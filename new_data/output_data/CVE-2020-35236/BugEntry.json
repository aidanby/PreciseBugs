{"buggy_code": ["import { Lokka } from 'lokka';\nimport { Transport } from './lokka-transport-http-retry';\nimport { propOr, replace, toUpper, pipe, toLower } from 'ramda';\nimport { createJWTWithoutUserId } from './jwt';\nimport { logger } from './local-logging';\n\ninterface Project {\n  slack: any;\n  name: string;\n  openshift: any;\n}\n\ninterface GroupPatch {\n  name?: string;\n}\n\ninterface UserPatch {\n  email?: string;\n  firstName?: string;\n  lastName?: string;\n  comment?: string;\n  gitlabId?: number;\n}\n\ninterface ProjectPatch {\n  name?: string;\n  gitUrl?: string;\n  subfolder?: string;\n  activesystemsdeploy?: string;\n  activesystemsremove?: string;\n  branches?: string;\n  productionenvironment?: string;\n  autoidle?: number;\n  storagecalc?: number;\n  pullrequests?: string;\n  openshift?: number;\n  openshiftprojectpattern?: string;\n  productionRoutes?: string;\n  standbyRoutes?: string;\n  productionEnvironment?: string;\n  standbyProductionEnvironment?: string;\n}\n\ninterface DeploymentPatch {\n  name?: number;\n  status?: string;\n  created?: string;\n  started?: string;\n  completed?: string;\n  environment?: number;\n  remoteId?: string;\n}\n\ninterface TaskPatch {\n  name?: number;\n  status?: string;\n  created?: string;\n  started?: string;\n  completed?: string;\n  environment?: number;\n  remoteId?: string;\n}\n\ninterface RestorePatch {\n  status?: string;\n  created?: string;\n  restoreLocation?: string;\n}\n\nenum EnvType {\n  PRODUCTION = 'production',\n  DEVELOPMENT = 'development'\n}\n\nconst { JWTSECRET, JWTAUDIENCE } = process.env;\nconst API_HOST = propOr('http://api:3000', 'API_HOST', process.env);\n\nif (JWTSECRET == null) {\n  logger.warn(\n    'No JWTSECRET env variable set... this will cause api requests to fail'\n  );\n}\n\nif (JWTAUDIENCE == null) {\n  logger.warn(\n    'No JWTAUDIENCE env variable set... this may cause api requests to fail'\n  );\n}\n\nconst apiAdminToken = createJWTWithoutUserId({\n  payload: {\n    role: 'admin',\n    iss: 'lagoon-commons',\n    aud: JWTAUDIENCE || 'api.amazee.io'\n  },\n  jwtSecret: JWTSECRET || ''\n});\n\nconst options = {\n  headers: {\n    Authorization: `Bearer ${apiAdminToken}`\n  },\n  timeout: 60000\n};\n\nconst transport = new Transport(`${API_HOST}/graphql`, options);\n\nexport const graphqlapi = new Lokka({ transport });\n\nclass ProjectNotFound extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'ProjectNotFound';\n  }\n}\n\nclass EnvironmentNotFound extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'EnvironmentNotFound';\n  }\n}\n\nclass NoActiveSystemsDefined extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'NoActiveSystemsDefined';\n  }\n}\n\nconst sshKeyFragment = graphqlapi.createFragment(`\nfragment on SshKey {\n  id\n  name\n  keyValue\n  keyType\n}\n`);\n\nconst userFragment = graphqlapi.createFragment(`\nfragment on User {\n  id\n  email\n  firstName\n  lastName\n  gitlabId\n  sshKeys {\n    id\n    name\n  }\n}\n`);\n\nconst groupFragment = graphqlapi.createFragment(`\nfragment on Group {\n  id\n  name\n}\n`);\n\nconst projectFragment = graphqlapi.createFragment(`\nfragment on Project {\n  id\n  name\n  gitUrl\n  privateKey\n}\n`);\n\nconst backupFragment = graphqlapi.createFragment(`\nfragment on Backup {\n  id\n  environment {\n    id\n  }\n  backupId\n  source\n  created\n}\n`);\n\nexport const addGroup = (name: string): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($name: String!) {\n    addGroup(input: {\n        name: $name\n    }) {\n      ...${groupFragment}\n    }\n  }\n`,\n    {\n      name\n    }\n  );\n\nexport const addGroupWithParent = (\n  name: string,\n  parentGroupName: string\n): Promise<any> =>\n  graphqlapi.mutate(\n    `\n    ($name: String!, $parentGroupName: String) {\n      addGroup(input: {\n          name: $name\n          parentGroup: { name: $parentGroupName }\n      }) {\n        ...${groupFragment}\n      }\n    }\n  `,\n    {\n      name,\n      parentGroupName\n    }\n  );\n\nexport const addBackup = (\n  id: number = null,\n  environment: number,\n  source: string,\n  backupId: string,\n  created: string\n): Promise<any> =>\n  graphqlapi.mutate(\n    `\n    ($id: Int, $environment: Int!, $source: String!, $backupId: String!, $created: String!) {\n      addBackup(input: {\n          id: $id\n          environment: $environment\n          source: $source\n          backupId: $backupId\n          created: $created\n      }) {\n        ...${backupFragment}\n      }\n    }\n  `,\n    {\n      id,\n      environment,\n      source,\n      backupId,\n      created\n    }\n  );\n\nexport const deleteBackup = (backupId: string): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($backupId: String!) {\n    deleteBackup(input: {\n      backupId: $backupId\n    })\n  }\n  `,\n    { backupId }\n  );\n\nconst restoreFragment = graphqlapi.createFragment(`\n  fragment on Restore {\n    id\n    status\n    created\n    restoreLocation\n    backupId\n  }\n  `);\n\nexport const updateRestore = (\n  backupId: string,\n  patch: RestorePatch\n): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($backupId: String!, $patch: UpdateRestorePatchInput!) {\n    updateRestore(input: {\n      backupId: $backupId\n      patch: $patch\n    }) {\n      ...${restoreFragment}\n    }\n  }\n`,\n    { backupId, patch }\n  );\n\nexport const getAllEnvironmentBackups = (): Promise<Project[]> =>\n  graphqlapi.query(\n    `\n  {\n    allEnvironments {\n      id\n      name\n      openshiftProjectName\n      project {\n        name\n      }\n      backups {\n        ...${backupFragment}\n      }\n    }\n  }\n`\n  );\n\nexport const getEnvironmentBackups = (\n  openshiftProjectName: string\n): Promise<any[]> =>\n  graphqlapi.query(\n    `\n  query environmentByOpenshiftProjectName($openshiftProjectName: String!) {\n    environmentByOpenshiftProjectName(openshiftProjectName: $openshiftProjectName) {\n      id\n      name\n      openshiftProjectName\n      project {\n        name\n      }\n      backups {\n        id\n        backupId\n        source\n        created\n      }\n    }\n  }\n`,\n    { openshiftProjectName }\n  );\n\nexport const updateGroup = (name: string, patch: GroupPatch): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($name: String!, $patch: UpdateGroupPatchInput!) {\n    updateGroup(input: {\n      group: {\n        name: $name\n      }\n      patch: $patch\n    }) {\n      ...${groupFragment}\n    }\n  }\n  `,\n    { name, patch }\n  );\n\nexport const deleteGroup = (name: string): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($name: String!) {\n    deleteGroup(input: {\n      group: {\n        name: $name\n      }\n    })\n  }\n  `,\n    { name }\n  );\n\nexport const getUserBySshKey = (sshKey: string): Promise<any> =>\n  graphqlapi.query(\n    `\n  query userBySshKey($sshKey: String!) {\n    userBySshKey(sshKey: $sshKey) {\n      ...${userFragment}\n    }\n  }\n`,\n    { sshKey }\n  );\n\nexport const addUser = (\n  email: string,\n  firstName: string = null,\n  lastName: string = null,\n  comment: string = null,\n  gitlabId: number = null\n): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($email: String!, $firstName: String, $lastName: String, $comment: String, $gitlabId: Int) {\n    addUser(input: {\n      email: $email\n      firstName: $firstName\n      lastName: $lastName\n      comment: $comment\n      gitlabId: $gitlabId\n    }) {\n      ...${userFragment}\n    }\n  }\n`,\n    {\n      email,\n      firstName,\n      lastName,\n      comment,\n      gitlabId\n    }\n  );\n\nexport const updateUser = (email: string, patch: UserPatch): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($email: String!, $patch: UpdateUserPatchInput!) {\n    updateUser(input: {\n      user: {\n        email: $email\n      }\n      patch: $patch\n    }) {\n      ...${userFragment}\n    }\n  }\n  `,\n    { email, patch }\n  );\n\nexport const deleteUser = (email: string): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($email: Int!) {\n    deleteUser(input: {\n      user: {\n        email: $email\n      }\n    })\n  }\n  `,\n    { email }\n  );\n\nexport const addUserToGroup = (\n  userEmail: string,\n  groupName: string,\n  role: string\n): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($userEmail: String!, $groupName: String!, $role: GroupRole!) {\n    addUserToGroup(input: {\n      user: { email: $userEmail }\n      group: { name: $groupName }\n      role: $role\n    }) {\n      ...${groupFragment}\n    }\n  }\n  `,\n    { userEmail, groupName, role }\n  );\n\nexport const addGroupToProject = (\n  project: string,\n  group: string\n): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($project: String!, $group: String!) {\n    addGroupsToProject(input: {\n      project: { name: $project}\n      groups: [{name: $group}]\n    }) {\n      ...${projectFragment}\n    }\n  }\n  `,\n    { project, group }\n  );\n\nexport const removeGroupFromProject = (\n  project: string,\n  group: string\n): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($project: String!, $group: String!) {\n    removeGroupsFromProject(input: {\n      project: { name: $project}\n      groups: [{name: $group}]\n    }) {\n      ...${projectFragment}\n    }\n  }\n  `,\n    { project, group }\n  );\n\nexport const removeUserFromGroup = (\n  userEmail: string,\n  groupName: string\n): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($userEmail: String!, $groupName: String!) {\n    removeUserFromGroup(input: {\n      user: { email: $userEmail }\n      group: { name: $groupName }\n    }) {\n      ...${groupFragment}\n    }\n  }\n  `,\n    { userEmail, groupName }\n  );\n\nexport const addSshKey = (\n  id: number = null,\n  name: string,\n  keyValue: string,\n  keyType: string,\n  userEmail: string\n): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($id: Int, $name: String!, $keyValue: String!, $keyType: SshKeyType!, $userEmail: String!) {\n    addSshKey(input: {\n      id: $id\n      name: $name\n      keyValue: $keyValue\n      keyType: $keyType\n      user: {\n        email: $userEmail\n      }\n    }) {\n      ...${sshKeyFragment}\n    }\n  }\n  `,\n    {\n      id,\n      name,\n      keyValue,\n      userEmail,\n      keyType\n    }\n  );\n\nexport const deleteSshKey = (name: string): Promise<any> =>\n  graphqlapi.mutate(\n    `\n    ($name: String!) {\n      deleteSshKey(input: {\n        name: $name\n      })\n    }\n    `,\n    {\n      name,\n    },\n  );\n\nexport const addProject = (\n  name: string,\n  gitUrl: string,\n  openshift: number,\n  productionenvironment: string,\n  id: number = null\n): Promise<any> =>\n  graphqlapi.mutate(\n    `\n    ($name: String!, $gitUrl: String!, $openshift: Int!, $productionenvironment: String!, $id: Int) {\n      addProject(input: {\n        name: $name,\n        gitUrl: $gitUrl,\n        openshift: $openshift,\n        productionEnvironment: $productionenvironment,\n        id: $id,\n      }) {\n        ...${projectFragment}\n      }\n    }\n  `,\n    {\n      name,\n      gitUrl,\n      openshift,\n      productionenvironment,\n      id\n    }\n  );\n\nexport const updateProject = (\n  id: number,\n  patch: ProjectPatch\n): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($id: Int!, $patch: UpdateProjectPatchInput!) {\n    updateProject(input: {\n      id: $id\n      patch: $patch\n    }) {\n      ...${projectFragment}\n    }\n  }\n  `,\n    { id, patch }\n  );\n\nexport const deleteProject = (name: string): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($name: String!) {\n    deleteProject(input: {\n      project: $name\n    })\n  }\n  `,\n    { name }\n  );\n\nexport async function getProjectsByGitUrl(gitUrl: string): Promise<Project[]> {\n  const result = await graphqlapi.query(`\n    {\n      allProjects(gitUrl: \"${gitUrl}\") {\n        name\n        productionEnvironment\n        openshift {\n          consoleUrl\n          token\n          projectUser\n          routerPattern\n        }\n      }\n    }\n  `);\n\n  if (!result || !result.allProjects || !result.allProjects.length) {\n    throw new ProjectNotFound(`Cannot find project for git repo ${gitUrl}`);\n  }\n\n  return result.allProjects;\n}\n\nexport async function getProjectByName(project: string): Promise<any> {\n  const result = await graphqlapi.query(`\n    {\n      project:projectByName(name: \"${project}\") {\n        ...${projectFragment}\n      }\n    }\n  `);\n\n  if (!result || !result.project) {\n    throw new ProjectNotFound(`Cannot find project ${project}`);\n  }\n\n  return result.project;\n}\n\nexport async function getMicrosoftTeamsInfoForProject(\n  project: string, contentType = 'DEPLOYMENT'\n): Promise<any[]> {\n  const notificationsFragment = graphqlapi.createFragment(`\n    fragment on NotificationMicrosoftTeams {\n      webhook\n      contentType\n      notificationSeverityThreshold\n    }\n  `);\n\n  const result = await graphqlapi.query(`\n    {\n      project:projectByName(name: \"${project}\") {\n        microsoftTeams: notifications(type: MICROSOFTTEAMS, contentType: ${contentType}) {\n          ...${notificationsFragment}\n        }\n      }\n    }\n  `);\n\n  if (!result || !result.project || !result.project.microsoftTeams) {\n    throw new ProjectNotFound(\n      `Cannot find Microsoft Teams information for project ${project}`\n    );\n  }\n\n  return result.project.microsoftTeams;\n}\n\nexport async function getRocketChatInfoForProject(\n  project: string, contentType = 'DEPLOYMENT'\n): Promise<any[]> {\n  const notificationsFragment = graphqlapi.createFragment(`\n    fragment on NotificationRocketChat {\n      webhook\n      channel\n      contentType\n      notificationSeverityThreshold\n    }\n  `);\n\n  const result = await graphqlapi.query(`\n    {\n      project:projectByName(name: \"${project}\") {\n        rocketchats: notifications(type: ROCKETCHAT, contentType: ${contentType}) {\n          ...${notificationsFragment}\n        }\n      }\n    }\n  `);\n\n  if (!result || !result.project || !result.project.rocketchats) {\n    throw new ProjectNotFound(\n      `Cannot find rocketchat information for project ${project}`\n    );\n  }\n\n  return result.project.rocketchats;\n}\n\nexport async function getSlackinfoForProject(\n  project: string, contentType = 'DEPLOYMENT'\n): Promise<Project> {\n  const notificationsFragment = graphqlapi.createFragment(`\n    fragment on NotificationSlack {\n      webhook\n      channel\n      contentType\n      notificationSeverityThreshold\n    }\n  `);\n\n  const result = await graphqlapi.query(`\n    {\n      project:projectByName(name: \"${project}\") {\n        slacks: notifications(type: SLACK, contentType: ${contentType}) {\n          ...${notificationsFragment}\n        }\n      }\n    }\n  `);\n\n  if (!result || !result.project || !result.project.slacks) {\n    throw new ProjectNotFound(\n      `Cannot find slack information for project ${project}`\n    );\n  }\n\n  return result.project.slacks;\n}\n\nexport async function getEmailInfoForProject(\n  project: string, contentType = 'DEPLOYMENT'\n): Promise<any[]> {\n  const notificationsFragment = graphqlapi.createFragment(`\n    fragment on NotificationEmail {\n      emailAddress\n      contentType\n      notificationSeverityThreshold\n    }\n  `);\n\n  const result = await graphqlapi.query(`\n    {\n      project:projectByName(name: \"${project}\") {\n        emails: notifications(type: EMAIL, contentType: ${contentType}) {\n          ...${notificationsFragment}\n        }\n      }\n    }\n  `);\n\n  if (!result || !result.project || !result.project.emails) {\n    throw new ProjectNotFound(\n      `Cannot find email information for project ${project}`\n    );\n  }\n\n  return result.project.emails;\n}\n\ninterface GetActiveSystemForProjectResult {\n  branches: string;\n  pullrequests: string;\n  activeSystemsDeploy: string;\n  activeSystemsPromote: string;\n  activeSystemsRemove: string;\n  activeSystemsTask: string;\n  activeSystemsMisc: string;\n}\n\nexport async function getActiveSystemForProject(\n  project: string,\n  task: 'Deploy' | 'Promote' | 'Remove' | 'Task' | 'Misc'\n): Promise<GetActiveSystemForProjectResult> {\n  const field = `activeSystems${task}`;\n  const result = await graphqlapi.query(`\n    {\n      project:projectByName(name: \"${project}\"){\n        activeSystemsDeploy\n        activeSystemsPromote\n        activeSystemsRemove\n        activeSystemsTask\n        activeSystemsMisc\n        branches\n        pullrequests\n      }\n    }\n  `);\n\n  if (!result || !result.project) {\n    throw new ProjectNotFound(\n      `Cannot find active-systems information for project ${project}`\n    );\n  }\n\n  if (!result.project[field]) {\n    throw new NoActiveSystemsDefined(\n      `Cannot find active system for task ${task} in project ${project}`\n    );\n  }\n\n  return result.project;\n}\n\nexport async function getEnvironmentByName(\n  name: string,\n  projectId: number\n): Promise<any> {\n  const result = await graphqlapi.query(`\n    {\n      environmentByName(name: \"${name}\", project:${projectId}) {\n        id,\n        name,\n        route,\n        routes,\n        deployType,\n        environmentType,\n        openshiftProjectName,\n        updated,\n        created,\n        deleted,\n      }\n    }\n  `);\n\n  if (!result || !result.environmentByName) {\n    throw new EnvironmentNotFound(\n      `Cannot find environment for projectId ${projectId}, name ${name}\\n${result.environmentByName}`\n    );\n  }\n\n  return result;\n}\n\nexport async function getDeploymentByName(\n  openshiftProjectName: string,\n  deploymentName: string,\n): Promise<any> {\n  const result = await graphqlapi.query(`\n    {\n      environment:environmentByOpenshiftProjectName( openshiftProjectName: \"${openshiftProjectName}\") {\n        id\n        name\n        openshiftProjectName\n        project {\n          id\n          name\n        }\n        deployments(name: \"${deploymentName}\") {\n          id\n          name\n          uiLink\n        }\n      }\n    }\n  `);\n\n  if (!result || !result.environment) {\n    throw new EnvironmentNotFound(\n      `Cannot find deployment ${deploymentName} by projectName ${openshiftProjectName}\\n${\n        result.environment\n      }`,\n    );\n  }\n\n  return result;\n}\n\nexport async function getEnvironmentByOpenshiftProjectName(\n  openshiftProjectName: string\n): Promise<any[]> {\n  const result = await graphqlapi.query(`\n    {\n      environmentByOpenshiftProjectName(openshiftProjectName: \"${openshiftProjectName}\") {\n        id,\n        name,\n        project {\n          name\n        }\n      }\n    }\n  `);\n\n  if (!result || !result.environmentByOpenshiftProjectName) {\n    throw new EnvironmentNotFound(\n      `Cannot find environment for OpenshiftProjectName ${openshiftProjectName}\\n${result.environmentByOpenshiftProjectName}`\n    );\n  }\n\n  return result;\n}\n\nexport const addOrUpdateEnvironment = (\n  name: string,\n  projectId: number,\n  deployType: string,\n  deployBaseRef: string,\n  environmentType: string,\n  openshiftProjectName: string,\n  deployHeadRef: string = null,\n  deployTitle: string = null\n): Promise<any> =>\n  graphqlapi.mutate(\n    `\n($name: String!, $project: Int!, $deployType: DeployType!, $deployBaseRef: String!, $deployHeadRef: String, $deployTitle: String, $environmentType: EnvType!, $openshiftProjectName: String!) {\n  addOrUpdateEnvironment(input: {\n    name: $name,\n    project: $project,\n    deployType: $deployType,\n    deployBaseRef: $deployBaseRef,\n    deployHeadRef: $deployHeadRef,\n    deployTitle: $deployTitle,\n    environmentType: $environmentType,\n    openshiftProjectName: $openshiftProjectName\n  }) {\n    id\n    name\n    project {\n      name\n    }\n    deployType\n    environmentType\n    openshiftProjectName\n    envVariables {\n      name\n      value\n      scope\n    }\n  }\n}\n`,\n    {\n      name,\n      project: projectId,\n      deployType,\n      deployBaseRef,\n      deployHeadRef,\n      deployTitle,\n      environmentType,\n      openshiftProjectName\n    }\n  );\n\nexport const updateEnvironment = (\n  environmentId: number,\n  patch: string\n): Promise<any> =>\n  graphqlapi.query(`\n    mutation {\n      updateEnvironment(input: {\n        id: ${environmentId},\n        patch: ${patch}\n      }) {\n        id\n        name\n      }\n    }\n  `);\n\nexport async function deleteEnvironment(\n  name: string,\n  project: string,\n  execute: boolean = true\n): Promise<any> {\n  return graphqlapi.mutate(\n    `\n  ($name: String!, $project: String!, $execute: Boolean) {\n    deleteEnvironment(input: {\n      name: $name\n      project: $project\n      execute: $execute\n    })\n  }\n  `,\n    {\n      name,\n      project,\n      execute\n    }\n  );\n}\n\nexport const getOpenShiftInfoForProject = (project: string): Promise<any> =>\n  graphqlapi.query(`\n    {\n      project:projectByName(name: \"${project}\"){\n        id\n        openshift  {\n          name\n          consoleUrl\n          token\n          projectUser\n          routerPattern\n          monitoringConfig\n        }\n        availability\n        gitUrl\n        privateKey\n        subfolder\n        openshiftProjectPattern\n        productionEnvironment\n        productionRoutes\n        productionAlias\n        standbyProductionEnvironment\n        standbyRoutes\n        standbyAlias\n        envVariables {\n          name\n          value\n          scope\n        }\n      }\n    }\n`);\n\nexport const getBillingGroupForProject = (project: string): Promise<any> =>\n  graphqlapi.query(`\n    {\n      project:projectByName(name: \"${project}\"){\n        groups {\n          ... on BillingGroup {\n            type\n            uptimeRobotStatusPageId\n          }\n        }\n      }\n    }\n`);\n\ninterface GetEnvironentsForProjectEnvironmentResult {\n  name: string;\n  environmentType: EnvType;\n}\n\ninterface GetEnvironentsForProjectProjectResult {\n  developmentEnvironmentsLimit: number;\n  productionEnvironment: string;\n  standbyProductionEnvironment: string;\n  environments: GetEnvironentsForProjectEnvironmentResult[];\n}\n\ninterface GetEnvironentsForProjectResult {\n  project: GetEnvironentsForProjectProjectResult\n}\n\nexport const getEnvironmentsForProject = (\n  project: string\n): Promise<GetEnvironentsForProjectResult> =>\n  graphqlapi.query(`\n  {\n    project:projectByName(name: \"${project}\"){\n      developmentEnvironmentsLimit\n      productionEnvironment\n      environments(includeDeleted:false) { name, environmentType }\n    }\n  }\n`);\n\nexport const getProductionEnvironmentForProject = (\n  project: string\n): Promise<any> =>\n  graphqlapi.query(`\n    {\n      project:projectByName(name: \"${project}\"){\n        productionEnvironment\n      }\n    }\n`);\n\nexport const setEnvironmentServices = (\n  environment: number,\n  services: string[]\n): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($environment: Int!, $services: [String]!) {\n    setEnvironmentServices(input: {\n      environment: $environment\n      services: $services\n    }) {\n      id\n      name\n    }\n  }\n  `,\n    { environment, services }\n  );\n\nconst deploymentFragment = graphqlapi.createFragment(`\nfragment on Deployment {\n  id\n  name\n  status\n  created\n  started\n  completed\n  remoteId\n  uiLink\n  environment {\n    name\n  }\n}\n`);\n\nexport const getDeploymentByRemoteId = (id: string): Promise<any> =>\n  graphqlapi.query(\n    `\n  query deploymentByRemoteId($id: String!) {\n    deploymentByRemoteId(id: $id) {\n      ...${deploymentFragment}\n    }\n  }\n`,\n    { id }\n  );\n\nexport const addDeployment = (\n  name: string,\n  status: string,\n  created: string,\n  environment: number,\n  remoteId: string = null,\n  id: number = null,\n  started: string = null,\n  completed: string = null\n): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($name: String!, $status: DeploymentStatusType!, $created: String!, $environment: Int!, $id: Int, $remoteId: String, $started: String, $completed: String) {\n    addDeployment(input: {\n        name: $name\n        status: $status\n        created: $created\n        environment: $environment\n        id: $id\n        remoteId: $remoteId\n        started: $started\n        completed: $completed\n    }) {\n      ...${deploymentFragment}\n    }\n  }\n`,\n    {\n      name,\n      status,\n      created,\n      environment,\n      id,\n      remoteId,\n      started,\n      completed\n    }\n  );\n\n  export const addTask = (\n    name,\n    status,\n    created,\n    environment,\n    remoteId = null,\n    id = null,\n    started = null,\n    completed = null,\n    service = null,\n    command = null,\n    execute = false,\n  ) =>\n    graphqlapi.mutate(\n      `\n    ($name: String!, $status: TaskStatusType!, $created: String!, $environment: Int!, $id: Int, $remoteId: String, $started: String, $completed: String, $service: String, $command: String, $execute: Boolean) {\n      addTask(input: {\n          name: $name\n          status: $status\n          created: $created\n          environment: $environment\n          id: $id\n          remoteId: $remoteId\n          started: $started\n          completed: $completed\n          service: $service\n          command: $command\n          execute: $execute\n      }) {\n        ...${taskFragment}\n      }\n    }\n  `,\n      {\n        name,\n        status,\n        created,\n        environment,\n        id,\n        remoteId,\n        started,\n        completed,\n        service,\n        command,\n        execute,\n      },\n    );\n\nexport const updateDeployment = (\n  id: number,\n  patch: DeploymentPatch\n): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($id: Int!, $patch: UpdateDeploymentPatchInput!) {\n    updateDeployment(input: {\n      id: $id\n      patch: $patch\n    }) {\n      ...${deploymentFragment}\n    }\n  }\n`,\n    { id, patch }\n  );\n\nconst taskFragment = graphqlapi.createFragment(`\nfragment on Task {\n  id\n  name\n  status\n  created\n  started\n  completed\n  remoteId\n  environment {\n    name\n  }\n}\n`);\n\nexport const updateTask = (id: number, patch: TaskPatch): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($id: Int!, $patch: UpdateTaskPatchInput!) {\n    updateTask(input: {\n      id: $id\n      patch: $patch\n    }) {\n      ...${taskFragment}\n    }\n  }\n`,\n    { id, patch }\n  );\n\nexport const sanitizeGroupName = pipe(\n  replace(/[^a-zA-Z0-9-]/g, '-'),\n  toLower\n);\nexport const sanitizeProjectName = pipe(\n  replace(/[^a-zA-Z0-9-]/g, '-'),\n  toLower\n);\n\nexport const getProjectsByGroupName = groupName =>\n  graphqlapi.query(\n    `query groupByName($name: String!) {\n    groupByName(name: $name) {\n      id\n      name\n      projects {\n        id\n        name\n        gitUrl\n      }\n    }\n  }`,\n    { name: groupName }\n  );\n\nexport const getGroupMembersByGroupName = groupName =>\n  graphqlapi.query(\n    `query groupByName($name: String!) {\n    groupByName(name: $name) {\n      id\n      name\n      members {\n        user {\n          id\n          email\n        }\n        role\n      }\n    }\n  }`,\n  { name: groupName }\n);\n\nexport const addProblem = ({\n  id = null,\n  environment,\n  identifier,\n  severity,\n  source,\n  severityScore,\n  data,\n  service,\n  associatedPackage,\n  description,\n  version,\n  fixedVersion,\n  links\n}) => {\n  return graphqlapi.mutate(\n  `($id: Int,\n    $environment: Int!,\n    $identifier: String!,\n    $severity: ProblemSeverityRating!,\n    $source: String!,\n    $severityScore: SeverityScore,\n    $data: String!,\n    $service: String,\n    $associatedPackage: String,\n    $description: String,\n    $version: String,\n    $fixedVersion: String,\n    $links: String) {\n    addProblem(input: {\n      id: $id\n      environment: $environment\n      identifier: $identifier\n      severity: $severity\n      source: $source\n      severityScore: $severityScore\n      data: $data\n      service: $service\n      associatedPackage: $associatedPackage\n      description: $description\n      version: $version\n      fixedVersion: $fixedVersion\n      links: $links\n    }) {\n      id\n      environment {\n        id\n      }\n      identifier\n      severity\n      source\n      severityScore\n      data\n      associatedPackage\n      description\n      version\n      fixedVersion\n      links\n    }\n  }`,\n  {\n    id,\n    environment,\n    identifier,\n    severity,\n    source,\n    severityScore,\n    data,\n    service,\n    associatedPackage,\n    description,\n    version,\n    fixedVersion,\n    links\n  },\n)};\n\nexport const deleteProblemsFromSource = (\n  environment,\n  source,\n  service\n) => {\n  return graphqlapi.mutate(\n    `($environment: Int!, $source: String!, $service: String!) {\n      deleteProblemsFromSource(input: {environment: $environment, source: $source, service: $service })\n    }\n    `,\n    {\n      environment,\n      source,\n      service\n    }\n  )};\n\nconst problemFragment = graphqlapi.createFragment(`\nfragment on Problem {\n  id\n  severity\n  severityScore\n  identifier\n  service\n  source\n  associatedPackage\n  description\n  links\n  version\n  fixedVersion\n  data\n  created\n  deleted\n} \n`);\n\nexport const getProblemsforProjectEnvironment = async (\n  environmentName,\n  project\n) => {\n  const response = await graphqlapi.query(\n    `query getProject($environmentName: String!, $project: Int!) {\n      environmentByName(name: $environmentName, project: $project) {\n        id\n        name\n        problems {\n          ...${problemFragment}\n        }\n      }\n    }`\n  ,\n  {\n    environmentName,\n    project\n  });\n  return response.environmentByName.problems;\n};\n\nexport const getProblemHarborScanMatches = () => graphqlapi.query(\n    `query getProblemHarborScanMatches {\n      allProblemHarborScanMatchers {\n        id\n        name\n        description\n        defaultLagoonProject\n        defaultLagoonEnvironment\n        defaultLagoonService\n        regex\n      }\n    }`\n);", "import axios from 'axios';\nimport { pathOr, propOr } from 'ramda';\n\nconst API_HOST = propOr('http://gitlab', 'GITLAB_API_HOST', process.env);\nconst API_TOKEN = propOr(\n  'personal access token',\n  'GITLAB_API_TOKEN',\n  process.env\n);\n\nconst options = {\n  baseURL: `${API_HOST}/api/v4/`,\n  timeout: 30000,\n  headers: {\n    'Private-Token': API_TOKEN\n  }\n};\n\nconst gitlabapi = axios.create(options);\n\nclass NetworkError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'NetworkError';\n  }\n}\n\nclass APIError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'GitLabAPIError';\n  }\n}\n\nconst getRequest = async (url: string): Promise<any> => {\n  try {\n    const response = await gitlabapi.get(url);\n    return response.data;\n  } catch (error) {\n    if (error.response) {\n      const errorMessage = pathOr(\n        error.message,\n        ['data', 'message'],\n        error.response\n      );\n      const errorString =\n        typeof errorMessage === 'string'\n          ? errorMessage\n          : JSON.stringify(errorMessage);\n\n      throw new APIError(errorString);\n    } else if (error.request) {\n      throw new NetworkError(error.message);\n    } else {\n      throw error;\n    }\n  }\n};\n\nconst postRequest = async (url: string, body: any): Promise<any> => {\n  try {\n    const response = await gitlabapi.post(url, body);\n    return response.data;\n  } catch (error) {\n    if (error.response) {\n      const errorMessage = pathOr(\n        error.message,\n        ['data', 'message'],\n        error.response\n      );\n      const errorString =\n        typeof errorMessage === 'string'\n          ? errorMessage\n          : JSON.stringify(errorMessage);\n\n      throw new APIError(errorString);\n    } else if (error.request) {\n      throw new NetworkError(error.message);\n    } else {\n      throw error;\n    }\n  }\n};\n\nconst getAllPagesRequest = async (url: string): Promise<any> => {\n  let page = 1;\n  let moreResults = true;\n  let results = [];\n\n  do {\n    try {\n      const response = await gitlabapi.get(url, {\n        params: {\n          per_page: 100,\n          page\n        }\n      });\n\n      if (response.data.length === 0) {\n        moreResults = false;\n      } else {\n        page++;\n        results = [...results, ...response.data];\n      }\n    } catch (error) {\n      if (error.response) {\n        const errorMessage = pathOr(\n          error.message,\n          ['data', 'message'],\n          error.response\n        );\n        const errorString =\n          typeof errorMessage === 'string'\n            ? errorMessage\n            : JSON.stringify(errorMessage);\n\n        throw new APIError(errorString);\n      } else if (error.request) {\n        throw new NetworkError(error.message);\n      } else {\n        throw error;\n      }\n    }\n  } while (moreResults);\n\n  return results;\n};\n\nexport const getUserByUsername = async (username: string): Promise<any> => {\n  try {\n    const response = await gitlabapi.get('users', {\n      params: {\n        username\n      }\n    });\n\n    if (response.data.length === 0) {\n      throw new APIError(`No user found with username: ${username}`);\n    }\n\n    return response.data[0];\n  } catch (error) {\n    if (error.response) {\n      const errorMessage = pathOr(\n        error.message,\n        ['data', 'message'],\n        error.response\n      );\n      const errorString =\n        typeof errorMessage === 'string'\n          ? errorMessage\n          : JSON.stringify(errorMessage);\n\n      throw new APIError(errorString);\n    } else if (error.request) {\n      throw new NetworkError(error.message);\n    } else {\n      throw error;\n    }\n  }\n};\n\nexport const getAllGroups = async () => getAllPagesRequest('groups');\nexport const getGroup = async (groupId: number): Promise<any> =>\n  getRequest(`groups/${groupId}`);\nexport const getGroupMembers = async (groupId: number): Promise<any> =>\n  getRequest(`groups/${groupId}/members`);\nexport const getAllProjects = async (): Promise<any> =>\n  getAllPagesRequest('projects');\nexport const getProject = async (projectId: number): Promise<any> =>\n  getRequest(`projects/${projectId}`);\nexport const getProjectMembers = async (projectId: number): Promise<any> =>\n  getRequest(`projects/${projectId}/members`);\nexport const getAllUsers = async () => getAllPagesRequest('users');\nexport const getUser = async (userId: number): Promise<any> =>\n  getRequest(`users/${userId}`);\nexport const getSshKey = async (keyId: number): Promise<any> =>\n  getRequest(`keys/${keyId}`);\n\nexport const addDeployKeyToProject = async (\n  projectId: number,\n  key: string\n): Promise<any> =>\n  postRequest(`projects/${projectId}/deploy_keys`, {\n    title: 'Lagoon Project Key',\n    key,\n    can_push: false\n  });\n", "import uuid4 from 'uuid4';\nimport url from 'url';\nimport R from 'ramda';\nimport { IncomingMessage } from 'http';\n\nimport type { RawData, WebhookRequestData } from './types';\n\n/**\n * This function will check request headers for\n * service specific data like github / gitlab / etc.\n * if the request method is POST.\n *\n * Will eventually generate 'custom' webhook data on\n * GET requests.\n *\n * Will throw an error on malformed request headers,\n * non-json body data or unsupported method.\n */\nexport function extractWebhookData(req: IncomingMessage, body: string): WebhookRequestData {\n  const { method, headers } = req;\n\n  let parameters: any = {};\n  let webhooktype;\n  let event;\n  let uuid;\n  let bodyObj: RawData;\n  let giturl;\n\n  if (method === 'POST') {\n    try {\n      bodyObj = body == null || body === '' ? {} : JSON.parse(body);\n    } catch (e) {\n      throw new Error(`Request body is not parsable as JSON. Are you sure you have enabled application/json as the webhook content type? ${e}.`);\n    }\n\n    if ('x-github-event' in req.headers) {\n      webhooktype = 'github';\n      event = req.headers['x-github-event'];\n      uuid = req.headers['x-github-delivery'];\n      giturl = R.path(['repository', 'ssh_url'], bodyObj);\n    } else if ('x-gitlab-event' in req.headers) {\n      webhooktype = 'gitlab';\n      event = bodyObj.object_kind || bodyObj.event_name;\n      uuid = uuid4();\n      giturl = R.path(['project', 'git_ssh_url'], bodyObj);\n\n      // This is a system webhook\n      if (!giturl) {\n        // Ensure the system hook came from gitlab\n        if (!('x-gitlab-token' in req.headers) || req.headers['x-gitlab-token'] !== process.env.GITLAB_SYSTEM_HOOK_TOKEN) {\n          throw new Error('Gitlab system hook secret verification failed');\n        }\n      }\n    } else if ('x-event-key' in req.headers) {\n      webhooktype = 'bitbucket'\n      event = req.headers['x-event-key']\n      uuid = req.headers['x-request-uuid']\n      // Bitbucket does not provide a git-ssh URI to the repo in the webhook payload\n      // We the html repo link (example https://bitbucket.org/teamawesome/repository) to extract the correct target domain (bitbucket.org)\n      // this could be bitbuck.org(.com) or a private bitbucket server\n      // Also the git server could be running on another port than 22, so there is a second regex match for `:[0-9]`\n      const regexmatch = bodyObj.repository.links.html.href.match(/https?:\\/\\/([a-z0-9-_.]*)(:[0-9]*)?\\//i)\n      // The first match is the domain\n      const domain = regexmatch[1]\n      if (!regexmatch[2]) {\n        // If there is no 2nd regex match, ther is no port found and it's not added to the URL\n        // use the extracted domain and repo full_name (teamawesome/repository) to build the git URI, example git@bitbucket.org:teamawesome/repository.git\n        giturl = `git@${domain}:${bodyObj.repository.full_name}.git`\n      } else {\n        // If there is a second regex match, we add the port to the url and also format the url with `ssh://` in front which is needed for requests with anoter port\n        const port = regexmatch[2]\n        giturl = `ssh://git@${domain}${port}/${bodyObj.repository.full_name}.git`\n      }\n    // TODO: Use when single snapshot data is fixed\n    // } else if (bodyObj.backup_metrics) {\n    //   webhooktype = 'resticbackup';\n    //   event = 'snapshot:finished'\n    //   uuid = uuid4();\n    } else if (bodyObj.snapshots) {\n      webhooktype = 'resticbackup';\n      event = 'snapshot:sync'\n      uuid = uuid4();\n    } else if (bodyObj.restore_location) {\n      webhooktype = 'resticbackup';\n      event = 'restore:finished';\n      uuid = uuid4();\n    } else if (bodyObj.type && bodyObj.type == 'scanningCompleted') {\n      webhooktype = 'problems';\n      event = 'harbor:scanningcompleted';\n      uuid = uuid4();\n    } else if (bodyObj.lagoonInfo) {\n      webhooktype = 'problems';\n      event = 'drutiny:resultset';\n      uuid = uuid4();\n    } else {\n      throw new Error('No supported event header found on POST request');\n    }\n  } else if (method === 'GET') {\n    try {\n      webhooktype = 'custom';\n      event = 'push';\n      uuid = uuid4();\n\n      const parsedUrl = url.parse(req.url, true); // true to get query as object\n      const { query = {} } = parsedUrl;\n\n      // TODO: Potential for refactor\n      const getParam = (name: string, shouldThrow: boolean = false): string => {\n        const value = query[name];\n        if (value == null && shouldThrow) {\n          throw new Error(`Query param '${name}' not found!`);\n        }\n        if (value === '' && shouldThrow) {\n          throw new Error(`Query param '${name}' is empty!`);\n        }\n        // @ts-ignore\n        return value;\n      };\n\n      giturl = req.url;\n      parameters.url = getParam('url', true);\n      parameters.branch = getParam('branch', true);\n      parameters.sha = getParam('sha') || '';\n      bodyObj = parameters;\n    } catch (e) {\n      throw new Error(`Error in handling GET request: ${e.message}`);\n    }\n  } else {\n    throw new Error(`Unsupported request method: ${method}`);\n  }\n\n  const ret: WebhookRequestData = {\n    webhooktype,\n    event,\n    body: bodyObj\n  };\n\n  if (giturl != null) {\n    ret.giturl = giturl;\n  }\n\n  if (uuid != null) {\n    ret.uuid = uuid;\n  }\n\n  return ret;\n}\n", "import { sendToLagoonLogs } from '@lagoon/commons/dist/logs';\nimport { deleteProject } from '@lagoon/commons/dist/api';\n\nimport { WebhookRequestData } from '../types';\n\nexport async function gitlabProjectDelete(webhook: WebhookRequestData) {\n  const {\n    webhooktype,\n    event,\n    uuid,\n    body,\n    body: { path: name }\n  } = webhook;\n\n  try {\n    const meta = {\n      project: name\n    };\n\n    await deleteProject(name);\n\n    sendToLagoonLogs(\n      'info',\n      '',\n      uuid,\n      `${webhooktype}:${event}:handled`,\n      meta,\n      `deleted project ${name}`\n    );\n\n    return;\n  } catch (error) {\n    sendToLagoonLogs(\n      'error',\n      '',\n      uuid,\n      `${webhooktype}:${event}:unhandled`,\n      { data: body },\n      `Could not delete project, reason: ${error}`\n    );\n\n    return;\n  }\n}\n", "import { ChannelWrapper } from 'amqp-connection-manager';\nimport { ConsumeMessage } from 'amqplib';\nimport { processProjects } from './webhooks/projects';\nimport { processDataSync } from './webhooks/dataSync';\nimport { processBackup } from './webhooks/backup';\nimport { processProblems } from './webhooks/problems';\nimport { WebhookRequestData } from './types';\n\nexport async function processQueue (rabbitMsg: ConsumeMessage, channelWrapperWebhooks: ChannelWrapper): Promise<void> {\n  const webhook: WebhookRequestData = JSON.parse(rabbitMsg.content.toString())\n\n  const {\n    webhooktype,\n    giturl,\n  } = webhook;\n\n  // GitLab supports System Hooks which trigger on changes like creating new\n  // organizations or users. Since these don't have associated projects, they\n  // must be handled separately.\n  if (webhooktype == 'gitlab' && !giturl) {\n    processDataSync(rabbitMsg, channelWrapperWebhooks);\n  } else if (webhooktype == 'resticbackup') {\n    processBackup(rabbitMsg, channelWrapperWebhooks);\n  } else if (webhooktype == 'problems') {\n    processProblems(rabbitMsg, channelWrapperWebhooks);\n  }\n  else {\n    processProjects(rabbitMsg, channelWrapperWebhooks);\n  }\n}\n"], "fixing_code": ["import { Lokka } from 'lokka';\nimport { Transport } from './lokka-transport-http-retry';\nimport { propOr, replace, toUpper, pipe, toLower } from 'ramda';\nimport { createJWTWithoutUserId } from './jwt';\nimport { logger } from './local-logging';\n\ninterface Project {\n  slack: any;\n  name: string;\n  openshift: any;\n}\n\ninterface GroupPatch {\n  name?: string;\n}\n\ninterface UserPatch {\n  email?: string;\n  firstName?: string;\n  lastName?: string;\n  comment?: string;\n  gitlabId?: number;\n}\n\ninterface ProjectPatch {\n  name?: string;\n  gitUrl?: string;\n  subfolder?: string;\n  activesystemsdeploy?: string;\n  activesystemsremove?: string;\n  branches?: string;\n  productionenvironment?: string;\n  autoidle?: number;\n  storagecalc?: number;\n  pullrequests?: string;\n  openshift?: number;\n  openshiftprojectpattern?: string;\n  productionRoutes?: string;\n  standbyRoutes?: string;\n  productionEnvironment?: string;\n  standbyProductionEnvironment?: string;\n}\n\ninterface DeploymentPatch {\n  name?: number;\n  status?: string;\n  created?: string;\n  started?: string;\n  completed?: string;\n  environment?: number;\n  remoteId?: string;\n}\n\ninterface TaskPatch {\n  name?: number;\n  status?: string;\n  created?: string;\n  started?: string;\n  completed?: string;\n  environment?: number;\n  remoteId?: string;\n}\n\ninterface RestorePatch {\n  status?: string;\n  created?: string;\n  restoreLocation?: string;\n}\n\nenum EnvType {\n  PRODUCTION = 'production',\n  DEVELOPMENT = 'development'\n}\n\nconst { JWTSECRET, JWTAUDIENCE } = process.env;\nconst API_HOST = propOr('http://api:3000', 'API_HOST', process.env);\n\nif (JWTSECRET == null) {\n  logger.warn(\n    'No JWTSECRET env variable set... this will cause api requests to fail'\n  );\n}\n\nif (JWTAUDIENCE == null) {\n  logger.warn(\n    'No JWTAUDIENCE env variable set... this may cause api requests to fail'\n  );\n}\n\nconst apiAdminToken = createJWTWithoutUserId({\n  payload: {\n    role: 'admin',\n    iss: 'lagoon-commons',\n    aud: JWTAUDIENCE || 'api.amazee.io'\n  },\n  jwtSecret: JWTSECRET || ''\n});\n\nconst options = {\n  headers: {\n    Authorization: `Bearer ${apiAdminToken}`\n  },\n  timeout: 60000\n};\n\nconst transport = new Transport(`${API_HOST}/graphql`, options);\n\nexport const graphqlapi = new Lokka({ transport });\n\nclass ProjectNotFound extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'ProjectNotFound';\n  }\n}\n\nclass EnvironmentNotFound extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'EnvironmentNotFound';\n  }\n}\n\nclass NoActiveSystemsDefined extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'NoActiveSystemsDefined';\n  }\n}\n\nconst sshKeyFragment = graphqlapi.createFragment(`\nfragment on SshKey {\n  id\n  name\n  keyValue\n  keyType\n}\n`);\n\nconst userFragment = graphqlapi.createFragment(`\nfragment on User {\n  id\n  email\n  firstName\n  lastName\n  gitlabId\n  sshKeys {\n    id\n    name\n  }\n}\n`);\n\nconst groupFragment = graphqlapi.createFragment(`\nfragment on Group {\n  id\n  name\n}\n`);\n\nconst projectFragment = graphqlapi.createFragment(`\nfragment on Project {\n  id\n  name\n  gitUrl\n  privateKey\n}\n`);\n\nconst backupFragment = graphqlapi.createFragment(`\nfragment on Backup {\n  id\n  environment {\n    id\n  }\n  backupId\n  source\n  created\n}\n`);\n\nexport const addGroup = (name: string): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($name: String!) {\n    addGroup(input: {\n        name: $name\n    }) {\n      ...${groupFragment}\n    }\n  }\n`,\n    {\n      name\n    }\n  );\n\nexport const addGroupWithParent = (\n  name: string,\n  parentGroupName: string\n): Promise<any> =>\n  graphqlapi.mutate(\n    `\n    ($name: String!, $parentGroupName: String) {\n      addGroup(input: {\n          name: $name\n          parentGroup: { name: $parentGroupName }\n      }) {\n        ...${groupFragment}\n      }\n    }\n  `,\n    {\n      name,\n      parentGroupName\n    }\n  );\n\nexport const addBackup = (\n  id: number = null,\n  environment: number,\n  source: string,\n  backupId: string,\n  created: string\n): Promise<any> =>\n  graphqlapi.mutate(\n    `\n    ($id: Int, $environment: Int!, $source: String!, $backupId: String!, $created: String!) {\n      addBackup(input: {\n          id: $id\n          environment: $environment\n          source: $source\n          backupId: $backupId\n          created: $created\n      }) {\n        ...${backupFragment}\n      }\n    }\n  `,\n    {\n      id,\n      environment,\n      source,\n      backupId,\n      created\n    }\n  );\n\nexport const deleteBackup = (backupId: string): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($backupId: String!) {\n    deleteBackup(input: {\n      backupId: $backupId\n    })\n  }\n  `,\n    { backupId }\n  );\n\nconst restoreFragment = graphqlapi.createFragment(`\n  fragment on Restore {\n    id\n    status\n    created\n    restoreLocation\n    backupId\n  }\n  `);\n\nexport const updateRestore = (\n  backupId: string,\n  patch: RestorePatch\n): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($backupId: String!, $patch: UpdateRestorePatchInput!) {\n    updateRestore(input: {\n      backupId: $backupId\n      patch: $patch\n    }) {\n      ...${restoreFragment}\n    }\n  }\n`,\n    { backupId, patch }\n  );\n\nexport const getAllEnvironmentBackups = (): Promise<Project[]> =>\n  graphqlapi.query(\n    `\n  {\n    allEnvironments {\n      id\n      name\n      openshiftProjectName\n      project {\n        name\n      }\n      backups {\n        ...${backupFragment}\n      }\n    }\n  }\n`\n  );\n\nexport const getEnvironmentBackups = (\n  openshiftProjectName: string\n): Promise<any[]> =>\n  graphqlapi.query(\n    `\n  query environmentByOpenshiftProjectName($openshiftProjectName: String!) {\n    environmentByOpenshiftProjectName(openshiftProjectName: $openshiftProjectName) {\n      id\n      name\n      openshiftProjectName\n      project {\n        name\n      }\n      backups {\n        id\n        backupId\n        source\n        created\n      }\n    }\n  }\n`,\n    { openshiftProjectName }\n  );\n\nexport const updateGroup = (name: string, patch: GroupPatch): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($name: String!, $patch: UpdateGroupPatchInput!) {\n    updateGroup(input: {\n      group: {\n        name: $name\n      }\n      patch: $patch\n    }) {\n      ...${groupFragment}\n    }\n  }\n  `,\n    { name, patch }\n  );\n\nexport const deleteGroup = (name: string): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($name: String!) {\n    deleteGroup(input: {\n      group: {\n        name: $name\n      }\n    })\n  }\n  `,\n    { name }\n  );\n\nexport const getUserBySshKey = (sshKey: string): Promise<any> =>\n  graphqlapi.query(\n    `\n  query userBySshKey($sshKey: String!) {\n    userBySshKey(sshKey: $sshKey) {\n      ...${userFragment}\n    }\n  }\n`,\n    { sshKey }\n  );\n\nexport const addUser = (\n  email: string,\n  firstName: string = null,\n  lastName: string = null,\n  comment: string = null,\n  gitlabId: number = null\n): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($email: String!, $firstName: String, $lastName: String, $comment: String, $gitlabId: Int) {\n    addUser(input: {\n      email: $email\n      firstName: $firstName\n      lastName: $lastName\n      comment: $comment\n      gitlabId: $gitlabId\n    }) {\n      ...${userFragment}\n    }\n  }\n`,\n    {\n      email,\n      firstName,\n      lastName,\n      comment,\n      gitlabId\n    }\n  );\n\nexport const updateUser = (email: string, patch: UserPatch): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($email: String!, $patch: UpdateUserPatchInput!) {\n    updateUser(input: {\n      user: {\n        email: $email\n      }\n      patch: $patch\n    }) {\n      ...${userFragment}\n    }\n  }\n  `,\n    { email, patch }\n  );\n\nexport const deleteUser = (email: string): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($email: Int!) {\n    deleteUser(input: {\n      user: {\n        email: $email\n      }\n    })\n  }\n  `,\n    { email }\n  );\n\nexport const addUserToGroup = (\n  userEmail: string,\n  groupName: string,\n  role: string\n): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($userEmail: String!, $groupName: String!, $role: GroupRole!) {\n    addUserToGroup(input: {\n      user: { email: $userEmail }\n      group: { name: $groupName }\n      role: $role\n    }) {\n      ...${groupFragment}\n    }\n  }\n  `,\n    { userEmail, groupName, role }\n  );\n\nexport const addGroupToProject = (\n  project: string,\n  group: string\n): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($project: String!, $group: String!) {\n    addGroupsToProject(input: {\n      project: { name: $project}\n      groups: [{name: $group}]\n    }) {\n      ...${projectFragment}\n    }\n  }\n  `,\n    { project, group }\n  );\n\nexport const removeGroupFromProject = (\n  project: string,\n  group: string\n): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($project: String!, $group: String!) {\n    removeGroupsFromProject(input: {\n      project: { name: $project}\n      groups: [{name: $group}]\n    }) {\n      ...${projectFragment}\n    }\n  }\n  `,\n    { project, group }\n  );\n\nexport const removeUserFromGroup = (\n  userEmail: string,\n  groupName: string\n): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($userEmail: String!, $groupName: String!) {\n    removeUserFromGroup(input: {\n      user: { email: $userEmail }\n      group: { name: $groupName }\n    }) {\n      ...${groupFragment}\n    }\n  }\n  `,\n    { userEmail, groupName }\n  );\n\nexport const addSshKey = (\n  id: number = null,\n  name: string,\n  keyValue: string,\n  keyType: string,\n  userEmail: string\n): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($id: Int, $name: String!, $keyValue: String!, $keyType: SshKeyType!, $userEmail: String!) {\n    addSshKey(input: {\n      id: $id\n      name: $name\n      keyValue: $keyValue\n      keyType: $keyType\n      user: {\n        email: $userEmail\n      }\n    }) {\n      ...${sshKeyFragment}\n    }\n  }\n  `,\n    {\n      id,\n      name,\n      keyValue,\n      userEmail,\n      keyType\n    }\n  );\n\nexport const deleteSshKey = (name: string): Promise<any> =>\n  graphqlapi.mutate(\n    `\n    ($name: String!) {\n      deleteSshKey(input: {\n        name: $name\n      })\n    }\n    `,\n    {\n      name,\n    },\n  );\n\nexport const addProject = (\n  name: string,\n  gitUrl: string,\n  openshift: number,\n  productionenvironment: string,\n  id: number = null\n): Promise<any> =>\n  graphqlapi.mutate(\n    `\n    ($name: String!, $gitUrl: String!, $openshift: Int!, $productionenvironment: String!, $id: Int) {\n      addProject(input: {\n        name: $name,\n        gitUrl: $gitUrl,\n        openshift: $openshift,\n        productionEnvironment: $productionenvironment,\n        id: $id,\n      }) {\n        ...${projectFragment}\n      }\n    }\n  `,\n    {\n      name,\n      gitUrl,\n      openshift,\n      productionenvironment,\n      id\n    }\n  );\n\nexport const updateProject = (\n  id: number,\n  patch: ProjectPatch\n): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($id: Int!, $patch: UpdateProjectPatchInput!) {\n    updateProject(input: {\n      id: $id\n      patch: $patch\n    }) {\n      ...${projectFragment}\n    }\n  }\n  `,\n    { id, patch }\n  );\n\nexport const deleteProject = (name: string): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($name: String!) {\n    deleteProject(input: {\n      project: $name\n    })\n  }\n  `,\n    { name }\n  );\n\nexport async function getProjectsByGitUrl(gitUrl: string): Promise<Project[]> {\n  const result = await graphqlapi.query(`\n    {\n      allProjects(gitUrl: \"${gitUrl}\") {\n        name\n        productionEnvironment\n        openshift {\n          consoleUrl\n          token\n          projectUser\n          routerPattern\n        }\n      }\n    }\n  `);\n\n  if (!result || !result.allProjects || !result.allProjects.length) {\n    throw new ProjectNotFound(`Cannot find project for git repo ${gitUrl}`);\n  }\n\n  return result.allProjects;\n}\n\nexport async function getProjectByName(project: string): Promise<any> {\n  const result = await graphqlapi.query(`\n    {\n      project:projectByName(name: \"${project}\") {\n        ...${projectFragment}\n      }\n    }\n  `);\n\n  if (!result || !result.project) {\n    throw new ProjectNotFound(`Cannot find project ${project}`);\n  }\n\n  return result.project;\n}\n\nexport const allProjectsInGroup = (groupInput: {\n  id?: string;\n  name?: string;\n}): Promise<any[]> =>\n  graphqlapi.query(\n    `\n    query($groupInput: GroupInput!) {\n      allProjectsInGroup(input: $groupInput) {\n        ...${projectFragment}\n      }\n    }\n  `,\n    {\n      groupInput\n    }\n  );\n\nexport async function getMicrosoftTeamsInfoForProject(\n  project: string, contentType = 'DEPLOYMENT'\n): Promise<any[]> {\n  const notificationsFragment = graphqlapi.createFragment(`\n    fragment on NotificationMicrosoftTeams {\n      webhook\n      contentType\n      notificationSeverityThreshold\n    }\n  `);\n\n  const result = await graphqlapi.query(`\n    {\n      project:projectByName(name: \"${project}\") {\n        microsoftTeams: notifications(type: MICROSOFTTEAMS, contentType: ${contentType}) {\n          ...${notificationsFragment}\n        }\n      }\n    }\n  `);\n\n  if (!result || !result.project || !result.project.microsoftTeams) {\n    throw new ProjectNotFound(\n      `Cannot find Microsoft Teams information for project ${project}`\n    );\n  }\n\n  return result.project.microsoftTeams;\n}\n\nexport async function getRocketChatInfoForProject(\n  project: string, contentType = 'DEPLOYMENT'\n): Promise<any[]> {\n  const notificationsFragment = graphqlapi.createFragment(`\n    fragment on NotificationRocketChat {\n      webhook\n      channel\n      contentType\n      notificationSeverityThreshold\n    }\n  `);\n\n  const result = await graphqlapi.query(`\n    {\n      project:projectByName(name: \"${project}\") {\n        rocketchats: notifications(type: ROCKETCHAT, contentType: ${contentType}) {\n          ...${notificationsFragment}\n        }\n      }\n    }\n  `);\n\n  if (!result || !result.project || !result.project.rocketchats) {\n    throw new ProjectNotFound(\n      `Cannot find rocketchat information for project ${project}`\n    );\n  }\n\n  return result.project.rocketchats;\n}\n\nexport async function getSlackinfoForProject(\n  project: string, contentType = 'DEPLOYMENT'\n): Promise<Project> {\n  const notificationsFragment = graphqlapi.createFragment(`\n    fragment on NotificationSlack {\n      webhook\n      channel\n      contentType\n      notificationSeverityThreshold\n    }\n  `);\n\n  const result = await graphqlapi.query(`\n    {\n      project:projectByName(name: \"${project}\") {\n        slacks: notifications(type: SLACK, contentType: ${contentType}) {\n          ...${notificationsFragment}\n        }\n      }\n    }\n  `);\n\n  if (!result || !result.project || !result.project.slacks) {\n    throw new ProjectNotFound(\n      `Cannot find slack information for project ${project}`\n    );\n  }\n\n  return result.project.slacks;\n}\n\nexport async function getEmailInfoForProject(\n  project: string, contentType = 'DEPLOYMENT'\n): Promise<any[]> {\n  const notificationsFragment = graphqlapi.createFragment(`\n    fragment on NotificationEmail {\n      emailAddress\n      contentType\n      notificationSeverityThreshold\n    }\n  `);\n\n  const result = await graphqlapi.query(`\n    {\n      project:projectByName(name: \"${project}\") {\n        emails: notifications(type: EMAIL, contentType: ${contentType}) {\n          ...${notificationsFragment}\n        }\n      }\n    }\n  `);\n\n  if (!result || !result.project || !result.project.emails) {\n    throw new ProjectNotFound(\n      `Cannot find email information for project ${project}`\n    );\n  }\n\n  return result.project.emails;\n}\n\ninterface GetActiveSystemForProjectResult {\n  branches: string;\n  pullrequests: string;\n  activeSystemsDeploy: string;\n  activeSystemsPromote: string;\n  activeSystemsRemove: string;\n  activeSystemsTask: string;\n  activeSystemsMisc: string;\n}\n\nexport async function getActiveSystemForProject(\n  project: string,\n  task: 'Deploy' | 'Promote' | 'Remove' | 'Task' | 'Misc'\n): Promise<GetActiveSystemForProjectResult> {\n  const field = `activeSystems${task}`;\n  const result = await graphqlapi.query(`\n    {\n      project:projectByName(name: \"${project}\"){\n        activeSystemsDeploy\n        activeSystemsPromote\n        activeSystemsRemove\n        activeSystemsTask\n        activeSystemsMisc\n        branches\n        pullrequests\n      }\n    }\n  `);\n\n  if (!result || !result.project) {\n    throw new ProjectNotFound(\n      `Cannot find active-systems information for project ${project}`\n    );\n  }\n\n  if (!result.project[field]) {\n    throw new NoActiveSystemsDefined(\n      `Cannot find active system for task ${task} in project ${project}`\n    );\n  }\n\n  return result.project;\n}\n\nexport async function getEnvironmentByName(\n  name: string,\n  projectId: number\n): Promise<any> {\n  const result = await graphqlapi.query(`\n    {\n      environmentByName(name: \"${name}\", project:${projectId}) {\n        id,\n        name,\n        route,\n        routes,\n        deployType,\n        environmentType,\n        openshiftProjectName,\n        updated,\n        created,\n        deleted,\n      }\n    }\n  `);\n\n  if (!result || !result.environmentByName) {\n    throw new EnvironmentNotFound(\n      `Cannot find environment for projectId ${projectId}, name ${name}\\n${result.environmentByName}`\n    );\n  }\n\n  return result;\n}\n\nexport async function getDeploymentByName(\n  openshiftProjectName: string,\n  deploymentName: string,\n): Promise<any> {\n  const result = await graphqlapi.query(`\n    {\n      environment:environmentByOpenshiftProjectName( openshiftProjectName: \"${openshiftProjectName}\") {\n        id\n        name\n        openshiftProjectName\n        project {\n          id\n          name\n        }\n        deployments(name: \"${deploymentName}\") {\n          id\n          name\n          uiLink\n        }\n      }\n    }\n  `);\n\n  if (!result || !result.environment) {\n    throw new EnvironmentNotFound(\n      `Cannot find deployment ${deploymentName} by projectName ${openshiftProjectName}\\n${\n        result.environment\n      }`,\n    );\n  }\n\n  return result;\n}\n\nexport async function getEnvironmentByOpenshiftProjectName(\n  openshiftProjectName: string\n): Promise<any[]> {\n  const result = await graphqlapi.query(`\n    {\n      environmentByOpenshiftProjectName(openshiftProjectName: \"${openshiftProjectName}\") {\n        id,\n        name,\n        project {\n          name\n        }\n      }\n    }\n  `);\n\n  if (!result || !result.environmentByOpenshiftProjectName) {\n    throw new EnvironmentNotFound(\n      `Cannot find environment for OpenshiftProjectName ${openshiftProjectName}\\n${result.environmentByOpenshiftProjectName}`\n    );\n  }\n\n  return result;\n}\n\nexport const addOrUpdateEnvironment = (\n  name: string,\n  projectId: number,\n  deployType: string,\n  deployBaseRef: string,\n  environmentType: string,\n  openshiftProjectName: string,\n  deployHeadRef: string = null,\n  deployTitle: string = null\n): Promise<any> =>\n  graphqlapi.mutate(\n    `\n($name: String!, $project: Int!, $deployType: DeployType!, $deployBaseRef: String!, $deployHeadRef: String, $deployTitle: String, $environmentType: EnvType!, $openshiftProjectName: String!) {\n  addOrUpdateEnvironment(input: {\n    name: $name,\n    project: $project,\n    deployType: $deployType,\n    deployBaseRef: $deployBaseRef,\n    deployHeadRef: $deployHeadRef,\n    deployTitle: $deployTitle,\n    environmentType: $environmentType,\n    openshiftProjectName: $openshiftProjectName\n  }) {\n    id\n    name\n    project {\n      name\n    }\n    deployType\n    environmentType\n    openshiftProjectName\n    envVariables {\n      name\n      value\n      scope\n    }\n  }\n}\n`,\n    {\n      name,\n      project: projectId,\n      deployType,\n      deployBaseRef,\n      deployHeadRef,\n      deployTitle,\n      environmentType,\n      openshiftProjectName\n    }\n  );\n\nexport const updateEnvironment = (\n  environmentId: number,\n  patch: string\n): Promise<any> =>\n  graphqlapi.query(`\n    mutation {\n      updateEnvironment(input: {\n        id: ${environmentId},\n        patch: ${patch}\n      }) {\n        id\n        name\n      }\n    }\n  `);\n\nexport async function deleteEnvironment(\n  name: string,\n  project: string,\n  execute: boolean = true\n): Promise<any> {\n  return graphqlapi.mutate(\n    `\n  ($name: String!, $project: String!, $execute: Boolean) {\n    deleteEnvironment(input: {\n      name: $name\n      project: $project\n      execute: $execute\n    })\n  }\n  `,\n    {\n      name,\n      project,\n      execute\n    }\n  );\n}\n\nexport const getOpenShiftInfoForProject = (project: string): Promise<any> =>\n  graphqlapi.query(`\n    {\n      project:projectByName(name: \"${project}\"){\n        id\n        openshift  {\n          name\n          consoleUrl\n          token\n          projectUser\n          routerPattern\n          monitoringConfig\n        }\n        availability\n        gitUrl\n        privateKey\n        subfolder\n        openshiftProjectPattern\n        productionEnvironment\n        productionRoutes\n        productionAlias\n        standbyProductionEnvironment\n        standbyRoutes\n        standbyAlias\n        envVariables {\n          name\n          value\n          scope\n        }\n      }\n    }\n`);\n\nexport const getBillingGroupForProject = (project: string): Promise<any> =>\n  graphqlapi.query(`\n    {\n      project:projectByName(name: \"${project}\"){\n        groups {\n          ... on BillingGroup {\n            type\n            uptimeRobotStatusPageId\n          }\n        }\n      }\n    }\n`);\n\ninterface GetEnvironentsForProjectEnvironmentResult {\n  name: string;\n  environmentType: EnvType;\n}\n\ninterface GetEnvironentsForProjectProjectResult {\n  developmentEnvironmentsLimit: number;\n  productionEnvironment: string;\n  standbyProductionEnvironment: string;\n  environments: GetEnvironentsForProjectEnvironmentResult[];\n}\n\ninterface GetEnvironentsForProjectResult {\n  project: GetEnvironentsForProjectProjectResult\n}\n\nexport const getEnvironmentsForProject = (\n  project: string\n): Promise<GetEnvironentsForProjectResult> =>\n  graphqlapi.query(`\n  {\n    project:projectByName(name: \"${project}\"){\n      developmentEnvironmentsLimit\n      productionEnvironment\n      environments(includeDeleted:false) { name, environmentType }\n    }\n  }\n`);\n\nexport const getProductionEnvironmentForProject = (\n  project: string\n): Promise<any> =>\n  graphqlapi.query(`\n    {\n      project:projectByName(name: \"${project}\"){\n        productionEnvironment\n      }\n    }\n`);\n\nexport const setEnvironmentServices = (\n  environment: number,\n  services: string[]\n): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($environment: Int!, $services: [String]!) {\n    setEnvironmentServices(input: {\n      environment: $environment\n      services: $services\n    }) {\n      id\n      name\n    }\n  }\n  `,\n    { environment, services }\n  );\n\nconst deploymentFragment = graphqlapi.createFragment(`\nfragment on Deployment {\n  id\n  name\n  status\n  created\n  started\n  completed\n  remoteId\n  uiLink\n  environment {\n    name\n  }\n}\n`);\n\nexport const getDeploymentByRemoteId = (id: string): Promise<any> =>\n  graphqlapi.query(\n    `\n  query deploymentByRemoteId($id: String!) {\n    deploymentByRemoteId(id: $id) {\n      ...${deploymentFragment}\n    }\n  }\n`,\n    { id }\n  );\n\nexport const addDeployment = (\n  name: string,\n  status: string,\n  created: string,\n  environment: number,\n  remoteId: string = null,\n  id: number = null,\n  started: string = null,\n  completed: string = null\n): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($name: String!, $status: DeploymentStatusType!, $created: String!, $environment: Int!, $id: Int, $remoteId: String, $started: String, $completed: String) {\n    addDeployment(input: {\n        name: $name\n        status: $status\n        created: $created\n        environment: $environment\n        id: $id\n        remoteId: $remoteId\n        started: $started\n        completed: $completed\n    }) {\n      ...${deploymentFragment}\n    }\n  }\n`,\n    {\n      name,\n      status,\n      created,\n      environment,\n      id,\n      remoteId,\n      started,\n      completed\n    }\n  );\n\n  export const addTask = (\n    name,\n    status,\n    created,\n    environment,\n    remoteId = null,\n    id = null,\n    started = null,\n    completed = null,\n    service = null,\n    command = null,\n    execute = false,\n  ) =>\n    graphqlapi.mutate(\n      `\n    ($name: String!, $status: TaskStatusType!, $created: String!, $environment: Int!, $id: Int, $remoteId: String, $started: String, $completed: String, $service: String, $command: String, $execute: Boolean) {\n      addTask(input: {\n          name: $name\n          status: $status\n          created: $created\n          environment: $environment\n          id: $id\n          remoteId: $remoteId\n          started: $started\n          completed: $completed\n          service: $service\n          command: $command\n          execute: $execute\n      }) {\n        ...${taskFragment}\n      }\n    }\n  `,\n      {\n        name,\n        status,\n        created,\n        environment,\n        id,\n        remoteId,\n        started,\n        completed,\n        service,\n        command,\n        execute,\n      },\n    );\n\nexport const updateDeployment = (\n  id: number,\n  patch: DeploymentPatch\n): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($id: Int!, $patch: UpdateDeploymentPatchInput!) {\n    updateDeployment(input: {\n      id: $id\n      patch: $patch\n    }) {\n      ...${deploymentFragment}\n    }\n  }\n`,\n    { id, patch }\n  );\n\nconst taskFragment = graphqlapi.createFragment(`\nfragment on Task {\n  id\n  name\n  status\n  created\n  started\n  completed\n  remoteId\n  environment {\n    name\n  }\n}\n`);\n\nexport const updateTask = (id: number, patch: TaskPatch): Promise<any> =>\n  graphqlapi.mutate(\n    `\n  ($id: Int!, $patch: UpdateTaskPatchInput!) {\n    updateTask(input: {\n      id: $id\n      patch: $patch\n    }) {\n      ...${taskFragment}\n    }\n  }\n`,\n    { id, patch }\n  );\n\nexport const sanitizeGroupName = pipe(\n  replace(/[^a-zA-Z0-9-]/g, '-'),\n  toLower\n);\nexport const sanitizeProjectName = pipe(\n  replace(/[^a-zA-Z0-9-]/g, '-'),\n  toLower\n);\n\nexport const getProjectsByGroupName = groupName =>\n  graphqlapi.query(\n    `query groupByName($name: String!) {\n    groupByName(name: $name) {\n      id\n      name\n      projects {\n        id\n        name\n        gitUrl\n      }\n    }\n  }`,\n    { name: groupName }\n  );\n\nexport const getGroupMembersByGroupName = groupName =>\n  graphqlapi.query(\n    `query groupByName($name: String!) {\n    groupByName(name: $name) {\n      id\n      name\n      members {\n        user {\n          id\n          email\n        }\n        role\n      }\n    }\n  }`,\n  { name: groupName }\n);\n\nexport const addProblem = ({\n  id = null,\n  environment,\n  identifier,\n  severity,\n  source,\n  severityScore,\n  data,\n  service,\n  associatedPackage,\n  description,\n  version,\n  fixedVersion,\n  links\n}) => {\n  return graphqlapi.mutate(\n  `($id: Int,\n    $environment: Int!,\n    $identifier: String!,\n    $severity: ProblemSeverityRating!,\n    $source: String!,\n    $severityScore: SeverityScore,\n    $data: String!,\n    $service: String,\n    $associatedPackage: String,\n    $description: String,\n    $version: String,\n    $fixedVersion: String,\n    $links: String) {\n    addProblem(input: {\n      id: $id\n      environment: $environment\n      identifier: $identifier\n      severity: $severity\n      source: $source\n      severityScore: $severityScore\n      data: $data\n      service: $service\n      associatedPackage: $associatedPackage\n      description: $description\n      version: $version\n      fixedVersion: $fixedVersion\n      links: $links\n    }) {\n      id\n      environment {\n        id\n      }\n      identifier\n      severity\n      source\n      severityScore\n      data\n      associatedPackage\n      description\n      version\n      fixedVersion\n      links\n    }\n  }`,\n  {\n    id,\n    environment,\n    identifier,\n    severity,\n    source,\n    severityScore,\n    data,\n    service,\n    associatedPackage,\n    description,\n    version,\n    fixedVersion,\n    links\n  },\n)};\n\nexport const deleteProblemsFromSource = (\n  environment,\n  source,\n  service\n) => {\n  return graphqlapi.mutate(\n    `($environment: Int!, $source: String!, $service: String!) {\n      deleteProblemsFromSource(input: {environment: $environment, source: $source, service: $service })\n    }\n    `,\n    {\n      environment,\n      source,\n      service\n    }\n  )};\n\nconst problemFragment = graphqlapi.createFragment(`\nfragment on Problem {\n  id\n  severity\n  severityScore\n  identifier\n  service\n  source\n  associatedPackage\n  description\n  links\n  version\n  fixedVersion\n  data\n  created\n  deleted\n} \n`);\n\nexport const getProblemsforProjectEnvironment = async (\n  environmentName,\n  project\n) => {\n  const response = await graphqlapi.query(\n    `query getProject($environmentName: String!, $project: Int!) {\n      environmentByName(name: $environmentName, project: $project) {\n        id\n        name\n        problems {\n          ...${problemFragment}\n        }\n      }\n    }`\n  ,\n  {\n    environmentName,\n    project\n  });\n  return response.environmentByName.problems;\n};\n\nexport const getProblemHarborScanMatches = () => graphqlapi.query(\n    `query getProblemHarborScanMatches {\n      allProblemHarborScanMatchers {\n        id\n        name\n        description\n        defaultLagoonProject\n        defaultLagoonEnvironment\n        defaultLagoonService\n        regex\n      }\n    }`\n);\n", "import axios from 'axios';\nimport { pathOr, propOr } from 'ramda';\n\nconst API_HOST = propOr('http://gitlab', 'GITLAB_API_HOST', process.env);\nconst API_TOKEN = propOr(\n  'personal access token',\n  'GITLAB_API_TOKEN',\n  process.env\n);\n\nconst options = {\n  baseURL: `${API_HOST}/api/v4/`,\n  timeout: 30000,\n  headers: {\n    'Private-Token': API_TOKEN\n  }\n};\n\nconst gitlabapi = axios.create(options);\n\nexport const secureGitlabSystemHooks = [\n  'group_create',\n  'group_rename',\n  'group_destroy',\n  'project_create',\n  'project_transfer',\n  'project_rename',\n  'project_update',\n  'project_destroy',\n  'user_create',\n  'user_rename',\n  'user_destroy',\n  'user_add_to_group',\n  'user_remove_from_group',\n  'user_add_to_team',\n  'user_remove_from_team',\n  'key_create',\n  'key_destroy',\n];\n\nclass NetworkError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'NetworkError';\n  }\n}\n\nclass APIError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'GitLabAPIError';\n  }\n}\n\nconst getRequest = async (url: string): Promise<any> => {\n  try {\n    const response = await gitlabapi.get(url);\n    return response.data;\n  } catch (error) {\n    if (error.response) {\n      const errorMessage = pathOr(\n        error.message,\n        ['data', 'message'],\n        error.response\n      );\n      const errorString =\n        typeof errorMessage === 'string'\n          ? errorMessage\n          : JSON.stringify(errorMessage);\n\n      throw new APIError(errorString);\n    } else if (error.request) {\n      throw new NetworkError(error.message);\n    } else {\n      throw error;\n    }\n  }\n};\n\nconst postRequest = async (url: string, body: any): Promise<any> => {\n  try {\n    const response = await gitlabapi.post(url, body);\n    return response.data;\n  } catch (error) {\n    if (error.response) {\n      const errorMessage = pathOr(\n        error.message,\n        ['data', 'message'],\n        error.response\n      );\n      const errorString =\n        typeof errorMessage === 'string'\n          ? errorMessage\n          : JSON.stringify(errorMessage);\n\n      throw new APIError(errorString);\n    } else if (error.request) {\n      throw new NetworkError(error.message);\n    } else {\n      throw error;\n    }\n  }\n};\n\nconst getAllPagesRequest = async (url: string): Promise<any> => {\n  let page = 1;\n  let moreResults = true;\n  let results = [];\n\n  do {\n    try {\n      const response = await gitlabapi.get(url, {\n        params: {\n          per_page: 100,\n          page\n        }\n      });\n\n      if (response.data.length === 0) {\n        moreResults = false;\n      } else {\n        page++;\n        results = [...results, ...response.data];\n      }\n    } catch (error) {\n      if (error.response) {\n        const errorMessage = pathOr(\n          error.message,\n          ['data', 'message'],\n          error.response\n        );\n        const errorString =\n          typeof errorMessage === 'string'\n            ? errorMessage\n            : JSON.stringify(errorMessage);\n\n        throw new APIError(errorString);\n      } else if (error.request) {\n        throw new NetworkError(error.message);\n      } else {\n        throw error;\n      }\n    }\n  } while (moreResults);\n\n  return results;\n};\n\nexport const getUserByUsername = async (username: string): Promise<any> => {\n  try {\n    const response = await gitlabapi.get('users', {\n      params: {\n        username\n      }\n    });\n\n    if (response.data.length === 0) {\n      throw new APIError(`No user found with username: ${username}`);\n    }\n\n    return response.data[0];\n  } catch (error) {\n    if (error.response) {\n      const errorMessage = pathOr(\n        error.message,\n        ['data', 'message'],\n        error.response\n      );\n      const errorString =\n        typeof errorMessage === 'string'\n          ? errorMessage\n          : JSON.stringify(errorMessage);\n\n      throw new APIError(errorString);\n    } else if (error.request) {\n      throw new NetworkError(error.message);\n    } else {\n      throw error;\n    }\n  }\n};\n\nexport const getAllGroups = async () => getAllPagesRequest('groups');\nexport const getGroup = async (groupId: number): Promise<any> =>\n  getRequest(`groups/${groupId}`);\nexport const getGroupMembers = async (groupId: number): Promise<any> =>\n  getRequest(`groups/${groupId}/members`);\nexport const getAllProjects = async (): Promise<any> =>\n  getAllPagesRequest('projects');\nexport const getProject = async (projectId: number): Promise<any> =>\n  getRequest(`projects/${projectId}`);\nexport const getProjectMembers = async (projectId: number): Promise<any> =>\n  getRequest(`projects/${projectId}/members`);\nexport const getAllUsers = async () => getAllPagesRequest('users');\nexport const getUser = async (userId: number): Promise<any> =>\n  getRequest(`users/${userId}`);\nexport const getSshKey = async (keyId: number): Promise<any> =>\n  getRequest(`keys/${keyId}`);\n\nexport const addDeployKeyToProject = async (\n  projectId: number,\n  key: string\n): Promise<any> =>\n  postRequest(`projects/${projectId}/deploy_keys`, {\n    title: 'Lagoon Project Key',\n    key,\n    can_push: false\n  });\n", "import uuid4 from 'uuid4';\nimport url from 'url';\nimport R from 'ramda';\nimport { IncomingMessage } from 'http';\nimport { secureGitlabSystemHooks } from '@lagoon/commons/dist/gitlabApi';\n\nimport type { RawData, WebhookRequestData } from './types';\n\n/**\n * This function will check request headers for\n * service specific data like github / gitlab / etc.\n * if the request method is POST.\n *\n * Will eventually generate 'custom' webhook data on\n * GET requests.\n *\n * Will throw an error on malformed request headers,\n * non-json body data or unsupported method.\n */\nexport function extractWebhookData(req: IncomingMessage, body: string): WebhookRequestData {\n  const { method, headers } = req;\n\n  let parameters: any = {};\n  let webhooktype;\n  let event;\n  let uuid;\n  let bodyObj: RawData;\n  let giturl;\n\n  if (method === 'POST') {\n    try {\n      bodyObj = body == null || body === '' ? {} : JSON.parse(body);\n    } catch (e) {\n      throw new Error(`Request body is not parsable as JSON. Are you sure you have enabled application/json as the webhook content type? ${e}.`);\n    }\n\n    if ('x-github-event' in req.headers) {\n      webhooktype = 'github';\n      event = req.headers['x-github-event'];\n      uuid = req.headers['x-github-delivery'];\n      giturl = R.path(['repository', 'ssh_url'], bodyObj);\n    } else if ('x-gitlab-event' in req.headers) {\n      webhooktype = 'gitlab';\n      event = bodyObj.object_kind || bodyObj.event_name;\n      uuid = uuid4();\n      giturl = R.path(['project', 'git_ssh_url'], bodyObj);\n\n      // This is a system webhook\n      if (R.contains(event, secureGitlabSystemHooks)) {\n        // Ensure the system hook came from gitlab\n        if (!('x-gitlab-token' in req.headers) || req.headers['x-gitlab-token'] !== process.env.GITLAB_SYSTEM_HOOK_TOKEN) {\n          throw new Error('Gitlab system hook secret verification failed');\n        }\n      }\n    } else if ('x-event-key' in req.headers) {\n      webhooktype = 'bitbucket'\n      event = req.headers['x-event-key']\n      uuid = req.headers['x-request-uuid']\n      // Bitbucket does not provide a git-ssh URI to the repo in the webhook payload\n      // We the html repo link (example https://bitbucket.org/teamawesome/repository) to extract the correct target domain (bitbucket.org)\n      // this could be bitbuck.org(.com) or a private bitbucket server\n      // Also the git server could be running on another port than 22, so there is a second regex match for `:[0-9]`\n      const regexmatch = bodyObj.repository.links.html.href.match(/https?:\\/\\/([a-z0-9-_.]*)(:[0-9]*)?\\//i)\n      // The first match is the domain\n      const domain = regexmatch[1]\n      if (!regexmatch[2]) {\n        // If there is no 2nd regex match, ther is no port found and it's not added to the URL\n        // use the extracted domain and repo full_name (teamawesome/repository) to build the git URI, example git@bitbucket.org:teamawesome/repository.git\n        giturl = `git@${domain}:${bodyObj.repository.full_name}.git`\n      } else {\n        // If there is a second regex match, we add the port to the url and also format the url with `ssh://` in front which is needed for requests with anoter port\n        const port = regexmatch[2]\n        giturl = `ssh://git@${domain}${port}/${bodyObj.repository.full_name}.git`\n      }\n    // TODO: Use when single snapshot data is fixed\n    // } else if (bodyObj.backup_metrics) {\n    //   webhooktype = 'resticbackup';\n    //   event = 'snapshot:finished'\n    //   uuid = uuid4();\n    } else if (bodyObj.snapshots) {\n      webhooktype = 'resticbackup';\n      event = 'snapshot:sync'\n      uuid = uuid4();\n    } else if (bodyObj.restore_location) {\n      webhooktype = 'resticbackup';\n      event = 'restore:finished';\n      uuid = uuid4();\n    } else if (bodyObj.type && bodyObj.type == 'scanningCompleted') {\n      webhooktype = 'problems';\n      event = 'harbor:scanningcompleted';\n      uuid = uuid4();\n    } else if (bodyObj.lagoonInfo) {\n      webhooktype = 'problems';\n      event = 'drutiny:resultset';\n      uuid = uuid4();\n    } else {\n      throw new Error('No supported event header found on POST request');\n    }\n  } else if (method === 'GET') {\n    try {\n      webhooktype = 'custom';\n      event = 'push';\n      uuid = uuid4();\n\n      const parsedUrl = url.parse(req.url, true); // true to get query as object\n      const { query = {} } = parsedUrl;\n\n      // TODO: Potential for refactor\n      const getParam = (name: string, shouldThrow: boolean = false): string => {\n        const value = query[name];\n        if (value == null && shouldThrow) {\n          throw new Error(`Query param '${name}' not found!`);\n        }\n        if (value === '' && shouldThrow) {\n          throw new Error(`Query param '${name}' is empty!`);\n        }\n        // @ts-ignore\n        return value;\n      };\n\n      giturl = req.url;\n      parameters.url = getParam('url', true);\n      parameters.branch = getParam('branch', true);\n      parameters.sha = getParam('sha') || '';\n      bodyObj = parameters;\n    } catch (e) {\n      throw new Error(`Error in handling GET request: ${e.message}`);\n    }\n  } else {\n    throw new Error(`Unsupported request method: ${method}`);\n  }\n\n  const ret: WebhookRequestData = {\n    webhooktype,\n    event,\n    body: bodyObj\n  };\n\n  if (giturl != null) {\n    ret.giturl = giturl;\n  }\n\n  if (uuid != null) {\n    ret.uuid = uuid;\n  }\n\n  return ret;\n}\n", "import R from 'ramda';\nimport { sendToLagoonLogs } from '@lagoon/commons/dist/logs';\nimport { allProjectsInGroup, deleteProject, sanitizeGroupName } from '@lagoon/commons/dist/api';\n\nimport { WebhookRequestData } from '../types';\n\nexport async function gitlabProjectDelete(webhook: WebhookRequestData) {\n  const {\n    webhooktype,\n    event,\n    uuid,\n    body,\n    body: { path: projectName, path_with_namespace }\n  } = webhook;\n\n  try {\n    const meta = {\n      project: projectName\n    };\n\n    const groupName = sanitizeGroupName(path_with_namespace.replace(`/${projectName}`, ''));\n    const projectsInGroup = await allProjectsInGroup({ name: groupName });\n    const projectExists = R.pipe(\n      R.prop('allProjectsInGroup'),\n      R.pluck('name'),\n      R.contains(projectName),\n    // @ts-ignore\n    )(projectsInGroup);\n\n    if (projectExists) {\n      await deleteProject(projectName);\n\n      sendToLagoonLogs(\n        'info',\n        '',\n        uuid,\n        `${webhooktype}:${event}:handled`,\n        meta,\n        `deleted project ${projectName}`\n      );\n\n      return;\n    }\n\n    sendToLagoonLogs(\n      'info',\n      '',\n      uuid,\n      `${webhooktype}:${event}:handled`,\n      meta,\n      `project \"${projectName}\" not a member of group \"${groupName}\"`\n    );\n\n    return;\n  } catch (error) {\n    sendToLagoonLogs(\n      'error',\n      '',\n      uuid,\n      `${webhooktype}:${event}:unhandled`,\n      { data: body },\n      `Could not delete project, reason: ${error}`\n    );\n\n    return;\n  }\n}\n", "import R from 'ramda';\nimport { ChannelWrapper } from 'amqp-connection-manager';\nimport { ConsumeMessage } from 'amqplib';\nimport { secureGitlabSystemHooks } from '@lagoon/commons/dist/gitlabApi';\nimport { processProjects } from './webhooks/projects';\nimport { processDataSync } from './webhooks/dataSync';\nimport { processBackup } from './webhooks/backup';\nimport { processProblems } from './webhooks/problems';\nimport { WebhookRequestData } from './types';\n\nexport async function processQueue (rabbitMsg: ConsumeMessage, channelWrapperWebhooks: ChannelWrapper): Promise<void> {\n  const webhook: WebhookRequestData = JSON.parse(rabbitMsg.content.toString())\n\n  const {\n    webhooktype,\n    event,\n    giturl,\n  } = webhook;\n\n  // GitLab supports System Hooks which trigger on changes like creating new\n  // organizations or users. Since these don't have associated projects, they\n  // must be handled separately.\n  if (webhooktype == 'gitlab' && R.contains(event, secureGitlabSystemHooks)) {\n    processDataSync(rabbitMsg, channelWrapperWebhooks);\n  } else if (webhooktype == 'resticbackup') {\n    processBackup(rabbitMsg, channelWrapperWebhooks);\n  } else if (webhooktype == 'problems') {\n    processProblems(rabbitMsg, channelWrapperWebhooks);\n  }\n  else {\n    processProjects(rabbitMsg, channelWrapperWebhooks);\n  }\n}\n"], "filenames": ["node-packages/commons/src/api.ts", "node-packages/commons/src/gitlabApi.ts", "services/webhook-handler/src/extractWebhookData.ts", "services/webhooks2tasks/src/handlers/gitlabProjectDelete.ts", "services/webhooks2tasks/src/processQueue.ts"], "buggy_code_start_loc": [654, 19, 4, 0, 0], "buggy_code_end_loc": [1460, 19, 49, 29, 21], "fixing_code_start_loc": [655, 20, 5, 1, 1], "fixing_code_end_loc": [1477, 40, 50, 52, 24], "type": "NVD-CWE-noinfo", "message": "The GitLab Webhook Handler in amazee.io Lagoon before 1.12.3 has incorrect access control associated with project deletion.", "other": {"cve": {"id": "CVE-2020-35236", "sourceIdentifier": "cve@mitre.org", "published": "2020-12-14T05:15:10.933", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The GitLab Webhook Handler in amazee.io Lagoon before 1.12.3 has incorrect access control associated with project deletion."}, {"lang": "es", "value": "El GitLab Webhook Handler en amazee.io Lagoon versiones anteriores a 1.12.3, presenta un control de acceso incorrecto asociado con una eliminaci\u00f3n de proyecto."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:amazee:lagoon:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.12.3", "matchCriteriaId": "281903CD-63B0-49AD-8C86-32A6D1E00D46"}]}]}], "references": [{"url": "https://github.com/amazeeio/lagoon/commit/1140289bf9fa98b8602ab4662ae867b210d8476b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/amazeeio/lagoon/compare/v1.12.2...v1.12.3", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/amazeeio/lagoon/tree/master/services/webhook-handler", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/amazeeio/lagoon/tree/master/services/webhooks2tasks", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/amazeeio/lagoon/commit/1140289bf9fa98b8602ab4662ae867b210d8476b"}}