{"buggy_code": ["package router\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/rudderlabs/rudder-server/utils/misc\"\n)\n\nvar failedEventsManager FailedEventsManagerI\n\ntype FailedEventRowT struct {\n\tDestinationID string          `json:\"destination_id\"`\n\tRecordID      json.RawMessage `json:\"record_id\"`\n}\n\nvar (\n\tfailedKeysTablePrefix  = \"failed_keys\"\n\tfailedKeysExpire       time.Duration\n\tfailedKeysCleanUpSleep time.Duration\n\tfailedKeysEnabled      bool\n)\n\ntype FailedEventsManagerI interface {\n\tSaveFailedRecordIDs(map[string][]*FailedEventRowT, *sql.Tx)\n\tDropFailedRecordIDs(jobRunID string)\n\tFetchFailedRecordIDs(jobRunID string) []*FailedEventRowT\n\tGetDBHandle() *sql.DB\n}\n\ntype FailedEventsManagerT struct {\n\tdbHandle *sql.DB\n}\n\nfunc GetFailedEventsManager() FailedEventsManagerI {\n\tif failedEventsManager == nil {\n\t\tfem := new(FailedEventsManagerT)\n\t\tdbHandle, err := sql.Open(\"postgres\", misc.GetConnectionString())\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tfem.dbHandle = dbHandle\n\t\tfailedEventsManager = fem\n\t}\n\n\treturn failedEventsManager\n}\n\nfunc (*FailedEventsManagerT) SaveFailedRecordIDs(taskRunIDFailedEventsMap map[string][]*FailedEventRowT, txn *sql.Tx) {\n\tif !failedKeysEnabled {\n\t\treturn\n\t}\n\n\tfor taskRunID, failedEvents := range taskRunIDFailedEventsMap {\n\t\ttable := `\"` + strings.ReplaceAll(fmt.Sprintf(`%s_%s`, failedKeysTablePrefix, taskRunID), `\"`, `\"\"`) + `\"`\n\t\tsqlStatement := fmt.Sprintf(`CREATE TABLE IF NOT EXISTS %s (\n\t\tdestination_id TEXT NOT NULL,\n\t\trecord_id JSONB NOT NULL,\n\t\tcreated_at TIMESTAMP NOT NULL);`, table)\n\t\t_, err := txn.Exec(sqlStatement)\n\t\tif err != nil {\n\t\t\t_ = txn.Rollback()\n\t\t\tpanic(err)\n\t\t}\n\t\tinsertQuery := fmt.Sprintf(`INSERT INTO %s VALUES($1, $2, $3);`, table)\n\t\tstmt, err := txn.Prepare(insertQuery)\n\t\tif err != nil {\n\t\t\t_ = txn.Rollback()\n\t\t\tpanic(err)\n\t\t}\n\t\tcreatedAt := time.Now()\n\t\tfor _, failedEvent := range failedEvents {\n\t\t\tif len(failedEvent.RecordID) == 0 || !json.Valid(failedEvent.RecordID) {\n\t\t\t\tpkgLogger.Infof(\"skipped adding invalid recordId: %s, to failed keys table: %s\", failedEvent.RecordID, table)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t_, err = stmt.Exec(failedEvent.DestinationID, failedEvent.RecordID, createdAt)\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t}\n\n\t\tstmt.Close()\n\t}\n}\n\nfunc (fem *FailedEventsManagerT) DropFailedRecordIDs(taskRunID string) {\n\tif !failedKeysEnabled {\n\t\treturn\n\t}\n\n\t// Drop table\n\ttable := fmt.Sprintf(`%s_%s`, failedKeysTablePrefix, taskRunID)\n\tsqlStatement := fmt.Sprintf(`DROP TABLE IF EXISTS %s`, table)\n\t_, err := fem.dbHandle.Exec(sqlStatement)\n\tif err != nil {\n\t\tpkgLogger.Errorf(\"Failed to drop table %s with error: %v\", taskRunID, err)\n\t}\n}\n\nfunc (fem *FailedEventsManagerT) FetchFailedRecordIDs(taskRunID string) []*FailedEventRowT {\n\tif !failedKeysEnabled {\n\t\treturn []*FailedEventRowT{}\n\t}\n\n\tfailedEvents := make([]*FailedEventRowT, 0)\n\n\tvar rows *sql.Rows\n\tvar err error\n\ttable := `\"` + strings.ReplaceAll(fmt.Sprintf(`%s_%s`, failedKeysTablePrefix, taskRunID), `\"`, `\"\"`) + `\"`\n\tsqlStatement := fmt.Sprintf(`SELECT %[1]s.destination_id, %[1]s.record_id\n                                             FROM %[1]s `, table)\n\trows, err = fem.dbHandle.Query(sqlStatement)\n\tif err != nil {\n\t\tpkgLogger.Errorf(\"Failed to fetch from table %s with error: %v\", taskRunID, err)\n\t\treturn failedEvents\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar failedEvent FailedEventRowT\n\t\terr := rows.Scan(&failedEvent.DestinationID, &failedEvent.RecordID)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tfailedEvents = append(failedEvents, &failedEvent)\n\t}\n\n\treturn failedEvents\n}\n\nfunc CleanFailedRecordsTableProcess(ctx context.Context) {\n\tif !failedKeysEnabled {\n\t\treturn\n\t}\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tcase <-time.After(failedKeysCleanUpSleep):\n\t\t\tdbHandle, err := sql.Open(\"postgres\", misc.GetConnectionString())\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tfailedKeysLike := failedKeysTablePrefix + \"%\"\n\t\t\tfailedKeysTableQuery := fmt.Sprintf(`SELECT table_name\n\t\t\t\t\t\t\t\t\t\t\t\t\tFROM information_schema.tables\n\t\t\t\t\t\t\t\t\t\t\t\t\tWHERE table_schema='public' AND table_type='BASE TABLE' AND table_name ilike '%s'`, failedKeysLike)\n\t\t\trows, err := dbHandle.Query(failedKeysTableQuery)\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tfor rows.Next() {\n\t\t\t\tvar table string\n\t\t\t\terr = rows.Scan(&table)\n\t\t\t\tif err != nil {\n\t\t\t\t\tpkgLogger.Errorf(\"Failed to scan failed keys table %s with error: %v\", table, err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlatestCreatedAtQuery := fmt.Sprintf(`SELECT created_at from %s order by created_at desc limit 1`, table)\n\t\t\t\trow := dbHandle.QueryRow(latestCreatedAtQuery)\n\t\t\t\tvar latestCreatedAt time.Time\n\t\t\t\terr = row.Scan(&latestCreatedAt)\n\t\t\t\tif err != nil && err != sql.ErrNoRows {\n\t\t\t\t\tpkgLogger.Errorf(\"Failed to fetch records from failed keys table %s with error: %v\", table, err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tcurrentTime := time.Now()\n\t\t\t\tdiff := currentTime.Sub(latestCreatedAt)\n\t\t\t\tif diff > failedKeysExpire {\n\t\t\t\t\tdropQuery := fmt.Sprintf(`DROP TABLE IF EXISTS %s`, table)\n\t\t\t\t\trows, err = dbHandle.Query(dropQuery)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tpkgLogger.Errorf(\"Failed to drop table %s with error: %v\", table, err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdbHandle.Close()\n\t\t}\n\t}\n}\n\nfunc (fem *FailedEventsManagerT) GetDBHandle() *sql.DB {\n\treturn fem.dbHandle\n}\n"], "fixing_code": ["package router\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/rudderlabs/rudder-server/utils/misc\"\n)\n\nvar failedEventsManager FailedEventsManagerI\n\ntype FailedEventRowT struct {\n\tDestinationID string          `json:\"destination_id\"`\n\tRecordID      json.RawMessage `json:\"record_id\"`\n}\n\nvar (\n\tfailedKeysTablePrefix  = \"failed_keys\"\n\tfailedKeysExpire       time.Duration\n\tfailedKeysCleanUpSleep time.Duration\n\tfailedKeysEnabled      bool\n)\n\ntype FailedEventsManagerI interface {\n\tSaveFailedRecordIDs(map[string][]*FailedEventRowT, *sql.Tx)\n\tDropFailedRecordIDs(jobRunID string)\n\tFetchFailedRecordIDs(jobRunID string) []*FailedEventRowT\n\tGetDBHandle() *sql.DB\n}\n\ntype FailedEventsManagerT struct {\n\tdbHandle *sql.DB\n}\n\nfunc GetFailedEventsManager() FailedEventsManagerI {\n\tif failedEventsManager == nil {\n\t\tfem := new(FailedEventsManagerT)\n\t\tdbHandle, err := sql.Open(\"postgres\", misc.GetConnectionString())\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tfem.dbHandle = dbHandle\n\t\tfailedEventsManager = fem\n\t}\n\n\treturn failedEventsManager\n}\n\nfunc (*FailedEventsManagerT) SaveFailedRecordIDs(taskRunIDFailedEventsMap map[string][]*FailedEventRowT, txn *sql.Tx) {\n\tif !failedKeysEnabled {\n\t\treturn\n\t}\n\n\tfor taskRunID, failedEvents := range taskRunIDFailedEventsMap {\n\t\ttable := getSqlSafeTablename(taskRunID)\n\t\tsqlStatement := fmt.Sprintf(`CREATE TABLE IF NOT EXISTS %s (\n\t\tdestination_id TEXT NOT NULL,\n\t\trecord_id JSONB NOT NULL,\n\t\tcreated_at TIMESTAMP NOT NULL);`, table)\n\t\t_, err := txn.Exec(sqlStatement)\n\t\tif err != nil {\n\t\t\t_ = txn.Rollback()\n\t\t\tpanic(err)\n\t\t}\n\t\tinsertQuery := fmt.Sprintf(`INSERT INTO %s VALUES($1, $2, $3);`, table)\n\t\tstmt, err := txn.Prepare(insertQuery)\n\t\tif err != nil {\n\t\t\t_ = txn.Rollback()\n\t\t\tpanic(err)\n\t\t}\n\t\tcreatedAt := time.Now()\n\t\tfor _, failedEvent := range failedEvents {\n\t\t\tif len(failedEvent.RecordID) == 0 || !json.Valid(failedEvent.RecordID) {\n\t\t\t\tpkgLogger.Infof(\"skipped adding invalid recordId: %s, to failed keys table: %s\", failedEvent.RecordID, table)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t_, err = stmt.Exec(failedEvent.DestinationID, failedEvent.RecordID, createdAt)\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t}\n\n\t\tstmt.Close()\n\t}\n}\n\nfunc (fem *FailedEventsManagerT) DropFailedRecordIDs(taskRunID string) {\n\tif !failedKeysEnabled {\n\t\treturn\n\t}\n\n\t// Drop table\n\ttable := getSqlSafeTablename(taskRunID)\n\tsqlStatement := fmt.Sprintf(`DROP TABLE IF EXISTS %s`, table)\n\t_, err := fem.dbHandle.Exec(sqlStatement)\n\tif err != nil {\n\t\tpkgLogger.Errorf(\"Failed to drop table %s with error: %v\", taskRunID, err)\n\t}\n}\n\nfunc (fem *FailedEventsManagerT) FetchFailedRecordIDs(taskRunID string) []*FailedEventRowT {\n\tif !failedKeysEnabled {\n\t\treturn []*FailedEventRowT{}\n\t}\n\n\tfailedEvents := make([]*FailedEventRowT, 0)\n\n\tvar rows *sql.Rows\n\tvar err error\n\ttable := getSqlSafeTablename(taskRunID)\n\tsqlStatement := fmt.Sprintf(`SELECT %[1]s.destination_id, %[1]s.record_id\n                                             FROM %[1]s `, table)\n\trows, err = fem.dbHandle.Query(sqlStatement)\n\tif err != nil {\n\t\tpkgLogger.Errorf(\"Failed to fetch from table %s with error: %v\", taskRunID, err)\n\t\treturn failedEvents\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar failedEvent FailedEventRowT\n\t\terr := rows.Scan(&failedEvent.DestinationID, &failedEvent.RecordID)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tfailedEvents = append(failedEvents, &failedEvent)\n\t}\n\n\treturn failedEvents\n}\n\nfunc CleanFailedRecordsTableProcess(ctx context.Context) {\n\tif !failedKeysEnabled {\n\t\treturn\n\t}\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tcase <-time.After(failedKeysCleanUpSleep):\n\t\t\tdbHandle, err := sql.Open(\"postgres\", misc.GetConnectionString())\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tfailedKeysLike := failedKeysTablePrefix + \"%\"\n\t\t\tfailedKeysTableQuery := fmt.Sprintf(`SELECT table_name\n\t\t\t\t\t\t\t\t\t\t\t\t\tFROM information_schema.tables\n\t\t\t\t\t\t\t\t\t\t\t\t\tWHERE table_schema='public' AND table_type='BASE TABLE' AND table_name ilike '%s'`, failedKeysLike)\n\t\t\trows, err := dbHandle.Query(failedKeysTableQuery)\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tfor rows.Next() {\n\t\t\t\tvar table string\n\t\t\t\terr = rows.Scan(&table)\n\t\t\t\tif err != nil {\n\t\t\t\t\tpkgLogger.Errorf(\"Failed to scan failed keys table %s with error: %v\", table, err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlatestCreatedAtQuery := fmt.Sprintf(`SELECT created_at from %s order by created_at desc limit 1`, table)\n\t\t\t\trow := dbHandle.QueryRow(latestCreatedAtQuery)\n\t\t\t\tvar latestCreatedAt time.Time\n\t\t\t\terr = row.Scan(&latestCreatedAt)\n\t\t\t\tif err != nil && err != sql.ErrNoRows {\n\t\t\t\t\tpkgLogger.Errorf(\"Failed to fetch records from failed keys table %s with error: %v\", table, err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tcurrentTime := time.Now()\n\t\t\t\tdiff := currentTime.Sub(latestCreatedAt)\n\t\t\t\tif diff > failedKeysExpire {\n\t\t\t\t\tdropQuery := fmt.Sprintf(`DROP TABLE IF EXISTS %s`, table)\n\t\t\t\t\trows, err = dbHandle.Query(dropQuery)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tpkgLogger.Errorf(\"Failed to drop table %s with error: %v\", table, err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdbHandle.Close()\n\t\t}\n\t}\n}\n\nfunc (fem *FailedEventsManagerT) GetDBHandle() *sql.DB {\n\treturn fem.dbHandle\n}\n\nfunc getSqlSafeTablename(taskRunID string) string {\n\treturn `\"` + strings.ReplaceAll(fmt.Sprintf(`%s_%s`, failedKeysTablePrefix, taskRunID), `\"`, `\"\"`) + `\"`\n}\n"], "filenames": ["router/failed-events-manager.go"], "buggy_code_start_loc": [59], "buggy_code_end_loc": [190], "fixing_code_start_loc": [59], "fixing_code_end_loc": [195], "type": "CWE-89", "message": "rudder-server is part of RudderStack, an open source Customer Data Platform (CDP). Versions of rudder-server prior to 1.3.0-rc.1 are vulnerable to SQL injection. This issue may lead to Remote Code Execution (RCE) due to the `rudder` role in PostgresSQL having superuser permissions by default. Version 1.3.0-rc.1 contains patches for this issue.", "other": {"cve": {"id": "CVE-2023-30625", "sourceIdentifier": "security-advisories@github.com", "published": "2023-06-16T17:15:11.950", "lastModified": "2023-07-31T19:15:16.943", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "rudder-server is part of RudderStack, an open source Customer Data Platform (CDP). Versions of rudder-server prior to 1.3.0-rc.1 are vulnerable to SQL injection. This issue may lead to Remote Code Execution (RCE) due to the `rudder` role in PostgresSQL having superuser permissions by default. Version 1.3.0-rc.1 contains patches for this issue."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rudderstack:rudder-server:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.2.5", "matchCriteriaId": "068B0699-3613-44C1-A9A6-D7DFDC1996D4"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/173837/Rudder-Server-SQL-Injection-Remote-Code-Execution.html", "source": "security-advisories@github.com"}, {"url": "https://github.com/rudderlabs/rudder-server/commit/0d061ff2d8c16845179d215bf8012afceba12a30", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/rudderlabs/rudder-server/commit/2f956b7eb3d5eb2de3e79d7df2c87405af25071e", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/rudderlabs/rudder-server/commit/9c009d9775abc99e72fc470f4c4c8e8f1775e82a", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/rudderlabs/rudder-server/pull/2652", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/rudderlabs/rudder-server/pull/2663", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/rudderlabs/rudder-server/pull/2664", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://securitylab.github.com/advisories/GHSL-2022-097_rudder-server/", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rudderlabs/rudder-server/commit/0d061ff2d8c16845179d215bf8012afceba12a30"}}