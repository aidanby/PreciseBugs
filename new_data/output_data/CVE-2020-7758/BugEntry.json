{"buggy_code": ["import archiver = require('archiver');\nimport * as bodyParser from 'body-parser';\nimport { Request, Response, Router } from 'express';\nimport * as _ from 'lodash';\nimport * as multer from 'multer';\nimport * as path from 'path';\n\nimport * as chromeHelper from './chrome-helper';\nimport { MAX_PAYLOAD_SIZE } from './config';\nimport { Features } from './features';\nimport { PuppeteerProvider } from './puppeteer-provider';\nimport {\n  IBrowserlessOptions,\n  IBrowserlessStats,\n  Feature,\n} from './types';\n\nimport {\n  asyncWebHandler,\n  bodyValidation,\n  buildWorkspaceDir,\n  exists,\n  fnLoader,\n  generateChromeTarget,\n  lstat,\n  queryValidation,\n  mkdir,\n} from './utils';\n\nimport {\n  content as contentSchema,\n  fn as fnSchema,\n  pdf as pdfSchema,\n  scrape as scrapeSchema,\n  screenshot as screenshotSchema,\n  stats as statsSchema,\n} from './schemas';\n\nimport {\n  after as downloadAfter,\n  before as downloadBefore,\n} from './apis/download';\n\nimport {\n  after as screencastAfter,\n  before as screenCastBefore,\n} from './apis/screencast';\n\nconst version = require('../version.json');\nconst protocol = require('../protocol.json');\nconst hints = require('../hints.json');\nconst rimraf = require('rimraf');\n\n// Browserless fn's\nconst screenshot = fnLoader('screenshot');\nconst content = fnLoader('content');\nconst scrape = fnLoader('scrape');\nconst pdf = fnLoader('pdf');\nconst stats = fnLoader('stats');\n\nconst jsonParser = bodyParser.json({\n  limit: MAX_PAYLOAD_SIZE,\n  type: ['application/json'],\n});\n\nconst jsParser = bodyParser.text({\n  limit: MAX_PAYLOAD_SIZE,\n  type: ['text/plain', 'application/javascript'],\n});\n\nconst htmlParser = bodyParser.text({\n  limit: MAX_PAYLOAD_SIZE,\n  type: ['text/plain', 'text/html'],\n});\n\ninterface IGetRoutes {\n  puppeteerProvider: PuppeteerProvider;\n  getMetrics: () => IBrowserlessStats[];\n  getConfig: () => IBrowserlessOptions;\n  getPressure: () => any;\n  workspaceDir: string;\n  disabledFeatures: Feature[];\n  enableAPIGet: boolean;\n  enableHeapdump: boolean;\n}\n\nexport const getRoutes = ({\n  puppeteerProvider,\n  getMetrics,\n  getConfig,\n  getPressure,\n  workspaceDir,\n  disabledFeatures,\n  enableAPIGet,\n  enableHeapdump,\n}: IGetRoutes): Router => {\n  const router = Router();\n  const storage = multer.diskStorage({\n    destination: async (req, _file, cb) => {\n      const trackingId = (req.query.trackingId || '') as string;\n\n      if (['/', '.', '\\\\'].some((routeLike) => trackingId.includes(routeLike))) {\n        return cb(new Error(`trackingId must not include paths`), workspaceDir);\n      }\n\n      const finalDest = path.join(workspaceDir, trackingId);\n\n      if (trackingId && !(await exists(finalDest))) {\n        await mkdir(finalDest);\n      }\n\n      cb(null, finalDest);\n    },\n    filename: (_req, file, cb) => {\n      cb(null, file.originalname);\n    },\n  });\n  const upload = multer({ storage }).any();\n  const config = getConfig();\n\n  if (!disabledFeatures.includes(Features.INTROSPECTION_ENDPOINT)) {\n    router.get('/introspection', (_req, res) => res.json(hints));\n  }\n  if (!disabledFeatures.includes(Features.METRICS_ENDPOINT)) {\n    router.get('/metrics', async (_req, res) => res.json(await getMetrics()));\n  }\n  if (!disabledFeatures.includes(Features.CONFIG_ENDPOINT)) {\n    router.get('/config', (_req, res) => res.json(config));\n  }\n\n  if (!disabledFeatures.includes(Features.WORKSPACES)) {\n    router.get('/workspace', async (_req, res) => {\n      const downloads = await buildWorkspaceDir(workspaceDir);\n\n      if (!downloads) {\n        return res.json([]);\n      }\n\n      return res.json(downloads);\n    });\n\n    router.post('/workspace', async (req, res) => {\n      return upload(req, res, (err?: any) => {\n        if (err) {\n          return res.status(400).send(err.message);\n        }\n\n        return res.json(req.files);\n      });\n    });\n\n    router.get(/^\\/workspace\\/(.*)/, async (req, res) => {\n      const file = req.params[0];\n\n      if (!file) {\n        return res.sendStatus(400);\n      }\n\n      const filePath = path.join(workspaceDir, file);\n\n      const hasFile = await exists(filePath);\n\n      if (!hasFile) {\n        return res.sendStatus(404);\n      }\n\n      const stats = await lstat(filePath);\n\n      if (stats.isDirectory()) {\n        const zipStream = archiver('zip');\n        zipStream.pipe(res);\n        return zipStream.directory(filePath, false).finalize();\n      }\n\n      return res.sendFile(filePath, {dotfiles: 'allow'});\n    });\n\n    router.delete(/^\\/workspace\\/(.*)/, async (req, res) => {\n      const file = req.params[0];\n\n      if (!file) {\n        return res.sendStatus(400);\n      }\n\n      const filePath = path.join(workspaceDir, file);\n      const hasFile = await exists(filePath);\n\n      if (!hasFile) {\n        return res.sendStatus(404);\n      }\n\n      rimraf(filePath, _.noop);\n\n      return res.sendStatus(204);\n    });\n  }\n\n  if (!disabledFeatures.includes(Features.DOWNLOAD_ENDPOINT)) {\n    router.post('/download', jsonParser, jsParser, asyncWebHandler(async (req: Request, res: Response) => {\n      const isJson = typeof req.body === 'object';\n      const code = isJson ? req.body.code : req.body;\n      const context = isJson ? req.body.context : {};\n\n      return puppeteerProvider.runHTTP({\n        after: downloadAfter,\n        before: downloadBefore,\n        code,\n        context,\n        req,\n        res,\n      });\n    }));\n  }\n\n  if (!disabledFeatures.includes(Features.PRESSURE_ENDPOINT)) {\n    router.get('/pressure', async (_req, res) =>\n      res.json({\n        pressure: await getPressure(),\n      }),\n    );\n  }\n\n  if (!disabledFeatures.includes(Features.FUNCTION_ENDPOINT)) {\n    router.post('/function',\n      jsonParser,\n      jsParser,\n      bodyValidation(fnSchema),\n      asyncWebHandler(async (req: Request, res: Response) => {\n        const isJson = typeof req.body === 'object';\n        const code = isJson ? req.body.code : req.body;\n        const context = isJson ? req.body.context : {};\n        const detached = isJson ? !!req.body.detached : false;\n\n        return puppeteerProvider.runHTTP({\n          code,\n          context,\n          detached,\n          req,\n          res,\n        });\n      }),\n    );\n  }\n\n  if (!disabledFeatures.includes(Features.KILL_ENDPOINT)) {\n    router.get('/kill/all', async (_req, res) => {\n      await chromeHelper.killAll();\n\n      return res.sendStatus(204);\n    });\n\n    router.get('/kill/:id', async (req, res) => {\n      await chromeHelper.kill(req.params.id);\n\n      return res.sendStatus(204);\n    });\n  }\n\n  if (!disabledFeatures.includes(Features.SCREENCAST_ENDPOINT)) {\n    // Screen cast route -- we inject some fun stuff here so that it all works properly :)\n    router.post('/screencast', jsonParser, jsParser, asyncWebHandler(async (req: Request, res: Response) => {\n      const isJson = typeof req.body === 'object';\n      const code = isJson ? req.body.code : req.body;\n      const context = isJson ? req.body.context : {};\n\n      return puppeteerProvider.runHTTP({\n        after: screencastAfter,\n        before: screenCastBefore,\n        code,\n        context,\n        req,\n        res,\n        ignoreDefaultArgs: ['--enable-automation'],\n      });\n    }));\n  }\n\n  if (!disabledFeatures.includes(Features.SCREENSHOT_ENDPOINT)) {\n    enableAPIGet && router.get('/screenshot',\n      queryValidation(screenshotSchema),\n      asyncWebHandler(async (req: Request, res: Response) =>\n        puppeteerProvider.runHTTP({\n          code: screenshot,\n          context: req.body,\n          req,\n          res,\n        }),\n      ),\n    );\n\n    router.post('/screenshot',\n      jsonParser,\n      htmlParser,\n      bodyValidation(screenshotSchema),\n      asyncWebHandler(async (req: Request, res: Response) => {\n        const isJson = typeof req.body === 'object';\n        const context = isJson ? req.body : {html: req.body};\n\n        return puppeteerProvider.runHTTP({\n          code: screenshot,\n          context,\n          req,\n          res,\n        });\n      }),\n    );\n  }\n\n  if (!disabledFeatures.includes(Features.CONTENT_ENDPOINT)) {\n    enableAPIGet && router.get('/content',\n      queryValidation(contentSchema),\n      asyncWebHandler(async (req: Request, res: Response) =>\n        puppeteerProvider.runHTTP({\n          code: content,\n          context: req.body,\n          req,\n          res,\n        }),\n      ),\n    );\n\n    router.post('/content',\n      jsonParser,\n      htmlParser,\n      bodyValidation(contentSchema),\n      asyncWebHandler(async (req: Request, res: Response) => {\n        const isJson = typeof req.body === 'object';\n        const context = isJson ? req.body : {html: req.body};\n\n        return puppeteerProvider.runHTTP({\n          code: content,\n          context,\n          req,\n          res,\n        });\n      }),\n    );\n  }\n\n  if (!disabledFeatures.includes(Features.SCRAPE_ENDPOINT)) {\n    enableAPIGet && router.get('/scrape',\n      queryValidation(scrapeSchema),\n      asyncWebHandler(async (req: Request, res: Response) =>\n        puppeteerProvider.runHTTP({\n          code: scrape,\n          context: req.body,\n          req,\n          res,\n        }),\n      ),\n    );\n\n    router.post('/scrape',\n      jsonParser,\n      bodyValidation(scrapeSchema),\n      asyncWebHandler(async (req: Request, res: Response) => {\n        const isJson = typeof req.body === 'object';\n        const context = isJson ? req.body : {};\n\n        return puppeteerProvider.runHTTP({\n          code: scrape,\n          context,\n          req,\n          res,\n        });\n      }),\n    );\n  }\n\n  if (!disabledFeatures.includes(Features.PDF_ENDPOINT)) {\n    enableAPIGet && router.get('/pdf',\n      queryValidation(pdfSchema),\n      asyncWebHandler(async (req: Request, res: Response) =>\n        puppeteerProvider.runHTTP({\n          code: pdf,\n          context: req.body,\n          req,\n          res,\n        }),\n      ),\n    );\n\n    router.post('/pdf',\n      jsonParser,\n      htmlParser,\n      bodyValidation(pdfSchema),\n      asyncWebHandler(async (req: Request, res: Response) => {\n        const isJson = typeof req.body === 'object';\n        const context = isJson ? req.body : {html: req.body};\n\n        return puppeteerProvider.runHTTP({\n          code: pdf,\n          context,\n          req,\n          res,\n        });\n      }),\n    );\n  }\n\n  if (!disabledFeatures.includes(Features.STATS_ENDPOINT)) {\n    enableAPIGet && router.get('/stats',\n      queryValidation(statsSchema),\n      asyncWebHandler(async (req: Request, res: Response) =>\n        puppeteerProvider.runHTTP({\n          builtin: ['url', 'child_process', 'path'],\n          code: stats,\n          context: req.body,\n          external: ['tree-kill'],\n          req,\n          res,\n        }),\n      ),\n    );\n\n    router.post('/stats', jsonParser, bodyValidation(statsSchema), asyncWebHandler(\n      async (req: Request, res: Response) =>\n        puppeteerProvider.runHTTP({\n          builtin: ['url', 'child_process', 'path'],\n          code: stats,\n          context: req.body,\n          external: ['tree-kill'],\n          req,\n          res,\n        }),\n      ));\n  }\n\n  if (!disabledFeatures.includes(Features.DEBUGGER)) {\n    router.get('/json/protocol', (_req, res) => res.json(protocol));\n\n    router.get('/json/new', asyncWebHandler(async (req: Request, res: Response) => {\n      const targetId = generateChromeTarget();\n      const baseUrl = req.get('host');\n      const protocol = req.protocol.includes('s') ? 'wss' : 'ws';\n\n      res.json({\n        description: '',\n        devtoolsFrontendUrl: `/devtools/inspector.html?${protocol}=${baseUrl}${targetId}`,\n        targetId,\n        title: 'about:blank',\n        type: 'page',\n        url: 'about:blank',\n        webSocketDebuggerUrl: `${protocol}://${baseUrl}${targetId}`,\n      });\n    }));\n\n    router.get('/json/version', (req, res) => {\n      const baseUrl = req.get('host');\n      const protocol = req.protocol.includes('s') ? 'wss' : 'ws';\n\n      return res.json({\n        ...version,\n        webSocketDebuggerUrl: `${protocol}://${baseUrl}`,\n      });\n    });\n\n    router.get('/json*', asyncWebHandler(async (req: Request, res: Response) => {\n      const targetId = generateChromeTarget();\n      const baseUrl = req.get('host');\n      const protocol = req.protocol.includes('s') ? 'wss' : 'ws';\n\n      res.json([{\n        description: '',\n        devtoolsFrontendUrl: `/devtools/inspector.html?${protocol}=${baseUrl}${targetId}`,\n        targetId,\n        title: 'about:blank',\n        type: 'page',\n        url: 'about:blank',\n        webSocketDebuggerUrl: `${protocol}://${baseUrl}${targetId}`,\n      }]);\n    }));\n  }\n\n  if (!disabledFeatures.includes(Features.DEBUG_VIEWER)) {\n    router.get('/sessions', asyncWebHandler(async (_req: Request, res: Response) => {\n      const pages = await chromeHelper.getDebuggingPages();\n\n      return res.json(pages);\n    }));\n  }\n\n  if (enableHeapdump) {\n    const heapdump = require('heapdump');\n    router.get('/heapdump', (_req, res) => {\n      const heapLocation = path.join(workspaceDir, `heap-${Date.now()}`);\n      heapdump.writeSnapshot(heapLocation, (err: Error) => {\n        if (err) {\n          return res.status(500).send(err.message);\n        }\n\n        return res.sendFile(heapLocation, (_err: Error) => rimraf(heapLocation, _.noop));\n      });\n    });\n  }\n\n  return router;\n};\n"], "fixing_code": ["import archiver = require('archiver');\nimport * as bodyParser from 'body-parser';\nimport { Request, Response, Router } from 'express';\nimport * as _ from 'lodash';\nimport * as multer from 'multer';\nimport * as path from 'path';\n\nimport * as chromeHelper from './chrome-helper';\nimport { MAX_PAYLOAD_SIZE } from './config';\nimport { Features } from './features';\nimport { PuppeteerProvider } from './puppeteer-provider';\nimport {\n  IBrowserlessOptions,\n  IBrowserlessStats,\n  Feature,\n} from './types';\n\nimport {\n  asyncWebHandler,\n  bodyValidation,\n  buildWorkspaceDir,\n  exists,\n  fnLoader,\n  generateChromeTarget,\n  lstat,\n  queryValidation,\n  mkdir,\n} from './utils';\n\nimport {\n  content as contentSchema,\n  fn as fnSchema,\n  pdf as pdfSchema,\n  scrape as scrapeSchema,\n  screenshot as screenshotSchema,\n  stats as statsSchema,\n} from './schemas';\n\nimport {\n  after as downloadAfter,\n  before as downloadBefore,\n} from './apis/download';\n\nimport {\n  after as screencastAfter,\n  before as screenCastBefore,\n} from './apis/screencast';\n\nconst version = require('../version.json');\nconst protocol = require('../protocol.json');\nconst hints = require('../hints.json');\nconst rimraf = require('rimraf');\n\n// Browserless fn's\nconst screenshot = fnLoader('screenshot');\nconst content = fnLoader('content');\nconst scrape = fnLoader('scrape');\nconst pdf = fnLoader('pdf');\nconst stats = fnLoader('stats');\n\nconst jsonParser = bodyParser.json({\n  limit: MAX_PAYLOAD_SIZE,\n  type: ['application/json'],\n});\n\nconst jsParser = bodyParser.text({\n  limit: MAX_PAYLOAD_SIZE,\n  type: ['text/plain', 'application/javascript'],\n});\n\nconst htmlParser = bodyParser.text({\n  limit: MAX_PAYLOAD_SIZE,\n  type: ['text/plain', 'text/html'],\n});\n\ninterface IGetRoutes {\n  puppeteerProvider: PuppeteerProvider;\n  getMetrics: () => IBrowserlessStats[];\n  getConfig: () => IBrowserlessOptions;\n  getPressure: () => any;\n  workspaceDir: string;\n  disabledFeatures: Feature[];\n  enableAPIGet: boolean;\n  enableHeapdump: boolean;\n}\n\nexport const getRoutes = ({\n  puppeteerProvider,\n  getMetrics,\n  getConfig,\n  getPressure,\n  workspaceDir,\n  disabledFeatures,\n  enableAPIGet,\n  enableHeapdump,\n}: IGetRoutes): Router => {\n  const router = Router();\n  const storage = multer.diskStorage({\n    destination: async (req, _file, cb) => {\n      const trackingId = (req.query.trackingId || '') as string;\n\n      if (['/', '.', '\\\\'].some((routeLike) => trackingId.includes(routeLike))) {\n        return cb(new Error(`trackingId must not include paths`), workspaceDir);\n      }\n\n      const finalDest = path.join(workspaceDir, trackingId);\n\n      if (trackingId && !(await exists(finalDest))) {\n        await mkdir(finalDest);\n      }\n\n      cb(null, finalDest);\n    },\n    filename: (_req, file, cb) => {\n      cb(null, file.originalname);\n    },\n  });\n  const upload = multer({ storage }).any();\n  const config = getConfig();\n\n  if (!disabledFeatures.includes(Features.INTROSPECTION_ENDPOINT)) {\n    router.get('/introspection', (_req, res) => res.json(hints));\n  }\n  if (!disabledFeatures.includes(Features.METRICS_ENDPOINT)) {\n    router.get('/metrics', async (_req, res) => res.json(await getMetrics()));\n  }\n  if (!disabledFeatures.includes(Features.CONFIG_ENDPOINT)) {\n    router.get('/config', (_req, res) => res.json(config));\n  }\n\n  if (!disabledFeatures.includes(Features.WORKSPACES)) {\n    router.get('/workspace', async (_req, res) => {\n      const downloads = await buildWorkspaceDir(workspaceDir);\n\n      if (!downloads) {\n        return res.json([]);\n      }\n\n      return res.json(downloads);\n    });\n\n    router.post('/workspace', async (req, res) => {\n      return upload(req, res, (err?: any) => {\n        if (err) {\n          return res.status(400).send(err.message);\n        }\n\n        return res.json(req.files);\n      });\n    });\n\n    router.get(/^\\/workspace\\/(.*)/, async (req, res) => {\n      const file = req.params[0];\n\n      if (!file) {\n        return res.sendStatus(400);\n      }\n\n      const filePath = path.join(workspaceDir, file);\n      const hasFile = await exists(filePath);\n\n      if (!filePath.includes(workspaceDir)) {\n        return res.sendStatus(404);\n      }\n\n      if (!hasFile) {\n        return res.sendStatus(404);\n      }\n\n      const stats = await lstat(filePath);\n\n      if (stats.isDirectory()) {\n        const zipStream = archiver('zip');\n        zipStream.pipe(res);\n        return zipStream.directory(filePath, false).finalize();\n      }\n\n      return res.sendFile(filePath, {dotfiles: 'allow'});\n    });\n\n    router.delete(/^\\/workspace\\/(.*)/, async (req, res) => {\n      const file = req.params[0];\n\n      if (!file) {\n        return res.sendStatus(400);\n      }\n\n      const filePath = path.join(workspaceDir, file);\n      const hasFile = await exists(filePath);\n\n      if (!filePath.includes(workspaceDir)) {\n        return res.sendStatus(404);\n      }\n\n      if (!hasFile) {\n        return res.sendStatus(404);\n      }\n\n      rimraf(filePath, _.noop);\n\n      return res.sendStatus(204);\n    });\n  }\n\n  if (!disabledFeatures.includes(Features.DOWNLOAD_ENDPOINT)) {\n    router.post('/download', jsonParser, jsParser, asyncWebHandler(async (req: Request, res: Response) => {\n      const isJson = typeof req.body === 'object';\n      const code = isJson ? req.body.code : req.body;\n      const context = isJson ? req.body.context : {};\n\n      return puppeteerProvider.runHTTP({\n        after: downloadAfter,\n        before: downloadBefore,\n        code,\n        context,\n        req,\n        res,\n      });\n    }));\n  }\n\n  if (!disabledFeatures.includes(Features.PRESSURE_ENDPOINT)) {\n    router.get('/pressure', async (_req, res) =>\n      res.json({\n        pressure: await getPressure(),\n      }),\n    );\n  }\n\n  if (!disabledFeatures.includes(Features.FUNCTION_ENDPOINT)) {\n    router.post('/function',\n      jsonParser,\n      jsParser,\n      bodyValidation(fnSchema),\n      asyncWebHandler(async (req: Request, res: Response) => {\n        const isJson = typeof req.body === 'object';\n        const code = isJson ? req.body.code : req.body;\n        const context = isJson ? req.body.context : {};\n        const detached = isJson ? !!req.body.detached : false;\n\n        return puppeteerProvider.runHTTP({\n          code,\n          context,\n          detached,\n          req,\n          res,\n        });\n      }),\n    );\n  }\n\n  if (!disabledFeatures.includes(Features.KILL_ENDPOINT)) {\n    router.get('/kill/all', async (_req, res) => {\n      await chromeHelper.killAll();\n\n      return res.sendStatus(204);\n    });\n\n    router.get('/kill/:id', async (req, res) => {\n      await chromeHelper.kill(req.params.id);\n\n      return res.sendStatus(204);\n    });\n  }\n\n  if (!disabledFeatures.includes(Features.SCREENCAST_ENDPOINT)) {\n    // Screen cast route -- we inject some fun stuff here so that it all works properly :)\n    router.post('/screencast', jsonParser, jsParser, asyncWebHandler(async (req: Request, res: Response) => {\n      const isJson = typeof req.body === 'object';\n      const code = isJson ? req.body.code : req.body;\n      const context = isJson ? req.body.context : {};\n\n      return puppeteerProvider.runHTTP({\n        after: screencastAfter,\n        before: screenCastBefore,\n        code,\n        context,\n        req,\n        res,\n        ignoreDefaultArgs: ['--enable-automation'],\n      });\n    }));\n  }\n\n  if (!disabledFeatures.includes(Features.SCREENSHOT_ENDPOINT)) {\n    enableAPIGet && router.get('/screenshot',\n      queryValidation(screenshotSchema),\n      asyncWebHandler(async (req: Request, res: Response) =>\n        puppeteerProvider.runHTTP({\n          code: screenshot,\n          context: req.body,\n          req,\n          res,\n        }),\n      ),\n    );\n\n    router.post('/screenshot',\n      jsonParser,\n      htmlParser,\n      bodyValidation(screenshotSchema),\n      asyncWebHandler(async (req: Request, res: Response) => {\n        const isJson = typeof req.body === 'object';\n        const context = isJson ? req.body : {html: req.body};\n\n        return puppeteerProvider.runHTTP({\n          code: screenshot,\n          context,\n          req,\n          res,\n        });\n      }),\n    );\n  }\n\n  if (!disabledFeatures.includes(Features.CONTENT_ENDPOINT)) {\n    enableAPIGet && router.get('/content',\n      queryValidation(contentSchema),\n      asyncWebHandler(async (req: Request, res: Response) =>\n        puppeteerProvider.runHTTP({\n          code: content,\n          context: req.body,\n          req,\n          res,\n        }),\n      ),\n    );\n\n    router.post('/content',\n      jsonParser,\n      htmlParser,\n      bodyValidation(contentSchema),\n      asyncWebHandler(async (req: Request, res: Response) => {\n        const isJson = typeof req.body === 'object';\n        const context = isJson ? req.body : {html: req.body};\n\n        return puppeteerProvider.runHTTP({\n          code: content,\n          context,\n          req,\n          res,\n        });\n      }),\n    );\n  }\n\n  if (!disabledFeatures.includes(Features.SCRAPE_ENDPOINT)) {\n    enableAPIGet && router.get('/scrape',\n      queryValidation(scrapeSchema),\n      asyncWebHandler(async (req: Request, res: Response) =>\n        puppeteerProvider.runHTTP({\n          code: scrape,\n          context: req.body,\n          req,\n          res,\n        }),\n      ),\n    );\n\n    router.post('/scrape',\n      jsonParser,\n      bodyValidation(scrapeSchema),\n      asyncWebHandler(async (req: Request, res: Response) => {\n        const isJson = typeof req.body === 'object';\n        const context = isJson ? req.body : {};\n\n        return puppeteerProvider.runHTTP({\n          code: scrape,\n          context,\n          req,\n          res,\n        });\n      }),\n    );\n  }\n\n  if (!disabledFeatures.includes(Features.PDF_ENDPOINT)) {\n    enableAPIGet && router.get('/pdf',\n      queryValidation(pdfSchema),\n      asyncWebHandler(async (req: Request, res: Response) =>\n        puppeteerProvider.runHTTP({\n          code: pdf,\n          context: req.body,\n          req,\n          res,\n        }),\n      ),\n    );\n\n    router.post('/pdf',\n      jsonParser,\n      htmlParser,\n      bodyValidation(pdfSchema),\n      asyncWebHandler(async (req: Request, res: Response) => {\n        const isJson = typeof req.body === 'object';\n        const context = isJson ? req.body : {html: req.body};\n\n        return puppeteerProvider.runHTTP({\n          code: pdf,\n          context,\n          req,\n          res,\n        });\n      }),\n    );\n  }\n\n  if (!disabledFeatures.includes(Features.STATS_ENDPOINT)) {\n    enableAPIGet && router.get('/stats',\n      queryValidation(statsSchema),\n      asyncWebHandler(async (req: Request, res: Response) =>\n        puppeteerProvider.runHTTP({\n          builtin: ['url', 'child_process', 'path'],\n          code: stats,\n          context: req.body,\n          external: ['tree-kill'],\n          req,\n          res,\n        }),\n      ),\n    );\n\n    router.post('/stats', jsonParser, bodyValidation(statsSchema), asyncWebHandler(\n      async (req: Request, res: Response) =>\n        puppeteerProvider.runHTTP({\n          builtin: ['url', 'child_process', 'path'],\n          code: stats,\n          context: req.body,\n          external: ['tree-kill'],\n          req,\n          res,\n        }),\n      ));\n  }\n\n  if (!disabledFeatures.includes(Features.DEBUGGER)) {\n    router.get('/json/protocol', (_req, res) => res.json(protocol));\n\n    router.get('/json/new', asyncWebHandler(async (req: Request, res: Response) => {\n      const targetId = generateChromeTarget();\n      const baseUrl = req.get('host');\n      const protocol = req.protocol.includes('s') ? 'wss' : 'ws';\n\n      res.json({\n        description: '',\n        devtoolsFrontendUrl: `/devtools/inspector.html?${protocol}=${baseUrl}${targetId}`,\n        targetId,\n        title: 'about:blank',\n        type: 'page',\n        url: 'about:blank',\n        webSocketDebuggerUrl: `${protocol}://${baseUrl}${targetId}`,\n      });\n    }));\n\n    router.get('/json/version', (req, res) => {\n      const baseUrl = req.get('host');\n      const protocol = req.protocol.includes('s') ? 'wss' : 'ws';\n\n      return res.json({\n        ...version,\n        webSocketDebuggerUrl: `${protocol}://${baseUrl}`,\n      });\n    });\n\n    router.get('/json*', asyncWebHandler(async (req: Request, res: Response) => {\n      const targetId = generateChromeTarget();\n      const baseUrl = req.get('host');\n      const protocol = req.protocol.includes('s') ? 'wss' : 'ws';\n\n      res.json([{\n        description: '',\n        devtoolsFrontendUrl: `/devtools/inspector.html?${protocol}=${baseUrl}${targetId}`,\n        targetId,\n        title: 'about:blank',\n        type: 'page',\n        url: 'about:blank',\n        webSocketDebuggerUrl: `${protocol}://${baseUrl}${targetId}`,\n      }]);\n    }));\n  }\n\n  if (!disabledFeatures.includes(Features.DEBUG_VIEWER)) {\n    router.get('/sessions', asyncWebHandler(async (_req: Request, res: Response) => {\n      const pages = await chromeHelper.getDebuggingPages();\n\n      return res.json(pages);\n    }));\n  }\n\n  if (enableHeapdump) {\n    const heapdump = require('heapdump');\n    router.get('/heapdump', (_req, res) => {\n      const heapLocation = path.join(workspaceDir, `heap-${Date.now()}`);\n      heapdump.writeSnapshot(heapLocation, (err: Error) => {\n        if (err) {\n          return res.status(500).send(err.message);\n        }\n\n        return res.sendFile(heapLocation, (_err: Error) => rimraf(heapLocation, _.noop));\n      });\n    });\n  }\n\n  return router;\n};\n"], "filenames": ["src/routes.ts"], "buggy_code_start_loc": [160], "buggy_code_end_loc": [186], "fixing_code_start_loc": [159], "fixing_code_end_loc": [194], "type": "CWE-22", "message": "This affects versions of package browserless-chrome before 1.40.2-chrome-stable. User input flowing from the workspace endpoint gets used to create a file path filePath and this is fetched and then sent back to a user. This can be escaped to fetch arbitrary files from a server.", "other": {"cve": {"id": "CVE-2020-7758", "sourceIdentifier": "report@snyk.io", "published": "2020-11-02T22:15:13.580", "lastModified": "2022-10-19T17:10:05.133", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects versions of package browserless-chrome before 1.40.2-chrome-stable. User input flowing from the workspace endpoint gets used to create a file path filePath and this is fetched and then sent back to a user. This can be escaped to fetch arbitrary files from a server."}, {"lang": "es", "value": "Esto afecta a las versiones del paquete browserless-chrome anterioes a la versi\u00f3n 1.40.2-chrome-stable. La entrada del usuario que fluye desde el endpoint del espacio de trabajo es usada para crear una ruta de archivo filePath y esta es extra\u00edda y luego se env\u00eda de vuelta a un usuario. Esto puede ser escapado para recuperar archivos arbitrarios desde un servidor"}], "metrics": {"cvssMetricV31": [{"source": "report@snyk.io", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:browserless:chrome:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "1.40.2", "matchCriteriaId": "B126F402-8BBC-4988-8348-F7DF30C8FA84"}]}]}], "references": [{"url": "https://github.com/browserless/chrome/blob/master/src/routes.ts%23L175", "source": "report@snyk.io", "tags": ["Broken Link"]}, {"url": "https://github.com/browserless/chrome/commit/848b87e5bea4f8473eea85261a5ff922d6ebd2b6", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/browserless/chrome/releases/tag/1.40.2-chrome-stable", "source": "report@snyk.io", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-BROWSERLESSCHROME-1023657", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/browserless/chrome/commit/848b87e5bea4f8473eea85261a5ff922d6ebd2b6"}}