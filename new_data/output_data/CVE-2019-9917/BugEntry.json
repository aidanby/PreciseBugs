{"buggy_code": ["/*\n * Copyright (C) 2004-2018 ZNC, see the NOTICE file for details.\n * Copyright (C) 2008 by Stefan Rado\n * based on admin.cpp by Sebastian Ramacher\n * based on admin.cpp in crox branch\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <znc/User.h>\n#include <znc/IRCNetwork.h>\n#include <znc/Chan.h>\n#include <znc/IRCSock.h>\n\nusing std::map;\nusing std::vector;\n\ntemplate <std::size_t N>\nstruct array_size_helper {\n    char __place_holder[N];\n};\n\ntemplate <class T, std::size_t N>\nstatic array_size_helper<N> array_size(T (&)[N]) {\n    return array_size_helper<N>();\n}\n\n#define ARRAY_SIZE(array) sizeof(array_size((array)))\n\nclass CAdminMod : public CModule {\n    using CModule::PutModule;\n\n    struct Setting {\n        const char* name;\n        CString type;\n    };\n\n    void PrintVarsHelp(const CString& sFilter, const Setting vars[],\n                       unsigned int uSize, const CString& sDescription) {\n        CTable VarTable;\n        VarTable.AddColumn(t_s(\"Type\", \"helptable\"));\n        VarTable.AddColumn(t_s(\"Variables\", \"helptable\"));\n        std::map<CString, VCString> mvsTypedVariables;\n        for (unsigned int i = 0; i != uSize; ++i) {\n            CString sVar = CString(vars[i].name).AsLower();\n            if (sFilter.empty() || sVar.StartsWith(sFilter) ||\n                sVar.WildCmp(sFilter)) {\n                mvsTypedVariables[vars[i].type].emplace_back(vars[i].name);\n            }\n        }\n        for (const auto& i : mvsTypedVariables) {\n            VarTable.AddRow();\n            VarTable.SetCell(t_s(\"Type\", \"helptable\"), i.first);\n            VarTable.SetCell(\n                t_s(\"Variables\", \"helptable\"),\n                CString(\", \").Join(i.second.cbegin(), i.second.cend()));\n        }\n        if (!VarTable.empty()) {\n            PutModule(sDescription);\n            PutModule(VarTable);\n        }\n    }\n\n    void PrintHelp(const CString& sLine) {\n        HandleHelpCommand(sLine);\n\n        const CString str = t_s(\"String\");\n        const CString boolean = t_s(\"Boolean (true/false)\");\n        const CString integer = t_s(\"Integer\");\n        const CString number = t_s(\"Number\");\n\n        const CString sCmdFilter = sLine.Token(1, false);\n        const CString sVarFilter = sLine.Token(2, true).AsLower();\n\n        if (sCmdFilter.empty() || sCmdFilter.StartsWith(\"Set\") ||\n            sCmdFilter.StartsWith(\"Get\")) {\n            Setting vars[] = {\n                {\"Nick\", str},\n                {\"Altnick\", str},\n                {\"Ident\", str},\n                {\"RealName\", str},\n                {\"BindHost\", str},\n                {\"MultiClients\", boolean},\n                {\"DenyLoadMod\", boolean},\n                {\"DenySetBindHost\", boolean},\n                {\"DefaultChanModes\", str},\n                {\"QuitMsg\", str},\n                {\"ChanBufferSize\", integer},\n                {\"QueryBufferSize\", integer},\n                {\"AutoClearChanBuffer\", boolean},\n                {\"AutoClearQueryBuffer\", boolean},\n                {\"Password\", str},\n                {\"JoinTries\", integer},\n                {\"MaxJoins\", integer},\n                {\"MaxNetworks\", integer},\n                {\"MaxQueryBuffers\", integer},\n                {\"Timezone\", str},\n                {\"Admin\", boolean},\n                {\"AppendTimestamp\", boolean},\n                {\"PrependTimestamp\", boolean},\n                {\"AuthOnlyViaModule\", boolean},\n                {\"TimestampFormat\", str},\n                {\"DCCBindHost\", str},\n                {\"StatusPrefix\", str},\n#ifdef HAVE_I18N\n                {\"Language\", str},\n#endif\n#ifdef HAVE_ICU\n                {\"ClientEncoding\", str},\n#endif\n            };\n            PrintVarsHelp(sVarFilter, vars, ARRAY_SIZE(vars),\n                          t_s(\"The following variables are available when \"\n                              \"using the Set/Get commands:\"));\n        }\n\n        if (sCmdFilter.empty() || sCmdFilter.StartsWith(\"SetNetwork\") ||\n            sCmdFilter.StartsWith(\"GetNetwork\")) {\n            Setting nvars[] = {\n                {\"Nick\", str},\n                {\"Altnick\", str},\n                {\"Ident\", str},\n                {\"RealName\", str},\n                {\"BindHost\", str},\n                {\"FloodRate\", number},\n                {\"FloodBurst\", integer},\n                {\"JoinDelay\", integer},\n#ifdef HAVE_ICU\n                {\"Encoding\", str},\n#endif\n                {\"QuitMsg\", str},\n                {\"TrustAllCerts\", boolean},\n                {\"TrustPKI\", boolean},\n            };\n            PrintVarsHelp(sVarFilter, nvars, ARRAY_SIZE(nvars),\n                          t_s(\"The following variables are available when \"\n                              \"using the SetNetwork/GetNetwork commands:\"));\n        }\n\n        if (sCmdFilter.empty() || sCmdFilter.StartsWith(\"SetChan\") ||\n            sCmdFilter.StartsWith(\"GetChan\")) {\n            Setting cvars[] = {{\"DefModes\", str},\n                               {\"Key\", str},\n                               {\"BufferSize\", integer},\n                               {\"InConfig\", boolean},\n                               {\"AutoClearChanBuffer\", boolean},\n                               {\"Detached\", boolean}};\n            PrintVarsHelp(sVarFilter, cvars, ARRAY_SIZE(cvars),\n                          t_s(\"The following variables are available when \"\n                              \"using the SetChan/GetChan commands:\"));\n        }\n\n        if (sCmdFilter.empty())\n            PutModule(\n                t_s(\"You can use $user as the user name and $network as the \"\n                    \"network name for modifying your own user and network.\"));\n    }\n\n    CUser* FindUser(const CString& sUsername) {\n        if (sUsername.Equals(\"$me\") || sUsername.Equals(\"$user\"))\n            return GetUser();\n        CUser* pUser = CZNC::Get().FindUser(sUsername);\n        if (!pUser) {\n            PutModule(t_f(\"Error: User [{1}] does not exist!\")(sUsername));\n            return nullptr;\n        }\n        if (pUser != GetUser() && !GetUser()->IsAdmin()) {\n            PutModule(t_s(\n                \"Error: You need to have admin rights to modify other users!\"));\n            return nullptr;\n        }\n        return pUser;\n    }\n\n    CIRCNetwork* FindNetwork(CUser* pUser, const CString& sNetwork) {\n        if (sNetwork.Equals(\"$net\") || sNetwork.Equals(\"$network\")) {\n            if (pUser != GetUser()) {\n                PutModule(t_s(\n                    \"Error: You cannot use $network to modify other users!\"));\n                return nullptr;\n            }\n            return CModule::GetNetwork();\n        }\n        CIRCNetwork* pNetwork = pUser->FindNetwork(sNetwork);\n        if (!pNetwork) {\n            PutModule(\n                t_f(\"Error: User {1} does not have a network named [{2}].\")(\n                    pUser->GetUserName(), sNetwork));\n        }\n        return pNetwork;\n    }\n\n    void Get(const CString& sLine) {\n        const CString sVar = sLine.Token(1).AsLower();\n        CString sUsername = sLine.Token(2, true);\n        CUser* pUser;\n\n        if (sVar.empty()) {\n            PutModule(t_s(\"Usage: Get <variable> [username]\"));\n            return;\n        }\n\n        if (sUsername.empty()) {\n            pUser = GetUser();\n        } else {\n            pUser = FindUser(sUsername);\n        }\n\n        if (!pUser) return;\n\n        if (sVar == \"nick\")\n            PutModule(\"Nick = \" + pUser->GetNick());\n        else if (sVar == \"altnick\")\n            PutModule(\"AltNick = \" + pUser->GetAltNick());\n        else if (sVar == \"ident\")\n            PutModule(\"Ident = \" + pUser->GetIdent());\n        else if (sVar == \"realname\")\n            PutModule(\"RealName = \" + pUser->GetRealName());\n        else if (sVar == \"bindhost\")\n            PutModule(\"BindHost = \" + pUser->GetBindHost());\n        else if (sVar == \"multiclients\")\n            PutModule(\"MultiClients = \" + CString(pUser->MultiClients()));\n        else if (sVar == \"denyloadmod\")\n            PutModule(\"DenyLoadMod = \" + CString(pUser->DenyLoadMod()));\n        else if (sVar == \"denysetbindhost\")\n            PutModule(\"DenySetBindHost = \" + CString(pUser->DenySetBindHost()));\n        else if (sVar == \"defaultchanmodes\")\n            PutModule(\"DefaultChanModes = \" + pUser->GetDefaultChanModes());\n        else if (sVar == \"quitmsg\")\n            PutModule(\"QuitMsg = \" + pUser->GetQuitMsg());\n        else if (sVar == \"buffercount\")\n            PutModule(\"BufferCount = \" + CString(pUser->GetBufferCount()));\n        else if (sVar == \"chanbuffersize\")\n            PutModule(\"ChanBufferSize = \" +\n                      CString(pUser->GetChanBufferSize()));\n        else if (sVar == \"querybuffersize\")\n            PutModule(\"QueryBufferSize = \" +\n                      CString(pUser->GetQueryBufferSize()));\n        else if (sVar == \"keepbuffer\")\n            // XXX compatibility crap, added in 0.207\n            PutModule(\"KeepBuffer = \" + CString(!pUser->AutoClearChanBuffer()));\n        else if (sVar == \"autoclearchanbuffer\")\n            PutModule(\"AutoClearChanBuffer = \" +\n                      CString(pUser->AutoClearChanBuffer()));\n        else if (sVar == \"autoclearquerybuffer\")\n            PutModule(\"AutoClearQueryBuffer = \" +\n                      CString(pUser->AutoClearQueryBuffer()));\n        else if (sVar == \"maxjoins\")\n            PutModule(\"MaxJoins = \" + CString(pUser->MaxJoins()));\n        else if (sVar == \"notraffictimeout\")\n            PutModule(\"NoTrafficTimeout = \" +\n                      CString(pUser->GetNoTrafficTimeout()));\n        else if (sVar == \"maxnetworks\")\n            PutModule(\"MaxNetworks = \" + CString(pUser->MaxNetworks()));\n        else if (sVar == \"maxquerybuffers\")\n            PutModule(\"MaxQueryBuffers = \" + CString(pUser->MaxQueryBuffers()));\n        else if (sVar == \"jointries\")\n            PutModule(\"JoinTries = \" + CString(pUser->JoinTries()));\n        else if (sVar == \"timezone\")\n            PutModule(\"Timezone = \" + pUser->GetTimezone());\n        else if (sVar == \"appendtimestamp\")\n            PutModule(\"AppendTimestamp = \" +\n                      CString(pUser->GetTimestampAppend()));\n        else if (sVar == \"prependtimestamp\")\n            PutModule(\"PrependTimestamp = \" +\n                      CString(pUser->GetTimestampPrepend()));\n        else if (sVar == \"authonlyviamodule\")\n            PutModule(\"AuthOnlyViaModule = \" +\n                      CString(pUser->AuthOnlyViaModule()));\n        else if (sVar == \"timestampformat\")\n            PutModule(\"TimestampFormat = \" + pUser->GetTimestampFormat());\n        else if (sVar == \"dccbindhost\")\n            PutModule(\"DCCBindHost = \" + CString(pUser->GetDCCBindHost()));\n        else if (sVar == \"admin\")\n            PutModule(\"Admin = \" + CString(pUser->IsAdmin()));\n        else if (sVar == \"statusprefix\")\n            PutModule(\"StatusPrefix = \" + pUser->GetStatusPrefix());\n#ifdef HAVE_I18N\n        else if (sVar == \"language\")\n            PutModule(\"Language = \" + (pUser->GetLanguage().empty()\n                                           ? \"en\"\n                                           : pUser->GetLanguage()));\n#endif\n#ifdef HAVE_ICU\n        else if (sVar == \"clientencoding\")\n            PutModule(\"ClientEncoding = \" + pUser->GetClientEncoding());\n#endif\n        else\n            PutModule(t_s(\"Error: Unknown variable\"));\n    }\n\n    void Set(const CString& sLine) {\n        const CString sVar = sLine.Token(1).AsLower();\n        CString sUserName = sLine.Token(2);\n        CString sValue = sLine.Token(3, true);\n\n        if (sValue.empty()) {\n            PutModule(t_s(\"Usage: Set <variable> <username> <value>\"));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUserName);\n        if (!pUser) return;\n\n        if (sVar == \"nick\") {\n            pUser->SetNick(sValue);\n            PutModule(\"Nick = \" + sValue);\n        } else if (sVar == \"altnick\") {\n            pUser->SetAltNick(sValue);\n            PutModule(\"AltNick = \" + sValue);\n        } else if (sVar == \"ident\") {\n            pUser->SetIdent(sValue);\n            PutModule(\"Ident = \" + sValue);\n        } else if (sVar == \"realname\") {\n            pUser->SetRealName(sValue);\n            PutModule(\"RealName = \" + sValue);\n        } else if (sVar == \"bindhost\") {\n            if (!pUser->DenySetBindHost() || GetUser()->IsAdmin()) {\n                if (sValue.Equals(pUser->GetBindHost())) {\n                    PutModule(t_s(\"This bind host is already set!\"));\n                    return;\n                }\n\n                pUser->SetBindHost(sValue);\n                PutModule(\"BindHost = \" + sValue);\n            } else {\n                PutModule(t_s(\"Access denied!\"));\n            }\n        } else if (sVar == \"multiclients\") {\n            bool b = sValue.ToBool();\n            pUser->SetMultiClients(b);\n            PutModule(\"MultiClients = \" + CString(b));\n        } else if (sVar == \"denyloadmod\") {\n            if (GetUser()->IsAdmin()) {\n                bool b = sValue.ToBool();\n                pUser->SetDenyLoadMod(b);\n                PutModule(\"DenyLoadMod = \" + CString(b));\n            } else {\n                PutModule(t_s(\"Access denied!\"));\n            }\n        } else if (sVar == \"denysetbindhost\") {\n            if (GetUser()->IsAdmin()) {\n                bool b = sValue.ToBool();\n                pUser->SetDenySetBindHost(b);\n                PutModule(\"DenySetBindHost = \" + CString(b));\n            } else {\n                PutModule(t_s(\"Access denied!\"));\n            }\n        } else if (sVar == \"defaultchanmodes\") {\n            pUser->SetDefaultChanModes(sValue);\n            PutModule(\"DefaultChanModes = \" + sValue);\n        } else if (sVar == \"quitmsg\") {\n            pUser->SetQuitMsg(sValue);\n            PutModule(\"QuitMsg = \" + sValue);\n        } else if (sVar == \"chanbuffersize\" || sVar == \"buffercount\") {\n            unsigned int i = sValue.ToUInt();\n            // Admins don't have to honour the buffer limit\n            if (pUser->SetChanBufferSize(i, GetUser()->IsAdmin())) {\n                PutModule(\"ChanBufferSize = \" + sValue);\n            } else {\n                PutModule(t_f(\"Setting failed, limit for buffer size is {1}\")(\n                    CString(CZNC::Get().GetMaxBufferSize())));\n            }\n        } else if (sVar == \"querybuffersize\") {\n            unsigned int i = sValue.ToUInt();\n            // Admins don't have to honour the buffer limit\n            if (pUser->SetQueryBufferSize(i, GetUser()->IsAdmin())) {\n                PutModule(\"QueryBufferSize = \" + sValue);\n            } else {\n                PutModule(t_f(\"Setting failed, limit for buffer size is {1}\")(\n                    CString(CZNC::Get().GetMaxBufferSize())));\n            }\n        } else if (sVar == \"keepbuffer\") {\n            // XXX compatibility crap, added in 0.207\n            bool b = !sValue.ToBool();\n            pUser->SetAutoClearChanBuffer(b);\n            PutModule(\"AutoClearChanBuffer = \" + CString(b));\n        } else if (sVar == \"autoclearchanbuffer\") {\n            bool b = sValue.ToBool();\n            pUser->SetAutoClearChanBuffer(b);\n            PutModule(\"AutoClearChanBuffer = \" + CString(b));\n        } else if (sVar == \"autoclearquerybuffer\") {\n            bool b = sValue.ToBool();\n            pUser->SetAutoClearQueryBuffer(b);\n            PutModule(\"AutoClearQueryBuffer = \" + CString(b));\n        } else if (sVar == \"password\") {\n            const CString sSalt = CUtils::GetSalt();\n            const CString sHash = CUser::SaltedHash(sValue, sSalt);\n            pUser->SetPass(sHash, CUser::HASH_DEFAULT, sSalt);\n            PutModule(t_s(\"Password has been changed!\"));\n        } else if (sVar == \"maxjoins\") {\n            unsigned int i = sValue.ToUInt();\n            pUser->SetMaxJoins(i);\n            PutModule(\"MaxJoins = \" + CString(pUser->MaxJoins()));\n        } else if (sVar == \"notraffictimeout\") {\n            unsigned int i = sValue.ToUInt();\n            if (i < 30) {\n                PutModule(t_s(\"Timeout can't be less than 30 seconds!\"));\n            } else {\n                pUser->SetNoTrafficTimeout(i);\n                PutModule(\"NoTrafficTimeout = \" +\n                          CString(pUser->GetNoTrafficTimeout()));\n            }\n        } else if (sVar == \"maxnetworks\") {\n            if (GetUser()->IsAdmin()) {\n                unsigned int i = sValue.ToUInt();\n                pUser->SetMaxNetworks(i);\n                PutModule(\"MaxNetworks = \" + sValue);\n            } else {\n                PutModule(t_s(\"Access denied!\"));\n            }\n        } else if (sVar == \"maxquerybuffers\") {\n            unsigned int i = sValue.ToUInt();\n            pUser->SetMaxQueryBuffers(i);\n            PutModule(\"MaxQueryBuffers = \" + sValue);\n        } else if (sVar == \"jointries\") {\n            unsigned int i = sValue.ToUInt();\n            pUser->SetJoinTries(i);\n            PutModule(\"JoinTries = \" + CString(pUser->JoinTries()));\n        } else if (sVar == \"timezone\") {\n            pUser->SetTimezone(sValue);\n            PutModule(\"Timezone = \" + pUser->GetTimezone());\n        } else if (sVar == \"admin\") {\n            if (GetUser()->IsAdmin() && pUser != GetUser()) {\n                bool b = sValue.ToBool();\n                pUser->SetAdmin(b);\n                PutModule(\"Admin = \" + CString(pUser->IsAdmin()));\n            } else {\n                PutModule(t_s(\"Access denied!\"));\n            }\n        } else if (sVar == \"prependtimestamp\") {\n            bool b = sValue.ToBool();\n            pUser->SetTimestampPrepend(b);\n            PutModule(\"PrependTimestamp = \" + CString(b));\n        } else if (sVar == \"appendtimestamp\") {\n            bool b = sValue.ToBool();\n            pUser->SetTimestampAppend(b);\n            PutModule(\"AppendTimestamp = \" + CString(b));\n        } else if (sVar == \"authonlyviamodule\") {\n            if (GetUser()->IsAdmin()) {\n                bool b = sValue.ToBool();\n                pUser->SetAuthOnlyViaModule(b);\n                PutModule(\"AuthOnlyViaModule = \" + CString(b));\n            } else {\n                PutModule(t_s(\"Access denied!\"));\n            }\n        } else if (sVar == \"timestampformat\") {\n            pUser->SetTimestampFormat(sValue);\n            PutModule(\"TimestampFormat = \" + sValue);\n        } else if (sVar == \"dccbindhost\") {\n            if (!pUser->DenySetBindHost() || GetUser()->IsAdmin()) {\n                pUser->SetDCCBindHost(sValue);\n                PutModule(\"DCCBindHost = \" + sValue);\n            } else {\n                PutModule(t_s(\"Access denied!\"));\n            }\n        } else if (sVar == \"statusprefix\") {\n            if (sVar.find_first_of(\" \\t\\n\") == CString::npos) {\n                pUser->SetStatusPrefix(sValue);\n                PutModule(\"StatusPrefix = \" + sValue);\n            } else {\n                PutModule(t_s(\"That would be a bad idea!\"));\n            }\n        }\n#ifdef HAVE_I18N\n        else if (sVar == \"language\") {\n            auto mTranslations = CTranslationInfo::GetTranslations();\n            // TODO: maybe stop special-casing English\n            if (sValue == \"en\") {\n                pUser->SetLanguage(\"\");\n                PutModule(\"Language is set to English\");\n            } else if (mTranslations.count(sValue)) {\n                pUser->SetLanguage(sValue);\n                PutModule(\"Language = \" + sValue);\n            } else {\n                VCString vsCodes = {\"en\"};\n                for (const auto it : mTranslations) {\n                    vsCodes.push_back(it.first);\n                }\n                PutModule(t_f(\"Supported languages: {1}\")(\n                    CString(\", \").Join(vsCodes.begin(), vsCodes.end())));\n            }\n        }\n#endif\n#ifdef HAVE_ICU\n        else if (sVar == \"clientencoding\") {\n            pUser->SetClientEncoding(sValue);\n            PutModule(\"ClientEncoding = \" + sValue);\n        }\n#endif\n        else\n            PutModule(t_s(\"Error: Unknown variable\"));\n    }\n\n    void GetNetwork(const CString& sLine) {\n        const CString sVar = sLine.Token(1).AsLower();\n        const CString sUsername = sLine.Token(2);\n        const CString sNetwork = sLine.Token(3);\n\n        CIRCNetwork* pNetwork = nullptr;\n        CUser* pUser;\n\n        if (sVar.empty()) {\n            PutModule(t_s(\"Usage: GetNetwork <variable> [username] [network]\"));\n            return;\n        }\n\n        if (sUsername.empty()) {\n            pUser = GetUser();\n        } else {\n            pUser = FindUser(sUsername);\n        }\n\n        if (!pUser) {\n            return;\n        }\n\n        if (sNetwork.empty()) {\n            if (pUser == GetUser()) {\n                pNetwork = CModule::GetNetwork();\n            } else {\n                PutModule(\n                    t_s(\"Error: A network must be specified to get another \"\n                        \"users settings.\"));\n                return;\n            }\n\n            if (!pNetwork) {\n                PutModule(t_s(\"You are not currently attached to a network.\"));\n                return;\n            }\n        } else {\n            pNetwork = FindNetwork(pUser, sNetwork);\n            if (!pNetwork) {\n                PutModule(t_s(\"Error: Invalid network.\"));\n                return;\n            }\n        }\n\n        if (sVar.Equals(\"nick\")) {\n            PutModule(\"Nick = \" + pNetwork->GetNick());\n        } else if (sVar.Equals(\"altnick\")) {\n            PutModule(\"AltNick = \" + pNetwork->GetAltNick());\n        } else if (sVar.Equals(\"ident\")) {\n            PutModule(\"Ident = \" + pNetwork->GetIdent());\n        } else if (sVar.Equals(\"realname\")) {\n            PutModule(\"RealName = \" + pNetwork->GetRealName());\n        } else if (sVar.Equals(\"bindhost\")) {\n            PutModule(\"BindHost = \" + pNetwork->GetBindHost());\n        } else if (sVar.Equals(\"floodrate\")) {\n            PutModule(\"FloodRate = \" + CString(pNetwork->GetFloodRate()));\n        } else if (sVar.Equals(\"floodburst\")) {\n            PutModule(\"FloodBurst = \" + CString(pNetwork->GetFloodBurst()));\n        } else if (sVar.Equals(\"joindelay\")) {\n            PutModule(\"JoinDelay = \" + CString(pNetwork->GetJoinDelay()));\n#ifdef HAVE_ICU\n        } else if (sVar.Equals(\"encoding\")) {\n            PutModule(\"Encoding = \" + pNetwork->GetEncoding());\n#endif\n        } else if (sVar.Equals(\"quitmsg\")) {\n            PutModule(\"QuitMsg = \" + pNetwork->GetQuitMsg());\n        } else if (sVar.Equals(\"trustallcerts\")) {\n            PutModule(\"TrustAllCerts = \" + CString(pNetwork->GetTrustAllCerts()));\n        } else if (sVar.Equals(\"trustpki\")) {\n            PutModule(\"TrustPKI = \" + CString(pNetwork->GetTrustPKI()));\n        } else {\n            PutModule(t_s(\"Error: Unknown variable\"));\n        }\n    }\n\n    void SetNetwork(const CString& sLine) {\n        const CString sVar = sLine.Token(1).AsLower();\n        const CString sUsername = sLine.Token(2);\n        const CString sNetwork = sLine.Token(3);\n        const CString sValue = sLine.Token(4, true);\n\n        if (sValue.empty()) {\n            PutModule(t_s(\n                \"Usage: SetNetwork <variable> <username> <network> <value>\"));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUsername);\n        if (!pUser) {\n            return;\n        }\n\n        CIRCNetwork* pNetwork = FindNetwork(pUser, sNetwork);\n        if (!pNetwork) {\n            return;\n        }\n\n        if (sVar.Equals(\"nick\")) {\n            pNetwork->SetNick(sValue);\n            PutModule(\"Nick = \" + pNetwork->GetNick());\n        } else if (sVar.Equals(\"altnick\")) {\n            pNetwork->SetAltNick(sValue);\n            PutModule(\"AltNick = \" + pNetwork->GetAltNick());\n        } else if (sVar.Equals(\"ident\")) {\n            pNetwork->SetIdent(sValue);\n            PutModule(\"Ident = \" + pNetwork->GetIdent());\n        } else if (sVar.Equals(\"realname\")) {\n            pNetwork->SetRealName(sValue);\n            PutModule(\"RealName = \" + pNetwork->GetRealName());\n        } else if (sVar.Equals(\"bindhost\")) {\n            if (!pUser->DenySetBindHost() || GetUser()->IsAdmin()) {\n                if (sValue.Equals(pNetwork->GetBindHost())) {\n                    PutModule(t_s(\"This bind host is already set!\"));\n                    return;\n                }\n\n                pNetwork->SetBindHost(sValue);\n                PutModule(\"BindHost = \" + sValue);\n            } else {\n                PutModule(t_s(\"Access denied!\"));\n            }\n        } else if (sVar.Equals(\"floodrate\")) {\n            pNetwork->SetFloodRate(sValue.ToDouble());\n            PutModule(\"FloodRate = \" + CString(pNetwork->GetFloodRate()));\n        } else if (sVar.Equals(\"floodburst\")) {\n            pNetwork->SetFloodBurst(sValue.ToUShort());\n            PutModule(\"FloodBurst = \" + CString(pNetwork->GetFloodBurst()));\n        } else if (sVar.Equals(\"joindelay\")) {\n            pNetwork->SetJoinDelay(sValue.ToUShort());\n            PutModule(\"JoinDelay = \" + CString(pNetwork->GetJoinDelay()));\n#ifdef HAVE_ICU\n        } else if (sVar.Equals(\"encoding\")) {\n            pNetwork->SetEncoding(sValue);\n            PutModule(\"Encoding = \" + pNetwork->GetEncoding());\n#endif\n        } else if (sVar.Equals(\"quitmsg\")) {\n            pNetwork->SetQuitMsg(sValue);\n            PutModule(\"QuitMsg = \" + pNetwork->GetQuitMsg());\n        } else if (sVar.Equals(\"trustallcerts\")) {\n            bool b = sValue.ToBool();\n            pNetwork->SetTrustAllCerts(b);\n            PutModule(\"TrustAllCerts = \" + CString(b));\n        } else if (sVar.Equals(\"trustpki\")) {\n            bool b = sValue.ToBool();\n            pNetwork->SetTrustPKI(b);\n            PutModule(\"TrustPKI = \" + CString(b));\n        } else {\n            PutModule(t_s(\"Error: Unknown variable\"));\n        }\n    }\n\n    void AddChan(const CString& sLine) {\n        const CString sUsername = sLine.Token(1);\n        const CString sNetwork = sLine.Token(2);\n        const CString sChan = sLine.Token(3);\n\n        if (sChan.empty()) {\n            PutModule(t_s(\"Usage: AddChan <username> <network> <channel>\"));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUsername);\n        if (!pUser) return;\n\n        CIRCNetwork* pNetwork = FindNetwork(pUser, sNetwork);\n        if (!pNetwork) {\n            return;\n        }\n\n        if (pNetwork->FindChan(sChan)) {\n            PutModule(t_f(\"Error: User {1} already has a channel named {2}.\")(\n                sUsername, sChan));\n            return;\n        }\n\n        CChan* pChan = new CChan(sChan, pNetwork, true);\n        if (pNetwork->AddChan(pChan))\n            PutModule(t_f(\"Channel {1} for user {2} added to network {3}.\")(\n                pChan->GetName(), sUsername, pNetwork->GetName()));\n        else\n            PutModule(t_f(\n                \"Could not add channel {1} for user {2} to network {3}, does \"\n                \"it already exist?\")(sChan, sUsername, pNetwork->GetName()));\n    }\n\n    void DelChan(const CString& sLine) {\n        const CString sUsername = sLine.Token(1);\n        const CString sNetwork = sLine.Token(2);\n        const CString sChan = sLine.Token(3);\n\n        if (sChan.empty()) {\n            PutModule(t_s(\"Usage: DelChan <username> <network> <channel>\"));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUsername);\n        if (!pUser) return;\n\n        CIRCNetwork* pNetwork = FindNetwork(pUser, sNetwork);\n        if (!pNetwork) {\n            return;\n        }\n\n        std::vector<CChan*> vChans = pNetwork->FindChans(sChan);\n        if (vChans.empty()) {\n            PutModule(\n                t_f(\"Error: User {1} does not have any channel matching [{2}] \"\n                    \"in network {3}\")(sUsername, sChan, pNetwork->GetName()));\n            return;\n        }\n\n        VCString vsNames;\n        for (const CChan* pChan : vChans) {\n            const CString& sName = pChan->GetName();\n            vsNames.push_back(sName);\n            pNetwork->PutIRC(\"PART \" + sName);\n            pNetwork->DelChan(sName);\n        }\n\n        PutModule(t_p(\"Channel {1} is deleted from network {2} of user {3}\",\n                      \"Channels {1} are deleted from network {2} of user {3}\",\n                      vsNames.size())(\n            CString(\", \").Join(vsNames.begin(), vsNames.end()),\n            pNetwork->GetName(), sUsername));\n    }\n\n    void GetChan(const CString& sLine) {\n        const CString sVar = sLine.Token(1).AsLower();\n        CString sUsername = sLine.Token(2);\n        CString sNetwork = sLine.Token(3);\n        CString sChan = sLine.Token(4, true);\n\n        if (sChan.empty()) {\n            PutModule(\n                t_s(\"Usage: GetChan <variable> <username> <network> <chan>\"));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUsername);\n        if (!pUser) return;\n\n        CIRCNetwork* pNetwork = FindNetwork(pUser, sNetwork);\n        if (!pNetwork) {\n            return;\n        }\n\n        std::vector<CChan*> vChans = pNetwork->FindChans(sChan);\n        if (vChans.empty()) {\n            PutModule(t_f(\"Error: No channels matching [{1}] found.\")(sChan));\n            return;\n        }\n\n        for (CChan* pChan : vChans) {\n            if (sVar == \"defmodes\") {\n                PutModule(pChan->GetName() + \": DefModes = \" +\n                          pChan->GetDefaultModes());\n            } else if (sVar == \"buffersize\" || sVar == \"buffer\") {\n                CString sValue(pChan->GetBufferCount());\n                if (!pChan->HasBufferCountSet()) {\n                    sValue += \" (default)\";\n                }\n                PutModule(pChan->GetName() + \": BufferSize = \" + sValue);\n            } else if (sVar == \"inconfig\") {\n                PutModule(pChan->GetName() + \": InConfig = \" +\n                          CString(pChan->InConfig()));\n            } else if (sVar == \"keepbuffer\") {\n                // XXX compatibility crap, added in 0.207\n                PutModule(pChan->GetName() + \": KeepBuffer = \" +\n                          CString(!pChan->AutoClearChanBuffer()));\n            } else if (sVar == \"autoclearchanbuffer\") {\n                CString sValue(pChan->AutoClearChanBuffer());\n                if (!pChan->HasAutoClearChanBufferSet()) {\n                    sValue += \" (default)\";\n                }\n                PutModule(pChan->GetName() + \": AutoClearChanBuffer = \" +\n                          sValue);\n            } else if (sVar == \"detached\") {\n                PutModule(pChan->GetName() + \": Detached = \" +\n                          CString(pChan->IsDetached()));\n            } else if (sVar == \"key\") {\n                PutModule(pChan->GetName() + \": Key = \" + pChan->GetKey());\n            } else {\n                PutModule(t_s(\"Error: Unknown variable\"));\n                return;\n            }\n        }\n    }\n\n    void SetChan(const CString& sLine) {\n        const CString sVar = sLine.Token(1).AsLower();\n        CString sUsername = sLine.Token(2);\n        CString sNetwork = sLine.Token(3);\n        CString sChan = sLine.Token(4);\n        CString sValue = sLine.Token(5, true);\n\n        if (sValue.empty()) {\n            PutModule(\n                t_s(\"Usage: SetChan <variable> <username> <network> <chan> \"\n                    \"<value>\"));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUsername);\n        if (!pUser) return;\n\n        CIRCNetwork* pNetwork = FindNetwork(pUser, sNetwork);\n        if (!pNetwork) {\n            return;\n        }\n\n        std::vector<CChan*> vChans = pNetwork->FindChans(sChan);\n        if (vChans.empty()) {\n            PutModule(t_f(\"Error: No channels matching [{1}] found.\")(sChan));\n            return;\n        }\n\n        for (CChan* pChan : vChans) {\n            if (sVar == \"defmodes\") {\n                pChan->SetDefaultModes(sValue);\n                PutModule(pChan->GetName() + \": DefModes = \" + sValue);\n            } else if (sVar == \"buffersize\" || sVar == \"buffer\") {\n                unsigned int i = sValue.ToUInt();\n                if (sValue.Equals(\"-\")) {\n                    pChan->ResetBufferCount();\n                    PutModule(pChan->GetName() + \": BufferSize = \" +\n                              CString(pChan->GetBufferCount()));\n                } else if (pChan->SetBufferCount(i, GetUser()->IsAdmin())) {\n                    // Admins don't have to honour the buffer limit\n                    PutModule(pChan->GetName() + \": BufferSize = \" + sValue);\n                } else {\n                    PutModule(\n                        t_f(\"Setting failed, limit for buffer size is {1}\")(\n                            CString(CZNC::Get().GetMaxBufferSize())));\n                    return;\n                }\n            } else if (sVar == \"inconfig\") {\n                bool b = sValue.ToBool();\n                pChan->SetInConfig(b);\n                PutModule(pChan->GetName() + \": InConfig = \" + CString(b));\n            } else if (sVar == \"keepbuffer\") {\n                // XXX compatibility crap, added in 0.207\n                bool b = !sValue.ToBool();\n                pChan->SetAutoClearChanBuffer(b);\n                PutModule(pChan->GetName() + \": AutoClearChanBuffer = \" +\n                          CString(b));\n            } else if (sVar == \"autoclearchanbuffer\") {\n                if (sValue.Equals(\"-\")) {\n                    pChan->ResetAutoClearChanBuffer();\n                } else {\n                    bool b = sValue.ToBool();\n                    pChan->SetAutoClearChanBuffer(b);\n                }\n                PutModule(pChan->GetName() + \": AutoClearChanBuffer = \" +\n                          CString(pChan->AutoClearChanBuffer()));\n            } else if (sVar == \"detached\") {\n                bool b = sValue.ToBool();\n                if (pChan->IsDetached() != b) {\n                    if (b)\n                        pChan->DetachUser();\n                    else\n                        pChan->AttachUser();\n                }\n                PutModule(pChan->GetName() + \": Detached = \" + CString(b));\n            } else if (sVar == \"key\") {\n                pChan->SetKey(sValue);\n                PutModule(pChan->GetName() + \": Key = \" + sValue);\n            } else {\n                PutModule(t_s(\"Error: Unknown variable\"));\n                return;\n            }\n        }\n    }\n\n    void ListUsers(const CString&) {\n        if (!GetUser()->IsAdmin()) return;\n\n        const map<CString, CUser*>& msUsers = CZNC::Get().GetUserMap();\n        CTable Table;\n        Table.AddColumn(t_s(\"Username\", \"listusers\"));\n        Table.AddColumn(t_s(\"Realname\", \"listusers\"));\n        Table.AddColumn(t_s(\"IsAdmin\", \"listusers\"));\n        Table.AddColumn(t_s(\"Nick\", \"listusers\"));\n        Table.AddColumn(t_s(\"AltNick\", \"listusers\"));\n        Table.AddColumn(t_s(\"Ident\", \"listusers\"));\n        Table.AddColumn(t_s(\"BindHost\", \"listusers\"));\n\n        for (const auto& it : msUsers) {\n            Table.AddRow();\n            Table.SetCell(t_s(\"Username\", \"listusers\"), it.first);\n            Table.SetCell(t_s(\"Realname\", \"listusers\"),\n                          it.second->GetRealName());\n            if (!it.second->IsAdmin())\n                Table.SetCell(t_s(\"IsAdmin\", \"listusers\"), t_s(\"No\"));\n            else\n                Table.SetCell(t_s(\"IsAdmin\", \"listusers\"), t_s(\"Yes\"));\n            Table.SetCell(t_s(\"Nick\", \"listusers\"), it.second->GetNick());\n            Table.SetCell(t_s(\"AltNick\", \"listusers\"), it.second->GetAltNick());\n            Table.SetCell(t_s(\"Ident\", \"listusers\"), it.second->GetIdent());\n            Table.SetCell(t_s(\"BindHost\", \"listusers\"),\n                          it.second->GetBindHost());\n        }\n\n        PutModule(Table);\n    }\n\n    void AddUser(const CString& sLine) {\n        if (!GetUser()->IsAdmin()) {\n            PutModule(\n                t_s(\"Error: You need to have admin rights to add new users!\"));\n            return;\n        }\n\n        const CString sUsername = sLine.Token(1), sPassword = sLine.Token(2);\n        if (sPassword.empty()) {\n            PutModule(t_s(\"Usage: AddUser <username> <password>\"));\n            return;\n        }\n\n        if (CZNC::Get().FindUser(sUsername)) {\n            PutModule(t_f(\"Error: User {1} already exists!\")(sUsername));\n            return;\n        }\n\n        CUser* pNewUser = new CUser(sUsername);\n        CString sSalt = CUtils::GetSalt();\n        pNewUser->SetPass(CUser::SaltedHash(sPassword, sSalt),\n                          CUser::HASH_DEFAULT, sSalt);\n\n        CString sErr;\n        if (!CZNC::Get().AddUser(pNewUser, sErr)) {\n            delete pNewUser;\n            PutModule(t_f(\"Error: User not added: {1}\")(sErr));\n            return;\n        }\n\n        PutModule(t_f(\"User {1} added!\")(sUsername));\n        return;\n    }\n\n    void DelUser(const CString& sLine) {\n        if (!GetUser()->IsAdmin()) {\n            PutModule(\n                t_s(\"Error: You need to have admin rights to delete users!\"));\n            return;\n        }\n\n        const CString sUsername = sLine.Token(1, true);\n        if (sUsername.empty()) {\n            PutModule(t_s(\"Usage: DelUser <username>\"));\n            return;\n        }\n\n        CUser* pUser = CZNC::Get().FindUser(sUsername);\n\n        if (!pUser) {\n            PutModule(t_f(\"Error: User [{1}] does not exist!\")(sUsername));\n            return;\n        }\n\n        if (pUser == GetUser()) {\n            PutModule(t_s(\"Error: You can't delete yourself!\"));\n            return;\n        }\n\n        if (!CZNC::Get().DeleteUser(pUser->GetUserName())) {\n            // This can't happen, because we got the user from FindUser()\n            PutModule(t_s(\"Error: Internal error!\"));\n            return;\n        }\n\n        PutModule(t_f(\"User {1} deleted!\")(sUsername));\n        return;\n    }\n\n    void CloneUser(const CString& sLine) {\n        if (!GetUser()->IsAdmin()) {\n            PutModule(\n                t_s(\"Error: You need to have admin rights to add new users!\"));\n            return;\n        }\n\n        const CString sOldUsername = sLine.Token(1),\n                      sNewUsername = sLine.Token(2, true);\n\n        if (sOldUsername.empty() || sNewUsername.empty()) {\n            PutModule(t_s(\"Usage: CloneUser <old username> <new username>\"));\n            return;\n        }\n\n        CUser* pOldUser = CZNC::Get().FindUser(sOldUsername);\n\n        if (!pOldUser) {\n            PutModule(t_f(\"Error: User [{1}] does not exist!\")(sOldUsername));\n            return;\n        }\n\n        CUser* pNewUser = new CUser(sNewUsername);\n        CString sError;\n        if (!pNewUser->Clone(*pOldUser, sError)) {\n            delete pNewUser;\n            PutModule(t_f(\"Error: Cloning failed: {1}\")(sError));\n            return;\n        }\n\n        if (!CZNC::Get().AddUser(pNewUser, sError)) {\n            delete pNewUser;\n            PutModule(t_f(\"Error: User not added: {1}\")(sError));\n            return;\n        }\n\n        PutModule(t_f(\"User {1} added!\")(sNewUsername));\n        return;\n    }\n\n    void AddNetwork(const CString& sLine) {\n        CString sUser = sLine.Token(1);\n        CString sNetwork = sLine.Token(2);\n        CUser* pUser = GetUser();\n\n        if (sNetwork.empty()) {\n            sNetwork = sUser;\n        } else {\n            pUser = FindUser(sUser);\n            if (!pUser) {\n                return;\n            }\n        }\n\n        if (sNetwork.empty()) {\n            PutModule(t_s(\"Usage: AddNetwork [user] network\"));\n            return;\n        }\n\n        if (!GetUser()->IsAdmin() && !pUser->HasSpaceForNewNetwork()) {\n            PutStatus(\n                t_s(\"Network number limit reached. Ask an admin to increase \"\n                    \"the limit for you, or delete unneeded networks using /znc \"\n                    \"DelNetwork <name>\"));\n            return;\n        }\n\n        if (pUser->FindNetwork(sNetwork)) {\n            PutModule(\n                t_f(\"Error: User {1} already has a network with the name {2}\")(\n                    pUser->GetUserName(), sNetwork));\n            return;\n        }\n\n        CString sNetworkAddError;\n        if (pUser->AddNetwork(sNetwork, sNetworkAddError)) {\n            PutModule(t_f(\"Network {1} added to user {2}.\")(\n                sNetwork, pUser->GetUserName()));\n        } else {\n            PutModule(t_f(\n                \"Error: Network [{1}] could not be added for user {2}: {3}\")(\n                sNetwork, pUser->GetUserName(), sNetworkAddError));\n        }\n    }\n\n    void DelNetwork(const CString& sLine) {\n        CString sUser = sLine.Token(1);\n        CString sNetwork = sLine.Token(2);\n        CUser* pUser = GetUser();\n\n        if (sNetwork.empty()) {\n            sNetwork = sUser;\n        } else {\n            pUser = FindUser(sUser);\n            if (!pUser) {\n                return;\n            }\n        }\n\n        if (sNetwork.empty()) {\n            PutModule(t_s(\"Usage: DelNetwork [user] network\"));\n            return;\n        }\n\n        CIRCNetwork* pNetwork = FindNetwork(pUser, sNetwork);\n        if (!pNetwork) {\n            return;\n        }\n\n        if (pNetwork == CModule::GetNetwork()) {\n            PutModule(t_f(\n                \"The currently active network can be deleted via {1}status\")(\n                GetUser()->GetStatusPrefix()));\n            return;\n        }\n\n        if (pUser->DeleteNetwork(sNetwork)) {\n            PutModule(t_f(\"Network {1} deleted for user {2}.\")(\n                sNetwork, pUser->GetUserName()));\n        } else {\n            PutModule(\n                t_f(\"Error: Network {1} could not be deleted for user {2}.\")(\n                    sNetwork, pUser->GetUserName()));\n        }\n    }\n\n    void ListNetworks(const CString& sLine) {\n        CString sUser = sLine.Token(1);\n        CUser* pUser = GetUser();\n\n        if (!sUser.empty()) {\n            pUser = FindUser(sUser);\n            if (!pUser) {\n                return;\n            }\n        }\n\n        const vector<CIRCNetwork*>& vNetworks = pUser->GetNetworks();\n\n        CTable Table;\n        Table.AddColumn(t_s(\"Network\", \"listnetworks\"));\n        Table.AddColumn(t_s(\"OnIRC\", \"listnetworks\"));\n        Table.AddColumn(t_s(\"IRC Server\", \"listnetworks\"));\n        Table.AddColumn(t_s(\"IRC User\", \"listnetworks\"));\n        Table.AddColumn(t_s(\"Channels\", \"listnetworks\"));\n\n        for (const CIRCNetwork* pNetwork : vNetworks) {\n            Table.AddRow();\n            Table.SetCell(t_s(\"Network\", \"listnetworks\"), pNetwork->GetName());\n            if (pNetwork->IsIRCConnected()) {\n                Table.SetCell(t_s(\"OnIRC\", \"listnetworks\"), t_s(\"Yes\"));\n                Table.SetCell(t_s(\"IRC Server\", \"listnetworks\"),\n                              pNetwork->GetIRCServer());\n                Table.SetCell(t_s(\"IRC User\", \"listnetworks\"),\n                              pNetwork->GetIRCNick().GetNickMask());\n                Table.SetCell(t_s(\"Channels\", \"listnetworks\"),\n                              CString(pNetwork->GetChans().size()));\n            } else {\n                Table.SetCell(t_s(\"OnIRC\", \"listnetworks\"), t_s(\"No\"));\n            }\n        }\n\n        if (PutModule(Table) == 0) {\n            PutModule(t_s(\"No networks\"));\n        }\n    }\n\n    void AddServer(const CString& sLine) {\n        CString sUsername = sLine.Token(1);\n        CString sNetwork = sLine.Token(2);\n        CString sServer = sLine.Token(3, true);\n\n        if (sServer.empty()) {\n            PutModule(\n                t_s(\"Usage: AddServer <username> <network> <server> [[+]port] \"\n                    \"[password]\"));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUsername);\n        if (!pUser) return;\n\n        CIRCNetwork* pNetwork = FindNetwork(pUser, sNetwork);\n        if (!pNetwork) {\n            return;\n        }\n\n        if (pNetwork->AddServer(sServer))\n            PutModule(t_f(\"Added IRC Server {1} to network {2} for user {3}.\")(\n                sServer, pNetwork->GetName(), pUser->GetUserName()));\n        else\n            PutModule(t_f(\n                \"Error: Could not add IRC server {1} to network {2} for user \"\n                \"{3}.\")(sServer, pNetwork->GetName(), pUser->GetUserName()));\n    }\n\n    void DelServer(const CString& sLine) {\n        CString sUsername = sLine.Token(1);\n        CString sNetwork = sLine.Token(2);\n        CString sServer = sLine.Token(3, true);\n        unsigned short uPort = sLine.Token(4).ToUShort();\n        CString sPass = sLine.Token(5);\n\n        if (sServer.empty()) {\n            PutModule(\n                t_s(\"Usage: DelServer <username> <network> <server> [[+]port] \"\n                    \"[password]\"));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUsername);\n        if (!pUser) return;\n\n        CIRCNetwork* pNetwork = FindNetwork(pUser, sNetwork);\n        if (!pNetwork) {\n            return;\n        }\n\n        if (pNetwork->DelServer(sServer, uPort, sPass))\n            PutModule(\n                t_f(\"Deleted IRC Server {1} from network {2} for user {3}.\")(\n                    sServer, pNetwork->GetName(), pUser->GetUserName()));\n        else\n            PutModule(\n                t_f(\"Error: Could not delete IRC server {1} from network {2} \"\n                    \"for user {3}.\")(sServer, pNetwork->GetName(),\n                                     pUser->GetUserName()));\n    }\n\n    void ReconnectUser(const CString& sLine) {\n        CString sUserName = sLine.Token(1);\n        CString sNetwork = sLine.Token(2);\n\n        if (sNetwork.empty()) {\n            PutModule(t_s(\"Usage: Reconnect <username> <network>\"));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUserName);\n        if (!pUser) {\n            return;\n        }\n\n        CIRCNetwork* pNetwork = FindNetwork(pUser, sNetwork);\n        if (!pNetwork) {\n            return;\n        }\n\n        CIRCSock* pIRCSock = pNetwork->GetIRCSock();\n        // cancel connection attempt:\n        if (pIRCSock && !pIRCSock->IsConnected()) {\n            pIRCSock->Close();\n        }\n        // or close existing connection:\n        else if (pIRCSock) {\n            pIRCSock->Quit();\n        }\n\n        // then reconnect\n        pNetwork->SetIRCConnectEnabled(true);\n\n        PutModule(t_f(\"Queued network {1} of user {2} for a reconnect.\")(\n            pNetwork->GetName(), pUser->GetUserName()));\n    }\n\n    void DisconnectUser(const CString& sLine) {\n        CString sUserName = sLine.Token(1);\n        CString sNetwork = sLine.Token(2);\n\n        if (sNetwork.empty()) {\n            PutModule(t_s(\"Usage: Disconnect <username> <network>\"));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUserName);\n        if (!pUser) {\n            return;\n        }\n\n        CIRCNetwork* pNetwork = FindNetwork(pUser, sNetwork);\n        if (!pNetwork) {\n            return;\n        }\n\n        pNetwork->SetIRCConnectEnabled(false);\n        PutModule(t_f(\"Closed IRC connection for network {1} of user {2}.\")(\n            pNetwork->GetName(), pUser->GetUserName()));\n    }\n\n    void ListCTCP(const CString& sLine) {\n        CString sUserName = sLine.Token(1, true);\n\n        if (sUserName.empty()) {\n            sUserName = GetUser()->GetUserName();\n        }\n        CUser* pUser = FindUser(sUserName);\n        if (!pUser) return;\n\n        const MCString& msCTCPReplies = pUser->GetCTCPReplies();\n        CTable Table;\n        Table.AddColumn(t_s(\"Request\", \"listctcp\"));\n        Table.AddColumn(t_s(\"Reply\", \"listctcp\"));\n        for (const auto& it : msCTCPReplies) {\n            Table.AddRow();\n            Table.SetCell(t_s(\"Request\", \"listctcp\"), it.first);\n            Table.SetCell(t_s(\"Reply\", \"listctcp\"), it.second);\n        }\n\n        if (Table.empty()) {\n            PutModule(t_f(\"No CTCP replies for user {1} are configured\")(\n                pUser->GetUserName()));\n        } else {\n            PutModule(t_f(\"CTCP replies for user {1}:\")(pUser->GetUserName()));\n            PutModule(Table);\n        }\n    }\n\n    void AddCTCP(const CString& sLine) {\n        CString sUserName = sLine.Token(1);\n        CString sCTCPRequest = sLine.Token(2);\n        CString sCTCPReply = sLine.Token(3, true);\n\n        if (sCTCPRequest.empty()) {\n            sCTCPRequest = sUserName;\n            sCTCPReply = sLine.Token(2, true);\n            sUserName = GetUser()->GetUserName();\n        }\n        if (sCTCPRequest.empty()) {\n            PutModule(t_s(\"Usage: AddCTCP [user] [request] [reply]\"));\n            PutModule(\n                t_s(\"This will cause ZNC to reply to the CTCP instead of \"\n                    \"forwarding it to clients.\"));\n            PutModule(t_s(\n                \"An empty reply will cause the CTCP request to be blocked.\"));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUserName);\n        if (!pUser) return;\n\n        pUser->AddCTCPReply(sCTCPRequest, sCTCPReply);\n        if (sCTCPReply.empty()) {\n            PutModule(t_f(\"CTCP requests {1} to user {2} will now be blocked.\")(\n                sCTCPRequest.AsUpper(), pUser->GetUserName()));\n        } else {\n            PutModule(\n                t_f(\"CTCP requests {1} to user {2} will now get reply: {3}\")(\n                    sCTCPRequest.AsUpper(), pUser->GetUserName(), sCTCPReply));\n        }\n    }\n\n    void DelCTCP(const CString& sLine) {\n        CString sUserName = sLine.Token(1);\n        CString sCTCPRequest = sLine.Token(2, true);\n\n        if (sCTCPRequest.empty()) {\n            sCTCPRequest = sUserName;\n            sUserName = GetUser()->GetUserName();\n        }\n        CUser* pUser = FindUser(sUserName);\n        if (!pUser) return;\n\n        if (sCTCPRequest.empty()) {\n            PutModule(t_s(\"Usage: DelCTCP [user] [request]\"));\n            return;\n        }\n\n        if (pUser->DelCTCPReply(sCTCPRequest)) {\n            PutModule(t_f(\n                \"CTCP requests {1} to user {2} will now be sent to IRC clients\")(\n                sCTCPRequest.AsUpper(), pUser->GetUserName()));\n        } else {\n            PutModule(\n                t_f(\"CTCP requests {1} to user {2} will be sent to IRC clients \"\n                    \"(nothing has changed)\")(sCTCPRequest.AsUpper(),\n                                             pUser->GetUserName()));\n        }\n    }\n\n    void LoadModuleFor(CModules& Modules, const CString& sModName,\n                       const CString& sArgs, CModInfo::EModuleType eType,\n                       CUser* pUser, CIRCNetwork* pNetwork) {\n        if (pUser->DenyLoadMod() && !GetUser()->IsAdmin()) {\n            PutModule(t_s(\"Loading modules has been disabled.\"));\n            return;\n        }\n\n        CString sModRet;\n        CModule* pMod = Modules.FindModule(sModName);\n        if (!pMod) {\n            if (!Modules.LoadModule(sModName, sArgs, eType, pUser, pNetwork,\n                                    sModRet)) {\n                PutModule(t_f(\"Error: Unable to load module {1}: {2}\")(\n                    sModName, sModRet));\n            } else {\n                PutModule(t_f(\"Loaded module {1}\")(sModName));\n            }\n        } else if (pMod->GetArgs() != sArgs) {\n            if (!Modules.ReloadModule(sModName, sArgs, pUser, pNetwork,\n                                      sModRet)) {\n                PutModule(t_f(\"Error: Unable to reload module {1}: {2}\")(\n                    sModName, sModRet));\n            } else {\n                PutModule(t_f(\"Reloaded module {1}\")(sModName));\n            }\n        } else {\n            PutModule(\n                t_f(\"Error: Unable to load module {1} because it is already \"\n                    \"loaded\")(sModName));\n        }\n    }\n\n    void LoadModuleForUser(const CString& sLine) {\n        CString sUsername = sLine.Token(1);\n        CString sModName = sLine.Token(2);\n        CString sArgs = sLine.Token(3, true);\n\n        if (sModName.empty()) {\n            PutModule(t_s(\"Usage: LoadModule <username> <modulename> [args]\"));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUsername);\n        if (!pUser) return;\n\n        LoadModuleFor(pUser->GetModules(), sModName, sArgs,\n                      CModInfo::UserModule, pUser, nullptr);\n    }\n\n    void LoadModuleForNetwork(const CString& sLine) {\n        CString sUsername = sLine.Token(1);\n        CString sNetwork = sLine.Token(2);\n        CString sModName = sLine.Token(3);\n        CString sArgs = sLine.Token(4, true);\n\n        if (sModName.empty()) {\n            PutModule(\n                t_s(\"Usage: LoadNetModule <username> <network> <modulename> \"\n                    \"[args]\"));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUsername);\n        if (!pUser) return;\n\n        CIRCNetwork* pNetwork = FindNetwork(pUser, sNetwork);\n        if (!pNetwork) {\n            return;\n        }\n\n        LoadModuleFor(pNetwork->GetModules(), sModName, sArgs,\n                      CModInfo::NetworkModule, pUser, pNetwork);\n    }\n\n    void UnLoadModuleFor(CModules& Modules, const CString& sModName,\n                         CUser* pUser) {\n        if (pUser->DenyLoadMod() && !GetUser()->IsAdmin()) {\n            PutModule(t_s(\"Loading modules has been disabled.\"));\n            return;\n        }\n\n        if (Modules.FindModule(sModName) == this) {\n            PutModule(t_f(\"Please use /znc unloadmod {1}\")(sModName));\n            return;\n        }\n\n        CString sModRet;\n        if (!Modules.UnloadModule(sModName, sModRet)) {\n            PutModule(t_f(\"Error: Unable to unload module {1}: {2}\")(sModName,\n                                                                     sModRet));\n        } else {\n            PutModule(t_f(\"Unloaded module {1}\")(sModName));\n        }\n    }\n\n    void UnLoadModuleForUser(const CString& sLine) {\n        CString sUsername = sLine.Token(1);\n        CString sModName = sLine.Token(2);\n\n        if (sModName.empty()) {\n            PutModule(t_s(\"Usage: UnloadModule <username> <modulename>\"));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUsername);\n        if (!pUser) return;\n\n        UnLoadModuleFor(pUser->GetModules(), sModName, pUser);\n    }\n\n    void UnLoadModuleForNetwork(const CString& sLine) {\n        CString sUsername = sLine.Token(1);\n        CString sNetwork = sLine.Token(2);\n        CString sModName = sLine.Token(3);\n\n        if (sModName.empty()) {\n            PutModule(t_s(\n                \"Usage: UnloadNetModule <username> <network> <modulename>\"));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUsername);\n        if (!pUser) return;\n\n        CIRCNetwork* pNetwork = FindNetwork(pUser, sNetwork);\n        if (!pNetwork) {\n            return;\n        }\n\n        UnLoadModuleFor(pNetwork->GetModules(), sModName, pUser);\n    }\n\n    void ListModulesFor(CModules& Modules) {\n        CTable Table;\n        Table.AddColumn(t_s(\"Name\", \"listmodules\"));\n        Table.AddColumn(t_s(\"Arguments\", \"listmodules\"));\n\n        for (const CModule* pMod : Modules) {\n            Table.AddRow();\n            Table.SetCell(t_s(\"Name\", \"listmodules\"), pMod->GetModName());\n            Table.SetCell(t_s(\"Arguments\", \"listmodules\"), pMod->GetArgs());\n        }\n\n        PutModule(Table);\n    }\n\n    void ListModulesForUser(const CString& sLine) {\n        CString sUsername = sLine.Token(1);\n\n        if (sUsername.empty()) {\n            PutModule(\"Usage: ListMods <username>\");\n            return;\n        }\n\n        CUser* pUser = FindUser(sUsername);\n        if (!pUser) return;\n\n        if (pUser->GetModules().empty()) {\n            PutModule(\n                t_f(\"User {1} has no modules loaded.\")(pUser->GetUserName()));\n            return;\n        }\n\n        PutModule(t_f(\"Modules loaded for user {1}:\")(pUser->GetUserName()));\n        ListModulesFor(pUser->GetModules());\n    }\n\n    void ListModulesForNetwork(const CString& sLine) {\n        CString sUsername = sLine.Token(1);\n        CString sNetwork = sLine.Token(2);\n\n        if (sNetwork.empty()) {\n            PutModule(\"Usage: ListNetMods <username> <network>\");\n            return;\n        }\n\n        CUser* pUser = FindUser(sUsername);\n        if (!pUser) return;\n\n        CIRCNetwork* pNetwork = FindNetwork(pUser, sNetwork);\n        if (!pNetwork) return;\n\n        if (pNetwork->GetModules().empty()) {\n            PutModule(t_f(\"Network {1} of user {2} has no modules loaded.\")(\n                pNetwork->GetName(), pUser->GetUserName()));\n            return;\n        }\n\n        PutModule(t_f(\"Modules loaded for network {1} of user {2}:\")(\n            pNetwork->GetName(), pUser->GetUserName()));\n        ListModulesFor(pNetwork->GetModules());\n    }\n\n  public:\n    MODCONSTRUCTOR(CAdminMod) {\n        AddCommand(\"Help\", t_d(\"[command] [variable]\"),\n                   t_d(\"Prints help for matching commands and variables\"),\n                   [=](const CString& sLine) { PrintHelp(sLine); });\n        AddCommand(\n            \"Get\", t_d(\"<variable> [username]\"),\n            t_d(\"Prints the variable's value for the given or current user\"),\n            [=](const CString& sLine) { Get(sLine); });\n        AddCommand(\"Set\", t_d(\"<variable> <username> <value>\"),\n                   t_d(\"Sets the variable's value for the given user\"),\n                   [=](const CString& sLine) { Set(sLine); });\n        AddCommand(\"GetNetwork\", t_d(\"<variable> [username] [network]\"),\n                   t_d(\"Prints the variable's value for the given network\"),\n                   [=](const CString& sLine) { GetNetwork(sLine); });\n        AddCommand(\"SetNetwork\", t_d(\"<variable> <username> <network> <value>\"),\n                   t_d(\"Sets the variable's value for the given network\"),\n                   [=](const CString& sLine) { SetNetwork(sLine); });\n        AddCommand(\"GetChan\", t_d(\"<variable> [username] <network> <chan>\"),\n                   t_d(\"Prints the variable's value for the given channel\"),\n                   [=](const CString& sLine) { GetChan(sLine); });\n        AddCommand(\"SetChan\",\n                   t_d(\"<variable> <username> <network> <chan> <value>\"),\n                   t_d(\"Sets the variable's value for the given channel\"),\n                   [=](const CString& sLine) { SetChan(sLine); });\n        AddCommand(\"AddChan\", t_d(\"<username> <network> <chan>\"),\n                   t_d(\"Adds a new channel\"),\n                   [=](const CString& sLine) { AddChan(sLine); });\n        AddCommand(\"DelChan\", t_d(\"<username> <network> <chan>\"),\n                   t_d(\"Deletes a channel\"),\n                   [=](const CString& sLine) { DelChan(sLine); });\n        AddCommand(\"ListUsers\", \"\", t_d(\"Lists users\"),\n                   [=](const CString& sLine) { ListUsers(sLine); });\n        AddCommand(\"AddUser\", t_d(\"<username> <password>\"),\n                   t_d(\"Adds a new user\"),\n                   [=](const CString& sLine) { AddUser(sLine); });\n        AddCommand(\"DelUser\", t_d(\"<username>\"), t_d(\"Deletes a user\"),\n                   [=](const CString& sLine) { DelUser(sLine); });\n        AddCommand(\"CloneUser\", t_d(\"<old username> <new username>\"),\n                   t_d(\"Clones a user\"),\n                   [=](const CString& sLine) { CloneUser(sLine); });\n        AddCommand(\"AddServer\", t_d(\"<username> <network> <server>\"),\n                   t_d(\"Adds a new IRC server for the given or current user\"),\n                   [=](const CString& sLine) { AddServer(sLine); });\n        AddCommand(\"DelServer\", t_d(\"<username> <network> <server>\"),\n                   t_d(\"Deletes an IRC server from the given or current user\"),\n                   [=](const CString& sLine) { DelServer(sLine); });\n        AddCommand(\"Reconnect\", t_d(\"<username> <network>\"),\n                   t_d(\"Cycles the user's IRC server connection\"),\n                   [=](const CString& sLine) { ReconnectUser(sLine); });\n        AddCommand(\"Disconnect\", t_d(\"<username> <network>\"),\n                   t_d(\"Disconnects the user from their IRC server\"),\n                   [=](const CString& sLine) { DisconnectUser(sLine); });\n        AddCommand(\"LoadModule\", t_d(\"<username> <modulename> [args]\"),\n                   t_d(\"Loads a Module for a user\"),\n                   [=](const CString& sLine) { LoadModuleForUser(sLine); });\n        AddCommand(\"UnLoadModule\", t_d(\"<username> <modulename>\"),\n                   t_d(\"Removes a Module of a user\"),\n                   [=](const CString& sLine) { UnLoadModuleForUser(sLine); });\n        AddCommand(\"ListMods\", t_d(\"<username>\"),\n                   t_d(\"Get the list of modules for a user\"),\n                   [=](const CString& sLine) { ListModulesForUser(sLine); });\n        AddCommand(\"LoadNetModule\",\n                   t_d(\"<username> <network> <modulename> [args]\"),\n                   t_d(\"Loads a Module for a network\"),\n                   [=](const CString& sLine) { LoadModuleForNetwork(sLine); });\n        AddCommand(\n            \"UnLoadNetModule\", t_d(\"<username> <network> <modulename>\"),\n            t_d(\"Removes a Module of a network\"),\n            [=](const CString& sLine) { UnLoadModuleForNetwork(sLine); });\n        AddCommand(\"ListNetMods\", t_d(\"<username> <network>\"),\n                   t_d(\"Get the list of modules for a network\"),\n                   [=](const CString& sLine) { ListModulesForNetwork(sLine); });\n        AddCommand(\"ListCTCPs\", t_d(\"<username>\"),\n                   t_d(\"List the configured CTCP replies\"),\n                   [=](const CString& sLine) { ListCTCP(sLine); });\n        AddCommand(\"AddCTCP\", t_d(\"<username> <ctcp> [reply]\"),\n                   t_d(\"Configure a new CTCP reply\"),\n                   [=](const CString& sLine) { AddCTCP(sLine); });\n        AddCommand(\"DelCTCP\", t_d(\"<username> <ctcp>\"),\n                   t_d(\"Remove a CTCP reply\"),\n                   [=](const CString& sLine) { DelCTCP(sLine); });\n\n        // Network commands\n        AddCommand(\"AddNetwork\", t_d(\"[username] <network>\"),\n                   t_d(\"Add a network for a user\"),\n                   [=](const CString& sLine) { AddNetwork(sLine); });\n        AddCommand(\"DelNetwork\", t_d(\"[username] <network>\"),\n                   t_d(\"Delete a network for a user\"),\n                   [=](const CString& sLine) { DelNetwork(sLine); });\n        AddCommand(\"ListNetworks\", t_d(\"[username]\"),\n                   t_d(\"List all networks for a user\"),\n                   [=](const CString& sLine) { ListNetworks(sLine); });\n    }\n\n    ~CAdminMod() override {}\n};\n\ntemplate <>\nvoid TModInfo<CAdminMod>(CModInfo& Info) {\n    Info.SetWikiPage(\"controlpanel\");\n}\n\nUSERMODULEDEFS(CAdminMod,\n               t_s(\"Dynamic configuration through IRC. Allows editing only \"\n               \"yourself if you're not ZNC admin.\"))\n", "/*\n * Copyright (C) 2004-2018 ZNC, see the NOTICE file for details.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <znc/IRCNetwork.h>\n#include <znc/User.h>\n#include <znc/FileUtils.h>\n#include <znc/Config.h>\n#include <znc/IRCSock.h>\n#include <znc/Server.h>\n#include <znc/Chan.h>\n#include <znc/Query.h>\n#include <znc/Message.h>\n#include <algorithm>\n#include <memory>\n\nusing std::vector;\nusing std::set;\n\nclass CIRCNetworkPingTimer : public CCron {\n  public:\n    CIRCNetworkPingTimer(CIRCNetwork* pNetwork)\n        : CCron(), m_pNetwork(pNetwork) {\n        SetName(\"CIRCNetworkPingTimer::\" +\n                m_pNetwork->GetUser()->GetUserName() + \"::\" +\n                m_pNetwork->GetName());\n        Start(m_pNetwork->GetUser()->GetPingSlack());\n    }\n\n    ~CIRCNetworkPingTimer() override {}\n\n    CIRCNetworkPingTimer(const CIRCNetworkPingTimer&) = delete;\n    CIRCNetworkPingTimer& operator=(const CIRCNetworkPingTimer&) = delete;\n\n  protected:\n    void RunJob() override {\n        CIRCSock* pIRCSock = m_pNetwork->GetIRCSock();\n        auto uFrequency = m_pNetwork->GetUser()->GetPingFrequency();\n\n        if (pIRCSock &&\n            pIRCSock->GetTimeSinceLastDataTransaction() >= uFrequency) {\n            pIRCSock->PutIRC(\"PING :ZNC\");\n        }\n\n        const vector<CClient*>& vClients = m_pNetwork->GetClients();\n        for (CClient* pClient : vClients) {\n            if (pClient->GetTimeSinceLastDataTransaction() >= uFrequency) {\n                pClient->PutClient(\"PING :ZNC\");\n            }\n        }\n\n        // Restart timer for the case if the period had changed. Usually this is\n        // noop\n        Start(m_pNetwork->GetUser()->GetPingSlack());\n    }\n\n  private:\n    CIRCNetwork* m_pNetwork;\n};\n\nclass CIRCNetworkJoinTimer : public CCron {\n    constexpr static int JOIN_FREQUENCY = 30 /* seconds */;\n\n  public:\n    CIRCNetworkJoinTimer(CIRCNetwork* pNetwork)\n        : CCron(), m_bDelayed(false), m_pNetwork(pNetwork) {\n        SetName(\"CIRCNetworkJoinTimer::\" +\n                m_pNetwork->GetUser()->GetUserName() + \"::\" +\n                m_pNetwork->GetName());\n        Start(JOIN_FREQUENCY);\n    }\n\n    ~CIRCNetworkJoinTimer() override {}\n\n    CIRCNetworkJoinTimer(const CIRCNetworkJoinTimer&) = delete;\n    CIRCNetworkJoinTimer& operator=(const CIRCNetworkJoinTimer&) = delete;\n\n    void Delay(unsigned short int uDelay) {\n        m_bDelayed = true;\n        Start(uDelay);\n    }\n\n  protected:\n    void RunJob() override {\n        if (m_bDelayed) {\n            m_bDelayed = false;\n            Start(JOIN_FREQUENCY);\n        }\n        if (m_pNetwork->IsIRCConnected()) {\n            m_pNetwork->JoinChans();\n        }\n    }\n\n  private:\n    bool m_bDelayed;\n    CIRCNetwork* m_pNetwork;\n};\n\nbool CIRCNetwork::IsValidNetwork(const CString& sNetwork) {\n    // ^[-\\w]+$\n\n    if (sNetwork.empty()) {\n        return false;\n    }\n\n    const char* p = sNetwork.c_str();\n    while (*p) {\n        if (*p != '_' && *p != '-' && !isalnum(*p)) {\n            return false;\n        }\n\n        p++;\n    }\n\n    return true;\n}\n\nCIRCNetwork::CIRCNetwork(CUser* pUser, const CString& sName)\n    : m_sName(sName),\n      m_pUser(nullptr),\n      m_sNick(\"\"),\n      m_sAltNick(\"\"),\n      m_sIdent(\"\"),\n      m_sRealName(\"\"),\n      m_sBindHost(\"\"),\n      m_sEncoding(\"\"),\n      m_sQuitMsg(\"\"),\n      m_ssTrustedFingerprints(),\n      m_pModules(new CModules),\n      m_vClients(),\n      m_pIRCSock(nullptr),\n      m_vChans(),\n      m_vQueries(),\n      m_sChanPrefixes(\"\"),\n      m_bIRCConnectEnabled(true),\n      m_bTrustAllCerts(false),\n      m_bTrustPKI(true),\n      m_sIRCServer(\"\"),\n      m_vServers(),\n      m_uServerIdx(0),\n      m_IRCNick(),\n      m_bIRCAway(false),\n      m_fFloodRate(2),\n      m_uFloodBurst(9),\n      m_RawBuffer(),\n      m_MotdBuffer(),\n      m_NoticeBuffer(),\n      m_pPingTimer(nullptr),\n      m_pJoinTimer(nullptr),\n      m_uJoinDelay(0),\n      m_uBytesRead(0),\n      m_uBytesWritten(0) {\n    SetUser(pUser);\n\n    // This should be more than enough raws, especially since we are buffering\n    // the MOTD separately\n    m_RawBuffer.SetLineCount(100, true);\n    // This should be more than enough motd lines\n    m_MotdBuffer.SetLineCount(200, true);\n    m_NoticeBuffer.SetLineCount(250, true);\n\n    m_pPingTimer = new CIRCNetworkPingTimer(this);\n    CZNC::Get().GetManager().AddCron(m_pPingTimer);\n\n    m_pJoinTimer = new CIRCNetworkJoinTimer(this);\n    CZNC::Get().GetManager().AddCron(m_pJoinTimer);\n\n    SetIRCConnectEnabled(true);\n}\n\nCIRCNetwork::CIRCNetwork(CUser* pUser, const CIRCNetwork& Network)\n    : CIRCNetwork(pUser, \"\") {\n    Clone(Network);\n}\n\nvoid CIRCNetwork::Clone(const CIRCNetwork& Network, bool bCloneName) {\n    if (bCloneName) {\n        m_sName = Network.GetName();\n    }\n\n    m_fFloodRate = Network.GetFloodRate();\n    m_uFloodBurst = Network.GetFloodBurst();\n    m_uJoinDelay = Network.GetJoinDelay();\n\n    SetNick(Network.GetNick());\n    SetAltNick(Network.GetAltNick());\n    SetIdent(Network.GetIdent());\n    SetRealName(Network.GetRealName());\n    SetBindHost(Network.GetBindHost());\n    SetEncoding(Network.GetEncoding());\n    SetQuitMsg(Network.GetQuitMsg());\n    m_ssTrustedFingerprints = Network.m_ssTrustedFingerprints;\n\n    // Servers\n    const vector<CServer*>& vServers = Network.GetServers();\n    CString sServer;\n    CServer* pCurServ = GetCurrentServer();\n\n    if (pCurServ) {\n        sServer = pCurServ->GetName();\n    }\n\n    DelServers();\n\n    for (CServer* pServer : vServers) {\n        AddServer(pServer->GetName(), pServer->GetPort(), pServer->GetPass(),\n                  pServer->IsSSL());\n    }\n\n    m_uServerIdx = 0;\n    for (size_t a = 0; a < m_vServers.size(); a++) {\n        if (sServer.Equals(m_vServers[a]->GetName())) {\n            m_uServerIdx = a + 1;\n            break;\n        }\n    }\n    if (m_uServerIdx == 0) {\n        m_uServerIdx = m_vServers.size();\n        CIRCSock* pSock = GetIRCSock();\n\n        if (pSock) {\n            PutStatus(\n                t_s(\"Jumping servers because this server is no longer in the \"\n                    \"list\"));\n            pSock->Quit();\n        }\n    }\n    // !Servers\n\n    // Chans\n    const vector<CChan*>& vChans = Network.GetChans();\n    for (CChan* pNewChan : vChans) {\n        CChan* pChan = FindChan(pNewChan->GetName());\n\n        if (pChan) {\n            pChan->SetInConfig(pNewChan->InConfig());\n        } else {\n            AddChan(pNewChan->GetName(), pNewChan->InConfig());\n        }\n    }\n\n    for (CChan* pChan : m_vChans) {\n        CChan* pNewChan = Network.FindChan(pChan->GetName());\n\n        if (!pNewChan) {\n            pChan->SetInConfig(false);\n        } else {\n            pChan->Clone(*pNewChan);\n        }\n    }\n    // !Chans\n\n    // Modules\n    set<CString> ssUnloadMods;\n    CModules& vCurMods = GetModules();\n    const CModules& vNewMods = Network.GetModules();\n\n    for (CModule* pNewMod : vNewMods) {\n        CString sModRet;\n        CModule* pCurMod = vCurMods.FindModule(pNewMod->GetModName());\n\n        if (!pCurMod) {\n            vCurMods.LoadModule(pNewMod->GetModName(), pNewMod->GetArgs(),\n                                CModInfo::NetworkModule, m_pUser, this,\n                                sModRet);\n        } else if (pNewMod->GetArgs() != pCurMod->GetArgs()) {\n            vCurMods.ReloadModule(pNewMod->GetModName(), pNewMod->GetArgs(),\n                                  m_pUser, this, sModRet);\n        }\n    }\n\n    for (CModule* pCurMod : vCurMods) {\n        CModule* pNewMod = vNewMods.FindModule(pCurMod->GetModName());\n\n        if (!pNewMod) {\n            ssUnloadMods.insert(pCurMod->GetModName());\n        }\n    }\n\n    for (const CString& sMod : ssUnloadMods) {\n        vCurMods.UnloadModule(sMod);\n    }\n    // !Modules\n\n    SetIRCConnectEnabled(Network.GetIRCConnectEnabled());\n}\n\nCIRCNetwork::~CIRCNetwork() {\n    if (m_pIRCSock) {\n        CZNC::Get().GetManager().DelSockByAddr(m_pIRCSock);\n        m_pIRCSock = nullptr;\n    }\n\n    // Delete clients\n    while (!m_vClients.empty()) {\n        CZNC::Get().GetManager().DelSockByAddr(m_vClients[0]);\n    }\n    m_vClients.clear();\n\n    // Delete servers\n    DelServers();\n\n    // Delete modules (this unloads all modules)\n    delete m_pModules;\n    m_pModules = nullptr;\n\n    // Delete Channels\n    for (CChan* pChan : m_vChans) {\n        delete pChan;\n    }\n    m_vChans.clear();\n\n    // Delete Queries\n    for (CQuery* pQuery : m_vQueries) {\n        delete pQuery;\n    }\n    m_vQueries.clear();\n\n    CUser* pUser = GetUser();\n    SetUser(nullptr);\n\n    // Make sure we are not in the connection queue\n    CZNC::Get().GetConnectionQueue().remove(this);\n\n    CZNC::Get().GetManager().DelCronByAddr(m_pPingTimer);\n    CZNC::Get().GetManager().DelCronByAddr(m_pJoinTimer);\n\n    if (pUser) {\n        pUser->AddBytesRead(m_uBytesRead);\n        pUser->AddBytesWritten(m_uBytesWritten);\n    } else {\n        CZNC::Get().AddBytesRead(m_uBytesRead);\n        CZNC::Get().AddBytesWritten(m_uBytesWritten);\n    }\n}\n\nvoid CIRCNetwork::DelServers() {\n    for (CServer* pServer : m_vServers) {\n        delete pServer;\n    }\n    m_vServers.clear();\n}\n\nCString CIRCNetwork::GetNetworkPath() const {\n    CString sNetworkPath = m_pUser->GetUserPath() + \"/networks/\" + m_sName;\n\n    if (!CFile::Exists(sNetworkPath)) {\n        CDir::MakeDir(sNetworkPath);\n    }\n\n    return sNetworkPath;\n}\n\ntemplate <class T>\nstruct TOption {\n    const char* name;\n    void (CIRCNetwork::*pSetter)(T);\n};\n\nbool CIRCNetwork::ParseConfig(CConfig* pConfig, CString& sError,\n                              bool bUpgrade) {\n    VCString vsList;\n\n    if (!bUpgrade) {\n        TOption<const CString&> StringOptions[] = {\n            {\"nick\", &CIRCNetwork::SetNick},\n            {\"altnick\", &CIRCNetwork::SetAltNick},\n            {\"ident\", &CIRCNetwork::SetIdent},\n            {\"realname\", &CIRCNetwork::SetRealName},\n            {\"bindhost\", &CIRCNetwork::SetBindHost},\n            {\"encoding\", &CIRCNetwork::SetEncoding},\n            {\"quitmsg\", &CIRCNetwork::SetQuitMsg},\n        };\n        TOption<bool> BoolOptions[] = {\n            {\"ircconnectenabled\", &CIRCNetwork::SetIRCConnectEnabled},\n            {\"trustallcerts\", &CIRCNetwork::SetTrustAllCerts},\n            {\"trustpki\", &CIRCNetwork::SetTrustPKI},\n        };\n        TOption<double> DoubleOptions[] = {\n            {\"floodrate\", &CIRCNetwork::SetFloodRate},\n        };\n        TOption<short unsigned int> SUIntOptions[] = {\n            {\"floodburst\", &CIRCNetwork::SetFloodBurst},\n            {\"joindelay\", &CIRCNetwork::SetJoinDelay},\n        };\n\n        for (const auto& Option : StringOptions) {\n            CString sValue;\n            if (pConfig->FindStringEntry(Option.name, sValue))\n                (this->*Option.pSetter)(sValue);\n        }\n\n        for (const auto& Option : BoolOptions) {\n            CString sValue;\n            if (pConfig->FindStringEntry(Option.name, sValue))\n                (this->*Option.pSetter)(sValue.ToBool());\n        }\n\n        for (const auto& Option : DoubleOptions) {\n            double fValue;\n            if (pConfig->FindDoubleEntry(Option.name, fValue))\n                (this->*Option.pSetter)(fValue);\n        }\n\n        for (const auto& Option : SUIntOptions) {\n            unsigned short value;\n            if (pConfig->FindUShortEntry(Option.name, value))\n                (this->*Option.pSetter)(value);\n        }\n\n        pConfig->FindStringVector(\"loadmodule\", vsList);\n        for (const CString& sValue : vsList) {\n            CString sModName = sValue.Token(0);\n            CString sNotice = \"Loading network module [\" + sModName + \"]\";\n\n            // XXX Legacy crap, added in ZNC 0.203, modified in 0.207\n            // Note that 0.203 == 0.207\n            if (sModName == \"away\") {\n                sNotice =\n                    \"NOTICE: [away] was renamed, loading [awaystore] instead\";\n                sModName = \"awaystore\";\n            }\n\n            // XXX Legacy crap, added in ZNC 0.207\n            if (sModName == \"autoaway\") {\n                sNotice =\n                    \"NOTICE: [autoaway] was renamed, loading [awaystore] \"\n                    \"instead\";\n                sModName = \"awaystore\";\n            }\n\n            // XXX Legacy crap, added in 1.1; fakeonline module was dropped in\n            // 1.0 and returned in 1.1\n            if (sModName == \"fakeonline\") {\n                sNotice =\n                    \"NOTICE: [fakeonline] was renamed, loading \"\n                    \"[modules_online] instead\";\n                sModName = \"modules_online\";\n            }\n\n            CString sModRet;\n            CString sArgs = sValue.Token(1, true);\n\n            bool bModRet = LoadModule(sModName, sArgs, sNotice, sModRet);\n\n            if (!bModRet) {\n                // XXX The awaynick module was retired in 1.6 (still available\n                // as external module)\n                if (sModName == \"awaynick\") {\n                    // load simple_away instead, unless it's already on the list\n                    bool bFound = false;\n                    for (const CString& sLoadMod : vsList) {\n                        if (sLoadMod.Token(0).Equals(\"simple_away\")) {\n                            bFound = true;\n                        }\n                    }\n                    if (!bFound) {\n                        sNotice =\n                            \"NOTICE: awaynick was retired, loading network \"\n                            \"module [simple_away] instead; if you still need \"\n                            \"awaynick, install it as an external module\";\n                        sModName = \"simple_away\";\n                        // not a fatal error if simple_away is not available\n                        LoadModule(sModName, sArgs, sNotice, sModRet);\n                    }\n                } else {\n                    sError = sModRet;\n                    return false;\n                }\n            }\n        }\n    }\n\n    pConfig->FindStringVector(\"server\", vsList);\n    for (const CString& sServer : vsList) {\n        CUtils::PrintAction(\"Adding server [\" + sServer + \"]\");\n        CUtils::PrintStatus(AddServer(sServer));\n    }\n\n    pConfig->FindStringVector(\"trustedserverfingerprint\", vsList);\n    for (const CString& sFP : vsList) {\n        AddTrustedFingerprint(sFP);\n    }\n\n    pConfig->FindStringVector(\"chan\", vsList);\n    for (const CString& sChan : vsList) {\n        AddChan(sChan, true);\n    }\n\n    CConfig::SubConfig subConf;\n    CConfig::SubConfig::const_iterator subIt;\n\n    pConfig->FindSubConfig(\"chan\", subConf);\n    for (subIt = subConf.begin(); subIt != subConf.end(); ++subIt) {\n        const CString& sChanName = subIt->first;\n        CConfig* pSubConf = subIt->second.m_pSubConfig;\n        CChan* pChan = new CChan(sChanName, this, true, pSubConf);\n\n        if (!pSubConf->empty()) {\n            sError = \"Unhandled lines in config for User [\" +\n                     m_pUser->GetUserName() + \"], Network [\" + GetName() +\n                     \"], Channel [\" + sChanName + \"]!\";\n            CUtils::PrintError(sError);\n\n            CZNC::DumpConfig(pSubConf);\n            delete pChan;\n            return false;\n        }\n\n        // Save the channel name, because AddChan\n        // deletes the CChannel*, if adding fails\n        sError = pChan->GetName();\n        if (!AddChan(pChan)) {\n            sError = \"Channel [\" + sError + \"] defined more than once\";\n            CUtils::PrintError(sError);\n            return false;\n        }\n        sError.clear();\n    }\n\n    return true;\n}\n\nCConfig CIRCNetwork::ToConfig() const {\n    CConfig config;\n\n    if (!m_sNick.empty()) {\n        config.AddKeyValuePair(\"Nick\", m_sNick);\n    }\n\n    if (!m_sAltNick.empty()) {\n        config.AddKeyValuePair(\"AltNick\", m_sAltNick);\n    }\n\n    if (!m_sIdent.empty()) {\n        config.AddKeyValuePair(\"Ident\", m_sIdent);\n    }\n\n    if (!m_sRealName.empty()) {\n        config.AddKeyValuePair(\"RealName\", m_sRealName);\n    }\n    if (!m_sBindHost.empty()) {\n        config.AddKeyValuePair(\"BindHost\", m_sBindHost);\n    }\n\n    config.AddKeyValuePair(\"IRCConnectEnabled\",\n                           CString(GetIRCConnectEnabled()));\n    config.AddKeyValuePair(\"TrustAllCerts\", CString(GetTrustAllCerts()));\n    config.AddKeyValuePair(\"TrustPKI\", CString(GetTrustPKI()));\n    config.AddKeyValuePair(\"FloodRate\", CString(GetFloodRate()));\n    config.AddKeyValuePair(\"FloodBurst\", CString(GetFloodBurst()));\n    config.AddKeyValuePair(\"JoinDelay\", CString(GetJoinDelay()));\n    config.AddKeyValuePair(\"Encoding\", m_sEncoding);\n\n    if (!m_sQuitMsg.empty()) {\n        config.AddKeyValuePair(\"QuitMsg\", m_sQuitMsg);\n    }\n\n    // Modules\n    const CModules& Mods = GetModules();\n\n    if (!Mods.empty()) {\n        for (CModule* pMod : Mods) {\n            CString sArgs = pMod->GetArgs();\n\n            if (!sArgs.empty()) {\n                sArgs = \" \" + sArgs;\n            }\n\n            config.AddKeyValuePair(\"LoadModule\", pMod->GetModName() + sArgs);\n        }\n    }\n\n    // Servers\n    for (CServer* pServer : m_vServers) {\n        config.AddKeyValuePair(\"Server\", pServer->GetString());\n    }\n\n    for (const CString& sFP : m_ssTrustedFingerprints) {\n        config.AddKeyValuePair(\"TrustedServerFingerprint\", sFP);\n    }\n\n    // Chans\n    for (CChan* pChan : m_vChans) {\n        if (pChan->InConfig()) {\n            config.AddSubConfig(\"Chan\", pChan->GetName(), pChan->ToConfig());\n        }\n    }\n\n    return config;\n}\n\nvoid CIRCNetwork::BounceAllClients() {\n    for (CClient* pClient : m_vClients) {\n        pClient->BouncedOff();\n    }\n\n    m_vClients.clear();\n}\n\nbool CIRCNetwork::IsUserOnline() const {\n    for (CClient* pClient : m_vClients) {\n        if (!pClient->IsAway()) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nvoid CIRCNetwork::ClientConnected(CClient* pClient) {\n    if (!m_pUser->MultiClients()) {\n        BounceAllClients();\n    }\n\n    m_vClients.push_back(pClient);\n\n    size_t uIdx, uSize;\n\n    if (m_pIRCSock) {\n        pClient->NotifyServerDependentCaps(m_pIRCSock->GetAcceptedCaps());\n    }\n\n    pClient->SetPlaybackActive(true);\n\n    if (m_RawBuffer.IsEmpty()) {\n        pClient->PutClient(\":irc.znc.in 001 \" + pClient->GetNick() +\n                           \" :\" + t_s(\"Welcome to ZNC\"));\n    } else {\n        const CString& sClientNick = pClient->GetNick(false);\n        MCString msParams;\n        msParams[\"target\"] = sClientNick;\n\n        uSize = m_RawBuffer.Size();\n        for (uIdx = 0; uIdx < uSize; uIdx++) {\n            pClient->PutClient(m_RawBuffer.GetLine(uIdx, *pClient, msParams));\n        }\n\n        const CNick& Nick = GetIRCNick();\n        if (sClientNick != Nick.GetNick()) {  // case-sensitive match\n            pClient->PutClient(\":\" + sClientNick + \"!\" + Nick.GetIdent() + \"@\" +\n                               Nick.GetHost() + \" NICK :\" + Nick.GetNick());\n            pClient->SetNick(Nick.GetNick());\n        }\n    }\n\n    MCString msParams;\n    msParams[\"target\"] = GetIRCNick().GetNick();\n\n    // Send the cached MOTD\n    uSize = m_MotdBuffer.Size();\n    if (uSize > 0) {\n        for (uIdx = 0; uIdx < uSize; uIdx++) {\n            pClient->PutClient(m_MotdBuffer.GetLine(uIdx, *pClient, msParams));\n        }\n    }\n\n    if (GetIRCSock() != nullptr) {\n        CString sUserMode(\"\");\n        const set<char>& scUserModes = GetIRCSock()->GetUserModes();\n        for (char cMode : scUserModes) {\n            sUserMode += cMode;\n        }\n        if (!sUserMode.empty()) {\n            pClient->PutClient(\":\" + GetIRCNick().GetNickMask() + \" MODE \" +\n                               GetIRCNick().GetNick() + \" :+\" + sUserMode);\n        }\n    }\n\n    if (m_bIRCAway) {\n        // If they want to know their away reason they'll have to whois\n        // themselves. At least we can tell them their away status...\n        pClient->PutClient(\":irc.znc.in 306 \" + GetIRCNick().GetNick() +\n                           \" :You have been marked as being away\");\n    }\n\n    const vector<CChan*>& vChans = GetChans();\n    for (CChan* pChan : vChans) {\n        if ((pChan->IsOn()) && (!pChan->IsDetached())) {\n            pChan->AttachUser(pClient);\n        }\n    }\n\n    bool bClearQuery = m_pUser->AutoClearQueryBuffer();\n    for (CQuery* pQuery : m_vQueries) {\n        pQuery->SendBuffer(pClient);\n        if (bClearQuery) {\n            delete pQuery;\n        }\n    }\n    if (bClearQuery) {\n        m_vQueries.clear();\n    }\n\n    uSize = m_NoticeBuffer.Size();\n    for (uIdx = 0; uIdx < uSize; uIdx++) {\n        const CBufLine& BufLine = m_NoticeBuffer.GetBufLine(uIdx);\n        CMessage Message(BufLine.GetLine(*pClient, msParams));\n        Message.SetNetwork(this);\n        Message.SetClient(pClient);\n        Message.SetTime(BufLine.GetTime());\n        Message.SetTags(BufLine.GetTags());\n        bool bContinue = false;\n        NETWORKMODULECALL(OnPrivBufferPlayMessage(Message), m_pUser, this,\n                          nullptr, &bContinue);\n        if (bContinue) continue;\n        pClient->PutClient(Message);\n    }\n    m_NoticeBuffer.Clear();\n\n    pClient->SetPlaybackActive(false);\n\n    // Tell them why they won't connect\n    if (!GetIRCConnectEnabled())\n        pClient->PutStatus(\n            t_s(\"You are currently disconnected from IRC. Use 'connect' to \"\n                \"reconnect.\"));\n}\n\nvoid CIRCNetwork::ClientDisconnected(CClient* pClient) {\n    auto it = std::find(m_vClients.begin(), m_vClients.end(), pClient);\n    if (it != m_vClients.end()) {\n        m_vClients.erase(it);\n    }\n}\n\nCUser* CIRCNetwork::GetUser() const { return m_pUser; }\n\nconst CString& CIRCNetwork::GetName() const { return m_sName; }\n\nstd::vector<CClient*> CIRCNetwork::FindClients(\n    const CString& sIdentifier) const {\n    std::vector<CClient*> vClients;\n    for (CClient* pClient : m_vClients) {\n        if (pClient->GetIdentifier().Equals(sIdentifier)) {\n            vClients.push_back(pClient);\n        }\n    }\n\n    return vClients;\n}\n\nvoid CIRCNetwork::SetUser(CUser* pUser) {\n    for (CClient* pClient : m_vClients) {\n        pClient->PutStatus(\n            t_s(\"This network is being deleted or moved to another user.\"));\n        pClient->SetNetwork(nullptr);\n    }\n\n    m_vClients.clear();\n\n    if (m_pUser) {\n        m_pUser->RemoveNetwork(this);\n    }\n\n    m_pUser = pUser;\n    if (m_pUser) {\n        m_pUser->AddNetwork(this);\n    }\n}\n\nbool CIRCNetwork::SetName(const CString& sName) {\n    if (IsValidNetwork(sName)) {\n        m_sName = sName;\n        return true;\n    }\n\n    return false;\n}\n\nbool CIRCNetwork::PutUser(const CString& sLine, CClient* pClient,\n                          CClient* pSkipClient) {\n    for (CClient* pEachClient : m_vClients) {\n        if ((!pClient || pClient == pEachClient) &&\n            pSkipClient != pEachClient) {\n            pEachClient->PutClient(sLine);\n\n            if (pClient) {\n                return true;\n            }\n        }\n    }\n\n    return (pClient == nullptr);\n}\n\nbool CIRCNetwork::PutUser(const CMessage& Message, CClient* pClient,\n                          CClient* pSkipClient) {\n    for (CClient* pEachClient : m_vClients) {\n        if ((!pClient || pClient == pEachClient) &&\n            pSkipClient != pEachClient) {\n            pEachClient->PutClient(Message);\n\n            if (pClient) {\n                return true;\n            }\n        }\n    }\n\n    return (pClient == nullptr);\n}\n\nbool CIRCNetwork::PutStatus(const CString& sLine, CClient* pClient,\n                            CClient* pSkipClient) {\n    for (CClient* pEachClient : m_vClients) {\n        if ((!pClient || pClient == pEachClient) &&\n            pSkipClient != pEachClient) {\n            pEachClient->PutStatus(sLine);\n\n            if (pClient) {\n                return true;\n            }\n        }\n    }\n\n    return (pClient == nullptr);\n}\n\nbool CIRCNetwork::PutModule(const CString& sModule, const CString& sLine,\n                            CClient* pClient, CClient* pSkipClient) {\n    for (CClient* pEachClient : m_vClients) {\n        if ((!pClient || pClient == pEachClient) &&\n            pSkipClient != pEachClient) {\n            pEachClient->PutModule(sModule, sLine);\n\n            if (pClient) {\n                return true;\n            }\n        }\n    }\n\n    return (pClient == nullptr);\n}\n\n// Channels\n\nconst vector<CChan*>& CIRCNetwork::GetChans() const { return m_vChans; }\n\nCChan* CIRCNetwork::FindChan(CString sName) const {\n    if (GetIRCSock()) {\n        // See\n        // https://tools.ietf.org/html/draft-brocklesby-irc-isupport-03#section-3.16\n        sName.TrimLeft(GetIRCSock()->GetISupport(\"STATUSMSG\", \"\"));\n    }\n\n    for (CChan* pChan : m_vChans) {\n        if (sName.Equals(pChan->GetName())) {\n            return pChan;\n        }\n    }\n\n    return nullptr;\n}\n\nstd::vector<CChan*> CIRCNetwork::FindChans(const CString& sWild) const {\n    std::vector<CChan*> vChans;\n    vChans.reserve(m_vChans.size());\n    const CString sLower = sWild.AsLower();\n    for (CChan* pChan : m_vChans) {\n        if (pChan->GetName().AsLower().WildCmp(sLower)) vChans.push_back(pChan);\n    }\n    return vChans;\n}\n\nbool CIRCNetwork::AddChan(CChan* pChan) {\n    if (!pChan) {\n        return false;\n    }\n\n    for (CChan* pEachChan : m_vChans) {\n        if (pEachChan->GetName().Equals(pChan->GetName())) {\n            delete pChan;\n            return false;\n        }\n    }\n\n    m_vChans.push_back(pChan);\n    return true;\n}\n\nbool CIRCNetwork::AddChan(const CString& sName, bool bInConfig) {\n    if (sName.empty() || FindChan(sName)) {\n        return false;\n    }\n\n    CChan* pChan = new CChan(sName, this, bInConfig);\n    m_vChans.push_back(pChan);\n    return true;\n}\n\nbool CIRCNetwork::DelChan(const CString& sName) {\n    for (vector<CChan*>::iterator a = m_vChans.begin(); a != m_vChans.end();\n         ++a) {\n        if (sName.Equals((*a)->GetName())) {\n            delete *a;\n            m_vChans.erase(a);\n            return true;\n        }\n    }\n\n    return false;\n}\n\nvoid CIRCNetwork::JoinChans() {\n    // Avoid divsion by zero, it's bad!\n    if (m_vChans.empty()) return;\n\n    // We start at a random offset into the channel list so that if your\n    // first 3 channels are invite-only and you got MaxJoins == 3, ZNC will\n    // still be able to join the rest of your channels.\n    unsigned int start = rand() % m_vChans.size();\n    unsigned int uJoins = m_pUser->MaxJoins();\n    set<CChan*> sChans;\n    for (unsigned int a = 0; a < m_vChans.size(); a++) {\n        unsigned int idx = (start + a) % m_vChans.size();\n        CChan* pChan = m_vChans[idx];\n        if (!pChan->IsOn() && !pChan->IsDisabled()) {\n            if (!JoinChan(pChan)) continue;\n\n            sChans.insert(pChan);\n\n            // Limit the number of joins\n            if (uJoins != 0 && --uJoins == 0) {\n                // Reset the timer.\n                m_pJoinTimer->Reset();\n                break;\n            }\n        }\n    }\n\n    while (!sChans.empty()) JoinChans(sChans);\n}\n\nvoid CIRCNetwork::JoinChans(set<CChan*>& sChans) {\n    CString sKeys, sJoin;\n    bool bHaveKey = false;\n    size_t uiJoinLength = strlen(\"JOIN \");\n\n    while (!sChans.empty()) {\n        set<CChan*>::iterator it = sChans.begin();\n        const CString& sName = (*it)->GetName();\n        const CString& sKey = (*it)->GetKey();\n        size_t len = sName.length() + sKey.length();\n        len += 2;  // two comma\n\n        if (!sKeys.empty() && uiJoinLength + len >= 512) break;\n\n        if (!sJoin.empty()) {\n            sJoin += \",\";\n            sKeys += \",\";\n        }\n        uiJoinLength += len;\n        sJoin += sName;\n        if (!sKey.empty()) {\n            sKeys += sKey;\n            bHaveKey = true;\n        }\n        sChans.erase(it);\n    }\n\n    if (bHaveKey)\n        PutIRC(\"JOIN \" + sJoin + \" \" + sKeys);\n    else\n        PutIRC(\"JOIN \" + sJoin);\n}\n\nbool CIRCNetwork::JoinChan(CChan* pChan) {\n    bool bReturn = false;\n    NETWORKMODULECALL(OnJoining(*pChan), m_pUser, this, nullptr, &bReturn);\n\n    if (bReturn) return false;\n\n    if (m_pUser->JoinTries() != 0 &&\n        pChan->GetJoinTries() >= m_pUser->JoinTries()) {\n        PutStatus(t_f(\"The channel {1} could not be joined, disabling it.\")(\n            pChan->GetName()));\n        pChan->Disable();\n    } else {\n        pChan->IncJoinTries();\n        bool bFailed = false;\n        NETWORKMODULECALL(OnTimerAutoJoin(*pChan), m_pUser, this, nullptr,\n                          &bFailed);\n        if (bFailed) return false;\n        return true;\n    }\n    return false;\n}\n\nbool CIRCNetwork::IsChan(const CString& sChan) const {\n    if (sChan.empty()) return false;  // There is no way this is a chan\n    if (GetChanPrefixes().empty())\n        return true;  // We can't know, so we allow everything\n    // Thanks to the above if (empty), we can do sChan[0]\n    return GetChanPrefixes().find(sChan[0]) != CString::npos;\n}\n\n// Queries\n\nconst vector<CQuery*>& CIRCNetwork::GetQueries() const { return m_vQueries; }\n\nCQuery* CIRCNetwork::FindQuery(const CString& sName) const {\n    for (CQuery* pQuery : m_vQueries) {\n        if (sName.Equals(pQuery->GetName())) {\n            return pQuery;\n        }\n    }\n\n    return nullptr;\n}\n\nstd::vector<CQuery*> CIRCNetwork::FindQueries(const CString& sWild) const {\n    std::vector<CQuery*> vQueries;\n    vQueries.reserve(m_vQueries.size());\n    const CString sLower = sWild.AsLower();\n    for (CQuery* pQuery : m_vQueries) {\n        if (pQuery->GetName().AsLower().WildCmp(sLower))\n            vQueries.push_back(pQuery);\n    }\n    return vQueries;\n}\n\nCQuery* CIRCNetwork::AddQuery(const CString& sName) {\n    if (sName.empty()) {\n        return nullptr;\n    }\n\n    CQuery* pQuery = FindQuery(sName);\n    if (!pQuery) {\n        pQuery = new CQuery(sName, this);\n        m_vQueries.push_back(pQuery);\n\n        if (m_pUser->MaxQueryBuffers() > 0) {\n            while (m_vQueries.size() > m_pUser->MaxQueryBuffers()) {\n                delete *m_vQueries.begin();\n                m_vQueries.erase(m_vQueries.begin());\n            }\n        }\n    }\n\n    return pQuery;\n}\n\nbool CIRCNetwork::DelQuery(const CString& sName) {\n    for (vector<CQuery*>::iterator a = m_vQueries.begin();\n         a != m_vQueries.end(); ++a) {\n        if (sName.Equals((*a)->GetName())) {\n            delete *a;\n            m_vQueries.erase(a);\n            return true;\n        }\n    }\n\n    return false;\n}\n\n// Server list\n\nconst vector<CServer*>& CIRCNetwork::GetServers() const { return m_vServers; }\n\nCServer* CIRCNetwork::FindServer(const CString& sName) const {\n    for (CServer* pServer : m_vServers) {\n        if (sName.Equals(pServer->GetName())) {\n            return pServer;\n        }\n    }\n\n    return nullptr;\n}\n\nbool CIRCNetwork::DelServer(const CString& sName, unsigned short uPort,\n                            const CString& sPass) {\n    if (sName.empty()) {\n        return false;\n    }\n\n    unsigned int a = 0;\n    bool bSawCurrentServer = false;\n    CServer* pCurServer = GetCurrentServer();\n\n    for (vector<CServer*>::iterator it = m_vServers.begin();\n         it != m_vServers.end(); ++it, a++) {\n        CServer* pServer = *it;\n\n        if (pServer == pCurServer) bSawCurrentServer = true;\n\n        if (!pServer->GetName().Equals(sName)) continue;\n\n        if (uPort != 0 && pServer->GetPort() != uPort) continue;\n\n        if (!sPass.empty() && pServer->GetPass() != sPass) continue;\n\n        m_vServers.erase(it);\n\n        if (pServer == pCurServer) {\n            CIRCSock* pIRCSock = GetIRCSock();\n\n            // Make sure we don't skip the next server in the list!\n            if (m_uServerIdx) {\n                m_uServerIdx--;\n            }\n\n            if (pIRCSock) {\n                pIRCSock->Quit();\n                PutStatus(t_s(\"Your current server was removed, jumping...\"));\n            }\n        } else if (!bSawCurrentServer) {\n            // Our current server comes after the server which we\n            // are removing. This means that it now got a different\n            // index in m_vServers!\n            m_uServerIdx--;\n        }\n\n        delete pServer;\n\n        return true;\n    }\n\n    return false;\n}\n\nbool CIRCNetwork::AddServer(const CString& sName) {\n    if (sName.empty()) {\n        return false;\n    }\n\n    bool bSSL = false;\n    CString sLine = sName;\n    sLine.Trim();\n\n    CString sHost = sLine.Token(0);\n    CString sPort = sLine.Token(1);\n\n    if (sPort.TrimPrefix(\"+\")) {\n        bSSL = true;\n    }\n\n    unsigned short uPort = sPort.ToUShort();\n    CString sPass = sLine.Token(2, true);\n\n    return AddServer(sHost, uPort, sPass, bSSL);\n}\n\nbool CIRCNetwork::AddServer(const CString& sName, unsigned short uPort,\n                            const CString& sPass, bool bSSL) {\n#ifndef HAVE_LIBSSL\n    if (bSSL) {\n        return false;\n    }\n#endif\n\n    if (sName.empty()) {\n        return false;\n    }\n\n    if (!uPort) {\n        uPort = 6667;\n    }\n\n    // Check if server is already added\n    for (CServer* pServer : m_vServers) {\n        if (!sName.Equals(pServer->GetName())) continue;\n\n        if (uPort != pServer->GetPort()) continue;\n\n        if (sPass != pServer->GetPass()) continue;\n\n        if (bSSL != pServer->IsSSL()) continue;\n\n        // Server is already added\n        return false;\n    }\n\n    CServer* pServer = new CServer(sName, uPort, sPass, bSSL);\n    m_vServers.push_back(pServer);\n\n    CheckIRCConnect();\n\n    return true;\n}\n\nCServer* CIRCNetwork::GetNextServer(bool bAdvance) {\n    if (m_vServers.empty()) {\n        return nullptr;\n    }\n\n    if (m_uServerIdx >= m_vServers.size()) {\n        m_uServerIdx = 0;\n    }\n\n    if (bAdvance) {\n        return m_vServers[m_uServerIdx++];\n    } else {\n        return m_vServers[m_uServerIdx];\n    }\n}\n\nCServer* CIRCNetwork::GetCurrentServer() const {\n    size_t uIdx = (m_uServerIdx) ? m_uServerIdx - 1 : 0;\n\n    if (uIdx >= m_vServers.size()) {\n        return nullptr;\n    }\n\n    return m_vServers[uIdx];\n}\n\nvoid CIRCNetwork::SetIRCServer(const CString& s) { m_sIRCServer = s; }\n\nbool CIRCNetwork::SetNextServer(const CServer* pServer) {\n    for (unsigned int a = 0; a < m_vServers.size(); a++) {\n        if (m_vServers[a] == pServer) {\n            m_uServerIdx = a;\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool CIRCNetwork::IsLastServer() const {\n    return (m_uServerIdx >= m_vServers.size());\n}\n\nconst CString& CIRCNetwork::GetIRCServer() const { return m_sIRCServer; }\nconst CNick& CIRCNetwork::GetIRCNick() const { return m_IRCNick; }\n\nvoid CIRCNetwork::SetIRCNick(const CNick& n) {\n    m_IRCNick = n;\n\n    for (CClient* pClient : m_vClients) {\n        pClient->SetNick(n.GetNick());\n    }\n}\n\nCString CIRCNetwork::GetCurNick() const {\n    const CIRCSock* pIRCSock = GetIRCSock();\n\n    if (pIRCSock) {\n        return pIRCSock->GetNick();\n    }\n\n    if (!m_vClients.empty()) {\n        return m_vClients[0]->GetNick();\n    }\n\n    return \"\";\n}\n\nbool CIRCNetwork::Connect() {\n    if (!GetIRCConnectEnabled() || m_pIRCSock || !HasServers()) return false;\n\n    CServer* pServer = GetNextServer();\n    if (!pServer) return false;\n\n    if (CZNC::Get().GetServerThrottle(pServer->GetName())) {\n        // Can't connect right now, schedule retry later\n        CZNC::Get().AddNetworkToQueue(this);\n        return false;\n    }\n\n    CZNC::Get().AddServerThrottle(pServer->GetName());\n\n    bool bSSL = pServer->IsSSL();\n#ifndef HAVE_LIBSSL\n    if (bSSL) {\n        PutStatus(\n            t_f(\"Cannot connect to {1}, because ZNC is not compiled with SSL \"\n                \"support.\")(pServer->GetString(false)));\n        CZNC::Get().AddNetworkToQueue(this);\n        return false;\n    }\n#endif\n\n    CIRCSock* pIRCSock = new CIRCSock(this);\n    pIRCSock->SetPass(pServer->GetPass());\n    pIRCSock->SetSSLTrustedPeerFingerprints(m_ssTrustedFingerprints);\n    pIRCSock->SetTrustAllCerts(GetTrustAllCerts());\n    pIRCSock->SetTrustPKI(GetTrustPKI());\n\n    DEBUG(\"Connecting user/network [\" << m_pUser->GetUserName() << \"/\"\n                                      << m_sName << \"]\");\n\n    bool bAbort = false;\n    NETWORKMODULECALL(OnIRCConnecting(pIRCSock), m_pUser, this, nullptr,\n                      &bAbort);\n    if (bAbort) {\n        DEBUG(\"Some module aborted the connection attempt\");\n        PutStatus(t_s(\"Some module aborted the connection attempt\"));\n        delete pIRCSock;\n        CZNC::Get().AddNetworkToQueue(this);\n        return false;\n    }\n\n    CString sSockName = \"IRC::\" + m_pUser->GetUserName() + \"::\" + m_sName;\n    CZNC::Get().GetManager().Connect(pServer->GetName(), pServer->GetPort(),\n                                     sSockName, 120, bSSL, GetBindHost(),\n                                     pIRCSock);\n\n    return true;\n}\n\nbool CIRCNetwork::IsIRCConnected() const {\n    const CIRCSock* pSock = GetIRCSock();\n    return (pSock && pSock->IsAuthed());\n}\n\nvoid CIRCNetwork::SetIRCSocket(CIRCSock* pIRCSock) { m_pIRCSock = pIRCSock; }\n\nvoid CIRCNetwork::IRCConnected() {\n    const SCString& ssCaps = m_pIRCSock->GetAcceptedCaps();\n    for (CClient* pClient : m_vClients) {\n        pClient->NotifyServerDependentCaps(ssCaps);\n    }\n    if (m_uJoinDelay > 0) {\n        m_pJoinTimer->Delay(m_uJoinDelay);\n    } else {\n        JoinChans();\n    }\n}\n\nvoid CIRCNetwork::IRCDisconnected() {\n    for (CClient* pClient : m_vClients) {\n        pClient->ClearServerDependentCaps();\n    }\n    m_pIRCSock = nullptr;\n\n    SetIRCServer(\"\");\n    m_bIRCAway = false;\n\n    // Get the reconnect going\n    CheckIRCConnect();\n}\n\nvoid CIRCNetwork::SetIRCConnectEnabled(bool b) {\n    m_bIRCConnectEnabled = b;\n\n    if (m_bIRCConnectEnabled) {\n        CheckIRCConnect();\n    } else if (GetIRCSock()) {\n        if (GetIRCSock()->IsConnected()) {\n            GetIRCSock()->Quit();\n        } else {\n            GetIRCSock()->Close();\n        }\n    }\n}\n\nvoid CIRCNetwork::CheckIRCConnect() {\n    // Do we want to connect?\n    if (GetIRCConnectEnabled() && GetIRCSock() == nullptr)\n        CZNC::Get().AddNetworkToQueue(this);\n}\n\nbool CIRCNetwork::PutIRC(const CString& sLine) {\n    CIRCSock* pIRCSock = GetIRCSock();\n\n    if (!pIRCSock) {\n        return false;\n    }\n\n    pIRCSock->PutIRC(sLine);\n    return true;\n}\n\nbool CIRCNetwork::PutIRC(const CMessage& Message) {\n    CIRCSock* pIRCSock = GetIRCSock();\n\n    if (!pIRCSock) {\n        return false;\n    }\n\n    pIRCSock->PutIRC(Message);\n    return true;\n}\n\nvoid CIRCNetwork::ClearQueryBuffer() {\n    std::for_each(m_vQueries.begin(), m_vQueries.end(),\n                  std::default_delete<CQuery>());\n    m_vQueries.clear();\n}\n\nconst CString& CIRCNetwork::GetNick(const bool bAllowDefault) const {\n    if (m_sNick.empty()) {\n        return m_pUser->GetNick(bAllowDefault);\n    }\n\n    return m_sNick;\n}\n\nconst CString& CIRCNetwork::GetAltNick(const bool bAllowDefault) const {\n    if (m_sAltNick.empty()) {\n        return m_pUser->GetAltNick(bAllowDefault);\n    }\n\n    return m_sAltNick;\n}\n\nconst CString& CIRCNetwork::GetIdent(const bool bAllowDefault) const {\n    if (m_sIdent.empty()) {\n        return m_pUser->GetIdent(bAllowDefault);\n    }\n\n    return m_sIdent;\n}\n\nCString CIRCNetwork::GetRealName() const {\n    if (m_sRealName.empty()) {\n        return m_pUser->GetRealName();\n    }\n\n    return m_sRealName;\n}\n\nconst CString& CIRCNetwork::GetBindHost() const {\n    if (m_sBindHost.empty()) {\n        return m_pUser->GetBindHost();\n    }\n\n    return m_sBindHost;\n}\n\nconst CString& CIRCNetwork::GetEncoding() const { return m_sEncoding; }\n\nCString CIRCNetwork::GetQuitMsg() const {\n    if (m_sQuitMsg.empty()) {\n        return m_pUser->GetQuitMsg();\n    }\n\n    return m_sQuitMsg;\n}\n\nvoid CIRCNetwork::SetNick(const CString& s) {\n    if (m_pUser->GetNick().Equals(s)) {\n        m_sNick = \"\";\n    } else {\n        m_sNick = s;\n    }\n}\n\nvoid CIRCNetwork::SetAltNick(const CString& s) {\n    if (m_pUser->GetAltNick().Equals(s)) {\n        m_sAltNick = \"\";\n    } else {\n        m_sAltNick = s;\n    }\n}\n\nvoid CIRCNetwork::SetIdent(const CString& s) {\n    if (m_pUser->GetIdent().Equals(s)) {\n        m_sIdent = \"\";\n    } else {\n        m_sIdent = s;\n    }\n}\n\nvoid CIRCNetwork::SetRealName(const CString& s) {\n    if (m_pUser->GetRealName().Equals(s)) {\n        m_sRealName = \"\";\n    } else {\n        m_sRealName = s;\n    }\n}\n\nvoid CIRCNetwork::SetBindHost(const CString& s) {\n    if (m_pUser->GetBindHost().Equals(s)) {\n        m_sBindHost = \"\";\n    } else {\n        m_sBindHost = s;\n    }\n}\n\nvoid CIRCNetwork::SetEncoding(const CString& s) {\n    m_sEncoding = s;\n    if (GetIRCSock()) {\n        GetIRCSock()->SetEncoding(s);\n    }\n}\n\nvoid CIRCNetwork::SetQuitMsg(const CString& s) {\n    if (m_pUser->GetQuitMsg().Equals(s)) {\n        m_sQuitMsg = \"\";\n    } else {\n        m_sQuitMsg = s;\n    }\n}\n\nCString CIRCNetwork::ExpandString(const CString& sStr) const {\n    CString sRet;\n    return ExpandString(sStr, sRet);\n}\n\nCString& CIRCNetwork::ExpandString(const CString& sStr, CString& sRet) const {\n    sRet = sStr;\n\n    sRet.Replace(\"%altnick%\", GetAltNick());\n    sRet.Replace(\"%bindhost%\", GetBindHost());\n    sRet.Replace(\"%defnick%\", GetNick());\n    sRet.Replace(\"%ident%\", GetIdent());\n    sRet.Replace(\"%network%\", GetName());\n    sRet.Replace(\"%nick%\", GetCurNick());\n    sRet.Replace(\"%realname%\", GetRealName());\n\n    return m_pUser->ExpandString(sRet, sRet);\n}\n\nbool CIRCNetwork::LoadModule(const CString& sModName, const CString& sArgs,\n                             const CString& sNotice, CString& sError) {\n    CUtils::PrintAction(sNotice);\n    CString sModRet;\n\n    bool bModRet = GetModules().LoadModule(\n        sModName, sArgs, CModInfo::NetworkModule, GetUser(), this, sModRet);\n\n    CUtils::PrintStatus(bModRet, sModRet);\n    if (!bModRet) {\n        sError = sModRet;\n    }\n    return bModRet;\n}\n", "/*\n * Copyright (C) 2004-2018 ZNC, see the NOTICE file for details.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <znc/User.h>\n#include <znc/Config.h>\n#include <znc/FileUtils.h>\n#include <znc/IRCNetwork.h>\n#include <znc/IRCSock.h>\n#include <znc/Chan.h>\n#include <znc/Query.h>\n#include <math.h>\n#include <time.h>\n#include <algorithm>\n\nusing std::vector;\nusing std::set;\n\nclass CUserTimer : public CCron {\n  public:\n    CUserTimer(CUser* pUser) : CCron(), m_pUser(pUser) {\n        SetName(\"CUserTimer::\" + m_pUser->GetUserName());\n        Start(m_pUser->GetPingSlack());\n    }\n    ~CUserTimer() override {}\n\n    CUserTimer(const CUserTimer&) = delete;\n    CUserTimer& operator=(const CUserTimer&) = delete;\n\n  private:\n  protected:\n    void RunJob() override {\n        const vector<CClient*>& vUserClients = m_pUser->GetUserClients();\n\n        for (CClient* pUserClient : vUserClients) {\n            if (pUserClient->GetTimeSinceLastDataTransaction() >=\n                m_pUser->GetPingFrequency()) {\n                pUserClient->PutClient(\"PING :ZNC\");\n            }\n        }\n\n        // Restart timer for the case if the period had changed. Usually this is\n        // noop\n        Start(m_pUser->GetPingSlack());\n    }\n\n    CUser* m_pUser;\n};\n\nCUser::CUser(const CString& sUserName)\n    : m_sUserName(sUserName),\n      m_sCleanUserName(MakeCleanUserName(sUserName)),\n      m_sNick(m_sCleanUserName),\n      m_sAltNick(\"\"),\n      m_sIdent(m_sCleanUserName),\n      m_sRealName(\"\"),\n      m_sBindHost(\"\"),\n      m_sDCCBindHost(\"\"),\n      m_sPass(\"\"),\n      m_sPassSalt(\"\"),\n      m_sStatusPrefix(\"*\"),\n      m_sDefaultChanModes(\"\"),\n      m_sClientEncoding(\"\"),\n      m_sQuitMsg(\"\"),\n      m_mssCTCPReplies(),\n      m_sTimestampFormat(\"[%H:%M:%S]\"),\n      m_sTimezone(\"\"),\n      m_eHashType(HASH_NONE),\n      m_sUserPath(CZNC::Get().GetUserPath() + \"/\" + sUserName),\n      m_bMultiClients(true),\n      m_bDenyLoadMod(false),\n      m_bAdmin(false),\n      m_bDenySetBindHost(false),\n      m_bAutoClearChanBuffer(true),\n      m_bAutoClearQueryBuffer(true),\n      m_bBeingDeleted(false),\n      m_bAppendTimestamp(false),\n      m_bPrependTimestamp(true),\n      m_bAuthOnlyViaModule(false),\n      m_pUserTimer(nullptr),\n      m_vIRCNetworks(),\n      m_vClients(),\n      m_ssAllowedHosts(),\n      m_uChanBufferSize(50),\n      m_uQueryBufferSize(50),\n      m_uBytesRead(0),\n      m_uBytesWritten(0),\n      m_uMaxJoinTries(10),\n      m_uMaxNetworks(1),\n      m_uMaxQueryBuffers(50),\n      m_uMaxJoins(0),\n      m_uNoTrafficTimeout(180),\n      m_sSkinName(\"\"),\n      m_pModules(new CModules) {\n    m_pUserTimer = new CUserTimer(this);\n    CZNC::Get().GetManager().AddCron(m_pUserTimer);\n}\n\nCUser::~CUser() {\n    // Delete networks\n    while (!m_vIRCNetworks.empty()) {\n        delete *m_vIRCNetworks.begin();\n    }\n\n    // Delete clients\n    while (!m_vClients.empty()) {\n        CZNC::Get().GetManager().DelSockByAddr(m_vClients[0]);\n    }\n    m_vClients.clear();\n\n    // Delete modules (unloads all modules!)\n    delete m_pModules;\n    m_pModules = nullptr;\n\n    CZNC::Get().GetManager().DelCronByAddr(m_pUserTimer);\n\n    CZNC::Get().AddBytesRead(m_uBytesRead);\n    CZNC::Get().AddBytesWritten(m_uBytesWritten);\n}\n\ntemplate <class T>\nstruct TOption {\n    const char* name;\n    void (CUser::*pSetter)(T);\n};\n\nbool CUser::ParseConfig(CConfig* pConfig, CString& sError) {\n    TOption<const CString&> StringOptions[] = {\n        {\"nick\", &CUser::SetNick},\n        {\"quitmsg\", &CUser::SetQuitMsg},\n        {\"altnick\", &CUser::SetAltNick},\n        {\"ident\", &CUser::SetIdent},\n        {\"realname\", &CUser::SetRealName},\n        {\"chanmodes\", &CUser::SetDefaultChanModes},\n        {\"bindhost\", &CUser::SetBindHost},\n        {\"vhost\", &CUser::SetBindHost},\n        {\"dccbindhost\", &CUser::SetDCCBindHost},\n        {\"dccvhost\", &CUser::SetDCCBindHost},\n        {\"timestampformat\", &CUser::SetTimestampFormat},\n        {\"skin\", &CUser::SetSkinName},\n        {\"clientencoding\", &CUser::SetClientEncoding},\n    };\n    TOption<unsigned int> UIntOptions[] = {\n        {\"jointries\", &CUser::SetJoinTries},\n        {\"maxnetworks\", &CUser::SetMaxNetworks},\n        {\"maxquerybuffers\", &CUser::SetMaxQueryBuffers},\n        {\"maxjoins\", &CUser::SetMaxJoins},\n        {\"notraffictimeout\", &CUser::SetNoTrafficTimeout},\n    };\n    TOption<bool> BoolOptions[] = {\n        {\"keepbuffer\",\n         &CUser::SetKeepBuffer},  // XXX compatibility crap from pre-0.207\n        {\"autoclearchanbuffer\", &CUser::SetAutoClearChanBuffer},\n        {\"autoclearquerybuffer\", &CUser::SetAutoClearQueryBuffer},\n        {\"multiclients\", &CUser::SetMultiClients},\n        {\"denyloadmod\", &CUser::SetDenyLoadMod},\n        {\"admin\", &CUser::SetAdmin},\n        {\"denysetbindhost\", &CUser::SetDenySetBindHost},\n        {\"denysetvhost\", &CUser::SetDenySetBindHost},\n        {\"appendtimestamp\", &CUser::SetTimestampAppend},\n        {\"prependtimestamp\", &CUser::SetTimestampPrepend},\n        {\"authonlyviamodule\", &CUser::SetAuthOnlyViaModule},\n    };\n\n    for (const auto& Option : StringOptions) {\n        CString sValue;\n        if (pConfig->FindStringEntry(Option.name, sValue))\n            (this->*Option.pSetter)(sValue);\n    }\n    for (const auto& Option : UIntOptions) {\n        CString sValue;\n        if (pConfig->FindStringEntry(Option.name, sValue))\n            (this->*Option.pSetter)(sValue.ToUInt());\n    }\n    for (const auto& Option : BoolOptions) {\n        CString sValue;\n        if (pConfig->FindStringEntry(Option.name, sValue))\n            (this->*Option.pSetter)(sValue.ToBool());\n    }\n\n    VCString vsList;\n    pConfig->FindStringVector(\"allow\", vsList);\n    for (const CString& sHost : vsList) {\n        AddAllowedHost(sHost);\n    }\n    pConfig->FindStringVector(\"ctcpreply\", vsList);\n    for (const CString& sReply : vsList) {\n        AddCTCPReply(sReply.Token(0), sReply.Token(1, true));\n    }\n\n    CString sValue;\n\n    CString sDCCLookupValue;\n    pConfig->FindStringEntry(\"dcclookupmethod\", sDCCLookupValue);\n    if (pConfig->FindStringEntry(\"bouncedccs\", sValue)) {\n        if (sValue.ToBool()) {\n            CUtils::PrintAction(\"Loading Module [bouncedcc]\");\n            CString sModRet;\n            bool bModRet = GetModules().LoadModule(\n                \"bouncedcc\", \"\", CModInfo::UserModule, this, nullptr, sModRet);\n\n            CUtils::PrintStatus(bModRet, sModRet);\n            if (!bModRet) {\n                sError = sModRet;\n                return false;\n            }\n\n            if (sDCCLookupValue.Equals(\"Client\")) {\n                GetModules().FindModule(\"bouncedcc\")->SetNV(\"UseClientIP\", \"1\");\n            }\n        }\n    }\n    if (pConfig->FindStringEntry(\"buffer\", sValue))\n        SetBufferCount(sValue.ToUInt(), true);\n    if (pConfig->FindStringEntry(\"chanbuffersize\", sValue))\n        SetChanBufferSize(sValue.ToUInt(), true);\n    if (pConfig->FindStringEntry(\"querybuffersize\", sValue))\n        SetQueryBufferSize(sValue.ToUInt(), true);\n    if (pConfig->FindStringEntry(\"awaysuffix\", sValue)) {\n        CUtils::PrintMessage(\n            \"WARNING: AwaySuffix has been deprecated, instead try -> \"\n            \"LoadModule = awaynick %nick%_\" +\n            sValue);\n    }\n    if (pConfig->FindStringEntry(\"autocycle\", sValue)) {\n        if (sValue.Equals(\"true\"))\n            CUtils::PrintError(\n                \"WARNING: AutoCycle has been removed, instead try -> \"\n                \"LoadModule = autocycle\");\n    }\n    if (pConfig->FindStringEntry(\"keepnick\", sValue)) {\n        if (sValue.Equals(\"true\"))\n            CUtils::PrintError(\n                \"WARNING: KeepNick has been deprecated, instead try -> \"\n                \"LoadModule = keepnick\");\n    }\n    if (pConfig->FindStringEntry(\"statusprefix\", sValue)) {\n        if (!SetStatusPrefix(sValue)) {\n            sError = \"Invalid StatusPrefix [\" + sValue +\n                     \"] Must be 1-5 chars, no spaces.\";\n            CUtils::PrintError(sError);\n            return false;\n        }\n    }\n    if (pConfig->FindStringEntry(\"timezone\", sValue)) {\n        SetTimezone(sValue);\n    }\n    if (pConfig->FindStringEntry(\"timezoneoffset\", sValue)) {\n        if (fabs(sValue.ToDouble()) > 0.1) {\n            CUtils::PrintError(\n                \"WARNING: TimezoneOffset has been deprecated, now you can set \"\n                \"your timezone by name\");\n        }\n    }\n    if (pConfig->FindStringEntry(\"timestamp\", sValue)) {\n        if (!sValue.Trim_n().Equals(\"true\")) {\n            if (sValue.Trim_n().Equals(\"append\")) {\n                SetTimestampAppend(true);\n                SetTimestampPrepend(false);\n            } else if (sValue.Trim_n().Equals(\"prepend\")) {\n                SetTimestampAppend(false);\n                SetTimestampPrepend(true);\n            } else if (sValue.Trim_n().Equals(\"false\")) {\n                SetTimestampAppend(false);\n                SetTimestampPrepend(false);\n            } else {\n                SetTimestampFormat(sValue);\n            }\n        }\n    }\n    if (pConfig->FindStringEntry(\"language\", sValue)) {\n        SetLanguage(sValue);\n    }\n    pConfig->FindStringEntry(\"pass\", sValue);\n    // There are different formats for this available:\n    // Pass = <plain text>\n    // Pass = <md5 hash> -\n    // Pass = plain#<plain text>\n    // Pass = <hash name>#<hash>\n    // Pass = <hash name>#<salted hash>#<salt>#\n    // 'Salted hash' means hash of 'password' + 'salt'\n    // Possible hashes are md5 and sha256\n    if (sValue.TrimSuffix(\"-\")) {\n        SetPass(sValue.Trim_n(), CUser::HASH_MD5);\n    } else {\n        CString sMethod = sValue.Token(0, false, \"#\");\n        CString sPass = sValue.Token(1, true, \"#\");\n        if (sMethod == \"md5\" || sMethod == \"sha256\") {\n            CUser::eHashType type = CUser::HASH_MD5;\n            if (sMethod == \"sha256\") type = CUser::HASH_SHA256;\n\n            CString sSalt = sPass.Token(1, false, \"#\");\n            sPass = sPass.Token(0, false, \"#\");\n            SetPass(sPass, type, sSalt);\n        } else if (sMethod == \"plain\") {\n            SetPass(sPass, CUser::HASH_NONE);\n        } else {\n            SetPass(sValue, CUser::HASH_NONE);\n        }\n    }\n    CConfig::SubConfig subConf;\n    CConfig::SubConfig::const_iterator subIt;\n    pConfig->FindSubConfig(\"pass\", subConf);\n    if (!sValue.empty() && !subConf.empty()) {\n        sError = \"Password defined more than once\";\n        CUtils::PrintError(sError);\n        return false;\n    }\n    subIt = subConf.begin();\n    if (subIt != subConf.end()) {\n        CConfig* pSubConf = subIt->second.m_pSubConfig;\n        CString sHash;\n        CString sMethod;\n        CString sSalt;\n        CUser::eHashType method;\n        pSubConf->FindStringEntry(\"hash\", sHash);\n        pSubConf->FindStringEntry(\"method\", sMethod);\n        pSubConf->FindStringEntry(\"salt\", sSalt);\n        if (sMethod.empty() || sMethod.Equals(\"plain\"))\n            method = CUser::HASH_NONE;\n        else if (sMethod.Equals(\"md5\"))\n            method = CUser::HASH_MD5;\n        else if (sMethod.Equals(\"sha256\"))\n            method = CUser::HASH_SHA256;\n        else {\n            sError = \"Invalid hash method\";\n            CUtils::PrintError(sError);\n            return false;\n        }\n\n        SetPass(sHash, method, sSalt);\n        if (!pSubConf->empty()) {\n            sError = \"Unhandled lines in config!\";\n            CUtils::PrintError(sError);\n\n            CZNC::DumpConfig(pSubConf);\n            return false;\n        }\n        ++subIt;\n    }\n    if (subIt != subConf.end()) {\n        sError = \"Password defined more than once\";\n        CUtils::PrintError(sError);\n        return false;\n    }\n\n    pConfig->FindSubConfig(\"network\", subConf);\n    for (subIt = subConf.begin(); subIt != subConf.end(); ++subIt) {\n        const CString& sNetworkName = subIt->first;\n\n        CUtils::PrintMessage(\"Loading network [\" + sNetworkName + \"]\");\n\n        CIRCNetwork* pNetwork = FindNetwork(sNetworkName);\n\n        if (!pNetwork) {\n            pNetwork = new CIRCNetwork(this, sNetworkName);\n        }\n\n        if (!pNetwork->ParseConfig(subIt->second.m_pSubConfig, sError)) {\n            return false;\n        }\n    }\n\n    if (pConfig->FindStringVector(\"server\", vsList, false) ||\n        pConfig->FindStringVector(\"chan\", vsList, false) ||\n        pConfig->FindSubConfig(\"chan\", subConf, false)) {\n        CIRCNetwork* pNetwork = FindNetwork(\"default\");\n        if (!pNetwork) {\n            CString sErrorDummy;\n            pNetwork = AddNetwork(\"default\", sErrorDummy);\n        }\n\n        if (pNetwork) {\n            CUtils::PrintMessage(\n                \"NOTICE: Found deprecated config, upgrading to a network\");\n\n            if (!pNetwork->ParseConfig(pConfig, sError, true)) {\n                return false;\n            }\n        }\n    }\n\n    pConfig->FindStringVector(\"loadmodule\", vsList);\n    for (const CString& sMod : vsList) {\n        CString sModName = sMod.Token(0);\n        CString sNotice = \"Loading user module [\" + sModName + \"]\";\n\n        // XXX Legacy crap, added in ZNC 0.089\n        if (sModName == \"discon_kick\") {\n            sNotice =\n                \"NOTICE: [discon_kick] was renamed, loading [disconkick] \"\n                \"instead\";\n            sModName = \"disconkick\";\n        }\n\n        // XXX Legacy crap, added in ZNC 0.099\n        if (sModName == \"fixfreenode\") {\n            sNotice =\n                \"NOTICE: [fixfreenode] doesn't do anything useful anymore, \"\n                \"ignoring it\";\n            CUtils::PrintMessage(sNotice);\n            continue;\n        }\n\n        // XXX Legacy crap, added in ZNC 0.207\n        if (sModName == \"admin\") {\n            sNotice =\n                \"NOTICE: [admin] module was renamed, loading [controlpanel] \"\n                \"instead\";\n            sModName = \"controlpanel\";\n        }\n\n        // XXX Legacy crap, should have been added ZNC 0.207, but added only in\n        // 1.1 :(\n        if (sModName == \"away\") {\n            sNotice = \"NOTICE: [away] was renamed, loading [awaystore] instead\";\n            sModName = \"awaystore\";\n        }\n\n        // XXX Legacy crap, added in 1.1; fakeonline module was dropped in 1.0\n        // and returned in 1.1\n        if (sModName == \"fakeonline\") {\n            sNotice =\n                \"NOTICE: [fakeonline] was renamed, loading [modules_online] \"\n                \"instead\";\n            sModName = \"modules_online\";\n        }\n\n        // XXX Legacy crap, added in 1.3\n        if (sModName == \"charset\") {\n            CUtils::PrintAction(\n                \"NOTICE: Charset support was moved to core, importing old \"\n                \"charset module settings\");\n            size_t uIndex = 1;\n            if (sMod.Token(uIndex).Equals(\"-force\")) {\n                uIndex++;\n            }\n            VCString vsClient, vsServer;\n            sMod.Token(uIndex).Split(\",\", vsClient);\n            sMod.Token(uIndex + 1).Split(\",\", vsServer);\n            if (vsClient.empty() || vsServer.empty()) {\n                CUtils::PrintStatus(\n                    false, \"charset module was loaded with wrong parameters.\");\n                continue;\n            }\n            SetClientEncoding(vsClient[0]);\n            for (CIRCNetwork* pNetwork : m_vIRCNetworks) {\n                pNetwork->SetEncoding(vsServer[0]);\n            }\n            CUtils::PrintStatus(true, \"Using [\" + vsClient[0] +\n                                          \"] for clients, and [\" + vsServer[0] +\n                                          \"] for servers\");\n            continue;\n        }\n\n        CString sModRet;\n        CString sArgs = sMod.Token(1, true);\n\n        bool bModRet = LoadModule(sModName, sArgs, sNotice, sModRet);\n\n        CUtils::PrintStatus(bModRet, sModRet);\n        if (!bModRet) {\n            // XXX The awaynick module was retired in 1.6 (still available as\n            // external module)\n            if (sModName == \"awaynick\") {\n                // load simple_away instead, unless it's already on the list\n                if (std::find(vsList.begin(), vsList.end(), \"simple_away\") ==\n                    vsList.end()) {\n                    sNotice = \"Loading [simple_away] module instead\";\n                    sModName = \"simple_away\";\n                    // not a fatal error if simple_away is not available\n                    LoadModule(sModName, sArgs, sNotice, sModRet);\n                }\n            } else {\n                sError = sModRet;\n                return false;\n            }\n        }\n        continue;\n    }\n\n    // Move ircconnectenabled to the networks\n    if (pConfig->FindStringEntry(\"ircconnectenabled\", sValue)) {\n        for (CIRCNetwork* pNetwork : m_vIRCNetworks) {\n            pNetwork->SetIRCConnectEnabled(sValue.ToBool());\n        }\n    }\n\n    return true;\n}\n\nCIRCNetwork* CUser::AddNetwork(const CString& sNetwork, CString& sErrorRet) {\n    if (!CIRCNetwork::IsValidNetwork(sNetwork)) {\n        sErrorRet =\n            t_s(\"Invalid network name. It should be alphanumeric. Not to be \"\n                \"confused with server name\");\n        return nullptr;\n    } else if (FindNetwork(sNetwork)) {\n        sErrorRet = t_f(\"Network {1} already exists\")(sNetwork);\n        return nullptr;\n    }\n\n    CIRCNetwork* pNetwork = new CIRCNetwork(this, sNetwork);\n\n    bool bCancel = false;\n    USERMODULECALL(OnAddNetwork(*pNetwork, sErrorRet), this, nullptr, &bCancel);\n    if (bCancel) {\n        RemoveNetwork(pNetwork);\n        delete pNetwork;\n        return nullptr;\n    }\n\n    return pNetwork;\n}\n\nbool CUser::AddNetwork(CIRCNetwork* pNetwork) {\n    if (FindNetwork(pNetwork->GetName())) {\n        return false;\n    }\n\n    m_vIRCNetworks.push_back(pNetwork);\n\n    return true;\n}\n\nvoid CUser::RemoveNetwork(CIRCNetwork* pNetwork) {\n    auto it = std::find(m_vIRCNetworks.begin(), m_vIRCNetworks.end(), pNetwork);\n    if (it != m_vIRCNetworks.end()) {\n        m_vIRCNetworks.erase(it);\n    }\n}\n\nbool CUser::DeleteNetwork(const CString& sNetwork) {\n    CIRCNetwork* pNetwork = FindNetwork(sNetwork);\n\n    if (pNetwork) {\n        bool bCancel = false;\n        USERMODULECALL(OnDeleteNetwork(*pNetwork), this, nullptr, &bCancel);\n        if (!bCancel) {\n            delete pNetwork;\n            return true;\n        }\n    }\n\n    return false;\n}\n\nCIRCNetwork* CUser::FindNetwork(const CString& sNetwork) const {\n    for (CIRCNetwork* pNetwork : m_vIRCNetworks) {\n        if (pNetwork->GetName().Equals(sNetwork)) {\n            return pNetwork;\n        }\n    }\n\n    return nullptr;\n}\n\nconst vector<CIRCNetwork*>& CUser::GetNetworks() const {\n    return m_vIRCNetworks;\n}\n\nCString CUser::ExpandString(const CString& sStr) const {\n    CString sRet;\n    return ExpandString(sStr, sRet);\n}\n\nCString& CUser::ExpandString(const CString& sStr, CString& sRet) const {\n    CString sTime = CUtils::CTime(time(nullptr), m_sTimezone);\n\n    sRet = sStr;\n    sRet.Replace(\"%altnick%\", GetAltNick());\n    sRet.Replace(\"%bindhost%\", GetBindHost());\n    sRet.Replace(\"%defnick%\", GetNick());\n    sRet.Replace(\"%ident%\", GetIdent());\n    sRet.Replace(\"%nick%\", GetNick());\n    sRet.Replace(\"%realname%\", GetRealName());\n    sRet.Replace(\"%time%\", sTime);\n    sRet.Replace(\"%uptime%\", CZNC::Get().GetUptime());\n    sRet.Replace(\"%user%\", GetUserName());\n    sRet.Replace(\"%version%\", CZNC::GetVersion());\n    sRet.Replace(\"%vhost%\", GetBindHost());\n    sRet.Replace(\"%znc%\", CZNC::GetTag(false));\n\n    // Allows for escaping ExpandString if necessary, or to prevent\n    // defaults from kicking in if you don't want them.\n    sRet.Replace(\"%empty%\", \"\");\n    // The following lines do not exist. You must be on DrUgS!\n    sRet.Replace(\"%irc%\", \"All your IRC are belong to ZNC\");\n    // Chosen by fair zocchihedron dice roll by SilverLeo\n    sRet.Replace(\"%rand%\", \"42\");\n\n    return sRet;\n}\n\nCString CUser::AddTimestamp(const CString& sStr) const {\n    timeval tv;\n    gettimeofday(&tv, nullptr);\n    return AddTimestamp(tv, sStr);\n}\n\nCString CUser::AddTimestamp(time_t tm, const CString& sStr) const {\n    timeval tv;\n    tv.tv_sec = tm;\n    tv.tv_usec = 0;\n    return AddTimestamp(tv, sStr);\n}\n\nCString CUser::AddTimestamp(timeval tv, const CString& sStr) const {\n    CString sRet = sStr;\n\n    if (!GetTimestampFormat().empty() &&\n        (m_bAppendTimestamp || m_bPrependTimestamp)) {\n        CString sTimestamp =\n            CUtils::FormatTime(tv, GetTimestampFormat(), m_sTimezone);\n        if (sTimestamp.empty()) {\n            return sRet;\n        }\n\n        if (m_bPrependTimestamp) {\n            sRet = sTimestamp;\n            sRet += \" \" + sStr;\n        }\n        if (m_bAppendTimestamp) {\n            // From http://www.mirc.com/colors.html\n            // The Control+O key combination in mIRC inserts ascii character 15,\n            // which turns off all previous attributes, including color, bold,\n            // underline, and italics.\n            //\n            // \\x02 bold\n            // \\x03 mIRC-compatible color\n            // \\x04 RRGGBB color\n            // \\x0F normal/reset (turn off bold, colors, etc.)\n            // \\x12 reverse (weechat)\n            // \\x16 reverse (mirc, kvirc)\n            // \\x1D italic\n            // \\x1F underline\n            // Also see http://www.visualirc.net/tech-attrs.php\n            //\n            // Keep in sync with CIRCSocket::IcuExt__UCallback\n            if (CString::npos !=\n                sRet.find_first_of(\"\\x02\\x03\\x04\\x0F\\x12\\x16\\x1D\\x1F\")) {\n                sRet += \"\\x0F\";\n            }\n\n            sRet += \" \" + sTimestamp;\n        }\n    }\n\n    return sRet;\n}\n\nvoid CUser::BounceAllClients() {\n    for (CClient* pClient : m_vClients) {\n        pClient->BouncedOff();\n    }\n\n    m_vClients.clear();\n}\n\nvoid CUser::UserConnected(CClient* pClient) {\n    if (!MultiClients()) {\n        BounceAllClients();\n    }\n\n    pClient->PutClient(\":irc.znc.in 001 \" + pClient->GetNick() + \" :\" +\n                       t_s(\"Welcome to ZNC\"));\n\n    m_vClients.push_back(pClient);\n}\n\nvoid CUser::UserDisconnected(CClient* pClient) {\n    auto it = std::find(m_vClients.begin(), m_vClients.end(), pClient);\n    if (it != m_vClients.end()) {\n        m_vClients.erase(it);\n    }\n}\n\nvoid CUser::CloneNetworks(const CUser& User) {\n    const vector<CIRCNetwork*>& vNetworks = User.GetNetworks();\n    for (CIRCNetwork* pUserNetwork : vNetworks) {\n        CIRCNetwork* pNetwork = FindNetwork(pUserNetwork->GetName());\n\n        if (pNetwork) {\n            pNetwork->Clone(*pUserNetwork);\n        } else {\n            new CIRCNetwork(this, *pUserNetwork);\n        }\n    }\n\n    set<CString> ssDeleteNetworks;\n    for (CIRCNetwork* pNetwork : m_vIRCNetworks) {\n        if (!(User.FindNetwork(pNetwork->GetName()))) {\n            ssDeleteNetworks.insert(pNetwork->GetName());\n        }\n    }\n\n    for (const CString& sNetwork : ssDeleteNetworks) {\n        // The following will move all the clients to the user.\n        // So the clients are not disconnected. The client could\n        // have requested the rehash. Then when we do\n        // client->PutStatus(\"Rehashing succeeded!\") we would\n        // crash if there was no client anymore.\n        const vector<CClient*>& vClients = FindNetwork(sNetwork)->GetClients();\n\n        while (vClients.begin() != vClients.end()) {\n            CClient* pClient = vClients.front();\n            // This line will remove pClient from vClients,\n            // because it's a reference to the internal Network's vector.\n            pClient->SetNetwork(nullptr);\n        }\n\n        DeleteNetwork(sNetwork);\n    }\n}\n\nbool CUser::Clone(const CUser& User, CString& sErrorRet, bool bCloneNetworks) {\n    sErrorRet.clear();\n\n    if (!User.IsValid(sErrorRet, true)) {\n        return false;\n    }\n\n    // user names can only specified for the constructor, changing it later\n    // on breaks too much stuff (e.g. lots of paths depend on the user name)\n    if (GetUserName() != User.GetUserName()) {\n        DEBUG(\"Ignoring username in CUser::Clone(), old username [\"\n              << GetUserName() << \"]; New username [\" << User.GetUserName()\n              << \"]\");\n    }\n\n    if (!User.GetPass().empty()) {\n        SetPass(User.GetPass(), User.GetPassHashType(), User.GetPassSalt());\n    }\n\n    SetNick(User.GetNick(false));\n    SetAltNick(User.GetAltNick(false));\n    SetIdent(User.GetIdent(false));\n    SetRealName(User.GetRealName());\n    SetStatusPrefix(User.GetStatusPrefix());\n    SetBindHost(User.GetBindHost());\n    SetDCCBindHost(User.GetDCCBindHost());\n    SetQuitMsg(User.GetQuitMsg());\n    SetSkinName(User.GetSkinName());\n    SetDefaultChanModes(User.GetDefaultChanModes());\n    SetChanBufferSize(User.GetChanBufferSize(), true);\n    SetQueryBufferSize(User.GetQueryBufferSize(), true);\n    SetJoinTries(User.JoinTries());\n    SetMaxNetworks(User.MaxNetworks());\n    SetMaxQueryBuffers(User.MaxQueryBuffers());\n    SetMaxJoins(User.MaxJoins());\n    SetNoTrafficTimeout(User.GetNoTrafficTimeout());\n    SetClientEncoding(User.GetClientEncoding());\n    SetLanguage(User.GetLanguage());\n\n    // Allowed Hosts\n    m_ssAllowedHosts.clear();\n    const set<CString>& ssHosts = User.GetAllowedHosts();\n    for (const CString& sHost : ssHosts) {\n        AddAllowedHost(sHost);\n    }\n\n    for (CClient* pSock : m_vClients) {\n        if (!IsHostAllowed(pSock->GetRemoteIP())) {\n            pSock->PutStatusNotice(\n                t_s(\"You are being disconnected because your IP is no longer \"\n                    \"allowed to connect to this user\"));\n            pSock->Close();\n        }\n    }\n\n    // !Allowed Hosts\n\n    // Networks\n    if (bCloneNetworks) {\n        CloneNetworks(User);\n    }\n    // !Networks\n\n    // CTCP Replies\n    m_mssCTCPReplies.clear();\n    const MCString& msReplies = User.GetCTCPReplies();\n    for (const auto& it : msReplies) {\n        AddCTCPReply(it.first, it.second);\n    }\n    // !CTCP Replies\n\n    // Flags\n    SetAutoClearChanBuffer(User.AutoClearChanBuffer());\n    SetAutoClearQueryBuffer(User.AutoClearQueryBuffer());\n    SetMultiClients(User.MultiClients());\n    SetDenyLoadMod(User.DenyLoadMod());\n    SetAdmin(User.IsAdmin());\n    SetDenySetBindHost(User.DenySetBindHost());\n    SetAuthOnlyViaModule(User.AuthOnlyViaModule());\n    SetTimestampAppend(User.GetTimestampAppend());\n    SetTimestampPrepend(User.GetTimestampPrepend());\n    SetTimestampFormat(User.GetTimestampFormat());\n    SetTimezone(User.GetTimezone());\n    // !Flags\n\n    // Modules\n    set<CString> ssUnloadMods;\n    CModules& vCurMods = GetModules();\n    const CModules& vNewMods = User.GetModules();\n\n    for (CModule* pNewMod : vNewMods) {\n        CString sModRet;\n        CModule* pCurMod = vCurMods.FindModule(pNewMod->GetModName());\n\n        if (!pCurMod) {\n            vCurMods.LoadModule(pNewMod->GetModName(), pNewMod->GetArgs(),\n                                CModInfo::UserModule, this, nullptr, sModRet);\n        } else if (pNewMod->GetArgs() != pCurMod->GetArgs()) {\n            vCurMods.ReloadModule(pNewMod->GetModName(), pNewMod->GetArgs(),\n                                  this, nullptr, sModRet);\n        }\n    }\n\n    for (CModule* pCurMod : vCurMods) {\n        CModule* pNewMod = vNewMods.FindModule(pCurMod->GetModName());\n\n        if (!pNewMod) {\n            ssUnloadMods.insert(pCurMod->GetModName());\n        }\n    }\n\n    for (const CString& sMod : ssUnloadMods) {\n        vCurMods.UnloadModule(sMod);\n    }\n    // !Modules\n\n    return true;\n}\n\nconst set<CString>& CUser::GetAllowedHosts() const { return m_ssAllowedHosts; }\nbool CUser::AddAllowedHost(const CString& sHostMask) {\n    if (sHostMask.empty() ||\n        m_ssAllowedHosts.find(sHostMask) != m_ssAllowedHosts.end()) {\n        return false;\n    }\n\n    m_ssAllowedHosts.insert(sHostMask);\n    return true;\n}\nbool CUser::RemAllowedHost(const CString& sHostMask) {\n    return m_ssAllowedHosts.erase(sHostMask) > 0;\n}\nvoid CUser::ClearAllowedHosts() { m_ssAllowedHosts.clear(); }\n\nbool CUser::IsHostAllowed(const CString& sHost) const {\n    if (m_ssAllowedHosts.empty()) {\n        return true;\n    }\n\n    for (const CString& sAllowedHost : m_ssAllowedHosts) {\n        if (CUtils::CheckCIDR(sHost, sAllowedHost)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nconst CString& CUser::GetTimestampFormat() const { return m_sTimestampFormat; }\nbool CUser::GetTimestampAppend() const { return m_bAppendTimestamp; }\nbool CUser::GetTimestampPrepend() const { return m_bPrependTimestamp; }\n\nbool CUser::IsValidUserName(const CString& sUserName) {\n    // /^[a-zA-Z][a-zA-Z@._\\-]*$/\n    const char* p = sUserName.c_str();\n\n    if (sUserName.empty()) {\n        return false;\n    }\n\n    if ((*p < 'a' || *p > 'z') && (*p < 'A' || *p > 'Z')) {\n        return false;\n    }\n\n    while (*p) {\n        if (*p != '@' && *p != '.' && *p != '-' && *p != '_' && !isalnum(*p)) {\n            return false;\n        }\n\n        p++;\n    }\n\n    return true;\n}\n\nbool CUser::IsValid(CString& sErrMsg, bool bSkipPass) const {\n    sErrMsg.clear();\n\n    if (!bSkipPass && m_sPass.empty()) {\n        sErrMsg = t_s(\"Password is empty\");\n        return false;\n    }\n\n    if (m_sUserName.empty()) {\n        sErrMsg = t_s(\"Username is empty\");\n        return false;\n    }\n\n    if (!CUser::IsValidUserName(m_sUserName)) {\n        sErrMsg = t_s(\"Username is invalid\");\n        return false;\n    }\n\n    return true;\n}\n\nCConfig CUser::ToConfig() const {\n    CConfig config;\n    CConfig passConfig;\n\n    CString sHash;\n    switch (m_eHashType) {\n        case HASH_NONE:\n            sHash = \"Plain\";\n            break;\n        case HASH_MD5:\n            sHash = \"MD5\";\n            break;\n        case HASH_SHA256:\n            sHash = \"SHA256\";\n            break;\n    }\n    passConfig.AddKeyValuePair(\"Salt\", m_sPassSalt);\n    passConfig.AddKeyValuePair(\"Method\", sHash);\n    passConfig.AddKeyValuePair(\"Hash\", GetPass());\n    config.AddSubConfig(\"Pass\", \"password\", passConfig);\n\n    config.AddKeyValuePair(\"Nick\", GetNick());\n    config.AddKeyValuePair(\"AltNick\", GetAltNick());\n    config.AddKeyValuePair(\"Ident\", GetIdent());\n    config.AddKeyValuePair(\"RealName\", GetRealName());\n    config.AddKeyValuePair(\"BindHost\", GetBindHost());\n    config.AddKeyValuePair(\"DCCBindHost\", GetDCCBindHost());\n    config.AddKeyValuePair(\"QuitMsg\", GetQuitMsg());\n    if (CZNC::Get().GetStatusPrefix() != GetStatusPrefix())\n        config.AddKeyValuePair(\"StatusPrefix\", GetStatusPrefix());\n    config.AddKeyValuePair(\"Skin\", GetSkinName());\n    config.AddKeyValuePair(\"ChanModes\", GetDefaultChanModes());\n    config.AddKeyValuePair(\"ChanBufferSize\", CString(GetChanBufferSize()));\n    config.AddKeyValuePair(\"QueryBufferSize\", CString(GetQueryBufferSize()));\n    config.AddKeyValuePair(\"AutoClearChanBuffer\",\n                           CString(AutoClearChanBuffer()));\n    config.AddKeyValuePair(\"AutoClearQueryBuffer\",\n                           CString(AutoClearQueryBuffer()));\n    config.AddKeyValuePair(\"MultiClients\", CString(MultiClients()));\n    config.AddKeyValuePair(\"DenyLoadMod\", CString(DenyLoadMod()));\n    config.AddKeyValuePair(\"Admin\", CString(IsAdmin()));\n    config.AddKeyValuePair(\"DenySetBindHost\", CString(DenySetBindHost()));\n    config.AddKeyValuePair(\"TimestampFormat\", GetTimestampFormat());\n    config.AddKeyValuePair(\"AppendTimestamp\", CString(GetTimestampAppend()));\n    config.AddKeyValuePair(\"PrependTimestamp\", CString(GetTimestampPrepend()));\n    config.AddKeyValuePair(\"AuthOnlyViaModule\", CString(AuthOnlyViaModule()));\n    config.AddKeyValuePair(\"Timezone\", m_sTimezone);\n    config.AddKeyValuePair(\"JoinTries\", CString(m_uMaxJoinTries));\n    config.AddKeyValuePair(\"MaxNetworks\", CString(m_uMaxNetworks));\n    config.AddKeyValuePair(\"MaxQueryBuffers\", CString(m_uMaxQueryBuffers));\n    config.AddKeyValuePair(\"MaxJoins\", CString(m_uMaxJoins));\n    config.AddKeyValuePair(\"ClientEncoding\", GetClientEncoding());\n    config.AddKeyValuePair(\"Language\", GetLanguage());\n    config.AddKeyValuePair(\"NoTrafficTimeout\", CString(GetNoTrafficTimeout()));\n\n    // Allow Hosts\n    if (!m_ssAllowedHosts.empty()) {\n        for (const CString& sHost : m_ssAllowedHosts) {\n            config.AddKeyValuePair(\"Allow\", sHost);\n        }\n    }\n\n    // CTCP Replies\n    if (!m_mssCTCPReplies.empty()) {\n        for (const auto& itb : m_mssCTCPReplies) {\n            config.AddKeyValuePair(\"CTCPReply\",\n                                   itb.first.AsUpper() + \" \" + itb.second);\n        }\n    }\n\n    // Modules\n    const CModules& Mods = GetModules();\n\n    if (!Mods.empty()) {\n        for (CModule* pMod : Mods) {\n            CString sArgs = pMod->GetArgs();\n\n            if (!sArgs.empty()) {\n                sArgs = \" \" + sArgs;\n            }\n\n            config.AddKeyValuePair(\"LoadModule\", pMod->GetModName() + sArgs);\n        }\n    }\n\n    // Networks\n    for (CIRCNetwork* pNetwork : m_vIRCNetworks) {\n        config.AddSubConfig(\"Network\", pNetwork->GetName(),\n                            pNetwork->ToConfig());\n    }\n\n    return config;\n}\n\nbool CUser::CheckPass(const CString& sPass) const {\n    if(AuthOnlyViaModule() || CZNC::Get().GetAuthOnlyViaModule()) {\n        return false;\n    }\n\n    switch (m_eHashType) {\n        case HASH_MD5:\n            return m_sPass.Equals(CUtils::SaltedMD5Hash(sPass, m_sPassSalt));\n        case HASH_SHA256:\n            return m_sPass.Equals(CUtils::SaltedSHA256Hash(sPass, m_sPassSalt));\n        case HASH_NONE:\n        default:\n            return (sPass == m_sPass);\n    }\n}\n\n/*CClient* CUser::GetClient() {\n    // Todo: optimize this by saving a pointer to the sock\n    CSockManager& Manager = CZNC::Get().GetManager();\n    CString sSockName = \"USR::\" + m_sUserName;\n\n    for (unsigned int a = 0; a < Manager.size(); a++) {\n        Csock* pSock = Manager[a];\n        if (pSock->GetSockName().Equals(sSockName)) {\n            if (!pSock->IsClosed()) {\n                return (CClient*) pSock;\n            }\n        }\n    }\n\n    return (CClient*) CZNC::Get().GetManager().FindSockByName(sSockName);\n}*/\n\nCString CUser::GetLocalDCCIP() const {\n    if (!GetDCCBindHost().empty()) return GetDCCBindHost();\n\n    for (CIRCNetwork* pNetwork : m_vIRCNetworks) {\n        CIRCSock* pIRCSock = pNetwork->GetIRCSock();\n        if (pIRCSock) {\n            return pIRCSock->GetLocalIP();\n        }\n    }\n\n    if (!GetAllClients().empty()) {\n        return GetAllClients()[0]->GetLocalIP();\n    }\n\n    return \"\";\n}\n\nbool CUser::PutUser(const CString& sLine, CClient* pClient,\n                    CClient* pSkipClient) {\n    for (CClient* pEachClient : m_vClients) {\n        if ((!pClient || pClient == pEachClient) &&\n            pSkipClient != pEachClient) {\n            pEachClient->PutClient(sLine);\n\n            if (pClient) {\n                return true;\n            }\n        }\n    }\n\n    return (pClient == nullptr);\n}\n\nbool CUser::PutAllUser(const CString& sLine, CClient* pClient,\n                       CClient* pSkipClient) {\n    PutUser(sLine, pClient, pSkipClient);\n\n    for (CIRCNetwork* pNetwork : m_vIRCNetworks) {\n        if (pNetwork->PutUser(sLine, pClient, pSkipClient)) {\n            return true;\n        }\n    }\n\n    return (pClient == nullptr);\n}\n\nbool CUser::PutStatus(const CString& sLine, CClient* pClient,\n                      CClient* pSkipClient) {\n    vector<CClient*> vClients = GetAllClients();\n    for (CClient* pEachClient : vClients) {\n        if ((!pClient || pClient == pEachClient) &&\n            pSkipClient != pEachClient) {\n            pEachClient->PutStatus(sLine);\n\n            if (pClient) {\n                return true;\n            }\n        }\n    }\n\n    return (pClient == nullptr);\n}\n\nbool CUser::PutStatusNotice(const CString& sLine, CClient* pClient,\n                            CClient* pSkipClient) {\n    vector<CClient*> vClients = GetAllClients();\n    for (CClient* pEachClient : vClients) {\n        if ((!pClient || pClient == pEachClient) &&\n            pSkipClient != pEachClient) {\n            pEachClient->PutStatusNotice(sLine);\n\n            if (pClient) {\n                return true;\n            }\n        }\n    }\n\n    return (pClient == nullptr);\n}\n\nbool CUser::PutModule(const CString& sModule, const CString& sLine,\n                      CClient* pClient, CClient* pSkipClient) {\n    for (CClient* pEachClient : m_vClients) {\n        if ((!pClient || pClient == pEachClient) &&\n            pSkipClient != pEachClient) {\n            pEachClient->PutModule(sModule, sLine);\n\n            if (pClient) {\n                return true;\n            }\n        }\n    }\n\n    return (pClient == nullptr);\n}\n\nbool CUser::PutModNotice(const CString& sModule, const CString& sLine,\n                         CClient* pClient, CClient* pSkipClient) {\n    for (CClient* pEachClient : m_vClients) {\n        if ((!pClient || pClient == pEachClient) &&\n            pSkipClient != pEachClient) {\n            pEachClient->PutModNotice(sModule, sLine);\n\n            if (pClient) {\n                return true;\n            }\n        }\n    }\n\n    return (pClient == nullptr);\n}\n\nCString CUser::MakeCleanUserName(const CString& sUserName) {\n    return sUserName.Token(0, false, \"@\").Replace_n(\".\", \"\");\n}\n\nbool CUser::IsUserAttached() const {\n    if (!m_vClients.empty()) {\n        return true;\n    }\n\n    for (const CIRCNetwork* pNetwork : m_vIRCNetworks) {\n        if (pNetwork->IsUserAttached()) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool CUser::LoadModule(const CString& sModName, const CString& sArgs,\n                       const CString& sNotice, CString& sError) {\n    bool bModRet = true;\n    CString sModRet;\n\n    CModInfo ModInfo;\n    if (!CZNC::Get().GetModules().GetModInfo(ModInfo, sModName, sModRet)) {\n        sError = t_f(\"Unable to find modinfo {1}: {2}\")(sModName, sModRet);\n        return false;\n    }\n\n    CUtils::PrintAction(sNotice);\n\n    if (!ModInfo.SupportsType(CModInfo::UserModule) &&\n        ModInfo.SupportsType(CModInfo::NetworkModule)) {\n        CUtils::PrintMessage(\n            \"NOTICE: Module [\" + sModName +\n            \"] is a network module, loading module for all networks in user.\");\n\n        // Do they have old NV?\n        CFile fNVFile =\n            CFile(GetUserPath() + \"/moddata/\" + sModName + \"/.registry\");\n\n        for (CIRCNetwork* pNetwork : m_vIRCNetworks) {\n            // Check whether the network already has this module loaded (#954)\n            if (pNetwork->GetModules().FindModule(sModName)) {\n                continue;\n            }\n\n            if (fNVFile.Exists()) {\n                CString sNetworkModPath =\n                    pNetwork->GetNetworkPath() + \"/moddata/\" + sModName;\n                if (!CFile::Exists(sNetworkModPath)) {\n                    CDir::MakeDir(sNetworkModPath);\n                }\n\n                fNVFile.Copy(sNetworkModPath + \"/.registry\");\n            }\n\n            bModRet = pNetwork->GetModules().LoadModule(\n                sModName, sArgs, CModInfo::NetworkModule, this, pNetwork,\n                sModRet);\n            if (!bModRet) {\n                break;\n            }\n        }\n    } else {\n        bModRet = GetModules().LoadModule(sModName, sArgs, CModInfo::UserModule,\n                                          this, nullptr, sModRet);\n    }\n\n    if (!bModRet) {\n        sError = sModRet;\n    }\n    return bModRet;\n}\n\n// Setters\nvoid CUser::SetNick(const CString& s) { m_sNick = s; }\nvoid CUser::SetAltNick(const CString& s) { m_sAltNick = s; }\nvoid CUser::SetIdent(const CString& s) { m_sIdent = s; }\nvoid CUser::SetRealName(const CString& s) { m_sRealName = s; }\nvoid CUser::SetBindHost(const CString& s) { m_sBindHost = s; }\nvoid CUser::SetDCCBindHost(const CString& s) { m_sDCCBindHost = s; }\nvoid CUser::SetPass(const CString& s, eHashType eHash, const CString& sSalt) {\n    m_sPass = s;\n    m_eHashType = eHash;\n    m_sPassSalt = sSalt;\n}\nvoid CUser::SetMultiClients(bool b) { m_bMultiClients = b; }\nvoid CUser::SetDenyLoadMod(bool b) { m_bDenyLoadMod = b; }\nvoid CUser::SetAdmin(bool b) { m_bAdmin = b; }\nvoid CUser::SetDenySetBindHost(bool b) { m_bDenySetBindHost = b; }\nvoid CUser::SetDefaultChanModes(const CString& s) { m_sDefaultChanModes = s; }\nvoid CUser::SetClientEncoding(const CString& s) {\n    m_sClientEncoding = s;\n    for (CClient* pClient : GetAllClients()) {\n        pClient->SetEncoding(s);\n    }\n}\nvoid CUser::SetQuitMsg(const CString& s) { m_sQuitMsg = s; }\nvoid CUser::SetAutoClearChanBuffer(bool b) {\n    for (CIRCNetwork* pNetwork : m_vIRCNetworks) {\n        for (CChan* pChan : pNetwork->GetChans()) {\n            pChan->InheritAutoClearChanBuffer(b);\n        }\n    }\n    m_bAutoClearChanBuffer = b;\n}\nvoid CUser::SetAutoClearQueryBuffer(bool b) { m_bAutoClearQueryBuffer = b; }\n\nbool CUser::SetBufferCount(unsigned int u, bool bForce) {\n    return SetChanBufferSize(u, bForce);\n}\n\nbool CUser::SetChanBufferSize(unsigned int u, bool bForce) {\n    if (!bForce && u > CZNC::Get().GetMaxBufferSize()) return false;\n    for (CIRCNetwork* pNetwork : m_vIRCNetworks) {\n        for (CChan* pChan : pNetwork->GetChans()) {\n            pChan->InheritBufferCount(u, bForce);\n        }\n    }\n    m_uChanBufferSize = u;\n    return true;\n}\n\nbool CUser::SetQueryBufferSize(unsigned int u, bool bForce) {\n    if (!bForce && u > CZNC::Get().GetMaxBufferSize()) return false;\n    for (CIRCNetwork* pNetwork : m_vIRCNetworks) {\n        for (CQuery* pQuery : pNetwork->GetQueries()) {\n            pQuery->SetBufferCount(u, bForce);\n        }\n    }\n    m_uQueryBufferSize = u;\n    return true;\n}\n\nbool CUser::AddCTCPReply(const CString& sCTCP, const CString& sReply) {\n    // Reject CTCP requests containing spaces\n    if (sCTCP.find_first_of(' ') != CString::npos) {\n        return false;\n    }\n    // Reject empty CTCP requests\n    if (sCTCP.empty()) {\n        return false;\n    }\n    m_mssCTCPReplies[sCTCP.AsUpper()] = sReply;\n    return true;\n}\n\nbool CUser::DelCTCPReply(const CString& sCTCP) {\n    return m_mssCTCPReplies.erase(sCTCP.AsUpper()) > 0;\n}\n\nbool CUser::SetStatusPrefix(const CString& s) {\n    if ((!s.empty()) && (s.length() < 6) && (!s.Contains(\" \"))) {\n        m_sStatusPrefix = (s.empty()) ? \"*\" : s;\n        return true;\n    }\n\n    return false;\n}\n\nbool CUser::SetLanguage(const CString& s) {\n    // They look like ru-RU\n    for (char c : s) {\n        if (isalpha(c) || c == '-' || c == '_') {\n        } else {\n            return false;\n        }\n    }\n    m_sLanguage = s;\n    // 1.7.0 accidentally used _ instead of -, which made language\n    // non-selectable. But it's possible that someone put _ to znc.conf\n    // manually.\n    // TODO: cleanup _ some time later.\n    m_sLanguage.Replace(\"_\", \"-\");\n    return true;\n}\n// !Setters\n\n// Getters\nvector<CClient*> CUser::GetAllClients() const {\n    vector<CClient*> vClients;\n\n    for (CIRCNetwork* pNetwork : m_vIRCNetworks) {\n        for (CClient* pClient : pNetwork->GetClients()) {\n            vClients.push_back(pClient);\n        }\n    }\n\n    for (CClient* pClient : m_vClients) {\n        vClients.push_back(pClient);\n    }\n\n    return vClients;\n}\n\nconst CString& CUser::GetUserName() const { return m_sUserName; }\nconst CString& CUser::GetCleanUserName() const { return m_sCleanUserName; }\nconst CString& CUser::GetNick(bool bAllowDefault) const {\n    return (bAllowDefault && m_sNick.empty()) ? GetCleanUserName() : m_sNick;\n}\nconst CString& CUser::GetAltNick(bool bAllowDefault) const {\n    return (bAllowDefault && m_sAltNick.empty()) ? GetCleanUserName()\n                                                 : m_sAltNick;\n}\nconst CString& CUser::GetIdent(bool bAllowDefault) const {\n    return (bAllowDefault && m_sIdent.empty()) ? GetCleanUserName() : m_sIdent;\n}\nCString CUser::GetRealName() const {\n    // Not include version number via GetTag() because of\n    // https://github.com/znc/znc/issues/818#issuecomment-70402820\n    return (!m_sRealName.Trim_n().empty()) ? m_sRealName\n                                           : \"ZNC - https://znc.in\";\n}\nconst CString& CUser::GetBindHost() const { return m_sBindHost; }\nconst CString& CUser::GetDCCBindHost() const { return m_sDCCBindHost; }\nconst CString& CUser::GetPass() const { return m_sPass; }\nCUser::eHashType CUser::GetPassHashType() const { return m_eHashType; }\nconst CString& CUser::GetPassSalt() const { return m_sPassSalt; }\nbool CUser::DenyLoadMod() const { return m_bDenyLoadMod; }\nbool CUser::IsAdmin() const { return m_bAdmin; }\nbool CUser::DenySetBindHost() const { return m_bDenySetBindHost; }\nbool CUser::MultiClients() const { return m_bMultiClients; }\nbool CUser::AuthOnlyViaModule() const { return m_bAuthOnlyViaModule; }\nconst CString& CUser::GetStatusPrefix() const { return m_sStatusPrefix; }\nconst CString& CUser::GetDefaultChanModes() const {\n    return m_sDefaultChanModes;\n}\nconst CString& CUser::GetClientEncoding() const { return m_sClientEncoding; }\nbool CUser::HasSpaceForNewNetwork() const {\n    return GetNetworks().size() < MaxNetworks();\n}\n\nCString CUser::GetQuitMsg() const {\n    return (!m_sQuitMsg.Trim_n().empty()) ? m_sQuitMsg : \"%znc%\";\n}\nconst MCString& CUser::GetCTCPReplies() const { return m_mssCTCPReplies; }\nunsigned int CUser::GetBufferCount() const { return GetChanBufferSize(); }\nunsigned int CUser::GetChanBufferSize() const { return m_uChanBufferSize; }\nunsigned int CUser::GetQueryBufferSize() const { return m_uQueryBufferSize; }\nbool CUser::AutoClearChanBuffer() const { return m_bAutoClearChanBuffer; }\nbool CUser::AutoClearQueryBuffer() const { return m_bAutoClearQueryBuffer; }\n// CString CUser::GetSkinName() const { return (!m_sSkinName.empty()) ?\n// m_sSkinName : CZNC::Get().GetSkinName(); }\nCString CUser::GetSkinName() const { return m_sSkinName; }\nCString CUser::GetLanguage() const { return m_sLanguage; }\nconst CString& CUser::GetUserPath() const {\n    if (!CFile::Exists(m_sUserPath)) {\n        CDir::MakeDir(m_sUserPath);\n    }\n    return m_sUserPath;\n}\n// !Getters\n\nunsigned long long CUser::BytesRead() const {\n    unsigned long long uBytes = m_uBytesRead;\n    for (const CIRCNetwork* pNetwork : m_vIRCNetworks) {\n        uBytes += pNetwork->BytesRead();\n    }\n    return uBytes;\n}\n\nunsigned long long CUser::BytesWritten() const {\n    unsigned long long uBytes = m_uBytesWritten;\n    for (const CIRCNetwork* pNetwork : m_vIRCNetworks) {\n        uBytes += pNetwork->BytesWritten();\n    }\n    return uBytes;\n}\n", "/*\n * Copyright (C) 2004-2018 ZNC, see the NOTICE file for details.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <znc/znc.h>\n#include <znc/FileUtils.h>\n#include <znc/IRCSock.h>\n#include <znc/Server.h>\n#include <znc/User.h>\n#include <znc/IRCNetwork.h>\n#include <znc/Config.h>\n#include <time.h>\n#include <tuple>\n#include <algorithm>\n\nusing std::endl;\nusing std::cout;\nusing std::map;\nusing std::set;\nusing std::vector;\nusing std::list;\nusing std::tuple;\nusing std::make_tuple;\n\nCZNC::CZNC()\n    : m_TimeStarted(time(nullptr)),\n      m_eConfigState(ECONFIG_NOTHING),\n      m_vpListeners(),\n      m_msUsers(),\n      m_msDelUsers(),\n      m_Manager(),\n      m_sCurPath(\"\"),\n      m_sZNCPath(\"\"),\n      m_sConfigFile(\"\"),\n      m_sSkinName(\"\"),\n      m_sStatusPrefix(\"\"),\n      m_sPidFile(\"\"),\n      m_sSSLCertFile(\"\"),\n      m_sSSLKeyFile(\"\"),\n      m_sSSLDHParamFile(\"\"),\n      m_sSSLCiphers(\"\"),\n      m_sSSLProtocols(\"\"),\n      m_vsBindHosts(),\n      m_vsTrustedProxies(),\n      m_vsMotd(),\n      m_pLockFile(nullptr),\n      m_uiConnectDelay(5),\n      m_uiAnonIPLimit(10),\n      m_uiMaxBufferSize(500),\n      m_uDisabledSSLProtocols(Csock::EDP_SSL),\n      m_pModules(new CModules),\n      m_uBytesRead(0),\n      m_uBytesWritten(0),\n      m_lpConnectQueue(),\n      m_pConnectQueueTimer(nullptr),\n      m_uiConnectPaused(0),\n      m_uiForceEncoding(0),\n      m_sConnectThrottle(),\n      m_bProtectWebSessions(true),\n      m_bHideVersion(false),\n      m_bAuthOnlyViaModule(false),\n      m_Translation(\"znc\"),\n      m_uiConfigWriteDelay(0),\n      m_pConfigTimer(nullptr) {\n    if (!InitCsocket()) {\n        CUtils::PrintError(\"Could not initialize Csocket!\");\n        exit(-1);\n    }\n    m_sConnectThrottle.SetTTL(30000);\n}\n\nCZNC::~CZNC() {\n    m_pModules->UnloadAll();\n\n    for (const auto& it : m_msUsers) {\n        it.second->GetModules().UnloadAll();\n\n        const vector<CIRCNetwork*>& networks = it.second->GetNetworks();\n        for (CIRCNetwork* pNetwork : networks) {\n            pNetwork->GetModules().UnloadAll();\n        }\n    }\n\n    for (CListener* pListener : m_vpListeners) {\n        delete pListener;\n    }\n\n    for (const auto& it : m_msUsers) {\n        it.second->SetBeingDeleted(true);\n    }\n\n    m_pConnectQueueTimer = nullptr;\n    // This deletes m_pConnectQueueTimer\n    m_Manager.Cleanup();\n    DeleteUsers();\n\n    delete m_pModules;\n    delete m_pLockFile;\n\n    ShutdownCsocket();\n    DeletePidFile();\n}\n\nCString CZNC::GetVersion() {\n    return CString(VERSION_STR) + CString(ZNC_VERSION_EXTRA);\n}\n\nCString CZNC::GetTag(bool bIncludeVersion, bool bHTML) {\n    if (!Get().m_bHideVersion) {\n        bIncludeVersion = true;\n    }\n    CString sAddress = bHTML ? \"<a href=\\\"https://znc.in\\\">https://znc.in</a>\"\n                             : \"https://znc.in\";\n\n    if (!bIncludeVersion) {\n        return \"ZNC - \" + sAddress;\n    }\n\n    CString sVersion = GetVersion();\n\n    return \"ZNC \" + sVersion + \" - \" + sAddress;\n}\n\nCString CZNC::GetCompileOptionsString() {\n    // Build system doesn't affect ABI\n    return ZNC_COMPILE_OPTIONS_STRING + CString(\n                                            \", build: \"\n#ifdef BUILD_WITH_CMAKE\n                                            \"cmake\"\n#else\n                                            \"autoconf\"\n#endif\n                                            );\n}\n\nCString CZNC::GetUptime() const {\n    time_t now = time(nullptr);\n    return CString::ToTimeStr(now - TimeStarted());\n}\n\nbool CZNC::OnBoot() {\n    bool bFail = false;\n    ALLMODULECALL(OnBoot(), &bFail);\n    if (bFail) return false;\n\n    return true;\n}\n\nbool CZNC::HandleUserDeletion() {\n    if (m_msDelUsers.empty()) return false;\n\n    for (const auto& it : m_msDelUsers) {\n        CUser* pUser = it.second;\n        pUser->SetBeingDeleted(true);\n\n        if (GetModules().OnDeleteUser(*pUser)) {\n            pUser->SetBeingDeleted(false);\n            continue;\n        }\n        m_msUsers.erase(pUser->GetUserName());\n        CWebSock::FinishUserSessions(*pUser);\n        delete pUser;\n    }\n\n    m_msDelUsers.clear();\n\n    return true;\n}\n\nclass CConfigWriteTimer : public CCron {\n  public:\n    CConfigWriteTimer(int iSecs) : CCron() {\n        SetName(\"Config write timer\");\n        Start(iSecs);\n    }\n\n  protected:\n    void RunJob() override {\n        CZNC::Get().SetConfigState(CZNC::ECONFIG_NEED_WRITE);\n\n        CZNC::Get().DisableConfigTimer();\n    }\n};\n\nvoid CZNC::Loop() {\n    while (true) {\n        CString sError;\n\n        ConfigState eState = GetConfigState();\n        switch (eState) {\n            case ECONFIG_NEED_REHASH:\n                SetConfigState(ECONFIG_NOTHING);\n\n                if (RehashConfig(sError)) {\n                    Broadcast(\"Rehashing succeeded\", true);\n                } else {\n                    Broadcast(\"Rehashing failed: \" + sError, true);\n                    Broadcast(\"ZNC is in some possibly inconsistent state!\",\n                              true);\n                }\n                break;\n            case ECONFIG_DELAYED_WRITE:\n                SetConfigState(ECONFIG_NOTHING);\n\n                if (GetConfigWriteDelay() > 0) {\n                    if (m_pConfigTimer == nullptr) {\n                        m_pConfigTimer = new CConfigWriteTimer(GetConfigWriteDelay());\n                        GetManager().AddCron(m_pConfigTimer);\n                    }\n                    break;\n                }\n                /* Fall through */\n            case ECONFIG_NEED_WRITE:\n            case ECONFIG_NEED_VERBOSE_WRITE:\n                SetConfigState(ECONFIG_NOTHING);\n\n                // stop pending configuration timer\n                DisableConfigTimer();\n\n                if (!WriteConfig()) {\n                    Broadcast(\"Writing the config file failed\", true);\n                } else if (eState == ECONFIG_NEED_VERBOSE_WRITE) {\n                    Broadcast(\"Writing the config succeeded\", true);\n                }\n                break;\n            case ECONFIG_NOTHING:\n                break;\n            case ECONFIG_NEED_QUIT:\n                return;\n        }\n\n        // Check for users that need to be deleted\n        if (HandleUserDeletion()) {\n            // Also remove those user(s) from the config file\n            WriteConfig();\n        }\n\n        // Csocket wants micro seconds\n        // 100 msec to 5 min\n        m_Manager.DynamicSelectLoop(100 * 1000, 5 * 60 * 1000 * 1000);\n    }\n}\n\nCFile* CZNC::InitPidFile() {\n    if (!m_sPidFile.empty()) {\n        CString sFile;\n\n        // absolute path or relative to the data dir?\n        if (m_sPidFile[0] != '/')\n            sFile = GetZNCPath() + \"/\" + m_sPidFile;\n        else\n            sFile = m_sPidFile;\n\n        return new CFile(sFile);\n    }\n\n    return nullptr;\n}\n\nbool CZNC::WritePidFile(int iPid) {\n    CFile* File = InitPidFile();\n    if (File == nullptr) return false;\n\n    CUtils::PrintAction(\"Writing pid file [\" + File->GetLongName() + \"]\");\n\n    bool bRet = false;\n    if (File->Open(O_WRONLY | O_TRUNC | O_CREAT)) {\n        File->Write(CString(iPid) + \"\\n\");\n        File->Close();\n        bRet = true;\n    }\n\n    delete File;\n    CUtils::PrintStatus(bRet);\n    return bRet;\n}\n\nbool CZNC::DeletePidFile() {\n    CFile* File = InitPidFile();\n    if (File == nullptr) return false;\n\n    CUtils::PrintAction(\"Deleting pid file [\" + File->GetLongName() + \"]\");\n\n    bool bRet = File->Delete();\n\n    delete File;\n    CUtils::PrintStatus(bRet);\n    return bRet;\n}\n\nbool CZNC::WritePemFile() {\n#ifndef HAVE_LIBSSL\n    CUtils::PrintError(\"ZNC was not compiled with ssl support.\");\n    return false;\n#else\n    CString sPemFile = GetPemLocation();\n\n    CUtils::PrintAction(\"Writing Pem file [\" + sPemFile + \"]\");\n#ifndef _WIN32\n    int fd = creat(sPemFile.c_str(), 0600);\n    if (fd == -1) {\n        CUtils::PrintStatus(false, \"Unable to open\");\n        return false;\n    }\n    FILE* f = fdopen(fd, \"w\");\n#else\n    FILE* f = fopen(sPemFile.c_str(), \"w\");\n#endif\n\n    if (!f) {\n        CUtils::PrintStatus(false, \"Unable to open\");\n        return false;\n    }\n\n    CUtils::GenerateCert(f, \"\");\n    fclose(f);\n\n    CUtils::PrintStatus(true);\n    return true;\n#endif\n}\n\nvoid CZNC::DeleteUsers() {\n    for (const auto& it : m_msUsers) {\n        it.second->SetBeingDeleted(true);\n        delete it.second;\n    }\n\n    m_msUsers.clear();\n    DisableConnectQueue();\n}\n\nbool CZNC::IsHostAllowed(const CString& sHostMask) const {\n    for (const auto& it : m_msUsers) {\n        if (it.second->IsHostAllowed(sHostMask)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool CZNC::AllowConnectionFrom(const CString& sIP) const {\n    if (m_uiAnonIPLimit == 0) return true;\n    return (GetManager().GetAnonConnectionCount(sIP) < m_uiAnonIPLimit);\n}\n\nvoid CZNC::InitDirs(const CString& sArgvPath, const CString& sDataDir) {\n    // If the bin was not ran from the current directory, we need to add that\n    // dir onto our cwd\n    CString::size_type uPos = sArgvPath.rfind('/');\n    if (uPos == CString::npos)\n        m_sCurPath = \"./\";\n    else\n        m_sCurPath = CDir::ChangeDir(\"./\", sArgvPath.Left(uPos), \"\");\n\n    // Try to set the user's home dir, default to binpath on failure\n    CFile::InitHomePath(m_sCurPath);\n\n    if (sDataDir.empty()) {\n        m_sZNCPath = CFile::GetHomePath() + \"/.znc\";\n    } else {\n        m_sZNCPath = sDataDir;\n    }\n\n    m_sSSLCertFile = m_sZNCPath + \"/znc.pem\";\n}\n\nCString CZNC::GetConfPath(bool bAllowMkDir) const {\n    CString sConfPath = m_sZNCPath + \"/configs\";\n    if (bAllowMkDir && !CFile::Exists(sConfPath)) {\n        CDir::MakeDir(sConfPath);\n    }\n\n    return sConfPath;\n}\n\nCString CZNC::GetUserPath() const {\n    CString sUserPath = m_sZNCPath + \"/users\";\n    if (!CFile::Exists(sUserPath)) {\n        CDir::MakeDir(sUserPath);\n    }\n\n    return sUserPath;\n}\n\nCString CZNC::GetModPath() const {\n    CString sModPath = m_sZNCPath + \"/modules\";\n\n    return sModPath;\n}\n\nconst CString& CZNC::GetCurPath() const {\n    if (!CFile::Exists(m_sCurPath)) {\n        CDir::MakeDir(m_sCurPath);\n    }\n    return m_sCurPath;\n}\n\nconst CString& CZNC::GetHomePath() const { return CFile::GetHomePath(); }\n\nconst CString& CZNC::GetZNCPath() const {\n    if (!CFile::Exists(m_sZNCPath)) {\n        CDir::MakeDir(m_sZNCPath);\n    }\n    return m_sZNCPath;\n}\n\nCString CZNC::GetPemLocation() const {\n    return CDir::ChangeDir(\"\", m_sSSLCertFile);\n}\n\nCString CZNC::GetKeyLocation() const {\n    return CDir::ChangeDir(\n        \"\", m_sSSLKeyFile.empty() ? m_sSSLCertFile : m_sSSLKeyFile);\n}\n\nCString CZNC::GetDHParamLocation() const {\n    return CDir::ChangeDir(\n        \"\", m_sSSLDHParamFile.empty() ? m_sSSLCertFile : m_sSSLDHParamFile);\n}\n\nCString CZNC::ExpandConfigPath(const CString& sConfigFile, bool bAllowMkDir) {\n    CString sRetPath;\n\n    if (sConfigFile.empty()) {\n        sRetPath = GetConfPath(bAllowMkDir) + \"/znc.conf\";\n    } else {\n        if (sConfigFile.StartsWith(\"./\") || sConfigFile.StartsWith(\"../\")) {\n            sRetPath = GetCurPath() + \"/\" + sConfigFile;\n        } else if (!sConfigFile.StartsWith(\"/\")) {\n            sRetPath = GetConfPath(bAllowMkDir) + \"/\" + sConfigFile;\n        } else {\n            sRetPath = sConfigFile;\n        }\n    }\n\n    return sRetPath;\n}\n\nbool CZNC::WriteConfig() {\n    if (GetConfigFile().empty()) {\n        DEBUG(\"Config file name is empty?!\");\n        return false;\n    }\n\n    // We first write to a temporary file and then move it to the right place\n    CFile* pFile = new CFile(GetConfigFile() + \"~\");\n\n    if (!pFile->Open(O_WRONLY | O_CREAT | O_TRUNC, 0600)) {\n        DEBUG(\"Could not write config to \" + GetConfigFile() + \"~: \" +\n              CString(strerror(errno)));\n        delete pFile;\n        return false;\n    }\n\n    // We have to \"transfer\" our lock on the config to the new file.\n    // The old file (= inode) is going away and thus a lock on it would be\n    // useless. These lock should always succeed (races, anyone?).\n    if (!pFile->TryExLock()) {\n        DEBUG(\"Error while locking the new config file, errno says: \" +\n              CString(strerror(errno)));\n        pFile->Delete();\n        delete pFile;\n        return false;\n    }\n\n    pFile->Write(MakeConfigHeader() + \"\\n\");\n\n    CConfig config;\n    config.AddKeyValuePair(\"AnonIPLimit\", CString(m_uiAnonIPLimit));\n    config.AddKeyValuePair(\"MaxBufferSize\", CString(m_uiMaxBufferSize));\n    config.AddKeyValuePair(\"SSLCertFile\", CString(GetPemLocation()));\n    config.AddKeyValuePair(\"SSLKeyFile\", CString(GetKeyLocation()));\n    config.AddKeyValuePair(\"SSLDHParamFile\", CString(GetDHParamLocation()));\n    config.AddKeyValuePair(\"ProtectWebSessions\",\n                           CString(m_bProtectWebSessions));\n    config.AddKeyValuePair(\"HideVersion\", CString(m_bHideVersion));\n    config.AddKeyValuePair(\"AuthOnlyViaModule\", CString(m_bAuthOnlyViaModule));\n    config.AddKeyValuePair(\"Version\", CString(VERSION_STR));\n    config.AddKeyValuePair(\"ConfigWriteDelay\", CString(m_uiConfigWriteDelay));\n\n    unsigned int l = 0;\n    for (CListener* pListener : m_vpListeners) {\n        CConfig listenerConfig;\n\n        listenerConfig.AddKeyValuePair(\"Host\", pListener->GetBindHost());\n        listenerConfig.AddKeyValuePair(\"URIPrefix\",\n                                       pListener->GetURIPrefix() + \"/\");\n        listenerConfig.AddKeyValuePair(\"Port\", CString(pListener->GetPort()));\n\n        listenerConfig.AddKeyValuePair(\n            \"IPv4\", CString(pListener->GetAddrType() != ADDR_IPV6ONLY));\n        listenerConfig.AddKeyValuePair(\n            \"IPv6\", CString(pListener->GetAddrType() != ADDR_IPV4ONLY));\n\n        listenerConfig.AddKeyValuePair(\"SSL\", CString(pListener->IsSSL()));\n\n        listenerConfig.AddKeyValuePair(\n            \"AllowIRC\",\n            CString(pListener->GetAcceptType() != CListener::ACCEPT_HTTP));\n        listenerConfig.AddKeyValuePair(\n            \"AllowWeb\",\n            CString(pListener->GetAcceptType() != CListener::ACCEPT_IRC));\n\n        config.AddSubConfig(\"Listener\", \"listener\" + CString(l++),\n                            listenerConfig);\n    }\n\n    config.AddKeyValuePair(\"ConnectDelay\", CString(m_uiConnectDelay));\n    config.AddKeyValuePair(\"ServerThrottle\",\n                           CString(m_sConnectThrottle.GetTTL() / 1000));\n\n    if (!m_sPidFile.empty()) {\n        config.AddKeyValuePair(\"PidFile\", m_sPidFile.FirstLine());\n    }\n\n    if (!m_sSkinName.empty()) {\n        config.AddKeyValuePair(\"Skin\", m_sSkinName.FirstLine());\n    }\n\n    if (!m_sStatusPrefix.empty()) {\n        config.AddKeyValuePair(\"StatusPrefix\", m_sStatusPrefix.FirstLine());\n    }\n\n    if (!m_sSSLCiphers.empty()) {\n        config.AddKeyValuePair(\"SSLCiphers\", CString(m_sSSLCiphers));\n    }\n\n    if (!m_sSSLProtocols.empty()) {\n        config.AddKeyValuePair(\"SSLProtocols\", m_sSSLProtocols);\n    }\n\n    for (const CString& sLine : m_vsMotd) {\n        config.AddKeyValuePair(\"Motd\", sLine.FirstLine());\n    }\n\n    for (const CString& sProxy : m_vsTrustedProxies) {\n        config.AddKeyValuePair(\"TrustedProxy\", sProxy.FirstLine());\n    }\n\n    CModules& Mods = GetModules();\n\n    for (const CModule* pMod : Mods) {\n        CString sName = pMod->GetModName();\n        CString sArgs = pMod->GetArgs();\n\n        if (!sArgs.empty()) {\n            sArgs = \" \" + sArgs.FirstLine();\n        }\n\n        config.AddKeyValuePair(\"LoadModule\", sName.FirstLine() + sArgs);\n    }\n\n    for (const auto& it : m_msUsers) {\n        CString sErr;\n\n        if (!it.second->IsValid(sErr)) {\n            DEBUG(\"** Error writing config for user [\" << it.first << \"] [\"\n                                                       << sErr << \"]\");\n            continue;\n        }\n\n        config.AddSubConfig(\"User\", it.second->GetUserName(),\n                            it.second->ToConfig());\n    }\n\n    config.Write(*pFile);\n\n    // If Sync() fails... well, let's hope nothing important breaks..\n    pFile->Sync();\n\n    if (pFile->HadError()) {\n        DEBUG(\"Error while writing the config, errno says: \" +\n              CString(strerror(errno)));\n        pFile->Delete();\n        delete pFile;\n        return false;\n    }\n\n    // We wrote to a temporary name, move it to the right place\n    if (!pFile->Move(GetConfigFile(), true)) {\n        DEBUG(\n            \"Error while replacing the config file with a new version, errno \"\n            \"says \"\n            << strerror(errno));\n        pFile->Delete();\n        delete pFile;\n        return false;\n    }\n\n    // Everything went fine, just need to update the saved path.\n    pFile->SetFileName(GetConfigFile());\n\n    // Make sure the lock is kept alive as long as we need it.\n    delete m_pLockFile;\n    m_pLockFile = pFile;\n\n    return true;\n}\n\nCString CZNC::MakeConfigHeader() {\n    return \"// WARNING\\n\"\n           \"//\\n\"\n           \"// Do NOT edit this file while ZNC is running!\\n\"\n           \"// Use webadmin or *controlpanel instead.\\n\"\n           \"//\\n\"\n           \"// Altering this file by hand will forfeit all support.\\n\"\n           \"//\\n\"\n           \"// But if you feel risky, you might want to read help on /znc \"\n           \"saveconfig and /znc rehash.\\n\"\n           \"// Also check https://wiki.znc.in/Configuration\\n\";\n}\n\nbool CZNC::WriteNewConfig(const CString& sConfigFile) {\n    CString sAnswer, sUser, sNetwork;\n    VCString vsLines;\n\n    vsLines.push_back(MakeConfigHeader());\n    vsLines.push_back(\"Version = \" + CString(VERSION_STR));\n\n    m_sConfigFile = ExpandConfigPath(sConfigFile);\n\n    if (CFile::Exists(m_sConfigFile)) {\n        CUtils::PrintStatus(\n            false, \"WARNING: config [\" + m_sConfigFile + \"] already exists.\");\n    }\n\n    CUtils::PrintMessage(\"\");\n    CUtils::PrintMessage(\"-- Global settings --\");\n    CUtils::PrintMessage(\"\");\n\n// Listen\n#ifdef HAVE_IPV6\n    bool b6 = true;\n#else\n    bool b6 = false;\n#endif\n    CString sListenHost;\n    CString sURIPrefix;\n    bool bListenSSL = false;\n    unsigned int uListenPort = 0;\n    bool bSuccess;\n\n    do {\n        bSuccess = true;\n        while (true) {\n            if (!CUtils::GetNumInput(\"Listen on port\", uListenPort, 1025,\n                                     65534)) {\n                continue;\n            }\n            if (uListenPort == 6667) {\n                CUtils::PrintStatus(false,\n                                    \"WARNING: Some web browsers reject port \"\n                                    \"6667. If you intend to\");\n                CUtils::PrintStatus(false,\n                                    \"use ZNC's web interface, you might want \"\n                                    \"to use another port.\");\n                if (!CUtils::GetBoolInput(\"Proceed with port 6667 anyway?\",\n                                          true)) {\n                    continue;\n                }\n            }\n            break;\n        }\n\n#ifdef HAVE_LIBSSL\n        bListenSSL = CUtils::GetBoolInput(\"Listen using SSL\", bListenSSL);\n#endif\n\n#ifdef HAVE_IPV6\n        b6 = CUtils::GetBoolInput(\"Listen using both IPv4 and IPv6\", b6);\n#endif\n\n        // Don't ask for listen host, it may be configured later if needed.\n\n        CUtils::PrintAction(\"Verifying the listener\");\n        CListener* pListener = new CListener(\n            (unsigned short int)uListenPort, sListenHost, sURIPrefix,\n            bListenSSL, b6 ? ADDR_ALL : ADDR_IPV4ONLY, CListener::ACCEPT_ALL);\n        if (!pListener->Listen()) {\n            CUtils::PrintStatus(false, FormatBindError());\n            bSuccess = false;\n        } else\n            CUtils::PrintStatus(true);\n        delete pListener;\n    } while (!bSuccess);\n\n#ifdef HAVE_LIBSSL\n    CString sPemFile = GetPemLocation();\n    if (!CFile::Exists(sPemFile)) {\n        CUtils::PrintMessage(\"Unable to locate pem file: [\" + sPemFile +\n                             \"], creating it\");\n        WritePemFile();\n    }\n#endif\n\n    vsLines.push_back(\"<Listener l>\");\n    vsLines.push_back(\"\\tPort = \" + CString(uListenPort));\n    vsLines.push_back(\"\\tIPv4 = true\");\n    vsLines.push_back(\"\\tIPv6 = \" + CString(b6));\n    vsLines.push_back(\"\\tSSL = \" + CString(bListenSSL));\n    if (!sListenHost.empty()) {\n        vsLines.push_back(\"\\tHost = \" + sListenHost);\n    }\n    vsLines.push_back(\"</Listener>\");\n    // !Listen\n\n    set<CModInfo> ssGlobalMods;\n    GetModules().GetDefaultMods(ssGlobalMods, CModInfo::GlobalModule);\n    vector<CString> vsGlobalModNames;\n    for (const CModInfo& Info : ssGlobalMods) {\n        vsGlobalModNames.push_back(Info.GetName());\n        vsLines.push_back(\"LoadModule = \" + Info.GetName());\n    }\n    CUtils::PrintMessage(\n        \"Enabled global modules [\" +\n        CString(\", \").Join(vsGlobalModNames.begin(), vsGlobalModNames.end()) +\n        \"]\");\n\n    // User\n    CUtils::PrintMessage(\"\");\n    CUtils::PrintMessage(\"-- Admin user settings --\");\n    CUtils::PrintMessage(\"\");\n\n    vsLines.push_back(\"\");\n    CString sNick;\n    do {\n        CUtils::GetInput(\"Username\", sUser, \"\", \"alphanumeric\");\n    } while (!CUser::IsValidUserName(sUser));\n\n    vsLines.push_back(\"<User \" + sUser + \">\");\n    CString sSalt;\n    sAnswer = CUtils::GetSaltedHashPass(sSalt);\n    vsLines.push_back(\"\\tPass       = \" + CUtils::sDefaultHash + \"#\" + sAnswer +\n                      \"#\" + sSalt + \"#\");\n\n    vsLines.push_back(\"\\tAdmin      = true\");\n\n    CUtils::GetInput(\"Nick\", sNick, CUser::MakeCleanUserName(sUser));\n    vsLines.push_back(\"\\tNick       = \" + sNick);\n    CUtils::GetInput(\"Alternate nick\", sAnswer, sNick + \"_\");\n    if (!sAnswer.empty()) {\n        vsLines.push_back(\"\\tAltNick    = \" + sAnswer);\n    }\n    CUtils::GetInput(\"Ident\", sAnswer, sUser);\n    vsLines.push_back(\"\\tIdent      = \" + sAnswer);\n    CUtils::GetInput(\"Real name\", sAnswer, \"\", \"optional\");\n    if (!sAnswer.empty()) {\n        vsLines.push_back(\"\\tRealName   = \" + sAnswer);\n    }\n    CUtils::GetInput(\"Bind host\", sAnswer, \"\", \"optional\");\n    if (!sAnswer.empty()) {\n        vsLines.push_back(\"\\tBindHost   = \" + sAnswer);\n    }\n\n    set<CModInfo> ssUserMods;\n    GetModules().GetDefaultMods(ssUserMods, CModInfo::UserModule);\n    vector<CString> vsUserModNames;\n    for (const CModInfo& Info : ssUserMods) {\n        vsUserModNames.push_back(Info.GetName());\n        vsLines.push_back(\"\\tLoadModule = \" + Info.GetName());\n    }\n    CUtils::PrintMessage(\n        \"Enabled user modules [\" +\n        CString(\", \").Join(vsUserModNames.begin(), vsUserModNames.end()) + \"]\");\n\n    CUtils::PrintMessage(\"\");\n    if (CUtils::GetBoolInput(\"Set up a network?\", true)) {\n        vsLines.push_back(\"\");\n\n        CUtils::PrintMessage(\"\");\n        CUtils::PrintMessage(\"-- Network settings --\");\n        CUtils::PrintMessage(\"\");\n\n        do {\n            CUtils::GetInput(\"Name\", sNetwork, \"freenode\");\n        } while (!CIRCNetwork::IsValidNetwork(sNetwork));\n\n        vsLines.push_back(\"\\t<Network \" + sNetwork + \">\");\n\n        set<CModInfo> ssNetworkMods;\n        GetModules().GetDefaultMods(ssNetworkMods, CModInfo::NetworkModule);\n        vector<CString> vsNetworkModNames;\n        for (const CModInfo& Info : ssNetworkMods) {\n            vsNetworkModNames.push_back(Info.GetName());\n            vsLines.push_back(\"\\t\\tLoadModule = \" + Info.GetName());\n        }\n\n        CString sHost, sPass, sHint;\n        bool bSSL = false;\n        unsigned int uServerPort = 0;\n\n        if (sNetwork.Equals(\"freenode\")) {\n            sHost = \"chat.freenode.net\";\n#ifdef HAVE_LIBSSL\n            bSSL = true;\n#endif\n        } else {\n            sHint = \"host only\";\n        }\n\n        while (!CUtils::GetInput(\"Server host\", sHost, sHost, sHint) ||\n               !CServer::IsValidHostName(sHost))\n            ;\n#ifdef HAVE_LIBSSL\n        bSSL = CUtils::GetBoolInput(\"Server uses SSL?\", bSSL);\n#endif\n        while (!CUtils::GetNumInput(\"Server port\", uServerPort, 1, 65535,\n                                    bSSL ? 6697 : 6667))\n            ;\n        CUtils::GetInput(\"Server password (probably empty)\", sPass);\n\n        vsLines.push_back(\"\\t\\tServer     = \" + sHost + ((bSSL) ? \" +\" : \" \") +\n                          CString(uServerPort) + \" \" + sPass);\n\n        CString sChans;\n        if (CUtils::GetInput(\"Initial channels\", sChans)) {\n            vsLines.push_back(\"\");\n            VCString vsChans;\n            sChans.Replace(\",\", \" \");\n            sChans.Replace(\";\", \" \");\n            sChans.Split(\" \", vsChans, false, \"\", \"\", true, true);\n            for (const CString& sChan : vsChans) {\n                vsLines.push_back(\"\\t\\t<Chan \" + sChan + \">\");\n                vsLines.push_back(\"\\t\\t</Chan>\");\n            }\n        }\n\n        CUtils::PrintMessage(\"Enabled network modules [\" +\n                             CString(\", \").Join(vsNetworkModNames.begin(),\n                                                vsNetworkModNames.end()) +\n                             \"]\");\n\n        vsLines.push_back(\"\\t</Network>\");\n    }\n\n    vsLines.push_back(\"</User>\");\n\n    CUtils::PrintMessage(\"\");\n    // !User\n\n    CFile File;\n    bool bFileOK, bFileOpen = false;\n    do {\n        CUtils::PrintAction(\"Writing config [\" + m_sConfigFile + \"]\");\n\n        bFileOK = true;\n        if (CFile::Exists(m_sConfigFile)) {\n            if (!File.TryExLock(m_sConfigFile)) {\n                CUtils::PrintStatus(false,\n                                    \"ZNC is currently running on this config.\");\n                bFileOK = false;\n            } else {\n                File.Close();\n                CUtils::PrintStatus(false, \"This config already exists.\");\n                if (CUtils::GetBoolInput(\n                        \"Are you sure you want to overwrite it?\", false))\n                    CUtils::PrintAction(\"Overwriting config [\" + m_sConfigFile +\n                                        \"]\");\n                else\n                    bFileOK = false;\n            }\n        }\n\n        if (bFileOK) {\n            File.SetFileName(m_sConfigFile);\n            if (File.Open(O_WRONLY | O_CREAT | O_TRUNC, 0600)) {\n                bFileOpen = true;\n            } else {\n                CUtils::PrintStatus(false, \"Unable to open file\");\n                bFileOK = false;\n            }\n        }\n        if (!bFileOK) {\n            while (!CUtils::GetInput(\"Please specify an alternate location\",\n                                     m_sConfigFile, \"\",\n                                     \"or \\\"stdout\\\" for displaying the config\"))\n                ;\n            if (m_sConfigFile.Equals(\"stdout\"))\n                bFileOK = true;\n            else\n                m_sConfigFile = ExpandConfigPath(m_sConfigFile);\n        }\n    } while (!bFileOK);\n\n    if (!bFileOpen) {\n        CUtils::PrintMessage(\"\");\n        CUtils::PrintMessage(\"Printing the new config to stdout:\");\n        CUtils::PrintMessage(\"\");\n        cout << endl << \"------------------------------------------------------\"\n                        \"----------------------\" << endl << endl;\n    }\n\n    for (const CString& sLine : vsLines) {\n        if (bFileOpen) {\n            File.Write(sLine + \"\\n\");\n        } else {\n            cout << sLine << endl;\n        }\n    }\n\n    if (bFileOpen) {\n        File.Close();\n        if (File.HadError())\n            CUtils::PrintStatus(false,\n                                \"There was an error while writing the config\");\n        else\n            CUtils::PrintStatus(true);\n    } else {\n        cout << endl << \"------------------------------------------------------\"\n                        \"----------------------\" << endl << endl;\n    }\n\n    if (File.HadError()) {\n        bFileOpen = false;\n        CUtils::PrintMessage(\"Printing the new config to stdout instead:\");\n        cout << endl << \"------------------------------------------------------\"\n                        \"----------------------\" << endl << endl;\n        for (const CString& sLine : vsLines) {\n            cout << sLine << endl;\n        }\n        cout << endl << \"------------------------------------------------------\"\n                        \"----------------------\" << endl << endl;\n    }\n\n    const CString sProtocol(bListenSSL ? \"https\" : \"http\");\n    const CString sSSL(bListenSSL ? \"+\" : \"\");\n    CUtils::PrintMessage(\"\");\n    CUtils::PrintMessage(\n        \"To connect to this ZNC you need to connect to it as your IRC server\",\n        true);\n    CUtils::PrintMessage(\n        \"using the port that you supplied.  You have to supply your login info\",\n        true);\n    CUtils::PrintMessage(\n        \"as the IRC server password like this: user/network:pass.\", true);\n    CUtils::PrintMessage(\"\");\n    CUtils::PrintMessage(\"Try something like this in your IRC client...\", true);\n    CUtils::PrintMessage(\"/server <znc_server_ip> \" + sSSL +\n                             CString(uListenPort) + \" \" + sUser + \":<pass>\",\n                         true);\n    CUtils::PrintMessage(\"\");\n    CUtils::PrintMessage(\n        \"To manage settings, users and networks, point your web browser to\",\n        true);\n    CUtils::PrintMessage(\n        sProtocol + \"://<znc_server_ip>:\" + CString(uListenPort) + \"/\", true);\n    CUtils::PrintMessage(\"\");\n\n    File.UnLock();\n\n    bool bWantLaunch = bFileOpen;\n    if (bWantLaunch) {\n        // \"export ZNC_NO_LAUNCH_AFTER_MAKECONF=1\" would cause znc --makeconf to\n        // not offer immediate launch.\n        // Useful for distros which want to create config when znc package is\n        // installed.\n        // See https://github.com/znc/znc/pull/257\n        char* szNoLaunch = getenv(\"ZNC_NO_LAUNCH_AFTER_MAKECONF\");\n        if (szNoLaunch && *szNoLaunch == '1') {\n            bWantLaunch = false;\n        }\n    }\n    if (bWantLaunch) {\n        bWantLaunch = CUtils::GetBoolInput(\"Launch ZNC now?\", true);\n    }\n    return bWantLaunch;\n}\n\nvoid CZNC::BackupConfigOnce(const CString& sSuffix) {\n    static bool didBackup = false;\n    if (didBackup) return;\n    didBackup = true;\n\n    CUtils::PrintAction(\"Creating a config backup\");\n\n    CString sBackup = CDir::ChangeDir(m_sConfigFile, \"../znc.conf.\" + sSuffix);\n    if (CFile::Copy(m_sConfigFile, sBackup))\n        CUtils::PrintStatus(true, sBackup);\n    else\n        CUtils::PrintStatus(false, strerror(errno));\n}\n\nbool CZNC::ParseConfig(const CString& sConfig, CString& sError) {\n    m_sConfigFile = ExpandConfigPath(sConfig, false);\n\n    CConfig config;\n    if (!ReadConfig(config, sError)) return false;\n\n    if (!LoadGlobal(config, sError)) return false;\n\n    if (!LoadUsers(config, sError)) return false;\n\n    return true;\n}\n\nbool CZNC::ReadConfig(CConfig& config, CString& sError) {\n    sError.clear();\n\n    CUtils::PrintAction(\"Opening config [\" + m_sConfigFile + \"]\");\n\n    if (!CFile::Exists(m_sConfigFile)) {\n        sError = \"No such file\";\n        CUtils::PrintStatus(false, sError);\n        CUtils::PrintMessage(\n            \"Restart ZNC with the --makeconf option if you wish to create this \"\n            \"config.\");\n        return false;\n    }\n\n    if (!CFile::IsReg(m_sConfigFile)) {\n        sError = \"Not a file\";\n        CUtils::PrintStatus(false, sError);\n        return false;\n    }\n\n    CFile* pFile = new CFile(m_sConfigFile);\n\n    // need to open the config file Read/Write for fcntl()\n    // exclusive locking to work properly!\n    if (!pFile->Open(m_sConfigFile, O_RDWR)) {\n        sError = \"Can not open config file\";\n        CUtils::PrintStatus(false, sError);\n        delete pFile;\n        return false;\n    }\n\n    if (!pFile->TryExLock()) {\n        sError = \"ZNC is already running on this config.\";\n        CUtils::PrintStatus(false, sError);\n        delete pFile;\n        return false;\n    }\n\n    // (re)open the config file\n    delete m_pLockFile;\n    m_pLockFile = pFile;\n    CFile& File = *pFile;\n\n    if (!config.Parse(File, sError)) {\n        CUtils::PrintStatus(false, sError);\n        return false;\n    }\n    CUtils::PrintStatus(true);\n\n    // check if config is from old ZNC version and\n    // create a backup file if necessary\n    CString sSavedVersion;\n    config.FindStringEntry(\"version\", sSavedVersion);\n    if (sSavedVersion.empty()) {\n        CUtils::PrintError(\n            \"Config does not contain a version identifier. It may be be too \"\n            \"old or corrupt.\");\n        return false;\n    }\n\n    tuple<unsigned int, unsigned int> tSavedVersion =\n        make_tuple(sSavedVersion.Token(0, false, \".\").ToUInt(),\n                   sSavedVersion.Token(1, false, \".\").ToUInt());\n    tuple<unsigned int, unsigned int> tCurrentVersion =\n        make_tuple(VERSION_MAJOR, VERSION_MINOR);\n    if (tSavedVersion < tCurrentVersion) {\n        CUtils::PrintMessage(\"Found old config from ZNC \" + sSavedVersion +\n                             \". Saving a backup of it.\");\n        BackupConfigOnce(\"pre-\" + CString(VERSION_STR));\n    } else if (tSavedVersion > tCurrentVersion) {\n        CUtils::PrintError(\"Config was saved from ZNC \" + sSavedVersion +\n                           \". It may or may not work with current ZNC \" +\n                           GetVersion());\n    }\n\n    return true;\n}\n\nbool CZNC::RehashConfig(CString& sError) {\n    ALLMODULECALL(OnPreRehash(), NOTHING);\n\n    CConfig config;\n    if (!ReadConfig(config, sError)) return false;\n\n    if (!LoadGlobal(config, sError)) return false;\n\n    // do not reload users - it's dangerous!\n\n    ALLMODULECALL(OnPostRehash(), NOTHING);\n    return true;\n}\n\nbool CZNC::LoadGlobal(CConfig& config, CString& sError) {\n    sError.clear();\n\n    MCString msModules;  // Modules are queued for later loading\n\n    VCString vsList;\n    config.FindStringVector(\"loadmodule\", vsList);\n    for (const CString& sModLine : vsList) {\n        CString sModName = sModLine.Token(0);\n        CString sArgs = sModLine.Token(1, true);\n\n        // compatibility for pre-1.0 configs\n        CString sSavedVersion;\n        config.FindStringEntry(\"version\", sSavedVersion);\n        tuple<unsigned int, unsigned int> tSavedVersion =\n            make_tuple(sSavedVersion.Token(0, false, \".\").ToUInt(),\n                       sSavedVersion.Token(1, false, \".\").ToUInt());\n        if (sModName == \"saslauth\" && tSavedVersion < make_tuple(0, 207)) {\n            CUtils::PrintMessage(\n                \"saslauth module was renamed to cyrusauth. Loading cyrusauth \"\n                \"instead.\");\n            sModName = \"cyrusauth\";\n        }\n        // end-compatibility for pre-1.0 configs\n\n        if (msModules.find(sModName) != msModules.end()) {\n            sError = \"Module [\" + sModName + \"] already loaded\";\n            CUtils::PrintError(sError);\n            return false;\n        }\n        CString sModRet;\n        CModule* pOldMod;\n\n        pOldMod = GetModules().FindModule(sModName);\n        if (!pOldMod) {\n            CUtils::PrintAction(\"Loading global module [\" + sModName + \"]\");\n\n            bool bModRet =\n                GetModules().LoadModule(sModName, sArgs, CModInfo::GlobalModule,\n                                        nullptr, nullptr, sModRet);\n\n            CUtils::PrintStatus(bModRet, bModRet ? \"\" : sModRet);\n            if (!bModRet) {\n                sError = sModRet;\n                return false;\n            }\n        } else if (pOldMod->GetArgs() != sArgs) {\n            CUtils::PrintAction(\"Reloading global module [\" + sModName + \"]\");\n\n            bool bModRet = GetModules().ReloadModule(sModName, sArgs, nullptr,\n                                                     nullptr, sModRet);\n\n            CUtils::PrintStatus(bModRet, sModRet);\n            if (!bModRet) {\n                sError = sModRet;\n                return false;\n            }\n        } else\n            CUtils::PrintMessage(\"Module [\" + sModName + \"] already loaded.\");\n\n        msModules[sModName] = sArgs;\n    }\n\n    m_vsMotd.clear();\n    config.FindStringVector(\"motd\", vsList);\n    for (const CString& sMotd : vsList) {\n        AddMotd(sMotd);\n    }\n\n    if (config.FindStringVector(\"bindhost\", vsList)) {\n        CUtils::PrintStatus(false,\n                            \"WARNING: the global BindHost list is deprecated. \"\n                            \"Ignoring the following lines:\");\n        for (const CString& sHost : vsList) {\n            CUtils::PrintStatus(false, \"BindHost = \" + sHost);\n        }\n    }\n    if (config.FindStringVector(\"vhost\", vsList)) {\n        CUtils::PrintStatus(false,\n                            \"WARNING: the global vHost list is deprecated. \"\n                            \"Ignoring the following lines:\");\n        for (const CString& sHost : vsList) {\n            CUtils::PrintStatus(false, \"vHost = \" + sHost);\n        }\n    }\n\n    m_vsTrustedProxies.clear();\n    config.FindStringVector(\"trustedproxy\", vsList);\n    for (const CString& sProxy : vsList) {\n        AddTrustedProxy(sProxy);\n    }\n\n    CString sVal;\n    if (config.FindStringEntry(\"pidfile\", sVal)) m_sPidFile = sVal;\n    if (config.FindStringEntry(\"statusprefix\", sVal)) m_sStatusPrefix = sVal;\n    if (config.FindStringEntry(\"sslcertfile\", sVal)) m_sSSLCertFile = sVal;\n    if (config.FindStringEntry(\"sslkeyfile\", sVal)) m_sSSLKeyFile = sVal;\n    if (config.FindStringEntry(\"ssldhparamfile\", sVal))\n        m_sSSLDHParamFile = sVal;\n    if (config.FindStringEntry(\"sslciphers\", sVal)) m_sSSLCiphers = sVal;\n    if (config.FindStringEntry(\"skin\", sVal)) SetSkinName(sVal);\n    if (config.FindStringEntry(\"connectdelay\", sVal))\n        SetConnectDelay(sVal.ToUInt());\n    if (config.FindStringEntry(\"serverthrottle\", sVal))\n        m_sConnectThrottle.SetTTL(sVal.ToUInt() * 1000);\n    if (config.FindStringEntry(\"anoniplimit\", sVal))\n        m_uiAnonIPLimit = sVal.ToUInt();\n    if (config.FindStringEntry(\"maxbuffersize\", sVal))\n        m_uiMaxBufferSize = sVal.ToUInt();\n    if (config.FindStringEntry(\"protectwebsessions\", sVal))\n        m_bProtectWebSessions = sVal.ToBool();\n    if (config.FindStringEntry(\"hideversion\", sVal))\n        m_bHideVersion = sVal.ToBool();\n    if (config.FindStringEntry(\"authonlyviamodule\", sVal))\n        m_bAuthOnlyViaModule = sVal.ToBool();\n    if (config.FindStringEntry(\"sslprotocols\", sVal)) {\n        if (!SetSSLProtocols(sVal)) {\n            VCString vsProtocols = GetAvailableSSLProtocols();\n            CUtils::PrintError(\"Invalid SSLProtocols value [\" + sVal + \"]\");\n            CUtils::PrintError(\n                \"The syntax is [SSLProtocols = [+|-]<protocol> ...]\");\n            CUtils::PrintError(\n                \"Available protocols are [\" +\n                CString(\", \").Join(vsProtocols.begin(), vsProtocols.end()) +\n                \"]\");\n            return false;\n        }\n    }\n    if (config.FindStringEntry(\"configwritedelay\", sVal))\n        m_uiConfigWriteDelay = sVal.ToUInt();\n\n    UnloadRemovedModules(msModules);\n\n    if (!LoadListeners(config, sError)) return false;\n\n    return true;\n}\n\nbool CZNC::LoadUsers(CConfig& config, CString& sError) {\n    sError.clear();\n\n    m_msUsers.clear();\n\n    CConfig::SubConfig subConf;\n    config.FindSubConfig(\"user\", subConf);\n\n    for (const auto& subIt : subConf) {\n        const CString& sUserName = subIt.first;\n        CConfig* pSubConf = subIt.second.m_pSubConfig;\n\n        CUtils::PrintMessage(\"Loading user [\" + sUserName + \"]\");\n\n        std::unique_ptr<CUser> pUser(new CUser(sUserName));\n\n        if (!m_sStatusPrefix.empty()) {\n            if (!pUser->SetStatusPrefix(m_sStatusPrefix)) {\n                sError = \"Invalid StatusPrefix [\" + m_sStatusPrefix +\n                         \"] Must be 1-5 chars, no spaces.\";\n                CUtils::PrintError(sError);\n                return false;\n            }\n        }\n\n        if (!pUser->ParseConfig(pSubConf, sError)) {\n            CUtils::PrintError(sError);\n            return false;\n        }\n\n        if (!pSubConf->empty()) {\n            sError = \"Unhandled lines in config for User [\" + sUserName + \"]!\";\n            CUtils::PrintError(sError);\n            DumpConfig(pSubConf);\n            return false;\n        }\n\n        CString sErr;\n        if (!AddUser(pUser.release(), sErr, true)) {\n            sError = \"Invalid user [\" + sUserName + \"] \" + sErr;\n        }\n\n        if (!sError.empty()) {\n            CUtils::PrintError(sError);\n            pUser->SetBeingDeleted(true);\n            return false;\n        }\n    }\n\n    if (m_msUsers.empty()) {\n        sError = \"You must define at least one user in your config.\";\n        CUtils::PrintError(sError);\n        return false;\n    }\n\n    return true;\n}\n\nbool CZNC::LoadListeners(CConfig& config, CString& sError) {\n    sError.clear();\n\n    // Delete all listeners\n    while (!m_vpListeners.empty()) {\n        delete m_vpListeners[0];\n        m_vpListeners.erase(m_vpListeners.begin());\n    }\n\n    // compatibility for pre-1.0 configs\n    const char* szListenerEntries[] = {\"listen\",   \"listen6\",   \"listen4\",\n                                       \"listener\", \"listener6\", \"listener4\"};\n\n    VCString vsList;\n    config.FindStringVector(\"loadmodule\", vsList);\n\n    // This has to be after SSLCertFile is handled since it uses that value\n    for (const char* szEntry : szListenerEntries) {\n        config.FindStringVector(szEntry, vsList);\n        for (const CString& sListener : vsList) {\n            if (!AddListener(szEntry + CString(\" \") + sListener, sError))\n                return false;\n        }\n    }\n    // end-compatibility for pre-1.0 configs\n\n    CConfig::SubConfig subConf;\n    config.FindSubConfig(\"listener\", subConf);\n\n    for (const auto& subIt : subConf) {\n        CConfig* pSubConf = subIt.second.m_pSubConfig;\n        if (!AddListener(pSubConf, sError)) return false;\n        if (!pSubConf->empty()) {\n            sError = \"Unhandled lines in Listener config!\";\n            CUtils::PrintError(sError);\n\n            CZNC::DumpConfig(pSubConf);\n            return false;\n        }\n    }\n\n    if (m_vpListeners.empty()) {\n        sError = \"You must supply at least one Listener in your config.\";\n        CUtils::PrintError(sError);\n        return false;\n    }\n\n    return true;\n}\n\nvoid CZNC::UnloadRemovedModules(const MCString& msModules) {\n    // unload modules which are no longer in the config\n\n    set<CString> ssUnload;\n    for (CModule* pCurMod : GetModules()) {\n        if (msModules.find(pCurMod->GetModName()) == msModules.end())\n            ssUnload.insert(pCurMod->GetModName());\n    }\n\n    for (const CString& sMod : ssUnload) {\n        if (GetModules().UnloadModule(sMod))\n            CUtils::PrintMessage(\"Unloaded global module [\" + sMod + \"]\");\n        else\n            CUtils::PrintMessage(\"Could not unload [\" + sMod + \"]\");\n    }\n}\n\nvoid CZNC::DumpConfig(const CConfig* pConfig) {\n    CConfig::EntryMapIterator eit = pConfig->BeginEntries();\n    for (; eit != pConfig->EndEntries(); ++eit) {\n        const CString& sKey = eit->first;\n        const VCString& vsList = eit->second;\n        VCString::const_iterator it = vsList.begin();\n        for (; it != vsList.end(); ++it) {\n            CUtils::PrintError(sKey + \" = \" + *it);\n        }\n    }\n\n    CConfig::SubConfigMapIterator sit = pConfig->BeginSubConfigs();\n    for (; sit != pConfig->EndSubConfigs(); ++sit) {\n        const CString& sKey = sit->first;\n        const CConfig::SubConfig& sSub = sit->second;\n        CConfig::SubConfig::const_iterator it = sSub.begin();\n\n        for (; it != sSub.end(); ++it) {\n            CUtils::PrintError(\"SubConfig [\" + sKey + \" \" + it->first + \"]:\");\n            DumpConfig(it->second.m_pSubConfig);\n        }\n    }\n}\n\nvoid CZNC::ClearTrustedProxies() { m_vsTrustedProxies.clear(); }\n\nbool CZNC::AddTrustedProxy(const CString& sHost) {\n    if (sHost.empty()) {\n        return false;\n    }\n\n    for (const CString& sTrustedProxy : m_vsTrustedProxies) {\n        if (sTrustedProxy.Equals(sHost)) {\n            return false;\n        }\n    }\n\n    m_vsTrustedProxies.push_back(sHost);\n    return true;\n}\n\nbool CZNC::RemTrustedProxy(const CString& sHost) {\n    VCString::iterator it;\n    for (it = m_vsTrustedProxies.begin(); it != m_vsTrustedProxies.end();\n         ++it) {\n        if (sHost.Equals(*it)) {\n            m_vsTrustedProxies.erase(it);\n            return true;\n        }\n    }\n\n    return false;\n}\n\nvoid CZNC::Broadcast(const CString& sMessage, bool bAdminOnly, CUser* pSkipUser,\n                     CClient* pSkipClient) {\n    for (const auto& it : m_msUsers) {\n        if (bAdminOnly && !it.second->IsAdmin()) continue;\n\n        if (it.second != pSkipUser) {\n            // TODO: translate message to user's language\n            CString sMsg = sMessage;\n\n            bool bContinue = false;\n            USERMODULECALL(OnBroadcast(sMsg), it.second, nullptr, &bContinue);\n            if (bContinue) continue;\n\n            it.second->PutStatusNotice(\"*** \" + sMsg, nullptr, pSkipClient);\n        }\n    }\n}\n\nCModule* CZNC::FindModule(const CString& sModName, const CString& sUsername) {\n    if (sUsername.empty()) {\n        return CZNC::Get().GetModules().FindModule(sModName);\n    }\n\n    CUser* pUser = FindUser(sUsername);\n\n    return (!pUser) ? nullptr : pUser->GetModules().FindModule(sModName);\n}\n\nCModule* CZNC::FindModule(const CString& sModName, CUser* pUser) {\n    if (pUser) {\n        return pUser->GetModules().FindModule(sModName);\n    }\n\n    return CZNC::Get().GetModules().FindModule(sModName);\n}\n\nbool CZNC::UpdateModule(const CString& sModule) {\n    CModule* pModule;\n\n    map<CUser*, CString> musLoaded;\n    map<CIRCNetwork*, CString> mnsLoaded;\n\n    // Unload the module for every user and network\n    for (const auto& it : m_msUsers) {\n        CUser* pUser = it.second;\n\n        pModule = pUser->GetModules().FindModule(sModule);\n        if (pModule) {\n            musLoaded[pUser] = pModule->GetArgs();\n            pUser->GetModules().UnloadModule(sModule);\n        }\n\n        // See if the user has this module loaded to a network\n        vector<CIRCNetwork*> vNetworks = pUser->GetNetworks();\n        for (CIRCNetwork* pNetwork : vNetworks) {\n            pModule = pNetwork->GetModules().FindModule(sModule);\n            if (pModule) {\n                mnsLoaded[pNetwork] = pModule->GetArgs();\n                pNetwork->GetModules().UnloadModule(sModule);\n            }\n        }\n    }\n\n    // Unload the global module\n    bool bGlobal = false;\n    CString sGlobalArgs;\n\n    pModule = GetModules().FindModule(sModule);\n    if (pModule) {\n        bGlobal = true;\n        sGlobalArgs = pModule->GetArgs();\n        GetModules().UnloadModule(sModule);\n    }\n\n    // Lets reload everything\n    bool bError = false;\n    CString sErr;\n\n    // Reload the global module\n    if (bGlobal) {\n        if (!GetModules().LoadModule(sModule, sGlobalArgs,\n                                     CModInfo::GlobalModule, nullptr, nullptr,\n                                     sErr)) {\n            DEBUG(\"Failed to reload [\" << sModule << \"] globally [\" << sErr\n                                       << \"]\");\n            bError = true;\n        }\n    }\n\n    // Reload the module for all users\n    for (const auto& it : musLoaded) {\n        CUser* pUser = it.first;\n        const CString& sArgs = it.second;\n\n        if (!pUser->GetModules().LoadModule(\n                sModule, sArgs, CModInfo::UserModule, pUser, nullptr, sErr)) {\n            DEBUG(\"Failed to reload [\" << sModule << \"] for [\"\n                                       << pUser->GetUserName() << \"] [\" << sErr\n                                       << \"]\");\n            bError = true;\n        }\n    }\n\n    // Reload the module for all networks\n    for (const auto& it : mnsLoaded) {\n        CIRCNetwork* pNetwork = it.first;\n        const CString& sArgs = it.second;\n\n        if (!pNetwork->GetModules().LoadModule(\n                sModule, sArgs, CModInfo::NetworkModule, pNetwork->GetUser(),\n                pNetwork, sErr)) {\n            DEBUG(\"Failed to reload [\"\n                  << sModule << \"] for [\" << pNetwork->GetUser()->GetUserName()\n                  << \"/\" << pNetwork->GetName() << \"] [\" << sErr << \"]\");\n            bError = true;\n        }\n    }\n\n    return !bError;\n}\n\nCUser* CZNC::FindUser(const CString& sUsername) {\n    map<CString, CUser*>::iterator it = m_msUsers.find(sUsername);\n\n    if (it != m_msUsers.end()) {\n        return it->second;\n    }\n\n    return nullptr;\n}\n\nbool CZNC::DeleteUser(const CString& sUsername) {\n    CUser* pUser = FindUser(sUsername);\n\n    if (!pUser) {\n        return false;\n    }\n\n    m_msDelUsers[pUser->GetUserName()] = pUser;\n    return true;\n}\n\nbool CZNC::AddUser(CUser* pUser, CString& sErrorRet, bool bStartup) {\n    if (FindUser(pUser->GetUserName()) != nullptr) {\n        sErrorRet = t_s(\"User already exists\");\n        DEBUG(\"User [\" << pUser->GetUserName() << \"] - already exists\");\n        return false;\n    }\n    if (!pUser->IsValid(sErrorRet)) {\n        DEBUG(\"Invalid user [\" << pUser->GetUserName() << \"] - [\" << sErrorRet\n                               << \"]\");\n        return false;\n    }\n    bool bFailed = false;\n\n    // do not call OnAddUser hook during ZNC startup\n    if (!bStartup) {\n        GLOBALMODULECALL(OnAddUser(*pUser, sErrorRet), &bFailed);\n    }\n\n    if (bFailed) {\n        DEBUG(\"AddUser [\" << pUser->GetUserName() << \"] aborted by a module [\"\n                          << sErrorRet << \"]\");\n        return false;\n    }\n    m_msUsers[pUser->GetUserName()] = pUser;\n    return true;\n}\n\nCListener* CZNC::FindListener(u_short uPort, const CString& sBindHost,\n                              EAddrType eAddr) {\n    for (CListener* pListener : m_vpListeners) {\n        if (pListener->GetPort() != uPort) continue;\n        if (pListener->GetBindHost() != sBindHost) continue;\n        if (pListener->GetAddrType() != eAddr) continue;\n        return pListener;\n    }\n    return nullptr;\n}\n\nbool CZNC::AddListener(const CString& sLine, CString& sError) {\n    CString sName = sLine.Token(0);\n    CString sValue = sLine.Token(1, true);\n\n    EAddrType eAddr = ADDR_ALL;\n    if (sName.Equals(\"Listen4\") || sName.Equals(\"Listen\") ||\n        sName.Equals(\"Listener4\")) {\n        eAddr = ADDR_IPV4ONLY;\n    }\n    if (sName.Equals(\"Listener6\")) {\n        eAddr = ADDR_IPV6ONLY;\n    }\n\n    CListener::EAcceptType eAccept = CListener::ACCEPT_ALL;\n    if (sValue.TrimPrefix(\"irc_only \"))\n        eAccept = CListener::ACCEPT_IRC;\n    else if (sValue.TrimPrefix(\"web_only \"))\n        eAccept = CListener::ACCEPT_HTTP;\n\n    bool bSSL = false;\n    CString sPort;\n    CString sBindHost;\n\n    if (ADDR_IPV4ONLY == eAddr) {\n        sValue.Replace(\":\", \" \");\n    }\n\n    if (sValue.Contains(\" \")) {\n        sBindHost = sValue.Token(0, false, \" \");\n        sPort = sValue.Token(1, true, \" \");\n    } else {\n        sPort = sValue;\n    }\n\n    if (sPort.TrimPrefix(\"+\")) {\n        bSSL = true;\n    }\n\n    // No support for URIPrefix for old-style configs.\n    CString sURIPrefix;\n    unsigned short uPort = sPort.ToUShort();\n    return AddListener(uPort, sBindHost, sURIPrefix, bSSL, eAddr, eAccept,\n                       sError);\n}\n\nbool CZNC::AddListener(unsigned short uPort, const CString& sBindHost,\n                       const CString& sURIPrefixRaw, bool bSSL, EAddrType eAddr,\n                       CListener::EAcceptType eAccept, CString& sError) {\n    CString sHostComment;\n\n    if (!sBindHost.empty()) {\n        sHostComment = \" on host [\" + sBindHost + \"]\";\n    }\n\n    CString sIPV6Comment;\n\n    switch (eAddr) {\n        case ADDR_ALL:\n            sIPV6Comment = \"\";\n            break;\n        case ADDR_IPV4ONLY:\n            sIPV6Comment = \" using ipv4\";\n            break;\n        case ADDR_IPV6ONLY:\n            sIPV6Comment = \" using ipv6\";\n    }\n\n    CUtils::PrintAction(\"Binding to port [\" + CString((bSSL) ? \"+\" : \"\") +\n                        CString(uPort) + \"]\" + sHostComment + sIPV6Comment);\n\n#ifndef HAVE_IPV6\n    if (ADDR_IPV6ONLY == eAddr) {\n        sError = t_s(\"IPv6 is not enabled\");\n        CUtils::PrintStatus(false, sError);\n        return false;\n    }\n#endif\n\n#ifndef HAVE_LIBSSL\n    if (bSSL) {\n        sError = t_s(\"SSL is not enabled\");\n        CUtils::PrintStatus(false, sError);\n        return false;\n    }\n#else\n    CString sPemFile = GetPemLocation();\n\n    if (bSSL && !CFile::Exists(sPemFile)) {\n        sError = t_f(\"Unable to locate pem file: {1}\")(sPemFile);\n        CUtils::PrintStatus(false, sError);\n\n        // If stdin is e.g. /dev/null and we call GetBoolInput(),\n        // we are stuck in an endless loop!\n        if (isatty(0) &&\n            CUtils::GetBoolInput(\"Would you like to create a new pem file?\",\n                                 true)) {\n            sError.clear();\n            WritePemFile();\n        } else {\n            return false;\n        }\n\n        CUtils::PrintAction(\"Binding to port [+\" + CString(uPort) + \"]\" +\n                            sHostComment + sIPV6Comment);\n    }\n#endif\n    if (!uPort) {\n        sError = t_s(\"Invalid port\");\n        CUtils::PrintStatus(false, sError);\n        return false;\n    }\n\n    // URIPrefix must start with a slash and end without one.\n    CString sURIPrefix = CString(sURIPrefixRaw);\n    if (!sURIPrefix.empty()) {\n        if (!sURIPrefix.StartsWith(\"/\")) {\n            sURIPrefix = \"/\" + sURIPrefix;\n        }\n        if (sURIPrefix.EndsWith(\"/\")) {\n            sURIPrefix.TrimRight(\"/\");\n        }\n    }\n\n    CListener* pListener =\n        new CListener(uPort, sBindHost, sURIPrefix, bSSL, eAddr, eAccept);\n\n    if (!pListener->Listen()) {\n        sError = FormatBindError();\n        CUtils::PrintStatus(false, sError);\n        delete pListener;\n        return false;\n    }\n\n    m_vpListeners.push_back(pListener);\n    CUtils::PrintStatus(true);\n\n    return true;\n}\n\nbool CZNC::AddListener(CConfig* pConfig, CString& sError) {\n    CString sBindHost;\n    CString sURIPrefix;\n    bool bSSL;\n    bool b4;\n#ifdef HAVE_IPV6\n    bool b6 = true;\n#else\n    bool b6 = false;\n#endif\n    bool bIRC;\n    bool bWeb;\n    unsigned short uPort;\n    if (!pConfig->FindUShortEntry(\"port\", uPort)) {\n        sError = \"No port given\";\n        CUtils::PrintError(sError);\n        return false;\n    }\n    pConfig->FindStringEntry(\"host\", sBindHost);\n    pConfig->FindBoolEntry(\"ssl\", bSSL, false);\n    pConfig->FindBoolEntry(\"ipv4\", b4, true);\n    pConfig->FindBoolEntry(\"ipv6\", b6, b6);\n    pConfig->FindBoolEntry(\"allowirc\", bIRC, true);\n    pConfig->FindBoolEntry(\"allowweb\", bWeb, true);\n    pConfig->FindStringEntry(\"uriprefix\", sURIPrefix);\n\n    EAddrType eAddr;\n    if (b4 && b6) {\n        eAddr = ADDR_ALL;\n    } else if (b4 && !b6) {\n        eAddr = ADDR_IPV4ONLY;\n    } else if (!b4 && b6) {\n        eAddr = ADDR_IPV6ONLY;\n    } else {\n        sError = \"No address family given\";\n        CUtils::PrintError(sError);\n        return false;\n    }\n\n    CListener::EAcceptType eAccept;\n    if (bIRC && bWeb) {\n        eAccept = CListener::ACCEPT_ALL;\n    } else if (bIRC && !bWeb) {\n        eAccept = CListener::ACCEPT_IRC;\n    } else if (!bIRC && bWeb) {\n        eAccept = CListener::ACCEPT_HTTP;\n    } else {\n        sError = \"Either Web or IRC or both should be selected\";\n        CUtils::PrintError(sError);\n        return false;\n    }\n\n    return AddListener(uPort, sBindHost, sURIPrefix, bSSL, eAddr, eAccept,\n                       sError);\n}\n\nbool CZNC::AddListener(CListener* pListener) {\n    if (!pListener->GetRealListener()) {\n        // Listener doesn't actually listen\n        delete pListener;\n        return false;\n    }\n\n    // We don't check if there is an identical listener already listening\n    // since one can't listen on e.g. the same port multiple times\n\n    m_vpListeners.push_back(pListener);\n    return true;\n}\n\nbool CZNC::DelListener(CListener* pListener) {\n    auto it = std::find(m_vpListeners.begin(), m_vpListeners.end(), pListener);\n    if (it != m_vpListeners.end()) {\n        m_vpListeners.erase(it);\n        delete pListener;\n        return true;\n    }\n\n    return false;\n}\n\nCString CZNC::FormatBindError() {\n    CString sError = (errno == 0 ? t_s((\"unknown error, check the host name\"))\n                                 : CString(strerror(errno)));\n    return t_f(\"Unable to bind: {1}\")(sError);\n}\n\nstatic CZNC* s_pZNC = nullptr;\n\nvoid CZNC::CreateInstance() {\n    if (s_pZNC) abort();\n\n    s_pZNC = new CZNC();\n}\n\nCZNC& CZNC::Get() { return *s_pZNC; }\n\nvoid CZNC::DestroyInstance() {\n    delete s_pZNC;\n    s_pZNC = nullptr;\n}\n\nCZNC::TrafficStatsMap CZNC::GetTrafficStats(TrafficStatsPair& Users,\n                                            TrafficStatsPair& ZNC,\n                                            TrafficStatsPair& Total) {\n    TrafficStatsMap ret;\n    unsigned long long uiUsers_in, uiUsers_out, uiZNC_in, uiZNC_out;\n    const map<CString, CUser*>& msUsers = CZNC::Get().GetUserMap();\n\n    uiUsers_in = uiUsers_out = 0;\n    uiZNC_in = BytesRead();\n    uiZNC_out = BytesWritten();\n\n    for (const auto& it : msUsers) {\n        ret[it.first] =\n            TrafficStatsPair(it.second->BytesRead(), it.second->BytesWritten());\n        uiUsers_in += it.second->BytesRead();\n        uiUsers_out += it.second->BytesWritten();\n    }\n\n    for (Csock* pSock : m_Manager) {\n        CUser* pUser = nullptr;\n        if (pSock->GetSockName().StartsWith(\"IRC::\")) {\n            pUser = ((CIRCSock*)pSock)->GetNetwork()->GetUser();\n        } else if (pSock->GetSockName().StartsWith(\"USR::\")) {\n            pUser = ((CClient*)pSock)->GetUser();\n        }\n\n        if (pUser) {\n            ret[pUser->GetUserName()].first += pSock->GetBytesRead();\n            ret[pUser->GetUserName()].second += pSock->GetBytesWritten();\n            uiUsers_in += pSock->GetBytesRead();\n            uiUsers_out += pSock->GetBytesWritten();\n        } else {\n            uiZNC_in += pSock->GetBytesRead();\n            uiZNC_out += pSock->GetBytesWritten();\n        }\n    }\n\n    Users = TrafficStatsPair(uiUsers_in, uiUsers_out);\n    ZNC = TrafficStatsPair(uiZNC_in, uiZNC_out);\n    Total = TrafficStatsPair(uiUsers_in + uiZNC_in, uiUsers_out + uiZNC_out);\n\n    return ret;\n}\n\nCZNC::TrafficStatsMap CZNC::GetNetworkTrafficStats(const CString& sUsername,\n                                                   TrafficStatsPair& Total) {\n    TrafficStatsMap Networks;\n\n    CUser* pUser = FindUser(sUsername);\n    if (pUser) {\n        for (const CIRCNetwork* pNetwork : pUser->GetNetworks()) {\n            Networks[pNetwork->GetName()].first = pNetwork->BytesRead();\n            Networks[pNetwork->GetName()].second = pNetwork->BytesWritten();\n            Total.first += pNetwork->BytesRead();\n            Total.second += pNetwork->BytesWritten();\n        }\n\n        for (Csock* pSock : m_Manager) {\n            CIRCNetwork* pNetwork = nullptr;\n            if (pSock->GetSockName().StartsWith(\"IRC::\")) {\n                pNetwork = ((CIRCSock*)pSock)->GetNetwork();\n            } else if (pSock->GetSockName().StartsWith(\"USR::\")) {\n                pNetwork = ((CClient*)pSock)->GetNetwork();\n            }\n\n            if (pNetwork && pNetwork->GetUser() == pUser) {\n                Networks[pNetwork->GetName()].first = pSock->GetBytesRead();\n                Networks[pNetwork->GetName()].second = pSock->GetBytesWritten();\n                Total.first += pSock->GetBytesRead();\n                Total.second += pSock->GetBytesWritten();\n            }\n        }\n    }\n\n    return Networks;\n}\n\nvoid CZNC::AuthUser(std::shared_ptr<CAuthBase> AuthClass) {\n    // TODO unless the auth module calls it, CUser::IsHostAllowed() is not\n    // honoured\n    bool bReturn = false;\n    GLOBALMODULECALL(OnLoginAttempt(AuthClass), &bReturn);\n    if (bReturn) return;\n\n    CUser* pUser = FindUser(AuthClass->GetUsername());\n\n    if (!pUser || !pUser->CheckPass(AuthClass->GetPassword())) {\n        AuthClass->RefuseLogin(\"Invalid Password\");\n        return;\n    }\n\n    CString sHost = AuthClass->GetRemoteIP();\n\n    if (!pUser->IsHostAllowed(sHost)) {\n        AuthClass->RefuseLogin(\"Your host [\" + sHost + \"] is not allowed\");\n        return;\n    }\n\n    AuthClass->AcceptLogin(*pUser);\n}\n\nclass CConnectQueueTimer : public CCron {\n  public:\n    CConnectQueueTimer(int iSecs) : CCron() {\n        SetName(\"Connect users\");\n        Start(iSecs);\n        // Don't wait iSecs seconds for first timer run\n        m_bRunOnNextCall = true;\n    }\n    ~CConnectQueueTimer() override {\n        // This is only needed when ZNC shuts down:\n        // CZNC::~CZNC() sets its CConnectQueueTimer pointer to nullptr and\n        // calls the manager's Cleanup() which destroys all sockets and\n        // timers. If something calls CZNC::EnableConnectQueue() here\n        // (e.g. because a CIRCSock is destroyed), the socket manager\n        // deletes that timer almost immediately, but CZNC now got a\n        // dangling pointer to this timer which can crash later on.\n        //\n        // Unlikely but possible ;)\n        CZNC::Get().LeakConnectQueueTimer(this);\n    }\n\n  protected:\n    void RunJob() override {\n        list<CIRCNetwork*> ConnectionQueue;\n        list<CIRCNetwork*>& RealConnectionQueue =\n            CZNC::Get().GetConnectionQueue();\n\n        // Problem: If a network can't connect right now because e.g. it\n        // is throttled, it will re-insert itself into the connection\n        // queue. However, we must only give each network a single\n        // chance during this timer run.\n        //\n        // Solution: We move the connection queue to our local list at\n        // the beginning and work from that.\n        ConnectionQueue.swap(RealConnectionQueue);\n\n        while (!ConnectionQueue.empty()) {\n            CIRCNetwork* pNetwork = ConnectionQueue.front();\n            ConnectionQueue.pop_front();\n\n            if (pNetwork->Connect()) {\n                break;\n            }\n        }\n\n        /* Now re-insert anything that is left in our local list into\n         * the real connection queue.\n         */\n        RealConnectionQueue.splice(RealConnectionQueue.begin(),\n                                   ConnectionQueue);\n\n        if (RealConnectionQueue.empty()) {\n            DEBUG(\"ConnectQueueTimer done\");\n            CZNC::Get().DisableConnectQueue();\n        }\n    }\n};\n\nvoid CZNC::SetConnectDelay(unsigned int i) {\n    if (i < 1) {\n        // Don't hammer server with our failed connects\n        i = 1;\n    }\n    if (m_uiConnectDelay != i && m_pConnectQueueTimer != nullptr) {\n        m_pConnectQueueTimer->Start(i);\n    }\n    m_uiConnectDelay = i;\n}\n\nVCString CZNC::GetAvailableSSLProtocols() {\n    // NOTE: keep in sync with SetSSLProtocols()\n    return {\"SSLv2\", \"SSLv3\", \"TLSv1\", \"TLSV1.1\", \"TLSv1.2\"};\n}\n\nbool CZNC::SetSSLProtocols(const CString& sProtocols) {\n    VCString vsProtocols;\n    sProtocols.Split(\" \", vsProtocols, false, \"\", \"\", true, true);\n\n    unsigned int uDisabledProtocols = Csock::EDP_SSL;\n    for (CString& sProtocol : vsProtocols) {\n        unsigned int uFlag = 0;\n        bool bEnable = sProtocol.TrimPrefix(\"+\");\n        bool bDisable = sProtocol.TrimPrefix(\"-\");\n\n        // NOTE: keep in sync with GetAvailableSSLProtocols()\n        if (sProtocol.Equals(\"All\")) {\n            uFlag = ~0;\n        } else if (sProtocol.Equals(\"SSLv2\")) {\n            uFlag = Csock::EDP_SSLv2;\n        } else if (sProtocol.Equals(\"SSLv3\")) {\n            uFlag = Csock::EDP_SSLv3;\n        } else if (sProtocol.Equals(\"TLSv1\")) {\n            uFlag = Csock::EDP_TLSv1;\n        } else if (sProtocol.Equals(\"TLSv1.1\")) {\n            uFlag = Csock::EDP_TLSv1_1;\n        } else if (sProtocol.Equals(\"TLSv1.2\")) {\n            uFlag = Csock::EDP_TLSv1_2;\n        } else {\n            return false;\n        }\n\n        if (bEnable) {\n            uDisabledProtocols &= ~uFlag;\n        } else if (bDisable) {\n            uDisabledProtocols |= uFlag;\n        } else {\n            uDisabledProtocols = ~uFlag;\n        }\n    }\n\n    m_sSSLProtocols = sProtocols;\n    m_uDisabledSSLProtocols = uDisabledProtocols;\n    return true;\n}\n\nvoid CZNC::EnableConnectQueue() {\n    if (!m_pConnectQueueTimer && !m_uiConnectPaused &&\n        !m_lpConnectQueue.empty()) {\n        m_pConnectQueueTimer = new CConnectQueueTimer(m_uiConnectDelay);\n        GetManager().AddCron(m_pConnectQueueTimer);\n    }\n}\n\nvoid CZNC::DisableConnectQueue() {\n    if (m_pConnectQueueTimer) {\n        // This will kill the cron\n        m_pConnectQueueTimer->Stop();\n        m_pConnectQueueTimer = nullptr;\n    }\n}\n\nvoid CZNC::PauseConnectQueue() {\n    DEBUG(\"Connection queue paused\");\n    m_uiConnectPaused++;\n\n    if (m_pConnectQueueTimer) {\n        m_pConnectQueueTimer->Pause();\n    }\n}\n\nvoid CZNC::ResumeConnectQueue() {\n    DEBUG(\"Connection queue resumed\");\n    m_uiConnectPaused--;\n\n    EnableConnectQueue();\n    if (m_pConnectQueueTimer) {\n        m_pConnectQueueTimer->UnPause();\n    }\n}\n\nvoid CZNC::ForceEncoding() {\n    m_uiForceEncoding++;\n#ifdef HAVE_ICU\n    for (Csock* pSock : GetManager()) {\n        if (pSock->GetEncoding().empty()) {\n            pSock->SetEncoding(\"UTF-8\");\n        }\n    }\n#endif\n}\nvoid CZNC::UnforceEncoding() { m_uiForceEncoding--; }\nbool CZNC::IsForcingEncoding() const { return m_uiForceEncoding; }\nCString CZNC::FixupEncoding(const CString& sEncoding) const {\n    if (sEncoding.empty() && m_uiForceEncoding) {\n        return \"UTF-8\";\n    }\n    return sEncoding;\n}\n\nvoid CZNC::AddNetworkToQueue(CIRCNetwork* pNetwork) {\n    // Make sure we are not already in the queue\n    if (std::find(m_lpConnectQueue.begin(), m_lpConnectQueue.end(), pNetwork) !=\n        m_lpConnectQueue.end()) {\n        return;\n    }\n\n    m_lpConnectQueue.push_back(pNetwork);\n    EnableConnectQueue();\n}\n\nvoid CZNC::LeakConnectQueueTimer(CConnectQueueTimer* pTimer) {\n    if (m_pConnectQueueTimer == pTimer) m_pConnectQueueTimer = nullptr;\n}\n\nbool CZNC::WaitForChildLock() { return m_pLockFile && m_pLockFile->ExLock(); }\n\nvoid CZNC::DisableConfigTimer() {\n    if (m_pConfigTimer) {\n        m_pConfigTimer->Stop();\n        m_pConfigTimer = nullptr;\n    }\n}\n", "/*\n * Copyright (C) 2004-2016 ZNC, see the NOTICE file for details.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"znctest.h\"\n\nnamespace znc_inttest {\nnamespace {\n\nTEST_F(ZNCTest, Modperl) {\n    if (QProcessEnvironment::systemEnvironment().value(\n            \"DISABLED_ZNC_PERL_PYTHON_TEST\") == \"1\") {\n        return;\n    }\n    auto znc = Run();\n    znc->CanLeak();\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    client.Write(\"znc loadmod modperl\");\n    client.Write(\"znc loadmod perleval\");\n    client.Write(\"PRIVMSG *perleval :2+2\");\n    client.ReadUntil(\":*perleval!znc@znc.in PRIVMSG nick :Result: 4\");\n    client.Write(\"PRIVMSG *perleval :$self->GetUser->GetUserName\");\n    client.ReadUntil(\"Result: user\");\n}\n\nTEST_F(ZNCTest, Modpython) {\n    if (QProcessEnvironment::systemEnvironment().value(\n            \"DISABLED_ZNC_PERL_PYTHON_TEST\") == \"1\") {\n        return;\n    }\n    auto znc = Run();\n    znc->CanLeak();\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    client.Write(\"znc loadmod modpython\");\n    client.Write(\"znc loadmod pyeval\");\n    client.Write(\"PRIVMSG *pyeval :2+2\");\n    client.ReadUntil(\":*pyeval!znc@znc.in PRIVMSG nick :4\");\n    client.Write(\"PRIVMSG *pyeval :module.GetUser().GetUserName()\");\n    client.ReadUntil(\"nick :'user'\");\n    ircd.Write(\":server 001 nick :Hello\");\n    ircd.Write(\":n!u@h PRIVMSG nick :Hi\\xF0, github issue #1229\");\n    // \"replacement character\"\n    client.ReadUntil(\"Hi\\xEF\\xBF\\xBD, github issue\");\n}\n\nTEST_F(ZNCTest, ModpythonSocket) {\n    if (QProcessEnvironment::systemEnvironment().value(\n            \"DISABLED_ZNC_PERL_PYTHON_TEST\") == \"1\") {\n        return;\n    }\n    auto znc = Run();\n    znc->CanLeak();\n\n    InstallModule(\"socktest.py\", R\"(\n        import znc\n\n        class acc(znc.Socket):\n            def OnReadData(self, data):\n                self.GetModule().PutModule('received {} bytes'.format(len(data)))\n                self.Close()\n\n        class lis(znc.Socket):\n            def OnAccepted(self, host, port):\n                sock = self.GetModule().CreateSocket(acc)\n                sock.DisableReadLine()\n                return sock\n\n        class socktest(znc.Module):\n            def OnLoad(self, args, ret):\n                listen = self.CreateSocket(lis)\n                self.port = listen.Listen()\n                return True\n\n            def OnModCommand(self, cmd):\n                sock = self.CreateSocket()\n                sock.Connect('127.0.0.1', self.port)\n                sock.WriteBytes(b'blah')\n    )\");\n\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    client.Write(\"znc loadmod modpython\");\n    client.Write(\"znc loadmod socktest\");\n    client.Write(\"PRIVMSG *socktest :foo\");\n    client.ReadUntil(\"received 4 bytes\");\n}\n\nTEST_F(ZNCTest, ModperlSocket) {\n    if (QProcessEnvironment::systemEnvironment().value(\n            \"DISABLED_ZNC_PERL_PYTHON_TEST\") == \"1\") {\n        return;\n    }\n    auto znc = Run();\n    znc->CanLeak();\n\n    InstallModule(\"socktest.pm\", R\"(\n        package socktest::acc;\n        use base 'ZNC::Socket';\n        sub OnReadData {\n            my ($self, $data, $len) = @_;\n            $self->GetModule->PutModule(\"received $len bytes\");\n            $self->Close;\n        }\n\n        package socktest::lis;\n        use base 'ZNC::Socket';\n        sub OnAccepted {\n            my $self = shift;\n            return $self->GetModule->CreateSocket('socktest::acc');\n        }\n\n        package socktest::conn;\n        use base 'ZNC::Socket';\n\n        package socktest;\n        use base 'ZNC::Module';\n        sub OnLoad {\n            my $self = shift;\n            my $listen = $self->CreateSocket('socktest::lis');\n            $self->{port} = $listen->Listen;\n            return 1;\n        }\n        sub OnModCommand {\n            my ($self, $cmd) = @_;\n            my $sock = $self->CreateSocket('socktest::conn');\n            $sock->Connect('127.0.0.1', $self->{port});\n            $sock->Write('blah');\n        }\n\n        1;\n    )\");\n\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    client.Write(\"znc loadmod modperl\");\n    client.Write(\"znc loadmod socktest\");\n    client.Write(\"PRIVMSG *socktest :foo\");\n    client.ReadUntil(\"received 4 bytes\");\n}\n\nTEST_F(ZNCTest, ModpythonVCString) {\n    if (QProcessEnvironment::systemEnvironment().value(\n            \"DISABLED_ZNC_PERL_PYTHON_TEST\") == \"1\") {\n        return;\n    }\n    auto znc = Run();\n    znc->CanLeak();\n\n    InstallModule(\"test.py\", R\"(\n        import znc\n\n        class test(znc.Module):\n            def OnUserRawMessage(self, msg):\n                self.PutModule(str(msg.GetParams()))\n                return znc.CONTINUE\n    )\");\n\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    client.Write(\"znc loadmod modpython\");\n    client.Write(\"znc loadmod test\");\n    client.Write(\"PRIVMSG *test :foo\");\n    client.ReadUntil(\"'*test', 'foo'\");\n}\n\nTEST_F(ZNCTest, ModperlVCString) {\n    if (QProcessEnvironment::systemEnvironment().value(\n            \"DISABLED_ZNC_PERL_PYTHON_TEST\") == \"1\") {\n        return;\n    }\n    auto znc = Run();\n    znc->CanLeak();\n\n    InstallModule(\"test.pm\", R\"(\n        package test;\n        use base 'ZNC::Module';\n        sub OnUserRawMessage {\n            my ($self, $msg) = @_;\n            my @params = $msg->GetParams;\n            $self->PutModule(\"@params\");\n            return $ZNC::CONTINUE;\n        }\n\n        1;\n    )\");\n\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    client.Write(\"znc loadmod modperl\");\n    client.Write(\"znc loadmod test\");\n    client.Write(\"PRIVMSG *test :foo\");\n    client.ReadUntil(\":*test foo\");\n}\n\nTEST_F(ZNCTest, ModperlNV) {\n    if (QProcessEnvironment::systemEnvironment().value(\n            \"DISABLED_ZNC_PERL_PYTHON_TEST\") == \"1\") {\n        return;\n    }\n    auto znc = Run();\n    znc->CanLeak();\n\n    InstallModule(\"test.pm\", R\"(\n        package test;\n        use base 'ZNC::Module';\n        sub OnLoad {\n            my $self = shift;\n            $self->SetNV('a', 'X');\n            $self->NV->{b} = 'Y';\n            my @k = keys %{$self->NV};\n            $self->PutModule(\"@k\");\n            return $ZNC::CONTINUE;\n        }\n\n        1;\n    )\");\n\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    client.Write(\"znc loadmod modperl\");\n    client.Write(\"znc loadmod test\");\n    client.ReadUntil(\":a b\");\n}\n\n}  // namespace\n}  // namespace znc_inttest\n"], "fixing_code": ["/*\n * Copyright (C) 2004-2018 ZNC, see the NOTICE file for details.\n * Copyright (C) 2008 by Stefan Rado\n * based on admin.cpp by Sebastian Ramacher\n * based on admin.cpp in crox branch\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <znc/User.h>\n#include <znc/IRCNetwork.h>\n#include <znc/Chan.h>\n#include <znc/IRCSock.h>\n\nusing std::map;\nusing std::vector;\n\ntemplate <std::size_t N>\nstruct array_size_helper {\n    char __place_holder[N];\n};\n\ntemplate <class T, std::size_t N>\nstatic array_size_helper<N> array_size(T (&)[N]) {\n    return array_size_helper<N>();\n}\n\n#define ARRAY_SIZE(array) sizeof(array_size((array)))\n\nclass CAdminMod : public CModule {\n    using CModule::PutModule;\n\n    struct Setting {\n        const char* name;\n        CString type;\n    };\n\n    void PrintVarsHelp(const CString& sFilter, const Setting vars[],\n                       unsigned int uSize, const CString& sDescription) {\n        CTable VarTable;\n        VarTable.AddColumn(t_s(\"Type\", \"helptable\"));\n        VarTable.AddColumn(t_s(\"Variables\", \"helptable\"));\n        std::map<CString, VCString> mvsTypedVariables;\n        for (unsigned int i = 0; i != uSize; ++i) {\n            CString sVar = CString(vars[i].name).AsLower();\n            if (sFilter.empty() || sVar.StartsWith(sFilter) ||\n                sVar.WildCmp(sFilter)) {\n                mvsTypedVariables[vars[i].type].emplace_back(vars[i].name);\n            }\n        }\n        for (const auto& i : mvsTypedVariables) {\n            VarTable.AddRow();\n            VarTable.SetCell(t_s(\"Type\", \"helptable\"), i.first);\n            VarTable.SetCell(\n                t_s(\"Variables\", \"helptable\"),\n                CString(\", \").Join(i.second.cbegin(), i.second.cend()));\n        }\n        if (!VarTable.empty()) {\n            PutModule(sDescription);\n            PutModule(VarTable);\n        }\n    }\n\n    void PrintHelp(const CString& sLine) {\n        HandleHelpCommand(sLine);\n\n        const CString str = t_s(\"String\");\n        const CString boolean = t_s(\"Boolean (true/false)\");\n        const CString integer = t_s(\"Integer\");\n        const CString number = t_s(\"Number\");\n\n        const CString sCmdFilter = sLine.Token(1, false);\n        const CString sVarFilter = sLine.Token(2, true).AsLower();\n\n        if (sCmdFilter.empty() || sCmdFilter.StartsWith(\"Set\") ||\n            sCmdFilter.StartsWith(\"Get\")) {\n            Setting vars[] = {\n                {\"Nick\", str},\n                {\"Altnick\", str},\n                {\"Ident\", str},\n                {\"RealName\", str},\n                {\"BindHost\", str},\n                {\"MultiClients\", boolean},\n                {\"DenyLoadMod\", boolean},\n                {\"DenySetBindHost\", boolean},\n                {\"DefaultChanModes\", str},\n                {\"QuitMsg\", str},\n                {\"ChanBufferSize\", integer},\n                {\"QueryBufferSize\", integer},\n                {\"AutoClearChanBuffer\", boolean},\n                {\"AutoClearQueryBuffer\", boolean},\n                {\"Password\", str},\n                {\"JoinTries\", integer},\n                {\"MaxJoins\", integer},\n                {\"MaxNetworks\", integer},\n                {\"MaxQueryBuffers\", integer},\n                {\"Timezone\", str},\n                {\"Admin\", boolean},\n                {\"AppendTimestamp\", boolean},\n                {\"PrependTimestamp\", boolean},\n                {\"AuthOnlyViaModule\", boolean},\n                {\"TimestampFormat\", str},\n                {\"DCCBindHost\", str},\n                {\"StatusPrefix\", str},\n#ifdef HAVE_I18N\n                {\"Language\", str},\n#endif\n#ifdef HAVE_ICU\n                {\"ClientEncoding\", str},\n#endif\n            };\n            PrintVarsHelp(sVarFilter, vars, ARRAY_SIZE(vars),\n                          t_s(\"The following variables are available when \"\n                              \"using the Set/Get commands:\"));\n        }\n\n        if (sCmdFilter.empty() || sCmdFilter.StartsWith(\"SetNetwork\") ||\n            sCmdFilter.StartsWith(\"GetNetwork\")) {\n            Setting nvars[] = {\n                {\"Nick\", str},\n                {\"Altnick\", str},\n                {\"Ident\", str},\n                {\"RealName\", str},\n                {\"BindHost\", str},\n                {\"FloodRate\", number},\n                {\"FloodBurst\", integer},\n                {\"JoinDelay\", integer},\n#ifdef HAVE_ICU\n                {\"Encoding\", str},\n#endif\n                {\"QuitMsg\", str},\n                {\"TrustAllCerts\", boolean},\n                {\"TrustPKI\", boolean},\n            };\n            PrintVarsHelp(sVarFilter, nvars, ARRAY_SIZE(nvars),\n                          t_s(\"The following variables are available when \"\n                              \"using the SetNetwork/GetNetwork commands:\"));\n        }\n\n        if (sCmdFilter.empty() || sCmdFilter.StartsWith(\"SetChan\") ||\n            sCmdFilter.StartsWith(\"GetChan\")) {\n            Setting cvars[] = {{\"DefModes\", str},\n                               {\"Key\", str},\n                               {\"BufferSize\", integer},\n                               {\"InConfig\", boolean},\n                               {\"AutoClearChanBuffer\", boolean},\n                               {\"Detached\", boolean}};\n            PrintVarsHelp(sVarFilter, cvars, ARRAY_SIZE(cvars),\n                          t_s(\"The following variables are available when \"\n                              \"using the SetChan/GetChan commands:\"));\n        }\n\n        if (sCmdFilter.empty())\n            PutModule(\n                t_s(\"You can use $user as the user name and $network as the \"\n                    \"network name for modifying your own user and network.\"));\n    }\n\n    CUser* FindUser(const CString& sUsername) {\n        if (sUsername.Equals(\"$me\") || sUsername.Equals(\"$user\"))\n            return GetUser();\n        CUser* pUser = CZNC::Get().FindUser(sUsername);\n        if (!pUser) {\n            PutModule(t_f(\"Error: User [{1}] does not exist!\")(sUsername));\n            return nullptr;\n        }\n        if (pUser != GetUser() && !GetUser()->IsAdmin()) {\n            PutModule(t_s(\n                \"Error: You need to have admin rights to modify other users!\"));\n            return nullptr;\n        }\n        return pUser;\n    }\n\n    CIRCNetwork* FindNetwork(CUser* pUser, const CString& sNetwork) {\n        if (sNetwork.Equals(\"$net\") || sNetwork.Equals(\"$network\")) {\n            if (pUser != GetUser()) {\n                PutModule(t_s(\n                    \"Error: You cannot use $network to modify other users!\"));\n                return nullptr;\n            }\n            return CModule::GetNetwork();\n        }\n        CIRCNetwork* pNetwork = pUser->FindNetwork(sNetwork);\n        if (!pNetwork) {\n            PutModule(\n                t_f(\"Error: User {1} does not have a network named [{2}].\")(\n                    pUser->GetUserName(), sNetwork));\n        }\n        return pNetwork;\n    }\n\n    void Get(const CString& sLine) {\n        const CString sVar = sLine.Token(1).AsLower();\n        CString sUsername = sLine.Token(2, true);\n        CUser* pUser;\n\n        if (sVar.empty()) {\n            PutModule(t_s(\"Usage: Get <variable> [username]\"));\n            return;\n        }\n\n        if (sUsername.empty()) {\n            pUser = GetUser();\n        } else {\n            pUser = FindUser(sUsername);\n        }\n\n        if (!pUser) return;\n\n        if (sVar == \"nick\")\n            PutModule(\"Nick = \" + pUser->GetNick());\n        else if (sVar == \"altnick\")\n            PutModule(\"AltNick = \" + pUser->GetAltNick());\n        else if (sVar == \"ident\")\n            PutModule(\"Ident = \" + pUser->GetIdent());\n        else if (sVar == \"realname\")\n            PutModule(\"RealName = \" + pUser->GetRealName());\n        else if (sVar == \"bindhost\")\n            PutModule(\"BindHost = \" + pUser->GetBindHost());\n        else if (sVar == \"multiclients\")\n            PutModule(\"MultiClients = \" + CString(pUser->MultiClients()));\n        else if (sVar == \"denyloadmod\")\n            PutModule(\"DenyLoadMod = \" + CString(pUser->DenyLoadMod()));\n        else if (sVar == \"denysetbindhost\")\n            PutModule(\"DenySetBindHost = \" + CString(pUser->DenySetBindHost()));\n        else if (sVar == \"defaultchanmodes\")\n            PutModule(\"DefaultChanModes = \" + pUser->GetDefaultChanModes());\n        else if (sVar == \"quitmsg\")\n            PutModule(\"QuitMsg = \" + pUser->GetQuitMsg());\n        else if (sVar == \"buffercount\")\n            PutModule(\"BufferCount = \" + CString(pUser->GetBufferCount()));\n        else if (sVar == \"chanbuffersize\")\n            PutModule(\"ChanBufferSize = \" +\n                      CString(pUser->GetChanBufferSize()));\n        else if (sVar == \"querybuffersize\")\n            PutModule(\"QueryBufferSize = \" +\n                      CString(pUser->GetQueryBufferSize()));\n        else if (sVar == \"keepbuffer\")\n            // XXX compatibility crap, added in 0.207\n            PutModule(\"KeepBuffer = \" + CString(!pUser->AutoClearChanBuffer()));\n        else if (sVar == \"autoclearchanbuffer\")\n            PutModule(\"AutoClearChanBuffer = \" +\n                      CString(pUser->AutoClearChanBuffer()));\n        else if (sVar == \"autoclearquerybuffer\")\n            PutModule(\"AutoClearQueryBuffer = \" +\n                      CString(pUser->AutoClearQueryBuffer()));\n        else if (sVar == \"maxjoins\")\n            PutModule(\"MaxJoins = \" + CString(pUser->MaxJoins()));\n        else if (sVar == \"notraffictimeout\")\n            PutModule(\"NoTrafficTimeout = \" +\n                      CString(pUser->GetNoTrafficTimeout()));\n        else if (sVar == \"maxnetworks\")\n            PutModule(\"MaxNetworks = \" + CString(pUser->MaxNetworks()));\n        else if (sVar == \"maxquerybuffers\")\n            PutModule(\"MaxQueryBuffers = \" + CString(pUser->MaxQueryBuffers()));\n        else if (sVar == \"jointries\")\n            PutModule(\"JoinTries = \" + CString(pUser->JoinTries()));\n        else if (sVar == \"timezone\")\n            PutModule(\"Timezone = \" + pUser->GetTimezone());\n        else if (sVar == \"appendtimestamp\")\n            PutModule(\"AppendTimestamp = \" +\n                      CString(pUser->GetTimestampAppend()));\n        else if (sVar == \"prependtimestamp\")\n            PutModule(\"PrependTimestamp = \" +\n                      CString(pUser->GetTimestampPrepend()));\n        else if (sVar == \"authonlyviamodule\")\n            PutModule(\"AuthOnlyViaModule = \" +\n                      CString(pUser->AuthOnlyViaModule()));\n        else if (sVar == \"timestampformat\")\n            PutModule(\"TimestampFormat = \" + pUser->GetTimestampFormat());\n        else if (sVar == \"dccbindhost\")\n            PutModule(\"DCCBindHost = \" + CString(pUser->GetDCCBindHost()));\n        else if (sVar == \"admin\")\n            PutModule(\"Admin = \" + CString(pUser->IsAdmin()));\n        else if (sVar == \"statusprefix\")\n            PutModule(\"StatusPrefix = \" + pUser->GetStatusPrefix());\n#ifdef HAVE_I18N\n        else if (sVar == \"language\")\n            PutModule(\"Language = \" + (pUser->GetLanguage().empty()\n                                           ? \"en\"\n                                           : pUser->GetLanguage()));\n#endif\n#ifdef HAVE_ICU\n        else if (sVar == \"clientencoding\")\n            PutModule(\"ClientEncoding = \" + pUser->GetClientEncoding());\n#endif\n        else\n            PutModule(t_s(\"Error: Unknown variable\"));\n    }\n\n    void Set(const CString& sLine) {\n        const CString sVar = sLine.Token(1).AsLower();\n        CString sUserName = sLine.Token(2);\n        CString sValue = sLine.Token(3, true);\n\n        if (sValue.empty()) {\n            PutModule(t_s(\"Usage: Set <variable> <username> <value>\"));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUserName);\n        if (!pUser) return;\n\n        if (sVar == \"nick\") {\n            pUser->SetNick(sValue);\n            PutModule(\"Nick = \" + sValue);\n        } else if (sVar == \"altnick\") {\n            pUser->SetAltNick(sValue);\n            PutModule(\"AltNick = \" + sValue);\n        } else if (sVar == \"ident\") {\n            pUser->SetIdent(sValue);\n            PutModule(\"Ident = \" + sValue);\n        } else if (sVar == \"realname\") {\n            pUser->SetRealName(sValue);\n            PutModule(\"RealName = \" + sValue);\n        } else if (sVar == \"bindhost\") {\n            if (!pUser->DenySetBindHost() || GetUser()->IsAdmin()) {\n                if (sValue.Equals(pUser->GetBindHost())) {\n                    PutModule(t_s(\"This bind host is already set!\"));\n                    return;\n                }\n\n                pUser->SetBindHost(sValue);\n                PutModule(\"BindHost = \" + sValue);\n            } else {\n                PutModule(t_s(\"Access denied!\"));\n            }\n        } else if (sVar == \"multiclients\") {\n            bool b = sValue.ToBool();\n            pUser->SetMultiClients(b);\n            PutModule(\"MultiClients = \" + CString(b));\n        } else if (sVar == \"denyloadmod\") {\n            if (GetUser()->IsAdmin()) {\n                bool b = sValue.ToBool();\n                pUser->SetDenyLoadMod(b);\n                PutModule(\"DenyLoadMod = \" + CString(b));\n            } else {\n                PutModule(t_s(\"Access denied!\"));\n            }\n        } else if (sVar == \"denysetbindhost\") {\n            if (GetUser()->IsAdmin()) {\n                bool b = sValue.ToBool();\n                pUser->SetDenySetBindHost(b);\n                PutModule(\"DenySetBindHost = \" + CString(b));\n            } else {\n                PutModule(t_s(\"Access denied!\"));\n            }\n        } else if (sVar == \"defaultchanmodes\") {\n            pUser->SetDefaultChanModes(sValue);\n            PutModule(\"DefaultChanModes = \" + sValue);\n        } else if (sVar == \"quitmsg\") {\n            pUser->SetQuitMsg(sValue);\n            PutModule(\"QuitMsg = \" + sValue);\n        } else if (sVar == \"chanbuffersize\" || sVar == \"buffercount\") {\n            unsigned int i = sValue.ToUInt();\n            // Admins don't have to honour the buffer limit\n            if (pUser->SetChanBufferSize(i, GetUser()->IsAdmin())) {\n                PutModule(\"ChanBufferSize = \" + sValue);\n            } else {\n                PutModule(t_f(\"Setting failed, limit for buffer size is {1}\")(\n                    CString(CZNC::Get().GetMaxBufferSize())));\n            }\n        } else if (sVar == \"querybuffersize\") {\n            unsigned int i = sValue.ToUInt();\n            // Admins don't have to honour the buffer limit\n            if (pUser->SetQueryBufferSize(i, GetUser()->IsAdmin())) {\n                PutModule(\"QueryBufferSize = \" + sValue);\n            } else {\n                PutModule(t_f(\"Setting failed, limit for buffer size is {1}\")(\n                    CString(CZNC::Get().GetMaxBufferSize())));\n            }\n        } else if (sVar == \"keepbuffer\") {\n            // XXX compatibility crap, added in 0.207\n            bool b = !sValue.ToBool();\n            pUser->SetAutoClearChanBuffer(b);\n            PutModule(\"AutoClearChanBuffer = \" + CString(b));\n        } else if (sVar == \"autoclearchanbuffer\") {\n            bool b = sValue.ToBool();\n            pUser->SetAutoClearChanBuffer(b);\n            PutModule(\"AutoClearChanBuffer = \" + CString(b));\n        } else if (sVar == \"autoclearquerybuffer\") {\n            bool b = sValue.ToBool();\n            pUser->SetAutoClearQueryBuffer(b);\n            PutModule(\"AutoClearQueryBuffer = \" + CString(b));\n        } else if (sVar == \"password\") {\n            const CString sSalt = CUtils::GetSalt();\n            const CString sHash = CUser::SaltedHash(sValue, sSalt);\n            pUser->SetPass(sHash, CUser::HASH_DEFAULT, sSalt);\n            PutModule(t_s(\"Password has been changed!\"));\n        } else if (sVar == \"maxjoins\") {\n            unsigned int i = sValue.ToUInt();\n            pUser->SetMaxJoins(i);\n            PutModule(\"MaxJoins = \" + CString(pUser->MaxJoins()));\n        } else if (sVar == \"notraffictimeout\") {\n            unsigned int i = sValue.ToUInt();\n            if (i < 30) {\n                PutModule(t_s(\"Timeout can't be less than 30 seconds!\"));\n            } else {\n                pUser->SetNoTrafficTimeout(i);\n                PutModule(\"NoTrafficTimeout = \" +\n                          CString(pUser->GetNoTrafficTimeout()));\n            }\n        } else if (sVar == \"maxnetworks\") {\n            if (GetUser()->IsAdmin()) {\n                unsigned int i = sValue.ToUInt();\n                pUser->SetMaxNetworks(i);\n                PutModule(\"MaxNetworks = \" + sValue);\n            } else {\n                PutModule(t_s(\"Access denied!\"));\n            }\n        } else if (sVar == \"maxquerybuffers\") {\n            unsigned int i = sValue.ToUInt();\n            pUser->SetMaxQueryBuffers(i);\n            PutModule(\"MaxQueryBuffers = \" + sValue);\n        } else if (sVar == \"jointries\") {\n            unsigned int i = sValue.ToUInt();\n            pUser->SetJoinTries(i);\n            PutModule(\"JoinTries = \" + CString(pUser->JoinTries()));\n        } else if (sVar == \"timezone\") {\n            pUser->SetTimezone(sValue);\n            PutModule(\"Timezone = \" + pUser->GetTimezone());\n        } else if (sVar == \"admin\") {\n            if (GetUser()->IsAdmin() && pUser != GetUser()) {\n                bool b = sValue.ToBool();\n                pUser->SetAdmin(b);\n                PutModule(\"Admin = \" + CString(pUser->IsAdmin()));\n            } else {\n                PutModule(t_s(\"Access denied!\"));\n            }\n        } else if (sVar == \"prependtimestamp\") {\n            bool b = sValue.ToBool();\n            pUser->SetTimestampPrepend(b);\n            PutModule(\"PrependTimestamp = \" + CString(b));\n        } else if (sVar == \"appendtimestamp\") {\n            bool b = sValue.ToBool();\n            pUser->SetTimestampAppend(b);\n            PutModule(\"AppendTimestamp = \" + CString(b));\n        } else if (sVar == \"authonlyviamodule\") {\n            if (GetUser()->IsAdmin()) {\n                bool b = sValue.ToBool();\n                pUser->SetAuthOnlyViaModule(b);\n                PutModule(\"AuthOnlyViaModule = \" + CString(b));\n            } else {\n                PutModule(t_s(\"Access denied!\"));\n            }\n        } else if (sVar == \"timestampformat\") {\n            pUser->SetTimestampFormat(sValue);\n            PutModule(\"TimestampFormat = \" + sValue);\n        } else if (sVar == \"dccbindhost\") {\n            if (!pUser->DenySetBindHost() || GetUser()->IsAdmin()) {\n                pUser->SetDCCBindHost(sValue);\n                PutModule(\"DCCBindHost = \" + sValue);\n            } else {\n                PutModule(t_s(\"Access denied!\"));\n            }\n        } else if (sVar == \"statusprefix\") {\n            if (sVar.find_first_of(\" \\t\\n\") == CString::npos) {\n                pUser->SetStatusPrefix(sValue);\n                PutModule(\"StatusPrefix = \" + sValue);\n            } else {\n                PutModule(t_s(\"That would be a bad idea!\"));\n            }\n        }\n#ifdef HAVE_I18N\n        else if (sVar == \"language\") {\n            auto mTranslations = CTranslationInfo::GetTranslations();\n            // TODO: maybe stop special-casing English\n            if (sValue == \"en\") {\n                pUser->SetLanguage(\"\");\n                PutModule(\"Language is set to English\");\n            } else if (mTranslations.count(sValue)) {\n                pUser->SetLanguage(sValue);\n                PutModule(\"Language = \" + sValue);\n            } else {\n                VCString vsCodes = {\"en\"};\n                for (const auto it : mTranslations) {\n                    vsCodes.push_back(it.first);\n                }\n                PutModule(t_f(\"Supported languages: {1}\")(\n                    CString(\", \").Join(vsCodes.begin(), vsCodes.end())));\n            }\n        }\n#endif\n#ifdef HAVE_ICU\n        else if (sVar == \"clientencoding\") {\n            pUser->SetClientEncoding(sValue);\n            PutModule(\"ClientEncoding = \" + pUser->GetClientEncoding());\n        }\n#endif\n        else\n            PutModule(t_s(\"Error: Unknown variable\"));\n    }\n\n    void GetNetwork(const CString& sLine) {\n        const CString sVar = sLine.Token(1).AsLower();\n        const CString sUsername = sLine.Token(2);\n        const CString sNetwork = sLine.Token(3);\n\n        CIRCNetwork* pNetwork = nullptr;\n        CUser* pUser;\n\n        if (sVar.empty()) {\n            PutModule(t_s(\"Usage: GetNetwork <variable> [username] [network]\"));\n            return;\n        }\n\n        if (sUsername.empty()) {\n            pUser = GetUser();\n        } else {\n            pUser = FindUser(sUsername);\n        }\n\n        if (!pUser) {\n            return;\n        }\n\n        if (sNetwork.empty()) {\n            if (pUser == GetUser()) {\n                pNetwork = CModule::GetNetwork();\n            } else {\n                PutModule(\n                    t_s(\"Error: A network must be specified to get another \"\n                        \"users settings.\"));\n                return;\n            }\n\n            if (!pNetwork) {\n                PutModule(t_s(\"You are not currently attached to a network.\"));\n                return;\n            }\n        } else {\n            pNetwork = FindNetwork(pUser, sNetwork);\n            if (!pNetwork) {\n                PutModule(t_s(\"Error: Invalid network.\"));\n                return;\n            }\n        }\n\n        if (sVar.Equals(\"nick\")) {\n            PutModule(\"Nick = \" + pNetwork->GetNick());\n        } else if (sVar.Equals(\"altnick\")) {\n            PutModule(\"AltNick = \" + pNetwork->GetAltNick());\n        } else if (sVar.Equals(\"ident\")) {\n            PutModule(\"Ident = \" + pNetwork->GetIdent());\n        } else if (sVar.Equals(\"realname\")) {\n            PutModule(\"RealName = \" + pNetwork->GetRealName());\n        } else if (sVar.Equals(\"bindhost\")) {\n            PutModule(\"BindHost = \" + pNetwork->GetBindHost());\n        } else if (sVar.Equals(\"floodrate\")) {\n            PutModule(\"FloodRate = \" + CString(pNetwork->GetFloodRate()));\n        } else if (sVar.Equals(\"floodburst\")) {\n            PutModule(\"FloodBurst = \" + CString(pNetwork->GetFloodBurst()));\n        } else if (sVar.Equals(\"joindelay\")) {\n            PutModule(\"JoinDelay = \" + CString(pNetwork->GetJoinDelay()));\n#ifdef HAVE_ICU\n        } else if (sVar.Equals(\"encoding\")) {\n            PutModule(\"Encoding = \" + pNetwork->GetEncoding());\n#endif\n        } else if (sVar.Equals(\"quitmsg\")) {\n            PutModule(\"QuitMsg = \" + pNetwork->GetQuitMsg());\n        } else if (sVar.Equals(\"trustallcerts\")) {\n            PutModule(\"TrustAllCerts = \" + CString(pNetwork->GetTrustAllCerts()));\n        } else if (sVar.Equals(\"trustpki\")) {\n            PutModule(\"TrustPKI = \" + CString(pNetwork->GetTrustPKI()));\n        } else {\n            PutModule(t_s(\"Error: Unknown variable\"));\n        }\n    }\n\n    void SetNetwork(const CString& sLine) {\n        const CString sVar = sLine.Token(1).AsLower();\n        const CString sUsername = sLine.Token(2);\n        const CString sNetwork = sLine.Token(3);\n        const CString sValue = sLine.Token(4, true);\n\n        if (sValue.empty()) {\n            PutModule(t_s(\n                \"Usage: SetNetwork <variable> <username> <network> <value>\"));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUsername);\n        if (!pUser) {\n            return;\n        }\n\n        CIRCNetwork* pNetwork = FindNetwork(pUser, sNetwork);\n        if (!pNetwork) {\n            return;\n        }\n\n        if (sVar.Equals(\"nick\")) {\n            pNetwork->SetNick(sValue);\n            PutModule(\"Nick = \" + pNetwork->GetNick());\n        } else if (sVar.Equals(\"altnick\")) {\n            pNetwork->SetAltNick(sValue);\n            PutModule(\"AltNick = \" + pNetwork->GetAltNick());\n        } else if (sVar.Equals(\"ident\")) {\n            pNetwork->SetIdent(sValue);\n            PutModule(\"Ident = \" + pNetwork->GetIdent());\n        } else if (sVar.Equals(\"realname\")) {\n            pNetwork->SetRealName(sValue);\n            PutModule(\"RealName = \" + pNetwork->GetRealName());\n        } else if (sVar.Equals(\"bindhost\")) {\n            if (!pUser->DenySetBindHost() || GetUser()->IsAdmin()) {\n                if (sValue.Equals(pNetwork->GetBindHost())) {\n                    PutModule(t_s(\"This bind host is already set!\"));\n                    return;\n                }\n\n                pNetwork->SetBindHost(sValue);\n                PutModule(\"BindHost = \" + sValue);\n            } else {\n                PutModule(t_s(\"Access denied!\"));\n            }\n        } else if (sVar.Equals(\"floodrate\")) {\n            pNetwork->SetFloodRate(sValue.ToDouble());\n            PutModule(\"FloodRate = \" + CString(pNetwork->GetFloodRate()));\n        } else if (sVar.Equals(\"floodburst\")) {\n            pNetwork->SetFloodBurst(sValue.ToUShort());\n            PutModule(\"FloodBurst = \" + CString(pNetwork->GetFloodBurst()));\n        } else if (sVar.Equals(\"joindelay\")) {\n            pNetwork->SetJoinDelay(sValue.ToUShort());\n            PutModule(\"JoinDelay = \" + CString(pNetwork->GetJoinDelay()));\n#ifdef HAVE_ICU\n        } else if (sVar.Equals(\"encoding\")) {\n            pNetwork->SetEncoding(sValue);\n            PutModule(\"Encoding = \" + pNetwork->GetEncoding());\n#endif\n        } else if (sVar.Equals(\"quitmsg\")) {\n            pNetwork->SetQuitMsg(sValue);\n            PutModule(\"QuitMsg = \" + pNetwork->GetQuitMsg());\n        } else if (sVar.Equals(\"trustallcerts\")) {\n            bool b = sValue.ToBool();\n            pNetwork->SetTrustAllCerts(b);\n            PutModule(\"TrustAllCerts = \" + CString(b));\n        } else if (sVar.Equals(\"trustpki\")) {\n            bool b = sValue.ToBool();\n            pNetwork->SetTrustPKI(b);\n            PutModule(\"TrustPKI = \" + CString(b));\n        } else {\n            PutModule(t_s(\"Error: Unknown variable\"));\n        }\n    }\n\n    void AddChan(const CString& sLine) {\n        const CString sUsername = sLine.Token(1);\n        const CString sNetwork = sLine.Token(2);\n        const CString sChan = sLine.Token(3);\n\n        if (sChan.empty()) {\n            PutModule(t_s(\"Usage: AddChan <username> <network> <channel>\"));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUsername);\n        if (!pUser) return;\n\n        CIRCNetwork* pNetwork = FindNetwork(pUser, sNetwork);\n        if (!pNetwork) {\n            return;\n        }\n\n        if (pNetwork->FindChan(sChan)) {\n            PutModule(t_f(\"Error: User {1} already has a channel named {2}.\")(\n                sUsername, sChan));\n            return;\n        }\n\n        CChan* pChan = new CChan(sChan, pNetwork, true);\n        if (pNetwork->AddChan(pChan))\n            PutModule(t_f(\"Channel {1} for user {2} added to network {3}.\")(\n                pChan->GetName(), sUsername, pNetwork->GetName()));\n        else\n            PutModule(t_f(\n                \"Could not add channel {1} for user {2} to network {3}, does \"\n                \"it already exist?\")(sChan, sUsername, pNetwork->GetName()));\n    }\n\n    void DelChan(const CString& sLine) {\n        const CString sUsername = sLine.Token(1);\n        const CString sNetwork = sLine.Token(2);\n        const CString sChan = sLine.Token(3);\n\n        if (sChan.empty()) {\n            PutModule(t_s(\"Usage: DelChan <username> <network> <channel>\"));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUsername);\n        if (!pUser) return;\n\n        CIRCNetwork* pNetwork = FindNetwork(pUser, sNetwork);\n        if (!pNetwork) {\n            return;\n        }\n\n        std::vector<CChan*> vChans = pNetwork->FindChans(sChan);\n        if (vChans.empty()) {\n            PutModule(\n                t_f(\"Error: User {1} does not have any channel matching [{2}] \"\n                    \"in network {3}\")(sUsername, sChan, pNetwork->GetName()));\n            return;\n        }\n\n        VCString vsNames;\n        for (const CChan* pChan : vChans) {\n            const CString& sName = pChan->GetName();\n            vsNames.push_back(sName);\n            pNetwork->PutIRC(\"PART \" + sName);\n            pNetwork->DelChan(sName);\n        }\n\n        PutModule(t_p(\"Channel {1} is deleted from network {2} of user {3}\",\n                      \"Channels {1} are deleted from network {2} of user {3}\",\n                      vsNames.size())(\n            CString(\", \").Join(vsNames.begin(), vsNames.end()),\n            pNetwork->GetName(), sUsername));\n    }\n\n    void GetChan(const CString& sLine) {\n        const CString sVar = sLine.Token(1).AsLower();\n        CString sUsername = sLine.Token(2);\n        CString sNetwork = sLine.Token(3);\n        CString sChan = sLine.Token(4, true);\n\n        if (sChan.empty()) {\n            PutModule(\n                t_s(\"Usage: GetChan <variable> <username> <network> <chan>\"));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUsername);\n        if (!pUser) return;\n\n        CIRCNetwork* pNetwork = FindNetwork(pUser, sNetwork);\n        if (!pNetwork) {\n            return;\n        }\n\n        std::vector<CChan*> vChans = pNetwork->FindChans(sChan);\n        if (vChans.empty()) {\n            PutModule(t_f(\"Error: No channels matching [{1}] found.\")(sChan));\n            return;\n        }\n\n        for (CChan* pChan : vChans) {\n            if (sVar == \"defmodes\") {\n                PutModule(pChan->GetName() + \": DefModes = \" +\n                          pChan->GetDefaultModes());\n            } else if (sVar == \"buffersize\" || sVar == \"buffer\") {\n                CString sValue(pChan->GetBufferCount());\n                if (!pChan->HasBufferCountSet()) {\n                    sValue += \" (default)\";\n                }\n                PutModule(pChan->GetName() + \": BufferSize = \" + sValue);\n            } else if (sVar == \"inconfig\") {\n                PutModule(pChan->GetName() + \": InConfig = \" +\n                          CString(pChan->InConfig()));\n            } else if (sVar == \"keepbuffer\") {\n                // XXX compatibility crap, added in 0.207\n                PutModule(pChan->GetName() + \": KeepBuffer = \" +\n                          CString(!pChan->AutoClearChanBuffer()));\n            } else if (sVar == \"autoclearchanbuffer\") {\n                CString sValue(pChan->AutoClearChanBuffer());\n                if (!pChan->HasAutoClearChanBufferSet()) {\n                    sValue += \" (default)\";\n                }\n                PutModule(pChan->GetName() + \": AutoClearChanBuffer = \" +\n                          sValue);\n            } else if (sVar == \"detached\") {\n                PutModule(pChan->GetName() + \": Detached = \" +\n                          CString(pChan->IsDetached()));\n            } else if (sVar == \"key\") {\n                PutModule(pChan->GetName() + \": Key = \" + pChan->GetKey());\n            } else {\n                PutModule(t_s(\"Error: Unknown variable\"));\n                return;\n            }\n        }\n    }\n\n    void SetChan(const CString& sLine) {\n        const CString sVar = sLine.Token(1).AsLower();\n        CString sUsername = sLine.Token(2);\n        CString sNetwork = sLine.Token(3);\n        CString sChan = sLine.Token(4);\n        CString sValue = sLine.Token(5, true);\n\n        if (sValue.empty()) {\n            PutModule(\n                t_s(\"Usage: SetChan <variable> <username> <network> <chan> \"\n                    \"<value>\"));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUsername);\n        if (!pUser) return;\n\n        CIRCNetwork* pNetwork = FindNetwork(pUser, sNetwork);\n        if (!pNetwork) {\n            return;\n        }\n\n        std::vector<CChan*> vChans = pNetwork->FindChans(sChan);\n        if (vChans.empty()) {\n            PutModule(t_f(\"Error: No channels matching [{1}] found.\")(sChan));\n            return;\n        }\n\n        for (CChan* pChan : vChans) {\n            if (sVar == \"defmodes\") {\n                pChan->SetDefaultModes(sValue);\n                PutModule(pChan->GetName() + \": DefModes = \" + sValue);\n            } else if (sVar == \"buffersize\" || sVar == \"buffer\") {\n                unsigned int i = sValue.ToUInt();\n                if (sValue.Equals(\"-\")) {\n                    pChan->ResetBufferCount();\n                    PutModule(pChan->GetName() + \": BufferSize = \" +\n                              CString(pChan->GetBufferCount()));\n                } else if (pChan->SetBufferCount(i, GetUser()->IsAdmin())) {\n                    // Admins don't have to honour the buffer limit\n                    PutModule(pChan->GetName() + \": BufferSize = \" + sValue);\n                } else {\n                    PutModule(\n                        t_f(\"Setting failed, limit for buffer size is {1}\")(\n                            CString(CZNC::Get().GetMaxBufferSize())));\n                    return;\n                }\n            } else if (sVar == \"inconfig\") {\n                bool b = sValue.ToBool();\n                pChan->SetInConfig(b);\n                PutModule(pChan->GetName() + \": InConfig = \" + CString(b));\n            } else if (sVar == \"keepbuffer\") {\n                // XXX compatibility crap, added in 0.207\n                bool b = !sValue.ToBool();\n                pChan->SetAutoClearChanBuffer(b);\n                PutModule(pChan->GetName() + \": AutoClearChanBuffer = \" +\n                          CString(b));\n            } else if (sVar == \"autoclearchanbuffer\") {\n                if (sValue.Equals(\"-\")) {\n                    pChan->ResetAutoClearChanBuffer();\n                } else {\n                    bool b = sValue.ToBool();\n                    pChan->SetAutoClearChanBuffer(b);\n                }\n                PutModule(pChan->GetName() + \": AutoClearChanBuffer = \" +\n                          CString(pChan->AutoClearChanBuffer()));\n            } else if (sVar == \"detached\") {\n                bool b = sValue.ToBool();\n                if (pChan->IsDetached() != b) {\n                    if (b)\n                        pChan->DetachUser();\n                    else\n                        pChan->AttachUser();\n                }\n                PutModule(pChan->GetName() + \": Detached = \" + CString(b));\n            } else if (sVar == \"key\") {\n                pChan->SetKey(sValue);\n                PutModule(pChan->GetName() + \": Key = \" + sValue);\n            } else {\n                PutModule(t_s(\"Error: Unknown variable\"));\n                return;\n            }\n        }\n    }\n\n    void ListUsers(const CString&) {\n        if (!GetUser()->IsAdmin()) return;\n\n        const map<CString, CUser*>& msUsers = CZNC::Get().GetUserMap();\n        CTable Table;\n        Table.AddColumn(t_s(\"Username\", \"listusers\"));\n        Table.AddColumn(t_s(\"Realname\", \"listusers\"));\n        Table.AddColumn(t_s(\"IsAdmin\", \"listusers\"));\n        Table.AddColumn(t_s(\"Nick\", \"listusers\"));\n        Table.AddColumn(t_s(\"AltNick\", \"listusers\"));\n        Table.AddColumn(t_s(\"Ident\", \"listusers\"));\n        Table.AddColumn(t_s(\"BindHost\", \"listusers\"));\n\n        for (const auto& it : msUsers) {\n            Table.AddRow();\n            Table.SetCell(t_s(\"Username\", \"listusers\"), it.first);\n            Table.SetCell(t_s(\"Realname\", \"listusers\"),\n                          it.second->GetRealName());\n            if (!it.second->IsAdmin())\n                Table.SetCell(t_s(\"IsAdmin\", \"listusers\"), t_s(\"No\"));\n            else\n                Table.SetCell(t_s(\"IsAdmin\", \"listusers\"), t_s(\"Yes\"));\n            Table.SetCell(t_s(\"Nick\", \"listusers\"), it.second->GetNick());\n            Table.SetCell(t_s(\"AltNick\", \"listusers\"), it.second->GetAltNick());\n            Table.SetCell(t_s(\"Ident\", \"listusers\"), it.second->GetIdent());\n            Table.SetCell(t_s(\"BindHost\", \"listusers\"),\n                          it.second->GetBindHost());\n        }\n\n        PutModule(Table);\n    }\n\n    void AddUser(const CString& sLine) {\n        if (!GetUser()->IsAdmin()) {\n            PutModule(\n                t_s(\"Error: You need to have admin rights to add new users!\"));\n            return;\n        }\n\n        const CString sUsername = sLine.Token(1), sPassword = sLine.Token(2);\n        if (sPassword.empty()) {\n            PutModule(t_s(\"Usage: AddUser <username> <password>\"));\n            return;\n        }\n\n        if (CZNC::Get().FindUser(sUsername)) {\n            PutModule(t_f(\"Error: User {1} already exists!\")(sUsername));\n            return;\n        }\n\n        CUser* pNewUser = new CUser(sUsername);\n        CString sSalt = CUtils::GetSalt();\n        pNewUser->SetPass(CUser::SaltedHash(sPassword, sSalt),\n                          CUser::HASH_DEFAULT, sSalt);\n\n        CString sErr;\n        if (!CZNC::Get().AddUser(pNewUser, sErr)) {\n            delete pNewUser;\n            PutModule(t_f(\"Error: User not added: {1}\")(sErr));\n            return;\n        }\n\n        PutModule(t_f(\"User {1} added!\")(sUsername));\n        return;\n    }\n\n    void DelUser(const CString& sLine) {\n        if (!GetUser()->IsAdmin()) {\n            PutModule(\n                t_s(\"Error: You need to have admin rights to delete users!\"));\n            return;\n        }\n\n        const CString sUsername = sLine.Token(1, true);\n        if (sUsername.empty()) {\n            PutModule(t_s(\"Usage: DelUser <username>\"));\n            return;\n        }\n\n        CUser* pUser = CZNC::Get().FindUser(sUsername);\n\n        if (!pUser) {\n            PutModule(t_f(\"Error: User [{1}] does not exist!\")(sUsername));\n            return;\n        }\n\n        if (pUser == GetUser()) {\n            PutModule(t_s(\"Error: You can't delete yourself!\"));\n            return;\n        }\n\n        if (!CZNC::Get().DeleteUser(pUser->GetUserName())) {\n            // This can't happen, because we got the user from FindUser()\n            PutModule(t_s(\"Error: Internal error!\"));\n            return;\n        }\n\n        PutModule(t_f(\"User {1} deleted!\")(sUsername));\n        return;\n    }\n\n    void CloneUser(const CString& sLine) {\n        if (!GetUser()->IsAdmin()) {\n            PutModule(\n                t_s(\"Error: You need to have admin rights to add new users!\"));\n            return;\n        }\n\n        const CString sOldUsername = sLine.Token(1),\n                      sNewUsername = sLine.Token(2, true);\n\n        if (sOldUsername.empty() || sNewUsername.empty()) {\n            PutModule(t_s(\"Usage: CloneUser <old username> <new username>\"));\n            return;\n        }\n\n        CUser* pOldUser = CZNC::Get().FindUser(sOldUsername);\n\n        if (!pOldUser) {\n            PutModule(t_f(\"Error: User [{1}] does not exist!\")(sOldUsername));\n            return;\n        }\n\n        CUser* pNewUser = new CUser(sNewUsername);\n        CString sError;\n        if (!pNewUser->Clone(*pOldUser, sError)) {\n            delete pNewUser;\n            PutModule(t_f(\"Error: Cloning failed: {1}\")(sError));\n            return;\n        }\n\n        if (!CZNC::Get().AddUser(pNewUser, sError)) {\n            delete pNewUser;\n            PutModule(t_f(\"Error: User not added: {1}\")(sError));\n            return;\n        }\n\n        PutModule(t_f(\"User {1} added!\")(sNewUsername));\n        return;\n    }\n\n    void AddNetwork(const CString& sLine) {\n        CString sUser = sLine.Token(1);\n        CString sNetwork = sLine.Token(2);\n        CUser* pUser = GetUser();\n\n        if (sNetwork.empty()) {\n            sNetwork = sUser;\n        } else {\n            pUser = FindUser(sUser);\n            if (!pUser) {\n                return;\n            }\n        }\n\n        if (sNetwork.empty()) {\n            PutModule(t_s(\"Usage: AddNetwork [user] network\"));\n            return;\n        }\n\n        if (!GetUser()->IsAdmin() && !pUser->HasSpaceForNewNetwork()) {\n            PutStatus(\n                t_s(\"Network number limit reached. Ask an admin to increase \"\n                    \"the limit for you, or delete unneeded networks using /znc \"\n                    \"DelNetwork <name>\"));\n            return;\n        }\n\n        if (pUser->FindNetwork(sNetwork)) {\n            PutModule(\n                t_f(\"Error: User {1} already has a network with the name {2}\")(\n                    pUser->GetUserName(), sNetwork));\n            return;\n        }\n\n        CString sNetworkAddError;\n        if (pUser->AddNetwork(sNetwork, sNetworkAddError)) {\n            PutModule(t_f(\"Network {1} added to user {2}.\")(\n                sNetwork, pUser->GetUserName()));\n        } else {\n            PutModule(t_f(\n                \"Error: Network [{1}] could not be added for user {2}: {3}\")(\n                sNetwork, pUser->GetUserName(), sNetworkAddError));\n        }\n    }\n\n    void DelNetwork(const CString& sLine) {\n        CString sUser = sLine.Token(1);\n        CString sNetwork = sLine.Token(2);\n        CUser* pUser = GetUser();\n\n        if (sNetwork.empty()) {\n            sNetwork = sUser;\n        } else {\n            pUser = FindUser(sUser);\n            if (!pUser) {\n                return;\n            }\n        }\n\n        if (sNetwork.empty()) {\n            PutModule(t_s(\"Usage: DelNetwork [user] network\"));\n            return;\n        }\n\n        CIRCNetwork* pNetwork = FindNetwork(pUser, sNetwork);\n        if (!pNetwork) {\n            return;\n        }\n\n        if (pNetwork == CModule::GetNetwork()) {\n            PutModule(t_f(\n                \"The currently active network can be deleted via {1}status\")(\n                GetUser()->GetStatusPrefix()));\n            return;\n        }\n\n        if (pUser->DeleteNetwork(sNetwork)) {\n            PutModule(t_f(\"Network {1} deleted for user {2}.\")(\n                sNetwork, pUser->GetUserName()));\n        } else {\n            PutModule(\n                t_f(\"Error: Network {1} could not be deleted for user {2}.\")(\n                    sNetwork, pUser->GetUserName()));\n        }\n    }\n\n    void ListNetworks(const CString& sLine) {\n        CString sUser = sLine.Token(1);\n        CUser* pUser = GetUser();\n\n        if (!sUser.empty()) {\n            pUser = FindUser(sUser);\n            if (!pUser) {\n                return;\n            }\n        }\n\n        const vector<CIRCNetwork*>& vNetworks = pUser->GetNetworks();\n\n        CTable Table;\n        Table.AddColumn(t_s(\"Network\", \"listnetworks\"));\n        Table.AddColumn(t_s(\"OnIRC\", \"listnetworks\"));\n        Table.AddColumn(t_s(\"IRC Server\", \"listnetworks\"));\n        Table.AddColumn(t_s(\"IRC User\", \"listnetworks\"));\n        Table.AddColumn(t_s(\"Channels\", \"listnetworks\"));\n\n        for (const CIRCNetwork* pNetwork : vNetworks) {\n            Table.AddRow();\n            Table.SetCell(t_s(\"Network\", \"listnetworks\"), pNetwork->GetName());\n            if (pNetwork->IsIRCConnected()) {\n                Table.SetCell(t_s(\"OnIRC\", \"listnetworks\"), t_s(\"Yes\"));\n                Table.SetCell(t_s(\"IRC Server\", \"listnetworks\"),\n                              pNetwork->GetIRCServer());\n                Table.SetCell(t_s(\"IRC User\", \"listnetworks\"),\n                              pNetwork->GetIRCNick().GetNickMask());\n                Table.SetCell(t_s(\"Channels\", \"listnetworks\"),\n                              CString(pNetwork->GetChans().size()));\n            } else {\n                Table.SetCell(t_s(\"OnIRC\", \"listnetworks\"), t_s(\"No\"));\n            }\n        }\n\n        if (PutModule(Table) == 0) {\n            PutModule(t_s(\"No networks\"));\n        }\n    }\n\n    void AddServer(const CString& sLine) {\n        CString sUsername = sLine.Token(1);\n        CString sNetwork = sLine.Token(2);\n        CString sServer = sLine.Token(3, true);\n\n        if (sServer.empty()) {\n            PutModule(\n                t_s(\"Usage: AddServer <username> <network> <server> [[+]port] \"\n                    \"[password]\"));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUsername);\n        if (!pUser) return;\n\n        CIRCNetwork* pNetwork = FindNetwork(pUser, sNetwork);\n        if (!pNetwork) {\n            return;\n        }\n\n        if (pNetwork->AddServer(sServer))\n            PutModule(t_f(\"Added IRC Server {1} to network {2} for user {3}.\")(\n                sServer, pNetwork->GetName(), pUser->GetUserName()));\n        else\n            PutModule(t_f(\n                \"Error: Could not add IRC server {1} to network {2} for user \"\n                \"{3}.\")(sServer, pNetwork->GetName(), pUser->GetUserName()));\n    }\n\n    void DelServer(const CString& sLine) {\n        CString sUsername = sLine.Token(1);\n        CString sNetwork = sLine.Token(2);\n        CString sServer = sLine.Token(3, true);\n        unsigned short uPort = sLine.Token(4).ToUShort();\n        CString sPass = sLine.Token(5);\n\n        if (sServer.empty()) {\n            PutModule(\n                t_s(\"Usage: DelServer <username> <network> <server> [[+]port] \"\n                    \"[password]\"));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUsername);\n        if (!pUser) return;\n\n        CIRCNetwork* pNetwork = FindNetwork(pUser, sNetwork);\n        if (!pNetwork) {\n            return;\n        }\n\n        if (pNetwork->DelServer(sServer, uPort, sPass))\n            PutModule(\n                t_f(\"Deleted IRC Server {1} from network {2} for user {3}.\")(\n                    sServer, pNetwork->GetName(), pUser->GetUserName()));\n        else\n            PutModule(\n                t_f(\"Error: Could not delete IRC server {1} from network {2} \"\n                    \"for user {3}.\")(sServer, pNetwork->GetName(),\n                                     pUser->GetUserName()));\n    }\n\n    void ReconnectUser(const CString& sLine) {\n        CString sUserName = sLine.Token(1);\n        CString sNetwork = sLine.Token(2);\n\n        if (sNetwork.empty()) {\n            PutModule(t_s(\"Usage: Reconnect <username> <network>\"));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUserName);\n        if (!pUser) {\n            return;\n        }\n\n        CIRCNetwork* pNetwork = FindNetwork(pUser, sNetwork);\n        if (!pNetwork) {\n            return;\n        }\n\n        CIRCSock* pIRCSock = pNetwork->GetIRCSock();\n        // cancel connection attempt:\n        if (pIRCSock && !pIRCSock->IsConnected()) {\n            pIRCSock->Close();\n        }\n        // or close existing connection:\n        else if (pIRCSock) {\n            pIRCSock->Quit();\n        }\n\n        // then reconnect\n        pNetwork->SetIRCConnectEnabled(true);\n\n        PutModule(t_f(\"Queued network {1} of user {2} for a reconnect.\")(\n            pNetwork->GetName(), pUser->GetUserName()));\n    }\n\n    void DisconnectUser(const CString& sLine) {\n        CString sUserName = sLine.Token(1);\n        CString sNetwork = sLine.Token(2);\n\n        if (sNetwork.empty()) {\n            PutModule(t_s(\"Usage: Disconnect <username> <network>\"));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUserName);\n        if (!pUser) {\n            return;\n        }\n\n        CIRCNetwork* pNetwork = FindNetwork(pUser, sNetwork);\n        if (!pNetwork) {\n            return;\n        }\n\n        pNetwork->SetIRCConnectEnabled(false);\n        PutModule(t_f(\"Closed IRC connection for network {1} of user {2}.\")(\n            pNetwork->GetName(), pUser->GetUserName()));\n    }\n\n    void ListCTCP(const CString& sLine) {\n        CString sUserName = sLine.Token(1, true);\n\n        if (sUserName.empty()) {\n            sUserName = GetUser()->GetUserName();\n        }\n        CUser* pUser = FindUser(sUserName);\n        if (!pUser) return;\n\n        const MCString& msCTCPReplies = pUser->GetCTCPReplies();\n        CTable Table;\n        Table.AddColumn(t_s(\"Request\", \"listctcp\"));\n        Table.AddColumn(t_s(\"Reply\", \"listctcp\"));\n        for (const auto& it : msCTCPReplies) {\n            Table.AddRow();\n            Table.SetCell(t_s(\"Request\", \"listctcp\"), it.first);\n            Table.SetCell(t_s(\"Reply\", \"listctcp\"), it.second);\n        }\n\n        if (Table.empty()) {\n            PutModule(t_f(\"No CTCP replies for user {1} are configured\")(\n                pUser->GetUserName()));\n        } else {\n            PutModule(t_f(\"CTCP replies for user {1}:\")(pUser->GetUserName()));\n            PutModule(Table);\n        }\n    }\n\n    void AddCTCP(const CString& sLine) {\n        CString sUserName = sLine.Token(1);\n        CString sCTCPRequest = sLine.Token(2);\n        CString sCTCPReply = sLine.Token(3, true);\n\n        if (sCTCPRequest.empty()) {\n            sCTCPRequest = sUserName;\n            sCTCPReply = sLine.Token(2, true);\n            sUserName = GetUser()->GetUserName();\n        }\n        if (sCTCPRequest.empty()) {\n            PutModule(t_s(\"Usage: AddCTCP [user] [request] [reply]\"));\n            PutModule(\n                t_s(\"This will cause ZNC to reply to the CTCP instead of \"\n                    \"forwarding it to clients.\"));\n            PutModule(t_s(\n                \"An empty reply will cause the CTCP request to be blocked.\"));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUserName);\n        if (!pUser) return;\n\n        pUser->AddCTCPReply(sCTCPRequest, sCTCPReply);\n        if (sCTCPReply.empty()) {\n            PutModule(t_f(\"CTCP requests {1} to user {2} will now be blocked.\")(\n                sCTCPRequest.AsUpper(), pUser->GetUserName()));\n        } else {\n            PutModule(\n                t_f(\"CTCP requests {1} to user {2} will now get reply: {3}\")(\n                    sCTCPRequest.AsUpper(), pUser->GetUserName(), sCTCPReply));\n        }\n    }\n\n    void DelCTCP(const CString& sLine) {\n        CString sUserName = sLine.Token(1);\n        CString sCTCPRequest = sLine.Token(2, true);\n\n        if (sCTCPRequest.empty()) {\n            sCTCPRequest = sUserName;\n            sUserName = GetUser()->GetUserName();\n        }\n        CUser* pUser = FindUser(sUserName);\n        if (!pUser) return;\n\n        if (sCTCPRequest.empty()) {\n            PutModule(t_s(\"Usage: DelCTCP [user] [request]\"));\n            return;\n        }\n\n        if (pUser->DelCTCPReply(sCTCPRequest)) {\n            PutModule(t_f(\n                \"CTCP requests {1} to user {2} will now be sent to IRC clients\")(\n                sCTCPRequest.AsUpper(), pUser->GetUserName()));\n        } else {\n            PutModule(\n                t_f(\"CTCP requests {1} to user {2} will be sent to IRC clients \"\n                    \"(nothing has changed)\")(sCTCPRequest.AsUpper(),\n                                             pUser->GetUserName()));\n        }\n    }\n\n    void LoadModuleFor(CModules& Modules, const CString& sModName,\n                       const CString& sArgs, CModInfo::EModuleType eType,\n                       CUser* pUser, CIRCNetwork* pNetwork) {\n        if (pUser->DenyLoadMod() && !GetUser()->IsAdmin()) {\n            PutModule(t_s(\"Loading modules has been disabled.\"));\n            return;\n        }\n\n        CString sModRet;\n        CModule* pMod = Modules.FindModule(sModName);\n        if (!pMod) {\n            if (!Modules.LoadModule(sModName, sArgs, eType, pUser, pNetwork,\n                                    sModRet)) {\n                PutModule(t_f(\"Error: Unable to load module {1}: {2}\")(\n                    sModName, sModRet));\n            } else {\n                PutModule(t_f(\"Loaded module {1}\")(sModName));\n            }\n        } else if (pMod->GetArgs() != sArgs) {\n            if (!Modules.ReloadModule(sModName, sArgs, pUser, pNetwork,\n                                      sModRet)) {\n                PutModule(t_f(\"Error: Unable to reload module {1}: {2}\")(\n                    sModName, sModRet));\n            } else {\n                PutModule(t_f(\"Reloaded module {1}\")(sModName));\n            }\n        } else {\n            PutModule(\n                t_f(\"Error: Unable to load module {1} because it is already \"\n                    \"loaded\")(sModName));\n        }\n    }\n\n    void LoadModuleForUser(const CString& sLine) {\n        CString sUsername = sLine.Token(1);\n        CString sModName = sLine.Token(2);\n        CString sArgs = sLine.Token(3, true);\n\n        if (sModName.empty()) {\n            PutModule(t_s(\"Usage: LoadModule <username> <modulename> [args]\"));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUsername);\n        if (!pUser) return;\n\n        LoadModuleFor(pUser->GetModules(), sModName, sArgs,\n                      CModInfo::UserModule, pUser, nullptr);\n    }\n\n    void LoadModuleForNetwork(const CString& sLine) {\n        CString sUsername = sLine.Token(1);\n        CString sNetwork = sLine.Token(2);\n        CString sModName = sLine.Token(3);\n        CString sArgs = sLine.Token(4, true);\n\n        if (sModName.empty()) {\n            PutModule(\n                t_s(\"Usage: LoadNetModule <username> <network> <modulename> \"\n                    \"[args]\"));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUsername);\n        if (!pUser) return;\n\n        CIRCNetwork* pNetwork = FindNetwork(pUser, sNetwork);\n        if (!pNetwork) {\n            return;\n        }\n\n        LoadModuleFor(pNetwork->GetModules(), sModName, sArgs,\n                      CModInfo::NetworkModule, pUser, pNetwork);\n    }\n\n    void UnLoadModuleFor(CModules& Modules, const CString& sModName,\n                         CUser* pUser) {\n        if (pUser->DenyLoadMod() && !GetUser()->IsAdmin()) {\n            PutModule(t_s(\"Loading modules has been disabled.\"));\n            return;\n        }\n\n        if (Modules.FindModule(sModName) == this) {\n            PutModule(t_f(\"Please use /znc unloadmod {1}\")(sModName));\n            return;\n        }\n\n        CString sModRet;\n        if (!Modules.UnloadModule(sModName, sModRet)) {\n            PutModule(t_f(\"Error: Unable to unload module {1}: {2}\")(sModName,\n                                                                     sModRet));\n        } else {\n            PutModule(t_f(\"Unloaded module {1}\")(sModName));\n        }\n    }\n\n    void UnLoadModuleForUser(const CString& sLine) {\n        CString sUsername = sLine.Token(1);\n        CString sModName = sLine.Token(2);\n\n        if (sModName.empty()) {\n            PutModule(t_s(\"Usage: UnloadModule <username> <modulename>\"));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUsername);\n        if (!pUser) return;\n\n        UnLoadModuleFor(pUser->GetModules(), sModName, pUser);\n    }\n\n    void UnLoadModuleForNetwork(const CString& sLine) {\n        CString sUsername = sLine.Token(1);\n        CString sNetwork = sLine.Token(2);\n        CString sModName = sLine.Token(3);\n\n        if (sModName.empty()) {\n            PutModule(t_s(\n                \"Usage: UnloadNetModule <username> <network> <modulename>\"));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUsername);\n        if (!pUser) return;\n\n        CIRCNetwork* pNetwork = FindNetwork(pUser, sNetwork);\n        if (!pNetwork) {\n            return;\n        }\n\n        UnLoadModuleFor(pNetwork->GetModules(), sModName, pUser);\n    }\n\n    void ListModulesFor(CModules& Modules) {\n        CTable Table;\n        Table.AddColumn(t_s(\"Name\", \"listmodules\"));\n        Table.AddColumn(t_s(\"Arguments\", \"listmodules\"));\n\n        for (const CModule* pMod : Modules) {\n            Table.AddRow();\n            Table.SetCell(t_s(\"Name\", \"listmodules\"), pMod->GetModName());\n            Table.SetCell(t_s(\"Arguments\", \"listmodules\"), pMod->GetArgs());\n        }\n\n        PutModule(Table);\n    }\n\n    void ListModulesForUser(const CString& sLine) {\n        CString sUsername = sLine.Token(1);\n\n        if (sUsername.empty()) {\n            PutModule(\"Usage: ListMods <username>\");\n            return;\n        }\n\n        CUser* pUser = FindUser(sUsername);\n        if (!pUser) return;\n\n        if (pUser->GetModules().empty()) {\n            PutModule(\n                t_f(\"User {1} has no modules loaded.\")(pUser->GetUserName()));\n            return;\n        }\n\n        PutModule(t_f(\"Modules loaded for user {1}:\")(pUser->GetUserName()));\n        ListModulesFor(pUser->GetModules());\n    }\n\n    void ListModulesForNetwork(const CString& sLine) {\n        CString sUsername = sLine.Token(1);\n        CString sNetwork = sLine.Token(2);\n\n        if (sNetwork.empty()) {\n            PutModule(\"Usage: ListNetMods <username> <network>\");\n            return;\n        }\n\n        CUser* pUser = FindUser(sUsername);\n        if (!pUser) return;\n\n        CIRCNetwork* pNetwork = FindNetwork(pUser, sNetwork);\n        if (!pNetwork) return;\n\n        if (pNetwork->GetModules().empty()) {\n            PutModule(t_f(\"Network {1} of user {2} has no modules loaded.\")(\n                pNetwork->GetName(), pUser->GetUserName()));\n            return;\n        }\n\n        PutModule(t_f(\"Modules loaded for network {1} of user {2}:\")(\n            pNetwork->GetName(), pUser->GetUserName()));\n        ListModulesFor(pNetwork->GetModules());\n    }\n\n  public:\n    MODCONSTRUCTOR(CAdminMod) {\n        AddCommand(\"Help\", t_d(\"[command] [variable]\"),\n                   t_d(\"Prints help for matching commands and variables\"),\n                   [=](const CString& sLine) { PrintHelp(sLine); });\n        AddCommand(\n            \"Get\", t_d(\"<variable> [username]\"),\n            t_d(\"Prints the variable's value for the given or current user\"),\n            [=](const CString& sLine) { Get(sLine); });\n        AddCommand(\"Set\", t_d(\"<variable> <username> <value>\"),\n                   t_d(\"Sets the variable's value for the given user\"),\n                   [=](const CString& sLine) { Set(sLine); });\n        AddCommand(\"GetNetwork\", t_d(\"<variable> [username] [network]\"),\n                   t_d(\"Prints the variable's value for the given network\"),\n                   [=](const CString& sLine) { GetNetwork(sLine); });\n        AddCommand(\"SetNetwork\", t_d(\"<variable> <username> <network> <value>\"),\n                   t_d(\"Sets the variable's value for the given network\"),\n                   [=](const CString& sLine) { SetNetwork(sLine); });\n        AddCommand(\"GetChan\", t_d(\"<variable> [username] <network> <chan>\"),\n                   t_d(\"Prints the variable's value for the given channel\"),\n                   [=](const CString& sLine) { GetChan(sLine); });\n        AddCommand(\"SetChan\",\n                   t_d(\"<variable> <username> <network> <chan> <value>\"),\n                   t_d(\"Sets the variable's value for the given channel\"),\n                   [=](const CString& sLine) { SetChan(sLine); });\n        AddCommand(\"AddChan\", t_d(\"<username> <network> <chan>\"),\n                   t_d(\"Adds a new channel\"),\n                   [=](const CString& sLine) { AddChan(sLine); });\n        AddCommand(\"DelChan\", t_d(\"<username> <network> <chan>\"),\n                   t_d(\"Deletes a channel\"),\n                   [=](const CString& sLine) { DelChan(sLine); });\n        AddCommand(\"ListUsers\", \"\", t_d(\"Lists users\"),\n                   [=](const CString& sLine) { ListUsers(sLine); });\n        AddCommand(\"AddUser\", t_d(\"<username> <password>\"),\n                   t_d(\"Adds a new user\"),\n                   [=](const CString& sLine) { AddUser(sLine); });\n        AddCommand(\"DelUser\", t_d(\"<username>\"), t_d(\"Deletes a user\"),\n                   [=](const CString& sLine) { DelUser(sLine); });\n        AddCommand(\"CloneUser\", t_d(\"<old username> <new username>\"),\n                   t_d(\"Clones a user\"),\n                   [=](const CString& sLine) { CloneUser(sLine); });\n        AddCommand(\"AddServer\", t_d(\"<username> <network> <server>\"),\n                   t_d(\"Adds a new IRC server for the given or current user\"),\n                   [=](const CString& sLine) { AddServer(sLine); });\n        AddCommand(\"DelServer\", t_d(\"<username> <network> <server>\"),\n                   t_d(\"Deletes an IRC server from the given or current user\"),\n                   [=](const CString& sLine) { DelServer(sLine); });\n        AddCommand(\"Reconnect\", t_d(\"<username> <network>\"),\n                   t_d(\"Cycles the user's IRC server connection\"),\n                   [=](const CString& sLine) { ReconnectUser(sLine); });\n        AddCommand(\"Disconnect\", t_d(\"<username> <network>\"),\n                   t_d(\"Disconnects the user from their IRC server\"),\n                   [=](const CString& sLine) { DisconnectUser(sLine); });\n        AddCommand(\"LoadModule\", t_d(\"<username> <modulename> [args]\"),\n                   t_d(\"Loads a Module for a user\"),\n                   [=](const CString& sLine) { LoadModuleForUser(sLine); });\n        AddCommand(\"UnLoadModule\", t_d(\"<username> <modulename>\"),\n                   t_d(\"Removes a Module of a user\"),\n                   [=](const CString& sLine) { UnLoadModuleForUser(sLine); });\n        AddCommand(\"ListMods\", t_d(\"<username>\"),\n                   t_d(\"Get the list of modules for a user\"),\n                   [=](const CString& sLine) { ListModulesForUser(sLine); });\n        AddCommand(\"LoadNetModule\",\n                   t_d(\"<username> <network> <modulename> [args]\"),\n                   t_d(\"Loads a Module for a network\"),\n                   [=](const CString& sLine) { LoadModuleForNetwork(sLine); });\n        AddCommand(\n            \"UnLoadNetModule\", t_d(\"<username> <network> <modulename>\"),\n            t_d(\"Removes a Module of a network\"),\n            [=](const CString& sLine) { UnLoadModuleForNetwork(sLine); });\n        AddCommand(\"ListNetMods\", t_d(\"<username> <network>\"),\n                   t_d(\"Get the list of modules for a network\"),\n                   [=](const CString& sLine) { ListModulesForNetwork(sLine); });\n        AddCommand(\"ListCTCPs\", t_d(\"<username>\"),\n                   t_d(\"List the configured CTCP replies\"),\n                   [=](const CString& sLine) { ListCTCP(sLine); });\n        AddCommand(\"AddCTCP\", t_d(\"<username> <ctcp> [reply]\"),\n                   t_d(\"Configure a new CTCP reply\"),\n                   [=](const CString& sLine) { AddCTCP(sLine); });\n        AddCommand(\"DelCTCP\", t_d(\"<username> <ctcp>\"),\n                   t_d(\"Remove a CTCP reply\"),\n                   [=](const CString& sLine) { DelCTCP(sLine); });\n\n        // Network commands\n        AddCommand(\"AddNetwork\", t_d(\"[username] <network>\"),\n                   t_d(\"Add a network for a user\"),\n                   [=](const CString& sLine) { AddNetwork(sLine); });\n        AddCommand(\"DelNetwork\", t_d(\"[username] <network>\"),\n                   t_d(\"Delete a network for a user\"),\n                   [=](const CString& sLine) { DelNetwork(sLine); });\n        AddCommand(\"ListNetworks\", t_d(\"[username]\"),\n                   t_d(\"List all networks for a user\"),\n                   [=](const CString& sLine) { ListNetworks(sLine); });\n    }\n\n    ~CAdminMod() override {}\n};\n\ntemplate <>\nvoid TModInfo<CAdminMod>(CModInfo& Info) {\n    Info.SetWikiPage(\"controlpanel\");\n}\n\nUSERMODULEDEFS(CAdminMod,\n               t_s(\"Dynamic configuration through IRC. Allows editing only \"\n               \"yourself if you're not ZNC admin.\"))\n", "/*\n * Copyright (C) 2004-2018 ZNC, see the NOTICE file for details.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <znc/IRCNetwork.h>\n#include <znc/User.h>\n#include <znc/FileUtils.h>\n#include <znc/Config.h>\n#include <znc/IRCSock.h>\n#include <znc/Server.h>\n#include <znc/Chan.h>\n#include <znc/Query.h>\n#include <znc/Message.h>\n#include <algorithm>\n#include <memory>\n\nusing std::vector;\nusing std::set;\n\nclass CIRCNetworkPingTimer : public CCron {\n  public:\n    CIRCNetworkPingTimer(CIRCNetwork* pNetwork)\n        : CCron(), m_pNetwork(pNetwork) {\n        SetName(\"CIRCNetworkPingTimer::\" +\n                m_pNetwork->GetUser()->GetUserName() + \"::\" +\n                m_pNetwork->GetName());\n        Start(m_pNetwork->GetUser()->GetPingSlack());\n    }\n\n    ~CIRCNetworkPingTimer() override {}\n\n    CIRCNetworkPingTimer(const CIRCNetworkPingTimer&) = delete;\n    CIRCNetworkPingTimer& operator=(const CIRCNetworkPingTimer&) = delete;\n\n  protected:\n    void RunJob() override {\n        CIRCSock* pIRCSock = m_pNetwork->GetIRCSock();\n        auto uFrequency = m_pNetwork->GetUser()->GetPingFrequency();\n\n        if (pIRCSock &&\n            pIRCSock->GetTimeSinceLastDataTransaction() >= uFrequency) {\n            pIRCSock->PutIRC(\"PING :ZNC\");\n        }\n\n        const vector<CClient*>& vClients = m_pNetwork->GetClients();\n        for (CClient* pClient : vClients) {\n            if (pClient->GetTimeSinceLastDataTransaction() >= uFrequency) {\n                pClient->PutClient(\"PING :ZNC\");\n            }\n        }\n\n        // Restart timer for the case if the period had changed. Usually this is\n        // noop\n        Start(m_pNetwork->GetUser()->GetPingSlack());\n    }\n\n  private:\n    CIRCNetwork* m_pNetwork;\n};\n\nclass CIRCNetworkJoinTimer : public CCron {\n    constexpr static int JOIN_FREQUENCY = 30 /* seconds */;\n\n  public:\n    CIRCNetworkJoinTimer(CIRCNetwork* pNetwork)\n        : CCron(), m_bDelayed(false), m_pNetwork(pNetwork) {\n        SetName(\"CIRCNetworkJoinTimer::\" +\n                m_pNetwork->GetUser()->GetUserName() + \"::\" +\n                m_pNetwork->GetName());\n        Start(JOIN_FREQUENCY);\n    }\n\n    ~CIRCNetworkJoinTimer() override {}\n\n    CIRCNetworkJoinTimer(const CIRCNetworkJoinTimer&) = delete;\n    CIRCNetworkJoinTimer& operator=(const CIRCNetworkJoinTimer&) = delete;\n\n    void Delay(unsigned short int uDelay) {\n        m_bDelayed = true;\n        Start(uDelay);\n    }\n\n  protected:\n    void RunJob() override {\n        if (m_bDelayed) {\n            m_bDelayed = false;\n            Start(JOIN_FREQUENCY);\n        }\n        if (m_pNetwork->IsIRCConnected()) {\n            m_pNetwork->JoinChans();\n        }\n    }\n\n  private:\n    bool m_bDelayed;\n    CIRCNetwork* m_pNetwork;\n};\n\nbool CIRCNetwork::IsValidNetwork(const CString& sNetwork) {\n    // ^[-\\w]+$\n\n    if (sNetwork.empty()) {\n        return false;\n    }\n\n    const char* p = sNetwork.c_str();\n    while (*p) {\n        if (*p != '_' && *p != '-' && !isalnum(*p)) {\n            return false;\n        }\n\n        p++;\n    }\n\n    return true;\n}\n\nCIRCNetwork::CIRCNetwork(CUser* pUser, const CString& sName)\n    : m_sName(sName),\n      m_pUser(nullptr),\n      m_sNick(\"\"),\n      m_sAltNick(\"\"),\n      m_sIdent(\"\"),\n      m_sRealName(\"\"),\n      m_sBindHost(\"\"),\n      m_sEncoding(\"\"),\n      m_sQuitMsg(\"\"),\n      m_ssTrustedFingerprints(),\n      m_pModules(new CModules),\n      m_vClients(),\n      m_pIRCSock(nullptr),\n      m_vChans(),\n      m_vQueries(),\n      m_sChanPrefixes(\"\"),\n      m_bIRCConnectEnabled(true),\n      m_bTrustAllCerts(false),\n      m_bTrustPKI(true),\n      m_sIRCServer(\"\"),\n      m_vServers(),\n      m_uServerIdx(0),\n      m_IRCNick(),\n      m_bIRCAway(false),\n      m_fFloodRate(2),\n      m_uFloodBurst(9),\n      m_RawBuffer(),\n      m_MotdBuffer(),\n      m_NoticeBuffer(),\n      m_pPingTimer(nullptr),\n      m_pJoinTimer(nullptr),\n      m_uJoinDelay(0),\n      m_uBytesRead(0),\n      m_uBytesWritten(0) {\n    SetUser(pUser);\n\n    // This should be more than enough raws, especially since we are buffering\n    // the MOTD separately\n    m_RawBuffer.SetLineCount(100, true);\n    // This should be more than enough motd lines\n    m_MotdBuffer.SetLineCount(200, true);\n    m_NoticeBuffer.SetLineCount(250, true);\n\n    m_pPingTimer = new CIRCNetworkPingTimer(this);\n    CZNC::Get().GetManager().AddCron(m_pPingTimer);\n\n    m_pJoinTimer = new CIRCNetworkJoinTimer(this);\n    CZNC::Get().GetManager().AddCron(m_pJoinTimer);\n\n    SetIRCConnectEnabled(true);\n}\n\nCIRCNetwork::CIRCNetwork(CUser* pUser, const CIRCNetwork& Network)\n    : CIRCNetwork(pUser, \"\") {\n    Clone(Network);\n}\n\nvoid CIRCNetwork::Clone(const CIRCNetwork& Network, bool bCloneName) {\n    if (bCloneName) {\n        m_sName = Network.GetName();\n    }\n\n    m_fFloodRate = Network.GetFloodRate();\n    m_uFloodBurst = Network.GetFloodBurst();\n    m_uJoinDelay = Network.GetJoinDelay();\n\n    SetNick(Network.GetNick());\n    SetAltNick(Network.GetAltNick());\n    SetIdent(Network.GetIdent());\n    SetRealName(Network.GetRealName());\n    SetBindHost(Network.GetBindHost());\n    SetEncoding(Network.GetEncoding());\n    SetQuitMsg(Network.GetQuitMsg());\n    m_ssTrustedFingerprints = Network.m_ssTrustedFingerprints;\n\n    // Servers\n    const vector<CServer*>& vServers = Network.GetServers();\n    CString sServer;\n    CServer* pCurServ = GetCurrentServer();\n\n    if (pCurServ) {\n        sServer = pCurServ->GetName();\n    }\n\n    DelServers();\n\n    for (CServer* pServer : vServers) {\n        AddServer(pServer->GetName(), pServer->GetPort(), pServer->GetPass(),\n                  pServer->IsSSL());\n    }\n\n    m_uServerIdx = 0;\n    for (size_t a = 0; a < m_vServers.size(); a++) {\n        if (sServer.Equals(m_vServers[a]->GetName())) {\n            m_uServerIdx = a + 1;\n            break;\n        }\n    }\n    if (m_uServerIdx == 0) {\n        m_uServerIdx = m_vServers.size();\n        CIRCSock* pSock = GetIRCSock();\n\n        if (pSock) {\n            PutStatus(\n                t_s(\"Jumping servers because this server is no longer in the \"\n                    \"list\"));\n            pSock->Quit();\n        }\n    }\n    // !Servers\n\n    // Chans\n    const vector<CChan*>& vChans = Network.GetChans();\n    for (CChan* pNewChan : vChans) {\n        CChan* pChan = FindChan(pNewChan->GetName());\n\n        if (pChan) {\n            pChan->SetInConfig(pNewChan->InConfig());\n        } else {\n            AddChan(pNewChan->GetName(), pNewChan->InConfig());\n        }\n    }\n\n    for (CChan* pChan : m_vChans) {\n        CChan* pNewChan = Network.FindChan(pChan->GetName());\n\n        if (!pNewChan) {\n            pChan->SetInConfig(false);\n        } else {\n            pChan->Clone(*pNewChan);\n        }\n    }\n    // !Chans\n\n    // Modules\n    set<CString> ssUnloadMods;\n    CModules& vCurMods = GetModules();\n    const CModules& vNewMods = Network.GetModules();\n\n    for (CModule* pNewMod : vNewMods) {\n        CString sModRet;\n        CModule* pCurMod = vCurMods.FindModule(pNewMod->GetModName());\n\n        if (!pCurMod) {\n            vCurMods.LoadModule(pNewMod->GetModName(), pNewMod->GetArgs(),\n                                CModInfo::NetworkModule, m_pUser, this,\n                                sModRet);\n        } else if (pNewMod->GetArgs() != pCurMod->GetArgs()) {\n            vCurMods.ReloadModule(pNewMod->GetModName(), pNewMod->GetArgs(),\n                                  m_pUser, this, sModRet);\n        }\n    }\n\n    for (CModule* pCurMod : vCurMods) {\n        CModule* pNewMod = vNewMods.FindModule(pCurMod->GetModName());\n\n        if (!pNewMod) {\n            ssUnloadMods.insert(pCurMod->GetModName());\n        }\n    }\n\n    for (const CString& sMod : ssUnloadMods) {\n        vCurMods.UnloadModule(sMod);\n    }\n    // !Modules\n\n    SetIRCConnectEnabled(Network.GetIRCConnectEnabled());\n}\n\nCIRCNetwork::~CIRCNetwork() {\n    if (m_pIRCSock) {\n        CZNC::Get().GetManager().DelSockByAddr(m_pIRCSock);\n        m_pIRCSock = nullptr;\n    }\n\n    // Delete clients\n    while (!m_vClients.empty()) {\n        CZNC::Get().GetManager().DelSockByAddr(m_vClients[0]);\n    }\n    m_vClients.clear();\n\n    // Delete servers\n    DelServers();\n\n    // Delete modules (this unloads all modules)\n    delete m_pModules;\n    m_pModules = nullptr;\n\n    // Delete Channels\n    for (CChan* pChan : m_vChans) {\n        delete pChan;\n    }\n    m_vChans.clear();\n\n    // Delete Queries\n    for (CQuery* pQuery : m_vQueries) {\n        delete pQuery;\n    }\n    m_vQueries.clear();\n\n    CUser* pUser = GetUser();\n    SetUser(nullptr);\n\n    // Make sure we are not in the connection queue\n    CZNC::Get().GetConnectionQueue().remove(this);\n\n    CZNC::Get().GetManager().DelCronByAddr(m_pPingTimer);\n    CZNC::Get().GetManager().DelCronByAddr(m_pJoinTimer);\n\n    if (pUser) {\n        pUser->AddBytesRead(m_uBytesRead);\n        pUser->AddBytesWritten(m_uBytesWritten);\n    } else {\n        CZNC::Get().AddBytesRead(m_uBytesRead);\n        CZNC::Get().AddBytesWritten(m_uBytesWritten);\n    }\n}\n\nvoid CIRCNetwork::DelServers() {\n    for (CServer* pServer : m_vServers) {\n        delete pServer;\n    }\n    m_vServers.clear();\n}\n\nCString CIRCNetwork::GetNetworkPath() const {\n    CString sNetworkPath = m_pUser->GetUserPath() + \"/networks/\" + m_sName;\n\n    if (!CFile::Exists(sNetworkPath)) {\n        CDir::MakeDir(sNetworkPath);\n    }\n\n    return sNetworkPath;\n}\n\ntemplate <class T>\nstruct TOption {\n    const char* name;\n    void (CIRCNetwork::*pSetter)(T);\n};\n\nbool CIRCNetwork::ParseConfig(CConfig* pConfig, CString& sError,\n                              bool bUpgrade) {\n    VCString vsList;\n\n    if (!bUpgrade) {\n        TOption<const CString&> StringOptions[] = {\n            {\"nick\", &CIRCNetwork::SetNick},\n            {\"altnick\", &CIRCNetwork::SetAltNick},\n            {\"ident\", &CIRCNetwork::SetIdent},\n            {\"realname\", &CIRCNetwork::SetRealName},\n            {\"bindhost\", &CIRCNetwork::SetBindHost},\n            {\"encoding\", &CIRCNetwork::SetEncoding},\n            {\"quitmsg\", &CIRCNetwork::SetQuitMsg},\n        };\n        TOption<bool> BoolOptions[] = {\n            {\"ircconnectenabled\", &CIRCNetwork::SetIRCConnectEnabled},\n            {\"trustallcerts\", &CIRCNetwork::SetTrustAllCerts},\n            {\"trustpki\", &CIRCNetwork::SetTrustPKI},\n        };\n        TOption<double> DoubleOptions[] = {\n            {\"floodrate\", &CIRCNetwork::SetFloodRate},\n        };\n        TOption<short unsigned int> SUIntOptions[] = {\n            {\"floodburst\", &CIRCNetwork::SetFloodBurst},\n            {\"joindelay\", &CIRCNetwork::SetJoinDelay},\n        };\n\n        for (const auto& Option : StringOptions) {\n            CString sValue;\n            if (pConfig->FindStringEntry(Option.name, sValue))\n                (this->*Option.pSetter)(sValue);\n        }\n\n        for (const auto& Option : BoolOptions) {\n            CString sValue;\n            if (pConfig->FindStringEntry(Option.name, sValue))\n                (this->*Option.pSetter)(sValue.ToBool());\n        }\n\n        for (const auto& Option : DoubleOptions) {\n            double fValue;\n            if (pConfig->FindDoubleEntry(Option.name, fValue))\n                (this->*Option.pSetter)(fValue);\n        }\n\n        for (const auto& Option : SUIntOptions) {\n            unsigned short value;\n            if (pConfig->FindUShortEntry(Option.name, value))\n                (this->*Option.pSetter)(value);\n        }\n\n        pConfig->FindStringVector(\"loadmodule\", vsList);\n        for (const CString& sValue : vsList) {\n            CString sModName = sValue.Token(0);\n            CString sNotice = \"Loading network module [\" + sModName + \"]\";\n\n            // XXX Legacy crap, added in ZNC 0.203, modified in 0.207\n            // Note that 0.203 == 0.207\n            if (sModName == \"away\") {\n                sNotice =\n                    \"NOTICE: [away] was renamed, loading [awaystore] instead\";\n                sModName = \"awaystore\";\n            }\n\n            // XXX Legacy crap, added in ZNC 0.207\n            if (sModName == \"autoaway\") {\n                sNotice =\n                    \"NOTICE: [autoaway] was renamed, loading [awaystore] \"\n                    \"instead\";\n                sModName = \"awaystore\";\n            }\n\n            // XXX Legacy crap, added in 1.1; fakeonline module was dropped in\n            // 1.0 and returned in 1.1\n            if (sModName == \"fakeonline\") {\n                sNotice =\n                    \"NOTICE: [fakeonline] was renamed, loading \"\n                    \"[modules_online] instead\";\n                sModName = \"modules_online\";\n            }\n\n            CString sModRet;\n            CString sArgs = sValue.Token(1, true);\n\n            bool bModRet = LoadModule(sModName, sArgs, sNotice, sModRet);\n\n            if (!bModRet) {\n                // XXX The awaynick module was retired in 1.6 (still available\n                // as external module)\n                if (sModName == \"awaynick\") {\n                    // load simple_away instead, unless it's already on the list\n                    bool bFound = false;\n                    for (const CString& sLoadMod : vsList) {\n                        if (sLoadMod.Token(0).Equals(\"simple_away\")) {\n                            bFound = true;\n                        }\n                    }\n                    if (!bFound) {\n                        sNotice =\n                            \"NOTICE: awaynick was retired, loading network \"\n                            \"module [simple_away] instead; if you still need \"\n                            \"awaynick, install it as an external module\";\n                        sModName = \"simple_away\";\n                        // not a fatal error if simple_away is not available\n                        LoadModule(sModName, sArgs, sNotice, sModRet);\n                    }\n                } else {\n                    sError = sModRet;\n                    return false;\n                }\n            }\n        }\n    }\n\n    pConfig->FindStringVector(\"server\", vsList);\n    for (const CString& sServer : vsList) {\n        CUtils::PrintAction(\"Adding server [\" + sServer + \"]\");\n        CUtils::PrintStatus(AddServer(sServer));\n    }\n\n    pConfig->FindStringVector(\"trustedserverfingerprint\", vsList);\n    for (const CString& sFP : vsList) {\n        AddTrustedFingerprint(sFP);\n    }\n\n    pConfig->FindStringVector(\"chan\", vsList);\n    for (const CString& sChan : vsList) {\n        AddChan(sChan, true);\n    }\n\n    CConfig::SubConfig subConf;\n    CConfig::SubConfig::const_iterator subIt;\n\n    pConfig->FindSubConfig(\"chan\", subConf);\n    for (subIt = subConf.begin(); subIt != subConf.end(); ++subIt) {\n        const CString& sChanName = subIt->first;\n        CConfig* pSubConf = subIt->second.m_pSubConfig;\n        CChan* pChan = new CChan(sChanName, this, true, pSubConf);\n\n        if (!pSubConf->empty()) {\n            sError = \"Unhandled lines in config for User [\" +\n                     m_pUser->GetUserName() + \"], Network [\" + GetName() +\n                     \"], Channel [\" + sChanName + \"]!\";\n            CUtils::PrintError(sError);\n\n            CZNC::DumpConfig(pSubConf);\n            delete pChan;\n            return false;\n        }\n\n        // Save the channel name, because AddChan\n        // deletes the CChannel*, if adding fails\n        sError = pChan->GetName();\n        if (!AddChan(pChan)) {\n            sError = \"Channel [\" + sError + \"] defined more than once\";\n            CUtils::PrintError(sError);\n            return false;\n        }\n        sError.clear();\n    }\n\n    return true;\n}\n\nCConfig CIRCNetwork::ToConfig() const {\n    CConfig config;\n\n    if (!m_sNick.empty()) {\n        config.AddKeyValuePair(\"Nick\", m_sNick);\n    }\n\n    if (!m_sAltNick.empty()) {\n        config.AddKeyValuePair(\"AltNick\", m_sAltNick);\n    }\n\n    if (!m_sIdent.empty()) {\n        config.AddKeyValuePair(\"Ident\", m_sIdent);\n    }\n\n    if (!m_sRealName.empty()) {\n        config.AddKeyValuePair(\"RealName\", m_sRealName);\n    }\n    if (!m_sBindHost.empty()) {\n        config.AddKeyValuePair(\"BindHost\", m_sBindHost);\n    }\n\n    config.AddKeyValuePair(\"IRCConnectEnabled\",\n                           CString(GetIRCConnectEnabled()));\n    config.AddKeyValuePair(\"TrustAllCerts\", CString(GetTrustAllCerts()));\n    config.AddKeyValuePair(\"TrustPKI\", CString(GetTrustPKI()));\n    config.AddKeyValuePair(\"FloodRate\", CString(GetFloodRate()));\n    config.AddKeyValuePair(\"FloodBurst\", CString(GetFloodBurst()));\n    config.AddKeyValuePair(\"JoinDelay\", CString(GetJoinDelay()));\n    config.AddKeyValuePair(\"Encoding\", m_sEncoding);\n\n    if (!m_sQuitMsg.empty()) {\n        config.AddKeyValuePair(\"QuitMsg\", m_sQuitMsg);\n    }\n\n    // Modules\n    const CModules& Mods = GetModules();\n\n    if (!Mods.empty()) {\n        for (CModule* pMod : Mods) {\n            CString sArgs = pMod->GetArgs();\n\n            if (!sArgs.empty()) {\n                sArgs = \" \" + sArgs;\n            }\n\n            config.AddKeyValuePair(\"LoadModule\", pMod->GetModName() + sArgs);\n        }\n    }\n\n    // Servers\n    for (CServer* pServer : m_vServers) {\n        config.AddKeyValuePair(\"Server\", pServer->GetString());\n    }\n\n    for (const CString& sFP : m_ssTrustedFingerprints) {\n        config.AddKeyValuePair(\"TrustedServerFingerprint\", sFP);\n    }\n\n    // Chans\n    for (CChan* pChan : m_vChans) {\n        if (pChan->InConfig()) {\n            config.AddSubConfig(\"Chan\", pChan->GetName(), pChan->ToConfig());\n        }\n    }\n\n    return config;\n}\n\nvoid CIRCNetwork::BounceAllClients() {\n    for (CClient* pClient : m_vClients) {\n        pClient->BouncedOff();\n    }\n\n    m_vClients.clear();\n}\n\nbool CIRCNetwork::IsUserOnline() const {\n    for (CClient* pClient : m_vClients) {\n        if (!pClient->IsAway()) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nvoid CIRCNetwork::ClientConnected(CClient* pClient) {\n    if (!m_pUser->MultiClients()) {\n        BounceAllClients();\n    }\n\n    m_vClients.push_back(pClient);\n\n    size_t uIdx, uSize;\n\n    if (m_pIRCSock) {\n        pClient->NotifyServerDependentCaps(m_pIRCSock->GetAcceptedCaps());\n    }\n\n    pClient->SetPlaybackActive(true);\n\n    if (m_RawBuffer.IsEmpty()) {\n        pClient->PutClient(\":irc.znc.in 001 \" + pClient->GetNick() +\n                           \" :\" + t_s(\"Welcome to ZNC\"));\n    } else {\n        const CString& sClientNick = pClient->GetNick(false);\n        MCString msParams;\n        msParams[\"target\"] = sClientNick;\n\n        uSize = m_RawBuffer.Size();\n        for (uIdx = 0; uIdx < uSize; uIdx++) {\n            pClient->PutClient(m_RawBuffer.GetLine(uIdx, *pClient, msParams));\n        }\n\n        const CNick& Nick = GetIRCNick();\n        if (sClientNick != Nick.GetNick()) {  // case-sensitive match\n            pClient->PutClient(\":\" + sClientNick + \"!\" + Nick.GetIdent() + \"@\" +\n                               Nick.GetHost() + \" NICK :\" + Nick.GetNick());\n            pClient->SetNick(Nick.GetNick());\n        }\n    }\n\n    MCString msParams;\n    msParams[\"target\"] = GetIRCNick().GetNick();\n\n    // Send the cached MOTD\n    uSize = m_MotdBuffer.Size();\n    if (uSize > 0) {\n        for (uIdx = 0; uIdx < uSize; uIdx++) {\n            pClient->PutClient(m_MotdBuffer.GetLine(uIdx, *pClient, msParams));\n        }\n    }\n\n    if (GetIRCSock() != nullptr) {\n        CString sUserMode(\"\");\n        const set<char>& scUserModes = GetIRCSock()->GetUserModes();\n        for (char cMode : scUserModes) {\n            sUserMode += cMode;\n        }\n        if (!sUserMode.empty()) {\n            pClient->PutClient(\":\" + GetIRCNick().GetNickMask() + \" MODE \" +\n                               GetIRCNick().GetNick() + \" :+\" + sUserMode);\n        }\n    }\n\n    if (m_bIRCAway) {\n        // If they want to know their away reason they'll have to whois\n        // themselves. At least we can tell them their away status...\n        pClient->PutClient(\":irc.znc.in 306 \" + GetIRCNick().GetNick() +\n                           \" :You have been marked as being away\");\n    }\n\n    const vector<CChan*>& vChans = GetChans();\n    for (CChan* pChan : vChans) {\n        if ((pChan->IsOn()) && (!pChan->IsDetached())) {\n            pChan->AttachUser(pClient);\n        }\n    }\n\n    bool bClearQuery = m_pUser->AutoClearQueryBuffer();\n    for (CQuery* pQuery : m_vQueries) {\n        pQuery->SendBuffer(pClient);\n        if (bClearQuery) {\n            delete pQuery;\n        }\n    }\n    if (bClearQuery) {\n        m_vQueries.clear();\n    }\n\n    uSize = m_NoticeBuffer.Size();\n    for (uIdx = 0; uIdx < uSize; uIdx++) {\n        const CBufLine& BufLine = m_NoticeBuffer.GetBufLine(uIdx);\n        CMessage Message(BufLine.GetLine(*pClient, msParams));\n        Message.SetNetwork(this);\n        Message.SetClient(pClient);\n        Message.SetTime(BufLine.GetTime());\n        Message.SetTags(BufLine.GetTags());\n        bool bContinue = false;\n        NETWORKMODULECALL(OnPrivBufferPlayMessage(Message), m_pUser, this,\n                          nullptr, &bContinue);\n        if (bContinue) continue;\n        pClient->PutClient(Message);\n    }\n    m_NoticeBuffer.Clear();\n\n    pClient->SetPlaybackActive(false);\n\n    // Tell them why they won't connect\n    if (!GetIRCConnectEnabled())\n        pClient->PutStatus(\n            t_s(\"You are currently disconnected from IRC. Use 'connect' to \"\n                \"reconnect.\"));\n}\n\nvoid CIRCNetwork::ClientDisconnected(CClient* pClient) {\n    auto it = std::find(m_vClients.begin(), m_vClients.end(), pClient);\n    if (it != m_vClients.end()) {\n        m_vClients.erase(it);\n    }\n}\n\nCUser* CIRCNetwork::GetUser() const { return m_pUser; }\n\nconst CString& CIRCNetwork::GetName() const { return m_sName; }\n\nstd::vector<CClient*> CIRCNetwork::FindClients(\n    const CString& sIdentifier) const {\n    std::vector<CClient*> vClients;\n    for (CClient* pClient : m_vClients) {\n        if (pClient->GetIdentifier().Equals(sIdentifier)) {\n            vClients.push_back(pClient);\n        }\n    }\n\n    return vClients;\n}\n\nvoid CIRCNetwork::SetUser(CUser* pUser) {\n    for (CClient* pClient : m_vClients) {\n        pClient->PutStatus(\n            t_s(\"This network is being deleted or moved to another user.\"));\n        pClient->SetNetwork(nullptr);\n    }\n\n    m_vClients.clear();\n\n    if (m_pUser) {\n        m_pUser->RemoveNetwork(this);\n    }\n\n    m_pUser = pUser;\n    if (m_pUser) {\n        m_pUser->AddNetwork(this);\n    }\n}\n\nbool CIRCNetwork::SetName(const CString& sName) {\n    if (IsValidNetwork(sName)) {\n        m_sName = sName;\n        return true;\n    }\n\n    return false;\n}\n\nbool CIRCNetwork::PutUser(const CString& sLine, CClient* pClient,\n                          CClient* pSkipClient) {\n    for (CClient* pEachClient : m_vClients) {\n        if ((!pClient || pClient == pEachClient) &&\n            pSkipClient != pEachClient) {\n            pEachClient->PutClient(sLine);\n\n            if (pClient) {\n                return true;\n            }\n        }\n    }\n\n    return (pClient == nullptr);\n}\n\nbool CIRCNetwork::PutUser(const CMessage& Message, CClient* pClient,\n                          CClient* pSkipClient) {\n    for (CClient* pEachClient : m_vClients) {\n        if ((!pClient || pClient == pEachClient) &&\n            pSkipClient != pEachClient) {\n            pEachClient->PutClient(Message);\n\n            if (pClient) {\n                return true;\n            }\n        }\n    }\n\n    return (pClient == nullptr);\n}\n\nbool CIRCNetwork::PutStatus(const CString& sLine, CClient* pClient,\n                            CClient* pSkipClient) {\n    for (CClient* pEachClient : m_vClients) {\n        if ((!pClient || pClient == pEachClient) &&\n            pSkipClient != pEachClient) {\n            pEachClient->PutStatus(sLine);\n\n            if (pClient) {\n                return true;\n            }\n        }\n    }\n\n    return (pClient == nullptr);\n}\n\nbool CIRCNetwork::PutModule(const CString& sModule, const CString& sLine,\n                            CClient* pClient, CClient* pSkipClient) {\n    for (CClient* pEachClient : m_vClients) {\n        if ((!pClient || pClient == pEachClient) &&\n            pSkipClient != pEachClient) {\n            pEachClient->PutModule(sModule, sLine);\n\n            if (pClient) {\n                return true;\n            }\n        }\n    }\n\n    return (pClient == nullptr);\n}\n\n// Channels\n\nconst vector<CChan*>& CIRCNetwork::GetChans() const { return m_vChans; }\n\nCChan* CIRCNetwork::FindChan(CString sName) const {\n    if (GetIRCSock()) {\n        // See\n        // https://tools.ietf.org/html/draft-brocklesby-irc-isupport-03#section-3.16\n        sName.TrimLeft(GetIRCSock()->GetISupport(\"STATUSMSG\", \"\"));\n    }\n\n    for (CChan* pChan : m_vChans) {\n        if (sName.Equals(pChan->GetName())) {\n            return pChan;\n        }\n    }\n\n    return nullptr;\n}\n\nstd::vector<CChan*> CIRCNetwork::FindChans(const CString& sWild) const {\n    std::vector<CChan*> vChans;\n    vChans.reserve(m_vChans.size());\n    const CString sLower = sWild.AsLower();\n    for (CChan* pChan : m_vChans) {\n        if (pChan->GetName().AsLower().WildCmp(sLower)) vChans.push_back(pChan);\n    }\n    return vChans;\n}\n\nbool CIRCNetwork::AddChan(CChan* pChan) {\n    if (!pChan) {\n        return false;\n    }\n\n    for (CChan* pEachChan : m_vChans) {\n        if (pEachChan->GetName().Equals(pChan->GetName())) {\n            delete pChan;\n            return false;\n        }\n    }\n\n    m_vChans.push_back(pChan);\n    return true;\n}\n\nbool CIRCNetwork::AddChan(const CString& sName, bool bInConfig) {\n    if (sName.empty() || FindChan(sName)) {\n        return false;\n    }\n\n    CChan* pChan = new CChan(sName, this, bInConfig);\n    m_vChans.push_back(pChan);\n    return true;\n}\n\nbool CIRCNetwork::DelChan(const CString& sName) {\n    for (vector<CChan*>::iterator a = m_vChans.begin(); a != m_vChans.end();\n         ++a) {\n        if (sName.Equals((*a)->GetName())) {\n            delete *a;\n            m_vChans.erase(a);\n            return true;\n        }\n    }\n\n    return false;\n}\n\nvoid CIRCNetwork::JoinChans() {\n    // Avoid divsion by zero, it's bad!\n    if (m_vChans.empty()) return;\n\n    // We start at a random offset into the channel list so that if your\n    // first 3 channels are invite-only and you got MaxJoins == 3, ZNC will\n    // still be able to join the rest of your channels.\n    unsigned int start = rand() % m_vChans.size();\n    unsigned int uJoins = m_pUser->MaxJoins();\n    set<CChan*> sChans;\n    for (unsigned int a = 0; a < m_vChans.size(); a++) {\n        unsigned int idx = (start + a) % m_vChans.size();\n        CChan* pChan = m_vChans[idx];\n        if (!pChan->IsOn() && !pChan->IsDisabled()) {\n            if (!JoinChan(pChan)) continue;\n\n            sChans.insert(pChan);\n\n            // Limit the number of joins\n            if (uJoins != 0 && --uJoins == 0) {\n                // Reset the timer.\n                m_pJoinTimer->Reset();\n                break;\n            }\n        }\n    }\n\n    while (!sChans.empty()) JoinChans(sChans);\n}\n\nvoid CIRCNetwork::JoinChans(set<CChan*>& sChans) {\n    CString sKeys, sJoin;\n    bool bHaveKey = false;\n    size_t uiJoinLength = strlen(\"JOIN \");\n\n    while (!sChans.empty()) {\n        set<CChan*>::iterator it = sChans.begin();\n        const CString& sName = (*it)->GetName();\n        const CString& sKey = (*it)->GetKey();\n        size_t len = sName.length() + sKey.length();\n        len += 2;  // two comma\n\n        if (!sKeys.empty() && uiJoinLength + len >= 512) break;\n\n        if (!sJoin.empty()) {\n            sJoin += \",\";\n            sKeys += \",\";\n        }\n        uiJoinLength += len;\n        sJoin += sName;\n        if (!sKey.empty()) {\n            sKeys += sKey;\n            bHaveKey = true;\n        }\n        sChans.erase(it);\n    }\n\n    if (bHaveKey)\n        PutIRC(\"JOIN \" + sJoin + \" \" + sKeys);\n    else\n        PutIRC(\"JOIN \" + sJoin);\n}\n\nbool CIRCNetwork::JoinChan(CChan* pChan) {\n    bool bReturn = false;\n    NETWORKMODULECALL(OnJoining(*pChan), m_pUser, this, nullptr, &bReturn);\n\n    if (bReturn) return false;\n\n    if (m_pUser->JoinTries() != 0 &&\n        pChan->GetJoinTries() >= m_pUser->JoinTries()) {\n        PutStatus(t_f(\"The channel {1} could not be joined, disabling it.\")(\n            pChan->GetName()));\n        pChan->Disable();\n    } else {\n        pChan->IncJoinTries();\n        bool bFailed = false;\n        NETWORKMODULECALL(OnTimerAutoJoin(*pChan), m_pUser, this, nullptr,\n                          &bFailed);\n        if (bFailed) return false;\n        return true;\n    }\n    return false;\n}\n\nbool CIRCNetwork::IsChan(const CString& sChan) const {\n    if (sChan.empty()) return false;  // There is no way this is a chan\n    if (GetChanPrefixes().empty())\n        return true;  // We can't know, so we allow everything\n    // Thanks to the above if (empty), we can do sChan[0]\n    return GetChanPrefixes().find(sChan[0]) != CString::npos;\n}\n\n// Queries\n\nconst vector<CQuery*>& CIRCNetwork::GetQueries() const { return m_vQueries; }\n\nCQuery* CIRCNetwork::FindQuery(const CString& sName) const {\n    for (CQuery* pQuery : m_vQueries) {\n        if (sName.Equals(pQuery->GetName())) {\n            return pQuery;\n        }\n    }\n\n    return nullptr;\n}\n\nstd::vector<CQuery*> CIRCNetwork::FindQueries(const CString& sWild) const {\n    std::vector<CQuery*> vQueries;\n    vQueries.reserve(m_vQueries.size());\n    const CString sLower = sWild.AsLower();\n    for (CQuery* pQuery : m_vQueries) {\n        if (pQuery->GetName().AsLower().WildCmp(sLower))\n            vQueries.push_back(pQuery);\n    }\n    return vQueries;\n}\n\nCQuery* CIRCNetwork::AddQuery(const CString& sName) {\n    if (sName.empty()) {\n        return nullptr;\n    }\n\n    CQuery* pQuery = FindQuery(sName);\n    if (!pQuery) {\n        pQuery = new CQuery(sName, this);\n        m_vQueries.push_back(pQuery);\n\n        if (m_pUser->MaxQueryBuffers() > 0) {\n            while (m_vQueries.size() > m_pUser->MaxQueryBuffers()) {\n                delete *m_vQueries.begin();\n                m_vQueries.erase(m_vQueries.begin());\n            }\n        }\n    }\n\n    return pQuery;\n}\n\nbool CIRCNetwork::DelQuery(const CString& sName) {\n    for (vector<CQuery*>::iterator a = m_vQueries.begin();\n         a != m_vQueries.end(); ++a) {\n        if (sName.Equals((*a)->GetName())) {\n            delete *a;\n            m_vQueries.erase(a);\n            return true;\n        }\n    }\n\n    return false;\n}\n\n// Server list\n\nconst vector<CServer*>& CIRCNetwork::GetServers() const { return m_vServers; }\n\nCServer* CIRCNetwork::FindServer(const CString& sName) const {\n    for (CServer* pServer : m_vServers) {\n        if (sName.Equals(pServer->GetName())) {\n            return pServer;\n        }\n    }\n\n    return nullptr;\n}\n\nbool CIRCNetwork::DelServer(const CString& sName, unsigned short uPort,\n                            const CString& sPass) {\n    if (sName.empty()) {\n        return false;\n    }\n\n    unsigned int a = 0;\n    bool bSawCurrentServer = false;\n    CServer* pCurServer = GetCurrentServer();\n\n    for (vector<CServer*>::iterator it = m_vServers.begin();\n         it != m_vServers.end(); ++it, a++) {\n        CServer* pServer = *it;\n\n        if (pServer == pCurServer) bSawCurrentServer = true;\n\n        if (!pServer->GetName().Equals(sName)) continue;\n\n        if (uPort != 0 && pServer->GetPort() != uPort) continue;\n\n        if (!sPass.empty() && pServer->GetPass() != sPass) continue;\n\n        m_vServers.erase(it);\n\n        if (pServer == pCurServer) {\n            CIRCSock* pIRCSock = GetIRCSock();\n\n            // Make sure we don't skip the next server in the list!\n            if (m_uServerIdx) {\n                m_uServerIdx--;\n            }\n\n            if (pIRCSock) {\n                pIRCSock->Quit();\n                PutStatus(t_s(\"Your current server was removed, jumping...\"));\n            }\n        } else if (!bSawCurrentServer) {\n            // Our current server comes after the server which we\n            // are removing. This means that it now got a different\n            // index in m_vServers!\n            m_uServerIdx--;\n        }\n\n        delete pServer;\n\n        return true;\n    }\n\n    return false;\n}\n\nbool CIRCNetwork::AddServer(const CString& sName) {\n    if (sName.empty()) {\n        return false;\n    }\n\n    bool bSSL = false;\n    CString sLine = sName;\n    sLine.Trim();\n\n    CString sHost = sLine.Token(0);\n    CString sPort = sLine.Token(1);\n\n    if (sPort.TrimPrefix(\"+\")) {\n        bSSL = true;\n    }\n\n    unsigned short uPort = sPort.ToUShort();\n    CString sPass = sLine.Token(2, true);\n\n    return AddServer(sHost, uPort, sPass, bSSL);\n}\n\nbool CIRCNetwork::AddServer(const CString& sName, unsigned short uPort,\n                            const CString& sPass, bool bSSL) {\n#ifndef HAVE_LIBSSL\n    if (bSSL) {\n        return false;\n    }\n#endif\n\n    if (sName.empty()) {\n        return false;\n    }\n\n    if (!uPort) {\n        uPort = 6667;\n    }\n\n    // Check if server is already added\n    for (CServer* pServer : m_vServers) {\n        if (!sName.Equals(pServer->GetName())) continue;\n\n        if (uPort != pServer->GetPort()) continue;\n\n        if (sPass != pServer->GetPass()) continue;\n\n        if (bSSL != pServer->IsSSL()) continue;\n\n        // Server is already added\n        return false;\n    }\n\n    CServer* pServer = new CServer(sName, uPort, sPass, bSSL);\n    m_vServers.push_back(pServer);\n\n    CheckIRCConnect();\n\n    return true;\n}\n\nCServer* CIRCNetwork::GetNextServer(bool bAdvance) {\n    if (m_vServers.empty()) {\n        return nullptr;\n    }\n\n    if (m_uServerIdx >= m_vServers.size()) {\n        m_uServerIdx = 0;\n    }\n\n    if (bAdvance) {\n        return m_vServers[m_uServerIdx++];\n    } else {\n        return m_vServers[m_uServerIdx];\n    }\n}\n\nCServer* CIRCNetwork::GetCurrentServer() const {\n    size_t uIdx = (m_uServerIdx) ? m_uServerIdx - 1 : 0;\n\n    if (uIdx >= m_vServers.size()) {\n        return nullptr;\n    }\n\n    return m_vServers[uIdx];\n}\n\nvoid CIRCNetwork::SetIRCServer(const CString& s) { m_sIRCServer = s; }\n\nbool CIRCNetwork::SetNextServer(const CServer* pServer) {\n    for (unsigned int a = 0; a < m_vServers.size(); a++) {\n        if (m_vServers[a] == pServer) {\n            m_uServerIdx = a;\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool CIRCNetwork::IsLastServer() const {\n    return (m_uServerIdx >= m_vServers.size());\n}\n\nconst CString& CIRCNetwork::GetIRCServer() const { return m_sIRCServer; }\nconst CNick& CIRCNetwork::GetIRCNick() const { return m_IRCNick; }\n\nvoid CIRCNetwork::SetIRCNick(const CNick& n) {\n    m_IRCNick = n;\n\n    for (CClient* pClient : m_vClients) {\n        pClient->SetNick(n.GetNick());\n    }\n}\n\nCString CIRCNetwork::GetCurNick() const {\n    const CIRCSock* pIRCSock = GetIRCSock();\n\n    if (pIRCSock) {\n        return pIRCSock->GetNick();\n    }\n\n    if (!m_vClients.empty()) {\n        return m_vClients[0]->GetNick();\n    }\n\n    return \"\";\n}\n\nbool CIRCNetwork::Connect() {\n    if (!GetIRCConnectEnabled() || m_pIRCSock || !HasServers()) return false;\n\n    CServer* pServer = GetNextServer();\n    if (!pServer) return false;\n\n    if (CZNC::Get().GetServerThrottle(pServer->GetName())) {\n        // Can't connect right now, schedule retry later\n        CZNC::Get().AddNetworkToQueue(this);\n        return false;\n    }\n\n    CZNC::Get().AddServerThrottle(pServer->GetName());\n\n    bool bSSL = pServer->IsSSL();\n#ifndef HAVE_LIBSSL\n    if (bSSL) {\n        PutStatus(\n            t_f(\"Cannot connect to {1}, because ZNC is not compiled with SSL \"\n                \"support.\")(pServer->GetString(false)));\n        CZNC::Get().AddNetworkToQueue(this);\n        return false;\n    }\n#endif\n\n    CIRCSock* pIRCSock = new CIRCSock(this);\n    pIRCSock->SetPass(pServer->GetPass());\n    pIRCSock->SetSSLTrustedPeerFingerprints(m_ssTrustedFingerprints);\n    pIRCSock->SetTrustAllCerts(GetTrustAllCerts());\n    pIRCSock->SetTrustPKI(GetTrustPKI());\n\n    DEBUG(\"Connecting user/network [\" << m_pUser->GetUserName() << \"/\"\n                                      << m_sName << \"]\");\n\n    bool bAbort = false;\n    NETWORKMODULECALL(OnIRCConnecting(pIRCSock), m_pUser, this, nullptr,\n                      &bAbort);\n    if (bAbort) {\n        DEBUG(\"Some module aborted the connection attempt\");\n        PutStatus(t_s(\"Some module aborted the connection attempt\"));\n        delete pIRCSock;\n        CZNC::Get().AddNetworkToQueue(this);\n        return false;\n    }\n\n    CString sSockName = \"IRC::\" + m_pUser->GetUserName() + \"::\" + m_sName;\n    CZNC::Get().GetManager().Connect(pServer->GetName(), pServer->GetPort(),\n                                     sSockName, 120, bSSL, GetBindHost(),\n                                     pIRCSock);\n\n    return true;\n}\n\nbool CIRCNetwork::IsIRCConnected() const {\n    const CIRCSock* pSock = GetIRCSock();\n    return (pSock && pSock->IsAuthed());\n}\n\nvoid CIRCNetwork::SetIRCSocket(CIRCSock* pIRCSock) { m_pIRCSock = pIRCSock; }\n\nvoid CIRCNetwork::IRCConnected() {\n    const SCString& ssCaps = m_pIRCSock->GetAcceptedCaps();\n    for (CClient* pClient : m_vClients) {\n        pClient->NotifyServerDependentCaps(ssCaps);\n    }\n    if (m_uJoinDelay > 0) {\n        m_pJoinTimer->Delay(m_uJoinDelay);\n    } else {\n        JoinChans();\n    }\n}\n\nvoid CIRCNetwork::IRCDisconnected() {\n    for (CClient* pClient : m_vClients) {\n        pClient->ClearServerDependentCaps();\n    }\n    m_pIRCSock = nullptr;\n\n    SetIRCServer(\"\");\n    m_bIRCAway = false;\n\n    // Get the reconnect going\n    CheckIRCConnect();\n}\n\nvoid CIRCNetwork::SetIRCConnectEnabled(bool b) {\n    m_bIRCConnectEnabled = b;\n\n    if (m_bIRCConnectEnabled) {\n        CheckIRCConnect();\n    } else if (GetIRCSock()) {\n        if (GetIRCSock()->IsConnected()) {\n            GetIRCSock()->Quit();\n        } else {\n            GetIRCSock()->Close();\n        }\n    }\n}\n\nvoid CIRCNetwork::CheckIRCConnect() {\n    // Do we want to connect?\n    if (GetIRCConnectEnabled() && GetIRCSock() == nullptr)\n        CZNC::Get().AddNetworkToQueue(this);\n}\n\nbool CIRCNetwork::PutIRC(const CString& sLine) {\n    CIRCSock* pIRCSock = GetIRCSock();\n\n    if (!pIRCSock) {\n        return false;\n    }\n\n    pIRCSock->PutIRC(sLine);\n    return true;\n}\n\nbool CIRCNetwork::PutIRC(const CMessage& Message) {\n    CIRCSock* pIRCSock = GetIRCSock();\n\n    if (!pIRCSock) {\n        return false;\n    }\n\n    pIRCSock->PutIRC(Message);\n    return true;\n}\n\nvoid CIRCNetwork::ClearQueryBuffer() {\n    std::for_each(m_vQueries.begin(), m_vQueries.end(),\n                  std::default_delete<CQuery>());\n    m_vQueries.clear();\n}\n\nconst CString& CIRCNetwork::GetNick(const bool bAllowDefault) const {\n    if (m_sNick.empty()) {\n        return m_pUser->GetNick(bAllowDefault);\n    }\n\n    return m_sNick;\n}\n\nconst CString& CIRCNetwork::GetAltNick(const bool bAllowDefault) const {\n    if (m_sAltNick.empty()) {\n        return m_pUser->GetAltNick(bAllowDefault);\n    }\n\n    return m_sAltNick;\n}\n\nconst CString& CIRCNetwork::GetIdent(const bool bAllowDefault) const {\n    if (m_sIdent.empty()) {\n        return m_pUser->GetIdent(bAllowDefault);\n    }\n\n    return m_sIdent;\n}\n\nCString CIRCNetwork::GetRealName() const {\n    if (m_sRealName.empty()) {\n        return m_pUser->GetRealName();\n    }\n\n    return m_sRealName;\n}\n\nconst CString& CIRCNetwork::GetBindHost() const {\n    if (m_sBindHost.empty()) {\n        return m_pUser->GetBindHost();\n    }\n\n    return m_sBindHost;\n}\n\nconst CString& CIRCNetwork::GetEncoding() const { return m_sEncoding; }\n\nCString CIRCNetwork::GetQuitMsg() const {\n    if (m_sQuitMsg.empty()) {\n        return m_pUser->GetQuitMsg();\n    }\n\n    return m_sQuitMsg;\n}\n\nvoid CIRCNetwork::SetNick(const CString& s) {\n    if (m_pUser->GetNick().Equals(s)) {\n        m_sNick = \"\";\n    } else {\n        m_sNick = s;\n    }\n}\n\nvoid CIRCNetwork::SetAltNick(const CString& s) {\n    if (m_pUser->GetAltNick().Equals(s)) {\n        m_sAltNick = \"\";\n    } else {\n        m_sAltNick = s;\n    }\n}\n\nvoid CIRCNetwork::SetIdent(const CString& s) {\n    if (m_pUser->GetIdent().Equals(s)) {\n        m_sIdent = \"\";\n    } else {\n        m_sIdent = s;\n    }\n}\n\nvoid CIRCNetwork::SetRealName(const CString& s) {\n    if (m_pUser->GetRealName().Equals(s)) {\n        m_sRealName = \"\";\n    } else {\n        m_sRealName = s;\n    }\n}\n\nvoid CIRCNetwork::SetBindHost(const CString& s) {\n    if (m_pUser->GetBindHost().Equals(s)) {\n        m_sBindHost = \"\";\n    } else {\n        m_sBindHost = s;\n    }\n}\n\nvoid CIRCNetwork::SetEncoding(const CString& s) {\n    m_sEncoding = CZNC::Get().FixupEncoding(s);\n    if (GetIRCSock()) {\n        GetIRCSock()->SetEncoding(m_sEncoding);\n    }\n}\n\nvoid CIRCNetwork::SetQuitMsg(const CString& s) {\n    if (m_pUser->GetQuitMsg().Equals(s)) {\n        m_sQuitMsg = \"\";\n    } else {\n        m_sQuitMsg = s;\n    }\n}\n\nCString CIRCNetwork::ExpandString(const CString& sStr) const {\n    CString sRet;\n    return ExpandString(sStr, sRet);\n}\n\nCString& CIRCNetwork::ExpandString(const CString& sStr, CString& sRet) const {\n    sRet = sStr;\n\n    sRet.Replace(\"%altnick%\", GetAltNick());\n    sRet.Replace(\"%bindhost%\", GetBindHost());\n    sRet.Replace(\"%defnick%\", GetNick());\n    sRet.Replace(\"%ident%\", GetIdent());\n    sRet.Replace(\"%network%\", GetName());\n    sRet.Replace(\"%nick%\", GetCurNick());\n    sRet.Replace(\"%realname%\", GetRealName());\n\n    return m_pUser->ExpandString(sRet, sRet);\n}\n\nbool CIRCNetwork::LoadModule(const CString& sModName, const CString& sArgs,\n                             const CString& sNotice, CString& sError) {\n    CUtils::PrintAction(sNotice);\n    CString sModRet;\n\n    bool bModRet = GetModules().LoadModule(\n        sModName, sArgs, CModInfo::NetworkModule, GetUser(), this, sModRet);\n\n    CUtils::PrintStatus(bModRet, sModRet);\n    if (!bModRet) {\n        sError = sModRet;\n    }\n    return bModRet;\n}\n", "/*\n * Copyright (C) 2004-2018 ZNC, see the NOTICE file for details.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <znc/User.h>\n#include <znc/Config.h>\n#include <znc/FileUtils.h>\n#include <znc/IRCNetwork.h>\n#include <znc/IRCSock.h>\n#include <znc/Chan.h>\n#include <znc/Query.h>\n#include <math.h>\n#include <time.h>\n#include <algorithm>\n\nusing std::vector;\nusing std::set;\n\nclass CUserTimer : public CCron {\n  public:\n    CUserTimer(CUser* pUser) : CCron(), m_pUser(pUser) {\n        SetName(\"CUserTimer::\" + m_pUser->GetUserName());\n        Start(m_pUser->GetPingSlack());\n    }\n    ~CUserTimer() override {}\n\n    CUserTimer(const CUserTimer&) = delete;\n    CUserTimer& operator=(const CUserTimer&) = delete;\n\n  private:\n  protected:\n    void RunJob() override {\n        const vector<CClient*>& vUserClients = m_pUser->GetUserClients();\n\n        for (CClient* pUserClient : vUserClients) {\n            if (pUserClient->GetTimeSinceLastDataTransaction() >=\n                m_pUser->GetPingFrequency()) {\n                pUserClient->PutClient(\"PING :ZNC\");\n            }\n        }\n\n        // Restart timer for the case if the period had changed. Usually this is\n        // noop\n        Start(m_pUser->GetPingSlack());\n    }\n\n    CUser* m_pUser;\n};\n\nCUser::CUser(const CString& sUserName)\n    : m_sUserName(sUserName),\n      m_sCleanUserName(MakeCleanUserName(sUserName)),\n      m_sNick(m_sCleanUserName),\n      m_sAltNick(\"\"),\n      m_sIdent(m_sCleanUserName),\n      m_sRealName(\"\"),\n      m_sBindHost(\"\"),\n      m_sDCCBindHost(\"\"),\n      m_sPass(\"\"),\n      m_sPassSalt(\"\"),\n      m_sStatusPrefix(\"*\"),\n      m_sDefaultChanModes(\"\"),\n      m_sClientEncoding(\"\"),\n      m_sQuitMsg(\"\"),\n      m_mssCTCPReplies(),\n      m_sTimestampFormat(\"[%H:%M:%S]\"),\n      m_sTimezone(\"\"),\n      m_eHashType(HASH_NONE),\n      m_sUserPath(CZNC::Get().GetUserPath() + \"/\" + sUserName),\n      m_bMultiClients(true),\n      m_bDenyLoadMod(false),\n      m_bAdmin(false),\n      m_bDenySetBindHost(false),\n      m_bAutoClearChanBuffer(true),\n      m_bAutoClearQueryBuffer(true),\n      m_bBeingDeleted(false),\n      m_bAppendTimestamp(false),\n      m_bPrependTimestamp(true),\n      m_bAuthOnlyViaModule(false),\n      m_pUserTimer(nullptr),\n      m_vIRCNetworks(),\n      m_vClients(),\n      m_ssAllowedHosts(),\n      m_uChanBufferSize(50),\n      m_uQueryBufferSize(50),\n      m_uBytesRead(0),\n      m_uBytesWritten(0),\n      m_uMaxJoinTries(10),\n      m_uMaxNetworks(1),\n      m_uMaxQueryBuffers(50),\n      m_uMaxJoins(0),\n      m_uNoTrafficTimeout(180),\n      m_sSkinName(\"\"),\n      m_pModules(new CModules) {\n    m_pUserTimer = new CUserTimer(this);\n    CZNC::Get().GetManager().AddCron(m_pUserTimer);\n}\n\nCUser::~CUser() {\n    // Delete networks\n    while (!m_vIRCNetworks.empty()) {\n        delete *m_vIRCNetworks.begin();\n    }\n\n    // Delete clients\n    while (!m_vClients.empty()) {\n        CZNC::Get().GetManager().DelSockByAddr(m_vClients[0]);\n    }\n    m_vClients.clear();\n\n    // Delete modules (unloads all modules!)\n    delete m_pModules;\n    m_pModules = nullptr;\n\n    CZNC::Get().GetManager().DelCronByAddr(m_pUserTimer);\n\n    CZNC::Get().AddBytesRead(m_uBytesRead);\n    CZNC::Get().AddBytesWritten(m_uBytesWritten);\n}\n\ntemplate <class T>\nstruct TOption {\n    const char* name;\n    void (CUser::*pSetter)(T);\n};\n\nbool CUser::ParseConfig(CConfig* pConfig, CString& sError) {\n    TOption<const CString&> StringOptions[] = {\n        {\"nick\", &CUser::SetNick},\n        {\"quitmsg\", &CUser::SetQuitMsg},\n        {\"altnick\", &CUser::SetAltNick},\n        {\"ident\", &CUser::SetIdent},\n        {\"realname\", &CUser::SetRealName},\n        {\"chanmodes\", &CUser::SetDefaultChanModes},\n        {\"bindhost\", &CUser::SetBindHost},\n        {\"vhost\", &CUser::SetBindHost},\n        {\"dccbindhost\", &CUser::SetDCCBindHost},\n        {\"dccvhost\", &CUser::SetDCCBindHost},\n        {\"timestampformat\", &CUser::SetTimestampFormat},\n        {\"skin\", &CUser::SetSkinName},\n        {\"clientencoding\", &CUser::SetClientEncoding},\n    };\n    TOption<unsigned int> UIntOptions[] = {\n        {\"jointries\", &CUser::SetJoinTries},\n        {\"maxnetworks\", &CUser::SetMaxNetworks},\n        {\"maxquerybuffers\", &CUser::SetMaxQueryBuffers},\n        {\"maxjoins\", &CUser::SetMaxJoins},\n        {\"notraffictimeout\", &CUser::SetNoTrafficTimeout},\n    };\n    TOption<bool> BoolOptions[] = {\n        {\"keepbuffer\",\n         &CUser::SetKeepBuffer},  // XXX compatibility crap from pre-0.207\n        {\"autoclearchanbuffer\", &CUser::SetAutoClearChanBuffer},\n        {\"autoclearquerybuffer\", &CUser::SetAutoClearQueryBuffer},\n        {\"multiclients\", &CUser::SetMultiClients},\n        {\"denyloadmod\", &CUser::SetDenyLoadMod},\n        {\"admin\", &CUser::SetAdmin},\n        {\"denysetbindhost\", &CUser::SetDenySetBindHost},\n        {\"denysetvhost\", &CUser::SetDenySetBindHost},\n        {\"appendtimestamp\", &CUser::SetTimestampAppend},\n        {\"prependtimestamp\", &CUser::SetTimestampPrepend},\n        {\"authonlyviamodule\", &CUser::SetAuthOnlyViaModule},\n    };\n\n    for (const auto& Option : StringOptions) {\n        CString sValue;\n        if (pConfig->FindStringEntry(Option.name, sValue))\n            (this->*Option.pSetter)(sValue);\n    }\n    for (const auto& Option : UIntOptions) {\n        CString sValue;\n        if (pConfig->FindStringEntry(Option.name, sValue))\n            (this->*Option.pSetter)(sValue.ToUInt());\n    }\n    for (const auto& Option : BoolOptions) {\n        CString sValue;\n        if (pConfig->FindStringEntry(Option.name, sValue))\n            (this->*Option.pSetter)(sValue.ToBool());\n    }\n\n    VCString vsList;\n    pConfig->FindStringVector(\"allow\", vsList);\n    for (const CString& sHost : vsList) {\n        AddAllowedHost(sHost);\n    }\n    pConfig->FindStringVector(\"ctcpreply\", vsList);\n    for (const CString& sReply : vsList) {\n        AddCTCPReply(sReply.Token(0), sReply.Token(1, true));\n    }\n\n    CString sValue;\n\n    CString sDCCLookupValue;\n    pConfig->FindStringEntry(\"dcclookupmethod\", sDCCLookupValue);\n    if (pConfig->FindStringEntry(\"bouncedccs\", sValue)) {\n        if (sValue.ToBool()) {\n            CUtils::PrintAction(\"Loading Module [bouncedcc]\");\n            CString sModRet;\n            bool bModRet = GetModules().LoadModule(\n                \"bouncedcc\", \"\", CModInfo::UserModule, this, nullptr, sModRet);\n\n            CUtils::PrintStatus(bModRet, sModRet);\n            if (!bModRet) {\n                sError = sModRet;\n                return false;\n            }\n\n            if (sDCCLookupValue.Equals(\"Client\")) {\n                GetModules().FindModule(\"bouncedcc\")->SetNV(\"UseClientIP\", \"1\");\n            }\n        }\n    }\n    if (pConfig->FindStringEntry(\"buffer\", sValue))\n        SetBufferCount(sValue.ToUInt(), true);\n    if (pConfig->FindStringEntry(\"chanbuffersize\", sValue))\n        SetChanBufferSize(sValue.ToUInt(), true);\n    if (pConfig->FindStringEntry(\"querybuffersize\", sValue))\n        SetQueryBufferSize(sValue.ToUInt(), true);\n    if (pConfig->FindStringEntry(\"awaysuffix\", sValue)) {\n        CUtils::PrintMessage(\n            \"WARNING: AwaySuffix has been deprecated, instead try -> \"\n            \"LoadModule = awaynick %nick%_\" +\n            sValue);\n    }\n    if (pConfig->FindStringEntry(\"autocycle\", sValue)) {\n        if (sValue.Equals(\"true\"))\n            CUtils::PrintError(\n                \"WARNING: AutoCycle has been removed, instead try -> \"\n                \"LoadModule = autocycle\");\n    }\n    if (pConfig->FindStringEntry(\"keepnick\", sValue)) {\n        if (sValue.Equals(\"true\"))\n            CUtils::PrintError(\n                \"WARNING: KeepNick has been deprecated, instead try -> \"\n                \"LoadModule = keepnick\");\n    }\n    if (pConfig->FindStringEntry(\"statusprefix\", sValue)) {\n        if (!SetStatusPrefix(sValue)) {\n            sError = \"Invalid StatusPrefix [\" + sValue +\n                     \"] Must be 1-5 chars, no spaces.\";\n            CUtils::PrintError(sError);\n            return false;\n        }\n    }\n    if (pConfig->FindStringEntry(\"timezone\", sValue)) {\n        SetTimezone(sValue);\n    }\n    if (pConfig->FindStringEntry(\"timezoneoffset\", sValue)) {\n        if (fabs(sValue.ToDouble()) > 0.1) {\n            CUtils::PrintError(\n                \"WARNING: TimezoneOffset has been deprecated, now you can set \"\n                \"your timezone by name\");\n        }\n    }\n    if (pConfig->FindStringEntry(\"timestamp\", sValue)) {\n        if (!sValue.Trim_n().Equals(\"true\")) {\n            if (sValue.Trim_n().Equals(\"append\")) {\n                SetTimestampAppend(true);\n                SetTimestampPrepend(false);\n            } else if (sValue.Trim_n().Equals(\"prepend\")) {\n                SetTimestampAppend(false);\n                SetTimestampPrepend(true);\n            } else if (sValue.Trim_n().Equals(\"false\")) {\n                SetTimestampAppend(false);\n                SetTimestampPrepend(false);\n            } else {\n                SetTimestampFormat(sValue);\n            }\n        }\n    }\n    if (pConfig->FindStringEntry(\"language\", sValue)) {\n        SetLanguage(sValue);\n    }\n    pConfig->FindStringEntry(\"pass\", sValue);\n    // There are different formats for this available:\n    // Pass = <plain text>\n    // Pass = <md5 hash> -\n    // Pass = plain#<plain text>\n    // Pass = <hash name>#<hash>\n    // Pass = <hash name>#<salted hash>#<salt>#\n    // 'Salted hash' means hash of 'password' + 'salt'\n    // Possible hashes are md5 and sha256\n    if (sValue.TrimSuffix(\"-\")) {\n        SetPass(sValue.Trim_n(), CUser::HASH_MD5);\n    } else {\n        CString sMethod = sValue.Token(0, false, \"#\");\n        CString sPass = sValue.Token(1, true, \"#\");\n        if (sMethod == \"md5\" || sMethod == \"sha256\") {\n            CUser::eHashType type = CUser::HASH_MD5;\n            if (sMethod == \"sha256\") type = CUser::HASH_SHA256;\n\n            CString sSalt = sPass.Token(1, false, \"#\");\n            sPass = sPass.Token(0, false, \"#\");\n            SetPass(sPass, type, sSalt);\n        } else if (sMethod == \"plain\") {\n            SetPass(sPass, CUser::HASH_NONE);\n        } else {\n            SetPass(sValue, CUser::HASH_NONE);\n        }\n    }\n    CConfig::SubConfig subConf;\n    CConfig::SubConfig::const_iterator subIt;\n    pConfig->FindSubConfig(\"pass\", subConf);\n    if (!sValue.empty() && !subConf.empty()) {\n        sError = \"Password defined more than once\";\n        CUtils::PrintError(sError);\n        return false;\n    }\n    subIt = subConf.begin();\n    if (subIt != subConf.end()) {\n        CConfig* pSubConf = subIt->second.m_pSubConfig;\n        CString sHash;\n        CString sMethod;\n        CString sSalt;\n        CUser::eHashType method;\n        pSubConf->FindStringEntry(\"hash\", sHash);\n        pSubConf->FindStringEntry(\"method\", sMethod);\n        pSubConf->FindStringEntry(\"salt\", sSalt);\n        if (sMethod.empty() || sMethod.Equals(\"plain\"))\n            method = CUser::HASH_NONE;\n        else if (sMethod.Equals(\"md5\"))\n            method = CUser::HASH_MD5;\n        else if (sMethod.Equals(\"sha256\"))\n            method = CUser::HASH_SHA256;\n        else {\n            sError = \"Invalid hash method\";\n            CUtils::PrintError(sError);\n            return false;\n        }\n\n        SetPass(sHash, method, sSalt);\n        if (!pSubConf->empty()) {\n            sError = \"Unhandled lines in config!\";\n            CUtils::PrintError(sError);\n\n            CZNC::DumpConfig(pSubConf);\n            return false;\n        }\n        ++subIt;\n    }\n    if (subIt != subConf.end()) {\n        sError = \"Password defined more than once\";\n        CUtils::PrintError(sError);\n        return false;\n    }\n\n    pConfig->FindSubConfig(\"network\", subConf);\n    for (subIt = subConf.begin(); subIt != subConf.end(); ++subIt) {\n        const CString& sNetworkName = subIt->first;\n\n        CUtils::PrintMessage(\"Loading network [\" + sNetworkName + \"]\");\n\n        CIRCNetwork* pNetwork = FindNetwork(sNetworkName);\n\n        if (!pNetwork) {\n            pNetwork = new CIRCNetwork(this, sNetworkName);\n        }\n\n        if (!pNetwork->ParseConfig(subIt->second.m_pSubConfig, sError)) {\n            return false;\n        }\n    }\n\n    if (pConfig->FindStringVector(\"server\", vsList, false) ||\n        pConfig->FindStringVector(\"chan\", vsList, false) ||\n        pConfig->FindSubConfig(\"chan\", subConf, false)) {\n        CIRCNetwork* pNetwork = FindNetwork(\"default\");\n        if (!pNetwork) {\n            CString sErrorDummy;\n            pNetwork = AddNetwork(\"default\", sErrorDummy);\n        }\n\n        if (pNetwork) {\n            CUtils::PrintMessage(\n                \"NOTICE: Found deprecated config, upgrading to a network\");\n\n            if (!pNetwork->ParseConfig(pConfig, sError, true)) {\n                return false;\n            }\n        }\n    }\n\n    pConfig->FindStringVector(\"loadmodule\", vsList);\n    for (const CString& sMod : vsList) {\n        CString sModName = sMod.Token(0);\n        CString sNotice = \"Loading user module [\" + sModName + \"]\";\n\n        // XXX Legacy crap, added in ZNC 0.089\n        if (sModName == \"discon_kick\") {\n            sNotice =\n                \"NOTICE: [discon_kick] was renamed, loading [disconkick] \"\n                \"instead\";\n            sModName = \"disconkick\";\n        }\n\n        // XXX Legacy crap, added in ZNC 0.099\n        if (sModName == \"fixfreenode\") {\n            sNotice =\n                \"NOTICE: [fixfreenode] doesn't do anything useful anymore, \"\n                \"ignoring it\";\n            CUtils::PrintMessage(sNotice);\n            continue;\n        }\n\n        // XXX Legacy crap, added in ZNC 0.207\n        if (sModName == \"admin\") {\n            sNotice =\n                \"NOTICE: [admin] module was renamed, loading [controlpanel] \"\n                \"instead\";\n            sModName = \"controlpanel\";\n        }\n\n        // XXX Legacy crap, should have been added ZNC 0.207, but added only in\n        // 1.1 :(\n        if (sModName == \"away\") {\n            sNotice = \"NOTICE: [away] was renamed, loading [awaystore] instead\";\n            sModName = \"awaystore\";\n        }\n\n        // XXX Legacy crap, added in 1.1; fakeonline module was dropped in 1.0\n        // and returned in 1.1\n        if (sModName == \"fakeonline\") {\n            sNotice =\n                \"NOTICE: [fakeonline] was renamed, loading [modules_online] \"\n                \"instead\";\n            sModName = \"modules_online\";\n        }\n\n        // XXX Legacy crap, added in 1.3\n        if (sModName == \"charset\") {\n            CUtils::PrintAction(\n                \"NOTICE: Charset support was moved to core, importing old \"\n                \"charset module settings\");\n            size_t uIndex = 1;\n            if (sMod.Token(uIndex).Equals(\"-force\")) {\n                uIndex++;\n            }\n            VCString vsClient, vsServer;\n            sMod.Token(uIndex).Split(\",\", vsClient);\n            sMod.Token(uIndex + 1).Split(\",\", vsServer);\n            if (vsClient.empty() || vsServer.empty()) {\n                CUtils::PrintStatus(\n                    false, \"charset module was loaded with wrong parameters.\");\n                continue;\n            }\n            SetClientEncoding(vsClient[0]);\n            for (CIRCNetwork* pNetwork : m_vIRCNetworks) {\n                pNetwork->SetEncoding(vsServer[0]);\n            }\n            CUtils::PrintStatus(true, \"Using [\" + vsClient[0] +\n                                          \"] for clients, and [\" + vsServer[0] +\n                                          \"] for servers\");\n            continue;\n        }\n\n        CString sModRet;\n        CString sArgs = sMod.Token(1, true);\n\n        bool bModRet = LoadModule(sModName, sArgs, sNotice, sModRet);\n\n        CUtils::PrintStatus(bModRet, sModRet);\n        if (!bModRet) {\n            // XXX The awaynick module was retired in 1.6 (still available as\n            // external module)\n            if (sModName == \"awaynick\") {\n                // load simple_away instead, unless it's already on the list\n                if (std::find(vsList.begin(), vsList.end(), \"simple_away\") ==\n                    vsList.end()) {\n                    sNotice = \"Loading [simple_away] module instead\";\n                    sModName = \"simple_away\";\n                    // not a fatal error if simple_away is not available\n                    LoadModule(sModName, sArgs, sNotice, sModRet);\n                }\n            } else {\n                sError = sModRet;\n                return false;\n            }\n        }\n        continue;\n    }\n\n    // Move ircconnectenabled to the networks\n    if (pConfig->FindStringEntry(\"ircconnectenabled\", sValue)) {\n        for (CIRCNetwork* pNetwork : m_vIRCNetworks) {\n            pNetwork->SetIRCConnectEnabled(sValue.ToBool());\n        }\n    }\n\n    return true;\n}\n\nCIRCNetwork* CUser::AddNetwork(const CString& sNetwork, CString& sErrorRet) {\n    if (!CIRCNetwork::IsValidNetwork(sNetwork)) {\n        sErrorRet =\n            t_s(\"Invalid network name. It should be alphanumeric. Not to be \"\n                \"confused with server name\");\n        return nullptr;\n    } else if (FindNetwork(sNetwork)) {\n        sErrorRet = t_f(\"Network {1} already exists\")(sNetwork);\n        return nullptr;\n    }\n\n    CIRCNetwork* pNetwork = new CIRCNetwork(this, sNetwork);\n\n    bool bCancel = false;\n    USERMODULECALL(OnAddNetwork(*pNetwork, sErrorRet), this, nullptr, &bCancel);\n    if (bCancel) {\n        RemoveNetwork(pNetwork);\n        delete pNetwork;\n        return nullptr;\n    }\n\n    return pNetwork;\n}\n\nbool CUser::AddNetwork(CIRCNetwork* pNetwork) {\n    if (FindNetwork(pNetwork->GetName())) {\n        return false;\n    }\n\n    m_vIRCNetworks.push_back(pNetwork);\n\n    return true;\n}\n\nvoid CUser::RemoveNetwork(CIRCNetwork* pNetwork) {\n    auto it = std::find(m_vIRCNetworks.begin(), m_vIRCNetworks.end(), pNetwork);\n    if (it != m_vIRCNetworks.end()) {\n        m_vIRCNetworks.erase(it);\n    }\n}\n\nbool CUser::DeleteNetwork(const CString& sNetwork) {\n    CIRCNetwork* pNetwork = FindNetwork(sNetwork);\n\n    if (pNetwork) {\n        bool bCancel = false;\n        USERMODULECALL(OnDeleteNetwork(*pNetwork), this, nullptr, &bCancel);\n        if (!bCancel) {\n            delete pNetwork;\n            return true;\n        }\n    }\n\n    return false;\n}\n\nCIRCNetwork* CUser::FindNetwork(const CString& sNetwork) const {\n    for (CIRCNetwork* pNetwork : m_vIRCNetworks) {\n        if (pNetwork->GetName().Equals(sNetwork)) {\n            return pNetwork;\n        }\n    }\n\n    return nullptr;\n}\n\nconst vector<CIRCNetwork*>& CUser::GetNetworks() const {\n    return m_vIRCNetworks;\n}\n\nCString CUser::ExpandString(const CString& sStr) const {\n    CString sRet;\n    return ExpandString(sStr, sRet);\n}\n\nCString& CUser::ExpandString(const CString& sStr, CString& sRet) const {\n    CString sTime = CUtils::CTime(time(nullptr), m_sTimezone);\n\n    sRet = sStr;\n    sRet.Replace(\"%altnick%\", GetAltNick());\n    sRet.Replace(\"%bindhost%\", GetBindHost());\n    sRet.Replace(\"%defnick%\", GetNick());\n    sRet.Replace(\"%ident%\", GetIdent());\n    sRet.Replace(\"%nick%\", GetNick());\n    sRet.Replace(\"%realname%\", GetRealName());\n    sRet.Replace(\"%time%\", sTime);\n    sRet.Replace(\"%uptime%\", CZNC::Get().GetUptime());\n    sRet.Replace(\"%user%\", GetUserName());\n    sRet.Replace(\"%version%\", CZNC::GetVersion());\n    sRet.Replace(\"%vhost%\", GetBindHost());\n    sRet.Replace(\"%znc%\", CZNC::GetTag(false));\n\n    // Allows for escaping ExpandString if necessary, or to prevent\n    // defaults from kicking in if you don't want them.\n    sRet.Replace(\"%empty%\", \"\");\n    // The following lines do not exist. You must be on DrUgS!\n    sRet.Replace(\"%irc%\", \"All your IRC are belong to ZNC\");\n    // Chosen by fair zocchihedron dice roll by SilverLeo\n    sRet.Replace(\"%rand%\", \"42\");\n\n    return sRet;\n}\n\nCString CUser::AddTimestamp(const CString& sStr) const {\n    timeval tv;\n    gettimeofday(&tv, nullptr);\n    return AddTimestamp(tv, sStr);\n}\n\nCString CUser::AddTimestamp(time_t tm, const CString& sStr) const {\n    timeval tv;\n    tv.tv_sec = tm;\n    tv.tv_usec = 0;\n    return AddTimestamp(tv, sStr);\n}\n\nCString CUser::AddTimestamp(timeval tv, const CString& sStr) const {\n    CString sRet = sStr;\n\n    if (!GetTimestampFormat().empty() &&\n        (m_bAppendTimestamp || m_bPrependTimestamp)) {\n        CString sTimestamp =\n            CUtils::FormatTime(tv, GetTimestampFormat(), m_sTimezone);\n        if (sTimestamp.empty()) {\n            return sRet;\n        }\n\n        if (m_bPrependTimestamp) {\n            sRet = sTimestamp;\n            sRet += \" \" + sStr;\n        }\n        if (m_bAppendTimestamp) {\n            // From http://www.mirc.com/colors.html\n            // The Control+O key combination in mIRC inserts ascii character 15,\n            // which turns off all previous attributes, including color, bold,\n            // underline, and italics.\n            //\n            // \\x02 bold\n            // \\x03 mIRC-compatible color\n            // \\x04 RRGGBB color\n            // \\x0F normal/reset (turn off bold, colors, etc.)\n            // \\x12 reverse (weechat)\n            // \\x16 reverse (mirc, kvirc)\n            // \\x1D italic\n            // \\x1F underline\n            // Also see http://www.visualirc.net/tech-attrs.php\n            //\n            // Keep in sync with CIRCSocket::IcuExt__UCallback\n            if (CString::npos !=\n                sRet.find_first_of(\"\\x02\\x03\\x04\\x0F\\x12\\x16\\x1D\\x1F\")) {\n                sRet += \"\\x0F\";\n            }\n\n            sRet += \" \" + sTimestamp;\n        }\n    }\n\n    return sRet;\n}\n\nvoid CUser::BounceAllClients() {\n    for (CClient* pClient : m_vClients) {\n        pClient->BouncedOff();\n    }\n\n    m_vClients.clear();\n}\n\nvoid CUser::UserConnected(CClient* pClient) {\n    if (!MultiClients()) {\n        BounceAllClients();\n    }\n\n    pClient->PutClient(\":irc.znc.in 001 \" + pClient->GetNick() + \" :\" +\n                       t_s(\"Welcome to ZNC\"));\n\n    m_vClients.push_back(pClient);\n}\n\nvoid CUser::UserDisconnected(CClient* pClient) {\n    auto it = std::find(m_vClients.begin(), m_vClients.end(), pClient);\n    if (it != m_vClients.end()) {\n        m_vClients.erase(it);\n    }\n}\n\nvoid CUser::CloneNetworks(const CUser& User) {\n    const vector<CIRCNetwork*>& vNetworks = User.GetNetworks();\n    for (CIRCNetwork* pUserNetwork : vNetworks) {\n        CIRCNetwork* pNetwork = FindNetwork(pUserNetwork->GetName());\n\n        if (pNetwork) {\n            pNetwork->Clone(*pUserNetwork);\n        } else {\n            new CIRCNetwork(this, *pUserNetwork);\n        }\n    }\n\n    set<CString> ssDeleteNetworks;\n    for (CIRCNetwork* pNetwork : m_vIRCNetworks) {\n        if (!(User.FindNetwork(pNetwork->GetName()))) {\n            ssDeleteNetworks.insert(pNetwork->GetName());\n        }\n    }\n\n    for (const CString& sNetwork : ssDeleteNetworks) {\n        // The following will move all the clients to the user.\n        // So the clients are not disconnected. The client could\n        // have requested the rehash. Then when we do\n        // client->PutStatus(\"Rehashing succeeded!\") we would\n        // crash if there was no client anymore.\n        const vector<CClient*>& vClients = FindNetwork(sNetwork)->GetClients();\n\n        while (vClients.begin() != vClients.end()) {\n            CClient* pClient = vClients.front();\n            // This line will remove pClient from vClients,\n            // because it's a reference to the internal Network's vector.\n            pClient->SetNetwork(nullptr);\n        }\n\n        DeleteNetwork(sNetwork);\n    }\n}\n\nbool CUser::Clone(const CUser& User, CString& sErrorRet, bool bCloneNetworks) {\n    sErrorRet.clear();\n\n    if (!User.IsValid(sErrorRet, true)) {\n        return false;\n    }\n\n    // user names can only specified for the constructor, changing it later\n    // on breaks too much stuff (e.g. lots of paths depend on the user name)\n    if (GetUserName() != User.GetUserName()) {\n        DEBUG(\"Ignoring username in CUser::Clone(), old username [\"\n              << GetUserName() << \"]; New username [\" << User.GetUserName()\n              << \"]\");\n    }\n\n    if (!User.GetPass().empty()) {\n        SetPass(User.GetPass(), User.GetPassHashType(), User.GetPassSalt());\n    }\n\n    SetNick(User.GetNick(false));\n    SetAltNick(User.GetAltNick(false));\n    SetIdent(User.GetIdent(false));\n    SetRealName(User.GetRealName());\n    SetStatusPrefix(User.GetStatusPrefix());\n    SetBindHost(User.GetBindHost());\n    SetDCCBindHost(User.GetDCCBindHost());\n    SetQuitMsg(User.GetQuitMsg());\n    SetSkinName(User.GetSkinName());\n    SetDefaultChanModes(User.GetDefaultChanModes());\n    SetChanBufferSize(User.GetChanBufferSize(), true);\n    SetQueryBufferSize(User.GetQueryBufferSize(), true);\n    SetJoinTries(User.JoinTries());\n    SetMaxNetworks(User.MaxNetworks());\n    SetMaxQueryBuffers(User.MaxQueryBuffers());\n    SetMaxJoins(User.MaxJoins());\n    SetNoTrafficTimeout(User.GetNoTrafficTimeout());\n    SetClientEncoding(User.GetClientEncoding());\n    SetLanguage(User.GetLanguage());\n\n    // Allowed Hosts\n    m_ssAllowedHosts.clear();\n    const set<CString>& ssHosts = User.GetAllowedHosts();\n    for (const CString& sHost : ssHosts) {\n        AddAllowedHost(sHost);\n    }\n\n    for (CClient* pSock : m_vClients) {\n        if (!IsHostAllowed(pSock->GetRemoteIP())) {\n            pSock->PutStatusNotice(\n                t_s(\"You are being disconnected because your IP is no longer \"\n                    \"allowed to connect to this user\"));\n            pSock->Close();\n        }\n    }\n\n    // !Allowed Hosts\n\n    // Networks\n    if (bCloneNetworks) {\n        CloneNetworks(User);\n    }\n    // !Networks\n\n    // CTCP Replies\n    m_mssCTCPReplies.clear();\n    const MCString& msReplies = User.GetCTCPReplies();\n    for (const auto& it : msReplies) {\n        AddCTCPReply(it.first, it.second);\n    }\n    // !CTCP Replies\n\n    // Flags\n    SetAutoClearChanBuffer(User.AutoClearChanBuffer());\n    SetAutoClearQueryBuffer(User.AutoClearQueryBuffer());\n    SetMultiClients(User.MultiClients());\n    SetDenyLoadMod(User.DenyLoadMod());\n    SetAdmin(User.IsAdmin());\n    SetDenySetBindHost(User.DenySetBindHost());\n    SetAuthOnlyViaModule(User.AuthOnlyViaModule());\n    SetTimestampAppend(User.GetTimestampAppend());\n    SetTimestampPrepend(User.GetTimestampPrepend());\n    SetTimestampFormat(User.GetTimestampFormat());\n    SetTimezone(User.GetTimezone());\n    // !Flags\n\n    // Modules\n    set<CString> ssUnloadMods;\n    CModules& vCurMods = GetModules();\n    const CModules& vNewMods = User.GetModules();\n\n    for (CModule* pNewMod : vNewMods) {\n        CString sModRet;\n        CModule* pCurMod = vCurMods.FindModule(pNewMod->GetModName());\n\n        if (!pCurMod) {\n            vCurMods.LoadModule(pNewMod->GetModName(), pNewMod->GetArgs(),\n                                CModInfo::UserModule, this, nullptr, sModRet);\n        } else if (pNewMod->GetArgs() != pCurMod->GetArgs()) {\n            vCurMods.ReloadModule(pNewMod->GetModName(), pNewMod->GetArgs(),\n                                  this, nullptr, sModRet);\n        }\n    }\n\n    for (CModule* pCurMod : vCurMods) {\n        CModule* pNewMod = vNewMods.FindModule(pCurMod->GetModName());\n\n        if (!pNewMod) {\n            ssUnloadMods.insert(pCurMod->GetModName());\n        }\n    }\n\n    for (const CString& sMod : ssUnloadMods) {\n        vCurMods.UnloadModule(sMod);\n    }\n    // !Modules\n\n    return true;\n}\n\nconst set<CString>& CUser::GetAllowedHosts() const { return m_ssAllowedHosts; }\nbool CUser::AddAllowedHost(const CString& sHostMask) {\n    if (sHostMask.empty() ||\n        m_ssAllowedHosts.find(sHostMask) != m_ssAllowedHosts.end()) {\n        return false;\n    }\n\n    m_ssAllowedHosts.insert(sHostMask);\n    return true;\n}\nbool CUser::RemAllowedHost(const CString& sHostMask) {\n    return m_ssAllowedHosts.erase(sHostMask) > 0;\n}\nvoid CUser::ClearAllowedHosts() { m_ssAllowedHosts.clear(); }\n\nbool CUser::IsHostAllowed(const CString& sHost) const {\n    if (m_ssAllowedHosts.empty()) {\n        return true;\n    }\n\n    for (const CString& sAllowedHost : m_ssAllowedHosts) {\n        if (CUtils::CheckCIDR(sHost, sAllowedHost)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nconst CString& CUser::GetTimestampFormat() const { return m_sTimestampFormat; }\nbool CUser::GetTimestampAppend() const { return m_bAppendTimestamp; }\nbool CUser::GetTimestampPrepend() const { return m_bPrependTimestamp; }\n\nbool CUser::IsValidUserName(const CString& sUserName) {\n    // /^[a-zA-Z][a-zA-Z@._\\-]*$/\n    const char* p = sUserName.c_str();\n\n    if (sUserName.empty()) {\n        return false;\n    }\n\n    if ((*p < 'a' || *p > 'z') && (*p < 'A' || *p > 'Z')) {\n        return false;\n    }\n\n    while (*p) {\n        if (*p != '@' && *p != '.' && *p != '-' && *p != '_' && !isalnum(*p)) {\n            return false;\n        }\n\n        p++;\n    }\n\n    return true;\n}\n\nbool CUser::IsValid(CString& sErrMsg, bool bSkipPass) const {\n    sErrMsg.clear();\n\n    if (!bSkipPass && m_sPass.empty()) {\n        sErrMsg = t_s(\"Password is empty\");\n        return false;\n    }\n\n    if (m_sUserName.empty()) {\n        sErrMsg = t_s(\"Username is empty\");\n        return false;\n    }\n\n    if (!CUser::IsValidUserName(m_sUserName)) {\n        sErrMsg = t_s(\"Username is invalid\");\n        return false;\n    }\n\n    return true;\n}\n\nCConfig CUser::ToConfig() const {\n    CConfig config;\n    CConfig passConfig;\n\n    CString sHash;\n    switch (m_eHashType) {\n        case HASH_NONE:\n            sHash = \"Plain\";\n            break;\n        case HASH_MD5:\n            sHash = \"MD5\";\n            break;\n        case HASH_SHA256:\n            sHash = \"SHA256\";\n            break;\n    }\n    passConfig.AddKeyValuePair(\"Salt\", m_sPassSalt);\n    passConfig.AddKeyValuePair(\"Method\", sHash);\n    passConfig.AddKeyValuePair(\"Hash\", GetPass());\n    config.AddSubConfig(\"Pass\", \"password\", passConfig);\n\n    config.AddKeyValuePair(\"Nick\", GetNick());\n    config.AddKeyValuePair(\"AltNick\", GetAltNick());\n    config.AddKeyValuePair(\"Ident\", GetIdent());\n    config.AddKeyValuePair(\"RealName\", GetRealName());\n    config.AddKeyValuePair(\"BindHost\", GetBindHost());\n    config.AddKeyValuePair(\"DCCBindHost\", GetDCCBindHost());\n    config.AddKeyValuePair(\"QuitMsg\", GetQuitMsg());\n    if (CZNC::Get().GetStatusPrefix() != GetStatusPrefix())\n        config.AddKeyValuePair(\"StatusPrefix\", GetStatusPrefix());\n    config.AddKeyValuePair(\"Skin\", GetSkinName());\n    config.AddKeyValuePair(\"ChanModes\", GetDefaultChanModes());\n    config.AddKeyValuePair(\"ChanBufferSize\", CString(GetChanBufferSize()));\n    config.AddKeyValuePair(\"QueryBufferSize\", CString(GetQueryBufferSize()));\n    config.AddKeyValuePair(\"AutoClearChanBuffer\",\n                           CString(AutoClearChanBuffer()));\n    config.AddKeyValuePair(\"AutoClearQueryBuffer\",\n                           CString(AutoClearQueryBuffer()));\n    config.AddKeyValuePair(\"MultiClients\", CString(MultiClients()));\n    config.AddKeyValuePair(\"DenyLoadMod\", CString(DenyLoadMod()));\n    config.AddKeyValuePair(\"Admin\", CString(IsAdmin()));\n    config.AddKeyValuePair(\"DenySetBindHost\", CString(DenySetBindHost()));\n    config.AddKeyValuePair(\"TimestampFormat\", GetTimestampFormat());\n    config.AddKeyValuePair(\"AppendTimestamp\", CString(GetTimestampAppend()));\n    config.AddKeyValuePair(\"PrependTimestamp\", CString(GetTimestampPrepend()));\n    config.AddKeyValuePair(\"AuthOnlyViaModule\", CString(AuthOnlyViaModule()));\n    config.AddKeyValuePair(\"Timezone\", m_sTimezone);\n    config.AddKeyValuePair(\"JoinTries\", CString(m_uMaxJoinTries));\n    config.AddKeyValuePair(\"MaxNetworks\", CString(m_uMaxNetworks));\n    config.AddKeyValuePair(\"MaxQueryBuffers\", CString(m_uMaxQueryBuffers));\n    config.AddKeyValuePair(\"MaxJoins\", CString(m_uMaxJoins));\n    config.AddKeyValuePair(\"ClientEncoding\", GetClientEncoding());\n    config.AddKeyValuePair(\"Language\", GetLanguage());\n    config.AddKeyValuePair(\"NoTrafficTimeout\", CString(GetNoTrafficTimeout()));\n\n    // Allow Hosts\n    if (!m_ssAllowedHosts.empty()) {\n        for (const CString& sHost : m_ssAllowedHosts) {\n            config.AddKeyValuePair(\"Allow\", sHost);\n        }\n    }\n\n    // CTCP Replies\n    if (!m_mssCTCPReplies.empty()) {\n        for (const auto& itb : m_mssCTCPReplies) {\n            config.AddKeyValuePair(\"CTCPReply\",\n                                   itb.first.AsUpper() + \" \" + itb.second);\n        }\n    }\n\n    // Modules\n    const CModules& Mods = GetModules();\n\n    if (!Mods.empty()) {\n        for (CModule* pMod : Mods) {\n            CString sArgs = pMod->GetArgs();\n\n            if (!sArgs.empty()) {\n                sArgs = \" \" + sArgs;\n            }\n\n            config.AddKeyValuePair(\"LoadModule\", pMod->GetModName() + sArgs);\n        }\n    }\n\n    // Networks\n    for (CIRCNetwork* pNetwork : m_vIRCNetworks) {\n        config.AddSubConfig(\"Network\", pNetwork->GetName(),\n                            pNetwork->ToConfig());\n    }\n\n    return config;\n}\n\nbool CUser::CheckPass(const CString& sPass) const {\n    if(AuthOnlyViaModule() || CZNC::Get().GetAuthOnlyViaModule()) {\n        return false;\n    }\n\n    switch (m_eHashType) {\n        case HASH_MD5:\n            return m_sPass.Equals(CUtils::SaltedMD5Hash(sPass, m_sPassSalt));\n        case HASH_SHA256:\n            return m_sPass.Equals(CUtils::SaltedSHA256Hash(sPass, m_sPassSalt));\n        case HASH_NONE:\n        default:\n            return (sPass == m_sPass);\n    }\n}\n\n/*CClient* CUser::GetClient() {\n    // Todo: optimize this by saving a pointer to the sock\n    CSockManager& Manager = CZNC::Get().GetManager();\n    CString sSockName = \"USR::\" + m_sUserName;\n\n    for (unsigned int a = 0; a < Manager.size(); a++) {\n        Csock* pSock = Manager[a];\n        if (pSock->GetSockName().Equals(sSockName)) {\n            if (!pSock->IsClosed()) {\n                return (CClient*) pSock;\n            }\n        }\n    }\n\n    return (CClient*) CZNC::Get().GetManager().FindSockByName(sSockName);\n}*/\n\nCString CUser::GetLocalDCCIP() const {\n    if (!GetDCCBindHost().empty()) return GetDCCBindHost();\n\n    for (CIRCNetwork* pNetwork : m_vIRCNetworks) {\n        CIRCSock* pIRCSock = pNetwork->GetIRCSock();\n        if (pIRCSock) {\n            return pIRCSock->GetLocalIP();\n        }\n    }\n\n    if (!GetAllClients().empty()) {\n        return GetAllClients()[0]->GetLocalIP();\n    }\n\n    return \"\";\n}\n\nbool CUser::PutUser(const CString& sLine, CClient* pClient,\n                    CClient* pSkipClient) {\n    for (CClient* pEachClient : m_vClients) {\n        if ((!pClient || pClient == pEachClient) &&\n            pSkipClient != pEachClient) {\n            pEachClient->PutClient(sLine);\n\n            if (pClient) {\n                return true;\n            }\n        }\n    }\n\n    return (pClient == nullptr);\n}\n\nbool CUser::PutAllUser(const CString& sLine, CClient* pClient,\n                       CClient* pSkipClient) {\n    PutUser(sLine, pClient, pSkipClient);\n\n    for (CIRCNetwork* pNetwork : m_vIRCNetworks) {\n        if (pNetwork->PutUser(sLine, pClient, pSkipClient)) {\n            return true;\n        }\n    }\n\n    return (pClient == nullptr);\n}\n\nbool CUser::PutStatus(const CString& sLine, CClient* pClient,\n                      CClient* pSkipClient) {\n    vector<CClient*> vClients = GetAllClients();\n    for (CClient* pEachClient : vClients) {\n        if ((!pClient || pClient == pEachClient) &&\n            pSkipClient != pEachClient) {\n            pEachClient->PutStatus(sLine);\n\n            if (pClient) {\n                return true;\n            }\n        }\n    }\n\n    return (pClient == nullptr);\n}\n\nbool CUser::PutStatusNotice(const CString& sLine, CClient* pClient,\n                            CClient* pSkipClient) {\n    vector<CClient*> vClients = GetAllClients();\n    for (CClient* pEachClient : vClients) {\n        if ((!pClient || pClient == pEachClient) &&\n            pSkipClient != pEachClient) {\n            pEachClient->PutStatusNotice(sLine);\n\n            if (pClient) {\n                return true;\n            }\n        }\n    }\n\n    return (pClient == nullptr);\n}\n\nbool CUser::PutModule(const CString& sModule, const CString& sLine,\n                      CClient* pClient, CClient* pSkipClient) {\n    for (CClient* pEachClient : m_vClients) {\n        if ((!pClient || pClient == pEachClient) &&\n            pSkipClient != pEachClient) {\n            pEachClient->PutModule(sModule, sLine);\n\n            if (pClient) {\n                return true;\n            }\n        }\n    }\n\n    return (pClient == nullptr);\n}\n\nbool CUser::PutModNotice(const CString& sModule, const CString& sLine,\n                         CClient* pClient, CClient* pSkipClient) {\n    for (CClient* pEachClient : m_vClients) {\n        if ((!pClient || pClient == pEachClient) &&\n            pSkipClient != pEachClient) {\n            pEachClient->PutModNotice(sModule, sLine);\n\n            if (pClient) {\n                return true;\n            }\n        }\n    }\n\n    return (pClient == nullptr);\n}\n\nCString CUser::MakeCleanUserName(const CString& sUserName) {\n    return sUserName.Token(0, false, \"@\").Replace_n(\".\", \"\");\n}\n\nbool CUser::IsUserAttached() const {\n    if (!m_vClients.empty()) {\n        return true;\n    }\n\n    for (const CIRCNetwork* pNetwork : m_vIRCNetworks) {\n        if (pNetwork->IsUserAttached()) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool CUser::LoadModule(const CString& sModName, const CString& sArgs,\n                       const CString& sNotice, CString& sError) {\n    bool bModRet = true;\n    CString sModRet;\n\n    CModInfo ModInfo;\n    if (!CZNC::Get().GetModules().GetModInfo(ModInfo, sModName, sModRet)) {\n        sError = t_f(\"Unable to find modinfo {1}: {2}\")(sModName, sModRet);\n        return false;\n    }\n\n    CUtils::PrintAction(sNotice);\n\n    if (!ModInfo.SupportsType(CModInfo::UserModule) &&\n        ModInfo.SupportsType(CModInfo::NetworkModule)) {\n        CUtils::PrintMessage(\n            \"NOTICE: Module [\" + sModName +\n            \"] is a network module, loading module for all networks in user.\");\n\n        // Do they have old NV?\n        CFile fNVFile =\n            CFile(GetUserPath() + \"/moddata/\" + sModName + \"/.registry\");\n\n        for (CIRCNetwork* pNetwork : m_vIRCNetworks) {\n            // Check whether the network already has this module loaded (#954)\n            if (pNetwork->GetModules().FindModule(sModName)) {\n                continue;\n            }\n\n            if (fNVFile.Exists()) {\n                CString sNetworkModPath =\n                    pNetwork->GetNetworkPath() + \"/moddata/\" + sModName;\n                if (!CFile::Exists(sNetworkModPath)) {\n                    CDir::MakeDir(sNetworkModPath);\n                }\n\n                fNVFile.Copy(sNetworkModPath + \"/.registry\");\n            }\n\n            bModRet = pNetwork->GetModules().LoadModule(\n                sModName, sArgs, CModInfo::NetworkModule, this, pNetwork,\n                sModRet);\n            if (!bModRet) {\n                break;\n            }\n        }\n    } else {\n        bModRet = GetModules().LoadModule(sModName, sArgs, CModInfo::UserModule,\n                                          this, nullptr, sModRet);\n    }\n\n    if (!bModRet) {\n        sError = sModRet;\n    }\n    return bModRet;\n}\n\n// Setters\nvoid CUser::SetNick(const CString& s) { m_sNick = s; }\nvoid CUser::SetAltNick(const CString& s) { m_sAltNick = s; }\nvoid CUser::SetIdent(const CString& s) { m_sIdent = s; }\nvoid CUser::SetRealName(const CString& s) { m_sRealName = s; }\nvoid CUser::SetBindHost(const CString& s) { m_sBindHost = s; }\nvoid CUser::SetDCCBindHost(const CString& s) { m_sDCCBindHost = s; }\nvoid CUser::SetPass(const CString& s, eHashType eHash, const CString& sSalt) {\n    m_sPass = s;\n    m_eHashType = eHash;\n    m_sPassSalt = sSalt;\n}\nvoid CUser::SetMultiClients(bool b) { m_bMultiClients = b; }\nvoid CUser::SetDenyLoadMod(bool b) { m_bDenyLoadMod = b; }\nvoid CUser::SetAdmin(bool b) { m_bAdmin = b; }\nvoid CUser::SetDenySetBindHost(bool b) { m_bDenySetBindHost = b; }\nvoid CUser::SetDefaultChanModes(const CString& s) { m_sDefaultChanModes = s; }\nvoid CUser::SetClientEncoding(const CString& s) {\n    m_sClientEncoding = CZNC::Get().FixupEncoding(s);\n    for (CClient* pClient : GetAllClients()) {\n        pClient->SetEncoding(m_sClientEncoding);\n    }\n}\nvoid CUser::SetQuitMsg(const CString& s) { m_sQuitMsg = s; }\nvoid CUser::SetAutoClearChanBuffer(bool b) {\n    for (CIRCNetwork* pNetwork : m_vIRCNetworks) {\n        for (CChan* pChan : pNetwork->GetChans()) {\n            pChan->InheritAutoClearChanBuffer(b);\n        }\n    }\n    m_bAutoClearChanBuffer = b;\n}\nvoid CUser::SetAutoClearQueryBuffer(bool b) { m_bAutoClearQueryBuffer = b; }\n\nbool CUser::SetBufferCount(unsigned int u, bool bForce) {\n    return SetChanBufferSize(u, bForce);\n}\n\nbool CUser::SetChanBufferSize(unsigned int u, bool bForce) {\n    if (!bForce && u > CZNC::Get().GetMaxBufferSize()) return false;\n    for (CIRCNetwork* pNetwork : m_vIRCNetworks) {\n        for (CChan* pChan : pNetwork->GetChans()) {\n            pChan->InheritBufferCount(u, bForce);\n        }\n    }\n    m_uChanBufferSize = u;\n    return true;\n}\n\nbool CUser::SetQueryBufferSize(unsigned int u, bool bForce) {\n    if (!bForce && u > CZNC::Get().GetMaxBufferSize()) return false;\n    for (CIRCNetwork* pNetwork : m_vIRCNetworks) {\n        for (CQuery* pQuery : pNetwork->GetQueries()) {\n            pQuery->SetBufferCount(u, bForce);\n        }\n    }\n    m_uQueryBufferSize = u;\n    return true;\n}\n\nbool CUser::AddCTCPReply(const CString& sCTCP, const CString& sReply) {\n    // Reject CTCP requests containing spaces\n    if (sCTCP.find_first_of(' ') != CString::npos) {\n        return false;\n    }\n    // Reject empty CTCP requests\n    if (sCTCP.empty()) {\n        return false;\n    }\n    m_mssCTCPReplies[sCTCP.AsUpper()] = sReply;\n    return true;\n}\n\nbool CUser::DelCTCPReply(const CString& sCTCP) {\n    return m_mssCTCPReplies.erase(sCTCP.AsUpper()) > 0;\n}\n\nbool CUser::SetStatusPrefix(const CString& s) {\n    if ((!s.empty()) && (s.length() < 6) && (!s.Contains(\" \"))) {\n        m_sStatusPrefix = (s.empty()) ? \"*\" : s;\n        return true;\n    }\n\n    return false;\n}\n\nbool CUser::SetLanguage(const CString& s) {\n    // They look like ru-RU\n    for (char c : s) {\n        if (isalpha(c) || c == '-' || c == '_') {\n        } else {\n            return false;\n        }\n    }\n    m_sLanguage = s;\n    // 1.7.0 accidentally used _ instead of -, which made language\n    // non-selectable. But it's possible that someone put _ to znc.conf\n    // manually.\n    // TODO: cleanup _ some time later.\n    m_sLanguage.Replace(\"_\", \"-\");\n    return true;\n}\n// !Setters\n\n// Getters\nvector<CClient*> CUser::GetAllClients() const {\n    vector<CClient*> vClients;\n\n    for (CIRCNetwork* pNetwork : m_vIRCNetworks) {\n        for (CClient* pClient : pNetwork->GetClients()) {\n            vClients.push_back(pClient);\n        }\n    }\n\n    for (CClient* pClient : m_vClients) {\n        vClients.push_back(pClient);\n    }\n\n    return vClients;\n}\n\nconst CString& CUser::GetUserName() const { return m_sUserName; }\nconst CString& CUser::GetCleanUserName() const { return m_sCleanUserName; }\nconst CString& CUser::GetNick(bool bAllowDefault) const {\n    return (bAllowDefault && m_sNick.empty()) ? GetCleanUserName() : m_sNick;\n}\nconst CString& CUser::GetAltNick(bool bAllowDefault) const {\n    return (bAllowDefault && m_sAltNick.empty()) ? GetCleanUserName()\n                                                 : m_sAltNick;\n}\nconst CString& CUser::GetIdent(bool bAllowDefault) const {\n    return (bAllowDefault && m_sIdent.empty()) ? GetCleanUserName() : m_sIdent;\n}\nCString CUser::GetRealName() const {\n    // Not include version number via GetTag() because of\n    // https://github.com/znc/znc/issues/818#issuecomment-70402820\n    return (!m_sRealName.Trim_n().empty()) ? m_sRealName\n                                           : \"ZNC - https://znc.in\";\n}\nconst CString& CUser::GetBindHost() const { return m_sBindHost; }\nconst CString& CUser::GetDCCBindHost() const { return m_sDCCBindHost; }\nconst CString& CUser::GetPass() const { return m_sPass; }\nCUser::eHashType CUser::GetPassHashType() const { return m_eHashType; }\nconst CString& CUser::GetPassSalt() const { return m_sPassSalt; }\nbool CUser::DenyLoadMod() const { return m_bDenyLoadMod; }\nbool CUser::IsAdmin() const { return m_bAdmin; }\nbool CUser::DenySetBindHost() const { return m_bDenySetBindHost; }\nbool CUser::MultiClients() const { return m_bMultiClients; }\nbool CUser::AuthOnlyViaModule() const { return m_bAuthOnlyViaModule; }\nconst CString& CUser::GetStatusPrefix() const { return m_sStatusPrefix; }\nconst CString& CUser::GetDefaultChanModes() const {\n    return m_sDefaultChanModes;\n}\nconst CString& CUser::GetClientEncoding() const { return m_sClientEncoding; }\nbool CUser::HasSpaceForNewNetwork() const {\n    return GetNetworks().size() < MaxNetworks();\n}\n\nCString CUser::GetQuitMsg() const {\n    return (!m_sQuitMsg.Trim_n().empty()) ? m_sQuitMsg : \"%znc%\";\n}\nconst MCString& CUser::GetCTCPReplies() const { return m_mssCTCPReplies; }\nunsigned int CUser::GetBufferCount() const { return GetChanBufferSize(); }\nunsigned int CUser::GetChanBufferSize() const { return m_uChanBufferSize; }\nunsigned int CUser::GetQueryBufferSize() const { return m_uQueryBufferSize; }\nbool CUser::AutoClearChanBuffer() const { return m_bAutoClearChanBuffer; }\nbool CUser::AutoClearQueryBuffer() const { return m_bAutoClearQueryBuffer; }\n// CString CUser::GetSkinName() const { return (!m_sSkinName.empty()) ?\n// m_sSkinName : CZNC::Get().GetSkinName(); }\nCString CUser::GetSkinName() const { return m_sSkinName; }\nCString CUser::GetLanguage() const { return m_sLanguage; }\nconst CString& CUser::GetUserPath() const {\n    if (!CFile::Exists(m_sUserPath)) {\n        CDir::MakeDir(m_sUserPath);\n    }\n    return m_sUserPath;\n}\n// !Getters\n\nunsigned long long CUser::BytesRead() const {\n    unsigned long long uBytes = m_uBytesRead;\n    for (const CIRCNetwork* pNetwork : m_vIRCNetworks) {\n        uBytes += pNetwork->BytesRead();\n    }\n    return uBytes;\n}\n\nunsigned long long CUser::BytesWritten() const {\n    unsigned long long uBytes = m_uBytesWritten;\n    for (const CIRCNetwork* pNetwork : m_vIRCNetworks) {\n        uBytes += pNetwork->BytesWritten();\n    }\n    return uBytes;\n}\n", "/*\n * Copyright (C) 2004-2018 ZNC, see the NOTICE file for details.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <znc/znc.h>\n#include <znc/FileUtils.h>\n#include <znc/IRCSock.h>\n#include <znc/Server.h>\n#include <znc/User.h>\n#include <znc/IRCNetwork.h>\n#include <znc/Config.h>\n#include <time.h>\n#include <tuple>\n#include <algorithm>\n\nusing std::endl;\nusing std::cout;\nusing std::map;\nusing std::set;\nusing std::vector;\nusing std::list;\nusing std::tuple;\nusing std::make_tuple;\n\nCZNC::CZNC()\n    : m_TimeStarted(time(nullptr)),\n      m_eConfigState(ECONFIG_NOTHING),\n      m_vpListeners(),\n      m_msUsers(),\n      m_msDelUsers(),\n      m_Manager(),\n      m_sCurPath(\"\"),\n      m_sZNCPath(\"\"),\n      m_sConfigFile(\"\"),\n      m_sSkinName(\"\"),\n      m_sStatusPrefix(\"\"),\n      m_sPidFile(\"\"),\n      m_sSSLCertFile(\"\"),\n      m_sSSLKeyFile(\"\"),\n      m_sSSLDHParamFile(\"\"),\n      m_sSSLCiphers(\"\"),\n      m_sSSLProtocols(\"\"),\n      m_vsBindHosts(),\n      m_vsTrustedProxies(),\n      m_vsMotd(),\n      m_pLockFile(nullptr),\n      m_uiConnectDelay(5),\n      m_uiAnonIPLimit(10),\n      m_uiMaxBufferSize(500),\n      m_uDisabledSSLProtocols(Csock::EDP_SSL),\n      m_pModules(new CModules),\n      m_uBytesRead(0),\n      m_uBytesWritten(0),\n      m_lpConnectQueue(),\n      m_pConnectQueueTimer(nullptr),\n      m_uiConnectPaused(0),\n      m_uiForceEncoding(0),\n      m_sConnectThrottle(),\n      m_bProtectWebSessions(true),\n      m_bHideVersion(false),\n      m_bAuthOnlyViaModule(false),\n      m_Translation(\"znc\"),\n      m_uiConfigWriteDelay(0),\n      m_pConfigTimer(nullptr) {\n    if (!InitCsocket()) {\n        CUtils::PrintError(\"Could not initialize Csocket!\");\n        exit(-1);\n    }\n    m_sConnectThrottle.SetTTL(30000);\n}\n\nCZNC::~CZNC() {\n    m_pModules->UnloadAll();\n\n    for (const auto& it : m_msUsers) {\n        it.second->GetModules().UnloadAll();\n\n        const vector<CIRCNetwork*>& networks = it.second->GetNetworks();\n        for (CIRCNetwork* pNetwork : networks) {\n            pNetwork->GetModules().UnloadAll();\n        }\n    }\n\n    for (CListener* pListener : m_vpListeners) {\n        delete pListener;\n    }\n\n    for (const auto& it : m_msUsers) {\n        it.second->SetBeingDeleted(true);\n    }\n\n    m_pConnectQueueTimer = nullptr;\n    // This deletes m_pConnectQueueTimer\n    m_Manager.Cleanup();\n    DeleteUsers();\n\n    delete m_pModules;\n    delete m_pLockFile;\n\n    ShutdownCsocket();\n    DeletePidFile();\n}\n\nCString CZNC::GetVersion() {\n    return CString(VERSION_STR) + CString(ZNC_VERSION_EXTRA);\n}\n\nCString CZNC::GetTag(bool bIncludeVersion, bool bHTML) {\n    if (!Get().m_bHideVersion) {\n        bIncludeVersion = true;\n    }\n    CString sAddress = bHTML ? \"<a href=\\\"https://znc.in\\\">https://znc.in</a>\"\n                             : \"https://znc.in\";\n\n    if (!bIncludeVersion) {\n        return \"ZNC - \" + sAddress;\n    }\n\n    CString sVersion = GetVersion();\n\n    return \"ZNC \" + sVersion + \" - \" + sAddress;\n}\n\nCString CZNC::GetCompileOptionsString() {\n    // Build system doesn't affect ABI\n    return ZNC_COMPILE_OPTIONS_STRING + CString(\n                                            \", build: \"\n#ifdef BUILD_WITH_CMAKE\n                                            \"cmake\"\n#else\n                                            \"autoconf\"\n#endif\n                                            );\n}\n\nCString CZNC::GetUptime() const {\n    time_t now = time(nullptr);\n    return CString::ToTimeStr(now - TimeStarted());\n}\n\nbool CZNC::OnBoot() {\n    bool bFail = false;\n    ALLMODULECALL(OnBoot(), &bFail);\n    if (bFail) return false;\n\n    return true;\n}\n\nbool CZNC::HandleUserDeletion() {\n    if (m_msDelUsers.empty()) return false;\n\n    for (const auto& it : m_msDelUsers) {\n        CUser* pUser = it.second;\n        pUser->SetBeingDeleted(true);\n\n        if (GetModules().OnDeleteUser(*pUser)) {\n            pUser->SetBeingDeleted(false);\n            continue;\n        }\n        m_msUsers.erase(pUser->GetUserName());\n        CWebSock::FinishUserSessions(*pUser);\n        delete pUser;\n    }\n\n    m_msDelUsers.clear();\n\n    return true;\n}\n\nclass CConfigWriteTimer : public CCron {\n  public:\n    CConfigWriteTimer(int iSecs) : CCron() {\n        SetName(\"Config write timer\");\n        Start(iSecs);\n    }\n\n  protected:\n    void RunJob() override {\n        CZNC::Get().SetConfigState(CZNC::ECONFIG_NEED_WRITE);\n\n        CZNC::Get().DisableConfigTimer();\n    }\n};\n\nvoid CZNC::Loop() {\n    while (true) {\n        CString sError;\n\n        ConfigState eState = GetConfigState();\n        switch (eState) {\n            case ECONFIG_NEED_REHASH:\n                SetConfigState(ECONFIG_NOTHING);\n\n                if (RehashConfig(sError)) {\n                    Broadcast(\"Rehashing succeeded\", true);\n                } else {\n                    Broadcast(\"Rehashing failed: \" + sError, true);\n                    Broadcast(\"ZNC is in some possibly inconsistent state!\",\n                              true);\n                }\n                break;\n            case ECONFIG_DELAYED_WRITE:\n                SetConfigState(ECONFIG_NOTHING);\n\n                if (GetConfigWriteDelay() > 0) {\n                    if (m_pConfigTimer == nullptr) {\n                        m_pConfigTimer = new CConfigWriteTimer(GetConfigWriteDelay());\n                        GetManager().AddCron(m_pConfigTimer);\n                    }\n                    break;\n                }\n                /* Fall through */\n            case ECONFIG_NEED_WRITE:\n            case ECONFIG_NEED_VERBOSE_WRITE:\n                SetConfigState(ECONFIG_NOTHING);\n\n                // stop pending configuration timer\n                DisableConfigTimer();\n\n                if (!WriteConfig()) {\n                    Broadcast(\"Writing the config file failed\", true);\n                } else if (eState == ECONFIG_NEED_VERBOSE_WRITE) {\n                    Broadcast(\"Writing the config succeeded\", true);\n                }\n                break;\n            case ECONFIG_NOTHING:\n                break;\n            case ECONFIG_NEED_QUIT:\n                return;\n        }\n\n        // Check for users that need to be deleted\n        if (HandleUserDeletion()) {\n            // Also remove those user(s) from the config file\n            WriteConfig();\n        }\n\n        // Csocket wants micro seconds\n        // 100 msec to 5 min\n        m_Manager.DynamicSelectLoop(100 * 1000, 5 * 60 * 1000 * 1000);\n    }\n}\n\nCFile* CZNC::InitPidFile() {\n    if (!m_sPidFile.empty()) {\n        CString sFile;\n\n        // absolute path or relative to the data dir?\n        if (m_sPidFile[0] != '/')\n            sFile = GetZNCPath() + \"/\" + m_sPidFile;\n        else\n            sFile = m_sPidFile;\n\n        return new CFile(sFile);\n    }\n\n    return nullptr;\n}\n\nbool CZNC::WritePidFile(int iPid) {\n    CFile* File = InitPidFile();\n    if (File == nullptr) return false;\n\n    CUtils::PrintAction(\"Writing pid file [\" + File->GetLongName() + \"]\");\n\n    bool bRet = false;\n    if (File->Open(O_WRONLY | O_TRUNC | O_CREAT)) {\n        File->Write(CString(iPid) + \"\\n\");\n        File->Close();\n        bRet = true;\n    }\n\n    delete File;\n    CUtils::PrintStatus(bRet);\n    return bRet;\n}\n\nbool CZNC::DeletePidFile() {\n    CFile* File = InitPidFile();\n    if (File == nullptr) return false;\n\n    CUtils::PrintAction(\"Deleting pid file [\" + File->GetLongName() + \"]\");\n\n    bool bRet = File->Delete();\n\n    delete File;\n    CUtils::PrintStatus(bRet);\n    return bRet;\n}\n\nbool CZNC::WritePemFile() {\n#ifndef HAVE_LIBSSL\n    CUtils::PrintError(\"ZNC was not compiled with ssl support.\");\n    return false;\n#else\n    CString sPemFile = GetPemLocation();\n\n    CUtils::PrintAction(\"Writing Pem file [\" + sPemFile + \"]\");\n#ifndef _WIN32\n    int fd = creat(sPemFile.c_str(), 0600);\n    if (fd == -1) {\n        CUtils::PrintStatus(false, \"Unable to open\");\n        return false;\n    }\n    FILE* f = fdopen(fd, \"w\");\n#else\n    FILE* f = fopen(sPemFile.c_str(), \"w\");\n#endif\n\n    if (!f) {\n        CUtils::PrintStatus(false, \"Unable to open\");\n        return false;\n    }\n\n    CUtils::GenerateCert(f, \"\");\n    fclose(f);\n\n    CUtils::PrintStatus(true);\n    return true;\n#endif\n}\n\nvoid CZNC::DeleteUsers() {\n    for (const auto& it : m_msUsers) {\n        it.second->SetBeingDeleted(true);\n        delete it.second;\n    }\n\n    m_msUsers.clear();\n    DisableConnectQueue();\n}\n\nbool CZNC::IsHostAllowed(const CString& sHostMask) const {\n    for (const auto& it : m_msUsers) {\n        if (it.second->IsHostAllowed(sHostMask)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool CZNC::AllowConnectionFrom(const CString& sIP) const {\n    if (m_uiAnonIPLimit == 0) return true;\n    return (GetManager().GetAnonConnectionCount(sIP) < m_uiAnonIPLimit);\n}\n\nvoid CZNC::InitDirs(const CString& sArgvPath, const CString& sDataDir) {\n    // If the bin was not ran from the current directory, we need to add that\n    // dir onto our cwd\n    CString::size_type uPos = sArgvPath.rfind('/');\n    if (uPos == CString::npos)\n        m_sCurPath = \"./\";\n    else\n        m_sCurPath = CDir::ChangeDir(\"./\", sArgvPath.Left(uPos), \"\");\n\n    // Try to set the user's home dir, default to binpath on failure\n    CFile::InitHomePath(m_sCurPath);\n\n    if (sDataDir.empty()) {\n        m_sZNCPath = CFile::GetHomePath() + \"/.znc\";\n    } else {\n        m_sZNCPath = sDataDir;\n    }\n\n    m_sSSLCertFile = m_sZNCPath + \"/znc.pem\";\n}\n\nCString CZNC::GetConfPath(bool bAllowMkDir) const {\n    CString sConfPath = m_sZNCPath + \"/configs\";\n    if (bAllowMkDir && !CFile::Exists(sConfPath)) {\n        CDir::MakeDir(sConfPath);\n    }\n\n    return sConfPath;\n}\n\nCString CZNC::GetUserPath() const {\n    CString sUserPath = m_sZNCPath + \"/users\";\n    if (!CFile::Exists(sUserPath)) {\n        CDir::MakeDir(sUserPath);\n    }\n\n    return sUserPath;\n}\n\nCString CZNC::GetModPath() const {\n    CString sModPath = m_sZNCPath + \"/modules\";\n\n    return sModPath;\n}\n\nconst CString& CZNC::GetCurPath() const {\n    if (!CFile::Exists(m_sCurPath)) {\n        CDir::MakeDir(m_sCurPath);\n    }\n    return m_sCurPath;\n}\n\nconst CString& CZNC::GetHomePath() const { return CFile::GetHomePath(); }\n\nconst CString& CZNC::GetZNCPath() const {\n    if (!CFile::Exists(m_sZNCPath)) {\n        CDir::MakeDir(m_sZNCPath);\n    }\n    return m_sZNCPath;\n}\n\nCString CZNC::GetPemLocation() const {\n    return CDir::ChangeDir(\"\", m_sSSLCertFile);\n}\n\nCString CZNC::GetKeyLocation() const {\n    return CDir::ChangeDir(\n        \"\", m_sSSLKeyFile.empty() ? m_sSSLCertFile : m_sSSLKeyFile);\n}\n\nCString CZNC::GetDHParamLocation() const {\n    return CDir::ChangeDir(\n        \"\", m_sSSLDHParamFile.empty() ? m_sSSLCertFile : m_sSSLDHParamFile);\n}\n\nCString CZNC::ExpandConfigPath(const CString& sConfigFile, bool bAllowMkDir) {\n    CString sRetPath;\n\n    if (sConfigFile.empty()) {\n        sRetPath = GetConfPath(bAllowMkDir) + \"/znc.conf\";\n    } else {\n        if (sConfigFile.StartsWith(\"./\") || sConfigFile.StartsWith(\"../\")) {\n            sRetPath = GetCurPath() + \"/\" + sConfigFile;\n        } else if (!sConfigFile.StartsWith(\"/\")) {\n            sRetPath = GetConfPath(bAllowMkDir) + \"/\" + sConfigFile;\n        } else {\n            sRetPath = sConfigFile;\n        }\n    }\n\n    return sRetPath;\n}\n\nbool CZNC::WriteConfig() {\n    if (GetConfigFile().empty()) {\n        DEBUG(\"Config file name is empty?!\");\n        return false;\n    }\n\n    // We first write to a temporary file and then move it to the right place\n    CFile* pFile = new CFile(GetConfigFile() + \"~\");\n\n    if (!pFile->Open(O_WRONLY | O_CREAT | O_TRUNC, 0600)) {\n        DEBUG(\"Could not write config to \" + GetConfigFile() + \"~: \" +\n              CString(strerror(errno)));\n        delete pFile;\n        return false;\n    }\n\n    // We have to \"transfer\" our lock on the config to the new file.\n    // The old file (= inode) is going away and thus a lock on it would be\n    // useless. These lock should always succeed (races, anyone?).\n    if (!pFile->TryExLock()) {\n        DEBUG(\"Error while locking the new config file, errno says: \" +\n              CString(strerror(errno)));\n        pFile->Delete();\n        delete pFile;\n        return false;\n    }\n\n    pFile->Write(MakeConfigHeader() + \"\\n\");\n\n    CConfig config;\n    config.AddKeyValuePair(\"AnonIPLimit\", CString(m_uiAnonIPLimit));\n    config.AddKeyValuePair(\"MaxBufferSize\", CString(m_uiMaxBufferSize));\n    config.AddKeyValuePair(\"SSLCertFile\", CString(GetPemLocation()));\n    config.AddKeyValuePair(\"SSLKeyFile\", CString(GetKeyLocation()));\n    config.AddKeyValuePair(\"SSLDHParamFile\", CString(GetDHParamLocation()));\n    config.AddKeyValuePair(\"ProtectWebSessions\",\n                           CString(m_bProtectWebSessions));\n    config.AddKeyValuePair(\"HideVersion\", CString(m_bHideVersion));\n    config.AddKeyValuePair(\"AuthOnlyViaModule\", CString(m_bAuthOnlyViaModule));\n    config.AddKeyValuePair(\"Version\", CString(VERSION_STR));\n    config.AddKeyValuePair(\"ConfigWriteDelay\", CString(m_uiConfigWriteDelay));\n\n    unsigned int l = 0;\n    for (CListener* pListener : m_vpListeners) {\n        CConfig listenerConfig;\n\n        listenerConfig.AddKeyValuePair(\"Host\", pListener->GetBindHost());\n        listenerConfig.AddKeyValuePair(\"URIPrefix\",\n                                       pListener->GetURIPrefix() + \"/\");\n        listenerConfig.AddKeyValuePair(\"Port\", CString(pListener->GetPort()));\n\n        listenerConfig.AddKeyValuePair(\n            \"IPv4\", CString(pListener->GetAddrType() != ADDR_IPV6ONLY));\n        listenerConfig.AddKeyValuePair(\n            \"IPv6\", CString(pListener->GetAddrType() != ADDR_IPV4ONLY));\n\n        listenerConfig.AddKeyValuePair(\"SSL\", CString(pListener->IsSSL()));\n\n        listenerConfig.AddKeyValuePair(\n            \"AllowIRC\",\n            CString(pListener->GetAcceptType() != CListener::ACCEPT_HTTP));\n        listenerConfig.AddKeyValuePair(\n            \"AllowWeb\",\n            CString(pListener->GetAcceptType() != CListener::ACCEPT_IRC));\n\n        config.AddSubConfig(\"Listener\", \"listener\" + CString(l++),\n                            listenerConfig);\n    }\n\n    config.AddKeyValuePair(\"ConnectDelay\", CString(m_uiConnectDelay));\n    config.AddKeyValuePair(\"ServerThrottle\",\n                           CString(m_sConnectThrottle.GetTTL() / 1000));\n\n    if (!m_sPidFile.empty()) {\n        config.AddKeyValuePair(\"PidFile\", m_sPidFile.FirstLine());\n    }\n\n    if (!m_sSkinName.empty()) {\n        config.AddKeyValuePair(\"Skin\", m_sSkinName.FirstLine());\n    }\n\n    if (!m_sStatusPrefix.empty()) {\n        config.AddKeyValuePair(\"StatusPrefix\", m_sStatusPrefix.FirstLine());\n    }\n\n    if (!m_sSSLCiphers.empty()) {\n        config.AddKeyValuePair(\"SSLCiphers\", CString(m_sSSLCiphers));\n    }\n\n    if (!m_sSSLProtocols.empty()) {\n        config.AddKeyValuePair(\"SSLProtocols\", m_sSSLProtocols);\n    }\n\n    for (const CString& sLine : m_vsMotd) {\n        config.AddKeyValuePair(\"Motd\", sLine.FirstLine());\n    }\n\n    for (const CString& sProxy : m_vsTrustedProxies) {\n        config.AddKeyValuePair(\"TrustedProxy\", sProxy.FirstLine());\n    }\n\n    CModules& Mods = GetModules();\n\n    for (const CModule* pMod : Mods) {\n        CString sName = pMod->GetModName();\n        CString sArgs = pMod->GetArgs();\n\n        if (!sArgs.empty()) {\n            sArgs = \" \" + sArgs.FirstLine();\n        }\n\n        config.AddKeyValuePair(\"LoadModule\", sName.FirstLine() + sArgs);\n    }\n\n    for (const auto& it : m_msUsers) {\n        CString sErr;\n\n        if (!it.second->IsValid(sErr)) {\n            DEBUG(\"** Error writing config for user [\" << it.first << \"] [\"\n                                                       << sErr << \"]\");\n            continue;\n        }\n\n        config.AddSubConfig(\"User\", it.second->GetUserName(),\n                            it.second->ToConfig());\n    }\n\n    config.Write(*pFile);\n\n    // If Sync() fails... well, let's hope nothing important breaks..\n    pFile->Sync();\n\n    if (pFile->HadError()) {\n        DEBUG(\"Error while writing the config, errno says: \" +\n              CString(strerror(errno)));\n        pFile->Delete();\n        delete pFile;\n        return false;\n    }\n\n    // We wrote to a temporary name, move it to the right place\n    if (!pFile->Move(GetConfigFile(), true)) {\n        DEBUG(\n            \"Error while replacing the config file with a new version, errno \"\n            \"says \"\n            << strerror(errno));\n        pFile->Delete();\n        delete pFile;\n        return false;\n    }\n\n    // Everything went fine, just need to update the saved path.\n    pFile->SetFileName(GetConfigFile());\n\n    // Make sure the lock is kept alive as long as we need it.\n    delete m_pLockFile;\n    m_pLockFile = pFile;\n\n    return true;\n}\n\nCString CZNC::MakeConfigHeader() {\n    return \"// WARNING\\n\"\n           \"//\\n\"\n           \"// Do NOT edit this file while ZNC is running!\\n\"\n           \"// Use webadmin or *controlpanel instead.\\n\"\n           \"//\\n\"\n           \"// Altering this file by hand will forfeit all support.\\n\"\n           \"//\\n\"\n           \"// But if you feel risky, you might want to read help on /znc \"\n           \"saveconfig and /znc rehash.\\n\"\n           \"// Also check https://wiki.znc.in/Configuration\\n\";\n}\n\nbool CZNC::WriteNewConfig(const CString& sConfigFile) {\n    CString sAnswer, sUser, sNetwork;\n    VCString vsLines;\n\n    vsLines.push_back(MakeConfigHeader());\n    vsLines.push_back(\"Version = \" + CString(VERSION_STR));\n\n    m_sConfigFile = ExpandConfigPath(sConfigFile);\n\n    if (CFile::Exists(m_sConfigFile)) {\n        CUtils::PrintStatus(\n            false, \"WARNING: config [\" + m_sConfigFile + \"] already exists.\");\n    }\n\n    CUtils::PrintMessage(\"\");\n    CUtils::PrintMessage(\"-- Global settings --\");\n    CUtils::PrintMessage(\"\");\n\n// Listen\n#ifdef HAVE_IPV6\n    bool b6 = true;\n#else\n    bool b6 = false;\n#endif\n    CString sListenHost;\n    CString sURIPrefix;\n    bool bListenSSL = false;\n    unsigned int uListenPort = 0;\n    bool bSuccess;\n\n    do {\n        bSuccess = true;\n        while (true) {\n            if (!CUtils::GetNumInput(\"Listen on port\", uListenPort, 1025,\n                                     65534)) {\n                continue;\n            }\n            if (uListenPort == 6667) {\n                CUtils::PrintStatus(false,\n                                    \"WARNING: Some web browsers reject port \"\n                                    \"6667. If you intend to\");\n                CUtils::PrintStatus(false,\n                                    \"use ZNC's web interface, you might want \"\n                                    \"to use another port.\");\n                if (!CUtils::GetBoolInput(\"Proceed with port 6667 anyway?\",\n                                          true)) {\n                    continue;\n                }\n            }\n            break;\n        }\n\n#ifdef HAVE_LIBSSL\n        bListenSSL = CUtils::GetBoolInput(\"Listen using SSL\", bListenSSL);\n#endif\n\n#ifdef HAVE_IPV6\n        b6 = CUtils::GetBoolInput(\"Listen using both IPv4 and IPv6\", b6);\n#endif\n\n        // Don't ask for listen host, it may be configured later if needed.\n\n        CUtils::PrintAction(\"Verifying the listener\");\n        CListener* pListener = new CListener(\n            (unsigned short int)uListenPort, sListenHost, sURIPrefix,\n            bListenSSL, b6 ? ADDR_ALL : ADDR_IPV4ONLY, CListener::ACCEPT_ALL);\n        if (!pListener->Listen()) {\n            CUtils::PrintStatus(false, FormatBindError());\n            bSuccess = false;\n        } else\n            CUtils::PrintStatus(true);\n        delete pListener;\n    } while (!bSuccess);\n\n#ifdef HAVE_LIBSSL\n    CString sPemFile = GetPemLocation();\n    if (!CFile::Exists(sPemFile)) {\n        CUtils::PrintMessage(\"Unable to locate pem file: [\" + sPemFile +\n                             \"], creating it\");\n        WritePemFile();\n    }\n#endif\n\n    vsLines.push_back(\"<Listener l>\");\n    vsLines.push_back(\"\\tPort = \" + CString(uListenPort));\n    vsLines.push_back(\"\\tIPv4 = true\");\n    vsLines.push_back(\"\\tIPv6 = \" + CString(b6));\n    vsLines.push_back(\"\\tSSL = \" + CString(bListenSSL));\n    if (!sListenHost.empty()) {\n        vsLines.push_back(\"\\tHost = \" + sListenHost);\n    }\n    vsLines.push_back(\"</Listener>\");\n    // !Listen\n\n    set<CModInfo> ssGlobalMods;\n    GetModules().GetDefaultMods(ssGlobalMods, CModInfo::GlobalModule);\n    vector<CString> vsGlobalModNames;\n    for (const CModInfo& Info : ssGlobalMods) {\n        vsGlobalModNames.push_back(Info.GetName());\n        vsLines.push_back(\"LoadModule = \" + Info.GetName());\n    }\n    CUtils::PrintMessage(\n        \"Enabled global modules [\" +\n        CString(\", \").Join(vsGlobalModNames.begin(), vsGlobalModNames.end()) +\n        \"]\");\n\n    // User\n    CUtils::PrintMessage(\"\");\n    CUtils::PrintMessage(\"-- Admin user settings --\");\n    CUtils::PrintMessage(\"\");\n\n    vsLines.push_back(\"\");\n    CString sNick;\n    do {\n        CUtils::GetInput(\"Username\", sUser, \"\", \"alphanumeric\");\n    } while (!CUser::IsValidUserName(sUser));\n\n    vsLines.push_back(\"<User \" + sUser + \">\");\n    CString sSalt;\n    sAnswer = CUtils::GetSaltedHashPass(sSalt);\n    vsLines.push_back(\"\\tPass       = \" + CUtils::sDefaultHash + \"#\" + sAnswer +\n                      \"#\" + sSalt + \"#\");\n\n    vsLines.push_back(\"\\tAdmin      = true\");\n\n    CUtils::GetInput(\"Nick\", sNick, CUser::MakeCleanUserName(sUser));\n    vsLines.push_back(\"\\tNick       = \" + sNick);\n    CUtils::GetInput(\"Alternate nick\", sAnswer, sNick + \"_\");\n    if (!sAnswer.empty()) {\n        vsLines.push_back(\"\\tAltNick    = \" + sAnswer);\n    }\n    CUtils::GetInput(\"Ident\", sAnswer, sUser);\n    vsLines.push_back(\"\\tIdent      = \" + sAnswer);\n    CUtils::GetInput(\"Real name\", sAnswer, \"\", \"optional\");\n    if (!sAnswer.empty()) {\n        vsLines.push_back(\"\\tRealName   = \" + sAnswer);\n    }\n    CUtils::GetInput(\"Bind host\", sAnswer, \"\", \"optional\");\n    if (!sAnswer.empty()) {\n        vsLines.push_back(\"\\tBindHost   = \" + sAnswer);\n    }\n\n    set<CModInfo> ssUserMods;\n    GetModules().GetDefaultMods(ssUserMods, CModInfo::UserModule);\n    vector<CString> vsUserModNames;\n    for (const CModInfo& Info : ssUserMods) {\n        vsUserModNames.push_back(Info.GetName());\n        vsLines.push_back(\"\\tLoadModule = \" + Info.GetName());\n    }\n    CUtils::PrintMessage(\n        \"Enabled user modules [\" +\n        CString(\", \").Join(vsUserModNames.begin(), vsUserModNames.end()) + \"]\");\n\n    CUtils::PrintMessage(\"\");\n    if (CUtils::GetBoolInput(\"Set up a network?\", true)) {\n        vsLines.push_back(\"\");\n\n        CUtils::PrintMessage(\"\");\n        CUtils::PrintMessage(\"-- Network settings --\");\n        CUtils::PrintMessage(\"\");\n\n        do {\n            CUtils::GetInput(\"Name\", sNetwork, \"freenode\");\n        } while (!CIRCNetwork::IsValidNetwork(sNetwork));\n\n        vsLines.push_back(\"\\t<Network \" + sNetwork + \">\");\n\n        set<CModInfo> ssNetworkMods;\n        GetModules().GetDefaultMods(ssNetworkMods, CModInfo::NetworkModule);\n        vector<CString> vsNetworkModNames;\n        for (const CModInfo& Info : ssNetworkMods) {\n            vsNetworkModNames.push_back(Info.GetName());\n            vsLines.push_back(\"\\t\\tLoadModule = \" + Info.GetName());\n        }\n\n        CString sHost, sPass, sHint;\n        bool bSSL = false;\n        unsigned int uServerPort = 0;\n\n        if (sNetwork.Equals(\"freenode\")) {\n            sHost = \"chat.freenode.net\";\n#ifdef HAVE_LIBSSL\n            bSSL = true;\n#endif\n        } else {\n            sHint = \"host only\";\n        }\n\n        while (!CUtils::GetInput(\"Server host\", sHost, sHost, sHint) ||\n               !CServer::IsValidHostName(sHost))\n            ;\n#ifdef HAVE_LIBSSL\n        bSSL = CUtils::GetBoolInput(\"Server uses SSL?\", bSSL);\n#endif\n        while (!CUtils::GetNumInput(\"Server port\", uServerPort, 1, 65535,\n                                    bSSL ? 6697 : 6667))\n            ;\n        CUtils::GetInput(\"Server password (probably empty)\", sPass);\n\n        vsLines.push_back(\"\\t\\tServer     = \" + sHost + ((bSSL) ? \" +\" : \" \") +\n                          CString(uServerPort) + \" \" + sPass);\n\n        CString sChans;\n        if (CUtils::GetInput(\"Initial channels\", sChans)) {\n            vsLines.push_back(\"\");\n            VCString vsChans;\n            sChans.Replace(\",\", \" \");\n            sChans.Replace(\";\", \" \");\n            sChans.Split(\" \", vsChans, false, \"\", \"\", true, true);\n            for (const CString& sChan : vsChans) {\n                vsLines.push_back(\"\\t\\t<Chan \" + sChan + \">\");\n                vsLines.push_back(\"\\t\\t</Chan>\");\n            }\n        }\n\n        CUtils::PrintMessage(\"Enabled network modules [\" +\n                             CString(\", \").Join(vsNetworkModNames.begin(),\n                                                vsNetworkModNames.end()) +\n                             \"]\");\n\n        vsLines.push_back(\"\\t</Network>\");\n    }\n\n    vsLines.push_back(\"</User>\");\n\n    CUtils::PrintMessage(\"\");\n    // !User\n\n    CFile File;\n    bool bFileOK, bFileOpen = false;\n    do {\n        CUtils::PrintAction(\"Writing config [\" + m_sConfigFile + \"]\");\n\n        bFileOK = true;\n        if (CFile::Exists(m_sConfigFile)) {\n            if (!File.TryExLock(m_sConfigFile)) {\n                CUtils::PrintStatus(false,\n                                    \"ZNC is currently running on this config.\");\n                bFileOK = false;\n            } else {\n                File.Close();\n                CUtils::PrintStatus(false, \"This config already exists.\");\n                if (CUtils::GetBoolInput(\n                        \"Are you sure you want to overwrite it?\", false))\n                    CUtils::PrintAction(\"Overwriting config [\" + m_sConfigFile +\n                                        \"]\");\n                else\n                    bFileOK = false;\n            }\n        }\n\n        if (bFileOK) {\n            File.SetFileName(m_sConfigFile);\n            if (File.Open(O_WRONLY | O_CREAT | O_TRUNC, 0600)) {\n                bFileOpen = true;\n            } else {\n                CUtils::PrintStatus(false, \"Unable to open file\");\n                bFileOK = false;\n            }\n        }\n        if (!bFileOK) {\n            while (!CUtils::GetInput(\"Please specify an alternate location\",\n                                     m_sConfigFile, \"\",\n                                     \"or \\\"stdout\\\" for displaying the config\"))\n                ;\n            if (m_sConfigFile.Equals(\"stdout\"))\n                bFileOK = true;\n            else\n                m_sConfigFile = ExpandConfigPath(m_sConfigFile);\n        }\n    } while (!bFileOK);\n\n    if (!bFileOpen) {\n        CUtils::PrintMessage(\"\");\n        CUtils::PrintMessage(\"Printing the new config to stdout:\");\n        CUtils::PrintMessage(\"\");\n        cout << endl << \"------------------------------------------------------\"\n                        \"----------------------\" << endl << endl;\n    }\n\n    for (const CString& sLine : vsLines) {\n        if (bFileOpen) {\n            File.Write(sLine + \"\\n\");\n        } else {\n            cout << sLine << endl;\n        }\n    }\n\n    if (bFileOpen) {\n        File.Close();\n        if (File.HadError())\n            CUtils::PrintStatus(false,\n                                \"There was an error while writing the config\");\n        else\n            CUtils::PrintStatus(true);\n    } else {\n        cout << endl << \"------------------------------------------------------\"\n                        \"----------------------\" << endl << endl;\n    }\n\n    if (File.HadError()) {\n        bFileOpen = false;\n        CUtils::PrintMessage(\"Printing the new config to stdout instead:\");\n        cout << endl << \"------------------------------------------------------\"\n                        \"----------------------\" << endl << endl;\n        for (const CString& sLine : vsLines) {\n            cout << sLine << endl;\n        }\n        cout << endl << \"------------------------------------------------------\"\n                        \"----------------------\" << endl << endl;\n    }\n\n    const CString sProtocol(bListenSSL ? \"https\" : \"http\");\n    const CString sSSL(bListenSSL ? \"+\" : \"\");\n    CUtils::PrintMessage(\"\");\n    CUtils::PrintMessage(\n        \"To connect to this ZNC you need to connect to it as your IRC server\",\n        true);\n    CUtils::PrintMessage(\n        \"using the port that you supplied.  You have to supply your login info\",\n        true);\n    CUtils::PrintMessage(\n        \"as the IRC server password like this: user/network:pass.\", true);\n    CUtils::PrintMessage(\"\");\n    CUtils::PrintMessage(\"Try something like this in your IRC client...\", true);\n    CUtils::PrintMessage(\"/server <znc_server_ip> \" + sSSL +\n                             CString(uListenPort) + \" \" + sUser + \":<pass>\",\n                         true);\n    CUtils::PrintMessage(\"\");\n    CUtils::PrintMessage(\n        \"To manage settings, users and networks, point your web browser to\",\n        true);\n    CUtils::PrintMessage(\n        sProtocol + \"://<znc_server_ip>:\" + CString(uListenPort) + \"/\", true);\n    CUtils::PrintMessage(\"\");\n\n    File.UnLock();\n\n    bool bWantLaunch = bFileOpen;\n    if (bWantLaunch) {\n        // \"export ZNC_NO_LAUNCH_AFTER_MAKECONF=1\" would cause znc --makeconf to\n        // not offer immediate launch.\n        // Useful for distros which want to create config when znc package is\n        // installed.\n        // See https://github.com/znc/znc/pull/257\n        char* szNoLaunch = getenv(\"ZNC_NO_LAUNCH_AFTER_MAKECONF\");\n        if (szNoLaunch && *szNoLaunch == '1') {\n            bWantLaunch = false;\n        }\n    }\n    if (bWantLaunch) {\n        bWantLaunch = CUtils::GetBoolInput(\"Launch ZNC now?\", true);\n    }\n    return bWantLaunch;\n}\n\nvoid CZNC::BackupConfigOnce(const CString& sSuffix) {\n    static bool didBackup = false;\n    if (didBackup) return;\n    didBackup = true;\n\n    CUtils::PrintAction(\"Creating a config backup\");\n\n    CString sBackup = CDir::ChangeDir(m_sConfigFile, \"../znc.conf.\" + sSuffix);\n    if (CFile::Copy(m_sConfigFile, sBackup))\n        CUtils::PrintStatus(true, sBackup);\n    else\n        CUtils::PrintStatus(false, strerror(errno));\n}\n\nbool CZNC::ParseConfig(const CString& sConfig, CString& sError) {\n    m_sConfigFile = ExpandConfigPath(sConfig, false);\n\n    CConfig config;\n    if (!ReadConfig(config, sError)) return false;\n\n    if (!LoadGlobal(config, sError)) return false;\n\n    if (!LoadUsers(config, sError)) return false;\n\n    return true;\n}\n\nbool CZNC::ReadConfig(CConfig& config, CString& sError) {\n    sError.clear();\n\n    CUtils::PrintAction(\"Opening config [\" + m_sConfigFile + \"]\");\n\n    if (!CFile::Exists(m_sConfigFile)) {\n        sError = \"No such file\";\n        CUtils::PrintStatus(false, sError);\n        CUtils::PrintMessage(\n            \"Restart ZNC with the --makeconf option if you wish to create this \"\n            \"config.\");\n        return false;\n    }\n\n    if (!CFile::IsReg(m_sConfigFile)) {\n        sError = \"Not a file\";\n        CUtils::PrintStatus(false, sError);\n        return false;\n    }\n\n    CFile* pFile = new CFile(m_sConfigFile);\n\n    // need to open the config file Read/Write for fcntl()\n    // exclusive locking to work properly!\n    if (!pFile->Open(m_sConfigFile, O_RDWR)) {\n        sError = \"Can not open config file\";\n        CUtils::PrintStatus(false, sError);\n        delete pFile;\n        return false;\n    }\n\n    if (!pFile->TryExLock()) {\n        sError = \"ZNC is already running on this config.\";\n        CUtils::PrintStatus(false, sError);\n        delete pFile;\n        return false;\n    }\n\n    // (re)open the config file\n    delete m_pLockFile;\n    m_pLockFile = pFile;\n    CFile& File = *pFile;\n\n    if (!config.Parse(File, sError)) {\n        CUtils::PrintStatus(false, sError);\n        return false;\n    }\n    CUtils::PrintStatus(true);\n\n    // check if config is from old ZNC version and\n    // create a backup file if necessary\n    CString sSavedVersion;\n    config.FindStringEntry(\"version\", sSavedVersion);\n    if (sSavedVersion.empty()) {\n        CUtils::PrintError(\n            \"Config does not contain a version identifier. It may be be too \"\n            \"old or corrupt.\");\n        return false;\n    }\n\n    tuple<unsigned int, unsigned int> tSavedVersion =\n        make_tuple(sSavedVersion.Token(0, false, \".\").ToUInt(),\n                   sSavedVersion.Token(1, false, \".\").ToUInt());\n    tuple<unsigned int, unsigned int> tCurrentVersion =\n        make_tuple(VERSION_MAJOR, VERSION_MINOR);\n    if (tSavedVersion < tCurrentVersion) {\n        CUtils::PrintMessage(\"Found old config from ZNC \" + sSavedVersion +\n                             \". Saving a backup of it.\");\n        BackupConfigOnce(\"pre-\" + CString(VERSION_STR));\n    } else if (tSavedVersion > tCurrentVersion) {\n        CUtils::PrintError(\"Config was saved from ZNC \" + sSavedVersion +\n                           \". It may or may not work with current ZNC \" +\n                           GetVersion());\n    }\n\n    return true;\n}\n\nbool CZNC::RehashConfig(CString& sError) {\n    ALLMODULECALL(OnPreRehash(), NOTHING);\n\n    CConfig config;\n    if (!ReadConfig(config, sError)) return false;\n\n    if (!LoadGlobal(config, sError)) return false;\n\n    // do not reload users - it's dangerous!\n\n    ALLMODULECALL(OnPostRehash(), NOTHING);\n    return true;\n}\n\nbool CZNC::LoadGlobal(CConfig& config, CString& sError) {\n    sError.clear();\n\n    MCString msModules;  // Modules are queued for later loading\n\n    VCString vsList;\n    config.FindStringVector(\"loadmodule\", vsList);\n    for (const CString& sModLine : vsList) {\n        CString sModName = sModLine.Token(0);\n        CString sArgs = sModLine.Token(1, true);\n\n        // compatibility for pre-1.0 configs\n        CString sSavedVersion;\n        config.FindStringEntry(\"version\", sSavedVersion);\n        tuple<unsigned int, unsigned int> tSavedVersion =\n            make_tuple(sSavedVersion.Token(0, false, \".\").ToUInt(),\n                       sSavedVersion.Token(1, false, \".\").ToUInt());\n        if (sModName == \"saslauth\" && tSavedVersion < make_tuple(0, 207)) {\n            CUtils::PrintMessage(\n                \"saslauth module was renamed to cyrusauth. Loading cyrusauth \"\n                \"instead.\");\n            sModName = \"cyrusauth\";\n        }\n        // end-compatibility for pre-1.0 configs\n\n        if (msModules.find(sModName) != msModules.end()) {\n            sError = \"Module [\" + sModName + \"] already loaded\";\n            CUtils::PrintError(sError);\n            return false;\n        }\n        CString sModRet;\n        CModule* pOldMod;\n\n        pOldMod = GetModules().FindModule(sModName);\n        if (!pOldMod) {\n            CUtils::PrintAction(\"Loading global module [\" + sModName + \"]\");\n\n            bool bModRet =\n                GetModules().LoadModule(sModName, sArgs, CModInfo::GlobalModule,\n                                        nullptr, nullptr, sModRet);\n\n            CUtils::PrintStatus(bModRet, bModRet ? \"\" : sModRet);\n            if (!bModRet) {\n                sError = sModRet;\n                return false;\n            }\n        } else if (pOldMod->GetArgs() != sArgs) {\n            CUtils::PrintAction(\"Reloading global module [\" + sModName + \"]\");\n\n            bool bModRet = GetModules().ReloadModule(sModName, sArgs, nullptr,\n                                                     nullptr, sModRet);\n\n            CUtils::PrintStatus(bModRet, sModRet);\n            if (!bModRet) {\n                sError = sModRet;\n                return false;\n            }\n        } else\n            CUtils::PrintMessage(\"Module [\" + sModName + \"] already loaded.\");\n\n        msModules[sModName] = sArgs;\n    }\n\n    m_vsMotd.clear();\n    config.FindStringVector(\"motd\", vsList);\n    for (const CString& sMotd : vsList) {\n        AddMotd(sMotd);\n    }\n\n    if (config.FindStringVector(\"bindhost\", vsList)) {\n        CUtils::PrintStatus(false,\n                            \"WARNING: the global BindHost list is deprecated. \"\n                            \"Ignoring the following lines:\");\n        for (const CString& sHost : vsList) {\n            CUtils::PrintStatus(false, \"BindHost = \" + sHost);\n        }\n    }\n    if (config.FindStringVector(\"vhost\", vsList)) {\n        CUtils::PrintStatus(false,\n                            \"WARNING: the global vHost list is deprecated. \"\n                            \"Ignoring the following lines:\");\n        for (const CString& sHost : vsList) {\n            CUtils::PrintStatus(false, \"vHost = \" + sHost);\n        }\n    }\n\n    m_vsTrustedProxies.clear();\n    config.FindStringVector(\"trustedproxy\", vsList);\n    for (const CString& sProxy : vsList) {\n        AddTrustedProxy(sProxy);\n    }\n\n    CString sVal;\n    if (config.FindStringEntry(\"pidfile\", sVal)) m_sPidFile = sVal;\n    if (config.FindStringEntry(\"statusprefix\", sVal)) m_sStatusPrefix = sVal;\n    if (config.FindStringEntry(\"sslcertfile\", sVal)) m_sSSLCertFile = sVal;\n    if (config.FindStringEntry(\"sslkeyfile\", sVal)) m_sSSLKeyFile = sVal;\n    if (config.FindStringEntry(\"ssldhparamfile\", sVal))\n        m_sSSLDHParamFile = sVal;\n    if (config.FindStringEntry(\"sslciphers\", sVal)) m_sSSLCiphers = sVal;\n    if (config.FindStringEntry(\"skin\", sVal)) SetSkinName(sVal);\n    if (config.FindStringEntry(\"connectdelay\", sVal))\n        SetConnectDelay(sVal.ToUInt());\n    if (config.FindStringEntry(\"serverthrottle\", sVal))\n        m_sConnectThrottle.SetTTL(sVal.ToUInt() * 1000);\n    if (config.FindStringEntry(\"anoniplimit\", sVal))\n        m_uiAnonIPLimit = sVal.ToUInt();\n    if (config.FindStringEntry(\"maxbuffersize\", sVal))\n        m_uiMaxBufferSize = sVal.ToUInt();\n    if (config.FindStringEntry(\"protectwebsessions\", sVal))\n        m_bProtectWebSessions = sVal.ToBool();\n    if (config.FindStringEntry(\"hideversion\", sVal))\n        m_bHideVersion = sVal.ToBool();\n    if (config.FindStringEntry(\"authonlyviamodule\", sVal))\n        m_bAuthOnlyViaModule = sVal.ToBool();\n    if (config.FindStringEntry(\"sslprotocols\", sVal)) {\n        if (!SetSSLProtocols(sVal)) {\n            VCString vsProtocols = GetAvailableSSLProtocols();\n            CUtils::PrintError(\"Invalid SSLProtocols value [\" + sVal + \"]\");\n            CUtils::PrintError(\n                \"The syntax is [SSLProtocols = [+|-]<protocol> ...]\");\n            CUtils::PrintError(\n                \"Available protocols are [\" +\n                CString(\", \").Join(vsProtocols.begin(), vsProtocols.end()) +\n                \"]\");\n            return false;\n        }\n    }\n    if (config.FindStringEntry(\"configwritedelay\", sVal))\n        m_uiConfigWriteDelay = sVal.ToUInt();\n\n    UnloadRemovedModules(msModules);\n\n    if (!LoadListeners(config, sError)) return false;\n\n    return true;\n}\n\nbool CZNC::LoadUsers(CConfig& config, CString& sError) {\n    sError.clear();\n\n    m_msUsers.clear();\n\n    CConfig::SubConfig subConf;\n    config.FindSubConfig(\"user\", subConf);\n\n    for (const auto& subIt : subConf) {\n        const CString& sUserName = subIt.first;\n        CConfig* pSubConf = subIt.second.m_pSubConfig;\n\n        CUtils::PrintMessage(\"Loading user [\" + sUserName + \"]\");\n\n        std::unique_ptr<CUser> pUser(new CUser(sUserName));\n\n        if (!m_sStatusPrefix.empty()) {\n            if (!pUser->SetStatusPrefix(m_sStatusPrefix)) {\n                sError = \"Invalid StatusPrefix [\" + m_sStatusPrefix +\n                         \"] Must be 1-5 chars, no spaces.\";\n                CUtils::PrintError(sError);\n                return false;\n            }\n        }\n\n        if (!pUser->ParseConfig(pSubConf, sError)) {\n            CUtils::PrintError(sError);\n            return false;\n        }\n\n        if (!pSubConf->empty()) {\n            sError = \"Unhandled lines in config for User [\" + sUserName + \"]!\";\n            CUtils::PrintError(sError);\n            DumpConfig(pSubConf);\n            return false;\n        }\n\n        CString sErr;\n        if (!AddUser(pUser.release(), sErr, true)) {\n            sError = \"Invalid user [\" + sUserName + \"] \" + sErr;\n        }\n\n        if (!sError.empty()) {\n            CUtils::PrintError(sError);\n            pUser->SetBeingDeleted(true);\n            return false;\n        }\n    }\n\n    if (m_msUsers.empty()) {\n        sError = \"You must define at least one user in your config.\";\n        CUtils::PrintError(sError);\n        return false;\n    }\n\n    return true;\n}\n\nbool CZNC::LoadListeners(CConfig& config, CString& sError) {\n    sError.clear();\n\n    // Delete all listeners\n    while (!m_vpListeners.empty()) {\n        delete m_vpListeners[0];\n        m_vpListeners.erase(m_vpListeners.begin());\n    }\n\n    // compatibility for pre-1.0 configs\n    const char* szListenerEntries[] = {\"listen\",   \"listen6\",   \"listen4\",\n                                       \"listener\", \"listener6\", \"listener4\"};\n\n    VCString vsList;\n    config.FindStringVector(\"loadmodule\", vsList);\n\n    // This has to be after SSLCertFile is handled since it uses that value\n    for (const char* szEntry : szListenerEntries) {\n        config.FindStringVector(szEntry, vsList);\n        for (const CString& sListener : vsList) {\n            if (!AddListener(szEntry + CString(\" \") + sListener, sError))\n                return false;\n        }\n    }\n    // end-compatibility for pre-1.0 configs\n\n    CConfig::SubConfig subConf;\n    config.FindSubConfig(\"listener\", subConf);\n\n    for (const auto& subIt : subConf) {\n        CConfig* pSubConf = subIt.second.m_pSubConfig;\n        if (!AddListener(pSubConf, sError)) return false;\n        if (!pSubConf->empty()) {\n            sError = \"Unhandled lines in Listener config!\";\n            CUtils::PrintError(sError);\n\n            CZNC::DumpConfig(pSubConf);\n            return false;\n        }\n    }\n\n    if (m_vpListeners.empty()) {\n        sError = \"You must supply at least one Listener in your config.\";\n        CUtils::PrintError(sError);\n        return false;\n    }\n\n    return true;\n}\n\nvoid CZNC::UnloadRemovedModules(const MCString& msModules) {\n    // unload modules which are no longer in the config\n\n    set<CString> ssUnload;\n    for (CModule* pCurMod : GetModules()) {\n        if (msModules.find(pCurMod->GetModName()) == msModules.end())\n            ssUnload.insert(pCurMod->GetModName());\n    }\n\n    for (const CString& sMod : ssUnload) {\n        if (GetModules().UnloadModule(sMod))\n            CUtils::PrintMessage(\"Unloaded global module [\" + sMod + \"]\");\n        else\n            CUtils::PrintMessage(\"Could not unload [\" + sMod + \"]\");\n    }\n}\n\nvoid CZNC::DumpConfig(const CConfig* pConfig) {\n    CConfig::EntryMapIterator eit = pConfig->BeginEntries();\n    for (; eit != pConfig->EndEntries(); ++eit) {\n        const CString& sKey = eit->first;\n        const VCString& vsList = eit->second;\n        VCString::const_iterator it = vsList.begin();\n        for (; it != vsList.end(); ++it) {\n            CUtils::PrintError(sKey + \" = \" + *it);\n        }\n    }\n\n    CConfig::SubConfigMapIterator sit = pConfig->BeginSubConfigs();\n    for (; sit != pConfig->EndSubConfigs(); ++sit) {\n        const CString& sKey = sit->first;\n        const CConfig::SubConfig& sSub = sit->second;\n        CConfig::SubConfig::const_iterator it = sSub.begin();\n\n        for (; it != sSub.end(); ++it) {\n            CUtils::PrintError(\"SubConfig [\" + sKey + \" \" + it->first + \"]:\");\n            DumpConfig(it->second.m_pSubConfig);\n        }\n    }\n}\n\nvoid CZNC::ClearTrustedProxies() { m_vsTrustedProxies.clear(); }\n\nbool CZNC::AddTrustedProxy(const CString& sHost) {\n    if (sHost.empty()) {\n        return false;\n    }\n\n    for (const CString& sTrustedProxy : m_vsTrustedProxies) {\n        if (sTrustedProxy.Equals(sHost)) {\n            return false;\n        }\n    }\n\n    m_vsTrustedProxies.push_back(sHost);\n    return true;\n}\n\nbool CZNC::RemTrustedProxy(const CString& sHost) {\n    VCString::iterator it;\n    for (it = m_vsTrustedProxies.begin(); it != m_vsTrustedProxies.end();\n         ++it) {\n        if (sHost.Equals(*it)) {\n            m_vsTrustedProxies.erase(it);\n            return true;\n        }\n    }\n\n    return false;\n}\n\nvoid CZNC::Broadcast(const CString& sMessage, bool bAdminOnly, CUser* pSkipUser,\n                     CClient* pSkipClient) {\n    for (const auto& it : m_msUsers) {\n        if (bAdminOnly && !it.second->IsAdmin()) continue;\n\n        if (it.second != pSkipUser) {\n            // TODO: translate message to user's language\n            CString sMsg = sMessage;\n\n            bool bContinue = false;\n            USERMODULECALL(OnBroadcast(sMsg), it.second, nullptr, &bContinue);\n            if (bContinue) continue;\n\n            it.second->PutStatusNotice(\"*** \" + sMsg, nullptr, pSkipClient);\n        }\n    }\n}\n\nCModule* CZNC::FindModule(const CString& sModName, const CString& sUsername) {\n    if (sUsername.empty()) {\n        return CZNC::Get().GetModules().FindModule(sModName);\n    }\n\n    CUser* pUser = FindUser(sUsername);\n\n    return (!pUser) ? nullptr : pUser->GetModules().FindModule(sModName);\n}\n\nCModule* CZNC::FindModule(const CString& sModName, CUser* pUser) {\n    if (pUser) {\n        return pUser->GetModules().FindModule(sModName);\n    }\n\n    return CZNC::Get().GetModules().FindModule(sModName);\n}\n\nbool CZNC::UpdateModule(const CString& sModule) {\n    CModule* pModule;\n\n    map<CUser*, CString> musLoaded;\n    map<CIRCNetwork*, CString> mnsLoaded;\n\n    // Unload the module for every user and network\n    for (const auto& it : m_msUsers) {\n        CUser* pUser = it.second;\n\n        pModule = pUser->GetModules().FindModule(sModule);\n        if (pModule) {\n            musLoaded[pUser] = pModule->GetArgs();\n            pUser->GetModules().UnloadModule(sModule);\n        }\n\n        // See if the user has this module loaded to a network\n        vector<CIRCNetwork*> vNetworks = pUser->GetNetworks();\n        for (CIRCNetwork* pNetwork : vNetworks) {\n            pModule = pNetwork->GetModules().FindModule(sModule);\n            if (pModule) {\n                mnsLoaded[pNetwork] = pModule->GetArgs();\n                pNetwork->GetModules().UnloadModule(sModule);\n            }\n        }\n    }\n\n    // Unload the global module\n    bool bGlobal = false;\n    CString sGlobalArgs;\n\n    pModule = GetModules().FindModule(sModule);\n    if (pModule) {\n        bGlobal = true;\n        sGlobalArgs = pModule->GetArgs();\n        GetModules().UnloadModule(sModule);\n    }\n\n    // Lets reload everything\n    bool bError = false;\n    CString sErr;\n\n    // Reload the global module\n    if (bGlobal) {\n        if (!GetModules().LoadModule(sModule, sGlobalArgs,\n                                     CModInfo::GlobalModule, nullptr, nullptr,\n                                     sErr)) {\n            DEBUG(\"Failed to reload [\" << sModule << \"] globally [\" << sErr\n                                       << \"]\");\n            bError = true;\n        }\n    }\n\n    // Reload the module for all users\n    for (const auto& it : musLoaded) {\n        CUser* pUser = it.first;\n        const CString& sArgs = it.second;\n\n        if (!pUser->GetModules().LoadModule(\n                sModule, sArgs, CModInfo::UserModule, pUser, nullptr, sErr)) {\n            DEBUG(\"Failed to reload [\" << sModule << \"] for [\"\n                                       << pUser->GetUserName() << \"] [\" << sErr\n                                       << \"]\");\n            bError = true;\n        }\n    }\n\n    // Reload the module for all networks\n    for (const auto& it : mnsLoaded) {\n        CIRCNetwork* pNetwork = it.first;\n        const CString& sArgs = it.second;\n\n        if (!pNetwork->GetModules().LoadModule(\n                sModule, sArgs, CModInfo::NetworkModule, pNetwork->GetUser(),\n                pNetwork, sErr)) {\n            DEBUG(\"Failed to reload [\"\n                  << sModule << \"] for [\" << pNetwork->GetUser()->GetUserName()\n                  << \"/\" << pNetwork->GetName() << \"] [\" << sErr << \"]\");\n            bError = true;\n        }\n    }\n\n    return !bError;\n}\n\nCUser* CZNC::FindUser(const CString& sUsername) {\n    map<CString, CUser*>::iterator it = m_msUsers.find(sUsername);\n\n    if (it != m_msUsers.end()) {\n        return it->second;\n    }\n\n    return nullptr;\n}\n\nbool CZNC::DeleteUser(const CString& sUsername) {\n    CUser* pUser = FindUser(sUsername);\n\n    if (!pUser) {\n        return false;\n    }\n\n    m_msDelUsers[pUser->GetUserName()] = pUser;\n    return true;\n}\n\nbool CZNC::AddUser(CUser* pUser, CString& sErrorRet, bool bStartup) {\n    if (FindUser(pUser->GetUserName()) != nullptr) {\n        sErrorRet = t_s(\"User already exists\");\n        DEBUG(\"User [\" << pUser->GetUserName() << \"] - already exists\");\n        return false;\n    }\n    if (!pUser->IsValid(sErrorRet)) {\n        DEBUG(\"Invalid user [\" << pUser->GetUserName() << \"] - [\" << sErrorRet\n                               << \"]\");\n        return false;\n    }\n    bool bFailed = false;\n\n    // do not call OnAddUser hook during ZNC startup\n    if (!bStartup) {\n        GLOBALMODULECALL(OnAddUser(*pUser, sErrorRet), &bFailed);\n    }\n\n    if (bFailed) {\n        DEBUG(\"AddUser [\" << pUser->GetUserName() << \"] aborted by a module [\"\n                          << sErrorRet << \"]\");\n        return false;\n    }\n    m_msUsers[pUser->GetUserName()] = pUser;\n    return true;\n}\n\nCListener* CZNC::FindListener(u_short uPort, const CString& sBindHost,\n                              EAddrType eAddr) {\n    for (CListener* pListener : m_vpListeners) {\n        if (pListener->GetPort() != uPort) continue;\n        if (pListener->GetBindHost() != sBindHost) continue;\n        if (pListener->GetAddrType() != eAddr) continue;\n        return pListener;\n    }\n    return nullptr;\n}\n\nbool CZNC::AddListener(const CString& sLine, CString& sError) {\n    CString sName = sLine.Token(0);\n    CString sValue = sLine.Token(1, true);\n\n    EAddrType eAddr = ADDR_ALL;\n    if (sName.Equals(\"Listen4\") || sName.Equals(\"Listen\") ||\n        sName.Equals(\"Listener4\")) {\n        eAddr = ADDR_IPV4ONLY;\n    }\n    if (sName.Equals(\"Listener6\")) {\n        eAddr = ADDR_IPV6ONLY;\n    }\n\n    CListener::EAcceptType eAccept = CListener::ACCEPT_ALL;\n    if (sValue.TrimPrefix(\"irc_only \"))\n        eAccept = CListener::ACCEPT_IRC;\n    else if (sValue.TrimPrefix(\"web_only \"))\n        eAccept = CListener::ACCEPT_HTTP;\n\n    bool bSSL = false;\n    CString sPort;\n    CString sBindHost;\n\n    if (ADDR_IPV4ONLY == eAddr) {\n        sValue.Replace(\":\", \" \");\n    }\n\n    if (sValue.Contains(\" \")) {\n        sBindHost = sValue.Token(0, false, \" \");\n        sPort = sValue.Token(1, true, \" \");\n    } else {\n        sPort = sValue;\n    }\n\n    if (sPort.TrimPrefix(\"+\")) {\n        bSSL = true;\n    }\n\n    // No support for URIPrefix for old-style configs.\n    CString sURIPrefix;\n    unsigned short uPort = sPort.ToUShort();\n    return AddListener(uPort, sBindHost, sURIPrefix, bSSL, eAddr, eAccept,\n                       sError);\n}\n\nbool CZNC::AddListener(unsigned short uPort, const CString& sBindHost,\n                       const CString& sURIPrefixRaw, bool bSSL, EAddrType eAddr,\n                       CListener::EAcceptType eAccept, CString& sError) {\n    CString sHostComment;\n\n    if (!sBindHost.empty()) {\n        sHostComment = \" on host [\" + sBindHost + \"]\";\n    }\n\n    CString sIPV6Comment;\n\n    switch (eAddr) {\n        case ADDR_ALL:\n            sIPV6Comment = \"\";\n            break;\n        case ADDR_IPV4ONLY:\n            sIPV6Comment = \" using ipv4\";\n            break;\n        case ADDR_IPV6ONLY:\n            sIPV6Comment = \" using ipv6\";\n    }\n\n    CUtils::PrintAction(\"Binding to port [\" + CString((bSSL) ? \"+\" : \"\") +\n                        CString(uPort) + \"]\" + sHostComment + sIPV6Comment);\n\n#ifndef HAVE_IPV6\n    if (ADDR_IPV6ONLY == eAddr) {\n        sError = t_s(\"IPv6 is not enabled\");\n        CUtils::PrintStatus(false, sError);\n        return false;\n    }\n#endif\n\n#ifndef HAVE_LIBSSL\n    if (bSSL) {\n        sError = t_s(\"SSL is not enabled\");\n        CUtils::PrintStatus(false, sError);\n        return false;\n    }\n#else\n    CString sPemFile = GetPemLocation();\n\n    if (bSSL && !CFile::Exists(sPemFile)) {\n        sError = t_f(\"Unable to locate pem file: {1}\")(sPemFile);\n        CUtils::PrintStatus(false, sError);\n\n        // If stdin is e.g. /dev/null and we call GetBoolInput(),\n        // we are stuck in an endless loop!\n        if (isatty(0) &&\n            CUtils::GetBoolInput(\"Would you like to create a new pem file?\",\n                                 true)) {\n            sError.clear();\n            WritePemFile();\n        } else {\n            return false;\n        }\n\n        CUtils::PrintAction(\"Binding to port [+\" + CString(uPort) + \"]\" +\n                            sHostComment + sIPV6Comment);\n    }\n#endif\n    if (!uPort) {\n        sError = t_s(\"Invalid port\");\n        CUtils::PrintStatus(false, sError);\n        return false;\n    }\n\n    // URIPrefix must start with a slash and end without one.\n    CString sURIPrefix = CString(sURIPrefixRaw);\n    if (!sURIPrefix.empty()) {\n        if (!sURIPrefix.StartsWith(\"/\")) {\n            sURIPrefix = \"/\" + sURIPrefix;\n        }\n        if (sURIPrefix.EndsWith(\"/\")) {\n            sURIPrefix.TrimRight(\"/\");\n        }\n    }\n\n    CListener* pListener =\n        new CListener(uPort, sBindHost, sURIPrefix, bSSL, eAddr, eAccept);\n\n    if (!pListener->Listen()) {\n        sError = FormatBindError();\n        CUtils::PrintStatus(false, sError);\n        delete pListener;\n        return false;\n    }\n\n    m_vpListeners.push_back(pListener);\n    CUtils::PrintStatus(true);\n\n    return true;\n}\n\nbool CZNC::AddListener(CConfig* pConfig, CString& sError) {\n    CString sBindHost;\n    CString sURIPrefix;\n    bool bSSL;\n    bool b4;\n#ifdef HAVE_IPV6\n    bool b6 = true;\n#else\n    bool b6 = false;\n#endif\n    bool bIRC;\n    bool bWeb;\n    unsigned short uPort;\n    if (!pConfig->FindUShortEntry(\"port\", uPort)) {\n        sError = \"No port given\";\n        CUtils::PrintError(sError);\n        return false;\n    }\n    pConfig->FindStringEntry(\"host\", sBindHost);\n    pConfig->FindBoolEntry(\"ssl\", bSSL, false);\n    pConfig->FindBoolEntry(\"ipv4\", b4, true);\n    pConfig->FindBoolEntry(\"ipv6\", b6, b6);\n    pConfig->FindBoolEntry(\"allowirc\", bIRC, true);\n    pConfig->FindBoolEntry(\"allowweb\", bWeb, true);\n    pConfig->FindStringEntry(\"uriprefix\", sURIPrefix);\n\n    EAddrType eAddr;\n    if (b4 && b6) {\n        eAddr = ADDR_ALL;\n    } else if (b4 && !b6) {\n        eAddr = ADDR_IPV4ONLY;\n    } else if (!b4 && b6) {\n        eAddr = ADDR_IPV6ONLY;\n    } else {\n        sError = \"No address family given\";\n        CUtils::PrintError(sError);\n        return false;\n    }\n\n    CListener::EAcceptType eAccept;\n    if (bIRC && bWeb) {\n        eAccept = CListener::ACCEPT_ALL;\n    } else if (bIRC && !bWeb) {\n        eAccept = CListener::ACCEPT_IRC;\n    } else if (!bIRC && bWeb) {\n        eAccept = CListener::ACCEPT_HTTP;\n    } else {\n        sError = \"Either Web or IRC or both should be selected\";\n        CUtils::PrintError(sError);\n        return false;\n    }\n\n    return AddListener(uPort, sBindHost, sURIPrefix, bSSL, eAddr, eAccept,\n                       sError);\n}\n\nbool CZNC::AddListener(CListener* pListener) {\n    if (!pListener->GetRealListener()) {\n        // Listener doesn't actually listen\n        delete pListener;\n        return false;\n    }\n\n    // We don't check if there is an identical listener already listening\n    // since one can't listen on e.g. the same port multiple times\n\n    m_vpListeners.push_back(pListener);\n    return true;\n}\n\nbool CZNC::DelListener(CListener* pListener) {\n    auto it = std::find(m_vpListeners.begin(), m_vpListeners.end(), pListener);\n    if (it != m_vpListeners.end()) {\n        m_vpListeners.erase(it);\n        delete pListener;\n        return true;\n    }\n\n    return false;\n}\n\nCString CZNC::FormatBindError() {\n    CString sError = (errno == 0 ? t_s((\"unknown error, check the host name\"))\n                                 : CString(strerror(errno)));\n    return t_f(\"Unable to bind: {1}\")(sError);\n}\n\nstatic CZNC* s_pZNC = nullptr;\n\nvoid CZNC::CreateInstance() {\n    if (s_pZNC) abort();\n\n    s_pZNC = new CZNC();\n}\n\nCZNC& CZNC::Get() { return *s_pZNC; }\n\nvoid CZNC::DestroyInstance() {\n    delete s_pZNC;\n    s_pZNC = nullptr;\n}\n\nCZNC::TrafficStatsMap CZNC::GetTrafficStats(TrafficStatsPair& Users,\n                                            TrafficStatsPair& ZNC,\n                                            TrafficStatsPair& Total) {\n    TrafficStatsMap ret;\n    unsigned long long uiUsers_in, uiUsers_out, uiZNC_in, uiZNC_out;\n    const map<CString, CUser*>& msUsers = CZNC::Get().GetUserMap();\n\n    uiUsers_in = uiUsers_out = 0;\n    uiZNC_in = BytesRead();\n    uiZNC_out = BytesWritten();\n\n    for (const auto& it : msUsers) {\n        ret[it.first] =\n            TrafficStatsPair(it.second->BytesRead(), it.second->BytesWritten());\n        uiUsers_in += it.second->BytesRead();\n        uiUsers_out += it.second->BytesWritten();\n    }\n\n    for (Csock* pSock : m_Manager) {\n        CUser* pUser = nullptr;\n        if (pSock->GetSockName().StartsWith(\"IRC::\")) {\n            pUser = ((CIRCSock*)pSock)->GetNetwork()->GetUser();\n        } else if (pSock->GetSockName().StartsWith(\"USR::\")) {\n            pUser = ((CClient*)pSock)->GetUser();\n        }\n\n        if (pUser) {\n            ret[pUser->GetUserName()].first += pSock->GetBytesRead();\n            ret[pUser->GetUserName()].second += pSock->GetBytesWritten();\n            uiUsers_in += pSock->GetBytesRead();\n            uiUsers_out += pSock->GetBytesWritten();\n        } else {\n            uiZNC_in += pSock->GetBytesRead();\n            uiZNC_out += pSock->GetBytesWritten();\n        }\n    }\n\n    Users = TrafficStatsPair(uiUsers_in, uiUsers_out);\n    ZNC = TrafficStatsPair(uiZNC_in, uiZNC_out);\n    Total = TrafficStatsPair(uiUsers_in + uiZNC_in, uiUsers_out + uiZNC_out);\n\n    return ret;\n}\n\nCZNC::TrafficStatsMap CZNC::GetNetworkTrafficStats(const CString& sUsername,\n                                                   TrafficStatsPair& Total) {\n    TrafficStatsMap Networks;\n\n    CUser* pUser = FindUser(sUsername);\n    if (pUser) {\n        for (const CIRCNetwork* pNetwork : pUser->GetNetworks()) {\n            Networks[pNetwork->GetName()].first = pNetwork->BytesRead();\n            Networks[pNetwork->GetName()].second = pNetwork->BytesWritten();\n            Total.first += pNetwork->BytesRead();\n            Total.second += pNetwork->BytesWritten();\n        }\n\n        for (Csock* pSock : m_Manager) {\n            CIRCNetwork* pNetwork = nullptr;\n            if (pSock->GetSockName().StartsWith(\"IRC::\")) {\n                pNetwork = ((CIRCSock*)pSock)->GetNetwork();\n            } else if (pSock->GetSockName().StartsWith(\"USR::\")) {\n                pNetwork = ((CClient*)pSock)->GetNetwork();\n            }\n\n            if (pNetwork && pNetwork->GetUser() == pUser) {\n                Networks[pNetwork->GetName()].first = pSock->GetBytesRead();\n                Networks[pNetwork->GetName()].second = pSock->GetBytesWritten();\n                Total.first += pSock->GetBytesRead();\n                Total.second += pSock->GetBytesWritten();\n            }\n        }\n    }\n\n    return Networks;\n}\n\nvoid CZNC::AuthUser(std::shared_ptr<CAuthBase> AuthClass) {\n    // TODO unless the auth module calls it, CUser::IsHostAllowed() is not\n    // honoured\n    bool bReturn = false;\n    GLOBALMODULECALL(OnLoginAttempt(AuthClass), &bReturn);\n    if (bReturn) return;\n\n    CUser* pUser = FindUser(AuthClass->GetUsername());\n\n    if (!pUser || !pUser->CheckPass(AuthClass->GetPassword())) {\n        AuthClass->RefuseLogin(\"Invalid Password\");\n        return;\n    }\n\n    CString sHost = AuthClass->GetRemoteIP();\n\n    if (!pUser->IsHostAllowed(sHost)) {\n        AuthClass->RefuseLogin(\"Your host [\" + sHost + \"] is not allowed\");\n        return;\n    }\n\n    AuthClass->AcceptLogin(*pUser);\n}\n\nclass CConnectQueueTimer : public CCron {\n  public:\n    CConnectQueueTimer(int iSecs) : CCron() {\n        SetName(\"Connect users\");\n        Start(iSecs);\n        // Don't wait iSecs seconds for first timer run\n        m_bRunOnNextCall = true;\n    }\n    ~CConnectQueueTimer() override {\n        // This is only needed when ZNC shuts down:\n        // CZNC::~CZNC() sets its CConnectQueueTimer pointer to nullptr and\n        // calls the manager's Cleanup() which destroys all sockets and\n        // timers. If something calls CZNC::EnableConnectQueue() here\n        // (e.g. because a CIRCSock is destroyed), the socket manager\n        // deletes that timer almost immediately, but CZNC now got a\n        // dangling pointer to this timer which can crash later on.\n        //\n        // Unlikely but possible ;)\n        CZNC::Get().LeakConnectQueueTimer(this);\n    }\n\n  protected:\n    void RunJob() override {\n        list<CIRCNetwork*> ConnectionQueue;\n        list<CIRCNetwork*>& RealConnectionQueue =\n            CZNC::Get().GetConnectionQueue();\n\n        // Problem: If a network can't connect right now because e.g. it\n        // is throttled, it will re-insert itself into the connection\n        // queue. However, we must only give each network a single\n        // chance during this timer run.\n        //\n        // Solution: We move the connection queue to our local list at\n        // the beginning and work from that.\n        ConnectionQueue.swap(RealConnectionQueue);\n\n        while (!ConnectionQueue.empty()) {\n            CIRCNetwork* pNetwork = ConnectionQueue.front();\n            ConnectionQueue.pop_front();\n\n            if (pNetwork->Connect()) {\n                break;\n            }\n        }\n\n        /* Now re-insert anything that is left in our local list into\n         * the real connection queue.\n         */\n        RealConnectionQueue.splice(RealConnectionQueue.begin(),\n                                   ConnectionQueue);\n\n        if (RealConnectionQueue.empty()) {\n            DEBUG(\"ConnectQueueTimer done\");\n            CZNC::Get().DisableConnectQueue();\n        }\n    }\n};\n\nvoid CZNC::SetConnectDelay(unsigned int i) {\n    if (i < 1) {\n        // Don't hammer server with our failed connects\n        i = 1;\n    }\n    if (m_uiConnectDelay != i && m_pConnectQueueTimer != nullptr) {\n        m_pConnectQueueTimer->Start(i);\n    }\n    m_uiConnectDelay = i;\n}\n\nVCString CZNC::GetAvailableSSLProtocols() {\n    // NOTE: keep in sync with SetSSLProtocols()\n    return {\"SSLv2\", \"SSLv3\", \"TLSv1\", \"TLSV1.1\", \"TLSv1.2\"};\n}\n\nbool CZNC::SetSSLProtocols(const CString& sProtocols) {\n    VCString vsProtocols;\n    sProtocols.Split(\" \", vsProtocols, false, \"\", \"\", true, true);\n\n    unsigned int uDisabledProtocols = Csock::EDP_SSL;\n    for (CString& sProtocol : vsProtocols) {\n        unsigned int uFlag = 0;\n        bool bEnable = sProtocol.TrimPrefix(\"+\");\n        bool bDisable = sProtocol.TrimPrefix(\"-\");\n\n        // NOTE: keep in sync with GetAvailableSSLProtocols()\n        if (sProtocol.Equals(\"All\")) {\n            uFlag = ~0;\n        } else if (sProtocol.Equals(\"SSLv2\")) {\n            uFlag = Csock::EDP_SSLv2;\n        } else if (sProtocol.Equals(\"SSLv3\")) {\n            uFlag = Csock::EDP_SSLv3;\n        } else if (sProtocol.Equals(\"TLSv1\")) {\n            uFlag = Csock::EDP_TLSv1;\n        } else if (sProtocol.Equals(\"TLSv1.1\")) {\n            uFlag = Csock::EDP_TLSv1_1;\n        } else if (sProtocol.Equals(\"TLSv1.2\")) {\n            uFlag = Csock::EDP_TLSv1_2;\n        } else {\n            return false;\n        }\n\n        if (bEnable) {\n            uDisabledProtocols &= ~uFlag;\n        } else if (bDisable) {\n            uDisabledProtocols |= uFlag;\n        } else {\n            uDisabledProtocols = ~uFlag;\n        }\n    }\n\n    m_sSSLProtocols = sProtocols;\n    m_uDisabledSSLProtocols = uDisabledProtocols;\n    return true;\n}\n\nvoid CZNC::EnableConnectQueue() {\n    if (!m_pConnectQueueTimer && !m_uiConnectPaused &&\n        !m_lpConnectQueue.empty()) {\n        m_pConnectQueueTimer = new CConnectQueueTimer(m_uiConnectDelay);\n        GetManager().AddCron(m_pConnectQueueTimer);\n    }\n}\n\nvoid CZNC::DisableConnectQueue() {\n    if (m_pConnectQueueTimer) {\n        // This will kill the cron\n        m_pConnectQueueTimer->Stop();\n        m_pConnectQueueTimer = nullptr;\n    }\n}\n\nvoid CZNC::PauseConnectQueue() {\n    DEBUG(\"Connection queue paused\");\n    m_uiConnectPaused++;\n\n    if (m_pConnectQueueTimer) {\n        m_pConnectQueueTimer->Pause();\n    }\n}\n\nvoid CZNC::ResumeConnectQueue() {\n    DEBUG(\"Connection queue resumed\");\n    m_uiConnectPaused--;\n\n    EnableConnectQueue();\n    if (m_pConnectQueueTimer) {\n        m_pConnectQueueTimer->UnPause();\n    }\n}\n\nvoid CZNC::ForceEncoding() {\n    m_uiForceEncoding++;\n#ifdef HAVE_ICU\n    for (Csock* pSock : GetManager()) {\n        pSock->SetEncoding(FixupEncoding(pSock->GetEncoding()));\n    }\n#endif\n}\nvoid CZNC::UnforceEncoding() { m_uiForceEncoding--; }\nbool CZNC::IsForcingEncoding() const { return m_uiForceEncoding; }\nCString CZNC::FixupEncoding(const CString& sEncoding) const {\n    if (!m_uiForceEncoding) {\n        return sEncoding;\n    }\n    if (sEncoding.empty()) {\n        return \"UTF-8\";\n    }\n    const char* sRealEncoding = sEncoding.c_str();\n    if (sEncoding[0] == '*' || sEncoding[0] == '^') {\n        sRealEncoding++;\n    }\n    if (!*sRealEncoding) {\n        return \"UTF-8\";\n    }\n#ifdef HAVE_ICU\n    UErrorCode e = U_ZERO_ERROR;\n    UConverter* cnv = ucnv_open(sRealEncoding, &e);\n    if (cnv) {\n        ucnv_close(cnv);\n    }\n    if (U_FAILURE(e)) {\n        return \"UTF-8\";\n    }\n#endif\n    return sEncoding;\n}\n\nvoid CZNC::AddNetworkToQueue(CIRCNetwork* pNetwork) {\n    // Make sure we are not already in the queue\n    if (std::find(m_lpConnectQueue.begin(), m_lpConnectQueue.end(), pNetwork) !=\n        m_lpConnectQueue.end()) {\n        return;\n    }\n\n    m_lpConnectQueue.push_back(pNetwork);\n    EnableConnectQueue();\n}\n\nvoid CZNC::LeakConnectQueueTimer(CConnectQueueTimer* pTimer) {\n    if (m_pConnectQueueTimer == pTimer) m_pConnectQueueTimer = nullptr;\n}\n\nbool CZNC::WaitForChildLock() { return m_pLockFile && m_pLockFile->ExLock(); }\n\nvoid CZNC::DisableConfigTimer() {\n    if (m_pConfigTimer) {\n        m_pConfigTimer->Stop();\n        m_pConfigTimer = nullptr;\n    }\n}\n", "/*\n * Copyright (C) 2004-2016 ZNC, see the NOTICE file for details.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"znctest.h\"\n\nnamespace znc_inttest {\nnamespace {\n\nTEST_F(ZNCTest, Modperl) {\n    if (QProcessEnvironment::systemEnvironment().value(\n            \"DISABLED_ZNC_PERL_PYTHON_TEST\") == \"1\") {\n        return;\n    }\n    auto znc = Run();\n    znc->CanLeak();\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    client.Write(\"znc loadmod modperl\");\n    client.Write(\"znc loadmod perleval\");\n    client.Write(\"PRIVMSG *perleval :2+2\");\n    client.ReadUntil(\":*perleval!znc@znc.in PRIVMSG nick :Result: 4\");\n    client.Write(\"PRIVMSG *perleval :$self->GetUser->GetUserName\");\n    client.ReadUntil(\"Result: user\");\n}\n\nTEST_F(ZNCTest, Modpython) {\n    if (QProcessEnvironment::systemEnvironment().value(\n            \"DISABLED_ZNC_PERL_PYTHON_TEST\") == \"1\") {\n        return;\n    }\n    auto znc = Run();\n    znc->CanLeak();\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    client.Write(\"znc loadmod modpython\");\n    client.Write(\"znc loadmod pyeval\");\n    client.Write(\"PRIVMSG *pyeval :2+2\");\n    client.ReadUntil(\":*pyeval!znc@znc.in PRIVMSG nick :4\");\n    client.Write(\"PRIVMSG *pyeval :module.GetUser().GetUserName()\");\n    client.ReadUntil(\"nick :'user'\");\n    ircd.Write(\":server 001 nick :Hello\");\n    ircd.Write(\":n!u@h PRIVMSG nick :Hi\\xF0, github issue #1229\");\n    // \"replacement character\"\n    client.ReadUntil(\"Hi\\xEF\\xBF\\xBD, github issue\");\n\n    // Non-existing encoding\n    client.Write(\"PRIVMSG *controlpanel :Set ClientEncoding $me Western\");\n    client.Write(\"JOIN #a\\342\");\n    client.ReadUntil(\n        \":*controlpanel!znc@znc.in PRIVMSG nick :ClientEncoding = UTF-8\");\n    ircd.ReadUntil(\"JOIN #a\\xEF\\xBF\\xBD\");\n}\n\nTEST_F(ZNCTest, ModpythonSocket) {\n    if (QProcessEnvironment::systemEnvironment().value(\n            \"DISABLED_ZNC_PERL_PYTHON_TEST\") == \"1\") {\n        return;\n    }\n    auto znc = Run();\n    znc->CanLeak();\n\n    InstallModule(\"socktest.py\", R\"(\n        import znc\n\n        class acc(znc.Socket):\n            def OnReadData(self, data):\n                self.GetModule().PutModule('received {} bytes'.format(len(data)))\n                self.Close()\n\n        class lis(znc.Socket):\n            def OnAccepted(self, host, port):\n                sock = self.GetModule().CreateSocket(acc)\n                sock.DisableReadLine()\n                return sock\n\n        class socktest(znc.Module):\n            def OnLoad(self, args, ret):\n                listen = self.CreateSocket(lis)\n                self.port = listen.Listen()\n                return True\n\n            def OnModCommand(self, cmd):\n                sock = self.CreateSocket()\n                sock.Connect('127.0.0.1', self.port)\n                sock.WriteBytes(b'blah')\n    )\");\n\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    client.Write(\"znc loadmod modpython\");\n    client.Write(\"znc loadmod socktest\");\n    client.Write(\"PRIVMSG *socktest :foo\");\n    client.ReadUntil(\"received 4 bytes\");\n}\n\nTEST_F(ZNCTest, ModperlSocket) {\n    if (QProcessEnvironment::systemEnvironment().value(\n            \"DISABLED_ZNC_PERL_PYTHON_TEST\") == \"1\") {\n        return;\n    }\n    auto znc = Run();\n    znc->CanLeak();\n\n    InstallModule(\"socktest.pm\", R\"(\n        package socktest::acc;\n        use base 'ZNC::Socket';\n        sub OnReadData {\n            my ($self, $data, $len) = @_;\n            $self->GetModule->PutModule(\"received $len bytes\");\n            $self->Close;\n        }\n\n        package socktest::lis;\n        use base 'ZNC::Socket';\n        sub OnAccepted {\n            my $self = shift;\n            return $self->GetModule->CreateSocket('socktest::acc');\n        }\n\n        package socktest::conn;\n        use base 'ZNC::Socket';\n\n        package socktest;\n        use base 'ZNC::Module';\n        sub OnLoad {\n            my $self = shift;\n            my $listen = $self->CreateSocket('socktest::lis');\n            $self->{port} = $listen->Listen;\n            return 1;\n        }\n        sub OnModCommand {\n            my ($self, $cmd) = @_;\n            my $sock = $self->CreateSocket('socktest::conn');\n            $sock->Connect('127.0.0.1', $self->{port});\n            $sock->Write('blah');\n        }\n\n        1;\n    )\");\n\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    client.Write(\"znc loadmod modperl\");\n    client.Write(\"znc loadmod socktest\");\n    client.Write(\"PRIVMSG *socktest :foo\");\n    client.ReadUntil(\"received 4 bytes\");\n}\n\nTEST_F(ZNCTest, ModpythonVCString) {\n    if (QProcessEnvironment::systemEnvironment().value(\n            \"DISABLED_ZNC_PERL_PYTHON_TEST\") == \"1\") {\n        return;\n    }\n    auto znc = Run();\n    znc->CanLeak();\n\n    InstallModule(\"test.py\", R\"(\n        import znc\n\n        class test(znc.Module):\n            def OnUserRawMessage(self, msg):\n                self.PutModule(str(msg.GetParams()))\n                return znc.CONTINUE\n    )\");\n\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    client.Write(\"znc loadmod modpython\");\n    client.Write(\"znc loadmod test\");\n    client.Write(\"PRIVMSG *test :foo\");\n    client.ReadUntil(\"'*test', 'foo'\");\n}\n\nTEST_F(ZNCTest, ModperlVCString) {\n    if (QProcessEnvironment::systemEnvironment().value(\n            \"DISABLED_ZNC_PERL_PYTHON_TEST\") == \"1\") {\n        return;\n    }\n    auto znc = Run();\n    znc->CanLeak();\n\n    InstallModule(\"test.pm\", R\"(\n        package test;\n        use base 'ZNC::Module';\n        sub OnUserRawMessage {\n            my ($self, $msg) = @_;\n            my @params = $msg->GetParams;\n            $self->PutModule(\"@params\");\n            return $ZNC::CONTINUE;\n        }\n\n        1;\n    )\");\n\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    client.Write(\"znc loadmod modperl\");\n    client.Write(\"znc loadmod test\");\n    client.Write(\"PRIVMSG *test :foo\");\n    client.ReadUntil(\":*test foo\");\n}\n\nTEST_F(ZNCTest, ModperlNV) {\n    if (QProcessEnvironment::systemEnvironment().value(\n            \"DISABLED_ZNC_PERL_PYTHON_TEST\") == \"1\") {\n        return;\n    }\n    auto znc = Run();\n    znc->CanLeak();\n\n    InstallModule(\"test.pm\", R\"(\n        package test;\n        use base 'ZNC::Module';\n        sub OnLoad {\n            my $self = shift;\n            $self->SetNV('a', 'X');\n            $self->NV->{b} = 'Y';\n            my @k = keys %{$self->NV};\n            $self->PutModule(\"@k\");\n            return $ZNC::CONTINUE;\n        }\n\n        1;\n    )\");\n\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    client.Write(\"znc loadmod modperl\");\n    client.Write(\"znc loadmod test\");\n    client.ReadUntil(\":a b\");\n}\n\n}  // namespace\n}  // namespace znc_inttest\n"], "filenames": ["modules/controlpanel.cpp", "src/IRCNetwork.cpp", "src/User.cpp", "src/znc.cpp", "test/integration/tests/scripting.cpp"], "buggy_code_start_loc": [498, 1485, 1256, 2095, 57], "buggy_code_end_loc": [499, 1488, 1259, 2106, 57], "fixing_code_start_loc": [498, 1485, 1256, 2095, 58], "fixing_code_end_loc": [499, 1488, 1259, 2125, 65], "type": "CWE-20", "message": "ZNC before 1.7.3-rc1 allows an existing remote user to cause a Denial of Service (crash) via invalid encoding.", "other": {"cve": {"id": "CVE-2019-9917", "sourceIdentifier": "cve@mitre.org", "published": "2019-03-27T06:29:00.390", "lastModified": "2019-06-15T03:29:00.240", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "ZNC before 1.7.3-rc1 allows an existing remote user to cause a Denial of Service (crash) via invalid encoding."}, {"lang": "es", "value": "ZNC, en versiones anteriores a la 1.7.3-rc1, permite que un usuario remoto existente provoque una denegaci\u00f3n de servicio (cierre inesperado) mediante el cifrado inv\u00e1lido."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:znc:znc:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.7.2", "matchCriteriaId": "924F4471-68F0-427E-8B61-A2DBAE3F841C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:28:*:*:*:*:*:*:*", "matchCriteriaId": "DC1BD7B7-6D88-42B8-878E-F1318CA5FCAF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:29:*:*:*:*:*:*:*", "matchCriteriaId": "D100F7CE-FC64-4CC6-852A-6136D72DA419"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-07/msg00037.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-08/msg00018.html", "source": "cve@mitre.org"}, {"url": "https://github.com/znc/znc/commit/64613bc8b6b4adf1e32231f9844d99cd512b8973", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/7WTRBTPL7WWKQ7DZ2ALDTCGYUWSE6SL3/", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Release Notes", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WRHCMHI44AW5CJ22WV676BKFUWWCLA7T/", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Release Notes", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZRVSINQHM623GJYYNDSBYSXT2MHKFCYQ/", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Release Notes", "Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2019/Jun/23", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3950-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2019/dsa-4463", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/znc/znc/commit/64613bc8b6b4adf1e32231f9844d99cd512b8973"}}