{"buggy_code": ["<?php\n/*********************************************************************\n    class.queue.php\n\n    Custom (ticket) queues for osTicket\n\n    Jared Hancock <jared@osticket.com>\n    Peter Rotich <peter@osticket.com>\n    Copyright (c)  2006-2015 osTicket\n    http://www.osticket.com\n\n    Released under the GNU General Public License WITHOUT ANY WARRANTY.\n    See LICENSE.TXT for details.\n\n    vim: expandtab sw=4 ts=4 sts=4:\n**********************************************************************/\n\nclass CustomQueue extends VerySimpleModel {\n    static $meta = array(\n        'table' => QUEUE_TABLE,\n        'pk' => array('id'),\n        'ordering' => array('sort'),\n        'select_related' => array('parent', 'default_sort'),\n        'joins' => array(\n            'children' => array(\n                'reverse' => 'CustomQueue.parent',\n                'constrain' => ['children__id__gt' => 0],\n            ),\n            'columns' => array(\n                'reverse' => 'QueueColumnGlue.queue',\n                'constrain' => array('staff_id' =>'QueueColumnGlue.staff_id'),\n                'broker' => 'QueueColumnListBroker',\n            ),\n            'sorts' => array(\n                'reverse' => 'QueueSortGlue.queue',\n                'broker' => 'QueueSortListBroker',\n            ),\n            'default_sort' => array(\n                'constraint' => array('sort_id' => 'QueueSort.id'),\n                'null' => true,\n            ),\n            'exports' => array(\n                'reverse' => 'QueueExport.queue',\n            ),\n            'parent' => array(\n                'constraint' => array(\n                    'parent_id' => 'CustomQueue.id',\n                ),\n                'null' => true,\n            ),\n            'staff' => array(\n                'constraint' => array(\n                    'staff_id' => 'Staff.staff_id',\n                )\n            ),\n        )\n    );\n\n    const FLAG_PUBLIC =           0x0001; // Shows up in e'eryone's saved searches\n    const FLAG_QUEUE =            0x0002; // Shows up in queue navigation\n    const FLAG_DISABLED =         0x0004; // NOT enabled\n    const FLAG_INHERIT_CRITERIA = 0x0008; // Include criteria from parent\n    const FLAG_INHERIT_COLUMNS =  0x0010; // Inherit column layout from parent\n    const FLAG_INHERIT_SORTING =  0x0020; // Inherit advanced sorting from parent\n    const FLAG_INHERIT_DEF_SORT = 0x0040; // Inherit default selected sort\n    const FLAG_INHERIT_EXPORT  =  0x0080; // Inherit export fields from parent\n\n\n    const FLAG_INHERIT_EVERYTHING = 0x158; // Maskf or all INHERIT flags\n\n    var $criteria;\n    var $_conditions;\n\n    static function queues() {\n        return parent::objects()->filter(array(\n            'flags__hasbit' => static::FLAG_QUEUE\n        ));\n    }\n\n    function __onload() {\n        // Ensure valid state\n        if ($this->hasFlag(self::FLAG_INHERIT_COLUMNS) && !$this->parent_id)\n            $this->clearFlag(self::FLAG_INHERIT_COLUMNS);\n\n       if ($this->hasFlag(self::FLAG_INHERIT_EXPORT) && !$this->parent_id)\n            $this->clearFlag(self::FLAG_INHERIT_EXPORT);\n    }\n\n    function getId() {\n        return $this->id;\n    }\n\n    function getName() {\n        return $this->title;\n    }\n\n    function getHref() {\n        // TODO: Get base page from getRoot();\n        $root = $this->getRoot();\n        return 'tickets.php?queue='.$this->getId();\n    }\n\n    function getRoot() {\n        switch ($this->root) {\n        case 'T':\n        default:\n            return 'Ticket';\n        }\n    }\n\n    function getPath() {\n        return $this->path ?: $this->buildPath();\n    }\n\n    function criteriaRequired() {\n        return true;\n    }\n\n    function getCriteria($include_parent=false) {\n        if (!isset($this->criteria)) {\n            $this->criteria = is_string($this->config)\n                ? JsonDataParser::decode($this->config)\n                : $this->config;\n            // XXX: Drop this block in v1.12\n            // Auto-upgrade v1.10 saved-search criteria to new format\n            // But support new style with `conditions` support\n            $old = @$this->config[0] === '{';\n            if ($old && is_array($this->criteria)\n                && !isset($this->criteria['conditions'])\n            ) {\n                // TODO: Upgrade old ORM path names\n                // Parse criteria out of JSON if any.\n                $this->criteria = self::isolateCriteria($this->criteria,\n                        $this->getRoot());\n            }\n        }\n        $criteria = $this->criteria ?: array();\n        // Support new style with `conditions` support\n        if (isset($criteria['criteria']))\n            $criteria = $criteria['criteria'];\n        if ($include_parent && $this->parent_id && $this->parent) {\n            $criteria = array_merge($this->parent->getCriteria(true),\n                $criteria);\n        }\n        return $criteria;\n    }\n\n    function describeCriteria($criteria=false){\n        $all = $this->getSupportedMatches($this->getRoot());\n        $items = array();\n        $criteria = $criteria ?: $this->getCriteria(true);\n        foreach ($criteria ?: array() as $C) {\n            list($path, $method, $value) = $C;\n            if ($path === ':keywords') {\n                $items[] = Format::htmlchars(\"\\\"{$value}\\\"\");\n                continue;\n            }\n            if (!isset($all[$path]))\n                continue;\n            list($label, $field) = $all[$path];\n            $items[] = $field->describeSearch($method, $value, $label);\n        }\n        return implode(\"\\nAND \", $items);\n    }\n\n    /**\n     * Fetch an AdvancedSearchForm instance for use in displaying or\n     * configuring this search in the user interface.\n     *\n     * Parameters:\n     * $search - <array> Request parameters ($_POST) used to update the\n     *      search beyond the current configuration of the search criteria\n     * $searchables - search fields - default to current if not provided\n     */\n    function getForm($source=null, $searchable=null) {\n        $fields = array();\n        if (!isset($searchable)) {\n            $fields = array(\n                ':keywords' => new TextboxField(array(\n                    'id' => 3001,\n                    'configuration' => array(\n                        'size' => 40,\n                        'length' => 400,\n                        'autofocus' => true,\n                        'classes' => 'full-width headline',\n                        'placeholder' => __('Keywords \u2014 Optional'),\n                    ),\n                    'validators' => function($self, $v) {\n                        if (mb_str_wc($v) > 3)\n                            $self->addError(__('Search term cannot have more than 3 keywords'));\n                    },\n                )),\n            );\n\n            $searchable = $this->getCurrentSearchFields($source);\n        }\n\n        foreach ($searchable ?: array() as $path => $field)\n            $fields = array_merge($fields, static::getSearchField($field, $path));\n\n        $form = new AdvancedSearchForm($fields, $source);\n\n        // Field selection validator\n        if ($this->criteriaRequired()) {\n            $form->addValidator(function($form) {\n                    if (!$form->getNumFieldsSelected())\n                        $form->addError(__('No fields selected for searching'));\n                });\n        }\n\n        // Load state from current configuraiton\n        if (!$source) {\n            foreach ($this->getCriteria() as $I) {\n                list($path, $method, $value) = $I;\n                if ($path == ':keywords' && $method === null) {\n                    if ($F = $form->getField($path))\n                        $F->value = $value;\n                    continue;\n                }\n\n                if (!($F = $form->getField(\"{$path}+search\")))\n                    continue;\n                $F->value = true;\n\n                if (!($F = $form->getField(\"{$path}+method\")))\n                    continue;\n                $F->value = $method;\n\n                if ($value && ($F = $form->getField(\"{$path}+{$method}\")))\n                    $F->value = $value;\n            }\n        }\n        return $form;\n    }\n\n    /**\n     * Fetch a bucket of fields for a custom search. The fields should be\n     * added to a form before display. One searchable field may encompass 10\n     * or more actual fields because fields are expanded to support multiple\n     * search methods along with the fields for each search method. This\n     * method returns all the FormField instances for all the searchable\n     * model fields currently in use.\n     *\n     * Parameters:\n     * $source - <array> data from a request. $source['fields'] is expected\n     *      to contain a list extra fields by ORM path, of newly added\n     *      fields not yet saved in this object's getCriteria().\n     */\n    function getCurrentSearchFields($source=array(), $criteria=array()) {\n        static $basic = array(\n            'Ticket' => array(\n                'status__id',\n                'status__state',\n                'dept_id',\n                'assignee',\n                'topic_id',\n                'created',\n                'est_duedate',\n                'duedate',\n            )\n        );\n\n        $all = $this->getSupportedMatches();\n        $core = array();\n\n        // Include basic fields for new searches\n        if (!isset($this->id))\n            foreach ($basic[$this->getRoot()] as $path)\n                if (isset($all[$path]))\n                    $core[$path] = $all[$path];\n\n        // Add others from current configuration\n        foreach ($criteria ?: $this->getCriteria() as $C) {\n            list($path) = $C;\n            if (isset($all[$path]))\n                $core[$path] = $all[$path];\n        }\n\n        if (isset($source['fields']))\n            foreach ($source['fields'] as $path)\n                if (isset($all[$path]))\n                    $core[$path] = $all[$path];\n\n        return $core;\n    }\n\n    /**\n    * Fetch all supported ORM fields filterable by this search object.\n    */\n    function getSupportedFilters() {\n        return static::getFilterableFields($this->getRoot());\n    }\n\n\n    /**\n     * Get get supplemental matches for public queues.\n     *\n     */\n\n    function getSupplementalMatches() {\n        return array();\n    }\n\n    function getSupplementalCriteria() {\n        return array();\n    }\n\n    /**\n     * Fetch all supported ORM fields searchable by this search object. The\n     * returned list represents searchable fields, keyed by the ORM path.\n     * Use ::getCurrentSearchFields() or ::getSearchField() to retrieve for\n     * use in the user interface.\n     */\n    function getSupportedMatches() {\n        return static::getSearchableFields($this->getRoot());\n    }\n\n    /**\n     * Trace ORM fields from a base object and retrieve a complete list of\n     * fields which can be used in an ORM query based on the base object.\n     * The base object must implement Searchable interface and extend from\n     * VerySimpleModel. Then all joins from the object are also inspected,\n     * and any which implement the Searchable interface are traversed and\n     * automatically added to the list. The resulting list is cached based\n     * on the $base class, so multiple calls for the same $base return\n     * quickly.\n     *\n     * Parameters:\n     * $base - Class, name of a class implementing Searchable\n     * $recurse - int, number of levels to recurse, default is 2\n     * $cache - bool, cache results for future class for the same base\n     * $customData - bool, include all custom data fields for all general\n     *      forms\n     */\n    static function getSearchableFields($base, $recurse=2,\n        $customData=true, $exclude=array()\n    ) {\n        static $cache = array(), $otherFields;\n\n        // Early exit if already cached\n        $fields = &$cache[$base];\n        if ($fields)\n            return $fields;\n\n        if (!in_array('Searchable', class_implements($base)))\n            return array();\n\n        $fields = $fields ?: array();\n        foreach ($base::getSearchableFields() as $path=>$F) {\n            if (is_array($F)) {\n                list($label, $field) = $F;\n            }\n            else {\n                $label = $F->getLocal('label');\n                $field = $F;\n            }\n            $fields[$path] = array($label, $field);\n        }\n\n        if ($customData && $base::supportsCustomData()) {\n            if (!isset($otherFields)) {\n                $otherFields = array();\n                $dfs = DynamicFormField::objects()\n                    ->filter(array('form__type' => 'G'))\n                    ->select_related('form');\n                foreach ($dfs as $field) {\n                    $otherFields[$field->getId()] = array($field->form,\n                        $field->getImpl());\n                }\n            }\n            foreach ($otherFields as $id=>$F) {\n                list($form, $field) = $F;\n                $label = sprintf(\"%s / %s\",\n                    $form->getTitle(), $field->getLocal('label'));\n                $fields[\"entries__answers!{$id}__value\"] = array(\n                    $label, $field);\n            }\n        }\n\n        if ($recurse) {\n            $exclude[$base] = 1;\n            foreach ($base::getMeta('joins') as $path=>$j) {\n                $fc = $j['fkey'][0];\n                if (isset($exclude[$fc]) || $j['list'])\n                    continue;\n                foreach (static::getSearchableFields($fc, $recurse-1,\n                    true, $exclude)\n                as $path2=>$F) {\n                    list($label, $field) = $F;\n                    $fields[\"{$path}__{$path2}\"] = array(\n                        sprintf(\"%s / %s\", $fc, $label),\n                        $field);\n                }\n            }\n        }\n\n        // Sort the field listing by the (localized) label name\n        if (function_exists('collator_create')) {\n            $coll = Collator::create(Internationalization::getCurrentLanguage());\n            $keys = array_map(function($a) use ($coll) {\n                return $coll->getSortKey($a[0]); #nolint\n            }, $fields);\n        }\n        else {\n            // Fall back to 8-bit string sorting\n            $keys = array_map(function($a) { return $a[0]; }, $fields);\n        }\n        array_multisort($keys, $fields);\n\n        return $fields;\n    }\n\n  /**\n     * Fetch all searchable fileds, for the base object  which support quick filters.\n     */\n    function getFilterableFields($object) {\n        $filters = array();\n        foreach (static::getSearchableFields($object) as $p => $f) {\n            list($label, $field) = $f;\n            if ($field && $field->supportsQuickFilter())\n                $filters[$p] = $f;\n        }\n\n        return $filters;\n    }\n\n    /**\n     * Fetch the FormField instances used when for configuring a searchable\n     * field in the user interface. This is the glue between a field\n     * representing a searchable model field and the configuration of that\n     * search in the user interface.\n     *\n     * Parameters:\n     * $F - <array<string, FormField>> the label and the FormField instance\n     *      representing the configurable search\n     * $name - <string> ORM path for the search\n     */\n    static function getSearchField($F, $name) {\n        list($label, $field) = $F;\n\n        $pieces = array();\n        $pieces[\"{$name}+search\"] = new BooleanField(array(\n            'id' => sprintf('%u', crc32($name)) >> 1,\n            'configuration' => array(\n                'desc' => $label ?: $field->getLocal('label'),\n                'classes' => 'inline',\n            ),\n        ));\n        $methods = $field->getSearchMethods();\n\n        //remove future options for datetime fields that can't be in the future\n        if (in_array($field->getLabel(), DateTimeField::getPastPresentLabels()))\n          unset($methods['ndays'], $methods['future'], $methods['distfut']);\n\n        $pieces[\"{$name}+method\"] = new ChoiceField(array(\n            'choices' => $methods,\n            'default' => key($methods),\n            'visibility' => new VisibilityConstraint(new Q(array(\n                \"{$name}+search__eq\" => true,\n            )), VisibilityConstraint::HIDDEN),\n        ));\n        $offs = 0;\n        foreach ($field->getSearchMethodWidgets() as $m=>$w) {\n            if (!$w)\n                continue;\n            list($class, $args) = $w;\n            $args['required'] = true;\n            $args['__searchval__'] = true;\n            $args['visibility'] = new VisibilityConstraint(new Q(array(\n                    \"{$name}+method__eq\" => $m,\n                )), VisibilityConstraint::HIDDEN);\n            $pieces[\"{$name}+{$m}\"] = new $class($args);\n        }\n        return $pieces;\n    }\n\n    function getField($path) {\n        $searchable = $this->getSupportedMatches();\n        return $searchable[$path];\n    }\n\n    // Remove this and adjust advanced-search-criteria template to use the\n    // getCriteria() list and getField()\n    function getSearchFields($form=false) {\n        $form = $form ?: $this->getForm();\n        $searchable = $this->getCurrentSearchFields();\n        $info = array();\n        foreach ($form->getFields() as $f) {\n            if (substr($f->get('name'), -7) == '+search') {\n                $name = substr($f->get('name'), 0, -7);\n                $value = null;\n                // Determine the search method and fetch the original field\n                if (($M = $form->getField(\"{$name}+method\"))\n                    && ($method = $M->getClean())\n                    && (list(,$field) = $searchable[$name])\n                ) {\n                    // Request the field to generate a search Q for the\n                    // search method and given value\n                    if ($value = $form->getField(\"{$name}+{$method}\"))\n                        $value = $value->getClean();\n                }\n                $info[$name] = array(\n                    'field' => $field,\n                    'method' => $method,\n                    'value' => $value,\n                    'active' =>  $f->getClean(),\n                );\n            }\n        }\n        return $info;\n    }\n\n    /**\n     * Take the criteria from the SavedSearch fields setup and isolate the\n     * field name being search, the method used for searhing, and the method-\n     * specific data entered in the UI.\n     */\n    static function isolateCriteria($criteria, $base='Ticket') {\n\n        if (!is_array($criteria))\n            return null;\n\n        $items = array();\n        $searchable = static::getSearchableFields($base);\n        foreach ($criteria as $k=>$v) {\n            if (substr($k, -7) === '+method') {\n                list($name,) = explode('+', $k, 2);\n                if (!isset($searchable[$name]))\n                    continue;\n\n                // Require checkbox to be checked too\n                if (!$criteria[\"{$name}+search\"])\n                    continue;\n\n                // Lookup the field to search this condition\n                list($label, $field) = $searchable[$name];\n                // Get the search method\n                $method = is_array($v) ? key($v) : $v;\n                // Not all search methods require a value\n                $value = $criteria[\"{$name}+{$method}\"];\n\n                $items[] = array($name, $method, $value);\n            }\n        }\n        if (isset($criteria[':keywords'])\n            && ($kw = $criteria[':keywords'])\n        ) {\n            $items[] = array(':keywords', null, $kw);\n        }\n        return $items;\n    }\n\n    function getConditions() {\n        if (!isset($this->_conditions)) {\n            $this->getCriteria();\n            $conds = array();\n            if (is_array($this->criteria)\n                && isset($this->criteria['conditions'])\n            ) {\n                $conds = $this->criteria['conditions'];\n            }\n            foreach ($conds as $C)\n                if ($T = QueueColumnCondition::fromJson($C))\n                    $this->_conditions[] = $T;\n        }\n        return $this->_conditions;\n    }\n\n    function getExportableFields() {\n        $cdata = $fields = array();\n        foreach (TicketForm::getInstance()->getFields() as $f) {\n            // Ignore core fields\n            if (in_array($f->get('name'), array('priority')))\n                continue;\n            // Ignore non-data fields\n            elseif (!$f->hasData() || $f->isPresentationOnly())\n                continue;\n\n            $name = $f->get('name') ?: 'field_'.$f->get('id');\n            $key = 'cdata__'.$name;\n            $cdata[$key] = $f->getLocal('label');\n        }\n\n        // Standard export fields if none is provided.\n        $fields = array(\n                'number' =>         __('Ticket Number'),\n                'created' =>        __('Date Created'),\n                'cdata__subject' =>  __('Subject'),\n                'user__name' =>      __('From'),\n                'user__emails__address' => __('From Email'),\n                'cdata__priority' => __('Priority'),\n                'dept_id' => __('Department'),\n                'topic_id' => __('Help Topic'),\n                'source' =>         __('Source'),\n                'status__id' =>__('Current Status'),\n                'lastupdate' =>     __('Last Updated'),\n                'est_duedate' =>    __('SLA Due Date'),\n                'duedate' =>        __('Due Date'),\n                'closed' =>         __('Closed Date'),\n                'isoverdue' =>      __('Overdue'),\n                'isanswered' =>     __('Answered'),\n                'staff_id' => __('Agent Assigned'),\n                'team_id' =>  __('Team Assigned'),\n                'thread_count' =>   __('Thread Count'),\n                'reopen_count' =>   __('Reopen Count'),\n                'attachment_count' => __('Attachment Count'),\n                ) + $cdata;\n\n        return $fields;\n    }\n\n    function getExportFields($inherit=true) {\n\n        $fields = array();\n        if ($inherit\n            && $this->parent_id\n            && $this->hasFlag(self::FLAG_INHERIT_EXPORT)\n            && $this->parent\n        ) {\n            $fields = $this->parent->getExportFields();\n        }\n        elseif (count($this->exports)) {\n            foreach ($this->exports as $f)\n                $fields[$f->path] = $f->getHeading();\n        }\n        elseif ($this->isAQueue())\n            $fields = $this->getExportableFields();\n\n        if (!count($fields))\n            $fields = $this->getExportableFields();\n\n        return $fields;\n    }\n\n    function getExportColumns($fields=array()) {\n        $columns = array();\n        $fields = $fields ?: $this->getExportFields();\n        $i = 0;\n        foreach ($fields as $path => $label) {\n            $c = QueueColumn::placeholder(array(\n                        'id' => $i++,\n                        'heading' => $label,\n                        'primary' => $path,\n                        ));\n            $c->setQueue($this);\n            $columns[$path] = $c;\n        }\n        return $columns;\n    }\n\n    function getStandardColumns() {\n        return $this->getColumns();\n    }\n\n    function getColumns($use_template=false) {\n        if ($this->columns_id\n            && ($q = CustomQueue::lookup($this->columns_id))\n        ) {\n            // Use columns from cited queue\n            return $q->getColumns();\n        }\n        elseif ($this->parent_id\n            && $this->hasFlag(self::FLAG_INHERIT_COLUMNS)\n            && $this->parent\n        ) {\n            $columns = $this->parent->getColumns();\n            foreach ($columns as $c)\n                $c->setQueue($this);\n            return $columns;\n        }\n        elseif (count($this->columns)) {\n            return $this->columns;\n        }\n\n        // Use the columns of the \"Open\" queue as a default template\n        if ($use_template && ($template = CustomQueue::lookup(1)))\n            return $template->getColumns();\n\n        // Last resort \u2014 use standard columns\n        foreach (array(\n            QueueColumn::placeholder(array(\n                \"id\" => 1,\n                \"heading\" => \"Number\",\n                \"primary\" => 'number',\n                \"width\" => 85,\n                \"bits\" => QueueColumn::FLAG_SORTABLE,\n                \"filter\" => \"link:ticketP\",\n                \"annotations\" => '[{\"c\":\"TicketSourceDecoration\",\"p\":\"b\"}]',\n                \"conditions\" => '[{\"crit\":[\"isanswered\",\"nset\",null],\"prop\":{\"font-weight\":\"bold\"}}]',\n            )),\n            QueueColumn::placeholder(array(\n                \"id\" => 2,\n                \"heading\" => \"Created\",\n                \"primary\" => 'created',\n                \"filter\" => 'date:full',\n                \"truncate\" =>'wrap',\n                \"width\" => 120,\n                \"bits\" => QueueColumn::FLAG_SORTABLE,\n            )),\n            QueueColumn::placeholder(array(\n                \"id\" => 3,\n                \"heading\" => \"Subject\",\n                \"primary\" => 'cdata__subject',\n                \"width\" => 250,\n                \"bits\" => QueueColumn::FLAG_SORTABLE,\n                \"filter\" => \"link:ticket\",\n                \"annotations\" => '[{\"c\":\"TicketThreadCount\",\"p\":\">\"},{\"c\":\"ThreadAttachmentCount\",\"p\":\"a\"},{\"c\":\"OverdueFlagDecoration\",\"p\":\"<\"}]',\n                \"conditions\" => '[{\"crit\":[\"isanswered\",\"nset\",null],\"prop\":{\"font-weight\":\"bold\"}}]',\n                \"truncate\" => 'ellipsis',\n            )),\n            QueueColumn::placeholder(array(\n                \"id\" => 4,\n                \"heading\" => \"From\",\n                \"primary\" => 'user__name',\n                \"width\" => 150,\n                \"bits\" => QueueColumn::FLAG_SORTABLE,\n            )),\n            QueueColumn::placeholder(array(\n                \"id\" => 5,\n                \"heading\" => \"Priority\",\n                \"primary\" => 'cdata__priority',\n                \"width\" => 120,\n                \"bits\" => QueueColumn::FLAG_SORTABLE,\n            )),\n            QueueColumn::placeholder(array(\n                \"id\" => 8,\n                \"heading\" => \"Assignee\",\n                \"primary\" => 'assignee',\n                \"width\" => 100,\n                \"bits\" => QueueColumn::FLAG_SORTABLE,\n            )),\n        ) as $col)\n            $this->addColumn($col);\n\n        return $this->getColumns();\n    }\n\n    function addColumn(QueueColumn $col) {\n        $this->columns->add($col);\n        $col->queue = $this;\n    }\n\n    function getSortOptions() {\n        if ($this->inheritSorting() && $this->parent) {\n            return $this->parent->getSortOptions();\n        }\n        return $this->sorts;\n    }\n\n    function getDefaultSortId() {\n        if ($this->isDefaultSortInherited() && $this->parent\n            && ($sort_id = $this->parent->getDefaultSortId())\n        ) {\n            return $sort_id;\n        }\n        return $this->sort_id;\n    }\n\n    function getDefaultSort() {\n        if ($this->isDefaultSortInherited() && $this->parent\n            && ($sort = $this->parent->getDefaultSort())\n        ) {\n            return $sort;\n        }\n        return $this->default_sort;\n    }\n\n    function getStatus() {\n        return $this->hasFlag(self::FLAG_DISABLED)\n            ? __('Disabled') : __('Active');\n    }\n\n    function getChildren() {\n        return $this->children;\n    }\n\n    function getPublicChildren() {\n        return $this->children->findAll(array(\n            'flags__hasbit' => self::FLAG_QUEUE\n        ));\n    }\n\n    function getMyChildren() {\n        global $thisstaff;\n        if (!$thisstaff instanceof Staff)\n            return array();\n\n        return $this->children->findAll(array(\n            'staff_id' => $thisstaff->getId(),\n            Q::not(array(\n                'flags__hasbit' => self::FLAG_PUBLIC\n            ))\n        ));\n    }\n\n    function export($options=array()) {\n        global $thisstaff;\n\n        if (!$thisstaff\n                || !($query=$this->getBasicQuery())\n                || !($fields=$this->getExportFields()))\n            return false;\n\n        $filename = sprintf('%s Tickets-%s.csv',\n                $this->getName(),\n                strftime('%Y%m%d'));\n        // See if we have cached export preference\n        if (isset($_SESSION['Export:Q'.$this->getId()])) {\n            $opts = $_SESSION['Export:Q'.$this->getId()];\n            if (isset($opts['fields'])) {\n                $fields = array_intersect_key($fields,\n                        array_flip($opts['fields']));\n                $exportableFields = CustomQueue::getExportableFields();\n                foreach ($opts['fields'] as $key => $name) {\n                    if (is_null($fields[$name]) && isset($exportableFields)) {\n                        $fields[$name] = $exportableFields[$name];\n                    }\n                 }\n            }\n\n            if (isset($opts['filename'])\n                    && ($parts = pathinfo($opts['filename']))) {\n                $filename = $opts['filename'];\n                if (strcasecmp($parts['extension'], 'csv') !=0)\n                    $filename =\"$filename.csv\";\n            }\n\n            if (isset($opts['delimiter']) && !$options['delimiter'])\n                $options['delimiter'] = $opts['delimiter'];\n\n        }\n\n        // Apply columns\n        $columns = $this->getExportColumns($fields);\n        $headers = array(); // Reset fields based on validity of columns\n        foreach ($columns as $column) {\n            $query = $column->mangleQuery($query, $this->getRoot());\n            $headers[] = $column->getHeading();\n        }\n\n        // Apply visibility\n        if (!$this->ignoreVisibilityConstraints($thisstaff))\n            $query->filter($thisstaff->getTicketsVisibility());\n\n        // Render Util\n        $render = function ($row) use($columns) {\n            if (!$row) return false;\n\n            $record = array();\n            foreach ($columns as $path => $column) {\n                $record[] = (string) $column->from_query($row) ?:\n                    $row[$path] ?: '';\n            }\n            return $record;\n        };\n\n        $delimiter = $options['delimiter'] ?:\n            Internationalization::getCSVDelimiter();\n        $output = fopen('php://output', 'w');\n        Http::download($filename, \"text/csv\");\n        fputs($output, chr(0xEF) . chr(0xBB) . chr(0xBF));\n        fputcsv($output, $headers, $delimiter);\n        foreach ($query as $row)\n            fputcsv($output, $render($row), $delimiter);\n        fclose($output);\n        exit();\n    }\n\n    /**\n     * Add critiera to a query based on the constraints configured for this\n     * queue. The criteria of the parent queue is also automatically added\n     * if the queue is configured to inherit the criteria.\n     */\n    function getBasicQuery() {\n        if ($this->parent && $this->inheritCriteria()) {\n            $query = $this->parent->getBasicQuery();\n        }\n        else {\n            $root = $this->getRoot();\n            $query = $root::objects();\n        }\n        return $this->mangleQuerySet($query);\n    }\n\n    /**\n     * Retrieve a QuerySet instance based on the type of object (root) of\n     * this Q, which is automatically configured with the data and criteria\n     * of the queue and its columns.\n     *\n     * Returns:\n     * <QuerySet> instance\n     */\n    function getQuery($form=false, $quick_filter=null) {\n        // Start with basic criteria\n        $query = $this->getBasicQuery($form);\n\n        // Apply quick filter\n        if (isset($quick_filter)\n            && ($qf = $this->getQuickFilterField($quick_filter))\n        ) {\n            $filter = @self::getOrmPath($this->getQuickFilter(), $query);\n            $query = $qf->applyQuickFilter($query, $quick_filter,\n                $filter);\n        }\n\n        // Apply column, annotations and conditions additions\n        foreach ($this->getColumns() as $C) {\n            $C->setQueue($this);\n            $query = $C->mangleQuery($query, $this->getRoot());\n        }\n        return $query;\n    }\n\n    function getQuickFilter() {\n        if ($this->filter == '::' && $this->parent) {\n            return $this->parent->getQuickFilter();\n        }\n        return $this->filter;\n    }\n\n    function getQuickFilterField($value=null) {\n        if ($this->filter == '::') {\n            if ($this->parent) {\n                return $this->parent->getQuickFilterField($value);\n            }\n        }\n        elseif ($this->filter\n            && ($fields = self::getSearchableFields($this->getRoot()))\n            && (list(,$f) = @$fields[$this->filter])\n            && $f->supportsQuickFilter()\n        ) {\n            $f->value = $value;\n            return $f;\n        }\n    }\n\n    /**\n     * Get a description of a field in a search. Expects an entry from the\n     * array retrieved in ::getSearchFields()\n     */\n    function describeField($info, $name=false) {\n        $name = $name ?: $info['field']->get('label');\n        return $info['field']->describeSearch($info['method'], $info['value'], $name);\n    }\n\n    function mangleQuerySet(QuerySet $qs, $form=false) {\n        $qs = clone $qs;\n        $searchable = $this->getSupportedMatches();\n\n        // Figure out fields to search on\n        foreach ($this->getCriteria() as $I) {\n            list($name, $method, $value) = $I;\n\n            // Consider keyword searching\n            if ($name === ':keywords') {\n                global $ost;\n                $qs = $ost->searcher->find($value, $qs, false);\n            }\n            else {\n                // XXX: Move getOrmPath to be more of a utility\n                // Ensure the special join is created to support custom data joins\n                $name = @static::getOrmPath($name, $qs);\n\n                if (preg_match('/__answers!\\d+__/', $name)) {\n                    $qs->annotate(array($name => SqlAggregate::MAX($name)));\n                }\n\n                // Fetch a criteria Q for the query\n                if (list(,$field) = $searchable[$name]) {\n                    // Add annotation if the field supports it.\n                    if (is_subclass_of($field, 'AnnotatedField'))\n                       $qs = $field->annotate($qs, $name);\n\n                    if ($q = $field->getSearchQ($method, $value, $name))\n                        $qs = $qs->filter($q);\n                }\n            }\n        }\n\n        return $qs;\n    }\n\n    function applyDefaultSort($qs) {\n        // Apply default sort\n        if ($sorter = $this->getDefaultSort()) {\n            $qs = $sorter->applySort($qs, false, $this->getRoot());\n        }\n        return $qs;\n    }\n\n    function checkAccess(Staff $agent) {\n        return $this->isPublic() || $this->checkOwnership($agent);\n    }\n\n    function checkOwnership(Staff $agent) {\n\n        return ($agent->getId() == $this->staff_id &&\n                !$this->isAQueue());\n    }\n\n    function isOwner(Staff $agent) {\n        return $agent && $this->isPrivate() && $this->checkOwnership($agent);\n    }\n\n    function isSaved() {\n        return true;\n    }\n\n    function ignoreVisibilityConstraints(Staff $agent) {\n        // For searches (not queues), some staff can have a permission to\n        // see all records\n        return ($this->isASearch()\n                && $this->isOwner($agent)\n                && $agent->canSearchEverything());\n    }\n\n    function inheritCriteria() {\n        return $this->flags & self::FLAG_INHERIT_CRITERIA &&\n            $this->parent_id;\n    }\n\n    function inheritColumns() {\n        return $this->hasFlag(self::FLAG_INHERIT_COLUMNS);\n    }\n\n    function useStandardColumns() {\n        return ($this->hasFlag(self::FLAG_INHERIT_COLUMNS) ||\n                !count($this->columns));\n    }\n\n    function inheritExport() {\n        return ($this->hasFlag(self::FLAG_INHERIT_EXPORT) ||\n                !count($this->exports));\n    }\n\n    function inheritSorting() {\n        return $this->hasFlag(self::FLAG_INHERIT_SORTING);\n    }\n\n    function isDefaultSortInherited() {\n        return $this->hasFlag(self::FLAG_INHERIT_DEF_SORT);\n    }\n\n    function buildPath() {\n        if (!$this->id)\n            return;\n\n        $path = $this->parent ? $this->parent->buildPath() : '';\n        return rtrim($path, \"/\") . \"/{$this->id}/\";\n    }\n\n    function getFullName() {\n        $base = $this->getName();\n        if ($this->parent)\n            $base = sprintf(\"%s / %s\", $this->parent->getFullName(), $base);\n        return $base;\n    }\n\n    function isASubQueue() {\n        return $this->parent ? $this->parent->isASubQueue() :\n            $this->isAQueue();\n    }\n\n    function isAQueue() {\n        return $this->hasFlag(self::FLAG_QUEUE);\n    }\n\n    function isASearch() {\n        return !$this->isAQueue() || !$this->isSaved();\n    }\n\n    function isPrivate() {\n        return !$this->isAQueue() && $this->staff_id;\n    }\n\n    function isPublic() {\n        return $this->hasFlag(self::FLAG_PUBLIC);\n    }\n\n    protected function hasFlag($flag) {\n        return ($this->flags & $flag) !== 0;\n    }\n\n    protected function clearFlag($flag) {\n        return $this->flags &= ~$flag;\n    }\n\n    protected function setFlag($flag, $value=true) {\n        return $value\n            ? $this->flags |= $flag\n            : $this->clearFlag($flag);\n    }\n\n    function disable() {\n        $this->setFlag(self::FLAG_DISABLED);\n    }\n\n    function enable() {\n        $this->clearFlag(self::FLAG_DISABLED);\n    }\n\n    function getRoughCount() {\n        if (($count = $this->getRoughCountAPC()) !== false)\n            return $count;\n\n        $query = Ticket::objects();\n        $Q = $this->getBasicQuery();\n        $expr = SqlCase::N()->when(new SqlExpr(new Q($Q->constraints)),\n            new SqlField('ticket_id'));\n        $query = $query->aggregate(array(\n            \"ticket_count\" => SqlAggregate::COUNT($expr)\n        ));\n\n        $row = $query->values()->one();\n        return $row['ticket_count'];\n    }\n\n    function getRoughCountAPC() {\n        if (!function_exists('apcu_store'))\n            return false;\n\n        $key = \"rough.counts.\".SECRET_SALT;\n        $cached = false;\n        $counts = apcu_fetch($key, $cached);\n        if ($cached === true && isset($counts[\"q{$this->id}\"]))\n            return $counts[\"q{$this->id}\"];\n\n        // Fetch rough counts of all queues. That is, fetch a total of the\n        // counts based on the queue criteria alone. Do no consider agent\n        // access. This should be fast and \"rought\"\n        $queues = static::objects()\n            ->filter(['flags__hasbit' => CustomQueue::FLAG_PUBLIC])\n            ->exclude(['flags__hasbit' => CustomQueue::FLAG_DISABLED]);\n\n        $query = Ticket::objects();\n        $prefix = \"\";\n\n        foreach ($queues as $queue) {\n            $Q = $queue->getBasicQuery();\n            $expr = SqlCase::N()->when(new SqlExpr(new Q($Q->constraints)),\n                new SqlField('ticket_id'));\n            $query = $query->aggregate(array(\n                \"q{$queue->id}\" => SqlAggregate::COUNT($expr)\n            ));\n        }\n\n        $counts = $query->values()->one();\n\n        apcu_store($key, $counts, 900);\n        return @$counts[\"q{$this->id}\"];\n    }\n\n    function updateExports($fields, $save=true) {\n\n        if (!$fields)\n            return false;\n\n        $order = array_keys($fields);\n\n        $new = $fields;\n        foreach ($this->exports as $f) {\n            $heading = $f->getHeading();\n            $key = $f->getPath();\n            if (!isset($fields[$key])) {\n                $this->exports->remove($f);\n                continue;\n            }\n\n            $f->set('heading', $heading);\n            $f->set('sort', array_search($key, $order)+1);\n            unset($new[$key]);\n        }\n\n        $exportableFields = CustomQueue::getExportableFields();\n        foreach ($new as $k => $field) {\n            if (isset($exportableFields[$k]))\n                $heading = $exportableFields[$k];\n            elseif (is_array($field))\n                $heading = $field['heading'];\n            else\n                $heading = $field;\n\n            $f = QueueExport::create(array(\n                        'path' => $k,\n                        'heading' => $heading,\n                        'sort' => array_search($k, $order)+1));\n            $this->exports->add($f);\n        }\n\n        $this->exports->sort(function($f) { return $f->sort; });\n\n        if (!count($this->exports) && $this->parent)\n            $this->hasFlag(self::FLAG_INHERIT_EXPORT);\n\n        if ($save)\n            $this->exports->saveAll();\n\n        return true;\n    }\n\n    function update($vars, &$errors=array()) {\n\n        // Set basic search information\n        if (!$vars['queue-name'])\n            $errors['queue-name'] = __('A title is required');\n        elseif (($q=CustomQueue::lookup(array(\n                        'title' => $vars['queue-name'],\n                        'parent_id' => $vars['parent_id'] ?: 0,\n                        'staff_id'  => $this->staff_id)))\n                && $q->getId() != $this->id\n                )\n            $errors['queue-name'] = __('Saved queue with same name exists');\n\n        $this->title = $vars['queue-name'];\n        $this->parent_id = @$vars['parent_id'] ?: 0;\n        if ($this->parent_id && !$this->parent)\n            $errors['parent_id'] = __('Select a valid queue');\n\n        // Try to avoid infinite recursion determining ancestry\n        if ($this->parent_id && isset($this->id)) {\n            $P = $this;\n            while ($P = $P->parent)\n                if ($P->parent_id == $this->id)\n                    $errors['parent_id'] = __('Cannot be a descendent of itself');\n        }\n\n        // Configure quick filter options\n        $this->filter = $vars['filter'];\n        if ($vars['sort_id']) {\n            if ($vars['filter'] === '::') {\n                if (!$this->parent)\n                    $errors['filter'] = __('No parent selected');\n            }\n            elseif ($vars['filter'] && !array_key_exists($vars['filter'],\n                static::getSearchableFields($this->getRoot()))\n            ) {\n                $errors['filter'] = __('Select an item from the list');\n            }\n        }\n\n        // Set basic queue information\n        $this->path = $this->buildPath();\n        $this->setFlag(self::FLAG_INHERIT_CRITERIA, $this->parent_id);\n        $this->setFlag(self::FLAG_INHERIT_COLUMNS,\n            $this->parent_id > 0 && isset($vars['inherit-columns']));\n        $this->setFlag(self::FLAG_INHERIT_EXPORT,\n            $this->parent_id > 0 && isset($vars['inherit-exports']));\n        $this->setFlag(self::FLAG_INHERIT_SORTING,\n            $this->parent_id > 0 && isset($vars['inherit-sorting']));\n\n        // Saved Search - Use standard columns\n        if ($this instanceof SavedSearch && isset($vars['inherit-columns']))\n            $this->setFlag(self::FLAG_INHERIT_COLUMNS);\n        // Update queue columns (but without save)\n        if (!isset($vars['columns']) && $this->parent) {\n            // No columns -- imply column inheritance\n            $this->setFlag(self::FLAG_INHERIT_COLUMNS);\n        }\n\n\n        if ($this->getId()\n                && isset($vars['columns'])\n                && !$this->hasFlag(self::FLAG_INHERIT_COLUMNS)) {\n\n\n            if ($this->columns->updateColumns($vars['columns'], $errors, array(\n                                'queue_id' => $this->getId(),\n                                'staff_id' => $this->staff_id)))\n                $this->columns->reset();\n        }\n\n        // Update export fields for the queue\n        if (isset($vars['exports']) &&\n                 !$this->hasFlag(self::FLAG_INHERIT_EXPORT)) {\n            $this->updateExports($vars['exports'], false);\n        }\n\n        if (!count($this->exports) && $this->parent)\n            $this->hasFlag(self::FLAG_INHERIT_EXPORT);\n\n        // Update advanced sorting options for the queue\n        if (isset($vars['sorts']) && !$this->hasFlag(self::FLAG_INHERIT_SORTING)) {\n            $new = $order = $vars['sorts'];\n            foreach ($this->sorts as $sort) {\n                $key = $sort->sort_id;\n                $idx = array_search($key, $vars['sorts']);\n                if (false === $idx) {\n                    $this->sorts->remove($sort);\n                }\n                else {\n                    $sort->set('sort', $idx);\n                    unset($new[$idx]);\n                }\n            }\n            // Add new columns\n            foreach ($new as $id) {\n                if (!$sort = QueueSort::lookup($id))\n                    continue;\n                $glue = new QueueSortGlue(array(\n                    'sort_id' => $id,\n                    'queue' => $this,\n                    'sort' => array_search($id, $order),\n                ));\n                $this->sorts->add($sort, $glue);\n            }\n            // Re-sort the in-memory columns array\n            $this->sorts->sort(function($c) { return $c->sort; });\n        }\n        if (!count($this->sorts) && $this->parent) {\n            // No sorting -- imply sorting inheritance\n            $this->setFlag(self::FLAG_INHERIT_SORTING);\n        }\n\n        // Configure default sorting\n        $this->setFlag(self::FLAG_INHERIT_DEF_SORT,\n            $this->parent && $vars['sort_id'] === '::');\n        if ($vars['sort_id']) {\n            if ($vars['sort_id'] === '::') {\n                if (!$this->parent)\n                    $errors['sort_id'] = __('No parent selected');\n            }\n            elseif ($qs = QueueSort::lookup($vars['sort_id'])) {\n                $this->sort_id = $vars['sort_id'];\n            }\n            else {\n                $errors['sort_id'] = __('Select an item from the list');\n            }\n        }\n\n        list($this->_conditions, $conditions)\n            = QueueColumn::getConditionsFromPost($vars, $this->id, $this->getRoot());\n\n        // TODO: Move this to SavedSearch::update() and adjust\n        //       AjaxSearch::_saveSearch()\n        $form = $form ?: $this->getForm($vars);\n        if (!$vars) {\n            $errors['criteria'] = __('No criteria specified');\n        }\n        elseif (!$form->isValid()) {\n            $errors['criteria'] = __('Validation errors exist on criteria');\n        }\n        else {\n            $this->criteria = static::isolateCriteria($form->getClean(),\n                $this->getRoot());\n            $this->config = JsonDataEncoder::encode([\n                'criteria' => $this->criteria,\n                'conditions' => $conditions,\n            ]);\n            // Clear currently set criteria.and conditions.\n             $this->criteria = $this->_conditions = null;\n        }\n\n        return 0 === count($errors);\n    }\n\n    function psave() {\n        return parent::save();\n    }\n\n    function save($refetch=false) {\n\n        $nopath = !isset($this->path);\n        $path_changed = isset($this->dirty['parent_id']);\n\n        if ($this->dirty)\n            $this->updated = SqlFunction::NOW();\n\n        $clearCounts = ($this->dirty || $this->__new__);\n        if (!($rv = parent::save($refetch || $this->dirty)))\n            return $rv;\n\n        if ($nopath) {\n            $this->path = $this->buildPath();\n            $this->save();\n        }\n        if ($path_changed) {\n            $this->children->reset();\n            $move_children = function($q) use (&$move_children) {\n                foreach ($q->children as $qq) {\n                    $qq->path = $qq->buildPath();\n                    $qq->save();\n                    $move_children($qq);\n                }\n            };\n            $move_children($this);\n        }\n\n        // Refetch the queue counts\n        if ($clearCounts)\n            SavedQueue::clearCounts();\n\n        return $this->columns->saveAll()\n            && $this->exports->saveAll()\n            && $this->sorts->saveAll();\n    }\n\n    /**\n     * Fetch a tree-organized listing of the queues. Each queue is listed in\n     * the tree exactly once, and every visible queue is represented. The\n     * returned structure is an array where the items are two-item arrays\n     * where the first item is a CustomQueue object an the second is a list\n     * of the children using the same pattern (two-item arrays of a CustomQueue\n     * and its children). Visually:\n     *\n     * [ [ $queue, [ [ $child, [] ], [ $child, [] ] ], [ $queue, ... ] ]\n     *\n     * Parameters:\n     * $staff - <Staff> staff object which should be used to determine\n     *      visible queues.\n     * $pid - <int> parent_id of root queue. Default is zero (top-level)\n     */\n    static function getHierarchicalQueues(Staff $staff, $pid=0,\n            $primary=true) {\n        $query = static::objects()\n            ->annotate(array('_sort' =>  SqlCase::N()\n                        ->when(array('sort' => 0), 999)\n                        ->otherwise(new SqlField('sort'))))\n            ->filter(Q::any(array(\n                'flags__hasbit' => self::FLAG_PUBLIC,\n                'flags__hasbit' => static::FLAG_QUEUE,\n                'staff_id' => $staff->getId(),\n            )))\n            ->exclude(['flags__hasbit' => self::FLAG_DISABLED])\n            ->order_by('parent_id', '_sort', 'title');\n        $all = $query->asArray();\n        // Find all the queues with a given parent\n        $for_parent = function($pid) use ($primary, $all, &$for_parent) {\n            $results = [];\n            foreach (new \\ArrayIterator($all) as $q) {\n                if ($q->parent_id != $pid)\n                    continue;\n\n                if ($pid == 0 && (\n                            ($primary &&  !$q->isAQueue())\n                            || (!$primary && $q->isAQueue())))\n                    continue;\n\n                $results[] = [ $q, $for_parent($q->getId()) ];\n            }\n\n            return $results;\n        };\n\n        return $for_parent($pid);\n    }\n\n    static function getOrmPath($name, $query=null) {\n        // Special case for custom data `__answers!id__value`. Only add the\n        // join and constraint on the query the first pass, when the query\n        // being mangled is received.\n        $path = array();\n        if ($query && preg_match('/^(.+?)__(answers!(\\d+))/', $name, $path)) {\n            // Add a join to the model of the queryset where the custom data\n            // is forked from \u2014 duplicate the 'answers' join and add the\n            // constraint to the query based on the field_id\n            // $path[1] - part before the answers (user__org__entries)\n            // $path[2] - answers!xx join part\n            // $path[3] - the `xx` part of the answers!xx join component\n            $root = $query->model;\n            $meta = $root::getMeta()->getByPath($path[1]);\n            $joins = $meta['joins'];\n            if (!isset($joins[$path[2]])) {\n                $meta->addJoin($path[2], $joins['answers']);\n            }\n            // Ensure that the query join through answers!xx is only for the\n            // records which match field_id=xx\n            $query->constrain(array(\"{$path[1]}__{$path[2]}\" =>\n                array(\"{$path[1]}__{$path[2]}__field_id\" => (int) $path[3])\n            ));\n            // Leave $name unchanged\n        }\n        return $name;\n    }\n\n\n    static function create($vars=false) {\n\n        $queue = new static($vars);\n        $queue->created = SqlFunction::NOW();\n        if (!isset($vars['flags'])) {\n            $queue->setFlag(self::FLAG_PUBLIC);\n            $queue->setFlag(self::FLAG_QUEUE);\n        }\n\n        return $queue;\n    }\n\n    static function __create($vars) {\n        $q = static::create($vars);\n        $q->psave();\n        foreach ($vars['columns'] ?: array() as $info) {\n            $glue = new QueueColumnGlue($info);\n            $glue->queue_id = $q->getId();\n            $glue->save();\n        }\n        if (isset($vars['sorts'])) {\n            foreach ($vars['sorts'] as $info) {\n                $glue = new QueueSortGlue($info);\n                $glue->queue_id = $q->getId();\n                $glue->save();\n            }\n        }\n        return $q;\n    }\n}\n\nabstract class QueueColumnAnnotation {\n    static $icon = false;\n    static $desc = '';\n\n    var $config;\n\n    function __construct($config) {\n        $this->config = $config;\n    }\n\n    static function fromJson($config) {\n        $class = $config['c'];\n        if (class_exists($class))\n            return new $class($config);\n    }\n\n    static function getDescription() {\n        return __(static::$desc);\n    }\n    static function getIcon() {\n        return static::$icon;\n    }\n    static function getPositions() {\n        return array(\n            \"<\" => __('Start'),\n            \"b\" => __('Before'),\n            \"a\" => __('After'),\n            \">\" => __('End'),\n        );\n    }\n\n    function decorate($text, $dec) {\n        static $positions = array(\n            '<' => '<span class=\"pull-left\">%2$s</span>%1$s',\n            '>' => '<span class=\"pull-right\">%2$s</span>%1$s',\n            'a' => '%1$s%2$s',\n            'b' => '%2$s%1$s',\n        );\n\n        $pos = $this->getPosition();\n        if (!isset($positions[$pos]))\n            return $text;\n\n        return sprintf($positions[$pos], $text, $dec);\n    }\n\n    // Render the annotation with the database record $row. $text is the\n    // text of the cell before annotations were applied.\n    function render($row, $cell) {\n        if ($decoration = $this->getDecoration($row, $cell))\n            return $this->decorate($cell, $decoration);\n\n        return $cell;\n    }\n\n    // Add the annotation to a QuerySet\n    abstract function annotate($query, $name);\n\n    // Fetch some HTML to render the decoration on the page. This function\n    // can return boolean FALSE to indicate no decoration should be applied\n    abstract function getDecoration($row, $text);\n\n    function getPosition() {\n        return strtolower($this->config['p']) ?: 'a';\n    }\n\n    function getClassName() {\n        return @$this->config['c'] ?: get_class();\n    }\n\n    static function getAnnotations($root) {\n        // Ticket annotations\n        static $annotations;\n        if (!isset($annotations[$root])) {\n            foreach (get_declared_classes() as $class)\n                if (is_subclass_of($class, get_called_class()))\n                    $annotations[$root][] = $class;\n        }\n        return $annotations[$root];\n    }\n\n    /**\n     * Estimate the width of the rendered annotation in pixels\n     */\n    function getWidth($row) {\n        return $this->isVisible($row) ? 25 : 0;\n    }\n\n    function isVisible($row) {\n        return true;\n    }\n\n    static function addToQuery($query, $name=false) {\n        $name = $name ?: static::$qname;\n        $annotation = new Static(array());\n        return $annotation->annotate($query, $name);\n    }\n\n    static function from_query($row, $name=false) {\n        $name = $name ?: static::$qname;\n        return $row[$name];\n    }\n}\n\nclass TicketThreadCount\nextends QueueColumnAnnotation {\n    static $icon = 'comments-alt';\n    static $qname = '_thread_count';\n    static $desc = /* @trans */ 'Thread Count';\n\n    function annotate($query, $name=false) {\n        $name = $name ?: static::$qname;\n        return $query->annotate(array(\n            $name => TicketThread::objects()\n            ->filter(array('ticket__ticket_id' => new SqlField('ticket_id', 1)))\n            ->exclude(array('entries__flags__hasbit' => ThreadEntry::FLAG_HIDDEN))\n            ->aggregate(array('count' => SqlAggregate::COUNT('entries__id')))\n        ));\n    }\n\n    function getDecoration($row, $text) {\n        $threadcount = $row[static::$qname];\n        if ($threadcount > 1) {\n            return sprintf(\n                '<small class=\"faded-more\"><i class=\"icon-comments-alt\"></i> %s</small>',\n                $threadcount\n            );\n        }\n    }\n\n    function isVisible($row) {\n        return $row[static::$qname] > 1;\n    }\n}\n\nclass TicketReopenCount\nextends QueueColumnAnnotation {\n    static $icon = 'folder-open-alt';\n    static $qname = '_reopen_count';\n    static $desc = /* @trans */ 'Reopen Count';\n\n    function annotate($query, $name=false) {\n        $name = $name ?: static::$qname;\n        return $query->annotate(array(\n            $name => TicketThread::objects()\n            ->filter(array('ticket__ticket_id' => new SqlField('ticket_id', 1)))\n            ->filter(array('events__annulled' => 0, 'events__event_id' => Event::getIdByName('reopened')))\n            ->aggregate(array('count' => SqlAggregate::COUNT('events__id')))\n        ));\n    }\n\n    function getDecoration($row, $text) {\n        $reopencount = $row[static::$qname];\n        if ($reopencount) {\n            return sprintf(\n                '&nbsp;<small class=\"faded-more\"><i class=\"icon-%s\"></i> %s</small>',\n                static::$icon,\n                $reopencount > 1 ? $reopencount : ''\n            );\n        }\n    }\n\n    function isVisible($row) {\n        return $row[static::$qname];\n    }\n}\n\nclass ThreadAttachmentCount\nextends QueueColumnAnnotation {\n    static $icon = 'paperclip';\n    static $qname = '_att_count';\n    static $desc = /* @trans */ 'Attachment Count';\n\n    function annotate($query, $name=false) {\n        // TODO: Convert to Thread attachments\n        $name = $name ?: static::$qname;\n        return $query->annotate(array(\n            $name => TicketThread::objects()\n            ->filter(array('ticket__ticket_id' => new SqlField('ticket_id', 1)))\n            ->filter(array('entries__attachments__inline' => 0))\n            ->aggregate(array('count' => SqlAggregate::COUNT('entries__attachments__id')))\n        ));\n    }\n\n    function getDecoration($row, $text) {\n        $count = $row[static::$qname];\n        if ($count) {\n            return sprintf(\n                '<i class=\"small icon-paperclip icon-flip-horizontal\" data-toggle=\"tooltip\" title=\"%s\"></i>',\n                $count);\n        }\n    }\n\n    function isVisible($row) {\n        return $row[static::$qname] > 0;\n    }\n}\n\nclass ThreadCollaboratorCount\nextends QueueColumnAnnotation {\n    static $icon = 'group';\n    static $qname = '_collabs';\n    static $desc = /* @trans */ 'Collaborator Count';\n\n    function annotate($query, $name=false) {\n        $name = $name ?: static::$qname;\n        return $query->annotate(array(\n            $name => TicketThread::objects()\n            ->filter(array('ticket__ticket_id' => new SqlField('ticket_id', 1)))\n            ->aggregate(array('count' => SqlAggregate::COUNT('collaborators__id')))\n        ));\n    }\n\n    function getDecoration($row, $text) {\n        $count = $row[static::$qname];\n        if ($count) {\n            return sprintf(\n                '<span class=\"pull-right faded-more\" data-toggle=\"tooltip\" title=\"%d\"><i class=\"icon-group\"></i></span>',\n                $count);\n        }\n    }\n\n    function isVisible($row) {\n        return $row[static::$qname] > 0;\n    }\n}\n\nclass OverdueFlagDecoration\nextends QueueColumnAnnotation {\n    static $icon = 'exclamation';\n    static $desc = /* @trans */ 'Overdue Icon';\n\n    function annotate($query, $name=false) {\n        return $query->values('isoverdue');\n    }\n\n    function getDecoration($row, $text) {\n        if ($row['isoverdue'])\n            return '<span class=\"Icon overdueTicket\"></span>';\n    }\n\n    function isVisible($row) {\n        return $row['isoverdue'];\n    }\n}\n\nclass TicketSourceDecoration\nextends QueueColumnAnnotation {\n    static $icon = 'phone';\n    static $desc = /* @trans */ 'Ticket Source';\n\n    function annotate($query, $name=false) {\n        return $query->values('source');\n    }\n\n    function getDecoration($row, $text) {\n        return sprintf('<span class=\"Icon %sTicket\"></span>',\n            strtolower($row['source']));\n    }\n}\n\nclass LockDecoration\nextends QueueColumnAnnotation {\n    static $icon = \"lock\";\n    static $desc = /* @trans */ 'Locked';\n\n    function annotate($query, $name=false) {\n        global $thisstaff;\n\n        return $query\n            ->annotate(array(\n                '_locked' => new SqlExpr(new Q(array(\n                    'lock__expire__gt' => SqlFunction::NOW(),\n                    Q::not(array('lock__staff_id' => $thisstaff->getId())),\n                )))\n            ));\n    }\n\n    function getDecoration($row, $text) {\n        if ($row['_locked'])\n            return sprintf('<span class=\"Icon lockedTicket\"></span>');\n    }\n\n    function isVisible($row) {\n        return $row['_locked'];\n    }\n}\n\nclass AssigneeAvatarDecoration\nextends QueueColumnAnnotation {\n    static $icon = \"user\";\n    static $desc = /* @trans */ 'Assignee Avatar';\n\n    function annotate($query, $name=false) {\n        return $query->values('staff_id', 'team_id');\n    }\n\n    function getDecoration($row, $text) {\n        if ($row['staff_id'] && ($staff = Staff::lookup($row['staff_id'])))\n            return sprintf('<span class=\"avatar\">%s</span>',\n                $staff->getAvatar(16));\n        elseif ($row['team_id'] && ($team = Team::lookup($row['team_id']))) {\n            $avatars = [];\n            foreach ($team->getMembers() as $T)\n                $avatars[] = $T->getAvatar(16);\n            return sprintf('<span class=\"avatar group %s\">%s</span>',\n                count($avatars), implode('', $avatars));\n        }\n    }\n\n    function isVisible($row) {\n        return $row['staff_id'] + $row['team_id'] > 0;\n    }\n\n    function getWidth($row) {\n        if (!$this->isVisible($row))\n            return 0;\n\n        // If assigned to a team with no members, return 0 width\n        $width = 10;\n        if ($row['team_id'] && ($team = Team::lookup($row['team_id'])))\n            $width += (count($team->getMembers()) - 1) * 10;\n\n        return $width ? $width + 10 : $width;\n    }\n}\n\nclass UserAvatarDecoration\nextends QueueColumnAnnotation {\n    static $icon = \"user\";\n    static $desc = /* @trans */ 'User Avatar';\n\n    function annotate($query, $name=false) {\n        return $query->values('user_id');\n    }\n\n    function getDecoration($row, $text) {\n        if ($row['user_id'] && ($user = User::lookup($row['user_id'])))\n            return sprintf('<span class=\"avatar\">%s</span>',\n                $user->getAvatar(16));\n    }\n\n    function isVisible($row) {\n        return $row['user_id'] > 0;\n    }\n}\n\nclass DataSourceField\nextends ChoiceField {\n    function getChoices($verbose=false) {\n        $config = $this->getConfiguration();\n        $root = $config['root'];\n        $fields = array();\n        foreach (CustomQueue::getSearchableFields($root) as $path=>$f) {\n            list($label,) = $f;\n            $fields[$path] = $label;\n        }\n        return $fields;\n    }\n}\n\nclass QueueColumnCondition {\n    var $config;\n    var $queue;\n    var $properties = array();\n\n    static $uid = 1;\n\n    function __construct($config, $queue=null) {\n        $this->config = $config;\n        $this->queue = $queue;\n        if (is_array($config['prop']))\n            $this->properties = $config['prop'];\n    }\n\n    function getProperties() {\n        return $this->properties;\n    }\n\n    // Add the annotation to a QuerySet\n    function annotate($query) {\n        if (!($Q = $this->getSearchQ($query)))\n            return $query;\n\n        // Add an annotation to the query\n        return $query->annotate(array(\n            $this->getAnnotationName() => new SqlExpr(array($Q))\n        ));\n    }\n\n    function getField($name=null) {\n        // FIXME\n        #$root = $this->getColumn()->getRoot();\n        $root = 'Ticket';\n        $searchable = CustomQueue::getSearchableFields($root);\n\n        if (!isset($name))\n            list($name) = $this->config['crit'];\n\n        // Lookup the field to search this condition\n        if (isset($searchable[$name])) {\n            return $searchable[$name];\n        }\n    }\n\n    function getFieldName() {\n        list($name) = $this->config['crit'];\n        return $name;\n    }\n\n    function getCriteria() {\n        return $this->config['crit'];\n    }\n\n    function getSearchQ($query) {\n        list($name, $method, $value) = $this->config['crit'];\n\n        // XXX: Move getOrmPath to be more of a utility\n        // Ensure the special join is created to support custom data joins\n        $name = @CustomQueue::getOrmPath($name, $query);\n\n        $name2 = null;\n        if (preg_match('/__answers!\\d+__/', $name)) {\n            // Ensure that only one record is returned from the join through\n            // the entry and answers joins\n            $name2 = $this->getAnnotationName().'2';\n            $query->annotate(array($name2 => SqlAggregate::MAX($name)));\n        }\n\n        // Fetch a criteria Q for the query\n        if (list(,$field) = $this->getField($name))\n            return $field->getSearchQ($method, $value, $name2 ?: $name);\n    }\n\n    /**\n     * Take the criteria from the SavedSearch fields setup and isolate the\n     * field name being search, the method used for searhing, and the method-\n     * specific data entered in the UI.\n     */\n    static function isolateCriteria($criteria, $base='Ticket') {\n        $searchable = CustomQueue::getSearchableFields($base);\n        foreach ($criteria as $k=>$v) {\n            if (substr($k, -7) === '+method') {\n                list($name,) = explode('+', $k, 2);\n                if (!isset($searchable[$name]))\n                    continue;\n\n                // Lookup the field to search this condition\n                list($label, $field) = $searchable[$name];\n\n                // Get the search method and value\n                $method = $v;\n                // Not all search methods require a value\n                $value = $criteria[\"{$name}+{$method}\"];\n\n                return array($name, $method, $value);\n            }\n        }\n    }\n\n    function render($row, $text, &$styles=array()) {\n        if ($V = $row[$this->getAnnotationName()]) {\n            foreach ($this->getProperties() as $css=>$value) {\n                $field = QueueColumnConditionProperty::getField($css);\n                $field->value = $value;\n                $V = $field->getClean();\n                if (is_array($V))\n                    $V = current($V);\n                $styles[$css] = $V;\n            }\n        }\n        return $text;\n    }\n\n    function getAnnotationName() {\n        // This should be predictable based on the criteria so that the\n        // query can deduplicate the same annotations used in different\n        // conditions\n        if (!isset($this->annotation_name)) {\n            $this->annotation_name = $this->getShortHash();\n        }\n        return $this->annotation_name;\n    }\n\n    function __toString() {\n        list($name, $method, $value) = $this->config['crit'];\n        if (is_array($value))\n            $value = implode('+', $value);\n\n        return \"{$name} {$method} {$value}\";\n    }\n\n    function getHash($binary=false) {\n        return sha1($this->__toString(), $binary);\n    }\n\n    function getShortHash() {\n        return substr(base64_encode($this->getHash(true)), 0, 7);\n    }\n\n    static function getUid() {\n        return static::$uid++;\n    }\n\n    static function fromJson($config, $queue=null) {\n        if (is_string($config))\n            $config = JsonDataParser::decode($config);\n        if (!is_array($config))\n            throw new BadMethodCallException('$config must be string or array');\n\n        return new static($config, $queue);\n    }\n}\n\nclass QueueColumnConditionProperty\nextends ChoiceField {\n    static $properties = array(\n        'background-color' => 'ColorChoiceField',\n        'color' => 'ColorChoiceField',\n        'font-family' => array(\n            'monospace', 'serif', 'sans-serif', 'cursive', 'fantasy',\n        ),\n        'font-size' => array(\n            'small', 'medium', 'large', 'smaller', 'larger',\n        ),\n        'font-style' => array(\n            'normal', 'italic', 'oblique',\n        ),\n        'font-weight' => array(\n            'lighter', 'normal', 'bold', 'bolder',\n        ),\n        'text-decoration' => array(\n            'none', 'underline',\n        ),\n        'text-transform' => array(\n            'uppercase', 'lowercase', 'captalize',\n        ),\n    );\n\n    function __construct($property) {\n        $this->property = $property;\n    }\n\n    static function getProperties() {\n        return array_keys(static::$properties);\n    }\n\n    static function getField($prop) {\n        $choices = static::$properties[$prop];\n        if (!isset($choices))\n            return null;\n        if (is_array($choices))\n            return new ChoiceField(array(\n                'name' => $prop,\n                'choices' => array_combine($choices, $choices),\n            ));\n        elseif (class_exists($choices))\n            return new $choices(array('name' => $prop));\n    }\n\n    function getChoices($verbose=false) {\n        if (isset($this->property))\n            return static::$properties[$this->property];\n\n        $keys = array_keys(static::$properties);\n        return array_combine($keys, $keys);\n    }\n}\n\nclass LazyDisplayWrapper {\n    function __construct($field, $value) {\n        $this->field = $field;\n        $this->value = $value;\n        $this->safe = false;\n    }\n\n    /**\n     * Allow a filter to change the value of this to a \"safe\" value which\n     * will not be automatically encoded with htmlchars()\n     */\n    function changeTo($what, $safe=false) {\n        $this->field = null;\n        $this->value = $what;\n        $this->safe = $safe;\n    }\n\n    function __toString() {\n        return $this->display();\n    }\n\n    function display(&$styles=array()) {\n        if (isset($this->field))\n            return $this->field->display(\n                $this->field->to_php($this->value), $styles);\n        if ($this->safe)\n            return $this->value;\n        return Format::htmlchars($this->value);\n    }\n}\n\n/**\n * A column of a custom queue. Columns have many customizable features\n * including:\n *\n *   * Data Source (primary and secondary)\n *   * Heading\n *   * Link (to an object like the ticket)\n *   * Size and truncate settings\n *   * annotations (like counts and flags)\n *   * Conditions (which change the formatting like bold text)\n *\n * Columns are stored in a separate table from the queue itself, but other\n * breakout items for the annotations and conditions, for instance, are stored\n * as JSON text in the QueueColumn model.\n */\nclass QueueColumn\nextends VerySimpleModel {\n    static $meta = array(\n        'table' => COLUMN_TABLE,\n        'pk' => array('id'),\n        'ordering' => array('name'),\n    );\n\n    const FLAG_SORTABLE = 0x0001;\n\n    var $_annotations;\n    var $_conditions;\n    var $_queue;            // Apparent queue if being inherited\n    var $_fields;\n\n    function getId() {\n        return $this->id;\n    }\n\n    function getFilter() {\n         if ($this->filter\n                && ($F = QueueColumnFilter::getInstance($this->filter)))\n            return $F;\n     }\n\n    function getName() {\n        return $this->name;\n    }\n\n    // These getters fetch data from the annotated overlay from the\n    // queue_column table\n    function getQueue() {\n        if (!isset($this->_queue)) {\n            $queue = $this->queue;\n\n            if (!$queue && ($queue_id = $this->queue_id) && is_numeric($queue_id))\n                $queue = CustomQueue::lookup($queue_id);\n\n            $this->_queue = $queue;\n        }\n\n        return $this->_queue;\n    }\n    /**\n     * If a column is inherited into a child queue and there are conditions\n     * added to that queue, then the column will need to be linked at\n     * run-time to the child queue rather than the parent.\n     */\n    function setQueue(CustomQueue $queue) {\n        $this->_queue = $queue;\n    }\n\n    function getFields() {\n        if (!isset($this->_fields)) {\n            $root = ($q = $this->getQueue()) ? $q->getRoot() : 'Ticket';\n            $fields = CustomQueue::getSearchableFields($root);\n            $primary = CustomQueue::getOrmPath($this->primary);\n            $secondary = CustomQueue::getOrmPath($this->secondary);\n            if (($F = $fields[$primary]) && (list(,$field) = $F))\n                $this->_fields[$primary] = $field;\n            if (($F = $fields[$secondary]) && (list(,$field) = $F))\n                $this->_fields[$secondary] = $field;\n        }\n        return $this->_fields;\n    }\n\n    function getField($path=null) {\n        $fields = $this->getFields();\n        return @$fields[$path ?: $this->primary];\n    }\n\n    function getWidth() {\n        return $this->width ?: 100;\n    }\n\n    function getHeading() {\n        return $this->heading;\n    }\n\n    function getTranslateTag($subtag) {\n        return _H(sprintf('column.%s.%s.%s', $subtag, $this->queue_id, $this->id));\n    }\n    function getLocal($subtag) {\n        $tag = $this->getTranslateTag($subtag);\n        $T = CustomDataTranslation::translate($tag);\n        return $T != $tag ? $T : $this->get($subtag);\n    }\n    function getLocalHeading() {\n        return $this->getLocal('heading');\n    }\n\n    protected function setFlag($flag, $value=true, $field='flags') {\n        return $value\n            ? $this->{$field} |= $flag\n            : $this->clearFlag($flag, $field);\n    }\n\n    protected function clearFlag($flag, $field='flags') {\n        return $this->{$field} &= ~$flag;\n    }\n\n    function isSortable() {\n        return $this->bits & self::FLAG_SORTABLE;\n    }\n\n    function setSortable($sortable) {\n        $this->setFlag(self::FLAG_SORTABLE, $sortable, 'bits');\n    }\n\n    function render($row) {\n        // Basic data\n        $text = $this->renderBasicValue($row);\n\n        // Filter\n        if ($text && ($filter = $this->getFilter())) {\n            $text = $filter->filter($text, $row) ?: $text;\n        }\n\n        $styles = array();\n        if ($text instanceof LazyDisplayWrapper) {\n            $text = $text->display($styles);\n        }\n\n        // Truncate\n        $text = $this->applyTruncate($text, $row);\n\n        // annotations and conditions\n        foreach ($this->getAnnotations() as $D) {\n            $text = $D->render($row, $text);\n        }\n        foreach ($this->getConditions() as $C) {\n            $text = $C->render($row, $text, $styles);\n        }\n        $style = Format::array_implode(':', ';', $styles);\n        return array($text, $style);\n    }\n\n    function renderBasicValue($row) {\n        $fields = $this->getFields();\n        $primary = CustomQueue::getOrmPath($this->primary);\n        $secondary = CustomQueue::getOrmPath($this->secondary);\n\n        // Return a lazily ::display()ed value so that the value to be\n        // rendered by the field could be changed or display()ed when\n        // converted to a string.\n        if (($F = $fields[$primary])\n            && ($T = $F->from_query($row, $primary))\n        ) {\n            return new LazyDisplayWrapper($F, $T);\n        }\n        if (($F = $fields[$secondary])\n            && ($T = $F->from_query($row, $secondary))\n        ) {\n            return new LazyDisplayWrapper($F, $T);\n        }\n\n         return new LazyDisplayWrapper($F, '');\n    }\n\n    function from_query($row) {\n        if (!($f = $this->getField($this->primary)))\n            return '';\n\n        $val = $f->to_php($f->from_query($row, $this->primary));\n        if (!is_string($val))\n            $val = $f->display($val);\n\n        return $val;\n    }\n\n    function applyTruncate($text, $row) {\n        $offset = 0;\n        foreach ($this->getAnnotations() as $a)\n            $offset += $a->getWidth($row);\n\n        $width = $this->width - $offset;\n        $class = array();\n        switch ($this->truncate) {\n        case 'lclip':\n            $linfo = Internationalization::getCurrentLanguageInfo();\n            // Use `rtl` class to cut the beginning of LTR text. But, wrap\n            // the text with an appropriate direction so the ending\n            // punctuation is not rearranged.\n            $dir = $linfo['direction'] ?: 'ltr';\n            $text = sprintf('<span class=\"%s\">%s</span>', $dir, $text);\n            $class[] = $dir == 'rtl' ? 'ltr' : 'rtl';\n        case 'clip':\n            $class[] = 'bleed';\n        case 'ellipsis':\n            $class[] = 'truncate';\n            return sprintf('<span class=\"%s\" style=\"max-width:%dpx\">%s</span>',\n                implode(' ', $class), $width, $text);\n        default:\n        case 'wrap':\n            return $text;\n        }\n    }\n\n    function addToQuery($query, $field, $path) {\n        if (preg_match('/__answers!\\d+__/', $path)) {\n            // Ensure that only one record is returned from the join through\n            // the entry and answers joins\n            return $query->annotate(array(\n                $path => SqlAggregate::MAX($path)\n            ));\n        }\n        return $field->addToQuery($query, $path);\n    }\n\n    function mangleQuery($query, $root=null) {\n        // Basic data\n        $fields = $this->getFields();\n        if ($field = $fields[$this->primary]) {\n            $query = $this->addToQuery($query, $field,\n                CustomQueue::getOrmPath($this->primary, $query));\n        }\n        if ($field = $fields[$this->secondary]) {\n            $query = $this->addToQuery($query, $field,\n                CustomQueue::getOrmPath($this->secondary, $query));\n        }\n\n        if ($filter = $this->getFilter())\n            $query = $filter->mangleQuery($query, $this);\n\n        // annotations\n        foreach ($this->getAnnotations() as $D) {\n            $query = $D->annotate($query);\n        }\n\n        // Conditions\n        foreach ($this->getConditions() as $C) {\n            $query = $C->annotate($query);\n        }\n\n        return $query;\n    }\n\n    function applySort($query, $reverse=false) {\n\t    $root = ($q = $this->getQueue()) ? $q->getRoot() : 'Ticket';\n        $fields = CustomQueue::getSearchableFields($root);\n\n        $keys = array();\n        if ($primary = $fields[$this->primary]) {\n            list(,$field) = $primary;\n            $keys[] = array(CustomQueue::getOrmPath($this->primary, $query),\n                    $field);\n        }\n\n        if ($secondary = $fields[$this->secondary]) {\n            list(,$field) = $secondary;\n            $keys[] = array(CustomQueue::getOrmPath($this->secondary,\n                        $query), $field);\n        }\n\n        if (count($keys) > 1) {\n            $fields = array();\n            foreach ($keys as $key) {\n                list($path, $field) = $key;\n                foreach ($field->getSortKeys($path) as $field)\n                    $fields[]  = new SqlField($field);\n            }\n            // Force nulls to the buttom.\n            $fields[] = 'zzz';\n\n            $alias = sprintf('C%d', $this->getId());\n            $expr = call_user_func_array(array('SqlFunction', 'COALESCE'),\n                    $fields);\n            $query->annotate(array($alias => $expr));\n\n            $reverse = $reverse ? '-' : '';\n            $query = $query->order_by(\"{$reverse}{$alias}\");\n        } elseif($keys[0]) {\n            list($path, $field) = $keys[0];\n            $query = $field->applyOrderBy($query, $reverse, $path);\n        }\n\n        return $query;\n    }\n\n    function getDataConfigForm($source=false) {\n        return new QueueColDataConfigForm($source ?: $this->getDbFields(),\n            array('id' => $this->id));\n    }\n\n    function getAnnotations() {\n        if (!isset($this->_annotations)) {\n            $this->_annotations = array();\n            if ($this->annotations\n                && ($anns = JsonDataParser::decode($this->annotations))\n            ) {\n                foreach ($anns as $D)\n                    if ($T = QueueColumnAnnotation::fromJson($D))\n                        $this->_annotations[] = $T;\n            }\n        }\n        return $this->_annotations;\n    }\n\n    function getConditions($include_queue=true) {\n        if (!isset($this->_conditions)) {\n            $this->_conditions = array();\n            if ($this->conditions\n                && ($conds = JsonDataParser::decode($this->conditions))\n            ) {\n                foreach ($conds as $C)\n                    if ($T = QueueColumnCondition::fromJson($C))\n                        $this->_conditions[] = $T;\n            }\n            // Support row-spanning conditions\n            if ($include_queue && ($q = $this->getQueue())\n                && ($q_conds = $q->getConditions())\n            ) {\n                $this->_conditions = array_merge($q_conds, $this->_conditions);\n            }\n        }\n        return $this->_conditions;\n    }\n\n    static function __create($vars) {\n        $c = new static($vars);\n        $c->save();\n        return $c;\n    }\n\n    static function placeholder($vars) {\n        return static::__hydrate($vars);\n    }\n\n    function update($vars, $root='Ticket') {\n        $form = $this->getDataConfigForm($vars);\n        foreach ($form->getClean() as $k=>$v)\n            $this->set($k, $v);\n\n        // Do the annotations\n        $this->_annotations = $annotations = array();\n        if (isset($vars['annotations'])) {\n            foreach (@$vars['annotations'] as $i=>$class) {\n                if ($vars['deco_column'][$i] != $this->id)\n                    continue;\n                if (!class_exists($class) || !is_subclass_of($class, 'QueueColumnAnnotation'))\n                    continue;\n                $json = array('c' => $class, 'p' => $vars['deco_pos'][$i]);\n                $annotations[] = $json;\n                $this->_annotations[] = QueueColumnAnnotation::fromJson($json);\n            }\n        }\n\n        // Do the conditions\n        $this->_conditions = $conditions = array();\n        if (isset($vars['conditions'])) {\n            list($this->_conditions, $conditions)\n                = self::getConditionsFromPost($vars, $this->id, $root);\n        }\n\n        // Store as JSON array\n        $this->annotations = JsonDataEncoder::encode($annotations);\n        $this->conditions = JsonDataEncoder::encode($conditions);\n    }\n\n    static function getConditionsFromPost(array $vars, $myid, $root='Ticket') {\n        $condition_objects = $conditions = array();\n\n        if (!isset($vars['conditions']))\n            return array($condition_objects, $conditions);\n\n        foreach (@$vars['conditions'] as $i=>$id) {\n            if ($vars['condition_column'][$i] != $myid)\n                // Not a condition for this column\n                continue;\n            // Determine the criteria\n            $name = $vars['condition_field'][$i];\n            $fields = CustomQueue::getSearchableFields($root);\n            if (!isset($fields[$name]))\n                // No such field exists for this queue root type\n                continue;\n            $parts = CustomQueue::getSearchField($fields[$name], $name);\n            $search_form = new SimpleForm($parts, $vars, array('id' => $id));\n            $search_form->getField(\"{$name}+search\")->value = true;\n            $crit = $search_form->getClean();\n            // Check the box to enable searching on the field\n            $crit[\"{$name}+search\"] = true;\n\n            // Isolate only the critical parts of the criteria\n            $crit = QueueColumnCondition::isolateCriteria($crit);\n\n            // Determine the properties\n            $props = array();\n            foreach ($vars['properties'] as $i=>$cid) {\n                if ($cid != $id)\n                    // Not a property for this condition\n                    continue;\n\n                // Determine the property configuration\n                $prop = $vars['property_name'][$i];\n                if (!($F = QueueColumnConditionProperty::getField($prop))) {\n                    // Not a valid property\n                    continue;\n                }\n                $prop_form = new SimpleForm(array($F), $vars, array('id' => $cid));\n                $props[$prop] = $prop_form->getField($prop)->getClean();\n            }\n            $json = array('crit' => $crit, 'prop' => $props);\n            $condition_objects[] = QueueColumnCondition::fromJson($json);\n            $conditions[] = $json;\n        }\n        return array($condition_objects, $conditions);\n    }\n}\n\n\nclass QueueConfig\nextends VerySimpleModel {\n    static $meta = array(\n        'table' => QUEUE_CONFIG_TABLE,\n        'pk' => array('queue_id', 'staff_id'),\n        'joins' => array(\n            'queue' => array(\n                'constraint' => array(\n                    'queue_id' => 'CustomQueue.id'),\n            ),\n            'staff' => array(\n                'constraint' => array(\n                    'staff_id' => 'Staff.staff_id',\n                )\n            ),\n            'columns' => array(\n                'reverse' => 'QueueColumnGlue.config',\n                'constrain' => array('staff_id' =>'QueueColumnGlue.staff_id'),\n                'broker' => 'QueueColumnListBroker',\n            ),\n        ),\n    );\n\n    function getSettings() {\n        return JsonDataParser::decode($this->setting);\n    }\n\n\n    function update($vars, &$errors) {\n\n        // settings of interest\n        $setting = array(\n                'sort_id' => (int) $vars['sort_id'],\n                'filter' => $vars['filter'],\n                'inherit-columns' => isset($vars['inherit-columns']),\n                'criteria' => $vars['criteria'] ?: array(),\n                );\n\n        if (!$setting['inherit-columns'] && $vars['columns']) {\n            if (!$this->columns->updateColumns($vars['columns'], $errors, array(\n                                'queue_id' => $this->queue_id,\n                                'staff_id' => $this->staff_id)))\n                $setting['inherit-columns'] = true;\n            $this->columns->reset();\n        }\n\n        $this->setting =  JsonDataEncoder::encode($setting);\n\n        return $this->save();\n    }\n\n    function save($refetch=false) {\n        if ($this->dirty)\n            $this->updated = SqlFunction::NOW();\n        return parent::save($refetch || $this->dirty);\n    }\n\n    static function create($vars=false) {\n        $inst = new static($vars);\n        return $inst;\n    }\n}\n\n\nclass QueueExport\nextends VerySimpleModel {\n    static $meta = array(\n        'table' => QUEUE_EXPORT_TABLE,\n        'pk' => array('id'),\n        'joins' => array(\n            'queue' => array(\n                'constraint' => array('queue_id' => 'CustomQueue.id'),\n            ),\n        ),\n        'select_related' => array('queue'),\n        'ordering' => array('sort'),\n    );\n\n\n    function getPath() {\n        return $this->path;\n    }\n\n    function getField() {\n        return $this->getPath();\n    }\n\n    function getHeading() {\n        return $this->heading;\n    }\n\n    static function create($vars=false) {\n        $inst = new static($vars);\n        return $inst;\n    }\n}\n\nclass QueueColumnGlue\nextends VerySimpleModel {\n    static $meta = array(\n        'table' => QUEUE_COLUMN_TABLE,\n        'pk' => array('queue_id', 'staff_id', 'column_id'),\n        'joins' => array(\n            'column' => array(\n                'constraint' => array('column_id' => 'QueueColumn.id'),\n            ),\n            'queue' => array(\n                'constraint' => array(\n                    'queue_id' => 'CustomQueue.id',\n                    'staff_id' => 'CustomQueue.staff_id'),\n            ),\n            'config' => array(\n                'constraint' => array(\n                    'queue_id' => 'QueueConfig.queue_id',\n                    'staff_id' => 'QueueConfig.staff_id'),\n            ),\n        ),\n        'select_related' => array('column'),\n        'ordering' => array('sort'),\n    );\n}\n\nclass QueueColumnGlueMIM\nextends ModelInstanceManager {\n    function getOrBuild($modelClass, $fields, $cache=true) {\n        $m = parent::getOrBuild($modelClass, $fields, $cache);\n        if ($m && $modelClass === 'QueueColumnGlue') {\n            // Instead, yield the QueueColumn instance with the local fields\n            // in the association table as annotations\n            $m = AnnotatedModel::wrap($m->column, $m, 'QueueColumn');\n        }\n        return $m;\n    }\n}\n\nclass QueueColumnListBroker\nextends InstrumentedList {\n    function __construct($fkey, $queryset=false) {\n        parent::__construct($fkey, $queryset, 'QueueColumnGlueMIM');\n        $this->queryset->select_related('column');\n    }\n\n    function add($column, $glue=null, $php7_is_annoying=true) {\n        $glue = $glue ?: new QueueColumnGlue();\n        $glue->column = $column;\n        $anno = AnnotatedModel::wrap($column, $glue);\n        parent::add($anno, false);\n        return $anno;\n    }\n\n    function updateColumns($columns, &$errors, $options=array()) {\n        $new = $columns;\n        $order = array_keys($new);\n        foreach ($this as $col) {\n            $key = $col->column_id;\n            if (!isset($columns[$key])) {\n                $this->remove($col);\n                continue;\n            }\n            $info = $columns[$key];\n            $col->set('sort', array_search($key, $order));\n            $col->set('heading', $info['heading']);\n            $col->set('width', $info['width']);\n            $col->setSortable($info['sortable']);\n            unset($new[$key]);\n        }\n        // Add new columns\n        foreach ($new as $info) {\n            $glue = new QueueColumnGlue(array(\n                'staff_id' => $options['staff_id'] ?: 0 ,\n                'queue_id' => $options['queue_id'] ?: 0,\n                'column_id' => $info['column_id'],\n                'sort' => array_search($info['column_id'], $order),\n                'heading' => $info['heading'],\n                'width' => $info['width'] ?: 100,\n                'bits' => $info['sortable'] ?  QueueColumn::FLAG_SORTABLE : 0,\n            ));\n\n            $this->add(QueueColumn::lookup($info['column_id']), $glue);\n        }\n        // Re-sort the in-memory columns array\n        $this->sort(function($c) { return $c->sort; });\n\n        return $this->saveAll();\n    }\n}\n\nclass QueueSort\nextends VerySimpleModel {\n    static $meta = array(\n        'table' => QUEUE_SORT_TABLE,\n        'pk' => array('id'),\n        'ordering' => array('name'),\n        'joins' => array(\n            'queue' => array(\n                'constraint' => array('queue_id' => 'CustomQueue.id'),\n            ),\n        ),\n    );\n\n    var $_columns;\n    var $_extra;\n\n    function getRoot($hint=false) {\n        switch ($hint ?: $this->root) {\n        case 'T':\n        default:\n            return 'Ticket';\n        }\n    }\n\n    function getName() {\n        return $this->name;\n    }\n\n    function getId() {\n        return $this->id;\n    }\n\n    function getExtra() {\n        if (isset($this->extra) && !isset($this->_extra))\n            $this->_extra = JsonDataParser::decode($this->extra);\n        return $this->_extra;\n    }\n\n    function applySort(QuerySet $query, $reverse=false, $root=false) {\n        $fields = CustomQueue::getSearchableFields($this->getRoot($root));\n        foreach ($this->getColumnPaths() as $path=>$descending) {\n            $descending = $reverse ? !$descending : $descending;\n            if (isset($fields[$path])) {\n                list(,$field) = $fields[$path];\n                $query = $field->applyOrderBy($query, $descending,\n                    CustomQueue::getOrmPath($path, $query));\n            }\n        }\n        // Add index hint if defined\n        if (($extra = $this->getExtra()) && isset($extra['index'])) {\n            $query->setOption(QuerySet::OPT_INDEX_HINT, $extra['index']);\n        }\n        return $query;\n    }\n\n    function getColumnPaths() {\n        if (!isset($this->_columns)) {\n            $columns = array();\n            foreach (JsonDataParser::decode($this->columns) as $path) {\n                if ($descending = $path[0] == '-')\n                    $path = substr($path, 1);\n                $columns[$path] = $descending;\n            }\n            $this->_columns = $columns;\n        }\n        return $this->_columns;\n    }\n\n    function getColumns() {\n        $columns = array();\n        $paths = $this->getColumnPaths();\n        $everything = CustomQueue::getSearchableFields($this->getRoot());\n        foreach ($paths as $p=>$descending) {\n            if (isset($everything[$p])) {\n                $columns[$p] = array($everything[$p], $descending);\n            }\n        }\n        return $columns;\n    }\n\n    function getDataConfigForm($source=false) {\n        return new QueueSortDataConfigForm($source ?: $this->getDbFields(),\n            array('id' => $this->id));\n    }\n\n    function getAdvancedConfigForm($source=false) {\n        return new QueueSortAdvancedConfigForm($source ?: $this->getExtra(),\n            array('id' => $this->id));\n    }\n\n    static function forQueue(CustomQueue $queue) {\n        return static::objects()->filter([\n            'root' => $queue->root ?: 'T',\n        ]);\n    }\n\n    function save($refetch=false) {\n        if ($this->dirty)\n            $this->updated = SqlFunction::NOW();\n        return parent::save($refetch || $this->dirty);\n    }\n\n    function update($vars, &$errors=array()) {\n        if (!isset($vars['name']))\n            $errors['name'] = __('A title is required');\n\n        $this->name = $vars['name'];\n        if (isset($vars['root']))\n            $this->root = $vars['root'];\n        elseif (!isset($this->root))\n            $this->root = 'T';\n\n        $fields = CustomQueue::getSearchableFields($this->getRoot($vars['root']));\n        $columns = array();\n        if (@is_array($vars['columns'])) {\n            foreach ($vars['columns']as $path=>$info) {\n                $descending = (int) @$info['descending'];\n                // TODO: Check if column is valid, stash in $columns\n                if (!isset($fields[$path]))\n                    continue;\n                $columns[] = ($descending ? '-' : '') . $path;\n            }\n            $this->columns = JsonDataEncoder::encode($columns);\n        }\n\n        if ($this->getExtra() !== null) {\n            $extra = $this->getAdvancedConfigForm($vars)->getClean();\n            $this->extra = JsonDataEncoder::encode($extra);\n        }\n\n        if (count($errors))\n            return false;\n\n        return $this->save();\n    }\n\n    static function __create($vars) {\n        $c = new static($vars);\n        $c->save();\n        return $c;\n    }\n}\n\nclass QueueSortGlue\nextends VerySimpleModel {\n    static $meta = array(\n        'table' => QUEUE_SORTING_TABLE,\n        'pk' => array('sort_id', 'queue_id'),\n        'joins' => array(\n            'ordering' => array(\n                'constraint' => array('sort_id' => 'QueueSort.id'),\n            ),\n            'queue' => array(\n                'constraint' => array('queue_id' => 'CustomQueue.id'),\n            ),\n        ),\n        'select_related' => array('ordering', 'queue'),\n        'ordering' => array('sort'),\n    );\n}\n\nclass QueueSortGlueMIM\nextends ModelInstanceManager {\n    function getOrBuild($modelClass, $fields, $cache=true) {\n        $m = parent::getOrBuild($modelClass, $fields, $cache);\n        if ($m && $modelClass === 'QueueSortGlue') {\n            // Instead, yield the QueueColumn instance with the local fields\n            // in the association table as annotations\n            $m = AnnotatedModel::wrap($m->ordering, $m, 'QueueSort');\n        }\n        return $m;\n    }\n}\n\nclass QueueSortListBroker\nextends InstrumentedList {\n    function __construct($fkey, $queryset=false) {\n        parent::__construct($fkey, $queryset, 'QueueSortGlueMIM');\n        $this->queryset->select_related('ordering');\n    }\n\n    function add($ordering, $glue=null, $php7_is_annoying=true) {\n        $glue = $glue ?: new QueueSortGlue();\n        $glue->ordering = $ordering;\n        $anno = AnnotatedModel::wrap($ordering, $glue);\n        parent::add($anno, false);\n        return $anno;\n    }\n}\n\nabstract class QueueColumnFilter {\n    static $registry;\n\n    static $id = null;\n    static $desc = null;\n\n    static function register($filter, $group) {\n        if (!isset($filter::$id))\n            throw new Exception('QueueColumnFilter must define $id');\n        if (isset(static::$registry[$filter::$id]))\n            throw new Exception($filter::$id\n                . ': QueueColumnFilter already registered under that id');\n        if (!is_subclass_of($filter, get_called_class()))\n            throw new Exception('Filter must extend QueueColumnFilter');\n\n        static::$registry[$filter::$id] = array($group, $filter);\n    }\n\n    static function getFilters() {\n        $list = static::$registry;\n        $base = array();\n        foreach ($list as $id=>$stuff) {\n            list($group, $class) = $stuff;\n            $base[$group][$id] = __($class::$desc);\n        }\n        return $base;\n    }\n\n    static function getInstance($id) {\n        if (isset(static::$registry[$id])) {\n            list(, $class) = @static::$registry[$id];\n            if ($class && class_exists($class))\n                return new $class();\n        }\n    }\n\n    function mangleQuery($query, $column) { return $query; }\n\n    abstract function filter($value, $row);\n}\n\nclass TicketLinkFilter\nextends QueueColumnFilter {\n    static $id = 'link:ticket';\n    static $desc = /* @trans */ \"Ticket Link\";\n\n    function filter($text, $row) {\n        if ($link = $this->getLink($row))\n            return sprintf('<a style=\"display:inline\" href=\"%s\">%s</a>', $link, $text);\n    }\n\n    function mangleQuery($query, $column) {\n        static $fields = array(\n            'link:ticket'   => 'ticket_id',\n            'link:ticketP'  => 'ticket_id',\n            'link:user'     => 'user_id',\n            'link:org'      => 'user__org_id',\n        );\n\n        if (isset($fields[static::$id])) {\n            $query = $query->values($fields[static::$id]);\n        }\n        return $query;\n    }\n\n    function getLink($row) {\n        return Ticket::getLink($row['ticket_id']);\n    }\n}\n\nclass UserLinkFilter\nextends TicketLinkFilter {\n    static $id = 'link:user';\n    static $desc = /* @trans */ \"User Link\";\n\n    function getLink($row) {\n        return User::getLink($row['user_id']);\n    }\n}\n\nclass OrgLinkFilter\nextends TicketLinkFilter {\n    static $id = 'link:org';\n    static $desc = /* @trans */ \"Organization Link\";\n\n    function getLink($row) {\n        return Organization::getLink($row['user__org_id']);\n    }\n}\nQueueColumnFilter::register('TicketLinkFilter', __('Link'));\nQueueColumnFilter::register('UserLinkFilter', __('Link'));\nQueueColumnFilter::register('OrgLinkFilter', __('Link'));\n\nclass TicketLinkWithPreviewFilter\nextends TicketLinkFilter {\n    static $id = 'link:ticketP';\n    static $desc = /* @trans */ \"Ticket Link with Preview\";\n\n    function filter($text, $row) {\n        $link = $this->getLink($row);\n        return sprintf('<a style=\"display: inline\" class=\"preview\" data-preview=\"#tickets/%d/preview\" href=\"%s\">%s</a>',\n            $row['ticket_id'], $link, $text);\n    }\n}\nQueueColumnFilter::register('TicketLinkWithPreviewFilter', __('Link'));\n\nclass DateTimeFilter\nextends QueueColumnFilter {\n    static $id = 'date:full';\n    static $desc = /* @trans */ \"Date and Time\";\n\n    function filter($text, $row) {\n        return $text ?\n            $text->changeTo(Format::datetime($text->value)) : '';\n    }\n}\n\nclass HumanizedDateFilter\nextends QueueColumnFilter {\n    static $id = 'date:human';\n    static $desc = /* @trans */ \"Relative Date and Time\";\n\n    function filter($text, $row) {\n        return sprintf(\n            '<time class=\"relative\" datetime=\"%s\" title=\"%s\">%s</time>',\n            date(DateTime::W3C, Misc::db2gmtime($text->value)),\n            Format::daydatetime($text->value),\n            Format::relativeTime(Misc::db2gmtime($text->value))\n        );\n    }\n}\nQueueColumnFilter::register('DateTimeFilter', __('Date Format'));\nQueueColumnFilter::register('HumanizedDateFilter', __('Date Format'));\n\nclass QueueColDataConfigForm\nextends AbstractForm {\n    function buildFields() {\n        return array(\n            'primary' => new DataSourceField(array(\n                'label' => __('Primary Data Source'),\n                'required' => true,\n                'configuration' => array(\n                    'root' => 'Ticket',\n                ),\n                'layout' => new GridFluidCell(6),\n            )),\n            'secondary' => new DataSourceField(array(\n                'label' => __('Secondary Data Source'),\n                'configuration' => array(\n                    'root' => 'Ticket',\n                ),\n                'layout' => new GridFluidCell(6),\n            )),\n            'name' => new TextboxField(array(\n                'label' => __('Name'),\n                'required' => true,\n                'layout' => new GridFluidCell(4),\n            )),\n            'filter' => new ChoiceField(array(\n                'label' => __('Filter'),\n                'required' => false,\n                'choices' => QueueColumnFilter::getFilters(),\n                'layout' => new GridFluidCell(4),\n            )),\n            'truncate' => new ChoiceField(array(\n                'label' => __('Text Overflow'),\n                'choices' => array(\n                    'wrap' => __(\"Wrap Lines\"),\n                    'ellipsis' => __(\"Add Ellipsis\"),\n                    'clip' => __(\"Clip Text\"),\n                    'lclip' => __(\"Clip Beginning Text\"),\n                ),\n                'default' => 'wrap',\n                'layout' => new GridFluidCell(4),\n            )),\n        );\n    }\n}\n\nclass QueueSortDataConfigForm\nextends AbstractForm {\n    function getInstructions() {\n        return __('Add, and remove the fields in this list using the options below. Sorting can be performed on any field, whether displayed in the queue or not.');\n    }\n\n    function buildFields() {\n        return array(\n            'name' => new TextboxField(array(\n                'required' => true,\n                'layout' => new GridFluidCell(12),\n                'translatable' => isset($this->options['id'])\n                    ? _H('queuesort.name.'.$this->options['id']) : false,\n                'configuration' => array(\n                    'placeholder' => __('Sort Criteria Title'),\n                ),\n            )),\n        );\n    }\n}\n\nclass QueueSortAdvancedConfigForm\nextends AbstractForm {\n    function getInstructions() {\n        return __('If unsure, leave these options blank and unset');\n    }\n\n    function buildFields() {\n        return array(\n            'index' => new TextboxField(array(\n                'label' => __('Database Index'),\n                'hint' => __('Use this index when sorting on this column'),\n                'required' => false,\n                'layout' => new GridFluidCell(12),\n                'configuration' => array(\n                    'placeholder' => __('Automatic'),\n                ),\n            )),\n        );\n    }\n}\n", "<?php\n/*********************************************************************\n    queues.php\n\n    Handles management of custom queues\n\n    Jared Hancock <jared@osticket.com>\n    Peter Rotich <peter@osticket.com>\n    Copyright (c)  2006-2015 osTicket\n    http://www.osticket.com\n\n    Released under the GNU General Public License WITHOUT ANY WARRANTY.\n    See LICENSE.TXT for details.\n\n    vim: expandtab sw=4 ts=4 sts=4:\n**********************************************************************/\n\nrequire('admin.inc.php');\n\n$nav->setTabActive('settings', 'settings.php?t='.urlencode($_GET['t']));\n$errors = array();\n\nif ($_REQUEST['id'] && is_numeric($_REQUEST['id'])) {\n    $queue = CustomQueue::lookup($_REQUEST['id']);\n}\n\nif ($_POST) {\n    switch (strtolower($_POST['do'])) {\n    case 'update':\n        if (!$queue) {\n            $errors['err'] = '';\n            break;\n        }\n        if ($queue->update($_POST, $errors) && $queue->save()) {\n            $msg = sprintf(__('Successfully updated %s'), Format::htmlchars($_POST['name']));\n        }\n        elseif (!$errors['err']) {\n            $errors['err']=sprintf(__('Unable to update %s. Correct error(s) below and try again.'),\n                __('this queue'));\n        }\n        break;\n\n    case 'create':\n        $queue = CustomQueue::create(array(\n            'staff_id' => 0,\n            'title' => $_POST['queue-name'],\n            'root' => 'T'\n        ));\n\n        if ($queue->update($_POST, $errors) && $queue->save(true)) {\n            $msg = sprintf(__('Successfully added %s'),\n                    Format::htmlchars($queue->getName()));\n        }\n        elseif (!$errors['err']) {\n            $errors['err']=sprintf(__('Unable to add %s. Correct error(s) below and try again.'),\n                __('this queue'));\n        }\n        break;\n\n    case 'mass_process':\n        $updated = 0;\n        foreach (CustomQueue::objects()\n            ->filter(['id__in' => $_POST['ids']]) as $queue\n        ) {\n            switch ($_POST['a']) {\n            case 'enable':\n                $queue->enable();\n                if ($queue->save()) $updated++;\n                break;\n            case 'disable':\n                $queue->disable();\n                if ($queue->save()) $updated++;\n                break;\n            case 'delete':\n                if ($queue->getId() == $cfg->getDefaultTicketQueueId())\n                    $err = __('This queue is the default queue. Unable to delete. ');\n                elseif ($queue->delete()) $updated++;\n            }\n        }\n        if (!$updated) {\n            Messages::error($err ?: __(\n                'Unable to manage any of the selected queues'));\n        }\n        elseif ($_POST['count'] && $updated != $_POST['count']) {\n            Messages::warning(__(\n                'Not all selected items were updated'));\n        }\n        elseif ($updated) {\n            Messages::success(__(\n                'Successfully managed selected queues'));\n        }\n\n        // TODO: Consider redirecting based on the queue root\n        Http::redirect('settings.php?t=tickets#queues');\n    }\n}\nelseif (isset($_GET['a'])\n    && isset($queue) && $queue instanceof CustomQueue\n) {\n    switch (strtolower($_GET['a'])) {\n    case 'clone':\n        $queue = $queue->copy();\n        // Require a new name for the queue\n        unset($queue->title);\n        break;\n    case 'sub':\n        $q = new CustomQueue([\n            'parent' => $queue,\n            'flags' => CustomQueue::FLAG_QUEUE\n                     | CustomQueue::FLAG_INHERIT_EVERYTHING,\n        ]);\n        $queue = $q;\n        break;\n    }\n}\n\nrequire_once(STAFFINC_DIR.'header.inc.php');\ninclude_once(STAFFINC_DIR.\"queue.inc.php\");\ninclude_once(STAFFINC_DIR.'footer.inc.php');\n"], "fixing_code": ["<?php\n/*********************************************************************\n    class.queue.php\n\n    Custom (ticket) queues for osTicket\n\n    Jared Hancock <jared@osticket.com>\n    Peter Rotich <peter@osticket.com>\n    Copyright (c)  2006-2015 osTicket\n    http://www.osticket.com\n\n    Released under the GNU General Public License WITHOUT ANY WARRANTY.\n    See LICENSE.TXT for details.\n\n    vim: expandtab sw=4 ts=4 sts=4:\n**********************************************************************/\n\nclass CustomQueue extends VerySimpleModel {\n    static $meta = array(\n        'table' => QUEUE_TABLE,\n        'pk' => array('id'),\n        'ordering' => array('sort'),\n        'select_related' => array('parent', 'default_sort'),\n        'joins' => array(\n            'children' => array(\n                'reverse' => 'CustomQueue.parent',\n                'constrain' => ['children__id__gt' => 0],\n            ),\n            'columns' => array(\n                'reverse' => 'QueueColumnGlue.queue',\n                'constrain' => array('staff_id' =>'QueueColumnGlue.staff_id'),\n                'broker' => 'QueueColumnListBroker',\n            ),\n            'sorts' => array(\n                'reverse' => 'QueueSortGlue.queue',\n                'broker' => 'QueueSortListBroker',\n            ),\n            'default_sort' => array(\n                'constraint' => array('sort_id' => 'QueueSort.id'),\n                'null' => true,\n            ),\n            'exports' => array(\n                'reverse' => 'QueueExport.queue',\n            ),\n            'parent' => array(\n                'constraint' => array(\n                    'parent_id' => 'CustomQueue.id',\n                ),\n                'null' => true,\n            ),\n            'staff' => array(\n                'constraint' => array(\n                    'staff_id' => 'Staff.staff_id',\n                )\n            ),\n        )\n    );\n\n    const FLAG_PUBLIC =           0x0001; // Shows up in e'eryone's saved searches\n    const FLAG_QUEUE =            0x0002; // Shows up in queue navigation\n    const FLAG_DISABLED =         0x0004; // NOT enabled\n    const FLAG_INHERIT_CRITERIA = 0x0008; // Include criteria from parent\n    const FLAG_INHERIT_COLUMNS =  0x0010; // Inherit column layout from parent\n    const FLAG_INHERIT_SORTING =  0x0020; // Inherit advanced sorting from parent\n    const FLAG_INHERIT_DEF_SORT = 0x0040; // Inherit default selected sort\n    const FLAG_INHERIT_EXPORT  =  0x0080; // Inherit export fields from parent\n\n\n    const FLAG_INHERIT_EVERYTHING = 0x158; // Maskf or all INHERIT flags\n\n    var $criteria;\n    var $_conditions;\n\n    static function queues() {\n        return parent::objects()->filter(array(\n            'flags__hasbit' => static::FLAG_QUEUE\n        ));\n    }\n\n    function __onload() {\n        // Ensure valid state\n        if ($this->hasFlag(self::FLAG_INHERIT_COLUMNS) && !$this->parent_id)\n            $this->clearFlag(self::FLAG_INHERIT_COLUMNS);\n\n       if ($this->hasFlag(self::FLAG_INHERIT_EXPORT) && !$this->parent_id)\n            $this->clearFlag(self::FLAG_INHERIT_EXPORT);\n    }\n\n    function getId() {\n        return $this->id;\n    }\n\n    function getName() {\n        return $this->title;\n    }\n\n    function getHref() {\n        // TODO: Get base page from getRoot();\n        $root = $this->getRoot();\n        return 'tickets.php?queue='.$this->getId();\n    }\n\n    function getRoot() {\n        switch ($this->root) {\n        case 'T':\n        default:\n            return 'Ticket';\n        }\n    }\n\n    function getPath() {\n        return $this->path ?: $this->buildPath();\n    }\n\n    function criteriaRequired() {\n        return true;\n    }\n\n    function getCriteria($include_parent=false) {\n        if (!isset($this->criteria)) {\n            $this->criteria = is_string($this->config)\n                ? JsonDataParser::decode($this->config)\n                : $this->config;\n            // XXX: Drop this block in v1.12\n            // Auto-upgrade v1.10 saved-search criteria to new format\n            // But support new style with `conditions` support\n            $old = @$this->config[0] === '{';\n            if ($old && is_array($this->criteria)\n                && !isset($this->criteria['conditions'])\n            ) {\n                // TODO: Upgrade old ORM path names\n                // Parse criteria out of JSON if any.\n                $this->criteria = self::isolateCriteria($this->criteria,\n                        $this->getRoot());\n            }\n        }\n        $criteria = $this->criteria ?: array();\n        // Support new style with `conditions` support\n        if (isset($criteria['criteria']))\n            $criteria = $criteria['criteria'];\n        if ($include_parent && $this->parent_id && $this->parent) {\n            $criteria = array_merge($this->parent->getCriteria(true),\n                $criteria);\n        }\n        return $criteria;\n    }\n\n    function describeCriteria($criteria=false){\n        $all = $this->getSupportedMatches($this->getRoot());\n        $items = array();\n        $criteria = $criteria ?: $this->getCriteria(true);\n        foreach ($criteria ?: array() as $C) {\n            list($path, $method, $value) = $C;\n            if ($path === ':keywords') {\n                $items[] = Format::htmlchars(\"\\\"{$value}\\\"\");\n                continue;\n            }\n            if (!isset($all[$path]))\n                continue;\n            list($label, $field) = $all[$path];\n            $items[] = $field->describeSearch($method, $value, $label);\n        }\n        return implode(\"\\nAND \", $items);\n    }\n\n    /**\n     * Fetch an AdvancedSearchForm instance for use in displaying or\n     * configuring this search in the user interface.\n     *\n     * Parameters:\n     * $search - <array> Request parameters ($_POST) used to update the\n     *      search beyond the current configuration of the search criteria\n     * $searchables - search fields - default to current if not provided\n     */\n    function getForm($source=null, $searchable=null) {\n        $fields = array();\n        if (!isset($searchable)) {\n            $fields = array(\n                ':keywords' => new TextboxField(array(\n                    'id' => 3001,\n                    'configuration' => array(\n                        'size' => 40,\n                        'length' => 400,\n                        'autofocus' => true,\n                        'classes' => 'full-width headline',\n                        'placeholder' => __('Keywords \u2014 Optional'),\n                    ),\n                    'validators' => function($self, $v) {\n                        if (mb_str_wc($v) > 3)\n                            $self->addError(__('Search term cannot have more than 3 keywords'));\n                    },\n                )),\n            );\n\n            $searchable = $this->getCurrentSearchFields($source);\n        }\n\n        foreach ($searchable ?: array() as $path => $field)\n            $fields = array_merge($fields, static::getSearchField($field, $path));\n\n        $form = new AdvancedSearchForm($fields, $source);\n\n        // Field selection validator\n        if ($this->criteriaRequired()) {\n            $form->addValidator(function($form) {\n                    if (!$form->getNumFieldsSelected())\n                        $form->addError(__('No fields selected for searching'));\n                });\n        }\n\n        // Load state from current configuraiton\n        if (!$source) {\n            foreach ($this->getCriteria() as $I) {\n                list($path, $method, $value) = $I;\n                if ($path == ':keywords' && $method === null) {\n                    if ($F = $form->getField($path))\n                        $F->value = $value;\n                    continue;\n                }\n\n                if (!($F = $form->getField(\"{$path}+search\")))\n                    continue;\n                $F->value = true;\n\n                if (!($F = $form->getField(\"{$path}+method\")))\n                    continue;\n                $F->value = $method;\n\n                if ($value && ($F = $form->getField(\"{$path}+{$method}\")))\n                    $F->value = $value;\n            }\n        }\n        return $form;\n    }\n\n    /**\n     * Fetch a bucket of fields for a custom search. The fields should be\n     * added to a form before display. One searchable field may encompass 10\n     * or more actual fields because fields are expanded to support multiple\n     * search methods along with the fields for each search method. This\n     * method returns all the FormField instances for all the searchable\n     * model fields currently in use.\n     *\n     * Parameters:\n     * $source - <array> data from a request. $source['fields'] is expected\n     *      to contain a list extra fields by ORM path, of newly added\n     *      fields not yet saved in this object's getCriteria().\n     */\n    function getCurrentSearchFields($source=array(), $criteria=array()) {\n        static $basic = array(\n            'Ticket' => array(\n                'status__id',\n                'status__state',\n                'dept_id',\n                'assignee',\n                'topic_id',\n                'created',\n                'est_duedate',\n                'duedate',\n            )\n        );\n\n        $all = $this->getSupportedMatches();\n        $core = array();\n\n        // Include basic fields for new searches\n        if (!isset($this->id))\n            foreach ($basic[$this->getRoot()] as $path)\n                if (isset($all[$path]))\n                    $core[$path] = $all[$path];\n\n        // Add others from current configuration\n        foreach ($criteria ?: $this->getCriteria() as $C) {\n            list($path) = $C;\n            if (isset($all[$path]))\n                $core[$path] = $all[$path];\n        }\n\n        if (isset($source['fields']))\n            foreach ($source['fields'] as $path)\n                if (isset($all[$path]))\n                    $core[$path] = $all[$path];\n\n        return $core;\n    }\n\n    /**\n    * Fetch all supported ORM fields filterable by this search object.\n    */\n    function getSupportedFilters() {\n        return static::getFilterableFields($this->getRoot());\n    }\n\n\n    /**\n     * Get get supplemental matches for public queues.\n     *\n     */\n\n    function getSupplementalMatches() {\n        return array();\n    }\n\n    function getSupplementalCriteria() {\n        return array();\n    }\n\n    /**\n     * Fetch all supported ORM fields searchable by this search object. The\n     * returned list represents searchable fields, keyed by the ORM path.\n     * Use ::getCurrentSearchFields() or ::getSearchField() to retrieve for\n     * use in the user interface.\n     */\n    function getSupportedMatches() {\n        return static::getSearchableFields($this->getRoot());\n    }\n\n    /**\n     * Trace ORM fields from a base object and retrieve a complete list of\n     * fields which can be used in an ORM query based on the base object.\n     * The base object must implement Searchable interface and extend from\n     * VerySimpleModel. Then all joins from the object are also inspected,\n     * and any which implement the Searchable interface are traversed and\n     * automatically added to the list. The resulting list is cached based\n     * on the $base class, so multiple calls for the same $base return\n     * quickly.\n     *\n     * Parameters:\n     * $base - Class, name of a class implementing Searchable\n     * $recurse - int, number of levels to recurse, default is 2\n     * $cache - bool, cache results for future class for the same base\n     * $customData - bool, include all custom data fields for all general\n     *      forms\n     */\n    static function getSearchableFields($base, $recurse=2,\n        $customData=true, $exclude=array()\n    ) {\n        static $cache = array(), $otherFields;\n\n        // Early exit if already cached\n        $fields = &$cache[$base];\n        if ($fields)\n            return $fields;\n\n        if (!in_array('Searchable', class_implements($base)))\n            return array();\n\n        $fields = $fields ?: array();\n        foreach ($base::getSearchableFields() as $path=>$F) {\n            if (is_array($F)) {\n                list($label, $field) = $F;\n            }\n            else {\n                $label = $F->getLocal('label');\n                $field = $F;\n            }\n            $fields[$path] = array($label, $field);\n        }\n\n        if ($customData && $base::supportsCustomData()) {\n            if (!isset($otherFields)) {\n                $otherFields = array();\n                $dfs = DynamicFormField::objects()\n                    ->filter(array('form__type' => 'G'))\n                    ->select_related('form');\n                foreach ($dfs as $field) {\n                    $otherFields[$field->getId()] = array($field->form,\n                        $field->getImpl());\n                }\n            }\n            foreach ($otherFields as $id=>$F) {\n                list($form, $field) = $F;\n                $label = sprintf(\"%s / %s\",\n                    $form->getTitle(), $field->getLocal('label'));\n                $fields[\"entries__answers!{$id}__value\"] = array(\n                    $label, $field);\n            }\n        }\n\n        if ($recurse) {\n            $exclude[$base] = 1;\n            foreach ($base::getMeta('joins') as $path=>$j) {\n                $fc = $j['fkey'][0];\n                if (isset($exclude[$fc]) || $j['list'])\n                    continue;\n                foreach (static::getSearchableFields($fc, $recurse-1,\n                    true, $exclude)\n                as $path2=>$F) {\n                    list($label, $field) = $F;\n                    $fields[\"{$path}__{$path2}\"] = array(\n                        sprintf(\"%s / %s\", $fc, $label),\n                        $field);\n                }\n            }\n        }\n\n        // Sort the field listing by the (localized) label name\n        if (function_exists('collator_create')) {\n            $coll = Collator::create(Internationalization::getCurrentLanguage());\n            $keys = array_map(function($a) use ($coll) {\n                return $coll->getSortKey($a[0]); #nolint\n            }, $fields);\n        }\n        else {\n            // Fall back to 8-bit string sorting\n            $keys = array_map(function($a) { return $a[0]; }, $fields);\n        }\n        array_multisort($keys, $fields);\n\n        return $fields;\n    }\n\n  /**\n     * Fetch all searchable fileds, for the base object  which support quick filters.\n     */\n    function getFilterableFields($object) {\n        $filters = array();\n        foreach (static::getSearchableFields($object) as $p => $f) {\n            list($label, $field) = $f;\n            if ($field && $field->supportsQuickFilter())\n                $filters[$p] = $f;\n        }\n\n        return $filters;\n    }\n\n    /**\n     * Fetch the FormField instances used when for configuring a searchable\n     * field in the user interface. This is the glue between a field\n     * representing a searchable model field and the configuration of that\n     * search in the user interface.\n     *\n     * Parameters:\n     * $F - <array<string, FormField>> the label and the FormField instance\n     *      representing the configurable search\n     * $name - <string> ORM path for the search\n     */\n    static function getSearchField($F, $name) {\n        list($label, $field) = $F;\n\n        $pieces = array();\n        $pieces[\"{$name}+search\"] = new BooleanField(array(\n            'id' => sprintf('%u', crc32($name)) >> 1,\n            'configuration' => array(\n                'desc' => $label ?: $field->getLocal('label'),\n                'classes' => 'inline',\n            ),\n        ));\n        $methods = $field->getSearchMethods();\n\n        //remove future options for datetime fields that can't be in the future\n        if (in_array($field->getLabel(), DateTimeField::getPastPresentLabels()))\n          unset($methods['ndays'], $methods['future'], $methods['distfut']);\n\n        $pieces[\"{$name}+method\"] = new ChoiceField(array(\n            'choices' => $methods,\n            'default' => key($methods),\n            'visibility' => new VisibilityConstraint(new Q(array(\n                \"{$name}+search__eq\" => true,\n            )), VisibilityConstraint::HIDDEN),\n        ));\n        $offs = 0;\n        foreach ($field->getSearchMethodWidgets() as $m=>$w) {\n            if (!$w)\n                continue;\n            list($class, $args) = $w;\n            $args['required'] = true;\n            $args['__searchval__'] = true;\n            $args['visibility'] = new VisibilityConstraint(new Q(array(\n                    \"{$name}+method__eq\" => $m,\n                )), VisibilityConstraint::HIDDEN);\n            $pieces[\"{$name}+{$m}\"] = new $class($args);\n        }\n        return $pieces;\n    }\n\n    function getField($path) {\n        $searchable = $this->getSupportedMatches();\n        return $searchable[$path];\n    }\n\n    // Remove this and adjust advanced-search-criteria template to use the\n    // getCriteria() list and getField()\n    function getSearchFields($form=false) {\n        $form = $form ?: $this->getForm();\n        $searchable = $this->getCurrentSearchFields();\n        $info = array();\n        foreach ($form->getFields() as $f) {\n            if (substr($f->get('name'), -7) == '+search') {\n                $name = substr($f->get('name'), 0, -7);\n                $value = null;\n                // Determine the search method and fetch the original field\n                if (($M = $form->getField(\"{$name}+method\"))\n                    && ($method = $M->getClean())\n                    && (list(,$field) = $searchable[$name])\n                ) {\n                    // Request the field to generate a search Q for the\n                    // search method and given value\n                    if ($value = $form->getField(\"{$name}+{$method}\"))\n                        $value = $value->getClean();\n                }\n                $info[$name] = array(\n                    'field' => $field,\n                    'method' => $method,\n                    'value' => $value,\n                    'active' =>  $f->getClean(),\n                );\n            }\n        }\n        return $info;\n    }\n\n    /**\n     * Take the criteria from the SavedSearch fields setup and isolate the\n     * field name being search, the method used for searhing, and the method-\n     * specific data entered in the UI.\n     */\n    static function isolateCriteria($criteria, $base='Ticket') {\n\n        if (!is_array($criteria))\n            return null;\n\n        $items = array();\n        $searchable = static::getSearchableFields($base);\n        foreach ($criteria as $k=>$v) {\n            if (substr($k, -7) === '+method') {\n                list($name,) = explode('+', $k, 2);\n                if (!isset($searchable[$name]))\n                    continue;\n\n                // Require checkbox to be checked too\n                if (!$criteria[\"{$name}+search\"])\n                    continue;\n\n                // Lookup the field to search this condition\n                list($label, $field) = $searchable[$name];\n                // Get the search method\n                $method = is_array($v) ? key($v) : $v;\n                // Not all search methods require a value\n                $value = $criteria[\"{$name}+{$method}\"];\n\n                $items[] = array($name, $method, $value);\n            }\n        }\n        if (isset($criteria[':keywords'])\n            && ($kw = $criteria[':keywords'])\n        ) {\n            $items[] = array(':keywords', null, $kw);\n        }\n        return $items;\n    }\n\n    function getConditions() {\n        if (!isset($this->_conditions)) {\n            $this->getCriteria();\n            $conds = array();\n            if (is_array($this->criteria)\n                && isset($this->criteria['conditions'])\n            ) {\n                $conds = $this->criteria['conditions'];\n            }\n            foreach ($conds as $C)\n                if ($T = QueueColumnCondition::fromJson($C))\n                    $this->_conditions[] = $T;\n        }\n        return $this->_conditions;\n    }\n\n    function getExportableFields() {\n        $cdata = $fields = array();\n        foreach (TicketForm::getInstance()->getFields() as $f) {\n            // Ignore core fields\n            if (in_array($f->get('name'), array('priority')))\n                continue;\n            // Ignore non-data fields\n            elseif (!$f->hasData() || $f->isPresentationOnly())\n                continue;\n\n            $name = $f->get('name') ?: 'field_'.$f->get('id');\n            $key = 'cdata__'.$name;\n            $cdata[$key] = $f->getLocal('label');\n        }\n\n        // Standard export fields if none is provided.\n        $fields = array(\n                'number' =>         __('Ticket Number'),\n                'created' =>        __('Date Created'),\n                'cdata__subject' =>  __('Subject'),\n                'user__name' =>      __('From'),\n                'user__emails__address' => __('From Email'),\n                'cdata__priority' => __('Priority'),\n                'dept_id' => __('Department'),\n                'topic_id' => __('Help Topic'),\n                'source' =>         __('Source'),\n                'status__id' =>__('Current Status'),\n                'lastupdate' =>     __('Last Updated'),\n                'est_duedate' =>    __('SLA Due Date'),\n                'duedate' =>        __('Due Date'),\n                'closed' =>         __('Closed Date'),\n                'isoverdue' =>      __('Overdue'),\n                'isanswered' =>     __('Answered'),\n                'staff_id' => __('Agent Assigned'),\n                'team_id' =>  __('Team Assigned'),\n                'thread_count' =>   __('Thread Count'),\n                'reopen_count' =>   __('Reopen Count'),\n                'attachment_count' => __('Attachment Count'),\n                ) + $cdata;\n\n        return $fields;\n    }\n\n    function getExportFields($inherit=true) {\n\n        $fields = array();\n        if ($inherit\n            && $this->parent_id\n            && $this->hasFlag(self::FLAG_INHERIT_EXPORT)\n            && $this->parent\n        ) {\n            $fields = $this->parent->getExportFields();\n        }\n        elseif (count($this->exports)) {\n            foreach ($this->exports as $f)\n                $fields[$f->path] = $f->getHeading();\n        }\n        elseif ($this->isAQueue())\n            $fields = $this->getExportableFields();\n\n        if (!count($fields))\n            $fields = $this->getExportableFields();\n\n        return $fields;\n    }\n\n    function getExportColumns($fields=array()) {\n        $columns = array();\n        $fields = $fields ?: $this->getExportFields();\n        $i = 0;\n        foreach ($fields as $path => $label) {\n            $c = QueueColumn::placeholder(array(\n                        'id' => $i++,\n                        'heading' => $label,\n                        'primary' => $path,\n                        ));\n            $c->setQueue($this);\n            $columns[$path] = $c;\n        }\n        return $columns;\n    }\n\n    function getStandardColumns() {\n        return $this->getColumns();\n    }\n\n    function getColumns($use_template=false) {\n        if ($this->columns_id\n            && ($q = CustomQueue::lookup($this->columns_id))\n        ) {\n            // Use columns from cited queue\n            return $q->getColumns();\n        }\n        elseif ($this->parent_id\n            && $this->hasFlag(self::FLAG_INHERIT_COLUMNS)\n            && $this->parent\n        ) {\n            $columns = $this->parent->getColumns();\n            foreach ($columns as $c)\n                $c->setQueue($this);\n            return $columns;\n        }\n        elseif (count($this->columns)) {\n            return $this->columns;\n        }\n\n        // Use the columns of the \"Open\" queue as a default template\n        if ($use_template && ($template = CustomQueue::lookup(1)))\n            return $template->getColumns();\n\n        // Last resort \u2014 use standard columns\n        foreach (array(\n            QueueColumn::placeholder(array(\n                \"id\" => 1,\n                \"heading\" => \"Number\",\n                \"primary\" => 'number',\n                \"width\" => 85,\n                \"bits\" => QueueColumn::FLAG_SORTABLE,\n                \"filter\" => \"link:ticketP\",\n                \"annotations\" => '[{\"c\":\"TicketSourceDecoration\",\"p\":\"b\"}]',\n                \"conditions\" => '[{\"crit\":[\"isanswered\",\"nset\",null],\"prop\":{\"font-weight\":\"bold\"}}]',\n            )),\n            QueueColumn::placeholder(array(\n                \"id\" => 2,\n                \"heading\" => \"Created\",\n                \"primary\" => 'created',\n                \"filter\" => 'date:full',\n                \"truncate\" =>'wrap',\n                \"width\" => 120,\n                \"bits\" => QueueColumn::FLAG_SORTABLE,\n            )),\n            QueueColumn::placeholder(array(\n                \"id\" => 3,\n                \"heading\" => \"Subject\",\n                \"primary\" => 'cdata__subject',\n                \"width\" => 250,\n                \"bits\" => QueueColumn::FLAG_SORTABLE,\n                \"filter\" => \"link:ticket\",\n                \"annotations\" => '[{\"c\":\"TicketThreadCount\",\"p\":\">\"},{\"c\":\"ThreadAttachmentCount\",\"p\":\"a\"},{\"c\":\"OverdueFlagDecoration\",\"p\":\"<\"}]',\n                \"conditions\" => '[{\"crit\":[\"isanswered\",\"nset\",null],\"prop\":{\"font-weight\":\"bold\"}}]',\n                \"truncate\" => 'ellipsis',\n            )),\n            QueueColumn::placeholder(array(\n                \"id\" => 4,\n                \"heading\" => \"From\",\n                \"primary\" => 'user__name',\n                \"width\" => 150,\n                \"bits\" => QueueColumn::FLAG_SORTABLE,\n            )),\n            QueueColumn::placeholder(array(\n                \"id\" => 5,\n                \"heading\" => \"Priority\",\n                \"primary\" => 'cdata__priority',\n                \"width\" => 120,\n                \"bits\" => QueueColumn::FLAG_SORTABLE,\n            )),\n            QueueColumn::placeholder(array(\n                \"id\" => 8,\n                \"heading\" => \"Assignee\",\n                \"primary\" => 'assignee',\n                \"width\" => 100,\n                \"bits\" => QueueColumn::FLAG_SORTABLE,\n            )),\n        ) as $col)\n            $this->addColumn($col);\n\n        return $this->getColumns();\n    }\n\n    function addColumn(QueueColumn $col) {\n        $this->columns->add($col);\n        $col->queue = $this;\n    }\n\n    function getSortOptions() {\n        if ($this->inheritSorting() && $this->parent) {\n            return $this->parent->getSortOptions();\n        }\n        return $this->sorts;\n    }\n\n    function getDefaultSortId() {\n        if ($this->isDefaultSortInherited() && $this->parent\n            && ($sort_id = $this->parent->getDefaultSortId())\n        ) {\n            return $sort_id;\n        }\n        return $this->sort_id;\n    }\n\n    function getDefaultSort() {\n        if ($this->isDefaultSortInherited() && $this->parent\n            && ($sort = $this->parent->getDefaultSort())\n        ) {\n            return $sort;\n        }\n        return $this->default_sort;\n    }\n\n    function getStatus() {\n        return $this->hasFlag(self::FLAG_DISABLED)\n            ? __('Disabled') : __('Active');\n    }\n\n    function getChildren() {\n        return $this->children;\n    }\n\n    function getPublicChildren() {\n        return $this->children->findAll(array(\n            'flags__hasbit' => self::FLAG_QUEUE\n        ));\n    }\n\n    function getMyChildren() {\n        global $thisstaff;\n        if (!$thisstaff instanceof Staff)\n            return array();\n\n        return $this->children->findAll(array(\n            'staff_id' => $thisstaff->getId(),\n            Q::not(array(\n                'flags__hasbit' => self::FLAG_PUBLIC\n            ))\n        ));\n    }\n\n    function export($options=array()) {\n        global $thisstaff;\n\n        if (!$thisstaff\n                || !($query=$this->getBasicQuery())\n                || !($fields=$this->getExportFields()))\n            return false;\n\n        $filename = sprintf('%s Tickets-%s.csv',\n                $this->getName(),\n                strftime('%Y%m%d'));\n        // See if we have cached export preference\n        if (isset($_SESSION['Export:Q'.$this->getId()])) {\n            $opts = $_SESSION['Export:Q'.$this->getId()];\n            if (isset($opts['fields'])) {\n                $fields = array_intersect_key($fields,\n                        array_flip($opts['fields']));\n                $exportableFields = CustomQueue::getExportableFields();\n                foreach ($opts['fields'] as $key => $name) {\n                    if (is_null($fields[$name]) && isset($exportableFields)) {\n                        $fields[$name] = $exportableFields[$name];\n                    }\n                 }\n            }\n\n            if (isset($opts['filename'])\n                    && ($parts = pathinfo($opts['filename']))) {\n                $filename = $opts['filename'];\n                if (strcasecmp($parts['extension'], 'csv') !=0)\n                    $filename =\"$filename.csv\";\n            }\n\n            if (isset($opts['delimiter']) && !$options['delimiter'])\n                $options['delimiter'] = $opts['delimiter'];\n\n        }\n\n        // Apply columns\n        $columns = $this->getExportColumns($fields);\n        $headers = array(); // Reset fields based on validity of columns\n        foreach ($columns as $column) {\n            $query = $column->mangleQuery($query, $this->getRoot());\n            $headers[] = $column->getHeading();\n        }\n\n        // Apply visibility\n        if (!$this->ignoreVisibilityConstraints($thisstaff))\n            $query->filter($thisstaff->getTicketsVisibility());\n\n        // Render Util\n        $render = function ($row) use($columns) {\n            if (!$row) return false;\n\n            $record = array();\n            foreach ($columns as $path => $column) {\n                $record[] = (string) $column->from_query($row) ?:\n                    $row[$path] ?: '';\n            }\n            return $record;\n        };\n\n        $delimiter = $options['delimiter'] ?:\n            Internationalization::getCSVDelimiter();\n        $output = fopen('php://output', 'w');\n        Http::download($filename, \"text/csv\");\n        fputs($output, chr(0xEF) . chr(0xBB) . chr(0xBF));\n        fputcsv($output, $headers, $delimiter);\n        foreach ($query as $row)\n            fputcsv($output, $render($row), $delimiter);\n        fclose($output);\n        exit();\n    }\n\n    /**\n     * Add critiera to a query based on the constraints configured for this\n     * queue. The criteria of the parent queue is also automatically added\n     * if the queue is configured to inherit the criteria.\n     */\n    function getBasicQuery() {\n        if ($this->parent && $this->inheritCriteria()) {\n            $query = $this->parent->getBasicQuery();\n        }\n        else {\n            $root = $this->getRoot();\n            $query = $root::objects();\n        }\n        return $this->mangleQuerySet($query);\n    }\n\n    /**\n     * Retrieve a QuerySet instance based on the type of object (root) of\n     * this Q, which is automatically configured with the data and criteria\n     * of the queue and its columns.\n     *\n     * Returns:\n     * <QuerySet> instance\n     */\n    function getQuery($form=false, $quick_filter=null) {\n        // Start with basic criteria\n        $query = $this->getBasicQuery($form);\n\n        // Apply quick filter\n        if (isset($quick_filter)\n            && ($qf = $this->getQuickFilterField($quick_filter))\n        ) {\n            $filter = @self::getOrmPath($this->getQuickFilter(), $query);\n            $query = $qf->applyQuickFilter($query, $quick_filter,\n                $filter);\n        }\n\n        // Apply column, annotations and conditions additions\n        foreach ($this->getColumns() as $C) {\n            $C->setQueue($this);\n            $query = $C->mangleQuery($query, $this->getRoot());\n        }\n        return $query;\n    }\n\n    function getQuickFilter() {\n        if ($this->filter == '::' && $this->parent) {\n            return $this->parent->getQuickFilter();\n        }\n        return $this->filter;\n    }\n\n    function getQuickFilterField($value=null) {\n        if ($this->filter == '::') {\n            if ($this->parent) {\n                return $this->parent->getQuickFilterField($value);\n            }\n        }\n        elseif ($this->filter\n            && ($fields = self::getSearchableFields($this->getRoot()))\n            && (list(,$f) = @$fields[$this->filter])\n            && $f->supportsQuickFilter()\n        ) {\n            $f->value = $value;\n            return $f;\n        }\n    }\n\n    /**\n     * Get a description of a field in a search. Expects an entry from the\n     * array retrieved in ::getSearchFields()\n     */\n    function describeField($info, $name=false) {\n        $name = $name ?: $info['field']->get('label');\n        return $info['field']->describeSearch($info['method'], $info['value'], $name);\n    }\n\n    function mangleQuerySet(QuerySet $qs, $form=false) {\n        $qs = clone $qs;\n        $searchable = $this->getSupportedMatches();\n\n        // Figure out fields to search on\n        foreach ($this->getCriteria() as $I) {\n            list($name, $method, $value) = $I;\n\n            // Consider keyword searching\n            if ($name === ':keywords') {\n                global $ost;\n                $qs = $ost->searcher->find($value, $qs, false);\n            }\n            else {\n                // XXX: Move getOrmPath to be more of a utility\n                // Ensure the special join is created to support custom data joins\n                $name = @static::getOrmPath($name, $qs);\n\n                if (preg_match('/__answers!\\d+__/', $name)) {\n                    $qs->annotate(array($name => SqlAggregate::MAX($name)));\n                }\n\n                // Fetch a criteria Q for the query\n                if (list(,$field) = $searchable[$name]) {\n                    // Add annotation if the field supports it.\n                    if (is_subclass_of($field, 'AnnotatedField'))\n                       $qs = $field->annotate($qs, $name);\n\n                    if ($q = $field->getSearchQ($method, $value, $name))\n                        $qs = $qs->filter($q);\n                }\n            }\n        }\n\n        return $qs;\n    }\n\n    function applyDefaultSort($qs) {\n        // Apply default sort\n        if ($sorter = $this->getDefaultSort()) {\n            $qs = $sorter->applySort($qs, false, $this->getRoot());\n        }\n        return $qs;\n    }\n\n    function checkAccess(Staff $agent) {\n        return $this->isPublic() || $this->checkOwnership($agent);\n    }\n\n    function checkOwnership(Staff $agent) {\n\n        return ($agent->getId() == $this->staff_id &&\n                !$this->isAQueue());\n    }\n\n    function isOwner(Staff $agent) {\n        return $agent && $this->isPrivate() && $this->checkOwnership($agent);\n    }\n\n    function isSaved() {\n        return true;\n    }\n\n    function ignoreVisibilityConstraints(Staff $agent) {\n        // For searches (not queues), some staff can have a permission to\n        // see all records\n        return ($this->isASearch()\n                && $this->isOwner($agent)\n                && $agent->canSearchEverything());\n    }\n\n    function inheritCriteria() {\n        return $this->flags & self::FLAG_INHERIT_CRITERIA &&\n            $this->parent_id;\n    }\n\n    function inheritColumns() {\n        return $this->hasFlag(self::FLAG_INHERIT_COLUMNS);\n    }\n\n    function useStandardColumns() {\n        return ($this->hasFlag(self::FLAG_INHERIT_COLUMNS) ||\n                !count($this->columns));\n    }\n\n    function inheritExport() {\n        return ($this->hasFlag(self::FLAG_INHERIT_EXPORT) ||\n                !count($this->exports));\n    }\n\n    function inheritSorting() {\n        return $this->hasFlag(self::FLAG_INHERIT_SORTING);\n    }\n\n    function isDefaultSortInherited() {\n        return $this->hasFlag(self::FLAG_INHERIT_DEF_SORT);\n    }\n\n    function buildPath() {\n        if (!$this->id)\n            return;\n\n        $path = $this->parent ? $this->parent->buildPath() : '';\n        return rtrim($path, \"/\") . \"/{$this->id}/\";\n    }\n\n    function getFullName() {\n        $base = $this->getName();\n        if ($this->parent)\n            $base = sprintf(\"%s / %s\", $this->parent->getFullName(), $base);\n        return $base;\n    }\n\n    function isASubQueue() {\n        return $this->parent ? $this->parent->isASubQueue() :\n            $this->isAQueue();\n    }\n\n    function isAQueue() {\n        return $this->hasFlag(self::FLAG_QUEUE);\n    }\n\n    function isASearch() {\n        return !$this->isAQueue() || !$this->isSaved();\n    }\n\n    function isPrivate() {\n        return !$this->isAQueue() && $this->staff_id;\n    }\n\n    function isPublic() {\n        return $this->hasFlag(self::FLAG_PUBLIC);\n    }\n\n    protected function hasFlag($flag) {\n        return ($this->flags & $flag) !== 0;\n    }\n\n    protected function clearFlag($flag) {\n        return $this->flags &= ~$flag;\n    }\n\n    protected function setFlag($flag, $value=true) {\n        return $value\n            ? $this->flags |= $flag\n            : $this->clearFlag($flag);\n    }\n\n    function disable() {\n        $this->setFlag(self::FLAG_DISABLED);\n    }\n\n    function enable() {\n        $this->clearFlag(self::FLAG_DISABLED);\n    }\n\n    function getRoughCount() {\n        if (($count = $this->getRoughCountAPC()) !== false)\n            return $count;\n\n        $query = Ticket::objects();\n        $Q = $this->getBasicQuery();\n        $expr = SqlCase::N()->when(new SqlExpr(new Q($Q->constraints)),\n            new SqlField('ticket_id'));\n        $query = $query->aggregate(array(\n            \"ticket_count\" => SqlAggregate::COUNT($expr)\n        ));\n\n        $row = $query->values()->one();\n        return $row['ticket_count'];\n    }\n\n    function getRoughCountAPC() {\n        if (!function_exists('apcu_store'))\n            return false;\n\n        $key = \"rough.counts.\".SECRET_SALT;\n        $cached = false;\n        $counts = apcu_fetch($key, $cached);\n        if ($cached === true && isset($counts[\"q{$this->id}\"]))\n            return $counts[\"q{$this->id}\"];\n\n        // Fetch rough counts of all queues. That is, fetch a total of the\n        // counts based on the queue criteria alone. Do no consider agent\n        // access. This should be fast and \"rought\"\n        $queues = static::objects()\n            ->filter(['flags__hasbit' => CustomQueue::FLAG_PUBLIC])\n            ->exclude(['flags__hasbit' => CustomQueue::FLAG_DISABLED]);\n\n        $query = Ticket::objects();\n        $prefix = \"\";\n\n        foreach ($queues as $queue) {\n            $Q = $queue->getBasicQuery();\n            $expr = SqlCase::N()->when(new SqlExpr(new Q($Q->constraints)),\n                new SqlField('ticket_id'));\n            $query = $query->aggregate(array(\n                \"q{$queue->id}\" => SqlAggregate::COUNT($expr)\n            ));\n        }\n\n        $counts = $query->values()->one();\n\n        apcu_store($key, $counts, 900);\n        return @$counts[\"q{$this->id}\"];\n    }\n\n    function updateExports($fields, $save=true) {\n\n        if (!$fields)\n            return false;\n\n        $order = array_keys($fields);\n\n        $new = $fields;\n        foreach ($this->exports as $f) {\n            $heading = $f->getHeading();\n            $key = $f->getPath();\n            if (!isset($fields[$key])) {\n                $this->exports->remove($f);\n                continue;\n            }\n\n            $f->set('heading', $heading);\n            $f->set('sort', array_search($key, $order)+1);\n            unset($new[$key]);\n        }\n\n        $exportableFields = CustomQueue::getExportableFields();\n        foreach ($new as $k => $field) {\n            if (isset($exportableFields[$k]))\n                $heading = $exportableFields[$k];\n            elseif (is_array($field))\n                $heading = $field['heading'];\n            else\n                $heading = $field;\n\n            $f = QueueExport::create(array(\n                        'path' => $k,\n                        'heading' => $heading,\n                        'sort' => array_search($k, $order)+1));\n            $this->exports->add($f);\n        }\n\n        $this->exports->sort(function($f) { return $f->sort; });\n\n        if (!count($this->exports) && $this->parent)\n            $this->hasFlag(self::FLAG_INHERIT_EXPORT);\n\n        if ($save)\n            $this->exports->saveAll();\n\n        return true;\n    }\n\n    function update($vars, &$errors=array()) {\n\n        // Set basic search information\n        if (!$vars['queue-name'])\n            $errors['queue-name'] = __('A title is required');\n        elseif (($q=CustomQueue::lookup(array(\n                        'title' => Format::htmlchars($vars['queue-name']),\n                        'parent_id' => $vars['parent_id'] ?: 0,\n                        'staff_id'  => $this->staff_id)))\n                && $q->getId() != $this->id\n                )\n            $errors['queue-name'] = __('Saved queue with same name exists');\n\n        $this->title = Format::htmlchars($vars['queue-name']);\n        $this->parent_id = @$vars['parent_id'] ?: 0;\n        if ($this->parent_id && !$this->parent)\n            $errors['parent_id'] = __('Select a valid queue');\n\n        // Try to avoid infinite recursion determining ancestry\n        if ($this->parent_id && isset($this->id)) {\n            $P = $this;\n            while ($P = $P->parent)\n                if ($P->parent_id == $this->id)\n                    $errors['parent_id'] = __('Cannot be a descendent of itself');\n        }\n\n        // Configure quick filter options\n        $this->filter = $vars['filter'];\n        if ($vars['sort_id']) {\n            if ($vars['filter'] === '::') {\n                if (!$this->parent)\n                    $errors['filter'] = __('No parent selected');\n            }\n            elseif ($vars['filter'] && !array_key_exists($vars['filter'],\n                static::getSearchableFields($this->getRoot()))\n            ) {\n                $errors['filter'] = __('Select an item from the list');\n            }\n        }\n\n        // Set basic queue information\n        $this->path = $this->buildPath();\n        $this->setFlag(self::FLAG_INHERIT_CRITERIA, $this->parent_id);\n        $this->setFlag(self::FLAG_INHERIT_COLUMNS,\n            $this->parent_id > 0 && isset($vars['inherit-columns']));\n        $this->setFlag(self::FLAG_INHERIT_EXPORT,\n            $this->parent_id > 0 && isset($vars['inherit-exports']));\n        $this->setFlag(self::FLAG_INHERIT_SORTING,\n            $this->parent_id > 0 && isset($vars['inherit-sorting']));\n\n        // Saved Search - Use standard columns\n        if ($this instanceof SavedSearch && isset($vars['inherit-columns']))\n            $this->setFlag(self::FLAG_INHERIT_COLUMNS);\n        // Update queue columns (but without save)\n        if (!isset($vars['columns']) && $this->parent) {\n            // No columns -- imply column inheritance\n            $this->setFlag(self::FLAG_INHERIT_COLUMNS);\n        }\n\n\n        if ($this->getId()\n                && isset($vars['columns'])\n                && !$this->hasFlag(self::FLAG_INHERIT_COLUMNS)) {\n\n\n            if ($this->columns->updateColumns($vars['columns'], $errors, array(\n                                'queue_id' => $this->getId(),\n                                'staff_id' => $this->staff_id)))\n                $this->columns->reset();\n        }\n\n        // Update export fields for the queue\n        if (isset($vars['exports']) &&\n                 !$this->hasFlag(self::FLAG_INHERIT_EXPORT)) {\n            $this->updateExports($vars['exports'], false);\n        }\n\n        if (!count($this->exports) && $this->parent)\n            $this->hasFlag(self::FLAG_INHERIT_EXPORT);\n\n        // Update advanced sorting options for the queue\n        if (isset($vars['sorts']) && !$this->hasFlag(self::FLAG_INHERIT_SORTING)) {\n            $new = $order = $vars['sorts'];\n            foreach ($this->sorts as $sort) {\n                $key = $sort->sort_id;\n                $idx = array_search($key, $vars['sorts']);\n                if (false === $idx) {\n                    $this->sorts->remove($sort);\n                }\n                else {\n                    $sort->set('sort', $idx);\n                    unset($new[$idx]);\n                }\n            }\n            // Add new columns\n            foreach ($new as $id) {\n                if (!$sort = QueueSort::lookup($id))\n                    continue;\n                $glue = new QueueSortGlue(array(\n                    'sort_id' => $id,\n                    'queue' => $this,\n                    'sort' => array_search($id, $order),\n                ));\n                $this->sorts->add($sort, $glue);\n            }\n            // Re-sort the in-memory columns array\n            $this->sorts->sort(function($c) { return $c->sort; });\n        }\n        if (!count($this->sorts) && $this->parent) {\n            // No sorting -- imply sorting inheritance\n            $this->setFlag(self::FLAG_INHERIT_SORTING);\n        }\n\n        // Configure default sorting\n        $this->setFlag(self::FLAG_INHERIT_DEF_SORT,\n            $this->parent && $vars['sort_id'] === '::');\n        if ($vars['sort_id']) {\n            if ($vars['sort_id'] === '::') {\n                if (!$this->parent)\n                    $errors['sort_id'] = __('No parent selected');\n            }\n            elseif ($qs = QueueSort::lookup($vars['sort_id'])) {\n                $this->sort_id = $vars['sort_id'];\n            }\n            else {\n                $errors['sort_id'] = __('Select an item from the list');\n            }\n        }\n\n        list($this->_conditions, $conditions)\n            = QueueColumn::getConditionsFromPost($vars, $this->id, $this->getRoot());\n\n        // TODO: Move this to SavedSearch::update() and adjust\n        //       AjaxSearch::_saveSearch()\n        $form = $form ?: $this->getForm($vars);\n        if (!$vars) {\n            $errors['criteria'] = __('No criteria specified');\n        }\n        elseif (!$form->isValid()) {\n            $errors['criteria'] = __('Validation errors exist on criteria');\n        }\n        else {\n            $this->criteria = static::isolateCriteria($form->getClean(),\n                $this->getRoot());\n            $this->config = JsonDataEncoder::encode([\n                'criteria' => $this->criteria,\n                'conditions' => $conditions,\n            ]);\n            // Clear currently set criteria.and conditions.\n             $this->criteria = $this->_conditions = null;\n        }\n\n        return 0 === count($errors);\n    }\n\n    function psave() {\n        return parent::save();\n    }\n\n    function save($refetch=false) {\n\n        $nopath = !isset($this->path);\n        $path_changed = isset($this->dirty['parent_id']);\n\n        if ($this->dirty)\n            $this->updated = SqlFunction::NOW();\n\n        $clearCounts = ($this->dirty || $this->__new__);\n        if (!($rv = parent::save($refetch || $this->dirty)))\n            return $rv;\n\n        if ($nopath) {\n            $this->path = $this->buildPath();\n            $this->save();\n        }\n        if ($path_changed) {\n            $this->children->reset();\n            $move_children = function($q) use (&$move_children) {\n                foreach ($q->children as $qq) {\n                    $qq->path = $qq->buildPath();\n                    $qq->save();\n                    $move_children($qq);\n                }\n            };\n            $move_children($this);\n        }\n\n        // Refetch the queue counts\n        if ($clearCounts)\n            SavedQueue::clearCounts();\n\n        return $this->columns->saveAll()\n            && $this->exports->saveAll()\n            && $this->sorts->saveAll();\n    }\n\n    /**\n     * Fetch a tree-organized listing of the queues. Each queue is listed in\n     * the tree exactly once, and every visible queue is represented. The\n     * returned structure is an array where the items are two-item arrays\n     * where the first item is a CustomQueue object an the second is a list\n     * of the children using the same pattern (two-item arrays of a CustomQueue\n     * and its children). Visually:\n     *\n     * [ [ $queue, [ [ $child, [] ], [ $child, [] ] ], [ $queue, ... ] ]\n     *\n     * Parameters:\n     * $staff - <Staff> staff object which should be used to determine\n     *      visible queues.\n     * $pid - <int> parent_id of root queue. Default is zero (top-level)\n     */\n    static function getHierarchicalQueues(Staff $staff, $pid=0,\n            $primary=true) {\n        $query = static::objects()\n            ->annotate(array('_sort' =>  SqlCase::N()\n                        ->when(array('sort' => 0), 999)\n                        ->otherwise(new SqlField('sort'))))\n            ->filter(Q::any(array(\n                'flags__hasbit' => self::FLAG_PUBLIC,\n                'flags__hasbit' => static::FLAG_QUEUE,\n                'staff_id' => $staff->getId(),\n            )))\n            ->exclude(['flags__hasbit' => self::FLAG_DISABLED])\n            ->order_by('parent_id', '_sort', 'title');\n        $all = $query->asArray();\n        // Find all the queues with a given parent\n        $for_parent = function($pid) use ($primary, $all, &$for_parent) {\n            $results = [];\n            foreach (new \\ArrayIterator($all) as $q) {\n                if ($q->parent_id != $pid)\n                    continue;\n\n                if ($pid == 0 && (\n                            ($primary &&  !$q->isAQueue())\n                            || (!$primary && $q->isAQueue())))\n                    continue;\n\n                $results[] = [ $q, $for_parent($q->getId()) ];\n            }\n\n            return $results;\n        };\n\n        return $for_parent($pid);\n    }\n\n    static function getOrmPath($name, $query=null) {\n        // Special case for custom data `__answers!id__value`. Only add the\n        // join and constraint on the query the first pass, when the query\n        // being mangled is received.\n        $path = array();\n        if ($query && preg_match('/^(.+?)__(answers!(\\d+))/', $name, $path)) {\n            // Add a join to the model of the queryset where the custom data\n            // is forked from \u2014 duplicate the 'answers' join and add the\n            // constraint to the query based on the field_id\n            // $path[1] - part before the answers (user__org__entries)\n            // $path[2] - answers!xx join part\n            // $path[3] - the `xx` part of the answers!xx join component\n            $root = $query->model;\n            $meta = $root::getMeta()->getByPath($path[1]);\n            $joins = $meta['joins'];\n            if (!isset($joins[$path[2]])) {\n                $meta->addJoin($path[2], $joins['answers']);\n            }\n            // Ensure that the query join through answers!xx is only for the\n            // records which match field_id=xx\n            $query->constrain(array(\"{$path[1]}__{$path[2]}\" =>\n                array(\"{$path[1]}__{$path[2]}__field_id\" => (int) $path[3])\n            ));\n            // Leave $name unchanged\n        }\n        return $name;\n    }\n\n\n    static function create($vars=false) {\n\n        $queue = new static($vars);\n        $queue->created = SqlFunction::NOW();\n        if (!isset($vars['flags'])) {\n            $queue->setFlag(self::FLAG_PUBLIC);\n            $queue->setFlag(self::FLAG_QUEUE);\n        }\n\n        return $queue;\n    }\n\n    static function __create($vars) {\n        $q = static::create($vars);\n        $q->psave();\n        foreach ($vars['columns'] ?: array() as $info) {\n            $glue = new QueueColumnGlue($info);\n            $glue->queue_id = $q->getId();\n            $glue->save();\n        }\n        if (isset($vars['sorts'])) {\n            foreach ($vars['sorts'] as $info) {\n                $glue = new QueueSortGlue($info);\n                $glue->queue_id = $q->getId();\n                $glue->save();\n            }\n        }\n        return $q;\n    }\n}\n\nabstract class QueueColumnAnnotation {\n    static $icon = false;\n    static $desc = '';\n\n    var $config;\n\n    function __construct($config) {\n        $this->config = $config;\n    }\n\n    static function fromJson($config) {\n        $class = $config['c'];\n        if (class_exists($class))\n            return new $class($config);\n    }\n\n    static function getDescription() {\n        return __(static::$desc);\n    }\n    static function getIcon() {\n        return static::$icon;\n    }\n    static function getPositions() {\n        return array(\n            \"<\" => __('Start'),\n            \"b\" => __('Before'),\n            \"a\" => __('After'),\n            \">\" => __('End'),\n        );\n    }\n\n    function decorate($text, $dec) {\n        static $positions = array(\n            '<' => '<span class=\"pull-left\">%2$s</span>%1$s',\n            '>' => '<span class=\"pull-right\">%2$s</span>%1$s',\n            'a' => '%1$s%2$s',\n            'b' => '%2$s%1$s',\n        );\n\n        $pos = $this->getPosition();\n        if (!isset($positions[$pos]))\n            return $text;\n\n        return sprintf($positions[$pos], $text, $dec);\n    }\n\n    // Render the annotation with the database record $row. $text is the\n    // text of the cell before annotations were applied.\n    function render($row, $cell) {\n        if ($decoration = $this->getDecoration($row, $cell))\n            return $this->decorate($cell, $decoration);\n\n        return $cell;\n    }\n\n    // Add the annotation to a QuerySet\n    abstract function annotate($query, $name);\n\n    // Fetch some HTML to render the decoration on the page. This function\n    // can return boolean FALSE to indicate no decoration should be applied\n    abstract function getDecoration($row, $text);\n\n    function getPosition() {\n        return strtolower($this->config['p']) ?: 'a';\n    }\n\n    function getClassName() {\n        return @$this->config['c'] ?: get_class();\n    }\n\n    static function getAnnotations($root) {\n        // Ticket annotations\n        static $annotations;\n        if (!isset($annotations[$root])) {\n            foreach (get_declared_classes() as $class)\n                if (is_subclass_of($class, get_called_class()))\n                    $annotations[$root][] = $class;\n        }\n        return $annotations[$root];\n    }\n\n    /**\n     * Estimate the width of the rendered annotation in pixels\n     */\n    function getWidth($row) {\n        return $this->isVisible($row) ? 25 : 0;\n    }\n\n    function isVisible($row) {\n        return true;\n    }\n\n    static function addToQuery($query, $name=false) {\n        $name = $name ?: static::$qname;\n        $annotation = new Static(array());\n        return $annotation->annotate($query, $name);\n    }\n\n    static function from_query($row, $name=false) {\n        $name = $name ?: static::$qname;\n        return $row[$name];\n    }\n}\n\nclass TicketThreadCount\nextends QueueColumnAnnotation {\n    static $icon = 'comments-alt';\n    static $qname = '_thread_count';\n    static $desc = /* @trans */ 'Thread Count';\n\n    function annotate($query, $name=false) {\n        $name = $name ?: static::$qname;\n        return $query->annotate(array(\n            $name => TicketThread::objects()\n            ->filter(array('ticket__ticket_id' => new SqlField('ticket_id', 1)))\n            ->exclude(array('entries__flags__hasbit' => ThreadEntry::FLAG_HIDDEN))\n            ->aggregate(array('count' => SqlAggregate::COUNT('entries__id')))\n        ));\n    }\n\n    function getDecoration($row, $text) {\n        $threadcount = $row[static::$qname];\n        if ($threadcount > 1) {\n            return sprintf(\n                '<small class=\"faded-more\"><i class=\"icon-comments-alt\"></i> %s</small>',\n                $threadcount\n            );\n        }\n    }\n\n    function isVisible($row) {\n        return $row[static::$qname] > 1;\n    }\n}\n\nclass TicketReopenCount\nextends QueueColumnAnnotation {\n    static $icon = 'folder-open-alt';\n    static $qname = '_reopen_count';\n    static $desc = /* @trans */ 'Reopen Count';\n\n    function annotate($query, $name=false) {\n        $name = $name ?: static::$qname;\n        return $query->annotate(array(\n            $name => TicketThread::objects()\n            ->filter(array('ticket__ticket_id' => new SqlField('ticket_id', 1)))\n            ->filter(array('events__annulled' => 0, 'events__event_id' => Event::getIdByName('reopened')))\n            ->aggregate(array('count' => SqlAggregate::COUNT('events__id')))\n        ));\n    }\n\n    function getDecoration($row, $text) {\n        $reopencount = $row[static::$qname];\n        if ($reopencount) {\n            return sprintf(\n                '&nbsp;<small class=\"faded-more\"><i class=\"icon-%s\"></i> %s</small>',\n                static::$icon,\n                $reopencount > 1 ? $reopencount : ''\n            );\n        }\n    }\n\n    function isVisible($row) {\n        return $row[static::$qname];\n    }\n}\n\nclass ThreadAttachmentCount\nextends QueueColumnAnnotation {\n    static $icon = 'paperclip';\n    static $qname = '_att_count';\n    static $desc = /* @trans */ 'Attachment Count';\n\n    function annotate($query, $name=false) {\n        // TODO: Convert to Thread attachments\n        $name = $name ?: static::$qname;\n        return $query->annotate(array(\n            $name => TicketThread::objects()\n            ->filter(array('ticket__ticket_id' => new SqlField('ticket_id', 1)))\n            ->filter(array('entries__attachments__inline' => 0))\n            ->aggregate(array('count' => SqlAggregate::COUNT('entries__attachments__id')))\n        ));\n    }\n\n    function getDecoration($row, $text) {\n        $count = $row[static::$qname];\n        if ($count) {\n            return sprintf(\n                '<i class=\"small icon-paperclip icon-flip-horizontal\" data-toggle=\"tooltip\" title=\"%s\"></i>',\n                $count);\n        }\n    }\n\n    function isVisible($row) {\n        return $row[static::$qname] > 0;\n    }\n}\n\nclass ThreadCollaboratorCount\nextends QueueColumnAnnotation {\n    static $icon = 'group';\n    static $qname = '_collabs';\n    static $desc = /* @trans */ 'Collaborator Count';\n\n    function annotate($query, $name=false) {\n        $name = $name ?: static::$qname;\n        return $query->annotate(array(\n            $name => TicketThread::objects()\n            ->filter(array('ticket__ticket_id' => new SqlField('ticket_id', 1)))\n            ->aggregate(array('count' => SqlAggregate::COUNT('collaborators__id')))\n        ));\n    }\n\n    function getDecoration($row, $text) {\n        $count = $row[static::$qname];\n        if ($count) {\n            return sprintf(\n                '<span class=\"pull-right faded-more\" data-toggle=\"tooltip\" title=\"%d\"><i class=\"icon-group\"></i></span>',\n                $count);\n        }\n    }\n\n    function isVisible($row) {\n        return $row[static::$qname] > 0;\n    }\n}\n\nclass OverdueFlagDecoration\nextends QueueColumnAnnotation {\n    static $icon = 'exclamation';\n    static $desc = /* @trans */ 'Overdue Icon';\n\n    function annotate($query, $name=false) {\n        return $query->values('isoverdue');\n    }\n\n    function getDecoration($row, $text) {\n        if ($row['isoverdue'])\n            return '<span class=\"Icon overdueTicket\"></span>';\n    }\n\n    function isVisible($row) {\n        return $row['isoverdue'];\n    }\n}\n\nclass TicketSourceDecoration\nextends QueueColumnAnnotation {\n    static $icon = 'phone';\n    static $desc = /* @trans */ 'Ticket Source';\n\n    function annotate($query, $name=false) {\n        return $query->values('source');\n    }\n\n    function getDecoration($row, $text) {\n        return sprintf('<span class=\"Icon %sTicket\"></span>',\n            strtolower($row['source']));\n    }\n}\n\nclass LockDecoration\nextends QueueColumnAnnotation {\n    static $icon = \"lock\";\n    static $desc = /* @trans */ 'Locked';\n\n    function annotate($query, $name=false) {\n        global $thisstaff;\n\n        return $query\n            ->annotate(array(\n                '_locked' => new SqlExpr(new Q(array(\n                    'lock__expire__gt' => SqlFunction::NOW(),\n                    Q::not(array('lock__staff_id' => $thisstaff->getId())),\n                )))\n            ));\n    }\n\n    function getDecoration($row, $text) {\n        if ($row['_locked'])\n            return sprintf('<span class=\"Icon lockedTicket\"></span>');\n    }\n\n    function isVisible($row) {\n        return $row['_locked'];\n    }\n}\n\nclass AssigneeAvatarDecoration\nextends QueueColumnAnnotation {\n    static $icon = \"user\";\n    static $desc = /* @trans */ 'Assignee Avatar';\n\n    function annotate($query, $name=false) {\n        return $query->values('staff_id', 'team_id');\n    }\n\n    function getDecoration($row, $text) {\n        if ($row['staff_id'] && ($staff = Staff::lookup($row['staff_id'])))\n            return sprintf('<span class=\"avatar\">%s</span>',\n                $staff->getAvatar(16));\n        elseif ($row['team_id'] && ($team = Team::lookup($row['team_id']))) {\n            $avatars = [];\n            foreach ($team->getMembers() as $T)\n                $avatars[] = $T->getAvatar(16);\n            return sprintf('<span class=\"avatar group %s\">%s</span>',\n                count($avatars), implode('', $avatars));\n        }\n    }\n\n    function isVisible($row) {\n        return $row['staff_id'] + $row['team_id'] > 0;\n    }\n\n    function getWidth($row) {\n        if (!$this->isVisible($row))\n            return 0;\n\n        // If assigned to a team with no members, return 0 width\n        $width = 10;\n        if ($row['team_id'] && ($team = Team::lookup($row['team_id'])))\n            $width += (count($team->getMembers()) - 1) * 10;\n\n        return $width ? $width + 10 : $width;\n    }\n}\n\nclass UserAvatarDecoration\nextends QueueColumnAnnotation {\n    static $icon = \"user\";\n    static $desc = /* @trans */ 'User Avatar';\n\n    function annotate($query, $name=false) {\n        return $query->values('user_id');\n    }\n\n    function getDecoration($row, $text) {\n        if ($row['user_id'] && ($user = User::lookup($row['user_id'])))\n            return sprintf('<span class=\"avatar\">%s</span>',\n                $user->getAvatar(16));\n    }\n\n    function isVisible($row) {\n        return $row['user_id'] > 0;\n    }\n}\n\nclass DataSourceField\nextends ChoiceField {\n    function getChoices($verbose=false) {\n        $config = $this->getConfiguration();\n        $root = $config['root'];\n        $fields = array();\n        foreach (CustomQueue::getSearchableFields($root) as $path=>$f) {\n            list($label,) = $f;\n            $fields[$path] = $label;\n        }\n        return $fields;\n    }\n}\n\nclass QueueColumnCondition {\n    var $config;\n    var $queue;\n    var $properties = array();\n\n    static $uid = 1;\n\n    function __construct($config, $queue=null) {\n        $this->config = $config;\n        $this->queue = $queue;\n        if (is_array($config['prop']))\n            $this->properties = $config['prop'];\n    }\n\n    function getProperties() {\n        return $this->properties;\n    }\n\n    // Add the annotation to a QuerySet\n    function annotate($query) {\n        if (!($Q = $this->getSearchQ($query)))\n            return $query;\n\n        // Add an annotation to the query\n        return $query->annotate(array(\n            $this->getAnnotationName() => new SqlExpr(array($Q))\n        ));\n    }\n\n    function getField($name=null) {\n        // FIXME\n        #$root = $this->getColumn()->getRoot();\n        $root = 'Ticket';\n        $searchable = CustomQueue::getSearchableFields($root);\n\n        if (!isset($name))\n            list($name) = $this->config['crit'];\n\n        // Lookup the field to search this condition\n        if (isset($searchable[$name])) {\n            return $searchable[$name];\n        }\n    }\n\n    function getFieldName() {\n        list($name) = $this->config['crit'];\n        return $name;\n    }\n\n    function getCriteria() {\n        return $this->config['crit'];\n    }\n\n    function getSearchQ($query) {\n        list($name, $method, $value) = $this->config['crit'];\n\n        // XXX: Move getOrmPath to be more of a utility\n        // Ensure the special join is created to support custom data joins\n        $name = @CustomQueue::getOrmPath($name, $query);\n\n        $name2 = null;\n        if (preg_match('/__answers!\\d+__/', $name)) {\n            // Ensure that only one record is returned from the join through\n            // the entry and answers joins\n            $name2 = $this->getAnnotationName().'2';\n            $query->annotate(array($name2 => SqlAggregate::MAX($name)));\n        }\n\n        // Fetch a criteria Q for the query\n        if (list(,$field) = $this->getField($name))\n            return $field->getSearchQ($method, $value, $name2 ?: $name);\n    }\n\n    /**\n     * Take the criteria from the SavedSearch fields setup and isolate the\n     * field name being search, the method used for searhing, and the method-\n     * specific data entered in the UI.\n     */\n    static function isolateCriteria($criteria, $base='Ticket') {\n        $searchable = CustomQueue::getSearchableFields($base);\n        foreach ($criteria as $k=>$v) {\n            if (substr($k, -7) === '+method') {\n                list($name,) = explode('+', $k, 2);\n                if (!isset($searchable[$name]))\n                    continue;\n\n                // Lookup the field to search this condition\n                list($label, $field) = $searchable[$name];\n\n                // Get the search method and value\n                $method = $v;\n                // Not all search methods require a value\n                $value = $criteria[\"{$name}+{$method}\"];\n\n                return array($name, $method, $value);\n            }\n        }\n    }\n\n    function render($row, $text, &$styles=array()) {\n        if ($V = $row[$this->getAnnotationName()]) {\n            foreach ($this->getProperties() as $css=>$value) {\n                $field = QueueColumnConditionProperty::getField($css);\n                $field->value = $value;\n                $V = $field->getClean();\n                if (is_array($V))\n                    $V = current($V);\n                $styles[$css] = $V;\n            }\n        }\n        return $text;\n    }\n\n    function getAnnotationName() {\n        // This should be predictable based on the criteria so that the\n        // query can deduplicate the same annotations used in different\n        // conditions\n        if (!isset($this->annotation_name)) {\n            $this->annotation_name = $this->getShortHash();\n        }\n        return $this->annotation_name;\n    }\n\n    function __toString() {\n        list($name, $method, $value) = $this->config['crit'];\n        if (is_array($value))\n            $value = implode('+', $value);\n\n        return \"{$name} {$method} {$value}\";\n    }\n\n    function getHash($binary=false) {\n        return sha1($this->__toString(), $binary);\n    }\n\n    function getShortHash() {\n        return substr(base64_encode($this->getHash(true)), 0, 7);\n    }\n\n    static function getUid() {\n        return static::$uid++;\n    }\n\n    static function fromJson($config, $queue=null) {\n        if (is_string($config))\n            $config = JsonDataParser::decode($config);\n        if (!is_array($config))\n            throw new BadMethodCallException('$config must be string or array');\n\n        return new static($config, $queue);\n    }\n}\n\nclass QueueColumnConditionProperty\nextends ChoiceField {\n    static $properties = array(\n        'background-color' => 'ColorChoiceField',\n        'color' => 'ColorChoiceField',\n        'font-family' => array(\n            'monospace', 'serif', 'sans-serif', 'cursive', 'fantasy',\n        ),\n        'font-size' => array(\n            'small', 'medium', 'large', 'smaller', 'larger',\n        ),\n        'font-style' => array(\n            'normal', 'italic', 'oblique',\n        ),\n        'font-weight' => array(\n            'lighter', 'normal', 'bold', 'bolder',\n        ),\n        'text-decoration' => array(\n            'none', 'underline',\n        ),\n        'text-transform' => array(\n            'uppercase', 'lowercase', 'captalize',\n        ),\n    );\n\n    function __construct($property) {\n        $this->property = $property;\n    }\n\n    static function getProperties() {\n        return array_keys(static::$properties);\n    }\n\n    static function getField($prop) {\n        $choices = static::$properties[$prop];\n        if (!isset($choices))\n            return null;\n        if (is_array($choices))\n            return new ChoiceField(array(\n                'name' => $prop,\n                'choices' => array_combine($choices, $choices),\n            ));\n        elseif (class_exists($choices))\n            return new $choices(array('name' => $prop));\n    }\n\n    function getChoices($verbose=false) {\n        if (isset($this->property))\n            return static::$properties[$this->property];\n\n        $keys = array_keys(static::$properties);\n        return array_combine($keys, $keys);\n    }\n}\n\nclass LazyDisplayWrapper {\n    function __construct($field, $value) {\n        $this->field = $field;\n        $this->value = $value;\n        $this->safe = false;\n    }\n\n    /**\n     * Allow a filter to change the value of this to a \"safe\" value which\n     * will not be automatically encoded with htmlchars()\n     */\n    function changeTo($what, $safe=false) {\n        $this->field = null;\n        $this->value = $what;\n        $this->safe = $safe;\n    }\n\n    function __toString() {\n        return $this->display();\n    }\n\n    function display(&$styles=array()) {\n        if (isset($this->field))\n            return $this->field->display(\n                $this->field->to_php($this->value), $styles);\n        if ($this->safe)\n            return $this->value;\n        return Format::htmlchars($this->value);\n    }\n}\n\n/**\n * A column of a custom queue. Columns have many customizable features\n * including:\n *\n *   * Data Source (primary and secondary)\n *   * Heading\n *   * Link (to an object like the ticket)\n *   * Size and truncate settings\n *   * annotations (like counts and flags)\n *   * Conditions (which change the formatting like bold text)\n *\n * Columns are stored in a separate table from the queue itself, but other\n * breakout items for the annotations and conditions, for instance, are stored\n * as JSON text in the QueueColumn model.\n */\nclass QueueColumn\nextends VerySimpleModel {\n    static $meta = array(\n        'table' => COLUMN_TABLE,\n        'pk' => array('id'),\n        'ordering' => array('name'),\n    );\n\n    const FLAG_SORTABLE = 0x0001;\n\n    var $_annotations;\n    var $_conditions;\n    var $_queue;            // Apparent queue if being inherited\n    var $_fields;\n\n    function getId() {\n        return $this->id;\n    }\n\n    function getFilter() {\n         if ($this->filter\n                && ($F = QueueColumnFilter::getInstance($this->filter)))\n            return $F;\n     }\n\n    function getName() {\n        return $this->name;\n    }\n\n    // These getters fetch data from the annotated overlay from the\n    // queue_column table\n    function getQueue() {\n        if (!isset($this->_queue)) {\n            $queue = $this->queue;\n\n            if (!$queue && ($queue_id = $this->queue_id) && is_numeric($queue_id))\n                $queue = CustomQueue::lookup($queue_id);\n\n            $this->_queue = $queue;\n        }\n\n        return $this->_queue;\n    }\n    /**\n     * If a column is inherited into a child queue and there are conditions\n     * added to that queue, then the column will need to be linked at\n     * run-time to the child queue rather than the parent.\n     */\n    function setQueue(CustomQueue $queue) {\n        $this->_queue = $queue;\n    }\n\n    function getFields() {\n        if (!isset($this->_fields)) {\n            $root = ($q = $this->getQueue()) ? $q->getRoot() : 'Ticket';\n            $fields = CustomQueue::getSearchableFields($root);\n            $primary = CustomQueue::getOrmPath($this->primary);\n            $secondary = CustomQueue::getOrmPath($this->secondary);\n            if (($F = $fields[$primary]) && (list(,$field) = $F))\n                $this->_fields[$primary] = $field;\n            if (($F = $fields[$secondary]) && (list(,$field) = $F))\n                $this->_fields[$secondary] = $field;\n        }\n        return $this->_fields;\n    }\n\n    function getField($path=null) {\n        $fields = $this->getFields();\n        return @$fields[$path ?: $this->primary];\n    }\n\n    function getWidth() {\n        return $this->width ?: 100;\n    }\n\n    function getHeading() {\n        return $this->heading;\n    }\n\n    function getTranslateTag($subtag) {\n        return _H(sprintf('column.%s.%s.%s', $subtag, $this->queue_id, $this->id));\n    }\n    function getLocal($subtag) {\n        $tag = $this->getTranslateTag($subtag);\n        $T = CustomDataTranslation::translate($tag);\n        return $T != $tag ? $T : $this->get($subtag);\n    }\n    function getLocalHeading() {\n        return $this->getLocal('heading');\n    }\n\n    protected function setFlag($flag, $value=true, $field='flags') {\n        return $value\n            ? $this->{$field} |= $flag\n            : $this->clearFlag($flag, $field);\n    }\n\n    protected function clearFlag($flag, $field='flags') {\n        return $this->{$field} &= ~$flag;\n    }\n\n    function isSortable() {\n        return $this->bits & self::FLAG_SORTABLE;\n    }\n\n    function setSortable($sortable) {\n        $this->setFlag(self::FLAG_SORTABLE, $sortable, 'bits');\n    }\n\n    function render($row) {\n        // Basic data\n        $text = $this->renderBasicValue($row);\n\n        // Filter\n        if ($text && ($filter = $this->getFilter())) {\n            $text = $filter->filter($text, $row) ?: $text;\n        }\n\n        $styles = array();\n        if ($text instanceof LazyDisplayWrapper) {\n            $text = $text->display($styles);\n        }\n\n        // Truncate\n        $text = $this->applyTruncate($text, $row);\n\n        // annotations and conditions\n        foreach ($this->getAnnotations() as $D) {\n            $text = $D->render($row, $text);\n        }\n        foreach ($this->getConditions() as $C) {\n            $text = $C->render($row, $text, $styles);\n        }\n        $style = Format::array_implode(':', ';', $styles);\n        return array($text, $style);\n    }\n\n    function renderBasicValue($row) {\n        $fields = $this->getFields();\n        $primary = CustomQueue::getOrmPath($this->primary);\n        $secondary = CustomQueue::getOrmPath($this->secondary);\n\n        // Return a lazily ::display()ed value so that the value to be\n        // rendered by the field could be changed or display()ed when\n        // converted to a string.\n        if (($F = $fields[$primary])\n            && ($T = $F->from_query($row, $primary))\n        ) {\n            return new LazyDisplayWrapper($F, $T);\n        }\n        if (($F = $fields[$secondary])\n            && ($T = $F->from_query($row, $secondary))\n        ) {\n            return new LazyDisplayWrapper($F, $T);\n        }\n\n         return new LazyDisplayWrapper($F, '');\n    }\n\n    function from_query($row) {\n        if (!($f = $this->getField($this->primary)))\n            return '';\n\n        $val = $f->to_php($f->from_query($row, $this->primary));\n        if (!is_string($val))\n            $val = $f->display($val);\n\n        return $val;\n    }\n\n    function applyTruncate($text, $row) {\n        $offset = 0;\n        foreach ($this->getAnnotations() as $a)\n            $offset += $a->getWidth($row);\n\n        $width = $this->width - $offset;\n        $class = array();\n        switch ($this->truncate) {\n        case 'lclip':\n            $linfo = Internationalization::getCurrentLanguageInfo();\n            // Use `rtl` class to cut the beginning of LTR text. But, wrap\n            // the text with an appropriate direction so the ending\n            // punctuation is not rearranged.\n            $dir = $linfo['direction'] ?: 'ltr';\n            $text = sprintf('<span class=\"%s\">%s</span>', $dir, $text);\n            $class[] = $dir == 'rtl' ? 'ltr' : 'rtl';\n        case 'clip':\n            $class[] = 'bleed';\n        case 'ellipsis':\n            $class[] = 'truncate';\n            return sprintf('<span class=\"%s\" style=\"max-width:%dpx\">%s</span>',\n                implode(' ', $class), $width, $text);\n        default:\n        case 'wrap':\n            return $text;\n        }\n    }\n\n    function addToQuery($query, $field, $path) {\n        if (preg_match('/__answers!\\d+__/', $path)) {\n            // Ensure that only one record is returned from the join through\n            // the entry and answers joins\n            return $query->annotate(array(\n                $path => SqlAggregate::MAX($path)\n            ));\n        }\n        return $field->addToQuery($query, $path);\n    }\n\n    function mangleQuery($query, $root=null) {\n        // Basic data\n        $fields = $this->getFields();\n        if ($field = $fields[$this->primary]) {\n            $query = $this->addToQuery($query, $field,\n                CustomQueue::getOrmPath($this->primary, $query));\n        }\n        if ($field = $fields[$this->secondary]) {\n            $query = $this->addToQuery($query, $field,\n                CustomQueue::getOrmPath($this->secondary, $query));\n        }\n\n        if ($filter = $this->getFilter())\n            $query = $filter->mangleQuery($query, $this);\n\n        // annotations\n        foreach ($this->getAnnotations() as $D) {\n            $query = $D->annotate($query);\n        }\n\n        // Conditions\n        foreach ($this->getConditions() as $C) {\n            $query = $C->annotate($query);\n        }\n\n        return $query;\n    }\n\n    function applySort($query, $reverse=false) {\n\t    $root = ($q = $this->getQueue()) ? $q->getRoot() : 'Ticket';\n        $fields = CustomQueue::getSearchableFields($root);\n\n        $keys = array();\n        if ($primary = $fields[$this->primary]) {\n            list(,$field) = $primary;\n            $keys[] = array(CustomQueue::getOrmPath($this->primary, $query),\n                    $field);\n        }\n\n        if ($secondary = $fields[$this->secondary]) {\n            list(,$field) = $secondary;\n            $keys[] = array(CustomQueue::getOrmPath($this->secondary,\n                        $query), $field);\n        }\n\n        if (count($keys) > 1) {\n            $fields = array();\n            foreach ($keys as $key) {\n                list($path, $field) = $key;\n                foreach ($field->getSortKeys($path) as $field)\n                    $fields[]  = new SqlField($field);\n            }\n            // Force nulls to the buttom.\n            $fields[] = 'zzz';\n\n            $alias = sprintf('C%d', $this->getId());\n            $expr = call_user_func_array(array('SqlFunction', 'COALESCE'),\n                    $fields);\n            $query->annotate(array($alias => $expr));\n\n            $reverse = $reverse ? '-' : '';\n            $query = $query->order_by(\"{$reverse}{$alias}\");\n        } elseif($keys[0]) {\n            list($path, $field) = $keys[0];\n            $query = $field->applyOrderBy($query, $reverse, $path);\n        }\n\n        return $query;\n    }\n\n    function getDataConfigForm($source=false) {\n        return new QueueColDataConfigForm($source ?: $this->getDbFields(),\n            array('id' => $this->id));\n    }\n\n    function getAnnotations() {\n        if (!isset($this->_annotations)) {\n            $this->_annotations = array();\n            if ($this->annotations\n                && ($anns = JsonDataParser::decode($this->annotations))\n            ) {\n                foreach ($anns as $D)\n                    if ($T = QueueColumnAnnotation::fromJson($D))\n                        $this->_annotations[] = $T;\n            }\n        }\n        return $this->_annotations;\n    }\n\n    function getConditions($include_queue=true) {\n        if (!isset($this->_conditions)) {\n            $this->_conditions = array();\n            if ($this->conditions\n                && ($conds = JsonDataParser::decode($this->conditions))\n            ) {\n                foreach ($conds as $C)\n                    if ($T = QueueColumnCondition::fromJson($C))\n                        $this->_conditions[] = $T;\n            }\n            // Support row-spanning conditions\n            if ($include_queue && ($q = $this->getQueue())\n                && ($q_conds = $q->getConditions())\n            ) {\n                $this->_conditions = array_merge($q_conds, $this->_conditions);\n            }\n        }\n        return $this->_conditions;\n    }\n\n    static function __create($vars) {\n        $c = new static($vars);\n        $c->save();\n        return $c;\n    }\n\n    static function placeholder($vars) {\n        return static::__hydrate($vars);\n    }\n\n    function update($vars, $root='Ticket') {\n        $form = $this->getDataConfigForm($vars);\n        foreach ($form->getClean() as $k=>$v)\n            $this->set($k, $v);\n\n        // Do the annotations\n        $this->_annotations = $annotations = array();\n        if (isset($vars['annotations'])) {\n            foreach (@$vars['annotations'] as $i=>$class) {\n                if ($vars['deco_column'][$i] != $this->id)\n                    continue;\n                if (!class_exists($class) || !is_subclass_of($class, 'QueueColumnAnnotation'))\n                    continue;\n                $json = array('c' => $class, 'p' => $vars['deco_pos'][$i]);\n                $annotations[] = $json;\n                $this->_annotations[] = QueueColumnAnnotation::fromJson($json);\n            }\n        }\n\n        // Do the conditions\n        $this->_conditions = $conditions = array();\n        if (isset($vars['conditions'])) {\n            list($this->_conditions, $conditions)\n                = self::getConditionsFromPost($vars, $this->id, $root);\n        }\n\n        // Store as JSON array\n        $this->annotations = JsonDataEncoder::encode($annotations);\n        $this->conditions = JsonDataEncoder::encode($conditions);\n    }\n\n    static function getConditionsFromPost(array $vars, $myid, $root='Ticket') {\n        $condition_objects = $conditions = array();\n\n        if (!isset($vars['conditions']))\n            return array($condition_objects, $conditions);\n\n        foreach (@$vars['conditions'] as $i=>$id) {\n            if ($vars['condition_column'][$i] != $myid)\n                // Not a condition for this column\n                continue;\n            // Determine the criteria\n            $name = $vars['condition_field'][$i];\n            $fields = CustomQueue::getSearchableFields($root);\n            if (!isset($fields[$name]))\n                // No such field exists for this queue root type\n                continue;\n            $parts = CustomQueue::getSearchField($fields[$name], $name);\n            $search_form = new SimpleForm($parts, $vars, array('id' => $id));\n            $search_form->getField(\"{$name}+search\")->value = true;\n            $crit = $search_form->getClean();\n            // Check the box to enable searching on the field\n            $crit[\"{$name}+search\"] = true;\n\n            // Isolate only the critical parts of the criteria\n            $crit = QueueColumnCondition::isolateCriteria($crit);\n\n            // Determine the properties\n            $props = array();\n            foreach ($vars['properties'] as $i=>$cid) {\n                if ($cid != $id)\n                    // Not a property for this condition\n                    continue;\n\n                // Determine the property configuration\n                $prop = $vars['property_name'][$i];\n                if (!($F = QueueColumnConditionProperty::getField($prop))) {\n                    // Not a valid property\n                    continue;\n                }\n                $prop_form = new SimpleForm(array($F), $vars, array('id' => $cid));\n                $props[$prop] = $prop_form->getField($prop)->getClean();\n            }\n            $json = array('crit' => $crit, 'prop' => $props);\n            $condition_objects[] = QueueColumnCondition::fromJson($json);\n            $conditions[] = $json;\n        }\n        return array($condition_objects, $conditions);\n    }\n}\n\n\nclass QueueConfig\nextends VerySimpleModel {\n    static $meta = array(\n        'table' => QUEUE_CONFIG_TABLE,\n        'pk' => array('queue_id', 'staff_id'),\n        'joins' => array(\n            'queue' => array(\n                'constraint' => array(\n                    'queue_id' => 'CustomQueue.id'),\n            ),\n            'staff' => array(\n                'constraint' => array(\n                    'staff_id' => 'Staff.staff_id',\n                )\n            ),\n            'columns' => array(\n                'reverse' => 'QueueColumnGlue.config',\n                'constrain' => array('staff_id' =>'QueueColumnGlue.staff_id'),\n                'broker' => 'QueueColumnListBroker',\n            ),\n        ),\n    );\n\n    function getSettings() {\n        return JsonDataParser::decode($this->setting);\n    }\n\n\n    function update($vars, &$errors) {\n\n        // settings of interest\n        $setting = array(\n                'sort_id' => (int) $vars['sort_id'],\n                'filter' => $vars['filter'],\n                'inherit-columns' => isset($vars['inherit-columns']),\n                'criteria' => $vars['criteria'] ?: array(),\n                );\n\n        if (!$setting['inherit-columns'] && $vars['columns']) {\n            if (!$this->columns->updateColumns($vars['columns'], $errors, array(\n                                'queue_id' => $this->queue_id,\n                                'staff_id' => $this->staff_id)))\n                $setting['inherit-columns'] = true;\n            $this->columns->reset();\n        }\n\n        $this->setting =  JsonDataEncoder::encode($setting);\n\n        return $this->save();\n    }\n\n    function save($refetch=false) {\n        if ($this->dirty)\n            $this->updated = SqlFunction::NOW();\n        return parent::save($refetch || $this->dirty);\n    }\n\n    static function create($vars=false) {\n        $inst = new static($vars);\n        return $inst;\n    }\n}\n\n\nclass QueueExport\nextends VerySimpleModel {\n    static $meta = array(\n        'table' => QUEUE_EXPORT_TABLE,\n        'pk' => array('id'),\n        'joins' => array(\n            'queue' => array(\n                'constraint' => array('queue_id' => 'CustomQueue.id'),\n            ),\n        ),\n        'select_related' => array('queue'),\n        'ordering' => array('sort'),\n    );\n\n\n    function getPath() {\n        return $this->path;\n    }\n\n    function getField() {\n        return $this->getPath();\n    }\n\n    function getHeading() {\n        return $this->heading;\n    }\n\n    static function create($vars=false) {\n        $inst = new static($vars);\n        return $inst;\n    }\n}\n\nclass QueueColumnGlue\nextends VerySimpleModel {\n    static $meta = array(\n        'table' => QUEUE_COLUMN_TABLE,\n        'pk' => array('queue_id', 'staff_id', 'column_id'),\n        'joins' => array(\n            'column' => array(\n                'constraint' => array('column_id' => 'QueueColumn.id'),\n            ),\n            'queue' => array(\n                'constraint' => array(\n                    'queue_id' => 'CustomQueue.id',\n                    'staff_id' => 'CustomQueue.staff_id'),\n            ),\n            'config' => array(\n                'constraint' => array(\n                    'queue_id' => 'QueueConfig.queue_id',\n                    'staff_id' => 'QueueConfig.staff_id'),\n            ),\n        ),\n        'select_related' => array('column'),\n        'ordering' => array('sort'),\n    );\n}\n\nclass QueueColumnGlueMIM\nextends ModelInstanceManager {\n    function getOrBuild($modelClass, $fields, $cache=true) {\n        $m = parent::getOrBuild($modelClass, $fields, $cache);\n        if ($m && $modelClass === 'QueueColumnGlue') {\n            // Instead, yield the QueueColumn instance with the local fields\n            // in the association table as annotations\n            $m = AnnotatedModel::wrap($m->column, $m, 'QueueColumn');\n        }\n        return $m;\n    }\n}\n\nclass QueueColumnListBroker\nextends InstrumentedList {\n    function __construct($fkey, $queryset=false) {\n        parent::__construct($fkey, $queryset, 'QueueColumnGlueMIM');\n        $this->queryset->select_related('column');\n    }\n\n    function add($column, $glue=null, $php7_is_annoying=true) {\n        $glue = $glue ?: new QueueColumnGlue();\n        $glue->column = $column;\n        $anno = AnnotatedModel::wrap($column, $glue);\n        parent::add($anno, false);\n        return $anno;\n    }\n\n    function updateColumns($columns, &$errors, $options=array()) {\n        $new = $columns;\n        $order = array_keys($new);\n        foreach ($this as $col) {\n            $key = $col->column_id;\n            if (!isset($columns[$key])) {\n                $this->remove($col);\n                continue;\n            }\n            $info = $columns[$key];\n            $col->set('sort', array_search($key, $order));\n            $col->set('heading', $info['heading']);\n            $col->set('width', $info['width']);\n            $col->setSortable($info['sortable']);\n            unset($new[$key]);\n        }\n        // Add new columns\n        foreach ($new as $info) {\n            $glue = new QueueColumnGlue(array(\n                'staff_id' => $options['staff_id'] ?: 0 ,\n                'queue_id' => $options['queue_id'] ?: 0,\n                'column_id' => $info['column_id'],\n                'sort' => array_search($info['column_id'], $order),\n                'heading' => $info['heading'],\n                'width' => $info['width'] ?: 100,\n                'bits' => $info['sortable'] ?  QueueColumn::FLAG_SORTABLE : 0,\n            ));\n\n            $this->add(QueueColumn::lookup($info['column_id']), $glue);\n        }\n        // Re-sort the in-memory columns array\n        $this->sort(function($c) { return $c->sort; });\n\n        return $this->saveAll();\n    }\n}\n\nclass QueueSort\nextends VerySimpleModel {\n    static $meta = array(\n        'table' => QUEUE_SORT_TABLE,\n        'pk' => array('id'),\n        'ordering' => array('name'),\n        'joins' => array(\n            'queue' => array(\n                'constraint' => array('queue_id' => 'CustomQueue.id'),\n            ),\n        ),\n    );\n\n    var $_columns;\n    var $_extra;\n\n    function getRoot($hint=false) {\n        switch ($hint ?: $this->root) {\n        case 'T':\n        default:\n            return 'Ticket';\n        }\n    }\n\n    function getName() {\n        return $this->name;\n    }\n\n    function getId() {\n        return $this->id;\n    }\n\n    function getExtra() {\n        if (isset($this->extra) && !isset($this->_extra))\n            $this->_extra = JsonDataParser::decode($this->extra);\n        return $this->_extra;\n    }\n\n    function applySort(QuerySet $query, $reverse=false, $root=false) {\n        $fields = CustomQueue::getSearchableFields($this->getRoot($root));\n        foreach ($this->getColumnPaths() as $path=>$descending) {\n            $descending = $reverse ? !$descending : $descending;\n            if (isset($fields[$path])) {\n                list(,$field) = $fields[$path];\n                $query = $field->applyOrderBy($query, $descending,\n                    CustomQueue::getOrmPath($path, $query));\n            }\n        }\n        // Add index hint if defined\n        if (($extra = $this->getExtra()) && isset($extra['index'])) {\n            $query->setOption(QuerySet::OPT_INDEX_HINT, $extra['index']);\n        }\n        return $query;\n    }\n\n    function getColumnPaths() {\n        if (!isset($this->_columns)) {\n            $columns = array();\n            foreach (JsonDataParser::decode($this->columns) as $path) {\n                if ($descending = $path[0] == '-')\n                    $path = substr($path, 1);\n                $columns[$path] = $descending;\n            }\n            $this->_columns = $columns;\n        }\n        return $this->_columns;\n    }\n\n    function getColumns() {\n        $columns = array();\n        $paths = $this->getColumnPaths();\n        $everything = CustomQueue::getSearchableFields($this->getRoot());\n        foreach ($paths as $p=>$descending) {\n            if (isset($everything[$p])) {\n                $columns[$p] = array($everything[$p], $descending);\n            }\n        }\n        return $columns;\n    }\n\n    function getDataConfigForm($source=false) {\n        return new QueueSortDataConfigForm($source ?: $this->getDbFields(),\n            array('id' => $this->id));\n    }\n\n    function getAdvancedConfigForm($source=false) {\n        return new QueueSortAdvancedConfigForm($source ?: $this->getExtra(),\n            array('id' => $this->id));\n    }\n\n    static function forQueue(CustomQueue $queue) {\n        return static::objects()->filter([\n            'root' => $queue->root ?: 'T',\n        ]);\n    }\n\n    function save($refetch=false) {\n        if ($this->dirty)\n            $this->updated = SqlFunction::NOW();\n        return parent::save($refetch || $this->dirty);\n    }\n\n    function update($vars, &$errors=array()) {\n        if (!isset($vars['name']))\n            $errors['name'] = __('A title is required');\n\n        $this->name = $vars['name'];\n        if (isset($vars['root']))\n            $this->root = $vars['root'];\n        elseif (!isset($this->root))\n            $this->root = 'T';\n\n        $fields = CustomQueue::getSearchableFields($this->getRoot($vars['root']));\n        $columns = array();\n        if (@is_array($vars['columns'])) {\n            foreach ($vars['columns']as $path=>$info) {\n                $descending = (int) @$info['descending'];\n                // TODO: Check if column is valid, stash in $columns\n                if (!isset($fields[$path]))\n                    continue;\n                $columns[] = ($descending ? '-' : '') . $path;\n            }\n            $this->columns = JsonDataEncoder::encode($columns);\n        }\n\n        if ($this->getExtra() !== null) {\n            $extra = $this->getAdvancedConfigForm($vars)->getClean();\n            $this->extra = JsonDataEncoder::encode($extra);\n        }\n\n        if (count($errors))\n            return false;\n\n        return $this->save();\n    }\n\n    static function __create($vars) {\n        $c = new static($vars);\n        $c->save();\n        return $c;\n    }\n}\n\nclass QueueSortGlue\nextends VerySimpleModel {\n    static $meta = array(\n        'table' => QUEUE_SORTING_TABLE,\n        'pk' => array('sort_id', 'queue_id'),\n        'joins' => array(\n            'ordering' => array(\n                'constraint' => array('sort_id' => 'QueueSort.id'),\n            ),\n            'queue' => array(\n                'constraint' => array('queue_id' => 'CustomQueue.id'),\n            ),\n        ),\n        'select_related' => array('ordering', 'queue'),\n        'ordering' => array('sort'),\n    );\n}\n\nclass QueueSortGlueMIM\nextends ModelInstanceManager {\n    function getOrBuild($modelClass, $fields, $cache=true) {\n        $m = parent::getOrBuild($modelClass, $fields, $cache);\n        if ($m && $modelClass === 'QueueSortGlue') {\n            // Instead, yield the QueueColumn instance with the local fields\n            // in the association table as annotations\n            $m = AnnotatedModel::wrap($m->ordering, $m, 'QueueSort');\n        }\n        return $m;\n    }\n}\n\nclass QueueSortListBroker\nextends InstrumentedList {\n    function __construct($fkey, $queryset=false) {\n        parent::__construct($fkey, $queryset, 'QueueSortGlueMIM');\n        $this->queryset->select_related('ordering');\n    }\n\n    function add($ordering, $glue=null, $php7_is_annoying=true) {\n        $glue = $glue ?: new QueueSortGlue();\n        $glue->ordering = $ordering;\n        $anno = AnnotatedModel::wrap($ordering, $glue);\n        parent::add($anno, false);\n        return $anno;\n    }\n}\n\nabstract class QueueColumnFilter {\n    static $registry;\n\n    static $id = null;\n    static $desc = null;\n\n    static function register($filter, $group) {\n        if (!isset($filter::$id))\n            throw new Exception('QueueColumnFilter must define $id');\n        if (isset(static::$registry[$filter::$id]))\n            throw new Exception($filter::$id\n                . ': QueueColumnFilter already registered under that id');\n        if (!is_subclass_of($filter, get_called_class()))\n            throw new Exception('Filter must extend QueueColumnFilter');\n\n        static::$registry[$filter::$id] = array($group, $filter);\n    }\n\n    static function getFilters() {\n        $list = static::$registry;\n        $base = array();\n        foreach ($list as $id=>$stuff) {\n            list($group, $class) = $stuff;\n            $base[$group][$id] = __($class::$desc);\n        }\n        return $base;\n    }\n\n    static function getInstance($id) {\n        if (isset(static::$registry[$id])) {\n            list(, $class) = @static::$registry[$id];\n            if ($class && class_exists($class))\n                return new $class();\n        }\n    }\n\n    function mangleQuery($query, $column) { return $query; }\n\n    abstract function filter($value, $row);\n}\n\nclass TicketLinkFilter\nextends QueueColumnFilter {\n    static $id = 'link:ticket';\n    static $desc = /* @trans */ \"Ticket Link\";\n\n    function filter($text, $row) {\n        if ($link = $this->getLink($row))\n            return sprintf('<a style=\"display:inline\" href=\"%s\">%s</a>', $link, $text);\n    }\n\n    function mangleQuery($query, $column) {\n        static $fields = array(\n            'link:ticket'   => 'ticket_id',\n            'link:ticketP'  => 'ticket_id',\n            'link:user'     => 'user_id',\n            'link:org'      => 'user__org_id',\n        );\n\n        if (isset($fields[static::$id])) {\n            $query = $query->values($fields[static::$id]);\n        }\n        return $query;\n    }\n\n    function getLink($row) {\n        return Ticket::getLink($row['ticket_id']);\n    }\n}\n\nclass UserLinkFilter\nextends TicketLinkFilter {\n    static $id = 'link:user';\n    static $desc = /* @trans */ \"User Link\";\n\n    function getLink($row) {\n        return User::getLink($row['user_id']);\n    }\n}\n\nclass OrgLinkFilter\nextends TicketLinkFilter {\n    static $id = 'link:org';\n    static $desc = /* @trans */ \"Organization Link\";\n\n    function getLink($row) {\n        return Organization::getLink($row['user__org_id']);\n    }\n}\nQueueColumnFilter::register('TicketLinkFilter', __('Link'));\nQueueColumnFilter::register('UserLinkFilter', __('Link'));\nQueueColumnFilter::register('OrgLinkFilter', __('Link'));\n\nclass TicketLinkWithPreviewFilter\nextends TicketLinkFilter {\n    static $id = 'link:ticketP';\n    static $desc = /* @trans */ \"Ticket Link with Preview\";\n\n    function filter($text, $row) {\n        $link = $this->getLink($row);\n        return sprintf('<a style=\"display: inline\" class=\"preview\" data-preview=\"#tickets/%d/preview\" href=\"%s\">%s</a>',\n            $row['ticket_id'], $link, $text);\n    }\n}\nQueueColumnFilter::register('TicketLinkWithPreviewFilter', __('Link'));\n\nclass DateTimeFilter\nextends QueueColumnFilter {\n    static $id = 'date:full';\n    static $desc = /* @trans */ \"Date and Time\";\n\n    function filter($text, $row) {\n        return $text ?\n            $text->changeTo(Format::datetime($text->value)) : '';\n    }\n}\n\nclass HumanizedDateFilter\nextends QueueColumnFilter {\n    static $id = 'date:human';\n    static $desc = /* @trans */ \"Relative Date and Time\";\n\n    function filter($text, $row) {\n        return sprintf(\n            '<time class=\"relative\" datetime=\"%s\" title=\"%s\">%s</time>',\n            date(DateTime::W3C, Misc::db2gmtime($text->value)),\n            Format::daydatetime($text->value),\n            Format::relativeTime(Misc::db2gmtime($text->value))\n        );\n    }\n}\nQueueColumnFilter::register('DateTimeFilter', __('Date Format'));\nQueueColumnFilter::register('HumanizedDateFilter', __('Date Format'));\n\nclass QueueColDataConfigForm\nextends AbstractForm {\n    function buildFields() {\n        return array(\n            'primary' => new DataSourceField(array(\n                'label' => __('Primary Data Source'),\n                'required' => true,\n                'configuration' => array(\n                    'root' => 'Ticket',\n                ),\n                'layout' => new GridFluidCell(6),\n            )),\n            'secondary' => new DataSourceField(array(\n                'label' => __('Secondary Data Source'),\n                'configuration' => array(\n                    'root' => 'Ticket',\n                ),\n                'layout' => new GridFluidCell(6),\n            )),\n            'name' => new TextboxField(array(\n                'label' => __('Name'),\n                'required' => true,\n                'layout' => new GridFluidCell(4),\n            )),\n            'filter' => new ChoiceField(array(\n                'label' => __('Filter'),\n                'required' => false,\n                'choices' => QueueColumnFilter::getFilters(),\n                'layout' => new GridFluidCell(4),\n            )),\n            'truncate' => new ChoiceField(array(\n                'label' => __('Text Overflow'),\n                'choices' => array(\n                    'wrap' => __(\"Wrap Lines\"),\n                    'ellipsis' => __(\"Add Ellipsis\"),\n                    'clip' => __(\"Clip Text\"),\n                    'lclip' => __(\"Clip Beginning Text\"),\n                ),\n                'default' => 'wrap',\n                'layout' => new GridFluidCell(4),\n            )),\n        );\n    }\n}\n\nclass QueueSortDataConfigForm\nextends AbstractForm {\n    function getInstructions() {\n        return __('Add, and remove the fields in this list using the options below. Sorting can be performed on any field, whether displayed in the queue or not.');\n    }\n\n    function buildFields() {\n        return array(\n            'name' => new TextboxField(array(\n                'required' => true,\n                'layout' => new GridFluidCell(12),\n                'translatable' => isset($this->options['id'])\n                    ? _H('queuesort.name.'.$this->options['id']) : false,\n                'configuration' => array(\n                    'placeholder' => __('Sort Criteria Title'),\n                ),\n            )),\n        );\n    }\n}\n\nclass QueueSortAdvancedConfigForm\nextends AbstractForm {\n    function getInstructions() {\n        return __('If unsure, leave these options blank and unset');\n    }\n\n    function buildFields() {\n        return array(\n            'index' => new TextboxField(array(\n                'label' => __('Database Index'),\n                'hint' => __('Use this index when sorting on this column'),\n                'required' => false,\n                'layout' => new GridFluidCell(12),\n                'configuration' => array(\n                    'placeholder' => __('Automatic'),\n                ),\n            )),\n        );\n    }\n}\n", "<?php\n/*********************************************************************\n    queues.php\n\n    Handles management of custom queues\n\n    Jared Hancock <jared@osticket.com>\n    Peter Rotich <peter@osticket.com>\n    Copyright (c)  2006-2015 osTicket\n    http://www.osticket.com\n\n    Released under the GNU General Public License WITHOUT ANY WARRANTY.\n    See LICENSE.TXT for details.\n\n    vim: expandtab sw=4 ts=4 sts=4:\n**********************************************************************/\n\nrequire('admin.inc.php');\n\n$nav->setTabActive('settings', 'settings.php?t='.urlencode($_GET['t']));\n$errors = array();\n\nif ($_REQUEST['id'] && is_numeric($_REQUEST['id'])) {\n    $queue = CustomQueue::lookup($_REQUEST['id']);\n}\n\nif ($_POST) {\n    switch (strtolower($_POST['do'])) {\n    case 'update':\n        if (!$queue) {\n            $errors['err'] = '';\n            break;\n        }\n        if ($queue->update($_POST, $errors) && $queue->save()) {\n            $msg = sprintf(__('Successfully updated %s'), Format::htmlchars($_POST['name']));\n        }\n        elseif (!$errors['err']) {\n            $errors['err']=sprintf(__('Unable to update %s. Correct error(s) below and try again.'),\n                __('this queue'));\n        }\n        break;\n\n    case 'create':\n        $queue = CustomQueue::create(array(\n            'staff_id' => 0,\n            'title' => Format::htmlchars($_POST['queue-name']),\n            'root' => 'T'\n        ));\n\n        if ($queue->update($_POST, $errors) && $queue->save(true)) {\n            $msg = sprintf(__('Successfully added %s'),\n                    Format::htmlchars($queue->getName()));\n        }\n        elseif (!$errors['err']) {\n            $errors['err']=sprintf(__('Unable to add %s. Correct error(s) below and try again.'),\n                __('this queue'));\n        }\n        break;\n\n    case 'mass_process':\n        $updated = 0;\n        foreach (CustomQueue::objects()\n            ->filter(['id__in' => $_POST['ids']]) as $queue\n        ) {\n            switch ($_POST['a']) {\n            case 'enable':\n                $queue->enable();\n                if ($queue->save()) $updated++;\n                break;\n            case 'disable':\n                $queue->disable();\n                if ($queue->save()) $updated++;\n                break;\n            case 'delete':\n                if ($queue->getId() == $cfg->getDefaultTicketQueueId())\n                    $err = __('This queue is the default queue. Unable to delete. ');\n                elseif ($queue->delete()) $updated++;\n            }\n        }\n        if (!$updated) {\n            Messages::error($err ?: __(\n                'Unable to manage any of the selected queues'));\n        }\n        elseif ($_POST['count'] && $updated != $_POST['count']) {\n            Messages::warning(__(\n                'Not all selected items were updated'));\n        }\n        elseif ($updated) {\n            Messages::success(__(\n                'Successfully managed selected queues'));\n        }\n\n        // TODO: Consider redirecting based on the queue root\n        Http::redirect('settings.php?t=tickets#queues');\n    }\n}\nelseif (isset($_GET['a'])\n    && isset($queue) && $queue instanceof CustomQueue\n) {\n    switch (strtolower($_GET['a'])) {\n    case 'clone':\n        $queue = $queue->copy();\n        // Require a new name for the queue\n        unset($queue->title);\n        break;\n    case 'sub':\n        $q = new CustomQueue([\n            'parent' => $queue,\n            'flags' => CustomQueue::FLAG_QUEUE\n                     | CustomQueue::FLAG_INHERIT_EVERYTHING,\n        ]);\n        $queue = $q;\n        break;\n    }\n}\n\nrequire_once(STAFFINC_DIR.'header.inc.php');\ninclude_once(STAFFINC_DIR.\"queue.inc.php\");\ninclude_once(STAFFINC_DIR.'footer.inc.php');\n"], "filenames": ["include/class.queue.php", "scp/queues.php"], "buggy_code_start_loc": [1207, 46], "buggy_code_end_loc": [1215, 47], "fixing_code_start_loc": [1207, 46], "fixing_code_end_loc": [1215, 47], "type": "CWE-79", "message": "Cross Site Scripting (XSS) vulnerability in Enhancesoft osTicket before v1.12.6 via the queue-name parameter in include/class.queue.php.", "other": {"cve": {"id": "CVE-2020-22609", "sourceIdentifier": "cve@mitre.org", "published": "2021-06-28T19:15:07.900", "lastModified": "2021-07-01T18:52:56.123", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross Site Scripting (XSS) vulnerability in Enhancesoft osTicket before v1.12.6 via the queue-name parameter in include/class.queue.php."}, {"lang": "es", "value": "Una vulnerabilidad de tipo Cross Site Scripting (XSS) en Enhancesoft osTicket versiones anteriores a v1.12.6, por medio del par\u00e1metro queue-name en el archivo include/class.queue.php"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:enhancesoft:osticket:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.12.6", "matchCriteriaId": "841AF410-1840-4395-AD45-3D0FCD9DF878"}]}]}], "references": [{"url": "https://github.com/osTicket/osTicket/commit/6c724ea3fe352d10d457d334dc054ef81917fde1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/osTicket/osTicket/commit/6c724ea3fe352d10d457d334dc054ef81917fde1"}}