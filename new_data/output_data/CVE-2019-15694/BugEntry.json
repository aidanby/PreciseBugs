{"buggy_code": ["/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/time.h>\n#ifdef _WIN32\n#include <winsock2.h>\n#define close closesocket\n#undef errno\n#define errno WSAGetLastError()\n#include <os/winerrno.h>\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#endif\n\n#ifndef vncmin\n#define vncmin(a,b)            (((a) < (b)) ? (a) : (b))\n#endif\n#ifndef vncmax\n#define vncmax(a,b)            (((a) > (b)) ? (a) : (b))\n#endif\n\n/* Old systems have select() in sys/time.h */\n#ifdef HAVE_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n\n#include <rdr/FdInStream.h>\n#include <rdr/Exception.h>\n\nusing namespace rdr;\n\nenum { DEFAULT_BUF_SIZE = 8192,\n       MIN_BULK_SIZE = 1024 };\n\nFdInStream::FdInStream(int fd_, int timeoutms_, int bufSize_,\n                       bool closeWhenDone_)\n  : fd(fd_), closeWhenDone(closeWhenDone_),\n    timeoutms(timeoutms_), blockCallback(0),\n    timing(false), timeWaitedIn100us(5), timedKbits(0),\n    bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0)\n{\n  ptr = end = start = new U8[bufSize];\n}\n\nFdInStream::FdInStream(int fd_, FdInStreamBlockCallback* blockCallback_,\n                       int bufSize_)\n  : fd(fd_), timeoutms(0), blockCallback(blockCallback_),\n    timing(false), timeWaitedIn100us(5), timedKbits(0),\n    bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0)\n{\n  ptr = end = start = new U8[bufSize];\n}\n\nFdInStream::~FdInStream()\n{\n  delete [] start;\n  if (closeWhenDone) close(fd);\n}\n\n\nvoid FdInStream::setTimeout(int timeoutms_) {\n  timeoutms = timeoutms_;\n}\n\nvoid FdInStream::setBlockCallback(FdInStreamBlockCallback* blockCallback_)\n{\n  blockCallback = blockCallback_;\n  timeoutms = 0;\n}\n\nint FdInStream::pos()\n{\n  return offset + ptr - start;\n}\n\nvoid FdInStream::readBytes(void* data, int length)\n{\n  if (length < MIN_BULK_SIZE) {\n    InStream::readBytes(data, length);\n    return;\n  }\n\n  U8* dataPtr = (U8*)data;\n\n  int n = end - ptr;\n  if (n > length) n = length;\n\n  memcpy(dataPtr, ptr, n);\n  dataPtr += n;\n  length -= n;\n  ptr += n;\n\n  while (length > 0) {\n    n = readWithTimeoutOrCallback(dataPtr, length);\n    dataPtr += n;\n    length -= n;\n    offset += n;\n  }\n}\n\n\nint FdInStream::overrun(int itemSize, int nItems, bool wait)\n{\n  if (itemSize > bufSize)\n    throw Exception(\"FdInStream overrun: max itemSize exceeded\");\n\n  if (end - ptr != 0)\n    memmove(start, ptr, end - ptr);\n\n  offset += ptr - start;\n  end -= ptr - start;\n  ptr = start;\n\n  int bytes_to_read;\n  while (end < start + itemSize) {\n    bytes_to_read = start + bufSize - end;\n    if (!timing) {\n      // When not timing, we must be careful not to read too much\n      // extra data into the buffer. Otherwise, the line speed\n      // estimation might stay at zero for a long time: All reads\n      // during timing=1 can be satisfied without calling\n      // readWithTimeoutOrCallback. However, reading only 1 or 2 bytes\n      // bytes is ineffecient.\n      bytes_to_read = vncmin(bytes_to_read, vncmax(itemSize*nItems, 8));\n    }\n    int n = readWithTimeoutOrCallback((U8*)end, bytes_to_read, wait);\n    if (n == 0) return 0;\n    end += n;\n  }\n\n  if (itemSize * nItems > end - ptr)\n    nItems = (end - ptr) / itemSize;\n\n  return nItems;\n}\n\n//\n// readWithTimeoutOrCallback() reads up to the given length in bytes from the\n// file descriptor into a buffer.  If the wait argument is false, then zero is\n// returned if no bytes can be read without blocking.  Otherwise if a\n// blockCallback is set, it will be called (repeatedly) instead of blocking.\n// If alternatively there is a timeout set and that timeout expires, it throws\n// a TimedOut exception.  Otherwise it returns the number of bytes read.  It\n// never attempts to recv() unless select() indicates that the fd is readable -\n// this means it can be used on an fd which has been set non-blocking.  It also\n// has to cope with the annoying possibility of both select() and recv()\n// returning EINTR.\n//\n\nint FdInStream::readWithTimeoutOrCallback(void* buf, int len, bool wait)\n{\n  struct timeval before, after;\n  if (timing)\n    gettimeofday(&before, 0);\n\n  int n;\n  while (true) {\n    do {\n      fd_set fds;\n      struct timeval tv;\n      struct timeval* tvp = &tv;\n\n      if (!wait) {\n        tv.tv_sec = tv.tv_usec = 0;\n      } else if (timeoutms != -1) {\n        tv.tv_sec = timeoutms / 1000;\n        tv.tv_usec = (timeoutms % 1000) * 1000;\n      } else {\n        tvp = 0;\n      }\n\n      FD_ZERO(&fds);\n      FD_SET(fd, &fds);\n      n = select(fd+1, &fds, 0, 0, tvp);\n    } while (n < 0 && errno == EINTR);\n\n    if (n > 0) break;\n    if (n < 0) throw SystemException(\"select\",errno);\n    if (!wait) return 0;\n    if (!blockCallback) throw TimedOut();\n\n    blockCallback->blockCallback();\n  }\n\n  do {\n    n = ::recv(fd, (char*)buf, len, 0);\n  } while (n < 0 && errno == EINTR);\n\n  if (n < 0) throw SystemException(\"read\",errno);\n  if (n == 0) throw EndOfStream();\n\n  if (timing) {\n    gettimeofday(&after, 0);\n    int newTimeWaited = ((after.tv_sec - before.tv_sec) * 10000 +\n                         (after.tv_usec - before.tv_usec) / 100);\n    int newKbits = n * 8 / 1000;\n\n    // limit rate to between 10kbit/s and 40Mbit/s\n\n    if (newTimeWaited > newKbits*1000) newTimeWaited = newKbits*1000;\n    if (newTimeWaited < newKbits/4)    newTimeWaited = newKbits/4;\n\n    timeWaitedIn100us += newTimeWaited;\n    timedKbits += newKbits;\n  }\n\n  return n;\n}\n\nvoid FdInStream::startTiming()\n{\n  timing = true;\n\n  // Carry over up to 1s worth of previous rate for smoothing.\n\n  if (timeWaitedIn100us > 10000) {\n    timedKbits = timedKbits * 10000 / timeWaitedIn100us;\n    timeWaitedIn100us = 10000;\n  }\n}\n\nvoid FdInStream::stopTiming()\n{\n  timing = false; \n  if (timeWaitedIn100us < timedKbits/2)\n    timeWaitedIn100us = timedKbits/2; // upper limit 20Mbit/s\n}\n\nunsigned int FdInStream::kbitsPerSecond()\n{\n  // The following calculation will overflow 32-bit arithmetic if we have\n  // received more than about 50Mbytes (400Mbits) since we started timing, so\n  // it should be OK for a single RFB update.\n\n  return timedKbits * 10000 / timeWaitedIn100us;\n}\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n//\n// FdInStream streams from a file descriptor.\n//\n\n#ifndef __RDR_FDINSTREAM_H__\n#define __RDR_FDINSTREAM_H__\n\n#include <rdr/InStream.h>\n\nnamespace rdr {\n\n  class FdInStreamBlockCallback {\n  public:\n    virtual void blockCallback() = 0;\n    virtual ~FdInStreamBlockCallback() {}\n  };\n\n  class FdInStream : public InStream {\n\n  public:\n\n    FdInStream(int fd, int timeoutms=-1, int bufSize=0,\n               bool closeWhenDone_=false);\n    FdInStream(int fd, FdInStreamBlockCallback* blockCallback, int bufSize=0);\n    virtual ~FdInStream();\n\n    void setTimeout(int timeoutms);\n    void setBlockCallback(FdInStreamBlockCallback* blockCallback);\n    int getFd() { return fd; }\n    int pos();\n    void readBytes(void* data, int length);\n\n    void startTiming();\n    void stopTiming();\n    unsigned int kbitsPerSecond();\n    unsigned int timeWaited() { return timeWaitedIn100us; }\n\n  protected:\n    int overrun(int itemSize, int nItems, bool wait);\n\n  private:\n    int readWithTimeoutOrCallback(void* buf, int len, bool wait=true);\n\n    int fd;\n    bool closeWhenDone;\n    int timeoutms;\n    FdInStreamBlockCallback* blockCallback;\n\n    bool timing;\n    unsigned int timeWaitedIn100us;\n    unsigned int timedKbits;\n\n    int bufSize;\n    int offset;\n    U8* start;\n  };\n\n} // end of namespace rdr\n\n#endif\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * Copyright 2011 Pierre Ossman for Cendio AB\n * Copyright 2017 Peter Astrand <astrand@cendio.se> for Cendio AB\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#ifdef _WIN32\n#include <winsock2.h>\n#undef errno\n#define errno WSAGetLastError()\n#include <os/winerrno.h>\n#else\n#include <sys/types.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#endif\n\n/* Old systems have select() in sys/time.h */\n#ifdef HAVE_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n\n#include <rdr/FdOutStream.h>\n#include <rdr/Exception.h>\n#include <rfb/util.h>\n\n\nusing namespace rdr;\n\nenum { DEFAULT_BUF_SIZE = 16384 };\n\nFdOutStream::FdOutStream(int fd_, bool blocking_, int timeoutms_, int bufSize_)\n  : fd(fd_), blocking(blocking_), timeoutms(timeoutms_),\n    bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0)\n{\n  ptr = start = sentUpTo = new U8[bufSize];\n  end = start + bufSize;\n\n  gettimeofday(&lastWrite, NULL);\n}\n\nFdOutStream::~FdOutStream()\n{\n  try {\n    blocking = true;\n    flush();\n  } catch (Exception&) {\n  }\n  delete [] start;\n}\n\nvoid FdOutStream::setTimeout(int timeoutms_) {\n  timeoutms = timeoutms_;\n}\n\nvoid FdOutStream::setBlocking(bool blocking_) {\n  blocking = blocking_;\n}\n\nint FdOutStream::length()\n{\n  return offset + ptr - sentUpTo;\n}\n\nint FdOutStream::bufferUsage()\n{\n  return ptr - sentUpTo;\n}\n\nunsigned FdOutStream::getIdleTime()\n{\n  return rfb::msSince(&lastWrite);\n}\n\nvoid FdOutStream::flush()\n{\n  while (sentUpTo < ptr) {\n    int n = writeWithTimeout((const void*) sentUpTo,\n                             ptr - sentUpTo,\n                             blocking? timeoutms : 0);\n\n    // Timeout?\n    if (n == 0) {\n      // If non-blocking then we're done here\n      if (!blocking)\n        break;\n\n      throw TimedOut();\n    }\n\n    sentUpTo += n;\n    offset += n;\n  }\n\n   // Managed to flush everything?\n  if (sentUpTo == ptr)\n    ptr = sentUpTo = start;\n}\n\n\nint FdOutStream::overrun(int itemSize, int nItems)\n{\n  if (itemSize > bufSize)\n    throw Exception(\"FdOutStream overrun: max itemSize exceeded\");\n\n  // First try to get rid of the data we have\n  flush();\n\n  // Still not enough space?\n  if (itemSize > end - ptr) {\n    // Can we shuffle things around?\n    // (don't do this if it gains us less than 25%)\n    if ((sentUpTo - start > bufSize / 4) &&\n        (itemSize < bufSize - (ptr - sentUpTo))) {\n      memmove(start, sentUpTo, ptr - sentUpTo);\n      ptr = start + (ptr - sentUpTo);\n      sentUpTo = start;\n    } else {\n      // Have to get rid of more data, so turn off non-blocking\n      // for a bit...\n      bool realBlocking;\n\n      realBlocking = blocking;\n      blocking = true;\n      flush();\n      blocking = realBlocking;\n    }\n  }\n\n  // Can we fit all the items asked for?\n  if (itemSize * nItems > end - ptr)\n    nItems = (end - ptr) / itemSize;\n\n  return nItems;\n}\n\n//\n// writeWithTimeout() writes up to the given length in bytes from the given\n// buffer to the file descriptor.  If there is a timeout set and that timeout\n// expires, it throws a TimedOut exception.  Otherwise it returns the number of\n// bytes written.  It never attempts to send() unless select() indicates that\n// the fd is writable - this means it can be used on an fd which has been set\n// non-blocking.  It also has to cope with the annoying possibility of both\n// select() and send() returning EINTR.\n//\n\nint FdOutStream::writeWithTimeout(const void* data, int length, int timeoutms)\n{\n  int n;\n\n  do {\n    fd_set fds;\n    struct timeval tv;\n    struct timeval* tvp = &tv;\n\n    if (timeoutms != -1) {\n      tv.tv_sec = timeoutms / 1000;\n      tv.tv_usec = (timeoutms % 1000) * 1000;\n    } else {\n      tvp = NULL;\n    }\n\n    FD_ZERO(&fds);\n    FD_SET(fd, &fds);\n    n = select(fd+1, 0, &fds, 0, tvp);\n  } while (n < 0 && errno == EINTR);\n\n  if (n < 0)\n    throw SystemException(\"select\", errno);\n\n  if (n == 0)\n    return 0;\n\n  do {\n    // select only guarantees that you can write SO_SNDLOWAT without\n    // blocking, which is normally 1. Use MSG_DONTWAIT to avoid\n    // blocking, when possible.\n#ifndef MSG_DONTWAIT\n    n = ::send(fd, (const char*)data, length, 0);\n#else\n    n = ::send(fd, (const char*)data, length, MSG_DONTWAIT);\n#endif\n  } while (n < 0 && (errno == EINTR));\n\n  if (n < 0)\n    throw SystemException(\"write\", errno);\n\n  gettimeofday(&lastWrite, NULL);\n\n  return n;\n}\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * Copyright 2011 Pierre Ossman for Cendio AB\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n//\n// FdOutStream streams to a file descriptor.\n//\n\n#ifndef __RDR_FDOUTSTREAM_H__\n#define __RDR_FDOUTSTREAM_H__\n\n#include <sys/time.h>\n\n#include <rdr/OutStream.h>\n\nnamespace rdr {\n\n  class FdOutStream : public OutStream {\n\n  public:\n\n    FdOutStream(int fd, bool blocking=true, int timeoutms=-1, int bufSize=0);\n    virtual ~FdOutStream();\n\n    void setTimeout(int timeoutms);\n    void setBlocking(bool blocking);\n    int getFd() { return fd; }\n\n    void flush();\n    int length();\n\n    int bufferUsage();\n\n    unsigned getIdleTime();\n\n  private:\n    int overrun(int itemSize, int nItems);\n    int writeWithTimeout(const void* data, int length, int timeoutms);\n    int fd;\n    bool blocking;\n    int timeoutms;\n    int bufSize;\n    int offset;\n    U8* start;\n    U8* sentUpTo;\n    struct timeval lastWrite;\n  };\n\n}\n\n#endif\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * Copyright (C) 2013 D. R. Commander.  All Rights Reserved.\n * Copyright 2015 Pierre Ossman for Cendio AB\n *\n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#include <errno.h>\n\n#include <rdr/Exception.h>\n#include <rdr/FileInStream.h>\n\nusing namespace rdr;\n\nFileInStream::FileInStream(const char *fileName)\n{\n  file = fopen(fileName, \"rb\");\n  if (!file)\n    throw SystemException(\"fopen\", errno);\n  ptr = end = b;\n}\n\nFileInStream::~FileInStream(void) {\n  if (file) {\n    fclose(file);\n    file = NULL;\n  }\n}\n\nvoid FileInStream::reset(void) {\n  if (!file)\n    throw Exception(\"File is not open\");\n  if (fseek(file, 0, SEEK_SET) != 0)\n    throw SystemException(\"fseek\", errno);\n  ptr = end = b;\n}\n\nint FileInStream::pos()\n{\n  if (!file)\n    throw Exception(\"File is not open\");\n\n  return ftell(file) + ptr - b;\n}\n\nint FileInStream::overrun(int itemSize, int nItems, bool wait)\n{\n  if (itemSize > (int)sizeof(b))\n    throw Exception(\"FileInStream overrun: max itemSize exceeded\");\n\n  if (end - ptr != 0)\n    memmove(b, ptr, end - ptr);\n\n  end -= ptr - b;\n  ptr = b;\n\n\n  while (end < b + itemSize) {\n    size_t n = fread((U8 *)end, b + sizeof(b) - end, 1, file);\n    if (n == 0) {\n      if (ferror(file))\n        throw SystemException(\"fread\", errno);\n      if (feof(file))\n        throw EndOfStream();\n      return 0;\n    }\n    end += b + sizeof(b) - end;\n  }\n\n  if (itemSize * nItems > end - ptr)\n    nItems = (end - ptr) / itemSize;\n\n  return nItems;\n}\n", "/* Copyright (C) 2013 D. R. Commander.  All Rights Reserved.\n * Copyright 2015 Pierre Ossman for Cendio AB\n *\n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#ifndef __RDR_FILEINSTREAM_H__\n#define __RDR_FILEINSTREAM_H__\n\n#include <stdio.h>\n\n#include <rdr/InStream.h>\n\nnamespace rdr {\n\n  class FileInStream : public InStream {\n\n  public:\n\n    FileInStream(const char *fileName);\n    ~FileInStream(void);\n\n    void reset(void);\n\n    int pos();\n\n  protected:\n    int overrun(int itemSize, int nItems, bool wait = true);\n\n  private:\n    U8 b[131072];\n    FILE *file;\n  };\n\n} // end of namespace rdr\n\n#endif\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#include <rdr/HexInStream.h>\n#include <rdr/Exception.h>\n\n#include <stdlib.h>\n#include <ctype.h>\n\nusing namespace rdr;\n\nconst int DEFAULT_BUF_LEN = 16384;\n\nstatic inline int min(int a, int b) {return a<b ? a : b;}\n\nHexInStream::HexInStream(InStream& is, int bufSize_)\n: bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_LEN), offset(0), in_stream(is)\n{\n  ptr = end = start = new U8[bufSize];\n}\n\nHexInStream::~HexInStream() {\n  delete [] start;\n}\n\n\nbool HexInStream::readHexAndShift(char c, int* v) {\n  c=tolower(c);\n  if ((c >= '0') && (c <= '9'))\n    *v = (*v << 4) + (c - '0');\n  else if ((c >= 'a') && (c <= 'f'))\n    *v = (*v << 4) + (c - 'a' + 10);\n  else\n    return false;\n  return true;\n}\n\nbool HexInStream::hexStrToBin(const char* s, char** data, int* length) {\n  int l=strlen(s);\n  if ((l % 2) == 0) {\n    delete [] *data;\n    *data = 0; *length = 0;\n    if (l == 0)\n      return true;\n    *data = new char[l/2];\n    *length = l/2;\n    for(int i=0;i<l;i+=2) {\n      int byte = 0;\n      if (!readHexAndShift(s[i], &byte) ||\n        !readHexAndShift(s[i+1], &byte))\n        goto decodeError;\n      (*data)[i/2] = byte;\n    }\n    return true;\n  }\ndecodeError:\n  delete [] *data;\n  *data = 0;\n  *length = 0;\n  return false;\n}\n\n\nint HexInStream::pos() {\n  return offset + ptr - start;\n}\n\nint HexInStream::overrun(int itemSize, int nItems, bool wait) {\n  if (itemSize > bufSize)\n    throw Exception(\"HexInStream overrun: max itemSize exceeded\");\n\n  if (end - ptr != 0)\n    memmove(start, ptr, end - ptr);\n\n  end -= ptr - start;\n  offset += ptr - start;\n  ptr = start;\n\n  while (end < ptr + itemSize) {\n    int n = in_stream.check(2, 1, wait);\n    if (n == 0) return 0;\n    const U8* iptr = in_stream.getptr();\n    const U8* eptr = in_stream.getend();\n    int length = min((eptr - iptr)/2, start + bufSize - end);\n\n    U8* optr = (U8*) end;\n    for (int i=0; i<length; i++) {\n      int v = 0;\n      readHexAndShift(iptr[i*2], &v);\n      readHexAndShift(iptr[i*2+1], &v);\n      optr[i] = v;\n    }\n\n    in_stream.setptr(iptr + length*2);\n    end += length;\n  }\n\n  if (itemSize * nItems > end - ptr)\n    nItems = (end - ptr) / itemSize;\n\n  return nItems;\n}\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#ifndef __RDR_HEX_INSTREAM_H__\n#define __RDR_HEX_INSTREAM_H__\n\n#include <rdr/InStream.h>\n\nnamespace rdr {\n\n  class HexInStream : public InStream {\n  public:\n\n    HexInStream(InStream& is, int bufSize=0);\n    virtual ~HexInStream();\n\n    int pos();\n\n    static bool readHexAndShift(char c, int* v);\n    static bool hexStrToBin(const char* s, char** data, int* length);\n\n  protected:\n    int overrun(int itemSize, int nItems, bool wait);\n\n  private:\n    int bufSize;\n    U8* start;\n    int offset;\n\n    InStream& in_stream;\n  };\n\n} // end of namespace rdr\n\n#endif\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#include <rdr/HexOutStream.h>\n#include <rdr/Exception.h>\n\nusing namespace rdr;\n\nconst int DEFAULT_BUF_LEN = 16384;\n\nstatic inline int min(int a, int b) {return a<b ? a : b;}\n\nHexOutStream::HexOutStream(OutStream& os, int buflen)\n: out_stream(os), offset(0), bufSize(buflen ? buflen : DEFAULT_BUF_LEN)\n{\n  if (bufSize % 2)\n    bufSize--;\n  ptr = start = new U8[bufSize];\n  end = start + bufSize;\n}\n\nHexOutStream::~HexOutStream() {\n  delete [] start;\n}\n\n\nchar HexOutStream::intToHex(int i) {\n  if ((i>=0) && (i<=9))\n    return '0'+i;\n  else if ((i>=10) && (i<=15))\n    return 'a'+(i-10);\n  else\n    throw rdr::Exception(\"intToHex failed\");\n}\n\nchar* HexOutStream::binToHexStr(const char* data, int length) {\n  char* buffer = new char[length*2+1];\n  for (int i=0; i<length; i++) {\n    buffer[i*2] = intToHex((data[i] >> 4) & 15);\n    buffer[i*2+1] = intToHex((data[i] & 15));\n    if (!buffer[i*2] || !buffer[i*2+1]) {\n      delete [] buffer;\n      return 0;\n    }\n  }\n  buffer[length*2] = 0;\n  return buffer;\n}\n\n\nvoid\nHexOutStream::writeBuffer() {\n  U8* pos = start;\n  while (pos != ptr) {\n    out_stream.check(2);\n    U8* optr = out_stream.getptr();\n    U8* oend = out_stream.getend();\n    int length = min(ptr-pos, (oend-optr)/2);\n\n    for (int i=0; i<length; i++) {\n      optr[i*2] = intToHex((pos[i] >> 4) & 0xf);\n      optr[i*2+1] = intToHex(pos[i] & 0xf);\n    }\n\n    out_stream.setptr(optr + length*2);\n    pos += length;\n  }\n  offset += ptr - start;\n  ptr = start;\n}\n\nint HexOutStream::length()\n{\n  return offset + ptr - start;\n}\n\nvoid\nHexOutStream::flush() {\n  writeBuffer();\n  out_stream.flush();\n}\n\nint\nHexOutStream::overrun(int itemSize, int nItems) {\n  if (itemSize > bufSize)\n    throw Exception(\"HexOutStream overrun: max itemSize exceeded\");\n\n  writeBuffer();\n\n  if (itemSize * nItems > end - ptr)\n    nItems = (end - ptr) / itemSize;\n\n  return nItems;\n}\n\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#ifndef __RDR_HEX_OUTSTREAM_H__\n#define __RDR_HEX_OUTSTREAM_H__\n\n#include <rdr/OutStream.h>\n\nnamespace rdr {\n\n  class HexOutStream : public OutStream {\n  public:\n\n    HexOutStream(OutStream& os, int buflen=0);\n    virtual ~HexOutStream();\n\n    void flush();\n    int length();\n\n    static char intToHex(int i);\n    static char* binToHexStr(const char* data, int length);\n\n  private:\n    void writeBuffer();\n    int overrun(int itemSize, int nItems);\n\n    OutStream& out_stream;\n\n    U8* start;\n    int offset;\n    int bufSize;\n  };\n\n}\n\n#endif\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n//\n// rdr::InStream marshalls data from a buffer stored in RDR (RFB Data\n// Representation).\n//\n\n#ifndef __RDR_INSTREAM_H__\n#define __RDR_INSTREAM_H__\n\n#include <rdr/types.h>\n#include <string.h> // for memcpy\n\nnamespace rdr {\n\n  class InStream {\n\n  public:\n\n    virtual ~InStream() {}\n\n    // check() ensures there is buffer data for at least one item of size\n    // itemSize bytes.  Returns the number of items in the buffer (up to a\n    // maximum of nItems).  If wait is false, then instead of blocking to wait\n    // for the bytes, zero is returned if the bytes are not immediately\n    // available.\n\n    inline int check(int itemSize, int nItems=1, bool wait=true)\n    {\n      if (ptr + itemSize * nItems > end) {\n        if (ptr + itemSize > end)\n          return overrun(itemSize, nItems, wait);\n\n        nItems = (end - ptr) / itemSize;\n      }\n      return nItems;\n    }\n\n    // checkNoWait() tries to make sure that the given number of bytes can\n    // be read without blocking.  It returns true if this is the case, false\n    // otherwise.  The length must be \"small\" (less than the buffer size).\n\n    inline bool checkNoWait(int length) { return check(length, 1, false)!=0; }\n\n    // readU/SN() methods read unsigned and signed N-bit integers.\n\n    inline U8  readU8()  { check(1); return *ptr++; }\n    inline U16 readU16() { check(2); int b0 = *ptr++; int b1 = *ptr++;\n                           return b0 << 8 | b1; }\n    inline U32 readU32() { check(4); int b0 = *ptr++; int b1 = *ptr++;\n                                     int b2 = *ptr++; int b3 = *ptr++;\n                           return b0 << 24 | b1 << 16 | b2 << 8 | b3; }\n\n    inline S8  readS8()  { return (S8) readU8();  }\n    inline S16 readS16() { return (S16)readU16(); }\n    inline S32 readS32() { return (S32)readU32(); }\n\n    // readString() reads a string - a U32 length followed by the data.\n    // Returns a null-terminated string - the caller should delete[] it\n    // afterwards.\n\n    char* readString();\n\n    // maxStringLength protects against allocating a huge buffer.  Set it\n    // higher if you need longer strings.\n\n    static U32 maxStringLength;\n\n    inline void skip(int bytes) {\n      while (bytes > 0) {\n        int n = check(1, bytes);\n        ptr += n;\n        bytes -= n;\n      }\n    }\n\n    // readBytes() reads an exact number of bytes.\n\n    void readBytes(void* data, int length) {\n      U8* dataPtr = (U8*)data;\n      U8* dataEnd = dataPtr + length;\n      while (dataPtr < dataEnd) {\n        int n = check(1, dataEnd - dataPtr);\n        memcpy(dataPtr, ptr, n);\n        ptr += n;\n        dataPtr += n;\n      }\n    }\n\n    // readOpaqueN() reads a quantity without byte-swapping.\n\n    inline U8  readOpaque8()  { return readU8(); }\n    inline U16 readOpaque16() { check(2); U16 r; ((U8*)&r)[0] = *ptr++;\n                                ((U8*)&r)[1] = *ptr++; return r; }\n    inline U32 readOpaque32() { check(4); U32 r; ((U8*)&r)[0] = *ptr++;\n                                ((U8*)&r)[1] = *ptr++; ((U8*)&r)[2] = *ptr++;\n                                ((U8*)&r)[3] = *ptr++; return r; }\n\n    // pos() returns the position in the stream.\n\n    virtual int pos() = 0;\n\n    // getptr(), getend() and setptr() are \"dirty\" methods which allow you to\n    // manipulate the buffer directly.  This is useful for a stream which is a\n    // wrapper around an underlying stream.\n\n    inline const U8* getptr() const { return ptr; }\n    inline const U8* getend() const { return end; }\n    inline void setptr(const U8* p) { ptr = p; }\n\n  private:\n\n    // overrun() is implemented by a derived class to cope with buffer overrun.\n    // It ensures there are at least itemSize bytes of buffer data.  Returns\n    // the number of items in the buffer (up to a maximum of nItems).  itemSize\n    // is supposed to be \"small\" (a few bytes).  If wait is false, then\n    // instead of blocking to wait for the bytes, zero is returned if the bytes\n    // are not immediately available.\n\n    virtual int overrun(int itemSize, int nItems, bool wait=true) = 0;\n\n  protected:\n\n    InStream() {}\n    const U8* ptr;\n    const U8* end;\n  };\n\n}\n\n#endif\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n//\n// rdr::MemInStream is an InStream which streams from a given memory buffer.\n// If the deleteWhenDone parameter is true then the buffer will be delete[]d in\n// the destructor.  Note that it is delete[]d as a U8* - strictly speaking this\n// means it ought to be new[]ed as a U8* as well, but on most platforms this\n// doesn't matter.\n//\n\n#ifndef __RDR_MEMINSTREAM_H__\n#define __RDR_MEMINSTREAM_H__\n\n#include <rdr/InStream.h>\n#include <rdr/Exception.h>\n\nnamespace rdr {\n\n  class MemInStream : public InStream {\n\n  public:\n\n    MemInStream(const void* data, int len, bool deleteWhenDone_=false)\n      : start((const U8*)data), deleteWhenDone(deleteWhenDone_)\n    {\n      ptr = start;\n      end = start + len;\n    }\n\n    virtual ~MemInStream() {\n      if (deleteWhenDone)\n        delete [] start;\n    }\n\n    int pos() { return ptr - start; }\n    void reposition(int pos) { ptr = start + pos; }\n\n  private:\n\n    int overrun(int itemSize, int nItems, bool wait) { throw EndOfStream(); }\n    const U8* start;\n    bool deleteWhenDone;\n  };\n\n}\n\n#endif\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n//\n// A MemOutStream grows as needed when data is written to it.\n//\n\n#ifndef __RDR_MEMOUTSTREAM_H__\n#define __RDR_MEMOUTSTREAM_H__\n\n#include <rdr/OutStream.h>\n\nnamespace rdr {\n\n  class MemOutStream : public OutStream {\n\n  public:\n\n    MemOutStream(int len=1024) {\n      start = ptr = new U8[len];\n      end = start + len;\n    }\n\n    virtual ~MemOutStream() {\n      delete [] start;\n    }\n\n    void writeBytes(const void* data, int length) {\n      check(length);\n      memcpy(ptr, data, length);\n      ptr += length;\n    }\n\n    int length() { return ptr - start; }\n    void clear() { ptr = start; };\n    void clearAndZero() { memset(start, 0, ptr-start); clear(); }\n    void reposition(int pos) { ptr = start + pos; }\n\n    // data() returns a pointer to the buffer.\n\n    const void* data() { return (const void*)start; }\n\n  protected:\n\n    // overrun() either doubles the buffer or adds enough space for nItems of\n    // size itemSize bytes.\n\n    int overrun(int itemSize, int nItems) {\n      int len = ptr - start + itemSize * nItems;\n      if (len < (end - start) * 2)\n        len = (end - start) * 2;\n\n      U8* newStart = new U8[len];\n      memcpy(newStart, start, ptr - start);\n      ptr = newStart + (ptr - start);\n      delete [] start;\n      start = newStart;\n      end = newStart + len;\n\n      return nItems;\n    }\n\n    U8* start;\n  };\n\n}\n\n#endif\n", "/* Copyright (C) 2002-2003 RealVNC Ltd.  All Rights Reserved.\n *    \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n//\n// rdr::OutStream marshalls data into a buffer stored in RDR (RFB Data\n// Representation).\n//\n\n#ifndef __RDR_OUTSTREAM_H__\n#define __RDR_OUTSTREAM_H__\n\n#include <rdr/types.h>\n#include <rdr/InStream.h>\n#include <string.h> // for memcpy\n\nnamespace rdr {\n\n  class OutStream {\n\n  protected:\n\n    OutStream() {}\n\n  public:\n\n    virtual ~OutStream() {}\n\n    // check() ensures there is buffer space for at least one item of size\n    // itemSize bytes.  Returns the number of items which fit (up to a maximum\n    // of nItems).\n\n    inline int check(int itemSize, int nItems=1)\n    {\n      if (ptr + itemSize * nItems > end) {\n        if (ptr + itemSize > end)\n          return overrun(itemSize, nItems);\n\n        nItems = (end - ptr) / itemSize;\n      }\n      return nItems;\n    }\n\n    // writeU/SN() methods write unsigned and signed N-bit integers.\n\n    inline void writeU8( U8  u) { check(1); *ptr++ = u; }\n    inline void writeU16(U16 u) { check(2); *ptr++ = u >> 8; *ptr++ = (U8)u; }\n    inline void writeU32(U32 u) { check(4); *ptr++ = u >> 24; *ptr++ = u >> 16;\n                                            *ptr++ = u >> 8; *ptr++ = u; }\n\n    inline void writeS8( S8  s) { writeU8((U8)s); }\n    inline void writeS16(S16 s) { writeU16((U16)s); }\n    inline void writeS32(S32 s) { writeU32((U32)s); }\n\n    // writeString() writes a string - a U32 length followed by the data.  The\n    // given string should be null-terminated (but the terminating null is not\n    // written to the stream).\n\n    inline void writeString(const char* str) {\n      U32 len = strlen(str);\n      writeU32(len);\n      writeBytes(str, len);\n    }\n\n    inline void pad(int bytes) {\n      while (bytes-- > 0) writeU8(0);\n    }\n\n    inline void skip(int bytes) {\n      while (bytes > 0) {\n        int n = check(1, bytes);\n        ptr += n;\n        bytes -= n;\n      }\n    }\n\n    // writeBytes() writes an exact number of bytes.\n\n    void writeBytes(const void* data, int length) {\n      const U8* dataPtr = (const U8*)data;\n      const U8* dataEnd = dataPtr + length;\n      while (dataPtr < dataEnd) {\n        int n = check(1, dataEnd - dataPtr);\n        memcpy(ptr, dataPtr, n);\n        ptr += n;\n        dataPtr += n;\n      }\n    }\n\n    // copyBytes() efficiently transfers data between streams\n\n    void copyBytes(InStream* is, int length) {\n      while (length > 0) {\n        int n = check(1, length);\n        is->readBytes(ptr, n);\n        ptr += n;\n        length -= n;\n      }\n    }\n\n    // writeOpaqueN() writes a quantity without byte-swapping.\n\n    inline void writeOpaque8( U8  u) { writeU8(u); }\n    inline void writeOpaque16(U16 u) { check(2); *ptr++ = ((U8*)&u)[0];\n                                       *ptr++ = ((U8*)&u)[1]; }\n    inline void writeOpaque32(U32 u) { check(4); *ptr++ = ((U8*)&u)[0];\n                                       *ptr++ = ((U8*)&u)[1];\n                                       *ptr++ = ((U8*)&u)[2];\n                                       *ptr++ = ((U8*)&u)[3]; }\n\n    // length() returns the length of the stream.\n\n    virtual int length() = 0;\n\n    // flush() requests that the stream be flushed.\n\n    virtual void flush() {}\n\n    // getptr(), getend() and setptr() are \"dirty\" methods which allow you to\n    // manipulate the buffer directly.  This is useful for a stream which is a\n    // wrapper around an underlying stream.\n\n    inline U8* getptr() { return ptr; }\n    inline U8* getend() { return end; }\n    inline void setptr(U8* p) { ptr = p; }\n\n  private:\n\n    // overrun() is implemented by a derived class to cope with buffer overrun.\n    // It ensures there are at least itemSize bytes of buffer space.  Returns\n    // the number of items which fit (up to a maximum of nItems).  itemSize is\n    // supposed to be \"small\" (a few bytes).\n\n    virtual int overrun(int itemSize, int nItems) = 0;\n\n  protected:\n\n    U8* ptr;\n    U8* end;\n  };\n\n}\n\n#endif\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#include <rdr/RandomStream.h>\n#include <rdr/Exception.h>\n#include <rfb/LogWriter.h>\n#include <time.h>\n#include <stdlib.h>\n#ifndef WIN32\n#include <unistd.h>\n#include <errno.h>\n#else\n#define getpid() GetCurrentProcessId()\n#ifndef RFB_HAVE_WINCRYPT\n#pragma message(\"  NOTE: Not building WinCrypt-based RandomStream\")\n#endif\n#endif\n\nstatic rfb::LogWriter vlog(\"RandomStream\");\n\nusing namespace rdr;\n\nconst int DEFAULT_BUF_LEN = 256;\n\nunsigned int RandomStream::seed;\n\nRandomStream::RandomStream()\n  : offset(0)\n{\n  ptr = end = start = new U8[DEFAULT_BUF_LEN];\n\n#ifdef RFB_HAVE_WINCRYPT\n  provider = 0;\n  if (!CryptAcquireContext(&provider, 0, 0, PROV_RSA_FULL, 0)) {\n    if (GetLastError() == (DWORD)NTE_BAD_KEYSET) {\n      if (!CryptAcquireContext(&provider, 0, 0, PROV_RSA_FULL, CRYPT_NEWKEYSET)) {\n        vlog.error(\"unable to create keyset\");\n        provider = 0;\n      }\n    } else {\n      vlog.error(\"unable to acquire context\");\n      provider = 0;\n    }\n  }\n  if (!provider) {\n#else\n#ifndef WIN32\n  fp = fopen(\"/dev/urandom\", \"r\");\n  if (!fp)\n    fp = fopen(\"/dev/random\", \"r\");\n  if (!fp) {\n#else\n  {\n#endif\n#endif\n    vlog.error(\"no OS supplied random source - using rand()\");\n    seed += (unsigned int) time(0) + getpid() + getpid() * 987654 + rand();\n    srand(seed);\n  }\n}\n\nRandomStream::~RandomStream() {\n  delete [] start;\n\n#ifdef RFB_HAVE_WINCRYPT\n  if (provider)\n    CryptReleaseContext(provider, 0);\n#endif\n#ifndef WIN32\n  if (fp) fclose(fp);\n#endif\n}\n\nint RandomStream::pos() {\n  return offset + ptr - start;\n}\n\nint RandomStream::overrun(int itemSize, int nItems, bool wait) {\n  if (itemSize > DEFAULT_BUF_LEN)\n    throw Exception(\"RandomStream overrun: max itemSize exceeded\");\n\n  if (end - ptr != 0)\n    memmove(start, ptr, end - ptr);\n\n  end -= ptr - start;\n  offset += ptr - start;\n  ptr = start;\n\n  int length = start + DEFAULT_BUF_LEN - end;\n\n#ifdef RFB_HAVE_WINCRYPT\n  if (provider) {\n    if (!CryptGenRandom(provider, length, (U8*)end))\n      throw rdr::SystemException(\"unable to CryptGenRandom\", GetLastError());\n    end += length;\n  } else {\n#else\n#ifndef WIN32\n  if (fp) {\n    int n = fread((U8*)end, length, 1, fp);\n    if (n != 1)\n      throw rdr::SystemException(\"reading /dev/urandom or /dev/random failed\",\n                                 errno);\n    end += length;\n  } else {\n#else\n  {\n#endif\n#endif\n    for (int i=0; i<length; i++)\n      *(U8*)end++ = (int) (256.0*rand()/(RAND_MAX+1.0));\n  }\n\n  if (itemSize * nItems > end - ptr)\n    nItems = (end - ptr) / itemSize;\n\n  return nItems;\n}\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#ifndef __RDR_RANDOMSTREAM_H__\n#define __RDR_RANDOMSTREAM_H__\n\n#include <stdio.h>\n#include <rdr/InStream.h>\n\n#ifdef WIN32\n#include <windows.h>\n#include <wincrypt.h>\n#ifdef WINCRYPT32API\n#define RFB_HAVE_WINCRYPT\n#endif\n#endif\n\nnamespace rdr {\n\n  class RandomStream : public InStream {\n\n  public:\n\n    RandomStream();\n    virtual ~RandomStream();\n\n    int pos();\n\n  protected:\n    int overrun(int itemSize, int nItems, bool wait);\n\n  private:\n    U8* start;\n    int offset;\n\n    static unsigned int seed;\n#ifdef RFB_HAVE_WINCRYPT\n    HCRYPTPROV provider;\n#endif\n#ifndef WIN32\n    FILE* fp;\n#endif\n\n  };\n\n} // end of namespace rdr\n\n#endif\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * Copyright (C) 2005 Martin Koegler\n * Copyright (C) 2010 TigerVNC Team\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <rdr/Exception.h>\n#include <rdr/TLSException.h>\n#include <rdr/TLSInStream.h>\n#include <errno.h>\n\n#ifdef HAVE_GNUTLS \nusing namespace rdr;\n\nenum { DEFAULT_BUF_SIZE = 16384 };\n\nssize_t TLSInStream::pull(gnutls_transport_ptr_t str, void* data, size_t size)\n{\n  TLSInStream* self= (TLSInStream*) str;\n  InStream *in = self->in;\n\n  try {\n    if (!in->check(1, 1, false)) {\n      gnutls_transport_set_errno(self->session, EAGAIN);\n      return -1;\n    }\n\n    if (in->getend() - in->getptr() < (ptrdiff_t)size)\n      size = in->getend() - in->getptr();\n  \n    in->readBytes(data, size);\n\n  } catch (Exception& e) {\n    gnutls_transport_set_errno(self->session, EINVAL);\n    return -1;\n  }\n\n  return size;\n}\n\nTLSInStream::TLSInStream(InStream* _in, gnutls_session_t _session)\n  : session(_session), in(_in), bufSize(DEFAULT_BUF_SIZE), offset(0)\n{\n  gnutls_transport_ptr_t recv, send;\n\n  ptr = end = start = new U8[bufSize];\n\n  gnutls_transport_set_pull_function(session, pull);\n  gnutls_transport_get_ptr2(session, &recv, &send);\n  gnutls_transport_set_ptr2(session, this, send);\n}\n\nTLSInStream::~TLSInStream()\n{\n  gnutls_transport_set_pull_function(session, NULL);\n\n  delete[] start;\n}\n\nint TLSInStream::pos()\n{\n  return offset + ptr - start;\n}\n\nint TLSInStream::overrun(int itemSize, int nItems, bool wait)\n{\n  if (itemSize > bufSize)\n    throw Exception(\"TLSInStream overrun: max itemSize exceeded\");\n\n  if (end - ptr != 0)\n    memmove(start, ptr, end - ptr);\n\n  offset += ptr - start;\n  end -= ptr - start;\n  ptr = start;\n\n  while (end < start + itemSize) {\n    int n = readTLS((U8*) end, start + bufSize - end, wait);\n    if (!wait && n == 0)\n      return 0;\n    end += n;\n  }\n\n  if (itemSize * nItems > end - ptr)\n    nItems = (end - ptr) / itemSize;\n\n  return nItems;\n}\n\nint TLSInStream::readTLS(U8* buf, int len, bool wait)\n{\n  int n;\n\n  n = in->check(1, 1, wait);\n  if (n == 0)\n    return 0;\n\n  n = gnutls_record_recv(session, (void *) buf, len);\n  if (n == GNUTLS_E_INTERRUPTED || n == GNUTLS_E_AGAIN)\n    return 0;\n\n  if (n < 0) throw TLSException(\"readTLS\", n);\n\n  return n;\n}\n\n#endif\n", "/* Copyright (C) 2005 Martin Koegler\n * Copyright (C) 2010 TigerVNC Team\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#ifndef __RDR_TLSINSTREAM_H__\n#define __RDR_TLSINSTREAM_H__\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#ifdef HAVE_GNUTLS\n\n#include <gnutls/gnutls.h>\n#include <rdr/InStream.h>\n\nnamespace rdr {\n\n  class TLSInStream : public InStream {\n  public:\n    TLSInStream(InStream* in, gnutls_session_t session);\n    virtual ~TLSInStream();\n\n    int pos();\n\n  private:\n    int overrun(int itemSize, int nItems, bool wait);\n    int readTLS(U8* buf, int len, bool wait);\n    static ssize_t pull(gnutls_transport_ptr_t str, void* data, size_t size);\n\n    gnutls_session_t session;\n    InStream* in;\n    int bufSize;\n    int offset;\n    U8* start;\n  };\n};\n\n#endif\n#endif\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * Copyright (C) 2005 Martin Koegler\n * Copyright (C) 2010 TigerVNC Team\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <rdr/Exception.h>\n#include <rdr/TLSException.h>\n#include <rdr/TLSOutStream.h>\n#include <errno.h>\n\n#ifdef HAVE_GNUTLS\nusing namespace rdr;\n\nenum { DEFAULT_BUF_SIZE = 16384 };\n\nssize_t TLSOutStream::push(gnutls_transport_ptr_t str, const void* data,\n\t\t\t\t   size_t size)\n{\n  TLSOutStream* self= (TLSOutStream*) str;\n  OutStream *out = self->out;\n\n  try {\n    out->writeBytes(data, size);\n    out->flush();\n  } catch (Exception& e) {\n    gnutls_transport_set_errno(self->session, EINVAL);\n    return -1;\n  }\n\n  return size;\n}\n\nTLSOutStream::TLSOutStream(OutStream* _out, gnutls_session_t _session)\n  : session(_session), out(_out), bufSize(DEFAULT_BUF_SIZE), offset(0)\n{\n  gnutls_transport_ptr_t recv, send;\n\n  ptr = start = new U8[bufSize];\n  end = start + bufSize;\n\n  gnutls_transport_set_push_function(session, push);\n  gnutls_transport_get_ptr2(session, &recv, &send);\n  gnutls_transport_set_ptr2(session, recv, this);\n}\n\nTLSOutStream::~TLSOutStream()\n{\n#if 0\n  try {\n//    flush();\n  } catch (Exception&) {\n  }\n#endif\n  gnutls_transport_set_push_function(session, NULL);\n\n  delete [] start;\n}\n\nint TLSOutStream::length()\n{\n  return offset + ptr - start;\n}\n\nvoid TLSOutStream::flush()\n{\n  U8* sentUpTo = start;\n  while (sentUpTo < ptr) {\n    int n = writeTLS(sentUpTo, ptr - sentUpTo);\n    sentUpTo += n;\n    offset += n;\n  }\n\n  ptr = start;\n  out->flush();\n}\n\nint TLSOutStream::overrun(int itemSize, int nItems)\n{\n  if (itemSize > bufSize)\n    throw Exception(\"TLSOutStream overrun: max itemSize exceeded\");\n\n  flush();\n\n  if (itemSize * nItems > end - ptr)\n    nItems = (end - ptr) / itemSize;\n\n  return nItems;\n}\n\nint TLSOutStream::writeTLS(const U8* data, int length)\n{\n  int n;\n\n  n = gnutls_record_send(session, data, length);\n  if (n == GNUTLS_E_INTERRUPTED || n == GNUTLS_E_AGAIN)\n    return 0;\n\n  if (n < 0)\n    throw TLSException(\"writeTLS\", n);\n\n  return n;\n}\n\n#endif\n", "/* Copyright (C) 2005 Martin Koegler\n * Copyright (C) 2010 TigerVNC Team\n *\n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#ifndef __RDR_TLSOUTSTREAM_H__\n#define __RDR_TLSOUTSTREAM_H__\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#ifdef HAVE_GNUTLS\n#include <gnutls/gnutls.h>\n#include <rdr/OutStream.h>\n\nnamespace rdr {\n\n  class TLSOutStream : public OutStream {\n  public:\n    TLSOutStream(OutStream* out, gnutls_session_t session);\n    virtual ~TLSOutStream();\n\n    void flush();\n    int length();\n\n  protected:\n    int overrun(int itemSize, int nItems);\n\n  private:\n    int writeTLS(const U8* data, int length);\n    static ssize_t push(gnutls_transport_ptr_t str, const void* data, size_t size);\n\n    gnutls_session_t session;\n    OutStream* out;\n    int bufSize;\n    U8* start;\n    int offset;\n  };\n};\n\n#endif\n#endif\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#include <assert.h>\n\n#include <rdr/ZlibInStream.h>\n#include <rdr/Exception.h>\n#include <zlib.h>\n\nusing namespace rdr;\n\nenum { DEFAULT_BUF_SIZE = 16384 };\n\nZlibInStream::ZlibInStream(int bufSize_)\n  : underlying(0), bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0),\n    zs(NULL), bytesIn(0)\n{\n  ptr = end = start = new U8[bufSize];\n  init();\n}\n\nZlibInStream::~ZlibInStream()\n{\n  deinit();\n  delete [] start;\n}\n\nvoid ZlibInStream::setUnderlying(InStream* is, int bytesIn_)\n{\n  underlying = is;\n  bytesIn = bytesIn_;\n  ptr = end = start;\n}\n\nint ZlibInStream::pos()\n{\n  return offset + ptr - start;\n}\n\nvoid ZlibInStream::flushUnderlying()\n{\n  ptr = end = start;\n\n  while (bytesIn > 0) {\n    decompress(true);\n    end = start; // throw away any data\n  }\n\n  setUnderlying(NULL, 0);\n}\n\nvoid ZlibInStream::reset()\n{\n  deinit();\n  init();\n}\n\nvoid ZlibInStream::init()\n{\n  assert(zs == NULL);\n\n  zs = new z_stream;\n  zs->zalloc    = Z_NULL;\n  zs->zfree     = Z_NULL;\n  zs->opaque    = Z_NULL;\n  zs->next_in   = Z_NULL;\n  zs->avail_in  = 0;\n  if (inflateInit(zs) != Z_OK) {\n    delete zs;\n    zs = NULL;\n    throw Exception(\"ZlibInStream: inflateInit failed\");\n  }\n}\n\nvoid ZlibInStream::deinit()\n{\n  assert(zs != NULL);\n  setUnderlying(NULL, 0);\n  inflateEnd(zs);\n  delete zs;\n  zs = NULL;\n}\n\nint ZlibInStream::overrun(int itemSize, int nItems, bool wait)\n{\n  if (itemSize > bufSize)\n    throw Exception(\"ZlibInStream overrun: max itemSize exceeded\");\n\n  if (end - ptr != 0)\n    memmove(start, ptr, end - ptr);\n\n  offset += ptr - start;\n  end -= ptr - start;\n  ptr = start;\n\n  while (end - ptr < itemSize) {\n    if (!decompress(wait))\n      return 0;\n  }\n\n  if (itemSize * nItems > end - ptr)\n    nItems = (end - ptr) / itemSize;\n\n  return nItems;\n}\n\n// decompress() calls the decompressor once.  Note that this won't necessarily\n// generate any output data - it may just consume some input data.  Returns\n// false if wait is false and we would block on the underlying stream.\n\nbool ZlibInStream::decompress(bool wait)\n{\n  if (!underlying)\n    throw Exception(\"ZlibInStream overrun: no underlying stream\");\n\n  zs->next_out = (U8*)end;\n  zs->avail_out = start + bufSize - end;\n\n  int n = underlying->check(1, 1, wait);\n  if (n == 0) return false;\n  zs->next_in = (U8*)underlying->getptr();\n  zs->avail_in = underlying->getend() - underlying->getptr();\n  if ((int)zs->avail_in > bytesIn)\n    zs->avail_in = bytesIn;\n\n  int rc = inflate(zs, Z_SYNC_FLUSH);\n  if (rc != Z_OK) {\n    throw Exception(\"ZlibInStream: inflate failed\");\n  }\n\n  bytesIn -= zs->next_in - underlying->getptr();\n  end = zs->next_out;\n  underlying->setptr(zs->next_in);\n  return true;\n}\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n//\n// ZlibInStream streams from a compressed data stream (\"underlying\"),\n// decompressing with zlib on the fly.\n//\n\n#ifndef __RDR_ZLIBINSTREAM_H__\n#define __RDR_ZLIBINSTREAM_H__\n\n#include <rdr/InStream.h>\n\nstruct z_stream_s;\n\nnamespace rdr {\n\n  class ZlibInStream : public InStream {\n\n  public:\n\n    ZlibInStream(int bufSize=0);\n    virtual ~ZlibInStream();\n\n    void setUnderlying(InStream* is, int bytesIn);\n    void flushUnderlying();\n    int pos();\n    void reset();\n\n  private:\n\n    void init();\n    void deinit();\n\n    int overrun(int itemSize, int nItems, bool wait);\n    bool decompress(bool wait);\n\n    InStream* underlying;\n    int bufSize;\n    int offset;\n    z_stream_s* zs;\n    int bytesIn;\n    U8* start;\n  };\n\n} // end of namespace rdr\n\n#endif\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * Copyright (C) 2011 D. R. Commander.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#include <stdio.h>\n\n#include <rdr/ZlibOutStream.h>\n#include <rdr/Exception.h>\n#include <rfb/LogWriter.h>\n\n#include <zlib.h>\n\n#undef ZLIBOUT_DEBUG\n\nstatic rfb::LogWriter vlog(\"ZlibOutStream\");\n\nusing namespace rdr;\n\nenum { DEFAULT_BUF_SIZE = 16384 };\n\nZlibOutStream::ZlibOutStream(OutStream* os, int bufSize_, int compressLevel)\n  : underlying(os), compressionLevel(compressLevel), newLevel(compressLevel),\n    bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0)\n{\n  zs = new z_stream;\n  zs->zalloc    = Z_NULL;\n  zs->zfree     = Z_NULL;\n  zs->opaque    = Z_NULL;\n  zs->next_in   = Z_NULL;\n  zs->avail_in  = 0;\n  if (deflateInit(zs, compressLevel) != Z_OK) {\n    delete zs;\n    throw Exception(\"ZlibOutStream: deflateInit failed\");\n  }\n  ptr = start = new U8[bufSize];\n  end = start + bufSize;\n}\n\nZlibOutStream::~ZlibOutStream()\n{\n  try {\n    flush();\n  } catch (Exception&) {\n  }\n  delete [] start;\n  deflateEnd(zs);\n  delete zs;\n}\n\nvoid ZlibOutStream::setUnderlying(OutStream* os)\n{\n  underlying = os;\n}\n\nvoid ZlibOutStream::setCompressionLevel(int level)\n{\n  if (level < -1 || level > 9)\n    level = -1;                 // Z_DEFAULT_COMPRESSION\n\n  newLevel = level;\n}\n\nint ZlibOutStream::length()\n{\n  return offset + ptr - start;\n}\n\nvoid ZlibOutStream::flush()\n{\n  checkCompressionLevel();\n\n  zs->next_in = start;\n  zs->avail_in = ptr - start;\n\n#ifdef ZLIBOUT_DEBUG\n  vlog.debug(\"flush: avail_in %d\",zs->avail_in);\n#endif\n\n  // Force out everything from the zlib encoder\n  deflate(Z_SYNC_FLUSH);\n\n  offset += ptr - start;\n  ptr = start;\n}\n\nint ZlibOutStream::overrun(int itemSize, int nItems)\n{\n#ifdef ZLIBOUT_DEBUG\n  vlog.debug(\"overrun\");\n#endif\n\n  if (itemSize > bufSize)\n    throw Exception(\"ZlibOutStream overrun: max itemSize exceeded\");\n\n  checkCompressionLevel();\n\n  while (end - ptr < itemSize) {\n    zs->next_in = start;\n    zs->avail_in = ptr - start;\n\n    deflate(Z_NO_FLUSH);\n\n    // output buffer not full\n\n    if (zs->avail_in == 0) {\n      offset += ptr - start;\n      ptr = start;\n    } else {\n      // but didn't consume all the data?  try shifting what's left to the\n      // start of the buffer.\n      vlog.info(\"z out buf not full, but in data not consumed\");\n      memmove(start, zs->next_in, ptr - zs->next_in);\n      offset += zs->next_in - start;\n      ptr -= zs->next_in - start;\n    }\n  }\n\n  if (itemSize * nItems > end - ptr)\n    nItems = (end - ptr) / itemSize;\n\n  return nItems;\n}\n\nvoid ZlibOutStream::deflate(int flush)\n{\n  int rc;\n\n  if (!underlying)\n    throw Exception(\"ZlibOutStream: underlying OutStream has not been set\");\n\n  if ((flush == Z_NO_FLUSH) && (zs->avail_in == 0))\n    return;\n\n  do {\n    underlying->check(1);\n    zs->next_out = underlying->getptr();\n    zs->avail_out = underlying->getend() - underlying->getptr();\n\n#ifdef ZLIBOUT_DEBUG\n    vlog.debug(\"calling deflate, avail_in %d, avail_out %d\",\n               zs->avail_in,zs->avail_out);\n#endif\n\n    rc = ::deflate(zs, flush);\n    if (rc != Z_OK) {\n      // Silly zlib returns an error if you try to flush something twice\n      if ((rc == Z_BUF_ERROR) && (flush != Z_NO_FLUSH))\n        break;\n\n      throw Exception(\"ZlibOutStream: deflate failed\");\n    }\n\n#ifdef ZLIBOUT_DEBUG\n    vlog.debug(\"after deflate: %d bytes\",\n               zs->next_out-underlying->getptr());\n#endif\n\n    underlying->setptr(zs->next_out);\n  } while (zs->avail_out == 0);\n}\n\nvoid ZlibOutStream::checkCompressionLevel()\n{\n  int rc;\n\n  if (newLevel != compressionLevel) {\n#ifdef ZLIBOUT_DEBUG\n    vlog.debug(\"change: avail_in %d\",zs->avail_in);\n#endif\n\n    // zlib is just horribly stupid. It does an implicit flush on\n    // parameter changes, but the flush it does is not one that forces\n    // out all the data. And since you cannot flush things again, we\n    // cannot force out our data after the parameter change. Hence we\n    // need to do a more proper flush here first.\n    deflate(Z_SYNC_FLUSH);\n\n    rc = deflateParams (zs, newLevel, Z_DEFAULT_STRATEGY);\n    if (rc != Z_OK) {\n      // The implicit flush can result in this error, caused by the\n      // explicit flush we did above. It should be safe to ignore though\n      // as the first flush should have left things in a stable state...\n      if (rc != Z_BUF_ERROR)\n        throw Exception(\"ZlibOutStream: deflateParams failed\");\n    }\n\n    compressionLevel = newLevel;\n  }\n}\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * Copyright (C) 2011 D. R. Commander.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n//\n// ZlibOutStream streams to a compressed data stream (underlying), compressing\n// with zlib on the fly.\n//\n\n#ifndef __RDR_ZLIBOUTSTREAM_H__\n#define __RDR_ZLIBOUTSTREAM_H__\n\n#include <rdr/OutStream.h>\n\nstruct z_stream_s;\n\nnamespace rdr {\n\n  class ZlibOutStream : public OutStream {\n\n  public:\n\n    ZlibOutStream(OutStream* os=0, int bufSize=0, int compressionLevel=-1);\n    virtual ~ZlibOutStream();\n\n    void setUnderlying(OutStream* os);\n    void setCompressionLevel(int level=-1);\n    void flush();\n    int length();\n\n  private:\n\n    int overrun(int itemSize, int nItems);\n    void deflate(int flush);\n    void checkCompressionLevel();\n\n    OutStream* underlying;\n    int compressionLevel;\n    int newLevel;\n    int bufSize;\n    int offset;\n    z_stream_s* zs;\n    U8* start;\n  };\n\n} // end of namespace rdr\n\n#endif\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * Copyright 2004-2005 Cendio AB.\n * Copyright 2017 Peter Astrand <astrand@cendio.se> for Cendio AB\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n// -=- Configuration.cxx\n\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n\n#include <os/Mutex.h>\n\n#include <rfb/util.h>\n#include <rfb/Configuration.h>\n#include <rfb/LogWriter.h>\n#include <rfb/Exception.h>\n\n#define LOCK_CONFIG os::AutoMutex a(mutex)\n\n#include <rdr/HexOutStream.h>\n#include <rdr/HexInStream.h>\n\nusing namespace rfb;\n\nstatic LogWriter vlog(\"Config\");\n\n\n// -=- The Global/server/viewer Configuration objects\nConfiguration* Configuration::global_ = 0;\nConfiguration* Configuration::server_ = 0;\nConfiguration* Configuration::viewer_ = 0;\n\nConfiguration* Configuration::global() {\n  if (!global_)\n    global_ = new Configuration(\"Global\");\n  return global_;\n}\n\nConfiguration* Configuration::server() {\n  if (!server_)\n    server_ = new Configuration(\"Server\");\n  return server_;\n}\n\nConfiguration* Configuration::viewer() {\n  if (!viewer_)\n    viewer_ = new Configuration(\"Viewer\");\n  return viewer_;\n}\n\n// -=- Configuration implementation\n\nbool Configuration::set(const char* n, const char* v, bool immutable) {\n  return set(n, strlen(n), v, immutable);\n}\n\nbool Configuration::set(const char* name, int len,\n                             const char* val, bool immutable)\n{\n  VoidParameter* current = head;\n  while (current) {\n    if ((int)strlen(current->getName()) == len &&\n        strncasecmp(current->getName(), name, len) == 0)\n    {\n      bool b = current->setParam(val);\n      if (b && immutable) \n\tcurrent->setImmutable();\n      return b;\n    }\n    current = current->_next;\n  }\n  return _next ? _next->set(name, len, val, immutable) : false;\n}\n\nbool Configuration::set(const char* config, bool immutable) {\n  bool hyphen = false;\n  if (config[0] == '-') {\n    hyphen = true;\n    config++;\n    if (config[0] == '-') config++; // allow gnu-style --<option>\n  }\n  const char* equal = strchr(config, '=');\n  if (equal) {\n    return set(config, equal-config, equal+1, immutable);\n  } else if (hyphen) {\n    VoidParameter* current = head;\n    while (current) {\n      if (strcasecmp(current->getName(), config) == 0) {\n        bool b = current->setParam();\n        if (b && immutable) \n\t  current->setImmutable();\n        return b;\n      }\n      current = current->_next;\n    }\n  }    \n  return _next ? _next->set(config, immutable) : false;\n}\n\nVoidParameter* Configuration::get(const char* param)\n{\n  VoidParameter* current = head;\n  while (current) {\n    if (strcasecmp(current->getName(), param) == 0)\n      return current;\n    current = current->_next;\n  }\n  return _next ? _next->get(param) : 0;\n}\n\nvoid Configuration::list(int width, int nameWidth) {\n  VoidParameter* current = head;\n\n  fprintf(stderr, \"%s Parameters:\\n\", name.buf);\n  while (current) {\n    char* def_str = current->getDefaultStr();\n    const char* desc = current->getDescription();\n    fprintf(stderr,\"  %-*s -\", nameWidth, current->getName());\n    int column = strlen(current->getName());\n    if (column < nameWidth) column = nameWidth;\n    column += 4;\n    while (true) {\n      const char* s = strchr(desc, ' ');\n      int wordLen;\n      if (s) wordLen = s-desc;\n      else wordLen = strlen(desc);\n\n      if (column + wordLen + 1 > width) {\n        fprintf(stderr,\"\\n%*s\",nameWidth+4,\"\");\n        column = nameWidth+4;\n      }\n      fprintf(stderr,\" %.*s\",wordLen,desc);\n      column += wordLen + 1;\n      desc += wordLen + 1;\n      if (!s) break;\n    }\n\n    if (def_str) {\n      if (column + (int)strlen(def_str) + 11 > width)\n        fprintf(stderr,\"\\n%*s\",nameWidth+4,\"\");\n      fprintf(stderr,\" (default=%s)\\n\",def_str);\n      strFree(def_str);\n    } else {\n      fprintf(stderr,\"\\n\");\n    }\n    current = current->_next;\n  }\n\n  if (_next)\n    _next->list(width, nameWidth);\n}\n\n\nbool Configuration::remove(const char* param) {\n  VoidParameter *current = head;\n  VoidParameter **prevnext = &head;\n\n  while (current) {\n    if (strcasecmp(current->getName(), param) == 0) {\n      *prevnext = current->_next;\n      return true;\n    }\n    prevnext = &current->_next;\n    current = current->_next;\n  }\n\n  return false;\n}\n\n\n// -=- VoidParameter\n\nVoidParameter::VoidParameter(const char* name_, const char* desc_,\n\t\t\t     ConfigurationObject co)\n  : immutable(false), name(name_), description(desc_)\n{\n  Configuration *conf = NULL;\n\n  switch (co) {\n  case ConfGlobal: conf = Configuration::global();\n    break;\n  case ConfServer: conf = Configuration::server();\n    break;\n  case ConfViewer: conf = Configuration::viewer();\n    break;\n  }\n\n  _next = conf->head;\n  conf->head = this;\n\n  mutex = new os::Mutex();\n}\n\nVoidParameter::~VoidParameter() {\n  delete mutex;\n}\n\nconst char*\nVoidParameter::getName() const {\n  return name;\n}\n\nconst char*\nVoidParameter::getDescription() const {\n  return description;\n}\n\nbool VoidParameter::setParam() {\n  return false;\n}\n\nbool VoidParameter::isBool() const {\n  return false;\n}\n\nvoid\nVoidParameter::setImmutable() {\n  vlog.debug(\"set immutable %s\", getName());\n  immutable = true;\n}\n\n// -=- AliasParameter\n\nAliasParameter::AliasParameter(const char* name_, const char* desc_,\n                               VoidParameter* param_, ConfigurationObject co)\n  : VoidParameter(name_, desc_, co), param(param_) {\n}\n\nbool\nAliasParameter::setParam(const char* v) {\n  return param->setParam(v);\n}\n\nbool AliasParameter::setParam() {\n  return param->setParam();\n}\n\nchar*\nAliasParameter::getDefaultStr() const {\n  return 0;\n}\n\nchar* AliasParameter::getValueStr() const {\n  return param->getValueStr();\n}\n\nbool AliasParameter::isBool() const {\n  return param->isBool();\n}\n\nvoid\nAliasParameter::setImmutable() {\n  vlog.debug(\"set immutable %s (Alias)\", getName());\n  param->setImmutable();\n}\n\n\n// -=- BoolParameter\n\nBoolParameter::BoolParameter(const char* name_, const char* desc_, bool v,\n\t\t\t     ConfigurationObject co)\n: VoidParameter(name_, desc_, co), value(v), def_value(v) {\n}\n\nbool\nBoolParameter::setParam(const char* v) {\n  if (immutable) return true;\n\n  if (*v == 0 || strcasecmp(v, \"1\") == 0 || strcasecmp(v, \"on\") == 0\n      || strcasecmp(v, \"true\") == 0 || strcasecmp(v, \"yes\") == 0)\n    value = 1;\n  else if (strcasecmp(v, \"0\") == 0 || strcasecmp(v, \"off\") == 0\n           || strcasecmp(v, \"false\") == 0 || strcasecmp(v, \"no\") == 0)\n    value = 0;\n  else {\n    vlog.error(\"Bool parameter %s: invalid value '%s'\", getName(), v);\n    return false;\n  }\n\n  vlog.debug(\"set %s(Bool) to %s(%d)\", getName(), v, value);\n  return true;\n}\n\nbool BoolParameter::setParam() {\n  setParam(true);\n  return true;\n}\n\nvoid BoolParameter::setParam(bool b) {\n  if (immutable) return;\n  value = b;\n  vlog.debug(\"set %s(Bool) to %d\", getName(), value);\n}\n\nchar*\nBoolParameter::getDefaultStr() const {\n  return strDup(def_value ? \"1\" : \"0\");\n}\n\nchar* BoolParameter::getValueStr() const {\n  return strDup(value ? \"1\" : \"0\");\n}\n\nbool BoolParameter::isBool() const {\n  return true;\n}\n\nBoolParameter::operator bool() const {\n  return value;\n}\n\n// -=- IntParameter\n\nIntParameter::IntParameter(const char* name_, const char* desc_, int v,\n                           int minValue_, int maxValue_, ConfigurationObject co)\n  : VoidParameter(name_, desc_, co), value(v), def_value(v),\n    minValue(minValue_), maxValue(maxValue_)\n{\n}\n\nbool\nIntParameter::setParam(const char* v) {\n  if (immutable) return true;\n  vlog.debug(\"set %s(Int) to %s\", getName(), v);\n  int i = strtol(v, NULL, 0);\n  if (i < minValue || i > maxValue)\n    return false;\n  value = i;\n  return true;\n}\n\nbool\nIntParameter::setParam(int v) {\n  if (immutable) return true;\n  vlog.debug(\"set %s(Int) to %d\", getName(), v);\n  if (v < minValue || v > maxValue)\n    return false;\n  value = v;\n  return true;\n}\n\nchar*\nIntParameter::getDefaultStr() const {\n  char* result = new char[16];\n  sprintf(result, \"%d\", def_value);\n  return result;\n}\n\nchar* IntParameter::getValueStr() const {\n  char* result = new char[16];\n  sprintf(result, \"%d\", value);\n  return result;\n}\n\nIntParameter::operator int() const {\n  return value;\n}\n\n// -=- StringParameter\n\nStringParameter::StringParameter(const char* name_, const char* desc_,\n                                 const char* v, ConfigurationObject co)\n  : VoidParameter(name_, desc_, co), value(strDup(v)), def_value(v)\n{\n  if (!v) {\n    vlog.error(\"Default value <null> for %s not allowed\",name_);\n    throw rfb::Exception(\"Default value <null> not allowed\");\n  }\n}\n\nStringParameter::~StringParameter() {\n  strFree(value);\n}\n\nvoid StringParameter::setDefaultStr(const char* v) {\n  def_value = v;\n  strFree(value);\n  value = strDup(v);\n}\n\nbool StringParameter::setParam(const char* v) {\n  LOCK_CONFIG;\n  if (immutable) return true;\n  if (!v)\n    throw rfb::Exception(\"setParam(<null>) not allowed\");\n  vlog.debug(\"set %s(String) to %s\", getName(), v);\n  CharArray oldValue(value);\n  value = strDup(v);\n  return value != 0;\n}\n\nchar* StringParameter::getDefaultStr() const {\n  return strDup(def_value);\n}\n\nchar* StringParameter::getValueStr() const {\n  LOCK_CONFIG;\n  return strDup(value);\n}\n\nStringParameter::operator const char *() const {\n  return value;\n}\n\n// -=- BinaryParameter\n\nBinaryParameter::BinaryParameter(const char* name_, const char* desc_,\n\t\t\t\t const void* v, int l, ConfigurationObject co)\n: VoidParameter(name_, desc_, co), value(0), length(0), def_value((char*)v), def_length(l) {\n  if (l) {\n    value = new char[l];\n    length = l;\n    memcpy(value, v, l);\n  }\n}\nBinaryParameter::~BinaryParameter() {\n  if (value)\n    delete [] value;\n}\n\nbool BinaryParameter::setParam(const char* v) {\n  LOCK_CONFIG;\n  if (immutable) return true;\n  vlog.debug(\"set %s(Binary) to %s\", getName(), v);\n  return rdr::HexInStream::hexStrToBin(v, &value, &length);\n}\n\nvoid BinaryParameter::setParam(const void* v, int len) {\n  LOCK_CONFIG;\n  if (immutable) return; \n  vlog.debug(\"set %s(Binary)\", getName());\n  delete [] value; value = 0;\n  if (len) {\n    value = new char[len];\n    length = len;\n    memcpy(value, v, len);\n  }\n}\n\nchar* BinaryParameter::getDefaultStr() const {\n  return rdr::HexOutStream::binToHexStr(def_value, def_length);\n}\n\nchar* BinaryParameter::getValueStr() const {\n  LOCK_CONFIG;\n  return rdr::HexOutStream::binToHexStr(value, length);\n}\n\nvoid BinaryParameter::getData(void** data_, int* length_) const {\n  LOCK_CONFIG;\n  if (length_) *length_ = length;\n  if (data_) {\n    *data_ = new char[length];\n    memcpy(*data_, value, length);\n  }\n}\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n// -=- Configuration.h\n//\n// This header defines a set of classes used to represent configuration\n// parameters of different types.  Instances of the different parameter\n// types are associated with instances of the Configuration class, and\n// are each given a unique name.  The Configuration class provides a\n// generic API through which parameters may be located by name and their\n// value set, thus removing the need to write platform-specific code.\n// Simply defining a new parameter and associating it with a Configuration\n// will allow it to be configured by the user.\n//\n// If no Configuration is specified when creating a Parameter, then the\n// global Configuration will be assumed.\n//\n// Configurations can be \"chained\" into groups.  Each group has a root\n// Configuration, a pointer to which should be passed to the constructors\n// of the other group members.  set() and get() operations called on the\n// root will iterate through all of the group's members.\n//\n// NB: On platforms that support Threading, locking is performed to protect\n//     complex parameter types from concurrent access (e.g. strings).\n// NB: NO LOCKING is performed when linking Configurations to groups\n//     or when adding Parameters to Configurations.\n\n#ifndef __RFB_CONFIGURATION_H__\n#define __RFB_CONFIGURATION_H__\n\n#include <rfb/util.h>\n\nnamespace os { class Mutex; }\n\nnamespace rfb {\n  class VoidParameter;\n  struct ParameterIterator;\n\n  enum ConfigurationObject { ConfGlobal, ConfServer, ConfViewer };\n\n  // -=- Configuration\n  //     Class used to access parameters.\n\n  class Configuration {\n  public:\n    // - Create a new Configuration object\n    Configuration(const char* name_) : name(strDup(name_)), head(0), _next(0) {}\n\n    // - Return the buffer containing the Configuration's name\n    const char* getName() const { return name.buf; }\n\n    // - Set named parameter to value\n    bool set(const char* param, const char* value, bool immutable=false);\n\n    // - Set parameter to value (separated by \"=\")\n    bool set(const char* config, bool immutable=false);\n\n    // - Set named parameter to value, with name truncated at len\n    bool set(const char* name, int len,\n                  const char* val, bool immutable);\n\n    // - Get named parameter\n    VoidParameter* get(const char* param);\n\n    // - List the parameters of this Configuration group\n    void list(int width=79, int nameWidth=10);\n\n    // - Remove a parameter from this Configuration group\n    bool remove(const char* param);\n\n    // - readFromFile\n    //   Read configuration parameters from the specified file.\n    void readFromFile(const char* filename);\n\n    // - writeConfigToFile\n    //   Write a new configuration parameters file, then mv it\n    //   over the old file.\n    void writeToFile(const char* filename);\n\n\n    // - Get the Global Configuration object\n    //   NB: This call does NOT lock the Configuration system.\n    //       ALWAYS ensure that if you have ANY global Parameters,\n    //       then they are defined as global objects, to ensure that\n    //       global() is called when only the main thread is running.\n    static Configuration* global();\n\n    // Enable server/viewer specific parameters\n    static void enableServerParams() { global()->appendConfiguration(server()); }\n    static void enableViewerParams() { global()->appendConfiguration(viewer()); }\n\n    // - Container for process-wide Global parameters\n    static bool setParam(const char* param, const char* value, bool immutable=false) {\n      return global()->set(param, value, immutable);\n    }\n    static bool setParam(const char* config, bool immutable=false) { \n      return global()->set(config, immutable);\n    }\n    static bool setParam(const char* name, int len,\n      const char* val, bool immutable) {\n      return global()->set(name, len, val, immutable);\n    }\n    static VoidParameter* getParam(const char* param) { return global()->get(param); }\n    static void listParams(int width=79, int nameWidth=10) {\n      global()->list(width, nameWidth);\n    }\n    static bool removeParam(const char* param) {\n      return global()->remove(param);\n    }\n\n  private:\n    friend class VoidParameter;\n    friend struct ParameterIterator;\n\n    // Name for this Configuration\n    CharArray name;\n\n    // - Pointer to first Parameter in this group\n    VoidParameter* head;\n\n    // Pointer to next Configuration in this group\n    Configuration* _next;\n\n    // The process-wide, Global Configuration object\n    static Configuration* global_;\n\n    // The server only Configuration object\n    static Configuration* server_;\n\n    // The viewer only Configuration object\n    static Configuration* viewer_;\n\n    // Get server/viewer specific configuration object\n    static Configuration* server();\n    static Configuration* viewer();\n\n    // Append configuration object to this instance.\n    // NOTE: conf instance can be only one configuration object\n    void appendConfiguration(Configuration *conf) {\n      conf->_next = _next; _next = conf;\n    }\n  };\n\n  // -=- VoidParameter\n  //     Configuration parameter base-class.\n\n  class VoidParameter {\n  public:\n    VoidParameter(const char* name_, const char* desc_, ConfigurationObject co=ConfGlobal);\n    virtual  ~VoidParameter();\n    const char* getName() const;\n    const char* getDescription() const;\n\n    virtual bool setParam(const char* value)  = 0;\n    virtual bool setParam();\n    virtual char* getDefaultStr() const = 0;\n    virtual char* getValueStr() const = 0;\n    virtual bool isBool() const;\n\n    virtual void setImmutable();\n\n  protected:\n    friend class Configuration;\n    friend struct ParameterIterator;\n\n    VoidParameter* _next;\n    bool immutable;\n    const char* name;\n    const char* description;\n\n    os::Mutex* mutex;\n  };\n\n  class AliasParameter : public VoidParameter {\n  public:\n    AliasParameter(const char* name_, const char* desc_,VoidParameter* param_,\n\t\t   ConfigurationObject co=ConfGlobal);\n    virtual bool setParam(const char* value);\n    virtual bool setParam();\n    virtual char* getDefaultStr() const;\n    virtual char* getValueStr() const;\n    virtual bool isBool() const;\n    virtual void setImmutable();\n  private:\n    VoidParameter* param;\n  };\n\n  class BoolParameter : public VoidParameter {\n  public:\n    BoolParameter(const char* name_, const char* desc_, bool v,\n\t\t  ConfigurationObject co=ConfGlobal);\n    virtual bool setParam(const char* value);\n    virtual bool setParam();\n    virtual void setParam(bool b);\n    virtual char* getDefaultStr() const;\n    virtual char* getValueStr() const;\n    virtual bool isBool() const;\n    operator bool() const;\n  protected:\n    bool value;\n    bool def_value;\n  };\n\n  class IntParameter : public VoidParameter {\n  public:\n    IntParameter(const char* name_, const char* desc_, int v,\n                 int minValue=INT_MIN, int maxValue=INT_MAX,\n\t\t ConfigurationObject co=ConfGlobal);\n    using VoidParameter::setParam;\n    virtual bool setParam(const char* value);\n    virtual bool setParam(int v);\n    virtual char* getDefaultStr() const;\n    virtual char* getValueStr() const;\n    operator int() const;\n  protected:\n    int value;\n    int def_value;\n    int minValue, maxValue;\n  };\n\n  class StringParameter : public VoidParameter {\n  public:\n    // StringParameter contains a null-terminated string, which CANNOT\n    // be Null, and so neither can the default value!\n    StringParameter(const char* name_, const char* desc_, const char* v,\n\t\t    ConfigurationObject co=ConfGlobal);\n    virtual ~StringParameter();\n    virtual bool setParam(const char* value);\n    virtual char* getDefaultStr() const;\n    virtual char* getValueStr() const;\n    void setDefaultStr(const char* v);\n    operator const char*() const;\n\n    // getData() returns a copy of the data - it must be delete[]d by the\n    // caller.\n    char* getData() const { return getValueStr(); }\n  protected:\n    char* value;\n    const char* def_value;\n  };\n\n  class BinaryParameter : public VoidParameter {\n  public:\n    BinaryParameter(const char* name_, const char* desc_, const void* v, int l,\n\t\t    ConfigurationObject co=ConfGlobal);\n    using VoidParameter::setParam;\n    virtual ~BinaryParameter();\n    virtual bool setParam(const char* value);\n    virtual void setParam(const void* v, int l);\n    virtual char* getDefaultStr() const;\n    virtual char* getValueStr() const;\n\n    // getData() will return length zero if there is no data\n    // NB: data may be set to zero, OR set to a zero-length buffer\n    void getData(void** data, int* length) const;\n\n  protected:\n    char* value;\n    int length;\n    char* def_value;\n    int def_length;\n  };\n\n  // -=- ParameterIterator\n  //     Iterates over all enabled parameters (global + server/viewer).\n  //     Current Parameter is accessed via param, the current Configuration\n  //     via config. The next() method moves on to the next Parameter.\n\n  struct ParameterIterator {\n    ParameterIterator() : config(Configuration::global()), param(config->head) {}\n    void next() {\n      param = param->_next;\n      while (!param) {\n        config = config->_next;\n        if (!config) break;\n        param = config->head;\n      }\n    }\n    Configuration* config;\n    VoidParameter* param;\n  };\n\n};\n\n#endif // __RFB_CONFIGURATION_H__\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n//\n// XXX not thread-safe, because d3des isn't - do we need to worry about this?\n//\n\n#include <string.h>\nextern \"C\" {\n#include <rfb/d3des.h>\n}\n#include <rdr/types.h>\n#include <rdr/Exception.h>\n#include <rfb/Password.h>\n\nusing namespace rfb;\n\nstatic unsigned char d3desObfuscationKey[] = {23,82,107,6,35,78,88,7};\n\n\nPlainPasswd::PlainPasswd() {}\n\nPlainPasswd::PlainPasswd(char* pwd) : CharArray(pwd) {\n}\n\nPlainPasswd::PlainPasswd(int len) : CharArray(len) {\n}\n\nPlainPasswd::PlainPasswd(const ObfuscatedPasswd& obfPwd) : CharArray(9) {\n  if (obfPwd.length < 8)\n    throw rdr::Exception(\"bad obfuscated password length\");\n  deskey(d3desObfuscationKey, DE1);\n  des((rdr::U8*)obfPwd.buf, (rdr::U8*)buf);\n  buf[8] = 0;\n}\n\nPlainPasswd::~PlainPasswd() {\n  replaceBuf(0);\n}\n\nvoid PlainPasswd::replaceBuf(char* b) {\n  if (buf)\n    memset(buf, 0, strlen(buf));\n  CharArray::replaceBuf(b);\n}\n\n\nObfuscatedPasswd::ObfuscatedPasswd() : length(0) {\n}\n\nObfuscatedPasswd::ObfuscatedPasswd(int len) : CharArray(len), length(len) {\n}\n\nObfuscatedPasswd::ObfuscatedPasswd(const PlainPasswd& plainPwd) : CharArray(8), length(8) {\n  int l = strlen(plainPwd.buf), i;\n  for (i=0; i<8; i++)\n    buf[i] = i<l ? plainPwd.buf[i] : 0;\n  deskey(d3desObfuscationKey, EN0);\n  des((rdr::U8*)buf, (rdr::U8*)buf);\n}\n\nObfuscatedPasswd::~ObfuscatedPasswd() {\n  if (buf)\n    memset(buf, 0, length);\n}\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n#ifndef __RFB_PASSWORD_H__\n#define __RFB_PASSWORD_H__\n\n#include <rfb/util.h>\n\nnamespace rfb {\n\n  class ObfuscatedPasswd;\n\n  class PlainPasswd : public CharArray {\n  public:\n    PlainPasswd();\n    PlainPasswd(char* pwd);\n    PlainPasswd(int len);\n    PlainPasswd(const ObfuscatedPasswd& obfPwd);\n    ~PlainPasswd();\n    void replaceBuf(char* b);\n  };\n\n  class ObfuscatedPasswd : public CharArray {\n  public:\n    ObfuscatedPasswd();\n    ObfuscatedPasswd(int l);\n    ObfuscatedPasswd(const PlainPasswd& plainPwd);\n    ~ObfuscatedPasswd();\n    int length;\n  };\n\n}\n#endif\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * Copyright 2011-2019 Pierre Ossman for Cendio AB\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n//\n// util.h - miscellaneous useful bits\n//\n\n#ifndef __RFB_UTIL_H__\n#define __RFB_UTIL_H__\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <limits.h>\n#include <string.h>\n\nstruct timeval;\n\n#ifdef __GNUC__\n#  define __printf_attr(a, b) __attribute__((__format__ (__printf__, a, b)))\n#else\n#  define __printf_attr(a, b)\n#endif // __GNUC__\n\n#ifndef __unused_attr\n#  define __unused_attr __attribute((__unused__))\n#endif\n\nnamespace rfb {\n\n  // -=- Class to handle cleanup of arrays of characters\n  class CharArray {\n  public:\n    CharArray() : buf(0) {}\n    CharArray(char* str) : buf(str) {} // note: assumes ownership\n    CharArray(int len) {\n      buf = new char[len]();\n    }\n    ~CharArray() {\n      delete [] buf;\n    }\n    void format(const char *fmt, ...) __printf_attr(2, 3);\n    // Get the buffer pointer & clear it (i.e. caller takes ownership)\n    char* takeBuf() {char* tmp = buf; buf = 0; return tmp;}\n    void replaceBuf(char* b) {delete [] buf; buf = b;}\n    char* buf;\n  private:\n    CharArray(const CharArray&);\n    CharArray& operator=(const CharArray&);\n  };\n\n  char* strDup(const char* s);\n  void strFree(char* s);\n  void strFree(wchar_t* s);\n\n  // Returns true if split successful.  Returns false otherwise.\n  // ALWAYS *copies* first part of string to out1 buffer.\n  // If limiter not found, leaves out2 alone (null) and just copies to out1.\n  // If out1 or out2 non-zero, calls strFree and zeroes them.\n  // If fromEnd is true, splits at end of string rather than beginning.\n  // Either out1 or out2 may be null, in which case the split will not return\n  // that part of the string.  Obviously, setting both to 0 is not useful...\n  bool strSplit(const char* src, const char limiter, char** out1, char** out2, bool fromEnd=false);\n\n  // Returns true if src contains c\n  bool strContains(const char* src, char c);\n\n  // Copies src to dest, up to specified length-1, and guarantees termination\n  void strCopy(char* dest, const char* src, int destlen);\n\n  // Makes sure line endings are in a certain format\n\n  char* convertLF(const char* src, size_t bytes = (size_t)-1);\n  char* convertCRLF(const char* src, size_t bytes = (size_t)-1);\n\n  // Convertions between various Unicode formats. The returned strings are\n  // always null terminated and must be freed using strFree().\n\n  size_t ucs4ToUTF8(unsigned src, char* dst);\n  size_t utf8ToUCS4(const char* src, size_t max, unsigned* dst);\n\n  size_t ucs4ToUTF16(unsigned src, wchar_t* dst);\n  size_t utf16ToUCS4(const wchar_t* src, size_t max, unsigned* dst);\n\n  char* latin1ToUTF8(const char* src, size_t bytes = (size_t)-1);\n  char* utf8ToLatin1(const char* src, size_t bytes = (size_t)-1);\n\n  char* utf16ToUTF8(const wchar_t* src, size_t units = (size_t)-1);\n  wchar_t* utf8ToUTF16(const char* src, size_t bytes = (size_t)-1);\n\n  // HELPER functions for timeout handling\n\n  // soonestTimeout() is a function to help work out the soonest of several\n  //   timeouts.\n  inline void soonestTimeout(int* timeout, int newTimeout) {\n    if (newTimeout && (!*timeout || newTimeout < *timeout))\n      *timeout = newTimeout;\n  }\n\n  // secsToMillis() turns seconds into milliseconds, capping the value so it\n  //   can't wrap round and become -ve\n  inline int secsToMillis(int secs) {\n    return (secs < 0 || secs > (INT_MAX/1000) ? INT_MAX : secs * 1000);\n  }\n\n  // Returns time elapsed between two moments in milliseconds.\n  unsigned msBetween(const struct timeval *first,\n                     const struct timeval *second);\n\n  // Returns time elapsed since given moment in milliseconds.\n  unsigned msSince(const struct timeval *then);\n\n  // Returns true if first happened before seconds\n  bool isBefore(const struct timeval *first,\n                const struct timeval *second);\n\n  size_t siPrefix(long long value, const char *unit,\n                  char *buffer, size_t maxlen, int precision=6);\n  size_t iecPrefix(long long value, const char *unit,\n                   char *buffer, size_t maxlen, int precision=6);\n}\n\n// Some platforms (e.g. Windows) include max() and min() macros in their\n// standard headers, but they are also standard C++ template functions, so some\n// C++ headers will undefine them.  So we steer clear of the names min and max\n// and define __rfbmin and __rfbmax instead.\n\n#ifndef __rfbmax\n#define __rfbmax(a,b) (((a) > (b)) ? (a) : (b))\n#endif\n#ifndef __rfbmin\n#define __rfbmin(a,b) (((a) < (b)) ? (a) : (b))\n#endif\n\n#endif\n", "/* Copyright 2015 Pierre Ossman <ossman@cendio.se> for Cendio AB\n * Copyright (C) 2015 D. R. Commander.  All Rights Reserved.\n *\n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n/*\n * This program reads files produced by TightVNC's/TurboVNC's\n * fbs-dump, which in turn takes files from rfbproxy. It is\n * basically a dump of the RFB protocol from the server side after\n * the ServerInit message. Mostly this consists of FramebufferUpdate\n * message using the HexTile encoding. Screen size and pixel format\n * are not encoded in the file and must be specified by the user.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <sys/time.h>\n\n#include <rdr/Exception.h>\n#include <rdr/OutStream.h>\n#include <rdr/FileInStream.h>\n\n#include <rfb/PixelFormat.h>\n\n#include <rfb/CConnection.h>\n#include <rfb/CMsgReader.h>\n#include <rfb/UpdateTracker.h>\n\n#include <rfb/EncodeManager.h>\n#include <rfb/SConnection.h>\n#include <rfb/SMsgWriter.h>\n\n#include \"util.h\"\n\nstatic rfb::IntParameter width(\"width\", \"Frame buffer width\", 0);\nstatic rfb::IntParameter height(\"height\", \"Frame buffer height\", 0);\nstatic rfb::IntParameter count(\"count\", \"Number of benchmark iterations\", 9);\n\nstatic rfb::StringParameter format(\"format\", \"Pixel format (e.g. bgr888)\", \"\");\n\nstatic rfb::BoolParameter translate(\"translate\",\n                                    \"Translate 8-bit and 16-bit datasets into 24-bit\",\n                                    true);\n\n// The frame buffer (and output) is always this format\nstatic const rfb::PixelFormat fbPF(32, 24, false, true, 255, 255, 255, 0, 8, 16);\n\n// Encodings to use\nstatic const rdr::S32 encodings[] = {\n  rfb::encodingTight, rfb::encodingCopyRect, rfb::encodingRRE,\n  rfb::encodingHextile, rfb::encodingZRLE, rfb::pseudoEncodingLastRect,\n  rfb::pseudoEncodingQualityLevel0 + 8,\n  rfb::pseudoEncodingCompressLevel0 + 2};\n\nclass DummyOutStream : public rdr::OutStream {\npublic:\n  DummyOutStream();\n\n  virtual int length();\n  virtual void flush();\n\nprivate:\n  virtual int overrun(int itemSize, int nItems);\n\n  int offset;\n  rdr::U8 buf[131072];\n};\n\nclass CConn : public rfb::CConnection {\npublic:\n  CConn(const char *filename);\n  ~CConn();\n\n  void getStats(double& ratio, unsigned long long& bytes,\n                unsigned long long& rawEquivalent);\n\n  virtual void initDone();\n  virtual void setCursor(int, int, const rfb::Point&, const rdr::U8*);\n  virtual void framebufferUpdateStart();\n  virtual void framebufferUpdateEnd();\n  virtual void dataRect(const rfb::Rect&, int);\n  virtual void setColourMapEntries(int, int, rdr::U16*);\n  virtual void bell();\n  virtual void serverCutText(const char*);\n\npublic:\n  double decodeTime;\n  double encodeTime;\n\nprotected:\n  rdr::FileInStream *in;\n  rfb::SimpleUpdateTracker updates;\n  class SConn *sc;\n};\n\nclass Manager : public rfb::EncodeManager {\npublic:\n  Manager(class rfb::SConnection *conn);\n\n  void getStats(double&, unsigned long long&, unsigned long long&);\n};\n\nclass SConn : public rfb::SConnection {\npublic:\n  SConn();\n  ~SConn();\n\n  void writeUpdate(const rfb::UpdateInfo& ui, const rfb::PixelBuffer* pb);\n\n  void getStats(double&, unsigned long long&, unsigned long long&);\n\n  virtual void setAccessRights(AccessRights ar);\n\n  virtual void setDesktopSize(int fb_width, int fb_height,\n                              const rfb::ScreenSet& layout);\n\nprotected:\n  DummyOutStream *out;\n  Manager *manager;\n};\n\nDummyOutStream::DummyOutStream()\n{\n  offset = 0;\n  ptr = buf;\n  end = buf + sizeof(buf);\n}\n\nint DummyOutStream::length()\n{\n  flush();\n  return offset;\n}\n\nvoid DummyOutStream::flush()\n{\n  offset += ptr - buf;\n  ptr = buf;\n}\n\nint DummyOutStream::overrun(int itemSize, int nItems)\n{\n  flush();\n  if (itemSize * nItems > end - ptr)\n    nItems = (end - ptr) / itemSize;\n  return nItems;\n}\n\nCConn::CConn(const char *filename)\n{\n  decodeTime = 0.0;\n  encodeTime = 0.0;\n\n  in = new rdr::FileInStream(filename);\n  setStreams(in, NULL);\n\n  // Need to skip the initial handshake and ServerInit\n  setState(RFBSTATE_NORMAL);\n  // That also means that the reader and writer weren't setup\n  setReader(new rfb::CMsgReader(this, in));\n  // Nor the frame buffer size and format\n  rfb::PixelFormat pf;\n  pf.parse(format);\n  setPixelFormat(pf);\n  setDesktopSize(width, height);\n\n  sc = new SConn();\n  sc->client.setPF((bool)translate ? fbPF : pf);\n  sc->setEncodings(sizeof(encodings) / sizeof(*encodings), encodings);\n}\n\nCConn::~CConn()\n{\n  delete sc;\n  delete in;\n}\n\nvoid CConn::getStats(double& ratio, unsigned long long& bytes,\n                     unsigned long long& rawEquivalent)\n{\n  sc->getStats(ratio, bytes, rawEquivalent);\n}\n\nvoid CConn::initDone()\n{\n  rfb::ModifiablePixelBuffer *pb;\n\n  pb = new rfb::ManagedPixelBuffer((bool)translate ? fbPF : server.pf(),\n                                   server.width(), server.height());\n  setFramebuffer(pb);\n}\n\nvoid CConn::setCursor(int, int, const rfb::Point&, const rdr::U8*)\n{\n}\n\nvoid CConn::framebufferUpdateStart()\n{\n  CConnection::framebufferUpdateStart();\n\n  updates.clear();\n  startCpuCounter();\n}\n\nvoid CConn::framebufferUpdateEnd()\n{\n  rfb::UpdateInfo ui;\n  rfb::PixelBuffer* pb = getFramebuffer();\n  rfb::Region clip(pb->getRect());\n\n  CConnection::framebufferUpdateEnd();\n\n  endCpuCounter();\n\n  decodeTime += getCpuCounter();\n\n  updates.getUpdateInfo(&ui, clip);\n\n  startCpuCounter();\n  sc->writeUpdate(ui, pb);\n  endCpuCounter();\n\n  encodeTime += getCpuCounter();\n}\n\nvoid CConn::dataRect(const rfb::Rect &r, int encoding)\n{\n  CConnection::dataRect(r, encoding);\n\n  if (encoding != rfb::encodingCopyRect) // FIXME\n    updates.add_changed(rfb::Region(r));\n}\n\nvoid CConn::setColourMapEntries(int, int, rdr::U16*)\n{\n}\n\nvoid CConn::bell()\n{\n}\n\nvoid CConn::serverCutText(const char*)\n{\n}\n\nManager::Manager(class rfb::SConnection *conn) :\n  EncodeManager(conn)\n{\n}\n\nvoid Manager::getStats(double& ratio, unsigned long long& encodedBytes,\n                       unsigned long long& rawEquivalent)\n{\n  StatsVector::iterator iter;\n  unsigned long long bytes, equivalent;\n\n  bytes = equivalent = 0;\n  for (iter = stats.begin(); iter != stats.end(); ++iter) {\n    StatsVector::value_type::iterator iter2;\n    for (iter2 = iter->begin(); iter2 != iter->end(); ++iter2) {\n      bytes += iter2->bytes;\n      equivalent += iter2->equivalent;\n    }\n  }\n\n  ratio = (double)equivalent / bytes;\n  encodedBytes = bytes;\n  rawEquivalent = equivalent;\n}\n\nSConn::SConn()\n{\n  out = new DummyOutStream;\n  setStreams(NULL, out);\n\n  setWriter(new rfb::SMsgWriter(&client, out));\n\n  manager = new Manager(this);\n}\n\nSConn::~SConn()\n{\n  delete manager;\n  delete out;\n}\n\nvoid SConn::writeUpdate(const rfb::UpdateInfo& ui, const rfb::PixelBuffer* pb)\n{\n  manager->writeUpdate(ui, pb, NULL);\n}\n\nvoid SConn::getStats(double& ratio, unsigned long long& bytes,\n                     unsigned long long& rawEquivalent)\n{\n  manager->getStats(ratio, bytes, rawEquivalent);\n}\n\nvoid SConn::setAccessRights(AccessRights ar)\n{\n}\n\nvoid SConn::setDesktopSize(int fb_width, int fb_height,\n                           const rfb::ScreenSet& layout)\n{\n}\n\nstruct stats\n{\n  double decodeTime;\n  double encodeTime;\n  double realTime;\n\n  double ratio;\n  unsigned long long bytes;\n  unsigned long long rawEquivalent;\n};\n\nstatic struct stats runTest(const char *fn)\n{\n  CConn *cc;\n  struct stats s;\n  struct timeval start, stop;\n\n  gettimeofday(&start, NULL);\n\n  try {\n    cc = new CConn(fn);\n  } catch (rdr::Exception& e) {\n    fprintf(stderr, \"Failed to open rfb file: %s\\n\", e.str());\n    exit(1);\n  }\n\n  try {\n    while (true)\n      cc->processMsg();\n  } catch (rdr::EndOfStream& e) {\n  } catch (rdr::Exception& e) {\n    fprintf(stderr, \"Failed to run rfb file: %s\\n\", e.str());\n    exit(1);\n  }\n\n  gettimeofday(&stop, NULL);\n\n  s.decodeTime = cc->decodeTime;\n  s.encodeTime = cc->encodeTime;\n  s.realTime = (double)stop.tv_sec - start.tv_sec;\n  s.realTime += ((double)stop.tv_usec - start.tv_usec)/1000000.0;\n  cc->getStats(s.ratio, s.bytes, s.rawEquivalent);\n\n  delete cc;\n\n  return s;\n}\n\nstatic void sort(double *array, int count)\n{\n  bool sorted;\n  int i;\n  do {\n    sorted = true;\n    for (i = 1; i < count; i++) {\n      if (array[i-1] > array[i]) {\n        double d;\n        d = array[i];\n        array[i] = array[i - 1];\n        array[i - 1] = d;\n        sorted = false;\n      }\n    }\n  } while (!sorted);\n}\n\nstatic void usage(const char *argv0)\n{\n  fprintf(stderr, \"Syntax: %s [options] <rfb file>\\n\", argv0);\n  fprintf(stderr, \"Options:\\n\");\n  rfb::Configuration::listParams(79, 14);\n  exit(1);\n}\n\nint main(int argc, char **argv)\n{\n  int i;\n\n  const char *fn;\n\n  fn = NULL;\n  for (i = 1; i < argc; i++) {\n    if (rfb::Configuration::setParam(argv[i]))\n      continue;\n\n    if (argv[i][0] == '-') {\n      if (i + 1 < argc) {\n        if (rfb::Configuration::setParam(&argv[i][1], argv[i + 1])) {\n          i++;\n          continue;\n        }\n      }\n      usage(argv[0]);\n    }\n\n    if (fn != NULL)\n      usage(argv[0]);\n\n    fn = argv[i];\n  }\n\n  int runCount = count;\n  struct stats *runs = new struct stats[runCount];\n  double *values = new double[runCount];\n  double *dev = new double[runCount];\n  double median, meddev;\n\n  if (fn == NULL) {\n    fprintf(stderr, \"No file specified!\\n\\n\");\n    usage(argv[0]);\n  }\n\n  if (strcmp(format, \"\") == 0) {\n    fprintf(stderr, \"Pixel format not specified!\\n\\n\");\n    usage(argv[0]);\n  }\n\n  if (width == 0 || height == 0) {\n    fprintf(stderr, \"Frame buffer size not specified!\\n\\n\");\n    usage(argv[0]);\n  }\n\n  // Warmup\n  runTest(fn);\n\n  // Multiple runs to get a good average\n  for (i = 0; i < runCount; i++)\n    runs[i] = runTest(fn);\n\n  // Calculate median and median deviation for CPU usage decoding\n  for (i = 0;i < runCount;i++)\n    values[i] = runs[i].decodeTime;\n\n  sort(values, runCount);\n  median = values[runCount/2];\n\n  for (i = 0;i < runCount;i++)\n    dev[i] = fabs((values[i] - median) / median) * 100;\n\n  sort(dev, runCount);\n  meddev = dev[runCount/2];\n\n  printf(\"CPU time (decoding): %g s (+/- %g %%)\\n\", median, meddev);\n\n  // And for CPU usage encoding\n  for (i = 0;i < runCount;i++)\n    values[i] = runs[i].encodeTime;\n\n  sort(values, runCount);\n  median = values[runCount/2];\n\n  for (i = 0;i < runCount;i++)\n    dev[i] = fabs((values[i] - median) / median) * 100;\n\n  sort(dev, runCount);\n  meddev = dev[runCount/2];\n\n  printf(\"CPU time (encoding): %g s (+/- %g %%)\\n\", median, meddev);\n\n  // And for CPU core usage encoding\n  for (i = 0;i < runCount;i++)\n    values[i] = (runs[i].decodeTime + runs[i].encodeTime) / runs[i].realTime;\n\n  sort(values, runCount);\n  median = values[runCount/2];\n\n  for (i = 0;i < runCount;i++)\n    dev[i] = fabs((values[i] - median) / median) * 100;\n\n  sort(dev, runCount);\n  meddev = dev[runCount/2];\n\n  printf(\"Core usage (total): %g (+/- %g %%)\\n\", median, meddev);\n\n#ifdef WIN32\n  printf(\"Encoded bytes: %I64d\\n\", runs[0].bytes);\n  printf(\"Raw equivalent bytes: %I64d\\n\", runs[0].rawEquivalent);\n#else\n  printf(\"Encoded bytes: %lld\\n\", runs[0].bytes);\n  printf(\"Raw equivalent bytes: %lld\\n\", runs[0].rawEquivalent);\n#endif\n  printf(\"Ratio: %g\\n\", runs[0].ratio);\n\n  return 0;\n}\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n// -=- Registry.cxx\n\n#include <rfb_win32/Registry.h>\n#include <rfb_win32/Security.h>\n#include <rdr/MemOutStream.h>\n#include <rdr/HexOutStream.h>\n#include <rdr/HexInStream.h>\n#include <stdlib.h>\n#include <rfb/LogWriter.h>\n\n// These flags are required to control access control inheritance,\n// but are not defined by VC6's headers.  These definitions comes\n// from the Microsoft Platform SDK.\n#ifndef PROTECTED_DACL_SECURITY_INFORMATION\n#define PROTECTED_DACL_SECURITY_INFORMATION     (0x80000000L)\n#endif\n#ifndef UNPROTECTED_DACL_SECURITY_INFORMATION\n#define UNPROTECTED_DACL_SECURITY_INFORMATION     (0x20000000L)\n#endif\n\n\nusing namespace rfb;\nusing namespace rfb::win32;\n\n\nstatic LogWriter vlog(\"Registry\");\n\n\nRegKey::RegKey() : key(0), freeKey(false), valueNameBufLen(0) {}\n\nRegKey::RegKey(const HKEY k) : key(0), freeKey(false), valueNameBufLen(0) {\n  LONG result = RegOpenKeyEx(k, 0, 0, KEY_ALL_ACCESS, &key);\n  if (result != ERROR_SUCCESS)\n    throw rdr::SystemException(\"RegOpenKeyEx(HKEY)\", result);\n  vlog.debug(\"duplicated %p to %p\", k, key);\n  freeKey = true;\n}\n\nRegKey::RegKey(const RegKey& k) : key(0), freeKey(false), valueNameBufLen(0) {\n  LONG result = RegOpenKeyEx(k.key, 0, 0, KEY_ALL_ACCESS, &key);\n  if (result != ERROR_SUCCESS)\n    throw rdr::SystemException(\"RegOpenKeyEx(RegKey&)\", result);\n  vlog.debug(\"duplicated %p to %p\", k.key, key);\n  freeKey = true;\n}\n\nRegKey::~RegKey() {\n  close();\n}\n\n\nvoid RegKey::setHKEY(HKEY k, bool fK) {\n  vlog.debug(\"setHKEY(%p,%d)\", k, (int)fK);\n  close();\n  freeKey = fK;\n  key = k;\n}\n\n\nbool RegKey::createKey(const RegKey& root, const TCHAR* name) {\n  close();\n  LONG result = RegCreateKey(root.key, name, &key);\n  if (result != ERROR_SUCCESS) {\n    vlog.error(\"RegCreateKey(%p, %s): %lx\", root.key, name, result);\n    throw rdr::SystemException(\"RegCreateKeyEx\", result);\n  }\n  vlog.debug(\"createKey(%p,%s) = %p\", root.key, (const char*)CStr(name), key);\n  freeKey = true;\n  return true;\n}\n\nvoid RegKey::openKey(const RegKey& root, const TCHAR* name, bool readOnly) {\n  close();\n  LONG result = RegOpenKeyEx(root.key, name, 0, readOnly ? KEY_READ : KEY_ALL_ACCESS, &key);\n  if (result != ERROR_SUCCESS)\n    throw rdr::SystemException(\"RegOpenKeyEx (open)\", result);\n  vlog.debug(\"openKey(%p,%s,%s) = %p\", root.key, (const char*)CStr(name),\n\t         readOnly ? \"ro\" : \"rw\", key);\n  freeKey = true;\n}\n\nvoid RegKey::setDACL(const PACL acl, bool inherit) {\n  DWORD result;\n  if ((result = SetSecurityInfo(key, SE_REGISTRY_KEY,\n    DACL_SECURITY_INFORMATION |\n    (inherit ? UNPROTECTED_DACL_SECURITY_INFORMATION : PROTECTED_DACL_SECURITY_INFORMATION),\n    0, 0, acl, 0)) != ERROR_SUCCESS)\n    throw rdr::SystemException(\"RegKey::setDACL failed\", result);\n}\n\nvoid RegKey::close() {\n  if (freeKey) {\n    vlog.debug(\"RegCloseKey(%p)\", key);\n    RegCloseKey(key);\n    key = 0;\n  }\n}\n\nvoid RegKey::deleteKey(const TCHAR* name) const {\n  LONG result = RegDeleteKey(key, name);\n  if (result != ERROR_SUCCESS)\n    throw rdr::SystemException(\"RegDeleteKey\", result);\n}\n\nvoid RegKey::deleteValue(const TCHAR* name) const {\n  LONG result = RegDeleteValue(key, name);\n  if (result != ERROR_SUCCESS)\n    throw rdr::SystemException(\"RegDeleteValue\", result);\n}\n\nvoid RegKey::awaitChange(bool watchSubTree, DWORD filter, HANDLE event) const {\n  LONG result = RegNotifyChangeKeyValue(key, watchSubTree, filter, event, event != 0);\n  if (result != ERROR_SUCCESS)\n    throw rdr::SystemException(\"RegNotifyChangeKeyValue\", result);\n}\n\n\nRegKey::operator HKEY() const {return key;}\n\n\nvoid RegKey::setExpandString(const TCHAR* valname, const TCHAR* value) const {\n  LONG result = RegSetValueEx(key, valname, 0, REG_EXPAND_SZ, (const BYTE*)value, (_tcslen(value)+1)*sizeof(TCHAR));\n  if (result != ERROR_SUCCESS) throw rdr::SystemException(\"setExpandString\", result);\n}\n\nvoid RegKey::setString(const TCHAR* valname, const TCHAR* value) const {\n  LONG result = RegSetValueEx(key, valname, 0, REG_SZ, (const BYTE*)value, (_tcslen(value)+1)*sizeof(TCHAR));\n  if (result != ERROR_SUCCESS) throw rdr::SystemException(\"setString\", result);\n}\n\nvoid RegKey::setBinary(const TCHAR* valname, const void* value, int length) const {\n  LONG result = RegSetValueEx(key, valname, 0, REG_BINARY, (const BYTE*)value, length);\n  if (result != ERROR_SUCCESS) throw rdr::SystemException(\"setBinary\", result);\n}\n\nvoid RegKey::setInt(const TCHAR* valname, int value) const {\n  LONG result = RegSetValueEx(key, valname, 0, REG_DWORD, (const BYTE*)&value, sizeof(value));\n  if (result != ERROR_SUCCESS) throw rdr::SystemException(\"setInt\", result);\n}\n\nvoid RegKey::setBool(const TCHAR* valname, bool value) const {\n  setInt(valname, value ? 1 : 0);\n}\n\nTCHAR* RegKey::getString(const TCHAR* valname) const {return getRepresentation(valname);}\nTCHAR* RegKey::getString(const TCHAR* valname, const TCHAR* def) const {\n  try {\n    return getString(valname);\n  } catch(rdr::Exception&) {\n    return tstrDup(def);\n  }\n}\n\nvoid RegKey::getBinary(const TCHAR* valname, void** data, int* length) const {\n  TCharArray hex(getRepresentation(valname));\n  if (!rdr::HexInStream::hexStrToBin(CStr(hex.buf), (char**)data, length))\n    throw rdr::Exception(\"getBinary failed\");\n}\nvoid RegKey::getBinary(const TCHAR* valname, void** data, int* length, void* def, int deflen) const {\n  try {\n    getBinary(valname, data, length);\n  } catch(rdr::Exception&) {\n    if (deflen) {\n      *data = new char[deflen];\n      memcpy(*data, def, deflen);\n    } else\n      *data = 0;\n    *length = deflen;\n  }\n}\n\nint RegKey::getInt(const TCHAR* valname) const {\n  TCharArray tmp(getRepresentation(valname));\n  return _ttoi(tmp.buf);\n}\nint RegKey::getInt(const TCHAR* valname, int def) const {\n  try {\n    return getInt(valname);\n  } catch(rdr::Exception&) {\n    return def;\n  }\n}\n\nbool RegKey::getBool(const TCHAR* valname) const {\n  return getInt(valname) > 0;\n}\nbool RegKey::getBool(const TCHAR* valname, bool def) const {\n  return getInt(valname, def ? 1 : 0) > 0;\n}\n\nstatic inline TCHAR* terminateData(char* data, int length)\n{\n  // We must terminate the string, just to be sure.  Stupid Win32...\n  int len = length/sizeof(TCHAR);\n  TCharArray str(len+1);\n  memcpy(str.buf, data, length);\n  str.buf[len] = 0;\n  return str.takeBuf();\n}\n\nTCHAR* RegKey::getRepresentation(const TCHAR* valname) const {\n  DWORD type, length;\n  LONG result = RegQueryValueEx(key, valname, 0, &type, 0, &length);\n  if (result != ERROR_SUCCESS)\n    throw rdr::SystemException(\"get registry value length\", result);\n  CharArray data(length);\n  result = RegQueryValueEx(key, valname, 0, &type, (BYTE*)data.buf, &length);\n  if (result != ERROR_SUCCESS)\n    throw rdr::SystemException(\"get registry value\", result);\n\n  switch (type) {\n  case REG_BINARY:\n    {\n      TCharArray hex(rdr::HexOutStream::binToHexStr(data.buf, length));\n      return hex.takeBuf();\n    }\n  case REG_SZ:\n    if (length) {\n      return terminateData(data.buf, length);\n    } else {\n      return tstrDup(_T(\"\"));\n    }\n  case REG_DWORD:\n    {\n      TCharArray tmp(16);\n      _stprintf(tmp.buf, _T(\"%lu\"), *((DWORD*)data.buf));\n      return tmp.takeBuf();\n    }\n  case REG_EXPAND_SZ:\n    {\n    if (length) {\n      TCharArray str(terminateData(data.buf, length));\n      DWORD required = ExpandEnvironmentStrings(str.buf, 0, 0);\n      if (required==0)\n        throw rdr::SystemException(\"ExpandEnvironmentStrings\", GetLastError());\n      TCharArray result(required);\n      length = ExpandEnvironmentStrings(str.buf, result.buf, required);\n      if (required<length)\n        throw rdr::Exception(\"unable to expand environment strings\");\n      return result.takeBuf();\n    } else {\n      return tstrDup(_T(\"\"));\n    }\n    }\n  default:\n    throw rdr::Exception(\"unsupported registry type\");\n  }\n}\n\nbool RegKey::isValue(const TCHAR* valname) const {\n  try {\n    TCharArray tmp(getRepresentation(valname));\n    return true;\n  } catch(rdr::Exception&) {\n    return false;\n  }\n}\n\nconst TCHAR* RegKey::getValueName(int i) {\n  DWORD maxValueNameLen;\n  LONG result = RegQueryInfoKey(key, 0, 0, 0, 0, 0, 0, 0, &maxValueNameLen, 0, 0, 0);\n  if (result != ERROR_SUCCESS)\n    throw rdr::SystemException(\"RegQueryInfoKey\", result);\n  if (valueNameBufLen < maxValueNameLen + 1) {\n    valueNameBufLen = maxValueNameLen + 1;\n    delete [] valueName.buf;\n    valueName.buf = new TCHAR[valueNameBufLen];\n  }\n  DWORD length = valueNameBufLen;\n  result = RegEnumValue(key, i, valueName.buf, &length, NULL, 0, 0, 0);\n  if (result == ERROR_NO_MORE_ITEMS) return 0;\n  if (result != ERROR_SUCCESS)\n    throw rdr::SystemException(\"RegEnumValue\", result);\n  return valueName.buf;\n}\n\nconst TCHAR* RegKey::getKeyName(int i) {\n  DWORD maxValueNameLen;\n  LONG result = RegQueryInfoKey(key, 0, 0, 0, 0, &maxValueNameLen, 0, 0, 0, 0, 0, 0);\n  if (result != ERROR_SUCCESS)\n    throw rdr::SystemException(\"RegQueryInfoKey\", result);\n  if (valueNameBufLen < maxValueNameLen + 1) {\n    valueNameBufLen = maxValueNameLen + 1;\n    delete [] valueName.buf;\n    valueName.buf = new TCHAR[valueNameBufLen];\n  }\n  DWORD length = valueNameBufLen;\n  result = RegEnumKeyEx(key, i, valueName.buf, &length, NULL, 0, 0, 0);\n  if (result == ERROR_NO_MORE_ITEMS) return 0;\n  if (result != ERROR_SUCCESS)\n    throw rdr::SystemException(\"RegEnumKey\", result);\n  return valueName.buf;\n}\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n// -=- Registry.h\n\n// C++ wrappers around the Win32 Registry APIs\n\n#ifndef __RFB_WIN32_REGISTRY_H__\n#define __RFB_WIN32_REGISTRY_H__\n\n#include <windows.h>\n#include <rfb_win32/Security.h>\n#include <rfb/util.h>\n\nnamespace rfb {\n\n  namespace win32 {\n\n    class RegKey {\n    public:\n      // No key open\n      RegKey();\n\n      // Duplicate the specified existing key\n      RegKey(const HKEY k);\n      RegKey(const RegKey& k);\n\n      // Calls close() internally\n      ~RegKey();\n\n      void setHKEY(HKEY key, bool freeKey);\n    private:\n      RegKey& operator=(const RegKey& k);\n      HKEY& operator=(const HKEY& k);\n    public:\n\n      // Returns true if key was created, false if already existed\n      bool createKey(const RegKey& root, const TCHAR* name);\n\n      // Opens key if it exists, or raises an exception if not\n      void openKey(const RegKey& root, const TCHAR* name, bool readOnly=false);\n\n      // Set the (discretionary) access control list for the key\n      void setDACL(const PACL acl, bool inheritFromParent=true);\n\n      // Closes current key, if required\n      void close();\n\n      // Delete a subkey/value\n      void deleteKey(const TCHAR* name) const;\n      void deleteValue(const TCHAR* name) const;\n\n\n      // Block waiting for a registry change, OR return immediately and notify the\n      // event when there is a change, if specified\n      void awaitChange(bool watchSubTree, DWORD filter, HANDLE event=0) const;\n\n      void setExpandString(const TCHAR* valname, const TCHAR* s) const;\n      void setString(const TCHAR* valname, const TCHAR* s) const;\n      void setBinary(const TCHAR* valname, const void* data, int length) const;\n      void setInt(const TCHAR* valname, int i) const;\n      void setBool(const TCHAR* valname, bool b) const;\n\n      TCHAR* getString(const TCHAR* valname) const;\n      TCHAR* getString(const TCHAR* valname, const TCHAR* def) const;\n\n      void getBinary(const TCHAR* valname, void** data, int* length) const;\n      void getBinary(const TCHAR* valname, void** data, int* length, void* def, int deflength) const;\n\n      int getInt(const TCHAR* valname) const;\n      int getInt(const TCHAR* valname, int def) const;\n\n      bool getBool(const TCHAR* valname) const;\n      bool getBool(const TCHAR* valname, bool def) const;\n\n      TCHAR* getRepresentation(const TCHAR* valname) const;\n\n      bool isValue(const TCHAR* valname) const;\n\n      // Get the name of value/key number \"i\"\n      // If there are fewer than \"i\" values then return 0\n      // NAME IS OWNED BY RegKey OBJECT!\n      const TCHAR* getValueName(int i);\n      const TCHAR* getKeyName(int i);\n\n      operator HKEY() const;\n    protected:\n      HKEY key;\n      bool freeKey;\n      TCharArray valueName;\n      DWORD valueNameBufLen;\n    };\n\n  };\n\n};\n\n#endif // __RFB_WIN32_REG_CONFIG_H__\n"], "fixing_code": ["/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/time.h>\n#ifdef _WIN32\n#include <winsock2.h>\n#define close closesocket\n#undef errno\n#define errno WSAGetLastError()\n#include <os/winerrno.h>\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#endif\n\n#ifndef vncmin\n#define vncmin(a,b)            (((a) < (b)) ? (a) : (b))\n#endif\n#ifndef vncmax\n#define vncmax(a,b)            (((a) > (b)) ? (a) : (b))\n#endif\n\n/* Old systems have select() in sys/time.h */\n#ifdef HAVE_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n\n#include <rdr/FdInStream.h>\n#include <rdr/Exception.h>\n\nusing namespace rdr;\n\nenum { DEFAULT_BUF_SIZE = 8192,\n       MIN_BULK_SIZE = 1024 };\n\nFdInStream::FdInStream(int fd_, int timeoutms_, size_t bufSize_,\n                       bool closeWhenDone_)\n  : fd(fd_), closeWhenDone(closeWhenDone_),\n    timeoutms(timeoutms_), blockCallback(0),\n    timing(false), timeWaitedIn100us(5), timedKbits(0),\n    bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0)\n{\n  ptr = end = start = new U8[bufSize];\n}\n\nFdInStream::FdInStream(int fd_, FdInStreamBlockCallback* blockCallback_,\n                       size_t bufSize_)\n  : fd(fd_), timeoutms(0), blockCallback(blockCallback_),\n    timing(false), timeWaitedIn100us(5), timedKbits(0),\n    bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0)\n{\n  ptr = end = start = new U8[bufSize];\n}\n\nFdInStream::~FdInStream()\n{\n  delete [] start;\n  if (closeWhenDone) close(fd);\n}\n\n\nvoid FdInStream::setTimeout(int timeoutms_) {\n  timeoutms = timeoutms_;\n}\n\nvoid FdInStream::setBlockCallback(FdInStreamBlockCallback* blockCallback_)\n{\n  blockCallback = blockCallback_;\n  timeoutms = 0;\n}\n\nsize_t FdInStream::pos()\n{\n  return offset + ptr - start;\n}\n\nvoid FdInStream::readBytes(void* data, size_t length)\n{\n  if (length < MIN_BULK_SIZE) {\n    InStream::readBytes(data, length);\n    return;\n  }\n\n  U8* dataPtr = (U8*)data;\n\n  size_t n = end - ptr;\n  if (n > length) n = length;\n\n  memcpy(dataPtr, ptr, n);\n  dataPtr += n;\n  length -= n;\n  ptr += n;\n\n  while (length > 0) {\n    n = readWithTimeoutOrCallback(dataPtr, length);\n    dataPtr += n;\n    length -= n;\n    offset += n;\n  }\n}\n\n\nsize_t FdInStream::overrun(size_t itemSize, size_t nItems, bool wait)\n{\n  if (itemSize > bufSize)\n    throw Exception(\"FdInStream overrun: max itemSize exceeded\");\n\n  if (end - ptr != 0)\n    memmove(start, ptr, end - ptr);\n\n  offset += ptr - start;\n  end -= ptr - start;\n  ptr = start;\n\n  size_t bytes_to_read;\n  while (end < start + itemSize) {\n    bytes_to_read = start + bufSize - end;\n    if (!timing) {\n      // When not timing, we must be careful not to read too much\n      // extra data into the buffer. Otherwise, the line speed\n      // estimation might stay at zero for a long time: All reads\n      // during timing=1 can be satisfied without calling\n      // readWithTimeoutOrCallback. However, reading only 1 or 2 bytes\n      // bytes is ineffecient.\n      bytes_to_read = vncmin(bytes_to_read, vncmax(itemSize*nItems, 8));\n    }\n    size_t n = readWithTimeoutOrCallback((U8*)end, bytes_to_read, wait);\n    if (n == 0) return 0;\n    end += n;\n  }\n\n  if (itemSize * nItems > (size_t)(end - ptr))\n    nItems = (end - ptr) / itemSize;\n\n  return nItems;\n}\n\n//\n// readWithTimeoutOrCallback() reads up to the given length in bytes from the\n// file descriptor into a buffer.  If the wait argument is false, then zero is\n// returned if no bytes can be read without blocking.  Otherwise if a\n// blockCallback is set, it will be called (repeatedly) instead of blocking.\n// If alternatively there is a timeout set and that timeout expires, it throws\n// a TimedOut exception.  Otherwise it returns the number of bytes read.  It\n// never attempts to recv() unless select() indicates that the fd is readable -\n// this means it can be used on an fd which has been set non-blocking.  It also\n// has to cope with the annoying possibility of both select() and recv()\n// returning EINTR.\n//\n\nsize_t FdInStream::readWithTimeoutOrCallback(void* buf, size_t len, bool wait)\n{\n  struct timeval before, after;\n  if (timing)\n    gettimeofday(&before, 0);\n\n  int n;\n  while (true) {\n    do {\n      fd_set fds;\n      struct timeval tv;\n      struct timeval* tvp = &tv;\n\n      if (!wait) {\n        tv.tv_sec = tv.tv_usec = 0;\n      } else if (timeoutms != -1) {\n        tv.tv_sec = timeoutms / 1000;\n        tv.tv_usec = (timeoutms % 1000) * 1000;\n      } else {\n        tvp = 0;\n      }\n\n      FD_ZERO(&fds);\n      FD_SET(fd, &fds);\n      n = select(fd+1, &fds, 0, 0, tvp);\n    } while (n < 0 && errno == EINTR);\n\n    if (n > 0) break;\n    if (n < 0) throw SystemException(\"select\",errno);\n    if (!wait) return 0;\n    if (!blockCallback) throw TimedOut();\n\n    blockCallback->blockCallback();\n  }\n\n  do {\n    n = ::recv(fd, (char*)buf, len, 0);\n  } while (n < 0 && errno == EINTR);\n\n  if (n < 0) throw SystemException(\"read\",errno);\n  if (n == 0) throw EndOfStream();\n\n  if (timing) {\n    gettimeofday(&after, 0);\n    int newTimeWaited = ((after.tv_sec - before.tv_sec) * 10000 +\n                         (after.tv_usec - before.tv_usec) / 100);\n    int newKbits = n * 8 / 1000;\n\n    // limit rate to between 10kbit/s and 40Mbit/s\n\n    if (newTimeWaited > newKbits*1000) newTimeWaited = newKbits*1000;\n    if (newTimeWaited < newKbits/4)    newTimeWaited = newKbits/4;\n\n    timeWaitedIn100us += newTimeWaited;\n    timedKbits += newKbits;\n  }\n\n  return n;\n}\n\nvoid FdInStream::startTiming()\n{\n  timing = true;\n\n  // Carry over up to 1s worth of previous rate for smoothing.\n\n  if (timeWaitedIn100us > 10000) {\n    timedKbits = timedKbits * 10000 / timeWaitedIn100us;\n    timeWaitedIn100us = 10000;\n  }\n}\n\nvoid FdInStream::stopTiming()\n{\n  timing = false; \n  if (timeWaitedIn100us < timedKbits/2)\n    timeWaitedIn100us = timedKbits/2; // upper limit 20Mbit/s\n}\n\nunsigned int FdInStream::kbitsPerSecond()\n{\n  // The following calculation will overflow 32-bit arithmetic if we have\n  // received more than about 50Mbytes (400Mbits) since we started timing, so\n  // it should be OK for a single RFB update.\n\n  return timedKbits * 10000 / timeWaitedIn100us;\n}\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n//\n// FdInStream streams from a file descriptor.\n//\n\n#ifndef __RDR_FDINSTREAM_H__\n#define __RDR_FDINSTREAM_H__\n\n#include <rdr/InStream.h>\n\nnamespace rdr {\n\n  class FdInStreamBlockCallback {\n  public:\n    virtual void blockCallback() = 0;\n    virtual ~FdInStreamBlockCallback() {}\n  };\n\n  class FdInStream : public InStream {\n\n  public:\n\n    FdInStream(int fd, int timeoutms=-1, size_t bufSize=0,\n               bool closeWhenDone_=false);\n    FdInStream(int fd, FdInStreamBlockCallback* blockCallback,\n               size_t bufSize=0);\n    virtual ~FdInStream();\n\n    void setTimeout(int timeoutms);\n    void setBlockCallback(FdInStreamBlockCallback* blockCallback);\n    int getFd() { return fd; }\n    size_t pos();\n    void readBytes(void* data, size_t length);\n\n    void startTiming();\n    void stopTiming();\n    unsigned int kbitsPerSecond();\n    unsigned int timeWaited() { return timeWaitedIn100us; }\n\n  protected:\n    size_t overrun(size_t itemSize, size_t nItems, bool wait);\n\n  private:\n    size_t readWithTimeoutOrCallback(void* buf, size_t len, bool wait=true);\n\n    int fd;\n    bool closeWhenDone;\n    int timeoutms;\n    FdInStreamBlockCallback* blockCallback;\n\n    bool timing;\n    unsigned int timeWaitedIn100us;\n    unsigned int timedKbits;\n\n    size_t bufSize;\n    size_t offset;\n    U8* start;\n  };\n\n} // end of namespace rdr\n\n#endif\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * Copyright 2011 Pierre Ossman for Cendio AB\n * Copyright 2017 Peter Astrand <astrand@cendio.se> for Cendio AB\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#ifdef _WIN32\n#include <winsock2.h>\n#undef errno\n#define errno WSAGetLastError()\n#include <os/winerrno.h>\n#else\n#include <sys/types.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#endif\n\n/* Old systems have select() in sys/time.h */\n#ifdef HAVE_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n\n#include <rdr/FdOutStream.h>\n#include <rdr/Exception.h>\n#include <rfb/util.h>\n\n\nusing namespace rdr;\n\nenum { DEFAULT_BUF_SIZE = 16384 };\n\nFdOutStream::FdOutStream(int fd_, bool blocking_, int timeoutms_, size_t bufSize_)\n  : fd(fd_), blocking(blocking_), timeoutms(timeoutms_),\n    bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0)\n{\n  ptr = start = sentUpTo = new U8[bufSize];\n  end = start + bufSize;\n\n  gettimeofday(&lastWrite, NULL);\n}\n\nFdOutStream::~FdOutStream()\n{\n  try {\n    blocking = true;\n    flush();\n  } catch (Exception&) {\n  }\n  delete [] start;\n}\n\nvoid FdOutStream::setTimeout(int timeoutms_) {\n  timeoutms = timeoutms_;\n}\n\nvoid FdOutStream::setBlocking(bool blocking_) {\n  blocking = blocking_;\n}\n\nsize_t FdOutStream::length()\n{\n  return offset + ptr - sentUpTo;\n}\n\nint FdOutStream::bufferUsage()\n{\n  return ptr - sentUpTo;\n}\n\nunsigned FdOutStream::getIdleTime()\n{\n  return rfb::msSince(&lastWrite);\n}\n\nvoid FdOutStream::flush()\n{\n  while (sentUpTo < ptr) {\n    size_t n = writeWithTimeout((const void*) sentUpTo,\n                                ptr - sentUpTo,\n                                blocking? timeoutms : 0);\n\n    // Timeout?\n    if (n == 0) {\n      // If non-blocking then we're done here\n      if (!blocking)\n        break;\n\n      throw TimedOut();\n    }\n\n    sentUpTo += n;\n    offset += n;\n  }\n\n   // Managed to flush everything?\n  if (sentUpTo == ptr)\n    ptr = sentUpTo = start;\n}\n\n\nsize_t FdOutStream::overrun(size_t itemSize, size_t nItems)\n{\n  if (itemSize > bufSize)\n    throw Exception(\"FdOutStream overrun: max itemSize exceeded\");\n\n  // First try to get rid of the data we have\n  flush();\n\n  // Still not enough space?\n  if (itemSize > (size_t)(end - ptr)) {\n    // Can we shuffle things around?\n    // (don't do this if it gains us less than 25%)\n    if (((size_t)(sentUpTo - start) > bufSize / 4) &&\n        (itemSize < bufSize - (ptr - sentUpTo))) {\n      memmove(start, sentUpTo, ptr - sentUpTo);\n      ptr = start + (ptr - sentUpTo);\n      sentUpTo = start;\n    } else {\n      // Have to get rid of more data, so turn off non-blocking\n      // for a bit...\n      bool realBlocking;\n\n      realBlocking = blocking;\n      blocking = true;\n      flush();\n      blocking = realBlocking;\n    }\n  }\n\n  // Can we fit all the items asked for?\n  if (itemSize * nItems > (size_t)(end - ptr))\n    nItems = (end - ptr) / itemSize;\n\n  return nItems;\n}\n\n//\n// writeWithTimeout() writes up to the given length in bytes from the given\n// buffer to the file descriptor.  If there is a timeout set and that timeout\n// expires, it throws a TimedOut exception.  Otherwise it returns the number of\n// bytes written.  It never attempts to send() unless select() indicates that\n// the fd is writable - this means it can be used on an fd which has been set\n// non-blocking.  It also has to cope with the annoying possibility of both\n// select() and send() returning EINTR.\n//\n\nsize_t FdOutStream::writeWithTimeout(const void* data, size_t length, int timeoutms)\n{\n  int n;\n\n  do {\n    fd_set fds;\n    struct timeval tv;\n    struct timeval* tvp = &tv;\n\n    if (timeoutms != -1) {\n      tv.tv_sec = timeoutms / 1000;\n      tv.tv_usec = (timeoutms % 1000) * 1000;\n    } else {\n      tvp = NULL;\n    }\n\n    FD_ZERO(&fds);\n    FD_SET(fd, &fds);\n    n = select(fd+1, 0, &fds, 0, tvp);\n  } while (n < 0 && errno == EINTR);\n\n  if (n < 0)\n    throw SystemException(\"select\", errno);\n\n  if (n == 0)\n    return 0;\n\n  do {\n    // select only guarantees that you can write SO_SNDLOWAT without\n    // blocking, which is normally 1. Use MSG_DONTWAIT to avoid\n    // blocking, when possible.\n#ifndef MSG_DONTWAIT\n    n = ::send(fd, (const char*)data, length, 0);\n#else\n    n = ::send(fd, (const char*)data, length, MSG_DONTWAIT);\n#endif\n  } while (n < 0 && (errno == EINTR));\n\n  if (n < 0)\n    throw SystemException(\"write\", errno);\n\n  gettimeofday(&lastWrite, NULL);\n\n  return n;\n}\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * Copyright 2011 Pierre Ossman for Cendio AB\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n//\n// FdOutStream streams to a file descriptor.\n//\n\n#ifndef __RDR_FDOUTSTREAM_H__\n#define __RDR_FDOUTSTREAM_H__\n\n#include <sys/time.h>\n\n#include <rdr/OutStream.h>\n\nnamespace rdr {\n\n  class FdOutStream : public OutStream {\n\n  public:\n\n    FdOutStream(int fd, bool blocking=true, int timeoutms=-1, size_t bufSize=0);\n    virtual ~FdOutStream();\n\n    void setTimeout(int timeoutms);\n    void setBlocking(bool blocking);\n    int getFd() { return fd; }\n\n    void flush();\n    size_t length();\n\n    int bufferUsage();\n\n    unsigned getIdleTime();\n\n  private:\n    size_t overrun(size_t itemSize, size_t nItems);\n    size_t writeWithTimeout(const void* data, size_t length, int timeoutms);\n    int fd;\n    bool blocking;\n    int timeoutms;\n    size_t bufSize;\n    size_t offset;\n    U8* start;\n    U8* sentUpTo;\n    struct timeval lastWrite;\n  };\n\n}\n\n#endif\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * Copyright (C) 2013 D. R. Commander.  All Rights Reserved.\n * Copyright 2015 Pierre Ossman for Cendio AB\n *\n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#include <errno.h>\n\n#include <rdr/Exception.h>\n#include <rdr/FileInStream.h>\n\nusing namespace rdr;\n\nFileInStream::FileInStream(const char *fileName)\n{\n  file = fopen(fileName, \"rb\");\n  if (!file)\n    throw SystemException(\"fopen\", errno);\n  ptr = end = b;\n}\n\nFileInStream::~FileInStream(void) {\n  if (file) {\n    fclose(file);\n    file = NULL;\n  }\n}\n\nvoid FileInStream::reset(void) {\n  if (!file)\n    throw Exception(\"File is not open\");\n  if (fseek(file, 0, SEEK_SET) != 0)\n    throw SystemException(\"fseek\", errno);\n  ptr = end = b;\n}\n\nsize_t FileInStream::pos()\n{\n  if (!file)\n    throw Exception(\"File is not open\");\n\n  return ftell(file) + ptr - b;\n}\n\nsize_t FileInStream::overrun(size_t itemSize, size_t nItems, bool wait)\n{\n  if (itemSize > sizeof(b))\n    throw Exception(\"FileInStream overrun: max itemSize exceeded\");\n\n  if (end - ptr != 0)\n    memmove(b, ptr, end - ptr);\n\n  end -= ptr - b;\n  ptr = b;\n\n\n  while (end < b + itemSize) {\n    size_t n = fread((U8 *)end, b + sizeof(b) - end, 1, file);\n    if (n == 0) {\n      if (ferror(file))\n        throw SystemException(\"fread\", errno);\n      if (feof(file))\n        throw EndOfStream();\n      return 0;\n    }\n    end += b + sizeof(b) - end;\n  }\n\n  if (itemSize * nItems > (size_t)(end - ptr))\n    nItems = (end - ptr) / itemSize;\n\n  return nItems;\n}\n", "/* Copyright (C) 2013 D. R. Commander.  All Rights Reserved.\n * Copyright 2015 Pierre Ossman for Cendio AB\n *\n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#ifndef __RDR_FILEINSTREAM_H__\n#define __RDR_FILEINSTREAM_H__\n\n#include <stdio.h>\n\n#include <rdr/InStream.h>\n\nnamespace rdr {\n\n  class FileInStream : public InStream {\n\n  public:\n\n    FileInStream(const char *fileName);\n    ~FileInStream(void);\n\n    void reset(void);\n\n    size_t pos();\n\n  protected:\n    size_t overrun(size_t itemSize, size_t nItems, bool wait = true);\n\n  private:\n    U8 b[131072];\n    FILE *file;\n  };\n\n} // end of namespace rdr\n\n#endif\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#include <rdr/HexInStream.h>\n#include <rdr/Exception.h>\n\n#include <stdlib.h>\n#include <ctype.h>\n\nusing namespace rdr;\n\nconst int DEFAULT_BUF_LEN = 16384;\n\nstatic inline int min(int a, int b) {return a<b ? a : b;}\n\nHexInStream::HexInStream(InStream& is, size_t bufSize_)\n: bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_LEN), offset(0), in_stream(is)\n{\n  ptr = end = start = new U8[bufSize];\n}\n\nHexInStream::~HexInStream() {\n  delete [] start;\n}\n\n\nbool HexInStream::readHexAndShift(char c, int* v) {\n  c=tolower(c);\n  if ((c >= '0') && (c <= '9'))\n    *v = (*v << 4) + (c - '0');\n  else if ((c >= 'a') && (c <= 'f'))\n    *v = (*v << 4) + (c - 'a' + 10);\n  else\n    return false;\n  return true;\n}\n\nbool HexInStream::hexStrToBin(const char* s, char** data, size_t* length) {\n  size_t l=strlen(s);\n  if ((l % 2) == 0) {\n    delete [] *data;\n    *data = 0; *length = 0;\n    if (l == 0)\n      return true;\n    *data = new char[l/2];\n    *length = l/2;\n    for(size_t i=0;i<l;i+=2) {\n      int byte = 0;\n      if (!readHexAndShift(s[i], &byte) ||\n        !readHexAndShift(s[i+1], &byte))\n        goto decodeError;\n      (*data)[i/2] = byte;\n    }\n    return true;\n  }\ndecodeError:\n  delete [] *data;\n  *data = 0;\n  *length = 0;\n  return false;\n}\n\n\nsize_t HexInStream::pos() {\n  return offset + ptr - start;\n}\n\nsize_t HexInStream::overrun(size_t itemSize, size_t nItems, bool wait) {\n  if (itemSize > bufSize)\n    throw Exception(\"HexInStream overrun: max itemSize exceeded\");\n\n  if (end - ptr != 0)\n    memmove(start, ptr, end - ptr);\n\n  end -= ptr - start;\n  offset += ptr - start;\n  ptr = start;\n\n  while (end < ptr + itemSize) {\n    size_t n = in_stream.check(2, 1, wait);\n    if (n == 0) return 0;\n    const U8* iptr = in_stream.getptr();\n    const U8* eptr = in_stream.getend();\n    size_t length = min((eptr - iptr)/2, start + bufSize - end);\n\n    U8* optr = (U8*) end;\n    for (size_t i=0; i<length; i++) {\n      int v = 0;\n      readHexAndShift(iptr[i*2], &v);\n      readHexAndShift(iptr[i*2+1], &v);\n      optr[i] = v;\n    }\n\n    in_stream.setptr(iptr + length*2);\n    end += length;\n  }\n\n  if (itemSize * nItems > (size_t)(end - ptr))\n    nItems = (end - ptr) / itemSize;\n\n  return nItems;\n}\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#ifndef __RDR_HEX_INSTREAM_H__\n#define __RDR_HEX_INSTREAM_H__\n\n#include <rdr/InStream.h>\n\nnamespace rdr {\n\n  class HexInStream : public InStream {\n  public:\n\n    HexInStream(InStream& is, size_t bufSize=0);\n    virtual ~HexInStream();\n\n    size_t pos();\n\n    static bool readHexAndShift(char c, int* v);\n    static bool hexStrToBin(const char* s, char** data, size_t* length);\n\n  protected:\n    size_t overrun(size_t itemSize, size_t nItems, bool wait);\n\n  private:\n    size_t bufSize;\n    U8* start;\n    size_t offset;\n\n    InStream& in_stream;\n  };\n\n} // end of namespace rdr\n\n#endif\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#include <rdr/HexOutStream.h>\n#include <rdr/Exception.h>\n\nusing namespace rdr;\n\nconst int DEFAULT_BUF_LEN = 16384;\n\nstatic inline size_t min(size_t a, size_t b) {return a<b ? a : b;}\n\nHexOutStream::HexOutStream(OutStream& os, size_t buflen)\n: out_stream(os), offset(0), bufSize(buflen ? buflen : DEFAULT_BUF_LEN)\n{\n  if (bufSize % 2)\n    bufSize--;\n  ptr = start = new U8[bufSize];\n  end = start + bufSize;\n}\n\nHexOutStream::~HexOutStream() {\n  delete [] start;\n}\n\n\nchar HexOutStream::intToHex(int i) {\n  if ((i>=0) && (i<=9))\n    return '0'+i;\n  else if ((i>=10) && (i<=15))\n    return 'a'+(i-10);\n  else\n    throw rdr::Exception(\"intToHex failed\");\n}\n\nchar* HexOutStream::binToHexStr(const char* data, size_t length) {\n  char* buffer = new char[length*2+1];\n  for (size_t i=0; i<length; i++) {\n    buffer[i*2] = intToHex((data[i] >> 4) & 15);\n    buffer[i*2+1] = intToHex((data[i] & 15));\n    if (!buffer[i*2] || !buffer[i*2+1]) {\n      delete [] buffer;\n      return 0;\n    }\n  }\n  buffer[length*2] = 0;\n  return buffer;\n}\n\n\nvoid\nHexOutStream::writeBuffer() {\n  U8* pos = start;\n  while (pos != ptr) {\n    out_stream.check(2);\n    U8* optr = out_stream.getptr();\n    U8* oend = out_stream.getend();\n    size_t length = min(ptr-pos, (oend-optr)/2);\n\n    for (size_t i=0; i<length; i++) {\n      optr[i*2] = intToHex((pos[i] >> 4) & 0xf);\n      optr[i*2+1] = intToHex(pos[i] & 0xf);\n    }\n\n    out_stream.setptr(optr + length*2);\n    pos += length;\n  }\n  offset += ptr - start;\n  ptr = start;\n}\n\nsize_t HexOutStream::length()\n{\n  return offset + ptr - start;\n}\n\nvoid\nHexOutStream::flush() {\n  writeBuffer();\n  out_stream.flush();\n}\n\nsize_t\nHexOutStream::overrun(size_t itemSize, size_t nItems) {\n  if (itemSize > bufSize)\n    throw Exception(\"HexOutStream overrun: max itemSize exceeded\");\n\n  writeBuffer();\n\n  if (itemSize * nItems > (size_t)(end - ptr))\n    nItems = (end - ptr) / itemSize;\n\n  return nItems;\n}\n\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#ifndef __RDR_HEX_OUTSTREAM_H__\n#define __RDR_HEX_OUTSTREAM_H__\n\n#include <rdr/OutStream.h>\n\nnamespace rdr {\n\n  class HexOutStream : public OutStream {\n  public:\n\n    HexOutStream(OutStream& os, size_t buflen=0);\n    virtual ~HexOutStream();\n\n    void flush();\n    size_t length();\n\n    static char intToHex(int i);\n    static char* binToHexStr(const char* data, size_t length);\n\n  private:\n    void writeBuffer();\n    size_t overrun(size_t itemSize, size_t nItems);\n\n    OutStream& out_stream;\n\n    U8* start;\n    size_t offset;\n    size_t bufSize;\n  };\n\n}\n\n#endif\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n//\n// rdr::InStream marshalls data from a buffer stored in RDR (RFB Data\n// Representation).\n//\n\n#ifndef __RDR_INSTREAM_H__\n#define __RDR_INSTREAM_H__\n\n#include <rdr/types.h>\n#include <string.h> // for memcpy\n\nnamespace rdr {\n\n  class InStream {\n\n  public:\n\n    virtual ~InStream() {}\n\n    // check() ensures there is buffer data for at least one item of size\n    // itemSize bytes.  Returns the number of items in the buffer (up to a\n    // maximum of nItems).  If wait is false, then instead of blocking to wait\n    // for the bytes, zero is returned if the bytes are not immediately\n    // available.\n\n    inline size_t check(size_t itemSize, size_t nItems=1, bool wait=true)\n    {\n      if (ptr + itemSize * nItems > end) {\n        if (ptr + itemSize > end)\n          return overrun(itemSize, nItems, wait);\n\n        nItems = (end - ptr) / itemSize;\n      }\n      return nItems;\n    }\n\n    // checkNoWait() tries to make sure that the given number of bytes can\n    // be read without blocking.  It returns true if this is the case, false\n    // otherwise.  The length must be \"small\" (less than the buffer size).\n\n    inline bool checkNoWait(size_t length) { return check(length, 1, false)!=0; }\n\n    // readU/SN() methods read unsigned and signed N-bit integers.\n\n    inline U8  readU8()  { check(1); return *ptr++; }\n    inline U16 readU16() { check(2); int b0 = *ptr++; int b1 = *ptr++;\n                           return b0 << 8 | b1; }\n    inline U32 readU32() { check(4); int b0 = *ptr++; int b1 = *ptr++;\n                                     int b2 = *ptr++; int b3 = *ptr++;\n                           return b0 << 24 | b1 << 16 | b2 << 8 | b3; }\n\n    inline S8  readS8()  { return (S8) readU8();  }\n    inline S16 readS16() { return (S16)readU16(); }\n    inline S32 readS32() { return (S32)readU32(); }\n\n    // readString() reads a string - a U32 length followed by the data.\n    // Returns a null-terminated string - the caller should delete[] it\n    // afterwards.\n\n    char* readString();\n\n    // maxStringLength protects against allocating a huge buffer.  Set it\n    // higher if you need longer strings.\n\n    static U32 maxStringLength;\n\n    inline void skip(size_t bytes) {\n      while (bytes > 0) {\n        size_t n = check(1, bytes);\n        ptr += n;\n        bytes -= n;\n      }\n    }\n\n    // readBytes() reads an exact number of bytes.\n\n    void readBytes(void* data, size_t length) {\n      U8* dataPtr = (U8*)data;\n      U8* dataEnd = dataPtr + length;\n      while (dataPtr < dataEnd) {\n        size_t n = check(1, dataEnd - dataPtr);\n        memcpy(dataPtr, ptr, n);\n        ptr += n;\n        dataPtr += n;\n      }\n    }\n\n    // readOpaqueN() reads a quantity without byte-swapping.\n\n    inline U8  readOpaque8()  { return readU8(); }\n    inline U16 readOpaque16() { check(2); U16 r; ((U8*)&r)[0] = *ptr++;\n                                ((U8*)&r)[1] = *ptr++; return r; }\n    inline U32 readOpaque32() { check(4); U32 r; ((U8*)&r)[0] = *ptr++;\n                                ((U8*)&r)[1] = *ptr++; ((U8*)&r)[2] = *ptr++;\n                                ((U8*)&r)[3] = *ptr++; return r; }\n\n    // pos() returns the position in the stream.\n\n    virtual size_t pos() = 0;\n\n    // getptr(), getend() and setptr() are \"dirty\" methods which allow you to\n    // manipulate the buffer directly.  This is useful for a stream which is a\n    // wrapper around an underlying stream.\n\n    inline const U8* getptr() const { return ptr; }\n    inline const U8* getend() const { return end; }\n    inline void setptr(const U8* p) { ptr = p; }\n\n  private:\n\n    // overrun() is implemented by a derived class to cope with buffer overrun.\n    // It ensures there are at least itemSize bytes of buffer data.  Returns\n    // the number of items in the buffer (up to a maximum of nItems).  itemSize\n    // is supposed to be \"small\" (a few bytes).  If wait is false, then\n    // instead of blocking to wait for the bytes, zero is returned if the bytes\n    // are not immediately available.\n\n    virtual size_t overrun(size_t itemSize, size_t nItems, bool wait=true) = 0;\n\n  protected:\n\n    InStream() {}\n    const U8* ptr;\n    const U8* end;\n  };\n\n}\n\n#endif\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n//\n// rdr::MemInStream is an InStream which streams from a given memory buffer.\n// If the deleteWhenDone parameter is true then the buffer will be delete[]d in\n// the destructor.  Note that it is delete[]d as a U8* - strictly speaking this\n// means it ought to be new[]ed as a U8* as well, but on most platforms this\n// doesn't matter.\n//\n\n#ifndef __RDR_MEMINSTREAM_H__\n#define __RDR_MEMINSTREAM_H__\n\n#include <rdr/InStream.h>\n#include <rdr/Exception.h>\n\nnamespace rdr {\n\n  class MemInStream : public InStream {\n\n  public:\n\n    MemInStream(const void* data, size_t len, bool deleteWhenDone_=false)\n      : start((const U8*)data), deleteWhenDone(deleteWhenDone_)\n    {\n      ptr = start;\n      end = start + len;\n    }\n\n    virtual ~MemInStream() {\n      if (deleteWhenDone)\n        delete [] start;\n    }\n\n    size_t pos() { return ptr - start; }\n    void reposition(size_t pos) { ptr = start + pos; }\n\n  private:\n\n    size_t overrun(size_t itemSize, size_t nItems, bool wait) { throw EndOfStream(); }\n    const U8* start;\n    bool deleteWhenDone;\n  };\n\n}\n\n#endif\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n//\n// A MemOutStream grows as needed when data is written to it.\n//\n\n#ifndef __RDR_MEMOUTSTREAM_H__\n#define __RDR_MEMOUTSTREAM_H__\n\n#include <rdr/OutStream.h>\n\nnamespace rdr {\n\n  class MemOutStream : public OutStream {\n\n  public:\n\n    MemOutStream(int len=1024) {\n      start = ptr = new U8[len];\n      end = start + len;\n    }\n\n    virtual ~MemOutStream() {\n      delete [] start;\n    }\n\n    void writeBytes(const void* data, size_t length) {\n      check(length);\n      memcpy(ptr, data, length);\n      ptr += length;\n    }\n\n    size_t length() { return ptr - start; }\n    void clear() { ptr = start; };\n    void clearAndZero() { memset(start, 0, ptr-start); clear(); }\n    void reposition(size_t pos) { ptr = start + pos; }\n\n    // data() returns a pointer to the buffer.\n\n    const void* data() { return (const void*)start; }\n\n  protected:\n\n    // overrun() either doubles the buffer or adds enough space for nItems of\n    // size itemSize bytes.\n\n    size_t overrun(size_t itemSize, size_t nItems) {\n      size_t len = ptr - start + itemSize * nItems;\n      if (len < (size_t)(end - start) * 2)\n        len = (end - start) * 2;\n\n      U8* newStart = new U8[len];\n      memcpy(newStart, start, ptr - start);\n      ptr = newStart + (ptr - start);\n      delete [] start;\n      start = newStart;\n      end = newStart + len;\n\n      return nItems;\n    }\n\n    U8* start;\n  };\n\n}\n\n#endif\n", "/* Copyright (C) 2002-2003 RealVNC Ltd.  All Rights Reserved.\n *    \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n//\n// rdr::OutStream marshalls data into a buffer stored in RDR (RFB Data\n// Representation).\n//\n\n#ifndef __RDR_OUTSTREAM_H__\n#define __RDR_OUTSTREAM_H__\n\n#include <rdr/types.h>\n#include <rdr/InStream.h>\n#include <string.h> // for memcpy\n\nnamespace rdr {\n\n  class OutStream {\n\n  protected:\n\n    OutStream() {}\n\n  public:\n\n    virtual ~OutStream() {}\n\n    // check() ensures there is buffer space for at least one item of size\n    // itemSize bytes.  Returns the number of items which fit (up to a maximum\n    // of nItems).\n\n    inline size_t check(size_t itemSize, size_t nItems=1)\n    {\n      if (ptr + itemSize * nItems > end) {\n        if (ptr + itemSize > end)\n          return overrun(itemSize, nItems);\n\n        nItems = (end - ptr) / itemSize;\n      }\n      return nItems;\n    }\n\n    // writeU/SN() methods write unsigned and signed N-bit integers.\n\n    inline void writeU8( U8  u) { check(1); *ptr++ = u; }\n    inline void writeU16(U16 u) { check(2); *ptr++ = u >> 8; *ptr++ = (U8)u; }\n    inline void writeU32(U32 u) { check(4); *ptr++ = u >> 24; *ptr++ = u >> 16;\n                                            *ptr++ = u >> 8; *ptr++ = u; }\n\n    inline void writeS8( S8  s) { writeU8((U8)s); }\n    inline void writeS16(S16 s) { writeU16((U16)s); }\n    inline void writeS32(S32 s) { writeU32((U32)s); }\n\n    // writeString() writes a string - a U32 length followed by the data.  The\n    // given string should be null-terminated (but the terminating null is not\n    // written to the stream).\n\n    inline void writeString(const char* str) {\n      U32 len = strlen(str);\n      writeU32(len);\n      writeBytes(str, len);\n    }\n\n    inline void pad(size_t bytes) {\n      while (bytes-- > 0) writeU8(0);\n    }\n\n    inline void skip(size_t bytes) {\n      while (bytes > 0) {\n        size_t n = check(1, bytes);\n        ptr += n;\n        bytes -= n;\n      }\n    }\n\n    // writeBytes() writes an exact number of bytes.\n\n    void writeBytes(const void* data, size_t length) {\n      const U8* dataPtr = (const U8*)data;\n      const U8* dataEnd = dataPtr + length;\n      while (dataPtr < dataEnd) {\n        size_t n = check(1, dataEnd - dataPtr);\n        memcpy(ptr, dataPtr, n);\n        ptr += n;\n        dataPtr += n;\n      }\n    }\n\n    // copyBytes() efficiently transfers data between streams\n\n    void copyBytes(InStream* is, size_t length) {\n      while (length > 0) {\n        size_t n = check(1, length);\n        is->readBytes(ptr, n);\n        ptr += n;\n        length -= n;\n      }\n    }\n\n    // writeOpaqueN() writes a quantity without byte-swapping.\n\n    inline void writeOpaque8( U8  u) { writeU8(u); }\n    inline void writeOpaque16(U16 u) { check(2); *ptr++ = ((U8*)&u)[0];\n                                       *ptr++ = ((U8*)&u)[1]; }\n    inline void writeOpaque32(U32 u) { check(4); *ptr++ = ((U8*)&u)[0];\n                                       *ptr++ = ((U8*)&u)[1];\n                                       *ptr++ = ((U8*)&u)[2];\n                                       *ptr++ = ((U8*)&u)[3]; }\n\n    // length() returns the length of the stream.\n\n    virtual size_t length() = 0;\n\n    // flush() requests that the stream be flushed.\n\n    virtual void flush() {}\n\n    // getptr(), getend() and setptr() are \"dirty\" methods which allow you to\n    // manipulate the buffer directly.  This is useful for a stream which is a\n    // wrapper around an underlying stream.\n\n    inline U8* getptr() { return ptr; }\n    inline U8* getend() { return end; }\n    inline void setptr(U8* p) { ptr = p; }\n\n  private:\n\n    // overrun() is implemented by a derived class to cope with buffer overrun.\n    // It ensures there are at least itemSize bytes of buffer space.  Returns\n    // the number of items which fit (up to a maximum of nItems).  itemSize is\n    // supposed to be \"small\" (a few bytes).\n\n    virtual size_t overrun(size_t itemSize, size_t nItems) = 0;\n\n  protected:\n\n    U8* ptr;\n    U8* end;\n  };\n\n}\n\n#endif\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#include <rdr/RandomStream.h>\n#include <rdr/Exception.h>\n#include <rfb/LogWriter.h>\n#include <time.h>\n#include <stdlib.h>\n#ifndef WIN32\n#include <unistd.h>\n#include <errno.h>\n#else\n#define getpid() GetCurrentProcessId()\n#ifndef RFB_HAVE_WINCRYPT\n#pragma message(\"  NOTE: Not building WinCrypt-based RandomStream\")\n#endif\n#endif\n\nstatic rfb::LogWriter vlog(\"RandomStream\");\n\nusing namespace rdr;\n\nconst size_t DEFAULT_BUF_LEN = 256;\n\nunsigned int RandomStream::seed;\n\nRandomStream::RandomStream()\n  : offset(0)\n{\n  ptr = end = start = new U8[DEFAULT_BUF_LEN];\n\n#ifdef RFB_HAVE_WINCRYPT\n  provider = 0;\n  if (!CryptAcquireContext(&provider, 0, 0, PROV_RSA_FULL, 0)) {\n    if (GetLastError() == (DWORD)NTE_BAD_KEYSET) {\n      if (!CryptAcquireContext(&provider, 0, 0, PROV_RSA_FULL, CRYPT_NEWKEYSET)) {\n        vlog.error(\"unable to create keyset\");\n        provider = 0;\n      }\n    } else {\n      vlog.error(\"unable to acquire context\");\n      provider = 0;\n    }\n  }\n  if (!provider) {\n#else\n#ifndef WIN32\n  fp = fopen(\"/dev/urandom\", \"r\");\n  if (!fp)\n    fp = fopen(\"/dev/random\", \"r\");\n  if (!fp) {\n#else\n  {\n#endif\n#endif\n    vlog.error(\"no OS supplied random source - using rand()\");\n    seed += (unsigned int) time(0) + getpid() + getpid() * 987654 + rand();\n    srand(seed);\n  }\n}\n\nRandomStream::~RandomStream() {\n  delete [] start;\n\n#ifdef RFB_HAVE_WINCRYPT\n  if (provider)\n    CryptReleaseContext(provider, 0);\n#endif\n#ifndef WIN32\n  if (fp) fclose(fp);\n#endif\n}\n\nsize_t RandomStream::pos() {\n  return offset + ptr - start;\n}\n\nsize_t RandomStream::overrun(size_t itemSize, size_t nItems, bool wait) {\n  if (itemSize > DEFAULT_BUF_LEN)\n    throw Exception(\"RandomStream overrun: max itemSize exceeded\");\n\n  if (end - ptr != 0)\n    memmove(start, ptr, end - ptr);\n\n  end -= ptr - start;\n  offset += ptr - start;\n  ptr = start;\n\n  size_t length = start + DEFAULT_BUF_LEN - end;\n\n#ifdef RFB_HAVE_WINCRYPT\n  if (provider) {\n    if (!CryptGenRandom(provider, length, (U8*)end))\n      throw rdr::SystemException(\"unable to CryptGenRandom\", GetLastError());\n    end += length;\n  } else {\n#else\n#ifndef WIN32\n  if (fp) {\n    size_t n = fread((U8*)end, length, 1, fp);\n    if (n != 1)\n      throw rdr::SystemException(\"reading /dev/urandom or /dev/random failed\",\n                                 errno);\n    end += length;\n  } else {\n#else\n  {\n#endif\n#endif\n    for (size_t i=0; i<length; i++)\n      *(U8*)end++ = (int) (256.0*rand()/(RAND_MAX+1.0));\n  }\n\n  if (itemSize * nItems > (size_t)(end - ptr))\n    nItems = (end - ptr) / itemSize;\n\n  return nItems;\n}\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#ifndef __RDR_RANDOMSTREAM_H__\n#define __RDR_RANDOMSTREAM_H__\n\n#include <stdio.h>\n#include <rdr/InStream.h>\n\n#ifdef WIN32\n#include <windows.h>\n#include <wincrypt.h>\n#ifdef WINCRYPT32API\n#define RFB_HAVE_WINCRYPT\n#endif\n#endif\n\nnamespace rdr {\n\n  class RandomStream : public InStream {\n\n  public:\n\n    RandomStream();\n    virtual ~RandomStream();\n\n    size_t pos();\n\n  protected:\n    size_t overrun(size_t itemSize, size_t nItems, bool wait);\n\n  private:\n    U8* start;\n    size_t offset;\n\n    static unsigned int seed;\n#ifdef RFB_HAVE_WINCRYPT\n    HCRYPTPROV provider;\n#endif\n#ifndef WIN32\n    FILE* fp;\n#endif\n\n  };\n\n} // end of namespace rdr\n\n#endif\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * Copyright (C) 2005 Martin Koegler\n * Copyright (C) 2010 TigerVNC Team\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <rdr/Exception.h>\n#include <rdr/TLSException.h>\n#include <rdr/TLSInStream.h>\n#include <errno.h>\n\n#ifdef HAVE_GNUTLS \nusing namespace rdr;\n\nenum { DEFAULT_BUF_SIZE = 16384 };\n\nssize_t TLSInStream::pull(gnutls_transport_ptr_t str, void* data, size_t size)\n{\n  TLSInStream* self= (TLSInStream*) str;\n  InStream *in = self->in;\n\n  try {\n    if (!in->check(1, 1, false)) {\n      gnutls_transport_set_errno(self->session, EAGAIN);\n      return -1;\n    }\n\n    if (in->getend() - in->getptr() < (ptrdiff_t)size)\n      size = in->getend() - in->getptr();\n  \n    in->readBytes(data, size);\n\n  } catch (Exception& e) {\n    gnutls_transport_set_errno(self->session, EINVAL);\n    return -1;\n  }\n\n  return size;\n}\n\nTLSInStream::TLSInStream(InStream* _in, gnutls_session_t _session)\n  : session(_session), in(_in), bufSize(DEFAULT_BUF_SIZE), offset(0)\n{\n  gnutls_transport_ptr_t recv, send;\n\n  ptr = end = start = new U8[bufSize];\n\n  gnutls_transport_set_pull_function(session, pull);\n  gnutls_transport_get_ptr2(session, &recv, &send);\n  gnutls_transport_set_ptr2(session, this, send);\n}\n\nTLSInStream::~TLSInStream()\n{\n  gnutls_transport_set_pull_function(session, NULL);\n\n  delete[] start;\n}\n\nsize_t TLSInStream::pos()\n{\n  return offset + ptr - start;\n}\n\nsize_t TLSInStream::overrun(size_t itemSize, size_t nItems, bool wait)\n{\n  if (itemSize > bufSize)\n    throw Exception(\"TLSInStream overrun: max itemSize exceeded\");\n\n  if (end - ptr != 0)\n    memmove(start, ptr, end - ptr);\n\n  offset += ptr - start;\n  end -= ptr - start;\n  ptr = start;\n\n  while (end < start + itemSize) {\n    size_t n = readTLS((U8*) end, start + bufSize - end, wait);\n    if (!wait && n == 0)\n      return 0;\n    end += n;\n  }\n\n  if (itemSize * nItems > (size_t)(end - ptr))\n    nItems = (end - ptr) / itemSize;\n\n  return nItems;\n}\n\nsize_t TLSInStream::readTLS(U8* buf, size_t len, bool wait)\n{\n  int n;\n\n  n = in->check(1, 1, wait);\n  if (n == 0)\n    return 0;\n\n  n = gnutls_record_recv(session, (void *) buf, len);\n  if (n == GNUTLS_E_INTERRUPTED || n == GNUTLS_E_AGAIN)\n    return 0;\n\n  if (n < 0) throw TLSException(\"readTLS\", n);\n\n  return n;\n}\n\n#endif\n", "/* Copyright (C) 2005 Martin Koegler\n * Copyright (C) 2010 TigerVNC Team\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#ifndef __RDR_TLSINSTREAM_H__\n#define __RDR_TLSINSTREAM_H__\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#ifdef HAVE_GNUTLS\n\n#include <gnutls/gnutls.h>\n#include <rdr/InStream.h>\n\nnamespace rdr {\n\n  class TLSInStream : public InStream {\n  public:\n    TLSInStream(InStream* in, gnutls_session_t session);\n    virtual ~TLSInStream();\n\n    size_t pos();\n\n  private:\n    size_t overrun(size_t itemSize, size_t nItems, bool wait);\n    size_t readTLS(U8* buf, size_t len, bool wait);\n    static ssize_t pull(gnutls_transport_ptr_t str, void* data, size_t size);\n\n    gnutls_session_t session;\n    InStream* in;\n    size_t bufSize;\n    size_t offset;\n    U8* start;\n  };\n};\n\n#endif\n#endif\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * Copyright (C) 2005 Martin Koegler\n * Copyright (C) 2010 TigerVNC Team\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <rdr/Exception.h>\n#include <rdr/TLSException.h>\n#include <rdr/TLSOutStream.h>\n#include <errno.h>\n\n#ifdef HAVE_GNUTLS\nusing namespace rdr;\n\nenum { DEFAULT_BUF_SIZE = 16384 };\n\nssize_t TLSOutStream::push(gnutls_transport_ptr_t str, const void* data,\n\t\t\t\t   size_t size)\n{\n  TLSOutStream* self= (TLSOutStream*) str;\n  OutStream *out = self->out;\n\n  try {\n    out->writeBytes(data, size);\n    out->flush();\n  } catch (Exception& e) {\n    gnutls_transport_set_errno(self->session, EINVAL);\n    return -1;\n  }\n\n  return size;\n}\n\nTLSOutStream::TLSOutStream(OutStream* _out, gnutls_session_t _session)\n  : session(_session), out(_out), bufSize(DEFAULT_BUF_SIZE), offset(0)\n{\n  gnutls_transport_ptr_t recv, send;\n\n  ptr = start = new U8[bufSize];\n  end = start + bufSize;\n\n  gnutls_transport_set_push_function(session, push);\n  gnutls_transport_get_ptr2(session, &recv, &send);\n  gnutls_transport_set_ptr2(session, recv, this);\n}\n\nTLSOutStream::~TLSOutStream()\n{\n#if 0\n  try {\n//    flush();\n  } catch (Exception&) {\n  }\n#endif\n  gnutls_transport_set_push_function(session, NULL);\n\n  delete [] start;\n}\n\nsize_t TLSOutStream::length()\n{\n  return offset + ptr - start;\n}\n\nvoid TLSOutStream::flush()\n{\n  U8* sentUpTo = start;\n  while (sentUpTo < ptr) {\n    size_t n = writeTLS(sentUpTo, ptr - sentUpTo);\n    sentUpTo += n;\n    offset += n;\n  }\n\n  ptr = start;\n  out->flush();\n}\n\nsize_t TLSOutStream::overrun(size_t itemSize, size_t nItems)\n{\n  if (itemSize > bufSize)\n    throw Exception(\"TLSOutStream overrun: max itemSize exceeded\");\n\n  flush();\n\n  if (itemSize * nItems > (size_t)(end - ptr))\n    nItems = (end - ptr) / itemSize;\n\n  return nItems;\n}\n\nsize_t TLSOutStream::writeTLS(const U8* data, size_t length)\n{\n  int n;\n\n  n = gnutls_record_send(session, data, length);\n  if (n == GNUTLS_E_INTERRUPTED || n == GNUTLS_E_AGAIN)\n    return 0;\n\n  if (n < 0)\n    throw TLSException(\"writeTLS\", n);\n\n  return n;\n}\n\n#endif\n", "/* Copyright (C) 2005 Martin Koegler\n * Copyright (C) 2010 TigerVNC Team\n *\n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#ifndef __RDR_TLSOUTSTREAM_H__\n#define __RDR_TLSOUTSTREAM_H__\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#ifdef HAVE_GNUTLS\n#include <gnutls/gnutls.h>\n#include <rdr/OutStream.h>\n\nnamespace rdr {\n\n  class TLSOutStream : public OutStream {\n  public:\n    TLSOutStream(OutStream* out, gnutls_session_t session);\n    virtual ~TLSOutStream();\n\n    void flush();\n    size_t length();\n\n  protected:\n    size_t overrun(size_t itemSize, size_t nItems);\n\n  private:\n    size_t writeTLS(const U8* data, size_t length);\n    static ssize_t push(gnutls_transport_ptr_t str, const void* data, size_t size);\n\n    gnutls_session_t session;\n    OutStream* out;\n    size_t bufSize;\n    U8* start;\n    size_t offset;\n  };\n};\n\n#endif\n#endif\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#include <assert.h>\n\n#include <rdr/ZlibInStream.h>\n#include <rdr/Exception.h>\n#include <zlib.h>\n\nusing namespace rdr;\n\nenum { DEFAULT_BUF_SIZE = 16384 };\n\nZlibInStream::ZlibInStream(size_t bufSize_)\n  : underlying(0), bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0),\n    zs(NULL), bytesIn(0)\n{\n  ptr = end = start = new U8[bufSize];\n  init();\n}\n\nZlibInStream::~ZlibInStream()\n{\n  deinit();\n  delete [] start;\n}\n\nvoid ZlibInStream::setUnderlying(InStream* is, size_t bytesIn_)\n{\n  underlying = is;\n  bytesIn = bytesIn_;\n  ptr = end = start;\n}\n\nsize_t ZlibInStream::pos()\n{\n  return offset + ptr - start;\n}\n\nvoid ZlibInStream::flushUnderlying()\n{\n  ptr = end = start;\n\n  while (bytesIn > 0) {\n    decompress(true);\n    end = start; // throw away any data\n  }\n\n  setUnderlying(NULL, 0);\n}\n\nvoid ZlibInStream::reset()\n{\n  deinit();\n  init();\n}\n\nvoid ZlibInStream::init()\n{\n  assert(zs == NULL);\n\n  zs = new z_stream;\n  zs->zalloc    = Z_NULL;\n  zs->zfree     = Z_NULL;\n  zs->opaque    = Z_NULL;\n  zs->next_in   = Z_NULL;\n  zs->avail_in  = 0;\n  if (inflateInit(zs) != Z_OK) {\n    delete zs;\n    zs = NULL;\n    throw Exception(\"ZlibInStream: inflateInit failed\");\n  }\n}\n\nvoid ZlibInStream::deinit()\n{\n  assert(zs != NULL);\n  setUnderlying(NULL, 0);\n  inflateEnd(zs);\n  delete zs;\n  zs = NULL;\n}\n\nsize_t ZlibInStream::overrun(size_t itemSize, size_t nItems, bool wait)\n{\n  if (itemSize > bufSize)\n    throw Exception(\"ZlibInStream overrun: max itemSize exceeded\");\n\n  if (end - ptr != 0)\n    memmove(start, ptr, end - ptr);\n\n  offset += ptr - start;\n  end -= ptr - start;\n  ptr = start;\n\n  while ((size_t)(end - ptr) < itemSize) {\n    if (!decompress(wait))\n      return 0;\n  }\n\n  if (itemSize * nItems > (size_t)(end - ptr))\n    nItems = (end - ptr) / itemSize;\n\n  return nItems;\n}\n\n// decompress() calls the decompressor once.  Note that this won't necessarily\n// generate any output data - it may just consume some input data.  Returns\n// false if wait is false and we would block on the underlying stream.\n\nbool ZlibInStream::decompress(bool wait)\n{\n  if (!underlying)\n    throw Exception(\"ZlibInStream overrun: no underlying stream\");\n\n  zs->next_out = (U8*)end;\n  zs->avail_out = start + bufSize - end;\n\n  size_t n = underlying->check(1, 1, wait);\n  if (n == 0) return false;\n  zs->next_in = (U8*)underlying->getptr();\n  zs->avail_in = underlying->getend() - underlying->getptr();\n  if (zs->avail_in > bytesIn)\n    zs->avail_in = bytesIn;\n\n  int rc = inflate(zs, Z_SYNC_FLUSH);\n  if (rc != Z_OK) {\n    throw Exception(\"ZlibInStream: inflate failed\");\n  }\n\n  bytesIn -= zs->next_in - underlying->getptr();\n  end = zs->next_out;\n  underlying->setptr(zs->next_in);\n  return true;\n}\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n//\n// ZlibInStream streams from a compressed data stream (\"underlying\"),\n// decompressing with zlib on the fly.\n//\n\n#ifndef __RDR_ZLIBINSTREAM_H__\n#define __RDR_ZLIBINSTREAM_H__\n\n#include <rdr/InStream.h>\n\nstruct z_stream_s;\n\nnamespace rdr {\n\n  class ZlibInStream : public InStream {\n\n  public:\n\n    ZlibInStream(size_t bufSize=0);\n    virtual ~ZlibInStream();\n\n    void setUnderlying(InStream* is, size_t bytesIn);\n    void flushUnderlying();\n    size_t pos();\n    void reset();\n\n  private:\n\n    void init();\n    void deinit();\n\n    size_t overrun(size_t itemSize, size_t nItems, bool wait);\n    bool decompress(bool wait);\n\n    InStream* underlying;\n    size_t bufSize;\n    size_t offset;\n    z_stream_s* zs;\n    size_t bytesIn;\n    U8* start;\n  };\n\n} // end of namespace rdr\n\n#endif\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * Copyright (C) 2011 D. R. Commander.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#include <stdio.h>\n\n#include <rdr/ZlibOutStream.h>\n#include <rdr/Exception.h>\n#include <rfb/LogWriter.h>\n\n#include <zlib.h>\n\n#undef ZLIBOUT_DEBUG\n\nstatic rfb::LogWriter vlog(\"ZlibOutStream\");\n\nusing namespace rdr;\n\nenum { DEFAULT_BUF_SIZE = 16384 };\n\nZlibOutStream::ZlibOutStream(OutStream* os, size_t bufSize_, int compressLevel)\n  : underlying(os), compressionLevel(compressLevel), newLevel(compressLevel),\n    bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0)\n{\n  zs = new z_stream;\n  zs->zalloc    = Z_NULL;\n  zs->zfree     = Z_NULL;\n  zs->opaque    = Z_NULL;\n  zs->next_in   = Z_NULL;\n  zs->avail_in  = 0;\n  if (deflateInit(zs, compressLevel) != Z_OK) {\n    delete zs;\n    throw Exception(\"ZlibOutStream: deflateInit failed\");\n  }\n  ptr = start = new U8[bufSize];\n  end = start + bufSize;\n}\n\nZlibOutStream::~ZlibOutStream()\n{\n  try {\n    flush();\n  } catch (Exception&) {\n  }\n  delete [] start;\n  deflateEnd(zs);\n  delete zs;\n}\n\nvoid ZlibOutStream::setUnderlying(OutStream* os)\n{\n  underlying = os;\n}\n\nvoid ZlibOutStream::setCompressionLevel(int level)\n{\n  if (level < -1 || level > 9)\n    level = -1;                 // Z_DEFAULT_COMPRESSION\n\n  newLevel = level;\n}\n\nsize_t ZlibOutStream::length()\n{\n  return offset + ptr - start;\n}\n\nvoid ZlibOutStream::flush()\n{\n  checkCompressionLevel();\n\n  zs->next_in = start;\n  zs->avail_in = ptr - start;\n\n#ifdef ZLIBOUT_DEBUG\n  vlog.debug(\"flush: avail_in %d\",zs->avail_in);\n#endif\n\n  // Force out everything from the zlib encoder\n  deflate(Z_SYNC_FLUSH);\n\n  offset += ptr - start;\n  ptr = start;\n}\n\nsize_t ZlibOutStream::overrun(size_t itemSize, size_t nItems)\n{\n#ifdef ZLIBOUT_DEBUG\n  vlog.debug(\"overrun\");\n#endif\n\n  if (itemSize > bufSize)\n    throw Exception(\"ZlibOutStream overrun: max itemSize exceeded\");\n\n  checkCompressionLevel();\n\n  while ((size_t)(end - ptr) < itemSize) {\n    zs->next_in = start;\n    zs->avail_in = ptr - start;\n\n    deflate(Z_NO_FLUSH);\n\n    // output buffer not full\n\n    if (zs->avail_in == 0) {\n      offset += ptr - start;\n      ptr = start;\n    } else {\n      // but didn't consume all the data?  try shifting what's left to the\n      // start of the buffer.\n      vlog.info(\"z out buf not full, but in data not consumed\");\n      memmove(start, zs->next_in, ptr - zs->next_in);\n      offset += zs->next_in - start;\n      ptr -= zs->next_in - start;\n    }\n  }\n\n  if (itemSize * nItems > (size_t)(end - ptr))\n    nItems = (end - ptr) / itemSize;\n\n  return nItems;\n}\n\nvoid ZlibOutStream::deflate(int flush)\n{\n  int rc;\n\n  if (!underlying)\n    throw Exception(\"ZlibOutStream: underlying OutStream has not been set\");\n\n  if ((flush == Z_NO_FLUSH) && (zs->avail_in == 0))\n    return;\n\n  do {\n    underlying->check(1);\n    zs->next_out = underlying->getptr();\n    zs->avail_out = underlying->getend() - underlying->getptr();\n\n#ifdef ZLIBOUT_DEBUG\n    vlog.debug(\"calling deflate, avail_in %d, avail_out %d\",\n               zs->avail_in,zs->avail_out);\n#endif\n\n    rc = ::deflate(zs, flush);\n    if (rc != Z_OK) {\n      // Silly zlib returns an error if you try to flush something twice\n      if ((rc == Z_BUF_ERROR) && (flush != Z_NO_FLUSH))\n        break;\n\n      throw Exception(\"ZlibOutStream: deflate failed\");\n    }\n\n#ifdef ZLIBOUT_DEBUG\n    vlog.debug(\"after deflate: %d bytes\",\n               zs->next_out-underlying->getptr());\n#endif\n\n    underlying->setptr(zs->next_out);\n  } while (zs->avail_out == 0);\n}\n\nvoid ZlibOutStream::checkCompressionLevel()\n{\n  int rc;\n\n  if (newLevel != compressionLevel) {\n#ifdef ZLIBOUT_DEBUG\n    vlog.debug(\"change: avail_in %d\",zs->avail_in);\n#endif\n\n    // zlib is just horribly stupid. It does an implicit flush on\n    // parameter changes, but the flush it does is not one that forces\n    // out all the data. And since you cannot flush things again, we\n    // cannot force out our data after the parameter change. Hence we\n    // need to do a more proper flush here first.\n    deflate(Z_SYNC_FLUSH);\n\n    rc = deflateParams (zs, newLevel, Z_DEFAULT_STRATEGY);\n    if (rc != Z_OK) {\n      // The implicit flush can result in this error, caused by the\n      // explicit flush we did above. It should be safe to ignore though\n      // as the first flush should have left things in a stable state...\n      if (rc != Z_BUF_ERROR)\n        throw Exception(\"ZlibOutStream: deflateParams failed\");\n    }\n\n    compressionLevel = newLevel;\n  }\n}\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * Copyright (C) 2011 D. R. Commander.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n//\n// ZlibOutStream streams to a compressed data stream (underlying), compressing\n// with zlib on the fly.\n//\n\n#ifndef __RDR_ZLIBOUTSTREAM_H__\n#define __RDR_ZLIBOUTSTREAM_H__\n\n#include <rdr/OutStream.h>\n\nstruct z_stream_s;\n\nnamespace rdr {\n\n  class ZlibOutStream : public OutStream {\n\n  public:\n\n    ZlibOutStream(OutStream* os=0, size_t bufSize=0, int compressionLevel=-1);\n    virtual ~ZlibOutStream();\n\n    void setUnderlying(OutStream* os);\n    void setCompressionLevel(int level=-1);\n    void flush();\n    size_t length();\n\n  private:\n\n    size_t overrun(size_t itemSize, size_t nItems);\n    void deflate(int flush);\n    void checkCompressionLevel();\n\n    OutStream* underlying;\n    int compressionLevel;\n    int newLevel;\n    size_t bufSize;\n    size_t offset;\n    z_stream_s* zs;\n    U8* start;\n  };\n\n} // end of namespace rdr\n\n#endif\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * Copyright 2004-2005 Cendio AB.\n * Copyright 2017 Peter Astrand <astrand@cendio.se> for Cendio AB\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n// -=- Configuration.cxx\n\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n\n#include <os/Mutex.h>\n\n#include <rfb/util.h>\n#include <rfb/Configuration.h>\n#include <rfb/LogWriter.h>\n#include <rfb/Exception.h>\n\n#define LOCK_CONFIG os::AutoMutex a(mutex)\n\n#include <rdr/HexOutStream.h>\n#include <rdr/HexInStream.h>\n\nusing namespace rfb;\n\nstatic LogWriter vlog(\"Config\");\n\n\n// -=- The Global/server/viewer Configuration objects\nConfiguration* Configuration::global_ = 0;\nConfiguration* Configuration::server_ = 0;\nConfiguration* Configuration::viewer_ = 0;\n\nConfiguration* Configuration::global() {\n  if (!global_)\n    global_ = new Configuration(\"Global\");\n  return global_;\n}\n\nConfiguration* Configuration::server() {\n  if (!server_)\n    server_ = new Configuration(\"Server\");\n  return server_;\n}\n\nConfiguration* Configuration::viewer() {\n  if (!viewer_)\n    viewer_ = new Configuration(\"Viewer\");\n  return viewer_;\n}\n\n// -=- Configuration implementation\n\nbool Configuration::set(const char* n, const char* v, bool immutable) {\n  return set(n, strlen(n), v, immutable);\n}\n\nbool Configuration::set(const char* name, int len,\n                             const char* val, bool immutable)\n{\n  VoidParameter* current = head;\n  while (current) {\n    if ((int)strlen(current->getName()) == len &&\n        strncasecmp(current->getName(), name, len) == 0)\n    {\n      bool b = current->setParam(val);\n      if (b && immutable) \n\tcurrent->setImmutable();\n      return b;\n    }\n    current = current->_next;\n  }\n  return _next ? _next->set(name, len, val, immutable) : false;\n}\n\nbool Configuration::set(const char* config, bool immutable) {\n  bool hyphen = false;\n  if (config[0] == '-') {\n    hyphen = true;\n    config++;\n    if (config[0] == '-') config++; // allow gnu-style --<option>\n  }\n  const char* equal = strchr(config, '=');\n  if (equal) {\n    return set(config, equal-config, equal+1, immutable);\n  } else if (hyphen) {\n    VoidParameter* current = head;\n    while (current) {\n      if (strcasecmp(current->getName(), config) == 0) {\n        bool b = current->setParam();\n        if (b && immutable) \n\t  current->setImmutable();\n        return b;\n      }\n      current = current->_next;\n    }\n  }    \n  return _next ? _next->set(config, immutable) : false;\n}\n\nVoidParameter* Configuration::get(const char* param)\n{\n  VoidParameter* current = head;\n  while (current) {\n    if (strcasecmp(current->getName(), param) == 0)\n      return current;\n    current = current->_next;\n  }\n  return _next ? _next->get(param) : 0;\n}\n\nvoid Configuration::list(int width, int nameWidth) {\n  VoidParameter* current = head;\n\n  fprintf(stderr, \"%s Parameters:\\n\", name.buf);\n  while (current) {\n    char* def_str = current->getDefaultStr();\n    const char* desc = current->getDescription();\n    fprintf(stderr,\"  %-*s -\", nameWidth, current->getName());\n    int column = strlen(current->getName());\n    if (column < nameWidth) column = nameWidth;\n    column += 4;\n    while (true) {\n      const char* s = strchr(desc, ' ');\n      int wordLen;\n      if (s) wordLen = s-desc;\n      else wordLen = strlen(desc);\n\n      if (column + wordLen + 1 > width) {\n        fprintf(stderr,\"\\n%*s\",nameWidth+4,\"\");\n        column = nameWidth+4;\n      }\n      fprintf(stderr,\" %.*s\",wordLen,desc);\n      column += wordLen + 1;\n      desc += wordLen + 1;\n      if (!s) break;\n    }\n\n    if (def_str) {\n      if (column + (int)strlen(def_str) + 11 > width)\n        fprintf(stderr,\"\\n%*s\",nameWidth+4,\"\");\n      fprintf(stderr,\" (default=%s)\\n\",def_str);\n      strFree(def_str);\n    } else {\n      fprintf(stderr,\"\\n\");\n    }\n    current = current->_next;\n  }\n\n  if (_next)\n    _next->list(width, nameWidth);\n}\n\n\nbool Configuration::remove(const char* param) {\n  VoidParameter *current = head;\n  VoidParameter **prevnext = &head;\n\n  while (current) {\n    if (strcasecmp(current->getName(), param) == 0) {\n      *prevnext = current->_next;\n      return true;\n    }\n    prevnext = &current->_next;\n    current = current->_next;\n  }\n\n  return false;\n}\n\n\n// -=- VoidParameter\n\nVoidParameter::VoidParameter(const char* name_, const char* desc_,\n\t\t\t     ConfigurationObject co)\n  : immutable(false), name(name_), description(desc_)\n{\n  Configuration *conf = NULL;\n\n  switch (co) {\n  case ConfGlobal: conf = Configuration::global();\n    break;\n  case ConfServer: conf = Configuration::server();\n    break;\n  case ConfViewer: conf = Configuration::viewer();\n    break;\n  }\n\n  _next = conf->head;\n  conf->head = this;\n\n  mutex = new os::Mutex();\n}\n\nVoidParameter::~VoidParameter() {\n  delete mutex;\n}\n\nconst char*\nVoidParameter::getName() const {\n  return name;\n}\n\nconst char*\nVoidParameter::getDescription() const {\n  return description;\n}\n\nbool VoidParameter::setParam() {\n  return false;\n}\n\nbool VoidParameter::isBool() const {\n  return false;\n}\n\nvoid\nVoidParameter::setImmutable() {\n  vlog.debug(\"set immutable %s\", getName());\n  immutable = true;\n}\n\n// -=- AliasParameter\n\nAliasParameter::AliasParameter(const char* name_, const char* desc_,\n                               VoidParameter* param_, ConfigurationObject co)\n  : VoidParameter(name_, desc_, co), param(param_) {\n}\n\nbool\nAliasParameter::setParam(const char* v) {\n  return param->setParam(v);\n}\n\nbool AliasParameter::setParam() {\n  return param->setParam();\n}\n\nchar*\nAliasParameter::getDefaultStr() const {\n  return 0;\n}\n\nchar* AliasParameter::getValueStr() const {\n  return param->getValueStr();\n}\n\nbool AliasParameter::isBool() const {\n  return param->isBool();\n}\n\nvoid\nAliasParameter::setImmutable() {\n  vlog.debug(\"set immutable %s (Alias)\", getName());\n  param->setImmutable();\n}\n\n\n// -=- BoolParameter\n\nBoolParameter::BoolParameter(const char* name_, const char* desc_, bool v,\n\t\t\t     ConfigurationObject co)\n: VoidParameter(name_, desc_, co), value(v), def_value(v) {\n}\n\nbool\nBoolParameter::setParam(const char* v) {\n  if (immutable) return true;\n\n  if (*v == 0 || strcasecmp(v, \"1\") == 0 || strcasecmp(v, \"on\") == 0\n      || strcasecmp(v, \"true\") == 0 || strcasecmp(v, \"yes\") == 0)\n    value = 1;\n  else if (strcasecmp(v, \"0\") == 0 || strcasecmp(v, \"off\") == 0\n           || strcasecmp(v, \"false\") == 0 || strcasecmp(v, \"no\") == 0)\n    value = 0;\n  else {\n    vlog.error(\"Bool parameter %s: invalid value '%s'\", getName(), v);\n    return false;\n  }\n\n  vlog.debug(\"set %s(Bool) to %s(%d)\", getName(), v, value);\n  return true;\n}\n\nbool BoolParameter::setParam() {\n  setParam(true);\n  return true;\n}\n\nvoid BoolParameter::setParam(bool b) {\n  if (immutable) return;\n  value = b;\n  vlog.debug(\"set %s(Bool) to %d\", getName(), value);\n}\n\nchar*\nBoolParameter::getDefaultStr() const {\n  return strDup(def_value ? \"1\" : \"0\");\n}\n\nchar* BoolParameter::getValueStr() const {\n  return strDup(value ? \"1\" : \"0\");\n}\n\nbool BoolParameter::isBool() const {\n  return true;\n}\n\nBoolParameter::operator bool() const {\n  return value;\n}\n\n// -=- IntParameter\n\nIntParameter::IntParameter(const char* name_, const char* desc_, int v,\n                           int minValue_, int maxValue_, ConfigurationObject co)\n  : VoidParameter(name_, desc_, co), value(v), def_value(v),\n    minValue(minValue_), maxValue(maxValue_)\n{\n}\n\nbool\nIntParameter::setParam(const char* v) {\n  if (immutable) return true;\n  vlog.debug(\"set %s(Int) to %s\", getName(), v);\n  int i = strtol(v, NULL, 0);\n  if (i < minValue || i > maxValue)\n    return false;\n  value = i;\n  return true;\n}\n\nbool\nIntParameter::setParam(int v) {\n  if (immutable) return true;\n  vlog.debug(\"set %s(Int) to %d\", getName(), v);\n  if (v < minValue || v > maxValue)\n    return false;\n  value = v;\n  return true;\n}\n\nchar*\nIntParameter::getDefaultStr() const {\n  char* result = new char[16];\n  sprintf(result, \"%d\", def_value);\n  return result;\n}\n\nchar* IntParameter::getValueStr() const {\n  char* result = new char[16];\n  sprintf(result, \"%d\", value);\n  return result;\n}\n\nIntParameter::operator int() const {\n  return value;\n}\n\n// -=- StringParameter\n\nStringParameter::StringParameter(const char* name_, const char* desc_,\n                                 const char* v, ConfigurationObject co)\n  : VoidParameter(name_, desc_, co), value(strDup(v)), def_value(v)\n{\n  if (!v) {\n    vlog.error(\"Default value <null> for %s not allowed\",name_);\n    throw rfb::Exception(\"Default value <null> not allowed\");\n  }\n}\n\nStringParameter::~StringParameter() {\n  strFree(value);\n}\n\nvoid StringParameter::setDefaultStr(const char* v) {\n  def_value = v;\n  strFree(value);\n  value = strDup(v);\n}\n\nbool StringParameter::setParam(const char* v) {\n  LOCK_CONFIG;\n  if (immutable) return true;\n  if (!v)\n    throw rfb::Exception(\"setParam(<null>) not allowed\");\n  vlog.debug(\"set %s(String) to %s\", getName(), v);\n  CharArray oldValue(value);\n  value = strDup(v);\n  return value != 0;\n}\n\nchar* StringParameter::getDefaultStr() const {\n  return strDup(def_value);\n}\n\nchar* StringParameter::getValueStr() const {\n  LOCK_CONFIG;\n  return strDup(value);\n}\n\nStringParameter::operator const char *() const {\n  return value;\n}\n\n// -=- BinaryParameter\n\nBinaryParameter::BinaryParameter(const char* name_, const char* desc_,\n\t\t\t\t const void* v, size_t l, ConfigurationObject co)\n: VoidParameter(name_, desc_, co), value(0), length(0), def_value((char*)v), def_length(l) {\n  if (l) {\n    value = new char[l];\n    length = l;\n    memcpy(value, v, l);\n  }\n}\nBinaryParameter::~BinaryParameter() {\n  if (value)\n    delete [] value;\n}\n\nbool BinaryParameter::setParam(const char* v) {\n  LOCK_CONFIG;\n  if (immutable) return true;\n  vlog.debug(\"set %s(Binary) to %s\", getName(), v);\n  return rdr::HexInStream::hexStrToBin(v, &value, &length);\n}\n\nvoid BinaryParameter::setParam(const void* v, size_t len) {\n  LOCK_CONFIG;\n  if (immutable) return; \n  vlog.debug(\"set %s(Binary)\", getName());\n  delete [] value; value = 0;\n  if (len) {\n    value = new char[len];\n    length = len;\n    memcpy(value, v, len);\n  }\n}\n\nchar* BinaryParameter::getDefaultStr() const {\n  return rdr::HexOutStream::binToHexStr(def_value, def_length);\n}\n\nchar* BinaryParameter::getValueStr() const {\n  LOCK_CONFIG;\n  return rdr::HexOutStream::binToHexStr(value, length);\n}\n\nvoid BinaryParameter::getData(void** data_, size_t* length_) const {\n  LOCK_CONFIG;\n  if (length_) *length_ = length;\n  if (data_) {\n    *data_ = new char[length];\n    memcpy(*data_, value, length);\n  }\n}\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n// -=- Configuration.h\n//\n// This header defines a set of classes used to represent configuration\n// parameters of different types.  Instances of the different parameter\n// types are associated with instances of the Configuration class, and\n// are each given a unique name.  The Configuration class provides a\n// generic API through which parameters may be located by name and their\n// value set, thus removing the need to write platform-specific code.\n// Simply defining a new parameter and associating it with a Configuration\n// will allow it to be configured by the user.\n//\n// If no Configuration is specified when creating a Parameter, then the\n// global Configuration will be assumed.\n//\n// Configurations can be \"chained\" into groups.  Each group has a root\n// Configuration, a pointer to which should be passed to the constructors\n// of the other group members.  set() and get() operations called on the\n// root will iterate through all of the group's members.\n//\n// NB: On platforms that support Threading, locking is performed to protect\n//     complex parameter types from concurrent access (e.g. strings).\n// NB: NO LOCKING is performed when linking Configurations to groups\n//     or when adding Parameters to Configurations.\n\n#ifndef __RFB_CONFIGURATION_H__\n#define __RFB_CONFIGURATION_H__\n\n#include <rfb/util.h>\n\nnamespace os { class Mutex; }\n\nnamespace rfb {\n  class VoidParameter;\n  struct ParameterIterator;\n\n  enum ConfigurationObject { ConfGlobal, ConfServer, ConfViewer };\n\n  // -=- Configuration\n  //     Class used to access parameters.\n\n  class Configuration {\n  public:\n    // - Create a new Configuration object\n    Configuration(const char* name_) : name(strDup(name_)), head(0), _next(0) {}\n\n    // - Return the buffer containing the Configuration's name\n    const char* getName() const { return name.buf; }\n\n    // - Set named parameter to value\n    bool set(const char* param, const char* value, bool immutable=false);\n\n    // - Set parameter to value (separated by \"=\")\n    bool set(const char* config, bool immutable=false);\n\n    // - Set named parameter to value, with name truncated at len\n    bool set(const char* name, int len,\n                  const char* val, bool immutable);\n\n    // - Get named parameter\n    VoidParameter* get(const char* param);\n\n    // - List the parameters of this Configuration group\n    void list(int width=79, int nameWidth=10);\n\n    // - Remove a parameter from this Configuration group\n    bool remove(const char* param);\n\n    // - readFromFile\n    //   Read configuration parameters from the specified file.\n    void readFromFile(const char* filename);\n\n    // - writeConfigToFile\n    //   Write a new configuration parameters file, then mv it\n    //   over the old file.\n    void writeToFile(const char* filename);\n\n\n    // - Get the Global Configuration object\n    //   NB: This call does NOT lock the Configuration system.\n    //       ALWAYS ensure that if you have ANY global Parameters,\n    //       then they are defined as global objects, to ensure that\n    //       global() is called when only the main thread is running.\n    static Configuration* global();\n\n    // Enable server/viewer specific parameters\n    static void enableServerParams() { global()->appendConfiguration(server()); }\n    static void enableViewerParams() { global()->appendConfiguration(viewer()); }\n\n    // - Container for process-wide Global parameters\n    static bool setParam(const char* param, const char* value, bool immutable=false) {\n      return global()->set(param, value, immutable);\n    }\n    static bool setParam(const char* config, bool immutable=false) { \n      return global()->set(config, immutable);\n    }\n    static bool setParam(const char* name, int len,\n      const char* val, bool immutable) {\n      return global()->set(name, len, val, immutable);\n    }\n    static VoidParameter* getParam(const char* param) { return global()->get(param); }\n    static void listParams(int width=79, int nameWidth=10) {\n      global()->list(width, nameWidth);\n    }\n    static bool removeParam(const char* param) {\n      return global()->remove(param);\n    }\n\n  private:\n    friend class VoidParameter;\n    friend struct ParameterIterator;\n\n    // Name for this Configuration\n    CharArray name;\n\n    // - Pointer to first Parameter in this group\n    VoidParameter* head;\n\n    // Pointer to next Configuration in this group\n    Configuration* _next;\n\n    // The process-wide, Global Configuration object\n    static Configuration* global_;\n\n    // The server only Configuration object\n    static Configuration* server_;\n\n    // The viewer only Configuration object\n    static Configuration* viewer_;\n\n    // Get server/viewer specific configuration object\n    static Configuration* server();\n    static Configuration* viewer();\n\n    // Append configuration object to this instance.\n    // NOTE: conf instance can be only one configuration object\n    void appendConfiguration(Configuration *conf) {\n      conf->_next = _next; _next = conf;\n    }\n  };\n\n  // -=- VoidParameter\n  //     Configuration parameter base-class.\n\n  class VoidParameter {\n  public:\n    VoidParameter(const char* name_, const char* desc_, ConfigurationObject co=ConfGlobal);\n    virtual  ~VoidParameter();\n    const char* getName() const;\n    const char* getDescription() const;\n\n    virtual bool setParam(const char* value)  = 0;\n    virtual bool setParam();\n    virtual char* getDefaultStr() const = 0;\n    virtual char* getValueStr() const = 0;\n    virtual bool isBool() const;\n\n    virtual void setImmutable();\n\n  protected:\n    friend class Configuration;\n    friend struct ParameterIterator;\n\n    VoidParameter* _next;\n    bool immutable;\n    const char* name;\n    const char* description;\n\n    os::Mutex* mutex;\n  };\n\n  class AliasParameter : public VoidParameter {\n  public:\n    AliasParameter(const char* name_, const char* desc_,VoidParameter* param_,\n\t\t   ConfigurationObject co=ConfGlobal);\n    virtual bool setParam(const char* value);\n    virtual bool setParam();\n    virtual char* getDefaultStr() const;\n    virtual char* getValueStr() const;\n    virtual bool isBool() const;\n    virtual void setImmutable();\n  private:\n    VoidParameter* param;\n  };\n\n  class BoolParameter : public VoidParameter {\n  public:\n    BoolParameter(const char* name_, const char* desc_, bool v,\n\t\t  ConfigurationObject co=ConfGlobal);\n    virtual bool setParam(const char* value);\n    virtual bool setParam();\n    virtual void setParam(bool b);\n    virtual char* getDefaultStr() const;\n    virtual char* getValueStr() const;\n    virtual bool isBool() const;\n    operator bool() const;\n  protected:\n    bool value;\n    bool def_value;\n  };\n\n  class IntParameter : public VoidParameter {\n  public:\n    IntParameter(const char* name_, const char* desc_, int v,\n                 int minValue=INT_MIN, int maxValue=INT_MAX,\n\t\t ConfigurationObject co=ConfGlobal);\n    using VoidParameter::setParam;\n    virtual bool setParam(const char* value);\n    virtual bool setParam(int v);\n    virtual char* getDefaultStr() const;\n    virtual char* getValueStr() const;\n    operator int() const;\n  protected:\n    int value;\n    int def_value;\n    int minValue, maxValue;\n  };\n\n  class StringParameter : public VoidParameter {\n  public:\n    // StringParameter contains a null-terminated string, which CANNOT\n    // be Null, and so neither can the default value!\n    StringParameter(const char* name_, const char* desc_, const char* v,\n\t\t    ConfigurationObject co=ConfGlobal);\n    virtual ~StringParameter();\n    virtual bool setParam(const char* value);\n    virtual char* getDefaultStr() const;\n    virtual char* getValueStr() const;\n    void setDefaultStr(const char* v);\n    operator const char*() const;\n\n    // getData() returns a copy of the data - it must be delete[]d by the\n    // caller.\n    char* getData() const { return getValueStr(); }\n  protected:\n    char* value;\n    const char* def_value;\n  };\n\n  class BinaryParameter : public VoidParameter {\n  public:\n    BinaryParameter(const char* name_, const char* desc_,\n                    const void* v, size_t l,\n                    ConfigurationObject co=ConfGlobal);\n    using VoidParameter::setParam;\n    virtual ~BinaryParameter();\n    virtual bool setParam(const char* value);\n    virtual void setParam(const void* v, size_t l);\n    virtual char* getDefaultStr() const;\n    virtual char* getValueStr() const;\n\n    // getData() will return length zero if there is no data\n    // NB: data may be set to zero, OR set to a zero-length buffer\n    void getData(void** data, size_t* length) const;\n\n  protected:\n    char* value;\n    size_t length;\n    char* def_value;\n    size_t def_length;\n  };\n\n  // -=- ParameterIterator\n  //     Iterates over all enabled parameters (global + server/viewer).\n  //     Current Parameter is accessed via param, the current Configuration\n  //     via config. The next() method moves on to the next Parameter.\n\n  struct ParameterIterator {\n    ParameterIterator() : config(Configuration::global()), param(config->head) {}\n    void next() {\n      param = param->_next;\n      while (!param) {\n        config = config->_next;\n        if (!config) break;\n        param = config->head;\n      }\n    }\n    Configuration* config;\n    VoidParameter* param;\n  };\n\n};\n\n#endif // __RFB_CONFIGURATION_H__\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n//\n// XXX not thread-safe, because d3des isn't - do we need to worry about this?\n//\n\n#include <string.h>\nextern \"C\" {\n#include <rfb/d3des.h>\n}\n#include <rdr/types.h>\n#include <rdr/Exception.h>\n#include <rfb/Password.h>\n\nusing namespace rfb;\n\nstatic unsigned char d3desObfuscationKey[] = {23,82,107,6,35,78,88,7};\n\n\nPlainPasswd::PlainPasswd() {}\n\nPlainPasswd::PlainPasswd(char* pwd) : CharArray(pwd) {\n}\n\nPlainPasswd::PlainPasswd(size_t len) : CharArray(len) {\n}\n\nPlainPasswd::PlainPasswd(const ObfuscatedPasswd& obfPwd) : CharArray(9) {\n  if (obfPwd.length < 8)\n    throw rdr::Exception(\"bad obfuscated password length\");\n  deskey(d3desObfuscationKey, DE1);\n  des((rdr::U8*)obfPwd.buf, (rdr::U8*)buf);\n  buf[8] = 0;\n}\n\nPlainPasswd::~PlainPasswd() {\n  replaceBuf(0);\n}\n\nvoid PlainPasswd::replaceBuf(char* b) {\n  if (buf)\n    memset(buf, 0, strlen(buf));\n  CharArray::replaceBuf(b);\n}\n\n\nObfuscatedPasswd::ObfuscatedPasswd() : length(0) {\n}\n\nObfuscatedPasswd::ObfuscatedPasswd(size_t len) : CharArray(len), length(len) {\n}\n\nObfuscatedPasswd::ObfuscatedPasswd(const PlainPasswd& plainPwd) : CharArray(8), length(8) {\n  size_t l = strlen(plainPwd.buf), i;\n  for (i=0; i<8; i++)\n    buf[i] = i<l ? plainPwd.buf[i] : 0;\n  deskey(d3desObfuscationKey, EN0);\n  des((rdr::U8*)buf, (rdr::U8*)buf);\n}\n\nObfuscatedPasswd::~ObfuscatedPasswd() {\n  if (buf)\n    memset(buf, 0, length);\n}\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n#ifndef __RFB_PASSWORD_H__\n#define __RFB_PASSWORD_H__\n\n#include <rfb/util.h>\n\nnamespace rfb {\n\n  class ObfuscatedPasswd;\n\n  class PlainPasswd : public CharArray {\n  public:\n    PlainPasswd();\n    PlainPasswd(char* pwd);\n    PlainPasswd(size_t len);\n    PlainPasswd(const ObfuscatedPasswd& obfPwd);\n    ~PlainPasswd();\n    void replaceBuf(char* b);\n  };\n\n  class ObfuscatedPasswd : public CharArray {\n  public:\n    ObfuscatedPasswd();\n    ObfuscatedPasswd(size_t l);\n    ObfuscatedPasswd(const PlainPasswd& plainPwd);\n    ~ObfuscatedPasswd();\n    size_t length;\n  };\n\n}\n#endif\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * Copyright 2011-2019 Pierre Ossman for Cendio AB\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n//\n// util.h - miscellaneous useful bits\n//\n\n#ifndef __RFB_UTIL_H__\n#define __RFB_UTIL_H__\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <limits.h>\n#include <string.h>\n\nstruct timeval;\n\n#ifdef __GNUC__\n#  define __printf_attr(a, b) __attribute__((__format__ (__printf__, a, b)))\n#else\n#  define __printf_attr(a, b)\n#endif // __GNUC__\n\n#ifndef __unused_attr\n#  define __unused_attr __attribute((__unused__))\n#endif\n\nnamespace rfb {\n\n  // -=- Class to handle cleanup of arrays of characters\n  class CharArray {\n  public:\n    CharArray() : buf(0) {}\n    CharArray(char* str) : buf(str) {} // note: assumes ownership\n    CharArray(size_t len) {\n      buf = new char[len]();\n    }\n    ~CharArray() {\n      delete [] buf;\n    }\n    void format(const char *fmt, ...) __printf_attr(2, 3);\n    // Get the buffer pointer & clear it (i.e. caller takes ownership)\n    char* takeBuf() {char* tmp = buf; buf = 0; return tmp;}\n    void replaceBuf(char* b) {delete [] buf; buf = b;}\n    char* buf;\n  private:\n    CharArray(const CharArray&);\n    CharArray& operator=(const CharArray&);\n  };\n\n  char* strDup(const char* s);\n  void strFree(char* s);\n  void strFree(wchar_t* s);\n\n  // Returns true if split successful.  Returns false otherwise.\n  // ALWAYS *copies* first part of string to out1 buffer.\n  // If limiter not found, leaves out2 alone (null) and just copies to out1.\n  // If out1 or out2 non-zero, calls strFree and zeroes them.\n  // If fromEnd is true, splits at end of string rather than beginning.\n  // Either out1 or out2 may be null, in which case the split will not return\n  // that part of the string.  Obviously, setting both to 0 is not useful...\n  bool strSplit(const char* src, const char limiter, char** out1, char** out2, bool fromEnd=false);\n\n  // Returns true if src contains c\n  bool strContains(const char* src, char c);\n\n  // Copies src to dest, up to specified length-1, and guarantees termination\n  void strCopy(char* dest, const char* src, int destlen);\n\n  // Makes sure line endings are in a certain format\n\n  char* convertLF(const char* src, size_t bytes = (size_t)-1);\n  char* convertCRLF(const char* src, size_t bytes = (size_t)-1);\n\n  // Convertions between various Unicode formats. The returned strings are\n  // always null terminated and must be freed using strFree().\n\n  size_t ucs4ToUTF8(unsigned src, char* dst);\n  size_t utf8ToUCS4(const char* src, size_t max, unsigned* dst);\n\n  size_t ucs4ToUTF16(unsigned src, wchar_t* dst);\n  size_t utf16ToUCS4(const wchar_t* src, size_t max, unsigned* dst);\n\n  char* latin1ToUTF8(const char* src, size_t bytes = (size_t)-1);\n  char* utf8ToLatin1(const char* src, size_t bytes = (size_t)-1);\n\n  char* utf16ToUTF8(const wchar_t* src, size_t units = (size_t)-1);\n  wchar_t* utf8ToUTF16(const char* src, size_t bytes = (size_t)-1);\n\n  // HELPER functions for timeout handling\n\n  // soonestTimeout() is a function to help work out the soonest of several\n  //   timeouts.\n  inline void soonestTimeout(int* timeout, int newTimeout) {\n    if (newTimeout && (!*timeout || newTimeout < *timeout))\n      *timeout = newTimeout;\n  }\n\n  // secsToMillis() turns seconds into milliseconds, capping the value so it\n  //   can't wrap round and become -ve\n  inline int secsToMillis(int secs) {\n    return (secs < 0 || secs > (INT_MAX/1000) ? INT_MAX : secs * 1000);\n  }\n\n  // Returns time elapsed between two moments in milliseconds.\n  unsigned msBetween(const struct timeval *first,\n                     const struct timeval *second);\n\n  // Returns time elapsed since given moment in milliseconds.\n  unsigned msSince(const struct timeval *then);\n\n  // Returns true if first happened before seconds\n  bool isBefore(const struct timeval *first,\n                const struct timeval *second);\n\n  size_t siPrefix(long long value, const char *unit,\n                  char *buffer, size_t maxlen, int precision=6);\n  size_t iecPrefix(long long value, const char *unit,\n                   char *buffer, size_t maxlen, int precision=6);\n}\n\n// Some platforms (e.g. Windows) include max() and min() macros in their\n// standard headers, but they are also standard C++ template functions, so some\n// C++ headers will undefine them.  So we steer clear of the names min and max\n// and define __rfbmin and __rfbmax instead.\n\n#ifndef __rfbmax\n#define __rfbmax(a,b) (((a) > (b)) ? (a) : (b))\n#endif\n#ifndef __rfbmin\n#define __rfbmin(a,b) (((a) < (b)) ? (a) : (b))\n#endif\n\n#endif\n", "/* Copyright 2015 Pierre Ossman <ossman@cendio.se> for Cendio AB\n * Copyright (C) 2015 D. R. Commander.  All Rights Reserved.\n *\n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n/*\n * This program reads files produced by TightVNC's/TurboVNC's\n * fbs-dump, which in turn takes files from rfbproxy. It is\n * basically a dump of the RFB protocol from the server side after\n * the ServerInit message. Mostly this consists of FramebufferUpdate\n * message using the HexTile encoding. Screen size and pixel format\n * are not encoded in the file and must be specified by the user.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <sys/time.h>\n\n#include <rdr/Exception.h>\n#include <rdr/OutStream.h>\n#include <rdr/FileInStream.h>\n\n#include <rfb/PixelFormat.h>\n\n#include <rfb/CConnection.h>\n#include <rfb/CMsgReader.h>\n#include <rfb/UpdateTracker.h>\n\n#include <rfb/EncodeManager.h>\n#include <rfb/SConnection.h>\n#include <rfb/SMsgWriter.h>\n\n#include \"util.h\"\n\nstatic rfb::IntParameter width(\"width\", \"Frame buffer width\", 0);\nstatic rfb::IntParameter height(\"height\", \"Frame buffer height\", 0);\nstatic rfb::IntParameter count(\"count\", \"Number of benchmark iterations\", 9);\n\nstatic rfb::StringParameter format(\"format\", \"Pixel format (e.g. bgr888)\", \"\");\n\nstatic rfb::BoolParameter translate(\"translate\",\n                                    \"Translate 8-bit and 16-bit datasets into 24-bit\",\n                                    true);\n\n// The frame buffer (and output) is always this format\nstatic const rfb::PixelFormat fbPF(32, 24, false, true, 255, 255, 255, 0, 8, 16);\n\n// Encodings to use\nstatic const rdr::S32 encodings[] = {\n  rfb::encodingTight, rfb::encodingCopyRect, rfb::encodingRRE,\n  rfb::encodingHextile, rfb::encodingZRLE, rfb::pseudoEncodingLastRect,\n  rfb::pseudoEncodingQualityLevel0 + 8,\n  rfb::pseudoEncodingCompressLevel0 + 2};\n\nclass DummyOutStream : public rdr::OutStream {\npublic:\n  DummyOutStream();\n\n  virtual size_t length();\n  virtual void flush();\n\nprivate:\n  virtual size_t overrun(size_t itemSize, size_t nItems);\n\n  int offset;\n  rdr::U8 buf[131072];\n};\n\nclass CConn : public rfb::CConnection {\npublic:\n  CConn(const char *filename);\n  ~CConn();\n\n  void getStats(double& ratio, unsigned long long& bytes,\n                unsigned long long& rawEquivalent);\n\n  virtual void initDone();\n  virtual void setCursor(int, int, const rfb::Point&, const rdr::U8*);\n  virtual void framebufferUpdateStart();\n  virtual void framebufferUpdateEnd();\n  virtual void dataRect(const rfb::Rect&, int);\n  virtual void setColourMapEntries(int, int, rdr::U16*);\n  virtual void bell();\n  virtual void serverCutText(const char*);\n\npublic:\n  double decodeTime;\n  double encodeTime;\n\nprotected:\n  rdr::FileInStream *in;\n  rfb::SimpleUpdateTracker updates;\n  class SConn *sc;\n};\n\nclass Manager : public rfb::EncodeManager {\npublic:\n  Manager(class rfb::SConnection *conn);\n\n  void getStats(double&, unsigned long long&, unsigned long long&);\n};\n\nclass SConn : public rfb::SConnection {\npublic:\n  SConn();\n  ~SConn();\n\n  void writeUpdate(const rfb::UpdateInfo& ui, const rfb::PixelBuffer* pb);\n\n  void getStats(double&, unsigned long long&, unsigned long long&);\n\n  virtual void setAccessRights(AccessRights ar);\n\n  virtual void setDesktopSize(int fb_width, int fb_height,\n                              const rfb::ScreenSet& layout);\n\nprotected:\n  DummyOutStream *out;\n  Manager *manager;\n};\n\nDummyOutStream::DummyOutStream()\n{\n  offset = 0;\n  ptr = buf;\n  end = buf + sizeof(buf);\n}\n\nsize_t DummyOutStream::length()\n{\n  flush();\n  return offset;\n}\n\nvoid DummyOutStream::flush()\n{\n  offset += ptr - buf;\n  ptr = buf;\n}\n\nsize_t DummyOutStream::overrun(size_t itemSize, size_t nItems)\n{\n  flush();\n  if (itemSize * nItems > (size_t)(end - ptr))\n    nItems = (end - ptr) / itemSize;\n  return nItems;\n}\n\nCConn::CConn(const char *filename)\n{\n  decodeTime = 0.0;\n  encodeTime = 0.0;\n\n  in = new rdr::FileInStream(filename);\n  setStreams(in, NULL);\n\n  // Need to skip the initial handshake and ServerInit\n  setState(RFBSTATE_NORMAL);\n  // That also means that the reader and writer weren't setup\n  setReader(new rfb::CMsgReader(this, in));\n  // Nor the frame buffer size and format\n  rfb::PixelFormat pf;\n  pf.parse(format);\n  setPixelFormat(pf);\n  setDesktopSize(width, height);\n\n  sc = new SConn();\n  sc->client.setPF((bool)translate ? fbPF : pf);\n  sc->setEncodings(sizeof(encodings) / sizeof(*encodings), encodings);\n}\n\nCConn::~CConn()\n{\n  delete sc;\n  delete in;\n}\n\nvoid CConn::getStats(double& ratio, unsigned long long& bytes,\n                     unsigned long long& rawEquivalent)\n{\n  sc->getStats(ratio, bytes, rawEquivalent);\n}\n\nvoid CConn::initDone()\n{\n  rfb::ModifiablePixelBuffer *pb;\n\n  pb = new rfb::ManagedPixelBuffer((bool)translate ? fbPF : server.pf(),\n                                   server.width(), server.height());\n  setFramebuffer(pb);\n}\n\nvoid CConn::setCursor(int, int, const rfb::Point&, const rdr::U8*)\n{\n}\n\nvoid CConn::framebufferUpdateStart()\n{\n  CConnection::framebufferUpdateStart();\n\n  updates.clear();\n  startCpuCounter();\n}\n\nvoid CConn::framebufferUpdateEnd()\n{\n  rfb::UpdateInfo ui;\n  rfb::PixelBuffer* pb = getFramebuffer();\n  rfb::Region clip(pb->getRect());\n\n  CConnection::framebufferUpdateEnd();\n\n  endCpuCounter();\n\n  decodeTime += getCpuCounter();\n\n  updates.getUpdateInfo(&ui, clip);\n\n  startCpuCounter();\n  sc->writeUpdate(ui, pb);\n  endCpuCounter();\n\n  encodeTime += getCpuCounter();\n}\n\nvoid CConn::dataRect(const rfb::Rect &r, int encoding)\n{\n  CConnection::dataRect(r, encoding);\n\n  if (encoding != rfb::encodingCopyRect) // FIXME\n    updates.add_changed(rfb::Region(r));\n}\n\nvoid CConn::setColourMapEntries(int, int, rdr::U16*)\n{\n}\n\nvoid CConn::bell()\n{\n}\n\nvoid CConn::serverCutText(const char*)\n{\n}\n\nManager::Manager(class rfb::SConnection *conn) :\n  EncodeManager(conn)\n{\n}\n\nvoid Manager::getStats(double& ratio, unsigned long long& encodedBytes,\n                       unsigned long long& rawEquivalent)\n{\n  StatsVector::iterator iter;\n  unsigned long long bytes, equivalent;\n\n  bytes = equivalent = 0;\n  for (iter = stats.begin(); iter != stats.end(); ++iter) {\n    StatsVector::value_type::iterator iter2;\n    for (iter2 = iter->begin(); iter2 != iter->end(); ++iter2) {\n      bytes += iter2->bytes;\n      equivalent += iter2->equivalent;\n    }\n  }\n\n  ratio = (double)equivalent / bytes;\n  encodedBytes = bytes;\n  rawEquivalent = equivalent;\n}\n\nSConn::SConn()\n{\n  out = new DummyOutStream;\n  setStreams(NULL, out);\n\n  setWriter(new rfb::SMsgWriter(&client, out));\n\n  manager = new Manager(this);\n}\n\nSConn::~SConn()\n{\n  delete manager;\n  delete out;\n}\n\nvoid SConn::writeUpdate(const rfb::UpdateInfo& ui, const rfb::PixelBuffer* pb)\n{\n  manager->writeUpdate(ui, pb, NULL);\n}\n\nvoid SConn::getStats(double& ratio, unsigned long long& bytes,\n                     unsigned long long& rawEquivalent)\n{\n  manager->getStats(ratio, bytes, rawEquivalent);\n}\n\nvoid SConn::setAccessRights(AccessRights ar)\n{\n}\n\nvoid SConn::setDesktopSize(int fb_width, int fb_height,\n                           const rfb::ScreenSet& layout)\n{\n}\n\nstruct stats\n{\n  double decodeTime;\n  double encodeTime;\n  double realTime;\n\n  double ratio;\n  unsigned long long bytes;\n  unsigned long long rawEquivalent;\n};\n\nstatic struct stats runTest(const char *fn)\n{\n  CConn *cc;\n  struct stats s;\n  struct timeval start, stop;\n\n  gettimeofday(&start, NULL);\n\n  try {\n    cc = new CConn(fn);\n  } catch (rdr::Exception& e) {\n    fprintf(stderr, \"Failed to open rfb file: %s\\n\", e.str());\n    exit(1);\n  }\n\n  try {\n    while (true)\n      cc->processMsg();\n  } catch (rdr::EndOfStream& e) {\n  } catch (rdr::Exception& e) {\n    fprintf(stderr, \"Failed to run rfb file: %s\\n\", e.str());\n    exit(1);\n  }\n\n  gettimeofday(&stop, NULL);\n\n  s.decodeTime = cc->decodeTime;\n  s.encodeTime = cc->encodeTime;\n  s.realTime = (double)stop.tv_sec - start.tv_sec;\n  s.realTime += ((double)stop.tv_usec - start.tv_usec)/1000000.0;\n  cc->getStats(s.ratio, s.bytes, s.rawEquivalent);\n\n  delete cc;\n\n  return s;\n}\n\nstatic void sort(double *array, int count)\n{\n  bool sorted;\n  int i;\n  do {\n    sorted = true;\n    for (i = 1; i < count; i++) {\n      if (array[i-1] > array[i]) {\n        double d;\n        d = array[i];\n        array[i] = array[i - 1];\n        array[i - 1] = d;\n        sorted = false;\n      }\n    }\n  } while (!sorted);\n}\n\nstatic void usage(const char *argv0)\n{\n  fprintf(stderr, \"Syntax: %s [options] <rfb file>\\n\", argv0);\n  fprintf(stderr, \"Options:\\n\");\n  rfb::Configuration::listParams(79, 14);\n  exit(1);\n}\n\nint main(int argc, char **argv)\n{\n  int i;\n\n  const char *fn;\n\n  fn = NULL;\n  for (i = 1; i < argc; i++) {\n    if (rfb::Configuration::setParam(argv[i]))\n      continue;\n\n    if (argv[i][0] == '-') {\n      if (i + 1 < argc) {\n        if (rfb::Configuration::setParam(&argv[i][1], argv[i + 1])) {\n          i++;\n          continue;\n        }\n      }\n      usage(argv[0]);\n    }\n\n    if (fn != NULL)\n      usage(argv[0]);\n\n    fn = argv[i];\n  }\n\n  int runCount = count;\n  struct stats *runs = new struct stats[runCount];\n  double *values = new double[runCount];\n  double *dev = new double[runCount];\n  double median, meddev;\n\n  if (fn == NULL) {\n    fprintf(stderr, \"No file specified!\\n\\n\");\n    usage(argv[0]);\n  }\n\n  if (strcmp(format, \"\") == 0) {\n    fprintf(stderr, \"Pixel format not specified!\\n\\n\");\n    usage(argv[0]);\n  }\n\n  if (width == 0 || height == 0) {\n    fprintf(stderr, \"Frame buffer size not specified!\\n\\n\");\n    usage(argv[0]);\n  }\n\n  // Warmup\n  runTest(fn);\n\n  // Multiple runs to get a good average\n  for (i = 0; i < runCount; i++)\n    runs[i] = runTest(fn);\n\n  // Calculate median and median deviation for CPU usage decoding\n  for (i = 0;i < runCount;i++)\n    values[i] = runs[i].decodeTime;\n\n  sort(values, runCount);\n  median = values[runCount/2];\n\n  for (i = 0;i < runCount;i++)\n    dev[i] = fabs((values[i] - median) / median) * 100;\n\n  sort(dev, runCount);\n  meddev = dev[runCount/2];\n\n  printf(\"CPU time (decoding): %g s (+/- %g %%)\\n\", median, meddev);\n\n  // And for CPU usage encoding\n  for (i = 0;i < runCount;i++)\n    values[i] = runs[i].encodeTime;\n\n  sort(values, runCount);\n  median = values[runCount/2];\n\n  for (i = 0;i < runCount;i++)\n    dev[i] = fabs((values[i] - median) / median) * 100;\n\n  sort(dev, runCount);\n  meddev = dev[runCount/2];\n\n  printf(\"CPU time (encoding): %g s (+/- %g %%)\\n\", median, meddev);\n\n  // And for CPU core usage encoding\n  for (i = 0;i < runCount;i++)\n    values[i] = (runs[i].decodeTime + runs[i].encodeTime) / runs[i].realTime;\n\n  sort(values, runCount);\n  median = values[runCount/2];\n\n  for (i = 0;i < runCount;i++)\n    dev[i] = fabs((values[i] - median) / median) * 100;\n\n  sort(dev, runCount);\n  meddev = dev[runCount/2];\n\n  printf(\"Core usage (total): %g (+/- %g %%)\\n\", median, meddev);\n\n#ifdef WIN32\n  printf(\"Encoded bytes: %I64d\\n\", runs[0].bytes);\n  printf(\"Raw equivalent bytes: %I64d\\n\", runs[0].rawEquivalent);\n#else\n  printf(\"Encoded bytes: %lld\\n\", runs[0].bytes);\n  printf(\"Raw equivalent bytes: %lld\\n\", runs[0].rawEquivalent);\n#endif\n  printf(\"Ratio: %g\\n\", runs[0].ratio);\n\n  return 0;\n}\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n// -=- Registry.cxx\n\n#include <rfb_win32/Registry.h>\n#include <rfb_win32/Security.h>\n#include <rdr/MemOutStream.h>\n#include <rdr/HexOutStream.h>\n#include <rdr/HexInStream.h>\n#include <stdlib.h>\n#include <rfb/LogWriter.h>\n\n// These flags are required to control access control inheritance,\n// but are not defined by VC6's headers.  These definitions comes\n// from the Microsoft Platform SDK.\n#ifndef PROTECTED_DACL_SECURITY_INFORMATION\n#define PROTECTED_DACL_SECURITY_INFORMATION     (0x80000000L)\n#endif\n#ifndef UNPROTECTED_DACL_SECURITY_INFORMATION\n#define UNPROTECTED_DACL_SECURITY_INFORMATION     (0x20000000L)\n#endif\n\n\nusing namespace rfb;\nusing namespace rfb::win32;\n\n\nstatic LogWriter vlog(\"Registry\");\n\n\nRegKey::RegKey() : key(0), freeKey(false), valueNameBufLen(0) {}\n\nRegKey::RegKey(const HKEY k) : key(0), freeKey(false), valueNameBufLen(0) {\n  LONG result = RegOpenKeyEx(k, 0, 0, KEY_ALL_ACCESS, &key);\n  if (result != ERROR_SUCCESS)\n    throw rdr::SystemException(\"RegOpenKeyEx(HKEY)\", result);\n  vlog.debug(\"duplicated %p to %p\", k, key);\n  freeKey = true;\n}\n\nRegKey::RegKey(const RegKey& k) : key(0), freeKey(false), valueNameBufLen(0) {\n  LONG result = RegOpenKeyEx(k.key, 0, 0, KEY_ALL_ACCESS, &key);\n  if (result != ERROR_SUCCESS)\n    throw rdr::SystemException(\"RegOpenKeyEx(RegKey&)\", result);\n  vlog.debug(\"duplicated %p to %p\", k.key, key);\n  freeKey = true;\n}\n\nRegKey::~RegKey() {\n  close();\n}\n\n\nvoid RegKey::setHKEY(HKEY k, bool fK) {\n  vlog.debug(\"setHKEY(%p,%d)\", k, (int)fK);\n  close();\n  freeKey = fK;\n  key = k;\n}\n\n\nbool RegKey::createKey(const RegKey& root, const TCHAR* name) {\n  close();\n  LONG result = RegCreateKey(root.key, name, &key);\n  if (result != ERROR_SUCCESS) {\n    vlog.error(\"RegCreateKey(%p, %s): %lx\", root.key, name, result);\n    throw rdr::SystemException(\"RegCreateKeyEx\", result);\n  }\n  vlog.debug(\"createKey(%p,%s) = %p\", root.key, (const char*)CStr(name), key);\n  freeKey = true;\n  return true;\n}\n\nvoid RegKey::openKey(const RegKey& root, const TCHAR* name, bool readOnly) {\n  close();\n  LONG result = RegOpenKeyEx(root.key, name, 0, readOnly ? KEY_READ : KEY_ALL_ACCESS, &key);\n  if (result != ERROR_SUCCESS)\n    throw rdr::SystemException(\"RegOpenKeyEx (open)\", result);\n  vlog.debug(\"openKey(%p,%s,%s) = %p\", root.key, (const char*)CStr(name),\n\t         readOnly ? \"ro\" : \"rw\", key);\n  freeKey = true;\n}\n\nvoid RegKey::setDACL(const PACL acl, bool inherit) {\n  DWORD result;\n  if ((result = SetSecurityInfo(key, SE_REGISTRY_KEY,\n    DACL_SECURITY_INFORMATION |\n    (inherit ? UNPROTECTED_DACL_SECURITY_INFORMATION : PROTECTED_DACL_SECURITY_INFORMATION),\n    0, 0, acl, 0)) != ERROR_SUCCESS)\n    throw rdr::SystemException(\"RegKey::setDACL failed\", result);\n}\n\nvoid RegKey::close() {\n  if (freeKey) {\n    vlog.debug(\"RegCloseKey(%p)\", key);\n    RegCloseKey(key);\n    key = 0;\n  }\n}\n\nvoid RegKey::deleteKey(const TCHAR* name) const {\n  LONG result = RegDeleteKey(key, name);\n  if (result != ERROR_SUCCESS)\n    throw rdr::SystemException(\"RegDeleteKey\", result);\n}\n\nvoid RegKey::deleteValue(const TCHAR* name) const {\n  LONG result = RegDeleteValue(key, name);\n  if (result != ERROR_SUCCESS)\n    throw rdr::SystemException(\"RegDeleteValue\", result);\n}\n\nvoid RegKey::awaitChange(bool watchSubTree, DWORD filter, HANDLE event) const {\n  LONG result = RegNotifyChangeKeyValue(key, watchSubTree, filter, event, event != 0);\n  if (result != ERROR_SUCCESS)\n    throw rdr::SystemException(\"RegNotifyChangeKeyValue\", result);\n}\n\n\nRegKey::operator HKEY() const {return key;}\n\n\nvoid RegKey::setExpandString(const TCHAR* valname, const TCHAR* value) const {\n  LONG result = RegSetValueEx(key, valname, 0, REG_EXPAND_SZ, (const BYTE*)value, (_tcslen(value)+1)*sizeof(TCHAR));\n  if (result != ERROR_SUCCESS) throw rdr::SystemException(\"setExpandString\", result);\n}\n\nvoid RegKey::setString(const TCHAR* valname, const TCHAR* value) const {\n  LONG result = RegSetValueEx(key, valname, 0, REG_SZ, (const BYTE*)value, (_tcslen(value)+1)*sizeof(TCHAR));\n  if (result != ERROR_SUCCESS) throw rdr::SystemException(\"setString\", result);\n}\n\nvoid RegKey::setBinary(const TCHAR* valname, const void* value, size_t length) const {\n  LONG result = RegSetValueEx(key, valname, 0, REG_BINARY, (const BYTE*)value, length);\n  if (result != ERROR_SUCCESS) throw rdr::SystemException(\"setBinary\", result);\n}\n\nvoid RegKey::setInt(const TCHAR* valname, int value) const {\n  LONG result = RegSetValueEx(key, valname, 0, REG_DWORD, (const BYTE*)&value, sizeof(value));\n  if (result != ERROR_SUCCESS) throw rdr::SystemException(\"setInt\", result);\n}\n\nvoid RegKey::setBool(const TCHAR* valname, bool value) const {\n  setInt(valname, value ? 1 : 0);\n}\n\nTCHAR* RegKey::getString(const TCHAR* valname) const {return getRepresentation(valname);}\nTCHAR* RegKey::getString(const TCHAR* valname, const TCHAR* def) const {\n  try {\n    return getString(valname);\n  } catch(rdr::Exception&) {\n    return tstrDup(def);\n  }\n}\n\nvoid RegKey::getBinary(const TCHAR* valname, void** data, size_t* length) const {\n  TCharArray hex(getRepresentation(valname));\n  if (!rdr::HexInStream::hexStrToBin(CStr(hex.buf), (char**)data, length))\n    throw rdr::Exception(\"getBinary failed\");\n}\nvoid RegKey::getBinary(const TCHAR* valname, void** data, size_t* length, void* def, size_t deflen) const {\n  try {\n    getBinary(valname, data, length);\n  } catch(rdr::Exception&) {\n    if (deflen) {\n      *data = new char[deflen];\n      memcpy(*data, def, deflen);\n    } else\n      *data = 0;\n    *length = deflen;\n  }\n}\n\nint RegKey::getInt(const TCHAR* valname) const {\n  TCharArray tmp(getRepresentation(valname));\n  return _ttoi(tmp.buf);\n}\nint RegKey::getInt(const TCHAR* valname, int def) const {\n  try {\n    return getInt(valname);\n  } catch(rdr::Exception&) {\n    return def;\n  }\n}\n\nbool RegKey::getBool(const TCHAR* valname) const {\n  return getInt(valname) > 0;\n}\nbool RegKey::getBool(const TCHAR* valname, bool def) const {\n  return getInt(valname, def ? 1 : 0) > 0;\n}\n\nstatic inline TCHAR* terminateData(char* data, int length)\n{\n  // We must terminate the string, just to be sure.  Stupid Win32...\n  int len = length/sizeof(TCHAR);\n  TCharArray str(len+1);\n  memcpy(str.buf, data, length);\n  str.buf[len] = 0;\n  return str.takeBuf();\n}\n\nTCHAR* RegKey::getRepresentation(const TCHAR* valname) const {\n  DWORD type, length;\n  LONG result = RegQueryValueEx(key, valname, 0, &type, 0, &length);\n  if (result != ERROR_SUCCESS)\n    throw rdr::SystemException(\"get registry value length\", result);\n  CharArray data(length);\n  result = RegQueryValueEx(key, valname, 0, &type, (BYTE*)data.buf, &length);\n  if (result != ERROR_SUCCESS)\n    throw rdr::SystemException(\"get registry value\", result);\n\n  switch (type) {\n  case REG_BINARY:\n    {\n      TCharArray hex(rdr::HexOutStream::binToHexStr(data.buf, length));\n      return hex.takeBuf();\n    }\n  case REG_SZ:\n    if (length) {\n      return terminateData(data.buf, length);\n    } else {\n      return tstrDup(_T(\"\"));\n    }\n  case REG_DWORD:\n    {\n      TCharArray tmp(16);\n      _stprintf(tmp.buf, _T(\"%lu\"), *((DWORD*)data.buf));\n      return tmp.takeBuf();\n    }\n  case REG_EXPAND_SZ:\n    {\n    if (length) {\n      TCharArray str(terminateData(data.buf, length));\n      DWORD required = ExpandEnvironmentStrings(str.buf, 0, 0);\n      if (required==0)\n        throw rdr::SystemException(\"ExpandEnvironmentStrings\", GetLastError());\n      TCharArray result(required);\n      length = ExpandEnvironmentStrings(str.buf, result.buf, required);\n      if (required<length)\n        throw rdr::Exception(\"unable to expand environment strings\");\n      return result.takeBuf();\n    } else {\n      return tstrDup(_T(\"\"));\n    }\n    }\n  default:\n    throw rdr::Exception(\"unsupported registry type\");\n  }\n}\n\nbool RegKey::isValue(const TCHAR* valname) const {\n  try {\n    TCharArray tmp(getRepresentation(valname));\n    return true;\n  } catch(rdr::Exception&) {\n    return false;\n  }\n}\n\nconst TCHAR* RegKey::getValueName(int i) {\n  DWORD maxValueNameLen;\n  LONG result = RegQueryInfoKey(key, 0, 0, 0, 0, 0, 0, 0, &maxValueNameLen, 0, 0, 0);\n  if (result != ERROR_SUCCESS)\n    throw rdr::SystemException(\"RegQueryInfoKey\", result);\n  if (valueNameBufLen < maxValueNameLen + 1) {\n    valueNameBufLen = maxValueNameLen + 1;\n    delete [] valueName.buf;\n    valueName.buf = new TCHAR[valueNameBufLen];\n  }\n  DWORD length = valueNameBufLen;\n  result = RegEnumValue(key, i, valueName.buf, &length, NULL, 0, 0, 0);\n  if (result == ERROR_NO_MORE_ITEMS) return 0;\n  if (result != ERROR_SUCCESS)\n    throw rdr::SystemException(\"RegEnumValue\", result);\n  return valueName.buf;\n}\n\nconst TCHAR* RegKey::getKeyName(int i) {\n  DWORD maxValueNameLen;\n  LONG result = RegQueryInfoKey(key, 0, 0, 0, 0, &maxValueNameLen, 0, 0, 0, 0, 0, 0);\n  if (result != ERROR_SUCCESS)\n    throw rdr::SystemException(\"RegQueryInfoKey\", result);\n  if (valueNameBufLen < maxValueNameLen + 1) {\n    valueNameBufLen = maxValueNameLen + 1;\n    delete [] valueName.buf;\n    valueName.buf = new TCHAR[valueNameBufLen];\n  }\n  DWORD length = valueNameBufLen;\n  result = RegEnumKeyEx(key, i, valueName.buf, &length, NULL, 0, 0, 0);\n  if (result == ERROR_NO_MORE_ITEMS) return 0;\n  if (result != ERROR_SUCCESS)\n    throw rdr::SystemException(\"RegEnumKey\", result);\n  return valueName.buf;\n}\n", "/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n// -=- Registry.h\n\n// C++ wrappers around the Win32 Registry APIs\n\n#ifndef __RFB_WIN32_REGISTRY_H__\n#define __RFB_WIN32_REGISTRY_H__\n\n#include <windows.h>\n#include <rfb_win32/Security.h>\n#include <rfb/util.h>\n\nnamespace rfb {\n\n  namespace win32 {\n\n    class RegKey {\n    public:\n      // No key open\n      RegKey();\n\n      // Duplicate the specified existing key\n      RegKey(const HKEY k);\n      RegKey(const RegKey& k);\n\n      // Calls close() internally\n      ~RegKey();\n\n      void setHKEY(HKEY key, bool freeKey);\n    private:\n      RegKey& operator=(const RegKey& k);\n      HKEY& operator=(const HKEY& k);\n    public:\n\n      // Returns true if key was created, false if already existed\n      bool createKey(const RegKey& root, const TCHAR* name);\n\n      // Opens key if it exists, or raises an exception if not\n      void openKey(const RegKey& root, const TCHAR* name, bool readOnly=false);\n\n      // Set the (discretionary) access control list for the key\n      void setDACL(const PACL acl, bool inheritFromParent=true);\n\n      // Closes current key, if required\n      void close();\n\n      // Delete a subkey/value\n      void deleteKey(const TCHAR* name) const;\n      void deleteValue(const TCHAR* name) const;\n\n\n      // Block waiting for a registry change, OR return immediately and notify the\n      // event when there is a change, if specified\n      void awaitChange(bool watchSubTree, DWORD filter, HANDLE event=0) const;\n\n      void setExpandString(const TCHAR* valname, const TCHAR* s) const;\n      void setString(const TCHAR* valname, const TCHAR* s) const;\n      void setBinary(const TCHAR* valname, const void* data, size_t length) const;\n      void setInt(const TCHAR* valname, int i) const;\n      void setBool(const TCHAR* valname, bool b) const;\n\n      TCHAR* getString(const TCHAR* valname) const;\n      TCHAR* getString(const TCHAR* valname, const TCHAR* def) const;\n\n      void getBinary(const TCHAR* valname, void** data, size_t* length) const;\n      void getBinary(const TCHAR* valname, void** data, size_t* length, void* def, size_t deflength) const;\n\n      int getInt(const TCHAR* valname) const;\n      int getInt(const TCHAR* valname, int def) const;\n\n      bool getBool(const TCHAR* valname) const;\n      bool getBool(const TCHAR* valname, bool def) const;\n\n      TCHAR* getRepresentation(const TCHAR* valname) const;\n\n      bool isValue(const TCHAR* valname) const;\n\n      // Get the name of value/key number \"i\"\n      // If there are fewer than \"i\" values then return 0\n      // NAME IS OWNED BY RegKey OBJECT!\n      const TCHAR* getValueName(int i);\n      const TCHAR* getKeyName(int i);\n\n      operator HKEY() const;\n    protected:\n      HKEY key;\n      bool freeKey;\n      TCharArray valueName;\n      DWORD valueNameBufLen;\n    };\n\n  };\n\n};\n\n#endif // __RFB_WIN32_REG_CONFIG_H__\n"], "filenames": ["common/rdr/FdInStream.cxx", "common/rdr/FdInStream.h", "common/rdr/FdOutStream.cxx", "common/rdr/FdOutStream.h", "common/rdr/FileInStream.cxx", "common/rdr/FileInStream.h", "common/rdr/HexInStream.cxx", "common/rdr/HexInStream.h", "common/rdr/HexOutStream.cxx", "common/rdr/HexOutStream.h", "common/rdr/InStream.h", "common/rdr/MemInStream.h", "common/rdr/MemOutStream.h", "common/rdr/OutStream.h", "common/rdr/RandomStream.cxx", "common/rdr/RandomStream.h", "common/rdr/TLSInStream.cxx", "common/rdr/TLSInStream.h", "common/rdr/TLSOutStream.cxx", "common/rdr/TLSOutStream.h", "common/rdr/ZlibInStream.cxx", "common/rdr/ZlibInStream.h", "common/rdr/ZlibOutStream.cxx", "common/rdr/ZlibOutStream.h", "common/rfb/Configuration.cxx", "common/rfb/Configuration.h", "common/rfb/Password.cxx", "common/rfb/Password.h", "common/rfb/util.h", "tests/perf/encperf.cxx", "win/rfb_win32/Registry.cxx", "win/rfb_win32/Registry.h"], "buggy_code_start_loc": [59, 40, 54, 37, 51, 38, 31, 29, 26, 29, 44, 39, 43, 47, 38, 42, 78, 39, 78, 39, 29, 37, 36, 38, 424, 259, 41, 31, 53, 74, 149, 74], "buggy_code_end_loc": [175, 73, 170, 59, 84, 42, 114, 44, 106, 47, 137, 57, 66, 149, 130, 50, 109, 50, 110, 53, 139, 58, 134, 57, 466, 277, 71, 44, 54, 160, 178, 83], "fixing_code_start_loc": [59, 40, 54, 37, 51, 38, 31, 29, 26, 29, 44, 39, 43, 47, 38, 42, 78, 39, 78, 39, 29, 37, 36, 38, 424, 259, 41, 31, 53, 74, 149, 74], "fixing_code_end_loc": [175, 74, 170, 59, 84, 42, 114, 44, 106, 47, 137, 57, 66, 149, 130, 50, 109, 50, 110, 53, 139, 58, 134, 57, 466, 278, 71, 44, 54, 160, 178, 83], "type": "CWE-787", "message": "TigerVNC version prior to 1.10.1 is vulnerable to heap buffer overflow, which could be triggered from DecodeManager::decodeRect. Vulnerability occurs due to the signdness error in processing MemOutStream. Exploitation of this vulnerability could potentially result into remote code execution. This attack appear to be exploitable via network connectivity.", "other": {"cve": {"id": "CVE-2019-15694", "sourceIdentifier": "vulnerability@kaspersky.com", "published": "2019-12-26T15:15:11.337", "lastModified": "2020-10-16T20:00:01.087", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TigerVNC version prior to 1.10.1 is vulnerable to heap buffer overflow, which could be triggered from DecodeManager::decodeRect. Vulnerability occurs due to the signdness error in processing MemOutStream. Exploitation of this vulnerability could potentially result into remote code execution. This attack appear to be exploitable via network connectivity."}, {"lang": "es", "value": "TigerVNC versiones anteriores a 1.10.1, es vulnerable al desbordamiento de b\u00fafer de la pila, que podr\u00eda ser activada desde la funci\u00f3n DecodeManager::decodeRect. La vulnerabilidad se presenta debido a un error de firma en el procesamiento de MemOutStream. La explotaci\u00f3n de esta vulnerabilidad podr\u00eda resultar potencialmente en una ejecuci\u00f3n de c\u00f3digo remota. Este ataque parece ser explotable a trav\u00e9s de la conectividad de red."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "vulnerability@kaspersky.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tigervnc:tigervnc:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.10.1", "matchCriteriaId": "5DB31840-DC35-40A5-8126-FF5FDD81EAD7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-01/msg00039.html", "source": "vulnerability@kaspersky.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/CendioOssman/tigervnc/commit/0943c006c7d900dfc0281639e992791d6c567438", "source": "vulnerability@kaspersky.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/TigerVNC/tigervnc/releases/tag/v1.10.1", "source": "vulnerability@kaspersky.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2019/12/20/2", "source": "vulnerability@kaspersky.com", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/CendioOssman/tigervnc/commit/0943c006c7d900dfc0281639e992791d6c567438"}}