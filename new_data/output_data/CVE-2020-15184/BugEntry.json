{"buggy_code": ["/*\nCopyright The Helm Authors.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage chart\n\nimport (\n\t\"path/filepath\"\n\t\"strings\"\n)\n\n// APIVersionV1 is the API version number for version 1.\nconst APIVersionV1 = \"v1\"\n\n// APIVersionV2 is the API version number for version 2.\nconst APIVersionV2 = \"v2\"\n\n// Chart is a helm package that contains metadata, a default config, zero or more\n// optionally parameterizable templates, and zero or more charts (dependencies).\ntype Chart struct {\n\t// Raw contains the raw contents of the files originally contained in the chart archive.\n\t//\n\t// This should not be used except in special cases like `helm show values`,\n\t// where we want to display the raw values, comments and all.\n\tRaw []*File `json:\"-\"`\n\t// Metadata is the contents of the Chartfile.\n\tMetadata *Metadata `json:\"metadata\"`\n\t// Lock is the contents of Chart.lock.\n\tLock *Lock `json:\"lock\"`\n\t// Templates for this chart.\n\tTemplates []*File `json:\"templates\"`\n\t// Values are default config for this chart.\n\tValues map[string]interface{} `json:\"values\"`\n\t// Schema is an optional JSON schema for imposing structure on Values\n\tSchema []byte `json:\"schema\"`\n\t// Files are miscellaneous files in a chart archive,\n\t// e.g. README, LICENSE, etc.\n\tFiles []*File `json:\"files\"`\n\n\tparent       *Chart\n\tdependencies []*Chart\n}\n\ntype CRD struct {\n\t// Name is the File.Name for the crd file\n\tName string\n\t// Filename is the File obj Name including (sub-)chart.ChartFullPath\n\tFilename string\n\t// File is the File obj for the crd\n\tFile *File\n}\n\n// SetDependencies replaces the chart dependencies.\nfunc (ch *Chart) SetDependencies(charts ...*Chart) {\n\tch.dependencies = nil\n\tch.AddDependency(charts...)\n}\n\n// Name returns the name of the chart.\nfunc (ch *Chart) Name() string {\n\tif ch.Metadata == nil {\n\t\treturn \"\"\n\t}\n\treturn ch.Metadata.Name\n}\n\n// AddDependency determines if the chart is a subchart.\nfunc (ch *Chart) AddDependency(charts ...*Chart) {\n\tfor i, x := range charts {\n\t\tcharts[i].parent = ch\n\t\tch.dependencies = append(ch.dependencies, x)\n\t}\n}\n\n// Root finds the root chart.\nfunc (ch *Chart) Root() *Chart {\n\tif ch.IsRoot() {\n\t\treturn ch\n\t}\n\treturn ch.Parent().Root()\n}\n\n// Dependencies are the charts that this chart depends on.\nfunc (ch *Chart) Dependencies() []*Chart { return ch.dependencies }\n\n// IsRoot determines if the chart is the root chart.\nfunc (ch *Chart) IsRoot() bool { return ch.parent == nil }\n\n// Parent returns a subchart's parent chart.\nfunc (ch *Chart) Parent() *Chart { return ch.parent }\n\n// ChartPath returns the full path to this chart in dot notation.\nfunc (ch *Chart) ChartPath() string {\n\tif !ch.IsRoot() {\n\t\treturn ch.Parent().ChartPath() + \".\" + ch.Name()\n\t}\n\treturn ch.Name()\n}\n\n// ChartFullPath returns the full path to this chart.\nfunc (ch *Chart) ChartFullPath() string {\n\tif !ch.IsRoot() {\n\t\treturn ch.Parent().ChartFullPath() + \"/charts/\" + ch.Name()\n\t}\n\treturn ch.Name()\n}\n\n// Validate validates the metadata.\nfunc (ch *Chart) Validate() error {\n\treturn ch.Metadata.Validate()\n}\n\n// AppVersion returns the appversion of the chart.\nfunc (ch *Chart) AppVersion() string {\n\tif ch.Metadata == nil {\n\t\treturn \"\"\n\t}\n\treturn ch.Metadata.AppVersion\n}\n\n// CRDs returns a list of File objects in the 'crds/' directory of a Helm chart.\n// Deprecated: use CRDObjects()\nfunc (ch *Chart) CRDs() []*File {\n\tfiles := []*File{}\n\t// Find all resources in the crds/ directory\n\tfor _, f := range ch.Files {\n\t\tif strings.HasPrefix(f.Name, \"crds/\") && hasManifestExtension(f.Name) {\n\t\t\tfiles = append(files, f)\n\t\t}\n\t}\n\t// Get CRDs from dependencies, too.\n\tfor _, dep := range ch.Dependencies() {\n\t\tfiles = append(files, dep.CRDs()...)\n\t}\n\treturn files\n}\n\n// CRDObjects returns a list of CRD objects in the 'crds/' directory of a Helm chart & subcharts\nfunc (ch *Chart) CRDObjects() []CRD {\n\tcrds := []CRD{}\n\t// Find all resources in the crds/ directory\n\tfor _, f := range ch.Files {\n\t\tif strings.HasPrefix(f.Name, \"crds/\") && hasManifestExtension(f.Name) {\n\t\t\tmycrd := CRD{Name: f.Name, Filename: filepath.Join(ch.ChartFullPath(), f.Name), File: f}\n\t\t\tcrds = append(crds, mycrd)\n\t\t}\n\t}\n\t// Get CRDs from dependencies, too.\n\tfor _, dep := range ch.Dependencies() {\n\t\tcrds = append(crds, dep.CRDObjects()...)\n\t}\n\treturn crds\n}\n\nfunc hasManifestExtension(fname string) bool {\n\text := filepath.Ext(fname)\n\treturn strings.EqualFold(ext, \".yaml\") || strings.EqualFold(ext, \".yml\") || strings.EqualFold(ext, \".json\")\n}\n", "/*\nCopyright The Helm Authors.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage chart\n\n// ValidationError represents a data validation error.\ntype ValidationError string\n\nfunc (v ValidationError) Error() string {\n\treturn \"validation: \" + string(v)\n}\n", "/*\nCopyright The Helm Authors.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage chart\n\n// Maintainer describes a Chart maintainer.\ntype Maintainer struct {\n\t// Name is a user name or organization name\n\tName string `json:\"name,omitempty\"`\n\t// Email is an optional email address to contact the named maintainer\n\tEmail string `json:\"email,omitempty\"`\n\t// URL is an optional URL to an address for the named maintainer\n\tURL string `json:\"url,omitempty\"`\n}\n\n// Metadata for a Chart file. This models the structure of a Chart.yaml file.\ntype Metadata struct {\n\t// The name of the chart\n\tName string `json:\"name,omitempty\"`\n\t// The URL to a relevant project page, git repo, or contact person\n\tHome string `json:\"home,omitempty\"`\n\t// Source is the URL to the source code of this chart\n\tSources []string `json:\"sources,omitempty\"`\n\t// A SemVer 2 conformant version string of the chart\n\tVersion string `json:\"version,omitempty\"`\n\t// A one-sentence description of the chart\n\tDescription string `json:\"description,omitempty\"`\n\t// A list of string keywords\n\tKeywords []string `json:\"keywords,omitempty\"`\n\t// A list of name and URL/email address combinations for the maintainer(s)\n\tMaintainers []*Maintainer `json:\"maintainers,omitempty\"`\n\t// The URL to an icon file.\n\tIcon string `json:\"icon,omitempty\"`\n\t// The API Version of this chart.\n\tAPIVersion string `json:\"apiVersion,omitempty\"`\n\t// The condition to check to enable chart\n\tCondition string `json:\"condition,omitempty\"`\n\t// The tags to check to enable chart\n\tTags string `json:\"tags,omitempty\"`\n\t// The version of the application enclosed inside of this chart.\n\tAppVersion string `json:\"appVersion,omitempty\"`\n\t// Whether or not this chart is deprecated\n\tDeprecated bool `json:\"deprecated,omitempty\"`\n\t// Annotations are additional mappings uninterpreted by Helm,\n\t// made available for inspection by other applications.\n\tAnnotations map[string]string `json:\"annotations,omitempty\"`\n\t// KubeVersion is a SemVer constraint specifying the version of Kubernetes required.\n\tKubeVersion string `json:\"kubeVersion,omitempty\"`\n\t// Dependencies are a list of dependencies for a chart.\n\tDependencies []*Dependency `json:\"dependencies,omitempty\"`\n\t// Specifies the chart type: application or library\n\tType string `json:\"type,omitempty\"`\n}\n\n// Validate checks the metadata for known issues, returning an error if metadata is not correct\nfunc (md *Metadata) Validate() error {\n\tif md == nil {\n\t\treturn ValidationError(\"chart.metadata is required\")\n\t}\n\tif md.APIVersion == \"\" {\n\t\treturn ValidationError(\"chart.metadata.apiVersion is required\")\n\t}\n\tif md.Name == \"\" {\n\t\treturn ValidationError(\"chart.metadata.name is required\")\n\t}\n\tif md.Version == \"\" {\n\t\treturn ValidationError(\"chart.metadata.version is required\")\n\t}\n\tif !isValidChartType(md.Type) {\n\t\treturn ValidationError(\"chart.metadata.type must be application or library\")\n\t}\n\t// TODO validate valid semver here?\n\treturn nil\n}\n\nfunc isValidChartType(in string) bool {\n\tswitch in {\n\tcase \"\", \"application\", \"library\":\n\t\treturn true\n\t}\n\treturn false\n}\n", "/*\nCopyright The Helm Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\npackage chart\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValidate(t *testing.T) {\n\ttests := []struct {\n\t\tmd  *Metadata\n\t\terr error\n\t}{\n\t\t{\n\t\t\tnil,\n\t\t\tValidationError(\"chart.metadata is required\"),\n\t\t},\n\t\t{\n\t\t\t&Metadata{Name: \"test\", Version: \"1.0\"},\n\t\t\tValidationError(\"chart.metadata.apiVersion is required\"),\n\t\t},\n\t\t{\n\t\t\t&Metadata{APIVersion: \"v2\", Version: \"1.0\"},\n\t\t\tValidationError(\"chart.metadata.name is required\"),\n\t\t},\n\t\t{\n\t\t\t&Metadata{Name: \"test\", APIVersion: \"v2\"},\n\t\t\tValidationError(\"chart.metadata.version is required\"),\n\t\t},\n\t\t{\n\t\t\t&Metadata{Name: \"test\", APIVersion: \"v2\", Version: \"1.0\", Type: \"test\"},\n\t\t\tValidationError(\"chart.metadata.type must be application or library\"),\n\t\t},\n\t\t{\n\t\t\t&Metadata{Name: \"test\", APIVersion: \"v2\", Version: \"1.0\", Type: \"application\"},\n\t\t\tnil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult := tt.md.Validate()\n\t\tif result != tt.err {\n\t\t\tt.Errorf(\"expected %s, got %s\", tt.err, result)\n\t\t}\n\t}\n}\n"], "fixing_code": ["/*\nCopyright The Helm Authors.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage chart\n\nimport (\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n)\n\n// APIVersionV1 is the API version number for version 1.\nconst APIVersionV1 = \"v1\"\n\n// APIVersionV2 is the API version number for version 2.\nconst APIVersionV2 = \"v2\"\n\n// aliasNameFormat defines the characters that are legal in an alias name.\nvar aliasNameFormat = regexp.MustCompile(\"^[a-zA-Z0-9_-]+$\")\n\n// Chart is a helm package that contains metadata, a default config, zero or more\n// optionally parameterizable templates, and zero or more charts (dependencies).\ntype Chart struct {\n\t// Raw contains the raw contents of the files originally contained in the chart archive.\n\t//\n\t// This should not be used except in special cases like `helm show values`,\n\t// where we want to display the raw values, comments and all.\n\tRaw []*File `json:\"-\"`\n\t// Metadata is the contents of the Chartfile.\n\tMetadata *Metadata `json:\"metadata\"`\n\t// Lock is the contents of Chart.lock.\n\tLock *Lock `json:\"lock\"`\n\t// Templates for this chart.\n\tTemplates []*File `json:\"templates\"`\n\t// Values are default config for this chart.\n\tValues map[string]interface{} `json:\"values\"`\n\t// Schema is an optional JSON schema for imposing structure on Values\n\tSchema []byte `json:\"schema\"`\n\t// Files are miscellaneous files in a chart archive,\n\t// e.g. README, LICENSE, etc.\n\tFiles []*File `json:\"files\"`\n\n\tparent       *Chart\n\tdependencies []*Chart\n}\n\ntype CRD struct {\n\t// Name is the File.Name for the crd file\n\tName string\n\t// Filename is the File obj Name including (sub-)chart.ChartFullPath\n\tFilename string\n\t// File is the File obj for the crd\n\tFile *File\n}\n\n// SetDependencies replaces the chart dependencies.\nfunc (ch *Chart) SetDependencies(charts ...*Chart) {\n\tch.dependencies = nil\n\tch.AddDependency(charts...)\n}\n\n// Name returns the name of the chart.\nfunc (ch *Chart) Name() string {\n\tif ch.Metadata == nil {\n\t\treturn \"\"\n\t}\n\treturn ch.Metadata.Name\n}\n\n// AddDependency determines if the chart is a subchart.\nfunc (ch *Chart) AddDependency(charts ...*Chart) {\n\tfor i, x := range charts {\n\t\tcharts[i].parent = ch\n\t\tch.dependencies = append(ch.dependencies, x)\n\t}\n}\n\n// Root finds the root chart.\nfunc (ch *Chart) Root() *Chart {\n\tif ch.IsRoot() {\n\t\treturn ch\n\t}\n\treturn ch.Parent().Root()\n}\n\n// Dependencies are the charts that this chart depends on.\nfunc (ch *Chart) Dependencies() []*Chart { return ch.dependencies }\n\n// IsRoot determines if the chart is the root chart.\nfunc (ch *Chart) IsRoot() bool { return ch.parent == nil }\n\n// Parent returns a subchart's parent chart.\nfunc (ch *Chart) Parent() *Chart { return ch.parent }\n\n// ChartPath returns the full path to this chart in dot notation.\nfunc (ch *Chart) ChartPath() string {\n\tif !ch.IsRoot() {\n\t\treturn ch.Parent().ChartPath() + \".\" + ch.Name()\n\t}\n\treturn ch.Name()\n}\n\n// ChartFullPath returns the full path to this chart.\nfunc (ch *Chart) ChartFullPath() string {\n\tif !ch.IsRoot() {\n\t\treturn ch.Parent().ChartFullPath() + \"/charts/\" + ch.Name()\n\t}\n\treturn ch.Name()\n}\n\n// Validate validates the metadata.\nfunc (ch *Chart) Validate() error {\n\treturn ch.Metadata.Validate()\n}\n\n// AppVersion returns the appversion of the chart.\nfunc (ch *Chart) AppVersion() string {\n\tif ch.Metadata == nil {\n\t\treturn \"\"\n\t}\n\treturn ch.Metadata.AppVersion\n}\n\n// CRDs returns a list of File objects in the 'crds/' directory of a Helm chart.\n// Deprecated: use CRDObjects()\nfunc (ch *Chart) CRDs() []*File {\n\tfiles := []*File{}\n\t// Find all resources in the crds/ directory\n\tfor _, f := range ch.Files {\n\t\tif strings.HasPrefix(f.Name, \"crds/\") && hasManifestExtension(f.Name) {\n\t\t\tfiles = append(files, f)\n\t\t}\n\t}\n\t// Get CRDs from dependencies, too.\n\tfor _, dep := range ch.Dependencies() {\n\t\tfiles = append(files, dep.CRDs()...)\n\t}\n\treturn files\n}\n\n// CRDObjects returns a list of CRD objects in the 'crds/' directory of a Helm chart & subcharts\nfunc (ch *Chart) CRDObjects() []CRD {\n\tcrds := []CRD{}\n\t// Find all resources in the crds/ directory\n\tfor _, f := range ch.Files {\n\t\tif strings.HasPrefix(f.Name, \"crds/\") && hasManifestExtension(f.Name) {\n\t\t\tmycrd := CRD{Name: f.Name, Filename: filepath.Join(ch.ChartFullPath(), f.Name), File: f}\n\t\t\tcrds = append(crds, mycrd)\n\t\t}\n\t}\n\t// Get CRDs from dependencies, too.\n\tfor _, dep := range ch.Dependencies() {\n\t\tcrds = append(crds, dep.CRDObjects()...)\n\t}\n\treturn crds\n}\n\nfunc hasManifestExtension(fname string) bool {\n\text := filepath.Ext(fname)\n\treturn strings.EqualFold(ext, \".yaml\") || strings.EqualFold(ext, \".yml\") || strings.EqualFold(ext, \".json\")\n}\n", "/*\nCopyright The Helm Authors.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage chart\n\nimport \"fmt\"\n\n// ValidationError represents a data validation error.\ntype ValidationError string\n\nfunc (v ValidationError) Error() string {\n\treturn \"validation: \" + string(v)\n}\n\n// ValidationErrorf takes a message and formatting options and creates a ValidationError\nfunc ValidationErrorf(msg string, args ...interface{}) ValidationError {\n\treturn ValidationError(fmt.Sprintf(msg, args...))\n}\n", "/*\nCopyright The Helm Authors.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage chart\n\n// Maintainer describes a Chart maintainer.\ntype Maintainer struct {\n\t// Name is a user name or organization name\n\tName string `json:\"name,omitempty\"`\n\t// Email is an optional email address to contact the named maintainer\n\tEmail string `json:\"email,omitempty\"`\n\t// URL is an optional URL to an address for the named maintainer\n\tURL string `json:\"url,omitempty\"`\n}\n\n// Metadata for a Chart file. This models the structure of a Chart.yaml file.\ntype Metadata struct {\n\t// The name of the chart\n\tName string `json:\"name,omitempty\"`\n\t// The URL to a relevant project page, git repo, or contact person\n\tHome string `json:\"home,omitempty\"`\n\t// Source is the URL to the source code of this chart\n\tSources []string `json:\"sources,omitempty\"`\n\t// A SemVer 2 conformant version string of the chart\n\tVersion string `json:\"version,omitempty\"`\n\t// A one-sentence description of the chart\n\tDescription string `json:\"description,omitempty\"`\n\t// A list of string keywords\n\tKeywords []string `json:\"keywords,omitempty\"`\n\t// A list of name and URL/email address combinations for the maintainer(s)\n\tMaintainers []*Maintainer `json:\"maintainers,omitempty\"`\n\t// The URL to an icon file.\n\tIcon string `json:\"icon,omitempty\"`\n\t// The API Version of this chart.\n\tAPIVersion string `json:\"apiVersion,omitempty\"`\n\t// The condition to check to enable chart\n\tCondition string `json:\"condition,omitempty\"`\n\t// The tags to check to enable chart\n\tTags string `json:\"tags,omitempty\"`\n\t// The version of the application enclosed inside of this chart.\n\tAppVersion string `json:\"appVersion,omitempty\"`\n\t// Whether or not this chart is deprecated\n\tDeprecated bool `json:\"deprecated,omitempty\"`\n\t// Annotations are additional mappings uninterpreted by Helm,\n\t// made available for inspection by other applications.\n\tAnnotations map[string]string `json:\"annotations,omitempty\"`\n\t// KubeVersion is a SemVer constraint specifying the version of Kubernetes required.\n\tKubeVersion string `json:\"kubeVersion,omitempty\"`\n\t// Dependencies are a list of dependencies for a chart.\n\tDependencies []*Dependency `json:\"dependencies,omitempty\"`\n\t// Specifies the chart type: application or library\n\tType string `json:\"type,omitempty\"`\n}\n\n// Validate checks the metadata for known issues, returning an error if metadata is not correct\nfunc (md *Metadata) Validate() error {\n\tif md == nil {\n\t\treturn ValidationError(\"chart.metadata is required\")\n\t}\n\tif md.APIVersion == \"\" {\n\t\treturn ValidationError(\"chart.metadata.apiVersion is required\")\n\t}\n\tif md.Name == \"\" {\n\t\treturn ValidationError(\"chart.metadata.name is required\")\n\t}\n\tif md.Version == \"\" {\n\t\treturn ValidationError(\"chart.metadata.version is required\")\n\t}\n\tif !isValidChartType(md.Type) {\n\t\treturn ValidationError(\"chart.metadata.type must be application or library\")\n\t}\n\n\t// Aliases need to be validated here to make sure that the alias name does\n\t// not contain any illegal characters.\n\tfor _, dependency := range md.Dependencies {\n\t\tif err := validateDependency(dependency); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// TODO validate valid semver here?\n\treturn nil\n}\n\nfunc isValidChartType(in string) bool {\n\tswitch in {\n\tcase \"\", \"application\", \"library\":\n\t\treturn true\n\t}\n\treturn false\n}\n\n// validateDependency checks for common problems with the dependency datastructure in\n// the chart. This check must be done at load time before the dependency's charts are\n// loaded.\nfunc validateDependency(dep *Dependency) error {\n\tif len(dep.Alias) > 0 && !aliasNameFormat.MatchString(dep.Alias) {\n\t\treturn ValidationErrorf(\"dependency %q has disallowed characters in the alias\", dep.Name)\n\t}\n\treturn nil\n}\n", "/*\nCopyright The Helm Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\npackage chart\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValidate(t *testing.T) {\n\ttests := []struct {\n\t\tmd  *Metadata\n\t\terr error\n\t}{\n\t\t{\n\t\t\tnil,\n\t\t\tValidationError(\"chart.metadata is required\"),\n\t\t},\n\t\t{\n\t\t\t&Metadata{Name: \"test\", Version: \"1.0\"},\n\t\t\tValidationError(\"chart.metadata.apiVersion is required\"),\n\t\t},\n\t\t{\n\t\t\t&Metadata{APIVersion: \"v2\", Version: \"1.0\"},\n\t\t\tValidationError(\"chart.metadata.name is required\"),\n\t\t},\n\t\t{\n\t\t\t&Metadata{Name: \"test\", APIVersion: \"v2\"},\n\t\t\tValidationError(\"chart.metadata.version is required\"),\n\t\t},\n\t\t{\n\t\t\t&Metadata{Name: \"test\", APIVersion: \"v2\", Version: \"1.0\", Type: \"test\"},\n\t\t\tValidationError(\"chart.metadata.type must be application or library\"),\n\t\t},\n\t\t{\n\t\t\t&Metadata{Name: \"test\", APIVersion: \"v2\", Version: \"1.0\", Type: \"application\"},\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t&Metadata{\n\t\t\t\tName:       \"test\",\n\t\t\t\tAPIVersion: \"v2\",\n\t\t\t\tVersion:    \"1.0\",\n\t\t\t\tType:       \"application\",\n\t\t\t\tDependencies: []*Dependency{\n\t\t\t\t\t{Name: \"dependency\", Alias: \"legal-alias\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t&Metadata{\n\t\t\t\tName:       \"test\",\n\t\t\t\tAPIVersion: \"v2\",\n\t\t\t\tVersion:    \"1.0\",\n\t\t\t\tType:       \"application\",\n\t\t\t\tDependencies: []*Dependency{\n\t\t\t\t\t{Name: \"bad\", Alias: \"illegal alias\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tValidationError(\"dependency \\\"bad\\\" has disallowed characters in the alias\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult := tt.md.Validate()\n\t\tif result != tt.err {\n\t\t\tt.Errorf(\"expected '%s', got '%s'\", tt.err, result)\n\t\t}\n\t}\n}\n\nfunc TestValidateDependency(t *testing.T) {\n\tdep := &Dependency{\n\t\tName: \"example\",\n\t}\n\tfor value, shouldFail := range map[string]bool{\n\t\t\"abcdefghijklmenopQRSTUVWXYZ-0123456780_\": false,\n\t\t\"-okay\":      false,\n\t\t\"_okay\":      false,\n\t\t\"- bad\":      true,\n\t\t\" bad\":       true,\n\t\t\"bad\\nvalue\": true,\n\t\t\"bad \":       true,\n\t\t\"bad$\":       true,\n\t} {\n\t\tdep.Alias = value\n\t\tres := validateDependency(dep)\n\t\tif res != nil && !shouldFail {\n\t\t\tt.Errorf(\"Failed on case %q\", dep.Alias)\n\t\t} else if res == nil && shouldFail {\n\t\t\tt.Errorf(\"Expected failure for %q\", dep.Alias)\n\t\t}\n\t}\n}\n"], "filenames": ["pkg/chart/chart.go", "pkg/chart/errors.go", "pkg/chart/metadata.go", "pkg/chart/metadata_test.go"], "buggy_code_start_loc": [19, 17, 83, 50], "buggy_code_end_loc": [27, 23, 94, 59], "fixing_code_start_loc": [20, 18, 84, 51], "fixing_code_end_loc": [32, 31, 114, 108], "type": "CWE-74", "message": "In Helm before versions 2.16.11 and 3.3.2 there is a bug in which the `alias` field on a `Chart.yaml` is not properly sanitized. This could lead to the injection of unwanted information into a chart. This issue has been patched in Helm 3.3.2 and 2.16.11. A possible workaround is to manually review the `dependencies` field of any untrusted chart, verifying that the `alias` field is either not used, or (if used) does not contain newlines or path characters.", "other": {"cve": {"id": "CVE-2020-15184", "sourceIdentifier": "security-advisories@github.com", "published": "2020-09-17T21:15:17.550", "lastModified": "2021-11-18T17:50:32.987", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Helm before versions 2.16.11 and 3.3.2 there is a bug in which the `alias` field on a `Chart.yaml` is not properly sanitized. This could lead to the injection of unwanted information into a chart. This issue has been patched in Helm 3.3.2 and 2.16.11. A possible workaround is to manually review the `dependencies` field of any untrusted chart, verifying that the `alias` field is either not used, or (if used) does not contain newlines or path characters."}, {"lang": "es", "value": "En Helm versiones anteriores a 2.16.11 y 3.3.2, se presenta un error en el que el campo \"alias\" en un archivo \"Chart.yaml\" no es saneado  apropiadamente.&#xa0;Esto podr\u00eda conllevar a la inyecci\u00f3n de informaci\u00f3n no deseada en un gr\u00e1fico.&#xa0;Este problema ha sido corregido en Helm versiones 3.3.2 y 2.16.11.&#xa0;Una posible soluci\u00f3n es revisar manualmente que el campo \"dependencies\" de cualquier gr\u00e1fico no sea de confianza, verificando que el campo \"alias\" no sea usado o (si se utiliza) no contenga nuevas l\u00edneas o caracteres de ruta"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 2.7, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.7, "baseSeverity": "LOW"}, "exploitabilityScore": 2.2, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:helm:helm:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.16.11", "matchCriteriaId": "455BCCE5-1D43-4E59-9591-E84B52DAAF0B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:helm:helm:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.3.2", "matchCriteriaId": "B462D769-3FC0-4079-8B48-863F013662EF"}]}]}], "references": [{"url": "https://github.com/helm/helm/commit/e7c281564d8306e1dcf8023d97f972449ad74850", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/helm/helm/security/advisories/GHSA-9vp5-m38w-j776", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/helm/helm/commit/e7c281564d8306e1dcf8023d97f972449ad74850"}}