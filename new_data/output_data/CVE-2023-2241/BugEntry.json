{"buggy_code": ["cmake_minimum_required(VERSION 3.16)\n\nif (\"${CMAKE_BUILD_TYPE}\" STREQUAL \"\")\n    set(CMAKE_BUILD_TYPE \"Release\")\nendif()\n\n# Clean CMAKE_CONFIGURATION_TYPES. Only one configuration will be used\nunset(CMAKE_CONFIGURATION_TYPES CACHE) # It will also remove it from GUI\nset(CMAKE_CONFIGURATION_TYPES \"${CMAKE_BUILD_TYPE}\")\n\nproject(PoDoFo)\nenable_testing() # Needed to enable \"make test\" from binary dir\n\n# An useful variable to check if we are running from playground\nset(PODOFO_PLAYGROUND TRUE)\n\nif (\"${ARCH}\" STREQUAL \"\")\n    message(FATAL_ERROR \"ARCH is not set. Run the boostrap scripts\")\nendif()\n\nif (\"${PODOFO_DIR}\" STREQUAL \"\")\n    get_filename_component(PODOFO_DIR ${CMAKE_CURRENT_SOURCE_DIR} DIRECTORY)\nendif()\n\nset(DEPS_PATH \"$ENV{PODOFO_DEPS_PATH}\")\nif (\"${DEPS_PATH}\" STREQUAL \"\")\n    set(DEPS_PATH \"${PODOFO_DIR}/extern/deps/3rdparty\")\nendif()\n\nif(NOT EXISTS \"${DEPS_PATH}\")\n    message(FATAL_ERROR \"Deps path doesn't exists: try fetch git submodules with:\\n    git submodule update --init\")\nendif()\n\nif (MSVC)\n    # Ignore warnings about missing pdbs\n    set(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} /ignore:4099\")\n    set(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} /ignore:4099\")\n    set(CMAKE_STATIC_LINKER_FLAGS \"${CMAKE_STATIC_LINKER_FLAGS} /ignore:4099\")\nendif()\n\nmessage(\"ARCHITECTURE: ${ARCH}\")\nmessage(\"PODOFO_DIR: ${PODOFO_DIR}\")\nmessage(\"DEPS_PATH: ${DEPS_PATH}\")\n\n# Set include folders for find_package()\nlist(APPEND CMAKE_INCLUDE_PATH\n    \"${DEPS_PATH}/zlib/include\"\n    \"${DEPS_PATH}/libxml2/include\"\n    \"${DEPS_PATH}/fontconfig/include\"\n    \"${DEPS_PATH}/freetype/include\"\n    \"${DEPS_PATH}/libpng/include\"\n    \"${DEPS_PATH}/libjpeg/include\"\n    \"${DEPS_PATH}/libtiff/include\"\n    \"${DEPS_PATH}/openssl/include\"\n    \"${DEPS_PATH}/libidn/include\"\n)\n\n# Set library folders for find_package()\nlist(APPEND CMAKE_LIBRARY_PATH\n    \"${DEPS_PATH}/zlib/lib/${ARCH}\"\n    \"${DEPS_PATH}/libxml2/lib/${ARCH}\"\n    \"${DEPS_PATH}/freetype/lib/${ARCH}\"\n    \"${DEPS_PATH}/fontconfig/lib/${ARCH}\"\n    \"${DEPS_PATH}/libpng/lib/${ARCH}\"\n    \"${DEPS_PATH}/libjpeg/lib/${ARCH}\"\n    \"${DEPS_PATH}/libtiff/lib/${ARCH}\"\n    \"${DEPS_PATH}/openssl/lib/${ARCH}\"\n    \"${DEPS_PATH}/libidn/lib/${ARCH}\"\n)\n\n# Set use libxml2 static for fontconfig\nadd_compile_definitions(LIBXML_STATIC)\n# Set use libidn static\nadd_compile_definitions(LIBIDN_STATIC)\n\nif(WIN32)\n    if (\"${CMAKE_BUILD_TYPE}\" STREQUAL \"Debug\")\n        set(LIB_SUFFIX \"d\")\n    endif()\n\n    # Following libraries find-modules have issues in correctly\n    # determining the right optimized/debug library so we do it manually\n\n    # OpenSSL\n    set(OPENSSL_INCLUDE_DIR \"${DEPS_PATH}/openssl/include\" CACHE PATH \"\" FORCE)\n    set(LIB_EAY_DEBUG \"${DEPS_PATH}/openssl/lib/${ARCH}/cryptod.lib\" CACHE FILEPATH \"\" FORCE)\n    set(LIB_EAY_RELEASE \"${DEPS_PATH}/openssl/lib/${ARCH}/crypto.lib\" CACHE FILEPATH \"\" FORCE)\n    set(SSL_EAY_DEBUG \"${DEPS_PATH}/openssl/lib/${ARCH}/ssld.lib\" CACHE FILEPATH \"\" FORCE)\n    set(SSL_EAY_RELEASE \"${DEPS_PATH}/openssl/lib/${ARCH}/ssl.lib\" CACHE FILEPATH \"\" FORCE)\n    # Libxml2\n    set(LIBXML2_LIBRARY \"${DEPS_PATH}/libxml2/lib/${ARCH}/libxml2${LIB_SUFFIX}.lib\" CACHE FILEPATH \"\" FORCE)\n    # Fontconfig\n    set(Fontconfig_LIBRARY \"${DEPS_PATH}/fontconfig/lib/${ARCH}/fontconfig${LIB_SUFFIX}.lib\" CACHE FILEPATH \"\" FORCE)\nelse()\n    # Freetype\n    set(FREETYPE_INCLUDE_DIR_ft2build \"${DEPS_PATH}/freetype/include/freetype2\" CACHE PATH \"\" FORCE)\n    set(FREETYPE_INCLUDE_DIR_freetype2 \"${DEPS_PATH}/freetype/include\" CACHE PATH \"\" FORCE)\n    set(FREETYPE_LIBRARY_RELEASE \"${DEPS_PATH}/freetype/lib/${ARCH}/libfreetype.a\" CACHE FILEPATH \"\" FORCE)\n    # Fontconfig\n    set(Fontconfig_LIBRARY \"${DEPS_PATH}/fontconfig/lib/${ARCH}/libfontconfig.a\" CACHE FILEPATH \"\" FORCE)\n    set(PLATFORM_SYSTEM_LIBRARIES \"${DEPS_PATH}/bzip2/lib/${ARCH}/libbz2.a\" \"${DEPS_PATH}/libuuid/lib/${ARCH}/libuuid.a\")\nendif()\n\nadd_subdirectory(\"${PODOFO_DIR}\" \"${CMAKE_BINARY_DIR}/podofo\")\n", "/**\n * SPDX-FileCopyrightText: (C) 2009 Dominik Seichter <domseichter@web.de>\n * SPDX-FileCopyrightText: (C) 2020 Francesco Pretto <ceztko@gmail.com>\n * SPDX-License-Identifier: LGPL-2.0-or-later\n */\n\n#include <podofo/private/PdfDeclarationsPrivate.h>\n#include \"PdfXRefStreamParserObject.h\"\n\n#include \"PdfParser.h\"\n#include \"PdfArray.h\"\n#include \"PdfDictionary.h\"\n#include \"PdfObjectStream.h\"\n#include \"PdfVariant.h\"\n\nusing namespace std;\nusing namespace PoDoFo;\n\nPdfXRefStreamParserObject::PdfXRefStreamParserObject(PdfDocument& doc, InputStreamDevice& device, PdfXRefEntries& entries)\n    : PdfXRefStreamParserObject(&doc, device, entries) { }\n\nPdfXRefStreamParserObject::PdfXRefStreamParserObject(InputStreamDevice& device, PdfXRefEntries& entries)\n    : PdfXRefStreamParserObject(nullptr, device, entries) { }\n\nPdfXRefStreamParserObject::PdfXRefStreamParserObject(PdfDocument* doc, InputStreamDevice& device, PdfXRefEntries& entries)\n    : PdfParserObject(doc, PdfReference(), device, -1), m_NextOffset(-1), m_entries(&entries)\n{\n}\n\nvoid PdfXRefStreamParserObject::DelayedLoadImpl()\n{\n    // NOTE: Ignore the encryption in the XREF as the XREF stream must no be encrypted (see PDF Reference 3.4.7)\n\n    PdfTokenizer tokenizer;\n    auto reference = ReadReference(tokenizer);\n    SetIndirectReference(reference);\n    PdfParserObject::Parse(tokenizer);\n\n    // Do some very basic error checking\n    auto& dict = m_Variant.GetDictionary();\n    auto keyObj = dict.FindKey(PdfName::KeyType);\n    if (keyObj == nullptr)\n        PODOFO_RAISE_ERROR(PdfErrorCode::NoXRef);\n\n    if (!keyObj->IsName() || keyObj->GetName() != \"XRef\")\n        PODOFO_RAISE_ERROR(PdfErrorCode::NoXRef);\n\n    if (!dict.HasKey(PdfName::KeySize)\n        || !dict.HasKey(\"W\"))\n    {\n        PODOFO_RAISE_ERROR(PdfErrorCode::NoXRef);\n    }\n\n    if (dict.HasKey(\"Prev\"))\n        m_NextOffset = static_cast<ssize_t>(dict.FindKeyAs<double>(\"Prev\", 0));\n\n    if (!this->HasStreamToParse())\n        PODOFO_RAISE_ERROR(PdfErrorCode::NoXRef);\n}\n\nvoid PdfXRefStreamParserObject::ReadXRefTable()\n{\n    int64_t size = this->GetDictionary().FindKeyAs<int64_t>(PdfName::KeySize, 0);\n    auto& arrObj = this->GetDictionary().MustFindKey(\"W\");\n\n    // The pdf reference states that W is always an array with 3 entries\n    // all of them have to be integers\n    const PdfArray* arr;\n    if (!arrObj.TryGetArray(arr) || arr->size() != 3)\n        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef stream /W array\");\n\n    int64_t wArray[W_ARRAY_SIZE] = { 0, 0, 0 };\n    int64_t num;\n    for (unsigned i = 0; i < W_ARRAY_SIZE; i++)\n    {\n\n        if (!(*arr)[i].TryGetNumber(num))\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef stream /W array\");\n\n        wArray[i] = num;\n    }\n\n    vector<int64_t> indices;\n    getIndices(indices, static_cast<int64_t>(size));\n\n    parseStream(wArray, indices);\n}\n\nvoid PdfXRefStreamParserObject::parseStream(const int64_t wArray[W_ARRAY_SIZE], const vector<int64_t>& indices)\n{\n    for (int64_t lengthSum = 0, i = 0; i < W_ARRAY_SIZE; i++)\n    {\n        if (wArray[i] < 0)\n        {\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef,\n                \"Negative field length in XRef stream\");\n        }\n        if (numeric_limits<int64_t>::max() - lengthSum < wArray[i])\n        {\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef,\n                \"Invalid entry length in XRef stream\");\n        }\n        else\n        {\n            lengthSum += wArray[i];\n        }\n    }\n\n    const size_t entryLen = static_cast<size_t>(wArray[0] + wArray[1] + wArray[2]);\n\n    charbuff buffer;\n    this->GetOrCreateStream().CopyTo(buffer);\n\n    vector<int64_t>::const_iterator it = indices.begin();\n    char* cursor = buffer.data();\n    while (it != indices.end())\n    {\n        int64_t firstObj = *it++;\n        int64_t count = *it++;\n\n        m_entries->Enlarge(firstObj + count);\n        for (unsigned index = 0; index < (unsigned)count; index++)\n        {\n            if ((size_t)(cursor - buffer.data()) >= buffer.size())\n                PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid count in XRef stream\");\n\n            unsigned objIndex = (unsigned)firstObj + index;\n            auto& entry = (*m_entries)[objIndex];\n            if (objIndex < m_entries->GetSize() && !entry.Parsed)\n                readXRefStreamEntry(entry, cursor, wArray);\n\n            cursor += entryLen;\n        }\n    }\n}\n\nvoid PdfXRefStreamParserObject::getIndices(vector<int64_t>& indices, int64_t size)\n{\n    // get the first object number in this crossref stream.\n    // it is not required to have an index key though\n    auto indexObj = this->GetDictionary().GetKey(\"Index\");\n    if (indexObj == nullptr)\n    {\n        // Default\n        indices.push_back(static_cast<int64_t>(0));\n        indices.push_back(size);\n    }\n    else\n    {\n        const PdfArray* arr;\n        if (!indexObj->TryGetArray(arr))\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef Stream /Index\");\n\n        for (auto index : *arr)\n            indices.push_back(index.GetNumber());\n    }\n\n    // indices must be a multiple of 2\n    if (indices.size() % 2 != 0)\n        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef Stream /Index\");\n}\n\nvoid PdfXRefStreamParserObject::readXRefStreamEntry(PdfXRefEntry& entry, char* buffer, const int64_t wArray[W_ARRAY_SIZE])\n{\n    uint64_t entryRaw[W_ARRAY_SIZE];\n    for (unsigned i = 0; i < W_ARRAY_SIZE; i++)\n    {\n        if (wArray[i] > W_MAX_BYTES)\n        {\n            PoDoFo::LogMessage(PdfLogSeverity::Error,\n                \"The XRef stream dictionary has an entry in /W of size {}. The maximum supported value is {}\",\n                wArray[i], W_MAX_BYTES);\n\n            PODOFO_RAISE_ERROR(PdfErrorCode::InvalidXRefStream);\n        }\n\n        entryRaw[i] = 0;\n        for (int64_t z = W_MAX_BYTES - wArray[i]; z < W_MAX_BYTES; z++)\n        {\n            entryRaw[i] = (entryRaw[i] << 8) + static_cast<unsigned char>(*buffer);\n            buffer++;\n        }\n    }\n\n    entry.Parsed = true;\n\n    // TABLE 3.15 Additional entries specific to a cross - reference stream dictionary\n    // /W array: \"If the first element is zero, the type field is not present, and it defaults to type 1\"\n    uint64_t type;\n    if (wArray[0] == 0)\n        type = 1;\n    else\n        type = entryRaw[0]; // nData[0] contains the type information of this entry\n\n    switch (type)\n    {\n        // TABLE 3.16 Entries in a cross-reference stream\n        case 0:\n            // a free object\n            entry.ObjectNumber = entryRaw[1];\n            entry.Generation = (uint32_t)entryRaw[2];\n            entry.Type = XRefEntryType::Free;\n            break;\n        case 1:\n            // normal uncompressed object\n            entry.Offset = entryRaw[1];\n            entry.Generation = (uint32_t)entryRaw[2];\n            entry.Type = XRefEntryType::InUse;\n            break;\n        case 2:\n            // object that is part of an object stream\n            entry.ObjectNumber = entryRaw[1]; // object number of the stream\n            entry.Index = (uint32_t)entryRaw[2]; // index in the object stream\n            entry.Type = XRefEntryType::Compressed;\n            break;\n        default:\n            PODOFO_RAISE_ERROR(PdfErrorCode::InvalidXRefType);\n    }\n}\n\nbool PdfXRefStreamParserObject::TryGetPreviousOffset(size_t& previousOffset) const\n{\n    bool ret = m_NextOffset != -1;\n    previousOffset = ret ? (size_t)m_NextOffset : 0;\n    return ret;\n}\n", "/**\n * Copyright (C) 2007 by Dominik Seichter <domseichter@web.de>\n * Copyright (C) 2021 by Francesco Pretto <ceztko@gmail.com>\n *\n * Licensed under GNU Library General Public 2.0 or later.\n * Some rights reserved. See COPYING, AUTHORS.\n */\n\n/*\n    Notes:\n\n    1) out of memory tests don't run if Address Santizer (ASAN) is enabled because\n       ASAN terminates the unit test process the first time it attempts to allocate\n       too much memory (so running the tests with and without ASAN is recommended)\n\n    2) PoDoFo log warnings about inconsistencies or values out of range are expected\n       because the tests are supplying invalid values to check PoDoFo behaves correctly\n       in those situations\n*/\n\n#include <limits>\n\n#include <sstream>\n\n#include <PdfTest.h>\n\nusing namespace std;\nusing namespace PoDoFo;\n\nstatic string generateXRefEntries(size_t count);\nstatic bool canOutOfMemoryKillUnitTests();\nstatic void testReadXRefSubsection();\nstatic size_t getStackOverflowDepth();\n\n// this value is from Table C.1 in Appendix C.2 Architectural Limits in PDF 32000-1:2008\n// on 32-bit systems sizeof(PdfParser::TXRefEntry)=16 => max size of m_offsets=16*8,388,607 = 134 MB\n// on 64-bit systems sizeof(PdfParser::TXRefEntry)=24 => max size of m_offsets=16*8,388,607 = 201 MB\nconstexpr unsigned maxNumberOfIndirectObjects = 8388607;\n\nnamespace PoDoFo\n{\n    class PdfParserTest : public PdfParser\n    {\n    public:\n        PdfParserTest(PdfIndirectObjectList& objectList, string buff)\n            : PdfParser(objectList), m_buffer(std::move(buff)), m_device(new SpanStreamDevice(m_buffer))\n        {\n        }\n\n        void ReadXRefContents(size_t offset, bool positionAtEnd)\n        {\n            // call protected method\n            PdfParser::ReadXRefContents(*m_device, offset, positionAtEnd);\n        }\n\n        void ReadXRefSubsection(int64_t firstObject, int64_t objectCount)\n        {\n            // call protected method\n            PdfParser::ReadXRefSubsection(*m_device, firstObject, objectCount);\n        }\n\n        void ReadXRefStreamContents(size_t offset, bool readOnlyTrailer)\n        {\n            // call protected method\n            PdfParser::ReadXRefStreamContents(*m_device, offset, readOnlyTrailer);\n        }\n\n        void ReadDocumentStructure()\n        {\n            // call protected method\n            PdfParser::ReadDocumentStructure(*m_device);\n        }\n\n        void ReadObjects()\n        {\n            // call protected method\n            PdfParser::ReadObjects(*m_device);\n        }\n\n        bool IsPdfFile()\n        {\n            // call protected method\n            return PdfParser::IsPdfFile(*m_device);\n        }\n\n        const shared_ptr<InputStreamDevice>& GetDevice() { return m_device; }\n\n    private:\n        string m_buffer;\n        shared_ptr<InputStreamDevice> m_device;\n    };\n}\n\nTEST_CASE(\"TestMaxObjectCount\")\n{\n    PdfParser::SetMaxObjectCount(numeric_limits<unsigned short>::max());\n    testReadXRefSubsection();\n\n    PdfParser::SetMaxObjectCount(maxNumberOfIndirectObjects);\n    testReadXRefSubsection();\n}\n\n// NOTE: This test is too long to be normally done on every run\nTEST_CASE(\"TestMaxObjectCount2\", \"[.]\")\n{\n    PdfParser::SetMaxObjectCount(numeric_limits<unsigned>::max());\n    testReadXRefSubsection();\n}\n\n\nTEST_CASE(\"TestReadXRefContents\")\n{\n    try\n    {\n        // generate an xref section\n        // xref\n        // 0 3\n        // 0000000000 65535 f \n        // 0000000018 00000 n \n        // 0000000077 00000 n\n        // trailer << /Root 1 0 R /Size 3 >>\n        // startxref\n        // 0\n        // %%EOF\n        ostringstream oss;\n        oss << \"xref\\r\\n0 3\\r\\n\";\n        oss << generateXRefEntries(3);\n        oss << \"trailer << /Root 1 0 R /Size 3 >>\\r\\n\";\n        oss << \"startxref 0\\r\\n\";\n        oss << \"%EOF\";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, oss.str());\n        parser.ReadXRefContents(0, false);\n        // expected to succeed\n    }\n    catch (PdfError&)\n    {\n        FAIL(\"Should not throw PdfError\");\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    try\n    {\n        // generate an xref section with missing xref entries\n        // xref\n        // 0 3\n        // 0000000000 65535 f \n        // 0000000018 00000 n \n        // \n        // trailer << /Root 1 0 R /Size 3 >>\n        // startxref\n        // 0\n        // %%EOF        \n        ostringstream oss;\n        oss << \"xref\\r\\n0 3\\r\\n\";\n        oss << generateXRefEntries(2); // 2 entries supplied, but expecting 3 entries\n        oss << \"trailer << /Root 1 0 R /Size 3 >>\\r\\n\";\n        oss << \"startxref 0\\r\\n\";\n        oss << \"%EOF\";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, oss.str());\n        parser.ReadXRefContents(0, false);\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    try\n    {\n        // TODO malformed entries are not detected\n        // generate an xref section with badly formed xref entries\n        // xref\n        // 0 3        \n        // 000000000 65535\n        // 00000000065535 x\n        // 0000000\n        // 0000000018 00000 n\n        // 0000000077 00000 n        \n        // trailer << /Root 1 0 R /Size 3 >>\n        // startxref\n        // 0\n        // %%EOF\n        ostringstream oss;\n        oss << \"xref\\r\\n0 5\\r\\n\";\n        oss << \"000000000 65535\\r\\n\";\n        oss << \"00000000065535 x\\r\\n\";\n        oss << \"0000000\\r\\n\";\n        oss << generateXRefEntries(2);\n        oss << \"trailer << /Root 1 0 R /Size 5 >>\\r\\n\";\n        oss << \"startxref 0\\r\\n\";\n        oss << \"%EOF\";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, oss.str());\n        parser.ReadXRefContents(0, false);\n        // succeeds reading badly formed xref entries  - should it?\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    // CVE-2017-8053 ReadXRefContents and ReadXRefStreamContents are mutually recursive   \n    // and can cause stack overflow\n\n    try\n    {\n        // generate an xref section and one XRef stream that references itself\n        // via the /Prev entry (but use a slightly lower offset by linking to\n        // to whitespace discarded by the tokenizer just before the xref section)\n        // xref\n        // 0 1\n        // 000000000 65535\n        // 2 0 obj << /Type XRef /Prev offsetXrefStmObj2 >> stream ... endstream\n        // trailer << /Root 1 0 R /Size 3 >>\n        // startxref\n        // offsetXrefStmObj2\n        // %%EOF\n        ostringstream oss;\n\n        // object stream contents - length excludes trailing whitespace\n        string streamContents =\n            \"01 0E8A 0\\r\\n\"\n            \"02 0002 00\\r\\n\";\n        size_t streamContentsLength = streamContents.size() - strlen(\"\\r\\n\");\n\n        // xref section at offset 0\n        //size_t offsetXref = 0;\n        oss << \"xref\\r\\n0 1\\r\\n\";\n        oss << generateXRefEntries(1);\n\n        // XRef stream at offsetXrefStm1, but any /Prev entries pointing to any offet between\n        // offsetXrefStm1Whitespace and offsetXrefStm1 point to the same /Prev section\n        // because the PDF processing model says tokenizer must discard whitespace and comments\n        size_t offsetXrefStm1Whitespace = oss.str().length();\n        oss << \"    \\r\\n\";\n        oss << \"% comments and leading white space are ignored - see PdfTokenizer::GetNextToken\\r\\n\";\n        size_t offsetXrefStm1 = oss.str().length();\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << streamContentsLength << \" \";\n        oss << \"/Index [2 2] \";\n        oss << \"/Size 3 \";\n        oss << \"/Prev \" << offsetXrefStm1Whitespace << \" \";     // xref /Prev offset points back to start of this stream object\n        oss << \"/W [1 2 1] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        oss << streamContents;\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n\n        oss << \"trailer << /Root 1 0 R /Size 3 >>\\r\\n\";\n        oss << \"startxref \" << offsetXrefStm1 << \"\\r\\n\";\n        oss << \"%EOF\";\n\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, oss.str());\n        parser.ReadXRefContents(offsetXrefStm1, false);\n        // succeeds in current code - should it?\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRefType);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    try\n    {\n        // generate an xref section and two XRef streams that reference each other\n        // via the /Prev entry\n        // xref\n        // 0 1\n        // 000000000 65535\n        // 2 0 obj << /Type XRef /Prev offsetXrefStmObj3 >> stream ...  endstream\n        // 3 0 obj << /Type XRef /Prev offsetXrefStmObj2 >> stream ...  endstream\n        // trailer << /Root 1 0 R /Size 3 >>\n        // startxref\n        // offsetXrefStmObj2\n        // %%EOF\n        ostringstream oss;\n\n        // object stream contents - length excludes trailing whitespace\n        string streamContents =\n            \"01 0E8A 0\\r\\n\"\n            \"02 0002 00\\r\\n\";\n        size_t streamContentsLength = streamContents.size() - strlen(\"\\r\\n\");\n\n        // xref section at offset 0\n        //size_t offsetXref = 0;\n        oss << \"xref\\r\\n0 1\\r\\n\";\n        oss << generateXRefEntries(1);\n\n        // xrefstm at offsetXrefStm1\n        size_t offsetXrefStm1 = oss.str().length();\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << streamContentsLength << \" \";\n        oss << \"/Index [2 2] \";\n        oss << \"/Size 3 \";\n        oss << \"/Prev 185 \";     // xref stream 1 sets xref stream 2 as previous in chain\n        oss << \"/W [1 2 1] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        oss << streamContents;\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n\n        // xrefstm at offsetXrefStm2\n        size_t offsetXrefStm2 = oss.str().length();\n        REQUIRE(offsetXrefStm2 == 185); // hard-coded in /Prev entry in XrefStm1 above\n        oss << \"3 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << streamContentsLength << \" \";\n        oss << \"/Index [2 2] \";\n        oss << \"/Size 3 \";\n        oss << \"/Prev \" << offsetXrefStm1 << \" \";     // xref stream 2 sets xref stream 1 as previous in chain\n        oss << \"/W [1 2 1] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        oss << streamContents;\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n\n        oss << \"trailer << /Root 1 0 R /Size 3 >>\\r\\n\";\n        oss << \"startxref \" << offsetXrefStm2 << \"\\r\\n\";\n        oss << \"%EOF\";\n\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, oss.str());\n        parser.ReadXRefContents(offsetXrefStm2, false);\n        // succeeds in current code - should it?\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRefType);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    try\n    {\n        // generate an xref section and lots of XRef streams without loops but reference \n        // the previous stream via the /Prev entry\n        // xref\n        // 0 1\n        // 000000000 65535\n        // 2 0 obj << /Type XRef >> stream ...  endstream\n        // 3 0 obj << /Type XRef /Prev offsetStreamObj(2) >> stream ...  endstream\n        // 4 0 obj << /Type XRef /Prev offsetStreamObj(3) >> stream ...  endstream\n        // ...\n        // N 0 obj << /Type XRef /Prev offsetStreamObj(N-1) >> stream ...  endstream\n        // trailer << /Root 1 0 R /Size 3 >>\n        // startxref\n        // offsetStreamObj(N)\n        // %%EOF\n        ostringstream oss;\n        size_t prevOffset = 0;\n        size_t currentOffset = 0;\n\n        // object stream contents - length excludes trailing whitespace\n        string streamContents =\n            \"01 0E8A 0\\r\\n\"\n            \"02 0002 00\\r\\n\";\n        size_t streamContentsLength = streamContents.size() - strlen(\"\\r\\n\");\n\n        // xref section at offset 0\n        //size_t offsetXref = 0;\n        oss << \"xref\\r\\n0 1\\r\\n\";\n        oss << generateXRefEntries(1);\n\n        // this caused stack overflow on macOS 64-bit with around 3000 streams\n        // and on Windows 32-bit with around 1000 streams\n\n        constexpr size_t maxXrefStreams = 10000;\n        for (size_t i = 0; i < maxXrefStreams; i++)\n        {\n            size_t objNo = i + 2;\n\n            // xrefstm at currentOffset linked back to stream at prevOffset\n            prevOffset = currentOffset;\n            currentOffset = oss.str().length();\n            oss << objNo << \" 0 obj \";\n            oss << \"<< /Type /XRef \";\n            oss << \"/Length \" << streamContentsLength << \" \";\n            oss << \"/Index [2 2] \";\n            oss << \"/Size 3 \";\n            if (prevOffset > 0)\n                oss << \"/Prev \" << prevOffset << \" \";\n            oss << \"/W [1 2 1] \";\n            oss << \"/Filter /ASCIIHexDecode \";\n            oss << \">>\\r\\n\";\n            oss << \"stream\\r\\n\";\n            oss << streamContents;\n            oss << \"endstream\\r\\n\";\n            oss << \"endobj\\r\\n\";\n        }\n\n        oss << \"trailer << /Root 1 0 R /Size 3 >>\\r\\n\";\n        oss << \"startxref \" << currentOffset << \"\\r\\n\";\n        oss << \"%EOF\";\n\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, oss.str());\n        parser.ReadXRefContents(currentOffset, false);\n        // succeeds in current code - should it?\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRefType);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n}\n\nvoid testReadXRefSubsection()\n{\n    int64_t firstObject = 0;\n    int64_t objectCount = 0;\n\n    // TODO does ReadXRefSubsection with objectCount = 0 make sense ???\n\n    // CVE-2017-5855 m_offsets.resize() NULL ptr read\n    // CVE-2017-6844 m_offsets.resize() buffer overwrite \n    // false positives due to AFL setting allocator_may_return_null=1 which causes\n    // ASAN to return NULL instead of throwing bad_alloc for out-of-memory conditions\n    // https://github.com/mirrorer/afl/blob/master/docs/env_variables.txt#L248\n    // https://github.com/google/sanitizers/issues/295#issuecomment-234273218 \n    // the test for CVE-2018-5296 below checks that PoDoFo restricts allocations\n\n    // CVE-2018-5296 m_offsets.resize() malloc failure when large size specified\n    // check PoDoFo throws PdfError and not anything derived from exception\n    // check PoDoFo can't allocate unrestricted amounts of memory\n\n    if (PdfParser::GetMaxObjectCount() <= maxNumberOfIndirectObjects)\n    {\n        try\n        {\n            string strInput = generateXRefEntries(PdfParser::GetMaxObjectCount());\n            PdfIndirectObjectList objects;\n            PdfParserTest parser(objects, strInput);\n            firstObject = 0;\n            objectCount = PdfParser::GetMaxObjectCount();\n            parser.ReadXRefSubsection(firstObject, objectCount);\n            // expected to succeed\n        }\n        catch (PdfError&)\n        {\n            FAIL(\"should not throw PdfError\");\n        }\n        catch (exception&)\n        {\n            FAIL(\"Unexpected exception type\");\n        }\n    }\n    else\n    {\n        // test has been called from testMaxObjectCount with PdfParser::SetMaxObjectCount()\n        // set to a large value (large allocs are tested in address space tests below)\n    }\n\n    // don't run the following test if PdfParser::GetMaxObjectCount()+1 will overflow\n    // in the numXRefEntries calculation below (otherwise we get an ASAN error)\n    if (PdfParser::GetMaxObjectCount() < numeric_limits<unsigned>::max())\n    {\n        // don't generate xrefs for high values of GetMaxObjectCount() e.g. don't try to generate 2**63 xrefs\n        unsigned numXRefEntries = std::min(maxNumberOfIndirectObjects + 1, PdfParser::GetMaxObjectCount() + 1);\n\n        try\n        {\n            string strInput = generateXRefEntries(numXRefEntries);\n            PdfIndirectObjectList objects;\n            PdfParserTest parser(objects, strInput);\n            firstObject = 0;\n            objectCount = (int64_t)PdfParser::GetMaxObjectCount() + 1;\n            parser.ReadXRefSubsection(firstObject, objectCount);\n            FAIL(\"PdfError not thrown\");\n        }\n        catch (PdfError& error)\n        {\n            // too many indirect objects in Trailer /Size key throws PdfErrorCode::ValueOutOfRange\n            // but too many indirect objects in xref table throws PdfErrorCode::InvalidXRef\n            REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n        }\n        catch (exception&)\n        {\n            FAIL(\"Wrong exception type\");\n        }\n    }\n\n    // CVE-2018-5296 try to allocate more than address space size \n    // should throw a bad_length exception in STL which is rethrown as a PdfError\n    try\n    {\n        // this attempts to allocate numeric_limits<size_t>::max()/2 * sizeof(TXRefEntry)\n        // on 32-bit systems this allocates 2**31 * sizeof(TXRefEntry) = 2**31 * 16 (larger than 32-bit address space)\n        // on LP64 (macOS,*nix) systems this allocates 2**63 * sizeof(TXRefEntry) = 2**63 * 24 (larger than 64-bit address space)\n        // on LLP64 (Win64) systems this allocates 2**31 * sizeof(TXRefEntry) = 2**31 * 16 (smaller than 64-bit address space)\n        string strInput = \" \";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = 1;\n        objectCount = numeric_limits<size_t>::max() / 2 - 1;\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        // if objectCount > PdfParser::GetMaxObjectCount() then we'll see PdfErrorCode::InvalidXRef\n        // otherwise we'll see PdfErrorCode::ValueOutOfRange or PdfErrorCode::OutOfMemory (see testMaxObjectCount)\n        REQUIRE((error.GetCode() == PdfErrorCode::InvalidXRef\n            || error.GetCode() == PdfErrorCode::ValueOutOfRange\n            || error.GetCode() == PdfErrorCode::OutOfMemory));\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2018-5296 try to allocate 95% of VM address space size (which should always fail)\n    if (!canOutOfMemoryKillUnitTests())\n    {\n        constexpr size_t maxObjects = numeric_limits<size_t>::max() / sizeof(PdfXRefEntry) / 100 * 95;\n\n        try\n        {\n            string strInput = \" \";\n            PdfIndirectObjectList objects;\n            PdfParserTest parser(objects, strInput);\n            firstObject = 1;\n            objectCount = maxObjects;\n            parser.ReadXRefSubsection(firstObject, objectCount);\n            FAIL(\"PdfError not thrown\");\n        }\n        catch (PdfError& error)\n        {\n            if (maxObjects >= (size_t)PdfParser::GetMaxObjectCount())\n                REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n            else\n                REQUIRE(error.GetCode() == PdfErrorCode::OutOfMemory);\n        }\n        catch (exception&)\n        {\n            FAIL(\"Wrong exception type\");\n        }\n    }\n\n    // CVE-2015-8981 happens because this->GetNextNumber() can return negative numbers \n    // in range (LONG_MIN to LONG_MAX) so the xref section below causes a buffer underflow\n    // because m_offsets[-5].bParsed is set to true when first entry is read\n    // NOTE: vector operator[] is not bounds checked\n\n    // xref\n    // -5 5\n    // 0000000000 65535 f \n    // 0000000018 00000 n \n    // 0000000077 00000 n \n    // 0000000178 00000 n \n    // 0000000457 00000 n \n    // trailer\n    // <<  /Root 1 0 R\n    //    /Size 5\n    //>>\n    // startxref\n    // 565\n    // %%EOF\n\n    try\n    {\n        string strInput = \"0000000000 65535 f\\r\\n\";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = -5LL;\n        objectCount = 5;\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE((error.GetCode() == PdfErrorCode::ValueOutOfRange || error.GetCode() == PdfErrorCode::NoXRef));\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2015-8981 can also happen due to integer overflow in firstObject+objectCount\n    // in the example below 2147483647=0x7FFF, so 0x7FFF + 0x7FFF = 0XFFFE = -2 on a 32-bit system\n    // which means m_offsets.size()=5 because m_offsets.resize() is never called and \n    // m_offsets[2147483647].bParsed is set to true when first entry is read\n    // NOTE: vector operator[] is not bounds checked\n\n    // 2147483647 2147483647 \n    // 0000000000 65535 f \n    // 0000000018 00000 n \n    // 0000000077 00000 n \n    // 0000000178 00000 n \n    // 0000000457 00000 n \n    // trailer\n    // <<  /Root 1 0 R\n    //    /Size 5\n    //>>\n    // startxref\n    // 565\n    // %%EOF\n\n    try\n    {\n        string strInput = \"0000000000 65535 f\\r\\n\";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = numeric_limits<unsigned>::max();\n        objectCount = numeric_limits<unsigned>::max();\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    try\n    {\n        string strInput = \"0000000000 65535 f\\r\\n\";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = numeric_limits<int64_t>::max();\n        objectCount = numeric_limits<int64_t>::max();\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::ValueOutOfRange);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // test for integer overflows in ReadXRefSubsection (CVE-2017-5853) which caused\n    // wrong buffer size to be calculated and then triggered buffer overflow (CVE-2017-6844)   \n    // the overflow checks in ReadXRefSubsection depend on the value returned by GetMaxObjectCount\n    // if the value changes these checks need looked at again\n    REQUIRE(PdfParser::GetMaxObjectCount() <= numeric_limits<unsigned>::max());\n\n    // test CVE-2017-5853 signed integer overflow in firstObject + objectCount\n    // CVE-2017-5853 1.1 - firstObject < 0\n    try\n    {\n        string strInput = \" \";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = -1LL;\n        objectCount = 1;\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::ValueOutOfRange);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2017-5853 1.2 - firstObject = min value of unsigned\n    try\n    {\n        string strInput = \" \";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = numeric_limits<unsigned>::min();\n        objectCount = 1;\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::UnexpectedEOF);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2017-5853 1.3 - firstObject = min value of int64_t\n    try\n    {\n        string strInput = \" \";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = numeric_limits<int64_t>::min();\n        objectCount = 1;\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::ValueOutOfRange);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2017-5853 1.4 - firstObject = min value of size_t is zero (size_t is unsigned)\n    // and zero is a valid value for firstObject\n\n    // CVE-2017-5853 1.5 - firstObject = max value of unsigned\n    try\n    {\n        string strInput = \" \";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = numeric_limits<unsigned>::max();\n        objectCount = 1;\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2017-5853 1.6 - firstObject = max value of int64_t\n    try\n    {\n        string strInput = \" \";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = numeric_limits<int64_t>::max();\n        objectCount = 1;\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::ValueOutOfRange);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2017-5853 1.7 - firstObject = max value of size_t\n    try\n    {\n        string strInput = \" \";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = numeric_limits<size_t>::max();\n        objectCount = 1;\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        // weird: different errors returned depending on architecture \n        REQUIRE((error.GetCode() == PdfErrorCode::ValueOutOfRange || sizeof(size_t) == 4));\n        REQUIRE((error.GetCode() == PdfErrorCode::InvalidXRef || sizeof(size_t) == 8));\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2017-5853 1.8 - firstObject = PdfParser::GetMaxObjectCount()\n    try\n    {\n        string strInput = \" \";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        REQUIRE(PdfParser::GetMaxObjectCount() > 0);\n        firstObject = PdfParser::GetMaxObjectCount();\n        objectCount = 1;\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2017-5853 2.1 - objectCount < 0\n    try\n    {\n        string strInput = \" \";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = 1;\n        objectCount = -1LL;\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::ValueOutOfRange);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2017-5853 2.2 - objectCount = min value of int\n    try\n    {\n        string strInput = \" \";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = 1;\n        objectCount = numeric_limits<int>::min();\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::ValueOutOfRange);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2017-5853 2.3 - objectCount = min value of int64_t\n    try\n    {\n        string strInput = \" \";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = 1;\n        objectCount = numeric_limits<int64_t>::min();\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::ValueOutOfRange);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2017-5853 2.4 - objectCount = min value of size_t is zero (size_t is unsigned)\n    // and zero is a valid value for firstObject\n    // TODO\n\n    // CVE-2017-5853 2.5 - objectCount = max value of unsigned\n    try\n    {\n        string strInput = \" \";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = 1;\n        objectCount = numeric_limits<unsigned>::max();\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2017-5853 2.6 - objectCount = max value of int64_t\n    try\n    {\n        string strInput = \" \";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = 1;\n        objectCount = numeric_limits<int64_t>::max();\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::ValueOutOfRange);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2017-5853 2.7 - objectCount = max value of size_t\n    try\n    {\n        string strInput = \" \";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = 1;\n        objectCount = numeric_limits<size_t>::max();\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        // weird: different errors returned depending on architecture \n        REQUIRE((error.GetCode() == PdfErrorCode::ValueOutOfRange || sizeof(size_t) == 4));\n        REQUIRE((error.GetCode() == PdfErrorCode::InvalidXRef || sizeof(size_t) == 8));\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2017-5853 2.8 - objectCount = PdfParser::GetMaxObjectCount()\n    try\n    {\n        string strInput = \" \";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = 1;\n        objectCount = PdfParser::GetMaxObjectCount();\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2017-5853 2.9 - finally - loop through a set of interesting bit patterns\n    static uint64_t s_values[] =\n    {\n        //(1ull << 64) - 1,\n        //(1ull << 64),\n        //(1ull << 64) + 1,\n        (1ull << 63) - 1,\n        (1ull << 63),\n        (1ull << 63) + 1,\n        (1ull << 62) - 1,\n        (1ull << 62),\n        (1ull << 62) + 1,\n\n        (1ull << 49) - 1,\n        (1ull << 49),\n        (1ull << 49) + 1,\n        (1ull << 48) - 1,\n        (1ull << 48),\n        (1ull << 48) + 1,\n        (1ull << 47) - 1,\n        (1ull << 47),\n        (1ull << 47) + 1,\n\n        (1ull << 33) - 1,\n        (1ull << 33),\n        (1ull << 33) + 1,\n        (1ull << 32) - 1,\n        (1ull << 32),\n        (1ull << 32) + 1,\n        (1ull << 31) - 1,\n        (1ull << 31),\n        (1ull << 31) + 1,\n\n        (1ull << 25) - 1,\n        (1ull << 33),\n        (1ull << 33) + 1,\n        (1ull << 24) - 1,\n        (1ull << 24),\n        (1ull << 24) + 1,\n        (1ull << 31) - 1,\n        (1ull << 31),\n        (1ull << 31) + 1,\n\n        (1ull << 17) - 1,\n        (1ull << 17),\n        (1ull << 17) + 1,\n        (1ull << 16) - 1,\n        (1ull << 16),\n        (1ull << 16) + 1,\n        (1ull << 15) - 1,\n        (1ull << 15),\n        (1ull << 15) + 1,\n\n        (uint64_t)-1,\n        0,\n        1\n    };\n    constexpr size_t numValues = sizeof(s_values) / sizeof(s_values[0]);\n\n    for (size_t i = 0; i < numValues; i++)\n    {\n        for (size_t j = 0; j < numValues; j++)\n        {\n            try\n            {\n                string strInput = \" \";\n                PdfIndirectObjectList objects;\n                PdfParserTest parser(objects, strInput);\n                firstObject = s_values[i];\n                objectCount = s_values[j];\n\n                if (canOutOfMemoryKillUnitTests() && (firstObject > maxNumberOfIndirectObjects || objectCount > maxNumberOfIndirectObjects))\n                {\n                    // can't call this in test environments where an out-of-memory condition terminates\n                    // unit test process before all tests have run (e.g. AddressSanitizer)\n                }\n                else\n                {\n                    parser.ReadXRefSubsection(firstObject, objectCount);\n                    // some combinations of firstObject/objectCount from s_values are legal - so we expect to reach here sometimes\n                }\n            }\n            catch (PdfError& error)\n            {\n                // other combinations of firstObject/objectCount from s_values are illegal \n                // if we reach here it should be an invalid xref value of some type\n                REQUIRE((error.GetCode() == PdfErrorCode::InvalidXRef || error.GetCode() == PdfErrorCode::ValueOutOfRange\n                    || error.GetCode() == PdfErrorCode::UnexpectedEOF\n                    || error.GetCode() == PdfErrorCode::OutOfMemory));\n            }\n            catch (exception&)\n            {\n                // and should never reach here\n                FAIL(\"Wrong exception type\");\n            }\n        }\n    }\n}\n\nTEST_CASE(\"testReadXRefStreamContents\")\n{\n    // test valid stream\n    try\n    {\n        // generate an XRef stream with valid /W values\n        ostringstream oss;\n        size_t offsetStream;\n        size_t offsetEndstream;\n\n        // XRef stream with 5 entries\n        size_t lengthXRefObject = 58;\n        size_t offsetXRefObject = oss.str().length();\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [2 2] \";\n        oss << \"/Size 5 \";\n        oss << \"/W [1 2 1] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"01 0E8A 00\\r\\n\";\n        oss << \"02 0002 00\\r\\n\";\n        oss << \"02 0002 01\\r\\n\";\n        oss << \"02 0002 02\\r\\n\";\n        oss << \"02 0002 03\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // hard-coded in /Length entry in XRef stream above\n\n        // trailer\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%%EOF\";\n\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, oss.str());\n        parser.ReadXRefStreamContents(offsetXRefObject, false);\n        // should succeed\n    }\n    catch (PdfError&)\n    {\n        FAIL(\"Unexpected PdfError\");\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    // CVE-2018-5295: integer overflow caused by checking sum of /W entry values /W [ 1 2 9223372036854775807 ]\n    // see https://bugzilla.redhat.com/show_bug.cgi?id=1531897 (/W values used were extracted from PoC file)\n    try\n    {\n        ostringstream oss;\n        size_t offsetStream;\n        size_t offsetEndstream;\n\n        // XRef stream\n        size_t lengthXRefObject = 58;\n        size_t offsetXRefObject = 10;\n        oss << \"%PDF-1.4\\r\\n\";\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [2 2] \";\n        oss << \"/Size 5 \";\n        oss << \"/W [ 1 2 9223372036854775807 ] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"01 0E8A 00\\r\\n\";\n        oss << \"02 0002 00\\r\\n\";\n        oss << \"02 0002 01\\r\\n\";\n        oss << \"02 0002 02\\r\\n\";\n        oss << \"02 0002 03\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // check /Length entry in XRef stream above\n\n        // trailer\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%%EOF\";\n\n        auto inputStr = oss.str();\n        PdfXRefEntries offsets;\n        auto device = std::make_shared<SpanStreamDevice>(inputStr);\n        PdfMemDocument doc;\n        // Parse a doc using XRef stream with invalid /W entries\n        doc.LoadFromDevice(device);\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::NoXRef);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    // CVE-2017-8787: heap based overflow caused by unchecked /W entry values /W [ 1 -4 2 ]\n    // see https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=861738 for value of /W array\n    try\n    {\n        ostringstream oss;\n        size_t offsetStream;\n        size_t offsetEndstream;\n\n        // XRef stream\n        size_t lengthXRefObject = 58;\n        size_t offsetXRefObject = 10;\n        oss << \"%PDF-1.4\\r\\n\";\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [2 2] \";\n        oss << \"/Size 5 \";\n        oss << \"/W [ 1 -4 2 ] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"01 0E8A 00\\r\\n\";\n        oss << \"02 0002 00\\r\\n\";\n        oss << \"02 0002 01\\r\\n\";\n        oss << \"02 0002 02\\r\\n\";\n        oss << \"02 0002 03\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // check /Length entry in XRef stream above\n\n        // trailer\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%%EOF\";\n\n        auto inputStr = oss.str();\n        PdfXRefEntries offsets;\n        auto device = std::make_shared<SpanStreamDevice>(inputStr);\n        PdfMemDocument doc;\n        // Parse a doc using XRef stream with invalid /W entries\n        doc.LoadFromDevice(device);\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::NoXRef);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    // /W entry values /W [ 4095 1 1 ] for data in form 02 0002 00 (doesn't match size of entry)\n    try\n    {\n        ostringstream oss;\n        size_t offsetStream;\n        size_t offsetEndstream;\n\n        // XRef stream\n        size_t lengthXRefObject = 58;\n        size_t offsetXRefObject = 10;\n        oss << \"%PDF-1.4\\r\\n\";\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [2 2] \";\n        oss << \"/Size 5 \";\n        oss << \"/W [ 4095 1 1 ] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"01 0E8A 00\\r\\n\";\n        oss << \"02 0002 00\\r\\n\";\n        oss << \"02 0002 01\\r\\n\";\n        oss << \"02 0002 02\\r\\n\";\n        oss << \"02 0002 03\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE((offsetEndstream - offsetStream - strlen(\"\\r\\n\")) == lengthXRefObject); // check /Length entry in XRef stream above\n\n        // trailer\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%%EOF\";\n\n        auto inputStr = oss.str();\n        PdfXRefEntries offsets;\n        auto device = std::make_shared<SpanStreamDevice>(inputStr);\n        PdfMemDocument doc;\n        // Parse a doc using XRef stream with invalid /W entries\n        doc.LoadFromDevice(device);\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRefStream);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    // /W entry values /W [ 4 4 4 ] for data in form 02 0002 00 (doesn't match size of entry)\n    try\n    {\n        ostringstream oss;\n        size_t offsetStream;\n        size_t offsetEndstream;\n\n        // XRef stream\n        size_t lengthXRefObject = 58;\n        size_t offsetXRefObject = 10;\n        oss << \"%PDF-1.4\\r\\n\";\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [2 2] \";\n        oss << \"/Size 5 \";\n        oss << \"/W [ 4 4 4 ] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"01 0E8A 00\\r\\n\";\n        oss << \"02 0002 00\\r\\n\";\n        oss << \"02 0002 01\\r\\n\";\n        oss << \"02 0002 02\\r\\n\";\n        oss << \"02 0002 03\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // check /Length entry in XRef stream above\n\n        // trailer\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%%EOF\";\n\n        auto inputStr = oss.str();\n        PdfXRefEntries offsets;\n        auto device = std::make_shared<SpanStreamDevice>(inputStr);\n        PdfMemDocument doc;\n        // Parse a doc using XRef stream with invalid /W entries\n        doc.LoadFromDevice(device);\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRefType);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    // /W entry values /W [ 1 4 4 ] (size=9) for data 01 0E8A 0\\r\\n02 0002 00\\r\\n (size=8 bytes)\n    try\n    {\n        ostringstream oss;\n        size_t offsetStream;\n        size_t offsetEndstream;\n\n        // XRef stream\n        size_t lengthXRefObject = 22;\n        size_t offsetXRefObject = 10;\n        oss << \"%PDF-1.4\\r\\n\";\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [2 2] \";\n        oss << \"/Size 2 \";\n        oss << \"/W [ 1 4 4 ] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"01 0E8A 00\\r\\n\";\n        oss << \"02 0002 00\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // check /Length entry in XRef stream above\n\n        // trailer\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%%EOF\";\n\n        auto inputStr = oss.str();\n        PdfXRefEntries offsets;\n        auto device = std::make_shared<SpanStreamDevice>(inputStr);\n        PdfMemDocument doc;\n        // Parse a doc using XRef stream with invalid /W entries\n        doc.LoadFromDevice(device);\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::NoXRef);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    try\n    {\n        ostringstream oss;\n        size_t offsetStream;\n        size_t offsetEndstream;\n\n        size_t lengthXRefObject = 22;\n        size_t offsetXRefObject = 34;\n        oss << \"%PDF-1.4\\r\\n\";\n        oss << \"1 0 obj\\r\\n\";\n        oss << \"<< >>\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        oss << \"2 0 obj\\r\\n\";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [1 2] \";\n        oss << \"/Root 1 0 R \";\n        oss << \"/Size 3 \";\n        oss << \"/W [1 2 1] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"01 000A 00\\r\\n\";\n        oss << \"01 001A 00\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // hard-coded in /Length entry in XRef stream above\n\n        // trailer\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%%EOF\";\n\n        auto inputStr = oss.str();\n        PdfXRefEntries offsets;\n        auto device = std::make_shared<SpanStreamDevice>(inputStr);\n        PdfMemDocument doc;\n        doc.LoadFromDevice(device);\n    }\n    catch (PdfError&)\n    {\n        FAIL(\"Unexpected PdfError\");\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    // XRef stream with 5 entries but /Size 2 specified\n    try\n    {\n        ostringstream oss;\n        size_t offsetStream;\n        size_t offsetEndstream;\n\n        size_t lengthXRefObject = 58;\n        size_t offsetXRefObject = 10;\n        oss << \"%PDF-1.4\\r\\n\";\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [2 2] \";\n        oss << \"/Size 10 \";\n        oss << \"/W [1 2 1] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"01 0E8A 00\\r\\n\";\n        oss << \"01 0002 00\\r\\n\";\n        oss << \"01 0002 01\\r\\n\";\n        oss << \"01 0002 02\\r\\n\";\n        oss << \"01 0002 03\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // hard-coded in /Length entry in XRef stream above\n\n        // trailer\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%%EOF\";\n\n        auto inputStr = oss.str();\n        PdfXRefEntries offsets;\n        auto device = std::make_shared<SpanStreamDevice>(inputStr);\n        PdfMemDocument doc;\n        doc.LoadFromDevice(device);\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        (void)error;\n        // FIXME We should throw on exact error\n        //REQUIRE(error.GetError() == PdfErrorCode::NoXRef);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    // XRef stream with 5 entries but /Size 10 specified\n    try\n    {\n        ostringstream oss;\n        size_t offsetStream;\n        size_t offsetEndstream;\n\n        size_t lengthXRefObject = 58;\n        size_t offsetXRefObject = 10;\n        oss << \"%PDF-1.4\\r\\n\";\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [2 2] \";\n        oss << \"/Size 10 \";\n        oss << \"/W [1 2 1] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"01 0E8A 00\\r\\n\";\n        oss << \"01 0002 00\\r\\n\";\n        oss << \"01 0002 01\\r\\n\";\n        oss << \"01 0002 02\\r\\n\";\n        oss << \"01 0002 03\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // hard-coded in /Length entry in XRef stream above\n\n        // trailer\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%%EOF\";\n\n        auto inputStr = oss.str();\n        PdfXRefEntries offsets;\n        auto device = std::make_shared<SpanStreamDevice>(inputStr);\n        PdfMemDocument doc;\n        doc.LoadFromDevice(device);\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        (void)error;\n        // FIXME We should throw on exact error\n        //REQUIRE(error.GetError() == PdfErrorCode::NoXRef);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    // XRef stream with /Index [0 0] array\n    try\n    {\n        ostringstream oss;\n        size_t offsetStream;\n        size_t offsetEndstream;\n\n        size_t lengthXRefObject = 58;\n        size_t offsetXRefObject = 10;\n        oss << \"%PDF-1.4\\r\\n\";\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [0 0] \";\n        oss << \"/Size 5 \";\n        oss << \"/W [1 2 1] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"01 0E8A 00\\r\\n\";\n        oss << \"02 0002 00\\r\\n\";\n        oss << \"02 0002 01\\r\\n\";\n        oss << \"02 0002 02\\r\\n\";\n        oss << \"02 0002 03\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // hard-coded in /Length entry in XRef stream above\n\n        // trailer\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%%EOF\";\n\n        auto inputStr = oss.str();\n        PdfXRefEntries offsets;\n        auto device = std::make_shared<SpanStreamDevice>(inputStr);\n        PdfMemDocument doc;\n        doc.LoadFromDevice(device);\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        (void)error;\n        // FIXME We should throw on exact error\n        //REQUIRE(error.GetError() == PdfErrorCode::NoXRef);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    // XRef stream with /Index [-1 -1] array\n    try\n    {\n        ostringstream oss;\n        size_t offsetStream;\n        size_t offsetEndstream;\n\n        size_t lengthXRefObject = 58;\n        size_t offsetXRefObject = 10;\n        oss << \"%PDF-1.4\\r\\n\";\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [-1 -1] \";\n        oss << \"/Size 5 \";\n        oss << \"/W [1 2 1] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"01 0E8A 00\\r\\n\";\n        oss << \"02 0002 00\\r\\n\";\n        oss << \"02 0002 01\\r\\n\";\n        oss << \"02 0002 02\\r\\n\";\n        oss << \"02 0002 03\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // hard-coded in /Length entry in XRef stream above\n\n        // trailer\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%%EOF\";\n\n        auto inputStr = oss.str();\n        PdfXRefEntries offsets;\n        auto device = std::make_shared<SpanStreamDevice>(inputStr);\n        PdfMemDocument doc;\n        doc.LoadFromDevice(device);\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        (void)error;\n        // FIXME We should throw on exact error\n        //REQUIRE(error.GetError() == PdfErrorCode::NoXRef);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    // XRef stream with /Index array with no entries\n    try\n    {\n        ostringstream oss;\n        size_t offsetStream;\n        size_t offsetEndstream;\n\n        size_t lengthXRefObject = 58;\n        size_t offsetXRefObject = 10;\n        oss << \"%PDF-1.4\\r\\n\";\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [ ] \";\n        oss << \"/Size 5 \";\n        oss << \"/W [1 2 1] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"01 0E8A 00\\r\\n\";\n        oss << \"02 0002 00\\r\\n\";\n        oss << \"02 0002 01\\r\\n\";\n        oss << \"02 0002 02\\r\\n\";\n        oss << \"02 0002 03\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // hard-coded in /Length entry in XRef stream above\n\n        // trailer\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%%EOF\";\n\n        auto inputStr = oss.str();\n        PdfXRefEntries offsets;\n        auto device = std::make_shared<SpanStreamDevice>(inputStr);\n        PdfMemDocument doc;\n        doc.LoadFromDevice(device);\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        (void)error;\n        // FIXME We should throw on exact error\n        //REQUIRE(error.GetError() == PdfErrorCode::NoXRef);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    // XRef stream with /Index array with 3 entries\n    try\n    {\n        ostringstream oss;\n        size_t offsetStream;\n        size_t offsetEndstream;\n\n        size_t lengthXRefObject = 58;\n        size_t offsetXRefObject = 10;\n        oss << \"%PDF-1.4\\r\\n\";\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [2 2 2] \";\n        oss << \"/Size 5 \";\n        oss << \"/W [1 2 1] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"01 0E8A 00\\r\\n\";\n        oss << \"02 0002 00\\r\\n\";\n        oss << \"02 0002 01\\r\\n\";\n        oss << \"02 0002 02\\r\\n\";\n        oss << \"02 0002 03\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // hard-coded in /Length entry in XRef stream above\n\n        // trailer\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%%EOF\";\n\n        auto inputStr = oss.str();\n        PdfXRefEntries offsets;\n        auto device = std::make_shared<SpanStreamDevice>(inputStr);\n        PdfMemDocument doc;\n        doc.LoadFromDevice(device);\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::NoXRef);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    // XRef stream with /Index array with 22 entries\n    try\n    {\n        ostringstream oss;\n        size_t offsetStream;\n        size_t offsetEndstream;\n\n        size_t lengthXRefObject = 58;\n        size_t offsetXRefObject = 10;\n        oss << \"%PDF-1.4\\r\\n\";\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22] \";\n        oss << \"/Size 5 \";\n        oss << \"/W [1 2 1] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"00 0000 00\\r\\n\";\n        oss << \"00 0000 00\\r\\n\";\n        oss << \"00 0000 00\\r\\n\";\n        oss << \"00 0000 00\\r\\n\";\n        oss << \"00 0000 00\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // hard-coded in /Length entry in XRef stream above\n\n        // trailer\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%%EOF\";\n\n        auto inputStr = oss.str();\n        PdfXRefEntries offsets;\n        auto device = std::make_shared<SpanStreamDevice>(inputStr);\n        PdfMemDocument doc;\n        doc.LoadFromDevice(device);\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::NoXRef);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n}\n\nTEST_CASE(\"testReadObjects\")\n{\n    // CVE-2017-8378 - m_offsets out-of-bounds access when referenced encryption dictionary object doesn't exist\n    try\n    {\n        ostringstream oss;\n        oss << \"%PDF-1.0\\r\\n\";\n        oss << \"xref\\r\\n0 3\\r\\n\";\n        oss << generateXRefEntries(3);\n        oss << \"trailer << /Root 1 0 R /Size 3 /Encrypt 3 0 R >>\\r\\n\";\n        oss << \"startxref 0\\r\\n\";\n        oss << \"%%EOF\";\n        PdfIndirectObjectList objects;\n        auto docbuff = oss.str();\n        PdfParserTest parser(objects, docbuff);\n        parser.ReadDocumentStructure();\n        parser.ReadObjects();\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidEncryptionDict);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n}\n\nTEST_CASE(\"testIsPdfFile\")\n{\n    try\n    {\n        string strInput = \"%PDF-1.0\";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        REQUIRE(parser.IsPdfFile());\n    }\n    catch (PdfError&)\n    {\n        FAIL(\"Unexpected PdfError\");\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    try\n    {\n        string strInput = \"%PDF-1.1\";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        REQUIRE(parser.IsPdfFile());\n    }\n    catch (PdfError&)\n    {\n        FAIL(\"Unexpected PdfError\");\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    try\n    {\n        string strInput = \"%PDF-1.7\";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        REQUIRE(parser.IsPdfFile());\n    }\n    catch (PdfError&)\n    {\n        FAIL(\"Unexpected PdfError\");\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    try\n    {\n        string strInput = \"%PDF-1.9\";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        REQUIRE(!parser.IsPdfFile());\n    }\n    catch (PdfError&)\n    {\n        FAIL(\"Unexpected PdfError\");\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    try\n    {\n        string strInput = \"%PDF-2.0\";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        REQUIRE(parser.IsPdfFile());\n    }\n    catch (PdfError&)\n    {\n        FAIL(\"Unexpected PdfError\");\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    try\n    {\n        string strInput = \"%!PS-Adobe-2.0\";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        REQUIRE(!parser.IsPdfFile());\n    }\n    catch (PdfError&)\n    {\n        FAIL(\"Unexpected PdfError\");\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    try\n    {\n        string strInput = \"GIF89a\";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        REQUIRE(!parser.IsPdfFile());\n    }\n    catch (PdfError&)\n    {\n        FAIL(\"Unexpected PdfError\");\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n}\n\nTEST_CASE(\"testSaveIncrementalRoundTrip\")\n{\n    ostringstream oss;\n    oss << \"%PDF-1.1\\n\";\n    unsigned currObj = 1;\n    streamoff objPos[20];\n\n    // Pages\n\n    unsigned pagesObj = currObj;\n    objPos[currObj] = oss.tellp();\n    oss << currObj++ << \" 0 obj\\n\";\n    oss << \"<</Type /Pages /Count 0 /Kids []>>\\n\";\n    oss << \"endobj\\n\";\n\n    // Root catalog\n\n    unsigned rootObj = currObj;\n    objPos[currObj] = oss.tellp();\n    oss << currObj++ << \" 0 obj\\n\";\n    oss << \"<</Type /Catalog /Pages \" << pagesObj << \" 0 R>>\\n\";\n    oss << \"endobj\\n\";\n\n    // ID\n    unsigned idObj = currObj;\n    objPos[currObj] = oss.tellp();\n    oss << currObj++ << \" 0 obj\\n\";\n    oss << \"[<F1E375363A6314E3766EDF396D614748> <F1E375363A6314E3766EDF396D614748>]\\n\";\n    oss << \"endobj\\n\";\n\n    streamoff xrefPos = oss.tellp();\n    oss << \"xref\\n\";\n    oss << \"0 \" << currObj << \"\\n\";\n    oss << \"0000000000 65535 f \\n\";\n    for (unsigned i = 1; i < currObj; i++)\n        oss << utls::Format(\"{:010d} 00000 n \\n\", objPos[i]);\n\n    oss << \"trailer <<\\n\"\n        << \"  /Size \" << currObj << \"\\n\"\n        << \"  /Root \" << rootObj << \" 0 R\\n\"\n        << \"  /ID \" << idObj << \" 0 R\\n\" // indirect ID\n        << \">>\\n\"\n        << \"startxref\\n\"\n        << xrefPos << \"\\n\"\n        << \"%%EOF\\n\";\n\n    string docBuff = oss.str();\n    try\n    {\n        PdfMemDocument doc;\n        // load for update\n        doc.LoadFromBuffer(docBuff);\n\n        StringStreamDevice outDev(docBuff);\n\n        doc.SaveUpdate(outDev);\n        doc.LoadFromBuffer(docBuff);\n    }\n    catch (PdfError&)\n    {\n        FAIL(\"Unexpected PdfError\");\n    }\n}\n\n// CVE-2018-8002, CVE-2021-30470\nTEST_CASE(\"testNestedArrays\")\n{\n    // test valid stream\n    // generate an XRef stream with no deeply nested arrays\n    ostringstream oss;\n    size_t offsetStream;\n    size_t offsetEndstream;\n    size_t offsetXRefObject;\n    string buffer;\n\n    // XRef stream with 5 entries\n    constexpr size_t lengthXRefObject = 58;\n\n    offsetXRefObject = oss.str().length();\n    oss << \"2 0 obj \";\n    oss << \"<< /Type /XRef \";\n    oss << \"/Length \" << lengthXRefObject << \" \";\n    oss << \"/Index [2 2] \";\n    oss << \"/Size 5 \";\n    oss << \"/W [1 2 1] \";\n    oss << \"/Filter /ASCIIHexDecode \";\n    oss << \">>\\r\\n\";\n    oss << \"stream\\r\\n\";\n    offsetStream = oss.str().length();\n    oss << \"01 0E8A 00\\r\\n\";\n    oss << \"02 0002 00\\r\\n\";\n    oss << \"02 0002 01\\r\\n\";\n    oss << \"02 0002 02\\r\\n\";\n    oss << \"02 0002 03\\r\\n\";\n    offsetEndstream = oss.str().length();\n    oss << \"endstream\\r\\n\";\n    oss << \"endobj\\r\\n\";\n    REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // hard-coded in /Length entry in XRef stream above\n\n    // trailer\n    oss << \"trailer << /Root 1 0 R /Size 3 >>\\r\\n\";\n    oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n    oss << \"%EOF\";\n\n    buffer = oss.str();\n\n    {\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, buffer);\n        parser.ReadXRefStreamContents(offsetXRefObject, false);\n        REQUIRE(true);\n    }\n\n    // CVE-2021-30470 - lots of [[[[[]]]]] brackets represent nested arrays which caused stack overflow\n    try\n    {\n        // generate an XRef stream with deeply nested arrays\n        oss.str(\"\");\n        const size_t maxNesting = getStackOverflowDepth(); // big enough to cause stack overflow\n        // XRef stream with 5 entries\n        offsetXRefObject = oss.str().length();\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [2 2] \";\n        oss << \"/Size 5 \";\n        oss << \"/W [1 2 1] \";\n        \n        // output [[[[[[[[[[[0]]]]]]]]]]]\n        for (size_t i = 0; i < maxNesting; i++)\n        {\n            oss << \"[\";\n        }\n        oss << \"0\";\n        for (size_t i = 0; i < maxNesting; i++)\n        {\n            oss << \"]\";\n        }\n        oss << \" \";\n\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"01 0E8A 00\\r\\n\";\n        oss << \"02 0002 00\\r\\n\";\n        oss << \"02 0002 01\\r\\n\";\n        oss << \"02 0002 02\\r\\n\";\n        oss << \"02 0002 03\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // hard-coded in /Length entry in XRef stream above\n\n        // trailer\n        oss << \"trailer << /Root 1 0 R /Size 3 >>\\r\\n\";\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%EOF\";\n\n        buffer = oss.str();\n\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, buffer);\n        parser.ReadXRefStreamContents(offsetXRefObject, false);\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        // this must match the error value thrown by PdfRecursionGuard\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n    }\n}\n\n// CVE-2018-8002, CVE-2021-30470\nTEST_CASE(\"testNestedDictionaries\")\n{\n    // test valid stream\n    // generate an XRef stream with no deeply nested dictionaries\n    ostringstream oss;\n    size_t offsetStream;\n    size_t offsetEndstream;\n    size_t offsetXRefObject;\n    string buffer;\n\n    // XRef stream with 5 entries\n    constexpr size_t lengthXRefObject = 58;\n\n    offsetXRefObject = oss.str().length();\n    oss << \"2 0 obj \";\n    oss << \"<< /Type /XRef \";\n    oss << \"/Length \" << lengthXRefObject << \" \";\n    oss << \"/Index [2 2] \";\n    oss << \"/Size 5 \";\n    oss << \"/W [1 2 1] \";\n    oss << \"/Filter /ASCIIHexDecode \";\n    oss << \">>\\r\\n\";\n    oss << \"stream\\r\\n\";\n    offsetStream = oss.str().length();\n    oss << \"01 0E8A 00\\r\\n\";\n    oss << \"02 0002 00\\r\\n\";\n    oss << \"02 0002 01\\r\\n\";\n    oss << \"02 0002 02\\r\\n\";\n    oss << \"02 0002 03\\r\\n\";\n    offsetEndstream = oss.str().length();\n    oss << \"endstream\\r\\n\";\n    oss << \"endobj\\r\\n\";\n    REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // hard-coded in /Length entry in XRef stream above\n\n    // trailer\n    oss << \"trailer << /Root 1 0 R /Size 3 >>\\r\\n\";\n    oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n    oss << \"%EOF\";\n\n    buffer = oss.str();\n\n    {\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, buffer);\n        parser.ReadXRefStreamContents(offsetXRefObject, false);\n        REQUIRE(true);\n    }\n\n    // CVE-2021-30470 - lots of <<<>>> brackets represent nested dictionaries which caused stack overflow\n    try\n    {\n        // generate an XRef stream with deeply nested dictionaries\n        oss.str(\"\");\n\n        const size_t maxNesting = getStackOverflowDepth(); // big enough to cause stack overflow \n        // XRef stream with 5 entries\n        offsetXRefObject = oss.str().length();\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [2 2] \";\n        oss << \"/Size 5 \";\n        oss << \"/W [1 2 1] \";\n\n        // output << << << /Test 0 >> >> >>\n        for (size_t i = 0; i < maxNesting; i++)\n        {\n            oss << \"<< \";\n        }\n        oss << \" /Test 0\";\n        for (size_t i = 0; i < maxNesting; i++)\n        {\n            oss << \" >>\";\n        }\n        oss << \" \";\n\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"01 0E8A 00\\r\\n\";\n        oss << \"02 0002 00\\r\\n\";\n        oss << \"02 0002 01\\r\\n\";\n        oss << \"02 0002 02\\r\\n\";\n        oss << \"02 0002 03\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // hard-coded in /Length entry in XRef stream above\n\n        // trailer\n        oss << \"trailer << /Root 1 0 R /Size 3 >>\\r\\n\";\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%EOF\";\n\n        buffer = oss.str();\n\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, buffer);\n        parser.ReadXRefStreamContents(offsetXRefObject, false);\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        // this must match the error value thrown by PdfRecursionGuard\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n    }\n}\n\n// CVE-2021-30471\nTEST_CASE(\"testNestedNameTree\")\n{\n    // test for valid but deeply nested name tree\n    // maxDepth must be less than GetMaxObjectCount otherwise PdfParser::ResizeOffsets\n    // throws an error when reading the xref offsets table, and no outlines are read\n    ostringstream oss;\n    const size_t maxDepth = getStackOverflowDepth() - 6 - 1;\n    const size_t numObjects = maxDepth + 6;\n    vector<size_t> offsets(numObjects);\n    size_t xrefOffset = 0;\n\n    offsets[0] = 0;\n    oss << \"%PDF-1.0\\r\\n\";\n\n    offsets[1] = oss.tellp();\n    oss << \"1 0 obj<</Type/Catalog /Pages 2 0 R /Names 4 0 R>>endobj \";\n\n    offsets[2] = oss.tellp();\n    oss << \"2 0 obj<</Type/Pages/Kids[3 0 R]/Count 1>>endobj \";\n\n    offsets[3] = oss.tellp();\n    oss << \"3 0 obj<</Type/Page/MediaBox[0 0 3 3]>>endobj \";\n\n    // the name dictionary\n    offsets[4] = oss.tellp();\n    oss << \"4 0 obj<</Dests 5 0 R>>endobj \";\n\n    // root of /Dests name tree\n    offsets[5] = oss.tellp();\n    oss << \"5 0 obj<</Kids [6 0 R]>>endobj \";\n\n    // create name tree nested to maxDepth where each intermediate node has one child\n    // except single leaf node at maxDepth\n    for (size_t objNo = 6; objNo < numObjects; objNo++)\n    {\n        offsets[objNo] = oss.tellp();\n\n        if (objNo < numObjects - 1)\n            oss << objNo << \" 0 obj<</Kids [\" << objNo + 1 << \" 0 R] /Limits [(A) (Z)]>>endobj \";\n        else\n            oss << objNo << \" 0 obj<</Limits [(A) (Z)] /Names [ (A) (Avalue) (Z) (Zvalue) ] >>endobj \";\n    }\n\n    // output xref table\n    oss << \"\\r\\n\";\n    xrefOffset = oss.tellp();\n    oss << \"xref\\r\\n\";\n    oss << \"0 \" << numObjects << \"\\r\\n\";\n\n    oss << \"0000000000 65535 f\\r\\n\";\n\n    for (size_t objNo = 1; objNo < offsets.size(); objNo++)\n    {\n        // write xref entries like\n        // \"0000000010 00000 n\\r\\n\"\n        char refEntry[21];\n        snprintf(refEntry, 21, \"%010zu 00000 n\\r\\n\", offsets[objNo]);\n\n        oss << refEntry;\n    }\n\n    oss << \"trailer<</Size \" << numObjects << \"/Root 1 0 R>>\\r\\n\";\n    oss << \"startxref\\r\\n\";\n    oss << xrefOffset << \"\\r\\n\";\n    oss << \"%%EOF\";\n\n    auto buffer = oss.str();\n\n    try\n    {\n        PdfMemDocument doc;\n        doc.LoadFromBuffer(buffer);\n\n        auto names = doc.GetNames();\n        if (names != nullptr)\n        {\n            PdfDictionary dict;\n            names->ToDictionary(\"Dests\", dict);\n        }\n\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        // this must match the error value thrown by PdfRecursionGuard\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n    }\n}\n\n// CVE-2021-30471\nTEST_CASE(\"testLoopingNameTree\")\n{\n    string strNoLoop =\n        \"%PDF-1.0\\r\\n\"\n        \"1 0 obj<</Type/Catalog/Pages 2 0 R /Names 4 0 R>>endobj 2 0 obj<</Type/Pages/Kids[3 0 R]/Count 1>>endobj 3 0 obj<</Type/Page/MediaBox[0 0 3 3]>>endobj 4 0 obj<</Dests 2 0 R>>endobj\\r\\n\"\n        \"xref\\r\\n\"\n        \"0 5\\r\\n\"\n        \"0000000000 65535 f\\r\\n\"\n        \"0000000010 00000 n\\r\\n\"\n        \"0000000066 00000 n\\r\\n\"\n        \"0000000115 00000 n\\r\\n\"\n        \"0000000161 00000 n\\r\\n\"\n        \"trailer<</Size 4/Root 1 0 R>>\\r\\n\"\n        \"startxref\\r\\n\"\n        \"192\\r\\n\"\n        \"%%EOF\";\n\n    {\n        PdfMemDocument doc;\n        doc.LoadFromBuffer(strNoLoop);\n\n        auto names = doc.GetNames();\n        if (names != nullptr)\n        {\n            PdfDictionary dict;\n            names->ToDictionary(\"Dests\", dict);\n        }\n    }\n\n    // CVE-2021-30471 /Dests points at pages tree root which has a /Kids entry loooping back to pages tree root\n    string strSelfLoop =\n        \"%PDF-1.0\\r\\n\"\n        \"1 0 obj<</Type/Catalog/Pages 2 0 R /Names 4 0 R>>endobj 2 0 obj<</Type/Pages/Kids[2 0 R]/Count 1>>endobj 3 0 obj<</Type/Page/MediaBox[0 0 3 3]>>endobj 4 0 obj<</Dests 2 0 R>>endobj\\r\\n\"\n        \"xref\\r\\n\"\n        \"0 5\\r\\n\"\n        \"0000000000 65535 f\\r\\n\"\n        \"0000000010 00000 n\\r\\n\"\n        \"0000000066 00000 n\\r\\n\"\n        \"0000000115 00000 n\\r\\n\"\n        \"0000000161 00000 n\\r\\n\"\n        \"trailer<</Size 4/Root 1 0 R>>\\r\\n\"\n        \"startxref\\r\\n\"\n        \"192\\r\\n\"\n        \"%%EOF\";\n\n    try\n    {\n        PdfMemDocument doc;\n        doc.LoadFromBuffer(strSelfLoop);\n\n        auto names = doc.GetNames();\n        if (names != nullptr)\n        {\n            PdfDictionary dict;\n            names->ToDictionary(\"Dests\", dict);\n        }\n\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        // this must match the error value thrown by PdfRecursionGuard\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n    }\n\n    // CVE-2021-30471 /Dests points at pages tree which has a /Kids entry loooping back to ancestor (document root)\n    string strAncestorLoop =\n        \"%PDF-1.0\\r\\n\"\n        \"1 0 obj<</Type/Catalog/Pages 2 0 R /Names 4 0 R>>endobj 2 0 obj<</Type/Pages/Kids[1 0 R]/Count 1>>endobj 3 0 obj<</Type/Page/MediaBox[0 0 3 3]>>endobj 4 0 obj<</Dests 2 0 R>>endobj\\r\\n\"\n        \"xref\\r\\n\"\n        \"0 5\\r\\n\"\n        \"0000000000 65535 f\\r\\n\"\n        \"0000000010 00000 n\\r\\n\"\n        \"0000000066 00000 n\\r\\n\"\n        \"0000000115 00000 n\\r\\n\"\n        \"0000000161 00000 n\\r\\n\"\n        \"trailer<</Size 4/Root 1 0 R>>\\r\\n\"\n        \"startxref\\r\\n\"\n        \"192\\r\\n\"\n        \"%%EOF\";\n\n    try\n    {\n        PdfMemDocument doc;\n        doc.LoadFromBuffer(strAncestorLoop);\n\n        auto names = doc.GetNames();\n        if (names != nullptr)\n        {\n            PdfDictionary dict;\n            names->ToDictionary(\"Dests\", dict);\n        }\n\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidDataType);\n    }\n}\n\n// CVE-2021-30471\nTEST_CASE(\"testNestedPageTree\")\n{\n    // test for valid but deeply nested page tree\n    // maxDepth must be less than GetMaxObjectCount otherwise PdfParser::ResizeOffsets\n    // throws an error when reading the xref offsets table, and no outlines are read\n    ostringstream oss;\n    const size_t maxDepth = getStackOverflowDepth() - 4 - 1;\n    const size_t numObjects = maxDepth + 4;\n    vector<size_t> offsets(numObjects);\n    size_t xrefOffset = 0;\n\n    offsets[0] = 0;\n    oss << \"%PDF-1.0\\r\\n\";\n\n    offsets[1] = oss.tellp();\n    oss << \"1 0 obj<</Type/Catalog /AcroForm 2 0 R /Pages 3 0 R>>endobj \";\n\n    offsets[2] = oss.tellp();\n    oss << \"2 0 obj<</Type/AcroForm >>endobj \";\n\n    offsets[3] = oss.tellp();\n    oss << \"3 0 obj<</Type/Pages /Kids [4 0 R] /Count 1 >>endobj \";\n\n    // create pages tree nested to maxDepth where each node has one child\n    // except single leaf node at maxDepth\n    for (size_t objNo = 4; objNo < numObjects; objNo++)\n    {\n        offsets[objNo] = oss.tellp();\n\n        if (objNo < numObjects - 1)\n            oss << objNo << \" 0 obj<</Type/Pages /Kids [\" << objNo + 1 << \" 0 R] /Parent \" << objNo - 1 << \" 0 R /Count 1 >>endobj \";\n        else\n            oss << objNo << \" 0 obj<</Type/Page  /Parent \" << objNo - 1 << \" 0 R >>endobj \";\n    }\n\n    // output xref table\n    oss << \"\\r\\n\";\n    xrefOffset = oss.tellp();\n    oss << \"xref\\r\\n\";\n    oss << \"0 \" << numObjects << \"\\r\\n\";\n\n    oss << \"0000000000 65535 f\\r\\n\";\n\n    for (size_t objNo = 1; objNo < offsets.size(); objNo++)\n    {\n        // write xref entries like\n        // \"0000000010 00000 n\\r\\n\"\n        char refEntry[21];\n        snprintf(refEntry, 21, \"%010zu 00000 n\\r\\n\", offsets[objNo]);\n\n        oss << refEntry;\n    }\n\n    oss << \"trailer<</Size \" << numObjects << \"/Root 1 0 R>>\\r\\n\";\n    oss << \"startxref\\r\\n\";\n    oss << xrefOffset << \"\\r\\n\";\n    oss << \"%%EOF\";\n\n    auto buffer = oss.str();\n    try\n    {\n        PdfMemDocument doc;\n        doc.LoadFromBuffer(buffer);\n\n        auto& pages = doc.GetPages();\n        for (unsigned pageNo = 0; pageNo < pages.GetCount(); pageNo++)\n            (void)pages.GetPageAt(pageNo);\n\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n    }\n}\n\n// CVE-2021-30471\nTEST_CASE(\"testLoopingPageTree\")\n{\n    // test PDF without nested kids\n    string strNoLoop =\n        \"%PDF-1.0\\r\\n\"\n        \"1 0 obj<</Type/Catalog/Pages 2 0 R>>endobj 2 0 obj<</Type/Pages/Kids[3 0 R]/Count 1>>endobj 3 0 obj<</Type/Page/MediaBox[0 0 3 3]>>endobj\\r\\n\"\n        \"xref\\r\\n\"\n        \"0 4\\r\\n\"\n        \"0000000000 65535 f\\r\\n\"\n        \"0000000010 00000 n\\r\\n\"\n        \"0000000053 00000 n\\r\\n\"\n        \"0000000102 00000 n\\r\\n\"\n        \"trailer<</Size 4/Root 1 0 R>>\\r\\n\"\n        \"startxref\\r\\n\"\n        \"149\\r\\n\"\n        \"%%EOF\";\n\n    {\n        PdfMemDocument doc;\n        doc.LoadFromBuffer(strNoLoop);\n        auto& pages = doc.GetPages();\n        for (unsigned pageNo = 0; pageNo < doc.GetPages().GetCount(); pageNo++)\n            (void)pages.GetPageAt(pageNo);\n        REQUIRE(true);\n    }\n\n    // CVE-2021-30471 test for pages tree /Kids array that refer back to pages tree root\n    string strSelfLoop =\n        \"%PDF-1.0\\r\\n\"\n        \"1 0 obj<</Type/Catalog/Pages 2 0 R>>endobj 2 0 obj<</Type/Pages/Kids[2 0 R]/Count 1>>endobj 3 0 obj<</Type/Page/MediaBox[0 0 3 3]>>endobj\\r\\n\"\n        \"xref\\r\\n\"\n        \"0 4\\r\\n\"\n        \"0000000000 65535 f\\r\\n\"\n        \"0000000010 00000 n\\r\\n\"\n        \"0000000053 00000 n\\r\\n\"\n        \"0000000102 00000 n\\r\\n\"\n        \"trailer<</Size 4/Root 1 0 R>>\\r\\n\"\n        \"startxref\\r\\n\"\n        \"149\\r\\n\"\n        \"%%EOF\";\n\n    try\n    {\n        PdfMemDocument doc;\n        doc.LoadFromBuffer(strSelfLoop);\n        auto& pages = doc.GetPages();\n        for (unsigned pageNo = 0; pageNo < pages.GetCount(); pageNo++)\n            (void)pages.GetPageAt(pageNo);\n\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::PageNotFound);\n    }\n\n    // CVE-2021-30471 test for pages tree /Kids array that refer back to an ancestor (document root object)\n    string strAncestorLoop =\n        \"%PDF-1.0\\r\\n\"\n        \"1 0 obj<</Type/Catalog/Pages 2 0 R>>endobj 2 0 obj<</Type/Pages/Kids[1 0 R]/Count 1>>endobj 3 0 obj<</Type/Page/MediaBox[0 0 3 3]>>endobj\\r\\n\"\n        \"xref\\r\\n\"\n        \"0 4\\r\\n\"\n        \"0000000000 65535 f\\r\\n\"\n        \"0000000010 00000 n\\r\\n\"\n        \"0000000053 00000 n\\r\\n\"\n        \"0000000102 00000 n\\r\\n\"\n        \"trailer<</Size 4/Root 1 0 R>>\\r\\n\"\n        \"startxref\\r\\n\"\n        \"149\\r\\n\"\n        \"%%EOF\";\n\n    try\n    {\n        PdfMemDocument doc;\n        doc.LoadFromBuffer(strAncestorLoop);\n        auto& pages = doc.GetPages();\n        pages.GetPageAt(0);\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::PageNotFound);\n    }\n}\n\n// CVE-2020-18971\nTEST_CASE(\"testNestedOutlines\")\n{\n    // test for valid but deeply nested outlines\n    // maxDepth must be less than GetMaxObjectCount otherwise PdfParser::ResizeOffsets\n    // throws an error when reading the xref offsets table, and no outlines are read\n    ostringstream oss;\n    const size_t maxDepth = getStackOverflowDepth() - 4 - 1;\n    const size_t numObjects = maxDepth + 4;\n    vector<size_t> offsets(numObjects);\n    size_t xrefOffset = 0;\n\n    offsets[0] = 0;\n    oss << \"%PDF-1.0\\r\\n\";\n\n    offsets[1] = oss.tellp();\n    oss << \"1 0 obj<</Type/Catalog /AcroForm 2 0 R /Outlines 3 0 R>>endobj \";\n\n    offsets[2] = oss.tellp();\n    oss << \"2 0 obj<</Type/AcroForm >>endobj \";\n\n    offsets[3] = oss.tellp();\n    oss << \"3 0 obj<</Type/Outlines /First 4 0 R /Count \" << maxDepth << \" /Last 5 0 R >>endobj \";\n\n    // create outlines tree nested to maxDepth where each node has one child\n    // except single leaf node at maxDepth\n    for (size_t objNo = 4; objNo < numObjects; objNo++)\n    {\n        offsets[objNo] = oss.tellp();\n\n        if (objNo < numObjects - 1)\n            oss << objNo << \" 0 obj<</Title (Outline Item) /First \" << objNo + 1 << \" 0 R /Last \" << objNo + 1 << \" 0 R>>endobj \";\n        else\n            oss << objNo << \" 0 obj<</Title (Outline Item)>>endobj \";\n    }\n\n    // output xref table\n    oss << \"\\r\\n\";\n    xrefOffset = oss.tellp();\n    oss << \"xref\\r\\n\";\n    oss << \"0 \" << numObjects << \"\\r\\n\";\n\n    oss << \"0000000000 65535 f\\r\\n\";\n\n    for (size_t objNo = 1; objNo < offsets.size(); objNo++)\n    {\n        // write xref entries like\n        // \"0000000010 00000 n\\r\\n\"\n        char szXrefEntry[21];\n        snprintf(szXrefEntry, 21, \"%010zu 00000 n\\r\\n\", offsets[objNo]);\n\n        oss << szXrefEntry;\n    }\n\n    oss << \"trailer<</Size \" << numObjects << \"/Root 1 0 R>>\\r\\n\";\n    oss << \"startxref\\r\\n\";\n    oss << xrefOffset << \"\\r\\n\";\n    oss << \"%%EOF\";\n\n    auto buffer = oss.str();\n    try\n    {\n        PdfMemDocument doc;\n        doc.LoadFromBuffer(buffer);\n\n        // load should succeed, then GetOutlines goes recursive due to /Outlines deep nesting\n        (void)doc.GetOutlines();\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n    }\n}\n\n// CVE-2020-18971\nTEST_CASE(\"testLoopingOutlines\")\n{\n    // CVE-2020-18971 - PdfOutlineItem /Next refers a preceding sibling\n    string strNextLoop =\n        \"%PDF-1.0\\r\\n\"\n        \"1 0 obj<</Type/Catalog /AcroForm 2 0 R /Outlines 3 0 R>>endobj \"\n        \"2 0 obj<</Type/AcroForm >>endobj \"\n        \"3 0 obj<</Type/Outlines /First 4 0 R /Count 2 /Last 5 0 R >>endobj \"\n        \"4 0 obj<</Title (Outline Item 1) /Next 5 0 R>>endobj \"\n        \"5 0 obj<</Title (Outline Item 2) /Next 4 0 R>>endobj \" // /Next loops back to previous outline item\n        \"\\r\\n\"\n        \"xref\\r\\n\"\n        \"0 6\\r\\n\"\n        \"0000000000 65535 f\\r\\n\"\n        \"0000000010 00000 n\\r\\n\"\n        \"0000000073 00000 n\\r\\n\"\n        \"0000000106 00000 n\\r\\n\"\n        \"0000000173 00000 n\\r\\n\"\n        \"0000000226 00000 n\\r\\n\"\n        \"trailer<</Size 6/Root 1 0 R>>\\r\\n\"\n        \"startxref\\r\\n\"\n        \"281\\r\\n\"\n        \"%%EOF\";\n\n    try\n    {\n        PdfMemDocument doc;\n        doc.LoadFromBuffer(strNextLoop);\n\n        // load should succeed, then GetOutlines goes recursive due to /Outlines loop\n        (void)doc.GetOutlines();\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n    }\n\n    // https://sourceforge.net/p/podofo/tickets/25/\n    string strSelfLoop =\n        \"%PDF-1.0\\r\\n\"\n        \"1 0 obj<</Type/Catalog/Outlines 2 0 R>>endobj \"\n        \"2 0 obj<</Type/Outlines /First 2 0 R /Last 2 0 R /Count 1>>endobj\" // /First and /Last loop to self\n        \"\\r\\n\"\n        \"xref\\r\\n\"\n        \"0 3\\r\\n\"\n        \"0000000000 65535 f\\r\\n\"\n        \"0000000010 00000 n\\r\\n\"\n        \"0000000056 00000 n\\r\\n\"\n        \"trailer<</Size 3/Root 1 0 R>>\\r\\n\"\n        \"startxref\\r\\n\"\n        \"123\\r\\n\"\n        \"%%EOF\";\n\n    try\n    {\n        PdfMemDocument doc;\n        doc.LoadFromBuffer(strNextLoop);\n\n        // load should succeed, then GetOutlines goes recursive due to /Outlines loop\n        (void)doc.GetOutlines();\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n    }\n}\n\nstring generateXRefEntries(size_t count)\n{\n    string strXRefEntries;\n\n    // generates a block of 20-byte xref entries\n    // 0000000000 65535 f\\r\\n\n    // 0000000120 00000 n\\r\\n    \n    // 0000000120 00000 n\\r\\n\n    // 0000000120 00000 n\\r\\n\n    try\n    {\n        strXRefEntries.reserve(count * 20);\n        for (size_t i = 0; i < count; i++)\n        {\n            if (i == 0)\n                strXRefEntries.append(\"0000000000 65535 f\\r\\n\");\n            else\n                strXRefEntries.append(\"0000000120 00000 n\\r\\n\");\n        }\n    }\n    catch (exception&)\n    {\n        // if this fails it's a bug in the unit tests and not PoDoFo\n        FAIL(\"generateXRefEntries memory allocation failure\");\n    }\n\n    return strXRefEntries;\n}\n\nbool canOutOfMemoryKillUnitTests()\n{\n    // test if out of memory conditions will kill the unit test process\n    // which prevents tests completing\n\n#if defined(_WIN32)\n    // on Windows 32/64 allocations close to size of VM address space always fail gracefully\n    bool canTerminateProcess = false;\n#elif defined( __APPLE__ )\n    // on macOS/iOS allocations close to size of VM address space fail gracefully\n    // unless Address Sanitizer (ASAN) is enabled\n#if __has_feature(address_sanitizer)\n    // ASAN terminates the process if alloc fails - and using allocator_may_return_null=1\n    // to continue after an allocation doesn't work in C++ because new returns null which is\n    // forbidden by the C++ spec and terminates process when 'this' is dereferenced in constructor\n    // see https://github.com/google/sanitizers/issues/295\n    bool canTerminateProcess = true;\n#else\n    // if alloc fails following message is logged\n    // *** mach_vm_map failed (error code=3)\n    // *** error: can't allocate region\n    // *** set a breakpoint in malloc_error_break to debug\n    bool canTerminateProcess = false;\n#endif\n#elif defined( __linux__ )\n    // TODO do big allocs succeed then trigger OOM-killer fiasco??\n    bool canTerminateProcess = false;\n#else\n    // other systems - assume big allocs faily gracefully and throw bad_alloc\n    bool canTerminateProcess = false;\n#endif\n    return canTerminateProcess;\n}\n\nsize_t getStackOverflowDepth()\n{\n    // calculate stack overflow depth - need to do this because a value that consistently overflows a 64-bit stack\n    // doesn't work on 32-bit systems because they run out of heap in ReadObjects before they get a chance to overflow stack\n    // this is because sizeof(PdfParserObject) = 472 bytes (and there's one of these for every object read)\n    constexpr size_t parserObjectSize = sizeof(PdfParserObject);\n\n#if defined(_WIN64)\n    // 1 MB default stack size, 64-bit address space, Windows x64 ABI\n    // each stack frame has at least 4 64-bit stack params, 4 64-bit register params, plus 64-bit return address\n    // stack frame size increases if function contains local variables or more than 4 parameters\n    // see https://docs.microsoft.com/en-us/cpp/build/stack-usage?view=msvc-170\n    constexpr size_t stackSize = 1 * 1024 * 1024;\n    constexpr size_t frameSize = sizeof(void*) * (4 + 4 + 1); // 4 stack params + 4 register params + return address\n    constexpr size_t maxFrames = stackSize / frameSize; // overflows at 14,563 recursive calls (or sooner if functions contain local variables)\n#elif defined(_WIN32)\n    // 1 MB default stack size, 32-bit address space (can't allocate more than 2GB), Windows x86 thiscall calling convention\n    // each stack frame has at least 32-bit EBP and return address\n    // stack frame size increases if function contains local variables or any parameters\n    constexpr size_t stackSize = 1 * 1024 * 1024;\n    constexpr size_t frameSize = sizeof(void*) * (1 + 1); // EBP and return address\n    constexpr size_t maxFrames = stackSize / frameSize; // overflows at 131,072 recursive calls (or sooner if functions contain local variables or has parameters)\n#else\n    // assume 8MB macOS / Linux default stack size, 64-bit address space, System V AMD64 ABI\n    // each stack frame has at least 64-bit EBP and return address\n    // stack frame size increases if function contains local variables or any parameters\n    constexpr size_t stackSize = 8 * 1024 * 1024;\n    constexpr size_t frameSize = sizeof(void*) * (1 + 1); // EBP and return address\n    constexpr size_t maxFrames = stackSize / frameSize; // overflows at 524,288 recursive calls (or sooner if functions contain local variables or has parameters)\n#endif\n\n    // add a few frames to sure we go beyond end of stack\n    constexpr size_t overflowDepth = maxFrames + 1000;\n\n    // overflowDepth must be less than GetMaxObjectCount otherwise PdfParser::ResizeOffsets\n    // throws an error when reading the xref offsets table, and no recursive calls are made\n    // must also be allocate less than half of address space to prevent out-of-memory exceptions\n    REQUIRE(overflowDepth < PdfParser::GetMaxObjectCount());\n    REQUIRE(overflowDepth * parserObjectSize < numeric_limits<size_t>::max() / 2);\n\n    return overflowDepth;\n}\n"], "fixing_code": ["cmake_minimum_required(VERSION 3.16)\n\nif (\"${CMAKE_BUILD_TYPE}\" STREQUAL \"\")\n    set(CMAKE_BUILD_TYPE \"Release\")\nendif()\n\n# Clean CMAKE_CONFIGURATION_TYPES. Only one configuration will be used\nunset(CMAKE_CONFIGURATION_TYPES CACHE) # It will also remove it from GUI\nset(CMAKE_CONFIGURATION_TYPES \"${CMAKE_BUILD_TYPE}\")\n\nproject(podofo)\nenable_testing() # Needed to enable \"make test\" from binary dir\n\n# An useful variable to check if we are running from playground\nset(PODOFO_PLAYGROUND TRUE)\n\nif (\"${ARCH}\" STREQUAL \"\")\n    message(FATAL_ERROR \"ARCH is not set. Run the boostrap scripts\")\nendif()\n\nif (\"${PODOFO_DIR}\" STREQUAL \"\")\n    get_filename_component(PODOFO_DIR ${CMAKE_CURRENT_SOURCE_DIR} DIRECTORY)\nendif()\n\nset(DEPS_PATH \"$ENV{PODOFO_DEPS_PATH}\")\nif (\"${DEPS_PATH}\" STREQUAL \"\")\n    set(DEPS_PATH \"${PODOFO_DIR}/extern/deps/3rdparty\")\nendif()\n\nif(NOT EXISTS \"${DEPS_PATH}\")\n    message(FATAL_ERROR \"Deps path doesn't exists: try fetch git submodules with:\\n    git submodule update --init\")\nendif()\n\nif (MSVC)\n    # Ignore warnings about missing pdbs\n    set(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} /ignore:4099\")\n    set(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} /ignore:4099\")\n    set(CMAKE_STATIC_LINKER_FLAGS \"${CMAKE_STATIC_LINKER_FLAGS} /ignore:4099\")\nendif()\n\nmessage(\"ARCHITECTURE: ${ARCH}\")\nmessage(\"PODOFO_DIR: ${PODOFO_DIR}\")\nmessage(\"DEPS_PATH: ${DEPS_PATH}\")\n\n# Set include folders for find_package()\nlist(APPEND CMAKE_INCLUDE_PATH\n    \"${DEPS_PATH}/zlib/include\"\n    \"${DEPS_PATH}/libxml2/include\"\n    \"${DEPS_PATH}/fontconfig/include\"\n    \"${DEPS_PATH}/freetype/include\"\n    \"${DEPS_PATH}/libpng/include\"\n    \"${DEPS_PATH}/libjpeg/include\"\n    \"${DEPS_PATH}/libtiff/include\"\n    \"${DEPS_PATH}/openssl/include\"\n    \"${DEPS_PATH}/libidn/include\"\n)\n\n# Set library folders for find_package()\nlist(APPEND CMAKE_LIBRARY_PATH\n    \"${DEPS_PATH}/zlib/lib/${ARCH}\"\n    \"${DEPS_PATH}/libxml2/lib/${ARCH}\"\n    \"${DEPS_PATH}/freetype/lib/${ARCH}\"\n    \"${DEPS_PATH}/fontconfig/lib/${ARCH}\"\n    \"${DEPS_PATH}/libpng/lib/${ARCH}\"\n    \"${DEPS_PATH}/libjpeg/lib/${ARCH}\"\n    \"${DEPS_PATH}/libtiff/lib/${ARCH}\"\n    \"${DEPS_PATH}/openssl/lib/${ARCH}\"\n    \"${DEPS_PATH}/libidn/lib/${ARCH}\"\n)\n\n# Set use libxml2 static for fontconfig\nadd_compile_definitions(LIBXML_STATIC)\n# Set use libidn static\nadd_compile_definitions(LIBIDN_STATIC)\n\nif(WIN32)\n    if (\"${CMAKE_BUILD_TYPE}\" STREQUAL \"Debug\")\n        set(LIB_SUFFIX \"d\")\n    endif()\n\n    # Following libraries find-modules have issues in correctly\n    # determining the right optimized/debug library so we do it manually\n\n    # OpenSSL\n    set(OPENSSL_INCLUDE_DIR \"${DEPS_PATH}/openssl/include\" CACHE PATH \"\" FORCE)\n    set(LIB_EAY_DEBUG \"${DEPS_PATH}/openssl/lib/${ARCH}/cryptod.lib\" CACHE FILEPATH \"\" FORCE)\n    set(LIB_EAY_RELEASE \"${DEPS_PATH}/openssl/lib/${ARCH}/crypto.lib\" CACHE FILEPATH \"\" FORCE)\n    set(SSL_EAY_DEBUG \"${DEPS_PATH}/openssl/lib/${ARCH}/ssld.lib\" CACHE FILEPATH \"\" FORCE)\n    set(SSL_EAY_RELEASE \"${DEPS_PATH}/openssl/lib/${ARCH}/ssl.lib\" CACHE FILEPATH \"\" FORCE)\n    # Libxml2\n    set(LIBXML2_LIBRARY \"${DEPS_PATH}/libxml2/lib/${ARCH}/libxml2${LIB_SUFFIX}.lib\" CACHE FILEPATH \"\" FORCE)\n    # Fontconfig\n    set(Fontconfig_LIBRARY \"${DEPS_PATH}/fontconfig/lib/${ARCH}/fontconfig${LIB_SUFFIX}.lib\" CACHE FILEPATH \"\" FORCE)\nelse()\n    # Freetype\n    set(FREETYPE_INCLUDE_DIR_ft2build \"${DEPS_PATH}/freetype/include/freetype2\" CACHE PATH \"\" FORCE)\n    set(FREETYPE_INCLUDE_DIR_freetype2 \"${DEPS_PATH}/freetype/include\" CACHE PATH \"\" FORCE)\n    set(FREETYPE_LIBRARY_RELEASE \"${DEPS_PATH}/freetype/lib/${ARCH}/libfreetype.a\" CACHE FILEPATH \"\" FORCE)\n    # Fontconfig\n    set(Fontconfig_LIBRARY \"${DEPS_PATH}/fontconfig/lib/${ARCH}/libfontconfig.a\" CACHE FILEPATH \"\" FORCE)\n    set(PLATFORM_SYSTEM_LIBRARIES \"${DEPS_PATH}/bzip2/lib/${ARCH}/libbz2.a\" \"${DEPS_PATH}/libuuid/lib/${ARCH}/libuuid.a\")\nendif()\n\nadd_subdirectory(\"${PODOFO_DIR}\" \"${CMAKE_BINARY_DIR}/podofo\")\n", "/**\n * SPDX-FileCopyrightText: (C) 2009 Dominik Seichter <domseichter@web.de>\n * SPDX-FileCopyrightText: (C) 2020 Francesco Pretto <ceztko@gmail.com>\n * SPDX-License-Identifier: LGPL-2.0-or-later\n */\n\n#include <podofo/private/PdfDeclarationsPrivate.h>\n#include \"PdfXRefStreamParserObject.h\"\n\n#include \"PdfParser.h\"\n#include \"PdfArray.h\"\n#include \"PdfDictionary.h\"\n#include \"PdfObjectStream.h\"\n#include \"PdfVariant.h\"\n\nusing namespace std;\nusing namespace PoDoFo;\n\nPdfXRefStreamParserObject::PdfXRefStreamParserObject(PdfDocument& doc, InputStreamDevice& device, PdfXRefEntries& entries)\n    : PdfXRefStreamParserObject(&doc, device, entries) { }\n\nPdfXRefStreamParserObject::PdfXRefStreamParserObject(InputStreamDevice& device, PdfXRefEntries& entries)\n    : PdfXRefStreamParserObject(nullptr, device, entries) { }\n\nPdfXRefStreamParserObject::PdfXRefStreamParserObject(PdfDocument* doc, InputStreamDevice& device, PdfXRefEntries& entries)\n    : PdfParserObject(doc, PdfReference(), device, -1), m_NextOffset(-1), m_entries(&entries)\n{\n}\n\nvoid PdfXRefStreamParserObject::DelayedLoadImpl()\n{\n    // NOTE: Ignore the encryption in the XREF as the XREF stream must no be encrypted (see PDF Reference 3.4.7)\n\n    PdfTokenizer tokenizer;\n    auto reference = ReadReference(tokenizer);\n    SetIndirectReference(reference);\n    PdfParserObject::Parse(tokenizer);\n\n    // Do some very basic error checking\n    auto& dict = m_Variant.GetDictionary();\n    auto keyObj = dict.FindKey(PdfName::KeyType);\n    if (keyObj == nullptr)\n        PODOFO_RAISE_ERROR(PdfErrorCode::NoXRef);\n\n    if (!keyObj->IsName() || keyObj->GetName() != \"XRef\")\n        PODOFO_RAISE_ERROR(PdfErrorCode::NoXRef);\n\n    if (!dict.HasKey(PdfName::KeySize)\n        || !dict.HasKey(\"W\"))\n    {\n        PODOFO_RAISE_ERROR(PdfErrorCode::NoXRef);\n    }\n\n    if (dict.HasKey(\"Prev\"))\n        m_NextOffset = static_cast<ssize_t>(dict.FindKeyAs<double>(\"Prev\", 0));\n\n    if (!this->HasStreamToParse())\n        PODOFO_RAISE_ERROR(PdfErrorCode::NoXRef);\n}\n\nvoid PdfXRefStreamParserObject::ReadXRefTable()\n{\n    int64_t size = this->GetDictionary().FindKeyAs<int64_t>(PdfName::KeySize, 0);\n    auto& arrObj = this->GetDictionary().MustFindKey(\"W\");\n\n    // The pdf reference states that W is always an array with 3 entries\n    // all of them have to be integers\n    const PdfArray* arr;\n    if (!arrObj.TryGetArray(arr) || arr->size() != 3)\n        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream, \"Invalid XRef stream /W array\");\n\n    int64_t wArray[W_ARRAY_SIZE] = { 0, 0, 0 };\n    int64_t num;\n    for (unsigned i = 0; i < W_ARRAY_SIZE; i++)\n    {\n\n        if (!(*arr)[i].TryGetNumber(num))\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream, \"Invalid XRef stream /W array\");\n\n        wArray[i] = num;\n    }\n\n    vector<int64_t> indices;\n    getIndices(indices, static_cast<int64_t>(size));\n\n    parseStream(wArray, indices);\n}\n\nvoid PdfXRefStreamParserObject::parseStream(const int64_t wArray[W_ARRAY_SIZE], const vector<int64_t>& indices)\n{\n    for (int64_t lengthSum = 0, i = 0; i < W_ARRAY_SIZE; i++)\n    {\n        if (wArray[i] < 0)\n        {\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream,\n                \"Negative field length in XRef stream\");\n        }\n        if (numeric_limits<int64_t>::max() - lengthSum < wArray[i])\n        {\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream,\n                \"Invalid entry length in XRef stream\");\n        }\n        else\n        {\n            lengthSum += wArray[i];\n        }\n    }\n\n    const size_t entryLen = static_cast<size_t>(wArray[0] + wArray[1] + wArray[2]);\n\n    charbuff buffer;\n    this->GetOrCreateStream().CopyTo(buffer);\n\n    vector<int64_t>::const_iterator it = indices.begin();\n    size_t offset = 0;\n    while (it != indices.end())\n    {\n        int64_t firstObj = *it++;\n        int64_t count = *it++;\n\n        if ((offset + count * entryLen) > buffer.size())\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream, \"Invalid count in XRef stream\");\n\n        m_entries->Enlarge(firstObj + count);\n        for (unsigned index = 0; index < (unsigned)count; index++)\n        {\n            unsigned objIndex = (unsigned)firstObj + index;\n            auto& entry = (*m_entries)[objIndex];\n            if (objIndex < m_entries->GetSize() && !entry.Parsed)\n                readXRefStreamEntry(entry, buffer.data() + offset, wArray);\n\n            offset += entryLen;\n        }\n    }\n}\n\nvoid PdfXRefStreamParserObject::getIndices(vector<int64_t>& indices, int64_t size)\n{\n    // get the first object number in this crossref stream.\n    // it is not required to have an index key though\n    auto indexObj = this->GetDictionary().GetKey(\"Index\");\n    if (indexObj == nullptr)\n    {\n        // Default\n        indices.push_back(static_cast<int64_t>(0));\n        indices.push_back(size);\n    }\n    else\n    {\n        const PdfArray* arr;\n        if (!indexObj->TryGetArray(arr))\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream, \"Invalid XRef Stream /Index\");\n\n        for (auto index : *arr)\n            indices.push_back(index.GetNumber());\n    }\n\n    // indices must be a multiple of 2\n    if (indices.size() % 2 != 0)\n        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream, \"Invalid XRef Stream /Index\");\n}\n\nvoid PdfXRefStreamParserObject::readXRefStreamEntry(PdfXRefEntry& entry, char* buffer, const int64_t wArray[W_ARRAY_SIZE])\n{\n    uint64_t entryRaw[W_ARRAY_SIZE];\n    for (unsigned i = 0; i < W_ARRAY_SIZE; i++)\n    {\n        if (wArray[i] > W_MAX_BYTES)\n        {\n            PoDoFo::LogMessage(PdfLogSeverity::Error,\n                \"The XRef stream dictionary has an entry in /W of size {}. The maximum supported value is {}\",\n                wArray[i], W_MAX_BYTES);\n\n            PODOFO_RAISE_ERROR(PdfErrorCode::InvalidXRefStream);\n        }\n\n        entryRaw[i] = 0;\n        for (int64_t z = W_MAX_BYTES - wArray[i]; z < W_MAX_BYTES; z++)\n        {\n            entryRaw[i] = (entryRaw[i] << 8) + static_cast<unsigned char>(*buffer);\n            buffer++;\n        }\n    }\n\n    entry.Parsed = true;\n\n    // TABLE 3.15 Additional entries specific to a cross - reference stream dictionary\n    // /W array: \"If the first element is zero, the type field is not present, and it defaults to type 1\"\n    uint64_t type;\n    if (wArray[0] == 0)\n        type = 1;\n    else\n        type = entryRaw[0]; // nData[0] contains the type information of this entry\n\n    switch (type)\n    {\n        // TABLE 3.16 Entries in a cross-reference stream\n        case 0:\n            // a free object\n            entry.ObjectNumber = entryRaw[1];\n            entry.Generation = (uint32_t)entryRaw[2];\n            entry.Type = XRefEntryType::Free;\n            break;\n        case 1:\n            // normal uncompressed object\n            entry.Offset = entryRaw[1];\n            entry.Generation = (uint32_t)entryRaw[2];\n            entry.Type = XRefEntryType::InUse;\n            break;\n        case 2:\n            // object that is part of an object stream\n            entry.ObjectNumber = entryRaw[1]; // object number of the stream\n            entry.Index = (uint32_t)entryRaw[2]; // index in the object stream\n            entry.Type = XRefEntryType::Compressed;\n            break;\n        default:\n            PODOFO_RAISE_ERROR(PdfErrorCode::InvalidXRefType);\n    }\n}\n\nbool PdfXRefStreamParserObject::TryGetPreviousOffset(size_t& previousOffset) const\n{\n    bool ret = m_NextOffset != -1;\n    previousOffset = ret ? (size_t)m_NextOffset : 0;\n    return ret;\n}\n", "/**\n * Copyright (C) 2007 by Dominik Seichter <domseichter@web.de>\n * Copyright (C) 2021 by Francesco Pretto <ceztko@gmail.com>\n *\n * Licensed under GNU Library General Public 2.0 or later.\n * Some rights reserved. See COPYING, AUTHORS.\n */\n\n/*\n    Notes:\n\n    1) out of memory tests don't run if Address Santizer (ASAN) is enabled because\n       ASAN terminates the unit test process the first time it attempts to allocate\n       too much memory (so running the tests with and without ASAN is recommended)\n\n    2) PoDoFo log warnings about inconsistencies or values out of range are expected\n       because the tests are supplying invalid values to check PoDoFo behaves correctly\n       in those situations\n*/\n\n#include <limits>\n\n#include <sstream>\n\n#include <PdfTest.h>\n\nusing namespace std;\nusing namespace PoDoFo;\n\nstatic string generateXRefEntries(size_t count);\nstatic bool canOutOfMemoryKillUnitTests();\nstatic void testReadXRefSubsection();\nstatic size_t getStackOverflowDepth();\n\n// this value is from Table C.1 in Appendix C.2 Architectural Limits in PDF 32000-1:2008\n// on 32-bit systems sizeof(PdfParser::TXRefEntry)=16 => max size of m_offsets=16*8,388,607 = 134 MB\n// on 64-bit systems sizeof(PdfParser::TXRefEntry)=24 => max size of m_offsets=16*8,388,607 = 201 MB\nconstexpr unsigned maxNumberOfIndirectObjects = 8388607;\n\nnamespace PoDoFo\n{\n    class PdfParserTest : public PdfParser\n    {\n    public:\n        PdfParserTest(PdfIndirectObjectList& objectList, string buff)\n            : PdfParser(objectList), m_buffer(std::move(buff)), m_device(new SpanStreamDevice(m_buffer))\n        {\n        }\n\n        void ReadXRefContents(size_t offset, bool positionAtEnd)\n        {\n            // call protected method\n            PdfParser::ReadXRefContents(*m_device, offset, positionAtEnd);\n        }\n\n        void ReadXRefSubsection(int64_t firstObject, int64_t objectCount)\n        {\n            // call protected method\n            PdfParser::ReadXRefSubsection(*m_device, firstObject, objectCount);\n        }\n\n        void ReadXRefStreamContents(size_t offset, bool readOnlyTrailer)\n        {\n            // call protected method\n            PdfParser::ReadXRefStreamContents(*m_device, offset, readOnlyTrailer);\n        }\n\n        void ReadDocumentStructure()\n        {\n            // call protected method\n            PdfParser::ReadDocumentStructure(*m_device);\n        }\n\n        void ReadObjects()\n        {\n            // call protected method\n            PdfParser::ReadObjects(*m_device);\n        }\n\n        bool IsPdfFile()\n        {\n            // call protected method\n            return PdfParser::IsPdfFile(*m_device);\n        }\n\n        const shared_ptr<InputStreamDevice>& GetDevice() { return m_device; }\n\n    private:\n        string m_buffer;\n        shared_ptr<InputStreamDevice> m_device;\n    };\n}\n\nTEST_CASE(\"TestMaxObjectCount\")\n{\n    PdfParser::SetMaxObjectCount(numeric_limits<unsigned short>::max());\n    testReadXRefSubsection();\n\n    PdfParser::SetMaxObjectCount(maxNumberOfIndirectObjects);\n    testReadXRefSubsection();\n}\n\n// NOTE: This test is too long to be normally done on every run\nTEST_CASE(\"TestMaxObjectCount2\", \"[.]\")\n{\n    PdfParser::SetMaxObjectCount(numeric_limits<unsigned>::max());\n    testReadXRefSubsection();\n}\n\n\nTEST_CASE(\"TestReadXRefContents\")\n{\n    try\n    {\n        // generate an xref section\n        // xref\n        // 0 3\n        // 0000000000 65535 f \n        // 0000000018 00000 n \n        // 0000000077 00000 n\n        // trailer << /Root 1 0 R /Size 3 >>\n        // startxref\n        // 0\n        // %%EOF\n        ostringstream oss;\n        oss << \"xref\\r\\n0 3\\r\\n\";\n        oss << generateXRefEntries(3);\n        oss << \"trailer << /Root 1 0 R /Size 3 >>\\r\\n\";\n        oss << \"startxref 0\\r\\n\";\n        oss << \"%EOF\";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, oss.str());\n        parser.ReadXRefContents(0, false);\n        // expected to succeed\n    }\n    catch (PdfError&)\n    {\n        FAIL(\"Should not throw PdfError\");\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    try\n    {\n        // generate an xref section with missing xref entries\n        // xref\n        // 0 3\n        // 0000000000 65535 f \n        // 0000000018 00000 n \n        // \n        // trailer << /Root 1 0 R /Size 3 >>\n        // startxref\n        // 0\n        // %%EOF        \n        ostringstream oss;\n        oss << \"xref\\r\\n0 3\\r\\n\";\n        oss << generateXRefEntries(2); // 2 entries supplied, but expecting 3 entries\n        oss << \"trailer << /Root 1 0 R /Size 3 >>\\r\\n\";\n        oss << \"startxref 0\\r\\n\";\n        oss << \"%EOF\";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, oss.str());\n        parser.ReadXRefContents(0, false);\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    try\n    {\n        // TODO malformed entries are not detected\n        // generate an xref section with badly formed xref entries\n        // xref\n        // 0 3        \n        // 000000000 65535\n        // 00000000065535 x\n        // 0000000\n        // 0000000018 00000 n\n        // 0000000077 00000 n        \n        // trailer << /Root 1 0 R /Size 3 >>\n        // startxref\n        // 0\n        // %%EOF\n        ostringstream oss;\n        oss << \"xref\\r\\n0 5\\r\\n\";\n        oss << \"000000000 65535\\r\\n\";\n        oss << \"00000000065535 x\\r\\n\";\n        oss << \"0000000\\r\\n\";\n        oss << generateXRefEntries(2);\n        oss << \"trailer << /Root 1 0 R /Size 5 >>\\r\\n\";\n        oss << \"startxref 0\\r\\n\";\n        oss << \"%EOF\";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, oss.str());\n        parser.ReadXRefContents(0, false);\n        // succeeds reading badly formed xref entries  - should it?\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    // CVE-2017-8053 ReadXRefContents and ReadXRefStreamContents are mutually recursive   \n    // and can cause stack overflow\n\n    try\n    {\n        // generate an xref section and one XRef stream that references itself\n        // via the /Prev entry (but use a slightly lower offset by linking to\n        // to whitespace discarded by the tokenizer just before the xref section)\n        // xref\n        // 0 1\n        // 000000000 65535\n        // 2 0 obj << /Type XRef /Prev offsetXrefStmObj2 >> stream ... endstream\n        // trailer << /Root 1 0 R /Size 3 >>\n        // startxref\n        // offsetXrefStmObj2\n        // %%EOF\n        ostringstream oss;\n\n        // object stream contents - length excludes trailing whitespace\n        string streamContents =\n            \"01 0E8A 0\\r\\n\"\n            \"02 0002 00\\r\\n\";\n        size_t streamContentsLength = streamContents.size() - strlen(\"\\r\\n\");\n\n        // xref section at offset 0\n        //size_t offsetXref = 0;\n        oss << \"xref\\r\\n0 1\\r\\n\";\n        oss << generateXRefEntries(1);\n\n        // XRef stream at offsetXrefStm1, but any /Prev entries pointing to any offet between\n        // offsetXrefStm1Whitespace and offsetXrefStm1 point to the same /Prev section\n        // because the PDF processing model says tokenizer must discard whitespace and comments\n        size_t offsetXrefStm1Whitespace = oss.str().length();\n        oss << \"    \\r\\n\";\n        oss << \"% comments and leading white space are ignored - see PdfTokenizer::GetNextToken\\r\\n\";\n        size_t offsetXrefStm1 = oss.str().length();\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << streamContentsLength << \" \";\n        oss << \"/Index [2 2] \";\n        oss << \"/Size 3 \";\n        oss << \"/Prev \" << offsetXrefStm1Whitespace << \" \";     // xref /Prev offset points back to start of this stream object\n        oss << \"/W [1 2 1] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        oss << streamContents;\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n\n        oss << \"trailer << /Root 1 0 R /Size 3 >>\\r\\n\";\n        oss << \"startxref \" << offsetXrefStm1 << \"\\r\\n\";\n        oss << \"%EOF\";\n\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, oss.str());\n        parser.ReadXRefContents(offsetXrefStm1, false);\n        // succeeds in current code - should it?\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRefType);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    try\n    {\n        // generate an xref section and two XRef streams that reference each other\n        // via the /Prev entry\n        // xref\n        // 0 1\n        // 000000000 65535\n        // 2 0 obj << /Type XRef /Prev offsetXrefStmObj3 >> stream ...  endstream\n        // 3 0 obj << /Type XRef /Prev offsetXrefStmObj2 >> stream ...  endstream\n        // trailer << /Root 1 0 R /Size 3 >>\n        // startxref\n        // offsetXrefStmObj2\n        // %%EOF\n        ostringstream oss;\n\n        // object stream contents - length excludes trailing whitespace\n        string streamContents =\n            \"01 0E8A 0\\r\\n\"\n            \"02 0002 00\\r\\n\";\n        size_t streamContentsLength = streamContents.size() - strlen(\"\\r\\n\");\n\n        // xref section at offset 0\n        //size_t offsetXref = 0;\n        oss << \"xref\\r\\n0 1\\r\\n\";\n        oss << generateXRefEntries(1);\n\n        // xrefstm at offsetXrefStm1\n        size_t offsetXrefStm1 = oss.str().length();\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << streamContentsLength << \" \";\n        oss << \"/Index [2 2] \";\n        oss << \"/Size 3 \";\n        oss << \"/Prev 185 \";     // xref stream 1 sets xref stream 2 as previous in chain\n        oss << \"/W [1 2 1] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        oss << streamContents;\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n\n        // xrefstm at offsetXrefStm2\n        size_t offsetXrefStm2 = oss.str().length();\n        REQUIRE(offsetXrefStm2 == 185); // hard-coded in /Prev entry in XrefStm1 above\n        oss << \"3 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << streamContentsLength << \" \";\n        oss << \"/Index [2 2] \";\n        oss << \"/Size 3 \";\n        oss << \"/Prev \" << offsetXrefStm1 << \" \";     // xref stream 2 sets xref stream 1 as previous in chain\n        oss << \"/W [1 2 1] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        oss << streamContents;\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n\n        oss << \"trailer << /Root 1 0 R /Size 3 >>\\r\\n\";\n        oss << \"startxref \" << offsetXrefStm2 << \"\\r\\n\";\n        oss << \"%EOF\";\n\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, oss.str());\n        parser.ReadXRefContents(offsetXrefStm2, false);\n        // succeeds in current code - should it?\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRefType);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    try\n    {\n        // generate an xref section and lots of XRef streams without loops but reference \n        // the previous stream via the /Prev entry\n        // xref\n        // 0 1\n        // 000000000 65535\n        // 2 0 obj << /Type XRef >> stream ...  endstream\n        // 3 0 obj << /Type XRef /Prev offsetStreamObj(2) >> stream ...  endstream\n        // 4 0 obj << /Type XRef /Prev offsetStreamObj(3) >> stream ...  endstream\n        // ...\n        // N 0 obj << /Type XRef /Prev offsetStreamObj(N-1) >> stream ...  endstream\n        // trailer << /Root 1 0 R /Size 3 >>\n        // startxref\n        // offsetStreamObj(N)\n        // %%EOF\n        ostringstream oss;\n        size_t prevOffset = 0;\n        size_t currentOffset = 0;\n\n        // object stream contents - length excludes trailing whitespace\n        string streamContents =\n            \"01 0E8A 0\\r\\n\"\n            \"02 0002 00\\r\\n\";\n        size_t streamContentsLength = streamContents.size() - strlen(\"\\r\\n\");\n\n        // xref section at offset 0\n        //size_t offsetXref = 0;\n        oss << \"xref\\r\\n0 1\\r\\n\";\n        oss << generateXRefEntries(1);\n\n        // this caused stack overflow on macOS 64-bit with around 3000 streams\n        // and on Windows 32-bit with around 1000 streams\n\n        constexpr size_t maxXrefStreams = 10000;\n        for (size_t i = 0; i < maxXrefStreams; i++)\n        {\n            size_t objNo = i + 2;\n\n            // xrefstm at currentOffset linked back to stream at prevOffset\n            prevOffset = currentOffset;\n            currentOffset = oss.str().length();\n            oss << objNo << \" 0 obj \";\n            oss << \"<< /Type /XRef \";\n            oss << \"/Length \" << streamContentsLength << \" \";\n            oss << \"/Index [2 2] \";\n            oss << \"/Size 3 \";\n            if (prevOffset > 0)\n                oss << \"/Prev \" << prevOffset << \" \";\n            oss << \"/W [1 2 1] \";\n            oss << \"/Filter /ASCIIHexDecode \";\n            oss << \">>\\r\\n\";\n            oss << \"stream\\r\\n\";\n            oss << streamContents;\n            oss << \"endstream\\r\\n\";\n            oss << \"endobj\\r\\n\";\n        }\n\n        oss << \"trailer << /Root 1 0 R /Size 3 >>\\r\\n\";\n        oss << \"startxref \" << currentOffset << \"\\r\\n\";\n        oss << \"%EOF\";\n\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, oss.str());\n        parser.ReadXRefContents(currentOffset, false);\n        // succeeds in current code - should it?\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRefType);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n}\n\nvoid testReadXRefSubsection()\n{\n    int64_t firstObject = 0;\n    int64_t objectCount = 0;\n\n    // TODO does ReadXRefSubsection with objectCount = 0 make sense ???\n\n    // CVE-2017-5855 m_offsets.resize() NULL ptr read\n    // CVE-2017-6844 m_offsets.resize() buffer overwrite \n    // false positives due to AFL setting allocator_may_return_null=1 which causes\n    // ASAN to return NULL instead of throwing bad_alloc for out-of-memory conditions\n    // https://github.com/mirrorer/afl/blob/master/docs/env_variables.txt#L248\n    // https://github.com/google/sanitizers/issues/295#issuecomment-234273218 \n    // the test for CVE-2018-5296 below checks that PoDoFo restricts allocations\n\n    // CVE-2018-5296 m_offsets.resize() malloc failure when large size specified\n    // check PoDoFo throws PdfError and not anything derived from exception\n    // check PoDoFo can't allocate unrestricted amounts of memory\n\n    if (PdfParser::GetMaxObjectCount() <= maxNumberOfIndirectObjects)\n    {\n        try\n        {\n            string strInput = generateXRefEntries(PdfParser::GetMaxObjectCount());\n            PdfIndirectObjectList objects;\n            PdfParserTest parser(objects, strInput);\n            firstObject = 0;\n            objectCount = PdfParser::GetMaxObjectCount();\n            parser.ReadXRefSubsection(firstObject, objectCount);\n            // expected to succeed\n        }\n        catch (PdfError&)\n        {\n            FAIL(\"should not throw PdfError\");\n        }\n        catch (exception&)\n        {\n            FAIL(\"Unexpected exception type\");\n        }\n    }\n    else\n    {\n        // test has been called from testMaxObjectCount with PdfParser::SetMaxObjectCount()\n        // set to a large value (large allocs are tested in address space tests below)\n    }\n\n    // don't run the following test if PdfParser::GetMaxObjectCount()+1 will overflow\n    // in the numXRefEntries calculation below (otherwise we get an ASAN error)\n    if (PdfParser::GetMaxObjectCount() < numeric_limits<unsigned>::max())\n    {\n        // don't generate xrefs for high values of GetMaxObjectCount() e.g. don't try to generate 2**63 xrefs\n        unsigned numXRefEntries = std::min(maxNumberOfIndirectObjects + 1, PdfParser::GetMaxObjectCount() + 1);\n\n        try\n        {\n            string strInput = generateXRefEntries(numXRefEntries);\n            PdfIndirectObjectList objects;\n            PdfParserTest parser(objects, strInput);\n            firstObject = 0;\n            objectCount = (int64_t)PdfParser::GetMaxObjectCount() + 1;\n            parser.ReadXRefSubsection(firstObject, objectCount);\n            FAIL(\"PdfError not thrown\");\n        }\n        catch (PdfError& error)\n        {\n            // too many indirect objects in Trailer /Size key throws PdfErrorCode::ValueOutOfRange\n            // but too many indirect objects in xref table throws PdfErrorCode::InvalidXRef\n            REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n        }\n        catch (exception&)\n        {\n            FAIL(\"Wrong exception type\");\n        }\n    }\n\n    // CVE-2018-5296 try to allocate more than address space size \n    // should throw a bad_length exception in STL which is rethrown as a PdfError\n    try\n    {\n        // this attempts to allocate numeric_limits<size_t>::max()/2 * sizeof(TXRefEntry)\n        // on 32-bit systems this allocates 2**31 * sizeof(TXRefEntry) = 2**31 * 16 (larger than 32-bit address space)\n        // on LP64 (macOS,*nix) systems this allocates 2**63 * sizeof(TXRefEntry) = 2**63 * 24 (larger than 64-bit address space)\n        // on LLP64 (Win64) systems this allocates 2**31 * sizeof(TXRefEntry) = 2**31 * 16 (smaller than 64-bit address space)\n        string strInput = \" \";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = 1;\n        objectCount = numeric_limits<size_t>::max() / 2 - 1;\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        // if objectCount > PdfParser::GetMaxObjectCount() then we'll see PdfErrorCode::InvalidXRef\n        // otherwise we'll see PdfErrorCode::ValueOutOfRange or PdfErrorCode::OutOfMemory (see testMaxObjectCount)\n        REQUIRE((error.GetCode() == PdfErrorCode::InvalidXRef\n            || error.GetCode() == PdfErrorCode::ValueOutOfRange\n            || error.GetCode() == PdfErrorCode::OutOfMemory));\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2018-5296 try to allocate 95% of VM address space size (which should always fail)\n    if (!canOutOfMemoryKillUnitTests())\n    {\n        constexpr size_t maxObjects = numeric_limits<size_t>::max() / sizeof(PdfXRefEntry) / 100 * 95;\n\n        try\n        {\n            string strInput = \" \";\n            PdfIndirectObjectList objects;\n            PdfParserTest parser(objects, strInput);\n            firstObject = 1;\n            objectCount = maxObjects;\n            parser.ReadXRefSubsection(firstObject, objectCount);\n            FAIL(\"PdfError not thrown\");\n        }\n        catch (PdfError& error)\n        {\n            if (maxObjects >= (size_t)PdfParser::GetMaxObjectCount())\n                REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n            else\n                REQUIRE(error.GetCode() == PdfErrorCode::OutOfMemory);\n        }\n        catch (exception&)\n        {\n            FAIL(\"Wrong exception type\");\n        }\n    }\n\n    // CVE-2015-8981 happens because this->GetNextNumber() can return negative numbers \n    // in range (LONG_MIN to LONG_MAX) so the xref section below causes a buffer underflow\n    // because m_offsets[-5].bParsed is set to true when first entry is read\n    // NOTE: vector operator[] is not bounds checked\n\n    // xref\n    // -5 5\n    // 0000000000 65535 f \n    // 0000000018 00000 n \n    // 0000000077 00000 n \n    // 0000000178 00000 n \n    // 0000000457 00000 n \n    // trailer\n    // <<  /Root 1 0 R\n    //    /Size 5\n    //>>\n    // startxref\n    // 565\n    // %%EOF\n\n    try\n    {\n        string strInput = \"0000000000 65535 f\\r\\n\";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = -5LL;\n        objectCount = 5;\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE((error.GetCode() == PdfErrorCode::ValueOutOfRange || error.GetCode() == PdfErrorCode::NoXRef));\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2015-8981 can also happen due to integer overflow in firstObject+objectCount\n    // in the example below 2147483647=0x7FFF, so 0x7FFF + 0x7FFF = 0XFFFE = -2 on a 32-bit system\n    // which means m_offsets.size()=5 because m_offsets.resize() is never called and \n    // m_offsets[2147483647].bParsed is set to true when first entry is read\n    // NOTE: vector operator[] is not bounds checked\n\n    // 2147483647 2147483647 \n    // 0000000000 65535 f \n    // 0000000018 00000 n \n    // 0000000077 00000 n \n    // 0000000178 00000 n \n    // 0000000457 00000 n \n    // trailer\n    // <<  /Root 1 0 R\n    //    /Size 5\n    //>>\n    // startxref\n    // 565\n    // %%EOF\n\n    try\n    {\n        string strInput = \"0000000000 65535 f\\r\\n\";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = numeric_limits<unsigned>::max();\n        objectCount = numeric_limits<unsigned>::max();\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    try\n    {\n        string strInput = \"0000000000 65535 f\\r\\n\";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = numeric_limits<int64_t>::max();\n        objectCount = numeric_limits<int64_t>::max();\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::ValueOutOfRange);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // test for integer overflows in ReadXRefSubsection (CVE-2017-5853) which caused\n    // wrong buffer size to be calculated and then triggered buffer overflow (CVE-2017-6844)   \n    // the overflow checks in ReadXRefSubsection depend on the value returned by GetMaxObjectCount\n    // if the value changes these checks need looked at again\n    REQUIRE(PdfParser::GetMaxObjectCount() <= numeric_limits<unsigned>::max());\n\n    // test CVE-2017-5853 signed integer overflow in firstObject + objectCount\n    // CVE-2017-5853 1.1 - firstObject < 0\n    try\n    {\n        string strInput = \" \";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = -1LL;\n        objectCount = 1;\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::ValueOutOfRange);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2017-5853 1.2 - firstObject = min value of unsigned\n    try\n    {\n        string strInput = \" \";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = numeric_limits<unsigned>::min();\n        objectCount = 1;\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::UnexpectedEOF);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2017-5853 1.3 - firstObject = min value of int64_t\n    try\n    {\n        string strInput = \" \";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = numeric_limits<int64_t>::min();\n        objectCount = 1;\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::ValueOutOfRange);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2017-5853 1.4 - firstObject = min value of size_t is zero (size_t is unsigned)\n    // and zero is a valid value for firstObject\n\n    // CVE-2017-5853 1.5 - firstObject = max value of unsigned\n    try\n    {\n        string strInput = \" \";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = numeric_limits<unsigned>::max();\n        objectCount = 1;\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2017-5853 1.6 - firstObject = max value of int64_t\n    try\n    {\n        string strInput = \" \";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = numeric_limits<int64_t>::max();\n        objectCount = 1;\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::ValueOutOfRange);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2017-5853 1.7 - firstObject = max value of size_t\n    try\n    {\n        string strInput = \" \";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = numeric_limits<size_t>::max();\n        objectCount = 1;\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        // weird: different errors returned depending on architecture \n        REQUIRE((error.GetCode() == PdfErrorCode::ValueOutOfRange || sizeof(size_t) == 4));\n        REQUIRE((error.GetCode() == PdfErrorCode::InvalidXRef || sizeof(size_t) == 8));\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2017-5853 1.8 - firstObject = PdfParser::GetMaxObjectCount()\n    try\n    {\n        string strInput = \" \";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        REQUIRE(PdfParser::GetMaxObjectCount() > 0);\n        firstObject = PdfParser::GetMaxObjectCount();\n        objectCount = 1;\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2017-5853 2.1 - objectCount < 0\n    try\n    {\n        string strInput = \" \";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = 1;\n        objectCount = -1LL;\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::ValueOutOfRange);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2017-5853 2.2 - objectCount = min value of int\n    try\n    {\n        string strInput = \" \";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = 1;\n        objectCount = numeric_limits<int>::min();\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::ValueOutOfRange);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2017-5853 2.3 - objectCount = min value of int64_t\n    try\n    {\n        string strInput = \" \";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = 1;\n        objectCount = numeric_limits<int64_t>::min();\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::ValueOutOfRange);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2017-5853 2.4 - objectCount = min value of size_t is zero (size_t is unsigned)\n    // and zero is a valid value for firstObject\n    // TODO\n\n    // CVE-2017-5853 2.5 - objectCount = max value of unsigned\n    try\n    {\n        string strInput = \" \";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = 1;\n        objectCount = numeric_limits<unsigned>::max();\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2017-5853 2.6 - objectCount = max value of int64_t\n    try\n    {\n        string strInput = \" \";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = 1;\n        objectCount = numeric_limits<int64_t>::max();\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::ValueOutOfRange);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2017-5853 2.7 - objectCount = max value of size_t\n    try\n    {\n        string strInput = \" \";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = 1;\n        objectCount = numeric_limits<size_t>::max();\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        // weird: different errors returned depending on architecture \n        REQUIRE((error.GetCode() == PdfErrorCode::ValueOutOfRange || sizeof(size_t) == 4));\n        REQUIRE((error.GetCode() == PdfErrorCode::InvalidXRef || sizeof(size_t) == 8));\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2017-5853 2.8 - objectCount = PdfParser::GetMaxObjectCount()\n    try\n    {\n        string strInput = \" \";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        firstObject = 1;\n        objectCount = PdfParser::GetMaxObjectCount();\n        parser.ReadXRefSubsection(firstObject, objectCount);\n        FAIL(\"PdfError not thrown\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    // CVE-2017-5853 2.9 - finally - loop through a set of interesting bit patterns\n    static uint64_t s_values[] =\n    {\n        //(1ull << 64) - 1,\n        //(1ull << 64),\n        //(1ull << 64) + 1,\n        (1ull << 63) - 1,\n        (1ull << 63),\n        (1ull << 63) + 1,\n        (1ull << 62) - 1,\n        (1ull << 62),\n        (1ull << 62) + 1,\n\n        (1ull << 49) - 1,\n        (1ull << 49),\n        (1ull << 49) + 1,\n        (1ull << 48) - 1,\n        (1ull << 48),\n        (1ull << 48) + 1,\n        (1ull << 47) - 1,\n        (1ull << 47),\n        (1ull << 47) + 1,\n\n        (1ull << 33) - 1,\n        (1ull << 33),\n        (1ull << 33) + 1,\n        (1ull << 32) - 1,\n        (1ull << 32),\n        (1ull << 32) + 1,\n        (1ull << 31) - 1,\n        (1ull << 31),\n        (1ull << 31) + 1,\n\n        (1ull << 25) - 1,\n        (1ull << 33),\n        (1ull << 33) + 1,\n        (1ull << 24) - 1,\n        (1ull << 24),\n        (1ull << 24) + 1,\n        (1ull << 31) - 1,\n        (1ull << 31),\n        (1ull << 31) + 1,\n\n        (1ull << 17) - 1,\n        (1ull << 17),\n        (1ull << 17) + 1,\n        (1ull << 16) - 1,\n        (1ull << 16),\n        (1ull << 16) + 1,\n        (1ull << 15) - 1,\n        (1ull << 15),\n        (1ull << 15) + 1,\n\n        (uint64_t)-1,\n        0,\n        1\n    };\n    constexpr size_t numValues = sizeof(s_values) / sizeof(s_values[0]);\n\n    for (size_t i = 0; i < numValues; i++)\n    {\n        for (size_t j = 0; j < numValues; j++)\n        {\n            try\n            {\n                string strInput = \" \";\n                PdfIndirectObjectList objects;\n                PdfParserTest parser(objects, strInput);\n                firstObject = s_values[i];\n                objectCount = s_values[j];\n\n                if (canOutOfMemoryKillUnitTests() && (firstObject > maxNumberOfIndirectObjects || objectCount > maxNumberOfIndirectObjects))\n                {\n                    // can't call this in test environments where an out-of-memory condition terminates\n                    // unit test process before all tests have run (e.g. AddressSanitizer)\n                }\n                else\n                {\n                    parser.ReadXRefSubsection(firstObject, objectCount);\n                    // some combinations of firstObject/objectCount from s_values are legal - so we expect to reach here sometimes\n                }\n            }\n            catch (PdfError& error)\n            {\n                // other combinations of firstObject/objectCount from s_values are illegal \n                // if we reach here it should be an invalid xref value of some type\n                REQUIRE((error.GetCode() == PdfErrorCode::InvalidXRef || error.GetCode() == PdfErrorCode::ValueOutOfRange\n                    || error.GetCode() == PdfErrorCode::UnexpectedEOF\n                    || error.GetCode() == PdfErrorCode::OutOfMemory));\n            }\n            catch (exception&)\n            {\n                // and should never reach here\n                FAIL(\"Wrong exception type\");\n            }\n        }\n    }\n}\n\nTEST_CASE(\"TestReadXRefStreamContents\")\n{\n    // test valid stream\n    try\n    {\n        // generate an XRef stream with valid /W values\n        ostringstream oss;\n        size_t offsetStream;\n        size_t offsetEndstream;\n\n        // XRef stream with 5 entries\n        size_t lengthXRefObject = 58;\n        size_t offsetXRefObject = oss.str().length();\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [2 2] \";\n        oss << \"/Size 5 \";\n        oss << \"/W [1 2 1] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"01 0E8A 00\\r\\n\";\n        oss << \"02 0002 00\\r\\n\";\n        oss << \"02 0002 01\\r\\n\";\n        oss << \"02 0002 02\\r\\n\";\n        oss << \"02 0002 03\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // hard-coded in /Length entry in XRef stream above\n\n        // trailer\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%%EOF\";\n\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, oss.str());\n        parser.ReadXRefStreamContents(offsetXRefObject, false);\n        // should succeed\n    }\n    catch (PdfError&)\n    {\n        FAIL(\"Unexpected PdfError\");\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    // CVE-2018-5295: integer overflow caused by checking sum of /W entry values /W [ 1 2 9223372036854775807 ]\n    // see https://bugzilla.redhat.com/show_bug.cgi?id=1531897 (/W values used were extracted from PoC file)\n    try\n    {\n        ostringstream oss;\n        size_t offsetStream;\n        size_t offsetEndstream;\n\n        // XRef stream\n        size_t lengthXRefObject = 58;\n        size_t offsetXRefObject = 10;\n        oss << \"%PDF-1.4\\r\\n\";\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [2 2] \";\n        oss << \"/Size 5 \";\n        oss << \"/W [ 1 2 9223372036854775807 ] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"01 0E8A 00\\r\\n\";\n        oss << \"02 0002 00\\r\\n\";\n        oss << \"02 0002 01\\r\\n\";\n        oss << \"02 0002 02\\r\\n\";\n        oss << \"02 0002 03\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // check /Length entry in XRef stream above\n\n        // trailer\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%%EOF\";\n\n        auto inputStr = oss.str();\n        PdfXRefEntries offsets;\n        auto device = std::make_shared<SpanStreamDevice>(inputStr);\n        PdfMemDocument doc;\n        // Parse a doc using XRef stream with invalid /W entries\n        doc.LoadFromDevice(device);\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRefStream);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    // CVE-2017-8787: heap based overflow caused by unchecked /W entry values /W [ 1 -4 2 ]\n    // see https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=861738 for value of /W array\n    try\n    {\n        ostringstream oss;\n        size_t offsetStream;\n        size_t offsetEndstream;\n\n        // XRef stream\n        size_t lengthXRefObject = 58;\n        size_t offsetXRefObject = 10;\n        oss << \"%PDF-1.4\\r\\n\";\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [2 2] \";\n        oss << \"/Size 5 \";\n        oss << \"/W [ 1 -4 2 ] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"01 0E8A 00\\r\\n\";\n        oss << \"02 0002 00\\r\\n\";\n        oss << \"02 0002 01\\r\\n\";\n        oss << \"02 0002 02\\r\\n\";\n        oss << \"02 0002 03\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // check /Length entry in XRef stream above\n\n        // trailer\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%%EOF\";\n\n        auto inputStr = oss.str();\n        PdfXRefEntries offsets;\n        auto device = std::make_shared<SpanStreamDevice>(inputStr);\n        PdfMemDocument doc;\n        // Parse a doc using XRef stream with invalid /W entries\n        doc.LoadFromDevice(device);\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRefStream);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    // /W entry values /W [ 4095 1 1 ] for data in form 02 0002 00 (doesn't match size of entry)\n    try\n    {\n        ostringstream oss;\n        size_t offsetStream;\n        size_t offsetEndstream;\n\n        // XRef stream\n        size_t lengthXRefObject = 58;\n        size_t offsetXRefObject = 10;\n        oss << \"%PDF-1.4\\r\\n\";\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [2 2] \";\n        oss << \"/Size 5 \";\n        oss << \"/W [ 4095 1 1 ] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"01 0E8A 00\\r\\n\";\n        oss << \"02 0002 00\\r\\n\";\n        oss << \"02 0002 01\\r\\n\";\n        oss << \"02 0002 02\\r\\n\";\n        oss << \"02 0002 03\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE((offsetEndstream - offsetStream - strlen(\"\\r\\n\")) == lengthXRefObject); // check /Length entry in XRef stream above\n\n        // trailer\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%%EOF\";\n\n        auto inputStr = oss.str();\n        PdfXRefEntries offsets;\n        auto device = std::make_shared<SpanStreamDevice>(inputStr);\n        PdfMemDocument doc;\n        // Parse a doc using XRef stream with invalid /W entries\n        doc.LoadFromDevice(device);\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRefStream);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    // /W entry values /W [ 4 4 4 ] for data in form 02 0002 00 (doesn't match size of entry)\n    try\n    {\n        ostringstream oss;\n        size_t offsetStream;\n        size_t offsetEndstream;\n\n        // XRef stream\n        size_t lengthXRefObject = 58;\n        size_t offsetXRefObject = 10;\n        oss << \"%PDF-1.4\\r\\n\";\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [2 2] \";\n        oss << \"/Size 5 \";\n        oss << \"/W [ 4 4 4 ] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"01 0E8A 00\\r\\n\";\n        oss << \"02 0002 00\\r\\n\";\n        oss << \"02 0002 01\\r\\n\";\n        oss << \"02 0002 02\\r\\n\";\n        oss << \"02 0002 03\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // check /Length entry in XRef stream above\n\n        // trailer\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%%EOF\";\n\n        auto inputStr = oss.str();\n        PdfXRefEntries offsets;\n        auto device = std::make_shared<SpanStreamDevice>(inputStr);\n        PdfMemDocument doc;\n        // Parse a doc using XRef stream with invalid /W entries\n        doc.LoadFromDevice(device);\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRefStream);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    // /W entry values /W [ 1 4 4 ] (size=9) for data 01 0E8A 0\\r\\n02 0002 00\\r\\n (size=8 bytes)\n    try\n    {\n        ostringstream oss;\n        size_t offsetStream;\n        size_t offsetEndstream;\n\n        // XRef stream\n        size_t lengthXRefObject = 22;\n        size_t offsetXRefObject = 10;\n        oss << \"%PDF-1.4\\r\\n\";\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [2 2] \";\n        oss << \"/Size 2 \";\n        oss << \"/W [ 1 4 4 ] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"01 0E8A 00\\r\\n\";\n        oss << \"02 0002 00\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // check /Length entry in XRef stream above\n\n        // trailer\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%%EOF\";\n\n        auto inputStr = oss.str();\n        PdfXRefEntries offsets;\n        auto device = std::make_shared<SpanStreamDevice>(inputStr);\n        PdfMemDocument doc;\n        // Parse a doc using XRef stream with invalid /W entries\n        doc.LoadFromDevice(device);\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRefStream);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    try\n    {\n        ostringstream oss;\n        size_t offsetStream;\n        size_t offsetEndstream;\n\n        size_t lengthXRefObject = 22;\n        size_t offsetXRefObject = 34;\n        oss << \"%PDF-1.4\\r\\n\";\n        oss << \"1 0 obj\\r\\n\";\n        oss << \"<< >>\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        oss << \"2 0 obj\\r\\n\";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [1 2] \";\n        oss << \"/Root 1 0 R \";\n        oss << \"/Size 3 \";\n        oss << \"/W [1 2 1] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"01 000A 00\\r\\n\";\n        oss << \"01 001A 00\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // hard-coded in /Length entry in XRef stream above\n\n        // trailer\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%%EOF\";\n\n        auto inputStr = oss.str();\n        PdfXRefEntries offsets;\n        auto device = std::make_shared<SpanStreamDevice>(inputStr);\n        PdfMemDocument doc;\n        doc.LoadFromDevice(device);\n    }\n    catch (PdfError&)\n    {\n        FAIL(\"Unexpected PdfError\");\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    // XRef stream with 5 entries but /Size 2 specified\n    try\n    {\n        ostringstream oss;\n        size_t offsetStream;\n        size_t offsetEndstream;\n\n        size_t lengthXRefObject = 58;\n        size_t offsetXRefObject = 10;\n        oss << \"%PDF-1.4\\r\\n\";\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [2 2] \";\n        oss << \"/Size 10 \";\n        oss << \"/W [1 2 1] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"01 0E8A 00\\r\\n\";\n        oss << \"01 0002 00\\r\\n\";\n        oss << \"01 0002 01\\r\\n\";\n        oss << \"01 0002 02\\r\\n\";\n        oss << \"01 0002 03\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // hard-coded in /Length entry in XRef stream above\n\n        // trailer\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%%EOF\";\n\n        auto inputStr = oss.str();\n        PdfXRefEntries offsets;\n        auto device = std::make_shared<SpanStreamDevice>(inputStr);\n        PdfMemDocument doc;\n        doc.LoadFromDevice(device);\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        (void)error;\n        // FIXME We should throw on exact error\n        //REQUIRE(error.GetError() == PdfErrorCode::NoXRef);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    // XRef stream with 5 entries but /Size 10 specified\n    try\n    {\n        ostringstream oss;\n        size_t offsetStream;\n        size_t offsetEndstream;\n\n        size_t lengthXRefObject = 58;\n        size_t offsetXRefObject = 10;\n        oss << \"%PDF-1.4\\r\\n\";\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [2 2] \";\n        oss << \"/Size 10 \";\n        oss << \"/W [1 2 1] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"01 0E8A 00\\r\\n\";\n        oss << \"01 0002 00\\r\\n\";\n        oss << \"01 0002 01\\r\\n\";\n        oss << \"01 0002 02\\r\\n\";\n        oss << \"01 0002 03\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // hard-coded in /Length entry in XRef stream above\n\n        // trailer\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%%EOF\";\n\n        auto inputStr = oss.str();\n        PdfXRefEntries offsets;\n        auto device = std::make_shared<SpanStreamDevice>(inputStr);\n        PdfMemDocument doc;\n        doc.LoadFromDevice(device);\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        (void)error;\n        // FIXME We should throw on exact error\n        //REQUIRE(error.GetError() == PdfErrorCode::NoXRef);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    // XRef stream with /Index [0 0] array\n    try\n    {\n        ostringstream oss;\n        size_t offsetStream;\n        size_t offsetEndstream;\n\n        size_t lengthXRefObject = 58;\n        size_t offsetXRefObject = 10;\n        oss << \"%PDF-1.4\\r\\n\";\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [0 0] \";\n        oss << \"/Size 5 \";\n        oss << \"/W [1 2 1] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"01 0E8A 00\\r\\n\";\n        oss << \"02 0002 00\\r\\n\";\n        oss << \"02 0002 01\\r\\n\";\n        oss << \"02 0002 02\\r\\n\";\n        oss << \"02 0002 03\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // hard-coded in /Length entry in XRef stream above\n\n        // trailer\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%%EOF\";\n\n        auto inputStr = oss.str();\n        PdfXRefEntries offsets;\n        auto device = std::make_shared<SpanStreamDevice>(inputStr);\n        PdfMemDocument doc;\n        doc.LoadFromDevice(device);\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        (void)error;\n        // FIXME We should throw on exact error\n        //REQUIRE(error.GetError() == PdfErrorCode::NoXRef);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    // XRef stream with /Index [-1 -1] array\n    try\n    {\n        ostringstream oss;\n        size_t offsetStream;\n        size_t offsetEndstream;\n\n        size_t lengthXRefObject = 58;\n        size_t offsetXRefObject = 10;\n        oss << \"%PDF-1.4\\r\\n\";\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [-1 -1] \";\n        oss << \"/Size 5 \";\n        oss << \"/W [1 2 1] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"01 0E8A 00\\r\\n\";\n        oss << \"02 0002 00\\r\\n\";\n        oss << \"02 0002 01\\r\\n\";\n        oss << \"02 0002 02\\r\\n\";\n        oss << \"02 0002 03\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // hard-coded in /Length entry in XRef stream above\n\n        // trailer\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%%EOF\";\n\n        auto inputStr = oss.str();\n        PdfXRefEntries offsets;\n        auto device = std::make_shared<SpanStreamDevice>(inputStr);\n        PdfMemDocument doc;\n        doc.LoadFromDevice(device);\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        (void)error;\n        // FIXME We should throw on exact error\n        //REQUIRE(error.GetError() == PdfErrorCode::NoXRef);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    // XRef stream with /Index array with no entries\n    try\n    {\n        ostringstream oss;\n        size_t offsetStream;\n        size_t offsetEndstream;\n\n        size_t lengthXRefObject = 58;\n        size_t offsetXRefObject = 10;\n        oss << \"%PDF-1.4\\r\\n\";\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [ ] \";\n        oss << \"/Size 5 \";\n        oss << \"/W [1 2 1] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"01 0E8A 00\\r\\n\";\n        oss << \"02 0002 00\\r\\n\";\n        oss << \"02 0002 01\\r\\n\";\n        oss << \"02 0002 02\\r\\n\";\n        oss << \"02 0002 03\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // hard-coded in /Length entry in XRef stream above\n\n        // trailer\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%%EOF\";\n\n        auto inputStr = oss.str();\n        PdfXRefEntries offsets;\n        auto device = std::make_shared<SpanStreamDevice>(inputStr);\n        PdfMemDocument doc;\n        doc.LoadFromDevice(device);\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        (void)error;\n        // FIXME We should throw on exact error\n        //REQUIRE(error.GetError() == PdfErrorCode::NoXRef);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    // XRef stream with /Index array with 3 entries\n    try\n    {\n        ostringstream oss;\n        size_t offsetStream;\n        size_t offsetEndstream;\n\n        size_t lengthXRefObject = 58;\n        size_t offsetXRefObject = 10;\n        oss << \"%PDF-1.4\\r\\n\";\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [2 2 2] \";\n        oss << \"/Size 5 \";\n        oss << \"/W [1 2 1] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"01 0E8A 00\\r\\n\";\n        oss << \"02 0002 00\\r\\n\";\n        oss << \"02 0002 01\\r\\n\";\n        oss << \"02 0002 02\\r\\n\";\n        oss << \"02 0002 03\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // hard-coded in /Length entry in XRef stream above\n\n        // trailer\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%%EOF\";\n\n        auto inputStr = oss.str();\n        PdfXRefEntries offsets;\n        auto device = std::make_shared<SpanStreamDevice>(inputStr);\n        PdfMemDocument doc;\n        doc.LoadFromDevice(device);\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRefStream);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n\n    // XRef stream with /Index array with 22 entries\n    try\n    {\n        ostringstream oss;\n        size_t offsetStream;\n        size_t offsetEndstream;\n\n        size_t lengthXRefObject = 58;\n        size_t offsetXRefObject = 10;\n        oss << \"%PDF-1.4\\r\\n\";\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22] \";\n        oss << \"/Size 5 \";\n        oss << \"/W [1 2 1] \";\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"00 0000 00\\r\\n\";\n        oss << \"00 0000 00\\r\\n\";\n        oss << \"00 0000 00\\r\\n\";\n        oss << \"00 0000 00\\r\\n\";\n        oss << \"00 0000 00\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // hard-coded in /Length entry in XRef stream above\n\n        // trailer\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%%EOF\";\n\n        auto inputStr = oss.str();\n        PdfXRefEntries offsets;\n        auto device = std::make_shared<SpanStreamDevice>(inputStr);\n        PdfMemDocument doc;\n        doc.LoadFromDevice(device);\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRefStream);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n}\n\nTEST_CASE(\"testReadObjects\")\n{\n    // CVE-2017-8378 - m_offsets out-of-bounds access when referenced encryption dictionary object doesn't exist\n    try\n    {\n        ostringstream oss;\n        oss << \"%PDF-1.0\\r\\n\";\n        oss << \"xref\\r\\n0 3\\r\\n\";\n        oss << generateXRefEntries(3);\n        oss << \"trailer << /Root 1 0 R /Size 3 /Encrypt 3 0 R >>\\r\\n\";\n        oss << \"startxref 0\\r\\n\";\n        oss << \"%%EOF\";\n        PdfIndirectObjectList objects;\n        auto docbuff = oss.str();\n        PdfParserTest parser(objects, docbuff);\n        parser.ReadDocumentStructure();\n        parser.ReadObjects();\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidEncryptionDict);\n    }\n    catch (exception&)\n    {\n        FAIL(\"Unexpected exception type\");\n    }\n}\n\nTEST_CASE(\"testIsPdfFile\")\n{\n    try\n    {\n        string strInput = \"%PDF-1.0\";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        REQUIRE(parser.IsPdfFile());\n    }\n    catch (PdfError&)\n    {\n        FAIL(\"Unexpected PdfError\");\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    try\n    {\n        string strInput = \"%PDF-1.1\";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        REQUIRE(parser.IsPdfFile());\n    }\n    catch (PdfError&)\n    {\n        FAIL(\"Unexpected PdfError\");\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    try\n    {\n        string strInput = \"%PDF-1.7\";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        REQUIRE(parser.IsPdfFile());\n    }\n    catch (PdfError&)\n    {\n        FAIL(\"Unexpected PdfError\");\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    try\n    {\n        string strInput = \"%PDF-1.9\";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        REQUIRE(!parser.IsPdfFile());\n    }\n    catch (PdfError&)\n    {\n        FAIL(\"Unexpected PdfError\");\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    try\n    {\n        string strInput = \"%PDF-2.0\";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        REQUIRE(parser.IsPdfFile());\n    }\n    catch (PdfError&)\n    {\n        FAIL(\"Unexpected PdfError\");\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    try\n    {\n        string strInput = \"%!PS-Adobe-2.0\";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        REQUIRE(!parser.IsPdfFile());\n    }\n    catch (PdfError&)\n    {\n        FAIL(\"Unexpected PdfError\");\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n\n    try\n    {\n        string strInput = \"GIF89a\";\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, strInput);\n        REQUIRE(!parser.IsPdfFile());\n    }\n    catch (PdfError&)\n    {\n        FAIL(\"Unexpected PdfError\");\n    }\n    catch (exception&)\n    {\n        FAIL(\"Wrong exception type\");\n    }\n}\n\nTEST_CASE(\"testSaveIncrementalRoundTrip\")\n{\n    ostringstream oss;\n    oss << \"%PDF-1.1\\n\";\n    unsigned currObj = 1;\n    streamoff objPos[20];\n\n    // Pages\n\n    unsigned pagesObj = currObj;\n    objPos[currObj] = oss.tellp();\n    oss << currObj++ << \" 0 obj\\n\";\n    oss << \"<</Type /Pages /Count 0 /Kids []>>\\n\";\n    oss << \"endobj\\n\";\n\n    // Root catalog\n\n    unsigned rootObj = currObj;\n    objPos[currObj] = oss.tellp();\n    oss << currObj++ << \" 0 obj\\n\";\n    oss << \"<</Type /Catalog /Pages \" << pagesObj << \" 0 R>>\\n\";\n    oss << \"endobj\\n\";\n\n    // ID\n    unsigned idObj = currObj;\n    objPos[currObj] = oss.tellp();\n    oss << currObj++ << \" 0 obj\\n\";\n    oss << \"[<F1E375363A6314E3766EDF396D614748> <F1E375363A6314E3766EDF396D614748>]\\n\";\n    oss << \"endobj\\n\";\n\n    streamoff xrefPos = oss.tellp();\n    oss << \"xref\\n\";\n    oss << \"0 \" << currObj << \"\\n\";\n    oss << \"0000000000 65535 f \\n\";\n    for (unsigned i = 1; i < currObj; i++)\n        oss << utls::Format(\"{:010d} 00000 n \\n\", objPos[i]);\n\n    oss << \"trailer <<\\n\"\n        << \"  /Size \" << currObj << \"\\n\"\n        << \"  /Root \" << rootObj << \" 0 R\\n\"\n        << \"  /ID \" << idObj << \" 0 R\\n\" // indirect ID\n        << \">>\\n\"\n        << \"startxref\\n\"\n        << xrefPos << \"\\n\"\n        << \"%%EOF\\n\";\n\n    string docBuff = oss.str();\n    try\n    {\n        PdfMemDocument doc;\n        // load for update\n        doc.LoadFromBuffer(docBuff);\n\n        StringStreamDevice outDev(docBuff);\n\n        doc.SaveUpdate(outDev);\n        doc.LoadFromBuffer(docBuff);\n    }\n    catch (PdfError&)\n    {\n        FAIL(\"Unexpected PdfError\");\n    }\n}\n\n// CVE-2018-8002, CVE-2021-30470\nTEST_CASE(\"testNestedArrays\")\n{\n    // test valid stream\n    // generate an XRef stream with no deeply nested arrays\n    ostringstream oss;\n    size_t offsetStream;\n    size_t offsetEndstream;\n    size_t offsetXRefObject;\n    string buffer;\n\n    // XRef stream with 5 entries\n    constexpr size_t lengthXRefObject = 58;\n\n    offsetXRefObject = oss.str().length();\n    oss << \"2 0 obj \";\n    oss << \"<< /Type /XRef \";\n    oss << \"/Length \" << lengthXRefObject << \" \";\n    oss << \"/Index [2 2] \";\n    oss << \"/Size 5 \";\n    oss << \"/W [1 2 1] \";\n    oss << \"/Filter /ASCIIHexDecode \";\n    oss << \">>\\r\\n\";\n    oss << \"stream\\r\\n\";\n    offsetStream = oss.str().length();\n    oss << \"01 0E8A 00\\r\\n\";\n    oss << \"02 0002 00\\r\\n\";\n    oss << \"02 0002 01\\r\\n\";\n    oss << \"02 0002 02\\r\\n\";\n    oss << \"02 0002 03\\r\\n\";\n    offsetEndstream = oss.str().length();\n    oss << \"endstream\\r\\n\";\n    oss << \"endobj\\r\\n\";\n    REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // hard-coded in /Length entry in XRef stream above\n\n    // trailer\n    oss << \"trailer << /Root 1 0 R /Size 3 >>\\r\\n\";\n    oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n    oss << \"%EOF\";\n\n    buffer = oss.str();\n\n    {\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, buffer);\n        parser.ReadXRefStreamContents(offsetXRefObject, false);\n        REQUIRE(true);\n    }\n\n    // CVE-2021-30470 - lots of [[[[[]]]]] brackets represent nested arrays which caused stack overflow\n    try\n    {\n        // generate an XRef stream with deeply nested arrays\n        oss.str(\"\");\n        const size_t maxNesting = getStackOverflowDepth(); // big enough to cause stack overflow\n        // XRef stream with 5 entries\n        offsetXRefObject = oss.str().length();\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [2 2] \";\n        oss << \"/Size 5 \";\n        oss << \"/W [1 2 1] \";\n        \n        // output [[[[[[[[[[[0]]]]]]]]]]]\n        for (size_t i = 0; i < maxNesting; i++)\n        {\n            oss << \"[\";\n        }\n        oss << \"0\";\n        for (size_t i = 0; i < maxNesting; i++)\n        {\n            oss << \"]\";\n        }\n        oss << \" \";\n\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"01 0E8A 00\\r\\n\";\n        oss << \"02 0002 00\\r\\n\";\n        oss << \"02 0002 01\\r\\n\";\n        oss << \"02 0002 02\\r\\n\";\n        oss << \"02 0002 03\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // hard-coded in /Length entry in XRef stream above\n\n        // trailer\n        oss << \"trailer << /Root 1 0 R /Size 3 >>\\r\\n\";\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%EOF\";\n\n        buffer = oss.str();\n\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, buffer);\n        parser.ReadXRefStreamContents(offsetXRefObject, false);\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        // this must match the error value thrown by PdfRecursionGuard\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n    }\n}\n\n// CVE-2018-8002, CVE-2021-30470\nTEST_CASE(\"testNestedDictionaries\")\n{\n    // test valid stream\n    // generate an XRef stream with no deeply nested dictionaries\n    ostringstream oss;\n    size_t offsetStream;\n    size_t offsetEndstream;\n    size_t offsetXRefObject;\n    string buffer;\n\n    // XRef stream with 5 entries\n    constexpr size_t lengthXRefObject = 58;\n\n    offsetXRefObject = oss.str().length();\n    oss << \"2 0 obj \";\n    oss << \"<< /Type /XRef \";\n    oss << \"/Length \" << lengthXRefObject << \" \";\n    oss << \"/Index [2 2] \";\n    oss << \"/Size 5 \";\n    oss << \"/W [1 2 1] \";\n    oss << \"/Filter /ASCIIHexDecode \";\n    oss << \">>\\r\\n\";\n    oss << \"stream\\r\\n\";\n    offsetStream = oss.str().length();\n    oss << \"01 0E8A 00\\r\\n\";\n    oss << \"02 0002 00\\r\\n\";\n    oss << \"02 0002 01\\r\\n\";\n    oss << \"02 0002 02\\r\\n\";\n    oss << \"02 0002 03\\r\\n\";\n    offsetEndstream = oss.str().length();\n    oss << \"endstream\\r\\n\";\n    oss << \"endobj\\r\\n\";\n    REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // hard-coded in /Length entry in XRef stream above\n\n    // trailer\n    oss << \"trailer << /Root 1 0 R /Size 3 >>\\r\\n\";\n    oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n    oss << \"%EOF\";\n\n    buffer = oss.str();\n\n    {\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, buffer);\n        parser.ReadXRefStreamContents(offsetXRefObject, false);\n        REQUIRE(true);\n    }\n\n    // CVE-2021-30470 - lots of <<<>>> brackets represent nested dictionaries which caused stack overflow\n    try\n    {\n        // generate an XRef stream with deeply nested dictionaries\n        oss.str(\"\");\n\n        const size_t maxNesting = getStackOverflowDepth(); // big enough to cause stack overflow \n        // XRef stream with 5 entries\n        offsetXRefObject = oss.str().length();\n        oss << \"2 0 obj \";\n        oss << \"<< /Type /XRef \";\n        oss << \"/Length \" << lengthXRefObject << \" \";\n        oss << \"/Index [2 2] \";\n        oss << \"/Size 5 \";\n        oss << \"/W [1 2 1] \";\n\n        // output << << << /Test 0 >> >> >>\n        for (size_t i = 0; i < maxNesting; i++)\n        {\n            oss << \"<< \";\n        }\n        oss << \" /Test 0\";\n        for (size_t i = 0; i < maxNesting; i++)\n        {\n            oss << \" >>\";\n        }\n        oss << \" \";\n\n        oss << \"/Filter /ASCIIHexDecode \";\n        oss << \">>\\r\\n\";\n        oss << \"stream\\r\\n\";\n        offsetStream = oss.str().length();\n        oss << \"01 0E8A 00\\r\\n\";\n        oss << \"02 0002 00\\r\\n\";\n        oss << \"02 0002 01\\r\\n\";\n        oss << \"02 0002 02\\r\\n\";\n        oss << \"02 0002 03\\r\\n\";\n        offsetEndstream = oss.str().length();\n        oss << \"endstream\\r\\n\";\n        oss << \"endobj\\r\\n\";\n        REQUIRE(offsetEndstream - offsetStream - strlen(\"\\r\\n\") == lengthXRefObject); // hard-coded in /Length entry in XRef stream above\n\n        // trailer\n        oss << \"trailer << /Root 1 0 R /Size 3 >>\\r\\n\";\n        oss << \"startxref \" << offsetXRefObject << \"\\r\\n\";\n        oss << \"%EOF\";\n\n        buffer = oss.str();\n\n        PdfIndirectObjectList objects;\n        PdfParserTest parser(objects, buffer);\n        parser.ReadXRefStreamContents(offsetXRefObject, false);\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        // this must match the error value thrown by PdfRecursionGuard\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n    }\n}\n\n// CVE-2021-30471\nTEST_CASE(\"testNestedNameTree\")\n{\n    // test for valid but deeply nested name tree\n    // maxDepth must be less than GetMaxObjectCount otherwise PdfParser::ResizeOffsets\n    // throws an error when reading the xref offsets table, and no outlines are read\n    ostringstream oss;\n    const size_t maxDepth = getStackOverflowDepth() - 6 - 1;\n    const size_t numObjects = maxDepth + 6;\n    vector<size_t> offsets(numObjects);\n    size_t xrefOffset = 0;\n\n    offsets[0] = 0;\n    oss << \"%PDF-1.0\\r\\n\";\n\n    offsets[1] = oss.tellp();\n    oss << \"1 0 obj<</Type/Catalog /Pages 2 0 R /Names 4 0 R>>endobj \";\n\n    offsets[2] = oss.tellp();\n    oss << \"2 0 obj<</Type/Pages/Kids[3 0 R]/Count 1>>endobj \";\n\n    offsets[3] = oss.tellp();\n    oss << \"3 0 obj<</Type/Page/MediaBox[0 0 3 3]>>endobj \";\n\n    // the name dictionary\n    offsets[4] = oss.tellp();\n    oss << \"4 0 obj<</Dests 5 0 R>>endobj \";\n\n    // root of /Dests name tree\n    offsets[5] = oss.tellp();\n    oss << \"5 0 obj<</Kids [6 0 R]>>endobj \";\n\n    // create name tree nested to maxDepth where each intermediate node has one child\n    // except single leaf node at maxDepth\n    for (size_t objNo = 6; objNo < numObjects; objNo++)\n    {\n        offsets[objNo] = oss.tellp();\n\n        if (objNo < numObjects - 1)\n            oss << objNo << \" 0 obj<</Kids [\" << objNo + 1 << \" 0 R] /Limits [(A) (Z)]>>endobj \";\n        else\n            oss << objNo << \" 0 obj<</Limits [(A) (Z)] /Names [ (A) (Avalue) (Z) (Zvalue) ] >>endobj \";\n    }\n\n    // output xref table\n    oss << \"\\r\\n\";\n    xrefOffset = oss.tellp();\n    oss << \"xref\\r\\n\";\n    oss << \"0 \" << numObjects << \"\\r\\n\";\n\n    oss << \"0000000000 65535 f\\r\\n\";\n\n    for (size_t objNo = 1; objNo < offsets.size(); objNo++)\n    {\n        // write xref entries like\n        // \"0000000010 00000 n\\r\\n\"\n        char refEntry[21];\n        snprintf(refEntry, 21, \"%010zu 00000 n\\r\\n\", offsets[objNo]);\n\n        oss << refEntry;\n    }\n\n    oss << \"trailer<</Size \" << numObjects << \"/Root 1 0 R>>\\r\\n\";\n    oss << \"startxref\\r\\n\";\n    oss << xrefOffset << \"\\r\\n\";\n    oss << \"%%EOF\";\n\n    auto buffer = oss.str();\n\n    try\n    {\n        PdfMemDocument doc;\n        doc.LoadFromBuffer(buffer);\n\n        auto names = doc.GetNames();\n        if (names != nullptr)\n        {\n            PdfDictionary dict;\n            names->ToDictionary(\"Dests\", dict);\n        }\n\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        // this must match the error value thrown by PdfRecursionGuard\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n    }\n}\n\n// CVE-2021-30471\nTEST_CASE(\"testLoopingNameTree\")\n{\n    string strNoLoop =\n        \"%PDF-1.0\\r\\n\"\n        \"1 0 obj<</Type/Catalog/Pages 2 0 R /Names 4 0 R>>endobj 2 0 obj<</Type/Pages/Kids[3 0 R]/Count 1>>endobj 3 0 obj<</Type/Page/MediaBox[0 0 3 3]>>endobj 4 0 obj<</Dests 2 0 R>>endobj\\r\\n\"\n        \"xref\\r\\n\"\n        \"0 5\\r\\n\"\n        \"0000000000 65535 f\\r\\n\"\n        \"0000000010 00000 n\\r\\n\"\n        \"0000000066 00000 n\\r\\n\"\n        \"0000000115 00000 n\\r\\n\"\n        \"0000000161 00000 n\\r\\n\"\n        \"trailer<</Size 4/Root 1 0 R>>\\r\\n\"\n        \"startxref\\r\\n\"\n        \"192\\r\\n\"\n        \"%%EOF\";\n\n    {\n        PdfMemDocument doc;\n        doc.LoadFromBuffer(strNoLoop);\n\n        auto names = doc.GetNames();\n        if (names != nullptr)\n        {\n            PdfDictionary dict;\n            names->ToDictionary(\"Dests\", dict);\n        }\n    }\n\n    // CVE-2021-30471 /Dests points at pages tree root which has a /Kids entry loooping back to pages tree root\n    string strSelfLoop =\n        \"%PDF-1.0\\r\\n\"\n        \"1 0 obj<</Type/Catalog/Pages 2 0 R /Names 4 0 R>>endobj 2 0 obj<</Type/Pages/Kids[2 0 R]/Count 1>>endobj 3 0 obj<</Type/Page/MediaBox[0 0 3 3]>>endobj 4 0 obj<</Dests 2 0 R>>endobj\\r\\n\"\n        \"xref\\r\\n\"\n        \"0 5\\r\\n\"\n        \"0000000000 65535 f\\r\\n\"\n        \"0000000010 00000 n\\r\\n\"\n        \"0000000066 00000 n\\r\\n\"\n        \"0000000115 00000 n\\r\\n\"\n        \"0000000161 00000 n\\r\\n\"\n        \"trailer<</Size 4/Root 1 0 R>>\\r\\n\"\n        \"startxref\\r\\n\"\n        \"192\\r\\n\"\n        \"%%EOF\";\n\n    try\n    {\n        PdfMemDocument doc;\n        doc.LoadFromBuffer(strSelfLoop);\n\n        auto names = doc.GetNames();\n        if (names != nullptr)\n        {\n            PdfDictionary dict;\n            names->ToDictionary(\"Dests\", dict);\n        }\n\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        // this must match the error value thrown by PdfRecursionGuard\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n    }\n\n    // CVE-2021-30471 /Dests points at pages tree which has a /Kids entry loooping back to ancestor (document root)\n    string strAncestorLoop =\n        \"%PDF-1.0\\r\\n\"\n        \"1 0 obj<</Type/Catalog/Pages 2 0 R /Names 4 0 R>>endobj 2 0 obj<</Type/Pages/Kids[1 0 R]/Count 1>>endobj 3 0 obj<</Type/Page/MediaBox[0 0 3 3]>>endobj 4 0 obj<</Dests 2 0 R>>endobj\\r\\n\"\n        \"xref\\r\\n\"\n        \"0 5\\r\\n\"\n        \"0000000000 65535 f\\r\\n\"\n        \"0000000010 00000 n\\r\\n\"\n        \"0000000066 00000 n\\r\\n\"\n        \"0000000115 00000 n\\r\\n\"\n        \"0000000161 00000 n\\r\\n\"\n        \"trailer<</Size 4/Root 1 0 R>>\\r\\n\"\n        \"startxref\\r\\n\"\n        \"192\\r\\n\"\n        \"%%EOF\";\n\n    try\n    {\n        PdfMemDocument doc;\n        doc.LoadFromBuffer(strAncestorLoop);\n\n        auto names = doc.GetNames();\n        if (names != nullptr)\n        {\n            PdfDictionary dict;\n            names->ToDictionary(\"Dests\", dict);\n        }\n\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidDataType);\n    }\n}\n\n// CVE-2021-30471\nTEST_CASE(\"testNestedPageTree\")\n{\n    // test for valid but deeply nested page tree\n    // maxDepth must be less than GetMaxObjectCount otherwise PdfParser::ResizeOffsets\n    // throws an error when reading the xref offsets table, and no outlines are read\n    ostringstream oss;\n    const size_t maxDepth = getStackOverflowDepth() - 4 - 1;\n    const size_t numObjects = maxDepth + 4;\n    vector<size_t> offsets(numObjects);\n    size_t xrefOffset = 0;\n\n    offsets[0] = 0;\n    oss << \"%PDF-1.0\\r\\n\";\n\n    offsets[1] = oss.tellp();\n    oss << \"1 0 obj<</Type/Catalog /AcroForm 2 0 R /Pages 3 0 R>>endobj \";\n\n    offsets[2] = oss.tellp();\n    oss << \"2 0 obj<</Type/AcroForm >>endobj \";\n\n    offsets[3] = oss.tellp();\n    oss << \"3 0 obj<</Type/Pages /Kids [4 0 R] /Count 1 >>endobj \";\n\n    // create pages tree nested to maxDepth where each node has one child\n    // except single leaf node at maxDepth\n    for (size_t objNo = 4; objNo < numObjects; objNo++)\n    {\n        offsets[objNo] = oss.tellp();\n\n        if (objNo < numObjects - 1)\n            oss << objNo << \" 0 obj<</Type/Pages /Kids [\" << objNo + 1 << \" 0 R] /Parent \" << objNo - 1 << \" 0 R /Count 1 >>endobj \";\n        else\n            oss << objNo << \" 0 obj<</Type/Page  /Parent \" << objNo - 1 << \" 0 R >>endobj \";\n    }\n\n    // output xref table\n    oss << \"\\r\\n\";\n    xrefOffset = oss.tellp();\n    oss << \"xref\\r\\n\";\n    oss << \"0 \" << numObjects << \"\\r\\n\";\n\n    oss << \"0000000000 65535 f\\r\\n\";\n\n    for (size_t objNo = 1; objNo < offsets.size(); objNo++)\n    {\n        // write xref entries like\n        // \"0000000010 00000 n\\r\\n\"\n        char refEntry[21];\n        snprintf(refEntry, 21, \"%010zu 00000 n\\r\\n\", offsets[objNo]);\n\n        oss << refEntry;\n    }\n\n    oss << \"trailer<</Size \" << numObjects << \"/Root 1 0 R>>\\r\\n\";\n    oss << \"startxref\\r\\n\";\n    oss << xrefOffset << \"\\r\\n\";\n    oss << \"%%EOF\";\n\n    auto buffer = oss.str();\n    try\n    {\n        PdfMemDocument doc;\n        doc.LoadFromBuffer(buffer);\n\n        auto& pages = doc.GetPages();\n        for (unsigned pageNo = 0; pageNo < pages.GetCount(); pageNo++)\n            (void)pages.GetPageAt(pageNo);\n\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n    }\n}\n\n// CVE-2021-30471\nTEST_CASE(\"testLoopingPageTree\")\n{\n    // test PDF without nested kids\n    string strNoLoop =\n        \"%PDF-1.0\\r\\n\"\n        \"1 0 obj<</Type/Catalog/Pages 2 0 R>>endobj 2 0 obj<</Type/Pages/Kids[3 0 R]/Count 1>>endobj 3 0 obj<</Type/Page/MediaBox[0 0 3 3]>>endobj\\r\\n\"\n        \"xref\\r\\n\"\n        \"0 4\\r\\n\"\n        \"0000000000 65535 f\\r\\n\"\n        \"0000000010 00000 n\\r\\n\"\n        \"0000000053 00000 n\\r\\n\"\n        \"0000000102 00000 n\\r\\n\"\n        \"trailer<</Size 4/Root 1 0 R>>\\r\\n\"\n        \"startxref\\r\\n\"\n        \"149\\r\\n\"\n        \"%%EOF\";\n\n    {\n        PdfMemDocument doc;\n        doc.LoadFromBuffer(strNoLoop);\n        auto& pages = doc.GetPages();\n        for (unsigned pageNo = 0; pageNo < doc.GetPages().GetCount(); pageNo++)\n            (void)pages.GetPageAt(pageNo);\n        REQUIRE(true);\n    }\n\n    // CVE-2021-30471 test for pages tree /Kids array that refer back to pages tree root\n    string strSelfLoop =\n        \"%PDF-1.0\\r\\n\"\n        \"1 0 obj<</Type/Catalog/Pages 2 0 R>>endobj 2 0 obj<</Type/Pages/Kids[2 0 R]/Count 1>>endobj 3 0 obj<</Type/Page/MediaBox[0 0 3 3]>>endobj\\r\\n\"\n        \"xref\\r\\n\"\n        \"0 4\\r\\n\"\n        \"0000000000 65535 f\\r\\n\"\n        \"0000000010 00000 n\\r\\n\"\n        \"0000000053 00000 n\\r\\n\"\n        \"0000000102 00000 n\\r\\n\"\n        \"trailer<</Size 4/Root 1 0 R>>\\r\\n\"\n        \"startxref\\r\\n\"\n        \"149\\r\\n\"\n        \"%%EOF\";\n\n    try\n    {\n        PdfMemDocument doc;\n        doc.LoadFromBuffer(strSelfLoop);\n        auto& pages = doc.GetPages();\n        for (unsigned pageNo = 0; pageNo < pages.GetCount(); pageNo++)\n            (void)pages.GetPageAt(pageNo);\n\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::PageNotFound);\n    }\n\n    // CVE-2021-30471 test for pages tree /Kids array that refer back to an ancestor (document root object)\n    string strAncestorLoop =\n        \"%PDF-1.0\\r\\n\"\n        \"1 0 obj<</Type/Catalog/Pages 2 0 R>>endobj 2 0 obj<</Type/Pages/Kids[1 0 R]/Count 1>>endobj 3 0 obj<</Type/Page/MediaBox[0 0 3 3]>>endobj\\r\\n\"\n        \"xref\\r\\n\"\n        \"0 4\\r\\n\"\n        \"0000000000 65535 f\\r\\n\"\n        \"0000000010 00000 n\\r\\n\"\n        \"0000000053 00000 n\\r\\n\"\n        \"0000000102 00000 n\\r\\n\"\n        \"trailer<</Size 4/Root 1 0 R>>\\r\\n\"\n        \"startxref\\r\\n\"\n        \"149\\r\\n\"\n        \"%%EOF\";\n\n    try\n    {\n        PdfMemDocument doc;\n        doc.LoadFromBuffer(strAncestorLoop);\n        auto& pages = doc.GetPages();\n        pages.GetPageAt(0);\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::PageNotFound);\n    }\n}\n\n// CVE-2020-18971\nTEST_CASE(\"testNestedOutlines\")\n{\n    // test for valid but deeply nested outlines\n    // maxDepth must be less than GetMaxObjectCount otherwise PdfParser::ResizeOffsets\n    // throws an error when reading the xref offsets table, and no outlines are read\n    ostringstream oss;\n    const size_t maxDepth = getStackOverflowDepth() - 4 - 1;\n    const size_t numObjects = maxDepth + 4;\n    vector<size_t> offsets(numObjects);\n    size_t xrefOffset = 0;\n\n    offsets[0] = 0;\n    oss << \"%PDF-1.0\\r\\n\";\n\n    offsets[1] = oss.tellp();\n    oss << \"1 0 obj<</Type/Catalog /AcroForm 2 0 R /Outlines 3 0 R>>endobj \";\n\n    offsets[2] = oss.tellp();\n    oss << \"2 0 obj<</Type/AcroForm >>endobj \";\n\n    offsets[3] = oss.tellp();\n    oss << \"3 0 obj<</Type/Outlines /First 4 0 R /Count \" << maxDepth << \" /Last 5 0 R >>endobj \";\n\n    // create outlines tree nested to maxDepth where each node has one child\n    // except single leaf node at maxDepth\n    for (size_t objNo = 4; objNo < numObjects; objNo++)\n    {\n        offsets[objNo] = oss.tellp();\n\n        if (objNo < numObjects - 1)\n            oss << objNo << \" 0 obj<</Title (Outline Item) /First \" << objNo + 1 << \" 0 R /Last \" << objNo + 1 << \" 0 R>>endobj \";\n        else\n            oss << objNo << \" 0 obj<</Title (Outline Item)>>endobj \";\n    }\n\n    // output xref table\n    oss << \"\\r\\n\";\n    xrefOffset = oss.tellp();\n    oss << \"xref\\r\\n\";\n    oss << \"0 \" << numObjects << \"\\r\\n\";\n\n    oss << \"0000000000 65535 f\\r\\n\";\n\n    for (size_t objNo = 1; objNo < offsets.size(); objNo++)\n    {\n        // write xref entries like\n        // \"0000000010 00000 n\\r\\n\"\n        char szXrefEntry[21];\n        snprintf(szXrefEntry, 21, \"%010zu 00000 n\\r\\n\", offsets[objNo]);\n\n        oss << szXrefEntry;\n    }\n\n    oss << \"trailer<</Size \" << numObjects << \"/Root 1 0 R>>\\r\\n\";\n    oss << \"startxref\\r\\n\";\n    oss << xrefOffset << \"\\r\\n\";\n    oss << \"%%EOF\";\n\n    auto buffer = oss.str();\n    try\n    {\n        PdfMemDocument doc;\n        doc.LoadFromBuffer(buffer);\n\n        // load should succeed, then GetOutlines goes recursive due to /Outlines deep nesting\n        (void)doc.GetOutlines();\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n    }\n}\n\n// CVE-2020-18971\nTEST_CASE(\"testLoopingOutlines\")\n{\n    // CVE-2020-18971 - PdfOutlineItem /Next refers a preceding sibling\n    string strNextLoop =\n        \"%PDF-1.0\\r\\n\"\n        \"1 0 obj<</Type/Catalog /AcroForm 2 0 R /Outlines 3 0 R>>endobj \"\n        \"2 0 obj<</Type/AcroForm >>endobj \"\n        \"3 0 obj<</Type/Outlines /First 4 0 R /Count 2 /Last 5 0 R >>endobj \"\n        \"4 0 obj<</Title (Outline Item 1) /Next 5 0 R>>endobj \"\n        \"5 0 obj<</Title (Outline Item 2) /Next 4 0 R>>endobj \" // /Next loops back to previous outline item\n        \"\\r\\n\"\n        \"xref\\r\\n\"\n        \"0 6\\r\\n\"\n        \"0000000000 65535 f\\r\\n\"\n        \"0000000010 00000 n\\r\\n\"\n        \"0000000073 00000 n\\r\\n\"\n        \"0000000106 00000 n\\r\\n\"\n        \"0000000173 00000 n\\r\\n\"\n        \"0000000226 00000 n\\r\\n\"\n        \"trailer<</Size 6/Root 1 0 R>>\\r\\n\"\n        \"startxref\\r\\n\"\n        \"281\\r\\n\"\n        \"%%EOF\";\n\n    try\n    {\n        PdfMemDocument doc;\n        doc.LoadFromBuffer(strNextLoop);\n\n        // load should succeed, then GetOutlines goes recursive due to /Outlines loop\n        (void)doc.GetOutlines();\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n    }\n\n    // https://sourceforge.net/p/podofo/tickets/25/\n    string strSelfLoop =\n        \"%PDF-1.0\\r\\n\"\n        \"1 0 obj<</Type/Catalog/Outlines 2 0 R>>endobj \"\n        \"2 0 obj<</Type/Outlines /First 2 0 R /Last 2 0 R /Count 1>>endobj\" // /First and /Last loop to self\n        \"\\r\\n\"\n        \"xref\\r\\n\"\n        \"0 3\\r\\n\"\n        \"0000000000 65535 f\\r\\n\"\n        \"0000000010 00000 n\\r\\n\"\n        \"0000000056 00000 n\\r\\n\"\n        \"trailer<</Size 3/Root 1 0 R>>\\r\\n\"\n        \"startxref\\r\\n\"\n        \"123\\r\\n\"\n        \"%%EOF\";\n\n    try\n    {\n        PdfMemDocument doc;\n        doc.LoadFromBuffer(strNextLoop);\n\n        // load should succeed, then GetOutlines goes recursive due to /Outlines loop\n        (void)doc.GetOutlines();\n        FAIL(\"Should throw exception\");\n    }\n    catch (PdfError& error)\n    {\n        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);\n    }\n}\n\nstring generateXRefEntries(size_t count)\n{\n    string strXRefEntries;\n\n    // generates a block of 20-byte xref entries\n    // 0000000000 65535 f\\r\\n\n    // 0000000120 00000 n\\r\\n    \n    // 0000000120 00000 n\\r\\n\n    // 0000000120 00000 n\\r\\n\n    try\n    {\n        strXRefEntries.reserve(count * 20);\n        for (size_t i = 0; i < count; i++)\n        {\n            if (i == 0)\n                strXRefEntries.append(\"0000000000 65535 f\\r\\n\");\n            else\n                strXRefEntries.append(\"0000000120 00000 n\\r\\n\");\n        }\n    }\n    catch (exception&)\n    {\n        // if this fails it's a bug in the unit tests and not PoDoFo\n        FAIL(\"generateXRefEntries memory allocation failure\");\n    }\n\n    return strXRefEntries;\n}\n\nbool canOutOfMemoryKillUnitTests()\n{\n    // test if out of memory conditions will kill the unit test process\n    // which prevents tests completing\n\n#if defined(_WIN32)\n    // on Windows 32/64 allocations close to size of VM address space always fail gracefully\n    bool canTerminateProcess = false;\n#elif defined( __APPLE__ )\n    // on macOS/iOS allocations close to size of VM address space fail gracefully\n    // unless Address Sanitizer (ASAN) is enabled\n#if __has_feature(address_sanitizer)\n    // ASAN terminates the process if alloc fails - and using allocator_may_return_null=1\n    // to continue after an allocation doesn't work in C++ because new returns null which is\n    // forbidden by the C++ spec and terminates process when 'this' is dereferenced in constructor\n    // see https://github.com/google/sanitizers/issues/295\n    bool canTerminateProcess = true;\n#else\n    // if alloc fails following message is logged\n    // *** mach_vm_map failed (error code=3)\n    // *** error: can't allocate region\n    // *** set a breakpoint in malloc_error_break to debug\n    bool canTerminateProcess = false;\n#endif\n#elif defined( __linux__ )\n    // TODO do big allocs succeed then trigger OOM-killer fiasco??\n    bool canTerminateProcess = false;\n#else\n    // other systems - assume big allocs faily gracefully and throw bad_alloc\n    bool canTerminateProcess = false;\n#endif\n    return canTerminateProcess;\n}\n\nsize_t getStackOverflowDepth()\n{\n    // calculate stack overflow depth - need to do this because a value that consistently overflows a 64-bit stack\n    // doesn't work on 32-bit systems because they run out of heap in ReadObjects before they get a chance to overflow stack\n    // this is because sizeof(PdfParserObject) = 472 bytes (and there's one of these for every object read)\n    constexpr size_t parserObjectSize = sizeof(PdfParserObject);\n\n#if defined(_WIN64)\n    // 1 MB default stack size, 64-bit address space, Windows x64 ABI\n    // each stack frame has at least 4 64-bit stack params, 4 64-bit register params, plus 64-bit return address\n    // stack frame size increases if function contains local variables or more than 4 parameters\n    // see https://docs.microsoft.com/en-us/cpp/build/stack-usage?view=msvc-170\n    constexpr size_t stackSize = 1 * 1024 * 1024;\n    constexpr size_t frameSize = sizeof(void*) * (4 + 4 + 1); // 4 stack params + 4 register params + return address\n    constexpr size_t maxFrames = stackSize / frameSize; // overflows at 14,563 recursive calls (or sooner if functions contain local variables)\n#elif defined(_WIN32)\n    // 1 MB default stack size, 32-bit address space (can't allocate more than 2GB), Windows x86 thiscall calling convention\n    // each stack frame has at least 32-bit EBP and return address\n    // stack frame size increases if function contains local variables or any parameters\n    constexpr size_t stackSize = 1 * 1024 * 1024;\n    constexpr size_t frameSize = sizeof(void*) * (1 + 1); // EBP and return address\n    constexpr size_t maxFrames = stackSize / frameSize; // overflows at 131,072 recursive calls (or sooner if functions contain local variables or has parameters)\n#else\n    // assume 8MB macOS / Linux default stack size, 64-bit address space, System V AMD64 ABI\n    // each stack frame has at least 64-bit EBP and return address\n    // stack frame size increases if function contains local variables or any parameters\n    constexpr size_t stackSize = 8 * 1024 * 1024;\n    constexpr size_t frameSize = sizeof(void*) * (1 + 1); // EBP and return address\n    constexpr size_t maxFrames = stackSize / frameSize; // overflows at 524,288 recursive calls (or sooner if functions contain local variables or has parameters)\n#endif\n\n    // add a few frames to sure we go beyond end of stack\n    constexpr size_t overflowDepth = maxFrames + 1000;\n\n    // overflowDepth must be less than GetMaxObjectCount otherwise PdfParser::ResizeOffsets\n    // throws an error when reading the xref offsets table, and no recursive calls are made\n    // must also be allocate less than half of address space to prevent out-of-memory exceptions\n    REQUIRE(overflowDepth < PdfParser::GetMaxObjectCount());\n    REQUIRE(overflowDepth * parserObjectSize < numeric_limits<size_t>::max() / 2);\n\n    return overflowDepth;\n}\n"], "filenames": ["playground/CMakeLists.txt", "src/podofo/main/PdfXRefStreamParserObject.cpp", "test/unit/ParserTest.cpp"], "buggy_code_start_loc": [11, 70, 1063], "buggy_code_end_loc": [12, 161, 1776], "fixing_code_start_loc": [11, 70, 1063], "fixing_code_end_loc": [12, 161, 1776], "type": "CWE-122", "message": "A vulnerability, which was classified as critical, was found in PoDoFo 0.10.0. Affected is the function readXRefStreamEntry of the file PdfXRefStreamParserObject.cpp. The manipulation leads to heap-based buffer overflow. An attack has to be approached locally. The exploit has been disclosed to the public and may be used. The name of the patch is 535a786f124b739e3c857529cecc29e4eeb79778. It is recommended to apply a patch to fix this issue. VDB-227226 is the identifier assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2023-2241", "sourceIdentifier": "cna@vuldb.com", "published": "2023-04-22T16:15:42.050", "lastModified": "2023-04-29T03:03:33.527", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability, which was classified as critical, was found in PoDoFo 0.10.0. Affected is the function readXRefStreamEntry of the file PdfXRefStreamParserObject.cpp. The manipulation leads to heap-based buffer overflow. An attack has to be approached locally. The exploit has been disclosed to the public and may be used. The name of the patch is 535a786f124b739e3c857529cecc29e4eeb79778. It is recommended to apply a patch to fix this issue. VDB-227226 is the identifier assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.1, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:podofo_project:podofo:0.10.0:*:*:*:*:*:*:*", "matchCriteriaId": "9D2B6FCB-1882-4BAA-B8BE-25E150D012D7"}]}]}], "references": [{"url": "https://github.com/podofo/podofo/commit/535a786f124b739e3c857529cecc29e4eeb79778", "source": "cna@vuldb.com", "tags": ["Patch"]}, {"url": "https://github.com/podofo/podofo/files/11260976/poc-file.zip", "source": "cna@vuldb.com", "tags": ["Exploit"]}, {"url": "https://github.com/podofo/podofo/issues/69", "source": "cna@vuldb.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.227226", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.227226", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/podofo/podofo/commit/535a786f124b739e3c857529cecc29e4eeb79778"}}