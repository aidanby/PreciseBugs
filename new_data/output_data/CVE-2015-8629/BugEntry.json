{"buggy_code": ["/* -*- mode: c; c-file-style: \"bsd\"; indent-tabs-mode: t -*- */\n/*\n * Copyright 1993 OpenVision Technologies, Inc., All Rights Reserved\n */\n\n#include <gssrpc/rpc.h>\n#include <krb5.h>\n#include <errno.h>\n#include <kadm5/admin.h>\n#include <kadm5/kadm_rpc.h>\n#include <kadm5/admin_xdr.h>\n#include <stdlib.h>\n#include <string.h>\n\nstatic bool_t\n_xdr_kadm5_principal_ent_rec(XDR *xdrs, kadm5_principal_ent_rec *objp,\n\t\t\t     int v);\nstatic bool_t\n_xdr_kadm5_policy_ent_rec(XDR *xdrs, kadm5_policy_ent_rec *objp, int vers);\n\n/*\n * Function: xdr_ui_4\n *\n * Purpose: XDR function which serves as a wrapper for xdr_u_int32,\n * to prevent compiler warnings about type clashes between u_int32\n * and krb5_ui_4.\n */\nbool_t xdr_ui_4(XDR *xdrs, krb5_ui_4 *objp)\n{\n  /* Assumes that krb5_ui_4 and u_int32 are both four bytes long.\n     This should not be a harmful assumption. */\n  return xdr_u_int32(xdrs, (uint32_t *) objp);\n}\n\n\n/*\n * Function: xdr_nullstring\n *\n * Purpose: XDR function for \"strings\" that are either NULL-terminated\n * or NULL.\n */\nbool_t xdr_nullstring(XDR *xdrs, char **objp)\n{\n     u_int size;\n\n     if (xdrs->x_op == XDR_ENCODE) {\n\t  if (*objp == NULL)\n\t       size = 0;\n\t  else\n\t       size = strlen(*objp) + 1;\n     }\n     if (! xdr_u_int(xdrs, &size)) {\n\t  return FALSE;\n\t}\n     switch (xdrs->x_op) {\n     case XDR_DECODE:\n\t  if (size == 0) {\n\t       *objp = NULL;\n\t       return TRUE;\n\t  } else if (*objp == NULL) {\n\t       *objp = (char *) mem_alloc(size);\n\t       if (*objp == NULL) {\n\t\t    errno = ENOMEM;\n\t\t    return FALSE;\n\t       }\n\t  }\n\t  return (xdr_opaque(xdrs, *objp, size));\n\n     case XDR_ENCODE:\n\t  if (size != 0)\n\t       return (xdr_opaque(xdrs, *objp, size));\n\t  return TRUE;\n\n     case XDR_FREE:\n\t  if (*objp != NULL)\n\t       mem_free(*objp, size);\n\t  *objp = NULL;\n\t  return TRUE;\n     }\n\n     return FALSE;\n}\n\n/*\n * Function: xdr_nulltype\n *\n * Purpose: XDR function for arbitrary pointer types that are either\n * NULL or contain data.\n */\nbool_t xdr_nulltype(XDR *xdrs, void **objp, xdrproc_t proc)\n{\n     bool_t null;\n\n     switch (xdrs->x_op) {\n     case XDR_DECODE:\n\t  if (!xdr_bool(xdrs, &null))\n\t      return FALSE;\n\t  if (null) {\n\t       *objp = NULL;\n\t       return TRUE;\n\t  }\n\t  return (*proc)(xdrs, objp);\n\n     case XDR_ENCODE:\n\t  if (*objp == NULL)\n\t       null = TRUE;\n\t  else\n\t       null = FALSE;\n\t  if (!xdr_bool(xdrs, &null))\n\t       return FALSE;\n\t  if (null == FALSE)\n\t       return (*proc)(xdrs, objp);\n\t  return TRUE;\n\n     case XDR_FREE:\n\t  if (*objp)\n\t       return (*proc)(xdrs, objp);\n\t  return TRUE;\n     }\n\n     return FALSE;\n}\n\nbool_t\nxdr_krb5_timestamp(XDR *xdrs, krb5_timestamp *objp)\n{\n  /* This assumes that int32 and krb5_timestamp are the same size.\n     This shouldn't be a problem, since we've got a unit test which\n     checks for this. */\n\tif (!xdr_int32(xdrs, (int32_t *) objp)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_krb5_kvno(XDR *xdrs, krb5_kvno *objp)\n{\n\treturn xdr_u_int(xdrs, objp);\n}\n\nbool_t\nxdr_krb5_deltat(XDR *xdrs, krb5_deltat *objp)\n{\n  /* This assumes that int32 and krb5_deltat are the same size.\n     This shouldn't be a problem, since we've got a unit test which\n     checks for this. */\n\tif (!xdr_int32(xdrs, (int32_t *) objp)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_krb5_flags(XDR *xdrs, krb5_flags *objp)\n{\n  /* This assumes that int32 and krb5_flags are the same size.\n     This shouldn't be a problem, since we've got a unit test which\n     checks for this. */\n\tif (!xdr_int32(xdrs, (int32_t *) objp)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_krb5_ui_4(XDR *xdrs, krb5_ui_4 *objp)\n{\n\tif (!xdr_u_int32(xdrs, (uint32_t *) objp)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_krb5_int16(XDR *xdrs, krb5_int16 *objp)\n{\n    int tmp;\n\n    tmp = (int) *objp;\n\n    if (!xdr_int(xdrs, &tmp))\n\treturn(FALSE);\n\n    *objp = (krb5_int16) tmp;\n\n    return(TRUE);\n}\n\n/*\n * Function: xdr_krb5_ui_2\n *\n * Purpose: XDR function which serves as a wrapper for xdr_u_int,\n * to prevent compiler warnings about type clashes between u_int\n * and krb5_ui_2.\n */\nbool_t\nxdr_krb5_ui_2(XDR *xdrs, krb5_ui_2 *objp)\n{\n    unsigned int tmp;\n\n    tmp = (unsigned int) *objp;\n\n    if (!xdr_u_int(xdrs, &tmp))\n\treturn(FALSE);\n\n    *objp = (krb5_ui_2) tmp;\n\n    return(TRUE);\n}\n\n\n\nstatic bool_t xdr_krb5_boolean(XDR *xdrs, krb5_boolean *kbool)\n{\n\tbool_t val;\n\n\tswitch (xdrs->x_op) {\n\tcase XDR_DECODE:\n\t     if (!xdr_bool(xdrs, &val))\n\t\t     return FALSE;\n\n\t     *kbool = (val == FALSE) ? FALSE : TRUE;\n\t     return TRUE;\n\n\tcase XDR_ENCODE:\n\t     val = *kbool ? TRUE : FALSE;\n\t     return xdr_bool(xdrs, &val);\n\n\tcase XDR_FREE:\n\t     return TRUE;\n\t}\n\n\treturn FALSE;\n}\n\nbool_t xdr_krb5_key_data_nocontents(XDR *xdrs, krb5_key_data *objp)\n{\n     /*\n      * Note that this function intentionally DOES NOT tranfer key\n      * length or contents!  xdr_krb5_key_data in adb_xdr.c does, but\n      * that is only for use within the server-side library.\n      */\n     unsigned int tmp;\n\n     if (xdrs->x_op == XDR_DECODE)\n\t  memset(objp, 0, sizeof(krb5_key_data));\n\n     if (!xdr_krb5_int16(xdrs, &objp->key_data_ver)) {\n\t  return (FALSE);\n     }\n     if (!xdr_krb5_ui_2(xdrs, &objp->key_data_kvno)) {\n\t  return (FALSE);\n     }\n     if (!xdr_krb5_int16(xdrs, &objp->key_data_type[0])) {\n\t  return (FALSE);\n     }\n     if (objp->key_data_ver > 1) {\n\t  if (!xdr_krb5_int16(xdrs, &objp->key_data_type[1])) {\n\t       return (FALSE);\n\t  }\n     }\n     /*\n      * kadm5_get_principal on the server side allocates and returns\n      * key contents when asked.  Even though this function refuses to\n      * transmit that data, it still has to *free* the data at the\n      * appropriate time to avoid a memory leak.\n      */\n     if (xdrs->x_op == XDR_FREE) {\n\t  tmp = (unsigned int) objp->key_data_length[0];\n\t  if (!xdr_bytes(xdrs, (char **) &objp->key_data_contents[0],\n\t\t\t &tmp, ~0))\n\t       return FALSE;\n\n\t  tmp = (unsigned int) objp->key_data_length[1];\n\t  if (!xdr_bytes(xdrs, (char **) &objp->key_data_contents[1],\n\t\t\t &tmp, ~0))\n\t       return FALSE;\n     }\n\n     return (TRUE);\n}\n\n\nbool_t\nxdr_krb5_key_salt_tuple(XDR *xdrs, krb5_key_salt_tuple *objp)\n{\n    if (!xdr_krb5_enctype(xdrs, &objp->ks_enctype))\n\treturn FALSE;\n    if (!xdr_krb5_salttype(xdrs, &objp->ks_salttype))\n\treturn FALSE;\n    return TRUE;\n}\n\nbool_t xdr_krb5_tl_data(XDR *xdrs, krb5_tl_data **tl_data_head)\n{\n     krb5_tl_data *tl, *tl2;\n     bool_t more;\n     unsigned int len;\n\n     switch (xdrs->x_op) {\n     case XDR_FREE:\n\t  tl = tl2 = *tl_data_head;\n\t  while (tl) {\n\t       tl2 = tl->tl_data_next;\n\t       free(tl->tl_data_contents);\n\t       free(tl);\n\t       tl = tl2;\n\t  }\n\t  *tl_data_head = NULL;\n\t  break;\n\n     case XDR_ENCODE:\n\t  tl = *tl_data_head;\n\t  while (1) {\n\t       more = (tl != NULL);\n\t       if (!xdr_bool(xdrs, &more))\n\t\t    return FALSE;\n\t       if (tl == NULL)\n\t\t    break;\n\t       if (!xdr_krb5_int16(xdrs, &tl->tl_data_type))\n\t\t    return FALSE;\n\t       len = tl->tl_data_length;\n\t       if (!xdr_bytes(xdrs, (char **) &tl->tl_data_contents, &len, ~0))\n\t\t    return FALSE;\n\t       tl = tl->tl_data_next;\n\t  }\n\t  break;\n\n     case XDR_DECODE:\n\t  tl = NULL;\n\t  while (1) {\n\t       if (!xdr_bool(xdrs, &more))\n\t\t    return FALSE;\n\t       if (more == FALSE)\n\t\t    break;\n\t       tl2 = (krb5_tl_data *) malloc(sizeof(krb5_tl_data));\n\t       if (tl2 == NULL)\n\t\t    return FALSE;\n\t       memset(tl2, 0, sizeof(krb5_tl_data));\n\t       if (!xdr_krb5_int16(xdrs, &tl2->tl_data_type))\n\t\t    return FALSE;\n\t       if (!xdr_bytes(xdrs, (char **)&tl2->tl_data_contents, &len, ~0))\n\t\t    return FALSE;\n\t       tl2->tl_data_length = len;\n\n\t       tl2->tl_data_next = tl;\n\t       tl = tl2;\n\t  }\n\n\t  *tl_data_head = tl;\n\t  break;\n     }\n\n     return TRUE;\n}\n\nbool_t\nxdr_kadm5_ret_t(XDR *xdrs, kadm5_ret_t *objp)\n{\n\tuint32_t tmp;\n\n\tif (xdrs->x_op == XDR_ENCODE)\n\t\ttmp = (uint32_t) *objp;\n\n\tif (!xdr_u_int32(xdrs, &tmp))\n\t\treturn (FALSE);\n\n\tif (xdrs->x_op == XDR_DECODE)\n\t\t*objp = (kadm5_ret_t) tmp;\n\n\treturn (TRUE);\n}\n\nbool_t xdr_kadm5_principal_ent_rec(XDR *xdrs,\n\t\t\t\t   kadm5_principal_ent_rec *objp)\n{\n     return _xdr_kadm5_principal_ent_rec(xdrs, objp, KADM5_API_VERSION_3);\n}\n\nstatic bool_t\n_xdr_kadm5_principal_ent_rec(XDR *xdrs, kadm5_principal_ent_rec *objp,\n\t\t\t     int v)\n{\n\tunsigned int n;\n\n\tif (!xdr_krb5_principal(xdrs, &objp->principal)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_timestamp(xdrs, &objp->princ_expire_time)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_timestamp(xdrs, &objp->last_pwd_change)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_timestamp(xdrs, &objp->pw_expiration)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_deltat(xdrs, &objp->max_life)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nulltype(xdrs, (void **) &objp->mod_name,\n\t\t\t  xdr_krb5_principal)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_timestamp(xdrs, &objp->mod_date)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_flags(xdrs, &objp->attributes)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_kvno(xdrs, &objp->kvno)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_kvno(xdrs, &objp->mkvno)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->policy)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->aux_attributes)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_deltat(xdrs, &objp->max_renewable_life)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_timestamp(xdrs, &objp->last_success)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_timestamp(xdrs, &objp->last_failed)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_kvno(xdrs, &objp->fail_auth_count)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_int16(xdrs, &objp->n_key_data)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_int16(xdrs, &objp->n_tl_data)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nulltype(xdrs, (void **) &objp->tl_data,\n\t\t\t  xdr_krb5_tl_data)) {\n\t\treturn FALSE;\n\t}\n\tn = objp->n_key_data;\n\tif (!xdr_array(xdrs, (caddr_t *) &objp->key_data,\n\t\t       &n, ~0, sizeof(krb5_key_data),\n\t\t       xdr_krb5_key_data_nocontents)) {\n\t\treturn (FALSE);\n\t}\n\n\treturn (TRUE);\n}\n\nstatic bool_t\n_xdr_kadm5_policy_ent_rec(XDR *xdrs, kadm5_policy_ent_rec *objp, int vers)\n{\n\tif (!xdr_nullstring(xdrs, &objp->policy)) {\n\t\treturn (FALSE);\n\t}\n\t/* these all used to be u_int32, but it's stupid for sized types\n\t   to be exposed at the api, and they're the same as longs on the\n\t   wire. */\n\tif (!xdr_long(xdrs, &objp->pw_min_life)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->pw_max_life)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->pw_min_length)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->pw_min_classes)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->pw_history_num)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->policy_refcnt)) {\n\t\treturn (FALSE);\n\t}\n\tif (xdrs->x_op == XDR_DECODE) {\n\t\tobjp->pw_max_fail = 0;\n\t\tobjp->pw_failcnt_interval = 0;\n\t\tobjp->pw_lockout_duration = 0;\n\t\tobjp->attributes = 0;\n\t\tobjp->max_life = 0;\n\t\tobjp->max_renewable_life = 0;\n\t\tobjp->allowed_keysalts = NULL;\n\t\tobjp->n_tl_data = 0;\n\t\tobjp->tl_data = NULL;\n\t}\n\tif (vers >= KADM5_API_VERSION_3) {\n\t\tif (!xdr_krb5_kvno(xdrs, &objp->pw_max_fail))\n\t\t\treturn (FALSE);\n\t\tif (!xdr_krb5_deltat(xdrs, &objp->pw_failcnt_interval))\n\t\t\treturn (FALSE);\n\t\tif (!xdr_krb5_deltat(xdrs, &objp->pw_lockout_duration))\n\t\t\treturn (FALSE);\n\t}\n\tif (vers >= KADM5_API_VERSION_4) {\n\t\tif (!xdr_krb5_flags(xdrs, &objp->attributes)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t\tif (!xdr_krb5_deltat(xdrs, &objp->max_life)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t\tif (!xdr_krb5_deltat(xdrs, &objp->max_renewable_life)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t\tif (!xdr_nullstring(xdrs, &objp->allowed_keysalts)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t\tif (!xdr_krb5_int16(xdrs, &objp->n_tl_data)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t\tif (!xdr_nulltype(xdrs, (void **) &objp->tl_data,\n\t\t\t\t  xdr_krb5_tl_data)) {\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_kadm5_policy_ent_rec(XDR *xdrs, kadm5_policy_ent_rec *objp)\n{\n\treturn _xdr_kadm5_policy_ent_rec(xdrs, objp, KADM5_API_VERSION_4);\n}\n\nbool_t\nxdr_cprinc_arg(XDR *xdrs, cprinc_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!_xdr_kadm5_principal_ent_rec(xdrs, &objp->rec,\n\t\t\t\t\t  objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->mask)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->passwd)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_cprinc3_arg(XDR *xdrs, cprinc3_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!_xdr_kadm5_principal_ent_rec(xdrs, &objp->rec,\n\t\t\t\t\t  objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->mask)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_array(xdrs, (caddr_t *)&objp->ks_tuple,\n\t\t       (unsigned int *)&objp->n_ks_tuple, ~0,\n\t\t       sizeof(krb5_key_salt_tuple),\n\t\t       xdr_krb5_key_salt_tuple)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->passwd)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_generic_ret(XDR *xdrs, generic_ret *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t\treturn (FALSE);\n\t}\n\n\treturn(TRUE);\n}\n\nbool_t\nxdr_dprinc_arg(XDR *xdrs, dprinc_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_mprinc_arg(XDR *xdrs, mprinc_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!_xdr_kadm5_principal_ent_rec(xdrs, &objp->rec,\n\t\t\t\t\t  objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->mask)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_rprinc_arg(XDR *xdrs, rprinc_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->src)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->dest)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gprincs_arg(XDR *xdrs, gprincs_arg *objp)\n{\n     if (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t  return (FALSE);\n     }\n     if (!xdr_nullstring(xdrs, &objp->exp)) {\n\t  return (FALSE);\n     }\n     return (TRUE);\n}\n\nbool_t\nxdr_gprincs_ret(XDR *xdrs, gprincs_ret *objp)\n{\n     if (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t  return (FALSE);\n     }\n     if (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t  return (FALSE);\n     }\n     if (objp->code == KADM5_OK) {\n\t  if (!xdr_int(xdrs, &objp->count)) {\n\t       return (FALSE);\n\t  }\n\t  if (!xdr_array(xdrs, (caddr_t *) &objp->princs,\n\t\t\t (unsigned int *) &objp->count, ~0,\n\t\t\t sizeof(char *), xdr_nullstring)) {\n\t       return (FALSE);\n\t  }\n     }\n\n     return (TRUE);\n}\n\nbool_t\nxdr_chpass_arg(XDR *xdrs, chpass_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->pass)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_chpass3_arg(XDR *xdrs, chpass3_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_boolean(xdrs, &objp->keepold)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_array(xdrs, (caddr_t *)&objp->ks_tuple,\n\t\t       (unsigned int*)&objp->n_ks_tuple, ~0,\n\t\t       sizeof(krb5_key_salt_tuple),\n\t\t       xdr_krb5_key_salt_tuple)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->pass)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_setv4key_arg(XDR *xdrs, setv4key_arg *objp)\n{\n\tunsigned int n_keys = 1;\n\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_array(xdrs, (caddr_t *) &objp->keyblock,\n\t\t       &n_keys, ~0,\n\t\t       sizeof(krb5_keyblock), xdr_krb5_keyblock)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_setkey_arg(XDR *xdrs, setkey_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_array(xdrs, (caddr_t *) &objp->keyblocks,\n\t\t       (unsigned int *) &objp->n_keys, ~0,\n\t\t       sizeof(krb5_keyblock), xdr_krb5_keyblock)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_setkey3_arg(XDR *xdrs, setkey3_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_boolean(xdrs, &objp->keepold)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_array(xdrs, (caddr_t *) &objp->ks_tuple,\n\t\t       (unsigned int *) &objp->n_ks_tuple, ~0,\n\t\t       sizeof(krb5_key_salt_tuple), xdr_krb5_key_salt_tuple)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_array(xdrs, (caddr_t *) &objp->keyblocks,\n\t\t       (unsigned int *) &objp->n_keys, ~0,\n\t\t       sizeof(krb5_keyblock), xdr_krb5_keyblock)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_chrand_arg(XDR *xdrs, chrand_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_chrand3_arg(XDR *xdrs, chrand3_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_boolean(xdrs, &objp->keepold)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_array(xdrs, (caddr_t *)&objp->ks_tuple,\n\t\t       (unsigned int*)&objp->n_ks_tuple, ~0,\n\t\t       sizeof(krb5_key_salt_tuple),\n\t\t       xdr_krb5_key_salt_tuple)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_chrand_ret(XDR *xdrs, chrand_ret *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t\treturn (FALSE);\n\t}\n\tif (objp->code == KADM5_OK) {\n\t\tif (!xdr_array(xdrs, (char **)&objp->keys,\n\t\t\t       (unsigned int *)&objp->n_keys, ~0,\n\t\t\t       sizeof(krb5_keyblock), xdr_krb5_keyblock))\n\t\t\treturn FALSE;\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gprinc_arg(XDR *xdrs, gprinc_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->mask)) {\n\t     return FALSE;\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gprinc_ret(XDR *xdrs, gprinc_ret *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t\treturn (FALSE);\n\t}\n\tif(objp->code == KADM5_OK)  {\n\t\tif (!_xdr_kadm5_principal_ent_rec(xdrs, &objp->rec,\n\t\t\t\t\t\t  objp->api_version)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_cpol_arg(XDR *xdrs, cpol_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!_xdr_kadm5_policy_ent_rec(xdrs, &objp->rec,\n\t\t\t\t       objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->mask)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_dpol_arg(XDR *xdrs, dpol_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->name)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_mpol_arg(XDR *xdrs, mpol_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!_xdr_kadm5_policy_ent_rec(xdrs, &objp->rec,\n\t\t\t\t       objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->mask)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gpol_arg(XDR *xdrs, gpol_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->name)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gpol_ret(XDR *xdrs, gpol_ret *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t\treturn (FALSE);\n\t}\n\tif(objp->code == KADM5_OK) {\n\t    if (!_xdr_kadm5_policy_ent_rec(xdrs, &objp->rec,\n\t\t\t\t\t   objp->api_version))\n\t\treturn (FALSE);\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gpols_arg(XDR *xdrs, gpols_arg *objp)\n{\n     if (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t  return (FALSE);\n     }\n     if (!xdr_nullstring(xdrs, &objp->exp)) {\n\t  return (FALSE);\n     }\n     return (TRUE);\n}\n\nbool_t\nxdr_gpols_ret(XDR *xdrs, gpols_ret *objp)\n{\n     if (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t  return (FALSE);\n     }\n     if (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t  return (FALSE);\n     }\n     if (objp->code == KADM5_OK) {\n\t  if (!xdr_int(xdrs, &objp->count)) {\n\t       return (FALSE);\n\t  }\n\t  if (!xdr_array(xdrs, (caddr_t *) &objp->pols,\n\t\t\t (unsigned int *) &objp->count, ~0,\n\t\t\t sizeof(char *), xdr_nullstring)) {\n\t       return (FALSE);\n\t  }\n     }\n\n     return (TRUE);\n}\n\nbool_t xdr_getprivs_ret(XDR *xdrs, getprivs_ret *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n     if (! xdr_kadm5_ret_t(xdrs, &objp->code) ||\n\t ! xdr_long(xdrs, &objp->privs))\n\t  return FALSE;\n\n     return TRUE;\n}\n\nbool_t\nxdr_purgekeys_arg(XDR *xdrs, purgekeys_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_int(xdrs, &objp->keepkvno)) {\n\t     return FALSE;\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gstrings_arg(XDR *xdrs, gstrings_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gstrings_ret(XDR *xdrs, gstrings_ret *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t\treturn (FALSE);\n\t}\n\tif (objp->code == KADM5_OK) {\n\t\tif (!xdr_int(xdrs, &objp->count)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t\tif (!xdr_array(xdrs, (caddr_t *) &objp->strings,\n\t\t\t       (unsigned int *) &objp->count, ~0,\n\t\t\t       sizeof(krb5_string_attr),\n\t\t\t       xdr_krb5_string_attr)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_sstring_arg(XDR *xdrs, sstring_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->key)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->value)) {\n\t\treturn (FALSE);\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_krb5_principal(XDR *xdrs, krb5_principal *objp)\n{\n    int\t    ret;\n    char\t    *p = NULL;\n    krb5_principal  pr = NULL;\n    static krb5_context context = NULL;\n\n    /* using a static context here is ugly, but should work\n       ok, and the other solutions are even uglier */\n\n    if (!context &&\n\tkadm5_init_krb5_context(&context))\n       return(FALSE);\n\n    switch(xdrs->x_op) {\n    case XDR_ENCODE:\n\tif (*objp) {\n\t     if((ret = krb5_unparse_name(context, *objp, &p)) != 0)\n\t\t  return FALSE;\n\t}\n\tif(!xdr_nullstring(xdrs, &p))\n\t    return FALSE;\n\tif (p) free(p);\n\tbreak;\n    case XDR_DECODE:\n\tif(!xdr_nullstring(xdrs, &p))\n\t    return FALSE;\n\tif (p) {\n\t     ret = krb5_parse_name(context, p, &pr);\n\t     if(ret != 0)\n\t\t  return FALSE;\n\t     *objp = pr;\n\t     free(p);\n\t} else\n\t     *objp = NULL;\n\tbreak;\n    case XDR_FREE:\n\tif(*objp != NULL)\n\t    krb5_free_principal(context, *objp);\n\t*objp = NULL;\n\tbreak;\n    }\n    return TRUE;\n}\n\nbool_t\nxdr_krb5_octet(XDR *xdrs, krb5_octet *objp)\n{\n   if (!xdr_u_char(xdrs, objp))\n\treturn (FALSE);\n   return (TRUE);\n}\n\nbool_t\nxdr_krb5_enctype(XDR *xdrs, krb5_enctype *objp)\n{\n   /*\n    * This used to be xdr_krb5_keytype, but keytypes and enctypes have\n    * been merged into only enctypes.  However, randkey_principal\n    * already ensures that only a key of ENCTYPE_DES_CBC_CRC will be\n    * returned to v1 clients, and ENCTYPE_DES_CBC_CRC has the same\n    * value as KEYTYPE_DES used too, which is what all v1 clients\n    * expect.  Therefore, IMHO, just encoding whatever enctype we get\n    * is safe.\n    */\n\n   if (!xdr_int32(xdrs, (int32_t *) objp))\n\treturn (FALSE);\n   return (TRUE);\n}\n\nbool_t\nxdr_krb5_salttype(XDR *xdrs, krb5_int32 *objp)\n{\n    if (!xdr_int32(xdrs, (int32_t *) objp))\n\treturn FALSE;\n    return TRUE;\n}\n\nbool_t\nxdr_krb5_keyblock(XDR *xdrs, krb5_keyblock *objp)\n{\n   /* XXX This only works because free_keyblock assumes ->contents\n      is allocated by malloc() */\n\n   if(!xdr_krb5_enctype(xdrs, &objp->enctype))\n      return FALSE;\n   if(!xdr_bytes(xdrs, (char **) &objp->contents, (unsigned int *)\n\t\t &objp->length, ~0))\n      return FALSE;\n   return TRUE;\n}\n\nbool_t\nxdr_krb5_string_attr(XDR *xdrs, krb5_string_attr *objp)\n{\n\tif (!xdr_nullstring(xdrs, &objp->key))\n\t\treturn FALSE;\n\tif (!xdr_nullstring(xdrs, &objp->value))\n\t\treturn FALSE;\n\tif (xdrs->x_op == XDR_DECODE &&\n\t    (objp->key == NULL || objp->value == NULL))\n\t\treturn FALSE;\n\treturn TRUE;\n}\n"], "fixing_code": ["/* -*- mode: c; c-file-style: \"bsd\"; indent-tabs-mode: t -*- */\n/*\n * Copyright 1993 OpenVision Technologies, Inc., All Rights Reserved\n */\n\n#include <gssrpc/rpc.h>\n#include <krb5.h>\n#include <errno.h>\n#include <kadm5/admin.h>\n#include <kadm5/kadm_rpc.h>\n#include <kadm5/admin_xdr.h>\n#include <stdlib.h>\n#include <string.h>\n\nstatic bool_t\n_xdr_kadm5_principal_ent_rec(XDR *xdrs, kadm5_principal_ent_rec *objp,\n\t\t\t     int v);\nstatic bool_t\n_xdr_kadm5_policy_ent_rec(XDR *xdrs, kadm5_policy_ent_rec *objp, int vers);\n\n/*\n * Function: xdr_ui_4\n *\n * Purpose: XDR function which serves as a wrapper for xdr_u_int32,\n * to prevent compiler warnings about type clashes between u_int32\n * and krb5_ui_4.\n */\nbool_t xdr_ui_4(XDR *xdrs, krb5_ui_4 *objp)\n{\n  /* Assumes that krb5_ui_4 and u_int32 are both four bytes long.\n     This should not be a harmful assumption. */\n  return xdr_u_int32(xdrs, (uint32_t *) objp);\n}\n\n\n/*\n * Function: xdr_nullstring\n *\n * Purpose: XDR function for \"strings\" that are either NULL-terminated\n * or NULL.\n */\nbool_t xdr_nullstring(XDR *xdrs, char **objp)\n{\n     u_int size;\n\n     if (xdrs->x_op == XDR_ENCODE) {\n\t  if (*objp == NULL)\n\t       size = 0;\n\t  else\n\t       size = strlen(*objp) + 1;\n     }\n     if (! xdr_u_int(xdrs, &size)) {\n\t  return FALSE;\n\t}\n     switch (xdrs->x_op) {\n     case XDR_DECODE:\n\t  if (size == 0) {\n\t       *objp = NULL;\n\t       return TRUE;\n\t  } else if (*objp == NULL) {\n\t       *objp = (char *) mem_alloc(size);\n\t       if (*objp == NULL) {\n\t\t    errno = ENOMEM;\n\t\t    return FALSE;\n\t       }\n\t  }\n\t  if (!xdr_opaque(xdrs, *objp, size))\n\t\t  return FALSE;\n\t  /* Check that the unmarshalled bytes are a C string. */\n\t  if ((*objp)[size - 1] != '\\0')\n\t\t  return FALSE;\n\t  if (memchr(*objp, '\\0', size - 1) != NULL)\n\t\t  return FALSE;\n\t  return TRUE;\n\n     case XDR_ENCODE:\n\t  if (size != 0)\n\t       return (xdr_opaque(xdrs, *objp, size));\n\t  return TRUE;\n\n     case XDR_FREE:\n\t  if (*objp != NULL)\n\t       mem_free(*objp, size);\n\t  *objp = NULL;\n\t  return TRUE;\n     }\n\n     return FALSE;\n}\n\n/*\n * Function: xdr_nulltype\n *\n * Purpose: XDR function for arbitrary pointer types that are either\n * NULL or contain data.\n */\nbool_t xdr_nulltype(XDR *xdrs, void **objp, xdrproc_t proc)\n{\n     bool_t null;\n\n     switch (xdrs->x_op) {\n     case XDR_DECODE:\n\t  if (!xdr_bool(xdrs, &null))\n\t      return FALSE;\n\t  if (null) {\n\t       *objp = NULL;\n\t       return TRUE;\n\t  }\n\t  return (*proc)(xdrs, objp);\n\n     case XDR_ENCODE:\n\t  if (*objp == NULL)\n\t       null = TRUE;\n\t  else\n\t       null = FALSE;\n\t  if (!xdr_bool(xdrs, &null))\n\t       return FALSE;\n\t  if (null == FALSE)\n\t       return (*proc)(xdrs, objp);\n\t  return TRUE;\n\n     case XDR_FREE:\n\t  if (*objp)\n\t       return (*proc)(xdrs, objp);\n\t  return TRUE;\n     }\n\n     return FALSE;\n}\n\nbool_t\nxdr_krb5_timestamp(XDR *xdrs, krb5_timestamp *objp)\n{\n  /* This assumes that int32 and krb5_timestamp are the same size.\n     This shouldn't be a problem, since we've got a unit test which\n     checks for this. */\n\tif (!xdr_int32(xdrs, (int32_t *) objp)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_krb5_kvno(XDR *xdrs, krb5_kvno *objp)\n{\n\treturn xdr_u_int(xdrs, objp);\n}\n\nbool_t\nxdr_krb5_deltat(XDR *xdrs, krb5_deltat *objp)\n{\n  /* This assumes that int32 and krb5_deltat are the same size.\n     This shouldn't be a problem, since we've got a unit test which\n     checks for this. */\n\tif (!xdr_int32(xdrs, (int32_t *) objp)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_krb5_flags(XDR *xdrs, krb5_flags *objp)\n{\n  /* This assumes that int32 and krb5_flags are the same size.\n     This shouldn't be a problem, since we've got a unit test which\n     checks for this. */\n\tif (!xdr_int32(xdrs, (int32_t *) objp)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_krb5_ui_4(XDR *xdrs, krb5_ui_4 *objp)\n{\n\tif (!xdr_u_int32(xdrs, (uint32_t *) objp)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_krb5_int16(XDR *xdrs, krb5_int16 *objp)\n{\n    int tmp;\n\n    tmp = (int) *objp;\n\n    if (!xdr_int(xdrs, &tmp))\n\treturn(FALSE);\n\n    *objp = (krb5_int16) tmp;\n\n    return(TRUE);\n}\n\n/*\n * Function: xdr_krb5_ui_2\n *\n * Purpose: XDR function which serves as a wrapper for xdr_u_int,\n * to prevent compiler warnings about type clashes between u_int\n * and krb5_ui_2.\n */\nbool_t\nxdr_krb5_ui_2(XDR *xdrs, krb5_ui_2 *objp)\n{\n    unsigned int tmp;\n\n    tmp = (unsigned int) *objp;\n\n    if (!xdr_u_int(xdrs, &tmp))\n\treturn(FALSE);\n\n    *objp = (krb5_ui_2) tmp;\n\n    return(TRUE);\n}\n\n\n\nstatic bool_t xdr_krb5_boolean(XDR *xdrs, krb5_boolean *kbool)\n{\n\tbool_t val;\n\n\tswitch (xdrs->x_op) {\n\tcase XDR_DECODE:\n\t     if (!xdr_bool(xdrs, &val))\n\t\t     return FALSE;\n\n\t     *kbool = (val == FALSE) ? FALSE : TRUE;\n\t     return TRUE;\n\n\tcase XDR_ENCODE:\n\t     val = *kbool ? TRUE : FALSE;\n\t     return xdr_bool(xdrs, &val);\n\n\tcase XDR_FREE:\n\t     return TRUE;\n\t}\n\n\treturn FALSE;\n}\n\nbool_t xdr_krb5_key_data_nocontents(XDR *xdrs, krb5_key_data *objp)\n{\n     /*\n      * Note that this function intentionally DOES NOT tranfer key\n      * length or contents!  xdr_krb5_key_data in adb_xdr.c does, but\n      * that is only for use within the server-side library.\n      */\n     unsigned int tmp;\n\n     if (xdrs->x_op == XDR_DECODE)\n\t  memset(objp, 0, sizeof(krb5_key_data));\n\n     if (!xdr_krb5_int16(xdrs, &objp->key_data_ver)) {\n\t  return (FALSE);\n     }\n     if (!xdr_krb5_ui_2(xdrs, &objp->key_data_kvno)) {\n\t  return (FALSE);\n     }\n     if (!xdr_krb5_int16(xdrs, &objp->key_data_type[0])) {\n\t  return (FALSE);\n     }\n     if (objp->key_data_ver > 1) {\n\t  if (!xdr_krb5_int16(xdrs, &objp->key_data_type[1])) {\n\t       return (FALSE);\n\t  }\n     }\n     /*\n      * kadm5_get_principal on the server side allocates and returns\n      * key contents when asked.  Even though this function refuses to\n      * transmit that data, it still has to *free* the data at the\n      * appropriate time to avoid a memory leak.\n      */\n     if (xdrs->x_op == XDR_FREE) {\n\t  tmp = (unsigned int) objp->key_data_length[0];\n\t  if (!xdr_bytes(xdrs, (char **) &objp->key_data_contents[0],\n\t\t\t &tmp, ~0))\n\t       return FALSE;\n\n\t  tmp = (unsigned int) objp->key_data_length[1];\n\t  if (!xdr_bytes(xdrs, (char **) &objp->key_data_contents[1],\n\t\t\t &tmp, ~0))\n\t       return FALSE;\n     }\n\n     return (TRUE);\n}\n\n\nbool_t\nxdr_krb5_key_salt_tuple(XDR *xdrs, krb5_key_salt_tuple *objp)\n{\n    if (!xdr_krb5_enctype(xdrs, &objp->ks_enctype))\n\treturn FALSE;\n    if (!xdr_krb5_salttype(xdrs, &objp->ks_salttype))\n\treturn FALSE;\n    return TRUE;\n}\n\nbool_t xdr_krb5_tl_data(XDR *xdrs, krb5_tl_data **tl_data_head)\n{\n     krb5_tl_data *tl, *tl2;\n     bool_t more;\n     unsigned int len;\n\n     switch (xdrs->x_op) {\n     case XDR_FREE:\n\t  tl = tl2 = *tl_data_head;\n\t  while (tl) {\n\t       tl2 = tl->tl_data_next;\n\t       free(tl->tl_data_contents);\n\t       free(tl);\n\t       tl = tl2;\n\t  }\n\t  *tl_data_head = NULL;\n\t  break;\n\n     case XDR_ENCODE:\n\t  tl = *tl_data_head;\n\t  while (1) {\n\t       more = (tl != NULL);\n\t       if (!xdr_bool(xdrs, &more))\n\t\t    return FALSE;\n\t       if (tl == NULL)\n\t\t    break;\n\t       if (!xdr_krb5_int16(xdrs, &tl->tl_data_type))\n\t\t    return FALSE;\n\t       len = tl->tl_data_length;\n\t       if (!xdr_bytes(xdrs, (char **) &tl->tl_data_contents, &len, ~0))\n\t\t    return FALSE;\n\t       tl = tl->tl_data_next;\n\t  }\n\t  break;\n\n     case XDR_DECODE:\n\t  tl = NULL;\n\t  while (1) {\n\t       if (!xdr_bool(xdrs, &more))\n\t\t    return FALSE;\n\t       if (more == FALSE)\n\t\t    break;\n\t       tl2 = (krb5_tl_data *) malloc(sizeof(krb5_tl_data));\n\t       if (tl2 == NULL)\n\t\t    return FALSE;\n\t       memset(tl2, 0, sizeof(krb5_tl_data));\n\t       if (!xdr_krb5_int16(xdrs, &tl2->tl_data_type))\n\t\t    return FALSE;\n\t       if (!xdr_bytes(xdrs, (char **)&tl2->tl_data_contents, &len, ~0))\n\t\t    return FALSE;\n\t       tl2->tl_data_length = len;\n\n\t       tl2->tl_data_next = tl;\n\t       tl = tl2;\n\t  }\n\n\t  *tl_data_head = tl;\n\t  break;\n     }\n\n     return TRUE;\n}\n\nbool_t\nxdr_kadm5_ret_t(XDR *xdrs, kadm5_ret_t *objp)\n{\n\tuint32_t tmp;\n\n\tif (xdrs->x_op == XDR_ENCODE)\n\t\ttmp = (uint32_t) *objp;\n\n\tif (!xdr_u_int32(xdrs, &tmp))\n\t\treturn (FALSE);\n\n\tif (xdrs->x_op == XDR_DECODE)\n\t\t*objp = (kadm5_ret_t) tmp;\n\n\treturn (TRUE);\n}\n\nbool_t xdr_kadm5_principal_ent_rec(XDR *xdrs,\n\t\t\t\t   kadm5_principal_ent_rec *objp)\n{\n     return _xdr_kadm5_principal_ent_rec(xdrs, objp, KADM5_API_VERSION_3);\n}\n\nstatic bool_t\n_xdr_kadm5_principal_ent_rec(XDR *xdrs, kadm5_principal_ent_rec *objp,\n\t\t\t     int v)\n{\n\tunsigned int n;\n\n\tif (!xdr_krb5_principal(xdrs, &objp->principal)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_timestamp(xdrs, &objp->princ_expire_time)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_timestamp(xdrs, &objp->last_pwd_change)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_timestamp(xdrs, &objp->pw_expiration)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_deltat(xdrs, &objp->max_life)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nulltype(xdrs, (void **) &objp->mod_name,\n\t\t\t  xdr_krb5_principal)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_timestamp(xdrs, &objp->mod_date)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_flags(xdrs, &objp->attributes)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_kvno(xdrs, &objp->kvno)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_kvno(xdrs, &objp->mkvno)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->policy)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->aux_attributes)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_deltat(xdrs, &objp->max_renewable_life)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_timestamp(xdrs, &objp->last_success)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_timestamp(xdrs, &objp->last_failed)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_kvno(xdrs, &objp->fail_auth_count)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_int16(xdrs, &objp->n_key_data)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_int16(xdrs, &objp->n_tl_data)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nulltype(xdrs, (void **) &objp->tl_data,\n\t\t\t  xdr_krb5_tl_data)) {\n\t\treturn FALSE;\n\t}\n\tn = objp->n_key_data;\n\tif (!xdr_array(xdrs, (caddr_t *) &objp->key_data,\n\t\t       &n, ~0, sizeof(krb5_key_data),\n\t\t       xdr_krb5_key_data_nocontents)) {\n\t\treturn (FALSE);\n\t}\n\n\treturn (TRUE);\n}\n\nstatic bool_t\n_xdr_kadm5_policy_ent_rec(XDR *xdrs, kadm5_policy_ent_rec *objp, int vers)\n{\n\tif (!xdr_nullstring(xdrs, &objp->policy)) {\n\t\treturn (FALSE);\n\t}\n\t/* these all used to be u_int32, but it's stupid for sized types\n\t   to be exposed at the api, and they're the same as longs on the\n\t   wire. */\n\tif (!xdr_long(xdrs, &objp->pw_min_life)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->pw_max_life)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->pw_min_length)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->pw_min_classes)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->pw_history_num)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->policy_refcnt)) {\n\t\treturn (FALSE);\n\t}\n\tif (xdrs->x_op == XDR_DECODE) {\n\t\tobjp->pw_max_fail = 0;\n\t\tobjp->pw_failcnt_interval = 0;\n\t\tobjp->pw_lockout_duration = 0;\n\t\tobjp->attributes = 0;\n\t\tobjp->max_life = 0;\n\t\tobjp->max_renewable_life = 0;\n\t\tobjp->allowed_keysalts = NULL;\n\t\tobjp->n_tl_data = 0;\n\t\tobjp->tl_data = NULL;\n\t}\n\tif (vers >= KADM5_API_VERSION_3) {\n\t\tif (!xdr_krb5_kvno(xdrs, &objp->pw_max_fail))\n\t\t\treturn (FALSE);\n\t\tif (!xdr_krb5_deltat(xdrs, &objp->pw_failcnt_interval))\n\t\t\treturn (FALSE);\n\t\tif (!xdr_krb5_deltat(xdrs, &objp->pw_lockout_duration))\n\t\t\treturn (FALSE);\n\t}\n\tif (vers >= KADM5_API_VERSION_4) {\n\t\tif (!xdr_krb5_flags(xdrs, &objp->attributes)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t\tif (!xdr_krb5_deltat(xdrs, &objp->max_life)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t\tif (!xdr_krb5_deltat(xdrs, &objp->max_renewable_life)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t\tif (!xdr_nullstring(xdrs, &objp->allowed_keysalts)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t\tif (!xdr_krb5_int16(xdrs, &objp->n_tl_data)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t\tif (!xdr_nulltype(xdrs, (void **) &objp->tl_data,\n\t\t\t\t  xdr_krb5_tl_data)) {\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_kadm5_policy_ent_rec(XDR *xdrs, kadm5_policy_ent_rec *objp)\n{\n\treturn _xdr_kadm5_policy_ent_rec(xdrs, objp, KADM5_API_VERSION_4);\n}\n\nbool_t\nxdr_cprinc_arg(XDR *xdrs, cprinc_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!_xdr_kadm5_principal_ent_rec(xdrs, &objp->rec,\n\t\t\t\t\t  objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->mask)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->passwd)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_cprinc3_arg(XDR *xdrs, cprinc3_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!_xdr_kadm5_principal_ent_rec(xdrs, &objp->rec,\n\t\t\t\t\t  objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->mask)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_array(xdrs, (caddr_t *)&objp->ks_tuple,\n\t\t       (unsigned int *)&objp->n_ks_tuple, ~0,\n\t\t       sizeof(krb5_key_salt_tuple),\n\t\t       xdr_krb5_key_salt_tuple)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->passwd)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_generic_ret(XDR *xdrs, generic_ret *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t\treturn (FALSE);\n\t}\n\n\treturn(TRUE);\n}\n\nbool_t\nxdr_dprinc_arg(XDR *xdrs, dprinc_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_mprinc_arg(XDR *xdrs, mprinc_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!_xdr_kadm5_principal_ent_rec(xdrs, &objp->rec,\n\t\t\t\t\t  objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->mask)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_rprinc_arg(XDR *xdrs, rprinc_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->src)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->dest)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gprincs_arg(XDR *xdrs, gprincs_arg *objp)\n{\n     if (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t  return (FALSE);\n     }\n     if (!xdr_nullstring(xdrs, &objp->exp)) {\n\t  return (FALSE);\n     }\n     return (TRUE);\n}\n\nbool_t\nxdr_gprincs_ret(XDR *xdrs, gprincs_ret *objp)\n{\n     if (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t  return (FALSE);\n     }\n     if (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t  return (FALSE);\n     }\n     if (objp->code == KADM5_OK) {\n\t  if (!xdr_int(xdrs, &objp->count)) {\n\t       return (FALSE);\n\t  }\n\t  if (!xdr_array(xdrs, (caddr_t *) &objp->princs,\n\t\t\t (unsigned int *) &objp->count, ~0,\n\t\t\t sizeof(char *), xdr_nullstring)) {\n\t       return (FALSE);\n\t  }\n     }\n\n     return (TRUE);\n}\n\nbool_t\nxdr_chpass_arg(XDR *xdrs, chpass_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->pass)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_chpass3_arg(XDR *xdrs, chpass3_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_boolean(xdrs, &objp->keepold)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_array(xdrs, (caddr_t *)&objp->ks_tuple,\n\t\t       (unsigned int*)&objp->n_ks_tuple, ~0,\n\t\t       sizeof(krb5_key_salt_tuple),\n\t\t       xdr_krb5_key_salt_tuple)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->pass)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_setv4key_arg(XDR *xdrs, setv4key_arg *objp)\n{\n\tunsigned int n_keys = 1;\n\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_array(xdrs, (caddr_t *) &objp->keyblock,\n\t\t       &n_keys, ~0,\n\t\t       sizeof(krb5_keyblock), xdr_krb5_keyblock)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_setkey_arg(XDR *xdrs, setkey_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_array(xdrs, (caddr_t *) &objp->keyblocks,\n\t\t       (unsigned int *) &objp->n_keys, ~0,\n\t\t       sizeof(krb5_keyblock), xdr_krb5_keyblock)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_setkey3_arg(XDR *xdrs, setkey3_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_boolean(xdrs, &objp->keepold)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_array(xdrs, (caddr_t *) &objp->ks_tuple,\n\t\t       (unsigned int *) &objp->n_ks_tuple, ~0,\n\t\t       sizeof(krb5_key_salt_tuple), xdr_krb5_key_salt_tuple)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_array(xdrs, (caddr_t *) &objp->keyblocks,\n\t\t       (unsigned int *) &objp->n_keys, ~0,\n\t\t       sizeof(krb5_keyblock), xdr_krb5_keyblock)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_chrand_arg(XDR *xdrs, chrand_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_chrand3_arg(XDR *xdrs, chrand3_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_boolean(xdrs, &objp->keepold)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_array(xdrs, (caddr_t *)&objp->ks_tuple,\n\t\t       (unsigned int*)&objp->n_ks_tuple, ~0,\n\t\t       sizeof(krb5_key_salt_tuple),\n\t\t       xdr_krb5_key_salt_tuple)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_chrand_ret(XDR *xdrs, chrand_ret *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t\treturn (FALSE);\n\t}\n\tif (objp->code == KADM5_OK) {\n\t\tif (!xdr_array(xdrs, (char **)&objp->keys,\n\t\t\t       (unsigned int *)&objp->n_keys, ~0,\n\t\t\t       sizeof(krb5_keyblock), xdr_krb5_keyblock))\n\t\t\treturn FALSE;\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gprinc_arg(XDR *xdrs, gprinc_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->mask)) {\n\t     return FALSE;\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gprinc_ret(XDR *xdrs, gprinc_ret *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t\treturn (FALSE);\n\t}\n\tif(objp->code == KADM5_OK)  {\n\t\tif (!_xdr_kadm5_principal_ent_rec(xdrs, &objp->rec,\n\t\t\t\t\t\t  objp->api_version)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_cpol_arg(XDR *xdrs, cpol_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!_xdr_kadm5_policy_ent_rec(xdrs, &objp->rec,\n\t\t\t\t       objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->mask)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_dpol_arg(XDR *xdrs, dpol_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->name)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_mpol_arg(XDR *xdrs, mpol_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!_xdr_kadm5_policy_ent_rec(xdrs, &objp->rec,\n\t\t\t\t       objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->mask)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gpol_arg(XDR *xdrs, gpol_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->name)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gpol_ret(XDR *xdrs, gpol_ret *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t\treturn (FALSE);\n\t}\n\tif(objp->code == KADM5_OK) {\n\t    if (!_xdr_kadm5_policy_ent_rec(xdrs, &objp->rec,\n\t\t\t\t\t   objp->api_version))\n\t\treturn (FALSE);\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gpols_arg(XDR *xdrs, gpols_arg *objp)\n{\n     if (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t  return (FALSE);\n     }\n     if (!xdr_nullstring(xdrs, &objp->exp)) {\n\t  return (FALSE);\n     }\n     return (TRUE);\n}\n\nbool_t\nxdr_gpols_ret(XDR *xdrs, gpols_ret *objp)\n{\n     if (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t  return (FALSE);\n     }\n     if (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t  return (FALSE);\n     }\n     if (objp->code == KADM5_OK) {\n\t  if (!xdr_int(xdrs, &objp->count)) {\n\t       return (FALSE);\n\t  }\n\t  if (!xdr_array(xdrs, (caddr_t *) &objp->pols,\n\t\t\t (unsigned int *) &objp->count, ~0,\n\t\t\t sizeof(char *), xdr_nullstring)) {\n\t       return (FALSE);\n\t  }\n     }\n\n     return (TRUE);\n}\n\nbool_t xdr_getprivs_ret(XDR *xdrs, getprivs_ret *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n     if (! xdr_kadm5_ret_t(xdrs, &objp->code) ||\n\t ! xdr_long(xdrs, &objp->privs))\n\t  return FALSE;\n\n     return TRUE;\n}\n\nbool_t\nxdr_purgekeys_arg(XDR *xdrs, purgekeys_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_int(xdrs, &objp->keepkvno)) {\n\t     return FALSE;\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gstrings_arg(XDR *xdrs, gstrings_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gstrings_ret(XDR *xdrs, gstrings_ret *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t\treturn (FALSE);\n\t}\n\tif (objp->code == KADM5_OK) {\n\t\tif (!xdr_int(xdrs, &objp->count)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t\tif (!xdr_array(xdrs, (caddr_t *) &objp->strings,\n\t\t\t       (unsigned int *) &objp->count, ~0,\n\t\t\t       sizeof(krb5_string_attr),\n\t\t\t       xdr_krb5_string_attr)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_sstring_arg(XDR *xdrs, sstring_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->key)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->value)) {\n\t\treturn (FALSE);\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_krb5_principal(XDR *xdrs, krb5_principal *objp)\n{\n    int\t    ret;\n    char\t    *p = NULL;\n    krb5_principal  pr = NULL;\n    static krb5_context context = NULL;\n\n    /* using a static context here is ugly, but should work\n       ok, and the other solutions are even uglier */\n\n    if (!context &&\n\tkadm5_init_krb5_context(&context))\n       return(FALSE);\n\n    switch(xdrs->x_op) {\n    case XDR_ENCODE:\n\tif (*objp) {\n\t     if((ret = krb5_unparse_name(context, *objp, &p)) != 0)\n\t\t  return FALSE;\n\t}\n\tif(!xdr_nullstring(xdrs, &p))\n\t    return FALSE;\n\tif (p) free(p);\n\tbreak;\n    case XDR_DECODE:\n\tif(!xdr_nullstring(xdrs, &p))\n\t    return FALSE;\n\tif (p) {\n\t     ret = krb5_parse_name(context, p, &pr);\n\t     if(ret != 0)\n\t\t  return FALSE;\n\t     *objp = pr;\n\t     free(p);\n\t} else\n\t     *objp = NULL;\n\tbreak;\n    case XDR_FREE:\n\tif(*objp != NULL)\n\t    krb5_free_principal(context, *objp);\n\t*objp = NULL;\n\tbreak;\n    }\n    return TRUE;\n}\n\nbool_t\nxdr_krb5_octet(XDR *xdrs, krb5_octet *objp)\n{\n   if (!xdr_u_char(xdrs, objp))\n\treturn (FALSE);\n   return (TRUE);\n}\n\nbool_t\nxdr_krb5_enctype(XDR *xdrs, krb5_enctype *objp)\n{\n   /*\n    * This used to be xdr_krb5_keytype, but keytypes and enctypes have\n    * been merged into only enctypes.  However, randkey_principal\n    * already ensures that only a key of ENCTYPE_DES_CBC_CRC will be\n    * returned to v1 clients, and ENCTYPE_DES_CBC_CRC has the same\n    * value as KEYTYPE_DES used too, which is what all v1 clients\n    * expect.  Therefore, IMHO, just encoding whatever enctype we get\n    * is safe.\n    */\n\n   if (!xdr_int32(xdrs, (int32_t *) objp))\n\treturn (FALSE);\n   return (TRUE);\n}\n\nbool_t\nxdr_krb5_salttype(XDR *xdrs, krb5_int32 *objp)\n{\n    if (!xdr_int32(xdrs, (int32_t *) objp))\n\treturn FALSE;\n    return TRUE;\n}\n\nbool_t\nxdr_krb5_keyblock(XDR *xdrs, krb5_keyblock *objp)\n{\n   /* XXX This only works because free_keyblock assumes ->contents\n      is allocated by malloc() */\n\n   if(!xdr_krb5_enctype(xdrs, &objp->enctype))\n      return FALSE;\n   if(!xdr_bytes(xdrs, (char **) &objp->contents, (unsigned int *)\n\t\t &objp->length, ~0))\n      return FALSE;\n   return TRUE;\n}\n\nbool_t\nxdr_krb5_string_attr(XDR *xdrs, krb5_string_attr *objp)\n{\n\tif (!xdr_nullstring(xdrs, &objp->key))\n\t\treturn FALSE;\n\tif (!xdr_nullstring(xdrs, &objp->value))\n\t\treturn FALSE;\n\tif (xdrs->x_op == XDR_DECODE &&\n\t    (objp->key == NULL || objp->value == NULL))\n\t\treturn FALSE;\n\treturn TRUE;\n}\n"], "filenames": ["src/lib/kadm5/kadm_rpc_xdr.c"], "buggy_code_start_loc": [67], "buggy_code_end_loc": [68], "fixing_code_start_loc": [67], "fixing_code_end_loc": [75], "type": "CWE-125", "message": "The xdr_nullstring function in lib/kadm5/kadm_rpc_xdr.c in kadmind in MIT Kerberos 5 (aka krb5) before 1.13.4 and 1.14.x before 1.14.1 does not verify whether '\\0' characters exist as expected, which allows remote authenticated users to obtain sensitive information or cause a denial of service (out-of-bounds read) via a crafted string.", "other": {"cve": {"id": "CVE-2015-8629", "sourceIdentifier": "cve@mitre.org", "published": "2016-02-13T02:59:00.133", "lastModified": "2021-02-02T19:24:48.413", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The xdr_nullstring function in lib/kadm5/kadm_rpc_xdr.c in kadmind in MIT Kerberos 5 (aka krb5) before 1.13.4 and 1.14.x before 1.14.1 does not verify whether '\\0' characters exist as expected, which allows remote authenticated users to obtain sensitive information or cause a denial of service (out-of-bounds read) via a crafted string."}, {"lang": "es", "value": "La funci\u00f3n xdr_nullstring en lib/kadm5/kadm_rpc_xdr.c en kadmind in MIT Kerberos 5 (tambi\u00e9n conocido como krb5) en versiones anteriores a 1.13.4 y 1.14.x en versiones anteriores a 1.14.1 no verifica si existen caracteres '\\0' seg\u00fan lo esperado, lo que permite a usuarios remotos autenticados obtener informaci\u00f3n sensible o causar una denegaci\u00f3n de servicio (lectura fuera de rango) a trav\u00e9s de una cadena manipulada."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.13.4", "matchCriteriaId": "1169B718-3132-4984-9746-320524D141E5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.14", "versionEndExcluding": "1.14.1", "matchCriteriaId": "FFB93D70-A16F-4716-A5EE-7854D0974AC9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:oracle:linux:6:-:*:*:*:*:*:*", "matchCriteriaId": "D7B037A8-72A6-4DFF-94B2-D688A5F6F876"}, {"vulnerable": true, "criteria": "cpe:2.3:o:oracle:linux:7:-:*:*:*:*:*:*", "matchCriteriaId": "44B8FEDF-6CB0-46E9-9AD7-4445B001C158"}, {"vulnerable": true, "criteria": "cpe:2.3:o:oracle:solaris:10:*:*:*:*:*:*:*", "matchCriteriaId": "964B57CD-CB8A-4520-B358-1C93EC5EF2DC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:oracle:solaris:11.3:*:*:*:*:*:*:*", "matchCriteriaId": "79A602C5-61FE-47BA-9786-F045B6C6DBA8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.1:*:*:*:*:*:*:*", "matchCriteriaId": "4863BE36-D16A-4D75-90D9-FD76DB5B48B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.2:*:*:*:*:*:*:*", "matchCriteriaId": "03117DF1-3BEC-4B8D-AD63-DBBDB2126081"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "EE249E1B-A1FD-4E08-AA71-A0E1F10FFE97"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:6.7:*:*:*:*:*:*:*", "matchCriteriaId": "967EC28A-607F-48F4-AD64-5E3041C768F0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.2:*:*:*:*:*:*:*", "matchCriteriaId": "AE1D81A1-CD24-4B17-8AFD-DC95E90AD7D0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "807C024A-F8E8-4B48-A349-4C68CD252CA1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "F96E3779-F56A-45FF-BB3D-4980527D721E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.5:*:*:*:*:*:*:*", "matchCriteriaId": "0CF73560-2F5B-4723-A8A1-9AADBB3ADA00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "5BF3C7A5-9117-42C7-BEA1-4AA378A582EF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "83737173-E12E-4641-BC49-0BD84A6B29D0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "9BBCD86A-E6C7-4444-9D74-F861084090F0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.2:*:*:*:*:*:*:*", "matchCriteriaId": "1C8D871B-AEA1-4407-AEE3-47EC782250FF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "98381E61-F082-4302-B51F-5648884F998B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "D99A687E-EAE6-417E-A88E-D0082BC194CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B353CE99-D57C-465B-AAB0-73EF581127D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "7431ABC1-9252-419E-8CC1-311B41360078"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.2:*:*:*:*:*:*:*", "matchCriteriaId": "6755B6AD-0422-467B-8115-34A60B1D1A40"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "24C0F4E1-C52C-41E0-9F14-F83ADD5CC7ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B76AA310-FEC7-497F-AF04-C3EC1E76C4CC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "17F256A9-D3B9-4C72-B013-4EFD878BFEA8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "E5ED5807-55B7-47C5-97A6-03233F4FBC3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}], "references": [{"url": "http://krbdev.mit.edu/rt/Ticket/Display.html?id=8341", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2016-02/msg00059.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2016-02/msg00110.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-0493.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-0532.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2016/dsa-3466", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/topics/security/bulletinapr2016-2952098.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/topics/security/linuxbulletinapr2016-2952096.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/82801", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1034914", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/krb5/krb5/commit/df17a1224a3406f57477bcd372c61e04c0e5a5bb", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/krb5/krb5/commit/df17a1224a3406f57477bcd372c61e04c0e5a5bb"}}