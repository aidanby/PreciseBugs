{"buggy_code": ["use strict;\nuse warnings;\npackage Email::Address;\n# ABSTRACT: RFC 2822 Address Parsing and Creation\n\nour $COMMENT_NEST_LEVEL ||= 2;\nour $STRINGIFY          ||= 'format';\nour $COLLAPSE_SPACES      = 1 unless defined $COLLAPSE_SPACES; # I miss //=\n\n=head1 SYNOPSIS\n\n  use Email::Address;\n\n  my @addresses = Email::Address->parse($line);\n  my $address   = Email::Address->new(Casey => 'casey@localhost');\n\n  print $address->format;\n\n=head1 VERSION\n\nversion 1.898\n\n=head1 DESCRIPTION\n\nThis class implements a regex-based RFC 2822 parser that locates email\naddresses in strings and returns a list of C<Email::Address> objects found.\nAlternatively you may construct objects manually. The goal of this software is\nto be correct, and very very fast.\n\n=cut\n\nmy $CTL            = q{\\x00-\\x1F\\x7F};\nmy $special        = q{()<>\\\\[\\\\]:;@\\\\\\\\,.\"};\n\nmy $text           = qr/[^\\x0A\\x0D]/;\n\nmy $quoted_pair    = qr/\\\\$text/;\n\nmy $ctext          = qr/(?>[^()\\\\]+)/;\nmy ($ccontent, $comment) = (q{})x2;\nfor (1 .. $COMMENT_NEST_LEVEL) {\n  $ccontent = qr/$ctext|$quoted_pair|$comment/;\n  $comment  = qr/\\s*\\((?:\\s*$ccontent)*\\s*\\)\\s*/;\n}\nmy $cfws           = qr/$comment|\\s+/;\n\nmy $atext          = qq/[^$CTL$special\\\\s]/;\nmy $atom           = qr/$cfws*$atext+$cfws*/;\nmy $dot_atom_text  = qr/$atext+(?:\\.$atext+)*/;\nmy $dot_atom       = qr/$cfws*$dot_atom_text$cfws*/;\n\nmy $qtext          = qr/[^\\\\\"]/;\nmy $qcontent       = qr/$qtext|$quoted_pair/;\nmy $quoted_string  = qr/$cfws*\"$qcontent+\"$cfws*/;\n\nmy $word           = qr/$atom|$quoted_string/;\n\n# XXX: This ($phrase) used to just be: my $phrase = qr/$word+/; It was changed\n# to resolve bug 22991, creating a significant slowdown.  Given current speed\n# problems.  Once 16320 is resolved, this section should be dealt with.\n# -- rjbs, 2006-11-11\n#my $obs_phrase     = qr/$word(?:$word|\\.|$cfws)*/;\n\n# XXX: ...and the above solution caused endless problems (never returned) when\n# examining this address, now in a test:\n#   admin+=E6=96=B0=E5=8A=A0=E5=9D=A1_Weblog-- ATAT --test.socialtext.com\n# So we disallow the hateful CFWS in this context for now.  Of modern mail\n# agents, only Apple Web Mail 2.0 is known to produce obs-phrase.\n# -- rjbs, 2006-11-19\nmy $simple_word    = qr/$atom|\\.|\\s*\"$qcontent+\"\\s*/;\nmy $obs_phrase     = qr/$simple_word+/;\n\nmy $phrase         = qr/$obs_phrase|(?:$word+)/;\n\nmy $local_part     = qr/$dot_atom|$quoted_string/;\nmy $dtext          = qr/[^\\[\\]\\\\]/;\nmy $dcontent       = qr/$dtext|$quoted_pair/;\nmy $domain_literal = qr/$cfws*\\[(?:\\s*$dcontent)*\\s*\\]$cfws*/;\nmy $domain         = qr/$dot_atom|$domain_literal/;\n\nmy $display_name   = $phrase;\n\n=head2 Package Variables\n\nB<ACHTUNG!>  Email isn't easy (if even possible) to parse with a regex, I<at\nleast> if you're on a C<perl> prior to 5.10.0.  Providing regular expressions\nfor use by other programs isn't a great idea, because it makes it hard to\nimprove the parser without breaking the \"it's a regex\" feature.  Using these\nregular expressions is not encouraged, and methods like C<<\nEmail::Address->is_addr_spec >> should be provided in the future.\n\nSeveral regular expressions used in this package are useful to others.\nFor convenience, these variables are declared as package variables that\nyou may access from your program.\n\nThese regular expressions conform to the rules specified in RFC 2822.\n\nYou can access these variables using the full namespace. If you want\nshort names, define them yourself.\n\n  my $addr_spec = $Email::Address::addr_spec;\n\n=over 4\n\n=item $Email::Address::addr_spec\n\nThis regular expression defined what an email address is allowed to\nlook like.\n\n=item $Email::Address::angle_addr\n\nThis regular expression defines an C<$addr_spec> wrapped in angle\nbrackets.\n\n=item $Email::Address::name_addr\n\nThis regular expression defines what an email address can look like\nwith an optional preceding display name, also known as the C<phrase>.\n\n=item $Email::Address::mailbox\n\nThis is the complete regular expression defining an RFC 2822 email\naddress with an optional preceding display name and optional\nfollowing comment.\n\n=back\n\n=cut\n\nour $addr_spec  = qr/$local_part\\@$domain/;\nour $angle_addr = qr/$cfws*<$addr_spec>$cfws*/;\nour $name_addr  = qr/(?>$display_name?)$angle_addr/;\nour $mailbox    = qr/(?:$name_addr|$addr_spec)$comment*/;\n\nsub _PHRASE   () { 0 }\nsub _ADDRESS  () { 1 }\nsub _COMMENT  () { 2 }\nsub _ORIGINAL () { 3 }\nsub _IN_CACHE () { 4 }\n\nsub __dump {\n  return {\n    phrase   => $_[0][_PHRASE],\n    address  => $_[0][_ADDRESS],\n    comment  => $_[0][_COMMENT],\n    original => $_[0][_ORIGINAL],\n  }\n}\n\n=head2 Class Methods\n\n=over\n\n=item parse\n\n  my @addrs = Email::Address->parse(\n    q[me@local, Casey <me@local>, \"Casey\" <me@local> (West)]\n  );\n\nThis method returns a list of C<Email::Address> objects it finds in the input\nstring.  B<Please note> that it returns a list, and expects that it may find\nmultiple addresses.  The behavior in scalar context is undefined.\n\nThe specification for an email address allows for infinitely nestable comments.\nThat's nice in theory, but a little over done.  By default this module allows\nfor two (C<2>) levels of nested comments. If you think you need more, modify\nthe C<$Email::Address::COMMENT_NEST_LEVEL> package variable to allow more.\n\n  $Email::Address::COMMENT_NEST_LEVEL = 10; # I'm deep\n\nThe reason for this hardly-limiting limitation is simple: efficiency.\n\nLong strings of whitespace can be problematic for this module to parse, a bug\nwhich has not yet been adequately addressed.  The default behavior is now to\ncollapse multiple spaces into a single space, which avoids this problem.  To\nprevent this behavior, set C<$Email::Address::COLLAPSE_SPACES> to zero.  This\nvariable will go away when the bug is resolved properly.\n\nIn accordance with RFC 822 and its descendants, this module demands that email\naddresses be ASCII only.  Any non-ASCII content in the parsed addresses will\ncause the parser to return no results.\n\n=cut\n\nour (%PARSE_CACHE, %FORMAT_CACHE, %NAME_CACHE);\nmy $NOCACHE;\n\nsub __get_cached_parse {\n    return if $NOCACHE;\n\n    my ($class, $line) = @_;\n\n    return @{$PARSE_CACHE{$line}} if exists $PARSE_CACHE{$line};\n    return;\n}\n\nsub __cache_parse {\n    return if $NOCACHE;\n\n    my ($class, $line, $addrs) = @_;\n\n    $PARSE_CACHE{$line} = $addrs;\n}\n\nsub parse {\n    my ($class, $line) = @_;\n    return unless $line;\n\n    $line =~ s/[ \\t]+/ /g if $COLLAPSE_SPACES;\n\n    if (my @cached = $class->__get_cached_parse($line)) {\n        return @cached;\n    }\n\n    my (@mailboxes) = ($line =~ /$mailbox/go);\n    my @addrs;\n    foreach (@mailboxes) {\n      my $original = $_;\n\n      my @comments = /($comment)/go;\n      s/$comment//go if @comments;\n\n      my ($user, $host, $com);\n      ($user, $host) = ($1, $2) if s/<($local_part)\\@($domain)>\\s*\\z//o;\n      if (! defined($user) || ! defined($host)) {\n          s/($local_part)\\@($domain)//o;\n          ($user, $host) = ($1, $2);\n      }\n\n      next if $user =~ /\\P{ASCII}/;\n      next if $host =~ /\\P{ASCII}/;\n\n      my ($phrase)       = /($display_name)/o;\n\n      for ( $phrase, $host, $user, @comments ) {\n        next unless defined $_;\n        s/^\\s+//;\n        s/\\s+$//;\n        $_ = undef unless length $_;\n      }\n\n      my $new_comment = join q{ }, @comments;\n      push @addrs,\n        $class->new($phrase, \"$user\\@$host\", $new_comment, $original);\n      $addrs[-1]->[_IN_CACHE] = [ \\$line, $#addrs ]\n    }\n\n    $class->__cache_parse($line, \\@addrs);\n    return @addrs;\n}\n\n=item new\n\n  my $address = Email::Address->new(undef, 'casey@local');\n  my $address = Email::Address->new('Casey West', 'casey@local');\n  my $address = Email::Address->new(undef, 'casey@local', '(Casey)');\n\nConstructs and returns a new C<Email::Address> object. Takes four\npositional arguments: phrase, email, and comment, and original string.\n\nThe original string should only really be set using C<parse>.\n\n=cut\n\nsub new {\n  my ($class, $phrase, $email, $comment, $orig) = @_;\n  $phrase =~ s/\\A\"(.+)\"\\z/$1/ if $phrase;\n\n  bless [ $phrase, $email, $comment, $orig ] => $class;\n}\n\n=item purge_cache\n\n  Email::Address->purge_cache;\n\nOne way this module stays fast is with internal caches. Caches live\nin memory and there is the remote possibility that you will have a\nmemory problem. On the off chance that you think you're one of those\npeople, this class method will empty those caches.\n\nI've loaded over 12000 objects and not encountered a memory problem.\n\n=cut\n\nsub purge_cache {\n    %NAME_CACHE   = ();\n    %FORMAT_CACHE = ();\n    %PARSE_CACHE  = ();\n}\n\n=item disable_cache\n\n=item enable_cache\n\n  Email::Address->disable_cache if memory_low();\n\nIf you'd rather not cache address parses at all, you can disable (and\nre-enable) the Email::Address cache with these methods.  The cache is enabled\nby default.\n\n=cut\n\nsub disable_cache {\n  my ($class) = @_;\n  $class->purge_cache;\n  $NOCACHE = 1;\n}\n\nsub enable_cache {\n  $NOCACHE = undef;\n}\n\n=back\n\n=head2 Instance Methods\n\n=over 4\n\n=item phrase\n\n  my $phrase = $address->phrase;\n  $address->phrase( \"Me oh my\" );\n\nAccessor and mutator for the phrase portion of an address.\n\n=item address\n\n  my $addr = $address->address;\n  $addr->address( \"me@PROTECTED.com\" );\n\nAccessor and mutator for the address portion of an address.\n\n=item comment\n\n  my $comment = $address->comment;\n  $address->comment( \"(Work address)\" );\n\nAccessor and mutator for the comment portion of an address.\n\n=item original\n\n  my $orig = $address->original;\n\nAccessor for the original address found when parsing, or passed\nto C<new>.\n\n=item host\n\n  my $host = $address->host;\n\nAccessor for the host portion of an address's address.\n\n=item user\n\n  my $user = $address->user;\n\nAccessor for the user portion of an address's address.\n\n=cut\n\nBEGIN {\n  my %_INDEX = (\n    phrase   => _PHRASE,\n    address  => _ADDRESS,\n    comment  => _COMMENT,\n    original => _ORIGINAL,\n  );\n\n  for my $method (keys %_INDEX) {\n    no strict 'refs';\n    my $index = $_INDEX{ $method };\n    *$method = sub {\n      if ($_[1]) {\n        if ($_[0][_IN_CACHE]) {\n          my $replicant = bless [ @{$_[0]} ] => ref $_[0];\n          $PARSE_CACHE{ ${ $_[0][_IN_CACHE][0] } }[ $_[0][_IN_CACHE][1] ]\n            = $replicant;\n          $_[0][_IN_CACHE] = undef;\n        }\n        $_[0]->[ $index ] = $_[1];\n      } else {\n        $_[0]->[ $index ];\n      }\n    };\n  }\n}\n\nsub host { ($_[0]->[_ADDRESS] =~ /\\@($domain)/o)[0]     }\nsub user { ($_[0]->[_ADDRESS] =~ /($local_part)\\@/o)[0] }\n\n=pod\n\n=item format\n\n  my $printable = $address->format;\n\nReturns a properly formatted RFC 2822 address representing the\nobject.\n\n=cut\n\nsub format {\n    my $cache_str = do { no warnings 'uninitialized'; \"@{$_[0]}\" };\n    return $FORMAT_CACHE{$cache_str} if exists $FORMAT_CACHE{$cache_str};\n    $FORMAT_CACHE{$cache_str} = $_[0]->_format;\n}\n\nsub _format {\n    my ($self) = @_;\n\n    unless (\n      defined $self->[_PHRASE] && length $self->[_PHRASE]\n      ||\n      defined $self->[_COMMENT] && length $self->[_COMMENT]\n    ) {\n        return defined $self->[_ADDRESS] ? $self->[_ADDRESS] : '';\n    }\n\n    my $comment = defined $self->[_COMMENT] ? $self->[_COMMENT] : '';\n    $comment = \"($comment)\" if length $comment and $comment !~ /\\A\\(.*\\)\\z/;\n\n    my $format = sprintf q{%s <%s> %s},\n                 $self->_enquoted_phrase,\n                 (defined $self->[_ADDRESS] ? $self->[_ADDRESS] : ''),\n                 $comment;\n\n    $format =~ s/^\\s+//;\n    $format =~ s/\\s+$//;\n\n    return $format;\n}\n\nsub _enquoted_phrase {\n  my ($self) = @_;\n\n  my $phrase = $self->[_PHRASE];\n\n  return '' unless defined $phrase and length $phrase;\n\n  # if it's encoded -- rjbs, 2007-02-28\n  return $phrase if $phrase =~ /\\A=\\?.+\\?=\\z/;\n\n  $phrase =~ s/\\A\"(.+)\"\\z/$1/;\n  $phrase =~ s/([\\\\\"])/\\\\$1/g;\n\n  return qq{\"$phrase\"};\n}\n\n=item name\n\n  my $name = $address->name;\n\nThis method tries very hard to determine the name belonging to the address.\nFirst the C<phrase> is checked. If that doesn't work out the C<comment>\nis looked into. If that still doesn't work out, the C<user> portion of\nthe C<address> is returned.\n\nThis method does B<not> try to massage any name it identifies and instead\nleaves that up to someone else. Who is it to decide if someone wants their\nname capitalized, or if they're Irish?\n\n=cut\n\nsub name {\n    my $cache_str = do { no warnings 'uninitialized'; \"@{$_[0]}\" };\n    return $NAME_CACHE{$cache_str} if exists $NAME_CACHE{$cache_str};\n\n    my ($self) = @_;\n    my $name = q{};\n    if ( $name = $self->[_PHRASE] ) {\n        $name =~ s/^\"//;\n        $name =~ s/\"$//;\n        $name =~ s/($quoted_pair)/substr $1, -1/goe;\n    } elsif ( $name = $self->[_COMMENT] ) {\n        $name =~ s/^\\(//;\n        $name =~ s/\\)$//;\n        $name =~ s/($quoted_pair)/substr $1, -1/goe;\n        $name =~ s/$comment/ /go;\n    } else {\n        ($name) = $self->[_ADDRESS] =~ /($local_part)\\@/o;\n    }\n    $NAME_CACHE{$cache_str} = $name;\n}\n\n=back\n\n=head2 Overloaded Operators\n\n=over 4\n\n=item stringify\n\n  print \"I have your email address, $address.\";\n\nObjects stringify to C<format> by default. It's possible that you don't\nlike that idea. Okay, then, you can change it by modifying\nC<$Email:Address::STRINGIFY>. Please consider modifying this package\nvariable using C<local>. You might step on someone else's toes if you\ndon't.\n\n  {\n    local $Email::Address::STRINGIFY = 'host';\n    print \"I have your address, $address.\";\n    #   geeknest.com\n  }\n  print \"I have your address, $address.\";\n  #   \"Casey West\" <casey@geeknest.com>\n\nModifying this package variable is now deprecated. Subclassing is now the\nrecommended approach.\n\n=cut\n\nsub as_string {\n  warn 'altering $Email::Address::STRINGIFY is deprecated; subclass instead'\n    if $STRINGIFY ne 'format';\n\n  $_[0]->can($STRINGIFY)->($_[0]);\n}\n\nuse overload '\"\"' => 'as_string', fallback => 1;\n\n=pod\n\n=back\n\n=cut\n\n1;\n\n__END__\n\n=head2 Did I Mention Fast?\n\nOn his 1.8GHz Apple MacBook, rjbs gets these results:\n\n  $ perl -Ilib bench/ea-vs-ma.pl bench/corpus.txt 5\n                   Rate  Mail::Address Email::Address\n  Mail::Address  2.59/s             --           -44%\n  Email::Address 4.59/s            77%             --\n\n  $ perl -Ilib bench/ea-vs-ma.pl bench/corpus.txt 25\n                   Rate  Mail::Address Email::Address\n  Mail::Address  2.58/s             --           -67%\n  Email::Address 7.84/s           204%             --\n\n  $ perl -Ilib bench/ea-vs-ma.pl bench/corpus.txt 50\n                   Rate  Mail::Address Email::Address\n  Mail::Address  2.57/s             --           -70%\n  Email::Address 8.53/s           232%             --\n\n...unfortunately, a known bug causes a loss of speed the string to parse has\ncertain known characteristics, and disabling cache will also degrade\nperformance.\n\n=head1 ACKNOWLEDGEMENTS\n\nThanks to Kevin Riggle and Tatsuhiko Miyagawa for tests for annoying\nphrase-quoting bugs!\n\n=cut\n\n"], "fixing_code": ["use strict;\nuse warnings;\npackage Email::Address;\n# ABSTRACT: RFC 2822 Address Parsing and Creation\n\nour $COMMENT_NEST_LEVEL ||= 2;\nour $STRINGIFY          ||= 'format';\nour $COLLAPSE_SPACES      = 1 unless defined $COLLAPSE_SPACES; # I miss //=\n\n=head1 SYNOPSIS\n\n  use Email::Address;\n\n  my @addresses = Email::Address->parse($line);\n  my $address   = Email::Address->new(Casey => 'casey@localhost');\n\n  print $address->format;\n\n=head1 VERSION\n\nversion 1.898\n\n=head1 DESCRIPTION\n\nThis class implements a regex-based RFC 2822 parser that locates email\naddresses in strings and returns a list of C<Email::Address> objects found.\nAlternatively you may construct objects manually. The goal of this software is\nto be correct, and very very fast.\n\n=cut\n\nmy $CTL            = q{\\x00-\\x1F\\x7F};\nmy $special        = q{()<>\\\\[\\\\]:;@\\\\\\\\,.\"};\n\nmy $text           = qr/[^\\x0A\\x0D]/;\n\nmy $quoted_pair    = qr/\\\\$text/;\n\nmy $ctext          = qr/(?>[^()\\\\]+)/;\nmy ($ccontent, $comment) = (q{})x2;\nfor (1 .. $COMMENT_NEST_LEVEL) {\n  $ccontent = qr/$ctext|$quoted_pair|$comment/;\n  $comment  = qr/\\s*\\((?:\\s*$ccontent)*\\s*\\)\\s*/;\n}\nmy $cfws           = qr/$comment|\\s+/;\n\nmy $atext          = qq/[^$CTL$special\\\\s]/;\nmy $atom           = qr/$cfws*$atext+$cfws*/;\nmy $dot_atom_text  = qr/$atext+(?:\\.$atext+)*/;\nmy $dot_atom       = qr/$cfws*$dot_atom_text$cfws*/;\n\nmy $qtext          = qr/[^\\\\\"]/;\nmy $qcontent       = qr/$qtext|$quoted_pair/;\nmy $quoted_string  = qr/$cfws*\"$qcontent*\"$cfws*/;\n\nmy $word           = qr/$atom|$quoted_string/;\n\n# XXX: This ($phrase) used to just be: my $phrase = qr/$word+/; It was changed\n# to resolve bug 22991, creating a significant slowdown.  Given current speed\n# problems.  Once 16320 is resolved, this section should be dealt with.\n# -- rjbs, 2006-11-11\n#my $obs_phrase     = qr/$word(?:$word|\\.|$cfws)*/;\n\n# XXX: ...and the above solution caused endless problems (never returned) when\n# examining this address, now in a test:\n#   admin+=E6=96=B0=E5=8A=A0=E5=9D=A1_Weblog-- ATAT --test.socialtext.com\n# So we disallow the hateful CFWS in this context for now.  Of modern mail\n# agents, only Apple Web Mail 2.0 is known to produce obs-phrase.\n# -- rjbs, 2006-11-19\nmy $simple_word    = qr/$atom|\\.|\\s*\"$qcontent+\"\\s*/;\nmy $obs_phrase     = qr/$simple_word+/;\n\nmy $phrase         = qr/$obs_phrase|(?:$word+)/;\n\nmy $local_part     = qr/$dot_atom|$quoted_string/;\nmy $dtext          = qr/[^\\[\\]\\\\]/;\nmy $dcontent       = qr/$dtext|$quoted_pair/;\nmy $domain_literal = qr/$cfws*\\[(?:\\s*$dcontent)*\\s*\\]$cfws*/;\nmy $domain         = qr/$dot_atom|$domain_literal/;\n\nmy $display_name   = $phrase;\n\n=head2 Package Variables\n\nB<ACHTUNG!>  Email isn't easy (if even possible) to parse with a regex, I<at\nleast> if you're on a C<perl> prior to 5.10.0.  Providing regular expressions\nfor use by other programs isn't a great idea, because it makes it hard to\nimprove the parser without breaking the \"it's a regex\" feature.  Using these\nregular expressions is not encouraged, and methods like C<<\nEmail::Address->is_addr_spec >> should be provided in the future.\n\nSeveral regular expressions used in this package are useful to others.\nFor convenience, these variables are declared as package variables that\nyou may access from your program.\n\nThese regular expressions conform to the rules specified in RFC 2822.\n\nYou can access these variables using the full namespace. If you want\nshort names, define them yourself.\n\n  my $addr_spec = $Email::Address::addr_spec;\n\n=over 4\n\n=item $Email::Address::addr_spec\n\nThis regular expression defined what an email address is allowed to\nlook like.\n\n=item $Email::Address::angle_addr\n\nThis regular expression defines an C<$addr_spec> wrapped in angle\nbrackets.\n\n=item $Email::Address::name_addr\n\nThis regular expression defines what an email address can look like\nwith an optional preceding display name, also known as the C<phrase>.\n\n=item $Email::Address::mailbox\n\nThis is the complete regular expression defining an RFC 2822 email\naddress with an optional preceding display name and optional\nfollowing comment.\n\n=back\n\n=cut\n\nour $addr_spec  = qr/$local_part\\@$domain/;\nour $angle_addr = qr/$cfws*<$addr_spec>$cfws*/;\nour $name_addr  = qr/(?>$display_name?)$angle_addr/;\nour $mailbox    = qr/(?:$name_addr|$addr_spec)$comment*/;\n\nsub _PHRASE   () { 0 }\nsub _ADDRESS  () { 1 }\nsub _COMMENT  () { 2 }\nsub _ORIGINAL () { 3 }\nsub _IN_CACHE () { 4 }\n\nsub __dump {\n  return {\n    phrase   => $_[0][_PHRASE],\n    address  => $_[0][_ADDRESS],\n    comment  => $_[0][_COMMENT],\n    original => $_[0][_ORIGINAL],\n  }\n}\n\n=head2 Class Methods\n\n=over\n\n=item parse\n\n  my @addrs = Email::Address->parse(\n    q[me@local, Casey <me@local>, \"Casey\" <me@local> (West)]\n  );\n\nThis method returns a list of C<Email::Address> objects it finds in the input\nstring.  B<Please note> that it returns a list, and expects that it may find\nmultiple addresses.  The behavior in scalar context is undefined.\n\nThe specification for an email address allows for infinitely nestable comments.\nThat's nice in theory, but a little over done.  By default this module allows\nfor two (C<2>) levels of nested comments. If you think you need more, modify\nthe C<$Email::Address::COMMENT_NEST_LEVEL> package variable to allow more.\n\n  $Email::Address::COMMENT_NEST_LEVEL = 10; # I'm deep\n\nThe reason for this hardly-limiting limitation is simple: efficiency.\n\nLong strings of whitespace can be problematic for this module to parse, a bug\nwhich has not yet been adequately addressed.  The default behavior is now to\ncollapse multiple spaces into a single space, which avoids this problem.  To\nprevent this behavior, set C<$Email::Address::COLLAPSE_SPACES> to zero.  This\nvariable will go away when the bug is resolved properly.\n\nIn accordance with RFC 822 and its descendants, this module demands that email\naddresses be ASCII only.  Any non-ASCII content in the parsed addresses will\ncause the parser to return no results.\n\n=cut\n\nour (%PARSE_CACHE, %FORMAT_CACHE, %NAME_CACHE);\nmy $NOCACHE;\n\nsub __get_cached_parse {\n    return if $NOCACHE;\n\n    my ($class, $line) = @_;\n\n    return @{$PARSE_CACHE{$line}} if exists $PARSE_CACHE{$line};\n    return;\n}\n\nsub __cache_parse {\n    return if $NOCACHE;\n\n    my ($class, $line, $addrs) = @_;\n\n    $PARSE_CACHE{$line} = $addrs;\n}\n\nsub parse {\n    my ($class, $line) = @_;\n    return unless $line;\n\n    $line =~ s/[ \\t]+/ /g if $COLLAPSE_SPACES;\n\n    if (my @cached = $class->__get_cached_parse($line)) {\n        return @cached;\n    }\n\n    my (@mailboxes) = ($line =~ /$mailbox/go);\n    my @addrs;\n    foreach (@mailboxes) {\n      my $original = $_;\n\n      my @comments = /($comment)/go;\n      s/$comment//go if @comments;\n\n      my ($user, $host, $com);\n      ($user, $host) = ($1, $2) if s/<($local_part)\\@($domain)>\\s*\\z//o;\n      if (! defined($user) || ! defined($host)) {\n          s/($local_part)\\@($domain)//o;\n          ($user, $host) = ($1, $2);\n      }\n\n      next if $user =~ /\\P{ASCII}/;\n      next if $host =~ /\\P{ASCII}/;\n\n      my ($phrase)       = /($display_name)/o;\n\n      for ( $phrase, $host, $user, @comments ) {\n        next unless defined $_;\n        s/^\\s+//;\n        s/\\s+$//;\n        $_ = undef unless length $_;\n      }\n\n      my $new_comment = join q{ }, @comments;\n      push @addrs,\n        $class->new($phrase, \"$user\\@$host\", $new_comment, $original);\n      $addrs[-1]->[_IN_CACHE] = [ \\$line, $#addrs ]\n    }\n\n    $class->__cache_parse($line, \\@addrs);\n    return @addrs;\n}\n\n=item new\n\n  my $address = Email::Address->new(undef, 'casey@local');\n  my $address = Email::Address->new('Casey West', 'casey@local');\n  my $address = Email::Address->new(undef, 'casey@local', '(Casey)');\n\nConstructs and returns a new C<Email::Address> object. Takes four\npositional arguments: phrase, email, and comment, and original string.\n\nThe original string should only really be set using C<parse>.\n\n=cut\n\nsub new {\n  my ($class, $phrase, $email, $comment, $orig) = @_;\n  $phrase =~ s/\\A\"(.+)\"\\z/$1/ if $phrase;\n\n  bless [ $phrase, $email, $comment, $orig ] => $class;\n}\n\n=item purge_cache\n\n  Email::Address->purge_cache;\n\nOne way this module stays fast is with internal caches. Caches live\nin memory and there is the remote possibility that you will have a\nmemory problem. On the off chance that you think you're one of those\npeople, this class method will empty those caches.\n\nI've loaded over 12000 objects and not encountered a memory problem.\n\n=cut\n\nsub purge_cache {\n    %NAME_CACHE   = ();\n    %FORMAT_CACHE = ();\n    %PARSE_CACHE  = ();\n}\n\n=item disable_cache\n\n=item enable_cache\n\n  Email::Address->disable_cache if memory_low();\n\nIf you'd rather not cache address parses at all, you can disable (and\nre-enable) the Email::Address cache with these methods.  The cache is enabled\nby default.\n\n=cut\n\nsub disable_cache {\n  my ($class) = @_;\n  $class->purge_cache;\n  $NOCACHE = 1;\n}\n\nsub enable_cache {\n  $NOCACHE = undef;\n}\n\n=back\n\n=head2 Instance Methods\n\n=over 4\n\n=item phrase\n\n  my $phrase = $address->phrase;\n  $address->phrase( \"Me oh my\" );\n\nAccessor and mutator for the phrase portion of an address.\n\n=item address\n\n  my $addr = $address->address;\n  $addr->address( \"me@PROTECTED.com\" );\n\nAccessor and mutator for the address portion of an address.\n\n=item comment\n\n  my $comment = $address->comment;\n  $address->comment( \"(Work address)\" );\n\nAccessor and mutator for the comment portion of an address.\n\n=item original\n\n  my $orig = $address->original;\n\nAccessor for the original address found when parsing, or passed\nto C<new>.\n\n=item host\n\n  my $host = $address->host;\n\nAccessor for the host portion of an address's address.\n\n=item user\n\n  my $user = $address->user;\n\nAccessor for the user portion of an address's address.\n\n=cut\n\nBEGIN {\n  my %_INDEX = (\n    phrase   => _PHRASE,\n    address  => _ADDRESS,\n    comment  => _COMMENT,\n    original => _ORIGINAL,\n  );\n\n  for my $method (keys %_INDEX) {\n    no strict 'refs';\n    my $index = $_INDEX{ $method };\n    *$method = sub {\n      if ($_[1]) {\n        if ($_[0][_IN_CACHE]) {\n          my $replicant = bless [ @{$_[0]} ] => ref $_[0];\n          $PARSE_CACHE{ ${ $_[0][_IN_CACHE][0] } }[ $_[0][_IN_CACHE][1] ]\n            = $replicant;\n          $_[0][_IN_CACHE] = undef;\n        }\n        $_[0]->[ $index ] = $_[1];\n      } else {\n        $_[0]->[ $index ];\n      }\n    };\n  }\n}\n\nsub host { ($_[0]->[_ADDRESS] =~ /\\@($domain)/o)[0]     }\nsub user { ($_[0]->[_ADDRESS] =~ /($local_part)\\@/o)[0] }\n\n=pod\n\n=item format\n\n  my $printable = $address->format;\n\nReturns a properly formatted RFC 2822 address representing the\nobject.\n\n=cut\n\nsub format {\n    my $cache_str = do { no warnings 'uninitialized'; \"@{$_[0]}\" };\n    return $FORMAT_CACHE{$cache_str} if exists $FORMAT_CACHE{$cache_str};\n    $FORMAT_CACHE{$cache_str} = $_[0]->_format;\n}\n\nsub _format {\n    my ($self) = @_;\n\n    unless (\n      defined $self->[_PHRASE] && length $self->[_PHRASE]\n      ||\n      defined $self->[_COMMENT] && length $self->[_COMMENT]\n    ) {\n        return defined $self->[_ADDRESS] ? $self->[_ADDRESS] : '';\n    }\n\n    my $comment = defined $self->[_COMMENT] ? $self->[_COMMENT] : '';\n    $comment = \"($comment)\" if length $comment and $comment !~ /\\A\\(.*\\)\\z/;\n\n    my $format = sprintf q{%s <%s> %s},\n                 $self->_enquoted_phrase,\n                 (defined $self->[_ADDRESS] ? $self->[_ADDRESS] : ''),\n                 $comment;\n\n    $format =~ s/^\\s+//;\n    $format =~ s/\\s+$//;\n\n    return $format;\n}\n\nsub _enquoted_phrase {\n  my ($self) = @_;\n\n  my $phrase = $self->[_PHRASE];\n\n  return '' unless defined $phrase and length $phrase;\n\n  # if it's encoded -- rjbs, 2007-02-28\n  return $phrase if $phrase =~ /\\A=\\?.+\\?=\\z/;\n\n  $phrase =~ s/\\A\"(.+)\"\\z/$1/;\n  $phrase =~ s/([\\\\\"])/\\\\$1/g;\n\n  return qq{\"$phrase\"};\n}\n\n=item name\n\n  my $name = $address->name;\n\nThis method tries very hard to determine the name belonging to the address.\nFirst the C<phrase> is checked. If that doesn't work out the C<comment>\nis looked into. If that still doesn't work out, the C<user> portion of\nthe C<address> is returned.\n\nThis method does B<not> try to massage any name it identifies and instead\nleaves that up to someone else. Who is it to decide if someone wants their\nname capitalized, or if they're Irish?\n\n=cut\n\nsub name {\n    my $cache_str = do { no warnings 'uninitialized'; \"@{$_[0]}\" };\n    return $NAME_CACHE{$cache_str} if exists $NAME_CACHE{$cache_str};\n\n    my ($self) = @_;\n    my $name = q{};\n    if ( $name = $self->[_PHRASE] ) {\n        $name =~ s/^\"//;\n        $name =~ s/\"$//;\n        $name =~ s/($quoted_pair)/substr $1, -1/goe;\n    } elsif ( $name = $self->[_COMMENT] ) {\n        $name =~ s/^\\(//;\n        $name =~ s/\\)$//;\n        $name =~ s/($quoted_pair)/substr $1, -1/goe;\n        $name =~ s/$comment/ /go;\n    } else {\n        ($name) = $self->[_ADDRESS] =~ /($local_part)\\@/o;\n    }\n    $NAME_CACHE{$cache_str} = $name;\n}\n\n=back\n\n=head2 Overloaded Operators\n\n=over 4\n\n=item stringify\n\n  print \"I have your email address, $address.\";\n\nObjects stringify to C<format> by default. It's possible that you don't\nlike that idea. Okay, then, you can change it by modifying\nC<$Email:Address::STRINGIFY>. Please consider modifying this package\nvariable using C<local>. You might step on someone else's toes if you\ndon't.\n\n  {\n    local $Email::Address::STRINGIFY = 'host';\n    print \"I have your address, $address.\";\n    #   geeknest.com\n  }\n  print \"I have your address, $address.\";\n  #   \"Casey West\" <casey@geeknest.com>\n\nModifying this package variable is now deprecated. Subclassing is now the\nrecommended approach.\n\n=cut\n\nsub as_string {\n  warn 'altering $Email::Address::STRINGIFY is deprecated; subclass instead'\n    if $STRINGIFY ne 'format';\n\n  $_[0]->can($STRINGIFY)->($_[0]);\n}\n\nuse overload '\"\"' => 'as_string', fallback => 1;\n\n=pod\n\n=back\n\n=cut\n\n1;\n\n__END__\n\n=head2 Did I Mention Fast?\n\nOn his 1.8GHz Apple MacBook, rjbs gets these results:\n\n  $ perl -Ilib bench/ea-vs-ma.pl bench/corpus.txt 5\n                   Rate  Mail::Address Email::Address\n  Mail::Address  2.59/s             --           -44%\n  Email::Address 4.59/s            77%             --\n\n  $ perl -Ilib bench/ea-vs-ma.pl bench/corpus.txt 25\n                   Rate  Mail::Address Email::Address\n  Mail::Address  2.58/s             --           -67%\n  Email::Address 7.84/s           204%             --\n\n  $ perl -Ilib bench/ea-vs-ma.pl bench/corpus.txt 50\n                   Rate  Mail::Address Email::Address\n  Mail::Address  2.57/s             --           -70%\n  Email::Address 8.53/s           232%             --\n\n...unfortunately, a known bug causes a loss of speed the string to parse has\ncertain known characteristics, and disabling cache will also degrade\nperformance.\n\n=head1 ACKNOWLEDGEMENTS\n\nThanks to Kevin Riggle and Tatsuhiko Miyagawa for tests for annoying\nphrase-quoting bugs!\n\n=cut\n\n"], "filenames": ["lib/Email/Address.pm"], "buggy_code_start_loc": [54], "buggy_code_end_loc": [55], "fixing_code_start_loc": [54], "fixing_code_end_loc": [55], "type": "NVD-CWE-Other", "message": "The parse function in Email::Address module before 1.905 for Perl uses an inefficient regular expression, which allows remote attackers to cause a denial of service (CPU consumption) via an empty quoted string in an RFC 2822 address.", "other": {"cve": {"id": "CVE-2014-0477", "sourceIdentifier": "security@debian.org", "published": "2014-07-03T17:55:05.937", "lastModified": "2015-11-04T19:00:07.147", "vulnStatus": "Analyzed", "evaluatorComment": "<a href=\"http://cwe.mitre.org/data/definitions/185.html\" target=\"_blank\">CWE-185: CWE-185: Incorrect Regular Expression</a>", "descriptions": [{"lang": "en", "value": "The parse function in Email::Address module before 1.905 for Perl uses an inefficient regular expression, which allows remote attackers to cause a denial of service (CPU consumption) via an empty quoted string in an RFC 2822 address."}, {"lang": "es", "value": "La funci\u00f3n de an\u00e1lisis en el m\u00f3dulo Email::Address anterior a 1.905 para Perl utiliza una expresi\u00f3n regular ineficiente, lo que permite a atacantes remotos causar una denegaci\u00f3n de servicio (consumo de CPU) a trav\u00e9s de una cadena entrecomillada vac\u00eda en una direcci\u00f3n RFC 2822."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:*:*:*:*:*:perl:*:*", "versionEndIncluding": "1.904", "matchCriteriaId": "93832D0A-C5C3-45D0-864B-8632F874FA33"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.1:*:*:*:*:perl:*:*", "matchCriteriaId": "034B23B5-09E7-4A4B-B69A-FE4560DC7513"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.2:*:*:*:*:perl:*:*", "matchCriteriaId": "9F98BBB6-6341-462C-8178-75715B849FA3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.3:*:*:*:*:perl:*:*", "matchCriteriaId": "381FA46E-2E16-4D3C-9F5A-37CBCC470F41"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.5:*:*:*:*:perl:*:*", "matchCriteriaId": "78055F93-0E56-456D-8F3E-C15564822784"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.6:*:*:*:*:perl:*:*", "matchCriteriaId": "86AC613C-C5E3-42C8-ABF1-0A8BB3A98785"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.7:*:*:*:*:perl:*:*", "matchCriteriaId": "2D980BE9-B8E8-41DD-9C53-9FE96F6D3D1F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.80:*:*:*:*:perl:*:*", "matchCriteriaId": "4E8E0242-461B-489F-B26A-DC386126721E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.85:*:*:*:*:perl:*:*", "matchCriteriaId": "BBBBB7CE-B781-4E65-BD03-63019421D16D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.86:*:*:*:*:perl:*:*", "matchCriteriaId": "3B591508-FB08-46EA-9AD9-191FD7E5860D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.870:*:*:*:*:perl:*:*", "matchCriteriaId": "6C06ADC3-2033-4A33-934D-E368E9B7424F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.871:*:*:*:*:perl:*:*", "matchCriteriaId": "37F97A3B-1C95-4387-AACF-003585A921FA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.880:*:*:*:*:perl:*:*", "matchCriteriaId": "6F955901-D4DA-410C-BB96-28C14D8C76F6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.881:*:*:*:*:perl:*:*", "matchCriteriaId": "7F292919-76A5-4751-ACB6-21045710CD5B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.882:*:*:*:*:perl:*:*", "matchCriteriaId": "BAFA0B5F-047C-499C-BF59-1409B40F2F09"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.883:*:*:*:*:perl:*:*", "matchCriteriaId": "91601717-A232-4DEB-951F-D579D5180E04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.884:*:*:*:*:perl:*:*", "matchCriteriaId": "2AF85AE0-E4F1-480E-92E3-906E0871FF71"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.885:*:*:*:*:perl:*:*", "matchCriteriaId": "180C7550-63AB-4E30-8279-B64C6CBFEB98"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.886:*:*:*:*:perl:*:*", "matchCriteriaId": "EE2E7DA5-9CCB-4BA8-906A-E33FA98ADAD5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.887:*:*:*:*:perl:*:*", "matchCriteriaId": "4CF14ADF-C883-4F21-BD15-56EB6D9F9362"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.888:*:*:*:*:perl:*:*", "matchCriteriaId": "08EFFFAC-C98A-4472-9033-9DDD7969FC64"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.889:*:*:*:*:perl:*:*", "matchCriteriaId": "4A7D1330-AB55-479A-850F-42FD6FC91B6F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.890:*:*:*:*:perl:*:*", "matchCriteriaId": "9845B6A0-692B-4EE1-B262-32C76CC2132B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.891:*:*:*:*:perl:*:*", "matchCriteriaId": "C4A8584E-6656-472A-8A83-C3B1393F0C4B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.892:*:*:*:*:perl:*:*", "matchCriteriaId": "4374F1BA-FB71-4A13-BF75-027AABE8F764"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.893:*:*:*:*:perl:*:*", "matchCriteriaId": "931DBF2D-BD22-4ACA-A4DF-09D04ACBCAC1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.894:*:*:*:*:perl:*:*", "matchCriteriaId": "7772EF79-F1B7-48B1-B35C-E60A4B71D2EA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.895:*:*:*:*:perl:*:*", "matchCriteriaId": "3FFCC711-182C-47DC-9465-009EF50DE7F6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.896:*:*:*:*:perl:*:*", "matchCriteriaId": "CAC690BA-CB11-4A9B-A8E6-4F713CD57DD7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.897:*:*:*:*:perl:*:*", "matchCriteriaId": "CB6CC43F-81C6-46B6-8D69-75FA3BAC961F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.898:*:*:*:*:perl:*:*", "matchCriteriaId": "37616FE4-8CDA-47AF-8645-3B892F2C6115"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.899:*:*:*:*:perl:*:*", "matchCriteriaId": "95D3726D-CD58-428B-931D-44F8CAF511BC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.900:*:*:*:*:perl:*:*", "matchCriteriaId": "95071E16-03F9-4DA1-9979-B57587EB585B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.901:*:*:*:*:perl:*:*", "matchCriteriaId": "81929F29-61B0-4413-918F-EFD39118B5E8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.902:*:*:*:*:perl:*:*", "matchCriteriaId": "9D71F658-E454-4D66-8CCA-D6526EC4730F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:email\\:\\:address_module_project:email\\:\\:address:1.903:*:*:*:*:perl:*:*", "matchCriteriaId": "9FD189C1-E5EB-4332-9CE9-7B96FFEC5C59"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:*:*:*:*:*:*:*:*", "matchCriteriaId": "20294CE7-12C8-43CA-A702-5ED2A3044FFC"}]}]}], "references": [{"url": "http://seclists.org/oss-sec/2014/q2/563", "source": "security@debian.org"}, {"url": "http://www.debian.org/security/2014/dsa-2969", "source": "security@debian.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1110723", "source": "security@debian.org"}, {"url": "https://github.com/rjbs/Email-Address/blob/master/Changes", "source": "security@debian.org"}, {"url": "https://github.com/rjbs/Email-Address/commit/83f8306117115729ac9346523762c0c396251eb5", "source": "security@debian.org", "tags": ["Exploit", "Patch"]}, {"url": "https://metacpan.org/release/RJBS/Email-Address-1.905", "source": "security@debian.org"}]}, "github_commit_url": "https://github.com/rjbs/Email-Address/commit/83f8306117115729ac9346523762c0c396251eb5"}}