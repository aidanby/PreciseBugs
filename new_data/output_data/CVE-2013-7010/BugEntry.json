{"buggy_code": ["/*\n * DSP utils\n * Copyright (c) 2000, 2001 Fabrice Bellard\n * Copyright (c) 2002-2004 Michael Niedermayer <michaelni@gmx.at>\n *\n * gmc & q-pel & 32/64 bit based MC by Michael Niedermayer <michaelni@gmx.at>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * DSP utils\n */\n\n#include \"libavutil/attributes.h\"\n#include \"libavutil/imgutils.h\"\n#include \"libavutil/internal.h\"\n#include \"avcodec.h\"\n#include \"copy_block.h\"\n#include \"dct.h\"\n#include \"dsputil.h\"\n#include \"simple_idct.h\"\n#include \"faandct.h\"\n#include \"faanidct.h\"\n#include \"imgconvert.h\"\n#include \"mathops.h\"\n#include \"mpegvideo.h\"\n#include \"config.h\"\n#include \"diracdsp.h\"\n\nuint32_t ff_squareTbl[512] = {0, };\n\n#define BIT_DEPTH 16\n#include \"dsputil_template.c\"\n#undef BIT_DEPTH\n\n#define BIT_DEPTH 8\n#include \"dsputil_template.c\"\n\n// 0x7f7f7f7f or 0x7f7f7f7f7f7f7f7f or whatever, depending on the cpu's native arithmetic size\n#define pb_7f (~0UL/255 * 0x7f)\n#define pb_80 (~0UL/255 * 0x80)\n\n/* Specific zigzag scan for 248 idct. NOTE that unlike the\n   specification, we interleave the fields */\nconst uint8_t ff_zigzag248_direct[64] = {\n     0,  8,  1,  9, 16, 24,  2, 10,\n    17, 25, 32, 40, 48, 56, 33, 41,\n    18, 26,  3, 11,  4, 12, 19, 27,\n    34, 42, 49, 57, 50, 58, 35, 43,\n    20, 28,  5, 13,  6, 14, 21, 29,\n    36, 44, 51, 59, 52, 60, 37, 45,\n    22, 30,  7, 15, 23, 31, 38, 46,\n    53, 61, 54, 62, 39, 47, 55, 63,\n};\n\n/* not permutated inverse zigzag_direct + 1 for MMX quantizer */\nDECLARE_ALIGNED(16, uint16_t, ff_inv_zigzag_direct16)[64];\n\nconst uint8_t ff_alternate_horizontal_scan[64] = {\n    0,  1,   2,  3,  8,  9, 16, 17,\n    10, 11,  4,  5,  6,  7, 15, 14,\n    13, 12, 19, 18, 24, 25, 32, 33,\n    26, 27, 20, 21, 22, 23, 28, 29,\n    30, 31, 34, 35, 40, 41, 48, 49,\n    42, 43, 36, 37, 38, 39, 44, 45,\n    46, 47, 50, 51, 56, 57, 58, 59,\n    52, 53, 54, 55, 60, 61, 62, 63,\n};\n\nconst uint8_t ff_alternate_vertical_scan[64] = {\n    0,  8,  16, 24,  1,  9,  2, 10,\n    17, 25, 32, 40, 48, 56, 57, 49,\n    41, 33, 26, 18,  3, 11,  4, 12,\n    19, 27, 34, 42, 50, 58, 35, 43,\n    51, 59, 20, 28,  5, 13,  6, 14,\n    21, 29, 36, 44, 52, 60, 37, 45,\n    53, 61, 22, 30,  7, 15, 23, 31,\n    38, 46, 54, 62, 39, 47, 55, 63,\n};\n\n/* Input permutation for the simple_idct_mmx */\nstatic const uint8_t simple_mmx_permutation[64]={\n        0x00, 0x08, 0x04, 0x09, 0x01, 0x0C, 0x05, 0x0D,\n        0x10, 0x18, 0x14, 0x19, 0x11, 0x1C, 0x15, 0x1D,\n        0x20, 0x28, 0x24, 0x29, 0x21, 0x2C, 0x25, 0x2D,\n        0x12, 0x1A, 0x16, 0x1B, 0x13, 0x1E, 0x17, 0x1F,\n        0x02, 0x0A, 0x06, 0x0B, 0x03, 0x0E, 0x07, 0x0F,\n        0x30, 0x38, 0x34, 0x39, 0x31, 0x3C, 0x35, 0x3D,\n        0x22, 0x2A, 0x26, 0x2B, 0x23, 0x2E, 0x27, 0x2F,\n        0x32, 0x3A, 0x36, 0x3B, 0x33, 0x3E, 0x37, 0x3F,\n};\n\nstatic const uint8_t idct_sse2_row_perm[8] = {0, 4, 1, 5, 2, 6, 3, 7};\n\nav_cold void ff_init_scantable(uint8_t *permutation, ScanTable *st,\n                               const uint8_t *src_scantable)\n{\n    int i;\n    int end;\n\n    st->scantable= src_scantable;\n\n    for(i=0; i<64; i++){\n        int j;\n        j = src_scantable[i];\n        st->permutated[i] = permutation[j];\n    }\n\n    end=-1;\n    for(i=0; i<64; i++){\n        int j;\n        j = st->permutated[i];\n        if(j>end) end=j;\n        st->raster_end[i]= end;\n    }\n}\n\nav_cold void ff_init_scantable_permutation(uint8_t *idct_permutation,\n                                           int idct_permutation_type)\n{\n    int i;\n\n    switch(idct_permutation_type){\n    case FF_NO_IDCT_PERM:\n        for(i=0; i<64; i++)\n            idct_permutation[i]= i;\n        break;\n    case FF_LIBMPEG2_IDCT_PERM:\n        for(i=0; i<64; i++)\n            idct_permutation[i]= (i & 0x38) | ((i & 6) >> 1) | ((i & 1) << 2);\n        break;\n    case FF_SIMPLE_IDCT_PERM:\n        for(i=0; i<64; i++)\n            idct_permutation[i]= simple_mmx_permutation[i];\n        break;\n    case FF_TRANSPOSE_IDCT_PERM:\n        for(i=0; i<64; i++)\n            idct_permutation[i]= ((i&7)<<3) | (i>>3);\n        break;\n    case FF_PARTTRANS_IDCT_PERM:\n        for(i=0; i<64; i++)\n            idct_permutation[i]= (i&0x24) | ((i&3)<<3) | ((i>>3)&3);\n        break;\n    case FF_SSE2_IDCT_PERM:\n        for(i=0; i<64; i++)\n            idct_permutation[i]= (i&0x38) | idct_sse2_row_perm[i&7];\n        break;\n    default:\n        av_log(NULL, AV_LOG_ERROR, \"Internal error, IDCT permutation not set\\n\");\n    }\n}\n\nstatic int pix_sum_c(uint8_t * pix, int line_size)\n{\n    int s, i, j;\n\n    s = 0;\n    for (i = 0; i < 16; i++) {\n        for (j = 0; j < 16; j += 8) {\n            s += pix[0];\n            s += pix[1];\n            s += pix[2];\n            s += pix[3];\n            s += pix[4];\n            s += pix[5];\n            s += pix[6];\n            s += pix[7];\n            pix += 8;\n        }\n        pix += line_size - 16;\n    }\n    return s;\n}\n\nstatic int pix_norm1_c(uint8_t * pix, int line_size)\n{\n    int s, i, j;\n    uint32_t *sq = ff_squareTbl + 256;\n\n    s = 0;\n    for (i = 0; i < 16; i++) {\n        for (j = 0; j < 16; j += 8) {\n#if 0\n            s += sq[pix[0]];\n            s += sq[pix[1]];\n            s += sq[pix[2]];\n            s += sq[pix[3]];\n            s += sq[pix[4]];\n            s += sq[pix[5]];\n            s += sq[pix[6]];\n            s += sq[pix[7]];\n#else\n#if HAVE_FAST_64BIT\n            register uint64_t x=*(uint64_t*)pix;\n            s += sq[x&0xff];\n            s += sq[(x>>8)&0xff];\n            s += sq[(x>>16)&0xff];\n            s += sq[(x>>24)&0xff];\n            s += sq[(x>>32)&0xff];\n            s += sq[(x>>40)&0xff];\n            s += sq[(x>>48)&0xff];\n            s += sq[(x>>56)&0xff];\n#else\n            register uint32_t x=*(uint32_t*)pix;\n            s += sq[x&0xff];\n            s += sq[(x>>8)&0xff];\n            s += sq[(x>>16)&0xff];\n            s += sq[(x>>24)&0xff];\n            x=*(uint32_t*)(pix+4);\n            s += sq[x&0xff];\n            s += sq[(x>>8)&0xff];\n            s += sq[(x>>16)&0xff];\n            s += sq[(x>>24)&0xff];\n#endif\n#endif\n            pix += 8;\n        }\n        pix += line_size - 16;\n    }\n    return s;\n}\n\nstatic void bswap_buf(uint32_t *dst, const uint32_t *src, int w){\n    int i;\n\n    for(i=0; i+8<=w; i+=8){\n        dst[i+0]= av_bswap32(src[i+0]);\n        dst[i+1]= av_bswap32(src[i+1]);\n        dst[i+2]= av_bswap32(src[i+2]);\n        dst[i+3]= av_bswap32(src[i+3]);\n        dst[i+4]= av_bswap32(src[i+4]);\n        dst[i+5]= av_bswap32(src[i+5]);\n        dst[i+6]= av_bswap32(src[i+6]);\n        dst[i+7]= av_bswap32(src[i+7]);\n    }\n    for(;i<w; i++){\n        dst[i+0]= av_bswap32(src[i+0]);\n    }\n}\n\nstatic void bswap16_buf(uint16_t *dst, const uint16_t *src, int len)\n{\n    while (len--)\n        *dst++ = av_bswap16(*src++);\n}\n\nstatic int sse4_c(void *v, uint8_t * pix1, uint8_t * pix2, int line_size, int h)\n{\n    int s, i;\n    uint32_t *sq = ff_squareTbl + 256;\n\n    s = 0;\n    for (i = 0; i < h; i++) {\n        s += sq[pix1[0] - pix2[0]];\n        s += sq[pix1[1] - pix2[1]];\n        s += sq[pix1[2] - pix2[2]];\n        s += sq[pix1[3] - pix2[3]];\n        pix1 += line_size;\n        pix2 += line_size;\n    }\n    return s;\n}\n\nstatic int sse8_c(void *v, uint8_t * pix1, uint8_t * pix2, int line_size, int h)\n{\n    int s, i;\n    uint32_t *sq = ff_squareTbl + 256;\n\n    s = 0;\n    for (i = 0; i < h; i++) {\n        s += sq[pix1[0] - pix2[0]];\n        s += sq[pix1[1] - pix2[1]];\n        s += sq[pix1[2] - pix2[2]];\n        s += sq[pix1[3] - pix2[3]];\n        s += sq[pix1[4] - pix2[4]];\n        s += sq[pix1[5] - pix2[5]];\n        s += sq[pix1[6] - pix2[6]];\n        s += sq[pix1[7] - pix2[7]];\n        pix1 += line_size;\n        pix2 += line_size;\n    }\n    return s;\n}\n\nstatic int sse16_c(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)\n{\n    int s, i;\n    uint32_t *sq = ff_squareTbl + 256;\n\n    s = 0;\n    for (i = 0; i < h; i++) {\n        s += sq[pix1[ 0] - pix2[ 0]];\n        s += sq[pix1[ 1] - pix2[ 1]];\n        s += sq[pix1[ 2] - pix2[ 2]];\n        s += sq[pix1[ 3] - pix2[ 3]];\n        s += sq[pix1[ 4] - pix2[ 4]];\n        s += sq[pix1[ 5] - pix2[ 5]];\n        s += sq[pix1[ 6] - pix2[ 6]];\n        s += sq[pix1[ 7] - pix2[ 7]];\n        s += sq[pix1[ 8] - pix2[ 8]];\n        s += sq[pix1[ 9] - pix2[ 9]];\n        s += sq[pix1[10] - pix2[10]];\n        s += sq[pix1[11] - pix2[11]];\n        s += sq[pix1[12] - pix2[12]];\n        s += sq[pix1[13] - pix2[13]];\n        s += sq[pix1[14] - pix2[14]];\n        s += sq[pix1[15] - pix2[15]];\n\n        pix1 += line_size;\n        pix2 += line_size;\n    }\n    return s;\n}\n\nstatic void diff_pixels_c(int16_t *av_restrict block, const uint8_t *s1,\n                          const uint8_t *s2, int stride){\n    int i;\n\n    /* read the pixels */\n    for(i=0;i<8;i++) {\n        block[0] = s1[0] - s2[0];\n        block[1] = s1[1] - s2[1];\n        block[2] = s1[2] - s2[2];\n        block[3] = s1[3] - s2[3];\n        block[4] = s1[4] - s2[4];\n        block[5] = s1[5] - s2[5];\n        block[6] = s1[6] - s2[6];\n        block[7] = s1[7] - s2[7];\n        s1 += stride;\n        s2 += stride;\n        block += 8;\n    }\n}\n\nstatic void put_pixels_clamped_c(const int16_t *block, uint8_t *av_restrict pixels,\n                                 int line_size)\n{\n    int i;\n\n    /* read the pixels */\n    for(i=0;i<8;i++) {\n        pixels[0] = av_clip_uint8(block[0]);\n        pixels[1] = av_clip_uint8(block[1]);\n        pixels[2] = av_clip_uint8(block[2]);\n        pixels[3] = av_clip_uint8(block[3]);\n        pixels[4] = av_clip_uint8(block[4]);\n        pixels[5] = av_clip_uint8(block[5]);\n        pixels[6] = av_clip_uint8(block[6]);\n        pixels[7] = av_clip_uint8(block[7]);\n\n        pixels += line_size;\n        block += 8;\n    }\n}\n\nstatic void put_pixels_clamped4_c(const int16_t *block, uint8_t *av_restrict pixels,\n                                 int line_size)\n{\n    int i;\n\n    /* read the pixels */\n    for(i=0;i<4;i++) {\n        pixels[0] = av_clip_uint8(block[0]);\n        pixels[1] = av_clip_uint8(block[1]);\n        pixels[2] = av_clip_uint8(block[2]);\n        pixels[3] = av_clip_uint8(block[3]);\n\n        pixels += line_size;\n        block += 8;\n    }\n}\n\nstatic void put_pixels_clamped2_c(const int16_t *block, uint8_t *av_restrict pixels,\n                                 int line_size)\n{\n    int i;\n\n    /* read the pixels */\n    for(i=0;i<2;i++) {\n        pixels[0] = av_clip_uint8(block[0]);\n        pixels[1] = av_clip_uint8(block[1]);\n\n        pixels += line_size;\n        block += 8;\n    }\n}\n\nstatic void put_signed_pixels_clamped_c(const int16_t *block,\n                                        uint8_t *av_restrict pixels,\n                                        int line_size)\n{\n    int i, j;\n\n    for (i = 0; i < 8; i++) {\n        for (j = 0; j < 8; j++) {\n            if (*block < -128)\n                *pixels = 0;\n            else if (*block > 127)\n                *pixels = 255;\n            else\n                *pixels = (uint8_t)(*block + 128);\n            block++;\n            pixels++;\n        }\n        pixels += (line_size - 8);\n    }\n}\n\nstatic void add_pixels8_c(uint8_t *av_restrict pixels,\n                          int16_t *block,\n                          int line_size)\n{\n    int i;\n\n    for(i=0;i<8;i++) {\n        pixels[0] += block[0];\n        pixels[1] += block[1];\n        pixels[2] += block[2];\n        pixels[3] += block[3];\n        pixels[4] += block[4];\n        pixels[5] += block[5];\n        pixels[6] += block[6];\n        pixels[7] += block[7];\n        pixels += line_size;\n        block += 8;\n    }\n}\n\nstatic void add_pixels_clamped_c(const int16_t *block, uint8_t *av_restrict pixels,\n                                 int line_size)\n{\n    int i;\n\n    /* read the pixels */\n    for(i=0;i<8;i++) {\n        pixels[0] = av_clip_uint8(pixels[0] + block[0]);\n        pixels[1] = av_clip_uint8(pixels[1] + block[1]);\n        pixels[2] = av_clip_uint8(pixels[2] + block[2]);\n        pixels[3] = av_clip_uint8(pixels[3] + block[3]);\n        pixels[4] = av_clip_uint8(pixels[4] + block[4]);\n        pixels[5] = av_clip_uint8(pixels[5] + block[5]);\n        pixels[6] = av_clip_uint8(pixels[6] + block[6]);\n        pixels[7] = av_clip_uint8(pixels[7] + block[7]);\n        pixels += line_size;\n        block += 8;\n    }\n}\n\nstatic void add_pixels_clamped4_c(const int16_t *block, uint8_t *av_restrict pixels,\n                          int line_size)\n{\n    int i;\n\n    /* read the pixels */\n    for(i=0;i<4;i++) {\n        pixels[0] = av_clip_uint8(pixels[0] + block[0]);\n        pixels[1] = av_clip_uint8(pixels[1] + block[1]);\n        pixels[2] = av_clip_uint8(pixels[2] + block[2]);\n        pixels[3] = av_clip_uint8(pixels[3] + block[3]);\n        pixels += line_size;\n        block += 8;\n    }\n}\n\nstatic void add_pixels_clamped2_c(const int16_t *block, uint8_t *av_restrict pixels,\n                          int line_size)\n{\n    int i;\n\n    /* read the pixels */\n    for(i=0;i<2;i++) {\n        pixels[0] = av_clip_uint8(pixels[0] + block[0]);\n        pixels[1] = av_clip_uint8(pixels[1] + block[1]);\n        pixels += line_size;\n        block += 8;\n    }\n}\n\nstatic int sum_abs_dctelem_c(int16_t *block)\n{\n    int sum=0, i;\n    for(i=0; i<64; i++)\n        sum+= FFABS(block[i]);\n    return sum;\n}\n\nstatic void fill_block16_c(uint8_t *block, uint8_t value, int line_size, int h)\n{\n    int i;\n\n    for (i = 0; i < h; i++) {\n        memset(block, value, 16);\n        block += line_size;\n    }\n}\n\nstatic void fill_block8_c(uint8_t *block, uint8_t value, int line_size, int h)\n{\n    int i;\n\n    for (i = 0; i < h; i++) {\n        memset(block, value, 8);\n        block += line_size;\n    }\n}\n\n#define avg2(a,b) ((a+b+1)>>1)\n#define avg4(a,b,c,d) ((a+b+c+d+2)>>2)\n\nstatic void gmc1_c(uint8_t *dst, uint8_t *src, int stride, int h, int x16, int y16, int rounder)\n{\n    const int A=(16-x16)*(16-y16);\n    const int B=(   x16)*(16-y16);\n    const int C=(16-x16)*(   y16);\n    const int D=(   x16)*(   y16);\n    int i;\n\n    for(i=0; i<h; i++)\n    {\n        dst[0]= (A*src[0] + B*src[1] + C*src[stride+0] + D*src[stride+1] + rounder)>>8;\n        dst[1]= (A*src[1] + B*src[2] + C*src[stride+1] + D*src[stride+2] + rounder)>>8;\n        dst[2]= (A*src[2] + B*src[3] + C*src[stride+2] + D*src[stride+3] + rounder)>>8;\n        dst[3]= (A*src[3] + B*src[4] + C*src[stride+3] + D*src[stride+4] + rounder)>>8;\n        dst[4]= (A*src[4] + B*src[5] + C*src[stride+4] + D*src[stride+5] + rounder)>>8;\n        dst[5]= (A*src[5] + B*src[6] + C*src[stride+5] + D*src[stride+6] + rounder)>>8;\n        dst[6]= (A*src[6] + B*src[7] + C*src[stride+6] + D*src[stride+7] + rounder)>>8;\n        dst[7]= (A*src[7] + B*src[8] + C*src[stride+7] + D*src[stride+8] + rounder)>>8;\n        dst+= stride;\n        src+= stride;\n    }\n}\n\nvoid ff_gmc_c(uint8_t *dst, uint8_t *src, int stride, int h, int ox, int oy,\n                  int dxx, int dxy, int dyx, int dyy, int shift, int r, int width, int height)\n{\n    int y, vx, vy;\n    const int s= 1<<shift;\n\n    width--;\n    height--;\n\n    for(y=0; y<h; y++){\n        int x;\n\n        vx= ox;\n        vy= oy;\n        for(x=0; x<8; x++){ //XXX FIXME optimize\n            int src_x, src_y, frac_x, frac_y, index;\n\n            src_x= vx>>16;\n            src_y= vy>>16;\n            frac_x= src_x&(s-1);\n            frac_y= src_y&(s-1);\n            src_x>>=shift;\n            src_y>>=shift;\n\n            if((unsigned)src_x < width){\n                if((unsigned)src_y < height){\n                    index= src_x + src_y*stride;\n                    dst[y*stride + x]= (  (  src[index         ]*(s-frac_x)\n                                           + src[index       +1]*   frac_x )*(s-frac_y)\n                                        + (  src[index+stride  ]*(s-frac_x)\n                                           + src[index+stride+1]*   frac_x )*   frac_y\n                                        + r)>>(shift*2);\n                }else{\n                    index= src_x + av_clip(src_y, 0, height)*stride;\n                    dst[y*stride + x]= ( (  src[index         ]*(s-frac_x)\n                                          + src[index       +1]*   frac_x )*s\n                                        + r)>>(shift*2);\n                }\n            }else{\n                if((unsigned)src_y < height){\n                    index= av_clip(src_x, 0, width) + src_y*stride;\n                    dst[y*stride + x]= (  (  src[index         ]*(s-frac_y)\n                                           + src[index+stride  ]*   frac_y )*s\n                                        + r)>>(shift*2);\n                }else{\n                    index= av_clip(src_x, 0, width) + av_clip(src_y, 0, height)*stride;\n                    dst[y*stride + x]=    src[index         ];\n                }\n            }\n\n            vx+= dxx;\n            vy+= dyx;\n        }\n        ox += dxy;\n        oy += dyy;\n    }\n}\n\nstatic inline void put_tpel_pixels_mc00_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    switch(width){\n    case 2: put_pixels2_8_c (dst, src, stride, height); break;\n    case 4: put_pixels4_8_c (dst, src, stride, height); break;\n    case 8: put_pixels8_8_c (dst, src, stride, height); break;\n    case 16:put_pixels16_8_c(dst, src, stride, height); break;\n    }\n}\n\nstatic inline void put_tpel_pixels_mc10_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (683*(2*src[j] + src[j+1] + 1)) >> 11;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\nstatic inline void put_tpel_pixels_mc20_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (683*(src[j] + 2*src[j+1] + 1)) >> 11;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\nstatic inline void put_tpel_pixels_mc01_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (683*(2*src[j] + src[j+stride] + 1)) >> 11;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\nstatic inline void put_tpel_pixels_mc11_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (2731*(4*src[j] + 3*src[j+1] + 3*src[j+stride] + 2*src[j+stride+1] + 6)) >> 15;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\nstatic inline void put_tpel_pixels_mc12_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (2731*(3*src[j] + 2*src[j+1] + 4*src[j+stride] + 3*src[j+stride+1] + 6)) >> 15;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\nstatic inline void put_tpel_pixels_mc02_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (683*(src[j] + 2*src[j+stride] + 1)) >> 11;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\nstatic inline void put_tpel_pixels_mc21_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (2731*(3*src[j] + 4*src[j+1] + 2*src[j+stride] + 3*src[j+stride+1] + 6)) >> 15;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\nstatic inline void put_tpel_pixels_mc22_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (2731*(2*src[j] + 3*src[j+1] + 3*src[j+stride] + 4*src[j+stride+1] + 6)) >> 15;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\nstatic inline void avg_tpel_pixels_mc00_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    switch(width){\n    case 2: avg_pixels2_8_c (dst, src, stride, height); break;\n    case 4: avg_pixels4_8_c (dst, src, stride, height); break;\n    case 8: avg_pixels8_8_c (dst, src, stride, height); break;\n    case 16:avg_pixels16_8_c(dst, src, stride, height); break;\n    }\n}\n\nstatic inline void avg_tpel_pixels_mc10_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (dst[j] + ((683*(2*src[j] + src[j+1] + 1)) >> 11) + 1) >> 1;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\nstatic inline void avg_tpel_pixels_mc20_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (dst[j] + ((683*(src[j] + 2*src[j+1] + 1)) >> 11) + 1) >> 1;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\nstatic inline void avg_tpel_pixels_mc01_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (dst[j] + ((683*(2*src[j] + src[j+stride] + 1)) >> 11) + 1) >> 1;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\nstatic inline void avg_tpel_pixels_mc11_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (dst[j] + ((2731*(4*src[j] + 3*src[j+1] + 3*src[j+stride] + 2*src[j+stride+1] + 6)) >> 15) + 1) >> 1;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\nstatic inline void avg_tpel_pixels_mc12_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (dst[j] + ((2731*(3*src[j] + 2*src[j+1] + 4*src[j+stride] + 3*src[j+stride+1] + 6)) >> 15) + 1) >> 1;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\nstatic inline void avg_tpel_pixels_mc02_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (dst[j] + ((683*(src[j] + 2*src[j+stride] + 1)) >> 11) + 1) >> 1;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\nstatic inline void avg_tpel_pixels_mc21_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (dst[j] + ((2731*(3*src[j] + 4*src[j+1] + 2*src[j+stride] + 3*src[j+stride+1] + 6)) >> 15) + 1) >> 1;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\nstatic inline void avg_tpel_pixels_mc22_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (dst[j] + ((2731*(2*src[j] + 3*src[j+1] + 3*src[j+stride] + 4*src[j+stride+1] + 6)) >> 15) + 1) >> 1;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\n#define QPEL_MC(r, OPNAME, RND, OP) \\\nstatic void OPNAME ## mpeg4_qpel8_h_lowpass(uint8_t *dst, uint8_t *src, int dstStride, int srcStride, int h){\\\n    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\\\n    int i;\\\n    for(i=0; i<h; i++)\\\n    {\\\n        OP(dst[0], (src[0]+src[1])*20 - (src[0]+src[2])*6 + (src[1]+src[3])*3 - (src[2]+src[4]));\\\n        OP(dst[1], (src[1]+src[2])*20 - (src[0]+src[3])*6 + (src[0]+src[4])*3 - (src[1]+src[5]));\\\n        OP(dst[2], (src[2]+src[3])*20 - (src[1]+src[4])*6 + (src[0]+src[5])*3 - (src[0]+src[6]));\\\n        OP(dst[3], (src[3]+src[4])*20 - (src[2]+src[5])*6 + (src[1]+src[6])*3 - (src[0]+src[7]));\\\n        OP(dst[4], (src[4]+src[5])*20 - (src[3]+src[6])*6 + (src[2]+src[7])*3 - (src[1]+src[8]));\\\n        OP(dst[5], (src[5]+src[6])*20 - (src[4]+src[7])*6 + (src[3]+src[8])*3 - (src[2]+src[8]));\\\n        OP(dst[6], (src[6]+src[7])*20 - (src[5]+src[8])*6 + (src[4]+src[8])*3 - (src[3]+src[7]));\\\n        OP(dst[7], (src[7]+src[8])*20 - (src[6]+src[8])*6 + (src[5]+src[7])*3 - (src[4]+src[6]));\\\n        dst+=dstStride;\\\n        src+=srcStride;\\\n    }\\\n}\\\n\\\nstatic void OPNAME ## mpeg4_qpel8_v_lowpass(uint8_t *dst, uint8_t *src, int dstStride, int srcStride){\\\n    const int w=8;\\\n    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\\\n    int i;\\\n    for(i=0; i<w; i++)\\\n    {\\\n        const int src0= src[0*srcStride];\\\n        const int src1= src[1*srcStride];\\\n        const int src2= src[2*srcStride];\\\n        const int src3= src[3*srcStride];\\\n        const int src4= src[4*srcStride];\\\n        const int src5= src[5*srcStride];\\\n        const int src6= src[6*srcStride];\\\n        const int src7= src[7*srcStride];\\\n        const int src8= src[8*srcStride];\\\n        OP(dst[0*dstStride], (src0+src1)*20 - (src0+src2)*6 + (src1+src3)*3 - (src2+src4));\\\n        OP(dst[1*dstStride], (src1+src2)*20 - (src0+src3)*6 + (src0+src4)*3 - (src1+src5));\\\n        OP(dst[2*dstStride], (src2+src3)*20 - (src1+src4)*6 + (src0+src5)*3 - (src0+src6));\\\n        OP(dst[3*dstStride], (src3+src4)*20 - (src2+src5)*6 + (src1+src6)*3 - (src0+src7));\\\n        OP(dst[4*dstStride], (src4+src5)*20 - (src3+src6)*6 + (src2+src7)*3 - (src1+src8));\\\n        OP(dst[5*dstStride], (src5+src6)*20 - (src4+src7)*6 + (src3+src8)*3 - (src2+src8));\\\n        OP(dst[6*dstStride], (src6+src7)*20 - (src5+src8)*6 + (src4+src8)*3 - (src3+src7));\\\n        OP(dst[7*dstStride], (src7+src8)*20 - (src6+src8)*6 + (src5+src7)*3 - (src4+src6));\\\n        dst++;\\\n        src++;\\\n    }\\\n}\\\n\\\nstatic void OPNAME ## mpeg4_qpel16_h_lowpass(uint8_t *dst, uint8_t *src, int dstStride, int srcStride, int h){\\\n    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\\\n    int i;\\\n    \\\n    for(i=0; i<h; i++)\\\n    {\\\n        OP(dst[ 0], (src[ 0]+src[ 1])*20 - (src[ 0]+src[ 2])*6 + (src[ 1]+src[ 3])*3 - (src[ 2]+src[ 4]));\\\n        OP(dst[ 1], (src[ 1]+src[ 2])*20 - (src[ 0]+src[ 3])*6 + (src[ 0]+src[ 4])*3 - (src[ 1]+src[ 5]));\\\n        OP(dst[ 2], (src[ 2]+src[ 3])*20 - (src[ 1]+src[ 4])*6 + (src[ 0]+src[ 5])*3 - (src[ 0]+src[ 6]));\\\n        OP(dst[ 3], (src[ 3]+src[ 4])*20 - (src[ 2]+src[ 5])*6 + (src[ 1]+src[ 6])*3 - (src[ 0]+src[ 7]));\\\n        OP(dst[ 4], (src[ 4]+src[ 5])*20 - (src[ 3]+src[ 6])*6 + (src[ 2]+src[ 7])*3 - (src[ 1]+src[ 8]));\\\n        OP(dst[ 5], (src[ 5]+src[ 6])*20 - (src[ 4]+src[ 7])*6 + (src[ 3]+src[ 8])*3 - (src[ 2]+src[ 9]));\\\n        OP(dst[ 6], (src[ 6]+src[ 7])*20 - (src[ 5]+src[ 8])*6 + (src[ 4]+src[ 9])*3 - (src[ 3]+src[10]));\\\n        OP(dst[ 7], (src[ 7]+src[ 8])*20 - (src[ 6]+src[ 9])*6 + (src[ 5]+src[10])*3 - (src[ 4]+src[11]));\\\n        OP(dst[ 8], (src[ 8]+src[ 9])*20 - (src[ 7]+src[10])*6 + (src[ 6]+src[11])*3 - (src[ 5]+src[12]));\\\n        OP(dst[ 9], (src[ 9]+src[10])*20 - (src[ 8]+src[11])*6 + (src[ 7]+src[12])*3 - (src[ 6]+src[13]));\\\n        OP(dst[10], (src[10]+src[11])*20 - (src[ 9]+src[12])*6 + (src[ 8]+src[13])*3 - (src[ 7]+src[14]));\\\n        OP(dst[11], (src[11]+src[12])*20 - (src[10]+src[13])*6 + (src[ 9]+src[14])*3 - (src[ 8]+src[15]));\\\n        OP(dst[12], (src[12]+src[13])*20 - (src[11]+src[14])*6 + (src[10]+src[15])*3 - (src[ 9]+src[16]));\\\n        OP(dst[13], (src[13]+src[14])*20 - (src[12]+src[15])*6 + (src[11]+src[16])*3 - (src[10]+src[16]));\\\n        OP(dst[14], (src[14]+src[15])*20 - (src[13]+src[16])*6 + (src[12]+src[16])*3 - (src[11]+src[15]));\\\n        OP(dst[15], (src[15]+src[16])*20 - (src[14]+src[16])*6 + (src[13]+src[15])*3 - (src[12]+src[14]));\\\n        dst+=dstStride;\\\n        src+=srcStride;\\\n    }\\\n}\\\n\\\nstatic void OPNAME ## mpeg4_qpel16_v_lowpass(uint8_t *dst, uint8_t *src, int dstStride, int srcStride){\\\n    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\\\n    int i;\\\n    const int w=16;\\\n    for(i=0; i<w; i++)\\\n    {\\\n        const int src0= src[0*srcStride];\\\n        const int src1= src[1*srcStride];\\\n        const int src2= src[2*srcStride];\\\n        const int src3= src[3*srcStride];\\\n        const int src4= src[4*srcStride];\\\n        const int src5= src[5*srcStride];\\\n        const int src6= src[6*srcStride];\\\n        const int src7= src[7*srcStride];\\\n        const int src8= src[8*srcStride];\\\n        const int src9= src[9*srcStride];\\\n        const int src10= src[10*srcStride];\\\n        const int src11= src[11*srcStride];\\\n        const int src12= src[12*srcStride];\\\n        const int src13= src[13*srcStride];\\\n        const int src14= src[14*srcStride];\\\n        const int src15= src[15*srcStride];\\\n        const int src16= src[16*srcStride];\\\n        OP(dst[ 0*dstStride], (src0 +src1 )*20 - (src0 +src2 )*6 + (src1 +src3 )*3 - (src2 +src4 ));\\\n        OP(dst[ 1*dstStride], (src1 +src2 )*20 - (src0 +src3 )*6 + (src0 +src4 )*3 - (src1 +src5 ));\\\n        OP(dst[ 2*dstStride], (src2 +src3 )*20 - (src1 +src4 )*6 + (src0 +src5 )*3 - (src0 +src6 ));\\\n        OP(dst[ 3*dstStride], (src3 +src4 )*20 - (src2 +src5 )*6 + (src1 +src6 )*3 - (src0 +src7 ));\\\n        OP(dst[ 4*dstStride], (src4 +src5 )*20 - (src3 +src6 )*6 + (src2 +src7 )*3 - (src1 +src8 ));\\\n        OP(dst[ 5*dstStride], (src5 +src6 )*20 - (src4 +src7 )*6 + (src3 +src8 )*3 - (src2 +src9 ));\\\n        OP(dst[ 6*dstStride], (src6 +src7 )*20 - (src5 +src8 )*6 + (src4 +src9 )*3 - (src3 +src10));\\\n        OP(dst[ 7*dstStride], (src7 +src8 )*20 - (src6 +src9 )*6 + (src5 +src10)*3 - (src4 +src11));\\\n        OP(dst[ 8*dstStride], (src8 +src9 )*20 - (src7 +src10)*6 + (src6 +src11)*3 - (src5 +src12));\\\n        OP(dst[ 9*dstStride], (src9 +src10)*20 - (src8 +src11)*6 + (src7 +src12)*3 - (src6 +src13));\\\n        OP(dst[10*dstStride], (src10+src11)*20 - (src9 +src12)*6 + (src8 +src13)*3 - (src7 +src14));\\\n        OP(dst[11*dstStride], (src11+src12)*20 - (src10+src13)*6 + (src9 +src14)*3 - (src8 +src15));\\\n        OP(dst[12*dstStride], (src12+src13)*20 - (src11+src14)*6 + (src10+src15)*3 - (src9 +src16));\\\n        OP(dst[13*dstStride], (src13+src14)*20 - (src12+src15)*6 + (src11+src16)*3 - (src10+src16));\\\n        OP(dst[14*dstStride], (src14+src15)*20 - (src13+src16)*6 + (src12+src16)*3 - (src11+src15));\\\n        OP(dst[15*dstStride], (src15+src16)*20 - (src14+src16)*6 + (src13+src15)*3 - (src12+src14));\\\n        dst++;\\\n        src++;\\\n    }\\\n}\\\n\\\nstatic void OPNAME ## qpel8_mc10_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t half[64];\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(half, src, 8, stride, 8);\\\n    OPNAME ## pixels8_l2_8(dst, src, half, stride, stride, 8, 8);\\\n}\\\n\\\nstatic void OPNAME ## qpel8_mc20_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    OPNAME ## mpeg4_qpel8_h_lowpass(dst, src, stride, stride, 8);\\\n}\\\n\\\nstatic void OPNAME ## qpel8_mc30_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t half[64];\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(half, src, 8, stride, 8);\\\n    OPNAME ## pixels8_l2_8(dst, src+1, half, stride, stride, 8, 8);\\\n}\\\n\\\nstatic void OPNAME ## qpel8_mc01_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[16*9];\\\n    uint8_t half[64];\\\n    copy_block9(full, src, 16, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(half, full, 8, 16);\\\n    OPNAME ## pixels8_l2_8(dst, full, half, stride, 16, 8, 8);\\\n}\\\n\\\nstatic void OPNAME ## qpel8_mc02_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[16*9];\\\n    copy_block9(full, src, 16, stride, 9);\\\n    OPNAME ## mpeg4_qpel8_v_lowpass(dst, full, stride, 16);\\\n}\\\n\\\nstatic void OPNAME ## qpel8_mc03_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[16*9];\\\n    uint8_t half[64];\\\n    copy_block9(full, src, 16, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(half, full, 8, 16);\\\n    OPNAME ## pixels8_l2_8(dst, full+16, half, stride, 16, 8, 8);\\\n}\\\nvoid ff_ ## OPNAME ## qpel8_mc11_old_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[16*9];\\\n    uint8_t halfH[72];\\\n    uint8_t halfV[64];\\\n    uint8_t halfHV[64];\\\n    copy_block9(full, src, 16, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(halfH, full, 8, 16, 9);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfV, full, 8, 16);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfHV, halfH, 8, 8);\\\n    OPNAME ## pixels8_l4_8(dst, full, halfH, halfV, halfHV, stride, 16, 8, 8, 8, 8);\\\n}\\\nstatic void OPNAME ## qpel8_mc11_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[16*9];\\\n    uint8_t halfH[72];\\\n    uint8_t halfHV[64];\\\n    copy_block9(full, src, 16, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(halfH, full, 8, 16, 9);\\\n    put ## RND ## pixels8_l2_8(halfH, halfH, full, 8, 8, 16, 9);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfHV, halfH, 8, 8);\\\n    OPNAME ## pixels8_l2_8(dst, halfH, halfHV, stride, 8, 8, 8);\\\n}\\\nvoid ff_ ## OPNAME ## qpel8_mc31_old_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[16*9];\\\n    uint8_t halfH[72];\\\n    uint8_t halfV[64];\\\n    uint8_t halfHV[64];\\\n    copy_block9(full, src, 16, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(halfH, full, 8, 16, 9);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfV, full+1, 8, 16);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfHV, halfH, 8, 8);\\\n    OPNAME ## pixels8_l4_8(dst, full+1, halfH, halfV, halfHV, stride, 16, 8, 8, 8, 8);\\\n}\\\nstatic void OPNAME ## qpel8_mc31_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[16*9];\\\n    uint8_t halfH[72];\\\n    uint8_t halfHV[64];\\\n    copy_block9(full, src, 16, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(halfH, full, 8, 16, 9);\\\n    put ## RND ## pixels8_l2_8(halfH, halfH, full+1, 8, 8, 16, 9);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfHV, halfH, 8, 8);\\\n    OPNAME ## pixels8_l2_8(dst, halfH, halfHV, stride, 8, 8, 8);\\\n}\\\nvoid ff_ ## OPNAME ## qpel8_mc13_old_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[16*9];\\\n    uint8_t halfH[72];\\\n    uint8_t halfV[64];\\\n    uint8_t halfHV[64];\\\n    copy_block9(full, src, 16, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(halfH, full, 8, 16, 9);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfV, full, 8, 16);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfHV, halfH, 8, 8);\\\n    OPNAME ## pixels8_l4_8(dst, full+16, halfH+8, halfV, halfHV, stride, 16, 8, 8, 8, 8);\\\n}\\\nstatic void OPNAME ## qpel8_mc13_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[16*9];\\\n    uint8_t halfH[72];\\\n    uint8_t halfHV[64];\\\n    copy_block9(full, src, 16, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(halfH, full, 8, 16, 9);\\\n    put ## RND ## pixels8_l2_8(halfH, halfH, full, 8, 8, 16, 9);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfHV, halfH, 8, 8);\\\n    OPNAME ## pixels8_l2_8(dst, halfH+8, halfHV, stride, 8, 8, 8);\\\n}\\\nvoid ff_ ## OPNAME ## qpel8_mc33_old_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[16*9];\\\n    uint8_t halfH[72];\\\n    uint8_t halfV[64];\\\n    uint8_t halfHV[64];\\\n    copy_block9(full, src, 16, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(halfH, full  , 8, 16, 9);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfV, full+1, 8, 16);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfHV, halfH, 8, 8);\\\n    OPNAME ## pixels8_l4_8(dst, full+17, halfH+8, halfV, halfHV, stride, 16, 8, 8, 8, 8);\\\n}\\\nstatic void OPNAME ## qpel8_mc33_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[16*9];\\\n    uint8_t halfH[72];\\\n    uint8_t halfHV[64];\\\n    copy_block9(full, src, 16, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(halfH, full, 8, 16, 9);\\\n    put ## RND ## pixels8_l2_8(halfH, halfH, full+1, 8, 8, 16, 9);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfHV, halfH, 8, 8);\\\n    OPNAME ## pixels8_l2_8(dst, halfH+8, halfHV, stride, 8, 8, 8);\\\n}\\\nstatic void OPNAME ## qpel8_mc21_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t halfH[72];\\\n    uint8_t halfHV[64];\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(halfH, src, 8, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfHV, halfH, 8, 8);\\\n    OPNAME ## pixels8_l2_8(dst, halfH, halfHV, stride, 8, 8, 8);\\\n}\\\nstatic void OPNAME ## qpel8_mc23_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t halfH[72];\\\n    uint8_t halfHV[64];\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(halfH, src, 8, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfHV, halfH, 8, 8);\\\n    OPNAME ## pixels8_l2_8(dst, halfH+8, halfHV, stride, 8, 8, 8);\\\n}\\\nvoid ff_ ## OPNAME ## qpel8_mc12_old_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[16*9];\\\n    uint8_t halfH[72];\\\n    uint8_t halfV[64];\\\n    uint8_t halfHV[64];\\\n    copy_block9(full, src, 16, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(halfH, full, 8, 16, 9);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfV, full, 8, 16);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfHV, halfH, 8, 8);\\\n    OPNAME ## pixels8_l2_8(dst, halfV, halfHV, stride, 8, 8, 8);\\\n}\\\nstatic void OPNAME ## qpel8_mc12_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[16*9];\\\n    uint8_t halfH[72];\\\n    copy_block9(full, src, 16, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(halfH, full, 8, 16, 9);\\\n    put ## RND ## pixels8_l2_8(halfH, halfH, full, 8, 8, 16, 9);\\\n    OPNAME ## mpeg4_qpel8_v_lowpass(dst, halfH, stride, 8);\\\n}\\\nvoid ff_ ## OPNAME ## qpel8_mc32_old_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[16*9];\\\n    uint8_t halfH[72];\\\n    uint8_t halfV[64];\\\n    uint8_t halfHV[64];\\\n    copy_block9(full, src, 16, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(halfH, full, 8, 16, 9);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfV, full+1, 8, 16);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfHV, halfH, 8, 8);\\\n    OPNAME ## pixels8_l2_8(dst, halfV, halfHV, stride, 8, 8, 8);\\\n}\\\nstatic void OPNAME ## qpel8_mc32_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[16*9];\\\n    uint8_t halfH[72];\\\n    copy_block9(full, src, 16, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(halfH, full, 8, 16, 9);\\\n    put ## RND ## pixels8_l2_8(halfH, halfH, full+1, 8, 8, 16, 9);\\\n    OPNAME ## mpeg4_qpel8_v_lowpass(dst, halfH, stride, 8);\\\n}\\\nstatic void OPNAME ## qpel8_mc22_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t halfH[72];\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(halfH, src, 8, stride, 9);\\\n    OPNAME ## mpeg4_qpel8_v_lowpass(dst, halfH, stride, 8);\\\n}\\\n\\\nstatic void OPNAME ## qpel16_mc10_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t half[256];\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(half, src, 16, stride, 16);\\\n    OPNAME ## pixels16_l2_8(dst, src, half, stride, stride, 16, 16);\\\n}\\\n\\\nstatic void OPNAME ## qpel16_mc20_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    OPNAME ## mpeg4_qpel16_h_lowpass(dst, src, stride, stride, 16);\\\n}\\\n\\\nstatic void OPNAME ## qpel16_mc30_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t half[256];\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(half, src, 16, stride, 16);\\\n    OPNAME ## pixels16_l2_8(dst, src+1, half, stride, stride, 16, 16);\\\n}\\\n\\\nstatic void OPNAME ## qpel16_mc01_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[24*17];\\\n    uint8_t half[256];\\\n    copy_block17(full, src, 24, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(half, full, 16, 24);\\\n    OPNAME ## pixels16_l2_8(dst, full, half, stride, 24, 16, 16);\\\n}\\\n\\\nstatic void OPNAME ## qpel16_mc02_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[24*17];\\\n    copy_block17(full, src, 24, stride, 17);\\\n    OPNAME ## mpeg4_qpel16_v_lowpass(dst, full, stride, 24);\\\n}\\\n\\\nstatic void OPNAME ## qpel16_mc03_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[24*17];\\\n    uint8_t half[256];\\\n    copy_block17(full, src, 24, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(half, full, 16, 24);\\\n    OPNAME ## pixels16_l2_8(dst, full+24, half, stride, 24, 16, 16);\\\n}\\\nvoid ff_ ## OPNAME ## qpel16_mc11_old_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[24*17];\\\n    uint8_t halfH[272];\\\n    uint8_t halfV[256];\\\n    uint8_t halfHV[256];\\\n    copy_block17(full, src, 24, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(halfH, full, 16, 24, 17);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfV, full, 16, 24);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfHV, halfH, 16, 16);\\\n    OPNAME ## pixels16_l4_8(dst, full, halfH, halfV, halfHV, stride, 24, 16, 16, 16, 16);\\\n}\\\nstatic void OPNAME ## qpel16_mc11_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[24*17];\\\n    uint8_t halfH[272];\\\n    uint8_t halfHV[256];\\\n    copy_block17(full, src, 24, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(halfH, full, 16, 24, 17);\\\n    put ## RND ## pixels16_l2_8(halfH, halfH, full, 16, 16, 24, 17);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfHV, halfH, 16, 16);\\\n    OPNAME ## pixels16_l2_8(dst, halfH, halfHV, stride, 16, 16, 16);\\\n}\\\nvoid ff_ ## OPNAME ## qpel16_mc31_old_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[24*17];\\\n    uint8_t halfH[272];\\\n    uint8_t halfV[256];\\\n    uint8_t halfHV[256];\\\n    copy_block17(full, src, 24, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(halfH, full, 16, 24, 17);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfV, full+1, 16, 24);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfHV, halfH, 16, 16);\\\n    OPNAME ## pixels16_l4_8(dst, full+1, halfH, halfV, halfHV, stride, 24, 16, 16, 16, 16);\\\n}\\\nstatic void OPNAME ## qpel16_mc31_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[24*17];\\\n    uint8_t halfH[272];\\\n    uint8_t halfHV[256];\\\n    copy_block17(full, src, 24, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(halfH, full, 16, 24, 17);\\\n    put ## RND ## pixels16_l2_8(halfH, halfH, full+1, 16, 16, 24, 17);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfHV, halfH, 16, 16);\\\n    OPNAME ## pixels16_l2_8(dst, halfH, halfHV, stride, 16, 16, 16);\\\n}\\\nvoid ff_ ## OPNAME ## qpel16_mc13_old_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[24*17];\\\n    uint8_t halfH[272];\\\n    uint8_t halfV[256];\\\n    uint8_t halfHV[256];\\\n    copy_block17(full, src, 24, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(halfH, full, 16, 24, 17);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfV, full, 16, 24);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfHV, halfH, 16, 16);\\\n    OPNAME ## pixels16_l4_8(dst, full+24, halfH+16, halfV, halfHV, stride, 24, 16, 16, 16, 16);\\\n}\\\nstatic void OPNAME ## qpel16_mc13_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[24*17];\\\n    uint8_t halfH[272];\\\n    uint8_t halfHV[256];\\\n    copy_block17(full, src, 24, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(halfH, full, 16, 24, 17);\\\n    put ## RND ## pixels16_l2_8(halfH, halfH, full, 16, 16, 24, 17);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfHV, halfH, 16, 16);\\\n    OPNAME ## pixels16_l2_8(dst, halfH+16, halfHV, stride, 16, 16, 16);\\\n}\\\nvoid ff_ ## OPNAME ## qpel16_mc33_old_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[24*17];\\\n    uint8_t halfH[272];\\\n    uint8_t halfV[256];\\\n    uint8_t halfHV[256];\\\n    copy_block17(full, src, 24, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(halfH, full  , 16, 24, 17);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfV, full+1, 16, 24);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfHV, halfH, 16, 16);\\\n    OPNAME ## pixels16_l4_8(dst, full+25, halfH+16, halfV, halfHV, stride, 24, 16, 16, 16, 16);\\\n}\\\nstatic void OPNAME ## qpel16_mc33_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[24*17];\\\n    uint8_t halfH[272];\\\n    uint8_t halfHV[256];\\\n    copy_block17(full, src, 24, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(halfH, full, 16, 24, 17);\\\n    put ## RND ## pixels16_l2_8(halfH, halfH, full+1, 16, 16, 24, 17);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfHV, halfH, 16, 16);\\\n    OPNAME ## pixels16_l2_8(dst, halfH+16, halfHV, stride, 16, 16, 16);\\\n}\\\nstatic void OPNAME ## qpel16_mc21_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t halfH[272];\\\n    uint8_t halfHV[256];\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(halfH, src, 16, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfHV, halfH, 16, 16);\\\n    OPNAME ## pixels16_l2_8(dst, halfH, halfHV, stride, 16, 16, 16);\\\n}\\\nstatic void OPNAME ## qpel16_mc23_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t halfH[272];\\\n    uint8_t halfHV[256];\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(halfH, src, 16, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfHV, halfH, 16, 16);\\\n    OPNAME ## pixels16_l2_8(dst, halfH+16, halfHV, stride, 16, 16, 16);\\\n}\\\nvoid ff_ ## OPNAME ## qpel16_mc12_old_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[24*17];\\\n    uint8_t halfH[272];\\\n    uint8_t halfV[256];\\\n    uint8_t halfHV[256];\\\n    copy_block17(full, src, 24, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(halfH, full, 16, 24, 17);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfV, full, 16, 24);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfHV, halfH, 16, 16);\\\n    OPNAME ## pixels16_l2_8(dst, halfV, halfHV, stride, 16, 16, 16);\\\n}\\\nstatic void OPNAME ## qpel16_mc12_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[24*17];\\\n    uint8_t halfH[272];\\\n    copy_block17(full, src, 24, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(halfH, full, 16, 24, 17);\\\n    put ## RND ## pixels16_l2_8(halfH, halfH, full, 16, 16, 24, 17);\\\n    OPNAME ## mpeg4_qpel16_v_lowpass(dst, halfH, stride, 16);\\\n}\\\nvoid ff_ ## OPNAME ## qpel16_mc32_old_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[24*17];\\\n    uint8_t halfH[272];\\\n    uint8_t halfV[256];\\\n    uint8_t halfHV[256];\\\n    copy_block17(full, src, 24, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(halfH, full, 16, 24, 17);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfV, full+1, 16, 24);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfHV, halfH, 16, 16);\\\n    OPNAME ## pixels16_l2_8(dst, halfV, halfHV, stride, 16, 16, 16);\\\n}\\\nstatic void OPNAME ## qpel16_mc32_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[24*17];\\\n    uint8_t halfH[272];\\\n    copy_block17(full, src, 24, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(halfH, full, 16, 24, 17);\\\n    put ## RND ## pixels16_l2_8(halfH, halfH, full+1, 16, 16, 24, 17);\\\n    OPNAME ## mpeg4_qpel16_v_lowpass(dst, halfH, stride, 16);\\\n}\\\nstatic void OPNAME ## qpel16_mc22_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t halfH[272];\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(halfH, src, 16, stride, 17);\\\n    OPNAME ## mpeg4_qpel16_v_lowpass(dst, halfH, stride, 16);\\\n}\n\n#define op_avg(a, b) a = (((a)+cm[((b) + 16)>>5]+1)>>1)\n#define op_avg_no_rnd(a, b) a = (((a)+cm[((b) + 15)>>5])>>1)\n#define op_put(a, b) a = cm[((b) + 16)>>5]\n#define op_put_no_rnd(a, b) a = cm[((b) + 15)>>5]\n\nQPEL_MC(0, put_       , _       , op_put)\nQPEL_MC(1, put_no_rnd_, _no_rnd_, op_put_no_rnd)\nQPEL_MC(0, avg_       , _       , op_avg)\n//QPEL_MC(1, avg_no_rnd , _       , op_avg)\n#undef op_avg\n#undef op_avg_no_rnd\n#undef op_put\n#undef op_put_no_rnd\n\nvoid ff_put_pixels8x8_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    put_pixels8_8_c(dst, src, stride, 8);\n}\nvoid ff_avg_pixels8x8_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    avg_pixels8_8_c(dst, src, stride, 8);\n}\nvoid ff_put_pixels16x16_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    put_pixels16_8_c(dst, src, stride, 16);\n}\nvoid ff_avg_pixels16x16_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    avg_pixels16_8_c(dst, src, stride, 16);\n}\n\n#define put_qpel8_mc00_c  ff_put_pixels8x8_c\n#define avg_qpel8_mc00_c  ff_avg_pixels8x8_c\n#define put_qpel16_mc00_c ff_put_pixels16x16_c\n#define avg_qpel16_mc00_c ff_avg_pixels16x16_c\n#define put_no_rnd_qpel8_mc00_c  ff_put_pixels8x8_c\n#define put_no_rnd_qpel16_mc00_c ff_put_pixels16x16_c\n\nstatic void wmv2_mspel8_h_lowpass(uint8_t *dst, uint8_t *src, int dstStride, int srcStride, int h){\n    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\n    int i;\n\n    for(i=0; i<h; i++){\n        dst[0]= cm[(9*(src[0] + src[1]) - (src[-1] + src[2]) + 8)>>4];\n        dst[1]= cm[(9*(src[1] + src[2]) - (src[ 0] + src[3]) + 8)>>4];\n        dst[2]= cm[(9*(src[2] + src[3]) - (src[ 1] + src[4]) + 8)>>4];\n        dst[3]= cm[(9*(src[3] + src[4]) - (src[ 2] + src[5]) + 8)>>4];\n        dst[4]= cm[(9*(src[4] + src[5]) - (src[ 3] + src[6]) + 8)>>4];\n        dst[5]= cm[(9*(src[5] + src[6]) - (src[ 4] + src[7]) + 8)>>4];\n        dst[6]= cm[(9*(src[6] + src[7]) - (src[ 5] + src[8]) + 8)>>4];\n        dst[7]= cm[(9*(src[7] + src[8]) - (src[ 6] + src[9]) + 8)>>4];\n        dst+=dstStride;\n        src+=srcStride;\n    }\n}\n\n#if CONFIG_RV40_DECODER\nvoid ff_put_rv40_qpel16_mc33_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    put_pixels16_xy2_8_c(dst, src, stride, 16);\n}\nvoid ff_avg_rv40_qpel16_mc33_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    avg_pixels16_xy2_8_c(dst, src, stride, 16);\n}\nvoid ff_put_rv40_qpel8_mc33_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    put_pixels8_xy2_8_c(dst, src, stride, 8);\n}\nvoid ff_avg_rv40_qpel8_mc33_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    avg_pixels8_xy2_8_c(dst, src, stride, 8);\n}\n#endif /* CONFIG_RV40_DECODER */\n\n#if CONFIG_DIRAC_DECODER\n#define DIRAC_MC(OPNAME)\\\nvoid ff_ ## OPNAME ## _dirac_pixels8_c(uint8_t *dst, const uint8_t *src[5], int stride, int h)\\\n{\\\n     OPNAME ## _pixels8_8_c(dst, src[0], stride, h);\\\n}\\\nvoid ff_ ## OPNAME ## _dirac_pixels16_c(uint8_t *dst, const uint8_t *src[5], int stride, int h)\\\n{\\\n    OPNAME ## _pixels16_8_c(dst, src[0], stride, h);\\\n}\\\nvoid ff_ ## OPNAME ## _dirac_pixels32_c(uint8_t *dst, const uint8_t *src[5], int stride, int h)\\\n{\\\n    OPNAME ## _pixels16_8_c(dst   , src[0]   , stride, h);\\\n    OPNAME ## _pixels16_8_c(dst+16, src[0]+16, stride, h);\\\n}\\\nvoid ff_ ## OPNAME ## _dirac_pixels8_l2_c(uint8_t *dst, const uint8_t *src[5], int stride, int h)\\\n{\\\n    OPNAME ## _pixels8_l2_8(dst, src[0], src[1], stride, stride, stride, h);\\\n}\\\nvoid ff_ ## OPNAME ## _dirac_pixels16_l2_c(uint8_t *dst, const uint8_t *src[5], int stride, int h)\\\n{\\\n    OPNAME ## _pixels16_l2_8(dst, src[0], src[1], stride, stride, stride, h);\\\n}\\\nvoid ff_ ## OPNAME ## _dirac_pixels32_l2_c(uint8_t *dst, const uint8_t *src[5], int stride, int h)\\\n{\\\n    OPNAME ## _pixels16_l2_8(dst   , src[0]   , src[1]   , stride, stride, stride, h);\\\n    OPNAME ## _pixels16_l2_8(dst+16, src[0]+16, src[1]+16, stride, stride, stride, h);\\\n}\\\nvoid ff_ ## OPNAME ## _dirac_pixels8_l4_c(uint8_t *dst, const uint8_t *src[5], int stride, int h)\\\n{\\\n    OPNAME ## _pixels8_l4_8(dst, src[0], src[1], src[2], src[3], stride, stride, stride, stride, stride, h);\\\n}\\\nvoid ff_ ## OPNAME ## _dirac_pixels16_l4_c(uint8_t *dst, const uint8_t *src[5], int stride, int h)\\\n{\\\n    OPNAME ## _pixels16_l4_8(dst, src[0], src[1], src[2], src[3], stride, stride, stride, stride, stride, h);\\\n}\\\nvoid ff_ ## OPNAME ## _dirac_pixels32_l4_c(uint8_t *dst, const uint8_t *src[5], int stride, int h)\\\n{\\\n    OPNAME ## _pixels16_l4_8(dst   , src[0]   , src[1]   , src[2]   , src[3]   , stride, stride, stride, stride, stride, h);\\\n    OPNAME ## _pixels16_l4_8(dst+16, src[0]+16, src[1]+16, src[2]+16, src[3]+16, stride, stride, stride, stride, stride, h);\\\n}\nDIRAC_MC(put)\nDIRAC_MC(avg)\n#endif\n\nstatic void wmv2_mspel8_v_lowpass(uint8_t *dst, uint8_t *src, int dstStride, int srcStride, int w){\n    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\n    int i;\n\n    for(i=0; i<w; i++){\n        const int src_1= src[ -srcStride];\n        const int src0 = src[0          ];\n        const int src1 = src[  srcStride];\n        const int src2 = src[2*srcStride];\n        const int src3 = src[3*srcStride];\n        const int src4 = src[4*srcStride];\n        const int src5 = src[5*srcStride];\n        const int src6 = src[6*srcStride];\n        const int src7 = src[7*srcStride];\n        const int src8 = src[8*srcStride];\n        const int src9 = src[9*srcStride];\n        dst[0*dstStride]= cm[(9*(src0 + src1) - (src_1 + src2) + 8)>>4];\n        dst[1*dstStride]= cm[(9*(src1 + src2) - (src0  + src3) + 8)>>4];\n        dst[2*dstStride]= cm[(9*(src2 + src3) - (src1  + src4) + 8)>>4];\n        dst[3*dstStride]= cm[(9*(src3 + src4) - (src2  + src5) + 8)>>4];\n        dst[4*dstStride]= cm[(9*(src4 + src5) - (src3  + src6) + 8)>>4];\n        dst[5*dstStride]= cm[(9*(src5 + src6) - (src4  + src7) + 8)>>4];\n        dst[6*dstStride]= cm[(9*(src6 + src7) - (src5  + src8) + 8)>>4];\n        dst[7*dstStride]= cm[(9*(src7 + src8) - (src6  + src9) + 8)>>4];\n        src++;\n        dst++;\n    }\n}\n\nstatic void put_mspel8_mc10_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    uint8_t half[64];\n    wmv2_mspel8_h_lowpass(half, src, 8, stride, 8);\n    put_pixels8_l2_8(dst, src, half, stride, stride, 8, 8);\n}\n\nstatic void put_mspel8_mc20_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    wmv2_mspel8_h_lowpass(dst, src, stride, stride, 8);\n}\n\nstatic void put_mspel8_mc30_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    uint8_t half[64];\n    wmv2_mspel8_h_lowpass(half, src, 8, stride, 8);\n    put_pixels8_l2_8(dst, src+1, half, stride, stride, 8, 8);\n}\n\nstatic void put_mspel8_mc02_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    wmv2_mspel8_v_lowpass(dst, src, stride, stride, 8);\n}\n\nstatic void put_mspel8_mc12_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    uint8_t halfH[88];\n    uint8_t halfV[64];\n    uint8_t halfHV[64];\n    wmv2_mspel8_h_lowpass(halfH, src-stride, 8, stride, 11);\n    wmv2_mspel8_v_lowpass(halfV, src, 8, stride, 8);\n    wmv2_mspel8_v_lowpass(halfHV, halfH+8, 8, 8, 8);\n    put_pixels8_l2_8(dst, halfV, halfHV, stride, 8, 8, 8);\n}\nstatic void put_mspel8_mc32_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    uint8_t halfH[88];\n    uint8_t halfV[64];\n    uint8_t halfHV[64];\n    wmv2_mspel8_h_lowpass(halfH, src-stride, 8, stride, 11);\n    wmv2_mspel8_v_lowpass(halfV, src+1, 8, stride, 8);\n    wmv2_mspel8_v_lowpass(halfHV, halfH+8, 8, 8, 8);\n    put_pixels8_l2_8(dst, halfV, halfHV, stride, 8, 8, 8);\n}\nstatic void put_mspel8_mc22_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    uint8_t halfH[88];\n    wmv2_mspel8_h_lowpass(halfH, src-stride, 8, stride, 11);\n    wmv2_mspel8_v_lowpass(dst, halfH+8, stride, 8, 8);\n}\n\nstatic void h263_v_loop_filter_c(uint8_t *src, int stride, int qscale){\n    if(CONFIG_H263_DECODER || CONFIG_H263_ENCODER) {\n    int x;\n    const int strength= ff_h263_loop_filter_strength[qscale];\n\n    for(x=0; x<8; x++){\n        int d1, d2, ad1;\n        int p0= src[x-2*stride];\n        int p1= src[x-1*stride];\n        int p2= src[x+0*stride];\n        int p3= src[x+1*stride];\n        int d = (p0 - p3 + 4*(p2 - p1)) / 8;\n\n        if     (d<-2*strength) d1= 0;\n        else if(d<-  strength) d1=-2*strength - d;\n        else if(d<   strength) d1= d;\n        else if(d< 2*strength) d1= 2*strength - d;\n        else                   d1= 0;\n\n        p1 += d1;\n        p2 -= d1;\n        if(p1&256) p1= ~(p1>>31);\n        if(p2&256) p2= ~(p2>>31);\n\n        src[x-1*stride] = p1;\n        src[x+0*stride] = p2;\n\n        ad1= FFABS(d1)>>1;\n\n        d2= av_clip((p0-p3)/4, -ad1, ad1);\n\n        src[x-2*stride] = p0 - d2;\n        src[x+  stride] = p3 + d2;\n    }\n    }\n}\n\nstatic void h263_h_loop_filter_c(uint8_t *src, int stride, int qscale){\n    if(CONFIG_H263_DECODER || CONFIG_H263_ENCODER) {\n    int y;\n    const int strength= ff_h263_loop_filter_strength[qscale];\n\n    for(y=0; y<8; y++){\n        int d1, d2, ad1;\n        int p0= src[y*stride-2];\n        int p1= src[y*stride-1];\n        int p2= src[y*stride+0];\n        int p3= src[y*stride+1];\n        int d = (p0 - p3 + 4*(p2 - p1)) / 8;\n\n        if     (d<-2*strength) d1= 0;\n        else if(d<-  strength) d1=-2*strength - d;\n        else if(d<   strength) d1= d;\n        else if(d< 2*strength) d1= 2*strength - d;\n        else                   d1= 0;\n\n        p1 += d1;\n        p2 -= d1;\n        if(p1&256) p1= ~(p1>>31);\n        if(p2&256) p2= ~(p2>>31);\n\n        src[y*stride-1] = p1;\n        src[y*stride+0] = p2;\n\n        ad1= FFABS(d1)>>1;\n\n        d2= av_clip((p0-p3)/4, -ad1, ad1);\n\n        src[y*stride-2] = p0 - d2;\n        src[y*stride+1] = p3 + d2;\n    }\n    }\n}\n\nstatic inline int pix_abs16_c(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)\n{\n    int s, i;\n\n    s = 0;\n    for(i=0;i<h;i++) {\n        s += abs(pix1[0] - pix2[0]);\n        s += abs(pix1[1] - pix2[1]);\n        s += abs(pix1[2] - pix2[2]);\n        s += abs(pix1[3] - pix2[3]);\n        s += abs(pix1[4] - pix2[4]);\n        s += abs(pix1[5] - pix2[5]);\n        s += abs(pix1[6] - pix2[6]);\n        s += abs(pix1[7] - pix2[7]);\n        s += abs(pix1[8] - pix2[8]);\n        s += abs(pix1[9] - pix2[9]);\n        s += abs(pix1[10] - pix2[10]);\n        s += abs(pix1[11] - pix2[11]);\n        s += abs(pix1[12] - pix2[12]);\n        s += abs(pix1[13] - pix2[13]);\n        s += abs(pix1[14] - pix2[14]);\n        s += abs(pix1[15] - pix2[15]);\n        pix1 += line_size;\n        pix2 += line_size;\n    }\n    return s;\n}\n\nstatic int pix_abs16_x2_c(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)\n{\n    int s, i;\n\n    s = 0;\n    for(i=0;i<h;i++) {\n        s += abs(pix1[0] - avg2(pix2[0], pix2[1]));\n        s += abs(pix1[1] - avg2(pix2[1], pix2[2]));\n        s += abs(pix1[2] - avg2(pix2[2], pix2[3]));\n        s += abs(pix1[3] - avg2(pix2[3], pix2[4]));\n        s += abs(pix1[4] - avg2(pix2[4], pix2[5]));\n        s += abs(pix1[5] - avg2(pix2[5], pix2[6]));\n        s += abs(pix1[6] - avg2(pix2[6], pix2[7]));\n        s += abs(pix1[7] - avg2(pix2[7], pix2[8]));\n        s += abs(pix1[8] - avg2(pix2[8], pix2[9]));\n        s += abs(pix1[9] - avg2(pix2[9], pix2[10]));\n        s += abs(pix1[10] - avg2(pix2[10], pix2[11]));\n        s += abs(pix1[11] - avg2(pix2[11], pix2[12]));\n        s += abs(pix1[12] - avg2(pix2[12], pix2[13]));\n        s += abs(pix1[13] - avg2(pix2[13], pix2[14]));\n        s += abs(pix1[14] - avg2(pix2[14], pix2[15]));\n        s += abs(pix1[15] - avg2(pix2[15], pix2[16]));\n        pix1 += line_size;\n        pix2 += line_size;\n    }\n    return s;\n}\n\nstatic int pix_abs16_y2_c(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)\n{\n    int s, i;\n    uint8_t *pix3 = pix2 + line_size;\n\n    s = 0;\n    for(i=0;i<h;i++) {\n        s += abs(pix1[0] - avg2(pix2[0], pix3[0]));\n        s += abs(pix1[1] - avg2(pix2[1], pix3[1]));\n        s += abs(pix1[2] - avg2(pix2[2], pix3[2]));\n        s += abs(pix1[3] - avg2(pix2[3], pix3[3]));\n        s += abs(pix1[4] - avg2(pix2[4], pix3[4]));\n        s += abs(pix1[5] - avg2(pix2[5], pix3[5]));\n        s += abs(pix1[6] - avg2(pix2[6], pix3[6]));\n        s += abs(pix1[7] - avg2(pix2[7], pix3[7]));\n        s += abs(pix1[8] - avg2(pix2[8], pix3[8]));\n        s += abs(pix1[9] - avg2(pix2[9], pix3[9]));\n        s += abs(pix1[10] - avg2(pix2[10], pix3[10]));\n        s += abs(pix1[11] - avg2(pix2[11], pix3[11]));\n        s += abs(pix1[12] - avg2(pix2[12], pix3[12]));\n        s += abs(pix1[13] - avg2(pix2[13], pix3[13]));\n        s += abs(pix1[14] - avg2(pix2[14], pix3[14]));\n        s += abs(pix1[15] - avg2(pix2[15], pix3[15]));\n        pix1 += line_size;\n        pix2 += line_size;\n        pix3 += line_size;\n    }\n    return s;\n}\n\nstatic int pix_abs16_xy2_c(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)\n{\n    int s, i;\n    uint8_t *pix3 = pix2 + line_size;\n\n    s = 0;\n    for(i=0;i<h;i++) {\n        s += abs(pix1[0] - avg4(pix2[0], pix2[1], pix3[0], pix3[1]));\n        s += abs(pix1[1] - avg4(pix2[1], pix2[2], pix3[1], pix3[2]));\n        s += abs(pix1[2] - avg4(pix2[2], pix2[3], pix3[2], pix3[3]));\n        s += abs(pix1[3] - avg4(pix2[3], pix2[4], pix3[3], pix3[4]));\n        s += abs(pix1[4] - avg4(pix2[4], pix2[5], pix3[4], pix3[5]));\n        s += abs(pix1[5] - avg4(pix2[5], pix2[6], pix3[5], pix3[6]));\n        s += abs(pix1[6] - avg4(pix2[6], pix2[7], pix3[6], pix3[7]));\n        s += abs(pix1[7] - avg4(pix2[7], pix2[8], pix3[7], pix3[8]));\n        s += abs(pix1[8] - avg4(pix2[8], pix2[9], pix3[8], pix3[9]));\n        s += abs(pix1[9] - avg4(pix2[9], pix2[10], pix3[9], pix3[10]));\n        s += abs(pix1[10] - avg4(pix2[10], pix2[11], pix3[10], pix3[11]));\n        s += abs(pix1[11] - avg4(pix2[11], pix2[12], pix3[11], pix3[12]));\n        s += abs(pix1[12] - avg4(pix2[12], pix2[13], pix3[12], pix3[13]));\n        s += abs(pix1[13] - avg4(pix2[13], pix2[14], pix3[13], pix3[14]));\n        s += abs(pix1[14] - avg4(pix2[14], pix2[15], pix3[14], pix3[15]));\n        s += abs(pix1[15] - avg4(pix2[15], pix2[16], pix3[15], pix3[16]));\n        pix1 += line_size;\n        pix2 += line_size;\n        pix3 += line_size;\n    }\n    return s;\n}\n\nstatic inline int pix_abs8_c(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)\n{\n    int s, i;\n\n    s = 0;\n    for(i=0;i<h;i++) {\n        s += abs(pix1[0] - pix2[0]);\n        s += abs(pix1[1] - pix2[1]);\n        s += abs(pix1[2] - pix2[2]);\n        s += abs(pix1[3] - pix2[3]);\n        s += abs(pix1[4] - pix2[4]);\n        s += abs(pix1[5] - pix2[5]);\n        s += abs(pix1[6] - pix2[6]);\n        s += abs(pix1[7] - pix2[7]);\n        pix1 += line_size;\n        pix2 += line_size;\n    }\n    return s;\n}\n\nstatic int pix_abs8_x2_c(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)\n{\n    int s, i;\n\n    s = 0;\n    for(i=0;i<h;i++) {\n        s += abs(pix1[0] - avg2(pix2[0], pix2[1]));\n        s += abs(pix1[1] - avg2(pix2[1], pix2[2]));\n        s += abs(pix1[2] - avg2(pix2[2], pix2[3]));\n        s += abs(pix1[3] - avg2(pix2[3], pix2[4]));\n        s += abs(pix1[4] - avg2(pix2[4], pix2[5]));\n        s += abs(pix1[5] - avg2(pix2[5], pix2[6]));\n        s += abs(pix1[6] - avg2(pix2[6], pix2[7]));\n        s += abs(pix1[7] - avg2(pix2[7], pix2[8]));\n        pix1 += line_size;\n        pix2 += line_size;\n    }\n    return s;\n}\n\nstatic int pix_abs8_y2_c(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)\n{\n    int s, i;\n    uint8_t *pix3 = pix2 + line_size;\n\n    s = 0;\n    for(i=0;i<h;i++) {\n        s += abs(pix1[0] - avg2(pix2[0], pix3[0]));\n        s += abs(pix1[1] - avg2(pix2[1], pix3[1]));\n        s += abs(pix1[2] - avg2(pix2[2], pix3[2]));\n        s += abs(pix1[3] - avg2(pix2[3], pix3[3]));\n        s += abs(pix1[4] - avg2(pix2[4], pix3[4]));\n        s += abs(pix1[5] - avg2(pix2[5], pix3[5]));\n        s += abs(pix1[6] - avg2(pix2[6], pix3[6]));\n        s += abs(pix1[7] - avg2(pix2[7], pix3[7]));\n        pix1 += line_size;\n        pix2 += line_size;\n        pix3 += line_size;\n    }\n    return s;\n}\n\nstatic int pix_abs8_xy2_c(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)\n{\n    int s, i;\n    uint8_t *pix3 = pix2 + line_size;\n\n    s = 0;\n    for(i=0;i<h;i++) {\n        s += abs(pix1[0] - avg4(pix2[0], pix2[1], pix3[0], pix3[1]));\n        s += abs(pix1[1] - avg4(pix2[1], pix2[2], pix3[1], pix3[2]));\n        s += abs(pix1[2] - avg4(pix2[2], pix2[3], pix3[2], pix3[3]));\n        s += abs(pix1[3] - avg4(pix2[3], pix2[4], pix3[3], pix3[4]));\n        s += abs(pix1[4] - avg4(pix2[4], pix2[5], pix3[4], pix3[5]));\n        s += abs(pix1[5] - avg4(pix2[5], pix2[6], pix3[5], pix3[6]));\n        s += abs(pix1[6] - avg4(pix2[6], pix2[7], pix3[6], pix3[7]));\n        s += abs(pix1[7] - avg4(pix2[7], pix2[8], pix3[7], pix3[8]));\n        pix1 += line_size;\n        pix2 += line_size;\n        pix3 += line_size;\n    }\n    return s;\n}\n\nstatic int nsse16_c(void *v, uint8_t *s1, uint8_t *s2, int stride, int h){\n    MpegEncContext *c = v;\n    int score1=0;\n    int score2=0;\n    int x,y;\n\n    for(y=0; y<h; y++){\n        for(x=0; x<16; x++){\n            score1+= (s1[x  ] - s2[x ])*(s1[x  ] - s2[x ]);\n        }\n        if(y+1<h){\n            for(x=0; x<15; x++){\n                score2+= FFABS(  s1[x  ] - s1[x  +stride]\n                             - s1[x+1] + s1[x+1+stride])\n                        -FFABS(  s2[x  ] - s2[x  +stride]\n                             - s2[x+1] + s2[x+1+stride]);\n            }\n        }\n        s1+= stride;\n        s2+= stride;\n    }\n\n    if(c) return score1 + FFABS(score2)*c->avctx->nsse_weight;\n    else  return score1 + FFABS(score2)*8;\n}\n\nstatic int nsse8_c(void *v, uint8_t *s1, uint8_t *s2, int stride, int h){\n    MpegEncContext *c = v;\n    int score1=0;\n    int score2=0;\n    int x,y;\n\n    for(y=0; y<h; y++){\n        for(x=0; x<8; x++){\n            score1+= (s1[x  ] - s2[x ])*(s1[x  ] - s2[x ]);\n        }\n        if(y+1<h){\n            for(x=0; x<7; x++){\n                score2+= FFABS(  s1[x  ] - s1[x  +stride]\n                             - s1[x+1] + s1[x+1+stride])\n                        -FFABS(  s2[x  ] - s2[x  +stride]\n                             - s2[x+1] + s2[x+1+stride]);\n            }\n        }\n        s1+= stride;\n        s2+= stride;\n    }\n\n    if(c) return score1 + FFABS(score2)*c->avctx->nsse_weight;\n    else  return score1 + FFABS(score2)*8;\n}\n\nstatic int try_8x8basis_c(int16_t rem[64], int16_t weight[64], int16_t basis[64], int scale){\n    int i;\n    unsigned int sum=0;\n\n    for(i=0; i<8*8; i++){\n        int b= rem[i] + ((basis[i]*scale + (1<<(BASIS_SHIFT - RECON_SHIFT-1)))>>(BASIS_SHIFT - RECON_SHIFT));\n        int w= weight[i];\n        b>>= RECON_SHIFT;\n        av_assert2(-512<b && b<512);\n\n        sum += (w*b)*(w*b)>>4;\n    }\n    return sum>>2;\n}\n\nstatic void add_8x8basis_c(int16_t rem[64], int16_t basis[64], int scale){\n    int i;\n\n    for(i=0; i<8*8; i++){\n        rem[i] += (basis[i]*scale + (1<<(BASIS_SHIFT - RECON_SHIFT-1)))>>(BASIS_SHIFT - RECON_SHIFT);\n    }\n}\n\nstatic int zero_cmp(void *s, uint8_t *a, uint8_t *b, int stride, int h){\n    return 0;\n}\n\nvoid ff_set_cmp(DSPContext* c, me_cmp_func *cmp, int type){\n    int i;\n\n    memset(cmp, 0, sizeof(void*)*6);\n\n    for(i=0; i<6; i++){\n        switch(type&0xFF){\n        case FF_CMP_SAD:\n            cmp[i]= c->sad[i];\n            break;\n        case FF_CMP_SATD:\n            cmp[i]= c->hadamard8_diff[i];\n            break;\n        case FF_CMP_SSE:\n            cmp[i]= c->sse[i];\n            break;\n        case FF_CMP_DCT:\n            cmp[i]= c->dct_sad[i];\n            break;\n        case FF_CMP_DCT264:\n            cmp[i]= c->dct264_sad[i];\n            break;\n        case FF_CMP_DCTMAX:\n            cmp[i]= c->dct_max[i];\n            break;\n        case FF_CMP_PSNR:\n            cmp[i]= c->quant_psnr[i];\n            break;\n        case FF_CMP_BIT:\n            cmp[i]= c->bit[i];\n            break;\n        case FF_CMP_RD:\n            cmp[i]= c->rd[i];\n            break;\n        case FF_CMP_VSAD:\n            cmp[i]= c->vsad[i];\n            break;\n        case FF_CMP_VSSE:\n            cmp[i]= c->vsse[i];\n            break;\n        case FF_CMP_ZERO:\n            cmp[i]= zero_cmp;\n            break;\n        case FF_CMP_NSSE:\n            cmp[i]= c->nsse[i];\n            break;\n#if CONFIG_DWT\n        case FF_CMP_W53:\n            cmp[i]= c->w53[i];\n            break;\n        case FF_CMP_W97:\n            cmp[i]= c->w97[i];\n            break;\n#endif\n        default:\n            av_log(NULL, AV_LOG_ERROR,\"internal error in cmp function selection\\n\");\n        }\n    }\n}\n\nstatic void add_bytes_c(uint8_t *dst, uint8_t *src, int w){\n    long i;\n    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){\n        long a = *(long*)(src+i);\n        long b = *(long*)(dst+i);\n        *(long*)(dst+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);\n    }\n    for(; i<w; i++)\n        dst[i+0] += src[i+0];\n}\n\nstatic void diff_bytes_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2, int w){\n    long i;\n#if !HAVE_FAST_UNALIGNED\n    if((long)src2 & (sizeof(long)-1)){\n        for(i=0; i+7<w; i+=8){\n            dst[i+0] = src1[i+0]-src2[i+0];\n            dst[i+1] = src1[i+1]-src2[i+1];\n            dst[i+2] = src1[i+2]-src2[i+2];\n            dst[i+3] = src1[i+3]-src2[i+3];\n            dst[i+4] = src1[i+4]-src2[i+4];\n            dst[i+5] = src1[i+5]-src2[i+5];\n            dst[i+6] = src1[i+6]-src2[i+6];\n            dst[i+7] = src1[i+7]-src2[i+7];\n        }\n    }else\n#endif\n    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){\n        long a = *(long*)(src1+i);\n        long b = *(long*)(src2+i);\n        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);\n    }\n    for(; i<w; i++)\n        dst[i+0] = src1[i+0]-src2[i+0];\n}\n\nstatic void add_hfyu_median_prediction_c(uint8_t *dst, const uint8_t *src1, const uint8_t *diff, int w, int *left, int *left_top){\n    int i;\n    uint8_t l, lt;\n\n    l= *left;\n    lt= *left_top;\n\n    for(i=0; i<w; i++){\n        l= mid_pred(l, src1[i], (l + src1[i] - lt)&0xFF) + diff[i];\n        lt= src1[i];\n        dst[i]= l;\n    }\n\n    *left= l;\n    *left_top= lt;\n}\n\nstatic void sub_hfyu_median_prediction_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2, int w, int *left, int *left_top){\n    int i;\n    uint8_t l, lt;\n\n    l= *left;\n    lt= *left_top;\n\n    for(i=0; i<w; i++){\n        const int pred= mid_pred(l, src1[i], (l + src1[i] - lt)&0xFF);\n        lt= src1[i];\n        l= src2[i];\n        dst[i]= l - pred;\n    }\n\n    *left= l;\n    *left_top= lt;\n}\n\nstatic int add_hfyu_left_prediction_c(uint8_t *dst, const uint8_t *src, int w, int acc){\n    int i;\n\n    for(i=0; i<w-1; i++){\n        acc+= src[i];\n        dst[i]= acc;\n        i++;\n        acc+= src[i];\n        dst[i]= acc;\n    }\n\n    for(; i<w; i++){\n        acc+= src[i];\n        dst[i]= acc;\n    }\n\n    return acc;\n}\n\n#if HAVE_BIGENDIAN\n#define B 3\n#define G 2\n#define R 1\n#define A 0\n#else\n#define B 0\n#define G 1\n#define R 2\n#define A 3\n#endif\nstatic void add_hfyu_left_prediction_bgr32_c(uint8_t *dst, const uint8_t *src, int w, int *red, int *green, int *blue, int *alpha){\n    int i;\n    int r,g,b,a;\n    r= *red;\n    g= *green;\n    b= *blue;\n    a= *alpha;\n\n    for(i=0; i<w; i++){\n        b+= src[4*i+B];\n        g+= src[4*i+G];\n        r+= src[4*i+R];\n        a+= src[4*i+A];\n\n        dst[4*i+B]= b;\n        dst[4*i+G]= g;\n        dst[4*i+R]= r;\n        dst[4*i+A]= a;\n    }\n\n    *red= r;\n    *green= g;\n    *blue= b;\n    *alpha= a;\n}\n#undef B\n#undef G\n#undef R\n#undef A\n\n#define BUTTERFLY2(o1,o2,i1,i2) \\\no1= (i1)+(i2);\\\no2= (i1)-(i2);\n\n#define BUTTERFLY1(x,y) \\\n{\\\n    int a,b;\\\n    a= x;\\\n    b= y;\\\n    x= a+b;\\\n    y= a-b;\\\n}\n\n#define BUTTERFLYA(x,y) (FFABS((x)+(y)) + FFABS((x)-(y)))\n\nstatic int hadamard8_diff8x8_c(/*MpegEncContext*/ void *s, uint8_t *dst, uint8_t *src, int stride, int h){\n    int i;\n    int temp[64];\n    int sum=0;\n\n    av_assert2(h==8);\n\n    for(i=0; i<8; i++){\n        //FIXME try pointer walks\n        BUTTERFLY2(temp[8*i+0], temp[8*i+1], src[stride*i+0]-dst[stride*i+0],src[stride*i+1]-dst[stride*i+1]);\n        BUTTERFLY2(temp[8*i+2], temp[8*i+3], src[stride*i+2]-dst[stride*i+2],src[stride*i+3]-dst[stride*i+3]);\n        BUTTERFLY2(temp[8*i+4], temp[8*i+5], src[stride*i+4]-dst[stride*i+4],src[stride*i+5]-dst[stride*i+5]);\n        BUTTERFLY2(temp[8*i+6], temp[8*i+7], src[stride*i+6]-dst[stride*i+6],src[stride*i+7]-dst[stride*i+7]);\n\n        BUTTERFLY1(temp[8*i+0], temp[8*i+2]);\n        BUTTERFLY1(temp[8*i+1], temp[8*i+3]);\n        BUTTERFLY1(temp[8*i+4], temp[8*i+6]);\n        BUTTERFLY1(temp[8*i+5], temp[8*i+7]);\n\n        BUTTERFLY1(temp[8*i+0], temp[8*i+4]);\n        BUTTERFLY1(temp[8*i+1], temp[8*i+5]);\n        BUTTERFLY1(temp[8*i+2], temp[8*i+6]);\n        BUTTERFLY1(temp[8*i+3], temp[8*i+7]);\n    }\n\n    for(i=0; i<8; i++){\n        BUTTERFLY1(temp[8*0+i], temp[8*1+i]);\n        BUTTERFLY1(temp[8*2+i], temp[8*3+i]);\n        BUTTERFLY1(temp[8*4+i], temp[8*5+i]);\n        BUTTERFLY1(temp[8*6+i], temp[8*7+i]);\n\n        BUTTERFLY1(temp[8*0+i], temp[8*2+i]);\n        BUTTERFLY1(temp[8*1+i], temp[8*3+i]);\n        BUTTERFLY1(temp[8*4+i], temp[8*6+i]);\n        BUTTERFLY1(temp[8*5+i], temp[8*7+i]);\n\n        sum +=\n             BUTTERFLYA(temp[8*0+i], temp[8*4+i])\n            +BUTTERFLYA(temp[8*1+i], temp[8*5+i])\n            +BUTTERFLYA(temp[8*2+i], temp[8*6+i])\n            +BUTTERFLYA(temp[8*3+i], temp[8*7+i]);\n    }\n    return sum;\n}\n\nstatic int hadamard8_intra8x8_c(/*MpegEncContext*/ void *s, uint8_t *src, uint8_t *dummy, int stride, int h){\n    int i;\n    int temp[64];\n    int sum=0;\n\n    av_assert2(h==8);\n\n    for(i=0; i<8; i++){\n        //FIXME try pointer walks\n        BUTTERFLY2(temp[8*i+0], temp[8*i+1], src[stride*i+0],src[stride*i+1]);\n        BUTTERFLY2(temp[8*i+2], temp[8*i+3], src[stride*i+2],src[stride*i+3]);\n        BUTTERFLY2(temp[8*i+4], temp[8*i+5], src[stride*i+4],src[stride*i+5]);\n        BUTTERFLY2(temp[8*i+6], temp[8*i+7], src[stride*i+6],src[stride*i+7]);\n\n        BUTTERFLY1(temp[8*i+0], temp[8*i+2]);\n        BUTTERFLY1(temp[8*i+1], temp[8*i+3]);\n        BUTTERFLY1(temp[8*i+4], temp[8*i+6]);\n        BUTTERFLY1(temp[8*i+5], temp[8*i+7]);\n\n        BUTTERFLY1(temp[8*i+0], temp[8*i+4]);\n        BUTTERFLY1(temp[8*i+1], temp[8*i+5]);\n        BUTTERFLY1(temp[8*i+2], temp[8*i+6]);\n        BUTTERFLY1(temp[8*i+3], temp[8*i+7]);\n    }\n\n    for(i=0; i<8; i++){\n        BUTTERFLY1(temp[8*0+i], temp[8*1+i]);\n        BUTTERFLY1(temp[8*2+i], temp[8*3+i]);\n        BUTTERFLY1(temp[8*4+i], temp[8*5+i]);\n        BUTTERFLY1(temp[8*6+i], temp[8*7+i]);\n\n        BUTTERFLY1(temp[8*0+i], temp[8*2+i]);\n        BUTTERFLY1(temp[8*1+i], temp[8*3+i]);\n        BUTTERFLY1(temp[8*4+i], temp[8*6+i]);\n        BUTTERFLY1(temp[8*5+i], temp[8*7+i]);\n\n        sum +=\n             BUTTERFLYA(temp[8*0+i], temp[8*4+i])\n            +BUTTERFLYA(temp[8*1+i], temp[8*5+i])\n            +BUTTERFLYA(temp[8*2+i], temp[8*6+i])\n            +BUTTERFLYA(temp[8*3+i], temp[8*7+i]);\n    }\n\n    sum -= FFABS(temp[8*0] + temp[8*4]); // -mean\n\n    return sum;\n}\n\nstatic int dct_sad8x8_c(/*MpegEncContext*/ void *c, uint8_t *src1, uint8_t *src2, int stride, int h){\n    MpegEncContext * const s= (MpegEncContext *)c;\n    LOCAL_ALIGNED_16(int16_t, temp, [64]);\n\n    av_assert2(h==8);\n\n    s->dsp.diff_pixels(temp, src1, src2, stride);\n    s->dsp.fdct(temp);\n    return s->dsp.sum_abs_dctelem(temp);\n}\n\n#if CONFIG_GPL\n#define DCT8_1D {\\\n    const int s07 = SRC(0) + SRC(7);\\\n    const int s16 = SRC(1) + SRC(6);\\\n    const int s25 = SRC(2) + SRC(5);\\\n    const int s34 = SRC(3) + SRC(4);\\\n    const int a0 = s07 + s34;\\\n    const int a1 = s16 + s25;\\\n    const int a2 = s07 - s34;\\\n    const int a3 = s16 - s25;\\\n    const int d07 = SRC(0) - SRC(7);\\\n    const int d16 = SRC(1) - SRC(6);\\\n    const int d25 = SRC(2) - SRC(5);\\\n    const int d34 = SRC(3) - SRC(4);\\\n    const int a4 = d16 + d25 + (d07 + (d07>>1));\\\n    const int a5 = d07 - d34 - (d25 + (d25>>1));\\\n    const int a6 = d07 + d34 - (d16 + (d16>>1));\\\n    const int a7 = d16 - d25 + (d34 + (d34>>1));\\\n    DST(0,  a0 + a1     ) ;\\\n    DST(1,  a4 + (a7>>2)) ;\\\n    DST(2,  a2 + (a3>>1)) ;\\\n    DST(3,  a5 + (a6>>2)) ;\\\n    DST(4,  a0 - a1     ) ;\\\n    DST(5,  a6 - (a5>>2)) ;\\\n    DST(6, (a2>>1) - a3 ) ;\\\n    DST(7, (a4>>2) - a7 ) ;\\\n}\n\nstatic int dct264_sad8x8_c(/*MpegEncContext*/ void *c, uint8_t *src1, uint8_t *src2, int stride, int h){\n    MpegEncContext * const s= (MpegEncContext *)c;\n    int16_t dct[8][8];\n    int i;\n    int sum=0;\n\n    s->dsp.diff_pixels(dct[0], src1, src2, stride);\n\n#define SRC(x) dct[i][x]\n#define DST(x,v) dct[i][x]= v\n    for( i = 0; i < 8; i++ )\n        DCT8_1D\n#undef SRC\n#undef DST\n\n#define SRC(x) dct[x][i]\n#define DST(x,v) sum += FFABS(v)\n    for( i = 0; i < 8; i++ )\n        DCT8_1D\n#undef SRC\n#undef DST\n    return sum;\n}\n#endif\n\nstatic int dct_max8x8_c(/*MpegEncContext*/ void *c, uint8_t *src1, uint8_t *src2, int stride, int h){\n    MpegEncContext * const s= (MpegEncContext *)c;\n    LOCAL_ALIGNED_16(int16_t, temp, [64]);\n    int sum=0, i;\n\n    av_assert2(h==8);\n\n    s->dsp.diff_pixels(temp, src1, src2, stride);\n    s->dsp.fdct(temp);\n\n    for(i=0; i<64; i++)\n        sum= FFMAX(sum, FFABS(temp[i]));\n\n    return sum;\n}\n\nstatic int quant_psnr8x8_c(/*MpegEncContext*/ void *c, uint8_t *src1, uint8_t *src2, int stride, int h){\n    MpegEncContext * const s= (MpegEncContext *)c;\n    LOCAL_ALIGNED_16(int16_t, temp, [64*2]);\n    int16_t * const bak = temp+64;\n    int sum=0, i;\n\n    av_assert2(h==8);\n    s->mb_intra=0;\n\n    s->dsp.diff_pixels(temp, src1, src2, stride);\n\n    memcpy(bak, temp, 64*sizeof(int16_t));\n\n    s->block_last_index[0/*FIXME*/]= s->fast_dct_quantize(s, temp, 0/*FIXME*/, s->qscale, &i);\n    s->dct_unquantize_inter(s, temp, 0, s->qscale);\n    ff_simple_idct_8(temp); //FIXME\n\n    for(i=0; i<64; i++)\n        sum+= (temp[i]-bak[i])*(temp[i]-bak[i]);\n\n    return sum;\n}\n\nstatic int rd8x8_c(/*MpegEncContext*/ void *c, uint8_t *src1, uint8_t *src2, int stride, int h){\n    MpegEncContext * const s= (MpegEncContext *)c;\n    const uint8_t *scantable= s->intra_scantable.permutated;\n    LOCAL_ALIGNED_16(int16_t, temp, [64]);\n    LOCAL_ALIGNED_16(uint8_t, lsrc1, [64]);\n    LOCAL_ALIGNED_16(uint8_t, lsrc2, [64]);\n    int i, last, run, bits, level, distortion, start_i;\n    const int esc_length= s->ac_esc_length;\n    uint8_t * length;\n    uint8_t * last_length;\n\n    av_assert2(h==8);\n\n    copy_block8(lsrc1, src1, 8, stride, 8);\n    copy_block8(lsrc2, src2, 8, stride, 8);\n\n    s->dsp.diff_pixels(temp, lsrc1, lsrc2, 8);\n\n    s->block_last_index[0/*FIXME*/]= last= s->fast_dct_quantize(s, temp, 0/*FIXME*/, s->qscale, &i);\n\n    bits=0;\n\n    if (s->mb_intra) {\n        start_i = 1;\n        length     = s->intra_ac_vlc_length;\n        last_length= s->intra_ac_vlc_last_length;\n        bits+= s->luma_dc_vlc_length[temp[0] + 256]; //FIXME chroma\n    } else {\n        start_i = 0;\n        length     = s->inter_ac_vlc_length;\n        last_length= s->inter_ac_vlc_last_length;\n    }\n\n    if(last>=start_i){\n        run=0;\n        for(i=start_i; i<last; i++){\n            int j= scantable[i];\n            level= temp[j];\n\n            if(level){\n                level+=64;\n                if((level&(~127)) == 0){\n                    bits+= length[UNI_AC_ENC_INDEX(run, level)];\n                }else\n                    bits+= esc_length;\n                run=0;\n            }else\n                run++;\n        }\n        i= scantable[last];\n\n        level= temp[i] + 64;\n\n        av_assert2(level - 64);\n\n        if((level&(~127)) == 0){\n            bits+= last_length[UNI_AC_ENC_INDEX(run, level)];\n        }else\n            bits+= esc_length;\n\n    }\n\n    if(last>=0){\n        if(s->mb_intra)\n            s->dct_unquantize_intra(s, temp, 0, s->qscale);\n        else\n            s->dct_unquantize_inter(s, temp, 0, s->qscale);\n    }\n\n    s->dsp.idct_add(lsrc2, 8, temp);\n\n    distortion= s->dsp.sse[1](NULL, lsrc2, lsrc1, 8, 8);\n\n    return distortion + ((bits*s->qscale*s->qscale*109 + 64)>>7);\n}\n\nstatic int bit8x8_c(/*MpegEncContext*/ void *c, uint8_t *src1, uint8_t *src2, int stride, int h){\n    MpegEncContext * const s= (MpegEncContext *)c;\n    const uint8_t *scantable= s->intra_scantable.permutated;\n    LOCAL_ALIGNED_16(int16_t, temp, [64]);\n    int i, last, run, bits, level, start_i;\n    const int esc_length= s->ac_esc_length;\n    uint8_t * length;\n    uint8_t * last_length;\n\n    av_assert2(h==8);\n\n    s->dsp.diff_pixels(temp, src1, src2, stride);\n\n    s->block_last_index[0/*FIXME*/]= last= s->fast_dct_quantize(s, temp, 0/*FIXME*/, s->qscale, &i);\n\n    bits=0;\n\n    if (s->mb_intra) {\n        start_i = 1;\n        length     = s->intra_ac_vlc_length;\n        last_length= s->intra_ac_vlc_last_length;\n        bits+= s->luma_dc_vlc_length[temp[0] + 256]; //FIXME chroma\n    } else {\n        start_i = 0;\n        length     = s->inter_ac_vlc_length;\n        last_length= s->inter_ac_vlc_last_length;\n    }\n\n    if(last>=start_i){\n        run=0;\n        for(i=start_i; i<last; i++){\n            int j= scantable[i];\n            level= temp[j];\n\n            if(level){\n                level+=64;\n                if((level&(~127)) == 0){\n                    bits+= length[UNI_AC_ENC_INDEX(run, level)];\n                }else\n                    bits+= esc_length;\n                run=0;\n            }else\n                run++;\n        }\n        i= scantable[last];\n\n        level= temp[i] + 64;\n\n        av_assert2(level - 64);\n\n        if((level&(~127)) == 0){\n            bits+= last_length[UNI_AC_ENC_INDEX(run, level)];\n        }else\n            bits+= esc_length;\n    }\n\n    return bits;\n}\n\n#define VSAD_INTRA(size) \\\nstatic int vsad_intra##size##_c(/*MpegEncContext*/ void *c, uint8_t *s, uint8_t *dummy, int stride, int h){ \\\n    int score=0;                                                                                            \\\n    int x,y;                                                                                                \\\n                                                                                                            \\\n    for(y=1; y<h; y++){                                                                                     \\\n        for(x=0; x<size; x+=4){                                                                             \\\n            score+= FFABS(s[x  ] - s[x  +stride]) + FFABS(s[x+1] - s[x+1+stride])                           \\\n                   +FFABS(s[x+2] - s[x+2+stride]) + FFABS(s[x+3] - s[x+3+stride]);                          \\\n        }                                                                                                   \\\n        s+= stride;                                                                                         \\\n    }                                                                                                       \\\n                                                                                                            \\\n    return score;                                                                                           \\\n}\nVSAD_INTRA(8)\nVSAD_INTRA(16)\n\nstatic int vsad16_c(/*MpegEncContext*/ void *c, uint8_t *s1, uint8_t *s2, int stride, int h){\n    int score=0;\n    int x,y;\n\n    for(y=1; y<h; y++){\n        for(x=0; x<16; x++){\n            score+= FFABS(s1[x  ] - s2[x ] - s1[x  +stride] + s2[x +stride]);\n        }\n        s1+= stride;\n        s2+= stride;\n    }\n\n    return score;\n}\n\n#define SQ(a) ((a)*(a))\n#define VSSE_INTRA(size) \\\nstatic int vsse_intra##size##_c(/*MpegEncContext*/ void *c, uint8_t *s, uint8_t *dummy, int stride, int h){ \\\n    int score=0;                                                                                            \\\n    int x,y;                                                                                                \\\n                                                                                                            \\\n    for(y=1; y<h; y++){                                                                                     \\\n        for(x=0; x<size; x+=4){                                                                               \\\n            score+= SQ(s[x  ] - s[x  +stride]) + SQ(s[x+1] - s[x+1+stride])                                 \\\n                   +SQ(s[x+2] - s[x+2+stride]) + SQ(s[x+3] - s[x+3+stride]);                                \\\n        }                                                                                                   \\\n        s+= stride;                                                                                         \\\n    }                                                                                                       \\\n                                                                                                            \\\n    return score;                                                                                           \\\n}\nVSSE_INTRA(8)\nVSSE_INTRA(16)\n\nstatic int vsse16_c(/*MpegEncContext*/ void *c, uint8_t *s1, uint8_t *s2, int stride, int h){\n    int score=0;\n    int x,y;\n\n    for(y=1; y<h; y++){\n        for(x=0; x<16; x++){\n            score+= SQ(s1[x  ] - s2[x ] - s1[x  +stride] + s2[x +stride]);\n        }\n        s1+= stride;\n        s2+= stride;\n    }\n\n    return score;\n}\n\nstatic int ssd_int8_vs_int16_c(const int8_t *pix1, const int16_t *pix2,\n                               int size){\n    int score=0;\n    int i;\n    for(i=0; i<size; i++)\n        score += (pix1[i]-pix2[i])*(pix1[i]-pix2[i]);\n    return score;\n}\n\n#define WRAPPER8_16_SQ(name8, name16)\\\nstatic int name16(void /*MpegEncContext*/ *s, uint8_t *dst, uint8_t *src, int stride, int h){\\\n    int score=0;\\\n    score +=name8(s, dst           , src           , stride, 8);\\\n    score +=name8(s, dst+8         , src+8         , stride, 8);\\\n    if(h==16){\\\n        dst += 8*stride;\\\n        src += 8*stride;\\\n        score +=name8(s, dst           , src           , stride, 8);\\\n        score +=name8(s, dst+8         , src+8         , stride, 8);\\\n    }\\\n    return score;\\\n}\n\nWRAPPER8_16_SQ(hadamard8_diff8x8_c, hadamard8_diff16_c)\nWRAPPER8_16_SQ(hadamard8_intra8x8_c, hadamard8_intra16_c)\nWRAPPER8_16_SQ(dct_sad8x8_c, dct_sad16_c)\n#if CONFIG_GPL\nWRAPPER8_16_SQ(dct264_sad8x8_c, dct264_sad16_c)\n#endif\nWRAPPER8_16_SQ(dct_max8x8_c, dct_max16_c)\nWRAPPER8_16_SQ(quant_psnr8x8_c, quant_psnr16_c)\nWRAPPER8_16_SQ(rd8x8_c, rd16_c)\nWRAPPER8_16_SQ(bit8x8_c, bit16_c)\n\nstatic inline uint32_t clipf_c_one(uint32_t a, uint32_t mini,\n                   uint32_t maxi, uint32_t maxisign)\n{\n\n    if(a > mini) return mini;\n    else if((a^(1U<<31)) > maxisign) return maxi;\n    else return a;\n}\n\nstatic void vector_clipf_c_opposite_sign(float *dst, const float *src, float *min, float *max, int len){\n    int i;\n    uint32_t mini = *(uint32_t*)min;\n    uint32_t maxi = *(uint32_t*)max;\n    uint32_t maxisign = maxi ^ (1U<<31);\n    uint32_t *dsti = (uint32_t*)dst;\n    const uint32_t *srci = (const uint32_t*)src;\n    for(i=0; i<len; i+=8) {\n        dsti[i + 0] = clipf_c_one(srci[i + 0], mini, maxi, maxisign);\n        dsti[i + 1] = clipf_c_one(srci[i + 1], mini, maxi, maxisign);\n        dsti[i + 2] = clipf_c_one(srci[i + 2], mini, maxi, maxisign);\n        dsti[i + 3] = clipf_c_one(srci[i + 3], mini, maxi, maxisign);\n        dsti[i + 4] = clipf_c_one(srci[i + 4], mini, maxi, maxisign);\n        dsti[i + 5] = clipf_c_one(srci[i + 5], mini, maxi, maxisign);\n        dsti[i + 6] = clipf_c_one(srci[i + 6], mini, maxi, maxisign);\n        dsti[i + 7] = clipf_c_one(srci[i + 7], mini, maxi, maxisign);\n    }\n}\nstatic void vector_clipf_c(float *dst, const float *src, float min, float max, int len){\n    int i;\n    if(min < 0 && max > 0) {\n        vector_clipf_c_opposite_sign(dst, src, &min, &max, len);\n    } else {\n        for(i=0; i < len; i+=8) {\n            dst[i    ] = av_clipf(src[i    ], min, max);\n            dst[i + 1] = av_clipf(src[i + 1], min, max);\n            dst[i + 2] = av_clipf(src[i + 2], min, max);\n            dst[i + 3] = av_clipf(src[i + 3], min, max);\n            dst[i + 4] = av_clipf(src[i + 4], min, max);\n            dst[i + 5] = av_clipf(src[i + 5], min, max);\n            dst[i + 6] = av_clipf(src[i + 6], min, max);\n            dst[i + 7] = av_clipf(src[i + 7], min, max);\n        }\n    }\n}\n\nstatic int32_t scalarproduct_int16_c(const int16_t * v1, const int16_t * v2, int order)\n{\n    int res = 0;\n\n    while (order--)\n        res += *v1++ * *v2++;\n\n    return res;\n}\n\nstatic int32_t scalarproduct_and_madd_int16_c(int16_t *v1, const int16_t *v2, const int16_t *v3, int order, int mul)\n{\n    int res = 0;\n    while (order--) {\n        res   += *v1 * *v2++;\n        *v1++ += mul * *v3++;\n    }\n    return res;\n}\n\nstatic void apply_window_int16_c(int16_t *output, const int16_t *input,\n                                 const int16_t *window, unsigned int len)\n{\n    int i;\n    int len2 = len >> 1;\n\n    for (i = 0; i < len2; i++) {\n        int16_t w       = window[i];\n        output[i]       = (MUL16(input[i],       w) + (1 << 14)) >> 15;\n        output[len-i-1] = (MUL16(input[len-i-1], w) + (1 << 14)) >> 15;\n    }\n}\n\nstatic void vector_clip_int32_c(int32_t *dst, const int32_t *src, int32_t min,\n                                int32_t max, unsigned int len)\n{\n    do {\n        *dst++ = av_clip(*src++, min, max);\n        *dst++ = av_clip(*src++, min, max);\n        *dst++ = av_clip(*src++, min, max);\n        *dst++ = av_clip(*src++, min, max);\n        *dst++ = av_clip(*src++, min, max);\n        *dst++ = av_clip(*src++, min, max);\n        *dst++ = av_clip(*src++, min, max);\n        *dst++ = av_clip(*src++, min, max);\n        len -= 8;\n    } while (len > 0);\n}\n\nstatic void jref_idct_put(uint8_t *dest, int line_size, int16_t *block)\n{\n    ff_j_rev_dct (block);\n    put_pixels_clamped_c(block, dest, line_size);\n}\nstatic void jref_idct_add(uint8_t *dest, int line_size, int16_t *block)\n{\n    ff_j_rev_dct (block);\n    add_pixels_clamped_c(block, dest, line_size);\n}\n\nstatic void ff_jref_idct4_put(uint8_t *dest, int line_size, int16_t *block)\n{\n    ff_j_rev_dct4 (block);\n    put_pixels_clamped4_c(block, dest, line_size);\n}\nstatic void ff_jref_idct4_add(uint8_t *dest, int line_size, int16_t *block)\n{\n    ff_j_rev_dct4 (block);\n    add_pixels_clamped4_c(block, dest, line_size);\n}\n\nstatic void ff_jref_idct2_put(uint8_t *dest, int line_size, int16_t *block)\n{\n    ff_j_rev_dct2 (block);\n    put_pixels_clamped2_c(block, dest, line_size);\n}\nstatic void ff_jref_idct2_add(uint8_t *dest, int line_size, int16_t *block)\n{\n    ff_j_rev_dct2 (block);\n    add_pixels_clamped2_c(block, dest, line_size);\n}\n\nstatic void ff_jref_idct1_put(uint8_t *dest, int line_size, int16_t *block)\n{\n    dest[0] = av_clip_uint8((block[0] + 4)>>3);\n}\nstatic void ff_jref_idct1_add(uint8_t *dest, int line_size, int16_t *block)\n{\n    dest[0] = av_clip_uint8(dest[0] + ((block[0] + 4)>>3));\n}\n\n/* init static data */\nav_cold void ff_dsputil_static_init(void)\n{\n    int i;\n\n    for(i=0;i<512;i++) {\n        ff_squareTbl[i] = (i - 256) * (i - 256);\n    }\n\n    for(i=0; i<64; i++) ff_inv_zigzag_direct16[ff_zigzag_direct[i]]= i+1;\n}\n\nint ff_check_alignment(void){\n    static int did_fail=0;\n    LOCAL_ALIGNED_16(int, aligned, [4]);\n\n    if((intptr_t)aligned & 15){\n        if(!did_fail){\n#if HAVE_MMX || HAVE_ALTIVEC\n            av_log(NULL, AV_LOG_ERROR,\n                \"Compiler did not align stack variables. Libavcodec has been miscompiled\\n\"\n                \"and may be very slow or crash. This is not a bug in libavcodec,\\n\"\n                \"but in the compiler. You may try recompiling using gcc >= 4.2.\\n\"\n                \"Do not report crashes to FFmpeg developers.\\n\");\n#endif\n            did_fail=1;\n        }\n        return -1;\n    }\n    return 0;\n}\n\nav_cold void ff_dsputil_init(DSPContext* c, AVCodecContext *avctx)\n{\n    ff_check_alignment();\n\n#if CONFIG_ENCODERS\n    if (avctx->bits_per_raw_sample == 10) {\n        c->fdct    = ff_jpeg_fdct_islow_10;\n        c->fdct248 = ff_fdct248_islow_10;\n    } else {\n        if(avctx->dct_algo==FF_DCT_FASTINT) {\n            c->fdct    = ff_fdct_ifast;\n            c->fdct248 = ff_fdct_ifast248;\n        }\n        else if(avctx->dct_algo==FF_DCT_FAAN) {\n            c->fdct    = ff_faandct;\n            c->fdct248 = ff_faandct248;\n        }\n        else {\n            c->fdct    = ff_jpeg_fdct_islow_8; //slow/accurate/default\n            c->fdct248 = ff_fdct248_islow_8;\n        }\n    }\n#endif //CONFIG_ENCODERS\n\n    if(avctx->lowres==1){\n        c->idct_put= ff_jref_idct4_put;\n        c->idct_add= ff_jref_idct4_add;\n        c->idct    = ff_j_rev_dct4;\n        c->idct_permutation_type= FF_NO_IDCT_PERM;\n    }else if(avctx->lowres==2){\n        c->idct_put= ff_jref_idct2_put;\n        c->idct_add= ff_jref_idct2_add;\n        c->idct    = ff_j_rev_dct2;\n        c->idct_permutation_type= FF_NO_IDCT_PERM;\n    }else if(avctx->lowres==3){\n        c->idct_put= ff_jref_idct1_put;\n        c->idct_add= ff_jref_idct1_add;\n        c->idct    = ff_j_rev_dct1;\n        c->idct_permutation_type= FF_NO_IDCT_PERM;\n    }else{\n        if (avctx->bits_per_raw_sample == 10) {\n            c->idct_put              = ff_simple_idct_put_10;\n            c->idct_add              = ff_simple_idct_add_10;\n            c->idct                  = ff_simple_idct_10;\n            c->idct_permutation_type = FF_NO_IDCT_PERM;\n        } else {\n        if(avctx->idct_algo==FF_IDCT_INT){\n            c->idct_put= jref_idct_put;\n            c->idct_add= jref_idct_add;\n            c->idct    = ff_j_rev_dct;\n            c->idct_permutation_type= FF_LIBMPEG2_IDCT_PERM;\n        }else if(avctx->idct_algo==FF_IDCT_FAAN){\n            c->idct_put= ff_faanidct_put;\n            c->idct_add= ff_faanidct_add;\n            c->idct    = ff_faanidct;\n            c->idct_permutation_type= FF_NO_IDCT_PERM;\n        }else{ //accurate/default\n            c->idct_put = ff_simple_idct_put_8;\n            c->idct_add = ff_simple_idct_add_8;\n            c->idct     = ff_simple_idct_8;\n            c->idct_permutation_type= FF_NO_IDCT_PERM;\n        }\n        }\n    }\n\n    c->diff_pixels = diff_pixels_c;\n    c->put_pixels_clamped = put_pixels_clamped_c;\n    c->put_signed_pixels_clamped = put_signed_pixels_clamped_c;\n    c->add_pixels_clamped = add_pixels_clamped_c;\n    c->sum_abs_dctelem = sum_abs_dctelem_c;\n    c->gmc1 = gmc1_c;\n    c->gmc = ff_gmc_c;\n    c->pix_sum = pix_sum_c;\n    c->pix_norm1 = pix_norm1_c;\n\n    c->fill_block_tab[0] = fill_block16_c;\n    c->fill_block_tab[1] = fill_block8_c;\n\n    /* TODO [0] 16  [1] 8 */\n    c->pix_abs[0][0] = pix_abs16_c;\n    c->pix_abs[0][1] = pix_abs16_x2_c;\n    c->pix_abs[0][2] = pix_abs16_y2_c;\n    c->pix_abs[0][3] = pix_abs16_xy2_c;\n    c->pix_abs[1][0] = pix_abs8_c;\n    c->pix_abs[1][1] = pix_abs8_x2_c;\n    c->pix_abs[1][2] = pix_abs8_y2_c;\n    c->pix_abs[1][3] = pix_abs8_xy2_c;\n\n    c->put_tpel_pixels_tab[ 0] = put_tpel_pixels_mc00_c;\n    c->put_tpel_pixels_tab[ 1] = put_tpel_pixels_mc10_c;\n    c->put_tpel_pixels_tab[ 2] = put_tpel_pixels_mc20_c;\n    c->put_tpel_pixels_tab[ 4] = put_tpel_pixels_mc01_c;\n    c->put_tpel_pixels_tab[ 5] = put_tpel_pixels_mc11_c;\n    c->put_tpel_pixels_tab[ 6] = put_tpel_pixels_mc21_c;\n    c->put_tpel_pixels_tab[ 8] = put_tpel_pixels_mc02_c;\n    c->put_tpel_pixels_tab[ 9] = put_tpel_pixels_mc12_c;\n    c->put_tpel_pixels_tab[10] = put_tpel_pixels_mc22_c;\n\n    c->avg_tpel_pixels_tab[ 0] = avg_tpel_pixels_mc00_c;\n    c->avg_tpel_pixels_tab[ 1] = avg_tpel_pixels_mc10_c;\n    c->avg_tpel_pixels_tab[ 2] = avg_tpel_pixels_mc20_c;\n    c->avg_tpel_pixels_tab[ 4] = avg_tpel_pixels_mc01_c;\n    c->avg_tpel_pixels_tab[ 5] = avg_tpel_pixels_mc11_c;\n    c->avg_tpel_pixels_tab[ 6] = avg_tpel_pixels_mc21_c;\n    c->avg_tpel_pixels_tab[ 8] = avg_tpel_pixels_mc02_c;\n    c->avg_tpel_pixels_tab[ 9] = avg_tpel_pixels_mc12_c;\n    c->avg_tpel_pixels_tab[10] = avg_tpel_pixels_mc22_c;\n\n#define dspfunc(PFX, IDX, NUM) \\\n    c->PFX ## _pixels_tab[IDX][ 0] = PFX ## NUM ## _mc00_c; \\\n    c->PFX ## _pixels_tab[IDX][ 1] = PFX ## NUM ## _mc10_c; \\\n    c->PFX ## _pixels_tab[IDX][ 2] = PFX ## NUM ## _mc20_c; \\\n    c->PFX ## _pixels_tab[IDX][ 3] = PFX ## NUM ## _mc30_c; \\\n    c->PFX ## _pixels_tab[IDX][ 4] = PFX ## NUM ## _mc01_c; \\\n    c->PFX ## _pixels_tab[IDX][ 5] = PFX ## NUM ## _mc11_c; \\\n    c->PFX ## _pixels_tab[IDX][ 6] = PFX ## NUM ## _mc21_c; \\\n    c->PFX ## _pixels_tab[IDX][ 7] = PFX ## NUM ## _mc31_c; \\\n    c->PFX ## _pixels_tab[IDX][ 8] = PFX ## NUM ## _mc02_c; \\\n    c->PFX ## _pixels_tab[IDX][ 9] = PFX ## NUM ## _mc12_c; \\\n    c->PFX ## _pixels_tab[IDX][10] = PFX ## NUM ## _mc22_c; \\\n    c->PFX ## _pixels_tab[IDX][11] = PFX ## NUM ## _mc32_c; \\\n    c->PFX ## _pixels_tab[IDX][12] = PFX ## NUM ## _mc03_c; \\\n    c->PFX ## _pixels_tab[IDX][13] = PFX ## NUM ## _mc13_c; \\\n    c->PFX ## _pixels_tab[IDX][14] = PFX ## NUM ## _mc23_c; \\\n    c->PFX ## _pixels_tab[IDX][15] = PFX ## NUM ## _mc33_c\n\n    dspfunc(put_qpel, 0, 16);\n    dspfunc(put_no_rnd_qpel, 0, 16);\n\n    dspfunc(avg_qpel, 0, 16);\n    /* dspfunc(avg_no_rnd_qpel, 0, 16); */\n\n    dspfunc(put_qpel, 1, 8);\n    dspfunc(put_no_rnd_qpel, 1, 8);\n\n    dspfunc(avg_qpel, 1, 8);\n    /* dspfunc(avg_no_rnd_qpel, 1, 8); */\n\n#undef dspfunc\n\n    c->put_mspel_pixels_tab[0]= ff_put_pixels8x8_c;\n    c->put_mspel_pixels_tab[1]= put_mspel8_mc10_c;\n    c->put_mspel_pixels_tab[2]= put_mspel8_mc20_c;\n    c->put_mspel_pixels_tab[3]= put_mspel8_mc30_c;\n    c->put_mspel_pixels_tab[4]= put_mspel8_mc02_c;\n    c->put_mspel_pixels_tab[5]= put_mspel8_mc12_c;\n    c->put_mspel_pixels_tab[6]= put_mspel8_mc22_c;\n    c->put_mspel_pixels_tab[7]= put_mspel8_mc32_c;\n\n#define SET_CMP_FUNC(name) \\\n    c->name[0]= name ## 16_c;\\\n    c->name[1]= name ## 8x8_c;\n\n    SET_CMP_FUNC(hadamard8_diff)\n    c->hadamard8_diff[4]= hadamard8_intra16_c;\n    c->hadamard8_diff[5]= hadamard8_intra8x8_c;\n    SET_CMP_FUNC(dct_sad)\n    SET_CMP_FUNC(dct_max)\n#if CONFIG_GPL\n    SET_CMP_FUNC(dct264_sad)\n#endif\n    c->sad[0]= pix_abs16_c;\n    c->sad[1]= pix_abs8_c;\n    c->sse[0]= sse16_c;\n    c->sse[1]= sse8_c;\n    c->sse[2]= sse4_c;\n    SET_CMP_FUNC(quant_psnr)\n    SET_CMP_FUNC(rd)\n    SET_CMP_FUNC(bit)\n    c->vsad[0]= vsad16_c;\n    c->vsad[4]= vsad_intra16_c;\n    c->vsad[5]= vsad_intra8_c;\n    c->vsse[0]= vsse16_c;\n    c->vsse[4]= vsse_intra16_c;\n    c->vsse[5]= vsse_intra8_c;\n    c->nsse[0]= nsse16_c;\n    c->nsse[1]= nsse8_c;\n#if CONFIG_SNOW_DECODER || CONFIG_SNOW_ENCODER\n    ff_dsputil_init_dwt(c);\n#endif\n\n    c->ssd_int8_vs_int16 = ssd_int8_vs_int16_c;\n\n    c->add_bytes= add_bytes_c;\n    c->diff_bytes= diff_bytes_c;\n    c->add_hfyu_median_prediction= add_hfyu_median_prediction_c;\n    c->sub_hfyu_median_prediction= sub_hfyu_median_prediction_c;\n    c->add_hfyu_left_prediction  = add_hfyu_left_prediction_c;\n    c->add_hfyu_left_prediction_bgr32 = add_hfyu_left_prediction_bgr32_c;\n    c->bswap_buf= bswap_buf;\n    c->bswap16_buf = bswap16_buf;\n\n    if (CONFIG_H263_DECODER || CONFIG_H263_ENCODER) {\n        c->h263_h_loop_filter= h263_h_loop_filter_c;\n        c->h263_v_loop_filter= h263_v_loop_filter_c;\n    }\n\n    c->try_8x8basis= try_8x8basis_c;\n    c->add_8x8basis= add_8x8basis_c;\n\n    c->vector_clipf = vector_clipf_c;\n    c->scalarproduct_int16 = scalarproduct_int16_c;\n    c->scalarproduct_and_madd_int16 = scalarproduct_and_madd_int16_c;\n    c->apply_window_int16 = apply_window_int16_c;\n    c->vector_clip_int32 = vector_clip_int32_c;\n\n    c->shrink[0]= av_image_copy_plane;\n    c->shrink[1]= ff_shrink22;\n    c->shrink[2]= ff_shrink44;\n    c->shrink[3]= ff_shrink88;\n\n    c->add_pixels8 = add_pixels8_c;\n\n#undef FUNC\n#undef FUNCC\n#define FUNC(f, depth) f ## _ ## depth\n#define FUNCC(f, depth) f ## _ ## depth ## _c\n\n    c->draw_edges                    = FUNCC(draw_edges, 8);\n    c->clear_block                   = FUNCC(clear_block, 8);\n    c->clear_blocks                  = FUNCC(clear_blocks, 8);\n\n#define BIT_DEPTH_FUNCS(depth) \\\n    c->get_pixels                    = FUNCC(get_pixels,   depth);\n\n    switch (avctx->bits_per_raw_sample) {\n    case 9:\n    case 10:\n    case 12:\n    case 14:\n        BIT_DEPTH_FUNCS(16);\n        break;\n    default:\n        if(avctx->bits_per_raw_sample<=8 || avctx->codec_type != AVMEDIA_TYPE_VIDEO) {\n            BIT_DEPTH_FUNCS(8);\n        }\n        break;\n    }\n\n\n    if (ARCH_ALPHA)\n        ff_dsputil_init_alpha(c, avctx);\n    if (ARCH_ARM)\n        ff_dsputil_init_arm(c, avctx);\n    if (ARCH_BFIN)\n        ff_dsputil_init_bfin(c, avctx);\n    if (ARCH_PPC)\n        ff_dsputil_init_ppc(c, avctx);\n    if (ARCH_SH4)\n        ff_dsputil_init_sh4(c, avctx);\n    if (HAVE_VIS)\n        ff_dsputil_init_vis(c, avctx);\n    if (ARCH_X86)\n        ff_dsputil_init_x86(c, avctx);\n\n    ff_init_scantable_permutation(c->idct_permutation,\n                                  c->idct_permutation_type);\n}\n\nav_cold void dsputil_init(DSPContext* c, AVCodecContext *avctx)\n{\n    ff_dsputil_init(c, avctx);\n}\n\nav_cold void avpriv_dsputil_init(DSPContext *c, AVCodecContext *avctx)\n{\n    ff_dsputil_init(c, avctx);\n}\n"], "fixing_code": ["/*\n * DSP utils\n * Copyright (c) 2000, 2001 Fabrice Bellard\n * Copyright (c) 2002-2004 Michael Niedermayer <michaelni@gmx.at>\n *\n * gmc & q-pel & 32/64 bit based MC by Michael Niedermayer <michaelni@gmx.at>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * DSP utils\n */\n\n#include \"libavutil/attributes.h\"\n#include \"libavutil/imgutils.h\"\n#include \"libavutil/internal.h\"\n#include \"avcodec.h\"\n#include \"copy_block.h\"\n#include \"dct.h\"\n#include \"dsputil.h\"\n#include \"simple_idct.h\"\n#include \"faandct.h\"\n#include \"faanidct.h\"\n#include \"imgconvert.h\"\n#include \"mathops.h\"\n#include \"mpegvideo.h\"\n#include \"config.h\"\n#include \"diracdsp.h\"\n\nuint32_t ff_squareTbl[512] = {0, };\n\n#define BIT_DEPTH 16\n#include \"dsputil_template.c\"\n#undef BIT_DEPTH\n\n#define BIT_DEPTH 8\n#include \"dsputil_template.c\"\n\n// 0x7f7f7f7f or 0x7f7f7f7f7f7f7f7f or whatever, depending on the cpu's native arithmetic size\n#define pb_7f (~0UL/255 * 0x7f)\n#define pb_80 (~0UL/255 * 0x80)\n\n/* Specific zigzag scan for 248 idct. NOTE that unlike the\n   specification, we interleave the fields */\nconst uint8_t ff_zigzag248_direct[64] = {\n     0,  8,  1,  9, 16, 24,  2, 10,\n    17, 25, 32, 40, 48, 56, 33, 41,\n    18, 26,  3, 11,  4, 12, 19, 27,\n    34, 42, 49, 57, 50, 58, 35, 43,\n    20, 28,  5, 13,  6, 14, 21, 29,\n    36, 44, 51, 59, 52, 60, 37, 45,\n    22, 30,  7, 15, 23, 31, 38, 46,\n    53, 61, 54, 62, 39, 47, 55, 63,\n};\n\n/* not permutated inverse zigzag_direct + 1 for MMX quantizer */\nDECLARE_ALIGNED(16, uint16_t, ff_inv_zigzag_direct16)[64];\n\nconst uint8_t ff_alternate_horizontal_scan[64] = {\n    0,  1,   2,  3,  8,  9, 16, 17,\n    10, 11,  4,  5,  6,  7, 15, 14,\n    13, 12, 19, 18, 24, 25, 32, 33,\n    26, 27, 20, 21, 22, 23, 28, 29,\n    30, 31, 34, 35, 40, 41, 48, 49,\n    42, 43, 36, 37, 38, 39, 44, 45,\n    46, 47, 50, 51, 56, 57, 58, 59,\n    52, 53, 54, 55, 60, 61, 62, 63,\n};\n\nconst uint8_t ff_alternate_vertical_scan[64] = {\n    0,  8,  16, 24,  1,  9,  2, 10,\n    17, 25, 32, 40, 48, 56, 57, 49,\n    41, 33, 26, 18,  3, 11,  4, 12,\n    19, 27, 34, 42, 50, 58, 35, 43,\n    51, 59, 20, 28,  5, 13,  6, 14,\n    21, 29, 36, 44, 52, 60, 37, 45,\n    53, 61, 22, 30,  7, 15, 23, 31,\n    38, 46, 54, 62, 39, 47, 55, 63,\n};\n\n/* Input permutation for the simple_idct_mmx */\nstatic const uint8_t simple_mmx_permutation[64]={\n        0x00, 0x08, 0x04, 0x09, 0x01, 0x0C, 0x05, 0x0D,\n        0x10, 0x18, 0x14, 0x19, 0x11, 0x1C, 0x15, 0x1D,\n        0x20, 0x28, 0x24, 0x29, 0x21, 0x2C, 0x25, 0x2D,\n        0x12, 0x1A, 0x16, 0x1B, 0x13, 0x1E, 0x17, 0x1F,\n        0x02, 0x0A, 0x06, 0x0B, 0x03, 0x0E, 0x07, 0x0F,\n        0x30, 0x38, 0x34, 0x39, 0x31, 0x3C, 0x35, 0x3D,\n        0x22, 0x2A, 0x26, 0x2B, 0x23, 0x2E, 0x27, 0x2F,\n        0x32, 0x3A, 0x36, 0x3B, 0x33, 0x3E, 0x37, 0x3F,\n};\n\nstatic const uint8_t idct_sse2_row_perm[8] = {0, 4, 1, 5, 2, 6, 3, 7};\n\nav_cold void ff_init_scantable(uint8_t *permutation, ScanTable *st,\n                               const uint8_t *src_scantable)\n{\n    int i;\n    int end;\n\n    st->scantable= src_scantable;\n\n    for(i=0; i<64; i++){\n        int j;\n        j = src_scantable[i];\n        st->permutated[i] = permutation[j];\n    }\n\n    end=-1;\n    for(i=0; i<64; i++){\n        int j;\n        j = st->permutated[i];\n        if(j>end) end=j;\n        st->raster_end[i]= end;\n    }\n}\n\nav_cold void ff_init_scantable_permutation(uint8_t *idct_permutation,\n                                           int idct_permutation_type)\n{\n    int i;\n\n    switch(idct_permutation_type){\n    case FF_NO_IDCT_PERM:\n        for(i=0; i<64; i++)\n            idct_permutation[i]= i;\n        break;\n    case FF_LIBMPEG2_IDCT_PERM:\n        for(i=0; i<64; i++)\n            idct_permutation[i]= (i & 0x38) | ((i & 6) >> 1) | ((i & 1) << 2);\n        break;\n    case FF_SIMPLE_IDCT_PERM:\n        for(i=0; i<64; i++)\n            idct_permutation[i]= simple_mmx_permutation[i];\n        break;\n    case FF_TRANSPOSE_IDCT_PERM:\n        for(i=0; i<64; i++)\n            idct_permutation[i]= ((i&7)<<3) | (i>>3);\n        break;\n    case FF_PARTTRANS_IDCT_PERM:\n        for(i=0; i<64; i++)\n            idct_permutation[i]= (i&0x24) | ((i&3)<<3) | ((i>>3)&3);\n        break;\n    case FF_SSE2_IDCT_PERM:\n        for(i=0; i<64; i++)\n            idct_permutation[i]= (i&0x38) | idct_sse2_row_perm[i&7];\n        break;\n    default:\n        av_log(NULL, AV_LOG_ERROR, \"Internal error, IDCT permutation not set\\n\");\n    }\n}\n\nstatic int pix_sum_c(uint8_t * pix, int line_size)\n{\n    int s, i, j;\n\n    s = 0;\n    for (i = 0; i < 16; i++) {\n        for (j = 0; j < 16; j += 8) {\n            s += pix[0];\n            s += pix[1];\n            s += pix[2];\n            s += pix[3];\n            s += pix[4];\n            s += pix[5];\n            s += pix[6];\n            s += pix[7];\n            pix += 8;\n        }\n        pix += line_size - 16;\n    }\n    return s;\n}\n\nstatic int pix_norm1_c(uint8_t * pix, int line_size)\n{\n    int s, i, j;\n    uint32_t *sq = ff_squareTbl + 256;\n\n    s = 0;\n    for (i = 0; i < 16; i++) {\n        for (j = 0; j < 16; j += 8) {\n#if 0\n            s += sq[pix[0]];\n            s += sq[pix[1]];\n            s += sq[pix[2]];\n            s += sq[pix[3]];\n            s += sq[pix[4]];\n            s += sq[pix[5]];\n            s += sq[pix[6]];\n            s += sq[pix[7]];\n#else\n#if HAVE_FAST_64BIT\n            register uint64_t x=*(uint64_t*)pix;\n            s += sq[x&0xff];\n            s += sq[(x>>8)&0xff];\n            s += sq[(x>>16)&0xff];\n            s += sq[(x>>24)&0xff];\n            s += sq[(x>>32)&0xff];\n            s += sq[(x>>40)&0xff];\n            s += sq[(x>>48)&0xff];\n            s += sq[(x>>56)&0xff];\n#else\n            register uint32_t x=*(uint32_t*)pix;\n            s += sq[x&0xff];\n            s += sq[(x>>8)&0xff];\n            s += sq[(x>>16)&0xff];\n            s += sq[(x>>24)&0xff];\n            x=*(uint32_t*)(pix+4);\n            s += sq[x&0xff];\n            s += sq[(x>>8)&0xff];\n            s += sq[(x>>16)&0xff];\n            s += sq[(x>>24)&0xff];\n#endif\n#endif\n            pix += 8;\n        }\n        pix += line_size - 16;\n    }\n    return s;\n}\n\nstatic void bswap_buf(uint32_t *dst, const uint32_t *src, int w){\n    int i;\n\n    for(i=0; i+8<=w; i+=8){\n        dst[i+0]= av_bswap32(src[i+0]);\n        dst[i+1]= av_bswap32(src[i+1]);\n        dst[i+2]= av_bswap32(src[i+2]);\n        dst[i+3]= av_bswap32(src[i+3]);\n        dst[i+4]= av_bswap32(src[i+4]);\n        dst[i+5]= av_bswap32(src[i+5]);\n        dst[i+6]= av_bswap32(src[i+6]);\n        dst[i+7]= av_bswap32(src[i+7]);\n    }\n    for(;i<w; i++){\n        dst[i+0]= av_bswap32(src[i+0]);\n    }\n}\n\nstatic void bswap16_buf(uint16_t *dst, const uint16_t *src, int len)\n{\n    while (len--)\n        *dst++ = av_bswap16(*src++);\n}\n\nstatic int sse4_c(void *v, uint8_t * pix1, uint8_t * pix2, int line_size, int h)\n{\n    int s, i;\n    uint32_t *sq = ff_squareTbl + 256;\n\n    s = 0;\n    for (i = 0; i < h; i++) {\n        s += sq[pix1[0] - pix2[0]];\n        s += sq[pix1[1] - pix2[1]];\n        s += sq[pix1[2] - pix2[2]];\n        s += sq[pix1[3] - pix2[3]];\n        pix1 += line_size;\n        pix2 += line_size;\n    }\n    return s;\n}\n\nstatic int sse8_c(void *v, uint8_t * pix1, uint8_t * pix2, int line_size, int h)\n{\n    int s, i;\n    uint32_t *sq = ff_squareTbl + 256;\n\n    s = 0;\n    for (i = 0; i < h; i++) {\n        s += sq[pix1[0] - pix2[0]];\n        s += sq[pix1[1] - pix2[1]];\n        s += sq[pix1[2] - pix2[2]];\n        s += sq[pix1[3] - pix2[3]];\n        s += sq[pix1[4] - pix2[4]];\n        s += sq[pix1[5] - pix2[5]];\n        s += sq[pix1[6] - pix2[6]];\n        s += sq[pix1[7] - pix2[7]];\n        pix1 += line_size;\n        pix2 += line_size;\n    }\n    return s;\n}\n\nstatic int sse16_c(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)\n{\n    int s, i;\n    uint32_t *sq = ff_squareTbl + 256;\n\n    s = 0;\n    for (i = 0; i < h; i++) {\n        s += sq[pix1[ 0] - pix2[ 0]];\n        s += sq[pix1[ 1] - pix2[ 1]];\n        s += sq[pix1[ 2] - pix2[ 2]];\n        s += sq[pix1[ 3] - pix2[ 3]];\n        s += sq[pix1[ 4] - pix2[ 4]];\n        s += sq[pix1[ 5] - pix2[ 5]];\n        s += sq[pix1[ 6] - pix2[ 6]];\n        s += sq[pix1[ 7] - pix2[ 7]];\n        s += sq[pix1[ 8] - pix2[ 8]];\n        s += sq[pix1[ 9] - pix2[ 9]];\n        s += sq[pix1[10] - pix2[10]];\n        s += sq[pix1[11] - pix2[11]];\n        s += sq[pix1[12] - pix2[12]];\n        s += sq[pix1[13] - pix2[13]];\n        s += sq[pix1[14] - pix2[14]];\n        s += sq[pix1[15] - pix2[15]];\n\n        pix1 += line_size;\n        pix2 += line_size;\n    }\n    return s;\n}\n\nstatic void diff_pixels_c(int16_t *av_restrict block, const uint8_t *s1,\n                          const uint8_t *s2, int stride){\n    int i;\n\n    /* read the pixels */\n    for(i=0;i<8;i++) {\n        block[0] = s1[0] - s2[0];\n        block[1] = s1[1] - s2[1];\n        block[2] = s1[2] - s2[2];\n        block[3] = s1[3] - s2[3];\n        block[4] = s1[4] - s2[4];\n        block[5] = s1[5] - s2[5];\n        block[6] = s1[6] - s2[6];\n        block[7] = s1[7] - s2[7];\n        s1 += stride;\n        s2 += stride;\n        block += 8;\n    }\n}\n\nstatic void put_pixels_clamped_c(const int16_t *block, uint8_t *av_restrict pixels,\n                                 int line_size)\n{\n    int i;\n\n    /* read the pixels */\n    for(i=0;i<8;i++) {\n        pixels[0] = av_clip_uint8(block[0]);\n        pixels[1] = av_clip_uint8(block[1]);\n        pixels[2] = av_clip_uint8(block[2]);\n        pixels[3] = av_clip_uint8(block[3]);\n        pixels[4] = av_clip_uint8(block[4]);\n        pixels[5] = av_clip_uint8(block[5]);\n        pixels[6] = av_clip_uint8(block[6]);\n        pixels[7] = av_clip_uint8(block[7]);\n\n        pixels += line_size;\n        block += 8;\n    }\n}\n\nstatic void put_pixels_clamped4_c(const int16_t *block, uint8_t *av_restrict pixels,\n                                 int line_size)\n{\n    int i;\n\n    /* read the pixels */\n    for(i=0;i<4;i++) {\n        pixels[0] = av_clip_uint8(block[0]);\n        pixels[1] = av_clip_uint8(block[1]);\n        pixels[2] = av_clip_uint8(block[2]);\n        pixels[3] = av_clip_uint8(block[3]);\n\n        pixels += line_size;\n        block += 8;\n    }\n}\n\nstatic void put_pixels_clamped2_c(const int16_t *block, uint8_t *av_restrict pixels,\n                                 int line_size)\n{\n    int i;\n\n    /* read the pixels */\n    for(i=0;i<2;i++) {\n        pixels[0] = av_clip_uint8(block[0]);\n        pixels[1] = av_clip_uint8(block[1]);\n\n        pixels += line_size;\n        block += 8;\n    }\n}\n\nstatic void put_signed_pixels_clamped_c(const int16_t *block,\n                                        uint8_t *av_restrict pixels,\n                                        int line_size)\n{\n    int i, j;\n\n    for (i = 0; i < 8; i++) {\n        for (j = 0; j < 8; j++) {\n            if (*block < -128)\n                *pixels = 0;\n            else if (*block > 127)\n                *pixels = 255;\n            else\n                *pixels = (uint8_t)(*block + 128);\n            block++;\n            pixels++;\n        }\n        pixels += (line_size - 8);\n    }\n}\n\nstatic void add_pixels8_c(uint8_t *av_restrict pixels,\n                          int16_t *block,\n                          int line_size)\n{\n    int i;\n\n    for(i=0;i<8;i++) {\n        pixels[0] += block[0];\n        pixels[1] += block[1];\n        pixels[2] += block[2];\n        pixels[3] += block[3];\n        pixels[4] += block[4];\n        pixels[5] += block[5];\n        pixels[6] += block[6];\n        pixels[7] += block[7];\n        pixels += line_size;\n        block += 8;\n    }\n}\n\nstatic void add_pixels_clamped_c(const int16_t *block, uint8_t *av_restrict pixels,\n                                 int line_size)\n{\n    int i;\n\n    /* read the pixels */\n    for(i=0;i<8;i++) {\n        pixels[0] = av_clip_uint8(pixels[0] + block[0]);\n        pixels[1] = av_clip_uint8(pixels[1] + block[1]);\n        pixels[2] = av_clip_uint8(pixels[2] + block[2]);\n        pixels[3] = av_clip_uint8(pixels[3] + block[3]);\n        pixels[4] = av_clip_uint8(pixels[4] + block[4]);\n        pixels[5] = av_clip_uint8(pixels[5] + block[5]);\n        pixels[6] = av_clip_uint8(pixels[6] + block[6]);\n        pixels[7] = av_clip_uint8(pixels[7] + block[7]);\n        pixels += line_size;\n        block += 8;\n    }\n}\n\nstatic void add_pixels_clamped4_c(const int16_t *block, uint8_t *av_restrict pixels,\n                          int line_size)\n{\n    int i;\n\n    /* read the pixels */\n    for(i=0;i<4;i++) {\n        pixels[0] = av_clip_uint8(pixels[0] + block[0]);\n        pixels[1] = av_clip_uint8(pixels[1] + block[1]);\n        pixels[2] = av_clip_uint8(pixels[2] + block[2]);\n        pixels[3] = av_clip_uint8(pixels[3] + block[3]);\n        pixels += line_size;\n        block += 8;\n    }\n}\n\nstatic void add_pixels_clamped2_c(const int16_t *block, uint8_t *av_restrict pixels,\n                          int line_size)\n{\n    int i;\n\n    /* read the pixels */\n    for(i=0;i<2;i++) {\n        pixels[0] = av_clip_uint8(pixels[0] + block[0]);\n        pixels[1] = av_clip_uint8(pixels[1] + block[1]);\n        pixels += line_size;\n        block += 8;\n    }\n}\n\nstatic int sum_abs_dctelem_c(int16_t *block)\n{\n    int sum=0, i;\n    for(i=0; i<64; i++)\n        sum+= FFABS(block[i]);\n    return sum;\n}\n\nstatic void fill_block16_c(uint8_t *block, uint8_t value, int line_size, int h)\n{\n    int i;\n\n    for (i = 0; i < h; i++) {\n        memset(block, value, 16);\n        block += line_size;\n    }\n}\n\nstatic void fill_block8_c(uint8_t *block, uint8_t value, int line_size, int h)\n{\n    int i;\n\n    for (i = 0; i < h; i++) {\n        memset(block, value, 8);\n        block += line_size;\n    }\n}\n\n#define avg2(a,b) ((a+b+1)>>1)\n#define avg4(a,b,c,d) ((a+b+c+d+2)>>2)\n\nstatic void gmc1_c(uint8_t *dst, uint8_t *src, int stride, int h, int x16, int y16, int rounder)\n{\n    const int A=(16-x16)*(16-y16);\n    const int B=(   x16)*(16-y16);\n    const int C=(16-x16)*(   y16);\n    const int D=(   x16)*(   y16);\n    int i;\n\n    for(i=0; i<h; i++)\n    {\n        dst[0]= (A*src[0] + B*src[1] + C*src[stride+0] + D*src[stride+1] + rounder)>>8;\n        dst[1]= (A*src[1] + B*src[2] + C*src[stride+1] + D*src[stride+2] + rounder)>>8;\n        dst[2]= (A*src[2] + B*src[3] + C*src[stride+2] + D*src[stride+3] + rounder)>>8;\n        dst[3]= (A*src[3] + B*src[4] + C*src[stride+3] + D*src[stride+4] + rounder)>>8;\n        dst[4]= (A*src[4] + B*src[5] + C*src[stride+4] + D*src[stride+5] + rounder)>>8;\n        dst[5]= (A*src[5] + B*src[6] + C*src[stride+5] + D*src[stride+6] + rounder)>>8;\n        dst[6]= (A*src[6] + B*src[7] + C*src[stride+6] + D*src[stride+7] + rounder)>>8;\n        dst[7]= (A*src[7] + B*src[8] + C*src[stride+7] + D*src[stride+8] + rounder)>>8;\n        dst+= stride;\n        src+= stride;\n    }\n}\n\nvoid ff_gmc_c(uint8_t *dst, uint8_t *src, int stride, int h, int ox, int oy,\n                  int dxx, int dxy, int dyx, int dyy, int shift, int r, int width, int height)\n{\n    int y, vx, vy;\n    const int s= 1<<shift;\n\n    width--;\n    height--;\n\n    for(y=0; y<h; y++){\n        int x;\n\n        vx= ox;\n        vy= oy;\n        for(x=0; x<8; x++){ //XXX FIXME optimize\n            int src_x, src_y, frac_x, frac_y, index;\n\n            src_x= vx>>16;\n            src_y= vy>>16;\n            frac_x= src_x&(s-1);\n            frac_y= src_y&(s-1);\n            src_x>>=shift;\n            src_y>>=shift;\n\n            if((unsigned)src_x < width){\n                if((unsigned)src_y < height){\n                    index= src_x + src_y*stride;\n                    dst[y*stride + x]= (  (  src[index         ]*(s-frac_x)\n                                           + src[index       +1]*   frac_x )*(s-frac_y)\n                                        + (  src[index+stride  ]*(s-frac_x)\n                                           + src[index+stride+1]*   frac_x )*   frac_y\n                                        + r)>>(shift*2);\n                }else{\n                    index= src_x + av_clip(src_y, 0, height)*stride;\n                    dst[y*stride + x]= ( (  src[index         ]*(s-frac_x)\n                                          + src[index       +1]*   frac_x )*s\n                                        + r)>>(shift*2);\n                }\n            }else{\n                if((unsigned)src_y < height){\n                    index= av_clip(src_x, 0, width) + src_y*stride;\n                    dst[y*stride + x]= (  (  src[index         ]*(s-frac_y)\n                                           + src[index+stride  ]*   frac_y )*s\n                                        + r)>>(shift*2);\n                }else{\n                    index= av_clip(src_x, 0, width) + av_clip(src_y, 0, height)*stride;\n                    dst[y*stride + x]=    src[index         ];\n                }\n            }\n\n            vx+= dxx;\n            vy+= dyx;\n        }\n        ox += dxy;\n        oy += dyy;\n    }\n}\n\nstatic inline void put_tpel_pixels_mc00_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    switch(width){\n    case 2: put_pixels2_8_c (dst, src, stride, height); break;\n    case 4: put_pixels4_8_c (dst, src, stride, height); break;\n    case 8: put_pixels8_8_c (dst, src, stride, height); break;\n    case 16:put_pixels16_8_c(dst, src, stride, height); break;\n    }\n}\n\nstatic inline void put_tpel_pixels_mc10_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (683*(2*src[j] + src[j+1] + 1)) >> 11;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\nstatic inline void put_tpel_pixels_mc20_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (683*(src[j] + 2*src[j+1] + 1)) >> 11;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\nstatic inline void put_tpel_pixels_mc01_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (683*(2*src[j] + src[j+stride] + 1)) >> 11;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\nstatic inline void put_tpel_pixels_mc11_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (2731*(4*src[j] + 3*src[j+1] + 3*src[j+stride] + 2*src[j+stride+1] + 6)) >> 15;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\nstatic inline void put_tpel_pixels_mc12_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (2731*(3*src[j] + 2*src[j+1] + 4*src[j+stride] + 3*src[j+stride+1] + 6)) >> 15;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\nstatic inline void put_tpel_pixels_mc02_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (683*(src[j] + 2*src[j+stride] + 1)) >> 11;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\nstatic inline void put_tpel_pixels_mc21_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (2731*(3*src[j] + 4*src[j+1] + 2*src[j+stride] + 3*src[j+stride+1] + 6)) >> 15;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\nstatic inline void put_tpel_pixels_mc22_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (2731*(2*src[j] + 3*src[j+1] + 3*src[j+stride] + 4*src[j+stride+1] + 6)) >> 15;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\nstatic inline void avg_tpel_pixels_mc00_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    switch(width){\n    case 2: avg_pixels2_8_c (dst, src, stride, height); break;\n    case 4: avg_pixels4_8_c (dst, src, stride, height); break;\n    case 8: avg_pixels8_8_c (dst, src, stride, height); break;\n    case 16:avg_pixels16_8_c(dst, src, stride, height); break;\n    }\n}\n\nstatic inline void avg_tpel_pixels_mc10_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (dst[j] + ((683*(2*src[j] + src[j+1] + 1)) >> 11) + 1) >> 1;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\nstatic inline void avg_tpel_pixels_mc20_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (dst[j] + ((683*(src[j] + 2*src[j+1] + 1)) >> 11) + 1) >> 1;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\nstatic inline void avg_tpel_pixels_mc01_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (dst[j] + ((683*(2*src[j] + src[j+stride] + 1)) >> 11) + 1) >> 1;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\nstatic inline void avg_tpel_pixels_mc11_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (dst[j] + ((2731*(4*src[j] + 3*src[j+1] + 3*src[j+stride] + 2*src[j+stride+1] + 6)) >> 15) + 1) >> 1;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\nstatic inline void avg_tpel_pixels_mc12_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (dst[j] + ((2731*(3*src[j] + 2*src[j+1] + 4*src[j+stride] + 3*src[j+stride+1] + 6)) >> 15) + 1) >> 1;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\nstatic inline void avg_tpel_pixels_mc02_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (dst[j] + ((683*(src[j] + 2*src[j+stride] + 1)) >> 11) + 1) >> 1;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\nstatic inline void avg_tpel_pixels_mc21_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (dst[j] + ((2731*(3*src[j] + 4*src[j+1] + 2*src[j+stride] + 3*src[j+stride+1] + 6)) >> 15) + 1) >> 1;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\nstatic inline void avg_tpel_pixels_mc22_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (dst[j] + ((2731*(2*src[j] + 3*src[j+1] + 3*src[j+stride] + 4*src[j+stride+1] + 6)) >> 15) + 1) >> 1;\n      }\n      src += stride;\n      dst += stride;\n    }\n}\n\n#define QPEL_MC(r, OPNAME, RND, OP) \\\nstatic void OPNAME ## mpeg4_qpel8_h_lowpass(uint8_t *dst, uint8_t *src, int dstStride, int srcStride, int h){\\\n    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\\\n    int i;\\\n    for(i=0; i<h; i++)\\\n    {\\\n        OP(dst[0], (src[0]+src[1])*20 - (src[0]+src[2])*6 + (src[1]+src[3])*3 - (src[2]+src[4]));\\\n        OP(dst[1], (src[1]+src[2])*20 - (src[0]+src[3])*6 + (src[0]+src[4])*3 - (src[1]+src[5]));\\\n        OP(dst[2], (src[2]+src[3])*20 - (src[1]+src[4])*6 + (src[0]+src[5])*3 - (src[0]+src[6]));\\\n        OP(dst[3], (src[3]+src[4])*20 - (src[2]+src[5])*6 + (src[1]+src[6])*3 - (src[0]+src[7]));\\\n        OP(dst[4], (src[4]+src[5])*20 - (src[3]+src[6])*6 + (src[2]+src[7])*3 - (src[1]+src[8]));\\\n        OP(dst[5], (src[5]+src[6])*20 - (src[4]+src[7])*6 + (src[3]+src[8])*3 - (src[2]+src[8]));\\\n        OP(dst[6], (src[6]+src[7])*20 - (src[5]+src[8])*6 + (src[4]+src[8])*3 - (src[3]+src[7]));\\\n        OP(dst[7], (src[7]+src[8])*20 - (src[6]+src[8])*6 + (src[5]+src[7])*3 - (src[4]+src[6]));\\\n        dst+=dstStride;\\\n        src+=srcStride;\\\n    }\\\n}\\\n\\\nstatic void OPNAME ## mpeg4_qpel8_v_lowpass(uint8_t *dst, uint8_t *src, int dstStride, int srcStride){\\\n    const int w=8;\\\n    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\\\n    int i;\\\n    for(i=0; i<w; i++)\\\n    {\\\n        const int src0= src[0*srcStride];\\\n        const int src1= src[1*srcStride];\\\n        const int src2= src[2*srcStride];\\\n        const int src3= src[3*srcStride];\\\n        const int src4= src[4*srcStride];\\\n        const int src5= src[5*srcStride];\\\n        const int src6= src[6*srcStride];\\\n        const int src7= src[7*srcStride];\\\n        const int src8= src[8*srcStride];\\\n        OP(dst[0*dstStride], (src0+src1)*20 - (src0+src2)*6 + (src1+src3)*3 - (src2+src4));\\\n        OP(dst[1*dstStride], (src1+src2)*20 - (src0+src3)*6 + (src0+src4)*3 - (src1+src5));\\\n        OP(dst[2*dstStride], (src2+src3)*20 - (src1+src4)*6 + (src0+src5)*3 - (src0+src6));\\\n        OP(dst[3*dstStride], (src3+src4)*20 - (src2+src5)*6 + (src1+src6)*3 - (src0+src7));\\\n        OP(dst[4*dstStride], (src4+src5)*20 - (src3+src6)*6 + (src2+src7)*3 - (src1+src8));\\\n        OP(dst[5*dstStride], (src5+src6)*20 - (src4+src7)*6 + (src3+src8)*3 - (src2+src8));\\\n        OP(dst[6*dstStride], (src6+src7)*20 - (src5+src8)*6 + (src4+src8)*3 - (src3+src7));\\\n        OP(dst[7*dstStride], (src7+src8)*20 - (src6+src8)*6 + (src5+src7)*3 - (src4+src6));\\\n        dst++;\\\n        src++;\\\n    }\\\n}\\\n\\\nstatic void OPNAME ## mpeg4_qpel16_h_lowpass(uint8_t *dst, uint8_t *src, int dstStride, int srcStride, int h){\\\n    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\\\n    int i;\\\n    \\\n    for(i=0; i<h; i++)\\\n    {\\\n        OP(dst[ 0], (src[ 0]+src[ 1])*20 - (src[ 0]+src[ 2])*6 + (src[ 1]+src[ 3])*3 - (src[ 2]+src[ 4]));\\\n        OP(dst[ 1], (src[ 1]+src[ 2])*20 - (src[ 0]+src[ 3])*6 + (src[ 0]+src[ 4])*3 - (src[ 1]+src[ 5]));\\\n        OP(dst[ 2], (src[ 2]+src[ 3])*20 - (src[ 1]+src[ 4])*6 + (src[ 0]+src[ 5])*3 - (src[ 0]+src[ 6]));\\\n        OP(dst[ 3], (src[ 3]+src[ 4])*20 - (src[ 2]+src[ 5])*6 + (src[ 1]+src[ 6])*3 - (src[ 0]+src[ 7]));\\\n        OP(dst[ 4], (src[ 4]+src[ 5])*20 - (src[ 3]+src[ 6])*6 + (src[ 2]+src[ 7])*3 - (src[ 1]+src[ 8]));\\\n        OP(dst[ 5], (src[ 5]+src[ 6])*20 - (src[ 4]+src[ 7])*6 + (src[ 3]+src[ 8])*3 - (src[ 2]+src[ 9]));\\\n        OP(dst[ 6], (src[ 6]+src[ 7])*20 - (src[ 5]+src[ 8])*6 + (src[ 4]+src[ 9])*3 - (src[ 3]+src[10]));\\\n        OP(dst[ 7], (src[ 7]+src[ 8])*20 - (src[ 6]+src[ 9])*6 + (src[ 5]+src[10])*3 - (src[ 4]+src[11]));\\\n        OP(dst[ 8], (src[ 8]+src[ 9])*20 - (src[ 7]+src[10])*6 + (src[ 6]+src[11])*3 - (src[ 5]+src[12]));\\\n        OP(dst[ 9], (src[ 9]+src[10])*20 - (src[ 8]+src[11])*6 + (src[ 7]+src[12])*3 - (src[ 6]+src[13]));\\\n        OP(dst[10], (src[10]+src[11])*20 - (src[ 9]+src[12])*6 + (src[ 8]+src[13])*3 - (src[ 7]+src[14]));\\\n        OP(dst[11], (src[11]+src[12])*20 - (src[10]+src[13])*6 + (src[ 9]+src[14])*3 - (src[ 8]+src[15]));\\\n        OP(dst[12], (src[12]+src[13])*20 - (src[11]+src[14])*6 + (src[10]+src[15])*3 - (src[ 9]+src[16]));\\\n        OP(dst[13], (src[13]+src[14])*20 - (src[12]+src[15])*6 + (src[11]+src[16])*3 - (src[10]+src[16]));\\\n        OP(dst[14], (src[14]+src[15])*20 - (src[13]+src[16])*6 + (src[12]+src[16])*3 - (src[11]+src[15]));\\\n        OP(dst[15], (src[15]+src[16])*20 - (src[14]+src[16])*6 + (src[13]+src[15])*3 - (src[12]+src[14]));\\\n        dst+=dstStride;\\\n        src+=srcStride;\\\n    }\\\n}\\\n\\\nstatic void OPNAME ## mpeg4_qpel16_v_lowpass(uint8_t *dst, uint8_t *src, int dstStride, int srcStride){\\\n    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\\\n    int i;\\\n    const int w=16;\\\n    for(i=0; i<w; i++)\\\n    {\\\n        const int src0= src[0*srcStride];\\\n        const int src1= src[1*srcStride];\\\n        const int src2= src[2*srcStride];\\\n        const int src3= src[3*srcStride];\\\n        const int src4= src[4*srcStride];\\\n        const int src5= src[5*srcStride];\\\n        const int src6= src[6*srcStride];\\\n        const int src7= src[7*srcStride];\\\n        const int src8= src[8*srcStride];\\\n        const int src9= src[9*srcStride];\\\n        const int src10= src[10*srcStride];\\\n        const int src11= src[11*srcStride];\\\n        const int src12= src[12*srcStride];\\\n        const int src13= src[13*srcStride];\\\n        const int src14= src[14*srcStride];\\\n        const int src15= src[15*srcStride];\\\n        const int src16= src[16*srcStride];\\\n        OP(dst[ 0*dstStride], (src0 +src1 )*20 - (src0 +src2 )*6 + (src1 +src3 )*3 - (src2 +src4 ));\\\n        OP(dst[ 1*dstStride], (src1 +src2 )*20 - (src0 +src3 )*6 + (src0 +src4 )*3 - (src1 +src5 ));\\\n        OP(dst[ 2*dstStride], (src2 +src3 )*20 - (src1 +src4 )*6 + (src0 +src5 )*3 - (src0 +src6 ));\\\n        OP(dst[ 3*dstStride], (src3 +src4 )*20 - (src2 +src5 )*6 + (src1 +src6 )*3 - (src0 +src7 ));\\\n        OP(dst[ 4*dstStride], (src4 +src5 )*20 - (src3 +src6 )*6 + (src2 +src7 )*3 - (src1 +src8 ));\\\n        OP(dst[ 5*dstStride], (src5 +src6 )*20 - (src4 +src7 )*6 + (src3 +src8 )*3 - (src2 +src9 ));\\\n        OP(dst[ 6*dstStride], (src6 +src7 )*20 - (src5 +src8 )*6 + (src4 +src9 )*3 - (src3 +src10));\\\n        OP(dst[ 7*dstStride], (src7 +src8 )*20 - (src6 +src9 )*6 + (src5 +src10)*3 - (src4 +src11));\\\n        OP(dst[ 8*dstStride], (src8 +src9 )*20 - (src7 +src10)*6 + (src6 +src11)*3 - (src5 +src12));\\\n        OP(dst[ 9*dstStride], (src9 +src10)*20 - (src8 +src11)*6 + (src7 +src12)*3 - (src6 +src13));\\\n        OP(dst[10*dstStride], (src10+src11)*20 - (src9 +src12)*6 + (src8 +src13)*3 - (src7 +src14));\\\n        OP(dst[11*dstStride], (src11+src12)*20 - (src10+src13)*6 + (src9 +src14)*3 - (src8 +src15));\\\n        OP(dst[12*dstStride], (src12+src13)*20 - (src11+src14)*6 + (src10+src15)*3 - (src9 +src16));\\\n        OP(dst[13*dstStride], (src13+src14)*20 - (src12+src15)*6 + (src11+src16)*3 - (src10+src16));\\\n        OP(dst[14*dstStride], (src14+src15)*20 - (src13+src16)*6 + (src12+src16)*3 - (src11+src15));\\\n        OP(dst[15*dstStride], (src15+src16)*20 - (src14+src16)*6 + (src13+src15)*3 - (src12+src14));\\\n        dst++;\\\n        src++;\\\n    }\\\n}\\\n\\\nstatic void OPNAME ## qpel8_mc10_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t half[64];\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(half, src, 8, stride, 8);\\\n    OPNAME ## pixels8_l2_8(dst, src, half, stride, stride, 8, 8);\\\n}\\\n\\\nstatic void OPNAME ## qpel8_mc20_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    OPNAME ## mpeg4_qpel8_h_lowpass(dst, src, stride, stride, 8);\\\n}\\\n\\\nstatic void OPNAME ## qpel8_mc30_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t half[64];\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(half, src, 8, stride, 8);\\\n    OPNAME ## pixels8_l2_8(dst, src+1, half, stride, stride, 8, 8);\\\n}\\\n\\\nstatic void OPNAME ## qpel8_mc01_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[16*9];\\\n    uint8_t half[64];\\\n    copy_block9(full, src, 16, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(half, full, 8, 16);\\\n    OPNAME ## pixels8_l2_8(dst, full, half, stride, 16, 8, 8);\\\n}\\\n\\\nstatic void OPNAME ## qpel8_mc02_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[16*9];\\\n    copy_block9(full, src, 16, stride, 9);\\\n    OPNAME ## mpeg4_qpel8_v_lowpass(dst, full, stride, 16);\\\n}\\\n\\\nstatic void OPNAME ## qpel8_mc03_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[16*9];\\\n    uint8_t half[64];\\\n    copy_block9(full, src, 16, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(half, full, 8, 16);\\\n    OPNAME ## pixels8_l2_8(dst, full+16, half, stride, 16, 8, 8);\\\n}\\\nvoid ff_ ## OPNAME ## qpel8_mc11_old_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[16*9];\\\n    uint8_t halfH[72];\\\n    uint8_t halfV[64];\\\n    uint8_t halfHV[64];\\\n    copy_block9(full, src, 16, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(halfH, full, 8, 16, 9);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfV, full, 8, 16);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfHV, halfH, 8, 8);\\\n    OPNAME ## pixels8_l4_8(dst, full, halfH, halfV, halfHV, stride, 16, 8, 8, 8, 8);\\\n}\\\nstatic void OPNAME ## qpel8_mc11_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[16*9];\\\n    uint8_t halfH[72];\\\n    uint8_t halfHV[64];\\\n    copy_block9(full, src, 16, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(halfH, full, 8, 16, 9);\\\n    put ## RND ## pixels8_l2_8(halfH, halfH, full, 8, 8, 16, 9);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfHV, halfH, 8, 8);\\\n    OPNAME ## pixels8_l2_8(dst, halfH, halfHV, stride, 8, 8, 8);\\\n}\\\nvoid ff_ ## OPNAME ## qpel8_mc31_old_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[16*9];\\\n    uint8_t halfH[72];\\\n    uint8_t halfV[64];\\\n    uint8_t halfHV[64];\\\n    copy_block9(full, src, 16, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(halfH, full, 8, 16, 9);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfV, full+1, 8, 16);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfHV, halfH, 8, 8);\\\n    OPNAME ## pixels8_l4_8(dst, full+1, halfH, halfV, halfHV, stride, 16, 8, 8, 8, 8);\\\n}\\\nstatic void OPNAME ## qpel8_mc31_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[16*9];\\\n    uint8_t halfH[72];\\\n    uint8_t halfHV[64];\\\n    copy_block9(full, src, 16, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(halfH, full, 8, 16, 9);\\\n    put ## RND ## pixels8_l2_8(halfH, halfH, full+1, 8, 8, 16, 9);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfHV, halfH, 8, 8);\\\n    OPNAME ## pixels8_l2_8(dst, halfH, halfHV, stride, 8, 8, 8);\\\n}\\\nvoid ff_ ## OPNAME ## qpel8_mc13_old_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[16*9];\\\n    uint8_t halfH[72];\\\n    uint8_t halfV[64];\\\n    uint8_t halfHV[64];\\\n    copy_block9(full, src, 16, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(halfH, full, 8, 16, 9);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfV, full, 8, 16);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfHV, halfH, 8, 8);\\\n    OPNAME ## pixels8_l4_8(dst, full+16, halfH+8, halfV, halfHV, stride, 16, 8, 8, 8, 8);\\\n}\\\nstatic void OPNAME ## qpel8_mc13_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[16*9];\\\n    uint8_t halfH[72];\\\n    uint8_t halfHV[64];\\\n    copy_block9(full, src, 16, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(halfH, full, 8, 16, 9);\\\n    put ## RND ## pixels8_l2_8(halfH, halfH, full, 8, 8, 16, 9);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfHV, halfH, 8, 8);\\\n    OPNAME ## pixels8_l2_8(dst, halfH+8, halfHV, stride, 8, 8, 8);\\\n}\\\nvoid ff_ ## OPNAME ## qpel8_mc33_old_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[16*9];\\\n    uint8_t halfH[72];\\\n    uint8_t halfV[64];\\\n    uint8_t halfHV[64];\\\n    copy_block9(full, src, 16, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(halfH, full  , 8, 16, 9);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfV, full+1, 8, 16);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfHV, halfH, 8, 8);\\\n    OPNAME ## pixels8_l4_8(dst, full+17, halfH+8, halfV, halfHV, stride, 16, 8, 8, 8, 8);\\\n}\\\nstatic void OPNAME ## qpel8_mc33_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[16*9];\\\n    uint8_t halfH[72];\\\n    uint8_t halfHV[64];\\\n    copy_block9(full, src, 16, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(halfH, full, 8, 16, 9);\\\n    put ## RND ## pixels8_l2_8(halfH, halfH, full+1, 8, 8, 16, 9);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfHV, halfH, 8, 8);\\\n    OPNAME ## pixels8_l2_8(dst, halfH+8, halfHV, stride, 8, 8, 8);\\\n}\\\nstatic void OPNAME ## qpel8_mc21_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t halfH[72];\\\n    uint8_t halfHV[64];\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(halfH, src, 8, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfHV, halfH, 8, 8);\\\n    OPNAME ## pixels8_l2_8(dst, halfH, halfHV, stride, 8, 8, 8);\\\n}\\\nstatic void OPNAME ## qpel8_mc23_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t halfH[72];\\\n    uint8_t halfHV[64];\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(halfH, src, 8, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfHV, halfH, 8, 8);\\\n    OPNAME ## pixels8_l2_8(dst, halfH+8, halfHV, stride, 8, 8, 8);\\\n}\\\nvoid ff_ ## OPNAME ## qpel8_mc12_old_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[16*9];\\\n    uint8_t halfH[72];\\\n    uint8_t halfV[64];\\\n    uint8_t halfHV[64];\\\n    copy_block9(full, src, 16, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(halfH, full, 8, 16, 9);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfV, full, 8, 16);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfHV, halfH, 8, 8);\\\n    OPNAME ## pixels8_l2_8(dst, halfV, halfHV, stride, 8, 8, 8);\\\n}\\\nstatic void OPNAME ## qpel8_mc12_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[16*9];\\\n    uint8_t halfH[72];\\\n    copy_block9(full, src, 16, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(halfH, full, 8, 16, 9);\\\n    put ## RND ## pixels8_l2_8(halfH, halfH, full, 8, 8, 16, 9);\\\n    OPNAME ## mpeg4_qpel8_v_lowpass(dst, halfH, stride, 8);\\\n}\\\nvoid ff_ ## OPNAME ## qpel8_mc32_old_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[16*9];\\\n    uint8_t halfH[72];\\\n    uint8_t halfV[64];\\\n    uint8_t halfHV[64];\\\n    copy_block9(full, src, 16, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(halfH, full, 8, 16, 9);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfV, full+1, 8, 16);\\\n    put ## RND ## mpeg4_qpel8_v_lowpass(halfHV, halfH, 8, 8);\\\n    OPNAME ## pixels8_l2_8(dst, halfV, halfHV, stride, 8, 8, 8);\\\n}\\\nstatic void OPNAME ## qpel8_mc32_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[16*9];\\\n    uint8_t halfH[72];\\\n    copy_block9(full, src, 16, stride, 9);\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(halfH, full, 8, 16, 9);\\\n    put ## RND ## pixels8_l2_8(halfH, halfH, full+1, 8, 8, 16, 9);\\\n    OPNAME ## mpeg4_qpel8_v_lowpass(dst, halfH, stride, 8);\\\n}\\\nstatic void OPNAME ## qpel8_mc22_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t halfH[72];\\\n    put ## RND ## mpeg4_qpel8_h_lowpass(halfH, src, 8, stride, 9);\\\n    OPNAME ## mpeg4_qpel8_v_lowpass(dst, halfH, stride, 8);\\\n}\\\n\\\nstatic void OPNAME ## qpel16_mc10_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t half[256];\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(half, src, 16, stride, 16);\\\n    OPNAME ## pixels16_l2_8(dst, src, half, stride, stride, 16, 16);\\\n}\\\n\\\nstatic void OPNAME ## qpel16_mc20_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    OPNAME ## mpeg4_qpel16_h_lowpass(dst, src, stride, stride, 16);\\\n}\\\n\\\nstatic void OPNAME ## qpel16_mc30_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t half[256];\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(half, src, 16, stride, 16);\\\n    OPNAME ## pixels16_l2_8(dst, src+1, half, stride, stride, 16, 16);\\\n}\\\n\\\nstatic void OPNAME ## qpel16_mc01_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[24*17];\\\n    uint8_t half[256];\\\n    copy_block17(full, src, 24, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(half, full, 16, 24);\\\n    OPNAME ## pixels16_l2_8(dst, full, half, stride, 24, 16, 16);\\\n}\\\n\\\nstatic void OPNAME ## qpel16_mc02_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[24*17];\\\n    copy_block17(full, src, 24, stride, 17);\\\n    OPNAME ## mpeg4_qpel16_v_lowpass(dst, full, stride, 24);\\\n}\\\n\\\nstatic void OPNAME ## qpel16_mc03_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[24*17];\\\n    uint8_t half[256];\\\n    copy_block17(full, src, 24, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(half, full, 16, 24);\\\n    OPNAME ## pixels16_l2_8(dst, full+24, half, stride, 24, 16, 16);\\\n}\\\nvoid ff_ ## OPNAME ## qpel16_mc11_old_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[24*17];\\\n    uint8_t halfH[272];\\\n    uint8_t halfV[256];\\\n    uint8_t halfHV[256];\\\n    copy_block17(full, src, 24, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(halfH, full, 16, 24, 17);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfV, full, 16, 24);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfHV, halfH, 16, 16);\\\n    OPNAME ## pixels16_l4_8(dst, full, halfH, halfV, halfHV, stride, 24, 16, 16, 16, 16);\\\n}\\\nstatic void OPNAME ## qpel16_mc11_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[24*17];\\\n    uint8_t halfH[272];\\\n    uint8_t halfHV[256];\\\n    copy_block17(full, src, 24, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(halfH, full, 16, 24, 17);\\\n    put ## RND ## pixels16_l2_8(halfH, halfH, full, 16, 16, 24, 17);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfHV, halfH, 16, 16);\\\n    OPNAME ## pixels16_l2_8(dst, halfH, halfHV, stride, 16, 16, 16);\\\n}\\\nvoid ff_ ## OPNAME ## qpel16_mc31_old_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[24*17];\\\n    uint8_t halfH[272];\\\n    uint8_t halfV[256];\\\n    uint8_t halfHV[256];\\\n    copy_block17(full, src, 24, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(halfH, full, 16, 24, 17);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfV, full+1, 16, 24);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfHV, halfH, 16, 16);\\\n    OPNAME ## pixels16_l4_8(dst, full+1, halfH, halfV, halfHV, stride, 24, 16, 16, 16, 16);\\\n}\\\nstatic void OPNAME ## qpel16_mc31_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[24*17];\\\n    uint8_t halfH[272];\\\n    uint8_t halfHV[256];\\\n    copy_block17(full, src, 24, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(halfH, full, 16, 24, 17);\\\n    put ## RND ## pixels16_l2_8(halfH, halfH, full+1, 16, 16, 24, 17);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfHV, halfH, 16, 16);\\\n    OPNAME ## pixels16_l2_8(dst, halfH, halfHV, stride, 16, 16, 16);\\\n}\\\nvoid ff_ ## OPNAME ## qpel16_mc13_old_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[24*17];\\\n    uint8_t halfH[272];\\\n    uint8_t halfV[256];\\\n    uint8_t halfHV[256];\\\n    copy_block17(full, src, 24, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(halfH, full, 16, 24, 17);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfV, full, 16, 24);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfHV, halfH, 16, 16);\\\n    OPNAME ## pixels16_l4_8(dst, full+24, halfH+16, halfV, halfHV, stride, 24, 16, 16, 16, 16);\\\n}\\\nstatic void OPNAME ## qpel16_mc13_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[24*17];\\\n    uint8_t halfH[272];\\\n    uint8_t halfHV[256];\\\n    copy_block17(full, src, 24, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(halfH, full, 16, 24, 17);\\\n    put ## RND ## pixels16_l2_8(halfH, halfH, full, 16, 16, 24, 17);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfHV, halfH, 16, 16);\\\n    OPNAME ## pixels16_l2_8(dst, halfH+16, halfHV, stride, 16, 16, 16);\\\n}\\\nvoid ff_ ## OPNAME ## qpel16_mc33_old_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[24*17];\\\n    uint8_t halfH[272];\\\n    uint8_t halfV[256];\\\n    uint8_t halfHV[256];\\\n    copy_block17(full, src, 24, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(halfH, full  , 16, 24, 17);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfV, full+1, 16, 24);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfHV, halfH, 16, 16);\\\n    OPNAME ## pixels16_l4_8(dst, full+25, halfH+16, halfV, halfHV, stride, 24, 16, 16, 16, 16);\\\n}\\\nstatic void OPNAME ## qpel16_mc33_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[24*17];\\\n    uint8_t halfH[272];\\\n    uint8_t halfHV[256];\\\n    copy_block17(full, src, 24, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(halfH, full, 16, 24, 17);\\\n    put ## RND ## pixels16_l2_8(halfH, halfH, full+1, 16, 16, 24, 17);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfHV, halfH, 16, 16);\\\n    OPNAME ## pixels16_l2_8(dst, halfH+16, halfHV, stride, 16, 16, 16);\\\n}\\\nstatic void OPNAME ## qpel16_mc21_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t halfH[272];\\\n    uint8_t halfHV[256];\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(halfH, src, 16, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfHV, halfH, 16, 16);\\\n    OPNAME ## pixels16_l2_8(dst, halfH, halfHV, stride, 16, 16, 16);\\\n}\\\nstatic void OPNAME ## qpel16_mc23_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t halfH[272];\\\n    uint8_t halfHV[256];\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(halfH, src, 16, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfHV, halfH, 16, 16);\\\n    OPNAME ## pixels16_l2_8(dst, halfH+16, halfHV, stride, 16, 16, 16);\\\n}\\\nvoid ff_ ## OPNAME ## qpel16_mc12_old_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[24*17];\\\n    uint8_t halfH[272];\\\n    uint8_t halfV[256];\\\n    uint8_t halfHV[256];\\\n    copy_block17(full, src, 24, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(halfH, full, 16, 24, 17);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfV, full, 16, 24);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfHV, halfH, 16, 16);\\\n    OPNAME ## pixels16_l2_8(dst, halfV, halfHV, stride, 16, 16, 16);\\\n}\\\nstatic void OPNAME ## qpel16_mc12_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[24*17];\\\n    uint8_t halfH[272];\\\n    copy_block17(full, src, 24, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(halfH, full, 16, 24, 17);\\\n    put ## RND ## pixels16_l2_8(halfH, halfH, full, 16, 16, 24, 17);\\\n    OPNAME ## mpeg4_qpel16_v_lowpass(dst, halfH, stride, 16);\\\n}\\\nvoid ff_ ## OPNAME ## qpel16_mc32_old_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[24*17];\\\n    uint8_t halfH[272];\\\n    uint8_t halfV[256];\\\n    uint8_t halfHV[256];\\\n    copy_block17(full, src, 24, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(halfH, full, 16, 24, 17);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfV, full+1, 16, 24);\\\n    put ## RND ## mpeg4_qpel16_v_lowpass(halfHV, halfH, 16, 16);\\\n    OPNAME ## pixels16_l2_8(dst, halfV, halfHV, stride, 16, 16, 16);\\\n}\\\nstatic void OPNAME ## qpel16_mc32_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t full[24*17];\\\n    uint8_t halfH[272];\\\n    copy_block17(full, src, 24, stride, 17);\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(halfH, full, 16, 24, 17);\\\n    put ## RND ## pixels16_l2_8(halfH, halfH, full+1, 16, 16, 24, 17);\\\n    OPNAME ## mpeg4_qpel16_v_lowpass(dst, halfH, stride, 16);\\\n}\\\nstatic void OPNAME ## qpel16_mc22_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\\\n{\\\n    uint8_t halfH[272];\\\n    put ## RND ## mpeg4_qpel16_h_lowpass(halfH, src, 16, stride, 17);\\\n    OPNAME ## mpeg4_qpel16_v_lowpass(dst, halfH, stride, 16);\\\n}\n\n#define op_avg(a, b) a = (((a)+cm[((b) + 16)>>5]+1)>>1)\n#define op_avg_no_rnd(a, b) a = (((a)+cm[((b) + 15)>>5])>>1)\n#define op_put(a, b) a = cm[((b) + 16)>>5]\n#define op_put_no_rnd(a, b) a = cm[((b) + 15)>>5]\n\nQPEL_MC(0, put_       , _       , op_put)\nQPEL_MC(1, put_no_rnd_, _no_rnd_, op_put_no_rnd)\nQPEL_MC(0, avg_       , _       , op_avg)\n//QPEL_MC(1, avg_no_rnd , _       , op_avg)\n#undef op_avg\n#undef op_avg_no_rnd\n#undef op_put\n#undef op_put_no_rnd\n\nvoid ff_put_pixels8x8_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    put_pixels8_8_c(dst, src, stride, 8);\n}\nvoid ff_avg_pixels8x8_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    avg_pixels8_8_c(dst, src, stride, 8);\n}\nvoid ff_put_pixels16x16_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    put_pixels16_8_c(dst, src, stride, 16);\n}\nvoid ff_avg_pixels16x16_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    avg_pixels16_8_c(dst, src, stride, 16);\n}\n\n#define put_qpel8_mc00_c  ff_put_pixels8x8_c\n#define avg_qpel8_mc00_c  ff_avg_pixels8x8_c\n#define put_qpel16_mc00_c ff_put_pixels16x16_c\n#define avg_qpel16_mc00_c ff_avg_pixels16x16_c\n#define put_no_rnd_qpel8_mc00_c  ff_put_pixels8x8_c\n#define put_no_rnd_qpel16_mc00_c ff_put_pixels16x16_c\n\nstatic void wmv2_mspel8_h_lowpass(uint8_t *dst, uint8_t *src, int dstStride, int srcStride, int h){\n    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\n    int i;\n\n    for(i=0; i<h; i++){\n        dst[0]= cm[(9*(src[0] + src[1]) - (src[-1] + src[2]) + 8)>>4];\n        dst[1]= cm[(9*(src[1] + src[2]) - (src[ 0] + src[3]) + 8)>>4];\n        dst[2]= cm[(9*(src[2] + src[3]) - (src[ 1] + src[4]) + 8)>>4];\n        dst[3]= cm[(9*(src[3] + src[4]) - (src[ 2] + src[5]) + 8)>>4];\n        dst[4]= cm[(9*(src[4] + src[5]) - (src[ 3] + src[6]) + 8)>>4];\n        dst[5]= cm[(9*(src[5] + src[6]) - (src[ 4] + src[7]) + 8)>>4];\n        dst[6]= cm[(9*(src[6] + src[7]) - (src[ 5] + src[8]) + 8)>>4];\n        dst[7]= cm[(9*(src[7] + src[8]) - (src[ 6] + src[9]) + 8)>>4];\n        dst+=dstStride;\n        src+=srcStride;\n    }\n}\n\n#if CONFIG_RV40_DECODER\nvoid ff_put_rv40_qpel16_mc33_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    put_pixels16_xy2_8_c(dst, src, stride, 16);\n}\nvoid ff_avg_rv40_qpel16_mc33_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    avg_pixels16_xy2_8_c(dst, src, stride, 16);\n}\nvoid ff_put_rv40_qpel8_mc33_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    put_pixels8_xy2_8_c(dst, src, stride, 8);\n}\nvoid ff_avg_rv40_qpel8_mc33_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    avg_pixels8_xy2_8_c(dst, src, stride, 8);\n}\n#endif /* CONFIG_RV40_DECODER */\n\n#if CONFIG_DIRAC_DECODER\n#define DIRAC_MC(OPNAME)\\\nvoid ff_ ## OPNAME ## _dirac_pixels8_c(uint8_t *dst, const uint8_t *src[5], int stride, int h)\\\n{\\\n     OPNAME ## _pixels8_8_c(dst, src[0], stride, h);\\\n}\\\nvoid ff_ ## OPNAME ## _dirac_pixels16_c(uint8_t *dst, const uint8_t *src[5], int stride, int h)\\\n{\\\n    OPNAME ## _pixels16_8_c(dst, src[0], stride, h);\\\n}\\\nvoid ff_ ## OPNAME ## _dirac_pixels32_c(uint8_t *dst, const uint8_t *src[5], int stride, int h)\\\n{\\\n    OPNAME ## _pixels16_8_c(dst   , src[0]   , stride, h);\\\n    OPNAME ## _pixels16_8_c(dst+16, src[0]+16, stride, h);\\\n}\\\nvoid ff_ ## OPNAME ## _dirac_pixels8_l2_c(uint8_t *dst, const uint8_t *src[5], int stride, int h)\\\n{\\\n    OPNAME ## _pixels8_l2_8(dst, src[0], src[1], stride, stride, stride, h);\\\n}\\\nvoid ff_ ## OPNAME ## _dirac_pixels16_l2_c(uint8_t *dst, const uint8_t *src[5], int stride, int h)\\\n{\\\n    OPNAME ## _pixels16_l2_8(dst, src[0], src[1], stride, stride, stride, h);\\\n}\\\nvoid ff_ ## OPNAME ## _dirac_pixels32_l2_c(uint8_t *dst, const uint8_t *src[5], int stride, int h)\\\n{\\\n    OPNAME ## _pixels16_l2_8(dst   , src[0]   , src[1]   , stride, stride, stride, h);\\\n    OPNAME ## _pixels16_l2_8(dst+16, src[0]+16, src[1]+16, stride, stride, stride, h);\\\n}\\\nvoid ff_ ## OPNAME ## _dirac_pixels8_l4_c(uint8_t *dst, const uint8_t *src[5], int stride, int h)\\\n{\\\n    OPNAME ## _pixels8_l4_8(dst, src[0], src[1], src[2], src[3], stride, stride, stride, stride, stride, h);\\\n}\\\nvoid ff_ ## OPNAME ## _dirac_pixels16_l4_c(uint8_t *dst, const uint8_t *src[5], int stride, int h)\\\n{\\\n    OPNAME ## _pixels16_l4_8(dst, src[0], src[1], src[2], src[3], stride, stride, stride, stride, stride, h);\\\n}\\\nvoid ff_ ## OPNAME ## _dirac_pixels32_l4_c(uint8_t *dst, const uint8_t *src[5], int stride, int h)\\\n{\\\n    OPNAME ## _pixels16_l4_8(dst   , src[0]   , src[1]   , src[2]   , src[3]   , stride, stride, stride, stride, stride, h);\\\n    OPNAME ## _pixels16_l4_8(dst+16, src[0]+16, src[1]+16, src[2]+16, src[3]+16, stride, stride, stride, stride, stride, h);\\\n}\nDIRAC_MC(put)\nDIRAC_MC(avg)\n#endif\n\nstatic void wmv2_mspel8_v_lowpass(uint8_t *dst, uint8_t *src, int dstStride, int srcStride, int w){\n    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\n    int i;\n\n    for(i=0; i<w; i++){\n        const int src_1= src[ -srcStride];\n        const int src0 = src[0          ];\n        const int src1 = src[  srcStride];\n        const int src2 = src[2*srcStride];\n        const int src3 = src[3*srcStride];\n        const int src4 = src[4*srcStride];\n        const int src5 = src[5*srcStride];\n        const int src6 = src[6*srcStride];\n        const int src7 = src[7*srcStride];\n        const int src8 = src[8*srcStride];\n        const int src9 = src[9*srcStride];\n        dst[0*dstStride]= cm[(9*(src0 + src1) - (src_1 + src2) + 8)>>4];\n        dst[1*dstStride]= cm[(9*(src1 + src2) - (src0  + src3) + 8)>>4];\n        dst[2*dstStride]= cm[(9*(src2 + src3) - (src1  + src4) + 8)>>4];\n        dst[3*dstStride]= cm[(9*(src3 + src4) - (src2  + src5) + 8)>>4];\n        dst[4*dstStride]= cm[(9*(src4 + src5) - (src3  + src6) + 8)>>4];\n        dst[5*dstStride]= cm[(9*(src5 + src6) - (src4  + src7) + 8)>>4];\n        dst[6*dstStride]= cm[(9*(src6 + src7) - (src5  + src8) + 8)>>4];\n        dst[7*dstStride]= cm[(9*(src7 + src8) - (src6  + src9) + 8)>>4];\n        src++;\n        dst++;\n    }\n}\n\nstatic void put_mspel8_mc10_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    uint8_t half[64];\n    wmv2_mspel8_h_lowpass(half, src, 8, stride, 8);\n    put_pixels8_l2_8(dst, src, half, stride, stride, 8, 8);\n}\n\nstatic void put_mspel8_mc20_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    wmv2_mspel8_h_lowpass(dst, src, stride, stride, 8);\n}\n\nstatic void put_mspel8_mc30_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    uint8_t half[64];\n    wmv2_mspel8_h_lowpass(half, src, 8, stride, 8);\n    put_pixels8_l2_8(dst, src+1, half, stride, stride, 8, 8);\n}\n\nstatic void put_mspel8_mc02_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    wmv2_mspel8_v_lowpass(dst, src, stride, stride, 8);\n}\n\nstatic void put_mspel8_mc12_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    uint8_t halfH[88];\n    uint8_t halfV[64];\n    uint8_t halfHV[64];\n    wmv2_mspel8_h_lowpass(halfH, src-stride, 8, stride, 11);\n    wmv2_mspel8_v_lowpass(halfV, src, 8, stride, 8);\n    wmv2_mspel8_v_lowpass(halfHV, halfH+8, 8, 8, 8);\n    put_pixels8_l2_8(dst, halfV, halfHV, stride, 8, 8, 8);\n}\nstatic void put_mspel8_mc32_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    uint8_t halfH[88];\n    uint8_t halfV[64];\n    uint8_t halfHV[64];\n    wmv2_mspel8_h_lowpass(halfH, src-stride, 8, stride, 11);\n    wmv2_mspel8_v_lowpass(halfV, src+1, 8, stride, 8);\n    wmv2_mspel8_v_lowpass(halfHV, halfH+8, 8, 8, 8);\n    put_pixels8_l2_8(dst, halfV, halfHV, stride, 8, 8, 8);\n}\nstatic void put_mspel8_mc22_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    uint8_t halfH[88];\n    wmv2_mspel8_h_lowpass(halfH, src-stride, 8, stride, 11);\n    wmv2_mspel8_v_lowpass(dst, halfH+8, stride, 8, 8);\n}\n\nstatic void h263_v_loop_filter_c(uint8_t *src, int stride, int qscale){\n    if(CONFIG_H263_DECODER || CONFIG_H263_ENCODER) {\n    int x;\n    const int strength= ff_h263_loop_filter_strength[qscale];\n\n    for(x=0; x<8; x++){\n        int d1, d2, ad1;\n        int p0= src[x-2*stride];\n        int p1= src[x-1*stride];\n        int p2= src[x+0*stride];\n        int p3= src[x+1*stride];\n        int d = (p0 - p3 + 4*(p2 - p1)) / 8;\n\n        if     (d<-2*strength) d1= 0;\n        else if(d<-  strength) d1=-2*strength - d;\n        else if(d<   strength) d1= d;\n        else if(d< 2*strength) d1= 2*strength - d;\n        else                   d1= 0;\n\n        p1 += d1;\n        p2 -= d1;\n        if(p1&256) p1= ~(p1>>31);\n        if(p2&256) p2= ~(p2>>31);\n\n        src[x-1*stride] = p1;\n        src[x+0*stride] = p2;\n\n        ad1= FFABS(d1)>>1;\n\n        d2= av_clip((p0-p3)/4, -ad1, ad1);\n\n        src[x-2*stride] = p0 - d2;\n        src[x+  stride] = p3 + d2;\n    }\n    }\n}\n\nstatic void h263_h_loop_filter_c(uint8_t *src, int stride, int qscale){\n    if(CONFIG_H263_DECODER || CONFIG_H263_ENCODER) {\n    int y;\n    const int strength= ff_h263_loop_filter_strength[qscale];\n\n    for(y=0; y<8; y++){\n        int d1, d2, ad1;\n        int p0= src[y*stride-2];\n        int p1= src[y*stride-1];\n        int p2= src[y*stride+0];\n        int p3= src[y*stride+1];\n        int d = (p0 - p3 + 4*(p2 - p1)) / 8;\n\n        if     (d<-2*strength) d1= 0;\n        else if(d<-  strength) d1=-2*strength - d;\n        else if(d<   strength) d1= d;\n        else if(d< 2*strength) d1= 2*strength - d;\n        else                   d1= 0;\n\n        p1 += d1;\n        p2 -= d1;\n        if(p1&256) p1= ~(p1>>31);\n        if(p2&256) p2= ~(p2>>31);\n\n        src[y*stride-1] = p1;\n        src[y*stride+0] = p2;\n\n        ad1= FFABS(d1)>>1;\n\n        d2= av_clip((p0-p3)/4, -ad1, ad1);\n\n        src[y*stride-2] = p0 - d2;\n        src[y*stride+1] = p3 + d2;\n    }\n    }\n}\n\nstatic inline int pix_abs16_c(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)\n{\n    int s, i;\n\n    s = 0;\n    for(i=0;i<h;i++) {\n        s += abs(pix1[0] - pix2[0]);\n        s += abs(pix1[1] - pix2[1]);\n        s += abs(pix1[2] - pix2[2]);\n        s += abs(pix1[3] - pix2[3]);\n        s += abs(pix1[4] - pix2[4]);\n        s += abs(pix1[5] - pix2[5]);\n        s += abs(pix1[6] - pix2[6]);\n        s += abs(pix1[7] - pix2[7]);\n        s += abs(pix1[8] - pix2[8]);\n        s += abs(pix1[9] - pix2[9]);\n        s += abs(pix1[10] - pix2[10]);\n        s += abs(pix1[11] - pix2[11]);\n        s += abs(pix1[12] - pix2[12]);\n        s += abs(pix1[13] - pix2[13]);\n        s += abs(pix1[14] - pix2[14]);\n        s += abs(pix1[15] - pix2[15]);\n        pix1 += line_size;\n        pix2 += line_size;\n    }\n    return s;\n}\n\nstatic int pix_abs16_x2_c(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)\n{\n    int s, i;\n\n    s = 0;\n    for(i=0;i<h;i++) {\n        s += abs(pix1[0] - avg2(pix2[0], pix2[1]));\n        s += abs(pix1[1] - avg2(pix2[1], pix2[2]));\n        s += abs(pix1[2] - avg2(pix2[2], pix2[3]));\n        s += abs(pix1[3] - avg2(pix2[3], pix2[4]));\n        s += abs(pix1[4] - avg2(pix2[4], pix2[5]));\n        s += abs(pix1[5] - avg2(pix2[5], pix2[6]));\n        s += abs(pix1[6] - avg2(pix2[6], pix2[7]));\n        s += abs(pix1[7] - avg2(pix2[7], pix2[8]));\n        s += abs(pix1[8] - avg2(pix2[8], pix2[9]));\n        s += abs(pix1[9] - avg2(pix2[9], pix2[10]));\n        s += abs(pix1[10] - avg2(pix2[10], pix2[11]));\n        s += abs(pix1[11] - avg2(pix2[11], pix2[12]));\n        s += abs(pix1[12] - avg2(pix2[12], pix2[13]));\n        s += abs(pix1[13] - avg2(pix2[13], pix2[14]));\n        s += abs(pix1[14] - avg2(pix2[14], pix2[15]));\n        s += abs(pix1[15] - avg2(pix2[15], pix2[16]));\n        pix1 += line_size;\n        pix2 += line_size;\n    }\n    return s;\n}\n\nstatic int pix_abs16_y2_c(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)\n{\n    int s, i;\n    uint8_t *pix3 = pix2 + line_size;\n\n    s = 0;\n    for(i=0;i<h;i++) {\n        s += abs(pix1[0] - avg2(pix2[0], pix3[0]));\n        s += abs(pix1[1] - avg2(pix2[1], pix3[1]));\n        s += abs(pix1[2] - avg2(pix2[2], pix3[2]));\n        s += abs(pix1[3] - avg2(pix2[3], pix3[3]));\n        s += abs(pix1[4] - avg2(pix2[4], pix3[4]));\n        s += abs(pix1[5] - avg2(pix2[5], pix3[5]));\n        s += abs(pix1[6] - avg2(pix2[6], pix3[6]));\n        s += abs(pix1[7] - avg2(pix2[7], pix3[7]));\n        s += abs(pix1[8] - avg2(pix2[8], pix3[8]));\n        s += abs(pix1[9] - avg2(pix2[9], pix3[9]));\n        s += abs(pix1[10] - avg2(pix2[10], pix3[10]));\n        s += abs(pix1[11] - avg2(pix2[11], pix3[11]));\n        s += abs(pix1[12] - avg2(pix2[12], pix3[12]));\n        s += abs(pix1[13] - avg2(pix2[13], pix3[13]));\n        s += abs(pix1[14] - avg2(pix2[14], pix3[14]));\n        s += abs(pix1[15] - avg2(pix2[15], pix3[15]));\n        pix1 += line_size;\n        pix2 += line_size;\n        pix3 += line_size;\n    }\n    return s;\n}\n\nstatic int pix_abs16_xy2_c(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)\n{\n    int s, i;\n    uint8_t *pix3 = pix2 + line_size;\n\n    s = 0;\n    for(i=0;i<h;i++) {\n        s += abs(pix1[0] - avg4(pix2[0], pix2[1], pix3[0], pix3[1]));\n        s += abs(pix1[1] - avg4(pix2[1], pix2[2], pix3[1], pix3[2]));\n        s += abs(pix1[2] - avg4(pix2[2], pix2[3], pix3[2], pix3[3]));\n        s += abs(pix1[3] - avg4(pix2[3], pix2[4], pix3[3], pix3[4]));\n        s += abs(pix1[4] - avg4(pix2[4], pix2[5], pix3[4], pix3[5]));\n        s += abs(pix1[5] - avg4(pix2[5], pix2[6], pix3[5], pix3[6]));\n        s += abs(pix1[6] - avg4(pix2[6], pix2[7], pix3[6], pix3[7]));\n        s += abs(pix1[7] - avg4(pix2[7], pix2[8], pix3[7], pix3[8]));\n        s += abs(pix1[8] - avg4(pix2[8], pix2[9], pix3[8], pix3[9]));\n        s += abs(pix1[9] - avg4(pix2[9], pix2[10], pix3[9], pix3[10]));\n        s += abs(pix1[10] - avg4(pix2[10], pix2[11], pix3[10], pix3[11]));\n        s += abs(pix1[11] - avg4(pix2[11], pix2[12], pix3[11], pix3[12]));\n        s += abs(pix1[12] - avg4(pix2[12], pix2[13], pix3[12], pix3[13]));\n        s += abs(pix1[13] - avg4(pix2[13], pix2[14], pix3[13], pix3[14]));\n        s += abs(pix1[14] - avg4(pix2[14], pix2[15], pix3[14], pix3[15]));\n        s += abs(pix1[15] - avg4(pix2[15], pix2[16], pix3[15], pix3[16]));\n        pix1 += line_size;\n        pix2 += line_size;\n        pix3 += line_size;\n    }\n    return s;\n}\n\nstatic inline int pix_abs8_c(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)\n{\n    int s, i;\n\n    s = 0;\n    for(i=0;i<h;i++) {\n        s += abs(pix1[0] - pix2[0]);\n        s += abs(pix1[1] - pix2[1]);\n        s += abs(pix1[2] - pix2[2]);\n        s += abs(pix1[3] - pix2[3]);\n        s += abs(pix1[4] - pix2[4]);\n        s += abs(pix1[5] - pix2[5]);\n        s += abs(pix1[6] - pix2[6]);\n        s += abs(pix1[7] - pix2[7]);\n        pix1 += line_size;\n        pix2 += line_size;\n    }\n    return s;\n}\n\nstatic int pix_abs8_x2_c(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)\n{\n    int s, i;\n\n    s = 0;\n    for(i=0;i<h;i++) {\n        s += abs(pix1[0] - avg2(pix2[0], pix2[1]));\n        s += abs(pix1[1] - avg2(pix2[1], pix2[2]));\n        s += abs(pix1[2] - avg2(pix2[2], pix2[3]));\n        s += abs(pix1[3] - avg2(pix2[3], pix2[4]));\n        s += abs(pix1[4] - avg2(pix2[4], pix2[5]));\n        s += abs(pix1[5] - avg2(pix2[5], pix2[6]));\n        s += abs(pix1[6] - avg2(pix2[6], pix2[7]));\n        s += abs(pix1[7] - avg2(pix2[7], pix2[8]));\n        pix1 += line_size;\n        pix2 += line_size;\n    }\n    return s;\n}\n\nstatic int pix_abs8_y2_c(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)\n{\n    int s, i;\n    uint8_t *pix3 = pix2 + line_size;\n\n    s = 0;\n    for(i=0;i<h;i++) {\n        s += abs(pix1[0] - avg2(pix2[0], pix3[0]));\n        s += abs(pix1[1] - avg2(pix2[1], pix3[1]));\n        s += abs(pix1[2] - avg2(pix2[2], pix3[2]));\n        s += abs(pix1[3] - avg2(pix2[3], pix3[3]));\n        s += abs(pix1[4] - avg2(pix2[4], pix3[4]));\n        s += abs(pix1[5] - avg2(pix2[5], pix3[5]));\n        s += abs(pix1[6] - avg2(pix2[6], pix3[6]));\n        s += abs(pix1[7] - avg2(pix2[7], pix3[7]));\n        pix1 += line_size;\n        pix2 += line_size;\n        pix3 += line_size;\n    }\n    return s;\n}\n\nstatic int pix_abs8_xy2_c(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)\n{\n    int s, i;\n    uint8_t *pix3 = pix2 + line_size;\n\n    s = 0;\n    for(i=0;i<h;i++) {\n        s += abs(pix1[0] - avg4(pix2[0], pix2[1], pix3[0], pix3[1]));\n        s += abs(pix1[1] - avg4(pix2[1], pix2[2], pix3[1], pix3[2]));\n        s += abs(pix1[2] - avg4(pix2[2], pix2[3], pix3[2], pix3[3]));\n        s += abs(pix1[3] - avg4(pix2[3], pix2[4], pix3[3], pix3[4]));\n        s += abs(pix1[4] - avg4(pix2[4], pix2[5], pix3[4], pix3[5]));\n        s += abs(pix1[5] - avg4(pix2[5], pix2[6], pix3[5], pix3[6]));\n        s += abs(pix1[6] - avg4(pix2[6], pix2[7], pix3[6], pix3[7]));\n        s += abs(pix1[7] - avg4(pix2[7], pix2[8], pix3[7], pix3[8]));\n        pix1 += line_size;\n        pix2 += line_size;\n        pix3 += line_size;\n    }\n    return s;\n}\n\nstatic int nsse16_c(void *v, uint8_t *s1, uint8_t *s2, int stride, int h){\n    MpegEncContext *c = v;\n    int score1=0;\n    int score2=0;\n    int x,y;\n\n    for(y=0; y<h; y++){\n        for(x=0; x<16; x++){\n            score1+= (s1[x  ] - s2[x ])*(s1[x  ] - s2[x ]);\n        }\n        if(y+1<h){\n            for(x=0; x<15; x++){\n                score2+= FFABS(  s1[x  ] - s1[x  +stride]\n                             - s1[x+1] + s1[x+1+stride])\n                        -FFABS(  s2[x  ] - s2[x  +stride]\n                             - s2[x+1] + s2[x+1+stride]);\n            }\n        }\n        s1+= stride;\n        s2+= stride;\n    }\n\n    if(c) return score1 + FFABS(score2)*c->avctx->nsse_weight;\n    else  return score1 + FFABS(score2)*8;\n}\n\nstatic int nsse8_c(void *v, uint8_t *s1, uint8_t *s2, int stride, int h){\n    MpegEncContext *c = v;\n    int score1=0;\n    int score2=0;\n    int x,y;\n\n    for(y=0; y<h; y++){\n        for(x=0; x<8; x++){\n            score1+= (s1[x  ] - s2[x ])*(s1[x  ] - s2[x ]);\n        }\n        if(y+1<h){\n            for(x=0; x<7; x++){\n                score2+= FFABS(  s1[x  ] - s1[x  +stride]\n                             - s1[x+1] + s1[x+1+stride])\n                        -FFABS(  s2[x  ] - s2[x  +stride]\n                             - s2[x+1] + s2[x+1+stride]);\n            }\n        }\n        s1+= stride;\n        s2+= stride;\n    }\n\n    if(c) return score1 + FFABS(score2)*c->avctx->nsse_weight;\n    else  return score1 + FFABS(score2)*8;\n}\n\nstatic int try_8x8basis_c(int16_t rem[64], int16_t weight[64], int16_t basis[64], int scale){\n    int i;\n    unsigned int sum=0;\n\n    for(i=0; i<8*8; i++){\n        int b= rem[i] + ((basis[i]*scale + (1<<(BASIS_SHIFT - RECON_SHIFT-1)))>>(BASIS_SHIFT - RECON_SHIFT));\n        int w= weight[i];\n        b>>= RECON_SHIFT;\n        av_assert2(-512<b && b<512);\n\n        sum += (w*b)*(w*b)>>4;\n    }\n    return sum>>2;\n}\n\nstatic void add_8x8basis_c(int16_t rem[64], int16_t basis[64], int scale){\n    int i;\n\n    for(i=0; i<8*8; i++){\n        rem[i] += (basis[i]*scale + (1<<(BASIS_SHIFT - RECON_SHIFT-1)))>>(BASIS_SHIFT - RECON_SHIFT);\n    }\n}\n\nstatic int zero_cmp(void *s, uint8_t *a, uint8_t *b, int stride, int h){\n    return 0;\n}\n\nvoid ff_set_cmp(DSPContext* c, me_cmp_func *cmp, int type){\n    int i;\n\n    memset(cmp, 0, sizeof(void*)*6);\n\n    for(i=0; i<6; i++){\n        switch(type&0xFF){\n        case FF_CMP_SAD:\n            cmp[i]= c->sad[i];\n            break;\n        case FF_CMP_SATD:\n            cmp[i]= c->hadamard8_diff[i];\n            break;\n        case FF_CMP_SSE:\n            cmp[i]= c->sse[i];\n            break;\n        case FF_CMP_DCT:\n            cmp[i]= c->dct_sad[i];\n            break;\n        case FF_CMP_DCT264:\n            cmp[i]= c->dct264_sad[i];\n            break;\n        case FF_CMP_DCTMAX:\n            cmp[i]= c->dct_max[i];\n            break;\n        case FF_CMP_PSNR:\n            cmp[i]= c->quant_psnr[i];\n            break;\n        case FF_CMP_BIT:\n            cmp[i]= c->bit[i];\n            break;\n        case FF_CMP_RD:\n            cmp[i]= c->rd[i];\n            break;\n        case FF_CMP_VSAD:\n            cmp[i]= c->vsad[i];\n            break;\n        case FF_CMP_VSSE:\n            cmp[i]= c->vsse[i];\n            break;\n        case FF_CMP_ZERO:\n            cmp[i]= zero_cmp;\n            break;\n        case FF_CMP_NSSE:\n            cmp[i]= c->nsse[i];\n            break;\n#if CONFIG_DWT\n        case FF_CMP_W53:\n            cmp[i]= c->w53[i];\n            break;\n        case FF_CMP_W97:\n            cmp[i]= c->w97[i];\n            break;\n#endif\n        default:\n            av_log(NULL, AV_LOG_ERROR,\"internal error in cmp function selection\\n\");\n        }\n    }\n}\n\nstatic void add_bytes_c(uint8_t *dst, uint8_t *src, int w){\n    long i;\n    for(i=0; i<=w-(int)sizeof(long); i+=sizeof(long)){\n        long a = *(long*)(src+i);\n        long b = *(long*)(dst+i);\n        *(long*)(dst+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);\n    }\n    for(; i<w; i++)\n        dst[i+0] += src[i+0];\n}\n\nstatic void diff_bytes_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2, int w){\n    long i;\n#if !HAVE_FAST_UNALIGNED\n    if((long)src2 & (sizeof(long)-1)){\n        for(i=0; i+7<w; i+=8){\n            dst[i+0] = src1[i+0]-src2[i+0];\n            dst[i+1] = src1[i+1]-src2[i+1];\n            dst[i+2] = src1[i+2]-src2[i+2];\n            dst[i+3] = src1[i+3]-src2[i+3];\n            dst[i+4] = src1[i+4]-src2[i+4];\n            dst[i+5] = src1[i+5]-src2[i+5];\n            dst[i+6] = src1[i+6]-src2[i+6];\n            dst[i+7] = src1[i+7]-src2[i+7];\n        }\n    }else\n#endif\n    for(i=0; i<=w-(int)sizeof(long); i+=sizeof(long)){\n        long a = *(long*)(src1+i);\n        long b = *(long*)(src2+i);\n        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);\n    }\n    for(; i<w; i++)\n        dst[i+0] = src1[i+0]-src2[i+0];\n}\n\nstatic void add_hfyu_median_prediction_c(uint8_t *dst, const uint8_t *src1, const uint8_t *diff, int w, int *left, int *left_top){\n    int i;\n    uint8_t l, lt;\n\n    l= *left;\n    lt= *left_top;\n\n    for(i=0; i<w; i++){\n        l= mid_pred(l, src1[i], (l + src1[i] - lt)&0xFF) + diff[i];\n        lt= src1[i];\n        dst[i]= l;\n    }\n\n    *left= l;\n    *left_top= lt;\n}\n\nstatic void sub_hfyu_median_prediction_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2, int w, int *left, int *left_top){\n    int i;\n    uint8_t l, lt;\n\n    l= *left;\n    lt= *left_top;\n\n    for(i=0; i<w; i++){\n        const int pred= mid_pred(l, src1[i], (l + src1[i] - lt)&0xFF);\n        lt= src1[i];\n        l= src2[i];\n        dst[i]= l - pred;\n    }\n\n    *left= l;\n    *left_top= lt;\n}\n\nstatic int add_hfyu_left_prediction_c(uint8_t *dst, const uint8_t *src, int w, int acc){\n    int i;\n\n    for(i=0; i<w-1; i++){\n        acc+= src[i];\n        dst[i]= acc;\n        i++;\n        acc+= src[i];\n        dst[i]= acc;\n    }\n\n    for(; i<w; i++){\n        acc+= src[i];\n        dst[i]= acc;\n    }\n\n    return acc;\n}\n\n#if HAVE_BIGENDIAN\n#define B 3\n#define G 2\n#define R 1\n#define A 0\n#else\n#define B 0\n#define G 1\n#define R 2\n#define A 3\n#endif\nstatic void add_hfyu_left_prediction_bgr32_c(uint8_t *dst, const uint8_t *src, int w, int *red, int *green, int *blue, int *alpha){\n    int i;\n    int r,g,b,a;\n    r= *red;\n    g= *green;\n    b= *blue;\n    a= *alpha;\n\n    for(i=0; i<w; i++){\n        b+= src[4*i+B];\n        g+= src[4*i+G];\n        r+= src[4*i+R];\n        a+= src[4*i+A];\n\n        dst[4*i+B]= b;\n        dst[4*i+G]= g;\n        dst[4*i+R]= r;\n        dst[4*i+A]= a;\n    }\n\n    *red= r;\n    *green= g;\n    *blue= b;\n    *alpha= a;\n}\n#undef B\n#undef G\n#undef R\n#undef A\n\n#define BUTTERFLY2(o1,o2,i1,i2) \\\no1= (i1)+(i2);\\\no2= (i1)-(i2);\n\n#define BUTTERFLY1(x,y) \\\n{\\\n    int a,b;\\\n    a= x;\\\n    b= y;\\\n    x= a+b;\\\n    y= a-b;\\\n}\n\n#define BUTTERFLYA(x,y) (FFABS((x)+(y)) + FFABS((x)-(y)))\n\nstatic int hadamard8_diff8x8_c(/*MpegEncContext*/ void *s, uint8_t *dst, uint8_t *src, int stride, int h){\n    int i;\n    int temp[64];\n    int sum=0;\n\n    av_assert2(h==8);\n\n    for(i=0; i<8; i++){\n        //FIXME try pointer walks\n        BUTTERFLY2(temp[8*i+0], temp[8*i+1], src[stride*i+0]-dst[stride*i+0],src[stride*i+1]-dst[stride*i+1]);\n        BUTTERFLY2(temp[8*i+2], temp[8*i+3], src[stride*i+2]-dst[stride*i+2],src[stride*i+3]-dst[stride*i+3]);\n        BUTTERFLY2(temp[8*i+4], temp[8*i+5], src[stride*i+4]-dst[stride*i+4],src[stride*i+5]-dst[stride*i+5]);\n        BUTTERFLY2(temp[8*i+6], temp[8*i+7], src[stride*i+6]-dst[stride*i+6],src[stride*i+7]-dst[stride*i+7]);\n\n        BUTTERFLY1(temp[8*i+0], temp[8*i+2]);\n        BUTTERFLY1(temp[8*i+1], temp[8*i+3]);\n        BUTTERFLY1(temp[8*i+4], temp[8*i+6]);\n        BUTTERFLY1(temp[8*i+5], temp[8*i+7]);\n\n        BUTTERFLY1(temp[8*i+0], temp[8*i+4]);\n        BUTTERFLY1(temp[8*i+1], temp[8*i+5]);\n        BUTTERFLY1(temp[8*i+2], temp[8*i+6]);\n        BUTTERFLY1(temp[8*i+3], temp[8*i+7]);\n    }\n\n    for(i=0; i<8; i++){\n        BUTTERFLY1(temp[8*0+i], temp[8*1+i]);\n        BUTTERFLY1(temp[8*2+i], temp[8*3+i]);\n        BUTTERFLY1(temp[8*4+i], temp[8*5+i]);\n        BUTTERFLY1(temp[8*6+i], temp[8*7+i]);\n\n        BUTTERFLY1(temp[8*0+i], temp[8*2+i]);\n        BUTTERFLY1(temp[8*1+i], temp[8*3+i]);\n        BUTTERFLY1(temp[8*4+i], temp[8*6+i]);\n        BUTTERFLY1(temp[8*5+i], temp[8*7+i]);\n\n        sum +=\n             BUTTERFLYA(temp[8*0+i], temp[8*4+i])\n            +BUTTERFLYA(temp[8*1+i], temp[8*5+i])\n            +BUTTERFLYA(temp[8*2+i], temp[8*6+i])\n            +BUTTERFLYA(temp[8*3+i], temp[8*7+i]);\n    }\n    return sum;\n}\n\nstatic int hadamard8_intra8x8_c(/*MpegEncContext*/ void *s, uint8_t *src, uint8_t *dummy, int stride, int h){\n    int i;\n    int temp[64];\n    int sum=0;\n\n    av_assert2(h==8);\n\n    for(i=0; i<8; i++){\n        //FIXME try pointer walks\n        BUTTERFLY2(temp[8*i+0], temp[8*i+1], src[stride*i+0],src[stride*i+1]);\n        BUTTERFLY2(temp[8*i+2], temp[8*i+3], src[stride*i+2],src[stride*i+3]);\n        BUTTERFLY2(temp[8*i+4], temp[8*i+5], src[stride*i+4],src[stride*i+5]);\n        BUTTERFLY2(temp[8*i+6], temp[8*i+7], src[stride*i+6],src[stride*i+7]);\n\n        BUTTERFLY1(temp[8*i+0], temp[8*i+2]);\n        BUTTERFLY1(temp[8*i+1], temp[8*i+3]);\n        BUTTERFLY1(temp[8*i+4], temp[8*i+6]);\n        BUTTERFLY1(temp[8*i+5], temp[8*i+7]);\n\n        BUTTERFLY1(temp[8*i+0], temp[8*i+4]);\n        BUTTERFLY1(temp[8*i+1], temp[8*i+5]);\n        BUTTERFLY1(temp[8*i+2], temp[8*i+6]);\n        BUTTERFLY1(temp[8*i+3], temp[8*i+7]);\n    }\n\n    for(i=0; i<8; i++){\n        BUTTERFLY1(temp[8*0+i], temp[8*1+i]);\n        BUTTERFLY1(temp[8*2+i], temp[8*3+i]);\n        BUTTERFLY1(temp[8*4+i], temp[8*5+i]);\n        BUTTERFLY1(temp[8*6+i], temp[8*7+i]);\n\n        BUTTERFLY1(temp[8*0+i], temp[8*2+i]);\n        BUTTERFLY1(temp[8*1+i], temp[8*3+i]);\n        BUTTERFLY1(temp[8*4+i], temp[8*6+i]);\n        BUTTERFLY1(temp[8*5+i], temp[8*7+i]);\n\n        sum +=\n             BUTTERFLYA(temp[8*0+i], temp[8*4+i])\n            +BUTTERFLYA(temp[8*1+i], temp[8*5+i])\n            +BUTTERFLYA(temp[8*2+i], temp[8*6+i])\n            +BUTTERFLYA(temp[8*3+i], temp[8*7+i]);\n    }\n\n    sum -= FFABS(temp[8*0] + temp[8*4]); // -mean\n\n    return sum;\n}\n\nstatic int dct_sad8x8_c(/*MpegEncContext*/ void *c, uint8_t *src1, uint8_t *src2, int stride, int h){\n    MpegEncContext * const s= (MpegEncContext *)c;\n    LOCAL_ALIGNED_16(int16_t, temp, [64]);\n\n    av_assert2(h==8);\n\n    s->dsp.diff_pixels(temp, src1, src2, stride);\n    s->dsp.fdct(temp);\n    return s->dsp.sum_abs_dctelem(temp);\n}\n\n#if CONFIG_GPL\n#define DCT8_1D {\\\n    const int s07 = SRC(0) + SRC(7);\\\n    const int s16 = SRC(1) + SRC(6);\\\n    const int s25 = SRC(2) + SRC(5);\\\n    const int s34 = SRC(3) + SRC(4);\\\n    const int a0 = s07 + s34;\\\n    const int a1 = s16 + s25;\\\n    const int a2 = s07 - s34;\\\n    const int a3 = s16 - s25;\\\n    const int d07 = SRC(0) - SRC(7);\\\n    const int d16 = SRC(1) - SRC(6);\\\n    const int d25 = SRC(2) - SRC(5);\\\n    const int d34 = SRC(3) - SRC(4);\\\n    const int a4 = d16 + d25 + (d07 + (d07>>1));\\\n    const int a5 = d07 - d34 - (d25 + (d25>>1));\\\n    const int a6 = d07 + d34 - (d16 + (d16>>1));\\\n    const int a7 = d16 - d25 + (d34 + (d34>>1));\\\n    DST(0,  a0 + a1     ) ;\\\n    DST(1,  a4 + (a7>>2)) ;\\\n    DST(2,  a2 + (a3>>1)) ;\\\n    DST(3,  a5 + (a6>>2)) ;\\\n    DST(4,  a0 - a1     ) ;\\\n    DST(5,  a6 - (a5>>2)) ;\\\n    DST(6, (a2>>1) - a3 ) ;\\\n    DST(7, (a4>>2) - a7 ) ;\\\n}\n\nstatic int dct264_sad8x8_c(/*MpegEncContext*/ void *c, uint8_t *src1, uint8_t *src2, int stride, int h){\n    MpegEncContext * const s= (MpegEncContext *)c;\n    int16_t dct[8][8];\n    int i;\n    int sum=0;\n\n    s->dsp.diff_pixels(dct[0], src1, src2, stride);\n\n#define SRC(x) dct[i][x]\n#define DST(x,v) dct[i][x]= v\n    for( i = 0; i < 8; i++ )\n        DCT8_1D\n#undef SRC\n#undef DST\n\n#define SRC(x) dct[x][i]\n#define DST(x,v) sum += FFABS(v)\n    for( i = 0; i < 8; i++ )\n        DCT8_1D\n#undef SRC\n#undef DST\n    return sum;\n}\n#endif\n\nstatic int dct_max8x8_c(/*MpegEncContext*/ void *c, uint8_t *src1, uint8_t *src2, int stride, int h){\n    MpegEncContext * const s= (MpegEncContext *)c;\n    LOCAL_ALIGNED_16(int16_t, temp, [64]);\n    int sum=0, i;\n\n    av_assert2(h==8);\n\n    s->dsp.diff_pixels(temp, src1, src2, stride);\n    s->dsp.fdct(temp);\n\n    for(i=0; i<64; i++)\n        sum= FFMAX(sum, FFABS(temp[i]));\n\n    return sum;\n}\n\nstatic int quant_psnr8x8_c(/*MpegEncContext*/ void *c, uint8_t *src1, uint8_t *src2, int stride, int h){\n    MpegEncContext * const s= (MpegEncContext *)c;\n    LOCAL_ALIGNED_16(int16_t, temp, [64*2]);\n    int16_t * const bak = temp+64;\n    int sum=0, i;\n\n    av_assert2(h==8);\n    s->mb_intra=0;\n\n    s->dsp.diff_pixels(temp, src1, src2, stride);\n\n    memcpy(bak, temp, 64*sizeof(int16_t));\n\n    s->block_last_index[0/*FIXME*/]= s->fast_dct_quantize(s, temp, 0/*FIXME*/, s->qscale, &i);\n    s->dct_unquantize_inter(s, temp, 0, s->qscale);\n    ff_simple_idct_8(temp); //FIXME\n\n    for(i=0; i<64; i++)\n        sum+= (temp[i]-bak[i])*(temp[i]-bak[i]);\n\n    return sum;\n}\n\nstatic int rd8x8_c(/*MpegEncContext*/ void *c, uint8_t *src1, uint8_t *src2, int stride, int h){\n    MpegEncContext * const s= (MpegEncContext *)c;\n    const uint8_t *scantable= s->intra_scantable.permutated;\n    LOCAL_ALIGNED_16(int16_t, temp, [64]);\n    LOCAL_ALIGNED_16(uint8_t, lsrc1, [64]);\n    LOCAL_ALIGNED_16(uint8_t, lsrc2, [64]);\n    int i, last, run, bits, level, distortion, start_i;\n    const int esc_length= s->ac_esc_length;\n    uint8_t * length;\n    uint8_t * last_length;\n\n    av_assert2(h==8);\n\n    copy_block8(lsrc1, src1, 8, stride, 8);\n    copy_block8(lsrc2, src2, 8, stride, 8);\n\n    s->dsp.diff_pixels(temp, lsrc1, lsrc2, 8);\n\n    s->block_last_index[0/*FIXME*/]= last= s->fast_dct_quantize(s, temp, 0/*FIXME*/, s->qscale, &i);\n\n    bits=0;\n\n    if (s->mb_intra) {\n        start_i = 1;\n        length     = s->intra_ac_vlc_length;\n        last_length= s->intra_ac_vlc_last_length;\n        bits+= s->luma_dc_vlc_length[temp[0] + 256]; //FIXME chroma\n    } else {\n        start_i = 0;\n        length     = s->inter_ac_vlc_length;\n        last_length= s->inter_ac_vlc_last_length;\n    }\n\n    if(last>=start_i){\n        run=0;\n        for(i=start_i; i<last; i++){\n            int j= scantable[i];\n            level= temp[j];\n\n            if(level){\n                level+=64;\n                if((level&(~127)) == 0){\n                    bits+= length[UNI_AC_ENC_INDEX(run, level)];\n                }else\n                    bits+= esc_length;\n                run=0;\n            }else\n                run++;\n        }\n        i= scantable[last];\n\n        level= temp[i] + 64;\n\n        av_assert2(level - 64);\n\n        if((level&(~127)) == 0){\n            bits+= last_length[UNI_AC_ENC_INDEX(run, level)];\n        }else\n            bits+= esc_length;\n\n    }\n\n    if(last>=0){\n        if(s->mb_intra)\n            s->dct_unquantize_intra(s, temp, 0, s->qscale);\n        else\n            s->dct_unquantize_inter(s, temp, 0, s->qscale);\n    }\n\n    s->dsp.idct_add(lsrc2, 8, temp);\n\n    distortion= s->dsp.sse[1](NULL, lsrc2, lsrc1, 8, 8);\n\n    return distortion + ((bits*s->qscale*s->qscale*109 + 64)>>7);\n}\n\nstatic int bit8x8_c(/*MpegEncContext*/ void *c, uint8_t *src1, uint8_t *src2, int stride, int h){\n    MpegEncContext * const s= (MpegEncContext *)c;\n    const uint8_t *scantable= s->intra_scantable.permutated;\n    LOCAL_ALIGNED_16(int16_t, temp, [64]);\n    int i, last, run, bits, level, start_i;\n    const int esc_length= s->ac_esc_length;\n    uint8_t * length;\n    uint8_t * last_length;\n\n    av_assert2(h==8);\n\n    s->dsp.diff_pixels(temp, src1, src2, stride);\n\n    s->block_last_index[0/*FIXME*/]= last= s->fast_dct_quantize(s, temp, 0/*FIXME*/, s->qscale, &i);\n\n    bits=0;\n\n    if (s->mb_intra) {\n        start_i = 1;\n        length     = s->intra_ac_vlc_length;\n        last_length= s->intra_ac_vlc_last_length;\n        bits+= s->luma_dc_vlc_length[temp[0] + 256]; //FIXME chroma\n    } else {\n        start_i = 0;\n        length     = s->inter_ac_vlc_length;\n        last_length= s->inter_ac_vlc_last_length;\n    }\n\n    if(last>=start_i){\n        run=0;\n        for(i=start_i; i<last; i++){\n            int j= scantable[i];\n            level= temp[j];\n\n            if(level){\n                level+=64;\n                if((level&(~127)) == 0){\n                    bits+= length[UNI_AC_ENC_INDEX(run, level)];\n                }else\n                    bits+= esc_length;\n                run=0;\n            }else\n                run++;\n        }\n        i= scantable[last];\n\n        level= temp[i] + 64;\n\n        av_assert2(level - 64);\n\n        if((level&(~127)) == 0){\n            bits+= last_length[UNI_AC_ENC_INDEX(run, level)];\n        }else\n            bits+= esc_length;\n    }\n\n    return bits;\n}\n\n#define VSAD_INTRA(size) \\\nstatic int vsad_intra##size##_c(/*MpegEncContext*/ void *c, uint8_t *s, uint8_t *dummy, int stride, int h){ \\\n    int score=0;                                                                                            \\\n    int x,y;                                                                                                \\\n                                                                                                            \\\n    for(y=1; y<h; y++){                                                                                     \\\n        for(x=0; x<size; x+=4){                                                                             \\\n            score+= FFABS(s[x  ] - s[x  +stride]) + FFABS(s[x+1] - s[x+1+stride])                           \\\n                   +FFABS(s[x+2] - s[x+2+stride]) + FFABS(s[x+3] - s[x+3+stride]);                          \\\n        }                                                                                                   \\\n        s+= stride;                                                                                         \\\n    }                                                                                                       \\\n                                                                                                            \\\n    return score;                                                                                           \\\n}\nVSAD_INTRA(8)\nVSAD_INTRA(16)\n\nstatic int vsad16_c(/*MpegEncContext*/ void *c, uint8_t *s1, uint8_t *s2, int stride, int h){\n    int score=0;\n    int x,y;\n\n    for(y=1; y<h; y++){\n        for(x=0; x<16; x++){\n            score+= FFABS(s1[x  ] - s2[x ] - s1[x  +stride] + s2[x +stride]);\n        }\n        s1+= stride;\n        s2+= stride;\n    }\n\n    return score;\n}\n\n#define SQ(a) ((a)*(a))\n#define VSSE_INTRA(size) \\\nstatic int vsse_intra##size##_c(/*MpegEncContext*/ void *c, uint8_t *s, uint8_t *dummy, int stride, int h){ \\\n    int score=0;                                                                                            \\\n    int x,y;                                                                                                \\\n                                                                                                            \\\n    for(y=1; y<h; y++){                                                                                     \\\n        for(x=0; x<size; x+=4){                                                                               \\\n            score+= SQ(s[x  ] - s[x  +stride]) + SQ(s[x+1] - s[x+1+stride])                                 \\\n                   +SQ(s[x+2] - s[x+2+stride]) + SQ(s[x+3] - s[x+3+stride]);                                \\\n        }                                                                                                   \\\n        s+= stride;                                                                                         \\\n    }                                                                                                       \\\n                                                                                                            \\\n    return score;                                                                                           \\\n}\nVSSE_INTRA(8)\nVSSE_INTRA(16)\n\nstatic int vsse16_c(/*MpegEncContext*/ void *c, uint8_t *s1, uint8_t *s2, int stride, int h){\n    int score=0;\n    int x,y;\n\n    for(y=1; y<h; y++){\n        for(x=0; x<16; x++){\n            score+= SQ(s1[x  ] - s2[x ] - s1[x  +stride] + s2[x +stride]);\n        }\n        s1+= stride;\n        s2+= stride;\n    }\n\n    return score;\n}\n\nstatic int ssd_int8_vs_int16_c(const int8_t *pix1, const int16_t *pix2,\n                               int size){\n    int score=0;\n    int i;\n    for(i=0; i<size; i++)\n        score += (pix1[i]-pix2[i])*(pix1[i]-pix2[i]);\n    return score;\n}\n\n#define WRAPPER8_16_SQ(name8, name16)\\\nstatic int name16(void /*MpegEncContext*/ *s, uint8_t *dst, uint8_t *src, int stride, int h){\\\n    int score=0;\\\n    score +=name8(s, dst           , src           , stride, 8);\\\n    score +=name8(s, dst+8         , src+8         , stride, 8);\\\n    if(h==16){\\\n        dst += 8*stride;\\\n        src += 8*stride;\\\n        score +=name8(s, dst           , src           , stride, 8);\\\n        score +=name8(s, dst+8         , src+8         , stride, 8);\\\n    }\\\n    return score;\\\n}\n\nWRAPPER8_16_SQ(hadamard8_diff8x8_c, hadamard8_diff16_c)\nWRAPPER8_16_SQ(hadamard8_intra8x8_c, hadamard8_intra16_c)\nWRAPPER8_16_SQ(dct_sad8x8_c, dct_sad16_c)\n#if CONFIG_GPL\nWRAPPER8_16_SQ(dct264_sad8x8_c, dct264_sad16_c)\n#endif\nWRAPPER8_16_SQ(dct_max8x8_c, dct_max16_c)\nWRAPPER8_16_SQ(quant_psnr8x8_c, quant_psnr16_c)\nWRAPPER8_16_SQ(rd8x8_c, rd16_c)\nWRAPPER8_16_SQ(bit8x8_c, bit16_c)\n\nstatic inline uint32_t clipf_c_one(uint32_t a, uint32_t mini,\n                   uint32_t maxi, uint32_t maxisign)\n{\n\n    if(a > mini) return mini;\n    else if((a^(1U<<31)) > maxisign) return maxi;\n    else return a;\n}\n\nstatic void vector_clipf_c_opposite_sign(float *dst, const float *src, float *min, float *max, int len){\n    int i;\n    uint32_t mini = *(uint32_t*)min;\n    uint32_t maxi = *(uint32_t*)max;\n    uint32_t maxisign = maxi ^ (1U<<31);\n    uint32_t *dsti = (uint32_t*)dst;\n    const uint32_t *srci = (const uint32_t*)src;\n    for(i=0; i<len; i+=8) {\n        dsti[i + 0] = clipf_c_one(srci[i + 0], mini, maxi, maxisign);\n        dsti[i + 1] = clipf_c_one(srci[i + 1], mini, maxi, maxisign);\n        dsti[i + 2] = clipf_c_one(srci[i + 2], mini, maxi, maxisign);\n        dsti[i + 3] = clipf_c_one(srci[i + 3], mini, maxi, maxisign);\n        dsti[i + 4] = clipf_c_one(srci[i + 4], mini, maxi, maxisign);\n        dsti[i + 5] = clipf_c_one(srci[i + 5], mini, maxi, maxisign);\n        dsti[i + 6] = clipf_c_one(srci[i + 6], mini, maxi, maxisign);\n        dsti[i + 7] = clipf_c_one(srci[i + 7], mini, maxi, maxisign);\n    }\n}\nstatic void vector_clipf_c(float *dst, const float *src, float min, float max, int len){\n    int i;\n    if(min < 0 && max > 0) {\n        vector_clipf_c_opposite_sign(dst, src, &min, &max, len);\n    } else {\n        for(i=0; i < len; i+=8) {\n            dst[i    ] = av_clipf(src[i    ], min, max);\n            dst[i + 1] = av_clipf(src[i + 1], min, max);\n            dst[i + 2] = av_clipf(src[i + 2], min, max);\n            dst[i + 3] = av_clipf(src[i + 3], min, max);\n            dst[i + 4] = av_clipf(src[i + 4], min, max);\n            dst[i + 5] = av_clipf(src[i + 5], min, max);\n            dst[i + 6] = av_clipf(src[i + 6], min, max);\n            dst[i + 7] = av_clipf(src[i + 7], min, max);\n        }\n    }\n}\n\nstatic int32_t scalarproduct_int16_c(const int16_t * v1, const int16_t * v2, int order)\n{\n    int res = 0;\n\n    while (order--)\n        res += *v1++ * *v2++;\n\n    return res;\n}\n\nstatic int32_t scalarproduct_and_madd_int16_c(int16_t *v1, const int16_t *v2, const int16_t *v3, int order, int mul)\n{\n    int res = 0;\n    while (order--) {\n        res   += *v1 * *v2++;\n        *v1++ += mul * *v3++;\n    }\n    return res;\n}\n\nstatic void apply_window_int16_c(int16_t *output, const int16_t *input,\n                                 const int16_t *window, unsigned int len)\n{\n    int i;\n    int len2 = len >> 1;\n\n    for (i = 0; i < len2; i++) {\n        int16_t w       = window[i];\n        output[i]       = (MUL16(input[i],       w) + (1 << 14)) >> 15;\n        output[len-i-1] = (MUL16(input[len-i-1], w) + (1 << 14)) >> 15;\n    }\n}\n\nstatic void vector_clip_int32_c(int32_t *dst, const int32_t *src, int32_t min,\n                                int32_t max, unsigned int len)\n{\n    do {\n        *dst++ = av_clip(*src++, min, max);\n        *dst++ = av_clip(*src++, min, max);\n        *dst++ = av_clip(*src++, min, max);\n        *dst++ = av_clip(*src++, min, max);\n        *dst++ = av_clip(*src++, min, max);\n        *dst++ = av_clip(*src++, min, max);\n        *dst++ = av_clip(*src++, min, max);\n        *dst++ = av_clip(*src++, min, max);\n        len -= 8;\n    } while (len > 0);\n}\n\nstatic void jref_idct_put(uint8_t *dest, int line_size, int16_t *block)\n{\n    ff_j_rev_dct (block);\n    put_pixels_clamped_c(block, dest, line_size);\n}\nstatic void jref_idct_add(uint8_t *dest, int line_size, int16_t *block)\n{\n    ff_j_rev_dct (block);\n    add_pixels_clamped_c(block, dest, line_size);\n}\n\nstatic void ff_jref_idct4_put(uint8_t *dest, int line_size, int16_t *block)\n{\n    ff_j_rev_dct4 (block);\n    put_pixels_clamped4_c(block, dest, line_size);\n}\nstatic void ff_jref_idct4_add(uint8_t *dest, int line_size, int16_t *block)\n{\n    ff_j_rev_dct4 (block);\n    add_pixels_clamped4_c(block, dest, line_size);\n}\n\nstatic void ff_jref_idct2_put(uint8_t *dest, int line_size, int16_t *block)\n{\n    ff_j_rev_dct2 (block);\n    put_pixels_clamped2_c(block, dest, line_size);\n}\nstatic void ff_jref_idct2_add(uint8_t *dest, int line_size, int16_t *block)\n{\n    ff_j_rev_dct2 (block);\n    add_pixels_clamped2_c(block, dest, line_size);\n}\n\nstatic void ff_jref_idct1_put(uint8_t *dest, int line_size, int16_t *block)\n{\n    dest[0] = av_clip_uint8((block[0] + 4)>>3);\n}\nstatic void ff_jref_idct1_add(uint8_t *dest, int line_size, int16_t *block)\n{\n    dest[0] = av_clip_uint8(dest[0] + ((block[0] + 4)>>3));\n}\n\n/* init static data */\nav_cold void ff_dsputil_static_init(void)\n{\n    int i;\n\n    for(i=0;i<512;i++) {\n        ff_squareTbl[i] = (i - 256) * (i - 256);\n    }\n\n    for(i=0; i<64; i++) ff_inv_zigzag_direct16[ff_zigzag_direct[i]]= i+1;\n}\n\nint ff_check_alignment(void){\n    static int did_fail=0;\n    LOCAL_ALIGNED_16(int, aligned, [4]);\n\n    if((intptr_t)aligned & 15){\n        if(!did_fail){\n#if HAVE_MMX || HAVE_ALTIVEC\n            av_log(NULL, AV_LOG_ERROR,\n                \"Compiler did not align stack variables. Libavcodec has been miscompiled\\n\"\n                \"and may be very slow or crash. This is not a bug in libavcodec,\\n\"\n                \"but in the compiler. You may try recompiling using gcc >= 4.2.\\n\"\n                \"Do not report crashes to FFmpeg developers.\\n\");\n#endif\n            did_fail=1;\n        }\n        return -1;\n    }\n    return 0;\n}\n\nav_cold void ff_dsputil_init(DSPContext* c, AVCodecContext *avctx)\n{\n    ff_check_alignment();\n\n#if CONFIG_ENCODERS\n    if (avctx->bits_per_raw_sample == 10) {\n        c->fdct    = ff_jpeg_fdct_islow_10;\n        c->fdct248 = ff_fdct248_islow_10;\n    } else {\n        if(avctx->dct_algo==FF_DCT_FASTINT) {\n            c->fdct    = ff_fdct_ifast;\n            c->fdct248 = ff_fdct_ifast248;\n        }\n        else if(avctx->dct_algo==FF_DCT_FAAN) {\n            c->fdct    = ff_faandct;\n            c->fdct248 = ff_faandct248;\n        }\n        else {\n            c->fdct    = ff_jpeg_fdct_islow_8; //slow/accurate/default\n            c->fdct248 = ff_fdct248_islow_8;\n        }\n    }\n#endif //CONFIG_ENCODERS\n\n    if(avctx->lowres==1){\n        c->idct_put= ff_jref_idct4_put;\n        c->idct_add= ff_jref_idct4_add;\n        c->idct    = ff_j_rev_dct4;\n        c->idct_permutation_type= FF_NO_IDCT_PERM;\n    }else if(avctx->lowres==2){\n        c->idct_put= ff_jref_idct2_put;\n        c->idct_add= ff_jref_idct2_add;\n        c->idct    = ff_j_rev_dct2;\n        c->idct_permutation_type= FF_NO_IDCT_PERM;\n    }else if(avctx->lowres==3){\n        c->idct_put= ff_jref_idct1_put;\n        c->idct_add= ff_jref_idct1_add;\n        c->idct    = ff_j_rev_dct1;\n        c->idct_permutation_type= FF_NO_IDCT_PERM;\n    }else{\n        if (avctx->bits_per_raw_sample == 10) {\n            c->idct_put              = ff_simple_idct_put_10;\n            c->idct_add              = ff_simple_idct_add_10;\n            c->idct                  = ff_simple_idct_10;\n            c->idct_permutation_type = FF_NO_IDCT_PERM;\n        } else {\n        if(avctx->idct_algo==FF_IDCT_INT){\n            c->idct_put= jref_idct_put;\n            c->idct_add= jref_idct_add;\n            c->idct    = ff_j_rev_dct;\n            c->idct_permutation_type= FF_LIBMPEG2_IDCT_PERM;\n        }else if(avctx->idct_algo==FF_IDCT_FAAN){\n            c->idct_put= ff_faanidct_put;\n            c->idct_add= ff_faanidct_add;\n            c->idct    = ff_faanidct;\n            c->idct_permutation_type= FF_NO_IDCT_PERM;\n        }else{ //accurate/default\n            c->idct_put = ff_simple_idct_put_8;\n            c->idct_add = ff_simple_idct_add_8;\n            c->idct     = ff_simple_idct_8;\n            c->idct_permutation_type= FF_NO_IDCT_PERM;\n        }\n        }\n    }\n\n    c->diff_pixels = diff_pixels_c;\n    c->put_pixels_clamped = put_pixels_clamped_c;\n    c->put_signed_pixels_clamped = put_signed_pixels_clamped_c;\n    c->add_pixels_clamped = add_pixels_clamped_c;\n    c->sum_abs_dctelem = sum_abs_dctelem_c;\n    c->gmc1 = gmc1_c;\n    c->gmc = ff_gmc_c;\n    c->pix_sum = pix_sum_c;\n    c->pix_norm1 = pix_norm1_c;\n\n    c->fill_block_tab[0] = fill_block16_c;\n    c->fill_block_tab[1] = fill_block8_c;\n\n    /* TODO [0] 16  [1] 8 */\n    c->pix_abs[0][0] = pix_abs16_c;\n    c->pix_abs[0][1] = pix_abs16_x2_c;\n    c->pix_abs[0][2] = pix_abs16_y2_c;\n    c->pix_abs[0][3] = pix_abs16_xy2_c;\n    c->pix_abs[1][0] = pix_abs8_c;\n    c->pix_abs[1][1] = pix_abs8_x2_c;\n    c->pix_abs[1][2] = pix_abs8_y2_c;\n    c->pix_abs[1][3] = pix_abs8_xy2_c;\n\n    c->put_tpel_pixels_tab[ 0] = put_tpel_pixels_mc00_c;\n    c->put_tpel_pixels_tab[ 1] = put_tpel_pixels_mc10_c;\n    c->put_tpel_pixels_tab[ 2] = put_tpel_pixels_mc20_c;\n    c->put_tpel_pixels_tab[ 4] = put_tpel_pixels_mc01_c;\n    c->put_tpel_pixels_tab[ 5] = put_tpel_pixels_mc11_c;\n    c->put_tpel_pixels_tab[ 6] = put_tpel_pixels_mc21_c;\n    c->put_tpel_pixels_tab[ 8] = put_tpel_pixels_mc02_c;\n    c->put_tpel_pixels_tab[ 9] = put_tpel_pixels_mc12_c;\n    c->put_tpel_pixels_tab[10] = put_tpel_pixels_mc22_c;\n\n    c->avg_tpel_pixels_tab[ 0] = avg_tpel_pixels_mc00_c;\n    c->avg_tpel_pixels_tab[ 1] = avg_tpel_pixels_mc10_c;\n    c->avg_tpel_pixels_tab[ 2] = avg_tpel_pixels_mc20_c;\n    c->avg_tpel_pixels_tab[ 4] = avg_tpel_pixels_mc01_c;\n    c->avg_tpel_pixels_tab[ 5] = avg_tpel_pixels_mc11_c;\n    c->avg_tpel_pixels_tab[ 6] = avg_tpel_pixels_mc21_c;\n    c->avg_tpel_pixels_tab[ 8] = avg_tpel_pixels_mc02_c;\n    c->avg_tpel_pixels_tab[ 9] = avg_tpel_pixels_mc12_c;\n    c->avg_tpel_pixels_tab[10] = avg_tpel_pixels_mc22_c;\n\n#define dspfunc(PFX, IDX, NUM) \\\n    c->PFX ## _pixels_tab[IDX][ 0] = PFX ## NUM ## _mc00_c; \\\n    c->PFX ## _pixels_tab[IDX][ 1] = PFX ## NUM ## _mc10_c; \\\n    c->PFX ## _pixels_tab[IDX][ 2] = PFX ## NUM ## _mc20_c; \\\n    c->PFX ## _pixels_tab[IDX][ 3] = PFX ## NUM ## _mc30_c; \\\n    c->PFX ## _pixels_tab[IDX][ 4] = PFX ## NUM ## _mc01_c; \\\n    c->PFX ## _pixels_tab[IDX][ 5] = PFX ## NUM ## _mc11_c; \\\n    c->PFX ## _pixels_tab[IDX][ 6] = PFX ## NUM ## _mc21_c; \\\n    c->PFX ## _pixels_tab[IDX][ 7] = PFX ## NUM ## _mc31_c; \\\n    c->PFX ## _pixels_tab[IDX][ 8] = PFX ## NUM ## _mc02_c; \\\n    c->PFX ## _pixels_tab[IDX][ 9] = PFX ## NUM ## _mc12_c; \\\n    c->PFX ## _pixels_tab[IDX][10] = PFX ## NUM ## _mc22_c; \\\n    c->PFX ## _pixels_tab[IDX][11] = PFX ## NUM ## _mc32_c; \\\n    c->PFX ## _pixels_tab[IDX][12] = PFX ## NUM ## _mc03_c; \\\n    c->PFX ## _pixels_tab[IDX][13] = PFX ## NUM ## _mc13_c; \\\n    c->PFX ## _pixels_tab[IDX][14] = PFX ## NUM ## _mc23_c; \\\n    c->PFX ## _pixels_tab[IDX][15] = PFX ## NUM ## _mc33_c\n\n    dspfunc(put_qpel, 0, 16);\n    dspfunc(put_no_rnd_qpel, 0, 16);\n\n    dspfunc(avg_qpel, 0, 16);\n    /* dspfunc(avg_no_rnd_qpel, 0, 16); */\n\n    dspfunc(put_qpel, 1, 8);\n    dspfunc(put_no_rnd_qpel, 1, 8);\n\n    dspfunc(avg_qpel, 1, 8);\n    /* dspfunc(avg_no_rnd_qpel, 1, 8); */\n\n#undef dspfunc\n\n    c->put_mspel_pixels_tab[0]= ff_put_pixels8x8_c;\n    c->put_mspel_pixels_tab[1]= put_mspel8_mc10_c;\n    c->put_mspel_pixels_tab[2]= put_mspel8_mc20_c;\n    c->put_mspel_pixels_tab[3]= put_mspel8_mc30_c;\n    c->put_mspel_pixels_tab[4]= put_mspel8_mc02_c;\n    c->put_mspel_pixels_tab[5]= put_mspel8_mc12_c;\n    c->put_mspel_pixels_tab[6]= put_mspel8_mc22_c;\n    c->put_mspel_pixels_tab[7]= put_mspel8_mc32_c;\n\n#define SET_CMP_FUNC(name) \\\n    c->name[0]= name ## 16_c;\\\n    c->name[1]= name ## 8x8_c;\n\n    SET_CMP_FUNC(hadamard8_diff)\n    c->hadamard8_diff[4]= hadamard8_intra16_c;\n    c->hadamard8_diff[5]= hadamard8_intra8x8_c;\n    SET_CMP_FUNC(dct_sad)\n    SET_CMP_FUNC(dct_max)\n#if CONFIG_GPL\n    SET_CMP_FUNC(dct264_sad)\n#endif\n    c->sad[0]= pix_abs16_c;\n    c->sad[1]= pix_abs8_c;\n    c->sse[0]= sse16_c;\n    c->sse[1]= sse8_c;\n    c->sse[2]= sse4_c;\n    SET_CMP_FUNC(quant_psnr)\n    SET_CMP_FUNC(rd)\n    SET_CMP_FUNC(bit)\n    c->vsad[0]= vsad16_c;\n    c->vsad[4]= vsad_intra16_c;\n    c->vsad[5]= vsad_intra8_c;\n    c->vsse[0]= vsse16_c;\n    c->vsse[4]= vsse_intra16_c;\n    c->vsse[5]= vsse_intra8_c;\n    c->nsse[0]= nsse16_c;\n    c->nsse[1]= nsse8_c;\n#if CONFIG_SNOW_DECODER || CONFIG_SNOW_ENCODER\n    ff_dsputil_init_dwt(c);\n#endif\n\n    c->ssd_int8_vs_int16 = ssd_int8_vs_int16_c;\n\n    c->add_bytes= add_bytes_c;\n    c->diff_bytes= diff_bytes_c;\n    c->add_hfyu_median_prediction= add_hfyu_median_prediction_c;\n    c->sub_hfyu_median_prediction= sub_hfyu_median_prediction_c;\n    c->add_hfyu_left_prediction  = add_hfyu_left_prediction_c;\n    c->add_hfyu_left_prediction_bgr32 = add_hfyu_left_prediction_bgr32_c;\n    c->bswap_buf= bswap_buf;\n    c->bswap16_buf = bswap16_buf;\n\n    if (CONFIG_H263_DECODER || CONFIG_H263_ENCODER) {\n        c->h263_h_loop_filter= h263_h_loop_filter_c;\n        c->h263_v_loop_filter= h263_v_loop_filter_c;\n    }\n\n    c->try_8x8basis= try_8x8basis_c;\n    c->add_8x8basis= add_8x8basis_c;\n\n    c->vector_clipf = vector_clipf_c;\n    c->scalarproduct_int16 = scalarproduct_int16_c;\n    c->scalarproduct_and_madd_int16 = scalarproduct_and_madd_int16_c;\n    c->apply_window_int16 = apply_window_int16_c;\n    c->vector_clip_int32 = vector_clip_int32_c;\n\n    c->shrink[0]= av_image_copy_plane;\n    c->shrink[1]= ff_shrink22;\n    c->shrink[2]= ff_shrink44;\n    c->shrink[3]= ff_shrink88;\n\n    c->add_pixels8 = add_pixels8_c;\n\n#undef FUNC\n#undef FUNCC\n#define FUNC(f, depth) f ## _ ## depth\n#define FUNCC(f, depth) f ## _ ## depth ## _c\n\n    c->draw_edges                    = FUNCC(draw_edges, 8);\n    c->clear_block                   = FUNCC(clear_block, 8);\n    c->clear_blocks                  = FUNCC(clear_blocks, 8);\n\n#define BIT_DEPTH_FUNCS(depth) \\\n    c->get_pixels                    = FUNCC(get_pixels,   depth);\n\n    switch (avctx->bits_per_raw_sample) {\n    case 9:\n    case 10:\n    case 12:\n    case 14:\n        BIT_DEPTH_FUNCS(16);\n        break;\n    default:\n        if(avctx->bits_per_raw_sample<=8 || avctx->codec_type != AVMEDIA_TYPE_VIDEO) {\n            BIT_DEPTH_FUNCS(8);\n        }\n        break;\n    }\n\n\n    if (ARCH_ALPHA)\n        ff_dsputil_init_alpha(c, avctx);\n    if (ARCH_ARM)\n        ff_dsputil_init_arm(c, avctx);\n    if (ARCH_BFIN)\n        ff_dsputil_init_bfin(c, avctx);\n    if (ARCH_PPC)\n        ff_dsputil_init_ppc(c, avctx);\n    if (ARCH_SH4)\n        ff_dsputil_init_sh4(c, avctx);\n    if (HAVE_VIS)\n        ff_dsputil_init_vis(c, avctx);\n    if (ARCH_X86)\n        ff_dsputil_init_x86(c, avctx);\n\n    ff_init_scantable_permutation(c->idct_permutation,\n                                  c->idct_permutation_type);\n}\n\nav_cold void dsputil_init(DSPContext* c, AVCodecContext *avctx)\n{\n    ff_dsputil_init(c, avctx);\n}\n\nav_cold void avpriv_dsputil_init(DSPContext *c, AVCodecContext *avctx)\n{\n    ff_dsputil_init(c, avctx);\n}\n"], "filenames": ["libavcodec/dsputil.c"], "buggy_code_start_loc": [1934], "buggy_code_end_loc": [1960], "fixing_code_start_loc": [1934], "fixing_code_end_loc": [1960], "type": "CWE-189", "message": "Multiple integer signedness errors in libavcodec/dsputil.c in FFmpeg before 2.1 allow remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted data.", "other": {"cve": {"id": "CVE-2013-7010", "sourceIdentifier": "cve@mitre.org", "published": "2013-12-09T16:36:48.020", "lastModified": "2016-12-03T03:00:35.657", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Multiple integer signedness errors in libavcodec/dsputil.c in FFmpeg before 2.1 allow remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted data."}, {"lang": "es", "value": "M\u00faltiples errores de signo de enteros en libavcodec/dsputil.c en FFmpeg  anterior a v2.1 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (acceso a array fuera de rango) o posiblemente tener otro impacto no especificado a trav\u00e9s de informaci\u00f3n manipulada."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-189"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.0.1", "matchCriteriaId": "C41A1983-BA74-4806-A227-EBBF7989112C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3:*:*:*:*:*:*:*", "matchCriteriaId": "B2649A80-4739-4BBB-AB0B-99AD435BE7CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "D4A2E77D-B826-4B49-ADC8-7F704E149A5A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "18157837-4550-45E3-A12E-AE06E047E253"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "E9F42611-C3E2-416B-9AE7-A5AE83E4DEF7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "3A20789F-26E3-4871-B24E-25E922BADDF0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "67C6C243-3ACC-49C3-80CA-D7CA8FEFF0D8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "6AE6D368-0BA6-4499-B7E1-EE16C03012E9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "26C0F6EF-0452-4AFE-AF3E-B88F963A0938"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "5B4DD372-4D3B-445C-8C38-E083A3C0D4A7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "733C03D7-2780-4D69-A98D-BCFB91D1119A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "0AEE1977-E9E0-4BFF-B33B-B083E49E51F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "E6979C17-0BC6-47D1-9B73-254D84306A96"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "204C7C05-3441-4DB0-8702-D99C8FCB381E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.9:pre1:*:*:*:*:*:*", "matchCriteriaId": "2E1A7011-B992-4E35-B306-45772DACB23C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5:*:*:*:*:*:*:*", "matchCriteriaId": "8D486C17-FC4A-4AEE-A430-1B1FBCC2C27C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "632BC7C2-FE59-47B0-885C-0EB8C74DF041"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "5D1AE0BF-A6FD-4EBA-BF61-07AC81EA560D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "5B8FA106-FE65-4BB0-92A7-E8A5AF978A9B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "514669DA-8D02-44CE-BE18-8783F69AE394"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "8041E6ED-472A-40DF-AA90-F3509D90D47A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "D2C64382-9259-4D61-B352-7F123527289C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "32A152D9-947E-4198-9C2D-2A582F09AB75"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6:*:*:*:*:*:*:*", "matchCriteriaId": "37FBB817-A186-4517-9DA7-B3638576AAE7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "157ABA40-6101-4E9C-A24C-84F8E23D374D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "C7EA46DD-2CC4-426F-8709-821B7572C94A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "3DE12C59-4409-4F7A-9759-7B26FA9DAC34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7:*:*:*:*:*:*:*", "matchCriteriaId": "30FE6578-F031-4F5B-B955-8F912CFCA1B0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "07669E0E-8C4B-430E-802F-F64EEA2B5A0B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "F3EB7F17-F25D-4E48-8A43-F799619CE71F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.3:*:*:*:*:*:*:*", "matchCriteriaId": "60705A3B-7136-45D1-8068-E2DC9E01EB04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "C722B143-2648-4EB2-A090-7B788F41F300"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.5:*:*:*:*:*:*:*", "matchCriteriaId": "B31AFDBC-A782-4C18-8EAA-6D927397BEA3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.6:*:*:*:*:*:*:*", "matchCriteriaId": "73E9E8F4-A942-4F34-BCE2-82A180F1DD1F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.7:*:*:*:*:*:*:*", "matchCriteriaId": "AAA31D75-C3FB-4D89-8B2D-21372AAEB78B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.8:*:*:*:*:*:*:*", "matchCriteriaId": "B20E5358-826C-47A2-B39F-ED4E9213BA95"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.9:*:*:*:*:*:*:*", "matchCriteriaId": "26321888-E140-4F09-AAA0-7392AA7F6307"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.11:*:*:*:*:*:*:*", "matchCriteriaId": "7E46B9F3-A9C0-4B8A-A119-40CA4CBBD0EE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.12:*:*:*:*:*:*:*", "matchCriteriaId": "44800572-71C5-4AA1-9CB6-30AA902B0353"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "87090477-1D36-48B3-88AE-5CD5EE8F89D7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "2096FF8B-9B57-4C59-84DB-9CC0DEAB47AC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "34C99254-776C-4AAD-BDA2-3F544256AA67"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "CE9D7B73-9CDA-4BAE-8DD9-8E1E34C20648"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "4FDBF2C0-8E33-4575-8A19-4F1CABA3023F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "72040664-077A-48FB-9E6B-B69EA8D26CB4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "F428A2E4-A54F-4296-A00F-1A4E160253D7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.7:*:*:*:*:*:*:*", "matchCriteriaId": "5239E4FA-0359-49F1-93D4-24AB013FAC20"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.8:*:*:*:*:*:*:*", "matchCriteriaId": "F0C8230D-4E89-45F9-B0F7-E317119E0FA0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.10:*:*:*:*:*:*:*", "matchCriteriaId": "585CE7D2-1CE8-44AB-AE67-07D7D3721F68"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.11:*:*:*:*:*:*:*", "matchCriteriaId": "EE81C339-A794-4303-B829-BE743DF0B132"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.9:*:*:*:*:*:*:*", "matchCriteriaId": "5CE0A27B-66D7-4D1B-8E6A-F4722C070BD3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "864DC4A2-A378-4389-B62E-9E785879A744"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.10:*:*:*:*:*:*:*", "matchCriteriaId": "16304267-C808-4B6B-9903-2DEAB40AD899"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "CEEBBA83-1BFC-45A8-B34A-AB3A9B8A9414"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.10.4:*:*:*:*:*:*:*", "matchCriteriaId": "F559B34E-23EE-4E09-A044-E7F54C55B05E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.11:*:*:*:*:*:*:*", "matchCriteriaId": "62BA2708-BE77-42B7-B51A-C1B58632462C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "23E57BB1-DF1E-4173-BE52-72E2B3E6BA23"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "A3E30DB1-0CFC-4EAA-BF07-CE7551ABDCB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "DBA7D745-DC16-43B9-8A2D-4D6944A6BFD0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "87A511A5-2040-433A-9B32-B89332214FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "0C01DD9C-98C9-4896-8D66-A8336582298B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.2:*:*:*:*:*:*:*", "matchCriteriaId": "BBE7723A-3D6B-4390-B82E-6A5A6992141A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "1ED8FF93-5AA7-443C-BBDB-845736BB337B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:2.0:*:*:*:*:*:*:*", "matchCriteriaId": "A1337F5B-E9D9-4335-9E05-50018E59E530"}]}]}], "references": [{"url": "http://ffmpeg.org/security.html", "source": "cve@mitre.org"}, {"url": "http://git.libav.org/?p=libav.git;a=blob;f=Changelog;hb=refs/tags/v9.11", "source": "cve@mitre.org"}, {"url": "http://openwall.com/lists/oss-security/2013/11/26/7", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://openwall.com/lists/oss-security/2013/12/08/3", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://www.debian.org/security/2014/dsa-2855", "source": "cve@mitre.org"}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/454a11a1c9c686c78aa97954306fb63453299760", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}, {"url": "https://security.gentoo.org/glsa/201603-06", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/454a11a1c9c686c78aa97954306fb63453299760"}}