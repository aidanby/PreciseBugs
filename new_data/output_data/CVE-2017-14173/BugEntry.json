{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            TTTTT  X   X  TTTTT                              %\n%                              T     X X     T                                %\n%                              T      X      T                                %\n%                              T     X X     T                                %\n%                              T    X   X    T                                %\n%                                                                             %\n%                                                                             %\n%                      Render Text Onto A Canvas Image.                       %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/annotate.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteTXTImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s T X T                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsTXT() returns MagickTrue if the image format type, identified by the magick\n%  string, is TXT.\n%\n%  The format of the IsTXT method is:\n%\n%      MagickBooleanType IsTXT(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsTXT(const unsigned char *magick,const size_t length)\n{\n#define MagickID  \"# ImageMagick pixel enumeration:\"\n\n  char\n    colorspace[MagickPathExtent];\n\n  ssize_t\n    count;\n\n  unsigned long\n    columns,\n    depth,\n    rows;\n\n  if (length < 40)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick,MagickID,strlen(MagickID)) != 0)\n    return(MagickFalse);\n  count=(ssize_t) sscanf((const char *) magick+32,\"%lu,%lu,%lu,%s\",&columns,\n    &rows,&depth,colorspace);\n  if (count != 4)\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d T E X T I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadTEXTImage() reads a text file and returns it as an image.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadTEXTImage method is:\n%\n%      Image *ReadTEXTImage(const ImageInfo *image_info,Image *image,\n%        char *text,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the image.\n%\n%    o text: the text storage buffer.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadTEXTImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent],\n    geometry[MagickPathExtent],\n    *p,\n    text[MagickPathExtent];\n\n  DrawInfo\n    *draw_info;\n\n  Image\n    *image,\n    *texture;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    delta;\n\n  RectangleInfo\n    page;\n\n  ssize_t\n    offset;\n\n  TypeMetric\n    metrics;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) ResetMagickMemory(text,0,sizeof(text));\n  (void) ReadBlobString(image,text);\n  /*\n    Set the page geometry.\n  */\n  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  page.width=612;\n  page.height=792;\n  page.x=43;\n  page.y=43;\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  /*\n    Initialize Image structure.\n  */\n  image->columns=(size_t) floor((((double) page.width*image->resolution.x)/\n    delta.x)+0.5);\n  image->rows=(size_t) floor((((double) page.height*image->resolution.y)/\n    delta.y)+0.5);\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  image->page.x=0;\n  image->page.y=0;\n  texture=(Image *) NULL;\n  if (image_info->texture != (char *) NULL)\n    {\n      ImageInfo\n        *read_info;\n\n      read_info=CloneImageInfo(image_info);\n      SetImageInfoBlob(read_info,(void *) NULL,0);\n      (void) CopyMagickString(read_info->filename,image_info->texture,\n        MagickPathExtent);\n      texture=ReadImage(read_info,exception);\n      read_info=DestroyImageInfo(read_info);\n    }\n  /*\n    Annotate the text image.\n  */\n  (void) SetImageBackgroundColor(image,exception);\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  (void) CloneString(&draw_info->text,image_info->filename);\n  (void) FormatLocaleString(geometry,MagickPathExtent,\"%gx%g%+g%+g\",(double)\n    image->columns,(double) image->rows,(double) page.x,(double) page.y);\n  (void) CloneString(&draw_info->geometry,geometry);\n  status=GetTypeMetrics(image,draw_info,&metrics,exception);\n  if (status == MagickFalse)\n    ThrowReaderException(TypeError,\"UnableToGetTypeMetrics\");\n  page.y=(ssize_t) ceil((double) page.y+metrics.ascent-0.5);\n  (void) FormatLocaleString(geometry,MagickPathExtent,\"%gx%g%+g%+g\",(double)\n    image->columns,(double) image->rows,(double) page.x,(double) page.y);\n  (void) CloneString(&draw_info->geometry,geometry);\n  (void) CopyMagickString(filename,image_info->filename,MagickPathExtent);\n  if (*draw_info->text != '\\0')\n    *draw_info->text='\\0';\n  p=text;\n  for (offset=2*page.y; p != (char *) NULL; )\n  {\n    /*\n      Annotate image with text.\n    */\n    (void) ConcatenateString(&draw_info->text,text);\n    (void) ConcatenateString(&draw_info->text,\"\\n\");\n    offset+=(ssize_t) (metrics.ascent-metrics.descent);\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) offset,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n    p=ReadBlobString(image,text);\n    if ((offset < (ssize_t) image->rows) && (p != (char *) NULL))\n      continue;\n    if (texture != (Image *) NULL)\n      {\n        MagickProgressMonitor\n          progress_monitor;\n\n        progress_monitor=SetImageProgressMonitor(image,\n          (MagickProgressMonitor) NULL,image->client_data);\n        (void) TextureImage(image,texture,exception);\n        (void) SetImageProgressMonitor(image,progress_monitor,\n          image->client_data);\n      }\n    (void) AnnotateImage(image,draw_info,exception);\n    if (p == (char *) NULL)\n      break;\n    /*\n      Page is full-- allocate next image structure.\n    */\n    *draw_info->text='\\0';\n    offset=2*page.y;\n    AcquireNextImage(image_info,image,exception);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    image->next->columns=image->columns;\n    image->next->rows=image->rows;\n    image=SyncNextImageInList(image);\n    (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n    (void) SetImageBackgroundColor(image,exception);\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      GetBlobSize(image));\n    if (status == MagickFalse)\n      break;\n  }\n  if (texture != (Image *) NULL)\n    {\n      MagickProgressMonitor\n        progress_monitor;\n\n      progress_monitor=SetImageProgressMonitor(image,\n        (MagickProgressMonitor) NULL,image->client_data);\n      (void) TextureImage(image,texture,exception);\n      (void) SetImageProgressMonitor(image,progress_monitor,image->client_data);\n    }\n  (void) AnnotateImage(image,draw_info,exception);\n  if (texture != (Image *) NULL)\n    texture=DestroyImage(texture);\n  draw_info=DestroyDrawInfo(draw_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d T X T I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadTXTImage() reads a text file and returns it as an image.  It allocates\n%  the memory necessary for the new Image structure and returns a pointer to\n%  the new image.\n%\n%  The format of the ReadTXTImage method is:\n%\n%      Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    colorspace[MagickPathExtent],\n    text[MagickPathExtent];\n\n  Image\n    *image;\n\n  long\n    x_offset,\n    y_offset;\n\n  PixelInfo\n    pixel;\n\n  MagickBooleanType\n    status;\n\n  QuantumAny\n    range;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    count,\n    type,\n    y;\n\n  unsigned long\n    depth,\n    height,\n    max_value,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) ResetMagickMemory(text,0,sizeof(text));\n  (void) ReadBlobString(image,text);\n  if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    width=0;\n    height=0;\n    max_value=0;\n    *colorspace='\\0';\n    count=(ssize_t) sscanf(text+32,\"%lu,%lu,%lu,%s\",&width,&height,&max_value,\n      colorspace);\n    if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    image->columns=width;\n    image->rows=height;\n    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ;\n    image->depth=depth;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    LocaleLower(colorspace);\n    i=(ssize_t) strlen(colorspace)-1;\n    image->alpha_trait=UndefinedPixelTrait;\n    if ((i > 0) && (colorspace[i] == 'a'))\n      {\n        colorspace[i]='\\0';\n        image->alpha_trait=BlendPixelTrait;\n      }\n    type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);\n    if (type < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    (void) SetImageBackgroundColor(image,exception);\n    (void) SetImageColorspace(image,(ColorspaceType) type,exception);\n    GetPixelInfo(image,&pixel);\n    range=GetQuantumRange(image->depth);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      double\n        alpha,\n        black,\n        blue,\n        green,\n        red;\n\n      red=0.0;\n      green=0.0;\n      blue=0.0;\n      black=0.0;\n      alpha=0.0;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        if (ReadBlobString(image,text) == (char *) NULL)\n          break;\n        switch (image->colorspace)\n        {\n          case GRAYColorspace:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\"%ld,%ld: (%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&alpha);\n                green=red;\n                blue=red;\n                break;\n              }\n            count=(ssize_t) sscanf(text,\"%ld,%ld: (%lf%*[%,]\",&x_offset,\n              &y_offset,&red);\n            green=red;\n            blue=red;\n            break;       \n          }\n          case CMYKColorspace:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&black,&alpha);\n                break;\n              }\n            count=(ssize_t) sscanf(text,\n              \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue,&black);\n            break;\n          }\n          default:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&alpha);\n                break;\n              }\n            count=(ssize_t) sscanf(text,\n              \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue);\n            break;       \n          }\n        }\n        if (strchr(text,'%') != (char *) NULL)\n          {\n            red*=0.01*range;\n            green*=0.01*range;\n            blue*=0.01*range;\n            black*=0.01*range;\n            alpha*=0.01*range;\n          }\n        if (image->colorspace == LabColorspace)\n          {\n            green+=(range+1)/2.0;\n            blue+=(range+1)/2.0;\n          }\n        pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),\n          range);\n        pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),\n          range);\n        pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),\n          range);\n        pixel.black=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (black+0.5),\n          range);\n        pixel.alpha=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (alpha+0.5),\n          range);\n        q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          continue;\n        SetPixelViaPixelInfo(image,&pixel,q);\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n    }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    (void) ReadBlobString(image,text);\n    if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r T X T I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterTXTImage() adds attributes for the TXT image format to the\n%  list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterTXTImage method is:\n%\n%      size_t RegisterTXTImage(void)\n%\n*/\nModuleExport size_t RegisterTXTImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"TXT\",\"SPARSE-COLOR\",\"Sparse Color\");\n  entry->encoder=(EncodeImageHandler *) WriteTXTImage;\n  entry->flags|=CoderRawSupportFlag;\n  entry->flags|=CoderEndianSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TXT\",\"TEXT\",\"Text\");\n  entry->decoder=(DecodeImageHandler *) ReadTEXTImage;\n  entry->format_type=ImplicitFormatType;\n  entry->flags|=CoderRawSupportFlag;\n  entry->flags|=CoderEndianSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TXT\",\"TXT\",\"Text\");\n  entry->decoder=(DecodeImageHandler *) ReadTXTImage;\n  entry->encoder=(EncodeImageHandler *) WriteTXTImage;\n  entry->magick=(IsImageFormatHandler *) IsTXT;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r T X T I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterTXTImage() removes format registrations made by the\n%  TXT module from the list of supported format.\n%\n%  The format of the UnregisterTXTImage method is:\n%\n%      UnregisterTXTImage(void)\n%\n*/\nModuleExport void UnregisterTXTImage(void)\n{\n  (void) UnregisterMagickInfo(\"SPARSE-COLOR\");\n  (void) UnregisterMagickInfo(\"TEXT\");\n  (void) UnregisterMagickInfo(\"TXT\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e T X T I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteTXTImage writes the pixel values as text numbers.\n%\n%  The format of the WriteTXTImage method is:\n%\n%      MagickBooleanType WriteTXTImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteTXTImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    buffer[MagickPathExtent],\n    colorspace[MagickPathExtent],\n    tuple[MagickPathExtent];\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  PixelInfo\n    pixel;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    y;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  scene=0;\n  do\n  {\n    ComplianceType\n      compliance;\n\n    const char\n      *value;\n\n    (void) CopyMagickString(colorspace,CommandOptionToMnemonic(\n      MagickColorspaceOptions,(ssize_t) image->colorspace),MagickPathExtent);\n    LocaleLower(colorspace);\n    image->depth=GetImageQuantumDepth(image,MagickTrue);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      (void) ConcatenateMagickString(colorspace,\"a\",MagickPathExtent);\n    compliance=NoCompliance;\n    value=GetImageOption(image_info,\"txt:compliance\");\n    if (value != (char *) NULL)\n      compliance=(ComplianceType) ParseCommandOption(MagickComplianceOptions,\n        MagickFalse,value);\n    if (LocaleCompare(image_info->magick,\"SPARSE-COLOR\") != 0)\n      {\n        size_t\n          depth;\n\n        depth=compliance == SVGCompliance ? image->depth :\n          MAGICKCORE_QUANTUM_DEPTH;\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"# ImageMagick pixel enumeration: %.20g,%.20g,%.20g,%s\\n\",(double)\n          image->columns,(double) image->rows,(double) ((MagickOffsetType)\n          GetQuantumRange(depth)),colorspace);\n        (void) WriteBlobString(image,buffer);\n      }\n    GetPixelInfo(image,&pixel);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        GetPixelInfoPixel(image,p,&pixel);\n        if (pixel.colorspace == LabColorspace)\n          {\n            pixel.green-=(QuantumRange+1)/2.0;\n            pixel.blue-=(QuantumRange+1)/2.0;\n          }\n        if (LocaleCompare(image_info->magick,\"SPARSE-COLOR\") == 0)\n          {\n            /*\n              Sparse-color format.\n            */\n            if (GetPixelAlpha(image,p) == (Quantum) OpaqueAlpha)\n              {\n                GetColorTuple(&pixel,MagickFalse,tuple);\n                (void) FormatLocaleString(buffer,MagickPathExtent,\n                  \"%.20g,%.20g,\",(double) x,(double) y);\n                (void) WriteBlobString(image,buffer);\n                (void) WriteBlobString(image,tuple);\n                (void) WriteBlobString(image,\" \");\n              }\n            p+=GetPixelChannels(image);\n            continue;\n          }\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g,%.20g: \",\n          (double) x,(double) y);\n        (void) WriteBlobString(image,buffer);\n        (void) CopyMagickString(tuple,\"(\",MagickPathExtent);\n        if (pixel.colorspace == GRAYColorspace)\n          ConcatenateColorComponent(&pixel,GrayPixelChannel,compliance,tuple);\n        else\n          {\n            ConcatenateColorComponent(&pixel,RedPixelChannel,compliance,tuple);\n            (void) ConcatenateMagickString(tuple,\",\",MagickPathExtent);\n            ConcatenateColorComponent(&pixel,GreenPixelChannel,compliance,\n              tuple);\n            (void) ConcatenateMagickString(tuple,\",\",MagickPathExtent);\n            ConcatenateColorComponent(&pixel,BluePixelChannel,compliance,tuple);\n          }\n        if (pixel.colorspace == CMYKColorspace)\n          {\n            (void) ConcatenateMagickString(tuple,\",\",MagickPathExtent);\n            ConcatenateColorComponent(&pixel,BlackPixelChannel,compliance,\n              tuple);\n          }\n        if (pixel.alpha_trait != UndefinedPixelTrait)\n          {\n            (void) ConcatenateMagickString(tuple,\",\",MagickPathExtent);\n            ConcatenateColorComponent(&pixel,AlphaPixelChannel,compliance,\n              tuple);\n          }\n        (void) ConcatenateMagickString(tuple,\")\",MagickPathExtent);\n        (void) WriteBlobString(image,tuple);\n        (void) WriteBlobString(image,\"  \");\n        GetColorTuple(&pixel,MagickTrue,tuple);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%s\",tuple);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\"  \");\n        (void) QueryColorname(image,&pixel,SVGCompliance,tuple,exception);\n        (void) WriteBlobString(image,tuple);\n        (void) WriteBlobString(image,\"\\n\");\n        p+=GetPixelChannels(image);\n      }\n      status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n        image->rows);\n      if (status == MagickFalse)\n        break;\n    }\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            TTTTT  X   X  TTTTT                              %\n%                              T     X X     T                                %\n%                              T      X      T                                %\n%                              T     X X     T                                %\n%                              T    X   X    T                                %\n%                                                                             %\n%                                                                             %\n%                      Render Text Onto A Canvas Image.                       %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/annotate.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteTXTImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s T X T                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsTXT() returns MagickTrue if the image format type, identified by the magick\n%  string, is TXT.\n%\n%  The format of the IsTXT method is:\n%\n%      MagickBooleanType IsTXT(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsTXT(const unsigned char *magick,const size_t length)\n{\n#define MagickID  \"# ImageMagick pixel enumeration:\"\n\n  char\n    colorspace[MagickPathExtent];\n\n  ssize_t\n    count;\n\n  unsigned long\n    columns,\n    depth,\n    rows;\n\n  if (length < 40)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick,MagickID,strlen(MagickID)) != 0)\n    return(MagickFalse);\n  count=(ssize_t) sscanf((const char *) magick+32,\"%lu,%lu,%lu,%s\",&columns,\n    &rows,&depth,colorspace);\n  if (count != 4)\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d T E X T I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadTEXTImage() reads a text file and returns it as an image.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadTEXTImage method is:\n%\n%      Image *ReadTEXTImage(const ImageInfo *image_info,Image *image,\n%        char *text,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the image.\n%\n%    o text: the text storage buffer.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadTEXTImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent],\n    geometry[MagickPathExtent],\n    *p,\n    text[MagickPathExtent];\n\n  DrawInfo\n    *draw_info;\n\n  Image\n    *image,\n    *texture;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    delta;\n\n  RectangleInfo\n    page;\n\n  ssize_t\n    offset;\n\n  TypeMetric\n    metrics;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) ResetMagickMemory(text,0,sizeof(text));\n  (void) ReadBlobString(image,text);\n  /*\n    Set the page geometry.\n  */\n  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  page.width=612;\n  page.height=792;\n  page.x=43;\n  page.y=43;\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  /*\n    Initialize Image structure.\n  */\n  image->columns=(size_t) floor((((double) page.width*image->resolution.x)/\n    delta.x)+0.5);\n  image->rows=(size_t) floor((((double) page.height*image->resolution.y)/\n    delta.y)+0.5);\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  image->page.x=0;\n  image->page.y=0;\n  texture=(Image *) NULL;\n  if (image_info->texture != (char *) NULL)\n    {\n      ImageInfo\n        *read_info;\n\n      read_info=CloneImageInfo(image_info);\n      SetImageInfoBlob(read_info,(void *) NULL,0);\n      (void) CopyMagickString(read_info->filename,image_info->texture,\n        MagickPathExtent);\n      texture=ReadImage(read_info,exception);\n      read_info=DestroyImageInfo(read_info);\n    }\n  /*\n    Annotate the text image.\n  */\n  (void) SetImageBackgroundColor(image,exception);\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  (void) CloneString(&draw_info->text,image_info->filename);\n  (void) FormatLocaleString(geometry,MagickPathExtent,\"%gx%g%+g%+g\",(double)\n    image->columns,(double) image->rows,(double) page.x,(double) page.y);\n  (void) CloneString(&draw_info->geometry,geometry);\n  status=GetTypeMetrics(image,draw_info,&metrics,exception);\n  if (status == MagickFalse)\n    ThrowReaderException(TypeError,\"UnableToGetTypeMetrics\");\n  page.y=(ssize_t) ceil((double) page.y+metrics.ascent-0.5);\n  (void) FormatLocaleString(geometry,MagickPathExtent,\"%gx%g%+g%+g\",(double)\n    image->columns,(double) image->rows,(double) page.x,(double) page.y);\n  (void) CloneString(&draw_info->geometry,geometry);\n  (void) CopyMagickString(filename,image_info->filename,MagickPathExtent);\n  if (*draw_info->text != '\\0')\n    *draw_info->text='\\0';\n  p=text;\n  for (offset=2*page.y; p != (char *) NULL; )\n  {\n    /*\n      Annotate image with text.\n    */\n    (void) ConcatenateString(&draw_info->text,text);\n    (void) ConcatenateString(&draw_info->text,\"\\n\");\n    offset+=(ssize_t) (metrics.ascent-metrics.descent);\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) offset,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n    p=ReadBlobString(image,text);\n    if ((offset < (ssize_t) image->rows) && (p != (char *) NULL))\n      continue;\n    if (texture != (Image *) NULL)\n      {\n        MagickProgressMonitor\n          progress_monitor;\n\n        progress_monitor=SetImageProgressMonitor(image,\n          (MagickProgressMonitor) NULL,image->client_data);\n        (void) TextureImage(image,texture,exception);\n        (void) SetImageProgressMonitor(image,progress_monitor,\n          image->client_data);\n      }\n    (void) AnnotateImage(image,draw_info,exception);\n    if (p == (char *) NULL)\n      break;\n    /*\n      Page is full-- allocate next image structure.\n    */\n    *draw_info->text='\\0';\n    offset=2*page.y;\n    AcquireNextImage(image_info,image,exception);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    image->next->columns=image->columns;\n    image->next->rows=image->rows;\n    image=SyncNextImageInList(image);\n    (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n    (void) SetImageBackgroundColor(image,exception);\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      GetBlobSize(image));\n    if (status == MagickFalse)\n      break;\n  }\n  if (texture != (Image *) NULL)\n    {\n      MagickProgressMonitor\n        progress_monitor;\n\n      progress_monitor=SetImageProgressMonitor(image,\n        (MagickProgressMonitor) NULL,image->client_data);\n      (void) TextureImage(image,texture,exception);\n      (void) SetImageProgressMonitor(image,progress_monitor,image->client_data);\n    }\n  (void) AnnotateImage(image,draw_info,exception);\n  if (texture != (Image *) NULL)\n    texture=DestroyImage(texture);\n  draw_info=DestroyDrawInfo(draw_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d T X T I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadTXTImage() reads a text file and returns it as an image.  It allocates\n%  the memory necessary for the new Image structure and returns a pointer to\n%  the new image.\n%\n%  The format of the ReadTXTImage method is:\n%\n%      Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    colorspace[MagickPathExtent],\n    text[MagickPathExtent];\n\n  Image\n    *image;\n\n  long\n    x_offset,\n    y_offset;\n\n  PixelInfo\n    pixel;\n\n  MagickBooleanType\n    status;\n\n  QuantumAny\n    range;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    count,\n    type,\n    y;\n\n  unsigned long\n    depth,\n    height,\n    max_value,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) ResetMagickMemory(text,0,sizeof(text));\n  (void) ReadBlobString(image,text);\n  if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    width=0;\n    height=0;\n    max_value=0;\n    *colorspace='\\0';\n    count=(ssize_t) sscanf(text+32,\"%lu,%lu,%lu,%s\",&width,&height,&max_value,\n      colorspace);\n    if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    image->columns=width;\n    image->rows=height;\n    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++)\n      if (depth >= 64)\n        break;\n    image->depth=depth;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    LocaleLower(colorspace);\n    i=(ssize_t) strlen(colorspace)-1;\n    image->alpha_trait=UndefinedPixelTrait;\n    if ((i > 0) && (colorspace[i] == 'a'))\n      {\n        colorspace[i]='\\0';\n        image->alpha_trait=BlendPixelTrait;\n      }\n    type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);\n    if (type < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    (void) SetImageBackgroundColor(image,exception);\n    (void) SetImageColorspace(image,(ColorspaceType) type,exception);\n    GetPixelInfo(image,&pixel);\n    range=GetQuantumRange(image->depth);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      double\n        alpha,\n        black,\n        blue,\n        green,\n        red;\n\n      red=0.0;\n      green=0.0;\n      blue=0.0;\n      black=0.0;\n      alpha=0.0;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        if (ReadBlobString(image,text) == (char *) NULL)\n          break;\n        switch (image->colorspace)\n        {\n          case GRAYColorspace:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\"%ld,%ld: (%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&alpha);\n                green=red;\n                blue=red;\n                break;\n              }\n            count=(ssize_t) sscanf(text,\"%ld,%ld: (%lf%*[%,]\",&x_offset,\n              &y_offset,&red);\n            green=red;\n            blue=red;\n            break;       \n          }\n          case CMYKColorspace:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&black,&alpha);\n                break;\n              }\n            count=(ssize_t) sscanf(text,\n              \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue,&black);\n            break;\n          }\n          default:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&alpha);\n                break;\n              }\n            count=(ssize_t) sscanf(text,\n              \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue);\n            break;       \n          }\n        }\n        if (strchr(text,'%') != (char *) NULL)\n          {\n            red*=0.01*range;\n            green*=0.01*range;\n            blue*=0.01*range;\n            black*=0.01*range;\n            alpha*=0.01*range;\n          }\n        if (image->colorspace == LabColorspace)\n          {\n            green+=(range+1)/2.0;\n            blue+=(range+1)/2.0;\n          }\n        pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),\n          range);\n        pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),\n          range);\n        pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),\n          range);\n        pixel.black=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (black+0.5),\n          range);\n        pixel.alpha=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (alpha+0.5),\n          range);\n        q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          continue;\n        SetPixelViaPixelInfo(image,&pixel,q);\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n    }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    (void) ReadBlobString(image,text);\n    if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r T X T I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterTXTImage() adds attributes for the TXT image format to the\n%  list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterTXTImage method is:\n%\n%      size_t RegisterTXTImage(void)\n%\n*/\nModuleExport size_t RegisterTXTImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"TXT\",\"SPARSE-COLOR\",\"Sparse Color\");\n  entry->encoder=(EncodeImageHandler *) WriteTXTImage;\n  entry->flags|=CoderRawSupportFlag;\n  entry->flags|=CoderEndianSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TXT\",\"TEXT\",\"Text\");\n  entry->decoder=(DecodeImageHandler *) ReadTEXTImage;\n  entry->format_type=ImplicitFormatType;\n  entry->flags|=CoderRawSupportFlag;\n  entry->flags|=CoderEndianSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TXT\",\"TXT\",\"Text\");\n  entry->decoder=(DecodeImageHandler *) ReadTXTImage;\n  entry->encoder=(EncodeImageHandler *) WriteTXTImage;\n  entry->magick=(IsImageFormatHandler *) IsTXT;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r T X T I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterTXTImage() removes format registrations made by the\n%  TXT module from the list of supported format.\n%\n%  The format of the UnregisterTXTImage method is:\n%\n%      UnregisterTXTImage(void)\n%\n*/\nModuleExport void UnregisterTXTImage(void)\n{\n  (void) UnregisterMagickInfo(\"SPARSE-COLOR\");\n  (void) UnregisterMagickInfo(\"TEXT\");\n  (void) UnregisterMagickInfo(\"TXT\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e T X T I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteTXTImage writes the pixel values as text numbers.\n%\n%  The format of the WriteTXTImage method is:\n%\n%      MagickBooleanType WriteTXTImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteTXTImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    buffer[MagickPathExtent],\n    colorspace[MagickPathExtent],\n    tuple[MagickPathExtent];\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  PixelInfo\n    pixel;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    y;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  scene=0;\n  do\n  {\n    ComplianceType\n      compliance;\n\n    const char\n      *value;\n\n    (void) CopyMagickString(colorspace,CommandOptionToMnemonic(\n      MagickColorspaceOptions,(ssize_t) image->colorspace),MagickPathExtent);\n    LocaleLower(colorspace);\n    image->depth=GetImageQuantumDepth(image,MagickTrue);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      (void) ConcatenateMagickString(colorspace,\"a\",MagickPathExtent);\n    compliance=NoCompliance;\n    value=GetImageOption(image_info,\"txt:compliance\");\n    if (value != (char *) NULL)\n      compliance=(ComplianceType) ParseCommandOption(MagickComplianceOptions,\n        MagickFalse,value);\n    if (LocaleCompare(image_info->magick,\"SPARSE-COLOR\") != 0)\n      {\n        size_t\n          depth;\n\n        depth=compliance == SVGCompliance ? image->depth :\n          MAGICKCORE_QUANTUM_DEPTH;\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"# ImageMagick pixel enumeration: %.20g,%.20g,%.20g,%s\\n\",(double)\n          image->columns,(double) image->rows,(double) ((MagickOffsetType)\n          GetQuantumRange(depth)),colorspace);\n        (void) WriteBlobString(image,buffer);\n      }\n    GetPixelInfo(image,&pixel);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        GetPixelInfoPixel(image,p,&pixel);\n        if (pixel.colorspace == LabColorspace)\n          {\n            pixel.green-=(QuantumRange+1)/2.0;\n            pixel.blue-=(QuantumRange+1)/2.0;\n          }\n        if (LocaleCompare(image_info->magick,\"SPARSE-COLOR\") == 0)\n          {\n            /*\n              Sparse-color format.\n            */\n            if (GetPixelAlpha(image,p) == (Quantum) OpaqueAlpha)\n              {\n                GetColorTuple(&pixel,MagickFalse,tuple);\n                (void) FormatLocaleString(buffer,MagickPathExtent,\n                  \"%.20g,%.20g,\",(double) x,(double) y);\n                (void) WriteBlobString(image,buffer);\n                (void) WriteBlobString(image,tuple);\n                (void) WriteBlobString(image,\" \");\n              }\n            p+=GetPixelChannels(image);\n            continue;\n          }\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g,%.20g: \",\n          (double) x,(double) y);\n        (void) WriteBlobString(image,buffer);\n        (void) CopyMagickString(tuple,\"(\",MagickPathExtent);\n        if (pixel.colorspace == GRAYColorspace)\n          ConcatenateColorComponent(&pixel,GrayPixelChannel,compliance,tuple);\n        else\n          {\n            ConcatenateColorComponent(&pixel,RedPixelChannel,compliance,tuple);\n            (void) ConcatenateMagickString(tuple,\",\",MagickPathExtent);\n            ConcatenateColorComponent(&pixel,GreenPixelChannel,compliance,\n              tuple);\n            (void) ConcatenateMagickString(tuple,\",\",MagickPathExtent);\n            ConcatenateColorComponent(&pixel,BluePixelChannel,compliance,tuple);\n          }\n        if (pixel.colorspace == CMYKColorspace)\n          {\n            (void) ConcatenateMagickString(tuple,\",\",MagickPathExtent);\n            ConcatenateColorComponent(&pixel,BlackPixelChannel,compliance,\n              tuple);\n          }\n        if (pixel.alpha_trait != UndefinedPixelTrait)\n          {\n            (void) ConcatenateMagickString(tuple,\",\",MagickPathExtent);\n            ConcatenateColorComponent(&pixel,AlphaPixelChannel,compliance,\n              tuple);\n          }\n        (void) ConcatenateMagickString(tuple,\")\",MagickPathExtent);\n        (void) WriteBlobString(image,tuple);\n        (void) WriteBlobString(image,\"  \");\n        GetColorTuple(&pixel,MagickTrue,tuple);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%s\",tuple);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\"  \");\n        (void) QueryColorname(image,&pixel,SVGCompliance,tuple,exception);\n        (void) WriteBlobString(image,tuple);\n        (void) WriteBlobString(image,\"\\n\");\n        p+=GetPixelChannels(image);\n      }\n      status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n        image->rows);\n      if (status == MagickFalse)\n        break;\n    }\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "filenames": ["coders/txt.c"], "buggy_code_start_loc": [454], "buggy_code_end_loc": [455], "fixing_code_start_loc": [454], "fixing_code_end_loc": [457], "type": "CWE-190", "message": "In the function ReadTXTImage() in coders/txt.c in ImageMagick 7.0.6-10, an integer overflow might occur for the addition operation \"GetQuantumRange(depth)+1\" when \"depth\" is large, producing a smaller value than expected. As a result, an infinite loop would occur for a crafted TXT file that claims a very large \"max_value\" value.", "other": {"cve": {"id": "CVE-2017-14173", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-07T06:29:00.360", "lastModified": "2020-10-15T16:07:06.090", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the function ReadTXTImage() in coders/txt.c in ImageMagick 7.0.6-10, an integer overflow might occur for the addition operation \"GetQuantumRange(depth)+1\" when \"depth\" is large, producing a smaller value than expected. As a result, an infinite loop would occur for a crafted TXT file that claims a very large \"max_value\" value."}, {"lang": "es", "value": "En la funci\u00f3n ReadTXTImage() en coders/txt.c en ImageMagick 7.0.6-10, podr\u00eda ocurrir un desbordamiento de enteros por la operaci\u00f3n de suma \"GetQuantumRange(depth)+1\" cuando \"depth\" es muy grande, produciendo un valor m\u00e1s peque\u00f1o de lo esperado. Como consecuencia, podr\u00eda ocurrir un bucle infinito para un archivo TXT manipulado que pida un valor \"max_value\" muy grande."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}, {"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.6-10:*:*:*:*:*:*:*", "matchCriteriaId": "7B450807-6F43-4852-93CF-CC1EB85D83F7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:17.10:*:*:*:*:*:*:*", "matchCriteriaId": "9070C9D8-A14A-467F-8253-33B966C16886"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/ImageMagick/ImageMagick/commit/50f54462076648ac2e36c3f58f4dadd4babbf1c9", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/713", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/05/msg00015.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/09/msg00007.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201711-07", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3681-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/50f54462076648ac2e36c3f58f4dadd4babbf1c9"}}