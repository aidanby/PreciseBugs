{"buggy_code": ["package pluginproxy\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/grafana/grafana/pkg/api/datasource\"\n\tglog \"github.com/grafana/grafana/pkg/infra/log\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/plugins\"\n\t\"github.com/grafana/grafana/pkg/services/oauthtoken\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/util\"\n\t\"github.com/grafana/grafana/pkg/util/proxyutil\"\n\t\"github.com/opentracing/opentracing-go\"\n)\n\nvar (\n\tlogger = glog.New(\"data-proxy-log\")\n\tclient = newHTTPClient()\n)\n\ntype DataSourceProxy struct {\n\tds        *models.DataSource\n\tctx       *models.ReqContext\n\ttargetUrl *url.URL\n\tproxyPath string\n\troute     *plugins.AppPluginRoute\n\tplugin    *plugins.DataSourcePlugin\n\tcfg       *setting.Cfg\n}\n\ntype handleResponseTransport struct {\n\ttransport http.RoundTripper\n}\n\nfunc (t *handleResponseTransport) RoundTrip(req *http.Request) (*http.Response, error) {\n\tres, err := t.transport.RoundTrip(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tres.Header.Del(\"Set-Cookie\")\n\treturn res, nil\n}\n\ntype httpClient interface {\n\tDo(req *http.Request) (*http.Response, error)\n}\n\ntype logWrapper struct {\n\tlogger glog.Logger\n}\n\n// Write writes log messages as bytes from proxy\nfunc (lw *logWrapper) Write(p []byte) (n int, err error) {\n\twithoutNewline := strings.TrimSuffix(string(p), \"\\n\")\n\tlw.logger.Error(\"Data proxy error\", \"error\", withoutNewline)\n\treturn len(p), nil\n}\n\n// NewDataSourceProxy creates a new Datasource proxy\nfunc NewDataSourceProxy(ds *models.DataSource, plugin *plugins.DataSourcePlugin, ctx *models.ReqContext,\n\tproxyPath string, cfg *setting.Cfg) (*DataSourceProxy, error) {\n\ttargetURL, err := datasource.ValidateURL(ds.Type, ds.Url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &DataSourceProxy{\n\t\tds:        ds,\n\t\tplugin:    plugin,\n\t\tctx:       ctx,\n\t\tproxyPath: proxyPath,\n\t\ttargetUrl: targetURL,\n\t\tcfg:       cfg,\n\t}, nil\n}\n\nfunc newHTTPClient() httpClient {\n\treturn &http.Client{\n\t\tTimeout:   30 * time.Second,\n\t\tTransport: &http.Transport{Proxy: http.ProxyFromEnvironment},\n\t}\n}\n\nfunc (proxy *DataSourceProxy) HandleRequest() {\n\tif err := proxy.validateRequest(); err != nil {\n\t\tproxy.ctx.JsonApiErr(403, err.Error(), nil)\n\t\treturn\n\t}\n\n\tproxyErrorLogger := logger.New(\"userId\", proxy.ctx.UserId, \"orgId\", proxy.ctx.OrgId, \"uname\", proxy.ctx.Login,\n\t\t\"path\", proxy.ctx.Req.URL.Path, \"remote_addr\", proxy.ctx.RemoteAddr(), \"referer\", proxy.ctx.Req.Referer())\n\n\ttransport, err := proxy.ds.GetHttpTransport()\n\tif err != nil {\n\t\tproxy.ctx.JsonApiErr(400, \"Unable to load TLS certificate\", err)\n\t\treturn\n\t}\n\n\treverseProxy := &httputil.ReverseProxy{\n\t\tDirector:      proxy.director,\n\t\tFlushInterval: time.Millisecond * 200,\n\t\tErrorLog:      log.New(&logWrapper{logger: proxyErrorLogger}, \"\", 0),\n\t\tTransport: &handleResponseTransport{\n\t\t\ttransport: transport,\n\t\t},\n\t\tModifyResponse: func(resp *http.Response) error {\n\t\t\tif resp.StatusCode == 401 {\n\t\t\t\t// The data source rejected the request as unauthorized, convert to 400 (bad request)\n\t\t\t\tbody, err := ioutil.ReadAll(resp.Body)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"failed to read data source response body: %w\", err)\n\t\t\t\t}\n\t\t\t\t_ = resp.Body.Close()\n\n\t\t\t\tproxyErrorLogger.Info(\"Authentication to data source failed\", \"body\", string(body), \"statusCode\",\n\t\t\t\t\tresp.StatusCode)\n\t\t\t\tmsg := \"Authentication to data source failed\"\n\t\t\t\t*resp = http.Response{\n\t\t\t\t\tStatusCode:    400,\n\t\t\t\t\tStatus:        \"Bad Request\",\n\t\t\t\t\tBody:          ioutil.NopCloser(strings.NewReader(msg)),\n\t\t\t\t\tContentLength: int64(len(msg)),\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n\n\tproxy.logRequest()\n\n\tspan, ctx := opentracing.StartSpanFromContext(proxy.ctx.Req.Context(), \"datasource reverse proxy\")\n\tdefer span.Finish()\n\n\tproxy.ctx.Req.Request = proxy.ctx.Req.WithContext(ctx)\n\n\tspan.SetTag(\"datasource_name\", proxy.ds.Name)\n\tspan.SetTag(\"datasource_type\", proxy.ds.Type)\n\tspan.SetTag(\"user\", proxy.ctx.SignedInUser.Login)\n\tspan.SetTag(\"org_id\", proxy.ctx.SignedInUser.OrgId)\n\n\tproxy.addTraceFromHeaderValue(span, \"X-Panel-Id\", \"panel_id\")\n\tproxy.addTraceFromHeaderValue(span, \"X-Dashboard-Id\", \"dashboard_id\")\n\n\tif err := opentracing.GlobalTracer().Inject(\n\t\tspan.Context(),\n\t\topentracing.HTTPHeaders,\n\t\topentracing.HTTPHeadersCarrier(proxy.ctx.Req.Request.Header)); err != nil {\n\t\tlogger.Error(\"Failed to inject span context instance\", \"err\", err)\n\t}\n\n\treverseProxy.ServeHTTP(proxy.ctx.Resp, proxy.ctx.Req.Request)\n}\n\nfunc (proxy *DataSourceProxy) addTraceFromHeaderValue(span opentracing.Span, headerName string, tagName string) {\n\tpanelId := proxy.ctx.Req.Header.Get(headerName)\n\tdashId, err := strconv.Atoi(panelId)\n\tif err == nil {\n\t\tspan.SetTag(tagName, dashId)\n\t}\n}\n\nfunc (proxy *DataSourceProxy) director(req *http.Request) {\n\treq.URL.Scheme = proxy.targetUrl.Scheme\n\treq.URL.Host = proxy.targetUrl.Host\n\treq.Host = proxy.targetUrl.Host\n\n\treqQueryVals := req.URL.Query()\n\n\tswitch proxy.ds.Type {\n\tcase models.DS_INFLUXDB_08:\n\t\treq.URL.RawPath = util.JoinURLFragments(proxy.targetUrl.Path, \"db/\"+proxy.ds.Database+\"/\"+proxy.proxyPath)\n\t\treqQueryVals.Add(\"u\", proxy.ds.User)\n\t\treqQueryVals.Add(\"p\", proxy.ds.DecryptedPassword())\n\t\treq.URL.RawQuery = reqQueryVals.Encode()\n\tcase models.DS_INFLUXDB:\n\t\treq.URL.RawPath = util.JoinURLFragments(proxy.targetUrl.Path, proxy.proxyPath)\n\t\treq.URL.RawQuery = reqQueryVals.Encode()\n\t\tif !proxy.ds.BasicAuth {\n\t\t\treq.Header.Set(\"Authorization\", util.GetBasicAuthHeader(proxy.ds.User, proxy.ds.DecryptedPassword()))\n\t\t}\n\tdefault:\n\t\treq.URL.RawPath = util.JoinURLFragments(proxy.targetUrl.Path, proxy.proxyPath)\n\t}\n\n\tunescapedPath, err := url.PathUnescape(req.URL.RawPath)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to unescape raw path\", \"rawPath\", req.URL.RawPath, \"error\", err)\n\t\treturn\n\t}\n\n\treq.URL.Path = unescapedPath\n\n\tif proxy.ds.BasicAuth {\n\t\treq.Header.Set(\"Authorization\", util.GetBasicAuthHeader(proxy.ds.BasicAuthUser,\n\t\t\tproxy.ds.DecryptedBasicAuthPassword()))\n\t}\n\n\tdsAuth := req.Header.Get(\"X-DS-Authorization\")\n\tif len(dsAuth) > 0 {\n\t\treq.Header.Del(\"X-DS-Authorization\")\n\t\treq.Header.Set(\"Authorization\", dsAuth)\n\t}\n\n\tapplyUserHeader(proxy.cfg.SendUserHeader, req, proxy.ctx.SignedInUser)\n\n\tkeepCookieNames := []string{}\n\tif proxy.ds.JsonData != nil {\n\t\tif keepCookies := proxy.ds.JsonData.Get(\"keepCookies\"); keepCookies != nil {\n\t\t\tkeepCookieNames = keepCookies.MustStringArray()\n\t\t}\n\t}\n\n\tproxyutil.ClearCookieHeader(req, keepCookieNames)\n\tproxyutil.PrepareProxyRequest(req)\n\n\treq.Header.Set(\"User-Agent\", fmt.Sprintf(\"Grafana/%s\", setting.BuildVersion))\n\n\t// Clear Origin and Referer to avoir CORS issues\n\treq.Header.Del(\"Origin\")\n\treq.Header.Del(\"Referer\")\n\n\tif proxy.route != nil {\n\t\tApplyRoute(proxy.ctx.Req.Context(), req, proxy.proxyPath, proxy.route, proxy.ds)\n\t}\n\n\tif oauthtoken.IsOAuthPassThruEnabled(proxy.ds) {\n\t\tif token := oauthtoken.GetCurrentOAuthToken(proxy.ctx.Req.Context(), proxy.ctx.SignedInUser); token != nil {\n\t\t\treq.Header.Set(\"Authorization\", fmt.Sprintf(\"%s %s\", token.Type(), token.AccessToken))\n\t\t}\n\t}\n}\n\nfunc (proxy *DataSourceProxy) validateRequest() error {\n\tif !checkWhiteList(proxy.ctx, proxy.targetUrl.Host) {\n\t\treturn errors.New(\"target URL is not a valid target\")\n\t}\n\n\tif proxy.ds.Type == models.DS_PROMETHEUS {\n\t\tif proxy.ctx.Req.Request.Method == \"DELETE\" {\n\t\t\treturn errors.New(\"deletes not allowed on proxied Prometheus datasource\")\n\t\t}\n\t\tif proxy.ctx.Req.Request.Method == \"PUT\" {\n\t\t\treturn errors.New(\"puts not allowed on proxied Prometheus datasource\")\n\t\t}\n\t\tif proxy.ctx.Req.Request.Method == \"POST\" && !(proxy.proxyPath == \"api/v1/query\" || proxy.proxyPath == \"api/v1/query_range\" || proxy.proxyPath == \"api/v1/series\" || proxy.proxyPath == \"api/v1/labels\" || proxy.proxyPath == \"api/v1/query_exemplars\") {\n\t\t\treturn errors.New(\"posts not allowed on proxied Prometheus datasource except on /query, /query_range, /series and /labels\")\n\t\t}\n\t}\n\n\tif proxy.ds.Type == models.DS_ES {\n\t\tif proxy.ctx.Req.Request.Method == \"DELETE\" {\n\t\t\treturn errors.New(\"deletes not allowed on proxied Elasticsearch datasource\")\n\t\t}\n\t\tif proxy.ctx.Req.Request.Method == \"PUT\" {\n\t\t\treturn errors.New(\"puts not allowed on proxied Elasticsearch datasource\")\n\t\t}\n\t\tif proxy.ctx.Req.Request.Method == \"POST\" && proxy.proxyPath != \"_msearch\" {\n\t\t\treturn errors.New(\"posts not allowed on proxied Elasticsearch datasource except on /_msearch\")\n\t\t}\n\t}\n\n\t// found route if there are any\n\tif len(proxy.plugin.Routes) > 0 {\n\t\tfor _, route := range proxy.plugin.Routes {\n\t\t\t// method match\n\t\t\tif route.Method != \"\" && route.Method != \"*\" && route.Method != proxy.ctx.Req.Method {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif route.ReqRole.IsValid() {\n\t\t\t\tif !proxy.ctx.HasUserRole(route.ReqRole) {\n\t\t\t\t\treturn errors.New(\"plugin proxy route access denied\")\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif strings.HasPrefix(proxy.proxyPath, route.Path) {\n\t\t\t\tproxy.route = route\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (proxy *DataSourceProxy) logRequest() {\n\tif !setting.DataProxyLogging {\n\t\treturn\n\t}\n\n\tvar body string\n\tif proxy.ctx.Req.Request.Body != nil {\n\t\tbuffer, err := ioutil.ReadAll(proxy.ctx.Req.Request.Body)\n\t\tif err == nil {\n\t\t\tproxy.ctx.Req.Request.Body = ioutil.NopCloser(bytes.NewBuffer(buffer))\n\t\t\tbody = string(buffer)\n\t\t}\n\t}\n\n\tlogger.Info(\"Proxying incoming request\",\n\t\t\"userid\", proxy.ctx.UserId,\n\t\t\"orgid\", proxy.ctx.OrgId,\n\t\t\"username\", proxy.ctx.Login,\n\t\t\"datasource\", proxy.ds.Type,\n\t\t\"uri\", proxy.ctx.Req.RequestURI,\n\t\t\"method\", proxy.ctx.Req.Request.Method,\n\t\t\"body\", body)\n}\n\nfunc checkWhiteList(c *models.ReqContext, host string) bool {\n\tif host != \"\" && len(setting.DataProxyWhiteList) > 0 {\n\t\tif _, exists := setting.DataProxyWhiteList[host]; !exists {\n\t\t\tc.JsonApiErr(403, \"Data proxy hostname and ip are not included in whitelist\", nil)\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n", "package pluginproxy\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/grafana/grafana/pkg/api/datasource\"\n\t\"github.com/grafana/grafana/pkg/components/securejsondata\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"golang.org/x/oauth2\"\n\tmacaron \"gopkg.in/macaron.v1\"\n\n\t\"github.com/grafana/grafana/pkg/bus\"\n\t\"github.com/grafana/grafana/pkg/components/simplejson\"\n\t\"github.com/grafana/grafana/pkg/login/social\"\n\t\"github.com/grafana/grafana/pkg/plugins\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/util\"\n)\n\nfunc TestDataSourceProxy_routeRule(t *testing.T) {\n\tt.Run(\"Plugin with routes\", func(t *testing.T) {\n\t\tplugin := &plugins.DataSourcePlugin{\n\t\t\tRoutes: []*plugins.AppPluginRoute{\n\t\t\t\t{\n\t\t\t\t\tPath:    \"api/v4/\",\n\t\t\t\t\tURL:     \"https://www.google.com\",\n\t\t\t\t\tReqRole: models.ROLE_EDITOR,\n\t\t\t\t\tHeaders: []plugins.AppPluginRouteHeader{\n\t\t\t\t\t\t{Name: \"x-header\", Content: \"my secret {{.SecureJsonData.key}}\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tPath:    \"api/admin\",\n\t\t\t\t\tURL:     \"https://www.google.com\",\n\t\t\t\t\tReqRole: models.ROLE_ADMIN,\n\t\t\t\t\tHeaders: []plugins.AppPluginRouteHeader{\n\t\t\t\t\t\t{Name: \"x-header\", Content: \"my secret {{.SecureJsonData.key}}\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tPath: \"api/anon\",\n\t\t\t\t\tURL:  \"https://www.google.com\",\n\t\t\t\t\tHeaders: []plugins.AppPluginRouteHeader{\n\t\t\t\t\t\t{Name: \"x-header\", Content: \"my secret {{.SecureJsonData.key}}\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tPath: \"api/common\",\n\t\t\t\t\tURL:  \"{{.JsonData.dynamicUrl}}\",\n\t\t\t\t\tURLParams: []plugins.AppPluginRouteURLParam{\n\t\t\t\t\t\t{Name: \"{{.JsonData.queryParam}}\", Content: \"{{.SecureJsonData.key}}\"},\n\t\t\t\t\t},\n\t\t\t\t\tHeaders: []plugins.AppPluginRouteHeader{\n\t\t\t\t\t\t{Name: \"x-header\", Content: \"my secret {{.SecureJsonData.key}}\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tPath:    \"api/restricted\",\n\t\t\t\t\tReqRole: models.ROLE_ADMIN,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\torigSecretKey := setting.SecretKey\n\t\tt.Cleanup(func() {\n\t\t\tsetting.SecretKey = origSecretKey\n\t\t})\n\t\tsetting.SecretKey = \"password\" //nolint:goconst\n\n\t\tkey, err := util.Encrypt([]byte(\"123\"), \"password\")\n\t\trequire.NoError(t, err)\n\n\t\tds := &models.DataSource{\n\t\t\tJsonData: simplejson.NewFromAny(map[string]interface{}{\n\t\t\t\t\"clientId\":   \"asd\",\n\t\t\t\t\"dynamicUrl\": \"https://dynamic.grafana.com\",\n\t\t\t\t\"queryParam\": \"apiKey\",\n\t\t\t}),\n\t\t\tSecureJsonData: map[string][]byte{\n\t\t\t\t\"key\": key,\n\t\t\t},\n\t\t}\n\n\t\tsetUp := func() (*models.ReqContext, *http.Request) {\n\t\t\treq, err := http.NewRequest(\"GET\", \"http://localhost/asd\", nil)\n\t\t\trequire.NoError(t, err)\n\t\t\tctx := &models.ReqContext{\n\t\t\t\tContext: &macaron.Context{\n\t\t\t\t\tReq: macaron.Request{Request: req},\n\t\t\t\t},\n\t\t\t\tSignedInUser: &models.SignedInUser{OrgRole: models.ROLE_EDITOR},\n\t\t\t}\n\t\t\treturn ctx, req\n\t\t}\n\n\t\tt.Run(\"When matching route path\", func(t *testing.T) {\n\t\t\tctx, req := setUp()\n\t\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"api/v4/some/method\", &setting.Cfg{})\n\t\t\trequire.NoError(t, err)\n\t\t\tproxy.route = plugin.Routes[0]\n\t\t\tApplyRoute(proxy.ctx.Req.Context(), req, proxy.proxyPath, proxy.route, proxy.ds)\n\n\t\t\tassert.Equal(t, \"https://www.google.com/some/method\", req.URL.String())\n\t\t\tassert.Equal(t, \"my secret 123\", req.Header.Get(\"x-header\"))\n\t\t})\n\n\t\tt.Run(\"When matching route path and has dynamic url\", func(t *testing.T) {\n\t\t\tctx, req := setUp()\n\t\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"api/common/some/method\", &setting.Cfg{})\n\t\t\trequire.NoError(t, err)\n\t\t\tproxy.route = plugin.Routes[3]\n\t\t\tApplyRoute(proxy.ctx.Req.Context(), req, proxy.proxyPath, proxy.route, proxy.ds)\n\n\t\t\tassert.Equal(t, \"https://dynamic.grafana.com/some/method?apiKey=123\", req.URL.String())\n\t\t\tassert.Equal(t, \"my secret 123\", req.Header.Get(\"x-header\"))\n\t\t})\n\n\t\tt.Run(\"When matching route path with no url\", func(t *testing.T) {\n\t\t\tctx, req := setUp()\n\t\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"\", &setting.Cfg{})\n\t\t\trequire.NoError(t, err)\n\t\t\tproxy.route = plugin.Routes[4]\n\t\t\tApplyRoute(proxy.ctx.Req.Context(), req, proxy.proxyPath, proxy.route, proxy.ds)\n\n\t\t\tassert.Equal(t, \"http://localhost/asd\", req.URL.String())\n\t\t})\n\n\t\tt.Run(\"Validating request\", func(t *testing.T) {\n\t\t\tt.Run(\"plugin route with valid role\", func(t *testing.T) {\n\t\t\t\tctx, _ := setUp()\n\t\t\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"api/v4/some/method\", &setting.Cfg{})\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\terr = proxy.validateRequest()\n\t\t\t\trequire.NoError(t, err)\n\t\t\t})\n\n\t\t\tt.Run(\"plugin route with admin role and user is editor\", func(t *testing.T) {\n\t\t\t\tctx, _ := setUp()\n\t\t\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"api/admin\", &setting.Cfg{})\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\terr = proxy.validateRequest()\n\t\t\t\trequire.Error(t, err)\n\t\t\t})\n\n\t\t\tt.Run(\"plugin route with admin role and user is admin\", func(t *testing.T) {\n\t\t\t\tctx, _ := setUp()\n\t\t\t\tctx.SignedInUser.OrgRole = models.ROLE_ADMIN\n\t\t\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"api/admin\", &setting.Cfg{})\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\terr = proxy.validateRequest()\n\t\t\t\trequire.NoError(t, err)\n\t\t\t})\n\t\t})\n\t})\n\n\tt.Run(\"Plugin with multiple routes for token auth\", func(t *testing.T) {\n\t\tplugin := &plugins.DataSourcePlugin{\n\t\t\tRoutes: []*plugins.AppPluginRoute{\n\t\t\t\t{\n\t\t\t\t\tPath: \"pathwithtoken1\",\n\t\t\t\t\tURL:  \"https://api.nr1.io/some/path\",\n\t\t\t\t\tTokenAuth: &plugins.JwtTokenAuth{\n\t\t\t\t\t\tUrl: \"https://login.server.com/{{.JsonData.tenantId}}/oauth2/token\",\n\t\t\t\t\t\tParams: map[string]string{\n\t\t\t\t\t\t\t\"grant_type\":    \"client_credentials\",\n\t\t\t\t\t\t\t\"client_id\":     \"{{.JsonData.clientId}}\",\n\t\t\t\t\t\t\t\"client_secret\": \"{{.SecureJsonData.clientSecret}}\",\n\t\t\t\t\t\t\t\"resource\":      \"https://api.nr1.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tPath: \"pathwithtoken2\",\n\t\t\t\t\tURL:  \"https://api.nr2.io/some/path\",\n\t\t\t\t\tTokenAuth: &plugins.JwtTokenAuth{\n\t\t\t\t\t\tUrl: \"https://login.server.com/{{.JsonData.tenantId}}/oauth2/token\",\n\t\t\t\t\t\tParams: map[string]string{\n\t\t\t\t\t\t\t\"grant_type\":    \"client_credentials\",\n\t\t\t\t\t\t\t\"client_id\":     \"{{.JsonData.clientId}}\",\n\t\t\t\t\t\t\t\"client_secret\": \"{{.SecureJsonData.clientSecret}}\",\n\t\t\t\t\t\t\t\"resource\":      \"https://api.nr2.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\torigSecretKey := setting.SecretKey\n\t\tt.Cleanup(func() {\n\t\t\tsetting.SecretKey = origSecretKey\n\t\t})\n\t\tsetting.SecretKey = \"password\"\n\n\t\tkey, err := util.Encrypt([]byte(\"123\"), \"password\")\n\t\trequire.NoError(t, err)\n\n\t\tds := &models.DataSource{\n\t\t\tJsonData: simplejson.NewFromAny(map[string]interface{}{\n\t\t\t\t\"clientId\": \"asd\",\n\t\t\t\t\"tenantId\": \"mytenantId\",\n\t\t\t}),\n\t\t\tSecureJsonData: map[string][]byte{\n\t\t\t\t\"clientSecret\": key,\n\t\t\t},\n\t\t}\n\n\t\treq, err := http.NewRequest(\"GET\", \"http://localhost/asd\", nil)\n\t\trequire.NoError(t, err)\n\t\tctx := &models.ReqContext{\n\t\t\tContext: &macaron.Context{\n\t\t\t\tReq: macaron.Request{Request: req},\n\t\t\t},\n\t\t\tSignedInUser: &models.SignedInUser{OrgRole: models.ROLE_EDITOR},\n\t\t}\n\n\t\tt.Run(\"When creating and caching access tokens\", func(t *testing.T) {\n\t\t\tvar authorizationHeaderCall1 string\n\t\t\tvar authorizationHeaderCall2 string\n\n\t\t\tt.Run(\"first call should add authorization header with access token\", func(t *testing.T) {\n\t\t\t\tjson, err := ioutil.ReadFile(\"./test-data/access-token-1.json\")\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tclient = newFakeHTTPClient(t, json)\n\t\t\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"pathwithtoken1\", &setting.Cfg{})\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tApplyRoute(proxy.ctx.Req.Context(), req, proxy.proxyPath, plugin.Routes[0], proxy.ds)\n\n\t\t\t\tauthorizationHeaderCall1 = req.Header.Get(\"Authorization\")\n\t\t\t\tassert.Equal(t, \"https://api.nr1.io/some/path\", req.URL.String())\n\t\t\t\tassert.True(t, strings.HasPrefix(authorizationHeaderCall1, \"Bearer eyJ0e\"))\n\n\t\t\t\tt.Run(\"second call to another route should add a different access token\", func(t *testing.T) {\n\t\t\t\t\tjson2, err := ioutil.ReadFile(\"./test-data/access-token-2.json\")\n\t\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\t\treq, err := http.NewRequest(\"GET\", \"http://localhost/asd\", nil)\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\tclient = newFakeHTTPClient(t, json2)\n\t\t\t\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"pathwithtoken2\", &setting.Cfg{})\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\tApplyRoute(proxy.ctx.Req.Context(), req, proxy.proxyPath, plugin.Routes[1], proxy.ds)\n\n\t\t\t\t\tauthorizationHeaderCall2 = req.Header.Get(\"Authorization\")\n\n\t\t\t\t\tassert.Equal(t, \"https://api.nr2.io/some/path\", req.URL.String())\n\t\t\t\t\tassert.True(t, strings.HasPrefix(authorizationHeaderCall1, \"Bearer eyJ0e\"))\n\t\t\t\t\tassert.True(t, strings.HasPrefix(authorizationHeaderCall2, \"Bearer eyJ0e\"))\n\t\t\t\t\tassert.NotEqual(t, authorizationHeaderCall1, authorizationHeaderCall2)\n\n\t\t\t\t\tt.Run(\"third call to first route should add cached access token\", func(t *testing.T) {\n\t\t\t\t\t\treq, err := http.NewRequest(\"GET\", \"http://localhost/asd\", nil)\n\t\t\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\t\t\tclient = newFakeHTTPClient(t, []byte{})\n\t\t\t\t\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"pathwithtoken1\", &setting.Cfg{})\n\t\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\t\tApplyRoute(proxy.ctx.Req.Context(), req, proxy.proxyPath, plugin.Routes[0], proxy.ds)\n\n\t\t\t\t\t\tauthorizationHeaderCall3 := req.Header.Get(\"Authorization\")\n\t\t\t\t\t\tassert.Equal(t, \"https://api.nr1.io/some/path\", req.URL.String())\n\t\t\t\t\t\tassert.True(t, strings.HasPrefix(authorizationHeaderCall1, \"Bearer eyJ0e\"))\n\t\t\t\t\t\tassert.True(t, strings.HasPrefix(authorizationHeaderCall3, \"Bearer eyJ0e\"))\n\t\t\t\t\t\tassert.Equal(t, authorizationHeaderCall1, authorizationHeaderCall3)\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\t})\n\n\tt.Run(\"When proxying graphite\", func(t *testing.T) {\n\t\torigBuildVer := setting.BuildVersion\n\t\tt.Cleanup(func() {\n\t\t\tsetting.BuildVersion = origBuildVer\n\t\t})\n\t\tsetting.BuildVersion = \"5.3.0\"\n\n\t\tplugin := &plugins.DataSourcePlugin{}\n\t\tds := &models.DataSource{Url: \"htttp://graphite:8080\", Type: models.DS_GRAPHITE}\n\t\tctx := &models.ReqContext{}\n\n\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"/render\", &setting.Cfg{})\n\t\trequire.NoError(t, err)\n\t\treq, err := http.NewRequest(http.MethodGet, \"http://grafana.com/sub\", nil)\n\t\trequire.NoError(t, err)\n\n\t\tproxy.director(req)\n\n\t\tt.Run(\"Can translate request URL and path\", func(t *testing.T) {\n\t\t\tassert.Equal(t, \"graphite:8080\", req.URL.Host)\n\t\t\tassert.Equal(t, \"/render\", req.URL.Path)\n\t\t\tassert.Equal(t, \"Grafana/5.3.0\", req.Header.Get(\"User-Agent\"))\n\t\t})\n\t})\n\n\tt.Run(\"When proxying InfluxDB\", func(t *testing.T) {\n\t\tplugin := &plugins.DataSourcePlugin{}\n\n\t\tds := &models.DataSource{\n\t\t\tType:     models.DS_INFLUXDB_08,\n\t\t\tUrl:      \"http://influxdb:8083\",\n\t\t\tDatabase: \"site\",\n\t\t\tUser:     \"user\",\n\t\t\tPassword: \"password\",\n\t\t}\n\n\t\tctx := &models.ReqContext{}\n\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"\", &setting.Cfg{})\n\t\trequire.NoError(t, err)\n\n\t\treq, err := http.NewRequest(http.MethodGet, \"http://grafana.com/sub\", nil)\n\t\trequire.NoError(t, err)\n\n\t\tproxy.director(req)\n\t\tassert.Equal(t, \"/db/site/\", req.URL.Path)\n\t})\n\n\tt.Run(\"When proxying a data source with no keepCookies specified\", func(t *testing.T) {\n\t\tplugin := &plugins.DataSourcePlugin{}\n\n\t\tjson, err := simplejson.NewJson([]byte(`{\"keepCookies\": []}`))\n\t\trequire.NoError(t, err)\n\n\t\tds := &models.DataSource{\n\t\t\tType:     models.DS_GRAPHITE,\n\t\t\tUrl:      \"http://graphite:8086\",\n\t\t\tJsonData: json,\n\t\t}\n\n\t\tctx := &models.ReqContext{}\n\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"\", &setting.Cfg{})\n\t\trequire.NoError(t, err)\n\n\t\trequestURL, err := url.Parse(\"http://grafana.com/sub\")\n\t\trequire.NoError(t, err)\n\t\treq := http.Request{URL: requestURL, Header: make(http.Header)}\n\t\tcookies := \"grafana_user=admin; grafana_remember=99; grafana_sess=11; JSESSION_ID=test\"\n\t\treq.Header.Set(\"Cookie\", cookies)\n\n\t\tproxy.director(&req)\n\n\t\tassert.Equal(t, \"\", req.Header.Get(\"Cookie\"))\n\t})\n\n\tt.Run(\"When proxying a data source with keep cookies specified\", func(t *testing.T) {\n\t\tplugin := &plugins.DataSourcePlugin{}\n\n\t\tjson, err := simplejson.NewJson([]byte(`{\"keepCookies\": [\"JSESSION_ID\"]}`))\n\t\trequire.NoError(t, err)\n\n\t\tds := &models.DataSource{\n\t\t\tType:     models.DS_GRAPHITE,\n\t\t\tUrl:      \"http://graphite:8086\",\n\t\t\tJsonData: json,\n\t\t}\n\n\t\tctx := &models.ReqContext{}\n\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"\", &setting.Cfg{})\n\t\trequire.NoError(t, err)\n\n\t\trequestURL, err := url.Parse(\"http://grafana.com/sub\")\n\t\trequire.NoError(t, err)\n\t\treq := http.Request{URL: requestURL, Header: make(http.Header)}\n\t\tcookies := \"grafana_user=admin; grafana_remember=99; grafana_sess=11; JSESSION_ID=test\"\n\t\treq.Header.Set(\"Cookie\", cookies)\n\n\t\tproxy.director(&req)\n\n\t\tassert.Equal(t, \"JSESSION_ID=test\", req.Header.Get(\"Cookie\"))\n\t})\n\n\tt.Run(\"When proxying a custom datasource\", func(t *testing.T) {\n\t\tplugin := &plugins.DataSourcePlugin{}\n\t\tds := &models.DataSource{\n\t\t\tType: \"custom-datasource\",\n\t\t\tUrl:  \"http://host/root/\",\n\t\t}\n\t\tctx := &models.ReqContext{}\n\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"/path/to/folder/\", &setting.Cfg{})\n\t\trequire.NoError(t, err)\n\t\treq, err := http.NewRequest(http.MethodGet, \"http://grafana.com/sub\", nil)\n\t\treq.Header.Set(\"Origin\", \"grafana.com\")\n\t\treq.Header.Set(\"Referer\", \"grafana.com\")\n\t\treq.Header.Set(\"X-Canary\", \"stillthere\")\n\t\trequire.NoError(t, err)\n\n\t\tproxy.director(req)\n\n\t\tassert.Equal(t, \"http://host/root/path/to/folder/\", req.URL.String())\n\n\t\tassert.Empty(t, req.Header.Get(\"Origin\"))\n\t\tassert.Empty(t, req.Header.Get(\"Referer\"))\n\t\tassert.Equal(t, \"stillthere\", req.Header.Get(\"X-Canary\"))\n\t})\n\n\tt.Run(\"When proxying a datasource that has OAuth token pass-through enabled\", func(t *testing.T) {\n\t\tsocial.SocialMap[\"generic_oauth\"] = &social.SocialGenericOAuth{\n\t\t\tSocialBase: &social.SocialBase{\n\t\t\t\tConfig: &oauth2.Config{},\n\t\t\t},\n\t\t}\n\t\torigAuthSvc := setting.OAuthService\n\t\tt.Cleanup(func() {\n\t\t\tsetting.OAuthService = origAuthSvc\n\t\t})\n\t\tsetting.OAuthService = &setting.OAuther{}\n\t\tsetting.OAuthService.OAuthInfos = make(map[string]*setting.OAuthInfo)\n\t\tsetting.OAuthService.OAuthInfos[\"generic_oauth\"] = &setting.OAuthInfo{}\n\n\t\tbus.AddHandler(\"test\", func(query *models.GetAuthInfoQuery) error {\n\t\t\tquery.Result = &models.UserAuth{\n\t\t\t\tId:                1,\n\t\t\t\tUserId:            1,\n\t\t\t\tAuthModule:        \"generic_oauth\",\n\t\t\t\tOAuthAccessToken:  \"testtoken\",\n\t\t\t\tOAuthRefreshToken: \"testrefreshtoken\",\n\t\t\t\tOAuthTokenType:    \"Bearer\",\n\t\t\t\tOAuthExpiry:       time.Now().AddDate(0, 0, 1),\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\n\t\tplugin := &plugins.DataSourcePlugin{}\n\t\tds := &models.DataSource{\n\t\t\tType: \"custom-datasource\",\n\t\t\tUrl:  \"http://host/root/\",\n\t\t\tJsonData: simplejson.NewFromAny(map[string]interface{}{\n\t\t\t\t\"oauthPassThru\": true,\n\t\t\t}),\n\t\t}\n\n\t\treq, err := http.NewRequest(\"GET\", \"http://localhost/asd\", nil)\n\t\trequire.NoError(t, err)\n\t\tctx := &models.ReqContext{\n\t\t\tSignedInUser: &models.SignedInUser{UserId: 1},\n\t\t\tContext: &macaron.Context{\n\t\t\t\tReq: macaron.Request{Request: req},\n\t\t\t},\n\t\t}\n\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"/path/to/folder/\", &setting.Cfg{})\n\t\trequire.NoError(t, err)\n\t\treq, err = http.NewRequest(http.MethodGet, \"http://grafana.com/sub\", nil)\n\t\trequire.NoError(t, err)\n\n\t\tproxy.director(req)\n\n\t\tassert.Equal(t, \"Bearer testtoken\", req.Header.Get(\"Authorization\"))\n\t})\n\n\tt.Run(\"When SendUserHeader config is enabled\", func(t *testing.T) {\n\t\treq := getDatasourceProxiedRequest(\n\t\t\tt,\n\t\t\t&models.ReqContext{\n\t\t\t\tSignedInUser: &models.SignedInUser{\n\t\t\t\t\tLogin: \"test_user\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t&setting.Cfg{SendUserHeader: true},\n\t\t)\n\t\tassert.Equal(t, \"test_user\", req.Header.Get(\"X-Grafana-User\"))\n\t})\n\n\tt.Run(\"When SendUserHeader config is disabled\", func(t *testing.T) {\n\t\treq := getDatasourceProxiedRequest(\n\t\t\tt,\n\t\t\t&models.ReqContext{\n\t\t\t\tSignedInUser: &models.SignedInUser{\n\t\t\t\t\tLogin: \"test_user\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t&setting.Cfg{SendUserHeader: false},\n\t\t)\n\t\t// Get will return empty string even if header is not set\n\t\tassert.Empty(t, req.Header.Get(\"X-Grafana-User\"))\n\t})\n\n\tt.Run(\"When SendUserHeader config is enabled but user is anonymous\", func(t *testing.T) {\n\t\treq := getDatasourceProxiedRequest(\n\t\t\tt,\n\t\t\t&models.ReqContext{\n\t\t\t\tSignedInUser: &models.SignedInUser{IsAnonymous: true},\n\t\t\t},\n\t\t\t&setting.Cfg{SendUserHeader: true},\n\t\t)\n\t\t// Get will return empty string even if header is not set\n\t\tassert.Empty(t, req.Header.Get(\"X-Grafana-User\"))\n\t})\n\n\tt.Run(\"When proxying data source proxy should handle authentication\", func(t *testing.T) {\n\t\ttests := []*testCase{\n\t\t\tcreateAuthTest(t, models.DS_INFLUXDB_08, authTypePassword, authCheckQuery, false),\n\t\t\tcreateAuthTest(t, models.DS_INFLUXDB_08, authTypePassword, authCheckQuery, true),\n\t\t\tcreateAuthTest(t, models.DS_INFLUXDB, authTypePassword, authCheckHeader, true),\n\t\t\tcreateAuthTest(t, models.DS_INFLUXDB, authTypePassword, authCheckHeader, false),\n\t\t\tcreateAuthTest(t, models.DS_INFLUXDB, authTypeBasic, authCheckHeader, true),\n\t\t\tcreateAuthTest(t, models.DS_INFLUXDB, authTypeBasic, authCheckHeader, false),\n\n\t\t\t// These two should be enough for any other datasource at the moment. Proxy has special handling\n\t\t\t// only for Influx, others have the same path and only BasicAuth. Non BasicAuth datasources\n\t\t\t// do not go through proxy but through TSDB API which is not tested here.\n\t\t\tcreateAuthTest(t, models.DS_ES, authTypeBasic, authCheckHeader, false),\n\t\t\tcreateAuthTest(t, models.DS_ES, authTypeBasic, authCheckHeader, true),\n\t\t}\n\t\tfor _, test := range tests {\n\t\t\tmodels.ClearDSDecryptionCache()\n\t\t\trunDatasourceAuthTest(t, test)\n\t\t}\n\t})\n}\n\n// test DataSourceProxy request handling.\nfunc TestDataSourceProxy_requestHandling(t *testing.T) {\n\tvar writeErr error\n\n\tplugin := &plugins.DataSourcePlugin{}\n\n\ttype setUpCfg struct {\n\t\theaders map[string]string\n\t\twriteCb func(w http.ResponseWriter, r *http.Request)\n\t}\n\n\tsetUp := func(t *testing.T, cfgs ...setUpCfg) (*models.ReqContext, *models.DataSource) {\n\t\twriteErr = nil\n\n\t\tbackend := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\thttp.SetCookie(w, &http.Cookie{Name: \"flavor\", Value: \"chocolateChip\"})\n\t\t\twritten := false\n\t\t\tfor _, cfg := range cfgs {\n\t\t\t\tif cfg.writeCb != nil {\n\t\t\t\t\tt.Log(\"Writing response via callback\")\n\t\t\t\t\tcfg.writeCb(w, r)\n\t\t\t\t\twritten = true\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !written {\n\t\t\t\tt.Log(\"Writing default response\")\n\t\t\t\tw.WriteHeader(200)\n\t\t\t\t_, writeErr = w.Write([]byte(\"I am the backend\"))\n\t\t\t}\n\t\t}))\n\t\tt.Cleanup(backend.Close)\n\n\t\tds := &models.DataSource{Url: backend.URL, Type: models.DS_GRAPHITE, Name: \"graphite\"}\n\n\t\tresponseRecorder := &closeNotifierResponseRecorder{\n\t\t\tResponseRecorder: httptest.NewRecorder(),\n\t\t}\n\t\tt.Cleanup(responseRecorder.Close)\n\n\t\tresponseWriter := macaron.NewResponseWriter(\"GET\", responseRecorder)\n\n\t\t// XXX: Really unsure why, but setting headers within the HTTP handler function doesn't stick,\n\t\t// so doing it here instead\n\t\tfor _, cfg := range cfgs {\n\t\t\tfor k, v := range cfg.headers {\n\t\t\t\tresponseWriter.Header().Set(k, v)\n\t\t\t}\n\t\t}\n\n\t\treturn &models.ReqContext{\n\t\t\tSignedInUser: &models.SignedInUser{},\n\t\t\tContext: &macaron.Context{\n\t\t\t\tReq: macaron.Request{\n\t\t\t\t\tRequest: httptest.NewRequest(\"GET\", \"/render\", nil),\n\t\t\t\t},\n\t\t\t\tResp: responseWriter,\n\t\t\t},\n\t\t}, ds\n\t}\n\n\tt.Run(\"When response header Set-Cookie is not set should remove proxied Set-Cookie header\", func(t *testing.T) {\n\t\tctx, ds := setUp(t)\n\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"/render\", &setting.Cfg{})\n\t\trequire.NoError(t, err)\n\n\t\tproxy.HandleRequest()\n\n\t\trequire.NoError(t, writeErr)\n\t\tassert.Empty(t, proxy.ctx.Resp.Header().Get(\"Set-Cookie\"))\n\t})\n\n\tt.Run(\"When response header Set-Cookie is set should remove proxied Set-Cookie header and restore the original Set-Cookie header\", func(t *testing.T) {\n\t\tctx, ds := setUp(t, setUpCfg{\n\t\t\theaders: map[string]string{\n\t\t\t\t\"Set-Cookie\": \"important_cookie=important_value\",\n\t\t\t},\n\t\t})\n\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"/render\", &setting.Cfg{})\n\t\trequire.NoError(t, err)\n\n\t\tproxy.HandleRequest()\n\n\t\trequire.NoError(t, writeErr)\n\t\tassert.Equal(t, \"important_cookie=important_value\", proxy.ctx.Resp.Header().Get(\"Set-Cookie\"))\n\t})\n\n\tt.Run(\"Data source returns status code 401\", func(t *testing.T) {\n\t\tctx, ds := setUp(t, setUpCfg{\n\t\t\twriteCb: func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tw.WriteHeader(401)\n\t\t\t\tw.Header().Set(\"www-authenticate\", `Basic realm=\"Access to the server\"`)\n\t\t\t\t_, err := w.Write([]byte(\"Not authenticated\"))\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tt.Log(\"Wrote 401 response\")\n\t\t\t},\n\t\t})\n\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"/render\", &setting.Cfg{})\n\t\trequire.NoError(t, err)\n\n\t\tproxy.HandleRequest()\n\n\t\trequire.NoError(t, writeErr)\n\t\tassert.Equal(t, 400, proxy.ctx.Resp.Status(), \"Status code 401 should be converted to 400\")\n\t\tassert.Empty(t, proxy.ctx.Resp.Header().Get(\"www-authenticate\"))\n\t})\n\n\tt.Run(\"Data source should handle proxy path url encoding correctly\", func(t *testing.T) {\n\t\tvar req *http.Request\n\t\tctx, ds := setUp(t, setUpCfg{\n\t\t\twriteCb: func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\treq = r\n\t\t\t\tw.WriteHeader(200)\n\t\t\t\t_, err := w.Write([]byte(\"OK\"))\n\t\t\t\trequire.NoError(t, err)\n\t\t\t},\n\t\t})\n\n\t\tctx.Req.Request = httptest.NewRequest(\"GET\", \"/api/datasources/proxy/1/path/%2Ftest%2Ftest%2F?query=%2Ftest%2Ftest%2F\", nil)\n\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"/path/%2Ftest%2Ftest%2F\", &setting.Cfg{})\n\t\trequire.NoError(t, err)\n\n\t\tproxy.HandleRequest()\n\n\t\trequire.NoError(t, writeErr)\n\t\trequire.NotNil(t, req)\n\t\trequire.Equal(t, \"/path/%2Ftest%2Ftest%2F?query=%2Ftest%2Ftest%2F\", req.RequestURI)\n\t})\n}\n\nfunc TestNewDataSourceProxy_InvalidURL(t *testing.T) {\n\tctx := models.ReqContext{\n\t\tContext: &macaron.Context{\n\t\t\tReq: macaron.Request{},\n\t\t},\n\t\tSignedInUser: &models.SignedInUser{OrgRole: models.ROLE_EDITOR},\n\t}\n\tds := models.DataSource{\n\t\tType: \"test\",\n\t\tUrl:  \"://host/root\",\n\t}\n\tcfg := setting.Cfg{}\n\tplugin := plugins.DataSourcePlugin{}\n\t_, err := NewDataSourceProxy(&ds, &plugin, &ctx, \"api/method\", &cfg)\n\trequire.Error(t, err)\n\tassert.True(t, strings.HasPrefix(err.Error(), `validation of data source URL \"://host/root\" failed`))\n}\n\nfunc TestNewDataSourceProxy_ProtocolLessURL(t *testing.T) {\n\tctx := models.ReqContext{\n\t\tContext: &macaron.Context{\n\t\t\tReq: macaron.Request{},\n\t\t},\n\t\tSignedInUser: &models.SignedInUser{OrgRole: models.ROLE_EDITOR},\n\t}\n\tds := models.DataSource{\n\t\tType: \"test\",\n\t\tUrl:  \"127.0.01:5432\",\n\t}\n\tcfg := setting.Cfg{}\n\tplugin := plugins.DataSourcePlugin{}\n\n\t_, err := NewDataSourceProxy(&ds, &plugin, &ctx, \"api/method\", &cfg)\n\n\trequire.NoError(t, err)\n}\n\n// Test wth MSSQL type data sources.\nfunc TestNewDataSourceProxy_MSSQL(t *testing.T) {\n\tctx := models.ReqContext{\n\t\tContext: &macaron.Context{\n\t\t\tReq: macaron.Request{},\n\t\t},\n\t\tSignedInUser: &models.SignedInUser{OrgRole: models.ROLE_EDITOR},\n\t}\n\ttcs := []struct {\n\t\tdescription string\n\t\turl         string\n\t\terr         error\n\t}{\n\t\t{\n\t\t\tdescription: \"Valid ODBC URL\",\n\t\t\turl:         `localhost\\instance:1433`,\n\t\t},\n\t\t{\n\t\t\tdescription: \"Invalid ODBC URL\",\n\t\t\turl:         `localhost\\instance::1433`,\n\t\t\terr: datasource.URLValidationError{\n\t\t\t\tErr: fmt.Errorf(`unrecognized MSSQL URL format: \"localhost\\\\instance::1433\"`),\n\t\t\t\tURL: `localhost\\instance::1433`,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range tcs {\n\t\tt.Run(tc.description, func(t *testing.T) {\n\t\t\tcfg := setting.Cfg{}\n\t\t\tplugin := plugins.DataSourcePlugin{}\n\t\t\tds := models.DataSource{\n\t\t\t\tType: \"mssql\",\n\t\t\t\tUrl:  tc.url,\n\t\t\t}\n\n\t\t\tp, err := NewDataSourceProxy(&ds, &plugin, &ctx, \"api/method\", &cfg)\n\t\t\tif tc.err == nil {\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.Equal(t, &url.URL{\n\t\t\t\t\tScheme: \"sqlserver\",\n\t\t\t\t\tHost:   ds.Url,\n\t\t\t\t}, p.targetUrl)\n\t\t\t} else {\n\t\t\t\trequire.Error(t, err)\n\t\t\t\tassert.Equal(t, tc.err, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\ntype closeNotifierResponseRecorder struct {\n\t*httptest.ResponseRecorder\n\tcloseChan chan bool\n}\n\nfunc (r *closeNotifierResponseRecorder) CloseNotify() <-chan bool {\n\tr.closeChan = make(chan bool)\n\treturn r.closeChan\n}\n\nfunc (r *closeNotifierResponseRecorder) Close() {\n\tclose(r.closeChan)\n}\n\n// getDatasourceProxiedRequest is a helper for easier setup of tests based on global config and ReqContext.\nfunc getDatasourceProxiedRequest(t *testing.T, ctx *models.ReqContext, cfg *setting.Cfg) *http.Request {\n\tplugin := &plugins.DataSourcePlugin{}\n\n\tds := &models.DataSource{\n\t\tType: \"custom\",\n\t\tUrl:  \"http://host/root/\",\n\t}\n\n\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"\", cfg)\n\trequire.NoError(t, err)\n\treq, err := http.NewRequest(http.MethodGet, \"http://grafana.com/sub\", nil)\n\trequire.NoError(t, err)\n\n\tproxy.director(req)\n\treturn req\n}\n\ntype httpClientStub struct {\n\tt        *testing.T\n\tfakeBody []byte\n}\n\nfunc (c *httpClientStub) Do(req *http.Request) (*http.Response, error) {\n\tbodyJSON, err := simplejson.NewJson(c.fakeBody)\n\trequire.NoError(c.t, err)\n\t_, passedTokenCacheTest := bodyJSON.CheckGet(\"expires_on\")\n\trequire.True(c.t, passedTokenCacheTest)\n\n\tbodyJSON.Set(\"expires_on\", fmt.Sprint(time.Now().Add(time.Second*60).Unix()))\n\tbody, err := bodyJSON.MarshalJSON()\n\trequire.NoError(c.t, err)\n\tresp := &http.Response{\n\t\tBody: ioutil.NopCloser(bytes.NewReader(body)),\n\t}\n\n\treturn resp, nil\n}\n\nfunc newFakeHTTPClient(t *testing.T, fakeBody []byte) httpClient {\n\treturn &httpClientStub{\n\t\tt:        t,\n\t\tfakeBody: fakeBody,\n\t}\n}\n\ntype testCase struct {\n\tdatasource *models.DataSource\n\tcheckReq   func(req *http.Request)\n}\n\nconst (\n\tauthTypePassword = \"password\"\n\tauthTypeBasic    = \"basic\"\n)\n\nconst (\n\tauthCheckQuery  = \"query\"\n\tauthCheckHeader = \"header\"\n)\n\nfunc createAuthTest(t *testing.T, dsType string, authType string, authCheck string, useSecureJsonData bool) *testCase {\n\t// Basic user:password\n\tbase64AuthHeader := \"Basic dXNlcjpwYXNzd29yZA==\"\n\n\ttest := &testCase{\n\t\tdatasource: &models.DataSource{\n\t\t\tType:     dsType,\n\t\t\tJsonData: simplejson.New(),\n\t\t},\n\t}\n\tvar message string\n\tif authType == authTypePassword {\n\t\tmessage = fmt.Sprintf(\"%v should add username and password\", dsType)\n\t\ttest.datasource.User = \"user\"\n\t\tif useSecureJsonData {\n\t\t\ttest.datasource.SecureJsonData = securejsondata.GetEncryptedJsonData(map[string]string{\n\t\t\t\t\"password\": \"password\",\n\t\t\t})\n\t\t} else {\n\t\t\ttest.datasource.Password = \"password\"\n\t\t}\n\t} else {\n\t\tmessage = fmt.Sprintf(\"%v should add basic auth username and password\", dsType)\n\t\ttest.datasource.BasicAuth = true\n\t\ttest.datasource.BasicAuthUser = \"user\"\n\t\tif useSecureJsonData {\n\t\t\ttest.datasource.SecureJsonData = securejsondata.GetEncryptedJsonData(map[string]string{\n\t\t\t\t\"basicAuthPassword\": \"password\",\n\t\t\t})\n\t\t} else {\n\t\t\ttest.datasource.BasicAuthPassword = \"password\"\n\t\t}\n\t}\n\n\tif useSecureJsonData {\n\t\tmessage += \" from securejsondata\"\n\t}\n\n\tif authCheck == authCheckQuery {\n\t\tmessage += \" to query params\"\n\t\ttest.checkReq = func(req *http.Request) {\n\t\t\tqueryVals := req.URL.Query()\n\t\t\tassert.Equal(t, \"user\", queryVals[\"u\"][0], message)\n\t\t\tassert.Equal(t, \"password\", queryVals[\"p\"][0], message)\n\t\t}\n\t} else {\n\t\tmessage += \" to auth header\"\n\t\ttest.checkReq = func(req *http.Request) {\n\t\t\tassert.Equal(t, base64AuthHeader, req.Header.Get(\"Authorization\"), message)\n\t\t}\n\t}\n\n\treturn test\n}\n\nfunc runDatasourceAuthTest(t *testing.T, test *testCase) {\n\tplugin := &plugins.DataSourcePlugin{}\n\tctx := &models.ReqContext{}\n\tproxy, err := NewDataSourceProxy(test.datasource, plugin, ctx, \"\", &setting.Cfg{})\n\trequire.NoError(t, err)\n\n\treq, err := http.NewRequest(http.MethodGet, \"http://grafana.com/sub\", nil)\n\trequire.NoError(t, err)\n\n\tproxy.director(req)\n\n\ttest.checkReq(req)\n}\n", "package pluginproxy\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"net/url\"\n\n\t\"github.com/grafana/grafana/pkg/bus\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/plugins\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/util\"\n\t\"github.com/grafana/grafana/pkg/util/proxyutil\"\n)\n\ntype templateData struct {\n\tJsonData       map[string]interface{}\n\tSecureJsonData map[string]string\n}\n\n// NewApiPluginProxy create a plugin proxy\nfunc NewApiPluginProxy(ctx *models.ReqContext, proxyPath string, route *plugins.AppPluginRoute, appID string, cfg *setting.Cfg) *httputil.ReverseProxy {\n\tdirector := func(req *http.Request) {\n\t\tquery := models.GetPluginSettingByIdQuery{OrgId: ctx.OrgId, PluginId: appID}\n\t\tif err := bus.Dispatch(&query); err != nil {\n\t\t\tctx.JsonApiErr(500, \"Failed to fetch plugin settings\", err)\n\t\t\treturn\n\t\t}\n\n\t\tdata := templateData{\n\t\t\tJsonData:       query.Result.JsonData,\n\t\t\tSecureJsonData: query.Result.SecureJsonData.Decrypt(),\n\t\t}\n\n\t\tinterpolatedURL, err := interpolateString(route.URL, data)\n\t\tif err != nil {\n\t\t\tctx.JsonApiErr(500, \"Could not interpolate plugin route url\", err)\n\t\t\treturn\n\t\t}\n\t\ttargetURL, err := url.Parse(interpolatedURL)\n\t\tif err != nil {\n\t\t\tctx.JsonApiErr(500, \"Could not parse url\", err)\n\t\t\treturn\n\t\t}\n\t\treq.URL.Scheme = targetURL.Scheme\n\t\treq.URL.Host = targetURL.Host\n\t\treq.Host = targetURL.Host\n\t\treq.URL.Path = util.JoinURLFragments(targetURL.Path, proxyPath)\n\n\t\t// clear cookie headers\n\t\treq.Header.Del(\"Cookie\")\n\t\treq.Header.Del(\"Set-Cookie\")\n\n\t\tproxyutil.PrepareProxyRequest(req)\n\n\t\t// Create a HTTP header with the context in it.\n\t\tctxJSON, err := json.Marshal(ctx.SignedInUser)\n\t\tif err != nil {\n\t\t\tctx.JsonApiErr(500, \"failed to marshal context to json.\", err)\n\t\t\treturn\n\t\t}\n\n\t\treq.Header.Set(\"X-Grafana-Context\", string(ctxJSON))\n\n\t\tapplyUserHeader(cfg.SendUserHeader, req, ctx.SignedInUser)\n\n\t\tif err := addHeaders(&req.Header, route, data); err != nil {\n\t\t\tctx.JsonApiErr(500, \"Failed to render plugin headers\", err)\n\t\t\treturn\n\t\t}\n\t}\n\n\treturn &httputil.ReverseProxy{Director: director}\n}\n", "package pluginproxy\n\nimport (\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/grafana/grafana/pkg/bus\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/plugins\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/util\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestPluginProxy(t *testing.T) {\n\tt.Run(\"When getting proxy headers\", func(t *testing.T) {\n\t\troute := &plugins.AppPluginRoute{\n\t\t\tHeaders: []plugins.AppPluginRouteHeader{\n\t\t\t\t{Name: \"x-header\", Content: \"my secret {{.SecureJsonData.key}}\"},\n\t\t\t},\n\t\t}\n\n\t\tsetting.SecretKey = \"password\"\n\n\t\tbus.AddHandler(\"test\", func(query *models.GetPluginSettingByIdQuery) error {\n\t\t\tkey, err := util.Encrypt([]byte(\"123\"), \"password\")\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tquery.Result = &models.PluginSetting{\n\t\t\t\tSecureJsonData: map[string][]byte{\n\t\t\t\t\t\"key\": key,\n\t\t\t\t},\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\n\t\treq := getPluginProxiedRequest(\n\t\t\tt,\n\t\t\t&models.ReqContext{\n\t\t\t\tSignedInUser: &models.SignedInUser{\n\t\t\t\t\tLogin: \"test_user\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t&setting.Cfg{SendUserHeader: true},\n\t\t\troute,\n\t\t)\n\n\t\tassert.Equal(t, \"my secret 123\", req.Header.Get(\"x-header\"))\n\t})\n\n\tt.Run(\"When SendUserHeader config is enabled\", func(t *testing.T) {\n\t\treq := getPluginProxiedRequest(\n\t\t\tt,\n\t\t\t&models.ReqContext{\n\t\t\t\tSignedInUser: &models.SignedInUser{\n\t\t\t\t\tLogin: \"test_user\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t&setting.Cfg{SendUserHeader: true},\n\t\t\tnil,\n\t\t)\n\n\t\t// Get will return empty string even if header is not set\n\t\tassert.Equal(t, \"test_user\", req.Header.Get(\"X-Grafana-User\"))\n\t})\n\n\tt.Run(\"When SendUserHeader config is disabled\", func(t *testing.T) {\n\t\treq := getPluginProxiedRequest(\n\t\t\tt,\n\t\t\t&models.ReqContext{\n\t\t\t\tSignedInUser: &models.SignedInUser{\n\t\t\t\t\tLogin: \"test_user\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t&setting.Cfg{SendUserHeader: false},\n\t\t\tnil,\n\t\t)\n\t\t// Get will return empty string even if header is not set\n\t\tassert.Equal(t, \"\", req.Header.Get(\"X-Grafana-User\"))\n\t})\n\n\tt.Run(\"When SendUserHeader config is enabled but user is anonymous\", func(t *testing.T) {\n\t\treq := getPluginProxiedRequest(\n\t\t\tt,\n\t\t\t&models.ReqContext{\n\t\t\t\tSignedInUser: &models.SignedInUser{IsAnonymous: true},\n\t\t\t},\n\t\t\t&setting.Cfg{SendUserHeader: true},\n\t\t\tnil,\n\t\t)\n\n\t\t// Get will return empty string even if header is not set\n\t\tassert.Equal(t, \"\", req.Header.Get(\"X-Grafana-User\"))\n\t})\n\n\tt.Run(\"When getting templated url\", func(t *testing.T) {\n\t\troute := &plugins.AppPluginRoute{\n\t\t\tURL:    \"{{.JsonData.dynamicUrl}}\",\n\t\t\tMethod: \"GET\",\n\t\t}\n\n\t\tbus.AddHandler(\"test\", func(query *models.GetPluginSettingByIdQuery) error {\n\t\t\tquery.Result = &models.PluginSetting{\n\t\t\t\tJsonData: map[string]interface{}{\n\t\t\t\t\t\"dynamicUrl\": \"https://dynamic.grafana.com\",\n\t\t\t\t},\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\n\t\treq := getPluginProxiedRequest(\n\t\t\tt,\n\t\t\t&models.ReqContext{\n\t\t\t\tSignedInUser: &models.SignedInUser{\n\t\t\t\t\tLogin: \"test_user\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t&setting.Cfg{SendUserHeader: true},\n\t\t\troute,\n\t\t)\n\t\tassert.Equal(t, \"https://dynamic.grafana.com\", req.URL.String())\n\t\tassert.Equal(t, \"{{.JsonData.dynamicUrl}}\", route.URL)\n\t})\n\n\tt.Run(\"When getting complex templated url\", func(t *testing.T) {\n\t\troute := &plugins.AppPluginRoute{\n\t\t\tURL:    \"{{if .JsonData.apiHost}}{{.JsonData.apiHost}}{{else}}https://example.com{{end}}\",\n\t\t\tMethod: \"GET\",\n\t\t}\n\n\t\tbus.AddHandler(\"test\", func(query *models.GetPluginSettingByIdQuery) error {\n\t\t\tquery.Result = &models.PluginSetting{}\n\t\t\treturn nil\n\t\t})\n\n\t\treq := getPluginProxiedRequest(\n\t\t\tt,\n\t\t\t&models.ReqContext{\n\t\t\t\tSignedInUser: &models.SignedInUser{\n\t\t\t\t\tLogin: \"test_user\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t&setting.Cfg{SendUserHeader: true},\n\t\t\troute,\n\t\t)\n\t\tassert.Equal(t, \"https://example.com\", req.URL.String())\n\t})\n}\n\n// getPluginProxiedRequest is a helper for easier setup of tests based on global config and ReqContext.\nfunc getPluginProxiedRequest(t *testing.T, ctx *models.ReqContext, cfg *setting.Cfg, route *plugins.AppPluginRoute) *http.Request {\n\t// insert dummy route if none is specified\n\tif route == nil {\n\t\troute = &plugins.AppPluginRoute{\n\t\t\tPath:    \"api/v4/\",\n\t\t\tURL:     \"https://www.google.com\",\n\t\t\tReqRole: models.ROLE_EDITOR,\n\t\t}\n\t}\n\tproxy := NewApiPluginProxy(ctx, \"\", route, \"\", cfg)\n\n\treq, err := http.NewRequest(http.MethodGet, \"/api/plugin-proxy/grafana-simple-app/api/v4/alerts\", nil)\n\trequire.NoError(t, err)\n\tproxy.Director(req)\n\treturn req\n}\n", "package backendplugin\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/grafana/grafana-aws-sdk/pkg/awsds\"\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend\"\n\t\"github.com/grafana/grafana/pkg/infra/log\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/registry\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/util/errutil\"\n\t\"github.com/grafana/grafana/pkg/util/proxyutil\"\n)\n\nvar (\n\t// ErrPluginNotRegistered error returned when plugin not registered.\n\tErrPluginNotRegistered = errors.New(\"plugin not registered\")\n\t// ErrHealthCheckFailed error returned when health check failed.\n\tErrHealthCheckFailed = errors.New(\"health check failed\")\n\t// ErrPluginUnavailable error returned when plugin is unavailable.\n\tErrPluginUnavailable = errors.New(\"plugin unavailable\")\n\t// ErrMethodNotImplemented error returned when plugin method not implemented.\n\tErrMethodNotImplemented = errors.New(\"method not implemented\")\n)\n\nfunc init() {\n\tregistry.RegisterServiceWithPriority(&manager{}, registry.MediumHigh)\n}\n\n// Manager manages backend plugins.\ntype Manager interface {\n\t// Register registers a backend plugin\n\tRegister(pluginID string, factory PluginFactoryFunc) error\n\t// StartPlugin starts a non-managed backend plugin\n\tStartPlugin(ctx context.Context, pluginID string) error\n\t// CollectMetrics collects metrics from a registered backend plugin.\n\tCollectMetrics(ctx context.Context, pluginID string) (*backend.CollectMetricsResult, error)\n\t// CheckHealth checks the health of a registered backend plugin.\n\tCheckHealth(ctx context.Context, pCtx backend.PluginContext) (*backend.CheckHealthResult, error)\n\t// CallResource calls a plugin resource.\n\tCallResource(pluginConfig backend.PluginContext, ctx *models.ReqContext, path string)\n}\n\ntype manager struct {\n\tCfg                    *setting.Cfg                  `inject:\"\"`\n\tLicense                models.Licensing              `inject:\"\"`\n\tPluginRequestValidator models.PluginRequestValidator `inject:\"\"`\n\tpluginsMu              sync.RWMutex\n\tplugins                map[string]Plugin\n\tlogger                 log.Logger\n\tpluginSettings         map[string]pluginSettings\n}\n\nfunc (m *manager) Init() error {\n\tm.plugins = make(map[string]Plugin)\n\tm.logger = log.New(\"plugins.backend\")\n\tm.pluginSettings = extractPluginSettings(m.Cfg)\n\n\treturn nil\n}\n\nfunc (m *manager) Run(ctx context.Context) error {\n\tm.start(ctx)\n\t<-ctx.Done()\n\tm.stop(ctx)\n\treturn ctx.Err()\n}\n\n// Register registers a backend plugin\nfunc (m *manager) Register(pluginID string, factory PluginFactoryFunc) error {\n\tm.logger.Debug(\"Registering backend plugin\", \"pluginId\", pluginID)\n\tm.pluginsMu.Lock()\n\tdefer m.pluginsMu.Unlock()\n\n\tif _, exists := m.plugins[pluginID]; exists {\n\t\treturn fmt.Errorf(\"backend plugin %s already registered\", pluginID)\n\t}\n\n\tpluginSettings := pluginSettings{}\n\tif ps, exists := m.pluginSettings[pluginID]; exists {\n\t\tpluginSettings = ps\n\t}\n\n\thostEnv := []string{\n\t\tfmt.Sprintf(\"GF_VERSION=%s\", m.Cfg.BuildVersion),\n\t\tfmt.Sprintf(\"GF_EDITION=%s\", m.License.Edition()),\n\t}\n\n\tif m.License.HasLicense() {\n\t\thostEnv = append(\n\t\t\thostEnv,\n\t\t\tfmt.Sprintf(\"GF_ENTERPRISE_LICENSE_PATH=%s\", m.Cfg.EnterpriseLicensePath),\n\t\t)\n\n\t\tif envProvider, ok := m.License.(models.LicenseEnvironment); ok {\n\t\t\tfor k, v := range envProvider.Environment() {\n\t\t\t\thostEnv = append(hostEnv, fmt.Sprintf(\"%s=%s\", k, v))\n\t\t\t}\n\t\t}\n\t}\n\n\thostEnv = append(hostEnv, m.getAWSEnvironmentVariables()...)\n\n\tenv := pluginSettings.ToEnv(\"GF_PLUGIN\", hostEnv)\n\n\tpluginLogger := m.logger.New(\"pluginId\", pluginID)\n\tplugin, err := factory(pluginID, pluginLogger, env)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tm.plugins[pluginID] = plugin\n\tm.logger.Debug(\"Backend plugin registered\", \"pluginId\", pluginID)\n\treturn nil\n}\n\nfunc (m *manager) getAWSEnvironmentVariables() []string {\n\tvariables := []string{}\n\tif m.Cfg.AWSAssumeRoleEnabled {\n\t\tvariables = append(variables, awsds.AssumeRoleEnabledEnvVarKeyName+\"=true\")\n\t}\n\tif len(m.Cfg.AWSAllowedAuthProviders) > 0 {\n\t\tvariables = append(variables, awsds.AllowedAuthProvidersEnvVarKeyName+\"=\"+strings.Join(m.Cfg.AWSAllowedAuthProviders, \",\"))\n\t}\n\n\treturn variables\n}\n\n// start starts all managed backend plugins\nfunc (m *manager) start(ctx context.Context) {\n\tm.pluginsMu.RLock()\n\tdefer m.pluginsMu.RUnlock()\n\tfor _, p := range m.plugins {\n\t\tif !p.IsManaged() {\n\t\t\tcontinue\n\t\t}\n\n\t\tif err := startPluginAndRestartKilledProcesses(ctx, p); err != nil {\n\t\t\tp.Logger().Error(\"Failed to start plugin\", \"error\", err)\n\t\t\tcontinue\n\t\t}\n\t}\n}\n\n// StartPlugin starts a non-managed backend plugin\nfunc (m *manager) StartPlugin(ctx context.Context, pluginID string) error {\n\tm.pluginsMu.RLock()\n\tp, registered := m.plugins[pluginID]\n\tm.pluginsMu.RUnlock()\n\tif !registered {\n\t\treturn ErrPluginNotRegistered\n\t}\n\n\tif p.IsManaged() {\n\t\treturn errors.New(\"backend plugin is managed and cannot be manually started\")\n\t}\n\n\treturn startPluginAndRestartKilledProcesses(ctx, p)\n}\n\n// stop stops all managed backend plugins\nfunc (m *manager) stop(ctx context.Context) {\n\tm.pluginsMu.RLock()\n\tdefer m.pluginsMu.RUnlock()\n\tvar wg sync.WaitGroup\n\tfor _, p := range m.plugins {\n\t\twg.Add(1)\n\t\tgo func(p Plugin, ctx context.Context) {\n\t\t\tdefer wg.Done()\n\t\t\tp.Logger().Debug(\"Stopping plugin\")\n\t\t\tif err := p.Stop(ctx); err != nil {\n\t\t\t\tp.Logger().Error(\"Failed to stop plugin\", \"error\", err)\n\t\t\t}\n\t\t\tp.Logger().Debug(\"Plugin stopped\")\n\t\t}(p, ctx)\n\t}\n\twg.Wait()\n}\n\n// CollectMetrics collects metrics from a registered backend plugin.\nfunc (m *manager) CollectMetrics(ctx context.Context, pluginID string) (*backend.CollectMetricsResult, error) {\n\tm.pluginsMu.RLock()\n\tp, registered := m.plugins[pluginID]\n\tm.pluginsMu.RUnlock()\n\n\tif !registered {\n\t\treturn nil, ErrPluginNotRegistered\n\t}\n\n\tvar resp *backend.CollectMetricsResult\n\terr := instrumentCollectMetrics(p.PluginID(), func() (innerErr error) {\n\t\tresp, innerErr = p.CollectMetrics(ctx)\n\t\treturn\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn resp, nil\n}\n\n// CheckHealth checks the health of a registered backend plugin.\nfunc (m *manager) CheckHealth(ctx context.Context, pluginContext backend.PluginContext) (*backend.CheckHealthResult, error) {\n\tvar dsURL string\n\tif pluginContext.DataSourceInstanceSettings != nil {\n\t\tdsURL = pluginContext.DataSourceInstanceSettings.URL\n\t}\n\n\terr := m.PluginRequestValidator.Validate(dsURL, nil)\n\tif err != nil {\n\t\treturn &backend.CheckHealthResult{\n\t\t\tStatus:  http.StatusForbidden,\n\t\t\tMessage: \"Access denied\",\n\t\t}, nil\n\t}\n\n\tm.pluginsMu.RLock()\n\tp, registered := m.plugins[pluginContext.PluginID]\n\tm.pluginsMu.RUnlock()\n\n\tif !registered {\n\t\treturn nil, ErrPluginNotRegistered\n\t}\n\n\tvar resp *backend.CheckHealthResult\n\terr = instrumentCheckHealthRequest(p.PluginID(), func() (innerErr error) {\n\t\tresp, innerErr = p.CheckHealth(ctx, &backend.CheckHealthRequest{PluginContext: pluginContext})\n\t\treturn\n\t})\n\n\tif err != nil {\n\t\tif errors.Is(err, ErrMethodNotImplemented) {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif errors.Is(err, ErrPluginUnavailable) {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn nil, errutil.Wrap(\"failed to check plugin health\", ErrHealthCheckFailed)\n\t}\n\n\treturn resp, nil\n}\n\ntype keepCookiesJSONModel struct {\n\tKeepCookies []string `json:\"keepCookies\"`\n}\n\nfunc (m *manager) callResourceInternal(w http.ResponseWriter, req *http.Request, pCtx backend.PluginContext) error {\n\tm.pluginsMu.RLock()\n\tp, registered := m.plugins[pCtx.PluginID]\n\tm.pluginsMu.RUnlock()\n\n\tif !registered {\n\t\treturn ErrPluginNotRegistered\n\t}\n\n\tkeepCookieModel := keepCookiesJSONModel{}\n\tif dis := pCtx.DataSourceInstanceSettings; dis != nil {\n\t\terr := json.Unmarshal(dis.JSONData, &keepCookieModel)\n\t\tif err != nil {\n\t\t\tp.Logger().Error(\"Failed to to unpack JSONData in datasource instance settings\", \"error\", err)\n\t\t}\n\t}\n\n\tproxyutil.ClearCookieHeader(req, keepCookieModel.KeepCookies)\n\tproxyutil.PrepareProxyRequest(req)\n\n\tbody, err := ioutil.ReadAll(req.Body)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to read request body: %w\", err)\n\t}\n\n\tcrReq := &backend.CallResourceRequest{\n\t\tPluginContext: pCtx,\n\t\tPath:          req.URL.Path,\n\t\tMethod:        req.Method,\n\t\tURL:           req.URL.String(),\n\t\tHeaders:       req.Header,\n\t\tBody:          body,\n\t}\n\n\treturn instrumentCallResourceRequest(p.PluginID(), func() error {\n\t\tchildCtx, cancel := context.WithCancel(req.Context())\n\t\tdefer cancel()\n\t\tstream := newCallResourceResponseStream(childCtx)\n\n\t\tvar wg sync.WaitGroup\n\t\twg.Add(1)\n\n\t\tdefer func() {\n\t\t\tif err := stream.Close(); err != nil {\n\t\t\t\tm.logger.Warn(\"Failed to close stream\", \"err\", err)\n\t\t\t}\n\t\t\twg.Wait()\n\t\t}()\n\n\t\tvar flushStreamErr error\n\t\tgo func() {\n\t\t\tflushStreamErr = flushStream(p, stream, w)\n\t\t\twg.Done()\n\t\t}()\n\n\t\tif err := p.CallResource(req.Context(), crReq, stream); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn flushStreamErr\n\t})\n}\n\n// CallResource calls a plugin resource.\nfunc (m *manager) CallResource(pCtx backend.PluginContext, reqCtx *models.ReqContext, path string) {\n\tvar dsURL string\n\tif pCtx.DataSourceInstanceSettings != nil {\n\t\tdsURL = pCtx.DataSourceInstanceSettings.URL\n\t}\n\n\terr := m.PluginRequestValidator.Validate(dsURL, reqCtx.Req.Request)\n\tif err != nil {\n\t\treqCtx.JsonApiErr(http.StatusForbidden, \"Access denied\", err)\n\t\treturn\n\t}\n\n\tclonedReq := reqCtx.Req.Clone(reqCtx.Req.Context())\n\trawURL := path\n\tif clonedReq.URL.RawQuery != \"\" {\n\t\trawURL += \"?\" + clonedReq.URL.RawQuery\n\t}\n\turlPath, err := url.Parse(rawURL)\n\tif err != nil {\n\t\thandleCallResourceError(err, reqCtx)\n\t\treturn\n\t}\n\tclonedReq.URL = urlPath\n\terr = m.callResourceInternal(reqCtx.Resp, clonedReq, pCtx)\n\tif err != nil {\n\t\thandleCallResourceError(err, reqCtx)\n\t}\n}\n\nfunc handleCallResourceError(err error, reqCtx *models.ReqContext) {\n\tif errors.Is(err, ErrPluginUnavailable) {\n\t\treqCtx.JsonApiErr(503, \"Plugin unavailable\", err)\n\t\treturn\n\t}\n\n\tif errors.Is(err, ErrMethodNotImplemented) {\n\t\treqCtx.JsonApiErr(404, \"Not found\", err)\n\t\treturn\n\t}\n\n\treqCtx.JsonApiErr(500, \"Failed to call resource\", err)\n}\n\nfunc flushStream(plugin Plugin, stream CallResourceClientResponseStream, w http.ResponseWriter) error {\n\tprocessedStreams := 0\n\n\tfor {\n\t\tresp, err := stream.Recv()\n\t\tif errors.Is(err, io.EOF) {\n\t\t\tif processedStreams == 0 {\n\t\t\t\treturn errors.New(\"received empty resource response\")\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\tif err != nil {\n\t\t\tif processedStreams == 0 {\n\t\t\t\treturn errutil.Wrap(\"failed to receive response from resource call\", err)\n\t\t\t}\n\n\t\t\tplugin.Logger().Error(\"Failed to receive response from resource call\", \"error\", err)\n\t\t\treturn stream.Close()\n\t\t}\n\n\t\t// Expected that headers and status are only part of first stream\n\t\tif processedStreams == 0 && resp.Headers != nil {\n\t\t\t// Make sure a content type always is returned in response\n\t\t\tif _, exists := resp.Headers[\"Content-Type\"]; !exists {\n\t\t\t\tresp.Headers[\"Content-Type\"] = []string{\"application/json\"}\n\t\t\t}\n\n\t\t\tfor k, values := range resp.Headers {\n\t\t\t\t// Due to security reasons we don't want to forward\n\t\t\t\t// cookies from a backend plugin to clients/browsers.\n\t\t\t\tif k == \"Set-Cookie\" {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tfor _, v := range values {\n\t\t\t\t\t// TODO: Figure out if we should use Set here instead\n\t\t\t\t\t// nolint:gocritic\n\t\t\t\t\tw.Header().Add(k, v)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tw.WriteHeader(resp.Status)\n\t\t}\n\n\t\tif _, err := w.Write(resp.Body); err != nil {\n\t\t\tplugin.Logger().Error(\"Failed to write resource response\", \"error\", err)\n\t\t}\n\n\t\tif flusher, ok := w.(http.Flusher); ok {\n\t\t\tflusher.Flush()\n\t\t}\n\t\tprocessedStreams++\n\t}\n}\n\nfunc startPluginAndRestartKilledProcesses(ctx context.Context, p Plugin) error {\n\tif err := p.Start(ctx); err != nil {\n\t\treturn err\n\t}\n\n\tgo func(ctx context.Context, p Plugin) {\n\t\tif err := restartKilledProcess(ctx, p); err != nil {\n\t\t\tp.Logger().Error(\"Attempt to restart killed plugin process failed\", \"error\", err)\n\t\t}\n\t}(ctx, p)\n\n\treturn nil\n}\n\nfunc restartKilledProcess(ctx context.Context, p Plugin) error {\n\tticker := time.NewTicker(time.Second * 1)\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tif err := ctx.Err(); err != nil && !errors.Is(err, context.Canceled) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tcase <-ticker.C:\n\t\t\tif !p.Exited() {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tp.Logger().Debug(\"Restarting plugin\")\n\t\t\tif err := p.Start(ctx); err != nil {\n\t\t\t\tp.Logger().Error(\"Failed to restart plugin\", \"error\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tp.Logger().Debug(\"Plugin restarted\")\n\t\t}\n\t}\n}\n", "package backendplugin\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/grafana/grafana-aws-sdk/pkg/awsds\"\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend\"\n\t\"github.com/grafana/grafana/pkg/infra/log\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nconst testPluginID = \"test-plugin\"\n\nfunc TestManager(t *testing.T) {\n\tnewManagerScenario(t, false, func(t *testing.T, ctx *managerScenarioCtx) {\n\t\tt.Run(\"Unregistered plugin scenario\", func(t *testing.T) {\n\t\t\terr := ctx.manager.StartPlugin(context.Background(), testPluginID)\n\t\t\trequire.Equal(t, ErrPluginNotRegistered, err)\n\n\t\t\t_, err = ctx.manager.CollectMetrics(context.Background(), testPluginID)\n\t\t\trequire.Equal(t, ErrPluginNotRegistered, err)\n\n\t\t\t_, err = ctx.manager.CheckHealth(context.Background(), backend.PluginContext{PluginID: testPluginID})\n\t\t\trequire.Equal(t, ErrPluginNotRegistered, err)\n\n\t\t\treq, err := http.NewRequest(http.MethodGet, \"/test\", nil)\n\t\t\trequire.NoError(t, err)\n\t\t\tw := httptest.NewRecorder()\n\t\t\terr = ctx.manager.callResourceInternal(w, req, backend.PluginContext{PluginID: testPluginID})\n\t\t\trequire.Equal(t, ErrPluginNotRegistered, err)\n\t\t})\n\t})\n\n\tnewManagerScenario(t, true, func(t *testing.T, ctx *managerScenarioCtx) {\n\t\tt.Run(\"Managed plugin scenario\", func(t *testing.T) {\n\t\t\tctx.license.edition = \"Open Source\"\n\t\t\tctx.license.hasLicense = false\n\t\t\tctx.cfg.BuildVersion = \"7.0.0\"\n\n\t\t\tt.Run(\"Should be able to register plugin\", func(t *testing.T) {\n\t\t\t\terr := ctx.manager.Register(testPluginID, ctx.factory)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.NotNil(t, ctx.plugin)\n\t\t\t\trequire.Equal(t, testPluginID, ctx.plugin.pluginID)\n\t\t\t\trequire.NotNil(t, ctx.plugin.logger)\n\n\t\t\t\tt.Run(\"Should not be able to register an already registered plugin\", func(t *testing.T) {\n\t\t\t\t\terr := ctx.manager.Register(testPluginID, ctx.factory)\n\t\t\t\t\trequire.Error(t, err)\n\t\t\t\t})\n\n\t\t\t\tt.Run(\"Should provide expected host environment variables\", func(t *testing.T) {\n\t\t\t\t\trequire.Len(t, ctx.env, 4)\n\t\t\t\t\trequire.EqualValues(t, []string{\"GF_VERSION=7.0.0\", \"GF_EDITION=Open Source\", fmt.Sprintf(\"%s=true\", awsds.AssumeRoleEnabledEnvVarKeyName), fmt.Sprintf(\"%s=keys,credentials\", awsds.AllowedAuthProvidersEnvVarKeyName)}, ctx.env)\n\t\t\t\t})\n\n\t\t\t\tt.Run(\"When manager runs should start and stop plugin\", func(t *testing.T) {\n\t\t\t\t\tpCtx := context.Background()\n\t\t\t\t\tcCtx, cancel := context.WithCancel(pCtx)\n\t\t\t\t\tvar wg sync.WaitGroup\n\t\t\t\t\twg.Add(1)\n\t\t\t\t\tvar runErr error\n\t\t\t\t\tgo func() {\n\t\t\t\t\t\trunErr = ctx.manager.Run(cCtx)\n\t\t\t\t\t\twg.Done()\n\t\t\t\t\t}()\n\t\t\t\t\ttime.Sleep(time.Millisecond)\n\t\t\t\t\tcancel()\n\t\t\t\t\twg.Wait()\n\t\t\t\t\trequire.Equal(t, context.Canceled, runErr)\n\t\t\t\t\trequire.Equal(t, 1, ctx.plugin.startCount)\n\t\t\t\t\trequire.Equal(t, 1, ctx.plugin.stopCount)\n\t\t\t\t})\n\n\t\t\t\tt.Run(\"When manager runs should restart plugin process when killed\", func(t *testing.T) {\n\t\t\t\t\tctx.plugin.stopCount = 0\n\t\t\t\t\tctx.plugin.startCount = 0\n\t\t\t\t\tpCtx := context.Background()\n\t\t\t\t\tcCtx, cancel := context.WithCancel(pCtx)\n\t\t\t\t\tvar wgRun sync.WaitGroup\n\t\t\t\t\twgRun.Add(1)\n\t\t\t\t\tvar runErr error\n\t\t\t\t\tgo func() {\n\t\t\t\t\t\trunErr = ctx.manager.Run(cCtx)\n\t\t\t\t\t\twgRun.Done()\n\t\t\t\t\t}()\n\n\t\t\t\t\ttime.Sleep(time.Millisecond)\n\n\t\t\t\t\tvar wgKill sync.WaitGroup\n\t\t\t\t\twgKill.Add(1)\n\t\t\t\t\tgo func() {\n\t\t\t\t\t\tctx.plugin.kill()\n\t\t\t\t\t\tfor {\n\t\t\t\t\t\t\tif !ctx.plugin.Exited() {\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcancel()\n\t\t\t\t\t\twgKill.Done()\n\t\t\t\t\t}()\n\t\t\t\t\twgKill.Wait()\n\t\t\t\t\twgRun.Wait()\n\t\t\t\t\trequire.Equal(t, context.Canceled, runErr)\n\t\t\t\t\trequire.Equal(t, 1, ctx.plugin.stopCount)\n\t\t\t\t\trequire.Equal(t, 2, ctx.plugin.startCount)\n\t\t\t\t})\n\n\t\t\t\tt.Run(\"Shouldn't be able to start managed plugin\", func(t *testing.T) {\n\t\t\t\t\terr := ctx.manager.StartPlugin(context.Background(), testPluginID)\n\t\t\t\t\trequire.NotNil(t, err)\n\t\t\t\t})\n\n\t\t\t\tt.Run(\"Unimplemented handlers\", func(t *testing.T) {\n\t\t\t\t\tt.Run(\"Collect metrics should return method not implemented error\", func(t *testing.T) {\n\t\t\t\t\t\t_, err = ctx.manager.CollectMetrics(context.Background(), testPluginID)\n\t\t\t\t\t\trequire.Equal(t, ErrMethodNotImplemented, err)\n\t\t\t\t\t})\n\n\t\t\t\t\tt.Run(\"Check health should return method not implemented error\", func(t *testing.T) {\n\t\t\t\t\t\t_, err = ctx.manager.CheckHealth(context.Background(), backend.PluginContext{PluginID: testPluginID})\n\t\t\t\t\t\trequire.Equal(t, ErrMethodNotImplemented, err)\n\t\t\t\t\t})\n\n\t\t\t\t\tt.Run(\"Call resource should return method not implemented error\", func(t *testing.T) {\n\t\t\t\t\t\treq, err := http.NewRequest(http.MethodGet, \"/test\", bytes.NewReader([]byte{}))\n\t\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\t\tw := httptest.NewRecorder()\n\t\t\t\t\t\terr = ctx.manager.callResourceInternal(w, req, backend.PluginContext{PluginID: testPluginID})\n\t\t\t\t\t\trequire.Equal(t, ErrMethodNotImplemented, err)\n\t\t\t\t\t})\n\t\t\t\t})\n\n\t\t\t\tt.Run(\"Implemented handlers\", func(t *testing.T) {\n\t\t\t\t\tt.Run(\"Collect metrics should return expected result\", func(t *testing.T) {\n\t\t\t\t\t\tctx.plugin.CollectMetricsHandlerFunc = backend.CollectMetricsHandlerFunc(func(ctx context.Context) (*backend.CollectMetricsResult, error) {\n\t\t\t\t\t\t\treturn &backend.CollectMetricsResult{\n\t\t\t\t\t\t\t\tPrometheusMetrics: []byte(\"hello\"),\n\t\t\t\t\t\t\t}, nil\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tres, err := ctx.manager.CollectMetrics(context.Background(), testPluginID)\n\t\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\t\trequire.NotNil(t, res)\n\t\t\t\t\t\trequire.Equal(t, \"hello\", string(res.PrometheusMetrics))\n\t\t\t\t\t})\n\n\t\t\t\t\tt.Run(\"Check health should return expected result\", func(t *testing.T) {\n\t\t\t\t\t\tjson := []byte(`{\n\t\t\t\t\t\t\t\"key\": \"value\"\n\t\t\t\t\t\t}`)\n\t\t\t\t\t\tctx.plugin.CheckHealthHandlerFunc = backend.CheckHealthHandlerFunc(func(ctx context.Context, req *backend.CheckHealthRequest) (*backend.CheckHealthResult, error) {\n\t\t\t\t\t\t\treturn &backend.CheckHealthResult{\n\t\t\t\t\t\t\t\tStatus:      backend.HealthStatusOk,\n\t\t\t\t\t\t\t\tMessage:     \"All good\",\n\t\t\t\t\t\t\t\tJSONDetails: json,\n\t\t\t\t\t\t\t}, nil\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tres, err := ctx.manager.CheckHealth(context.Background(), backend.PluginContext{PluginID: testPluginID})\n\t\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\t\trequire.NotNil(t, res)\n\t\t\t\t\t\trequire.Equal(t, backend.HealthStatusOk, res.Status)\n\t\t\t\t\t\trequire.Equal(t, \"All good\", res.Message)\n\t\t\t\t\t\trequire.Equal(t, json, res.JSONDetails)\n\t\t\t\t\t})\n\n\t\t\t\t\tt.Run(\"Call resource should return expected response\", func(t *testing.T) {\n\t\t\t\t\t\tctx.plugin.CallResourceHandlerFunc = backend.CallResourceHandlerFunc(func(ctx context.Context, req *backend.CallResourceRequest, sender backend.CallResourceResponseSender) error {\n\t\t\t\t\t\t\treturn sender.Send(&backend.CallResourceResponse{\n\t\t\t\t\t\t\t\tStatus: http.StatusOK,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\treq, err := http.NewRequest(http.MethodGet, \"/test\", bytes.NewReader([]byte{}))\n\t\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\t\tw := httptest.NewRecorder()\n\t\t\t\t\t\terr = ctx.manager.callResourceInternal(w, req, backend.PluginContext{PluginID: testPluginID})\n\t\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\t\trequire.Equal(t, http.StatusOK, w.Code)\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\t})\n\n\tnewManagerScenario(t, false, func(t *testing.T, ctx *managerScenarioCtx) {\n\t\tt.Run(\"Unmanaged plugin scenario\", func(t *testing.T) {\n\t\t\tctx.license.edition = \"Open Source\"\n\t\t\tctx.license.hasLicense = false\n\t\t\tctx.cfg.BuildVersion = \"7.0.0\"\n\n\t\t\tt.Run(\"Should be able to register plugin\", func(t *testing.T) {\n\t\t\t\terr := ctx.manager.Register(testPluginID, ctx.factory)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.False(t, ctx.plugin.managed)\n\n\t\t\t\tt.Run(\"When manager runs should not start plugin\", func(t *testing.T) {\n\t\t\t\t\tpCtx := context.Background()\n\t\t\t\t\tcCtx, cancel := context.WithCancel(pCtx)\n\t\t\t\t\tvar wg sync.WaitGroup\n\t\t\t\t\twg.Add(1)\n\t\t\t\t\tvar runErr error\n\t\t\t\t\tgo func() {\n\t\t\t\t\t\trunErr = ctx.manager.Run(cCtx)\n\t\t\t\t\t\twg.Done()\n\t\t\t\t\t}()\n\t\t\t\t\tgo func() {\n\t\t\t\t\t\tcancel()\n\t\t\t\t\t}()\n\t\t\t\t\twg.Wait()\n\t\t\t\t\trequire.Equal(t, context.Canceled, runErr)\n\t\t\t\t\trequire.Equal(t, 0, ctx.plugin.startCount)\n\t\t\t\t\trequire.Equal(t, 1, ctx.plugin.stopCount)\n\t\t\t\t})\n\n\t\t\t\tt.Run(\"Should be able to start unmanaged plugin and be restarted when process is killed\", func(t *testing.T) {\n\t\t\t\t\tpCtx := context.Background()\n\t\t\t\t\tcCtx, cancel := context.WithCancel(pCtx)\n\t\t\t\t\tdefer cancel()\n\t\t\t\t\terr := ctx.manager.StartPlugin(cCtx, testPluginID)\n\t\t\t\t\trequire.Nil(t, err)\n\t\t\t\t\trequire.Equal(t, 1, ctx.plugin.startCount)\n\n\t\t\t\t\tvar wg sync.WaitGroup\n\t\t\t\t\twg.Add(1)\n\t\t\t\t\tgo func() {\n\t\t\t\t\t\tctx.plugin.kill()\n\t\t\t\t\t\tfor {\n\t\t\t\t\t\t\tif !ctx.plugin.Exited() {\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\twg.Done()\n\t\t\t\t\t}()\n\t\t\t\t\twg.Wait()\n\t\t\t\t\trequire.Equal(t, 2, ctx.plugin.startCount)\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\t})\n\n\tnewManagerScenario(t, true, func(t *testing.T, ctx *managerScenarioCtx) {\n\t\tt.Run(\"Plugin registration scenario when Grafana is licensed\", func(t *testing.T) {\n\t\t\tctx.license.edition = \"Enterprise\"\n\t\t\tctx.license.hasLicense = true\n\t\t\tctx.license.tokenRaw = \"testtoken\"\n\t\t\tctx.cfg.BuildVersion = \"7.0.0\"\n\t\t\tctx.cfg.EnterpriseLicensePath = \"/license.txt\"\n\n\t\t\terr := ctx.manager.Register(testPluginID, ctx.factory)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tt.Run(\"Should provide expected host environment variables\", func(t *testing.T) {\n\t\t\t\trequire.Len(t, ctx.env, 6)\n\t\t\t\trequire.EqualValues(t, []string{\"GF_VERSION=7.0.0\", \"GF_EDITION=Enterprise\", \"GF_ENTERPRISE_LICENSE_PATH=/license.txt\", \"GF_ENTERPRISE_LICENSE_TEXT=testtoken\", fmt.Sprintf(\"%s=true\", awsds.AssumeRoleEnabledEnvVarKeyName), fmt.Sprintf(\"%s=keys,credentials\", awsds.AllowedAuthProvidersEnvVarKeyName)}, ctx.env)\n\t\t\t})\n\t\t})\n\t})\n}\n\ntype managerScenarioCtx struct {\n\tcfg     *setting.Cfg\n\tlicense *testLicensingService\n\tmanager *manager\n\tfactory PluginFactoryFunc\n\tplugin  *testPlugin\n\tenv     []string\n}\n\nfunc newManagerScenario(t *testing.T, managed bool, fn func(t *testing.T, ctx *managerScenarioCtx)) {\n\tt.Helper()\n\tcfg := setting.NewCfg()\n\tcfg.AWSAllowedAuthProviders = []string{\"keys\", \"credentials\"}\n\tcfg.AWSAssumeRoleEnabled = true\n\n\tlicense := &testLicensingService{}\n\tvalidator := &testPluginRequestValidator{}\n\tctx := &managerScenarioCtx{\n\t\tcfg:     cfg,\n\t\tlicense: license,\n\t\tmanager: &manager{\n\t\t\tCfg:                    cfg,\n\t\t\tLicense:                license,\n\t\t\tPluginRequestValidator: validator,\n\t\t},\n\t}\n\n\terr := ctx.manager.Init()\n\trequire.NoError(t, err)\n\n\tctx.factory = PluginFactoryFunc(func(pluginID string, logger log.Logger, env []string) (Plugin, error) {\n\t\tctx.plugin = &testPlugin{\n\t\t\tpluginID: pluginID,\n\t\t\tlogger:   logger,\n\t\t\tmanaged:  managed,\n\t\t}\n\t\tctx.env = env\n\n\t\treturn ctx.plugin, nil\n\t})\n\n\tfn(t, ctx)\n}\n\ntype testPlugin struct {\n\tpluginID   string\n\tlogger     log.Logger\n\tstartCount int\n\tstopCount  int\n\tmanaged    bool\n\texited     bool\n\tbackend.CollectMetricsHandlerFunc\n\tbackend.CheckHealthHandlerFunc\n\tbackend.CallResourceHandlerFunc\n\tmutex sync.RWMutex\n}\n\nfunc (tp *testPlugin) PluginID() string {\n\treturn tp.pluginID\n}\n\nfunc (tp *testPlugin) Logger() log.Logger {\n\treturn tp.logger\n}\n\nfunc (tp *testPlugin) Start(ctx context.Context) error {\n\ttp.mutex.Lock()\n\tdefer tp.mutex.Unlock()\n\ttp.exited = false\n\ttp.startCount++\n\treturn nil\n}\n\nfunc (tp *testPlugin) Stop(ctx context.Context) error {\n\ttp.mutex.Lock()\n\tdefer tp.mutex.Unlock()\n\ttp.stopCount++\n\treturn nil\n}\n\nfunc (tp *testPlugin) IsManaged() bool {\n\treturn tp.managed\n}\n\nfunc (tp *testPlugin) Exited() bool {\n\ttp.mutex.RLock()\n\tdefer tp.mutex.RUnlock()\n\treturn tp.exited\n}\n\nfunc (tp *testPlugin) kill() {\n\ttp.mutex.Lock()\n\tdefer tp.mutex.Unlock()\n\ttp.exited = true\n}\n\nfunc (tp *testPlugin) CollectMetrics(ctx context.Context) (*backend.CollectMetricsResult, error) {\n\tif tp.CollectMetricsHandlerFunc != nil {\n\t\treturn tp.CollectMetricsHandlerFunc(ctx)\n\t}\n\n\treturn nil, ErrMethodNotImplemented\n}\n\nfunc (tp *testPlugin) CheckHealth(ctx context.Context, req *backend.CheckHealthRequest) (*backend.CheckHealthResult, error) {\n\tif tp.CheckHealthHandlerFunc != nil {\n\t\treturn tp.CheckHealthHandlerFunc(ctx, req)\n\t}\n\n\treturn nil, ErrMethodNotImplemented\n}\n\nfunc (tp *testPlugin) CallResource(ctx context.Context, req *backend.CallResourceRequest, sender backend.CallResourceResponseSender) error {\n\tif tp.CallResourceHandlerFunc != nil {\n\t\treturn tp.CallResourceHandlerFunc(ctx, req, sender)\n\t}\n\n\treturn ErrMethodNotImplemented\n}\n\ntype testLicensingService struct {\n\tedition    string\n\thasLicense bool\n\ttokenRaw   string\n}\n\nfunc (t *testLicensingService) HasLicense() bool {\n\treturn t.hasLicense\n}\n\nfunc (t *testLicensingService) Expiry() int64 {\n\treturn 0\n}\n\nfunc (t *testLicensingService) Edition() string {\n\treturn t.edition\n}\n\nfunc (t *testLicensingService) StateInfo() string {\n\treturn \"\"\n}\n\nfunc (t *testLicensingService) ContentDeliveryPrefix() string {\n\treturn \"\"\n}\n\nfunc (t *testLicensingService) LicenseURL(user *models.SignedInUser) string {\n\treturn \"\"\n}\n\nfunc (t *testLicensingService) HasValidLicense() bool {\n\treturn false\n}\n\nfunc (t *testLicensingService) Environment() map[string]string {\n\treturn map[string]string{\"GF_ENTERPRISE_LICENSE_TEXT\": t.tokenRaw}\n}\n\ntype testPluginRequestValidator struct{}\n\nfunc (t *testPluginRequestValidator) Validate(string, *http.Request) error {\n\treturn nil\n}\n", "package proxyutil\n\nimport (\n\t\"net\"\n\t\"net/http\"\n)\n\n// PrepareProxyRequest prepares a request for being proxied.\n// Removes X-Forwarded-Host, X-Forwarded-Port, X-Forwarded-Proto headers.\n// Set X-Forwarded-For headers.\nfunc PrepareProxyRequest(req *http.Request) {\n\treq.Header.Del(\"X-Forwarded-Host\")\n\treq.Header.Del(\"X-Forwarded-Port\")\n\treq.Header.Del(\"X-Forwarded-Proto\")\n\n\tif req.RemoteAddr != \"\" {\n\t\tremoteAddr, _, err := net.SplitHostPort(req.RemoteAddr)\n\t\tif err != nil {\n\t\t\tremoteAddr = req.RemoteAddr\n\t\t}\n\t\tif req.Header.Get(\"X-Forwarded-For\") != \"\" {\n\t\t\treq.Header.Set(\"X-Forwarded-For\", req.Header.Get(\"X-Forwarded-For\")+\", \"+remoteAddr)\n\t\t} else {\n\t\t\treq.Header.Set(\"X-Forwarded-For\", remoteAddr)\n\t\t}\n\t}\n}\n\n// ClearCookieHeader clear cookie header, except for cookies specified to be kept.\nfunc ClearCookieHeader(req *http.Request, keepCookiesNames []string) {\n\tvar keepCookies []*http.Cookie\n\tfor _, c := range req.Cookies() {\n\t\tfor _, v := range keepCookiesNames {\n\t\t\tif c.Name == v {\n\t\t\t\tkeepCookies = append(keepCookies, c)\n\t\t\t}\n\t\t}\n\t}\n\n\treq.Header.Del(\"Cookie\")\n\tfor _, c := range keepCookies {\n\t\treq.AddCookie(c)\n\t}\n}\n"], "fixing_code": ["package pluginproxy\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/grafana/grafana/pkg/api/datasource\"\n\tglog \"github.com/grafana/grafana/pkg/infra/log\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/plugins\"\n\t\"github.com/grafana/grafana/pkg/services/oauthtoken\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/util\"\n\t\"github.com/grafana/grafana/pkg/util/proxyutil\"\n\t\"github.com/opentracing/opentracing-go\"\n)\n\nvar (\n\tlogger = glog.New(\"data-proxy-log\")\n\tclient = newHTTPClient()\n)\n\ntype DataSourceProxy struct {\n\tds        *models.DataSource\n\tctx       *models.ReqContext\n\ttargetUrl *url.URL\n\tproxyPath string\n\troute     *plugins.AppPluginRoute\n\tplugin    *plugins.DataSourcePlugin\n\tcfg       *setting.Cfg\n}\n\ntype handleResponseTransport struct {\n\ttransport http.RoundTripper\n}\n\nfunc (t *handleResponseTransport) RoundTrip(req *http.Request) (*http.Response, error) {\n\tres, err := t.transport.RoundTrip(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tres.Header.Del(\"Set-Cookie\")\n\tproxyutil.SetProxyResponseHeaders(res.Header)\n\treturn res, nil\n}\n\ntype httpClient interface {\n\tDo(req *http.Request) (*http.Response, error)\n}\n\ntype logWrapper struct {\n\tlogger glog.Logger\n}\n\n// Write writes log messages as bytes from proxy\nfunc (lw *logWrapper) Write(p []byte) (n int, err error) {\n\twithoutNewline := strings.TrimSuffix(string(p), \"\\n\")\n\tlw.logger.Error(\"Data proxy error\", \"error\", withoutNewline)\n\treturn len(p), nil\n}\n\n// NewDataSourceProxy creates a new Datasource proxy\nfunc NewDataSourceProxy(ds *models.DataSource, plugin *plugins.DataSourcePlugin, ctx *models.ReqContext,\n\tproxyPath string, cfg *setting.Cfg) (*DataSourceProxy, error) {\n\ttargetURL, err := datasource.ValidateURL(ds.Type, ds.Url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &DataSourceProxy{\n\t\tds:        ds,\n\t\tplugin:    plugin,\n\t\tctx:       ctx,\n\t\tproxyPath: proxyPath,\n\t\ttargetUrl: targetURL,\n\t\tcfg:       cfg,\n\t}, nil\n}\n\nfunc newHTTPClient() httpClient {\n\treturn &http.Client{\n\t\tTimeout:   30 * time.Second,\n\t\tTransport: &http.Transport{Proxy: http.ProxyFromEnvironment},\n\t}\n}\n\nfunc (proxy *DataSourceProxy) HandleRequest() {\n\tif err := proxy.validateRequest(); err != nil {\n\t\tproxy.ctx.JsonApiErr(403, err.Error(), nil)\n\t\treturn\n\t}\n\n\tproxyErrorLogger := logger.New(\"userId\", proxy.ctx.UserId, \"orgId\", proxy.ctx.OrgId, \"uname\", proxy.ctx.Login,\n\t\t\"path\", proxy.ctx.Req.URL.Path, \"remote_addr\", proxy.ctx.RemoteAddr(), \"referer\", proxy.ctx.Req.Referer())\n\n\ttransport, err := proxy.ds.GetHttpTransport()\n\tif err != nil {\n\t\tproxy.ctx.JsonApiErr(400, \"Unable to load TLS certificate\", err)\n\t\treturn\n\t}\n\n\treverseProxy := &httputil.ReverseProxy{\n\t\tDirector:      proxy.director,\n\t\tFlushInterval: time.Millisecond * 200,\n\t\tErrorLog:      log.New(&logWrapper{logger: proxyErrorLogger}, \"\", 0),\n\t\tTransport: &handleResponseTransport{\n\t\t\ttransport: transport,\n\t\t},\n\t\tModifyResponse: func(resp *http.Response) error {\n\t\t\tif resp.StatusCode == 401 {\n\t\t\t\t// The data source rejected the request as unauthorized, convert to 400 (bad request)\n\t\t\t\tbody, err := ioutil.ReadAll(resp.Body)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"failed to read data source response body: %w\", err)\n\t\t\t\t}\n\t\t\t\t_ = resp.Body.Close()\n\n\t\t\t\tproxyErrorLogger.Info(\"Authentication to data source failed\", \"body\", string(body), \"statusCode\",\n\t\t\t\t\tresp.StatusCode)\n\t\t\t\tmsg := \"Authentication to data source failed\"\n\t\t\t\t*resp = http.Response{\n\t\t\t\t\tStatusCode:    400,\n\t\t\t\t\tStatus:        \"Bad Request\",\n\t\t\t\t\tBody:          ioutil.NopCloser(strings.NewReader(msg)),\n\t\t\t\t\tContentLength: int64(len(msg)),\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n\n\tproxy.logRequest()\n\n\tspan, ctx := opentracing.StartSpanFromContext(proxy.ctx.Req.Context(), \"datasource reverse proxy\")\n\tdefer span.Finish()\n\n\tproxy.ctx.Req.Request = proxy.ctx.Req.WithContext(ctx)\n\n\tspan.SetTag(\"datasource_name\", proxy.ds.Name)\n\tspan.SetTag(\"datasource_type\", proxy.ds.Type)\n\tspan.SetTag(\"user\", proxy.ctx.SignedInUser.Login)\n\tspan.SetTag(\"org_id\", proxy.ctx.SignedInUser.OrgId)\n\n\tproxy.addTraceFromHeaderValue(span, \"X-Panel-Id\", \"panel_id\")\n\tproxy.addTraceFromHeaderValue(span, \"X-Dashboard-Id\", \"dashboard_id\")\n\n\tif err := opentracing.GlobalTracer().Inject(\n\t\tspan.Context(),\n\t\topentracing.HTTPHeaders,\n\t\topentracing.HTTPHeadersCarrier(proxy.ctx.Req.Request.Header)); err != nil {\n\t\tlogger.Error(\"Failed to inject span context instance\", \"err\", err)\n\t}\n\n\treverseProxy.ServeHTTP(proxy.ctx.Resp, proxy.ctx.Req.Request)\n}\n\nfunc (proxy *DataSourceProxy) addTraceFromHeaderValue(span opentracing.Span, headerName string, tagName string) {\n\tpanelId := proxy.ctx.Req.Header.Get(headerName)\n\tdashId, err := strconv.Atoi(panelId)\n\tif err == nil {\n\t\tspan.SetTag(tagName, dashId)\n\t}\n}\n\nfunc (proxy *DataSourceProxy) director(req *http.Request) {\n\treq.URL.Scheme = proxy.targetUrl.Scheme\n\treq.URL.Host = proxy.targetUrl.Host\n\treq.Host = proxy.targetUrl.Host\n\n\treqQueryVals := req.URL.Query()\n\n\tswitch proxy.ds.Type {\n\tcase models.DS_INFLUXDB_08:\n\t\treq.URL.RawPath = util.JoinURLFragments(proxy.targetUrl.Path, \"db/\"+proxy.ds.Database+\"/\"+proxy.proxyPath)\n\t\treqQueryVals.Add(\"u\", proxy.ds.User)\n\t\treqQueryVals.Add(\"p\", proxy.ds.DecryptedPassword())\n\t\treq.URL.RawQuery = reqQueryVals.Encode()\n\tcase models.DS_INFLUXDB:\n\t\treq.URL.RawPath = util.JoinURLFragments(proxy.targetUrl.Path, proxy.proxyPath)\n\t\treq.URL.RawQuery = reqQueryVals.Encode()\n\t\tif !proxy.ds.BasicAuth {\n\t\t\treq.Header.Set(\"Authorization\", util.GetBasicAuthHeader(proxy.ds.User, proxy.ds.DecryptedPassword()))\n\t\t}\n\tdefault:\n\t\treq.URL.RawPath = util.JoinURLFragments(proxy.targetUrl.Path, proxy.proxyPath)\n\t}\n\n\tunescapedPath, err := url.PathUnescape(req.URL.RawPath)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to unescape raw path\", \"rawPath\", req.URL.RawPath, \"error\", err)\n\t\treturn\n\t}\n\n\treq.URL.Path = unescapedPath\n\n\tif proxy.ds.BasicAuth {\n\t\treq.Header.Set(\"Authorization\", util.GetBasicAuthHeader(proxy.ds.BasicAuthUser,\n\t\t\tproxy.ds.DecryptedBasicAuthPassword()))\n\t}\n\n\tdsAuth := req.Header.Get(\"X-DS-Authorization\")\n\tif len(dsAuth) > 0 {\n\t\treq.Header.Del(\"X-DS-Authorization\")\n\t\treq.Header.Set(\"Authorization\", dsAuth)\n\t}\n\n\tapplyUserHeader(proxy.cfg.SendUserHeader, req, proxy.ctx.SignedInUser)\n\n\tkeepCookieNames := []string{}\n\tif proxy.ds.JsonData != nil {\n\t\tif keepCookies := proxy.ds.JsonData.Get(\"keepCookies\"); keepCookies != nil {\n\t\t\tkeepCookieNames = keepCookies.MustStringArray()\n\t\t}\n\t}\n\n\tproxyutil.ClearCookieHeader(req, keepCookieNames)\n\tproxyutil.PrepareProxyRequest(req)\n\n\treq.Header.Set(\"User-Agent\", fmt.Sprintf(\"Grafana/%s\", setting.BuildVersion))\n\n\t// Clear Origin and Referer to avoir CORS issues\n\treq.Header.Del(\"Origin\")\n\treq.Header.Del(\"Referer\")\n\n\tif proxy.route != nil {\n\t\tApplyRoute(proxy.ctx.Req.Context(), req, proxy.proxyPath, proxy.route, proxy.ds)\n\t}\n\n\tif oauthtoken.IsOAuthPassThruEnabled(proxy.ds) {\n\t\tif token := oauthtoken.GetCurrentOAuthToken(proxy.ctx.Req.Context(), proxy.ctx.SignedInUser); token != nil {\n\t\t\treq.Header.Set(\"Authorization\", fmt.Sprintf(\"%s %s\", token.Type(), token.AccessToken))\n\t\t}\n\t}\n}\n\nfunc (proxy *DataSourceProxy) validateRequest() error {\n\tif !checkWhiteList(proxy.ctx, proxy.targetUrl.Host) {\n\t\treturn errors.New(\"target URL is not a valid target\")\n\t}\n\n\tif proxy.ds.Type == models.DS_PROMETHEUS {\n\t\tif proxy.ctx.Req.Request.Method == \"DELETE\" {\n\t\t\treturn errors.New(\"deletes not allowed on proxied Prometheus datasource\")\n\t\t}\n\t\tif proxy.ctx.Req.Request.Method == \"PUT\" {\n\t\t\treturn errors.New(\"puts not allowed on proxied Prometheus datasource\")\n\t\t}\n\t\tif proxy.ctx.Req.Request.Method == \"POST\" && !(proxy.proxyPath == \"api/v1/query\" || proxy.proxyPath == \"api/v1/query_range\" || proxy.proxyPath == \"api/v1/series\" || proxy.proxyPath == \"api/v1/labels\" || proxy.proxyPath == \"api/v1/query_exemplars\") {\n\t\t\treturn errors.New(\"posts not allowed on proxied Prometheus datasource except on /query, /query_range, /series and /labels\")\n\t\t}\n\t}\n\n\tif proxy.ds.Type == models.DS_ES {\n\t\tif proxy.ctx.Req.Request.Method == \"DELETE\" {\n\t\t\treturn errors.New(\"deletes not allowed on proxied Elasticsearch datasource\")\n\t\t}\n\t\tif proxy.ctx.Req.Request.Method == \"PUT\" {\n\t\t\treturn errors.New(\"puts not allowed on proxied Elasticsearch datasource\")\n\t\t}\n\t\tif proxy.ctx.Req.Request.Method == \"POST\" && proxy.proxyPath != \"_msearch\" {\n\t\t\treturn errors.New(\"posts not allowed on proxied Elasticsearch datasource except on /_msearch\")\n\t\t}\n\t}\n\n\t// found route if there are any\n\tif len(proxy.plugin.Routes) > 0 {\n\t\tfor _, route := range proxy.plugin.Routes {\n\t\t\t// method match\n\t\t\tif route.Method != \"\" && route.Method != \"*\" && route.Method != proxy.ctx.Req.Method {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif route.ReqRole.IsValid() {\n\t\t\t\tif !proxy.ctx.HasUserRole(route.ReqRole) {\n\t\t\t\t\treturn errors.New(\"plugin proxy route access denied\")\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif strings.HasPrefix(proxy.proxyPath, route.Path) {\n\t\t\t\tproxy.route = route\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (proxy *DataSourceProxy) logRequest() {\n\tif !setting.DataProxyLogging {\n\t\treturn\n\t}\n\n\tvar body string\n\tif proxy.ctx.Req.Request.Body != nil {\n\t\tbuffer, err := ioutil.ReadAll(proxy.ctx.Req.Request.Body)\n\t\tif err == nil {\n\t\t\tproxy.ctx.Req.Request.Body = ioutil.NopCloser(bytes.NewBuffer(buffer))\n\t\t\tbody = string(buffer)\n\t\t}\n\t}\n\n\tlogger.Info(\"Proxying incoming request\",\n\t\t\"userid\", proxy.ctx.UserId,\n\t\t\"orgid\", proxy.ctx.OrgId,\n\t\t\"username\", proxy.ctx.Login,\n\t\t\"datasource\", proxy.ds.Type,\n\t\t\"uri\", proxy.ctx.Req.RequestURI,\n\t\t\"method\", proxy.ctx.Req.Request.Method,\n\t\t\"body\", body)\n}\n\nfunc checkWhiteList(c *models.ReqContext, host string) bool {\n\tif host != \"\" && len(setting.DataProxyWhiteList) > 0 {\n\t\tif _, exists := setting.DataProxyWhiteList[host]; !exists {\n\t\t\tc.JsonApiErr(403, \"Data proxy hostname and ip are not included in whitelist\", nil)\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n", "package pluginproxy\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/grafana/grafana/pkg/api/datasource\"\n\t\"github.com/grafana/grafana/pkg/components/securejsondata\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"golang.org/x/oauth2\"\n\tmacaron \"gopkg.in/macaron.v1\"\n\n\t\"github.com/grafana/grafana/pkg/bus\"\n\t\"github.com/grafana/grafana/pkg/components/simplejson\"\n\t\"github.com/grafana/grafana/pkg/login/social\"\n\t\"github.com/grafana/grafana/pkg/plugins\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/util\"\n)\n\nfunc TestDataSourceProxy_routeRule(t *testing.T) {\n\tt.Run(\"Plugin with routes\", func(t *testing.T) {\n\t\tplugin := &plugins.DataSourcePlugin{\n\t\t\tRoutes: []*plugins.AppPluginRoute{\n\t\t\t\t{\n\t\t\t\t\tPath:    \"api/v4/\",\n\t\t\t\t\tURL:     \"https://www.google.com\",\n\t\t\t\t\tReqRole: models.ROLE_EDITOR,\n\t\t\t\t\tHeaders: []plugins.AppPluginRouteHeader{\n\t\t\t\t\t\t{Name: \"x-header\", Content: \"my secret {{.SecureJsonData.key}}\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tPath:    \"api/admin\",\n\t\t\t\t\tURL:     \"https://www.google.com\",\n\t\t\t\t\tReqRole: models.ROLE_ADMIN,\n\t\t\t\t\tHeaders: []plugins.AppPluginRouteHeader{\n\t\t\t\t\t\t{Name: \"x-header\", Content: \"my secret {{.SecureJsonData.key}}\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tPath: \"api/anon\",\n\t\t\t\t\tURL:  \"https://www.google.com\",\n\t\t\t\t\tHeaders: []plugins.AppPluginRouteHeader{\n\t\t\t\t\t\t{Name: \"x-header\", Content: \"my secret {{.SecureJsonData.key}}\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tPath: \"api/common\",\n\t\t\t\t\tURL:  \"{{.JsonData.dynamicUrl}}\",\n\t\t\t\t\tURLParams: []plugins.AppPluginRouteURLParam{\n\t\t\t\t\t\t{Name: \"{{.JsonData.queryParam}}\", Content: \"{{.SecureJsonData.key}}\"},\n\t\t\t\t\t},\n\t\t\t\t\tHeaders: []plugins.AppPluginRouteHeader{\n\t\t\t\t\t\t{Name: \"x-header\", Content: \"my secret {{.SecureJsonData.key}}\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tPath:    \"api/restricted\",\n\t\t\t\t\tReqRole: models.ROLE_ADMIN,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\torigSecretKey := setting.SecretKey\n\t\tt.Cleanup(func() {\n\t\t\tsetting.SecretKey = origSecretKey\n\t\t})\n\t\tsetting.SecretKey = \"password\" //nolint:goconst\n\n\t\tkey, err := util.Encrypt([]byte(\"123\"), \"password\")\n\t\trequire.NoError(t, err)\n\n\t\tds := &models.DataSource{\n\t\t\tJsonData: simplejson.NewFromAny(map[string]interface{}{\n\t\t\t\t\"clientId\":   \"asd\",\n\t\t\t\t\"dynamicUrl\": \"https://dynamic.grafana.com\",\n\t\t\t\t\"queryParam\": \"apiKey\",\n\t\t\t}),\n\t\t\tSecureJsonData: map[string][]byte{\n\t\t\t\t\"key\": key,\n\t\t\t},\n\t\t}\n\n\t\tsetUp := func() (*models.ReqContext, *http.Request) {\n\t\t\treq, err := http.NewRequest(\"GET\", \"http://localhost/asd\", nil)\n\t\t\trequire.NoError(t, err)\n\t\t\tctx := &models.ReqContext{\n\t\t\t\tContext: &macaron.Context{\n\t\t\t\t\tReq: macaron.Request{Request: req},\n\t\t\t\t},\n\t\t\t\tSignedInUser: &models.SignedInUser{OrgRole: models.ROLE_EDITOR},\n\t\t\t}\n\t\t\treturn ctx, req\n\t\t}\n\n\t\tt.Run(\"When matching route path\", func(t *testing.T) {\n\t\t\tctx, req := setUp()\n\t\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"api/v4/some/method\", &setting.Cfg{})\n\t\t\trequire.NoError(t, err)\n\t\t\tproxy.route = plugin.Routes[0]\n\t\t\tApplyRoute(proxy.ctx.Req.Context(), req, proxy.proxyPath, proxy.route, proxy.ds)\n\n\t\t\tassert.Equal(t, \"https://www.google.com/some/method\", req.URL.String())\n\t\t\tassert.Equal(t, \"my secret 123\", req.Header.Get(\"x-header\"))\n\t\t})\n\n\t\tt.Run(\"When matching route path and has dynamic url\", func(t *testing.T) {\n\t\t\tctx, req := setUp()\n\t\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"api/common/some/method\", &setting.Cfg{})\n\t\t\trequire.NoError(t, err)\n\t\t\tproxy.route = plugin.Routes[3]\n\t\t\tApplyRoute(proxy.ctx.Req.Context(), req, proxy.proxyPath, proxy.route, proxy.ds)\n\n\t\t\tassert.Equal(t, \"https://dynamic.grafana.com/some/method?apiKey=123\", req.URL.String())\n\t\t\tassert.Equal(t, \"my secret 123\", req.Header.Get(\"x-header\"))\n\t\t})\n\n\t\tt.Run(\"When matching route path with no url\", func(t *testing.T) {\n\t\t\tctx, req := setUp()\n\t\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"\", &setting.Cfg{})\n\t\t\trequire.NoError(t, err)\n\t\t\tproxy.route = plugin.Routes[4]\n\t\t\tApplyRoute(proxy.ctx.Req.Context(), req, proxy.proxyPath, proxy.route, proxy.ds)\n\n\t\t\tassert.Equal(t, \"http://localhost/asd\", req.URL.String())\n\t\t})\n\n\t\tt.Run(\"Validating request\", func(t *testing.T) {\n\t\t\tt.Run(\"plugin route with valid role\", func(t *testing.T) {\n\t\t\t\tctx, _ := setUp()\n\t\t\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"api/v4/some/method\", &setting.Cfg{})\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\terr = proxy.validateRequest()\n\t\t\t\trequire.NoError(t, err)\n\t\t\t})\n\n\t\t\tt.Run(\"plugin route with admin role and user is editor\", func(t *testing.T) {\n\t\t\t\tctx, _ := setUp()\n\t\t\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"api/admin\", &setting.Cfg{})\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\terr = proxy.validateRequest()\n\t\t\t\trequire.Error(t, err)\n\t\t\t})\n\n\t\t\tt.Run(\"plugin route with admin role and user is admin\", func(t *testing.T) {\n\t\t\t\tctx, _ := setUp()\n\t\t\t\tctx.SignedInUser.OrgRole = models.ROLE_ADMIN\n\t\t\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"api/admin\", &setting.Cfg{})\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\terr = proxy.validateRequest()\n\t\t\t\trequire.NoError(t, err)\n\t\t\t})\n\t\t})\n\t})\n\n\tt.Run(\"Plugin with multiple routes for token auth\", func(t *testing.T) {\n\t\tplugin := &plugins.DataSourcePlugin{\n\t\t\tRoutes: []*plugins.AppPluginRoute{\n\t\t\t\t{\n\t\t\t\t\tPath: \"pathwithtoken1\",\n\t\t\t\t\tURL:  \"https://api.nr1.io/some/path\",\n\t\t\t\t\tTokenAuth: &plugins.JwtTokenAuth{\n\t\t\t\t\t\tUrl: \"https://login.server.com/{{.JsonData.tenantId}}/oauth2/token\",\n\t\t\t\t\t\tParams: map[string]string{\n\t\t\t\t\t\t\t\"grant_type\":    \"client_credentials\",\n\t\t\t\t\t\t\t\"client_id\":     \"{{.JsonData.clientId}}\",\n\t\t\t\t\t\t\t\"client_secret\": \"{{.SecureJsonData.clientSecret}}\",\n\t\t\t\t\t\t\t\"resource\":      \"https://api.nr1.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tPath: \"pathwithtoken2\",\n\t\t\t\t\tURL:  \"https://api.nr2.io/some/path\",\n\t\t\t\t\tTokenAuth: &plugins.JwtTokenAuth{\n\t\t\t\t\t\tUrl: \"https://login.server.com/{{.JsonData.tenantId}}/oauth2/token\",\n\t\t\t\t\t\tParams: map[string]string{\n\t\t\t\t\t\t\t\"grant_type\":    \"client_credentials\",\n\t\t\t\t\t\t\t\"client_id\":     \"{{.JsonData.clientId}}\",\n\t\t\t\t\t\t\t\"client_secret\": \"{{.SecureJsonData.clientSecret}}\",\n\t\t\t\t\t\t\t\"resource\":      \"https://api.nr2.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\torigSecretKey := setting.SecretKey\n\t\tt.Cleanup(func() {\n\t\t\tsetting.SecretKey = origSecretKey\n\t\t})\n\t\tsetting.SecretKey = \"password\"\n\n\t\tkey, err := util.Encrypt([]byte(\"123\"), \"password\")\n\t\trequire.NoError(t, err)\n\n\t\tds := &models.DataSource{\n\t\t\tJsonData: simplejson.NewFromAny(map[string]interface{}{\n\t\t\t\t\"clientId\": \"asd\",\n\t\t\t\t\"tenantId\": \"mytenantId\",\n\t\t\t}),\n\t\t\tSecureJsonData: map[string][]byte{\n\t\t\t\t\"clientSecret\": key,\n\t\t\t},\n\t\t}\n\n\t\treq, err := http.NewRequest(\"GET\", \"http://localhost/asd\", nil)\n\t\trequire.NoError(t, err)\n\t\tctx := &models.ReqContext{\n\t\t\tContext: &macaron.Context{\n\t\t\t\tReq: macaron.Request{Request: req},\n\t\t\t},\n\t\t\tSignedInUser: &models.SignedInUser{OrgRole: models.ROLE_EDITOR},\n\t\t}\n\n\t\tt.Run(\"When creating and caching access tokens\", func(t *testing.T) {\n\t\t\tvar authorizationHeaderCall1 string\n\t\t\tvar authorizationHeaderCall2 string\n\n\t\t\tt.Run(\"first call should add authorization header with access token\", func(t *testing.T) {\n\t\t\t\tjson, err := ioutil.ReadFile(\"./test-data/access-token-1.json\")\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tclient = newFakeHTTPClient(t, json)\n\t\t\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"pathwithtoken1\", &setting.Cfg{})\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tApplyRoute(proxy.ctx.Req.Context(), req, proxy.proxyPath, plugin.Routes[0], proxy.ds)\n\n\t\t\t\tauthorizationHeaderCall1 = req.Header.Get(\"Authorization\")\n\t\t\t\tassert.Equal(t, \"https://api.nr1.io/some/path\", req.URL.String())\n\t\t\t\tassert.True(t, strings.HasPrefix(authorizationHeaderCall1, \"Bearer eyJ0e\"))\n\n\t\t\t\tt.Run(\"second call to another route should add a different access token\", func(t *testing.T) {\n\t\t\t\t\tjson2, err := ioutil.ReadFile(\"./test-data/access-token-2.json\")\n\t\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\t\treq, err := http.NewRequest(\"GET\", \"http://localhost/asd\", nil)\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\tclient = newFakeHTTPClient(t, json2)\n\t\t\t\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"pathwithtoken2\", &setting.Cfg{})\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\tApplyRoute(proxy.ctx.Req.Context(), req, proxy.proxyPath, plugin.Routes[1], proxy.ds)\n\n\t\t\t\t\tauthorizationHeaderCall2 = req.Header.Get(\"Authorization\")\n\n\t\t\t\t\tassert.Equal(t, \"https://api.nr2.io/some/path\", req.URL.String())\n\t\t\t\t\tassert.True(t, strings.HasPrefix(authorizationHeaderCall1, \"Bearer eyJ0e\"))\n\t\t\t\t\tassert.True(t, strings.HasPrefix(authorizationHeaderCall2, \"Bearer eyJ0e\"))\n\t\t\t\t\tassert.NotEqual(t, authorizationHeaderCall1, authorizationHeaderCall2)\n\n\t\t\t\t\tt.Run(\"third call to first route should add cached access token\", func(t *testing.T) {\n\t\t\t\t\t\treq, err := http.NewRequest(\"GET\", \"http://localhost/asd\", nil)\n\t\t\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\t\t\tclient = newFakeHTTPClient(t, []byte{})\n\t\t\t\t\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"pathwithtoken1\", &setting.Cfg{})\n\t\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\t\tApplyRoute(proxy.ctx.Req.Context(), req, proxy.proxyPath, plugin.Routes[0], proxy.ds)\n\n\t\t\t\t\t\tauthorizationHeaderCall3 := req.Header.Get(\"Authorization\")\n\t\t\t\t\t\tassert.Equal(t, \"https://api.nr1.io/some/path\", req.URL.String())\n\t\t\t\t\t\tassert.True(t, strings.HasPrefix(authorizationHeaderCall1, \"Bearer eyJ0e\"))\n\t\t\t\t\t\tassert.True(t, strings.HasPrefix(authorizationHeaderCall3, \"Bearer eyJ0e\"))\n\t\t\t\t\t\tassert.Equal(t, authorizationHeaderCall1, authorizationHeaderCall3)\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\t})\n\n\tt.Run(\"When proxying graphite\", func(t *testing.T) {\n\t\torigBuildVer := setting.BuildVersion\n\t\tt.Cleanup(func() {\n\t\t\tsetting.BuildVersion = origBuildVer\n\t\t})\n\t\tsetting.BuildVersion = \"5.3.0\"\n\n\t\tplugin := &plugins.DataSourcePlugin{}\n\t\tds := &models.DataSource{Url: \"htttp://graphite:8080\", Type: models.DS_GRAPHITE}\n\t\tctx := &models.ReqContext{}\n\n\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"/render\", &setting.Cfg{})\n\t\trequire.NoError(t, err)\n\t\treq, err := http.NewRequest(http.MethodGet, \"http://grafana.com/sub\", nil)\n\t\trequire.NoError(t, err)\n\n\t\tproxy.director(req)\n\n\t\tt.Run(\"Can translate request URL and path\", func(t *testing.T) {\n\t\t\tassert.Equal(t, \"graphite:8080\", req.URL.Host)\n\t\t\tassert.Equal(t, \"/render\", req.URL.Path)\n\t\t\tassert.Equal(t, \"Grafana/5.3.0\", req.Header.Get(\"User-Agent\"))\n\t\t})\n\t})\n\n\tt.Run(\"When proxying InfluxDB\", func(t *testing.T) {\n\t\tplugin := &plugins.DataSourcePlugin{}\n\n\t\tds := &models.DataSource{\n\t\t\tType:     models.DS_INFLUXDB_08,\n\t\t\tUrl:      \"http://influxdb:8083\",\n\t\t\tDatabase: \"site\",\n\t\t\tUser:     \"user\",\n\t\t\tPassword: \"password\",\n\t\t}\n\n\t\tctx := &models.ReqContext{}\n\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"\", &setting.Cfg{})\n\t\trequire.NoError(t, err)\n\n\t\treq, err := http.NewRequest(http.MethodGet, \"http://grafana.com/sub\", nil)\n\t\trequire.NoError(t, err)\n\n\t\tproxy.director(req)\n\t\tassert.Equal(t, \"/db/site/\", req.URL.Path)\n\t})\n\n\tt.Run(\"When proxying a data source with no keepCookies specified\", func(t *testing.T) {\n\t\tplugin := &plugins.DataSourcePlugin{}\n\n\t\tjson, err := simplejson.NewJson([]byte(`{\"keepCookies\": []}`))\n\t\trequire.NoError(t, err)\n\n\t\tds := &models.DataSource{\n\t\t\tType:     models.DS_GRAPHITE,\n\t\t\tUrl:      \"http://graphite:8086\",\n\t\t\tJsonData: json,\n\t\t}\n\n\t\tctx := &models.ReqContext{}\n\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"\", &setting.Cfg{})\n\t\trequire.NoError(t, err)\n\n\t\trequestURL, err := url.Parse(\"http://grafana.com/sub\")\n\t\trequire.NoError(t, err)\n\t\treq := http.Request{URL: requestURL, Header: make(http.Header)}\n\t\tcookies := \"grafana_user=admin; grafana_remember=99; grafana_sess=11; JSESSION_ID=test\"\n\t\treq.Header.Set(\"Cookie\", cookies)\n\n\t\tproxy.director(&req)\n\n\t\tassert.Equal(t, \"\", req.Header.Get(\"Cookie\"))\n\t})\n\n\tt.Run(\"When proxying a data source with keep cookies specified\", func(t *testing.T) {\n\t\tplugin := &plugins.DataSourcePlugin{}\n\n\t\tjson, err := simplejson.NewJson([]byte(`{\"keepCookies\": [\"JSESSION_ID\"]}`))\n\t\trequire.NoError(t, err)\n\n\t\tds := &models.DataSource{\n\t\t\tType:     models.DS_GRAPHITE,\n\t\t\tUrl:      \"http://graphite:8086\",\n\t\t\tJsonData: json,\n\t\t}\n\n\t\tctx := &models.ReqContext{}\n\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"\", &setting.Cfg{})\n\t\trequire.NoError(t, err)\n\n\t\trequestURL, err := url.Parse(\"http://grafana.com/sub\")\n\t\trequire.NoError(t, err)\n\t\treq := http.Request{URL: requestURL, Header: make(http.Header)}\n\t\tcookies := \"grafana_user=admin; grafana_remember=99; grafana_sess=11; JSESSION_ID=test\"\n\t\treq.Header.Set(\"Cookie\", cookies)\n\n\t\tproxy.director(&req)\n\n\t\tassert.Equal(t, \"JSESSION_ID=test\", req.Header.Get(\"Cookie\"))\n\t})\n\n\tt.Run(\"When proxying a custom datasource\", func(t *testing.T) {\n\t\tplugin := &plugins.DataSourcePlugin{}\n\t\tds := &models.DataSource{\n\t\t\tType: \"custom-datasource\",\n\t\t\tUrl:  \"http://host/root/\",\n\t\t}\n\t\tctx := &models.ReqContext{}\n\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"/path/to/folder/\", &setting.Cfg{})\n\t\trequire.NoError(t, err)\n\t\treq, err := http.NewRequest(http.MethodGet, \"http://grafana.com/sub\", nil)\n\t\treq.Header.Set(\"Origin\", \"grafana.com\")\n\t\treq.Header.Set(\"Referer\", \"grafana.com\")\n\t\treq.Header.Set(\"X-Canary\", \"stillthere\")\n\t\trequire.NoError(t, err)\n\n\t\tproxy.director(req)\n\n\t\tassert.Equal(t, \"http://host/root/path/to/folder/\", req.URL.String())\n\n\t\tassert.Empty(t, req.Header.Get(\"Origin\"))\n\t\tassert.Empty(t, req.Header.Get(\"Referer\"))\n\t\tassert.Equal(t, \"stillthere\", req.Header.Get(\"X-Canary\"))\n\t})\n\n\tt.Run(\"When proxying a datasource that has OAuth token pass-through enabled\", func(t *testing.T) {\n\t\tsocial.SocialMap[\"generic_oauth\"] = &social.SocialGenericOAuth{\n\t\t\tSocialBase: &social.SocialBase{\n\t\t\t\tConfig: &oauth2.Config{},\n\t\t\t},\n\t\t}\n\t\torigAuthSvc := setting.OAuthService\n\t\tt.Cleanup(func() {\n\t\t\tsetting.OAuthService = origAuthSvc\n\t\t})\n\t\tsetting.OAuthService = &setting.OAuther{}\n\t\tsetting.OAuthService.OAuthInfos = make(map[string]*setting.OAuthInfo)\n\t\tsetting.OAuthService.OAuthInfos[\"generic_oauth\"] = &setting.OAuthInfo{}\n\n\t\tbus.AddHandler(\"test\", func(query *models.GetAuthInfoQuery) error {\n\t\t\tquery.Result = &models.UserAuth{\n\t\t\t\tId:                1,\n\t\t\t\tUserId:            1,\n\t\t\t\tAuthModule:        \"generic_oauth\",\n\t\t\t\tOAuthAccessToken:  \"testtoken\",\n\t\t\t\tOAuthRefreshToken: \"testrefreshtoken\",\n\t\t\t\tOAuthTokenType:    \"Bearer\",\n\t\t\t\tOAuthExpiry:       time.Now().AddDate(0, 0, 1),\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\n\t\tplugin := &plugins.DataSourcePlugin{}\n\t\tds := &models.DataSource{\n\t\t\tType: \"custom-datasource\",\n\t\t\tUrl:  \"http://host/root/\",\n\t\t\tJsonData: simplejson.NewFromAny(map[string]interface{}{\n\t\t\t\t\"oauthPassThru\": true,\n\t\t\t}),\n\t\t}\n\n\t\treq, err := http.NewRequest(\"GET\", \"http://localhost/asd\", nil)\n\t\trequire.NoError(t, err)\n\t\tctx := &models.ReqContext{\n\t\t\tSignedInUser: &models.SignedInUser{UserId: 1},\n\t\t\tContext: &macaron.Context{\n\t\t\t\tReq: macaron.Request{Request: req},\n\t\t\t},\n\t\t}\n\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"/path/to/folder/\", &setting.Cfg{})\n\t\trequire.NoError(t, err)\n\t\treq, err = http.NewRequest(http.MethodGet, \"http://grafana.com/sub\", nil)\n\t\trequire.NoError(t, err)\n\n\t\tproxy.director(req)\n\n\t\tassert.Equal(t, \"Bearer testtoken\", req.Header.Get(\"Authorization\"))\n\t})\n\n\tt.Run(\"When SendUserHeader config is enabled\", func(t *testing.T) {\n\t\treq := getDatasourceProxiedRequest(\n\t\t\tt,\n\t\t\t&models.ReqContext{\n\t\t\t\tSignedInUser: &models.SignedInUser{\n\t\t\t\t\tLogin: \"test_user\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t&setting.Cfg{SendUserHeader: true},\n\t\t)\n\t\tassert.Equal(t, \"test_user\", req.Header.Get(\"X-Grafana-User\"))\n\t})\n\n\tt.Run(\"When SendUserHeader config is disabled\", func(t *testing.T) {\n\t\treq := getDatasourceProxiedRequest(\n\t\t\tt,\n\t\t\t&models.ReqContext{\n\t\t\t\tSignedInUser: &models.SignedInUser{\n\t\t\t\t\tLogin: \"test_user\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t&setting.Cfg{SendUserHeader: false},\n\t\t)\n\t\t// Get will return empty string even if header is not set\n\t\tassert.Empty(t, req.Header.Get(\"X-Grafana-User\"))\n\t})\n\n\tt.Run(\"When SendUserHeader config is enabled but user is anonymous\", func(t *testing.T) {\n\t\treq := getDatasourceProxiedRequest(\n\t\t\tt,\n\t\t\t&models.ReqContext{\n\t\t\t\tSignedInUser: &models.SignedInUser{IsAnonymous: true},\n\t\t\t},\n\t\t\t&setting.Cfg{SendUserHeader: true},\n\t\t)\n\t\t// Get will return empty string even if header is not set\n\t\tassert.Empty(t, req.Header.Get(\"X-Grafana-User\"))\n\t})\n\n\tt.Run(\"When proxying data source proxy should handle authentication\", func(t *testing.T) {\n\t\ttests := []*testCase{\n\t\t\tcreateAuthTest(t, models.DS_INFLUXDB_08, authTypePassword, authCheckQuery, false),\n\t\t\tcreateAuthTest(t, models.DS_INFLUXDB_08, authTypePassword, authCheckQuery, true),\n\t\t\tcreateAuthTest(t, models.DS_INFLUXDB, authTypePassword, authCheckHeader, true),\n\t\t\tcreateAuthTest(t, models.DS_INFLUXDB, authTypePassword, authCheckHeader, false),\n\t\t\tcreateAuthTest(t, models.DS_INFLUXDB, authTypeBasic, authCheckHeader, true),\n\t\t\tcreateAuthTest(t, models.DS_INFLUXDB, authTypeBasic, authCheckHeader, false),\n\n\t\t\t// These two should be enough for any other datasource at the moment. Proxy has special handling\n\t\t\t// only for Influx, others have the same path and only BasicAuth. Non BasicAuth datasources\n\t\t\t// do not go through proxy but through TSDB API which is not tested here.\n\t\t\tcreateAuthTest(t, models.DS_ES, authTypeBasic, authCheckHeader, false),\n\t\t\tcreateAuthTest(t, models.DS_ES, authTypeBasic, authCheckHeader, true),\n\t\t}\n\t\tfor _, test := range tests {\n\t\t\tmodels.ClearDSDecryptionCache()\n\t\t\trunDatasourceAuthTest(t, test)\n\t\t}\n\t})\n}\n\n// test DataSourceProxy request handling.\nfunc TestDataSourceProxy_requestHandling(t *testing.T) {\n\tvar writeErr error\n\n\tplugin := &plugins.DataSourcePlugin{}\n\n\ttype setUpCfg struct {\n\t\theaders map[string]string\n\t\twriteCb func(w http.ResponseWriter, r *http.Request)\n\t}\n\n\tsetUp := func(t *testing.T, cfgs ...setUpCfg) (*models.ReqContext, *models.DataSource) {\n\t\twriteErr = nil\n\n\t\tbackend := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\thttp.SetCookie(w, &http.Cookie{Name: \"flavor\", Value: \"chocolateChip\"})\n\t\t\twritten := false\n\t\t\tfor _, cfg := range cfgs {\n\t\t\t\tif cfg.writeCb != nil {\n\t\t\t\t\tt.Log(\"Writing response via callback\")\n\t\t\t\t\tcfg.writeCb(w, r)\n\t\t\t\t\twritten = true\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !written {\n\t\t\t\tt.Log(\"Writing default response\")\n\t\t\t\tw.WriteHeader(200)\n\t\t\t\t_, writeErr = w.Write([]byte(\"I am the backend\"))\n\t\t\t}\n\t\t}))\n\t\tt.Cleanup(backend.Close)\n\n\t\tds := &models.DataSource{Url: backend.URL, Type: models.DS_GRAPHITE, Name: \"graphite\"}\n\n\t\tresponseRecorder := &closeNotifierResponseRecorder{\n\t\t\tResponseRecorder: httptest.NewRecorder(),\n\t\t}\n\t\tt.Cleanup(responseRecorder.Close)\n\n\t\tresponseWriter := macaron.NewResponseWriter(\"GET\", responseRecorder)\n\n\t\t// XXX: Really unsure why, but setting headers within the HTTP handler function doesn't stick,\n\t\t// so doing it here instead\n\t\tfor _, cfg := range cfgs {\n\t\t\tfor k, v := range cfg.headers {\n\t\t\t\tresponseWriter.Header().Set(k, v)\n\t\t\t}\n\t\t}\n\n\t\treturn &models.ReqContext{\n\t\t\tSignedInUser: &models.SignedInUser{},\n\t\t\tContext: &macaron.Context{\n\t\t\t\tReq: macaron.Request{\n\t\t\t\t\tRequest: httptest.NewRequest(\"GET\", \"/render\", nil),\n\t\t\t\t},\n\t\t\t\tResp: responseWriter,\n\t\t\t},\n\t\t}, ds\n\t}\n\n\tt.Run(\"When response header Set-Cookie is not set should remove proxied Set-Cookie header\", func(t *testing.T) {\n\t\tctx, ds := setUp(t)\n\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"/render\", &setting.Cfg{})\n\t\trequire.NoError(t, err)\n\n\t\tproxy.HandleRequest()\n\n\t\trequire.NoError(t, writeErr)\n\t\tassert.Empty(t, proxy.ctx.Resp.Header().Get(\"Set-Cookie\"))\n\t})\n\n\tt.Run(\"When response header Set-Cookie is set should remove proxied Set-Cookie header and restore the original Set-Cookie header\", func(t *testing.T) {\n\t\tctx, ds := setUp(t, setUpCfg{\n\t\t\theaders: map[string]string{\n\t\t\t\t\"Set-Cookie\": \"important_cookie=important_value\",\n\t\t\t},\n\t\t})\n\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"/render\", &setting.Cfg{})\n\t\trequire.NoError(t, err)\n\n\t\tproxy.HandleRequest()\n\n\t\trequire.NoError(t, writeErr)\n\t\tassert.Equal(t, \"important_cookie=important_value\", proxy.ctx.Resp.Header().Get(\"Set-Cookie\"))\n\t})\n\n\tt.Run(\"When response should set Content-Security-Policy header\", func(t *testing.T) {\n\t\tctx, ds := setUp(t)\n\t\tdsPlugin := &plugins.DataSourcePlugin{}\n\t\tproxy, err := NewDataSourceProxy(ds, dsPlugin, ctx, \"/render\", &setting.Cfg{})\n\t\trequire.NoError(t, err)\n\n\t\tproxy.HandleRequest()\n\n\t\trequire.NoError(t, writeErr)\n\t\tassert.Equal(t, \"sandbox\", proxy.ctx.Resp.Header().Get(\"Content-Security-Policy\"))\n\t})\n\n\tt.Run(\"Data source returns status code 401\", func(t *testing.T) {\n\t\tctx, ds := setUp(t, setUpCfg{\n\t\t\twriteCb: func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tw.WriteHeader(401)\n\t\t\t\tw.Header().Set(\"www-authenticate\", `Basic realm=\"Access to the server\"`)\n\t\t\t\t_, err := w.Write([]byte(\"Not authenticated\"))\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tt.Log(\"Wrote 401 response\")\n\t\t\t},\n\t\t})\n\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"/render\", &setting.Cfg{})\n\t\trequire.NoError(t, err)\n\n\t\tproxy.HandleRequest()\n\n\t\trequire.NoError(t, writeErr)\n\t\tassert.Equal(t, 400, proxy.ctx.Resp.Status(), \"Status code 401 should be converted to 400\")\n\t\tassert.Empty(t, proxy.ctx.Resp.Header().Get(\"www-authenticate\"))\n\t})\n\n\tt.Run(\"Data source should handle proxy path url encoding correctly\", func(t *testing.T) {\n\t\tvar req *http.Request\n\t\tctx, ds := setUp(t, setUpCfg{\n\t\t\twriteCb: func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\treq = r\n\t\t\t\tw.WriteHeader(200)\n\t\t\t\t_, err := w.Write([]byte(\"OK\"))\n\t\t\t\trequire.NoError(t, err)\n\t\t\t},\n\t\t})\n\n\t\tctx.Req.Request = httptest.NewRequest(\"GET\", \"/api/datasources/proxy/1/path/%2Ftest%2Ftest%2F?query=%2Ftest%2Ftest%2F\", nil)\n\t\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"/path/%2Ftest%2Ftest%2F\", &setting.Cfg{})\n\t\trequire.NoError(t, err)\n\n\t\tproxy.HandleRequest()\n\n\t\trequire.NoError(t, writeErr)\n\t\trequire.NotNil(t, req)\n\t\trequire.Equal(t, \"/path/%2Ftest%2Ftest%2F?query=%2Ftest%2Ftest%2F\", req.RequestURI)\n\t})\n}\n\nfunc TestNewDataSourceProxy_InvalidURL(t *testing.T) {\n\tctx := models.ReqContext{\n\t\tContext: &macaron.Context{\n\t\t\tReq: macaron.Request{},\n\t\t},\n\t\tSignedInUser: &models.SignedInUser{OrgRole: models.ROLE_EDITOR},\n\t}\n\tds := models.DataSource{\n\t\tType: \"test\",\n\t\tUrl:  \"://host/root\",\n\t}\n\tcfg := setting.Cfg{}\n\tplugin := plugins.DataSourcePlugin{}\n\t_, err := NewDataSourceProxy(&ds, &plugin, &ctx, \"api/method\", &cfg)\n\trequire.Error(t, err)\n\tassert.True(t, strings.HasPrefix(err.Error(), `validation of data source URL \"://host/root\" failed`))\n}\n\nfunc TestNewDataSourceProxy_ProtocolLessURL(t *testing.T) {\n\tctx := models.ReqContext{\n\t\tContext: &macaron.Context{\n\t\t\tReq: macaron.Request{},\n\t\t},\n\t\tSignedInUser: &models.SignedInUser{OrgRole: models.ROLE_EDITOR},\n\t}\n\tds := models.DataSource{\n\t\tType: \"test\",\n\t\tUrl:  \"127.0.01:5432\",\n\t}\n\tcfg := setting.Cfg{}\n\tplugin := plugins.DataSourcePlugin{}\n\n\t_, err := NewDataSourceProxy(&ds, &plugin, &ctx, \"api/method\", &cfg)\n\n\trequire.NoError(t, err)\n}\n\n// Test wth MSSQL type data sources.\nfunc TestNewDataSourceProxy_MSSQL(t *testing.T) {\n\tctx := models.ReqContext{\n\t\tContext: &macaron.Context{\n\t\t\tReq: macaron.Request{},\n\t\t},\n\t\tSignedInUser: &models.SignedInUser{OrgRole: models.ROLE_EDITOR},\n\t}\n\ttcs := []struct {\n\t\tdescription string\n\t\turl         string\n\t\terr         error\n\t}{\n\t\t{\n\t\t\tdescription: \"Valid ODBC URL\",\n\t\t\turl:         `localhost\\instance:1433`,\n\t\t},\n\t\t{\n\t\t\tdescription: \"Invalid ODBC URL\",\n\t\t\turl:         `localhost\\instance::1433`,\n\t\t\terr: datasource.URLValidationError{\n\t\t\t\tErr: fmt.Errorf(`unrecognized MSSQL URL format: \"localhost\\\\instance::1433\"`),\n\t\t\t\tURL: `localhost\\instance::1433`,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range tcs {\n\t\tt.Run(tc.description, func(t *testing.T) {\n\t\t\tcfg := setting.Cfg{}\n\t\t\tplugin := plugins.DataSourcePlugin{}\n\t\t\tds := models.DataSource{\n\t\t\t\tType: \"mssql\",\n\t\t\t\tUrl:  tc.url,\n\t\t\t}\n\n\t\t\tp, err := NewDataSourceProxy(&ds, &plugin, &ctx, \"api/method\", &cfg)\n\t\t\tif tc.err == nil {\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.Equal(t, &url.URL{\n\t\t\t\t\tScheme: \"sqlserver\",\n\t\t\t\t\tHost:   ds.Url,\n\t\t\t\t}, p.targetUrl)\n\t\t\t} else {\n\t\t\t\trequire.Error(t, err)\n\t\t\t\tassert.Equal(t, tc.err, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\ntype closeNotifierResponseRecorder struct {\n\t*httptest.ResponseRecorder\n\tcloseChan chan bool\n}\n\nfunc (r *closeNotifierResponseRecorder) CloseNotify() <-chan bool {\n\tr.closeChan = make(chan bool)\n\treturn r.closeChan\n}\n\nfunc (r *closeNotifierResponseRecorder) Close() {\n\tclose(r.closeChan)\n}\n\n// getDatasourceProxiedRequest is a helper for easier setup of tests based on global config and ReqContext.\nfunc getDatasourceProxiedRequest(t *testing.T, ctx *models.ReqContext, cfg *setting.Cfg) *http.Request {\n\tplugin := &plugins.DataSourcePlugin{}\n\n\tds := &models.DataSource{\n\t\tType: \"custom\",\n\t\tUrl:  \"http://host/root/\",\n\t}\n\n\tproxy, err := NewDataSourceProxy(ds, plugin, ctx, \"\", cfg)\n\trequire.NoError(t, err)\n\treq, err := http.NewRequest(http.MethodGet, \"http://grafana.com/sub\", nil)\n\trequire.NoError(t, err)\n\n\tproxy.director(req)\n\treturn req\n}\n\ntype httpClientStub struct {\n\tt        *testing.T\n\tfakeBody []byte\n}\n\nfunc (c *httpClientStub) Do(req *http.Request) (*http.Response, error) {\n\tbodyJSON, err := simplejson.NewJson(c.fakeBody)\n\trequire.NoError(c.t, err)\n\t_, passedTokenCacheTest := bodyJSON.CheckGet(\"expires_on\")\n\trequire.True(c.t, passedTokenCacheTest)\n\n\tbodyJSON.Set(\"expires_on\", fmt.Sprint(time.Now().Add(time.Second*60).Unix()))\n\tbody, err := bodyJSON.MarshalJSON()\n\trequire.NoError(c.t, err)\n\tresp := &http.Response{\n\t\tBody: ioutil.NopCloser(bytes.NewReader(body)),\n\t}\n\n\treturn resp, nil\n}\n\nfunc newFakeHTTPClient(t *testing.T, fakeBody []byte) httpClient {\n\treturn &httpClientStub{\n\t\tt:        t,\n\t\tfakeBody: fakeBody,\n\t}\n}\n\ntype testCase struct {\n\tdatasource *models.DataSource\n\tcheckReq   func(req *http.Request)\n}\n\nconst (\n\tauthTypePassword = \"password\"\n\tauthTypeBasic    = \"basic\"\n)\n\nconst (\n\tauthCheckQuery  = \"query\"\n\tauthCheckHeader = \"header\"\n)\n\nfunc createAuthTest(t *testing.T, dsType string, authType string, authCheck string, useSecureJsonData bool) *testCase {\n\t// Basic user:password\n\tbase64AuthHeader := \"Basic dXNlcjpwYXNzd29yZA==\"\n\n\ttest := &testCase{\n\t\tdatasource: &models.DataSource{\n\t\t\tType:     dsType,\n\t\t\tJsonData: simplejson.New(),\n\t\t},\n\t}\n\tvar message string\n\tif authType == authTypePassword {\n\t\tmessage = fmt.Sprintf(\"%v should add username and password\", dsType)\n\t\ttest.datasource.User = \"user\"\n\t\tif useSecureJsonData {\n\t\t\ttest.datasource.SecureJsonData = securejsondata.GetEncryptedJsonData(map[string]string{\n\t\t\t\t\"password\": \"password\",\n\t\t\t})\n\t\t} else {\n\t\t\ttest.datasource.Password = \"password\"\n\t\t}\n\t} else {\n\t\tmessage = fmt.Sprintf(\"%v should add basic auth username and password\", dsType)\n\t\ttest.datasource.BasicAuth = true\n\t\ttest.datasource.BasicAuthUser = \"user\"\n\t\tif useSecureJsonData {\n\t\t\ttest.datasource.SecureJsonData = securejsondata.GetEncryptedJsonData(map[string]string{\n\t\t\t\t\"basicAuthPassword\": \"password\",\n\t\t\t})\n\t\t} else {\n\t\t\ttest.datasource.BasicAuthPassword = \"password\"\n\t\t}\n\t}\n\n\tif useSecureJsonData {\n\t\tmessage += \" from securejsondata\"\n\t}\n\n\tif authCheck == authCheckQuery {\n\t\tmessage += \" to query params\"\n\t\ttest.checkReq = func(req *http.Request) {\n\t\t\tqueryVals := req.URL.Query()\n\t\t\tassert.Equal(t, \"user\", queryVals[\"u\"][0], message)\n\t\t\tassert.Equal(t, \"password\", queryVals[\"p\"][0], message)\n\t\t}\n\t} else {\n\t\tmessage += \" to auth header\"\n\t\ttest.checkReq = func(req *http.Request) {\n\t\t\tassert.Equal(t, base64AuthHeader, req.Header.Get(\"Authorization\"), message)\n\t\t}\n\t}\n\n\treturn test\n}\n\nfunc runDatasourceAuthTest(t *testing.T, test *testCase) {\n\tplugin := &plugins.DataSourcePlugin{}\n\tctx := &models.ReqContext{}\n\tproxy, err := NewDataSourceProxy(test.datasource, plugin, ctx, \"\", &setting.Cfg{})\n\trequire.NoError(t, err)\n\n\treq, err := http.NewRequest(http.MethodGet, \"http://grafana.com/sub\", nil)\n\trequire.NoError(t, err)\n\n\tproxy.director(req)\n\n\ttest.checkReq(req)\n}\n", "package pluginproxy\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"net/url\"\n\n\t\"github.com/grafana/grafana/pkg/bus\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/plugins\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/util\"\n\t\"github.com/grafana/grafana/pkg/util/proxyutil\"\n)\n\ntype templateData struct {\n\tJsonData       map[string]interface{}\n\tSecureJsonData map[string]string\n}\n\n// NewApiPluginProxy create a plugin proxy\nfunc NewApiPluginProxy(ctx *models.ReqContext, proxyPath string, route *plugins.AppPluginRoute, appID string, cfg *setting.Cfg) *httputil.ReverseProxy {\n\tdirector := func(req *http.Request) {\n\t\tquery := models.GetPluginSettingByIdQuery{OrgId: ctx.OrgId, PluginId: appID}\n\t\tif err := bus.Dispatch(&query); err != nil {\n\t\t\tctx.JsonApiErr(500, \"Failed to fetch plugin settings\", err)\n\t\t\treturn\n\t\t}\n\n\t\tdata := templateData{\n\t\t\tJsonData:       query.Result.JsonData,\n\t\t\tSecureJsonData: query.Result.SecureJsonData.Decrypt(),\n\t\t}\n\n\t\tinterpolatedURL, err := interpolateString(route.URL, data)\n\t\tif err != nil {\n\t\t\tctx.JsonApiErr(500, \"Could not interpolate plugin route url\", err)\n\t\t\treturn\n\t\t}\n\t\ttargetURL, err := url.Parse(interpolatedURL)\n\t\tif err != nil {\n\t\t\tctx.JsonApiErr(500, \"Could not parse url\", err)\n\t\t\treturn\n\t\t}\n\t\treq.URL.Scheme = targetURL.Scheme\n\t\treq.URL.Host = targetURL.Host\n\t\treq.Host = targetURL.Host\n\t\treq.URL.Path = util.JoinURLFragments(targetURL.Path, proxyPath)\n\n\t\t// clear cookie headers\n\t\treq.Header.Del(\"Cookie\")\n\t\treq.Header.Del(\"Set-Cookie\")\n\n\t\tproxyutil.PrepareProxyRequest(req)\n\n\t\t// Create a HTTP header with the context in it.\n\t\tctxJSON, err := json.Marshal(ctx.SignedInUser)\n\t\tif err != nil {\n\t\t\tctx.JsonApiErr(500, \"failed to marshal context to json.\", err)\n\t\t\treturn\n\t\t}\n\n\t\treq.Header.Set(\"X-Grafana-Context\", string(ctxJSON))\n\n\t\tapplyUserHeader(cfg.SendUserHeader, req, ctx.SignedInUser)\n\n\t\tif err := addHeaders(&req.Header, route, data); err != nil {\n\t\t\tctx.JsonApiErr(500, \"Failed to render plugin headers\", err)\n\t\t\treturn\n\t\t}\n\t}\n\n\treturn &httputil.ReverseProxy{Director: director, ModifyResponse: modifyResponse}\n}\n\nfunc modifyResponse(resp *http.Response) error {\n\tproxyutil.SetProxyResponseHeaders(resp.Header)\n\n\treturn nil\n}\n", "package pluginproxy\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"github.com/grafana/grafana/pkg/bus\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/plugins\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/util\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\tmacaron \"gopkg.in/macaron.v1\"\n)\n\nfunc TestPluginProxy(t *testing.T) {\n\tt.Run(\"When getting proxy headers\", func(t *testing.T) {\n\t\troute := &plugins.AppPluginRoute{\n\t\t\tHeaders: []plugins.AppPluginRouteHeader{\n\t\t\t\t{Name: \"x-header\", Content: \"my secret {{.SecureJsonData.key}}\"},\n\t\t\t},\n\t\t}\n\n\t\tsetting.SecretKey = \"password\"\n\n\t\tbus.AddHandler(\"test\", func(query *models.GetPluginSettingByIdQuery) error {\n\t\t\tkey, err := util.Encrypt([]byte(\"123\"), \"password\")\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tquery.Result = &models.PluginSetting{\n\t\t\t\tSecureJsonData: map[string][]byte{\n\t\t\t\t\t\"key\": key,\n\t\t\t\t},\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\n\t\treq := getPluginProxiedRequest(\n\t\t\tt,\n\t\t\t&models.ReqContext{\n\t\t\t\tSignedInUser: &models.SignedInUser{\n\t\t\t\t\tLogin: \"test_user\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t&setting.Cfg{SendUserHeader: true},\n\t\t\troute,\n\t\t)\n\n\t\tassert.Equal(t, \"my secret 123\", req.Header.Get(\"x-header\"))\n\t})\n\n\tt.Run(\"When SendUserHeader config is enabled\", func(t *testing.T) {\n\t\treq := getPluginProxiedRequest(\n\t\t\tt,\n\t\t\t&models.ReqContext{\n\t\t\t\tSignedInUser: &models.SignedInUser{\n\t\t\t\t\tLogin: \"test_user\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t&setting.Cfg{SendUserHeader: true},\n\t\t\tnil,\n\t\t)\n\n\t\t// Get will return empty string even if header is not set\n\t\tassert.Equal(t, \"test_user\", req.Header.Get(\"X-Grafana-User\"))\n\t})\n\n\tt.Run(\"When SendUserHeader config is disabled\", func(t *testing.T) {\n\t\treq := getPluginProxiedRequest(\n\t\t\tt,\n\t\t\t&models.ReqContext{\n\t\t\t\tSignedInUser: &models.SignedInUser{\n\t\t\t\t\tLogin: \"test_user\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t&setting.Cfg{SendUserHeader: false},\n\t\t\tnil,\n\t\t)\n\t\t// Get will return empty string even if header is not set\n\t\tassert.Equal(t, \"\", req.Header.Get(\"X-Grafana-User\"))\n\t})\n\n\tt.Run(\"When SendUserHeader config is enabled but user is anonymous\", func(t *testing.T) {\n\t\treq := getPluginProxiedRequest(\n\t\t\tt,\n\t\t\t&models.ReqContext{\n\t\t\t\tSignedInUser: &models.SignedInUser{IsAnonymous: true},\n\t\t\t},\n\t\t\t&setting.Cfg{SendUserHeader: true},\n\t\t\tnil,\n\t\t)\n\n\t\t// Get will return empty string even if header is not set\n\t\tassert.Equal(t, \"\", req.Header.Get(\"X-Grafana-User\"))\n\t})\n\n\tt.Run(\"When getting templated url\", func(t *testing.T) {\n\t\troute := &plugins.AppPluginRoute{\n\t\t\tURL:    \"{{.JsonData.dynamicUrl}}\",\n\t\t\tMethod: \"GET\",\n\t\t}\n\n\t\tbus.AddHandler(\"test\", func(query *models.GetPluginSettingByIdQuery) error {\n\t\t\tquery.Result = &models.PluginSetting{\n\t\t\t\tJsonData: map[string]interface{}{\n\t\t\t\t\t\"dynamicUrl\": \"https://dynamic.grafana.com\",\n\t\t\t\t},\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\n\t\treq := getPluginProxiedRequest(\n\t\t\tt,\n\t\t\t&models.ReqContext{\n\t\t\t\tSignedInUser: &models.SignedInUser{\n\t\t\t\t\tLogin: \"test_user\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t&setting.Cfg{SendUserHeader: true},\n\t\t\troute,\n\t\t)\n\t\tassert.Equal(t, \"https://dynamic.grafana.com\", req.URL.String())\n\t\tassert.Equal(t, \"{{.JsonData.dynamicUrl}}\", route.URL)\n\t})\n\n\tt.Run(\"When getting complex templated url\", func(t *testing.T) {\n\t\troute := &plugins.AppPluginRoute{\n\t\t\tURL:    \"{{if .JsonData.apiHost}}{{.JsonData.apiHost}}{{else}}https://example.com{{end}}\",\n\t\t\tMethod: \"GET\",\n\t\t}\n\n\t\tbus.AddHandler(\"test\", func(query *models.GetPluginSettingByIdQuery) error {\n\t\t\tquery.Result = &models.PluginSetting{}\n\t\t\treturn nil\n\t\t})\n\n\t\treq := getPluginProxiedRequest(\n\t\t\tt,\n\t\t\t&models.ReqContext{\n\t\t\t\tSignedInUser: &models.SignedInUser{\n\t\t\t\t\tLogin: \"test_user\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t&setting.Cfg{SendUserHeader: true},\n\t\t\troute,\n\t\t)\n\t\tassert.Equal(t, \"https://example.com\", req.URL.String())\n\t})\n\n\tt.Run(\"When proxying a request should set expected response headers\", func(t *testing.T) {\n\t\trequestHandled := false\n\t\tbackendServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.WriteHeader(200)\n\t\t\t_, _ = w.Write([]byte(\"I am the backend\"))\n\t\t\trequestHandled = true\n\t\t}))\n\n\t\tresponseRecorder := &closeNotifierResponseRecorder{\n\t\t\tResponseRecorder: httptest.NewRecorder(),\n\t\t}\n\t\tresponseWriter := macaron.NewResponseWriter(\"GET\", responseRecorder)\n\n\t\tt.Cleanup(responseRecorder.Close)\n\t\tt.Cleanup(backendServer.Close)\n\n\t\troute := &plugins.AppPluginRoute{\n\t\t\tPath: \"/\",\n\t\t\tURL:  backendServer.URL,\n\t\t}\n\n\t\tctx := &models.ReqContext{\n\t\t\tSignedInUser: &models.SignedInUser{},\n\t\t\tContext: &macaron.Context{\n\t\t\t\tReq: macaron.Request{\n\t\t\t\t\tRequest: httptest.NewRequest(\"GET\", \"/\", nil),\n\t\t\t\t},\n\t\t\t\tResp: responseWriter,\n\t\t\t},\n\t\t}\n\t\tproxy := NewApiPluginProxy(ctx, \"\", route, \"\", &setting.Cfg{})\n\t\tproxy.ServeHTTP(ctx.Resp, ctx.Req.Request)\n\n\t\tfor {\n\t\t\tif requestHandled {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\trequire.Equal(t, \"sandbox\", ctx.Resp.Header().Get(\"Content-Security-Policy\"))\n\t})\n}\n\n// getPluginProxiedRequest is a helper for easier setup of tests based on global config and ReqContext.\nfunc getPluginProxiedRequest(t *testing.T, ctx *models.ReqContext, cfg *setting.Cfg, route *plugins.AppPluginRoute) *http.Request {\n\t// insert dummy route if none is specified\n\tif route == nil {\n\t\troute = &plugins.AppPluginRoute{\n\t\t\tPath:    \"api/v4/\",\n\t\t\tURL:     \"https://www.google.com\",\n\t\t\tReqRole: models.ROLE_EDITOR,\n\t\t}\n\t}\n\tproxy := NewApiPluginProxy(ctx, \"\", route, \"\", cfg)\n\n\treq, err := http.NewRequest(http.MethodGet, \"/api/plugin-proxy/grafana-simple-app/api/v4/alerts\", nil)\n\trequire.NoError(t, err)\n\tproxy.Director(req)\n\treturn req\n}\n", "package backendplugin\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/grafana/grafana-aws-sdk/pkg/awsds\"\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend\"\n\t\"github.com/grafana/grafana/pkg/infra/log\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/registry\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/util/errutil\"\n\t\"github.com/grafana/grafana/pkg/util/proxyutil\"\n)\n\nvar (\n\t// ErrPluginNotRegistered error returned when plugin not registered.\n\tErrPluginNotRegistered = errors.New(\"plugin not registered\")\n\t// ErrHealthCheckFailed error returned when health check failed.\n\tErrHealthCheckFailed = errors.New(\"health check failed\")\n\t// ErrPluginUnavailable error returned when plugin is unavailable.\n\tErrPluginUnavailable = errors.New(\"plugin unavailable\")\n\t// ErrMethodNotImplemented error returned when plugin method not implemented.\n\tErrMethodNotImplemented = errors.New(\"method not implemented\")\n)\n\nfunc init() {\n\tregistry.RegisterServiceWithPriority(&manager{}, registry.MediumHigh)\n}\n\n// Manager manages backend plugins.\ntype Manager interface {\n\t// Register registers a backend plugin\n\tRegister(pluginID string, factory PluginFactoryFunc) error\n\t// StartPlugin starts a non-managed backend plugin\n\tStartPlugin(ctx context.Context, pluginID string) error\n\t// CollectMetrics collects metrics from a registered backend plugin.\n\tCollectMetrics(ctx context.Context, pluginID string) (*backend.CollectMetricsResult, error)\n\t// CheckHealth checks the health of a registered backend plugin.\n\tCheckHealth(ctx context.Context, pCtx backend.PluginContext) (*backend.CheckHealthResult, error)\n\t// CallResource calls a plugin resource.\n\tCallResource(pluginConfig backend.PluginContext, ctx *models.ReqContext, path string)\n}\n\ntype manager struct {\n\tCfg                    *setting.Cfg                  `inject:\"\"`\n\tLicense                models.Licensing              `inject:\"\"`\n\tPluginRequestValidator models.PluginRequestValidator `inject:\"\"`\n\tpluginsMu              sync.RWMutex\n\tplugins                map[string]Plugin\n\tlogger                 log.Logger\n\tpluginSettings         map[string]pluginSettings\n}\n\nfunc (m *manager) Init() error {\n\tm.plugins = make(map[string]Plugin)\n\tm.logger = log.New(\"plugins.backend\")\n\tm.pluginSettings = extractPluginSettings(m.Cfg)\n\n\treturn nil\n}\n\nfunc (m *manager) Run(ctx context.Context) error {\n\tm.start(ctx)\n\t<-ctx.Done()\n\tm.stop(ctx)\n\treturn ctx.Err()\n}\n\n// Register registers a backend plugin\nfunc (m *manager) Register(pluginID string, factory PluginFactoryFunc) error {\n\tm.logger.Debug(\"Registering backend plugin\", \"pluginId\", pluginID)\n\tm.pluginsMu.Lock()\n\tdefer m.pluginsMu.Unlock()\n\n\tif _, exists := m.plugins[pluginID]; exists {\n\t\treturn fmt.Errorf(\"backend plugin %s already registered\", pluginID)\n\t}\n\n\tpluginSettings := pluginSettings{}\n\tif ps, exists := m.pluginSettings[pluginID]; exists {\n\t\tpluginSettings = ps\n\t}\n\n\thostEnv := []string{\n\t\tfmt.Sprintf(\"GF_VERSION=%s\", m.Cfg.BuildVersion),\n\t\tfmt.Sprintf(\"GF_EDITION=%s\", m.License.Edition()),\n\t}\n\n\tif m.License.HasLicense() {\n\t\thostEnv = append(\n\t\t\thostEnv,\n\t\t\tfmt.Sprintf(\"GF_ENTERPRISE_LICENSE_PATH=%s\", m.Cfg.EnterpriseLicensePath),\n\t\t)\n\n\t\tif envProvider, ok := m.License.(models.LicenseEnvironment); ok {\n\t\t\tfor k, v := range envProvider.Environment() {\n\t\t\t\thostEnv = append(hostEnv, fmt.Sprintf(\"%s=%s\", k, v))\n\t\t\t}\n\t\t}\n\t}\n\n\thostEnv = append(hostEnv, m.getAWSEnvironmentVariables()...)\n\n\tenv := pluginSettings.ToEnv(\"GF_PLUGIN\", hostEnv)\n\n\tpluginLogger := m.logger.New(\"pluginId\", pluginID)\n\tplugin, err := factory(pluginID, pluginLogger, env)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tm.plugins[pluginID] = plugin\n\tm.logger.Debug(\"Backend plugin registered\", \"pluginId\", pluginID)\n\treturn nil\n}\n\nfunc (m *manager) getAWSEnvironmentVariables() []string {\n\tvariables := []string{}\n\tif m.Cfg.AWSAssumeRoleEnabled {\n\t\tvariables = append(variables, awsds.AssumeRoleEnabledEnvVarKeyName+\"=true\")\n\t}\n\tif len(m.Cfg.AWSAllowedAuthProviders) > 0 {\n\t\tvariables = append(variables, awsds.AllowedAuthProvidersEnvVarKeyName+\"=\"+strings.Join(m.Cfg.AWSAllowedAuthProviders, \",\"))\n\t}\n\n\treturn variables\n}\n\n// start starts all managed backend plugins\nfunc (m *manager) start(ctx context.Context) {\n\tm.pluginsMu.RLock()\n\tdefer m.pluginsMu.RUnlock()\n\tfor _, p := range m.plugins {\n\t\tif !p.IsManaged() {\n\t\t\tcontinue\n\t\t}\n\n\t\tif err := startPluginAndRestartKilledProcesses(ctx, p); err != nil {\n\t\t\tp.Logger().Error(\"Failed to start plugin\", \"error\", err)\n\t\t\tcontinue\n\t\t}\n\t}\n}\n\n// StartPlugin starts a non-managed backend plugin\nfunc (m *manager) StartPlugin(ctx context.Context, pluginID string) error {\n\tm.pluginsMu.RLock()\n\tp, registered := m.plugins[pluginID]\n\tm.pluginsMu.RUnlock()\n\tif !registered {\n\t\treturn ErrPluginNotRegistered\n\t}\n\n\tif p.IsManaged() {\n\t\treturn errors.New(\"backend plugin is managed and cannot be manually started\")\n\t}\n\n\treturn startPluginAndRestartKilledProcesses(ctx, p)\n}\n\n// stop stops all managed backend plugins\nfunc (m *manager) stop(ctx context.Context) {\n\tm.pluginsMu.RLock()\n\tdefer m.pluginsMu.RUnlock()\n\tvar wg sync.WaitGroup\n\tfor _, p := range m.plugins {\n\t\twg.Add(1)\n\t\tgo func(p Plugin, ctx context.Context) {\n\t\t\tdefer wg.Done()\n\t\t\tp.Logger().Debug(\"Stopping plugin\")\n\t\t\tif err := p.Stop(ctx); err != nil {\n\t\t\t\tp.Logger().Error(\"Failed to stop plugin\", \"error\", err)\n\t\t\t}\n\t\t\tp.Logger().Debug(\"Plugin stopped\")\n\t\t}(p, ctx)\n\t}\n\twg.Wait()\n}\n\n// CollectMetrics collects metrics from a registered backend plugin.\nfunc (m *manager) CollectMetrics(ctx context.Context, pluginID string) (*backend.CollectMetricsResult, error) {\n\tm.pluginsMu.RLock()\n\tp, registered := m.plugins[pluginID]\n\tm.pluginsMu.RUnlock()\n\n\tif !registered {\n\t\treturn nil, ErrPluginNotRegistered\n\t}\n\n\tvar resp *backend.CollectMetricsResult\n\terr := instrumentCollectMetrics(p.PluginID(), func() (innerErr error) {\n\t\tresp, innerErr = p.CollectMetrics(ctx)\n\t\treturn\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn resp, nil\n}\n\n// CheckHealth checks the health of a registered backend plugin.\nfunc (m *manager) CheckHealth(ctx context.Context, pluginContext backend.PluginContext) (*backend.CheckHealthResult, error) {\n\tvar dsURL string\n\tif pluginContext.DataSourceInstanceSettings != nil {\n\t\tdsURL = pluginContext.DataSourceInstanceSettings.URL\n\t}\n\n\terr := m.PluginRequestValidator.Validate(dsURL, nil)\n\tif err != nil {\n\t\treturn &backend.CheckHealthResult{\n\t\t\tStatus:  http.StatusForbidden,\n\t\t\tMessage: \"Access denied\",\n\t\t}, nil\n\t}\n\n\tm.pluginsMu.RLock()\n\tp, registered := m.plugins[pluginContext.PluginID]\n\tm.pluginsMu.RUnlock()\n\n\tif !registered {\n\t\treturn nil, ErrPluginNotRegistered\n\t}\n\n\tvar resp *backend.CheckHealthResult\n\terr = instrumentCheckHealthRequest(p.PluginID(), func() (innerErr error) {\n\t\tresp, innerErr = p.CheckHealth(ctx, &backend.CheckHealthRequest{PluginContext: pluginContext})\n\t\treturn\n\t})\n\n\tif err != nil {\n\t\tif errors.Is(err, ErrMethodNotImplemented) {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif errors.Is(err, ErrPluginUnavailable) {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn nil, errutil.Wrap(\"failed to check plugin health\", ErrHealthCheckFailed)\n\t}\n\n\treturn resp, nil\n}\n\ntype keepCookiesJSONModel struct {\n\tKeepCookies []string `json:\"keepCookies\"`\n}\n\nfunc (m *manager) callResourceInternal(w http.ResponseWriter, req *http.Request, pCtx backend.PluginContext) error {\n\tm.pluginsMu.RLock()\n\tp, registered := m.plugins[pCtx.PluginID]\n\tm.pluginsMu.RUnlock()\n\n\tif !registered {\n\t\treturn ErrPluginNotRegistered\n\t}\n\n\tkeepCookieModel := keepCookiesJSONModel{}\n\tif dis := pCtx.DataSourceInstanceSettings; dis != nil {\n\t\terr := json.Unmarshal(dis.JSONData, &keepCookieModel)\n\t\tif err != nil {\n\t\t\tp.Logger().Error(\"Failed to to unpack JSONData in datasource instance settings\", \"error\", err)\n\t\t}\n\t}\n\n\tproxyutil.ClearCookieHeader(req, keepCookieModel.KeepCookies)\n\tproxyutil.PrepareProxyRequest(req)\n\n\tbody, err := ioutil.ReadAll(req.Body)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to read request body: %w\", err)\n\t}\n\n\tcrReq := &backend.CallResourceRequest{\n\t\tPluginContext: pCtx,\n\t\tPath:          req.URL.Path,\n\t\tMethod:        req.Method,\n\t\tURL:           req.URL.String(),\n\t\tHeaders:       req.Header,\n\t\tBody:          body,\n\t}\n\n\treturn instrumentCallResourceRequest(p.PluginID(), func() error {\n\t\tchildCtx, cancel := context.WithCancel(req.Context())\n\t\tdefer cancel()\n\t\tstream := newCallResourceResponseStream(childCtx)\n\n\t\tvar wg sync.WaitGroup\n\t\twg.Add(1)\n\n\t\tdefer func() {\n\t\t\tif err := stream.Close(); err != nil {\n\t\t\t\tm.logger.Warn(\"Failed to close stream\", \"err\", err)\n\t\t\t}\n\t\t\twg.Wait()\n\t\t}()\n\n\t\tvar flushStreamErr error\n\t\tgo func() {\n\t\t\tflushStreamErr = flushStream(p, stream, w)\n\t\t\twg.Done()\n\t\t}()\n\n\t\tif err := p.CallResource(req.Context(), crReq, stream); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn flushStreamErr\n\t})\n}\n\n// CallResource calls a plugin resource.\nfunc (m *manager) CallResource(pCtx backend.PluginContext, reqCtx *models.ReqContext, path string) {\n\tvar dsURL string\n\tif pCtx.DataSourceInstanceSettings != nil {\n\t\tdsURL = pCtx.DataSourceInstanceSettings.URL\n\t}\n\n\terr := m.PluginRequestValidator.Validate(dsURL, reqCtx.Req.Request)\n\tif err != nil {\n\t\treqCtx.JsonApiErr(http.StatusForbidden, \"Access denied\", err)\n\t\treturn\n\t}\n\n\tclonedReq := reqCtx.Req.Clone(reqCtx.Req.Context())\n\trawURL := path\n\tif clonedReq.URL.RawQuery != \"\" {\n\t\trawURL += \"?\" + clonedReq.URL.RawQuery\n\t}\n\turlPath, err := url.Parse(rawURL)\n\tif err != nil {\n\t\thandleCallResourceError(err, reqCtx)\n\t\treturn\n\t}\n\tclonedReq.URL = urlPath\n\terr = m.callResourceInternal(reqCtx.Resp, clonedReq, pCtx)\n\tif err != nil {\n\t\thandleCallResourceError(err, reqCtx)\n\t}\n}\n\nfunc handleCallResourceError(err error, reqCtx *models.ReqContext) {\n\tif errors.Is(err, ErrPluginUnavailable) {\n\t\treqCtx.JsonApiErr(503, \"Plugin unavailable\", err)\n\t\treturn\n\t}\n\n\tif errors.Is(err, ErrMethodNotImplemented) {\n\t\treqCtx.JsonApiErr(404, \"Not found\", err)\n\t\treturn\n\t}\n\n\treqCtx.JsonApiErr(500, \"Failed to call resource\", err)\n}\n\nfunc flushStream(plugin Plugin, stream CallResourceClientResponseStream, w http.ResponseWriter) error {\n\tprocessedStreams := 0\n\n\tfor {\n\t\tresp, err := stream.Recv()\n\t\tif errors.Is(err, io.EOF) {\n\t\t\tif processedStreams == 0 {\n\t\t\t\treturn errors.New(\"received empty resource response\")\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\tif err != nil {\n\t\t\tif processedStreams == 0 {\n\t\t\t\treturn errutil.Wrap(\"failed to receive response from resource call\", err)\n\t\t\t}\n\n\t\t\tplugin.Logger().Error(\"Failed to receive response from resource call\", \"error\", err)\n\t\t\treturn stream.Close()\n\t\t}\n\n\t\t// Expected that headers and status are only part of first stream\n\t\tif processedStreams == 0 && resp.Headers != nil {\n\t\t\t// Make sure a content type always is returned in response\n\t\t\tif _, exists := resp.Headers[\"Content-Type\"]; !exists {\n\t\t\t\tresp.Headers[\"Content-Type\"] = []string{\"application/json\"}\n\t\t\t}\n\n\t\t\tfor k, values := range resp.Headers {\n\t\t\t\t// Due to security reasons we don't want to forward\n\t\t\t\t// cookies from a backend plugin to clients/browsers.\n\t\t\t\tif k == \"Set-Cookie\" {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tfor _, v := range values {\n\t\t\t\t\t// TODO: Figure out if we should use Set here instead\n\t\t\t\t\t// nolint:gocritic\n\t\t\t\t\tw.Header().Add(k, v)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tproxyutil.SetProxyResponseHeaders(w.Header())\n\t\t\tw.WriteHeader(resp.Status)\n\t\t}\n\n\t\tif _, err := w.Write(resp.Body); err != nil {\n\t\t\tplugin.Logger().Error(\"Failed to write resource response\", \"error\", err)\n\t\t}\n\n\t\tif flusher, ok := w.(http.Flusher); ok {\n\t\t\tflusher.Flush()\n\t\t}\n\t\tprocessedStreams++\n\t}\n}\n\nfunc startPluginAndRestartKilledProcesses(ctx context.Context, p Plugin) error {\n\tif err := p.Start(ctx); err != nil {\n\t\treturn err\n\t}\n\n\tgo func(ctx context.Context, p Plugin) {\n\t\tif err := restartKilledProcess(ctx, p); err != nil {\n\t\t\tp.Logger().Error(\"Attempt to restart killed plugin process failed\", \"error\", err)\n\t\t}\n\t}(ctx, p)\n\n\treturn nil\n}\n\nfunc restartKilledProcess(ctx context.Context, p Plugin) error {\n\tticker := time.NewTicker(time.Second * 1)\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tif err := ctx.Err(); err != nil && !errors.Is(err, context.Canceled) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tcase <-ticker.C:\n\t\t\tif !p.Exited() {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tp.Logger().Debug(\"Restarting plugin\")\n\t\t\tif err := p.Start(ctx); err != nil {\n\t\t\t\tp.Logger().Error(\"Failed to restart plugin\", \"error\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tp.Logger().Debug(\"Plugin restarted\")\n\t\t}\n\t}\n}\n", "package backendplugin\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/grafana/grafana-aws-sdk/pkg/awsds\"\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend\"\n\t\"github.com/grafana/grafana/pkg/infra/log\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nconst testPluginID = \"test-plugin\"\n\nfunc TestManager(t *testing.T) {\n\tnewManagerScenario(t, false, func(t *testing.T, ctx *managerScenarioCtx) {\n\t\tt.Run(\"Unregistered plugin scenario\", func(t *testing.T) {\n\t\t\terr := ctx.manager.StartPlugin(context.Background(), testPluginID)\n\t\t\trequire.Equal(t, ErrPluginNotRegistered, err)\n\n\t\t\t_, err = ctx.manager.CollectMetrics(context.Background(), testPluginID)\n\t\t\trequire.Equal(t, ErrPluginNotRegistered, err)\n\n\t\t\t_, err = ctx.manager.CheckHealth(context.Background(), backend.PluginContext{PluginID: testPluginID})\n\t\t\trequire.Equal(t, ErrPluginNotRegistered, err)\n\n\t\t\treq, err := http.NewRequest(http.MethodGet, \"/test\", nil)\n\t\t\trequire.NoError(t, err)\n\t\t\tw := httptest.NewRecorder()\n\t\t\terr = ctx.manager.callResourceInternal(w, req, backend.PluginContext{PluginID: testPluginID})\n\t\t\trequire.Equal(t, ErrPluginNotRegistered, err)\n\t\t})\n\t})\n\n\tnewManagerScenario(t, true, func(t *testing.T, ctx *managerScenarioCtx) {\n\t\tt.Run(\"Managed plugin scenario\", func(t *testing.T) {\n\t\t\tctx.license.edition = \"Open Source\"\n\t\t\tctx.license.hasLicense = false\n\t\t\tctx.cfg.BuildVersion = \"7.0.0\"\n\n\t\t\tt.Run(\"Should be able to register plugin\", func(t *testing.T) {\n\t\t\t\terr := ctx.manager.Register(testPluginID, ctx.factory)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.NotNil(t, ctx.plugin)\n\t\t\t\trequire.Equal(t, testPluginID, ctx.plugin.pluginID)\n\t\t\t\trequire.NotNil(t, ctx.plugin.logger)\n\n\t\t\t\tt.Run(\"Should not be able to register an already registered plugin\", func(t *testing.T) {\n\t\t\t\t\terr := ctx.manager.Register(testPluginID, ctx.factory)\n\t\t\t\t\trequire.Error(t, err)\n\t\t\t\t})\n\n\t\t\t\tt.Run(\"Should provide expected host environment variables\", func(t *testing.T) {\n\t\t\t\t\trequire.Len(t, ctx.env, 4)\n\t\t\t\t\trequire.EqualValues(t, []string{\"GF_VERSION=7.0.0\", \"GF_EDITION=Open Source\", fmt.Sprintf(\"%s=true\", awsds.AssumeRoleEnabledEnvVarKeyName), fmt.Sprintf(\"%s=keys,credentials\", awsds.AllowedAuthProvidersEnvVarKeyName)}, ctx.env)\n\t\t\t\t})\n\n\t\t\t\tt.Run(\"When manager runs should start and stop plugin\", func(t *testing.T) {\n\t\t\t\t\tpCtx := context.Background()\n\t\t\t\t\tcCtx, cancel := context.WithCancel(pCtx)\n\t\t\t\t\tvar wg sync.WaitGroup\n\t\t\t\t\twg.Add(1)\n\t\t\t\t\tvar runErr error\n\t\t\t\t\tgo func() {\n\t\t\t\t\t\trunErr = ctx.manager.Run(cCtx)\n\t\t\t\t\t\twg.Done()\n\t\t\t\t\t}()\n\t\t\t\t\ttime.Sleep(time.Millisecond)\n\t\t\t\t\tcancel()\n\t\t\t\t\twg.Wait()\n\t\t\t\t\trequire.Equal(t, context.Canceled, runErr)\n\t\t\t\t\trequire.Equal(t, 1, ctx.plugin.startCount)\n\t\t\t\t\trequire.Equal(t, 1, ctx.plugin.stopCount)\n\t\t\t\t})\n\n\t\t\t\tt.Run(\"When manager runs should restart plugin process when killed\", func(t *testing.T) {\n\t\t\t\t\tctx.plugin.stopCount = 0\n\t\t\t\t\tctx.plugin.startCount = 0\n\t\t\t\t\tpCtx := context.Background()\n\t\t\t\t\tcCtx, cancel := context.WithCancel(pCtx)\n\t\t\t\t\tvar wgRun sync.WaitGroup\n\t\t\t\t\twgRun.Add(1)\n\t\t\t\t\tvar runErr error\n\t\t\t\t\tgo func() {\n\t\t\t\t\t\trunErr = ctx.manager.Run(cCtx)\n\t\t\t\t\t\twgRun.Done()\n\t\t\t\t\t}()\n\n\t\t\t\t\ttime.Sleep(time.Millisecond)\n\n\t\t\t\t\tvar wgKill sync.WaitGroup\n\t\t\t\t\twgKill.Add(1)\n\t\t\t\t\tgo func() {\n\t\t\t\t\t\tctx.plugin.kill()\n\t\t\t\t\t\tfor {\n\t\t\t\t\t\t\tif !ctx.plugin.Exited() {\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcancel()\n\t\t\t\t\t\twgKill.Done()\n\t\t\t\t\t}()\n\t\t\t\t\twgKill.Wait()\n\t\t\t\t\twgRun.Wait()\n\t\t\t\t\trequire.Equal(t, context.Canceled, runErr)\n\t\t\t\t\trequire.Equal(t, 1, ctx.plugin.stopCount)\n\t\t\t\t\trequire.Equal(t, 2, ctx.plugin.startCount)\n\t\t\t\t})\n\n\t\t\t\tt.Run(\"Shouldn't be able to start managed plugin\", func(t *testing.T) {\n\t\t\t\t\terr := ctx.manager.StartPlugin(context.Background(), testPluginID)\n\t\t\t\t\trequire.NotNil(t, err)\n\t\t\t\t})\n\n\t\t\t\tt.Run(\"Unimplemented handlers\", func(t *testing.T) {\n\t\t\t\t\tt.Run(\"Collect metrics should return method not implemented error\", func(t *testing.T) {\n\t\t\t\t\t\t_, err = ctx.manager.CollectMetrics(context.Background(), testPluginID)\n\t\t\t\t\t\trequire.Equal(t, ErrMethodNotImplemented, err)\n\t\t\t\t\t})\n\n\t\t\t\t\tt.Run(\"Check health should return method not implemented error\", func(t *testing.T) {\n\t\t\t\t\t\t_, err = ctx.manager.CheckHealth(context.Background(), backend.PluginContext{PluginID: testPluginID})\n\t\t\t\t\t\trequire.Equal(t, ErrMethodNotImplemented, err)\n\t\t\t\t\t})\n\n\t\t\t\t\tt.Run(\"Call resource should return method not implemented error\", func(t *testing.T) {\n\t\t\t\t\t\treq, err := http.NewRequest(http.MethodGet, \"/test\", bytes.NewReader([]byte{}))\n\t\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\t\tw := httptest.NewRecorder()\n\t\t\t\t\t\terr = ctx.manager.callResourceInternal(w, req, backend.PluginContext{PluginID: testPluginID})\n\t\t\t\t\t\trequire.Equal(t, ErrMethodNotImplemented, err)\n\t\t\t\t\t})\n\t\t\t\t})\n\n\t\t\t\tt.Run(\"Implemented handlers\", func(t *testing.T) {\n\t\t\t\t\tt.Run(\"Collect metrics should return expected result\", func(t *testing.T) {\n\t\t\t\t\t\tctx.plugin.CollectMetricsHandlerFunc = backend.CollectMetricsHandlerFunc(func(ctx context.Context) (*backend.CollectMetricsResult, error) {\n\t\t\t\t\t\t\treturn &backend.CollectMetricsResult{\n\t\t\t\t\t\t\t\tPrometheusMetrics: []byte(\"hello\"),\n\t\t\t\t\t\t\t}, nil\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tres, err := ctx.manager.CollectMetrics(context.Background(), testPluginID)\n\t\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\t\trequire.NotNil(t, res)\n\t\t\t\t\t\trequire.Equal(t, \"hello\", string(res.PrometheusMetrics))\n\t\t\t\t\t})\n\n\t\t\t\t\tt.Run(\"Check health should return expected result\", func(t *testing.T) {\n\t\t\t\t\t\tjson := []byte(`{\n\t\t\t\t\t\t\t\"key\": \"value\"\n\t\t\t\t\t\t}`)\n\t\t\t\t\t\tctx.plugin.CheckHealthHandlerFunc = backend.CheckHealthHandlerFunc(func(ctx context.Context, req *backend.CheckHealthRequest) (*backend.CheckHealthResult, error) {\n\t\t\t\t\t\t\treturn &backend.CheckHealthResult{\n\t\t\t\t\t\t\t\tStatus:      backend.HealthStatusOk,\n\t\t\t\t\t\t\t\tMessage:     \"All good\",\n\t\t\t\t\t\t\t\tJSONDetails: json,\n\t\t\t\t\t\t\t}, nil\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tres, err := ctx.manager.CheckHealth(context.Background(), backend.PluginContext{PluginID: testPluginID})\n\t\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\t\trequire.NotNil(t, res)\n\t\t\t\t\t\trequire.Equal(t, backend.HealthStatusOk, res.Status)\n\t\t\t\t\t\trequire.Equal(t, \"All good\", res.Message)\n\t\t\t\t\t\trequire.Equal(t, json, res.JSONDetails)\n\t\t\t\t\t})\n\n\t\t\t\t\tt.Run(\"Call resource should return expected response\", func(t *testing.T) {\n\t\t\t\t\t\tctx.plugin.CallResourceHandlerFunc = backend.CallResourceHandlerFunc(func(ctx context.Context, req *backend.CallResourceRequest, sender backend.CallResourceResponseSender) error {\n\t\t\t\t\t\t\treturn sender.Send(&backend.CallResourceResponse{\n\t\t\t\t\t\t\t\tStatus:  http.StatusOK,\n\t\t\t\t\t\t\t\tHeaders: map[string][]string{},\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\treq, err := http.NewRequest(http.MethodGet, \"/test\", bytes.NewReader([]byte{}))\n\t\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\t\tw := httptest.NewRecorder()\n\t\t\t\t\t\terr = ctx.manager.callResourceInternal(w, req, backend.PluginContext{PluginID: testPluginID})\n\t\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\t\tfor {\n\t\t\t\t\t\t\tif w.Flushed {\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\trequire.Equal(t, http.StatusOK, w.Code)\n\t\t\t\t\t\trequire.Equal(t, \"sandbox\", w.Header().Get(\"Content-Security-Policy\"))\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\t})\n\n\tnewManagerScenario(t, false, func(t *testing.T, ctx *managerScenarioCtx) {\n\t\tt.Run(\"Unmanaged plugin scenario\", func(t *testing.T) {\n\t\t\tctx.license.edition = \"Open Source\"\n\t\t\tctx.license.hasLicense = false\n\t\t\tctx.cfg.BuildVersion = \"7.0.0\"\n\n\t\t\tt.Run(\"Should be able to register plugin\", func(t *testing.T) {\n\t\t\t\terr := ctx.manager.Register(testPluginID, ctx.factory)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.False(t, ctx.plugin.managed)\n\n\t\t\t\tt.Run(\"When manager runs should not start plugin\", func(t *testing.T) {\n\t\t\t\t\tpCtx := context.Background()\n\t\t\t\t\tcCtx, cancel := context.WithCancel(pCtx)\n\t\t\t\t\tvar wg sync.WaitGroup\n\t\t\t\t\twg.Add(1)\n\t\t\t\t\tvar runErr error\n\t\t\t\t\tgo func() {\n\t\t\t\t\t\trunErr = ctx.manager.Run(cCtx)\n\t\t\t\t\t\twg.Done()\n\t\t\t\t\t}()\n\t\t\t\t\tgo func() {\n\t\t\t\t\t\tcancel()\n\t\t\t\t\t}()\n\t\t\t\t\twg.Wait()\n\t\t\t\t\trequire.Equal(t, context.Canceled, runErr)\n\t\t\t\t\trequire.Equal(t, 0, ctx.plugin.startCount)\n\t\t\t\t\trequire.Equal(t, 1, ctx.plugin.stopCount)\n\t\t\t\t})\n\n\t\t\t\tt.Run(\"Should be able to start unmanaged plugin and be restarted when process is killed\", func(t *testing.T) {\n\t\t\t\t\tpCtx := context.Background()\n\t\t\t\t\tcCtx, cancel := context.WithCancel(pCtx)\n\t\t\t\t\tdefer cancel()\n\t\t\t\t\terr := ctx.manager.StartPlugin(cCtx, testPluginID)\n\t\t\t\t\trequire.Nil(t, err)\n\t\t\t\t\trequire.Equal(t, 1, ctx.plugin.startCount)\n\n\t\t\t\t\tvar wg sync.WaitGroup\n\t\t\t\t\twg.Add(1)\n\t\t\t\t\tgo func() {\n\t\t\t\t\t\tctx.plugin.kill()\n\t\t\t\t\t\tfor {\n\t\t\t\t\t\t\tif !ctx.plugin.Exited() {\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\twg.Done()\n\t\t\t\t\t}()\n\t\t\t\t\twg.Wait()\n\t\t\t\t\trequire.Equal(t, 2, ctx.plugin.startCount)\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\t})\n\n\tnewManagerScenario(t, true, func(t *testing.T, ctx *managerScenarioCtx) {\n\t\tt.Run(\"Plugin registration scenario when Grafana is licensed\", func(t *testing.T) {\n\t\t\tctx.license.edition = \"Enterprise\"\n\t\t\tctx.license.hasLicense = true\n\t\t\tctx.license.tokenRaw = \"testtoken\"\n\t\t\tctx.cfg.BuildVersion = \"7.0.0\"\n\t\t\tctx.cfg.EnterpriseLicensePath = \"/license.txt\"\n\n\t\t\terr := ctx.manager.Register(testPluginID, ctx.factory)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tt.Run(\"Should provide expected host environment variables\", func(t *testing.T) {\n\t\t\t\trequire.Len(t, ctx.env, 6)\n\t\t\t\trequire.EqualValues(t, []string{\"GF_VERSION=7.0.0\", \"GF_EDITION=Enterprise\", \"GF_ENTERPRISE_LICENSE_PATH=/license.txt\", \"GF_ENTERPRISE_LICENSE_TEXT=testtoken\", fmt.Sprintf(\"%s=true\", awsds.AssumeRoleEnabledEnvVarKeyName), fmt.Sprintf(\"%s=keys,credentials\", awsds.AllowedAuthProvidersEnvVarKeyName)}, ctx.env)\n\t\t\t})\n\t\t})\n\t})\n}\n\ntype managerScenarioCtx struct {\n\tcfg     *setting.Cfg\n\tlicense *testLicensingService\n\tmanager *manager\n\tfactory PluginFactoryFunc\n\tplugin  *testPlugin\n\tenv     []string\n}\n\nfunc newManagerScenario(t *testing.T, managed bool, fn func(t *testing.T, ctx *managerScenarioCtx)) {\n\tt.Helper()\n\tcfg := setting.NewCfg()\n\tcfg.AWSAllowedAuthProviders = []string{\"keys\", \"credentials\"}\n\tcfg.AWSAssumeRoleEnabled = true\n\n\tlicense := &testLicensingService{}\n\tvalidator := &testPluginRequestValidator{}\n\tctx := &managerScenarioCtx{\n\t\tcfg:     cfg,\n\t\tlicense: license,\n\t\tmanager: &manager{\n\t\t\tCfg:                    cfg,\n\t\t\tLicense:                license,\n\t\t\tPluginRequestValidator: validator,\n\t\t},\n\t}\n\n\terr := ctx.manager.Init()\n\trequire.NoError(t, err)\n\n\tctx.factory = PluginFactoryFunc(func(pluginID string, logger log.Logger, env []string) (Plugin, error) {\n\t\tctx.plugin = &testPlugin{\n\t\t\tpluginID: pluginID,\n\t\t\tlogger:   logger,\n\t\t\tmanaged:  managed,\n\t\t}\n\t\tctx.env = env\n\n\t\treturn ctx.plugin, nil\n\t})\n\n\tfn(t, ctx)\n}\n\ntype testPlugin struct {\n\tpluginID   string\n\tlogger     log.Logger\n\tstartCount int\n\tstopCount  int\n\tmanaged    bool\n\texited     bool\n\tbackend.CollectMetricsHandlerFunc\n\tbackend.CheckHealthHandlerFunc\n\tbackend.CallResourceHandlerFunc\n\tmutex sync.RWMutex\n}\n\nfunc (tp *testPlugin) PluginID() string {\n\treturn tp.pluginID\n}\n\nfunc (tp *testPlugin) Logger() log.Logger {\n\treturn tp.logger\n}\n\nfunc (tp *testPlugin) Start(ctx context.Context) error {\n\ttp.mutex.Lock()\n\tdefer tp.mutex.Unlock()\n\ttp.exited = false\n\ttp.startCount++\n\treturn nil\n}\n\nfunc (tp *testPlugin) Stop(ctx context.Context) error {\n\ttp.mutex.Lock()\n\tdefer tp.mutex.Unlock()\n\ttp.stopCount++\n\treturn nil\n}\n\nfunc (tp *testPlugin) IsManaged() bool {\n\treturn tp.managed\n}\n\nfunc (tp *testPlugin) Exited() bool {\n\ttp.mutex.RLock()\n\tdefer tp.mutex.RUnlock()\n\treturn tp.exited\n}\n\nfunc (tp *testPlugin) kill() {\n\ttp.mutex.Lock()\n\tdefer tp.mutex.Unlock()\n\ttp.exited = true\n}\n\nfunc (tp *testPlugin) CollectMetrics(ctx context.Context) (*backend.CollectMetricsResult, error) {\n\tif tp.CollectMetricsHandlerFunc != nil {\n\t\treturn tp.CollectMetricsHandlerFunc(ctx)\n\t}\n\n\treturn nil, ErrMethodNotImplemented\n}\n\nfunc (tp *testPlugin) CheckHealth(ctx context.Context, req *backend.CheckHealthRequest) (*backend.CheckHealthResult, error) {\n\tif tp.CheckHealthHandlerFunc != nil {\n\t\treturn tp.CheckHealthHandlerFunc(ctx, req)\n\t}\n\n\treturn nil, ErrMethodNotImplemented\n}\n\nfunc (tp *testPlugin) CallResource(ctx context.Context, req *backend.CallResourceRequest, sender backend.CallResourceResponseSender) error {\n\tif tp.CallResourceHandlerFunc != nil {\n\t\treturn tp.CallResourceHandlerFunc(ctx, req, sender)\n\t}\n\n\treturn ErrMethodNotImplemented\n}\n\ntype testLicensingService struct {\n\tedition    string\n\thasLicense bool\n\ttokenRaw   string\n}\n\nfunc (t *testLicensingService) HasLicense() bool {\n\treturn t.hasLicense\n}\n\nfunc (t *testLicensingService) Expiry() int64 {\n\treturn 0\n}\n\nfunc (t *testLicensingService) Edition() string {\n\treturn t.edition\n}\n\nfunc (t *testLicensingService) StateInfo() string {\n\treturn \"\"\n}\n\nfunc (t *testLicensingService) ContentDeliveryPrefix() string {\n\treturn \"\"\n}\n\nfunc (t *testLicensingService) LicenseURL(user *models.SignedInUser) string {\n\treturn \"\"\n}\n\nfunc (t *testLicensingService) HasValidLicense() bool {\n\treturn false\n}\n\nfunc (t *testLicensingService) Environment() map[string]string {\n\treturn map[string]string{\"GF_ENTERPRISE_LICENSE_TEXT\": t.tokenRaw}\n}\n\ntype testPluginRequestValidator struct{}\n\nfunc (t *testPluginRequestValidator) Validate(string, *http.Request) error {\n\treturn nil\n}\n", "package proxyutil\n\nimport (\n\t\"net\"\n\t\"net/http\"\n)\n\n// PrepareProxyRequest prepares a request for being proxied.\n// Removes X-Forwarded-Host, X-Forwarded-Port, X-Forwarded-Proto headers.\n// Set X-Forwarded-For headers.\nfunc PrepareProxyRequest(req *http.Request) {\n\treq.Header.Del(\"X-Forwarded-Host\")\n\treq.Header.Del(\"X-Forwarded-Port\")\n\treq.Header.Del(\"X-Forwarded-Proto\")\n\n\tif req.RemoteAddr != \"\" {\n\t\tremoteAddr, _, err := net.SplitHostPort(req.RemoteAddr)\n\t\tif err != nil {\n\t\t\tremoteAddr = req.RemoteAddr\n\t\t}\n\t\tif req.Header.Get(\"X-Forwarded-For\") != \"\" {\n\t\t\treq.Header.Set(\"X-Forwarded-For\", req.Header.Get(\"X-Forwarded-For\")+\", \"+remoteAddr)\n\t\t} else {\n\t\t\treq.Header.Set(\"X-Forwarded-For\", remoteAddr)\n\t\t}\n\t}\n}\n\n// ClearCookieHeader clear cookie header, except for cookies specified to be kept.\nfunc ClearCookieHeader(req *http.Request, keepCookiesNames []string) {\n\tvar keepCookies []*http.Cookie\n\tfor _, c := range req.Cookies() {\n\t\tfor _, v := range keepCookiesNames {\n\t\t\tif c.Name == v {\n\t\t\t\tkeepCookies = append(keepCookies, c)\n\t\t\t}\n\t\t}\n\t}\n\n\treq.Header.Del(\"Cookie\")\n\tfor _, c := range keepCookies {\n\t\treq.AddCookie(c)\n\t}\n}\n\n// SetProxyResponseHeaders sets proxy response headers.\n// Sets Content-Security-Policy: sandbox\nfunc SetProxyResponseHeaders(header http.Header) {\n\theader.Set(\"Content-Security-Policy\", \"sandbox\")\n}\n"], "filenames": ["pkg/api/pluginproxy/ds_proxy.go", "pkg/api/pluginproxy/ds_proxy_test.go", "pkg/api/pluginproxy/pluginproxy.go", "pkg/api/pluginproxy/pluginproxy_test.go", "pkg/plugins/backendplugin/manager.go", "pkg/plugins/backendplugin/manager_test.go", "pkg/util/proxyutil/proxyutil.go"], "buggy_code_start_loc": [51, 607, 74, 4, 408, 180, 44], "buggy_code_end_loc": [51, 607, 75, 149, 408, 189, 44], "fixing_code_start_loc": [52, 608, 74, 5, 409, 180, 45], "fixing_code_end_loc": [53, 620, 82, 194, 410, 197, 51], "type": "CWE-79", "message": "Grafana is an open-source platform for monitoring and observability. In affected versions an attacker could serve HTML content thru the Grafana datasource or plugin proxy and trick a user to visit this HTML page using a specially crafted link and execute a Cross-site Scripting (XSS) attack. The attacker could either compromise an existing datasource for a specific Grafana instance or either set up its own public service and instruct anyone to set it up in their Grafana instance. To be impacted, all of the following must be applicable. For the data source proxy: A Grafana HTTP-based datasource configured with Server as Access Mode and a URL set, the attacker has to be in control of the HTTP server serving the URL of above datasource, and a specially crafted link pointing at the attacker controlled data source must be clicked on by an authenticated user. For the plugin proxy: A Grafana HTTP-based app plugin configured and enabled with a URL set, the attacker has to be in control of the HTTP server serving the URL of above app, and a specially crafted link pointing at the attacker controlled plugin must be clocked on by an authenticated user. For the backend plugin resource: An attacker must be able to navigate an authenticated user to a compromised plugin through a crafted link. Users are advised to update to a patched version. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2022-21702", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-08T20:15:08.987", "lastModified": "2022-09-10T02:41:08.097", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Grafana is an open-source platform for monitoring and observability. In affected versions an attacker could serve HTML content thru the Grafana datasource or plugin proxy and trick a user to visit this HTML page using a specially crafted link and execute a Cross-site Scripting (XSS) attack. The attacker could either compromise an existing datasource for a specific Grafana instance or either set up its own public service and instruct anyone to set it up in their Grafana instance. To be impacted, all of the following must be applicable. For the data source proxy: A Grafana HTTP-based datasource configured with Server as Access Mode and a URL set, the attacker has to be in control of the HTTP server serving the URL of above datasource, and a specially crafted link pointing at the attacker controlled data source must be clicked on by an authenticated user. For the plugin proxy: A Grafana HTTP-based app plugin configured and enabled with a URL set, the attacker has to be in control of the HTTP server serving the URL of above app, and a specially crafted link pointing at the attacker controlled plugin must be clocked on by an authenticated user. For the backend plugin resource: An attacker must be able to navigate an authenticated user to a compromised plugin through a crafted link. Users are advised to update to a patched version. There are no known workarounds for this vulnerability."}, {"lang": "es", "value": "Grafana es una plataforma de c\u00f3digo abierto para la monitorizaci\u00f3n y la observabilidad. En las versiones afectadas, un atacante podr\u00eda servir contenido HTML mediante la fuente de datos de Grafana o el proxy del plugin y enga\u00f1ar a un usuario para que visite esta p\u00e1gina HTML usando un enlace especialmente dise\u00f1ado y ejecutar un ataque de tipo Cross-site Scripting (XSS). El atacante podr\u00eda comprometer una fuente de datos existente para una instancia espec\u00edfica de Grafana o bien configurar su propio servicio p\u00fablico e instruir a cualquiera para que lo configure en su instancia de Grafana. Para ser impactado, todo lo siguiente debe ser aplicable. Para el proxy de la fuente de datos: Una fuente de datos basada en HTTP de Grafana configurada con Servidor como Modo de Acceso y una URL establecida, el atacante debe estar en control del servidor HTTP que sirve la URL de dicha fuente de datos, y un enlace especialmente dise\u00f1ado que apunte a la fuente de datos controlada por el atacante debe ser pulsado por un usuario autenticado. Para el plugin proxy: Un plugin de Grafana basado en HTTP configurado y habilitado con un conjunto de URL, el atacante debe estar en control del servidor HTTP que sirve la URL de la aplicaci\u00f3n anterior, y un enlace especialmente dise\u00f1ado que apunte al plugin controlado por el atacante debe ser marcado por un usuario autenticado. Para el recurso del plugin backend: Un atacante debe ser capaz de dirigir a un usuario autenticado a un plugin comprometido mediante un enlace dise\u00f1ado. Es recomendado a usuarios actualizar a una versi\u00f3n parcheada. No hay medidas de mitigaci\u00f3n adicionales conocidas para esta vulnerabilidad"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:C/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.3, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:grafana:grafana:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.1", "versionEndExcluding": "7.5.15", "matchCriteriaId": "EDAF22BC-1003-4EB9-8256-A7DEA894CCC1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:grafana:grafana:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.0.0", "versionEndExcluding": "8.3.5", "matchCriteriaId": "16145A8D-9FF1-4EEE-8E29-198B408582B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:grafana:grafana:2.0.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "9C4FC3E6-8C85-4398-B270-5B0373C129B6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:grafana:grafana:2.0.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "4C441D33-2494-4B4F-8C7D-3C0857FDD209"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_performance_analyzer:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.0", "matchCriteriaId": "CC05F69D-6C6B-472D-87B7-84231F14CA8B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/grafana/grafana/commit/27726868b3d7c613844b55cd209ca93645c99b85", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/grafana/grafana/security/advisories/GHSA-xc3p-28hw-q24g", "source": "security-advisories@github.com", "tags": ["Exploit", "Mitigation", "Release Notes", "Third Party Advisory"]}, {"url": "https://grafana.com/blog/2022/02/08/grafana-7.5.15-and-8.3.5-released-with-moderate-severity-security-fixes/", "source": "security-advisories@github.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/2PFW6Q2LXXWTFRTMTRN4ZGADFRQPKJ3D/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/36GUEPA5TPSC57DZTPYPBL6T7UPQ2FRH/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HLAQRRGNSO5MYCPAXGPH2OCSHOGHSQMQ/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20220303-0005/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/grafana/grafana/commit/27726868b3d7c613844b55cd209ca93645c99b85"}}