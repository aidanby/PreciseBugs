{"buggy_code": ["// Copyright 2018 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Package shm implements sysv shared memory segments.\n//\n// Known missing features:\n//\n// - SHM_LOCK/SHM_UNLOCK are no-ops. The sentry currently doesn't implement\n//   memory locking in general.\n//\n// - SHM_HUGETLB and related flags for shmget(2) are ignored. There's no easy\n//   way to implement hugetlb support on a per-map basis, and it has no impact\n//   on correctness.\n//\n// - SHM_NORESERVE for shmget(2) is ignored, the sentry doesn't implement swap\n//   so it's meaningless to reserve space for swap.\n//\n// - No per-process segment size enforcement. This feature probably isn't used\n//   much anyways, since Linux sets the per-process limits to the system-wide\n//   limits by default.\n//\n// Lock ordering: mm.mappingMu -> shm registry lock -> shm lock\npackage shm\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\n\t\"gvisor.googlesource.com/gvisor/pkg/abi/linux\"\n\t\"gvisor.googlesource.com/gvisor/pkg/log\"\n\t\"gvisor.googlesource.com/gvisor/pkg/refs\"\n\t\"gvisor.googlesource.com/gvisor/pkg/sentry/context\"\n\t\"gvisor.googlesource.com/gvisor/pkg/sentry/fs\"\n\t\"gvisor.googlesource.com/gvisor/pkg/sentry/kernel/auth\"\n\tktime \"gvisor.googlesource.com/gvisor/pkg/sentry/kernel/time\"\n\t\"gvisor.googlesource.com/gvisor/pkg/sentry/memmap\"\n\t\"gvisor.googlesource.com/gvisor/pkg/sentry/platform\"\n\t\"gvisor.googlesource.com/gvisor/pkg/sentry/usage\"\n\t\"gvisor.googlesource.com/gvisor/pkg/sentry/usermem\"\n\t\"gvisor.googlesource.com/gvisor/pkg/syserror\"\n)\n\n// Registry tracks all shared memory segments in an IPC namespace. The registry\n// provides the mechanisms for creating and finding segments, and reporting\n// global shm parameters.\n//\n// +stateify savable\ntype Registry struct {\n\t// userNS owns the IPC namespace this registry belong to. Immutable.\n\tuserNS *auth.UserNamespace\n\n\tmu sync.Mutex `state:\"nosave\"`\n\n\t// shms maps segment ids to segments. Protected by mu.\n\tshms map[int32]*Shm\n\n\t// Sum of the sizes of all existing segments rounded up to page size, in\n\t// units of page size. Protected by mu.\n\ttotalPages uint64\n\n\t// lastIDUsed is protected by mu.\n\tlastIDUsed int32\n}\n\n// NewRegistry creates a new shm registry.\nfunc NewRegistry(userNS *auth.UserNamespace) *Registry {\n\treturn &Registry{\n\t\tuserNS: userNS,\n\t\tshms:   make(map[int32]*Shm),\n\t}\n}\n\n// FindByID looks up a segment given an ID.\nfunc (r *Registry) FindByID(id int32) *Shm {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\treturn r.shms[id]\n}\n\n// Precondition: Caller must hold r.mu.\nfunc (r *Registry) findByKey(key int32) *Shm {\n\tfor _, v := range r.shms {\n\t\tif v.key == key {\n\t\t\treturn v\n\t\t}\n\t}\n\treturn nil\n}\n\n// FindOrCreate looks up or creates a segment in the registry. It's functionally\n// analogous to open(2).\nfunc (r *Registry) FindOrCreate(ctx context.Context, pid, key int32, size uint64, mode linux.FileMode, private, create, exclusive bool) (*Shm, error) {\n\tif (create || private) && (size < linux.SHMMIN || size > linux.SHMMAX) {\n\t\t// \"A new segment was to be created and size is less than SHMMIN or\n\t\t// greater than SHMMAX.\" - man shmget(2)\n\t\t//\n\t\t// Note that 'private' always implies the creation of a new segment\n\t\t// whether IPC_CREAT is specified or not.\n\t\treturn nil, syserror.EINVAL\n\t}\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif len(r.shms) >= linux.SHMMNI {\n\t\t// \"All possible shared memory IDs have been taken (SHMMNI) ...\"\n\t\t//   - man shmget(2)\n\t\treturn nil, syserror.ENOSPC\n\t}\n\n\tif !private {\n\t\t// Look up an existing segment.\n\t\tif shm := r.findByKey(key); shm != nil {\n\t\t\tshm.mu.Lock()\n\t\t\tdefer shm.mu.Unlock()\n\n\t\t\t// Check that caller can access the segment.\n\t\t\tif !shm.checkPermissions(ctx, fs.PermsFromMode(mode)) {\n\t\t\t\t// \"The user does not have permission to access the shared\n\t\t\t\t// memory segment, and does not have the CAP_IPC_OWNER\n\t\t\t\t// capability in the user namespace that governs its IPC\n\t\t\t\t// namespace.\" - man shmget(2)\n\t\t\t\treturn nil, syserror.EACCES\n\t\t\t}\n\n\t\t\tif size > shm.size {\n\t\t\t\t// \"A segment for the given key exists, but size is greater than\n\t\t\t\t// the size of that segment.\" - man shmget(2)\n\t\t\t\treturn nil, syserror.EINVAL\n\t\t\t}\n\n\t\t\tif create && exclusive {\n\t\t\t\t// \"IPC_CREAT and IPC_EXCL were specified in shmflg, but a\n\t\t\t\t// shared memory segment already exists for key.\"\n\t\t\t\t//  - man shmget(2)\n\t\t\t\treturn nil, syserror.EEXIST\n\t\t\t}\n\n\t\t\treturn shm, nil\n\t\t}\n\n\t\tif !create {\n\t\t\t// \"No segment exists for the given key, and IPC_CREAT was not\n\t\t\t// specified.\" - man shmget(2)\n\t\t\treturn nil, syserror.ENOENT\n\t\t}\n\t}\n\n\tvar sizeAligned uint64\n\tif val, ok := usermem.Addr(size).RoundUp(); ok {\n\t\tsizeAligned = uint64(val)\n\t} else {\n\t\treturn nil, syserror.EINVAL\n\t}\n\n\tif numPages := sizeAligned / usermem.PageSize; r.totalPages+numPages > linux.SHMALL {\n\t\t// \"... allocating a segment of the requested size would cause the\n\t\t// system to exceed the system-wide limit on shared memory (SHMALL).\"\n\t\t//   - man shmget(2)\n\t\treturn nil, syserror.ENOSPC\n\t}\n\n\t// Need to create a new segment.\n\tcreator := fs.FileOwnerFromContext(ctx)\n\tperms := fs.FilePermsFromMode(mode)\n\treturn r.newShm(ctx, pid, key, creator, perms, size)\n}\n\n// newShm creates a new segment in the registry.\nfunc (r *Registry) newShm(ctx context.Context, pid, key int32, creator fs.FileOwner, perms fs.FilePermissions, size uint64) (*Shm, error) {\n\tp := platform.FromContext(ctx)\n\tif p == nil {\n\t\tpanic(fmt.Sprintf(\"context.Context %T lacks non-nil value for key %T\", ctx, platform.CtxPlatform))\n\t}\n\n\teffectiveSize := uint64(usermem.Addr(size).MustRoundUp())\n\tfr, err := p.Memory().Allocate(effectiveSize, usage.Anonymous)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tshm := &Shm{\n\t\tp:             p,\n\t\tregistry:      r,\n\t\tcreator:       creator,\n\t\tsize:          size,\n\t\teffectiveSize: effectiveSize,\n\t\tfr:            fr,\n\t\tkey:           key,\n\t\tperms:         perms,\n\t\towner:         creator,\n\t\tcreatorPID:    pid,\n\t\tchangeTime:    ktime.NowFromContext(ctx),\n\t}\n\n\t// Find the next available ID.\n\tfor id := r.lastIDUsed + 1; id != r.lastIDUsed; id++ {\n\t\t// Handle wrap around.\n\t\tif id < 0 {\n\t\t\tid = 0\n\t\t\tcontinue\n\t\t}\n\t\tif r.shms[id] == nil {\n\t\t\tr.lastIDUsed = id\n\t\t\tr.shms[id] = shm\n\t\t\tshm.ID = id\n\n\t\t\tr.totalPages += effectiveSize / usermem.PageSize\n\n\t\t\treturn shm, nil\n\t\t}\n\t}\n\n\tlog.Warningf(\"Shm ids exhuasted, they may be leaking\")\n\treturn nil, syserror.ENOSPC\n}\n\n// IPCInfo reports global parameters for sysv shared memory segments on this\n// system. See shmctl(IPC_INFO).\nfunc (r *Registry) IPCInfo() *linux.ShmParams {\n\treturn &linux.ShmParams{\n\t\tShmMax: linux.SHMMAX,\n\t\tShmMin: linux.SHMMIN,\n\t\tShmMni: linux.SHMMNI,\n\t\tShmSeg: linux.SHMSEG,\n\t\tShmAll: linux.SHMALL,\n\t}\n}\n\n// ShmInfo reports linux-specific global parameters for sysv shared memory\n// segments on this system. See shmctl(SHM_INFO).\nfunc (r *Registry) ShmInfo() *linux.ShmInfo {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\treturn &linux.ShmInfo{\n\t\tUsedIDs: int32(r.lastIDUsed),\n\t\tShmTot:  r.totalPages,\n\t\tShmRss:  r.totalPages, // We could probably get a better estimate from memory accounting.\n\t\tShmSwp:  0,            // No reclaim at the moment.\n\t}\n}\n\n// remove unregisters a segment from this registry, preventing it from being\n// discovered in the future. Caller is responsible for ensuring s is destroyed.\n//\n// Precondition: To preserve lock ordering, caller must not hold s.mu.\nfunc (r *Registry) remove(s *Shm) {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\tdelete(r.shms, s.ID)\n\tr.totalPages -= s.effectiveSize / usermem.PageSize\n}\n\n// Shm represents a single shared memory segment.\n//\n// Shm segment are backed directly by an allocation from platform\n// memory. Segments are always mapped as a whole, greatly simplifying how\n// mappings are tracked. However note that mremap and munmap calls may cause the\n// vma for a segment to become fragmented; which requires special care when\n// unmapping a segment. See mm/shm.go.\n//\n// Segments persist until they are explicitly marked for destruction via\n// shmctl(SHM_RMID).\n//\n// Shm implements memmap.Mappable and memmap.MappingIdentity.\n//\n// +stateify savable\ntype Shm struct {\n\t// AtomicRefCount tracks the number of references to this segment from\n\t// maps. A segment always holds a reference to itself, until it's marked for\n\t// destruction.\n\trefs.AtomicRefCount\n\n\tp platform.Platform\n\n\t// registry points to the shm registry containing this segment. Immutable.\n\tregistry *Registry\n\n\t// ID is the kernel identifier for this segment. Immutable.\n\tID int32\n\n\t// creator is the user that created the segment. Immutable.\n\tcreator fs.FileOwner\n\n\t// size is the requested size of the segment at creation, in\n\t// bytes. Immutable.\n\tsize uint64\n\n\t// effectiveSize of the segment, rounding up to the next page\n\t// boundary. Immutable.\n\t//\n\t// Invariant: effectiveSize must be a multiple of usermem.PageSize.\n\teffectiveSize uint64\n\n\t// fr is the offset into platform.Memory() that backs this contents of this\n\t// segment. Immutable.\n\tfr platform.FileRange\n\n\t// key is the public identifier for this segment.\n\tkey int32\n\n\t// mu protects all fields below.\n\tmu sync.Mutex `state:\"nosave\"`\n\n\t// perms is the access permissions for the segment.\n\tperms fs.FilePermissions\n\n\t// owner of this segment.\n\towner fs.FileOwner\n\t// attachTime is updated on every successful shmat.\n\tattachTime ktime.Time\n\t// detachTime is updated on every successful shmdt.\n\tdetachTime ktime.Time\n\t// changeTime is updated on every successful changes to the segment via\n\t// shmctl(IPC_SET).\n\tchangeTime ktime.Time\n\n\t// creatorPID is the PID of the process that created the segment.\n\tcreatorPID int32\n\t// lastAttachDetachPID is the pid of the process that issued the last shmat\n\t// or shmdt syscall.\n\tlastAttachDetachPID int32\n\n\t// pendingDestruction indicates the segment was marked as destroyed through\n\t// shmctl(IPC_RMID). When marked as destroyed, the segment will not be found\n\t// in the registry and can no longer be attached. When the last user\n\t// detaches from the segment, it is destroyed. Protected by mu.\n\tpendingDestruction bool\n}\n\n// MappedName implements memmap.MappingIdentity.MappedName.\nfunc (s *Shm) MappedName(ctx context.Context) string {\n\treturn fmt.Sprintf(\"SYSV%08d\", s.key)\n}\n\n// DeviceID implements memmap.MappingIdentity.DeviceID.\nfunc (s *Shm) DeviceID() uint64 {\n\treturn shmDevice.DeviceID()\n}\n\n// InodeID implements memmap.MappingIdentity.InodeID.\nfunc (s *Shm) InodeID() uint64 {\n\t// \"shmid gets reported as \"inode#\" in /proc/pid/maps. proc-ps tools use\n\t// this. Changing this will break them.\" -- Linux, ipc/shm.c:newseg()\n\treturn uint64(s.ID)\n}\n\n// DecRef overrides refs.RefCount.DecRef with a destructor.\nfunc (s *Shm) DecRef() {\n\ts.DecRefWithDestructor(s.destroy)\n}\n\n// Msync implements memmap.MappingIdentity.Msync. Msync is a no-op for shm\n// segments.\nfunc (s *Shm) Msync(context.Context, memmap.MappableRange) error {\n\treturn nil\n}\n\n// AddMapping implements memmap.Mappable.AddMapping.\nfunc (s *Shm) AddMapping(ctx context.Context, ms memmap.MappingSpace, ar usermem.AddrRange, offset uint64) error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.attachTime = ktime.NowFromContext(ctx)\n\tif pid, ok := context.ThreadGroupIDFromContext(ctx); ok {\n\t\ts.lastAttachDetachPID = pid\n\t} else {\n\t\t// AddMapping is called during a syscall, so ctx should always be a task\n\t\t// context.\n\t\tlog.Warningf(\"Adding mapping to shm %+v but couldn't get the current pid; not updating the last attach pid\", s)\n\t}\n\treturn nil\n}\n\n// RemoveMapping implements memmap.Mappable.RemoveMapping.\nfunc (s *Shm) RemoveMapping(ctx context.Context, ms memmap.MappingSpace, ar usermem.AddrRange, offset uint64) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\t// TODO: RemoveMapping may be called during task exit, when ctx\n\t// is context.Background. Gracefully handle missing clocks. Failing to\n\t// update the detach time in these cases is ok, since no one can observe the\n\t// omission.\n\tif clock := ktime.RealtimeClockFromContext(ctx); clock != nil {\n\t\ts.detachTime = clock.Now()\n\t}\n\n\t// If called from a non-task context we also won't have a threadgroup\n\t// id. Silently skip updating the lastAttachDetachPid in that case.\n\tif pid, ok := context.ThreadGroupIDFromContext(ctx); ok {\n\t\ts.lastAttachDetachPID = pid\n\t} else {\n\t\tlog.Debugf(\"Couldn't obtain pid when removing mapping to shm %+v, not updating the last detach pid.\", s)\n\t}\n}\n\n// CopyMapping implements memmap.Mappable.CopyMapping.\nfunc (s *Shm) CopyMapping(ctx context.Context, ms memmap.MappingSpace, srcAR, dstAR usermem.AddrRange, offset uint64) error {\n\treturn nil\n}\n\n// Translate implements memmap.Mappable.Translate.\nfunc (s *Shm) Translate(ctx context.Context, required, optional memmap.MappableRange, at usermem.AccessType) ([]memmap.Translation, error) {\n\tvar err error\n\tif required.End > s.fr.Length() {\n\t\terr = &memmap.BusError{syserror.EFAULT}\n\t}\n\tif source := optional.Intersect(memmap.MappableRange{0, s.fr.Length()}); source.Length() != 0 {\n\t\treturn []memmap.Translation{\n\t\t\t{\n\t\t\t\tSource: source,\n\t\t\t\tFile:   s.p.Memory(),\n\t\t\t\tOffset: s.fr.Start + source.Start,\n\t\t\t},\n\t\t}, err\n\t}\n\treturn nil, err\n}\n\n// InvalidateUnsavable implements memmap.Mappable.InvalidateUnsavable.\nfunc (s *Shm) InvalidateUnsavable(ctx context.Context) error {\n\treturn nil\n}\n\n// AttachOpts describes various flags passed to shmat(2).\ntype AttachOpts struct {\n\tExecute  bool\n\tReadonly bool\n\tRemap    bool\n}\n\n// ConfigureAttach creates an mmap configuration for the segment with the\n// requested attach options.\n//\n// ConfigureAttach returns with a ref on s on success. The caller should drop\n// this once the map is installed. This reference prevents s from being\n// destroyed before the returned configuration is used.\nfunc (s *Shm) ConfigureAttach(ctx context.Context, addr usermem.Addr, opts AttachOpts) (memmap.MMapOpts, error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tif s.pendingDestruction && s.ReadRefs() == 0 {\n\t\treturn memmap.MMapOpts{}, syserror.EIDRM\n\t}\n\n\tif !s.checkPermissions(ctx, fs.PermMask{\n\t\tRead:    true,\n\t\tWrite:   !opts.Readonly,\n\t\tExecute: opts.Execute,\n\t}) {\n\t\t// \"The calling process does not have the required permissions for the\n\t\t// requested attach type, and does not have the CAP_IPC_OWNER capability\n\t\t// in the user namespace that governs its IPC namespace.\" - man shmat(2)\n\t\treturn memmap.MMapOpts{}, syserror.EACCES\n\t}\n\ts.IncRef()\n\treturn memmap.MMapOpts{\n\t\tLength: s.size,\n\t\tOffset: 0,\n\t\tAddr:   addr,\n\t\tFixed:  opts.Remap,\n\t\tPerms: usermem.AccessType{\n\t\t\tRead:    true,\n\t\t\tWrite:   !opts.Readonly,\n\t\t\tExecute: opts.Execute,\n\t\t},\n\t\tMaxPerms:        usermem.AnyAccess,\n\t\tMappable:        s,\n\t\tMappingIdentity: s,\n\t}, nil\n}\n\n// EffectiveSize returns the size of the underlying shared memory segment. This\n// may be larger than the requested size at creation, due to rounding to page\n// boundaries.\nfunc (s *Shm) EffectiveSize() uint64 {\n\treturn s.effectiveSize\n}\n\n// IPCStat returns information about a shm. See shmctl(IPC_STAT).\nfunc (s *Shm) IPCStat(ctx context.Context) (*linux.ShmidDS, error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\t// \"The caller must have read permission on the shared memory segment.\"\n\t//   - man shmctl(2)\n\tif !s.checkPermissions(ctx, fs.PermMask{Read: true}) {\n\t\t// \"IPC_STAT or SHM_STAT is requested and shm_perm.mode does not allow\n\t\t// read access for shmid, and the calling process does not have the\n\t\t// CAP_IPC_OWNER capability in the user namespace that governs its IPC\n\t\t// namespace.\" - man shmctl(2)\n\t\treturn nil, syserror.EACCES\n\t}\n\n\tvar mode uint16\n\tif s.pendingDestruction {\n\t\tmode |= linux.SHM_DEST\n\t}\n\tcreds := auth.CredentialsFromContext(ctx)\n\n\tnattach := uint64(s.ReadRefs())\n\t// Don't report the self-reference we keep prior to being marked for\n\t// destruction. However, also don't report a count of -1 for segments marked\n\t// as destroyed, with no mappings.\n\tif !s.pendingDestruction {\n\t\tnattach--\n\t}\n\n\tds := &linux.ShmidDS{\n\t\tShmPerm: linux.IPCPerm{\n\t\t\tKey:  uint32(s.key),\n\t\t\tUID:  uint32(creds.UserNamespace.MapFromKUID(s.owner.UID)),\n\t\t\tGID:  uint32(creds.UserNamespace.MapFromKGID(s.owner.GID)),\n\t\t\tCUID: uint32(creds.UserNamespace.MapFromKUID(s.creator.UID)),\n\t\t\tCGID: uint32(creds.UserNamespace.MapFromKGID(s.creator.GID)),\n\t\t\tMode: mode | uint16(s.perms.LinuxMode()),\n\t\t\tSeq:  0, // IPC sequences not supported.\n\t\t},\n\t\tShmSegsz:   s.size,\n\t\tShmAtime:   s.attachTime.TimeT(),\n\t\tShmDtime:   s.detachTime.TimeT(),\n\t\tShmCtime:   s.changeTime.TimeT(),\n\t\tShmCpid:    s.creatorPID,\n\t\tShmLpid:    s.lastAttachDetachPID,\n\t\tShmNattach: nattach,\n\t}\n\n\treturn ds, nil\n}\n\n// Set modifies attributes for a segment. See shmctl(IPC_SET).\nfunc (s *Shm) Set(ctx context.Context, ds *linux.ShmidDS) error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tif !s.checkOwnership(ctx) {\n\t\treturn syserror.EPERM\n\t}\n\n\tcreds := auth.CredentialsFromContext(ctx)\n\tuid := creds.UserNamespace.MapToKUID(auth.UID(ds.ShmPerm.UID))\n\tgid := creds.UserNamespace.MapToKGID(auth.GID(ds.ShmPerm.GID))\n\tif !uid.Ok() || !gid.Ok() {\n\t\treturn syserror.EINVAL\n\t}\n\n\t// User may only modify the lower 9 bits of the mode. All the other bits are\n\t// always 0 for the underlying inode.\n\tmode := linux.FileMode(ds.ShmPerm.Mode & 0x1ff)\n\ts.perms = fs.FilePermsFromMode(mode)\n\n\ts.owner.UID = uid\n\ts.owner.GID = gid\n\n\ts.changeTime = ktime.NowFromContext(ctx)\n\treturn nil\n}\n\nfunc (s *Shm) destroy() {\n\ts.registry.remove(s)\n\ts.p.Memory().DecRef(s.fr)\n}\n\n// MarkDestroyed marks a shm for destruction. The shm is actually destroyed once\n// it has no references. See shmctl(IPC_RMID).\nfunc (s *Shm) MarkDestroyed() {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\t// Prevent the segment from being found in the registry.\n\ts.key = linux.IPC_PRIVATE\n\ts.pendingDestruction = true\n\ts.DecRef()\n}\n\n// checkOwnership verifies whether a segment may be accessed by ctx as an\n// owner. See ipc/util.c:ipcctl_pre_down_nolock() in Linux.\n//\n// Precondition: Caller must hold s.mu.\nfunc (s *Shm) checkOwnership(ctx context.Context) bool {\n\tcreds := auth.CredentialsFromContext(ctx)\n\tif s.owner.UID == creds.EffectiveKUID || s.creator.UID == creds.EffectiveKUID {\n\t\treturn true\n\t}\n\n\t// Tasks with CAP_SYS_ADMIN may bypass ownership checks. Strangely, Linux\n\t// doesn't use CAP_IPC_OWNER for this despite CAP_IPC_OWNER being documented\n\t// for use to \"override IPC ownership checks\".\n\treturn creds.HasCapabilityIn(linux.CAP_SYS_ADMIN, s.registry.userNS)\n}\n\n// checkPermissions verifies whether a segment is accessible by ctx for access\n// described by req. See ipc/util.c:ipcperms() in Linux.\n//\n// Precondition: Caller must hold s.mu.\nfunc (s *Shm) checkPermissions(ctx context.Context, req fs.PermMask) bool {\n\tcreds := auth.CredentialsFromContext(ctx)\n\n\tp := s.perms.Other\n\tif s.owner.UID == creds.EffectiveKUID {\n\t\tp = s.perms.User\n\t} else if creds.InGroup(s.owner.GID) {\n\t\tp = s.perms.Group\n\t}\n\tif p.SupersetOf(req) {\n\t\treturn true\n\t}\n\n\t// Tasks with CAP_IPC_OWNER may bypass permission checks.\n\treturn creds.HasCapabilityIn(linux.CAP_IPC_OWNER, s.registry.userNS)\n}\n", "// Copyright 2018 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage linux\n\nimport (\n\t\"gvisor.googlesource.com/gvisor/pkg/abi/linux\"\n\t\"gvisor.googlesource.com/gvisor/pkg/sentry/arch\"\n\t\"gvisor.googlesource.com/gvisor/pkg/sentry/kernel\"\n\t\"gvisor.googlesource.com/gvisor/pkg/sentry/kernel/shm\"\n\t\"gvisor.googlesource.com/gvisor/pkg/syserror\"\n)\n\n// Shmget implements shmget(2).\nfunc Shmget(t *kernel.Task, args arch.SyscallArguments) (uintptr, *kernel.SyscallControl, error) {\n\tkey := args[0].Int()\n\tsize := uint64(args[1].SizeT())\n\tflag := args[2].Int()\n\n\tprivate := key == linux.IPC_PRIVATE\n\tcreate := flag&linux.IPC_CREAT == linux.IPC_CREAT\n\texclusive := flag&linux.IPC_EXCL == linux.IPC_EXCL\n\tmode := linux.FileMode(flag & 0777)\n\n\tpid := int32(t.ThreadGroup().ID())\n\tr := t.IPCNamespace().ShmRegistry()\n\tsegment, err := r.FindOrCreate(t, pid, key, size, mode, private, create, exclusive)\n\tif err != nil {\n\t\treturn 0, nil, err\n\t}\n\treturn uintptr(segment.ID), nil, nil\n}\n\n// findSegment retrives a shm segment by the given id.\nfunc findSegment(t *kernel.Task, id int32) (*shm.Shm, error) {\n\tr := t.IPCNamespace().ShmRegistry()\n\tsegment := r.FindByID(id)\n\tif segment == nil {\n\t\t// No segment with provided id.\n\t\treturn nil, syserror.EINVAL\n\t}\n\treturn segment, nil\n}\n\n// Shmat implements shmat(2).\nfunc Shmat(t *kernel.Task, args arch.SyscallArguments) (uintptr, *kernel.SyscallControl, error) {\n\tid := args[0].Int()\n\taddr := args[1].Pointer()\n\tflag := args[2].Int()\n\n\tsegment, err := findSegment(t, id)\n\tif err != nil {\n\t\treturn 0, nil, syserror.EINVAL\n\t}\n\n\topts, err := segment.ConfigureAttach(t, addr, shm.AttachOpts{\n\t\tExecute:  flag&linux.SHM_EXEC == linux.SHM_EXEC,\n\t\tReadonly: flag&linux.SHM_RDONLY == linux.SHM_RDONLY,\n\t\tRemap:    flag&linux.SHM_REMAP == linux.SHM_REMAP,\n\t})\n\tif err != nil {\n\t\treturn 0, nil, err\n\t}\n\tdefer segment.DecRef()\n\taddr, err = t.MemoryManager().MMap(t, opts)\n\treturn uintptr(addr), nil, err\n}\n\n// Shmdt implements shmdt(2).\nfunc Shmdt(t *kernel.Task, args arch.SyscallArguments) (uintptr, *kernel.SyscallControl, error) {\n\taddr := args[0].Pointer()\n\terr := t.MemoryManager().DetachShm(t, addr)\n\treturn 0, nil, err\n}\n\n// Shmctl implements shmctl(2).\nfunc Shmctl(t *kernel.Task, args arch.SyscallArguments) (uintptr, *kernel.SyscallControl, error) {\n\tid := args[0].Int()\n\tcmd := args[1].Int()\n\tbuf := args[2].Pointer()\n\n\tr := t.IPCNamespace().ShmRegistry()\n\n\tswitch cmd {\n\tcase linux.SHM_STAT:\n\t\t// Technically, we should be treating id as \"an index into the kernel's\n\t\t// internal array that maintains information about all shared memory\n\t\t// segments on the system\". Since we don't track segments in an array,\n\t\t// we'll just pretend the shmid is the index and do the same thing as\n\t\t// IPC_STAT. Linux also uses the index as the shmid.\n\t\tfallthrough\n\tcase linux.IPC_STAT:\n\t\tsegment, err := findSegment(t, id)\n\t\tif err != nil {\n\t\t\treturn 0, nil, syserror.EINVAL\n\t\t}\n\n\t\tstat, err := segment.IPCStat(t)\n\t\tif err == nil {\n\t\t\t_, err = t.CopyOut(buf, stat)\n\t\t}\n\t\treturn 0, nil, err\n\n\tcase linux.IPC_INFO:\n\t\tparams := r.IPCInfo()\n\t\t_, err := t.CopyOut(buf, params)\n\t\treturn 0, nil, err\n\n\tcase linux.SHM_INFO:\n\t\tinfo := r.ShmInfo()\n\t\t_, err := t.CopyOut(buf, info)\n\t\treturn 0, nil, err\n\t}\n\n\t// Remaining commands refer to a specific segment.\n\tsegment, err := findSegment(t, id)\n\tif err != nil {\n\t\treturn 0, nil, syserror.EINVAL\n\t}\n\n\tswitch cmd {\n\tcase linux.IPC_SET:\n\t\tvar ds linux.ShmidDS\n\t\t_, err = t.CopyIn(buf, &ds)\n\t\tif err != nil {\n\t\t\treturn 0, nil, err\n\t\t}\n\t\terr = segment.Set(t, &ds)\n\t\treturn 0, nil, err\n\n\tcase linux.IPC_RMID:\n\t\tsegment.MarkDestroyed()\n\t\treturn 0, nil, nil\n\n\tcase linux.SHM_LOCK, linux.SHM_UNLOCK:\n\t\t// We currently do not support memmory locking anywhere.\n\t\t// mlock(2)/munlock(2) are currently stubbed out as no-ops so do the\n\t\t// same here.\n\t\tt.Kernel().EmitUnimplementedEvent(t)\n\t\treturn 0, nil, nil\n\n\tdefault:\n\t\treturn 0, nil, syserror.EINVAL\n\t}\n}\n"], "fixing_code": ["// Copyright 2018 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Package shm implements sysv shared memory segments.\n//\n// Known missing features:\n//\n// - SHM_LOCK/SHM_UNLOCK are no-ops. The sentry currently doesn't implement\n//   memory locking in general.\n//\n// - SHM_HUGETLB and related flags for shmget(2) are ignored. There's no easy\n//   way to implement hugetlb support on a per-map basis, and it has no impact\n//   on correctness.\n//\n// - SHM_NORESERVE for shmget(2) is ignored, the sentry doesn't implement swap\n//   so it's meaningless to reserve space for swap.\n//\n// - No per-process segment size enforcement. This feature probably isn't used\n//   much anyways, since Linux sets the per-process limits to the system-wide\n//   limits by default.\n//\n// Lock ordering: mm.mappingMu -> shm registry lock -> shm lock\npackage shm\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\n\t\"gvisor.googlesource.com/gvisor/pkg/abi/linux\"\n\t\"gvisor.googlesource.com/gvisor/pkg/log\"\n\t\"gvisor.googlesource.com/gvisor/pkg/refs\"\n\t\"gvisor.googlesource.com/gvisor/pkg/sentry/context\"\n\t\"gvisor.googlesource.com/gvisor/pkg/sentry/fs\"\n\t\"gvisor.googlesource.com/gvisor/pkg/sentry/kernel/auth\"\n\tktime \"gvisor.googlesource.com/gvisor/pkg/sentry/kernel/time\"\n\t\"gvisor.googlesource.com/gvisor/pkg/sentry/memmap\"\n\t\"gvisor.googlesource.com/gvisor/pkg/sentry/platform\"\n\t\"gvisor.googlesource.com/gvisor/pkg/sentry/usage\"\n\t\"gvisor.googlesource.com/gvisor/pkg/sentry/usermem\"\n\t\"gvisor.googlesource.com/gvisor/pkg/syserror\"\n)\n\n// Registry tracks all shared memory segments in an IPC namespace. The registry\n// provides the mechanisms for creating and finding segments, and reporting\n// global shm parameters.\n//\n// +stateify savable\ntype Registry struct {\n\t// userNS owns the IPC namespace this registry belong to. Immutable.\n\tuserNS *auth.UserNamespace\n\n\tmu sync.Mutex `state:\"nosave\"`\n\n\t// shms maps segment ids to segments. Protected by mu.\n\tshms map[int32]*Shm\n\n\t// Sum of the sizes of all existing segments rounded up to page size, in\n\t// units of page size. Protected by mu.\n\ttotalPages uint64\n\n\t// lastIDUsed is protected by mu.\n\tlastIDUsed int32\n}\n\n// NewRegistry creates a new shm registry.\nfunc NewRegistry(userNS *auth.UserNamespace) *Registry {\n\treturn &Registry{\n\t\tuserNS: userNS,\n\t\tshms:   make(map[int32]*Shm),\n\t}\n}\n\n// FindByID looks up a segment given an ID.\nfunc (r *Registry) FindByID(id int32) *Shm {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\treturn r.shms[id]\n}\n\n// Precondition: Caller must hold r.mu.\nfunc (r *Registry) findByKey(key int32) *Shm {\n\tfor _, v := range r.shms {\n\t\tif v.key == key {\n\t\t\treturn v\n\t\t}\n\t}\n\treturn nil\n}\n\n// FindOrCreate looks up or creates a segment in the registry. It's functionally\n// analogous to open(2).\nfunc (r *Registry) FindOrCreate(ctx context.Context, pid, key int32, size uint64, mode linux.FileMode, private, create, exclusive bool) (*Shm, error) {\n\tif (create || private) && (size < linux.SHMMIN || size > linux.SHMMAX) {\n\t\t// \"A new segment was to be created and size is less than SHMMIN or\n\t\t// greater than SHMMAX.\" - man shmget(2)\n\t\t//\n\t\t// Note that 'private' always implies the creation of a new segment\n\t\t// whether IPC_CREAT is specified or not.\n\t\treturn nil, syserror.EINVAL\n\t}\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif len(r.shms) >= linux.SHMMNI {\n\t\t// \"All possible shared memory IDs have been taken (SHMMNI) ...\"\n\t\t//   - man shmget(2)\n\t\treturn nil, syserror.ENOSPC\n\t}\n\n\tif !private {\n\t\t// Look up an existing segment.\n\t\tif shm := r.findByKey(key); shm != nil {\n\t\t\tshm.mu.Lock()\n\t\t\tdefer shm.mu.Unlock()\n\n\t\t\t// Check that caller can access the segment.\n\t\t\tif !shm.checkPermissions(ctx, fs.PermsFromMode(mode)) {\n\t\t\t\t// \"The user does not have permission to access the shared\n\t\t\t\t// memory segment, and does not have the CAP_IPC_OWNER\n\t\t\t\t// capability in the user namespace that governs its IPC\n\t\t\t\t// namespace.\" - man shmget(2)\n\t\t\t\treturn nil, syserror.EACCES\n\t\t\t}\n\n\t\t\tif size > shm.size {\n\t\t\t\t// \"A segment for the given key exists, but size is greater than\n\t\t\t\t// the size of that segment.\" - man shmget(2)\n\t\t\t\treturn nil, syserror.EINVAL\n\t\t\t}\n\n\t\t\tif create && exclusive {\n\t\t\t\t// \"IPC_CREAT and IPC_EXCL were specified in shmflg, but a\n\t\t\t\t// shared memory segment already exists for key.\"\n\t\t\t\t//  - man shmget(2)\n\t\t\t\treturn nil, syserror.EEXIST\n\t\t\t}\n\n\t\t\treturn shm, nil\n\t\t}\n\n\t\tif !create {\n\t\t\t// \"No segment exists for the given key, and IPC_CREAT was not\n\t\t\t// specified.\" - man shmget(2)\n\t\t\treturn nil, syserror.ENOENT\n\t\t}\n\t}\n\n\tvar sizeAligned uint64\n\tif val, ok := usermem.Addr(size).RoundUp(); ok {\n\t\tsizeAligned = uint64(val)\n\t} else {\n\t\treturn nil, syserror.EINVAL\n\t}\n\n\tif numPages := sizeAligned / usermem.PageSize; r.totalPages+numPages > linux.SHMALL {\n\t\t// \"... allocating a segment of the requested size would cause the\n\t\t// system to exceed the system-wide limit on shared memory (SHMALL).\"\n\t\t//   - man shmget(2)\n\t\treturn nil, syserror.ENOSPC\n\t}\n\n\t// Need to create a new segment.\n\tcreator := fs.FileOwnerFromContext(ctx)\n\tperms := fs.FilePermsFromMode(mode)\n\treturn r.newShm(ctx, pid, key, creator, perms, size)\n}\n\n// newShm creates a new segment in the registry.\nfunc (r *Registry) newShm(ctx context.Context, pid, key int32, creator fs.FileOwner, perms fs.FilePermissions, size uint64) (*Shm, error) {\n\tp := platform.FromContext(ctx)\n\tif p == nil {\n\t\tpanic(fmt.Sprintf(\"context.Context %T lacks non-nil value for key %T\", ctx, platform.CtxPlatform))\n\t}\n\n\teffectiveSize := uint64(usermem.Addr(size).MustRoundUp())\n\tfr, err := p.Memory().Allocate(effectiveSize, usage.Anonymous)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tshm := &Shm{\n\t\tp:             p,\n\t\tregistry:      r,\n\t\tcreator:       creator,\n\t\tsize:          size,\n\t\teffectiveSize: effectiveSize,\n\t\tfr:            fr,\n\t\tkey:           key,\n\t\tperms:         perms,\n\t\towner:         creator,\n\t\tcreatorPID:    pid,\n\t\tchangeTime:    ktime.NowFromContext(ctx),\n\t}\n\n\t// Find the next available ID.\n\tfor id := r.lastIDUsed + 1; id != r.lastIDUsed; id++ {\n\t\t// Handle wrap around.\n\t\tif id < 0 {\n\t\t\tid = 0\n\t\t\tcontinue\n\t\t}\n\t\tif r.shms[id] == nil {\n\t\t\tr.lastIDUsed = id\n\t\t\tr.shms[id] = shm\n\t\t\tshm.ID = id\n\n\t\t\tr.totalPages += effectiveSize / usermem.PageSize\n\n\t\t\treturn shm, nil\n\t\t}\n\t}\n\n\tlog.Warningf(\"Shm ids exhuasted, they may be leaking\")\n\treturn nil, syserror.ENOSPC\n}\n\n// IPCInfo reports global parameters for sysv shared memory segments on this\n// system. See shmctl(IPC_INFO).\nfunc (r *Registry) IPCInfo() *linux.ShmParams {\n\treturn &linux.ShmParams{\n\t\tShmMax: linux.SHMMAX,\n\t\tShmMin: linux.SHMMIN,\n\t\tShmMni: linux.SHMMNI,\n\t\tShmSeg: linux.SHMSEG,\n\t\tShmAll: linux.SHMALL,\n\t}\n}\n\n// ShmInfo reports linux-specific global parameters for sysv shared memory\n// segments on this system. See shmctl(SHM_INFO).\nfunc (r *Registry) ShmInfo() *linux.ShmInfo {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\treturn &linux.ShmInfo{\n\t\tUsedIDs: int32(r.lastIDUsed),\n\t\tShmTot:  r.totalPages,\n\t\tShmRss:  r.totalPages, // We could probably get a better estimate from memory accounting.\n\t\tShmSwp:  0,            // No reclaim at the moment.\n\t}\n}\n\n// remove unregisters a segment from this registry, preventing it from being\n// discovered in the future. Caller is responsible for ensuring s is destroyed.\n//\n// Precondition: To preserve lock ordering, caller must not hold s.mu.\nfunc (r *Registry) remove(s *Shm) {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\tdelete(r.shms, s.ID)\n\tr.totalPages -= s.effectiveSize / usermem.PageSize\n}\n\n// Shm represents a single shared memory segment.\n//\n// Shm segment are backed directly by an allocation from platform\n// memory. Segments are always mapped as a whole, greatly simplifying how\n// mappings are tracked. However note that mremap and munmap calls may cause the\n// vma for a segment to become fragmented; which requires special care when\n// unmapping a segment. See mm/shm.go.\n//\n// Segments persist until they are explicitly marked for destruction via\n// shmctl(SHM_RMID).\n//\n// Shm implements memmap.Mappable and memmap.MappingIdentity.\n//\n// +stateify savable\ntype Shm struct {\n\t// AtomicRefCount tracks the number of references to this segment from\n\t// maps. A segment always holds a reference to itself, until it's marked for\n\t// destruction.\n\trefs.AtomicRefCount\n\n\tp platform.Platform\n\n\t// registry points to the shm registry containing this segment. Immutable.\n\tregistry *Registry\n\n\t// ID is the kernel identifier for this segment. Immutable.\n\tID int32\n\n\t// creator is the user that created the segment. Immutable.\n\tcreator fs.FileOwner\n\n\t// size is the requested size of the segment at creation, in\n\t// bytes. Immutable.\n\tsize uint64\n\n\t// effectiveSize of the segment, rounding up to the next page\n\t// boundary. Immutable.\n\t//\n\t// Invariant: effectiveSize must be a multiple of usermem.PageSize.\n\teffectiveSize uint64\n\n\t// fr is the offset into platform.Memory() that backs this contents of this\n\t// segment. Immutable.\n\tfr platform.FileRange\n\n\t// key is the public identifier for this segment.\n\tkey int32\n\n\t// mu protects all fields below.\n\tmu sync.Mutex `state:\"nosave\"`\n\n\t// perms is the access permissions for the segment.\n\tperms fs.FilePermissions\n\n\t// owner of this segment.\n\towner fs.FileOwner\n\t// attachTime is updated on every successful shmat.\n\tattachTime ktime.Time\n\t// detachTime is updated on every successful shmdt.\n\tdetachTime ktime.Time\n\t// changeTime is updated on every successful changes to the segment via\n\t// shmctl(IPC_SET).\n\tchangeTime ktime.Time\n\n\t// creatorPID is the PID of the process that created the segment.\n\tcreatorPID int32\n\t// lastAttachDetachPID is the pid of the process that issued the last shmat\n\t// or shmdt syscall.\n\tlastAttachDetachPID int32\n\n\t// pendingDestruction indicates the segment was marked as destroyed through\n\t// shmctl(IPC_RMID). When marked as destroyed, the segment will not be found\n\t// in the registry and can no longer be attached. When the last user\n\t// detaches from the segment, it is destroyed. Protected by mu.\n\tpendingDestruction bool\n}\n\n// MappedName implements memmap.MappingIdentity.MappedName.\nfunc (s *Shm) MappedName(ctx context.Context) string {\n\treturn fmt.Sprintf(\"SYSV%08d\", s.key)\n}\n\n// DeviceID implements memmap.MappingIdentity.DeviceID.\nfunc (s *Shm) DeviceID() uint64 {\n\treturn shmDevice.DeviceID()\n}\n\n// InodeID implements memmap.MappingIdentity.InodeID.\nfunc (s *Shm) InodeID() uint64 {\n\t// \"shmid gets reported as \"inode#\" in /proc/pid/maps. proc-ps tools use\n\t// this. Changing this will break them.\" -- Linux, ipc/shm.c:newseg()\n\treturn uint64(s.ID)\n}\n\n// DecRef overrides refs.RefCount.DecRef with a destructor.\nfunc (s *Shm) DecRef() {\n\ts.DecRefWithDestructor(s.destroy)\n}\n\n// Msync implements memmap.MappingIdentity.Msync. Msync is a no-op for shm\n// segments.\nfunc (s *Shm) Msync(context.Context, memmap.MappableRange) error {\n\treturn nil\n}\n\n// AddMapping implements memmap.Mappable.AddMapping.\nfunc (s *Shm) AddMapping(ctx context.Context, ms memmap.MappingSpace, ar usermem.AddrRange, offset uint64) error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.attachTime = ktime.NowFromContext(ctx)\n\tif pid, ok := context.ThreadGroupIDFromContext(ctx); ok {\n\t\ts.lastAttachDetachPID = pid\n\t} else {\n\t\t// AddMapping is called during a syscall, so ctx should always be a task\n\t\t// context.\n\t\tlog.Warningf(\"Adding mapping to shm %+v but couldn't get the current pid; not updating the last attach pid\", s)\n\t}\n\treturn nil\n}\n\n// RemoveMapping implements memmap.Mappable.RemoveMapping.\nfunc (s *Shm) RemoveMapping(ctx context.Context, ms memmap.MappingSpace, ar usermem.AddrRange, offset uint64) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\t// TODO: RemoveMapping may be called during task exit, when ctx\n\t// is context.Background. Gracefully handle missing clocks. Failing to\n\t// update the detach time in these cases is ok, since no one can observe the\n\t// omission.\n\tif clock := ktime.RealtimeClockFromContext(ctx); clock != nil {\n\t\ts.detachTime = clock.Now()\n\t}\n\n\t// If called from a non-task context we also won't have a threadgroup\n\t// id. Silently skip updating the lastAttachDetachPid in that case.\n\tif pid, ok := context.ThreadGroupIDFromContext(ctx); ok {\n\t\ts.lastAttachDetachPID = pid\n\t} else {\n\t\tlog.Debugf(\"Couldn't obtain pid when removing mapping to shm %+v, not updating the last detach pid.\", s)\n\t}\n}\n\n// CopyMapping implements memmap.Mappable.CopyMapping.\nfunc (s *Shm) CopyMapping(ctx context.Context, ms memmap.MappingSpace, srcAR, dstAR usermem.AddrRange, offset uint64) error {\n\treturn nil\n}\n\n// Translate implements memmap.Mappable.Translate.\nfunc (s *Shm) Translate(ctx context.Context, required, optional memmap.MappableRange, at usermem.AccessType) ([]memmap.Translation, error) {\n\tvar err error\n\tif required.End > s.fr.Length() {\n\t\terr = &memmap.BusError{syserror.EFAULT}\n\t}\n\tif source := optional.Intersect(memmap.MappableRange{0, s.fr.Length()}); source.Length() != 0 {\n\t\treturn []memmap.Translation{\n\t\t\t{\n\t\t\t\tSource: source,\n\t\t\t\tFile:   s.p.Memory(),\n\t\t\t\tOffset: s.fr.Start + source.Start,\n\t\t\t},\n\t\t}, err\n\t}\n\treturn nil, err\n}\n\n// InvalidateUnsavable implements memmap.Mappable.InvalidateUnsavable.\nfunc (s *Shm) InvalidateUnsavable(ctx context.Context) error {\n\treturn nil\n}\n\n// AttachOpts describes various flags passed to shmat(2).\ntype AttachOpts struct {\n\tExecute  bool\n\tReadonly bool\n\tRemap    bool\n}\n\n// ConfigureAttach creates an mmap configuration for the segment with the\n// requested attach options.\n//\n// ConfigureAttach returns with a ref on s on success. The caller should drop\n// this once the map is installed. This reference prevents s from being\n// destroyed before the returned configuration is used.\nfunc (s *Shm) ConfigureAttach(ctx context.Context, addr usermem.Addr, opts AttachOpts) (memmap.MMapOpts, error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tif s.pendingDestruction && s.ReadRefs() == 0 {\n\t\treturn memmap.MMapOpts{}, syserror.EIDRM\n\t}\n\n\tif !s.checkPermissions(ctx, fs.PermMask{\n\t\tRead:    true,\n\t\tWrite:   !opts.Readonly,\n\t\tExecute: opts.Execute,\n\t}) {\n\t\t// \"The calling process does not have the required permissions for the\n\t\t// requested attach type, and does not have the CAP_IPC_OWNER capability\n\t\t// in the user namespace that governs its IPC namespace.\" - man shmat(2)\n\t\treturn memmap.MMapOpts{}, syserror.EACCES\n\t}\n\ts.IncRef()\n\treturn memmap.MMapOpts{\n\t\tLength: s.size,\n\t\tOffset: 0,\n\t\tAddr:   addr,\n\t\tFixed:  opts.Remap,\n\t\tPerms: usermem.AccessType{\n\t\t\tRead:    true,\n\t\t\tWrite:   !opts.Readonly,\n\t\t\tExecute: opts.Execute,\n\t\t},\n\t\tMaxPerms:        usermem.AnyAccess,\n\t\tMappable:        s,\n\t\tMappingIdentity: s,\n\t}, nil\n}\n\n// EffectiveSize returns the size of the underlying shared memory segment. This\n// may be larger than the requested size at creation, due to rounding to page\n// boundaries.\nfunc (s *Shm) EffectiveSize() uint64 {\n\treturn s.effectiveSize\n}\n\n// IPCStat returns information about a shm. See shmctl(IPC_STAT).\nfunc (s *Shm) IPCStat(ctx context.Context) (*linux.ShmidDS, error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\t// \"The caller must have read permission on the shared memory segment.\"\n\t//   - man shmctl(2)\n\tif !s.checkPermissions(ctx, fs.PermMask{Read: true}) {\n\t\t// \"IPC_STAT or SHM_STAT is requested and shm_perm.mode does not allow\n\t\t// read access for shmid, and the calling process does not have the\n\t\t// CAP_IPC_OWNER capability in the user namespace that governs its IPC\n\t\t// namespace.\" - man shmctl(2)\n\t\treturn nil, syserror.EACCES\n\t}\n\n\tvar mode uint16\n\tif s.pendingDestruction {\n\t\tmode |= linux.SHM_DEST\n\t}\n\tcreds := auth.CredentialsFromContext(ctx)\n\n\tnattach := uint64(s.ReadRefs())\n\t// Don't report the self-reference we keep prior to being marked for\n\t// destruction. However, also don't report a count of -1 for segments marked\n\t// as destroyed, with no mappings.\n\tif !s.pendingDestruction {\n\t\tnattach--\n\t}\n\n\tds := &linux.ShmidDS{\n\t\tShmPerm: linux.IPCPerm{\n\t\t\tKey:  uint32(s.key),\n\t\t\tUID:  uint32(creds.UserNamespace.MapFromKUID(s.owner.UID)),\n\t\t\tGID:  uint32(creds.UserNamespace.MapFromKGID(s.owner.GID)),\n\t\t\tCUID: uint32(creds.UserNamespace.MapFromKUID(s.creator.UID)),\n\t\t\tCGID: uint32(creds.UserNamespace.MapFromKGID(s.creator.GID)),\n\t\t\tMode: mode | uint16(s.perms.LinuxMode()),\n\t\t\tSeq:  0, // IPC sequences not supported.\n\t\t},\n\t\tShmSegsz:   s.size,\n\t\tShmAtime:   s.attachTime.TimeT(),\n\t\tShmDtime:   s.detachTime.TimeT(),\n\t\tShmCtime:   s.changeTime.TimeT(),\n\t\tShmCpid:    s.creatorPID,\n\t\tShmLpid:    s.lastAttachDetachPID,\n\t\tShmNattach: nattach,\n\t}\n\n\treturn ds, nil\n}\n\n// Set modifies attributes for a segment. See shmctl(IPC_SET).\nfunc (s *Shm) Set(ctx context.Context, ds *linux.ShmidDS) error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tif !s.checkOwnership(ctx) {\n\t\treturn syserror.EPERM\n\t}\n\n\tcreds := auth.CredentialsFromContext(ctx)\n\tuid := creds.UserNamespace.MapToKUID(auth.UID(ds.ShmPerm.UID))\n\tgid := creds.UserNamespace.MapToKGID(auth.GID(ds.ShmPerm.GID))\n\tif !uid.Ok() || !gid.Ok() {\n\t\treturn syserror.EINVAL\n\t}\n\n\t// User may only modify the lower 9 bits of the mode. All the other bits are\n\t// always 0 for the underlying inode.\n\tmode := linux.FileMode(ds.ShmPerm.Mode & 0x1ff)\n\ts.perms = fs.FilePermsFromMode(mode)\n\n\ts.owner.UID = uid\n\ts.owner.GID = gid\n\n\ts.changeTime = ktime.NowFromContext(ctx)\n\treturn nil\n}\n\nfunc (s *Shm) destroy() {\n\ts.registry.remove(s)\n\ts.p.Memory().DecRef(s.fr)\n}\n\n// MarkDestroyed marks a shm for destruction. The shm is actually destroyed once\n// it has no references. See shmctl(IPC_RMID).\nfunc (s *Shm) MarkDestroyed() {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\t// Prevent the segment from being found in the registry.\n\ts.key = linux.IPC_PRIVATE\n\n\t// Only drop the segment's self-reference once, when destruction is\n\t// requested. Otherwise, repeated calls shmctl(IPC_RMID) would force a\n\t// segment to be destroyed prematurely, potentially with active maps to the\n\t// segment's address range. Remaining references are dropped when the\n\t// segment is detached or unmaped.\n\tif !s.pendingDestruction {\n\t\ts.pendingDestruction = true\n\t\ts.DecRef()\n\t}\n}\n\n// checkOwnership verifies whether a segment may be accessed by ctx as an\n// owner. See ipc/util.c:ipcctl_pre_down_nolock() in Linux.\n//\n// Precondition: Caller must hold s.mu.\nfunc (s *Shm) checkOwnership(ctx context.Context) bool {\n\tcreds := auth.CredentialsFromContext(ctx)\n\tif s.owner.UID == creds.EffectiveKUID || s.creator.UID == creds.EffectiveKUID {\n\t\treturn true\n\t}\n\n\t// Tasks with CAP_SYS_ADMIN may bypass ownership checks. Strangely, Linux\n\t// doesn't use CAP_IPC_OWNER for this despite CAP_IPC_OWNER being documented\n\t// for use to \"override IPC ownership checks\".\n\treturn creds.HasCapabilityIn(linux.CAP_SYS_ADMIN, s.registry.userNS)\n}\n\n// checkPermissions verifies whether a segment is accessible by ctx for access\n// described by req. See ipc/util.c:ipcperms() in Linux.\n//\n// Precondition: Caller must hold s.mu.\nfunc (s *Shm) checkPermissions(ctx context.Context, req fs.PermMask) bool {\n\tcreds := auth.CredentialsFromContext(ctx)\n\n\tp := s.perms.Other\n\tif s.owner.UID == creds.EffectiveKUID {\n\t\tp = s.perms.User\n\t} else if creds.InGroup(s.owner.GID) {\n\t\tp = s.perms.Group\n\t}\n\tif p.SupersetOf(req) {\n\t\treturn true\n\t}\n\n\t// Tasks with CAP_IPC_OWNER may bypass permission checks.\n\treturn creds.HasCapabilityIn(linux.CAP_IPC_OWNER, s.registry.userNS)\n}\n", "// Copyright 2018 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage linux\n\nimport (\n\t\"gvisor.googlesource.com/gvisor/pkg/abi/linux\"\n\t\"gvisor.googlesource.com/gvisor/pkg/sentry/arch\"\n\t\"gvisor.googlesource.com/gvisor/pkg/sentry/kernel\"\n\t\"gvisor.googlesource.com/gvisor/pkg/sentry/kernel/shm\"\n\t\"gvisor.googlesource.com/gvisor/pkg/syserror\"\n)\n\n// Shmget implements shmget(2).\nfunc Shmget(t *kernel.Task, args arch.SyscallArguments) (uintptr, *kernel.SyscallControl, error) {\n\tkey := args[0].Int()\n\tsize := uint64(args[1].SizeT())\n\tflag := args[2].Int()\n\n\tprivate := key == linux.IPC_PRIVATE\n\tcreate := flag&linux.IPC_CREAT == linux.IPC_CREAT\n\texclusive := flag&linux.IPC_EXCL == linux.IPC_EXCL\n\tmode := linux.FileMode(flag & 0777)\n\n\tpid := int32(t.ThreadGroup().ID())\n\tr := t.IPCNamespace().ShmRegistry()\n\tsegment, err := r.FindOrCreate(t, pid, key, size, mode, private, create, exclusive)\n\tif err != nil {\n\t\treturn 0, nil, err\n\t}\n\treturn uintptr(segment.ID), nil, nil\n}\n\n// findSegment retrives a shm segment by the given id.\nfunc findSegment(t *kernel.Task, id int32) (*shm.Shm, error) {\n\tr := t.IPCNamespace().ShmRegistry()\n\tsegment := r.FindByID(id)\n\tif segment == nil {\n\t\t// No segment with provided id.\n\t\treturn nil, syserror.EINVAL\n\t}\n\treturn segment, nil\n}\n\n// Shmat implements shmat(2).\nfunc Shmat(t *kernel.Task, args arch.SyscallArguments) (uintptr, *kernel.SyscallControl, error) {\n\tid := args[0].Int()\n\taddr := args[1].Pointer()\n\tflag := args[2].Int()\n\n\tsegment, err := findSegment(t, id)\n\tif err != nil {\n\t\treturn 0, nil, syserror.EINVAL\n\t}\n\n\topts, err := segment.ConfigureAttach(t, addr, shm.AttachOpts{\n\t\tExecute:  flag&linux.SHM_EXEC == linux.SHM_EXEC,\n\t\tReadonly: flag&linux.SHM_RDONLY == linux.SHM_RDONLY,\n\t\tRemap:    flag&linux.SHM_REMAP == linux.SHM_REMAP,\n\t})\n\tif err != nil {\n\t\treturn 0, nil, err\n\t}\n\tdefer segment.DecRef()\n\taddr, err = t.MemoryManager().MMap(t, opts)\n\treturn uintptr(addr), nil, err\n}\n\n// Shmdt implements shmdt(2).\nfunc Shmdt(t *kernel.Task, args arch.SyscallArguments) (uintptr, *kernel.SyscallControl, error) {\n\taddr := args[0].Pointer()\n\terr := t.MemoryManager().DetachShm(t, addr)\n\treturn 0, nil, err\n}\n\n// Shmctl implements shmctl(2).\nfunc Shmctl(t *kernel.Task, args arch.SyscallArguments) (uintptr, *kernel.SyscallControl, error) {\n\tid := args[0].Int()\n\tcmd := args[1].Int()\n\tbuf := args[2].Pointer()\n\n\tr := t.IPCNamespace().ShmRegistry()\n\n\tswitch cmd {\n\tcase linux.SHM_STAT:\n\t\t// Technically, we should be treating id as \"an index into the kernel's\n\t\t// internal array that maintains information about all shared memory\n\t\t// segments on the system\". Since we don't track segments in an array,\n\t\t// we'll just pretend the shmid is the index and do the same thing as\n\t\t// IPC_STAT. Linux also uses the index as the shmid.\n\t\tfallthrough\n\tcase linux.IPC_STAT:\n\t\tsegment, err := findSegment(t, id)\n\t\tif err != nil {\n\t\t\treturn 0, nil, syserror.EINVAL\n\t\t}\n\n\t\tstat, err := segment.IPCStat(t)\n\t\tif err == nil {\n\t\t\t_, err = t.CopyOut(buf, stat)\n\t\t}\n\t\treturn 0, nil, err\n\n\tcase linux.IPC_INFO:\n\t\tparams := r.IPCInfo()\n\t\t_, err := t.CopyOut(buf, params)\n\t\treturn 0, nil, err\n\n\tcase linux.SHM_INFO:\n\t\tinfo := r.ShmInfo()\n\t\t_, err := t.CopyOut(buf, info)\n\t\treturn 0, nil, err\n\t}\n\n\t// Remaining commands refer to a specific segment.\n\tsegment, err := findSegment(t, id)\n\tif err != nil {\n\t\treturn 0, nil, syserror.EINVAL\n\t}\n\n\tswitch cmd {\n\tcase linux.IPC_SET:\n\t\tvar ds linux.ShmidDS\n\t\t_, err = t.CopyIn(buf, &ds)\n\t\tif err != nil {\n\t\t\treturn 0, nil, err\n\t\t}\n\t\terr = segment.Set(t, &ds)\n\t\treturn 0, nil, err\n\n\tcase linux.IPC_RMID:\n\t\tsegment.MarkDestroyed()\n\t\treturn 0, nil, nil\n\n\tcase linux.SHM_LOCK, linux.SHM_UNLOCK:\n\t\t// We currently do not support memory locking anywhere.\n\t\t// mlock(2)/munlock(2) are currently stubbed out as no-ops so do the\n\t\t// same here.\n\t\tt.Kernel().EmitUnimplementedEvent(t)\n\t\treturn 0, nil, nil\n\n\tdefault:\n\t\treturn 0, nil, syserror.EINVAL\n\t}\n}\n"], "filenames": ["pkg/sentry/kernel/shm/shm.go", "pkg/sentry/syscalls/linux/sys_shm.go"], "buggy_code_start_loc": [577, 147], "buggy_code_end_loc": [582, 148], "fixing_code_start_loc": [578, 147], "fixing_code_end_loc": [591, 148], "type": "NVD-CWE-noinfo", "message": "pkg/sentry/kernel/shm/shm.go in Google gVisor before 2018-11-01 allows attackers to overwrite memory locations in processes running as root (but not escape the sandbox) via vectors involving IPC_RMID shmctl calls, because reference counting is mishandled.", "other": {"cve": {"id": "CVE-2018-19333", "sourceIdentifier": "cve@mitre.org", "published": "2018-11-17T17:29:00.227", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "pkg/sentry/kernel/shm/shm.go in Google gVisor before 2018-11-01 allows attackers to overwrite memory locations in processes running as root (but not escape the sandbox) via vectors involving IPC_RMID shmctl calls, because reference counting is mishandled."}, {"lang": "es", "value": "pkg/sentry/kernel/shm/shm.go en Google gVisor en versiones anteriores a la 2018-11-01 permite que los atacantes sobrescriban ubicaciones de memoria en procesos que se ejecutan como root (pero que no escapan del sandbox) mediante vectores relacionados con las llamadas shmctl IPC_RMID. Esto se debe a que el conteo de referencias se gestiona de manera incorrecta."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:gvisor:*:*:*:*:*:*:*:*", "versionEndExcluding": "2018-11-01", "matchCriteriaId": "63294ECB-847A-4190-84E3-679773AB2CBF"}]}]}], "references": [{"url": "https://github.com/google/gvisor/commit/0e277a39c8b6f905e289b75e8ad0594e6b3562ca", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://justi.cz/security/2018/11/14/gvisor-lpe.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/google/gvisor/commit/0e277a39c8b6f905e289b75e8ad0594e6b3562ca"}}