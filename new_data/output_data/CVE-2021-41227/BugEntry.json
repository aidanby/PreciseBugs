{"buggy_code": ["/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/kernels/immutable_constant_op.h\"\n\n#include <unordered_set>\n\n#include \"tensorflow/core/framework/types.pb.h\"\n\nnamespace tensorflow {\n\nnamespace {\nclass MemmappedTensorAllocator : public Allocator {\n public:\n  MemmappedTensorAllocator() {}\n\n  Status InitializeFromRegion(const string& name, Env* env) {\n    const auto status =\n        env->NewReadOnlyMemoryRegionFromFile(name, &memory_region_);\n    if (!status.ok()) {\n      return status;\n    }\n    return Status::OK();\n  }\n  string Name() override { return \"MemmappedTensorAllocator\"; }\n\n  void* AllocateRaw(size_t alignment, size_t num_bytes) override {\n    if ((reinterpret_cast<intptr_t>(memory_region_->data())) % alignment != 0) {\n      allocation_status_ =\n          errors::Internal(\"Readonly memory region has wrong alignment\");\n      return nullptr;\n    }\n    if (num_bytes > memory_region_->length()) {\n      allocation_status_ = errors::Internal(\n          \"Readonly memory region has wrong length (\", memory_region_->length(),\n          \") when allocating \", num_bytes);\n      return nullptr;\n    }\n    return const_cast<void*>(memory_region_->data());\n  }\n\n  void DeallocateRaw(void* ptr) override {\n    if (ptr != memory_region_->data()) {\n      LOG(ERROR)\n          << \"Deallocating not allocated region for readonly memory region\";\n    }\n    if (delete_on_deallocate_) {\n      delete this;\n    }\n  }\n  const Status& allocation_status() const { return allocation_status_; }\n\n  void set_delete_on_deallocate() { delete_on_deallocate_ = true; }\n\n  // Make sure tensors or complex types (strings, variants, resources) don't get\n  // their constructor called via a placement new since that would require\n  // writing to immutable data.\n  // See also: tensorflow/core/framework/typed_allocator.h\n  bool AllocatesOpaqueHandle() const override { return true; }\n\n private:\n  std::unique_ptr<ReadOnlyMemoryRegion> memory_region_;\n  // If there is an error during allocation we keep it in this status.\n  Status allocation_status_;\n\n  // When the allocator is owned by TensorBuffer it will be deleted on\n  // de-allocation.\n  bool delete_on_deallocate_ = false;\n\n  TF_DISALLOW_COPY_AND_ASSIGN(MemmappedTensorAllocator);\n};\n}  // namespace\n\nImmutableConstantOp::ImmutableConstantOp(OpKernelConstruction* context)\n    : OpKernel(context) {\n  OP_REQUIRES_OK(context,\n                 context->GetAttr(kMemoryRegionNameAttr, &region_name_));\n  OP_REQUIRES_OK(context, context->GetAttr(kDTypeAttr, &dtype_));\n  OP_REQUIRES(context, dtype_ != DT_RESOURCE && dtype_ != DT_VARIANT,\n              errors::InvalidArgument(\n                  \"Resource and variant dtypes are invalid for this op.\"));\n  OP_REQUIRES_OK(context, context->GetAttr(kShapeAttr, &shape_));\n}\n\nvoid ImmutableConstantOp::Compute(OpKernelContext* ctx) {\n  std::unique_ptr<MemmappedTensorAllocator> allocator(\n      new MemmappedTensorAllocator());\n\n  OP_REQUIRES_OK(ctx,\n                 allocator->InitializeFromRegion(region_name_, ctx->env()));\n  ctx->set_output(0, Tensor(allocator.get(), dtype_, shape_));\n  OP_REQUIRES_OK(ctx, allocator->allocation_status());\n  // Allocator is owned by the tensor from this point.\n  allocator.release()->set_delete_on_deallocate();\n}\n\nImmutableConstantOp::~ImmutableConstantOp() {}\nconstexpr char const* ImmutableConstantOp::kDTypeAttr;\nconstexpr char const* ImmutableConstantOp::kShapeAttr;\nconstexpr char const* ImmutableConstantOp::kMemoryRegionNameAttr;\n\nREGISTER_KERNEL_BUILDER(Name(\"ImmutableConst\").Device(DEVICE_CPU),\n                        ImmutableConstantOp);\n}  // namespace tensorflow\n", "/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include \"tensorflow/core/kernels/immutable_constant_op.h\"\n\n#include <algorithm>\n#include <tuple>\n\n#include \"tensorflow/cc/ops/standard_ops.h\"\n#include \"tensorflow/core/framework/allocator.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/graph/graph_def_builder.h\"\n#include \"tensorflow/core/lib/core/status_test_util.h\"\n#include \"tensorflow/core/lib/io/path.h\"\n#include \"tensorflow/core/platform/null_file_system.h\"\n#include \"tensorflow/core/platform/test.h\"\n#include \"tensorflow/core/platform/test_benchmark.h\"\n#include \"tensorflow/core/public/session.h\"\n\nnamespace tensorflow {\nnamespace {\n// A safe alignment that equal to memmapped page alignment on many modern\n// architectures.\nconstexpr size_t kTestAlignment = 4096;\nconstexpr size_t kTestTensorSize = 4;\nconstexpr size_t kTestTensorSizeBytes = kTestTensorSize * sizeof(float);\n\n// A test ReadOnlyMemoryRegion implementation.\nclass TestReadOnlyMemoryRegion : public ReadOnlyMemoryRegion {\n public:\n  TestReadOnlyMemoryRegion() = delete;\n  explicit TestReadOnlyMemoryRegion(uint64 length)\n      : memptr_(cpu_allocator()->AllocateRaw(kTestAlignment, length)),\n        length_(length) {}\n  ~TestReadOnlyMemoryRegion() override {\n    cpu_allocator()->DeallocateRaw(memptr_);\n  }\n  const void* data() override { return memptr_; }\n  float* GetWritableDataStart() { return reinterpret_cast<float*>(memptr_); }\n  uint64 length() override { return length_; }\n\n protected:\n  void* memptr_;\n  uint64 length_;\n};\n\n// A mock file system and environment class that creates ReadOnlyMemoryRegion\n// from allocated memory.\nclass TestFileSystem : public NullFileSystem {\n public:\n  ~TestFileSystem() override = default;\n\n  // import non-transactional method from the base class\n  using NullFileSystem::NewReadOnlyMemoryRegionFromFile;\n\n  Status NewReadOnlyMemoryRegionFromFile(\n      const string& fname, TransactionToken* token,\n      std::unique_ptr<ReadOnlyMemoryRegion>* result) override {\n    float val = 0;\n    StringPiece scheme, host, path;\n    io::ParseURI(fname, &scheme, &host, &path);\n    // For the tests create in-memory regions with float values equal to the\n    // region name.\n    if (path == \"/2\") {\n      val = 2.0f;\n    } else if (path == \"/3\") {\n      val = 3.0f;\n    } else {\n      val = 0.0f;\n    }\n\n    auto region = new TestReadOnlyMemoryRegion(kTestTensorSizeBytes);\n    std::fill_n(region->GetWritableDataStart(), kTestTensorSize, val);\n    result->reset(region);\n    return Status::OK();\n  }\n};\n\nREGISTER_FILE_SYSTEM(\"test\", TestFileSystem);\n\nstruct ImmutableConstantOpTest {};\n\nTEST(ImmutableConstantOpTest, Simple) {\n  const TensorShape kTestTensorShape({4, 1});\n  const TensorShape kTestTensorShapeT({1, 4});\n  auto root = Scope::NewRootScope().ExitOnError();\n  auto node1 =\n      ops::ImmutableConst(root, DT_FLOAT, kTestTensorShape, \"test:///2\");\n  auto node2 =\n      ops::ImmutableConst(root, DT_FLOAT, kTestTensorShapeT, \"test:///3\");\n  auto result = ops::MatMul(root, node1, node2);\n  GraphDef graph_def;\n  TF_ASSERT_OK(root.ToGraphDef(&graph_def));\n  SessionOptions session_options;\n  session_options.env = Env::Default();\n  session_options.config.mutable_graph_options()\n      ->mutable_optimizer_options()\n      ->set_opt_level(OptimizerOptions::L0);\n  std::unique_ptr<Session> session(NewSession(session_options));\n  ASSERT_TRUE(session != nullptr) << \"Failed to create session\";\n  TF_ASSERT_OK(session->Create(graph_def)) << \"Can't create test graph\";\n  std::vector<Tensor> outputs;\n  TF_ASSERT_OK(session->Run({}, {result.node()->name() + \":0\"}, {}, &outputs));\n  ASSERT_EQ(outputs.size(), 1);\n  EXPECT_EQ(outputs.front().flat<float>()(0), 2.0f * 3.0f);\n  EXPECT_EQ(outputs.front().flat<float>()(1), 2.0f * 3.0f);\n  EXPECT_EQ(outputs.front().flat<float>()(2), 2.0f * 3.0f);\n  EXPECT_EQ(outputs.front().flat<float>()(kTestTensorSize - 1), 2.0f * 3.0f);\n}\n\n// Creates a test graph with two immutable_const tensors and a simple math\n// operation, one of nodes has wrong size, check that error properly reported.\n\nTEST(ImmutableConstantOpTest, ExecutionError) {\n  const TensorShape kBadTensorShape({40, 100});\n  const TensorShape kTestTensorShapeT({1, 4});\n\n  auto root = Scope::DisabledShapeInferenceScope().ExitOnError();\n  auto node1 =\n      ops::ImmutableConst(root, DT_FLOAT, kBadTensorShape, \"test:///2\");\n  auto node2 =\n      ops::ImmutableConst(root, DT_FLOAT, kTestTensorShapeT, \"test:///3\");\n  auto result = ops::MatMul(root, node1, node2);\n  GraphDef graph_def;\n  TF_ASSERT_OK(root.ToGraphDef(&graph_def));\n  SessionOptions session_options;\n  session_options.env = Env::Default();\n  std::unique_ptr<Session> session(NewSession(session_options));\n  ASSERT_TRUE(session != nullptr) << \"Failed to create session\";\n  TF_ASSERT_OK(session->Create(graph_def)) << \"Can't create test graph\";\n  std::vector<Tensor> outputs;\n  // Check that the run returned error.\n  EXPECT_EQ(\n      session->Run({}, {result.node()->name() + \":0\"}, {}, &outputs).code(),\n      error::INTERNAL);\n}\n\nStatus CreateTempFile(Env* env, float value, uint64 size, string* filename) {\n  const string dir = testing::TmpDir();\n  *filename = io::JoinPath(dir, strings::StrCat(\"file_\", value));\n  std::unique_ptr<WritableFile> file;\n  TF_RETURN_IF_ERROR(env->NewWritableFile(*filename, &file));\n  for (uint64 i = 0; i < size; ++i) {\n    StringPiece sp(static_cast<char*>(static_cast<void*>(&value)),\n                   sizeof(value));\n    TF_RETURN_IF_ERROR(file->Append(sp));\n  }\n  TF_RETURN_IF_ERROR(file->Close());\n  return Status::OK();\n}\n\nTEST(ImmutableConstantOpTest, FromFile) {\n  const TensorShape kFileTensorShape({1000, 1});\n  Env* env = Env::Default();\n  auto root = Scope::NewRootScope().ExitOnError();\n\n  string two_file, three_file;\n  TF_ASSERT_OK(CreateTempFile(env, 2.0f, 1000, &two_file));\n  TF_ASSERT_OK(CreateTempFile(env, 3.0f, 1000, &three_file));\n  auto node1 = ops::ImmutableConst(root, DT_FLOAT, kFileTensorShape, two_file);\n  auto node2 =\n      ops::ImmutableConst(root, DT_FLOAT, kFileTensorShape, three_file);\n  auto result = ops::MatMul(root, node1, node2, ops::MatMul::TransposeB(true));\n\n  GraphDef graph_def;\n  TF_ASSERT_OK(root.ToGraphDef(&graph_def));\n  SessionOptions session_options;\n  session_options.config.mutable_graph_options()\n      ->mutable_optimizer_options()\n      ->set_opt_level(OptimizerOptions::L0);\n  std::unique_ptr<Session> session(NewSession(session_options));\n  ASSERT_TRUE(session != nullptr) << \"Failed to create session\";\n  TF_ASSERT_OK(session->Create(graph_def)) << \"Can't create test graph\";\n  std::vector<Tensor> outputs;\n  TF_ASSERT_OK(session->Run({}, {result.node()->name() + \":0\"}, {}, &outputs));\n  ASSERT_EQ(outputs.size(), 1);\n  EXPECT_EQ(outputs.front().flat<float>()(0), 2.0f * 3.0f);\n  EXPECT_EQ(outputs.front().flat<float>()(1), 2.0f * 3.0f);\n  EXPECT_EQ(outputs.front().flat<float>()(2), 2.0f * 3.0f);\n}\n\n}  // namespace\n}  // namespace tensorflow\n"], "fixing_code": ["/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/kernels/immutable_constant_op.h\"\n\n#include <unordered_set>\n\n#include \"tensorflow/core/framework/types.pb.h\"\n\nnamespace tensorflow {\n\nnamespace {\nclass MemmappedTensorAllocator : public Allocator {\n public:\n  MemmappedTensorAllocator() {}\n\n  Status InitializeFromRegion(const string& name, Env* env) {\n    const auto status =\n        env->NewReadOnlyMemoryRegionFromFile(name, &memory_region_);\n    if (!status.ok()) {\n      return status;\n    }\n    return Status::OK();\n  }\n  string Name() override { return \"MemmappedTensorAllocator\"; }\n\n  void* AllocateRaw(size_t alignment, size_t num_bytes) override {\n    if ((reinterpret_cast<intptr_t>(memory_region_->data())) % alignment != 0) {\n      allocation_status_ =\n          errors::Internal(\"Readonly memory region has wrong alignment\");\n      return nullptr;\n    }\n    if (num_bytes > memory_region_->length()) {\n      allocation_status_ = errors::Internal(\n          \"Readonly memory region has wrong length (\", memory_region_->length(),\n          \") when allocating \", num_bytes);\n      return nullptr;\n    }\n    return const_cast<void*>(memory_region_->data());\n  }\n\n  void DeallocateRaw(void* ptr) override {\n    if (ptr != memory_region_->data()) {\n      LOG(ERROR)\n          << \"Deallocating not allocated region for readonly memory region\";\n    }\n    if (delete_on_deallocate_) {\n      delete this;\n    }\n  }\n  const Status& allocation_status() const { return allocation_status_; }\n\n  void set_delete_on_deallocate() { delete_on_deallocate_ = true; }\n\n  // Make sure tensors or complex types (strings, variants, resources) don't get\n  // their constructor called via a placement new since that would require\n  // writing to immutable data.\n  // See also: tensorflow/core/framework/typed_allocator.h\n  bool AllocatesOpaqueHandle() const override { return true; }\n\n private:\n  std::unique_ptr<ReadOnlyMemoryRegion> memory_region_;\n  // If there is an error during allocation we keep it in this status.\n  Status allocation_status_;\n\n  // When the allocator is owned by TensorBuffer it will be deleted on\n  // de-allocation.\n  bool delete_on_deallocate_ = false;\n\n  TF_DISALLOW_COPY_AND_ASSIGN(MemmappedTensorAllocator);\n};\n}  // namespace\n\nImmutableConstantOp::ImmutableConstantOp(OpKernelConstruction* context)\n    : OpKernel(context) {\n  OP_REQUIRES_OK(context,\n                 context->GetAttr(kMemoryRegionNameAttr, &region_name_));\n  OP_REQUIRES_OK(context, context->GetAttr(kDTypeAttr, &dtype_));\n  OP_REQUIRES(context, dtype_ != DT_RESOURCE && dtype_ != DT_VARIANT,\n              errors::InvalidArgument(\n                  \"Resource and variant dtypes are invalid for this op.\"));\n  OP_REQUIRES_OK(context, context->GetAttr(kShapeAttr, &shape_));\n}\n\nvoid ImmutableConstantOp::Compute(OpKernelContext* ctx) {\n  std::unique_ptr<MemmappedTensorAllocator> allocator(\n      new MemmappedTensorAllocator());\n\n  OP_REQUIRES_OK(ctx,\n                 allocator->InitializeFromRegion(region_name_, ctx->env()));\n  OP_REQUIRES(ctx, dtype_ != DT_STRING,\n              errors::Unimplemented(\"Sorry, DT_STRING is not currently \"\n                                    \"supported for ImmutableConstOp.\"));\n  ctx->set_output(0, Tensor(allocator.get(), dtype_, shape_));\n  OP_REQUIRES_OK(ctx, allocator->allocation_status());\n  // Allocator is owned by the tensor from this point.\n  allocator.release()->set_delete_on_deallocate();\n}\n\nImmutableConstantOp::~ImmutableConstantOp() {}\nconstexpr char const* ImmutableConstantOp::kDTypeAttr;\nconstexpr char const* ImmutableConstantOp::kShapeAttr;\nconstexpr char const* ImmutableConstantOp::kMemoryRegionNameAttr;\n\nREGISTER_KERNEL_BUILDER(Name(\"ImmutableConst\").Device(DEVICE_CPU),\n                        ImmutableConstantOp);\n}  // namespace tensorflow\n", "/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include \"tensorflow/core/kernels/immutable_constant_op.h\"\n\n#include <algorithm>\n#include <tuple>\n\n#include \"tensorflow/cc/ops/standard_ops.h\"\n#include \"tensorflow/core/framework/allocator.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/graph/graph_def_builder.h\"\n#include \"tensorflow/core/lib/core/status_test_util.h\"\n#include \"tensorflow/core/lib/io/path.h\"\n#include \"tensorflow/core/platform/null_file_system.h\"\n#include \"tensorflow/core/platform/test.h\"\n#include \"tensorflow/core/platform/test_benchmark.h\"\n#include \"tensorflow/core/public/session.h\"\n\nnamespace tensorflow {\nnamespace {\n// A safe alignment that equal to memmapped page alignment on many modern\n// architectures.\nconstexpr size_t kTestAlignment = 4096;\nconstexpr size_t kTestTensorSize = 4;\nconstexpr size_t kTestTensorSizeBytes = kTestTensorSize * sizeof(float);\n\n// A test ReadOnlyMemoryRegion implementation.\nclass TestReadOnlyMemoryRegion : public ReadOnlyMemoryRegion {\n public:\n  TestReadOnlyMemoryRegion() = delete;\n  explicit TestReadOnlyMemoryRegion(uint64 length)\n      : memptr_(cpu_allocator()->AllocateRaw(kTestAlignment, length)),\n        length_(length) {}\n  ~TestReadOnlyMemoryRegion() override {\n    cpu_allocator()->DeallocateRaw(memptr_);\n  }\n  const void* data() override { return memptr_; }\n  float* GetWritableDataStart() { return reinterpret_cast<float*>(memptr_); }\n  uint64 length() override { return length_; }\n\n protected:\n  void* memptr_;\n  uint64 length_;\n};\n\n// A mock file system and environment class that creates ReadOnlyMemoryRegion\n// from allocated memory.\nclass TestFileSystem : public NullFileSystem {\n public:\n  ~TestFileSystem() override = default;\n\n  // import non-transactional method from the base class\n  using NullFileSystem::NewReadOnlyMemoryRegionFromFile;\n\n  Status NewReadOnlyMemoryRegionFromFile(\n      const string& fname, TransactionToken* token,\n      std::unique_ptr<ReadOnlyMemoryRegion>* result) override {\n    float val = 0;\n    StringPiece scheme, host, path;\n    io::ParseURI(fname, &scheme, &host, &path);\n    // For the tests create in-memory regions with float values equal to the\n    // region name.\n    if (path == \"/2\") {\n      val = 2.0f;\n    } else if (path == \"/3\") {\n      val = 3.0f;\n    } else {\n      val = 0.0f;\n    }\n\n    auto region = new TestReadOnlyMemoryRegion(kTestTensorSizeBytes);\n    std::fill_n(region->GetWritableDataStart(), kTestTensorSize, val);\n    result->reset(region);\n    return Status::OK();\n  }\n};\n\nREGISTER_FILE_SYSTEM(\"test\", TestFileSystem);\n\nstruct ImmutableConstantOpTest {};\n\nTEST(ImmutableConstantOpTest, Simple) {\n  const TensorShape kTestTensorShape({4, 1});\n  const TensorShape kTestTensorShapeT({1, 4});\n  auto root = Scope::NewRootScope().ExitOnError();\n  auto node1 =\n      ops::ImmutableConst(root, DT_FLOAT, kTestTensorShape, \"test:///2\");\n  auto node2 =\n      ops::ImmutableConst(root, DT_FLOAT, kTestTensorShapeT, \"test:///3\");\n  auto result = ops::MatMul(root, node1, node2);\n  GraphDef graph_def;\n  TF_ASSERT_OK(root.ToGraphDef(&graph_def));\n  SessionOptions session_options;\n  session_options.env = Env::Default();\n  session_options.config.mutable_graph_options()\n      ->mutable_optimizer_options()\n      ->set_opt_level(OptimizerOptions::L0);\n  std::unique_ptr<Session> session(NewSession(session_options));\n  ASSERT_TRUE(session != nullptr) << \"Failed to create session\";\n  TF_ASSERT_OK(session->Create(graph_def)) << \"Can't create test graph\";\n  std::vector<Tensor> outputs;\n  TF_ASSERT_OK(session->Run({}, {result.node()->name() + \":0\"}, {}, &outputs));\n  ASSERT_EQ(outputs.size(), 1);\n  EXPECT_EQ(outputs.front().flat<float>()(0), 2.0f * 3.0f);\n  EXPECT_EQ(outputs.front().flat<float>()(1), 2.0f * 3.0f);\n  EXPECT_EQ(outputs.front().flat<float>()(2), 2.0f * 3.0f);\n  EXPECT_EQ(outputs.front().flat<float>()(kTestTensorSize - 1), 2.0f * 3.0f);\n}\n\n// Creates a test graph with two immutable_const tensors and a simple math\n// operation, one of nodes has wrong size, check that error properly reported.\n\nTEST(ImmutableConstantOpTest, ExecutionError) {\n  const TensorShape kBadTensorShape({40, 100});\n  const TensorShape kTestTensorShapeT({1, 4});\n\n  auto root = Scope::DisabledShapeInferenceScope().ExitOnError();\n  auto node1 =\n      ops::ImmutableConst(root, DT_FLOAT, kBadTensorShape, \"test:///2\");\n  auto node2 =\n      ops::ImmutableConst(root, DT_FLOAT, kTestTensorShapeT, \"test:///3\");\n  auto result = ops::MatMul(root, node1, node2);\n  GraphDef graph_def;\n  TF_ASSERT_OK(root.ToGraphDef(&graph_def));\n  SessionOptions session_options;\n  session_options.env = Env::Default();\n  std::unique_ptr<Session> session(NewSession(session_options));\n  ASSERT_TRUE(session != nullptr) << \"Failed to create session\";\n  TF_ASSERT_OK(session->Create(graph_def)) << \"Can't create test graph\";\n  std::vector<Tensor> outputs;\n  // Check that the run returned error.\n  EXPECT_EQ(\n      session->Run({}, {result.node()->name() + \":0\"}, {}, &outputs).code(),\n      error::INTERNAL);\n}\n\nStatus CreateTempFileFloat(Env* env, float value, uint64 size,\n                           string* filename) {\n  const string dir = testing::TmpDir();\n  *filename = io::JoinPath(dir, strings::StrCat(\"file_\", value));\n  std::unique_ptr<WritableFile> file;\n  TF_RETURN_IF_ERROR(env->NewWritableFile(*filename, &file));\n  for (uint64 i = 0; i < size; ++i) {\n    StringPiece sp(static_cast<char*>(static_cast<void*>(&value)),\n                   sizeof(value));\n    TF_RETURN_IF_ERROR(file->Append(sp));\n  }\n  TF_RETURN_IF_ERROR(file->Close());\n  return Status::OK();\n}\n\nTEST(ImmutableConstantOpTest, FromFile) {\n  const TensorShape kFileTensorShape({1000, 1});\n  Env* env = Env::Default();\n  auto root = Scope::NewRootScope().ExitOnError();\n\n  string two_file, three_file;\n  TF_ASSERT_OK(CreateTempFileFloat(env, 2.0f, 1000, &two_file));\n  TF_ASSERT_OK(CreateTempFileFloat(env, 3.0f, 1000, &three_file));\n  auto node1 = ops::ImmutableConst(root, DT_FLOAT, kFileTensorShape, two_file);\n  auto node2 =\n      ops::ImmutableConst(root, DT_FLOAT, kFileTensorShape, three_file);\n  auto result = ops::MatMul(root, node1, node2, ops::MatMul::TransposeB(true));\n\n  GraphDef graph_def;\n  TF_ASSERT_OK(root.ToGraphDef(&graph_def));\n  SessionOptions session_options;\n  session_options.config.mutable_graph_options()\n      ->mutable_optimizer_options()\n      ->set_opt_level(OptimizerOptions::L0);\n  std::unique_ptr<Session> session(NewSession(session_options));\n  ASSERT_TRUE(session != nullptr) << \"Failed to create session\";\n  TF_ASSERT_OK(session->Create(graph_def)) << \"Can't create test graph\";\n  std::vector<Tensor> outputs;\n  TF_ASSERT_OK(session->Run({}, {result.node()->name() + \":0\"}, {}, &outputs));\n  ASSERT_EQ(outputs.size(), 1);\n  EXPECT_EQ(outputs.front().flat<float>()(0), 2.0f * 3.0f);\n  EXPECT_EQ(outputs.front().flat<float>()(1), 2.0f * 3.0f);\n  EXPECT_EQ(outputs.front().flat<float>()(2), 2.0f * 3.0f);\n}\n\nStatus CreateTempFileBadString(Env* env, char value, uint64 size,\n                               const string suffix, string* filename) {\n  const string dir = testing::TmpDir();\n  *filename = io::JoinPath(dir, strings::StrCat(\"file_\", suffix));\n  std::unique_ptr<WritableFile> file;\n  TF_RETURN_IF_ERROR(env->NewWritableFile(*filename, &file));\n  TF_RETURN_IF_ERROR(file->Append(std::string(size, value)));\n  TF_RETURN_IF_ERROR(file->Close());\n  return Status::OK();\n}\n\nTEST(ImmutableConstantOpTest, FromFileStringUnimplmented) {\n  const TensorShape kFileTensorShape({1});\n  Env* env = Env::Default();\n  auto root = Scope::NewRootScope().ExitOnError();\n\n  string bad_file;\n  TF_ASSERT_OK(CreateTempFileBadString(env, '\\xe2', 128, \"bad_e2\", &bad_file));\n  auto result =\n      ops::ImmutableConst(root, DT_STRING, kFileTensorShape, bad_file);\n  GraphDef graph_def;\n  TF_ASSERT_OK(root.ToGraphDef(&graph_def));\n  SessionOptions session_options;\n  session_options.env = Env::Default();\n  std::unique_ptr<Session> session(NewSession(session_options));\n  ASSERT_TRUE(session != nullptr) << \"Failed to create session\";\n  TF_ASSERT_OK(session->Create(graph_def)) << \"Can't create test graph\";\n  std::vector<Tensor> outputs;\n  // Check that the run returned error.\n  EXPECT_EQ(\n      session->Run({}, {result.node()->name() + \":0\"}, {}, &outputs).code(),\n      error::UNIMPLEMENTED);\n}\n\n}  // namespace\n}  // namespace tensorflow\n"], "filenames": ["tensorflow/core/kernels/immutable_constant_op.cc", "tensorflow/core/kernels/immutable_constant_op_test.cc"], "buggy_code_start_loc": [102, 149], "buggy_code_end_loc": [102, 192], "fixing_code_start_loc": [103, 149], "fixing_code_end_loc": [106, 228], "type": "CWE-125", "message": "TensorFlow is an open source platform for machine learning. In affected versions the `ImmutableConst` operation in TensorFlow can be tricked into reading arbitrary memory contents. This is because the `tstring` TensorFlow string class has a special case for memory mapped strings but the operation itself does not offer any support for this datatype. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.", "other": {"cve": {"id": "CVE-2021-41227", "sourceIdentifier": "security-advisories@github.com", "published": "2021-11-05T23:15:08.603", "lastModified": "2021-11-10T13:18:24.987", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an open source platform for machine learning. In affected versions the `ImmutableConst` operation in TensorFlow can be tricked into reading arbitrary memory contents. This is because the `tstring` TensorFlow string class has a special case for memory mapped strings but the operation itself does not offer any support for this datatype. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto para el aprendizaje autom\u00e1tico. En las versiones afectadas la operaci\u00f3n \"ImmutableConst\" en TensorFlow puede ser enga\u00f1ada para leer contenidos de memoria arbitrarios. Esto es debido a que la clase de cadena \"tstring\" de TensorFlow presenta un caso especial para cadenas mapeadas en memoria, pero la operaci\u00f3n en s\u00ed no ofrece ning\u00fan soporte para este tipo de datos. La correcci\u00f3n ser\u00e1 incluida en TensorFlow versi\u00f3n 2.7.0. Tambi\u00e9n ser\u00e1 incluida este commit en TensorFlow versi\u00f3n 2.6.1, TensorFlow versi\u00f3n 2.5.2, y TensorFlow versi\u00f3n 2.4.4, ya que estos tambi\u00e9n est\u00e1n afectados y todav\u00eda est\u00e1n en el rango admitido"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.0", "versionEndExcluding": "2.4.4", "matchCriteriaId": "0E596567-6F67-4880-8EC4-CB262BF02E0D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.5.0", "versionEndExcluding": "2.5.2", "matchCriteriaId": "035CDF63-1548-4FB4-B8A9-B8D328FAF910"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.6.0", "versionEndExcluding": "2.6.1", "matchCriteriaId": "5D68D8D1-DB27-4395-9D3D-2BED901B852C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.7.0:rc0:*:*:*:*:*:*", "matchCriteriaId": "A58EDA5C-66D6-46F1-962E-60AFB7C784A7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.7.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "89522760-C2DF-400D-9624-626D8F160CBA"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/1cb6bb6c2a6019417c9adaf9e6843ba75ee2580b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/commit/3712a2d3455e6ccb924daa5724a3652a86f6b585", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-j8c8-67vp-6mx7", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/1cb6bb6c2a6019417c9adaf9e6843ba75ee2580b"}}