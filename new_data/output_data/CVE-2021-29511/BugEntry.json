{"buggy_code": ["use primitive_types::U256;\nuse core::cmp::{min, max};\nuse alloc::vec::Vec;\nuse crate::{ExitError, ExitFatal};\n\n/// A sequencial memory. It uses Rust's `Vec` for internal\n/// representation.\n#[derive(Clone, Debug)]\npub struct Memory {\n\tdata: Vec<u8>,\n\teffective_len: U256,\n\tlimit: usize,\n}\n\nimpl Memory {\n\t/// Create a new memory with the given limit.\n\tpub fn new(limit: usize) -> Self {\n\t\tSelf {\n\t\t\tdata: Vec::new(),\n\t\t\teffective_len: U256::zero(),\n\t\t\tlimit,\n\t\t}\n\t}\n\n\t/// Memory limit.\n\tpub fn limit(&self) -> usize {\n\t\tself.limit\n\t}\n\n\t/// Get the length of the current memory range.\n\tpub fn len(&self) -> usize {\n\t\tself.data.len()\n\t}\n\n\t/// Get the effective length.\n\tpub fn effective_len(&self) -> U256 {\n\t\tself.effective_len\n\t}\n\n\t/// Return true if current effective memory range is zero.\n\tpub fn is_empty(&self) -> bool {\n\t\tself.len() == 0\n\t}\n\n\t/// Return the full memory.\n\tpub fn data(&self) -> &Vec<u8> {\n\t\t&self.data\n\t}\n\n\t/// Resize the memory, making it cover the memory region of `offset..(offset\n\t/// + len)`, with 32 bytes as the step. If the length is zero, this function\n\t/// does nothing.\n\tpub fn resize_offset(&mut self, offset: U256, len: U256) -> Result<(), ExitError> {\n\t\tif len == U256::zero() {\n\t\t\treturn Ok(())\n\t\t}\n\n\t\tif let Some(end) = offset.checked_add(len) {\n\t\t\tself.resize_end(end)\n\t\t} else {\n\t\t\tErr(ExitError::InvalidRange)\n\t\t}\n\t}\n\n\t/// Resize the memory, making it cover to `end`, with 32 bytes as the step.\n\tpub fn resize_end(&mut self, mut end: U256) -> Result<(), ExitError> {\n\t\twhile end % U256::from(32) != U256::zero() {\n\t\t\tend = match end.checked_add(U256::one()) {\n\t\t\t\tSome(end) => end,\n\t\t\t\tNone => return Err(ExitError::InvalidRange)\n\t\t\t};\n\t\t}\n\n\t\tself.effective_len = max(self.effective_len, end);\n\t\tOk(())\n\t}\n\n\t/// Get memory region at given offset.\n\t///\n\t/// ## Panics\n\t///\n\t/// Value of `size` is considered trusted. If they're too large,\n\t/// the program can run out of memory, or it can overflow.\n\tpub fn get(&self, offset: usize, size: usize) -> Vec<u8> {\n\t\tlet mut ret = Vec::new();\n\t\tret.resize(size, 0);\n\n\t\tfor index in 0..size {\n\t\t\tlet position = offset + index;\n\t\t\tif position >= self.data.len() {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tret[index] = self.data[position];\n\t\t}\n\n\t\tret\n\t}\n\n\t/// Set memory region at given offset. The offset and value is considered\n\t/// untrusted.\n\tpub fn set(\n\t\t&mut self,\n\t\toffset: usize,\n\t\tvalue: &[u8],\n\t\ttarget_size: Option<usize>\n\t) -> Result<(), ExitFatal> {\n\t\tlet target_size = target_size.unwrap_or(value.len());\n\n\t\tif offset.checked_add(target_size)\n\t\t\t.map(|pos| pos > self.limit).unwrap_or(true)\n\t\t{\n\t\t\treturn Err(ExitFatal::NotSupported)\n\t\t}\n\n\t\tif self.data.len() < offset + target_size {\n\t\t\tself.data.resize(offset + target_size, 0);\n\t\t}\n\n\t\tfor index in 0..target_size {\n\t\t\tif self.data.len() > offset + index && value.len() > index {\n\t\t\t\tself.data[offset + index] = value[index];\n\t\t\t} else {\n\t\t\t\tself.data[offset + index] = 0;\n\t\t\t}\n\t\t}\n\n\t\tOk(())\n\t}\n\n\t/// Copy `data` into the memory, of given `len`.\n\tpub fn copy_large(\n\t\t&mut self,\n\t\tmemory_offset: U256,\n\t\tdata_offset: U256,\n\t\tlen: U256,\n\t\tdata: &[u8]\n\t) -> Result<(), ExitFatal> {\n\t\tlet memory_offset = if memory_offset > U256::from(usize::max_value()) {\n\t\t\treturn Err(ExitFatal::NotSupported)\n\t\t} else {\n\t\t\tmemory_offset.as_usize()\n\t\t};\n\n\t\tlet ulen = if len > U256::from(usize::max_value()) {\n\t\t\treturn Err(ExitFatal::NotSupported)\n\t\t} else {\n\t\t\tlen.as_usize()\n\t\t};\n\n\t\tlet data = if let Some(end) = data_offset.checked_add(len) {\n\t\t\tif end > U256::from(usize::max_value()) {\n\t\t\t\t&[]\n\t\t\t} else {\n\t\t\t\tlet data_offset = data_offset.as_usize();\n\t\t\t\tlet end = end.as_usize();\n\n\t\t\t\tif data_offset > data.len() {\n\t\t\t\t\t&[]\n\t\t\t\t} else {\n\t\t\t\t\t&data[data_offset..min(end, data.len())]\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t&[]\n\t\t};\n\n\t\tself.set(memory_offset, data, Some(ulen))\n\t}\n}\n"], "fixing_code": ["use primitive_types::U256;\nuse core::cmp::{min, max};\nuse alloc::vec::Vec;\nuse crate::{ExitError, ExitFatal};\n\n/// A sequencial memory. It uses Rust's `Vec` for internal\n/// representation.\n#[derive(Clone, Debug)]\npub struct Memory {\n\tdata: Vec<u8>,\n\teffective_len: U256,\n\tlimit: usize,\n}\n\nimpl Memory {\n\t/// Create a new memory with the given limit.\n\tpub fn new(limit: usize) -> Self {\n\t\tSelf {\n\t\t\tdata: Vec::new(),\n\t\t\teffective_len: U256::zero(),\n\t\t\tlimit,\n\t\t}\n\t}\n\n\t/// Memory limit.\n\tpub fn limit(&self) -> usize {\n\t\tself.limit\n\t}\n\n\t/// Get the length of the current memory range.\n\tpub fn len(&self) -> usize {\n\t\tself.data.len()\n\t}\n\n\t/// Get the effective length.\n\tpub fn effective_len(&self) -> U256 {\n\t\tself.effective_len\n\t}\n\n\t/// Return true if current effective memory range is zero.\n\tpub fn is_empty(&self) -> bool {\n\t\tself.len() == 0\n\t}\n\n\t/// Return the full memory.\n\tpub fn data(&self) -> &Vec<u8> {\n\t\t&self.data\n\t}\n\n\t/// Resize the memory, making it cover the memory region of `offset..(offset\n\t/// + len)`, with 32 bytes as the step. If the length is zero, this function\n\t/// does nothing.\n\tpub fn resize_offset(&mut self, offset: U256, len: U256) -> Result<(), ExitError> {\n\t\tif len == U256::zero() {\n\t\t\treturn Ok(())\n\t\t}\n\n\t\tif let Some(end) = offset.checked_add(len) {\n\t\t\tself.resize_end(end)\n\t\t} else {\n\t\t\tErr(ExitError::InvalidRange)\n\t\t}\n\t}\n\n\t/// Resize the memory, making it cover to `end`, with 32 bytes as the step.\n\tpub fn resize_end(&mut self, mut end: U256) -> Result<(), ExitError> {\n\t\twhile end % U256::from(32) != U256::zero() {\n\t\t\tend = match end.checked_add(U256::one()) {\n\t\t\t\tSome(end) => end,\n\t\t\t\tNone => return Err(ExitError::InvalidRange)\n\t\t\t};\n\t\t}\n\n\t\tself.effective_len = max(self.effective_len, end);\n\t\tOk(())\n\t}\n\n\t/// Get memory region at given offset.\n\t///\n\t/// ## Panics\n\t///\n\t/// Value of `size` is considered trusted. If they're too large,\n\t/// the program can run out of memory, or it can overflow.\n\tpub fn get(&self, offset: usize, size: usize) -> Vec<u8> {\n\t\tlet mut ret = Vec::new();\n\t\tret.resize(size, 0);\n\n\t\tfor index in 0..size {\n\t\t\tlet position = offset + index;\n\t\t\tif position >= self.data.len() {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tret[index] = self.data[position];\n\t\t}\n\n\t\tret\n\t}\n\n\t/// Set memory region at given offset. The offset and value is considered\n\t/// untrusted.\n\tpub fn set(\n\t\t&mut self,\n\t\toffset: usize,\n\t\tvalue: &[u8],\n\t\ttarget_size: Option<usize>\n\t) -> Result<(), ExitFatal> {\n\t\tif value.is_empty() {\n\t\t\treturn Ok(())\n\t\t}\n\t\t\n\t\tlet target_size = target_size.unwrap_or(value.len());\n\n\t\tif offset.checked_add(target_size)\n\t\t\t.map(|pos| pos > self.limit).unwrap_or(true)\n\t\t{\n\t\t\treturn Err(ExitFatal::NotSupported)\n\t\t}\n\n\t\tif self.data.len() < offset + target_size {\n\t\t\tself.data.resize(offset + target_size, 0);\n\t\t}\n\n\t\tfor index in 0..target_size {\n\t\t\tif self.data.len() > offset + index && value.len() > index {\n\t\t\t\tself.data[offset + index] = value[index];\n\t\t\t} else {\n\t\t\t\tself.data[offset + index] = 0;\n\t\t\t}\n\t\t}\n\n\t\tOk(())\n\t}\n\n\t/// Copy `data` into the memory, of given `len`.\n\tpub fn copy_large(\n\t\t&mut self,\n\t\tmemory_offset: U256,\n\t\tdata_offset: U256,\n\t\tlen: U256,\n\t\tdata: &[u8]\n\t) -> Result<(), ExitFatal> {\n\t\tlet memory_offset = if memory_offset > U256::from(usize::max_value()) {\n\t\t\treturn Err(ExitFatal::NotSupported)\n\t\t} else {\n\t\t\tmemory_offset.as_usize()\n\t\t};\n\n\t\tlet ulen = if len > U256::from(usize::max_value()) {\n\t\t\treturn Err(ExitFatal::NotSupported)\n\t\t} else {\n\t\t\tlen.as_usize()\n\t\t};\n\n\t\tlet data = if let Some(end) = data_offset.checked_add(len) {\n\t\t\tif end > U256::from(usize::max_value()) {\n\t\t\t\t&[]\n\t\t\t} else {\n\t\t\t\tlet data_offset = data_offset.as_usize();\n\t\t\t\tlet end = end.as_usize();\n\n\t\t\t\tif data_offset > data.len() {\n\t\t\t\t\t&[]\n\t\t\t\t} else {\n\t\t\t\t\t&data[data_offset..min(end, data.len())]\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t&[]\n\t\t};\n\n\t\tself.set(memory_offset, data, Some(ulen))\n\t}\n}\n"], "filenames": ["core/src/memory.rs"], "buggy_code_start_loc": [107], "buggy_code_end_loc": [107], "fixing_code_start_loc": [108], "fixing_code_end_loc": [112], "type": "CWE-787", "message": "evm is a pure Rust implementation of Ethereum Virtual Machine. Prior to the patch, when executing specific EVM opcodes related to memory operations that use `evm_core::Memory::copy_large`, the `evm` crate can over-allocate memory when it is not needed, making it possible for an attacker to perform denial-of-service attack. The flaw was corrected in commit `19ade85`. Users should upgrade to `==0.21.1, ==0.23.1, ==0.24.1, ==0.25.1, >=0.26.1`. There are no workarounds. Please upgrade your `evm` crate version.", "other": {"cve": {"id": "CVE-2021-29511", "sourceIdentifier": "security-advisories@github.com", "published": "2021-05-12T18:15:08.527", "lastModified": "2022-10-25T19:13:21.267", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "evm is a pure Rust implementation of Ethereum Virtual Machine. Prior to the patch, when executing specific EVM opcodes related to memory operations that use `evm_core::Memory::copy_large`, the `evm` crate can over-allocate memory when it is not needed, making it possible for an attacker to perform denial-of-service attack. The flaw was corrected in commit `19ade85`. Users should upgrade to `==0.21.1, ==0.23.1, ==0.24.1, ==0.25.1, >=0.26.1`. There are no workarounds. Please upgrade your `evm` crate version."}, {"lang": "es", "value": "evm es una implementaci\u00f3n pura de Rust de Ethereum Virtual Machine. Anterior al parche, cuando se ejecutan c\u00f3digos de operaci\u00f3n EVM espec\u00edficos relacionados con operaciones de memoria que usan la funci\u00f3n \"evm_core::Memory::copy_large\", la crate \"evm\" puede sobreasignar memoria cuando no es necesaria, haciendo posible a un atacante llevar a cabo un ataque de denegaci\u00f3n de servicio. El fallo fue corregido en el commit \"19ade85\". Los usuarios deber\u00edan actualizar a \"==0.21.1, ==0.23.1, ==0.24.1, ==0.25.1, )=0.26.1\". No existen soluciones alternativas. Por favor Actualice su versi\u00f3n de crate \"evm\""}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:evm_project:evm:*:*:*:*:*:rust:*:*", "versionEndIncluding": "0.21.0", "matchCriteriaId": "BC526576-249B-4C0E-AAF0-85614F8F42E1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:evm_project:evm:0.22.0:*:*:*:*:rust:*:*", "matchCriteriaId": "F18F86B1-8BED-4A6E-91A9-BB77819A3A6C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:evm_project:evm:0.23.0:*:*:*:*:rust:*:*", "matchCriteriaId": "07E8CA2D-3CF8-4069-9F3F-D9CB0E6FB182"}, {"vulnerable": true, "criteria": "cpe:2.3:a:evm_project:evm:0.24.0:*:*:*:*:rust:*:*", "matchCriteriaId": "E70A1FF9-F6EE-486B-9E91-A6548E624A02"}, {"vulnerable": true, "criteria": "cpe:2.3:a:evm_project:evm:0.25.0:*:*:*:*:rust:*:*", "matchCriteriaId": "4D49607D-993F-44D7-A144-68B4939B6B2D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:evm_project:evm:0.26.0:*:*:*:*:rust:*:*", "matchCriteriaId": "2C81A330-9BAF-4CC7-BA5C-69164C4A6189"}]}]}], "references": [{"url": "https://crates.io/crates/evm", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/rust-blockchain/evm/commit/19ade858c430ab13eb562764a870ac9f8506f8dd", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rust-blockchain/evm/security/advisories/GHSA-4jwq-572w-4388", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rust-blockchain/evm/commit/19ade858c430ab13eb562764a870ac9f8506f8dd"}}