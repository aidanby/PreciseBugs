{"buggy_code": ["/*\n * Copyright (c) 2016-2017  Moddable Tech, Inc.\n *\n *   This file is part of the Moddable SDK Runtime.\n * \n *   The Moddable SDK Runtime is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n * \n *   The Moddable SDK Runtime is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n * \n *   You should have received a copy of the GNU Lesser General Public License\n *   along with the Moddable SDK Runtime.  If not, see <http://www.gnu.org/licenses/>.\n *\n * This file incorporates work covered by the following copyright and  \n * permission notice:  \n *\n *       Copyright (C) 2010-2016 Marvell International Ltd.\n *       Copyright (C) 2002-2010 Kinoma, Inc.\n *\n *       Licensed under the Apache License, Version 2.0 (the \"License\");\n *       you may not use this file except in compliance with the License.\n *       You may obtain a copy of the License at\n *\n *        http://www.apache.org/licenses/LICENSE-2.0\n *\n *       Unless required by applicable law or agreed to in writing, software\n *       distributed under the License is distributed on an \"AS IS\" BASIS,\n *       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *       See the License for the specific language governing permissions and\n *       limitations under the License.\n */\n\n#include \"xsAll.h\"\n\nstatic txSlot* fxArgToInstance(txMachine* the, txInteger i);\nstatic txBoolean fxCheckLength(txMachine* the, txSlot* slot, txInteger* index);\n\nstatic txSlot* fxCheckArrayBufferDetached(txMachine* the, txSlot* slot, txBoolean mutable);\nstatic txSlot* fxCheckArrayBufferInstance(txMachine* the, txSlot* slot);\nstatic txSlot* fxNewArrayBufferInstance(txMachine* the);\n\nstatic txSlot* fxCheckDataViewInstance(txMachine* the, txSlot* slot);\nstatic txInteger fxCheckDataViewSize(txMachine* the, txSlot* view, txSlot* buffer, txBoolean mutable);\nstatic txSlot* fxNewDataViewInstance(txMachine* the);\n\nstatic void fxCallTypedArrayItem(txMachine* the, txSlot* function, txSlot* dispatch, txSlot* view, txSlot* data, txInteger index, txSlot* item);\nstatic txSlot* fxCheckTypedArrayInstance(txMachine* the, txSlot* slot);\nstatic int fxCompareTypedArrayItem(txMachine* the, txSlot* function, txSlot* dispatch, txSlot* view, txSlot* data, txInteger index);\nstatic txSlot* fxConstructTypedArray(txMachine* the);\nstatic txSlot* fxNewTypedArrayInstance(txMachine* the, txTypeDispatch* dispatch, txTypeAtomics* atomics);\nstatic void fxReduceTypedArrayItem(txMachine* the, txSlot* function, txSlot* dispatch, txSlot* view, txSlot* data, txInteger index);\n\nstatic txBoolean fxTypedArrayDefineOwnProperty(txMachine* the, txSlot* instance, txID id, txIndex index, txSlot* slot, txFlag mask);\nstatic txBoolean fxTypedArrayDeleteProperty(txMachine* the, txSlot* instance, txID id, txIndex index);\nstatic txBoolean fxTypedArrayGetOwnProperty(txMachine* the, txSlot* instance, txID id, txIndex index, txSlot* slot);\nstatic txSlot* fxTypedArrayGetProperty(txMachine* the, txSlot* instance, txID id, txIndex index, txFlag flag);\nstatic txBoolean fxTypedArrayGetPropertyValue(txMachine* the, txSlot* instance, txID id, txIndex index, txSlot* value, txSlot* receiver);\nstatic txBoolean fxTypedArrayHasProperty(txMachine* the, txSlot* instance, txID id, txIndex index);\nstatic void fxTypedArrayOwnKeys(txMachine* the, txSlot* instance, txFlag flag, txSlot* keys);\nstatic txSlot* fxTypedArraySetProperty(txMachine* the, txSlot* instance, txID id, txIndex index, txFlag flag);\nstatic txBoolean fxTypedArraySetPropertyValue(txMachine* the, txSlot* instance, txID id, txIndex index, txSlot* value, txSlot* receiver);\n\nstatic void fx_TypedArray_from_object(txMachine* the, txSlot* instance, txSlot* function, txSlot* _this);\n\nconst txBehavior ICACHE_FLASH_ATTR gxTypedArrayBehavior = {\n\tfxTypedArrayGetProperty,\n\tfxTypedArraySetProperty,\n\tfxOrdinaryCall,\n\tfxOrdinaryConstruct,\n\tfxTypedArrayDefineOwnProperty,\n\tfxTypedArrayDeleteProperty,\n\tfxTypedArrayGetOwnProperty,\n\tfxTypedArrayGetPropertyValue,\n\tfxOrdinaryGetPrototype,\n\tfxTypedArrayHasProperty,\n\tfxOrdinaryIsExtensible,\n\tfxTypedArrayOwnKeys,\n\tfxOrdinaryPreventExtensions,\n\tfxTypedArraySetPropertyValue,\n\tfxOrdinarySetPrototype,\n};\n\nvoid *fxArrayBuffer(txMachine* the, txSlot* slot, void* data, txInteger byteLength, txInteger maxByteLength)\n{\n\ttxSlot* instance;\n\ttxSlot* arrayBuffer;\n\ttxSlot* bufferInfo;\n\tif (byteLength < 0)\n\t\tmxRangeError(\"invalid byteLength %ld\", byteLength);\n\tmxPush(mxArrayBufferPrototype);\n\tinstance = fxNewArrayBufferInstance(the);\n\tarrayBuffer = instance->next;\n\tarrayBuffer->value.arrayBuffer.address = fxNewChunk(the, byteLength);\n\tbufferInfo = arrayBuffer->next;\n\tbufferInfo->value.bufferInfo.length = byteLength;\n\tbufferInfo->value.bufferInfo.maxLength = maxByteLength;\n\tif (data != NULL)\n\t\tc_memcpy(arrayBuffer->value.arrayBuffer.address, data, byteLength);\n\telse\n\t\tc_memset(arrayBuffer->value.arrayBuffer.address, 0, byteLength);\n\tmxPullSlot(slot);\n\treturn arrayBuffer->value.arrayBuffer.address;\n}\n\nvoid fxGetArrayBufferData(txMachine* the, txSlot* slot, txInteger byteOffset, void* data, txInteger byteLength)\n{\n\ttxSlot* instance = fxCheckArrayBufferInstance(the, slot);\n\ttxSlot* arrayBuffer = instance->next;\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\ttxInteger length = bufferInfo->value.bufferInfo.length;\n\tif ((byteOffset < 0) || (length < byteOffset))\n\t\tmxRangeError(\"out of range byteOffset %ld\", byteOffset);\n\tif ((byteLength < 0) || (length < (byteOffset + byteLength)))\n\t\tmxRangeError(\"out of range byteLength %ld\", byteLength);\n\tc_memcpy(data, arrayBuffer->value.arrayBuffer.address + byteOffset, byteLength);\n}\n\ntxInteger fxGetArrayBufferLength(txMachine* the, txSlot* slot)\n{\n\ttxSlot* instance = fxCheckArrayBufferInstance(the, slot);\n\ttxSlot* arrayBuffer = instance->next;\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\treturn bufferInfo->value.bufferInfo.length;\n}\n\ntxInteger fxGetArrayBufferMaxLength(txMachine* the, txSlot* slot)\n{\n\ttxSlot* instance = fxCheckArrayBufferInstance(the, slot);\n\ttxSlot* arrayBuffer = instance->next;\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\treturn bufferInfo->value.bufferInfo.maxLength;\n}\n\nvoid fxSetArrayBufferData(txMachine* the, txSlot* slot, txInteger byteOffset, void* data, txInteger byteLength)\n{\n\ttxSlot* instance = fxCheckArrayBufferInstance(the, slot);\n\ttxSlot* arrayBuffer = instance->next;\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\ttxInteger length = bufferInfo->value.bufferInfo.length;\n\tif ((byteOffset < 0) || (length < byteOffset))\n\t\tmxRangeError(\"out of range byteOffset %ld\", byteOffset);\n\tif ((byteLength < 0) || (length < (byteOffset + byteLength)))\n\t\tmxRangeError(\"out of range byteLength %ld\", byteLength);\n\tc_memcpy(arrayBuffer->value.arrayBuffer.address + byteOffset, data, byteLength);\n}\n\nvoid fxSetArrayBufferLength(txMachine* the, txSlot* slot, txInteger target)\n{\n\ttxSlot* instance = fxCheckArrayBufferInstance(the, slot);\n\ttxSlot* arrayBuffer = instance->next;\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\ttxInteger length = bufferInfo->value.bufferInfo.length;\n\ttxByte* address = arrayBuffer->value.arrayBuffer.address;\n\tif (bufferInfo->value.bufferInfo.maxLength < 0)\n\t\tfxReport(the, \"# Use xsArrayBufferResizable instead of xsArrayBuffer\\n\");\n\tif (length != target) {\n\t\tif (address)\n\t\t\taddress = (txByte*)fxRenewChunk(the, address, target);\n\t\tif (address) {\n\t\t\tif (length < target)\n\t\t\t\tc_memset(address + length, 0, target - length);\n\t\t}\n\t\telse {\n\t\t\taddress = (txByte*)fxNewChunk(the, target);\n\t\t\tif (length < target) {\n\t\t\t\tc_memcpy(address, arrayBuffer->value.arrayBuffer.address, length);\n\t\t\t\tc_memset(address + length, 0, target - length);\n\t\t\t}\n\t\t\telse\n\t\t\t\tc_memcpy(address, arrayBuffer->value.arrayBuffer.address, target);\n\t\t}\n\t\tarrayBuffer->value.arrayBuffer.address = address;\n\t\tbufferInfo->value.bufferInfo.length = target;\n\t}\n}\n\nvoid* fxToArrayBuffer(txMachine* the, txSlot* slot)\n{\n\ttxSlot* instance = fxCheckArrayBufferInstance(the, slot);\n\ttxSlot* arrayBuffer = instance->next;\n\treturn arrayBuffer->value.arrayBuffer.address;\n}\n\nvoid fxBuildDataView(txMachine* the)\n{\n    txSlot* slot;\n\ttxInteger index;\n\tconst txTypeDispatch *dispatch;\n\tconst txTypeAtomics *atomics;\n\ttxSlot* property;\n    txSlot* constructor;\n\t\n\tmxPush(mxObjectPrototype);\n\tslot = fxLastProperty(the, fxNewObjectInstance(the));\n\tslot = fxNextHostAccessorProperty(the, slot, mxCallback(fx_ArrayBuffer_prototype_get_byteLength), C_NULL, mxID(_byteLength), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostAccessorProperty(the, slot, mxCallback(fx_ArrayBuffer_prototype_get_maxByteLength), C_NULL, mxID(_maxByteLength), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostAccessorProperty(the, slot, mxCallback(fx_ArrayBuffer_prototype_get_resizable), C_NULL, mxID(_resizable), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_ArrayBuffer_prototype_concat), 1, mxID(_concat), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_ArrayBuffer_prototype_resize), 1, mxID(_resize), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_ArrayBuffer_prototype_slice), 2, mxID(_slice), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_ArrayBuffer_prototype_transfer), 0, mxID(_transfer), XS_DONT_ENUM_FLAG);\n\tslot = fxNextStringXProperty(the, slot, \"ArrayBuffer\", mxID(_Symbol_toStringTag), XS_DONT_ENUM_FLAG | XS_DONT_SET_FLAG);\n\tmxArrayBufferPrototype = *the->stack;\n\tslot = fxBuildHostConstructor(the, mxCallback(fx_ArrayBuffer), 1, mxID(_ArrayBuffer));\n\tmxArrayBufferConstructor = *the->stack;\n\tslot = fxLastProperty(the, slot);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_ArrayBuffer_fromBigInt), 1, mxID(_fromBigInt), XS_DONT_ENUM_FLAG);\n#ifndef mxCESU8\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_ArrayBuffer_fromString), 1, mxID(_fromString), XS_DONT_ENUM_FLAG);\n#endif\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_ArrayBuffer_isView), 1, mxID(_isView), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostAccessorProperty(the, slot, mxCallback(fx_species_get), C_NULL, mxID(_Symbol_species), XS_DONT_ENUM_FLAG);\n\tmxPop();\n\t\n\tmxPush(mxObjectPrototype);\n\tslot = fxLastProperty(the, fxNewObjectInstance(the));\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_getBigInt64), 1, mxID(_getBigInt64), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_setBigInt64), 2, mxID(_setBigInt64), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_getBigUint64), 1, mxID(_getBigUint64), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_setBigUint64), 2, mxID(_setBigUint64), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_getFloat32), 1, mxID(_getFloat32), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_setFloat32), 2, mxID(_setFloat32), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_getFloat64), 1, mxID(_getFloat64), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_setFloat64), 2, mxID(_setFloat64), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_getInt8), 1, mxID(_getInt8), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_setInt8), 2, mxID(_setInt8), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_getInt16), 1, mxID(_getInt16), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_setInt16), 2, mxID(_setInt16), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_getInt32), 1, mxID(_getInt32), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_setInt32), 2, mxID(_setInt32), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_getUint8), 1, mxID(_getUint8), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_setUint8), 2, mxID(_setUint8), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_getUint16), 1, mxID(_getUint16), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_setUint16), 2, mxID(_setUint16), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_getUint32), 1, mxID(_getUint32), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_setUint32), 2, mxID(_setUint32), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostAccessorProperty(the, slot, mxCallback(fx_DataView_prototype_buffer_get), C_NULL, mxID(_buffer), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostAccessorProperty(the, slot, mxCallback(fx_DataView_prototype_byteLength_get), C_NULL, mxID(_byteLength), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostAccessorProperty(the, slot, mxCallback(fx_DataView_prototype_byteOffset_get), C_NULL, mxID(_byteOffset), XS_DONT_ENUM_FLAG);\n\tslot = fxNextStringXProperty(the, slot, \"DataView\", mxID(_Symbol_toStringTag), XS_DONT_ENUM_FLAG | XS_DONT_SET_FLAG);\n\tmxDataViewPrototype = *the->stack;\n\tslot = fxBuildHostConstructor(the, mxCallback(fx_DataView), 1, mxID(_DataView));\n\tmxDataViewConstructor = *the->stack;\n\tmxPop();\n\t\n\tfxNewHostFunction(the, mxCallback(fxTypedArrayGetter), 0, XS_NO_ID);\n\tfxNewHostFunction(the, mxCallback(fxTypedArraySetter), 1, XS_NO_ID);\n\tmxPushUndefined();\n\tthe->stack->flag = XS_DONT_DELETE_FLAG;\n\tthe->stack->kind = XS_ACCESSOR_KIND;\n\tthe->stack->value.accessor.getter = (the->stack + 2)->value.reference;\n\tthe->stack->value.accessor.setter = (the->stack + 1)->value.reference;\n\tmxPull(mxTypedArrayAccessor);\n\tmxPop();\n\tmxPop();\n\tmxPush(mxObjectPrototype);\n\tslot = fxLastProperty(the, fxNewObjectInstance(the));\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_at), 1, mxID(_at), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostAccessorProperty(the, slot, mxCallback(fx_TypedArray_prototype_buffer_get), C_NULL, mxID(_buffer), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostAccessorProperty(the, slot, mxCallback(fx_TypedArray_prototype_byteLength_get), C_NULL, mxID(_byteLength), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostAccessorProperty(the, slot, mxCallback(fx_TypedArray_prototype_byteOffset_get), C_NULL, mxID(_byteOffset), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostAccessorProperty(the, slot, mxCallback(fx_TypedArray_prototype_length_get), C_NULL, mxID(_length), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostAccessorProperty(the, slot, mxCallback(fx_TypedArray_prototype_toStringTag_get), C_NULL, mxID(_Symbol_toStringTag), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_copyWithin), 2, mxID(_copyWithin), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_entries), 0, mxID(_entries), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_every), 1, mxID(_every), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_fill), 1, mxID(_fill), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_filter), 1, mxID(_filter), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_find), 1, mxID(_find), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_findIndex), 1, mxID(_findIndex), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_findLast), 1, mxID(_findLast), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_findLastIndex), 1, mxID(_findLastIndex), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_forEach), 1, mxID(_forEach), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_includes), 1, mxID(_includes), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_indexOf), 1, mxID(_indexOf), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_join), 1, mxID(_join), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_keys), 0, mxID(_keys), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_lastIndexOf), 1, mxID(_lastIndexOf), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_map), 1, mxID(_map), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_reduce), 1, mxID(_reduce), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_reduceRight), 1, mxID(_reduceRight), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_reverse), 0, mxID(_reverse), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_set), 1, mxID(_set), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_slice), 2, mxID(_slice), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_some), 1, mxID(_some), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_sort), 1, mxID(_sort), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_subarray), 2, mxID(_subarray), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_toLocaleString), 0, mxID(_toLocaleString), XS_DONT_ENUM_FLAG);\n\tproperty = mxBehaviorGetProperty(the, mxArrayPrototype.value.reference, mxID(_toString), 0, XS_OWN);\n\tslot = fxNextSlotProperty(the, slot, property, mxID(_toString), XS_DONT_ENUM_FLAG);\n\tproperty = slot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_values), 0, mxID(_values), XS_DONT_ENUM_FLAG);\n\tslot = fxNextSlotProperty(the, slot, property, mxID(_Symbol_iterator), XS_DONT_ENUM_FLAG);\n\tmxTypedArrayPrototype = *the->stack;\t\n\tconstructor = fxBuildHostConstructor(the, mxCallback(fx_TypedArray), 0, mxID(_TypedArray));\n\tmxTypedArrayConstructor = *the->stack;\n\tslot = fxLastProperty(the, constructor);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_from), 1, mxID(_from), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_of), 0, mxID(_of), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostAccessorProperty(the, slot, mxCallback(fx_species_get), C_NULL, mxID(_Symbol_species), XS_DONT_ENUM_FLAG);\n\tfor (index = 0, dispatch = &gxTypeDispatches[0], atomics = &gxTypeAtomics[0]; index < mxTypeArrayCount; index++, dispatch++, atomics++) {\n\t\tmxPush(mxTypedArrayPrototype);\n\t\tslot = fxLastProperty(the, fxNewObjectInstance(the));\n\t\tslot = fxNextIntegerProperty(the, slot, dispatch->size, mxID(_BYTES_PER_ELEMENT), XS_GET_ONLY);\n\t\tslot = fxBuildHostConstructor(the, mxCallback(fx_TypedArray), 3, mxID(dispatch->constructorID));\n\t\tthe->stackPrototypes[-1 - (txInteger)dispatch->constructorID] = *the->stack; //@@\n\t\tslot->value.instance.prototype = constructor;\n\t\tproperty = mxFunctionInstanceHome(slot);\n\t\tslot = property->next;\n\t\tproperty = fxNextTypeDispatchProperty(the, property, (txTypeDispatch*)dispatch, (txTypeAtomics*)atomics, XS_NO_ID, XS_INTERNAL_FLAG);\n\t\tproperty->next = slot;\n\t\tslot = fxLastProperty(the, slot);\n\t\tslot = fxNextIntegerProperty(the, slot, dispatch->size, mxID(_BYTES_PER_ELEMENT), XS_GET_ONLY);\n\t\tmxPop();\n\t}\n\tmxPop();\n}\n\ntxInteger fxArgToByteLength(txMachine* the, txInteger argi, txInteger length)\n{\n\ttxSlot *arg = mxArgv(argi);\n\tif ((mxArgc > argi) && (arg->kind != XS_UNDEFINED_KIND)) {\n\t\ttxNumber value;\n\t\tif (XS_INTEGER_KIND == arg->kind) {\n\t\t\ttxInteger value = arg->value.integer;\n\t\t\tif (value < 0)\n\t\t\t\tmxRangeError(\"out of range byteLength\");\n\t\t\treturn value;\n\t\t}\n\t\tvalue = c_trunc(fxToNumber(the, arg));\n\t\tif (c_isnan(value))\n\t\t\treturn 0;\n\t\tif ((value < 0) || (0x7FFFFFFF < value))\n\t\t\tmxRangeError(\"out of range byteLength\");\n\t\treturn (txInteger)value;\n\t}\n\treturn length;\n}\n\ntxSlot* fxArgToInstance(txMachine* the, txInteger i)\n{\n\tif (mxArgc > i)\n\t\treturn fxToInstance(the, mxArgv(i));\n\tmxTypeError(\"Cannot coerce undefined to object\");\n\treturn C_NULL;\n}\n\ntxBoolean fxCheckLength(txMachine* the, txSlot* slot, txInteger* index)\n{\n\ttxNumber number = fxToNumber(the, slot);\n\ttxNumber check = c_trunc(number);\n\tif ((number == check) && (0 <= number) && (number <= 0x7FFFFFFF)) {\n\t\t*index = (txInteger)number;\n\t\treturn 1 ;\n\t}\n\treturn 0;\n}\n\ntxSlot* fxCheckArrayBufferDetached(txMachine* the, txSlot* slot, txBoolean mutable)\n{\n\tslot = slot->value.reference->next;\n\tif (slot->value.arrayBuffer.address == C_NULL)\n\t\tmxTypeError(\"detached buffer\");\n\tif (mutable && (slot->flag & XS_DONT_SET_FLAG))\n\t\tmxTypeError(\"ArrayBuffer instance is read-only\");\n\treturn slot;\n}\n\ntxSlot* fxCheckArrayBufferInstance(txMachine* the, txSlot* slot)\n{\n\tif (slot->kind == XS_REFERENCE_KIND) {\n\t\ttxSlot* instance = slot->value.reference;\n\t\tif (((slot = instance->next)) && (slot->flag & XS_INTERNAL_FLAG) && (slot->kind == XS_ARRAY_BUFFER_KIND))\n\t\t\treturn instance;\n\t}\n\tmxTypeError(\"this is no ArrayBuffer instance\");\n\treturn C_NULL;\n}\n\nvoid fxConstructArrayBufferResult(txMachine* the, txSlot* constructor, txInteger length)\n{\n\ttxSlot* instance;\n\tif (constructor)\n\t\tmxPushSlot(constructor);\n\telse {\n\t\tmxPushSlot(mxThis);\n\t\tmxGetID(mxID(_constructor));\n\t}\n\tfxToSpeciesConstructor(the, &mxArrayBufferConstructor);\n\tmxNew();\n\tmxPushInteger(length);\n\tmxRunCount(1);\n\tif (the->stack->kind != XS_REFERENCE_KIND)\n\t\tmxTypeError(\"no instance\");\n\tinstance = the->stack->value.reference;\n\tif (!(instance->next) || (instance->next->kind != XS_ARRAY_BUFFER_KIND))\n\t\tmxTypeError(\"no ArrayBuffer instance\");\n\tif (!constructor && (mxThis->value.reference == instance))\n\t\tmxTypeError(\"same ArrayBuffer instance\");\n\tif (instance->next->next->value.bufferInfo.length < length)\n\t\tmxTypeError(\"smaller ArrayBuffer instance\");\n\tmxPullSlot(mxResult);\n}\n\ntxSlot* fxNewArrayBufferInstance(txMachine* the)\n{\n\ttxSlot* instance;\n\ttxSlot* property;\n\tinstance = fxNewObjectInstance(the);\n\tproperty = instance->next = fxNewSlot(the);\n\tproperty->flag = XS_INTERNAL_FLAG;\n\tproperty->kind = XS_ARRAY_BUFFER_KIND;\n\tproperty->value.arrayBuffer.address = C_NULL;\n\tproperty->value.arrayBuffer.detachKey = C_NULL;\n\tproperty = property->next = fxNewSlot(the);\n\tproperty->flag = XS_INTERNAL_FLAG;\n\tproperty->kind = XS_BUFFER_INFO_KIND;\n\tproperty->value.bufferInfo.length = 0;\n\tproperty->value.bufferInfo.maxLength = -1;\n\treturn instance;\n}\n\nvoid fx_ArrayBuffer(txMachine* the)\n{\n\ttxSlot* instance;\n\ttxInteger byteLength;\n\ttxInteger maxByteLength = -1;\n\ttxSlot* property;\n\tif (mxIsUndefined(mxTarget))\n\t\tmxTypeError(\"call: ArrayBuffer\");\n\tmxPushSlot(mxTarget);\n\tfxGetPrototypeFromConstructor(the, &mxArrayBufferPrototype);\n\tinstance = fxNewArrayBufferInstance(the);\n\tmxPullSlot(mxResult);\n\tbyteLength = fxArgToByteLength(the, 0, 0);\n\tif ((mxArgc > 1) && mxIsReference(mxArgv(1))) {\n\t\tmxPushSlot(mxArgv(1));\n\t\tmxGetID(mxID(_maxByteLength));\n\t\tmxPullSlot(mxArgv(1));\n\t\tmaxByteLength = fxArgToByteLength(the, 1, -1);\n\t}\n\tif (maxByteLength >= 0) {\n\t\tif (byteLength > maxByteLength)\n\t\t\tmxRangeError(\"byteLength > maxByteLength\");\n\t}\n\tproperty = instance->next;\n\tproperty->value.arrayBuffer.address = fxNewChunk(the, byteLength);\n\tc_memset(property->value.arrayBuffer.address, 0, byteLength);\n\tproperty = property->next;\n\tproperty->value.bufferInfo.length = byteLength;\n\tproperty->value.bufferInfo.maxLength = maxByteLength;\n}\n\nvoid fx_ArrayBuffer_fromBigInt(txMachine* the)\n{\n\ttxU4 minBytes = 0;\n\ttxBoolean sign = 0;\n\tint endian = EndianBig;\n\tif (mxArgc < 1)\n\t\tmxTypeError(\"no argument\");\n\tif (mxArgc > 1) {\n\t\ttxInteger m = fxToInteger(the, mxArgv(1));\n\t\tif (m < 0)\n\t\t\tmxRangeError(\"minBytes < 0\");\n\t\tminBytes = (txU4)m;\n\t}\n\tif ((mxArgc > 2) && fxToBoolean(the, mxArgv(2)))\n\t\tsign = 1;\n\tif ((mxArgc > 3) && fxToBoolean(the, mxArgv(3)))\n\t\tendian = EndianLittle;\n\tif (gxTypeBigInt.toArrayBuffer) {\n\t\tgxTypeBigInt.toArrayBuffer(the, mxArgv(0), minBytes, sign, endian);\n\t}\n\telse {\n\t\tmxUnknownError(\"not built-in\");\n\t}\n}\n\n#ifndef mxCESU8\nvoid fx_ArrayBuffer_fromString(txMachine* the)\n{\n\ttxSize length;\n\tif (mxArgc < 1)\n\t\tmxTypeError(\"no argument\");\n\tlength = mxStringLength(fxToString(the, mxArgv(0)));\n\tfxConstructArrayBufferResult(the, mxThis, length);\n\tc_memcpy(mxResult->value.reference->next->value.arrayBuffer.address, mxArgv(0)->value.string, length);\n}\n#endif\n\nvoid fx_ArrayBuffer_isView(txMachine* the)\n{\n\ttxSlot* slot;\n\tmxResult->kind = XS_BOOLEAN_KIND;\n\tmxResult->value.boolean = 0;\n\tif (mxArgc > 0) {\n\t\tslot = mxArgv(0);\n\t\tif (slot->kind == XS_REFERENCE_KIND) {\n\t\t\tslot = slot->value.reference;\n\t\t\tif (slot->next) {\n\t\t\t\tslot = slot->next;\n\t\t\t\tif ((slot->kind == XS_DATA_VIEW_KIND) || (slot->kind == XS_TYPED_ARRAY_KIND)) {\n\t\t\t\t\tmxResult->value.boolean = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid fx_ArrayBuffer_prototype_get_byteLength(txMachine* the)\n{\n\ttxSlot* instance = fxCheckArrayBufferInstance(the, mxThis);\n\ttxSlot* arrayBuffer = instance->next;\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\tmxResult->kind = XS_INTEGER_KIND;\n\tif (arrayBuffer->value.arrayBuffer.address == C_NULL)\n\t\tmxResult->value.integer = 0;\n\telse\n\t\tmxResult->value.integer = bufferInfo->value.bufferInfo.length;\n}\n\nvoid fx_ArrayBuffer_prototype_get_maxByteLength(txMachine* the)\n{\n\ttxSlot* instance = fxCheckArrayBufferInstance(the, mxThis);\n\ttxSlot* arrayBuffer = instance->next;\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\tmxResult->kind = XS_INTEGER_KIND;\n\tif (arrayBuffer->value.arrayBuffer.address == C_NULL)\n\t\tmxResult->value.integer = 0;\n\telse if (bufferInfo->value.bufferInfo.maxLength >= 0)\n\t\tmxResult->value.integer = bufferInfo->value.bufferInfo.maxLength;\n\telse\n\t\tmxResult->value.integer = bufferInfo->value.bufferInfo.length;\n}\n\nvoid fx_ArrayBuffer_prototype_get_resizable(txMachine* the)\n{\n\ttxSlot* instance = fxCheckArrayBufferInstance(the, mxThis);\n\ttxSlot* arrayBuffer = instance->next;\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\tmxResult->kind = XS_BOOLEAN_KIND;\n\tmxResult->value.boolean = (bufferInfo->value.bufferInfo.maxLength >= 0) ? 1 : 0;\n}\n\nvoid fx_ArrayBuffer_prototype_concat(txMachine* the)\n{\n\ttxSlot* instance = fxCheckArrayBufferInstance(the, mxThis);\n\ttxSlot* arrayBuffer = instance->next;\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\ttxInteger length = bufferInfo->value.bufferInfo.length;\n\ttxInteger c = mxArgc, i = 0;\n\ttxByte* address;\n\ttxSlot* slot;\n\twhile (i < c) {\n\t\tarrayBuffer = C_NULL;\n\t\tbufferInfo = C_NULL;\n\t\tslot = mxArgv(i);\n\t\tif (slot->kind == XS_REFERENCE_KIND) {\n\t\t\tslot = slot->value.reference->next;\n\t\t\tif (slot && (slot->kind == XS_ARRAY_BUFFER_KIND)) {\n\t\t\t\tarrayBuffer = slot;\n\t\t\t\tbufferInfo = slot->next;\n\t\t\t}\n\t\t}\n\t\tif (arrayBuffer) \n\t\t\tlength = fxAddChunkSizes(the, length, bufferInfo->value.bufferInfo.length);\n\t\telse\n\t\t\tmxTypeError(\"arguments[%ld] is no ArrayBuffer instance\", i);\n\t\ti++;\n\t}\n\tfxConstructArrayBufferResult(the, C_NULL, length);\n\tarrayBuffer = instance->next;\n\tbufferInfo = arrayBuffer->next;\n\taddress = mxResult->value.reference->next->value.arrayBuffer.address;\n\tlength = bufferInfo->value.bufferInfo.length;\n\tc_memcpy(address, arrayBuffer->value.arrayBuffer.address, length);\n\taddress += length;\n\ti = 0;\n\twhile (i < c) {\n\t\tarrayBuffer = mxArgv(i)->value.reference->next;\n\t\tbufferInfo = arrayBuffer->next;\n\t\tlength = bufferInfo->value.bufferInfo.length;\n\t\tc_memcpy(address, arrayBuffer->value.arrayBuffer.address, length);\n\t\taddress += length;\n\t\ti++;\n\t}\n}\n\nvoid fx_ArrayBuffer_prototype_resize(txMachine* the)\n{\n\t/* txSlot* instance = */ fxCheckArrayBufferInstance(the, mxThis);\n\ttxSlot* arrayBuffer = fxCheckArrayBufferDetached(the, mxThis, XS_MUTABLE);\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\ttxInteger maxByteLength, oldByteLength, newByteLength;\n\ttxByte* chunk;\n\tmaxByteLength = bufferInfo->value.bufferInfo.maxLength;\n\tif (maxByteLength < 0)\n\t\tmxTypeError(\"not resizable\");\n\toldByteLength = bufferInfo->value.bufferInfo.length;\n\tnewByteLength = fxArgToByteLength(the, 0, 0);\n\tif (newByteLength > maxByteLength)\n\t\tmxRangeError(\"newLength > maxByteLength\");\n\tchunk = (txByte*)fxRenewChunk(the, arrayBuffer->value.arrayBuffer.address, newByteLength);\n\tif (!chunk) {\n\t\tchunk = (txByte*)fxNewChunk(the, newByteLength);\n\t\tc_memcpy(chunk, arrayBuffer->value.arrayBuffer.address, (newByteLength < oldByteLength) ? newByteLength : oldByteLength);\n\t}\n\tif (newByteLength > oldByteLength)\n\t\tc_memset(chunk + oldByteLength, 0, newByteLength - oldByteLength);\n\tarrayBuffer->value.arrayBuffer.address = chunk;\n\tbufferInfo->value.bufferInfo.length = newByteLength;\n}\n\nvoid fx_ArrayBuffer_prototype_slice(txMachine* the)\n{\n\t/* txSlot* instance = */ fxCheckArrayBufferInstance(the, mxThis);\n\ttxSlot* arrayBuffer = fxCheckArrayBufferDetached(the, mxThis, XS_IMMUTABLE);\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\ttxInteger length = bufferInfo->value.bufferInfo.length;\n\ttxInteger start = (txInteger)fxArgToIndex(the, 0, 0, length);\n\ttxInteger stop = (txInteger)fxArgToIndex(the, 1, length, length);\n\ttxSlot* resultBuffer;\n\tif (stop < start) \n\t\tstop = start;\n\tfxConstructArrayBufferResult(the, C_NULL, stop - start);\n\tresultBuffer = fxCheckArrayBufferDetached(the, mxResult, XS_MUTABLE);\n\tc_memcpy(resultBuffer->value.arrayBuffer.address, arrayBuffer->value.arrayBuffer.address + start, stop - start);\n}\n\nvoid fx_ArrayBuffer_prototype_transfer(txMachine* the)\n{\n\t/* txSlot* instance = */ fxCheckArrayBufferInstance(the, mxThis);\n\ttxSlot* arrayBuffer = fxCheckArrayBufferDetached(the, mxThis, XS_MUTABLE);\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\ttxInteger oldByteLength = bufferInfo->value.bufferInfo.length;\n\ttxInteger newByteLength = fxArgToByteLength(the, 0, oldByteLength);\n\ttxSlot* resultBuffer;\n\tfxConstructArrayBufferResult(the, C_NULL, newByteLength);\n\tresultBuffer = fxCheckArrayBufferDetached(the, mxResult, XS_MUTABLE);\n\tc_memcpy(resultBuffer->value.arrayBuffer.address, arrayBuffer->value.arrayBuffer.address, (newByteLength < oldByteLength) ? newByteLength : oldByteLength);\n\tif (newByteLength > oldByteLength)\n\t\tc_memset(resultBuffer->value.arrayBuffer.address + oldByteLength, 0, newByteLength - oldByteLength);\n\tarrayBuffer->value.arrayBuffer.address = C_NULL;\n\tbufferInfo->value.bufferInfo.length = 0;\n}\n\ntxSlot* fxCheckDataViewInstance(txMachine* the, txSlot* slot)\n{\n\tif (slot->kind == XS_REFERENCE_KIND) {\n\t\ttxSlot* instance = slot->value.reference;\n\t\tif (((slot = instance->next)) && (slot->flag & XS_INTERNAL_FLAG) && (slot->kind == XS_DATA_VIEW_KIND))\n\t\t\treturn instance;\n\t}\n\tmxTypeError(\"this is no DataView instance\");\n\treturn C_NULL;\n}\n\ntxInteger fxCheckDataViewSize(txMachine* the, txSlot* view, txSlot* buffer, txBoolean mutable)\n{\n\ttxInteger size = view->value.dataView.size;\n\ttxSlot* arrayBuffer = buffer->value.reference->next;\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\tif (arrayBuffer->value.arrayBuffer.address == C_NULL)\n\t\tmxTypeError(\"detached buffer\");\n\tif (mutable && (arrayBuffer->flag & XS_DONT_SET_FLAG))\n\t\tmxTypeError(\"read-only buffer\");\n\tif (bufferInfo->value.bufferInfo.maxLength >= 0) {\n\t\ttxInteger offset = view->value.dataView.offset;\n\t\ttxInteger byteLength = bufferInfo->value.bufferInfo.length;\n\t\tif (offset > byteLength)\n\t\t\tmxTypeError(\"out of bounds view\");\n\t\telse if (size < 0)\n\t\t\tsize = byteLength - offset;\n\t\telse if (offset + size > byteLength)\n\t\t\tmxTypeError(\"out of bounds view\");\n\t}\n\treturn size;\n}\n\ntxSlot* fxGetBufferInfo(txMachine* the, txSlot* buffer)\n{\n\ttxSlot* arrayBuffer = buffer->value.reference->next;\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\tif (arrayBuffer->kind == XS_ARRAY_BUFFER_KIND) {\n\t\tif (arrayBuffer->value.arrayBuffer.address == C_NULL)\n\t\t\tmxTypeError(\"detached buffer\");\n\t\treturn bufferInfo;\n\t}\n\tif (arrayBuffer->kind == XS_HOST_KIND) {\n\t\ttxInteger byteLength;\n\t\tif (bufferInfo && (bufferInfo->kind == XS_BUFFER_INFO_KIND))\n\t\t\treturn bufferInfo;\n\t\tmxPushSlot(buffer);\n\t\tmxGetID(mxID(_byteLength));\n\t\tif (!fxCheckLength(the, the->stack, &byteLength))\n\t\t\tmxTypeError(\"invalid byteLength\");\n\t\tfxReport(the, \"# Use xsSetHostBuffer instead of xsSetHostData\\n\");\n\t\tmxPop();\n\t\tbufferInfo = fxNewSlot(the);\n\t\tbufferInfo->next = arrayBuffer->next;\n\t\tbufferInfo->flag = XS_INTERNAL_FLAG;\n\t\tbufferInfo->kind = XS_BUFFER_INFO_KIND;\n\t\tbufferInfo->value.bufferInfo.length = byteLength;\n\t\tbufferInfo->value.bufferInfo.maxLength = -1;\n\t\tarrayBuffer->next = bufferInfo;\n\t\treturn bufferInfo;\n\t}\n\tmxTypeError(\"invalid buffer\");\n\treturn C_NULL;\n}\n\ntxInteger fxGetDataViewSize(txMachine* the, txSlot* view, txSlot* buffer)\n{\n\ttxInteger size = view->value.dataView.size;\n\ttxSlot* arrayBuffer = buffer->value.reference->next;\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\tif (arrayBuffer->value.arrayBuffer.address == C_NULL)\n\t\treturn 0;\n\tif (bufferInfo->value.bufferInfo.maxLength >= 0) {\n\t\ttxInteger offset = view->value.dataView.offset;\n\t\ttxInteger byteLength = bufferInfo->value.bufferInfo.length;\n\t\tif (offset > byteLength)\n\t\t\tsize = 0;\n\t\telse if (size < 0)\n\t\t\tsize = byteLength - offset;\n\t\telse if (offset + size > byteLength)\n\t\t\tsize = 0;\n\t}\n\treturn size;\n}\n\ntxSlot* fxNewDataViewInstance(txMachine* the)\n{\n\ttxSlot* instance;\n\ttxSlot* property;\n\tinstance = fxNewObjectInstance(the);\n\tproperty = instance->next = fxNewSlot(the);\n\tproperty->flag = XS_INTERNAL_FLAG;\n\tproperty->kind = XS_DATA_VIEW_KIND;\n\tproperty->value.dataView.offset = 0;\n\tproperty->value.dataView.size = 0;\n\tproperty = fxNextNullProperty(the, property, XS_NO_ID, XS_INTERNAL_FLAG);\n\treturn instance;\n}\n\nvoid fx_DataView(txMachine* the)\n{\n\ttxSlot* slot;\n\ttxBoolean flag = 0;\n\ttxInteger offset, size;\n\ttxSlot* info;\n\ttxSlot* instance;\n\ttxSlot* view;\n\ttxSlot* buffer;\n\tif (mxIsUndefined(mxTarget))\n\t\tmxTypeError(\"call: DataView\");\n\tif ((mxArgc > 0) && (mxArgv(0)->kind == XS_REFERENCE_KIND)) {\n\t\tslot = mxArgv(0)->value.reference->next;\n\t\tif (slot && ((slot->kind == XS_ARRAY_BUFFER_KIND) || (slot->kind == XS_HOST_KIND))) {\n\t\t\tflag = 1;\n\t\t}\n\t}\n\tif (!flag)\n\t\tmxTypeError(\"buffer is no ArrayBuffer instance\");\n\t\t\n\toffset = fxArgToByteLength(the, 1, 0);\n\tinfo = fxGetBufferInfo(the, mxArgv(0));\n\tif (info->value.bufferInfo.length < offset)\n\t\tmxRangeError(\"out of range byteOffset %ld\", offset);\n\tsize = fxArgToByteLength(the, 2, -1);\n\tif (size >= 0) {\n\t\tif (info->value.bufferInfo.length < (offset + size))\n\t\t\tmxRangeError(\"out of range byteLength %ld\", size);\n\t}\n\telse {\n\t\tif (info->value.bufferInfo.maxLength < 0)\n\t\t\tsize = info->value.bufferInfo.length - offset;\n\t}\n\tmxPushSlot(mxTarget);\n\tfxGetPrototypeFromConstructor(the, &mxDataViewPrototype);\n\tinstance = fxNewDataViewInstance(the);\n\tmxPullSlot(mxResult);\n\tview = instance->next;\n\tbuffer = view->next;\n\tbuffer->kind = XS_REFERENCE_KIND;\n\tbuffer->value.reference = mxArgv(0)->value.reference;\n\tinfo = fxGetBufferInfo(the, buffer);\n\tif (info->value.bufferInfo.maxLength >= 0) {\n\t\tif (info->value.bufferInfo.length < offset)\n\t\t\tmxRangeError(\"out of range byteOffset %ld\", offset);\n\t\telse if (size >= 0) {\n\t\t\tif (info->value.bufferInfo.length < (offset + size))\n\t\t\t\tmxRangeError(\"out of range byteLength %ld\", size);\n\t\t}\n\t}\n\tview->value.dataView.offset = offset;\n\tview->value.dataView.size = size;\n}\n\nvoid fx_DataView_prototype_buffer_get(txMachine* the)\n{\n\ttxSlot* instance = fxCheckDataViewInstance(the, mxThis);\n\ttxSlot* view = instance->next;\n\ttxSlot* buffer = view->next;\n\tmxResult->kind = buffer->kind;\n\tmxResult->value = buffer->value;\n}\n\nvoid fx_DataView_prototype_byteLength_get(txMachine* the)\n{\n\ttxSlot* instance = fxCheckDataViewInstance(the, mxThis);\n\ttxSlot* view = instance->next;\n\ttxSlot* buffer = view->next;\n\ttxInteger size = fxCheckDataViewSize(the, view, buffer, XS_IMMUTABLE);\n\tmxResult->kind = XS_INTEGER_KIND;\n\tmxResult->value.integer = size;\n}\n\nvoid fx_DataView_prototype_byteOffset_get(txMachine* the)\n{\n\ttxSlot* instance = fxCheckDataViewInstance(the, mxThis);\n\ttxSlot* view = instance->next;\n\ttxSlot* buffer = view->next;\n\tfxCheckDataViewSize(the, view, buffer, XS_IMMUTABLE);\n\tmxResult->kind = XS_INTEGER_KIND;\n\tmxResult->value.integer = view->value.dataView.offset;\n}\n\nvoid fx_DataView_prototype_get(txMachine* the, txNumber delta, txTypeCallback getter)\n{\n\ttxSlot* instance = fxCheckDataViewInstance(the, mxThis);\n\ttxSlot* view = instance->next;\n\ttxSlot* buffer = view->next;\n\ttxInteger offset = fxArgToByteLength(the, 0, 0);\n\ttxInteger size;\n\tint endian = EndianBig;\n\tif ((mxArgc > 1) && fxToBoolean(the, mxArgv(1)))\n\t\tendian = EndianLittle;\n\tsize = fxCheckDataViewSize(the, view, buffer, XS_IMMUTABLE);\n\tif ((size < delta) || ((size - delta) < offset))\n\t\tmxRangeError(\"out of range byteOffset\");\n\toffset += view->value.dataView.offset;\n\t(*getter)(the, buffer->value.reference->next, offset, mxResult, endian);\n}\n\nvoid fx_DataView_prototype_getBigInt64(txMachine* the)\n{\n\tfx_DataView_prototype_get(the, 8, fxBigInt64Getter);\n}\n\nvoid fx_DataView_prototype_getBigUint64(txMachine* the)\n{\n\tfx_DataView_prototype_get(the, 8, fxBigUint64Getter);\n}\n\nvoid fx_DataView_prototype_getFloat32(txMachine* the)\n{\n\tfx_DataView_prototype_get(the, 4, fxFloat32Getter);\n}\n\nvoid fx_DataView_prototype_getFloat64(txMachine* the)\n{\n\tfx_DataView_prototype_get(the, 8, fxFloat64Getter);\n}\n\nvoid fx_DataView_prototype_getInt8(txMachine* the)\n{\n\tfx_DataView_prototype_get(the, 1, fxInt8Getter);\n}\n\nvoid fx_DataView_prototype_getInt16(txMachine* the)\n{\n\tfx_DataView_prototype_get(the, 2, fxInt16Getter);\n}\n\nvoid fx_DataView_prototype_getInt32(txMachine* the)\n{\n\tfx_DataView_prototype_get(the, 4, fxInt32Getter);\n}\n\nvoid fx_DataView_prototype_getUint8(txMachine* the)\n{\n\tfx_DataView_prototype_get(the, 1, fxUint8Getter);\n}\n\nvoid fx_DataView_prototype_getUint16(txMachine* the)\n{\n\tfx_DataView_prototype_get(the, 2, fxUint16Getter);\n}\n\nvoid fx_DataView_prototype_getUint32(txMachine* the)\n{\n\tfx_DataView_prototype_get(the, 4, fxUint32Getter);\n}\n\nvoid fx_DataView_prototype_set(txMachine* the, txNumber delta, txTypeCoerce coercer, txTypeCallback setter)\n{\n\ttxSlot* instance = fxCheckDataViewInstance(the, mxThis);\n\ttxSlot* view = instance->next;\n\ttxSlot* buffer = view->next;\n\ttxInteger offset = fxArgToByteLength(the, 0, 0);\n\ttxInteger size;\n\tint endian = EndianBig;\n\ttxSlot* value;\n\tif (mxArgc > 1)\n\t\tmxPushSlot(mxArgv(1));\n\telse\n\t\tmxPushUndefined();\n\tvalue = the->stack;\t\n\t(*coercer)(the, value);\n\tif ((mxArgc > 2) && fxToBoolean(the, mxArgv(2)))\n\t\tendian = EndianLittle;\n\tsize = fxCheckDataViewSize(the, view, buffer, XS_MUTABLE);\n\tif ((size < delta) || ((size - delta) < offset))\n\t\tmxRangeError(\"out of range byteOffset\");\n\toffset += view->value.dataView.offset;\n\t(*setter)(the, buffer->value.reference->next, offset, value, endian);\n\tmxPop();\n}\n\nvoid fx_DataView_prototype_setBigInt64(txMachine* the)\n{\n\tfx_DataView_prototype_set(the, 8, fxBigIntCoerce, fxBigInt64Setter);\n}\n\nvoid fx_DataView_prototype_setBigUint64(txMachine* the)\n{\n\tfx_DataView_prototype_set(the, 8, fxBigIntCoerce, fxBigUint64Setter);\n}\n\nvoid fx_DataView_prototype_setFloat32(txMachine* the)\n{\n\tfx_DataView_prototype_set(the, 4, fxNumberCoerce, fxFloat32Setter);\n}\n\nvoid fx_DataView_prototype_setFloat64(txMachine* the)\n{\n\tfx_DataView_prototype_set(the, 8, fxNumberCoerce, fxFloat64Setter);\n}\n\nvoid fx_DataView_prototype_setInt8(txMachine* the)\n{\n\tfx_DataView_prototype_set(the, 1, fxIntCoerce, fxInt8Setter);\n}\n\nvoid fx_DataView_prototype_setInt16(txMachine* the)\n{\n\tfx_DataView_prototype_set(the, 2, fxIntCoerce, fxInt16Setter);\n}\n\nvoid fx_DataView_prototype_setInt32(txMachine* the)\n{\n\tfx_DataView_prototype_set(the, 4, fxIntCoerce, fxInt32Setter);\n}\n\nvoid fx_DataView_prototype_setUint8(txMachine* the)\n{\n\tfx_DataView_prototype_set(the, 1, fxUintCoerce, fxUint8Setter);\n}\n\nvoid fx_DataView_prototype_setUint16(txMachine* the)\n{\n\tfx_DataView_prototype_set(the, 2, fxUintCoerce, fxUint16Setter);\n}\n\nvoid fx_DataView_prototype_setUint32(txMachine* the)\n{\n\tfx_DataView_prototype_set(the, 4, fxUintCoerce, fxUint32Setter);\n}\n\n\n#define mxTypedArrayDeclarations \\\n\ttxSlot* instance = fxCheckTypedArrayInstance(the, mxThis); \\\n\ttxSlot* dispatch = instance->next; \\\n\ttxSlot* view = dispatch->next; \\\n\ttxSlot* buffer = view->next; \\\n\ttxInteger length = fxCheckDataViewSize(the, view, buffer, XS_IMMUTABLE) >> dispatch->value.typedArray.dispatch->shift\n\n#define mxMutableTypedArrayDeclarations \\\n\ttxSlot* instance = fxCheckTypedArrayInstance(the, mxThis); \\\n\ttxSlot* dispatch = instance->next; \\\n\ttxSlot* view = dispatch->next; \\\n\ttxSlot* buffer = view->next; \\\n\ttxInteger length = fxCheckDataViewSize(the, view, buffer, XS_MUTABLE) >> dispatch->value.typedArray.dispatch->shift\n\n#define mxResultTypedArrayDeclarations \\\n\ttxSlot* resultInstance = fxCheckTypedArrayInstance(the, mxResult); \\\n\ttxSlot* resultDispatch = resultInstance->next; \\\n\ttxSlot* resultView = resultDispatch->next; \\\n\ttxSlot* resultBuffer = resultView->next; \\\n\ttxInteger resultLength = fxCheckDataViewSize(the, resultView, resultBuffer, XS_MUTABLE) >> resultDispatch->value.typedArray.dispatch->shift\n\nvoid fxTypedArrayGetter(txMachine* the)\n{\n\ttxSlot* instance = fxToInstance(the, mxThis);\n\ttxSlot* dispatch;\n\twhile (instance) {\n\t\tif (instance->flag & XS_EXOTIC_FLAG) {\n\t\t\tdispatch = instance->next;\n\t\t\tif (dispatch->ID == XS_TYPED_ARRAY_BEHAVIOR)\n\t\t\t\tbreak;\n\t\t}\n\t\tinstance = fxGetPrototype(the, instance);\n\t}\n\tif (instance) {\n\t\ttxID id = the->scratch.value.at.id;\n\t\ttxIndex index = the->scratch.value.at.index;\n\t\ttxSlot* view = dispatch->next;\n\t\ttxSlot* buffer = view->next;\n\t\ttxU2 shift = dispatch->value.typedArray.dispatch->shift;\n\t\ttxIndex length = fxGetDataViewSize(the, view, buffer) >> shift;\n\t\tif ((!id) && (index < length)) {\n\t\t\t(*dispatch->value.typedArray.dispatch->getter)(the, buffer->value.reference->next, view->value.dataView.offset + (index << shift), mxResult, EndianNative);\n\t\t}\n\t}\n}\n\nvoid fxTypedArraySetter(txMachine* the)\n{\n\ttxSlot* instance = fxToInstance(the, mxThis);\n\ttxSlot* dispatch;\n\twhile (instance) {\n\t\tif (instance->flag & XS_EXOTIC_FLAG) {\n\t\t\tdispatch = instance->next;\n\t\t\tif (dispatch->ID == XS_TYPED_ARRAY_BEHAVIOR)\n\t\t\t\tbreak;\n\t\t}\n\t\tinstance = fxGetPrototype(the, instance);\n\t}\n\tif (instance) {\n\t\ttxSlot* slot = mxArgv(0);\n\t\ttxID id = the->scratch.value.at.id;\n\t\ttxIndex index = the->scratch.value.at.index;\n\t\ttxSlot* view = dispatch->next;\n\t\ttxSlot* buffer = view->next;\n\t\ttxU2 shift = dispatch->value.typedArray.dispatch->shift;\n\t\ttxSlot* arrayBuffer = buffer->value.reference->next;\n\t\ttxIndex length;\n\t\tdispatch->value.typedArray.dispatch->coerce(the, slot);\n\t\tif (arrayBuffer->flag & XS_DONT_SET_FLAG)\n\t\t\tmxTypeError(\"read-only buffer\");\n\t\tlength = fxGetDataViewSize(the, view, buffer) >> shift;\n\t\tif ((!id) && (index < length)) {\n\t\t\t(*dispatch->value.typedArray.dispatch->setter)(the, arrayBuffer, view->value.dataView.offset + (index << shift), slot, EndianNative);\n\t\t}\n\t}\n}\n\ntxBoolean fxTypedArrayDefineOwnProperty(txMachine* the, txSlot* instance, txID id, txIndex index, txSlot* slot, txFlag mask) \n{\n\tif ((!id) || fxIsCanonicalIndex(the, id)) {\n\t\ttxSlot* dispatch = instance->next;\n\t\ttxSlot* view = dispatch->next;\n\t\ttxSlot* buffer = view->next;\n\t\ttxU2 shift = dispatch->value.typedArray.dispatch->shift;\n\t\ttxSlot* arrayBuffer = buffer->value.reference->next;\n\t\ttxIndex length = fxGetDataViewSize(the, view, buffer) >> shift;\n\t\tif (id || (index >= length))\n\t\t\treturn 0;\n\t\tif ((mask & XS_DONT_DELETE_FLAG) && (slot->flag & XS_DONT_DELETE_FLAG))\n\t\t\treturn 0;\n\t\tif ((mask & XS_DONT_ENUM_FLAG) && (slot->flag & XS_DONT_ENUM_FLAG))\n\t\t\treturn 0;\n\t\tif (mask & XS_ACCESSOR_FLAG)\n\t\t\treturn 0;\n\t\tif ((mask & XS_DONT_SET_FLAG) && (slot->flag & XS_DONT_SET_FLAG))\n\t\t\treturn 0;\n\t\tif (slot->kind != XS_UNINITIALIZED_KIND) {\n\t\t\tdispatch->value.typedArray.dispatch->coerce(the, slot);\n\t\t\tif (arrayBuffer->flag & XS_DONT_SET_FLAG)\n\t\t\t\tmxTypeError(\"read-only buffer\");\n\t\t\tlength = fxGetDataViewSize(the, view, buffer) >> shift;\n\t\t\tif (index < length)\n\t\t\t\t(*dispatch->value.typedArray.dispatch->setter)(the, arrayBuffer, view->value.dataView.offset + (index << shift), slot, EndianNative);\n\t\t}\n\t\treturn 1;\n\t}\n\treturn fxOrdinaryDefineOwnProperty(the, instance, id, index, slot, mask);\n}\n\ntxBoolean fxTypedArrayDeleteProperty(txMachine* the, txSlot* instance, txID id, txIndex index)\n{\n\tif ((!id) || fxIsCanonicalIndex(the, id)) {\n\t\ttxSlot* dispatch = instance->next;\n\t\ttxSlot* view = dispatch->next;\n\t\ttxSlot* buffer = view->next;\n\t\ttxU2 shift = dispatch->value.typedArray.dispatch->shift;\n\t\ttxIndex length = fxGetDataViewSize(the, view, buffer) >> shift;\n\t\treturn ((!id) && (index < length)) ? 0 : 1;\n\t}\n\treturn fxOrdinaryDeleteProperty(the, instance, id, index);\n}\n\ntxBoolean fxTypedArrayGetOwnProperty(txMachine* the, txSlot* instance, txID id, txIndex index, txSlot* slot)\n{\n\tif ((!id) || fxIsCanonicalIndex(the, id)) {\n\t\ttxSlot* dispatch = instance->next;\n\t\ttxSlot* view = dispatch->next;\n\t\ttxSlot* buffer = view->next;\n\t\ttxU2 shift = dispatch->value.typedArray.dispatch->shift;\n\t\ttxIndex length = fxGetDataViewSize(the, view, buffer) >> shift;\n\t\tif ((!id) && (index < length)) {\n\t\t\t(*dispatch->value.typedArray.dispatch->getter)(the, buffer->value.reference->next, view->value.dataView.offset + (index << shift), slot, EndianNative);\n\t\t\treturn 1;\n\t\t}\n\t\tslot->kind = XS_UNDEFINED_KIND;\n\t\tslot->flag = XS_NO_FLAG;\n\t\treturn 0;\n\t}\n\treturn fxOrdinaryGetOwnProperty(the, instance, id, index, slot);\n}\n\ntxSlot* fxTypedArrayGetProperty(txMachine* the, txSlot* instance, txID id, txIndex index, txFlag flag)\n{\n\tif ((!id) || fxIsCanonicalIndex(the, id)) {\n\t\tthe->scratch.value.at.id = id;\n\t\tthe->scratch.value.at.index = index;\n\t\treturn &mxTypedArrayAccessor;\n\t}\n\treturn fxOrdinaryGetProperty(the, instance, id, index, flag);\n}\n\ntxBoolean fxTypedArrayGetPropertyValue(txMachine* the, txSlot* instance, txID id, txIndex index, txSlot* receiver, txSlot* value)\n{\n\tif ((!id) || fxIsCanonicalIndex(the, id)) {\n\t\ttxSlot* dispatch = instance->next;\n\t\ttxSlot* view = dispatch->next;\n\t\ttxSlot* buffer = view->next;\n\t\ttxU2 shift = dispatch->value.typedArray.dispatch->shift;\n\t\ttxIndex length = fxGetDataViewSize(the, view, buffer) >> shift;\n\t\tif ((!id) && (index < length)) {\n\t\t\t(*dispatch->value.typedArray.dispatch->getter)(the, buffer->value.reference->next, view->value.dataView.offset + (index << shift), value, EndianNative);\n\t\t\treturn 1;\n\t\t}\n\t\tvalue->kind = XS_UNDEFINED_KIND;\n\t\treturn 0;\n\t}\n\treturn fxOrdinaryGetPropertyValue(the, instance, id, index, receiver, value);\n}\n\ntxBoolean fxTypedArrayHasProperty(txMachine* the, txSlot* instance, txID id, txIndex index)\n{\n\tif ((!id) || fxIsCanonicalIndex(the, id)) {\n\t\ttxSlot* dispatch = instance->next;\n\t\ttxSlot* view = dispatch->next;\n\t\ttxSlot* buffer = view->next;\n\t\ttxU2 shift = dispatch->value.typedArray.dispatch->shift;\n\t\ttxIndex length = fxGetDataViewSize(the, view, buffer) >> shift;\n\t\treturn ((!id) && (index < length)) ? 1 : 0;\n\t}\n\treturn fxOrdinaryHasProperty(the, instance, id, index);\n}\n\nvoid fxTypedArrayOwnKeys(txMachine* the, txSlot* instance, txFlag flag, txSlot* keys)\n{\n\tif (flag & XS_EACH_NAME_FLAG) {\n\t\ttxSlot* dispatch = instance->next;\n\t\ttxSlot* view = dispatch->next;\n\t\ttxSlot* buffer = view->next;\n\t\ttxU2 shift = dispatch->value.typedArray.dispatch->shift;\n\t\ttxIndex length = fxGetDataViewSize(the, view, buffer) >> shift;\n\t\tif (length) {\n\t\t\ttxIndex index;\n\t\t\tfor (index = 0; index < length; index++)\n\t\t\t\tkeys = fxQueueKey(the, 0, index, keys);\n\t\t}\n\t}\n\tfxOrdinaryOwnKeys(the, instance, flag, keys);\n}\n\ntxSlot* fxTypedArraySetProperty(txMachine* the, txSlot* instance, txID id, txIndex index, txFlag flag)\n{\n\tif ((!id) || fxIsCanonicalIndex(the, id)) {\n\t\tthe->scratch.value.at.id = id;\n\t\tthe->scratch.value.at.index = index;\n\t\treturn &mxTypedArrayAccessor;\n\t}\n\treturn fxOrdinarySetProperty(the, instance, id, index, flag);\n}\n\ntxBoolean fxTypedArraySetPropertyValue(txMachine* the, txSlot* instance, txID id, txIndex index, txSlot* value, txSlot* receiver)\n{\n\tif ((!id) || fxIsCanonicalIndex(the, id)) {\n\t\ttxSlot* dispatch = instance->next;\n\t\ttxSlot* view = dispatch->next;\n\t\ttxSlot* buffer = view->next;\n\t\ttxU2 shift = dispatch->value.typedArray.dispatch->shift;\n\t\ttxSlot* arrayBuffer = buffer->value.reference->next;\n\t\ttxIndex length;\n\t\tdispatch->value.typedArray.dispatch->coerce(the, value);\n\t\tif (arrayBuffer->flag & XS_DONT_SET_FLAG)\n\t\t\tmxTypeError(\"read-only buffer\");\n\t\tlength = fxGetDataViewSize(the, view, buffer) >> shift;\n\t\tif ((!id) && (index < length)) {\n\t\t\t(*dispatch->value.typedArray.dispatch->setter)(the, buffer->value.reference->next, view->value.dataView.offset + (index << shift), value, EndianNative);\n\t\t}\n\t\treturn 1;\n\t}\n\treturn fxOrdinarySetPropertyValue(the, instance, id, index, value, receiver);\n}\n\nvoid fxCallTypedArrayItem(txMachine* the, txSlot* function, txSlot* dispatch, txSlot* view, txSlot* data, txInteger index, txSlot* item)\n{\n\t/* THIS */\n\tif (mxArgc > 1)\n\t\tmxPushSlot(mxArgv(1));\n\telse\n\t\tmxPushUndefined();\n\t/* FUNCTION */\n\tmxPushSlot(function);\n\tmxCall();\n\t/* ARGUMENTS */\n\tmxPushSlot(mxThis);\n\tmxGetIndex(index);\n\tif (item) {\n\t\titem->kind = the->stack->kind;\n\t\titem->value = the->stack->value;\n\t}\n\tmxPushInteger(index);\n\tmxPushSlot(mxThis);\n\tmxRunCount(3);\n}\n\ntxSlot* fxCheckTypedArrayInstance(txMachine* the, txSlot* slot)\n{\n\tif (slot->kind == XS_REFERENCE_KIND) {\n        txSlot* instance = slot->value.reference;\n\t\tif (((slot = instance->next)) && (slot->flag & XS_INTERNAL_FLAG) && (slot->kind == XS_TYPED_ARRAY_KIND))\n\t\t\treturn instance;\n\t}\n\tmxTypeError(\"this is no TypedArray instance\");\n\treturn C_NULL;\n}\n\nint fxCompareTypedArrayItem(txMachine* the, txSlot* function, txSlot* dispatch, txSlot* view, txSlot* data, txInteger index)\n{\n\ttxSlot* slot = the->stack;\n\tint result;\n\t/* THIS */\n\tmxPushUndefined();\n\t/* FUNCTION */\n\tmxPushSlot(function);\n\tmxCall();\n\t/* ARGUMENTS */\n\tmxPushUndefined();\n\t(*dispatch->value.typedArray.dispatch->getter)(the, data, view->value.dataView.offset + (index << dispatch->value.typedArray.dispatch->shift), the->stack, EndianNative);\n\tmxPushSlot(slot);\n\tmxRunCount(2);\n\tif (the->stack->kind == XS_INTEGER_KIND)\n\t\tresult = the->stack->value.integer;\n\telse {\n\t\ttxNumber number = fxToNumber(the, the->stack);\n\t\tresult = (number < 0) ? -1 :  (number > 0) ? 1 : 0;\n\t}\n\tmxPop();\n\tif (data->value.arrayBuffer.address == C_NULL)\n\t\tmxTypeError(\"detached buffer\");\n\treturn result;\n}\n\ntxSlot* fxConstructTypedArray(txMachine* the)\n{\n\ttxSlot* prototype;\n\ttxSlot* dispatch;\n\ttxSlot* instance;\n\tif (mxIsUndefined(mxTarget))\n\t\tmxTypeError(\"call: TypedArray\");\n\tdispatch = mxFunctionInstanceHome(mxFunction->value.reference);\n\tdispatch = dispatch->next;\n\tprototype = mxBehaviorGetProperty(the, mxFunction->value.reference, mxID(_prototype), 0, XS_ANY);\n\tif (!dispatch || (dispatch->kind != XS_TYPED_ARRAY_KIND))\n\t\tmxTypeError(\"new: TypedArray\");\n\tmxPushSlot(mxTarget);\n\tfxGetPrototypeFromConstructor(the, prototype);\n\tinstance = fxNewTypedArrayInstance(the, dispatch->value.typedArray.dispatch, dispatch->value.typedArray.atomics);\n\tmxPullSlot(mxResult);\n\treturn instance;\n}\n\nvoid fxCreateTypedArraySpecies(txMachine* the)\n{\n\ttxSlot* instance = fxToInstance(the, mxThis);\n\ttxSlot* dispatch = instance->next;\n\ttxSlot* constructor = &the->stackPrototypes[-1 - (txInteger)dispatch->value.typedArray.dispatch->constructorID];\n\tmxPushSlot(mxThis);\n\tmxGetID(mxID(_constructor));\n\tfxToSpeciesConstructor(the, constructor);\n\tmxNew();\n}\n\ntxSlot* fxGetTypedArrayValue(txMachine* the, txSlot* instance, txInteger index)\n{\n\ttxSlot* dispatch = instance->next;\n\ttxSlot* view = dispatch->next;\n\ttxSlot* buffer = view->next;\n\ttxSlot* data = mxIsReference(buffer) ? fxCheckArrayBufferDetached(the, buffer, XS_IMMUTABLE) : C_NULL;\n\ttxU2 shift = dispatch->value.typedArray.dispatch->shift;\n\tindex <<= shift;\n\tif ((0 <= index) && ((index + (1 << shift)) <= view->value.dataView.size)) {\n\t\t(*dispatch->value.typedArray.dispatch->getter)(the, data, view->value.dataView.offset + index, &(the->scratch), EndianNative);\n\t\treturn &the->scratch;\n\t}\n\treturn C_NULL;\n}\n\nvoid fxReduceTypedArrayItem(txMachine* the, txSlot* function, txSlot* dispatch, txSlot* view, txSlot* data, txInteger index)\n{\n\t/* THIS */\n\tmxPushUndefined();\n\t/* FUNCTION */\n\tmxPushSlot(function);\n\tmxCall();\n\t/* ARGUMENTS */\n\tmxPushSlot(mxResult);\n\tmxPushSlot(mxThis);\n\tmxGetIndex(index);\n\tmxPushInteger(index);\n\tmxPushSlot(mxThis);\n\tmxRunCount(4);\n\tmxPullSlot(mxResult);\n}\n\ntxSlot* fxNewTypedArrayInstance(txMachine* the, txTypeDispatch* dispatch, txTypeAtomics* atomics)\n{\n\ttxSlot* instance;\n\ttxSlot* property;\n\tinstance = fxNewObjectInstance(the);\n\tinstance->flag |= XS_EXOTIC_FLAG;\n\tproperty = fxNextTypeDispatchProperty(the, instance, dispatch, atomics, XS_TYPED_ARRAY_BEHAVIOR, XS_INTERNAL_FLAG);\n\tproperty = property->next = fxNewSlot(the);\n\tproperty->flag = XS_INTERNAL_FLAG;\n\tproperty->kind = XS_DATA_VIEW_KIND;\n\tproperty->value.dataView.offset = 0;\n\tproperty->value.dataView.size = 0;\n\tproperty = fxNextNullProperty(the, property, XS_NO_ID, XS_INTERNAL_FLAG);\n\treturn instance;\n}\n\nvoid fx_TypedArray(txMachine* the)\n{\n\ttxSlot* instance = fxConstructTypedArray(the);\n\ttxSlot* dispatch = instance->next;\n\ttxSlot* view = dispatch->next;\n\ttxSlot* buffer = view->next;\n\ttxSlot* data = C_NULL;\n\ttxU2 shift = dispatch->value.typedArray.dispatch->shift;\n\ttxSlot* slot;\n\tif ((mxArgc > 0) && (mxArgv(0)->kind == XS_REFERENCE_KIND)) {\n\t\tslot = mxArgv(0)->value.reference->next;\n\t\tif (slot && ((slot->kind == XS_ARRAY_BUFFER_KIND) || (slot->kind == XS_HOST_KIND))) {\n\t\t\ttxInteger offset = fxArgToByteLength(the, 1, 0);\n\t\t\ttxInteger size;\n\t\t\ttxSlot* info;\n\t\t\tif (offset & ((1 << shift) - 1))\n\t\t\t\tmxRangeError(\"invalid byteOffset %ld\", offset);\n\t\t\tsize = fxArgToByteLength(the, 2, -1);\n\t\t\tinfo = fxGetBufferInfo(the, mxArgv(0));\n\t\t\tif (size >= 0) {\n\t\t\t\tsize <<= shift;\n\t\t\t\tif (info->value.bufferInfo.length < (offset + size))\n\t\t\t\t\tmxRangeError(\"out of range byteLength %ld\", size);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (info->value.bufferInfo.length & ((1 << shift) - 1))\n\t\t\t\t\tmxRangeError(\"invalid byteLength %ld\", info->value.bufferInfo.length);\n\t\t\t\tsize = info->value.bufferInfo.length - offset;\n\t\t\t\tif (size < 0)\n\t\t\t\t\tmxRangeError(\"out of range byteLength %ld\", size);\n\t\t\t\tif (info->value.bufferInfo.maxLength >= 0)\n\t\t\t\t\tsize = -1;\n\t\t\t}\n\t\t\tview->value.dataView.offset = offset;\n\t\t\tview->value.dataView.size = size;\n\t\t\tbuffer->kind = XS_REFERENCE_KIND;\n\t\t\tbuffer->value.reference = mxArgv(0)->value.reference;\n\t\t}\n\t\telse if (slot && (slot->kind == XS_TYPED_ARRAY_KIND)) {\n\t\t\ttxSlot* sourceDispatch = slot;\n\t\t\ttxSlot* sourceView = sourceDispatch->next;\n\t\t\ttxSlot* sourceBuffer = sourceView->next;\n\t\t\ttxU2 sourceShift = sourceDispatch->value.typedArray.dispatch->shift;\n\t\t\ttxInteger sourceLength = fxCheckDataViewSize(the, sourceView, sourceBuffer, XS_IMMUTABLE) >> sourceShift;\n\t\t\ttxSlot* sourceData = sourceBuffer->value.reference->next;\n\t\t\ttxInteger sourceDelta = sourceDispatch->value.typedArray.dispatch->size;\n\t\t\ttxInteger sourceOffset = sourceView->value.dataView.offset;\n\t\t\ttxInteger offset = 0;\n\t\t\ttxInteger size = sourceLength << shift;\n\t\t\t/* THIS */\n\t\t\tmxPushUninitialized();\t\n\t\t\t/* FUNCTION */\n\t\t\tmxPush(mxArrayBufferConstructor);\n\t\t\t/* TARGET */\n\t\t\tif (sourceData->kind == XS_ARRAY_BUFFER_KIND) {\n\t\t\t\tmxPushSlot(sourceBuffer);\n\t\t\t\tmxGetID(mxID(_constructor));\n\t\t\t\tfxToSpeciesConstructor(the, &mxArrayBufferConstructor);\n\t\t\t}\n\t\t\telse\n\t\t\t\tmxPush(mxArrayBufferConstructor);\n\t\t\t/* RESULT */\n\t\t\tmxPushUndefined();\t\n\t\t\tmxPushUninitialized();\t\n\t\t\tmxPushUninitialized();\t\n\t\t\t/* ARGUMENTS */\n\t\t\tsourceLength = fxGetDataViewSize(the, sourceView, sourceBuffer) >> sourceShift;\n\t\t\tsize = sourceLength << shift;\n\t\t\tmxPushInteger(size);\n\t\t\tmxRunCount(1);\n\t\t\tmxPullSlot(buffer);\n\t\t\tsourceLength = fxCheckDataViewSize(the, sourceView, sourceBuffer, XS_IMMUTABLE) >> sourceShift;\n\t\t\tsize = sourceLength << shift;\n\t\t\t\n\t\t\tdata = fxCheckArrayBufferDetached(the, buffer, XS_MUTABLE);\n\t\t\tview->value.dataView.offset = offset;\n\t\t\tview->value.dataView.size = size;\n\t\t\tif (dispatch == sourceDispatch)\n\t\t\t\tc_memcpy(data->value.arrayBuffer.address + offset, sourceData->value.arrayBuffer.address + sourceOffset, size);\n\t\t\telse {\n\t\t\t\ttxBoolean contentType = (dispatch->value.typedArray.dispatch->constructorID == _BigInt64Array)\n\t\t\t\t\t\t|| (dispatch->value.typedArray.dispatch->constructorID == _BigUint64Array);\n\t\t\t\ttxBoolean sourceContentType = (sourceDispatch->value.typedArray.dispatch->constructorID == _BigInt64Array)\n\t\t\t\t\t\t|| (sourceDispatch->value.typedArray.dispatch->constructorID == _BigUint64Array);\n\t\t\t\tif (contentType != sourceContentType)\n\t\t\t\t\tmxTypeError(\"incompatible content type\");\n\t\t\t\tmxPushUndefined();\n\t\t\t\twhile (offset < size) {\n\t\t\t\t\t(*sourceDispatch->value.typedArray.dispatch->getter)(the, sourceData, sourceOffset, the->stack, EndianNative);\n\t\t\t\t\t(*dispatch->value.typedArray.dispatch->coerce)(the, the->stack);\n\t\t\t\t\t(*dispatch->value.typedArray.dispatch->setter)(the, data, offset, the->stack, EndianNative);\n\t\t\t\t\tsourceOffset += sourceDelta;\n\t\t\t\t\toffset += 1 << shift;\n\t\t\t\t}\n\t\t\t\tmxPop();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfx_TypedArray_from_object(the, instance, C_NULL, C_NULL);\n\t\t}\n\t}\n\telse {\n        txInteger length = fxArgToByteLength(the, 0, 0);\n        if (length & (((1 << shift) - 1) << (32 - shift)))\n\t\t\tmxRangeError(\"out of range byteLength\");\n        length <<= shift;\n\t\tmxPush(mxArrayBufferConstructor);\n\t\tmxNew();\n\t\tmxPushInteger(length);\n\t\tmxRunCount(1);\n\t\tmxPullSlot(buffer);\n        view->value.dataView.offset = 0;\n        view->value.dataView.size = length;\n\t}\n}\n\nvoid fx_TypedArray_from(txMachine* the)\n{\n\ttxSlot* function = C_NULL;\n\ttxSlot* _this = C_NULL;\n\tif (!mxIsReference(mxThis) || !(mxIsConstructor(mxThis->value.reference)))\n\t\tmxTypeError(\"this is no constructor\");\n\tif (mxArgc > 1) {\n\t\ttxSlot* slot = mxArgv(1);\n\t\tif (!mxIsUndefined(slot)) {\n\t\t\tfunction = slot;\n\t\t\tif (!fxIsCallable(the, function))\n\t\t\t\tmxTypeError(\"map is no function\");\n\t\t\tif (mxArgc > 2)\n\t\t\t\t_this = mxArgv(2);\n\t\t}\n\t}\n\tfx_TypedArray_from_object(the, C_NULL, function, _this);\n}\n\nvoid fx_TypedArray_from_object(txMachine* the, txSlot* instance, txSlot* function, txSlot* _this)\n{\n\ttxSlot* stack = the->stack;\n\ttxSlot* iterator;\n\ttxSlot* next;\n\ttxSlot* value;\n\ttxSlot* list = C_NULL;\n\ttxSlot* slot;\n\ttxSlot* dispatch;\n\ttxSlot* view;\n\ttxSlot* buffer;\n\ttxSlot* data;\n\ttxU2 shift;\n\ttxNumber length;\n\tmxTemporary(iterator);\n\tmxTemporary(next);\n\tif (fxGetIterator(the, mxArgv(0), iterator, next, 1)) {\n\t\tlist = fxNewInstance(the);\n\t\tslot = list;\n\t\tlength = 0;\n\t\tmxTemporary(value);\n\t\twhile (fxIteratorNext(the, iterator, next, value)) {\n\t\t\tslot = fxNextSlotProperty(the, slot, value, XS_NO_ID, XS_NO_FLAG);\n\t\t\tlength++;\n\t\t}\n\t}\n\telse {\n\t\tmxPushSlot(mxArgv(0));\n\t\tmxGetID(mxID(_length));\n\t\tlength = fxToLength(the, the->stack);\n\t\tmxPop();\n\t}\n\tif (instance) {\n\t\tdispatch = instance->next;\n\t\tview = dispatch->next;\n\t\tbuffer = view->next;\n\t\tshift = dispatch->value.typedArray.dispatch->shift;\n\t\tmxPush(mxArrayBufferConstructor);\n\t\tmxNew();\n\t\tmxPushNumber(length * dispatch->value.typedArray.dispatch->size);\n\t\tmxRunCount(1);\n\t\tmxPullSlot(buffer);\n\t\tdata = fxCheckArrayBufferDetached(the, buffer, XS_MUTABLE);\n\t\tview->value.dataView.offset = 0;\n\t\tview->value.dataView.size = data->next->value.bufferInfo.length;\n\t}\n\telse {\n\t\tmxPushSlot(mxThis);\n\t\tmxNew();\n\t\tmxPushNumber(length);\n\t\tmxRunCount(1);\n\t\tmxPullSlot(mxResult);\n\t\tinstance = fxToInstance(the, mxResult);\n\t\tif (((slot = instance->next)) && (slot->flag & XS_INTERNAL_FLAG) && (slot->kind == XS_TYPED_ARRAY_KIND)) {\n\t\t\tdispatch = instance->next;\n\t\t\tview = dispatch->next;\n\t\t\tbuffer = view->next;\n\t\t\tdata = fxCheckArrayBufferDetached(the, buffer, XS_MUTABLE);\n\t\t\tshift = dispatch->value.typedArray.dispatch->shift;\n\t\t\tif (view->value.dataView.size < (length * dispatch->value.typedArray.dispatch->size))\n\t\t\t\tmxTypeError(\"too small TypedArray\");\n\t\t}\n\t\telse\n\t\t\tmxTypeError(\"no TypedArray\");\n\t}\n\tif (list) {\n\t\ttxInteger index = 0;\n\t\tslot = list->next;\n\t\twhile (slot) {\n\t\t\t/* ARG0 */\n\t\t\tif (function) {\n\t\t\t\t/* THIS */\n\t\t\t\tif (_this)\n\t\t\t\t\tmxPushSlot(_this);\n\t\t\t\telse\n\t\t\t\t\tmxPushUndefined();\n\t\t\t\t/* FUNCTION */\n\t\t\t\tmxPushSlot(function);\n\t\t\t\tmxCall();\n\t\t\t\t/* ARGUMENTS */\n\t\t\t\tmxPushSlot(slot);\n\t\t\t\tmxPushInteger(index);\n\t\t\t\tmxRunCount(2);\n\t\t\t}\n\t\t\telse\n\t\t\t\tmxPushSlot(slot);\n\t\t\t(*dispatch->value.typedArray.dispatch->coerce)(the, the->stack);\n\t\t\t(*dispatch->value.typedArray.dispatch->setter)(the, data, (index << shift), the->stack, EndianNative);\n\t\t\tmxPop();\n\t\t\tindex++;\n\t\t\tslot = slot->next;\n\t\t}\n\t}\n\telse {\n\t\ttxInteger index = 0;\n\t\ttxInteger count = (txInteger)length;\n\t\twhile (index < count) {\n\t\t\tif (function) {\n\t\t\t\t/* THIS */\n\t\t\t\tif (_this)\n\t\t\t\t\tmxPushSlot(_this);\n\t\t\t\telse\n\t\t\t\t\tmxPushUndefined();\n\t\t\t\t/* FUNCTION */\n\t\t\t\tmxPushSlot(function);\n\t\t\t\tmxCall();\n\t\t\t\t/* ARGUMENTS */\n\t\t\t\tmxPushSlot(mxArgv(0));\n\t\t\t\tmxGetIndex(index);\n\t\t\t\tmxPushInteger(index);\n\t\t\t\tmxRunCount(2);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmxPushSlot(mxArgv(0));\n\t\t\t\tmxGetIndex(index);\n\t\t\t}\n\t\t\t(*dispatch->value.typedArray.dispatch->coerce)(the, the->stack);\n\t\t\t(*dispatch->value.typedArray.dispatch->setter)(the, data, (index << shift), the->stack, EndianNative);\n\t\t\tmxPop();\n\t\t\tindex++;\n\t\t}\t\n\t}\n\tthe->stack = stack;\n}\n\nvoid fx_TypedArray_of(txMachine* the)\n{\n\ttxInteger count = mxArgc;\n\ttxInteger index = 0;\n\tmxPushSlot(mxThis);\n\tmxNew();\n\tmxPushInteger(count);\n\tmxRunCount(1);\n\tmxPullSlot(mxResult);\n\t{\n\t\tmxResultTypedArrayDeclarations;\n\t\ttxU2 shift = resultDispatch->value.typedArray.dispatch->shift;\n\t\tif (resultLength < count)\n\t\t\tmxTypeError(\"insufficient TypedArray\");\n\t\twhile (index < count) {\n\t\t\t(*resultDispatch->value.typedArray.dispatch->coerce)(the, mxArgv(index));\n\t\t\tif (resultBuffer->value.arrayBuffer.address == C_NULL)\n\t\t\t\tmxTypeError(\"detached buffer\");\n\t\t\t(*resultDispatch->value.typedArray.dispatch->setter)(the, resultBuffer->value.reference->next, resultView->value.dataView.offset + (index << shift), mxArgv(index), EndianNative);\n\t\t\tindex++;\n\t\t}\n\t}\n}\n\nvoid fx_TypedArray_prototype_at(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\ttxInteger index = (mxArgc > 0) ? fxToInteger(the, mxArgv(0)) : 0;\n\tif (index < 0)\n\t\tindex = length + index;\n\tif ((0 <= index) && (index < length)) {\n\t\tmxPushSlot(mxThis);\n\t\tmxGetIndex(index);\n\t\tmxPullSlot(mxResult);\n\t}\n}\n\nvoid fx_TypedArray_prototype_buffer_get(txMachine* the)\n{\n\ttxSlot* instance = fxCheckTypedArrayInstance(the, mxThis);\n\ttxSlot* dispatch = instance->next;\n\ttxSlot* view = dispatch->next;\n\ttxSlot* buffer = view->next;\n\tmxResult->kind = buffer->kind;\n\tmxResult->value = buffer->value;\n}\n\nvoid fx_TypedArray_prototype_byteLength_get(txMachine* the)\n{\n\ttxSlot* instance = fxCheckTypedArrayInstance(the, mxThis);\n\ttxSlot* dispatch = instance->next;\n\ttxSlot* view = dispatch->next;\n\ttxSlot* buffer = view->next;\n\tmxResult->kind = XS_INTEGER_KIND;\n\tmxResult->value.integer = fxGetDataViewSize(the, view, buffer);\n}\n\nvoid fx_TypedArray_prototype_byteOffset_get(txMachine* the)\n{\n\ttxSlot* instance = fxCheckTypedArrayInstance(the, mxThis);\n\ttxSlot* dispatch = instance->next;\n\ttxSlot* view = dispatch->next;\n\ttxSlot* buffer = view->next;\n\ttxInteger offset = view->value.dataView.offset;\n\ttxInteger size = view->value.dataView.size;\n\ttxSlot* arrayBuffer = buffer->value.reference->next;\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\tmxResult->kind = XS_INTEGER_KIND;\n\tmxResult->value.integer = 0;\n\tif (arrayBuffer->value.arrayBuffer.address == C_NULL)\n\t\treturn;\n\tif (bufferInfo->value.bufferInfo.maxLength >= 0) {\n\t\ttxInteger byteLength = bufferInfo->value.bufferInfo.length;\n\t\tif (offset > byteLength)\n\t\t\treturn;\n\t\tsize = (size < 0) ? byteLength : offset + size;\n\t\tif (size > byteLength)\n\t\t\treturn;\n\t\tsize -= offset;\n\t}\n\tmxResult->value.integer = offset;\n}\n\nvoid fx_TypedArray_prototype_copyWithin(txMachine* the)\n{\n\tmxMutableTypedArrayDeclarations;\n\ttxInteger delta = dispatch->value.typedArray.dispatch->size;\n\ttxInteger target = (txInteger)fxArgToIndex(the, 0, 0, length);\n\ttxInteger start = (txInteger)fxArgToIndex(the, 1, 0, length);\n\ttxInteger end = (txInteger)fxArgToIndex(the, 2, length, length);\n\ttxInteger count = end - start;\n\tfxCheckArrayBufferDetached(the, buffer, XS_MUTABLE);\n\tif (count > length - target)\n\t\tcount = length - target;\n\tif (count > 0) {\n\t\ttxByte* address = buffer->value.reference->next->value.arrayBuffer.address + view->value.dataView.offset;\n\t\tc_memmove(address + (target * delta), address + (start * delta), count * delta);\n\t\tmxMeterSome((txU4)count * 2);\n\t}\n\tmxResult->kind = mxThis->kind;\n\tmxResult->value = mxThis->value;\n}\n\nvoid fx_TypedArray_prototype_entries(txMachine* the)\n{\n\ttxSlot* instance = fxCheckTypedArrayInstance(the, mxThis);\n\ttxSlot* dispatch = instance->next;\n\ttxSlot* view = dispatch->next;\n\ttxSlot* buffer = view->next;\n\ttxSlot* property;\n\tfxCheckDataViewSize(the, view, buffer, XS_IMMUTABLE);\n\tmxPush(mxArrayIteratorPrototype);\n\tproperty = fxLastProperty(the, fxNewIteratorInstance(the, mxThis, mxID(_Array)));\n\tproperty = fxNextIntegerProperty(the, property, 2, XS_NO_ID, XS_INTERNAL_FLAG);\n\tmxPullSlot(mxResult);\n}\n\nvoid fx_TypedArray_prototype_every(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\ttxSlot* function = fxArgToCallback(the, 0);\n\ttxInteger index = 0;\n\tmxResult->kind = XS_BOOLEAN_KIND;\n\tmxResult->value.boolean = 1;\n\twhile (index < length) {\n\t\tfxCallTypedArrayItem(the, function, dispatch, view, buffer->value.reference->next, index, C_NULL);\n\t\tmxResult->value.boolean = fxToBoolean(the, the->stack++);\n\t\tif (!mxResult->value.boolean)\n\t\t\tbreak;\n\t\tindex++;\n\t}\n}\n\nvoid fx_TypedArray_prototype_fill(txMachine* the)\n{\n\tmxMutableTypedArrayDeclarations;\n\ttxInteger delta = dispatch->value.typedArray.dispatch->size;\n\ttxInteger start = (txInteger)fxArgToIndex(the, 1, 0, length);\n\ttxInteger end = (txInteger)fxArgToIndex(the, 2, length, length);\n\tstart *= delta;\n\tend *= delta;\n\tstart += view->value.dataView.offset;\n\tend += view->value.dataView.offset;\n\tif (mxArgc > 0)\n\t\tmxPushSlot(mxArgv(0));\n\telse\n\t\tmxPushUndefined();\n\t(*dispatch->value.typedArray.dispatch->coerce)(the, the->stack);\n\tfxCheckDataViewSize(the, view, buffer, XS_MUTABLE);\n\twhile (start < end) {\n\t\t(*dispatch->value.typedArray.dispatch->setter)(the, buffer->value.reference->next, start, the->stack, EndianNative);\n\t\tstart += delta;\n\t}\n\tmxPop();\n\tmxResult->kind = mxThis->kind;\n\tmxResult->value = mxThis->value;\n}\n\nvoid fx_TypedArray_prototype_filter(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\ttxSlot* function = fxArgToCallback(the, 0);\n\ttxSlot* list = fxNewInstance(the);\n\ttxSlot* slot = list;\n\ttxInteger count = 0;\n\ttxInteger index = 0;\n\tmxPushUndefined();\n\twhile (index < length) {\n\t\tfxCallTypedArrayItem(the, function, dispatch, view, buffer->value.reference->next, index, the->stack);\n\t\tif (fxToBoolean(the, the->stack++)) {\n\t\t\tcount++;\n\t\t\tslot = fxNextSlotProperty(the, slot, the->stack, XS_NO_ID, XS_NO_FLAG);\n\t\t}\n\t\tindex++;\n\t}\n\tmxPop();\n\tfxCreateTypedArraySpecies(the);\n\tmxPushNumber(count);\n\tmxRunCount(1);\n\tmxPullSlot(mxResult);\n\t{\n\t\tmxResultTypedArrayDeclarations;\n\t\ttxInteger resultOffset = 0;\n\t\ttxInteger resultSize = resultDispatch->value.typedArray.dispatch->size;\n\t\tif (resultLength < count)\n\t\t\tmxTypeError(\"insufficient buffer\");\n\t\tslot = list->next;\n\t\twhile (slot) {\n\t\t\t(*resultDispatch->value.typedArray.dispatch->coerce)(the, slot);\n\t\t\t(*resultDispatch->value.typedArray.dispatch->setter)(the, resultBuffer->value.reference->next, resultOffset, slot, EndianNative);\n\t\t\tresultOffset += resultSize;\n\t\t\tslot = slot->next;\n\t\t}\n\t}\n\tmxPop();\n}\n\nvoid fx_TypedArray_prototype_find(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\ttxSlot* function = fxArgToCallback(the, 0);\n\ttxInteger index = 0;\n\tmxPushUndefined();\n\twhile (index < length) {\n\t\tfxCallTypedArrayItem(the, function, dispatch, view, buffer->value.reference->next, index, the->stack);\n\t\tif (fxToBoolean(the, the->stack++)) {\n\t\t\tmxResult->kind = the->stack->kind;\n\t\t\tmxResult->value = the->stack->value;\n\t\t\tbreak;\n\t\t}\n\t\tindex++;\n\t}\n\tmxPop();\n}\n\nvoid fx_TypedArray_prototype_findIndex(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\ttxSlot* function = fxArgToCallback(the, 0);\n\ttxInteger index = 0;\n\tmxResult->kind = XS_INTEGER_KIND;\n\tmxResult->value.integer = -1;\n\twhile (index < length) {\n\t\tfxCallTypedArrayItem(the, function, dispatch, view, buffer->value.reference->next, index, C_NULL);\n\t\tif (fxToBoolean(the, the->stack++)) {\n\t\t\tmxResult->value.integer = index;\n\t\t\tbreak;\n\t\t}\n\t\tindex++;\n\t}\n}\n\nvoid fx_TypedArray_prototype_findLast(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\ttxSlot* function = fxArgToCallback(the, 0);\n\ttxInteger index = length;\n\tmxPushUndefined();\n\twhile (index > 0) {\n\t\tindex--;\n\t\tfxCallTypedArrayItem(the, function, dispatch, view, buffer->value.reference->next, index, the->stack);\n\t\tif (fxToBoolean(the, the->stack++)) {\n\t\t\tmxResult->kind = the->stack->kind;\n\t\t\tmxResult->value = the->stack->value;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmxPop();\n}\n\nvoid fx_TypedArray_prototype_findLastIndex(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\ttxSlot* function = fxArgToCallback(the, 0);\n\ttxInteger index = length;\n\tmxResult->kind = XS_INTEGER_KIND;\n\tmxResult->value.integer = -1;\n\twhile (index > 0) {\n\t\tindex--;\n\t\tfxCallTypedArrayItem(the, function, dispatch, view, buffer->value.reference->next, index, C_NULL);\n\t\tif (fxToBoolean(the, the->stack++)) {\n\t\t\tmxResult->value.integer = index;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid fx_TypedArray_prototype_forEach(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\ttxSlot* function = fxArgToCallback(the, 0);\n\ttxInteger index = 0;\n\twhile (index < length) {\n\t\tfxCallTypedArrayItem(the, function, dispatch, view, buffer->value.reference->next, index, C_NULL);\n\t\tmxPop();\n\t\tindex++;\n\t}\n}\n\nvoid fx_TypedArray_prototype_includes(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\tfxBoolean(the, mxResult, 0);\n\tif (length) {\n\t\ttxInteger index = (txInteger)fxArgToIndex(the, 1, 0, length);\n\t\ttxSlot* argument;\n\t\tif (mxArgc > 0)\n\t\t\tmxPushSlot(mxArgv(0));\n\t\telse\n\t\t\tmxPushUndefined();\n\t\targument = the->stack;\n\t\twhile (index < length) {\n\t\t\tmxPushSlot(mxThis);\n\t\t\tmxGetIndex(index);\n\t\t\tif (fxIsSameValue(the, the->stack++, argument, 1)) {\n\t\t\t\tmxResult->value.boolean = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\tmxPop();\n\t}\n}\n\nvoid fx_TypedArray_prototype_indexOf(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\tfxInteger(the, mxResult, -1);\n\tif (length) {\n\t\ttxInteger index = (txInteger)fxArgToIndex(the, 1, 0, length);\n\t\ttxSlot* argument;\n\t\tif (mxArgc > 0)\n\t\t\tmxPushSlot(mxArgv(0));\n\t\telse\n\t\t\tmxPushUndefined();\n\t\targument = the->stack;\n\t\twhile (index < length) {\n\t\t\tmxPushSlot(mxThis);\n\t\t\tif (fxHasIndex(the, index)) {\n\t\t\t\tmxPushSlot(mxThis);\n\t\t\t\tmxGetIndex(index);\n\t\t\t\tif (fxIsSameSlot(the, the->stack++, argument)) {\n\t\t\t\t\tmxResult->value.integer = index;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\tmxPop();\n\t}\n}\n\nvoid fx_TypedArray_prototype_join(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\ttxInteger delta = dispatch->value.typedArray.dispatch->size;\n\ttxInteger offset = view->value.dataView.offset;\n\ttxInteger limit = offset + (length << dispatch->value.typedArray.dispatch->shift);\n\ttxString string;\n\ttxSlot* list = fxNewInstance(the);\n\ttxSlot* slot = list;\n\ttxBoolean comma = 0;\n\ttxInteger size = 0;\n\tif ((mxArgc > 0) && (mxArgv(0)->kind != XS_UNDEFINED_KIND)) {\n\t\tmxPushSlot(mxArgv(0));\n\t\tstring = fxToString(the, the->stack);\n\t\tthe->stack->kind += XS_KEY_KIND - XS_STRING_KIND;\n\t\tthe->stack->value.key.sum = mxStringLength(the->stack->value.string);\n\t}\n\telse {\n\t\tmxPushStringX(\",\");\n\t\tthe->stack->kind += XS_KEY_KIND - XS_STRING_KIND;\n\t\tthe->stack->value.key.sum = 1;\n\t}\n\tlength = offset + fxGetDataViewSize(the, view, buffer);\n\twhile (offset < limit) {\n\t\tif (comma) {\n\t\t\tslot = fxNextSlotProperty(the, slot, the->stack, XS_NO_ID, XS_NO_FLAG);\n            size = fxAddChunkSizes(the, size, slot->value.key.sum);\n\t\t}\n\t\telse\n\t\t\tcomma = 1;\n\t\tif (offset < length) {\n\t\t\tmxPushUndefined();\n\t\t\t(*dispatch->value.typedArray.dispatch->getter)(the, buffer->value.reference->next, offset, the->stack, EndianNative);\n\t\t\tslot = fxNextSlotProperty(the, slot, the->stack, XS_NO_ID, XS_NO_FLAG);\n\t\t\tstring = fxToString(the, slot);\n\t\t\tslot->kind += XS_KEY_KIND - XS_STRING_KIND;\n\t\t\tslot->value.key.sum = mxStringLength(string);\n\t\t\tsize = fxAddChunkSizes(the, size, slot->value.key.sum);\n\t\t\tmxPop();\n\t\t}\n\t\toffset += delta;\n\t}\n\tmxPop();\n\tstring = mxResult->value.string = fxNewChunk(the, fxAddChunkSizes(the, size, 1));\n\tslot = list->next;\n\twhile (slot) {\n\t\tc_memcpy(string, slot->value.key.string, slot->value.key.sum);\n\t\tstring += slot->value.key.sum;\n\t\tslot = slot->next;\n\t}\n\t*string = 0;\n\tmxResult->kind = XS_STRING_KIND;\n\tmxPop();\n}\n\nvoid fx_TypedArray_prototype_keys(txMachine* the)\n{\n\ttxSlot* instance = fxCheckTypedArrayInstance(the, mxThis);\n\ttxSlot* dispatch = instance->next;\n\ttxSlot* view = dispatch->next;\n\ttxSlot* buffer = view->next;\n\ttxSlot* property;\n\tfxCheckDataViewSize(the, view, buffer, XS_IMMUTABLE);\n\tmxPush(mxArrayIteratorPrototype);\n\tproperty = fxLastProperty(the, fxNewIteratorInstance(the, mxThis, mxID(_Array)));\n\tproperty = fxNextIntegerProperty(the, property, 1, XS_NO_ID, XS_INTERNAL_FLAG);\n\tmxPullSlot(mxResult);\n}\n\nvoid fx_TypedArray_prototype_lastIndexOf(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\tfxInteger(the, mxResult, -1);\n\tif (length) {\n\t\ttxIndex index = (txIndex)fxArgToLastIndex(the, 1, length, length);\n\t\ttxSlot* argument;\n\t\tif (mxArgc > 0)\n\t\t\tmxPushSlot(mxArgv(0));\n\t\telse\n\t\t\tmxPushUndefined();\n\t\targument = the->stack;\n\t\twhile (index > 0) {\n\t\t\tindex--;\n\t\t\tmxPushSlot(mxThis);\n\t\t\tif (fxHasIndex(the, index)) {\n\t\t\t\tmxPushSlot(mxThis);\n\t\t\t\tmxGetIndex(index);\n\t\t\t\tif (fxIsSameSlot(the, the->stack++, argument)) {\n\t\t\t\t\tmxResult->value.integer = index;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmxPop();\n\t}\n}\n\nvoid fx_TypedArray_prototype_length_get(txMachine* the)\n{\n\ttxSlot* instance = fxCheckTypedArrayInstance(the, mxThis);\n\ttxSlot* dispatch = instance->next;\n\ttxSlot* view = dispatch->next;\n\ttxSlot* buffer = view->next;\n\ttxU2 shift = dispatch->value.typedArray.dispatch->shift;\n\tmxResult->kind = XS_INTEGER_KIND;\n\tmxResult->value.integer = fxGetDataViewSize(the, view, buffer) >> shift;\n}\n\nvoid fx_TypedArray_prototype_map(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\ttxSlot* function = fxArgToCallback(the, 0);\n\tfxCreateTypedArraySpecies(the);\n\tmxPushNumber(length);\n\tmxRunCount(1);\n\tmxPullSlot(mxResult);\n\t{\n\t\tmxResultTypedArrayDeclarations;\n\t\ttxU2 shift = resultDispatch->value.typedArray.dispatch->shift;\n\t\ttxInteger index = 0;\n\t\tif (resultLength < length)\n\t\t\tmxTypeError(\"insufficient buffer\");\n\t\twhile (index < length) {\n\t\t\tfxCallTypedArrayItem(the, function, dispatch, view, buffer->value.reference->next, index, C_NULL);\n\t\t\tif (resultBuffer->value.arrayBuffer.address == C_NULL)\n\t\t\t\tmxTypeError(\"detached buffer\");\n\t\t\t(*resultDispatch->value.typedArray.dispatch->coerce)(the, the->stack);\n\t\t\t(*resultDispatch->value.typedArray.dispatch->setter)(the, resultBuffer->value.reference->next, resultView->value.dataView.offset + (index << shift), the->stack, EndianNative);\n\t\t\tmxPop();\n\t\t\tindex++;\n\t\t}\n\t}\n}\n\nvoid fx_TypedArray_prototype_reduce(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\ttxSlot* function = fxArgToCallback(the, 0);\n\ttxInteger index = 0;\n\tif (mxArgc > 1)\n\t\t*mxResult = *mxArgv(1);\n\telse if (index < length) {\n\t\t(*dispatch->value.typedArray.dispatch->getter)(the, buffer->value.reference->next, view->value.dataView.offset, mxResult, EndianNative);\n\t\tindex++;\n\t}\n\telse\n\t\tmxTypeError(\"no initial value\");\n\twhile (index < length) {\n\t\tfxReduceTypedArrayItem(the, function, dispatch, view, buffer->value.reference->next, index);\n\t\tindex++;\n\t}\n}\n\nvoid fx_TypedArray_prototype_reduceRight(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\ttxInteger delta = dispatch->value.typedArray.dispatch->size;\n\ttxSlot* function = fxArgToCallback(the, 0);\n\ttxInteger index = length - 1;\n\tif (mxArgc > 1)\n\t\t*mxResult = *mxArgv(1);\n\telse if (index >= 0) {\n\t\t(*dispatch->value.typedArray.dispatch->getter)(the, buffer->value.reference->next, view->value.dataView.offset + (index * delta), mxResult, EndianNative);\n\t\tindex--;\n\t}\n\telse\n\t\tmxTypeError(\"no initial value\");\n\twhile (index >= 0) {\n\t\tfxReduceTypedArrayItem(the, function, dispatch, view, buffer->value.reference->next, index);\n\t\tindex--;\n\t}\n}\n\nvoid fx_TypedArray_prototype_reverse(txMachine* the)\n{\n\tmxMutableTypedArrayDeclarations;\n\ttxInteger delta = dispatch->value.typedArray.dispatch->size;\n\tif (length) {\n\t\ttxByte tmp;\n\t\ttxByte* first = buffer->value.reference->next->value.arrayBuffer.address + view->value.dataView.offset;\n\t\ttxByte* last = first + (length << dispatch->value.typedArray.dispatch->shift) - delta;\n\t\ttxInteger offset;\n\t\twhile (first < last) {\n\t\t\tfor (offset = 0; offset < delta; offset++) {\n\t\t\t\ttmp = last[offset];\n\t\t\t\tlast[offset] = first[offset];\n\t\t\t\tfirst[offset] = tmp;\n\t\t\t}\n\t\t\tfirst += delta;\n\t\t\tlast -= delta;\n\t\t}\n\t\tmxMeterSome(length * 4);\n\t}\n\tmxResult->kind = mxThis->kind;\n\tmxResult->value = mxThis->value;\n}\n\nvoid fx_TypedArray_prototype_set(txMachine* the)\n{\n\tmxMutableTypedArrayDeclarations;\n\ttxSlot* data = buffer->value.reference->next;\n\ttxInteger delta = dispatch->value.typedArray.dispatch->size;\n\ttxSlot* source = fxArgToInstance(the, 0);\n\ttxInteger target = fxArgToByteLength(the, 1, 0);\n\ttxInteger offset = view->value.dataView.offset + (target * delta);\t\n\tif (source->next && (source->next->kind == XS_TYPED_ARRAY_KIND)) {\n\t\ttxSlot* sourceDispatch = source->next;\n\t\ttxSlot* sourceView = sourceDispatch->next;\n\t\ttxSlot* sourceBuffer = sourceView->next;\n\t\ttxU2 shift = sourceDispatch->value.typedArray.dispatch->shift;\n\t\ttxInteger sourceLength = fxCheckDataViewSize(the, sourceView, sourceBuffer, XS_IMMUTABLE) >> shift;\n\t\ttxInteger sourceOffset = sourceView->value.dataView.offset;\t\n\t\ttxSlot* sourceData = sourceBuffer->value.reference->next;\n\t\ttxInteger limit = offset + (sourceLength * delta);\n\t\tif ((target < 0) || (length - sourceLength < target))\n\t\t\tmxRangeError(\"invalid offset\");\n\t\tif (data == sourceData) {\n\t\t\ttxSlot* resultBuffer;\n\t\t\tmxPush(mxArrayBufferConstructor);\n\t\t\tmxNew();\n\t\t\tmxPushInteger(sourceLength << shift);\n\t\t\tmxRunCount(1);\n\t\t\tresultBuffer = the->stack->value.reference->next;\n\t\t\tc_memcpy(resultBuffer->value.arrayBuffer.address, sourceData->value.arrayBuffer.address + sourceOffset, sourceLength << shift);\n\t\t\tsourceData = resultBuffer;\n\t\t\tsourceOffset = 0;\n\t\t}\n\t\telse \n\t\t\tmxPushUndefined();\n\t\tif (dispatch == sourceDispatch) {\n\t\t\tc_memcpy(data->value.arrayBuffer.address + offset, sourceData->value.arrayBuffer.address + sourceOffset, limit - offset);\n\t\t\tmxMeterSome(((txU4)(limit - offset)) * 2);\n\t\t}\n\t\telse {\n\t\t\ttxInteger sourceDelta = 1 << shift;\n\t\t\tmxPushUndefined();\n\t\t\twhile (offset < limit) {\n\t\t\t\t(*sourceDispatch->value.typedArray.dispatch->getter)(the, sourceData, sourceOffset, the->stack, EndianNative);\n\t\t\t\t(*dispatch->value.typedArray.dispatch->coerce)(the, the->stack);\n                if (data->value.arrayBuffer.address == C_NULL)\n                    mxTypeError(\"detached buffer\");\n\t\t\t\t(*dispatch->value.typedArray.dispatch->setter)(the, data, offset, the->stack, EndianNative);\n\t\t\t\tsourceOffset += sourceDelta;\n\t\t\t\toffset += delta;\n\t\t\t}\n\t\t\tmxPop();\n\t\t}\n\t\tmxPop();\n\t}\n\telse {\n\t\ttxInteger count, index;\n\t\tmxPushSlot(mxArgv(0));\n\t\tmxGetID(mxID(_length));\n\t\tcount = fxToInteger(the, the->stack);\n\t\tmxPop();\n\t\tif ((target < 0) || (length - count < target))\n\t\t\tmxRangeError(\"invalid offset\");\n\t\tindex = 0;\n\t\twhile (index < count) {\n\t\t\tmxPushSlot(mxArgv(0));\n\t\t\tmxGetIndex(index);\n\t\t\t(*dispatch->value.typedArray.dispatch->coerce)(the, the->stack);\n\t\t\tif (data->value.arrayBuffer.address == C_NULL)\n\t\t\t\tmxTypeError(\"detached buffer\");\n\t\t\t(*dispatch->value.typedArray.dispatch->setter)(the, data, offset, the->stack, EndianNative);\n\t\t\tmxPop();\n\t\t\toffset += delta;\n\t\t\tindex++;\n\t\t}\t\n\t}\n}\n\nvoid fx_TypedArray_prototype_slice(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\ttxInteger delta = dispatch->value.typedArray.dispatch->size;\n\ttxInteger start = (txInteger)fxArgToIndex(the, 0, 0, length);\n\ttxInteger end = (txInteger)fxArgToIndex(the, 1, length, length);\n\ttxInteger count = (end > start) ? end - start : 0;\n\ttxInteger index = 0;\n\tfxCreateTypedArraySpecies(the);\n\tmxPushNumber(count);\n\tmxRunCount(1);\n\tmxPullSlot(mxResult);\n\t{\n\t\tmxResultTypedArrayDeclarations;\n\t\tif (resultLength < count)\n\t\t\tmxTypeError(\"insufficient buffer\");\n\t\tif (count) {\n\t\t\tlength = fxCheckDataViewSize(the, view, buffer, XS_IMMUTABLE);\n\t\t\tmxPushUndefined();\n\t\t\twhile ((start < length) && (start < end)) {\n\t\t\t\t(*dispatch->value.typedArray.dispatch->getter)(the, buffer->value.reference->next, view->value.dataView.offset + (start * delta), the->stack, EndianNative);\n\t\t\t\t(*resultDispatch->value.typedArray.dispatch->coerce)(the, the->stack);\n\t\t\t\t(*resultDispatch->value.typedArray.dispatch->setter)(the, resultBuffer->value.reference->next, resultView->value.dataView.offset + (index << resultDispatch->value.typedArray.dispatch->shift), the->stack, EndianNative);\n\t\t\t\tstart++;\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\twhile (start < end) {\n\t\t\t\tthe->stack->kind = XS_UNDEFINED_KIND;\n\t\t\t\t(*resultDispatch->value.typedArray.dispatch->coerce)(the, the->stack);\n\t\t\t\t(*resultDispatch->value.typedArray.dispatch->setter)(the, resultBuffer->value.reference->next, resultView->value.dataView.offset + (index << resultDispatch->value.typedArray.dispatch->shift), the->stack, EndianNative);\n\t\t\t\tstart++;\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\tmxPop();\n\t\t}\n\t}\n}\n\nvoid fx_TypedArray_prototype_some(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\ttxSlot* function = fxArgToCallback(the, 0);\n\ttxInteger index = 0;\n\tmxResult->kind = XS_BOOLEAN_KIND;\n\tmxResult->value.boolean = 0;\n\twhile (index < length) {\n\t\tfxCallTypedArrayItem(the, function, dispatch, view, buffer->value.reference->next, index, C_NULL);\n\t\tmxResult->value.boolean = fxToBoolean(the, the->stack++);\n\t\tif (mxResult->value.boolean)\n\t\t\tbreak;\n\t\tindex++;\n\t}\n}\n\nvoid fx_TypedArray_prototype_sort(txMachine* the)\n{\n\tmxMutableTypedArrayDeclarations;\n\ttxSlot* data = buffer->value.reference->next;\n\ttxInteger delta = dispatch->value.typedArray.dispatch->size;\n\ttxSlot* function = C_NULL;\n\tif (mxArgc > 0) {\n\t\ttxSlot* slot = mxArgv(0);\n\t\tif (slot->kind != XS_UNDEFINED_KIND) {\n\t\t\tif (fxIsCallable(the, slot))\n\t\t\t\tfunction = slot;\n\t\t\telse\n\t\t\t\tmxTypeError(\"compare is no function\");\n\t\t}\n\t}\n\tif (function) {\n\t\t/* like GCC qsort */\n\t\t#define COMPARE(INDEX) \\\n\t\t\tfxCompareTypedArrayItem(the, function, dispatch, view, data, INDEX)\n\t\t#define MOVE(FROM,TO) \\\n\t\t\tfrom = data->value.arrayBuffer.address + view->value.dataView.offset + ((FROM) * delta); \\\n\t\t\tto = data->value.arrayBuffer.address + view->value.dataView.offset + ((TO) * delta); \\\n\t\t\tfor (k = 0; k < delta; k++) *to++ = *from++\n\t\t#define PUSH(INDEX) \\\n\t\t\tmxPushUndefined(); \\\n\t\t\t(*dispatch->value.typedArray.dispatch->getter)(the, data, view->value.dataView.offset + ((INDEX) * delta), the->stack, EndianNative)\n\t\t#define PULL(INDEX) \\\n\t\t\t(*dispatch->value.typedArray.dispatch->setter)(the, data, view->value.dataView.offset + ((INDEX) * delta), the->stack++, EndianNative)\n\t\tif (length > 0) {\n\t\t\ttxInteger i, j, k;\n\t\t\ttxByte* from;\n\t\t\ttxByte* to;\n\t\t\tif (length > mxSortThreshold) {\n\t\t\t\ttxInteger lo = 0, hi = length - 1;\n\t\t\t\ttxSortPartition stack[mxSortPartitionCount];\n\t\t\t\ttxSortPartition *top = stack + 1;\n\t\t\t\twhile (stack < top) {\n\t\t\t\t\ttxIndex mid = lo + ((hi - lo) >> 1);\n\t\t\t\t\tPUSH(mid);\n\t\t\t\t\tif (COMPARE(lo) > 0) {\n\t\t\t\t\t\tMOVE(lo, mid);\n\t\t\t\t\t\tPULL(lo);\n\t\t\t\t\t\tPUSH(mid);\n\t\t\t\t\t}\n\t\t\t\t\tif (COMPARE(hi) < 0) {\n\t\t\t\t\t\tMOVE(hi, mid);\n\t\t\t\t\t\tPULL(hi);\n\t\t\t\t\t\tPUSH(mid);\n\t\t\t\t\t\tif (COMPARE(lo) > 0) {\n\t\t\t\t\t\t\tMOVE(lo, mid);\n\t\t\t\t\t\t\tPULL(lo);\n\t\t\t\t\t\t\tPUSH(mid);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti = lo + 1;\n\t\t\t\t\tj = hi - 1;\n\t\t\t\t\tdo {\n\t\t\t\t\t\twhile ((COMPARE(i) < 0) && (i <= j)) i++;\n\t\t\t\t\t\twhile ((COMPARE(j) > 0) && (i <= j)) j--;\n\t\t\t\t\t\tif (i < j) {\n\t\t\t\t\t\t\tPUSH(i);\n\t\t\t\t\t\t\tMOVE(j, i);\n\t\t\t\t\t\t\tPULL(j);\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\tj--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (i == j) {\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\tj--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (i <= j);\n\t\t\t\t\tif ((j - lo) <= mxSortThreshold) {\n\t\t\t\t\t\tif ((hi - i) <= mxSortThreshold) {\n\t\t\t\t\t\t\ttop--;\n\t\t\t\t\t\t\tlo = top->lo; \n\t\t\t\t\t\t\thi = top->hi;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlo = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ((hi - i) <= mxSortThreshold) {\n\t\t\t\t\t\thi = j;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((j - lo) > (hi - i)) {\n\t\t\t\t\t\ttop->lo = lo;\n\t\t\t\t\t\ttop->hi = j; \n\t\t\t\t\t\ttop++;\n\t\t\t\t\t\tlo = i;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttop->lo = i;\n\t\t\t\t\t\ttop->hi = hi; \n\t\t\t\t\t\ttop++;\n\t\t\t\t\t\thi = j;\n\t\t\t\t\t}\n\t\t\t\t\tmxPop();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 1; i < length; i++) {\n\t\t\t\tPUSH(i);\n\t\t\t\tfor (j = i; (j > 0) && (COMPARE(j - 1) > 0); j--) {\n\t\t\t\t\tMOVE(j - 1, j);\n\t\t\t\t}\t\n\t\t\t\tPULL(j);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\tc_qsort(data->value.arrayBuffer.address, length, delta, dispatch->value.typedArray.dispatch->compare);\n\tmxResult->kind = mxThis->kind;\n\tmxResult->value = mxThis->value;\n}\n\nvoid fx_TypedArray_prototype_subarray(txMachine* the)\n{\n\ttxSlot* instance = fxCheckTypedArrayInstance(the, mxThis);\n\ttxSlot* dispatch = instance->next;\n\ttxSlot* view = dispatch->next;\n\ttxSlot* buffer = view->next;\n\ttxU2 shift = dispatch->value.typedArray.dispatch->shift;\n\ttxInteger length = fxGetDataViewSize(the, view, buffer) >> shift;\n\ttxInteger start = (txInteger)fxArgToIndex(the, 0, 0, length);\n\ttxInteger stop = (txInteger)fxArgToIndex(the, 1, length, length);\n\tif (stop < start) \n\t\tstop = start;\n\tfxCreateTypedArraySpecies(the);\n\tmxPushSlot(buffer);\n\tmxPushInteger(view->value.dataView.offset + (start << shift));\n\tmxPushInteger(stop - start);\n\tmxRunCount(3);\n\tmxPullSlot(mxResult);\n\tfxCheckTypedArrayInstance(the, mxResult);\n}\n\nvoid fx_TypedArray_prototype_toLocaleString(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\ttxInteger index = 0;\n\ttxString string;\n\ttxSlot* list = fxNewInstance(the);\n\ttxSlot* slot = list;\n\ttxBoolean comma = 0;\n\ttxInteger size = 0;\n\tmxPushStringX(\",\");\n\tthe->stack->kind += XS_KEY_KIND - XS_STRING_KIND;\n\tthe->stack->value.key.sum = 1;\n\twhile (index < length) {\n\t\tif (comma) {\n\t\t\tslot = fxNextSlotProperty(the, slot, the->stack, XS_NO_ID, XS_NO_FLAG);\n\t\t\tsize += slot->value.key.sum;\n\t\t}\n\t\telse\n\t\t\tcomma = 1;\n\t\tmxPushSlot(mxThis);\n\t\tmxGetIndex(index);\n\t\tif ((the->stack->kind != XS_UNDEFINED_KIND) && (the->stack->kind != XS_NULL_KIND)) {\n\t\t\tmxDub();\n\t\t\tmxGetID(mxID(_toLocaleString));\n\t\t\tmxCall();\n\t\t\tmxRunCount(0);\n\t\t\tslot = fxNextSlotProperty(the, slot, the->stack, XS_NO_ID, XS_NO_FLAG);\n\t\t\tstring = fxToString(the, slot);\n\t\t\tslot->kind += XS_KEY_KIND - XS_STRING_KIND;\n\t\t\tslot->value.key.sum = mxStringLength(string);\n\t\t\tsize = fxAddChunkSizes(the, size, slot->value.key.sum);\n\t\t}\n\t\tmxPop();\n\t\tindex++;\n\t}\n\tstring = mxResult->value.string = fxNewChunk(the, fxAddChunkSizes(the, size, 1));\n\tslot = list->next;\n\twhile (slot) {\n\t\tc_memcpy(string, slot->value.key.string, slot->value.key.sum);\n\t\tstring += slot->value.key.sum;\n\t\tslot = slot->next;\n\t}\n\t*string = 0;\n\tmxResult->kind = XS_STRING_KIND;\n\tmxPop();\n}\n\nvoid fx_TypedArray_prototype_toStringTag_get(txMachine* the)\n{\n\tif (mxThis->kind == XS_REFERENCE_KIND) {\n        txSlot* instance = mxThis->value.reference;\n        txSlot* slot = instance->next;\n\t\tif (slot && (slot->flag & XS_INTERNAL_FLAG) && (slot->kind == XS_TYPED_ARRAY_KIND)) {\n\t\t\ttxTypeDispatch *dispatch = instance->next->value.typedArray.dispatch;\n\t\t\ttxSlot* key = fxGetKey(the, mxID(dispatch->constructorID));\n\t\t\tif (key->kind == XS_KEY_X_KIND)\n\t\t\t\tmxResult->kind = XS_STRING_X_KIND;\n\t\t\telse\n\t\t\t\tmxResult->kind = XS_STRING_KIND;\n\t\t\tmxResult->value.string = key->value.key.string;\n\t\t}\n\t}\n}\n\nvoid fx_TypedArray_prototype_values(txMachine* the)\n{\n\ttxSlot* instance = fxCheckTypedArrayInstance(the, mxThis);\n\ttxSlot* dispatch = instance->next;\n\ttxSlot* view = dispatch->next;\n\ttxSlot* buffer = view->next;\n\ttxSlot* property;\n\tfxCheckDataViewSize(the, view, buffer, XS_IMMUTABLE);\n\tmxPush(mxArrayIteratorPrototype);\n\tproperty = fxLastProperty(the, fxNewIteratorInstance(the, mxThis, mxID(_Array)));\n\tproperty = fxNextIntegerProperty(the, property, 0, XS_NO_ID, XS_INTERNAL_FLAG);\n\tmxPullSlot(mxResult);\n}\n\n#if mxBigEndian\n\t#define mxEndianDouble_BtoN(a) (a)\n\t#define mxEndianFloat_BtoN(a) (a)\n\t#define mxEndianS64_BtoN(a) (a)\n\t#define mxEndianU64_BtoN(a) (a)\n\t#define mxEndianS32_BtoN(a) (a)\n\t#define mxEndianU32_BtoN(a) (a)\n\t#define mxEndianS16_BtoN(a) (a)\n\t#define mxEndianU16_BtoN(a) (a)\n\n\t#define mxEndianDouble_NtoB(a) (a)\n\t#define mxEndianFloat_NtoB(a) (a)\n\t#define mxEndianS64_NtoB(a) (a)\n\t#define mxEndianU64_NtoB(a) (a)\n\t#define mxEndianS32_NtoB(a) (a)\n\t#define mxEndianU32_NtoB(a) (a)\n\t#define mxEndianS16_NtoB(a) (a)\n\t#define mxEndianU16_NtoB(a) (a)\n#else\n\t#define mxEndianDouble_LtoN(a) (a)\n\t#define mxEndianFloat_LtoN(a) (a)\n\t#define mxEndianS64_LtoN(a) (a)\n\t#define mxEndianU64_LtoN(a) (a)\n\t#define mxEndianS32_LtoN(a) (a)\n\t#define mxEndianU32_LtoN(a) (a)\n\t#define mxEndianS16_LtoN(a) (a)\n\t#define mxEndianU16_LtoN(a) (a)\n\n\t#define mxEndianDouble_NtoL(a) (a)\n\t#define mxEndianFloat_NtoL(a) (a)\n\t#define mxEndianS64_NtoL(a) (a)\n\t#define mxEndianU64_NtoL(a) (a)\n\t#define mxEndianS32_NtoL(a) (a)\n\t#define mxEndianU32_NtoL(a) (a)\n\t#define mxEndianS16_NtoL(a) (a)\n\t#define mxEndianU16_NtoL(a) (a)\n#endif\n\n#if mxLittleEndian\n\t#define mxEndianDouble_BtoN(a) (mxEndianDouble_Swap(a))\n\t#define mxEndianFloat_BtoN(a) (mxEndianFloat_Swap(a))\n\t#define mxEndianS64_BtoN(a) ((txS8) mxEndian64_Swap(a))\n\t#define mxEndianU64_BtoN(a) ((txU8) mxEndian64_Swap(a))\n\t#define mxEndianS32_BtoN(a) ((txS4) mxEndian32_Swap(a))\n\t#define mxEndianU32_BtoN(a) ((txU4) mxEndian32_Swap(a))\n\t#define mxEndianS16_BtoN(a) ((txS2) mxEndian16_Swap(a))\n\t#define mxEndianU16_BtoN(a) ((txU2) mxEndian16_Swap(a))\n\n\t#define mxEndianDouble_NtoB(a) (mxEndianDouble_Swap(a))\n\t#define mxEndianFloat_NtoB(a) (mxEndianFloat_Swap(a))\n\t#define mxEndianS64_NtoB(a) ((txS8) mxEndian64_Swap(a))\n\t#define mxEndianU64_NtoB(a) ((txU8) mxEndian64_Swap(a))\n\t#define mxEndianS32_NtoB(a) ((txS4) mxEndian32_Swap(a))\n\t#define mxEndianU32_NtoB(a) ((txU4) mxEndian32_Swap(a))\n\t#define mxEndianS16_NtoB(a) ((txS2) mxEndian16_Swap(a))\n\t#define mxEndianU16_NtoB(a) ((txU2) mxEndian16_Swap(a))\n#else\n\t#define mxEndianDouble_LtoN(a) (mxEndianDouble_Swap(a))\n\t#define mxEndianFloat_LtoN(a) (mxEndianFloat_Swap(a))\n\t#define mxEndianS64_LtoN(a) ((txS8) mxEndian64_Swap(a))\n\t#define mxEndianU64_LtoN(a) ((txU8) mxEndian64_Swap(a))\n\t#define mxEndianS32_LtoN(a) ((txS4) mxEndian32_Swap(a))\n\t#define mxEndianU32_LtoN(a) ((txU4) mxEndian32_Swap(a))\n\t#define mxEndianS16_LtoN(a) ((txS2) mxEndian16_Swap(a))\n\t#define mxEndianU16_LtoN(a) ((txU2) mxEndian16_Swap(a))\n\n\t#define mxEndianDouble_NtoL(a) (mxEndianDouble_Swap(a))\n\t#define mxEndianFloat_NtoL(a) (mxEndianFloat_Swap(a))\n\t#define mxEndianS64_NtoL(a) ((txS8) mxEndian64_Swap(a))\n\t#define mxEndianU64_NtoL(a) ((txU8) mxEndian64_Swap(a))\n\t#define mxEndianS32_NtoL(a) ((txS4) mxEndian32_Swap(a))\n\t#define mxEndianU32_NtoL(a) ((txU4) mxEndian32_Swap(a))\n\t#define mxEndianS16_NtoL(a) ((txS2) mxEndian16_Swap(a))\n\t#define mxEndianU16_NtoL(a) ((txU2) mxEndian16_Swap(a))\n#endif\n\n#if defined(__GNUC__) || defined(__llvm__)\n\t#define mxEndian16_Swap(a) __builtin_bswap16(a)\n#else\n\tstatic txU2 mxEndian16_Swap(txU2 a)\n\t{\n\t\ttxU2 b;\n\t\ttxU1 *p1 = (txU1 *) &a, *p2 = (txU1 *) &b;\n\t\tint i;\n\t\tfor (i = 0; i < 2; i++)\n\t\t\tp2[i] = p1[1 - i];\n\t\treturn b;\n\t}\n#endif\n\n#if defined(__GNUC__) || defined(__llvm__)\n\t#define mxEndian32_Swap(a) __builtin_bswap32(a)\n#else\n\tstatic txU4 mxEndian32_Swap(txU4 a)\n\t{\n\t\ttxU4 b;\n\t\ttxU1 *p1 = (txU1 *) &a, *p2 = (txU1 *) &b;\n\t\tint i;\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tp2[i] = p1[3 - i];\n\t\treturn b;\n\t}\n#endif\n\n#if defined(__GNUC__) || defined(__llvm__)\n\t#define mxEndian64_Swap(a) __builtin_bswap64(a)\n#else\n\tstatic txU8 mxEndian64_Swap(txU8 a)\n\t{\n\t\ttxU4 b;\n\t\ttxU1 *p1 = (txU1 *) &a, *p2 = (txU1 *) &b;\n\t\tint i;\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tp2[i] = p1[7 - i];\n\t\treturn b;\n\t}\n#endif\n\nstatic float mxEndianFloat_Swap(float a)\n{\n#if defined(__GNUC__) || defined(__llvm__)\n\tuint32_t result = __builtin_bswap32(*(uint32_t *)&a);\n\treturn *(float *)&result;\n#else\n\tfloat b;\n\ttxU1 *p1 = (txU1 *) &a, *p2 = (txU1 *) &b;\n\tint i;\n\tfor (i = 0; i < 4; i++)\n\t\tp2[i] = p1[3 - i];\n\treturn b;\n#endif\n}\n\nstatic double mxEndianDouble_Swap(double a)\n{\n#if defined(__GNUC__) || defined(__llvm__)\n\tuint64_t result = __builtin_bswap64(*(uint64_t *)&a);\n\treturn *(double *)&result;\n#else\n\tdouble b;\n\ttxU1 *p1 = (txU1 *) &a, *p2 = (txU1 *) &b;\n\tint i;\n\tfor (i = 0; i < 8; i++)\n\t\tp2[i] = p1[7 - i];\n\treturn b;\n#endif\n}\n\n#define toNative(size, endian) mxEndian##size##_##endian##toN\n#define fromNative(size, endian) mxEndian##size##_Nto##endian\n#define IMPORT(size) (endian == EndianBig ? toNative(size, B)(value) : endian == EndianLittle ? toNative(size, L)(value) : (value))\n#define EXPORT(size) (endian == EndianBig ? fromNative(size, B)(value) : endian == EndianLittle ? toNative(size, L)(value) : (value))\n\nint fxBigInt64Compare(const void* p, const void* q)\n{\n\ttxS8 a = *((txS8*)p);\n\ttxS8 b = *((txS8*)q);\n\treturn (a < b) ? -1 : (a > b) ? 1 : 0;\n}\n\nvoid fxBigInt64Getter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\ttxS8 value;\n#ifdef mxMisalignedSettersCrash\n\tvalue = c_read32(data->value.arrayBuffer.address + offset);\n#else\n\tvalue = *((txS8*)(data->value.arrayBuffer.address + offset));\n#endif\n\tvalue = IMPORT(S64);\n\tfxFromBigInt64(the, slot, value);\n\tmxMeterOne();\n}\n\nvoid fxBigInt64Setter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\ttxS8 value = (txS8)fxToBigInt64(the, slot);\n#ifdef mxMisalignedSettersCrash\n\tvalue = EXPORT(S64);\n\tc_memcpy(data->value.arrayBuffer.address + offset, &value, sizeof(txS8));\n#else\n\t*((txS8*)(data->value.arrayBuffer.address + offset)) = EXPORT(S64);\n#endif\n\tmxMeterOne();\n}\n\nint fxBigUint64Compare(const void* p, const void* q)\n{\n\ttxU8 a = *((txU8*)p);\n\ttxU8 b = *((txU8*)q);\n\treturn (a < b) ? -1 : (a > b) ? 1 : 0;\n}\n\nvoid fxBigUint64Getter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\ttxU8 value;\n#ifdef mxMisalignedSettersCrash\n\tvalue = c_read32(data->value.arrayBuffer.address + offset);\n#else\n\tvalue = *((txU8*)(data->value.arrayBuffer.address + offset));\n#endif\n\tvalue = IMPORT(U64);\n\tfxFromBigUint64(the, slot, value);\n\tmxMeterOne();\n}\n\nvoid fxBigUint64Setter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\ttxU8 value = (txU8)fxToBigUint64(the, slot);\n#ifdef mxMisalignedSettersCrash\n\tvalue = EXPORT(U64);\n\tc_memcpy(data->value.arrayBuffer.address + offset, &value, sizeof(txU8));\n#else\n\t*((txU8*)(data->value.arrayBuffer.address + offset)) = EXPORT(U64);\n#endif\n\tmxMeterOne();\n}\n\nint fxFloat32Compare(const void* p, const void* q)\n{\n\tfloat a = *((float*)p);\n\tfloat b = *((float*)q);\n\tif (c_isnan(a)) {\n\t\tif (c_isnan(b)) \n\t\t\treturn 0;\n\t\treturn 1;\n\t}\n\tif (c_isnan(b))\n\t\treturn -1;\n\tif (a < b)\n\t\treturn -1;\n\tif (a > b)\n\t\treturn 1;\n\tif (a == 0) {\n\t\tif (c_signbit(a)) {\n\t\t\tif (c_signbit(b)) \n\t\t\t\treturn 0;\n\t\t\treturn -1;\n\t\t}\n\t\tif (c_signbit(b))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nvoid fxFloat32Getter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\tfloat value;\n\tslot->kind = XS_NUMBER_KIND;\n#ifdef mxMisalignedSettersCrash\n\tc_memcpy(&value, data->value.arrayBuffer.address + offset, sizeof(value));\n#else\n\tvalue = *((float*)(data->value.arrayBuffer.address + offset));\n#endif\n\tslot->value.number = IMPORT(Float);\n\tmxMeterOne();\n}\n\nvoid fxFloat32Setter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\tfloat value = (float)slot->value.number;\n#ifdef mxMisalignedSettersCrash\n\tvalue = EXPORT(Float);\n\tc_memcpy(data->value.arrayBuffer.address + offset, &value, sizeof(float));\n#else\n\t*((float*)(data->value.arrayBuffer.address + offset)) = EXPORT(Float);\n#endif\n\tmxMeterOne();\n}\n\nint fxFloat64Compare(const void* p, const void* q)\n{\n\tdouble a = *((double*)p);\n\tdouble b = *((double*)q);\n\tif (c_isnan(a)) {\n\t\tif (c_isnan(b)) \n\t\t\treturn 0;\n\t\treturn 1;\n\t}\n\tif (c_isnan(b))\n\t\treturn -1;\n\tif (a < b)\n\t\treturn -1;\n\tif (a > b)\n\t\treturn 1;\n\tif (a == 0) {\n\t\tif (c_signbit(a)) {\n\t\t\tif (c_signbit(b)) \n\t\t\t\treturn 0;\n\t\t\treturn -1;\n\t\t}\n\t\tif (c_signbit(b))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nvoid fxFloat64Getter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\tdouble value;\n\tslot->kind = XS_NUMBER_KIND;\n#ifdef mxMisalignedSettersCrash\n\tc_memcpy(&value, data->value.arrayBuffer.address + offset, sizeof(value));\n#else\n\tvalue = *((double*)(data->value.arrayBuffer.address + offset));\n#endif\n\tslot->value.number = IMPORT(Double);\n\tmxMeterOne();\n}\n\nvoid fxFloat64Setter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\tdouble value = slot->value.number;\n#ifdef mxMisalignedSettersCrash\n\tvalue = EXPORT(Double);\n\tc_memcpy(data->value.arrayBuffer.address + offset, &value, sizeof(double));\n#else\n\t*((double*)(data->value.arrayBuffer.address + offset)) = EXPORT(Double);\n#endif\n\tmxMeterOne();\n}\n\nvoid fxIntCoerce(txMachine* the, txSlot* slot)\n{\n\tfxToInteger(the, slot);\n}\n\nvoid fxUintCoerce(txMachine* the, txSlot* slot)\n{\n\tfxToUnsigned(the, slot);\n}\n\nint fxInt8Compare(const void* p, const void* q)\n{\n\ttxS1 a = *((txS1*)p);\n\ttxS1 b = *((txS1*)q);\n\treturn (a < b) ? -1 : (a > b) ? 1 : 0;\n}\n\nvoid fxInt8Getter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\tslot->kind = XS_INTEGER_KIND;\n\tslot->value.integer = *((txS1*)(data->value.arrayBuffer.address + offset));\n\tmxMeterOne();\n}\n\nvoid fxInt8Setter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\t*((txS1*)(data->value.arrayBuffer.address + offset)) = (txS1)slot->value.integer;\n\tmxMeterOne();\n}\n\nint fxInt16Compare(const void* p, const void* q)\n{\n\ttxS2 a = *((txS2*)p);\n\ttxS2 b = *((txS2*)q);\n\treturn (a < b) ? -1 : (a > b) ? 1 : 0;\n}\n\nvoid fxInt16Getter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\ttxS2 value;\n\tslot->kind = XS_INTEGER_KIND;\n#ifdef mxMisalignedSettersCrash\n\tc_memcpy(&value, data->value.arrayBuffer.address + offset, sizeof(value));\n#else\n\tvalue = *((txS2*)(data->value.arrayBuffer.address + offset));\n#endif\n\tslot->value.integer = IMPORT(S16);\n\tmxMeterOne();\n}\n\nvoid fxInt16Setter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\ttxS2 value = (txS2)slot->value.integer;\n#ifdef mxMisalignedSettersCrash\n\tvalue = EXPORT(S16);\n\tc_memcpy(data->value.arrayBuffer.address + offset, &value, sizeof(txS2));\n#else\n\t*((txS2*)(data->value.arrayBuffer.address + offset)) = EXPORT(S16);\n#endif\n\tmxMeterOne();\n}\n\nint fxInt32Compare(const void* p, const void* q)\n{\n\ttxS4 a = *((txS4*)p);\n\ttxS4 b = *((txS4*)q);\n\treturn (a < b) ? -1 : (a > b) ? 1 : 0;\n}\n\nvoid fxInt32Getter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\ttxS4 value;\n\tslot->kind = XS_INTEGER_KIND;\n#ifdef mxMisalignedSettersCrash\n\tvalue = c_read32(data->value.arrayBuffer.address + offset);\n#else\n\tvalue = *((txS4*)(data->value.arrayBuffer.address + offset));\n#endif\n\tslot->value.integer = IMPORT(S32);\n\tmxMeterOne();\n}\n\nvoid fxInt32Setter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\ttxS4 value = (txS4)slot->value.integer;\n#ifdef mxMisalignedSettersCrash\n\tvalue = EXPORT(S32);\n\tc_memcpy(data->value.arrayBuffer.address + offset, &value, sizeof(txS4));\n#else\n\t*((txS4*)(data->value.arrayBuffer.address + offset)) = EXPORT(S32);\n#endif\n\tmxMeterOne();\n}\n\nint fxUint8Compare(const void* p, const void* q)\n{\n\ttxU1 a = c_read8((txU1*)p);\n\ttxU1 b = c_read8((txU1*)q);\n\treturn (a < b) ? -1 : (a > b) ? 1 : 0;\n}\n\nvoid fxUint8Getter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\tslot->kind = XS_INTEGER_KIND;\n\tslot->value.integer = c_read8((txU1*)(data->value.arrayBuffer.address + offset));\n\tmxMeterOne();\n}\n\nvoid fxUint8Setter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\ttxUnsigned tmp = (slot->kind == XS_INTEGER_KIND) ? (txUnsigned)slot->value.integer : (txUnsigned)slot->value.number;\n\t*((txU1*)(data->value.arrayBuffer.address + offset)) = (txU1)tmp;\n\tmxMeterOne();\n}\n\nint fxUint16Compare(const void* p, const void* q)\n{\n\ttxU2 a = *((txU2*)p);\n\ttxU2 b = *((txU2*)q);\n\treturn (a < b) ? -1 : (a > b) ? 1 : 0;\n}\n\nvoid fxUint16Getter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\ttxU2 value;\n\tslot->kind = XS_INTEGER_KIND;\n#ifdef mxMisalignedSettersCrash\n\tc_memcpy(&value, data->value.arrayBuffer.address + offset, sizeof(value));\n#else\n\tvalue = *((txU2*)(data->value.arrayBuffer.address + offset));\n#endif\n\tslot->value.integer = IMPORT(U16);\n\tmxMeterOne();\n}\n\nvoid fxUint16Setter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\ttxUnsigned tmp = (slot->kind == XS_INTEGER_KIND) ? (txUnsigned)slot->value.integer : (txUnsigned)slot->value.number;\n\ttxU2 value = (txU2)tmp;\n#ifdef mxMisalignedSettersCrash\n\tvalue = EXPORT(U16);\n\tc_memcpy(data->value.arrayBuffer.address + offset, &value, sizeof(txU2));\n#else\n\t*((txU2*)(data->value.arrayBuffer.address + offset)) = EXPORT(U16);\n#endif\n\tmxMeterOne();\n}\n\nint fxUint32Compare(const void* p, const void* q)\n{\n\ttxU4 a = *((txU4*)p);\n\ttxU4 b = *((txU4*)q);\n\treturn (a < b) ? -1 : (a > b) ? 1 : 0;\n}\n\nvoid fxUint32Getter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n#ifdef mxMisalignedSettersCrash\n\ttxUnsigned value = c_read32(data->value.arrayBuffer.address + offset);\n#else\n\ttxUnsigned value = *((txU4*)(data->value.arrayBuffer.address + offset));\n#endif\n\tvalue = IMPORT(U32);\n\tif (((txInteger)value) >= 0) {\n\t\tslot->kind = XS_INTEGER_KIND;\n\t\tslot->value.integer = value;\n\t}\n\telse {\n\t\tslot->kind = XS_NUMBER_KIND;\n\t\tslot->value.number = value;\n\t}\n\tmxMeterOne();\n}\n\nvoid fxUint32Setter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\ttxU4 value = (slot->kind == XS_INTEGER_KIND) ? (txU4)slot->value.integer : (txU4)slot->value.number;\n#ifdef mxMisalignedSettersCrash\n\tvalue = EXPORT(U32);\n\tc_memcpy(data->value.arrayBuffer.address + offset, &value, sizeof(txU4));\n#else\n\t*((txU4*)(data->value.arrayBuffer.address + offset)) = EXPORT(U32);\n#endif\n\tmxMeterOne();\n}\n\nvoid fxUint8ClampedSetter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\ttxNumber value = fxToNumber(the, slot);\n\tif (value <= 0)\n\t\tvalue = 0;\n\telse if (value >= 255)\n\t\tvalue = 255;\n\telse if (c_isnan(value))\n\t\tvalue = 0;\n\telse\n\t\tvalue = c_nearbyint(value);\n\t*((txU1*)(data->value.arrayBuffer.address + offset)) = (txU1)value;\n\tmxMeterOne();\n}\n\n"], "fixing_code": ["/*\n * Copyright (c) 2016-2017  Moddable Tech, Inc.\n *\n *   This file is part of the Moddable SDK Runtime.\n * \n *   The Moddable SDK Runtime is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published by\n *   the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n * \n *   The Moddable SDK Runtime is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Lesser General Public License for more details.\n * \n *   You should have received a copy of the GNU Lesser General Public License\n *   along with the Moddable SDK Runtime.  If not, see <http://www.gnu.org/licenses/>.\n *\n * This file incorporates work covered by the following copyright and  \n * permission notice:  \n *\n *       Copyright (C) 2010-2016 Marvell International Ltd.\n *       Copyright (C) 2002-2010 Kinoma, Inc.\n *\n *       Licensed under the Apache License, Version 2.0 (the \"License\");\n *       you may not use this file except in compliance with the License.\n *       You may obtain a copy of the License at\n *\n *        http://www.apache.org/licenses/LICENSE-2.0\n *\n *       Unless required by applicable law or agreed to in writing, software\n *       distributed under the License is distributed on an \"AS IS\" BASIS,\n *       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *       See the License for the specific language governing permissions and\n *       limitations under the License.\n */\n\n#include \"xsAll.h\"\n\nstatic txSlot* fxArgToInstance(txMachine* the, txInteger i);\nstatic txBoolean fxCheckLength(txMachine* the, txSlot* slot, txInteger* index);\n\nstatic txSlot* fxCheckArrayBufferDetached(txMachine* the, txSlot* slot, txBoolean mutable);\nstatic txSlot* fxCheckArrayBufferInstance(txMachine* the, txSlot* slot);\nstatic txSlot* fxNewArrayBufferInstance(txMachine* the);\n\nstatic txSlot* fxCheckDataViewInstance(txMachine* the, txSlot* slot);\nstatic txInteger fxCheckDataViewSize(txMachine* the, txSlot* view, txSlot* buffer, txBoolean mutable);\nstatic txSlot* fxNewDataViewInstance(txMachine* the);\n\nstatic void fxCallTypedArrayItem(txMachine* the, txSlot* function, txSlot* dispatch, txSlot* view, txSlot* data, txInteger index, txSlot* item);\nstatic txSlot* fxCheckTypedArrayInstance(txMachine* the, txSlot* slot);\nstatic int fxCompareTypedArrayItem(txMachine* the, txSlot* function, txSlot* dispatch, txSlot* view, txSlot* data, txInteger index);\nstatic txSlot* fxConstructTypedArray(txMachine* the);\nstatic txSlot* fxNewTypedArrayInstance(txMachine* the, txTypeDispatch* dispatch, txTypeAtomics* atomics);\nstatic void fxReduceTypedArrayItem(txMachine* the, txSlot* function, txSlot* dispatch, txSlot* view, txSlot* data, txInteger index);\n\nstatic txBoolean fxTypedArrayDefineOwnProperty(txMachine* the, txSlot* instance, txID id, txIndex index, txSlot* slot, txFlag mask);\nstatic txBoolean fxTypedArrayDeleteProperty(txMachine* the, txSlot* instance, txID id, txIndex index);\nstatic txBoolean fxTypedArrayGetOwnProperty(txMachine* the, txSlot* instance, txID id, txIndex index, txSlot* slot);\nstatic txSlot* fxTypedArrayGetProperty(txMachine* the, txSlot* instance, txID id, txIndex index, txFlag flag);\nstatic txBoolean fxTypedArrayGetPropertyValue(txMachine* the, txSlot* instance, txID id, txIndex index, txSlot* value, txSlot* receiver);\nstatic txBoolean fxTypedArrayHasProperty(txMachine* the, txSlot* instance, txID id, txIndex index);\nstatic void fxTypedArrayOwnKeys(txMachine* the, txSlot* instance, txFlag flag, txSlot* keys);\nstatic txSlot* fxTypedArraySetProperty(txMachine* the, txSlot* instance, txID id, txIndex index, txFlag flag);\nstatic txBoolean fxTypedArraySetPropertyValue(txMachine* the, txSlot* instance, txID id, txIndex index, txSlot* value, txSlot* receiver);\n\nstatic void fx_TypedArray_from_object(txMachine* the, txSlot* instance, txSlot* function, txSlot* _this);\n\nconst txBehavior ICACHE_FLASH_ATTR gxTypedArrayBehavior = {\n\tfxTypedArrayGetProperty,\n\tfxTypedArraySetProperty,\n\tfxOrdinaryCall,\n\tfxOrdinaryConstruct,\n\tfxTypedArrayDefineOwnProperty,\n\tfxTypedArrayDeleteProperty,\n\tfxTypedArrayGetOwnProperty,\n\tfxTypedArrayGetPropertyValue,\n\tfxOrdinaryGetPrototype,\n\tfxTypedArrayHasProperty,\n\tfxOrdinaryIsExtensible,\n\tfxTypedArrayOwnKeys,\n\tfxOrdinaryPreventExtensions,\n\tfxTypedArraySetPropertyValue,\n\tfxOrdinarySetPrototype,\n};\n\nvoid *fxArrayBuffer(txMachine* the, txSlot* slot, void* data, txInteger byteLength, txInteger maxByteLength)\n{\n\ttxSlot* instance;\n\ttxSlot* arrayBuffer;\n\ttxSlot* bufferInfo;\n\tif (byteLength < 0)\n\t\tmxRangeError(\"invalid byteLength %ld\", byteLength);\n\tmxPush(mxArrayBufferPrototype);\n\tinstance = fxNewArrayBufferInstance(the);\n\tarrayBuffer = instance->next;\n\tarrayBuffer->value.arrayBuffer.address = fxNewChunk(the, byteLength);\n\tbufferInfo = arrayBuffer->next;\n\tbufferInfo->value.bufferInfo.length = byteLength;\n\tbufferInfo->value.bufferInfo.maxLength = maxByteLength;\n\tif (data != NULL)\n\t\tc_memcpy(arrayBuffer->value.arrayBuffer.address, data, byteLength);\n\telse\n\t\tc_memset(arrayBuffer->value.arrayBuffer.address, 0, byteLength);\n\tmxPullSlot(slot);\n\treturn arrayBuffer->value.arrayBuffer.address;\n}\n\nvoid fxGetArrayBufferData(txMachine* the, txSlot* slot, txInteger byteOffset, void* data, txInteger byteLength)\n{\n\ttxSlot* instance = fxCheckArrayBufferInstance(the, slot);\n\ttxSlot* arrayBuffer = instance->next;\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\ttxInteger length = bufferInfo->value.bufferInfo.length;\n\tif ((byteOffset < 0) || (length < byteOffset))\n\t\tmxRangeError(\"out of range byteOffset %ld\", byteOffset);\n\tif ((byteLength < 0) || (length < (byteOffset + byteLength)))\n\t\tmxRangeError(\"out of range byteLength %ld\", byteLength);\n\tc_memcpy(data, arrayBuffer->value.arrayBuffer.address + byteOffset, byteLength);\n}\n\ntxInteger fxGetArrayBufferLength(txMachine* the, txSlot* slot)\n{\n\ttxSlot* instance = fxCheckArrayBufferInstance(the, slot);\n\ttxSlot* arrayBuffer = instance->next;\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\treturn bufferInfo->value.bufferInfo.length;\n}\n\ntxInteger fxGetArrayBufferMaxLength(txMachine* the, txSlot* slot)\n{\n\ttxSlot* instance = fxCheckArrayBufferInstance(the, slot);\n\ttxSlot* arrayBuffer = instance->next;\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\treturn bufferInfo->value.bufferInfo.maxLength;\n}\n\nvoid fxSetArrayBufferData(txMachine* the, txSlot* slot, txInteger byteOffset, void* data, txInteger byteLength)\n{\n\ttxSlot* instance = fxCheckArrayBufferInstance(the, slot);\n\ttxSlot* arrayBuffer = instance->next;\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\ttxInteger length = bufferInfo->value.bufferInfo.length;\n\tif ((byteOffset < 0) || (length < byteOffset))\n\t\tmxRangeError(\"out of range byteOffset %ld\", byteOffset);\n\tif ((byteLength < 0) || (length < (byteOffset + byteLength)))\n\t\tmxRangeError(\"out of range byteLength %ld\", byteLength);\n\tc_memcpy(arrayBuffer->value.arrayBuffer.address + byteOffset, data, byteLength);\n}\n\nvoid fxSetArrayBufferLength(txMachine* the, txSlot* slot, txInteger target)\n{\n\ttxSlot* instance = fxCheckArrayBufferInstance(the, slot);\n\ttxSlot* arrayBuffer = instance->next;\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\ttxInteger length = bufferInfo->value.bufferInfo.length;\n\ttxByte* address = arrayBuffer->value.arrayBuffer.address;\n\tif (bufferInfo->value.bufferInfo.maxLength < 0)\n\t\tfxReport(the, \"# Use xsArrayBufferResizable instead of xsArrayBuffer\\n\");\n\tif (length != target) {\n\t\tif (address)\n\t\t\taddress = (txByte*)fxRenewChunk(the, address, target);\n\t\tif (address) {\n\t\t\tif (length < target)\n\t\t\t\tc_memset(address + length, 0, target - length);\n\t\t}\n\t\telse {\n\t\t\taddress = (txByte*)fxNewChunk(the, target);\n\t\t\tif (length < target) {\n\t\t\t\tc_memcpy(address, arrayBuffer->value.arrayBuffer.address, length);\n\t\t\t\tc_memset(address + length, 0, target - length);\n\t\t\t}\n\t\t\telse\n\t\t\t\tc_memcpy(address, arrayBuffer->value.arrayBuffer.address, target);\n\t\t}\n\t\tarrayBuffer->value.arrayBuffer.address = address;\n\t\tbufferInfo->value.bufferInfo.length = target;\n\t}\n}\n\nvoid* fxToArrayBuffer(txMachine* the, txSlot* slot)\n{\n\ttxSlot* instance = fxCheckArrayBufferInstance(the, slot);\n\ttxSlot* arrayBuffer = instance->next;\n\treturn arrayBuffer->value.arrayBuffer.address;\n}\n\nvoid fxBuildDataView(txMachine* the)\n{\n    txSlot* slot;\n\ttxInteger index;\n\tconst txTypeDispatch *dispatch;\n\tconst txTypeAtomics *atomics;\n\ttxSlot* property;\n    txSlot* constructor;\n\t\n\tmxPush(mxObjectPrototype);\n\tslot = fxLastProperty(the, fxNewObjectInstance(the));\n\tslot = fxNextHostAccessorProperty(the, slot, mxCallback(fx_ArrayBuffer_prototype_get_byteLength), C_NULL, mxID(_byteLength), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostAccessorProperty(the, slot, mxCallback(fx_ArrayBuffer_prototype_get_maxByteLength), C_NULL, mxID(_maxByteLength), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostAccessorProperty(the, slot, mxCallback(fx_ArrayBuffer_prototype_get_resizable), C_NULL, mxID(_resizable), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_ArrayBuffer_prototype_concat), 1, mxID(_concat), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_ArrayBuffer_prototype_resize), 1, mxID(_resize), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_ArrayBuffer_prototype_slice), 2, mxID(_slice), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_ArrayBuffer_prototype_transfer), 0, mxID(_transfer), XS_DONT_ENUM_FLAG);\n\tslot = fxNextStringXProperty(the, slot, \"ArrayBuffer\", mxID(_Symbol_toStringTag), XS_DONT_ENUM_FLAG | XS_DONT_SET_FLAG);\n\tmxArrayBufferPrototype = *the->stack;\n\tslot = fxBuildHostConstructor(the, mxCallback(fx_ArrayBuffer), 1, mxID(_ArrayBuffer));\n\tmxArrayBufferConstructor = *the->stack;\n\tslot = fxLastProperty(the, slot);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_ArrayBuffer_fromBigInt), 1, mxID(_fromBigInt), XS_DONT_ENUM_FLAG);\n#ifndef mxCESU8\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_ArrayBuffer_fromString), 1, mxID(_fromString), XS_DONT_ENUM_FLAG);\n#endif\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_ArrayBuffer_isView), 1, mxID(_isView), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostAccessorProperty(the, slot, mxCallback(fx_species_get), C_NULL, mxID(_Symbol_species), XS_DONT_ENUM_FLAG);\n\tmxPop();\n\t\n\tmxPush(mxObjectPrototype);\n\tslot = fxLastProperty(the, fxNewObjectInstance(the));\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_getBigInt64), 1, mxID(_getBigInt64), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_setBigInt64), 2, mxID(_setBigInt64), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_getBigUint64), 1, mxID(_getBigUint64), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_setBigUint64), 2, mxID(_setBigUint64), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_getFloat32), 1, mxID(_getFloat32), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_setFloat32), 2, mxID(_setFloat32), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_getFloat64), 1, mxID(_getFloat64), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_setFloat64), 2, mxID(_setFloat64), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_getInt8), 1, mxID(_getInt8), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_setInt8), 2, mxID(_setInt8), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_getInt16), 1, mxID(_getInt16), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_setInt16), 2, mxID(_setInt16), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_getInt32), 1, mxID(_getInt32), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_setInt32), 2, mxID(_setInt32), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_getUint8), 1, mxID(_getUint8), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_setUint8), 2, mxID(_setUint8), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_getUint16), 1, mxID(_getUint16), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_setUint16), 2, mxID(_setUint16), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_getUint32), 1, mxID(_getUint32), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_DataView_prototype_setUint32), 2, mxID(_setUint32), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostAccessorProperty(the, slot, mxCallback(fx_DataView_prototype_buffer_get), C_NULL, mxID(_buffer), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostAccessorProperty(the, slot, mxCallback(fx_DataView_prototype_byteLength_get), C_NULL, mxID(_byteLength), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostAccessorProperty(the, slot, mxCallback(fx_DataView_prototype_byteOffset_get), C_NULL, mxID(_byteOffset), XS_DONT_ENUM_FLAG);\n\tslot = fxNextStringXProperty(the, slot, \"DataView\", mxID(_Symbol_toStringTag), XS_DONT_ENUM_FLAG | XS_DONT_SET_FLAG);\n\tmxDataViewPrototype = *the->stack;\n\tslot = fxBuildHostConstructor(the, mxCallback(fx_DataView), 1, mxID(_DataView));\n\tmxDataViewConstructor = *the->stack;\n\tmxPop();\n\t\n\tfxNewHostFunction(the, mxCallback(fxTypedArrayGetter), 0, XS_NO_ID);\n\tfxNewHostFunction(the, mxCallback(fxTypedArraySetter), 1, XS_NO_ID);\n\tmxPushUndefined();\n\tthe->stack->flag = XS_DONT_DELETE_FLAG;\n\tthe->stack->kind = XS_ACCESSOR_KIND;\n\tthe->stack->value.accessor.getter = (the->stack + 2)->value.reference;\n\tthe->stack->value.accessor.setter = (the->stack + 1)->value.reference;\n\tmxPull(mxTypedArrayAccessor);\n\tmxPop();\n\tmxPop();\n\tmxPush(mxObjectPrototype);\n\tslot = fxLastProperty(the, fxNewObjectInstance(the));\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_at), 1, mxID(_at), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostAccessorProperty(the, slot, mxCallback(fx_TypedArray_prototype_buffer_get), C_NULL, mxID(_buffer), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostAccessorProperty(the, slot, mxCallback(fx_TypedArray_prototype_byteLength_get), C_NULL, mxID(_byteLength), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostAccessorProperty(the, slot, mxCallback(fx_TypedArray_prototype_byteOffset_get), C_NULL, mxID(_byteOffset), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostAccessorProperty(the, slot, mxCallback(fx_TypedArray_prototype_length_get), C_NULL, mxID(_length), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostAccessorProperty(the, slot, mxCallback(fx_TypedArray_prototype_toStringTag_get), C_NULL, mxID(_Symbol_toStringTag), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_copyWithin), 2, mxID(_copyWithin), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_entries), 0, mxID(_entries), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_every), 1, mxID(_every), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_fill), 1, mxID(_fill), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_filter), 1, mxID(_filter), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_find), 1, mxID(_find), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_findIndex), 1, mxID(_findIndex), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_findLast), 1, mxID(_findLast), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_findLastIndex), 1, mxID(_findLastIndex), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_forEach), 1, mxID(_forEach), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_includes), 1, mxID(_includes), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_indexOf), 1, mxID(_indexOf), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_join), 1, mxID(_join), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_keys), 0, mxID(_keys), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_lastIndexOf), 1, mxID(_lastIndexOf), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_map), 1, mxID(_map), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_reduce), 1, mxID(_reduce), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_reduceRight), 1, mxID(_reduceRight), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_reverse), 0, mxID(_reverse), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_set), 1, mxID(_set), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_slice), 2, mxID(_slice), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_some), 1, mxID(_some), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_sort), 1, mxID(_sort), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_subarray), 2, mxID(_subarray), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_toLocaleString), 0, mxID(_toLocaleString), XS_DONT_ENUM_FLAG);\n\tproperty = mxBehaviorGetProperty(the, mxArrayPrototype.value.reference, mxID(_toString), 0, XS_OWN);\n\tslot = fxNextSlotProperty(the, slot, property, mxID(_toString), XS_DONT_ENUM_FLAG);\n\tproperty = slot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_prototype_values), 0, mxID(_values), XS_DONT_ENUM_FLAG);\n\tslot = fxNextSlotProperty(the, slot, property, mxID(_Symbol_iterator), XS_DONT_ENUM_FLAG);\n\tmxTypedArrayPrototype = *the->stack;\t\n\tconstructor = fxBuildHostConstructor(the, mxCallback(fx_TypedArray), 0, mxID(_TypedArray));\n\tmxTypedArrayConstructor = *the->stack;\n\tslot = fxLastProperty(the, constructor);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_from), 1, mxID(_from), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostFunctionProperty(the, slot, mxCallback(fx_TypedArray_of), 0, mxID(_of), XS_DONT_ENUM_FLAG);\n\tslot = fxNextHostAccessorProperty(the, slot, mxCallback(fx_species_get), C_NULL, mxID(_Symbol_species), XS_DONT_ENUM_FLAG);\n\tfor (index = 0, dispatch = &gxTypeDispatches[0], atomics = &gxTypeAtomics[0]; index < mxTypeArrayCount; index++, dispatch++, atomics++) {\n\t\tmxPush(mxTypedArrayPrototype);\n\t\tslot = fxLastProperty(the, fxNewObjectInstance(the));\n\t\tslot = fxNextIntegerProperty(the, slot, dispatch->size, mxID(_BYTES_PER_ELEMENT), XS_GET_ONLY);\n\t\tslot = fxBuildHostConstructor(the, mxCallback(fx_TypedArray), 3, mxID(dispatch->constructorID));\n\t\tthe->stackPrototypes[-1 - (txInteger)dispatch->constructorID] = *the->stack; //@@\n\t\tslot->value.instance.prototype = constructor;\n\t\tproperty = mxFunctionInstanceHome(slot);\n\t\tslot = property->next;\n\t\tproperty = fxNextTypeDispatchProperty(the, property, (txTypeDispatch*)dispatch, (txTypeAtomics*)atomics, XS_NO_ID, XS_INTERNAL_FLAG);\n\t\tproperty->next = slot;\n\t\tslot = fxLastProperty(the, slot);\n\t\tslot = fxNextIntegerProperty(the, slot, dispatch->size, mxID(_BYTES_PER_ELEMENT), XS_GET_ONLY);\n\t\tmxPop();\n\t}\n\tmxPop();\n}\n\ntxInteger fxArgToByteLength(txMachine* the, txInteger argi, txInteger length)\n{\n\ttxSlot *arg = mxArgv(argi);\n\tif ((mxArgc > argi) && (arg->kind != XS_UNDEFINED_KIND)) {\n\t\ttxNumber value;\n\t\tif (XS_INTEGER_KIND == arg->kind) {\n\t\t\ttxInteger value = arg->value.integer;\n\t\t\tif (value < 0)\n\t\t\t\tmxRangeError(\"out of range byteLength\");\n\t\t\treturn value;\n\t\t}\n\t\tvalue = c_trunc(fxToNumber(the, arg));\n\t\tif (c_isnan(value))\n\t\t\treturn 0;\n\t\tif ((value < 0) || (0x7FFFFFFF < value))\n\t\t\tmxRangeError(\"out of range byteLength\");\n\t\treturn (txInteger)value;\n\t}\n\treturn length;\n}\n\ntxSlot* fxArgToInstance(txMachine* the, txInteger i)\n{\n\tif (mxArgc > i)\n\t\treturn fxToInstance(the, mxArgv(i));\n\tmxTypeError(\"Cannot coerce undefined to object\");\n\treturn C_NULL;\n}\n\ntxBoolean fxCheckLength(txMachine* the, txSlot* slot, txInteger* index)\n{\n\ttxNumber number = fxToNumber(the, slot);\n\ttxNumber check = c_trunc(number);\n\tif ((number == check) && (0 <= number) && (number <= 0x7FFFFFFF)) {\n\t\t*index = (txInteger)number;\n\t\treturn 1 ;\n\t}\n\treturn 0;\n}\n\ntxSlot* fxCheckArrayBufferDetached(txMachine* the, txSlot* slot, txBoolean mutable)\n{\n\tslot = slot->value.reference->next;\n\tif (slot->value.arrayBuffer.address == C_NULL)\n\t\tmxTypeError(\"detached buffer\");\n\tif (mutable && (slot->flag & XS_DONT_SET_FLAG))\n\t\tmxTypeError(\"ArrayBuffer instance is read-only\");\n\treturn slot;\n}\n\ntxSlot* fxCheckArrayBufferInstance(txMachine* the, txSlot* slot)\n{\n\tif (slot->kind == XS_REFERENCE_KIND) {\n\t\ttxSlot* instance = slot->value.reference;\n\t\tif (((slot = instance->next)) && (slot->flag & XS_INTERNAL_FLAG) && (slot->kind == XS_ARRAY_BUFFER_KIND))\n\t\t\treturn instance;\n\t}\n\tmxTypeError(\"this is no ArrayBuffer instance\");\n\treturn C_NULL;\n}\n\nvoid fxConstructArrayBufferResult(txMachine* the, txSlot* constructor, txInteger length)\n{\n\ttxSlot* instance;\n\tif (constructor)\n\t\tmxPushSlot(constructor);\n\telse {\n\t\tmxPushSlot(mxThis);\n\t\tmxGetID(mxID(_constructor));\n\t}\n\tfxToSpeciesConstructor(the, &mxArrayBufferConstructor);\n\tmxNew();\n\tmxPushInteger(length);\n\tmxRunCount(1);\n\tif (the->stack->kind != XS_REFERENCE_KIND)\n\t\tmxTypeError(\"no instance\");\n\tinstance = the->stack->value.reference;\n\tif (!(instance->next) || (instance->next->kind != XS_ARRAY_BUFFER_KIND))\n\t\tmxTypeError(\"no ArrayBuffer instance\");\n\tif (!constructor && (mxThis->value.reference == instance))\n\t\tmxTypeError(\"same ArrayBuffer instance\");\n\tif (instance->next->next->value.bufferInfo.length < length)\n\t\tmxTypeError(\"smaller ArrayBuffer instance\");\n\tmxPullSlot(mxResult);\n}\n\ntxSlot* fxNewArrayBufferInstance(txMachine* the)\n{\n\ttxSlot* instance;\n\ttxSlot* property;\n\tinstance = fxNewObjectInstance(the);\n\tproperty = instance->next = fxNewSlot(the);\n\tproperty->flag = XS_INTERNAL_FLAG;\n\tproperty->kind = XS_ARRAY_BUFFER_KIND;\n\tproperty->value.arrayBuffer.address = C_NULL;\n\tproperty->value.arrayBuffer.detachKey = C_NULL;\n\tproperty = property->next = fxNewSlot(the);\n\tproperty->flag = XS_INTERNAL_FLAG;\n\tproperty->kind = XS_BUFFER_INFO_KIND;\n\tproperty->value.bufferInfo.length = 0;\n\tproperty->value.bufferInfo.maxLength = -1;\n\treturn instance;\n}\n\nvoid fx_ArrayBuffer(txMachine* the)\n{\n\ttxSlot* instance;\n\ttxInteger byteLength;\n\ttxInteger maxByteLength = -1;\n\ttxSlot* property;\n\tif (mxIsUndefined(mxTarget))\n\t\tmxTypeError(\"call: ArrayBuffer\");\n\tmxPushSlot(mxTarget);\n\tfxGetPrototypeFromConstructor(the, &mxArrayBufferPrototype);\n\tinstance = fxNewArrayBufferInstance(the);\n\tmxPullSlot(mxResult);\n\tbyteLength = fxArgToByteLength(the, 0, 0);\n\tif ((mxArgc > 1) && mxIsReference(mxArgv(1))) {\n\t\tmxPushSlot(mxArgv(1));\n\t\tmxGetID(mxID(_maxByteLength));\n\t\tmxPullSlot(mxArgv(1));\n\t\tmaxByteLength = fxArgToByteLength(the, 1, -1);\n\t}\n\tif (maxByteLength >= 0) {\n\t\tif (byteLength > maxByteLength)\n\t\t\tmxRangeError(\"byteLength > maxByteLength\");\n\t}\n\tproperty = instance->next;\n\tproperty->value.arrayBuffer.address = fxNewChunk(the, byteLength);\n\tc_memset(property->value.arrayBuffer.address, 0, byteLength);\n\tproperty = property->next;\n\tproperty->value.bufferInfo.length = byteLength;\n\tproperty->value.bufferInfo.maxLength = maxByteLength;\n}\n\nvoid fx_ArrayBuffer_fromBigInt(txMachine* the)\n{\n\ttxU4 minBytes = 0;\n\ttxBoolean sign = 0;\n\tint endian = EndianBig;\n\tif (mxArgc < 1)\n\t\tmxTypeError(\"no argument\");\n\tif (mxArgc > 1) {\n\t\ttxInteger m = fxToInteger(the, mxArgv(1));\n\t\tif (m < 0)\n\t\t\tmxRangeError(\"minBytes < 0\");\n\t\tminBytes = (txU4)m;\n\t}\n\tif ((mxArgc > 2) && fxToBoolean(the, mxArgv(2)))\n\t\tsign = 1;\n\tif ((mxArgc > 3) && fxToBoolean(the, mxArgv(3)))\n\t\tendian = EndianLittle;\n\tif (gxTypeBigInt.toArrayBuffer) {\n\t\tgxTypeBigInt.toArrayBuffer(the, mxArgv(0), minBytes, sign, endian);\n\t}\n\telse {\n\t\tmxUnknownError(\"not built-in\");\n\t}\n}\n\n#ifndef mxCESU8\nvoid fx_ArrayBuffer_fromString(txMachine* the)\n{\n\ttxSize length;\n\tif (mxArgc < 1)\n\t\tmxTypeError(\"no argument\");\n\tlength = mxStringLength(fxToString(the, mxArgv(0)));\n\tfxConstructArrayBufferResult(the, mxThis, length);\n\tc_memcpy(mxResult->value.reference->next->value.arrayBuffer.address, mxArgv(0)->value.string, length);\n}\n#endif\n\nvoid fx_ArrayBuffer_isView(txMachine* the)\n{\n\ttxSlot* slot;\n\tmxResult->kind = XS_BOOLEAN_KIND;\n\tmxResult->value.boolean = 0;\n\tif (mxArgc > 0) {\n\t\tslot = mxArgv(0);\n\t\tif (slot->kind == XS_REFERENCE_KIND) {\n\t\t\tslot = slot->value.reference;\n\t\t\tif (slot->next) {\n\t\t\t\tslot = slot->next;\n\t\t\t\tif ((slot->kind == XS_DATA_VIEW_KIND) || (slot->kind == XS_TYPED_ARRAY_KIND)) {\n\t\t\t\t\tmxResult->value.boolean = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid fx_ArrayBuffer_prototype_get_byteLength(txMachine* the)\n{\n\ttxSlot* instance = fxCheckArrayBufferInstance(the, mxThis);\n\ttxSlot* arrayBuffer = instance->next;\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\tmxResult->kind = XS_INTEGER_KIND;\n\tif (arrayBuffer->value.arrayBuffer.address == C_NULL)\n\t\tmxResult->value.integer = 0;\n\telse\n\t\tmxResult->value.integer = bufferInfo->value.bufferInfo.length;\n}\n\nvoid fx_ArrayBuffer_prototype_get_maxByteLength(txMachine* the)\n{\n\ttxSlot* instance = fxCheckArrayBufferInstance(the, mxThis);\n\ttxSlot* arrayBuffer = instance->next;\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\tmxResult->kind = XS_INTEGER_KIND;\n\tif (arrayBuffer->value.arrayBuffer.address == C_NULL)\n\t\tmxResult->value.integer = 0;\n\telse if (bufferInfo->value.bufferInfo.maxLength >= 0)\n\t\tmxResult->value.integer = bufferInfo->value.bufferInfo.maxLength;\n\telse\n\t\tmxResult->value.integer = bufferInfo->value.bufferInfo.length;\n}\n\nvoid fx_ArrayBuffer_prototype_get_resizable(txMachine* the)\n{\n\ttxSlot* instance = fxCheckArrayBufferInstance(the, mxThis);\n\ttxSlot* arrayBuffer = instance->next;\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\tmxResult->kind = XS_BOOLEAN_KIND;\n\tmxResult->value.boolean = (bufferInfo->value.bufferInfo.maxLength >= 0) ? 1 : 0;\n}\n\nvoid fx_ArrayBuffer_prototype_concat(txMachine* the)\n{\n\ttxSlot* instance = fxCheckArrayBufferInstance(the, mxThis);\n\ttxSlot* arrayBuffer = instance->next;\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\ttxInteger length = bufferInfo->value.bufferInfo.length;\n\ttxInteger c = mxArgc, i = 0;\n\ttxByte* address;\n\ttxSlot* slot;\n\twhile (i < c) {\n\t\tarrayBuffer = C_NULL;\n\t\tbufferInfo = C_NULL;\n\t\tslot = mxArgv(i);\n\t\tif (slot->kind == XS_REFERENCE_KIND) {\n\t\t\tslot = slot->value.reference->next;\n\t\t\tif (slot && (slot->kind == XS_ARRAY_BUFFER_KIND)) {\n\t\t\t\tarrayBuffer = slot;\n\t\t\t\tbufferInfo = slot->next;\n\t\t\t}\n\t\t}\n\t\tif (arrayBuffer) \n\t\t\tlength = fxAddChunkSizes(the, length, bufferInfo->value.bufferInfo.length);\n\t\telse\n\t\t\tmxTypeError(\"arguments[%ld] is no ArrayBuffer instance\", i);\n\t\ti++;\n\t}\n\tfxConstructArrayBufferResult(the, C_NULL, length);\n\tarrayBuffer = instance->next;\n\tbufferInfo = arrayBuffer->next;\n\taddress = mxResult->value.reference->next->value.arrayBuffer.address;\n\tlength = bufferInfo->value.bufferInfo.length;\n\tc_memcpy(address, arrayBuffer->value.arrayBuffer.address, length);\n\taddress += length;\n\ti = 0;\n\twhile (i < c) {\n\t\tarrayBuffer = mxArgv(i)->value.reference->next;\n\t\tbufferInfo = arrayBuffer->next;\n\t\tlength = bufferInfo->value.bufferInfo.length;\n\t\tc_memcpy(address, arrayBuffer->value.arrayBuffer.address, length);\n\t\taddress += length;\n\t\ti++;\n\t}\n}\n\nvoid fx_ArrayBuffer_prototype_resize(txMachine* the)\n{\n\t/* txSlot* instance = */ fxCheckArrayBufferInstance(the, mxThis);\n\ttxSlot* arrayBuffer = fxCheckArrayBufferDetached(the, mxThis, XS_MUTABLE);\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\ttxInteger maxByteLength, oldByteLength, newByteLength;\n\ttxByte* chunk;\n\tmaxByteLength = bufferInfo->value.bufferInfo.maxLength;\n\tif (maxByteLength < 0)\n\t\tmxTypeError(\"not resizable\");\n\toldByteLength = bufferInfo->value.bufferInfo.length;\n\tnewByteLength = fxArgToByteLength(the, 0, 0);\n\tif (newByteLength > maxByteLength)\n\t\tmxRangeError(\"newLength > maxByteLength\");\n\tchunk = (txByte*)fxRenewChunk(the, arrayBuffer->value.arrayBuffer.address, newByteLength);\n\tif (!chunk) {\n\t\tchunk = (txByte*)fxNewChunk(the, newByteLength);\n\t\tc_memcpy(chunk, arrayBuffer->value.arrayBuffer.address, (newByteLength < oldByteLength) ? newByteLength : oldByteLength);\n\t}\n\tif (newByteLength > oldByteLength)\n\t\tc_memset(chunk + oldByteLength, 0, newByteLength - oldByteLength);\n\tarrayBuffer->value.arrayBuffer.address = chunk;\n\tbufferInfo->value.bufferInfo.length = newByteLength;\n}\n\nvoid fx_ArrayBuffer_prototype_slice(txMachine* the)\n{\n\t/* txSlot* instance = */ fxCheckArrayBufferInstance(the, mxThis);\n\ttxSlot* arrayBuffer = fxCheckArrayBufferDetached(the, mxThis, XS_IMMUTABLE);\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\ttxInteger length = bufferInfo->value.bufferInfo.length;\n\ttxInteger start = (txInteger)fxArgToIndex(the, 0, 0, length);\n\ttxInteger stop = (txInteger)fxArgToIndex(the, 1, length, length);\n\ttxSlot* resultBuffer;\n\tif (stop < start) \n\t\tstop = start;\n\tfxConstructArrayBufferResult(the, C_NULL, stop - start);\n\tresultBuffer = fxCheckArrayBufferDetached(the, mxResult, XS_MUTABLE);\n\tc_memcpy(resultBuffer->value.arrayBuffer.address, arrayBuffer->value.arrayBuffer.address + start, stop - start);\n}\n\nvoid fx_ArrayBuffer_prototype_transfer(txMachine* the)\n{\n\t/* txSlot* instance = */ fxCheckArrayBufferInstance(the, mxThis);\n\ttxSlot* arrayBuffer = fxCheckArrayBufferDetached(the, mxThis, XS_MUTABLE);\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\ttxInteger oldByteLength = bufferInfo->value.bufferInfo.length;\n\ttxInteger newByteLength = fxArgToByteLength(the, 0, oldByteLength);\n\ttxSlot* resultBuffer;\n\tfxConstructArrayBufferResult(the, C_NULL, newByteLength);\n\tresultBuffer = fxCheckArrayBufferDetached(the, mxResult, XS_MUTABLE);\n\tc_memcpy(resultBuffer->value.arrayBuffer.address, arrayBuffer->value.arrayBuffer.address, (newByteLength < oldByteLength) ? newByteLength : oldByteLength);\n\tif (newByteLength > oldByteLength)\n\t\tc_memset(resultBuffer->value.arrayBuffer.address + oldByteLength, 0, newByteLength - oldByteLength);\n\tarrayBuffer->value.arrayBuffer.address = C_NULL;\n\tbufferInfo->value.bufferInfo.length = 0;\n}\n\ntxSlot* fxCheckDataViewInstance(txMachine* the, txSlot* slot)\n{\n\tif (slot->kind == XS_REFERENCE_KIND) {\n\t\ttxSlot* instance = slot->value.reference;\n\t\tif (((slot = instance->next)) && (slot->flag & XS_INTERNAL_FLAG) && (slot->kind == XS_DATA_VIEW_KIND))\n\t\t\treturn instance;\n\t}\n\tmxTypeError(\"this is no DataView instance\");\n\treturn C_NULL;\n}\n\ntxInteger fxCheckDataViewSize(txMachine* the, txSlot* view, txSlot* buffer, txBoolean mutable)\n{\n\ttxInteger size = view->value.dataView.size;\n\ttxSlot* arrayBuffer = buffer->value.reference->next;\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\tif (arrayBuffer->value.arrayBuffer.address == C_NULL)\n\t\tmxTypeError(\"detached buffer\");\n\tif (mutable && (arrayBuffer->flag & XS_DONT_SET_FLAG))\n\t\tmxTypeError(\"read-only buffer\");\n\tif (bufferInfo->value.bufferInfo.maxLength >= 0) {\n\t\ttxInteger offset = view->value.dataView.offset;\n\t\ttxInteger byteLength = bufferInfo->value.bufferInfo.length;\n\t\tif (offset > byteLength)\n\t\t\tmxTypeError(\"out of bounds view\");\n\t\telse if (size < 0)\n\t\t\tsize = byteLength - offset;\n\t\telse if (offset + size > byteLength)\n\t\t\tmxTypeError(\"out of bounds view\");\n\t}\n\treturn size;\n}\n\ntxSlot* fxGetBufferInfo(txMachine* the, txSlot* buffer)\n{\n\ttxSlot* arrayBuffer = buffer->value.reference->next;\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\tif (arrayBuffer->kind == XS_ARRAY_BUFFER_KIND) {\n\t\tif (arrayBuffer->value.arrayBuffer.address == C_NULL)\n\t\t\tmxTypeError(\"detached buffer\");\n\t\treturn bufferInfo;\n\t}\n\tif (arrayBuffer->kind == XS_HOST_KIND) {\n\t\ttxInteger byteLength;\n\t\tif (bufferInfo && (bufferInfo->kind == XS_BUFFER_INFO_KIND))\n\t\t\treturn bufferInfo;\n\t\tmxPushSlot(buffer);\n\t\tmxGetID(mxID(_byteLength));\n\t\tif (!fxCheckLength(the, the->stack, &byteLength))\n\t\t\tmxTypeError(\"invalid byteLength\");\n\t\tfxReport(the, \"# Use xsSetHostBuffer instead of xsSetHostData\\n\");\n\t\tmxPop();\n\t\tbufferInfo = fxNewSlot(the);\n\t\tbufferInfo->next = arrayBuffer->next;\n\t\tbufferInfo->flag = XS_INTERNAL_FLAG;\n\t\tbufferInfo->kind = XS_BUFFER_INFO_KIND;\n\t\tbufferInfo->value.bufferInfo.length = byteLength;\n\t\tbufferInfo->value.bufferInfo.maxLength = -1;\n\t\tarrayBuffer->next = bufferInfo;\n\t\treturn bufferInfo;\n\t}\n\tmxTypeError(\"invalid buffer\");\n\treturn C_NULL;\n}\n\ntxInteger fxGetDataViewSize(txMachine* the, txSlot* view, txSlot* buffer)\n{\n\ttxInteger size = view->value.dataView.size;\n\ttxSlot* arrayBuffer = buffer->value.reference->next;\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\tif (arrayBuffer->value.arrayBuffer.address == C_NULL)\n\t\treturn 0;\n\tif (bufferInfo->value.bufferInfo.maxLength >= 0) {\n\t\ttxInteger offset = view->value.dataView.offset;\n\t\ttxInteger byteLength = bufferInfo->value.bufferInfo.length;\n\t\tif (offset > byteLength)\n\t\t\tsize = 0;\n\t\telse if (size < 0)\n\t\t\tsize = byteLength - offset;\n\t\telse if (offset + size > byteLength)\n\t\t\tsize = 0;\n\t}\n\treturn size;\n}\n\ntxSlot* fxNewDataViewInstance(txMachine* the)\n{\n\ttxSlot* instance;\n\ttxSlot* property;\n\tinstance = fxNewObjectInstance(the);\n\tproperty = instance->next = fxNewSlot(the);\n\tproperty->flag = XS_INTERNAL_FLAG;\n\tproperty->kind = XS_DATA_VIEW_KIND;\n\tproperty->value.dataView.offset = 0;\n\tproperty->value.dataView.size = 0;\n\tproperty = fxNextNullProperty(the, property, XS_NO_ID, XS_INTERNAL_FLAG);\n\treturn instance;\n}\n\nvoid fx_DataView(txMachine* the)\n{\n\ttxSlot* slot;\n\ttxBoolean flag = 0;\n\ttxInteger offset, size;\n\ttxSlot* info;\n\ttxSlot* instance;\n\ttxSlot* view;\n\ttxSlot* buffer;\n\tif (mxIsUndefined(mxTarget))\n\t\tmxTypeError(\"call: DataView\");\n\tif ((mxArgc > 0) && (mxArgv(0)->kind == XS_REFERENCE_KIND)) {\n\t\tslot = mxArgv(0)->value.reference->next;\n\t\tif (slot && ((slot->kind == XS_ARRAY_BUFFER_KIND) || (slot->kind == XS_HOST_KIND))) {\n\t\t\tflag = 1;\n\t\t}\n\t}\n\tif (!flag)\n\t\tmxTypeError(\"buffer is no ArrayBuffer instance\");\n\t\t\n\toffset = fxArgToByteLength(the, 1, 0);\n\tinfo = fxGetBufferInfo(the, mxArgv(0));\n\tif (info->value.bufferInfo.length < offset)\n\t\tmxRangeError(\"out of range byteOffset %ld\", offset);\n\tsize = fxArgToByteLength(the, 2, -1);\n\tif (size >= 0) {\n\t\ttxInteger end = offset + size;\n\t\tif ((info->value.bufferInfo.length < end) || (end < offset))\n\t\t\tmxRangeError(\"out of range byteLength %ld\", size);\n\t}\n\telse {\n\t\tif (info->value.bufferInfo.maxLength < 0)\n\t\t\tsize = info->value.bufferInfo.length - offset;\n\t}\n\tmxPushSlot(mxTarget);\n\tfxGetPrototypeFromConstructor(the, &mxDataViewPrototype);\n\tinstance = fxNewDataViewInstance(the);\n\tmxPullSlot(mxResult);\n\tview = instance->next;\n\tbuffer = view->next;\n\tbuffer->kind = XS_REFERENCE_KIND;\n\tbuffer->value.reference = mxArgv(0)->value.reference;\n\tinfo = fxGetBufferInfo(the, buffer);\n\tif (info->value.bufferInfo.maxLength >= 0) {\n\t\tif (info->value.bufferInfo.length < offset)\n\t\t\tmxRangeError(\"out of range byteOffset %ld\", offset);\n\t\telse if (size >= 0) {\n\t\t\ttxInteger end = offset + size;\n\t\t\tif ((info->value.bufferInfo.length < end) || (end < offset))\n\t\t\t\tmxRangeError(\"out of range byteLength %ld\", size);\n\t\t}\n\t}\n\tview->value.dataView.offset = offset;\n\tview->value.dataView.size = size;\n}\n\nvoid fx_DataView_prototype_buffer_get(txMachine* the)\n{\n\ttxSlot* instance = fxCheckDataViewInstance(the, mxThis);\n\ttxSlot* view = instance->next;\n\ttxSlot* buffer = view->next;\n\tmxResult->kind = buffer->kind;\n\tmxResult->value = buffer->value;\n}\n\nvoid fx_DataView_prototype_byteLength_get(txMachine* the)\n{\n\ttxSlot* instance = fxCheckDataViewInstance(the, mxThis);\n\ttxSlot* view = instance->next;\n\ttxSlot* buffer = view->next;\n\ttxInteger size = fxCheckDataViewSize(the, view, buffer, XS_IMMUTABLE);\n\tmxResult->kind = XS_INTEGER_KIND;\n\tmxResult->value.integer = size;\n}\n\nvoid fx_DataView_prototype_byteOffset_get(txMachine* the)\n{\n\ttxSlot* instance = fxCheckDataViewInstance(the, mxThis);\n\ttxSlot* view = instance->next;\n\ttxSlot* buffer = view->next;\n\tfxCheckDataViewSize(the, view, buffer, XS_IMMUTABLE);\n\tmxResult->kind = XS_INTEGER_KIND;\n\tmxResult->value.integer = view->value.dataView.offset;\n}\n\nvoid fx_DataView_prototype_get(txMachine* the, txNumber delta, txTypeCallback getter)\n{\n\ttxSlot* instance = fxCheckDataViewInstance(the, mxThis);\n\ttxSlot* view = instance->next;\n\ttxSlot* buffer = view->next;\n\ttxInteger offset = fxArgToByteLength(the, 0, 0);\n\ttxInteger size;\n\tint endian = EndianBig;\n\tif ((mxArgc > 1) && fxToBoolean(the, mxArgv(1)))\n\t\tendian = EndianLittle;\n\tsize = fxCheckDataViewSize(the, view, buffer, XS_IMMUTABLE);\n\tif ((size < delta) || ((size - delta) < offset))\n\t\tmxRangeError(\"out of range byteOffset\");\n\toffset += view->value.dataView.offset;\n\t(*getter)(the, buffer->value.reference->next, offset, mxResult, endian);\n}\n\nvoid fx_DataView_prototype_getBigInt64(txMachine* the)\n{\n\tfx_DataView_prototype_get(the, 8, fxBigInt64Getter);\n}\n\nvoid fx_DataView_prototype_getBigUint64(txMachine* the)\n{\n\tfx_DataView_prototype_get(the, 8, fxBigUint64Getter);\n}\n\nvoid fx_DataView_prototype_getFloat32(txMachine* the)\n{\n\tfx_DataView_prototype_get(the, 4, fxFloat32Getter);\n}\n\nvoid fx_DataView_prototype_getFloat64(txMachine* the)\n{\n\tfx_DataView_prototype_get(the, 8, fxFloat64Getter);\n}\n\nvoid fx_DataView_prototype_getInt8(txMachine* the)\n{\n\tfx_DataView_prototype_get(the, 1, fxInt8Getter);\n}\n\nvoid fx_DataView_prototype_getInt16(txMachine* the)\n{\n\tfx_DataView_prototype_get(the, 2, fxInt16Getter);\n}\n\nvoid fx_DataView_prototype_getInt32(txMachine* the)\n{\n\tfx_DataView_prototype_get(the, 4, fxInt32Getter);\n}\n\nvoid fx_DataView_prototype_getUint8(txMachine* the)\n{\n\tfx_DataView_prototype_get(the, 1, fxUint8Getter);\n}\n\nvoid fx_DataView_prototype_getUint16(txMachine* the)\n{\n\tfx_DataView_prototype_get(the, 2, fxUint16Getter);\n}\n\nvoid fx_DataView_prototype_getUint32(txMachine* the)\n{\n\tfx_DataView_prototype_get(the, 4, fxUint32Getter);\n}\n\nvoid fx_DataView_prototype_set(txMachine* the, txNumber delta, txTypeCoerce coercer, txTypeCallback setter)\n{\n\ttxSlot* instance = fxCheckDataViewInstance(the, mxThis);\n\ttxSlot* view = instance->next;\n\ttxSlot* buffer = view->next;\n\ttxInteger offset = fxArgToByteLength(the, 0, 0);\n\ttxInteger size;\n\tint endian = EndianBig;\n\ttxSlot* value;\n\tif (mxArgc > 1)\n\t\tmxPushSlot(mxArgv(1));\n\telse\n\t\tmxPushUndefined();\n\tvalue = the->stack;\t\n\t(*coercer)(the, value);\n\tif ((mxArgc > 2) && fxToBoolean(the, mxArgv(2)))\n\t\tendian = EndianLittle;\n\tsize = fxCheckDataViewSize(the, view, buffer, XS_MUTABLE);\n\tif ((size < delta) || ((size - delta) < offset))\n\t\tmxRangeError(\"out of range byteOffset\");\n\toffset += view->value.dataView.offset;\n\t(*setter)(the, buffer->value.reference->next, offset, value, endian);\n\tmxPop();\n}\n\nvoid fx_DataView_prototype_setBigInt64(txMachine* the)\n{\n\tfx_DataView_prototype_set(the, 8, fxBigIntCoerce, fxBigInt64Setter);\n}\n\nvoid fx_DataView_prototype_setBigUint64(txMachine* the)\n{\n\tfx_DataView_prototype_set(the, 8, fxBigIntCoerce, fxBigUint64Setter);\n}\n\nvoid fx_DataView_prototype_setFloat32(txMachine* the)\n{\n\tfx_DataView_prototype_set(the, 4, fxNumberCoerce, fxFloat32Setter);\n}\n\nvoid fx_DataView_prototype_setFloat64(txMachine* the)\n{\n\tfx_DataView_prototype_set(the, 8, fxNumberCoerce, fxFloat64Setter);\n}\n\nvoid fx_DataView_prototype_setInt8(txMachine* the)\n{\n\tfx_DataView_prototype_set(the, 1, fxIntCoerce, fxInt8Setter);\n}\n\nvoid fx_DataView_prototype_setInt16(txMachine* the)\n{\n\tfx_DataView_prototype_set(the, 2, fxIntCoerce, fxInt16Setter);\n}\n\nvoid fx_DataView_prototype_setInt32(txMachine* the)\n{\n\tfx_DataView_prototype_set(the, 4, fxIntCoerce, fxInt32Setter);\n}\n\nvoid fx_DataView_prototype_setUint8(txMachine* the)\n{\n\tfx_DataView_prototype_set(the, 1, fxUintCoerce, fxUint8Setter);\n}\n\nvoid fx_DataView_prototype_setUint16(txMachine* the)\n{\n\tfx_DataView_prototype_set(the, 2, fxUintCoerce, fxUint16Setter);\n}\n\nvoid fx_DataView_prototype_setUint32(txMachine* the)\n{\n\tfx_DataView_prototype_set(the, 4, fxUintCoerce, fxUint32Setter);\n}\n\n\n#define mxTypedArrayDeclarations \\\n\ttxSlot* instance = fxCheckTypedArrayInstance(the, mxThis); \\\n\ttxSlot* dispatch = instance->next; \\\n\ttxSlot* view = dispatch->next; \\\n\ttxSlot* buffer = view->next; \\\n\ttxInteger length = fxCheckDataViewSize(the, view, buffer, XS_IMMUTABLE) >> dispatch->value.typedArray.dispatch->shift\n\n#define mxMutableTypedArrayDeclarations \\\n\ttxSlot* instance = fxCheckTypedArrayInstance(the, mxThis); \\\n\ttxSlot* dispatch = instance->next; \\\n\ttxSlot* view = dispatch->next; \\\n\ttxSlot* buffer = view->next; \\\n\ttxInteger length = fxCheckDataViewSize(the, view, buffer, XS_MUTABLE) >> dispatch->value.typedArray.dispatch->shift\n\n#define mxResultTypedArrayDeclarations \\\n\ttxSlot* resultInstance = fxCheckTypedArrayInstance(the, mxResult); \\\n\ttxSlot* resultDispatch = resultInstance->next; \\\n\ttxSlot* resultView = resultDispatch->next; \\\n\ttxSlot* resultBuffer = resultView->next; \\\n\ttxInteger resultLength = fxCheckDataViewSize(the, resultView, resultBuffer, XS_MUTABLE) >> resultDispatch->value.typedArray.dispatch->shift\n\nvoid fxTypedArrayGetter(txMachine* the)\n{\n\ttxSlot* instance = fxToInstance(the, mxThis);\n\ttxSlot* dispatch;\n\twhile (instance) {\n\t\tif (instance->flag & XS_EXOTIC_FLAG) {\n\t\t\tdispatch = instance->next;\n\t\t\tif (dispatch->ID == XS_TYPED_ARRAY_BEHAVIOR)\n\t\t\t\tbreak;\n\t\t}\n\t\tinstance = fxGetPrototype(the, instance);\n\t}\n\tif (instance) {\n\t\ttxID id = the->scratch.value.at.id;\n\t\ttxIndex index = the->scratch.value.at.index;\n\t\ttxSlot* view = dispatch->next;\n\t\ttxSlot* buffer = view->next;\n\t\ttxU2 shift = dispatch->value.typedArray.dispatch->shift;\n\t\ttxIndex length = fxGetDataViewSize(the, view, buffer) >> shift;\n\t\tif ((!id) && (index < length)) {\n\t\t\t(*dispatch->value.typedArray.dispatch->getter)(the, buffer->value.reference->next, view->value.dataView.offset + (index << shift), mxResult, EndianNative);\n\t\t}\n\t}\n}\n\nvoid fxTypedArraySetter(txMachine* the)\n{\n\ttxSlot* instance = fxToInstance(the, mxThis);\n\ttxSlot* dispatch;\n\twhile (instance) {\n\t\tif (instance->flag & XS_EXOTIC_FLAG) {\n\t\t\tdispatch = instance->next;\n\t\t\tif (dispatch->ID == XS_TYPED_ARRAY_BEHAVIOR)\n\t\t\t\tbreak;\n\t\t}\n\t\tinstance = fxGetPrototype(the, instance);\n\t}\n\tif (instance) {\n\t\ttxSlot* slot = mxArgv(0);\n\t\ttxID id = the->scratch.value.at.id;\n\t\ttxIndex index = the->scratch.value.at.index;\n\t\ttxSlot* view = dispatch->next;\n\t\ttxSlot* buffer = view->next;\n\t\ttxU2 shift = dispatch->value.typedArray.dispatch->shift;\n\t\ttxSlot* arrayBuffer = buffer->value.reference->next;\n\t\ttxIndex length;\n\t\tdispatch->value.typedArray.dispatch->coerce(the, slot);\n\t\tif (arrayBuffer->flag & XS_DONT_SET_FLAG)\n\t\t\tmxTypeError(\"read-only buffer\");\n\t\tlength = fxGetDataViewSize(the, view, buffer) >> shift;\n\t\tif ((!id) && (index < length)) {\n\t\t\t(*dispatch->value.typedArray.dispatch->setter)(the, arrayBuffer, view->value.dataView.offset + (index << shift), slot, EndianNative);\n\t\t}\n\t}\n}\n\ntxBoolean fxTypedArrayDefineOwnProperty(txMachine* the, txSlot* instance, txID id, txIndex index, txSlot* slot, txFlag mask) \n{\n\tif ((!id) || fxIsCanonicalIndex(the, id)) {\n\t\ttxSlot* dispatch = instance->next;\n\t\ttxSlot* view = dispatch->next;\n\t\ttxSlot* buffer = view->next;\n\t\ttxU2 shift = dispatch->value.typedArray.dispatch->shift;\n\t\ttxSlot* arrayBuffer = buffer->value.reference->next;\n\t\ttxIndex length = fxGetDataViewSize(the, view, buffer) >> shift;\n\t\tif (id || (index >= length))\n\t\t\treturn 0;\n\t\tif ((mask & XS_DONT_DELETE_FLAG) && (slot->flag & XS_DONT_DELETE_FLAG))\n\t\t\treturn 0;\n\t\tif ((mask & XS_DONT_ENUM_FLAG) && (slot->flag & XS_DONT_ENUM_FLAG))\n\t\t\treturn 0;\n\t\tif (mask & XS_ACCESSOR_FLAG)\n\t\t\treturn 0;\n\t\tif ((mask & XS_DONT_SET_FLAG) && (slot->flag & XS_DONT_SET_FLAG))\n\t\t\treturn 0;\n\t\tif (slot->kind != XS_UNINITIALIZED_KIND) {\n\t\t\tdispatch->value.typedArray.dispatch->coerce(the, slot);\n\t\t\tif (arrayBuffer->flag & XS_DONT_SET_FLAG)\n\t\t\t\tmxTypeError(\"read-only buffer\");\n\t\t\tlength = fxGetDataViewSize(the, view, buffer) >> shift;\n\t\t\tif (index < length)\n\t\t\t\t(*dispatch->value.typedArray.dispatch->setter)(the, arrayBuffer, view->value.dataView.offset + (index << shift), slot, EndianNative);\n\t\t}\n\t\treturn 1;\n\t}\n\treturn fxOrdinaryDefineOwnProperty(the, instance, id, index, slot, mask);\n}\n\ntxBoolean fxTypedArrayDeleteProperty(txMachine* the, txSlot* instance, txID id, txIndex index)\n{\n\tif ((!id) || fxIsCanonicalIndex(the, id)) {\n\t\ttxSlot* dispatch = instance->next;\n\t\ttxSlot* view = dispatch->next;\n\t\ttxSlot* buffer = view->next;\n\t\ttxU2 shift = dispatch->value.typedArray.dispatch->shift;\n\t\ttxIndex length = fxGetDataViewSize(the, view, buffer) >> shift;\n\t\treturn ((!id) && (index < length)) ? 0 : 1;\n\t}\n\treturn fxOrdinaryDeleteProperty(the, instance, id, index);\n}\n\ntxBoolean fxTypedArrayGetOwnProperty(txMachine* the, txSlot* instance, txID id, txIndex index, txSlot* slot)\n{\n\tif ((!id) || fxIsCanonicalIndex(the, id)) {\n\t\ttxSlot* dispatch = instance->next;\n\t\ttxSlot* view = dispatch->next;\n\t\ttxSlot* buffer = view->next;\n\t\ttxU2 shift = dispatch->value.typedArray.dispatch->shift;\n\t\ttxIndex length = fxGetDataViewSize(the, view, buffer) >> shift;\n\t\tif ((!id) && (index < length)) {\n\t\t\t(*dispatch->value.typedArray.dispatch->getter)(the, buffer->value.reference->next, view->value.dataView.offset + (index << shift), slot, EndianNative);\n\t\t\treturn 1;\n\t\t}\n\t\tslot->kind = XS_UNDEFINED_KIND;\n\t\tslot->flag = XS_NO_FLAG;\n\t\treturn 0;\n\t}\n\treturn fxOrdinaryGetOwnProperty(the, instance, id, index, slot);\n}\n\ntxSlot* fxTypedArrayGetProperty(txMachine* the, txSlot* instance, txID id, txIndex index, txFlag flag)\n{\n\tif ((!id) || fxIsCanonicalIndex(the, id)) {\n\t\tthe->scratch.value.at.id = id;\n\t\tthe->scratch.value.at.index = index;\n\t\treturn &mxTypedArrayAccessor;\n\t}\n\treturn fxOrdinaryGetProperty(the, instance, id, index, flag);\n}\n\ntxBoolean fxTypedArrayGetPropertyValue(txMachine* the, txSlot* instance, txID id, txIndex index, txSlot* receiver, txSlot* value)\n{\n\tif ((!id) || fxIsCanonicalIndex(the, id)) {\n\t\ttxSlot* dispatch = instance->next;\n\t\ttxSlot* view = dispatch->next;\n\t\ttxSlot* buffer = view->next;\n\t\ttxU2 shift = dispatch->value.typedArray.dispatch->shift;\n\t\ttxIndex length = fxGetDataViewSize(the, view, buffer) >> shift;\n\t\tif ((!id) && (index < length)) {\n\t\t\t(*dispatch->value.typedArray.dispatch->getter)(the, buffer->value.reference->next, view->value.dataView.offset + (index << shift), value, EndianNative);\n\t\t\treturn 1;\n\t\t}\n\t\tvalue->kind = XS_UNDEFINED_KIND;\n\t\treturn 0;\n\t}\n\treturn fxOrdinaryGetPropertyValue(the, instance, id, index, receiver, value);\n}\n\ntxBoolean fxTypedArrayHasProperty(txMachine* the, txSlot* instance, txID id, txIndex index)\n{\n\tif ((!id) || fxIsCanonicalIndex(the, id)) {\n\t\ttxSlot* dispatch = instance->next;\n\t\ttxSlot* view = dispatch->next;\n\t\ttxSlot* buffer = view->next;\n\t\ttxU2 shift = dispatch->value.typedArray.dispatch->shift;\n\t\ttxIndex length = fxGetDataViewSize(the, view, buffer) >> shift;\n\t\treturn ((!id) && (index < length)) ? 1 : 0;\n\t}\n\treturn fxOrdinaryHasProperty(the, instance, id, index);\n}\n\nvoid fxTypedArrayOwnKeys(txMachine* the, txSlot* instance, txFlag flag, txSlot* keys)\n{\n\tif (flag & XS_EACH_NAME_FLAG) {\n\t\ttxSlot* dispatch = instance->next;\n\t\ttxSlot* view = dispatch->next;\n\t\ttxSlot* buffer = view->next;\n\t\ttxU2 shift = dispatch->value.typedArray.dispatch->shift;\n\t\ttxIndex length = fxGetDataViewSize(the, view, buffer) >> shift;\n\t\tif (length) {\n\t\t\ttxIndex index;\n\t\t\tfor (index = 0; index < length; index++)\n\t\t\t\tkeys = fxQueueKey(the, 0, index, keys);\n\t\t}\n\t}\n\tfxOrdinaryOwnKeys(the, instance, flag, keys);\n}\n\ntxSlot* fxTypedArraySetProperty(txMachine* the, txSlot* instance, txID id, txIndex index, txFlag flag)\n{\n\tif ((!id) || fxIsCanonicalIndex(the, id)) {\n\t\tthe->scratch.value.at.id = id;\n\t\tthe->scratch.value.at.index = index;\n\t\treturn &mxTypedArrayAccessor;\n\t}\n\treturn fxOrdinarySetProperty(the, instance, id, index, flag);\n}\n\ntxBoolean fxTypedArraySetPropertyValue(txMachine* the, txSlot* instance, txID id, txIndex index, txSlot* value, txSlot* receiver)\n{\n\tif ((!id) || fxIsCanonicalIndex(the, id)) {\n\t\ttxSlot* dispatch = instance->next;\n\t\ttxSlot* view = dispatch->next;\n\t\ttxSlot* buffer = view->next;\n\t\ttxU2 shift = dispatch->value.typedArray.dispatch->shift;\n\t\ttxSlot* arrayBuffer = buffer->value.reference->next;\n\t\ttxIndex length;\n\t\tdispatch->value.typedArray.dispatch->coerce(the, value);\n\t\tif (arrayBuffer->flag & XS_DONT_SET_FLAG)\n\t\t\tmxTypeError(\"read-only buffer\");\n\t\tlength = fxGetDataViewSize(the, view, buffer) >> shift;\n\t\tif ((!id) && (index < length)) {\n\t\t\t(*dispatch->value.typedArray.dispatch->setter)(the, buffer->value.reference->next, view->value.dataView.offset + (index << shift), value, EndianNative);\n\t\t}\n\t\treturn 1;\n\t}\n\treturn fxOrdinarySetPropertyValue(the, instance, id, index, value, receiver);\n}\n\nvoid fxCallTypedArrayItem(txMachine* the, txSlot* function, txSlot* dispatch, txSlot* view, txSlot* data, txInteger index, txSlot* item)\n{\n\t/* THIS */\n\tif (mxArgc > 1)\n\t\tmxPushSlot(mxArgv(1));\n\telse\n\t\tmxPushUndefined();\n\t/* FUNCTION */\n\tmxPushSlot(function);\n\tmxCall();\n\t/* ARGUMENTS */\n\tmxPushSlot(mxThis);\n\tmxGetIndex(index);\n\tif (item) {\n\t\titem->kind = the->stack->kind;\n\t\titem->value = the->stack->value;\n\t}\n\tmxPushInteger(index);\n\tmxPushSlot(mxThis);\n\tmxRunCount(3);\n}\n\ntxSlot* fxCheckTypedArrayInstance(txMachine* the, txSlot* slot)\n{\n\tif (slot->kind == XS_REFERENCE_KIND) {\n        txSlot* instance = slot->value.reference;\n\t\tif (((slot = instance->next)) && (slot->flag & XS_INTERNAL_FLAG) && (slot->kind == XS_TYPED_ARRAY_KIND))\n\t\t\treturn instance;\n\t}\n\tmxTypeError(\"this is no TypedArray instance\");\n\treturn C_NULL;\n}\n\nint fxCompareTypedArrayItem(txMachine* the, txSlot* function, txSlot* dispatch, txSlot* view, txSlot* data, txInteger index)\n{\n\ttxSlot* slot = the->stack;\n\tint result;\n\t/* THIS */\n\tmxPushUndefined();\n\t/* FUNCTION */\n\tmxPushSlot(function);\n\tmxCall();\n\t/* ARGUMENTS */\n\tmxPushUndefined();\n\t(*dispatch->value.typedArray.dispatch->getter)(the, data, view->value.dataView.offset + (index << dispatch->value.typedArray.dispatch->shift), the->stack, EndianNative);\n\tmxPushSlot(slot);\n\tmxRunCount(2);\n\tif (the->stack->kind == XS_INTEGER_KIND)\n\t\tresult = the->stack->value.integer;\n\telse {\n\t\ttxNumber number = fxToNumber(the, the->stack);\n\t\tresult = (number < 0) ? -1 :  (number > 0) ? 1 : 0;\n\t}\n\tmxPop();\n\tif (data->value.arrayBuffer.address == C_NULL)\n\t\tmxTypeError(\"detached buffer\");\n\treturn result;\n}\n\ntxSlot* fxConstructTypedArray(txMachine* the)\n{\n\ttxSlot* prototype;\n\ttxSlot* dispatch;\n\ttxSlot* instance;\n\tif (mxIsUndefined(mxTarget))\n\t\tmxTypeError(\"call: TypedArray\");\n\tdispatch = mxFunctionInstanceHome(mxFunction->value.reference);\n\tdispatch = dispatch->next;\n\tprototype = mxBehaviorGetProperty(the, mxFunction->value.reference, mxID(_prototype), 0, XS_ANY);\n\tif (!dispatch || (dispatch->kind != XS_TYPED_ARRAY_KIND))\n\t\tmxTypeError(\"new: TypedArray\");\n\tmxPushSlot(mxTarget);\n\tfxGetPrototypeFromConstructor(the, prototype);\n\tinstance = fxNewTypedArrayInstance(the, dispatch->value.typedArray.dispatch, dispatch->value.typedArray.atomics);\n\tmxPullSlot(mxResult);\n\treturn instance;\n}\n\nvoid fxCreateTypedArraySpecies(txMachine* the)\n{\n\ttxSlot* instance = fxToInstance(the, mxThis);\n\ttxSlot* dispatch = instance->next;\n\ttxSlot* constructor = &the->stackPrototypes[-1 - (txInteger)dispatch->value.typedArray.dispatch->constructorID];\n\tmxPushSlot(mxThis);\n\tmxGetID(mxID(_constructor));\n\tfxToSpeciesConstructor(the, constructor);\n\tmxNew();\n}\n\ntxSlot* fxGetTypedArrayValue(txMachine* the, txSlot* instance, txInteger index)\n{\n\ttxSlot* dispatch = instance->next;\n\ttxSlot* view = dispatch->next;\n\ttxSlot* buffer = view->next;\n\ttxSlot* data = mxIsReference(buffer) ? fxCheckArrayBufferDetached(the, buffer, XS_IMMUTABLE) : C_NULL;\n\ttxU2 shift = dispatch->value.typedArray.dispatch->shift;\n\tindex <<= shift;\n\tif ((0 <= index) && ((index + (1 << shift)) <= view->value.dataView.size)) {\n\t\t(*dispatch->value.typedArray.dispatch->getter)(the, data, view->value.dataView.offset + index, &(the->scratch), EndianNative);\n\t\treturn &the->scratch;\n\t}\n\treturn C_NULL;\n}\n\nvoid fxReduceTypedArrayItem(txMachine* the, txSlot* function, txSlot* dispatch, txSlot* view, txSlot* data, txInteger index)\n{\n\t/* THIS */\n\tmxPushUndefined();\n\t/* FUNCTION */\n\tmxPushSlot(function);\n\tmxCall();\n\t/* ARGUMENTS */\n\tmxPushSlot(mxResult);\n\tmxPushSlot(mxThis);\n\tmxGetIndex(index);\n\tmxPushInteger(index);\n\tmxPushSlot(mxThis);\n\tmxRunCount(4);\n\tmxPullSlot(mxResult);\n}\n\ntxSlot* fxNewTypedArrayInstance(txMachine* the, txTypeDispatch* dispatch, txTypeAtomics* atomics)\n{\n\ttxSlot* instance;\n\ttxSlot* property;\n\tinstance = fxNewObjectInstance(the);\n\tinstance->flag |= XS_EXOTIC_FLAG;\n\tproperty = fxNextTypeDispatchProperty(the, instance, dispatch, atomics, XS_TYPED_ARRAY_BEHAVIOR, XS_INTERNAL_FLAG);\n\tproperty = property->next = fxNewSlot(the);\n\tproperty->flag = XS_INTERNAL_FLAG;\n\tproperty->kind = XS_DATA_VIEW_KIND;\n\tproperty->value.dataView.offset = 0;\n\tproperty->value.dataView.size = 0;\n\tproperty = fxNextNullProperty(the, property, XS_NO_ID, XS_INTERNAL_FLAG);\n\treturn instance;\n}\n\nvoid fx_TypedArray(txMachine* the)\n{\n\ttxSlot* instance = fxConstructTypedArray(the);\n\ttxSlot* dispatch = instance->next;\n\ttxSlot* view = dispatch->next;\n\ttxSlot* buffer = view->next;\n\ttxSlot* data = C_NULL;\n\ttxU2 shift = dispatch->value.typedArray.dispatch->shift;\n\ttxSlot* slot;\n\tif ((mxArgc > 0) && (mxArgv(0)->kind == XS_REFERENCE_KIND)) {\n\t\tslot = mxArgv(0)->value.reference->next;\n\t\tif (slot && ((slot->kind == XS_ARRAY_BUFFER_KIND) || (slot->kind == XS_HOST_KIND))) {\n\t\t\ttxInteger offset = fxArgToByteLength(the, 1, 0);\n\t\t\ttxInteger size;\n\t\t\ttxSlot* info;\n\t\t\tif (offset & ((1 << shift) - 1))\n\t\t\t\tmxRangeError(\"invalid byteOffset %ld\", offset);\n\t\t\tsize = fxArgToByteLength(the, 2, -1);\n\t\t\tinfo = fxGetBufferInfo(the, mxArgv(0));\n\t\t\tif (size >= 0) {\n\t\t\t\ttxInteger delta = size << shift;\n\t\t\t\ttxInteger end = offset + delta;\n\t\t\t\tif ((info->value.bufferInfo.length < end) || (end < offset))\n\t\t\t\t\tmxRangeError(\"out of range length %ld\", size);\n\t\t\t\tsize = delta;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (info->value.bufferInfo.length & ((1 << shift) - 1))\n\t\t\t\t\tmxRangeError(\"invalid byteLength %ld\", info->value.bufferInfo.length);\n\t\t\t\tsize = info->value.bufferInfo.length - offset;\n\t\t\t\tif (size < 0)\n\t\t\t\t\tmxRangeError(\"out of range byteLength %ld\", size);\n\t\t\t\tif (info->value.bufferInfo.maxLength >= 0)\n\t\t\t\t\tsize = -1;\n\t\t\t}\n\t\t\tview->value.dataView.offset = offset;\n\t\t\tview->value.dataView.size = size;\n\t\t\tbuffer->kind = XS_REFERENCE_KIND;\n\t\t\tbuffer->value.reference = mxArgv(0)->value.reference;\n\t\t}\n\t\telse if (slot && (slot->kind == XS_TYPED_ARRAY_KIND)) {\n\t\t\ttxSlot* sourceDispatch = slot;\n\t\t\ttxSlot* sourceView = sourceDispatch->next;\n\t\t\ttxSlot* sourceBuffer = sourceView->next;\n\t\t\ttxU2 sourceShift = sourceDispatch->value.typedArray.dispatch->shift;\n\t\t\ttxInteger sourceLength = fxCheckDataViewSize(the, sourceView, sourceBuffer, XS_IMMUTABLE) >> sourceShift;\n\t\t\ttxSlot* sourceData = sourceBuffer->value.reference->next;\n\t\t\ttxInteger sourceDelta = sourceDispatch->value.typedArray.dispatch->size;\n\t\t\ttxInteger sourceOffset = sourceView->value.dataView.offset;\n\t\t\ttxInteger offset = 0;\n\t\t\ttxInteger size = sourceLength << shift;\n\t\t\t/* THIS */\n\t\t\tmxPushUninitialized();\t\n\t\t\t/* FUNCTION */\n\t\t\tmxPush(mxArrayBufferConstructor);\n\t\t\t/* TARGET */\n\t\t\tif (sourceData->kind == XS_ARRAY_BUFFER_KIND) {\n\t\t\t\tmxPushSlot(sourceBuffer);\n\t\t\t\tmxGetID(mxID(_constructor));\n\t\t\t\tfxToSpeciesConstructor(the, &mxArrayBufferConstructor);\n\t\t\t}\n\t\t\telse\n\t\t\t\tmxPush(mxArrayBufferConstructor);\n\t\t\t/* RESULT */\n\t\t\tmxPushUndefined();\t\n\t\t\tmxPushUninitialized();\t\n\t\t\tmxPushUninitialized();\t\n\t\t\t/* ARGUMENTS */\n\t\t\tsourceLength = fxGetDataViewSize(the, sourceView, sourceBuffer) >> sourceShift;\n\t\t\tsize = sourceLength << shift;\n\t\t\tmxPushInteger(size);\n\t\t\tmxRunCount(1);\n\t\t\tmxPullSlot(buffer);\n\t\t\tsourceLength = fxCheckDataViewSize(the, sourceView, sourceBuffer, XS_IMMUTABLE) >> sourceShift;\n\t\t\tsize = sourceLength << shift;\n\t\t\t\n\t\t\tdata = fxCheckArrayBufferDetached(the, buffer, XS_MUTABLE);\n\t\t\tview->value.dataView.offset = offset;\n\t\t\tview->value.dataView.size = size;\n\t\t\tif (dispatch == sourceDispatch)\n\t\t\t\tc_memcpy(data->value.arrayBuffer.address + offset, sourceData->value.arrayBuffer.address + sourceOffset, size);\n\t\t\telse {\n\t\t\t\ttxBoolean contentType = (dispatch->value.typedArray.dispatch->constructorID == _BigInt64Array)\n\t\t\t\t\t\t|| (dispatch->value.typedArray.dispatch->constructorID == _BigUint64Array);\n\t\t\t\ttxBoolean sourceContentType = (sourceDispatch->value.typedArray.dispatch->constructorID == _BigInt64Array)\n\t\t\t\t\t\t|| (sourceDispatch->value.typedArray.dispatch->constructorID == _BigUint64Array);\n\t\t\t\tif (contentType != sourceContentType)\n\t\t\t\t\tmxTypeError(\"incompatible content type\");\n\t\t\t\tmxPushUndefined();\n\t\t\t\twhile (offset < size) {\n\t\t\t\t\t(*sourceDispatch->value.typedArray.dispatch->getter)(the, sourceData, sourceOffset, the->stack, EndianNative);\n\t\t\t\t\t(*dispatch->value.typedArray.dispatch->coerce)(the, the->stack);\n\t\t\t\t\t(*dispatch->value.typedArray.dispatch->setter)(the, data, offset, the->stack, EndianNative);\n\t\t\t\t\tsourceOffset += sourceDelta;\n\t\t\t\t\toffset += 1 << shift;\n\t\t\t\t}\n\t\t\t\tmxPop();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfx_TypedArray_from_object(the, instance, C_NULL, C_NULL);\n\t\t}\n\t}\n\telse {\n        txInteger length = fxArgToByteLength(the, 0, 0);\n        if (length & (((1 << shift) - 1) << (32 - shift)))\n\t\t\tmxRangeError(\"out of range byteLength\");\n        length <<= shift;\n\t\tmxPush(mxArrayBufferConstructor);\n\t\tmxNew();\n\t\tmxPushInteger(length);\n\t\tmxRunCount(1);\n\t\tmxPullSlot(buffer);\n        view->value.dataView.offset = 0;\n        view->value.dataView.size = length;\n\t}\n}\n\nvoid fx_TypedArray_from(txMachine* the)\n{\n\ttxSlot* function = C_NULL;\n\ttxSlot* _this = C_NULL;\n\tif (!mxIsReference(mxThis) || !(mxIsConstructor(mxThis->value.reference)))\n\t\tmxTypeError(\"this is no constructor\");\n\tif (mxArgc > 1) {\n\t\ttxSlot* slot = mxArgv(1);\n\t\tif (!mxIsUndefined(slot)) {\n\t\t\tfunction = slot;\n\t\t\tif (!fxIsCallable(the, function))\n\t\t\t\tmxTypeError(\"map is no function\");\n\t\t\tif (mxArgc > 2)\n\t\t\t\t_this = mxArgv(2);\n\t\t}\n\t}\n\tfx_TypedArray_from_object(the, C_NULL, function, _this);\n}\n\nvoid fx_TypedArray_from_object(txMachine* the, txSlot* instance, txSlot* function, txSlot* _this)\n{\n\ttxSlot* stack = the->stack;\n\ttxSlot* iterator;\n\ttxSlot* next;\n\ttxSlot* value;\n\ttxSlot* list = C_NULL;\n\ttxSlot* slot;\n\ttxSlot* dispatch;\n\ttxSlot* view;\n\ttxSlot* buffer;\n\ttxSlot* data;\n\ttxU2 shift;\n\ttxNumber length;\n\tmxTemporary(iterator);\n\tmxTemporary(next);\n\tif (fxGetIterator(the, mxArgv(0), iterator, next, 1)) {\n\t\tlist = fxNewInstance(the);\n\t\tslot = list;\n\t\tlength = 0;\n\t\tmxTemporary(value);\n\t\twhile (fxIteratorNext(the, iterator, next, value)) {\n\t\t\tslot = fxNextSlotProperty(the, slot, value, XS_NO_ID, XS_NO_FLAG);\n\t\t\tlength++;\n\t\t}\n\t}\n\telse {\n\t\tmxPushSlot(mxArgv(0));\n\t\tmxGetID(mxID(_length));\n\t\tlength = fxToLength(the, the->stack);\n\t\tmxPop();\n\t}\n\tif (instance) {\n\t\tdispatch = instance->next;\n\t\tview = dispatch->next;\n\t\tbuffer = view->next;\n\t\tshift = dispatch->value.typedArray.dispatch->shift;\n\t\tmxPush(mxArrayBufferConstructor);\n\t\tmxNew();\n\t\tmxPushNumber(length * dispatch->value.typedArray.dispatch->size);\n\t\tmxRunCount(1);\n\t\tmxPullSlot(buffer);\n\t\tdata = fxCheckArrayBufferDetached(the, buffer, XS_MUTABLE);\n\t\tview->value.dataView.offset = 0;\n\t\tview->value.dataView.size = data->next->value.bufferInfo.length;\n\t}\n\telse {\n\t\tmxPushSlot(mxThis);\n\t\tmxNew();\n\t\tmxPushNumber(length);\n\t\tmxRunCount(1);\n\t\tmxPullSlot(mxResult);\n\t\tinstance = fxToInstance(the, mxResult);\n\t\tif (((slot = instance->next)) && (slot->flag & XS_INTERNAL_FLAG) && (slot->kind == XS_TYPED_ARRAY_KIND)) {\n\t\t\tdispatch = instance->next;\n\t\t\tview = dispatch->next;\n\t\t\tbuffer = view->next;\n\t\t\tdata = fxCheckArrayBufferDetached(the, buffer, XS_MUTABLE);\n\t\t\tshift = dispatch->value.typedArray.dispatch->shift;\n\t\t\tif (view->value.dataView.size < (length * dispatch->value.typedArray.dispatch->size))\n\t\t\t\tmxTypeError(\"too small TypedArray\");\n\t\t}\n\t\telse\n\t\t\tmxTypeError(\"no TypedArray\");\n\t}\n\tif (list) {\n\t\ttxInteger index = 0;\n\t\tslot = list->next;\n\t\twhile (slot) {\n\t\t\t/* ARG0 */\n\t\t\tif (function) {\n\t\t\t\t/* THIS */\n\t\t\t\tif (_this)\n\t\t\t\t\tmxPushSlot(_this);\n\t\t\t\telse\n\t\t\t\t\tmxPushUndefined();\n\t\t\t\t/* FUNCTION */\n\t\t\t\tmxPushSlot(function);\n\t\t\t\tmxCall();\n\t\t\t\t/* ARGUMENTS */\n\t\t\t\tmxPushSlot(slot);\n\t\t\t\tmxPushInteger(index);\n\t\t\t\tmxRunCount(2);\n\t\t\t}\n\t\t\telse\n\t\t\t\tmxPushSlot(slot);\n\t\t\t(*dispatch->value.typedArray.dispatch->coerce)(the, the->stack);\n\t\t\t(*dispatch->value.typedArray.dispatch->setter)(the, data, (index << shift), the->stack, EndianNative);\n\t\t\tmxPop();\n\t\t\tindex++;\n\t\t\tslot = slot->next;\n\t\t}\n\t}\n\telse {\n\t\ttxInteger index = 0;\n\t\ttxInteger count = (txInteger)length;\n\t\twhile (index < count) {\n\t\t\tif (function) {\n\t\t\t\t/* THIS */\n\t\t\t\tif (_this)\n\t\t\t\t\tmxPushSlot(_this);\n\t\t\t\telse\n\t\t\t\t\tmxPushUndefined();\n\t\t\t\t/* FUNCTION */\n\t\t\t\tmxPushSlot(function);\n\t\t\t\tmxCall();\n\t\t\t\t/* ARGUMENTS */\n\t\t\t\tmxPushSlot(mxArgv(0));\n\t\t\t\tmxGetIndex(index);\n\t\t\t\tmxPushInteger(index);\n\t\t\t\tmxRunCount(2);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmxPushSlot(mxArgv(0));\n\t\t\t\tmxGetIndex(index);\n\t\t\t}\n\t\t\t(*dispatch->value.typedArray.dispatch->coerce)(the, the->stack);\n\t\t\t(*dispatch->value.typedArray.dispatch->setter)(the, data, (index << shift), the->stack, EndianNative);\n\t\t\tmxPop();\n\t\t\tindex++;\n\t\t}\t\n\t}\n\tthe->stack = stack;\n}\n\nvoid fx_TypedArray_of(txMachine* the)\n{\n\ttxInteger count = mxArgc;\n\ttxInteger index = 0;\n\tmxPushSlot(mxThis);\n\tmxNew();\n\tmxPushInteger(count);\n\tmxRunCount(1);\n\tmxPullSlot(mxResult);\n\t{\n\t\tmxResultTypedArrayDeclarations;\n\t\ttxU2 shift = resultDispatch->value.typedArray.dispatch->shift;\n\t\tif (resultLength < count)\n\t\t\tmxTypeError(\"insufficient TypedArray\");\n\t\twhile (index < count) {\n\t\t\t(*resultDispatch->value.typedArray.dispatch->coerce)(the, mxArgv(index));\n\t\t\tif (resultBuffer->value.arrayBuffer.address == C_NULL)\n\t\t\t\tmxTypeError(\"detached buffer\");\n\t\t\t(*resultDispatch->value.typedArray.dispatch->setter)(the, resultBuffer->value.reference->next, resultView->value.dataView.offset + (index << shift), mxArgv(index), EndianNative);\n\t\t\tindex++;\n\t\t}\n\t}\n}\n\nvoid fx_TypedArray_prototype_at(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\ttxInteger index = (mxArgc > 0) ? fxToInteger(the, mxArgv(0)) : 0;\n\tif (index < 0)\n\t\tindex = length + index;\n\tif ((0 <= index) && (index < length)) {\n\t\tmxPushSlot(mxThis);\n\t\tmxGetIndex(index);\n\t\tmxPullSlot(mxResult);\n\t}\n}\n\nvoid fx_TypedArray_prototype_buffer_get(txMachine* the)\n{\n\ttxSlot* instance = fxCheckTypedArrayInstance(the, mxThis);\n\ttxSlot* dispatch = instance->next;\n\ttxSlot* view = dispatch->next;\n\ttxSlot* buffer = view->next;\n\tmxResult->kind = buffer->kind;\n\tmxResult->value = buffer->value;\n}\n\nvoid fx_TypedArray_prototype_byteLength_get(txMachine* the)\n{\n\ttxSlot* instance = fxCheckTypedArrayInstance(the, mxThis);\n\ttxSlot* dispatch = instance->next;\n\ttxSlot* view = dispatch->next;\n\ttxSlot* buffer = view->next;\n\tmxResult->kind = XS_INTEGER_KIND;\n\tmxResult->value.integer = fxGetDataViewSize(the, view, buffer);\n}\n\nvoid fx_TypedArray_prototype_byteOffset_get(txMachine* the)\n{\n\ttxSlot* instance = fxCheckTypedArrayInstance(the, mxThis);\n\ttxSlot* dispatch = instance->next;\n\ttxSlot* view = dispatch->next;\n\ttxSlot* buffer = view->next;\n\ttxInteger offset = view->value.dataView.offset;\n\ttxInteger size = view->value.dataView.size;\n\ttxSlot* arrayBuffer = buffer->value.reference->next;\n\ttxSlot* bufferInfo = arrayBuffer->next;\n\tmxResult->kind = XS_INTEGER_KIND;\n\tmxResult->value.integer = 0;\n\tif (arrayBuffer->value.arrayBuffer.address == C_NULL)\n\t\treturn;\n\tif (bufferInfo->value.bufferInfo.maxLength >= 0) {\n\t\ttxInteger byteLength = bufferInfo->value.bufferInfo.length;\n\t\tif (offset > byteLength)\n\t\t\treturn;\n\t\tsize = (size < 0) ? byteLength : offset + size;\n\t\tif (size > byteLength)\n\t\t\treturn;\n\t\tsize -= offset;\n\t}\n\tmxResult->value.integer = offset;\n}\n\nvoid fx_TypedArray_prototype_copyWithin(txMachine* the)\n{\n\tmxMutableTypedArrayDeclarations;\n\ttxInteger delta = dispatch->value.typedArray.dispatch->size;\n\ttxInteger target = (txInteger)fxArgToIndex(the, 0, 0, length);\n\ttxInteger start = (txInteger)fxArgToIndex(the, 1, 0, length);\n\ttxInteger end = (txInteger)fxArgToIndex(the, 2, length, length);\n\ttxInteger count = end - start;\n\tfxCheckArrayBufferDetached(the, buffer, XS_MUTABLE);\n\tif (count > length - target)\n\t\tcount = length - target;\n\tif (count > 0) {\n\t\ttxByte* address = buffer->value.reference->next->value.arrayBuffer.address + view->value.dataView.offset;\n\t\tc_memmove(address + (target * delta), address + (start * delta), count * delta);\n\t\tmxMeterSome((txU4)count * 2);\n\t}\n\tmxResult->kind = mxThis->kind;\n\tmxResult->value = mxThis->value;\n}\n\nvoid fx_TypedArray_prototype_entries(txMachine* the)\n{\n\ttxSlot* instance = fxCheckTypedArrayInstance(the, mxThis);\n\ttxSlot* dispatch = instance->next;\n\ttxSlot* view = dispatch->next;\n\ttxSlot* buffer = view->next;\n\ttxSlot* property;\n\tfxCheckDataViewSize(the, view, buffer, XS_IMMUTABLE);\n\tmxPush(mxArrayIteratorPrototype);\n\tproperty = fxLastProperty(the, fxNewIteratorInstance(the, mxThis, mxID(_Array)));\n\tproperty = fxNextIntegerProperty(the, property, 2, XS_NO_ID, XS_INTERNAL_FLAG);\n\tmxPullSlot(mxResult);\n}\n\nvoid fx_TypedArray_prototype_every(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\ttxSlot* function = fxArgToCallback(the, 0);\n\ttxInteger index = 0;\n\tmxResult->kind = XS_BOOLEAN_KIND;\n\tmxResult->value.boolean = 1;\n\twhile (index < length) {\n\t\tfxCallTypedArrayItem(the, function, dispatch, view, buffer->value.reference->next, index, C_NULL);\n\t\tmxResult->value.boolean = fxToBoolean(the, the->stack++);\n\t\tif (!mxResult->value.boolean)\n\t\t\tbreak;\n\t\tindex++;\n\t}\n}\n\nvoid fx_TypedArray_prototype_fill(txMachine* the)\n{\n\tmxMutableTypedArrayDeclarations;\n\ttxInteger delta = dispatch->value.typedArray.dispatch->size;\n\ttxInteger start = (txInteger)fxArgToIndex(the, 1, 0, length);\n\ttxInteger end = (txInteger)fxArgToIndex(the, 2, length, length);\n\tstart *= delta;\n\tend *= delta;\n\tstart += view->value.dataView.offset;\n\tend += view->value.dataView.offset;\n\tif (mxArgc > 0)\n\t\tmxPushSlot(mxArgv(0));\n\telse\n\t\tmxPushUndefined();\n\t(*dispatch->value.typedArray.dispatch->coerce)(the, the->stack);\n\tfxCheckDataViewSize(the, view, buffer, XS_MUTABLE);\n\twhile (start < end) {\n\t\t(*dispatch->value.typedArray.dispatch->setter)(the, buffer->value.reference->next, start, the->stack, EndianNative);\n\t\tstart += delta;\n\t}\n\tmxPop();\n\tmxResult->kind = mxThis->kind;\n\tmxResult->value = mxThis->value;\n}\n\nvoid fx_TypedArray_prototype_filter(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\ttxSlot* function = fxArgToCallback(the, 0);\n\ttxSlot* list = fxNewInstance(the);\n\ttxSlot* slot = list;\n\ttxInteger count = 0;\n\ttxInteger index = 0;\n\tmxPushUndefined();\n\twhile (index < length) {\n\t\tfxCallTypedArrayItem(the, function, dispatch, view, buffer->value.reference->next, index, the->stack);\n\t\tif (fxToBoolean(the, the->stack++)) {\n\t\t\tcount++;\n\t\t\tslot = fxNextSlotProperty(the, slot, the->stack, XS_NO_ID, XS_NO_FLAG);\n\t\t}\n\t\tindex++;\n\t}\n\tmxPop();\n\tfxCreateTypedArraySpecies(the);\n\tmxPushNumber(count);\n\tmxRunCount(1);\n\tmxPullSlot(mxResult);\n\t{\n\t\tmxResultTypedArrayDeclarations;\n\t\ttxInteger resultOffset = 0;\n\t\ttxInteger resultSize = resultDispatch->value.typedArray.dispatch->size;\n\t\tif (resultLength < count)\n\t\t\tmxTypeError(\"insufficient buffer\");\n\t\tslot = list->next;\n\t\twhile (slot) {\n\t\t\t(*resultDispatch->value.typedArray.dispatch->coerce)(the, slot);\n\t\t\t(*resultDispatch->value.typedArray.dispatch->setter)(the, resultBuffer->value.reference->next, resultOffset, slot, EndianNative);\n\t\t\tresultOffset += resultSize;\n\t\t\tslot = slot->next;\n\t\t}\n\t}\n\tmxPop();\n}\n\nvoid fx_TypedArray_prototype_find(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\ttxSlot* function = fxArgToCallback(the, 0);\n\ttxInteger index = 0;\n\tmxPushUndefined();\n\twhile (index < length) {\n\t\tfxCallTypedArrayItem(the, function, dispatch, view, buffer->value.reference->next, index, the->stack);\n\t\tif (fxToBoolean(the, the->stack++)) {\n\t\t\tmxResult->kind = the->stack->kind;\n\t\t\tmxResult->value = the->stack->value;\n\t\t\tbreak;\n\t\t}\n\t\tindex++;\n\t}\n\tmxPop();\n}\n\nvoid fx_TypedArray_prototype_findIndex(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\ttxSlot* function = fxArgToCallback(the, 0);\n\ttxInteger index = 0;\n\tmxResult->kind = XS_INTEGER_KIND;\n\tmxResult->value.integer = -1;\n\twhile (index < length) {\n\t\tfxCallTypedArrayItem(the, function, dispatch, view, buffer->value.reference->next, index, C_NULL);\n\t\tif (fxToBoolean(the, the->stack++)) {\n\t\t\tmxResult->value.integer = index;\n\t\t\tbreak;\n\t\t}\n\t\tindex++;\n\t}\n}\n\nvoid fx_TypedArray_prototype_findLast(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\ttxSlot* function = fxArgToCallback(the, 0);\n\ttxInteger index = length;\n\tmxPushUndefined();\n\twhile (index > 0) {\n\t\tindex--;\n\t\tfxCallTypedArrayItem(the, function, dispatch, view, buffer->value.reference->next, index, the->stack);\n\t\tif (fxToBoolean(the, the->stack++)) {\n\t\t\tmxResult->kind = the->stack->kind;\n\t\t\tmxResult->value = the->stack->value;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmxPop();\n}\n\nvoid fx_TypedArray_prototype_findLastIndex(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\ttxSlot* function = fxArgToCallback(the, 0);\n\ttxInteger index = length;\n\tmxResult->kind = XS_INTEGER_KIND;\n\tmxResult->value.integer = -1;\n\twhile (index > 0) {\n\t\tindex--;\n\t\tfxCallTypedArrayItem(the, function, dispatch, view, buffer->value.reference->next, index, C_NULL);\n\t\tif (fxToBoolean(the, the->stack++)) {\n\t\t\tmxResult->value.integer = index;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid fx_TypedArray_prototype_forEach(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\ttxSlot* function = fxArgToCallback(the, 0);\n\ttxInteger index = 0;\n\twhile (index < length) {\n\t\tfxCallTypedArrayItem(the, function, dispatch, view, buffer->value.reference->next, index, C_NULL);\n\t\tmxPop();\n\t\tindex++;\n\t}\n}\n\nvoid fx_TypedArray_prototype_includes(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\tfxBoolean(the, mxResult, 0);\n\tif (length) {\n\t\ttxInteger index = (txInteger)fxArgToIndex(the, 1, 0, length);\n\t\ttxSlot* argument;\n\t\tif (mxArgc > 0)\n\t\t\tmxPushSlot(mxArgv(0));\n\t\telse\n\t\t\tmxPushUndefined();\n\t\targument = the->stack;\n\t\twhile (index < length) {\n\t\t\tmxPushSlot(mxThis);\n\t\t\tmxGetIndex(index);\n\t\t\tif (fxIsSameValue(the, the->stack++, argument, 1)) {\n\t\t\t\tmxResult->value.boolean = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\tmxPop();\n\t}\n}\n\nvoid fx_TypedArray_prototype_indexOf(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\tfxInteger(the, mxResult, -1);\n\tif (length) {\n\t\ttxInteger index = (txInteger)fxArgToIndex(the, 1, 0, length);\n\t\ttxSlot* argument;\n\t\tif (mxArgc > 0)\n\t\t\tmxPushSlot(mxArgv(0));\n\t\telse\n\t\t\tmxPushUndefined();\n\t\targument = the->stack;\n\t\twhile (index < length) {\n\t\t\tmxPushSlot(mxThis);\n\t\t\tif (fxHasIndex(the, index)) {\n\t\t\t\tmxPushSlot(mxThis);\n\t\t\t\tmxGetIndex(index);\n\t\t\t\tif (fxIsSameSlot(the, the->stack++, argument)) {\n\t\t\t\t\tmxResult->value.integer = index;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\tmxPop();\n\t}\n}\n\nvoid fx_TypedArray_prototype_join(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\ttxInteger delta = dispatch->value.typedArray.dispatch->size;\n\ttxInteger offset = view->value.dataView.offset;\n\ttxInteger limit = offset + (length << dispatch->value.typedArray.dispatch->shift);\n\ttxString string;\n\ttxSlot* list = fxNewInstance(the);\n\ttxSlot* slot = list;\n\ttxBoolean comma = 0;\n\ttxInteger size = 0;\n\tif ((mxArgc > 0) && (mxArgv(0)->kind != XS_UNDEFINED_KIND)) {\n\t\tmxPushSlot(mxArgv(0));\n\t\tstring = fxToString(the, the->stack);\n\t\tthe->stack->kind += XS_KEY_KIND - XS_STRING_KIND;\n\t\tthe->stack->value.key.sum = mxStringLength(the->stack->value.string);\n\t}\n\telse {\n\t\tmxPushStringX(\",\");\n\t\tthe->stack->kind += XS_KEY_KIND - XS_STRING_KIND;\n\t\tthe->stack->value.key.sum = 1;\n\t}\n\tlength = offset + fxGetDataViewSize(the, view, buffer);\n\twhile (offset < limit) {\n\t\tif (comma) {\n\t\t\tslot = fxNextSlotProperty(the, slot, the->stack, XS_NO_ID, XS_NO_FLAG);\n            size = fxAddChunkSizes(the, size, slot->value.key.sum);\n\t\t}\n\t\telse\n\t\t\tcomma = 1;\n\t\tif (offset < length) {\n\t\t\tmxPushUndefined();\n\t\t\t(*dispatch->value.typedArray.dispatch->getter)(the, buffer->value.reference->next, offset, the->stack, EndianNative);\n\t\t\tslot = fxNextSlotProperty(the, slot, the->stack, XS_NO_ID, XS_NO_FLAG);\n\t\t\tstring = fxToString(the, slot);\n\t\t\tslot->kind += XS_KEY_KIND - XS_STRING_KIND;\n\t\t\tslot->value.key.sum = mxStringLength(string);\n\t\t\tsize = fxAddChunkSizes(the, size, slot->value.key.sum);\n\t\t\tmxPop();\n\t\t}\n\t\toffset += delta;\n\t}\n\tmxPop();\n\tstring = mxResult->value.string = fxNewChunk(the, fxAddChunkSizes(the, size, 1));\n\tslot = list->next;\n\twhile (slot) {\n\t\tc_memcpy(string, slot->value.key.string, slot->value.key.sum);\n\t\tstring += slot->value.key.sum;\n\t\tslot = slot->next;\n\t}\n\t*string = 0;\n\tmxResult->kind = XS_STRING_KIND;\n\tmxPop();\n}\n\nvoid fx_TypedArray_prototype_keys(txMachine* the)\n{\n\ttxSlot* instance = fxCheckTypedArrayInstance(the, mxThis);\n\ttxSlot* dispatch = instance->next;\n\ttxSlot* view = dispatch->next;\n\ttxSlot* buffer = view->next;\n\ttxSlot* property;\n\tfxCheckDataViewSize(the, view, buffer, XS_IMMUTABLE);\n\tmxPush(mxArrayIteratorPrototype);\n\tproperty = fxLastProperty(the, fxNewIteratorInstance(the, mxThis, mxID(_Array)));\n\tproperty = fxNextIntegerProperty(the, property, 1, XS_NO_ID, XS_INTERNAL_FLAG);\n\tmxPullSlot(mxResult);\n}\n\nvoid fx_TypedArray_prototype_lastIndexOf(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\tfxInteger(the, mxResult, -1);\n\tif (length) {\n\t\ttxIndex index = (txIndex)fxArgToLastIndex(the, 1, length, length);\n\t\ttxSlot* argument;\n\t\tif (mxArgc > 0)\n\t\t\tmxPushSlot(mxArgv(0));\n\t\telse\n\t\t\tmxPushUndefined();\n\t\targument = the->stack;\n\t\twhile (index > 0) {\n\t\t\tindex--;\n\t\t\tmxPushSlot(mxThis);\n\t\t\tif (fxHasIndex(the, index)) {\n\t\t\t\tmxPushSlot(mxThis);\n\t\t\t\tmxGetIndex(index);\n\t\t\t\tif (fxIsSameSlot(the, the->stack++, argument)) {\n\t\t\t\t\tmxResult->value.integer = index;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmxPop();\n\t}\n}\n\nvoid fx_TypedArray_prototype_length_get(txMachine* the)\n{\n\ttxSlot* instance = fxCheckTypedArrayInstance(the, mxThis);\n\ttxSlot* dispatch = instance->next;\n\ttxSlot* view = dispatch->next;\n\ttxSlot* buffer = view->next;\n\ttxU2 shift = dispatch->value.typedArray.dispatch->shift;\n\tmxResult->kind = XS_INTEGER_KIND;\n\tmxResult->value.integer = fxGetDataViewSize(the, view, buffer) >> shift;\n}\n\nvoid fx_TypedArray_prototype_map(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\ttxSlot* function = fxArgToCallback(the, 0);\n\tfxCreateTypedArraySpecies(the);\n\tmxPushNumber(length);\n\tmxRunCount(1);\n\tmxPullSlot(mxResult);\n\t{\n\t\tmxResultTypedArrayDeclarations;\n\t\ttxU2 shift = resultDispatch->value.typedArray.dispatch->shift;\n\t\ttxInteger index = 0;\n\t\tif (resultLength < length)\n\t\t\tmxTypeError(\"insufficient buffer\");\n\t\twhile (index < length) {\n\t\t\tfxCallTypedArrayItem(the, function, dispatch, view, buffer->value.reference->next, index, C_NULL);\n\t\t\tif (resultBuffer->value.arrayBuffer.address == C_NULL)\n\t\t\t\tmxTypeError(\"detached buffer\");\n\t\t\t(*resultDispatch->value.typedArray.dispatch->coerce)(the, the->stack);\n\t\t\t(*resultDispatch->value.typedArray.dispatch->setter)(the, resultBuffer->value.reference->next, resultView->value.dataView.offset + (index << shift), the->stack, EndianNative);\n\t\t\tmxPop();\n\t\t\tindex++;\n\t\t}\n\t}\n}\n\nvoid fx_TypedArray_prototype_reduce(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\ttxSlot* function = fxArgToCallback(the, 0);\n\ttxInteger index = 0;\n\tif (mxArgc > 1)\n\t\t*mxResult = *mxArgv(1);\n\telse if (index < length) {\n\t\t(*dispatch->value.typedArray.dispatch->getter)(the, buffer->value.reference->next, view->value.dataView.offset, mxResult, EndianNative);\n\t\tindex++;\n\t}\n\telse\n\t\tmxTypeError(\"no initial value\");\n\twhile (index < length) {\n\t\tfxReduceTypedArrayItem(the, function, dispatch, view, buffer->value.reference->next, index);\n\t\tindex++;\n\t}\n}\n\nvoid fx_TypedArray_prototype_reduceRight(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\ttxInteger delta = dispatch->value.typedArray.dispatch->size;\n\ttxSlot* function = fxArgToCallback(the, 0);\n\ttxInteger index = length - 1;\n\tif (mxArgc > 1)\n\t\t*mxResult = *mxArgv(1);\n\telse if (index >= 0) {\n\t\t(*dispatch->value.typedArray.dispatch->getter)(the, buffer->value.reference->next, view->value.dataView.offset + (index * delta), mxResult, EndianNative);\n\t\tindex--;\n\t}\n\telse\n\t\tmxTypeError(\"no initial value\");\n\twhile (index >= 0) {\n\t\tfxReduceTypedArrayItem(the, function, dispatch, view, buffer->value.reference->next, index);\n\t\tindex--;\n\t}\n}\n\nvoid fx_TypedArray_prototype_reverse(txMachine* the)\n{\n\tmxMutableTypedArrayDeclarations;\n\ttxInteger delta = dispatch->value.typedArray.dispatch->size;\n\tif (length) {\n\t\ttxByte tmp;\n\t\ttxByte* first = buffer->value.reference->next->value.arrayBuffer.address + view->value.dataView.offset;\n\t\ttxByte* last = first + (length << dispatch->value.typedArray.dispatch->shift) - delta;\n\t\ttxInteger offset;\n\t\twhile (first < last) {\n\t\t\tfor (offset = 0; offset < delta; offset++) {\n\t\t\t\ttmp = last[offset];\n\t\t\t\tlast[offset] = first[offset];\n\t\t\t\tfirst[offset] = tmp;\n\t\t\t}\n\t\t\tfirst += delta;\n\t\t\tlast -= delta;\n\t\t}\n\t\tmxMeterSome(length * 4);\n\t}\n\tmxResult->kind = mxThis->kind;\n\tmxResult->value = mxThis->value;\n}\n\nvoid fx_TypedArray_prototype_set(txMachine* the)\n{\n\tmxMutableTypedArrayDeclarations;\n\ttxSlot* data = buffer->value.reference->next;\n\ttxInteger delta = dispatch->value.typedArray.dispatch->size;\n\ttxSlot* source = fxArgToInstance(the, 0);\n\ttxInteger target = fxArgToByteLength(the, 1, 0);\n\ttxInteger offset = view->value.dataView.offset + (target * delta);\t\n\tif (source->next && (source->next->kind == XS_TYPED_ARRAY_KIND)) {\n\t\ttxSlot* sourceDispatch = source->next;\n\t\ttxSlot* sourceView = sourceDispatch->next;\n\t\ttxSlot* sourceBuffer = sourceView->next;\n\t\ttxU2 shift = sourceDispatch->value.typedArray.dispatch->shift;\n\t\ttxInteger sourceLength = fxCheckDataViewSize(the, sourceView, sourceBuffer, XS_IMMUTABLE) >> shift;\n\t\ttxInteger sourceOffset = sourceView->value.dataView.offset;\t\n\t\ttxSlot* sourceData = sourceBuffer->value.reference->next;\n\t\ttxInteger limit = offset + (sourceLength * delta);\n\t\tif ((target < 0) || (length - sourceLength < target))\n\t\t\tmxRangeError(\"invalid offset\");\n\t\tif (data == sourceData) {\n\t\t\ttxSlot* resultBuffer;\n\t\t\tmxPush(mxArrayBufferConstructor);\n\t\t\tmxNew();\n\t\t\tmxPushInteger(sourceLength << shift);\n\t\t\tmxRunCount(1);\n\t\t\tresultBuffer = the->stack->value.reference->next;\n\t\t\tc_memcpy(resultBuffer->value.arrayBuffer.address, sourceData->value.arrayBuffer.address + sourceOffset, sourceLength << shift);\n\t\t\tsourceData = resultBuffer;\n\t\t\tsourceOffset = 0;\n\t\t}\n\t\telse \n\t\t\tmxPushUndefined();\n\t\tif (dispatch == sourceDispatch) {\n\t\t\tc_memcpy(data->value.arrayBuffer.address + offset, sourceData->value.arrayBuffer.address + sourceOffset, limit - offset);\n\t\t\tmxMeterSome(((txU4)(limit - offset)) * 2);\n\t\t}\n\t\telse {\n\t\t\ttxInteger sourceDelta = 1 << shift;\n\t\t\tmxPushUndefined();\n\t\t\twhile (offset < limit) {\n\t\t\t\t(*sourceDispatch->value.typedArray.dispatch->getter)(the, sourceData, sourceOffset, the->stack, EndianNative);\n\t\t\t\t(*dispatch->value.typedArray.dispatch->coerce)(the, the->stack);\n                if (data->value.arrayBuffer.address == C_NULL)\n                    mxTypeError(\"detached buffer\");\n\t\t\t\t(*dispatch->value.typedArray.dispatch->setter)(the, data, offset, the->stack, EndianNative);\n\t\t\t\tsourceOffset += sourceDelta;\n\t\t\t\toffset += delta;\n\t\t\t}\n\t\t\tmxPop();\n\t\t}\n\t\tmxPop();\n\t}\n\telse {\n\t\ttxInteger count, index;\n\t\tmxPushSlot(mxArgv(0));\n\t\tmxGetID(mxID(_length));\n\t\tcount = fxToInteger(the, the->stack);\n\t\tmxPop();\n\t\tif ((target < 0) || (length - count < target))\n\t\t\tmxRangeError(\"invalid offset\");\n\t\tindex = 0;\n\t\twhile (index < count) {\n\t\t\tmxPushSlot(mxArgv(0));\n\t\t\tmxGetIndex(index);\n\t\t\t(*dispatch->value.typedArray.dispatch->coerce)(the, the->stack);\n\t\t\tif (data->value.arrayBuffer.address == C_NULL)\n\t\t\t\tmxTypeError(\"detached buffer\");\n\t\t\t(*dispatch->value.typedArray.dispatch->setter)(the, data, offset, the->stack, EndianNative);\n\t\t\tmxPop();\n\t\t\toffset += delta;\n\t\t\tindex++;\n\t\t}\t\n\t}\n}\n\nvoid fx_TypedArray_prototype_slice(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\ttxInteger delta = dispatch->value.typedArray.dispatch->size;\n\ttxInteger start = (txInteger)fxArgToIndex(the, 0, 0, length);\n\ttxInteger end = (txInteger)fxArgToIndex(the, 1, length, length);\n\ttxInteger count = (end > start) ? end - start : 0;\n\ttxInteger index = 0;\n\tfxCreateTypedArraySpecies(the);\n\tmxPushNumber(count);\n\tmxRunCount(1);\n\tmxPullSlot(mxResult);\n\t{\n\t\tmxResultTypedArrayDeclarations;\n\t\tif (resultLength < count)\n\t\t\tmxTypeError(\"insufficient buffer\");\n\t\tif (count) {\n\t\t\tlength = fxCheckDataViewSize(the, view, buffer, XS_IMMUTABLE);\n\t\t\tmxPushUndefined();\n\t\t\twhile ((start < length) && (start < end)) {\n\t\t\t\t(*dispatch->value.typedArray.dispatch->getter)(the, buffer->value.reference->next, view->value.dataView.offset + (start * delta), the->stack, EndianNative);\n\t\t\t\t(*resultDispatch->value.typedArray.dispatch->coerce)(the, the->stack);\n\t\t\t\t(*resultDispatch->value.typedArray.dispatch->setter)(the, resultBuffer->value.reference->next, resultView->value.dataView.offset + (index << resultDispatch->value.typedArray.dispatch->shift), the->stack, EndianNative);\n\t\t\t\tstart++;\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\twhile (start < end) {\n\t\t\t\tthe->stack->kind = XS_UNDEFINED_KIND;\n\t\t\t\t(*resultDispatch->value.typedArray.dispatch->coerce)(the, the->stack);\n\t\t\t\t(*resultDispatch->value.typedArray.dispatch->setter)(the, resultBuffer->value.reference->next, resultView->value.dataView.offset + (index << resultDispatch->value.typedArray.dispatch->shift), the->stack, EndianNative);\n\t\t\t\tstart++;\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\tmxPop();\n\t\t}\n\t}\n}\n\nvoid fx_TypedArray_prototype_some(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\ttxSlot* function = fxArgToCallback(the, 0);\n\ttxInteger index = 0;\n\tmxResult->kind = XS_BOOLEAN_KIND;\n\tmxResult->value.boolean = 0;\n\twhile (index < length) {\n\t\tfxCallTypedArrayItem(the, function, dispatch, view, buffer->value.reference->next, index, C_NULL);\n\t\tmxResult->value.boolean = fxToBoolean(the, the->stack++);\n\t\tif (mxResult->value.boolean)\n\t\t\tbreak;\n\t\tindex++;\n\t}\n}\n\nvoid fx_TypedArray_prototype_sort(txMachine* the)\n{\n\tmxMutableTypedArrayDeclarations;\n\ttxSlot* data = buffer->value.reference->next;\n\ttxInteger delta = dispatch->value.typedArray.dispatch->size;\n\ttxSlot* function = C_NULL;\n\tif (mxArgc > 0) {\n\t\ttxSlot* slot = mxArgv(0);\n\t\tif (slot->kind != XS_UNDEFINED_KIND) {\n\t\t\tif (fxIsCallable(the, slot))\n\t\t\t\tfunction = slot;\n\t\t\telse\n\t\t\t\tmxTypeError(\"compare is no function\");\n\t\t}\n\t}\n\tif (function) {\n\t\t/* like GCC qsort */\n\t\t#define COMPARE(INDEX) \\\n\t\t\tfxCompareTypedArrayItem(the, function, dispatch, view, data, INDEX)\n\t\t#define MOVE(FROM,TO) \\\n\t\t\tfrom = data->value.arrayBuffer.address + view->value.dataView.offset + ((FROM) * delta); \\\n\t\t\tto = data->value.arrayBuffer.address + view->value.dataView.offset + ((TO) * delta); \\\n\t\t\tfor (k = 0; k < delta; k++) *to++ = *from++\n\t\t#define PUSH(INDEX) \\\n\t\t\tmxPushUndefined(); \\\n\t\t\t(*dispatch->value.typedArray.dispatch->getter)(the, data, view->value.dataView.offset + ((INDEX) * delta), the->stack, EndianNative)\n\t\t#define PULL(INDEX) \\\n\t\t\t(*dispatch->value.typedArray.dispatch->setter)(the, data, view->value.dataView.offset + ((INDEX) * delta), the->stack++, EndianNative)\n\t\tif (length > 0) {\n\t\t\ttxInteger i, j, k;\n\t\t\ttxByte* from;\n\t\t\ttxByte* to;\n\t\t\tif (length > mxSortThreshold) {\n\t\t\t\ttxInteger lo = 0, hi = length - 1;\n\t\t\t\ttxSortPartition stack[mxSortPartitionCount];\n\t\t\t\ttxSortPartition *top = stack + 1;\n\t\t\t\twhile (stack < top) {\n\t\t\t\t\ttxIndex mid = lo + ((hi - lo) >> 1);\n\t\t\t\t\tPUSH(mid);\n\t\t\t\t\tif (COMPARE(lo) > 0) {\n\t\t\t\t\t\tMOVE(lo, mid);\n\t\t\t\t\t\tPULL(lo);\n\t\t\t\t\t\tPUSH(mid);\n\t\t\t\t\t}\n\t\t\t\t\tif (COMPARE(hi) < 0) {\n\t\t\t\t\t\tMOVE(hi, mid);\n\t\t\t\t\t\tPULL(hi);\n\t\t\t\t\t\tPUSH(mid);\n\t\t\t\t\t\tif (COMPARE(lo) > 0) {\n\t\t\t\t\t\t\tMOVE(lo, mid);\n\t\t\t\t\t\t\tPULL(lo);\n\t\t\t\t\t\t\tPUSH(mid);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti = lo + 1;\n\t\t\t\t\tj = hi - 1;\n\t\t\t\t\tdo {\n\t\t\t\t\t\twhile ((COMPARE(i) < 0) && (i <= j)) i++;\n\t\t\t\t\t\twhile ((COMPARE(j) > 0) && (i <= j)) j--;\n\t\t\t\t\t\tif (i < j) {\n\t\t\t\t\t\t\tPUSH(i);\n\t\t\t\t\t\t\tMOVE(j, i);\n\t\t\t\t\t\t\tPULL(j);\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\tj--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (i == j) {\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\tj--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (i <= j);\n\t\t\t\t\tif ((j - lo) <= mxSortThreshold) {\n\t\t\t\t\t\tif ((hi - i) <= mxSortThreshold) {\n\t\t\t\t\t\t\ttop--;\n\t\t\t\t\t\t\tlo = top->lo; \n\t\t\t\t\t\t\thi = top->hi;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlo = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ((hi - i) <= mxSortThreshold) {\n\t\t\t\t\t\thi = j;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((j - lo) > (hi - i)) {\n\t\t\t\t\t\ttop->lo = lo;\n\t\t\t\t\t\ttop->hi = j; \n\t\t\t\t\t\ttop++;\n\t\t\t\t\t\tlo = i;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttop->lo = i;\n\t\t\t\t\t\ttop->hi = hi; \n\t\t\t\t\t\ttop++;\n\t\t\t\t\t\thi = j;\n\t\t\t\t\t}\n\t\t\t\t\tmxPop();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 1; i < length; i++) {\n\t\t\t\tPUSH(i);\n\t\t\t\tfor (j = i; (j > 0) && (COMPARE(j - 1) > 0); j--) {\n\t\t\t\t\tMOVE(j - 1, j);\n\t\t\t\t}\t\n\t\t\t\tPULL(j);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\tc_qsort(data->value.arrayBuffer.address, length, delta, dispatch->value.typedArray.dispatch->compare);\n\tmxResult->kind = mxThis->kind;\n\tmxResult->value = mxThis->value;\n}\n\nvoid fx_TypedArray_prototype_subarray(txMachine* the)\n{\n\ttxSlot* instance = fxCheckTypedArrayInstance(the, mxThis);\n\ttxSlot* dispatch = instance->next;\n\ttxSlot* view = dispatch->next;\n\ttxSlot* buffer = view->next;\n\ttxU2 shift = dispatch->value.typedArray.dispatch->shift;\n\ttxInteger length = fxGetDataViewSize(the, view, buffer) >> shift;\n\ttxInteger start = (txInteger)fxArgToIndex(the, 0, 0, length);\n\ttxInteger stop = (txInteger)fxArgToIndex(the, 1, length, length);\n\tif (stop < start) \n\t\tstop = start;\n\tfxCreateTypedArraySpecies(the);\n\tmxPushSlot(buffer);\n\tmxPushInteger(view->value.dataView.offset + (start << shift));\n\tmxPushInteger(stop - start);\n\tmxRunCount(3);\n\tmxPullSlot(mxResult);\n\tfxCheckTypedArrayInstance(the, mxResult);\n}\n\nvoid fx_TypedArray_prototype_toLocaleString(txMachine* the)\n{\n\tmxTypedArrayDeclarations;\n\ttxInteger index = 0;\n\ttxString string;\n\ttxSlot* list = fxNewInstance(the);\n\ttxSlot* slot = list;\n\ttxBoolean comma = 0;\n\ttxInteger size = 0;\n\tmxPushStringX(\",\");\n\tthe->stack->kind += XS_KEY_KIND - XS_STRING_KIND;\n\tthe->stack->value.key.sum = 1;\n\twhile (index < length) {\n\t\tif (comma) {\n\t\t\tslot = fxNextSlotProperty(the, slot, the->stack, XS_NO_ID, XS_NO_FLAG);\n\t\t\tsize += slot->value.key.sum;\n\t\t}\n\t\telse\n\t\t\tcomma = 1;\n\t\tmxPushSlot(mxThis);\n\t\tmxGetIndex(index);\n\t\tif ((the->stack->kind != XS_UNDEFINED_KIND) && (the->stack->kind != XS_NULL_KIND)) {\n\t\t\tmxDub();\n\t\t\tmxGetID(mxID(_toLocaleString));\n\t\t\tmxCall();\n\t\t\tmxRunCount(0);\n\t\t\tslot = fxNextSlotProperty(the, slot, the->stack, XS_NO_ID, XS_NO_FLAG);\n\t\t\tstring = fxToString(the, slot);\n\t\t\tslot->kind += XS_KEY_KIND - XS_STRING_KIND;\n\t\t\tslot->value.key.sum = mxStringLength(string);\n\t\t\tsize = fxAddChunkSizes(the, size, slot->value.key.sum);\n\t\t}\n\t\tmxPop();\n\t\tindex++;\n\t}\n\tstring = mxResult->value.string = fxNewChunk(the, fxAddChunkSizes(the, size, 1));\n\tslot = list->next;\n\twhile (slot) {\n\t\tc_memcpy(string, slot->value.key.string, slot->value.key.sum);\n\t\tstring += slot->value.key.sum;\n\t\tslot = slot->next;\n\t}\n\t*string = 0;\n\tmxResult->kind = XS_STRING_KIND;\n\tmxPop();\n}\n\nvoid fx_TypedArray_prototype_toStringTag_get(txMachine* the)\n{\n\tif (mxThis->kind == XS_REFERENCE_KIND) {\n        txSlot* instance = mxThis->value.reference;\n        txSlot* slot = instance->next;\n\t\tif (slot && (slot->flag & XS_INTERNAL_FLAG) && (slot->kind == XS_TYPED_ARRAY_KIND)) {\n\t\t\ttxTypeDispatch *dispatch = instance->next->value.typedArray.dispatch;\n\t\t\ttxSlot* key = fxGetKey(the, mxID(dispatch->constructorID));\n\t\t\tif (key->kind == XS_KEY_X_KIND)\n\t\t\t\tmxResult->kind = XS_STRING_X_KIND;\n\t\t\telse\n\t\t\t\tmxResult->kind = XS_STRING_KIND;\n\t\t\tmxResult->value.string = key->value.key.string;\n\t\t}\n\t}\n}\n\nvoid fx_TypedArray_prototype_values(txMachine* the)\n{\n\ttxSlot* instance = fxCheckTypedArrayInstance(the, mxThis);\n\ttxSlot* dispatch = instance->next;\n\ttxSlot* view = dispatch->next;\n\ttxSlot* buffer = view->next;\n\ttxSlot* property;\n\tfxCheckDataViewSize(the, view, buffer, XS_IMMUTABLE);\n\tmxPush(mxArrayIteratorPrototype);\n\tproperty = fxLastProperty(the, fxNewIteratorInstance(the, mxThis, mxID(_Array)));\n\tproperty = fxNextIntegerProperty(the, property, 0, XS_NO_ID, XS_INTERNAL_FLAG);\n\tmxPullSlot(mxResult);\n}\n\n#if mxBigEndian\n\t#define mxEndianDouble_BtoN(a) (a)\n\t#define mxEndianFloat_BtoN(a) (a)\n\t#define mxEndianS64_BtoN(a) (a)\n\t#define mxEndianU64_BtoN(a) (a)\n\t#define mxEndianS32_BtoN(a) (a)\n\t#define mxEndianU32_BtoN(a) (a)\n\t#define mxEndianS16_BtoN(a) (a)\n\t#define mxEndianU16_BtoN(a) (a)\n\n\t#define mxEndianDouble_NtoB(a) (a)\n\t#define mxEndianFloat_NtoB(a) (a)\n\t#define mxEndianS64_NtoB(a) (a)\n\t#define mxEndianU64_NtoB(a) (a)\n\t#define mxEndianS32_NtoB(a) (a)\n\t#define mxEndianU32_NtoB(a) (a)\n\t#define mxEndianS16_NtoB(a) (a)\n\t#define mxEndianU16_NtoB(a) (a)\n#else\n\t#define mxEndianDouble_LtoN(a) (a)\n\t#define mxEndianFloat_LtoN(a) (a)\n\t#define mxEndianS64_LtoN(a) (a)\n\t#define mxEndianU64_LtoN(a) (a)\n\t#define mxEndianS32_LtoN(a) (a)\n\t#define mxEndianU32_LtoN(a) (a)\n\t#define mxEndianS16_LtoN(a) (a)\n\t#define mxEndianU16_LtoN(a) (a)\n\n\t#define mxEndianDouble_NtoL(a) (a)\n\t#define mxEndianFloat_NtoL(a) (a)\n\t#define mxEndianS64_NtoL(a) (a)\n\t#define mxEndianU64_NtoL(a) (a)\n\t#define mxEndianS32_NtoL(a) (a)\n\t#define mxEndianU32_NtoL(a) (a)\n\t#define mxEndianS16_NtoL(a) (a)\n\t#define mxEndianU16_NtoL(a) (a)\n#endif\n\n#if mxLittleEndian\n\t#define mxEndianDouble_BtoN(a) (mxEndianDouble_Swap(a))\n\t#define mxEndianFloat_BtoN(a) (mxEndianFloat_Swap(a))\n\t#define mxEndianS64_BtoN(a) ((txS8) mxEndian64_Swap(a))\n\t#define mxEndianU64_BtoN(a) ((txU8) mxEndian64_Swap(a))\n\t#define mxEndianS32_BtoN(a) ((txS4) mxEndian32_Swap(a))\n\t#define mxEndianU32_BtoN(a) ((txU4) mxEndian32_Swap(a))\n\t#define mxEndianS16_BtoN(a) ((txS2) mxEndian16_Swap(a))\n\t#define mxEndianU16_BtoN(a) ((txU2) mxEndian16_Swap(a))\n\n\t#define mxEndianDouble_NtoB(a) (mxEndianDouble_Swap(a))\n\t#define mxEndianFloat_NtoB(a) (mxEndianFloat_Swap(a))\n\t#define mxEndianS64_NtoB(a) ((txS8) mxEndian64_Swap(a))\n\t#define mxEndianU64_NtoB(a) ((txU8) mxEndian64_Swap(a))\n\t#define mxEndianS32_NtoB(a) ((txS4) mxEndian32_Swap(a))\n\t#define mxEndianU32_NtoB(a) ((txU4) mxEndian32_Swap(a))\n\t#define mxEndianS16_NtoB(a) ((txS2) mxEndian16_Swap(a))\n\t#define mxEndianU16_NtoB(a) ((txU2) mxEndian16_Swap(a))\n#else\n\t#define mxEndianDouble_LtoN(a) (mxEndianDouble_Swap(a))\n\t#define mxEndianFloat_LtoN(a) (mxEndianFloat_Swap(a))\n\t#define mxEndianS64_LtoN(a) ((txS8) mxEndian64_Swap(a))\n\t#define mxEndianU64_LtoN(a) ((txU8) mxEndian64_Swap(a))\n\t#define mxEndianS32_LtoN(a) ((txS4) mxEndian32_Swap(a))\n\t#define mxEndianU32_LtoN(a) ((txU4) mxEndian32_Swap(a))\n\t#define mxEndianS16_LtoN(a) ((txS2) mxEndian16_Swap(a))\n\t#define mxEndianU16_LtoN(a) ((txU2) mxEndian16_Swap(a))\n\n\t#define mxEndianDouble_NtoL(a) (mxEndianDouble_Swap(a))\n\t#define mxEndianFloat_NtoL(a) (mxEndianFloat_Swap(a))\n\t#define mxEndianS64_NtoL(a) ((txS8) mxEndian64_Swap(a))\n\t#define mxEndianU64_NtoL(a) ((txU8) mxEndian64_Swap(a))\n\t#define mxEndianS32_NtoL(a) ((txS4) mxEndian32_Swap(a))\n\t#define mxEndianU32_NtoL(a) ((txU4) mxEndian32_Swap(a))\n\t#define mxEndianS16_NtoL(a) ((txS2) mxEndian16_Swap(a))\n\t#define mxEndianU16_NtoL(a) ((txU2) mxEndian16_Swap(a))\n#endif\n\n#if defined(__GNUC__) || defined(__llvm__)\n\t#define mxEndian16_Swap(a) __builtin_bswap16(a)\n#else\n\tstatic txU2 mxEndian16_Swap(txU2 a)\n\t{\n\t\ttxU2 b;\n\t\ttxU1 *p1 = (txU1 *) &a, *p2 = (txU1 *) &b;\n\t\tint i;\n\t\tfor (i = 0; i < 2; i++)\n\t\t\tp2[i] = p1[1 - i];\n\t\treturn b;\n\t}\n#endif\n\n#if defined(__GNUC__) || defined(__llvm__)\n\t#define mxEndian32_Swap(a) __builtin_bswap32(a)\n#else\n\tstatic txU4 mxEndian32_Swap(txU4 a)\n\t{\n\t\ttxU4 b;\n\t\ttxU1 *p1 = (txU1 *) &a, *p2 = (txU1 *) &b;\n\t\tint i;\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tp2[i] = p1[3 - i];\n\t\treturn b;\n\t}\n#endif\n\n#if defined(__GNUC__) || defined(__llvm__)\n\t#define mxEndian64_Swap(a) __builtin_bswap64(a)\n#else\n\tstatic txU8 mxEndian64_Swap(txU8 a)\n\t{\n\t\ttxU4 b;\n\t\ttxU1 *p1 = (txU1 *) &a, *p2 = (txU1 *) &b;\n\t\tint i;\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tp2[i] = p1[7 - i];\n\t\treturn b;\n\t}\n#endif\n\nstatic float mxEndianFloat_Swap(float a)\n{\n#if defined(__GNUC__) || defined(__llvm__)\n\tuint32_t result = __builtin_bswap32(*(uint32_t *)&a);\n\treturn *(float *)&result;\n#else\n\tfloat b;\n\ttxU1 *p1 = (txU1 *) &a, *p2 = (txU1 *) &b;\n\tint i;\n\tfor (i = 0; i < 4; i++)\n\t\tp2[i] = p1[3 - i];\n\treturn b;\n#endif\n}\n\nstatic double mxEndianDouble_Swap(double a)\n{\n#if defined(__GNUC__) || defined(__llvm__)\n\tuint64_t result = __builtin_bswap64(*(uint64_t *)&a);\n\treturn *(double *)&result;\n#else\n\tdouble b;\n\ttxU1 *p1 = (txU1 *) &a, *p2 = (txU1 *) &b;\n\tint i;\n\tfor (i = 0; i < 8; i++)\n\t\tp2[i] = p1[7 - i];\n\treturn b;\n#endif\n}\n\n#define toNative(size, endian) mxEndian##size##_##endian##toN\n#define fromNative(size, endian) mxEndian##size##_Nto##endian\n#define IMPORT(size) (endian == EndianBig ? toNative(size, B)(value) : endian == EndianLittle ? toNative(size, L)(value) : (value))\n#define EXPORT(size) (endian == EndianBig ? fromNative(size, B)(value) : endian == EndianLittle ? toNative(size, L)(value) : (value))\n\nint fxBigInt64Compare(const void* p, const void* q)\n{\n\ttxS8 a = *((txS8*)p);\n\ttxS8 b = *((txS8*)q);\n\treturn (a < b) ? -1 : (a > b) ? 1 : 0;\n}\n\nvoid fxBigInt64Getter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\ttxS8 value;\n#ifdef mxMisalignedSettersCrash\n\tvalue = c_read32(data->value.arrayBuffer.address + offset);\n#else\n\tvalue = *((txS8*)(data->value.arrayBuffer.address + offset));\n#endif\n\tvalue = IMPORT(S64);\n\tfxFromBigInt64(the, slot, value);\n\tmxMeterOne();\n}\n\nvoid fxBigInt64Setter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\ttxS8 value = (txS8)fxToBigInt64(the, slot);\n#ifdef mxMisalignedSettersCrash\n\tvalue = EXPORT(S64);\n\tc_memcpy(data->value.arrayBuffer.address + offset, &value, sizeof(txS8));\n#else\n\t*((txS8*)(data->value.arrayBuffer.address + offset)) = EXPORT(S64);\n#endif\n\tmxMeterOne();\n}\n\nint fxBigUint64Compare(const void* p, const void* q)\n{\n\ttxU8 a = *((txU8*)p);\n\ttxU8 b = *((txU8*)q);\n\treturn (a < b) ? -1 : (a > b) ? 1 : 0;\n}\n\nvoid fxBigUint64Getter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\ttxU8 value;\n#ifdef mxMisalignedSettersCrash\n\tvalue = c_read32(data->value.arrayBuffer.address + offset);\n#else\n\tvalue = *((txU8*)(data->value.arrayBuffer.address + offset));\n#endif\n\tvalue = IMPORT(U64);\n\tfxFromBigUint64(the, slot, value);\n\tmxMeterOne();\n}\n\nvoid fxBigUint64Setter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\ttxU8 value = (txU8)fxToBigUint64(the, slot);\n#ifdef mxMisalignedSettersCrash\n\tvalue = EXPORT(U64);\n\tc_memcpy(data->value.arrayBuffer.address + offset, &value, sizeof(txU8));\n#else\n\t*((txU8*)(data->value.arrayBuffer.address + offset)) = EXPORT(U64);\n#endif\n\tmxMeterOne();\n}\n\nint fxFloat32Compare(const void* p, const void* q)\n{\n\tfloat a = *((float*)p);\n\tfloat b = *((float*)q);\n\tif (c_isnan(a)) {\n\t\tif (c_isnan(b)) \n\t\t\treturn 0;\n\t\treturn 1;\n\t}\n\tif (c_isnan(b))\n\t\treturn -1;\n\tif (a < b)\n\t\treturn -1;\n\tif (a > b)\n\t\treturn 1;\n\tif (a == 0) {\n\t\tif (c_signbit(a)) {\n\t\t\tif (c_signbit(b)) \n\t\t\t\treturn 0;\n\t\t\treturn -1;\n\t\t}\n\t\tif (c_signbit(b))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nvoid fxFloat32Getter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\tfloat value;\n\tslot->kind = XS_NUMBER_KIND;\n#ifdef mxMisalignedSettersCrash\n\tc_memcpy(&value, data->value.arrayBuffer.address + offset, sizeof(value));\n#else\n\tvalue = *((float*)(data->value.arrayBuffer.address + offset));\n#endif\n\tslot->value.number = IMPORT(Float);\n\tmxMeterOne();\n}\n\nvoid fxFloat32Setter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\tfloat value = (float)slot->value.number;\n#ifdef mxMisalignedSettersCrash\n\tvalue = EXPORT(Float);\n\tc_memcpy(data->value.arrayBuffer.address + offset, &value, sizeof(float));\n#else\n\t*((float*)(data->value.arrayBuffer.address + offset)) = EXPORT(Float);\n#endif\n\tmxMeterOne();\n}\n\nint fxFloat64Compare(const void* p, const void* q)\n{\n\tdouble a = *((double*)p);\n\tdouble b = *((double*)q);\n\tif (c_isnan(a)) {\n\t\tif (c_isnan(b)) \n\t\t\treturn 0;\n\t\treturn 1;\n\t}\n\tif (c_isnan(b))\n\t\treturn -1;\n\tif (a < b)\n\t\treturn -1;\n\tif (a > b)\n\t\treturn 1;\n\tif (a == 0) {\n\t\tif (c_signbit(a)) {\n\t\t\tif (c_signbit(b)) \n\t\t\t\treturn 0;\n\t\t\treturn -1;\n\t\t}\n\t\tif (c_signbit(b))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nvoid fxFloat64Getter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\tdouble value;\n\tslot->kind = XS_NUMBER_KIND;\n#ifdef mxMisalignedSettersCrash\n\tc_memcpy(&value, data->value.arrayBuffer.address + offset, sizeof(value));\n#else\n\tvalue = *((double*)(data->value.arrayBuffer.address + offset));\n#endif\n\tslot->value.number = IMPORT(Double);\n\tmxMeterOne();\n}\n\nvoid fxFloat64Setter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\tdouble value = slot->value.number;\n#ifdef mxMisalignedSettersCrash\n\tvalue = EXPORT(Double);\n\tc_memcpy(data->value.arrayBuffer.address + offset, &value, sizeof(double));\n#else\n\t*((double*)(data->value.arrayBuffer.address + offset)) = EXPORT(Double);\n#endif\n\tmxMeterOne();\n}\n\nvoid fxIntCoerce(txMachine* the, txSlot* slot)\n{\n\tfxToInteger(the, slot);\n}\n\nvoid fxUintCoerce(txMachine* the, txSlot* slot)\n{\n\tfxToUnsigned(the, slot);\n}\n\nint fxInt8Compare(const void* p, const void* q)\n{\n\ttxS1 a = *((txS1*)p);\n\ttxS1 b = *((txS1*)q);\n\treturn (a < b) ? -1 : (a > b) ? 1 : 0;\n}\n\nvoid fxInt8Getter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\tslot->kind = XS_INTEGER_KIND;\n\tslot->value.integer = *((txS1*)(data->value.arrayBuffer.address + offset));\n\tmxMeterOne();\n}\n\nvoid fxInt8Setter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\t*((txS1*)(data->value.arrayBuffer.address + offset)) = (txS1)slot->value.integer;\n\tmxMeterOne();\n}\n\nint fxInt16Compare(const void* p, const void* q)\n{\n\ttxS2 a = *((txS2*)p);\n\ttxS2 b = *((txS2*)q);\n\treturn (a < b) ? -1 : (a > b) ? 1 : 0;\n}\n\nvoid fxInt16Getter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\ttxS2 value;\n\tslot->kind = XS_INTEGER_KIND;\n#ifdef mxMisalignedSettersCrash\n\tc_memcpy(&value, data->value.arrayBuffer.address + offset, sizeof(value));\n#else\n\tvalue = *((txS2*)(data->value.arrayBuffer.address + offset));\n#endif\n\tslot->value.integer = IMPORT(S16);\n\tmxMeterOne();\n}\n\nvoid fxInt16Setter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\ttxS2 value = (txS2)slot->value.integer;\n#ifdef mxMisalignedSettersCrash\n\tvalue = EXPORT(S16);\n\tc_memcpy(data->value.arrayBuffer.address + offset, &value, sizeof(txS2));\n#else\n\t*((txS2*)(data->value.arrayBuffer.address + offset)) = EXPORT(S16);\n#endif\n\tmxMeterOne();\n}\n\nint fxInt32Compare(const void* p, const void* q)\n{\n\ttxS4 a = *((txS4*)p);\n\ttxS4 b = *((txS4*)q);\n\treturn (a < b) ? -1 : (a > b) ? 1 : 0;\n}\n\nvoid fxInt32Getter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\ttxS4 value;\n\tslot->kind = XS_INTEGER_KIND;\n#ifdef mxMisalignedSettersCrash\n\tvalue = c_read32(data->value.arrayBuffer.address + offset);\n#else\n\tvalue = *((txS4*)(data->value.arrayBuffer.address + offset));\n#endif\n\tslot->value.integer = IMPORT(S32);\n\tmxMeterOne();\n}\n\nvoid fxInt32Setter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\ttxS4 value = (txS4)slot->value.integer;\n#ifdef mxMisalignedSettersCrash\n\tvalue = EXPORT(S32);\n\tc_memcpy(data->value.arrayBuffer.address + offset, &value, sizeof(txS4));\n#else\n\t*((txS4*)(data->value.arrayBuffer.address + offset)) = EXPORT(S32);\n#endif\n\tmxMeterOne();\n}\n\nint fxUint8Compare(const void* p, const void* q)\n{\n\ttxU1 a = c_read8((txU1*)p);\n\ttxU1 b = c_read8((txU1*)q);\n\treturn (a < b) ? -1 : (a > b) ? 1 : 0;\n}\n\nvoid fxUint8Getter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\tslot->kind = XS_INTEGER_KIND;\n\tslot->value.integer = c_read8((txU1*)(data->value.arrayBuffer.address + offset));\n\tmxMeterOne();\n}\n\nvoid fxUint8Setter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\ttxUnsigned tmp = (slot->kind == XS_INTEGER_KIND) ? (txUnsigned)slot->value.integer : (txUnsigned)slot->value.number;\n\t*((txU1*)(data->value.arrayBuffer.address + offset)) = (txU1)tmp;\n\tmxMeterOne();\n}\n\nint fxUint16Compare(const void* p, const void* q)\n{\n\ttxU2 a = *((txU2*)p);\n\ttxU2 b = *((txU2*)q);\n\treturn (a < b) ? -1 : (a > b) ? 1 : 0;\n}\n\nvoid fxUint16Getter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\ttxU2 value;\n\tslot->kind = XS_INTEGER_KIND;\n#ifdef mxMisalignedSettersCrash\n\tc_memcpy(&value, data->value.arrayBuffer.address + offset, sizeof(value));\n#else\n\tvalue = *((txU2*)(data->value.arrayBuffer.address + offset));\n#endif\n\tslot->value.integer = IMPORT(U16);\n\tmxMeterOne();\n}\n\nvoid fxUint16Setter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\ttxUnsigned tmp = (slot->kind == XS_INTEGER_KIND) ? (txUnsigned)slot->value.integer : (txUnsigned)slot->value.number;\n\ttxU2 value = (txU2)tmp;\n#ifdef mxMisalignedSettersCrash\n\tvalue = EXPORT(U16);\n\tc_memcpy(data->value.arrayBuffer.address + offset, &value, sizeof(txU2));\n#else\n\t*((txU2*)(data->value.arrayBuffer.address + offset)) = EXPORT(U16);\n#endif\n\tmxMeterOne();\n}\n\nint fxUint32Compare(const void* p, const void* q)\n{\n\ttxU4 a = *((txU4*)p);\n\ttxU4 b = *((txU4*)q);\n\treturn (a < b) ? -1 : (a > b) ? 1 : 0;\n}\n\nvoid fxUint32Getter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n#ifdef mxMisalignedSettersCrash\n\ttxUnsigned value = c_read32(data->value.arrayBuffer.address + offset);\n#else\n\ttxUnsigned value = *((txU4*)(data->value.arrayBuffer.address + offset));\n#endif\n\tvalue = IMPORT(U32);\n\tif (((txInteger)value) >= 0) {\n\t\tslot->kind = XS_INTEGER_KIND;\n\t\tslot->value.integer = value;\n\t}\n\telse {\n\t\tslot->kind = XS_NUMBER_KIND;\n\t\tslot->value.number = value;\n\t}\n\tmxMeterOne();\n}\n\nvoid fxUint32Setter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\ttxU4 value = (slot->kind == XS_INTEGER_KIND) ? (txU4)slot->value.integer : (txU4)slot->value.number;\n#ifdef mxMisalignedSettersCrash\n\tvalue = EXPORT(U32);\n\tc_memcpy(data->value.arrayBuffer.address + offset, &value, sizeof(txU4));\n#else\n\t*((txU4*)(data->value.arrayBuffer.address + offset)) = EXPORT(U32);\n#endif\n\tmxMeterOne();\n}\n\nvoid fxUint8ClampedSetter(txMachine* the, txSlot* data, txInteger offset, txSlot* slot, int endian)\n{\n\ttxNumber value = fxToNumber(the, slot);\n\tif (value <= 0)\n\t\tvalue = 0;\n\telse if (value >= 255)\n\t\tvalue = 255;\n\telse if (c_isnan(value))\n\t\tvalue = 0;\n\telse\n\t\tvalue = c_nearbyint(value);\n\t*((txU1*)(data->value.arrayBuffer.address + offset)) = (txU1)value;\n\tmxMeterOne();\n}\n\n"], "filenames": ["xs/sources/xsDataView.c"], "buggy_code_start_loc": [776], "buggy_code_end_loc": [1366], "fixing_code_start_loc": [776], "fixing_code_end_loc": [1370], "type": "CWE-125", "message": "Moddable commit before 135aa9a4a6a9b49b60aa730ebc3bcc6247d75c45 was discovered to contain an out-of-bounds read via the function fxUint8Getter at /moddable/xs/sources/xsDataView.c.", "other": {"cve": {"id": "CVE-2022-29368", "sourceIdentifier": "cve@mitre.org", "published": "2022-05-12T19:15:49.493", "lastModified": "2023-01-24T15:41:05.627", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Moddable commit before 135aa9a4a6a9b49b60aa730ebc3bcc6247d75c45 was discovered to contain an out-of-bounds read via the function fxUint8Getter at /moddable/xs/sources/xsDataView.c."}, {"lang": "es", "value": "Se ha detectado que el commit de Moddable versiones anteriores a 135aa9a4a6a9b49b60aa730ebc3bcc6247d75c45, conten\u00eda una lectura fuera de l\u00edmites por medio de la funci\u00f3n fxUint8Getter en el archivo /moddable/xs/sources/xsDataView.c"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:moddable:moddable:*:*:*:*:*:*:*:*", "versionEndIncluding": "os220330", "matchCriteriaId": "4095912D-3ADA-4DF1-9254-03818D03B9C2"}]}]}], "references": [{"url": "https://github.com/Moddable-OpenSource/moddable/commit/135aa9a4a6a9b49b60aa730ebc3bcc6247d75c45", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Moddable-OpenSource/moddable/issues/896", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Moddable-OpenSource/moddable/commit/135aa9a4a6a9b49b60aa730ebc3bcc6247d75c45"}}