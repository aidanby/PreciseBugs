{"buggy_code": ["//! TFA configuration and user data.\n//!\n//! This is the same as used in PBS but without the `#[api]` type.\n//!\n//! We may want to move this into a shared crate making the `#[api]` macro feature-gated!\n\nuse std::collections::HashMap;\n\nuse anyhow::{bail, format_err, Error};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\nuse url::Url;\n\nuse webauthn_rs::{proto::UserVerificationPolicy, Webauthn};\n\nuse crate::totp::Totp;\nuse proxmox_uuid::Uuid;\n\nmod serde_tools;\n\nmod recovery;\nmod u2f;\nmod webauthn;\n\npub mod methods;\n\npub use recovery::RecoveryState;\npub use u2f::U2fConfig;\nuse webauthn::WebauthnConfigInstance;\npub use webauthn::{WebauthnConfig, WebauthnCredential};\n\n#[cfg(feature = \"api-types\")]\npub use webauthn::WebauthnConfigUpdater;\n\npub use crate::types::TfaInfo;\n\nuse recovery::Recovery;\nuse u2f::{U2fChallenge, U2fChallengeEntry, U2fRegistrationChallenge};\nuse webauthn::{WebauthnAuthChallenge, WebauthnRegistrationChallenge};\n\ntrait IsExpired {\n    fn is_expired(&self, at_epoch: i64) -> bool;\n}\n\npub trait OpenUserChallengeData {\n    fn open(&self, userid: &str) -> Result<Box<dyn UserChallengeAccess>, Error>;\n\n    fn open_no_create(&self, userid: &str) -> Result<Option<Box<dyn UserChallengeAccess>>, Error>;\n\n    /// Should return `true` if something was removed, `false` if no data existed for the user.\n    fn remove(&self, userid: &str) -> Result<bool, Error>;\n}\n\npub trait UserChallengeAccess {\n    fn get_mut(&mut self) -> &mut TfaUserChallenges;\n    fn save(&mut self) -> Result<(), Error>;\n}\n\nconst CHALLENGE_TIMEOUT_SECS: i64 = 2 * 60;\n\n/// TFA Configuration for this instance.\n#[derive(Clone, Default, Deserialize, Serialize)]\npub struct TfaConfig {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub u2f: Option<U2fConfig>,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub webauthn: Option<WebauthnConfig>,\n\n    #[serde(skip_serializing_if = \"TfaUsers::is_empty\", default)]\n    pub users: TfaUsers,\n}\n\n/// Helper to get a u2f instance from a u2f config, or `None` if there isn't one configured.\nfn get_u2f(u2f: &Option<U2fConfig>) -> Option<u2f::U2f> {\n    u2f.as_ref().map(|cfg| {\n        u2f::U2f::new(\n            cfg.appid.clone(),\n            cfg.origin.clone().unwrap_or_else(|| cfg.appid.clone()),\n        )\n    })\n}\n\n/// Helper to get a u2f instance from a u2f config.\n///\n/// This is outside of `TfaConfig` to not borrow its `&self`.\nfn check_u2f(u2f: &Option<U2fConfig>) -> Result<u2f::U2f, Error> {\n    get_u2f(u2f).ok_or_else(|| format_err!(\"no u2f configuration available\"))\n}\n\n/// Helper to get a `Webauthn` instance from a `WebauthnConfig`, or `None` if there isn't one\n/// configured.\nfn get_webauthn<'a, 'config: 'a, 'origin: 'a>(\n    waconfig: &'config Option<WebauthnConfig>,\n    origin: Option<&'origin Url>,\n) -> Option<Webauthn<WebauthnConfigInstance<'a>>> {\n    match waconfig.as_ref()?.instantiate(origin) {\n        Ok(wa) => Some(Webauthn::new(wa)),\n        Err(err) => {\n            log::error!(\"webauthn error: {err}\");\n            None\n        }\n    }\n}\n\n/// Helper to get a `WebauthnConfigInstance` from a `WebauthnConfig`\n///\n/// This is outside of `TfaConfig` to not borrow its `&self`.\nfn check_webauthn<'a, 'config: 'a, 'origin: 'a>(\n    waconfig: &'config Option<WebauthnConfig>,\n    origin: Option<&'origin Url>,\n) -> Result<Webauthn<WebauthnConfigInstance<'a>>, Error> {\n    get_webauthn(waconfig, origin).ok_or_else(|| format_err!(\"no webauthn configuration available\"))\n}\n\nimpl TfaConfig {\n    // Get a u2f registration challenge.\n    pub fn u2f_registration_challenge<A: ?Sized + OpenUserChallengeData>(\n        &mut self,\n        access: &A,\n        userid: &str,\n        description: String,\n    ) -> Result<String, Error> {\n        let u2f = check_u2f(&self.u2f)?;\n\n        self.users\n            .entry(userid.to_owned())\n            .or_default()\n            .u2f_registration_challenge(access, userid, &u2f, description)\n    }\n\n    /// Finish a u2f registration challenge.\n    pub fn u2f_registration_finish<A: ?Sized + OpenUserChallengeData>(\n        &mut self,\n        access: &A,\n        userid: &str,\n        challenge: &str,\n        response: &str,\n    ) -> Result<String, Error> {\n        let u2f = check_u2f(&self.u2f)?;\n\n        match self.users.get_mut(userid) {\n            Some(user) => user.u2f_registration_finish(access, userid, &u2f, challenge, response),\n            None => bail!(\"no such challenge\"),\n        }\n    }\n\n    /// Get a webauthn registration challenge.\n    pub fn webauthn_registration_challenge<A: ?Sized + OpenUserChallengeData>(\n        &mut self,\n        access: &A,\n        user: &str,\n        description: String,\n        origin: Option<&Url>,\n    ) -> Result<String, Error> {\n        let webauthn = check_webauthn(&self.webauthn, origin)?;\n\n        self.users\n            .entry(user.to_owned())\n            .or_default()\n            .webauthn_registration_challenge(access, webauthn, user, description)\n    }\n\n    /// Finish a webauthn registration challenge.\n    pub fn webauthn_registration_finish<A: ?Sized + OpenUserChallengeData>(\n        &mut self,\n        access: &A,\n        userid: &str,\n        challenge: &str,\n        response: &str,\n        origin: Option<&Url>,\n    ) -> Result<String, Error> {\n        let webauthn = check_webauthn(&self.webauthn, origin)?;\n\n        let response: webauthn_rs::proto::RegisterPublicKeyCredential =\n            serde_json::from_str(response)\n                .map_err(|err| format_err!(\"error parsing challenge response: {}\", err))?;\n\n        match self.users.get_mut(userid) {\n            Some(user) => {\n                user.webauthn_registration_finish(access, webauthn, userid, challenge, response)\n            }\n            None => bail!(\"no such challenge\"),\n        }\n    }\n\n    /// Add a TOTP entry for a user.\n    ///\n    /// Unlike U2F/WA, this does not require a challenge/response. The user can choose their secret\n    /// themselves.\n    pub fn add_totp(&mut self, userid: &str, description: String, value: Totp) -> String {\n        self.users\n            .entry(userid.to_owned())\n            .or_default()\n            .add_totp(description, value)\n    }\n\n    /// Add a Yubico key to a user.\n    ///\n    /// Unlike U2F/WA, this does not require a challenge/response. The user can choose their secret\n    /// themselves.\n    pub fn add_yubico(&mut self, userid: &str, description: String, key: String) -> String {\n        self.users\n            .entry(userid.to_owned())\n            .or_default()\n            .add_yubico(description, key)\n    }\n\n    /// Add a new set of recovery keys. There can only be 1 set of keys at a time.\n    pub fn add_recovery(&mut self, userid: &str) -> Result<Vec<String>, Error> {\n        self.users\n            .entry(userid.to_owned())\n            .or_default()\n            .add_recovery()\n    }\n\n    /// Get a two factor authentication challenge for a user, if the user has TFA set up.\n    pub fn authentication_challenge<A: ?Sized + OpenUserChallengeData>(\n        &mut self,\n        access: &A,\n        userid: &str,\n        origin: Option<&Url>,\n    ) -> Result<Option<TfaChallenge>, Error> {\n        match self.users.get_mut(userid) {\n            Some(udata) => udata.challenge(\n                access,\n                userid,\n                get_webauthn(&self.webauthn, origin),\n                get_u2f(&self.u2f).as_ref(),\n            ),\n            None => Ok(None),\n        }\n    }\n\n    /// Verify a TFA challenge.\n    pub fn verify<A: ?Sized + OpenUserChallengeData>(\n        &mut self,\n        access: &A,\n        userid: &str,\n        challenge: &TfaChallenge,\n        response: TfaResponse,\n        origin: Option<&Url>,\n    ) -> Result<NeedsSaving, Error> {\n        match self.users.get_mut(userid) {\n            Some(user) => match response {\n                TfaResponse::Totp(value) => user.verify_totp(&value),\n                TfaResponse::U2f(value) => match &challenge.u2f {\n                    Some(challenge) => {\n                        let u2f = check_u2f(&self.u2f)?;\n                        user.verify_u2f(access, userid, u2f, &challenge.challenge, value)\n                    }\n                    None => bail!(\"no u2f factor available for user '{}'\", userid),\n                },\n                TfaResponse::Webauthn(value) => {\n                    let webauthn = check_webauthn(&self.webauthn, origin)?;\n                    user.verify_webauthn(access, userid, webauthn, value)\n                }\n                TfaResponse::Recovery(value) => {\n                    user.verify_recovery(&value)?;\n                    return Ok(NeedsSaving::Yes);\n                }\n            },\n            None => bail!(\"no 2nd factor available for user '{}'\", userid),\n        }?;\n\n        Ok(NeedsSaving::No)\n    }\n\n    pub fn remove_user<A: ?Sized + OpenUserChallengeData>(\n        &mut self,\n        access: &A,\n        userid: &str,\n    ) -> Result<NeedsSaving, Error> {\n        let mut save = access.remove(userid)?;\n        if self.users.remove(userid).is_some() {\n            save = true;\n        }\n        Ok(save.into())\n    }\n}\n\n#[must_use = \"must save the config in order to ensure one-time use of recovery keys\"]\n#[derive(Clone, Copy)]\npub enum NeedsSaving {\n    No,\n    Yes,\n}\n\nimpl NeedsSaving {\n    /// Convenience method so we don't need to import the type name.\n    pub fn needs_saving(self) -> bool {\n        matches!(self, NeedsSaving::Yes)\n    }\n}\n\nimpl From<bool> for NeedsSaving {\n    fn from(v: bool) -> Self {\n        if v {\n            NeedsSaving::Yes\n        } else {\n            NeedsSaving::No\n        }\n    }\n}\n\n/// Mapping of userid to TFA entry.\npub type TfaUsers = HashMap<String, TfaUserData>;\n\n/// TFA data for a user.\n#[derive(Clone, Default, Deserialize, Serialize)]\n#[serde(deny_unknown_fields)]\n#[serde(rename_all = \"kebab-case\")]\npub struct TfaUserData {\n    /// Totp keys for a user.\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    pub totp: Vec<TfaEntry<Totp>>,\n\n    /// Registered u2f tokens for a user.\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    pub u2f: Vec<TfaEntry<u2f::Registration>>,\n\n    /// Registered webauthn tokens for a user.\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    pub webauthn: Vec<TfaEntry<WebauthnCredential>>,\n\n    /// Recovery keys. (Unordered OTP values).\n    #[serde(skip_serializing_if = \"Option::is_none\", default)]\n    pub recovery: Option<Recovery>,\n\n    /// Yubico keys for a user. NOTE: This is not directly supported currently, we just need this\n    /// available for PVE, where the yubico API server configuration is part if the realm.\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    pub yubico: Vec<TfaEntry<String>>,\n}\n\nimpl TfaUserData {\n    /// `true` if no second factors exist\n    pub fn is_empty(&self) -> bool {\n        self.totp.is_empty()\n            && self.u2f.is_empty()\n            && self.webauthn.is_empty()\n            && self.yubico.is_empty()\n            && self.recovery.is_none()\n    }\n\n    /// Find an entry by id, except for the \"recovery\" entry which we're currently treating\n    /// specially.\n    pub fn find_entry_mut<'a>(&'a mut self, id: &str) -> Option<&'a mut TfaInfo> {\n        for entry in &mut self.totp {\n            if entry.info.id == id {\n                return Some(&mut entry.info);\n            }\n        }\n\n        for entry in &mut self.webauthn {\n            if entry.info.id == id {\n                return Some(&mut entry.info);\n            }\n        }\n\n        for entry in &mut self.u2f {\n            if entry.info.id == id {\n                return Some(&mut entry.info);\n            }\n        }\n\n        for entry in &mut self.yubico {\n            if entry.info.id == id {\n                return Some(&mut entry.info);\n            }\n        }\n\n        None\n    }\n\n    /// Create a u2f registration challenge.\n    ///\n    /// The description is required at this point already mostly to better be able to identify such\n    /// challenges in the tfa config file if necessary. The user otherwise has no access to this\n    /// information at this point, as the challenge is identified by its actual challenge data\n    /// instead.\n    fn u2f_registration_challenge<A: ?Sized + OpenUserChallengeData>(\n        &mut self,\n        access: &A,\n        userid: &str,\n        u2f: &u2f::U2f,\n        description: String,\n    ) -> Result<String, Error> {\n        let challenge = serde_json::to_string(&u2f.registration_challenge()?)?;\n\n        let mut data = access.open(userid)?;\n        data.get_mut()\n            .u2f_registrations\n            .push(U2fRegistrationChallenge::new(\n                challenge.clone(),\n                description,\n            ));\n        data.save()?;\n\n        Ok(challenge)\n    }\n\n    fn u2f_registration_finish<A: ?Sized + OpenUserChallengeData>(\n        &mut self,\n        access: &A,\n        userid: &str,\n        u2f: &u2f::U2f,\n        challenge: &str,\n        response: &str,\n    ) -> Result<String, Error> {\n        let mut data = access.open(userid)?;\n        let entry = data\n            .get_mut()\n            .u2f_registration_finish(u2f, challenge, response)?;\n        data.save()?;\n\n        let id = entry.info.id.clone();\n        self.u2f.push(entry);\n        Ok(id)\n    }\n\n    /// Create a webauthn registration challenge.\n    ///\n    /// The description is required at this point already mostly to better be able to identify such\n    /// challenges in the tfa config file if necessary. The user otherwise has no access to this\n    /// information at this point, as the challenge is identified by its actual challenge data\n    /// instead.\n    fn webauthn_registration_challenge<A: ?Sized + OpenUserChallengeData>(\n        &mut self,\n        access: &A,\n        webauthn: Webauthn<WebauthnConfigInstance>,\n        userid: &str,\n        description: String,\n    ) -> Result<String, Error> {\n        let cred_ids: Vec<_> = self\n            .enabled_webauthn_entries()\n            .map(|cred| cred.cred_id.clone())\n            .collect();\n\n        let (challenge, state) = webauthn.generate_challenge_register_options(\n            userid.as_bytes().to_vec(),\n            userid.to_owned(),\n            userid.to_owned(),\n            Some(cred_ids),\n            Some(UserVerificationPolicy::Discouraged),\n            None,\n        )?;\n\n        let challenge_string = challenge.public_key.challenge.to_string();\n        let challenge = serde_json::to_string(&challenge)?;\n\n        let mut data = access.open(userid)?;\n        data.get_mut()\n            .webauthn_registrations\n            .push(WebauthnRegistrationChallenge::new(\n                state,\n                challenge_string,\n                description,\n            ));\n        data.save()?;\n\n        Ok(challenge)\n    }\n\n    /// Finish a webauthn registration. The challenge should correspond to an output of\n    /// `webauthn_registration_challenge`. The response should come directly from the client.\n    fn webauthn_registration_finish<A: ?Sized + OpenUserChallengeData>(\n        &mut self,\n        access: &A,\n        webauthn: Webauthn<WebauthnConfigInstance>,\n        userid: &str,\n        challenge: &str,\n        response: webauthn_rs::proto::RegisterPublicKeyCredential,\n    ) -> Result<String, Error> {\n        let mut data = access.open(userid)?;\n        let entry = data.get_mut().webauthn_registration_finish(\n            webauthn,\n            challenge,\n            response,\n            &self.webauthn,\n        )?;\n        data.save()?;\n\n        let id = entry.info.id.clone();\n        self.webauthn.push(entry);\n        Ok(id)\n    }\n\n    fn add_totp(&mut self, description: String, totp: Totp) -> String {\n        let entry = TfaEntry::new(description, totp);\n        let id = entry.info.id.clone();\n        self.totp.push(entry);\n        id\n    }\n\n    fn add_yubico(&mut self, description: String, key: String) -> String {\n        let entry = TfaEntry::new(description, key);\n        let id = entry.info.id.clone();\n        self.yubico.push(entry);\n        id\n    }\n\n    /// Add a new set of recovery keys. There can only be 1 set of keys at a time.\n    fn add_recovery(&mut self) -> Result<Vec<String>, Error> {\n        if self.recovery.is_some() {\n            bail!(\"user already has recovery keys\");\n        }\n\n        let (recovery, original) = Recovery::generate()?;\n\n        self.recovery = Some(recovery);\n\n        Ok(original)\n    }\n\n    /// Helper to iterate over enabled totp entries.\n    fn enabled_totp_entries(&self) -> impl Iterator<Item = &Totp> {\n        self.totp\n            .iter()\n            .filter_map(|e| if e.info.enable { Some(&e.entry) } else { None })\n    }\n\n    /// Helper to iterate over enabled u2f entries.\n    fn enabled_u2f_entries(&self) -> impl Iterator<Item = &u2f::Registration> {\n        self.u2f\n            .iter()\n            .filter_map(|e| if e.info.enable { Some(&e.entry) } else { None })\n    }\n\n    /// Helper to iterate over enabled u2f entries.\n    fn enabled_webauthn_entries(&self) -> impl Iterator<Item = &WebauthnCredential> {\n        self.webauthn\n            .iter()\n            .filter_map(|e| if e.info.enable { Some(&e.entry) } else { None })\n    }\n\n    /// Helper to iterate over enabled yubico entries.\n    pub fn enabled_yubico_entries(&self) -> impl Iterator<Item = &str> {\n        self.yubico.iter().filter_map(|e| {\n            if e.info.enable {\n                Some(e.entry.as_str())\n            } else {\n                None\n            }\n        })\n    }\n\n    /// Verify a totp challenge. The `value` should be the totp digits as plain text.\n    fn verify_totp(&self, value: &str) -> Result<(), Error> {\n        let now = std::time::SystemTime::now();\n\n        for entry in self.enabled_totp_entries() {\n            if entry.verify(value, now, -1..=1)?.is_some() {\n                return Ok(());\n            }\n        }\n\n        bail!(\"totp verification failed\");\n    }\n\n    /// Generate a generic TFA challenge. See the [`TfaChallenge`] description for details.\n    fn challenge<A: ?Sized + OpenUserChallengeData>(\n        &mut self,\n        access: &A,\n        userid: &str,\n        webauthn: Option<Webauthn<WebauthnConfigInstance>>,\n        u2f: Option<&u2f::U2f>,\n    ) -> Result<Option<TfaChallenge>, Error> {\n        if self.is_empty() {\n            return Ok(None);\n        }\n\n        // Since we don't bail out when failing to generate WA or U2F challenges, we keep track of\n        // whether we tried here, otherwise `challenge.check()` would consider these to be not\n        // configured by the user and might allow logging in without them on error.\n        let mut not_empty = false;\n\n        let challenge = TfaChallenge {\n            totp: self.totp.iter().any(|e| e.info.enable),\n            recovery: self.recovery_state(),\n            webauthn: match webauthn {\n                Some(webauthn) => match self.webauthn_challenge(access, userid, webauthn) {\n                    Ok(wa) => wa,\n                    Err(err) => {\n                        not_empty = true;\n                        log::error!(\"failed to generate webauthn challenge: {err}\");\n                        None\n                    }\n                },\n                None => None,\n            },\n            u2f: match u2f {\n                Some(u2f) => match self.u2f_challenge(access, userid, u2f) {\n                    Ok(u2f) => u2f,\n                    Err(err) => {\n                        not_empty = true;\n                        log::error!(\"failed to generate u2f challenge: {err}\");\n                        None\n                    }\n                },\n                None => None,\n            },\n            yubico: self.yubico.iter().any(|e| e.info.enable),\n        };\n\n        // This happens if 2nd factors exist but are all disabled.\n        if challenge.is_empty() && !not_empty {\n            return Ok(None);\n        }\n\n        Ok(Some(challenge))\n    }\n\n    /// Get the recovery state.\n    pub fn recovery_state(&self) -> Option<RecoveryState> {\n        self.recovery.as_ref().map(RecoveryState::from)\n    }\n\n    /// Generate an optional webauthn challenge.\n    fn webauthn_challenge<A: ?Sized + OpenUserChallengeData>(\n        &mut self,\n        access: &A,\n        userid: &str,\n        webauthn: Webauthn<WebauthnConfigInstance>,\n    ) -> Result<Option<webauthn_rs::proto::RequestChallengeResponse>, Error> {\n        if self.webauthn.is_empty() {\n            return Ok(None);\n        }\n\n        let creds: Vec<_> = self\n            .enabled_webauthn_entries()\n            .map(|cred| cred.clone().into())\n            .collect();\n\n        if creds.is_empty() {\n            return Ok(None);\n        }\n\n        let (challenge, state) = webauthn.generate_challenge_authenticate(creds)?;\n\n        let challenge_string = challenge.public_key.challenge.to_string();\n        let mut data = access.open(userid)?;\n        data.get_mut()\n            .webauthn_auths\n            .push(WebauthnAuthChallenge::new(state, challenge_string));\n        data.save()?;\n\n        Ok(Some(challenge))\n    }\n\n    /// Generate an optional u2f challenge.\n    fn u2f_challenge<A: ?Sized + OpenUserChallengeData>(\n        &self,\n        access: &A,\n        userid: &str,\n        u2f: &u2f::U2f,\n    ) -> Result<Option<U2fChallenge>, Error> {\n        if self.u2f.is_empty() {\n            return Ok(None);\n        }\n\n        let keys: Vec<crate::u2f::RegisteredKey> = self\n            .enabled_u2f_entries()\n            .map(|registration| registration.key.clone())\n            .collect();\n\n        if keys.is_empty() {\n            return Ok(None);\n        }\n\n        let challenge = U2fChallenge {\n            challenge: u2f.auth_challenge()?,\n            keys,\n        };\n\n        let mut data = access.open(userid)?;\n        data.get_mut()\n            .u2f_auths\n            .push(U2fChallengeEntry::new(&challenge));\n        data.save()?;\n\n        Ok(Some(challenge))\n    }\n\n    /// Verify a u2f response.\n    fn verify_u2f<A: ?Sized + OpenUserChallengeData>(\n        &self,\n        access: &A,\n        userid: &str,\n        u2f: u2f::U2f,\n        challenge: &crate::u2f::AuthChallenge,\n        response: Value,\n    ) -> Result<(), Error> {\n        let expire_before = proxmox_time::epoch_i64() - CHALLENGE_TIMEOUT_SECS;\n\n        let response: crate::u2f::AuthResponse = serde_json::from_value(response)\n            .map_err(|err| format_err!(\"invalid u2f response: {}\", err))?;\n\n        if let Some(entry) = self\n            .enabled_u2f_entries()\n            .find(|e| e.key.key_handle == response.key_handle())\n        {\n            if u2f\n                .auth_verify_obj(&entry.public_key, &challenge.challenge, response)?\n                .is_some()\n            {\n                let mut data = match access.open_no_create(userid)? {\n                    Some(data) => data,\n                    None => bail!(\"no such challenge\"),\n                };\n                let index = data\n                    .get_mut()\n                    .u2f_auths\n                    .iter()\n                    .position(|r| r == challenge)\n                    .ok_or_else(|| format_err!(\"no such challenge\"))?;\n                let entry = data.get_mut().u2f_auths.remove(index);\n                if entry.is_expired(expire_before) {\n                    bail!(\"no such challenge\");\n                }\n                data.save()\n                    .map_err(|err| format_err!(\"failed to save challenge file: {}\", err))?;\n\n                return Ok(());\n            }\n        }\n\n        bail!(\"u2f verification failed\");\n    }\n\n    /// Verify a webauthn response.\n    fn verify_webauthn<A: ?Sized + OpenUserChallengeData>(\n        &mut self,\n        access: &A,\n        userid: &str,\n        webauthn: Webauthn<WebauthnConfigInstance>,\n        mut response: Value,\n    ) -> Result<(), Error> {\n        let expire_before = proxmox_time::epoch_i64() - CHALLENGE_TIMEOUT_SECS;\n\n        let challenge = match response\n            .as_object_mut()\n            .ok_or_else(|| format_err!(\"invalid response, must be a json object\"))?\n            .remove(\"challenge\")\n            .ok_or_else(|| format_err!(\"missing challenge data in response\"))?\n        {\n            Value::String(s) => s,\n            _ => bail!(\"invalid challenge data in response\"),\n        };\n\n        let response: webauthn_rs::proto::PublicKeyCredential = serde_json::from_value(response)\n            .map_err(|err| format_err!(\"invalid webauthn response: {}\", err))?;\n\n        let mut data = match access.open_no_create(userid)? {\n            Some(data) => data,\n            None => bail!(\"no such challenge\"),\n        };\n\n        let index = data\n            .get_mut()\n            .webauthn_auths\n            .iter()\n            .position(|r| r.challenge == challenge)\n            .ok_or_else(|| format_err!(\"no such challenge\"))?;\n\n        let challenge = data.get_mut().webauthn_auths.remove(index);\n        if challenge.is_expired(expire_before) {\n            bail!(\"no such challenge\");\n        }\n\n        // we don't allow re-trying the challenge, so make the removal persistent now:\n        data.save()\n            .map_err(|err| format_err!(\"failed to save challenge file: {}\", err))?;\n\n        webauthn.authenticate_credential(&response, &challenge.state)?;\n\n        Ok(())\n    }\n\n    /// Verify a recovery key.\n    ///\n    /// NOTE: If successful, the key will automatically be removed from the list of available\n    /// recovery keys, so the configuration needs to be saved afterwards!\n    fn verify_recovery(&mut self, value: &str) -> Result<(), Error> {\n        if let Some(r) = &mut self.recovery {\n            if r.verify(value)? {\n                return Ok(());\n            }\n        }\n        bail!(\"recovery verification failed\");\n    }\n}\n\n/// A TFA entry for a user.\n///\n/// This simply connects a raw registration to a non optional descriptive text chosen by the user.\n#[derive(Clone, Deserialize, Serialize)]\n#[serde(deny_unknown_fields)]\npub struct TfaEntry<T> {\n    #[serde(flatten)]\n    pub info: TfaInfo,\n\n    /// The actual entry.\n    pub entry: T,\n}\n\nimpl<T> TfaEntry<T> {\n    /// Create an entry with a description. The id will be autogenerated.\n    fn new(description: String, entry: T) -> Self {\n        Self {\n            info: TfaInfo {\n                id: Uuid::generate().to_string(),\n                enable: true,\n                description,\n                created: proxmox_time::epoch_i64(),\n            },\n            entry,\n        }\n    }\n\n    /// Create a raw entry from a `TfaInfo` and the corresponding entry data.\n    pub fn from_parts(info: TfaInfo, entry: T) -> Self {\n        Self { info, entry }\n    }\n}\n\n/// When sending a TFA challenge to the user, we include information about what kind of challenge\n/// the user may perform. If webauthn credentials are available, a webauthn challenge will be\n/// included.\n#[derive(Deserialize, Serialize)]\n#[serde(rename_all = \"kebab-case\")]\npub struct TfaChallenge {\n    /// True if the user has TOTP devices.\n    #[serde(skip_serializing_if = \"bool_is_false\", default)]\n    pub totp: bool,\n\n    /// Whether there are recovery keys available.\n    #[serde(skip_serializing_if = \"Option::is_none\", default)]\n    pub recovery: Option<RecoveryState>,\n\n    /// If the user has any u2f tokens registered, this will contain the U2F challenge data.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub u2f: Option<U2fChallenge>,\n\n    /// If the user has any webauthn credentials registered, this will contain the corresponding\n    /// challenge data.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub webauthn: Option<webauthn_rs::proto::RequestChallengeResponse>,\n\n    /// True if the user has yubico keys configured.\n    #[serde(skip_serializing_if = \"bool_is_false\", default)]\n    pub yubico: bool,\n}\n\nimpl TfaChallenge {\n    pub fn is_empty(&self) -> bool {\n        !self.totp\n            && self.recovery.is_none()\n            && self.u2f.is_none()\n            && self.webauthn.is_none()\n            && !self.yubico\n    }\n}\n\nfn bool_is_false(v: &bool) -> bool {\n    !v\n}\n\n/// A user's response to a TFA challenge.\npub enum TfaResponse {\n    Totp(String),\n    U2f(Value),\n    Webauthn(Value),\n    Recovery(String),\n}\n\n/// This is part of the REST API:\nimpl std::str::FromStr for TfaResponse {\n    type Err = Error;\n\n    fn from_str(s: &str) -> Result<Self, Error> {\n        Ok(if let Some(totp) = s.strip_prefix(\"totp:\") {\n            TfaResponse::Totp(totp.to_string())\n        } else if let Some(u2f) = s.strip_prefix(\"u2f:\") {\n            TfaResponse::U2f(serde_json::from_str(u2f)?)\n        } else if let Some(webauthn) = s.strip_prefix(\"webauthn:\") {\n            TfaResponse::Webauthn(serde_json::from_str(webauthn)?)\n        } else if let Some(recovery) = s.strip_prefix(\"recovery:\") {\n            TfaResponse::Recovery(recovery.to_string())\n        } else {\n            bail!(\"invalid tfa response\");\n        })\n    }\n}\n\n/// Active TFA challenges per user, stored in a restricted temporary file on the machine handling\n/// the current user's authentication.\n#[derive(Default, Deserialize, Serialize)]\npub struct TfaUserChallenges {\n    /// Active u2f registration challenges for a user.\n    ///\n    /// Expired values are automatically filtered out while parsing the tfa configuration file.\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    #[serde(deserialize_with = \"filter_expired_challenge\")]\n    u2f_registrations: Vec<U2fRegistrationChallenge>,\n\n    /// Active u2f authentication challenges for a user.\n    ///\n    /// Expired values are automatically filtered out while parsing the tfa configuration file.\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    #[serde(deserialize_with = \"filter_expired_challenge\")]\n    u2f_auths: Vec<U2fChallengeEntry>,\n\n    /// Active webauthn registration challenges for a user.\n    ///\n    /// Expired values are automatically filtered out while parsing the tfa configuration file.\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    #[serde(deserialize_with = \"filter_expired_challenge\")]\n    webauthn_registrations: Vec<WebauthnRegistrationChallenge>,\n\n    /// Active webauthn authentication challenges for a user.\n    ///\n    /// Expired values are automatically filtered out while parsing the tfa configuration file.\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    #[serde(deserialize_with = \"filter_expired_challenge\")]\n    webauthn_auths: Vec<WebauthnAuthChallenge>,\n}\n\n/// Serde helper using our `FilteredVecVisitor` to filter out expired entries directly at load\n/// time.\nfn filter_expired_challenge<'de, D, T>(deserializer: D) -> Result<Vec<T>, D::Error>\nwhere\n    D: serde::Deserializer<'de>,\n    T: Deserialize<'de> + IsExpired,\n{\n    let expire_before = proxmox_time::epoch_i64() - CHALLENGE_TIMEOUT_SECS;\n    deserializer.deserialize_seq(serde_tools::fold(\n        \"a challenge entry\",\n        |cap| cap.map(Vec::with_capacity).unwrap_or_else(Vec::new),\n        move |out, reg: T| {\n            if !reg.is_expired(expire_before) {\n                out.push(reg);\n            }\n        },\n    ))\n}\n\nimpl TfaUserChallenges {\n    /// Finish a u2f registration. The challenge should correspond to an output of\n    /// `u2f_registration_challenge` (which is a stringified `RegistrationChallenge`). The response\n    /// should come directly from the client.\n    fn u2f_registration_finish(\n        &mut self,\n        u2f: &u2f::U2f,\n        challenge: &str,\n        response: &str,\n    ) -> Result<TfaEntry<u2f::Registration>, Error> {\n        let expire_before = proxmox_time::epoch_i64() - CHALLENGE_TIMEOUT_SECS;\n\n        let index = self\n            .u2f_registrations\n            .iter()\n            .position(|r| r.challenge == challenge)\n            .ok_or_else(|| format_err!(\"no such challenge\"))?;\n\n        let reg = &self.u2f_registrations[index];\n        if reg.is_expired(expire_before) {\n            bail!(\"no such challenge\");\n        }\n\n        // the verify call only takes the actual challenge string, so we have to extract it\n        // (u2f::RegistrationChallenge did not always implement Deserialize...)\n        let chobj: Value = serde_json::from_str(challenge)\n            .map_err(|err| format_err!(\"error parsing original registration challenge: {}\", err))?;\n        let challenge = chobj[\"challenge\"]\n            .as_str()\n            .ok_or_else(|| format_err!(\"invalid registration challenge\"))?;\n\n        let (mut reg, description) = match u2f.registration_verify(challenge, response)? {\n            None => bail!(\"verification failed\"),\n            Some(reg) => {\n                let entry = self.u2f_registrations.remove(index);\n                (reg, entry.description)\n            }\n        };\n\n        // we do not care about the attestation certificates, so don't store them\n        reg.certificate.clear();\n\n        Ok(TfaEntry::new(description, reg))\n    }\n\n    /// Finish a webauthn registration. The challenge should correspond to an output of\n    /// `webauthn_registration_challenge`. The response should come directly from the client.\n    fn webauthn_registration_finish(\n        &mut self,\n        webauthn: Webauthn<WebauthnConfigInstance>,\n        challenge: &str,\n        response: webauthn_rs::proto::RegisterPublicKeyCredential,\n        existing_registrations: &[TfaEntry<WebauthnCredential>],\n    ) -> Result<TfaEntry<WebauthnCredential>, Error> {\n        let expire_before = proxmox_time::epoch_i64() - CHALLENGE_TIMEOUT_SECS;\n\n        let index = self\n            .webauthn_registrations\n            .iter()\n            .position(|r| r.challenge == challenge)\n            .ok_or_else(|| format_err!(\"no such challenge\"))?;\n\n        let reg = self.webauthn_registrations.remove(index);\n        if reg.is_expired(expire_before) {\n            bail!(\"no such challenge\");\n        }\n\n        let (credential, _authenticator) =\n            webauthn.register_credential(&response, &reg.state, |id| -> Result<bool, ()> {\n                Ok(existing_registrations\n                    .iter()\n                    .any(|cred| cred.entry.cred_id == *id))\n            })?;\n\n        Ok(TfaEntry::new(reg.description, credential.into()))\n    }\n}\n"], "fixing_code": ["//! TFA configuration and user data.\n//!\n//! This is the same as used in PBS but without the `#[api]` type.\n//!\n//! We may want to move this into a shared crate making the `#[api]` macro feature-gated!\n\nuse std::collections::HashMap;\n\nuse anyhow::{bail, format_err, Error};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\nuse url::Url;\n\nuse webauthn_rs::{proto::UserVerificationPolicy, Webauthn};\n\nuse crate::totp::Totp;\nuse proxmox_uuid::Uuid;\n\nmod serde_tools;\n\nmod recovery;\nmod u2f;\nmod webauthn;\n\npub mod methods;\n\npub use recovery::RecoveryState;\npub use u2f::U2fConfig;\nuse webauthn::WebauthnConfigInstance;\npub use webauthn::{WebauthnConfig, WebauthnCredential};\n\n#[cfg(feature = \"api-types\")]\npub use webauthn::WebauthnConfigUpdater;\n\npub use crate::types::TfaInfo;\n\nuse recovery::Recovery;\nuse u2f::{U2fChallenge, U2fChallengeEntry, U2fRegistrationChallenge};\nuse webauthn::{WebauthnAuthChallenge, WebauthnRegistrationChallenge};\n\ntrait IsExpired {\n    fn is_expired(&self, at_epoch: i64) -> bool;\n}\n\npub trait OpenUserChallengeData {\n    fn open(&self, userid: &str) -> Result<Box<dyn UserChallengeAccess>, Error>;\n\n    fn open_no_create(&self, userid: &str) -> Result<Option<Box<dyn UserChallengeAccess>>, Error>;\n\n    /// Should return `true` if something was removed, `false` if no data existed for the user.\n    fn remove(&self, userid: &str) -> Result<bool, Error>;\n}\n\npub trait UserChallengeAccess {\n    fn get_mut(&mut self) -> &mut TfaUserChallenges;\n    fn save(&mut self) -> Result<(), Error>;\n}\n\nconst CHALLENGE_TIMEOUT_SECS: i64 = 2 * 60;\n\n/// TFA Configuration for this instance.\n#[derive(Clone, Default, Deserialize, Serialize)]\npub struct TfaConfig {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub u2f: Option<U2fConfig>,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub webauthn: Option<WebauthnConfig>,\n\n    #[serde(skip_serializing_if = \"TfaUsers::is_empty\", default)]\n    pub users: TfaUsers,\n}\n\n/// Helper to get a u2f instance from a u2f config, or `None` if there isn't one configured.\nfn get_u2f(u2f: &Option<U2fConfig>) -> Option<u2f::U2f> {\n    u2f.as_ref().map(|cfg| {\n        u2f::U2f::new(\n            cfg.appid.clone(),\n            cfg.origin.clone().unwrap_or_else(|| cfg.appid.clone()),\n        )\n    })\n}\n\n/// Helper to get a u2f instance from a u2f config.\n///\n/// This is outside of `TfaConfig` to not borrow its `&self`.\nfn check_u2f(u2f: &Option<U2fConfig>) -> Result<u2f::U2f, Error> {\n    get_u2f(u2f).ok_or_else(|| format_err!(\"no u2f configuration available\"))\n}\n\n/// Helper to get a `Webauthn` instance from a `WebauthnConfig`, or `None` if there isn't one\n/// configured.\nfn get_webauthn<'a, 'config: 'a, 'origin: 'a>(\n    waconfig: &'config Option<WebauthnConfig>,\n    origin: Option<&'origin Url>,\n) -> Option<Webauthn<WebauthnConfigInstance<'a>>> {\n    match waconfig.as_ref()?.instantiate(origin) {\n        Ok(wa) => Some(Webauthn::new(wa)),\n        Err(err) => {\n            log::error!(\"webauthn error: {err}\");\n            None\n        }\n    }\n}\n\n/// Helper to get a `WebauthnConfigInstance` from a `WebauthnConfig`\n///\n/// This is outside of `TfaConfig` to not borrow its `&self`.\nfn check_webauthn<'a, 'config: 'a, 'origin: 'a>(\n    waconfig: &'config Option<WebauthnConfig>,\n    origin: Option<&'origin Url>,\n) -> Result<Webauthn<WebauthnConfigInstance<'a>>, Error> {\n    get_webauthn(waconfig, origin).ok_or_else(|| format_err!(\"no webauthn configuration available\"))\n}\n\nimpl TfaConfig {\n    // Get a u2f registration challenge.\n    pub fn u2f_registration_challenge<A: ?Sized + OpenUserChallengeData>(\n        &mut self,\n        access: &A,\n        userid: &str,\n        description: String,\n    ) -> Result<String, Error> {\n        let u2f = check_u2f(&self.u2f)?;\n\n        self.users\n            .entry(userid.to_owned())\n            .or_default()\n            .u2f_registration_challenge(access, userid, &u2f, description)\n    }\n\n    /// Finish a u2f registration challenge.\n    pub fn u2f_registration_finish<A: ?Sized + OpenUserChallengeData>(\n        &mut self,\n        access: &A,\n        userid: &str,\n        challenge: &str,\n        response: &str,\n    ) -> Result<String, Error> {\n        let u2f = check_u2f(&self.u2f)?;\n\n        match self.users.get_mut(userid) {\n            Some(user) => user.u2f_registration_finish(access, userid, &u2f, challenge, response),\n            None => bail!(\"no such challenge\"),\n        }\n    }\n\n    /// Get a webauthn registration challenge.\n    pub fn webauthn_registration_challenge<A: ?Sized + OpenUserChallengeData>(\n        &mut self,\n        access: &A,\n        user: &str,\n        description: String,\n        origin: Option<&Url>,\n    ) -> Result<String, Error> {\n        let webauthn = check_webauthn(&self.webauthn, origin)?;\n\n        self.users\n            .entry(user.to_owned())\n            .or_default()\n            .webauthn_registration_challenge(access, webauthn, user, description)\n    }\n\n    /// Finish a webauthn registration challenge.\n    pub fn webauthn_registration_finish<A: ?Sized + OpenUserChallengeData>(\n        &mut self,\n        access: &A,\n        userid: &str,\n        challenge: &str,\n        response: &str,\n        origin: Option<&Url>,\n    ) -> Result<String, Error> {\n        let webauthn = check_webauthn(&self.webauthn, origin)?;\n\n        let response: webauthn_rs::proto::RegisterPublicKeyCredential =\n            serde_json::from_str(response)\n                .map_err(|err| format_err!(\"error parsing challenge response: {}\", err))?;\n\n        match self.users.get_mut(userid) {\n            Some(user) => {\n                user.webauthn_registration_finish(access, webauthn, userid, challenge, response)\n            }\n            None => bail!(\"no such challenge\"),\n        }\n    }\n\n    /// Add a TOTP entry for a user.\n    ///\n    /// Unlike U2F/WA, this does not require a challenge/response. The user can choose their secret\n    /// themselves.\n    pub fn add_totp(&mut self, userid: &str, description: String, value: Totp) -> String {\n        self.users\n            .entry(userid.to_owned())\n            .or_default()\n            .add_totp(description, value)\n    }\n\n    /// Add a Yubico key to a user.\n    ///\n    /// Unlike U2F/WA, this does not require a challenge/response. The user can choose their secret\n    /// themselves.\n    pub fn add_yubico(&mut self, userid: &str, description: String, key: String) -> String {\n        self.users\n            .entry(userid.to_owned())\n            .or_default()\n            .add_yubico(description, key)\n    }\n\n    /// Add a new set of recovery keys. There can only be 1 set of keys at a time.\n    pub fn add_recovery(&mut self, userid: &str) -> Result<Vec<String>, Error> {\n        self.users\n            .entry(userid.to_owned())\n            .or_default()\n            .add_recovery()\n    }\n\n    /// Get a two factor authentication challenge for a user, if the user has TFA set up.\n    pub fn authentication_challenge<A: ?Sized + OpenUserChallengeData>(\n        &mut self,\n        access: &A,\n        userid: &str,\n        origin: Option<&Url>,\n    ) -> Result<Option<TfaChallenge>, Error> {\n        match self.users.get_mut(userid) {\n            Some(udata) => udata.challenge(\n                access,\n                userid,\n                get_webauthn(&self.webauthn, origin),\n                get_u2f(&self.u2f).as_ref(),\n            ),\n            None => Ok(None),\n        }\n    }\n\n    /// Verify a TFA challenge.\n    pub fn verify<A: ?Sized + OpenUserChallengeData>(\n        &mut self,\n        access: &A,\n        userid: &str,\n        challenge: &TfaChallenge,\n        response: TfaResponse,\n        origin: Option<&Url>,\n    ) -> Result<NeedsSaving, Error> {\n        match self.users.get_mut(userid) {\n            Some(user) => match response {\n                TfaResponse::Totp(value) => user.verify_totp(&value),\n                TfaResponse::U2f(value) => match &challenge.u2f {\n                    Some(challenge) => {\n                        let u2f = check_u2f(&self.u2f)?;\n                        user.verify_u2f(access, userid, u2f, &challenge.challenge, value)\n                    }\n                    None => bail!(\"no u2f factor available for user '{}'\", userid),\n                },\n                TfaResponse::Webauthn(value) => {\n                    let webauthn = check_webauthn(&self.webauthn, origin)?;\n                    user.verify_webauthn(access, userid, webauthn, value)\n                }\n                TfaResponse::Recovery(value) => {\n                    user.verify_recovery(&value)?;\n                    return Ok(NeedsSaving::Yes);\n                }\n            },\n            None => bail!(\"no 2nd factor available for user '{}'\", userid),\n        }?;\n\n        Ok(NeedsSaving::No)\n    }\n\n    pub fn remove_user<A: ?Sized + OpenUserChallengeData>(\n        &mut self,\n        access: &A,\n        userid: &str,\n    ) -> Result<NeedsSaving, Error> {\n        let mut save = access.remove(userid)?;\n        if self.users.remove(userid).is_some() {\n            save = true;\n        }\n        Ok(save.into())\n    }\n}\n\n#[must_use = \"must save the config in order to ensure one-time use of recovery keys\"]\n#[derive(Clone, Copy)]\npub enum NeedsSaving {\n    No,\n    Yes,\n}\n\nimpl NeedsSaving {\n    /// Convenience method so we don't need to import the type name.\n    pub fn needs_saving(self) -> bool {\n        matches!(self, NeedsSaving::Yes)\n    }\n}\n\nimpl From<bool> for NeedsSaving {\n    fn from(v: bool) -> Self {\n        if v {\n            NeedsSaving::Yes\n        } else {\n            NeedsSaving::No\n        }\n    }\n}\n\n/// Mapping of userid to TFA entry.\npub type TfaUsers = HashMap<String, TfaUserData>;\n\n/// TFA data for a user.\n#[derive(Clone, Default, Deserialize, Serialize)]\n#[serde(deny_unknown_fields)]\n#[serde(rename_all = \"kebab-case\")]\npub struct TfaUserData {\n    /// Totp keys for a user.\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    pub totp: Vec<TfaEntry<Totp>>,\n\n    /// Registered u2f tokens for a user.\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    pub u2f: Vec<TfaEntry<u2f::Registration>>,\n\n    /// Registered webauthn tokens for a user.\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    pub webauthn: Vec<TfaEntry<WebauthnCredential>>,\n\n    /// Recovery keys. (Unordered OTP values).\n    #[serde(skip_serializing_if = \"Option::is_none\", default)]\n    pub recovery: Option<Recovery>,\n\n    /// Yubico keys for a user. NOTE: This is not directly supported currently, we just need this\n    /// available for PVE, where the yubico API server configuration is part if the realm.\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    pub yubico: Vec<TfaEntry<String>>,\n\n    /// Once a user runs into a TOTP limit they get locked out of TOTP until they successfully use\n    /// a recovery key.\n    #[serde(skip_serializing_if = \"bool_is_false\", default)]\n    pub totp_locked: bool,\n\n    /// If a user hits too many 2nd factor failures, they get completely blocked for a while.\n    #[serde(skip_serializing_if = \"Option::is_none\", default)]\n    pub tfa_blocked_until: Option<i64>,\n}\n\nimpl TfaUserData {\n    /// `true` if no second factors exist\n    pub fn is_empty(&self) -> bool {\n        self.totp.is_empty()\n            && self.u2f.is_empty()\n            && self.webauthn.is_empty()\n            && self.yubico.is_empty()\n            && self.recovery.is_none()\n    }\n\n    /// Find an entry by id, except for the \"recovery\" entry which we're currently treating\n    /// specially.\n    pub fn find_entry_mut<'a>(&'a mut self, id: &str) -> Option<&'a mut TfaInfo> {\n        for entry in &mut self.totp {\n            if entry.info.id == id {\n                return Some(&mut entry.info);\n            }\n        }\n\n        for entry in &mut self.webauthn {\n            if entry.info.id == id {\n                return Some(&mut entry.info);\n            }\n        }\n\n        for entry in &mut self.u2f {\n            if entry.info.id == id {\n                return Some(&mut entry.info);\n            }\n        }\n\n        for entry in &mut self.yubico {\n            if entry.info.id == id {\n                return Some(&mut entry.info);\n            }\n        }\n\n        None\n    }\n\n    /// Create a u2f registration challenge.\n    ///\n    /// The description is required at this point already mostly to better be able to identify such\n    /// challenges in the tfa config file if necessary. The user otherwise has no access to this\n    /// information at this point, as the challenge is identified by its actual challenge data\n    /// instead.\n    fn u2f_registration_challenge<A: ?Sized + OpenUserChallengeData>(\n        &mut self,\n        access: &A,\n        userid: &str,\n        u2f: &u2f::U2f,\n        description: String,\n    ) -> Result<String, Error> {\n        let challenge = serde_json::to_string(&u2f.registration_challenge()?)?;\n\n        let mut data = access.open(userid)?;\n        data.get_mut()\n            .u2f_registrations\n            .push(U2fRegistrationChallenge::new(\n                challenge.clone(),\n                description,\n            ));\n        data.save()?;\n\n        Ok(challenge)\n    }\n\n    fn u2f_registration_finish<A: ?Sized + OpenUserChallengeData>(\n        &mut self,\n        access: &A,\n        userid: &str,\n        u2f: &u2f::U2f,\n        challenge: &str,\n        response: &str,\n    ) -> Result<String, Error> {\n        let mut data = access.open(userid)?;\n        let entry = data\n            .get_mut()\n            .u2f_registration_finish(u2f, challenge, response)?;\n        data.save()?;\n\n        let id = entry.info.id.clone();\n        self.u2f.push(entry);\n        Ok(id)\n    }\n\n    /// Create a webauthn registration challenge.\n    ///\n    /// The description is required at this point already mostly to better be able to identify such\n    /// challenges in the tfa config file if necessary. The user otherwise has no access to this\n    /// information at this point, as the challenge is identified by its actual challenge data\n    /// instead.\n    fn webauthn_registration_challenge<A: ?Sized + OpenUserChallengeData>(\n        &mut self,\n        access: &A,\n        webauthn: Webauthn<WebauthnConfigInstance>,\n        userid: &str,\n        description: String,\n    ) -> Result<String, Error> {\n        let cred_ids: Vec<_> = self\n            .enabled_webauthn_entries()\n            .map(|cred| cred.cred_id.clone())\n            .collect();\n\n        let (challenge, state) = webauthn.generate_challenge_register_options(\n            userid.as_bytes().to_vec(),\n            userid.to_owned(),\n            userid.to_owned(),\n            Some(cred_ids),\n            Some(UserVerificationPolicy::Discouraged),\n            None,\n        )?;\n\n        let challenge_string = challenge.public_key.challenge.to_string();\n        let challenge = serde_json::to_string(&challenge)?;\n\n        let mut data = access.open(userid)?;\n        data.get_mut()\n            .webauthn_registrations\n            .push(WebauthnRegistrationChallenge::new(\n                state,\n                challenge_string,\n                description,\n            ));\n        data.save()?;\n\n        Ok(challenge)\n    }\n\n    /// Finish a webauthn registration. The challenge should correspond to an output of\n    /// `webauthn_registration_challenge`. The response should come directly from the client.\n    fn webauthn_registration_finish<A: ?Sized + OpenUserChallengeData>(\n        &mut self,\n        access: &A,\n        webauthn: Webauthn<WebauthnConfigInstance>,\n        userid: &str,\n        challenge: &str,\n        response: webauthn_rs::proto::RegisterPublicKeyCredential,\n    ) -> Result<String, Error> {\n        let mut data = access.open(userid)?;\n        let entry = data.get_mut().webauthn_registration_finish(\n            webauthn,\n            challenge,\n            response,\n            &self.webauthn,\n        )?;\n        data.save()?;\n\n        let id = entry.info.id.clone();\n        self.webauthn.push(entry);\n        Ok(id)\n    }\n\n    fn add_totp(&mut self, description: String, totp: Totp) -> String {\n        let entry = TfaEntry::new(description, totp);\n        let id = entry.info.id.clone();\n        self.totp.push(entry);\n        id\n    }\n\n    fn add_yubico(&mut self, description: String, key: String) -> String {\n        let entry = TfaEntry::new(description, key);\n        let id = entry.info.id.clone();\n        self.yubico.push(entry);\n        id\n    }\n\n    /// Add a new set of recovery keys. There can only be 1 set of keys at a time.\n    fn add_recovery(&mut self) -> Result<Vec<String>, Error> {\n        if self.recovery.is_some() {\n            bail!(\"user already has recovery keys\");\n        }\n\n        let (recovery, original) = Recovery::generate()?;\n\n        self.recovery = Some(recovery);\n\n        Ok(original)\n    }\n\n    /// Helper to iterate over enabled totp entries.\n    fn enabled_totp_entries(&self) -> impl Iterator<Item = &Totp> {\n        self.totp\n            .iter()\n            .filter_map(|e| if e.info.enable { Some(&e.entry) } else { None })\n    }\n\n    /// Helper to iterate over enabled u2f entries.\n    fn enabled_u2f_entries(&self) -> impl Iterator<Item = &u2f::Registration> {\n        self.u2f\n            .iter()\n            .filter_map(|e| if e.info.enable { Some(&e.entry) } else { None })\n    }\n\n    /// Helper to iterate over enabled u2f entries.\n    fn enabled_webauthn_entries(&self) -> impl Iterator<Item = &WebauthnCredential> {\n        self.webauthn\n            .iter()\n            .filter_map(|e| if e.info.enable { Some(&e.entry) } else { None })\n    }\n\n    /// Helper to iterate over enabled yubico entries.\n    pub fn enabled_yubico_entries(&self) -> impl Iterator<Item = &str> {\n        self.yubico.iter().filter_map(|e| {\n            if e.info.enable {\n                Some(e.entry.as_str())\n            } else {\n                None\n            }\n        })\n    }\n\n    /// Verify a totp challenge. The `value` should be the totp digits as plain text.\n    fn verify_totp(&self, value: &str) -> Result<(), Error> {\n        let now = std::time::SystemTime::now();\n\n        for entry in self.enabled_totp_entries() {\n            if entry.verify(value, now, -1..=1)?.is_some() {\n                return Ok(());\n            }\n        }\n\n        bail!(\"totp verification failed\");\n    }\n\n    /// Generate a generic TFA challenge. See the [`TfaChallenge`] description for details.\n    fn challenge<A: ?Sized + OpenUserChallengeData>(\n        &mut self,\n        access: &A,\n        userid: &str,\n        webauthn: Option<Webauthn<WebauthnConfigInstance>>,\n        u2f: Option<&u2f::U2f>,\n    ) -> Result<Option<TfaChallenge>, Error> {\n        if self.is_empty() {\n            return Ok(None);\n        }\n\n        // Since we don't bail out when failing to generate WA or U2F challenges, we keep track of\n        // whether we tried here, otherwise `challenge.check()` would consider these to be not\n        // configured by the user and might allow logging in without them on error.\n        let mut not_empty = false;\n\n        let challenge = TfaChallenge {\n            totp: self.totp.iter().any(|e| e.info.enable),\n            recovery: self.recovery_state(),\n            webauthn: match webauthn {\n                Some(webauthn) => match self.webauthn_challenge(access, userid, webauthn) {\n                    Ok(wa) => wa,\n                    Err(err) => {\n                        not_empty = true;\n                        log::error!(\"failed to generate webauthn challenge: {err}\");\n                        None\n                    }\n                },\n                None => None,\n            },\n            u2f: match u2f {\n                Some(u2f) => match self.u2f_challenge(access, userid, u2f) {\n                    Ok(u2f) => u2f,\n                    Err(err) => {\n                        not_empty = true;\n                        log::error!(\"failed to generate u2f challenge: {err}\");\n                        None\n                    }\n                },\n                None => None,\n            },\n            yubico: self.yubico.iter().any(|e| e.info.enable),\n        };\n\n        // This happens if 2nd factors exist but are all disabled.\n        if challenge.is_empty() && !not_empty {\n            return Ok(None);\n        }\n\n        Ok(Some(challenge))\n    }\n\n    /// Get the recovery state.\n    pub fn recovery_state(&self) -> Option<RecoveryState> {\n        self.recovery.as_ref().map(RecoveryState::from)\n    }\n\n    /// Generate an optional webauthn challenge.\n    fn webauthn_challenge<A: ?Sized + OpenUserChallengeData>(\n        &mut self,\n        access: &A,\n        userid: &str,\n        webauthn: Webauthn<WebauthnConfigInstance>,\n    ) -> Result<Option<webauthn_rs::proto::RequestChallengeResponse>, Error> {\n        if self.webauthn.is_empty() {\n            return Ok(None);\n        }\n\n        let creds: Vec<_> = self\n            .enabled_webauthn_entries()\n            .map(|cred| cred.clone().into())\n            .collect();\n\n        if creds.is_empty() {\n            return Ok(None);\n        }\n\n        let (challenge, state) = webauthn.generate_challenge_authenticate(creds)?;\n\n        let challenge_string = challenge.public_key.challenge.to_string();\n        let mut data = access.open(userid)?;\n        data.get_mut()\n            .webauthn_auths\n            .push(WebauthnAuthChallenge::new(state, challenge_string));\n        data.save()?;\n\n        Ok(Some(challenge))\n    }\n\n    /// Generate an optional u2f challenge.\n    fn u2f_challenge<A: ?Sized + OpenUserChallengeData>(\n        &self,\n        access: &A,\n        userid: &str,\n        u2f: &u2f::U2f,\n    ) -> Result<Option<U2fChallenge>, Error> {\n        if self.u2f.is_empty() {\n            return Ok(None);\n        }\n\n        let keys: Vec<crate::u2f::RegisteredKey> = self\n            .enabled_u2f_entries()\n            .map(|registration| registration.key.clone())\n            .collect();\n\n        if keys.is_empty() {\n            return Ok(None);\n        }\n\n        let challenge = U2fChallenge {\n            challenge: u2f.auth_challenge()?,\n            keys,\n        };\n\n        let mut data = access.open(userid)?;\n        data.get_mut()\n            .u2f_auths\n            .push(U2fChallengeEntry::new(&challenge));\n        data.save()?;\n\n        Ok(Some(challenge))\n    }\n\n    /// Verify a u2f response.\n    fn verify_u2f<A: ?Sized + OpenUserChallengeData>(\n        &self,\n        access: &A,\n        userid: &str,\n        u2f: u2f::U2f,\n        challenge: &crate::u2f::AuthChallenge,\n        response: Value,\n    ) -> Result<(), Error> {\n        let expire_before = proxmox_time::epoch_i64() - CHALLENGE_TIMEOUT_SECS;\n\n        let response: crate::u2f::AuthResponse = serde_json::from_value(response)\n            .map_err(|err| format_err!(\"invalid u2f response: {}\", err))?;\n\n        if let Some(entry) = self\n            .enabled_u2f_entries()\n            .find(|e| e.key.key_handle == response.key_handle())\n        {\n            if u2f\n                .auth_verify_obj(&entry.public_key, &challenge.challenge, response)?\n                .is_some()\n            {\n                let mut data = match access.open_no_create(userid)? {\n                    Some(data) => data,\n                    None => bail!(\"no such challenge\"),\n                };\n                let index = data\n                    .get_mut()\n                    .u2f_auths\n                    .iter()\n                    .position(|r| r == challenge)\n                    .ok_or_else(|| format_err!(\"no such challenge\"))?;\n                let entry = data.get_mut().u2f_auths.remove(index);\n                if entry.is_expired(expire_before) {\n                    bail!(\"no such challenge\");\n                }\n                data.save()\n                    .map_err(|err| format_err!(\"failed to save challenge file: {}\", err))?;\n\n                return Ok(());\n            }\n        }\n\n        bail!(\"u2f verification failed\");\n    }\n\n    /// Verify a webauthn response.\n    fn verify_webauthn<A: ?Sized + OpenUserChallengeData>(\n        &mut self,\n        access: &A,\n        userid: &str,\n        webauthn: Webauthn<WebauthnConfigInstance>,\n        mut response: Value,\n    ) -> Result<(), Error> {\n        let expire_before = proxmox_time::epoch_i64() - CHALLENGE_TIMEOUT_SECS;\n\n        let challenge = match response\n            .as_object_mut()\n            .ok_or_else(|| format_err!(\"invalid response, must be a json object\"))?\n            .remove(\"challenge\")\n            .ok_or_else(|| format_err!(\"missing challenge data in response\"))?\n        {\n            Value::String(s) => s,\n            _ => bail!(\"invalid challenge data in response\"),\n        };\n\n        let response: webauthn_rs::proto::PublicKeyCredential = serde_json::from_value(response)\n            .map_err(|err| format_err!(\"invalid webauthn response: {}\", err))?;\n\n        let mut data = match access.open_no_create(userid)? {\n            Some(data) => data,\n            None => bail!(\"no such challenge\"),\n        };\n\n        let index = data\n            .get_mut()\n            .webauthn_auths\n            .iter()\n            .position(|r| r.challenge == challenge)\n            .ok_or_else(|| format_err!(\"no such challenge\"))?;\n\n        let challenge = data.get_mut().webauthn_auths.remove(index);\n        if challenge.is_expired(expire_before) {\n            bail!(\"no such challenge\");\n        }\n\n        // we don't allow re-trying the challenge, so make the removal persistent now:\n        data.save()\n            .map_err(|err| format_err!(\"failed to save challenge file: {}\", err))?;\n\n        webauthn.authenticate_credential(&response, &challenge.state)?;\n\n        Ok(())\n    }\n\n    /// Verify a recovery key.\n    ///\n    /// NOTE: If successful, the key will automatically be removed from the list of available\n    /// recovery keys, so the configuration needs to be saved afterwards!\n    fn verify_recovery(&mut self, value: &str) -> Result<(), Error> {\n        if let Some(r) = &mut self.recovery {\n            if r.verify(value)? {\n                return Ok(());\n            }\n        }\n        bail!(\"recovery verification failed\");\n    }\n}\n\n/// A TFA entry for a user.\n///\n/// This simply connects a raw registration to a non optional descriptive text chosen by the user.\n#[derive(Clone, Deserialize, Serialize)]\n#[serde(deny_unknown_fields)]\npub struct TfaEntry<T> {\n    #[serde(flatten)]\n    pub info: TfaInfo,\n\n    /// The actual entry.\n    pub entry: T,\n}\n\nimpl<T> TfaEntry<T> {\n    /// Create an entry with a description. The id will be autogenerated.\n    fn new(description: String, entry: T) -> Self {\n        Self {\n            info: TfaInfo {\n                id: Uuid::generate().to_string(),\n                enable: true,\n                description,\n                created: proxmox_time::epoch_i64(),\n            },\n            entry,\n        }\n    }\n\n    /// Create a raw entry from a `TfaInfo` and the corresponding entry data.\n    pub fn from_parts(info: TfaInfo, entry: T) -> Self {\n        Self { info, entry }\n    }\n}\n\n/// When sending a TFA challenge to the user, we include information about what kind of challenge\n/// the user may perform. If webauthn credentials are available, a webauthn challenge will be\n/// included.\n#[derive(Deserialize, Serialize)]\n#[serde(rename_all = \"kebab-case\")]\npub struct TfaChallenge {\n    /// True if the user has TOTP devices.\n    #[serde(skip_serializing_if = \"bool_is_false\", default)]\n    pub totp: bool,\n\n    /// Whether there are recovery keys available.\n    #[serde(skip_serializing_if = \"Option::is_none\", default)]\n    pub recovery: Option<RecoveryState>,\n\n    /// If the user has any u2f tokens registered, this will contain the U2F challenge data.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub u2f: Option<U2fChallenge>,\n\n    /// If the user has any webauthn credentials registered, this will contain the corresponding\n    /// challenge data.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub webauthn: Option<webauthn_rs::proto::RequestChallengeResponse>,\n\n    /// True if the user has yubico keys configured.\n    #[serde(skip_serializing_if = \"bool_is_false\", default)]\n    pub yubico: bool,\n}\n\nimpl TfaChallenge {\n    pub fn is_empty(&self) -> bool {\n        !self.totp\n            && self.recovery.is_none()\n            && self.u2f.is_none()\n            && self.webauthn.is_none()\n            && !self.yubico\n    }\n}\n\nfn bool_is_false(v: &bool) -> bool {\n    !v\n}\n\n/// A user's response to a TFA challenge.\npub enum TfaResponse {\n    Totp(String),\n    U2f(Value),\n    Webauthn(Value),\n    Recovery(String),\n}\n\n/// This is part of the REST API:\nimpl std::str::FromStr for TfaResponse {\n    type Err = Error;\n\n    fn from_str(s: &str) -> Result<Self, Error> {\n        Ok(if let Some(totp) = s.strip_prefix(\"totp:\") {\n            TfaResponse::Totp(totp.to_string())\n        } else if let Some(u2f) = s.strip_prefix(\"u2f:\") {\n            TfaResponse::U2f(serde_json::from_str(u2f)?)\n        } else if let Some(webauthn) = s.strip_prefix(\"webauthn:\") {\n            TfaResponse::Webauthn(serde_json::from_str(webauthn)?)\n        } else if let Some(recovery) = s.strip_prefix(\"recovery:\") {\n            TfaResponse::Recovery(recovery.to_string())\n        } else {\n            bail!(\"invalid tfa response\");\n        })\n    }\n}\n\n/// Active TFA challenges per user, stored in a restricted temporary file on the machine handling\n/// the current user's authentication.\n#[derive(Default, Deserialize, Serialize)]\npub struct TfaUserChallenges {\n    /// Active u2f registration challenges for a user.\n    ///\n    /// Expired values are automatically filtered out while parsing the tfa configuration file.\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    #[serde(deserialize_with = \"filter_expired_challenge\")]\n    u2f_registrations: Vec<U2fRegistrationChallenge>,\n\n    /// Active u2f authentication challenges for a user.\n    ///\n    /// Expired values are automatically filtered out while parsing the tfa configuration file.\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    #[serde(deserialize_with = \"filter_expired_challenge\")]\n    u2f_auths: Vec<U2fChallengeEntry>,\n\n    /// Active webauthn registration challenges for a user.\n    ///\n    /// Expired values are automatically filtered out while parsing the tfa configuration file.\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    #[serde(deserialize_with = \"filter_expired_challenge\")]\n    webauthn_registrations: Vec<WebauthnRegistrationChallenge>,\n\n    /// Active webauthn authentication challenges for a user.\n    ///\n    /// Expired values are automatically filtered out while parsing the tfa configuration file.\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    #[serde(deserialize_with = \"filter_expired_challenge\")]\n    webauthn_auths: Vec<WebauthnAuthChallenge>,\n\n    /// Number of consecutive TOTP failures. Too many of those will lock out a user.\n    #[serde(skip_serializing_if = \"u32_is_zero\", default)]\n    totp_failures: u32,\n\n    /// Number of consecutive 2nd factor failures. When the limit is reached, the user is locked\n    /// out for 12 hours.\n    #[serde(skip_serializing_if = \"u32_is_zero\", default)]\n    tfa_failures: u32,\n}\n\nfn u32_is_zero(n: &u32) -> bool {\n    *n == 0\n}\n\n/// Serde helper using our `FilteredVecVisitor` to filter out expired entries directly at load\n/// time.\nfn filter_expired_challenge<'de, D, T>(deserializer: D) -> Result<Vec<T>, D::Error>\nwhere\n    D: serde::Deserializer<'de>,\n    T: Deserialize<'de> + IsExpired,\n{\n    let expire_before = proxmox_time::epoch_i64() - CHALLENGE_TIMEOUT_SECS;\n    deserializer.deserialize_seq(serde_tools::fold(\n        \"a challenge entry\",\n        |cap| cap.map(Vec::with_capacity).unwrap_or_else(Vec::new),\n        move |out, reg: T| {\n            if !reg.is_expired(expire_before) {\n                out.push(reg);\n            }\n        },\n    ))\n}\n\nimpl TfaUserChallenges {\n    /// Finish a u2f registration. The challenge should correspond to an output of\n    /// `u2f_registration_challenge` (which is a stringified `RegistrationChallenge`). The response\n    /// should come directly from the client.\n    fn u2f_registration_finish(\n        &mut self,\n        u2f: &u2f::U2f,\n        challenge: &str,\n        response: &str,\n    ) -> Result<TfaEntry<u2f::Registration>, Error> {\n        let expire_before = proxmox_time::epoch_i64() - CHALLENGE_TIMEOUT_SECS;\n\n        let index = self\n            .u2f_registrations\n            .iter()\n            .position(|r| r.challenge == challenge)\n            .ok_or_else(|| format_err!(\"no such challenge\"))?;\n\n        let reg = &self.u2f_registrations[index];\n        if reg.is_expired(expire_before) {\n            bail!(\"no such challenge\");\n        }\n\n        // the verify call only takes the actual challenge string, so we have to extract it\n        // (u2f::RegistrationChallenge did not always implement Deserialize...)\n        let chobj: Value = serde_json::from_str(challenge)\n            .map_err(|err| format_err!(\"error parsing original registration challenge: {}\", err))?;\n        let challenge = chobj[\"challenge\"]\n            .as_str()\n            .ok_or_else(|| format_err!(\"invalid registration challenge\"))?;\n\n        let (mut reg, description) = match u2f.registration_verify(challenge, response)? {\n            None => bail!(\"verification failed\"),\n            Some(reg) => {\n                let entry = self.u2f_registrations.remove(index);\n                (reg, entry.description)\n            }\n        };\n\n        // we do not care about the attestation certificates, so don't store them\n        reg.certificate.clear();\n\n        Ok(TfaEntry::new(description, reg))\n    }\n\n    /// Finish a webauthn registration. The challenge should correspond to an output of\n    /// `webauthn_registration_challenge`. The response should come directly from the client.\n    fn webauthn_registration_finish(\n        &mut self,\n        webauthn: Webauthn<WebauthnConfigInstance>,\n        challenge: &str,\n        response: webauthn_rs::proto::RegisterPublicKeyCredential,\n        existing_registrations: &[TfaEntry<WebauthnCredential>],\n    ) -> Result<TfaEntry<WebauthnCredential>, Error> {\n        let expire_before = proxmox_time::epoch_i64() - CHALLENGE_TIMEOUT_SECS;\n\n        let index = self\n            .webauthn_registrations\n            .iter()\n            .position(|r| r.challenge == challenge)\n            .ok_or_else(|| format_err!(\"no such challenge\"))?;\n\n        let reg = self.webauthn_registrations.remove(index);\n        if reg.is_expired(expire_before) {\n            bail!(\"no such challenge\");\n        }\n\n        let (credential, _authenticator) =\n            webauthn.register_credential(&response, &reg.state, |id| -> Result<bool, ()> {\n                Ok(existing_registrations\n                    .iter()\n                    .any(|cred| cred.entry.cred_id == *id))\n            })?;\n\n        Ok(TfaEntry::new(reg.description, credential.into()))\n    }\n}\n"], "filenames": ["proxmox-tfa/src/api/mod.rs"], "buggy_code_start_loc": [333], "buggy_code_end_loc": [926], "fixing_code_start_loc": [334], "fixing_code_end_loc": [949], "type": "NVD-CWE-noinfo", "message": "An issue in Proxmox Server Solutions GmbH Proxmox VE v.5.4 thru v.8.0, Proxmox Backup Server v.1.1 thru v.3.0, and Proxmox Mail Gateway v.7.1 thru v.8.0 allows a remote authenticated attacker to escalate privileges via bypassing the two-factor authentication component.", "other": {"cve": {"id": "CVE-2023-43320", "sourceIdentifier": "cve@mitre.org", "published": "2023-09-27T23:15:12.113", "lastModified": "2024-02-02T17:15:10.963", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue in Proxmox Server Solutions GmbH Proxmox VE v.5.4 thru v.8.0, Proxmox Backup Server v.1.1 thru v.3.0, and Proxmox Mail Gateway v.7.1 thru v.8.0 allows a remote authenticated attacker to escalate privileges via bypassing the two-factor authentication component."}, {"lang": "es", "value": "Un problema en Proxmox Server Solutions GmbH Proxmox VE v.5.4 hasta v.8.0, Proxmox Backup Server v.1.1 hasta v.3.0 y Proxmox Mail Gateway v.7.1 hasta v.8.0 permite a un atacante autenticado remoto escalar privilegios evitando el Componente de autenticaci\u00f3n de dos factores."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:proxmox:backup_server:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.1", "versionEndIncluding": "3.0", "matchCriteriaId": "026AA113-B499-4137-BB0E-18B1A1B80E63"}, {"vulnerable": true, "criteria": "cpe:2.3:a:proxmox:proxmox_mail_gateway:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.1", "versionEndIncluding": "8.0", "matchCriteriaId": "3454EA4B-BC66-4F9F-A3EA-F81668740672"}, {"vulnerable": true, "criteria": "cpe:2.3:a:proxmox:virtual_environment:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.4", "versionEndIncluding": "8.0", "matchCriteriaId": "B76EFF18-E949-4A2D-93E0-893ECAF4493C"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/176967/Proxmox-VE-7.4-1-TOTP-Brute-Force.html", "source": "cve@mitre.org"}, {"url": "https://bugzilla.proxmox.com/show_bug.cgi?id=4579", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "https://bugzilla.proxmox.com/show_bug.cgi?id=4584", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "https://github.com/proxmox/proxmox-rs/commit/50b793db8d3421bbfe2bce060a486263f18a90cb", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/proxmox/proxmox-rs/commit/50b793db8d3421bbfe2bce060a486263f18a90cb"}}