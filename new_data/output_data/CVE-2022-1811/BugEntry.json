{"buggy_code": ["# frozen_string_literal: true\n\nrequire \"marcel\"\n\nclass ResourceUploader < CarrierWave::Uploader::Base\n  include CarrierWave::MiniMagick\n  before :cache, :check_image_content_type!\n\n  def content_type_allowlist\n    [%r{image/}, %r{audio/}, %r{video/}, \"text/plain\"]\n  end\n\n  def store_dir\n    \"files/#{model.class.to_s.underscore}/#{model.id}\"\n  end\n\n  version :thumb, if: :image? do\n    process dynamic_resize_to_fit: :thumb\n  end\n\n  version :medium, if: :image? do\n    process dynamic_resize_to_fit: :medium\n  end\n\n  version :avatar, if: :image? do\n    process dynamic_resize_to_fit: :avatar\n  end\n\n  def dynamic_resize_to_fit(size)\n    resize_setting = model.blog.send(\"image_#{size}_size\").to_i\n\n    resize_to_fit(resize_setting, resize_setting)\n  end\n\n  def image?(new_file)\n    content_type = new_file.content_type\n    content_type&.include?(\"image\")\n  end\n\n  def check_image_content_type!(new_file)\n    if image?(new_file)\n      magic_type = mime_magic_content_type(new_file)\n      if magic_type != new_file.content_type\n        raise CarrierWave::IntegrityError, \"has MIME type mismatch\"\n      end\n    end\n  end\n\n  private\n\n  # NOTE: This method was adapted from MagicMimeBlacklist#extract_content_type\n  # from CarrierWave 1.0.0 and SanitizedFile#mime_magic_content_type from CarrierWave 0.11.2\n  def mime_magic_content_type(new_file)\n    content_type = nil\n\n    File.open(new_file.path) do |fd|\n      content_type = Marcel::MimeType.for(fd)\n    end\n\n    content_type\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\ndescribe Admin::ResourcesController, type: :controller do\n  render_views\n\n  before do\n    create(:blog)\n    admin = create :user, :as_admin\n    sign_in admin\n  end\n\n  describe \"#index\" do\n    before do\n      get :index\n    end\n\n    it \"renders index template\" do\n      assert_response :success\n      assert_template \"index\"\n      expect(assigns(:resources)).not_to be_nil\n    end\n  end\n\n  describe \"#destroy\" do\n    let(:uploaded_file) { file_upload(\"testfile.txt\", \"text/plain\") }\n\n    it \"redirects to the index\" do\n      res_id = create(:resource, upload: uploaded_file).id\n\n      delete :destroy, params: { id: res_id }\n      expect(response).to redirect_to(action: \"index\")\n    end\n  end\n\n  # TODO: Should be create, mkay?\n  describe \"#upload\" do\n    before do\n      ResourceUploader.enable_processing = true\n    end\n\n    after do\n      ResourceUploader.enable_processing = false\n    end\n\n    context \"when uploading a text file\" do\n      let(:upload) { file_upload(\"testfile.txt\", \"text/plain\") }\n\n      it \"creates a new Resource\" do\n        expect { post :upload, params: { upload: upload } }.\n          to change(Resource, :count).by(1)\n      end\n\n      it \"sets the content type to text/plain\" do\n        post :upload, params: { upload: upload }\n        expect(Resource.last.mime).to eq \"text/plain\"\n      end\n\n      it \"sets the flash to success\" do\n        post :upload, params: { upload: upload }\n        aggregate_failures do\n          expect(flash[:success]).not_to be_nil\n          expect(flash[:warning]).to be_nil\n        end\n      end\n    end\n\n    context \"when uploading an image file\" do\n      let(:upload) { file_upload(\"testfile.png\", \"image/png\") }\n\n      it \"creates a new Resource\" do\n        expect { post :upload, params: { upload: upload } }.\n          to change(Resource, :count).by(1)\n      end\n\n      it \"sets the content type correctly\" do\n        post :upload, params: { upload: upload }\n        expect(Resource.last.mime).to eq \"image/png\"\n      end\n\n      it \"sets the flash to success\" do\n        post :upload, params: { upload: upload }\n        aggregate_failures do\n          expect(flash[:success]).not_to be_nil\n          expect(flash[:warning]).to be_nil\n        end\n      end\n    end\n\n    context \"when attempting to upload a dangerous svg\" do\n      let(:upload) { file_upload(\"exploit.svg\", \"image/svg\") }\n\n      it \"does not create a new image Resource\" do\n        expect { post :upload, params: { upload: upload } }.\n          not_to change(Resource, :count)\n      end\n\n      it \"does not attempt to process the image\" do\n        post :upload, params: { upload: upload }\n        result = assigns(:up)\n        expect(result.errors[:upload]).\n          to match_array [\"has MIME type mismatch\", \"can't be blank\"]\n      end\n\n      it \"sets the flash to failure\" do\n        post :upload, params: { upload: upload }\n        aggregate_failures do\n          expect(flash[:success]).to be_nil\n          expect(flash[:warning]).not_to be_nil\n        end\n      end\n    end\n\n    context \"when attempting to upload a fake png with a txt extension\" do\n      let(:upload) { file_upload(\"testfile.txt\", \"image/png\") }\n\n      it \"does not create a new fake image Resource\" do\n        expect { post :upload, params: { upload: upload } }.\n          not_to change(Resource, :count)\n      end\n\n      it \"does not attempt to process a new fake image Resource\" do\n        post :upload, params: { upload: upload }\n        result = assigns(:up)\n        expect(result.errors[:upload]).\n          to match_array [\"has MIME type mismatch\", \"can't be blank\"]\n      end\n\n      it \"sets the flash to failure\" do\n        post :upload, params: { upload: upload }\n        aggregate_failures do\n          expect(flash[:success]).to be_nil\n          expect(flash[:warning]).not_to be_nil\n        end\n      end\n    end\n\n    context \"when attempting to upload a fake png with a png extension\" do\n      let(:upload) { file_upload(\"fakepng.png\", \"image/png\") }\n\n      it \"does not create a new fake image Resource\" do\n        expect { post :upload, params: { upload: upload } }.\n          not_to change(Resource, :count)\n      end\n\n      it \"does not attempt to process a new fake image Resource\" do\n        post :upload, params: { upload: upload }\n        result = assigns(:up)\n        expect(result.errors[:upload]).\n          to match_array [\"has MIME type mismatch\", \"can't be blank\"]\n      end\n\n      it \"sets the flash to failure\" do\n        post :upload, params: { upload: upload }\n        aggregate_failures do\n          expect(flash[:success]).to be_nil\n          expect(flash[:warning]).not_to be_nil\n        end\n      end\n    end\n\n    context \"when attempting to upload an html file\" do\n      let(:upload) { file_upload(\"just_some.html\", \"text/html\") }\n\n      it \"does not create a new Resource\" do\n        expect { post :upload, params: { upload: upload } }.\n          not_to change(Resource, :count)\n      end\n\n      it \"warns the user they can't upload this type of file\" do\n        post :upload, params: { upload: upload }\n        result = assigns(:up)\n        expect(result.errors[:upload]).\n          to match_array [\n            %r{You are not allowed to upload text/html files},\n            \"can't be blank\",\n          ]\n      end\n\n      it \"sets the flash to failure\" do\n        post :upload, params: { upload: upload }\n        aggregate_failures do\n          expect(flash[:success]).to be_nil\n          expect(flash[:warning]).not_to be_nil\n        end\n      end\n    end\n\n    context \"when uploading nothing\" do\n      it \"does not create a new Resource\" do\n        expect { post :upload }.\n          not_to change(Resource, :count)\n      end\n\n      it \"sets the flash to failure\" do\n        post :upload\n        aggregate_failures do\n          expect(flash[:success]).to be_nil\n          expect(flash[:warning]).not_to be_nil\n        end\n      end\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nrequire \"marcel\"\n\nclass ResourceUploader < CarrierWave::Uploader::Base\n  include CarrierWave::MiniMagick\n  before :cache, :check_content_type!\n\n  def content_type_allowlist\n    [%r{image/}, %r{audio/}, %r{video/}, \"text/plain\"]\n  end\n\n  def store_dir\n    \"files/#{model.class.to_s.underscore}/#{model.id}\"\n  end\n\n  version :thumb, if: :image? do\n    process dynamic_resize_to_fit: :thumb\n  end\n\n  version :medium, if: :image? do\n    process dynamic_resize_to_fit: :medium\n  end\n\n  version :avatar, if: :image? do\n    process dynamic_resize_to_fit: :avatar\n  end\n\n  def dynamic_resize_to_fit(size)\n    resize_setting = model.blog.send(\"image_#{size}_size\").to_i\n\n    resize_to_fit(resize_setting, resize_setting)\n  end\n\n  def image?(new_file)\n    content_type = new_file.content_type\n    content_type&.include?(\"image\")\n  end\n\n  def check_content_type!(new_file)\n    detected_type = if image? new_file\n                      file_content_content_type(new_file)\n                    else\n                      file_content_type(new_file)\n                    end\n    if detected_type != new_file.content_type\n      raise CarrierWave::IntegrityError, \"has MIME type mismatch\"\n    end\n  end\n\n  private\n\n  def file_content_content_type(new_file)\n    Marcel::MimeType.for Pathname.new(new_file.path)\n  end\n\n  def file_content_type(new_file)\n    Marcel::MimeType.for Pathname.new(new_file.path), name: new_file.filename\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\ndescribe Admin::ResourcesController, type: :controller do\n  render_views\n\n  before do\n    create(:blog)\n    admin = create :user, :as_admin\n    sign_in admin\n  end\n\n  describe \"#index\" do\n    before do\n      get :index\n    end\n\n    it \"renders index template\" do\n      assert_response :success\n      assert_template \"index\"\n      expect(assigns(:resources)).not_to be_nil\n    end\n  end\n\n  describe \"#destroy\" do\n    let(:uploaded_file) { file_upload(\"testfile.txt\", \"text/plain\") }\n\n    it \"redirects to the index\" do\n      res_id = create(:resource, upload: uploaded_file).id\n\n      delete :destroy, params: { id: res_id }\n      expect(response).to redirect_to(action: \"index\")\n    end\n  end\n\n  # TODO: Should be create, mkay?\n  describe \"#upload\" do\n    before do\n      ResourceUploader.enable_processing = true\n    end\n\n    after do\n      ResourceUploader.enable_processing = false\n    end\n\n    context \"when uploading a text file\" do\n      let(:upload) { file_upload(\"testfile.txt\", \"text/plain\") }\n\n      it \"creates a new Resource\" do\n        expect { post :upload, params: { upload: upload } }.\n          to change(Resource, :count).by(1)\n      end\n\n      it \"sets the content type to text/plain\" do\n        post :upload, params: { upload: upload }\n        expect(Resource.last.mime).to eq \"text/plain\"\n      end\n\n      it \"sets the flash to success\" do\n        post :upload, params: { upload: upload }\n        aggregate_failures do\n          expect(flash[:success]).not_to be_nil\n          expect(flash[:warning]).to be_nil\n        end\n      end\n    end\n\n    context \"when uploading an image file\" do\n      let(:upload) { file_upload(\"testfile.png\", \"image/png\") }\n\n      it \"creates a new Resource\" do\n        expect { post :upload, params: { upload: upload } }.\n          to change(Resource, :count).by(1)\n      end\n\n      it \"sets the content type correctly\" do\n        post :upload, params: { upload: upload }\n        expect(Resource.last.mime).to eq \"image/png\"\n      end\n\n      it \"sets the flash to success\" do\n        post :upload, params: { upload: upload }\n        aggregate_failures do\n          expect(flash[:success]).not_to be_nil\n          expect(flash[:warning]).to be_nil\n        end\n      end\n    end\n\n    context \"when attempting to upload a dangerous svg\" do\n      let(:upload) { file_upload(\"exploit.svg\", \"image/svg\") }\n\n      it \"does not create a new image Resource\" do\n        expect { post :upload, params: { upload: upload } }.\n          not_to change(Resource, :count)\n      end\n\n      it \"does not attempt to process the image\" do\n        post :upload, params: { upload: upload }\n        result = assigns(:up)\n        expect(result.errors[:upload]).\n          to match_array [\"has MIME type mismatch\", \"can't be blank\"]\n      end\n\n      it \"sets the flash to failure\" do\n        post :upload, params: { upload: upload }\n        aggregate_failures do\n          expect(flash[:success]).to be_nil\n          expect(flash[:warning]).not_to be_nil\n        end\n      end\n    end\n\n    context \"when attempting to upload a fake png with a txt extension\" do\n      let(:upload) { file_upload(\"testfile.txt\", \"image/png\") }\n\n      it \"does not create a new fake image Resource\" do\n        expect { post :upload, params: { upload: upload } }.\n          not_to change(Resource, :count)\n      end\n\n      it \"does not attempt to process a new fake image Resource\" do\n        post :upload, params: { upload: upload }\n        result = assigns(:up)\n        expect(result.errors[:upload]).\n          to match_array [\"has MIME type mismatch\", \"can't be blank\"]\n      end\n\n      it \"sets the flash to failure\" do\n        post :upload, params: { upload: upload }\n        aggregate_failures do\n          expect(flash[:success]).to be_nil\n          expect(flash[:warning]).not_to be_nil\n        end\n      end\n    end\n\n    context \"when attempting to upload a fake png with a png extension\" do\n      let(:upload) { file_upload(\"fakepng.png\", \"image/png\") }\n\n      it \"does not create a new fake image Resource\" do\n        expect { post :upload, params: { upload: upload } }.\n          not_to change(Resource, :count)\n      end\n\n      it \"does not attempt to process a new fake image Resource\" do\n        post :upload, params: { upload: upload }\n        result = assigns(:up)\n        expect(result.errors[:upload]).\n          to match_array [\"has MIME type mismatch\", \"can't be blank\"]\n      end\n\n      it \"sets the flash to failure\" do\n        post :upload, params: { upload: upload }\n        aggregate_failures do\n          expect(flash[:success]).to be_nil\n          expect(flash[:warning]).not_to be_nil\n        end\n      end\n    end\n\n    context \"when attempting to upload an html file\" do\n      let(:upload) { file_upload(\"just_some.html\", \"text/html\") }\n\n      it \"does not create a new Resource\" do\n        expect { post :upload, params: { upload: upload } }.\n          not_to change(Resource, :count)\n      end\n\n      it \"warns the user they can't upload this type of file\" do\n        post :upload, params: { upload: upload }\n        result = assigns(:up)\n        expect(result.errors[:upload]).\n          to match_array [\n            %r{You are not allowed to upload text/html files},\n            \"can't be blank\",\n          ]\n      end\n\n      it \"sets the flash to failure\" do\n        post :upload, params: { upload: upload }\n        aggregate_failures do\n          expect(flash[:success]).to be_nil\n          expect(flash[:warning]).not_to be_nil\n        end\n      end\n    end\n\n    context \"when attempting to upload an html file as text/plain\" do\n      let(:upload) { file_upload(\"just_some.html\", \"text/plain\") }\n\n      it \"does not create a new Resource\" do\n        expect { post :upload, params: { upload: upload } }.\n          not_to change(Resource, :count)\n      end\n\n      it \"warns the user they can't upload this type of file\" do\n        post :upload, params: { upload: upload }\n        result = assigns(:up)\n        expect(result.errors[:upload]).\n          to match_array [\"has MIME type mismatch\", \"can't be blank\"]\n      end\n\n      it \"sets the flash to failure\" do\n        post :upload, params: { upload: upload }\n        aggregate_failures do\n          expect(flash[:success]).to be_nil\n          expect(flash[:warning]).not_to be_nil\n        end\n      end\n    end\n\n    context \"when uploading nothing\" do\n      it \"does not create a new Resource\" do\n        expect { post :upload }.\n          not_to change(Resource, :count)\n      end\n\n      it \"sets the flash to failure\" do\n        post :upload\n        aggregate_failures do\n          expect(flash[:success]).to be_nil\n          expect(flash[:warning]).not_to be_nil\n        end\n      end\n    end\n  end\nend\n"], "filenames": ["publify_core/app/uploaders/resource_uploader.rb", "publify_core/spec/controllers/admin/resources_controller_spec.rb"], "buggy_code_start_loc": [7, 189], "buggy_code_end_loc": [61, 189], "fixing_code_start_loc": [7, 190], "fixing_code_end_loc": [59, 214], "type": "CWE-79", "message": "Unrestricted Upload of File with Dangerous Type in GitHub repository publify/publify prior to 9.2.9.", "other": {"cve": {"id": "CVE-2022-1811", "sourceIdentifier": "security@huntr.dev", "published": "2022-05-23T16:16:06.963", "lastModified": "2022-06-02T22:57:49.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Unrestricted Upload of File with Dangerous Type in GitHub repository publify/publify prior to 9.2.9."}, {"lang": "es", "value": "Una Carga no Restringida de un Archivo con un Tipo Peligroso en el repositorio GitHub publify/publify versiones anteriores a 9.2.9"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 5.3}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-434"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:publify_project:publify:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.2.9", "matchCriteriaId": "FF11F0A5-4738-433F-9CBE-0312BE9B3DB2"}]}]}], "references": [{"url": "https://github.com/publify/publify/commit/0fb6b027fbaf17f6a6551f2148482a03eac12927", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/4d97f665-c9f1-4c38-b774-692255a7c44c", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/publify/publify/commit/0fb6b027fbaf17f6a6551f2148482a03eac12927"}}