{"buggy_code": ["/**\n * xrdp: A Remote Desktop Protocol server.\n *\n * Copyright (C) Jay Sorg 2004-2014\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * main include file\n */\n\n#ifndef _XRDP_XRDP_H_\n#define _XRDP_XRDP_H_\n\n/* include other h files */\n#include \"arch.h\"\n#include \"parse.h\"\n#include \"trans.h\"\n#include \"list.h\"\n#include \"list16.h\"\n#include \"libxrdpinc.h\"\n#include \"xrdp_constants.h\"\n#include \"xrdp_types.h\"\n#include \"defines.h\"\n#include \"os_calls.h\"\n#include \"ssl_calls.h\"\n#include \"thread_calls.h\"\n#include \"file.h\"\n#include \"xrdp_client_info.h\"\n#include \"log.h\"\n\n/* xrdp.c */\nlong\ng_xrdp_sync(long (*sync_func)(long param1, long param2), long sync_param1,\n            long sync_param2);\nint\nxrdp_child_fork(void);\nlong\ng_get_sync_mutex(void);\nvoid\ng_set_sync_mutex(long mutex);\nlong\ng_get_sync1_mutex(void);\nvoid\ng_set_sync1_mutex(long mutex);\nvoid\ng_set_term_event(tbus event);\nvoid\ng_set_sigchld_event(tbus event);\nvoid\ng_set_sync_event(tbus event);\nlong\ng_get_threadid(void);\nvoid\ng_set_threadid(long id);\ntbus\ng_get_term(void);\ntbus\ng_get_sigchld(void);\nint\ng_is_term(void);\nvoid\ng_set_term(int in_val);\nvoid\ng_set_sigchld(int in_val);\ntbus\ng_get_sync_event(void);\nvoid\ng_process_waiting_function(void);\n\n/* xrdp_cache.c */\nstruct xrdp_cache *\nxrdp_cache_create(struct xrdp_wm *owner, struct xrdp_session *session,\n                  struct xrdp_client_info *client_info);\nvoid\nxrdp_cache_delete(struct xrdp_cache *self);\nint\nxrdp_cache_reset(struct xrdp_cache *self,\n                 struct xrdp_client_info *client_info);\nint\nxrdp_cache_add_bitmap(struct xrdp_cache *self, struct xrdp_bitmap *bitmap,\n                      int hints);\nint\nxrdp_cache_add_palette(struct xrdp_cache *self, int *palette);\nint\nxrdp_cache_add_char(struct xrdp_cache *self,\n                    struct xrdp_font_char *font_item);\nint\nxrdp_cache_add_pointer(struct xrdp_cache *self,\n                       struct xrdp_pointer_item *pointer_item);\nint\nxrdp_cache_add_pointer_static(struct xrdp_cache *self,\n                              struct xrdp_pointer_item *pointer_item,\n                              int index);\nint\nxrdp_cache_add_brush(struct xrdp_cache *self,\n                     char *brush_item_data);\nint\nxrdp_cache_add_os_bitmap(struct xrdp_cache *self, struct xrdp_bitmap *bitmap,\n                         int rdpindex);\nint\nxrdp_cache_remove_os_bitmap(struct xrdp_cache *self, int rdpindex);\nstruct xrdp_os_bitmap_item *\nxrdp_cache_get_os_bitmap(struct xrdp_cache *self, int rdpindex);\n\n/* xrdp_wm.c */\nstruct xrdp_wm *\nxrdp_wm_create(struct xrdp_process *owner,\n               struct xrdp_client_info *client_info);\nvoid\nxrdp_wm_delete(struct xrdp_wm *self);\nint\nxrdp_wm_send_palette(struct xrdp_wm *self);\nint\nxrdp_wm_send_bell(struct xrdp_wm *self);\nint\nxrdp_wm_load_static_colors_plus(struct xrdp_wm *self, char *autorun_name);\nint\nxrdp_wm_load_static_pointers(struct xrdp_wm *self);\nint\nxrdp_wm_init(struct xrdp_wm *self);\nint\nxrdp_wm_send_bitmap(struct xrdp_wm *self, struct xrdp_bitmap *bitmap,\n                    int x, int y, int cx, int cy);\nint\nxrdp_wm_set_pointer(struct xrdp_wm *self, int cache_idx);\nunsigned int\nxrdp_wm_htoi (const char *ptr);\nint\nxrdp_wm_set_focused(struct xrdp_wm *self, struct xrdp_bitmap *wnd);\nint\nxrdp_wm_get_vis_region(struct xrdp_wm *self, struct xrdp_bitmap *bitmap,\n                       int x, int y, int cx, int cy,\n                       struct xrdp_region *region, int clip_children);\nint\nxrdp_wm_mouse_move(struct xrdp_wm *self, int x, int y);\nint\nxrdp_wm_mouse_touch(struct xrdp_wm *self, int gesture, int param);\nint\nxrdp_wm_mouse_click(struct xrdp_wm *self, int x, int y, int but, int down);\nint\nxrdp_wm_key(struct xrdp_wm *self, int device_flags, int scan_code);\nint\nxrdp_wm_key_sync(struct xrdp_wm *self, int device_flags, int key_flags);\nint\nxrdp_wm_pu(struct xrdp_wm *self, struct xrdp_bitmap *control);\nint\nxrdp_wm_send_pointer(struct xrdp_wm *self, int cache_idx,\n                     char *data, char *mask, int x, int y, int bpp,\n                     int width, int height);\nint\nxrdp_wm_pointer(struct xrdp_wm *self, char *data, char *mask, int x, int y,\n                int bpp, int width, int height);\nint\ncallback(intptr_t id, int msg, intptr_t param1, intptr_t param2,\n         intptr_t param3, intptr_t param4);\nint\nxrdp_wm_delete_all_children(struct xrdp_wm *self);\nint\nxrdp_wm_show_log(struct xrdp_wm *self);\nint\nxrdp_wm_log_msg(struct xrdp_wm *self, enum logLevels loglevel,\n                const char *fmt, ...) printflike(3, 4);\nint\nxrdp_wm_get_wait_objs(struct xrdp_wm *self, tbus *robjs, int *rc,\n                      tbus *wobjs, int *wc, int *timeout);\nint\nxrdp_wm_check_wait_objs(struct xrdp_wm *self);\nconst char *\nxrdp_wm_login_state_to_str(enum wm_login_state login_state);\nint\nxrdp_wm_set_login_state(struct xrdp_wm *self, enum wm_login_state login_state);\nint\nxrdp_wm_can_resize(struct xrdp_wm *self);\nvoid\nxrdp_wm_mod_connect_done(struct xrdp_wm *self, int status);\n\n/* xrdp_process.c */\nstruct xrdp_process *\nxrdp_process_create(struct xrdp_listen *owner, tbus done_event);\nvoid\nxrdp_process_delete(struct xrdp_process *self);\nint\nxrdp_process_main_loop(struct xrdp_process *self);\n\n/* xrdp_listen.c */\nstruct xrdp_listen *\nxrdp_listen_create(void);\nvoid\nxrdp_listen_delete(struct xrdp_listen *self);\nint\nxrdp_listen_main_loop(struct xrdp_listen *self);\nint\nxrdp_listen_test(struct xrdp_startup_params *startup_params);\n\n/* xrdp_region.c */\nstruct xrdp_region *\nxrdp_region_create(struct xrdp_wm *wm);\nvoid\nxrdp_region_delete(struct xrdp_region *self);\nint\nxrdp_region_add_rect(struct xrdp_region *self, struct xrdp_rect *rect);\nint\nxrdp_region_subtract_rect(struct xrdp_region *self, struct xrdp_rect *rect);\nint\nxrdp_region_intersect_rect(struct xrdp_region *self, struct xrdp_rect *rect);\nint\nxrdp_region_get_rect(struct xrdp_region *self, int index,\n                     struct xrdp_rect *rect);\nint\nxrdp_region_get_bounds(struct xrdp_region *self, struct xrdp_rect *rect);\nint\nxrdp_region_not_empty(struct xrdp_region *self);\n\n/* xrdp_bitmap_common.c */\nstruct xrdp_bitmap *\nxrdp_bitmap_create(int width, int height, int bpp,\n                   int type, struct xrdp_wm *wm);\nstruct xrdp_bitmap *\nxrdp_bitmap_create_with_data(int width, int height,\n                             int bpp, char *data,\n                             struct xrdp_wm *wm);\nvoid\nxrdp_bitmap_delete(struct xrdp_bitmap *self);\nint\nxrdp_bitmap_resize(struct xrdp_bitmap *self, int width, int height);\nint\nxrdp_bitmap_get_pixel(struct xrdp_bitmap *self, int x, int y);\nint\nxrdp_bitmap_set_pixel(struct xrdp_bitmap *self, int x, int y, int pixel);\nint\nxrdp_bitmap_copy_box(struct xrdp_bitmap *self,\n                     struct xrdp_bitmap *dest,\n                     int x, int y, int cx, int cy);\n\n/* xrdp_bitmap.c */\nstruct xrdp_bitmap *\nxrdp_bitmap_get_child_by_id(struct xrdp_bitmap *self, int id);\nint\nxrdp_bitmap_set_focus(struct xrdp_bitmap *self, int focused);\nint\nxrdp_bitmap_hash_crc(struct xrdp_bitmap *self);\nint\nxrdp_bitmap_copy_box_with_crc(struct xrdp_bitmap *self,\n                              struct xrdp_bitmap *dest,\n                              int x, int y, int cx, int cy);\nint\nxrdp_bitmap_compare(struct xrdp_bitmap *self,\n                    struct xrdp_bitmap *b);\nint\nxrdp_bitmap_invalidate(struct xrdp_bitmap *self, struct xrdp_rect *rect);\nint\nxrdp_bitmap_def_proc(struct xrdp_bitmap *self, int msg,\n                     int param1, int param2);\nint\nxrdp_bitmap_to_screenx(struct xrdp_bitmap *self, int x);\nint\nxrdp_bitmap_to_screeny(struct xrdp_bitmap *self, int y);\nint\nxrdp_bitmap_from_screenx(struct xrdp_bitmap *self, int x);\nint\nxrdp_bitmap_from_screeny(struct xrdp_bitmap *self, int y);\nint\nxrdp_bitmap_get_screen_clip(struct xrdp_bitmap *self,\n                            struct xrdp_painter *painter,\n                            struct xrdp_rect *rect,\n                            int *dx, int *dy);\n\n/* xrdp_bitmap_load.c */\n/**\n * Loads a bitmap from a file and (optionally) transforms it\n *\n * @param self from rdp_bitmap_create()\n * @param filename Filename to load\n * @param[in] palette For 8-bit conversions. Currently unused\n * @param background Background color for alpha-blending\n * @param transform Transform to apply to the image after loading\n * @param twidth target width if transform != XBLT_NONE\n * @param theight target height if transform != XBLT_NONE\n * @return 0 for success.\n *\n * The background color is only used if the specified image contains\n * an alpha layer. It is in HCOLOR format, and the bpp must correspond to\n * the bpp used to create 'self'.\n *\n * After a successful call, the bitmap is resized to the image file size.\n *\n * If the call is not successful, the bitmap will be in an indeterminate\n * state and should not be used.\n */\nint\nxrdp_bitmap_load(struct xrdp_bitmap *self, const char *filename,\n                 const int *palette,\n                 int background,\n                 enum xrdp_bitmap_load_transform transform,\n                 int twidth,\n                 int theight);\n/* xrdp_painter.c */\nstruct xrdp_painter *\nxrdp_painter_create(struct xrdp_wm *wm, struct xrdp_session *session);\nvoid\nxrdp_painter_delete(struct xrdp_painter *self);\nint\nwm_painter_set_target(struct xrdp_painter *self);\nint\nxrdp_painter_begin_update(struct xrdp_painter *self);\nint\nxrdp_painter_end_update(struct xrdp_painter *self);\nint\nxrdp_painter_font_needed(struct xrdp_painter *self);\nint\nxrdp_painter_set_clip(struct xrdp_painter *self,\n                      int x, int y, int cx, int cy);\nint\nxrdp_painter_clr_clip(struct xrdp_painter *self);\nint\nxrdp_painter_fill_rect(struct xrdp_painter *self,\n                       struct xrdp_bitmap *bitmap,\n                       int x, int y, int cx, int cy);\nint\nxrdp_painter_draw_bitmap(struct xrdp_painter *self,\n                         struct xrdp_bitmap *bitmap,\n                         struct xrdp_bitmap *to_draw,\n                         int x, int y, int cx, int cy);\nint\nxrdp_painter_text_width(struct xrdp_painter *self, const char *text);\nunsigned int\nxrdp_painter_font_body_height(const struct xrdp_painter *self);\nint\nxrdp_painter_draw_text(struct xrdp_painter *self,\n                       struct xrdp_bitmap *bitmap,\n                       int x, int y, const char *text);\nint\nxrdp_painter_draw_text2(struct xrdp_painter *self,\n                        struct xrdp_bitmap *bitmap,\n                        int font, int flags, int mixmode,\n                        int clip_left, int clip_top,\n                        int clip_right, int clip_bottom,\n                        int box_left, int box_top,\n                        int box_right, int box_bottom,\n                        int x, int y, char *data, int data_len);\nint\nxrdp_painter_copy(struct xrdp_painter *self,\n                  struct xrdp_bitmap *src,\n                  struct xrdp_bitmap *dst,\n                  int x, int y, int cx, int cy,\n                  int srcx, int srcy);\nint\nxrdp_painter_composite(struct xrdp_painter *self,\n                       struct xrdp_bitmap *src,\n                       int srcformat,\n                       int srcwidth,\n                       int srcrepeat,\n                       struct xrdp_bitmap *dst,\n                       int *srctransform,\n                       int mskflags,\n                       struct xrdp_bitmap *msk,\n                       int mskformat, int mskwidth, int mskrepeat, int op,\n                       int srcx, int srcy, int mskx, int msky,\n                       int dstx, int dsty, int width, int height,\n                       int dstformat);\nint\nxrdp_painter_line(struct xrdp_painter *self,\n                  struct xrdp_bitmap *bitmap,\n                  int x1, int y1, int x2, int y2);\n\n/* xrdp_font.c */\nstruct xrdp_font *\nxrdp_font_create(struct xrdp_wm *wm, unsigned int dpi);\nvoid\nxrdp_font_delete(struct xrdp_font *self);\nint\nxrdp_font_item_compare(struct xrdp_font_char *font1,\n                       struct xrdp_font_char *font2);\n\n/* funcs.c */\nint\nrect_contains_pt(struct xrdp_rect *in, int x, int y);\nint\nrect_intersect(struct xrdp_rect *in1, struct xrdp_rect *in2,\n               struct xrdp_rect *out);\nint\nrect_contained_by(struct xrdp_rect *in1, int left, int top,\n                  int right, int bottom);\nint\ncheck_bounds(struct xrdp_bitmap *b, int *x, int *y, int *cx, int *cy);\nint\nadd_char_at(char *text, int text_size, twchar ch, int index);\nint\nremove_char_at(char *text, int text_size, int index);\nint\nset_string(char **in_str, const char *in);\nint\nwchar_repeat(twchar *dest, int dest_size_in_wchars, twchar ch, int repeat);\n\n/* in lang.c */\nstruct xrdp_key_info *\nget_key_info_from_scan_code(int device_flags, int scan_code, int *keys,\n                            int caps_lock, int num_lock, int scroll_lock,\n                            struct xrdp_keymap *keymap);\nint\nget_keysym_from_scan_code(int device_flags, int scan_code, int *keys,\n                          int caps_lock, int num_lock, int scroll_lock,\n                          struct xrdp_keymap *keymap);\ntwchar\nget_char_from_scan_code(int device_flags, int scan_code, int *keys,\n                        int caps_lock, int num_lock, int scroll_lock,\n                        struct xrdp_keymap *keymap);\nint\nget_keymaps(int keylayout, struct xrdp_keymap *keymap);\n\nint\nkm_load_file(const char *filename, struct xrdp_keymap *keymap);\n\n/* xrdp_login_wnd.c */\n/**\n * Gets the DPI of the login (primary) monitor\n *\n * @param self xrdp_wm instance\n * @return DPI of primary monitor, or 0 if unavailable.\n */\nunsigned int\nxrdp_login_wnd_get_monitor_dpi(struct xrdp_wm *self);\nint\nxrdp_login_wnd_create(struct xrdp_wm *self);\nint\nload_xrdp_config(struct xrdp_config *config, const char *xrdp_ini, int bpp);\nvoid\nxrdp_login_wnd_scale_config_values(struct xrdp_wm *self);\n\n/* xrdp_bitmap_compress.c */\nint\nxrdp_bitmap_compress(char *in_data, int width, int height,\n                     struct stream *s, int bpp, int byte_limit,\n                     int start_line, struct stream *temp,\n                     int e);\n\n/* xrdp_mm.c */\n\nstruct display_control_monitor_layout_data\n{\n    struct display_size_description description;\n    enum display_resize_state state;\n    int last_state_update_timestamp;\n    int start_time;\n};\n\nint\nxrdp_mm_drdynvc_up(struct xrdp_mm *self);\nint\nxrdp_mm_suppress_output(struct xrdp_mm *self, int suppress,\n                        int left, int top, int right, int bottom);\nstruct xrdp_mm *\nxrdp_mm_create(struct xrdp_wm *owner);\nvoid\nxrdp_mm_delete(struct xrdp_mm *self);\nvoid\nxrdp_mm_connect(struct xrdp_mm *self);\nint\nxrdp_mm_process_channel_data(struct xrdp_mm *self, tbus param1, tbus param2,\n                             tbus param3, tbus param4);\nint\nxrdp_mm_get_wait_objs(struct xrdp_mm *self,\n                      tbus *read_objs, int *rcount,\n                      tbus *write_objs, int *wcount, int *timeout);\nint\nxrdp_mm_check_chan(struct xrdp_mm *self);\nint\nxrdp_mm_check_wait_objs(struct xrdp_mm *self);\nint\nxrdp_mm_frame_ack(struct xrdp_mm *self, int frame_id);\nint\nxrdp_mm_egfx_send_planar_bitmap(struct xrdp_mm *self,\n                                struct xrdp_bitmap *bitmap,\n                                struct xrdp_rect *rect);\nint\nserver_begin_update(struct xrdp_mod *mod);\nint\nserver_end_update(struct xrdp_mod *mod);\nint\nserver_bell_trigger(struct xrdp_mod *mod);\nint\nserver_chansrv_in_use(struct xrdp_mod *mod);\nint\nserver_fill_rect(struct xrdp_mod *mod, int x, int y, int cx, int cy);\nint\nserver_screen_blt(struct xrdp_mod *mod, int x, int y, int cx, int cy,\n                  int srcx, int srcy);\nint\nserver_paint_rect(struct xrdp_mod *mod, int x, int y, int cx, int cy,\n                  char *data, int width, int height, int srcx, int srcy);\nint\nserver_paint_rect_bpp(struct xrdp_mod *mod, int x, int y, int cx, int cy,\n                      char *data, int width, int height, int srcx, int srcy,\n                      int bpp);\nint\nserver_composite(struct xrdp_mod *mod, int srcidx, int srcformat, int srcwidth,\n                 int srcrepeat, int *srctransform, int mskflags, int mskidx,\n                 int mskformat, int mskwidth, int mskrepeat, int op,\n                 int srcx, int srcy, int mskx, int msky,\n                 int dstx, int dsty, int width, int height, int dstformat);\nint\nserver_paint_rects(struct xrdp_mod *mod, int num_drects, short *drects,\n                   int num_crects, short *crects,\n                   char *data, int width, int height,\n                   int flags, int frame_id);\nint\nserver_set_pointer(struct xrdp_mod *mod, int x, int y,\n                   char *data, char *mask);\nint\nserver_set_pointer_ex(struct xrdp_mod *mod, int x, int y,\n                      char *data, char *mask, int bpp);\nint\nserver_set_pointer_large(struct xrdp_mod *mod, int x, int y,\n                         char *data, char *mask, int bpp,\n                         int width, int height);\nint\nserver_paint_rects_ex(struct xrdp_mod *mod, int num_drects, short *drects,\n                      int num_crects, short *crects,\n                      char *data, int left, int top,\n                      int width, int height,\n                      int flags, int frame_id,\n                      void *shmem_ptr, int shmem_bytes);\nint\nserver_palette(struct xrdp_mod *mod, int *palette);\nint\nserver_msg(struct xrdp_mod *mod, const char *msg, int code);\nint\nserver_set_clip(struct xrdp_mod *mod, int x, int y, int cx, int cy);\nint\nserver_reset_clip(struct xrdp_mod *mod);\nint\nserver_set_fgcolor(struct xrdp_mod *mod, int fgcolor);\nint\nserver_set_bgcolor(struct xrdp_mod *mod, int bgcolor);\nint\nserver_set_opcode(struct xrdp_mod *mod, int opcode);\nint\nserver_set_mixmode(struct xrdp_mod *mod, int mixmode);\nint\nserver_set_brush(struct xrdp_mod *mod, int x_origin, int y_origin,\n                 int style, char *pattern);\nint\nserver_set_pen(struct xrdp_mod *mod, int style, int width);\nint\nserver_draw_line(struct xrdp_mod *mod, int x1, int y1, int x2, int y2);\nint\nserver_add_char(struct xrdp_mod *mod, int font, int character,\n                int offset, int baseline,\n                int width, int height, char *data);\nint\nserver_draw_text(struct xrdp_mod *mod, int font,\n                 int flags, int mixmode, int clip_left, int clip_top,\n                 int clip_right, int clip_bottom,\n                 int box_left, int box_top,\n                 int box_right, int box_bottom,\n                 int x, int y, char *data, int data_len);\nint\nserver_reset(struct xrdp_mod *mod, int width, int height, int bpp);\nint\nis_channel_allowed(struct xrdp_wm *wm, int channel_id);\nint\nserver_get_channel_count(struct xrdp_mod *mod);\nint\nserver_query_channel(struct xrdp_mod *mod, int index, char *channel_name,\n                     int *channel_flags);\nint\nserver_get_channel_id(struct xrdp_mod *mod, const char *name);\nint\nserver_send_to_channel(struct xrdp_mod *mod, int channel_id,\n                       char *data, int data_len,\n                       int total_data_len, int flags);\nint\nserver_create_os_surface(struct xrdp_mod *mod, int id,\n                         int width, int height);\nint\nserver_create_os_surface_bpp(struct xrdp_mod *mod, int id,\n                             int width, int height, int bpp);\nint\nserver_switch_os_surface(struct xrdp_mod *mod, int id);\nint\nserver_delete_os_surface(struct xrdp_mod *mod, int id);\nint\nserver_paint_rect_os(struct xrdp_mod *mod, int x, int y, int cx, int cy,\n                     int id, int srcx, int srcy);\nint\nserver_set_hints(struct xrdp_mod *mod, int hints, int mask);\nint\nserver_window_new_update(struct xrdp_mod *mod, int window_id,\n                         struct rail_window_state_order *window_state,\n                         int flags);\nint\nserver_window_delete(struct xrdp_mod *mod, int window_id);\nint\nserver_window_icon(struct xrdp_mod *mod, int window_id, int cache_entry,\n                   int cache_id, struct rail_icon_info *icon_info,\n                   int flags);\nint\nserver_window_cached_icon(struct xrdp_mod *mod,\n                          int window_id, int cache_entry,\n                          int cache_id, int flags);\nint\nserver_notify_new_update(struct xrdp_mod *mod,\n                         int window_id, int notify_id,\n                         struct rail_notify_state_order *notify_state,\n                         int flags);\nint\nserver_notify_delete(struct xrdp_mod *mod, int window_id,\n                     int notify_id);\nint\nserver_monitored_desktop(struct xrdp_mod *mod,\n                         struct rail_monitored_desktop_order *mdo,\n                         int flags);\nint\nserver_add_char_alpha(struct xrdp_mod *mod, int font, int character,\n                      int offset, int baseline,\n                      int width, int height, char *data);\nint\nserver_session_info(struct xrdp_mod *mod, const char *data, int data_bytes);\n\n#endif\n", "/**\n * xrdp: A Remote Desktop Protocol server.\n *\n * Copyright (C) Jay Sorg 2004-2014\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * fonts\n */\n\n/* fv1 files are described in fontutils/README_fv1.txt */\n\n#if defined(HAVE_CONFIG_H)\n#include <config_ac.h>\n#endif\n\n#include <ctype.h>\n\n#include \"xrdp.h\"\n#include \"log.h\"\n#include \"string_calls.h\"\n\n#if 0 /* not used */\nstatic char w_char[] =\n{\n    0x00, 0x00, 0x00, // ........................\n    0x00, 0x00, 0x00, // ........................\n    0x00, 0x00, 0x00, // ........................\n    0x08, 0x20, 0x80, // ....X.....X.....X.......\n    0x08, 0x50, 0x80, // ....X....X.X....X.......\n    0x04, 0x51, 0x00, // .....X...X.X...X........\n    0x04, 0x51, 0x00, // .....X...X.X...X........\n    0x04, 0x51, 0x00, // .....X...X.X...X........\n    0x02, 0x8a, 0x00, // ......X.X...X.X.........\n    0x02, 0x8a, 0x00, // ......X.X...X.X.........\n    0x02, 0x8a, 0x00, // ......X.X...X.X.........\n    0x01, 0x04, 0x00, // .......X.....X..........\n    0x01, 0x04, 0x00, // .......X.....X..........\n    0x00, 0x00, 0x00, // ........................\n    0x00, 0x00, 0x00, // ........................\n    0x00, 0x00, 0x00, // ........................\n};\n#endif\n\n/*****************************************************************************/\n/**\n * Parses the fv1_select configuration value to get the font to use,\n * based on the DPI of the primary monitor\n *\n * @param globals Configuration globals\n * @param dpi DPI of primary monitor. If not known, a suitable\n *            default should be passed in here.\n * @param[out] font_name Name of font to use\n * @param[in] font_name_len Length of font name buffer\n */\nstatic void\nget_font_name_from_dpi(const struct xrdp_cfg_globals *globals,\n                       unsigned int dpi,\n                       char *font_name, int font_name_len)\n{\n    int bad_selector = 0;\n\n    font_name[0] = '\\0';\n\n    const char *fv1_select = globals->fv1_select;\n    if (fv1_select == NULL || fv1_select[0] == '\\0')\n    {\n        fv1_select = DEFAULT_FV1_SELECT;\n    }\n\n    const char *p = fv1_select;\n\n    while (p != NULL)\n    {\n        /* DPI value must be next in string */\n        if (!isdigit(*p))\n        {\n            bad_selector = 1;\n            break;\n        }\n        unsigned int field_dpi = g_atoi(p);\n        if (field_dpi <= dpi)\n        {\n            /* Use this font */\n            p = g_strchr(p, ':');\n            if (p == NULL)\n            {\n                bad_selector = 1;\n            }\n            else\n            {\n                ++p;\n                const char *q = g_strchr(p, ',');\n                if (q == NULL)\n                {\n                    q = p + g_strlen(p);\n                }\n                if (q - p > (font_name_len - 1))\n                {\n                    q = p + font_name_len - 1;\n                }\n                g_memcpy(font_name, p, q - p);\n                font_name[q - p] = '\\0';\n            }\n            break;\n        }\n        else\n        {\n            p = g_strchr(p, ',');\n            if (p != NULL)\n            {\n                ++p;\n            }\n        }\n    }\n\n    if (bad_selector)\n    {\n        LOG(LOG_LEVEL_WARNING, \"Unable to parse fv1_select configuration\");\n    }\n\n    if (font_name[0] == '\\0')\n    {\n        LOG(LOG_LEVEL_WARNING, \"Loading default font \" DEFAULT_FONT_NAME);\n        g_snprintf(font_name, font_name_len, DEFAULT_FONT_NAME);\n    }\n}\n\n/*****************************************************************************/\nstruct xrdp_font *\nxrdp_font_create(struct xrdp_wm *wm, unsigned int dpi)\n{\n    struct xrdp_font *self;\n    struct stream *s;\n    int fd;\n    int b;\n    int i;\n    int index;\n    int datasize;\n    int file_size;\n    struct xrdp_font_char *f;\n    const char *file_path;\n    char file_path_buff[256];\n    int min_descender;\n    char font_name[256];\n    const struct xrdp_cfg_globals *globals = &wm->xrdp_config->cfg_globals;\n    LOG_DEVEL(LOG_LEVEL_TRACE, \"in xrdp_font_create\");\n\n    if (dpi == 0)\n    {\n        LOG(LOG_LEVEL_WARNING, \"No DPI value is available to find login font\");\n        dpi = globals->default_dpi;\n        LOG(LOG_LEVEL_WARNING, \"Using the default_dpi of %u\", dpi);\n    }\n    get_font_name_from_dpi(globals, dpi, font_name, sizeof(font_name));\n\n    if (font_name[0] == '/')\n    {\n        /* User specified absolute path */\n        file_path = font_name;\n    }\n    else\n    {\n        g_snprintf(file_path_buff, sizeof(file_path_buff),\n                   XRDP_SHARE_PATH \"/%s\",\n                   font_name);\n        file_path = file_path_buff;\n    }\n\n    if (!g_file_exist(file_path))\n    {\n        /* Try to fall back to the default */\n        const char *default_file_path = XRDP_SHARE_PATH \"/\" DEFAULT_FONT_NAME;\n        if (g_file_exist(default_file_path))\n        {\n            LOG(LOG_LEVEL_WARNING,\n                \"xrdp_font_create: font file [%s] does not exist - using [%s]\",\n                file_path, default_file_path);\n            file_path = default_file_path;\n        }\n        else\n        {\n            LOG(LOG_LEVEL_ERROR,\n                \"xrdp_font_create: Can't load either [%s] or [%s]\",\n                file_path, default_file_path);\n            return 0;\n        }\n    }\n\n    file_size = g_file_get_size(file_path);\n\n    if (file_size < 1)\n    {\n        LOG(LOG_LEVEL_ERROR, \"xrdp_font_create: error reading font from file [%s]\",\n            file_path);\n        return 0;\n    }\n\n    self = (struct xrdp_font *)g_malloc(sizeof(struct xrdp_font), 1);\n    self->wm = wm;\n    make_stream(s);\n    init_stream(s, file_size + 1024);\n    fd = g_file_open_ro(file_path);\n\n    if (fd != -1)\n    {\n        b = g_file_read(fd, s->data, file_size + 1024);\n        g_file_close(fd);\n\n        if (b > 0)\n        {\n            s->end = s->data + b;\n            in_uint8s(s, 4);\n            in_uint8a(s, self->name, 32);\n            in_uint16_le(s, self->size);\n            in_uint16_le(s, self->style);\n            in_uint16_le(s, self->body_height);\n            in_sint16_le(s, min_descender);\n            in_uint8s(s, 4);\n            index = 32;\n\n            while (s_check_rem(s, 16))\n            {\n                f = self->font_items + index;\n                in_sint16_le(s, i);\n                f->width = i;\n                in_sint16_le(s, i);\n                f->height = i;\n                in_sint16_le(s, i);\n                /* Move the glyph up so there are no descenders */\n                f->baseline = i + min_descender;\n                in_sint16_le(s, i);\n                f->offset = i;\n                in_sint16_le(s, i);\n                f->incby = i;\n                in_uint8s(s, 6);\n                datasize = FONT_DATASIZE(f);\n\n                if (datasize < 0 || datasize > 512)\n                {\n                    /* shouldn't happen */\n                    LOG(LOG_LEVEL_ERROR, \"error in xrdp_font_create, datasize wrong \"\n                        \"width %d, height %d, datasize %d, index %d\",\n                        f->width, f->height, datasize, index);\n                    break;\n                }\n\n                if (datasize == 0)\n                {\n                    /* Allocate a single blank pixel for the glyph, so\n                     * that it can be added to the glyph cache if required */\n                    f->width = 1;\n                    f->height = 1;\n                    f->data = (char *)g_malloc(FONT_DATASIZE(f), 1);\n                }\n                else if (s_check_rem(s, datasize))\n                {\n                    f->data = (char *)g_malloc(datasize, 0);\n                    in_uint8a(s, f->data, datasize);\n                }\n                else\n                {\n                    LOG(LOG_LEVEL_ERROR, \"error in xrdp_font_create\");\n                }\n                index++;\n            }\n\n            if (self->body_height == 0 && index > 32)\n            {\n                /* Older font made for xrdp v0.9.x. Synthesise this\n                 * value from the first glyph */\n                self->body_height = -self->font_items[32].baseline + 1;\n            }\n        }\n    }\n\n    free_stream(s);\n    /*\n      self->font_items[0].offset = -4;\n      self->font_items[0].baseline = -16;\n      self->font_items[0].width = 24;\n      self->font_items[0].height = 16;\n      self->font_items[0].data = g_malloc(3 * 16, 0);\n      g_memcpy(self->font_items[0].data, w_char, 3 * 16);\n    */\n    LOG_DEVEL(LOG_LEVEL_TRACE, \"out xrdp_font_create\");\n    return self;\n}\n\n/*****************************************************************************/\n/* free the font and all the items */\nvoid\nxrdp_font_delete(struct xrdp_font *self)\n{\n    int i;\n\n    if (self == 0)\n    {\n        return;\n    }\n\n    for (i = 0; i < NUM_FONTS; i++)\n    {\n        g_free(self->font_items[i].data);\n    }\n\n    g_free(self);\n}\n\n/*****************************************************************************/\n/* compare the two font items returns 1 if they match */\nint\nxrdp_font_item_compare(struct xrdp_font_char *font1,\n                       struct xrdp_font_char *font2)\n{\n    int datasize;\n\n    if (font1 == 0)\n    {\n        return 0;\n    }\n\n    if (font2 == 0)\n    {\n        return 0;\n    }\n\n    if (font1->offset != font2->offset)\n    {\n        return 0;\n    }\n\n    if (font1->baseline != font2->baseline)\n    {\n        return 0;\n    }\n\n    if (font1->width != font2->width)\n    {\n        return 0;\n    }\n\n    if (font1->height != font2->height)\n    {\n        return 0;\n    }\n\n    datasize = FONT_DATASIZE(font1);\n\n    if (g_memcmp(font1->data, font2->data, datasize) == 0)\n    {\n        return 1;\n    }\n\n    return 0;\n}\n", "/**\n * xrdp: A Remote Desktop Protocol server.\n *\n * Copyright (C) Jay Sorg 2004-2014\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * painter, gc\n */\n\n#if defined(HAVE_CONFIG_H)\n#include <config_ac.h>\n#endif\n\n#include \"xrdp.h\"\n#include \"string_calls.h\"\n\n#if defined(XRDP_PAINTER)\n#include <painter.h> /* libpainter */\n#endif\n\n\n#if defined(XRDP_PAINTER)\n\n/*****************************************************************************/\nstatic int\nxrdp_painter_add_dirty_rect(struct xrdp_painter *self, int x, int y,\n                            int cx, int cy, struct xrdp_rect *clip_rect)\n{\n    int x2;\n    int y2;\n    struct xrdp_rect rect;\n\n    if (clip_rect != 0)\n    {\n        x2 = x + cx;\n        y2 = y + cy;\n        x = MAX(x, clip_rect->left);\n        y = MAX(y, clip_rect->top);\n        x2 = MIN(x2, clip_rect->right);\n        y2 = MIN(y2, clip_rect->bottom);\n        cx = x2 - x;\n        cy = y2 - y;\n    }\n    if (cx < 1 || cy < 1)\n    {\n        return 0;\n    }\n    rect.left = x;\n    rect.top = y;\n    rect.right = x + cx;\n    rect.bottom = y + cy;\n    xrdp_region_add_rect(self->dirty_region, &rect);\n    LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_add_dirty_rect: x %d y %d cx %d cy %d\",\n              x, y, cx, cy);\n    return 0;\n}\n\n/*****************************************************************************/\nstatic int\nxrdp_painter_send_dirty(struct xrdp_painter *self)\n{\n    int cx;\n    int cy;\n    int bpp;\n    int Bpp;\n    int index;\n    int jndex;\n    int error;\n    char *ldata;\n    char *src;\n    char *dst;\n    struct xrdp_rect rect;\n\n    LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_send_dirty:\");\n\n    bpp = self->wm->screen->bpp;\n    Bpp = (bpp + 7) / 8;\n    if (Bpp == 3)\n    {\n        Bpp = 4;\n    }\n\n    jndex = 0;\n    error = xrdp_region_get_rect(self->dirty_region, jndex, &rect);\n    while (error == 0)\n    {\n        cx = rect.right - rect.left;\n        cy = rect.bottom - rect.top;\n        ldata = (char *)g_malloc(cx * cy * Bpp, 0);\n        if (ldata == 0)\n        {\n            return 1;\n        }\n        src = self->wm->screen->data;\n        src += self->wm->screen->line_size * rect.top;\n        src += rect.left * Bpp;\n        dst = ldata;\n        for (index = 0; index < cy; index++)\n        {\n            g_memcpy(dst, src, cx * Bpp);\n            src += self->wm->screen->line_size;\n            dst += cx * Bpp;\n        }\n        LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_send_dirty: x %d y %d cx %d cy %d\",\n                  rect.left, rect.top, cx, cy);\n        libxrdp_send_bitmap(self->session, cx, cy, bpp,\n                            ldata, rect.left, rect.top, cx, cy);\n        g_free(ldata);\n\n        jndex++;\n        error = xrdp_region_get_rect(self->dirty_region, jndex, &rect);\n    }\n\n    xrdp_region_delete(self->dirty_region);\n    self->dirty_region = xrdp_region_create(self->wm);\n\n    return 0;\n}\n\n#endif\n\n/*****************************************************************************/\nstruct xrdp_painter *\nxrdp_painter_create(struct xrdp_wm *wm, struct xrdp_session *session)\n{\n    struct xrdp_painter *self;\n\n    LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_create:\");\n    self = (struct xrdp_painter *)g_malloc(sizeof(struct xrdp_painter), 1);\n    self->wm = wm;\n    self->session = session;\n    self->rop = 0xcc; /* copy will use 0xcc */\n    self->clip_children = 1;\n\n\n    if (self->session->client_info->no_orders_supported)\n    {\n#if defined(XRDP_PAINTER)\n        if (painter_create(&(self->painter)) != PT_ERROR_NONE)\n        {\n            self->painter = 0;\n            LOG_DEVEL(LOG_LEVEL_WARNING, \"xrdp_painter_create: painter_create failed\");\n        }\n        else\n        {\n            LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_create: painter_create success\");\n        }\n        self->dirty_region = xrdp_region_create(wm);\n#endif\n    }\n\n    return self;\n}\n\n/*****************************************************************************/\nvoid\nxrdp_painter_delete(struct xrdp_painter *self)\n{\n    LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_delete:\");\n    if (self == 0)\n    {\n        return;\n    }\n\n#if defined(XRDP_PAINTER)\n    painter_delete(self->painter);\n    xrdp_region_delete(self->dirty_region);\n#endif\n\n    g_free(self);\n}\n\n/*****************************************************************************/\nint\nwm_painter_set_target(struct xrdp_painter *self)\n{\n    int surface_index;\n    int index;\n    struct list *del_list;\n\n    LOG_DEVEL(LOG_LEVEL_DEBUG, \"wm_painter_set_target:\");\n\n    if (self->painter != 0)\n    {\n        return 0;\n    }\n\n    if (self->wm->target_surface->type == WND_TYPE_SCREEN)\n    {\n        if (self->wm->current_surface_index != 0xffff)\n        {\n            libxrdp_orders_send_switch_os_surface(self->session, 0xffff);\n            self->wm->current_surface_index = 0xffff;\n        }\n    }\n    else if (self->wm->target_surface->type == WND_TYPE_OFFSCREEN)\n    {\n        surface_index = self->wm->target_surface->item_index;\n\n        if (surface_index != self->wm->current_surface_index)\n        {\n            if (self->wm->target_surface->tab_stop == 0) /* tab_stop is hack */\n            {\n                del_list = self->wm->cache->xrdp_os_del_list;\n                index = list_index_of(del_list, surface_index);\n                list_remove_item(del_list, index);\n                libxrdp_orders_send_create_os_surface(self->session, surface_index,\n                                                      self->wm->target_surface->width,\n                                                      self->wm->target_surface->height,\n                                                      del_list);\n                self->wm->target_surface->tab_stop = 1;\n                list_clear(del_list);\n            }\n\n            libxrdp_orders_send_switch_os_surface(self->session, surface_index);\n            self->wm->current_surface_index = surface_index;\n        }\n    }\n    else\n    {\n        LOG(LOG_LEVEL_WARNING, \"xrdp_painter_begin_update: bad target_surface\");\n    }\n\n    return 0;\n}\n\n/*****************************************************************************/\nint\nxrdp_painter_begin_update(struct xrdp_painter *self)\n{\n    LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_begin_update:\");\n    if (self == 0)\n    {\n        return 0;\n    }\n\n    self->begin_end_level++;\n\n    if (self->painter != 0)\n    {\n        return 0;\n    }\n\n    libxrdp_orders_init(self->session);\n    wm_painter_set_target(self);\n    return 0;\n}\n\n/*****************************************************************************/\nint\nxrdp_painter_end_update(struct xrdp_painter *self)\n{\n    LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_end_update:\");\n    if (self == 0)\n    {\n        return 0;\n    }\n\n    self->begin_end_level--;\n\n    if (self->painter != 0)\n    {\n#if defined(XRDP_PAINTER)\n        if (self->begin_end_level == 0)\n        {\n            xrdp_painter_send_dirty(self);\n            return 0;\n        }\n#endif\n    }\n\n    libxrdp_orders_send(self->session);\n    return 0;\n}\n\n/*****************************************************************************/\nint\nxrdp_painter_font_needed(struct xrdp_painter *self)\n{\n    if (self->font == 0)\n    {\n        self->font = self->wm->default_font;\n    }\n\n    return 0;\n}\n\n#if 0\n/*****************************************************************************/\n/* returns boolean, true if there is something to draw */\nstatic int\nxrdp_painter_clip_adj(struct xrdp_painter *self, int *x, int *y,\n                      int *cx, int *cy)\n{\n    int dx;\n    int dy;\n\n    if (!self->use_clip)\n    {\n        return 1;\n    }\n\n    if (self->clip.left > *x)\n    {\n        dx = self->clip.left - *x;\n    }\n    else\n    {\n        dx = 0;\n    }\n\n    if (self->clip.top > *y)\n    {\n        dy = self->clip.top - *y;\n    }\n    else\n    {\n        dy = 0;\n    }\n\n    if (*x + *cx > self->clip.right)\n    {\n        *cx = *cx - ((*x + *cx) - self->clip.right);\n    }\n\n    if (*y + *cy > self->clip.bottom)\n    {\n        *cy = *cy - ((*y + *cy) - self->clip.bottom);\n    }\n\n    *cx = *cx - dx;\n    *cy = *cy - dy;\n\n    if (*cx <= 0)\n    {\n        return 0;\n    }\n\n    if (*cy <= 0)\n    {\n        return 0;\n    }\n\n    *x = *x + dx;\n    *y = *y + dy;\n    return 1;\n}\n#endif\n\n/*****************************************************************************/\nint\nxrdp_painter_set_clip(struct xrdp_painter *self,\n                      int x, int y, int cx, int cy)\n{\n    self->use_clip = &self->clip;\n    self->clip.left = x;\n    self->clip.top = y;\n    self->clip.right = x + cx;\n    self->clip.bottom = y + cy;\n    return 0;\n}\n\n/*****************************************************************************/\nint\nxrdp_painter_clr_clip(struct xrdp_painter *self)\n{\n    self->use_clip = 0;\n    return 0;\n}\n\n#if 0\n/*****************************************************************************/\nstatic int\nxrdp_painter_rop(int rop, int src, int dst)\n{\n    switch (rop & 0x0f)\n    {\n        case 0x0:\n            return 0;\n        case 0x1:\n            return ~(src | dst);\n        case 0x2:\n            return (~src) & dst;\n        case 0x3:\n            return ~src;\n        case 0x4:\n            return src & (~dst);\n        case 0x5:\n            return ~(dst);\n        case 0x6:\n            return src ^ dst;\n        case 0x7:\n            return ~(src & dst);\n        case 0x8:\n            return src & dst;\n        case 0x9:\n            return ~(src) ^ dst;\n        case 0xa:\n            return dst;\n        case 0xb:\n            return (~src) | dst;\n        case 0xc:\n            return src;\n        case 0xd:\n            return src | (~dst);\n        case 0xe:\n            return src | dst;\n        case 0xf:\n            return ~0;\n    }\n\n    return dst;\n}\n#endif\n\n/*****************************************************************************/\nint\nxrdp_painter_text_width(struct xrdp_painter *self, const char *text)\n{\n    int index;\n    int rv;\n    int len;\n    struct xrdp_font_char *font_item;\n    twchar *wstr;\n\n    LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_text_width:\");\n    xrdp_painter_font_needed(self);\n\n    if (self->font == 0)\n    {\n        return 0;\n    }\n\n    if (text == 0)\n    {\n        return 0;\n    }\n\n    rv = 0;\n    len = g_mbstowcs(0, text, 0);\n    wstr = (twchar *)g_malloc((len + 2) * sizeof(twchar), 0);\n    g_mbstowcs(wstr, text, len + 1);\n\n    for (index = 0; index < len; index++)\n    {\n        font_item = self->font->font_items + wstr[index];\n        rv = rv + font_item->incby;\n    }\n\n    g_free(wstr);\n    return rv;\n}\n\n/*****************************************************************************/\nunsigned int\nxrdp_painter_font_body_height(const struct xrdp_painter *self)\n{\n    return (self->font == NULL) ? 0 : self->font->body_height;\n}\n\n/*****************************************************************************/\nstatic int\nxrdp_painter_setup_brush(struct xrdp_painter *self,\n                         struct xrdp_brush *out_brush,\n                         struct xrdp_brush *in_brush)\n{\n    int cache_id;\n\n    LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_setup_brush:\");\n\n    if (self->painter != 0)\n    {\n        return 0;\n    }\n\n    g_memcpy(out_brush, in_brush, sizeof(struct xrdp_brush));\n\n    if (in_brush->style == 3)\n    {\n        if (self->session->client_info->brush_cache_code == 1)\n        {\n            cache_id = xrdp_cache_add_brush(self->wm->cache, in_brush->pattern);\n            g_memset(out_brush->pattern, 0, 8);\n            out_brush->pattern[0] = cache_id;\n            out_brush->style = 0x81;\n        }\n    }\n\n    return 0;\n}\n\n#if defined(XRDP_PAINTER)\n\n/*****************************************************************************/\nstatic int\nget_pt_format(struct xrdp_painter *self)\n{\n    switch (self->wm->screen->bpp)\n    {\n        case 8:\n            return PT_FORMAT_r3g3b2;\n        case 15:\n            return PT_FORMAT_a1r5g5b5;\n        case 16:\n            return PT_FORMAT_r5g6b5;\n    }\n    return PT_FORMAT_a8r8g8b8;\n}\n\n/*****************************************************************************/\nstatic int\nget_rgb_from_rdp_color(struct xrdp_painter *self, int rdp_color)\n{\n    if (self->wm->screen->bpp < 24)\n    {\n        return rdp_color;\n    }\n    /* well, this is really BGR2RGB */\n    return XR_RGB2BGR(rdp_color);\n}\n\n#endif\n\n/*****************************************************************************/\n/* fill in an area of the screen with one color */\nint\nxrdp_painter_fill_rect(struct xrdp_painter *self,\n                       struct xrdp_bitmap *dst,\n                       int x, int y, int cx, int cy)\n{\n    struct xrdp_rect clip_rect;\n    struct xrdp_rect draw_rect;\n    struct xrdp_rect rect;\n    struct xrdp_region *region;\n    struct xrdp_brush brush;\n    int k;\n    int dx;\n    int dy;\n    int rop;\n\n    LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_fill_rect:\");\n\n    if (self == 0)\n    {\n        return 0;\n    }\n\n    dx = 0;\n    dy = 0;\n\n    if (self->painter != 0)\n    {\n#if defined(XRDP_PAINTER)\n        struct painter_bitmap dst_pb;\n        struct xrdp_bitmap *ldst;\n        struct painter_bitmap pat;\n\n        LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_fill_rect: dst->type %d\", dst->type);\n        if (dst->type != WND_TYPE_OFFSCREEN)\n        {\n            LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_fill_rect: using painter\");\n\n            ldst = self->wm->screen;\n\n            g_memset(&dst_pb, 0, sizeof(dst_pb));\n            dst_pb.format = get_pt_format(self);\n            dst_pb.width = ldst->width;\n            dst_pb.stride_bytes = ldst->line_size;\n            dst_pb.height = ldst->height;\n            dst_pb.data = ldst->data;\n\n            LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_fill_rect: ldst->width %d ldst->height %d \"\n                      \"dst->data %p self->fg_color %d\",\n                      ldst->width, ldst->height, ldst->data, self->fg_color);\n\n            xrdp_bitmap_get_screen_clip(dst, self, &clip_rect, &dx, &dy);\n            region = xrdp_region_create(self->wm);\n            xrdp_wm_get_vis_region(self->wm, dst, x, y, cx, cy, region,\n                                   self->clip_children);\n            x += dx;\n            y += dy;\n\n            rop = self->rop;\n            switch (self->rop)\n            {\n                case 0x5a:\n                    rop = PT_ROP_DSx;\n                    break;\n                case 0xf0:\n                    rop = PT_ROP_S;\n                    break;\n                case 0xfb:\n                    rop = PT_ROP_D;\n                    break;\n                case 0xc0:\n                    rop = PT_ROP_DSa;\n                    break;\n            }\n            painter_set_rop(self->painter, rop);\n\n            if (self->mix_mode == 0)\n            {\n                painter_set_pattern_mode(self->painter, PT_PATTERN_MODE_OPAQUE);\n                painter_set_fgcolor(self->painter, get_rgb_from_rdp_color(self, self->fg_color));\n                k = 0;\n                while (xrdp_region_get_rect(region, k, &rect) == 0)\n                {\n                    if (rect_intersect(&rect, &clip_rect, &draw_rect))\n                    {\n                        painter_set_clip(self->painter,\n                                         draw_rect.left, draw_rect.top,\n                                         draw_rect.right - draw_rect.left,\n                                         draw_rect.bottom - draw_rect.top);\n                        painter_fill_rect(self->painter, &dst_pb, x, y, cx, cy);\n                        xrdp_painter_add_dirty_rect(self, x, y, cx, cy, &draw_rect);\n                    }\n                    k++;\n                }\n            }\n            else\n            {\n                painter_set_pattern_mode(self->painter, PT_PATTERN_MODE_OPAQUE);\n                painter_set_fgcolor(self->painter, get_rgb_from_rdp_color(self, self->fg_color));\n                painter_set_bgcolor(self->painter, get_rgb_from_rdp_color(self, self->bg_color));\n                painter_set_pattern_origin(self->painter, self->brush.x_origin, self->brush.y_origin);\n                g_memset(&pat, 0, sizeof(pat));\n                pat.format = PT_FORMAT_c1;\n                pat.width = 8;\n                pat.stride_bytes = 1;\n                pat.height = 8;\n                pat.data = self->brush.pattern;\n                k = 0;\n                while (xrdp_region_get_rect(region, k, &rect) == 0)\n                {\n                    if (rect_intersect(&rect, &clip_rect, &draw_rect))\n                    {\n                        painter_set_clip(self->painter,\n                                         draw_rect.left, draw_rect.top,\n                                         draw_rect.right - draw_rect.left,\n                                         draw_rect.bottom - draw_rect.top);\n                        painter_fill_pattern(self->painter, &dst_pb, &pat,\n                                             x, y, x, y, cx, cy);\n                        xrdp_painter_add_dirty_rect(self, x, y, cx, cy, &draw_rect);\n                    }\n                    k++;\n                }\n            }\n            painter_clear_clip(self->painter);\n            xrdp_region_delete(region);\n        }\n        return 0;\n#endif\n    }\n\n    /* todo data */\n\n    if (dst->type == WND_TYPE_BITMAP) /* 0 */\n    {\n        return 0;\n    }\n\n    xrdp_bitmap_get_screen_clip(dst, self, &clip_rect, &dx, &dy);\n    region = xrdp_region_create(self->wm);\n\n    if (dst->type != WND_TYPE_OFFSCREEN)\n    {\n        xrdp_wm_get_vis_region(self->wm, dst, x, y, cx, cy, region,\n                               self->clip_children);\n    }\n    else\n    {\n        xrdp_region_add_rect(region, &clip_rect);\n    }\n\n    x += dx;\n    y += dy;\n\n    if (self->mix_mode == 0 && self->rop == 0xcc)\n    {\n        k = 0;\n\n        while (xrdp_region_get_rect(region, k, &rect) == 0)\n        {\n            if (rect_intersect(&rect, &clip_rect, &draw_rect))\n            {\n                libxrdp_orders_rect(self->session, x, y, cx, cy,\n                                    self->fg_color, &draw_rect);\n            }\n\n            k++;\n        }\n    }\n    else if (self->mix_mode == 0 &&\n             ((self->rop & 0xf) == 0x0 || /* black */\n              (self->rop & 0xf) == 0xf || /* white */\n              (self->rop & 0xf) == 0x5))  /* DSTINVERT */\n    {\n        k = 0;\n\n        while (xrdp_region_get_rect(region, k, &rect) == 0)\n        {\n            if (rect_intersect(&rect, &clip_rect, &draw_rect))\n            {\n                libxrdp_orders_dest_blt(self->session, x, y, cx, cy,\n                                        self->rop, &draw_rect);\n            }\n\n            k++;\n        }\n    }\n    else\n    {\n        k = 0;\n        rop = self->rop;\n\n        /* if opcode is in the form 0x00, 0x11, 0x22, ... convert it */\n        if (((rop & 0xf0) >> 4) == (rop & 0xf))\n        {\n            switch (rop)\n            {\n                case 0x66: /* xor */\n                    rop = 0x5a;\n                    break;\n                case 0xaa: /* noop */\n                    rop = 0xfb;\n                    break;\n                case 0xcc: /* copy */\n                    rop = 0xf0;\n                    break;\n                case 0x88: /* and */\n                    rop = 0xc0;\n                    break;\n            }\n        }\n\n        xrdp_painter_setup_brush(self, &brush, &self->brush);\n\n        while (xrdp_region_get_rect(region, k, &rect) == 0)\n        {\n            if (rect_intersect(&rect, &clip_rect, &draw_rect))\n            {\n                libxrdp_orders_pat_blt(self->session, x, y, cx, cy,\n                                       rop, self->bg_color, self->fg_color,\n                                       &brush, &draw_rect);\n            }\n\n            k++;\n        }\n    }\n\n    xrdp_region_delete(region);\n    return 0;\n}\n\n/*****************************************************************************/\nint\nxrdp_painter_draw_text(struct xrdp_painter *self,\n                       struct xrdp_bitmap *dst,\n                       int x, int y, const char *text)\n{\n    int i;\n    int f;\n    int c;\n    int k;\n    int x1;\n    int y1;\n    int flags;\n    int len;\n    int index;\n    int total_width;\n    int total_height;\n    int dx;\n    int dy;\n    char *data;\n    struct xrdp_region *region;\n    struct xrdp_rect rect;\n    struct xrdp_rect clip_rect;\n    struct xrdp_rect draw_rect;\n    struct xrdp_font *font;\n    struct xrdp_font_char *font_item;\n    twchar *wstr;\n\n    LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_draw_text:\");\n\n    if (self == 0)\n    {\n        return 0;\n    }\n\n    len = g_mbstowcs(0, text, 0);\n\n    if (len < 1)\n    {\n        return 0;\n    }\n\n    /* todo data */\n\n    if (dst->type == 0)\n    {\n        return 0;\n    }\n\n    xrdp_painter_font_needed(self);\n\n    if (self->font == 0)\n    {\n        return 0;\n    }\n\n    if (self->painter != 0)\n    {\n#if defined(XRDP_PAINTER)\n        struct painter_bitmap pat;\n        struct painter_bitmap dst_pb;\n        struct xrdp_bitmap *ldst;\n\n        if (dst->type != WND_TYPE_OFFSCREEN)\n        {\n            ldst = self->wm->screen;\n            /* convert to wide char */\n            wstr = (twchar *)g_malloc((len + 2) * sizeof(twchar), 0);\n            g_mbstowcs(wstr, text, len + 1);\n            font = self->font;\n            total_width = 0;\n            total_height = 0;\n            for (index = 0; index < len; index++)\n            {\n                font_item = font->font_items + wstr[index];\n                k = font_item->incby;\n                total_width += k;\n                /* Use the nominal height of the font to work out the\n                 * actual height of this glyph */\n                int glyph_height =\n                    font->body_height + font_item->baseline + font_item->height;\n                total_height = MAX(total_height, glyph_height);\n            }\n            xrdp_bitmap_get_screen_clip(dst, self, &clip_rect, &dx, &dy);\n            region = xrdp_region_create(self->wm);\n            xrdp_wm_get_vis_region(self->wm, dst, x, y,\n                                   total_width, total_height,\n                                   region, self->clip_children);\n            x += dx;\n            y += dy;\n            g_memset(&dst_pb, 0, sizeof(dst_pb));\n            dst_pb.format = get_pt_format(self);\n            dst_pb.width = ldst->width;\n            dst_pb.stride_bytes = ldst->line_size;\n            dst_pb.height = ldst->height;\n            dst_pb.data = ldst->data;\n            painter_set_rop(self->painter, PT_ROP_S);\n            painter_set_pattern_origin(self->painter, 0, 0);\n            painter_set_pattern_mode(self->painter, PT_PATTERN_MODE_NORMAL);\n            painter_set_fgcolor(self->painter,\n                                get_rgb_from_rdp_color(self, self->fg_color));\n            k = 0;\n            while (xrdp_region_get_rect(region, k, &rect) == 0)\n            {\n                if (rect_intersect(&rect, &clip_rect, &draw_rect))\n                {\n                    painter_set_clip(self->painter,\n                                     draw_rect.left, draw_rect.top,\n                                     draw_rect.right - draw_rect.left,\n                                     draw_rect.bottom - draw_rect.top);\n                    for (index = 0; index < len; index++)\n                    {\n                        font_item = font->font_items + wstr[index];\n                        g_memset(&pat, 0, sizeof(pat));\n                        pat.format = PT_FORMAT_c1;\n                        pat.width = font_item->width;\n                        pat.stride_bytes = (font_item->width + 7) / 8;\n                        pat.height = font_item->height;\n                        pat.data = font_item->data;\n                        x1 = x + font_item->offset;\n                        y1 = y + (font->body_height + font_item->baseline);\n                        painter_fill_pattern(self->painter, &dst_pb, &pat,\n                                             0, 0, x1, y1,\n                                             font_item->width,\n                                             font_item->height);\n                        xrdp_painter_add_dirty_rect(self, x1, y1,\n                                                    font_item->width,\n                                                    font_item->height,\n                                                    &draw_rect);\n                        x += font_item->incby;\n                    }\n                }\n                k++;\n            }\n            painter_clear_clip(self->painter);\n            xrdp_region_delete(region);\n            g_free(wstr);\n        }\n        return 0;\n#endif\n    }\n\n    /* convert to wide char */\n    wstr = (twchar *)g_malloc((len + 2) * sizeof(twchar), 0);\n    g_mbstowcs(wstr, text, len + 1);\n    font = self->font;\n    f = 0;\n    k = 0;\n    total_width = 0;\n    total_height = 0;\n    data = (char *)g_malloc(len * 4, 1);\n\n    for (index = 0; index < len; index++)\n    {\n        font_item = font->font_items + wstr[index];\n        i = xrdp_cache_add_char(self->wm->cache, font_item);\n        f = HIWORD(i);\n        c = LOWORD(i);\n        data[index * 2] = c;\n        data[index * 2 + 1] = k;\n        k = font_item->incby;\n        total_width += k;\n        /* Use the nominal height of the font to work out the\n         * actual height of this glyph */\n        int glyph_height =\n            font->body_height + font_item->baseline + font_item->height;\n        total_height = MAX(total_height, glyph_height);\n    }\n\n    xrdp_bitmap_get_screen_clip(dst, self, &clip_rect, &dx, &dy);\n    region = xrdp_region_create(self->wm);\n\n    if (dst->type != WND_TYPE_OFFSCREEN)\n    {\n        xrdp_wm_get_vis_region(self->wm, dst, x, y, total_width, total_height,\n                               region, self->clip_children);\n    }\n    else\n    {\n        xrdp_region_add_rect(region, &clip_rect);\n    }\n\n    x += dx;\n    y += dy;\n    k = 0;\n\n    while (xrdp_region_get_rect(region, k, &rect) == 0)\n    {\n        if (rect_intersect(&rect, &clip_rect, &draw_rect))\n        {\n            x1 = x;\n            y1 = y + font->body_height;\n            flags = 0x03; /* 0x03 0x73; TEXT2_IMPLICIT_X and something else */\n            libxrdp_orders_text(self->session, f, flags, 0,\n                                self->fg_color, 0,\n                                x - 1, y - 1, x + total_width, y + total_height,\n                                0, 0, 0, 0,\n                                x1, y1, data, len * 2, &draw_rect);\n        }\n\n        k++;\n    }\n\n    xrdp_region_delete(region);\n    g_free(data);\n    g_free(wstr);\n    return 0;\n}\n\n/*****************************************************************************/\nint\nxrdp_painter_draw_text2(struct xrdp_painter *self,\n                        struct xrdp_bitmap *dst,\n                        int font, int flags, int mixmode,\n                        int clip_left, int clip_top,\n                        int clip_right, int clip_bottom,\n                        int box_left, int box_top,\n                        int box_right, int box_bottom,\n                        int x, int y, char *data, int data_len)\n{\n    struct xrdp_rect clip_rect;\n    struct xrdp_rect draw_rect;\n    struct xrdp_rect rect;\n    struct xrdp_region *region;\n    int k;\n    int dx;\n    int dy;\n\n    LOG_DEVEL(LOG_LEVEL_INFO, \"xrdp_painter_draw_text2:\");\n\n    if (self == 0)\n    {\n        return 0;\n    }\n\n    if (self->painter != 0)\n    {\n        return 0;\n    }\n\n    /* todo data */\n\n    if (dst->type == WND_TYPE_BITMAP)\n    {\n        return 0;\n    }\n\n    xrdp_bitmap_get_screen_clip(dst, self, &clip_rect, &dx, &dy);\n    region = xrdp_region_create(self->wm);\n\n    if (dst->type != WND_TYPE_OFFSCREEN)\n    {\n        if (box_right - box_left > 1)\n        {\n            xrdp_wm_get_vis_region(self->wm, dst, box_left, box_top,\n                                   box_right - box_left, box_bottom - box_top,\n                                   region, self->clip_children);\n        }\n        else\n        {\n            xrdp_wm_get_vis_region(self->wm, dst, clip_left, clip_top,\n                                   clip_right - clip_left, clip_bottom - clip_top,\n                                   region, self->clip_children);\n        }\n    }\n    else\n    {\n        xrdp_region_add_rect(region, &clip_rect);\n    }\n\n    clip_left += dx;\n    clip_top += dy;\n    clip_right += dx;\n    clip_bottom += dy;\n    box_left += dx;\n    box_top += dy;\n    box_right += dx;\n    box_bottom += dy;\n    x += dx;\n    y += dy;\n    k = 0;\n\n    while (xrdp_region_get_rect(region, k, &rect) == 0)\n    {\n        if (rect_intersect(&rect, &clip_rect, &draw_rect))\n        {\n            libxrdp_orders_text(self->session, font, flags, mixmode,\n                                self->fg_color, self->bg_color,\n                                clip_left, clip_top, clip_right, clip_bottom,\n                                box_left, box_top, box_right, box_bottom,\n                                x, y, data, data_len, &draw_rect);\n        }\n\n        k++;\n    }\n\n    xrdp_region_delete(region);\n    return 0;\n}\n\n/*****************************************************************************/\nint\nxrdp_painter_copy(struct xrdp_painter *self,\n                  struct xrdp_bitmap *src,\n                  struct xrdp_bitmap *dst,\n                  int x, int y, int cx, int cy,\n                  int srcx, int srcy)\n{\n    struct xrdp_rect clip_rect;\n    struct xrdp_rect draw_rect;\n    struct xrdp_rect rect1;\n    struct xrdp_rect rect2;\n    struct xrdp_region *region;\n    struct xrdp_bitmap *b;\n    int i;\n    int j;\n    int k;\n    int dx;\n    int dy;\n    int palette_id;\n    int bitmap_id;\n    int cache_id;\n    int cache_idx;\n    int dstx;\n    int dsty;\n    int w;\n    int h;\n    int index;\n    struct list *del_list;\n\n    LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_copy:\");\n\n    if (self == 0 || src == 0 || dst == 0)\n    {\n        return 0;\n    }\n\n    if (self->painter != 0)\n    {\n#if defined(XRDP_PAINTER)\n        struct painter_bitmap src_pb;\n        struct painter_bitmap dst_pb;\n        struct xrdp_bitmap *ldst;\n\n        LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_copy: src->type %d dst->type %d\", src->type, dst->type);\n        LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_copy: self->rop 0x%2.2x\", self->rop);\n\n        if (dst->type != WND_TYPE_OFFSCREEN)\n        {\n            LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_copy: using painter\");\n            ldst = self->wm->screen;\n\n            g_memset(&dst_pb, 0, sizeof(dst_pb));\n            dst_pb.format = get_pt_format(self);\n            dst_pb.width = ldst->width;\n            dst_pb.stride_bytes = ldst->line_size;\n            dst_pb.height = ldst->height;\n            dst_pb.data = ldst->data;\n\n            g_memset(&src_pb, 0, sizeof(src_pb));\n            src_pb.format = get_pt_format(self);\n            src_pb.width = src->width;\n            src_pb.stride_bytes = src->line_size;\n            src_pb.height = src->height;\n            src_pb.data = src->data;\n\n            xrdp_bitmap_get_screen_clip(dst, self, &clip_rect, &dx, &dy);\n            region = xrdp_region_create(self->wm);\n            xrdp_wm_get_vis_region(self->wm, dst, x, y, cx, cy, region,\n                                   self->clip_children);\n            x += dx;\n            y += dy;\n            k = 0;\n\n            painter_set_rop(self->painter, self->rop);\n            while (xrdp_region_get_rect(region, k, &rect1) == 0)\n            {\n                if (rect_intersect(&rect1, &clip_rect, &draw_rect))\n                {\n                    painter_set_clip(self->painter,\n                                     draw_rect.left, draw_rect.top,\n                                     draw_rect.right - draw_rect.left,\n                                     draw_rect.bottom - draw_rect.top);\n                    LOG_DEVEL(LOG_LEVEL_DEBUG, \"  x %d y %d cx %d cy %d srcx %d srcy %d\",\n                              x, y, cx, cy, srcx, srcy);\n                    painter_copy(self->painter, &dst_pb, x, y, cx, cy,\n                                 &src_pb, srcx, srcy);\n                    xrdp_painter_add_dirty_rect(self, x, y, cx, cy,\n                                                &draw_rect);\n                }\n                k++;\n            }\n            painter_clear_clip(self->painter);\n            xrdp_region_delete(region);\n        }\n\n        return 0;\n#endif\n    }\n\n    /* todo data */\n\n    if (dst->type == WND_TYPE_BITMAP)\n    {\n        return 0;\n    }\n\n    if (src->type == WND_TYPE_SCREEN)\n    {\n        xrdp_bitmap_get_screen_clip(dst, self, &clip_rect, &dx, &dy);\n        region = xrdp_region_create(self->wm);\n\n        if (dst->type != WND_TYPE_OFFSCREEN)\n        {\n            xrdp_wm_get_vis_region(self->wm, dst, x, y, cx, cy,\n                                   region, self->clip_children);\n        }\n        else\n        {\n            xrdp_region_add_rect(region, &clip_rect);\n        }\n\n        x += dx;\n        y += dy;\n        srcx += dx;\n        srcy += dy;\n        k = 0;\n\n        while (xrdp_region_get_rect(region, k, &rect1) == 0)\n        {\n            if (rect_intersect(&rect1, &clip_rect, &draw_rect))\n            {\n                libxrdp_orders_screen_blt(self->session, x, y, cx, cy,\n                                          srcx, srcy, self->rop, &draw_rect);\n            }\n\n            k++;\n        }\n\n        xrdp_region_delete(region);\n    }\n    else if (src->type == WND_TYPE_OFFSCREEN)\n    {\n        LOG(LOG_LEVEL_DEBUG, \"xrdp_painter_copy: todo\");\n\n        xrdp_bitmap_get_screen_clip(dst, self, &clip_rect, &dx, &dy);\n        region = xrdp_region_create(self->wm);\n\n        if (dst->type != WND_TYPE_OFFSCREEN)\n        {\n            LOG(LOG_LEVEL_DEBUG, \"off screen to screen\");\n            xrdp_wm_get_vis_region(self->wm, dst, x, y, cx, cy,\n                                   region, self->clip_children);\n        }\n        else\n        {\n            LOG(LOG_LEVEL_DEBUG, \"off screen to off screen\");\n            xrdp_region_add_rect(region, &clip_rect);\n        }\n\n        x += dx;\n        y += dy;\n\n        palette_id = 0;\n        cache_id = 255; // todo\n        cache_idx = src->item_index; // todo\n\n        if (src->tab_stop == 0)\n        {\n            LOG(LOG_LEVEL_WARNING, \"xrdp_painter_copy: warning src not created\");\n            del_list = self->wm->cache->xrdp_os_del_list;\n            index = list_index_of(del_list, cache_idx);\n            list_remove_item(del_list, index);\n            libxrdp_orders_send_create_os_surface(self->session,\n                                                  cache_idx,\n                                                  src->width,\n                                                  src->height,\n                                                  del_list);\n            src->tab_stop = 1;\n            list_clear(del_list);\n        }\n\n\n        k = 0;\n\n        while (xrdp_region_get_rect(region, k, &rect1) == 0)\n        {\n            if (rect_intersect(&rect1, &clip_rect, &rect2))\n            {\n                MAKERECT(rect1, x, y, cx, cy);\n\n                if (rect_intersect(&rect2, &rect1, &draw_rect))\n                {\n                    libxrdp_orders_mem_blt(self->session, cache_id, palette_id,\n                                           x, y, cx, cy, self->rop, srcx, srcy,\n                                           cache_idx, &draw_rect);\n                }\n            }\n\n            k++;\n        }\n\n        xrdp_region_delete(region);\n    }\n    else if (src->data != 0)\n        /* todo, the non bitmap cache part is gone, it should be put back */\n    {\n        xrdp_bitmap_get_screen_clip(dst, self, &clip_rect, &dx, &dy);\n        region = xrdp_region_create(self->wm);\n\n        if (dst->type != WND_TYPE_OFFSCREEN)\n        {\n            xrdp_wm_get_vis_region(self->wm, dst, x, y, cx, cy,\n                                   region, self->clip_children);\n        }\n        else\n        {\n            xrdp_region_add_rect(region, &clip_rect);\n        }\n\n        x += dx;\n        y += dy;\n        palette_id = 0;\n        j = srcy;\n\n        while (j < (srcy + cy))\n        {\n            i = srcx;\n\n            while (i < (srcx + cx))\n            {\n                w = MIN(64, ((srcx + cx) - i));\n                h = MIN(64, ((srcy + cy) - j));\n                b = xrdp_bitmap_create(w, h, src->bpp, 0, self->wm);\n#if 1\n                xrdp_bitmap_copy_box_with_crc(src, b, i, j, w, h);\n#else\n                xrdp_bitmap_copy_box(src, b, i, j, w, h);\n                xrdp_bitmap_hash_crc(b);\n#endif\n                bitmap_id = xrdp_cache_add_bitmap(self->wm->cache, b, self->wm->hints);\n                cache_id = HIWORD(bitmap_id);\n                cache_idx = LOWORD(bitmap_id);\n                dstx = (x + i) - srcx;\n                dsty = (y + j) - srcy;\n                k = 0;\n\n                while (xrdp_region_get_rect(region, k, &rect1) == 0)\n                {\n                    if (rect_intersect(&rect1, &clip_rect, &rect2))\n                    {\n                        MAKERECT(rect1, dstx, dsty, w, h);\n\n                        if (rect_intersect(&rect2, &rect1, &draw_rect))\n                        {\n                            libxrdp_orders_mem_blt(self->session, cache_id, palette_id,\n                                                   dstx, dsty, w, h, self->rop, 0, 0,\n                                                   cache_idx, &draw_rect);\n                        }\n                    }\n\n                    k++;\n                }\n\n                i += 64;\n            }\n\n            j += 64;\n        }\n\n        xrdp_region_delete(region);\n    }\n\n    return 0;\n}\n\n/*****************************************************************************/\nint\nxrdp_painter_composite(struct xrdp_painter *self,\n                       struct xrdp_bitmap *src,\n                       int srcformat,\n                       int srcwidth,\n                       int srcrepeat,\n                       struct xrdp_bitmap *dst,\n                       int *srctransform,\n                       int mskflags,\n                       struct xrdp_bitmap *msk,\n                       int mskformat, int mskwidth, int mskrepeat, int op,\n                       int srcx, int srcy, int mskx, int msky,\n                       int dstx, int dsty, int width, int height, int dstformat)\n{\n    struct xrdp_rect clip_rect;\n    struct xrdp_rect draw_rect;\n    struct xrdp_rect rect1;\n    struct xrdp_rect rect2;\n    struct xrdp_region *region;\n    int k;\n    int dx;\n    int dy;\n    int cache_srcidx;\n    int cache_mskidx;\n\n    LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_composite:\");\n\n    if (self == 0 || src == 0 || dst == 0)\n    {\n        return 0;\n    }\n\n    if (self->painter != 0)\n    {\n        return 0;\n    }\n\n    /* todo data */\n\n    if (dst->type == WND_TYPE_BITMAP)\n    {\n        return 0;\n    }\n\n    if (src->type == WND_TYPE_OFFSCREEN)\n    {\n        xrdp_bitmap_get_screen_clip(dst, self, &clip_rect, &dx, &dy);\n        region = xrdp_region_create(self->wm);\n        xrdp_region_add_rect(region, &clip_rect);\n        dstx += dx;\n        dsty += dy;\n\n        cache_srcidx = src->item_index;\n        cache_mskidx = -1;\n        if (mskflags & 1)\n        {\n            if (msk != 0)\n            {\n                cache_mskidx = msk->item_index; // todo\n            }\n        }\n\n        k = 0;\n        while (xrdp_region_get_rect(region, k, &rect1) == 0)\n        {\n            if (rect_intersect(&rect1, &clip_rect, &rect2))\n            {\n                MAKERECT(rect1, dstx, dsty, width, height);\n                if (rect_intersect(&rect2, &rect1, &draw_rect))\n                {\n                    libxrdp_orders_composite_blt(self->session, cache_srcidx, srcformat, srcwidth,\n                                                 srcrepeat, srctransform, mskflags, cache_mskidx,\n                                                 mskformat, mskwidth, mskrepeat, op, srcx, srcy,\n                                                 mskx, msky, dstx, dsty, width, height, dstformat,\n                                                 &draw_rect);\n                }\n            }\n            k++;\n        }\n        xrdp_region_delete(region);\n    }\n    return 0;\n}\n\n/*****************************************************************************/\nint\nxrdp_painter_line(struct xrdp_painter *self,\n                  struct xrdp_bitmap *dst,\n                  int x1, int y1, int x2, int y2)\n{\n    struct xrdp_rect clip_rect;\n    struct xrdp_rect draw_rect;\n    struct xrdp_rect rect;\n    struct xrdp_region *region;\n    int k;\n    int dx;\n    int dy;\n    int rop;\n\n    LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_line:\");\n    if (self == 0)\n    {\n        return 0;\n    }\n    if (self->painter != 0)\n    {\n#if defined(XRDP_PAINTER)\n        int x;\n        int y;\n        int cx;\n        int cy;\n        struct painter_bitmap dst_pb;\n        struct xrdp_bitmap *ldst;\n\n        LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_line: dst->type %d\", dst->type);\n        LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_line: self->rop 0x%2.2x\", self->rop);\n\n        if (dst->type != WND_TYPE_OFFSCREEN)\n        {\n            LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_line: using painter\");\n            ldst = self->wm->screen;\n\n            g_memset(&dst_pb, 0, sizeof(dst_pb));\n            dst_pb.format = get_pt_format(self);\n            dst_pb.width = ldst->width;\n            dst_pb.stride_bytes = ldst->line_size;\n            dst_pb.height = ldst->height;\n            dst_pb.data = ldst->data;\n\n            xrdp_bitmap_get_screen_clip(dst, self, &clip_rect, &dx, &dy);\n            region = xrdp_region_create(self->wm);\n            x = MIN(x1, x2);\n            y = MIN(y1, y2);\n            cx = g_abs(x1 - x2) + 1;\n            cy = g_abs(y1 - y2) + 1;\n            xrdp_wm_get_vis_region(self->wm, dst, x, y, cx, cy,\n                                   region, self->clip_children);\n            x1 += dx;\n            y1 += dy;\n            x2 += dx;\n            y2 += dy;\n            k = 0;\n            rop = self->rop;\n\n            painter_set_rop(self->painter, rop);\n            painter_set_fgcolor(self->painter, self->pen.color);\n            while (xrdp_region_get_rect(region, k, &rect) == 0)\n            {\n                if (rect_intersect(&rect, &clip_rect, &draw_rect))\n                {\n                    painter_set_clip(self->painter,\n                                     draw_rect.left, draw_rect.top,\n                                     draw_rect.right - draw_rect.left,\n                                     draw_rect.bottom - draw_rect.top);\n                    painter_line(self->painter, &dst_pb, x1, y1, x2, y2,\n                                 self->pen.width, 0);\n                    xrdp_painter_add_dirty_rect(self, x, y, cx, cy,\n                                                &draw_rect);\n                }\n                k++;\n            }\n            painter_clear_clip(self->painter);\n            xrdp_region_delete(region);\n        }\n\n        return 0;\n#endif\n    }\n\n    /* todo data */\n\n    if (dst->type == WND_TYPE_BITMAP)\n    {\n        return 0;\n    }\n\n    xrdp_bitmap_get_screen_clip(dst, self, &clip_rect, &dx, &dy);\n    region = xrdp_region_create(self->wm);\n\n    if (dst->type != WND_TYPE_OFFSCREEN)\n    {\n        xrdp_wm_get_vis_region(self->wm, dst, MIN(x1, x2), MIN(y1, y2),\n                               g_abs(x1 - x2) + 1, g_abs(y1 - y2) + 1,\n                               region, self->clip_children);\n    }\n    else\n    {\n        xrdp_region_add_rect(region, &clip_rect);\n    }\n\n    x1 += dx;\n    y1 += dy;\n    x2 += dx;\n    y2 += dy;\n    k = 0;\n    rop = self->rop;\n\n    if (rop < 0x01 || rop > 0x10)\n    {\n        rop = (rop & 0xf) + 1;\n    }\n\n    while (xrdp_region_get_rect(region, k, &rect) == 0)\n    {\n        if (rect_intersect(&rect, &clip_rect, &draw_rect))\n        {\n            libxrdp_orders_line(self->session, 1, x1, y1, x2, y2,\n                                rop, self->bg_color,\n                                &self->pen, &draw_rect);\n        }\n\n        k++;\n    }\n\n    xrdp_region_delete(region);\n    return 0;\n}\n", "/**\n * xrdp: A Remote Desktop Protocol server.\n *\n * Copyright (C) Jay Sorg 2004-2014\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * types\n */\n\n#ifndef _XRDP_TYPES_H_\n#define _XRDP_TYPES_H_\n\n#define DEFAULT_STRING_LEN 255\n#define LOG_WINDOW_CHAR_PER_LINE 60\n\n#include \"xrdp_rail.h\"\n#include \"xrdp_constants.h\"\n#include \"fifo.h\"\n#include \"guid.h\"\n\n#define MAX_NR_CHANNELS 16\n#define MAX_CHANNEL_NAME 16\n\n/* Code values used in 'xrdp_mm->code=' settings */\n#define XVNC_SESSION_CODE 0\n#define XORG_SESSION_CODE 20\n\n/* To check whether touch events has been implemented on session type 'mm' */\n#define XRDP_MM_IMPLEMENTS_TOUCH(mm) ((mm)->code != XVNC_SESSION_CODE)\n\nstruct source_info;\nstruct list16;\n\n/* lib */\nstruct xrdp_mod\n{\n    int size; /* size of this struct */\n    int version; /* internal version */\n    /* client functions */\n    int (*mod_start)(struct xrdp_mod *v, int w, int h, int bpp);\n    int (*mod_connect)(struct xrdp_mod *v);\n    int (*mod_event)(struct xrdp_mod *v, int msg, long param1, long param2,\n                     long param3, long param4);\n    int (*mod_signal)(struct xrdp_mod *v);\n    int (*mod_end)(struct xrdp_mod *v);\n    int (*mod_set_param)(struct xrdp_mod *v, const char *name, const char *value);\n    int (*mod_session_change)(struct xrdp_mod *v, int, int);\n    int (*mod_get_wait_objs)(struct xrdp_mod *v, tbus *read_objs, int *rcount,\n                             tbus *write_objs, int *wcount, int *timeout);\n    int (*mod_check_wait_objs)(struct xrdp_mod *v);\n    int (*mod_frame_ack)(struct xrdp_mod *v, int flags, int frame_id);\n    int (*mod_suppress_output)(struct xrdp_mod *v, int suppress,\n                               int left, int top, int right, int bottom);\n    int (*mod_server_monitor_resize)(struct xrdp_mod *v,\n                                     int width, int height);\n    int (*mod_server_monitor_full_invalidate)(struct xrdp_mod *v,\n            int width, int height);\n    int (*mod_server_version_message)(struct xrdp_mod *v);\n    tintptr mod_dumby[100 - 14]; /* align, 100 minus the number of mod\n                                  functions above */\n    /* server functions */\n    int (*server_begin_update)(struct xrdp_mod *v);\n    int (*server_end_update)(struct xrdp_mod *v);\n    int (*server_fill_rect)(struct xrdp_mod *v, int x, int y, int cx, int cy);\n    int (*server_screen_blt)(struct xrdp_mod *v, int x, int y, int cx, int cy,\n                             int srcx, int srcy);\n    int (*server_paint_rect)(struct xrdp_mod *v, int x, int y, int cx, int cy,\n                             char *data, int width, int height,\n                             int srcx, int srcy);\n    int (*server_set_pointer)(struct xrdp_mod *v, int x, int y,\n                              char *data, char *mask);\n    int (*server_palette)(struct xrdp_mod *v, int *palette);\n    int (*server_msg)(struct xrdp_mod *v, const char *msg, int code);\n    /* This one can be assigned directly into the is_term member of\n     * a struct trans */\n    int (*server_is_term)(void);\n    int (*server_set_clip)(struct xrdp_mod *v, int x, int y, int cx, int cy);\n    int (*server_reset_clip)(struct xrdp_mod *v);\n    int (*server_set_fgcolor)(struct xrdp_mod *v, int fgcolor);\n    int (*server_set_bgcolor)(struct xrdp_mod *v, int bgcolor);\n    int (*server_set_opcode)(struct xrdp_mod *v, int opcode);\n    int (*server_set_mixmode)(struct xrdp_mod *v, int mixmode);\n    int (*server_set_brush)(struct xrdp_mod *v, int x_origin, int y_origin,\n                            int style, char *pattern);\n    int (*server_set_pen)(struct xrdp_mod *v, int style,\n                          int width);\n    int (*server_draw_line)(struct xrdp_mod *v, int x1, int y1, int x2, int y2);\n    int (*server_add_char)(struct xrdp_mod *v, int font, int character,\n                           int offset, int baseline,\n                           int width, int height, char *data);\n    int (*server_draw_text)(struct xrdp_mod *v, int font,\n                            int flags, int mixmode, int clip_left, int clip_top,\n                            int clip_right, int clip_bottom,\n                            int box_left, int box_top,\n                            int box_right, int box_bottom,\n                            int x, int y, char *data, int data_len);\n    int (*server_reset)(struct xrdp_mod *v, int width, int height, int bpp);\n    int (*server_get_channel_count)(struct xrdp_mod *v);\n    int (*server_query_channel)(struct xrdp_mod *v, int index,\n                                char *channel_name,\n                                int *channel_flags);\n    int (*server_get_channel_id)(struct xrdp_mod *v, const char *name);\n    int (*server_send_to_channel)(struct xrdp_mod *v, int channel_id,\n                                  char *data, int data_len,\n                                  int total_data_len, int flags);\n    int (*server_bell_trigger)(struct xrdp_mod *v);\n    int (*server_chansrv_in_use)(struct xrdp_mod *v);\n    /* off screen bitmaps */\n    int (*server_create_os_surface)(struct xrdp_mod *v, int rdpindex,\n                                    int width, int height);\n    int (*server_switch_os_surface)(struct xrdp_mod *v, int rdpindex);\n    int (*server_delete_os_surface)(struct xrdp_mod *v, int rdpindex);\n    int (*server_paint_rect_os)(struct xrdp_mod *mod, int x, int y,\n                                int cx, int cy,\n                                int rdpindex, int srcx, int srcy);\n    int (*server_set_hints)(struct xrdp_mod *mod, int hints, int mask);\n    /* rail */\n    int (*server_window_new_update)(struct xrdp_mod *mod, int window_id,\n                                    struct rail_window_state_order *window_state,\n                                    int flags);\n    int (*server_window_delete)(struct xrdp_mod *mod, int window_id);\n    int (*server_window_icon)(struct xrdp_mod *mod,\n                              int window_id, int cache_entry, int cache_id,\n                              struct rail_icon_info *icon_info,\n                              int flags);\n    int (*server_window_cached_icon)(struct xrdp_mod *mod,\n                                     int window_id, int cache_entry,\n                                     int cache_id, int flags);\n    int (*server_notify_new_update)(struct xrdp_mod *mod,\n                                    int window_id, int notify_id,\n                                    struct rail_notify_state_order *notify_state,\n                                    int flags);\n    int (*server_notify_delete)(struct xrdp_mod *mod, int window_id,\n                                int notify_id);\n    int (*server_monitored_desktop)(struct xrdp_mod *mod,\n                                    struct rail_monitored_desktop_order *mdo,\n                                    int flags);\n    int (*server_set_pointer_ex)(struct xrdp_mod *v, int x, int y, char *data,\n                                 char *mask, int bpp);\n    int (*server_add_char_alpha)(struct xrdp_mod *mod, int font, int character,\n                                 int offset, int baseline,\n                                 int width, int height, char *data);\n\n    int (*server_create_os_surface_bpp)(struct xrdp_mod *v, int rdpindex,\n                                        int width, int height, int bpp);\n    int (*server_paint_rect_bpp)(struct xrdp_mod *v, int x, int y, int cx, int cy,\n                                 char *data, int width, int height,\n                                 int srcx, int srcy, int bpp);\n    int (*server_composite)(struct xrdp_mod *v, int srcidx, int srcformat,\n                            int srcwidth, int srcrepeat, int *srctransform,\n                            int mskflags, int mskidx, int mskformat,\n                            int mskwidth, int mskrepeat, int op,\n                            int srcx, int srcy, int mskx, int msky,\n                            int dstx, int dsty, int width, int height,\n                            int dstformat);\n    int (*server_paint_rects)(struct xrdp_mod *v,\n                              int num_drects, short *drects,\n                              int num_crects, short *crects,\n                              char *data, int width, int height,\n                              int flags, int frame_id);\n    int (*server_session_info)(struct xrdp_mod *v, const char *data,\n                               int data_bytes);\n    int (*server_set_pointer_large)(struct xrdp_mod *v, int x, int y,\n                                    char *data, char *mask, int bpp,\n                                    int width, int height);\n    int (*server_paint_rects_ex)(struct xrdp_mod *v,\n                                 int num_drects, short *drects,\n                                 int num_crects, short *crects,\n                                 char *data, int left, int top,\n                                 int width, int height,\n                                 int flags, int frame_id,\n                                 void *shmem_ptr, int shmem_bytes);\n    tintptr server_dumby[100 - 48]; /* align, 100 minus the number of server\n                                     functions above */\n    /* common */\n    tintptr handle; /* pointer to self as int */\n    tintptr wm; /* struct xrdp_wm* */\n    tintptr painter;\n    struct source_info *si;\n};\n\n/**\n * Transform to apply to loaded images\n */\nenum xrdp_bitmap_load_transform\n{\n    XBLT_NONE = 0,\n    XBLT_SCALE,\n    XBLT_ZOOM\n};\n\n/* header for bmp file */\nstruct xrdp_bmp_header\n{\n    int size;\n    int image_width;\n    int image_height;\n    short planes;\n    short bit_count;\n    int compression;\n    int image_size;\n    int x_pels_per_meter;\n    int y_pels_per_meter;\n    int clr_used;\n    int clr_important;\n};\n\nstruct xrdp_palette_item\n{\n    int stamp;\n    int palette[256];\n};\n\nstruct xrdp_bitmap_item\n{\n    int stamp;\n    int lru_index;\n    struct xrdp_bitmap *bitmap;\n};\n\nstruct xrdp_lru_item\n{\n    int next;\n    int prev;\n};\n\nstruct xrdp_os_bitmap_item\n{\n    int id;\n    struct xrdp_bitmap *bitmap;\n};\n\nstruct xrdp_char_item\n{\n    int stamp;\n    struct xrdp_font_char font_item;\n};\n\nstruct xrdp_pointer_item\n{\n    int stamp;\n    int x; /* hotspot */\n    int y;\n    int pad0;\n    char data[96 * 96 * 4];\n    char mask[96 * 96 / 8];\n    int bpp;\n    int width;\n    int height;\n    int pad1;\n};\n\nstruct xrdp_brush_item\n{\n    int stamp;\n    /* expand this to a structure to handle more complicated brushes\n       for now it's 8x8 1bpp brushes only */\n    char pattern[8];\n};\n\n/* moved to xrdp_constants.h\n#define XRDP_BITMAP_CACHE_ENTRIES 2048 */\n\n/* difference caches */\nstruct xrdp_cache\n{\n    struct xrdp_wm *wm; /* owner */\n    struct xrdp_session *session;\n    /* palette */\n    int palette_stamp;\n    struct xrdp_palette_item palette_items[6];\n    /* bitmap */\n    int bitmap_stamp;\n    struct xrdp_bitmap_item bitmap_items[XRDP_MAX_BITMAP_CACHE_ID]\n        [XRDP_MAX_BITMAP_CACHE_IDX];\n\n    /* lru optimize */\n    struct xrdp_lru_item bitmap_lrus[XRDP_MAX_BITMAP_CACHE_ID]\n        [XRDP_MAX_BITMAP_CACHE_IDX];\n    int lru_head[XRDP_MAX_BITMAP_CACHE_ID];\n    int lru_tail[XRDP_MAX_BITMAP_CACHE_ID];\n    int lru_reset[XRDP_MAX_BITMAP_CACHE_ID];\n\n    /* crc optimize */\n    struct list16 crc16[XRDP_MAX_BITMAP_CACHE_ID][64 * 1024];\n\n    int use_bitmap_comp;\n    int cache1_entries;\n    int cache1_size;\n    int cache2_entries;\n    int cache2_size;\n    int cache3_entries;\n    int cache3_size;\n    int bitmap_cache_persist_enable;\n    int bitmap_cache_version;\n    /* font */\n    int char_stamp;\n    struct xrdp_char_item char_items[12][256];\n    /* pointer */\n    int pointer_stamp;\n    struct xrdp_pointer_item pointer_items[32];\n    int pointer_cache_entries;\n    int brush_stamp;\n    struct xrdp_brush_item brush_items[64];\n    struct xrdp_os_bitmap_item os_bitmap_items[2000];\n    struct list *xrdp_os_del_list;\n};\n\n/* defined later */\nstruct xrdp_enc_data;\n\n/**\n * Stages we go through connecting to the session\n */\nenum mm_connect_state\n{\n    MMCS_CONNECT_TO_SESMAN,\n    MMCS_GATEWAY_LOGIN,\n    MMCS_SESSION_LOGIN,\n    MMCS_CREATE_SESSION,\n    MMCS_CONNECT_TO_SESSION,\n    MMCS_CONNECT_TO_CHANSRV,\n    MMCS_DONE\n};\n\nenum display_resize_state\n{\n    WMRZ_ENCODER_DELETE = 0,\n    WMRZ_EGFX_DELETE_SURFACE,\n    WMRZ_EGFX_CONN_CLOSE,\n    WMRZ_EGFX_CONN_CLOSING,\n    WMRZ_EGFX_CONN_CLOSED,\n    WRMZ_EGFX_DELETE,\n    WMRZ_SERVER_MONITOR_RESIZE,\n    WMRZ_SERVER_VERSION_MESSAGE,\n    WMRZ_XRDP_CORE_RESIZE,\n    WMRZ_EGFX_INITIALIZE,\n    WMRZ_EGFX_INITALIZING,\n    WMRZ_EGFX_INITIALIZED,\n    WMRZ_ENCODER_CREATE,\n    WMRZ_SERVER_INVALIDATE,\n    WMRZ_COMPLETE,\n    WMRZ_ERROR\n};\n\n#define XRDP_DISPLAY_RESIZE_STATE_TO_STR(status) \\\n    ((status) == WMRZ_ENCODER_DELETE ? \"WMRZ_ENCODER_DELETE\" : \\\n     (status) == WMRZ_EGFX_DELETE_SURFACE ? \"WMRZ_EGFX_DELETE_SURFACE\" : \\\n     (status) == WMRZ_EGFX_CONN_CLOSE ? \"WMRZ_EGFX_CONN_CLOSE\" : \\\n     (status) == WMRZ_EGFX_CONN_CLOSING ? \"WMRZ_EGFX_CONN_CLOSING\" : \\\n     (status) == WMRZ_EGFX_CONN_CLOSED ? \"WMRZ_EGFX_CONN_CLOSED\" : \\\n     (status) == WRMZ_EGFX_DELETE ? \"WMRZ_EGFX_DELETE\" : \\\n     (status) == WMRZ_SERVER_MONITOR_RESIZE ? \"WMRZ_SERVER_MONITOR_RESIZE\" : \\\n     (status) == WMRZ_SERVER_VERSION_MESSAGE ? \"WMRZ_SERVER_VERSION_MESSAGE\" : \\\n     (status) == WMRZ_XRDP_CORE_RESIZE ? \"WMRZ_XRDP_CORE_RESIZE\" : \\\n     (status) == WMRZ_EGFX_INITIALIZE ? \"WMRZ_EGFX_INITIALIZE\" : \\\n     (status) == WMRZ_EGFX_INITALIZING ? \"WMRZ_EGFX_INITALIZING\" : \\\n     (status) == WMRZ_EGFX_INITIALIZED ? \"WMRZ_EGFX_INITIALIZED\" : \\\n     (status) == WMRZ_ENCODER_CREATE ? \"WMRZ_ENCODER_CREATE\" : \\\n     (status) == WMRZ_SERVER_INVALIDATE ? \"WMRZ_SERVER_INVALIDATE\" : \\\n     (status) == WMRZ_COMPLETE ? \"WMRZ_COMPLETE\" : \\\n     (status) == WMRZ_ERROR ? \"WMRZ_ERROR\" : \\\n     \"unknown\" \\\n    )\n\nstruct xrdp_mm\n{\n    struct xrdp_wm *wm; /* owner */\n    enum mm_connect_state connect_state; /* State of connection */\n    int mmcs_expecting_msg; /* Connect state machine is expecting\n                               a message from sesman */\n    /* Other processes we connect to */\n    int use_sesman; /* true if this is a sesman session */\n    int use_gw_login; /* True if we're to login using  a gateway */\n    int use_chansrv; /* true if chansrvport is set in xrdp.ini or using sesman */\n    struct trans *sesman_trans; /* connection to sesman */\n    struct trans *chan_trans; /* connection to chansrv */\n\n    /* We can't delete transports while we're in a callback for that\n     * transport, as this causes trans.c to reference undefined memory.\n     * These flags mark transports as needing to be deleted when\n     * we are definitely not in a transport callback */\n    int delete_sesman_trans;\n\n    struct list *login_names;\n    struct list *login_values;\n    /* mod vars */\n    long mod_handle; /* returned from g_load_library */\n    struct xrdp_mod *(*mod_init)(void);\n    int (*mod_exit)(struct xrdp_mod *);\n    struct xrdp_mod *mod; /* module interface */\n    int display; /* 10 for :10.0, 11 for :11.0, etc */\n    struct guid guid; /* GUID for the session, or all zeros  */\n    int code; /* 0=Xvnc session, 20=xorg driver mode */\n    struct xrdp_encoder *encoder;\n    int cs2xr_cid_map[256];\n    int xr2cr_cid_map[256];\n    int dynamic_monitor_chanid;\n    struct xrdp_egfx *egfx;\n    int egfx_up;\n\n    /* Resize on-the-fly control */\n    struct display_control_monitor_layout_data *resize_data;\n    struct list *resize_queue;\n    tbus resize_ready;\n};\n\nstruct xrdp_key_info\n{\n    int sym;\n    int chr;\n};\n\nstruct xrdp_keymap\n{\n    struct xrdp_key_info keys_noshift[256];\n    struct xrdp_key_info keys_shift[256];\n    struct xrdp_key_info keys_altgr[256];\n    struct xrdp_key_info keys_shiftaltgr[256];\n    struct xrdp_key_info keys_capslock[256];\n    struct xrdp_key_info keys_capslockaltgr[256];\n    struct xrdp_key_info keys_shiftcapslock[256];\n    struct xrdp_key_info keys_shiftcapslockaltgr[256];\n};\n\n/* the window manager */\n\n/***\n * Window manager login mode states\n *\n * Use with xrdp_wm_set_login_state()\n */\nenum wm_login_state\n{\n    /**\n     * Place the window manager in this state to reset it\n     */\n    WMLS_RESET = 0,\n    /**\n     * In this state, the window manager is waiting for the user to fill\n     * in the login box\n     */\n    WMLS_USER_PROMPT,\n    /**\n     * Place the window manager in this state to request xrdp connects to\n     * the X server, sesman, chansrv etc\n     */\n    WMLS_START_CONNECT,\n    /**\n     * In this state, the window manager is making required connections\n     */\n    WMLS_CONNECT_IN_PROGRESS,\n    /**\n     * Place the window manager in this state to request it finishes.\n     */\n    WMLS_CLEANUP,\n    /**\n     * In this state, the window manager is inactive\n     */\n    WMLS_INACTIVE\n};\n\nstruct xrdp_wm\n{\n    struct xrdp_process *pro_layer; /* owner */\n    struct xrdp_bitmap *screen;\n    struct xrdp_session *session;\n    struct xrdp_painter *painter;\n    struct xrdp_cache *cache;\n    int palette[256];\n    struct xrdp_bitmap *login_window;\n    /* generic colors */\n    int black;\n    int grey;\n    int dark_grey;\n    int blue;\n    int dark_blue;\n    int white;\n    int red;\n    int green;\n    int background;\n    /* dragging info */\n    int dragging;\n    int draggingx;\n    int draggingy;\n    int draggingcx;\n    int draggingcy;\n    int draggingdx;\n    int draggingdy;\n    int draggingorgx;\n    int draggingorgy;\n    int draggingxorstate;\n    struct xrdp_bitmap *dragging_window;\n    /* the down(clicked) button */\n    struct xrdp_bitmap *button_down;\n    /* popup for combo box */\n    struct xrdp_bitmap *popup_wnd;\n    /* focused window */\n    struct xrdp_bitmap *focused_window;\n    /* pointer */\n    int current_pointer;\n    int mouse_x;\n    int mouse_y;\n    /* keyboard info */\n    int keys[256]; /* key states 0 up 1 down*/\n    int caps_lock;\n    int scroll_lock;\n    int num_lock;\n    /* client info */\n    struct xrdp_client_info *client_info;\n    /* session log */\n    struct list *log;\n    struct xrdp_bitmap *log_wnd;\n    enum wm_login_state login_state;\n    tbus login_state_event;\n    struct xrdp_mm *mm;\n    struct xrdp_font *default_font;\n    struct xrdp_keymap keymap;\n    int hide_log_window;\n    int fatal_error_in_log_window;\n    struct xrdp_bitmap *target_surface; /* either screen or os surface */\n    int current_surface_index;\n    int hints;\n    char pamerrortxt[256];\n\n    /* configuration derived from xrdp.ini */\n    struct xrdp_config *xrdp_config;\n\n    struct xrdp_region *screen_dirty_region;\n    int last_screen_draw_time;\n};\n\n/* rdp process */\nstruct xrdp_process\n{\n    int status;\n    struct trans *server_trans; /* in tcp server mode */\n    tbus self_term_event;\n    struct xrdp_listen *lis_layer; /* owner */\n    struct xrdp_session *session;\n    /* create these when up and running */\n    struct xrdp_wm *wm;\n    //int app_sck;\n    tbus done_event;\n    int session_id;\n};\n\n/* rdp listener */\nstruct xrdp_listen\n{\n    int status;\n    struct list *trans_list; /* list of struct trans* */\n    struct list *process_list;\n    struct list *fork_list;\n    tbus pro_done_event;\n    struct xrdp_startup_params *startup_params;\n};\n\n/* region */\nstruct xrdp_region\n{\n    struct xrdp_wm *wm; /* owner */\n    struct pixman_region16 *reg;\n};\n\n/* painter */\nstruct xrdp_painter\n{\n    int rop;\n    struct xrdp_rect *use_clip; /* nil if not using clip */\n    struct xrdp_rect clip;\n    int clip_children;\n    int bg_color;\n    int fg_color;\n    int mix_mode;\n    struct xrdp_brush brush;\n    struct xrdp_pen pen;\n    struct xrdp_session *session;\n    struct xrdp_wm *wm; /* owner */\n    struct xrdp_font *font;\n    void *painter;\n    struct xrdp_region *dirty_region;\n    int begin_end_level;\n};\n\n/* window or bitmap */\nstruct xrdp_bitmap\n{\n    /* 0 = bitmap 1 = window 2 = screen 3 = button 4 = image 5 = edit\n       6 = label 7 = combo 8 = special */\n    int type;\n    int width;\n    int height;\n    struct xrdp_wm *wm;\n    /* msg 1 = click 2 = mouse move 3 = paint 100 = modal result */\n    /* see messages in constants.h */\n    int (*notify)(struct xrdp_bitmap *wnd, struct xrdp_bitmap *sender,\n                  int msg, long param1, long param2);\n    /* for bitmap */\n    int bpp;\n    int line_size; /* in bytes */\n    int do_not_free_data;\n    char *data;\n    /* for all but bitmap */\n    int left;\n    int top;\n    int pointer;\n    int bg_color;\n    int tab_stop;\n    int id;\n    char *caption1;\n    /* for window or screen */\n    struct xrdp_bitmap *modal_dialog;\n    struct xrdp_bitmap *focused_control;\n    struct xrdp_bitmap *owner; /* window that created us */\n    struct xrdp_bitmap *parent; /* window contained in */\n    /* for modal dialog */\n    struct xrdp_bitmap *default_button; /* button when enter is pressed */\n    struct xrdp_bitmap *esc_button; /* button when esc is pressed */\n    /* list of child windows */\n    struct list *child_list;\n    /* for edit */\n    int edit_pos;\n    twchar password_char;\n    /* for button or combo */\n    int state; /* for button 0 = normal 1 = down */\n    /* for combo */\n    struct list *string_list;\n    struct list *data_list;\n    /* for combo or popup */\n    int item_index;\n    /* for popup */\n    struct xrdp_bitmap *popped_from;\n    int item_height;\n    /* crc */\n    int crc32;\n    int crc16;\n};\n\n#define NUM_FONTS 0x4e00\n#define DEFAULT_FONT_NAME \"sans-10.fv1\"\n#define DEFAULT_FONT_PIXEL_SIZE 16\n#define DEFAULT_FV1_SELECT \"130:sans-18.fv1,0:\" DEFAULT_FONT_NAME\n\n#define DEFAULT_BUTTON_MARGIN_H 12\n#define DEFAULT_BUTTON_MARGIN_W 12\n#define DEFAULT_COMBO_MARGIN_H 6\n#define DEFAULT_EDIT_MARGIN_H  6\n#define DEFAULT_WND_LOGIN_W   425\n#define DEFAULT_WND_LOGIN_H   475\n#define DEFAULT_WND_HELP_W    340\n#define DEFAULT_WND_HELP_H    300\n#define DEFAULT_WND_LOG_W     400\n#define DEFAULT_WND_LOG_H     400\n#define DEFAULT_WND_SPECIAL_H 100\n\n/* font */\nstruct xrdp_font\n{\n    struct xrdp_wm *wm;\n    struct xrdp_font_char font_items[NUM_FONTS];\n    char name[32];\n    int size;\n    /** Body height in pixels */\n    int body_height;\n    int style;\n};\n\n/* module */\nstruct xrdp_mod_data\n{\n    struct list *names;\n    struct list *values;\n};\n\nstruct xrdp_startup_params\n{\n    /* xrdp_ini is not malloc'd and has at least the same lifetime as main() */\n    const char *xrdp_ini;\n    char port[1024];\n    int kill;\n    int no_daemon;\n    int help;\n    int version;\n    int fork;\n    int dump_config;\n    int license;\n    int tcp_send_buffer_bytes;\n    int tcp_recv_buffer_bytes;\n    int tcp_nodelay;\n    int tcp_keepalive;\n    int use_vsock;\n};\n\n/*\n * For storing xrdp.ini (and other) configuration settings\n */\n\nstruct xrdp_ls_dimensions\n{\n    int  width;               /* window width */\n    int  height;              /* window height */\n    int  logo_width;          /* logo width (optional) */\n    int  logo_height;          /* logo height (optional) */\n    int  logo_x_pos;          /* logo x co-ordinate */\n    int  logo_y_pos;          /* logo y co-ordinate */\n    int  label_x_pos;         /* x pos of labels */\n    int  label_width;         /* width of labels */\n    int  input_x_pos;         /* x pos of text and combo boxes */\n    int  input_width;         /* width of input and combo boxes */\n    int  input_y_pos;         /* y pos for for first label and combo box */\n    int  btn_ok_x_pos;        /* x pos for OK button */\n    int  btn_ok_y_pos;        /* y pos for OK button */\n    int  btn_ok_width;        /* width of OK button */\n    int  btn_ok_height;       /* height of OK button */\n    int  btn_cancel_x_pos;    /* x pos for Cancel button */\n    int  btn_cancel_y_pos;    /* y pos for Cancel button */\n    int  btn_cancel_width;    /* width of Cancel button */\n    int  btn_cancel_height;   /* height of Cancel button */\n    int default_btn_height;   /* Default button height (e.g. OK on login box) */\n    int log_wnd_width;        /* Width of log window */\n    int log_wnd_height;       /* Height of log window */\n    int edit_height;          /* Height of an edit box */\n    int combo_height;         /* Height of a combo box */\n    int help_wnd_width;        /* Width of login help window */\n    int help_wnd_height;       /* Height of login help window */\n};\n\nstruct xrdp_cfg_globals\n{\n    int  ini_version;            /* xrdp.ini file version number */\n    int  use_bitmap_cache;\n    int  use_bitmap_compression;\n    int  port;\n    int  crypt_level;            /* low=1, medium=2, high=3 */\n    int  allow_channels;\n    int  max_bpp;\n    int  fork;\n    int  tcp_nodelay;\n    int  tcp_keepalive;\n    int  tcp_send_buffer_bytes;\n    int  tcp_recv_buffer_bytes;\n    char autorun[256];\n    int  hidelogwindow;\n    int  require_credentials;\n    int  bulk_compression;\n    int  new_cursors;\n    int  nego_sec_layer;\n    int  allow_multimon;\n    int  enable_token_login;\n\n    /* colors */\n\n    int  grey;\n    int  black;\n    int  dark_grey;\n    int  blue;\n    int  dark_blue;\n    int  white;\n    int  red;\n    int  green;\n    int  background;\n\n    /* login screen */\n    unsigned int  default_dpi;   /* Default DPI to use if nothing from client */\n    char fv1_select[256];        /* Selection string for fv1 font */\n    int  ls_top_window_bg_color; /* top level window background color */\n    int  ls_bg_color;            /* background color */\n    char ls_background_image[256];  /* background image file name */\n    /* transform to apply to background image */\n    enum xrdp_bitmap_load_transform ls_background_transform;\n    char ls_logo_filename[256];  /* logo filename */\n    /* transform to apply to logo */\n    enum xrdp_bitmap_load_transform ls_logo_transform;\n    char ls_title[256];          /* loginscreen window title */\n    /* Login screen dimensions, unscaled (from config) */\n    struct xrdp_ls_dimensions ls_unscaled;\n    /* Login screen dimensions, scaled (after font is loaded) */\n    struct xrdp_ls_dimensions ls_scaled;\n};\n\nstruct xrdp_cfg_logging\n{\n\n};\n\nstruct xrdp_cfg_channels\n{\n\n};\n\nstruct xrdp_config\n{\n    struct xrdp_cfg_globals   cfg_globals;\n    struct xrdp_cfg_logging   cfg_logging;\n    struct xrdp_cfg_channels  cfg_channels;\n};\n\n#endif\n"], "fixing_code": ["/**\n * xrdp: A Remote Desktop Protocol server.\n *\n * Copyright (C) Jay Sorg 2004-2014\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * main include file\n */\n\n#ifndef _XRDP_XRDP_H_\n#define _XRDP_XRDP_H_\n\n/* include other h files */\n#include \"arch.h\"\n#include \"parse.h\"\n#include \"trans.h\"\n#include \"list.h\"\n#include \"list16.h\"\n#include \"libxrdpinc.h\"\n#include \"xrdp_constants.h\"\n#include \"xrdp_types.h\"\n#include \"defines.h\"\n#include \"os_calls.h\"\n#include \"ssl_calls.h\"\n#include \"thread_calls.h\"\n#include \"file.h\"\n#include \"xrdp_client_info.h\"\n#include \"log.h\"\n\n/* xrdp.c */\nlong\ng_xrdp_sync(long (*sync_func)(long param1, long param2), long sync_param1,\n            long sync_param2);\nint\nxrdp_child_fork(void);\nlong\ng_get_sync_mutex(void);\nvoid\ng_set_sync_mutex(long mutex);\nlong\ng_get_sync1_mutex(void);\nvoid\ng_set_sync1_mutex(long mutex);\nvoid\ng_set_term_event(tbus event);\nvoid\ng_set_sigchld_event(tbus event);\nvoid\ng_set_sync_event(tbus event);\nlong\ng_get_threadid(void);\nvoid\ng_set_threadid(long id);\ntbus\ng_get_term(void);\ntbus\ng_get_sigchld(void);\nint\ng_is_term(void);\nvoid\ng_set_term(int in_val);\nvoid\ng_set_sigchld(int in_val);\ntbus\ng_get_sync_event(void);\nvoid\ng_process_waiting_function(void);\n\n/* xrdp_cache.c */\nstruct xrdp_cache *\nxrdp_cache_create(struct xrdp_wm *owner, struct xrdp_session *session,\n                  struct xrdp_client_info *client_info);\nvoid\nxrdp_cache_delete(struct xrdp_cache *self);\nint\nxrdp_cache_reset(struct xrdp_cache *self,\n                 struct xrdp_client_info *client_info);\nint\nxrdp_cache_add_bitmap(struct xrdp_cache *self, struct xrdp_bitmap *bitmap,\n                      int hints);\nint\nxrdp_cache_add_palette(struct xrdp_cache *self, int *palette);\nint\nxrdp_cache_add_char(struct xrdp_cache *self,\n                    struct xrdp_font_char *font_item);\nint\nxrdp_cache_add_pointer(struct xrdp_cache *self,\n                       struct xrdp_pointer_item *pointer_item);\nint\nxrdp_cache_add_pointer_static(struct xrdp_cache *self,\n                              struct xrdp_pointer_item *pointer_item,\n                              int index);\nint\nxrdp_cache_add_brush(struct xrdp_cache *self,\n                     char *brush_item_data);\nint\nxrdp_cache_add_os_bitmap(struct xrdp_cache *self, struct xrdp_bitmap *bitmap,\n                         int rdpindex);\nint\nxrdp_cache_remove_os_bitmap(struct xrdp_cache *self, int rdpindex);\nstruct xrdp_os_bitmap_item *\nxrdp_cache_get_os_bitmap(struct xrdp_cache *self, int rdpindex);\n\n/* xrdp_wm.c */\nstruct xrdp_wm *\nxrdp_wm_create(struct xrdp_process *owner,\n               struct xrdp_client_info *client_info);\nvoid\nxrdp_wm_delete(struct xrdp_wm *self);\nint\nxrdp_wm_send_palette(struct xrdp_wm *self);\nint\nxrdp_wm_send_bell(struct xrdp_wm *self);\nint\nxrdp_wm_load_static_colors_plus(struct xrdp_wm *self, char *autorun_name);\nint\nxrdp_wm_load_static_pointers(struct xrdp_wm *self);\nint\nxrdp_wm_init(struct xrdp_wm *self);\nint\nxrdp_wm_send_bitmap(struct xrdp_wm *self, struct xrdp_bitmap *bitmap,\n                    int x, int y, int cx, int cy);\nint\nxrdp_wm_set_pointer(struct xrdp_wm *self, int cache_idx);\nunsigned int\nxrdp_wm_htoi (const char *ptr);\nint\nxrdp_wm_set_focused(struct xrdp_wm *self, struct xrdp_bitmap *wnd);\nint\nxrdp_wm_get_vis_region(struct xrdp_wm *self, struct xrdp_bitmap *bitmap,\n                       int x, int y, int cx, int cy,\n                       struct xrdp_region *region, int clip_children);\nint\nxrdp_wm_mouse_move(struct xrdp_wm *self, int x, int y);\nint\nxrdp_wm_mouse_touch(struct xrdp_wm *self, int gesture, int param);\nint\nxrdp_wm_mouse_click(struct xrdp_wm *self, int x, int y, int but, int down);\nint\nxrdp_wm_key(struct xrdp_wm *self, int device_flags, int scan_code);\nint\nxrdp_wm_key_sync(struct xrdp_wm *self, int device_flags, int key_flags);\nint\nxrdp_wm_pu(struct xrdp_wm *self, struct xrdp_bitmap *control);\nint\nxrdp_wm_send_pointer(struct xrdp_wm *self, int cache_idx,\n                     char *data, char *mask, int x, int y, int bpp,\n                     int width, int height);\nint\nxrdp_wm_pointer(struct xrdp_wm *self, char *data, char *mask, int x, int y,\n                int bpp, int width, int height);\nint\ncallback(intptr_t id, int msg, intptr_t param1, intptr_t param2,\n         intptr_t param3, intptr_t param4);\nint\nxrdp_wm_delete_all_children(struct xrdp_wm *self);\nint\nxrdp_wm_show_log(struct xrdp_wm *self);\nint\nxrdp_wm_log_msg(struct xrdp_wm *self, enum logLevels loglevel,\n                const char *fmt, ...) printflike(3, 4);\nint\nxrdp_wm_get_wait_objs(struct xrdp_wm *self, tbus *robjs, int *rc,\n                      tbus *wobjs, int *wc, int *timeout);\nint\nxrdp_wm_check_wait_objs(struct xrdp_wm *self);\nconst char *\nxrdp_wm_login_state_to_str(enum wm_login_state login_state);\nint\nxrdp_wm_set_login_state(struct xrdp_wm *self, enum wm_login_state login_state);\nint\nxrdp_wm_can_resize(struct xrdp_wm *self);\nvoid\nxrdp_wm_mod_connect_done(struct xrdp_wm *self, int status);\n\n/* xrdp_process.c */\nstruct xrdp_process *\nxrdp_process_create(struct xrdp_listen *owner, tbus done_event);\nvoid\nxrdp_process_delete(struct xrdp_process *self);\nint\nxrdp_process_main_loop(struct xrdp_process *self);\n\n/* xrdp_listen.c */\nstruct xrdp_listen *\nxrdp_listen_create(void);\nvoid\nxrdp_listen_delete(struct xrdp_listen *self);\nint\nxrdp_listen_main_loop(struct xrdp_listen *self);\nint\nxrdp_listen_test(struct xrdp_startup_params *startup_params);\n\n/* xrdp_region.c */\nstruct xrdp_region *\nxrdp_region_create(struct xrdp_wm *wm);\nvoid\nxrdp_region_delete(struct xrdp_region *self);\nint\nxrdp_region_add_rect(struct xrdp_region *self, struct xrdp_rect *rect);\nint\nxrdp_region_subtract_rect(struct xrdp_region *self, struct xrdp_rect *rect);\nint\nxrdp_region_intersect_rect(struct xrdp_region *self, struct xrdp_rect *rect);\nint\nxrdp_region_get_rect(struct xrdp_region *self, int index,\n                     struct xrdp_rect *rect);\nint\nxrdp_region_get_bounds(struct xrdp_region *self, struct xrdp_rect *rect);\nint\nxrdp_region_not_empty(struct xrdp_region *self);\n\n/* xrdp_bitmap_common.c */\nstruct xrdp_bitmap *\nxrdp_bitmap_create(int width, int height, int bpp,\n                   int type, struct xrdp_wm *wm);\nstruct xrdp_bitmap *\nxrdp_bitmap_create_with_data(int width, int height,\n                             int bpp, char *data,\n                             struct xrdp_wm *wm);\nvoid\nxrdp_bitmap_delete(struct xrdp_bitmap *self);\nint\nxrdp_bitmap_resize(struct xrdp_bitmap *self, int width, int height);\nint\nxrdp_bitmap_get_pixel(struct xrdp_bitmap *self, int x, int y);\nint\nxrdp_bitmap_set_pixel(struct xrdp_bitmap *self, int x, int y, int pixel);\nint\nxrdp_bitmap_copy_box(struct xrdp_bitmap *self,\n                     struct xrdp_bitmap *dest,\n                     int x, int y, int cx, int cy);\n\n/* xrdp_bitmap.c */\nstruct xrdp_bitmap *\nxrdp_bitmap_get_child_by_id(struct xrdp_bitmap *self, int id);\nint\nxrdp_bitmap_set_focus(struct xrdp_bitmap *self, int focused);\nint\nxrdp_bitmap_hash_crc(struct xrdp_bitmap *self);\nint\nxrdp_bitmap_copy_box_with_crc(struct xrdp_bitmap *self,\n                              struct xrdp_bitmap *dest,\n                              int x, int y, int cx, int cy);\nint\nxrdp_bitmap_compare(struct xrdp_bitmap *self,\n                    struct xrdp_bitmap *b);\nint\nxrdp_bitmap_invalidate(struct xrdp_bitmap *self, struct xrdp_rect *rect);\nint\nxrdp_bitmap_def_proc(struct xrdp_bitmap *self, int msg,\n                     int param1, int param2);\nint\nxrdp_bitmap_to_screenx(struct xrdp_bitmap *self, int x);\nint\nxrdp_bitmap_to_screeny(struct xrdp_bitmap *self, int y);\nint\nxrdp_bitmap_from_screenx(struct xrdp_bitmap *self, int x);\nint\nxrdp_bitmap_from_screeny(struct xrdp_bitmap *self, int y);\nint\nxrdp_bitmap_get_screen_clip(struct xrdp_bitmap *self,\n                            struct xrdp_painter *painter,\n                            struct xrdp_rect *rect,\n                            int *dx, int *dy);\n\n/* xrdp_bitmap_load.c */\n/**\n * Loads a bitmap from a file and (optionally) transforms it\n *\n * @param self from rdp_bitmap_create()\n * @param filename Filename to load\n * @param[in] palette For 8-bit conversions. Currently unused\n * @param background Background color for alpha-blending\n * @param transform Transform to apply to the image after loading\n * @param twidth target width if transform != XBLT_NONE\n * @param theight target height if transform != XBLT_NONE\n * @return 0 for success.\n *\n * The background color is only used if the specified image contains\n * an alpha layer. It is in HCOLOR format, and the bpp must correspond to\n * the bpp used to create 'self'.\n *\n * After a successful call, the bitmap is resized to the image file size.\n *\n * If the call is not successful, the bitmap will be in an indeterminate\n * state and should not be used.\n */\nint\nxrdp_bitmap_load(struct xrdp_bitmap *self, const char *filename,\n                 const int *palette,\n                 int background,\n                 enum xrdp_bitmap_load_transform transform,\n                 int twidth,\n                 int theight);\n/* xrdp_painter.c */\nstruct xrdp_painter *\nxrdp_painter_create(struct xrdp_wm *wm, struct xrdp_session *session);\nvoid\nxrdp_painter_delete(struct xrdp_painter *self);\nint\nwm_painter_set_target(struct xrdp_painter *self);\nint\nxrdp_painter_begin_update(struct xrdp_painter *self);\nint\nxrdp_painter_end_update(struct xrdp_painter *self);\nint\nxrdp_painter_font_needed(struct xrdp_painter *self);\nint\nxrdp_painter_set_clip(struct xrdp_painter *self,\n                      int x, int y, int cx, int cy);\nint\nxrdp_painter_clr_clip(struct xrdp_painter *self);\nint\nxrdp_painter_fill_rect(struct xrdp_painter *self,\n                       struct xrdp_bitmap *bitmap,\n                       int x, int y, int cx, int cy);\nint\nxrdp_painter_draw_bitmap(struct xrdp_painter *self,\n                         struct xrdp_bitmap *bitmap,\n                         struct xrdp_bitmap *to_draw,\n                         int x, int y, int cx, int cy);\nint\nxrdp_painter_text_width(struct xrdp_painter *self, const char *text);\nunsigned int\nxrdp_painter_font_body_height(const struct xrdp_painter *self);\nint\nxrdp_painter_draw_text(struct xrdp_painter *self,\n                       struct xrdp_bitmap *bitmap,\n                       int x, int y, const char *text);\nint\nxrdp_painter_draw_text2(struct xrdp_painter *self,\n                        struct xrdp_bitmap *bitmap,\n                        int font, int flags, int mixmode,\n                        int clip_left, int clip_top,\n                        int clip_right, int clip_bottom,\n                        int box_left, int box_top,\n                        int box_right, int box_bottom,\n                        int x, int y, char *data, int data_len);\nint\nxrdp_painter_copy(struct xrdp_painter *self,\n                  struct xrdp_bitmap *src,\n                  struct xrdp_bitmap *dst,\n                  int x, int y, int cx, int cy,\n                  int srcx, int srcy);\nint\nxrdp_painter_composite(struct xrdp_painter *self,\n                       struct xrdp_bitmap *src,\n                       int srcformat,\n                       int srcwidth,\n                       int srcrepeat,\n                       struct xrdp_bitmap *dst,\n                       int *srctransform,\n                       int mskflags,\n                       struct xrdp_bitmap *msk,\n                       int mskformat, int mskwidth, int mskrepeat, int op,\n                       int srcx, int srcy, int mskx, int msky,\n                       int dstx, int dsty, int width, int height,\n                       int dstformat);\nint\nxrdp_painter_line(struct xrdp_painter *self,\n                  struct xrdp_bitmap *bitmap,\n                  int x1, int y1, int x2, int y2);\n\n/* xrdp_font.c */\nstruct xrdp_font *\nxrdp_font_create(struct xrdp_wm *wm, unsigned int dpi);\nvoid\nxrdp_font_delete(struct xrdp_font *self);\nint\nxrdp_font_item_compare(struct xrdp_font_char *font1,\n                       struct xrdp_font_char *font2);\n/**\n * Gets a checked xrdp_font_char from a font\n * @param f Font\n * @param c32 Unicode codepoint\n */\n#define XRDP_FONT_GET_CHAR(f, c32) \\\n    (((unsigned int)(c32) >= ' ') && ((unsigned int)(c32) < (f)->char_count) \\\n     ? ((f)->chars + (unsigned int)(c32)) \\\n     : (f)->default_char)\n\n/* funcs.c */\nint\nrect_contains_pt(struct xrdp_rect *in, int x, int y);\nint\nrect_intersect(struct xrdp_rect *in1, struct xrdp_rect *in2,\n               struct xrdp_rect *out);\nint\nrect_contained_by(struct xrdp_rect *in1, int left, int top,\n                  int right, int bottom);\nint\ncheck_bounds(struct xrdp_bitmap *b, int *x, int *y, int *cx, int *cy);\nint\nadd_char_at(char *text, int text_size, twchar ch, int index);\nint\nremove_char_at(char *text, int text_size, int index);\nint\nset_string(char **in_str, const char *in);\nint\nwchar_repeat(twchar *dest, int dest_size_in_wchars, twchar ch, int repeat);\n\n/* in lang.c */\nstruct xrdp_key_info *\nget_key_info_from_scan_code(int device_flags, int scan_code, int *keys,\n                            int caps_lock, int num_lock, int scroll_lock,\n                            struct xrdp_keymap *keymap);\nint\nget_keysym_from_scan_code(int device_flags, int scan_code, int *keys,\n                          int caps_lock, int num_lock, int scroll_lock,\n                          struct xrdp_keymap *keymap);\ntwchar\nget_char_from_scan_code(int device_flags, int scan_code, int *keys,\n                        int caps_lock, int num_lock, int scroll_lock,\n                        struct xrdp_keymap *keymap);\nint\nget_keymaps(int keylayout, struct xrdp_keymap *keymap);\n\nint\nkm_load_file(const char *filename, struct xrdp_keymap *keymap);\n\n/* xrdp_login_wnd.c */\n/**\n * Gets the DPI of the login (primary) monitor\n *\n * @param self xrdp_wm instance\n * @return DPI of primary monitor, or 0 if unavailable.\n */\nunsigned int\nxrdp_login_wnd_get_monitor_dpi(struct xrdp_wm *self);\nint\nxrdp_login_wnd_create(struct xrdp_wm *self);\nint\nload_xrdp_config(struct xrdp_config *config, const char *xrdp_ini, int bpp);\nvoid\nxrdp_login_wnd_scale_config_values(struct xrdp_wm *self);\n\n/* xrdp_bitmap_compress.c */\nint\nxrdp_bitmap_compress(char *in_data, int width, int height,\n                     struct stream *s, int bpp, int byte_limit,\n                     int start_line, struct stream *temp,\n                     int e);\n\n/* xrdp_mm.c */\n\nstruct display_control_monitor_layout_data\n{\n    struct display_size_description description;\n    enum display_resize_state state;\n    int last_state_update_timestamp;\n    int start_time;\n};\n\nint\nxrdp_mm_drdynvc_up(struct xrdp_mm *self);\nint\nxrdp_mm_suppress_output(struct xrdp_mm *self, int suppress,\n                        int left, int top, int right, int bottom);\nstruct xrdp_mm *\nxrdp_mm_create(struct xrdp_wm *owner);\nvoid\nxrdp_mm_delete(struct xrdp_mm *self);\nvoid\nxrdp_mm_connect(struct xrdp_mm *self);\nint\nxrdp_mm_process_channel_data(struct xrdp_mm *self, tbus param1, tbus param2,\n                             tbus param3, tbus param4);\nint\nxrdp_mm_get_wait_objs(struct xrdp_mm *self,\n                      tbus *read_objs, int *rcount,\n                      tbus *write_objs, int *wcount, int *timeout);\nint\nxrdp_mm_check_chan(struct xrdp_mm *self);\nint\nxrdp_mm_check_wait_objs(struct xrdp_mm *self);\nint\nxrdp_mm_frame_ack(struct xrdp_mm *self, int frame_id);\nint\nxrdp_mm_egfx_send_planar_bitmap(struct xrdp_mm *self,\n                                struct xrdp_bitmap *bitmap,\n                                struct xrdp_rect *rect);\nint\nserver_begin_update(struct xrdp_mod *mod);\nint\nserver_end_update(struct xrdp_mod *mod);\nint\nserver_bell_trigger(struct xrdp_mod *mod);\nint\nserver_chansrv_in_use(struct xrdp_mod *mod);\nint\nserver_fill_rect(struct xrdp_mod *mod, int x, int y, int cx, int cy);\nint\nserver_screen_blt(struct xrdp_mod *mod, int x, int y, int cx, int cy,\n                  int srcx, int srcy);\nint\nserver_paint_rect(struct xrdp_mod *mod, int x, int y, int cx, int cy,\n                  char *data, int width, int height, int srcx, int srcy);\nint\nserver_paint_rect_bpp(struct xrdp_mod *mod, int x, int y, int cx, int cy,\n                      char *data, int width, int height, int srcx, int srcy,\n                      int bpp);\nint\nserver_composite(struct xrdp_mod *mod, int srcidx, int srcformat, int srcwidth,\n                 int srcrepeat, int *srctransform, int mskflags, int mskidx,\n                 int mskformat, int mskwidth, int mskrepeat, int op,\n                 int srcx, int srcy, int mskx, int msky,\n                 int dstx, int dsty, int width, int height, int dstformat);\nint\nserver_paint_rects(struct xrdp_mod *mod, int num_drects, short *drects,\n                   int num_crects, short *crects,\n                   char *data, int width, int height,\n                   int flags, int frame_id);\nint\nserver_set_pointer(struct xrdp_mod *mod, int x, int y,\n                   char *data, char *mask);\nint\nserver_set_pointer_ex(struct xrdp_mod *mod, int x, int y,\n                      char *data, char *mask, int bpp);\nint\nserver_set_pointer_large(struct xrdp_mod *mod, int x, int y,\n                         char *data, char *mask, int bpp,\n                         int width, int height);\nint\nserver_paint_rects_ex(struct xrdp_mod *mod, int num_drects, short *drects,\n                      int num_crects, short *crects,\n                      char *data, int left, int top,\n                      int width, int height,\n                      int flags, int frame_id,\n                      void *shmem_ptr, int shmem_bytes);\nint\nserver_palette(struct xrdp_mod *mod, int *palette);\nint\nserver_msg(struct xrdp_mod *mod, const char *msg, int code);\nint\nserver_set_clip(struct xrdp_mod *mod, int x, int y, int cx, int cy);\nint\nserver_reset_clip(struct xrdp_mod *mod);\nint\nserver_set_fgcolor(struct xrdp_mod *mod, int fgcolor);\nint\nserver_set_bgcolor(struct xrdp_mod *mod, int bgcolor);\nint\nserver_set_opcode(struct xrdp_mod *mod, int opcode);\nint\nserver_set_mixmode(struct xrdp_mod *mod, int mixmode);\nint\nserver_set_brush(struct xrdp_mod *mod, int x_origin, int y_origin,\n                 int style, char *pattern);\nint\nserver_set_pen(struct xrdp_mod *mod, int style, int width);\nint\nserver_draw_line(struct xrdp_mod *mod, int x1, int y1, int x2, int y2);\nint\nserver_add_char(struct xrdp_mod *mod, int font, int character,\n                int offset, int baseline,\n                int width, int height, char *data);\nint\nserver_draw_text(struct xrdp_mod *mod, int font,\n                 int flags, int mixmode, int clip_left, int clip_top,\n                 int clip_right, int clip_bottom,\n                 int box_left, int box_top,\n                 int box_right, int box_bottom,\n                 int x, int y, char *data, int data_len);\nint\nserver_reset(struct xrdp_mod *mod, int width, int height, int bpp);\nint\nis_channel_allowed(struct xrdp_wm *wm, int channel_id);\nint\nserver_get_channel_count(struct xrdp_mod *mod);\nint\nserver_query_channel(struct xrdp_mod *mod, int index, char *channel_name,\n                     int *channel_flags);\nint\nserver_get_channel_id(struct xrdp_mod *mod, const char *name);\nint\nserver_send_to_channel(struct xrdp_mod *mod, int channel_id,\n                       char *data, int data_len,\n                       int total_data_len, int flags);\nint\nserver_create_os_surface(struct xrdp_mod *mod, int id,\n                         int width, int height);\nint\nserver_create_os_surface_bpp(struct xrdp_mod *mod, int id,\n                             int width, int height, int bpp);\nint\nserver_switch_os_surface(struct xrdp_mod *mod, int id);\nint\nserver_delete_os_surface(struct xrdp_mod *mod, int id);\nint\nserver_paint_rect_os(struct xrdp_mod *mod, int x, int y, int cx, int cy,\n                     int id, int srcx, int srcy);\nint\nserver_set_hints(struct xrdp_mod *mod, int hints, int mask);\nint\nserver_window_new_update(struct xrdp_mod *mod, int window_id,\n                         struct rail_window_state_order *window_state,\n                         int flags);\nint\nserver_window_delete(struct xrdp_mod *mod, int window_id);\nint\nserver_window_icon(struct xrdp_mod *mod, int window_id, int cache_entry,\n                   int cache_id, struct rail_icon_info *icon_info,\n                   int flags);\nint\nserver_window_cached_icon(struct xrdp_mod *mod,\n                          int window_id, int cache_entry,\n                          int cache_id, int flags);\nint\nserver_notify_new_update(struct xrdp_mod *mod,\n                         int window_id, int notify_id,\n                         struct rail_notify_state_order *notify_state,\n                         int flags);\nint\nserver_notify_delete(struct xrdp_mod *mod, int window_id,\n                     int notify_id);\nint\nserver_monitored_desktop(struct xrdp_mod *mod,\n                         struct rail_monitored_desktop_order *mdo,\n                         int flags);\nint\nserver_add_char_alpha(struct xrdp_mod *mod, int font, int character,\n                      int offset, int baseline,\n                      int width, int height, char *data);\nint\nserver_session_info(struct xrdp_mod *mod, const char *data, int data_bytes);\n\n#endif\n", "/**\n * xrdp: A Remote Desktop Protocol server.\n *\n * Copyright (C) Jay Sorg 2004-2014\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * fonts\n */\n\n/* fv1 files are described in fontutils/README_fv1.txt */\n\n#if defined(HAVE_CONFIG_H)\n#include <config_ac.h>\n#endif\n\n#include <ctype.h>\n\n#include \"xrdp.h\"\n#include \"log.h\"\n#include \"string_calls.h\"\n\n#if 0 /* not used */\nstatic char w_char[] =\n{\n    0x00, 0x00, 0x00, // ........................\n    0x00, 0x00, 0x00, // ........................\n    0x00, 0x00, 0x00, // ........................\n    0x08, 0x20, 0x80, // ....X.....X.....X.......\n    0x08, 0x50, 0x80, // ....X....X.X....X.......\n    0x04, 0x51, 0x00, // .....X...X.X...X........\n    0x04, 0x51, 0x00, // .....X...X.X...X........\n    0x04, 0x51, 0x00, // .....X...X.X...X........\n    0x02, 0x8a, 0x00, // ......X.X...X.X.........\n    0x02, 0x8a, 0x00, // ......X.X...X.X.........\n    0x02, 0x8a, 0x00, // ......X.X...X.X.........\n    0x01, 0x04, 0x00, // .......X.....X..........\n    0x01, 0x04, 0x00, // .......X.....X..........\n    0x00, 0x00, 0x00, // ........................\n    0x00, 0x00, 0x00, // ........................\n    0x00, 0x00, 0x00, // ........................\n};\n#endif\n\n// Unicode definitions\n#define UNICODE_WHITE_SQUARE 0x25a1\n\n// First character allocated in the 'struct xrdp_font.chars' array\n#define FIRST_CHAR ' '\n\n/*****************************************************************************/\n/**\n * Parses the fv1_select configuration value to get the font to use,\n * based on the DPI of the primary monitor\n *\n * @param globals Configuration globals\n * @param dpi DPI of primary monitor. If not known, a suitable\n *            default should be passed in here.\n * @param[out] font_name Name of font to use\n * @param[in] font_name_len Length of font name buffer\n */\nstatic void\nget_font_name_from_dpi(const struct xrdp_cfg_globals *globals,\n                       unsigned int dpi,\n                       char *font_name, int font_name_len)\n{\n    int bad_selector = 0;\n\n    font_name[0] = '\\0';\n\n    const char *fv1_select = globals->fv1_select;\n    if (fv1_select == NULL || fv1_select[0] == '\\0')\n    {\n        fv1_select = DEFAULT_FV1_SELECT;\n    }\n\n    const char *p = fv1_select;\n\n    while (p != NULL)\n    {\n        /* DPI value must be next in string */\n        if (!isdigit(*p))\n        {\n            bad_selector = 1;\n            break;\n        }\n        unsigned int field_dpi = g_atoi(p);\n        if (field_dpi <= dpi)\n        {\n            /* Use this font */\n            p = g_strchr(p, ':');\n            if (p == NULL)\n            {\n                bad_selector = 1;\n            }\n            else\n            {\n                ++p;\n                const char *q = g_strchr(p, ',');\n                if (q == NULL)\n                {\n                    q = p + g_strlen(p);\n                }\n                if (q - p > (font_name_len - 1))\n                {\n                    q = p + font_name_len - 1;\n                }\n                g_memcpy(font_name, p, q - p);\n                font_name[q - p] = '\\0';\n            }\n            break;\n        }\n        else\n        {\n            p = g_strchr(p, ',');\n            if (p != NULL)\n            {\n                ++p;\n            }\n        }\n    }\n\n    if (bad_selector)\n    {\n        LOG(LOG_LEVEL_WARNING, \"Unable to parse fv1_select configuration\");\n    }\n\n    if (font_name[0] == '\\0')\n    {\n        LOG(LOG_LEVEL_WARNING, \"Loading default font \" DEFAULT_FONT_NAME);\n        g_snprintf(font_name, font_name_len, DEFAULT_FONT_NAME);\n    }\n}\n\n/*****************************************************************************/\nstruct xrdp_font *\nxrdp_font_create(struct xrdp_wm *wm, unsigned int dpi)\n{\n    struct xrdp_font *self;\n    struct stream *s;\n    int fd;\n    int b;\n    int i;\n    unsigned int char_count;\n    unsigned int datasize; // Size of glyph data on disk\n    int file_size;\n    struct xrdp_font_char *f;\n    const char *file_path;\n    char file_path_buff[256];\n    int min_descender;\n    char font_name[256];\n    const struct xrdp_cfg_globals *globals = &wm->xrdp_config->cfg_globals;\n    LOG_DEVEL(LOG_LEVEL_TRACE, \"in xrdp_font_create\");\n\n    if (dpi == 0)\n    {\n        LOG(LOG_LEVEL_WARNING, \"No DPI value is available to find login font\");\n        dpi = globals->default_dpi;\n        LOG(LOG_LEVEL_WARNING, \"Using the default_dpi of %u\", dpi);\n    }\n    get_font_name_from_dpi(globals, dpi, font_name, sizeof(font_name));\n\n    if (font_name[0] == '/')\n    {\n        /* User specified absolute path */\n        file_path = font_name;\n    }\n    else\n    {\n        g_snprintf(file_path_buff, sizeof(file_path_buff),\n                   XRDP_SHARE_PATH \"/%s\",\n                   font_name);\n        file_path = file_path_buff;\n    }\n\n    if (!g_file_exist(file_path))\n    {\n        /* Try to fall back to the default */\n        const char *default_file_path = XRDP_SHARE_PATH \"/\" DEFAULT_FONT_NAME;\n        if (g_file_exist(default_file_path))\n        {\n            LOG(LOG_LEVEL_WARNING,\n                \"xrdp_font_create: font file [%s] does not exist - using [%s]\",\n                file_path, default_file_path);\n            file_path = default_file_path;\n        }\n        else\n        {\n            LOG(LOG_LEVEL_ERROR,\n                \"xrdp_font_create: Can't load either [%s] or [%s]\",\n                file_path, default_file_path);\n            return 0;\n        }\n    }\n\n    file_size = g_file_get_size(file_path);\n\n    if (file_size < 1)\n    {\n        LOG(LOG_LEVEL_ERROR, \"xrdp_font_create: error reading font from file [%s]\",\n            file_path);\n        return 0;\n    }\n\n    self = (struct xrdp_font *)g_malloc(sizeof(struct xrdp_font), 1);\n    if (self == NULL)\n    {\n        LOG(LOG_LEVEL_ERROR, \"xrdp_font_create: \"\n            \"Can't allocate memory for font\");\n        return self;\n    }\n    self->wm = wm;\n    make_stream(s);\n    init_stream(s, file_size + 1024);\n    fd = g_file_open_ro(file_path);\n\n    if (fd < 0)\n    {\n        LOG(LOG_LEVEL_ERROR,\n            \"xrdp_font_create: Can't open %s - %s\", file_path,\n            g_get_strerror());\n        g_free(self);\n        self = NULL;\n    }\n    else\n    {\n        b = g_file_read(fd, s->data, file_size + 1024);\n        g_file_close(fd);\n\n        // Got at least a header?\n        if (b < (4 + 32 + 2 + 2 + 2 + 2 + 4))\n        {\n            LOG(LOG_LEVEL_ERROR,\n                \"xrdp_font_create: Font %s is truncated\", file_path);\n            g_free(self);\n            self = NULL;\n        }\n        else\n        {\n            s->end = s->data + b;\n            in_uint8s(s, 4);\n            in_uint8a(s, self->name, 32);\n            in_uint16_le(s, self->size);\n            in_uint16_le(s, self->style);\n            in_uint16_le(s, self->body_height);\n            in_sint16_le(s, min_descender);\n            in_uint8s(s, 4);\n            char_count = FIRST_CHAR;\n\n            while (!s_check_end(s))\n            {\n                if (!s_check_rem(s, 16))\n                {\n                    LOG(LOG_LEVEL_WARNING,\n                        \"xrdp_font_create: \"\n                        \"Can't parse header for character U+%X\", char_count);\n                    break;\n                }\n\n                if (char_count >= MAX_FONT_CHARS)\n                {\n                    LOG(LOG_LEVEL_WARNING,\n                        \"xrdp_font_create: \"\n                        \"Ignoring characters >= U+%x\", MAX_FONT_CHARS);\n                    break;\n                }\n\n                f = self->chars + char_count;\n                in_sint16_le(s, i);\n                f->width = i;\n                in_sint16_le(s, i);\n                f->height = i;\n                in_sint16_le(s, i);\n                /* Move the glyph up so there are no descenders */\n                f->baseline = i + min_descender;\n                in_sint16_le(s, i);\n                f->offset = i;\n                in_sint16_le(s, i);\n                f->incby = i;\n                in_uint8s(s, 6);\n                datasize = FONT_DATASIZE(f);\n\n                if (datasize < 0 || datasize > 512)\n                {\n                    /* shouldn't happen */\n                    LOG(LOG_LEVEL_ERROR,\n                        \"xrdp_font_create: \"\n                        \"datasize for U+%x wrong \"\n                        \"width %d, height %d, datasize %d\",\n                        char_count, f->width, f->height, datasize);\n                    break;\n                }\n\n                if (!s_check_rem(s, datasize))\n                {\n                    LOG(LOG_LEVEL_ERROR,\n                        \"xrdp_font_create: \"\n                        \"Not enough data for character U+%X\", char_count);\n                    break;\n                }\n\n                if (datasize == 0)\n                {\n                    /* Allocate a single blank pixel for the glyph, so\n                     * that it can be added to the glyph cache if required */\n                    f->width = 1;\n                    f->height = 1;\n\n                    /* GOTCHA - we need to allocate more than one byte in\n                     * memory for this glyph */\n                    f->data = (char *)g_malloc(FONT_DATASIZE(f), 1);\n                }\n                else\n                {\n                    f->data = (char *)g_malloc(datasize, 0);\n                }\n\n                if (f->data == NULL)\n                {\n                    LOG(LOG_LEVEL_ERROR,\n                        \"xrdp_font_create: \"\n                        \"Allocation error for character U+%X\", char_count);\n                    break;\n                }\n                in_uint8a(s, f->data, datasize);\n\n                ++char_count;\n            }\n\n            self->char_count = char_count;\n            if (char_count <= FIRST_CHAR)\n            {\n                /* We read no characters from the font */\n                xrdp_font_delete(self);\n                self = NULL;\n            }\n            else\n            {\n                if (self->body_height == 0)\n                {\n                    /* Older font made for xrdp v0.9.x. Synthesise this\n                     * value from the first glyph */\n                    self->body_height = -self->chars[FIRST_CHAR].baseline + 1;\n                }\n\n                // Find a default glyph\n                if (char_count > UNICODE_WHITE_SQUARE)\n                {\n                    self->default_char = &self->chars[UNICODE_WHITE_SQUARE];\n                }\n                else if (char_count > '?')\n                {\n                    self->default_char = &self->chars['?'];\n                }\n                else\n                {\n                    self->default_char = &self->chars[FIRST_CHAR];\n                }\n            }\n        }\n    }\n\n    free_stream(s);\n    /*\n      self->font_items[0].offset = -4;\n      self->font_items[0].baseline = -16;\n      self->font_items[0].width = 24;\n      self->font_items[0].height = 16;\n      self->font_items[0].data = g_malloc(3 * 16, 0);\n      g_memcpy(self->font_items[0].data, w_char, 3 * 16);\n    */\n    LOG_DEVEL(LOG_LEVEL_TRACE, \"out xrdp_font_create\");\n    return self;\n}\n\n/*****************************************************************************/\n/* free the font and all the items */\nvoid\nxrdp_font_delete(struct xrdp_font *self)\n{\n    unsigned int i;\n\n    if (self == 0)\n    {\n        return;\n    }\n\n    for (i = FIRST_CHAR; i < self->char_count; i++)\n    {\n        g_free(self->chars[i].data);\n    }\n\n    g_free(self);\n}\n\n/*****************************************************************************/\n/* compare the two font items returns 1 if they match */\nint\nxrdp_font_item_compare(struct xrdp_font_char *font1,\n                       struct xrdp_font_char *font2)\n{\n    int datasize;\n\n    if (font1 == 0)\n    {\n        return 0;\n    }\n\n    if (font2 == 0)\n    {\n        return 0;\n    }\n\n    if (font1->offset != font2->offset)\n    {\n        return 0;\n    }\n\n    if (font1->baseline != font2->baseline)\n    {\n        return 0;\n    }\n\n    if (font1->width != font2->width)\n    {\n        return 0;\n    }\n\n    if (font1->height != font2->height)\n    {\n        return 0;\n    }\n\n    datasize = FONT_DATASIZE(font1);\n\n    if (g_memcmp(font1->data, font2->data, datasize) == 0)\n    {\n        return 1;\n    }\n\n    return 0;\n}\n", "/**\n * xrdp: A Remote Desktop Protocol server.\n *\n * Copyright (C) Jay Sorg 2004-2014\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * painter, gc\n */\n\n#if defined(HAVE_CONFIG_H)\n#include <config_ac.h>\n#endif\n\n#include \"xrdp.h\"\n#include \"string_calls.h\"\n\n#if defined(XRDP_PAINTER)\n#include <painter.h> /* libpainter */\n#endif\n\n\n#if defined(XRDP_PAINTER)\n\n/*****************************************************************************/\nstatic int\nxrdp_painter_add_dirty_rect(struct xrdp_painter *self, int x, int y,\n                            int cx, int cy, struct xrdp_rect *clip_rect)\n{\n    int x2;\n    int y2;\n    struct xrdp_rect rect;\n\n    if (clip_rect != 0)\n    {\n        x2 = x + cx;\n        y2 = y + cy;\n        x = MAX(x, clip_rect->left);\n        y = MAX(y, clip_rect->top);\n        x2 = MIN(x2, clip_rect->right);\n        y2 = MIN(y2, clip_rect->bottom);\n        cx = x2 - x;\n        cy = y2 - y;\n    }\n    if (cx < 1 || cy < 1)\n    {\n        return 0;\n    }\n    rect.left = x;\n    rect.top = y;\n    rect.right = x + cx;\n    rect.bottom = y + cy;\n    xrdp_region_add_rect(self->dirty_region, &rect);\n    LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_add_dirty_rect: x %d y %d cx %d cy %d\",\n              x, y, cx, cy);\n    return 0;\n}\n\n/*****************************************************************************/\nstatic int\nxrdp_painter_send_dirty(struct xrdp_painter *self)\n{\n    int cx;\n    int cy;\n    int bpp;\n    int Bpp;\n    int index;\n    int jndex;\n    int error;\n    char *ldata;\n    char *src;\n    char *dst;\n    struct xrdp_rect rect;\n\n    LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_send_dirty:\");\n\n    bpp = self->wm->screen->bpp;\n    Bpp = (bpp + 7) / 8;\n    if (Bpp == 3)\n    {\n        Bpp = 4;\n    }\n\n    jndex = 0;\n    error = xrdp_region_get_rect(self->dirty_region, jndex, &rect);\n    while (error == 0)\n    {\n        cx = rect.right - rect.left;\n        cy = rect.bottom - rect.top;\n        ldata = (char *)g_malloc(cx * cy * Bpp, 0);\n        if (ldata == 0)\n        {\n            return 1;\n        }\n        src = self->wm->screen->data;\n        src += self->wm->screen->line_size * rect.top;\n        src += rect.left * Bpp;\n        dst = ldata;\n        for (index = 0; index < cy; index++)\n        {\n            g_memcpy(dst, src, cx * Bpp);\n            src += self->wm->screen->line_size;\n            dst += cx * Bpp;\n        }\n        LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_send_dirty: x %d y %d cx %d cy %d\",\n                  rect.left, rect.top, cx, cy);\n        libxrdp_send_bitmap(self->session, cx, cy, bpp,\n                            ldata, rect.left, rect.top, cx, cy);\n        g_free(ldata);\n\n        jndex++;\n        error = xrdp_region_get_rect(self->dirty_region, jndex, &rect);\n    }\n\n    xrdp_region_delete(self->dirty_region);\n    self->dirty_region = xrdp_region_create(self->wm);\n\n    return 0;\n}\n\n#endif\n\n/*****************************************************************************/\nstruct xrdp_painter *\nxrdp_painter_create(struct xrdp_wm *wm, struct xrdp_session *session)\n{\n    struct xrdp_painter *self;\n\n    LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_create:\");\n    self = (struct xrdp_painter *)g_malloc(sizeof(struct xrdp_painter), 1);\n    self->wm = wm;\n    self->session = session;\n    self->rop = 0xcc; /* copy will use 0xcc */\n    self->clip_children = 1;\n\n\n    if (self->session->client_info->no_orders_supported)\n    {\n#if defined(XRDP_PAINTER)\n        if (painter_create(&(self->painter)) != PT_ERROR_NONE)\n        {\n            self->painter = 0;\n            LOG_DEVEL(LOG_LEVEL_WARNING, \"xrdp_painter_create: painter_create failed\");\n        }\n        else\n        {\n            LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_create: painter_create success\");\n        }\n        self->dirty_region = xrdp_region_create(wm);\n#endif\n    }\n\n    return self;\n}\n\n/*****************************************************************************/\nvoid\nxrdp_painter_delete(struct xrdp_painter *self)\n{\n    LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_delete:\");\n    if (self == 0)\n    {\n        return;\n    }\n\n#if defined(XRDP_PAINTER)\n    painter_delete(self->painter);\n    xrdp_region_delete(self->dirty_region);\n#endif\n\n    g_free(self);\n}\n\n/*****************************************************************************/\nint\nwm_painter_set_target(struct xrdp_painter *self)\n{\n    int surface_index;\n    int index;\n    struct list *del_list;\n\n    LOG_DEVEL(LOG_LEVEL_DEBUG, \"wm_painter_set_target:\");\n\n    if (self->painter != 0)\n    {\n        return 0;\n    }\n\n    if (self->wm->target_surface->type == WND_TYPE_SCREEN)\n    {\n        if (self->wm->current_surface_index != 0xffff)\n        {\n            libxrdp_orders_send_switch_os_surface(self->session, 0xffff);\n            self->wm->current_surface_index = 0xffff;\n        }\n    }\n    else if (self->wm->target_surface->type == WND_TYPE_OFFSCREEN)\n    {\n        surface_index = self->wm->target_surface->item_index;\n\n        if (surface_index != self->wm->current_surface_index)\n        {\n            if (self->wm->target_surface->tab_stop == 0) /* tab_stop is hack */\n            {\n                del_list = self->wm->cache->xrdp_os_del_list;\n                index = list_index_of(del_list, surface_index);\n                list_remove_item(del_list, index);\n                libxrdp_orders_send_create_os_surface(self->session, surface_index,\n                                                      self->wm->target_surface->width,\n                                                      self->wm->target_surface->height,\n                                                      del_list);\n                self->wm->target_surface->tab_stop = 1;\n                list_clear(del_list);\n            }\n\n            libxrdp_orders_send_switch_os_surface(self->session, surface_index);\n            self->wm->current_surface_index = surface_index;\n        }\n    }\n    else\n    {\n        LOG(LOG_LEVEL_WARNING, \"xrdp_painter_begin_update: bad target_surface\");\n    }\n\n    return 0;\n}\n\n/*****************************************************************************/\nint\nxrdp_painter_begin_update(struct xrdp_painter *self)\n{\n    LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_begin_update:\");\n    if (self == 0)\n    {\n        return 0;\n    }\n\n    self->begin_end_level++;\n\n    if (self->painter != 0)\n    {\n        return 0;\n    }\n\n    libxrdp_orders_init(self->session);\n    wm_painter_set_target(self);\n    return 0;\n}\n\n/*****************************************************************************/\nint\nxrdp_painter_end_update(struct xrdp_painter *self)\n{\n    LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_end_update:\");\n    if (self == 0)\n    {\n        return 0;\n    }\n\n    self->begin_end_level--;\n\n    if (self->painter != 0)\n    {\n#if defined(XRDP_PAINTER)\n        if (self->begin_end_level == 0)\n        {\n            xrdp_painter_send_dirty(self);\n            return 0;\n        }\n#endif\n    }\n\n    libxrdp_orders_send(self->session);\n    return 0;\n}\n\n/*****************************************************************************/\nint\nxrdp_painter_font_needed(struct xrdp_painter *self)\n{\n    if (self->font == 0)\n    {\n        self->font = self->wm->default_font;\n    }\n\n    return 0;\n}\n\n#if 0\n/*****************************************************************************/\n/* returns boolean, true if there is something to draw */\nstatic int\nxrdp_painter_clip_adj(struct xrdp_painter *self, int *x, int *y,\n                      int *cx, int *cy)\n{\n    int dx;\n    int dy;\n\n    if (!self->use_clip)\n    {\n        return 1;\n    }\n\n    if (self->clip.left > *x)\n    {\n        dx = self->clip.left - *x;\n    }\n    else\n    {\n        dx = 0;\n    }\n\n    if (self->clip.top > *y)\n    {\n        dy = self->clip.top - *y;\n    }\n    else\n    {\n        dy = 0;\n    }\n\n    if (*x + *cx > self->clip.right)\n    {\n        *cx = *cx - ((*x + *cx) - self->clip.right);\n    }\n\n    if (*y + *cy > self->clip.bottom)\n    {\n        *cy = *cy - ((*y + *cy) - self->clip.bottom);\n    }\n\n    *cx = *cx - dx;\n    *cy = *cy - dy;\n\n    if (*cx <= 0)\n    {\n        return 0;\n    }\n\n    if (*cy <= 0)\n    {\n        return 0;\n    }\n\n    *x = *x + dx;\n    *y = *y + dy;\n    return 1;\n}\n#endif\n\n/*****************************************************************************/\nint\nxrdp_painter_set_clip(struct xrdp_painter *self,\n                      int x, int y, int cx, int cy)\n{\n    self->use_clip = &self->clip;\n    self->clip.left = x;\n    self->clip.top = y;\n    self->clip.right = x + cx;\n    self->clip.bottom = y + cy;\n    return 0;\n}\n\n/*****************************************************************************/\nint\nxrdp_painter_clr_clip(struct xrdp_painter *self)\n{\n    self->use_clip = 0;\n    return 0;\n}\n\n#if 0\n/*****************************************************************************/\nstatic int\nxrdp_painter_rop(int rop, int src, int dst)\n{\n    switch (rop & 0x0f)\n    {\n        case 0x0:\n            return 0;\n        case 0x1:\n            return ~(src | dst);\n        case 0x2:\n            return (~src) & dst;\n        case 0x3:\n            return ~src;\n        case 0x4:\n            return src & (~dst);\n        case 0x5:\n            return ~(dst);\n        case 0x6:\n            return src ^ dst;\n        case 0x7:\n            return ~(src & dst);\n        case 0x8:\n            return src & dst;\n        case 0x9:\n            return ~(src) ^ dst;\n        case 0xa:\n            return dst;\n        case 0xb:\n            return (~src) | dst;\n        case 0xc:\n            return src;\n        case 0xd:\n            return src | (~dst);\n        case 0xe:\n            return src | dst;\n        case 0xf:\n            return ~0;\n    }\n\n    return dst;\n}\n#endif\n\n/*****************************************************************************/\nint\nxrdp_painter_text_width(struct xrdp_painter *self, const char *text)\n{\n    int index;\n    int rv;\n    int len;\n    struct xrdp_font_char *font_item;\n    twchar *wstr;\n\n    LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_text_width:\");\n    xrdp_painter_font_needed(self);\n\n    if (self->font == 0)\n    {\n        return 0;\n    }\n\n    if (text == 0)\n    {\n        return 0;\n    }\n\n    rv = 0;\n    len = g_mbstowcs(0, text, 0);\n    wstr = (twchar *)g_malloc((len + 2) * sizeof(twchar), 0);\n    g_mbstowcs(wstr, text, len + 1);\n\n    for (index = 0; index < len; index++)\n    {\n        font_item = XRDP_FONT_GET_CHAR(self->font, wstr[index]);\n        rv = rv + font_item->incby;\n    }\n\n    g_free(wstr);\n    return rv;\n}\n\n/*****************************************************************************/\nunsigned int\nxrdp_painter_font_body_height(const struct xrdp_painter *self)\n{\n    return (self->font == NULL) ? 0 : self->font->body_height;\n}\n\n/*****************************************************************************/\nstatic int\nxrdp_painter_setup_brush(struct xrdp_painter *self,\n                         struct xrdp_brush *out_brush,\n                         struct xrdp_brush *in_brush)\n{\n    int cache_id;\n\n    LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_setup_brush:\");\n\n    if (self->painter != 0)\n    {\n        return 0;\n    }\n\n    g_memcpy(out_brush, in_brush, sizeof(struct xrdp_brush));\n\n    if (in_brush->style == 3)\n    {\n        if (self->session->client_info->brush_cache_code == 1)\n        {\n            cache_id = xrdp_cache_add_brush(self->wm->cache, in_brush->pattern);\n            g_memset(out_brush->pattern, 0, 8);\n            out_brush->pattern[0] = cache_id;\n            out_brush->style = 0x81;\n        }\n    }\n\n    return 0;\n}\n\n#if defined(XRDP_PAINTER)\n\n/*****************************************************************************/\nstatic int\nget_pt_format(struct xrdp_painter *self)\n{\n    switch (self->wm->screen->bpp)\n    {\n        case 8:\n            return PT_FORMAT_r3g3b2;\n        case 15:\n            return PT_FORMAT_a1r5g5b5;\n        case 16:\n            return PT_FORMAT_r5g6b5;\n    }\n    return PT_FORMAT_a8r8g8b8;\n}\n\n/*****************************************************************************/\nstatic int\nget_rgb_from_rdp_color(struct xrdp_painter *self, int rdp_color)\n{\n    if (self->wm->screen->bpp < 24)\n    {\n        return rdp_color;\n    }\n    /* well, this is really BGR2RGB */\n    return XR_RGB2BGR(rdp_color);\n}\n\n#endif\n\n/*****************************************************************************/\n/* fill in an area of the screen with one color */\nint\nxrdp_painter_fill_rect(struct xrdp_painter *self,\n                       struct xrdp_bitmap *dst,\n                       int x, int y, int cx, int cy)\n{\n    struct xrdp_rect clip_rect;\n    struct xrdp_rect draw_rect;\n    struct xrdp_rect rect;\n    struct xrdp_region *region;\n    struct xrdp_brush brush;\n    int k;\n    int dx;\n    int dy;\n    int rop;\n\n    LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_fill_rect:\");\n\n    if (self == 0)\n    {\n        return 0;\n    }\n\n    dx = 0;\n    dy = 0;\n\n    if (self->painter != 0)\n    {\n#if defined(XRDP_PAINTER)\n        struct painter_bitmap dst_pb;\n        struct xrdp_bitmap *ldst;\n        struct painter_bitmap pat;\n\n        LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_fill_rect: dst->type %d\", dst->type);\n        if (dst->type != WND_TYPE_OFFSCREEN)\n        {\n            LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_fill_rect: using painter\");\n\n            ldst = self->wm->screen;\n\n            g_memset(&dst_pb, 0, sizeof(dst_pb));\n            dst_pb.format = get_pt_format(self);\n            dst_pb.width = ldst->width;\n            dst_pb.stride_bytes = ldst->line_size;\n            dst_pb.height = ldst->height;\n            dst_pb.data = ldst->data;\n\n            LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_fill_rect: ldst->width %d ldst->height %d \"\n                      \"dst->data %p self->fg_color %d\",\n                      ldst->width, ldst->height, ldst->data, self->fg_color);\n\n            xrdp_bitmap_get_screen_clip(dst, self, &clip_rect, &dx, &dy);\n            region = xrdp_region_create(self->wm);\n            xrdp_wm_get_vis_region(self->wm, dst, x, y, cx, cy, region,\n                                   self->clip_children);\n            x += dx;\n            y += dy;\n\n            rop = self->rop;\n            switch (self->rop)\n            {\n                case 0x5a:\n                    rop = PT_ROP_DSx;\n                    break;\n                case 0xf0:\n                    rop = PT_ROP_S;\n                    break;\n                case 0xfb:\n                    rop = PT_ROP_D;\n                    break;\n                case 0xc0:\n                    rop = PT_ROP_DSa;\n                    break;\n            }\n            painter_set_rop(self->painter, rop);\n\n            if (self->mix_mode == 0)\n            {\n                painter_set_pattern_mode(self->painter, PT_PATTERN_MODE_OPAQUE);\n                painter_set_fgcolor(self->painter, get_rgb_from_rdp_color(self, self->fg_color));\n                k = 0;\n                while (xrdp_region_get_rect(region, k, &rect) == 0)\n                {\n                    if (rect_intersect(&rect, &clip_rect, &draw_rect))\n                    {\n                        painter_set_clip(self->painter,\n                                         draw_rect.left, draw_rect.top,\n                                         draw_rect.right - draw_rect.left,\n                                         draw_rect.bottom - draw_rect.top);\n                        painter_fill_rect(self->painter, &dst_pb, x, y, cx, cy);\n                        xrdp_painter_add_dirty_rect(self, x, y, cx, cy, &draw_rect);\n                    }\n                    k++;\n                }\n            }\n            else\n            {\n                painter_set_pattern_mode(self->painter, PT_PATTERN_MODE_OPAQUE);\n                painter_set_fgcolor(self->painter, get_rgb_from_rdp_color(self, self->fg_color));\n                painter_set_bgcolor(self->painter, get_rgb_from_rdp_color(self, self->bg_color));\n                painter_set_pattern_origin(self->painter, self->brush.x_origin, self->brush.y_origin);\n                g_memset(&pat, 0, sizeof(pat));\n                pat.format = PT_FORMAT_c1;\n                pat.width = 8;\n                pat.stride_bytes = 1;\n                pat.height = 8;\n                pat.data = self->brush.pattern;\n                k = 0;\n                while (xrdp_region_get_rect(region, k, &rect) == 0)\n                {\n                    if (rect_intersect(&rect, &clip_rect, &draw_rect))\n                    {\n                        painter_set_clip(self->painter,\n                                         draw_rect.left, draw_rect.top,\n                                         draw_rect.right - draw_rect.left,\n                                         draw_rect.bottom - draw_rect.top);\n                        painter_fill_pattern(self->painter, &dst_pb, &pat,\n                                             x, y, x, y, cx, cy);\n                        xrdp_painter_add_dirty_rect(self, x, y, cx, cy, &draw_rect);\n                    }\n                    k++;\n                }\n            }\n            painter_clear_clip(self->painter);\n            xrdp_region_delete(region);\n        }\n        return 0;\n#endif\n    }\n\n    /* todo data */\n\n    if (dst->type == WND_TYPE_BITMAP) /* 0 */\n    {\n        return 0;\n    }\n\n    xrdp_bitmap_get_screen_clip(dst, self, &clip_rect, &dx, &dy);\n    region = xrdp_region_create(self->wm);\n\n    if (dst->type != WND_TYPE_OFFSCREEN)\n    {\n        xrdp_wm_get_vis_region(self->wm, dst, x, y, cx, cy, region,\n                               self->clip_children);\n    }\n    else\n    {\n        xrdp_region_add_rect(region, &clip_rect);\n    }\n\n    x += dx;\n    y += dy;\n\n    if (self->mix_mode == 0 && self->rop == 0xcc)\n    {\n        k = 0;\n\n        while (xrdp_region_get_rect(region, k, &rect) == 0)\n        {\n            if (rect_intersect(&rect, &clip_rect, &draw_rect))\n            {\n                libxrdp_orders_rect(self->session, x, y, cx, cy,\n                                    self->fg_color, &draw_rect);\n            }\n\n            k++;\n        }\n    }\n    else if (self->mix_mode == 0 &&\n             ((self->rop & 0xf) == 0x0 || /* black */\n              (self->rop & 0xf) == 0xf || /* white */\n              (self->rop & 0xf) == 0x5))  /* DSTINVERT */\n    {\n        k = 0;\n\n        while (xrdp_region_get_rect(region, k, &rect) == 0)\n        {\n            if (rect_intersect(&rect, &clip_rect, &draw_rect))\n            {\n                libxrdp_orders_dest_blt(self->session, x, y, cx, cy,\n                                        self->rop, &draw_rect);\n            }\n\n            k++;\n        }\n    }\n    else\n    {\n        k = 0;\n        rop = self->rop;\n\n        /* if opcode is in the form 0x00, 0x11, 0x22, ... convert it */\n        if (((rop & 0xf0) >> 4) == (rop & 0xf))\n        {\n            switch (rop)\n            {\n                case 0x66: /* xor */\n                    rop = 0x5a;\n                    break;\n                case 0xaa: /* noop */\n                    rop = 0xfb;\n                    break;\n                case 0xcc: /* copy */\n                    rop = 0xf0;\n                    break;\n                case 0x88: /* and */\n                    rop = 0xc0;\n                    break;\n            }\n        }\n\n        xrdp_painter_setup_brush(self, &brush, &self->brush);\n\n        while (xrdp_region_get_rect(region, k, &rect) == 0)\n        {\n            if (rect_intersect(&rect, &clip_rect, &draw_rect))\n            {\n                libxrdp_orders_pat_blt(self->session, x, y, cx, cy,\n                                       rop, self->bg_color, self->fg_color,\n                                       &brush, &draw_rect);\n            }\n\n            k++;\n        }\n    }\n\n    xrdp_region_delete(region);\n    return 0;\n}\n\n/*****************************************************************************/\nint\nxrdp_painter_draw_text(struct xrdp_painter *self,\n                       struct xrdp_bitmap *dst,\n                       int x, int y, const char *text)\n{\n    int i;\n    int f;\n    int c;\n    int k;\n    int x1;\n    int y1;\n    int flags;\n    int len;\n    int index;\n    int total_width;\n    int total_height;\n    int dx;\n    int dy;\n    char *data;\n    struct xrdp_region *region;\n    struct xrdp_rect rect;\n    struct xrdp_rect clip_rect;\n    struct xrdp_rect draw_rect;\n    struct xrdp_font *font;\n    struct xrdp_font_char *font_item;\n    twchar *wstr;\n\n    LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_draw_text:\");\n\n    if (self == 0)\n    {\n        return 0;\n    }\n\n    len = g_mbstowcs(0, text, 0);\n\n    if (len < 1)\n    {\n        return 0;\n    }\n\n    /* todo data */\n\n    if (dst->type == 0)\n    {\n        return 0;\n    }\n\n    xrdp_painter_font_needed(self);\n\n    if (self->font == 0)\n    {\n        return 0;\n    }\n\n    if (self->painter != 0)\n    {\n#if defined(XRDP_PAINTER)\n        struct painter_bitmap pat;\n        struct painter_bitmap dst_pb;\n        struct xrdp_bitmap *ldst;\n\n        if (dst->type != WND_TYPE_OFFSCREEN)\n        {\n            ldst = self->wm->screen;\n            /* convert to wide char */\n            wstr = (twchar *)g_malloc((len + 2) * sizeof(twchar), 0);\n            g_mbstowcs(wstr, text, len + 1);\n            font = self->font;\n            total_width = 0;\n            total_height = 0;\n            for (index = 0; index < len; index++)\n            {\n                font_item = XRDP_FONT_GET_CHAR(font, wstr[index]);\n                k = font_item->incby;\n                total_width += k;\n                /* Use the nominal height of the font to work out the\n                 * actual height of this glyph */\n                int glyph_height =\n                    font->body_height + font_item->baseline + font_item->height;\n                total_height = MAX(total_height, glyph_height);\n            }\n            xrdp_bitmap_get_screen_clip(dst, self, &clip_rect, &dx, &dy);\n            region = xrdp_region_create(self->wm);\n            xrdp_wm_get_vis_region(self->wm, dst, x, y,\n                                   total_width, total_height,\n                                   region, self->clip_children);\n            x += dx;\n            y += dy;\n            g_memset(&dst_pb, 0, sizeof(dst_pb));\n            dst_pb.format = get_pt_format(self);\n            dst_pb.width = ldst->width;\n            dst_pb.stride_bytes = ldst->line_size;\n            dst_pb.height = ldst->height;\n            dst_pb.data = ldst->data;\n            painter_set_rop(self->painter, PT_ROP_S);\n            painter_set_pattern_origin(self->painter, 0, 0);\n            painter_set_pattern_mode(self->painter, PT_PATTERN_MODE_NORMAL);\n            painter_set_fgcolor(self->painter,\n                                get_rgb_from_rdp_color(self, self->fg_color));\n            k = 0;\n            while (xrdp_region_get_rect(region, k, &rect) == 0)\n            {\n                if (rect_intersect(&rect, &clip_rect, &draw_rect))\n                {\n                    painter_set_clip(self->painter,\n                                     draw_rect.left, draw_rect.top,\n                                     draw_rect.right - draw_rect.left,\n                                     draw_rect.bottom - draw_rect.top);\n                    for (index = 0; index < len; index++)\n                    {\n                        font_item = XRDP_FONT_GET_CHAR(font, wstr[index]);\n                        g_memset(&pat, 0, sizeof(pat));\n                        pat.format = PT_FORMAT_c1;\n                        pat.width = font_item->width;\n                        pat.stride_bytes = (font_item->width + 7) / 8;\n                        pat.height = font_item->height;\n                        pat.data = font_item->data;\n                        x1 = x + font_item->offset;\n                        y1 = y + (font->body_height + font_item->baseline);\n                        painter_fill_pattern(self->painter, &dst_pb, &pat,\n                                             0, 0, x1, y1,\n                                             font_item->width,\n                                             font_item->height);\n                        xrdp_painter_add_dirty_rect(self, x1, y1,\n                                                    font_item->width,\n                                                    font_item->height,\n                                                    &draw_rect);\n                        x += font_item->incby;\n                    }\n                }\n                k++;\n            }\n            painter_clear_clip(self->painter);\n            xrdp_region_delete(region);\n            g_free(wstr);\n        }\n        return 0;\n#endif\n    }\n\n    /* convert to wide char */\n    wstr = (twchar *)g_malloc((len + 2) * sizeof(twchar), 0);\n    g_mbstowcs(wstr, text, len + 1);\n    font = self->font;\n    f = 0;\n    k = 0;\n    total_width = 0;\n    total_height = 0;\n    data = (char *)g_malloc(len * 4, 1);\n\n    for (index = 0; index < len; index++)\n    {\n        font_item = XRDP_FONT_GET_CHAR(font, wstr[index]);\n        i = xrdp_cache_add_char(self->wm->cache, font_item);\n        f = HIWORD(i);\n        c = LOWORD(i);\n        data[index * 2] = c;\n        data[index * 2 + 1] = k;\n        k = font_item->incby;\n        total_width += k;\n        /* Use the nominal height of the font to work out the\n         * actual height of this glyph */\n        int glyph_height =\n            font->body_height + font_item->baseline + font_item->height;\n        total_height = MAX(total_height, glyph_height);\n    }\n\n    xrdp_bitmap_get_screen_clip(dst, self, &clip_rect, &dx, &dy);\n    region = xrdp_region_create(self->wm);\n\n    if (dst->type != WND_TYPE_OFFSCREEN)\n    {\n        xrdp_wm_get_vis_region(self->wm, dst, x, y, total_width, total_height,\n                               region, self->clip_children);\n    }\n    else\n    {\n        xrdp_region_add_rect(region, &clip_rect);\n    }\n\n    x += dx;\n    y += dy;\n    k = 0;\n\n    while (xrdp_region_get_rect(region, k, &rect) == 0)\n    {\n        if (rect_intersect(&rect, &clip_rect, &draw_rect))\n        {\n            x1 = x;\n            y1 = y + font->body_height;\n            flags = 0x03; /* 0x03 0x73; TEXT2_IMPLICIT_X and something else */\n            libxrdp_orders_text(self->session, f, flags, 0,\n                                self->fg_color, 0,\n                                x - 1, y - 1, x + total_width, y + total_height,\n                                0, 0, 0, 0,\n                                x1, y1, data, len * 2, &draw_rect);\n        }\n\n        k++;\n    }\n\n    xrdp_region_delete(region);\n    g_free(data);\n    g_free(wstr);\n    return 0;\n}\n\n/*****************************************************************************/\nint\nxrdp_painter_draw_text2(struct xrdp_painter *self,\n                        struct xrdp_bitmap *dst,\n                        int font, int flags, int mixmode,\n                        int clip_left, int clip_top,\n                        int clip_right, int clip_bottom,\n                        int box_left, int box_top,\n                        int box_right, int box_bottom,\n                        int x, int y, char *data, int data_len)\n{\n    struct xrdp_rect clip_rect;\n    struct xrdp_rect draw_rect;\n    struct xrdp_rect rect;\n    struct xrdp_region *region;\n    int k;\n    int dx;\n    int dy;\n\n    LOG_DEVEL(LOG_LEVEL_INFO, \"xrdp_painter_draw_text2:\");\n\n    if (self == 0)\n    {\n        return 0;\n    }\n\n    if (self->painter != 0)\n    {\n        return 0;\n    }\n\n    /* todo data */\n\n    if (dst->type == WND_TYPE_BITMAP)\n    {\n        return 0;\n    }\n\n    xrdp_bitmap_get_screen_clip(dst, self, &clip_rect, &dx, &dy);\n    region = xrdp_region_create(self->wm);\n\n    if (dst->type != WND_TYPE_OFFSCREEN)\n    {\n        if (box_right - box_left > 1)\n        {\n            xrdp_wm_get_vis_region(self->wm, dst, box_left, box_top,\n                                   box_right - box_left, box_bottom - box_top,\n                                   region, self->clip_children);\n        }\n        else\n        {\n            xrdp_wm_get_vis_region(self->wm, dst, clip_left, clip_top,\n                                   clip_right - clip_left, clip_bottom - clip_top,\n                                   region, self->clip_children);\n        }\n    }\n    else\n    {\n        xrdp_region_add_rect(region, &clip_rect);\n    }\n\n    clip_left += dx;\n    clip_top += dy;\n    clip_right += dx;\n    clip_bottom += dy;\n    box_left += dx;\n    box_top += dy;\n    box_right += dx;\n    box_bottom += dy;\n    x += dx;\n    y += dy;\n    k = 0;\n\n    while (xrdp_region_get_rect(region, k, &rect) == 0)\n    {\n        if (rect_intersect(&rect, &clip_rect, &draw_rect))\n        {\n            libxrdp_orders_text(self->session, font, flags, mixmode,\n                                self->fg_color, self->bg_color,\n                                clip_left, clip_top, clip_right, clip_bottom,\n                                box_left, box_top, box_right, box_bottom,\n                                x, y, data, data_len, &draw_rect);\n        }\n\n        k++;\n    }\n\n    xrdp_region_delete(region);\n    return 0;\n}\n\n/*****************************************************************************/\nint\nxrdp_painter_copy(struct xrdp_painter *self,\n                  struct xrdp_bitmap *src,\n                  struct xrdp_bitmap *dst,\n                  int x, int y, int cx, int cy,\n                  int srcx, int srcy)\n{\n    struct xrdp_rect clip_rect;\n    struct xrdp_rect draw_rect;\n    struct xrdp_rect rect1;\n    struct xrdp_rect rect2;\n    struct xrdp_region *region;\n    struct xrdp_bitmap *b;\n    int i;\n    int j;\n    int k;\n    int dx;\n    int dy;\n    int palette_id;\n    int bitmap_id;\n    int cache_id;\n    int cache_idx;\n    int dstx;\n    int dsty;\n    int w;\n    int h;\n    int index;\n    struct list *del_list;\n\n    LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_copy:\");\n\n    if (self == 0 || src == 0 || dst == 0)\n    {\n        return 0;\n    }\n\n    if (self->painter != 0)\n    {\n#if defined(XRDP_PAINTER)\n        struct painter_bitmap src_pb;\n        struct painter_bitmap dst_pb;\n        struct xrdp_bitmap *ldst;\n\n        LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_copy: src->type %d dst->type %d\", src->type, dst->type);\n        LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_copy: self->rop 0x%2.2x\", self->rop);\n\n        if (dst->type != WND_TYPE_OFFSCREEN)\n        {\n            LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_copy: using painter\");\n            ldst = self->wm->screen;\n\n            g_memset(&dst_pb, 0, sizeof(dst_pb));\n            dst_pb.format = get_pt_format(self);\n            dst_pb.width = ldst->width;\n            dst_pb.stride_bytes = ldst->line_size;\n            dst_pb.height = ldst->height;\n            dst_pb.data = ldst->data;\n\n            g_memset(&src_pb, 0, sizeof(src_pb));\n            src_pb.format = get_pt_format(self);\n            src_pb.width = src->width;\n            src_pb.stride_bytes = src->line_size;\n            src_pb.height = src->height;\n            src_pb.data = src->data;\n\n            xrdp_bitmap_get_screen_clip(dst, self, &clip_rect, &dx, &dy);\n            region = xrdp_region_create(self->wm);\n            xrdp_wm_get_vis_region(self->wm, dst, x, y, cx, cy, region,\n                                   self->clip_children);\n            x += dx;\n            y += dy;\n            k = 0;\n\n            painter_set_rop(self->painter, self->rop);\n            while (xrdp_region_get_rect(region, k, &rect1) == 0)\n            {\n                if (rect_intersect(&rect1, &clip_rect, &draw_rect))\n                {\n                    painter_set_clip(self->painter,\n                                     draw_rect.left, draw_rect.top,\n                                     draw_rect.right - draw_rect.left,\n                                     draw_rect.bottom - draw_rect.top);\n                    LOG_DEVEL(LOG_LEVEL_DEBUG, \"  x %d y %d cx %d cy %d srcx %d srcy %d\",\n                              x, y, cx, cy, srcx, srcy);\n                    painter_copy(self->painter, &dst_pb, x, y, cx, cy,\n                                 &src_pb, srcx, srcy);\n                    xrdp_painter_add_dirty_rect(self, x, y, cx, cy,\n                                                &draw_rect);\n                }\n                k++;\n            }\n            painter_clear_clip(self->painter);\n            xrdp_region_delete(region);\n        }\n\n        return 0;\n#endif\n    }\n\n    /* todo data */\n\n    if (dst->type == WND_TYPE_BITMAP)\n    {\n        return 0;\n    }\n\n    if (src->type == WND_TYPE_SCREEN)\n    {\n        xrdp_bitmap_get_screen_clip(dst, self, &clip_rect, &dx, &dy);\n        region = xrdp_region_create(self->wm);\n\n        if (dst->type != WND_TYPE_OFFSCREEN)\n        {\n            xrdp_wm_get_vis_region(self->wm, dst, x, y, cx, cy,\n                                   region, self->clip_children);\n        }\n        else\n        {\n            xrdp_region_add_rect(region, &clip_rect);\n        }\n\n        x += dx;\n        y += dy;\n        srcx += dx;\n        srcy += dy;\n        k = 0;\n\n        while (xrdp_region_get_rect(region, k, &rect1) == 0)\n        {\n            if (rect_intersect(&rect1, &clip_rect, &draw_rect))\n            {\n                libxrdp_orders_screen_blt(self->session, x, y, cx, cy,\n                                          srcx, srcy, self->rop, &draw_rect);\n            }\n\n            k++;\n        }\n\n        xrdp_region_delete(region);\n    }\n    else if (src->type == WND_TYPE_OFFSCREEN)\n    {\n        LOG(LOG_LEVEL_DEBUG, \"xrdp_painter_copy: todo\");\n\n        xrdp_bitmap_get_screen_clip(dst, self, &clip_rect, &dx, &dy);\n        region = xrdp_region_create(self->wm);\n\n        if (dst->type != WND_TYPE_OFFSCREEN)\n        {\n            LOG(LOG_LEVEL_DEBUG, \"off screen to screen\");\n            xrdp_wm_get_vis_region(self->wm, dst, x, y, cx, cy,\n                                   region, self->clip_children);\n        }\n        else\n        {\n            LOG(LOG_LEVEL_DEBUG, \"off screen to off screen\");\n            xrdp_region_add_rect(region, &clip_rect);\n        }\n\n        x += dx;\n        y += dy;\n\n        palette_id = 0;\n        cache_id = 255; // todo\n        cache_idx = src->item_index; // todo\n\n        if (src->tab_stop == 0)\n        {\n            LOG(LOG_LEVEL_WARNING, \"xrdp_painter_copy: warning src not created\");\n            del_list = self->wm->cache->xrdp_os_del_list;\n            index = list_index_of(del_list, cache_idx);\n            list_remove_item(del_list, index);\n            libxrdp_orders_send_create_os_surface(self->session,\n                                                  cache_idx,\n                                                  src->width,\n                                                  src->height,\n                                                  del_list);\n            src->tab_stop = 1;\n            list_clear(del_list);\n        }\n\n\n        k = 0;\n\n        while (xrdp_region_get_rect(region, k, &rect1) == 0)\n        {\n            if (rect_intersect(&rect1, &clip_rect, &rect2))\n            {\n                MAKERECT(rect1, x, y, cx, cy);\n\n                if (rect_intersect(&rect2, &rect1, &draw_rect))\n                {\n                    libxrdp_orders_mem_blt(self->session, cache_id, palette_id,\n                                           x, y, cx, cy, self->rop, srcx, srcy,\n                                           cache_idx, &draw_rect);\n                }\n            }\n\n            k++;\n        }\n\n        xrdp_region_delete(region);\n    }\n    else if (src->data != 0)\n        /* todo, the non bitmap cache part is gone, it should be put back */\n    {\n        xrdp_bitmap_get_screen_clip(dst, self, &clip_rect, &dx, &dy);\n        region = xrdp_region_create(self->wm);\n\n        if (dst->type != WND_TYPE_OFFSCREEN)\n        {\n            xrdp_wm_get_vis_region(self->wm, dst, x, y, cx, cy,\n                                   region, self->clip_children);\n        }\n        else\n        {\n            xrdp_region_add_rect(region, &clip_rect);\n        }\n\n        x += dx;\n        y += dy;\n        palette_id = 0;\n        j = srcy;\n\n        while (j < (srcy + cy))\n        {\n            i = srcx;\n\n            while (i < (srcx + cx))\n            {\n                w = MIN(64, ((srcx + cx) - i));\n                h = MIN(64, ((srcy + cy) - j));\n                b = xrdp_bitmap_create(w, h, src->bpp, 0, self->wm);\n#if 1\n                xrdp_bitmap_copy_box_with_crc(src, b, i, j, w, h);\n#else\n                xrdp_bitmap_copy_box(src, b, i, j, w, h);\n                xrdp_bitmap_hash_crc(b);\n#endif\n                bitmap_id = xrdp_cache_add_bitmap(self->wm->cache, b, self->wm->hints);\n                cache_id = HIWORD(bitmap_id);\n                cache_idx = LOWORD(bitmap_id);\n                dstx = (x + i) - srcx;\n                dsty = (y + j) - srcy;\n                k = 0;\n\n                while (xrdp_region_get_rect(region, k, &rect1) == 0)\n                {\n                    if (rect_intersect(&rect1, &clip_rect, &rect2))\n                    {\n                        MAKERECT(rect1, dstx, dsty, w, h);\n\n                        if (rect_intersect(&rect2, &rect1, &draw_rect))\n                        {\n                            libxrdp_orders_mem_blt(self->session, cache_id, palette_id,\n                                                   dstx, dsty, w, h, self->rop, 0, 0,\n                                                   cache_idx, &draw_rect);\n                        }\n                    }\n\n                    k++;\n                }\n\n                i += 64;\n            }\n\n            j += 64;\n        }\n\n        xrdp_region_delete(region);\n    }\n\n    return 0;\n}\n\n/*****************************************************************************/\nint\nxrdp_painter_composite(struct xrdp_painter *self,\n                       struct xrdp_bitmap *src,\n                       int srcformat,\n                       int srcwidth,\n                       int srcrepeat,\n                       struct xrdp_bitmap *dst,\n                       int *srctransform,\n                       int mskflags,\n                       struct xrdp_bitmap *msk,\n                       int mskformat, int mskwidth, int mskrepeat, int op,\n                       int srcx, int srcy, int mskx, int msky,\n                       int dstx, int dsty, int width, int height, int dstformat)\n{\n    struct xrdp_rect clip_rect;\n    struct xrdp_rect draw_rect;\n    struct xrdp_rect rect1;\n    struct xrdp_rect rect2;\n    struct xrdp_region *region;\n    int k;\n    int dx;\n    int dy;\n    int cache_srcidx;\n    int cache_mskidx;\n\n    LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_composite:\");\n\n    if (self == 0 || src == 0 || dst == 0)\n    {\n        return 0;\n    }\n\n    if (self->painter != 0)\n    {\n        return 0;\n    }\n\n    /* todo data */\n\n    if (dst->type == WND_TYPE_BITMAP)\n    {\n        return 0;\n    }\n\n    if (src->type == WND_TYPE_OFFSCREEN)\n    {\n        xrdp_bitmap_get_screen_clip(dst, self, &clip_rect, &dx, &dy);\n        region = xrdp_region_create(self->wm);\n        xrdp_region_add_rect(region, &clip_rect);\n        dstx += dx;\n        dsty += dy;\n\n        cache_srcidx = src->item_index;\n        cache_mskidx = -1;\n        if (mskflags & 1)\n        {\n            if (msk != 0)\n            {\n                cache_mskidx = msk->item_index; // todo\n            }\n        }\n\n        k = 0;\n        while (xrdp_region_get_rect(region, k, &rect1) == 0)\n        {\n            if (rect_intersect(&rect1, &clip_rect, &rect2))\n            {\n                MAKERECT(rect1, dstx, dsty, width, height);\n                if (rect_intersect(&rect2, &rect1, &draw_rect))\n                {\n                    libxrdp_orders_composite_blt(self->session, cache_srcidx, srcformat, srcwidth,\n                                                 srcrepeat, srctransform, mskflags, cache_mskidx,\n                                                 mskformat, mskwidth, mskrepeat, op, srcx, srcy,\n                                                 mskx, msky, dstx, dsty, width, height, dstformat,\n                                                 &draw_rect);\n                }\n            }\n            k++;\n        }\n        xrdp_region_delete(region);\n    }\n    return 0;\n}\n\n/*****************************************************************************/\nint\nxrdp_painter_line(struct xrdp_painter *self,\n                  struct xrdp_bitmap *dst,\n                  int x1, int y1, int x2, int y2)\n{\n    struct xrdp_rect clip_rect;\n    struct xrdp_rect draw_rect;\n    struct xrdp_rect rect;\n    struct xrdp_region *region;\n    int k;\n    int dx;\n    int dy;\n    int rop;\n\n    LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_line:\");\n    if (self == 0)\n    {\n        return 0;\n    }\n    if (self->painter != 0)\n    {\n#if defined(XRDP_PAINTER)\n        int x;\n        int y;\n        int cx;\n        int cy;\n        struct painter_bitmap dst_pb;\n        struct xrdp_bitmap *ldst;\n\n        LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_line: dst->type %d\", dst->type);\n        LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_line: self->rop 0x%2.2x\", self->rop);\n\n        if (dst->type != WND_TYPE_OFFSCREEN)\n        {\n            LOG_DEVEL(LOG_LEVEL_DEBUG, \"xrdp_painter_line: using painter\");\n            ldst = self->wm->screen;\n\n            g_memset(&dst_pb, 0, sizeof(dst_pb));\n            dst_pb.format = get_pt_format(self);\n            dst_pb.width = ldst->width;\n            dst_pb.stride_bytes = ldst->line_size;\n            dst_pb.height = ldst->height;\n            dst_pb.data = ldst->data;\n\n            xrdp_bitmap_get_screen_clip(dst, self, &clip_rect, &dx, &dy);\n            region = xrdp_region_create(self->wm);\n            x = MIN(x1, x2);\n            y = MIN(y1, y2);\n            cx = g_abs(x1 - x2) + 1;\n            cy = g_abs(y1 - y2) + 1;\n            xrdp_wm_get_vis_region(self->wm, dst, x, y, cx, cy,\n                                   region, self->clip_children);\n            x1 += dx;\n            y1 += dy;\n            x2 += dx;\n            y2 += dy;\n            k = 0;\n            rop = self->rop;\n\n            painter_set_rop(self->painter, rop);\n            painter_set_fgcolor(self->painter, self->pen.color);\n            while (xrdp_region_get_rect(region, k, &rect) == 0)\n            {\n                if (rect_intersect(&rect, &clip_rect, &draw_rect))\n                {\n                    painter_set_clip(self->painter,\n                                     draw_rect.left, draw_rect.top,\n                                     draw_rect.right - draw_rect.left,\n                                     draw_rect.bottom - draw_rect.top);\n                    painter_line(self->painter, &dst_pb, x1, y1, x2, y2,\n                                 self->pen.width, 0);\n                    xrdp_painter_add_dirty_rect(self, x, y, cx, cy,\n                                                &draw_rect);\n                }\n                k++;\n            }\n            painter_clear_clip(self->painter);\n            xrdp_region_delete(region);\n        }\n\n        return 0;\n#endif\n    }\n\n    /* todo data */\n\n    if (dst->type == WND_TYPE_BITMAP)\n    {\n        return 0;\n    }\n\n    xrdp_bitmap_get_screen_clip(dst, self, &clip_rect, &dx, &dy);\n    region = xrdp_region_create(self->wm);\n\n    if (dst->type != WND_TYPE_OFFSCREEN)\n    {\n        xrdp_wm_get_vis_region(self->wm, dst, MIN(x1, x2), MIN(y1, y2),\n                               g_abs(x1 - x2) + 1, g_abs(y1 - y2) + 1,\n                               region, self->clip_children);\n    }\n    else\n    {\n        xrdp_region_add_rect(region, &clip_rect);\n    }\n\n    x1 += dx;\n    y1 += dy;\n    x2 += dx;\n    y2 += dy;\n    k = 0;\n    rop = self->rop;\n\n    if (rop < 0x01 || rop > 0x10)\n    {\n        rop = (rop & 0xf) + 1;\n    }\n\n    while (xrdp_region_get_rect(region, k, &rect) == 0)\n    {\n        if (rect_intersect(&rect, &clip_rect, &draw_rect))\n        {\n            libxrdp_orders_line(self->session, 1, x1, y1, x2, y2,\n                                rop, self->bg_color,\n                                &self->pen, &draw_rect);\n        }\n\n        k++;\n    }\n\n    xrdp_region_delete(region);\n    return 0;\n}\n", "/**\n * xrdp: A Remote Desktop Protocol server.\n *\n * Copyright (C) Jay Sorg 2004-2014\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * types\n */\n\n#ifndef _XRDP_TYPES_H_\n#define _XRDP_TYPES_H_\n\n#define DEFAULT_STRING_LEN 255\n#define LOG_WINDOW_CHAR_PER_LINE 60\n\n#include \"xrdp_rail.h\"\n#include \"xrdp_constants.h\"\n#include \"fifo.h\"\n#include \"guid.h\"\n\n#define MAX_NR_CHANNELS 16\n#define MAX_CHANNEL_NAME 16\n\n/* Code values used in 'xrdp_mm->code=' settings */\n#define XVNC_SESSION_CODE 0\n#define XORG_SESSION_CODE 20\n\n/* To check whether touch events has been implemented on session type 'mm' */\n#define XRDP_MM_IMPLEMENTS_TOUCH(mm) ((mm)->code != XVNC_SESSION_CODE)\n\nstruct source_info;\nstruct list16;\n\n/* lib */\nstruct xrdp_mod\n{\n    int size; /* size of this struct */\n    int version; /* internal version */\n    /* client functions */\n    int (*mod_start)(struct xrdp_mod *v, int w, int h, int bpp);\n    int (*mod_connect)(struct xrdp_mod *v);\n    int (*mod_event)(struct xrdp_mod *v, int msg, long param1, long param2,\n                     long param3, long param4);\n    int (*mod_signal)(struct xrdp_mod *v);\n    int (*mod_end)(struct xrdp_mod *v);\n    int (*mod_set_param)(struct xrdp_mod *v, const char *name, const char *value);\n    int (*mod_session_change)(struct xrdp_mod *v, int, int);\n    int (*mod_get_wait_objs)(struct xrdp_mod *v, tbus *read_objs, int *rcount,\n                             tbus *write_objs, int *wcount, int *timeout);\n    int (*mod_check_wait_objs)(struct xrdp_mod *v);\n    int (*mod_frame_ack)(struct xrdp_mod *v, int flags, int frame_id);\n    int (*mod_suppress_output)(struct xrdp_mod *v, int suppress,\n                               int left, int top, int right, int bottom);\n    int (*mod_server_monitor_resize)(struct xrdp_mod *v,\n                                     int width, int height);\n    int (*mod_server_monitor_full_invalidate)(struct xrdp_mod *v,\n            int width, int height);\n    int (*mod_server_version_message)(struct xrdp_mod *v);\n    tintptr mod_dumby[100 - 14]; /* align, 100 minus the number of mod\n                                  functions above */\n    /* server functions */\n    int (*server_begin_update)(struct xrdp_mod *v);\n    int (*server_end_update)(struct xrdp_mod *v);\n    int (*server_fill_rect)(struct xrdp_mod *v, int x, int y, int cx, int cy);\n    int (*server_screen_blt)(struct xrdp_mod *v, int x, int y, int cx, int cy,\n                             int srcx, int srcy);\n    int (*server_paint_rect)(struct xrdp_mod *v, int x, int y, int cx, int cy,\n                             char *data, int width, int height,\n                             int srcx, int srcy);\n    int (*server_set_pointer)(struct xrdp_mod *v, int x, int y,\n                              char *data, char *mask);\n    int (*server_palette)(struct xrdp_mod *v, int *palette);\n    int (*server_msg)(struct xrdp_mod *v, const char *msg, int code);\n    /* This one can be assigned directly into the is_term member of\n     * a struct trans */\n    int (*server_is_term)(void);\n    int (*server_set_clip)(struct xrdp_mod *v, int x, int y, int cx, int cy);\n    int (*server_reset_clip)(struct xrdp_mod *v);\n    int (*server_set_fgcolor)(struct xrdp_mod *v, int fgcolor);\n    int (*server_set_bgcolor)(struct xrdp_mod *v, int bgcolor);\n    int (*server_set_opcode)(struct xrdp_mod *v, int opcode);\n    int (*server_set_mixmode)(struct xrdp_mod *v, int mixmode);\n    int (*server_set_brush)(struct xrdp_mod *v, int x_origin, int y_origin,\n                            int style, char *pattern);\n    int (*server_set_pen)(struct xrdp_mod *v, int style,\n                          int width);\n    int (*server_draw_line)(struct xrdp_mod *v, int x1, int y1, int x2, int y2);\n    int (*server_add_char)(struct xrdp_mod *v, int font, int character,\n                           int offset, int baseline,\n                           int width, int height, char *data);\n    int (*server_draw_text)(struct xrdp_mod *v, int font,\n                            int flags, int mixmode, int clip_left, int clip_top,\n                            int clip_right, int clip_bottom,\n                            int box_left, int box_top,\n                            int box_right, int box_bottom,\n                            int x, int y, char *data, int data_len);\n    int (*server_reset)(struct xrdp_mod *v, int width, int height, int bpp);\n    int (*server_get_channel_count)(struct xrdp_mod *v);\n    int (*server_query_channel)(struct xrdp_mod *v, int index,\n                                char *channel_name,\n                                int *channel_flags);\n    int (*server_get_channel_id)(struct xrdp_mod *v, const char *name);\n    int (*server_send_to_channel)(struct xrdp_mod *v, int channel_id,\n                                  char *data, int data_len,\n                                  int total_data_len, int flags);\n    int (*server_bell_trigger)(struct xrdp_mod *v);\n    int (*server_chansrv_in_use)(struct xrdp_mod *v);\n    /* off screen bitmaps */\n    int (*server_create_os_surface)(struct xrdp_mod *v, int rdpindex,\n                                    int width, int height);\n    int (*server_switch_os_surface)(struct xrdp_mod *v, int rdpindex);\n    int (*server_delete_os_surface)(struct xrdp_mod *v, int rdpindex);\n    int (*server_paint_rect_os)(struct xrdp_mod *mod, int x, int y,\n                                int cx, int cy,\n                                int rdpindex, int srcx, int srcy);\n    int (*server_set_hints)(struct xrdp_mod *mod, int hints, int mask);\n    /* rail */\n    int (*server_window_new_update)(struct xrdp_mod *mod, int window_id,\n                                    struct rail_window_state_order *window_state,\n                                    int flags);\n    int (*server_window_delete)(struct xrdp_mod *mod, int window_id);\n    int (*server_window_icon)(struct xrdp_mod *mod,\n                              int window_id, int cache_entry, int cache_id,\n                              struct rail_icon_info *icon_info,\n                              int flags);\n    int (*server_window_cached_icon)(struct xrdp_mod *mod,\n                                     int window_id, int cache_entry,\n                                     int cache_id, int flags);\n    int (*server_notify_new_update)(struct xrdp_mod *mod,\n                                    int window_id, int notify_id,\n                                    struct rail_notify_state_order *notify_state,\n                                    int flags);\n    int (*server_notify_delete)(struct xrdp_mod *mod, int window_id,\n                                int notify_id);\n    int (*server_monitored_desktop)(struct xrdp_mod *mod,\n                                    struct rail_monitored_desktop_order *mdo,\n                                    int flags);\n    int (*server_set_pointer_ex)(struct xrdp_mod *v, int x, int y, char *data,\n                                 char *mask, int bpp);\n    int (*server_add_char_alpha)(struct xrdp_mod *mod, int font, int character,\n                                 int offset, int baseline,\n                                 int width, int height, char *data);\n\n    int (*server_create_os_surface_bpp)(struct xrdp_mod *v, int rdpindex,\n                                        int width, int height, int bpp);\n    int (*server_paint_rect_bpp)(struct xrdp_mod *v, int x, int y, int cx, int cy,\n                                 char *data, int width, int height,\n                                 int srcx, int srcy, int bpp);\n    int (*server_composite)(struct xrdp_mod *v, int srcidx, int srcformat,\n                            int srcwidth, int srcrepeat, int *srctransform,\n                            int mskflags, int mskidx, int mskformat,\n                            int mskwidth, int mskrepeat, int op,\n                            int srcx, int srcy, int mskx, int msky,\n                            int dstx, int dsty, int width, int height,\n                            int dstformat);\n    int (*server_paint_rects)(struct xrdp_mod *v,\n                              int num_drects, short *drects,\n                              int num_crects, short *crects,\n                              char *data, int width, int height,\n                              int flags, int frame_id);\n    int (*server_session_info)(struct xrdp_mod *v, const char *data,\n                               int data_bytes);\n    int (*server_set_pointer_large)(struct xrdp_mod *v, int x, int y,\n                                    char *data, char *mask, int bpp,\n                                    int width, int height);\n    int (*server_paint_rects_ex)(struct xrdp_mod *v,\n                                 int num_drects, short *drects,\n                                 int num_crects, short *crects,\n                                 char *data, int left, int top,\n                                 int width, int height,\n                                 int flags, int frame_id,\n                                 void *shmem_ptr, int shmem_bytes);\n    tintptr server_dumby[100 - 48]; /* align, 100 minus the number of server\n                                     functions above */\n    /* common */\n    tintptr handle; /* pointer to self as int */\n    tintptr wm; /* struct xrdp_wm* */\n    tintptr painter;\n    struct source_info *si;\n};\n\n/**\n * Transform to apply to loaded images\n */\nenum xrdp_bitmap_load_transform\n{\n    XBLT_NONE = 0,\n    XBLT_SCALE,\n    XBLT_ZOOM\n};\n\n/* header for bmp file */\nstruct xrdp_bmp_header\n{\n    int size;\n    int image_width;\n    int image_height;\n    short planes;\n    short bit_count;\n    int compression;\n    int image_size;\n    int x_pels_per_meter;\n    int y_pels_per_meter;\n    int clr_used;\n    int clr_important;\n};\n\nstruct xrdp_palette_item\n{\n    int stamp;\n    int palette[256];\n};\n\nstruct xrdp_bitmap_item\n{\n    int stamp;\n    int lru_index;\n    struct xrdp_bitmap *bitmap;\n};\n\nstruct xrdp_lru_item\n{\n    int next;\n    int prev;\n};\n\nstruct xrdp_os_bitmap_item\n{\n    int id;\n    struct xrdp_bitmap *bitmap;\n};\n\nstruct xrdp_char_item\n{\n    int stamp;\n    struct xrdp_font_char font_item;\n};\n\nstruct xrdp_pointer_item\n{\n    int stamp;\n    int x; /* hotspot */\n    int y;\n    int pad0;\n    char data[96 * 96 * 4];\n    char mask[96 * 96 / 8];\n    int bpp;\n    int width;\n    int height;\n    int pad1;\n};\n\nstruct xrdp_brush_item\n{\n    int stamp;\n    /* expand this to a structure to handle more complicated brushes\n       for now it's 8x8 1bpp brushes only */\n    char pattern[8];\n};\n\n/* moved to xrdp_constants.h\n#define XRDP_BITMAP_CACHE_ENTRIES 2048 */\n\n/* difference caches */\nstruct xrdp_cache\n{\n    struct xrdp_wm *wm; /* owner */\n    struct xrdp_session *session;\n    /* palette */\n    int palette_stamp;\n    struct xrdp_palette_item palette_items[6];\n    /* bitmap */\n    int bitmap_stamp;\n    struct xrdp_bitmap_item bitmap_items[XRDP_MAX_BITMAP_CACHE_ID]\n        [XRDP_MAX_BITMAP_CACHE_IDX];\n\n    /* lru optimize */\n    struct xrdp_lru_item bitmap_lrus[XRDP_MAX_BITMAP_CACHE_ID]\n        [XRDP_MAX_BITMAP_CACHE_IDX];\n    int lru_head[XRDP_MAX_BITMAP_CACHE_ID];\n    int lru_tail[XRDP_MAX_BITMAP_CACHE_ID];\n    int lru_reset[XRDP_MAX_BITMAP_CACHE_ID];\n\n    /* crc optimize */\n    struct list16 crc16[XRDP_MAX_BITMAP_CACHE_ID][64 * 1024];\n\n    int use_bitmap_comp;\n    int cache1_entries;\n    int cache1_size;\n    int cache2_entries;\n    int cache2_size;\n    int cache3_entries;\n    int cache3_size;\n    int bitmap_cache_persist_enable;\n    int bitmap_cache_version;\n    /* font */\n    int char_stamp;\n    struct xrdp_char_item char_items[12][256];\n    /* pointer */\n    int pointer_stamp;\n    struct xrdp_pointer_item pointer_items[32];\n    int pointer_cache_entries;\n    int brush_stamp;\n    struct xrdp_brush_item brush_items[64];\n    struct xrdp_os_bitmap_item os_bitmap_items[2000];\n    struct list *xrdp_os_del_list;\n};\n\n/* defined later */\nstruct xrdp_enc_data;\n\n/**\n * Stages we go through connecting to the session\n */\nenum mm_connect_state\n{\n    MMCS_CONNECT_TO_SESMAN,\n    MMCS_GATEWAY_LOGIN,\n    MMCS_SESSION_LOGIN,\n    MMCS_CREATE_SESSION,\n    MMCS_CONNECT_TO_SESSION,\n    MMCS_CONNECT_TO_CHANSRV,\n    MMCS_DONE\n};\n\nenum display_resize_state\n{\n    WMRZ_ENCODER_DELETE = 0,\n    WMRZ_EGFX_DELETE_SURFACE,\n    WMRZ_EGFX_CONN_CLOSE,\n    WMRZ_EGFX_CONN_CLOSING,\n    WMRZ_EGFX_CONN_CLOSED,\n    WRMZ_EGFX_DELETE,\n    WMRZ_SERVER_MONITOR_RESIZE,\n    WMRZ_SERVER_VERSION_MESSAGE,\n    WMRZ_XRDP_CORE_RESIZE,\n    WMRZ_EGFX_INITIALIZE,\n    WMRZ_EGFX_INITALIZING,\n    WMRZ_EGFX_INITIALIZED,\n    WMRZ_ENCODER_CREATE,\n    WMRZ_SERVER_INVALIDATE,\n    WMRZ_COMPLETE,\n    WMRZ_ERROR\n};\n\n#define XRDP_DISPLAY_RESIZE_STATE_TO_STR(status) \\\n    ((status) == WMRZ_ENCODER_DELETE ? \"WMRZ_ENCODER_DELETE\" : \\\n     (status) == WMRZ_EGFX_DELETE_SURFACE ? \"WMRZ_EGFX_DELETE_SURFACE\" : \\\n     (status) == WMRZ_EGFX_CONN_CLOSE ? \"WMRZ_EGFX_CONN_CLOSE\" : \\\n     (status) == WMRZ_EGFX_CONN_CLOSING ? \"WMRZ_EGFX_CONN_CLOSING\" : \\\n     (status) == WMRZ_EGFX_CONN_CLOSED ? \"WMRZ_EGFX_CONN_CLOSED\" : \\\n     (status) == WRMZ_EGFX_DELETE ? \"WMRZ_EGFX_DELETE\" : \\\n     (status) == WMRZ_SERVER_MONITOR_RESIZE ? \"WMRZ_SERVER_MONITOR_RESIZE\" : \\\n     (status) == WMRZ_SERVER_VERSION_MESSAGE ? \"WMRZ_SERVER_VERSION_MESSAGE\" : \\\n     (status) == WMRZ_XRDP_CORE_RESIZE ? \"WMRZ_XRDP_CORE_RESIZE\" : \\\n     (status) == WMRZ_EGFX_INITIALIZE ? \"WMRZ_EGFX_INITIALIZE\" : \\\n     (status) == WMRZ_EGFX_INITALIZING ? \"WMRZ_EGFX_INITALIZING\" : \\\n     (status) == WMRZ_EGFX_INITIALIZED ? \"WMRZ_EGFX_INITIALIZED\" : \\\n     (status) == WMRZ_ENCODER_CREATE ? \"WMRZ_ENCODER_CREATE\" : \\\n     (status) == WMRZ_SERVER_INVALIDATE ? \"WMRZ_SERVER_INVALIDATE\" : \\\n     (status) == WMRZ_COMPLETE ? \"WMRZ_COMPLETE\" : \\\n     (status) == WMRZ_ERROR ? \"WMRZ_ERROR\" : \\\n     \"unknown\" \\\n    )\n\nstruct xrdp_mm\n{\n    struct xrdp_wm *wm; /* owner */\n    enum mm_connect_state connect_state; /* State of connection */\n    int mmcs_expecting_msg; /* Connect state machine is expecting\n                               a message from sesman */\n    /* Other processes we connect to */\n    int use_sesman; /* true if this is a sesman session */\n    int use_gw_login; /* True if we're to login using  a gateway */\n    int use_chansrv; /* true if chansrvport is set in xrdp.ini or using sesman */\n    struct trans *sesman_trans; /* connection to sesman */\n    struct trans *chan_trans; /* connection to chansrv */\n\n    /* We can't delete transports while we're in a callback for that\n     * transport, as this causes trans.c to reference undefined memory.\n     * These flags mark transports as needing to be deleted when\n     * we are definitely not in a transport callback */\n    int delete_sesman_trans;\n\n    struct list *login_names;\n    struct list *login_values;\n    /* mod vars */\n    long mod_handle; /* returned from g_load_library */\n    struct xrdp_mod *(*mod_init)(void);\n    int (*mod_exit)(struct xrdp_mod *);\n    struct xrdp_mod *mod; /* module interface */\n    int display; /* 10 for :10.0, 11 for :11.0, etc */\n    struct guid guid; /* GUID for the session, or all zeros  */\n    int code; /* 0=Xvnc session, 20=xorg driver mode */\n    struct xrdp_encoder *encoder;\n    int cs2xr_cid_map[256];\n    int xr2cr_cid_map[256];\n    int dynamic_monitor_chanid;\n    struct xrdp_egfx *egfx;\n    int egfx_up;\n\n    /* Resize on-the-fly control */\n    struct display_control_monitor_layout_data *resize_data;\n    struct list *resize_queue;\n    tbus resize_ready;\n};\n\nstruct xrdp_key_info\n{\n    int sym;\n    int chr;\n};\n\nstruct xrdp_keymap\n{\n    struct xrdp_key_info keys_noshift[256];\n    struct xrdp_key_info keys_shift[256];\n    struct xrdp_key_info keys_altgr[256];\n    struct xrdp_key_info keys_shiftaltgr[256];\n    struct xrdp_key_info keys_capslock[256];\n    struct xrdp_key_info keys_capslockaltgr[256];\n    struct xrdp_key_info keys_shiftcapslock[256];\n    struct xrdp_key_info keys_shiftcapslockaltgr[256];\n};\n\n/* the window manager */\n\n/***\n * Window manager login mode states\n *\n * Use with xrdp_wm_set_login_state()\n */\nenum wm_login_state\n{\n    /**\n     * Place the window manager in this state to reset it\n     */\n    WMLS_RESET = 0,\n    /**\n     * In this state, the window manager is waiting for the user to fill\n     * in the login box\n     */\n    WMLS_USER_PROMPT,\n    /**\n     * Place the window manager in this state to request xrdp connects to\n     * the X server, sesman, chansrv etc\n     */\n    WMLS_START_CONNECT,\n    /**\n     * In this state, the window manager is making required connections\n     */\n    WMLS_CONNECT_IN_PROGRESS,\n    /**\n     * Place the window manager in this state to request it finishes.\n     */\n    WMLS_CLEANUP,\n    /**\n     * In this state, the window manager is inactive\n     */\n    WMLS_INACTIVE\n};\n\nstruct xrdp_wm\n{\n    struct xrdp_process *pro_layer; /* owner */\n    struct xrdp_bitmap *screen;\n    struct xrdp_session *session;\n    struct xrdp_painter *painter;\n    struct xrdp_cache *cache;\n    int palette[256];\n    struct xrdp_bitmap *login_window;\n    /* generic colors */\n    int black;\n    int grey;\n    int dark_grey;\n    int blue;\n    int dark_blue;\n    int white;\n    int red;\n    int green;\n    int background;\n    /* dragging info */\n    int dragging;\n    int draggingx;\n    int draggingy;\n    int draggingcx;\n    int draggingcy;\n    int draggingdx;\n    int draggingdy;\n    int draggingorgx;\n    int draggingorgy;\n    int draggingxorstate;\n    struct xrdp_bitmap *dragging_window;\n    /* the down(clicked) button */\n    struct xrdp_bitmap *button_down;\n    /* popup for combo box */\n    struct xrdp_bitmap *popup_wnd;\n    /* focused window */\n    struct xrdp_bitmap *focused_window;\n    /* pointer */\n    int current_pointer;\n    int mouse_x;\n    int mouse_y;\n    /* keyboard info */\n    int keys[256]; /* key states 0 up 1 down*/\n    int caps_lock;\n    int scroll_lock;\n    int num_lock;\n    /* client info */\n    struct xrdp_client_info *client_info;\n    /* session log */\n    struct list *log;\n    struct xrdp_bitmap *log_wnd;\n    enum wm_login_state login_state;\n    tbus login_state_event;\n    struct xrdp_mm *mm;\n    struct xrdp_font *default_font;\n    struct xrdp_keymap keymap;\n    int hide_log_window;\n    int fatal_error_in_log_window;\n    struct xrdp_bitmap *target_surface; /* either screen or os surface */\n    int current_surface_index;\n    int hints;\n    char pamerrortxt[256];\n\n    /* configuration derived from xrdp.ini */\n    struct xrdp_config *xrdp_config;\n\n    struct xrdp_region *screen_dirty_region;\n    int last_screen_draw_time;\n};\n\n/* rdp process */\nstruct xrdp_process\n{\n    int status;\n    struct trans *server_trans; /* in tcp server mode */\n    tbus self_term_event;\n    struct xrdp_listen *lis_layer; /* owner */\n    struct xrdp_session *session;\n    /* create these when up and running */\n    struct xrdp_wm *wm;\n    //int app_sck;\n    tbus done_event;\n    int session_id;\n};\n\n/* rdp listener */\nstruct xrdp_listen\n{\n    int status;\n    struct list *trans_list; /* list of struct trans* */\n    struct list *process_list;\n    struct list *fork_list;\n    tbus pro_done_event;\n    struct xrdp_startup_params *startup_params;\n};\n\n/* region */\nstruct xrdp_region\n{\n    struct xrdp_wm *wm; /* owner */\n    struct pixman_region16 *reg;\n};\n\n/* painter */\nstruct xrdp_painter\n{\n    int rop;\n    struct xrdp_rect *use_clip; /* nil if not using clip */\n    struct xrdp_rect clip;\n    int clip_children;\n    int bg_color;\n    int fg_color;\n    int mix_mode;\n    struct xrdp_brush brush;\n    struct xrdp_pen pen;\n    struct xrdp_session *session;\n    struct xrdp_wm *wm; /* owner */\n    struct xrdp_font *font;\n    void *painter;\n    struct xrdp_region *dirty_region;\n    int begin_end_level;\n};\n\n/* window or bitmap */\nstruct xrdp_bitmap\n{\n    /* 0 = bitmap 1 = window 2 = screen 3 = button 4 = image 5 = edit\n       6 = label 7 = combo 8 = special */\n    int type;\n    int width;\n    int height;\n    struct xrdp_wm *wm;\n    /* msg 1 = click 2 = mouse move 3 = paint 100 = modal result */\n    /* see messages in constants.h */\n    int (*notify)(struct xrdp_bitmap *wnd, struct xrdp_bitmap *sender,\n                  int msg, long param1, long param2);\n    /* for bitmap */\n    int bpp;\n    int line_size; /* in bytes */\n    int do_not_free_data;\n    char *data;\n    /* for all but bitmap */\n    int left;\n    int top;\n    int pointer;\n    int bg_color;\n    int tab_stop;\n    int id;\n    char *caption1;\n    /* for window or screen */\n    struct xrdp_bitmap *modal_dialog;\n    struct xrdp_bitmap *focused_control;\n    struct xrdp_bitmap *owner; /* window that created us */\n    struct xrdp_bitmap *parent; /* window contained in */\n    /* for modal dialog */\n    struct xrdp_bitmap *default_button; /* button when enter is pressed */\n    struct xrdp_bitmap *esc_button; /* button when esc is pressed */\n    /* list of child windows */\n    struct list *child_list;\n    /* for edit */\n    int edit_pos;\n    twchar password_char;\n    /* for button or combo */\n    int state; /* for button 0 = normal 1 = down */\n    /* for combo */\n    struct list *string_list;\n    struct list *data_list;\n    /* for combo or popup */\n    int item_index;\n    /* for popup */\n    struct xrdp_bitmap *popped_from;\n    int item_height;\n    /* crc */\n    int crc32;\n    int crc16;\n};\n\n#define MAX_FONT_CHARS 0x4e00\n#define DEFAULT_FONT_NAME \"sans-10.fv1\"\n#define DEFAULT_FONT_PIXEL_SIZE 16\n#define DEFAULT_FV1_SELECT \"130:sans-18.fv1,0:\" DEFAULT_FONT_NAME\n\n#define DEFAULT_BUTTON_MARGIN_H 12\n#define DEFAULT_BUTTON_MARGIN_W 12\n#define DEFAULT_COMBO_MARGIN_H 6\n#define DEFAULT_EDIT_MARGIN_H  6\n#define DEFAULT_WND_LOGIN_W   425\n#define DEFAULT_WND_LOGIN_H   475\n#define DEFAULT_WND_HELP_W    340\n#define DEFAULT_WND_HELP_H    300\n#define DEFAULT_WND_LOG_W     400\n#define DEFAULT_WND_LOG_H     400\n#define DEFAULT_WND_SPECIAL_H 100\n\n/* font */\nstruct xrdp_font\n{\n    struct xrdp_wm *wm;\n    // Font characters, accessed by Unicode codepoint. The first 32\n    // entries are unused.\n    struct xrdp_font_char chars[MAX_FONT_CHARS];\n    unsigned int char_count; // # elements in above array\n    struct xrdp_font_char *default_char; // Pointer into above array\n    char name[32];\n    int size;\n    /** Body height in pixels */\n    int body_height;\n    int style;\n};\n\n/* module */\nstruct xrdp_mod_data\n{\n    struct list *names;\n    struct list *values;\n};\n\nstruct xrdp_startup_params\n{\n    /* xrdp_ini is not malloc'd and has at least the same lifetime as main() */\n    const char *xrdp_ini;\n    char port[1024];\n    int kill;\n    int no_daemon;\n    int help;\n    int version;\n    int fork;\n    int dump_config;\n    int license;\n    int tcp_send_buffer_bytes;\n    int tcp_recv_buffer_bytes;\n    int tcp_nodelay;\n    int tcp_keepalive;\n    int use_vsock;\n};\n\n/*\n * For storing xrdp.ini (and other) configuration settings\n */\n\nstruct xrdp_ls_dimensions\n{\n    int  width;               /* window width */\n    int  height;              /* window height */\n    int  logo_width;          /* logo width (optional) */\n    int  logo_height;          /* logo height (optional) */\n    int  logo_x_pos;          /* logo x co-ordinate */\n    int  logo_y_pos;          /* logo y co-ordinate */\n    int  label_x_pos;         /* x pos of labels */\n    int  label_width;         /* width of labels */\n    int  input_x_pos;         /* x pos of text and combo boxes */\n    int  input_width;         /* width of input and combo boxes */\n    int  input_y_pos;         /* y pos for for first label and combo box */\n    int  btn_ok_x_pos;        /* x pos for OK button */\n    int  btn_ok_y_pos;        /* y pos for OK button */\n    int  btn_ok_width;        /* width of OK button */\n    int  btn_ok_height;       /* height of OK button */\n    int  btn_cancel_x_pos;    /* x pos for Cancel button */\n    int  btn_cancel_y_pos;    /* y pos for Cancel button */\n    int  btn_cancel_width;    /* width of Cancel button */\n    int  btn_cancel_height;   /* height of Cancel button */\n    int default_btn_height;   /* Default button height (e.g. OK on login box) */\n    int log_wnd_width;        /* Width of log window */\n    int log_wnd_height;       /* Height of log window */\n    int edit_height;          /* Height of an edit box */\n    int combo_height;         /* Height of a combo box */\n    int help_wnd_width;        /* Width of login help window */\n    int help_wnd_height;       /* Height of login help window */\n};\n\nstruct xrdp_cfg_globals\n{\n    int  ini_version;            /* xrdp.ini file version number */\n    int  use_bitmap_cache;\n    int  use_bitmap_compression;\n    int  port;\n    int  crypt_level;            /* low=1, medium=2, high=3 */\n    int  allow_channels;\n    int  max_bpp;\n    int  fork;\n    int  tcp_nodelay;\n    int  tcp_keepalive;\n    int  tcp_send_buffer_bytes;\n    int  tcp_recv_buffer_bytes;\n    char autorun[256];\n    int  hidelogwindow;\n    int  require_credentials;\n    int  bulk_compression;\n    int  new_cursors;\n    int  nego_sec_layer;\n    int  allow_multimon;\n    int  enable_token_login;\n\n    /* colors */\n\n    int  grey;\n    int  black;\n    int  dark_grey;\n    int  blue;\n    int  dark_blue;\n    int  white;\n    int  red;\n    int  green;\n    int  background;\n\n    /* login screen */\n    unsigned int  default_dpi;   /* Default DPI to use if nothing from client */\n    char fv1_select[256];        /* Selection string for fv1 font */\n    int  ls_top_window_bg_color; /* top level window background color */\n    int  ls_bg_color;            /* background color */\n    char ls_background_image[256];  /* background image file name */\n    /* transform to apply to background image */\n    enum xrdp_bitmap_load_transform ls_background_transform;\n    char ls_logo_filename[256];  /* logo filename */\n    /* transform to apply to logo */\n    enum xrdp_bitmap_load_transform ls_logo_transform;\n    char ls_title[256];          /* loginscreen window title */\n    /* Login screen dimensions, unscaled (from config) */\n    struct xrdp_ls_dimensions ls_unscaled;\n    /* Login screen dimensions, scaled (after font is loaded) */\n    struct xrdp_ls_dimensions ls_scaled;\n};\n\nstruct xrdp_cfg_logging\n{\n\n};\n\nstruct xrdp_cfg_channels\n{\n\n};\n\nstruct xrdp_config\n{\n    struct xrdp_cfg_globals   cfg_globals;\n    struct xrdp_cfg_logging   cfg_logging;\n    struct xrdp_cfg_channels  cfg_channels;\n};\n\n#endif\n"], "filenames": ["xrdp/xrdp.h", "xrdp/xrdp_font.c", "xrdp/xrdp_painter.c", "xrdp/xrdp_types.h"], "buggy_code_start_loc": [383, 53, 457, 651], "buggy_code_end_loc": [383, 315, 921, 673], "fixing_code_start_loc": [384, 54, 457, 651], "fixing_code_end_loc": [393, 401, 921, 677], "type": "CWE-125", "message": " xrdp is an open source remote desktop protocol server. Access to the font glyphs in xrdp_painter.c is not bounds-checked . Since some of this data is controllable by the user, this can result in an out-of-bounds read within the xrdp executable. The vulnerability allows an out-of-bounds read within a potentially privileged process. On non-Debian platforms, xrdp tends to run as root. Potentially an out-of-bounds write can follow the out-of-bounds read. There is no denial-of-service impact, providing xrdp is running in forking mode. This issue has been addressed in release 0.9.23.1. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-42822", "sourceIdentifier": "security-advisories@github.com", "published": "2023-09-27T18:15:11.903", "lastModified": "2023-11-03T21:15:16.230", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": " xrdp is an open source remote desktop protocol server. Access to the font glyphs in xrdp_painter.c is not bounds-checked . Since some of this data is controllable by the user, this can result in an out-of-bounds read within the xrdp executable. The vulnerability allows an out-of-bounds read within a potentially privileged process. On non-Debian platforms, xrdp tends to run as root. Potentially an out-of-bounds write can follow the out-of-bounds read. There is no denial-of-service impact, providing xrdp is running in forking mode. This issue has been addressed in release 0.9.23.1. Users are advised to upgrade. There are no known workarounds for this vulnerability."}, {"lang": "es", "value": "xrdp es un servidor de protocolo de escritorio remoto de c\u00f3digo abierto. El acceso a los font glyphs en xrdp_painter.c no est\u00e1 controlado por los l\u00edmites. Dado que algunos de estos datos son controlables por el usuario, esto puede resultar en una lectura fuera de los l\u00edmites dentro del ejecutable xrdp. La vulnerabilidad permite una lectura fuera de los l\u00edmites dentro de un proceso potencialmente privilegiado. En plataformas que no son Debian, xrdp tiende a ejecutarse como root. Potencialmente, una escritura fuera de los l\u00edmites puede seguir a la lectura fuera de los l\u00edmites. No hay ning\u00fan impacto de denegaci\u00f3n de servicio, siempre que xrdp se ejecute en modo fork. Este problema se solucion\u00f3 en la versi\u00f3n 0.9.23.1. Se recomienda a los usuarios que actualicen. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 2.5}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:neutrinolabs:xrdp:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.9.23.1", "matchCriteriaId": "0601B4B9-2AC4-494C-88F4-FDF58EFD0AF6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:38:*:*:*:*:*:*:*", "matchCriteriaId": "CC559B26-5DFC-4B7A-A27C-B77DE755DFF9"}]}]}], "references": [{"url": "https://github.com/neutrinolabs/xrdp/commit/73acbe1f7957c65122b00de4d6f57a8d0d257c40", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/neutrinolabs/xrdp/security/advisories/GHSA-2hjx-rm4f-r9hw", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/5FPGA4M7IYCP7OILDF2ZJEVSXUOFEFQ6/", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PFGL22QQF65OIZRMCKUZCVJQCKGUBRYE/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Release Notes"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RTXODUR4ILM7ZPA6ZGY6VSK4BBSBMKGY/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Release Notes"]}]}, "github_commit_url": "https://github.com/neutrinolabs/xrdp/commit/73acbe1f7957c65122b00de4d6f57a8d0d257c40"}}