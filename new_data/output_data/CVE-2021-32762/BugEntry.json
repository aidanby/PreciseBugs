{"buggy_code": ["/*\n * Copyright (c) 2009-2011, Salvatore Sanfilippo <antirez at gmail dot com>\n * Copyright (c) 2010-2014, Pieter Noordhuis <pcnoordhuis at gmail dot com>\n * Copyright (c) 2015, Matt Stancliff <matt at genges dot com>,\n *                     Jan-Erik Rediger <janerik at fnordig dot com>\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"fmacros.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <errno.h>\n#include <ctype.h>\n\n#include \"hiredis.h\"\n#include \"net.h\"\n#include \"sds.h\"\n#include \"async.h\"\n#include \"win32.h\"\n\nextern int redisContextUpdateConnectTimeout(redisContext *c, const struct timeval *timeout);\nextern int redisContextUpdateCommandTimeout(redisContext *c, const struct timeval *timeout);\n\nstatic redisContextFuncs redisContextDefaultFuncs = {\n    .free_privctx = NULL,\n    .async_read = redisAsyncRead,\n    .async_write = redisAsyncWrite,\n    .read = redisNetRead,\n    .write = redisNetWrite\n};\n\nstatic redisReply *createReplyObject(int type);\nstatic void *createStringObject(const redisReadTask *task, char *str, size_t len);\nstatic void *createArrayObject(const redisReadTask *task, size_t elements);\nstatic void *createIntegerObject(const redisReadTask *task, long long value);\nstatic void *createDoubleObject(const redisReadTask *task, double value, char *str, size_t len);\nstatic void *createNilObject(const redisReadTask *task);\nstatic void *createBoolObject(const redisReadTask *task, int bval);\n\n/* Default set of functions to build the reply. Keep in mind that such a\n * function returning NULL is interpreted as OOM. */\nstatic redisReplyObjectFunctions defaultFunctions = {\n    createStringObject,\n    createArrayObject,\n    createIntegerObject,\n    createDoubleObject,\n    createNilObject,\n    createBoolObject,\n    freeReplyObject\n};\n\n/* Create a reply object */\nstatic redisReply *createReplyObject(int type) {\n    redisReply *r = hi_calloc(1,sizeof(*r));\n\n    if (r == NULL)\n        return NULL;\n\n    r->type = type;\n    return r;\n}\n\n/* Free a reply object */\nvoid freeReplyObject(void *reply) {\n    redisReply *r = reply;\n    size_t j;\n\n    if (r == NULL)\n        return;\n\n    switch(r->type) {\n    case REDIS_REPLY_INTEGER:\n        break; /* Nothing to free */\n    case REDIS_REPLY_ARRAY:\n    case REDIS_REPLY_MAP:\n    case REDIS_REPLY_SET:\n    case REDIS_REPLY_PUSH:\n        if (r->element != NULL) {\n            for (j = 0; j < r->elements; j++)\n                freeReplyObject(r->element[j]);\n            hi_free(r->element);\n        }\n        break;\n    case REDIS_REPLY_ERROR:\n    case REDIS_REPLY_STATUS:\n    case REDIS_REPLY_STRING:\n    case REDIS_REPLY_DOUBLE:\n    case REDIS_REPLY_VERB:\n        hi_free(r->str);\n        break;\n    }\n    hi_free(r);\n}\n\nstatic void *createStringObject(const redisReadTask *task, char *str, size_t len) {\n    redisReply *r, *parent;\n    char *buf;\n\n    r = createReplyObject(task->type);\n    if (r == NULL)\n        return NULL;\n\n    assert(task->type == REDIS_REPLY_ERROR  ||\n           task->type == REDIS_REPLY_STATUS ||\n           task->type == REDIS_REPLY_STRING ||\n           task->type == REDIS_REPLY_VERB);\n\n    /* Copy string value */\n    if (task->type == REDIS_REPLY_VERB) {\n        buf = hi_malloc(len-4+1); /* Skip 4 bytes of verbatim type header. */\n        if (buf == NULL) goto oom;\n\n        memcpy(r->vtype,str,3);\n        r->vtype[3] = '\\0';\n        memcpy(buf,str+4,len-4);\n        buf[len-4] = '\\0';\n        r->len = len - 4;\n    } else {\n        buf = hi_malloc(len+1);\n        if (buf == NULL) goto oom;\n\n        memcpy(buf,str,len);\n        buf[len] = '\\0';\n        r->len = len;\n    }\n    r->str = buf;\n\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET ||\n               parent->type == REDIS_REPLY_PUSH);\n        parent->element[task->idx] = r;\n    }\n    return r;\n\noom:\n    freeReplyObject(r);\n    return NULL;\n}\n\nstatic void *createArrayObject(const redisReadTask *task, size_t elements) {\n    redisReply *r, *parent;\n\n    r = createReplyObject(task->type);\n    if (r == NULL)\n        return NULL;\n\n    if (elements > 0) {\n        r->element = hi_calloc(elements,sizeof(redisReply*));\n        if (r->element == NULL) {\n            freeReplyObject(r);\n            return NULL;\n        }\n    }\n\n    r->elements = elements;\n\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET ||\n               parent->type == REDIS_REPLY_PUSH);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}\n\nstatic void *createIntegerObject(const redisReadTask *task, long long value) {\n    redisReply *r, *parent;\n\n    r = createReplyObject(REDIS_REPLY_INTEGER);\n    if (r == NULL)\n        return NULL;\n\n    r->integer = value;\n\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET ||\n               parent->type == REDIS_REPLY_PUSH);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}\n\nstatic void *createDoubleObject(const redisReadTask *task, double value, char *str, size_t len) {\n    redisReply *r, *parent;\n\n    r = createReplyObject(REDIS_REPLY_DOUBLE);\n    if (r == NULL)\n        return NULL;\n\n    r->dval = value;\n    r->str = hi_malloc(len+1);\n    if (r->str == NULL) {\n        freeReplyObject(r);\n        return NULL;\n    }\n\n    /* The double reply also has the original protocol string representing a\n     * double as a null terminated string. This way the caller does not need\n     * to format back for string conversion, especially since Redis does efforts\n     * to make the string more human readable avoiding the calssical double\n     * decimal string conversion artifacts. */\n    memcpy(r->str, str, len);\n    r->str[len] = '\\0';\n\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}\n\nstatic void *createNilObject(const redisReadTask *task) {\n    redisReply *r, *parent;\n\n    r = createReplyObject(REDIS_REPLY_NIL);\n    if (r == NULL)\n        return NULL;\n\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET ||\n               parent->type == REDIS_REPLY_PUSH);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}\n\nstatic void *createBoolObject(const redisReadTask *task, int bval) {\n    redisReply *r, *parent;\n\n    r = createReplyObject(REDIS_REPLY_BOOL);\n    if (r == NULL)\n        return NULL;\n\n    r->integer = bval != 0;\n\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}\n\n/* Return the number of digits of 'v' when converted to string in radix 10.\n * Implementation borrowed from link in redis/src/util.c:string2ll(). */\nstatic uint32_t countDigits(uint64_t v) {\n  uint32_t result = 1;\n  for (;;) {\n    if (v < 10) return result;\n    if (v < 100) return result + 1;\n    if (v < 1000) return result + 2;\n    if (v < 10000) return result + 3;\n    v /= 10000U;\n    result += 4;\n  }\n}\n\n/* Helper that calculates the bulk length given a certain string length. */\nstatic size_t bulklen(size_t len) {\n    return 1+countDigits(len)+2+len+2;\n}\n\nint redisvFormatCommand(char **target, const char *format, va_list ap) {\n    const char *c = format;\n    char *cmd = NULL; /* final command */\n    int pos; /* position in final command */\n    hisds curarg, newarg; /* current argument */\n    int touched = 0; /* was the current argument touched? */\n    char **curargv = NULL, **newargv = NULL;\n    int argc = 0;\n    int totlen = 0;\n    int error_type = 0; /* 0 = no error; -1 = memory error; -2 = format error */\n    int j;\n\n    /* Abort if there is not target to set */\n    if (target == NULL)\n        return -1;\n\n    /* Build the command string accordingly to protocol */\n    curarg = hi_sdsempty();\n    if (curarg == NULL)\n        return -1;\n\n    while(*c != '\\0') {\n        if (*c != '%' || c[1] == '\\0') {\n            if (*c == ' ') {\n                if (touched) {\n                    newargv = hi_realloc(curargv,sizeof(char*)*(argc+1));\n                    if (newargv == NULL) goto memory_err;\n                    curargv = newargv;\n                    curargv[argc++] = curarg;\n                    totlen += bulklen(hi_sdslen(curarg));\n\n                    /* curarg is put in argv so it can be overwritten. */\n                    curarg = hi_sdsempty();\n                    if (curarg == NULL) goto memory_err;\n                    touched = 0;\n                }\n            } else {\n                newarg = hi_sdscatlen(curarg,c,1);\n                if (newarg == NULL) goto memory_err;\n                curarg = newarg;\n                touched = 1;\n            }\n        } else {\n            char *arg;\n            size_t size;\n\n            /* Set newarg so it can be checked even if it is not touched. */\n            newarg = curarg;\n\n            switch(c[1]) {\n            case 's':\n                arg = va_arg(ap,char*);\n                size = strlen(arg);\n                if (size > 0)\n                    newarg = hi_sdscatlen(curarg,arg,size);\n                break;\n            case 'b':\n                arg = va_arg(ap,char*);\n                size = va_arg(ap,size_t);\n                if (size > 0)\n                    newarg = hi_sdscatlen(curarg,arg,size);\n                break;\n            case '%':\n                newarg = hi_sdscat(curarg,\"%\");\n                break;\n            default:\n                /* Try to detect printf format */\n                {\n                    static const char intfmts[] = \"diouxX\";\n                    static const char flags[] = \"#0-+ \";\n                    char _format[16];\n                    const char *_p = c+1;\n                    size_t _l = 0;\n                    va_list _cpy;\n\n                    /* Flags */\n                    while (*_p != '\\0' && strchr(flags,*_p) != NULL) _p++;\n\n                    /* Field width */\n                    while (*_p != '\\0' && isdigit(*_p)) _p++;\n\n                    /* Precision */\n                    if (*_p == '.') {\n                        _p++;\n                        while (*_p != '\\0' && isdigit(*_p)) _p++;\n                    }\n\n                    /* Copy va_list before consuming with va_arg */\n                    va_copy(_cpy,ap);\n\n                    /* Integer conversion (without modifiers) */\n                    if (strchr(intfmts,*_p) != NULL) {\n                        va_arg(ap,int);\n                        goto fmt_valid;\n                    }\n\n                    /* Double conversion (without modifiers) */\n                    if (strchr(\"eEfFgGaA\",*_p) != NULL) {\n                        va_arg(ap,double);\n                        goto fmt_valid;\n                    }\n\n                    /* Size: char */\n                    if (_p[0] == 'h' && _p[1] == 'h') {\n                        _p += 2;\n                        if (*_p != '\\0' && strchr(intfmts,*_p) != NULL) {\n                            va_arg(ap,int); /* char gets promoted to int */\n                            goto fmt_valid;\n                        }\n                        goto fmt_invalid;\n                    }\n\n                    /* Size: short */\n                    if (_p[0] == 'h') {\n                        _p += 1;\n                        if (*_p != '\\0' && strchr(intfmts,*_p) != NULL) {\n                            va_arg(ap,int); /* short gets promoted to int */\n                            goto fmt_valid;\n                        }\n                        goto fmt_invalid;\n                    }\n\n                    /* Size: long long */\n                    if (_p[0] == 'l' && _p[1] == 'l') {\n                        _p += 2;\n                        if (*_p != '\\0' && strchr(intfmts,*_p) != NULL) {\n                            va_arg(ap,long long);\n                            goto fmt_valid;\n                        }\n                        goto fmt_invalid;\n                    }\n\n                    /* Size: long */\n                    if (_p[0] == 'l') {\n                        _p += 1;\n                        if (*_p != '\\0' && strchr(intfmts,*_p) != NULL) {\n                            va_arg(ap,long);\n                            goto fmt_valid;\n                        }\n                        goto fmt_invalid;\n                    }\n\n                fmt_invalid:\n                    va_end(_cpy);\n                    goto format_err;\n\n                fmt_valid:\n                    _l = (_p+1)-c;\n                    if (_l < sizeof(_format)-2) {\n                        memcpy(_format,c,_l);\n                        _format[_l] = '\\0';\n                        newarg = hi_sdscatvprintf(curarg,_format,_cpy);\n\n                        /* Update current position (note: outer blocks\n                         * increment c twice so compensate here) */\n                        c = _p-1;\n                    }\n\n                    va_end(_cpy);\n                    break;\n                }\n            }\n\n            if (newarg == NULL) goto memory_err;\n            curarg = newarg;\n\n            touched = 1;\n            c++;\n        }\n        c++;\n    }\n\n    /* Add the last argument if needed */\n    if (touched) {\n        newargv = hi_realloc(curargv,sizeof(char*)*(argc+1));\n        if (newargv == NULL) goto memory_err;\n        curargv = newargv;\n        curargv[argc++] = curarg;\n        totlen += bulklen(hi_sdslen(curarg));\n    } else {\n        hi_sdsfree(curarg);\n    }\n\n    /* Clear curarg because it was put in curargv or was free'd. */\n    curarg = NULL;\n\n    /* Add bytes needed to hold multi bulk count */\n    totlen += 1+countDigits(argc)+2;\n\n    /* Build the command at protocol level */\n    cmd = hi_malloc(totlen+1);\n    if (cmd == NULL) goto memory_err;\n\n    pos = sprintf(cmd,\"*%d\\r\\n\",argc);\n    for (j = 0; j < argc; j++) {\n        pos += sprintf(cmd+pos,\"$%zu\\r\\n\",hi_sdslen(curargv[j]));\n        memcpy(cmd+pos,curargv[j],hi_sdslen(curargv[j]));\n        pos += hi_sdslen(curargv[j]);\n        hi_sdsfree(curargv[j]);\n        cmd[pos++] = '\\r';\n        cmd[pos++] = '\\n';\n    }\n    assert(pos == totlen);\n    cmd[pos] = '\\0';\n\n    hi_free(curargv);\n    *target = cmd;\n    return totlen;\n\nformat_err:\n    error_type = -2;\n    goto cleanup;\n\nmemory_err:\n    error_type = -1;\n    goto cleanup;\n\ncleanup:\n    if (curargv) {\n        while(argc--)\n            hi_sdsfree(curargv[argc]);\n        hi_free(curargv);\n    }\n\n    hi_sdsfree(curarg);\n    hi_free(cmd);\n\n    return error_type;\n}\n\n/* Format a command according to the Redis protocol. This function\n * takes a format similar to printf:\n *\n * %s represents a C null terminated string you want to interpolate\n * %b represents a binary safe string\n *\n * When using %b you need to provide both the pointer to the string\n * and the length in bytes as a size_t. Examples:\n *\n * len = redisFormatCommand(target, \"GET %s\", mykey);\n * len = redisFormatCommand(target, \"SET %s %b\", mykey, myval, myvallen);\n */\nint redisFormatCommand(char **target, const char *format, ...) {\n    va_list ap;\n    int len;\n    va_start(ap,format);\n    len = redisvFormatCommand(target,format,ap);\n    va_end(ap);\n\n    /* The API says \"-1\" means bad result, but we now also return \"-2\" in some\n     * cases.  Force the return value to always be -1. */\n    if (len < 0)\n        len = -1;\n\n    return len;\n}\n\n/* Format a command according to the Redis protocol using an hisds string and\n * hi_sdscatfmt for the processing of arguments. This function takes the\n * number of arguments, an array with arguments and an array with their\n * lengths. If the latter is set to NULL, strlen will be used to compute the\n * argument lengths.\n */\nint redisFormatSdsCommandArgv(hisds *target, int argc, const char **argv,\n                              const size_t *argvlen)\n{\n    hisds cmd, aux;\n    unsigned long long totlen;\n    int j;\n    size_t len;\n\n    /* Abort on a NULL target */\n    if (target == NULL)\n        return -1;\n\n    /* Calculate our total size */\n    totlen = 1+countDigits(argc)+2;\n    for (j = 0; j < argc; j++) {\n        len = argvlen ? argvlen[j] : strlen(argv[j]);\n        totlen += bulklen(len);\n    }\n\n    /* Use an SDS string for command construction */\n    cmd = hi_sdsempty();\n    if (cmd == NULL)\n        return -1;\n\n    /* We already know how much storage we need */\n    aux = hi_sdsMakeRoomFor(cmd, totlen);\n    if (aux == NULL) {\n        hi_sdsfree(cmd);\n        return -1;\n    }\n\n    cmd = aux;\n\n    /* Construct command */\n    cmd = hi_sdscatfmt(cmd, \"*%i\\r\\n\", argc);\n    for (j=0; j < argc; j++) {\n        len = argvlen ? argvlen[j] : strlen(argv[j]);\n        cmd = hi_sdscatfmt(cmd, \"$%u\\r\\n\", len);\n        cmd = hi_sdscatlen(cmd, argv[j], len);\n        cmd = hi_sdscatlen(cmd, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n    }\n\n    assert(hi_sdslen(cmd)==totlen);\n\n    *target = cmd;\n    return totlen;\n}\n\nvoid redisFreeSdsCommand(hisds cmd) {\n    hi_sdsfree(cmd);\n}\n\n/* Format a command according to the Redis protocol. This function takes the\n * number of arguments, an array with arguments and an array with their\n * lengths. If the latter is set to NULL, strlen will be used to compute the\n * argument lengths.\n */\nint redisFormatCommandArgv(char **target, int argc, const char **argv, const size_t *argvlen) {\n    char *cmd = NULL; /* final command */\n    int pos; /* position in final command */\n    size_t len;\n    int totlen, j;\n\n    /* Abort on a NULL target */\n    if (target == NULL)\n        return -1;\n\n    /* Calculate number of bytes needed for the command */\n    totlen = 1+countDigits(argc)+2;\n    for (j = 0; j < argc; j++) {\n        len = argvlen ? argvlen[j] : strlen(argv[j]);\n        totlen += bulklen(len);\n    }\n\n    /* Build the command at protocol level */\n    cmd = hi_malloc(totlen+1);\n    if (cmd == NULL)\n        return -1;\n\n    pos = sprintf(cmd,\"*%d\\r\\n\",argc);\n    for (j = 0; j < argc; j++) {\n        len = argvlen ? argvlen[j] : strlen(argv[j]);\n        pos += sprintf(cmd+pos,\"$%zu\\r\\n\",len);\n        memcpy(cmd+pos,argv[j],len);\n        pos += len;\n        cmd[pos++] = '\\r';\n        cmd[pos++] = '\\n';\n    }\n    assert(pos == totlen);\n    cmd[pos] = '\\0';\n\n    *target = cmd;\n    return totlen;\n}\n\nvoid redisFreeCommand(char *cmd) {\n    hi_free(cmd);\n}\n\nvoid __redisSetError(redisContext *c, int type, const char *str) {\n    size_t len;\n\n    c->err = type;\n    if (str != NULL) {\n        len = strlen(str);\n        len = len < (sizeof(c->errstr)-1) ? len : (sizeof(c->errstr)-1);\n        memcpy(c->errstr,str,len);\n        c->errstr[len] = '\\0';\n    } else {\n        /* Only REDIS_ERR_IO may lack a description! */\n        assert(type == REDIS_ERR_IO);\n        strerror_r(errno, c->errstr, sizeof(c->errstr));\n    }\n}\n\nredisReader *redisReaderCreate(void) {\n    return redisReaderCreateWithFunctions(&defaultFunctions);\n}\n\nstatic void redisPushAutoFree(void *privdata, void *reply) {\n    (void)privdata;\n    freeReplyObject(reply);\n}\n\nstatic redisContext *redisContextInit(void) {\n    redisContext *c;\n\n    c = hi_calloc(1, sizeof(*c));\n    if (c == NULL)\n        return NULL;\n\n    c->funcs = &redisContextDefaultFuncs;\n\n    c->obuf = hi_sdsempty();\n    c->reader = redisReaderCreate();\n    c->fd = REDIS_INVALID_FD;\n\n    if (c->obuf == NULL || c->reader == NULL) {\n        redisFree(c);\n        return NULL;\n    }\n\n    return c;\n}\n\nvoid redisFree(redisContext *c) {\n    if (c == NULL)\n        return;\n    redisNetClose(c);\n\n    hi_sdsfree(c->obuf);\n    redisReaderFree(c->reader);\n    hi_free(c->tcp.host);\n    hi_free(c->tcp.source_addr);\n    hi_free(c->unix_sock.path);\n    hi_free(c->connect_timeout);\n    hi_free(c->command_timeout);\n    hi_free(c->saddr);\n\n    if (c->privdata && c->free_privdata)\n        c->free_privdata(c->privdata);\n\n    if (c->funcs->free_privctx)\n        c->funcs->free_privctx(c->privctx);\n\n    memset(c, 0xff, sizeof(*c));\n    hi_free(c);\n}\n\nredisFD redisFreeKeepFd(redisContext *c) {\n    redisFD fd = c->fd;\n    c->fd = REDIS_INVALID_FD;\n    redisFree(c);\n    return fd;\n}\n\nint redisReconnect(redisContext *c) {\n    c->err = 0;\n    memset(c->errstr, '\\0', strlen(c->errstr));\n\n    if (c->privctx && c->funcs->free_privctx) {\n        c->funcs->free_privctx(c->privctx);\n        c->privctx = NULL;\n    }\n\n    redisNetClose(c);\n\n    hi_sdsfree(c->obuf);\n    redisReaderFree(c->reader);\n\n    c->obuf = hi_sdsempty();\n    c->reader = redisReaderCreate();\n\n    if (c->obuf == NULL || c->reader == NULL) {\n        __redisSetError(c, REDIS_ERR_OOM, \"Out of memory\");\n        return REDIS_ERR;\n    }\n\n    int ret = REDIS_ERR;\n    if (c->connection_type == REDIS_CONN_TCP) {\n        ret = redisContextConnectBindTcp(c, c->tcp.host, c->tcp.port,\n               c->connect_timeout, c->tcp.source_addr);\n    } else if (c->connection_type == REDIS_CONN_UNIX) {\n        ret = redisContextConnectUnix(c, c->unix_sock.path, c->connect_timeout);\n    } else {\n        /* Something bad happened here and shouldn't have. There isn't\n           enough information in the context to reconnect. */\n        __redisSetError(c,REDIS_ERR_OTHER,\"Not enough information to reconnect\");\n        ret = REDIS_ERR;\n    }\n\n    if (c->command_timeout != NULL && (c->flags & REDIS_BLOCK) && c->fd != REDIS_INVALID_FD) {\n        redisContextSetTimeout(c, *c->command_timeout);\n    }\n\n    return ret;\n}\n\nredisContext *redisConnectWithOptions(const redisOptions *options) {\n    redisContext *c = redisContextInit();\n    if (c == NULL) {\n        return NULL;\n    }\n    if (!(options->options & REDIS_OPT_NONBLOCK)) {\n        c->flags |= REDIS_BLOCK;\n    }\n    if (options->options & REDIS_OPT_REUSEADDR) {\n        c->flags |= REDIS_REUSEADDR;\n    }\n    if (options->options & REDIS_OPT_NOAUTOFREE) {\n        c->flags |= REDIS_NO_AUTO_FREE;\n    }\n\n    /* Set any user supplied RESP3 PUSH handler or use freeReplyObject\n     * as a default unless specifically flagged that we don't want one. */\n    if (options->push_cb != NULL)\n        redisSetPushCallback(c, options->push_cb);\n    else if (!(options->options & REDIS_OPT_NO_PUSH_AUTOFREE))\n        redisSetPushCallback(c, redisPushAutoFree);\n\n    c->privdata = options->privdata;\n    c->free_privdata = options->free_privdata;\n\n    if (redisContextUpdateConnectTimeout(c, options->connect_timeout) != REDIS_OK ||\n        redisContextUpdateCommandTimeout(c, options->command_timeout) != REDIS_OK) {\n        __redisSetError(c, REDIS_ERR_OOM, \"Out of memory\");\n        return c;\n    }\n\n    if (options->type == REDIS_CONN_TCP) {\n        redisContextConnectBindTcp(c, options->endpoint.tcp.ip,\n                                   options->endpoint.tcp.port, options->connect_timeout,\n                                   options->endpoint.tcp.source_addr);\n    } else if (options->type == REDIS_CONN_UNIX) {\n        redisContextConnectUnix(c, options->endpoint.unix_socket,\n                                options->connect_timeout);\n    } else if (options->type == REDIS_CONN_USERFD) {\n        c->fd = options->endpoint.fd;\n        c->flags |= REDIS_CONNECTED;\n    } else {\n        // Unknown type - FIXME - FREE\n        return NULL;\n    }\n\n    if (options->command_timeout != NULL && (c->flags & REDIS_BLOCK) && c->fd != REDIS_INVALID_FD) {\n        redisContextSetTimeout(c, *options->command_timeout);\n    }\n\n    return c;\n}\n\n/* Connect to a Redis instance. On error the field error in the returned\n * context will be set to the return value of the error function.\n * When no set of reply functions is given, the default set will be used. */\nredisContext *redisConnect(const char *ip, int port) {\n    redisOptions options = {0};\n    REDIS_OPTIONS_SET_TCP(&options, ip, port);\n    return redisConnectWithOptions(&options);\n}\n\nredisContext *redisConnectWithTimeout(const char *ip, int port, const struct timeval tv) {\n    redisOptions options = {0};\n    REDIS_OPTIONS_SET_TCP(&options, ip, port);\n    options.connect_timeout = &tv;\n    return redisConnectWithOptions(&options);\n}\n\nredisContext *redisConnectNonBlock(const char *ip, int port) {\n    redisOptions options = {0};\n    REDIS_OPTIONS_SET_TCP(&options, ip, port);\n    options.options |= REDIS_OPT_NONBLOCK;\n    return redisConnectWithOptions(&options);\n}\n\nredisContext *redisConnectBindNonBlock(const char *ip, int port,\n                                       const char *source_addr) {\n    redisOptions options = {0};\n    REDIS_OPTIONS_SET_TCP(&options, ip, port);\n    options.endpoint.tcp.source_addr = source_addr;\n    options.options |= REDIS_OPT_NONBLOCK;\n    return redisConnectWithOptions(&options);\n}\n\nredisContext *redisConnectBindNonBlockWithReuse(const char *ip, int port,\n                                                const char *source_addr) {\n    redisOptions options = {0};\n    REDIS_OPTIONS_SET_TCP(&options, ip, port);\n    options.endpoint.tcp.source_addr = source_addr;\n    options.options |= REDIS_OPT_NONBLOCK|REDIS_OPT_REUSEADDR;\n    return redisConnectWithOptions(&options);\n}\n\nredisContext *redisConnectUnix(const char *path) {\n    redisOptions options = {0};\n    REDIS_OPTIONS_SET_UNIX(&options, path);\n    return redisConnectWithOptions(&options);\n}\n\nredisContext *redisConnectUnixWithTimeout(const char *path, const struct timeval tv) {\n    redisOptions options = {0};\n    REDIS_OPTIONS_SET_UNIX(&options, path);\n    options.connect_timeout = &tv;\n    return redisConnectWithOptions(&options);\n}\n\nredisContext *redisConnectUnixNonBlock(const char *path) {\n    redisOptions options = {0};\n    REDIS_OPTIONS_SET_UNIX(&options, path);\n    options.options |= REDIS_OPT_NONBLOCK;\n    return redisConnectWithOptions(&options);\n}\n\nredisContext *redisConnectFd(redisFD fd) {\n    redisOptions options = {0};\n    options.type = REDIS_CONN_USERFD;\n    options.endpoint.fd = fd;\n    return redisConnectWithOptions(&options);\n}\n\n/* Set read/write timeout on a blocking socket. */\nint redisSetTimeout(redisContext *c, const struct timeval tv) {\n    if (c->flags & REDIS_BLOCK)\n        return redisContextSetTimeout(c,tv);\n    return REDIS_ERR;\n}\n\n/* Enable connection KeepAlive. */\nint redisEnableKeepAlive(redisContext *c) {\n    if (redisKeepAlive(c, REDIS_KEEPALIVE_INTERVAL) != REDIS_OK)\n        return REDIS_ERR;\n    return REDIS_OK;\n}\n\n/* Set a user provided RESP3 PUSH handler and return any old one set. */\nredisPushFn *redisSetPushCallback(redisContext *c, redisPushFn *fn) {\n    redisPushFn *old = c->push_cb;\n    c->push_cb = fn;\n    return old;\n}\n\n/* Use this function to handle a read event on the descriptor. It will try\n * and read some bytes from the socket and feed them to the reply parser.\n *\n * After this function is called, you may use redisGetReplyFromReader to\n * see if there is a reply available. */\nint redisBufferRead(redisContext *c) {\n    char buf[1024*16];\n    int nread;\n\n    /* Return early when the context has seen an error. */\n    if (c->err)\n        return REDIS_ERR;\n\n    nread = c->funcs->read(c, buf, sizeof(buf));\n    if (nread > 0) {\n        if (redisReaderFeed(c->reader, buf, nread) != REDIS_OK) {\n            __redisSetError(c, c->reader->err, c->reader->errstr);\n            return REDIS_ERR;\n        } else {\n        }\n    } else if (nread < 0) {\n        return REDIS_ERR;\n    }\n    return REDIS_OK;\n}\n\n/* Write the output buffer to the socket.\n *\n * Returns REDIS_OK when the buffer is empty, or (a part of) the buffer was\n * successfully written to the socket. When the buffer is empty after the\n * write operation, \"done\" is set to 1 (if given).\n *\n * Returns REDIS_ERR if an error occurred trying to write and sets\n * c->errstr to hold the appropriate error string.\n */\nint redisBufferWrite(redisContext *c, int *done) {\n\n    /* Return early when the context has seen an error. */\n    if (c->err)\n        return REDIS_ERR;\n\n    if (hi_sdslen(c->obuf) > 0) {\n        ssize_t nwritten = c->funcs->write(c);\n        if (nwritten < 0) {\n            return REDIS_ERR;\n        } else if (nwritten > 0) {\n            if (nwritten == (ssize_t)hi_sdslen(c->obuf)) {\n                hi_sdsfree(c->obuf);\n                c->obuf = hi_sdsempty();\n                if (c->obuf == NULL)\n                    goto oom;\n            } else {\n                if (hi_sdsrange(c->obuf,nwritten,-1) < 0) goto oom;\n            }\n        }\n    }\n    if (done != NULL) *done = (hi_sdslen(c->obuf) == 0);\n    return REDIS_OK;\n\noom:\n    __redisSetError(c, REDIS_ERR_OOM, \"Out of memory\");\n    return REDIS_ERR;\n}\n\n/* Internal helper function to try and get a reply from the reader,\n * or set an error in the context otherwise. */\nint redisGetReplyFromReader(redisContext *c, void **reply) {\n    if (redisReaderGetReply(c->reader,reply) == REDIS_ERR) {\n        __redisSetError(c,c->reader->err,c->reader->errstr);\n        return REDIS_ERR;\n    }\n\n    return REDIS_OK;\n}\n\n/* Internal helper that returns 1 if the reply was a RESP3 PUSH\n * message and we handled it with a user-provided callback. */\nstatic int redisHandledPushReply(redisContext *c, void *reply) {\n    if (reply && c->push_cb && redisIsPushReply(reply)) {\n        c->push_cb(c->privdata, reply);\n        return 1;\n    }\n\n    return 0;\n}\n\nint redisGetReply(redisContext *c, void **reply) {\n    int wdone = 0;\n    void *aux = NULL;\n\n    /* Try to read pending replies */\n    if (redisGetReplyFromReader(c,&aux) == REDIS_ERR)\n        return REDIS_ERR;\n\n    /* For the blocking context, flush output buffer and read reply */\n    if (aux == NULL && c->flags & REDIS_BLOCK) {\n        /* Write until done */\n        do {\n            if (redisBufferWrite(c,&wdone) == REDIS_ERR)\n                return REDIS_ERR;\n        } while (!wdone);\n\n        /* Read until there is a reply */\n        do {\n            if (redisBufferRead(c) == REDIS_ERR)\n                return REDIS_ERR;\n\n            /* We loop here in case the user has specified a RESP3\n             * PUSH handler (e.g. for client tracking). */\n            do {\n                if (redisGetReplyFromReader(c,&aux) == REDIS_ERR)\n                    return REDIS_ERR;\n            } while (redisHandledPushReply(c, aux));\n        } while (aux == NULL);\n    }\n\n    /* Set reply or free it if we were passed NULL */\n    if (reply != NULL) {\n        *reply = aux;\n    } else {\n        freeReplyObject(aux);\n    }\n\n    return REDIS_OK;\n}\n\n\n/* Helper function for the redisAppendCommand* family of functions.\n *\n * Write a formatted command to the output buffer. When this family\n * is used, you need to call redisGetReply yourself to retrieve\n * the reply (or replies in pub/sub).\n */\nint __redisAppendCommand(redisContext *c, const char *cmd, size_t len) {\n    hisds newbuf;\n\n    newbuf = hi_sdscatlen(c->obuf,cmd,len);\n    if (newbuf == NULL) {\n        __redisSetError(c,REDIS_ERR_OOM,\"Out of memory\");\n        return REDIS_ERR;\n    }\n\n    c->obuf = newbuf;\n    return REDIS_OK;\n}\n\nint redisAppendFormattedCommand(redisContext *c, const char *cmd, size_t len) {\n\n    if (__redisAppendCommand(c, cmd, len) != REDIS_OK) {\n        return REDIS_ERR;\n    }\n\n    return REDIS_OK;\n}\n\nint redisvAppendCommand(redisContext *c, const char *format, va_list ap) {\n    char *cmd;\n    int len;\n\n    len = redisvFormatCommand(&cmd,format,ap);\n    if (len == -1) {\n        __redisSetError(c,REDIS_ERR_OOM,\"Out of memory\");\n        return REDIS_ERR;\n    } else if (len == -2) {\n        __redisSetError(c,REDIS_ERR_OTHER,\"Invalid format string\");\n        return REDIS_ERR;\n    }\n\n    if (__redisAppendCommand(c,cmd,len) != REDIS_OK) {\n        hi_free(cmd);\n        return REDIS_ERR;\n    }\n\n    hi_free(cmd);\n    return REDIS_OK;\n}\n\nint redisAppendCommand(redisContext *c, const char *format, ...) {\n    va_list ap;\n    int ret;\n\n    va_start(ap,format);\n    ret = redisvAppendCommand(c,format,ap);\n    va_end(ap);\n    return ret;\n}\n\nint redisAppendCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen) {\n    hisds cmd;\n    int len;\n\n    len = redisFormatSdsCommandArgv(&cmd,argc,argv,argvlen);\n    if (len == -1) {\n        __redisSetError(c,REDIS_ERR_OOM,\"Out of memory\");\n        return REDIS_ERR;\n    }\n\n    if (__redisAppendCommand(c,cmd,len) != REDIS_OK) {\n        hi_sdsfree(cmd);\n        return REDIS_ERR;\n    }\n\n    hi_sdsfree(cmd);\n    return REDIS_OK;\n}\n\n/* Helper function for the redisCommand* family of functions.\n *\n * Write a formatted command to the output buffer. If the given context is\n * blocking, immediately read the reply into the \"reply\" pointer. When the\n * context is non-blocking, the \"reply\" pointer will not be used and the\n * command is simply appended to the write buffer.\n *\n * Returns the reply when a reply was successfully retrieved. Returns NULL\n * otherwise. When NULL is returned in a blocking context, the error field\n * in the context will be set.\n */\nstatic void *__redisBlockForReply(redisContext *c) {\n    void *reply;\n\n    if (c->flags & REDIS_BLOCK) {\n        if (redisGetReply(c,&reply) != REDIS_OK)\n            return NULL;\n        return reply;\n    }\n    return NULL;\n}\n\nvoid *redisvCommand(redisContext *c, const char *format, va_list ap) {\n    if (redisvAppendCommand(c,format,ap) != REDIS_OK)\n        return NULL;\n    return __redisBlockForReply(c);\n}\n\nvoid *redisCommand(redisContext *c, const char *format, ...) {\n    va_list ap;\n    va_start(ap,format);\n    void *reply = redisvCommand(c,format,ap);\n    va_end(ap);\n    return reply;\n}\n\nvoid *redisCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen) {\n    if (redisAppendCommandArgv(c,argc,argv,argvlen) != REDIS_OK)\n        return NULL;\n    return __redisBlockForReply(c);\n}\n", "#include \"fmacros.h\"\n#include \"sockcompat.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifndef _WIN32\n#include <strings.h>\n#include <sys/time.h>\n#endif\n#include <assert.h>\n#include <signal.h>\n#include <errno.h>\n#include <limits.h>\n\n#include \"hiredis.h\"\n#include \"async.h\"\n#ifdef HIREDIS_TEST_SSL\n#include \"hiredis_ssl.h\"\n#endif\n#include \"net.h\"\n#include \"win32.h\"\n\nenum connection_type {\n    CONN_TCP,\n    CONN_UNIX,\n    CONN_FD,\n    CONN_SSL\n};\n\nstruct config {\n    enum connection_type type;\n\n    struct {\n        const char *host;\n        int port;\n        struct timeval timeout;\n    } tcp;\n\n    struct {\n        const char *path;\n    } unix_sock;\n\n    struct {\n        const char *host;\n        int port;\n        const char *ca_cert;\n        const char *cert;\n        const char *key;\n    } ssl;\n};\n\nstruct privdata {\n    int dtor_counter;\n};\n\nstruct pushCounters {\n    int nil;\n    int str;\n};\n\n#ifdef HIREDIS_TEST_SSL\nredisSSLContext *_ssl_ctx = NULL;\n#endif\n\n/* The following lines make up our testing \"framework\" :) */\nstatic int tests = 0, fails = 0, skips = 0;\n#define test(_s) { printf(\"#%02d \", ++tests); printf(_s); }\n#define test_cond(_c) if(_c) printf(\"\\033[0;32mPASSED\\033[0;0m\\n\"); else {printf(\"\\033[0;31mFAILED\\033[0;0m\\n\"); fails++;}\n#define test_skipped() { printf(\"\\033[01;33mSKIPPED\\033[0;0m\\n\"); skips++; }\n\nstatic long long usec(void) {\n#ifndef _MSC_VER\n    struct timeval tv;\n    gettimeofday(&tv,NULL);\n    return (((long long)tv.tv_sec)*1000000)+tv.tv_usec;\n#else\n    FILETIME ft;\n    GetSystemTimeAsFileTime(&ft);\n    return (((long long)ft.dwHighDateTime << 32) | ft.dwLowDateTime) / 10;\n#endif\n}\n\n/* The assert() calls below have side effects, so we need assert()\n * even if we are compiling without asserts (-DNDEBUG). */\n#ifdef NDEBUG\n#undef assert\n#define assert(e) (void)(e)\n#endif\n\n/* Helper to extract Redis version information.  Aborts on any failure. */\n#define REDIS_VERSION_FIELD \"redis_version:\"\nvoid get_redis_version(redisContext *c, int *majorptr, int *minorptr) {\n    redisReply *reply;\n    char *eptr, *s, *e;\n    int major, minor;\n\n    reply = redisCommand(c, \"INFO\");\n    if (reply == NULL || c->err || reply->type != REDIS_REPLY_STRING)\n        goto abort;\n    if ((s = strstr(reply->str, REDIS_VERSION_FIELD)) == NULL)\n        goto abort;\n\n    s += strlen(REDIS_VERSION_FIELD);\n\n    /* We need a field terminator and at least 'x.y.z' (5) bytes of data */\n    if ((e = strstr(s, \"\\r\\n\")) == NULL || (e - s) < 5)\n        goto abort;\n\n    /* Extract version info */\n    major = strtol(s, &eptr, 10);\n    if (*eptr != '.') goto abort;\n    minor = strtol(eptr+1, NULL, 10);\n\n    /* Push info the caller wants */\n    if (majorptr) *majorptr = major;\n    if (minorptr) *minorptr = minor;\n\n    freeReplyObject(reply);\n    return;\n\nabort:\n    freeReplyObject(reply);\n    fprintf(stderr, \"Error:  Cannot determine Redis version, aborting\\n\");\n    exit(1);\n}\n\nstatic redisContext *select_database(redisContext *c) {\n    redisReply *reply;\n\n    /* Switch to DB 9 for testing, now that we know we can chat. */\n    reply = redisCommand(c,\"SELECT 9\");\n    assert(reply != NULL);\n    freeReplyObject(reply);\n\n    /* Make sure the DB is emtpy */\n    reply = redisCommand(c,\"DBSIZE\");\n    assert(reply != NULL);\n    if (reply->type == REDIS_REPLY_INTEGER && reply->integer == 0) {\n        /* Awesome, DB 9 is empty and we can continue. */\n        freeReplyObject(reply);\n    } else {\n        printf(\"Database #9 is not empty, test can not continue\\n\");\n        exit(1);\n    }\n\n    return c;\n}\n\n/* Switch protocol */\nstatic void send_hello(redisContext *c, int version) {\n    redisReply *reply;\n    int expected;\n\n    reply = redisCommand(c, \"HELLO %d\", version);\n    expected = version == 3 ? REDIS_REPLY_MAP : REDIS_REPLY_ARRAY;\n    assert(reply != NULL && reply->type == expected);\n    freeReplyObject(reply);\n}\n\n/* Togggle client tracking */\nstatic void send_client_tracking(redisContext *c, const char *str) {\n    redisReply *reply;\n\n    reply = redisCommand(c, \"CLIENT TRACKING %s\", str);\n    assert(reply != NULL && reply->type == REDIS_REPLY_STATUS);\n    freeReplyObject(reply);\n}\n\nstatic int disconnect(redisContext *c, int keep_fd) {\n    redisReply *reply;\n\n    /* Make sure we're on DB 9. */\n    reply = redisCommand(c,\"SELECT 9\");\n    assert(reply != NULL);\n    freeReplyObject(reply);\n    reply = redisCommand(c,\"FLUSHDB\");\n    assert(reply != NULL);\n    freeReplyObject(reply);\n\n    /* Free the context as well, but keep the fd if requested. */\n    if (keep_fd)\n        return redisFreeKeepFd(c);\n    redisFree(c);\n    return -1;\n}\n\nstatic void do_ssl_handshake(redisContext *c) {\n#ifdef HIREDIS_TEST_SSL\n    redisInitiateSSLWithContext(c, _ssl_ctx);\n    if (c->err) {\n        printf(\"SSL error: %s\\n\", c->errstr);\n        redisFree(c);\n        exit(1);\n    }\n#else\n    (void) c;\n#endif\n}\n\nstatic redisContext *do_connect(struct config config) {\n    redisContext *c = NULL;\n\n    if (config.type == CONN_TCP) {\n        c = redisConnect(config.tcp.host, config.tcp.port);\n    } else if (config.type == CONN_SSL) {\n        c = redisConnect(config.ssl.host, config.ssl.port);\n    } else if (config.type == CONN_UNIX) {\n        c = redisConnectUnix(config.unix_sock.path);\n    } else if (config.type == CONN_FD) {\n        /* Create a dummy connection just to get an fd to inherit */\n        redisContext *dummy_ctx = redisConnectUnix(config.unix_sock.path);\n        if (dummy_ctx) {\n            int fd = disconnect(dummy_ctx, 1);\n            printf(\"Connecting to inherited fd %d\\n\", fd);\n            c = redisConnectFd(fd);\n        }\n    } else {\n        assert(NULL);\n    }\n\n    if (c == NULL) {\n        printf(\"Connection error: can't allocate redis context\\n\");\n        exit(1);\n    } else if (c->err) {\n        printf(\"Connection error: %s\\n\", c->errstr);\n        redisFree(c);\n        exit(1);\n    }\n\n    if (config.type == CONN_SSL) {\n        do_ssl_handshake(c);\n    }\n\n    return select_database(c);\n}\n\nstatic void do_reconnect(redisContext *c, struct config config) {\n    redisReconnect(c);\n\n    if (config.type == CONN_SSL) {\n        do_ssl_handshake(c);\n    }\n}\n\nstatic void test_format_commands(void) {\n    char *cmd;\n    int len;\n\n    test(\"Format command without interpolation: \");\n    len = redisFormatCommand(&cmd,\"SET foo bar\");\n    test_cond(strncmp(cmd,\"*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nfoo\\r\\n$3\\r\\nbar\\r\\n\",len) == 0 &&\n        len == 4+4+(3+2)+4+(3+2)+4+(3+2));\n    hi_free(cmd);\n\n    test(\"Format command with %%s string interpolation: \");\n    len = redisFormatCommand(&cmd,\"SET %s %s\",\"foo\",\"bar\");\n    test_cond(strncmp(cmd,\"*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nfoo\\r\\n$3\\r\\nbar\\r\\n\",len) == 0 &&\n        len == 4+4+(3+2)+4+(3+2)+4+(3+2));\n    hi_free(cmd);\n\n    test(\"Format command with %%s and an empty string: \");\n    len = redisFormatCommand(&cmd,\"SET %s %s\",\"foo\",\"\");\n    test_cond(strncmp(cmd,\"*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nfoo\\r\\n$0\\r\\n\\r\\n\",len) == 0 &&\n        len == 4+4+(3+2)+4+(3+2)+4+(0+2));\n    hi_free(cmd);\n\n    test(\"Format command with an empty string in between proper interpolations: \");\n    len = redisFormatCommand(&cmd,\"SET %s %s\",\"\",\"foo\");\n    test_cond(strncmp(cmd,\"*3\\r\\n$3\\r\\nSET\\r\\n$0\\r\\n\\r\\n$3\\r\\nfoo\\r\\n\",len) == 0 &&\n        len == 4+4+(3+2)+4+(0+2)+4+(3+2));\n    hi_free(cmd);\n\n    test(\"Format command with %%b string interpolation: \");\n    len = redisFormatCommand(&cmd,\"SET %b %b\",\"foo\",(size_t)3,\"b\\0r\",(size_t)3);\n    test_cond(strncmp(cmd,\"*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nfoo\\r\\n$3\\r\\nb\\0r\\r\\n\",len) == 0 &&\n        len == 4+4+(3+2)+4+(3+2)+4+(3+2));\n    hi_free(cmd);\n\n    test(\"Format command with %%b and an empty string: \");\n    len = redisFormatCommand(&cmd,\"SET %b %b\",\"foo\",(size_t)3,\"\",(size_t)0);\n    test_cond(strncmp(cmd,\"*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nfoo\\r\\n$0\\r\\n\\r\\n\",len) == 0 &&\n        len == 4+4+(3+2)+4+(3+2)+4+(0+2));\n    hi_free(cmd);\n\n    test(\"Format command with literal %%: \");\n    len = redisFormatCommand(&cmd,\"SET %% %%\");\n    test_cond(strncmp(cmd,\"*3\\r\\n$3\\r\\nSET\\r\\n$1\\r\\n%\\r\\n$1\\r\\n%\\r\\n\",len) == 0 &&\n        len == 4+4+(3+2)+4+(1+2)+4+(1+2));\n    hi_free(cmd);\n\n    /* Vararg width depends on the type. These tests make sure that the\n     * width is correctly determined using the format and subsequent varargs\n     * can correctly be interpolated. */\n#define INTEGER_WIDTH_TEST(fmt, type) do {                                                \\\n    type value = 123;                                                                     \\\n    test(\"Format command with printf-delegation (\" #type \"): \");                          \\\n    len = redisFormatCommand(&cmd,\"key:%08\" fmt \" str:%s\", value, \"hello\");               \\\n    test_cond(strncmp(cmd,\"*2\\r\\n$12\\r\\nkey:00000123\\r\\n$9\\r\\nstr:hello\\r\\n\",len) == 0 && \\\n        len == 4+5+(12+2)+4+(9+2));                                                       \\\n    hi_free(cmd);                                                                         \\\n} while(0)\n\n#define FLOAT_WIDTH_TEST(type) do {                                                       \\\n    type value = 123.0;                                                                   \\\n    test(\"Format command with printf-delegation (\" #type \"): \");                          \\\n    len = redisFormatCommand(&cmd,\"key:%08.3f str:%s\", value, \"hello\");                   \\\n    test_cond(strncmp(cmd,\"*2\\r\\n$12\\r\\nkey:0123.000\\r\\n$9\\r\\nstr:hello\\r\\n\",len) == 0 && \\\n        len == 4+5+(12+2)+4+(9+2));                                                       \\\n    hi_free(cmd);                                                                         \\\n} while(0)\n\n    INTEGER_WIDTH_TEST(\"d\", int);\n    INTEGER_WIDTH_TEST(\"hhd\", char);\n    INTEGER_WIDTH_TEST(\"hd\", short);\n    INTEGER_WIDTH_TEST(\"ld\", long);\n    INTEGER_WIDTH_TEST(\"lld\", long long);\n    INTEGER_WIDTH_TEST(\"u\", unsigned int);\n    INTEGER_WIDTH_TEST(\"hhu\", unsigned char);\n    INTEGER_WIDTH_TEST(\"hu\", unsigned short);\n    INTEGER_WIDTH_TEST(\"lu\", unsigned long);\n    INTEGER_WIDTH_TEST(\"llu\", unsigned long long);\n    FLOAT_WIDTH_TEST(float);\n    FLOAT_WIDTH_TEST(double);\n\n    test(\"Format command with invalid printf format: \");\n    len = redisFormatCommand(&cmd,\"key:%08p %b\",(void*)1234,\"foo\",(size_t)3);\n    test_cond(len == -1);\n\n    const char *argv[3];\n    argv[0] = \"SET\";\n    argv[1] = \"foo\\0xxx\";\n    argv[2] = \"bar\";\n    size_t lens[3] = { 3, 7, 3 };\n    int argc = 3;\n\n    test(\"Format command by passing argc/argv without lengths: \");\n    len = redisFormatCommandArgv(&cmd,argc,argv,NULL);\n    test_cond(strncmp(cmd,\"*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nfoo\\r\\n$3\\r\\nbar\\r\\n\",len) == 0 &&\n        len == 4+4+(3+2)+4+(3+2)+4+(3+2));\n    hi_free(cmd);\n\n    test(\"Format command by passing argc/argv with lengths: \");\n    len = redisFormatCommandArgv(&cmd,argc,argv,lens);\n    test_cond(strncmp(cmd,\"*3\\r\\n$3\\r\\nSET\\r\\n$7\\r\\nfoo\\0xxx\\r\\n$3\\r\\nbar\\r\\n\",len) == 0 &&\n        len == 4+4+(3+2)+4+(7+2)+4+(3+2));\n    hi_free(cmd);\n\n    hisds sds_cmd;\n\n    sds_cmd = NULL;\n    test(\"Format command into hisds by passing argc/argv without lengths: \");\n    len = redisFormatSdsCommandArgv(&sds_cmd,argc,argv,NULL);\n    test_cond(strncmp(sds_cmd,\"*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nfoo\\r\\n$3\\r\\nbar\\r\\n\",len) == 0 &&\n        len == 4+4+(3+2)+4+(3+2)+4+(3+2));\n    hi_sdsfree(sds_cmd);\n\n    sds_cmd = NULL;\n    test(\"Format command into hisds by passing argc/argv with lengths: \");\n    len = redisFormatSdsCommandArgv(&sds_cmd,argc,argv,lens);\n    test_cond(strncmp(sds_cmd,\"*3\\r\\n$3\\r\\nSET\\r\\n$7\\r\\nfoo\\0xxx\\r\\n$3\\r\\nbar\\r\\n\",len) == 0 &&\n        len == 4+4+(3+2)+4+(7+2)+4+(3+2));\n    hi_sdsfree(sds_cmd);\n}\n\nstatic void test_append_formatted_commands(struct config config) {\n    redisContext *c;\n    redisReply *reply;\n    char *cmd;\n    int len;\n\n    c = do_connect(config);\n\n    test(\"Append format command: \");\n\n    len = redisFormatCommand(&cmd, \"SET foo bar\");\n\n    test_cond(redisAppendFormattedCommand(c, cmd, len) == REDIS_OK);\n\n    assert(redisGetReply(c, (void*)&reply) == REDIS_OK);\n\n    hi_free(cmd);\n    freeReplyObject(reply);\n\n    disconnect(c, 0);\n}\n\nstatic void test_reply_reader(void) {\n    redisReader *reader;\n    void *reply, *root;\n    int ret;\n    int i;\n\n    test(\"Error handling in reply parser: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader,(char*)\"@foo\\r\\n\",6);\n    ret = redisReaderGetReply(reader,NULL);\n    test_cond(ret == REDIS_ERR &&\n              strcasecmp(reader->errstr,\"Protocol error, got \\\"@\\\" as reply type byte\") == 0);\n    redisReaderFree(reader);\n\n    /* when the reply already contains multiple items, they must be free'd\n     * on an error. valgrind will bark when this doesn't happen. */\n    test(\"Memory cleanup in reply parser: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader,(char*)\"*2\\r\\n\",4);\n    redisReaderFeed(reader,(char*)\"$5\\r\\nhello\\r\\n\",11);\n    redisReaderFeed(reader,(char*)\"@foo\\r\\n\",6);\n    ret = redisReaderGetReply(reader,NULL);\n    test_cond(ret == REDIS_ERR &&\n              strcasecmp(reader->errstr,\"Protocol error, got \\\"@\\\" as reply type byte\") == 0);\n    redisReaderFree(reader);\n\n    reader = redisReaderCreate();\n    test(\"Can handle arbitrarily nested multi-bulks: \");\n    for (i = 0; i < 128; i++) {\n        redisReaderFeed(reader,(char*)\"*1\\r\\n\", 4);\n    }\n    redisReaderFeed(reader,(char*)\"$6\\r\\nLOLWUT\\r\\n\",12);\n    ret = redisReaderGetReply(reader,&reply);\n    root = reply; /* Keep track of the root reply */\n    test_cond(ret == REDIS_OK &&\n        ((redisReply*)reply)->type == REDIS_REPLY_ARRAY &&\n        ((redisReply*)reply)->elements == 1);\n\n    test(\"Can parse arbitrarily nested multi-bulks correctly: \");\n    while(i--) {\n        assert(reply != NULL && ((redisReply*)reply)->type == REDIS_REPLY_ARRAY);\n        reply = ((redisReply*)reply)->element[0];\n    }\n    test_cond(((redisReply*)reply)->type == REDIS_REPLY_STRING &&\n        !memcmp(((redisReply*)reply)->str, \"LOLWUT\", 6));\n    freeReplyObject(root);\n    redisReaderFree(reader);\n\n    test(\"Correctly parses LLONG_MAX: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \":9223372036854775807\\r\\n\",22);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_OK &&\n            ((redisReply*)reply)->type == REDIS_REPLY_INTEGER &&\n            ((redisReply*)reply)->integer == LLONG_MAX);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    test(\"Set error when > LLONG_MAX: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \":9223372036854775808\\r\\n\",22);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR &&\n              strcasecmp(reader->errstr,\"Bad integer value\") == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    test(\"Correctly parses LLONG_MIN: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \":-9223372036854775808\\r\\n\",23);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_OK &&\n            ((redisReply*)reply)->type == REDIS_REPLY_INTEGER &&\n            ((redisReply*)reply)->integer == LLONG_MIN);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    test(\"Set error when < LLONG_MIN: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \":-9223372036854775809\\r\\n\",23);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR &&\n              strcasecmp(reader->errstr,\"Bad integer value\") == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    test(\"Set error when array < -1: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \"*-2\\r\\n+asdf\\r\\n\",12);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR &&\n              strcasecmp(reader->errstr,\"Multi-bulk length out of range\") == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    test(\"Set error when bulk < -1: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \"$-2\\r\\nasdf\\r\\n\",11);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR &&\n              strcasecmp(reader->errstr,\"Bulk string length out of range\") == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    test(\"Can configure maximum multi-bulk elements: \");\n    reader = redisReaderCreate();\n    reader->maxelements = 1024;\n    redisReaderFeed(reader, \"*1025\\r\\n\", 7);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR &&\n              strcasecmp(reader->errstr, \"Multi-bulk length out of range\") == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n#if LLONG_MAX > SIZE_MAX\n    test(\"Set error when array > SIZE_MAX: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \"*9223372036854775807\\r\\n+asdf\\r\\n\",29);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR &&\n            strcasecmp(reader->errstr,\"Multi-bulk length out of range\") == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    test(\"Set error when bulk > SIZE_MAX: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \"$9223372036854775807\\r\\nasdf\\r\\n\",28);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR &&\n            strcasecmp(reader->errstr,\"Bulk string length out of range\") == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n#endif\n\n    test(\"Works with NULL functions for reply: \");\n    reader = redisReaderCreate();\n    reader->fn = NULL;\n    redisReaderFeed(reader,(char*)\"+OK\\r\\n\",5);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_OK && reply == (void*)REDIS_REPLY_STATUS);\n    redisReaderFree(reader);\n\n    test(\"Works when a single newline (\\\\r\\\\n) covers two calls to feed: \");\n    reader = redisReaderCreate();\n    reader->fn = NULL;\n    redisReaderFeed(reader,(char*)\"+OK\\r\",4);\n    ret = redisReaderGetReply(reader,&reply);\n    assert(ret == REDIS_OK && reply == NULL);\n    redisReaderFeed(reader,(char*)\"\\n\",1);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_OK && reply == (void*)REDIS_REPLY_STATUS);\n    redisReaderFree(reader);\n\n    test(\"Don't reset state after protocol error: \");\n    reader = redisReaderCreate();\n    reader->fn = NULL;\n    redisReaderFeed(reader,(char*)\"x\",1);\n    ret = redisReaderGetReply(reader,&reply);\n    assert(ret == REDIS_ERR);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR && reply == NULL);\n    redisReaderFree(reader);\n\n    /* Regression test for issue #45 on GitHub. */\n    test(\"Don't do empty allocation for empty multi bulk: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader,(char*)\"*0\\r\\n\",4);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_OK &&\n        ((redisReply*)reply)->type == REDIS_REPLY_ARRAY &&\n        ((redisReply*)reply)->elements == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    /* RESP3 verbatim strings (GitHub issue #802) */\n    test(\"Can parse RESP3 verbatim strings: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader,(char*)\"=10\\r\\ntxt:LOLWUT\\r\\n\",17);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_OK &&\n        ((redisReply*)reply)->type == REDIS_REPLY_VERB &&\n         !memcmp(((redisReply*)reply)->str,\"LOLWUT\", 6));\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    /* RESP3 push messages (Github issue #815) */\n    test(\"Can parse RESP3 push messages: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader,(char*)\">2\\r\\n$6\\r\\nLOLWUT\\r\\n:42\\r\\n\",21);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_OK &&\n        ((redisReply*)reply)->type == REDIS_REPLY_PUSH &&\n        ((redisReply*)reply)->elements == 2 &&\n        ((redisReply*)reply)->element[0]->type == REDIS_REPLY_STRING &&\n        !memcmp(((redisReply*)reply)->element[0]->str,\"LOLWUT\",6) &&\n        ((redisReply*)reply)->element[1]->type == REDIS_REPLY_INTEGER &&\n        ((redisReply*)reply)->element[1]->integer == 42);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n}\n\nstatic void test_free_null(void) {\n    void *redisCtx = NULL;\n    void *reply = NULL;\n\n    test(\"Don't fail when redisFree is passed a NULL value: \");\n    redisFree(redisCtx);\n    test_cond(redisCtx == NULL);\n\n    test(\"Don't fail when freeReplyObject is passed a NULL value: \");\n    freeReplyObject(reply);\n    test_cond(reply == NULL);\n}\n\nstatic void *hi_malloc_fail(size_t size) {\n    (void)size;\n    return NULL;\n}\n\nstatic void *hi_calloc_fail(size_t nmemb, size_t size) {\n    (void)nmemb;\n    (void)size;\n    return NULL;\n}\n\nstatic void *hi_realloc_fail(void *ptr, size_t size) {\n    (void)ptr;\n    (void)size;\n    return NULL;\n}\n\nstatic void test_allocator_injection(void) {\n    hiredisAllocFuncs ha = {\n        .mallocFn = hi_malloc_fail,\n        .callocFn = hi_calloc_fail,\n        .reallocFn = hi_realloc_fail,\n        .strdupFn = strdup,\n        .freeFn = free,\n    };\n\n    // Override hiredis allocators\n    hiredisSetAllocators(&ha);\n\n    test(\"redisContext uses injected allocators: \");\n    redisContext *c = redisConnect(\"localhost\", 6379);\n    test_cond(c == NULL);\n\n    test(\"redisReader uses injected allocators: \");\n    redisReader *reader = redisReaderCreate();\n    test_cond(reader == NULL);\n\n    // Return allocators to default\n    hiredisResetAllocators();\n}\n\n#define HIREDIS_BAD_DOMAIN \"idontexist-noreally.com\"\nstatic void test_blocking_connection_errors(void) {\n    redisContext *c;\n    struct addrinfo hints = {.ai_family = AF_INET};\n    struct addrinfo *ai_tmp = NULL;\n\n    int rv = getaddrinfo(HIREDIS_BAD_DOMAIN, \"6379\", &hints, &ai_tmp);\n    if (rv != 0) {\n        // Address does *not* exist\n        test(\"Returns error when host cannot be resolved: \");\n        // First see if this domain name *actually* resolves to NXDOMAIN\n        c = redisConnect(HIREDIS_BAD_DOMAIN, 6379);\n        test_cond(\n            c->err == REDIS_ERR_OTHER &&\n            (strcmp(c->errstr, \"Name or service not known\") == 0 ||\n             strcmp(c->errstr, \"Can't resolve: \" HIREDIS_BAD_DOMAIN) == 0 ||\n             strcmp(c->errstr, \"Name does not resolve\") == 0 ||\n             strcmp(c->errstr, \"nodename nor servname provided, or not known\") == 0 ||\n             strcmp(c->errstr, \"No address associated with hostname\") == 0 ||\n             strcmp(c->errstr, \"Temporary failure in name resolution\") == 0 ||\n             strcmp(c->errstr, \"hostname nor servname provided, or not known\") == 0 ||\n             strcmp(c->errstr, \"no address associated with name\") == 0 ||\n             strcmp(c->errstr, \"No such host is known. \") == 0));\n        redisFree(c);\n    } else {\n        printf(\"Skipping NXDOMAIN test. Found evil ISP!\\n\");\n        freeaddrinfo(ai_tmp);\n    }\n\n#ifndef _WIN32\n    test(\"Returns error when the port is not open: \");\n    c = redisConnect((char*)\"localhost\", 1);\n    test_cond(c->err == REDIS_ERR_IO &&\n        strcmp(c->errstr,\"Connection refused\") == 0);\n    redisFree(c);\n\n    test(\"Returns error when the unix_sock socket path doesn't accept connections: \");\n    c = redisConnectUnix((char*)\"/tmp/idontexist.sock\");\n    test_cond(c->err == REDIS_ERR_IO); /* Don't care about the message... */\n    redisFree(c);\n#endif\n}\n\n/* Test push handler */\nvoid push_handler(void *privdata, void *r) {\n    struct pushCounters *pcounts = privdata;\n    redisReply *reply = r, *payload;\n\n    assert(reply && reply->type == REDIS_REPLY_PUSH && reply->elements == 2);\n\n    payload = reply->element[1];\n    if (payload->type == REDIS_REPLY_ARRAY) {\n        payload = payload->element[0];\n    }\n\n    if (payload->type == REDIS_REPLY_STRING) {\n        pcounts->str++;\n    } else if (payload->type == REDIS_REPLY_NIL) {\n        pcounts->nil++;\n    }\n\n    freeReplyObject(reply);\n}\n\n/* Dummy function just to test setting a callback with redisOptions */\nvoid push_handler_async(redisAsyncContext *ac, void *reply) {\n    (void)ac;\n    (void)reply;\n}\n\nstatic void test_resp3_push_handler(redisContext *c) {\n    struct pushCounters pc = {0};\n    redisPushFn *old = NULL;\n    redisReply *reply;\n    void *privdata;\n\n    /* Switch to RESP3 and turn on client tracking */\n    send_hello(c, 3);\n    send_client_tracking(c, \"ON\");\n    privdata = c->privdata;\n    c->privdata = &pc;\n\n    reply = redisCommand(c, \"GET key:0\");\n    assert(reply != NULL);\n    freeReplyObject(reply);\n\n    test(\"RESP3 PUSH messages are handled out of band by default: \");\n    reply = redisCommand(c, \"SET key:0 val:0\");\n    test_cond(reply != NULL && reply->type == REDIS_REPLY_STATUS);\n    freeReplyObject(reply);\n\n    assert((reply = redisCommand(c, \"GET key:0\")) != NULL);\n    freeReplyObject(reply);\n\n    old = redisSetPushCallback(c, push_handler);\n    test(\"We can set a custom RESP3 PUSH handler: \");\n    reply = redisCommand(c, \"SET key:0 val:0\");\n    test_cond(reply != NULL && reply->type == REDIS_REPLY_STATUS && pc.str == 1);\n    freeReplyObject(reply);\n\n    test(\"We properly handle a NIL invalidation payload: \");\n    reply = redisCommand(c, \"FLUSHDB\");\n    test_cond(reply != NULL && reply->type == REDIS_REPLY_STATUS && pc.nil == 1);\n    freeReplyObject(reply);\n\n    /* Unset the push callback and generate an invalidate message making\n     * sure it is not handled out of band. */\n    test(\"With no handler, PUSH replies come in-band: \");\n    redisSetPushCallback(c, NULL);\n    assert((reply = redisCommand(c, \"GET key:0\")) != NULL);\n    freeReplyObject(reply);\n    assert((reply = redisCommand(c, \"SET key:0 invalid\")) != NULL);\n    test_cond(reply->type == REDIS_REPLY_PUSH);\n    freeReplyObject(reply);\n\n    test(\"With no PUSH handler, no replies are lost: \");\n    assert(redisGetReply(c, (void**)&reply) == REDIS_OK);\n    test_cond(reply != NULL && reply->type == REDIS_REPLY_STATUS);\n    freeReplyObject(reply);\n\n    /* Return to the originally set PUSH handler */\n    assert(old != NULL);\n    redisSetPushCallback(c, old);\n\n    /* Switch back to RESP2 and disable tracking */\n    c->privdata = privdata;\n    send_client_tracking(c, \"OFF\");\n    send_hello(c, 2);\n}\n\nredisOptions get_redis_tcp_options(struct config config) {\n    redisOptions options = {0};\n    REDIS_OPTIONS_SET_TCP(&options, config.tcp.host, config.tcp.port);\n    return options;\n}\n\nstatic void test_resp3_push_options(struct config config) {\n    redisAsyncContext *ac;\n    redisContext *c;\n    redisOptions options;\n\n    test(\"We set a default RESP3 handler for redisContext: \");\n    options = get_redis_tcp_options(config);\n    assert((c = redisConnectWithOptions(&options)) != NULL);\n    test_cond(c->push_cb != NULL);\n    redisFree(c);\n\n    test(\"We don't set a default RESP3 push handler for redisAsyncContext: \");\n    options = get_redis_tcp_options(config);\n    assert((ac = redisAsyncConnectWithOptions(&options)) != NULL);\n    test_cond(ac->c.push_cb == NULL);\n    redisAsyncFree(ac);\n\n    test(\"Our REDIS_OPT_NO_PUSH_AUTOFREE flag works: \");\n    options = get_redis_tcp_options(config);\n    options.options |= REDIS_OPT_NO_PUSH_AUTOFREE;\n    assert((c = redisConnectWithOptions(&options)) != NULL);\n    test_cond(c->push_cb == NULL);\n    redisFree(c);\n\n    test(\"We can use redisOptions to set a custom PUSH handler for redisContext: \");\n    options = get_redis_tcp_options(config);\n    options.push_cb = push_handler;\n    assert((c = redisConnectWithOptions(&options)) != NULL);\n    test_cond(c->push_cb == push_handler);\n    redisFree(c);\n\n    test(\"We can use redisOptions to set a custom PUSH handler for redisAsyncContext: \");\n    options = get_redis_tcp_options(config);\n    options.async_push_cb = push_handler_async;\n    assert((ac = redisAsyncConnectWithOptions(&options)) != NULL);\n    test_cond(ac->push_cb == push_handler_async);\n    redisAsyncFree(ac);\n}\n\nvoid free_privdata(void *privdata) {\n    struct privdata *data = privdata;\n    data->dtor_counter++;\n}\n\nstatic void test_privdata_hooks(struct config config) {\n    struct privdata data = {0};\n    redisOptions options;\n    redisContext *c;\n\n    test(\"We can use redisOptions to set privdata: \");\n    options = get_redis_tcp_options(config);\n    REDIS_OPTIONS_SET_PRIVDATA(&options, &data, free_privdata);\n    assert((c = redisConnectWithOptions(&options)) != NULL);\n    test_cond(c->privdata == &data);\n\n    test(\"Our privdata destructor fires when we free the context: \");\n    redisFree(c);\n    test_cond(data.dtor_counter == 1);\n}\n\nstatic void test_blocking_connection(struct config config) {\n    redisContext *c;\n    redisReply *reply;\n    int major;\n\n    c = do_connect(config);\n\n    test(\"Is able to deliver commands: \");\n    reply = redisCommand(c,\"PING\");\n    test_cond(reply->type == REDIS_REPLY_STATUS &&\n        strcasecmp(reply->str,\"pong\") == 0)\n    freeReplyObject(reply);\n\n    test(\"Is a able to send commands verbatim: \");\n    reply = redisCommand(c,\"SET foo bar\");\n    test_cond (reply->type == REDIS_REPLY_STATUS &&\n        strcasecmp(reply->str,\"ok\") == 0)\n    freeReplyObject(reply);\n\n    test(\"%%s String interpolation works: \");\n    reply = redisCommand(c,\"SET %s %s\",\"foo\",\"hello world\");\n    freeReplyObject(reply);\n    reply = redisCommand(c,\"GET foo\");\n    test_cond(reply->type == REDIS_REPLY_STRING &&\n        strcmp(reply->str,\"hello world\") == 0);\n    freeReplyObject(reply);\n\n    test(\"%%b String interpolation works: \");\n    reply = redisCommand(c,\"SET %b %b\",\"foo\",(size_t)3,\"hello\\x00world\",(size_t)11);\n    freeReplyObject(reply);\n    reply = redisCommand(c,\"GET foo\");\n    test_cond(reply->type == REDIS_REPLY_STRING &&\n        memcmp(reply->str,\"hello\\x00world\",11) == 0)\n\n    test(\"Binary reply length is correct: \");\n    test_cond(reply->len == 11)\n    freeReplyObject(reply);\n\n    test(\"Can parse nil replies: \");\n    reply = redisCommand(c,\"GET nokey\");\n    test_cond(reply->type == REDIS_REPLY_NIL)\n    freeReplyObject(reply);\n\n    /* test 7 */\n    test(\"Can parse integer replies: \");\n    reply = redisCommand(c,\"INCR mycounter\");\n    test_cond(reply->type == REDIS_REPLY_INTEGER && reply->integer == 1)\n    freeReplyObject(reply);\n\n    test(\"Can parse multi bulk replies: \");\n    freeReplyObject(redisCommand(c,\"LPUSH mylist foo\"));\n    freeReplyObject(redisCommand(c,\"LPUSH mylist bar\"));\n    reply = redisCommand(c,\"LRANGE mylist 0 -1\");\n    test_cond(reply->type == REDIS_REPLY_ARRAY &&\n              reply->elements == 2 &&\n              !memcmp(reply->element[0]->str,\"bar\",3) &&\n              !memcmp(reply->element[1]->str,\"foo\",3))\n    freeReplyObject(reply);\n\n    /* m/e with multi bulk reply *before* other reply.\n     * specifically test ordering of reply items to parse. */\n    test(\"Can handle nested multi bulk replies: \");\n    freeReplyObject(redisCommand(c,\"MULTI\"));\n    freeReplyObject(redisCommand(c,\"LRANGE mylist 0 -1\"));\n    freeReplyObject(redisCommand(c,\"PING\"));\n    reply = (redisCommand(c,\"EXEC\"));\n    test_cond(reply->type == REDIS_REPLY_ARRAY &&\n              reply->elements == 2 &&\n              reply->element[0]->type == REDIS_REPLY_ARRAY &&\n              reply->element[0]->elements == 2 &&\n              !memcmp(reply->element[0]->element[0]->str,\"bar\",3) &&\n              !memcmp(reply->element[0]->element[1]->str,\"foo\",3) &&\n              reply->element[1]->type == REDIS_REPLY_STATUS &&\n              strcasecmp(reply->element[1]->str,\"pong\") == 0);\n    freeReplyObject(reply);\n\n    /* Make sure passing NULL to redisGetReply is safe */\n    test(\"Can pass NULL to redisGetReply: \");\n    assert(redisAppendCommand(c, \"PING\") == REDIS_OK);\n    test_cond(redisGetReply(c, NULL) == REDIS_OK);\n\n    get_redis_version(c, &major, NULL);\n    if (major >= 6) test_resp3_push_handler(c);\n    test_resp3_push_options(config);\n\n    test_privdata_hooks(config);\n\n    disconnect(c, 0);\n}\n\n/* Send DEBUG SLEEP 0 to detect if we have this command */\nstatic int detect_debug_sleep(redisContext *c) {\n    int detected;\n    redisReply *reply = redisCommand(c, \"DEBUG SLEEP 0\\r\\n\");\n\n    if (reply == NULL || c->err) {\n        const char *cause = c->err ? c->errstr : \"(none)\";\n        fprintf(stderr, \"Error testing for DEBUG SLEEP (Redis error: %s), exiting\\n\", cause);\n        exit(-1);\n    }\n\n    detected = reply->type == REDIS_REPLY_STATUS;\n    freeReplyObject(reply);\n\n    return detected;\n}\n\nstatic void test_blocking_connection_timeouts(struct config config) {\n    redisContext *c;\n    redisReply *reply;\n    ssize_t s;\n    const char *sleep_cmd = \"DEBUG SLEEP 3\\r\\n\";\n    struct timeval tv;\n\n    c = do_connect(config);\n    test(\"Successfully completes a command when the timeout is not exceeded: \");\n    reply = redisCommand(c,\"SET foo fast\");\n    freeReplyObject(reply);\n    tv.tv_sec = 0;\n    tv.tv_usec = 10000;\n    redisSetTimeout(c, tv);\n    reply = redisCommand(c, \"GET foo\");\n    test_cond(reply != NULL && reply->type == REDIS_REPLY_STRING && memcmp(reply->str, \"fast\", 4) == 0);\n    freeReplyObject(reply);\n    disconnect(c, 0);\n\n    c = do_connect(config);\n    test(\"Does not return a reply when the command times out: \");\n    if (detect_debug_sleep(c)) {\n        redisAppendFormattedCommand(c, sleep_cmd, strlen(sleep_cmd));\n        s = c->funcs->write(c);\n        tv.tv_sec = 0;\n        tv.tv_usec = 10000;\n        redisSetTimeout(c, tv);\n        reply = redisCommand(c, \"GET foo\");\n#ifndef _WIN32\n        test_cond(s > 0 && reply == NULL && c->err == REDIS_ERR_IO &&\n                  strcmp(c->errstr, \"Resource temporarily unavailable\") == 0);\n#else\n        test_cond(s > 0 && reply == NULL && c->err == REDIS_ERR_TIMEOUT &&\n                  strcmp(c->errstr, \"recv timeout\") == 0);\n#endif\n        freeReplyObject(reply);\n    } else {\n        test_skipped();\n    }\n\n    test(\"Reconnect properly reconnects after a timeout: \");\n    do_reconnect(c, config);\n    reply = redisCommand(c, \"PING\");\n    test_cond(reply != NULL && reply->type == REDIS_REPLY_STATUS && strcmp(reply->str, \"PONG\") == 0);\n    freeReplyObject(reply);\n\n    test(\"Reconnect properly uses owned parameters: \");\n    config.tcp.host = \"foo\";\n    config.unix_sock.path = \"foo\";\n    do_reconnect(c, config);\n    reply = redisCommand(c, \"PING\");\n    test_cond(reply != NULL && reply->type == REDIS_REPLY_STATUS && strcmp(reply->str, \"PONG\") == 0);\n    freeReplyObject(reply);\n\n    disconnect(c, 0);\n}\n\nstatic void test_blocking_io_errors(struct config config) {\n    redisContext *c;\n    redisReply *reply;\n    void *_reply;\n    int major, minor;\n\n    /* Connect to target given by config. */\n    c = do_connect(config);\n    get_redis_version(c, &major, &minor);\n\n    test(\"Returns I/O error when the connection is lost: \");\n    reply = redisCommand(c,\"QUIT\");\n    if (major > 2 || (major == 2 && minor > 0)) {\n        /* > 2.0 returns OK on QUIT and read() should be issued once more\n         * to know the descriptor is at EOF. */\n        test_cond(strcasecmp(reply->str,\"OK\") == 0 &&\n            redisGetReply(c,&_reply) == REDIS_ERR);\n        freeReplyObject(reply);\n    } else {\n        test_cond(reply == NULL);\n    }\n\n#ifndef _WIN32\n    /* On 2.0, QUIT will cause the connection to be closed immediately and\n     * the read(2) for the reply on QUIT will set the error to EOF.\n     * On >2.0, QUIT will return with OK and another read(2) needed to be\n     * issued to find out the socket was closed by the server. In both\n     * conditions, the error will be set to EOF. */\n    assert(c->err == REDIS_ERR_EOF &&\n        strcmp(c->errstr,\"Server closed the connection\") == 0);\n#endif\n    redisFree(c);\n\n    c = do_connect(config);\n    test(\"Returns I/O error on socket timeout: \");\n    struct timeval tv = { 0, 1000 };\n    assert(redisSetTimeout(c,tv) == REDIS_OK);\n    int respcode = redisGetReply(c,&_reply);\n#ifndef _WIN32\n    test_cond(respcode == REDIS_ERR && c->err == REDIS_ERR_IO && errno == EAGAIN);\n#else\n    test_cond(respcode == REDIS_ERR && c->err == REDIS_ERR_TIMEOUT);\n#endif\n    redisFree(c);\n}\n\nstatic void test_invalid_timeout_errors(struct config config) {\n    redisContext *c;\n\n    test(\"Set error when an invalid timeout usec value is given to redisConnectWithTimeout: \");\n\n    config.tcp.timeout.tv_sec = 0;\n    config.tcp.timeout.tv_usec = 10000001;\n\n    c = redisConnectWithTimeout(config.tcp.host, config.tcp.port, config.tcp.timeout);\n\n    test_cond(c->err == REDIS_ERR_IO && strcmp(c->errstr, \"Invalid timeout specified\") == 0);\n    redisFree(c);\n\n    test(\"Set error when an invalid timeout sec value is given to redisConnectWithTimeout: \");\n\n    config.tcp.timeout.tv_sec = (((LONG_MAX) - 999) / 1000) + 1;\n    config.tcp.timeout.tv_usec = 0;\n\n    c = redisConnectWithTimeout(config.tcp.host, config.tcp.port, config.tcp.timeout);\n\n    test_cond(c->err == REDIS_ERR_IO && strcmp(c->errstr, \"Invalid timeout specified\") == 0);\n    redisFree(c);\n}\n\n/* Wrap malloc to abort on failure so OOM checks don't make the test logic\n * harder to follow. */\nvoid *hi_malloc_safe(size_t size) {\n    void *ptr = hi_malloc(size);\n    if (ptr == NULL) {\n        fprintf(stderr, \"Error:  Out of memory\\n\");\n        exit(-1);\n    }\n\n    return ptr;\n}\n\nstatic void test_throughput(struct config config) {\n    redisContext *c = do_connect(config);\n    redisReply **replies;\n    int i, num;\n    long long t1, t2;\n\n    test(\"Throughput:\\n\");\n    for (i = 0; i < 500; i++)\n        freeReplyObject(redisCommand(c,\"LPUSH mylist foo\"));\n\n    num = 1000;\n    replies = hi_malloc_safe(sizeof(redisReply*)*num);\n    t1 = usec();\n    for (i = 0; i < num; i++) {\n        replies[i] = redisCommand(c,\"PING\");\n        assert(replies[i] != NULL && replies[i]->type == REDIS_REPLY_STATUS);\n    }\n    t2 = usec();\n    for (i = 0; i < num; i++) freeReplyObject(replies[i]);\n    hi_free(replies);\n    printf(\"\\t(%dx PING: %.3fs)\\n\", num, (t2-t1)/1000000.0);\n\n    replies = hi_malloc_safe(sizeof(redisReply*)*num);\n    t1 = usec();\n    for (i = 0; i < num; i++) {\n        replies[i] = redisCommand(c,\"LRANGE mylist 0 499\");\n        assert(replies[i] != NULL && replies[i]->type == REDIS_REPLY_ARRAY);\n        assert(replies[i] != NULL && replies[i]->elements == 500);\n    }\n    t2 = usec();\n    for (i = 0; i < num; i++) freeReplyObject(replies[i]);\n    hi_free(replies);\n    printf(\"\\t(%dx LRANGE with 500 elements: %.3fs)\\n\", num, (t2-t1)/1000000.0);\n\n    replies = hi_malloc_safe(sizeof(redisReply*)*num);\n    t1 = usec();\n    for (i = 0; i < num; i++) {\n        replies[i] = redisCommand(c, \"INCRBY incrkey %d\", 1000000);\n        assert(replies[i] != NULL && replies[i]->type == REDIS_REPLY_INTEGER);\n    }\n    t2 = usec();\n    for (i = 0; i < num; i++) freeReplyObject(replies[i]);\n    hi_free(replies);\n    printf(\"\\t(%dx INCRBY: %.3fs)\\n\", num, (t2-t1)/1000000.0);\n\n    num = 10000;\n    replies = hi_malloc_safe(sizeof(redisReply*)*num);\n    for (i = 0; i < num; i++)\n        redisAppendCommand(c,\"PING\");\n    t1 = usec();\n    for (i = 0; i < num; i++) {\n        assert(redisGetReply(c, (void*)&replies[i]) == REDIS_OK);\n        assert(replies[i] != NULL && replies[i]->type == REDIS_REPLY_STATUS);\n    }\n    t2 = usec();\n    for (i = 0; i < num; i++) freeReplyObject(replies[i]);\n    hi_free(replies);\n    printf(\"\\t(%dx PING (pipelined): %.3fs)\\n\", num, (t2-t1)/1000000.0);\n\n    replies = hi_malloc_safe(sizeof(redisReply*)*num);\n    for (i = 0; i < num; i++)\n        redisAppendCommand(c,\"LRANGE mylist 0 499\");\n    t1 = usec();\n    for (i = 0; i < num; i++) {\n        assert(redisGetReply(c, (void*)&replies[i]) == REDIS_OK);\n        assert(replies[i] != NULL && replies[i]->type == REDIS_REPLY_ARRAY);\n        assert(replies[i] != NULL && replies[i]->elements == 500);\n    }\n    t2 = usec();\n    for (i = 0; i < num; i++) freeReplyObject(replies[i]);\n    hi_free(replies);\n    printf(\"\\t(%dx LRANGE with 500 elements (pipelined): %.3fs)\\n\", num, (t2-t1)/1000000.0);\n\n    replies = hi_malloc_safe(sizeof(redisReply*)*num);\n    for (i = 0; i < num; i++)\n        redisAppendCommand(c,\"INCRBY incrkey %d\", 1000000);\n    t1 = usec();\n    for (i = 0; i < num; i++) {\n        assert(redisGetReply(c, (void*)&replies[i]) == REDIS_OK);\n        assert(replies[i] != NULL && replies[i]->type == REDIS_REPLY_INTEGER);\n    }\n    t2 = usec();\n    for (i = 0; i < num; i++) freeReplyObject(replies[i]);\n    hi_free(replies);\n    printf(\"\\t(%dx INCRBY (pipelined): %.3fs)\\n\", num, (t2-t1)/1000000.0);\n\n    disconnect(c, 0);\n}\n\n// static long __test_callback_flags = 0;\n// static void __test_callback(redisContext *c, void *privdata) {\n//     ((void)c);\n//     /* Shift to detect execution order */\n//     __test_callback_flags <<= 8;\n//     __test_callback_flags |= (long)privdata;\n// }\n//\n// static void __test_reply_callback(redisContext *c, redisReply *reply, void *privdata) {\n//     ((void)c);\n//     /* Shift to detect execution order */\n//     __test_callback_flags <<= 8;\n//     __test_callback_flags |= (long)privdata;\n//     if (reply) freeReplyObject(reply);\n// }\n//\n// static redisContext *__connect_nonblock() {\n//     /* Reset callback flags */\n//     __test_callback_flags = 0;\n//     return redisConnectNonBlock(\"127.0.0.1\", port, NULL);\n// }\n//\n// static void test_nonblocking_connection() {\n//     redisContext *c;\n//     int wdone = 0;\n//\n//     test(\"Calls command callback when command is issued: \");\n//     c = __connect_nonblock();\n//     redisSetCommandCallback(c,__test_callback,(void*)1);\n//     redisCommand(c,\"PING\");\n//     test_cond(__test_callback_flags == 1);\n//     redisFree(c);\n//\n//     test(\"Calls disconnect callback on redisDisconnect: \");\n//     c = __connect_nonblock();\n//     redisSetDisconnectCallback(c,__test_callback,(void*)2);\n//     redisDisconnect(c);\n//     test_cond(__test_callback_flags == 2);\n//     redisFree(c);\n//\n//     test(\"Calls disconnect callback and free callback on redisFree: \");\n//     c = __connect_nonblock();\n//     redisSetDisconnectCallback(c,__test_callback,(void*)2);\n//     redisSetFreeCallback(c,__test_callback,(void*)4);\n//     redisFree(c);\n//     test_cond(__test_callback_flags == ((2 << 8) | 4));\n//\n//     test(\"redisBufferWrite against empty write buffer: \");\n//     c = __connect_nonblock();\n//     test_cond(redisBufferWrite(c,&wdone) == REDIS_OK && wdone == 1);\n//     redisFree(c);\n//\n//     test(\"redisBufferWrite against not yet connected fd: \");\n//     c = __connect_nonblock();\n//     redisCommand(c,\"PING\");\n//     test_cond(redisBufferWrite(c,NULL) == REDIS_ERR &&\n//               strncmp(c->error,\"write:\",6) == 0);\n//     redisFree(c);\n//\n//     test(\"redisBufferWrite against closed fd: \");\n//     c = __connect_nonblock();\n//     redisCommand(c,\"PING\");\n//     redisDisconnect(c);\n//     test_cond(redisBufferWrite(c,NULL) == REDIS_ERR &&\n//               strncmp(c->error,\"write:\",6) == 0);\n//     redisFree(c);\n//\n//     test(\"Process callbacks in the right sequence: \");\n//     c = __connect_nonblock();\n//     redisCommandWithCallback(c,__test_reply_callback,(void*)1,\"PING\");\n//     redisCommandWithCallback(c,__test_reply_callback,(void*)2,\"PING\");\n//     redisCommandWithCallback(c,__test_reply_callback,(void*)3,\"PING\");\n//\n//     /* Write output buffer */\n//     wdone = 0;\n//     while(!wdone) {\n//         usleep(500);\n//         redisBufferWrite(c,&wdone);\n//     }\n//\n//     /* Read until at least one callback is executed (the 3 replies will\n//      * arrive in a single packet, causing all callbacks to be executed in\n//      * a single pass). */\n//     while(__test_callback_flags == 0) {\n//         assert(redisBufferRead(c) == REDIS_OK);\n//         redisProcessCallbacks(c);\n//     }\n//     test_cond(__test_callback_flags == 0x010203);\n//     redisFree(c);\n//\n//     test(\"redisDisconnect executes pending callbacks with NULL reply: \");\n//     c = __connect_nonblock();\n//     redisSetDisconnectCallback(c,__test_callback,(void*)1);\n//     redisCommandWithCallback(c,__test_reply_callback,(void*)2,\"PING\");\n//     redisDisconnect(c);\n//     test_cond(__test_callback_flags == 0x0201);\n//     redisFree(c);\n// }\n\nint main(int argc, char **argv) {\n    struct config cfg = {\n        .tcp = {\n            .host = \"127.0.0.1\",\n            .port = 6379\n        },\n        .unix_sock = {\n            .path = \"/tmp/redis.sock\"\n        }\n    };\n    int throughput = 1;\n    int test_inherit_fd = 1;\n    int skips_as_fails = 0;\n    int test_unix_socket;\n\n    /* Parse command line options. */\n    argv++; argc--;\n    while (argc) {\n        if (argc >= 2 && !strcmp(argv[0],\"-h\")) {\n            argv++; argc--;\n            cfg.tcp.host = argv[0];\n        } else if (argc >= 2 && !strcmp(argv[0],\"-p\")) {\n            argv++; argc--;\n            cfg.tcp.port = atoi(argv[0]);\n        } else if (argc >= 2 && !strcmp(argv[0],\"-s\")) {\n            argv++; argc--;\n            cfg.unix_sock.path = argv[0];\n        } else if (argc >= 1 && !strcmp(argv[0],\"--skip-throughput\")) {\n            throughput = 0;\n        } else if (argc >= 1 && !strcmp(argv[0],\"--skip-inherit-fd\")) {\n            test_inherit_fd = 0;\n        } else if (argc >= 1 && !strcmp(argv[0],\"--skips-as-fails\")) {\n            skips_as_fails = 1;\n#ifdef HIREDIS_TEST_SSL\n        } else if (argc >= 2 && !strcmp(argv[0],\"--ssl-port\")) {\n            argv++; argc--;\n            cfg.ssl.port = atoi(argv[0]);\n        } else if (argc >= 2 && !strcmp(argv[0],\"--ssl-host\")) {\n            argv++; argc--;\n            cfg.ssl.host = argv[0];\n        } else if (argc >= 2 && !strcmp(argv[0],\"--ssl-ca-cert\")) {\n            argv++; argc--;\n            cfg.ssl.ca_cert  = argv[0];\n        } else if (argc >= 2 && !strcmp(argv[0],\"--ssl-cert\")) {\n            argv++; argc--;\n            cfg.ssl.cert = argv[0];\n        } else if (argc >= 2 && !strcmp(argv[0],\"--ssl-key\")) {\n            argv++; argc--;\n            cfg.ssl.key = argv[0];\n#endif\n        } else {\n            fprintf(stderr, \"Invalid argument: %s\\n\", argv[0]);\n            exit(1);\n        }\n        argv++; argc--;\n    }\n\n#ifndef _WIN32\n    /* Ignore broken pipe signal (for I/O error tests). */\n    signal(SIGPIPE, SIG_IGN);\n\n    test_unix_socket = access(cfg.unix_sock.path, F_OK) == 0;\n\n#else\n    /* Unix sockets don't exist in Windows */\n    test_unix_socket = 0;\n#endif\n\n    test_allocator_injection();\n\n    test_format_commands();\n    test_reply_reader();\n    test_blocking_connection_errors();\n    test_free_null();\n\n    printf(\"\\nTesting against TCP connection (%s:%d):\\n\", cfg.tcp.host, cfg.tcp.port);\n    cfg.type = CONN_TCP;\n    test_blocking_connection(cfg);\n    test_blocking_connection_timeouts(cfg);\n    test_blocking_io_errors(cfg);\n    test_invalid_timeout_errors(cfg);\n    test_append_formatted_commands(cfg);\n    if (throughput) test_throughput(cfg);\n\n    printf(\"\\nTesting against Unix socket connection (%s): \", cfg.unix_sock.path);\n    if (test_unix_socket) {\n        printf(\"\\n\");\n        cfg.type = CONN_UNIX;\n        test_blocking_connection(cfg);\n        test_blocking_connection_timeouts(cfg);\n        test_blocking_io_errors(cfg);\n        if (throughput) test_throughput(cfg);\n    } else {\n        test_skipped();\n    }\n\n#ifdef HIREDIS_TEST_SSL\n    if (cfg.ssl.port && cfg.ssl.host) {\n\n        redisInitOpenSSL();\n        _ssl_ctx = redisCreateSSLContext(cfg.ssl.ca_cert, NULL, cfg.ssl.cert, cfg.ssl.key, NULL, NULL);\n        assert(_ssl_ctx != NULL);\n\n        printf(\"\\nTesting against SSL connection (%s:%d):\\n\", cfg.ssl.host, cfg.ssl.port);\n        cfg.type = CONN_SSL;\n\n        test_blocking_connection(cfg);\n        test_blocking_connection_timeouts(cfg);\n        test_blocking_io_errors(cfg);\n        test_invalid_timeout_errors(cfg);\n        test_append_formatted_commands(cfg);\n        if (throughput) test_throughput(cfg);\n\n        redisFreeSSLContext(_ssl_ctx);\n        _ssl_ctx = NULL;\n    }\n#endif\n\n    if (test_inherit_fd) {\n        printf(\"\\nTesting against inherited fd (%s): \", cfg.unix_sock.path);\n        if (test_unix_socket) {\n            printf(\"\\n\");\n            cfg.type = CONN_FD;\n            test_blocking_connection(cfg);\n        } else {\n            test_skipped();\n        }\n    }\n\n    if (fails || (skips_as_fails && skips)) {\n        printf(\"*** %d TESTS FAILED ***\\n\", fails);\n        if (skips) {\n            printf(\"*** %d TESTS SKIPPED ***\\n\", skips);\n        }\n        return 1;\n    }\n\n    printf(\"ALL TESTS PASSED (%d skipped)\\n\", skips);\n    return 0;\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2009-2011, Salvatore Sanfilippo <antirez at gmail dot com>\n * Copyright (c) 2010-2014, Pieter Noordhuis <pcnoordhuis at gmail dot com>\n * Copyright (c) 2015, Matt Stancliff <matt at genges dot com>,\n *                     Jan-Erik Rediger <janerik at fnordig dot com>\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"fmacros.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <errno.h>\n#include <ctype.h>\n\n#include \"hiredis.h\"\n#include \"net.h\"\n#include \"sds.h\"\n#include \"async.h\"\n#include \"win32.h\"\n\nextern int redisContextUpdateConnectTimeout(redisContext *c, const struct timeval *timeout);\nextern int redisContextUpdateCommandTimeout(redisContext *c, const struct timeval *timeout);\n\nstatic redisContextFuncs redisContextDefaultFuncs = {\n    .free_privctx = NULL,\n    .async_read = redisAsyncRead,\n    .async_write = redisAsyncWrite,\n    .read = redisNetRead,\n    .write = redisNetWrite\n};\n\nstatic redisReply *createReplyObject(int type);\nstatic void *createStringObject(const redisReadTask *task, char *str, size_t len);\nstatic void *createArrayObject(const redisReadTask *task, size_t elements);\nstatic void *createIntegerObject(const redisReadTask *task, long long value);\nstatic void *createDoubleObject(const redisReadTask *task, double value, char *str, size_t len);\nstatic void *createNilObject(const redisReadTask *task);\nstatic void *createBoolObject(const redisReadTask *task, int bval);\n\n/* Default set of functions to build the reply. Keep in mind that such a\n * function returning NULL is interpreted as OOM. */\nstatic redisReplyObjectFunctions defaultFunctions = {\n    createStringObject,\n    createArrayObject,\n    createIntegerObject,\n    createDoubleObject,\n    createNilObject,\n    createBoolObject,\n    freeReplyObject\n};\n\n/* Create a reply object */\nstatic redisReply *createReplyObject(int type) {\n    redisReply *r = hi_calloc(1,sizeof(*r));\n\n    if (r == NULL)\n        return NULL;\n\n    r->type = type;\n    return r;\n}\n\n/* Free a reply object */\nvoid freeReplyObject(void *reply) {\n    redisReply *r = reply;\n    size_t j;\n\n    if (r == NULL)\n        return;\n\n    switch(r->type) {\n    case REDIS_REPLY_INTEGER:\n        break; /* Nothing to free */\n    case REDIS_REPLY_ARRAY:\n    case REDIS_REPLY_MAP:\n    case REDIS_REPLY_SET:\n    case REDIS_REPLY_PUSH:\n        if (r->element != NULL) {\n            for (j = 0; j < r->elements; j++)\n                freeReplyObject(r->element[j]);\n            hi_free(r->element);\n        }\n        break;\n    case REDIS_REPLY_ERROR:\n    case REDIS_REPLY_STATUS:\n    case REDIS_REPLY_STRING:\n    case REDIS_REPLY_DOUBLE:\n    case REDIS_REPLY_VERB:\n        hi_free(r->str);\n        break;\n    }\n    hi_free(r);\n}\n\nstatic void *createStringObject(const redisReadTask *task, char *str, size_t len) {\n    redisReply *r, *parent;\n    char *buf;\n\n    r = createReplyObject(task->type);\n    if (r == NULL)\n        return NULL;\n\n    assert(task->type == REDIS_REPLY_ERROR  ||\n           task->type == REDIS_REPLY_STATUS ||\n           task->type == REDIS_REPLY_STRING ||\n           task->type == REDIS_REPLY_VERB);\n\n    /* Copy string value */\n    if (task->type == REDIS_REPLY_VERB) {\n        buf = hi_malloc(len-4+1); /* Skip 4 bytes of verbatim type header. */\n        if (buf == NULL) goto oom;\n\n        memcpy(r->vtype,str,3);\n        r->vtype[3] = '\\0';\n        memcpy(buf,str+4,len-4);\n        buf[len-4] = '\\0';\n        r->len = len - 4;\n    } else {\n        buf = hi_malloc(len+1);\n        if (buf == NULL) goto oom;\n\n        memcpy(buf,str,len);\n        buf[len] = '\\0';\n        r->len = len;\n    }\n    r->str = buf;\n\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET ||\n               parent->type == REDIS_REPLY_PUSH);\n        parent->element[task->idx] = r;\n    }\n    return r;\n\noom:\n    freeReplyObject(r);\n    return NULL;\n}\n\nstatic void *createArrayObject(const redisReadTask *task, size_t elements) {\n    redisReply *r, *parent;\n\n    r = createReplyObject(task->type);\n    if (r == NULL)\n        return NULL;\n\n    if (elements > 0) {\n        if (SIZE_MAX / sizeof(redisReply*) < elements) return NULL;  /* Don't overflow */\n        r->element = hi_calloc(elements,sizeof(redisReply*));\n        if (r->element == NULL) {\n            freeReplyObject(r);\n            return NULL;\n        }\n    }\n\n    r->elements = elements;\n\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET ||\n               parent->type == REDIS_REPLY_PUSH);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}\n\nstatic void *createIntegerObject(const redisReadTask *task, long long value) {\n    redisReply *r, *parent;\n\n    r = createReplyObject(REDIS_REPLY_INTEGER);\n    if (r == NULL)\n        return NULL;\n\n    r->integer = value;\n\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET ||\n               parent->type == REDIS_REPLY_PUSH);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}\n\nstatic void *createDoubleObject(const redisReadTask *task, double value, char *str, size_t len) {\n    redisReply *r, *parent;\n\n    r = createReplyObject(REDIS_REPLY_DOUBLE);\n    if (r == NULL)\n        return NULL;\n\n    r->dval = value;\n    r->str = hi_malloc(len+1);\n    if (r->str == NULL) {\n        freeReplyObject(r);\n        return NULL;\n    }\n\n    /* The double reply also has the original protocol string representing a\n     * double as a null terminated string. This way the caller does not need\n     * to format back for string conversion, especially since Redis does efforts\n     * to make the string more human readable avoiding the calssical double\n     * decimal string conversion artifacts. */\n    memcpy(r->str, str, len);\n    r->str[len] = '\\0';\n\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}\n\nstatic void *createNilObject(const redisReadTask *task) {\n    redisReply *r, *parent;\n\n    r = createReplyObject(REDIS_REPLY_NIL);\n    if (r == NULL)\n        return NULL;\n\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET ||\n               parent->type == REDIS_REPLY_PUSH);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}\n\nstatic void *createBoolObject(const redisReadTask *task, int bval) {\n    redisReply *r, *parent;\n\n    r = createReplyObject(REDIS_REPLY_BOOL);\n    if (r == NULL)\n        return NULL;\n\n    r->integer = bval != 0;\n\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}\n\n/* Return the number of digits of 'v' when converted to string in radix 10.\n * Implementation borrowed from link in redis/src/util.c:string2ll(). */\nstatic uint32_t countDigits(uint64_t v) {\n  uint32_t result = 1;\n  for (;;) {\n    if (v < 10) return result;\n    if (v < 100) return result + 1;\n    if (v < 1000) return result + 2;\n    if (v < 10000) return result + 3;\n    v /= 10000U;\n    result += 4;\n  }\n}\n\n/* Helper that calculates the bulk length given a certain string length. */\nstatic size_t bulklen(size_t len) {\n    return 1+countDigits(len)+2+len+2;\n}\n\nint redisvFormatCommand(char **target, const char *format, va_list ap) {\n    const char *c = format;\n    char *cmd = NULL; /* final command */\n    int pos; /* position in final command */\n    hisds curarg, newarg; /* current argument */\n    int touched = 0; /* was the current argument touched? */\n    char **curargv = NULL, **newargv = NULL;\n    int argc = 0;\n    int totlen = 0;\n    int error_type = 0; /* 0 = no error; -1 = memory error; -2 = format error */\n    int j;\n\n    /* Abort if there is not target to set */\n    if (target == NULL)\n        return -1;\n\n    /* Build the command string accordingly to protocol */\n    curarg = hi_sdsempty();\n    if (curarg == NULL)\n        return -1;\n\n    while(*c != '\\0') {\n        if (*c != '%' || c[1] == '\\0') {\n            if (*c == ' ') {\n                if (touched) {\n                    newargv = hi_realloc(curargv,sizeof(char*)*(argc+1));\n                    if (newargv == NULL) goto memory_err;\n                    curargv = newargv;\n                    curargv[argc++] = curarg;\n                    totlen += bulklen(hi_sdslen(curarg));\n\n                    /* curarg is put in argv so it can be overwritten. */\n                    curarg = hi_sdsempty();\n                    if (curarg == NULL) goto memory_err;\n                    touched = 0;\n                }\n            } else {\n                newarg = hi_sdscatlen(curarg,c,1);\n                if (newarg == NULL) goto memory_err;\n                curarg = newarg;\n                touched = 1;\n            }\n        } else {\n            char *arg;\n            size_t size;\n\n            /* Set newarg so it can be checked even if it is not touched. */\n            newarg = curarg;\n\n            switch(c[1]) {\n            case 's':\n                arg = va_arg(ap,char*);\n                size = strlen(arg);\n                if (size > 0)\n                    newarg = hi_sdscatlen(curarg,arg,size);\n                break;\n            case 'b':\n                arg = va_arg(ap,char*);\n                size = va_arg(ap,size_t);\n                if (size > 0)\n                    newarg = hi_sdscatlen(curarg,arg,size);\n                break;\n            case '%':\n                newarg = hi_sdscat(curarg,\"%\");\n                break;\n            default:\n                /* Try to detect printf format */\n                {\n                    static const char intfmts[] = \"diouxX\";\n                    static const char flags[] = \"#0-+ \";\n                    char _format[16];\n                    const char *_p = c+1;\n                    size_t _l = 0;\n                    va_list _cpy;\n\n                    /* Flags */\n                    while (*_p != '\\0' && strchr(flags,*_p) != NULL) _p++;\n\n                    /* Field width */\n                    while (*_p != '\\0' && isdigit(*_p)) _p++;\n\n                    /* Precision */\n                    if (*_p == '.') {\n                        _p++;\n                        while (*_p != '\\0' && isdigit(*_p)) _p++;\n                    }\n\n                    /* Copy va_list before consuming with va_arg */\n                    va_copy(_cpy,ap);\n\n                    /* Integer conversion (without modifiers) */\n                    if (strchr(intfmts,*_p) != NULL) {\n                        va_arg(ap,int);\n                        goto fmt_valid;\n                    }\n\n                    /* Double conversion (without modifiers) */\n                    if (strchr(\"eEfFgGaA\",*_p) != NULL) {\n                        va_arg(ap,double);\n                        goto fmt_valid;\n                    }\n\n                    /* Size: char */\n                    if (_p[0] == 'h' && _p[1] == 'h') {\n                        _p += 2;\n                        if (*_p != '\\0' && strchr(intfmts,*_p) != NULL) {\n                            va_arg(ap,int); /* char gets promoted to int */\n                            goto fmt_valid;\n                        }\n                        goto fmt_invalid;\n                    }\n\n                    /* Size: short */\n                    if (_p[0] == 'h') {\n                        _p += 1;\n                        if (*_p != '\\0' && strchr(intfmts,*_p) != NULL) {\n                            va_arg(ap,int); /* short gets promoted to int */\n                            goto fmt_valid;\n                        }\n                        goto fmt_invalid;\n                    }\n\n                    /* Size: long long */\n                    if (_p[0] == 'l' && _p[1] == 'l') {\n                        _p += 2;\n                        if (*_p != '\\0' && strchr(intfmts,*_p) != NULL) {\n                            va_arg(ap,long long);\n                            goto fmt_valid;\n                        }\n                        goto fmt_invalid;\n                    }\n\n                    /* Size: long */\n                    if (_p[0] == 'l') {\n                        _p += 1;\n                        if (*_p != '\\0' && strchr(intfmts,*_p) != NULL) {\n                            va_arg(ap,long);\n                            goto fmt_valid;\n                        }\n                        goto fmt_invalid;\n                    }\n\n                fmt_invalid:\n                    va_end(_cpy);\n                    goto format_err;\n\n                fmt_valid:\n                    _l = (_p+1)-c;\n                    if (_l < sizeof(_format)-2) {\n                        memcpy(_format,c,_l);\n                        _format[_l] = '\\0';\n                        newarg = hi_sdscatvprintf(curarg,_format,_cpy);\n\n                        /* Update current position (note: outer blocks\n                         * increment c twice so compensate here) */\n                        c = _p-1;\n                    }\n\n                    va_end(_cpy);\n                    break;\n                }\n            }\n\n            if (newarg == NULL) goto memory_err;\n            curarg = newarg;\n\n            touched = 1;\n            c++;\n        }\n        c++;\n    }\n\n    /* Add the last argument if needed */\n    if (touched) {\n        newargv = hi_realloc(curargv,sizeof(char*)*(argc+1));\n        if (newargv == NULL) goto memory_err;\n        curargv = newargv;\n        curargv[argc++] = curarg;\n        totlen += bulklen(hi_sdslen(curarg));\n    } else {\n        hi_sdsfree(curarg);\n    }\n\n    /* Clear curarg because it was put in curargv or was free'd. */\n    curarg = NULL;\n\n    /* Add bytes needed to hold multi bulk count */\n    totlen += 1+countDigits(argc)+2;\n\n    /* Build the command at protocol level */\n    cmd = hi_malloc(totlen+1);\n    if (cmd == NULL) goto memory_err;\n\n    pos = sprintf(cmd,\"*%d\\r\\n\",argc);\n    for (j = 0; j < argc; j++) {\n        pos += sprintf(cmd+pos,\"$%zu\\r\\n\",hi_sdslen(curargv[j]));\n        memcpy(cmd+pos,curargv[j],hi_sdslen(curargv[j]));\n        pos += hi_sdslen(curargv[j]);\n        hi_sdsfree(curargv[j]);\n        cmd[pos++] = '\\r';\n        cmd[pos++] = '\\n';\n    }\n    assert(pos == totlen);\n    cmd[pos] = '\\0';\n\n    hi_free(curargv);\n    *target = cmd;\n    return totlen;\n\nformat_err:\n    error_type = -2;\n    goto cleanup;\n\nmemory_err:\n    error_type = -1;\n    goto cleanup;\n\ncleanup:\n    if (curargv) {\n        while(argc--)\n            hi_sdsfree(curargv[argc]);\n        hi_free(curargv);\n    }\n\n    hi_sdsfree(curarg);\n    hi_free(cmd);\n\n    return error_type;\n}\n\n/* Format a command according to the Redis protocol. This function\n * takes a format similar to printf:\n *\n * %s represents a C null terminated string you want to interpolate\n * %b represents a binary safe string\n *\n * When using %b you need to provide both the pointer to the string\n * and the length in bytes as a size_t. Examples:\n *\n * len = redisFormatCommand(target, \"GET %s\", mykey);\n * len = redisFormatCommand(target, \"SET %s %b\", mykey, myval, myvallen);\n */\nint redisFormatCommand(char **target, const char *format, ...) {\n    va_list ap;\n    int len;\n    va_start(ap,format);\n    len = redisvFormatCommand(target,format,ap);\n    va_end(ap);\n\n    /* The API says \"-1\" means bad result, but we now also return \"-2\" in some\n     * cases.  Force the return value to always be -1. */\n    if (len < 0)\n        len = -1;\n\n    return len;\n}\n\n/* Format a command according to the Redis protocol using an hisds string and\n * hi_sdscatfmt for the processing of arguments. This function takes the\n * number of arguments, an array with arguments and an array with their\n * lengths. If the latter is set to NULL, strlen will be used to compute the\n * argument lengths.\n */\nint redisFormatSdsCommandArgv(hisds *target, int argc, const char **argv,\n                              const size_t *argvlen)\n{\n    hisds cmd, aux;\n    unsigned long long totlen;\n    int j;\n    size_t len;\n\n    /* Abort on a NULL target */\n    if (target == NULL)\n        return -1;\n\n    /* Calculate our total size */\n    totlen = 1+countDigits(argc)+2;\n    for (j = 0; j < argc; j++) {\n        len = argvlen ? argvlen[j] : strlen(argv[j]);\n        totlen += bulklen(len);\n    }\n\n    /* Use an SDS string for command construction */\n    cmd = hi_sdsempty();\n    if (cmd == NULL)\n        return -1;\n\n    /* We already know how much storage we need */\n    aux = hi_sdsMakeRoomFor(cmd, totlen);\n    if (aux == NULL) {\n        hi_sdsfree(cmd);\n        return -1;\n    }\n\n    cmd = aux;\n\n    /* Construct command */\n    cmd = hi_sdscatfmt(cmd, \"*%i\\r\\n\", argc);\n    for (j=0; j < argc; j++) {\n        len = argvlen ? argvlen[j] : strlen(argv[j]);\n        cmd = hi_sdscatfmt(cmd, \"$%u\\r\\n\", len);\n        cmd = hi_sdscatlen(cmd, argv[j], len);\n        cmd = hi_sdscatlen(cmd, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n    }\n\n    assert(hi_sdslen(cmd)==totlen);\n\n    *target = cmd;\n    return totlen;\n}\n\nvoid redisFreeSdsCommand(hisds cmd) {\n    hi_sdsfree(cmd);\n}\n\n/* Format a command according to the Redis protocol. This function takes the\n * number of arguments, an array with arguments and an array with their\n * lengths. If the latter is set to NULL, strlen will be used to compute the\n * argument lengths.\n */\nint redisFormatCommandArgv(char **target, int argc, const char **argv, const size_t *argvlen) {\n    char *cmd = NULL; /* final command */\n    int pos; /* position in final command */\n    size_t len;\n    int totlen, j;\n\n    /* Abort on a NULL target */\n    if (target == NULL)\n        return -1;\n\n    /* Calculate number of bytes needed for the command */\n    totlen = 1+countDigits(argc)+2;\n    for (j = 0; j < argc; j++) {\n        len = argvlen ? argvlen[j] : strlen(argv[j]);\n        totlen += bulklen(len);\n    }\n\n    /* Build the command at protocol level */\n    cmd = hi_malloc(totlen+1);\n    if (cmd == NULL)\n        return -1;\n\n    pos = sprintf(cmd,\"*%d\\r\\n\",argc);\n    for (j = 0; j < argc; j++) {\n        len = argvlen ? argvlen[j] : strlen(argv[j]);\n        pos += sprintf(cmd+pos,\"$%zu\\r\\n\",len);\n        memcpy(cmd+pos,argv[j],len);\n        pos += len;\n        cmd[pos++] = '\\r';\n        cmd[pos++] = '\\n';\n    }\n    assert(pos == totlen);\n    cmd[pos] = '\\0';\n\n    *target = cmd;\n    return totlen;\n}\n\nvoid redisFreeCommand(char *cmd) {\n    hi_free(cmd);\n}\n\nvoid __redisSetError(redisContext *c, int type, const char *str) {\n    size_t len;\n\n    c->err = type;\n    if (str != NULL) {\n        len = strlen(str);\n        len = len < (sizeof(c->errstr)-1) ? len : (sizeof(c->errstr)-1);\n        memcpy(c->errstr,str,len);\n        c->errstr[len] = '\\0';\n    } else {\n        /* Only REDIS_ERR_IO may lack a description! */\n        assert(type == REDIS_ERR_IO);\n        strerror_r(errno, c->errstr, sizeof(c->errstr));\n    }\n}\n\nredisReader *redisReaderCreate(void) {\n    return redisReaderCreateWithFunctions(&defaultFunctions);\n}\n\nstatic void redisPushAutoFree(void *privdata, void *reply) {\n    (void)privdata;\n    freeReplyObject(reply);\n}\n\nstatic redisContext *redisContextInit(void) {\n    redisContext *c;\n\n    c = hi_calloc(1, sizeof(*c));\n    if (c == NULL)\n        return NULL;\n\n    c->funcs = &redisContextDefaultFuncs;\n\n    c->obuf = hi_sdsempty();\n    c->reader = redisReaderCreate();\n    c->fd = REDIS_INVALID_FD;\n\n    if (c->obuf == NULL || c->reader == NULL) {\n        redisFree(c);\n        return NULL;\n    }\n\n    return c;\n}\n\nvoid redisFree(redisContext *c) {\n    if (c == NULL)\n        return;\n    redisNetClose(c);\n\n    hi_sdsfree(c->obuf);\n    redisReaderFree(c->reader);\n    hi_free(c->tcp.host);\n    hi_free(c->tcp.source_addr);\n    hi_free(c->unix_sock.path);\n    hi_free(c->connect_timeout);\n    hi_free(c->command_timeout);\n    hi_free(c->saddr);\n\n    if (c->privdata && c->free_privdata)\n        c->free_privdata(c->privdata);\n\n    if (c->funcs->free_privctx)\n        c->funcs->free_privctx(c->privctx);\n\n    memset(c, 0xff, sizeof(*c));\n    hi_free(c);\n}\n\nredisFD redisFreeKeepFd(redisContext *c) {\n    redisFD fd = c->fd;\n    c->fd = REDIS_INVALID_FD;\n    redisFree(c);\n    return fd;\n}\n\nint redisReconnect(redisContext *c) {\n    c->err = 0;\n    memset(c->errstr, '\\0', strlen(c->errstr));\n\n    if (c->privctx && c->funcs->free_privctx) {\n        c->funcs->free_privctx(c->privctx);\n        c->privctx = NULL;\n    }\n\n    redisNetClose(c);\n\n    hi_sdsfree(c->obuf);\n    redisReaderFree(c->reader);\n\n    c->obuf = hi_sdsempty();\n    c->reader = redisReaderCreate();\n\n    if (c->obuf == NULL || c->reader == NULL) {\n        __redisSetError(c, REDIS_ERR_OOM, \"Out of memory\");\n        return REDIS_ERR;\n    }\n\n    int ret = REDIS_ERR;\n    if (c->connection_type == REDIS_CONN_TCP) {\n        ret = redisContextConnectBindTcp(c, c->tcp.host, c->tcp.port,\n               c->connect_timeout, c->tcp.source_addr);\n    } else if (c->connection_type == REDIS_CONN_UNIX) {\n        ret = redisContextConnectUnix(c, c->unix_sock.path, c->connect_timeout);\n    } else {\n        /* Something bad happened here and shouldn't have. There isn't\n           enough information in the context to reconnect. */\n        __redisSetError(c,REDIS_ERR_OTHER,\"Not enough information to reconnect\");\n        ret = REDIS_ERR;\n    }\n\n    if (c->command_timeout != NULL && (c->flags & REDIS_BLOCK) && c->fd != REDIS_INVALID_FD) {\n        redisContextSetTimeout(c, *c->command_timeout);\n    }\n\n    return ret;\n}\n\nredisContext *redisConnectWithOptions(const redisOptions *options) {\n    redisContext *c = redisContextInit();\n    if (c == NULL) {\n        return NULL;\n    }\n    if (!(options->options & REDIS_OPT_NONBLOCK)) {\n        c->flags |= REDIS_BLOCK;\n    }\n    if (options->options & REDIS_OPT_REUSEADDR) {\n        c->flags |= REDIS_REUSEADDR;\n    }\n    if (options->options & REDIS_OPT_NOAUTOFREE) {\n        c->flags |= REDIS_NO_AUTO_FREE;\n    }\n\n    /* Set any user supplied RESP3 PUSH handler or use freeReplyObject\n     * as a default unless specifically flagged that we don't want one. */\n    if (options->push_cb != NULL)\n        redisSetPushCallback(c, options->push_cb);\n    else if (!(options->options & REDIS_OPT_NO_PUSH_AUTOFREE))\n        redisSetPushCallback(c, redisPushAutoFree);\n\n    c->privdata = options->privdata;\n    c->free_privdata = options->free_privdata;\n\n    if (redisContextUpdateConnectTimeout(c, options->connect_timeout) != REDIS_OK ||\n        redisContextUpdateCommandTimeout(c, options->command_timeout) != REDIS_OK) {\n        __redisSetError(c, REDIS_ERR_OOM, \"Out of memory\");\n        return c;\n    }\n\n    if (options->type == REDIS_CONN_TCP) {\n        redisContextConnectBindTcp(c, options->endpoint.tcp.ip,\n                                   options->endpoint.tcp.port, options->connect_timeout,\n                                   options->endpoint.tcp.source_addr);\n    } else if (options->type == REDIS_CONN_UNIX) {\n        redisContextConnectUnix(c, options->endpoint.unix_socket,\n                                options->connect_timeout);\n    } else if (options->type == REDIS_CONN_USERFD) {\n        c->fd = options->endpoint.fd;\n        c->flags |= REDIS_CONNECTED;\n    } else {\n        // Unknown type - FIXME - FREE\n        return NULL;\n    }\n\n    if (options->command_timeout != NULL && (c->flags & REDIS_BLOCK) && c->fd != REDIS_INVALID_FD) {\n        redisContextSetTimeout(c, *options->command_timeout);\n    }\n\n    return c;\n}\n\n/* Connect to a Redis instance. On error the field error in the returned\n * context will be set to the return value of the error function.\n * When no set of reply functions is given, the default set will be used. */\nredisContext *redisConnect(const char *ip, int port) {\n    redisOptions options = {0};\n    REDIS_OPTIONS_SET_TCP(&options, ip, port);\n    return redisConnectWithOptions(&options);\n}\n\nredisContext *redisConnectWithTimeout(const char *ip, int port, const struct timeval tv) {\n    redisOptions options = {0};\n    REDIS_OPTIONS_SET_TCP(&options, ip, port);\n    options.connect_timeout = &tv;\n    return redisConnectWithOptions(&options);\n}\n\nredisContext *redisConnectNonBlock(const char *ip, int port) {\n    redisOptions options = {0};\n    REDIS_OPTIONS_SET_TCP(&options, ip, port);\n    options.options |= REDIS_OPT_NONBLOCK;\n    return redisConnectWithOptions(&options);\n}\n\nredisContext *redisConnectBindNonBlock(const char *ip, int port,\n                                       const char *source_addr) {\n    redisOptions options = {0};\n    REDIS_OPTIONS_SET_TCP(&options, ip, port);\n    options.endpoint.tcp.source_addr = source_addr;\n    options.options |= REDIS_OPT_NONBLOCK;\n    return redisConnectWithOptions(&options);\n}\n\nredisContext *redisConnectBindNonBlockWithReuse(const char *ip, int port,\n                                                const char *source_addr) {\n    redisOptions options = {0};\n    REDIS_OPTIONS_SET_TCP(&options, ip, port);\n    options.endpoint.tcp.source_addr = source_addr;\n    options.options |= REDIS_OPT_NONBLOCK|REDIS_OPT_REUSEADDR;\n    return redisConnectWithOptions(&options);\n}\n\nredisContext *redisConnectUnix(const char *path) {\n    redisOptions options = {0};\n    REDIS_OPTIONS_SET_UNIX(&options, path);\n    return redisConnectWithOptions(&options);\n}\n\nredisContext *redisConnectUnixWithTimeout(const char *path, const struct timeval tv) {\n    redisOptions options = {0};\n    REDIS_OPTIONS_SET_UNIX(&options, path);\n    options.connect_timeout = &tv;\n    return redisConnectWithOptions(&options);\n}\n\nredisContext *redisConnectUnixNonBlock(const char *path) {\n    redisOptions options = {0};\n    REDIS_OPTIONS_SET_UNIX(&options, path);\n    options.options |= REDIS_OPT_NONBLOCK;\n    return redisConnectWithOptions(&options);\n}\n\nredisContext *redisConnectFd(redisFD fd) {\n    redisOptions options = {0};\n    options.type = REDIS_CONN_USERFD;\n    options.endpoint.fd = fd;\n    return redisConnectWithOptions(&options);\n}\n\n/* Set read/write timeout on a blocking socket. */\nint redisSetTimeout(redisContext *c, const struct timeval tv) {\n    if (c->flags & REDIS_BLOCK)\n        return redisContextSetTimeout(c,tv);\n    return REDIS_ERR;\n}\n\n/* Enable connection KeepAlive. */\nint redisEnableKeepAlive(redisContext *c) {\n    if (redisKeepAlive(c, REDIS_KEEPALIVE_INTERVAL) != REDIS_OK)\n        return REDIS_ERR;\n    return REDIS_OK;\n}\n\n/* Set a user provided RESP3 PUSH handler and return any old one set. */\nredisPushFn *redisSetPushCallback(redisContext *c, redisPushFn *fn) {\n    redisPushFn *old = c->push_cb;\n    c->push_cb = fn;\n    return old;\n}\n\n/* Use this function to handle a read event on the descriptor. It will try\n * and read some bytes from the socket and feed them to the reply parser.\n *\n * After this function is called, you may use redisGetReplyFromReader to\n * see if there is a reply available. */\nint redisBufferRead(redisContext *c) {\n    char buf[1024*16];\n    int nread;\n\n    /* Return early when the context has seen an error. */\n    if (c->err)\n        return REDIS_ERR;\n\n    nread = c->funcs->read(c, buf, sizeof(buf));\n    if (nread > 0) {\n        if (redisReaderFeed(c->reader, buf, nread) != REDIS_OK) {\n            __redisSetError(c, c->reader->err, c->reader->errstr);\n            return REDIS_ERR;\n        } else {\n        }\n    } else if (nread < 0) {\n        return REDIS_ERR;\n    }\n    return REDIS_OK;\n}\n\n/* Write the output buffer to the socket.\n *\n * Returns REDIS_OK when the buffer is empty, or (a part of) the buffer was\n * successfully written to the socket. When the buffer is empty after the\n * write operation, \"done\" is set to 1 (if given).\n *\n * Returns REDIS_ERR if an error occurred trying to write and sets\n * c->errstr to hold the appropriate error string.\n */\nint redisBufferWrite(redisContext *c, int *done) {\n\n    /* Return early when the context has seen an error. */\n    if (c->err)\n        return REDIS_ERR;\n\n    if (hi_sdslen(c->obuf) > 0) {\n        ssize_t nwritten = c->funcs->write(c);\n        if (nwritten < 0) {\n            return REDIS_ERR;\n        } else if (nwritten > 0) {\n            if (nwritten == (ssize_t)hi_sdslen(c->obuf)) {\n                hi_sdsfree(c->obuf);\n                c->obuf = hi_sdsempty();\n                if (c->obuf == NULL)\n                    goto oom;\n            } else {\n                if (hi_sdsrange(c->obuf,nwritten,-1) < 0) goto oom;\n            }\n        }\n    }\n    if (done != NULL) *done = (hi_sdslen(c->obuf) == 0);\n    return REDIS_OK;\n\noom:\n    __redisSetError(c, REDIS_ERR_OOM, \"Out of memory\");\n    return REDIS_ERR;\n}\n\n/* Internal helper function to try and get a reply from the reader,\n * or set an error in the context otherwise. */\nint redisGetReplyFromReader(redisContext *c, void **reply) {\n    if (redisReaderGetReply(c->reader,reply) == REDIS_ERR) {\n        __redisSetError(c,c->reader->err,c->reader->errstr);\n        return REDIS_ERR;\n    }\n\n    return REDIS_OK;\n}\n\n/* Internal helper that returns 1 if the reply was a RESP3 PUSH\n * message and we handled it with a user-provided callback. */\nstatic int redisHandledPushReply(redisContext *c, void *reply) {\n    if (reply && c->push_cb && redisIsPushReply(reply)) {\n        c->push_cb(c->privdata, reply);\n        return 1;\n    }\n\n    return 0;\n}\n\nint redisGetReply(redisContext *c, void **reply) {\n    int wdone = 0;\n    void *aux = NULL;\n\n    /* Try to read pending replies */\n    if (redisGetReplyFromReader(c,&aux) == REDIS_ERR)\n        return REDIS_ERR;\n\n    /* For the blocking context, flush output buffer and read reply */\n    if (aux == NULL && c->flags & REDIS_BLOCK) {\n        /* Write until done */\n        do {\n            if (redisBufferWrite(c,&wdone) == REDIS_ERR)\n                return REDIS_ERR;\n        } while (!wdone);\n\n        /* Read until there is a reply */\n        do {\n            if (redisBufferRead(c) == REDIS_ERR)\n                return REDIS_ERR;\n\n            /* We loop here in case the user has specified a RESP3\n             * PUSH handler (e.g. for client tracking). */\n            do {\n                if (redisGetReplyFromReader(c,&aux) == REDIS_ERR)\n                    return REDIS_ERR;\n            } while (redisHandledPushReply(c, aux));\n        } while (aux == NULL);\n    }\n\n    /* Set reply or free it if we were passed NULL */\n    if (reply != NULL) {\n        *reply = aux;\n    } else {\n        freeReplyObject(aux);\n    }\n\n    return REDIS_OK;\n}\n\n\n/* Helper function for the redisAppendCommand* family of functions.\n *\n * Write a formatted command to the output buffer. When this family\n * is used, you need to call redisGetReply yourself to retrieve\n * the reply (or replies in pub/sub).\n */\nint __redisAppendCommand(redisContext *c, const char *cmd, size_t len) {\n    hisds newbuf;\n\n    newbuf = hi_sdscatlen(c->obuf,cmd,len);\n    if (newbuf == NULL) {\n        __redisSetError(c,REDIS_ERR_OOM,\"Out of memory\");\n        return REDIS_ERR;\n    }\n\n    c->obuf = newbuf;\n    return REDIS_OK;\n}\n\nint redisAppendFormattedCommand(redisContext *c, const char *cmd, size_t len) {\n\n    if (__redisAppendCommand(c, cmd, len) != REDIS_OK) {\n        return REDIS_ERR;\n    }\n\n    return REDIS_OK;\n}\n\nint redisvAppendCommand(redisContext *c, const char *format, va_list ap) {\n    char *cmd;\n    int len;\n\n    len = redisvFormatCommand(&cmd,format,ap);\n    if (len == -1) {\n        __redisSetError(c,REDIS_ERR_OOM,\"Out of memory\");\n        return REDIS_ERR;\n    } else if (len == -2) {\n        __redisSetError(c,REDIS_ERR_OTHER,\"Invalid format string\");\n        return REDIS_ERR;\n    }\n\n    if (__redisAppendCommand(c,cmd,len) != REDIS_OK) {\n        hi_free(cmd);\n        return REDIS_ERR;\n    }\n\n    hi_free(cmd);\n    return REDIS_OK;\n}\n\nint redisAppendCommand(redisContext *c, const char *format, ...) {\n    va_list ap;\n    int ret;\n\n    va_start(ap,format);\n    ret = redisvAppendCommand(c,format,ap);\n    va_end(ap);\n    return ret;\n}\n\nint redisAppendCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen) {\n    hisds cmd;\n    int len;\n\n    len = redisFormatSdsCommandArgv(&cmd,argc,argv,argvlen);\n    if (len == -1) {\n        __redisSetError(c,REDIS_ERR_OOM,\"Out of memory\");\n        return REDIS_ERR;\n    }\n\n    if (__redisAppendCommand(c,cmd,len) != REDIS_OK) {\n        hi_sdsfree(cmd);\n        return REDIS_ERR;\n    }\n\n    hi_sdsfree(cmd);\n    return REDIS_OK;\n}\n\n/* Helper function for the redisCommand* family of functions.\n *\n * Write a formatted command to the output buffer. If the given context is\n * blocking, immediately read the reply into the \"reply\" pointer. When the\n * context is non-blocking, the \"reply\" pointer will not be used and the\n * command is simply appended to the write buffer.\n *\n * Returns the reply when a reply was successfully retrieved. Returns NULL\n * otherwise. When NULL is returned in a blocking context, the error field\n * in the context will be set.\n */\nstatic void *__redisBlockForReply(redisContext *c) {\n    void *reply;\n\n    if (c->flags & REDIS_BLOCK) {\n        if (redisGetReply(c,&reply) != REDIS_OK)\n            return NULL;\n        return reply;\n    }\n    return NULL;\n}\n\nvoid *redisvCommand(redisContext *c, const char *format, va_list ap) {\n    if (redisvAppendCommand(c,format,ap) != REDIS_OK)\n        return NULL;\n    return __redisBlockForReply(c);\n}\n\nvoid *redisCommand(redisContext *c, const char *format, ...) {\n    va_list ap;\n    va_start(ap,format);\n    void *reply = redisvCommand(c,format,ap);\n    va_end(ap);\n    return reply;\n}\n\nvoid *redisCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen) {\n    if (redisAppendCommandArgv(c,argc,argv,argvlen) != REDIS_OK)\n        return NULL;\n    return __redisBlockForReply(c);\n}\n", "#include \"fmacros.h\"\n#include \"sockcompat.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifndef _WIN32\n#include <strings.h>\n#include <sys/time.h>\n#endif\n#include <assert.h>\n#include <signal.h>\n#include <errno.h>\n#include <limits.h>\n\n#include \"hiredis.h\"\n#include \"async.h\"\n#ifdef HIREDIS_TEST_SSL\n#include \"hiredis_ssl.h\"\n#endif\n#include \"net.h\"\n#include \"win32.h\"\n\nenum connection_type {\n    CONN_TCP,\n    CONN_UNIX,\n    CONN_FD,\n    CONN_SSL\n};\n\nstruct config {\n    enum connection_type type;\n\n    struct {\n        const char *host;\n        int port;\n        struct timeval timeout;\n    } tcp;\n\n    struct {\n        const char *path;\n    } unix_sock;\n\n    struct {\n        const char *host;\n        int port;\n        const char *ca_cert;\n        const char *cert;\n        const char *key;\n    } ssl;\n};\n\nstruct privdata {\n    int dtor_counter;\n};\n\nstruct pushCounters {\n    int nil;\n    int str;\n};\n\n#ifdef HIREDIS_TEST_SSL\nredisSSLContext *_ssl_ctx = NULL;\n#endif\n\n/* The following lines make up our testing \"framework\" :) */\nstatic int tests = 0, fails = 0, skips = 0;\n#define test(_s) { printf(\"#%02d \", ++tests); printf(_s); }\n#define test_cond(_c) if(_c) printf(\"\\033[0;32mPASSED\\033[0;0m\\n\"); else {printf(\"\\033[0;31mFAILED\\033[0;0m\\n\"); fails++;}\n#define test_skipped() { printf(\"\\033[01;33mSKIPPED\\033[0;0m\\n\"); skips++; }\n\nstatic long long usec(void) {\n#ifndef _MSC_VER\n    struct timeval tv;\n    gettimeofday(&tv,NULL);\n    return (((long long)tv.tv_sec)*1000000)+tv.tv_usec;\n#else\n    FILETIME ft;\n    GetSystemTimeAsFileTime(&ft);\n    return (((long long)ft.dwHighDateTime << 32) | ft.dwLowDateTime) / 10;\n#endif\n}\n\n/* The assert() calls below have side effects, so we need assert()\n * even if we are compiling without asserts (-DNDEBUG). */\n#ifdef NDEBUG\n#undef assert\n#define assert(e) (void)(e)\n#endif\n\n/* Helper to extract Redis version information.  Aborts on any failure. */\n#define REDIS_VERSION_FIELD \"redis_version:\"\nvoid get_redis_version(redisContext *c, int *majorptr, int *minorptr) {\n    redisReply *reply;\n    char *eptr, *s, *e;\n    int major, minor;\n\n    reply = redisCommand(c, \"INFO\");\n    if (reply == NULL || c->err || reply->type != REDIS_REPLY_STRING)\n        goto abort;\n    if ((s = strstr(reply->str, REDIS_VERSION_FIELD)) == NULL)\n        goto abort;\n\n    s += strlen(REDIS_VERSION_FIELD);\n\n    /* We need a field terminator and at least 'x.y.z' (5) bytes of data */\n    if ((e = strstr(s, \"\\r\\n\")) == NULL || (e - s) < 5)\n        goto abort;\n\n    /* Extract version info */\n    major = strtol(s, &eptr, 10);\n    if (*eptr != '.') goto abort;\n    minor = strtol(eptr+1, NULL, 10);\n\n    /* Push info the caller wants */\n    if (majorptr) *majorptr = major;\n    if (minorptr) *minorptr = minor;\n\n    freeReplyObject(reply);\n    return;\n\nabort:\n    freeReplyObject(reply);\n    fprintf(stderr, \"Error:  Cannot determine Redis version, aborting\\n\");\n    exit(1);\n}\n\nstatic redisContext *select_database(redisContext *c) {\n    redisReply *reply;\n\n    /* Switch to DB 9 for testing, now that we know we can chat. */\n    reply = redisCommand(c,\"SELECT 9\");\n    assert(reply != NULL);\n    freeReplyObject(reply);\n\n    /* Make sure the DB is emtpy */\n    reply = redisCommand(c,\"DBSIZE\");\n    assert(reply != NULL);\n    if (reply->type == REDIS_REPLY_INTEGER && reply->integer == 0) {\n        /* Awesome, DB 9 is empty and we can continue. */\n        freeReplyObject(reply);\n    } else {\n        printf(\"Database #9 is not empty, test can not continue\\n\");\n        exit(1);\n    }\n\n    return c;\n}\n\n/* Switch protocol */\nstatic void send_hello(redisContext *c, int version) {\n    redisReply *reply;\n    int expected;\n\n    reply = redisCommand(c, \"HELLO %d\", version);\n    expected = version == 3 ? REDIS_REPLY_MAP : REDIS_REPLY_ARRAY;\n    assert(reply != NULL && reply->type == expected);\n    freeReplyObject(reply);\n}\n\n/* Togggle client tracking */\nstatic void send_client_tracking(redisContext *c, const char *str) {\n    redisReply *reply;\n\n    reply = redisCommand(c, \"CLIENT TRACKING %s\", str);\n    assert(reply != NULL && reply->type == REDIS_REPLY_STATUS);\n    freeReplyObject(reply);\n}\n\nstatic int disconnect(redisContext *c, int keep_fd) {\n    redisReply *reply;\n\n    /* Make sure we're on DB 9. */\n    reply = redisCommand(c,\"SELECT 9\");\n    assert(reply != NULL);\n    freeReplyObject(reply);\n    reply = redisCommand(c,\"FLUSHDB\");\n    assert(reply != NULL);\n    freeReplyObject(reply);\n\n    /* Free the context as well, but keep the fd if requested. */\n    if (keep_fd)\n        return redisFreeKeepFd(c);\n    redisFree(c);\n    return -1;\n}\n\nstatic void do_ssl_handshake(redisContext *c) {\n#ifdef HIREDIS_TEST_SSL\n    redisInitiateSSLWithContext(c, _ssl_ctx);\n    if (c->err) {\n        printf(\"SSL error: %s\\n\", c->errstr);\n        redisFree(c);\n        exit(1);\n    }\n#else\n    (void) c;\n#endif\n}\n\nstatic redisContext *do_connect(struct config config) {\n    redisContext *c = NULL;\n\n    if (config.type == CONN_TCP) {\n        c = redisConnect(config.tcp.host, config.tcp.port);\n    } else if (config.type == CONN_SSL) {\n        c = redisConnect(config.ssl.host, config.ssl.port);\n    } else if (config.type == CONN_UNIX) {\n        c = redisConnectUnix(config.unix_sock.path);\n    } else if (config.type == CONN_FD) {\n        /* Create a dummy connection just to get an fd to inherit */\n        redisContext *dummy_ctx = redisConnectUnix(config.unix_sock.path);\n        if (dummy_ctx) {\n            int fd = disconnect(dummy_ctx, 1);\n            printf(\"Connecting to inherited fd %d\\n\", fd);\n            c = redisConnectFd(fd);\n        }\n    } else {\n        assert(NULL);\n    }\n\n    if (c == NULL) {\n        printf(\"Connection error: can't allocate redis context\\n\");\n        exit(1);\n    } else if (c->err) {\n        printf(\"Connection error: %s\\n\", c->errstr);\n        redisFree(c);\n        exit(1);\n    }\n\n    if (config.type == CONN_SSL) {\n        do_ssl_handshake(c);\n    }\n\n    return select_database(c);\n}\n\nstatic void do_reconnect(redisContext *c, struct config config) {\n    redisReconnect(c);\n\n    if (config.type == CONN_SSL) {\n        do_ssl_handshake(c);\n    }\n}\n\nstatic void test_format_commands(void) {\n    char *cmd;\n    int len;\n\n    test(\"Format command without interpolation: \");\n    len = redisFormatCommand(&cmd,\"SET foo bar\");\n    test_cond(strncmp(cmd,\"*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nfoo\\r\\n$3\\r\\nbar\\r\\n\",len) == 0 &&\n        len == 4+4+(3+2)+4+(3+2)+4+(3+2));\n    hi_free(cmd);\n\n    test(\"Format command with %%s string interpolation: \");\n    len = redisFormatCommand(&cmd,\"SET %s %s\",\"foo\",\"bar\");\n    test_cond(strncmp(cmd,\"*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nfoo\\r\\n$3\\r\\nbar\\r\\n\",len) == 0 &&\n        len == 4+4+(3+2)+4+(3+2)+4+(3+2));\n    hi_free(cmd);\n\n    test(\"Format command with %%s and an empty string: \");\n    len = redisFormatCommand(&cmd,\"SET %s %s\",\"foo\",\"\");\n    test_cond(strncmp(cmd,\"*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nfoo\\r\\n$0\\r\\n\\r\\n\",len) == 0 &&\n        len == 4+4+(3+2)+4+(3+2)+4+(0+2));\n    hi_free(cmd);\n\n    test(\"Format command with an empty string in between proper interpolations: \");\n    len = redisFormatCommand(&cmd,\"SET %s %s\",\"\",\"foo\");\n    test_cond(strncmp(cmd,\"*3\\r\\n$3\\r\\nSET\\r\\n$0\\r\\n\\r\\n$3\\r\\nfoo\\r\\n\",len) == 0 &&\n        len == 4+4+(3+2)+4+(0+2)+4+(3+2));\n    hi_free(cmd);\n\n    test(\"Format command with %%b string interpolation: \");\n    len = redisFormatCommand(&cmd,\"SET %b %b\",\"foo\",(size_t)3,\"b\\0r\",(size_t)3);\n    test_cond(strncmp(cmd,\"*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nfoo\\r\\n$3\\r\\nb\\0r\\r\\n\",len) == 0 &&\n        len == 4+4+(3+2)+4+(3+2)+4+(3+2));\n    hi_free(cmd);\n\n    test(\"Format command with %%b and an empty string: \");\n    len = redisFormatCommand(&cmd,\"SET %b %b\",\"foo\",(size_t)3,\"\",(size_t)0);\n    test_cond(strncmp(cmd,\"*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nfoo\\r\\n$0\\r\\n\\r\\n\",len) == 0 &&\n        len == 4+4+(3+2)+4+(3+2)+4+(0+2));\n    hi_free(cmd);\n\n    test(\"Format command with literal %%: \");\n    len = redisFormatCommand(&cmd,\"SET %% %%\");\n    test_cond(strncmp(cmd,\"*3\\r\\n$3\\r\\nSET\\r\\n$1\\r\\n%\\r\\n$1\\r\\n%\\r\\n\",len) == 0 &&\n        len == 4+4+(3+2)+4+(1+2)+4+(1+2));\n    hi_free(cmd);\n\n    /* Vararg width depends on the type. These tests make sure that the\n     * width is correctly determined using the format and subsequent varargs\n     * can correctly be interpolated. */\n#define INTEGER_WIDTH_TEST(fmt, type) do {                                                \\\n    type value = 123;                                                                     \\\n    test(\"Format command with printf-delegation (\" #type \"): \");                          \\\n    len = redisFormatCommand(&cmd,\"key:%08\" fmt \" str:%s\", value, \"hello\");               \\\n    test_cond(strncmp(cmd,\"*2\\r\\n$12\\r\\nkey:00000123\\r\\n$9\\r\\nstr:hello\\r\\n\",len) == 0 && \\\n        len == 4+5+(12+2)+4+(9+2));                                                       \\\n    hi_free(cmd);                                                                         \\\n} while(0)\n\n#define FLOAT_WIDTH_TEST(type) do {                                                       \\\n    type value = 123.0;                                                                   \\\n    test(\"Format command with printf-delegation (\" #type \"): \");                          \\\n    len = redisFormatCommand(&cmd,\"key:%08.3f str:%s\", value, \"hello\");                   \\\n    test_cond(strncmp(cmd,\"*2\\r\\n$12\\r\\nkey:0123.000\\r\\n$9\\r\\nstr:hello\\r\\n\",len) == 0 && \\\n        len == 4+5+(12+2)+4+(9+2));                                                       \\\n    hi_free(cmd);                                                                         \\\n} while(0)\n\n    INTEGER_WIDTH_TEST(\"d\", int);\n    INTEGER_WIDTH_TEST(\"hhd\", char);\n    INTEGER_WIDTH_TEST(\"hd\", short);\n    INTEGER_WIDTH_TEST(\"ld\", long);\n    INTEGER_WIDTH_TEST(\"lld\", long long);\n    INTEGER_WIDTH_TEST(\"u\", unsigned int);\n    INTEGER_WIDTH_TEST(\"hhu\", unsigned char);\n    INTEGER_WIDTH_TEST(\"hu\", unsigned short);\n    INTEGER_WIDTH_TEST(\"lu\", unsigned long);\n    INTEGER_WIDTH_TEST(\"llu\", unsigned long long);\n    FLOAT_WIDTH_TEST(float);\n    FLOAT_WIDTH_TEST(double);\n\n    test(\"Format command with invalid printf format: \");\n    len = redisFormatCommand(&cmd,\"key:%08p %b\",(void*)1234,\"foo\",(size_t)3);\n    test_cond(len == -1);\n\n    const char *argv[3];\n    argv[0] = \"SET\";\n    argv[1] = \"foo\\0xxx\";\n    argv[2] = \"bar\";\n    size_t lens[3] = { 3, 7, 3 };\n    int argc = 3;\n\n    test(\"Format command by passing argc/argv without lengths: \");\n    len = redisFormatCommandArgv(&cmd,argc,argv,NULL);\n    test_cond(strncmp(cmd,\"*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nfoo\\r\\n$3\\r\\nbar\\r\\n\",len) == 0 &&\n        len == 4+4+(3+2)+4+(3+2)+4+(3+2));\n    hi_free(cmd);\n\n    test(\"Format command by passing argc/argv with lengths: \");\n    len = redisFormatCommandArgv(&cmd,argc,argv,lens);\n    test_cond(strncmp(cmd,\"*3\\r\\n$3\\r\\nSET\\r\\n$7\\r\\nfoo\\0xxx\\r\\n$3\\r\\nbar\\r\\n\",len) == 0 &&\n        len == 4+4+(3+2)+4+(7+2)+4+(3+2));\n    hi_free(cmd);\n\n    hisds sds_cmd;\n\n    sds_cmd = NULL;\n    test(\"Format command into hisds by passing argc/argv without lengths: \");\n    len = redisFormatSdsCommandArgv(&sds_cmd,argc,argv,NULL);\n    test_cond(strncmp(sds_cmd,\"*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nfoo\\r\\n$3\\r\\nbar\\r\\n\",len) == 0 &&\n        len == 4+4+(3+2)+4+(3+2)+4+(3+2));\n    hi_sdsfree(sds_cmd);\n\n    sds_cmd = NULL;\n    test(\"Format command into hisds by passing argc/argv with lengths: \");\n    len = redisFormatSdsCommandArgv(&sds_cmd,argc,argv,lens);\n    test_cond(strncmp(sds_cmd,\"*3\\r\\n$3\\r\\nSET\\r\\n$7\\r\\nfoo\\0xxx\\r\\n$3\\r\\nbar\\r\\n\",len) == 0 &&\n        len == 4+4+(3+2)+4+(7+2)+4+(3+2));\n    hi_sdsfree(sds_cmd);\n}\n\nstatic void test_append_formatted_commands(struct config config) {\n    redisContext *c;\n    redisReply *reply;\n    char *cmd;\n    int len;\n\n    c = do_connect(config);\n\n    test(\"Append format command: \");\n\n    len = redisFormatCommand(&cmd, \"SET foo bar\");\n\n    test_cond(redisAppendFormattedCommand(c, cmd, len) == REDIS_OK);\n\n    assert(redisGetReply(c, (void*)&reply) == REDIS_OK);\n\n    hi_free(cmd);\n    freeReplyObject(reply);\n\n    disconnect(c, 0);\n}\n\nstatic void test_reply_reader(void) {\n    redisReader *reader;\n    void *reply, *root;\n    int ret;\n    int i;\n\n    test(\"Error handling in reply parser: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader,(char*)\"@foo\\r\\n\",6);\n    ret = redisReaderGetReply(reader,NULL);\n    test_cond(ret == REDIS_ERR &&\n              strcasecmp(reader->errstr,\"Protocol error, got \\\"@\\\" as reply type byte\") == 0);\n    redisReaderFree(reader);\n\n    /* when the reply already contains multiple items, they must be free'd\n     * on an error. valgrind will bark when this doesn't happen. */\n    test(\"Memory cleanup in reply parser: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader,(char*)\"*2\\r\\n\",4);\n    redisReaderFeed(reader,(char*)\"$5\\r\\nhello\\r\\n\",11);\n    redisReaderFeed(reader,(char*)\"@foo\\r\\n\",6);\n    ret = redisReaderGetReply(reader,NULL);\n    test_cond(ret == REDIS_ERR &&\n              strcasecmp(reader->errstr,\"Protocol error, got \\\"@\\\" as reply type byte\") == 0);\n    redisReaderFree(reader);\n\n    reader = redisReaderCreate();\n    test(\"Can handle arbitrarily nested multi-bulks: \");\n    for (i = 0; i < 128; i++) {\n        redisReaderFeed(reader,(char*)\"*1\\r\\n\", 4);\n    }\n    redisReaderFeed(reader,(char*)\"$6\\r\\nLOLWUT\\r\\n\",12);\n    ret = redisReaderGetReply(reader,&reply);\n    root = reply; /* Keep track of the root reply */\n    test_cond(ret == REDIS_OK &&\n        ((redisReply*)reply)->type == REDIS_REPLY_ARRAY &&\n        ((redisReply*)reply)->elements == 1);\n\n    test(\"Can parse arbitrarily nested multi-bulks correctly: \");\n    while(i--) {\n        assert(reply != NULL && ((redisReply*)reply)->type == REDIS_REPLY_ARRAY);\n        reply = ((redisReply*)reply)->element[0];\n    }\n    test_cond(((redisReply*)reply)->type == REDIS_REPLY_STRING &&\n        !memcmp(((redisReply*)reply)->str, \"LOLWUT\", 6));\n    freeReplyObject(root);\n    redisReaderFree(reader);\n\n    test(\"Correctly parses LLONG_MAX: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \":9223372036854775807\\r\\n\",22);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_OK &&\n            ((redisReply*)reply)->type == REDIS_REPLY_INTEGER &&\n            ((redisReply*)reply)->integer == LLONG_MAX);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    test(\"Set error when > LLONG_MAX: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \":9223372036854775808\\r\\n\",22);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR &&\n              strcasecmp(reader->errstr,\"Bad integer value\") == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    test(\"Correctly parses LLONG_MIN: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \":-9223372036854775808\\r\\n\",23);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_OK &&\n            ((redisReply*)reply)->type == REDIS_REPLY_INTEGER &&\n            ((redisReply*)reply)->integer == LLONG_MIN);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    test(\"Set error when < LLONG_MIN: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \":-9223372036854775809\\r\\n\",23);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR &&\n              strcasecmp(reader->errstr,\"Bad integer value\") == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    test(\"Set error when array < -1: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \"*-2\\r\\n+asdf\\r\\n\",12);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR &&\n              strcasecmp(reader->errstr,\"Multi-bulk length out of range\") == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    test(\"Set error when bulk < -1: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \"$-2\\r\\nasdf\\r\\n\",11);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR &&\n              strcasecmp(reader->errstr,\"Bulk string length out of range\") == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    test(\"Can configure maximum multi-bulk elements: \");\n    reader = redisReaderCreate();\n    reader->maxelements = 1024;\n    redisReaderFeed(reader, \"*1025\\r\\n\", 7);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR &&\n              strcasecmp(reader->errstr, \"Multi-bulk length out of range\") == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    test(\"Multi-bulk never overflows regardless of maxelements: \");\n    size_t bad_mbulk_len = (SIZE_MAX / sizeof(void *)) + 3;\n    char bad_mbulk_reply[100];\n    snprintf(bad_mbulk_reply, sizeof(bad_mbulk_reply), \"*%llu\\r\\n+asdf\\r\\n\",\n        (unsigned long long) bad_mbulk_len);\n\n    reader = redisReaderCreate();\n    reader->maxelements = 0;    /* Don't rely on default limit */\n    redisReaderFeed(reader, bad_mbulk_reply, strlen(bad_mbulk_reply));\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR && strcasecmp(reader->errstr, \"Out of memory\") == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n#if LLONG_MAX > SIZE_MAX\n    test(\"Set error when array > SIZE_MAX: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \"*9223372036854775807\\r\\n+asdf\\r\\n\",29);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR &&\n            strcasecmp(reader->errstr,\"Multi-bulk length out of range\") == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    test(\"Set error when bulk > SIZE_MAX: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader, \"$9223372036854775807\\r\\nasdf\\r\\n\",28);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR &&\n            strcasecmp(reader->errstr,\"Bulk string length out of range\") == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n#endif\n\n    test(\"Works with NULL functions for reply: \");\n    reader = redisReaderCreate();\n    reader->fn = NULL;\n    redisReaderFeed(reader,(char*)\"+OK\\r\\n\",5);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_OK && reply == (void*)REDIS_REPLY_STATUS);\n    redisReaderFree(reader);\n\n    test(\"Works when a single newline (\\\\r\\\\n) covers two calls to feed: \");\n    reader = redisReaderCreate();\n    reader->fn = NULL;\n    redisReaderFeed(reader,(char*)\"+OK\\r\",4);\n    ret = redisReaderGetReply(reader,&reply);\n    assert(ret == REDIS_OK && reply == NULL);\n    redisReaderFeed(reader,(char*)\"\\n\",1);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_OK && reply == (void*)REDIS_REPLY_STATUS);\n    redisReaderFree(reader);\n\n    test(\"Don't reset state after protocol error: \");\n    reader = redisReaderCreate();\n    reader->fn = NULL;\n    redisReaderFeed(reader,(char*)\"x\",1);\n    ret = redisReaderGetReply(reader,&reply);\n    assert(ret == REDIS_ERR);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_ERR && reply == NULL);\n    redisReaderFree(reader);\n\n    /* Regression test for issue #45 on GitHub. */\n    test(\"Don't do empty allocation for empty multi bulk: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader,(char*)\"*0\\r\\n\",4);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_OK &&\n        ((redisReply*)reply)->type == REDIS_REPLY_ARRAY &&\n        ((redisReply*)reply)->elements == 0);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    /* RESP3 verbatim strings (GitHub issue #802) */\n    test(\"Can parse RESP3 verbatim strings: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader,(char*)\"=10\\r\\ntxt:LOLWUT\\r\\n\",17);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_OK &&\n        ((redisReply*)reply)->type == REDIS_REPLY_VERB &&\n         !memcmp(((redisReply*)reply)->str,\"LOLWUT\", 6));\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n\n    /* RESP3 push messages (Github issue #815) */\n    test(\"Can parse RESP3 push messages: \");\n    reader = redisReaderCreate();\n    redisReaderFeed(reader,(char*)\">2\\r\\n$6\\r\\nLOLWUT\\r\\n:42\\r\\n\",21);\n    ret = redisReaderGetReply(reader,&reply);\n    test_cond(ret == REDIS_OK &&\n        ((redisReply*)reply)->type == REDIS_REPLY_PUSH &&\n        ((redisReply*)reply)->elements == 2 &&\n        ((redisReply*)reply)->element[0]->type == REDIS_REPLY_STRING &&\n        !memcmp(((redisReply*)reply)->element[0]->str,\"LOLWUT\",6) &&\n        ((redisReply*)reply)->element[1]->type == REDIS_REPLY_INTEGER &&\n        ((redisReply*)reply)->element[1]->integer == 42);\n    freeReplyObject(reply);\n    redisReaderFree(reader);\n}\n\nstatic void test_free_null(void) {\n    void *redisCtx = NULL;\n    void *reply = NULL;\n\n    test(\"Don't fail when redisFree is passed a NULL value: \");\n    redisFree(redisCtx);\n    test_cond(redisCtx == NULL);\n\n    test(\"Don't fail when freeReplyObject is passed a NULL value: \");\n    freeReplyObject(reply);\n    test_cond(reply == NULL);\n}\n\nstatic void *hi_malloc_fail(size_t size) {\n    (void)size;\n    return NULL;\n}\n\nstatic void *hi_calloc_fail(size_t nmemb, size_t size) {\n    (void)nmemb;\n    (void)size;\n    return NULL;\n}\n\nstatic void *hi_realloc_fail(void *ptr, size_t size) {\n    (void)ptr;\n    (void)size;\n    return NULL;\n}\n\nstatic void test_allocator_injection(void) {\n    hiredisAllocFuncs ha = {\n        .mallocFn = hi_malloc_fail,\n        .callocFn = hi_calloc_fail,\n        .reallocFn = hi_realloc_fail,\n        .strdupFn = strdup,\n        .freeFn = free,\n    };\n\n    // Override hiredis allocators\n    hiredisSetAllocators(&ha);\n\n    test(\"redisContext uses injected allocators: \");\n    redisContext *c = redisConnect(\"localhost\", 6379);\n    test_cond(c == NULL);\n\n    test(\"redisReader uses injected allocators: \");\n    redisReader *reader = redisReaderCreate();\n    test_cond(reader == NULL);\n\n    // Return allocators to default\n    hiredisResetAllocators();\n}\n\n#define HIREDIS_BAD_DOMAIN \"idontexist-noreally.com\"\nstatic void test_blocking_connection_errors(void) {\n    redisContext *c;\n    struct addrinfo hints = {.ai_family = AF_INET};\n    struct addrinfo *ai_tmp = NULL;\n\n    int rv = getaddrinfo(HIREDIS_BAD_DOMAIN, \"6379\", &hints, &ai_tmp);\n    if (rv != 0) {\n        // Address does *not* exist\n        test(\"Returns error when host cannot be resolved: \");\n        // First see if this domain name *actually* resolves to NXDOMAIN\n        c = redisConnect(HIREDIS_BAD_DOMAIN, 6379);\n        test_cond(\n            c->err == REDIS_ERR_OTHER &&\n            (strcmp(c->errstr, \"Name or service not known\") == 0 ||\n             strcmp(c->errstr, \"Can't resolve: \" HIREDIS_BAD_DOMAIN) == 0 ||\n             strcmp(c->errstr, \"Name does not resolve\") == 0 ||\n             strcmp(c->errstr, \"nodename nor servname provided, or not known\") == 0 ||\n             strcmp(c->errstr, \"No address associated with hostname\") == 0 ||\n             strcmp(c->errstr, \"Temporary failure in name resolution\") == 0 ||\n             strcmp(c->errstr, \"hostname nor servname provided, or not known\") == 0 ||\n             strcmp(c->errstr, \"no address associated with name\") == 0 ||\n             strcmp(c->errstr, \"No such host is known. \") == 0));\n        redisFree(c);\n    } else {\n        printf(\"Skipping NXDOMAIN test. Found evil ISP!\\n\");\n        freeaddrinfo(ai_tmp);\n    }\n\n#ifndef _WIN32\n    test(\"Returns error when the port is not open: \");\n    c = redisConnect((char*)\"localhost\", 1);\n    test_cond(c->err == REDIS_ERR_IO &&\n        strcmp(c->errstr,\"Connection refused\") == 0);\n    redisFree(c);\n\n    test(\"Returns error when the unix_sock socket path doesn't accept connections: \");\n    c = redisConnectUnix((char*)\"/tmp/idontexist.sock\");\n    test_cond(c->err == REDIS_ERR_IO); /* Don't care about the message... */\n    redisFree(c);\n#endif\n}\n\n/* Test push handler */\nvoid push_handler(void *privdata, void *r) {\n    struct pushCounters *pcounts = privdata;\n    redisReply *reply = r, *payload;\n\n    assert(reply && reply->type == REDIS_REPLY_PUSH && reply->elements == 2);\n\n    payload = reply->element[1];\n    if (payload->type == REDIS_REPLY_ARRAY) {\n        payload = payload->element[0];\n    }\n\n    if (payload->type == REDIS_REPLY_STRING) {\n        pcounts->str++;\n    } else if (payload->type == REDIS_REPLY_NIL) {\n        pcounts->nil++;\n    }\n\n    freeReplyObject(reply);\n}\n\n/* Dummy function just to test setting a callback with redisOptions */\nvoid push_handler_async(redisAsyncContext *ac, void *reply) {\n    (void)ac;\n    (void)reply;\n}\n\nstatic void test_resp3_push_handler(redisContext *c) {\n    struct pushCounters pc = {0};\n    redisPushFn *old = NULL;\n    redisReply *reply;\n    void *privdata;\n\n    /* Switch to RESP3 and turn on client tracking */\n    send_hello(c, 3);\n    send_client_tracking(c, \"ON\");\n    privdata = c->privdata;\n    c->privdata = &pc;\n\n    reply = redisCommand(c, \"GET key:0\");\n    assert(reply != NULL);\n    freeReplyObject(reply);\n\n    test(\"RESP3 PUSH messages are handled out of band by default: \");\n    reply = redisCommand(c, \"SET key:0 val:0\");\n    test_cond(reply != NULL && reply->type == REDIS_REPLY_STATUS);\n    freeReplyObject(reply);\n\n    assert((reply = redisCommand(c, \"GET key:0\")) != NULL);\n    freeReplyObject(reply);\n\n    old = redisSetPushCallback(c, push_handler);\n    test(\"We can set a custom RESP3 PUSH handler: \");\n    reply = redisCommand(c, \"SET key:0 val:0\");\n    test_cond(reply != NULL && reply->type == REDIS_REPLY_STATUS && pc.str == 1);\n    freeReplyObject(reply);\n\n    test(\"We properly handle a NIL invalidation payload: \");\n    reply = redisCommand(c, \"FLUSHDB\");\n    test_cond(reply != NULL && reply->type == REDIS_REPLY_STATUS && pc.nil == 1);\n    freeReplyObject(reply);\n\n    /* Unset the push callback and generate an invalidate message making\n     * sure it is not handled out of band. */\n    test(\"With no handler, PUSH replies come in-band: \");\n    redisSetPushCallback(c, NULL);\n    assert((reply = redisCommand(c, \"GET key:0\")) != NULL);\n    freeReplyObject(reply);\n    assert((reply = redisCommand(c, \"SET key:0 invalid\")) != NULL);\n    test_cond(reply->type == REDIS_REPLY_PUSH);\n    freeReplyObject(reply);\n\n    test(\"With no PUSH handler, no replies are lost: \");\n    assert(redisGetReply(c, (void**)&reply) == REDIS_OK);\n    test_cond(reply != NULL && reply->type == REDIS_REPLY_STATUS);\n    freeReplyObject(reply);\n\n    /* Return to the originally set PUSH handler */\n    assert(old != NULL);\n    redisSetPushCallback(c, old);\n\n    /* Switch back to RESP2 and disable tracking */\n    c->privdata = privdata;\n    send_client_tracking(c, \"OFF\");\n    send_hello(c, 2);\n}\n\nredisOptions get_redis_tcp_options(struct config config) {\n    redisOptions options = {0};\n    REDIS_OPTIONS_SET_TCP(&options, config.tcp.host, config.tcp.port);\n    return options;\n}\n\nstatic void test_resp3_push_options(struct config config) {\n    redisAsyncContext *ac;\n    redisContext *c;\n    redisOptions options;\n\n    test(\"We set a default RESP3 handler for redisContext: \");\n    options = get_redis_tcp_options(config);\n    assert((c = redisConnectWithOptions(&options)) != NULL);\n    test_cond(c->push_cb != NULL);\n    redisFree(c);\n\n    test(\"We don't set a default RESP3 push handler for redisAsyncContext: \");\n    options = get_redis_tcp_options(config);\n    assert((ac = redisAsyncConnectWithOptions(&options)) != NULL);\n    test_cond(ac->c.push_cb == NULL);\n    redisAsyncFree(ac);\n\n    test(\"Our REDIS_OPT_NO_PUSH_AUTOFREE flag works: \");\n    options = get_redis_tcp_options(config);\n    options.options |= REDIS_OPT_NO_PUSH_AUTOFREE;\n    assert((c = redisConnectWithOptions(&options)) != NULL);\n    test_cond(c->push_cb == NULL);\n    redisFree(c);\n\n    test(\"We can use redisOptions to set a custom PUSH handler for redisContext: \");\n    options = get_redis_tcp_options(config);\n    options.push_cb = push_handler;\n    assert((c = redisConnectWithOptions(&options)) != NULL);\n    test_cond(c->push_cb == push_handler);\n    redisFree(c);\n\n    test(\"We can use redisOptions to set a custom PUSH handler for redisAsyncContext: \");\n    options = get_redis_tcp_options(config);\n    options.async_push_cb = push_handler_async;\n    assert((ac = redisAsyncConnectWithOptions(&options)) != NULL);\n    test_cond(ac->push_cb == push_handler_async);\n    redisAsyncFree(ac);\n}\n\nvoid free_privdata(void *privdata) {\n    struct privdata *data = privdata;\n    data->dtor_counter++;\n}\n\nstatic void test_privdata_hooks(struct config config) {\n    struct privdata data = {0};\n    redisOptions options;\n    redisContext *c;\n\n    test(\"We can use redisOptions to set privdata: \");\n    options = get_redis_tcp_options(config);\n    REDIS_OPTIONS_SET_PRIVDATA(&options, &data, free_privdata);\n    assert((c = redisConnectWithOptions(&options)) != NULL);\n    test_cond(c->privdata == &data);\n\n    test(\"Our privdata destructor fires when we free the context: \");\n    redisFree(c);\n    test_cond(data.dtor_counter == 1);\n}\n\nstatic void test_blocking_connection(struct config config) {\n    redisContext *c;\n    redisReply *reply;\n    int major;\n\n    c = do_connect(config);\n\n    test(\"Is able to deliver commands: \");\n    reply = redisCommand(c,\"PING\");\n    test_cond(reply->type == REDIS_REPLY_STATUS &&\n        strcasecmp(reply->str,\"pong\") == 0)\n    freeReplyObject(reply);\n\n    test(\"Is a able to send commands verbatim: \");\n    reply = redisCommand(c,\"SET foo bar\");\n    test_cond (reply->type == REDIS_REPLY_STATUS &&\n        strcasecmp(reply->str,\"ok\") == 0)\n    freeReplyObject(reply);\n\n    test(\"%%s String interpolation works: \");\n    reply = redisCommand(c,\"SET %s %s\",\"foo\",\"hello world\");\n    freeReplyObject(reply);\n    reply = redisCommand(c,\"GET foo\");\n    test_cond(reply->type == REDIS_REPLY_STRING &&\n        strcmp(reply->str,\"hello world\") == 0);\n    freeReplyObject(reply);\n\n    test(\"%%b String interpolation works: \");\n    reply = redisCommand(c,\"SET %b %b\",\"foo\",(size_t)3,\"hello\\x00world\",(size_t)11);\n    freeReplyObject(reply);\n    reply = redisCommand(c,\"GET foo\");\n    test_cond(reply->type == REDIS_REPLY_STRING &&\n        memcmp(reply->str,\"hello\\x00world\",11) == 0)\n\n    test(\"Binary reply length is correct: \");\n    test_cond(reply->len == 11)\n    freeReplyObject(reply);\n\n    test(\"Can parse nil replies: \");\n    reply = redisCommand(c,\"GET nokey\");\n    test_cond(reply->type == REDIS_REPLY_NIL)\n    freeReplyObject(reply);\n\n    /* test 7 */\n    test(\"Can parse integer replies: \");\n    reply = redisCommand(c,\"INCR mycounter\");\n    test_cond(reply->type == REDIS_REPLY_INTEGER && reply->integer == 1)\n    freeReplyObject(reply);\n\n    test(\"Can parse multi bulk replies: \");\n    freeReplyObject(redisCommand(c,\"LPUSH mylist foo\"));\n    freeReplyObject(redisCommand(c,\"LPUSH mylist bar\"));\n    reply = redisCommand(c,\"LRANGE mylist 0 -1\");\n    test_cond(reply->type == REDIS_REPLY_ARRAY &&\n              reply->elements == 2 &&\n              !memcmp(reply->element[0]->str,\"bar\",3) &&\n              !memcmp(reply->element[1]->str,\"foo\",3))\n    freeReplyObject(reply);\n\n    /* m/e with multi bulk reply *before* other reply.\n     * specifically test ordering of reply items to parse. */\n    test(\"Can handle nested multi bulk replies: \");\n    freeReplyObject(redisCommand(c,\"MULTI\"));\n    freeReplyObject(redisCommand(c,\"LRANGE mylist 0 -1\"));\n    freeReplyObject(redisCommand(c,\"PING\"));\n    reply = (redisCommand(c,\"EXEC\"));\n    test_cond(reply->type == REDIS_REPLY_ARRAY &&\n              reply->elements == 2 &&\n              reply->element[0]->type == REDIS_REPLY_ARRAY &&\n              reply->element[0]->elements == 2 &&\n              !memcmp(reply->element[0]->element[0]->str,\"bar\",3) &&\n              !memcmp(reply->element[0]->element[1]->str,\"foo\",3) &&\n              reply->element[1]->type == REDIS_REPLY_STATUS &&\n              strcasecmp(reply->element[1]->str,\"pong\") == 0);\n    freeReplyObject(reply);\n\n    /* Make sure passing NULL to redisGetReply is safe */\n    test(\"Can pass NULL to redisGetReply: \");\n    assert(redisAppendCommand(c, \"PING\") == REDIS_OK);\n    test_cond(redisGetReply(c, NULL) == REDIS_OK);\n\n    get_redis_version(c, &major, NULL);\n    if (major >= 6) test_resp3_push_handler(c);\n    test_resp3_push_options(config);\n\n    test_privdata_hooks(config);\n\n    disconnect(c, 0);\n}\n\n/* Send DEBUG SLEEP 0 to detect if we have this command */\nstatic int detect_debug_sleep(redisContext *c) {\n    int detected;\n    redisReply *reply = redisCommand(c, \"DEBUG SLEEP 0\\r\\n\");\n\n    if (reply == NULL || c->err) {\n        const char *cause = c->err ? c->errstr : \"(none)\";\n        fprintf(stderr, \"Error testing for DEBUG SLEEP (Redis error: %s), exiting\\n\", cause);\n        exit(-1);\n    }\n\n    detected = reply->type == REDIS_REPLY_STATUS;\n    freeReplyObject(reply);\n\n    return detected;\n}\n\nstatic void test_blocking_connection_timeouts(struct config config) {\n    redisContext *c;\n    redisReply *reply;\n    ssize_t s;\n    const char *sleep_cmd = \"DEBUG SLEEP 3\\r\\n\";\n    struct timeval tv;\n\n    c = do_connect(config);\n    test(\"Successfully completes a command when the timeout is not exceeded: \");\n    reply = redisCommand(c,\"SET foo fast\");\n    freeReplyObject(reply);\n    tv.tv_sec = 0;\n    tv.tv_usec = 10000;\n    redisSetTimeout(c, tv);\n    reply = redisCommand(c, \"GET foo\");\n    test_cond(reply != NULL && reply->type == REDIS_REPLY_STRING && memcmp(reply->str, \"fast\", 4) == 0);\n    freeReplyObject(reply);\n    disconnect(c, 0);\n\n    c = do_connect(config);\n    test(\"Does not return a reply when the command times out: \");\n    if (detect_debug_sleep(c)) {\n        redisAppendFormattedCommand(c, sleep_cmd, strlen(sleep_cmd));\n        s = c->funcs->write(c);\n        tv.tv_sec = 0;\n        tv.tv_usec = 10000;\n        redisSetTimeout(c, tv);\n        reply = redisCommand(c, \"GET foo\");\n#ifndef _WIN32\n        test_cond(s > 0 && reply == NULL && c->err == REDIS_ERR_IO &&\n                  strcmp(c->errstr, \"Resource temporarily unavailable\") == 0);\n#else\n        test_cond(s > 0 && reply == NULL && c->err == REDIS_ERR_TIMEOUT &&\n                  strcmp(c->errstr, \"recv timeout\") == 0);\n#endif\n        freeReplyObject(reply);\n    } else {\n        test_skipped();\n    }\n\n    test(\"Reconnect properly reconnects after a timeout: \");\n    do_reconnect(c, config);\n    reply = redisCommand(c, \"PING\");\n    test_cond(reply != NULL && reply->type == REDIS_REPLY_STATUS && strcmp(reply->str, \"PONG\") == 0);\n    freeReplyObject(reply);\n\n    test(\"Reconnect properly uses owned parameters: \");\n    config.tcp.host = \"foo\";\n    config.unix_sock.path = \"foo\";\n    do_reconnect(c, config);\n    reply = redisCommand(c, \"PING\");\n    test_cond(reply != NULL && reply->type == REDIS_REPLY_STATUS && strcmp(reply->str, \"PONG\") == 0);\n    freeReplyObject(reply);\n\n    disconnect(c, 0);\n}\n\nstatic void test_blocking_io_errors(struct config config) {\n    redisContext *c;\n    redisReply *reply;\n    void *_reply;\n    int major, minor;\n\n    /* Connect to target given by config. */\n    c = do_connect(config);\n    get_redis_version(c, &major, &minor);\n\n    test(\"Returns I/O error when the connection is lost: \");\n    reply = redisCommand(c,\"QUIT\");\n    if (major > 2 || (major == 2 && minor > 0)) {\n        /* > 2.0 returns OK on QUIT and read() should be issued once more\n         * to know the descriptor is at EOF. */\n        test_cond(strcasecmp(reply->str,\"OK\") == 0 &&\n            redisGetReply(c,&_reply) == REDIS_ERR);\n        freeReplyObject(reply);\n    } else {\n        test_cond(reply == NULL);\n    }\n\n#ifndef _WIN32\n    /* On 2.0, QUIT will cause the connection to be closed immediately and\n     * the read(2) for the reply on QUIT will set the error to EOF.\n     * On >2.0, QUIT will return with OK and another read(2) needed to be\n     * issued to find out the socket was closed by the server. In both\n     * conditions, the error will be set to EOF. */\n    assert(c->err == REDIS_ERR_EOF &&\n        strcmp(c->errstr,\"Server closed the connection\") == 0);\n#endif\n    redisFree(c);\n\n    c = do_connect(config);\n    test(\"Returns I/O error on socket timeout: \");\n    struct timeval tv = { 0, 1000 };\n    assert(redisSetTimeout(c,tv) == REDIS_OK);\n    int respcode = redisGetReply(c,&_reply);\n#ifndef _WIN32\n    test_cond(respcode == REDIS_ERR && c->err == REDIS_ERR_IO && errno == EAGAIN);\n#else\n    test_cond(respcode == REDIS_ERR && c->err == REDIS_ERR_TIMEOUT);\n#endif\n    redisFree(c);\n}\n\nstatic void test_invalid_timeout_errors(struct config config) {\n    redisContext *c;\n\n    test(\"Set error when an invalid timeout usec value is given to redisConnectWithTimeout: \");\n\n    config.tcp.timeout.tv_sec = 0;\n    config.tcp.timeout.tv_usec = 10000001;\n\n    c = redisConnectWithTimeout(config.tcp.host, config.tcp.port, config.tcp.timeout);\n\n    test_cond(c->err == REDIS_ERR_IO && strcmp(c->errstr, \"Invalid timeout specified\") == 0);\n    redisFree(c);\n\n    test(\"Set error when an invalid timeout sec value is given to redisConnectWithTimeout: \");\n\n    config.tcp.timeout.tv_sec = (((LONG_MAX) - 999) / 1000) + 1;\n    config.tcp.timeout.tv_usec = 0;\n\n    c = redisConnectWithTimeout(config.tcp.host, config.tcp.port, config.tcp.timeout);\n\n    test_cond(c->err == REDIS_ERR_IO && strcmp(c->errstr, \"Invalid timeout specified\") == 0);\n    redisFree(c);\n}\n\n/* Wrap malloc to abort on failure so OOM checks don't make the test logic\n * harder to follow. */\nvoid *hi_malloc_safe(size_t size) {\n    void *ptr = hi_malloc(size);\n    if (ptr == NULL) {\n        fprintf(stderr, \"Error:  Out of memory\\n\");\n        exit(-1);\n    }\n\n    return ptr;\n}\n\nstatic void test_throughput(struct config config) {\n    redisContext *c = do_connect(config);\n    redisReply **replies;\n    int i, num;\n    long long t1, t2;\n\n    test(\"Throughput:\\n\");\n    for (i = 0; i < 500; i++)\n        freeReplyObject(redisCommand(c,\"LPUSH mylist foo\"));\n\n    num = 1000;\n    replies = hi_malloc_safe(sizeof(redisReply*)*num);\n    t1 = usec();\n    for (i = 0; i < num; i++) {\n        replies[i] = redisCommand(c,\"PING\");\n        assert(replies[i] != NULL && replies[i]->type == REDIS_REPLY_STATUS);\n    }\n    t2 = usec();\n    for (i = 0; i < num; i++) freeReplyObject(replies[i]);\n    hi_free(replies);\n    printf(\"\\t(%dx PING: %.3fs)\\n\", num, (t2-t1)/1000000.0);\n\n    replies = hi_malloc_safe(sizeof(redisReply*)*num);\n    t1 = usec();\n    for (i = 0; i < num; i++) {\n        replies[i] = redisCommand(c,\"LRANGE mylist 0 499\");\n        assert(replies[i] != NULL && replies[i]->type == REDIS_REPLY_ARRAY);\n        assert(replies[i] != NULL && replies[i]->elements == 500);\n    }\n    t2 = usec();\n    for (i = 0; i < num; i++) freeReplyObject(replies[i]);\n    hi_free(replies);\n    printf(\"\\t(%dx LRANGE with 500 elements: %.3fs)\\n\", num, (t2-t1)/1000000.0);\n\n    replies = hi_malloc_safe(sizeof(redisReply*)*num);\n    t1 = usec();\n    for (i = 0; i < num; i++) {\n        replies[i] = redisCommand(c, \"INCRBY incrkey %d\", 1000000);\n        assert(replies[i] != NULL && replies[i]->type == REDIS_REPLY_INTEGER);\n    }\n    t2 = usec();\n    for (i = 0; i < num; i++) freeReplyObject(replies[i]);\n    hi_free(replies);\n    printf(\"\\t(%dx INCRBY: %.3fs)\\n\", num, (t2-t1)/1000000.0);\n\n    num = 10000;\n    replies = hi_malloc_safe(sizeof(redisReply*)*num);\n    for (i = 0; i < num; i++)\n        redisAppendCommand(c,\"PING\");\n    t1 = usec();\n    for (i = 0; i < num; i++) {\n        assert(redisGetReply(c, (void*)&replies[i]) == REDIS_OK);\n        assert(replies[i] != NULL && replies[i]->type == REDIS_REPLY_STATUS);\n    }\n    t2 = usec();\n    for (i = 0; i < num; i++) freeReplyObject(replies[i]);\n    hi_free(replies);\n    printf(\"\\t(%dx PING (pipelined): %.3fs)\\n\", num, (t2-t1)/1000000.0);\n\n    replies = hi_malloc_safe(sizeof(redisReply*)*num);\n    for (i = 0; i < num; i++)\n        redisAppendCommand(c,\"LRANGE mylist 0 499\");\n    t1 = usec();\n    for (i = 0; i < num; i++) {\n        assert(redisGetReply(c, (void*)&replies[i]) == REDIS_OK);\n        assert(replies[i] != NULL && replies[i]->type == REDIS_REPLY_ARRAY);\n        assert(replies[i] != NULL && replies[i]->elements == 500);\n    }\n    t2 = usec();\n    for (i = 0; i < num; i++) freeReplyObject(replies[i]);\n    hi_free(replies);\n    printf(\"\\t(%dx LRANGE with 500 elements (pipelined): %.3fs)\\n\", num, (t2-t1)/1000000.0);\n\n    replies = hi_malloc_safe(sizeof(redisReply*)*num);\n    for (i = 0; i < num; i++)\n        redisAppendCommand(c,\"INCRBY incrkey %d\", 1000000);\n    t1 = usec();\n    for (i = 0; i < num; i++) {\n        assert(redisGetReply(c, (void*)&replies[i]) == REDIS_OK);\n        assert(replies[i] != NULL && replies[i]->type == REDIS_REPLY_INTEGER);\n    }\n    t2 = usec();\n    for (i = 0; i < num; i++) freeReplyObject(replies[i]);\n    hi_free(replies);\n    printf(\"\\t(%dx INCRBY (pipelined): %.3fs)\\n\", num, (t2-t1)/1000000.0);\n\n    disconnect(c, 0);\n}\n\n// static long __test_callback_flags = 0;\n// static void __test_callback(redisContext *c, void *privdata) {\n//     ((void)c);\n//     /* Shift to detect execution order */\n//     __test_callback_flags <<= 8;\n//     __test_callback_flags |= (long)privdata;\n// }\n//\n// static void __test_reply_callback(redisContext *c, redisReply *reply, void *privdata) {\n//     ((void)c);\n//     /* Shift to detect execution order */\n//     __test_callback_flags <<= 8;\n//     __test_callback_flags |= (long)privdata;\n//     if (reply) freeReplyObject(reply);\n// }\n//\n// static redisContext *__connect_nonblock() {\n//     /* Reset callback flags */\n//     __test_callback_flags = 0;\n//     return redisConnectNonBlock(\"127.0.0.1\", port, NULL);\n// }\n//\n// static void test_nonblocking_connection() {\n//     redisContext *c;\n//     int wdone = 0;\n//\n//     test(\"Calls command callback when command is issued: \");\n//     c = __connect_nonblock();\n//     redisSetCommandCallback(c,__test_callback,(void*)1);\n//     redisCommand(c,\"PING\");\n//     test_cond(__test_callback_flags == 1);\n//     redisFree(c);\n//\n//     test(\"Calls disconnect callback on redisDisconnect: \");\n//     c = __connect_nonblock();\n//     redisSetDisconnectCallback(c,__test_callback,(void*)2);\n//     redisDisconnect(c);\n//     test_cond(__test_callback_flags == 2);\n//     redisFree(c);\n//\n//     test(\"Calls disconnect callback and free callback on redisFree: \");\n//     c = __connect_nonblock();\n//     redisSetDisconnectCallback(c,__test_callback,(void*)2);\n//     redisSetFreeCallback(c,__test_callback,(void*)4);\n//     redisFree(c);\n//     test_cond(__test_callback_flags == ((2 << 8) | 4));\n//\n//     test(\"redisBufferWrite against empty write buffer: \");\n//     c = __connect_nonblock();\n//     test_cond(redisBufferWrite(c,&wdone) == REDIS_OK && wdone == 1);\n//     redisFree(c);\n//\n//     test(\"redisBufferWrite against not yet connected fd: \");\n//     c = __connect_nonblock();\n//     redisCommand(c,\"PING\");\n//     test_cond(redisBufferWrite(c,NULL) == REDIS_ERR &&\n//               strncmp(c->error,\"write:\",6) == 0);\n//     redisFree(c);\n//\n//     test(\"redisBufferWrite against closed fd: \");\n//     c = __connect_nonblock();\n//     redisCommand(c,\"PING\");\n//     redisDisconnect(c);\n//     test_cond(redisBufferWrite(c,NULL) == REDIS_ERR &&\n//               strncmp(c->error,\"write:\",6) == 0);\n//     redisFree(c);\n//\n//     test(\"Process callbacks in the right sequence: \");\n//     c = __connect_nonblock();\n//     redisCommandWithCallback(c,__test_reply_callback,(void*)1,\"PING\");\n//     redisCommandWithCallback(c,__test_reply_callback,(void*)2,\"PING\");\n//     redisCommandWithCallback(c,__test_reply_callback,(void*)3,\"PING\");\n//\n//     /* Write output buffer */\n//     wdone = 0;\n//     while(!wdone) {\n//         usleep(500);\n//         redisBufferWrite(c,&wdone);\n//     }\n//\n//     /* Read until at least one callback is executed (the 3 replies will\n//      * arrive in a single packet, causing all callbacks to be executed in\n//      * a single pass). */\n//     while(__test_callback_flags == 0) {\n//         assert(redisBufferRead(c) == REDIS_OK);\n//         redisProcessCallbacks(c);\n//     }\n//     test_cond(__test_callback_flags == 0x010203);\n//     redisFree(c);\n//\n//     test(\"redisDisconnect executes pending callbacks with NULL reply: \");\n//     c = __connect_nonblock();\n//     redisSetDisconnectCallback(c,__test_callback,(void*)1);\n//     redisCommandWithCallback(c,__test_reply_callback,(void*)2,\"PING\");\n//     redisDisconnect(c);\n//     test_cond(__test_callback_flags == 0x0201);\n//     redisFree(c);\n// }\n\nint main(int argc, char **argv) {\n    struct config cfg = {\n        .tcp = {\n            .host = \"127.0.0.1\",\n            .port = 6379\n        },\n        .unix_sock = {\n            .path = \"/tmp/redis.sock\"\n        }\n    };\n    int throughput = 1;\n    int test_inherit_fd = 1;\n    int skips_as_fails = 0;\n    int test_unix_socket;\n\n    /* Parse command line options. */\n    argv++; argc--;\n    while (argc) {\n        if (argc >= 2 && !strcmp(argv[0],\"-h\")) {\n            argv++; argc--;\n            cfg.tcp.host = argv[0];\n        } else if (argc >= 2 && !strcmp(argv[0],\"-p\")) {\n            argv++; argc--;\n            cfg.tcp.port = atoi(argv[0]);\n        } else if (argc >= 2 && !strcmp(argv[0],\"-s\")) {\n            argv++; argc--;\n            cfg.unix_sock.path = argv[0];\n        } else if (argc >= 1 && !strcmp(argv[0],\"--skip-throughput\")) {\n            throughput = 0;\n        } else if (argc >= 1 && !strcmp(argv[0],\"--skip-inherit-fd\")) {\n            test_inherit_fd = 0;\n        } else if (argc >= 1 && !strcmp(argv[0],\"--skips-as-fails\")) {\n            skips_as_fails = 1;\n#ifdef HIREDIS_TEST_SSL\n        } else if (argc >= 2 && !strcmp(argv[0],\"--ssl-port\")) {\n            argv++; argc--;\n            cfg.ssl.port = atoi(argv[0]);\n        } else if (argc >= 2 && !strcmp(argv[0],\"--ssl-host\")) {\n            argv++; argc--;\n            cfg.ssl.host = argv[0];\n        } else if (argc >= 2 && !strcmp(argv[0],\"--ssl-ca-cert\")) {\n            argv++; argc--;\n            cfg.ssl.ca_cert  = argv[0];\n        } else if (argc >= 2 && !strcmp(argv[0],\"--ssl-cert\")) {\n            argv++; argc--;\n            cfg.ssl.cert = argv[0];\n        } else if (argc >= 2 && !strcmp(argv[0],\"--ssl-key\")) {\n            argv++; argc--;\n            cfg.ssl.key = argv[0];\n#endif\n        } else {\n            fprintf(stderr, \"Invalid argument: %s\\n\", argv[0]);\n            exit(1);\n        }\n        argv++; argc--;\n    }\n\n#ifndef _WIN32\n    /* Ignore broken pipe signal (for I/O error tests). */\n    signal(SIGPIPE, SIG_IGN);\n\n    test_unix_socket = access(cfg.unix_sock.path, F_OK) == 0;\n\n#else\n    /* Unix sockets don't exist in Windows */\n    test_unix_socket = 0;\n#endif\n\n    test_allocator_injection();\n\n    test_format_commands();\n    test_reply_reader();\n    test_blocking_connection_errors();\n    test_free_null();\n\n    printf(\"\\nTesting against TCP connection (%s:%d):\\n\", cfg.tcp.host, cfg.tcp.port);\n    cfg.type = CONN_TCP;\n    test_blocking_connection(cfg);\n    test_blocking_connection_timeouts(cfg);\n    test_blocking_io_errors(cfg);\n    test_invalid_timeout_errors(cfg);\n    test_append_formatted_commands(cfg);\n    if (throughput) test_throughput(cfg);\n\n    printf(\"\\nTesting against Unix socket connection (%s): \", cfg.unix_sock.path);\n    if (test_unix_socket) {\n        printf(\"\\n\");\n        cfg.type = CONN_UNIX;\n        test_blocking_connection(cfg);\n        test_blocking_connection_timeouts(cfg);\n        test_blocking_io_errors(cfg);\n        if (throughput) test_throughput(cfg);\n    } else {\n        test_skipped();\n    }\n\n#ifdef HIREDIS_TEST_SSL\n    if (cfg.ssl.port && cfg.ssl.host) {\n\n        redisInitOpenSSL();\n        _ssl_ctx = redisCreateSSLContext(cfg.ssl.ca_cert, NULL, cfg.ssl.cert, cfg.ssl.key, NULL, NULL);\n        assert(_ssl_ctx != NULL);\n\n        printf(\"\\nTesting against SSL connection (%s:%d):\\n\", cfg.ssl.host, cfg.ssl.port);\n        cfg.type = CONN_SSL;\n\n        test_blocking_connection(cfg);\n        test_blocking_connection_timeouts(cfg);\n        test_blocking_io_errors(cfg);\n        test_invalid_timeout_errors(cfg);\n        test_append_formatted_commands(cfg);\n        if (throughput) test_throughput(cfg);\n\n        redisFreeSSLContext(_ssl_ctx);\n        _ssl_ctx = NULL;\n    }\n#endif\n\n    if (test_inherit_fd) {\n        printf(\"\\nTesting against inherited fd (%s): \", cfg.unix_sock.path);\n        if (test_unix_socket) {\n            printf(\"\\n\");\n            cfg.type = CONN_FD;\n            test_blocking_connection(cfg);\n        } else {\n            test_skipped();\n        }\n    }\n\n    if (fails || (skips_as_fails && skips)) {\n        printf(\"*** %d TESTS FAILED ***\\n\", fails);\n        if (skips) {\n            printf(\"*** %d TESTS SKIPPED ***\\n\", skips);\n        }\n        return 1;\n    }\n\n    printf(\"ALL TESTS PASSED (%d skipped)\\n\", skips);\n    return 0;\n}\n"], "filenames": ["deps/hiredis/hiredis.c", "deps/hiredis/test.c"], "buggy_code_start_loc": [176, 497], "buggy_code_end_loc": [176, 497], "fixing_code_start_loc": [177, 498], "fixing_code_end_loc": [178, 512], "type": "CWE-190", "message": "Redis is an open source, in-memory database that persists on disk. The redis-cli command line tool and redis-sentinel service may be vulnerable to integer overflow when parsing specially crafted large multi-bulk network replies. This is a result of a vulnerability in the underlying hiredis library which does not perform an overflow check before calling the calloc() heap allocation function. This issue only impacts systems with heap allocators that do not perform their own overflow checks. Most modern systems do and are therefore not likely to be affected. Furthermore, by default redis-sentinel uses the jemalloc allocator which is also not vulnerable. The problem is fixed in Redis versions 6.2.6, 6.0.16 and 5.0.14.", "other": {"cve": {"id": "CVE-2021-32762", "sourceIdentifier": "security-advisories@github.com", "published": "2021-10-04T18:15:09.043", "lastModified": "2022-10-06T16:53:25.217", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Redis is an open source, in-memory database that persists on disk. The redis-cli command line tool and redis-sentinel service may be vulnerable to integer overflow when parsing specially crafted large multi-bulk network replies. This is a result of a vulnerability in the underlying hiredis library which does not perform an overflow check before calling the calloc() heap allocation function. This issue only impacts systems with heap allocators that do not perform their own overflow checks. Most modern systems do and are therefore not likely to be affected. Furthermore, by default redis-sentinel uses the jemalloc allocator which is also not vulnerable. The problem is fixed in Redis versions 6.2.6, 6.0.16 and 5.0.14."}, {"lang": "es", "value": "Redis es una base de datos en memoria de c\u00f3digo abierto que persiste en el disco. La herramienta de l\u00ednea de comandos redis-cli y el servicio redis-sentinel pueden ser vulnerables a un desbordamiento de enteros cuando analizan respuestas de red de gran tama\u00f1o especialmente dise\u00f1adas. Esto es resultado de una vulnerabilidad en la biblioteca hiredis subyacente que no lleva a cabo una comprobaci\u00f3n de desbordamiento antes de llamar a la funci\u00f3n de asignaci\u00f3n de pila calloc(). Este problema s\u00f3lo afecta a los sistemas con asignadores de pila que no llevan a cabo sus propias comprobaciones de desbordamiento. La mayor\u00eda de los sistemas modernos lo hacen y, por lo tanto, no es probable que est\u00e9n afectados. Adem\u00e1s, por defecto redis-sentinel usa el asignador jemalloc que tampoco es vulnerable. El problema se ha corregido en las versiones de Redis 6.2.6, 6.0.16 y 5.0.14"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 9.0}, "baseSeverity": "HIGH", "exploitabilityScore": 8.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}, {"lang": "en", "value": "CWE-680"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.0.14", "matchCriteriaId": "D5D64A76-B253-4A64-8AA2-DD8815CB3CF8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0.0", "versionEndExcluding": "6.0.16", "matchCriteriaId": "02DF8086-645E-4D42-93D3-A4B11D289C7C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.2.0", "versionEndExcluding": "6.2.6", "matchCriteriaId": "4686800E-16BA-42CE-B691-011D1D5D0CC2"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:management_services_for_element_software:-:*:*:*:*:*:*:*", "matchCriteriaId": "86B51137-28D9-41F2-AFA2-3CC22B4954D1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:management_services_for_netapp_hci:-:*:*:*:*:*:*:*", "matchCriteriaId": "4455CF3A-CC91-4BE4-A7AB-929AC82E34F5"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_operations_monitor:4.3:*:*:*:*:*:*:*", "matchCriteriaId": "CBE1A019-7BB6-4226-8AC4-9D6927ADAEFA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_operations_monitor:4.4:*:*:*:*:*:*:*", "matchCriteriaId": "B98BAEB2-A540-4E8A-A946-C4331B913AFD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_operations_monitor:5.0:*:*:*:*:*:*:*", "matchCriteriaId": "B8FBE260-E306-4215-80C0-D2D27CA43E0F"}]}]}], "references": [{"url": "https://github.com/redis/redis/commit/0215324a66af949be39b34be2d55143232c1cb71", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/redis/redis/security/advisories/GHSA-833w-8v3m-8wwr", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HTYQ5ZF37HNGTZWVNJD3VXP7I6MEEF42/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VL5KXFN3ATM7IIM7Q4O4PWTSRGZ5744Z/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WR5WKJWXD4D6S3DJCZ56V74ESLTDQRAB/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202209-17", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20211104-0003/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2021/dsa-5001", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2022.html", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/redis/redis/commit/0215324a66af949be39b34be2d55143232c1cb71"}}