{"buggy_code": ["/* Copyright (C) 2007-2013 Open Information Security Foundation\n *\n * You can copy, redistribute or modify this Program under the terms of\n * the GNU General Public License version 2 as published by the Free\n * Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * version 2 along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n */\n\n/**\n * \\ingroup decode\n *\n * @{\n */\n\n\n/**\n * \\file\n *\n * \\author Victor Julien <victor@inliniac.net>\n *\n * Decode TCP\n */\n\n#include \"suricata-common.h\"\n#include \"decode.h\"\n#include \"decode-tcp.h\"\n#include \"decode-events.h\"\n#include \"util-unittest.h\"\n#include \"util-debug.h\"\n#include \"util-optimize.h\"\n#include \"flow.h\"\n#include \"util-profiling.h\"\n#include \"pkt-var.h\"\n#include \"host.h\"\n\n#define SET_OPTS(dst, src) \\\n    (dst).type = (src).type; \\\n    (dst).len  = (src).len; \\\n    (dst).data = (src).data\n\nstatic void DecodeTCPOptions(Packet *p, const uint8_t *pkt, uint16_t pktlen)\n{\n    uint8_t tcp_opt_cnt = 0;\n    TCPOpt tcp_opts[TCP_OPTMAX];\n\n    uint16_t plen = pktlen;\n    while (plen)\n    {\n        const uint8_t type = *pkt;\n\n        /* single byte options */\n        if (type == TCP_OPT_EOL) {\n            break;\n        } else if (type == TCP_OPT_NOP) {\n            pkt++;\n            plen--;\n\n        /* multibyte options */\n        } else {\n            if (plen < 2) {\n                break;\n            }\n\n            const uint8_t olen = *(pkt+1);\n\n            /* we already know that the total options len is valid,\n             * so here the len of the specific option must be bad.\n             * Also check for invalid lengths 0 and 1. */\n            if (unlikely(olen > plen || olen < 2)) {\n                ENGINE_SET_INVALID_EVENT(p, TCP_OPT_INVALID_LEN);\n                return;\n            }\n\n            tcp_opts[tcp_opt_cnt].type = type;\n            tcp_opts[tcp_opt_cnt].len  = olen;\n            tcp_opts[tcp_opt_cnt].data = (olen > 2) ? (pkt+2) : NULL;\n\n            /* we are parsing the most commonly used opts to prevent\n             * us from having to walk the opts list for these all the\n             * time. */\n            switch (type) {\n                case TCP_OPT_WS:\n                    if (olen != TCP_OPT_WS_LEN) {\n                        ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);\n                    } else {\n                        if (p->tcpvars.ws.type != 0) {\n                            ENGINE_SET_EVENT(p,TCP_OPT_DUPLICATE);\n                        } else {\n                            SET_OPTS(p->tcpvars.ws, tcp_opts[tcp_opt_cnt]);\n                        }\n                    }\n                    break;\n                case TCP_OPT_MSS:\n                    if (olen != TCP_OPT_MSS_LEN) {\n                        ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);\n                    } else {\n                        if (p->tcpvars.mss.type != 0) {\n                            ENGINE_SET_EVENT(p,TCP_OPT_DUPLICATE);\n                        } else {\n                            SET_OPTS(p->tcpvars.mss, tcp_opts[tcp_opt_cnt]);\n                        }\n                    }\n                    break;\n                case TCP_OPT_SACKOK:\n                    if (olen != TCP_OPT_SACKOK_LEN) {\n                        ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);\n                    } else {\n                        if (p->tcpvars.sackok.type != 0) {\n                            ENGINE_SET_EVENT(p,TCP_OPT_DUPLICATE);\n                        } else {\n                            SET_OPTS(p->tcpvars.sackok, tcp_opts[tcp_opt_cnt]);\n                        }\n                    }\n                    break;\n                case TCP_OPT_TS:\n                    if (olen != TCP_OPT_TS_LEN) {\n                        ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);\n                    } else {\n                        if (p->tcpvars.ts_set) {\n                            ENGINE_SET_EVENT(p,TCP_OPT_DUPLICATE);\n                        } else {\n                            uint32_t values[2];\n                            memcpy(&values, tcp_opts[tcp_opt_cnt].data, sizeof(values));\n                            p->tcpvars.ts_val = SCNtohl(values[0]);\n                            p->tcpvars.ts_ecr = SCNtohl(values[1]);\n                            p->tcpvars.ts_set = true;\n                        }\n                    }\n                    break;\n                case TCP_OPT_SACK:\n                    SCLogDebug(\"SACK option, len %u\", olen);\n                    if ((olen != 2) &&\n                           (olen < TCP_OPT_SACK_MIN_LEN ||\n                            olen > TCP_OPT_SACK_MAX_LEN ||\n                            !((olen - 2) % 8 == 0)))\n                    {\n                        ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);\n                    } else {\n                        if (p->tcpvars.sack.type != 0) {\n                            ENGINE_SET_EVENT(p,TCP_OPT_DUPLICATE);\n                        } else {\n                            SET_OPTS(p->tcpvars.sack, tcp_opts[tcp_opt_cnt]);\n                        }\n                    }\n                    break;\n                case TCP_OPT_TFO:\n                    SCLogDebug(\"TFO option, len %u\", olen);\n                    if ((olen != 2) && (olen < TCP_OPT_TFO_MIN_LEN || olen > TCP_OPT_TFO_MAX_LEN ||\n                                               !(((olen - 2) & 0x1) == 0))) {\n                        ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);\n                    } else {\n                        if (p->tcpvars.tfo.type != 0) {\n                            ENGINE_SET_EVENT(p,TCP_OPT_DUPLICATE);\n                        } else {\n                            SET_OPTS(p->tcpvars.tfo, tcp_opts[tcp_opt_cnt]);\n                        }\n                    }\n                    break;\n                /* experimental options, could be TFO */\n                case TCP_OPT_EXP1:\n                case TCP_OPT_EXP2:\n                    SCLogDebug(\"TCP EXP option, len %u\", olen);\n                    if (olen == 4 || olen == 12) {\n                        uint16_t magic = SCNtohs(*(uint16_t *)tcp_opts[tcp_opt_cnt].data);\n                        if (magic == 0xf989) {\n                            if (p->tcpvars.tfo.type != 0) {\n                                ENGINE_SET_EVENT(p,TCP_OPT_DUPLICATE);\n                            } else {\n                                SET_OPTS(p->tcpvars.tfo, tcp_opts[tcp_opt_cnt]);\n                                p->tcpvars.tfo.type = TCP_OPT_TFO; // treat as regular TFO\n                            }\n                        }\n                    } else {\n                        ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);\n                    }\n                    break;\n            }\n\n            pkt += olen;\n            plen -= olen;\n            tcp_opt_cnt++;\n        }\n    }\n}\n\nstatic int DecodeTCPPacket(ThreadVars *tv, Packet *p, const uint8_t *pkt, uint16_t len)\n{\n    if (unlikely(len < TCP_HEADER_LEN)) {\n        ENGINE_SET_INVALID_EVENT(p, TCP_PKT_TOO_SMALL);\n        return -1;\n    }\n\n    p->tcph = (TCPHdr *)pkt;\n\n    uint8_t hlen = TCP_GET_HLEN(p);\n    if (unlikely(len < hlen)) {\n        ENGINE_SET_INVALID_EVENT(p, TCP_HLEN_TOO_SMALL);\n        return -1;\n    }\n\n    uint8_t tcp_opt_len = hlen - TCP_HEADER_LEN;\n    if (unlikely(tcp_opt_len > TCP_OPTLENMAX)) {\n        ENGINE_SET_INVALID_EVENT(p, TCP_INVALID_OPTLEN);\n        return -1;\n    }\n\n    if (likely(tcp_opt_len > 0)) {\n        DecodeTCPOptions(p, pkt + TCP_HEADER_LEN, tcp_opt_len);\n    }\n\n    SET_TCP_SRC_PORT(p,&p->sp);\n    SET_TCP_DST_PORT(p,&p->dp);\n\n    p->proto = IPPROTO_TCP;\n\n    p->payload = (uint8_t *)pkt + hlen;\n    p->payload_len = len - hlen;\n\n    return 0;\n}\n\nint DecodeTCP(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p,\n        const uint8_t *pkt, uint16_t len)\n{\n    StatsIncr(tv, dtv->counter_tcp);\n\n    if (unlikely(DecodeTCPPacket(tv, p, pkt,len) < 0)) {\n        SCLogDebug(\"invalid TCP packet\");\n        CLEAR_TCP_PACKET(p);\n        return TM_ECODE_FAILED;\n    }\n\n#ifdef DEBUG\n    SCLogDebug(\"TCP sp: %\" PRIu32 \" -> dp: %\" PRIu32 \" - HLEN: %\" PRIu32 \" LEN: %\" PRIu32 \" %s%s%s%s%s%s\",\n        GET_TCP_SRC_PORT(p), GET_TCP_DST_PORT(p), TCP_GET_HLEN(p), len,\n        TCP_HAS_SACKOK(p) ? \"SACKOK \" : \"\", TCP_HAS_SACK(p) ? \"SACK \" : \"\",\n        TCP_HAS_WSCALE(p) ? \"WS \" : \"\", TCP_HAS_TS(p) ? \"TS \" : \"\",\n        TCP_HAS_MSS(p) ? \"MSS \" : \"\", TCP_HAS_TFO(p) ? \"TFO \" : \"\");\n#endif\n\n    FlowSetupPacket(p);\n\n    return TM_ECODE_OK;\n}\n\n#ifdef UNITTESTS\nstatic int TCPCalculateValidChecksumtest01(void)\n{\n    uint16_t csum = 0;\n\n    uint8_t raw_ipshdr[] = {\n        0x40, 0x8e, 0x7e, 0xb2, 0xc0, 0xa8, 0x01, 0x03};\n\n    uint8_t raw_tcp[] = {\n        0x00, 0x50, 0x8e, 0x16, 0x0d, 0x59, 0xcd, 0x3c,\n        0xcf, 0x0d, 0x21, 0x80, 0xa0, 0x12, 0x16, 0xa0,\n        0xfa, 0x03, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4,\n        0x04, 0x02, 0x08, 0x0a, 0x6e, 0x18, 0x78, 0x73,\n        0x01, 0x71, 0x74, 0xde, 0x01, 0x03, 0x03, 02};\n\n    csum = *( ((uint16_t *)raw_tcp) + 8);\n\n    FAIL_IF(TCPChecksum((uint16_t *)raw_ipshdr,\n            (uint16_t *)raw_tcp, sizeof(raw_tcp), csum) != 0);\n    PASS;\n}\n\nstatic int TCPCalculateInvalidChecksumtest02(void)\n{\n    uint16_t csum = 0;\n\n    uint8_t raw_ipshdr[] = {\n        0x40, 0x8e, 0x7e, 0xb2, 0xc0, 0xa8, 0x01, 0x03};\n\n    uint8_t raw_tcp[] = {\n        0x00, 0x50, 0x8e, 0x16, 0x0d, 0x59, 0xcd, 0x3c,\n        0xcf, 0x0d, 0x21, 0x80, 0xa0, 0x12, 0x16, 0xa0,\n        0xfa, 0x03, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4,\n        0x04, 0x02, 0x08, 0x0a, 0x6e, 0x18, 0x78, 0x73,\n        0x01, 0x71, 0x74, 0xde, 0x01, 0x03, 0x03, 03};\n\n    csum = *( ((uint16_t *)raw_tcp) + 8);\n\n    FAIL_IF(TCPChecksum((uint16_t *) raw_ipshdr,\n            (uint16_t *)raw_tcp, sizeof(raw_tcp), csum) == 0);\n    PASS;\n}\n\nstatic int TCPV6CalculateValidChecksumtest03(void)\n{\n    uint16_t csum = 0;\n\n    static uint8_t raw_ipv6[] = {\n        0x00, 0x60, 0x97, 0x07, 0x69, 0xea, 0x00, 0x00,\n        0x86, 0x05, 0x80, 0xda, 0x86, 0xdd, 0x60, 0x00,\n        0x00, 0x00, 0x00, 0x20, 0x06, 0x40, 0x3f, 0xfe,\n        0x05, 0x07, 0x00, 0x00, 0x00, 0x01, 0x02, 0x00,\n        0x86, 0xff, 0xfe, 0x05, 0x80, 0xda, 0x3f, 0xfe,\n        0x05, 0x01, 0x04, 0x10, 0x00, 0x00, 0x02, 0xc0,\n        0xdf, 0xff, 0xfe, 0x47, 0x03, 0x3e, 0x03, 0xfe,\n        0x00, 0x16, 0xd6, 0x76, 0xf5, 0x2d, 0x0c, 0x7a,\n        0x08, 0x77, 0x80, 0x10, 0x21, 0x5c, 0xc2, 0xf1,\n        0x00, 0x00, 0x01, 0x01, 0x08, 0x0a, 0x00, 0x08,\n        0xca, 0x5a, 0x00, 0x01, 0x69, 0x27};\n\n    csum = *( ((uint16_t *)(raw_ipv6 + 70)));\n\n    FAIL_IF(TCPV6Checksum((uint16_t *)(raw_ipv6 + 14 + 8),\n            (uint16_t *)(raw_ipv6 + 54), 32, csum) != 0);\n    PASS;\n}\n\nstatic int TCPV6CalculateInvalidChecksumtest04(void)\n{\n    uint16_t csum = 0;\n\n    static uint8_t raw_ipv6[] = {\n        0x00, 0x60, 0x97, 0x07, 0x69, 0xea, 0x00, 0x00,\n        0x86, 0x05, 0x80, 0xda, 0x86, 0xdd, 0x60, 0x00,\n        0x00, 0x00, 0x00, 0x20, 0x06, 0x40, 0x3f, 0xfe,\n        0x05, 0x07, 0x00, 0x00, 0x00, 0x01, 0x02, 0x00,\n        0x86, 0xff, 0xfe, 0x05, 0x80, 0xda, 0x3f, 0xfe,\n        0x05, 0x01, 0x04, 0x10, 0x00, 0x00, 0x02, 0xc0,\n        0xdf, 0xff, 0xfe, 0x47, 0x03, 0x3e, 0x03, 0xfe,\n        0x00, 0x16, 0xd6, 0x76, 0xf5, 0x2d, 0x0c, 0x7a,\n        0x08, 0x77, 0x80, 0x10, 0x21, 0x5c, 0xc2, 0xf1,\n        0x00, 0x00, 0x01, 0x01, 0x08, 0x0a, 0x00, 0x08,\n        0xca, 0x5a, 0x00, 0x01, 0x69, 0x28};\n\n    csum = *( ((uint16_t *)(raw_ipv6 + 70)));\n\n    FAIL_IF(TCPV6Checksum((uint16_t *)(raw_ipv6 + 14 + 8),\n            (uint16_t *)(raw_ipv6 + 54), 32, csum) == 0);\n    PASS;\n}\n\n/** \\test Get the wscale of 2 */\nstatic int TCPGetWscaleTest01(void)\n{\n    int retval = 0;\n    static uint8_t raw_tcp[] = {0xda, 0xc1, 0x00, 0x50, 0xb6, 0x21, 0x7f, 0x58,\n                                0x00, 0x00, 0x00, 0x00, 0xa0, 0x02, 0x16, 0xd0,\n                                0x8a, 0xaf, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4,\n                                0x04, 0x02, 0x08, 0x0a, 0x00, 0x62, 0x88, 0x28,\n                                0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x02};\n    Packet *p = PacketGetFromAlloc();\n    if (unlikely(p == NULL))\n        return 0;\n    IPV4Hdr ip4h;\n    ThreadVars tv;\n    DecodeThreadVars dtv;\n\n    memset(&tv, 0, sizeof(ThreadVars));\n    memset(&dtv, 0, sizeof(DecodeThreadVars));\n    memset(&ip4h, 0, sizeof(IPV4Hdr));\n\n    p->src.family = AF_INET;\n    p->dst.family = AF_INET;\n    p->ip4h = &ip4h;\n\n\n    FlowInitConfig(FLOW_QUIET);\n    DecodeTCP(&tv, &dtv, p, raw_tcp, sizeof(raw_tcp));\n\n    if (p->tcph == NULL) {\n        printf(\"tcp packet decode failed: \");\n        goto end;\n    }\n\n    uint8_t wscale = TCP_GET_WSCALE(p);\n    if (wscale != 2) {\n        printf(\"wscale %\"PRIu8\", expected 2: \", wscale);\n        goto end;\n    }\n\n    retval = 1;\nend:\n    PACKET_RECYCLE(p);\n    FlowShutdown();\n    SCFree(p);\n    return retval;\n}\n\n/** \\test Get the wscale of 15, so see if return 0 properly */\nstatic int TCPGetWscaleTest02(void)\n{\n    int retval = 0;\n    static uint8_t raw_tcp[] = {0xda, 0xc1, 0x00, 0x50, 0xb6, 0x21, 0x7f, 0x58,\n                                0x00, 0x00, 0x00, 0x00, 0xa0, 0x02, 0x16, 0xd0,\n                                0x8a, 0xaf, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4,\n                                0x04, 0x02, 0x08, 0x0a, 0x00, 0x62, 0x88, 0x28,\n                                0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x0f};\n    Packet *p = PacketGetFromAlloc();\n    if (unlikely(p == NULL))\n        return 0;\n    IPV4Hdr ip4h;\n    ThreadVars tv;\n    DecodeThreadVars dtv;\n\n    memset(&tv, 0, sizeof(ThreadVars));\n    memset(&dtv, 0, sizeof(DecodeThreadVars));\n    memset(&ip4h, 0, sizeof(IPV4Hdr));\n\n    p->src.family = AF_INET;\n    p->dst.family = AF_INET;\n    p->ip4h = &ip4h;\n\n    FlowInitConfig(FLOW_QUIET);\n    DecodeTCP(&tv, &dtv, p, raw_tcp, sizeof(raw_tcp));\n\n    if (p->tcph == NULL) {\n        printf(\"tcp packet decode failed: \");\n        goto end;\n    }\n\n    uint8_t wscale = TCP_GET_WSCALE(p);\n    if (wscale != 0) {\n        printf(\"wscale %\"PRIu8\", expected 0: \", wscale);\n        goto end;\n    }\n\n    retval = 1;\nend:\n    PACKET_RECYCLE(p);\n    FlowShutdown();\n    SCFree(p);\n    return retval;\n}\n\n/** \\test Get the wscale, but it's missing, so see if return 0 properly */\nstatic int TCPGetWscaleTest03(void)\n{\n    int retval = 0;\n    static uint8_t raw_tcp[] = {0xda, 0xc1, 0x00, 0x50, 0xb6, 0x21, 0x7f, 0x59,\n                                0xdd, 0xa3, 0x6f, 0xf8, 0x80, 0x10, 0x05, 0xb4,\n                                0x7c, 0x70, 0x00, 0x00, 0x01, 0x01, 0x08, 0x0a,\n                                0x00, 0x62, 0x88, 0x9e, 0x00, 0x00, 0x00, 0x00};\n    Packet *p = PacketGetFromAlloc();\n    if (unlikely(p == NULL))\n        return 0;\n    IPV4Hdr ip4h;\n    ThreadVars tv;\n    DecodeThreadVars dtv;\n\n    memset(&tv, 0, sizeof(ThreadVars));\n    memset(&dtv, 0, sizeof(DecodeThreadVars));\n    memset(&ip4h, 0, sizeof(IPV4Hdr));\n\n    p->src.family = AF_INET;\n    p->dst.family = AF_INET;\n    p->ip4h = &ip4h;\n\n    FlowInitConfig(FLOW_QUIET);\n    DecodeTCP(&tv, &dtv, p, raw_tcp, sizeof(raw_tcp));\n\n    if (p->tcph == NULL) {\n        printf(\"tcp packet decode failed: \");\n        goto end;\n    }\n\n    uint8_t wscale = TCP_GET_WSCALE(p);\n    if (wscale != 0) {\n        printf(\"wscale %\"PRIu8\", expected 0: \", wscale);\n        goto end;\n    }\n\n    retval = 1;\nend:\n    PACKET_RECYCLE(p);\n    FlowShutdown();\n    SCFree(p);\n    return retval;\n}\n\nstatic int TCPGetSackTest01(void)\n{\n    int retval = 0;\n    static uint8_t raw_tcp[] = {\n        0x00, 0x50, 0x06, 0xa6, 0xfa, 0x87, 0x0b, 0xf5,\n        0xf1, 0x59, 0x02, 0xe0, 0xa0, 0x10, 0x3e, 0xbc,\n        0x1d, 0xe7, 0x00, 0x00, 0x01, 0x01, 0x05, 0x12,\n        0xf1, 0x59, 0x13, 0xfc, 0xf1, 0x59, 0x1f, 0x64,\n        0xf1, 0x59, 0x08, 0x94, 0xf1, 0x59, 0x0e, 0x48 };\n    static uint8_t raw_tcp_sack[] = {\n        0xf1, 0x59, 0x13, 0xfc, 0xf1, 0x59, 0x1f, 0x64,\n        0xf1, 0x59, 0x08, 0x94, 0xf1, 0x59, 0x0e, 0x48 };\n    Packet *p = PacketGetFromAlloc();\n    if (unlikely(p == NULL))\n        return 0;\n    IPV4Hdr ip4h;\n    ThreadVars tv;\n    DecodeThreadVars dtv;\n\n    memset(&tv, 0, sizeof(ThreadVars));\n    memset(&dtv, 0, sizeof(DecodeThreadVars));\n    memset(&ip4h, 0, sizeof(IPV4Hdr));\n\n    p->src.family = AF_INET;\n    p->dst.family = AF_INET;\n    p->ip4h = &ip4h;\n\n    FlowInitConfig(FLOW_QUIET);\n    DecodeTCP(&tv, &dtv, p, raw_tcp, sizeof(raw_tcp));\n\n    if (p->tcph == NULL) {\n        printf(\"tcp packet decode failed: \");\n        goto end;\n    }\n\n    if (!TCP_HAS_SACK(p)) {\n        printf(\"tcp packet sack not decoded: \");\n        goto end;\n    }\n\n    int sack = TCP_GET_SACK_CNT(p);\n    if (sack != 2) {\n        printf(\"expected 2 sack records, got %u: \", TCP_GET_SACK_CNT(p));\n        goto end;\n    }\n\n    const uint8_t *sackptr = TCP_GET_SACK_PTR(p);\n    if (sackptr == NULL) {\n        printf(\"no sack data: \");\n        goto end;\n    }\n\n    if (memcmp(sackptr, raw_tcp_sack, 16) != 0) {\n        printf(\"malformed sack data: \");\n        goto end;\n    }\n\n    retval = 1;\nend:\n    PACKET_RECYCLE(p);\n    FlowShutdown();\n    SCFree(p);\n    return retval;\n}\n#endif /* UNITTESTS */\n\nvoid DecodeTCPRegisterTests(void)\n{\n#ifdef UNITTESTS\n    UtRegisterTest(\"TCPCalculateValidChecksumtest01\",\n                   TCPCalculateValidChecksumtest01);\n    UtRegisterTest(\"TCPCalculateInvalidChecksumtest02\",\n                   TCPCalculateInvalidChecksumtest02);\n    UtRegisterTest(\"TCPV6CalculateValidChecksumtest03\",\n                   TCPV6CalculateValidChecksumtest03);\n    UtRegisterTest(\"TCPV6CalculateInvalidChecksumtest04\",\n                   TCPV6CalculateInvalidChecksumtest04);\n    UtRegisterTest(\"TCPGetWscaleTest01\", TCPGetWscaleTest01);\n    UtRegisterTest(\"TCPGetWscaleTest02\", TCPGetWscaleTest02);\n    UtRegisterTest(\"TCPGetWscaleTest03\", TCPGetWscaleTest03);\n    UtRegisterTest(\"TCPGetSackTest01\", TCPGetSackTest01);\n#endif /* UNITTESTS */\n}\n/**\n * @}\n */\n", "/* Copyright (C) 2007-2013 Open Information Security Foundation\n *\n * You can copy, redistribute or modify this Program under the terms of\n * the GNU General Public License version 2 as published by the Free\n * Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * version 2 along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n */\n\n/**\n * \\file\n *\n * \\author Victor Julien <victor@inliniac.net>\n * \\todo RAW* macro's should be returning the raw value, not the host order\n */\n\n#ifndef __DECODE_TCP_H__\n#define __DECODE_TCP_H__\n\n#define TCP_HEADER_LEN                       20\n#define TCP_OPTLENMAX                        40\n#define TCP_OPTMAX                           20 /* every opt is at least 2 bytes\n                                                 * (type + len), except EOL and NOP */\n\n/* TCP flags */\n\n#define TH_FIN                               0x01\n#define TH_SYN                               0x02\n#define TH_RST                               0x04\n#define TH_PUSH                              0x08\n#define TH_ACK                               0x10\n#define TH_URG                               0x20\n/** Establish a new connection reducing window */\n#define TH_ECN                               0x40\n/** Echo Congestion flag */\n#define TH_CWR                               0x80\n\n/* tcp option codes */\n#define TCP_OPT_EOL                          0x00\n#define TCP_OPT_NOP                          0x01\n#define TCP_OPT_MSS                          0x02\n#define TCP_OPT_WS                           0x03\n#define TCP_OPT_SACKOK                       0x04\n#define TCP_OPT_SACK                         0x05\n#define TCP_OPT_TS                           0x08\n#define TCP_OPT_TFO                          0x22   /* TCP Fast Open */\n#define TCP_OPT_EXP1                         0xfd   /* Experimental, could be TFO */\n#define TCP_OPT_EXP2                         0xfe   /* Experimental, could be TFO */\n\n#define TCP_OPT_SACKOK_LEN                   2\n#define TCP_OPT_WS_LEN                       3\n#define TCP_OPT_TS_LEN                       10\n#define TCP_OPT_MSS_LEN                      4\n#define TCP_OPT_SACK_MIN_LEN                 10 /* hdr 2, 1 pair 8 = 10 */\n#define TCP_OPT_SACK_MAX_LEN                 34 /* hdr 2, 4 pair 32= 34 */\n#define TCP_OPT_TFO_MIN_LEN                  6  /* kind, len, 6 */\n#define TCP_OPT_TFO_MAX_LEN                  18 /* kind, len, 18 */\n\n/** Max valid wscale value. */\n#define TCP_WSCALE_MAX                       14\n\n#define TCP_GET_RAW_OFFSET(tcph)             (((tcph)->th_offx2 & 0xf0) >> 4)\n#define TCP_GET_RAW_X2(tcph)                 (unsigned char)((tcph)->th_offx2 & 0x0f)\n#define TCP_GET_RAW_SRC_PORT(tcph)           SCNtohs((tcph)->th_sport)\n#define TCP_GET_RAW_DST_PORT(tcph)           SCNtohs((tcph)->th_dport)\n\n#define TCP_SET_RAW_TCP_OFFSET(tcph, value)  ((tcph)->th_offx2 = (unsigned char)(((tcph)->th_offx2 & 0x0f) | (value << 4)))\n#define TCP_SET_RAW_TCP_X2(tcph, value)      ((tcph)->th_offx2 = (unsigned char)(((tcph)->th_offx2 & 0xf0) | (value & 0x0f)))\n\n#define TCP_GET_RAW_SEQ(tcph)                SCNtohl((tcph)->th_seq)\n#define TCP_GET_RAW_ACK(tcph)                SCNtohl((tcph)->th_ack)\n\n#define TCP_GET_RAW_WINDOW(tcph)             SCNtohs((tcph)->th_win)\n#define TCP_GET_RAW_URG_POINTER(tcph)        SCNtohs((tcph)->th_urp)\n#define TCP_GET_RAW_SUM(tcph)                SCNtohs((tcph)->th_sum)\n\n/** macro for getting the first timestamp from the packet in host order */\n#define TCP_GET_TSVAL(p)                    ((p)->tcpvars.ts_val)\n\n/** macro for getting the second timestamp from the packet in host order. */\n#define TCP_GET_TSECR(p)                    ((p)->tcpvars.ts_ecr)\n\n#define TCP_HAS_WSCALE(p)                   ((p)->tcpvars.ws.type == TCP_OPT_WS)\n#define TCP_HAS_SACK(p)                     ((p)->tcpvars.sack.type == TCP_OPT_SACK)\n#define TCP_HAS_SACKOK(p)                   ((p)->tcpvars.sackok.type == TCP_OPT_SACKOK)\n#define TCP_HAS_TS(p)                       ((p)->tcpvars.ts_set)\n#define TCP_HAS_MSS(p)                      ((p)->tcpvars.mss.type == TCP_OPT_MSS)\n#define TCP_HAS_TFO(p)                      ((p)->tcpvars.tfo.type == TCP_OPT_TFO)\n\n/** macro for getting the wscale from the packet. */\n#define TCP_GET_WSCALE(p)                    (TCP_HAS_WSCALE((p)) ? \\\n                                                (((*(uint8_t *)(p)->tcpvars.ws.data) <= TCP_WSCALE_MAX) ? \\\n                                                  (*(uint8_t *)((p)->tcpvars.ws.data)) : 0) : 0)\n\n#define TCP_GET_SACKOK(p)                    (TCP_HAS_SACKOK((p)) ? 1 : 0)\n#define TCP_GET_SACK_PTR(p)                  TCP_HAS_SACK((p)) ? (p)->tcpvars.sack.data : NULL\n#define TCP_GET_SACK_CNT(p)                  (TCP_HAS_SACK((p)) ? (((p)->tcpvars.sack.len - 2) / 8) : 0)\n#define TCP_GET_MSS(p)                       SCNtohs(*(uint16_t *)((p)->tcpvars.mss.data))\n\n#define TCP_GET_OFFSET(p)                    TCP_GET_RAW_OFFSET((p)->tcph)\n#define TCP_GET_X2(p)                        TCP_GET_RAW_X2((p)->tcph)\n#define TCP_GET_HLEN(p)                      (TCP_GET_OFFSET((p)) << 2)\n#define TCP_GET_SRC_PORT(p)                  TCP_GET_RAW_SRC_PORT((p)->tcph)\n#define TCP_GET_DST_PORT(p)                  TCP_GET_RAW_DST_PORT((p)->tcph)\n#define TCP_GET_SEQ(p)                       TCP_GET_RAW_SEQ((p)->tcph)\n#define TCP_GET_ACK(p)                       TCP_GET_RAW_ACK((p)->tcph)\n#define TCP_GET_WINDOW(p)                    TCP_GET_RAW_WINDOW((p)->tcph)\n#define TCP_GET_URG_POINTER(p)               TCP_GET_RAW_URG_POINTER((p)->tcph)\n#define TCP_GET_SUM(p)                       TCP_GET_RAW_SUM((p)->tcph)\n#define TCP_GET_FLAGS(p)                     (p)->tcph->th_flags\n\n#define TCP_ISSET_FLAG_FIN(p)                ((p)->tcph->th_flags & TH_FIN)\n#define TCP_ISSET_FLAG_SYN(p)                ((p)->tcph->th_flags & TH_SYN)\n#define TCP_ISSET_FLAG_RST(p)                ((p)->tcph->th_flags & TH_RST)\n#define TCP_ISSET_FLAG_PUSH(p)               ((p)->tcph->th_flags & TH_PUSH)\n#define TCP_ISSET_FLAG_ACK(p)                ((p)->tcph->th_flags & TH_ACK)\n#define TCP_ISSET_FLAG_URG(p)                ((p)->tcph->th_flags & TH_URG)\n#define TCP_ISSET_FLAG_RES2(p)               ((p)->tcph->th_flags & TH_RES2)\n#define TCP_ISSET_FLAG_RES1(p)               ((p)->tcph->th_flags & TH_RES1)\n\ntypedef struct TCPOpt_ {\n    uint8_t type;\n    uint8_t len;\n    const uint8_t *data;\n} TCPOpt;\n\ntypedef struct TCPOptSackRecord_ {\n    uint32_t le;        /**< left edge, network order */\n    uint32_t re;        /**< right edge, network order */\n} TCPOptSackRecord;\n\ntypedef struct TCPHdr_\n{\n    uint16_t th_sport;  /**< source port */\n    uint16_t th_dport;  /**< destination port */\n    uint32_t th_seq;    /**< sequence number */\n    uint32_t th_ack;    /**< acknowledgement number */\n    uint8_t th_offx2;   /**< offset and reserved */\n    uint8_t th_flags;   /**< pkt flags */\n    uint16_t th_win;    /**< pkt window */\n    uint16_t th_sum;    /**< checksum */\n    uint16_t th_urp;    /**< urgent pointer */\n} __attribute__((__packed__)) TCPHdr;\n\ntypedef struct TCPVars_\n{\n    /* commonly used and needed opts */\n    bool ts_set;\n    uint32_t ts_val;    /* host-order */\n    uint32_t ts_ecr;    /* host-order */\n    TCPOpt sack;\n    TCPOpt sackok;\n    TCPOpt ws;\n    TCPOpt mss;\n    TCPOpt tfo;         /* tcp fast open */\n} TCPVars;\n\n#define CLEAR_TCP_PACKET(p) {   \\\n    (p)->level4_comp_csum = -1; \\\n    PACKET_CLEAR_L4VARS((p));   \\\n    (p)->tcph = NULL;           \\\n}\n\nvoid DecodeTCPRegisterTests(void);\n\n/** -------- Inline functions ------- */\nstatic inline uint16_t TCPChecksum(uint16_t *, uint16_t *, uint16_t, uint16_t);\nstatic inline uint16_t TCPV6Checksum(uint16_t *, uint16_t *, uint16_t, uint16_t);\n\n/**\n * \\brief Calculate or validate the checksum for the TCP packet\n *\n * \\param shdr Pointer to source address field from the IP packet.  Used as a\n *             part of the pseudoheader for computing the checksum\n * \\param pkt  Pointer to the start of the TCP packet\n * \\param tlen Total length of the TCP packet(header + payload)\n * \\param init The current checksum if validating, 0 if generating.\n *\n * \\retval csum For validation 0 will be returned for success, for calculation\n *    this will be the checksum.\n */\nstatic inline uint16_t TCPChecksum(uint16_t *shdr, uint16_t *pkt,\n                                   uint16_t tlen, uint16_t init)\n{\n    uint16_t pad = 0;\n    uint32_t csum = init;\n\n    csum += shdr[0] + shdr[1] + shdr[2] + shdr[3] + htons(6) + htons(tlen);\n\n    csum += pkt[0] + pkt[1] + pkt[2] + pkt[3] + pkt[4] + pkt[5] + pkt[6] +\n        pkt[7] + pkt[9];\n\n    tlen -= 20;\n    pkt += 10;\n\n    while (tlen >= 32) {\n        csum += pkt[0] + pkt[1] + pkt[2] + pkt[3] + pkt[4] + pkt[5] + pkt[6] +\n            pkt[7] +\n            pkt[8] +\n            pkt[9] + pkt[10] + pkt[11] + pkt[12] + pkt[13] +\n            pkt[14] + pkt[15];\n        tlen -= 32;\n        pkt += 16;\n    }\n\n    while(tlen >= 8) {\n        csum += pkt[0] + pkt[1] + pkt[2] + pkt[3];\n        tlen -= 8;\n        pkt += 4;\n    }\n\n    while(tlen >= 4) {\n        csum += pkt[0] + pkt[1];\n        tlen -= 4;\n        pkt += 2;\n    }\n\n    while (tlen > 1) {\n        csum += pkt[0];\n        pkt += 1;\n        tlen -= 2;\n    }\n\n    if (tlen == 1) {\n        *(uint8_t *)(&pad) = (*(uint8_t *)pkt);\n        csum += pad;\n    }\n\n    csum = (csum >> 16) + (csum & 0x0000FFFF);\n    csum += (csum >> 16);\n\n    return (uint16_t)~csum;\n}\n\n/**\n * \\brief Calculate or validate the checksum for the TCP packet\n *\n * \\param shdr Pointer to source address field from the IPV6 packet.  Used as a\n *             part of the psuedoheader for computing the checksum\n * \\param pkt  Pointer to the start of the TCP packet\n * \\param tlen Total length of the TCP packet(header + payload)\n * \\param init The current checksum if validating, 0 if generating.\n *\n * \\retval csum For validation 0 will be returned for success, for calculation\n *    this will be the checksum.\n */\nstatic inline uint16_t TCPV6Checksum(uint16_t *shdr, uint16_t *pkt,\n                                     uint16_t tlen, uint16_t init)\n{\n    uint16_t pad = 0;\n    uint32_t csum = init;\n\n    csum += shdr[0] + shdr[1] + shdr[2] + shdr[3] + shdr[4] + shdr[5] +\n        shdr[6] +  shdr[7] + shdr[8] + shdr[9] + shdr[10] + shdr[11] +\n        shdr[12] + shdr[13] + shdr[14] + shdr[15] + htons(6) + htons(tlen);\n\n    csum += pkt[0] + pkt[1] + pkt[2] + pkt[3] + pkt[4] + pkt[5] + pkt[6] +\n        pkt[7] + pkt[9];\n\n    tlen -= 20;\n    pkt += 10;\n\n    while (tlen >= 32) {\n        csum += pkt[0] + pkt[1] + pkt[2] + pkt[3] + pkt[4] + pkt[5] + pkt[6] +\n            pkt[7] + pkt[8] + pkt[9] + pkt[10] + pkt[11] + pkt[12] + pkt[13] +\n            pkt[14] + pkt[15];\n        tlen -= 32;\n        pkt += 16;\n    }\n\n    while(tlen >= 8) {\n        csum += pkt[0] + pkt[1] + pkt[2] + pkt[3];\n        tlen -= 8;\n        pkt += 4;\n    }\n\n    while(tlen >= 4) {\n        csum += pkt[0] + pkt[1];\n        tlen -= 4;\n        pkt += 2;\n    }\n\n    while (tlen > 1) {\n        csum += pkt[0];\n        pkt += 1;\n        tlen -= 2;\n    }\n\n    if (tlen == 1) {\n        *(uint8_t *)(&pad) = (*(uint8_t *)pkt);\n        csum += pad;\n    }\n\n    csum = (csum >> 16) + (csum & 0x0000FFFF);\n    csum += (csum >> 16);\n\n    return (uint16_t)~csum;\n}\n\n\n#endif /* __DECODE_TCP_H__ */\n\n", "/* Copyright (C) 2007-2021 Open Information Security Foundation\n *\n * You can copy, redistribute or modify this Program under the terms of\n * the GNU General Public License version 2 as published by the Free\n * Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * version 2 along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n */\n\n/**\n * \\file\n *\n * \\author Victor Julien <victor@inliniac.net>\n * \\author Gurvinder Singh <gurvindersinghdahiya@gmail.com>\n *\n * TCP stream tracking and reassembly engine.\n *\n * \\todo - 4WHS: what if after the 2nd SYN we turn out to be normal 3WHS anyway?\n */\n\n#include \"suricata-common.h\"\n#include \"suricata.h\"\n\n#include \"decode.h\"\n#include \"debug.h\"\n#include \"detect.h\"\n\n#include \"flow.h\"\n#include \"flow-util.h\"\n\n#include \"conf.h\"\n#include \"conf-yaml-loader.h\"\n\n#include \"threads.h\"\n#include \"threadvars.h\"\n#include \"tm-threads.h\"\n\n#include \"util-pool.h\"\n#include \"util-pool-thread.h\"\n#include \"util-checksum.h\"\n#include \"util-unittest.h\"\n#include \"util-print.h\"\n#include \"util-debug.h\"\n#include \"util-device.h\"\n\n#include \"stream-tcp-private.h\"\n#include \"stream-tcp-reassemble.h\"\n#include \"stream-tcp.h\"\n#include \"stream-tcp-inline.h\"\n#include \"stream-tcp-sack.h\"\n#include \"stream-tcp-util.h\"\n#include \"stream.h\"\n\n#include \"pkt-var.h\"\n#include \"host.h\"\n\n#include \"app-layer.h\"\n#include \"app-layer-parser.h\"\n#include \"app-layer-protos.h\"\n#include \"app-layer-htp-mem.h\"\n\n#include \"util-host-os-info.h\"\n#include \"util-privs.h\"\n#include \"util-profiling.h\"\n#include \"util-misc.h\"\n#include \"util-validate.h\"\n#include \"util-runmodes.h\"\n#include \"util-random.h\"\n\n#include \"source-pcap-file.h\"\n\n//#define DEBUG\n\n#define STREAMTCP_DEFAULT_PREALLOC              2048\n#define STREAMTCP_DEFAULT_MEMCAP                (64 * 1024 * 1024)  /* 64mb */\n#define STREAMTCP_DEFAULT_REASSEMBLY_MEMCAP     (256 * 1024 * 1024) /* 256mb */\n#define STREAMTCP_DEFAULT_TOSERVER_CHUNK_SIZE   2560\n#define STREAMTCP_DEFAULT_TOCLIENT_CHUNK_SIZE   2560\n#define STREAMTCP_DEFAULT_MAX_SYNACK_QUEUED     5\n\n#define STREAMTCP_NEW_TIMEOUT                   60\n#define STREAMTCP_EST_TIMEOUT                   3600\n#define STREAMTCP_CLOSED_TIMEOUT                120\n\n#define STREAMTCP_EMERG_NEW_TIMEOUT             10\n#define STREAMTCP_EMERG_EST_TIMEOUT             300\n#define STREAMTCP_EMERG_CLOSED_TIMEOUT          20\n\nstatic int StreamTcpHandleFin(ThreadVars *tv, StreamTcpThread *, TcpSession *, Packet *, PacketQueueNoLock *);\nvoid StreamTcpReturnStreamSegments (TcpStream *);\nvoid StreamTcpInitConfig(bool);\nint StreamTcpGetFlowState(void *);\nvoid StreamTcpSetOSPolicy(TcpStream*, Packet*);\n\nstatic int StreamTcpValidateTimestamp(TcpSession * , Packet *);\nstatic int StreamTcpHandleTimestamp(TcpSession * , Packet *);\nstatic int StreamTcpValidateRst(TcpSession * , Packet *);\nstatic inline int StreamTcpValidateAck(TcpSession *ssn, TcpStream *, Packet *);\nstatic int StreamTcpStateDispatch(ThreadVars *tv, Packet *p,\n        StreamTcpThread *stt, TcpSession *ssn, PacketQueueNoLock *pq,\n        uint8_t state);\n\nextern int g_detect_disabled;\n\nstatic PoolThread *ssn_pool = NULL;\nstatic SCMutex ssn_pool_mutex = SCMUTEX_INITIALIZER; /**< init only, protect initializing and growing pool */\n#ifdef DEBUG\nstatic uint64_t ssn_pool_cnt = 0; /** counts ssns, protected by ssn_pool_mutex */\n#endif\n\nTcpStreamCnf stream_config;\nuint64_t StreamTcpReassembleMemuseGlobalCounter(void);\nSC_ATOMIC_DECLARE(uint64_t, st_memuse);\n\nvoid StreamTcpInitMemuse(void)\n{\n    SC_ATOMIC_INIT(st_memuse);\n}\n\nvoid StreamTcpIncrMemuse(uint64_t size)\n{\n    (void) SC_ATOMIC_ADD(st_memuse, size);\n    SCLogDebug(\"STREAM %\"PRIu64\", incr %\"PRIu64, StreamTcpMemuseCounter(), size);\n    return;\n}\n\nvoid StreamTcpDecrMemuse(uint64_t size)\n{\n#ifdef DEBUG_VALIDATION\n    uint64_t presize = SC_ATOMIC_GET(st_memuse);\n    if (RunmodeIsUnittests()) {\n        BUG_ON(presize > UINT_MAX);\n    }\n#endif\n\n    (void) SC_ATOMIC_SUB(st_memuse, size);\n\n#ifdef DEBUG_VALIDATION\n    if (RunmodeIsUnittests()) {\n        uint64_t postsize = SC_ATOMIC_GET(st_memuse);\n        BUG_ON(postsize > presize);\n    }\n#endif\n    SCLogDebug(\"STREAM %\"PRIu64\", decr %\"PRIu64, StreamTcpMemuseCounter(), size);\n    return;\n}\n\nuint64_t StreamTcpMemuseCounter(void)\n{\n    uint64_t memusecopy = SC_ATOMIC_GET(st_memuse);\n    return memusecopy;\n}\n\n/**\n *  \\brief Check if alloc'ing \"size\" would mean we're over memcap\n *\n *  \\retval 1 if in bounds\n *  \\retval 0 if not in bounds\n */\nint StreamTcpCheckMemcap(uint64_t size)\n{\n    uint64_t memcapcopy = SC_ATOMIC_GET(stream_config.memcap);\n    if (memcapcopy == 0 || size + SC_ATOMIC_GET(st_memuse) <= memcapcopy)\n        return 1;\n    return 0;\n}\n\n/**\n *  \\brief Update memcap value\n *\n *  \\param size new memcap value\n */\nint StreamTcpSetMemcap(uint64_t size)\n{\n    if (size == 0 || (uint64_t)SC_ATOMIC_GET(st_memuse) < size) {\n        SC_ATOMIC_SET(stream_config.memcap, size);\n        return 1;\n    }\n\n    return 0;\n}\n\n/**\n *  \\brief Return memcap value\n *\n *  \\param memcap memcap value\n */\nuint64_t StreamTcpGetMemcap(void)\n{\n    uint64_t memcapcopy = SC_ATOMIC_GET(stream_config.memcap);\n    return memcapcopy;\n}\n\nvoid StreamTcpStreamCleanup(TcpStream *stream)\n{\n    if (stream != NULL) {\n        StreamTcpSackFreeList(stream);\n        StreamTcpReturnStreamSegments(stream);\n        StreamingBufferClear(&stream->sb);\n    }\n}\n\n/**\n *  \\brief Session cleanup function. Does not free the ssn.\n *  \\param ssn tcp session\n */\nvoid StreamTcpSessionCleanup(TcpSession *ssn)\n{\n    SCEnter();\n    TcpStateQueue *q, *q_next;\n\n    if (ssn == NULL)\n        return;\n\n    StreamTcpStreamCleanup(&ssn->client);\n    StreamTcpStreamCleanup(&ssn->server);\n\n    q = ssn->queue;\n    while (q != NULL) {\n        q_next = q->next;\n        SCFree(q);\n        q = q_next;\n        StreamTcpDecrMemuse((uint64_t)sizeof(TcpStateQueue));\n    }\n    ssn->queue = NULL;\n    ssn->queue_len = 0;\n\n    SCReturn;\n}\n\n/**\n *  \\brief Function to return the stream back to the pool. It returns the\n *         segments in the stream to the segment pool.\n *\n *  This function is called when the flow is destroyed, so it should free\n *  *everything* related to the tcp session. So including the app layer\n *  data. We are guaranteed to only get here when the flow's use_cnt is 0.\n *\n *  \\param ssn Void ptr to the ssn.\n */\nvoid StreamTcpSessionClear(void *ssnptr)\n{\n    SCEnter();\n    TcpSession *ssn = (TcpSession *)ssnptr;\n    if (ssn == NULL)\n        return;\n\n    StreamTcpSessionCleanup(ssn);\n\n    /* HACK: don't loose track of thread id */\n    PoolThreadReserved a = ssn->res;\n    memset(ssn, 0, sizeof(TcpSession));\n    ssn->res = a;\n\n    PoolThreadReturn(ssn_pool, ssn);\n#ifdef DEBUG\n    SCMutexLock(&ssn_pool_mutex);\n    ssn_pool_cnt--;\n    SCMutexUnlock(&ssn_pool_mutex);\n#endif\n\n    SCReturn;\n}\n\n/**\n *  \\brief Function to return the stream segments back to the pool.\n *\n *  We don't clear out the app layer storage here as that is under protection\n *  of the \"use_cnt\" reference counter in the flow. This function is called\n *  when the use_cnt is always at least 1 (this pkt has incremented the flow\n *  use_cnt itself), so we don't bother.\n *\n *  \\param p Packet used to identify the stream.\n */\nvoid StreamTcpSessionPktFree (Packet *p)\n{\n    SCEnter();\n\n    TcpSession *ssn = (TcpSession *)p->flow->protoctx;\n    if (ssn == NULL)\n        SCReturn;\n\n    StreamTcpReturnStreamSegments(&ssn->client);\n    StreamTcpReturnStreamSegments(&ssn->server);\n\n    SCReturn;\n}\n\n/** \\brief Stream alloc function for the Pool\n *  \\retval ptr void ptr to TcpSession structure with all vars set to 0/NULL\n */\nstatic void *StreamTcpSessionPoolAlloc(void)\n{\n    void *ptr = NULL;\n\n    if (StreamTcpCheckMemcap((uint32_t)sizeof(TcpSession)) == 0)\n        return NULL;\n\n    ptr = SCMalloc(sizeof(TcpSession));\n    if (unlikely(ptr == NULL))\n        return NULL;\n\n    return ptr;\n}\n\nstatic int StreamTcpSessionPoolInit(void *data, void* initdata)\n{\n    memset(data, 0, sizeof(TcpSession));\n    StreamTcpIncrMemuse((uint64_t)sizeof(TcpSession));\n\n    return 1;\n}\n\n/** \\brief Pool cleanup function\n *  \\param s Void ptr to TcpSession memory */\nstatic void StreamTcpSessionPoolCleanup(void *s)\n{\n    if (s != NULL) {\n        StreamTcpSessionCleanup(s);\n        /** \\todo not very clean, as the memory is not freed here */\n        StreamTcpDecrMemuse((uint64_t)sizeof(TcpSession));\n    }\n}\n\n/**\n *  \\brief See if stream engine is dropping invalid packet in inline mode\n *\n *  \\retval 0 no\n *  \\retval 1 yes\n */\nint StreamTcpInlineDropInvalid(void)\n{\n    return ((stream_config.flags & STREAMTCP_INIT_FLAG_INLINE)\n            && (stream_config.flags & STREAMTCP_INIT_FLAG_DROP_INVALID));\n}\n\n/* hack: stream random range code expects random values in range of 0-RAND_MAX,\n * but we can get both <0 and >RAND_MAX values from RandomGet\n */\nstatic int RandomGetWrap(void)\n{\n    unsigned long r;\n\n    do {\n        r = RandomGet();\n    } while(r >= ULONG_MAX - (ULONG_MAX % RAND_MAX));\n\n    return r % RAND_MAX;\n}\n\n/** \\brief          To initialize the stream global configuration data\n *\n *  \\param  quiet   It tells the mode of operation, if it is true nothing will\n *                  be get printed.\n */\n\nvoid StreamTcpInitConfig(bool quiet)\n{\n    intmax_t value = 0;\n    uint16_t rdrange = 10;\n\n    SCLogDebug(\"Initializing Stream\");\n\n    memset(&stream_config,  0, sizeof(stream_config));\n\n    SC_ATOMIC_INIT(stream_config.memcap);\n    SC_ATOMIC_INIT(stream_config.reassembly_memcap);\n\n    if ((ConfGetInt(\"stream.max-sessions\", &value)) == 1) {\n        SCLogWarning(SC_WARN_OPTION_OBSOLETE, \"max-sessions is obsolete. \"\n            \"Number of concurrent sessions is now only limited by Flow and \"\n            \"TCP stream engine memcaps.\");\n    }\n\n    if ((ConfGetInt(\"stream.prealloc-sessions\", &value)) == 1) {\n        stream_config.prealloc_sessions = (uint32_t)value;\n    } else {\n        if (RunmodeIsUnittests()) {\n            stream_config.prealloc_sessions = 128;\n        } else {\n            stream_config.prealloc_sessions = STREAMTCP_DEFAULT_PREALLOC;\n            if (ConfGetNode(\"stream.prealloc-sessions\") != NULL) {\n                WarnInvalidConfEntry(\"stream.prealloc_sessions\",\n                                     \"%\"PRIu32,\n                                     stream_config.prealloc_sessions);\n            }\n        }\n    }\n    if (!quiet) {\n        SCLogConfig(\"stream \\\"prealloc-sessions\\\": %\"PRIu32\" (per thread)\",\n                stream_config.prealloc_sessions);\n    }\n\n    const char *temp_stream_memcap_str;\n    if (ConfGetValue(\"stream.memcap\", &temp_stream_memcap_str) == 1) {\n        uint64_t stream_memcap_copy;\n        if (ParseSizeStringU64(temp_stream_memcap_str, &stream_memcap_copy) < 0) {\n            SCLogError(SC_ERR_SIZE_PARSE, \"Error parsing stream.memcap \"\n                       \"from conf file - %s.  Killing engine\",\n                       temp_stream_memcap_str);\n            exit(EXIT_FAILURE);\n        } else {\n            SC_ATOMIC_SET(stream_config.memcap, stream_memcap_copy);\n        }\n    } else {\n        SC_ATOMIC_SET(stream_config.memcap, STREAMTCP_DEFAULT_MEMCAP);\n    }\n\n    if (!quiet) {\n        SCLogConfig(\"stream \\\"memcap\\\": %\"PRIu64, SC_ATOMIC_GET(stream_config.memcap));\n    }\n\n    int imidstream;\n    (void)ConfGetBool(\"stream.midstream\", &imidstream);\n    stream_config.midstream = imidstream != 0;\n\n    if (!quiet) {\n        SCLogConfig(\"stream \\\"midstream\\\" session pickups: %s\", stream_config.midstream ? \"enabled\" : \"disabled\");\n    }\n\n    (void)ConfGetBool(\"stream.async-oneside\", &stream_config.async_oneside);\n\n    if (!quiet) {\n        SCLogConfig(\"stream \\\"async-oneside\\\": %s\", stream_config.async_oneside ? \"enabled\" : \"disabled\");\n    }\n\n    int csum = 0;\n\n    if ((ConfGetBool(\"stream.checksum-validation\", &csum)) == 1) {\n        if (csum == 1) {\n            stream_config.flags |= STREAMTCP_INIT_FLAG_CHECKSUM_VALIDATION;\n        }\n    /* Default is that we validate the checksum of all the packets */\n    } else {\n        stream_config.flags |= STREAMTCP_INIT_FLAG_CHECKSUM_VALIDATION;\n    }\n\n    if (!quiet) {\n        SCLogConfig(\"stream \\\"checksum-validation\\\": %s\",\n                stream_config.flags & STREAMTCP_INIT_FLAG_CHECKSUM_VALIDATION ?\n                \"enabled\" : \"disabled\");\n    }\n\n    const char *temp_stream_inline_str;\n    if (ConfGetValue(\"stream.inline\", &temp_stream_inline_str) == 1) {\n        int inl = 0;\n\n        /* checking for \"auto\" and falling back to boolean to provide\n         * backward compatibility */\n        if (strcmp(temp_stream_inline_str, \"auto\") == 0) {\n            if (EngineModeIsIPS()) {\n                stream_config.flags |= STREAMTCP_INIT_FLAG_INLINE;\n            }\n        } else if (ConfGetBool(\"stream.inline\", &inl) == 1) {\n            if (inl) {\n                stream_config.flags |= STREAMTCP_INIT_FLAG_INLINE;\n            }\n        }\n    } else {\n        /* default to 'auto' */\n        if (EngineModeIsIPS()) {\n            stream_config.flags |= STREAMTCP_INIT_FLAG_INLINE;\n        }\n    }\n\n    if (!quiet) {\n        SCLogConfig(\"stream.\\\"inline\\\": %s\",\n                    stream_config.flags & STREAMTCP_INIT_FLAG_INLINE\n                    ? \"enabled\" : \"disabled\");\n    }\n\n    int bypass = 0;\n    if ((ConfGetBool(\"stream.bypass\", &bypass)) == 1) {\n        if (bypass == 1) {\n            stream_config.flags |= STREAMTCP_INIT_FLAG_BYPASS;\n        }\n    }\n\n    if (!quiet) {\n        SCLogConfig(\"stream \\\"bypass\\\": %s\",\n                    (stream_config.flags & STREAMTCP_INIT_FLAG_BYPASS)\n                    ? \"enabled\" : \"disabled\");\n    }\n\n    int drop_invalid = 0;\n    if ((ConfGetBool(\"stream.drop-invalid\", &drop_invalid)) == 1) {\n        if (drop_invalid == 1) {\n            stream_config.flags |= STREAMTCP_INIT_FLAG_DROP_INVALID;\n        }\n    } else {\n        stream_config.flags |= STREAMTCP_INIT_FLAG_DROP_INVALID;\n    }\n\n    if ((ConfGetInt(\"stream.max-synack-queued\", &value)) == 1) {\n        if (value >= 0 && value <= 255) {\n            stream_config.max_synack_queued = (uint8_t)value;\n        } else {\n            stream_config.max_synack_queued = (uint8_t)STREAMTCP_DEFAULT_MAX_SYNACK_QUEUED;\n        }\n    } else {\n        stream_config.max_synack_queued = (uint8_t)STREAMTCP_DEFAULT_MAX_SYNACK_QUEUED;\n    }\n    if (!quiet) {\n        SCLogConfig(\"stream \\\"max-synack-queued\\\": %\"PRIu8, stream_config.max_synack_queued);\n    }\n\n    const char *temp_stream_reassembly_memcap_str;\n    if (ConfGetValue(\"stream.reassembly.memcap\", &temp_stream_reassembly_memcap_str) == 1) {\n        uint64_t stream_reassembly_memcap_copy;\n        if (ParseSizeStringU64(temp_stream_reassembly_memcap_str,\n                               &stream_reassembly_memcap_copy) < 0) {\n            SCLogError(SC_ERR_SIZE_PARSE, \"Error parsing \"\n                       \"stream.reassembly.memcap \"\n                       \"from conf file - %s.  Killing engine\",\n                       temp_stream_reassembly_memcap_str);\n            exit(EXIT_FAILURE);\n        } else {\n            SC_ATOMIC_SET(stream_config.reassembly_memcap, stream_reassembly_memcap_copy);\n        }\n    } else {\n        SC_ATOMIC_SET(stream_config.reassembly_memcap , STREAMTCP_DEFAULT_REASSEMBLY_MEMCAP);\n    }\n\n    if (!quiet) {\n        SCLogConfig(\"stream.reassembly \\\"memcap\\\": %\"PRIu64\"\",\n                    SC_ATOMIC_GET(stream_config.reassembly_memcap));\n    }\n\n    const char *temp_stream_reassembly_depth_str;\n    if (ConfGetValue(\"stream.reassembly.depth\", &temp_stream_reassembly_depth_str) == 1) {\n        if (ParseSizeStringU32(temp_stream_reassembly_depth_str,\n                               &stream_config.reassembly_depth) < 0) {\n            SCLogError(SC_ERR_SIZE_PARSE, \"Error parsing \"\n                       \"stream.reassembly.depth \"\n                       \"from conf file - %s.  Killing engine\",\n                       temp_stream_reassembly_depth_str);\n            exit(EXIT_FAILURE);\n        }\n    } else {\n        stream_config.reassembly_depth = 0;\n    }\n\n    if (!quiet) {\n        SCLogConfig(\"stream.reassembly \\\"depth\\\": %\"PRIu32\"\", stream_config.reassembly_depth);\n    }\n\n    int randomize = 0;\n    if ((ConfGetBool(\"stream.reassembly.randomize-chunk-size\", &randomize)) == 0) {\n        /* randomize by default if value not set\n         * In ut mode we disable, to get predictable test results */\n        if (!(RunmodeIsUnittests()))\n            randomize = 1;\n    }\n\n    if (randomize) {\n        const char *temp_rdrange;\n        if (ConfGetValue(\"stream.reassembly.randomize-chunk-range\",\n                    &temp_rdrange) == 1) {\n            if (ParseSizeStringU16(temp_rdrange, &rdrange) < 0) {\n                SCLogError(SC_ERR_SIZE_PARSE, \"Error parsing \"\n                        \"stream.reassembly.randomize-chunk-range \"\n                        \"from conf file - %s.  Killing engine\",\n                        temp_rdrange);\n                exit(EXIT_FAILURE);\n            } else if (rdrange >= 100) {\n                           FatalError(SC_ERR_FATAL,\n                                      \"stream.reassembly.randomize-chunk-range \"\n                                      \"must be lower than 100\");\n            }\n        }\n    }\n\n    const char *temp_stream_reassembly_toserver_chunk_size_str;\n    if (ConfGetValue(\"stream.reassembly.toserver-chunk-size\",\n                &temp_stream_reassembly_toserver_chunk_size_str) == 1) {\n        if (ParseSizeStringU16(temp_stream_reassembly_toserver_chunk_size_str,\n                               &stream_config.reassembly_toserver_chunk_size) < 0) {\n            SCLogError(SC_ERR_SIZE_PARSE, \"Error parsing \"\n                       \"stream.reassembly.toserver-chunk-size \"\n                       \"from conf file - %s.  Killing engine\",\n                       temp_stream_reassembly_toserver_chunk_size_str);\n            exit(EXIT_FAILURE);\n        }\n    } else {\n        stream_config.reassembly_toserver_chunk_size =\n            STREAMTCP_DEFAULT_TOSERVER_CHUNK_SIZE;\n    }\n\n    if (randomize) {\n        long int r = RandomGetWrap();\n        stream_config.reassembly_toserver_chunk_size +=\n            (int) (stream_config.reassembly_toserver_chunk_size *\n                   (r * 1.0 / RAND_MAX - 0.5) * rdrange / 100);\n    }\n    const char *temp_stream_reassembly_toclient_chunk_size_str;\n    if (ConfGetValue(\"stream.reassembly.toclient-chunk-size\",\n                &temp_stream_reassembly_toclient_chunk_size_str) == 1) {\n        if (ParseSizeStringU16(temp_stream_reassembly_toclient_chunk_size_str,\n                               &stream_config.reassembly_toclient_chunk_size) < 0) {\n            SCLogError(SC_ERR_SIZE_PARSE, \"Error parsing \"\n                       \"stream.reassembly.toclient-chunk-size \"\n                       \"from conf file - %s.  Killing engine\",\n                       temp_stream_reassembly_toclient_chunk_size_str);\n            exit(EXIT_FAILURE);\n        }\n    } else {\n        stream_config.reassembly_toclient_chunk_size =\n            STREAMTCP_DEFAULT_TOCLIENT_CHUNK_SIZE;\n    }\n\n    if (randomize) {\n        long int r = RandomGetWrap();\n        stream_config.reassembly_toclient_chunk_size +=\n            (int) (stream_config.reassembly_toclient_chunk_size *\n                   (r * 1.0 / RAND_MAX - 0.5) * rdrange / 100);\n    }\n    if (!quiet) {\n        SCLogConfig(\"stream.reassembly \\\"toserver-chunk-size\\\": %\"PRIu16,\n            stream_config.reassembly_toserver_chunk_size);\n        SCLogConfig(\"stream.reassembly \\\"toclient-chunk-size\\\": %\"PRIu16,\n            stream_config.reassembly_toclient_chunk_size);\n    }\n\n    int enable_raw = 1;\n    if (ConfGetBool(\"stream.reassembly.raw\", &enable_raw) == 1) {\n        if (!enable_raw) {\n            stream_config.stream_init_flags = STREAMTCP_STREAM_FLAG_DISABLE_RAW;\n        }\n    } else {\n        enable_raw = 1;\n    }\n    if (!quiet)\n        SCLogConfig(\"stream.reassembly.raw: %s\", enable_raw ? \"enabled\" : \"disabled\");\n\n    /* init the memcap/use tracking */\n    StreamTcpInitMemuse();\n    StatsRegisterGlobalCounter(\"tcp.memuse\", StreamTcpMemuseCounter);\n\n    StreamTcpReassembleInit(quiet);\n\n    /* set the default free function and flow state function\n     * values. */\n    FlowSetProtoFreeFunc(IPPROTO_TCP, StreamTcpSessionClear);\n\n#ifdef UNITTESTS\n    if (RunmodeIsUnittests()) {\n        SCMutexLock(&ssn_pool_mutex);\n        if (ssn_pool == NULL) {\n            ssn_pool = PoolThreadInit(1, /* thread */\n                    0, /* unlimited */\n                    stream_config.prealloc_sessions,\n                    sizeof(TcpSession),\n                    StreamTcpSessionPoolAlloc,\n                    StreamTcpSessionPoolInit, NULL,\n                    StreamTcpSessionPoolCleanup, NULL);\n        }\n        SCMutexUnlock(&ssn_pool_mutex);\n    }\n#endif\n}\n\nvoid StreamTcpFreeConfig(bool quiet)\n{\n    StreamTcpReassembleFree(quiet);\n\n    SCMutexLock(&ssn_pool_mutex);\n    if (ssn_pool != NULL) {\n        PoolThreadFree(ssn_pool);\n        ssn_pool = NULL;\n    }\n    SCMutexUnlock(&ssn_pool_mutex);\n    SCMutexDestroy(&ssn_pool_mutex);\n\n    SCLogDebug(\"ssn_pool_cnt %\"PRIu64\"\", ssn_pool_cnt);\n}\n\n/** \\internal\n *  \\brief The function is used to to fetch a TCP session from the\n *         ssn_pool, when a TCP SYN is received.\n *\n *  \\param p packet starting the new TCP session.\n *  \\param id thread pool id\n *\n *  \\retval ssn new TCP session.\n */\nstatic TcpSession *StreamTcpNewSession (Packet *p, int id)\n{\n    TcpSession *ssn = (TcpSession *)p->flow->protoctx;\n\n    if (ssn == NULL) {\n        p->flow->protoctx = PoolThreadGetById(ssn_pool, id);\n#ifdef DEBUG\n        SCMutexLock(&ssn_pool_mutex);\n        if (p->flow->protoctx != NULL)\n            ssn_pool_cnt++;\n        SCMutexUnlock(&ssn_pool_mutex);\n#endif\n\n        ssn = (TcpSession *)p->flow->protoctx;\n        if (ssn == NULL) {\n            SCLogDebug(\"ssn_pool is empty\");\n            return NULL;\n        }\n\n        ssn->state = TCP_NONE;\n        ssn->reassembly_depth = stream_config.reassembly_depth;\n        ssn->tcp_packet_flags = p->tcph ? p->tcph->th_flags : 0;\n        ssn->server.flags = stream_config.stream_init_flags;\n        ssn->client.flags = stream_config.stream_init_flags;\n\n        StreamingBuffer x = STREAMING_BUFFER_INITIALIZER(&stream_config.sbcnf);\n        ssn->client.sb = x;\n        ssn->server.sb = x;\n\n        if (PKT_IS_TOSERVER(p)) {\n            ssn->client.tcp_flags = p->tcph ? p->tcph->th_flags : 0;\n            ssn->server.tcp_flags = 0;\n        } else if (PKT_IS_TOCLIENT(p)) {\n            ssn->server.tcp_flags = p->tcph ? p->tcph->th_flags : 0;\n            ssn->client.tcp_flags = 0;\n        }\n    }\n\n    return ssn;\n}\n\nstatic void StreamTcpPacketSetState(Packet *p, TcpSession *ssn,\n                                           uint8_t state)\n{\n    if (state == ssn->state || PKT_IS_PSEUDOPKT(p))\n        return;\n\n    ssn->pstate = ssn->state;\n    ssn->state = state;\n\n    /* update the flow state */\n    switch(ssn->state) {\n        case TCP_ESTABLISHED:\n        case TCP_FIN_WAIT1:\n        case TCP_FIN_WAIT2:\n        case TCP_CLOSING:\n        case TCP_CLOSE_WAIT:\n            FlowUpdateState(p->flow, FLOW_STATE_ESTABLISHED);\n            break;\n        case TCP_LAST_ACK:\n        case TCP_TIME_WAIT:\n        case TCP_CLOSED:\n            FlowUpdateState(p->flow, FLOW_STATE_CLOSED);\n            break;\n    }\n}\n\n/**\n *  \\brief  Function to set the OS policy for the given stream based on the\n *          destination of the received packet.\n *\n *  \\param  stream  TcpStream of which os_policy needs to set\n *  \\param  p       Packet which is used to set the os policy\n */\nvoid StreamTcpSetOSPolicy(TcpStream *stream, Packet *p)\n{\n    int ret = 0;\n\n    if (PKT_IS_IPV4(p)) {\n        /* Get the OS policy based on destination IP address, as destination\n           OS will decide how to react on the anomalies of newly received\n           packets */\n        ret = SCHInfoGetIPv4HostOSFlavour((uint8_t *)GET_IPV4_DST_ADDR_PTR(p));\n        if (ret > 0)\n            stream->os_policy = ret;\n        else\n            stream->os_policy = OS_POLICY_DEFAULT;\n\n    } else if (PKT_IS_IPV6(p)) {\n        /* Get the OS policy based on destination IP address, as destination\n           OS will decide how to react on the anomalies of newly received\n           packets */\n        ret = SCHInfoGetIPv6HostOSFlavour((uint8_t *)GET_IPV6_DST_ADDR(p));\n        if (ret > 0)\n            stream->os_policy = ret;\n        else\n            stream->os_policy = OS_POLICY_DEFAULT;\n    }\n\n    if (stream->os_policy == OS_POLICY_BSD_RIGHT)\n        stream->os_policy = OS_POLICY_BSD;\n    else if (stream->os_policy == OS_POLICY_OLD_SOLARIS)\n        stream->os_policy = OS_POLICY_SOLARIS;\n\n    SCLogDebug(\"Policy is %\"PRIu8\"\", stream->os_policy);\n\n}\n\n/**\n *  \\brief macro to update last_ack only if the new value is higher\n *\n *  \\param ssn session\n *  \\param stream stream to update\n *  \\param ack ACK value to test and set\n */\n#define StreamTcpUpdateLastAck(ssn, stream, ack) { \\\n    if (SEQ_GT((ack), (stream)->last_ack)) \\\n    { \\\n        SCLogDebug(\"ssn %p: last_ack set to %\"PRIu32\", moved %u forward\", (ssn), (ack), (ack) - (stream)->last_ack); \\\n        if ((SEQ_LEQ((stream)->last_ack, (stream)->next_seq) && SEQ_GT((ack),(stream)->next_seq))) { \\\n            SCLogDebug(\"last_ack just passed next_seq: %u (was %u) > %u\", (ack), (stream)->last_ack, (stream)->next_seq); \\\n        } else { \\\n            SCLogDebug(\"next_seq (%u) <> last_ack now %d\", (stream)->next_seq, (int)(stream)->next_seq - (ack)); \\\n        }\\\n        (stream)->last_ack = (ack); \\\n        StreamTcpSackPruneList((stream)); \\\n    } else { \\\n        SCLogDebug(\"ssn %p: no update: ack %u, last_ack %\"PRIu32\", next_seq %u (state %u)\", \\\n                    (ssn), (ack), (stream)->last_ack, (stream)->next_seq, (ssn)->state); \\\n    }\\\n}\n\n#define StreamTcpAsyncLastAckUpdate(ssn, stream) {                              \\\n    if ((ssn)->flags & STREAMTCP_FLAG_ASYNC) {                                  \\\n        if (SEQ_GT((stream)->next_seq, (stream)->last_ack)) {                   \\\n            uint32_t ack_diff = (stream)->next_seq - (stream)->last_ack;        \\\n            (stream)->last_ack += ack_diff;                                     \\\n            SCLogDebug(\"ssn %p: ASYNC last_ack set to %\"PRIu32\", moved %u forward\",     \\\n                    (ssn), (stream)->next_seq, ack_diff);                               \\\n        }                                                                       \\\n    }                                                                           \\\n}\n\n#define StreamTcpUpdateNextSeq(ssn, stream, seq) {                      \\\n    (stream)->next_seq = seq;                                           \\\n    SCLogDebug(\"ssn %p: next_seq %\" PRIu32, (ssn), (stream)->next_seq); \\\n    StreamTcpAsyncLastAckUpdate((ssn), (stream));                       \\\n}\n\n/**\n *  \\brief macro to update next_win only if the new value is higher\n *\n *  \\param ssn session\n *  \\param stream stream to update\n *  \\param win window value to test and set\n */\n#define StreamTcpUpdateNextWin(ssn, stream, win) { \\\n    uint32_t sacked_size__ = StreamTcpSackedSize((stream)); \\\n    if (SEQ_GT(((win) + sacked_size__), (stream)->next_win)) { \\\n        (stream)->next_win = ((win) + sacked_size__); \\\n        SCLogDebug(\"ssn %p: next_win set to %\"PRIu32, (ssn), (stream)->next_win); \\\n    } \\\n}\n\nstatic inline void StreamTcpCloseSsnWithReset(Packet *p, TcpSession *ssn)\n{\n    ssn->flags |= STREAMTCP_FLAG_CLOSED_BY_RST;\n    StreamTcpPacketSetState(p, ssn, TCP_CLOSED);\n    SCLogDebug(\"ssn %p: (state: %s) Reset received and state changed to \"\n            \"TCP_CLOSED\", ssn, StreamTcpStateAsString(ssn->state));\n}\n\nstatic int StreamTcpPacketIsRetransmission(TcpStream *stream, Packet *p)\n{\n    if (p->payload_len == 0)\n        SCReturnInt(0);\n\n    /* retransmission of already partially ack'd data */\n    if (SEQ_LT(TCP_GET_SEQ(p), stream->last_ack) && SEQ_GT((TCP_GET_SEQ(p) + p->payload_len), stream->last_ack))\n    {\n        StreamTcpSetEvent(p, STREAM_PKT_RETRANSMISSION);\n        SCReturnInt(1);\n    }\n\n    /* retransmission of already ack'd data */\n    if (SEQ_LEQ((TCP_GET_SEQ(p) + p->payload_len), stream->last_ack)) {\n        StreamTcpSetEvent(p, STREAM_PKT_RETRANSMISSION);\n        SCReturnInt(1);\n    }\n\n    /* retransmission of in flight data */\n    if (SEQ_LEQ((TCP_GET_SEQ(p) + p->payload_len), stream->next_seq)) {\n        StreamTcpSetEvent(p, STREAM_PKT_RETRANSMISSION);\n        SCReturnInt(2);\n    }\n\n    SCLogDebug(\"seq %u payload_len %u => %u, last_ack %u, next_seq %u\", TCP_GET_SEQ(p),\n            p->payload_len, (TCP_GET_SEQ(p) + p->payload_len), stream->last_ack, stream->next_seq);\n    SCReturnInt(0);\n}\n\n/**\n *  \\internal\n *  \\brief  Function to handle the TCP_CLOSED or NONE state. The function handles\n *          packets while the session state is None which means a newly\n *          initialized structure, or a fully closed session.\n *\n *  \\param  tv      Thread Variable containing  input/output queue, cpu affinity\n *  \\param  p       Packet which has to be handled in this TCP state.\n *  \\param  stt     Strean Thread module registered to handle the stream handling\n *\n *  \\retval 0 ok\n *  \\retval -1 error\n */\nstatic int StreamTcpPacketStateNone(ThreadVars *tv, Packet *p,\n        StreamTcpThread *stt, TcpSession *ssn,\n        PacketQueueNoLock *pq)\n{\n    if (p->tcph->th_flags & TH_RST) {\n        StreamTcpSetEvent(p, STREAM_RST_BUT_NO_SESSION);\n        SCLogDebug(\"RST packet received, no session setup\");\n        return -1;\n\n    } else if (p->tcph->th_flags & TH_FIN) {\n        StreamTcpSetEvent(p, STREAM_FIN_BUT_NO_SESSION);\n        SCLogDebug(\"FIN packet received, no session setup\");\n        return -1;\n\n    /* SYN/ACK */\n    } else if ((p->tcph->th_flags & (TH_SYN|TH_ACK)) == (TH_SYN|TH_ACK)) {\n        if (!stream_config.midstream && stream_config.async_oneside == FALSE)\n            return 0;\n\n        if (ssn == NULL) {\n            ssn = StreamTcpNewSession(p, stt->ssn_pool_id);\n            if (ssn == NULL) {\n                StatsIncr(tv, stt->counter_tcp_ssn_memcap);\n                return -1;\n            }\n            StatsIncr(tv, stt->counter_tcp_sessions);\n            StatsIncr(tv, stt->counter_tcp_midstream_pickups);\n        }\n\n        /* reverse packet and flow */\n        SCLogDebug(\"reversing flow and packet\");\n        PacketSwap(p);\n        FlowSwap(p->flow);\n\n        /* set the state */\n        StreamTcpPacketSetState(p, ssn, TCP_SYN_RECV);\n        SCLogDebug(\"ssn %p: =~ midstream picked ssn state is now \"\n                \"TCP_SYN_RECV\", ssn);\n        ssn->flags |= STREAMTCP_FLAG_MIDSTREAM;\n        /* Flag used to change the direct in the later stage in the session */\n        ssn->flags |= STREAMTCP_FLAG_MIDSTREAM_SYNACK;\n        if (stream_config.async_oneside) {\n            SCLogDebug(\"ssn %p: =~ ASYNC\", ssn);\n            ssn->flags |= STREAMTCP_FLAG_ASYNC;\n        }\n\n        /* sequence number & window */\n        ssn->server.isn = TCP_GET_SEQ(p);\n        STREAMTCP_SET_RA_BASE_SEQ(&ssn->server, ssn->server.isn);\n        ssn->server.next_seq = ssn->server.isn + 1;\n        ssn->server.window = TCP_GET_WINDOW(p);\n        SCLogDebug(\"ssn %p: server window %u\", ssn, ssn->server.window);\n\n        ssn->client.isn = TCP_GET_ACK(p) - 1;\n        STREAMTCP_SET_RA_BASE_SEQ(&ssn->client, ssn->client.isn);\n        ssn->client.next_seq = ssn->client.isn + 1;\n\n        ssn->client.last_ack = TCP_GET_ACK(p);\n        ssn->server.last_ack = TCP_GET_SEQ(p);\n\n        ssn->server.next_win = ssn->server.last_ack + ssn->server.window;\n\n        /** If the client has a wscale option the server had it too,\n         *  so set the wscale for the server to max. Otherwise none\n         *  will have the wscale opt just like it should. */\n        if (TCP_HAS_WSCALE(p)) {\n            ssn->client.wscale = TCP_GET_WSCALE(p);\n            ssn->server.wscale = TCP_WSCALE_MAX;\n            SCLogDebug(\"ssn %p: wscale enabled. client %u server %u\",\n                    ssn, ssn->client.wscale, ssn->server.wscale);\n        }\n\n        SCLogDebug(\"ssn %p: ssn->client.isn %\"PRIu32\", ssn->client.next_seq\"\n                \" %\"PRIu32\", ssn->client.last_ack %\"PRIu32\"\", ssn,\n                ssn->client.isn, ssn->client.next_seq,\n                ssn->client.last_ack);\n        SCLogDebug(\"ssn %p: ssn->server.isn %\"PRIu32\", ssn->server.next_seq\"\n                \" %\"PRIu32\", ssn->server.last_ack %\"PRIu32\"\", ssn,\n                ssn->server.isn, ssn->server.next_seq,\n                ssn->server.last_ack);\n\n        /* Set the timestamp value for both streams, if packet has timestamp\n         * option enabled.*/\n        if (TCP_HAS_TS(p)) {\n            ssn->server.last_ts = TCP_GET_TSVAL(p);\n            ssn->client.last_ts = TCP_GET_TSECR(p);\n            SCLogDebug(\"ssn %p: ssn->server.last_ts %\" PRIu32\" \"\n                    \"ssn->client.last_ts %\" PRIu32\"\", ssn,\n                    ssn->server.last_ts, ssn->client.last_ts);\n\n            ssn->flags |= STREAMTCP_FLAG_TIMESTAMP;\n\n            ssn->server.last_pkt_ts = p->ts.tv_sec;\n            if (ssn->server.last_ts == 0)\n                ssn->server.flags |= STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n            if (ssn->client.last_ts == 0)\n                ssn->client.flags |= STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n\n        } else {\n            ssn->server.last_ts = 0;\n            ssn->client.last_ts = 0;\n        }\n\n        if (TCP_GET_SACKOK(p) == 1) {\n            ssn->flags |= STREAMTCP_FLAG_SACKOK;\n            SCLogDebug(\"ssn %p: SYN/ACK with SACK permitted, assuming \"\n                    \"SACK permitted for both sides\", ssn);\n        }\n        return 0;\n\n    } else if (p->tcph->th_flags & TH_SYN) {\n        if (ssn == NULL) {\n            ssn = StreamTcpNewSession(p, stt->ssn_pool_id);\n            if (ssn == NULL) {\n                StatsIncr(tv, stt->counter_tcp_ssn_memcap);\n                return -1;\n            }\n\n            StatsIncr(tv, stt->counter_tcp_sessions);\n        }\n\n        /* set the state */\n        StreamTcpPacketSetState(p, ssn, TCP_SYN_SENT);\n        SCLogDebug(\"ssn %p: =~ ssn state is now TCP_SYN_SENT\", ssn);\n\n        if (stream_config.async_oneside) {\n            SCLogDebug(\"ssn %p: =~ ASYNC\", ssn);\n            ssn->flags |= STREAMTCP_FLAG_ASYNC;\n        }\n\n        /* set the sequence numbers and window */\n        ssn->client.isn = TCP_GET_SEQ(p);\n        STREAMTCP_SET_RA_BASE_SEQ(&ssn->client, ssn->client.isn);\n        ssn->client.next_seq = ssn->client.isn + 1;\n\n        /* Set the stream timestamp value, if packet has timestamp option\n         * enabled. */\n        if (TCP_HAS_TS(p)) {\n            ssn->client.last_ts = TCP_GET_TSVAL(p);\n            SCLogDebug(\"ssn %p: %02x\", ssn, ssn->client.last_ts);\n\n            if (ssn->client.last_ts == 0)\n                ssn->client.flags |= STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n\n            ssn->client.last_pkt_ts = p->ts.tv_sec;\n            ssn->client.flags |= STREAMTCP_STREAM_FLAG_TIMESTAMP;\n        }\n\n        ssn->server.window = TCP_GET_WINDOW(p);\n        if (TCP_HAS_WSCALE(p)) {\n            ssn->flags |= STREAMTCP_FLAG_SERVER_WSCALE;\n            ssn->server.wscale = TCP_GET_WSCALE(p);\n        }\n\n        if (TCP_GET_SACKOK(p) == 1) {\n            ssn->flags |= STREAMTCP_FLAG_CLIENT_SACKOK;\n            SCLogDebug(\"ssn %p: SACK permitted on SYN packet\", ssn);\n        }\n\n        if (TCP_HAS_TFO(p)) {\n            ssn->flags |= STREAMTCP_FLAG_TCP_FAST_OPEN;\n            if (p->payload_len) {\n                StreamTcpUpdateNextSeq(ssn, &ssn->client, (ssn->client.next_seq + p->payload_len));\n                SCLogDebug(\"ssn: %p (TFO) [len: %d] isn %u base_seq %u next_seq %u payload len %u\",\n                        ssn, p->tcpvars.tfo.len, ssn->client.isn, ssn->client.base_seq, ssn->client.next_seq, p->payload_len);\n                StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn, &ssn->client, p, pq);\n            }\n        }\n\n        SCLogDebug(\"ssn %p: ssn->client.isn %\" PRIu32 \", \"\n                \"ssn->client.next_seq %\" PRIu32 \", ssn->client.last_ack \"\n                \"%\"PRIu32\"\", ssn, ssn->client.isn, ssn->client.next_seq,\n                ssn->client.last_ack);\n\n    } else if (p->tcph->th_flags & TH_ACK) {\n        if (!stream_config.midstream)\n            return 0;\n\n        if (ssn == NULL) {\n            ssn = StreamTcpNewSession(p, stt->ssn_pool_id);\n            if (ssn == NULL) {\n                StatsIncr(tv, stt->counter_tcp_ssn_memcap);\n                return -1;\n            }\n            StatsIncr(tv, stt->counter_tcp_sessions);\n            StatsIncr(tv, stt->counter_tcp_midstream_pickups);\n        }\n        /* set the state */\n        StreamTcpPacketSetState(p, ssn, TCP_ESTABLISHED);\n        SCLogDebug(\"ssn %p: =~ midstream picked ssn state is now \"\n                \"TCP_ESTABLISHED\", ssn);\n\n        ssn->flags = STREAMTCP_FLAG_MIDSTREAM;\n        ssn->flags |= STREAMTCP_FLAG_MIDSTREAM_ESTABLISHED;\n        if (stream_config.async_oneside) {\n            SCLogDebug(\"ssn %p: =~ ASYNC\", ssn);\n            ssn->flags |= STREAMTCP_FLAG_ASYNC;\n        }\n\n        /** window scaling for midstream pickups, we can't do much other\n         *  than assume that it's set to the max value: 14 */\n        ssn->client.wscale = TCP_WSCALE_MAX;\n        ssn->server.wscale = TCP_WSCALE_MAX;\n\n        /* set the sequence numbers and window */\n        ssn->client.isn = TCP_GET_SEQ(p) - 1;\n        STREAMTCP_SET_RA_BASE_SEQ(&ssn->client, ssn->client.isn);\n        ssn->client.next_seq = TCP_GET_SEQ(p) + p->payload_len;\n        ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n        ssn->client.last_ack = TCP_GET_SEQ(p);\n        ssn->client.next_win = ssn->client.last_ack + ssn->client.window;\n        SCLogDebug(\"ssn %p: ssn->client.isn %u, ssn->client.next_seq %u\",\n                ssn, ssn->client.isn, ssn->client.next_seq);\n\n        ssn->server.isn = TCP_GET_ACK(p) - 1;\n        STREAMTCP_SET_RA_BASE_SEQ(&ssn->server, ssn->server.isn);\n        ssn->server.next_seq = ssn->server.isn + 1;\n        ssn->server.last_ack = TCP_GET_ACK(p);\n        ssn->server.next_win = ssn->server.last_ack;\n\n        SCLogDebug(\"ssn %p: ssn->client.next_win %\"PRIu32\", \"\n                \"ssn->server.next_win %\"PRIu32\"\", ssn,\n                ssn->client.next_win, ssn->server.next_win);\n        SCLogDebug(\"ssn %p: ssn->client.last_ack %\"PRIu32\", \"\n                \"ssn->server.last_ack %\"PRIu32\"\", ssn,\n                ssn->client.last_ack, ssn->server.last_ack);\n\n        /* Set the timestamp value for both streams, if packet has timestamp\n         * option enabled.*/\n        if (TCP_HAS_TS(p)) {\n            ssn->client.last_ts = TCP_GET_TSVAL(p);\n            ssn->server.last_ts = TCP_GET_TSECR(p);\n            SCLogDebug(\"ssn %p: ssn->server.last_ts %\" PRIu32\" \"\n                    \"ssn->client.last_ts %\" PRIu32\"\", ssn,\n                    ssn->server.last_ts, ssn->client.last_ts);\n\n            ssn->flags |= STREAMTCP_FLAG_TIMESTAMP;\n\n            ssn->client.last_pkt_ts = p->ts.tv_sec;\n            if (ssn->server.last_ts == 0)\n                ssn->server.flags |= STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n            if (ssn->client.last_ts == 0)\n                ssn->client.flags |= STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n\n        } else {\n            ssn->server.last_ts = 0;\n            ssn->client.last_ts = 0;\n        }\n\n        StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn, &ssn->client, p, pq);\n\n        ssn->flags |= STREAMTCP_FLAG_SACKOK;\n        SCLogDebug(\"ssn %p: assuming SACK permitted for both sides\", ssn);\n\n    } else {\n        SCLogDebug(\"default case\");\n    }\n\n    return 0;\n}\n\n/** \\internal\n *  \\brief Setup TcpStateQueue based on SYN/ACK packet\n */\nstatic inline void StreamTcp3whsSynAckToStateQueue(Packet *p, TcpStateQueue *q)\n{\n    q->flags = 0;\n    q->wscale = 0;\n    q->ts = 0;\n    q->win = TCP_GET_WINDOW(p);\n    q->seq = TCP_GET_SEQ(p);\n    q->ack = TCP_GET_ACK(p);\n    q->pkt_ts = p->ts.tv_sec;\n\n    if (TCP_GET_SACKOK(p) == 1)\n        q->flags |= STREAMTCP_QUEUE_FLAG_SACK;\n\n    if (TCP_HAS_WSCALE(p)) {\n        q->flags |= STREAMTCP_QUEUE_FLAG_WS;\n        q->wscale = TCP_GET_WSCALE(p);\n    }\n    if (TCP_HAS_TS(p)) {\n        q->flags |= STREAMTCP_QUEUE_FLAG_TS;\n        q->ts = TCP_GET_TSVAL(p);\n    }\n}\n\n/** \\internal\n *  \\brief Find the Queued SYN/ACK that is the same as this SYN/ACK\n *  \\retval q or NULL */\nstatic TcpStateQueue *StreamTcp3whsFindSynAckBySynAck(TcpSession *ssn, Packet *p)\n{\n    TcpStateQueue *q = ssn->queue;\n    TcpStateQueue search;\n\n    StreamTcp3whsSynAckToStateQueue(p, &search);\n\n    while (q != NULL) {\n        if (search.flags == q->flags &&\n            search.wscale == q->wscale &&\n            search.win == q->win &&\n            search.seq == q->seq &&\n            search.ack == q->ack &&\n            search.ts == q->ts) {\n            return q;\n        }\n\n        q = q->next;\n    }\n\n    return q;\n}\n\nstatic int StreamTcp3whsQueueSynAck(TcpSession *ssn, Packet *p)\n{\n    /* first see if this is already in our list */\n    if (StreamTcp3whsFindSynAckBySynAck(ssn, p) != NULL)\n        return 0;\n\n    if (ssn->queue_len == stream_config.max_synack_queued) {\n        SCLogDebug(\"ssn %p: =~ SYN/ACK queue limit reached\", ssn);\n        StreamTcpSetEvent(p, STREAM_3WHS_SYNACK_FLOOD);\n        return -1;\n    }\n\n    if (StreamTcpCheckMemcap((uint32_t)sizeof(TcpStateQueue)) == 0) {\n        SCLogDebug(\"ssn %p: =~ SYN/ACK queue failed: stream memcap reached\", ssn);\n        return -1;\n    }\n\n    TcpStateQueue *q = SCMalloc(sizeof(*q));\n    if (unlikely(q == NULL)) {\n        SCLogDebug(\"ssn %p: =~ SYN/ACK queue failed: alloc failed\", ssn);\n        return -1;\n    }\n    memset(q, 0x00, sizeof(*q));\n    StreamTcpIncrMemuse((uint64_t)sizeof(TcpStateQueue));\n\n    StreamTcp3whsSynAckToStateQueue(p, q);\n\n    /* put in list */\n    q->next = ssn->queue;\n    ssn->queue = q;\n    ssn->queue_len++;\n    return 0;\n}\n\n/** \\internal\n *  \\brief Find the Queued SYN/ACK that goes with this ACK\n *  \\retval q or NULL */\nstatic TcpStateQueue *StreamTcp3whsFindSynAckByAck(TcpSession *ssn, Packet *p)\n{\n    uint32_t ack = TCP_GET_SEQ(p);\n    uint32_t seq = TCP_GET_ACK(p) - 1;\n    TcpStateQueue *q = ssn->queue;\n\n    while (q != NULL) {\n        if (seq == q->seq &&\n            ack == q->ack) {\n            return q;\n        }\n\n        q = q->next;\n    }\n\n    return NULL;\n}\n\n/** \\internal\n *  \\brief Update SSN after receiving a valid SYN/ACK\n *\n *  Normally we update the SSN from the SYN/ACK packet. But in case\n *  of queued SYN/ACKs, we can use one of those.\n *\n *  \\param ssn TCP session\n *  \\param p Packet\n *  \\param q queued state if used, NULL otherwise\n *\n *  To make sure all SYN/ACK based state updates are in one place,\n *  this function can updated based on Packet or TcpStateQueue, where\n *  the latter takes precedence.\n */\nstatic void StreamTcp3whsSynAckUpdate(TcpSession *ssn, Packet *p, TcpStateQueue *q)\n{\n    TcpStateQueue update;\n    if (likely(q == NULL)) {\n        StreamTcp3whsSynAckToStateQueue(p, &update);\n        q = &update;\n    }\n\n    if (ssn->state != TCP_SYN_RECV) {\n        /* update state */\n        StreamTcpPacketSetState(p, ssn, TCP_SYN_RECV);\n        SCLogDebug(\"ssn %p: =~ ssn state is now TCP_SYN_RECV\", ssn);\n    }\n    /* sequence number & window */\n    ssn->server.isn = q->seq;\n    STREAMTCP_SET_RA_BASE_SEQ(&ssn->server, ssn->server.isn);\n    ssn->server.next_seq = ssn->server.isn + 1;\n\n    ssn->client.window = q->win;\n    SCLogDebug(\"ssn %p: window %\" PRIu32 \"\", ssn, ssn->server.window);\n\n    /* Set the timestamp values used to validate the timestamp of\n     * received packets.*/\n    if ((q->flags & STREAMTCP_QUEUE_FLAG_TS) &&\n            (ssn->client.flags & STREAMTCP_STREAM_FLAG_TIMESTAMP))\n    {\n        ssn->server.last_ts = q->ts;\n        SCLogDebug(\"ssn %p: ssn->server.last_ts %\" PRIu32\" \"\n                \"ssn->client.last_ts %\" PRIu32\"\", ssn,\n                ssn->server.last_ts, ssn->client.last_ts);\n        ssn->flags |= STREAMTCP_FLAG_TIMESTAMP;\n        ssn->server.last_pkt_ts = q->pkt_ts;\n        if (ssn->server.last_ts == 0)\n            ssn->server.flags |= STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n    } else {\n        ssn->client.last_ts = 0;\n        ssn->server.last_ts = 0;\n        ssn->client.flags &= ~STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n    }\n\n    ssn->client.last_ack = q->ack;\n    ssn->server.last_ack = ssn->server.isn + 1;\n\n    /** check for the presense of the ws ptr to determine if we\n     *  support wscale at all */\n    if ((ssn->flags & STREAMTCP_FLAG_SERVER_WSCALE) &&\n            (q->flags & STREAMTCP_QUEUE_FLAG_WS))\n    {\n        ssn->client.wscale = q->wscale;\n    } else {\n        ssn->client.wscale = 0;\n    }\n\n    if ((ssn->flags & STREAMTCP_FLAG_CLIENT_SACKOK) &&\n            (q->flags & STREAMTCP_QUEUE_FLAG_SACK)) {\n        ssn->flags |= STREAMTCP_FLAG_SACKOK;\n        SCLogDebug(\"ssn %p: SACK permitted for session\", ssn);\n    } else {\n        ssn->flags &= ~STREAMTCP_FLAG_SACKOK;\n    }\n\n    ssn->server.next_win = ssn->server.last_ack + ssn->server.window;\n    ssn->client.next_win = ssn->client.last_ack + ssn->client.window;\n    SCLogDebug(\"ssn %p: ssn->server.next_win %\" PRIu32 \"\", ssn,\n            ssn->server.next_win);\n    SCLogDebug(\"ssn %p: ssn->client.next_win %\" PRIu32 \"\", ssn,\n            ssn->client.next_win);\n    SCLogDebug(\"ssn %p: ssn->server.isn %\" PRIu32 \", \"\n            \"ssn->server.next_seq %\" PRIu32 \", \"\n            \"ssn->server.last_ack %\" PRIu32 \" \"\n            \"(ssn->client.last_ack %\" PRIu32 \")\", ssn,\n            ssn->server.isn, ssn->server.next_seq,\n            ssn->server.last_ack, ssn->client.last_ack);\n\n    /* unset the 4WHS flag as we received this SYN/ACK as part of a\n     * (so far) valid 3WHS */\n    if (ssn->flags & STREAMTCP_FLAG_4WHS)\n        SCLogDebug(\"ssn %p: STREAMTCP_FLAG_4WHS unset, normal SYN/ACK\"\n                \" so considering 3WHS\", ssn);\n\n    ssn->flags &=~ STREAMTCP_FLAG_4WHS;\n}\n\n/** \\internal\n *  \\brief detect timestamp anomalies when processing responses to the\n *         SYN packet.\n *  \\retval true packet is ok\n *  \\retval false packet is bad\n */\nstatic inline bool StateSynSentValidateTimestamp(TcpSession *ssn, Packet *p)\n{\n    /* we only care about evil server here, so skip TS packets */\n    if (PKT_IS_TOSERVER(p) || !(TCP_HAS_TS(p))) {\n        return true;\n    }\n\n    TcpStream *receiver_stream = &ssn->client;\n    uint32_t ts_echo = TCP_GET_TSECR(p);\n    if ((receiver_stream->flags & STREAMTCP_STREAM_FLAG_TIMESTAMP) != 0) {\n        if (receiver_stream->last_ts != 0 && ts_echo != 0 &&\n            ts_echo != receiver_stream->last_ts)\n        {\n            SCLogDebug(\"ssn %p: BAD TSECR echo %u recv %u\", ssn,\n                    ts_echo, receiver_stream->last_ts);\n            return false;\n        }\n    } else {\n        if (receiver_stream->last_ts == 0 && ts_echo != 0) {\n            SCLogDebug(\"ssn %p: BAD TSECR echo %u recv %u\", ssn,\n                    ts_echo, receiver_stream->last_ts);\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n *  \\brief  Function to handle the TCP_SYN_SENT state. The function handles\n *          SYN, SYN/ACK, RST packets and correspondingly changes the connection\n *          state.\n *\n *  \\param  tv      Thread Variable containing  input/output queue, cpu affinity\n *  \\param  p       Packet which has to be handled in this TCP state.\n *  \\param  stt     Strean Thread module registered to handle the stream handling\n */\n\nstatic int StreamTcpPacketStateSynSent(ThreadVars *tv, Packet *p,\n        StreamTcpThread *stt, TcpSession *ssn,\n        PacketQueueNoLock *pq)\n{\n    if (ssn == NULL)\n        return -1;\n\n    SCLogDebug(\"ssn %p: pkt received: %s\", ssn, PKT_IS_TOCLIENT(p) ?\n               \"toclient\":\"toserver\");\n\n    /* check for bad responses */\n    if (StateSynSentValidateTimestamp(ssn, p) == false)\n        return -1;\n\n    /* RST */\n    if (p->tcph->th_flags & TH_RST) {\n        if (!StreamTcpValidateRst(ssn, p))\n            return -1;\n\n        if (PKT_IS_TOSERVER(p)) {\n            if (SEQ_EQ(TCP_GET_SEQ(p), ssn->client.isn) &&\n                    SEQ_EQ(TCP_GET_WINDOW(p), 0) &&\n                    SEQ_EQ(TCP_GET_ACK(p), (ssn->client.isn + 1)))\n            {\n                SCLogDebug(\"ssn->server.flags |= STREAMTCP_STREAM_FLAG_RST_RECV\");\n                ssn->server.flags |= STREAMTCP_STREAM_FLAG_RST_RECV;\n                StreamTcpCloseSsnWithReset(p, ssn);\n            }\n        } else {\n            ssn->client.flags |= STREAMTCP_STREAM_FLAG_RST_RECV;\n            SCLogDebug(\"ssn->client.flags |= STREAMTCP_STREAM_FLAG_RST_RECV\");\n            StreamTcpCloseSsnWithReset(p, ssn);\n        }\n\n    /* FIN */\n    } else if (p->tcph->th_flags & TH_FIN) {\n        /** \\todo */\n\n    /* SYN/ACK */\n    } else if ((p->tcph->th_flags & (TH_SYN|TH_ACK)) == (TH_SYN|TH_ACK)) {\n        if ((ssn->flags & STREAMTCP_FLAG_4WHS) && PKT_IS_TOSERVER(p)) {\n            SCLogDebug(\"ssn %p: SYN/ACK received on 4WHS session\", ssn);\n\n            /* Check if the SYN/ACK packet ack's the earlier\n             * received SYN packet. */\n            if (!(SEQ_EQ(TCP_GET_ACK(p), ssn->server.isn + 1))) {\n                StreamTcpSetEvent(p, STREAM_4WHS_SYNACK_WITH_WRONG_ACK);\n\n                SCLogDebug(\"ssn %p: 4WHS ACK mismatch, packet ACK %\"PRIu32\"\"\n                        \" != %\" PRIu32 \" from stream\", ssn,\n                        TCP_GET_ACK(p), ssn->server.isn + 1);\n                return -1;\n            }\n\n            /* Check if the SYN/ACK packet SEQ's the *FIRST* received SYN\n             * packet. */\n            if (!(SEQ_EQ(TCP_GET_SEQ(p), ssn->client.isn))) {\n                StreamTcpSetEvent(p, STREAM_4WHS_SYNACK_WITH_WRONG_SYN);\n\n                SCLogDebug(\"ssn %p: 4WHS SEQ mismatch, packet SEQ %\"PRIu32\"\"\n                        \" != %\" PRIu32 \" from *first* SYN pkt\", ssn,\n                        TCP_GET_SEQ(p), ssn->client.isn);\n                return -1;\n            }\n\n\n            /* update state */\n            StreamTcpPacketSetState(p, ssn, TCP_SYN_RECV);\n            SCLogDebug(\"ssn %p: =~ 4WHS ssn state is now TCP_SYN_RECV\", ssn);\n\n            /* sequence number & window */\n            ssn->client.isn = TCP_GET_SEQ(p);\n            STREAMTCP_SET_RA_BASE_SEQ(&ssn->client, ssn->client.isn);\n            ssn->client.next_seq = ssn->client.isn + 1;\n\n            ssn->server.window = TCP_GET_WINDOW(p);\n            SCLogDebug(\"ssn %p: 4WHS window %\" PRIu32 \"\", ssn,\n                    ssn->client.window);\n\n            /* Set the timestamp values used to validate the timestamp of\n             * received packets. */\n            if ((TCP_HAS_TS(p)) &&\n                    (ssn->server.flags & STREAMTCP_STREAM_FLAG_TIMESTAMP))\n            {\n                ssn->client.last_ts = TCP_GET_TSVAL(p);\n                SCLogDebug(\"ssn %p: 4WHS ssn->client.last_ts %\" PRIu32\" \"\n                        \"ssn->server.last_ts %\" PRIu32\"\", ssn,\n                        ssn->client.last_ts, ssn->server.last_ts);\n                ssn->flags |= STREAMTCP_FLAG_TIMESTAMP;\n                ssn->client.last_pkt_ts = p->ts.tv_sec;\n                if (ssn->client.last_ts == 0)\n                    ssn->client.flags |= STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n            } else {\n                ssn->server.last_ts = 0;\n                ssn->client.last_ts = 0;\n                ssn->server.flags &= ~STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n            }\n\n            ssn->server.last_ack = TCP_GET_ACK(p);\n            ssn->client.last_ack = ssn->client.isn + 1;\n\n            /** check for the presense of the ws ptr to determine if we\n             *  support wscale at all */\n            if ((ssn->flags & STREAMTCP_FLAG_SERVER_WSCALE) &&\n                    (TCP_HAS_WSCALE(p)))\n            {\n                ssn->server.wscale = TCP_GET_WSCALE(p);\n            } else {\n                ssn->server.wscale = 0;\n            }\n\n            if ((ssn->flags & STREAMTCP_FLAG_CLIENT_SACKOK) &&\n                    TCP_GET_SACKOK(p) == 1) {\n                ssn->flags |= STREAMTCP_FLAG_SACKOK;\n                SCLogDebug(\"ssn %p: SACK permitted for 4WHS session\", ssn);\n            }\n\n            ssn->client.next_win = ssn->client.last_ack + ssn->client.window;\n            ssn->server.next_win = ssn->server.last_ack + ssn->server.window;\n            SCLogDebug(\"ssn %p: 4WHS ssn->client.next_win %\" PRIu32 \"\", ssn,\n                    ssn->client.next_win);\n            SCLogDebug(\"ssn %p: 4WHS ssn->server.next_win %\" PRIu32 \"\", ssn,\n                    ssn->server.next_win);\n            SCLogDebug(\"ssn %p: 4WHS ssn->client.isn %\" PRIu32 \", \"\n                    \"ssn->client.next_seq %\" PRIu32 \", \"\n                    \"ssn->client.last_ack %\" PRIu32 \" \"\n                    \"(ssn->server.last_ack %\" PRIu32 \")\", ssn,\n                    ssn->client.isn, ssn->client.next_seq,\n                    ssn->client.last_ack, ssn->server.last_ack);\n\n            /* done here */\n            return 0;\n        }\n\n        if (PKT_IS_TOSERVER(p)) {\n            StreamTcpSetEvent(p, STREAM_3WHS_SYNACK_IN_WRONG_DIRECTION);\n            SCLogDebug(\"ssn %p: SYN/ACK received in the wrong direction\", ssn);\n            return -1;\n        }\n\n        if (!(TCP_HAS_TFO(p) || (ssn->flags & STREAMTCP_FLAG_TCP_FAST_OPEN))) {\n            /* Check if the SYN/ACK packet ack's the earlier\n             * received SYN packet. */\n            if (!(SEQ_EQ(TCP_GET_ACK(p), ssn->client.isn + 1))) {\n                StreamTcpSetEvent(p, STREAM_3WHS_SYNACK_WITH_WRONG_ACK);\n                SCLogDebug(\"ssn %p: ACK mismatch, packet ACK %\" PRIu32 \" != \"\n                        \"%\" PRIu32 \" from stream\", ssn, TCP_GET_ACK(p),\n                        ssn->client.isn + 1);\n                return -1;\n            }\n        } else {\n            if (!(SEQ_EQ(TCP_GET_ACK(p), ssn->client.next_seq))) {\n                StreamTcpSetEvent(p, STREAM_3WHS_SYNACK_WITH_WRONG_ACK);\n                SCLogDebug(\"ssn %p: (TFO) ACK mismatch, packet ACK %\" PRIu32 \" != \"\n                        \"%\" PRIu32 \" from stream\", ssn, TCP_GET_ACK(p),\n                        ssn->client.next_seq);\n                return -1;\n            }\n            SCLogDebug(\"ssn %p: (TFO) ACK match, packet ACK %\" PRIu32 \" == \"\n                    \"%\" PRIu32 \" from stream\", ssn, TCP_GET_ACK(p),\n                    ssn->client.next_seq);\n\n            ssn->flags |= STREAMTCP_FLAG_TCP_FAST_OPEN;\n            StreamTcpPacketSetState(p, ssn, TCP_ESTABLISHED);\n        }\n        StreamTcp3whsSynAckUpdate(ssn, p, /* no queue override */NULL);\n\n    } else if (p->tcph->th_flags & TH_SYN) {\n        SCLogDebug(\"ssn %p: SYN packet on state SYN_SENT... resent\", ssn);\n        if (ssn->flags & STREAMTCP_FLAG_4WHS) {\n            SCLogDebug(\"ssn %p: SYN packet on state SYN_SENT... resent of \"\n                    \"4WHS SYN\", ssn);\n        }\n\n        if (PKT_IS_TOCLIENT(p)) {\n            /** a SYN only packet in the opposite direction could be:\n             *  http://www.breakingpointsystems.com/community/blog/tcp-\n             *  portals-the-three-way-handshake-is-a-lie\n             *\n             * \\todo improve resetting the session */\n\n            /* indicate that we're dealing with 4WHS here */\n            ssn->flags |= STREAMTCP_FLAG_4WHS;\n            SCLogDebug(\"ssn %p: STREAMTCP_FLAG_4WHS flag set\", ssn);\n\n            /* set the sequence numbers and window for server\n             * We leave the ssn->client.isn in place as we will\n             * check the SYN/ACK pkt with that.\n             */\n            ssn->server.isn = TCP_GET_SEQ(p);\n            STREAMTCP_SET_RA_BASE_SEQ(&ssn->server, ssn->server.isn);\n            ssn->server.next_seq = ssn->server.isn + 1;\n\n            /* Set the stream timestamp value, if packet has timestamp\n             * option enabled. */\n            if (TCP_HAS_TS(p)) {\n                ssn->server.last_ts = TCP_GET_TSVAL(p);\n                SCLogDebug(\"ssn %p: %02x\", ssn, ssn->server.last_ts);\n\n                if (ssn->server.last_ts == 0)\n                    ssn->server.flags |= STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n                ssn->server.last_pkt_ts = p->ts.tv_sec;\n                ssn->server.flags |= STREAMTCP_STREAM_FLAG_TIMESTAMP;\n            }\n\n            ssn->server.window = TCP_GET_WINDOW(p);\n            if (TCP_HAS_WSCALE(p)) {\n                ssn->flags |= STREAMTCP_FLAG_SERVER_WSCALE;\n                ssn->server.wscale = TCP_GET_WSCALE(p);\n            } else {\n                ssn->flags &= ~STREAMTCP_FLAG_SERVER_WSCALE;\n                ssn->server.wscale = 0;\n            }\n\n            if (TCP_GET_SACKOK(p) == 1) {\n                ssn->flags |= STREAMTCP_FLAG_CLIENT_SACKOK;\n            } else {\n                ssn->flags &= ~STREAMTCP_FLAG_CLIENT_SACKOK;\n            }\n\n            SCLogDebug(\"ssn %p: 4WHS ssn->server.isn %\" PRIu32 \", \"\n                    \"ssn->server.next_seq %\" PRIu32 \", \"\n                    \"ssn->server.last_ack %\"PRIu32\"\", ssn,\n                    ssn->server.isn, ssn->server.next_seq,\n                    ssn->server.last_ack);\n            SCLogDebug(\"ssn %p: 4WHS ssn->client.isn %\" PRIu32 \", \"\n                    \"ssn->client.next_seq %\" PRIu32 \", \"\n                    \"ssn->client.last_ack %\"PRIu32\"\", ssn,\n                    ssn->client.isn, ssn->client.next_seq,\n                    ssn->client.last_ack);\n        }\n\n        /** \\todo check if it's correct or set event */\n\n    } else if (p->tcph->th_flags & TH_ACK) {\n        /* Handle the asynchronous stream, when we receive a  SYN packet\n           and now instead of receiving a SYN/ACK we receive a ACK from the\n           same host, which sent the SYN, this suggests the ASYNC streams.*/\n        if (stream_config.async_oneside == FALSE)\n            return 0;\n\n        /* we are in AYNC (one side) mode now. */\n\n        /* one side async means we won't see a SYN/ACK, so we can\n         * only check the SYN. */\n        if (!(SEQ_EQ(TCP_GET_SEQ(p), ssn->client.next_seq))) {\n            StreamTcpSetEvent(p, STREAM_3WHS_ASYNC_WRONG_SEQ);\n\n            SCLogDebug(\"ssn %p: SEQ mismatch, packet SEQ %\" PRIu32 \" != \"\n                    \"%\" PRIu32 \" from stream\",ssn, TCP_GET_SEQ(p),\n                    ssn->client.next_seq);\n            return -1;\n        }\n\n        ssn->flags |= STREAMTCP_FLAG_ASYNC;\n        StreamTcpPacketSetState(p, ssn, TCP_ESTABLISHED);\n        SCLogDebug(\"ssn %p: =~ ssn state is now TCP_ESTABLISHED\", ssn);\n\n        ssn->client.window = TCP_GET_WINDOW(p);\n        ssn->client.last_ack = TCP_GET_SEQ(p);\n        ssn->client.next_win = ssn->client.last_ack + ssn->client.window;\n\n        /* Set the server side parameters */\n        ssn->server.isn = TCP_GET_ACK(p) - 1;\n        STREAMTCP_SET_RA_BASE_SEQ(&ssn->server, ssn->server.isn);\n        ssn->server.next_seq = ssn->server.isn + 1;\n        ssn->server.last_ack = ssn->server.next_seq;\n        ssn->server.next_win = ssn->server.last_ack;\n\n        SCLogDebug(\"ssn %p: synsent => Asynchronous stream, packet SEQ\"\n                \" %\" PRIu32 \", payload size %\" PRIu32 \" (%\" PRIu32 \"), \"\n                \"ssn->client.next_seq %\" PRIu32 \"\"\n                ,ssn, TCP_GET_SEQ(p), p->payload_len, TCP_GET_SEQ(p)\n                + p->payload_len, ssn->client.next_seq);\n\n        /* if SYN had wscale, assume it to be supported. Otherwise\n         * we know it not to be supported. */\n        if (ssn->flags & STREAMTCP_FLAG_SERVER_WSCALE) {\n            ssn->client.wscale = TCP_WSCALE_MAX;\n        }\n\n        /* Set the timestamp values used to validate the timestamp of\n         * received packets.*/\n        if (TCP_HAS_TS(p) &&\n                (ssn->client.flags & STREAMTCP_STREAM_FLAG_TIMESTAMP))\n        {\n            ssn->flags |= STREAMTCP_FLAG_TIMESTAMP;\n            ssn->client.flags &= ~STREAMTCP_STREAM_FLAG_TIMESTAMP;\n            ssn->client.last_pkt_ts = p->ts.tv_sec;\n        } else {\n            ssn->client.last_ts = 0;\n            ssn->client.flags &= ~STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n        }\n\n        if (ssn->flags & STREAMTCP_FLAG_CLIENT_SACKOK) {\n            ssn->flags |= STREAMTCP_FLAG_SACKOK;\n        }\n\n        StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                &ssn->client, p, pq);\n\n    } else {\n        SCLogDebug(\"ssn %p: default case\", ssn);\n    }\n\n    return 0;\n}\n\n/**\n *  \\brief  Function to handle the TCP_SYN_RECV state. The function handles\n *          SYN, SYN/ACK, ACK, FIN, RST packets and correspondingly changes\n *          the connection state.\n *\n *  \\param  tv      Thread Variable containing  input/output queue, cpu affinity\n *  \\param  p       Packet which has to be handled in this TCP state.\n *  \\param  stt     Strean Thread module registered to handle the stream handling\n *\n *  \\retval  0 ok\n *  \\retval -1 error\n */\n\nstatic int StreamTcpPacketStateSynRecv(ThreadVars *tv, Packet *p,\n        StreamTcpThread *stt, TcpSession *ssn,\n        PacketQueueNoLock *pq)\n{\n    if (ssn == NULL)\n        return -1;\n\n    if (p->tcph->th_flags & TH_RST) {\n        if (!StreamTcpValidateRst(ssn, p))\n            return -1;\n\n        bool reset = true;\n        /* After receiveing the RST in SYN_RECV state and if detection\n           evasion flags has been set, then the following operating\n           systems will not closed the connection. As they consider the\n           packet as stray packet and not belonging to the current\n           session, for more information check\n           http://www.packetstan.com/2010/06/recently-ive-been-on-campaign-to-make.html */\n        if (ssn->flags & STREAMTCP_FLAG_DETECTION_EVASION_ATTEMPT) {\n            if (PKT_IS_TOSERVER(p)) {\n                if ((ssn->server.os_policy == OS_POLICY_LINUX) ||\n                        (ssn->server.os_policy == OS_POLICY_OLD_LINUX) ||\n                        (ssn->server.os_policy == OS_POLICY_SOLARIS))\n                {\n                    reset = false;\n                    SCLogDebug(\"Detection evasion has been attempted, so\"\n                            \" not resetting the connection !!\");\n                }\n            } else {\n                if ((ssn->client.os_policy == OS_POLICY_LINUX) ||\n                        (ssn->client.os_policy == OS_POLICY_OLD_LINUX) ||\n                        (ssn->client.os_policy == OS_POLICY_SOLARIS))\n                {\n                    reset = false;\n                    SCLogDebug(\"Detection evasion has been attempted, so\"\n                            \" not resetting the connection !!\");\n                }\n            }\n        }\n\n        if (reset) {\n            StreamTcpCloseSsnWithReset(p, ssn);\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n        }\n\n    } else if (p->tcph->th_flags & TH_FIN) {\n        /* FIN is handled in the same way as in TCP_ESTABLISHED case */;\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            if (!StreamTcpValidateTimestamp(ssn, p))\n                return -1;\n        }\n\n        if ((StreamTcpHandleFin(tv, stt, ssn, p, pq)) == -1)\n            return -1;\n\n    /* SYN/ACK */\n    } else if ((p->tcph->th_flags & (TH_SYN|TH_ACK)) == (TH_SYN|TH_ACK)) {\n        SCLogDebug(\"ssn %p: SYN/ACK packet on state SYN_RECV. resent\", ssn);\n\n        if (PKT_IS_TOSERVER(p)) {\n            SCLogDebug(\"ssn %p: SYN/ACK-pkt to server in SYN_RECV state\", ssn);\n\n            StreamTcpSetEvent(p, STREAM_3WHS_SYNACK_TOSERVER_ON_SYN_RECV);\n            return -1;\n        }\n\n        /* Check if the SYN/ACK packets ACK matches the earlier\n         * received SYN/ACK packet. */\n        if (!(SEQ_EQ(TCP_GET_ACK(p), ssn->client.last_ack))) {\n            SCLogDebug(\"ssn %p: ACK mismatch, packet ACK %\" PRIu32 \" != \"\n                    \"%\" PRIu32 \" from stream\", ssn, TCP_GET_ACK(p),\n                    ssn->client.isn + 1);\n\n            StreamTcpSetEvent(p, STREAM_3WHS_SYNACK_RESEND_WITH_DIFFERENT_ACK);\n            return -1;\n        }\n\n        /* Check if the SYN/ACK packet SEQ the earlier\n         * received SYN/ACK packet, server resend with different ISN. */\n        if (!(SEQ_EQ(TCP_GET_SEQ(p), ssn->server.isn))) {\n            SCLogDebug(\"ssn %p: SEQ mismatch, packet SEQ %\" PRIu32 \" != \"\n                    \"%\" PRIu32 \" from stream\", ssn, TCP_GET_SEQ(p),\n                    ssn->client.isn);\n\n            if (StreamTcp3whsQueueSynAck(ssn, p) == -1)\n                return -1;\n            SCLogDebug(\"ssn %p: queued different SYN/ACK\", ssn);\n        }\n\n    } else if (p->tcph->th_flags & TH_SYN) {\n        SCLogDebug(\"ssn %p: SYN packet on state SYN_RECV... resent\", ssn);\n\n        if (PKT_IS_TOCLIENT(p)) {\n            SCLogDebug(\"ssn %p: SYN-pkt to client in SYN_RECV state\", ssn);\n\n            StreamTcpSetEvent(p, STREAM_3WHS_SYN_TOCLIENT_ON_SYN_RECV);\n            return -1;\n        }\n\n        if (!(SEQ_EQ(TCP_GET_SEQ(p), ssn->client.isn))) {\n            SCLogDebug(\"ssn %p: SYN with different SEQ on SYN_RECV state\", ssn);\n\n            StreamTcpSetEvent(p, STREAM_3WHS_SYN_RESEND_DIFF_SEQ_ON_SYN_RECV);\n            return -1;\n        }\n\n    } else if (p->tcph->th_flags & TH_ACK) {\n        if (ssn->queue_len) {\n            SCLogDebug(\"ssn %p: checking ACK against queued SYN/ACKs\", ssn);\n            TcpStateQueue *q = StreamTcp3whsFindSynAckByAck(ssn, p);\n            if (q != NULL) {\n                SCLogDebug(\"ssn %p: here we update state against queued SYN/ACK\", ssn);\n                StreamTcp3whsSynAckUpdate(ssn, p, /* using queue to update state */q);\n            } else {\n                SCLogDebug(\"ssn %p: none found, now checking ACK against original SYN/ACK (state)\", ssn);\n            }\n        }\n\n\n        /* If the timestamp option is enabled for both the streams, then\n         * validate the received packet timestamp value against the\n         * stream->last_ts. If the timestamp is valid then process the\n         * packet normally otherwise the drop the packet (RFC 1323)*/\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            if (!(StreamTcpValidateTimestamp(ssn, p))) {\n                return -1;\n            }\n        }\n\n        if ((ssn->flags & STREAMTCP_FLAG_4WHS) && PKT_IS_TOCLIENT(p)) {\n            SCLogDebug(\"ssn %p: ACK received on 4WHS session\",ssn);\n\n            if (!(SEQ_EQ(TCP_GET_SEQ(p), ssn->server.next_seq))) {\n                SCLogDebug(\"ssn %p: 4WHS wrong seq nr on packet\", ssn);\n                StreamTcpSetEvent(p, STREAM_4WHS_WRONG_SEQ);\n                return -1;\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->client, p) == -1) {\n                SCLogDebug(\"ssn %p: 4WHS invalid ack nr on packet\", ssn);\n                StreamTcpSetEvent(p, STREAM_4WHS_INVALID_ACK);\n                return -1;\n            }\n\n            SCLogDebug(\"4WHS normal pkt\");\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to client: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_ACK(p));\n            StreamTcpUpdateNextSeq(ssn, &ssn->server, (ssn->server.next_seq + p->payload_len));\n            ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n            ssn->client.next_win = ssn->client.last_ack + ssn->client.window;\n\n            StreamTcpPacketSetState(p, ssn, TCP_ESTABLISHED);\n            SCLogDebug(\"ssn %p: =~ ssn state is now TCP_ESTABLISHED\", ssn);\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n\n            SCLogDebug(\"ssn %p: ssn->client.next_win %\" PRIu32 \", \"\n                    \"ssn->client.last_ack %\"PRIu32\"\", ssn,\n                    ssn->client.next_win, ssn->client.last_ack);\n            return 0;\n        }\n\n        bool ack_indicates_missed_3whs_ack_packet = false;\n        /* Check if the ACK received is in right direction. But when we have\n         * picked up a mid stream session after missing the initial SYN pkt,\n         * in this case the ACK packet can arrive from either client (normal\n         * case) or from server itself (asynchronous streams). Therefore\n         *  the check has been avoided in this case */\n        if (PKT_IS_TOCLIENT(p)) {\n            /* special case, handle 4WHS, so SYN/ACK in the opposite\n             * direction */\n            if (ssn->flags & STREAMTCP_FLAG_MIDSTREAM_SYNACK) {\n                SCLogDebug(\"ssn %p: ACK received on midstream SYN/ACK \"\n                        \"pickup session\",ssn);\n                /* fall through */\n            } else if (ssn->flags & STREAMTCP_FLAG_TCP_FAST_OPEN) {\n                SCLogDebug(\"ssn %p: ACK received on TFO session\",ssn);\n                /* fall through */\n\n            } else {\n                /* if we missed traffic between the S/SA and the current\n                 * 'wrong direction' ACK, we could end up here. In IPS\n                 * reject it. But in IDS mode we continue.\n                 *\n                 * IPS rejects as it should see all packets, so pktloss\n                 * should lead to retransmissions. As this can also be\n                 * pattern for MOTS/MITM injection attacks, we need to be\n                 * careful.\n                 */\n                if (StreamTcpInlineMode()) {\n                    if (p->payload_len > 0 &&\n                            SEQ_EQ(TCP_GET_ACK(p), ssn->client.last_ack) &&\n                            SEQ_EQ(TCP_GET_SEQ(p), ssn->server.next_seq)) {\n                        /* packet loss is possible but unlikely here */\n                        SCLogDebug(\"ssn %p: possible data injection\", ssn);\n                        StreamTcpSetEvent(p, STREAM_3WHS_ACK_DATA_INJECT);\n                        return -1;\n                    }\n\n                    SCLogDebug(\"ssn %p: ACK received in the wrong direction\",\n                            ssn);\n                    StreamTcpSetEvent(p, STREAM_3WHS_ACK_IN_WRONG_DIR);\n                    return -1;\n                }\n                ack_indicates_missed_3whs_ack_packet = true;\n            }\n        }\n\n        SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to server: SEQ %\" PRIu32 \"\"\n                \", ACK %\" PRIu32 \"\", ssn, p->payload_len, TCP_GET_SEQ(p),\n                TCP_GET_ACK(p));\n\n        /* Check both seq and ack number before accepting the packet and\n           changing to ESTABLISHED state */\n        if ((SEQ_EQ(TCP_GET_SEQ(p), ssn->client.next_seq)) &&\n                SEQ_EQ(TCP_GET_ACK(p), ssn->server.next_seq)) {\n            SCLogDebug(\"normal pkt\");\n\n            /* process the packet normal, No Async streams :) */\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server, TCP_GET_ACK(p));\n            StreamTcpUpdateNextSeq(ssn, &ssn->client, (ssn->client.next_seq + p->payload_len));\n            ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n\n            ssn->server.next_win = ssn->server.last_ack + ssn->server.window;\n\n            if (ssn->flags & STREAMTCP_FLAG_MIDSTREAM) {\n                ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n                ssn->client.next_win = ssn->client.last_ack + ssn->client.window;\n                ssn->server.next_win = ssn->server.last_ack +\n                    ssn->server.window;\n                if (!(ssn->flags & STREAMTCP_FLAG_MIDSTREAM_SYNACK)) {\n                    /* window scaling for midstream pickups, we can't do much\n                     * other than assume that it's set to the max value: 14 */\n                    ssn->server.wscale = TCP_WSCALE_MAX;\n                    ssn->client.wscale = TCP_WSCALE_MAX;\n                    ssn->flags |= STREAMTCP_FLAG_SACKOK;\n                }\n            }\n\n            StreamTcpPacketSetState(p, ssn, TCP_ESTABLISHED);\n            SCLogDebug(\"ssn %p: =~ ssn state is now TCP_ESTABLISHED\", ssn);\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n\n            /* If asynchronous stream handling is allowed then set the session,\n               if packet's seq number is equal the expected seq no.*/\n        } else if (stream_config.async_oneside == TRUE &&\n                (SEQ_EQ(TCP_GET_SEQ(p), ssn->server.next_seq)))\n        {\n            /*set the ASYNC flag used to indicate the session as async stream\n              and helps in relaxing the windows checks.*/\n            ssn->flags |= STREAMTCP_FLAG_ASYNC;\n            ssn->server.next_seq += p->payload_len;\n            ssn->server.last_ack = TCP_GET_SEQ(p);\n\n            ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n            ssn->client.last_ack = TCP_GET_ACK(p);\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            if (ssn->flags & STREAMTCP_FLAG_MIDSTREAM) {\n                ssn->server.window = TCP_GET_WINDOW(p);\n                ssn->server.next_win = ssn->server.last_ack + ssn->server.window;\n                /* window scaling for midstream pickups, we can't do much\n                 * other than assume that it's set to the max value: 14 */\n                ssn->server.wscale = TCP_WSCALE_MAX;\n                ssn->client.wscale = TCP_WSCALE_MAX;\n                ssn->flags |= STREAMTCP_FLAG_SACKOK;\n            }\n\n            SCLogDebug(\"ssn %p: synrecv => Asynchronous stream, packet SEQ\"\n                    \" %\" PRIu32 \", payload size %\" PRIu32 \" (%\" PRIu32 \"), \"\n                    \"ssn->server.next_seq %\" PRIu32\n                    , ssn, TCP_GET_SEQ(p), p->payload_len, TCP_GET_SEQ(p)\n                    + p->payload_len, ssn->server.next_seq);\n\n            StreamTcpPacketSetState(p, ssn, TCP_ESTABLISHED);\n            SCLogDebug(\"ssn %p: =~ ssn state is now TCP_ESTABLISHED\", ssn);\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n            /* Upon receiving the packet with correct seq number and wrong\n               ACK number, it causes the other end to send RST. But some target\n               system (Linux & solaris) does not RST the connection, so it is\n               likely to avoid the detection */\n        } else if (SEQ_EQ(TCP_GET_SEQ(p), ssn->client.next_seq)){\n            ssn->flags |= STREAMTCP_FLAG_DETECTION_EVASION_ATTEMPT;\n            SCLogDebug(\"ssn %p: wrong ack nr on packet, possible evasion!!\",\n                    ssn);\n\n            StreamTcpSetEvent(p, STREAM_3WHS_RIGHT_SEQ_WRONG_ACK_EVASION);\n            return -1;\n\n            /* SYN/ACK followed by more TOCLIENT suggesting packet loss */\n        } else if (PKT_IS_TOCLIENT(p) && !StreamTcpInlineMode() &&\n                   SEQ_GT(TCP_GET_SEQ(p), ssn->client.next_seq) &&\n                   SEQ_GT(TCP_GET_ACK(p), ssn->client.last_ack)) {\n            SCLogDebug(\"ssn %p: ACK for missing data\", ssn);\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_ACK(p));\n\n            ssn->server.next_seq = TCP_GET_SEQ(p) + p->payload_len;\n            SCLogDebug(\"ssn %p: ACK for missing data: ssn->server.next_seq %u\", ssn,\n                    ssn->server.next_seq);\n            ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n\n            ssn->client.next_win = ssn->client.last_ack + ssn->client.window;\n\n            ssn->client.window = TCP_GET_WINDOW(p);\n            ssn->server.next_win = ssn->server.last_ack + ssn->server.window;\n\n            StreamTcpPacketSetState(p, ssn, TCP_ESTABLISHED);\n            SCLogDebug(\"ssn %p: =~ ssn state is now TCP_ESTABLISHED\", ssn);\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn, &ssn->server, p, pq);\n\n            /* if we get a packet with a proper ack, but a seq that is beyond\n             * next_seq but in-window, we probably missed some packets */\n        } else if (SEQ_GT(TCP_GET_SEQ(p), ssn->client.next_seq) &&\n                   SEQ_LEQ(TCP_GET_SEQ(p), ssn->client.next_win) &&\n                   SEQ_EQ(TCP_GET_ACK(p), ssn->server.next_seq)) {\n            SCLogDebug(\"ssn %p: ACK for missing data\", ssn);\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server, TCP_GET_ACK(p));\n\n            ssn->client.next_seq = TCP_GET_SEQ(p) + p->payload_len;\n            SCLogDebug(\"ssn %p: ACK for missing data: ssn->client.next_seq %u\", ssn, ssn->client.next_seq);\n            ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n\n            ssn->server.next_win = ssn->server.last_ack + ssn->server.window;\n\n            if (ssn->flags & STREAMTCP_FLAG_MIDSTREAM) {\n                ssn->client.window = TCP_GET_WINDOW(p);\n                ssn->server.next_win = ssn->server.last_ack +\n                    ssn->server.window;\n                /* window scaling for midstream pickups, we can't do much\n                 * other than assume that it's set to the max value: 14 */\n                ssn->server.wscale = TCP_WSCALE_MAX;\n                ssn->client.wscale = TCP_WSCALE_MAX;\n                ssn->flags |= STREAMTCP_FLAG_SACKOK;\n            }\n\n            StreamTcpPacketSetState(p, ssn, TCP_ESTABLISHED);\n            SCLogDebug(\"ssn %p: =~ ssn state is now TCP_ESTABLISHED\", ssn);\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n\n        /* toclient packet: after having missed the 3whs's final ACK */\n        } else if ((ack_indicates_missed_3whs_ack_packet ||\n                           (ssn->flags & STREAMTCP_FLAG_TCP_FAST_OPEN)) &&\n                   SEQ_EQ(TCP_GET_ACK(p), ssn->client.last_ack) &&\n                   SEQ_EQ(TCP_GET_SEQ(p), ssn->server.next_seq)) {\n            if (ack_indicates_missed_3whs_ack_packet) {\n                SCLogDebug(\"ssn %p: packet fits perfectly after a missed 3whs-ACK\", ssn);\n            } else {\n                SCLogDebug(\"ssn %p: (TFO) expected packet fits perfectly after SYN/ACK\", ssn);\n            }\n\n            StreamTcpUpdateNextSeq(ssn, &ssn->server, (TCP_GET_SEQ(p) + p->payload_len));\n\n            ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n            ssn->server.next_win = ssn->server.last_ack + ssn->server.window;\n\n            StreamTcpPacketSetState(p, ssn, TCP_ESTABLISHED);\n            SCLogDebug(\"ssn %p: =~ ssn state is now TCP_ESTABLISHED\", ssn);\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n\n        } else {\n            SCLogDebug(\"ssn %p: wrong seq nr on packet\", ssn);\n\n            StreamTcpSetEvent(p, STREAM_3WHS_WRONG_SEQ_WRONG_ACK);\n            return -1;\n        }\n\n        SCLogDebug(\"ssn %p: ssn->server.next_win %\" PRIu32 \", \"\n                \"ssn->server.last_ack %\"PRIu32\"\", ssn,\n                ssn->server.next_win, ssn->server.last_ack);\n    } else {\n        SCLogDebug(\"ssn %p: default case\", ssn);\n    }\n\n    return 0;\n}\n\n/**\n *  \\brief  Function to handle the TCP_ESTABLISHED state packets, which are\n *          sent by the client to server. The function handles\n *          ACK packets and call StreamTcpReassembleHandleSegment() to handle\n *          the reassembly.\n *\n *  Timestamp has already been checked at this point.\n *\n *  \\param  tv      Thread Variable containing  input/output queue, cpu affinity etc.\n *  \\param  ssn     Pointer to the current TCP session\n *  \\param  p       Packet which has to be handled in this TCP state.\n *  \\param  stt     Strean Thread module registered to handle the stream handling\n */\nstatic int HandleEstablishedPacketToServer(ThreadVars *tv, TcpSession *ssn, Packet *p,\n                        StreamTcpThread *stt, PacketQueueNoLock *pq)\n{\n    SCLogDebug(\"ssn %p: =+ pkt (%\" PRIu32 \") is to server: SEQ %\" PRIu32 \",\"\n               \"ACK %\" PRIu32 \", WIN %\"PRIu16\"\", ssn, p->payload_len,\n                TCP_GET_SEQ(p), TCP_GET_ACK(p), TCP_GET_WINDOW(p));\n\n    if (StreamTcpValidateAck(ssn, &(ssn->server), p) == -1) {\n        SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n        StreamTcpSetEvent(p, STREAM_EST_INVALID_ACK);\n        return -1;\n    }\n\n    /* check for Keep Alive */\n    if ((p->payload_len == 0 || p->payload_len == 1) &&\n            (TCP_GET_SEQ(p) == (ssn->client.next_seq - 1))) {\n        SCLogDebug(\"ssn %p: pkt is keep alive\", ssn);\n\n    /* normal pkt */\n    } else if (!(SEQ_GEQ((TCP_GET_SEQ(p)+p->payload_len), ssn->client.last_ack))) {\n        if (ssn->flags & STREAMTCP_FLAG_ASYNC) {\n            SCLogDebug(\"ssn %p: server => Asynchrouns stream, packet SEQ\"\n                    \" %\" PRIu32 \", payload size %\" PRIu32 \" (%\" PRIu32 \"),\"\n                    \" ssn->client.last_ack %\" PRIu32 \", ssn->client.next_win\"\n                    \"%\" PRIu32\"(%\"PRIu32\")\", ssn, TCP_GET_SEQ(p),\n                    p->payload_len, TCP_GET_SEQ(p) + p->payload_len,\n                    ssn->client.last_ack, ssn->client.next_win,\n                    TCP_GET_SEQ(p) + p->payload_len - ssn->client.next_win);\n\n            /* update the last_ack to current seq number as the session is\n             * async and other stream is not updating it anymore :( */\n            StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_SEQ(p));\n\n        } else if (SEQ_EQ(ssn->client.next_seq, TCP_GET_SEQ(p)) &&\n                (stream_config.async_oneside == TRUE) &&\n                (ssn->flags & STREAMTCP_FLAG_MIDSTREAM)) {\n            SCLogDebug(\"ssn %p: server => Asynchronous stream, packet SEQ.\"\n                    \" %\" PRIu32 \", payload size %\" PRIu32 \" (%\" PRIu32 \"), \"\n                    \"ssn->client.last_ack %\" PRIu32 \", ssn->client.next_win \"\n                    \"%\" PRIu32 \"(%\"PRIu32\")\", ssn, TCP_GET_SEQ(p),\n                    p->payload_len, TCP_GET_SEQ(p) + p->payload_len,\n                    ssn->client.last_ack, ssn->client.next_win,\n                    TCP_GET_SEQ(p) + p->payload_len - ssn->client.next_win);\n\n            /* it seems we missed SYN and SYN/ACK packets of this session.\n             * Update the last_ack to current seq number as the session\n             * is async and other stream is not updating it anymore :( */\n            StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_SEQ(p));\n            ssn->flags |= STREAMTCP_FLAG_ASYNC;\n\n        } else if (SEQ_EQ(ssn->client.last_ack, (ssn->client.isn + 1)) &&\n                (stream_config.async_oneside == TRUE) &&\n                (ssn->flags & STREAMTCP_FLAG_MIDSTREAM)) {\n            SCLogDebug(\"ssn %p: server => Asynchronous stream, packet SEQ\"\n                    \" %\" PRIu32 \", payload size %\" PRIu32 \" (%\" PRIu32 \"), \"\n                    \"ssn->client.last_ack %\" PRIu32 \", ssn->client.next_win \"\n                    \"%\" PRIu32 \"(%\"PRIu32\")\", ssn, TCP_GET_SEQ(p),\n                    p->payload_len, TCP_GET_SEQ(p) + p->payload_len,\n                    ssn->client.last_ack, ssn->client.next_win,\n                    TCP_GET_SEQ(p) + p->payload_len - ssn->client.next_win);\n\n            /* it seems we missed SYN and SYN/ACK packets of this session.\n             * Update the last_ack to current seq number as the session\n             * is async and other stream is not updating it anymore :(*/\n            StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_SEQ(p));\n            ssn->flags |= STREAMTCP_FLAG_ASYNC;\n\n        /* if last ack is beyond next_seq, we have accepted ack's for missing data.\n         * In this case we do accept the data before last_ack if it is (partly)\n         * beyond next seq */\n        } else if (SEQ_GT(ssn->client.last_ack, ssn->client.next_seq) &&\n                   SEQ_GT((TCP_GET_SEQ(p)+p->payload_len),ssn->client.next_seq))\n        {\n            SCLogDebug(\"ssn %p: PKT SEQ %\"PRIu32\" payload_len %\"PRIu16\n                    \" before last_ack %\"PRIu32\", after next_seq %\"PRIu32\":\"\n                    \" acked data that we haven't seen before\",\n                    ssn, TCP_GET_SEQ(p), p->payload_len, ssn->client.last_ack, ssn->client.next_seq);\n            if (SEQ_EQ(TCP_GET_SEQ(p),ssn->client.next_seq)) {\n                StreamTcpUpdateNextSeq(ssn, &ssn->client, (ssn->client.next_seq + p->payload_len));\n            }\n        } else {\n            SCLogDebug(\"ssn %p: server => SEQ before last_ack, packet SEQ\"\n                    \" %\" PRIu32 \", payload size %\" PRIu32 \" (%\" PRIu32 \"), \"\n                    \"ssn->client.last_ack %\" PRIu32 \", ssn->client.next_win \"\n                    \"%\" PRIu32 \"(%\"PRIu32\")\", ssn, TCP_GET_SEQ(p),\n                    p->payload_len, TCP_GET_SEQ(p) + p->payload_len,\n                    ssn->client.last_ack, ssn->client.next_win,\n                    TCP_GET_SEQ(p) + p->payload_len - ssn->client.next_win);\n\n            SCLogDebug(\"ssn %p: rejecting because pkt before last_ack\", ssn);\n            StreamTcpSetEvent(p, STREAM_EST_PKT_BEFORE_LAST_ACK);\n            return -1;\n        }\n    }\n\n    int zerowindowprobe = 0;\n    /* zero window probe */\n    if (p->payload_len == 1 && TCP_GET_SEQ(p) == ssn->client.next_seq && ssn->client.window == 0) {\n        SCLogDebug(\"ssn %p: zero window probe\", ssn);\n        zerowindowprobe = 1;\n\n    /* expected packet */\n    } else if (SEQ_EQ(ssn->client.next_seq, TCP_GET_SEQ(p))) {\n        StreamTcpUpdateNextSeq(ssn, &ssn->client, (ssn->client.next_seq + p->payload_len));\n\n    /* not completely as expected, but valid */\n    } else if (SEQ_LT(TCP_GET_SEQ(p),ssn->client.next_seq) &&\n               SEQ_GT((TCP_GET_SEQ(p)+p->payload_len), ssn->client.next_seq))\n    {\n        StreamTcpUpdateNextSeq(ssn, &ssn->client, (TCP_GET_SEQ(p) + p->payload_len));\n        SCLogDebug(\"ssn %p: ssn->client.next_seq %\"PRIu32\n                   \" (started before next_seq, ended after)\",\n                   ssn, ssn->client.next_seq);\n\n    /* if next_seq has fallen behind last_ack, we got some catching up to do */\n    } else if (SEQ_LT(ssn->client.next_seq, ssn->client.last_ack)) {\n        StreamTcpUpdateNextSeq(ssn, &ssn->client, (TCP_GET_SEQ(p) + p->payload_len));\n        SCLogDebug(\"ssn %p: ssn->client.next_seq %\"PRIu32\n                   \" (next_seq had fallen behind last_ack)\",\n                   ssn, ssn->client.next_seq);\n\n    } else {\n        SCLogDebug(\"ssn %p: no update to ssn->client.next_seq %\"PRIu32\n                   \" SEQ %u SEQ+ %u last_ack %u\",\n                   ssn, ssn->client.next_seq,\n                   TCP_GET_SEQ(p), TCP_GET_SEQ(p)+p->payload_len, ssn->client.last_ack);\n    }\n\n    /* in window check */\n    if (zerowindowprobe) {\n        SCLogDebug(\"ssn %p: zero window probe, skipping oow check\", ssn);\n    } else if (SEQ_LEQ(TCP_GET_SEQ(p) + p->payload_len, ssn->client.next_win) ||\n            (ssn->flags & (STREAMTCP_FLAG_MIDSTREAM|STREAMTCP_FLAG_ASYNC)))\n    {\n        SCLogDebug(\"ssn %p: seq %\"PRIu32\" in window, ssn->client.next_win \"\n                   \"%\" PRIu32 \"\", ssn, TCP_GET_SEQ(p), ssn->client.next_win);\n\n        ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n        SCLogDebug(\"ssn %p: ssn->server.window %\"PRIu32\"\", ssn,\n                    ssn->server.window);\n\n        /* Check if the ACK value is sane and inside the window limit */\n        if (p->tcph->th_flags & TH_ACK)\n            StreamTcpUpdateLastAck(ssn, &ssn->server, TCP_GET_ACK(p));\n        SCLogDebug(\"ack %u last_ack %u next_seq %u\", TCP_GET_ACK(p), ssn->server.last_ack, ssn->server.next_seq);\n\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            StreamTcpHandleTimestamp(ssn, p);\n        }\n\n        StreamTcpSackUpdatePacket(&ssn->server, p);\n\n        /* update next_win */\n        StreamTcpUpdateNextWin(ssn, &ssn->server, (ssn->server.last_ack + ssn->server.window));\n\n        /* handle data (if any) */\n        StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn, &ssn->client, p, pq);\n\n    } else {\n        SCLogDebug(\"ssn %p: toserver => SEQ out of window, packet SEQ \"\n                \"%\" PRIu32 \", payload size %\" PRIu32 \" (%\" PRIu32 \"),\"\n                \"ssn->client.last_ack %\" PRIu32 \", ssn->client.next_win \"\n                \"%\" PRIu32 \"(%\"PRIu32\")\", ssn, TCP_GET_SEQ(p),\n                p->payload_len, TCP_GET_SEQ(p) + p->payload_len,\n                ssn->client.last_ack, ssn->client.next_win,\n                (TCP_GET_SEQ(p) + p->payload_len) - ssn->client.next_win);\n        SCLogDebug(\"ssn %p: window %u sacked %u\", ssn, ssn->client.window,\n                StreamTcpSackedSize(&ssn->client));\n        StreamTcpSetEvent(p, STREAM_EST_PACKET_OUT_OF_WINDOW);\n        return -1;\n    }\n    return 0;\n}\n\n/**\n *  \\brief  Function to handle the TCP_ESTABLISHED state packets, which are\n *          sent by the server to client. The function handles\n *          ACK packets and call StreamTcpReassembleHandleSegment() to handle\n *          the reassembly\n *\n *  Timestamp has already been checked at this point.\n *\n *  \\param  tv      Thread Variable containing  input/output queue, cpu affinity etc.\n *  \\param  ssn     Pointer to the current TCP session\n *  \\param  p       Packet which has to be handled in this TCP state.\n *  \\param  stt     Strean Thread module registered to handle the stream handling\n */\nstatic int HandleEstablishedPacketToClient(ThreadVars *tv, TcpSession *ssn, Packet *p,\n                        StreamTcpThread *stt, PacketQueueNoLock *pq)\n{\n    SCLogDebug(\"ssn %p: =+ pkt (%\" PRIu32 \") is to client: SEQ %\" PRIu32 \",\"\n               \" ACK %\" PRIu32 \", WIN %\"PRIu16\"\", ssn, p->payload_len,\n                TCP_GET_SEQ(p), TCP_GET_ACK(p), TCP_GET_WINDOW(p));\n\n    if (StreamTcpValidateAck(ssn, &ssn->client, p) == -1) {\n        SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n        StreamTcpSetEvent(p, STREAM_EST_INVALID_ACK);\n        return -1;\n    }\n\n    /* To get the server window value from the servers packet, when connection\n       is picked up as midstream */\n    if ((ssn->flags & STREAMTCP_FLAG_MIDSTREAM) &&\n            (ssn->flags & STREAMTCP_FLAG_MIDSTREAM_ESTABLISHED))\n    {\n        ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n        ssn->server.next_win = ssn->server.last_ack + ssn->server.window;\n        ssn->flags &= ~STREAMTCP_FLAG_MIDSTREAM_ESTABLISHED;\n        SCLogDebug(\"ssn %p: adjusted midstream ssn->server.next_win to \"\n                \"%\" PRIu32 \"\", ssn, ssn->server.next_win);\n    }\n\n    /* check for Keep Alive */\n    if ((p->payload_len == 0 || p->payload_len == 1) &&\n            (TCP_GET_SEQ(p) == (ssn->server.next_seq - 1))) {\n        SCLogDebug(\"ssn %p: pkt is keep alive\", ssn);\n\n    /* normal pkt */\n    } else if (!(SEQ_GEQ((TCP_GET_SEQ(p)+p->payload_len), ssn->server.last_ack))) {\n        if (ssn->flags & STREAMTCP_FLAG_ASYNC) {\n\n            SCLogDebug(\"ssn %p: client => Asynchrouns stream, packet SEQ\"\n                    \" %\" PRIu32 \", payload size %\" PRIu32 \" (%\" PRIu32 \"),\"\n                    \" ssn->client.last_ack %\" PRIu32 \", ssn->client.next_win\"\n                    \" %\"PRIu32\"(%\"PRIu32\")\", ssn, TCP_GET_SEQ(p),\n                    p->payload_len, TCP_GET_SEQ(p) + p->payload_len,\n                    ssn->server.last_ack, ssn->server.next_win,\n                    TCP_GET_SEQ(p) + p->payload_len - ssn->server.next_win);\n\n            ssn->server.last_ack = TCP_GET_SEQ(p);\n\n        /* if last ack is beyond next_seq, we have accepted ack's for missing data.\n         * In this case we do accept the data before last_ack if it is (partly)\n         * beyond next seq */\n        } else if (SEQ_GT(ssn->server.last_ack, ssn->server.next_seq) &&\n                   SEQ_GT((TCP_GET_SEQ(p)+p->payload_len),ssn->server.next_seq))\n        {\n            SCLogDebug(\"ssn %p: PKT SEQ %\"PRIu32\" payload_len %\"PRIu16\n                    \" before last_ack %\"PRIu32\", after next_seq %\"PRIu32\":\"\n                    \" acked data that we haven't seen before\",\n                    ssn, TCP_GET_SEQ(p), p->payload_len, ssn->server.last_ack, ssn->server.next_seq);\n            if (SEQ_EQ(TCP_GET_SEQ(p),ssn->server.next_seq)) {\n                StreamTcpUpdateNextSeq(ssn, &ssn->server, (ssn->server.next_seq + p->payload_len));\n            }\n        } else {\n            SCLogDebug(\"ssn %p: PKT SEQ %\"PRIu32\" payload_len %\"PRIu16\n                    \" before last_ack %\"PRIu32\". next_seq %\"PRIu32,\n                    ssn, TCP_GET_SEQ(p), p->payload_len, ssn->server.last_ack, ssn->server.next_seq);\n            StreamTcpSetEvent(p, STREAM_EST_PKT_BEFORE_LAST_ACK);\n            return -1;\n        }\n    }\n\n    int zerowindowprobe = 0;\n    /* zero window probe */\n    if (p->payload_len == 1 && TCP_GET_SEQ(p) == ssn->server.next_seq && ssn->server.window == 0) {\n        SCLogDebug(\"ssn %p: zero window probe\", ssn);\n        zerowindowprobe = 1;\n\n    /* expected packet */\n    } else if (SEQ_EQ(ssn->server.next_seq, TCP_GET_SEQ(p))) {\n        StreamTcpUpdateNextSeq(ssn, &ssn->server, (ssn->server.next_seq + p->payload_len));\n\n    /* not completely as expected, but valid */\n    } else if (SEQ_LT(TCP_GET_SEQ(p),ssn->server.next_seq) &&\n               SEQ_GT((TCP_GET_SEQ(p)+p->payload_len), ssn->server.next_seq))\n    {\n        StreamTcpUpdateNextSeq(ssn, &ssn->server, (TCP_GET_SEQ(p) + p->payload_len));\n        SCLogDebug(\"ssn %p: ssn->server.next_seq %\" PRIu32\n                   \" (started before next_seq, ended after)\",\n                   ssn, ssn->server.next_seq);\n\n    /* if next_seq has fallen behind last_ack, we got some catching up to do */\n    } else if (SEQ_LT(ssn->server.next_seq, ssn->server.last_ack)) {\n        StreamTcpUpdateNextSeq(ssn, &ssn->server, (TCP_GET_SEQ(p) + p->payload_len));\n        SCLogDebug(\"ssn %p: ssn->server.next_seq %\"PRIu32\n                   \" (next_seq had fallen behind last_ack)\",\n                   ssn, ssn->server.next_seq);\n\n    } else {\n        SCLogDebug(\"ssn %p: no update to ssn->server.next_seq %\"PRIu32\n                   \" SEQ %u SEQ+ %u last_ack %u\",\n                   ssn, ssn->server.next_seq,\n                   TCP_GET_SEQ(p), TCP_GET_SEQ(p)+p->payload_len, ssn->server.last_ack);\n    }\n\n    if (zerowindowprobe) {\n        SCLogDebug(\"ssn %p: zero window probe, skipping oow check\", ssn);\n    } else if (SEQ_LEQ(TCP_GET_SEQ(p) + p->payload_len, ssn->server.next_win) ||\n            (ssn->flags & (STREAMTCP_FLAG_MIDSTREAM|STREAMTCP_FLAG_ASYNC)))\n    {\n        SCLogDebug(\"ssn %p: seq %\"PRIu32\" in window, ssn->server.next_win \"\n                \"%\" PRIu32 \"\", ssn, TCP_GET_SEQ(p), ssn->server.next_win);\n        ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n        SCLogDebug(\"ssn %p: ssn->client.window %\"PRIu32\"\", ssn,\n                    ssn->client.window);\n\n        if (p->tcph->th_flags & TH_ACK)\n            StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_ACK(p));\n\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            StreamTcpHandleTimestamp(ssn, p);\n        }\n\n        StreamTcpSackUpdatePacket(&ssn->client, p);\n\n        StreamTcpUpdateNextWin(ssn, &ssn->client, (ssn->client.last_ack + ssn->client.window));\n\n        StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn, &ssn->server, p, pq);\n    } else {\n        SCLogDebug(\"ssn %p: client => SEQ out of window, packet SEQ\"\n                   \"%\" PRIu32 \", payload size %\" PRIu32 \" (%\" PRIu32 \"),\"\n                   \" ssn->server.last_ack %\" PRIu32 \", ssn->server.next_win \"\n                   \"%\" PRIu32 \"(%\"PRIu32\")\", ssn, TCP_GET_SEQ(p),\n                   p->payload_len, TCP_GET_SEQ(p) + p->payload_len,\n                   ssn->server.last_ack, ssn->server.next_win,\n                   TCP_GET_SEQ(p) + p->payload_len - ssn->server.next_win);\n        StreamTcpSetEvent(p, STREAM_EST_PACKET_OUT_OF_WINDOW);\n        return -1;\n    }\n    return 0;\n}\n\n/**\n *  \\internal\n *\n *  \\brief Find the highest sequence number needed to consider all segments as ACK'd\n *\n *  Used to treat all segments as ACK'd upon receiving a valid RST.\n *\n *  \\param stream stream to inspect the segments from\n *  \\param seq sequence number to check against\n *\n *  \\retval ack highest ack we need to set\n */\nstatic inline uint32_t StreamTcpResetGetMaxAck(TcpStream *stream, uint32_t seq)\n{\n    uint32_t ack = seq;\n\n    if (STREAM_HAS_SEEN_DATA(stream)) {\n        const uint32_t tail_seq = STREAM_SEQ_RIGHT_EDGE(stream);\n        if (SEQ_GT(tail_seq, ack)) {\n            ack = tail_seq;\n        }\n    }\n\n    SCReturnUInt(ack);\n}\n\n/** \\internal\n *  \\brief check if a ACK packet is outdated so processing can be fast tracked\n *\n *  Consider a packet outdated ack if:\n *  - state is >= ESTABLISHED\n *  - ACK < last_ACK\n *  - SACK acks nothing new\n *  - packet has no data\n *  - SEQ == next_SEQ\n *  - flags has ACK set but don't contain SYN/FIN/RST\n *\n *  \\todo the most likely explanation for this packet is that we already\n *        accepted a \"newer\" ACK. We will not consider an outdated timestamp\n *        option an issue for this packet, but we should probably still\n *        check if the ts isn't too far off.\n */\nstatic bool StreamTcpPacketIsOutdatedAck(TcpSession *ssn, Packet *p)\n{\n    if (ssn->state < TCP_ESTABLISHED)\n        return false;\n    if (p->payload_len != 0)\n        return false;\n    if ((p->tcph->th_flags & (TH_ACK | TH_SYN | TH_FIN | TH_RST)) != TH_ACK)\n        return false;\n\n    /* lets see if this is a packet that is entirely eclipsed by earlier ACKs */\n    if (PKT_IS_TOSERVER(p)) {\n        if (SEQ_EQ(TCP_GET_SEQ(p), ssn->client.next_seq) &&\n                SEQ_LT(TCP_GET_ACK(p), ssn->server.last_ack)) {\n            if (!TCP_HAS_SACK(p)) {\n                SCLogDebug(\"outdated ACK (no SACK, SEQ %u vs next_seq %u)\", TCP_GET_SEQ(p),\n                        ssn->client.next_seq);\n                return true;\n            }\n\n            if (StreamTcpSackPacketIsOutdated(&ssn->server, p)) {\n                SCLogDebug(\"outdated ACK (have SACK, SEQ %u vs next_seq %u)\", TCP_GET_SEQ(p),\n                        ssn->client.next_seq);\n                return true;\n            }\n        }\n    } else {\n        if (SEQ_EQ(TCP_GET_SEQ(p), ssn->server.next_seq) &&\n                SEQ_LT(TCP_GET_ACK(p), ssn->client.last_ack)) {\n            if (!TCP_HAS_SACK(p)) {\n                SCLogDebug(\"outdated ACK (no SACK, SEQ %u vs next_seq %u)\", TCP_GET_SEQ(p),\n                        ssn->client.next_seq);\n                return true;\n            }\n\n            if (StreamTcpSackPacketIsOutdated(&ssn->client, p)) {\n                SCLogDebug(\"outdated ACK (have SACK, SEQ %u vs next_seq %u)\", TCP_GET_SEQ(p),\n                        ssn->client.next_seq);\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n/**\n *  \\brief  Function to handle the TCP_ESTABLISHED state. The function handles\n *          ACK, FIN, RST packets and correspondingly changes the connection\n *          state. The function handles the data inside packets and call\n *          StreamTcpReassembleHandleSegment(tv, ) to handle the reassembling.\n *\n *  \\param  tv      Thread Variable containing  input/output queue, cpu affinity etc.\n *  \\param  p       Packet which has to be handled in this TCP state.\n *  \\param  stt     Strean Thread module registered to handle the stream handling\n */\n\nstatic int StreamTcpPacketStateEstablished(ThreadVars *tv, Packet *p,\n        StreamTcpThread *stt, TcpSession *ssn, PacketQueueNoLock *pq)\n{\n    if (ssn == NULL)\n        return -1;\n\n    if (p->tcph->th_flags & TH_RST) {\n        if (!StreamTcpValidateRst(ssn, p))\n            return -1;\n\n        if (PKT_IS_TOSERVER(p)) {\n            StreamTcpCloseSsnWithReset(p, ssn);\n\n            ssn->server.next_seq = TCP_GET_ACK(p);\n            ssn->client.next_seq = TCP_GET_SEQ(p) + p->payload_len;\n            SCLogDebug(\"ssn %p: ssn->server.next_seq %\" PRIu32 \"\", ssn,\n                    ssn->server.next_seq);\n            ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n\n            if ((p->tcph->th_flags & TH_ACK) && StreamTcpValidateAck(ssn, &ssn->server, p) == 0)\n                StreamTcpUpdateLastAck(ssn, &ssn->server,\n                        StreamTcpResetGetMaxAck(&ssn->server, TCP_GET_ACK(p)));\n\n            StreamTcpUpdateLastAck(ssn, &ssn->client,\n                    StreamTcpResetGetMaxAck(&ssn->client, TCP_GET_SEQ(p)));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->client.next_seq,\n                    ssn->server.last_ack);\n\n            /* don't return packets to pools here just yet, the pseudo\n             * packet will take care, otherwise the normal session\n             * cleanup. */\n        } else {\n            StreamTcpCloseSsnWithReset(p, ssn);\n\n            ssn->server.next_seq = TCP_GET_SEQ(p) + p->payload_len + 1;\n            ssn->client.next_seq = TCP_GET_ACK(p);\n\n            SCLogDebug(\"ssn %p: ssn->server.next_seq %\" PRIu32 \"\", ssn,\n                    ssn->server.next_seq);\n            ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n\n            if ((p->tcph->th_flags & TH_ACK) && StreamTcpValidateAck(ssn, &ssn->client, p) == 0)\n                StreamTcpUpdateLastAck(ssn, &ssn->client,\n                        StreamTcpResetGetMaxAck(&ssn->client, TCP_GET_ACK(p)));\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server,\n                    StreamTcpResetGetMaxAck(&ssn->server, TCP_GET_SEQ(p)));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->server.next_seq,\n                    ssn->client.last_ack);\n\n            /* don't return packets to pools here just yet, the pseudo\n             * packet will take care, otherwise the normal session\n             * cleanup. */\n        }\n\n    } else if (p->tcph->th_flags & TH_FIN) {\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            if (!StreamTcpValidateTimestamp(ssn, p))\n                return -1;\n        }\n\n        SCLogDebug(\"ssn (%p: FIN received SEQ\"\n                \" %\" PRIu32 \", last ACK %\" PRIu32 \", next win %\"PRIu32\",\"\n                \" win %\" PRIu32 \"\", ssn, ssn->server.next_seq,\n                ssn->client.last_ack, ssn->server.next_win,\n                ssn->server.window);\n\n        if ((StreamTcpHandleFin(tv, stt, ssn, p, pq)) == -1)\n            return -1;\n\n    /* SYN/ACK */\n    } else if ((p->tcph->th_flags & (TH_SYN|TH_ACK)) == (TH_SYN|TH_ACK)) {\n        SCLogDebug(\"ssn %p: SYN/ACK packet on state ESTABLISHED... resent\",\n                ssn);\n\n        if (PKT_IS_TOSERVER(p)) {\n            SCLogDebug(\"ssn %p: SYN/ACK-pkt to server in ESTABLISHED state\", ssn);\n\n            StreamTcpSetEvent(p, STREAM_EST_SYNACK_TOSERVER);\n            return -1;\n        }\n\n        /* Check if the SYN/ACK packets ACK matches the earlier\n         * received SYN/ACK packet. */\n        if (!(SEQ_EQ(TCP_GET_ACK(p), ssn->client.last_ack))) {\n            SCLogDebug(\"ssn %p: ACK mismatch, packet ACK %\" PRIu32 \" != \"\n                    \"%\" PRIu32 \" from stream\", ssn, TCP_GET_ACK(p),\n                    ssn->client.isn + 1);\n\n            StreamTcpSetEvent(p, STREAM_EST_SYNACK_RESEND_WITH_DIFFERENT_ACK);\n            return -1;\n        }\n\n        /* Check if the SYN/ACK packet SEQ the earlier\n         * received SYN packet. */\n        if (!(SEQ_EQ(TCP_GET_SEQ(p), ssn->server.isn))) {\n            SCLogDebug(\"ssn %p: SEQ mismatch, packet SEQ %\" PRIu32 \" != \"\n                    \"%\" PRIu32 \" from stream\", ssn, TCP_GET_ACK(p),\n                    ssn->client.isn + 1);\n\n            StreamTcpSetEvent(p, STREAM_EST_SYNACK_RESEND_WITH_DIFF_SEQ);\n            return -1;\n        }\n\n        if (ssn->flags & STREAMTCP_FLAG_3WHS_CONFIRMED) {\n            /* a resend of a SYN while we are established already -- fishy */\n            StreamTcpSetEvent(p, STREAM_EST_SYNACK_RESEND);\n            return -1;\n        }\n\n        SCLogDebug(\"ssn %p: SYN/ACK packet on state ESTABLISHED... resent. \"\n                \"Likely due server not receiving final ACK in 3whs\", ssn);\n        return 0;\n\n    } else if (p->tcph->th_flags & TH_SYN) {\n        SCLogDebug(\"ssn %p: SYN packet on state ESTABLISHED... resent\", ssn);\n        if (PKT_IS_TOCLIENT(p)) {\n            SCLogDebug(\"ssn %p: SYN-pkt to client in EST state\", ssn);\n\n            StreamTcpSetEvent(p, STREAM_EST_SYN_TOCLIENT);\n            return -1;\n        }\n\n        if (!(SEQ_EQ(TCP_GET_SEQ(p), ssn->client.isn))) {\n            SCLogDebug(\"ssn %p: SYN with different SEQ on SYN_RECV state\", ssn);\n\n            StreamTcpSetEvent(p, STREAM_EST_SYN_RESEND_DIFF_SEQ);\n            return -1;\n        }\n\n        /* a resend of a SYN while we are established already -- fishy */\n        StreamTcpSetEvent(p, STREAM_EST_SYN_RESEND);\n        return -1;\n\n    } else if (p->tcph->th_flags & TH_ACK) {\n        /* Urgent pointer size can be more than the payload size, as it tells\n         * the future coming data from the sender will be handled urgently\n         * until data of size equal to urgent offset has been processed\n         * (RFC 2147) */\n\n        /* If the timestamp option is enabled for both the streams, then\n         * validate the received packet timestamp value against the\n         * stream->last_ts. If the timestamp is valid then process the\n         * packet normally otherwise the drop the packet (RFC 1323) */\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            if (!StreamTcpValidateTimestamp(ssn, p))\n                return -1;\n        }\n\n        if (PKT_IS_TOSERVER(p)) {\n            /* Process the received packet to server */\n            HandleEstablishedPacketToServer(tv, ssn, p, stt, pq);\n\n            SCLogDebug(\"ssn %p: next SEQ %\" PRIu32 \", last ACK %\" PRIu32 \",\"\n                    \" next win %\" PRIu32 \", win %\" PRIu32 \"\", ssn,\n                    ssn->client.next_seq, ssn->server.last_ack\n                    ,ssn->client.next_win, ssn->client.window);\n\n        } else { /* implied to client */\n            if (!(ssn->flags & STREAMTCP_FLAG_3WHS_CONFIRMED)) {\n                ssn->flags |= STREAMTCP_FLAG_3WHS_CONFIRMED;\n                SCLogDebug(\"3whs is now confirmed by server\");\n            }\n\n            /* Process the received packet to client */\n            HandleEstablishedPacketToClient(tv, ssn, p, stt, pq);\n\n            SCLogDebug(\"ssn %p: next SEQ %\" PRIu32 \", last ACK %\" PRIu32 \",\"\n                    \" next win %\" PRIu32 \", win %\" PRIu32 \"\", ssn,\n                    ssn->server.next_seq, ssn->client.last_ack,\n                    ssn->server.next_win, ssn->server.window);\n        }\n    } else {\n        SCLogDebug(\"ssn %p: default case\", ssn);\n    }\n\n    return 0;\n}\n\n/**\n *  \\brief  Function to handle the FIN packets for states TCP_SYN_RECV and\n *          TCP_ESTABLISHED and changes to another TCP state as required.\n *\n *  \\param  tv      Thread Variable containing  input/output queue, cpu affinity\n *  \\param  p       Packet which has to be handled in this TCP state.\n *  \\param  stt     Strean Thread module registered to handle the stream handling\n *\n *  \\retval 0 success\n *  \\retval -1 something wrong with the packet\n */\n\nstatic int StreamTcpHandleFin(ThreadVars *tv, StreamTcpThread *stt,\n                                TcpSession *ssn, Packet *p, PacketQueueNoLock *pq)\n{\n    if (PKT_IS_TOSERVER(p)) {\n        SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to server: SEQ %\" PRIu32 \",\"\n                \" ACK %\" PRIu32 \"\", ssn, p->payload_len, TCP_GET_SEQ(p),\n                TCP_GET_ACK(p));\n\n        if (StreamTcpValidateAck(ssn, &ssn->server, p) == -1) {\n            SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n            StreamTcpSetEvent(p, STREAM_FIN_INVALID_ACK);\n            return -1;\n        }\n\n        if (SEQ_LT(TCP_GET_SEQ(p), ssn->client.next_seq) ||\n            SEQ_GT(TCP_GET_SEQ(p), (ssn->client.last_ack + ssn->client.window)))\n        {\n            SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \" != \"\n                    \"%\" PRIu32 \" from stream\", ssn, TCP_GET_SEQ(p),\n                    ssn->client.next_seq);\n\n            StreamTcpSetEvent(p, STREAM_FIN_OUT_OF_WINDOW);\n            return -1;\n        }\n\n        StreamTcpPacketSetState(p, ssn, TCP_CLOSE_WAIT);\n        SCLogDebug(\"ssn %p: state changed to TCP_CLOSE_WAIT\", ssn);\n\n        if (SEQ_EQ(TCP_GET_SEQ(p), ssn->client.next_seq))\n            ssn->client.next_seq = TCP_GET_SEQ(p) + p->payload_len;\n\n        SCLogDebug(\"ssn %p: ssn->client.next_seq %\" PRIu32 \"\", ssn,\n                    ssn->client.next_seq);\n        ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n\n        if (p->tcph->th_flags & TH_ACK)\n            StreamTcpUpdateLastAck(ssn, &ssn->server, TCP_GET_ACK(p));\n\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            StreamTcpHandleTimestamp(ssn, p);\n        }\n\n        /* Update the next_seq, in case if we have missed the client packet\n           and server has already received and acked it */\n        if (SEQ_LT(ssn->server.next_seq, TCP_GET_ACK(p)))\n            ssn->server.next_seq = TCP_GET_ACK(p);\n\n        StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn, &ssn->client, p, pq);\n\n        SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK %\" PRIu32 \"\",\n                ssn, ssn->client.next_seq, ssn->server.last_ack);\n    } else { /* implied to client */\n        SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to client: SEQ %\" PRIu32 \", \"\n                   \"ACK %\" PRIu32 \"\", ssn, p->payload_len, TCP_GET_SEQ(p),\n                    TCP_GET_ACK(p));\n\n        if (StreamTcpValidateAck(ssn, &ssn->client, p) == -1) {\n            SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n            StreamTcpSetEvent(p, STREAM_FIN_INVALID_ACK);\n            return -1;\n        }\n\n        if (SEQ_LT(TCP_GET_SEQ(p), ssn->server.next_seq) ||\n                SEQ_GT(TCP_GET_SEQ(p), (ssn->server.last_ack + ssn->server.window)))\n        {\n            SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \" != \"\n                    \"%\" PRIu32 \" from stream (last_ack %u win %u = %u)\", ssn, TCP_GET_SEQ(p),\n                    ssn->server.next_seq, ssn->server.last_ack, ssn->server.window, (ssn->server.last_ack + ssn->server.window));\n\n            StreamTcpSetEvent(p, STREAM_FIN_OUT_OF_WINDOW);\n            return -1;\n        }\n\n        StreamTcpPacketSetState(p, ssn, TCP_FIN_WAIT1);\n        SCLogDebug(\"ssn %p: state changed to TCP_FIN_WAIT1\", ssn);\n\n        if (SEQ_EQ(TCP_GET_SEQ(p), ssn->server.next_seq))\n            ssn->server.next_seq = TCP_GET_SEQ(p) + p->payload_len;\n\n        SCLogDebug(\"ssn %p: ssn->server.next_seq %\" PRIu32 \"\", ssn,\n                    ssn->server.next_seq);\n        ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n\n        if (p->tcph->th_flags & TH_ACK)\n            StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_ACK(p));\n\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            StreamTcpHandleTimestamp(ssn, p);\n        }\n\n        /* Update the next_seq, in case if we have missed the client packet\n           and server has already received and acked it */\n        if (SEQ_LT(ssn->client.next_seq, TCP_GET_ACK(p)))\n            ssn->client.next_seq = TCP_GET_ACK(p);\n\n        StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn, &ssn->server, p, pq);\n\n        SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK %\" PRIu32 \"\",\n                ssn, ssn->server.next_seq, ssn->client.last_ack);\n    }\n\n    return 0;\n}\n\n/**\n *  \\brief  Function to handle the TCP_FIN_WAIT1 state. The function handles\n *          ACK, FIN, RST packets and correspondingly changes the connection\n *          state.\n *\n *  \\param  tv      Thread Variable containing  input/output queue, cpu affinity\n *  \\param  p       Packet which has to be handled in this TCP state.\n *  \\param  stt     Strean Thread module registered to handle the stream handling\n *\n *  \\retval 0 success\n *  \\retval -1 something wrong with the packet\n */\n\nstatic int StreamTcpPacketStateFinWait1(ThreadVars *tv, Packet *p,\n        StreamTcpThread *stt, TcpSession *ssn, PacketQueueNoLock *pq)\n{\n    if (ssn == NULL)\n        return -1;\n\n    if (p->tcph->th_flags & TH_RST) {\n        if (!StreamTcpValidateRst(ssn, p))\n            return -1;\n\n        StreamTcpCloseSsnWithReset(p, ssn);\n\n        if (PKT_IS_TOSERVER(p)) {\n            if ((p->tcph->th_flags & TH_ACK) && StreamTcpValidateAck(ssn, &ssn->server, p) == 0)\n                StreamTcpUpdateLastAck(ssn, &ssn->server,\n                        StreamTcpResetGetMaxAck(&ssn->server, TCP_GET_ACK(p)));\n\n            StreamTcpUpdateLastAck(ssn, &ssn->client,\n                    StreamTcpResetGetMaxAck(&ssn->client, TCP_GET_SEQ(p)));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n        } else {\n            if ((p->tcph->th_flags & TH_ACK) && StreamTcpValidateAck(ssn, &ssn->client, p) == 0)\n                StreamTcpUpdateLastAck(ssn, &ssn->client,\n                        StreamTcpResetGetMaxAck(&ssn->client, TCP_GET_ACK(p)));\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server,\n                    StreamTcpResetGetMaxAck(&ssn->server, TCP_GET_SEQ(p)));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n        }\n\n    } else if ((p->tcph->th_flags & (TH_FIN|TH_ACK)) == (TH_FIN|TH_ACK)) {\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            if (!StreamTcpValidateTimestamp(ssn, p))\n                return -1;\n        }\n\n        if (PKT_IS_TOSERVER(p)) {\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to server: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n            int retransmission = 0;\n\n            if (StreamTcpPacketIsRetransmission(&ssn->client, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n\n            } else if (SEQ_LT(TCP_GET_SEQ(p), ssn->client.next_seq) ||\n                    SEQ_GT(TCP_GET_SEQ(p), (ssn->client.last_ack + ssn->client.window)))\n            {\n                SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                        \" != %\" PRIu32 \" from stream\", ssn,\n                        TCP_GET_SEQ(p), ssn->client.next_seq);\n                StreamTcpSetEvent(p, STREAM_FIN1_FIN_WRONG_SEQ);\n                return -1;\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->server, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_FIN1_INVALID_ACK);\n                return -1;\n            }\n\n            if (!retransmission) {\n                StreamTcpPacketSetState(p, ssn, TCP_TIME_WAIT);\n                SCLogDebug(\"ssn %p: state changed to TCP_TIME_WAIT\", ssn);\n\n                ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->server.next_seq, TCP_GET_ACK(p)))\n                ssn->server.next_seq = TCP_GET_ACK(p);\n\n            if (SEQ_EQ(ssn->client.next_seq, TCP_GET_SEQ(p))) {\n                StreamTcpUpdateNextSeq(ssn, &ssn->client, (ssn->client.next_seq + p->payload_len));\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->client.next_seq,\n                    ssn->server.last_ack);\n        } else { /* implied to client */\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to client: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n            int retransmission = 0;\n\n            if (StreamTcpPacketIsRetransmission(&ssn->server, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n            } else if (SEQ_EQ(ssn->server.next_seq, TCP_GET_SEQ(p)) &&\n                       SEQ_EQ(ssn->client.last_ack, TCP_GET_ACK(p))) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n\n            } else if (SEQ_LT(TCP_GET_SEQ(p), ssn->server.next_seq) ||\n                       SEQ_GT(TCP_GET_SEQ(p), (ssn->server.last_ack + ssn->server.window))) {\n                SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                        \" != %\" PRIu32 \" from stream\", ssn,\n                        TCP_GET_SEQ(p), ssn->server.next_seq);\n                StreamTcpSetEvent(p, STREAM_FIN1_FIN_WRONG_SEQ);\n                return -1;\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->client, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_FIN1_INVALID_ACK);\n                return -1;\n            }\n\n            if (!retransmission) {\n                StreamTcpPacketSetState(p, ssn, TCP_TIME_WAIT);\n                SCLogDebug(\"ssn %p: state changed to TCP_TIME_WAIT\", ssn);\n\n                ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->client.next_seq, TCP_GET_ACK(p)))\n                ssn->client.next_seq = TCP_GET_ACK(p);\n\n            if (SEQ_EQ(ssn->server.next_seq, TCP_GET_SEQ(p))) {\n                StreamTcpUpdateNextSeq(ssn, &ssn->server, (ssn->server.next_seq + p->payload_len));\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->server.next_seq,\n                    ssn->client.last_ack);\n        }\n\n    } else if (p->tcph->th_flags & TH_FIN) {\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            if (!StreamTcpValidateTimestamp(ssn, p))\n                return -1;\n        }\n\n        if (PKT_IS_TOSERVER(p)) {\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to server: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n            int retransmission = 0;\n\n            if (StreamTcpPacketIsRetransmission(&ssn->client, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n\n            } else if (SEQ_LT(TCP_GET_SEQ(p), ssn->client.next_seq) ||\n                    SEQ_GT(TCP_GET_SEQ(p), (ssn->client.last_ack + ssn->client.window)))\n            {\n                SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                        \" != %\" PRIu32 \" from stream\", ssn,\n                        TCP_GET_SEQ(p), ssn->client.next_seq);\n                StreamTcpSetEvent(p, STREAM_FIN1_FIN_WRONG_SEQ);\n                return -1;\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->server, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_FIN1_INVALID_ACK);\n                return -1;\n            }\n\n            if (!retransmission) {\n                StreamTcpPacketSetState(p, ssn, TCP_CLOSING);\n                SCLogDebug(\"ssn %p: state changed to TCP_CLOSING\", ssn);\n\n                ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n            }\n\n            if (p->tcph->th_flags & TH_ACK)\n                StreamTcpUpdateLastAck(ssn, &ssn->server, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->server.next_seq, TCP_GET_ACK(p)))\n                ssn->server.next_seq = TCP_GET_ACK(p);\n\n            if (SEQ_EQ(ssn->client.next_seq, TCP_GET_SEQ(p))) {\n                StreamTcpUpdateNextSeq(ssn, &ssn->client, (ssn->client.next_seq + p->payload_len));\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->client.next_seq,\n                    ssn->server.last_ack);\n        } else { /* implied to client */\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to client: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n\n            int retransmission = 0;\n\n            if (StreamTcpPacketIsRetransmission(&ssn->server, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n\n            } else if (SEQ_LT(TCP_GET_SEQ(p), ssn->server.next_seq) ||\n                    SEQ_GT(TCP_GET_SEQ(p), (ssn->server.last_ack + ssn->server.window)))\n            {\n                SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                        \" != %\" PRIu32 \" from stream\", ssn,\n                        TCP_GET_SEQ(p), ssn->server.next_seq);\n                StreamTcpSetEvent(p, STREAM_FIN1_FIN_WRONG_SEQ);\n                return -1;\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->client, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_FIN1_INVALID_ACK);\n                return -1;\n            }\n\n            if (!retransmission) {\n                StreamTcpPacketSetState(p, ssn, TCP_CLOSING);\n                SCLogDebug(\"ssn %p: state changed to TCP_CLOSING\", ssn);\n\n                ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n            }\n\n            if (p->tcph->th_flags & TH_ACK)\n                StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->client.next_seq, TCP_GET_ACK(p)))\n                ssn->client.next_seq = TCP_GET_ACK(p);\n\n            if (SEQ_EQ(ssn->server.next_seq, TCP_GET_SEQ(p))) {\n                StreamTcpUpdateNextSeq(ssn, &ssn->server, (ssn->server.next_seq + p->payload_len));\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->server.next_seq,\n                    ssn->client.last_ack);\n        }\n    } else if (p->tcph->th_flags & TH_SYN) {\n        SCLogDebug(\"ssn (%p): SYN pkt on FinWait1\", ssn);\n        StreamTcpSetEvent(p, STREAM_SHUTDOWN_SYN_RESEND);\n        return -1;\n\n    } else if (p->tcph->th_flags & TH_ACK) {\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            if (!StreamTcpValidateTimestamp(ssn, p))\n                return -1;\n        }\n\n        if (PKT_IS_TOSERVER(p)) {\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to server: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n            int retransmission = 0;\n\n            if (StreamTcpPacketIsRetransmission(&ssn->client, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->server, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_FIN1_INVALID_ACK);\n                return -1;\n            }\n\n            if (!retransmission) {\n                if (SEQ_LEQ(TCP_GET_SEQ(p) + p->payload_len, ssn->client.next_win) ||\n                        (ssn->flags & (STREAMTCP_FLAG_MIDSTREAM|STREAMTCP_FLAG_ASYNC)))\n                {\n                    SCLogDebug(\"ssn %p: seq %\"PRIu32\" in window, ssn->client.next_win \"\n                            \"%\" PRIu32 \"\", ssn, TCP_GET_SEQ(p), ssn->client.next_win);\n\n                    if (TCP_GET_SEQ(p) == ssn->client.next_seq) {\n                        StreamTcpPacketSetState(p, ssn, TCP_FIN_WAIT2);\n                        SCLogDebug(\"ssn %p: state changed to TCP_FIN_WAIT2\", ssn);\n                    }\n                } else {\n                    SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                            \" != %\" PRIu32 \" from stream\", ssn,\n                            TCP_GET_SEQ(p), ssn->client.next_seq);\n\n                    StreamTcpSetEvent(p, STREAM_FIN1_ACK_WRONG_SEQ);\n                    return -1;\n                }\n\n                ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->server.next_seq, TCP_GET_ACK(p)))\n                ssn->server.next_seq = TCP_GET_ACK(p);\n\n            if (SEQ_EQ(ssn->client.next_seq, TCP_GET_SEQ(p))) {\n                StreamTcpUpdateNextSeq(ssn, &ssn->client, (ssn->client.next_seq + p->payload_len));\n            }\n\n            StreamTcpSackUpdatePacket(&ssn->server, p);\n\n            /* update next_win */\n            StreamTcpUpdateNextWin(ssn, &ssn->server, (ssn->server.last_ack + ssn->server.window));\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->client.next_seq,\n                    ssn->server.last_ack);\n\n        } else { /* implied to client */\n\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to client: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n\n            int retransmission = 0;\n\n            if (StreamTcpPacketIsRetransmission(&ssn->server, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->client, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_FIN1_INVALID_ACK);\n                return -1;\n            }\n\n            if (!retransmission) {\n                if (SEQ_LEQ(TCP_GET_SEQ(p) + p->payload_len, ssn->server.next_win) ||\n                        (ssn->flags & (STREAMTCP_FLAG_MIDSTREAM|STREAMTCP_FLAG_ASYNC)))\n                {\n                    SCLogDebug(\"ssn %p: seq %\"PRIu32\" in window, ssn->server.next_win \"\n                            \"%\" PRIu32 \"\", ssn, TCP_GET_SEQ(p), ssn->server.next_win);\n\n                    if (TCP_GET_SEQ(p) == ssn->server.next_seq) {\n                        StreamTcpPacketSetState(p, ssn, TCP_FIN_WAIT2);\n                        SCLogDebug(\"ssn %p: state changed to TCP_FIN_WAIT2\", ssn);\n                    }\n                } else {\n                    SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                            \" != %\" PRIu32 \" from stream\", ssn,\n                            TCP_GET_SEQ(p), ssn->server.next_seq);\n                    StreamTcpSetEvent(p, STREAM_FIN1_ACK_WRONG_SEQ);\n                    return -1;\n                }\n\n                ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->client.next_seq, TCP_GET_ACK(p)))\n                ssn->client.next_seq = TCP_GET_ACK(p);\n\n            if (SEQ_EQ(ssn->server.next_seq, TCP_GET_SEQ(p))) {\n                StreamTcpUpdateNextSeq(ssn, &ssn->server, (ssn->server.next_seq + p->payload_len));\n            }\n\n            StreamTcpSackUpdatePacket(&ssn->client, p);\n\n            /* update next_win */\n            StreamTcpUpdateNextWin(ssn, &ssn->client, (ssn->client.last_ack + ssn->client.window));\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->server.next_seq,\n                    ssn->client.last_ack);\n        }\n    } else {\n        SCLogDebug(\"ssn (%p): default case\", ssn);\n    }\n\n    return 0;\n}\n\n/**\n *  \\brief  Function to handle the TCP_FIN_WAIT2 state. The function handles\n *          ACK, RST, FIN packets and correspondingly changes the connection\n *          state.\n *\n *  \\param  tv      Thread Variable containing  input/output queue, cpu affinity\n *  \\param  p       Packet which has to be handled in this TCP state.\n *  \\param  stt     Strean Thread module registered to handle the stream handling\n */\n\nstatic int StreamTcpPacketStateFinWait2(ThreadVars *tv, Packet *p,\n        StreamTcpThread *stt, TcpSession *ssn, PacketQueueNoLock *pq)\n{\n    if (ssn == NULL)\n        return -1;\n\n    if (p->tcph->th_flags & TH_RST) {\n        if (!StreamTcpValidateRst(ssn, p))\n            return -1;\n\n        StreamTcpCloseSsnWithReset(p, ssn);\n\n        if (PKT_IS_TOSERVER(p)) {\n            if ((p->tcph->th_flags & TH_ACK) && StreamTcpValidateAck(ssn, &ssn->server, p) == 0)\n                StreamTcpUpdateLastAck(ssn, &ssn->server,\n                        StreamTcpResetGetMaxAck(&ssn->server, TCP_GET_ACK(p)));\n\n            StreamTcpUpdateLastAck(ssn, &ssn->client,\n                    StreamTcpResetGetMaxAck(&ssn->client, TCP_GET_SEQ(p)));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n        } else {\n            if ((p->tcph->th_flags & TH_ACK) && StreamTcpValidateAck(ssn, &ssn->client, p) == 0)\n                StreamTcpUpdateLastAck(ssn, &ssn->client,\n                        StreamTcpResetGetMaxAck(&ssn->client, TCP_GET_ACK(p)));\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server,\n                    StreamTcpResetGetMaxAck(&ssn->server, TCP_GET_SEQ(p)));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n        }\n\n    } else if (p->tcph->th_flags & TH_FIN) {\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            if (!StreamTcpValidateTimestamp(ssn, p))\n                return -1;\n        }\n\n        if (PKT_IS_TOSERVER(p)) {\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to server: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n            int retransmission = 0;\n\n            if (SEQ_EQ(TCP_GET_SEQ(p), ssn->client.next_seq - 1) &&\n                SEQ_EQ(TCP_GET_ACK(p), ssn->server.last_ack)) {\n                SCLogDebug(\"ssn %p: retransmission\", ssn);\n                retransmission = 1;\n            } else if (StreamTcpPacketIsRetransmission(&ssn->client, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n\n            } else if (SEQ_LT(TCP_GET_SEQ(p), ssn->client.next_seq) ||\n                    SEQ_GT(TCP_GET_SEQ(p), (ssn->client.last_ack + ssn->client.window)))\n            {\n                SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ \"\n                        \"%\" PRIu32 \" != %\" PRIu32 \" from stream\", ssn,\n                        TCP_GET_SEQ(p), ssn->client.next_seq);\n                StreamTcpSetEvent(p, STREAM_FIN2_FIN_WRONG_SEQ);\n                return -1;\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->server, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_FIN2_INVALID_ACK);\n                return -1;\n            }\n\n            if (!retransmission) {\n                StreamTcpPacketSetState(p, ssn, TCP_TIME_WAIT);\n                SCLogDebug(\"ssn %p: state changed to TCP_TIME_WAIT\", ssn);\n\n                if (SEQ_EQ(ssn->client.next_seq, TCP_GET_SEQ(p))) {\n                    StreamTcpUpdateNextSeq(\n                            ssn, &ssn->client, (ssn->client.next_seq + p->payload_len));\n                }\n                ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n            }\n\n            if (p->tcph->th_flags & TH_ACK)\n                StreamTcpUpdateLastAck(ssn, &ssn->server, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->server.next_seq, TCP_GET_ACK(p)))\n                ssn->server.next_seq = TCP_GET_ACK(p);\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->client.next_seq,\n                    ssn->server.last_ack);\n        } else { /* implied to client */\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to client: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n            int retransmission = 0;\n\n            if (SEQ_EQ(TCP_GET_SEQ(p), ssn->server.next_seq - 1) &&\n                SEQ_EQ(TCP_GET_ACK(p), ssn->client.last_ack)) {\n                SCLogDebug(\"ssn %p: retransmission\", ssn);\n                retransmission = 1;\n            } else if (StreamTcpPacketIsRetransmission(&ssn->server, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n\n            } else if (SEQ_LT(TCP_GET_SEQ(p), ssn->server.next_seq) ||\n                    SEQ_GT(TCP_GET_SEQ(p), (ssn->server.last_ack + ssn->server.window)))\n            {\n                SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ \"\n                        \"%\" PRIu32 \" != %\" PRIu32 \" from stream\", ssn,\n                        TCP_GET_SEQ(p), ssn->server.next_seq);\n                StreamTcpSetEvent(p, STREAM_FIN2_FIN_WRONG_SEQ);\n                return -1;\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->client, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_FIN2_INVALID_ACK);\n                return -1;\n            }\n\n            if (!retransmission) {\n                StreamTcpPacketSetState(p, ssn, TCP_TIME_WAIT);\n                SCLogDebug(\"ssn %p: state changed to TCP_TIME_WAIT\", ssn);\n\n                ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n            }\n\n            if (p->tcph->th_flags & TH_ACK)\n                StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->client.next_seq, TCP_GET_ACK(p)))\n                ssn->client.next_seq = TCP_GET_ACK(p);\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->server.next_seq,\n                    ssn->client.last_ack);\n        }\n\n    } else if (p->tcph->th_flags & TH_SYN) {\n        SCLogDebug(\"ssn (%p): SYN pkt on FinWait2\", ssn);\n        StreamTcpSetEvent(p, STREAM_SHUTDOWN_SYN_RESEND);\n        return -1;\n\n    } else if (p->tcph->th_flags & TH_ACK) {\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            if (!StreamTcpValidateTimestamp(ssn, p))\n                return -1;\n        }\n\n        if (PKT_IS_TOSERVER(p)) {\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to server: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n            int retransmission = 0;\n\n            if (StreamTcpPacketIsRetransmission(&ssn->client, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->server, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_FIN2_INVALID_ACK);\n                return -1;\n            }\n\n            if (!retransmission) {\n                if (SEQ_LEQ(TCP_GET_SEQ(p) + p->payload_len, ssn->client.next_win) ||\n                        (ssn->flags & (STREAMTCP_FLAG_MIDSTREAM|STREAMTCP_FLAG_ASYNC)))\n                {\n                    SCLogDebug(\"ssn %p: seq %\"PRIu32\" in window, ssn->client.next_win \"\n                            \"%\" PRIu32 \"\", ssn, TCP_GET_SEQ(p), ssn->client.next_win);\n\n                } else {\n                    SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                            \" != %\" PRIu32 \" from stream\", ssn,\n                            TCP_GET_SEQ(p), ssn->client.next_seq);\n                    StreamTcpSetEvent(p, STREAM_FIN2_ACK_WRONG_SEQ);\n                    return -1;\n                }\n\n                ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            if (SEQ_EQ(ssn->client.next_seq, TCP_GET_SEQ(p))) {\n                StreamTcpUpdateNextSeq(ssn, &ssn->client, (ssn->client.next_seq + p->payload_len));\n            }\n\n            StreamTcpSackUpdatePacket(&ssn->server, p);\n\n            /* update next_win */\n            StreamTcpUpdateNextWin(ssn, &ssn->server, (ssn->server.last_ack + ssn->server.window));\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->client.next_seq,\n                    ssn->server.last_ack);\n        } else { /* implied to client */\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to client: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n            int retransmission = 0;\n\n            if (StreamTcpPacketIsRetransmission(&ssn->server, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->client, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_FIN2_INVALID_ACK);\n                return -1;\n            }\n\n            if (!retransmission) {\n                if (SEQ_LEQ(TCP_GET_SEQ(p) + p->payload_len, ssn->server.next_win) ||\n                        (ssn->flags & (STREAMTCP_FLAG_MIDSTREAM|STREAMTCP_FLAG_ASYNC)))\n                {\n                    SCLogDebug(\"ssn %p: seq %\"PRIu32\" in window, ssn->server.next_win \"\n                            \"%\" PRIu32 \"\", ssn, TCP_GET_SEQ(p), ssn->server.next_win);\n                } else {\n                    SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                            \" != %\" PRIu32 \" from stream\", ssn,\n                            TCP_GET_SEQ(p), ssn->server.next_seq);\n                    StreamTcpSetEvent(p, STREAM_FIN2_ACK_WRONG_SEQ);\n                    return -1;\n                }\n\n                ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            if (SEQ_EQ(ssn->server.next_seq, TCP_GET_SEQ(p))) {\n                StreamTcpUpdateNextSeq(ssn, &ssn->server, (ssn->server.next_seq + p->payload_len));\n            }\n\n            StreamTcpSackUpdatePacket(&ssn->client, p);\n\n            /* update next_win */\n            StreamTcpUpdateNextWin(ssn, &ssn->client, (ssn->client.last_ack + ssn->client.window));\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->server.next_seq,\n                    ssn->client.last_ack);\n        }\n    } else {\n        SCLogDebug(\"ssn %p: default case\", ssn);\n    }\n\n    return 0;\n}\n\n/**\n *  \\brief  Function to handle the TCP_CLOSING state. Upon arrival of ACK\n *          the connection goes to TCP_TIME_WAIT state. The state has been\n *          reached as both end application has been closed.\n *\n *  \\param  tv      Thread Variable containing  input/output queue, cpu affinity\n *  \\param  p       Packet which has to be handled in this TCP state.\n *  \\param  stt     Strean Thread module registered to handle the stream handling\n */\n\nstatic int StreamTcpPacketStateClosing(ThreadVars *tv, Packet *p,\n        StreamTcpThread *stt, TcpSession *ssn, PacketQueueNoLock *pq)\n{\n    if (ssn == NULL)\n        return -1;\n\n    if (p->tcph->th_flags & TH_RST) {\n        if (!StreamTcpValidateRst(ssn, p))\n            return -1;\n\n        StreamTcpCloseSsnWithReset(p, ssn);\n\n        if (PKT_IS_TOSERVER(p)) {\n            if ((p->tcph->th_flags & TH_ACK) && StreamTcpValidateAck(ssn, &ssn->server, p) == 0)\n                StreamTcpUpdateLastAck(ssn, &ssn->server,\n                        StreamTcpResetGetMaxAck(&ssn->server, TCP_GET_ACK(p)));\n\n            StreamTcpUpdateLastAck(ssn, &ssn->client,\n                    StreamTcpResetGetMaxAck(&ssn->client, TCP_GET_SEQ(p)));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n        } else {\n            if ((p->tcph->th_flags & TH_ACK) && StreamTcpValidateAck(ssn, &ssn->client, p) == 0)\n                StreamTcpUpdateLastAck(ssn, &ssn->client,\n                        StreamTcpResetGetMaxAck(&ssn->client, TCP_GET_ACK(p)));\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server,\n                    StreamTcpResetGetMaxAck(&ssn->server, TCP_GET_SEQ(p)));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n        }\n\n    } else if (p->tcph->th_flags & TH_SYN) {\n        SCLogDebug(\"ssn (%p): SYN pkt on Closing\", ssn);\n        StreamTcpSetEvent(p, STREAM_SHUTDOWN_SYN_RESEND);\n        return -1;\n\n    } else if (p->tcph->th_flags & TH_ACK) {\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            if (!StreamTcpValidateTimestamp(ssn, p))\n                return -1;\n        }\n\n        if (PKT_IS_TOSERVER(p)) {\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to server: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n            int retransmission = 0;\n            if (StreamTcpPacketIsRetransmission(&ssn->client, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n            }\n\n            if (TCP_GET_SEQ(p) != ssn->client.next_seq) {\n                SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                        \" != %\" PRIu32 \" from stream\", ssn,\n                        TCP_GET_SEQ(p), ssn->client.next_seq);\n                StreamTcpSetEvent(p, STREAM_CLOSING_ACK_WRONG_SEQ);\n                return -1;\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->server, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_CLOSING_INVALID_ACK);\n                return -1;\n            }\n\n            if (!retransmission) {\n                StreamTcpPacketSetState(p, ssn, TCP_TIME_WAIT);\n                SCLogDebug(\"ssn %p: state changed to TCP_TIME_WAIT\", ssn);\n\n                ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->server.next_seq, TCP_GET_ACK(p)))\n                ssn->server.next_seq = TCP_GET_ACK(p);\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->client.next_seq,\n                    ssn->server.last_ack);\n        } else { /* implied to client */\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to client: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n            int retransmission = 0;\n            if (StreamTcpPacketIsRetransmission(&ssn->server, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n            }\n\n            if (TCP_GET_SEQ(p) != ssn->server.next_seq) {\n                SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                        \" != %\" PRIu32 \" from stream\", ssn,\n                        TCP_GET_SEQ(p), ssn->server.next_seq);\n                StreamTcpSetEvent(p, STREAM_CLOSING_ACK_WRONG_SEQ);\n                return -1;\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->client, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_CLOSING_INVALID_ACK);\n                return -1;\n            }\n\n            if (!retransmission) {\n                StreamTcpPacketSetState(p, ssn, TCP_TIME_WAIT);\n                SCLogDebug(\"ssn %p: state changed to TCP_TIME_WAIT\", ssn);\n\n                ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->client.next_seq, TCP_GET_ACK(p)))\n                ssn->client.next_seq = TCP_GET_ACK(p);\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n            SCLogDebug(\"StreamTcpPacketStateClosing (%p): =+ next SEQ \"\n                    \"%\" PRIu32 \", last ACK %\" PRIu32 \"\", ssn,\n                    ssn->server.next_seq, ssn->client.last_ack);\n        }\n    } else {\n        SCLogDebug(\"ssn %p: default case\", ssn);\n    }\n\n    return 0;\n}\n\n/**\n *  \\brief  Function to handle the TCP_CLOSE_WAIT state. Upon arrival of FIN\n *          packet from server the connection goes to TCP_LAST_ACK state.\n *          The state is possible only for server host.\n *\n *  \\param  tv      Thread Variable containing  input/output queue, cpu affinity\n *  \\param  p       Packet which has to be handled in this TCP state.\n *  \\param  stt     Strean Thread module registered to handle the stream handling\n */\n\nstatic int StreamTcpPacketStateCloseWait(ThreadVars *tv, Packet *p,\n        StreamTcpThread *stt, TcpSession *ssn, PacketQueueNoLock *pq)\n{\n    SCEnter();\n\n    if (ssn == NULL) {\n        SCReturnInt(-1);\n    }\n\n    if (PKT_IS_TOCLIENT(p)) {\n        SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to client: SEQ \"\n                \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                TCP_GET_SEQ(p), TCP_GET_ACK(p));\n    } else {\n        SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to server: SEQ \"\n                \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                TCP_GET_SEQ(p), TCP_GET_ACK(p));\n    }\n\n    if (p->tcph->th_flags & TH_RST) {\n        if (!StreamTcpValidateRst(ssn, p))\n            return -1;\n\n        StreamTcpCloseSsnWithReset(p, ssn);\n\n        if (PKT_IS_TOSERVER(p)) {\n            if ((p->tcph->th_flags & TH_ACK) && StreamTcpValidateAck(ssn, &ssn->server, p) == 0)\n                StreamTcpUpdateLastAck(ssn, &ssn->server,\n                        StreamTcpResetGetMaxAck(&ssn->server, TCP_GET_ACK(p)));\n\n            StreamTcpUpdateLastAck(ssn, &ssn->client,\n                    StreamTcpResetGetMaxAck(&ssn->client, TCP_GET_SEQ(p)));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n        } else {\n            if ((p->tcph->th_flags & TH_ACK) && StreamTcpValidateAck(ssn, &ssn->client, p) == 0)\n                StreamTcpUpdateLastAck(ssn, &ssn->client,\n                        StreamTcpResetGetMaxAck(&ssn->client, TCP_GET_ACK(p)));\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server,\n                    StreamTcpResetGetMaxAck(&ssn->server, TCP_GET_SEQ(p)));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n        }\n\n    } else if (p->tcph->th_flags & TH_FIN) {\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            if (!StreamTcpValidateTimestamp(ssn, p))\n                SCReturnInt(-1);\n        }\n\n        if (PKT_IS_TOSERVER(p)) {\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to server: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n\n            int retransmission = 0;\n            if (StreamTcpPacketIsRetransmission(&ssn->client, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n            }\n\n            if (!retransmission) {\n                if (SEQ_LT(TCP_GET_SEQ(p), ssn->client.next_seq) ||\n                        SEQ_GT(TCP_GET_SEQ(p), (ssn->client.last_ack + ssn->client.window)))\n                {\n                    SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                            \" != %\" PRIu32 \" from stream\", ssn,\n                            TCP_GET_SEQ(p), ssn->client.next_seq);\n                    StreamTcpSetEvent(p, STREAM_CLOSEWAIT_FIN_OUT_OF_WINDOW);\n                    SCReturnInt(-1);\n                }\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->server, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_CLOSEWAIT_INVALID_ACK);\n                SCReturnInt(-1);\n            }\n\n            /* don't update to LAST_ACK here as we want a toclient FIN for that */\n\n            if (!retransmission)\n                ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n\n            if (p->tcph->th_flags & TH_ACK)\n                StreamTcpUpdateLastAck(ssn, &ssn->server, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->server.next_seq, TCP_GET_ACK(p)))\n                ssn->server.next_seq = TCP_GET_ACK(p);\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->client.next_seq,\n                    ssn->server.last_ack);\n        } else {\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to client: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n\n            int retransmission = 0;\n            if (StreamTcpPacketIsRetransmission(&ssn->server, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n            }\n\n            if (!retransmission) {\n                if (SEQ_LT(TCP_GET_SEQ(p), ssn->server.next_seq) ||\n                        SEQ_GT(TCP_GET_SEQ(p), (ssn->server.last_ack + ssn->server.window)))\n                {\n                    SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                            \" != %\" PRIu32 \" from stream\", ssn,\n                            TCP_GET_SEQ(p), ssn->server.next_seq);\n                    StreamTcpSetEvent(p, STREAM_CLOSEWAIT_FIN_OUT_OF_WINDOW);\n                    SCReturnInt(-1);\n                }\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->client, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_CLOSEWAIT_INVALID_ACK);\n                SCReturnInt(-1);\n            }\n\n            if (!retransmission) {\n                StreamTcpPacketSetState(p, ssn, TCP_LAST_ACK);\n                SCLogDebug(\"ssn %p: state changed to TCP_LAST_ACK\", ssn);\n\n                ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n            }\n\n            if (p->tcph->th_flags & TH_ACK)\n                StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->client.next_seq, TCP_GET_ACK(p)))\n                ssn->client.next_seq = TCP_GET_ACK(p);\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->server.next_seq,\n                    ssn->client.last_ack);\n        }\n\n    } else if (p->tcph->th_flags & TH_SYN) {\n        SCLogDebug(\"ssn (%p): SYN pkt on CloseWait\", ssn);\n        StreamTcpSetEvent(p, STREAM_SHUTDOWN_SYN_RESEND);\n        SCReturnInt(-1);\n\n    } else if (p->tcph->th_flags & TH_ACK) {\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            if (!StreamTcpValidateTimestamp(ssn, p))\n                SCReturnInt(-1);\n        }\n\n        if (PKT_IS_TOSERVER(p)) {\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to server: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n\n            int retransmission = 0;\n            if (StreamTcpPacketIsRetransmission(&ssn->client, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n            }\n\n            if (p->payload_len > 0 && (SEQ_LEQ((TCP_GET_SEQ(p) + p->payload_len), ssn->client.last_ack))) {\n                SCLogDebug(\"ssn %p: -> retransmission\", ssn);\n                StreamTcpSetEvent(p, STREAM_CLOSEWAIT_PKT_BEFORE_LAST_ACK);\n                SCReturnInt(-1);\n\n            } else if (SEQ_GT(TCP_GET_SEQ(p), (ssn->client.last_ack + ssn->client.window)))\n            {\n                SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                        \" != %\" PRIu32 \" from stream\", ssn,\n                        TCP_GET_SEQ(p), ssn->client.next_seq);\n                StreamTcpSetEvent(p, STREAM_CLOSEWAIT_ACK_OUT_OF_WINDOW);\n                SCReturnInt(-1);\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->server, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_CLOSEWAIT_INVALID_ACK);\n                SCReturnInt(-1);\n            }\n\n            if (!retransmission) {\n                ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->server.next_seq, TCP_GET_ACK(p)))\n                ssn->server.next_seq = TCP_GET_ACK(p);\n\n            if (SEQ_EQ(TCP_GET_SEQ(p),ssn->client.next_seq))\n                StreamTcpUpdateNextSeq(ssn, &ssn->client, (ssn->client.next_seq + p->payload_len));\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->client.next_seq,\n                    ssn->server.last_ack);\n        } else {\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to client: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n            int retransmission = 0;\n            if (StreamTcpPacketIsRetransmission(&ssn->server, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n            }\n\n            if (p->payload_len > 0 && (SEQ_LEQ((TCP_GET_SEQ(p) + p->payload_len), ssn->server.last_ack))) {\n                SCLogDebug(\"ssn %p: -> retransmission\", ssn);\n                StreamTcpSetEvent(p, STREAM_CLOSEWAIT_PKT_BEFORE_LAST_ACK);\n                SCReturnInt(-1);\n\n            } else if (SEQ_GT(TCP_GET_SEQ(p), (ssn->server.last_ack + ssn->server.window)))\n            {\n                SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                        \" != %\" PRIu32 \" from stream\", ssn,\n                        TCP_GET_SEQ(p), ssn->server.next_seq);\n                StreamTcpSetEvent(p, STREAM_CLOSEWAIT_ACK_OUT_OF_WINDOW);\n                SCReturnInt(-1);\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->client, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_CLOSEWAIT_INVALID_ACK);\n                SCReturnInt(-1);\n            }\n\n            if (!retransmission) {\n                ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->client.next_seq, TCP_GET_ACK(p)))\n                ssn->client.next_seq = TCP_GET_ACK(p);\n\n            if (SEQ_EQ(TCP_GET_SEQ(p),ssn->server.next_seq))\n                StreamTcpUpdateNextSeq(ssn, &ssn->server, (ssn->server.next_seq + p->payload_len));\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->server.next_seq,\n                    ssn->client.last_ack);\n        }\n\n    } else {\n        SCLogDebug(\"ssn %p: default case\", ssn);\n    }\n    SCReturnInt(0);\n}\n\n/**\n *  \\brief  Function to handle the TCP_LAST_ACK state. Upon arrival of ACK\n *          the connection goes to TCP_CLOSED state and stream memory is\n *          returned back to pool. The state is possible only for server host.\n *\n *  \\param  tv      Thread Variable containing  input/output queue, cpu affinity\n *  \\param  p       Packet which has to be handled in this TCP state.\n *  \\param  stt     Strean Thread module registered to handle the stream handling\n */\n\nstatic int StreamTcpPacketStateLastAck(ThreadVars *tv, Packet *p,\n        StreamTcpThread *stt, TcpSession *ssn, PacketQueueNoLock *pq)\n{\n    if (ssn == NULL)\n        return -1;\n\n    if (p->tcph->th_flags & TH_RST) {\n        if (!StreamTcpValidateRst(ssn, p))\n            return -1;\n\n        StreamTcpCloseSsnWithReset(p, ssn);\n\n        if (PKT_IS_TOSERVER(p)) {\n            if ((p->tcph->th_flags & TH_ACK) && StreamTcpValidateAck(ssn, &ssn->server, p) == 0)\n                StreamTcpUpdateLastAck(ssn, &ssn->server,\n                        StreamTcpResetGetMaxAck(&ssn->server, TCP_GET_ACK(p)));\n\n            StreamTcpUpdateLastAck(ssn, &ssn->client,\n                    StreamTcpResetGetMaxAck(&ssn->client, TCP_GET_SEQ(p)));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n        } else {\n            if ((p->tcph->th_flags & TH_ACK) && StreamTcpValidateAck(ssn, &ssn->client, p) == 0)\n                StreamTcpUpdateLastAck(ssn, &ssn->client,\n                        StreamTcpResetGetMaxAck(&ssn->client, TCP_GET_ACK(p)));\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server,\n                    StreamTcpResetGetMaxAck(&ssn->server, TCP_GET_SEQ(p)));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n        }\n\n    } else if (p->tcph->th_flags & TH_FIN) {\n        /** \\todo */\n        SCLogDebug(\"ssn (%p): FIN pkt on LastAck\", ssn);\n\n    } else if (p->tcph->th_flags & TH_SYN) {\n        SCLogDebug(\"ssn (%p): SYN pkt on LastAck\", ssn);\n        StreamTcpSetEvent(p, STREAM_SHUTDOWN_SYN_RESEND);\n        return -1;\n\n    } else if (p->tcph->th_flags & TH_ACK) {\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            if (!StreamTcpValidateTimestamp(ssn, p))\n                return -1;\n        }\n\n        if (PKT_IS_TOSERVER(p)) {\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to server: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n\n            int retransmission = 0;\n            if (StreamTcpPacketIsRetransmission(&ssn->client, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->server, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_LASTACK_INVALID_ACK);\n                SCReturnInt(-1);\n            }\n\n            if (!retransmission) {\n                if (SEQ_LT(TCP_GET_SEQ(p), ssn->client.next_seq)) {\n                    SCLogDebug(\"ssn %p: not updating state as packet is before next_seq\", ssn);\n                } else if (TCP_GET_SEQ(p) != ssn->client.next_seq && TCP_GET_SEQ(p) != ssn->client.next_seq + 1) {\n                    SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                            \" != %\" PRIu32 \" from stream\", ssn,\n                            TCP_GET_SEQ(p), ssn->client.next_seq);\n                    StreamTcpSetEvent(p, STREAM_LASTACK_ACK_WRONG_SEQ);\n                    return -1;\n                } else {\n                    StreamTcpPacketSetState(p, ssn, TCP_CLOSED);\n                    SCLogDebug(\"ssn %p: state changed to TCP_CLOSED\", ssn);\n\n                }\n                ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->server.next_seq, TCP_GET_ACK(p)))\n                ssn->server.next_seq = TCP_GET_ACK(p);\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->client.next_seq,\n                    ssn->server.last_ack);\n        }\n    } else {\n        SCLogDebug(\"ssn %p: default case\", ssn);\n    }\n\n    return 0;\n}\n\n/**\n *  \\brief  Function to handle the TCP_TIME_WAIT state. Upon arrival of ACK\n *          the connection goes to TCP_CLOSED state and stream memory is\n *          returned back to pool.\n *\n *  \\param  tv      Thread Variable containing  input/output queue, cpu affinity\n *  \\param  p       Packet which has to be handled in this TCP state.\n *  \\param  stt     Strean Thread module registered to handle the stream handling\n */\n\nstatic int StreamTcpPacketStateTimeWait(ThreadVars *tv, Packet *p,\n        StreamTcpThread *stt, TcpSession *ssn, PacketQueueNoLock *pq)\n{\n    if (ssn == NULL)\n        return -1;\n\n    if (p->tcph->th_flags & TH_RST) {\n        if (!StreamTcpValidateRst(ssn, p))\n            return -1;\n\n        StreamTcpCloseSsnWithReset(p, ssn);\n\n        if (PKT_IS_TOSERVER(p)) {\n            if ((p->tcph->th_flags & TH_ACK) && StreamTcpValidateAck(ssn, &ssn->server, p) == 0)\n                StreamTcpUpdateLastAck(ssn, &ssn->server,\n                        StreamTcpResetGetMaxAck(&ssn->server, TCP_GET_ACK(p)));\n\n            StreamTcpUpdateLastAck(ssn, &ssn->client,\n                    StreamTcpResetGetMaxAck(&ssn->client, TCP_GET_SEQ(p)));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n        } else {\n            if ((p->tcph->th_flags & TH_ACK) && StreamTcpValidateAck(ssn, &ssn->client, p) == 0)\n                StreamTcpUpdateLastAck(ssn, &ssn->client,\n                        StreamTcpResetGetMaxAck(&ssn->client, TCP_GET_ACK(p)));\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server,\n                    StreamTcpResetGetMaxAck(&ssn->server, TCP_GET_SEQ(p)));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n        }\n\n    } else if (p->tcph->th_flags & TH_FIN) {\n        /** \\todo */\n\n    } else if (p->tcph->th_flags & TH_SYN) {\n        SCLogDebug(\"ssn (%p): SYN pkt on TimeWait\", ssn);\n        StreamTcpSetEvent(p, STREAM_SHUTDOWN_SYN_RESEND);\n        return -1;\n\n    } else if (p->tcph->th_flags & TH_ACK) {\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            if (!StreamTcpValidateTimestamp(ssn, p))\n                return -1;\n        }\n\n        if (PKT_IS_TOSERVER(p)) {\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to server: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n            int retransmission = 0;\n            if (StreamTcpPacketIsRetransmission(&ssn->client, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n\n            } else if (TCP_GET_SEQ(p) != ssn->client.next_seq && TCP_GET_SEQ(p) != ssn->client.next_seq+1) {\n                SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                        \" != %\" PRIu32 \" from stream\", ssn,\n                        TCP_GET_SEQ(p), ssn->client.next_seq);\n                StreamTcpSetEvent(p, STREAM_TIMEWAIT_ACK_WRONG_SEQ);\n                return -1;\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->server, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_TIMEWAIT_INVALID_ACK);\n                SCReturnInt(-1);\n            }\n\n            if (!retransmission) {\n                StreamTcpPacketSetState(p, ssn, TCP_CLOSED);\n                SCLogDebug(\"ssn %p: state changed to TCP_CLOSED\", ssn);\n\n                ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->server.next_seq, TCP_GET_ACK(p)))\n                ssn->server.next_seq = TCP_GET_ACK(p);\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->client.next_seq,\n                    ssn->server.last_ack);\n        } else {\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to client: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n            int retransmission = 0;\n            if (StreamTcpPacketIsRetransmission(&ssn->server, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n            } else if (TCP_GET_SEQ(p) != ssn->server.next_seq && TCP_GET_SEQ(p) != ssn->server.next_seq+1) {\n                if (p->payload_len > 0 && TCP_GET_SEQ(p) == ssn->server.last_ack) {\n                    SCLogDebug(\"ssn %p: -> retransmission\", ssn);\n                    SCReturnInt(0);\n                } else {\n                    SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                            \" != %\" PRIu32 \" from stream\", ssn,\n                            TCP_GET_SEQ(p), ssn->server.next_seq);\n                    StreamTcpSetEvent(p, STREAM_TIMEWAIT_ACK_WRONG_SEQ);\n                    return -1;\n                }\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->client, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_TIMEWAIT_INVALID_ACK);\n                SCReturnInt(-1);\n            }\n\n            if (!retransmission) {\n                StreamTcpPacketSetState(p, ssn, TCP_CLOSED);\n                SCLogDebug(\"ssn %p: state changed to TCP_CLOSED\", ssn);\n\n                ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->client.next_seq, TCP_GET_ACK(p)))\n                ssn->client.next_seq = TCP_GET_ACK(p);\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->server.next_seq,\n                    ssn->client.last_ack);\n        }\n\n    } else {\n        SCLogDebug(\"ssn %p: default case\", ssn);\n    }\n\n    return 0;\n}\n\nstatic int StreamTcpPacketStateClosed(ThreadVars *tv, Packet *p,\n        StreamTcpThread *stt, TcpSession *ssn, PacketQueueNoLock *pq)\n{\n    if (ssn == NULL)\n        return -1;\n\n    if (p->tcph->th_flags & TH_RST) {\n        SCLogDebug(\"RST on closed state\");\n        return 0;\n    }\n\n    TcpStream *stream = NULL, *ostream = NULL;\n    if (PKT_IS_TOSERVER(p)) {\n        stream = &ssn->client;\n        ostream = &ssn->server;\n    } else {\n        stream = &ssn->server;\n        ostream = &ssn->client;\n    }\n\n    SCLogDebug(\"stream %s ostream %s\",\n            stream->flags & STREAMTCP_STREAM_FLAG_RST_RECV?\"true\":\"false\",\n            ostream->flags & STREAMTCP_STREAM_FLAG_RST_RECV ? \"true\":\"false\");\n\n    /* if we've seen a RST on our direction, but not on the other\n     * see if we perhaps need to continue processing anyway. */\n    if ((stream->flags & STREAMTCP_STREAM_FLAG_RST_RECV) == 0) {\n        if (ostream->flags & STREAMTCP_STREAM_FLAG_RST_RECV) {\n            if (StreamTcpStateDispatch(tv, p, stt, ssn, &stt->pseudo_queue, ssn->pstate) < 0)\n                return -1;\n        }\n    }\n    return 0;\n}\n\nstatic void StreamTcpPacketCheckPostRst(TcpSession *ssn, Packet *p)\n{\n    if (p->flags & PKT_PSEUDO_STREAM_END) {\n        return;\n    }\n    /* more RSTs are not unusual */\n    if ((p->tcph->th_flags & (TH_RST)) != 0) {\n        return;\n    }\n\n    TcpStream *ostream = NULL;\n    if (PKT_IS_TOSERVER(p)) {\n        ostream = &ssn->server;\n    } else {\n        ostream = &ssn->client;\n    }\n\n    if (ostream->flags & STREAMTCP_STREAM_FLAG_RST_RECV) {\n        SCLogDebug(\"regular packet %\"PRIu64\" from same sender as \"\n                \"the previous RST. Looks like it injected!\", p->pcap_cnt);\n        ostream->flags &= ~STREAMTCP_STREAM_FLAG_RST_RECV;\n        ssn->flags &= ~STREAMTCP_FLAG_CLOSED_BY_RST;\n        StreamTcpSetEvent(p, STREAM_SUSPECTED_RST_INJECT);\n        return;\n    }\n    return;\n}\n\n/**\n *  \\retval 1 packet is a keep alive pkt\n *  \\retval 0 packet is not a keep alive pkt\n */\nstatic int StreamTcpPacketIsKeepAlive(TcpSession *ssn, Packet *p)\n{\n    TcpStream *stream = NULL, *ostream = NULL;\n    uint32_t seq;\n    uint32_t ack;\n\n    if (p->flags & PKT_PSEUDO_STREAM_END)\n        return 0;\n\n    /*\n       rfc 1122:\n       An implementation SHOULD send a keep-alive segment with no\n       data; however, it MAY be configurable to send a keep-alive\n       segment containing one garbage octet, for compatibility with\n       erroneous TCP implementations.\n     */\n    if (p->payload_len > 1)\n        return 0;\n\n    if ((p->tcph->th_flags & (TH_SYN|TH_FIN|TH_RST)) != 0) {\n        return 0;\n    }\n\n    if (PKT_IS_TOSERVER(p)) {\n        stream = &ssn->client;\n        ostream = &ssn->server;\n    } else {\n        stream = &ssn->server;\n        ostream = &ssn->client;\n    }\n\n    seq = TCP_GET_SEQ(p);\n    ack = TCP_GET_ACK(p);\n\n    if (ack == ostream->last_ack && seq == (stream->next_seq - 1)) {\n        SCLogDebug(\"packet is TCP keep-alive: %\"PRIu64, p->pcap_cnt);\n        stream->flags |= STREAMTCP_STREAM_FLAG_KEEPALIVE;\n        return 1;\n    }\n    SCLogDebug(\"seq %u (%u), ack %u (%u)\", seq,  (stream->next_seq - 1), ack, ostream->last_ack);\n    return 0;\n}\n\n/**\n *  \\retval 1 packet is a keep alive ACK pkt\n *  \\retval 0 packet is not a keep alive ACK pkt\n */\nstatic int StreamTcpPacketIsKeepAliveACK(TcpSession *ssn, Packet *p)\n{\n    TcpStream *stream = NULL, *ostream = NULL;\n    uint32_t seq;\n    uint32_t ack;\n    uint32_t pkt_win;\n\n    if (p->flags & PKT_PSEUDO_STREAM_END)\n        return 0;\n    /* should get a normal ACK to a Keep Alive */\n    if (p->payload_len > 0)\n        return 0;\n\n    if ((p->tcph->th_flags & (TH_SYN|TH_FIN|TH_RST)) != 0)\n        return 0;\n\n    if (TCP_GET_WINDOW(p) == 0)\n        return 0;\n\n    if (PKT_IS_TOSERVER(p)) {\n        stream = &ssn->client;\n        ostream = &ssn->server;\n    } else {\n        stream = &ssn->server;\n        ostream = &ssn->client;\n    }\n\n    seq = TCP_GET_SEQ(p);\n    ack = TCP_GET_ACK(p);\n\n    pkt_win = TCP_GET_WINDOW(p) << ostream->wscale;\n    if (pkt_win != ostream->window)\n        return 0;\n\n    if ((ostream->flags & STREAMTCP_STREAM_FLAG_KEEPALIVE) && ack == ostream->last_ack && seq == stream->next_seq) {\n        SCLogDebug(\"packet is TCP keep-aliveACK: %\"PRIu64, p->pcap_cnt);\n        ostream->flags &= ~STREAMTCP_STREAM_FLAG_KEEPALIVE;\n        return 1;\n    }\n    SCLogDebug(\"seq %u (%u), ack %u (%u) FLAG_KEEPALIVE: %s\", seq, stream->next_seq, ack, ostream->last_ack,\n            ostream->flags & STREAMTCP_STREAM_FLAG_KEEPALIVE ? \"set\" : \"not set\");\n    return 0;\n}\n\nstatic void StreamTcpClearKeepAliveFlag(TcpSession *ssn, Packet *p)\n{\n    TcpStream *stream = NULL;\n\n    if (p->flags & PKT_PSEUDO_STREAM_END)\n        return;\n\n    if (PKT_IS_TOSERVER(p)) {\n        stream = &ssn->client;\n    } else {\n        stream = &ssn->server;\n    }\n\n    if (stream->flags & STREAMTCP_STREAM_FLAG_KEEPALIVE) {\n        stream->flags &= ~STREAMTCP_STREAM_FLAG_KEEPALIVE;\n        SCLogDebug(\"FLAG_KEEPALIVE cleared\");\n    }\n}\n\n/**\n *  \\retval 1 packet is a window update pkt\n *  \\retval 0 packet is not a window update pkt\n */\nstatic int StreamTcpPacketIsWindowUpdate(TcpSession *ssn, Packet *p)\n{\n    TcpStream *stream = NULL, *ostream = NULL;\n    uint32_t seq;\n    uint32_t ack;\n    uint32_t pkt_win;\n\n    if (p->flags & PKT_PSEUDO_STREAM_END)\n        return 0;\n\n    if (ssn->state < TCP_ESTABLISHED)\n        return 0;\n\n    if (p->payload_len > 0)\n        return 0;\n\n    if ((p->tcph->th_flags & (TH_SYN|TH_FIN|TH_RST)) != 0)\n        return 0;\n\n    if (TCP_GET_WINDOW(p) == 0)\n        return 0;\n\n    if (PKT_IS_TOSERVER(p)) {\n        stream = &ssn->client;\n        ostream = &ssn->server;\n    } else {\n        stream = &ssn->server;\n        ostream = &ssn->client;\n    }\n\n    seq = TCP_GET_SEQ(p);\n    ack = TCP_GET_ACK(p);\n\n    pkt_win = TCP_GET_WINDOW(p) << ostream->wscale;\n    if (pkt_win == ostream->window)\n        return 0;\n\n    if (ack == ostream->last_ack && seq == stream->next_seq) {\n        SCLogDebug(\"packet is TCP window update: %\"PRIu64, p->pcap_cnt);\n        return 1;\n    }\n    SCLogDebug(\"seq %u (%u), ack %u (%u)\", seq, stream->next_seq, ack, ostream->last_ack);\n    return 0;\n}\n\n/**\n *  Try to detect whether a packet is a valid FIN 4whs final ack.\n *\n */\nstatic int StreamTcpPacketIsFinShutdownAck(TcpSession *ssn, Packet *p)\n{\n    TcpStream *stream = NULL, *ostream = NULL;\n    uint32_t seq;\n    uint32_t ack;\n\n    if (p->flags & PKT_PSEUDO_STREAM_END)\n        return 0;\n    if (!(ssn->state == TCP_TIME_WAIT || ssn->state == TCP_CLOSE_WAIT || ssn->state == TCP_LAST_ACK))\n        return 0;\n    if (p->tcph->th_flags != TH_ACK)\n        return 0;\n    if (p->payload_len != 0)\n        return 0;\n\n    if (PKT_IS_TOSERVER(p)) {\n        stream = &ssn->client;\n        ostream = &ssn->server;\n    } else {\n        stream = &ssn->server;\n        ostream = &ssn->client;\n    }\n\n    seq = TCP_GET_SEQ(p);\n    ack = TCP_GET_ACK(p);\n\n    SCLogDebug(\"%\"PRIu64\", seq %u ack %u stream->next_seq %u ostream->next_seq %u\",\n            p->pcap_cnt, seq, ack, stream->next_seq, ostream->next_seq);\n\n    if (SEQ_EQ(stream->next_seq + 1, seq) && SEQ_EQ(ack, ostream->next_seq + 1)) {\n        return 1;\n    }\n    return 0;\n}\n\n/**\n *  Try to detect packets doing bad window updates\n *\n *  See bug 1238.\n *\n *  Find packets that are unexpected, and shrink the window to the point\n *  where the packets we do expect are rejected for being out of window.\n *\n *  The logic we use here is:\n *  - packet seq > next_seq\n *  - packet ack > next_seq (packet acks unseen data)\n *  - packet shrinks window more than it's own data size\n *  - packet shrinks window more than the diff between it's ack and the\n *    last_ack value\n *\n *  Packets coming in after packet loss can look quite a bit like this.\n */\nstatic int StreamTcpPacketIsBadWindowUpdate(TcpSession *ssn, Packet *p)\n{\n    TcpStream *stream = NULL, *ostream = NULL;\n    uint32_t seq;\n    uint32_t ack;\n    uint32_t pkt_win;\n\n    if (p->flags & PKT_PSEUDO_STREAM_END)\n        return 0;\n\n    if (ssn->state < TCP_ESTABLISHED || ssn->state == TCP_CLOSED)\n        return 0;\n\n    if ((p->tcph->th_flags & (TH_SYN|TH_FIN|TH_RST)) != 0)\n        return 0;\n\n    if (PKT_IS_TOSERVER(p)) {\n        stream = &ssn->client;\n        ostream = &ssn->server;\n    } else {\n        stream = &ssn->server;\n        ostream = &ssn->client;\n    }\n\n    seq = TCP_GET_SEQ(p);\n    ack = TCP_GET_ACK(p);\n\n    pkt_win = TCP_GET_WINDOW(p) << ostream->wscale;\n\n    if (pkt_win < ostream->window) {\n        uint32_t diff = ostream->window - pkt_win;\n        if (diff > p->payload_len &&\n                SEQ_GT(ack, ostream->next_seq) &&\n                SEQ_GT(seq, stream->next_seq))\n        {\n            SCLogDebug(\"%\"PRIu64\", pkt_win %u, stream win %u, diff %u, dsize %u\",\n                p->pcap_cnt, pkt_win, ostream->window, diff, p->payload_len);\n            SCLogDebug(\"%\"PRIu64\", pkt_win %u, stream win %u\",\n                p->pcap_cnt, pkt_win, ostream->window);\n            SCLogDebug(\"%\"PRIu64\", seq %u ack %u ostream->next_seq %u ostream->last_ack %u, ostream->next_win %u, diff %u (%u)\",\n                    p->pcap_cnt, seq, ack, ostream->next_seq, ostream->last_ack, ostream->next_win,\n                    ostream->next_seq - ostream->last_ack, stream->next_seq - stream->last_ack);\n\n            /* get the expected window shrinking from looking at ack vs last_ack.\n             * Observed a lot of just a little overrunning that value. So added some\n             * margin that is still ok. To make sure this isn't a loophole to still\n             * close the window, this is limited to windows above 1024. Both values\n             * are rather arbitrary. */\n            uint32_t adiff = ack - ostream->last_ack;\n            if (((pkt_win > 1024) && (diff > (adiff + 32))) ||\n                ((pkt_win <= 1024) && (diff > adiff)))\n            {\n                SCLogDebug(\"pkt ACK %u is %u bytes beyond last_ack %u, shrinks window by %u \"\n                        \"(allowing 32 bytes extra): pkt WIN %u\", ack, adiff, ostream->last_ack, diff, pkt_win);\n                SCLogDebug(\"%u - %u = %u (state %u)\", diff, adiff, diff - adiff, ssn->state);\n                StreamTcpSetEvent(p, STREAM_PKT_BAD_WINDOW_UPDATE);\n                return 1;\n            }\n        }\n\n    }\n    SCLogDebug(\"seq %u (%u), ack %u (%u)\", seq, stream->next_seq, ack, ostream->last_ack);\n    return 0;\n}\n\n/** \\internal\n *  \\brief call packet handling function for 'state'\n *  \\param state current TCP state\n */\nstatic inline int StreamTcpStateDispatch(ThreadVars *tv, Packet *p,\n        StreamTcpThread *stt, TcpSession *ssn, PacketQueueNoLock *pq,\n        const uint8_t state)\n{\n    SCLogDebug(\"ssn: %p\", ssn);\n    switch (state) {\n        case TCP_SYN_SENT:\n            SCLogDebug(\"packet received on TCP_SYN_SENT state\");\n            if (StreamTcpPacketStateSynSent(tv, p, stt, ssn, pq)) {\n                return -1;\n            }\n            break;\n        case TCP_SYN_RECV:\n            SCLogDebug(\"packet received on TCP_SYN_RECV state\");\n            if (StreamTcpPacketStateSynRecv(tv, p, stt, ssn, pq)) {\n                return -1;\n            }\n            break;\n        case TCP_ESTABLISHED:\n            SCLogDebug(\"packet received on TCP_ESTABLISHED state\");\n            if (StreamTcpPacketStateEstablished(tv, p, stt, ssn, pq)) {\n                return -1;\n            }\n            break;\n        case TCP_FIN_WAIT1:\n            SCLogDebug(\"packet received on TCP_FIN_WAIT1 state\");\n            if (StreamTcpPacketStateFinWait1(tv, p, stt, ssn, pq)) {\n                return -1;\n            }\n            break;\n        case TCP_FIN_WAIT2:\n            SCLogDebug(\"packet received on TCP_FIN_WAIT2 state\");\n            if (StreamTcpPacketStateFinWait2(tv, p, stt, ssn, pq)) {\n                return -1;\n            }\n            break;\n        case TCP_CLOSING:\n            SCLogDebug(\"packet received on TCP_CLOSING state\");\n            if (StreamTcpPacketStateClosing(tv, p, stt, ssn, pq)) {\n                return -1;\n            }\n            break;\n        case TCP_CLOSE_WAIT:\n            SCLogDebug(\"packet received on TCP_CLOSE_WAIT state\");\n            if (StreamTcpPacketStateCloseWait(tv, p, stt, ssn, pq)) {\n                return -1;\n            }\n            break;\n        case TCP_LAST_ACK:\n            SCLogDebug(\"packet received on TCP_LAST_ACK state\");\n            if (StreamTcpPacketStateLastAck(tv, p, stt, ssn, pq)) {\n                return -1;\n            }\n            break;\n        case TCP_TIME_WAIT:\n            SCLogDebug(\"packet received on TCP_TIME_WAIT state\");\n            if (StreamTcpPacketStateTimeWait(tv, p, stt, ssn, pq)) {\n                return -1;\n            }\n            break;\n        case TCP_CLOSED:\n            /* TCP session memory is not returned to pool until timeout. */\n            SCLogDebug(\"packet received on closed state\");\n\n            if (StreamTcpPacketStateClosed(tv, p, stt, ssn, pq)) {\n                return -1;\n            }\n\n            break;\n        default:\n            SCLogDebug(\"packet received on default state\");\n            break;\n    }\n    return 0;\n}\n\nstatic inline void HandleThreadId(ThreadVars *tv, Packet *p, StreamTcpThread *stt)\n{\n    const int idx = (!(PKT_IS_TOSERVER(p)));\n\n    /* assign the thread id to the flow */\n    if (unlikely(p->flow->thread_id[idx] == 0)) {\n        p->flow->thread_id[idx] = (FlowThreadId)tv->id;\n    } else if (unlikely((FlowThreadId)tv->id != p->flow->thread_id[idx])) {\n        SCLogDebug(\"wrong thread: flow has %u, we are %d\", p->flow->thread_id[idx], tv->id);\n        if (p->pkt_src == PKT_SRC_WIRE) {\n            StatsIncr(tv, stt->counter_tcp_wrong_thread);\n            if ((p->flow->flags & FLOW_WRONG_THREAD) == 0) {\n                p->flow->flags |= FLOW_WRONG_THREAD;\n                StreamTcpSetEvent(p, STREAM_WRONG_THREAD);\n            }\n        }\n    }\n}\n\n/* flow is and stays locked */\nint StreamTcpPacket (ThreadVars *tv, Packet *p, StreamTcpThread *stt,\n                     PacketQueueNoLock *pq)\n{\n    SCEnter();\n\n    DEBUG_ASSERT_FLOW_LOCKED(p->flow);\n\n    SCLogDebug(\"p->pcap_cnt %\"PRIu64, p->pcap_cnt);\n\n    HandleThreadId(tv, p, stt);\n\n    TcpSession *ssn = (TcpSession *)p->flow->protoctx;\n\n    /* track TCP flags */\n    if (ssn != NULL) {\n        ssn->tcp_packet_flags |= p->tcph->th_flags;\n        if (PKT_IS_TOSERVER(p))\n            ssn->client.tcp_flags |= p->tcph->th_flags;\n        else if (PKT_IS_TOCLIENT(p))\n            ssn->server.tcp_flags |= p->tcph->th_flags;\n\n        /* check if we need to unset the ASYNC flag */\n        if (ssn->flags & STREAMTCP_FLAG_ASYNC &&\n            ssn->client.tcp_flags != 0 &&\n            ssn->server.tcp_flags != 0)\n        {\n            SCLogDebug(\"ssn %p: removing ASYNC flag as we have packets on both sides\", ssn);\n            ssn->flags &= ~STREAMTCP_FLAG_ASYNC;\n        }\n    }\n\n    /* update counters */\n    if ((p->tcph->th_flags & (TH_SYN|TH_ACK)) == (TH_SYN|TH_ACK)) {\n        StatsIncr(tv, stt->counter_tcp_synack);\n    } else if (p->tcph->th_flags & (TH_SYN)) {\n        StatsIncr(tv, stt->counter_tcp_syn);\n    }\n    if (p->tcph->th_flags & (TH_RST)) {\n        StatsIncr(tv, stt->counter_tcp_rst);\n    }\n\n    /* broken TCP http://ask.wireshark.org/questions/3183/acknowledgment-number-broken-tcp-the-acknowledge-field-is-nonzero-while-the-ack-flag-is-not-set */\n    if (!(p->tcph->th_flags & TH_ACK) && TCP_GET_ACK(p) != 0) {\n        StreamTcpSetEvent(p, STREAM_PKT_BROKEN_ACK);\n    }\n\n    /* If we are on IPS mode, and got a drop action triggered from\n     * the IP only module, or from a reassembled msg and/or from an\n     * applayer detection, then drop the rest of the packets of the\n     * same stream and avoid inspecting it any further */\n    if (StreamTcpCheckFlowDrops(p) == 1) {\n        SCLogDebug(\"This flow/stream triggered a drop rule\");\n        FlowSetNoPacketInspectionFlag(p->flow);\n        DecodeSetNoPacketInspectionFlag(p);\n        StreamTcpDisableAppLayer(p->flow);\n        PACKET_DROP(p);\n        /* return the segments to the pool */\n        StreamTcpSessionPktFree(p);\n        SCReturnInt(0);\n    }\n\n    if (ssn == NULL || ssn->state == TCP_NONE) {\n        if (StreamTcpPacketStateNone(tv, p, stt, ssn, &stt->pseudo_queue) == -1) {\n            goto error;\n        }\n\n        if (ssn != NULL)\n            SCLogDebug(\"ssn->alproto %\"PRIu16\"\", p->flow->alproto);\n    } else {\n        /* special case for PKT_PSEUDO_STREAM_END packets:\n         * bypass the state handling and various packet checks,\n         * we care about reassembly here. */\n        if (p->flags & PKT_PSEUDO_STREAM_END) {\n            if (PKT_IS_TOCLIENT(p)) {\n                ssn->client.last_ack = TCP_GET_ACK(p);\n                StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                        &ssn->server, p, pq);\n            } else {\n                ssn->server.last_ack = TCP_GET_ACK(p);\n                StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                        &ssn->client, p, pq);\n            }\n            /* straight to 'skip' as we already handled reassembly */\n            goto skip;\n        }\n\n        if (p->flow->flags & FLOW_WRONG_THREAD) {\n            /* Stream and/or session in known bad condition. Block events\n             * from being set. */\n            p->flags |= PKT_STREAM_NO_EVENTS;\n        }\n\n        if (StreamTcpPacketIsKeepAlive(ssn, p) == 1) {\n            goto skip;\n        }\n        if (StreamTcpPacketIsKeepAliveACK(ssn, p) == 1) {\n            StreamTcpClearKeepAliveFlag(ssn, p);\n            goto skip;\n        }\n        StreamTcpClearKeepAliveFlag(ssn, p);\n\n        /* if packet is not a valid window update, check if it is perhaps\n         * a bad window update that we should ignore (and alert on) */\n        if (StreamTcpPacketIsFinShutdownAck(ssn, p) == 0) {\n            if (StreamTcpPacketIsWindowUpdate(ssn, p) == 0) {\n                if (StreamTcpPacketIsBadWindowUpdate(ssn,p))\n                    goto skip;\n                if (StreamTcpPacketIsOutdatedAck(ssn, p))\n                    goto skip;\n            }\n        }\n\n        /* handle the per 'state' logic */\n        if (StreamTcpStateDispatch(tv, p, stt, ssn, &stt->pseudo_queue, ssn->state) < 0)\n            goto error;\n\n    skip:\n        StreamTcpPacketCheckPostRst(ssn, p);\n\n        if (ssn->state >= TCP_ESTABLISHED) {\n            p->flags |= PKT_STREAM_EST;\n        }\n    }\n\n    /* deal with a pseudo packet that is created upon receiving a RST\n     * segment. To be sure we process both sides of the connection, we\n     * inject a fake packet into the system, forcing reassembly of the\n     * opposing direction.\n     * There should be only one, but to be sure we do a while loop. */\n    if (ssn != NULL) {\n        while (stt->pseudo_queue.len > 0) {\n            SCLogDebug(\"processing pseudo packet / stream end\");\n            Packet *np = PacketDequeueNoLock(&stt->pseudo_queue);\n            if (np != NULL) {\n                /* process the opposing direction of the original packet */\n                if (PKT_IS_TOSERVER(np)) {\n                    SCLogDebug(\"pseudo packet is to server\");\n                    StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                            &ssn->client, np, NULL);\n                } else {\n                    SCLogDebug(\"pseudo packet is to client\");\n                    StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                            &ssn->server, np, NULL);\n                }\n\n                /* enqueue this packet so we inspect it in detect etc */\n                PacketEnqueueNoLock(pq, np);\n            }\n            SCLogDebug(\"processing pseudo packet / stream end done\");\n        }\n\n        /* recalc the csum on the packet if it was modified */\n        if (p->flags & PKT_STREAM_MODIFIED) {\n            ReCalculateChecksum(p);\n        }\n        /* check for conditions that may make us not want to log this packet */\n\n        /* streams that hit depth */\n        if ((ssn->client.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) ||\n             (ssn->server.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED))\n        {\n            /* we can call bypass callback, if enabled */\n            if (StreamTcpBypassEnabled()) {\n                PacketBypassCallback(p);\n            }\n        }\n\n        if ((ssn->client.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) ||\n             (ssn->server.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED))\n        {\n            p->flags |= PKT_STREAM_NOPCAPLOG;\n        }\n\n        /* encrypted packets */\n        if ((PKT_IS_TOSERVER(p) && (ssn->client.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY)) ||\n            (PKT_IS_TOCLIENT(p) && (ssn->server.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY)))\n        {\n            p->flags |= PKT_STREAM_NOPCAPLOG;\n        }\n\n        if (ssn->flags & STREAMTCP_FLAG_BYPASS) {\n            /* we can call bypass callback, if enabled */\n            if (StreamTcpBypassEnabled()) {\n                PacketBypassCallback(p);\n            }\n\n        /* if stream is dead and we have no detect engine at all, bypass. */\n        } else if (g_detect_disabled &&\n                (ssn->client.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) &&\n                (ssn->server.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) &&\n                StreamTcpBypassEnabled())\n        {\n            SCLogDebug(\"bypass as stream is dead and we have no rules\");\n            PacketBypassCallback(p);\n        }\n    }\n\n    SCReturnInt(0);\n\nerror:\n    /* make sure we don't leave packets in our pseudo queue */\n    while (stt->pseudo_queue.len > 0) {\n        Packet *np = PacketDequeueNoLock(&stt->pseudo_queue);\n        if (np != NULL) {\n            PacketEnqueueNoLock(pq, np);\n        }\n    }\n\n    /* recalc the csum on the packet if it was modified */\n    if (p->flags & PKT_STREAM_MODIFIED) {\n        ReCalculateChecksum(p);\n    }\n\n    if (StreamTcpInlineDropInvalid()) {\n        /* disable payload inspection as we're dropping this packet\n         * anyway. Doesn't disable all detection, so we can still\n         * match on the stream event that was set. */\n        DecodeSetNoPayloadInspectionFlag(p);\n        PACKET_DROP(p);\n    }\n    SCReturnInt(-1);\n}\n\n/**\n *  \\brief  Function to validate the checksum of the received packet. If the\n *          checksum is invalid, packet will be dropped, as the end system will\n *          also drop the packet.\n *\n *  \\param  p       Packet of which checksum has to be validated\n *  \\retval  1 if the checksum is valid, otherwise 0\n */\nstatic inline int StreamTcpValidateChecksum(Packet *p)\n{\n    int ret = 1;\n\n    if (p->flags & PKT_IGNORE_CHECKSUM)\n        return ret;\n\n    if (p->level4_comp_csum == -1) {\n        if (PKT_IS_IPV4(p)) {\n            p->level4_comp_csum = TCPChecksum(p->ip4h->s_ip_addrs,\n                                              (uint16_t *)p->tcph,\n                                              (p->payload_len +\n                                                  TCP_GET_HLEN(p)),\n                                              p->tcph->th_sum);\n        } else if (PKT_IS_IPV6(p)) {\n            p->level4_comp_csum = TCPV6Checksum(p->ip6h->s_ip6_addrs,\n                                                (uint16_t *)p->tcph,\n                                                (p->payload_len +\n                                                    TCP_GET_HLEN(p)),\n                                                p->tcph->th_sum);\n        }\n    }\n\n    if (p->level4_comp_csum != 0) {\n        ret = 0;\n        if (p->livedev) {\n            (void) SC_ATOMIC_ADD(p->livedev->invalid_checksums, 1);\n        } else if (p->pcap_cnt) {\n            PcapIncreaseInvalidChecksum();\n        }\n    }\n\n    return ret;\n}\n\n/** \\internal\n *  \\brief check if a packet is a valid stream started\n *  \\retval bool true/false */\nstatic int TcpSessionPacketIsStreamStarter(const Packet *p)\n{\n    if (p->tcph->th_flags == TH_SYN) {\n        SCLogDebug(\"packet %\"PRIu64\" is a stream starter: %02x\", p->pcap_cnt, p->tcph->th_flags);\n        return 1;\n    }\n\n    if (stream_config.midstream || stream_config.async_oneside == TRUE) {\n        if (p->tcph->th_flags == (TH_SYN|TH_ACK)) {\n            SCLogDebug(\"packet %\"PRIu64\" is a midstream stream starter: %02x\", p->pcap_cnt, p->tcph->th_flags);\n            return 1;\n        }\n    }\n    return 0;\n}\n\n/** \\internal\n *  \\brief Check if Flow and TCP SSN allow this flow/tuple to be reused\n *  \\retval bool true yes reuse, false no keep tracking old ssn */\nstatic int TcpSessionReuseDoneEnoughSyn(const Packet *p, const Flow *f, const TcpSession *ssn)\n{\n    if (FlowGetPacketDirection(f, p) == TOSERVER) {\n        if (ssn == NULL) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p null. No reuse.\", p->pcap_cnt, ssn);\n            return 0;\n        }\n        if (SEQ_EQ(ssn->client.isn, TCP_GET_SEQ(p))) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p. Packet SEQ == Stream ISN. Retransmission. Don't reuse.\", p->pcap_cnt, ssn);\n            return 0;\n        }\n        if (ssn->state >= TCP_LAST_ACK) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p state >= TCP_LAST_ACK (%u). Reuse.\", p->pcap_cnt, ssn, ssn->state);\n            return 1;\n        }\n        if (ssn->state == TCP_NONE) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p state == TCP_NONE (%u). Reuse.\", p->pcap_cnt, ssn, ssn->state);\n            return 1;\n        }\n        if (ssn->state < TCP_LAST_ACK) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p state < TCP_LAST_ACK (%u). Don't reuse.\", p->pcap_cnt, ssn, ssn->state);\n            return 0;\n        }\n\n    } else {\n        if (ssn == NULL) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p null. Reuse.\", p->pcap_cnt, ssn);\n            return 1;\n        }\n        if (ssn->state >= TCP_LAST_ACK) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p state >= TCP_LAST_ACK (%u). Reuse.\", p->pcap_cnt, ssn, ssn->state);\n            return 1;\n        }\n        if (ssn->state == TCP_NONE) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p state == TCP_NONE (%u). Reuse.\", p->pcap_cnt, ssn, ssn->state);\n            return 1;\n        }\n        if (ssn->state < TCP_LAST_ACK) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p state < TCP_LAST_ACK (%u). Don't reuse.\", p->pcap_cnt, ssn, ssn->state);\n            return 0;\n        }\n    }\n\n    SCLogDebug(\"default: how did we get here?\");\n    return 0;\n}\n\n/** \\internal\n *  \\brief check if ssn is done enough for reuse by syn/ack\n *  \\note should only be called if midstream is enabled\n */\nstatic int TcpSessionReuseDoneEnoughSynAck(const Packet *p, const Flow *f, const TcpSession *ssn)\n{\n    if (FlowGetPacketDirection(f, p) == TOCLIENT) {\n        if (ssn == NULL) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p null. No reuse.\", p->pcap_cnt, ssn);\n            return 0;\n        }\n        if (SEQ_EQ(ssn->server.isn, TCP_GET_SEQ(p))) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p. Packet SEQ == Stream ISN. Retransmission. Don't reuse.\", p->pcap_cnt, ssn);\n            return 0;\n        }\n        if (ssn->state >= TCP_LAST_ACK) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p state >= TCP_LAST_ACK (%u). Reuse.\", p->pcap_cnt, ssn, ssn->state);\n            return 1;\n        }\n        if (ssn->state == TCP_NONE) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p state == TCP_NONE (%u). Reuse.\", p->pcap_cnt, ssn, ssn->state);\n            return 1;\n        }\n        if (ssn->state < TCP_LAST_ACK) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p state < TCP_LAST_ACK (%u). Don't reuse.\", p->pcap_cnt, ssn, ssn->state);\n            return 0;\n        }\n\n    } else {\n        if (ssn == NULL) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p null. Reuse.\", p->pcap_cnt, ssn);\n            return 1;\n        }\n        if (ssn->state >= TCP_LAST_ACK) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p state >= TCP_LAST_ACK (%u). Reuse.\", p->pcap_cnt, ssn, ssn->state);\n            return 1;\n        }\n        if (ssn->state == TCP_NONE) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p state == TCP_NONE (%u). Reuse.\", p->pcap_cnt, ssn, ssn->state);\n            return 1;\n        }\n        if (ssn->state < TCP_LAST_ACK) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p state < TCP_LAST_ACK (%u). Don't reuse.\", p->pcap_cnt, ssn, ssn->state);\n            return 0;\n        }\n    }\n\n    SCLogDebug(\"default: how did we get here?\");\n    return 0;\n}\n\n/** \\brief Check if SSN is done enough for reuse\n *\n *  Reuse means a new TCP session reuses the tuple (flow in suri)\n *\n *  \\retval bool true if ssn can be reused, false if not */\nstatic int TcpSessionReuseDoneEnough(const Packet *p, const Flow *f, const TcpSession *ssn)\n{\n    if (p->tcph->th_flags == TH_SYN) {\n        return TcpSessionReuseDoneEnoughSyn(p, f, ssn);\n    }\n\n    if (stream_config.midstream || stream_config.async_oneside == TRUE) {\n        if (p->tcph->th_flags == (TH_SYN|TH_ACK)) {\n            return TcpSessionReuseDoneEnoughSynAck(p, f, ssn);\n        }\n    }\n\n    return 0;\n}\n\nint TcpSessionPacketSsnReuse(const Packet *p, const Flow *f, const void *tcp_ssn)\n{\n    if (p->proto == IPPROTO_TCP && p->tcph != NULL) {\n        if (TcpSessionPacketIsStreamStarter(p) == 1) {\n            if (TcpSessionReuseDoneEnough(p, f, tcp_ssn) == 1) {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nTmEcode StreamTcp (ThreadVars *tv, Packet *p, void *data, PacketQueueNoLock *pq)\n{\n    StreamTcpThread *stt = (StreamTcpThread *)data;\n\n    SCLogDebug(\"p->pcap_cnt %\" PRIu64 \" direction %s\", p->pcap_cnt,\n            p->flow ? (FlowGetPacketDirection(p->flow, p) == TOSERVER ? \"toserver\" : \"toclient\")\n                    : \"noflow\");\n\n    if (!(PKT_IS_TCP(p))) {\n        return TM_ECODE_OK;\n    }\n\n    if (p->flow == NULL) {\n        StatsIncr(tv, stt->counter_tcp_no_flow);\n        return TM_ECODE_OK;\n    }\n\n    /* only TCP packets with a flow from here */\n\n    if (!(p->flags & PKT_PSEUDO_STREAM_END)) {\n        if (stream_config.flags & STREAMTCP_INIT_FLAG_CHECKSUM_VALIDATION) {\n            if (StreamTcpValidateChecksum(p) == 0) {\n                StatsIncr(tv, stt->counter_tcp_invalid_checksum);\n                return TM_ECODE_OK;\n            }\n        } else {\n            p->flags |= PKT_IGNORE_CHECKSUM;\n        }\n    } else {\n        p->flags |= PKT_IGNORE_CHECKSUM; //TODO check that this is set at creation\n    }\n    AppLayerProfilingReset(stt->ra_ctx->app_tctx);\n\n    (void)StreamTcpPacket(tv, p, stt, pq);\n\n    return TM_ECODE_OK;\n}\n\nTmEcode StreamTcpThreadInit(ThreadVars *tv, void *initdata, void **data)\n{\n    SCEnter();\n    StreamTcpThread *stt = SCMalloc(sizeof(StreamTcpThread));\n    if (unlikely(stt == NULL))\n        SCReturnInt(TM_ECODE_FAILED);\n    memset(stt, 0, sizeof(StreamTcpThread));\n    stt->ssn_pool_id = -1;\n\n    *data = (void *)stt;\n\n    stt->counter_tcp_sessions = StatsRegisterCounter(\"tcp.sessions\", tv);\n    stt->counter_tcp_ssn_memcap = StatsRegisterCounter(\"tcp.ssn_memcap_drop\", tv);\n    stt->counter_tcp_pseudo = StatsRegisterCounter(\"tcp.pseudo\", tv);\n    stt->counter_tcp_pseudo_failed = StatsRegisterCounter(\"tcp.pseudo_failed\", tv);\n    stt->counter_tcp_invalid_checksum = StatsRegisterCounter(\"tcp.invalid_checksum\", tv);\n    stt->counter_tcp_no_flow = StatsRegisterCounter(\"tcp.no_flow\", tv);\n    stt->counter_tcp_syn = StatsRegisterCounter(\"tcp.syn\", tv);\n    stt->counter_tcp_synack = StatsRegisterCounter(\"tcp.synack\", tv);\n    stt->counter_tcp_rst = StatsRegisterCounter(\"tcp.rst\", tv);\n    stt->counter_tcp_midstream_pickups = StatsRegisterCounter(\"tcp.midstream_pickups\", tv);\n    stt->counter_tcp_wrong_thread = StatsRegisterCounter(\"tcp.pkt_on_wrong_thread\", tv);\n\n    /* init reassembly ctx */\n    stt->ra_ctx = StreamTcpReassembleInitThreadCtx(tv);\n    if (stt->ra_ctx == NULL)\n        SCReturnInt(TM_ECODE_FAILED);\n\n    stt->ra_ctx->counter_tcp_segment_memcap = StatsRegisterCounter(\"tcp.segment_memcap_drop\", tv);\n    stt->ra_ctx->counter_tcp_stream_depth = StatsRegisterCounter(\"tcp.stream_depth_reached\", tv);\n    stt->ra_ctx->counter_tcp_reass_gap = StatsRegisterCounter(\"tcp.reassembly_gap\", tv);\n    stt->ra_ctx->counter_tcp_reass_overlap = StatsRegisterCounter(\"tcp.overlap\", tv);\n    stt->ra_ctx->counter_tcp_reass_overlap_diff_data = StatsRegisterCounter(\"tcp.overlap_diff_data\", tv);\n\n    stt->ra_ctx->counter_tcp_reass_data_normal_fail = StatsRegisterCounter(\"tcp.insert_data_normal_fail\", tv);\n    stt->ra_ctx->counter_tcp_reass_data_overlap_fail = StatsRegisterCounter(\"tcp.insert_data_overlap_fail\", tv);\n    stt->ra_ctx->counter_tcp_reass_list_fail = StatsRegisterCounter(\"tcp.insert_list_fail\", tv);\n\n\n    SCLogDebug(\"StreamTcp thread specific ctx online at %p, reassembly ctx %p\",\n                stt, stt->ra_ctx);\n\n    SCMutexLock(&ssn_pool_mutex);\n    if (ssn_pool == NULL) {\n        ssn_pool = PoolThreadInit(1, /* thread */\n                0, /* unlimited */\n                stream_config.prealloc_sessions,\n                sizeof(TcpSession),\n                StreamTcpSessionPoolAlloc,\n                StreamTcpSessionPoolInit, NULL,\n                StreamTcpSessionPoolCleanup, NULL);\n        stt->ssn_pool_id = 0;\n        SCLogDebug(\"pool size %d, thread ssn_pool_id %d\", PoolThreadSize(ssn_pool), stt->ssn_pool_id);\n    } else {\n        /* grow ssn_pool until we have a element for our thread id */\n        stt->ssn_pool_id = PoolThreadExpand(ssn_pool);\n        SCLogDebug(\"pool size %d, thread ssn_pool_id %d\", PoolThreadSize(ssn_pool), stt->ssn_pool_id);\n    }\n    SCMutexUnlock(&ssn_pool_mutex);\n    if (stt->ssn_pool_id < 0 || ssn_pool == NULL) {\n        SCLogError(SC_ERR_MEM_ALLOC, \"failed to setup/expand stream session pool. Expand stream.memcap?\");\n        SCReturnInt(TM_ECODE_FAILED);\n    }\n\n    SCReturnInt(TM_ECODE_OK);\n}\n\nTmEcode StreamTcpThreadDeinit(ThreadVars *tv, void *data)\n{\n    SCEnter();\n    StreamTcpThread *stt = (StreamTcpThread *)data;\n    if (stt == NULL) {\n        return TM_ECODE_OK;\n    }\n\n    /* XXX */\n\n    /* free reassembly ctx */\n    StreamTcpReassembleFreeThreadCtx(stt->ra_ctx);\n\n    /* clear memory */\n    memset(stt, 0, sizeof(StreamTcpThread));\n\n    SCFree(stt);\n    SCReturnInt(TM_ECODE_OK);\n}\n\n/**\n *  \\brief   Function to check the validity of the RST packets based on the\n *           target OS of the given packet.\n *\n *  \\param   ssn    TCP session to which the given packet belongs\n *  \\param   p      Packet which has to be checked for its validity\n *\n *  \\retval 0 unacceptable RST\n *  \\retval 1 acceptable RST\n *\n *  WebSense sends RST packets that are:\n *  - RST flag, win 0, ack 0, seq = nextseq\n *\n */\n\nstatic int StreamTcpValidateRst(TcpSession *ssn, Packet *p)\n{\n\n    uint8_t os_policy;\n\n    if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n        if (!StreamTcpValidateTimestamp(ssn, p)) {\n            SCReturnInt(0);\n        }\n    }\n\n    /* Set up the os_policy to be used in validating the RST packets based on\n       target system */\n    if (PKT_IS_TOSERVER(p)) {\n        if (ssn->server.os_policy == 0)\n            StreamTcpSetOSPolicy(&ssn->server, p);\n\n        os_policy = ssn->server.os_policy;\n\n        if (p->tcph->th_flags & TH_ACK &&\n                TCP_GET_ACK(p) && StreamTcpValidateAck(ssn, &ssn->server, p) == -1) {\n            SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n            StreamTcpSetEvent(p, STREAM_RST_INVALID_ACK);\n            SCReturnInt(0);\n        }\n\n    } else {\n        if (ssn->client.os_policy == 0)\n            StreamTcpSetOSPolicy(&ssn->client, p);\n\n        os_policy = ssn->client.os_policy;\n\n        if (p->tcph->th_flags & TH_ACK &&\n                TCP_GET_ACK(p) && StreamTcpValidateAck(ssn, &ssn->client, p) == -1) {\n            SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n            StreamTcpSetEvent(p, STREAM_RST_INVALID_ACK);\n            SCReturnInt(0);\n        }\n    }\n\n    if (ssn->flags & STREAMTCP_FLAG_ASYNC) {\n        if (PKT_IS_TOSERVER(p)) {\n            if (SEQ_GEQ(TCP_GET_SEQ(p), ssn->client.next_seq)) {\n                SCLogDebug(\"ssn %p: ASYNC accept RST\", ssn);\n                return 1;\n            }\n        } else {\n            if (SEQ_GEQ(TCP_GET_SEQ(p), ssn->server.next_seq)) {\n                SCLogDebug(\"ssn %p: ASYNC accept RST\", ssn);\n                return 1;\n            }\n        }\n        SCLogDebug(\"ssn %p: ASYNC reject RST\", ssn);\n        return 0;\n    }\n\n    switch (os_policy) {\n        case OS_POLICY_HPUX11:\n            if(PKT_IS_TOSERVER(p)){\n                if(SEQ_GEQ(TCP_GET_SEQ(p), ssn->client.next_seq)) {\n                    SCLogDebug(\"reset is Valid! Packet SEQ: %\" PRIu32 \"\",\n                                TCP_GET_SEQ(p));\n                    return 1;\n                } else {\n                    SCLogDebug(\"reset is not Valid! Packet SEQ: %\" PRIu32 \" \"\n                               \"and server SEQ: %\" PRIu32 \"\", TCP_GET_SEQ(p),\n                                ssn->client.next_seq);\n                    return 0;\n                }\n            } else { /* implied to client */\n                if(SEQ_GEQ(TCP_GET_SEQ(p), ssn->server.next_seq)) {\n                    SCLogDebug(\"reset is valid! Packet SEQ: %\" PRIu32 \"\",\n                                TCP_GET_SEQ(p));\n                    return 1;\n                } else {\n                    SCLogDebug(\"reset is not valid! Packet SEQ: %\" PRIu32 \" \"\n                               \"and client SEQ: %\" PRIu32 \"\", TCP_GET_SEQ(p),\n                                ssn->server.next_seq);\n                    return 0;\n                }\n            }\n            break;\n        case OS_POLICY_OLD_LINUX:\n        case OS_POLICY_LINUX:\n        case OS_POLICY_SOLARIS:\n            if(PKT_IS_TOSERVER(p)){\n                if(SEQ_GEQ((TCP_GET_SEQ(p)+p->payload_len),\n                            ssn->client.last_ack))\n                { /*window base is needed !!*/\n                    if(SEQ_LT(TCP_GET_SEQ(p),\n                              (ssn->client.next_seq + ssn->client.window)))\n                    {\n                        SCLogDebug(\"reset is Valid! Packet SEQ: %\" PRIu32 \"\",\n                                    TCP_GET_SEQ(p));\n                        return 1;\n                    }\n                } else {\n                    SCLogDebug(\"reset is not valid! Packet SEQ: %\" PRIu32 \" and\"\n                               \" server SEQ: %\" PRIu32 \"\", TCP_GET_SEQ(p),\n                                ssn->client.next_seq);\n                    return 0;\n                }\n            } else { /* implied to client */\n                if(SEQ_GEQ((TCP_GET_SEQ(p) + p->payload_len),\n                            ssn->server.last_ack))\n                { /*window base is needed !!*/\n                    if(SEQ_LT(TCP_GET_SEQ(p),\n                                (ssn->server.next_seq + ssn->server.window)))\n                    {\n                        SCLogDebug(\"reset is Valid! Packet SEQ: %\" PRIu32 \"\",\n                                    TCP_GET_SEQ(p));\n                        return 1;\n                    }\n                } else {\n                    SCLogDebug(\"reset is not valid! Packet SEQ: %\" PRIu32 \" and\"\n                               \" client SEQ: %\" PRIu32 \"\", TCP_GET_SEQ(p),\n                                 ssn->server.next_seq);\n                    return 0;\n                }\n            }\n            break;\n        default:\n        case OS_POLICY_BSD:\n        case OS_POLICY_FIRST:\n        case OS_POLICY_HPUX10:\n        case OS_POLICY_IRIX:\n        case OS_POLICY_MACOS:\n        case OS_POLICY_LAST:\n        case OS_POLICY_WINDOWS:\n        case OS_POLICY_WINDOWS2K3:\n        case OS_POLICY_VISTA:\n            if(PKT_IS_TOSERVER(p)) {\n                if(SEQ_EQ(TCP_GET_SEQ(p), ssn->client.next_seq)) {\n                    SCLogDebug(\"reset is valid! Packet SEQ: %\" PRIu32 \"\",\n                               TCP_GET_SEQ(p));\n                    return 1;\n                } else {\n                    SCLogDebug(\"reset is not valid! Packet SEQ: %\" PRIu32 \" \"\n                               \"and server SEQ: %\" PRIu32 \"\", TCP_GET_SEQ(p),\n                               ssn->client.next_seq);\n                    return 0;\n                }\n            } else { /* implied to client */\n                if (SEQ_EQ(TCP_GET_SEQ(p), ssn->server.next_seq)) {\n                    SCLogDebug(\"reset is valid! Packet SEQ: %\" PRIu32 \" Stream %u\",\n                                TCP_GET_SEQ(p), ssn->server.next_seq);\n                    return 1;\n                } else {\n                    SCLogDebug(\"reset is not valid! Packet SEQ: %\" PRIu32 \" and\"\n                               \" client SEQ: %\" PRIu32 \"\",\n                               TCP_GET_SEQ(p), ssn->server.next_seq);\n                    return 0;\n                }\n            }\n            break;\n    }\n    return 0;\n}\n\n/**\n *  \\brief Function to check the validity of the received timestamp based on\n *         the target OS of the given stream.\n *\n *  It's passive except for:\n *  1. it sets the os policy on the stream if necessary\n *  2. it sets an event in the packet if necessary\n *\n *  \\param ssn TCP session to which the given packet belongs\n *  \\param p Packet which has to be checked for its validity\n *\n *  \\retval 1 if the timestamp is valid\n *  \\retval 0 if the timestamp is invalid\n */\nstatic int StreamTcpValidateTimestamp (TcpSession *ssn, Packet *p)\n{\n    SCEnter();\n\n    TcpStream *sender_stream;\n    TcpStream *receiver_stream;\n    uint8_t ret = 1;\n    uint8_t check_ts = 1;\n\n    if (PKT_IS_TOSERVER(p)) {\n        sender_stream = &ssn->client;\n        receiver_stream = &ssn->server;\n    } else {\n        sender_stream = &ssn->server;\n        receiver_stream = &ssn->client;\n    }\n\n    /* Set up the os_policy to be used in validating the timestamps based on\n       the target system */\n    if (receiver_stream->os_policy == 0) {\n        StreamTcpSetOSPolicy(receiver_stream, p);\n    }\n\n    if (TCP_HAS_TS(p)) {\n        uint32_t ts = TCP_GET_TSVAL(p);\n        uint32_t last_pkt_ts = sender_stream->last_pkt_ts;\n        uint32_t last_ts = sender_stream->last_ts;\n\n        if (sender_stream->flags & STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP) {\n            /* The 3whs used the timestamp with 0 value. */\n            switch (receiver_stream->os_policy) {\n                case OS_POLICY_LINUX:\n                case OS_POLICY_WINDOWS2K3:\n                    /* Linux and windows 2003 does not allow the use of 0 as\n                     * timestamp in the 3whs. */\n                    check_ts = 0;\n                    break;\n\n                case OS_POLICY_OLD_LINUX:\n                case OS_POLICY_WINDOWS:\n                case OS_POLICY_VISTA:\n                    if (SEQ_EQ(sender_stream->next_seq, TCP_GET_SEQ(p))) {\n                        last_ts = ts;\n                        check_ts = 0; /*next packet will be checked for validity\n                                        and stream TS has been updated with this\n                                        one.*/\n                    }\n                    break;\n            }\n        }\n\n        if (receiver_stream->os_policy == OS_POLICY_HPUX11) {\n            /* HPUX11 ignores the timestamp of out of order packets */\n            if (!SEQ_EQ(sender_stream->next_seq, TCP_GET_SEQ(p)))\n                check_ts = 0;\n        }\n\n        if (ts == 0) {\n            switch (receiver_stream->os_policy) {\n                case OS_POLICY_OLD_LINUX:\n                case OS_POLICY_WINDOWS:\n                case OS_POLICY_WINDOWS2K3:\n                case OS_POLICY_VISTA:\n                case OS_POLICY_SOLARIS:\n                    /* Old Linux and windows allowed packet with 0 timestamp. */\n                    break;\n                default:\n                    /* other OS simply drop the packet with 0 timestamp, when\n                     * 3whs has valid timestamp*/\n                    goto invalid;\n            }\n        }\n\n        if (check_ts) {\n            int32_t result = 0;\n\n            SCLogDebug(\"ts %\"PRIu32\", last_ts %\"PRIu32\"\", ts, last_ts);\n\n            if (receiver_stream->os_policy == OS_POLICY_LINUX) {\n                /* Linux accepts TS which are off by one.*/\n                result = (int32_t) ((ts - last_ts) + 1);\n            } else {\n                result = (int32_t) (ts - last_ts);\n            }\n\n            SCLogDebug(\"result %\"PRIi32\", p->ts.tv_sec %\"PRIuMAX\"\", result, (uintmax_t)p->ts.tv_sec);\n\n            if (last_pkt_ts == 0 &&\n                    (ssn->flags & STREAMTCP_FLAG_MIDSTREAM))\n            {\n                last_pkt_ts = p->ts.tv_sec;\n            }\n\n            if (result < 0) {\n                SCLogDebug(\"timestamp is not valid last_ts \"\n                           \"%\" PRIu32 \" p->tcpvars->ts %\" PRIu32 \" result \"\n                           \"%\" PRId32 \"\", last_ts, ts, result);\n                /* candidate for rejection */\n                ret = 0;\n            } else if ((sender_stream->last_ts != 0) &&\n                        (((uint32_t) p->ts.tv_sec) >\n                            last_pkt_ts + PAWS_24DAYS))\n            {\n                SCLogDebug(\"packet is not valid last_pkt_ts \"\n                           \"%\" PRIu32 \" p->ts.tv_sec %\" PRIu32 \"\",\n                            last_pkt_ts, (uint32_t) p->ts.tv_sec);\n                /* candidate for rejection */\n                ret = 0;\n            }\n\n            if (ret == 0) {\n                /* if the timestamp of packet is not valid then, check if the\n                 * current stream timestamp is not so old. if so then we need to\n                 * accept the packet and update the stream->last_ts (RFC 1323)*/\n                if ((SEQ_EQ(sender_stream->next_seq, TCP_GET_SEQ(p))) &&\n                        (((uint32_t) p->ts.tv_sec > (last_pkt_ts + PAWS_24DAYS))))\n                {\n                    SCLogDebug(\"timestamp considered valid anyway\");\n                } else {\n                    goto invalid;\n                }\n            }\n        }\n    }\n\n    SCReturnInt(1);\n\ninvalid:\n    StreamTcpSetEvent(p, STREAM_PKT_INVALID_TIMESTAMP);\n    SCReturnInt(0);\n}\n\n/**\n *  \\brief Function to check the validity of the received timestamp based on\n *         the target OS of the given stream and update the session.\n *\n *  \\param ssn TCP session to which the given packet belongs\n *  \\param p Packet which has to be checked for its validity\n *\n *  \\retval 1 if the timestamp is valid\n *  \\retval 0 if the timestamp is invalid\n */\nstatic int StreamTcpHandleTimestamp (TcpSession *ssn, Packet *p)\n{\n    SCEnter();\n\n    TcpStream *sender_stream;\n    TcpStream *receiver_stream;\n    uint8_t ret = 1;\n    uint8_t check_ts = 1;\n\n    if (PKT_IS_TOSERVER(p)) {\n        sender_stream = &ssn->client;\n        receiver_stream = &ssn->server;\n    } else {\n        sender_stream = &ssn->server;\n        receiver_stream = &ssn->client;\n    }\n\n    /* Set up the os_policy to be used in validating the timestamps based on\n       the target system */\n    if (receiver_stream->os_policy == 0) {\n        StreamTcpSetOSPolicy(receiver_stream, p);\n    }\n\n    if (TCP_HAS_TS(p)) {\n        uint32_t ts = TCP_GET_TSVAL(p);\n\n        if (sender_stream->flags & STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP) {\n            /* The 3whs used the timestamp with 0 value. */\n            switch (receiver_stream->os_policy) {\n                case OS_POLICY_LINUX:\n                case OS_POLICY_WINDOWS2K3:\n                    /* Linux and windows 2003 does not allow the use of 0 as\n                     * timestamp in the 3whs. */\n                    ssn->flags &= ~STREAMTCP_FLAG_TIMESTAMP;\n                    check_ts = 0;\n                    break;\n\n                case OS_POLICY_OLD_LINUX:\n                case OS_POLICY_WINDOWS:\n                case OS_POLICY_VISTA:\n                    sender_stream->flags &= ~STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n                    if (SEQ_EQ(sender_stream->next_seq, TCP_GET_SEQ(p))) {\n                        sender_stream->last_ts = ts;\n                        check_ts = 0; /*next packet will be checked for validity\n                                        and stream TS has been updated with this\n                                        one.*/\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        if (receiver_stream->os_policy == OS_POLICY_HPUX11) {\n            /*HPUX11 ignores the timestamp of out of order packets*/\n            if (!SEQ_EQ(sender_stream->next_seq, TCP_GET_SEQ(p)))\n                check_ts = 0;\n        }\n\n        if (ts == 0) {\n            switch (receiver_stream->os_policy) {\n                case OS_POLICY_OLD_LINUX:\n                case OS_POLICY_WINDOWS:\n                case OS_POLICY_WINDOWS2K3:\n                case OS_POLICY_VISTA:\n                case OS_POLICY_SOLARIS:\n                    /* Old Linux and windows allowed packet with 0 timestamp. */\n                    break;\n                default:\n                    /* other OS simply drop the packet with 0 timestamp, when\n                     * 3whs has valid timestamp*/\n                    goto invalid;\n            }\n        }\n\n        if (check_ts) {\n            int32_t result = 0;\n\n            SCLogDebug(\"ts %\"PRIu32\", last_ts %\"PRIu32\"\", ts, sender_stream->last_ts);\n\n            if (receiver_stream->os_policy == OS_POLICY_LINUX) {\n                /* Linux accepts TS which are off by one.*/\n                result = (int32_t) ((ts - sender_stream->last_ts) + 1);\n            } else {\n                result = (int32_t) (ts - sender_stream->last_ts);\n            }\n\n            SCLogDebug(\"result %\"PRIi32\", p->ts.tv_sec %\"PRIuMAX\"\", result, (uintmax_t)p->ts.tv_sec);\n\n            if (sender_stream->last_pkt_ts == 0 &&\n                    (ssn->flags & STREAMTCP_FLAG_MIDSTREAM))\n            {\n                sender_stream->last_pkt_ts = p->ts.tv_sec;\n            }\n\n            if (result < 0) {\n                SCLogDebug(\"timestamp is not valid sender_stream->last_ts \"\n                           \"%\" PRIu32 \" p->tcpvars->ts %\" PRIu32 \" result \"\n                           \"%\" PRId32 \"\", sender_stream->last_ts, ts, result);\n                /* candidate for rejection */\n                ret = 0;\n            } else if ((sender_stream->last_ts != 0) &&\n                        (((uint32_t) p->ts.tv_sec) >\n                            sender_stream->last_pkt_ts + PAWS_24DAYS))\n            {\n                SCLogDebug(\"packet is not valid sender_stream->last_pkt_ts \"\n                           \"%\" PRIu32 \" p->ts.tv_sec %\" PRIu32 \"\",\n                            sender_stream->last_pkt_ts, (uint32_t) p->ts.tv_sec);\n                /* candidate for rejection */\n                ret = 0;\n            }\n\n            if (ret == 1) {\n                /* Update the timestamp and last seen packet time for this\n                 * stream */\n                if (SEQ_EQ(sender_stream->next_seq, TCP_GET_SEQ(p)))\n                    sender_stream->last_ts = ts;\n\n                sender_stream->last_pkt_ts = p->ts.tv_sec;\n\n            } else if (ret == 0) {\n                /* if the timestamp of packet is not valid then, check if the\n                 * current stream timestamp is not so old. if so then we need to\n                 * accept the packet and update the stream->last_ts (RFC 1323)*/\n                if ((SEQ_EQ(sender_stream->next_seq, TCP_GET_SEQ(p))) &&\n                        (((uint32_t) p->ts.tv_sec > (sender_stream->last_pkt_ts + PAWS_24DAYS))))\n                {\n                    sender_stream->last_ts = ts;\n                    sender_stream->last_pkt_ts = p->ts.tv_sec;\n\n                    SCLogDebug(\"timestamp considered valid anyway\");\n                } else {\n                    goto invalid;\n                }\n            }\n        }\n    } else {\n        /* Solaris stops using timestamps if a packet is received\n           without a timestamp and timestamps were used on that stream. */\n        if (receiver_stream->os_policy == OS_POLICY_SOLARIS)\n            ssn->flags &= ~STREAMTCP_FLAG_TIMESTAMP;\n    }\n\n    SCReturnInt(1);\n\ninvalid:\n    StreamTcpSetEvent(p, STREAM_PKT_INVALID_TIMESTAMP);\n    SCReturnInt(0);\n}\n\n/**\n *  \\brief  Function to test the received ACK values against the stream window\n *          and previous ack value. ACK values should be higher than previous\n *          ACK value and less than the next_win value.\n *\n *  \\param  ssn     TcpSession for state access\n *  \\param  stream  TcpStream of which last_ack needs to be tested\n *  \\param  p       Packet which is used to test the last_ack\n *\n *  \\retval 0  ACK is valid, last_ack is updated if ACK was higher\n *  \\retval -1 ACK is invalid\n */\nstatic inline int StreamTcpValidateAck(TcpSession *ssn, TcpStream *stream, Packet *p)\n{\n    SCEnter();\n\n    if (!(p->tcph->th_flags & TH_ACK))\n        SCReturnInt(0);\n\n    uint32_t ack = TCP_GET_ACK(p);\n\n    /* fast track */\n    if (SEQ_GT(ack, stream->last_ack) && SEQ_LEQ(ack, stream->next_win))\n    {\n        SCLogDebug(\"ACK in bounds\");\n        SCReturnInt(0);\n    }\n    /* fast track */\n    else if (SEQ_EQ(ack, stream->last_ack)) {\n        SCLogDebug(\"pkt ACK %\"PRIu32\" == stream last ACK %\"PRIu32, TCP_GET_ACK(p), stream->last_ack);\n        SCReturnInt(0);\n    }\n\n    /* exception handling */\n    if (SEQ_LT(ack, stream->last_ack)) {\n        SCLogDebug(\"pkt ACK %\"PRIu32\" < stream last ACK %\"PRIu32, TCP_GET_ACK(p), stream->last_ack);\n\n        /* This is an attempt to get a 'left edge' value that we can check against.\n         * It doesn't work when the window is 0, need to think of a better way. */\n\n        if (stream->window != 0 && SEQ_LT(ack, (stream->last_ack - stream->window))) {\n            SCLogDebug(\"ACK %\"PRIu32\" is before last_ack %\"PRIu32\" - window \"\n                    \"%\"PRIu32\" = %\"PRIu32, ack, stream->last_ack,\n                    stream->window, stream->last_ack - stream->window);\n            goto invalid;\n        }\n\n        SCReturnInt(0);\n    }\n\n    /* no further checks possible for ASYNC */\n    if ((ssn->flags & STREAMTCP_FLAG_ASYNC) != 0) {\n        SCReturnInt(0);\n    }\n\n    if (ssn->state > TCP_SYN_SENT && SEQ_GT(ack, stream->next_win)) {\n        SCLogDebug(\"ACK %\"PRIu32\" is after next_win %\"PRIu32, ack, stream->next_win);\n        goto invalid;\n    /* a toclient RST as a reponse to SYN, next_win is 0, ack will be isn+1, just like\n     * the syn ack */\n    } else if (ssn->state == TCP_SYN_SENT && PKT_IS_TOCLIENT(p) &&\n            p->tcph->th_flags & TH_RST &&\n            SEQ_EQ(ack, stream->isn + 1)) {\n        SCReturnInt(0);\n    }\n\n    SCLogDebug(\"default path leading to invalid: ACK %\"PRIu32\", last_ack %\"PRIu32\n        \" next_win %\"PRIu32, ack, stream->last_ack, stream->next_win);\ninvalid:\n    StreamTcpSetEvent(p, STREAM_PKT_INVALID_ACK);\n    SCReturnInt(-1);\n}\n\n/** \\brief update reassembly progress\n\n * \\param ssn TCP Session\n * \\param direction direction to set the flag in: 0 toserver, 1 toclient\n */\nvoid StreamTcpUpdateAppLayerProgress(TcpSession *ssn, char direction,\n        const uint32_t progress)\n{\n    if (direction) {\n        ssn->server.app_progress_rel += progress;\n    } else {\n        ssn->client.app_progress_rel += progress;\n    }\n}\n\n/** \\brief disable reassembly\n\n *  Disable app layer and set raw inspect to no longer accept new data.\n *  Stream engine will then fully disable raw after last inspection.\n *\n * \\param ssn TCP Session to set the flag in\n * \\param direction direction to set the flag in: 0 toserver, 1 toclient\n */\nvoid StreamTcpSetSessionNoReassemblyFlag(TcpSession *ssn, char direction)\n{\n    ssn->flags |= STREAMTCP_FLAG_APP_LAYER_DISABLED;\n    if (direction) {\n        ssn->server.flags |= STREAMTCP_STREAM_FLAG_NEW_RAW_DISABLED;\n    } else {\n        ssn->client.flags |= STREAMTCP_STREAM_FLAG_NEW_RAW_DISABLED;\n    }\n}\n\n/** \\brief  Set the No reassembly flag for the given direction in given TCP\n *          session.\n *\n * \\param ssn TCP Session to set the flag in\n * \\param direction direction to set the flag in: 0 toserver, 1 toclient\n */\nvoid StreamTcpSetDisableRawReassemblyFlag(TcpSession *ssn, char direction)\n{\n    direction ? (ssn->server.flags |= STREAMTCP_STREAM_FLAG_NEW_RAW_DISABLED) :\n                (ssn->client.flags |= STREAMTCP_STREAM_FLAG_NEW_RAW_DISABLED);\n}\n\n/** \\brief enable bypass\n *\n * \\param ssn TCP Session to set the flag in\n * \\param direction direction to set the flag in: 0 toserver, 1 toclient\n */\nvoid StreamTcpSetSessionBypassFlag(TcpSession *ssn)\n{\n    ssn->flags |= STREAMTCP_FLAG_BYPASS;\n}\n\n#define PSEUDO_PKT_SET_IPV4HDR(nipv4h,ipv4h) do { \\\n        IPV4_SET_RAW_VER(nipv4h, IPV4_GET_RAW_VER(ipv4h)); \\\n        IPV4_SET_RAW_HLEN(nipv4h, IPV4_GET_RAW_HLEN(ipv4h)); \\\n        IPV4_SET_RAW_IPLEN(nipv4h, IPV4_GET_RAW_IPLEN(ipv4h)); \\\n        IPV4_SET_RAW_IPTOS(nipv4h, IPV4_GET_RAW_IPTOS(ipv4h)); \\\n        IPV4_SET_RAW_IPPROTO(nipv4h, IPV4_GET_RAW_IPPROTO(ipv4h)); \\\n        (nipv4h)->s_ip_src = IPV4_GET_RAW_IPDST(ipv4h); \\\n        (nipv4h)->s_ip_dst = IPV4_GET_RAW_IPSRC(ipv4h); \\\n    } while (0)\n\n#define PSEUDO_PKT_SET_IPV6HDR(nipv6h,ipv6h) do { \\\n        (nipv6h)->s_ip6_src[0] = (ipv6h)->s_ip6_dst[0]; \\\n        (nipv6h)->s_ip6_src[1] = (ipv6h)->s_ip6_dst[1]; \\\n        (nipv6h)->s_ip6_src[2] = (ipv6h)->s_ip6_dst[2]; \\\n        (nipv6h)->s_ip6_src[3] = (ipv6h)->s_ip6_dst[3]; \\\n        (nipv6h)->s_ip6_dst[0] = (ipv6h)->s_ip6_src[0]; \\\n        (nipv6h)->s_ip6_dst[1] = (ipv6h)->s_ip6_src[1]; \\\n        (nipv6h)->s_ip6_dst[2] = (ipv6h)->s_ip6_src[2]; \\\n        (nipv6h)->s_ip6_dst[3] = (ipv6h)->s_ip6_src[3]; \\\n        IPV6_SET_RAW_NH(nipv6h, IPV6_GET_RAW_NH(ipv6h));    \\\n    } while (0)\n\n#define PSEUDO_PKT_SET_TCPHDR(ntcph,tcph) do { \\\n        COPY_PORT((tcph)->th_dport, (ntcph)->th_sport); \\\n        COPY_PORT((tcph)->th_sport, (ntcph)->th_dport); \\\n        (ntcph)->th_seq = (tcph)->th_ack; \\\n        (ntcph)->th_ack = (tcph)->th_seq; \\\n    } while (0)\n\n/**\n * \\brief   Function to fetch a packet from the packet allocation queue for\n *          creation of the pseudo packet from the reassembled stream.\n *\n * @param parent    Pointer to the parent of the pseudo packet\n * @param pkt       pointer to the raw packet of the parent\n * @param len       length of the packet\n * @return          upon success returns the pointer to the new pseudo packet\n *                  otherwise NULL\n */\nPacket *StreamTcpPseudoSetup(Packet *parent, uint8_t *pkt, uint32_t len)\n{\n    SCEnter();\n\n    if (len == 0) {\n        SCReturnPtr(NULL, \"Packet\");\n    }\n\n    Packet *p = PacketGetFromQueueOrAlloc();\n    if (p == NULL) {\n        SCReturnPtr(NULL, \"Packet\");\n    }\n\n    /* set the root ptr to the lowest layer */\n    if (parent->root != NULL)\n        p->root = parent->root;\n    else\n        p->root = parent;\n\n    /* copy packet and set length, proto */\n    p->proto = parent->proto;\n    p->datalink = parent->datalink;\n\n    PacketCopyData(p, pkt, len);\n    p->recursion_level = parent->recursion_level + 1;\n    p->ts.tv_sec = parent->ts.tv_sec;\n    p->ts.tv_usec = parent->ts.tv_usec;\n\n    FlowReference(&p->flow, parent->flow);\n    /* set tunnel flags */\n\n    /* tell new packet it's part of a tunnel */\n    SET_TUNNEL_PKT(p);\n    /* tell parent packet it's part of a tunnel */\n    SET_TUNNEL_PKT(parent);\n\n    /* increment tunnel packet refcnt in the root packet */\n    TUNNEL_INCR_PKT_TPR(p);\n\n    return p;\n}\n\n/** \\brief Create a pseudo packet injected into the engine to signal the\n *         opposing direction of this stream trigger detection/logging.\n *\n *  \\param parent real packet\n *  \\param pq packet queue to store the new pseudo packet in\n *  \\param dir 0 ts 1 tc\n */\nstatic void StreamTcpPseudoPacketCreateDetectLogFlush(ThreadVars *tv,\n        StreamTcpThread *stt, Packet *parent,\n        TcpSession *ssn, PacketQueueNoLock *pq, int dir)\n{\n    SCEnter();\n    Flow *f = parent->flow;\n\n    if (parent->flags & PKT_PSEUDO_DETECTLOG_FLUSH) {\n        SCReturn;\n    }\n\n    Packet *np = PacketPoolGetPacket();\n    if (np == NULL) {\n        SCReturn;\n    }\n    PKT_SET_SRC(np, PKT_SRC_STREAM_TCP_DETECTLOG_FLUSH);\n\n    np->tenant_id = f->tenant_id;\n    np->datalink = DLT_RAW;\n    np->proto = IPPROTO_TCP;\n    FlowReference(&np->flow, f);\n    np->flags |= PKT_STREAM_EST;\n    np->flags |= PKT_HAS_FLOW;\n    np->flags |= PKT_IGNORE_CHECKSUM;\n    np->flags |= PKT_PSEUDO_DETECTLOG_FLUSH;\n    np->vlan_id[0] = f->vlan_id[0];\n    np->vlan_id[1] = f->vlan_id[1];\n    np->vlan_idx = f->vlan_idx;\n    np->livedev = (struct LiveDevice_ *)f->livedev;\n\n    if (f->flags & FLOW_NOPACKET_INSPECTION) {\n        DecodeSetNoPacketInspectionFlag(np);\n    }\n    if (f->flags & FLOW_NOPAYLOAD_INSPECTION) {\n        DecodeSetNoPayloadInspectionFlag(np);\n    }\n\n    if (dir == 0) {\n        SCLogDebug(\"pseudo is to_server\");\n        np->flowflags |= FLOW_PKT_TOSERVER;\n    } else {\n        SCLogDebug(\"pseudo is to_client\");\n        np->flowflags |= FLOW_PKT_TOCLIENT;\n    }\n    np->flowflags |= FLOW_PKT_ESTABLISHED;\n    np->payload = NULL;\n    np->payload_len = 0;\n\n    if (FLOW_IS_IPV4(f)) {\n        if (dir == 0) {\n            FLOW_COPY_IPV4_ADDR_TO_PACKET(&f->src, &np->src);\n            FLOW_COPY_IPV4_ADDR_TO_PACKET(&f->dst, &np->dst);\n            np->sp = f->sp;\n            np->dp = f->dp;\n        } else {\n            FLOW_COPY_IPV4_ADDR_TO_PACKET(&f->src, &np->dst);\n            FLOW_COPY_IPV4_ADDR_TO_PACKET(&f->dst, &np->src);\n            np->sp = f->dp;\n            np->dp = f->sp;\n        }\n\n        /* Check if we have enough room in direct data. We need ipv4 hdr + tcp hdr.\n         * Force an allocation if it is not the case.\n         */\n        if (GET_PKT_DIRECT_MAX_SIZE(np) <  40) {\n            if (PacketCallocExtPkt(np, 40) == -1) {\n                goto error;\n            }\n        }\n        /* set the ip header */\n        np->ip4h = (IPV4Hdr *)GET_PKT_DATA(np);\n        /* version 4 and length 20 bytes for the tcp header */\n        np->ip4h->ip_verhl = 0x45;\n        np->ip4h->ip_tos = 0;\n        np->ip4h->ip_len = htons(40);\n        np->ip4h->ip_id = 0;\n        np->ip4h->ip_off = 0;\n        np->ip4h->ip_ttl = 64;\n        np->ip4h->ip_proto = IPPROTO_TCP;\n        if (dir == 0) {\n            np->ip4h->s_ip_src.s_addr = f->src.addr_data32[0];\n            np->ip4h->s_ip_dst.s_addr = f->dst.addr_data32[0];\n        } else {\n            np->ip4h->s_ip_src.s_addr = f->dst.addr_data32[0];\n            np->ip4h->s_ip_dst.s_addr = f->src.addr_data32[0];\n        }\n\n        /* set the tcp header */\n        np->tcph = (TCPHdr *)((uint8_t *)GET_PKT_DATA(np) + 20);\n\n        SET_PKT_LEN(np, 40); /* ipv4 hdr + tcp hdr */\n\n    } else if (FLOW_IS_IPV6(f)) {\n        if (dir == 0) {\n            FLOW_COPY_IPV6_ADDR_TO_PACKET(&f->src, &np->src);\n            FLOW_COPY_IPV6_ADDR_TO_PACKET(&f->dst, &np->dst);\n            np->sp = f->sp;\n            np->dp = f->dp;\n        } else {\n            FLOW_COPY_IPV6_ADDR_TO_PACKET(&f->src, &np->dst);\n            FLOW_COPY_IPV6_ADDR_TO_PACKET(&f->dst, &np->src);\n            np->sp = f->dp;\n            np->dp = f->sp;\n        }\n\n        /* Check if we have enough room in direct data. We need ipv6 hdr + tcp hdr.\n         * Force an allocation if it is not the case.\n         */\n        if (GET_PKT_DIRECT_MAX_SIZE(np) <  60) {\n            if (PacketCallocExtPkt(np, 60) == -1) {\n                goto error;\n            }\n        }\n        /* set the ip header */\n        np->ip6h = (IPV6Hdr *)GET_PKT_DATA(np);\n        /* version 6 */\n        np->ip6h->s_ip6_vfc = 0x60;\n        np->ip6h->s_ip6_flow = 0;\n        np->ip6h->s_ip6_nxt = IPPROTO_TCP;\n        np->ip6h->s_ip6_plen = htons(20);\n        np->ip6h->s_ip6_hlim = 64;\n        if (dir == 0) {\n            np->ip6h->s_ip6_src[0] = f->src.addr_data32[0];\n            np->ip6h->s_ip6_src[1] = f->src.addr_data32[1];\n            np->ip6h->s_ip6_src[2] = f->src.addr_data32[2];\n            np->ip6h->s_ip6_src[3] = f->src.addr_data32[3];\n            np->ip6h->s_ip6_dst[0] = f->dst.addr_data32[0];\n            np->ip6h->s_ip6_dst[1] = f->dst.addr_data32[1];\n            np->ip6h->s_ip6_dst[2] = f->dst.addr_data32[2];\n            np->ip6h->s_ip6_dst[3] = f->dst.addr_data32[3];\n        } else {\n            np->ip6h->s_ip6_src[0] = f->dst.addr_data32[0];\n            np->ip6h->s_ip6_src[1] = f->dst.addr_data32[1];\n            np->ip6h->s_ip6_src[2] = f->dst.addr_data32[2];\n            np->ip6h->s_ip6_src[3] = f->dst.addr_data32[3];\n            np->ip6h->s_ip6_dst[0] = f->src.addr_data32[0];\n            np->ip6h->s_ip6_dst[1] = f->src.addr_data32[1];\n            np->ip6h->s_ip6_dst[2] = f->src.addr_data32[2];\n            np->ip6h->s_ip6_dst[3] = f->src.addr_data32[3];\n        }\n\n        /* set the tcp header */\n        np->tcph = (TCPHdr *)((uint8_t *)GET_PKT_DATA(np) + 40);\n\n        SET_PKT_LEN(np, 60); /* ipv6 hdr + tcp hdr */\n    }\n\n    np->tcph->th_offx2 = 0x50;\n    np->tcph->th_flags |= TH_ACK;\n    np->tcph->th_win = 10;\n    np->tcph->th_urp = 0;\n\n    /* to server */\n    if (dir == 0) {\n        np->tcph->th_sport = htons(f->sp);\n        np->tcph->th_dport = htons(f->dp);\n\n        np->tcph->th_seq = htonl(ssn->client.next_seq);\n        np->tcph->th_ack = htonl(ssn->server.last_ack);\n\n    /* to client */\n    } else {\n        np->tcph->th_sport = htons(f->dp);\n        np->tcph->th_dport = htons(f->sp);\n\n        np->tcph->th_seq = htonl(ssn->server.next_seq);\n        np->tcph->th_ack = htonl(ssn->client.last_ack);\n    }\n\n    /* use parent time stamp */\n    memcpy(&np->ts, &parent->ts, sizeof(struct timeval));\n\n    SCLogDebug(\"np %p\", np);\n    PacketEnqueueNoLock(pq, np);\n\n    StatsIncr(tv, stt->counter_tcp_pseudo);\n    SCReturn;\nerror:\n    FlowDeReference(&np->flow);\n    SCReturn;\n}\n\n/** \\brief create packets in both directions to flush out logging\n *         and detection before switching protocols.\n *         In IDS mode, create first in packet dir, 2nd in opposing\n *         In IPS mode, do the reverse.\n *         Flag TCP engine that data needs to be inspected regardless\n *         of how far we are wrt inspect limits.\n */\nvoid StreamTcpDetectLogFlush(ThreadVars *tv, StreamTcpThread *stt, Flow *f, Packet *p,\n        PacketQueueNoLock *pq)\n{\n    TcpSession *ssn = f->protoctx;\n    ssn->client.flags |= STREAMTCP_STREAM_FLAG_TRIGGER_RAW;\n    ssn->server.flags |= STREAMTCP_STREAM_FLAG_TRIGGER_RAW;\n    bool ts = PKT_IS_TOSERVER(p) ? true : false;\n    ts ^= StreamTcpInlineMode();\n    StreamTcpPseudoPacketCreateDetectLogFlush(tv, stt, p, ssn, pq, ts^0);\n    StreamTcpPseudoPacketCreateDetectLogFlush(tv, stt, p, ssn, pq, ts^1);\n}\n\n/**\n * \\brief Run callback function on each TCP segment\n *\n * \\note when stream engine is running in inline mode all segments are used,\n *       in IDS/non-inline mode only ack'd segments are iterated.\n *\n * \\note Must be called under flow lock.\n *\n * \\return -1 in case of error, the number of segment in case of success\n *\n */\nint StreamTcpSegmentForEach(const Packet *p, uint8_t flag, StreamSegmentCallback CallbackFunc, void *data)\n{\n    TcpSession *ssn = NULL;\n    TcpStream *stream = NULL;\n    int ret = 0;\n    int cnt = 0;\n\n    if (p->flow == NULL)\n        return 0;\n\n    ssn = (TcpSession *)p->flow->protoctx;\n\n    if (ssn == NULL) {\n        return 0;\n    }\n\n    if (flag & FLOW_PKT_TOSERVER) {\n        stream = &(ssn->server);\n    } else {\n        stream = &(ssn->client);\n    }\n\n    /* for IDS, return ack'd segments. For IPS all. */\n    TcpSegment *seg;\n    RB_FOREACH(seg, TCPSEG, &stream->seg_tree) {\n        if (!((stream_config.flags & STREAMTCP_INIT_FLAG_INLINE)\n                    || SEQ_LT(seg->seq, stream->last_ack)))\n            break;\n\n        const uint8_t *seg_data;\n        uint32_t seg_datalen;\n        StreamingBufferSegmentGetData(&stream->sb, &seg->sbseg, &seg_data, &seg_datalen);\n\n        ret = CallbackFunc(p, data, seg_data, seg_datalen);\n        if (ret != 1) {\n            SCLogDebug(\"Callback function has failed\");\n            return -1;\n        }\n\n        cnt++;\n    }\n    return cnt;\n}\n\nint StreamTcpBypassEnabled(void)\n{\n    return (stream_config.flags & STREAMTCP_INIT_FLAG_BYPASS);\n}\n\n/**\n *  \\brief See if stream engine is operating in inline mode\n *\n *  \\retval 0 no\n *  \\retval 1 yes\n */\nint StreamTcpInlineMode(void)\n{\n    return (stream_config.flags & STREAMTCP_INIT_FLAG_INLINE) ? 1 : 0;\n}\n\n\nvoid TcpSessionSetReassemblyDepth(TcpSession *ssn, uint32_t size)\n{\n    if (size > ssn->reassembly_depth || size == 0) {\n        ssn->reassembly_depth = size;\n    }\n\n    return;\n}\n\nconst char *StreamTcpStateAsString(const enum TcpState state)\n{\n    const char *tcp_state = NULL;\n    switch (state) {\n        case TCP_NONE:\n            tcp_state = \"none\";\n            break;\n        case TCP_LISTEN:\n            tcp_state = \"listen\";\n            break;\n        case TCP_SYN_SENT:\n            tcp_state = \"syn_sent\";\n            break;\n        case TCP_SYN_RECV:\n            tcp_state = \"syn_recv\";\n            break;\n        case TCP_ESTABLISHED:\n            tcp_state = \"established\";\n            break;\n        case TCP_FIN_WAIT1:\n            tcp_state = \"fin_wait1\";\n            break;\n        case TCP_FIN_WAIT2:\n            tcp_state = \"fin_wait2\";\n            break;\n        case TCP_TIME_WAIT:\n            tcp_state = \"time_wait\";\n            break;\n        case TCP_LAST_ACK:\n            tcp_state = \"last_ack\";\n            break;\n        case TCP_CLOSE_WAIT:\n            tcp_state = \"close_wait\";\n            break;\n        case TCP_CLOSING:\n            tcp_state = \"closing\";\n            break;\n        case TCP_CLOSED:\n            tcp_state = \"closed\";\n            break;\n    }\n    return tcp_state;\n}\n\nconst char *StreamTcpSsnStateAsString(const TcpSession *ssn)\n{\n    if (ssn == NULL)\n        return NULL;\n    return StreamTcpStateAsString(ssn->state);\n}\n\n#ifdef UNITTESTS\n#include \"tests/stream-tcp.c\"\n#endif\n"], "fixing_code": ["/* Copyright (C) 2007-2013 Open Information Security Foundation\n *\n * You can copy, redistribute or modify this Program under the terms of\n * the GNU General Public License version 2 as published by the Free\n * Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * version 2 along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n */\n\n/**\n * \\ingroup decode\n *\n * @{\n */\n\n\n/**\n * \\file\n *\n * \\author Victor Julien <victor@inliniac.net>\n *\n * Decode TCP\n */\n\n#include \"suricata-common.h\"\n#include \"decode.h\"\n#include \"decode-tcp.h\"\n#include \"decode-events.h\"\n#include \"util-unittest.h\"\n#include \"util-debug.h\"\n#include \"util-optimize.h\"\n#include \"flow.h\"\n#include \"util-profiling.h\"\n#include \"pkt-var.h\"\n#include \"host.h\"\n\n#define SET_OPTS(dst, src) \\\n    (dst).type = (src).type; \\\n    (dst).len  = (src).len; \\\n    (dst).data = (src).data\n\nstatic void DecodeTCPOptions(Packet *p, const uint8_t *pkt, uint16_t pktlen)\n{\n    uint8_t tcp_opt_cnt = 0;\n    TCPOpt tcp_opts[TCP_OPTMAX];\n\n    uint16_t plen = pktlen;\n    while (plen)\n    {\n        const uint8_t type = *pkt;\n\n        /* single byte options */\n        if (type == TCP_OPT_EOL) {\n            break;\n        } else if (type == TCP_OPT_NOP) {\n            pkt++;\n            plen--;\n\n        /* multibyte options */\n        } else {\n            if (plen < 2) {\n                break;\n            }\n\n            const uint8_t olen = *(pkt+1);\n\n            /* we already know that the total options len is valid,\n             * so here the len of the specific option must be bad.\n             * Also check for invalid lengths 0 and 1. */\n            if (unlikely(olen > plen || olen < 2)) {\n                ENGINE_SET_INVALID_EVENT(p, TCP_OPT_INVALID_LEN);\n                return;\n            }\n\n            tcp_opts[tcp_opt_cnt].type = type;\n            tcp_opts[tcp_opt_cnt].len  = olen;\n            tcp_opts[tcp_opt_cnt].data = (olen > 2) ? (pkt+2) : NULL;\n\n            /* we are parsing the most commonly used opts to prevent\n             * us from having to walk the opts list for these all the\n             * time. */\n            switch (type) {\n                case TCP_OPT_WS:\n                    if (olen != TCP_OPT_WS_LEN) {\n                        ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);\n                    } else {\n                        if (p->tcpvars.ws.type != 0) {\n                            ENGINE_SET_EVENT(p,TCP_OPT_DUPLICATE);\n                        } else {\n                            SET_OPTS(p->tcpvars.ws, tcp_opts[tcp_opt_cnt]);\n                        }\n                    }\n                    break;\n                case TCP_OPT_MSS:\n                    if (olen != TCP_OPT_MSS_LEN) {\n                        ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);\n                    } else {\n                        if (p->tcpvars.mss.type != 0) {\n                            ENGINE_SET_EVENT(p,TCP_OPT_DUPLICATE);\n                        } else {\n                            SET_OPTS(p->tcpvars.mss, tcp_opts[tcp_opt_cnt]);\n                        }\n                    }\n                    break;\n                case TCP_OPT_SACKOK:\n                    if (olen != TCP_OPT_SACKOK_LEN) {\n                        ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);\n                    } else {\n                        if (p->tcpvars.sackok.type != 0) {\n                            ENGINE_SET_EVENT(p,TCP_OPT_DUPLICATE);\n                        } else {\n                            SET_OPTS(p->tcpvars.sackok, tcp_opts[tcp_opt_cnt]);\n                        }\n                    }\n                    break;\n                case TCP_OPT_TS:\n                    if (olen != TCP_OPT_TS_LEN) {\n                        ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);\n                    } else {\n                        if (p->tcpvars.ts_set) {\n                            ENGINE_SET_EVENT(p,TCP_OPT_DUPLICATE);\n                        } else {\n                            uint32_t values[2];\n                            memcpy(&values, tcp_opts[tcp_opt_cnt].data, sizeof(values));\n                            p->tcpvars.ts_val = SCNtohl(values[0]);\n                            p->tcpvars.ts_ecr = SCNtohl(values[1]);\n                            p->tcpvars.ts_set = true;\n                        }\n                    }\n                    break;\n                case TCP_OPT_SACK:\n                    SCLogDebug(\"SACK option, len %u\", olen);\n                    if ((olen != 2) &&\n                           (olen < TCP_OPT_SACK_MIN_LEN ||\n                            olen > TCP_OPT_SACK_MAX_LEN ||\n                            !((olen - 2) % 8 == 0)))\n                    {\n                        ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);\n                    } else {\n                        if (p->tcpvars.sack.type != 0) {\n                            ENGINE_SET_EVENT(p,TCP_OPT_DUPLICATE);\n                        } else {\n                            SET_OPTS(p->tcpvars.sack, tcp_opts[tcp_opt_cnt]);\n                        }\n                    }\n                    break;\n                case TCP_OPT_TFO:\n                    SCLogDebug(\"TFO option, len %u\", olen);\n                    if ((olen != 2) && (olen < TCP_OPT_TFO_MIN_LEN || olen > TCP_OPT_TFO_MAX_LEN ||\n                                               !(((olen - 2) & 0x1) == 0))) {\n                        ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);\n                    } else {\n                        if (p->tcpvars.tfo.type != 0) {\n                            ENGINE_SET_EVENT(p,TCP_OPT_DUPLICATE);\n                        } else {\n                            SET_OPTS(p->tcpvars.tfo, tcp_opts[tcp_opt_cnt]);\n                        }\n                    }\n                    break;\n                /* experimental options, could be TFO */\n                case TCP_OPT_EXP1:\n                case TCP_OPT_EXP2:\n                    SCLogDebug(\"TCP EXP option, len %u\", olen);\n                    if (olen == 4 || olen == 12) {\n                        uint16_t magic = SCNtohs(*(uint16_t *)tcp_opts[tcp_opt_cnt].data);\n                        if (magic == 0xf989) {\n                            if (p->tcpvars.tfo.type != 0) {\n                                ENGINE_SET_EVENT(p,TCP_OPT_DUPLICATE);\n                            } else {\n                                SET_OPTS(p->tcpvars.tfo, tcp_opts[tcp_opt_cnt]);\n                                p->tcpvars.tfo.type = TCP_OPT_TFO; // treat as regular TFO\n                            }\n                        }\n                    } else {\n                        ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);\n                    }\n                    break;\n                /* RFC 2385 MD5 option */\n                case TCP_OPT_MD5:\n                    SCLogDebug(\"MD5 option, len %u\", olen);\n                    if (olen != 18) {\n                        ENGINE_SET_INVALID_EVENT(p,TCP_OPT_INVALID_LEN);\n                    } else {\n                        /* we can't validate the option as the key is out of band */\n                        p->tcpvars.md5_option_present = true;\n                    }\n                    break;\n                /* RFC 5925 AO option */\n                case TCP_OPT_AO:\n                    SCLogDebug(\"AU option, len %u\", olen);\n                    if (olen < 4) {\n                        ENGINE_SET_INVALID_EVENT(p,TCP_OPT_INVALID_LEN);\n                    } else {\n                        /* we can't validate the option as the key is out of band */\n                        p->tcpvars.ao_option_present = true;\n                    }\n                    break;\n            }\n\n            pkt += olen;\n            plen -= olen;\n            tcp_opt_cnt++;\n        }\n    }\n}\n\nstatic int DecodeTCPPacket(ThreadVars *tv, Packet *p, const uint8_t *pkt, uint16_t len)\n{\n    if (unlikely(len < TCP_HEADER_LEN)) {\n        ENGINE_SET_INVALID_EVENT(p, TCP_PKT_TOO_SMALL);\n        return -1;\n    }\n\n    p->tcph = (TCPHdr *)pkt;\n\n    uint8_t hlen = TCP_GET_HLEN(p);\n    if (unlikely(len < hlen)) {\n        ENGINE_SET_INVALID_EVENT(p, TCP_HLEN_TOO_SMALL);\n        return -1;\n    }\n\n    uint8_t tcp_opt_len = hlen - TCP_HEADER_LEN;\n    if (unlikely(tcp_opt_len > TCP_OPTLENMAX)) {\n        ENGINE_SET_INVALID_EVENT(p, TCP_INVALID_OPTLEN);\n        return -1;\n    }\n\n    if (likely(tcp_opt_len > 0)) {\n        DecodeTCPOptions(p, pkt + TCP_HEADER_LEN, tcp_opt_len);\n    }\n\n    SET_TCP_SRC_PORT(p,&p->sp);\n    SET_TCP_DST_PORT(p,&p->dp);\n\n    p->proto = IPPROTO_TCP;\n\n    p->payload = (uint8_t *)pkt + hlen;\n    p->payload_len = len - hlen;\n\n    return 0;\n}\n\nint DecodeTCP(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p,\n        const uint8_t *pkt, uint16_t len)\n{\n    StatsIncr(tv, dtv->counter_tcp);\n\n    if (unlikely(DecodeTCPPacket(tv, p, pkt,len) < 0)) {\n        SCLogDebug(\"invalid TCP packet\");\n        CLEAR_TCP_PACKET(p);\n        return TM_ECODE_FAILED;\n    }\n\n#ifdef DEBUG\n    SCLogDebug(\"TCP sp: %\" PRIu32 \" -> dp: %\" PRIu32 \" - HLEN: %\" PRIu32 \" LEN: %\" PRIu32 \" %s%s%s%s%s%s\",\n        GET_TCP_SRC_PORT(p), GET_TCP_DST_PORT(p), TCP_GET_HLEN(p), len,\n        TCP_HAS_SACKOK(p) ? \"SACKOK \" : \"\", TCP_HAS_SACK(p) ? \"SACK \" : \"\",\n        TCP_HAS_WSCALE(p) ? \"WS \" : \"\", TCP_HAS_TS(p) ? \"TS \" : \"\",\n        TCP_HAS_MSS(p) ? \"MSS \" : \"\", TCP_HAS_TFO(p) ? \"TFO \" : \"\");\n#endif\n\n    FlowSetupPacket(p);\n\n    return TM_ECODE_OK;\n}\n\n#ifdef UNITTESTS\nstatic int TCPCalculateValidChecksumtest01(void)\n{\n    uint16_t csum = 0;\n\n    uint8_t raw_ipshdr[] = {\n        0x40, 0x8e, 0x7e, 0xb2, 0xc0, 0xa8, 0x01, 0x03};\n\n    uint8_t raw_tcp[] = {\n        0x00, 0x50, 0x8e, 0x16, 0x0d, 0x59, 0xcd, 0x3c,\n        0xcf, 0x0d, 0x21, 0x80, 0xa0, 0x12, 0x16, 0xa0,\n        0xfa, 0x03, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4,\n        0x04, 0x02, 0x08, 0x0a, 0x6e, 0x18, 0x78, 0x73,\n        0x01, 0x71, 0x74, 0xde, 0x01, 0x03, 0x03, 02};\n\n    csum = *( ((uint16_t *)raw_tcp) + 8);\n\n    FAIL_IF(TCPChecksum((uint16_t *)raw_ipshdr,\n            (uint16_t *)raw_tcp, sizeof(raw_tcp), csum) != 0);\n    PASS;\n}\n\nstatic int TCPCalculateInvalidChecksumtest02(void)\n{\n    uint16_t csum = 0;\n\n    uint8_t raw_ipshdr[] = {\n        0x40, 0x8e, 0x7e, 0xb2, 0xc0, 0xa8, 0x01, 0x03};\n\n    uint8_t raw_tcp[] = {\n        0x00, 0x50, 0x8e, 0x16, 0x0d, 0x59, 0xcd, 0x3c,\n        0xcf, 0x0d, 0x21, 0x80, 0xa0, 0x12, 0x16, 0xa0,\n        0xfa, 0x03, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4,\n        0x04, 0x02, 0x08, 0x0a, 0x6e, 0x18, 0x78, 0x73,\n        0x01, 0x71, 0x74, 0xde, 0x01, 0x03, 0x03, 03};\n\n    csum = *( ((uint16_t *)raw_tcp) + 8);\n\n    FAIL_IF(TCPChecksum((uint16_t *) raw_ipshdr,\n            (uint16_t *)raw_tcp, sizeof(raw_tcp), csum) == 0);\n    PASS;\n}\n\nstatic int TCPV6CalculateValidChecksumtest03(void)\n{\n    uint16_t csum = 0;\n\n    static uint8_t raw_ipv6[] = {\n        0x00, 0x60, 0x97, 0x07, 0x69, 0xea, 0x00, 0x00,\n        0x86, 0x05, 0x80, 0xda, 0x86, 0xdd, 0x60, 0x00,\n        0x00, 0x00, 0x00, 0x20, 0x06, 0x40, 0x3f, 0xfe,\n        0x05, 0x07, 0x00, 0x00, 0x00, 0x01, 0x02, 0x00,\n        0x86, 0xff, 0xfe, 0x05, 0x80, 0xda, 0x3f, 0xfe,\n        0x05, 0x01, 0x04, 0x10, 0x00, 0x00, 0x02, 0xc0,\n        0xdf, 0xff, 0xfe, 0x47, 0x03, 0x3e, 0x03, 0xfe,\n        0x00, 0x16, 0xd6, 0x76, 0xf5, 0x2d, 0x0c, 0x7a,\n        0x08, 0x77, 0x80, 0x10, 0x21, 0x5c, 0xc2, 0xf1,\n        0x00, 0x00, 0x01, 0x01, 0x08, 0x0a, 0x00, 0x08,\n        0xca, 0x5a, 0x00, 0x01, 0x69, 0x27};\n\n    csum = *( ((uint16_t *)(raw_ipv6 + 70)));\n\n    FAIL_IF(TCPV6Checksum((uint16_t *)(raw_ipv6 + 14 + 8),\n            (uint16_t *)(raw_ipv6 + 54), 32, csum) != 0);\n    PASS;\n}\n\nstatic int TCPV6CalculateInvalidChecksumtest04(void)\n{\n    uint16_t csum = 0;\n\n    static uint8_t raw_ipv6[] = {\n        0x00, 0x60, 0x97, 0x07, 0x69, 0xea, 0x00, 0x00,\n        0x86, 0x05, 0x80, 0xda, 0x86, 0xdd, 0x60, 0x00,\n        0x00, 0x00, 0x00, 0x20, 0x06, 0x40, 0x3f, 0xfe,\n        0x05, 0x07, 0x00, 0x00, 0x00, 0x01, 0x02, 0x00,\n        0x86, 0xff, 0xfe, 0x05, 0x80, 0xda, 0x3f, 0xfe,\n        0x05, 0x01, 0x04, 0x10, 0x00, 0x00, 0x02, 0xc0,\n        0xdf, 0xff, 0xfe, 0x47, 0x03, 0x3e, 0x03, 0xfe,\n        0x00, 0x16, 0xd6, 0x76, 0xf5, 0x2d, 0x0c, 0x7a,\n        0x08, 0x77, 0x80, 0x10, 0x21, 0x5c, 0xc2, 0xf1,\n        0x00, 0x00, 0x01, 0x01, 0x08, 0x0a, 0x00, 0x08,\n        0xca, 0x5a, 0x00, 0x01, 0x69, 0x28};\n\n    csum = *( ((uint16_t *)(raw_ipv6 + 70)));\n\n    FAIL_IF(TCPV6Checksum((uint16_t *)(raw_ipv6 + 14 + 8),\n            (uint16_t *)(raw_ipv6 + 54), 32, csum) == 0);\n    PASS;\n}\n\n/** \\test Get the wscale of 2 */\nstatic int TCPGetWscaleTest01(void)\n{\n    int retval = 0;\n    static uint8_t raw_tcp[] = {0xda, 0xc1, 0x00, 0x50, 0xb6, 0x21, 0x7f, 0x58,\n                                0x00, 0x00, 0x00, 0x00, 0xa0, 0x02, 0x16, 0xd0,\n                                0x8a, 0xaf, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4,\n                                0x04, 0x02, 0x08, 0x0a, 0x00, 0x62, 0x88, 0x28,\n                                0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x02};\n    Packet *p = PacketGetFromAlloc();\n    if (unlikely(p == NULL))\n        return 0;\n    IPV4Hdr ip4h;\n    ThreadVars tv;\n    DecodeThreadVars dtv;\n\n    memset(&tv, 0, sizeof(ThreadVars));\n    memset(&dtv, 0, sizeof(DecodeThreadVars));\n    memset(&ip4h, 0, sizeof(IPV4Hdr));\n\n    p->src.family = AF_INET;\n    p->dst.family = AF_INET;\n    p->ip4h = &ip4h;\n\n\n    FlowInitConfig(FLOW_QUIET);\n    DecodeTCP(&tv, &dtv, p, raw_tcp, sizeof(raw_tcp));\n\n    if (p->tcph == NULL) {\n        printf(\"tcp packet decode failed: \");\n        goto end;\n    }\n\n    uint8_t wscale = TCP_GET_WSCALE(p);\n    if (wscale != 2) {\n        printf(\"wscale %\"PRIu8\", expected 2: \", wscale);\n        goto end;\n    }\n\n    retval = 1;\nend:\n    PACKET_RECYCLE(p);\n    FlowShutdown();\n    SCFree(p);\n    return retval;\n}\n\n/** \\test Get the wscale of 15, so see if return 0 properly */\nstatic int TCPGetWscaleTest02(void)\n{\n    int retval = 0;\n    static uint8_t raw_tcp[] = {0xda, 0xc1, 0x00, 0x50, 0xb6, 0x21, 0x7f, 0x58,\n                                0x00, 0x00, 0x00, 0x00, 0xa0, 0x02, 0x16, 0xd0,\n                                0x8a, 0xaf, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4,\n                                0x04, 0x02, 0x08, 0x0a, 0x00, 0x62, 0x88, 0x28,\n                                0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x0f};\n    Packet *p = PacketGetFromAlloc();\n    if (unlikely(p == NULL))\n        return 0;\n    IPV4Hdr ip4h;\n    ThreadVars tv;\n    DecodeThreadVars dtv;\n\n    memset(&tv, 0, sizeof(ThreadVars));\n    memset(&dtv, 0, sizeof(DecodeThreadVars));\n    memset(&ip4h, 0, sizeof(IPV4Hdr));\n\n    p->src.family = AF_INET;\n    p->dst.family = AF_INET;\n    p->ip4h = &ip4h;\n\n    FlowInitConfig(FLOW_QUIET);\n    DecodeTCP(&tv, &dtv, p, raw_tcp, sizeof(raw_tcp));\n\n    if (p->tcph == NULL) {\n        printf(\"tcp packet decode failed: \");\n        goto end;\n    }\n\n    uint8_t wscale = TCP_GET_WSCALE(p);\n    if (wscale != 0) {\n        printf(\"wscale %\"PRIu8\", expected 0: \", wscale);\n        goto end;\n    }\n\n    retval = 1;\nend:\n    PACKET_RECYCLE(p);\n    FlowShutdown();\n    SCFree(p);\n    return retval;\n}\n\n/** \\test Get the wscale, but it's missing, so see if return 0 properly */\nstatic int TCPGetWscaleTest03(void)\n{\n    int retval = 0;\n    static uint8_t raw_tcp[] = {0xda, 0xc1, 0x00, 0x50, 0xb6, 0x21, 0x7f, 0x59,\n                                0xdd, 0xa3, 0x6f, 0xf8, 0x80, 0x10, 0x05, 0xb4,\n                                0x7c, 0x70, 0x00, 0x00, 0x01, 0x01, 0x08, 0x0a,\n                                0x00, 0x62, 0x88, 0x9e, 0x00, 0x00, 0x00, 0x00};\n    Packet *p = PacketGetFromAlloc();\n    if (unlikely(p == NULL))\n        return 0;\n    IPV4Hdr ip4h;\n    ThreadVars tv;\n    DecodeThreadVars dtv;\n\n    memset(&tv, 0, sizeof(ThreadVars));\n    memset(&dtv, 0, sizeof(DecodeThreadVars));\n    memset(&ip4h, 0, sizeof(IPV4Hdr));\n\n    p->src.family = AF_INET;\n    p->dst.family = AF_INET;\n    p->ip4h = &ip4h;\n\n    FlowInitConfig(FLOW_QUIET);\n    DecodeTCP(&tv, &dtv, p, raw_tcp, sizeof(raw_tcp));\n\n    if (p->tcph == NULL) {\n        printf(\"tcp packet decode failed: \");\n        goto end;\n    }\n\n    uint8_t wscale = TCP_GET_WSCALE(p);\n    if (wscale != 0) {\n        printf(\"wscale %\"PRIu8\", expected 0: \", wscale);\n        goto end;\n    }\n\n    retval = 1;\nend:\n    PACKET_RECYCLE(p);\n    FlowShutdown();\n    SCFree(p);\n    return retval;\n}\n\nstatic int TCPGetSackTest01(void)\n{\n    int retval = 0;\n    static uint8_t raw_tcp[] = {\n        0x00, 0x50, 0x06, 0xa6, 0xfa, 0x87, 0x0b, 0xf5,\n        0xf1, 0x59, 0x02, 0xe0, 0xa0, 0x10, 0x3e, 0xbc,\n        0x1d, 0xe7, 0x00, 0x00, 0x01, 0x01, 0x05, 0x12,\n        0xf1, 0x59, 0x13, 0xfc, 0xf1, 0x59, 0x1f, 0x64,\n        0xf1, 0x59, 0x08, 0x94, 0xf1, 0x59, 0x0e, 0x48 };\n    static uint8_t raw_tcp_sack[] = {\n        0xf1, 0x59, 0x13, 0xfc, 0xf1, 0x59, 0x1f, 0x64,\n        0xf1, 0x59, 0x08, 0x94, 0xf1, 0x59, 0x0e, 0x48 };\n    Packet *p = PacketGetFromAlloc();\n    if (unlikely(p == NULL))\n        return 0;\n    IPV4Hdr ip4h;\n    ThreadVars tv;\n    DecodeThreadVars dtv;\n\n    memset(&tv, 0, sizeof(ThreadVars));\n    memset(&dtv, 0, sizeof(DecodeThreadVars));\n    memset(&ip4h, 0, sizeof(IPV4Hdr));\n\n    p->src.family = AF_INET;\n    p->dst.family = AF_INET;\n    p->ip4h = &ip4h;\n\n    FlowInitConfig(FLOW_QUIET);\n    DecodeTCP(&tv, &dtv, p, raw_tcp, sizeof(raw_tcp));\n\n    if (p->tcph == NULL) {\n        printf(\"tcp packet decode failed: \");\n        goto end;\n    }\n\n    if (!TCP_HAS_SACK(p)) {\n        printf(\"tcp packet sack not decoded: \");\n        goto end;\n    }\n\n    int sack = TCP_GET_SACK_CNT(p);\n    if (sack != 2) {\n        printf(\"expected 2 sack records, got %u: \", TCP_GET_SACK_CNT(p));\n        goto end;\n    }\n\n    const uint8_t *sackptr = TCP_GET_SACK_PTR(p);\n    if (sackptr == NULL) {\n        printf(\"no sack data: \");\n        goto end;\n    }\n\n    if (memcmp(sackptr, raw_tcp_sack, 16) != 0) {\n        printf(\"malformed sack data: \");\n        goto end;\n    }\n\n    retval = 1;\nend:\n    PACKET_RECYCLE(p);\n    FlowShutdown();\n    SCFree(p);\n    return retval;\n}\n#endif /* UNITTESTS */\n\nvoid DecodeTCPRegisterTests(void)\n{\n#ifdef UNITTESTS\n    UtRegisterTest(\"TCPCalculateValidChecksumtest01\",\n                   TCPCalculateValidChecksumtest01);\n    UtRegisterTest(\"TCPCalculateInvalidChecksumtest02\",\n                   TCPCalculateInvalidChecksumtest02);\n    UtRegisterTest(\"TCPV6CalculateValidChecksumtest03\",\n                   TCPV6CalculateValidChecksumtest03);\n    UtRegisterTest(\"TCPV6CalculateInvalidChecksumtest04\",\n                   TCPV6CalculateInvalidChecksumtest04);\n    UtRegisterTest(\"TCPGetWscaleTest01\", TCPGetWscaleTest01);\n    UtRegisterTest(\"TCPGetWscaleTest02\", TCPGetWscaleTest02);\n    UtRegisterTest(\"TCPGetWscaleTest03\", TCPGetWscaleTest03);\n    UtRegisterTest(\"TCPGetSackTest01\", TCPGetSackTest01);\n#endif /* UNITTESTS */\n}\n/**\n * @}\n */\n", "/* Copyright (C) 2007-2013 Open Information Security Foundation\n *\n * You can copy, redistribute or modify this Program under the terms of\n * the GNU General Public License version 2 as published by the Free\n * Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * version 2 along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n */\n\n/**\n * \\file\n *\n * \\author Victor Julien <victor@inliniac.net>\n * \\todo RAW* macro's should be returning the raw value, not the host order\n */\n\n#ifndef __DECODE_TCP_H__\n#define __DECODE_TCP_H__\n\n#define TCP_HEADER_LEN                       20\n#define TCP_OPTLENMAX                        40\n#define TCP_OPTMAX                           20 /* every opt is at least 2 bytes\n                                                 * (type + len), except EOL and NOP */\n\n/* TCP flags */\n\n#define TH_FIN                               0x01\n#define TH_SYN                               0x02\n#define TH_RST                               0x04\n#define TH_PUSH                              0x08\n#define TH_ACK                               0x10\n#define TH_URG                               0x20\n/** Establish a new connection reducing window */\n#define TH_ECN                               0x40\n/** Echo Congestion flag */\n#define TH_CWR                               0x80\n\n/* tcp option codes */\n#define TCP_OPT_EOL                          0x00\n#define TCP_OPT_NOP                          0x01\n#define TCP_OPT_MSS                          0x02\n#define TCP_OPT_WS                           0x03\n#define TCP_OPT_SACKOK                       0x04\n#define TCP_OPT_SACK                         0x05\n#define TCP_OPT_TS                           0x08\n#define TCP_OPT_TFO                          0x22   /* TCP Fast Open */\n#define TCP_OPT_EXP1                         0xfd   /* Experimental, could be TFO */\n#define TCP_OPT_EXP2                         0xfe   /* Experimental, could be TFO */\n#define TCP_OPT_MD5                          0x13   /* 19: RFC 2385 TCP MD5 option */\n#define TCP_OPT_AO                           0x1d   /* 29: RFC 5925 TCP AO option */\n\n#define TCP_OPT_SACKOK_LEN                   2\n#define TCP_OPT_WS_LEN                       3\n#define TCP_OPT_TS_LEN                       10\n#define TCP_OPT_MSS_LEN                      4\n#define TCP_OPT_SACK_MIN_LEN                 10 /* hdr 2, 1 pair 8 = 10 */\n#define TCP_OPT_SACK_MAX_LEN                 34 /* hdr 2, 4 pair 32= 34 */\n#define TCP_OPT_TFO_MIN_LEN                  6  /* kind, len, 6 */\n#define TCP_OPT_TFO_MAX_LEN                  18 /* kind, len, 18 */\n\n/** Max valid wscale value. */\n#define TCP_WSCALE_MAX                       14\n\n#define TCP_GET_RAW_OFFSET(tcph)             (((tcph)->th_offx2 & 0xf0) >> 4)\n#define TCP_GET_RAW_X2(tcph)                 (unsigned char)((tcph)->th_offx2 & 0x0f)\n#define TCP_GET_RAW_SRC_PORT(tcph)           SCNtohs((tcph)->th_sport)\n#define TCP_GET_RAW_DST_PORT(tcph)           SCNtohs((tcph)->th_dport)\n\n#define TCP_SET_RAW_TCP_OFFSET(tcph, value)  ((tcph)->th_offx2 = (unsigned char)(((tcph)->th_offx2 & 0x0f) | (value << 4)))\n#define TCP_SET_RAW_TCP_X2(tcph, value)      ((tcph)->th_offx2 = (unsigned char)(((tcph)->th_offx2 & 0xf0) | (value & 0x0f)))\n\n#define TCP_GET_RAW_SEQ(tcph)                SCNtohl((tcph)->th_seq)\n#define TCP_GET_RAW_ACK(tcph)                SCNtohl((tcph)->th_ack)\n\n#define TCP_GET_RAW_WINDOW(tcph)             SCNtohs((tcph)->th_win)\n#define TCP_GET_RAW_URG_POINTER(tcph)        SCNtohs((tcph)->th_urp)\n#define TCP_GET_RAW_SUM(tcph)                SCNtohs((tcph)->th_sum)\n\n/** macro for getting the first timestamp from the packet in host order */\n#define TCP_GET_TSVAL(p)                    ((p)->tcpvars.ts_val)\n\n/** macro for getting the second timestamp from the packet in host order. */\n#define TCP_GET_TSECR(p)                    ((p)->tcpvars.ts_ecr)\n\n#define TCP_HAS_WSCALE(p)                   ((p)->tcpvars.ws.type == TCP_OPT_WS)\n#define TCP_HAS_SACK(p)                     ((p)->tcpvars.sack.type == TCP_OPT_SACK)\n#define TCP_HAS_SACKOK(p)                   ((p)->tcpvars.sackok.type == TCP_OPT_SACKOK)\n#define TCP_HAS_TS(p)                       ((p)->tcpvars.ts_set)\n#define TCP_HAS_MSS(p)                      ((p)->tcpvars.mss.type == TCP_OPT_MSS)\n#define TCP_HAS_TFO(p)                      ((p)->tcpvars.tfo.type == TCP_OPT_TFO)\n\n/** macro for getting the wscale from the packet. */\n#define TCP_GET_WSCALE(p)                    (TCP_HAS_WSCALE((p)) ? \\\n                                                (((*(uint8_t *)(p)->tcpvars.ws.data) <= TCP_WSCALE_MAX) ? \\\n                                                  (*(uint8_t *)((p)->tcpvars.ws.data)) : 0) : 0)\n\n#define TCP_GET_SACKOK(p)                    (TCP_HAS_SACKOK((p)) ? 1 : 0)\n#define TCP_GET_SACK_PTR(p)                  TCP_HAS_SACK((p)) ? (p)->tcpvars.sack.data : NULL\n#define TCP_GET_SACK_CNT(p)                  (TCP_HAS_SACK((p)) ? (((p)->tcpvars.sack.len - 2) / 8) : 0)\n#define TCP_GET_MSS(p)                       SCNtohs(*(uint16_t *)((p)->tcpvars.mss.data))\n\n#define TCP_GET_OFFSET(p)                    TCP_GET_RAW_OFFSET((p)->tcph)\n#define TCP_GET_X2(p)                        TCP_GET_RAW_X2((p)->tcph)\n#define TCP_GET_HLEN(p)                      (TCP_GET_OFFSET((p)) << 2)\n#define TCP_GET_SRC_PORT(p)                  TCP_GET_RAW_SRC_PORT((p)->tcph)\n#define TCP_GET_DST_PORT(p)                  TCP_GET_RAW_DST_PORT((p)->tcph)\n#define TCP_GET_SEQ(p)                       TCP_GET_RAW_SEQ((p)->tcph)\n#define TCP_GET_ACK(p)                       TCP_GET_RAW_ACK((p)->tcph)\n#define TCP_GET_WINDOW(p)                    TCP_GET_RAW_WINDOW((p)->tcph)\n#define TCP_GET_URG_POINTER(p)               TCP_GET_RAW_URG_POINTER((p)->tcph)\n#define TCP_GET_SUM(p)                       TCP_GET_RAW_SUM((p)->tcph)\n#define TCP_GET_FLAGS(p)                     (p)->tcph->th_flags\n\n#define TCP_ISSET_FLAG_FIN(p)                ((p)->tcph->th_flags & TH_FIN)\n#define TCP_ISSET_FLAG_SYN(p)                ((p)->tcph->th_flags & TH_SYN)\n#define TCP_ISSET_FLAG_RST(p)                ((p)->tcph->th_flags & TH_RST)\n#define TCP_ISSET_FLAG_PUSH(p)               ((p)->tcph->th_flags & TH_PUSH)\n#define TCP_ISSET_FLAG_ACK(p)                ((p)->tcph->th_flags & TH_ACK)\n#define TCP_ISSET_FLAG_URG(p)                ((p)->tcph->th_flags & TH_URG)\n#define TCP_ISSET_FLAG_RES2(p)               ((p)->tcph->th_flags & TH_RES2)\n#define TCP_ISSET_FLAG_RES1(p)               ((p)->tcph->th_flags & TH_RES1)\n\ntypedef struct TCPOpt_ {\n    uint8_t type;\n    uint8_t len;\n    const uint8_t *data;\n} TCPOpt;\n\ntypedef struct TCPOptSackRecord_ {\n    uint32_t le;        /**< left edge, network order */\n    uint32_t re;        /**< right edge, network order */\n} TCPOptSackRecord;\n\ntypedef struct TCPHdr_\n{\n    uint16_t th_sport;  /**< source port */\n    uint16_t th_dport;  /**< destination port */\n    uint32_t th_seq;    /**< sequence number */\n    uint32_t th_ack;    /**< acknowledgement number */\n    uint8_t th_offx2;   /**< offset and reserved */\n    uint8_t th_flags;   /**< pkt flags */\n    uint16_t th_win;    /**< pkt window */\n    uint16_t th_sum;    /**< checksum */\n    uint16_t th_urp;    /**< urgent pointer */\n} __attribute__((__packed__)) TCPHdr;\n\ntypedef struct TCPVars_\n{\n    /* commonly used and needed opts */\n    bool md5_option_present;\n    bool ao_option_present;\n    bool ts_set;\n    uint32_t ts_val;    /* host-order */\n    uint32_t ts_ecr;    /* host-order */\n    TCPOpt sack;\n    TCPOpt sackok;\n    TCPOpt ws;\n    TCPOpt mss;\n    TCPOpt tfo;         /* tcp fast open */\n} TCPVars;\n\n#define CLEAR_TCP_PACKET(p) {   \\\n    (p)->level4_comp_csum = -1; \\\n    PACKET_CLEAR_L4VARS((p));   \\\n    (p)->tcph = NULL;           \\\n}\n\nvoid DecodeTCPRegisterTests(void);\n\n/** -------- Inline functions ------- */\nstatic inline uint16_t TCPChecksum(uint16_t *, uint16_t *, uint16_t, uint16_t);\nstatic inline uint16_t TCPV6Checksum(uint16_t *, uint16_t *, uint16_t, uint16_t);\n\n/**\n * \\brief Calculate or validate the checksum for the TCP packet\n *\n * \\param shdr Pointer to source address field from the IP packet.  Used as a\n *             part of the pseudoheader for computing the checksum\n * \\param pkt  Pointer to the start of the TCP packet\n * \\param tlen Total length of the TCP packet(header + payload)\n * \\param init The current checksum if validating, 0 if generating.\n *\n * \\retval csum For validation 0 will be returned for success, for calculation\n *    this will be the checksum.\n */\nstatic inline uint16_t TCPChecksum(uint16_t *shdr, uint16_t *pkt,\n                                   uint16_t tlen, uint16_t init)\n{\n    uint16_t pad = 0;\n    uint32_t csum = init;\n\n    csum += shdr[0] + shdr[1] + shdr[2] + shdr[3] + htons(6) + htons(tlen);\n\n    csum += pkt[0] + pkt[1] + pkt[2] + pkt[3] + pkt[4] + pkt[5] + pkt[6] +\n        pkt[7] + pkt[9];\n\n    tlen -= 20;\n    pkt += 10;\n\n    while (tlen >= 32) {\n        csum += pkt[0] + pkt[1] + pkt[2] + pkt[3] + pkt[4] + pkt[5] + pkt[6] +\n            pkt[7] +\n            pkt[8] +\n            pkt[9] + pkt[10] + pkt[11] + pkt[12] + pkt[13] +\n            pkt[14] + pkt[15];\n        tlen -= 32;\n        pkt += 16;\n    }\n\n    while(tlen >= 8) {\n        csum += pkt[0] + pkt[1] + pkt[2] + pkt[3];\n        tlen -= 8;\n        pkt += 4;\n    }\n\n    while(tlen >= 4) {\n        csum += pkt[0] + pkt[1];\n        tlen -= 4;\n        pkt += 2;\n    }\n\n    while (tlen > 1) {\n        csum += pkt[0];\n        pkt += 1;\n        tlen -= 2;\n    }\n\n    if (tlen == 1) {\n        *(uint8_t *)(&pad) = (*(uint8_t *)pkt);\n        csum += pad;\n    }\n\n    csum = (csum >> 16) + (csum & 0x0000FFFF);\n    csum += (csum >> 16);\n\n    return (uint16_t)~csum;\n}\n\n/**\n * \\brief Calculate or validate the checksum for the TCP packet\n *\n * \\param shdr Pointer to source address field from the IPV6 packet.  Used as a\n *             part of the psuedoheader for computing the checksum\n * \\param pkt  Pointer to the start of the TCP packet\n * \\param tlen Total length of the TCP packet(header + payload)\n * \\param init The current checksum if validating, 0 if generating.\n *\n * \\retval csum For validation 0 will be returned for success, for calculation\n *    this will be the checksum.\n */\nstatic inline uint16_t TCPV6Checksum(uint16_t *shdr, uint16_t *pkt,\n                                     uint16_t tlen, uint16_t init)\n{\n    uint16_t pad = 0;\n    uint32_t csum = init;\n\n    csum += shdr[0] + shdr[1] + shdr[2] + shdr[3] + shdr[4] + shdr[5] +\n        shdr[6] +  shdr[7] + shdr[8] + shdr[9] + shdr[10] + shdr[11] +\n        shdr[12] + shdr[13] + shdr[14] + shdr[15] + htons(6) + htons(tlen);\n\n    csum += pkt[0] + pkt[1] + pkt[2] + pkt[3] + pkt[4] + pkt[5] + pkt[6] +\n        pkt[7] + pkt[9];\n\n    tlen -= 20;\n    pkt += 10;\n\n    while (tlen >= 32) {\n        csum += pkt[0] + pkt[1] + pkt[2] + pkt[3] + pkt[4] + pkt[5] + pkt[6] +\n            pkt[7] + pkt[8] + pkt[9] + pkt[10] + pkt[11] + pkt[12] + pkt[13] +\n            pkt[14] + pkt[15];\n        tlen -= 32;\n        pkt += 16;\n    }\n\n    while(tlen >= 8) {\n        csum += pkt[0] + pkt[1] + pkt[2] + pkt[3];\n        tlen -= 8;\n        pkt += 4;\n    }\n\n    while(tlen >= 4) {\n        csum += pkt[0] + pkt[1];\n        tlen -= 4;\n        pkt += 2;\n    }\n\n    while (tlen > 1) {\n        csum += pkt[0];\n        pkt += 1;\n        tlen -= 2;\n    }\n\n    if (tlen == 1) {\n        *(uint8_t *)(&pad) = (*(uint8_t *)pkt);\n        csum += pad;\n    }\n\n    csum = (csum >> 16) + (csum & 0x0000FFFF);\n    csum += (csum >> 16);\n\n    return (uint16_t)~csum;\n}\n\n\n#endif /* __DECODE_TCP_H__ */\n\n", "/* Copyright (C) 2007-2021 Open Information Security Foundation\n *\n * You can copy, redistribute or modify this Program under the terms of\n * the GNU General Public License version 2 as published by the Free\n * Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * version 2 along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n */\n\n/**\n * \\file\n *\n * \\author Victor Julien <victor@inliniac.net>\n * \\author Gurvinder Singh <gurvindersinghdahiya@gmail.com>\n *\n * TCP stream tracking and reassembly engine.\n *\n * \\todo - 4WHS: what if after the 2nd SYN we turn out to be normal 3WHS anyway?\n */\n\n#include \"suricata-common.h\"\n#include \"suricata.h\"\n\n#include \"decode.h\"\n#include \"debug.h\"\n#include \"detect.h\"\n\n#include \"flow.h\"\n#include \"flow-util.h\"\n\n#include \"conf.h\"\n#include \"conf-yaml-loader.h\"\n\n#include \"threads.h\"\n#include \"threadvars.h\"\n#include \"tm-threads.h\"\n\n#include \"util-pool.h\"\n#include \"util-pool-thread.h\"\n#include \"util-checksum.h\"\n#include \"util-unittest.h\"\n#include \"util-print.h\"\n#include \"util-debug.h\"\n#include \"util-device.h\"\n\n#include \"stream-tcp-private.h\"\n#include \"stream-tcp-reassemble.h\"\n#include \"stream-tcp.h\"\n#include \"stream-tcp-inline.h\"\n#include \"stream-tcp-sack.h\"\n#include \"stream-tcp-util.h\"\n#include \"stream.h\"\n\n#include \"pkt-var.h\"\n#include \"host.h\"\n\n#include \"app-layer.h\"\n#include \"app-layer-parser.h\"\n#include \"app-layer-protos.h\"\n#include \"app-layer-htp-mem.h\"\n\n#include \"util-host-os-info.h\"\n#include \"util-privs.h\"\n#include \"util-profiling.h\"\n#include \"util-misc.h\"\n#include \"util-validate.h\"\n#include \"util-runmodes.h\"\n#include \"util-random.h\"\n\n#include \"source-pcap-file.h\"\n\n//#define DEBUG\n\n#define STREAMTCP_DEFAULT_PREALLOC              2048\n#define STREAMTCP_DEFAULT_MEMCAP                (64 * 1024 * 1024)  /* 64mb */\n#define STREAMTCP_DEFAULT_REASSEMBLY_MEMCAP     (256 * 1024 * 1024) /* 256mb */\n#define STREAMTCP_DEFAULT_TOSERVER_CHUNK_SIZE   2560\n#define STREAMTCP_DEFAULT_TOCLIENT_CHUNK_SIZE   2560\n#define STREAMTCP_DEFAULT_MAX_SYNACK_QUEUED     5\n\n#define STREAMTCP_NEW_TIMEOUT                   60\n#define STREAMTCP_EST_TIMEOUT                   3600\n#define STREAMTCP_CLOSED_TIMEOUT                120\n\n#define STREAMTCP_EMERG_NEW_TIMEOUT             10\n#define STREAMTCP_EMERG_EST_TIMEOUT             300\n#define STREAMTCP_EMERG_CLOSED_TIMEOUT          20\n\nstatic int StreamTcpHandleFin(ThreadVars *tv, StreamTcpThread *, TcpSession *, Packet *, PacketQueueNoLock *);\nvoid StreamTcpReturnStreamSegments (TcpStream *);\nvoid StreamTcpInitConfig(bool);\nint StreamTcpGetFlowState(void *);\nvoid StreamTcpSetOSPolicy(TcpStream*, Packet*);\n\nstatic int StreamTcpValidateTimestamp(TcpSession * , Packet *);\nstatic int StreamTcpHandleTimestamp(TcpSession * , Packet *);\nstatic int StreamTcpValidateRst(TcpSession * , Packet *);\nstatic inline int StreamTcpValidateAck(TcpSession *ssn, TcpStream *, Packet *);\nstatic int StreamTcpStateDispatch(ThreadVars *tv, Packet *p,\n        StreamTcpThread *stt, TcpSession *ssn, PacketQueueNoLock *pq,\n        uint8_t state);\n\nextern int g_detect_disabled;\n\nstatic PoolThread *ssn_pool = NULL;\nstatic SCMutex ssn_pool_mutex = SCMUTEX_INITIALIZER; /**< init only, protect initializing and growing pool */\n#ifdef DEBUG\nstatic uint64_t ssn_pool_cnt = 0; /** counts ssns, protected by ssn_pool_mutex */\n#endif\n\nTcpStreamCnf stream_config;\nuint64_t StreamTcpReassembleMemuseGlobalCounter(void);\nSC_ATOMIC_DECLARE(uint64_t, st_memuse);\n\nvoid StreamTcpInitMemuse(void)\n{\n    SC_ATOMIC_INIT(st_memuse);\n}\n\nvoid StreamTcpIncrMemuse(uint64_t size)\n{\n    (void) SC_ATOMIC_ADD(st_memuse, size);\n    SCLogDebug(\"STREAM %\"PRIu64\", incr %\"PRIu64, StreamTcpMemuseCounter(), size);\n    return;\n}\n\nvoid StreamTcpDecrMemuse(uint64_t size)\n{\n#ifdef DEBUG_VALIDATION\n    uint64_t presize = SC_ATOMIC_GET(st_memuse);\n    if (RunmodeIsUnittests()) {\n        BUG_ON(presize > UINT_MAX);\n    }\n#endif\n\n    (void) SC_ATOMIC_SUB(st_memuse, size);\n\n#ifdef DEBUG_VALIDATION\n    if (RunmodeIsUnittests()) {\n        uint64_t postsize = SC_ATOMIC_GET(st_memuse);\n        BUG_ON(postsize > presize);\n    }\n#endif\n    SCLogDebug(\"STREAM %\"PRIu64\", decr %\"PRIu64, StreamTcpMemuseCounter(), size);\n    return;\n}\n\nuint64_t StreamTcpMemuseCounter(void)\n{\n    uint64_t memusecopy = SC_ATOMIC_GET(st_memuse);\n    return memusecopy;\n}\n\n/**\n *  \\brief Check if alloc'ing \"size\" would mean we're over memcap\n *\n *  \\retval 1 if in bounds\n *  \\retval 0 if not in bounds\n */\nint StreamTcpCheckMemcap(uint64_t size)\n{\n    uint64_t memcapcopy = SC_ATOMIC_GET(stream_config.memcap);\n    if (memcapcopy == 0 || size + SC_ATOMIC_GET(st_memuse) <= memcapcopy)\n        return 1;\n    return 0;\n}\n\n/**\n *  \\brief Update memcap value\n *\n *  \\param size new memcap value\n */\nint StreamTcpSetMemcap(uint64_t size)\n{\n    if (size == 0 || (uint64_t)SC_ATOMIC_GET(st_memuse) < size) {\n        SC_ATOMIC_SET(stream_config.memcap, size);\n        return 1;\n    }\n\n    return 0;\n}\n\n/**\n *  \\brief Return memcap value\n *\n *  \\param memcap memcap value\n */\nuint64_t StreamTcpGetMemcap(void)\n{\n    uint64_t memcapcopy = SC_ATOMIC_GET(stream_config.memcap);\n    return memcapcopy;\n}\n\nvoid StreamTcpStreamCleanup(TcpStream *stream)\n{\n    if (stream != NULL) {\n        StreamTcpSackFreeList(stream);\n        StreamTcpReturnStreamSegments(stream);\n        StreamingBufferClear(&stream->sb);\n    }\n}\n\n/**\n *  \\brief Session cleanup function. Does not free the ssn.\n *  \\param ssn tcp session\n */\nvoid StreamTcpSessionCleanup(TcpSession *ssn)\n{\n    SCEnter();\n    TcpStateQueue *q, *q_next;\n\n    if (ssn == NULL)\n        return;\n\n    StreamTcpStreamCleanup(&ssn->client);\n    StreamTcpStreamCleanup(&ssn->server);\n\n    q = ssn->queue;\n    while (q != NULL) {\n        q_next = q->next;\n        SCFree(q);\n        q = q_next;\n        StreamTcpDecrMemuse((uint64_t)sizeof(TcpStateQueue));\n    }\n    ssn->queue = NULL;\n    ssn->queue_len = 0;\n\n    SCReturn;\n}\n\n/**\n *  \\brief Function to return the stream back to the pool. It returns the\n *         segments in the stream to the segment pool.\n *\n *  This function is called when the flow is destroyed, so it should free\n *  *everything* related to the tcp session. So including the app layer\n *  data. We are guaranteed to only get here when the flow's use_cnt is 0.\n *\n *  \\param ssn Void ptr to the ssn.\n */\nvoid StreamTcpSessionClear(void *ssnptr)\n{\n    SCEnter();\n    TcpSession *ssn = (TcpSession *)ssnptr;\n    if (ssn == NULL)\n        return;\n\n    StreamTcpSessionCleanup(ssn);\n\n    /* HACK: don't loose track of thread id */\n    PoolThreadReserved a = ssn->res;\n    memset(ssn, 0, sizeof(TcpSession));\n    ssn->res = a;\n\n    PoolThreadReturn(ssn_pool, ssn);\n#ifdef DEBUG\n    SCMutexLock(&ssn_pool_mutex);\n    ssn_pool_cnt--;\n    SCMutexUnlock(&ssn_pool_mutex);\n#endif\n\n    SCReturn;\n}\n\n/**\n *  \\brief Function to return the stream segments back to the pool.\n *\n *  We don't clear out the app layer storage here as that is under protection\n *  of the \"use_cnt\" reference counter in the flow. This function is called\n *  when the use_cnt is always at least 1 (this pkt has incremented the flow\n *  use_cnt itself), so we don't bother.\n *\n *  \\param p Packet used to identify the stream.\n */\nvoid StreamTcpSessionPktFree (Packet *p)\n{\n    SCEnter();\n\n    TcpSession *ssn = (TcpSession *)p->flow->protoctx;\n    if (ssn == NULL)\n        SCReturn;\n\n    StreamTcpReturnStreamSegments(&ssn->client);\n    StreamTcpReturnStreamSegments(&ssn->server);\n\n    SCReturn;\n}\n\n/** \\brief Stream alloc function for the Pool\n *  \\retval ptr void ptr to TcpSession structure with all vars set to 0/NULL\n */\nstatic void *StreamTcpSessionPoolAlloc(void)\n{\n    void *ptr = NULL;\n\n    if (StreamTcpCheckMemcap((uint32_t)sizeof(TcpSession)) == 0)\n        return NULL;\n\n    ptr = SCMalloc(sizeof(TcpSession));\n    if (unlikely(ptr == NULL))\n        return NULL;\n\n    return ptr;\n}\n\nstatic int StreamTcpSessionPoolInit(void *data, void* initdata)\n{\n    memset(data, 0, sizeof(TcpSession));\n    StreamTcpIncrMemuse((uint64_t)sizeof(TcpSession));\n\n    return 1;\n}\n\n/** \\brief Pool cleanup function\n *  \\param s Void ptr to TcpSession memory */\nstatic void StreamTcpSessionPoolCleanup(void *s)\n{\n    if (s != NULL) {\n        StreamTcpSessionCleanup(s);\n        /** \\todo not very clean, as the memory is not freed here */\n        StreamTcpDecrMemuse((uint64_t)sizeof(TcpSession));\n    }\n}\n\n/**\n *  \\brief See if stream engine is dropping invalid packet in inline mode\n *\n *  \\retval 0 no\n *  \\retval 1 yes\n */\nint StreamTcpInlineDropInvalid(void)\n{\n    return ((stream_config.flags & STREAMTCP_INIT_FLAG_INLINE)\n            && (stream_config.flags & STREAMTCP_INIT_FLAG_DROP_INVALID));\n}\n\n/* hack: stream random range code expects random values in range of 0-RAND_MAX,\n * but we can get both <0 and >RAND_MAX values from RandomGet\n */\nstatic int RandomGetWrap(void)\n{\n    unsigned long r;\n\n    do {\n        r = RandomGet();\n    } while(r >= ULONG_MAX - (ULONG_MAX % RAND_MAX));\n\n    return r % RAND_MAX;\n}\n\n/** \\brief          To initialize the stream global configuration data\n *\n *  \\param  quiet   It tells the mode of operation, if it is true nothing will\n *                  be get printed.\n */\n\nvoid StreamTcpInitConfig(bool quiet)\n{\n    intmax_t value = 0;\n    uint16_t rdrange = 10;\n\n    SCLogDebug(\"Initializing Stream\");\n\n    memset(&stream_config,  0, sizeof(stream_config));\n\n    SC_ATOMIC_INIT(stream_config.memcap);\n    SC_ATOMIC_INIT(stream_config.reassembly_memcap);\n\n    if ((ConfGetInt(\"stream.max-sessions\", &value)) == 1) {\n        SCLogWarning(SC_WARN_OPTION_OBSOLETE, \"max-sessions is obsolete. \"\n            \"Number of concurrent sessions is now only limited by Flow and \"\n            \"TCP stream engine memcaps.\");\n    }\n\n    if ((ConfGetInt(\"stream.prealloc-sessions\", &value)) == 1) {\n        stream_config.prealloc_sessions = (uint32_t)value;\n    } else {\n        if (RunmodeIsUnittests()) {\n            stream_config.prealloc_sessions = 128;\n        } else {\n            stream_config.prealloc_sessions = STREAMTCP_DEFAULT_PREALLOC;\n            if (ConfGetNode(\"stream.prealloc-sessions\") != NULL) {\n                WarnInvalidConfEntry(\"stream.prealloc_sessions\",\n                                     \"%\"PRIu32,\n                                     stream_config.prealloc_sessions);\n            }\n        }\n    }\n    if (!quiet) {\n        SCLogConfig(\"stream \\\"prealloc-sessions\\\": %\"PRIu32\" (per thread)\",\n                stream_config.prealloc_sessions);\n    }\n\n    const char *temp_stream_memcap_str;\n    if (ConfGetValue(\"stream.memcap\", &temp_stream_memcap_str) == 1) {\n        uint64_t stream_memcap_copy;\n        if (ParseSizeStringU64(temp_stream_memcap_str, &stream_memcap_copy) < 0) {\n            SCLogError(SC_ERR_SIZE_PARSE, \"Error parsing stream.memcap \"\n                       \"from conf file - %s.  Killing engine\",\n                       temp_stream_memcap_str);\n            exit(EXIT_FAILURE);\n        } else {\n            SC_ATOMIC_SET(stream_config.memcap, stream_memcap_copy);\n        }\n    } else {\n        SC_ATOMIC_SET(stream_config.memcap, STREAMTCP_DEFAULT_MEMCAP);\n    }\n\n    if (!quiet) {\n        SCLogConfig(\"stream \\\"memcap\\\": %\"PRIu64, SC_ATOMIC_GET(stream_config.memcap));\n    }\n\n    int imidstream;\n    (void)ConfGetBool(\"stream.midstream\", &imidstream);\n    stream_config.midstream = imidstream != 0;\n\n    if (!quiet) {\n        SCLogConfig(\"stream \\\"midstream\\\" session pickups: %s\", stream_config.midstream ? \"enabled\" : \"disabled\");\n    }\n\n    (void)ConfGetBool(\"stream.async-oneside\", &stream_config.async_oneside);\n\n    if (!quiet) {\n        SCLogConfig(\"stream \\\"async-oneside\\\": %s\", stream_config.async_oneside ? \"enabled\" : \"disabled\");\n    }\n\n    int csum = 0;\n\n    if ((ConfGetBool(\"stream.checksum-validation\", &csum)) == 1) {\n        if (csum == 1) {\n            stream_config.flags |= STREAMTCP_INIT_FLAG_CHECKSUM_VALIDATION;\n        }\n    /* Default is that we validate the checksum of all the packets */\n    } else {\n        stream_config.flags |= STREAMTCP_INIT_FLAG_CHECKSUM_VALIDATION;\n    }\n\n    if (!quiet) {\n        SCLogConfig(\"stream \\\"checksum-validation\\\": %s\",\n                stream_config.flags & STREAMTCP_INIT_FLAG_CHECKSUM_VALIDATION ?\n                \"enabled\" : \"disabled\");\n    }\n\n    const char *temp_stream_inline_str;\n    if (ConfGetValue(\"stream.inline\", &temp_stream_inline_str) == 1) {\n        int inl = 0;\n\n        /* checking for \"auto\" and falling back to boolean to provide\n         * backward compatibility */\n        if (strcmp(temp_stream_inline_str, \"auto\") == 0) {\n            if (EngineModeIsIPS()) {\n                stream_config.flags |= STREAMTCP_INIT_FLAG_INLINE;\n            }\n        } else if (ConfGetBool(\"stream.inline\", &inl) == 1) {\n            if (inl) {\n                stream_config.flags |= STREAMTCP_INIT_FLAG_INLINE;\n            }\n        }\n    } else {\n        /* default to 'auto' */\n        if (EngineModeIsIPS()) {\n            stream_config.flags |= STREAMTCP_INIT_FLAG_INLINE;\n        }\n    }\n\n    if (!quiet) {\n        SCLogConfig(\"stream.\\\"inline\\\": %s\",\n                    stream_config.flags & STREAMTCP_INIT_FLAG_INLINE\n                    ? \"enabled\" : \"disabled\");\n    }\n\n    int bypass = 0;\n    if ((ConfGetBool(\"stream.bypass\", &bypass)) == 1) {\n        if (bypass == 1) {\n            stream_config.flags |= STREAMTCP_INIT_FLAG_BYPASS;\n        }\n    }\n\n    if (!quiet) {\n        SCLogConfig(\"stream \\\"bypass\\\": %s\",\n                    (stream_config.flags & STREAMTCP_INIT_FLAG_BYPASS)\n                    ? \"enabled\" : \"disabled\");\n    }\n\n    int drop_invalid = 0;\n    if ((ConfGetBool(\"stream.drop-invalid\", &drop_invalid)) == 1) {\n        if (drop_invalid == 1) {\n            stream_config.flags |= STREAMTCP_INIT_FLAG_DROP_INVALID;\n        }\n    } else {\n        stream_config.flags |= STREAMTCP_INIT_FLAG_DROP_INVALID;\n    }\n\n    if ((ConfGetInt(\"stream.max-synack-queued\", &value)) == 1) {\n        if (value >= 0 && value <= 255) {\n            stream_config.max_synack_queued = (uint8_t)value;\n        } else {\n            stream_config.max_synack_queued = (uint8_t)STREAMTCP_DEFAULT_MAX_SYNACK_QUEUED;\n        }\n    } else {\n        stream_config.max_synack_queued = (uint8_t)STREAMTCP_DEFAULT_MAX_SYNACK_QUEUED;\n    }\n    if (!quiet) {\n        SCLogConfig(\"stream \\\"max-synack-queued\\\": %\"PRIu8, stream_config.max_synack_queued);\n    }\n\n    const char *temp_stream_reassembly_memcap_str;\n    if (ConfGetValue(\"stream.reassembly.memcap\", &temp_stream_reassembly_memcap_str) == 1) {\n        uint64_t stream_reassembly_memcap_copy;\n        if (ParseSizeStringU64(temp_stream_reassembly_memcap_str,\n                               &stream_reassembly_memcap_copy) < 0) {\n            SCLogError(SC_ERR_SIZE_PARSE, \"Error parsing \"\n                       \"stream.reassembly.memcap \"\n                       \"from conf file - %s.  Killing engine\",\n                       temp_stream_reassembly_memcap_str);\n            exit(EXIT_FAILURE);\n        } else {\n            SC_ATOMIC_SET(stream_config.reassembly_memcap, stream_reassembly_memcap_copy);\n        }\n    } else {\n        SC_ATOMIC_SET(stream_config.reassembly_memcap , STREAMTCP_DEFAULT_REASSEMBLY_MEMCAP);\n    }\n\n    if (!quiet) {\n        SCLogConfig(\"stream.reassembly \\\"memcap\\\": %\"PRIu64\"\",\n                    SC_ATOMIC_GET(stream_config.reassembly_memcap));\n    }\n\n    const char *temp_stream_reassembly_depth_str;\n    if (ConfGetValue(\"stream.reassembly.depth\", &temp_stream_reassembly_depth_str) == 1) {\n        if (ParseSizeStringU32(temp_stream_reassembly_depth_str,\n                               &stream_config.reassembly_depth) < 0) {\n            SCLogError(SC_ERR_SIZE_PARSE, \"Error parsing \"\n                       \"stream.reassembly.depth \"\n                       \"from conf file - %s.  Killing engine\",\n                       temp_stream_reassembly_depth_str);\n            exit(EXIT_FAILURE);\n        }\n    } else {\n        stream_config.reassembly_depth = 0;\n    }\n\n    if (!quiet) {\n        SCLogConfig(\"stream.reassembly \\\"depth\\\": %\"PRIu32\"\", stream_config.reassembly_depth);\n    }\n\n    int randomize = 0;\n    if ((ConfGetBool(\"stream.reassembly.randomize-chunk-size\", &randomize)) == 0) {\n        /* randomize by default if value not set\n         * In ut mode we disable, to get predictable test results */\n        if (!(RunmodeIsUnittests()))\n            randomize = 1;\n    }\n\n    if (randomize) {\n        const char *temp_rdrange;\n        if (ConfGetValue(\"stream.reassembly.randomize-chunk-range\",\n                    &temp_rdrange) == 1) {\n            if (ParseSizeStringU16(temp_rdrange, &rdrange) < 0) {\n                SCLogError(SC_ERR_SIZE_PARSE, \"Error parsing \"\n                        \"stream.reassembly.randomize-chunk-range \"\n                        \"from conf file - %s.  Killing engine\",\n                        temp_rdrange);\n                exit(EXIT_FAILURE);\n            } else if (rdrange >= 100) {\n                           FatalError(SC_ERR_FATAL,\n                                      \"stream.reassembly.randomize-chunk-range \"\n                                      \"must be lower than 100\");\n            }\n        }\n    }\n\n    const char *temp_stream_reassembly_toserver_chunk_size_str;\n    if (ConfGetValue(\"stream.reassembly.toserver-chunk-size\",\n                &temp_stream_reassembly_toserver_chunk_size_str) == 1) {\n        if (ParseSizeStringU16(temp_stream_reassembly_toserver_chunk_size_str,\n                               &stream_config.reassembly_toserver_chunk_size) < 0) {\n            SCLogError(SC_ERR_SIZE_PARSE, \"Error parsing \"\n                       \"stream.reassembly.toserver-chunk-size \"\n                       \"from conf file - %s.  Killing engine\",\n                       temp_stream_reassembly_toserver_chunk_size_str);\n            exit(EXIT_FAILURE);\n        }\n    } else {\n        stream_config.reassembly_toserver_chunk_size =\n            STREAMTCP_DEFAULT_TOSERVER_CHUNK_SIZE;\n    }\n\n    if (randomize) {\n        long int r = RandomGetWrap();\n        stream_config.reassembly_toserver_chunk_size +=\n            (int) (stream_config.reassembly_toserver_chunk_size *\n                   (r * 1.0 / RAND_MAX - 0.5) * rdrange / 100);\n    }\n    const char *temp_stream_reassembly_toclient_chunk_size_str;\n    if (ConfGetValue(\"stream.reassembly.toclient-chunk-size\",\n                &temp_stream_reassembly_toclient_chunk_size_str) == 1) {\n        if (ParseSizeStringU16(temp_stream_reassembly_toclient_chunk_size_str,\n                               &stream_config.reassembly_toclient_chunk_size) < 0) {\n            SCLogError(SC_ERR_SIZE_PARSE, \"Error parsing \"\n                       \"stream.reassembly.toclient-chunk-size \"\n                       \"from conf file - %s.  Killing engine\",\n                       temp_stream_reassembly_toclient_chunk_size_str);\n            exit(EXIT_FAILURE);\n        }\n    } else {\n        stream_config.reassembly_toclient_chunk_size =\n            STREAMTCP_DEFAULT_TOCLIENT_CHUNK_SIZE;\n    }\n\n    if (randomize) {\n        long int r = RandomGetWrap();\n        stream_config.reassembly_toclient_chunk_size +=\n            (int) (stream_config.reassembly_toclient_chunk_size *\n                   (r * 1.0 / RAND_MAX - 0.5) * rdrange / 100);\n    }\n    if (!quiet) {\n        SCLogConfig(\"stream.reassembly \\\"toserver-chunk-size\\\": %\"PRIu16,\n            stream_config.reassembly_toserver_chunk_size);\n        SCLogConfig(\"stream.reassembly \\\"toclient-chunk-size\\\": %\"PRIu16,\n            stream_config.reassembly_toclient_chunk_size);\n    }\n\n    int enable_raw = 1;\n    if (ConfGetBool(\"stream.reassembly.raw\", &enable_raw) == 1) {\n        if (!enable_raw) {\n            stream_config.stream_init_flags = STREAMTCP_STREAM_FLAG_DISABLE_RAW;\n        }\n    } else {\n        enable_raw = 1;\n    }\n    if (!quiet)\n        SCLogConfig(\"stream.reassembly.raw: %s\", enable_raw ? \"enabled\" : \"disabled\");\n\n    /* init the memcap/use tracking */\n    StreamTcpInitMemuse();\n    StatsRegisterGlobalCounter(\"tcp.memuse\", StreamTcpMemuseCounter);\n\n    StreamTcpReassembleInit(quiet);\n\n    /* set the default free function and flow state function\n     * values. */\n    FlowSetProtoFreeFunc(IPPROTO_TCP, StreamTcpSessionClear);\n\n#ifdef UNITTESTS\n    if (RunmodeIsUnittests()) {\n        SCMutexLock(&ssn_pool_mutex);\n        if (ssn_pool == NULL) {\n            ssn_pool = PoolThreadInit(1, /* thread */\n                    0, /* unlimited */\n                    stream_config.prealloc_sessions,\n                    sizeof(TcpSession),\n                    StreamTcpSessionPoolAlloc,\n                    StreamTcpSessionPoolInit, NULL,\n                    StreamTcpSessionPoolCleanup, NULL);\n        }\n        SCMutexUnlock(&ssn_pool_mutex);\n    }\n#endif\n}\n\nvoid StreamTcpFreeConfig(bool quiet)\n{\n    StreamTcpReassembleFree(quiet);\n\n    SCMutexLock(&ssn_pool_mutex);\n    if (ssn_pool != NULL) {\n        PoolThreadFree(ssn_pool);\n        ssn_pool = NULL;\n    }\n    SCMutexUnlock(&ssn_pool_mutex);\n    SCMutexDestroy(&ssn_pool_mutex);\n\n    SCLogDebug(\"ssn_pool_cnt %\"PRIu64\"\", ssn_pool_cnt);\n}\n\n/** \\internal\n *  \\brief The function is used to to fetch a TCP session from the\n *         ssn_pool, when a TCP SYN is received.\n *\n *  \\param p packet starting the new TCP session.\n *  \\param id thread pool id\n *\n *  \\retval ssn new TCP session.\n */\nstatic TcpSession *StreamTcpNewSession (Packet *p, int id)\n{\n    TcpSession *ssn = (TcpSession *)p->flow->protoctx;\n\n    if (ssn == NULL) {\n        p->flow->protoctx = PoolThreadGetById(ssn_pool, id);\n#ifdef DEBUG\n        SCMutexLock(&ssn_pool_mutex);\n        if (p->flow->protoctx != NULL)\n            ssn_pool_cnt++;\n        SCMutexUnlock(&ssn_pool_mutex);\n#endif\n\n        ssn = (TcpSession *)p->flow->protoctx;\n        if (ssn == NULL) {\n            SCLogDebug(\"ssn_pool is empty\");\n            return NULL;\n        }\n\n        ssn->state = TCP_NONE;\n        ssn->reassembly_depth = stream_config.reassembly_depth;\n        ssn->tcp_packet_flags = p->tcph ? p->tcph->th_flags : 0;\n        ssn->server.flags = stream_config.stream_init_flags;\n        ssn->client.flags = stream_config.stream_init_flags;\n\n        StreamingBuffer x = STREAMING_BUFFER_INITIALIZER(&stream_config.sbcnf);\n        ssn->client.sb = x;\n        ssn->server.sb = x;\n\n        if (PKT_IS_TOSERVER(p)) {\n            ssn->client.tcp_flags = p->tcph ? p->tcph->th_flags : 0;\n            ssn->server.tcp_flags = 0;\n        } else if (PKT_IS_TOCLIENT(p)) {\n            ssn->server.tcp_flags = p->tcph ? p->tcph->th_flags : 0;\n            ssn->client.tcp_flags = 0;\n        }\n    }\n\n    return ssn;\n}\n\nstatic void StreamTcpPacketSetState(Packet *p, TcpSession *ssn,\n                                           uint8_t state)\n{\n    if (state == ssn->state || PKT_IS_PSEUDOPKT(p))\n        return;\n\n    ssn->pstate = ssn->state;\n    ssn->state = state;\n\n    /* update the flow state */\n    switch(ssn->state) {\n        case TCP_ESTABLISHED:\n        case TCP_FIN_WAIT1:\n        case TCP_FIN_WAIT2:\n        case TCP_CLOSING:\n        case TCP_CLOSE_WAIT:\n            FlowUpdateState(p->flow, FLOW_STATE_ESTABLISHED);\n            break;\n        case TCP_LAST_ACK:\n        case TCP_TIME_WAIT:\n        case TCP_CLOSED:\n            FlowUpdateState(p->flow, FLOW_STATE_CLOSED);\n            break;\n    }\n}\n\n/**\n *  \\brief  Function to set the OS policy for the given stream based on the\n *          destination of the received packet.\n *\n *  \\param  stream  TcpStream of which os_policy needs to set\n *  \\param  p       Packet which is used to set the os policy\n */\nvoid StreamTcpSetOSPolicy(TcpStream *stream, Packet *p)\n{\n    int ret = 0;\n\n    if (PKT_IS_IPV4(p)) {\n        /* Get the OS policy based on destination IP address, as destination\n           OS will decide how to react on the anomalies of newly received\n           packets */\n        ret = SCHInfoGetIPv4HostOSFlavour((uint8_t *)GET_IPV4_DST_ADDR_PTR(p));\n        if (ret > 0)\n            stream->os_policy = ret;\n        else\n            stream->os_policy = OS_POLICY_DEFAULT;\n\n    } else if (PKT_IS_IPV6(p)) {\n        /* Get the OS policy based on destination IP address, as destination\n           OS will decide how to react on the anomalies of newly received\n           packets */\n        ret = SCHInfoGetIPv6HostOSFlavour((uint8_t *)GET_IPV6_DST_ADDR(p));\n        if (ret > 0)\n            stream->os_policy = ret;\n        else\n            stream->os_policy = OS_POLICY_DEFAULT;\n    }\n\n    if (stream->os_policy == OS_POLICY_BSD_RIGHT)\n        stream->os_policy = OS_POLICY_BSD;\n    else if (stream->os_policy == OS_POLICY_OLD_SOLARIS)\n        stream->os_policy = OS_POLICY_SOLARIS;\n\n    SCLogDebug(\"Policy is %\"PRIu8\"\", stream->os_policy);\n\n}\n\n/**\n *  \\brief macro to update last_ack only if the new value is higher\n *\n *  \\param ssn session\n *  \\param stream stream to update\n *  \\param ack ACK value to test and set\n */\n#define StreamTcpUpdateLastAck(ssn, stream, ack) { \\\n    if (SEQ_GT((ack), (stream)->last_ack)) \\\n    { \\\n        SCLogDebug(\"ssn %p: last_ack set to %\"PRIu32\", moved %u forward\", (ssn), (ack), (ack) - (stream)->last_ack); \\\n        if ((SEQ_LEQ((stream)->last_ack, (stream)->next_seq) && SEQ_GT((ack),(stream)->next_seq))) { \\\n            SCLogDebug(\"last_ack just passed next_seq: %u (was %u) > %u\", (ack), (stream)->last_ack, (stream)->next_seq); \\\n        } else { \\\n            SCLogDebug(\"next_seq (%u) <> last_ack now %d\", (stream)->next_seq, (int)(stream)->next_seq - (ack)); \\\n        }\\\n        (stream)->last_ack = (ack); \\\n        StreamTcpSackPruneList((stream)); \\\n    } else { \\\n        SCLogDebug(\"ssn %p: no update: ack %u, last_ack %\"PRIu32\", next_seq %u (state %u)\", \\\n                    (ssn), (ack), (stream)->last_ack, (stream)->next_seq, (ssn)->state); \\\n    }\\\n}\n\n#define StreamTcpAsyncLastAckUpdate(ssn, stream) {                              \\\n    if ((ssn)->flags & STREAMTCP_FLAG_ASYNC) {                                  \\\n        if (SEQ_GT((stream)->next_seq, (stream)->last_ack)) {                   \\\n            uint32_t ack_diff = (stream)->next_seq - (stream)->last_ack;        \\\n            (stream)->last_ack += ack_diff;                                     \\\n            SCLogDebug(\"ssn %p: ASYNC last_ack set to %\"PRIu32\", moved %u forward\",     \\\n                    (ssn), (stream)->next_seq, ack_diff);                               \\\n        }                                                                       \\\n    }                                                                           \\\n}\n\n#define StreamTcpUpdateNextSeq(ssn, stream, seq) {                      \\\n    (stream)->next_seq = seq;                                           \\\n    SCLogDebug(\"ssn %p: next_seq %\" PRIu32, (ssn), (stream)->next_seq); \\\n    StreamTcpAsyncLastAckUpdate((ssn), (stream));                       \\\n}\n\n/**\n *  \\brief macro to update next_win only if the new value is higher\n *\n *  \\param ssn session\n *  \\param stream stream to update\n *  \\param win window value to test and set\n */\n#define StreamTcpUpdateNextWin(ssn, stream, win) { \\\n    uint32_t sacked_size__ = StreamTcpSackedSize((stream)); \\\n    if (SEQ_GT(((win) + sacked_size__), (stream)->next_win)) { \\\n        (stream)->next_win = ((win) + sacked_size__); \\\n        SCLogDebug(\"ssn %p: next_win set to %\"PRIu32, (ssn), (stream)->next_win); \\\n    } \\\n}\n\nstatic inline void StreamTcpCloseSsnWithReset(Packet *p, TcpSession *ssn)\n{\n    ssn->flags |= STREAMTCP_FLAG_CLOSED_BY_RST;\n    StreamTcpPacketSetState(p, ssn, TCP_CLOSED);\n    SCLogDebug(\"ssn %p: (state: %s) Reset received and state changed to \"\n            \"TCP_CLOSED\", ssn, StreamTcpStateAsString(ssn->state));\n}\n\nstatic int StreamTcpPacketIsRetransmission(TcpStream *stream, Packet *p)\n{\n    if (p->payload_len == 0)\n        SCReturnInt(0);\n\n    /* retransmission of already partially ack'd data */\n    if (SEQ_LT(TCP_GET_SEQ(p), stream->last_ack) && SEQ_GT((TCP_GET_SEQ(p) + p->payload_len), stream->last_ack))\n    {\n        StreamTcpSetEvent(p, STREAM_PKT_RETRANSMISSION);\n        SCReturnInt(1);\n    }\n\n    /* retransmission of already ack'd data */\n    if (SEQ_LEQ((TCP_GET_SEQ(p) + p->payload_len), stream->last_ack)) {\n        StreamTcpSetEvent(p, STREAM_PKT_RETRANSMISSION);\n        SCReturnInt(1);\n    }\n\n    /* retransmission of in flight data */\n    if (SEQ_LEQ((TCP_GET_SEQ(p) + p->payload_len), stream->next_seq)) {\n        StreamTcpSetEvent(p, STREAM_PKT_RETRANSMISSION);\n        SCReturnInt(2);\n    }\n\n    SCLogDebug(\"seq %u payload_len %u => %u, last_ack %u, next_seq %u\", TCP_GET_SEQ(p),\n            p->payload_len, (TCP_GET_SEQ(p) + p->payload_len), stream->last_ack, stream->next_seq);\n    SCReturnInt(0);\n}\n\n/**\n *  \\internal\n *  \\brief  Function to handle the TCP_CLOSED or NONE state. The function handles\n *          packets while the session state is None which means a newly\n *          initialized structure, or a fully closed session.\n *\n *  \\param  tv      Thread Variable containing  input/output queue, cpu affinity\n *  \\param  p       Packet which has to be handled in this TCP state.\n *  \\param  stt     Strean Thread module registered to handle the stream handling\n *\n *  \\retval 0 ok\n *  \\retval -1 error\n */\nstatic int StreamTcpPacketStateNone(ThreadVars *tv, Packet *p,\n        StreamTcpThread *stt, TcpSession *ssn,\n        PacketQueueNoLock *pq)\n{\n    if (p->tcph->th_flags & TH_RST) {\n        StreamTcpSetEvent(p, STREAM_RST_BUT_NO_SESSION);\n        SCLogDebug(\"RST packet received, no session setup\");\n        return -1;\n\n    } else if (p->tcph->th_flags & TH_FIN) {\n        StreamTcpSetEvent(p, STREAM_FIN_BUT_NO_SESSION);\n        SCLogDebug(\"FIN packet received, no session setup\");\n        return -1;\n\n    /* SYN/ACK */\n    } else if ((p->tcph->th_flags & (TH_SYN|TH_ACK)) == (TH_SYN|TH_ACK)) {\n        if (!stream_config.midstream && stream_config.async_oneside == FALSE)\n            return 0;\n\n        if (ssn == NULL) {\n            ssn = StreamTcpNewSession(p, stt->ssn_pool_id);\n            if (ssn == NULL) {\n                StatsIncr(tv, stt->counter_tcp_ssn_memcap);\n                return -1;\n            }\n            StatsIncr(tv, stt->counter_tcp_sessions);\n            StatsIncr(tv, stt->counter_tcp_midstream_pickups);\n        }\n\n        /* reverse packet and flow */\n        SCLogDebug(\"reversing flow and packet\");\n        PacketSwap(p);\n        FlowSwap(p->flow);\n\n        /* set the state */\n        StreamTcpPacketSetState(p, ssn, TCP_SYN_RECV);\n        SCLogDebug(\"ssn %p: =~ midstream picked ssn state is now \"\n                \"TCP_SYN_RECV\", ssn);\n        ssn->flags |= STREAMTCP_FLAG_MIDSTREAM;\n        /* Flag used to change the direct in the later stage in the session */\n        ssn->flags |= STREAMTCP_FLAG_MIDSTREAM_SYNACK;\n        if (stream_config.async_oneside) {\n            SCLogDebug(\"ssn %p: =~ ASYNC\", ssn);\n            ssn->flags |= STREAMTCP_FLAG_ASYNC;\n        }\n\n        /* sequence number & window */\n        ssn->server.isn = TCP_GET_SEQ(p);\n        STREAMTCP_SET_RA_BASE_SEQ(&ssn->server, ssn->server.isn);\n        ssn->server.next_seq = ssn->server.isn + 1;\n        ssn->server.window = TCP_GET_WINDOW(p);\n        SCLogDebug(\"ssn %p: server window %u\", ssn, ssn->server.window);\n\n        ssn->client.isn = TCP_GET_ACK(p) - 1;\n        STREAMTCP_SET_RA_BASE_SEQ(&ssn->client, ssn->client.isn);\n        ssn->client.next_seq = ssn->client.isn + 1;\n\n        ssn->client.last_ack = TCP_GET_ACK(p);\n        ssn->server.last_ack = TCP_GET_SEQ(p);\n\n        ssn->server.next_win = ssn->server.last_ack + ssn->server.window;\n\n        /** If the client has a wscale option the server had it too,\n         *  so set the wscale for the server to max. Otherwise none\n         *  will have the wscale opt just like it should. */\n        if (TCP_HAS_WSCALE(p)) {\n            ssn->client.wscale = TCP_GET_WSCALE(p);\n            ssn->server.wscale = TCP_WSCALE_MAX;\n            SCLogDebug(\"ssn %p: wscale enabled. client %u server %u\",\n                    ssn, ssn->client.wscale, ssn->server.wscale);\n        }\n\n        SCLogDebug(\"ssn %p: ssn->client.isn %\"PRIu32\", ssn->client.next_seq\"\n                \" %\"PRIu32\", ssn->client.last_ack %\"PRIu32\"\", ssn,\n                ssn->client.isn, ssn->client.next_seq,\n                ssn->client.last_ack);\n        SCLogDebug(\"ssn %p: ssn->server.isn %\"PRIu32\", ssn->server.next_seq\"\n                \" %\"PRIu32\", ssn->server.last_ack %\"PRIu32\"\", ssn,\n                ssn->server.isn, ssn->server.next_seq,\n                ssn->server.last_ack);\n\n        /* Set the timestamp value for both streams, if packet has timestamp\n         * option enabled.*/\n        if (TCP_HAS_TS(p)) {\n            ssn->server.last_ts = TCP_GET_TSVAL(p);\n            ssn->client.last_ts = TCP_GET_TSECR(p);\n            SCLogDebug(\"ssn %p: ssn->server.last_ts %\" PRIu32\" \"\n                    \"ssn->client.last_ts %\" PRIu32\"\", ssn,\n                    ssn->server.last_ts, ssn->client.last_ts);\n\n            ssn->flags |= STREAMTCP_FLAG_TIMESTAMP;\n\n            ssn->server.last_pkt_ts = p->ts.tv_sec;\n            if (ssn->server.last_ts == 0)\n                ssn->server.flags |= STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n            if (ssn->client.last_ts == 0)\n                ssn->client.flags |= STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n\n        } else {\n            ssn->server.last_ts = 0;\n            ssn->client.last_ts = 0;\n        }\n\n        if (TCP_GET_SACKOK(p) == 1) {\n            ssn->flags |= STREAMTCP_FLAG_SACKOK;\n            SCLogDebug(\"ssn %p: SYN/ACK with SACK permitted, assuming \"\n                    \"SACK permitted for both sides\", ssn);\n        }\n        return 0;\n\n    } else if (p->tcph->th_flags & TH_SYN) {\n        if (ssn == NULL) {\n            ssn = StreamTcpNewSession(p, stt->ssn_pool_id);\n            if (ssn == NULL) {\n                StatsIncr(tv, stt->counter_tcp_ssn_memcap);\n                return -1;\n            }\n\n            StatsIncr(tv, stt->counter_tcp_sessions);\n        }\n\n        /* set the state */\n        StreamTcpPacketSetState(p, ssn, TCP_SYN_SENT);\n        SCLogDebug(\"ssn %p: =~ ssn state is now TCP_SYN_SENT\", ssn);\n\n        if (stream_config.async_oneside) {\n            SCLogDebug(\"ssn %p: =~ ASYNC\", ssn);\n            ssn->flags |= STREAMTCP_FLAG_ASYNC;\n        }\n\n        /* set the sequence numbers and window */\n        ssn->client.isn = TCP_GET_SEQ(p);\n        STREAMTCP_SET_RA_BASE_SEQ(&ssn->client, ssn->client.isn);\n        ssn->client.next_seq = ssn->client.isn + 1;\n\n        /* Set the stream timestamp value, if packet has timestamp option\n         * enabled. */\n        if (TCP_HAS_TS(p)) {\n            ssn->client.last_ts = TCP_GET_TSVAL(p);\n            SCLogDebug(\"ssn %p: %02x\", ssn, ssn->client.last_ts);\n\n            if (ssn->client.last_ts == 0)\n                ssn->client.flags |= STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n\n            ssn->client.last_pkt_ts = p->ts.tv_sec;\n            ssn->client.flags |= STREAMTCP_STREAM_FLAG_TIMESTAMP;\n        }\n\n        ssn->server.window = TCP_GET_WINDOW(p);\n        if (TCP_HAS_WSCALE(p)) {\n            ssn->flags |= STREAMTCP_FLAG_SERVER_WSCALE;\n            ssn->server.wscale = TCP_GET_WSCALE(p);\n        }\n\n        if (TCP_GET_SACKOK(p) == 1) {\n            ssn->flags |= STREAMTCP_FLAG_CLIENT_SACKOK;\n            SCLogDebug(\"ssn %p: SACK permitted on SYN packet\", ssn);\n        }\n\n        if (TCP_HAS_TFO(p)) {\n            ssn->flags |= STREAMTCP_FLAG_TCP_FAST_OPEN;\n            if (p->payload_len) {\n                StreamTcpUpdateNextSeq(ssn, &ssn->client, (ssn->client.next_seq + p->payload_len));\n                SCLogDebug(\"ssn: %p (TFO) [len: %d] isn %u base_seq %u next_seq %u payload len %u\",\n                        ssn, p->tcpvars.tfo.len, ssn->client.isn, ssn->client.base_seq, ssn->client.next_seq, p->payload_len);\n                StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn, &ssn->client, p, pq);\n            }\n        }\n\n        SCLogDebug(\"ssn %p: ssn->client.isn %\" PRIu32 \", \"\n                \"ssn->client.next_seq %\" PRIu32 \", ssn->client.last_ack \"\n                \"%\"PRIu32\"\", ssn, ssn->client.isn, ssn->client.next_seq,\n                ssn->client.last_ack);\n\n    } else if (p->tcph->th_flags & TH_ACK) {\n        if (!stream_config.midstream)\n            return 0;\n\n        if (ssn == NULL) {\n            ssn = StreamTcpNewSession(p, stt->ssn_pool_id);\n            if (ssn == NULL) {\n                StatsIncr(tv, stt->counter_tcp_ssn_memcap);\n                return -1;\n            }\n            StatsIncr(tv, stt->counter_tcp_sessions);\n            StatsIncr(tv, stt->counter_tcp_midstream_pickups);\n        }\n        /* set the state */\n        StreamTcpPacketSetState(p, ssn, TCP_ESTABLISHED);\n        SCLogDebug(\"ssn %p: =~ midstream picked ssn state is now \"\n                \"TCP_ESTABLISHED\", ssn);\n\n        ssn->flags = STREAMTCP_FLAG_MIDSTREAM;\n        ssn->flags |= STREAMTCP_FLAG_MIDSTREAM_ESTABLISHED;\n        if (stream_config.async_oneside) {\n            SCLogDebug(\"ssn %p: =~ ASYNC\", ssn);\n            ssn->flags |= STREAMTCP_FLAG_ASYNC;\n        }\n\n        /** window scaling for midstream pickups, we can't do much other\n         *  than assume that it's set to the max value: 14 */\n        ssn->client.wscale = TCP_WSCALE_MAX;\n        ssn->server.wscale = TCP_WSCALE_MAX;\n\n        /* set the sequence numbers and window */\n        ssn->client.isn = TCP_GET_SEQ(p) - 1;\n        STREAMTCP_SET_RA_BASE_SEQ(&ssn->client, ssn->client.isn);\n        ssn->client.next_seq = TCP_GET_SEQ(p) + p->payload_len;\n        ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n        ssn->client.last_ack = TCP_GET_SEQ(p);\n        ssn->client.next_win = ssn->client.last_ack + ssn->client.window;\n        SCLogDebug(\"ssn %p: ssn->client.isn %u, ssn->client.next_seq %u\",\n                ssn, ssn->client.isn, ssn->client.next_seq);\n\n        ssn->server.isn = TCP_GET_ACK(p) - 1;\n        STREAMTCP_SET_RA_BASE_SEQ(&ssn->server, ssn->server.isn);\n        ssn->server.next_seq = ssn->server.isn + 1;\n        ssn->server.last_ack = TCP_GET_ACK(p);\n        ssn->server.next_win = ssn->server.last_ack;\n\n        SCLogDebug(\"ssn %p: ssn->client.next_win %\"PRIu32\", \"\n                \"ssn->server.next_win %\"PRIu32\"\", ssn,\n                ssn->client.next_win, ssn->server.next_win);\n        SCLogDebug(\"ssn %p: ssn->client.last_ack %\"PRIu32\", \"\n                \"ssn->server.last_ack %\"PRIu32\"\", ssn,\n                ssn->client.last_ack, ssn->server.last_ack);\n\n        /* Set the timestamp value for both streams, if packet has timestamp\n         * option enabled.*/\n        if (TCP_HAS_TS(p)) {\n            ssn->client.last_ts = TCP_GET_TSVAL(p);\n            ssn->server.last_ts = TCP_GET_TSECR(p);\n            SCLogDebug(\"ssn %p: ssn->server.last_ts %\" PRIu32\" \"\n                    \"ssn->client.last_ts %\" PRIu32\"\", ssn,\n                    ssn->server.last_ts, ssn->client.last_ts);\n\n            ssn->flags |= STREAMTCP_FLAG_TIMESTAMP;\n\n            ssn->client.last_pkt_ts = p->ts.tv_sec;\n            if (ssn->server.last_ts == 0)\n                ssn->server.flags |= STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n            if (ssn->client.last_ts == 0)\n                ssn->client.flags |= STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n\n        } else {\n            ssn->server.last_ts = 0;\n            ssn->client.last_ts = 0;\n        }\n\n        StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn, &ssn->client, p, pq);\n\n        ssn->flags |= STREAMTCP_FLAG_SACKOK;\n        SCLogDebug(\"ssn %p: assuming SACK permitted for both sides\", ssn);\n\n    } else {\n        SCLogDebug(\"default case\");\n    }\n\n    return 0;\n}\n\n/** \\internal\n *  \\brief Setup TcpStateQueue based on SYN/ACK packet\n */\nstatic inline void StreamTcp3whsSynAckToStateQueue(Packet *p, TcpStateQueue *q)\n{\n    q->flags = 0;\n    q->wscale = 0;\n    q->ts = 0;\n    q->win = TCP_GET_WINDOW(p);\n    q->seq = TCP_GET_SEQ(p);\n    q->ack = TCP_GET_ACK(p);\n    q->pkt_ts = p->ts.tv_sec;\n\n    if (TCP_GET_SACKOK(p) == 1)\n        q->flags |= STREAMTCP_QUEUE_FLAG_SACK;\n\n    if (TCP_HAS_WSCALE(p)) {\n        q->flags |= STREAMTCP_QUEUE_FLAG_WS;\n        q->wscale = TCP_GET_WSCALE(p);\n    }\n    if (TCP_HAS_TS(p)) {\n        q->flags |= STREAMTCP_QUEUE_FLAG_TS;\n        q->ts = TCP_GET_TSVAL(p);\n    }\n}\n\n/** \\internal\n *  \\brief Find the Queued SYN/ACK that is the same as this SYN/ACK\n *  \\retval q or NULL */\nstatic TcpStateQueue *StreamTcp3whsFindSynAckBySynAck(TcpSession *ssn, Packet *p)\n{\n    TcpStateQueue *q = ssn->queue;\n    TcpStateQueue search;\n\n    StreamTcp3whsSynAckToStateQueue(p, &search);\n\n    while (q != NULL) {\n        if (search.flags == q->flags &&\n            search.wscale == q->wscale &&\n            search.win == q->win &&\n            search.seq == q->seq &&\n            search.ack == q->ack &&\n            search.ts == q->ts) {\n            return q;\n        }\n\n        q = q->next;\n    }\n\n    return q;\n}\n\nstatic int StreamTcp3whsQueueSynAck(TcpSession *ssn, Packet *p)\n{\n    /* first see if this is already in our list */\n    if (StreamTcp3whsFindSynAckBySynAck(ssn, p) != NULL)\n        return 0;\n\n    if (ssn->queue_len == stream_config.max_synack_queued) {\n        SCLogDebug(\"ssn %p: =~ SYN/ACK queue limit reached\", ssn);\n        StreamTcpSetEvent(p, STREAM_3WHS_SYNACK_FLOOD);\n        return -1;\n    }\n\n    if (StreamTcpCheckMemcap((uint32_t)sizeof(TcpStateQueue)) == 0) {\n        SCLogDebug(\"ssn %p: =~ SYN/ACK queue failed: stream memcap reached\", ssn);\n        return -1;\n    }\n\n    TcpStateQueue *q = SCMalloc(sizeof(*q));\n    if (unlikely(q == NULL)) {\n        SCLogDebug(\"ssn %p: =~ SYN/ACK queue failed: alloc failed\", ssn);\n        return -1;\n    }\n    memset(q, 0x00, sizeof(*q));\n    StreamTcpIncrMemuse((uint64_t)sizeof(TcpStateQueue));\n\n    StreamTcp3whsSynAckToStateQueue(p, q);\n\n    /* put in list */\n    q->next = ssn->queue;\n    ssn->queue = q;\n    ssn->queue_len++;\n    return 0;\n}\n\n/** \\internal\n *  \\brief Find the Queued SYN/ACK that goes with this ACK\n *  \\retval q or NULL */\nstatic TcpStateQueue *StreamTcp3whsFindSynAckByAck(TcpSession *ssn, Packet *p)\n{\n    uint32_t ack = TCP_GET_SEQ(p);\n    uint32_t seq = TCP_GET_ACK(p) - 1;\n    TcpStateQueue *q = ssn->queue;\n\n    while (q != NULL) {\n        if (seq == q->seq &&\n            ack == q->ack) {\n            return q;\n        }\n\n        q = q->next;\n    }\n\n    return NULL;\n}\n\n/** \\internal\n *  \\brief Update SSN after receiving a valid SYN/ACK\n *\n *  Normally we update the SSN from the SYN/ACK packet. But in case\n *  of queued SYN/ACKs, we can use one of those.\n *\n *  \\param ssn TCP session\n *  \\param p Packet\n *  \\param q queued state if used, NULL otherwise\n *\n *  To make sure all SYN/ACK based state updates are in one place,\n *  this function can updated based on Packet or TcpStateQueue, where\n *  the latter takes precedence.\n */\nstatic void StreamTcp3whsSynAckUpdate(TcpSession *ssn, Packet *p, TcpStateQueue *q)\n{\n    TcpStateQueue update;\n    if (likely(q == NULL)) {\n        StreamTcp3whsSynAckToStateQueue(p, &update);\n        q = &update;\n    }\n\n    if (ssn->state != TCP_SYN_RECV) {\n        /* update state */\n        StreamTcpPacketSetState(p, ssn, TCP_SYN_RECV);\n        SCLogDebug(\"ssn %p: =~ ssn state is now TCP_SYN_RECV\", ssn);\n    }\n    /* sequence number & window */\n    ssn->server.isn = q->seq;\n    STREAMTCP_SET_RA_BASE_SEQ(&ssn->server, ssn->server.isn);\n    ssn->server.next_seq = ssn->server.isn + 1;\n\n    ssn->client.window = q->win;\n    SCLogDebug(\"ssn %p: window %\" PRIu32 \"\", ssn, ssn->server.window);\n\n    /* Set the timestamp values used to validate the timestamp of\n     * received packets.*/\n    if ((q->flags & STREAMTCP_QUEUE_FLAG_TS) &&\n            (ssn->client.flags & STREAMTCP_STREAM_FLAG_TIMESTAMP))\n    {\n        ssn->server.last_ts = q->ts;\n        SCLogDebug(\"ssn %p: ssn->server.last_ts %\" PRIu32\" \"\n                \"ssn->client.last_ts %\" PRIu32\"\", ssn,\n                ssn->server.last_ts, ssn->client.last_ts);\n        ssn->flags |= STREAMTCP_FLAG_TIMESTAMP;\n        ssn->server.last_pkt_ts = q->pkt_ts;\n        if (ssn->server.last_ts == 0)\n            ssn->server.flags |= STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n    } else {\n        ssn->client.last_ts = 0;\n        ssn->server.last_ts = 0;\n        ssn->client.flags &= ~STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n    }\n\n    ssn->client.last_ack = q->ack;\n    ssn->server.last_ack = ssn->server.isn + 1;\n\n    /** check for the presense of the ws ptr to determine if we\n     *  support wscale at all */\n    if ((ssn->flags & STREAMTCP_FLAG_SERVER_WSCALE) &&\n            (q->flags & STREAMTCP_QUEUE_FLAG_WS))\n    {\n        ssn->client.wscale = q->wscale;\n    } else {\n        ssn->client.wscale = 0;\n    }\n\n    if ((ssn->flags & STREAMTCP_FLAG_CLIENT_SACKOK) &&\n            (q->flags & STREAMTCP_QUEUE_FLAG_SACK)) {\n        ssn->flags |= STREAMTCP_FLAG_SACKOK;\n        SCLogDebug(\"ssn %p: SACK permitted for session\", ssn);\n    } else {\n        ssn->flags &= ~STREAMTCP_FLAG_SACKOK;\n    }\n\n    ssn->server.next_win = ssn->server.last_ack + ssn->server.window;\n    ssn->client.next_win = ssn->client.last_ack + ssn->client.window;\n    SCLogDebug(\"ssn %p: ssn->server.next_win %\" PRIu32 \"\", ssn,\n            ssn->server.next_win);\n    SCLogDebug(\"ssn %p: ssn->client.next_win %\" PRIu32 \"\", ssn,\n            ssn->client.next_win);\n    SCLogDebug(\"ssn %p: ssn->server.isn %\" PRIu32 \", \"\n            \"ssn->server.next_seq %\" PRIu32 \", \"\n            \"ssn->server.last_ack %\" PRIu32 \" \"\n            \"(ssn->client.last_ack %\" PRIu32 \")\", ssn,\n            ssn->server.isn, ssn->server.next_seq,\n            ssn->server.last_ack, ssn->client.last_ack);\n\n    /* unset the 4WHS flag as we received this SYN/ACK as part of a\n     * (so far) valid 3WHS */\n    if (ssn->flags & STREAMTCP_FLAG_4WHS)\n        SCLogDebug(\"ssn %p: STREAMTCP_FLAG_4WHS unset, normal SYN/ACK\"\n                \" so considering 3WHS\", ssn);\n\n    ssn->flags &=~ STREAMTCP_FLAG_4WHS;\n}\n\n/** \\internal\n *  \\brief detect timestamp anomalies when processing responses to the\n *         SYN packet.\n *  \\retval true packet is ok\n *  \\retval false packet is bad\n */\nstatic inline bool StateSynSentValidateTimestamp(TcpSession *ssn, Packet *p)\n{\n    /* we only care about evil server here, so skip TS packets */\n    if (PKT_IS_TOSERVER(p) || !(TCP_HAS_TS(p))) {\n        return true;\n    }\n\n    TcpStream *receiver_stream = &ssn->client;\n    uint32_t ts_echo = TCP_GET_TSECR(p);\n    if ((receiver_stream->flags & STREAMTCP_STREAM_FLAG_TIMESTAMP) != 0) {\n        if (receiver_stream->last_ts != 0 && ts_echo != 0 &&\n            ts_echo != receiver_stream->last_ts)\n        {\n            SCLogDebug(\"ssn %p: BAD TSECR echo %u recv %u\", ssn,\n                    ts_echo, receiver_stream->last_ts);\n            return false;\n        }\n    } else {\n        if (receiver_stream->last_ts == 0 && ts_echo != 0) {\n            SCLogDebug(\"ssn %p: BAD TSECR echo %u recv %u\", ssn,\n                    ts_echo, receiver_stream->last_ts);\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n *  \\brief  Function to handle the TCP_SYN_SENT state. The function handles\n *          SYN, SYN/ACK, RST packets and correspondingly changes the connection\n *          state.\n *\n *  \\param  tv      Thread Variable containing  input/output queue, cpu affinity\n *  \\param  p       Packet which has to be handled in this TCP state.\n *  \\param  stt     Strean Thread module registered to handle the stream handling\n */\n\nstatic int StreamTcpPacketStateSynSent(ThreadVars *tv, Packet *p,\n        StreamTcpThread *stt, TcpSession *ssn,\n        PacketQueueNoLock *pq)\n{\n    if (ssn == NULL)\n        return -1;\n\n    SCLogDebug(\"ssn %p: pkt received: %s\", ssn, PKT_IS_TOCLIENT(p) ?\n               \"toclient\":\"toserver\");\n\n    /* check for bad responses */\n    if (StateSynSentValidateTimestamp(ssn, p) == false)\n        return -1;\n\n    /* RST */\n    if (p->tcph->th_flags & TH_RST) {\n        if (!StreamTcpValidateRst(ssn, p))\n            return -1;\n\n        if (PKT_IS_TOSERVER(p)) {\n            if (SEQ_EQ(TCP_GET_SEQ(p), ssn->client.isn) &&\n                    SEQ_EQ(TCP_GET_WINDOW(p), 0) &&\n                    SEQ_EQ(TCP_GET_ACK(p), (ssn->client.isn + 1)))\n            {\n                SCLogDebug(\"ssn->server.flags |= STREAMTCP_STREAM_FLAG_RST_RECV\");\n                ssn->server.flags |= STREAMTCP_STREAM_FLAG_RST_RECV;\n                StreamTcpCloseSsnWithReset(p, ssn);\n            }\n        } else {\n            ssn->client.flags |= STREAMTCP_STREAM_FLAG_RST_RECV;\n            SCLogDebug(\"ssn->client.flags |= STREAMTCP_STREAM_FLAG_RST_RECV\");\n            StreamTcpCloseSsnWithReset(p, ssn);\n        }\n\n    /* FIN */\n    } else if (p->tcph->th_flags & TH_FIN) {\n        /** \\todo */\n\n    /* SYN/ACK */\n    } else if ((p->tcph->th_flags & (TH_SYN|TH_ACK)) == (TH_SYN|TH_ACK)) {\n        if ((ssn->flags & STREAMTCP_FLAG_4WHS) && PKT_IS_TOSERVER(p)) {\n            SCLogDebug(\"ssn %p: SYN/ACK received on 4WHS session\", ssn);\n\n            /* Check if the SYN/ACK packet ack's the earlier\n             * received SYN packet. */\n            if (!(SEQ_EQ(TCP_GET_ACK(p), ssn->server.isn + 1))) {\n                StreamTcpSetEvent(p, STREAM_4WHS_SYNACK_WITH_WRONG_ACK);\n\n                SCLogDebug(\"ssn %p: 4WHS ACK mismatch, packet ACK %\"PRIu32\"\"\n                        \" != %\" PRIu32 \" from stream\", ssn,\n                        TCP_GET_ACK(p), ssn->server.isn + 1);\n                return -1;\n            }\n\n            /* Check if the SYN/ACK packet SEQ's the *FIRST* received SYN\n             * packet. */\n            if (!(SEQ_EQ(TCP_GET_SEQ(p), ssn->client.isn))) {\n                StreamTcpSetEvent(p, STREAM_4WHS_SYNACK_WITH_WRONG_SYN);\n\n                SCLogDebug(\"ssn %p: 4WHS SEQ mismatch, packet SEQ %\"PRIu32\"\"\n                        \" != %\" PRIu32 \" from *first* SYN pkt\", ssn,\n                        TCP_GET_SEQ(p), ssn->client.isn);\n                return -1;\n            }\n\n\n            /* update state */\n            StreamTcpPacketSetState(p, ssn, TCP_SYN_RECV);\n            SCLogDebug(\"ssn %p: =~ 4WHS ssn state is now TCP_SYN_RECV\", ssn);\n\n            /* sequence number & window */\n            ssn->client.isn = TCP_GET_SEQ(p);\n            STREAMTCP_SET_RA_BASE_SEQ(&ssn->client, ssn->client.isn);\n            ssn->client.next_seq = ssn->client.isn + 1;\n\n            ssn->server.window = TCP_GET_WINDOW(p);\n            SCLogDebug(\"ssn %p: 4WHS window %\" PRIu32 \"\", ssn,\n                    ssn->client.window);\n\n            /* Set the timestamp values used to validate the timestamp of\n             * received packets. */\n            if ((TCP_HAS_TS(p)) &&\n                    (ssn->server.flags & STREAMTCP_STREAM_FLAG_TIMESTAMP))\n            {\n                ssn->client.last_ts = TCP_GET_TSVAL(p);\n                SCLogDebug(\"ssn %p: 4WHS ssn->client.last_ts %\" PRIu32\" \"\n                        \"ssn->server.last_ts %\" PRIu32\"\", ssn,\n                        ssn->client.last_ts, ssn->server.last_ts);\n                ssn->flags |= STREAMTCP_FLAG_TIMESTAMP;\n                ssn->client.last_pkt_ts = p->ts.tv_sec;\n                if (ssn->client.last_ts == 0)\n                    ssn->client.flags |= STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n            } else {\n                ssn->server.last_ts = 0;\n                ssn->client.last_ts = 0;\n                ssn->server.flags &= ~STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n            }\n\n            ssn->server.last_ack = TCP_GET_ACK(p);\n            ssn->client.last_ack = ssn->client.isn + 1;\n\n            /** check for the presense of the ws ptr to determine if we\n             *  support wscale at all */\n            if ((ssn->flags & STREAMTCP_FLAG_SERVER_WSCALE) &&\n                    (TCP_HAS_WSCALE(p)))\n            {\n                ssn->server.wscale = TCP_GET_WSCALE(p);\n            } else {\n                ssn->server.wscale = 0;\n            }\n\n            if ((ssn->flags & STREAMTCP_FLAG_CLIENT_SACKOK) &&\n                    TCP_GET_SACKOK(p) == 1) {\n                ssn->flags |= STREAMTCP_FLAG_SACKOK;\n                SCLogDebug(\"ssn %p: SACK permitted for 4WHS session\", ssn);\n            }\n\n            ssn->client.next_win = ssn->client.last_ack + ssn->client.window;\n            ssn->server.next_win = ssn->server.last_ack + ssn->server.window;\n            SCLogDebug(\"ssn %p: 4WHS ssn->client.next_win %\" PRIu32 \"\", ssn,\n                    ssn->client.next_win);\n            SCLogDebug(\"ssn %p: 4WHS ssn->server.next_win %\" PRIu32 \"\", ssn,\n                    ssn->server.next_win);\n            SCLogDebug(\"ssn %p: 4WHS ssn->client.isn %\" PRIu32 \", \"\n                    \"ssn->client.next_seq %\" PRIu32 \", \"\n                    \"ssn->client.last_ack %\" PRIu32 \" \"\n                    \"(ssn->server.last_ack %\" PRIu32 \")\", ssn,\n                    ssn->client.isn, ssn->client.next_seq,\n                    ssn->client.last_ack, ssn->server.last_ack);\n\n            /* done here */\n            return 0;\n        }\n\n        if (PKT_IS_TOSERVER(p)) {\n            StreamTcpSetEvent(p, STREAM_3WHS_SYNACK_IN_WRONG_DIRECTION);\n            SCLogDebug(\"ssn %p: SYN/ACK received in the wrong direction\", ssn);\n            return -1;\n        }\n\n        if (!(TCP_HAS_TFO(p) || (ssn->flags & STREAMTCP_FLAG_TCP_FAST_OPEN))) {\n            /* Check if the SYN/ACK packet ack's the earlier\n             * received SYN packet. */\n            if (!(SEQ_EQ(TCP_GET_ACK(p), ssn->client.isn + 1))) {\n                StreamTcpSetEvent(p, STREAM_3WHS_SYNACK_WITH_WRONG_ACK);\n                SCLogDebug(\"ssn %p: ACK mismatch, packet ACK %\" PRIu32 \" != \"\n                        \"%\" PRIu32 \" from stream\", ssn, TCP_GET_ACK(p),\n                        ssn->client.isn + 1);\n                return -1;\n            }\n        } else {\n            if (!(SEQ_EQ(TCP_GET_ACK(p), ssn->client.next_seq))) {\n                StreamTcpSetEvent(p, STREAM_3WHS_SYNACK_WITH_WRONG_ACK);\n                SCLogDebug(\"ssn %p: (TFO) ACK mismatch, packet ACK %\" PRIu32 \" != \"\n                        \"%\" PRIu32 \" from stream\", ssn, TCP_GET_ACK(p),\n                        ssn->client.next_seq);\n                return -1;\n            }\n            SCLogDebug(\"ssn %p: (TFO) ACK match, packet ACK %\" PRIu32 \" == \"\n                    \"%\" PRIu32 \" from stream\", ssn, TCP_GET_ACK(p),\n                    ssn->client.next_seq);\n\n            ssn->flags |= STREAMTCP_FLAG_TCP_FAST_OPEN;\n            StreamTcpPacketSetState(p, ssn, TCP_ESTABLISHED);\n        }\n        StreamTcp3whsSynAckUpdate(ssn, p, /* no queue override */NULL);\n\n    } else if (p->tcph->th_flags & TH_SYN) {\n        SCLogDebug(\"ssn %p: SYN packet on state SYN_SENT... resent\", ssn);\n        if (ssn->flags & STREAMTCP_FLAG_4WHS) {\n            SCLogDebug(\"ssn %p: SYN packet on state SYN_SENT... resent of \"\n                    \"4WHS SYN\", ssn);\n        }\n\n        if (PKT_IS_TOCLIENT(p)) {\n            /** a SYN only packet in the opposite direction could be:\n             *  http://www.breakingpointsystems.com/community/blog/tcp-\n             *  portals-the-three-way-handshake-is-a-lie\n             *\n             * \\todo improve resetting the session */\n\n            /* indicate that we're dealing with 4WHS here */\n            ssn->flags |= STREAMTCP_FLAG_4WHS;\n            SCLogDebug(\"ssn %p: STREAMTCP_FLAG_4WHS flag set\", ssn);\n\n            /* set the sequence numbers and window for server\n             * We leave the ssn->client.isn in place as we will\n             * check the SYN/ACK pkt with that.\n             */\n            ssn->server.isn = TCP_GET_SEQ(p);\n            STREAMTCP_SET_RA_BASE_SEQ(&ssn->server, ssn->server.isn);\n            ssn->server.next_seq = ssn->server.isn + 1;\n\n            /* Set the stream timestamp value, if packet has timestamp\n             * option enabled. */\n            if (TCP_HAS_TS(p)) {\n                ssn->server.last_ts = TCP_GET_TSVAL(p);\n                SCLogDebug(\"ssn %p: %02x\", ssn, ssn->server.last_ts);\n\n                if (ssn->server.last_ts == 0)\n                    ssn->server.flags |= STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n                ssn->server.last_pkt_ts = p->ts.tv_sec;\n                ssn->server.flags |= STREAMTCP_STREAM_FLAG_TIMESTAMP;\n            }\n\n            ssn->server.window = TCP_GET_WINDOW(p);\n            if (TCP_HAS_WSCALE(p)) {\n                ssn->flags |= STREAMTCP_FLAG_SERVER_WSCALE;\n                ssn->server.wscale = TCP_GET_WSCALE(p);\n            } else {\n                ssn->flags &= ~STREAMTCP_FLAG_SERVER_WSCALE;\n                ssn->server.wscale = 0;\n            }\n\n            if (TCP_GET_SACKOK(p) == 1) {\n                ssn->flags |= STREAMTCP_FLAG_CLIENT_SACKOK;\n            } else {\n                ssn->flags &= ~STREAMTCP_FLAG_CLIENT_SACKOK;\n            }\n\n            SCLogDebug(\"ssn %p: 4WHS ssn->server.isn %\" PRIu32 \", \"\n                    \"ssn->server.next_seq %\" PRIu32 \", \"\n                    \"ssn->server.last_ack %\"PRIu32\"\", ssn,\n                    ssn->server.isn, ssn->server.next_seq,\n                    ssn->server.last_ack);\n            SCLogDebug(\"ssn %p: 4WHS ssn->client.isn %\" PRIu32 \", \"\n                    \"ssn->client.next_seq %\" PRIu32 \", \"\n                    \"ssn->client.last_ack %\"PRIu32\"\", ssn,\n                    ssn->client.isn, ssn->client.next_seq,\n                    ssn->client.last_ack);\n        }\n\n        /** \\todo check if it's correct or set event */\n\n    } else if (p->tcph->th_flags & TH_ACK) {\n        /* Handle the asynchronous stream, when we receive a  SYN packet\n           and now instead of receiving a SYN/ACK we receive a ACK from the\n           same host, which sent the SYN, this suggests the ASYNC streams.*/\n        if (stream_config.async_oneside == FALSE)\n            return 0;\n\n        /* we are in AYNC (one side) mode now. */\n\n        /* one side async means we won't see a SYN/ACK, so we can\n         * only check the SYN. */\n        if (!(SEQ_EQ(TCP_GET_SEQ(p), ssn->client.next_seq))) {\n            StreamTcpSetEvent(p, STREAM_3WHS_ASYNC_WRONG_SEQ);\n\n            SCLogDebug(\"ssn %p: SEQ mismatch, packet SEQ %\" PRIu32 \" != \"\n                    \"%\" PRIu32 \" from stream\",ssn, TCP_GET_SEQ(p),\n                    ssn->client.next_seq);\n            return -1;\n        }\n\n        ssn->flags |= STREAMTCP_FLAG_ASYNC;\n        StreamTcpPacketSetState(p, ssn, TCP_ESTABLISHED);\n        SCLogDebug(\"ssn %p: =~ ssn state is now TCP_ESTABLISHED\", ssn);\n\n        ssn->client.window = TCP_GET_WINDOW(p);\n        ssn->client.last_ack = TCP_GET_SEQ(p);\n        ssn->client.next_win = ssn->client.last_ack + ssn->client.window;\n\n        /* Set the server side parameters */\n        ssn->server.isn = TCP_GET_ACK(p) - 1;\n        STREAMTCP_SET_RA_BASE_SEQ(&ssn->server, ssn->server.isn);\n        ssn->server.next_seq = ssn->server.isn + 1;\n        ssn->server.last_ack = ssn->server.next_seq;\n        ssn->server.next_win = ssn->server.last_ack;\n\n        SCLogDebug(\"ssn %p: synsent => Asynchronous stream, packet SEQ\"\n                \" %\" PRIu32 \", payload size %\" PRIu32 \" (%\" PRIu32 \"), \"\n                \"ssn->client.next_seq %\" PRIu32 \"\"\n                ,ssn, TCP_GET_SEQ(p), p->payload_len, TCP_GET_SEQ(p)\n                + p->payload_len, ssn->client.next_seq);\n\n        /* if SYN had wscale, assume it to be supported. Otherwise\n         * we know it not to be supported. */\n        if (ssn->flags & STREAMTCP_FLAG_SERVER_WSCALE) {\n            ssn->client.wscale = TCP_WSCALE_MAX;\n        }\n\n        /* Set the timestamp values used to validate the timestamp of\n         * received packets.*/\n        if (TCP_HAS_TS(p) &&\n                (ssn->client.flags & STREAMTCP_STREAM_FLAG_TIMESTAMP))\n        {\n            ssn->flags |= STREAMTCP_FLAG_TIMESTAMP;\n            ssn->client.flags &= ~STREAMTCP_STREAM_FLAG_TIMESTAMP;\n            ssn->client.last_pkt_ts = p->ts.tv_sec;\n        } else {\n            ssn->client.last_ts = 0;\n            ssn->client.flags &= ~STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n        }\n\n        if (ssn->flags & STREAMTCP_FLAG_CLIENT_SACKOK) {\n            ssn->flags |= STREAMTCP_FLAG_SACKOK;\n        }\n\n        StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                &ssn->client, p, pq);\n\n    } else {\n        SCLogDebug(\"ssn %p: default case\", ssn);\n    }\n\n    return 0;\n}\n\n/**\n *  \\brief  Function to handle the TCP_SYN_RECV state. The function handles\n *          SYN, SYN/ACK, ACK, FIN, RST packets and correspondingly changes\n *          the connection state.\n *\n *  \\param  tv      Thread Variable containing  input/output queue, cpu affinity\n *  \\param  p       Packet which has to be handled in this TCP state.\n *  \\param  stt     Strean Thread module registered to handle the stream handling\n *\n *  \\retval  0 ok\n *  \\retval -1 error\n */\n\nstatic int StreamTcpPacketStateSynRecv(ThreadVars *tv, Packet *p,\n        StreamTcpThread *stt, TcpSession *ssn,\n        PacketQueueNoLock *pq)\n{\n    if (ssn == NULL)\n        return -1;\n\n    if (p->tcph->th_flags & TH_RST) {\n        if (!StreamTcpValidateRst(ssn, p))\n            return -1;\n\n        bool reset = true;\n        /* After receiveing the RST in SYN_RECV state and if detection\n           evasion flags has been set, then the following operating\n           systems will not closed the connection. As they consider the\n           packet as stray packet and not belonging to the current\n           session, for more information check\n           http://www.packetstan.com/2010/06/recently-ive-been-on-campaign-to-make.html */\n        if (ssn->flags & STREAMTCP_FLAG_DETECTION_EVASION_ATTEMPT) {\n            if (PKT_IS_TOSERVER(p)) {\n                if ((ssn->server.os_policy == OS_POLICY_LINUX) ||\n                        (ssn->server.os_policy == OS_POLICY_OLD_LINUX) ||\n                        (ssn->server.os_policy == OS_POLICY_SOLARIS))\n                {\n                    reset = false;\n                    SCLogDebug(\"Detection evasion has been attempted, so\"\n                            \" not resetting the connection !!\");\n                }\n            } else {\n                if ((ssn->client.os_policy == OS_POLICY_LINUX) ||\n                        (ssn->client.os_policy == OS_POLICY_OLD_LINUX) ||\n                        (ssn->client.os_policy == OS_POLICY_SOLARIS))\n                {\n                    reset = false;\n                    SCLogDebug(\"Detection evasion has been attempted, so\"\n                            \" not resetting the connection !!\");\n                }\n            }\n        }\n\n        if (reset) {\n            StreamTcpCloseSsnWithReset(p, ssn);\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n        }\n\n    } else if (p->tcph->th_flags & TH_FIN) {\n        /* FIN is handled in the same way as in TCP_ESTABLISHED case */;\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            if (!StreamTcpValidateTimestamp(ssn, p))\n                return -1;\n        }\n\n        if ((StreamTcpHandleFin(tv, stt, ssn, p, pq)) == -1)\n            return -1;\n\n    /* SYN/ACK */\n    } else if ((p->tcph->th_flags & (TH_SYN|TH_ACK)) == (TH_SYN|TH_ACK)) {\n        SCLogDebug(\"ssn %p: SYN/ACK packet on state SYN_RECV. resent\", ssn);\n\n        if (PKT_IS_TOSERVER(p)) {\n            SCLogDebug(\"ssn %p: SYN/ACK-pkt to server in SYN_RECV state\", ssn);\n\n            StreamTcpSetEvent(p, STREAM_3WHS_SYNACK_TOSERVER_ON_SYN_RECV);\n            return -1;\n        }\n\n        /* Check if the SYN/ACK packets ACK matches the earlier\n         * received SYN/ACK packet. */\n        if (!(SEQ_EQ(TCP_GET_ACK(p), ssn->client.last_ack))) {\n            SCLogDebug(\"ssn %p: ACK mismatch, packet ACK %\" PRIu32 \" != \"\n                    \"%\" PRIu32 \" from stream\", ssn, TCP_GET_ACK(p),\n                    ssn->client.isn + 1);\n\n            StreamTcpSetEvent(p, STREAM_3WHS_SYNACK_RESEND_WITH_DIFFERENT_ACK);\n            return -1;\n        }\n\n        /* Check if the SYN/ACK packet SEQ the earlier\n         * received SYN/ACK packet, server resend with different ISN. */\n        if (!(SEQ_EQ(TCP_GET_SEQ(p), ssn->server.isn))) {\n            SCLogDebug(\"ssn %p: SEQ mismatch, packet SEQ %\" PRIu32 \" != \"\n                    \"%\" PRIu32 \" from stream\", ssn, TCP_GET_SEQ(p),\n                    ssn->client.isn);\n\n            if (StreamTcp3whsQueueSynAck(ssn, p) == -1)\n                return -1;\n            SCLogDebug(\"ssn %p: queued different SYN/ACK\", ssn);\n        }\n\n    } else if (p->tcph->th_flags & TH_SYN) {\n        SCLogDebug(\"ssn %p: SYN packet on state SYN_RECV... resent\", ssn);\n\n        if (PKT_IS_TOCLIENT(p)) {\n            SCLogDebug(\"ssn %p: SYN-pkt to client in SYN_RECV state\", ssn);\n\n            StreamTcpSetEvent(p, STREAM_3WHS_SYN_TOCLIENT_ON_SYN_RECV);\n            return -1;\n        }\n\n        if (!(SEQ_EQ(TCP_GET_SEQ(p), ssn->client.isn))) {\n            SCLogDebug(\"ssn %p: SYN with different SEQ on SYN_RECV state\", ssn);\n\n            StreamTcpSetEvent(p, STREAM_3WHS_SYN_RESEND_DIFF_SEQ_ON_SYN_RECV);\n            return -1;\n        }\n\n    } else if (p->tcph->th_flags & TH_ACK) {\n        if (ssn->queue_len) {\n            SCLogDebug(\"ssn %p: checking ACK against queued SYN/ACKs\", ssn);\n            TcpStateQueue *q = StreamTcp3whsFindSynAckByAck(ssn, p);\n            if (q != NULL) {\n                SCLogDebug(\"ssn %p: here we update state against queued SYN/ACK\", ssn);\n                StreamTcp3whsSynAckUpdate(ssn, p, /* using queue to update state */q);\n            } else {\n                SCLogDebug(\"ssn %p: none found, now checking ACK against original SYN/ACK (state)\", ssn);\n            }\n        }\n\n\n        /* If the timestamp option is enabled for both the streams, then\n         * validate the received packet timestamp value against the\n         * stream->last_ts. If the timestamp is valid then process the\n         * packet normally otherwise the drop the packet (RFC 1323)*/\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            if (!(StreamTcpValidateTimestamp(ssn, p))) {\n                return -1;\n            }\n        }\n\n        if ((ssn->flags & STREAMTCP_FLAG_4WHS) && PKT_IS_TOCLIENT(p)) {\n            SCLogDebug(\"ssn %p: ACK received on 4WHS session\",ssn);\n\n            if (!(SEQ_EQ(TCP_GET_SEQ(p), ssn->server.next_seq))) {\n                SCLogDebug(\"ssn %p: 4WHS wrong seq nr on packet\", ssn);\n                StreamTcpSetEvent(p, STREAM_4WHS_WRONG_SEQ);\n                return -1;\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->client, p) == -1) {\n                SCLogDebug(\"ssn %p: 4WHS invalid ack nr on packet\", ssn);\n                StreamTcpSetEvent(p, STREAM_4WHS_INVALID_ACK);\n                return -1;\n            }\n\n            SCLogDebug(\"4WHS normal pkt\");\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to client: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_ACK(p));\n            StreamTcpUpdateNextSeq(ssn, &ssn->server, (ssn->server.next_seq + p->payload_len));\n            ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n            ssn->client.next_win = ssn->client.last_ack + ssn->client.window;\n\n            StreamTcpPacketSetState(p, ssn, TCP_ESTABLISHED);\n            SCLogDebug(\"ssn %p: =~ ssn state is now TCP_ESTABLISHED\", ssn);\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n\n            SCLogDebug(\"ssn %p: ssn->client.next_win %\" PRIu32 \", \"\n                    \"ssn->client.last_ack %\"PRIu32\"\", ssn,\n                    ssn->client.next_win, ssn->client.last_ack);\n            return 0;\n        }\n\n        bool ack_indicates_missed_3whs_ack_packet = false;\n        /* Check if the ACK received is in right direction. But when we have\n         * picked up a mid stream session after missing the initial SYN pkt,\n         * in this case the ACK packet can arrive from either client (normal\n         * case) or from server itself (asynchronous streams). Therefore\n         *  the check has been avoided in this case */\n        if (PKT_IS_TOCLIENT(p)) {\n            /* special case, handle 4WHS, so SYN/ACK in the opposite\n             * direction */\n            if (ssn->flags & STREAMTCP_FLAG_MIDSTREAM_SYNACK) {\n                SCLogDebug(\"ssn %p: ACK received on midstream SYN/ACK \"\n                        \"pickup session\",ssn);\n                /* fall through */\n            } else if (ssn->flags & STREAMTCP_FLAG_TCP_FAST_OPEN) {\n                SCLogDebug(\"ssn %p: ACK received on TFO session\",ssn);\n                /* fall through */\n\n            } else {\n                /* if we missed traffic between the S/SA and the current\n                 * 'wrong direction' ACK, we could end up here. In IPS\n                 * reject it. But in IDS mode we continue.\n                 *\n                 * IPS rejects as it should see all packets, so pktloss\n                 * should lead to retransmissions. As this can also be\n                 * pattern for MOTS/MITM injection attacks, we need to be\n                 * careful.\n                 */\n                if (StreamTcpInlineMode()) {\n                    if (p->payload_len > 0 &&\n                            SEQ_EQ(TCP_GET_ACK(p), ssn->client.last_ack) &&\n                            SEQ_EQ(TCP_GET_SEQ(p), ssn->server.next_seq)) {\n                        /* packet loss is possible but unlikely here */\n                        SCLogDebug(\"ssn %p: possible data injection\", ssn);\n                        StreamTcpSetEvent(p, STREAM_3WHS_ACK_DATA_INJECT);\n                        return -1;\n                    }\n\n                    SCLogDebug(\"ssn %p: ACK received in the wrong direction\",\n                            ssn);\n                    StreamTcpSetEvent(p, STREAM_3WHS_ACK_IN_WRONG_DIR);\n                    return -1;\n                }\n                ack_indicates_missed_3whs_ack_packet = true;\n            }\n        }\n\n        SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to server: SEQ %\" PRIu32 \"\"\n                \", ACK %\" PRIu32 \"\", ssn, p->payload_len, TCP_GET_SEQ(p),\n                TCP_GET_ACK(p));\n\n        /* Check both seq and ack number before accepting the packet and\n           changing to ESTABLISHED state */\n        if ((SEQ_EQ(TCP_GET_SEQ(p), ssn->client.next_seq)) &&\n                SEQ_EQ(TCP_GET_ACK(p), ssn->server.next_seq)) {\n            SCLogDebug(\"normal pkt\");\n\n            /* process the packet normal, No Async streams :) */\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server, TCP_GET_ACK(p));\n            StreamTcpUpdateNextSeq(ssn, &ssn->client, (ssn->client.next_seq + p->payload_len));\n            ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n\n            ssn->server.next_win = ssn->server.last_ack + ssn->server.window;\n\n            if (ssn->flags & STREAMTCP_FLAG_MIDSTREAM) {\n                ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n                ssn->client.next_win = ssn->client.last_ack + ssn->client.window;\n                ssn->server.next_win = ssn->server.last_ack +\n                    ssn->server.window;\n                if (!(ssn->flags & STREAMTCP_FLAG_MIDSTREAM_SYNACK)) {\n                    /* window scaling for midstream pickups, we can't do much\n                     * other than assume that it's set to the max value: 14 */\n                    ssn->server.wscale = TCP_WSCALE_MAX;\n                    ssn->client.wscale = TCP_WSCALE_MAX;\n                    ssn->flags |= STREAMTCP_FLAG_SACKOK;\n                }\n            }\n\n            StreamTcpPacketSetState(p, ssn, TCP_ESTABLISHED);\n            SCLogDebug(\"ssn %p: =~ ssn state is now TCP_ESTABLISHED\", ssn);\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n\n            /* If asynchronous stream handling is allowed then set the session,\n               if packet's seq number is equal the expected seq no.*/\n        } else if (stream_config.async_oneside == TRUE &&\n                (SEQ_EQ(TCP_GET_SEQ(p), ssn->server.next_seq)))\n        {\n            /*set the ASYNC flag used to indicate the session as async stream\n              and helps in relaxing the windows checks.*/\n            ssn->flags |= STREAMTCP_FLAG_ASYNC;\n            ssn->server.next_seq += p->payload_len;\n            ssn->server.last_ack = TCP_GET_SEQ(p);\n\n            ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n            ssn->client.last_ack = TCP_GET_ACK(p);\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            if (ssn->flags & STREAMTCP_FLAG_MIDSTREAM) {\n                ssn->server.window = TCP_GET_WINDOW(p);\n                ssn->server.next_win = ssn->server.last_ack + ssn->server.window;\n                /* window scaling for midstream pickups, we can't do much\n                 * other than assume that it's set to the max value: 14 */\n                ssn->server.wscale = TCP_WSCALE_MAX;\n                ssn->client.wscale = TCP_WSCALE_MAX;\n                ssn->flags |= STREAMTCP_FLAG_SACKOK;\n            }\n\n            SCLogDebug(\"ssn %p: synrecv => Asynchronous stream, packet SEQ\"\n                    \" %\" PRIu32 \", payload size %\" PRIu32 \" (%\" PRIu32 \"), \"\n                    \"ssn->server.next_seq %\" PRIu32\n                    , ssn, TCP_GET_SEQ(p), p->payload_len, TCP_GET_SEQ(p)\n                    + p->payload_len, ssn->server.next_seq);\n\n            StreamTcpPacketSetState(p, ssn, TCP_ESTABLISHED);\n            SCLogDebug(\"ssn %p: =~ ssn state is now TCP_ESTABLISHED\", ssn);\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n            /* Upon receiving the packet with correct seq number and wrong\n               ACK number, it causes the other end to send RST. But some target\n               system (Linux & solaris) does not RST the connection, so it is\n               likely to avoid the detection */\n        } else if (SEQ_EQ(TCP_GET_SEQ(p), ssn->client.next_seq)){\n            ssn->flags |= STREAMTCP_FLAG_DETECTION_EVASION_ATTEMPT;\n            SCLogDebug(\"ssn %p: wrong ack nr on packet, possible evasion!!\",\n                    ssn);\n\n            StreamTcpSetEvent(p, STREAM_3WHS_RIGHT_SEQ_WRONG_ACK_EVASION);\n            return -1;\n\n            /* SYN/ACK followed by more TOCLIENT suggesting packet loss */\n        } else if (PKT_IS_TOCLIENT(p) && !StreamTcpInlineMode() &&\n                   SEQ_GT(TCP_GET_SEQ(p), ssn->client.next_seq) &&\n                   SEQ_GT(TCP_GET_ACK(p), ssn->client.last_ack)) {\n            SCLogDebug(\"ssn %p: ACK for missing data\", ssn);\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_ACK(p));\n\n            ssn->server.next_seq = TCP_GET_SEQ(p) + p->payload_len;\n            SCLogDebug(\"ssn %p: ACK for missing data: ssn->server.next_seq %u\", ssn,\n                    ssn->server.next_seq);\n            ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n\n            ssn->client.next_win = ssn->client.last_ack + ssn->client.window;\n\n            ssn->client.window = TCP_GET_WINDOW(p);\n            ssn->server.next_win = ssn->server.last_ack + ssn->server.window;\n\n            StreamTcpPacketSetState(p, ssn, TCP_ESTABLISHED);\n            SCLogDebug(\"ssn %p: =~ ssn state is now TCP_ESTABLISHED\", ssn);\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn, &ssn->server, p, pq);\n\n            /* if we get a packet with a proper ack, but a seq that is beyond\n             * next_seq but in-window, we probably missed some packets */\n        } else if (SEQ_GT(TCP_GET_SEQ(p), ssn->client.next_seq) &&\n                   SEQ_LEQ(TCP_GET_SEQ(p), ssn->client.next_win) &&\n                   SEQ_EQ(TCP_GET_ACK(p), ssn->server.next_seq)) {\n            SCLogDebug(\"ssn %p: ACK for missing data\", ssn);\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server, TCP_GET_ACK(p));\n\n            ssn->client.next_seq = TCP_GET_SEQ(p) + p->payload_len;\n            SCLogDebug(\"ssn %p: ACK for missing data: ssn->client.next_seq %u\", ssn, ssn->client.next_seq);\n            ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n\n            ssn->server.next_win = ssn->server.last_ack + ssn->server.window;\n\n            if (ssn->flags & STREAMTCP_FLAG_MIDSTREAM) {\n                ssn->client.window = TCP_GET_WINDOW(p);\n                ssn->server.next_win = ssn->server.last_ack +\n                    ssn->server.window;\n                /* window scaling for midstream pickups, we can't do much\n                 * other than assume that it's set to the max value: 14 */\n                ssn->server.wscale = TCP_WSCALE_MAX;\n                ssn->client.wscale = TCP_WSCALE_MAX;\n                ssn->flags |= STREAMTCP_FLAG_SACKOK;\n            }\n\n            StreamTcpPacketSetState(p, ssn, TCP_ESTABLISHED);\n            SCLogDebug(\"ssn %p: =~ ssn state is now TCP_ESTABLISHED\", ssn);\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n\n        /* toclient packet: after having missed the 3whs's final ACK */\n        } else if ((ack_indicates_missed_3whs_ack_packet ||\n                           (ssn->flags & STREAMTCP_FLAG_TCP_FAST_OPEN)) &&\n                   SEQ_EQ(TCP_GET_ACK(p), ssn->client.last_ack) &&\n                   SEQ_EQ(TCP_GET_SEQ(p), ssn->server.next_seq)) {\n            if (ack_indicates_missed_3whs_ack_packet) {\n                SCLogDebug(\"ssn %p: packet fits perfectly after a missed 3whs-ACK\", ssn);\n            } else {\n                SCLogDebug(\"ssn %p: (TFO) expected packet fits perfectly after SYN/ACK\", ssn);\n            }\n\n            StreamTcpUpdateNextSeq(ssn, &ssn->server, (TCP_GET_SEQ(p) + p->payload_len));\n\n            ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n            ssn->server.next_win = ssn->server.last_ack + ssn->server.window;\n\n            StreamTcpPacketSetState(p, ssn, TCP_ESTABLISHED);\n            SCLogDebug(\"ssn %p: =~ ssn state is now TCP_ESTABLISHED\", ssn);\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n\n        } else {\n            SCLogDebug(\"ssn %p: wrong seq nr on packet\", ssn);\n\n            StreamTcpSetEvent(p, STREAM_3WHS_WRONG_SEQ_WRONG_ACK);\n            return -1;\n        }\n\n        SCLogDebug(\"ssn %p: ssn->server.next_win %\" PRIu32 \", \"\n                \"ssn->server.last_ack %\"PRIu32\"\", ssn,\n                ssn->server.next_win, ssn->server.last_ack);\n    } else {\n        SCLogDebug(\"ssn %p: default case\", ssn);\n    }\n\n    return 0;\n}\n\n/**\n *  \\brief  Function to handle the TCP_ESTABLISHED state packets, which are\n *          sent by the client to server. The function handles\n *          ACK packets and call StreamTcpReassembleHandleSegment() to handle\n *          the reassembly.\n *\n *  Timestamp has already been checked at this point.\n *\n *  \\param  tv      Thread Variable containing  input/output queue, cpu affinity etc.\n *  \\param  ssn     Pointer to the current TCP session\n *  \\param  p       Packet which has to be handled in this TCP state.\n *  \\param  stt     Strean Thread module registered to handle the stream handling\n */\nstatic int HandleEstablishedPacketToServer(ThreadVars *tv, TcpSession *ssn, Packet *p,\n                        StreamTcpThread *stt, PacketQueueNoLock *pq)\n{\n    SCLogDebug(\"ssn %p: =+ pkt (%\" PRIu32 \") is to server: SEQ %\" PRIu32 \",\"\n               \"ACK %\" PRIu32 \", WIN %\"PRIu16\"\", ssn, p->payload_len,\n                TCP_GET_SEQ(p), TCP_GET_ACK(p), TCP_GET_WINDOW(p));\n\n    if (StreamTcpValidateAck(ssn, &(ssn->server), p) == -1) {\n        SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n        StreamTcpSetEvent(p, STREAM_EST_INVALID_ACK);\n        return -1;\n    }\n\n    /* check for Keep Alive */\n    if ((p->payload_len == 0 || p->payload_len == 1) &&\n            (TCP_GET_SEQ(p) == (ssn->client.next_seq - 1))) {\n        SCLogDebug(\"ssn %p: pkt is keep alive\", ssn);\n\n    /* normal pkt */\n    } else if (!(SEQ_GEQ((TCP_GET_SEQ(p)+p->payload_len), ssn->client.last_ack))) {\n        if (ssn->flags & STREAMTCP_FLAG_ASYNC) {\n            SCLogDebug(\"ssn %p: server => Asynchrouns stream, packet SEQ\"\n                    \" %\" PRIu32 \", payload size %\" PRIu32 \" (%\" PRIu32 \"),\"\n                    \" ssn->client.last_ack %\" PRIu32 \", ssn->client.next_win\"\n                    \"%\" PRIu32\"(%\"PRIu32\")\", ssn, TCP_GET_SEQ(p),\n                    p->payload_len, TCP_GET_SEQ(p) + p->payload_len,\n                    ssn->client.last_ack, ssn->client.next_win,\n                    TCP_GET_SEQ(p) + p->payload_len - ssn->client.next_win);\n\n            /* update the last_ack to current seq number as the session is\n             * async and other stream is not updating it anymore :( */\n            StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_SEQ(p));\n\n        } else if (SEQ_EQ(ssn->client.next_seq, TCP_GET_SEQ(p)) &&\n                (stream_config.async_oneside == TRUE) &&\n                (ssn->flags & STREAMTCP_FLAG_MIDSTREAM)) {\n            SCLogDebug(\"ssn %p: server => Asynchronous stream, packet SEQ.\"\n                    \" %\" PRIu32 \", payload size %\" PRIu32 \" (%\" PRIu32 \"), \"\n                    \"ssn->client.last_ack %\" PRIu32 \", ssn->client.next_win \"\n                    \"%\" PRIu32 \"(%\"PRIu32\")\", ssn, TCP_GET_SEQ(p),\n                    p->payload_len, TCP_GET_SEQ(p) + p->payload_len,\n                    ssn->client.last_ack, ssn->client.next_win,\n                    TCP_GET_SEQ(p) + p->payload_len - ssn->client.next_win);\n\n            /* it seems we missed SYN and SYN/ACK packets of this session.\n             * Update the last_ack to current seq number as the session\n             * is async and other stream is not updating it anymore :( */\n            StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_SEQ(p));\n            ssn->flags |= STREAMTCP_FLAG_ASYNC;\n\n        } else if (SEQ_EQ(ssn->client.last_ack, (ssn->client.isn + 1)) &&\n                (stream_config.async_oneside == TRUE) &&\n                (ssn->flags & STREAMTCP_FLAG_MIDSTREAM)) {\n            SCLogDebug(\"ssn %p: server => Asynchronous stream, packet SEQ\"\n                    \" %\" PRIu32 \", payload size %\" PRIu32 \" (%\" PRIu32 \"), \"\n                    \"ssn->client.last_ack %\" PRIu32 \", ssn->client.next_win \"\n                    \"%\" PRIu32 \"(%\"PRIu32\")\", ssn, TCP_GET_SEQ(p),\n                    p->payload_len, TCP_GET_SEQ(p) + p->payload_len,\n                    ssn->client.last_ack, ssn->client.next_win,\n                    TCP_GET_SEQ(p) + p->payload_len - ssn->client.next_win);\n\n            /* it seems we missed SYN and SYN/ACK packets of this session.\n             * Update the last_ack to current seq number as the session\n             * is async and other stream is not updating it anymore :(*/\n            StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_SEQ(p));\n            ssn->flags |= STREAMTCP_FLAG_ASYNC;\n\n        /* if last ack is beyond next_seq, we have accepted ack's for missing data.\n         * In this case we do accept the data before last_ack if it is (partly)\n         * beyond next seq */\n        } else if (SEQ_GT(ssn->client.last_ack, ssn->client.next_seq) &&\n                   SEQ_GT((TCP_GET_SEQ(p)+p->payload_len),ssn->client.next_seq))\n        {\n            SCLogDebug(\"ssn %p: PKT SEQ %\"PRIu32\" payload_len %\"PRIu16\n                    \" before last_ack %\"PRIu32\", after next_seq %\"PRIu32\":\"\n                    \" acked data that we haven't seen before\",\n                    ssn, TCP_GET_SEQ(p), p->payload_len, ssn->client.last_ack, ssn->client.next_seq);\n            if (SEQ_EQ(TCP_GET_SEQ(p),ssn->client.next_seq)) {\n                StreamTcpUpdateNextSeq(ssn, &ssn->client, (ssn->client.next_seq + p->payload_len));\n            }\n        } else {\n            SCLogDebug(\"ssn %p: server => SEQ before last_ack, packet SEQ\"\n                    \" %\" PRIu32 \", payload size %\" PRIu32 \" (%\" PRIu32 \"), \"\n                    \"ssn->client.last_ack %\" PRIu32 \", ssn->client.next_win \"\n                    \"%\" PRIu32 \"(%\"PRIu32\")\", ssn, TCP_GET_SEQ(p),\n                    p->payload_len, TCP_GET_SEQ(p) + p->payload_len,\n                    ssn->client.last_ack, ssn->client.next_win,\n                    TCP_GET_SEQ(p) + p->payload_len - ssn->client.next_win);\n\n            SCLogDebug(\"ssn %p: rejecting because pkt before last_ack\", ssn);\n            StreamTcpSetEvent(p, STREAM_EST_PKT_BEFORE_LAST_ACK);\n            return -1;\n        }\n    }\n\n    int zerowindowprobe = 0;\n    /* zero window probe */\n    if (p->payload_len == 1 && TCP_GET_SEQ(p) == ssn->client.next_seq && ssn->client.window == 0) {\n        SCLogDebug(\"ssn %p: zero window probe\", ssn);\n        zerowindowprobe = 1;\n\n    /* expected packet */\n    } else if (SEQ_EQ(ssn->client.next_seq, TCP_GET_SEQ(p))) {\n        StreamTcpUpdateNextSeq(ssn, &ssn->client, (ssn->client.next_seq + p->payload_len));\n\n    /* not completely as expected, but valid */\n    } else if (SEQ_LT(TCP_GET_SEQ(p),ssn->client.next_seq) &&\n               SEQ_GT((TCP_GET_SEQ(p)+p->payload_len), ssn->client.next_seq))\n    {\n        StreamTcpUpdateNextSeq(ssn, &ssn->client, (TCP_GET_SEQ(p) + p->payload_len));\n        SCLogDebug(\"ssn %p: ssn->client.next_seq %\"PRIu32\n                   \" (started before next_seq, ended after)\",\n                   ssn, ssn->client.next_seq);\n\n    /* if next_seq has fallen behind last_ack, we got some catching up to do */\n    } else if (SEQ_LT(ssn->client.next_seq, ssn->client.last_ack)) {\n        StreamTcpUpdateNextSeq(ssn, &ssn->client, (TCP_GET_SEQ(p) + p->payload_len));\n        SCLogDebug(\"ssn %p: ssn->client.next_seq %\"PRIu32\n                   \" (next_seq had fallen behind last_ack)\",\n                   ssn, ssn->client.next_seq);\n\n    } else {\n        SCLogDebug(\"ssn %p: no update to ssn->client.next_seq %\"PRIu32\n                   \" SEQ %u SEQ+ %u last_ack %u\",\n                   ssn, ssn->client.next_seq,\n                   TCP_GET_SEQ(p), TCP_GET_SEQ(p)+p->payload_len, ssn->client.last_ack);\n    }\n\n    /* in window check */\n    if (zerowindowprobe) {\n        SCLogDebug(\"ssn %p: zero window probe, skipping oow check\", ssn);\n    } else if (SEQ_LEQ(TCP_GET_SEQ(p) + p->payload_len, ssn->client.next_win) ||\n            (ssn->flags & (STREAMTCP_FLAG_MIDSTREAM|STREAMTCP_FLAG_ASYNC)))\n    {\n        SCLogDebug(\"ssn %p: seq %\"PRIu32\" in window, ssn->client.next_win \"\n                   \"%\" PRIu32 \"\", ssn, TCP_GET_SEQ(p), ssn->client.next_win);\n\n        ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n        SCLogDebug(\"ssn %p: ssn->server.window %\"PRIu32\"\", ssn,\n                    ssn->server.window);\n\n        /* Check if the ACK value is sane and inside the window limit */\n        if (p->tcph->th_flags & TH_ACK)\n            StreamTcpUpdateLastAck(ssn, &ssn->server, TCP_GET_ACK(p));\n        SCLogDebug(\"ack %u last_ack %u next_seq %u\", TCP_GET_ACK(p), ssn->server.last_ack, ssn->server.next_seq);\n\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            StreamTcpHandleTimestamp(ssn, p);\n        }\n\n        StreamTcpSackUpdatePacket(&ssn->server, p);\n\n        /* update next_win */\n        StreamTcpUpdateNextWin(ssn, &ssn->server, (ssn->server.last_ack + ssn->server.window));\n\n        /* handle data (if any) */\n        StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn, &ssn->client, p, pq);\n\n    } else {\n        SCLogDebug(\"ssn %p: toserver => SEQ out of window, packet SEQ \"\n                \"%\" PRIu32 \", payload size %\" PRIu32 \" (%\" PRIu32 \"),\"\n                \"ssn->client.last_ack %\" PRIu32 \", ssn->client.next_win \"\n                \"%\" PRIu32 \"(%\"PRIu32\")\", ssn, TCP_GET_SEQ(p),\n                p->payload_len, TCP_GET_SEQ(p) + p->payload_len,\n                ssn->client.last_ack, ssn->client.next_win,\n                (TCP_GET_SEQ(p) + p->payload_len) - ssn->client.next_win);\n        SCLogDebug(\"ssn %p: window %u sacked %u\", ssn, ssn->client.window,\n                StreamTcpSackedSize(&ssn->client));\n        StreamTcpSetEvent(p, STREAM_EST_PACKET_OUT_OF_WINDOW);\n        return -1;\n    }\n    return 0;\n}\n\n/**\n *  \\brief  Function to handle the TCP_ESTABLISHED state packets, which are\n *          sent by the server to client. The function handles\n *          ACK packets and call StreamTcpReassembleHandleSegment() to handle\n *          the reassembly\n *\n *  Timestamp has already been checked at this point.\n *\n *  \\param  tv      Thread Variable containing  input/output queue, cpu affinity etc.\n *  \\param  ssn     Pointer to the current TCP session\n *  \\param  p       Packet which has to be handled in this TCP state.\n *  \\param  stt     Strean Thread module registered to handle the stream handling\n */\nstatic int HandleEstablishedPacketToClient(ThreadVars *tv, TcpSession *ssn, Packet *p,\n                        StreamTcpThread *stt, PacketQueueNoLock *pq)\n{\n    SCLogDebug(\"ssn %p: =+ pkt (%\" PRIu32 \") is to client: SEQ %\" PRIu32 \",\"\n               \" ACK %\" PRIu32 \", WIN %\"PRIu16\"\", ssn, p->payload_len,\n                TCP_GET_SEQ(p), TCP_GET_ACK(p), TCP_GET_WINDOW(p));\n\n    if (StreamTcpValidateAck(ssn, &ssn->client, p) == -1) {\n        SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n        StreamTcpSetEvent(p, STREAM_EST_INVALID_ACK);\n        return -1;\n    }\n\n    /* To get the server window value from the servers packet, when connection\n       is picked up as midstream */\n    if ((ssn->flags & STREAMTCP_FLAG_MIDSTREAM) &&\n            (ssn->flags & STREAMTCP_FLAG_MIDSTREAM_ESTABLISHED))\n    {\n        ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n        ssn->server.next_win = ssn->server.last_ack + ssn->server.window;\n        ssn->flags &= ~STREAMTCP_FLAG_MIDSTREAM_ESTABLISHED;\n        SCLogDebug(\"ssn %p: adjusted midstream ssn->server.next_win to \"\n                \"%\" PRIu32 \"\", ssn, ssn->server.next_win);\n    }\n\n    /* check for Keep Alive */\n    if ((p->payload_len == 0 || p->payload_len == 1) &&\n            (TCP_GET_SEQ(p) == (ssn->server.next_seq - 1))) {\n        SCLogDebug(\"ssn %p: pkt is keep alive\", ssn);\n\n    /* normal pkt */\n    } else if (!(SEQ_GEQ((TCP_GET_SEQ(p)+p->payload_len), ssn->server.last_ack))) {\n        if (ssn->flags & STREAMTCP_FLAG_ASYNC) {\n\n            SCLogDebug(\"ssn %p: client => Asynchrouns stream, packet SEQ\"\n                    \" %\" PRIu32 \", payload size %\" PRIu32 \" (%\" PRIu32 \"),\"\n                    \" ssn->client.last_ack %\" PRIu32 \", ssn->client.next_win\"\n                    \" %\"PRIu32\"(%\"PRIu32\")\", ssn, TCP_GET_SEQ(p),\n                    p->payload_len, TCP_GET_SEQ(p) + p->payload_len,\n                    ssn->server.last_ack, ssn->server.next_win,\n                    TCP_GET_SEQ(p) + p->payload_len - ssn->server.next_win);\n\n            ssn->server.last_ack = TCP_GET_SEQ(p);\n\n        /* if last ack is beyond next_seq, we have accepted ack's for missing data.\n         * In this case we do accept the data before last_ack if it is (partly)\n         * beyond next seq */\n        } else if (SEQ_GT(ssn->server.last_ack, ssn->server.next_seq) &&\n                   SEQ_GT((TCP_GET_SEQ(p)+p->payload_len),ssn->server.next_seq))\n        {\n            SCLogDebug(\"ssn %p: PKT SEQ %\"PRIu32\" payload_len %\"PRIu16\n                    \" before last_ack %\"PRIu32\", after next_seq %\"PRIu32\":\"\n                    \" acked data that we haven't seen before\",\n                    ssn, TCP_GET_SEQ(p), p->payload_len, ssn->server.last_ack, ssn->server.next_seq);\n            if (SEQ_EQ(TCP_GET_SEQ(p),ssn->server.next_seq)) {\n                StreamTcpUpdateNextSeq(ssn, &ssn->server, (ssn->server.next_seq + p->payload_len));\n            }\n        } else {\n            SCLogDebug(\"ssn %p: PKT SEQ %\"PRIu32\" payload_len %\"PRIu16\n                    \" before last_ack %\"PRIu32\". next_seq %\"PRIu32,\n                    ssn, TCP_GET_SEQ(p), p->payload_len, ssn->server.last_ack, ssn->server.next_seq);\n            StreamTcpSetEvent(p, STREAM_EST_PKT_BEFORE_LAST_ACK);\n            return -1;\n        }\n    }\n\n    int zerowindowprobe = 0;\n    /* zero window probe */\n    if (p->payload_len == 1 && TCP_GET_SEQ(p) == ssn->server.next_seq && ssn->server.window == 0) {\n        SCLogDebug(\"ssn %p: zero window probe\", ssn);\n        zerowindowprobe = 1;\n\n    /* expected packet */\n    } else if (SEQ_EQ(ssn->server.next_seq, TCP_GET_SEQ(p))) {\n        StreamTcpUpdateNextSeq(ssn, &ssn->server, (ssn->server.next_seq + p->payload_len));\n\n    /* not completely as expected, but valid */\n    } else if (SEQ_LT(TCP_GET_SEQ(p),ssn->server.next_seq) &&\n               SEQ_GT((TCP_GET_SEQ(p)+p->payload_len), ssn->server.next_seq))\n    {\n        StreamTcpUpdateNextSeq(ssn, &ssn->server, (TCP_GET_SEQ(p) + p->payload_len));\n        SCLogDebug(\"ssn %p: ssn->server.next_seq %\" PRIu32\n                   \" (started before next_seq, ended after)\",\n                   ssn, ssn->server.next_seq);\n\n    /* if next_seq has fallen behind last_ack, we got some catching up to do */\n    } else if (SEQ_LT(ssn->server.next_seq, ssn->server.last_ack)) {\n        StreamTcpUpdateNextSeq(ssn, &ssn->server, (TCP_GET_SEQ(p) + p->payload_len));\n        SCLogDebug(\"ssn %p: ssn->server.next_seq %\"PRIu32\n                   \" (next_seq had fallen behind last_ack)\",\n                   ssn, ssn->server.next_seq);\n\n    } else {\n        SCLogDebug(\"ssn %p: no update to ssn->server.next_seq %\"PRIu32\n                   \" SEQ %u SEQ+ %u last_ack %u\",\n                   ssn, ssn->server.next_seq,\n                   TCP_GET_SEQ(p), TCP_GET_SEQ(p)+p->payload_len, ssn->server.last_ack);\n    }\n\n    if (zerowindowprobe) {\n        SCLogDebug(\"ssn %p: zero window probe, skipping oow check\", ssn);\n    } else if (SEQ_LEQ(TCP_GET_SEQ(p) + p->payload_len, ssn->server.next_win) ||\n            (ssn->flags & (STREAMTCP_FLAG_MIDSTREAM|STREAMTCP_FLAG_ASYNC)))\n    {\n        SCLogDebug(\"ssn %p: seq %\"PRIu32\" in window, ssn->server.next_win \"\n                \"%\" PRIu32 \"\", ssn, TCP_GET_SEQ(p), ssn->server.next_win);\n        ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n        SCLogDebug(\"ssn %p: ssn->client.window %\"PRIu32\"\", ssn,\n                    ssn->client.window);\n\n        if (p->tcph->th_flags & TH_ACK)\n            StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_ACK(p));\n\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            StreamTcpHandleTimestamp(ssn, p);\n        }\n\n        StreamTcpSackUpdatePacket(&ssn->client, p);\n\n        StreamTcpUpdateNextWin(ssn, &ssn->client, (ssn->client.last_ack + ssn->client.window));\n\n        StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn, &ssn->server, p, pq);\n    } else {\n        SCLogDebug(\"ssn %p: client => SEQ out of window, packet SEQ\"\n                   \"%\" PRIu32 \", payload size %\" PRIu32 \" (%\" PRIu32 \"),\"\n                   \" ssn->server.last_ack %\" PRIu32 \", ssn->server.next_win \"\n                   \"%\" PRIu32 \"(%\"PRIu32\")\", ssn, TCP_GET_SEQ(p),\n                   p->payload_len, TCP_GET_SEQ(p) + p->payload_len,\n                   ssn->server.last_ack, ssn->server.next_win,\n                   TCP_GET_SEQ(p) + p->payload_len - ssn->server.next_win);\n        StreamTcpSetEvent(p, STREAM_EST_PACKET_OUT_OF_WINDOW);\n        return -1;\n    }\n    return 0;\n}\n\n/**\n *  \\internal\n *\n *  \\brief Find the highest sequence number needed to consider all segments as ACK'd\n *\n *  Used to treat all segments as ACK'd upon receiving a valid RST.\n *\n *  \\param stream stream to inspect the segments from\n *  \\param seq sequence number to check against\n *\n *  \\retval ack highest ack we need to set\n */\nstatic inline uint32_t StreamTcpResetGetMaxAck(TcpStream *stream, uint32_t seq)\n{\n    uint32_t ack = seq;\n\n    if (STREAM_HAS_SEEN_DATA(stream)) {\n        const uint32_t tail_seq = STREAM_SEQ_RIGHT_EDGE(stream);\n        if (SEQ_GT(tail_seq, ack)) {\n            ack = tail_seq;\n        }\n    }\n\n    SCReturnUInt(ack);\n}\n\n/** \\internal\n *  \\brief check if a ACK packet is outdated so processing can be fast tracked\n *\n *  Consider a packet outdated ack if:\n *  - state is >= ESTABLISHED\n *  - ACK < last_ACK\n *  - SACK acks nothing new\n *  - packet has no data\n *  - SEQ == next_SEQ\n *  - flags has ACK set but don't contain SYN/FIN/RST\n *\n *  \\todo the most likely explanation for this packet is that we already\n *        accepted a \"newer\" ACK. We will not consider an outdated timestamp\n *        option an issue for this packet, but we should probably still\n *        check if the ts isn't too far off.\n */\nstatic bool StreamTcpPacketIsOutdatedAck(TcpSession *ssn, Packet *p)\n{\n    if (ssn->state < TCP_ESTABLISHED)\n        return false;\n    if (p->payload_len != 0)\n        return false;\n    if ((p->tcph->th_flags & (TH_ACK | TH_SYN | TH_FIN | TH_RST)) != TH_ACK)\n        return false;\n\n    /* lets see if this is a packet that is entirely eclipsed by earlier ACKs */\n    if (PKT_IS_TOSERVER(p)) {\n        if (SEQ_EQ(TCP_GET_SEQ(p), ssn->client.next_seq) &&\n                SEQ_LT(TCP_GET_ACK(p), ssn->server.last_ack)) {\n            if (!TCP_HAS_SACK(p)) {\n                SCLogDebug(\"outdated ACK (no SACK, SEQ %u vs next_seq %u)\", TCP_GET_SEQ(p),\n                        ssn->client.next_seq);\n                return true;\n            }\n\n            if (StreamTcpSackPacketIsOutdated(&ssn->server, p)) {\n                SCLogDebug(\"outdated ACK (have SACK, SEQ %u vs next_seq %u)\", TCP_GET_SEQ(p),\n                        ssn->client.next_seq);\n                return true;\n            }\n        }\n    } else {\n        if (SEQ_EQ(TCP_GET_SEQ(p), ssn->server.next_seq) &&\n                SEQ_LT(TCP_GET_ACK(p), ssn->client.last_ack)) {\n            if (!TCP_HAS_SACK(p)) {\n                SCLogDebug(\"outdated ACK (no SACK, SEQ %u vs next_seq %u)\", TCP_GET_SEQ(p),\n                        ssn->client.next_seq);\n                return true;\n            }\n\n            if (StreamTcpSackPacketIsOutdated(&ssn->client, p)) {\n                SCLogDebug(\"outdated ACK (have SACK, SEQ %u vs next_seq %u)\", TCP_GET_SEQ(p),\n                        ssn->client.next_seq);\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n/**\n *  \\brief  Function to handle the TCP_ESTABLISHED state. The function handles\n *          ACK, FIN, RST packets and correspondingly changes the connection\n *          state. The function handles the data inside packets and call\n *          StreamTcpReassembleHandleSegment(tv, ) to handle the reassembling.\n *\n *  \\param  tv      Thread Variable containing  input/output queue, cpu affinity etc.\n *  \\param  p       Packet which has to be handled in this TCP state.\n *  \\param  stt     Strean Thread module registered to handle the stream handling\n */\n\nstatic int StreamTcpPacketStateEstablished(ThreadVars *tv, Packet *p,\n        StreamTcpThread *stt, TcpSession *ssn, PacketQueueNoLock *pq)\n{\n    if (ssn == NULL)\n        return -1;\n\n    if (p->tcph->th_flags & TH_RST) {\n        if (!StreamTcpValidateRst(ssn, p))\n            return -1;\n\n        if (PKT_IS_TOSERVER(p)) {\n            StreamTcpCloseSsnWithReset(p, ssn);\n\n            ssn->server.next_seq = TCP_GET_ACK(p);\n            ssn->client.next_seq = TCP_GET_SEQ(p) + p->payload_len;\n            SCLogDebug(\"ssn %p: ssn->server.next_seq %\" PRIu32 \"\", ssn,\n                    ssn->server.next_seq);\n            ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n\n            if ((p->tcph->th_flags & TH_ACK) && StreamTcpValidateAck(ssn, &ssn->server, p) == 0)\n                StreamTcpUpdateLastAck(ssn, &ssn->server,\n                        StreamTcpResetGetMaxAck(&ssn->server, TCP_GET_ACK(p)));\n\n            StreamTcpUpdateLastAck(ssn, &ssn->client,\n                    StreamTcpResetGetMaxAck(&ssn->client, TCP_GET_SEQ(p)));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->client.next_seq,\n                    ssn->server.last_ack);\n\n            /* don't return packets to pools here just yet, the pseudo\n             * packet will take care, otherwise the normal session\n             * cleanup. */\n        } else {\n            StreamTcpCloseSsnWithReset(p, ssn);\n\n            ssn->server.next_seq = TCP_GET_SEQ(p) + p->payload_len + 1;\n            ssn->client.next_seq = TCP_GET_ACK(p);\n\n            SCLogDebug(\"ssn %p: ssn->server.next_seq %\" PRIu32 \"\", ssn,\n                    ssn->server.next_seq);\n            ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n\n            if ((p->tcph->th_flags & TH_ACK) && StreamTcpValidateAck(ssn, &ssn->client, p) == 0)\n                StreamTcpUpdateLastAck(ssn, &ssn->client,\n                        StreamTcpResetGetMaxAck(&ssn->client, TCP_GET_ACK(p)));\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server,\n                    StreamTcpResetGetMaxAck(&ssn->server, TCP_GET_SEQ(p)));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->server.next_seq,\n                    ssn->client.last_ack);\n\n            /* don't return packets to pools here just yet, the pseudo\n             * packet will take care, otherwise the normal session\n             * cleanup. */\n        }\n\n    } else if (p->tcph->th_flags & TH_FIN) {\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            if (!StreamTcpValidateTimestamp(ssn, p))\n                return -1;\n        }\n\n        SCLogDebug(\"ssn (%p: FIN received SEQ\"\n                \" %\" PRIu32 \", last ACK %\" PRIu32 \", next win %\"PRIu32\",\"\n                \" win %\" PRIu32 \"\", ssn, ssn->server.next_seq,\n                ssn->client.last_ack, ssn->server.next_win,\n                ssn->server.window);\n\n        if ((StreamTcpHandleFin(tv, stt, ssn, p, pq)) == -1)\n            return -1;\n\n    /* SYN/ACK */\n    } else if ((p->tcph->th_flags & (TH_SYN|TH_ACK)) == (TH_SYN|TH_ACK)) {\n        SCLogDebug(\"ssn %p: SYN/ACK packet on state ESTABLISHED... resent\",\n                ssn);\n\n        if (PKT_IS_TOSERVER(p)) {\n            SCLogDebug(\"ssn %p: SYN/ACK-pkt to server in ESTABLISHED state\", ssn);\n\n            StreamTcpSetEvent(p, STREAM_EST_SYNACK_TOSERVER);\n            return -1;\n        }\n\n        /* Check if the SYN/ACK packets ACK matches the earlier\n         * received SYN/ACK packet. */\n        if (!(SEQ_EQ(TCP_GET_ACK(p), ssn->client.last_ack))) {\n            SCLogDebug(\"ssn %p: ACK mismatch, packet ACK %\" PRIu32 \" != \"\n                    \"%\" PRIu32 \" from stream\", ssn, TCP_GET_ACK(p),\n                    ssn->client.isn + 1);\n\n            StreamTcpSetEvent(p, STREAM_EST_SYNACK_RESEND_WITH_DIFFERENT_ACK);\n            return -1;\n        }\n\n        /* Check if the SYN/ACK packet SEQ the earlier\n         * received SYN packet. */\n        if (!(SEQ_EQ(TCP_GET_SEQ(p), ssn->server.isn))) {\n            SCLogDebug(\"ssn %p: SEQ mismatch, packet SEQ %\" PRIu32 \" != \"\n                    \"%\" PRIu32 \" from stream\", ssn, TCP_GET_ACK(p),\n                    ssn->client.isn + 1);\n\n            StreamTcpSetEvent(p, STREAM_EST_SYNACK_RESEND_WITH_DIFF_SEQ);\n            return -1;\n        }\n\n        if (ssn->flags & STREAMTCP_FLAG_3WHS_CONFIRMED) {\n            /* a resend of a SYN while we are established already -- fishy */\n            StreamTcpSetEvent(p, STREAM_EST_SYNACK_RESEND);\n            return -1;\n        }\n\n        SCLogDebug(\"ssn %p: SYN/ACK packet on state ESTABLISHED... resent. \"\n                \"Likely due server not receiving final ACK in 3whs\", ssn);\n        return 0;\n\n    } else if (p->tcph->th_flags & TH_SYN) {\n        SCLogDebug(\"ssn %p: SYN packet on state ESTABLISHED... resent\", ssn);\n        if (PKT_IS_TOCLIENT(p)) {\n            SCLogDebug(\"ssn %p: SYN-pkt to client in EST state\", ssn);\n\n            StreamTcpSetEvent(p, STREAM_EST_SYN_TOCLIENT);\n            return -1;\n        }\n\n        if (!(SEQ_EQ(TCP_GET_SEQ(p), ssn->client.isn))) {\n            SCLogDebug(\"ssn %p: SYN with different SEQ on SYN_RECV state\", ssn);\n\n            StreamTcpSetEvent(p, STREAM_EST_SYN_RESEND_DIFF_SEQ);\n            return -1;\n        }\n\n        /* a resend of a SYN while we are established already -- fishy */\n        StreamTcpSetEvent(p, STREAM_EST_SYN_RESEND);\n        return -1;\n\n    } else if (p->tcph->th_flags & TH_ACK) {\n        /* Urgent pointer size can be more than the payload size, as it tells\n         * the future coming data from the sender will be handled urgently\n         * until data of size equal to urgent offset has been processed\n         * (RFC 2147) */\n\n        /* If the timestamp option is enabled for both the streams, then\n         * validate the received packet timestamp value against the\n         * stream->last_ts. If the timestamp is valid then process the\n         * packet normally otherwise the drop the packet (RFC 1323) */\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            if (!StreamTcpValidateTimestamp(ssn, p))\n                return -1;\n        }\n\n        if (PKT_IS_TOSERVER(p)) {\n            /* Process the received packet to server */\n            HandleEstablishedPacketToServer(tv, ssn, p, stt, pq);\n\n            SCLogDebug(\"ssn %p: next SEQ %\" PRIu32 \", last ACK %\" PRIu32 \",\"\n                    \" next win %\" PRIu32 \", win %\" PRIu32 \"\", ssn,\n                    ssn->client.next_seq, ssn->server.last_ack\n                    ,ssn->client.next_win, ssn->client.window);\n\n        } else { /* implied to client */\n            if (!(ssn->flags & STREAMTCP_FLAG_3WHS_CONFIRMED)) {\n                ssn->flags |= STREAMTCP_FLAG_3WHS_CONFIRMED;\n                SCLogDebug(\"3whs is now confirmed by server\");\n            }\n\n            /* Process the received packet to client */\n            HandleEstablishedPacketToClient(tv, ssn, p, stt, pq);\n\n            SCLogDebug(\"ssn %p: next SEQ %\" PRIu32 \", last ACK %\" PRIu32 \",\"\n                    \" next win %\" PRIu32 \", win %\" PRIu32 \"\", ssn,\n                    ssn->server.next_seq, ssn->client.last_ack,\n                    ssn->server.next_win, ssn->server.window);\n        }\n    } else {\n        SCLogDebug(\"ssn %p: default case\", ssn);\n    }\n\n    return 0;\n}\n\n/**\n *  \\brief  Function to handle the FIN packets for states TCP_SYN_RECV and\n *          TCP_ESTABLISHED and changes to another TCP state as required.\n *\n *  \\param  tv      Thread Variable containing  input/output queue, cpu affinity\n *  \\param  p       Packet which has to be handled in this TCP state.\n *  \\param  stt     Strean Thread module registered to handle the stream handling\n *\n *  \\retval 0 success\n *  \\retval -1 something wrong with the packet\n */\n\nstatic int StreamTcpHandleFin(ThreadVars *tv, StreamTcpThread *stt,\n                                TcpSession *ssn, Packet *p, PacketQueueNoLock *pq)\n{\n    if (PKT_IS_TOSERVER(p)) {\n        SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to server: SEQ %\" PRIu32 \",\"\n                \" ACK %\" PRIu32 \"\", ssn, p->payload_len, TCP_GET_SEQ(p),\n                TCP_GET_ACK(p));\n\n        if (StreamTcpValidateAck(ssn, &ssn->server, p) == -1) {\n            SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n            StreamTcpSetEvent(p, STREAM_FIN_INVALID_ACK);\n            return -1;\n        }\n\n        if (SEQ_LT(TCP_GET_SEQ(p), ssn->client.next_seq) ||\n            SEQ_GT(TCP_GET_SEQ(p), (ssn->client.last_ack + ssn->client.window)))\n        {\n            SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \" != \"\n                    \"%\" PRIu32 \" from stream\", ssn, TCP_GET_SEQ(p),\n                    ssn->client.next_seq);\n\n            StreamTcpSetEvent(p, STREAM_FIN_OUT_OF_WINDOW);\n            return -1;\n        }\n\n        StreamTcpPacketSetState(p, ssn, TCP_CLOSE_WAIT);\n        SCLogDebug(\"ssn %p: state changed to TCP_CLOSE_WAIT\", ssn);\n\n        if (SEQ_EQ(TCP_GET_SEQ(p), ssn->client.next_seq))\n            ssn->client.next_seq = TCP_GET_SEQ(p) + p->payload_len;\n\n        SCLogDebug(\"ssn %p: ssn->client.next_seq %\" PRIu32 \"\", ssn,\n                    ssn->client.next_seq);\n        ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n\n        if (p->tcph->th_flags & TH_ACK)\n            StreamTcpUpdateLastAck(ssn, &ssn->server, TCP_GET_ACK(p));\n\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            StreamTcpHandleTimestamp(ssn, p);\n        }\n\n        /* Update the next_seq, in case if we have missed the client packet\n           and server has already received and acked it */\n        if (SEQ_LT(ssn->server.next_seq, TCP_GET_ACK(p)))\n            ssn->server.next_seq = TCP_GET_ACK(p);\n\n        StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn, &ssn->client, p, pq);\n\n        SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK %\" PRIu32 \"\",\n                ssn, ssn->client.next_seq, ssn->server.last_ack);\n    } else { /* implied to client */\n        SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to client: SEQ %\" PRIu32 \", \"\n                   \"ACK %\" PRIu32 \"\", ssn, p->payload_len, TCP_GET_SEQ(p),\n                    TCP_GET_ACK(p));\n\n        if (StreamTcpValidateAck(ssn, &ssn->client, p) == -1) {\n            SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n            StreamTcpSetEvent(p, STREAM_FIN_INVALID_ACK);\n            return -1;\n        }\n\n        if (SEQ_LT(TCP_GET_SEQ(p), ssn->server.next_seq) ||\n                SEQ_GT(TCP_GET_SEQ(p), (ssn->server.last_ack + ssn->server.window)))\n        {\n            SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \" != \"\n                    \"%\" PRIu32 \" from stream (last_ack %u win %u = %u)\", ssn, TCP_GET_SEQ(p),\n                    ssn->server.next_seq, ssn->server.last_ack, ssn->server.window, (ssn->server.last_ack + ssn->server.window));\n\n            StreamTcpSetEvent(p, STREAM_FIN_OUT_OF_WINDOW);\n            return -1;\n        }\n\n        StreamTcpPacketSetState(p, ssn, TCP_FIN_WAIT1);\n        SCLogDebug(\"ssn %p: state changed to TCP_FIN_WAIT1\", ssn);\n\n        if (SEQ_EQ(TCP_GET_SEQ(p), ssn->server.next_seq))\n            ssn->server.next_seq = TCP_GET_SEQ(p) + p->payload_len;\n\n        SCLogDebug(\"ssn %p: ssn->server.next_seq %\" PRIu32 \"\", ssn,\n                    ssn->server.next_seq);\n        ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n\n        if (p->tcph->th_flags & TH_ACK)\n            StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_ACK(p));\n\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            StreamTcpHandleTimestamp(ssn, p);\n        }\n\n        /* Update the next_seq, in case if we have missed the client packet\n           and server has already received and acked it */\n        if (SEQ_LT(ssn->client.next_seq, TCP_GET_ACK(p)))\n            ssn->client.next_seq = TCP_GET_ACK(p);\n\n        StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn, &ssn->server, p, pq);\n\n        SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK %\" PRIu32 \"\",\n                ssn, ssn->server.next_seq, ssn->client.last_ack);\n    }\n\n    return 0;\n}\n\n/**\n *  \\brief  Function to handle the TCP_FIN_WAIT1 state. The function handles\n *          ACK, FIN, RST packets and correspondingly changes the connection\n *          state.\n *\n *  \\param  tv      Thread Variable containing  input/output queue, cpu affinity\n *  \\param  p       Packet which has to be handled in this TCP state.\n *  \\param  stt     Strean Thread module registered to handle the stream handling\n *\n *  \\retval 0 success\n *  \\retval -1 something wrong with the packet\n */\n\nstatic int StreamTcpPacketStateFinWait1(ThreadVars *tv, Packet *p,\n        StreamTcpThread *stt, TcpSession *ssn, PacketQueueNoLock *pq)\n{\n    if (ssn == NULL)\n        return -1;\n\n    if (p->tcph->th_flags & TH_RST) {\n        if (!StreamTcpValidateRst(ssn, p))\n            return -1;\n\n        StreamTcpCloseSsnWithReset(p, ssn);\n\n        if (PKT_IS_TOSERVER(p)) {\n            if ((p->tcph->th_flags & TH_ACK) && StreamTcpValidateAck(ssn, &ssn->server, p) == 0)\n                StreamTcpUpdateLastAck(ssn, &ssn->server,\n                        StreamTcpResetGetMaxAck(&ssn->server, TCP_GET_ACK(p)));\n\n            StreamTcpUpdateLastAck(ssn, &ssn->client,\n                    StreamTcpResetGetMaxAck(&ssn->client, TCP_GET_SEQ(p)));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n        } else {\n            if ((p->tcph->th_flags & TH_ACK) && StreamTcpValidateAck(ssn, &ssn->client, p) == 0)\n                StreamTcpUpdateLastAck(ssn, &ssn->client,\n                        StreamTcpResetGetMaxAck(&ssn->client, TCP_GET_ACK(p)));\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server,\n                    StreamTcpResetGetMaxAck(&ssn->server, TCP_GET_SEQ(p)));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n        }\n\n    } else if ((p->tcph->th_flags & (TH_FIN|TH_ACK)) == (TH_FIN|TH_ACK)) {\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            if (!StreamTcpValidateTimestamp(ssn, p))\n                return -1;\n        }\n\n        if (PKT_IS_TOSERVER(p)) {\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to server: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n            int retransmission = 0;\n\n            if (StreamTcpPacketIsRetransmission(&ssn->client, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n\n            } else if (SEQ_LT(TCP_GET_SEQ(p), ssn->client.next_seq) ||\n                    SEQ_GT(TCP_GET_SEQ(p), (ssn->client.last_ack + ssn->client.window)))\n            {\n                SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                        \" != %\" PRIu32 \" from stream\", ssn,\n                        TCP_GET_SEQ(p), ssn->client.next_seq);\n                StreamTcpSetEvent(p, STREAM_FIN1_FIN_WRONG_SEQ);\n                return -1;\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->server, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_FIN1_INVALID_ACK);\n                return -1;\n            }\n\n            if (!retransmission) {\n                StreamTcpPacketSetState(p, ssn, TCP_TIME_WAIT);\n                SCLogDebug(\"ssn %p: state changed to TCP_TIME_WAIT\", ssn);\n\n                ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->server.next_seq, TCP_GET_ACK(p)))\n                ssn->server.next_seq = TCP_GET_ACK(p);\n\n            if (SEQ_EQ(ssn->client.next_seq, TCP_GET_SEQ(p))) {\n                StreamTcpUpdateNextSeq(ssn, &ssn->client, (ssn->client.next_seq + p->payload_len));\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->client.next_seq,\n                    ssn->server.last_ack);\n        } else { /* implied to client */\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to client: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n            int retransmission = 0;\n\n            if (StreamTcpPacketIsRetransmission(&ssn->server, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n            } else if (SEQ_EQ(ssn->server.next_seq, TCP_GET_SEQ(p)) &&\n                       SEQ_EQ(ssn->client.last_ack, TCP_GET_ACK(p))) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n\n            } else if (SEQ_LT(TCP_GET_SEQ(p), ssn->server.next_seq) ||\n                       SEQ_GT(TCP_GET_SEQ(p), (ssn->server.last_ack + ssn->server.window))) {\n                SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                        \" != %\" PRIu32 \" from stream\", ssn,\n                        TCP_GET_SEQ(p), ssn->server.next_seq);\n                StreamTcpSetEvent(p, STREAM_FIN1_FIN_WRONG_SEQ);\n                return -1;\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->client, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_FIN1_INVALID_ACK);\n                return -1;\n            }\n\n            if (!retransmission) {\n                StreamTcpPacketSetState(p, ssn, TCP_TIME_WAIT);\n                SCLogDebug(\"ssn %p: state changed to TCP_TIME_WAIT\", ssn);\n\n                ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->client.next_seq, TCP_GET_ACK(p)))\n                ssn->client.next_seq = TCP_GET_ACK(p);\n\n            if (SEQ_EQ(ssn->server.next_seq, TCP_GET_SEQ(p))) {\n                StreamTcpUpdateNextSeq(ssn, &ssn->server, (ssn->server.next_seq + p->payload_len));\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->server.next_seq,\n                    ssn->client.last_ack);\n        }\n\n    } else if (p->tcph->th_flags & TH_FIN) {\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            if (!StreamTcpValidateTimestamp(ssn, p))\n                return -1;\n        }\n\n        if (PKT_IS_TOSERVER(p)) {\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to server: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n            int retransmission = 0;\n\n            if (StreamTcpPacketIsRetransmission(&ssn->client, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n\n            } else if (SEQ_LT(TCP_GET_SEQ(p), ssn->client.next_seq) ||\n                    SEQ_GT(TCP_GET_SEQ(p), (ssn->client.last_ack + ssn->client.window)))\n            {\n                SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                        \" != %\" PRIu32 \" from stream\", ssn,\n                        TCP_GET_SEQ(p), ssn->client.next_seq);\n                StreamTcpSetEvent(p, STREAM_FIN1_FIN_WRONG_SEQ);\n                return -1;\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->server, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_FIN1_INVALID_ACK);\n                return -1;\n            }\n\n            if (!retransmission) {\n                StreamTcpPacketSetState(p, ssn, TCP_CLOSING);\n                SCLogDebug(\"ssn %p: state changed to TCP_CLOSING\", ssn);\n\n                ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n            }\n\n            if (p->tcph->th_flags & TH_ACK)\n                StreamTcpUpdateLastAck(ssn, &ssn->server, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->server.next_seq, TCP_GET_ACK(p)))\n                ssn->server.next_seq = TCP_GET_ACK(p);\n\n            if (SEQ_EQ(ssn->client.next_seq, TCP_GET_SEQ(p))) {\n                StreamTcpUpdateNextSeq(ssn, &ssn->client, (ssn->client.next_seq + p->payload_len));\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->client.next_seq,\n                    ssn->server.last_ack);\n        } else { /* implied to client */\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to client: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n\n            int retransmission = 0;\n\n            if (StreamTcpPacketIsRetransmission(&ssn->server, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n\n            } else if (SEQ_LT(TCP_GET_SEQ(p), ssn->server.next_seq) ||\n                    SEQ_GT(TCP_GET_SEQ(p), (ssn->server.last_ack + ssn->server.window)))\n            {\n                SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                        \" != %\" PRIu32 \" from stream\", ssn,\n                        TCP_GET_SEQ(p), ssn->server.next_seq);\n                StreamTcpSetEvent(p, STREAM_FIN1_FIN_WRONG_SEQ);\n                return -1;\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->client, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_FIN1_INVALID_ACK);\n                return -1;\n            }\n\n            if (!retransmission) {\n                StreamTcpPacketSetState(p, ssn, TCP_CLOSING);\n                SCLogDebug(\"ssn %p: state changed to TCP_CLOSING\", ssn);\n\n                ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n            }\n\n            if (p->tcph->th_flags & TH_ACK)\n                StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->client.next_seq, TCP_GET_ACK(p)))\n                ssn->client.next_seq = TCP_GET_ACK(p);\n\n            if (SEQ_EQ(ssn->server.next_seq, TCP_GET_SEQ(p))) {\n                StreamTcpUpdateNextSeq(ssn, &ssn->server, (ssn->server.next_seq + p->payload_len));\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->server.next_seq,\n                    ssn->client.last_ack);\n        }\n    } else if (p->tcph->th_flags & TH_SYN) {\n        SCLogDebug(\"ssn (%p): SYN pkt on FinWait1\", ssn);\n        StreamTcpSetEvent(p, STREAM_SHUTDOWN_SYN_RESEND);\n        return -1;\n\n    } else if (p->tcph->th_flags & TH_ACK) {\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            if (!StreamTcpValidateTimestamp(ssn, p))\n                return -1;\n        }\n\n        if (PKT_IS_TOSERVER(p)) {\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to server: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n            int retransmission = 0;\n\n            if (StreamTcpPacketIsRetransmission(&ssn->client, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->server, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_FIN1_INVALID_ACK);\n                return -1;\n            }\n\n            if (!retransmission) {\n                if (SEQ_LEQ(TCP_GET_SEQ(p) + p->payload_len, ssn->client.next_win) ||\n                        (ssn->flags & (STREAMTCP_FLAG_MIDSTREAM|STREAMTCP_FLAG_ASYNC)))\n                {\n                    SCLogDebug(\"ssn %p: seq %\"PRIu32\" in window, ssn->client.next_win \"\n                            \"%\" PRIu32 \"\", ssn, TCP_GET_SEQ(p), ssn->client.next_win);\n\n                    if (TCP_GET_SEQ(p) == ssn->client.next_seq) {\n                        StreamTcpPacketSetState(p, ssn, TCP_FIN_WAIT2);\n                        SCLogDebug(\"ssn %p: state changed to TCP_FIN_WAIT2\", ssn);\n                    }\n                } else {\n                    SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                            \" != %\" PRIu32 \" from stream\", ssn,\n                            TCP_GET_SEQ(p), ssn->client.next_seq);\n\n                    StreamTcpSetEvent(p, STREAM_FIN1_ACK_WRONG_SEQ);\n                    return -1;\n                }\n\n                ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->server.next_seq, TCP_GET_ACK(p)))\n                ssn->server.next_seq = TCP_GET_ACK(p);\n\n            if (SEQ_EQ(ssn->client.next_seq, TCP_GET_SEQ(p))) {\n                StreamTcpUpdateNextSeq(ssn, &ssn->client, (ssn->client.next_seq + p->payload_len));\n            }\n\n            StreamTcpSackUpdatePacket(&ssn->server, p);\n\n            /* update next_win */\n            StreamTcpUpdateNextWin(ssn, &ssn->server, (ssn->server.last_ack + ssn->server.window));\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->client.next_seq,\n                    ssn->server.last_ack);\n\n        } else { /* implied to client */\n\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to client: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n\n            int retransmission = 0;\n\n            if (StreamTcpPacketIsRetransmission(&ssn->server, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->client, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_FIN1_INVALID_ACK);\n                return -1;\n            }\n\n            if (!retransmission) {\n                if (SEQ_LEQ(TCP_GET_SEQ(p) + p->payload_len, ssn->server.next_win) ||\n                        (ssn->flags & (STREAMTCP_FLAG_MIDSTREAM|STREAMTCP_FLAG_ASYNC)))\n                {\n                    SCLogDebug(\"ssn %p: seq %\"PRIu32\" in window, ssn->server.next_win \"\n                            \"%\" PRIu32 \"\", ssn, TCP_GET_SEQ(p), ssn->server.next_win);\n\n                    if (TCP_GET_SEQ(p) == ssn->server.next_seq) {\n                        StreamTcpPacketSetState(p, ssn, TCP_FIN_WAIT2);\n                        SCLogDebug(\"ssn %p: state changed to TCP_FIN_WAIT2\", ssn);\n                    }\n                } else {\n                    SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                            \" != %\" PRIu32 \" from stream\", ssn,\n                            TCP_GET_SEQ(p), ssn->server.next_seq);\n                    StreamTcpSetEvent(p, STREAM_FIN1_ACK_WRONG_SEQ);\n                    return -1;\n                }\n\n                ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->client.next_seq, TCP_GET_ACK(p)))\n                ssn->client.next_seq = TCP_GET_ACK(p);\n\n            if (SEQ_EQ(ssn->server.next_seq, TCP_GET_SEQ(p))) {\n                StreamTcpUpdateNextSeq(ssn, &ssn->server, (ssn->server.next_seq + p->payload_len));\n            }\n\n            StreamTcpSackUpdatePacket(&ssn->client, p);\n\n            /* update next_win */\n            StreamTcpUpdateNextWin(ssn, &ssn->client, (ssn->client.last_ack + ssn->client.window));\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->server.next_seq,\n                    ssn->client.last_ack);\n        }\n    } else {\n        SCLogDebug(\"ssn (%p): default case\", ssn);\n    }\n\n    return 0;\n}\n\n/**\n *  \\brief  Function to handle the TCP_FIN_WAIT2 state. The function handles\n *          ACK, RST, FIN packets and correspondingly changes the connection\n *          state.\n *\n *  \\param  tv      Thread Variable containing  input/output queue, cpu affinity\n *  \\param  p       Packet which has to be handled in this TCP state.\n *  \\param  stt     Strean Thread module registered to handle the stream handling\n */\n\nstatic int StreamTcpPacketStateFinWait2(ThreadVars *tv, Packet *p,\n        StreamTcpThread *stt, TcpSession *ssn, PacketQueueNoLock *pq)\n{\n    if (ssn == NULL)\n        return -1;\n\n    if (p->tcph->th_flags & TH_RST) {\n        if (!StreamTcpValidateRst(ssn, p))\n            return -1;\n\n        StreamTcpCloseSsnWithReset(p, ssn);\n\n        if (PKT_IS_TOSERVER(p)) {\n            if ((p->tcph->th_flags & TH_ACK) && StreamTcpValidateAck(ssn, &ssn->server, p) == 0)\n                StreamTcpUpdateLastAck(ssn, &ssn->server,\n                        StreamTcpResetGetMaxAck(&ssn->server, TCP_GET_ACK(p)));\n\n            StreamTcpUpdateLastAck(ssn, &ssn->client,\n                    StreamTcpResetGetMaxAck(&ssn->client, TCP_GET_SEQ(p)));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n        } else {\n            if ((p->tcph->th_flags & TH_ACK) && StreamTcpValidateAck(ssn, &ssn->client, p) == 0)\n                StreamTcpUpdateLastAck(ssn, &ssn->client,\n                        StreamTcpResetGetMaxAck(&ssn->client, TCP_GET_ACK(p)));\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server,\n                    StreamTcpResetGetMaxAck(&ssn->server, TCP_GET_SEQ(p)));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n        }\n\n    } else if (p->tcph->th_flags & TH_FIN) {\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            if (!StreamTcpValidateTimestamp(ssn, p))\n                return -1;\n        }\n\n        if (PKT_IS_TOSERVER(p)) {\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to server: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n            int retransmission = 0;\n\n            if (SEQ_EQ(TCP_GET_SEQ(p), ssn->client.next_seq - 1) &&\n                SEQ_EQ(TCP_GET_ACK(p), ssn->server.last_ack)) {\n                SCLogDebug(\"ssn %p: retransmission\", ssn);\n                retransmission = 1;\n            } else if (StreamTcpPacketIsRetransmission(&ssn->client, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n\n            } else if (SEQ_LT(TCP_GET_SEQ(p), ssn->client.next_seq) ||\n                    SEQ_GT(TCP_GET_SEQ(p), (ssn->client.last_ack + ssn->client.window)))\n            {\n                SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ \"\n                        \"%\" PRIu32 \" != %\" PRIu32 \" from stream\", ssn,\n                        TCP_GET_SEQ(p), ssn->client.next_seq);\n                StreamTcpSetEvent(p, STREAM_FIN2_FIN_WRONG_SEQ);\n                return -1;\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->server, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_FIN2_INVALID_ACK);\n                return -1;\n            }\n\n            if (!retransmission) {\n                StreamTcpPacketSetState(p, ssn, TCP_TIME_WAIT);\n                SCLogDebug(\"ssn %p: state changed to TCP_TIME_WAIT\", ssn);\n\n                if (SEQ_EQ(ssn->client.next_seq, TCP_GET_SEQ(p))) {\n                    StreamTcpUpdateNextSeq(\n                            ssn, &ssn->client, (ssn->client.next_seq + p->payload_len));\n                }\n                ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n            }\n\n            if (p->tcph->th_flags & TH_ACK)\n                StreamTcpUpdateLastAck(ssn, &ssn->server, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->server.next_seq, TCP_GET_ACK(p)))\n                ssn->server.next_seq = TCP_GET_ACK(p);\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->client.next_seq,\n                    ssn->server.last_ack);\n        } else { /* implied to client */\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to client: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n            int retransmission = 0;\n\n            if (SEQ_EQ(TCP_GET_SEQ(p), ssn->server.next_seq - 1) &&\n                SEQ_EQ(TCP_GET_ACK(p), ssn->client.last_ack)) {\n                SCLogDebug(\"ssn %p: retransmission\", ssn);\n                retransmission = 1;\n            } else if (StreamTcpPacketIsRetransmission(&ssn->server, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n\n            } else if (SEQ_LT(TCP_GET_SEQ(p), ssn->server.next_seq) ||\n                    SEQ_GT(TCP_GET_SEQ(p), (ssn->server.last_ack + ssn->server.window)))\n            {\n                SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ \"\n                        \"%\" PRIu32 \" != %\" PRIu32 \" from stream\", ssn,\n                        TCP_GET_SEQ(p), ssn->server.next_seq);\n                StreamTcpSetEvent(p, STREAM_FIN2_FIN_WRONG_SEQ);\n                return -1;\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->client, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_FIN2_INVALID_ACK);\n                return -1;\n            }\n\n            if (!retransmission) {\n                StreamTcpPacketSetState(p, ssn, TCP_TIME_WAIT);\n                SCLogDebug(\"ssn %p: state changed to TCP_TIME_WAIT\", ssn);\n\n                ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n            }\n\n            if (p->tcph->th_flags & TH_ACK)\n                StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->client.next_seq, TCP_GET_ACK(p)))\n                ssn->client.next_seq = TCP_GET_ACK(p);\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->server.next_seq,\n                    ssn->client.last_ack);\n        }\n\n    } else if (p->tcph->th_flags & TH_SYN) {\n        SCLogDebug(\"ssn (%p): SYN pkt on FinWait2\", ssn);\n        StreamTcpSetEvent(p, STREAM_SHUTDOWN_SYN_RESEND);\n        return -1;\n\n    } else if (p->tcph->th_flags & TH_ACK) {\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            if (!StreamTcpValidateTimestamp(ssn, p))\n                return -1;\n        }\n\n        if (PKT_IS_TOSERVER(p)) {\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to server: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n            int retransmission = 0;\n\n            if (StreamTcpPacketIsRetransmission(&ssn->client, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->server, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_FIN2_INVALID_ACK);\n                return -1;\n            }\n\n            if (!retransmission) {\n                if (SEQ_LEQ(TCP_GET_SEQ(p) + p->payload_len, ssn->client.next_win) ||\n                        (ssn->flags & (STREAMTCP_FLAG_MIDSTREAM|STREAMTCP_FLAG_ASYNC)))\n                {\n                    SCLogDebug(\"ssn %p: seq %\"PRIu32\" in window, ssn->client.next_win \"\n                            \"%\" PRIu32 \"\", ssn, TCP_GET_SEQ(p), ssn->client.next_win);\n\n                } else {\n                    SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                            \" != %\" PRIu32 \" from stream\", ssn,\n                            TCP_GET_SEQ(p), ssn->client.next_seq);\n                    StreamTcpSetEvent(p, STREAM_FIN2_ACK_WRONG_SEQ);\n                    return -1;\n                }\n\n                ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            if (SEQ_EQ(ssn->client.next_seq, TCP_GET_SEQ(p))) {\n                StreamTcpUpdateNextSeq(ssn, &ssn->client, (ssn->client.next_seq + p->payload_len));\n            }\n\n            StreamTcpSackUpdatePacket(&ssn->server, p);\n\n            /* update next_win */\n            StreamTcpUpdateNextWin(ssn, &ssn->server, (ssn->server.last_ack + ssn->server.window));\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->client.next_seq,\n                    ssn->server.last_ack);\n        } else { /* implied to client */\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to client: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n            int retransmission = 0;\n\n            if (StreamTcpPacketIsRetransmission(&ssn->server, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->client, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_FIN2_INVALID_ACK);\n                return -1;\n            }\n\n            if (!retransmission) {\n                if (SEQ_LEQ(TCP_GET_SEQ(p) + p->payload_len, ssn->server.next_win) ||\n                        (ssn->flags & (STREAMTCP_FLAG_MIDSTREAM|STREAMTCP_FLAG_ASYNC)))\n                {\n                    SCLogDebug(\"ssn %p: seq %\"PRIu32\" in window, ssn->server.next_win \"\n                            \"%\" PRIu32 \"\", ssn, TCP_GET_SEQ(p), ssn->server.next_win);\n                } else {\n                    SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                            \" != %\" PRIu32 \" from stream\", ssn,\n                            TCP_GET_SEQ(p), ssn->server.next_seq);\n                    StreamTcpSetEvent(p, STREAM_FIN2_ACK_WRONG_SEQ);\n                    return -1;\n                }\n\n                ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            if (SEQ_EQ(ssn->server.next_seq, TCP_GET_SEQ(p))) {\n                StreamTcpUpdateNextSeq(ssn, &ssn->server, (ssn->server.next_seq + p->payload_len));\n            }\n\n            StreamTcpSackUpdatePacket(&ssn->client, p);\n\n            /* update next_win */\n            StreamTcpUpdateNextWin(ssn, &ssn->client, (ssn->client.last_ack + ssn->client.window));\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->server.next_seq,\n                    ssn->client.last_ack);\n        }\n    } else {\n        SCLogDebug(\"ssn %p: default case\", ssn);\n    }\n\n    return 0;\n}\n\n/**\n *  \\brief  Function to handle the TCP_CLOSING state. Upon arrival of ACK\n *          the connection goes to TCP_TIME_WAIT state. The state has been\n *          reached as both end application has been closed.\n *\n *  \\param  tv      Thread Variable containing  input/output queue, cpu affinity\n *  \\param  p       Packet which has to be handled in this TCP state.\n *  \\param  stt     Strean Thread module registered to handle the stream handling\n */\n\nstatic int StreamTcpPacketStateClosing(ThreadVars *tv, Packet *p,\n        StreamTcpThread *stt, TcpSession *ssn, PacketQueueNoLock *pq)\n{\n    if (ssn == NULL)\n        return -1;\n\n    if (p->tcph->th_flags & TH_RST) {\n        if (!StreamTcpValidateRst(ssn, p))\n            return -1;\n\n        StreamTcpCloseSsnWithReset(p, ssn);\n\n        if (PKT_IS_TOSERVER(p)) {\n            if ((p->tcph->th_flags & TH_ACK) && StreamTcpValidateAck(ssn, &ssn->server, p) == 0)\n                StreamTcpUpdateLastAck(ssn, &ssn->server,\n                        StreamTcpResetGetMaxAck(&ssn->server, TCP_GET_ACK(p)));\n\n            StreamTcpUpdateLastAck(ssn, &ssn->client,\n                    StreamTcpResetGetMaxAck(&ssn->client, TCP_GET_SEQ(p)));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n        } else {\n            if ((p->tcph->th_flags & TH_ACK) && StreamTcpValidateAck(ssn, &ssn->client, p) == 0)\n                StreamTcpUpdateLastAck(ssn, &ssn->client,\n                        StreamTcpResetGetMaxAck(&ssn->client, TCP_GET_ACK(p)));\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server,\n                    StreamTcpResetGetMaxAck(&ssn->server, TCP_GET_SEQ(p)));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n        }\n\n    } else if (p->tcph->th_flags & TH_SYN) {\n        SCLogDebug(\"ssn (%p): SYN pkt on Closing\", ssn);\n        StreamTcpSetEvent(p, STREAM_SHUTDOWN_SYN_RESEND);\n        return -1;\n\n    } else if (p->tcph->th_flags & TH_ACK) {\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            if (!StreamTcpValidateTimestamp(ssn, p))\n                return -1;\n        }\n\n        if (PKT_IS_TOSERVER(p)) {\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to server: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n            int retransmission = 0;\n            if (StreamTcpPacketIsRetransmission(&ssn->client, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n            }\n\n            if (TCP_GET_SEQ(p) != ssn->client.next_seq) {\n                SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                        \" != %\" PRIu32 \" from stream\", ssn,\n                        TCP_GET_SEQ(p), ssn->client.next_seq);\n                StreamTcpSetEvent(p, STREAM_CLOSING_ACK_WRONG_SEQ);\n                return -1;\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->server, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_CLOSING_INVALID_ACK);\n                return -1;\n            }\n\n            if (!retransmission) {\n                StreamTcpPacketSetState(p, ssn, TCP_TIME_WAIT);\n                SCLogDebug(\"ssn %p: state changed to TCP_TIME_WAIT\", ssn);\n\n                ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->server.next_seq, TCP_GET_ACK(p)))\n                ssn->server.next_seq = TCP_GET_ACK(p);\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->client.next_seq,\n                    ssn->server.last_ack);\n        } else { /* implied to client */\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to client: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n            int retransmission = 0;\n            if (StreamTcpPacketIsRetransmission(&ssn->server, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n            }\n\n            if (TCP_GET_SEQ(p) != ssn->server.next_seq) {\n                SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                        \" != %\" PRIu32 \" from stream\", ssn,\n                        TCP_GET_SEQ(p), ssn->server.next_seq);\n                StreamTcpSetEvent(p, STREAM_CLOSING_ACK_WRONG_SEQ);\n                return -1;\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->client, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_CLOSING_INVALID_ACK);\n                return -1;\n            }\n\n            if (!retransmission) {\n                StreamTcpPacketSetState(p, ssn, TCP_TIME_WAIT);\n                SCLogDebug(\"ssn %p: state changed to TCP_TIME_WAIT\", ssn);\n\n                ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->client.next_seq, TCP_GET_ACK(p)))\n                ssn->client.next_seq = TCP_GET_ACK(p);\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n            SCLogDebug(\"StreamTcpPacketStateClosing (%p): =+ next SEQ \"\n                    \"%\" PRIu32 \", last ACK %\" PRIu32 \"\", ssn,\n                    ssn->server.next_seq, ssn->client.last_ack);\n        }\n    } else {\n        SCLogDebug(\"ssn %p: default case\", ssn);\n    }\n\n    return 0;\n}\n\n/**\n *  \\brief  Function to handle the TCP_CLOSE_WAIT state. Upon arrival of FIN\n *          packet from server the connection goes to TCP_LAST_ACK state.\n *          The state is possible only for server host.\n *\n *  \\param  tv      Thread Variable containing  input/output queue, cpu affinity\n *  \\param  p       Packet which has to be handled in this TCP state.\n *  \\param  stt     Strean Thread module registered to handle the stream handling\n */\n\nstatic int StreamTcpPacketStateCloseWait(ThreadVars *tv, Packet *p,\n        StreamTcpThread *stt, TcpSession *ssn, PacketQueueNoLock *pq)\n{\n    SCEnter();\n\n    if (ssn == NULL) {\n        SCReturnInt(-1);\n    }\n\n    if (PKT_IS_TOCLIENT(p)) {\n        SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to client: SEQ \"\n                \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                TCP_GET_SEQ(p), TCP_GET_ACK(p));\n    } else {\n        SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to server: SEQ \"\n                \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                TCP_GET_SEQ(p), TCP_GET_ACK(p));\n    }\n\n    if (p->tcph->th_flags & TH_RST) {\n        if (!StreamTcpValidateRst(ssn, p))\n            return -1;\n\n        StreamTcpCloseSsnWithReset(p, ssn);\n\n        if (PKT_IS_TOSERVER(p)) {\n            if ((p->tcph->th_flags & TH_ACK) && StreamTcpValidateAck(ssn, &ssn->server, p) == 0)\n                StreamTcpUpdateLastAck(ssn, &ssn->server,\n                        StreamTcpResetGetMaxAck(&ssn->server, TCP_GET_ACK(p)));\n\n            StreamTcpUpdateLastAck(ssn, &ssn->client,\n                    StreamTcpResetGetMaxAck(&ssn->client, TCP_GET_SEQ(p)));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n        } else {\n            if ((p->tcph->th_flags & TH_ACK) && StreamTcpValidateAck(ssn, &ssn->client, p) == 0)\n                StreamTcpUpdateLastAck(ssn, &ssn->client,\n                        StreamTcpResetGetMaxAck(&ssn->client, TCP_GET_ACK(p)));\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server,\n                    StreamTcpResetGetMaxAck(&ssn->server, TCP_GET_SEQ(p)));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n        }\n\n    } else if (p->tcph->th_flags & TH_FIN) {\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            if (!StreamTcpValidateTimestamp(ssn, p))\n                SCReturnInt(-1);\n        }\n\n        if (PKT_IS_TOSERVER(p)) {\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to server: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n\n            int retransmission = 0;\n            if (StreamTcpPacketIsRetransmission(&ssn->client, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n            }\n\n            if (!retransmission) {\n                if (SEQ_LT(TCP_GET_SEQ(p), ssn->client.next_seq) ||\n                        SEQ_GT(TCP_GET_SEQ(p), (ssn->client.last_ack + ssn->client.window)))\n                {\n                    SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                            \" != %\" PRIu32 \" from stream\", ssn,\n                            TCP_GET_SEQ(p), ssn->client.next_seq);\n                    StreamTcpSetEvent(p, STREAM_CLOSEWAIT_FIN_OUT_OF_WINDOW);\n                    SCReturnInt(-1);\n                }\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->server, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_CLOSEWAIT_INVALID_ACK);\n                SCReturnInt(-1);\n            }\n\n            /* don't update to LAST_ACK here as we want a toclient FIN for that */\n\n            if (!retransmission)\n                ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n\n            if (p->tcph->th_flags & TH_ACK)\n                StreamTcpUpdateLastAck(ssn, &ssn->server, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->server.next_seq, TCP_GET_ACK(p)))\n                ssn->server.next_seq = TCP_GET_ACK(p);\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->client.next_seq,\n                    ssn->server.last_ack);\n        } else {\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to client: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n\n            int retransmission = 0;\n            if (StreamTcpPacketIsRetransmission(&ssn->server, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n            }\n\n            if (!retransmission) {\n                if (SEQ_LT(TCP_GET_SEQ(p), ssn->server.next_seq) ||\n                        SEQ_GT(TCP_GET_SEQ(p), (ssn->server.last_ack + ssn->server.window)))\n                {\n                    SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                            \" != %\" PRIu32 \" from stream\", ssn,\n                            TCP_GET_SEQ(p), ssn->server.next_seq);\n                    StreamTcpSetEvent(p, STREAM_CLOSEWAIT_FIN_OUT_OF_WINDOW);\n                    SCReturnInt(-1);\n                }\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->client, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_CLOSEWAIT_INVALID_ACK);\n                SCReturnInt(-1);\n            }\n\n            if (!retransmission) {\n                StreamTcpPacketSetState(p, ssn, TCP_LAST_ACK);\n                SCLogDebug(\"ssn %p: state changed to TCP_LAST_ACK\", ssn);\n\n                ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n            }\n\n            if (p->tcph->th_flags & TH_ACK)\n                StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->client.next_seq, TCP_GET_ACK(p)))\n                ssn->client.next_seq = TCP_GET_ACK(p);\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->server.next_seq,\n                    ssn->client.last_ack);\n        }\n\n    } else if (p->tcph->th_flags & TH_SYN) {\n        SCLogDebug(\"ssn (%p): SYN pkt on CloseWait\", ssn);\n        StreamTcpSetEvent(p, STREAM_SHUTDOWN_SYN_RESEND);\n        SCReturnInt(-1);\n\n    } else if (p->tcph->th_flags & TH_ACK) {\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            if (!StreamTcpValidateTimestamp(ssn, p))\n                SCReturnInt(-1);\n        }\n\n        if (PKT_IS_TOSERVER(p)) {\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to server: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n\n            int retransmission = 0;\n            if (StreamTcpPacketIsRetransmission(&ssn->client, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n            }\n\n            if (p->payload_len > 0 && (SEQ_LEQ((TCP_GET_SEQ(p) + p->payload_len), ssn->client.last_ack))) {\n                SCLogDebug(\"ssn %p: -> retransmission\", ssn);\n                StreamTcpSetEvent(p, STREAM_CLOSEWAIT_PKT_BEFORE_LAST_ACK);\n                SCReturnInt(-1);\n\n            } else if (SEQ_GT(TCP_GET_SEQ(p), (ssn->client.last_ack + ssn->client.window)))\n            {\n                SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                        \" != %\" PRIu32 \" from stream\", ssn,\n                        TCP_GET_SEQ(p), ssn->client.next_seq);\n                StreamTcpSetEvent(p, STREAM_CLOSEWAIT_ACK_OUT_OF_WINDOW);\n                SCReturnInt(-1);\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->server, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_CLOSEWAIT_INVALID_ACK);\n                SCReturnInt(-1);\n            }\n\n            if (!retransmission) {\n                ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->server.next_seq, TCP_GET_ACK(p)))\n                ssn->server.next_seq = TCP_GET_ACK(p);\n\n            if (SEQ_EQ(TCP_GET_SEQ(p),ssn->client.next_seq))\n                StreamTcpUpdateNextSeq(ssn, &ssn->client, (ssn->client.next_seq + p->payload_len));\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->client.next_seq,\n                    ssn->server.last_ack);\n        } else {\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to client: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n            int retransmission = 0;\n            if (StreamTcpPacketIsRetransmission(&ssn->server, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n            }\n\n            if (p->payload_len > 0 && (SEQ_LEQ((TCP_GET_SEQ(p) + p->payload_len), ssn->server.last_ack))) {\n                SCLogDebug(\"ssn %p: -> retransmission\", ssn);\n                StreamTcpSetEvent(p, STREAM_CLOSEWAIT_PKT_BEFORE_LAST_ACK);\n                SCReturnInt(-1);\n\n            } else if (SEQ_GT(TCP_GET_SEQ(p), (ssn->server.last_ack + ssn->server.window)))\n            {\n                SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                        \" != %\" PRIu32 \" from stream\", ssn,\n                        TCP_GET_SEQ(p), ssn->server.next_seq);\n                StreamTcpSetEvent(p, STREAM_CLOSEWAIT_ACK_OUT_OF_WINDOW);\n                SCReturnInt(-1);\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->client, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_CLOSEWAIT_INVALID_ACK);\n                SCReturnInt(-1);\n            }\n\n            if (!retransmission) {\n                ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->client.next_seq, TCP_GET_ACK(p)))\n                ssn->client.next_seq = TCP_GET_ACK(p);\n\n            if (SEQ_EQ(TCP_GET_SEQ(p),ssn->server.next_seq))\n                StreamTcpUpdateNextSeq(ssn, &ssn->server, (ssn->server.next_seq + p->payload_len));\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->server.next_seq,\n                    ssn->client.last_ack);\n        }\n\n    } else {\n        SCLogDebug(\"ssn %p: default case\", ssn);\n    }\n    SCReturnInt(0);\n}\n\n/**\n *  \\brief  Function to handle the TCP_LAST_ACK state. Upon arrival of ACK\n *          the connection goes to TCP_CLOSED state and stream memory is\n *          returned back to pool. The state is possible only for server host.\n *\n *  \\param  tv      Thread Variable containing  input/output queue, cpu affinity\n *  \\param  p       Packet which has to be handled in this TCP state.\n *  \\param  stt     Strean Thread module registered to handle the stream handling\n */\n\nstatic int StreamTcpPacketStateLastAck(ThreadVars *tv, Packet *p,\n        StreamTcpThread *stt, TcpSession *ssn, PacketQueueNoLock *pq)\n{\n    if (ssn == NULL)\n        return -1;\n\n    if (p->tcph->th_flags & TH_RST) {\n        if (!StreamTcpValidateRst(ssn, p))\n            return -1;\n\n        StreamTcpCloseSsnWithReset(p, ssn);\n\n        if (PKT_IS_TOSERVER(p)) {\n            if ((p->tcph->th_flags & TH_ACK) && StreamTcpValidateAck(ssn, &ssn->server, p) == 0)\n                StreamTcpUpdateLastAck(ssn, &ssn->server,\n                        StreamTcpResetGetMaxAck(&ssn->server, TCP_GET_ACK(p)));\n\n            StreamTcpUpdateLastAck(ssn, &ssn->client,\n                    StreamTcpResetGetMaxAck(&ssn->client, TCP_GET_SEQ(p)));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n        } else {\n            if ((p->tcph->th_flags & TH_ACK) && StreamTcpValidateAck(ssn, &ssn->client, p) == 0)\n                StreamTcpUpdateLastAck(ssn, &ssn->client,\n                        StreamTcpResetGetMaxAck(&ssn->client, TCP_GET_ACK(p)));\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server,\n                    StreamTcpResetGetMaxAck(&ssn->server, TCP_GET_SEQ(p)));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n        }\n\n    } else if (p->tcph->th_flags & TH_FIN) {\n        /** \\todo */\n        SCLogDebug(\"ssn (%p): FIN pkt on LastAck\", ssn);\n\n    } else if (p->tcph->th_flags & TH_SYN) {\n        SCLogDebug(\"ssn (%p): SYN pkt on LastAck\", ssn);\n        StreamTcpSetEvent(p, STREAM_SHUTDOWN_SYN_RESEND);\n        return -1;\n\n    } else if (p->tcph->th_flags & TH_ACK) {\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            if (!StreamTcpValidateTimestamp(ssn, p))\n                return -1;\n        }\n\n        if (PKT_IS_TOSERVER(p)) {\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to server: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n\n            int retransmission = 0;\n            if (StreamTcpPacketIsRetransmission(&ssn->client, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->server, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_LASTACK_INVALID_ACK);\n                SCReturnInt(-1);\n            }\n\n            if (!retransmission) {\n                if (SEQ_LT(TCP_GET_SEQ(p), ssn->client.next_seq)) {\n                    SCLogDebug(\"ssn %p: not updating state as packet is before next_seq\", ssn);\n                } else if (TCP_GET_SEQ(p) != ssn->client.next_seq && TCP_GET_SEQ(p) != ssn->client.next_seq + 1) {\n                    SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                            \" != %\" PRIu32 \" from stream\", ssn,\n                            TCP_GET_SEQ(p), ssn->client.next_seq);\n                    StreamTcpSetEvent(p, STREAM_LASTACK_ACK_WRONG_SEQ);\n                    return -1;\n                } else {\n                    StreamTcpPacketSetState(p, ssn, TCP_CLOSED);\n                    SCLogDebug(\"ssn %p: state changed to TCP_CLOSED\", ssn);\n\n                }\n                ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->server.next_seq, TCP_GET_ACK(p)))\n                ssn->server.next_seq = TCP_GET_ACK(p);\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->client.next_seq,\n                    ssn->server.last_ack);\n        }\n    } else {\n        SCLogDebug(\"ssn %p: default case\", ssn);\n    }\n\n    return 0;\n}\n\n/**\n *  \\brief  Function to handle the TCP_TIME_WAIT state. Upon arrival of ACK\n *          the connection goes to TCP_CLOSED state and stream memory is\n *          returned back to pool.\n *\n *  \\param  tv      Thread Variable containing  input/output queue, cpu affinity\n *  \\param  p       Packet which has to be handled in this TCP state.\n *  \\param  stt     Strean Thread module registered to handle the stream handling\n */\n\nstatic int StreamTcpPacketStateTimeWait(ThreadVars *tv, Packet *p,\n        StreamTcpThread *stt, TcpSession *ssn, PacketQueueNoLock *pq)\n{\n    if (ssn == NULL)\n        return -1;\n\n    if (p->tcph->th_flags & TH_RST) {\n        if (!StreamTcpValidateRst(ssn, p))\n            return -1;\n\n        StreamTcpCloseSsnWithReset(p, ssn);\n\n        if (PKT_IS_TOSERVER(p)) {\n            if ((p->tcph->th_flags & TH_ACK) && StreamTcpValidateAck(ssn, &ssn->server, p) == 0)\n                StreamTcpUpdateLastAck(ssn, &ssn->server,\n                        StreamTcpResetGetMaxAck(&ssn->server, TCP_GET_ACK(p)));\n\n            StreamTcpUpdateLastAck(ssn, &ssn->client,\n                    StreamTcpResetGetMaxAck(&ssn->client, TCP_GET_SEQ(p)));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n        } else {\n            if ((p->tcph->th_flags & TH_ACK) && StreamTcpValidateAck(ssn, &ssn->client, p) == 0)\n                StreamTcpUpdateLastAck(ssn, &ssn->client,\n                        StreamTcpResetGetMaxAck(&ssn->client, TCP_GET_ACK(p)));\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server,\n                    StreamTcpResetGetMaxAck(&ssn->server, TCP_GET_SEQ(p)));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n        }\n\n    } else if (p->tcph->th_flags & TH_FIN) {\n        /** \\todo */\n\n    } else if (p->tcph->th_flags & TH_SYN) {\n        SCLogDebug(\"ssn (%p): SYN pkt on TimeWait\", ssn);\n        StreamTcpSetEvent(p, STREAM_SHUTDOWN_SYN_RESEND);\n        return -1;\n\n    } else if (p->tcph->th_flags & TH_ACK) {\n        if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n            if (!StreamTcpValidateTimestamp(ssn, p))\n                return -1;\n        }\n\n        if (PKT_IS_TOSERVER(p)) {\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to server: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n            int retransmission = 0;\n            if (StreamTcpPacketIsRetransmission(&ssn->client, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n\n            } else if (TCP_GET_SEQ(p) != ssn->client.next_seq && TCP_GET_SEQ(p) != ssn->client.next_seq+1) {\n                SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                        \" != %\" PRIu32 \" from stream\", ssn,\n                        TCP_GET_SEQ(p), ssn->client.next_seq);\n                StreamTcpSetEvent(p, STREAM_TIMEWAIT_ACK_WRONG_SEQ);\n                return -1;\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->server, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_TIMEWAIT_INVALID_ACK);\n                SCReturnInt(-1);\n            }\n\n            if (!retransmission) {\n                StreamTcpPacketSetState(p, ssn, TCP_CLOSED);\n                SCLogDebug(\"ssn %p: state changed to TCP_CLOSED\", ssn);\n\n                ssn->server.window = TCP_GET_WINDOW(p) << ssn->server.wscale;\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->server, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->server.next_seq, TCP_GET_ACK(p)))\n                ssn->server.next_seq = TCP_GET_ACK(p);\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->client, p, pq);\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->client.next_seq,\n                    ssn->server.last_ack);\n        } else {\n            SCLogDebug(\"ssn %p: pkt (%\" PRIu32 \") is to client: SEQ \"\n                    \"%\" PRIu32 \", ACK %\" PRIu32 \"\", ssn, p->payload_len,\n                    TCP_GET_SEQ(p), TCP_GET_ACK(p));\n            int retransmission = 0;\n            if (StreamTcpPacketIsRetransmission(&ssn->server, p)) {\n                SCLogDebug(\"ssn %p: packet is retransmission\", ssn);\n                retransmission = 1;\n            } else if (TCP_GET_SEQ(p) != ssn->server.next_seq && TCP_GET_SEQ(p) != ssn->server.next_seq+1) {\n                if (p->payload_len > 0 && TCP_GET_SEQ(p) == ssn->server.last_ack) {\n                    SCLogDebug(\"ssn %p: -> retransmission\", ssn);\n                    SCReturnInt(0);\n                } else {\n                    SCLogDebug(\"ssn %p: -> SEQ mismatch, packet SEQ %\" PRIu32 \"\"\n                            \" != %\" PRIu32 \" from stream\", ssn,\n                            TCP_GET_SEQ(p), ssn->server.next_seq);\n                    StreamTcpSetEvent(p, STREAM_TIMEWAIT_ACK_WRONG_SEQ);\n                    return -1;\n                }\n            }\n\n            if (StreamTcpValidateAck(ssn, &ssn->client, p) == -1) {\n                SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n                StreamTcpSetEvent(p, STREAM_TIMEWAIT_INVALID_ACK);\n                SCReturnInt(-1);\n            }\n\n            if (!retransmission) {\n                StreamTcpPacketSetState(p, ssn, TCP_CLOSED);\n                SCLogDebug(\"ssn %p: state changed to TCP_CLOSED\", ssn);\n\n                ssn->client.window = TCP_GET_WINDOW(p) << ssn->client.wscale;\n            }\n\n            StreamTcpUpdateLastAck(ssn, &ssn->client, TCP_GET_ACK(p));\n\n            if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n                StreamTcpHandleTimestamp(ssn, p);\n            }\n\n            /* Update the next_seq, in case if we have missed the client\n               packet and server has already received and acked it */\n            if (SEQ_LT(ssn->client.next_seq, TCP_GET_ACK(p)))\n                ssn->client.next_seq = TCP_GET_ACK(p);\n\n            StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                    &ssn->server, p, pq);\n            SCLogDebug(\"ssn %p: =+ next SEQ %\" PRIu32 \", last ACK \"\n                    \"%\" PRIu32 \"\", ssn, ssn->server.next_seq,\n                    ssn->client.last_ack);\n        }\n\n    } else {\n        SCLogDebug(\"ssn %p: default case\", ssn);\n    }\n\n    return 0;\n}\n\nstatic int StreamTcpPacketStateClosed(ThreadVars *tv, Packet *p,\n        StreamTcpThread *stt, TcpSession *ssn, PacketQueueNoLock *pq)\n{\n    if (ssn == NULL)\n        return -1;\n\n    if (p->tcph->th_flags & TH_RST) {\n        SCLogDebug(\"RST on closed state\");\n        return 0;\n    }\n\n    TcpStream *stream = NULL, *ostream = NULL;\n    if (PKT_IS_TOSERVER(p)) {\n        stream = &ssn->client;\n        ostream = &ssn->server;\n    } else {\n        stream = &ssn->server;\n        ostream = &ssn->client;\n    }\n\n    SCLogDebug(\"stream %s ostream %s\",\n            stream->flags & STREAMTCP_STREAM_FLAG_RST_RECV?\"true\":\"false\",\n            ostream->flags & STREAMTCP_STREAM_FLAG_RST_RECV ? \"true\":\"false\");\n\n    /* if we've seen a RST on our direction, but not on the other\n     * see if we perhaps need to continue processing anyway. */\n    if ((stream->flags & STREAMTCP_STREAM_FLAG_RST_RECV) == 0) {\n        if (ostream->flags & STREAMTCP_STREAM_FLAG_RST_RECV) {\n            if (StreamTcpStateDispatch(tv, p, stt, ssn, &stt->pseudo_queue, ssn->pstate) < 0)\n                return -1;\n            /* if state is still \"closed\", it wasn't updated by our dispatch. */\n            if (ssn->state == TCP_CLOSED)\n                ssn->state = ssn->pstate;\n        }\n    }\n    return 0;\n}\n\nstatic void StreamTcpPacketCheckPostRst(TcpSession *ssn, Packet *p)\n{\n    if (p->flags & PKT_PSEUDO_STREAM_END) {\n        return;\n    }\n    /* more RSTs are not unusual */\n    if ((p->tcph->th_flags & (TH_RST)) != 0) {\n        return;\n    }\n\n    TcpStream *ostream = NULL;\n    if (PKT_IS_TOSERVER(p)) {\n        ostream = &ssn->server;\n    } else {\n        ostream = &ssn->client;\n    }\n\n    if (ostream->flags & STREAMTCP_STREAM_FLAG_RST_RECV) {\n        SCLogDebug(\"regular packet %\"PRIu64\" from same sender as \"\n                \"the previous RST. Looks like it injected!\", p->pcap_cnt);\n        ostream->flags &= ~STREAMTCP_STREAM_FLAG_RST_RECV;\n        ssn->flags &= ~STREAMTCP_FLAG_CLOSED_BY_RST;\n        StreamTcpSetEvent(p, STREAM_SUSPECTED_RST_INJECT);\n        return;\n    }\n    return;\n}\n\n/**\n *  \\retval 1 packet is a keep alive pkt\n *  \\retval 0 packet is not a keep alive pkt\n */\nstatic int StreamTcpPacketIsKeepAlive(TcpSession *ssn, Packet *p)\n{\n    TcpStream *stream = NULL, *ostream = NULL;\n    uint32_t seq;\n    uint32_t ack;\n\n    if (p->flags & PKT_PSEUDO_STREAM_END)\n        return 0;\n\n    /*\n       rfc 1122:\n       An implementation SHOULD send a keep-alive segment with no\n       data; however, it MAY be configurable to send a keep-alive\n       segment containing one garbage octet, for compatibility with\n       erroneous TCP implementations.\n     */\n    if (p->payload_len > 1)\n        return 0;\n\n    if ((p->tcph->th_flags & (TH_SYN|TH_FIN|TH_RST)) != 0) {\n        return 0;\n    }\n\n    if (PKT_IS_TOSERVER(p)) {\n        stream = &ssn->client;\n        ostream = &ssn->server;\n    } else {\n        stream = &ssn->server;\n        ostream = &ssn->client;\n    }\n\n    seq = TCP_GET_SEQ(p);\n    ack = TCP_GET_ACK(p);\n\n    if (ack == ostream->last_ack && seq == (stream->next_seq - 1)) {\n        SCLogDebug(\"packet is TCP keep-alive: %\"PRIu64, p->pcap_cnt);\n        stream->flags |= STREAMTCP_STREAM_FLAG_KEEPALIVE;\n        return 1;\n    }\n    SCLogDebug(\"seq %u (%u), ack %u (%u)\", seq,  (stream->next_seq - 1), ack, ostream->last_ack);\n    return 0;\n}\n\n/**\n *  \\retval 1 packet is a keep alive ACK pkt\n *  \\retval 0 packet is not a keep alive ACK pkt\n */\nstatic int StreamTcpPacketIsKeepAliveACK(TcpSession *ssn, Packet *p)\n{\n    TcpStream *stream = NULL, *ostream = NULL;\n    uint32_t seq;\n    uint32_t ack;\n    uint32_t pkt_win;\n\n    if (p->flags & PKT_PSEUDO_STREAM_END)\n        return 0;\n    /* should get a normal ACK to a Keep Alive */\n    if (p->payload_len > 0)\n        return 0;\n\n    if ((p->tcph->th_flags & (TH_SYN|TH_FIN|TH_RST)) != 0)\n        return 0;\n\n    if (TCP_GET_WINDOW(p) == 0)\n        return 0;\n\n    if (PKT_IS_TOSERVER(p)) {\n        stream = &ssn->client;\n        ostream = &ssn->server;\n    } else {\n        stream = &ssn->server;\n        ostream = &ssn->client;\n    }\n\n    seq = TCP_GET_SEQ(p);\n    ack = TCP_GET_ACK(p);\n\n    pkt_win = TCP_GET_WINDOW(p) << ostream->wscale;\n    if (pkt_win != ostream->window)\n        return 0;\n\n    if ((ostream->flags & STREAMTCP_STREAM_FLAG_KEEPALIVE) && ack == ostream->last_ack && seq == stream->next_seq) {\n        SCLogDebug(\"packet is TCP keep-aliveACK: %\"PRIu64, p->pcap_cnt);\n        ostream->flags &= ~STREAMTCP_STREAM_FLAG_KEEPALIVE;\n        return 1;\n    }\n    SCLogDebug(\"seq %u (%u), ack %u (%u) FLAG_KEEPALIVE: %s\", seq, stream->next_seq, ack, ostream->last_ack,\n            ostream->flags & STREAMTCP_STREAM_FLAG_KEEPALIVE ? \"set\" : \"not set\");\n    return 0;\n}\n\nstatic void StreamTcpClearKeepAliveFlag(TcpSession *ssn, Packet *p)\n{\n    TcpStream *stream = NULL;\n\n    if (p->flags & PKT_PSEUDO_STREAM_END)\n        return;\n\n    if (PKT_IS_TOSERVER(p)) {\n        stream = &ssn->client;\n    } else {\n        stream = &ssn->server;\n    }\n\n    if (stream->flags & STREAMTCP_STREAM_FLAG_KEEPALIVE) {\n        stream->flags &= ~STREAMTCP_STREAM_FLAG_KEEPALIVE;\n        SCLogDebug(\"FLAG_KEEPALIVE cleared\");\n    }\n}\n\n/**\n *  \\retval 1 packet is a window update pkt\n *  \\retval 0 packet is not a window update pkt\n */\nstatic int StreamTcpPacketIsWindowUpdate(TcpSession *ssn, Packet *p)\n{\n    TcpStream *stream = NULL, *ostream = NULL;\n    uint32_t seq;\n    uint32_t ack;\n    uint32_t pkt_win;\n\n    if (p->flags & PKT_PSEUDO_STREAM_END)\n        return 0;\n\n    if (ssn->state < TCP_ESTABLISHED)\n        return 0;\n\n    if (p->payload_len > 0)\n        return 0;\n\n    if ((p->tcph->th_flags & (TH_SYN|TH_FIN|TH_RST)) != 0)\n        return 0;\n\n    if (TCP_GET_WINDOW(p) == 0)\n        return 0;\n\n    if (PKT_IS_TOSERVER(p)) {\n        stream = &ssn->client;\n        ostream = &ssn->server;\n    } else {\n        stream = &ssn->server;\n        ostream = &ssn->client;\n    }\n\n    seq = TCP_GET_SEQ(p);\n    ack = TCP_GET_ACK(p);\n\n    pkt_win = TCP_GET_WINDOW(p) << ostream->wscale;\n    if (pkt_win == ostream->window)\n        return 0;\n\n    if (ack == ostream->last_ack && seq == stream->next_seq) {\n        SCLogDebug(\"packet is TCP window update: %\"PRIu64, p->pcap_cnt);\n        return 1;\n    }\n    SCLogDebug(\"seq %u (%u), ack %u (%u)\", seq, stream->next_seq, ack, ostream->last_ack);\n    return 0;\n}\n\n/**\n *  Try to detect whether a packet is a valid FIN 4whs final ack.\n *\n */\nstatic int StreamTcpPacketIsFinShutdownAck(TcpSession *ssn, Packet *p)\n{\n    TcpStream *stream = NULL, *ostream = NULL;\n    uint32_t seq;\n    uint32_t ack;\n\n    if (p->flags & PKT_PSEUDO_STREAM_END)\n        return 0;\n    if (!(ssn->state == TCP_TIME_WAIT || ssn->state == TCP_CLOSE_WAIT || ssn->state == TCP_LAST_ACK))\n        return 0;\n    if (p->tcph->th_flags != TH_ACK)\n        return 0;\n    if (p->payload_len != 0)\n        return 0;\n\n    if (PKT_IS_TOSERVER(p)) {\n        stream = &ssn->client;\n        ostream = &ssn->server;\n    } else {\n        stream = &ssn->server;\n        ostream = &ssn->client;\n    }\n\n    seq = TCP_GET_SEQ(p);\n    ack = TCP_GET_ACK(p);\n\n    SCLogDebug(\"%\"PRIu64\", seq %u ack %u stream->next_seq %u ostream->next_seq %u\",\n            p->pcap_cnt, seq, ack, stream->next_seq, ostream->next_seq);\n\n    if (SEQ_EQ(stream->next_seq + 1, seq) && SEQ_EQ(ack, ostream->next_seq + 1)) {\n        return 1;\n    }\n    return 0;\n}\n\n/**\n *  Try to detect packets doing bad window updates\n *\n *  See bug 1238.\n *\n *  Find packets that are unexpected, and shrink the window to the point\n *  where the packets we do expect are rejected for being out of window.\n *\n *  The logic we use here is:\n *  - packet seq > next_seq\n *  - packet ack > next_seq (packet acks unseen data)\n *  - packet shrinks window more than it's own data size\n *  - packet shrinks window more than the diff between it's ack and the\n *    last_ack value\n *\n *  Packets coming in after packet loss can look quite a bit like this.\n */\nstatic int StreamTcpPacketIsBadWindowUpdate(TcpSession *ssn, Packet *p)\n{\n    TcpStream *stream = NULL, *ostream = NULL;\n    uint32_t seq;\n    uint32_t ack;\n    uint32_t pkt_win;\n\n    if (p->flags & PKT_PSEUDO_STREAM_END)\n        return 0;\n\n    if (ssn->state < TCP_ESTABLISHED || ssn->state == TCP_CLOSED)\n        return 0;\n\n    if ((p->tcph->th_flags & (TH_SYN|TH_FIN|TH_RST)) != 0)\n        return 0;\n\n    if (PKT_IS_TOSERVER(p)) {\n        stream = &ssn->client;\n        ostream = &ssn->server;\n    } else {\n        stream = &ssn->server;\n        ostream = &ssn->client;\n    }\n\n    seq = TCP_GET_SEQ(p);\n    ack = TCP_GET_ACK(p);\n\n    pkt_win = TCP_GET_WINDOW(p) << ostream->wscale;\n\n    if (pkt_win < ostream->window) {\n        uint32_t diff = ostream->window - pkt_win;\n        if (diff > p->payload_len &&\n                SEQ_GT(ack, ostream->next_seq) &&\n                SEQ_GT(seq, stream->next_seq))\n        {\n            SCLogDebug(\"%\"PRIu64\", pkt_win %u, stream win %u, diff %u, dsize %u\",\n                p->pcap_cnt, pkt_win, ostream->window, diff, p->payload_len);\n            SCLogDebug(\"%\"PRIu64\", pkt_win %u, stream win %u\",\n                p->pcap_cnt, pkt_win, ostream->window);\n            SCLogDebug(\"%\"PRIu64\", seq %u ack %u ostream->next_seq %u ostream->last_ack %u, ostream->next_win %u, diff %u (%u)\",\n                    p->pcap_cnt, seq, ack, ostream->next_seq, ostream->last_ack, ostream->next_win,\n                    ostream->next_seq - ostream->last_ack, stream->next_seq - stream->last_ack);\n\n            /* get the expected window shrinking from looking at ack vs last_ack.\n             * Observed a lot of just a little overrunning that value. So added some\n             * margin that is still ok. To make sure this isn't a loophole to still\n             * close the window, this is limited to windows above 1024. Both values\n             * are rather arbitrary. */\n            uint32_t adiff = ack - ostream->last_ack;\n            if (((pkt_win > 1024) && (diff > (adiff + 32))) ||\n                ((pkt_win <= 1024) && (diff > adiff)))\n            {\n                SCLogDebug(\"pkt ACK %u is %u bytes beyond last_ack %u, shrinks window by %u \"\n                        \"(allowing 32 bytes extra): pkt WIN %u\", ack, adiff, ostream->last_ack, diff, pkt_win);\n                SCLogDebug(\"%u - %u = %u (state %u)\", diff, adiff, diff - adiff, ssn->state);\n                StreamTcpSetEvent(p, STREAM_PKT_BAD_WINDOW_UPDATE);\n                return 1;\n            }\n        }\n\n    }\n    SCLogDebug(\"seq %u (%u), ack %u (%u)\", seq, stream->next_seq, ack, ostream->last_ack);\n    return 0;\n}\n\n/** \\internal\n *  \\brief call packet handling function for 'state'\n *  \\param state current TCP state\n */\nstatic inline int StreamTcpStateDispatch(ThreadVars *tv, Packet *p,\n        StreamTcpThread *stt, TcpSession *ssn, PacketQueueNoLock *pq,\n        const uint8_t state)\n{\n    SCLogDebug(\"ssn: %p\", ssn);\n    switch (state) {\n        case TCP_SYN_SENT:\n            SCLogDebug(\"packet received on TCP_SYN_SENT state\");\n            if (StreamTcpPacketStateSynSent(tv, p, stt, ssn, pq)) {\n                return -1;\n            }\n            break;\n        case TCP_SYN_RECV:\n            SCLogDebug(\"packet received on TCP_SYN_RECV state\");\n            if (StreamTcpPacketStateSynRecv(tv, p, stt, ssn, pq)) {\n                return -1;\n            }\n            break;\n        case TCP_ESTABLISHED:\n            SCLogDebug(\"packet received on TCP_ESTABLISHED state\");\n            if (StreamTcpPacketStateEstablished(tv, p, stt, ssn, pq)) {\n                return -1;\n            }\n            break;\n        case TCP_FIN_WAIT1:\n            SCLogDebug(\"packet received on TCP_FIN_WAIT1 state\");\n            if (StreamTcpPacketStateFinWait1(tv, p, stt, ssn, pq)) {\n                return -1;\n            }\n            break;\n        case TCP_FIN_WAIT2:\n            SCLogDebug(\"packet received on TCP_FIN_WAIT2 state\");\n            if (StreamTcpPacketStateFinWait2(tv, p, stt, ssn, pq)) {\n                return -1;\n            }\n            break;\n        case TCP_CLOSING:\n            SCLogDebug(\"packet received on TCP_CLOSING state\");\n            if (StreamTcpPacketStateClosing(tv, p, stt, ssn, pq)) {\n                return -1;\n            }\n            break;\n        case TCP_CLOSE_WAIT:\n            SCLogDebug(\"packet received on TCP_CLOSE_WAIT state\");\n            if (StreamTcpPacketStateCloseWait(tv, p, stt, ssn, pq)) {\n                return -1;\n            }\n            break;\n        case TCP_LAST_ACK:\n            SCLogDebug(\"packet received on TCP_LAST_ACK state\");\n            if (StreamTcpPacketStateLastAck(tv, p, stt, ssn, pq)) {\n                return -1;\n            }\n            break;\n        case TCP_TIME_WAIT:\n            SCLogDebug(\"packet received on TCP_TIME_WAIT state\");\n            if (StreamTcpPacketStateTimeWait(tv, p, stt, ssn, pq)) {\n                return -1;\n            }\n            break;\n        case TCP_CLOSED:\n            /* TCP session memory is not returned to pool until timeout. */\n            SCLogDebug(\"packet received on closed state\");\n\n            if (StreamTcpPacketStateClosed(tv, p, stt, ssn, pq)) {\n                return -1;\n            }\n\n            break;\n        default:\n            SCLogDebug(\"packet received on default state\");\n            break;\n    }\n    return 0;\n}\n\nstatic inline void HandleThreadId(ThreadVars *tv, Packet *p, StreamTcpThread *stt)\n{\n    const int idx = (!(PKT_IS_TOSERVER(p)));\n\n    /* assign the thread id to the flow */\n    if (unlikely(p->flow->thread_id[idx] == 0)) {\n        p->flow->thread_id[idx] = (FlowThreadId)tv->id;\n    } else if (unlikely((FlowThreadId)tv->id != p->flow->thread_id[idx])) {\n        SCLogDebug(\"wrong thread: flow has %u, we are %d\", p->flow->thread_id[idx], tv->id);\n        if (p->pkt_src == PKT_SRC_WIRE) {\n            StatsIncr(tv, stt->counter_tcp_wrong_thread);\n            if ((p->flow->flags & FLOW_WRONG_THREAD) == 0) {\n                p->flow->flags |= FLOW_WRONG_THREAD;\n                StreamTcpSetEvent(p, STREAM_WRONG_THREAD);\n            }\n        }\n    }\n}\n\n/* flow is and stays locked */\nint StreamTcpPacket (ThreadVars *tv, Packet *p, StreamTcpThread *stt,\n                     PacketQueueNoLock *pq)\n{\n    SCEnter();\n\n    DEBUG_ASSERT_FLOW_LOCKED(p->flow);\n\n    SCLogDebug(\"p->pcap_cnt %\"PRIu64, p->pcap_cnt);\n\n    HandleThreadId(tv, p, stt);\n\n    TcpSession *ssn = (TcpSession *)p->flow->protoctx;\n\n    /* track TCP flags */\n    if (ssn != NULL) {\n        ssn->tcp_packet_flags |= p->tcph->th_flags;\n        if (PKT_IS_TOSERVER(p))\n            ssn->client.tcp_flags |= p->tcph->th_flags;\n        else if (PKT_IS_TOCLIENT(p))\n            ssn->server.tcp_flags |= p->tcph->th_flags;\n\n        /* check if we need to unset the ASYNC flag */\n        if (ssn->flags & STREAMTCP_FLAG_ASYNC &&\n            ssn->client.tcp_flags != 0 &&\n            ssn->server.tcp_flags != 0)\n        {\n            SCLogDebug(\"ssn %p: removing ASYNC flag as we have packets on both sides\", ssn);\n            ssn->flags &= ~STREAMTCP_FLAG_ASYNC;\n        }\n    }\n\n    /* update counters */\n    if ((p->tcph->th_flags & (TH_SYN|TH_ACK)) == (TH_SYN|TH_ACK)) {\n        StatsIncr(tv, stt->counter_tcp_synack);\n    } else if (p->tcph->th_flags & (TH_SYN)) {\n        StatsIncr(tv, stt->counter_tcp_syn);\n    }\n    if (p->tcph->th_flags & (TH_RST)) {\n        StatsIncr(tv, stt->counter_tcp_rst);\n    }\n\n    /* broken TCP http://ask.wireshark.org/questions/3183/acknowledgment-number-broken-tcp-the-acknowledge-field-is-nonzero-while-the-ack-flag-is-not-set */\n    if (!(p->tcph->th_flags & TH_ACK) && TCP_GET_ACK(p) != 0) {\n        StreamTcpSetEvent(p, STREAM_PKT_BROKEN_ACK);\n    }\n\n    /* If we are on IPS mode, and got a drop action triggered from\n     * the IP only module, or from a reassembled msg and/or from an\n     * applayer detection, then drop the rest of the packets of the\n     * same stream and avoid inspecting it any further */\n    if (StreamTcpCheckFlowDrops(p) == 1) {\n        SCLogDebug(\"This flow/stream triggered a drop rule\");\n        FlowSetNoPacketInspectionFlag(p->flow);\n        DecodeSetNoPacketInspectionFlag(p);\n        StreamTcpDisableAppLayer(p->flow);\n        PACKET_DROP(p);\n        /* return the segments to the pool */\n        StreamTcpSessionPktFree(p);\n        SCReturnInt(0);\n    }\n\n    if (ssn == NULL || ssn->state == TCP_NONE) {\n        if (StreamTcpPacketStateNone(tv, p, stt, ssn, &stt->pseudo_queue) == -1) {\n            goto error;\n        }\n\n        if (ssn != NULL)\n            SCLogDebug(\"ssn->alproto %\"PRIu16\"\", p->flow->alproto);\n    } else {\n        /* special case for PKT_PSEUDO_STREAM_END packets:\n         * bypass the state handling and various packet checks,\n         * we care about reassembly here. */\n        if (p->flags & PKT_PSEUDO_STREAM_END) {\n            if (PKT_IS_TOCLIENT(p)) {\n                ssn->client.last_ack = TCP_GET_ACK(p);\n                StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                        &ssn->server, p, pq);\n            } else {\n                ssn->server.last_ack = TCP_GET_ACK(p);\n                StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                        &ssn->client, p, pq);\n            }\n            /* straight to 'skip' as we already handled reassembly */\n            goto skip;\n        }\n\n        if (p->flow->flags & FLOW_WRONG_THREAD) {\n            /* Stream and/or session in known bad condition. Block events\n             * from being set. */\n            p->flags |= PKT_STREAM_NO_EVENTS;\n        }\n\n        if (StreamTcpPacketIsKeepAlive(ssn, p) == 1) {\n            goto skip;\n        }\n        if (StreamTcpPacketIsKeepAliveACK(ssn, p) == 1) {\n            StreamTcpClearKeepAliveFlag(ssn, p);\n            goto skip;\n        }\n        StreamTcpClearKeepAliveFlag(ssn, p);\n\n        /* if packet is not a valid window update, check if it is perhaps\n         * a bad window update that we should ignore (and alert on) */\n        if (StreamTcpPacketIsFinShutdownAck(ssn, p) == 0) {\n            if (StreamTcpPacketIsWindowUpdate(ssn, p) == 0) {\n                if (StreamTcpPacketIsBadWindowUpdate(ssn,p))\n                    goto skip;\n                if (StreamTcpPacketIsOutdatedAck(ssn, p))\n                    goto skip;\n            }\n        }\n\n        /* handle the per 'state' logic */\n        if (StreamTcpStateDispatch(tv, p, stt, ssn, &stt->pseudo_queue, ssn->state) < 0)\n            goto error;\n\n    skip:\n        StreamTcpPacketCheckPostRst(ssn, p);\n\n        if (ssn->state >= TCP_ESTABLISHED) {\n            p->flags |= PKT_STREAM_EST;\n        }\n    }\n\n    /* deal with a pseudo packet that is created upon receiving a RST\n     * segment. To be sure we process both sides of the connection, we\n     * inject a fake packet into the system, forcing reassembly of the\n     * opposing direction.\n     * There should be only one, but to be sure we do a while loop. */\n    if (ssn != NULL) {\n        while (stt->pseudo_queue.len > 0) {\n            SCLogDebug(\"processing pseudo packet / stream end\");\n            Packet *np = PacketDequeueNoLock(&stt->pseudo_queue);\n            if (np != NULL) {\n                /* process the opposing direction of the original packet */\n                if (PKT_IS_TOSERVER(np)) {\n                    SCLogDebug(\"pseudo packet is to server\");\n                    StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                            &ssn->client, np, NULL);\n                } else {\n                    SCLogDebug(\"pseudo packet is to client\");\n                    StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                            &ssn->server, np, NULL);\n                }\n\n                /* enqueue this packet so we inspect it in detect etc */\n                PacketEnqueueNoLock(pq, np);\n            }\n            SCLogDebug(\"processing pseudo packet / stream end done\");\n        }\n\n        /* recalc the csum on the packet if it was modified */\n        if (p->flags & PKT_STREAM_MODIFIED) {\n            ReCalculateChecksum(p);\n        }\n        /* check for conditions that may make us not want to log this packet */\n\n        /* streams that hit depth */\n        if ((ssn->client.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) ||\n             (ssn->server.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED))\n        {\n            /* we can call bypass callback, if enabled */\n            if (StreamTcpBypassEnabled()) {\n                PacketBypassCallback(p);\n            }\n        }\n\n        if ((ssn->client.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) ||\n             (ssn->server.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED))\n        {\n            p->flags |= PKT_STREAM_NOPCAPLOG;\n        }\n\n        /* encrypted packets */\n        if ((PKT_IS_TOSERVER(p) && (ssn->client.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY)) ||\n            (PKT_IS_TOCLIENT(p) && (ssn->server.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY)))\n        {\n            p->flags |= PKT_STREAM_NOPCAPLOG;\n        }\n\n        if (ssn->flags & STREAMTCP_FLAG_BYPASS) {\n            /* we can call bypass callback, if enabled */\n            if (StreamTcpBypassEnabled()) {\n                PacketBypassCallback(p);\n            }\n\n        /* if stream is dead and we have no detect engine at all, bypass. */\n        } else if (g_detect_disabled &&\n                (ssn->client.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) &&\n                (ssn->server.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) &&\n                StreamTcpBypassEnabled())\n        {\n            SCLogDebug(\"bypass as stream is dead and we have no rules\");\n            PacketBypassCallback(p);\n        }\n    }\n\n    SCReturnInt(0);\n\nerror:\n    /* make sure we don't leave packets in our pseudo queue */\n    while (stt->pseudo_queue.len > 0) {\n        Packet *np = PacketDequeueNoLock(&stt->pseudo_queue);\n        if (np != NULL) {\n            PacketEnqueueNoLock(pq, np);\n        }\n    }\n\n    /* recalc the csum on the packet if it was modified */\n    if (p->flags & PKT_STREAM_MODIFIED) {\n        ReCalculateChecksum(p);\n    }\n\n    if (StreamTcpInlineDropInvalid()) {\n        /* disable payload inspection as we're dropping this packet\n         * anyway. Doesn't disable all detection, so we can still\n         * match on the stream event that was set. */\n        DecodeSetNoPayloadInspectionFlag(p);\n        PACKET_DROP(p);\n    }\n    SCReturnInt(-1);\n}\n\n/**\n *  \\brief  Function to validate the checksum of the received packet. If the\n *          checksum is invalid, packet will be dropped, as the end system will\n *          also drop the packet.\n *\n *  \\param  p       Packet of which checksum has to be validated\n *  \\retval  1 if the checksum is valid, otherwise 0\n */\nstatic inline int StreamTcpValidateChecksum(Packet *p)\n{\n    int ret = 1;\n\n    if (p->flags & PKT_IGNORE_CHECKSUM)\n        return ret;\n\n    if (p->level4_comp_csum == -1) {\n        if (PKT_IS_IPV4(p)) {\n            p->level4_comp_csum = TCPChecksum(p->ip4h->s_ip_addrs,\n                                              (uint16_t *)p->tcph,\n                                              (p->payload_len +\n                                                  TCP_GET_HLEN(p)),\n                                              p->tcph->th_sum);\n        } else if (PKT_IS_IPV6(p)) {\n            p->level4_comp_csum = TCPV6Checksum(p->ip6h->s_ip6_addrs,\n                                                (uint16_t *)p->tcph,\n                                                (p->payload_len +\n                                                    TCP_GET_HLEN(p)),\n                                                p->tcph->th_sum);\n        }\n    }\n\n    if (p->level4_comp_csum != 0) {\n        ret = 0;\n        if (p->livedev) {\n            (void) SC_ATOMIC_ADD(p->livedev->invalid_checksums, 1);\n        } else if (p->pcap_cnt) {\n            PcapIncreaseInvalidChecksum();\n        }\n    }\n\n    return ret;\n}\n\n/** \\internal\n *  \\brief check if a packet is a valid stream started\n *  \\retval bool true/false */\nstatic int TcpSessionPacketIsStreamStarter(const Packet *p)\n{\n    if (p->tcph->th_flags == TH_SYN) {\n        SCLogDebug(\"packet %\"PRIu64\" is a stream starter: %02x\", p->pcap_cnt, p->tcph->th_flags);\n        return 1;\n    }\n\n    if (stream_config.midstream || stream_config.async_oneside == TRUE) {\n        if (p->tcph->th_flags == (TH_SYN|TH_ACK)) {\n            SCLogDebug(\"packet %\"PRIu64\" is a midstream stream starter: %02x\", p->pcap_cnt, p->tcph->th_flags);\n            return 1;\n        }\n    }\n    return 0;\n}\n\n/** \\internal\n *  \\brief Check if Flow and TCP SSN allow this flow/tuple to be reused\n *  \\retval bool true yes reuse, false no keep tracking old ssn */\nstatic int TcpSessionReuseDoneEnoughSyn(const Packet *p, const Flow *f, const TcpSession *ssn)\n{\n    if (FlowGetPacketDirection(f, p) == TOSERVER) {\n        if (ssn == NULL) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p null. No reuse.\", p->pcap_cnt, ssn);\n            return 0;\n        }\n        if (SEQ_EQ(ssn->client.isn, TCP_GET_SEQ(p))) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p. Packet SEQ == Stream ISN. Retransmission. Don't reuse.\", p->pcap_cnt, ssn);\n            return 0;\n        }\n        if (ssn->state >= TCP_LAST_ACK) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p state >= TCP_LAST_ACK (%u). Reuse.\", p->pcap_cnt, ssn, ssn->state);\n            return 1;\n        }\n        if (ssn->state == TCP_NONE) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p state == TCP_NONE (%u). Reuse.\", p->pcap_cnt, ssn, ssn->state);\n            return 1;\n        }\n        if (ssn->state < TCP_LAST_ACK) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p state < TCP_LAST_ACK (%u). Don't reuse.\", p->pcap_cnt, ssn, ssn->state);\n            return 0;\n        }\n\n    } else {\n        if (ssn == NULL) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p null. Reuse.\", p->pcap_cnt, ssn);\n            return 1;\n        }\n        if (ssn->state >= TCP_LAST_ACK) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p state >= TCP_LAST_ACK (%u). Reuse.\", p->pcap_cnt, ssn, ssn->state);\n            return 1;\n        }\n        if (ssn->state == TCP_NONE) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p state == TCP_NONE (%u). Reuse.\", p->pcap_cnt, ssn, ssn->state);\n            return 1;\n        }\n        if (ssn->state < TCP_LAST_ACK) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p state < TCP_LAST_ACK (%u). Don't reuse.\", p->pcap_cnt, ssn, ssn->state);\n            return 0;\n        }\n    }\n\n    SCLogDebug(\"default: how did we get here?\");\n    return 0;\n}\n\n/** \\internal\n *  \\brief check if ssn is done enough for reuse by syn/ack\n *  \\note should only be called if midstream is enabled\n */\nstatic int TcpSessionReuseDoneEnoughSynAck(const Packet *p, const Flow *f, const TcpSession *ssn)\n{\n    if (FlowGetPacketDirection(f, p) == TOCLIENT) {\n        if (ssn == NULL) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p null. No reuse.\", p->pcap_cnt, ssn);\n            return 0;\n        }\n        if (SEQ_EQ(ssn->server.isn, TCP_GET_SEQ(p))) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p. Packet SEQ == Stream ISN. Retransmission. Don't reuse.\", p->pcap_cnt, ssn);\n            return 0;\n        }\n        if (ssn->state >= TCP_LAST_ACK) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p state >= TCP_LAST_ACK (%u). Reuse.\", p->pcap_cnt, ssn, ssn->state);\n            return 1;\n        }\n        if (ssn->state == TCP_NONE) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p state == TCP_NONE (%u). Reuse.\", p->pcap_cnt, ssn, ssn->state);\n            return 1;\n        }\n        if (ssn->state < TCP_LAST_ACK) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p state < TCP_LAST_ACK (%u). Don't reuse.\", p->pcap_cnt, ssn, ssn->state);\n            return 0;\n        }\n\n    } else {\n        if (ssn == NULL) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p null. Reuse.\", p->pcap_cnt, ssn);\n            return 1;\n        }\n        if (ssn->state >= TCP_LAST_ACK) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p state >= TCP_LAST_ACK (%u). Reuse.\", p->pcap_cnt, ssn, ssn->state);\n            return 1;\n        }\n        if (ssn->state == TCP_NONE) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p state == TCP_NONE (%u). Reuse.\", p->pcap_cnt, ssn, ssn->state);\n            return 1;\n        }\n        if (ssn->state < TCP_LAST_ACK) {\n            SCLogDebug(\"steam starter packet %\"PRIu64\", ssn %p state < TCP_LAST_ACK (%u). Don't reuse.\", p->pcap_cnt, ssn, ssn->state);\n            return 0;\n        }\n    }\n\n    SCLogDebug(\"default: how did we get here?\");\n    return 0;\n}\n\n/** \\brief Check if SSN is done enough for reuse\n *\n *  Reuse means a new TCP session reuses the tuple (flow in suri)\n *\n *  \\retval bool true if ssn can be reused, false if not */\nstatic int TcpSessionReuseDoneEnough(const Packet *p, const Flow *f, const TcpSession *ssn)\n{\n    if (p->tcph->th_flags == TH_SYN) {\n        return TcpSessionReuseDoneEnoughSyn(p, f, ssn);\n    }\n\n    if (stream_config.midstream || stream_config.async_oneside == TRUE) {\n        if (p->tcph->th_flags == (TH_SYN|TH_ACK)) {\n            return TcpSessionReuseDoneEnoughSynAck(p, f, ssn);\n        }\n    }\n\n    return 0;\n}\n\nint TcpSessionPacketSsnReuse(const Packet *p, const Flow *f, const void *tcp_ssn)\n{\n    if (p->proto == IPPROTO_TCP && p->tcph != NULL) {\n        if (TcpSessionPacketIsStreamStarter(p) == 1) {\n            if (TcpSessionReuseDoneEnough(p, f, tcp_ssn) == 1) {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nTmEcode StreamTcp (ThreadVars *tv, Packet *p, void *data, PacketQueueNoLock *pq)\n{\n    StreamTcpThread *stt = (StreamTcpThread *)data;\n\n    SCLogDebug(\"p->pcap_cnt %\" PRIu64 \" direction %s\", p->pcap_cnt,\n            p->flow ? (FlowGetPacketDirection(p->flow, p) == TOSERVER ? \"toserver\" : \"toclient\")\n                    : \"noflow\");\n\n    if (!(PKT_IS_TCP(p))) {\n        return TM_ECODE_OK;\n    }\n\n    if (p->flow == NULL) {\n        StatsIncr(tv, stt->counter_tcp_no_flow);\n        return TM_ECODE_OK;\n    }\n\n    /* only TCP packets with a flow from here */\n\n    if (!(p->flags & PKT_PSEUDO_STREAM_END)) {\n        if (stream_config.flags & STREAMTCP_INIT_FLAG_CHECKSUM_VALIDATION) {\n            if (StreamTcpValidateChecksum(p) == 0) {\n                StatsIncr(tv, stt->counter_tcp_invalid_checksum);\n                return TM_ECODE_OK;\n            }\n        } else {\n            p->flags |= PKT_IGNORE_CHECKSUM;\n        }\n    } else {\n        p->flags |= PKT_IGNORE_CHECKSUM; //TODO check that this is set at creation\n    }\n    AppLayerProfilingReset(stt->ra_ctx->app_tctx);\n\n    (void)StreamTcpPacket(tv, p, stt, pq);\n\n    return TM_ECODE_OK;\n}\n\nTmEcode StreamTcpThreadInit(ThreadVars *tv, void *initdata, void **data)\n{\n    SCEnter();\n    StreamTcpThread *stt = SCMalloc(sizeof(StreamTcpThread));\n    if (unlikely(stt == NULL))\n        SCReturnInt(TM_ECODE_FAILED);\n    memset(stt, 0, sizeof(StreamTcpThread));\n    stt->ssn_pool_id = -1;\n\n    *data = (void *)stt;\n\n    stt->counter_tcp_sessions = StatsRegisterCounter(\"tcp.sessions\", tv);\n    stt->counter_tcp_ssn_memcap = StatsRegisterCounter(\"tcp.ssn_memcap_drop\", tv);\n    stt->counter_tcp_pseudo = StatsRegisterCounter(\"tcp.pseudo\", tv);\n    stt->counter_tcp_pseudo_failed = StatsRegisterCounter(\"tcp.pseudo_failed\", tv);\n    stt->counter_tcp_invalid_checksum = StatsRegisterCounter(\"tcp.invalid_checksum\", tv);\n    stt->counter_tcp_no_flow = StatsRegisterCounter(\"tcp.no_flow\", tv);\n    stt->counter_tcp_syn = StatsRegisterCounter(\"tcp.syn\", tv);\n    stt->counter_tcp_synack = StatsRegisterCounter(\"tcp.synack\", tv);\n    stt->counter_tcp_rst = StatsRegisterCounter(\"tcp.rst\", tv);\n    stt->counter_tcp_midstream_pickups = StatsRegisterCounter(\"tcp.midstream_pickups\", tv);\n    stt->counter_tcp_wrong_thread = StatsRegisterCounter(\"tcp.pkt_on_wrong_thread\", tv);\n\n    /* init reassembly ctx */\n    stt->ra_ctx = StreamTcpReassembleInitThreadCtx(tv);\n    if (stt->ra_ctx == NULL)\n        SCReturnInt(TM_ECODE_FAILED);\n\n    stt->ra_ctx->counter_tcp_segment_memcap = StatsRegisterCounter(\"tcp.segment_memcap_drop\", tv);\n    stt->ra_ctx->counter_tcp_stream_depth = StatsRegisterCounter(\"tcp.stream_depth_reached\", tv);\n    stt->ra_ctx->counter_tcp_reass_gap = StatsRegisterCounter(\"tcp.reassembly_gap\", tv);\n    stt->ra_ctx->counter_tcp_reass_overlap = StatsRegisterCounter(\"tcp.overlap\", tv);\n    stt->ra_ctx->counter_tcp_reass_overlap_diff_data = StatsRegisterCounter(\"tcp.overlap_diff_data\", tv);\n\n    stt->ra_ctx->counter_tcp_reass_data_normal_fail = StatsRegisterCounter(\"tcp.insert_data_normal_fail\", tv);\n    stt->ra_ctx->counter_tcp_reass_data_overlap_fail = StatsRegisterCounter(\"tcp.insert_data_overlap_fail\", tv);\n    stt->ra_ctx->counter_tcp_reass_list_fail = StatsRegisterCounter(\"tcp.insert_list_fail\", tv);\n\n\n    SCLogDebug(\"StreamTcp thread specific ctx online at %p, reassembly ctx %p\",\n                stt, stt->ra_ctx);\n\n    SCMutexLock(&ssn_pool_mutex);\n    if (ssn_pool == NULL) {\n        ssn_pool = PoolThreadInit(1, /* thread */\n                0, /* unlimited */\n                stream_config.prealloc_sessions,\n                sizeof(TcpSession),\n                StreamTcpSessionPoolAlloc,\n                StreamTcpSessionPoolInit, NULL,\n                StreamTcpSessionPoolCleanup, NULL);\n        stt->ssn_pool_id = 0;\n        SCLogDebug(\"pool size %d, thread ssn_pool_id %d\", PoolThreadSize(ssn_pool), stt->ssn_pool_id);\n    } else {\n        /* grow ssn_pool until we have a element for our thread id */\n        stt->ssn_pool_id = PoolThreadExpand(ssn_pool);\n        SCLogDebug(\"pool size %d, thread ssn_pool_id %d\", PoolThreadSize(ssn_pool), stt->ssn_pool_id);\n    }\n    SCMutexUnlock(&ssn_pool_mutex);\n    if (stt->ssn_pool_id < 0 || ssn_pool == NULL) {\n        SCLogError(SC_ERR_MEM_ALLOC, \"failed to setup/expand stream session pool. Expand stream.memcap?\");\n        SCReturnInt(TM_ECODE_FAILED);\n    }\n\n    SCReturnInt(TM_ECODE_OK);\n}\n\nTmEcode StreamTcpThreadDeinit(ThreadVars *tv, void *data)\n{\n    SCEnter();\n    StreamTcpThread *stt = (StreamTcpThread *)data;\n    if (stt == NULL) {\n        return TM_ECODE_OK;\n    }\n\n    /* XXX */\n\n    /* free reassembly ctx */\n    StreamTcpReassembleFreeThreadCtx(stt->ra_ctx);\n\n    /* clear memory */\n    memset(stt, 0, sizeof(StreamTcpThread));\n\n    SCFree(stt);\n    SCReturnInt(TM_ECODE_OK);\n}\n\n/**\n *  \\brief   Function to check the validity of the RST packets based on the\n *           target OS of the given packet.\n *\n *  \\param   ssn    TCP session to which the given packet belongs\n *  \\param   p      Packet which has to be checked for its validity\n *\n *  \\retval 0 unacceptable RST\n *  \\retval 1 acceptable RST\n *\n *  WebSense sends RST packets that are:\n *  - RST flag, win 0, ack 0, seq = nextseq\n *\n */\n\nstatic int StreamTcpValidateRst(TcpSession *ssn, Packet *p)\n{\n    uint8_t os_policy;\n\n    if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {\n        if (!StreamTcpValidateTimestamp(ssn, p)) {\n            SCReturnInt(0);\n        }\n    }\n\n    /* Set up the os_policy to be used in validating the RST packets based on\n       target system */\n    if (PKT_IS_TOSERVER(p)) {\n        if (ssn->server.os_policy == 0)\n            StreamTcpSetOSPolicy(&ssn->server, p);\n\n        os_policy = ssn->server.os_policy;\n\n        if (p->tcph->th_flags & TH_ACK &&\n                TCP_GET_ACK(p) && StreamTcpValidateAck(ssn, &ssn->server, p) == -1) {\n            SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n            StreamTcpSetEvent(p, STREAM_RST_INVALID_ACK);\n            SCReturnInt(0);\n        }\n\n    } else {\n        if (ssn->client.os_policy == 0)\n            StreamTcpSetOSPolicy(&ssn->client, p);\n\n        os_policy = ssn->client.os_policy;\n\n        if (p->tcph->th_flags & TH_ACK &&\n                TCP_GET_ACK(p) && StreamTcpValidateAck(ssn, &ssn->client, p) == -1) {\n            SCLogDebug(\"ssn %p: rejecting because of invalid ack value\", ssn);\n            StreamTcpSetEvent(p, STREAM_RST_INVALID_ACK);\n            SCReturnInt(0);\n        }\n    }\n\n    /* RFC 2385 md5 signature header or RFC 5925 TCP AO headerpresent. Since we can't\n     * validate these (requires key that is set/transfered out of band), we can't know\n     * if the RST will be accepted or rejected by the end host. We accept it, but keep\n     * tracking if the sender of it ignores it, which would be a sign of injection. */\n    if (p->tcpvars.md5_option_present || p->tcpvars.ao_option_present) {\n        TcpStream *receiver_stream;\n        if (PKT_IS_TOSERVER(p)) {\n            receiver_stream = &ssn->server;\n        } else {\n            receiver_stream = &ssn->client;\n        }\n        SCLogDebug(\"ssn %p: setting STREAMTCP_STREAM_FLAG_RST_RECV on receiver stream\", ssn);\n        receiver_stream->flags |= STREAMTCP_STREAM_FLAG_RST_RECV;\n    }\n\n    if (ssn->flags & STREAMTCP_FLAG_ASYNC) {\n        if (PKT_IS_TOSERVER(p)) {\n            if (SEQ_GEQ(TCP_GET_SEQ(p), ssn->client.next_seq)) {\n                SCLogDebug(\"ssn %p: ASYNC accept RST\", ssn);\n                return 1;\n            }\n        } else {\n            if (SEQ_GEQ(TCP_GET_SEQ(p), ssn->server.next_seq)) {\n                SCLogDebug(\"ssn %p: ASYNC accept RST\", ssn);\n                return 1;\n            }\n        }\n        SCLogDebug(\"ssn %p: ASYNC reject RST\", ssn);\n        return 0;\n    }\n\n    switch (os_policy) {\n        case OS_POLICY_HPUX11:\n            if(PKT_IS_TOSERVER(p)){\n                if(SEQ_GEQ(TCP_GET_SEQ(p), ssn->client.next_seq)) {\n                    SCLogDebug(\"reset is Valid! Packet SEQ: %\" PRIu32 \"\",\n                                TCP_GET_SEQ(p));\n                    return 1;\n                } else {\n                    SCLogDebug(\"reset is not Valid! Packet SEQ: %\" PRIu32 \" \"\n                               \"and server SEQ: %\" PRIu32 \"\", TCP_GET_SEQ(p),\n                                ssn->client.next_seq);\n                    return 0;\n                }\n            } else { /* implied to client */\n                if(SEQ_GEQ(TCP_GET_SEQ(p), ssn->server.next_seq)) {\n                    SCLogDebug(\"reset is valid! Packet SEQ: %\" PRIu32 \"\",\n                                TCP_GET_SEQ(p));\n                    return 1;\n                } else {\n                    SCLogDebug(\"reset is not valid! Packet SEQ: %\" PRIu32 \" \"\n                               \"and client SEQ: %\" PRIu32 \"\", TCP_GET_SEQ(p),\n                                ssn->server.next_seq);\n                    return 0;\n                }\n            }\n            break;\n        case OS_POLICY_OLD_LINUX:\n        case OS_POLICY_LINUX:\n        case OS_POLICY_SOLARIS:\n            if(PKT_IS_TOSERVER(p)){\n                if(SEQ_GEQ((TCP_GET_SEQ(p)+p->payload_len),\n                            ssn->client.last_ack))\n                { /*window base is needed !!*/\n                    if(SEQ_LT(TCP_GET_SEQ(p),\n                              (ssn->client.next_seq + ssn->client.window)))\n                    {\n                        SCLogDebug(\"reset is Valid! Packet SEQ: %\" PRIu32 \"\",\n                                    TCP_GET_SEQ(p));\n                        return 1;\n                    }\n                } else {\n                    SCLogDebug(\"reset is not valid! Packet SEQ: %\" PRIu32 \" and\"\n                               \" server SEQ: %\" PRIu32 \"\", TCP_GET_SEQ(p),\n                                ssn->client.next_seq);\n                    return 0;\n                }\n            } else { /* implied to client */\n                if(SEQ_GEQ((TCP_GET_SEQ(p) + p->payload_len),\n                            ssn->server.last_ack))\n                { /*window base is needed !!*/\n                    if(SEQ_LT(TCP_GET_SEQ(p),\n                                (ssn->server.next_seq + ssn->server.window)))\n                    {\n                        SCLogDebug(\"reset is Valid! Packet SEQ: %\" PRIu32 \"\",\n                                    TCP_GET_SEQ(p));\n                        return 1;\n                    }\n                } else {\n                    SCLogDebug(\"reset is not valid! Packet SEQ: %\" PRIu32 \" and\"\n                               \" client SEQ: %\" PRIu32 \"\", TCP_GET_SEQ(p),\n                                 ssn->server.next_seq);\n                    return 0;\n                }\n            }\n            break;\n        default:\n        case OS_POLICY_BSD:\n        case OS_POLICY_FIRST:\n        case OS_POLICY_HPUX10:\n        case OS_POLICY_IRIX:\n        case OS_POLICY_MACOS:\n        case OS_POLICY_LAST:\n        case OS_POLICY_WINDOWS:\n        case OS_POLICY_WINDOWS2K3:\n        case OS_POLICY_VISTA:\n            if(PKT_IS_TOSERVER(p)) {\n                if(SEQ_EQ(TCP_GET_SEQ(p), ssn->client.next_seq)) {\n                    SCLogDebug(\"reset is valid! Packet SEQ: %\" PRIu32 \"\",\n                               TCP_GET_SEQ(p));\n                    return 1;\n                } else {\n                    SCLogDebug(\"reset is not valid! Packet SEQ: %\" PRIu32 \" \"\n                               \"and server SEQ: %\" PRIu32 \"\", TCP_GET_SEQ(p),\n                               ssn->client.next_seq);\n                    return 0;\n                }\n            } else { /* implied to client */\n                if (SEQ_EQ(TCP_GET_SEQ(p), ssn->server.next_seq)) {\n                    SCLogDebug(\"reset is valid! Packet SEQ: %\" PRIu32 \" Stream %u\",\n                                TCP_GET_SEQ(p), ssn->server.next_seq);\n                    return 1;\n                } else {\n                    SCLogDebug(\"reset is not valid! Packet SEQ: %\" PRIu32 \" and\"\n                               \" client SEQ: %\" PRIu32 \"\",\n                               TCP_GET_SEQ(p), ssn->server.next_seq);\n                    return 0;\n                }\n            }\n            break;\n    }\n    return 0;\n}\n\n/**\n *  \\brief Function to check the validity of the received timestamp based on\n *         the target OS of the given stream.\n *\n *  It's passive except for:\n *  1. it sets the os policy on the stream if necessary\n *  2. it sets an event in the packet if necessary\n *\n *  \\param ssn TCP session to which the given packet belongs\n *  \\param p Packet which has to be checked for its validity\n *\n *  \\retval 1 if the timestamp is valid\n *  \\retval 0 if the timestamp is invalid\n */\nstatic int StreamTcpValidateTimestamp (TcpSession *ssn, Packet *p)\n{\n    SCEnter();\n\n    TcpStream *sender_stream;\n    TcpStream *receiver_stream;\n    uint8_t ret = 1;\n    uint8_t check_ts = 1;\n\n    if (PKT_IS_TOSERVER(p)) {\n        sender_stream = &ssn->client;\n        receiver_stream = &ssn->server;\n    } else {\n        sender_stream = &ssn->server;\n        receiver_stream = &ssn->client;\n    }\n\n    /* Set up the os_policy to be used in validating the timestamps based on\n       the target system */\n    if (receiver_stream->os_policy == 0) {\n        StreamTcpSetOSPolicy(receiver_stream, p);\n    }\n\n    if (TCP_HAS_TS(p)) {\n        uint32_t ts = TCP_GET_TSVAL(p);\n        uint32_t last_pkt_ts = sender_stream->last_pkt_ts;\n        uint32_t last_ts = sender_stream->last_ts;\n\n        if (sender_stream->flags & STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP) {\n            /* The 3whs used the timestamp with 0 value. */\n            switch (receiver_stream->os_policy) {\n                case OS_POLICY_LINUX:\n                case OS_POLICY_WINDOWS2K3:\n                    /* Linux and windows 2003 does not allow the use of 0 as\n                     * timestamp in the 3whs. */\n                    check_ts = 0;\n                    break;\n\n                case OS_POLICY_OLD_LINUX:\n                case OS_POLICY_WINDOWS:\n                case OS_POLICY_VISTA:\n                    if (SEQ_EQ(sender_stream->next_seq, TCP_GET_SEQ(p))) {\n                        last_ts = ts;\n                        check_ts = 0; /*next packet will be checked for validity\n                                        and stream TS has been updated with this\n                                        one.*/\n                    }\n                    break;\n            }\n        }\n\n        if (receiver_stream->os_policy == OS_POLICY_HPUX11) {\n            /* HPUX11 ignores the timestamp of out of order packets */\n            if (!SEQ_EQ(sender_stream->next_seq, TCP_GET_SEQ(p)))\n                check_ts = 0;\n        }\n\n        if (ts == 0) {\n            switch (receiver_stream->os_policy) {\n                case OS_POLICY_OLD_LINUX:\n                case OS_POLICY_WINDOWS:\n                case OS_POLICY_WINDOWS2K3:\n                case OS_POLICY_VISTA:\n                case OS_POLICY_SOLARIS:\n                    /* Old Linux and windows allowed packet with 0 timestamp. */\n                    break;\n                default:\n                    /* other OS simply drop the packet with 0 timestamp, when\n                     * 3whs has valid timestamp*/\n                    goto invalid;\n            }\n        }\n\n        if (check_ts) {\n            int32_t result = 0;\n\n            SCLogDebug(\"ts %\"PRIu32\", last_ts %\"PRIu32\"\", ts, last_ts);\n\n            if (receiver_stream->os_policy == OS_POLICY_LINUX) {\n                /* Linux accepts TS which are off by one.*/\n                result = (int32_t) ((ts - last_ts) + 1);\n            } else {\n                result = (int32_t) (ts - last_ts);\n            }\n\n            SCLogDebug(\"result %\"PRIi32\", p->ts.tv_sec %\"PRIuMAX\"\", result, (uintmax_t)p->ts.tv_sec);\n\n            if (last_pkt_ts == 0 &&\n                    (ssn->flags & STREAMTCP_FLAG_MIDSTREAM))\n            {\n                last_pkt_ts = p->ts.tv_sec;\n            }\n\n            if (result < 0) {\n                SCLogDebug(\"timestamp is not valid last_ts \"\n                           \"%\" PRIu32 \" p->tcpvars->ts %\" PRIu32 \" result \"\n                           \"%\" PRId32 \"\", last_ts, ts, result);\n                /* candidate for rejection */\n                ret = 0;\n            } else if ((sender_stream->last_ts != 0) &&\n                        (((uint32_t) p->ts.tv_sec) >\n                            last_pkt_ts + PAWS_24DAYS))\n            {\n                SCLogDebug(\"packet is not valid last_pkt_ts \"\n                           \"%\" PRIu32 \" p->ts.tv_sec %\" PRIu32 \"\",\n                            last_pkt_ts, (uint32_t) p->ts.tv_sec);\n                /* candidate for rejection */\n                ret = 0;\n            }\n\n            if (ret == 0) {\n                /* if the timestamp of packet is not valid then, check if the\n                 * current stream timestamp is not so old. if so then we need to\n                 * accept the packet and update the stream->last_ts (RFC 1323)*/\n                if ((SEQ_EQ(sender_stream->next_seq, TCP_GET_SEQ(p))) &&\n                        (((uint32_t) p->ts.tv_sec > (last_pkt_ts + PAWS_24DAYS))))\n                {\n                    SCLogDebug(\"timestamp considered valid anyway\");\n                } else {\n                    goto invalid;\n                }\n            }\n        }\n    }\n\n    SCReturnInt(1);\n\ninvalid:\n    StreamTcpSetEvent(p, STREAM_PKT_INVALID_TIMESTAMP);\n    SCReturnInt(0);\n}\n\n/**\n *  \\brief Function to check the validity of the received timestamp based on\n *         the target OS of the given stream and update the session.\n *\n *  \\param ssn TCP session to which the given packet belongs\n *  \\param p Packet which has to be checked for its validity\n *\n *  \\retval 1 if the timestamp is valid\n *  \\retval 0 if the timestamp is invalid\n */\nstatic int StreamTcpHandleTimestamp (TcpSession *ssn, Packet *p)\n{\n    SCEnter();\n\n    TcpStream *sender_stream;\n    TcpStream *receiver_stream;\n    uint8_t ret = 1;\n    uint8_t check_ts = 1;\n\n    if (PKT_IS_TOSERVER(p)) {\n        sender_stream = &ssn->client;\n        receiver_stream = &ssn->server;\n    } else {\n        sender_stream = &ssn->server;\n        receiver_stream = &ssn->client;\n    }\n\n    /* Set up the os_policy to be used in validating the timestamps based on\n       the target system */\n    if (receiver_stream->os_policy == 0) {\n        StreamTcpSetOSPolicy(receiver_stream, p);\n    }\n\n    if (TCP_HAS_TS(p)) {\n        uint32_t ts = TCP_GET_TSVAL(p);\n\n        if (sender_stream->flags & STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP) {\n            /* The 3whs used the timestamp with 0 value. */\n            switch (receiver_stream->os_policy) {\n                case OS_POLICY_LINUX:\n                case OS_POLICY_WINDOWS2K3:\n                    /* Linux and windows 2003 does not allow the use of 0 as\n                     * timestamp in the 3whs. */\n                    ssn->flags &= ~STREAMTCP_FLAG_TIMESTAMP;\n                    check_ts = 0;\n                    break;\n\n                case OS_POLICY_OLD_LINUX:\n                case OS_POLICY_WINDOWS:\n                case OS_POLICY_VISTA:\n                    sender_stream->flags &= ~STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n                    if (SEQ_EQ(sender_stream->next_seq, TCP_GET_SEQ(p))) {\n                        sender_stream->last_ts = ts;\n                        check_ts = 0; /*next packet will be checked for validity\n                                        and stream TS has been updated with this\n                                        one.*/\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        if (receiver_stream->os_policy == OS_POLICY_HPUX11) {\n            /*HPUX11 ignores the timestamp of out of order packets*/\n            if (!SEQ_EQ(sender_stream->next_seq, TCP_GET_SEQ(p)))\n                check_ts = 0;\n        }\n\n        if (ts == 0) {\n            switch (receiver_stream->os_policy) {\n                case OS_POLICY_OLD_LINUX:\n                case OS_POLICY_WINDOWS:\n                case OS_POLICY_WINDOWS2K3:\n                case OS_POLICY_VISTA:\n                case OS_POLICY_SOLARIS:\n                    /* Old Linux and windows allowed packet with 0 timestamp. */\n                    break;\n                default:\n                    /* other OS simply drop the packet with 0 timestamp, when\n                     * 3whs has valid timestamp*/\n                    goto invalid;\n            }\n        }\n\n        if (check_ts) {\n            int32_t result = 0;\n\n            SCLogDebug(\"ts %\"PRIu32\", last_ts %\"PRIu32\"\", ts, sender_stream->last_ts);\n\n            if (receiver_stream->os_policy == OS_POLICY_LINUX) {\n                /* Linux accepts TS which are off by one.*/\n                result = (int32_t) ((ts - sender_stream->last_ts) + 1);\n            } else {\n                result = (int32_t) (ts - sender_stream->last_ts);\n            }\n\n            SCLogDebug(\"result %\"PRIi32\", p->ts.tv_sec %\"PRIuMAX\"\", result, (uintmax_t)p->ts.tv_sec);\n\n            if (sender_stream->last_pkt_ts == 0 &&\n                    (ssn->flags & STREAMTCP_FLAG_MIDSTREAM))\n            {\n                sender_stream->last_pkt_ts = p->ts.tv_sec;\n            }\n\n            if (result < 0) {\n                SCLogDebug(\"timestamp is not valid sender_stream->last_ts \"\n                           \"%\" PRIu32 \" p->tcpvars->ts %\" PRIu32 \" result \"\n                           \"%\" PRId32 \"\", sender_stream->last_ts, ts, result);\n                /* candidate for rejection */\n                ret = 0;\n            } else if ((sender_stream->last_ts != 0) &&\n                        (((uint32_t) p->ts.tv_sec) >\n                            sender_stream->last_pkt_ts + PAWS_24DAYS))\n            {\n                SCLogDebug(\"packet is not valid sender_stream->last_pkt_ts \"\n                           \"%\" PRIu32 \" p->ts.tv_sec %\" PRIu32 \"\",\n                            sender_stream->last_pkt_ts, (uint32_t) p->ts.tv_sec);\n                /* candidate for rejection */\n                ret = 0;\n            }\n\n            if (ret == 1) {\n                /* Update the timestamp and last seen packet time for this\n                 * stream */\n                if (SEQ_EQ(sender_stream->next_seq, TCP_GET_SEQ(p)))\n                    sender_stream->last_ts = ts;\n\n                sender_stream->last_pkt_ts = p->ts.tv_sec;\n\n            } else if (ret == 0) {\n                /* if the timestamp of packet is not valid then, check if the\n                 * current stream timestamp is not so old. if so then we need to\n                 * accept the packet and update the stream->last_ts (RFC 1323)*/\n                if ((SEQ_EQ(sender_stream->next_seq, TCP_GET_SEQ(p))) &&\n                        (((uint32_t) p->ts.tv_sec > (sender_stream->last_pkt_ts + PAWS_24DAYS))))\n                {\n                    sender_stream->last_ts = ts;\n                    sender_stream->last_pkt_ts = p->ts.tv_sec;\n\n                    SCLogDebug(\"timestamp considered valid anyway\");\n                } else {\n                    goto invalid;\n                }\n            }\n        }\n    } else {\n        /* Solaris stops using timestamps if a packet is received\n           without a timestamp and timestamps were used on that stream. */\n        if (receiver_stream->os_policy == OS_POLICY_SOLARIS)\n            ssn->flags &= ~STREAMTCP_FLAG_TIMESTAMP;\n    }\n\n    SCReturnInt(1);\n\ninvalid:\n    StreamTcpSetEvent(p, STREAM_PKT_INVALID_TIMESTAMP);\n    SCReturnInt(0);\n}\n\n/**\n *  \\brief  Function to test the received ACK values against the stream window\n *          and previous ack value. ACK values should be higher than previous\n *          ACK value and less than the next_win value.\n *\n *  \\param  ssn     TcpSession for state access\n *  \\param  stream  TcpStream of which last_ack needs to be tested\n *  \\param  p       Packet which is used to test the last_ack\n *\n *  \\retval 0  ACK is valid, last_ack is updated if ACK was higher\n *  \\retval -1 ACK is invalid\n */\nstatic inline int StreamTcpValidateAck(TcpSession *ssn, TcpStream *stream, Packet *p)\n{\n    SCEnter();\n\n    if (!(p->tcph->th_flags & TH_ACK))\n        SCReturnInt(0);\n\n    uint32_t ack = TCP_GET_ACK(p);\n\n    /* fast track */\n    if (SEQ_GT(ack, stream->last_ack) && SEQ_LEQ(ack, stream->next_win))\n    {\n        SCLogDebug(\"ACK in bounds\");\n        SCReturnInt(0);\n    }\n    /* fast track */\n    else if (SEQ_EQ(ack, stream->last_ack)) {\n        SCLogDebug(\"pkt ACK %\"PRIu32\" == stream last ACK %\"PRIu32, TCP_GET_ACK(p), stream->last_ack);\n        SCReturnInt(0);\n    }\n\n    /* exception handling */\n    if (SEQ_LT(ack, stream->last_ack)) {\n        SCLogDebug(\"pkt ACK %\"PRIu32\" < stream last ACK %\"PRIu32, TCP_GET_ACK(p), stream->last_ack);\n\n        /* This is an attempt to get a 'left edge' value that we can check against.\n         * It doesn't work when the window is 0, need to think of a better way. */\n\n        if (stream->window != 0 && SEQ_LT(ack, (stream->last_ack - stream->window))) {\n            SCLogDebug(\"ACK %\"PRIu32\" is before last_ack %\"PRIu32\" - window \"\n                    \"%\"PRIu32\" = %\"PRIu32, ack, stream->last_ack,\n                    stream->window, stream->last_ack - stream->window);\n            goto invalid;\n        }\n\n        SCReturnInt(0);\n    }\n\n    /* no further checks possible for ASYNC */\n    if ((ssn->flags & STREAMTCP_FLAG_ASYNC) != 0) {\n        SCReturnInt(0);\n    }\n\n    if (ssn->state > TCP_SYN_SENT && SEQ_GT(ack, stream->next_win)) {\n        SCLogDebug(\"ACK %\"PRIu32\" is after next_win %\"PRIu32, ack, stream->next_win);\n        goto invalid;\n    /* a toclient RST as a reponse to SYN, next_win is 0, ack will be isn+1, just like\n     * the syn ack */\n    } else if (ssn->state == TCP_SYN_SENT && PKT_IS_TOCLIENT(p) &&\n            p->tcph->th_flags & TH_RST &&\n            SEQ_EQ(ack, stream->isn + 1)) {\n        SCReturnInt(0);\n    }\n\n    SCLogDebug(\"default path leading to invalid: ACK %\"PRIu32\", last_ack %\"PRIu32\n        \" next_win %\"PRIu32, ack, stream->last_ack, stream->next_win);\ninvalid:\n    StreamTcpSetEvent(p, STREAM_PKT_INVALID_ACK);\n    SCReturnInt(-1);\n}\n\n/** \\brief update reassembly progress\n\n * \\param ssn TCP Session\n * \\param direction direction to set the flag in: 0 toserver, 1 toclient\n */\nvoid StreamTcpUpdateAppLayerProgress(TcpSession *ssn, char direction,\n        const uint32_t progress)\n{\n    if (direction) {\n        ssn->server.app_progress_rel += progress;\n    } else {\n        ssn->client.app_progress_rel += progress;\n    }\n}\n\n/** \\brief disable reassembly\n\n *  Disable app layer and set raw inspect to no longer accept new data.\n *  Stream engine will then fully disable raw after last inspection.\n *\n * \\param ssn TCP Session to set the flag in\n * \\param direction direction to set the flag in: 0 toserver, 1 toclient\n */\nvoid StreamTcpSetSessionNoReassemblyFlag(TcpSession *ssn, char direction)\n{\n    ssn->flags |= STREAMTCP_FLAG_APP_LAYER_DISABLED;\n    if (direction) {\n        ssn->server.flags |= STREAMTCP_STREAM_FLAG_NEW_RAW_DISABLED;\n    } else {\n        ssn->client.flags |= STREAMTCP_STREAM_FLAG_NEW_RAW_DISABLED;\n    }\n}\n\n/** \\brief  Set the No reassembly flag for the given direction in given TCP\n *          session.\n *\n * \\param ssn TCP Session to set the flag in\n * \\param direction direction to set the flag in: 0 toserver, 1 toclient\n */\nvoid StreamTcpSetDisableRawReassemblyFlag(TcpSession *ssn, char direction)\n{\n    direction ? (ssn->server.flags |= STREAMTCP_STREAM_FLAG_NEW_RAW_DISABLED) :\n                (ssn->client.flags |= STREAMTCP_STREAM_FLAG_NEW_RAW_DISABLED);\n}\n\n/** \\brief enable bypass\n *\n * \\param ssn TCP Session to set the flag in\n * \\param direction direction to set the flag in: 0 toserver, 1 toclient\n */\nvoid StreamTcpSetSessionBypassFlag(TcpSession *ssn)\n{\n    ssn->flags |= STREAMTCP_FLAG_BYPASS;\n}\n\n#define PSEUDO_PKT_SET_IPV4HDR(nipv4h,ipv4h) do { \\\n        IPV4_SET_RAW_VER(nipv4h, IPV4_GET_RAW_VER(ipv4h)); \\\n        IPV4_SET_RAW_HLEN(nipv4h, IPV4_GET_RAW_HLEN(ipv4h)); \\\n        IPV4_SET_RAW_IPLEN(nipv4h, IPV4_GET_RAW_IPLEN(ipv4h)); \\\n        IPV4_SET_RAW_IPTOS(nipv4h, IPV4_GET_RAW_IPTOS(ipv4h)); \\\n        IPV4_SET_RAW_IPPROTO(nipv4h, IPV4_GET_RAW_IPPROTO(ipv4h)); \\\n        (nipv4h)->s_ip_src = IPV4_GET_RAW_IPDST(ipv4h); \\\n        (nipv4h)->s_ip_dst = IPV4_GET_RAW_IPSRC(ipv4h); \\\n    } while (0)\n\n#define PSEUDO_PKT_SET_IPV6HDR(nipv6h,ipv6h) do { \\\n        (nipv6h)->s_ip6_src[0] = (ipv6h)->s_ip6_dst[0]; \\\n        (nipv6h)->s_ip6_src[1] = (ipv6h)->s_ip6_dst[1]; \\\n        (nipv6h)->s_ip6_src[2] = (ipv6h)->s_ip6_dst[2]; \\\n        (nipv6h)->s_ip6_src[3] = (ipv6h)->s_ip6_dst[3]; \\\n        (nipv6h)->s_ip6_dst[0] = (ipv6h)->s_ip6_src[0]; \\\n        (nipv6h)->s_ip6_dst[1] = (ipv6h)->s_ip6_src[1]; \\\n        (nipv6h)->s_ip6_dst[2] = (ipv6h)->s_ip6_src[2]; \\\n        (nipv6h)->s_ip6_dst[3] = (ipv6h)->s_ip6_src[3]; \\\n        IPV6_SET_RAW_NH(nipv6h, IPV6_GET_RAW_NH(ipv6h));    \\\n    } while (0)\n\n#define PSEUDO_PKT_SET_TCPHDR(ntcph,tcph) do { \\\n        COPY_PORT((tcph)->th_dport, (ntcph)->th_sport); \\\n        COPY_PORT((tcph)->th_sport, (ntcph)->th_dport); \\\n        (ntcph)->th_seq = (tcph)->th_ack; \\\n        (ntcph)->th_ack = (tcph)->th_seq; \\\n    } while (0)\n\n/**\n * \\brief   Function to fetch a packet from the packet allocation queue for\n *          creation of the pseudo packet from the reassembled stream.\n *\n * @param parent    Pointer to the parent of the pseudo packet\n * @param pkt       pointer to the raw packet of the parent\n * @param len       length of the packet\n * @return          upon success returns the pointer to the new pseudo packet\n *                  otherwise NULL\n */\nPacket *StreamTcpPseudoSetup(Packet *parent, uint8_t *pkt, uint32_t len)\n{\n    SCEnter();\n\n    if (len == 0) {\n        SCReturnPtr(NULL, \"Packet\");\n    }\n\n    Packet *p = PacketGetFromQueueOrAlloc();\n    if (p == NULL) {\n        SCReturnPtr(NULL, \"Packet\");\n    }\n\n    /* set the root ptr to the lowest layer */\n    if (parent->root != NULL)\n        p->root = parent->root;\n    else\n        p->root = parent;\n\n    /* copy packet and set length, proto */\n    p->proto = parent->proto;\n    p->datalink = parent->datalink;\n\n    PacketCopyData(p, pkt, len);\n    p->recursion_level = parent->recursion_level + 1;\n    p->ts.tv_sec = parent->ts.tv_sec;\n    p->ts.tv_usec = parent->ts.tv_usec;\n\n    FlowReference(&p->flow, parent->flow);\n    /* set tunnel flags */\n\n    /* tell new packet it's part of a tunnel */\n    SET_TUNNEL_PKT(p);\n    /* tell parent packet it's part of a tunnel */\n    SET_TUNNEL_PKT(parent);\n\n    /* increment tunnel packet refcnt in the root packet */\n    TUNNEL_INCR_PKT_TPR(p);\n\n    return p;\n}\n\n/** \\brief Create a pseudo packet injected into the engine to signal the\n *         opposing direction of this stream trigger detection/logging.\n *\n *  \\param parent real packet\n *  \\param pq packet queue to store the new pseudo packet in\n *  \\param dir 0 ts 1 tc\n */\nstatic void StreamTcpPseudoPacketCreateDetectLogFlush(ThreadVars *tv,\n        StreamTcpThread *stt, Packet *parent,\n        TcpSession *ssn, PacketQueueNoLock *pq, int dir)\n{\n    SCEnter();\n    Flow *f = parent->flow;\n\n    if (parent->flags & PKT_PSEUDO_DETECTLOG_FLUSH) {\n        SCReturn;\n    }\n\n    Packet *np = PacketPoolGetPacket();\n    if (np == NULL) {\n        SCReturn;\n    }\n    PKT_SET_SRC(np, PKT_SRC_STREAM_TCP_DETECTLOG_FLUSH);\n\n    np->tenant_id = f->tenant_id;\n    np->datalink = DLT_RAW;\n    np->proto = IPPROTO_TCP;\n    FlowReference(&np->flow, f);\n    np->flags |= PKT_STREAM_EST;\n    np->flags |= PKT_HAS_FLOW;\n    np->flags |= PKT_IGNORE_CHECKSUM;\n    np->flags |= PKT_PSEUDO_DETECTLOG_FLUSH;\n    np->vlan_id[0] = f->vlan_id[0];\n    np->vlan_id[1] = f->vlan_id[1];\n    np->vlan_idx = f->vlan_idx;\n    np->livedev = (struct LiveDevice_ *)f->livedev;\n\n    if (f->flags & FLOW_NOPACKET_INSPECTION) {\n        DecodeSetNoPacketInspectionFlag(np);\n    }\n    if (f->flags & FLOW_NOPAYLOAD_INSPECTION) {\n        DecodeSetNoPayloadInspectionFlag(np);\n    }\n\n    if (dir == 0) {\n        SCLogDebug(\"pseudo is to_server\");\n        np->flowflags |= FLOW_PKT_TOSERVER;\n    } else {\n        SCLogDebug(\"pseudo is to_client\");\n        np->flowflags |= FLOW_PKT_TOCLIENT;\n    }\n    np->flowflags |= FLOW_PKT_ESTABLISHED;\n    np->payload = NULL;\n    np->payload_len = 0;\n\n    if (FLOW_IS_IPV4(f)) {\n        if (dir == 0) {\n            FLOW_COPY_IPV4_ADDR_TO_PACKET(&f->src, &np->src);\n            FLOW_COPY_IPV4_ADDR_TO_PACKET(&f->dst, &np->dst);\n            np->sp = f->sp;\n            np->dp = f->dp;\n        } else {\n            FLOW_COPY_IPV4_ADDR_TO_PACKET(&f->src, &np->dst);\n            FLOW_COPY_IPV4_ADDR_TO_PACKET(&f->dst, &np->src);\n            np->sp = f->dp;\n            np->dp = f->sp;\n        }\n\n        /* Check if we have enough room in direct data. We need ipv4 hdr + tcp hdr.\n         * Force an allocation if it is not the case.\n         */\n        if (GET_PKT_DIRECT_MAX_SIZE(np) <  40) {\n            if (PacketCallocExtPkt(np, 40) == -1) {\n                goto error;\n            }\n        }\n        /* set the ip header */\n        np->ip4h = (IPV4Hdr *)GET_PKT_DATA(np);\n        /* version 4 and length 20 bytes for the tcp header */\n        np->ip4h->ip_verhl = 0x45;\n        np->ip4h->ip_tos = 0;\n        np->ip4h->ip_len = htons(40);\n        np->ip4h->ip_id = 0;\n        np->ip4h->ip_off = 0;\n        np->ip4h->ip_ttl = 64;\n        np->ip4h->ip_proto = IPPROTO_TCP;\n        if (dir == 0) {\n            np->ip4h->s_ip_src.s_addr = f->src.addr_data32[0];\n            np->ip4h->s_ip_dst.s_addr = f->dst.addr_data32[0];\n        } else {\n            np->ip4h->s_ip_src.s_addr = f->dst.addr_data32[0];\n            np->ip4h->s_ip_dst.s_addr = f->src.addr_data32[0];\n        }\n\n        /* set the tcp header */\n        np->tcph = (TCPHdr *)((uint8_t *)GET_PKT_DATA(np) + 20);\n\n        SET_PKT_LEN(np, 40); /* ipv4 hdr + tcp hdr */\n\n    } else if (FLOW_IS_IPV6(f)) {\n        if (dir == 0) {\n            FLOW_COPY_IPV6_ADDR_TO_PACKET(&f->src, &np->src);\n            FLOW_COPY_IPV6_ADDR_TO_PACKET(&f->dst, &np->dst);\n            np->sp = f->sp;\n            np->dp = f->dp;\n        } else {\n            FLOW_COPY_IPV6_ADDR_TO_PACKET(&f->src, &np->dst);\n            FLOW_COPY_IPV6_ADDR_TO_PACKET(&f->dst, &np->src);\n            np->sp = f->dp;\n            np->dp = f->sp;\n        }\n\n        /* Check if we have enough room in direct data. We need ipv6 hdr + tcp hdr.\n         * Force an allocation if it is not the case.\n         */\n        if (GET_PKT_DIRECT_MAX_SIZE(np) <  60) {\n            if (PacketCallocExtPkt(np, 60) == -1) {\n                goto error;\n            }\n        }\n        /* set the ip header */\n        np->ip6h = (IPV6Hdr *)GET_PKT_DATA(np);\n        /* version 6 */\n        np->ip6h->s_ip6_vfc = 0x60;\n        np->ip6h->s_ip6_flow = 0;\n        np->ip6h->s_ip6_nxt = IPPROTO_TCP;\n        np->ip6h->s_ip6_plen = htons(20);\n        np->ip6h->s_ip6_hlim = 64;\n        if (dir == 0) {\n            np->ip6h->s_ip6_src[0] = f->src.addr_data32[0];\n            np->ip6h->s_ip6_src[1] = f->src.addr_data32[1];\n            np->ip6h->s_ip6_src[2] = f->src.addr_data32[2];\n            np->ip6h->s_ip6_src[3] = f->src.addr_data32[3];\n            np->ip6h->s_ip6_dst[0] = f->dst.addr_data32[0];\n            np->ip6h->s_ip6_dst[1] = f->dst.addr_data32[1];\n            np->ip6h->s_ip6_dst[2] = f->dst.addr_data32[2];\n            np->ip6h->s_ip6_dst[3] = f->dst.addr_data32[3];\n        } else {\n            np->ip6h->s_ip6_src[0] = f->dst.addr_data32[0];\n            np->ip6h->s_ip6_src[1] = f->dst.addr_data32[1];\n            np->ip6h->s_ip6_src[2] = f->dst.addr_data32[2];\n            np->ip6h->s_ip6_src[3] = f->dst.addr_data32[3];\n            np->ip6h->s_ip6_dst[0] = f->src.addr_data32[0];\n            np->ip6h->s_ip6_dst[1] = f->src.addr_data32[1];\n            np->ip6h->s_ip6_dst[2] = f->src.addr_data32[2];\n            np->ip6h->s_ip6_dst[3] = f->src.addr_data32[3];\n        }\n\n        /* set the tcp header */\n        np->tcph = (TCPHdr *)((uint8_t *)GET_PKT_DATA(np) + 40);\n\n        SET_PKT_LEN(np, 60); /* ipv6 hdr + tcp hdr */\n    }\n\n    np->tcph->th_offx2 = 0x50;\n    np->tcph->th_flags |= TH_ACK;\n    np->tcph->th_win = 10;\n    np->tcph->th_urp = 0;\n\n    /* to server */\n    if (dir == 0) {\n        np->tcph->th_sport = htons(f->sp);\n        np->tcph->th_dport = htons(f->dp);\n\n        np->tcph->th_seq = htonl(ssn->client.next_seq);\n        np->tcph->th_ack = htonl(ssn->server.last_ack);\n\n    /* to client */\n    } else {\n        np->tcph->th_sport = htons(f->dp);\n        np->tcph->th_dport = htons(f->sp);\n\n        np->tcph->th_seq = htonl(ssn->server.next_seq);\n        np->tcph->th_ack = htonl(ssn->client.last_ack);\n    }\n\n    /* use parent time stamp */\n    memcpy(&np->ts, &parent->ts, sizeof(struct timeval));\n\n    SCLogDebug(\"np %p\", np);\n    PacketEnqueueNoLock(pq, np);\n\n    StatsIncr(tv, stt->counter_tcp_pseudo);\n    SCReturn;\nerror:\n    FlowDeReference(&np->flow);\n    SCReturn;\n}\n\n/** \\brief create packets in both directions to flush out logging\n *         and detection before switching protocols.\n *         In IDS mode, create first in packet dir, 2nd in opposing\n *         In IPS mode, do the reverse.\n *         Flag TCP engine that data needs to be inspected regardless\n *         of how far we are wrt inspect limits.\n */\nvoid StreamTcpDetectLogFlush(ThreadVars *tv, StreamTcpThread *stt, Flow *f, Packet *p,\n        PacketQueueNoLock *pq)\n{\n    TcpSession *ssn = f->protoctx;\n    ssn->client.flags |= STREAMTCP_STREAM_FLAG_TRIGGER_RAW;\n    ssn->server.flags |= STREAMTCP_STREAM_FLAG_TRIGGER_RAW;\n    bool ts = PKT_IS_TOSERVER(p) ? true : false;\n    ts ^= StreamTcpInlineMode();\n    StreamTcpPseudoPacketCreateDetectLogFlush(tv, stt, p, ssn, pq, ts^0);\n    StreamTcpPseudoPacketCreateDetectLogFlush(tv, stt, p, ssn, pq, ts^1);\n}\n\n/**\n * \\brief Run callback function on each TCP segment\n *\n * \\note when stream engine is running in inline mode all segments are used,\n *       in IDS/non-inline mode only ack'd segments are iterated.\n *\n * \\note Must be called under flow lock.\n *\n * \\return -1 in case of error, the number of segment in case of success\n *\n */\nint StreamTcpSegmentForEach(const Packet *p, uint8_t flag, StreamSegmentCallback CallbackFunc, void *data)\n{\n    TcpSession *ssn = NULL;\n    TcpStream *stream = NULL;\n    int ret = 0;\n    int cnt = 0;\n\n    if (p->flow == NULL)\n        return 0;\n\n    ssn = (TcpSession *)p->flow->protoctx;\n\n    if (ssn == NULL) {\n        return 0;\n    }\n\n    if (flag & FLOW_PKT_TOSERVER) {\n        stream = &(ssn->server);\n    } else {\n        stream = &(ssn->client);\n    }\n\n    /* for IDS, return ack'd segments. For IPS all. */\n    TcpSegment *seg;\n    RB_FOREACH(seg, TCPSEG, &stream->seg_tree) {\n        if (!((stream_config.flags & STREAMTCP_INIT_FLAG_INLINE)\n                    || SEQ_LT(seg->seq, stream->last_ack)))\n            break;\n\n        const uint8_t *seg_data;\n        uint32_t seg_datalen;\n        StreamingBufferSegmentGetData(&stream->sb, &seg->sbseg, &seg_data, &seg_datalen);\n\n        ret = CallbackFunc(p, data, seg_data, seg_datalen);\n        if (ret != 1) {\n            SCLogDebug(\"Callback function has failed\");\n            return -1;\n        }\n\n        cnt++;\n    }\n    return cnt;\n}\n\nint StreamTcpBypassEnabled(void)\n{\n    return (stream_config.flags & STREAMTCP_INIT_FLAG_BYPASS);\n}\n\n/**\n *  \\brief See if stream engine is operating in inline mode\n *\n *  \\retval 0 no\n *  \\retval 1 yes\n */\nint StreamTcpInlineMode(void)\n{\n    return (stream_config.flags & STREAMTCP_INIT_FLAG_INLINE) ? 1 : 0;\n}\n\n\nvoid TcpSessionSetReassemblyDepth(TcpSession *ssn, uint32_t size)\n{\n    if (size > ssn->reassembly_depth || size == 0) {\n        ssn->reassembly_depth = size;\n    }\n\n    return;\n}\n\nconst char *StreamTcpStateAsString(const enum TcpState state)\n{\n    const char *tcp_state = NULL;\n    switch (state) {\n        case TCP_NONE:\n            tcp_state = \"none\";\n            break;\n        case TCP_LISTEN:\n            tcp_state = \"listen\";\n            break;\n        case TCP_SYN_SENT:\n            tcp_state = \"syn_sent\";\n            break;\n        case TCP_SYN_RECV:\n            tcp_state = \"syn_recv\";\n            break;\n        case TCP_ESTABLISHED:\n            tcp_state = \"established\";\n            break;\n        case TCP_FIN_WAIT1:\n            tcp_state = \"fin_wait1\";\n            break;\n        case TCP_FIN_WAIT2:\n            tcp_state = \"fin_wait2\";\n            break;\n        case TCP_TIME_WAIT:\n            tcp_state = \"time_wait\";\n            break;\n        case TCP_LAST_ACK:\n            tcp_state = \"last_ack\";\n            break;\n        case TCP_CLOSE_WAIT:\n            tcp_state = \"close_wait\";\n            break;\n        case TCP_CLOSING:\n            tcp_state = \"closing\";\n            break;\n        case TCP_CLOSED:\n            tcp_state = \"closed\";\n            break;\n    }\n    return tcp_state;\n}\n\nconst char *StreamTcpSsnStateAsString(const TcpSession *ssn)\n{\n    if (ssn == NULL)\n        return NULL;\n    return StreamTcpStateAsString(ssn->state);\n}\n\n#ifdef UNITTESTS\n#include \"tests/stream-tcp.c\"\n#endif\n"], "filenames": ["src/decode-tcp.c", "src/decode-tcp.h", "src/stream-tcp.c"], "buggy_code_start_loc": [185, 56, 4435], "buggy_code_end_loc": [185, 155, 5448], "fixing_code_start_loc": [186, 57, 4436], "fixing_code_end_loc": [206, 160, 5466], "type": "NVD-CWE-noinfo", "message": "An issue was discovered in Suricata before 6.0.4. It is possible to bypass/evade any HTTP-based signature by faking an RST TCP packet with random TCP options of the md5header from the client side. After the three-way handshake, it's possible to inject an RST ACK with a random TCP md5header option. Then, the client can send an HTTP GET request with a forbidden URL. The server will ignore the RST ACK and send the response HTTP packet for the client's request. These packets will not trigger a Suricata reject action.", "other": {"cve": {"id": "CVE-2021-45098", "sourceIdentifier": "cve@mitre.org", "published": "2021-12-16T05:15:08.727", "lastModified": "2022-01-04T16:48:54.087", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in Suricata before 6.0.4. It is possible to bypass/evade any HTTP-based signature by faking an RST TCP packet with random TCP options of the md5header from the client side. After the three-way handshake, it's possible to inject an RST ACK with a random TCP md5header option. Then, the client can send an HTTP GET request with a forbidden URL. The server will ignore the RST ACK and send the response HTTP packet for the client's request. These packets will not trigger a Suricata reject action."}, {"lang": "es", "value": "Se ha detectado un problema en Suricata versiones anteriores a 6.0.4. Es posible omitir/evadir cualquier firma basada en HTTP al falsificar un paquete RST TCP con opciones TCP aleatorias del md5header desde el lado del cliente. Despu\u00e9s del handshake de tres v\u00edas, es posible inyectar un RST ACK con una opci\u00f3n TCP md5header aleatoria. Entonces, el cliente puede enviar una petici\u00f3n HTTP GET con una URL prohibida. El servidor ignorar\u00e1 el RST ACK y enviar\u00e1 el paquete HTTP de respuesta para la petici\u00f3n del cliente. Estos paquetes no desencadenar\u00e1n una acci\u00f3n de rechazo de Suricata"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oisf:suricata:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.0.4", "matchCriteriaId": "58D90161-8343-4EB0-BF64-2EEFFABDCEE6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "https://forum.suricata.io/t/suricata-6-0-4-and-5-0-8-released/1942", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/OISF/suricata/commit/50e2b973eeec7172991bf8f544ab06fb782b97df", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/OISF/suricata/releases", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://redmine.openinfosecfoundation.org/issues/4710", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/OISF/suricata/commit/50e2b973eeec7172991bf8f544ab06fb782b97df"}}