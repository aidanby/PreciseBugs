{"buggy_code": ["/*\n *  net/dccp/input.c\n *\n *  An implementation of the DCCP protocol\n *  Arnaldo Carvalho de Melo <acme@conectiva.com.br>\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License\n *\tas published by the Free Software Foundation; either version\n *\t2 of the License, or (at your option) any later version.\n */\n\n#include <linux/dccp.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n\n#include <net/sock.h>\n\n#include \"ackvec.h\"\n#include \"ccid.h\"\n#include \"dccp.h\"\n\n/* rate-limit for syncs in reply to sequence-invalid packets; RFC 4340, 7.5.4 */\nint sysctl_dccp_sync_ratelimit\t__read_mostly = HZ / 8;\n\nstatic void dccp_enqueue_skb(struct sock *sk, struct sk_buff *skb)\n{\n\t__skb_pull(skb, dccp_hdr(skb)->dccph_doff * 4);\n\t__skb_queue_tail(&sk->sk_receive_queue, skb);\n\tskb_set_owner_r(skb, sk);\n\tsk->sk_data_ready(sk);\n}\n\nstatic void dccp_fin(struct sock *sk, struct sk_buff *skb)\n{\n\t/*\n\t * On receiving Close/CloseReq, both RD/WR shutdown are performed.\n\t * RFC 4340, 8.3 says that we MAY send further Data/DataAcks after\n\t * receiving the closing segment, but there is no guarantee that such\n\t * data will be processed at all.\n\t */\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tsock_set_flag(sk, SOCK_DONE);\n\tdccp_enqueue_skb(sk, skb);\n}\n\nstatic int dccp_rcv_close(struct sock *sk, struct sk_buff *skb)\n{\n\tint queued = 0;\n\n\tswitch (sk->sk_state) {\n\t/*\n\t * We ignore Close when received in one of the following states:\n\t *  - CLOSED\t\t(may be a late or duplicate packet)\n\t *  - PASSIVE_CLOSEREQ\t(the peer has sent a CloseReq earlier)\n\t *  - RESPOND\t\t(already handled by dccp_check_req)\n\t */\n\tcase DCCP_CLOSING:\n\t\t/*\n\t\t * Simultaneous-close: receiving a Close after sending one. This\n\t\t * can happen if both client and server perform active-close and\n\t\t * will result in an endless ping-pong of crossing and retrans-\n\t\t * mitted Close packets, which only terminates when one of the\n\t\t * nodes times out (min. 64 seconds). Quicker convergence can be\n\t\t * achieved when one of the nodes acts as tie-breaker.\n\t\t * This is ok as both ends are done with data transfer and each\n\t\t * end is just waiting for the other to acknowledge termination.\n\t\t */\n\t\tif (dccp_sk(sk)->dccps_role != DCCP_ROLE_CLIENT)\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase DCCP_REQUESTING:\n\tcase DCCP_ACTIVE_CLOSEREQ:\n\t\tdccp_send_reset(sk, DCCP_RESET_CODE_CLOSED);\n\t\tdccp_done(sk);\n\t\tbreak;\n\tcase DCCP_OPEN:\n\tcase DCCP_PARTOPEN:\n\t\t/* Give waiting application a chance to read pending data */\n\t\tqueued = 1;\n\t\tdccp_fin(sk, skb);\n\t\tdccp_set_state(sk, DCCP_PASSIVE_CLOSE);\n\t\t/* fall through */\n\tcase DCCP_PASSIVE_CLOSE:\n\t\t/*\n\t\t * Retransmitted Close: we have already enqueued the first one.\n\t\t */\n\t\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_HUP);\n\t}\n\treturn queued;\n}\n\nstatic int dccp_rcv_closereq(struct sock *sk, struct sk_buff *skb)\n{\n\tint queued = 0;\n\n\t/*\n\t *   Step 7: Check for unexpected packet types\n\t *      If (S.is_server and P.type == CloseReq)\n\t *\t  Send Sync packet acknowledging P.seqno\n\t *\t  Drop packet and return\n\t */\n\tif (dccp_sk(sk)->dccps_role != DCCP_ROLE_CLIENT) {\n\t\tdccp_send_sync(sk, DCCP_SKB_CB(skb)->dccpd_seq, DCCP_PKT_SYNC);\n\t\treturn queued;\n\t}\n\n\t/* Step 13: process relevant Client states < CLOSEREQ */\n\tswitch (sk->sk_state) {\n\tcase DCCP_REQUESTING:\n\t\tdccp_send_close(sk, 0);\n\t\tdccp_set_state(sk, DCCP_CLOSING);\n\t\tbreak;\n\tcase DCCP_OPEN:\n\tcase DCCP_PARTOPEN:\n\t\t/* Give waiting application a chance to read pending data */\n\t\tqueued = 1;\n\t\tdccp_fin(sk, skb);\n\t\tdccp_set_state(sk, DCCP_PASSIVE_CLOSEREQ);\n\t\t/* fall through */\n\tcase DCCP_PASSIVE_CLOSEREQ:\n\t\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_HUP);\n\t}\n\treturn queued;\n}\n\nstatic u16 dccp_reset_code_convert(const u8 code)\n{\n\tconst u16 error_code[] = {\n\t[DCCP_RESET_CODE_CLOSED]\t     = 0,\t/* normal termination */\n\t[DCCP_RESET_CODE_UNSPECIFIED]\t     = 0,\t/* nothing known */\n\t[DCCP_RESET_CODE_ABORTED]\t     = ECONNRESET,\n\n\t[DCCP_RESET_CODE_NO_CONNECTION]\t     = ECONNREFUSED,\n\t[DCCP_RESET_CODE_CONNECTION_REFUSED] = ECONNREFUSED,\n\t[DCCP_RESET_CODE_TOO_BUSY]\t     = EUSERS,\n\t[DCCP_RESET_CODE_AGGRESSION_PENALTY] = EDQUOT,\n\n\t[DCCP_RESET_CODE_PACKET_ERROR]\t     = ENOMSG,\n\t[DCCP_RESET_CODE_BAD_INIT_COOKIE]    = EBADR,\n\t[DCCP_RESET_CODE_BAD_SERVICE_CODE]   = EBADRQC,\n\t[DCCP_RESET_CODE_OPTION_ERROR]\t     = EILSEQ,\n\t[DCCP_RESET_CODE_MANDATORY_ERROR]    = EOPNOTSUPP,\n\t};\n\n\treturn code >= DCCP_MAX_RESET_CODES ? 0 : error_code[code];\n}\n\nstatic void dccp_rcv_reset(struct sock *sk, struct sk_buff *skb)\n{\n\tu16 err = dccp_reset_code_convert(dccp_hdr_reset(skb)->dccph_reset_code);\n\n\tsk->sk_err = err;\n\n\t/* Queue the equivalent of TCP fin so that dccp_recvmsg exits the loop */\n\tdccp_fin(sk, skb);\n\n\tif (err && !sock_flag(sk, SOCK_DEAD))\n\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_ERR);\n\tdccp_time_wait(sk, DCCP_TIME_WAIT, 0);\n}\n\nstatic void dccp_handle_ackvec_processing(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct dccp_ackvec *av = dccp_sk(sk)->dccps_hc_rx_ackvec;\n\n\tif (av == NULL)\n\t\treturn;\n\tif (DCCP_SKB_CB(skb)->dccpd_ack_seq != DCCP_PKT_WITHOUT_ACK_SEQ)\n\t\tdccp_ackvec_clear_state(av, DCCP_SKB_CB(skb)->dccpd_ack_seq);\n\tdccp_ackvec_input(av, skb);\n}\n\nstatic void dccp_deliver_input_to_ccids(struct sock *sk, struct sk_buff *skb)\n{\n\tconst struct dccp_sock *dp = dccp_sk(sk);\n\n\t/* Don't deliver to RX CCID when node has shut down read end. */\n\tif (!(sk->sk_shutdown & RCV_SHUTDOWN))\n\t\tccid_hc_rx_packet_recv(dp->dccps_hc_rx_ccid, sk, skb);\n\t/*\n\t * Until the TX queue has been drained, we can not honour SHUT_WR, since\n\t * we need received feedback as input to adjust congestion control.\n\t */\n\tif (sk->sk_write_queue.qlen > 0 || !(sk->sk_shutdown & SEND_SHUTDOWN))\n\t\tccid_hc_tx_packet_recv(dp->dccps_hc_tx_ccid, sk, skb);\n}\n\nstatic int dccp_check_seqno(struct sock *sk, struct sk_buff *skb)\n{\n\tconst struct dccp_hdr *dh = dccp_hdr(skb);\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tu64 lswl, lawl, seqno = DCCP_SKB_CB(skb)->dccpd_seq,\n\t\t\tackno = DCCP_SKB_CB(skb)->dccpd_ack_seq;\n\n\t/*\n\t *   Step 5: Prepare sequence numbers for Sync\n\t *     If P.type == Sync or P.type == SyncAck,\n\t *\t  If S.AWL <= P.ackno <= S.AWH and P.seqno >= S.SWL,\n\t *\t     / * P is valid, so update sequence number variables\n\t *\t\t accordingly.  After this update, P will pass the tests\n\t *\t\t in Step 6.  A SyncAck is generated if necessary in\n\t *\t\t Step 15 * /\n\t *\t     Update S.GSR, S.SWL, S.SWH\n\t *\t  Otherwise,\n\t *\t     Drop packet and return\n\t */\n\tif (dh->dccph_type == DCCP_PKT_SYNC ||\n\t    dh->dccph_type == DCCP_PKT_SYNCACK) {\n\t\tif (between48(ackno, dp->dccps_awl, dp->dccps_awh) &&\n\t\t    dccp_delta_seqno(dp->dccps_swl, seqno) >= 0)\n\t\t\tdccp_update_gsr(sk, seqno);\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\t/*\n\t *   Step 6: Check sequence numbers\n\t *      Let LSWL = S.SWL and LAWL = S.AWL\n\t *      If P.type == CloseReq or P.type == Close or P.type == Reset,\n\t *\t  LSWL := S.GSR + 1, LAWL := S.GAR\n\t *      If LSWL <= P.seqno <= S.SWH\n\t *\t     and (P.ackno does not exist or LAWL <= P.ackno <= S.AWH),\n\t *\t  Update S.GSR, S.SWL, S.SWH\n\t *\t  If P.type != Sync,\n\t *\t     Update S.GAR\n\t */\n\tlswl = dp->dccps_swl;\n\tlawl = dp->dccps_awl;\n\n\tif (dh->dccph_type == DCCP_PKT_CLOSEREQ ||\n\t    dh->dccph_type == DCCP_PKT_CLOSE ||\n\t    dh->dccph_type == DCCP_PKT_RESET) {\n\t\tlswl = ADD48(dp->dccps_gsr, 1);\n\t\tlawl = dp->dccps_gar;\n\t}\n\n\tif (between48(seqno, lswl, dp->dccps_swh) &&\n\t    (ackno == DCCP_PKT_WITHOUT_ACK_SEQ ||\n\t     between48(ackno, lawl, dp->dccps_awh))) {\n\t\tdccp_update_gsr(sk, seqno);\n\n\t\tif (dh->dccph_type != DCCP_PKT_SYNC &&\n\t\t    ackno != DCCP_PKT_WITHOUT_ACK_SEQ &&\n\t\t    after48(ackno, dp->dccps_gar))\n\t\t\tdp->dccps_gar = ackno;\n\t} else {\n\t\tunsigned long now = jiffies;\n\t\t/*\n\t\t *   Step 6: Check sequence numbers\n\t\t *      Otherwise,\n\t\t *         If P.type == Reset,\n\t\t *            Send Sync packet acknowledging S.GSR\n\t\t *         Otherwise,\n\t\t *            Send Sync packet acknowledging P.seqno\n\t\t *      Drop packet and return\n\t\t *\n\t\t *   These Syncs are rate-limited as per RFC 4340, 7.5.4:\n\t\t *   at most 1 / (dccp_sync_rate_limit * HZ) Syncs per second.\n\t\t */\n\t\tif (time_before(now, (dp->dccps_rate_last +\n\t\t\t\t      sysctl_dccp_sync_ratelimit)))\n\t\t\treturn -1;\n\n\t\tDCCP_WARN(\"Step 6 failed for %s packet, \"\n\t\t\t  \"(LSWL(%llu) <= P.seqno(%llu) <= S.SWH(%llu)) and \"\n\t\t\t  \"(P.ackno %s or LAWL(%llu) <= P.ackno(%llu) <= S.AWH(%llu), \"\n\t\t\t  \"sending SYNC...\\n\",  dccp_packet_name(dh->dccph_type),\n\t\t\t  (unsigned long long) lswl, (unsigned long long) seqno,\n\t\t\t  (unsigned long long) dp->dccps_swh,\n\t\t\t  (ackno == DCCP_PKT_WITHOUT_ACK_SEQ) ? \"doesn't exist\"\n\t\t\t\t\t\t\t      : \"exists\",\n\t\t\t  (unsigned long long) lawl, (unsigned long long) ackno,\n\t\t\t  (unsigned long long) dp->dccps_awh);\n\n\t\tdp->dccps_rate_last = now;\n\n\t\tif (dh->dccph_type == DCCP_PKT_RESET)\n\t\t\tseqno = dp->dccps_gsr;\n\t\tdccp_send_sync(sk, seqno, DCCP_PKT_SYNC);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int __dccp_rcv_established(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  const struct dccp_hdr *dh, const unsigned int len)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\n\tswitch (dccp_hdr(skb)->dccph_type) {\n\tcase DCCP_PKT_DATAACK:\n\tcase DCCP_PKT_DATA:\n\t\t/*\n\t\t * FIXME: schedule DATA_DROPPED (RFC 4340, 11.7.2) if and when\n\t\t * - sk_shutdown == RCV_SHUTDOWN, use Code 1, \"Not Listening\"\n\t\t * - sk_receive_queue is full, use Code 2, \"Receive Buffer\"\n\t\t */\n\t\tdccp_enqueue_skb(sk, skb);\n\t\treturn 0;\n\tcase DCCP_PKT_ACK:\n\t\tgoto discard;\n\tcase DCCP_PKT_RESET:\n\t\t/*\n\t\t *  Step 9: Process Reset\n\t\t *\tIf P.type == Reset,\n\t\t *\t\tTear down connection\n\t\t *\t\tS.state := TIMEWAIT\n\t\t *\t\tSet TIMEWAIT timer\n\t\t *\t\tDrop packet and return\n\t\t */\n\t\tdccp_rcv_reset(sk, skb);\n\t\treturn 0;\n\tcase DCCP_PKT_CLOSEREQ:\n\t\tif (dccp_rcv_closereq(sk, skb))\n\t\t\treturn 0;\n\t\tgoto discard;\n\tcase DCCP_PKT_CLOSE:\n\t\tif (dccp_rcv_close(sk, skb))\n\t\t\treturn 0;\n\t\tgoto discard;\n\tcase DCCP_PKT_REQUEST:\n\t\t/* Step 7\n\t\t *   or (S.is_server and P.type == Response)\n\t\t *   or (S.is_client and P.type == Request)\n\t\t *   or (S.state >= OPEN and P.type == Request\n\t\t *\tand P.seqno >= S.OSR)\n\t\t *    or (S.state >= OPEN and P.type == Response\n\t\t *\tand P.seqno >= S.OSR)\n\t\t *    or (S.state == RESPOND and P.type == Data),\n\t\t *  Send Sync packet acknowledging P.seqno\n\t\t *  Drop packet and return\n\t\t */\n\t\tif (dp->dccps_role != DCCP_ROLE_LISTEN)\n\t\t\tgoto send_sync;\n\t\tgoto check_seq;\n\tcase DCCP_PKT_RESPONSE:\n\t\tif (dp->dccps_role != DCCP_ROLE_CLIENT)\n\t\t\tgoto send_sync;\ncheck_seq:\n\t\tif (dccp_delta_seqno(dp->dccps_osr,\n\t\t\t\t     DCCP_SKB_CB(skb)->dccpd_seq) >= 0) {\nsend_sync:\n\t\t\tdccp_send_sync(sk, DCCP_SKB_CB(skb)->dccpd_seq,\n\t\t\t\t       DCCP_PKT_SYNC);\n\t\t}\n\t\tbreak;\n\tcase DCCP_PKT_SYNC:\n\t\tdccp_send_sync(sk, DCCP_SKB_CB(skb)->dccpd_seq,\n\t\t\t       DCCP_PKT_SYNCACK);\n\t\t/*\n\t\t * From RFC 4340, sec. 5.7\n\t\t *\n\t\t * As with DCCP-Ack packets, DCCP-Sync and DCCP-SyncAck packets\n\t\t * MAY have non-zero-length application data areas, whose\n\t\t * contents receivers MUST ignore.\n\t\t */\n\t\tgoto discard;\n\t}\n\n\tDCCP_INC_STATS(DCCP_MIB_INERRS);\ndiscard:\n\t__kfree_skb(skb);\n\treturn 0;\n}\n\nint dccp_rcv_established(struct sock *sk, struct sk_buff *skb,\n\t\t\t const struct dccp_hdr *dh, const unsigned int len)\n{\n\tif (dccp_check_seqno(sk, skb))\n\t\tgoto discard;\n\n\tif (dccp_parse_options(sk, NULL, skb))\n\t\treturn 1;\n\n\tdccp_handle_ackvec_processing(sk, skb);\n\tdccp_deliver_input_to_ccids(sk, skb);\n\n\treturn __dccp_rcv_established(sk, skb, dh, len);\ndiscard:\n\t__kfree_skb(skb);\n\treturn 0;\n}\n\nEXPORT_SYMBOL_GPL(dccp_rcv_established);\n\nstatic int dccp_rcv_request_sent_state_process(struct sock *sk,\n\t\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t\t       const struct dccp_hdr *dh,\n\t\t\t\t\t       const unsigned int len)\n{\n\t/*\n\t *  Step 4: Prepare sequence numbers in REQUEST\n\t *     If S.state == REQUEST,\n\t *\t  If (P.type == Response or P.type == Reset)\n\t *\t\tand S.AWL <= P.ackno <= S.AWH,\n\t *\t     / * Set sequence number variables corresponding to the\n\t *\t\tother endpoint, so P will pass the tests in Step 6 * /\n\t *\t     Set S.GSR, S.ISR, S.SWL, S.SWH\n\t *\t     / * Response processing continues in Step 10; Reset\n\t *\t\tprocessing continues in Step 9 * /\n\t*/\n\tif (dh->dccph_type == DCCP_PKT_RESPONSE) {\n\t\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\t\tstruct dccp_sock *dp = dccp_sk(sk);\n\t\tlong tstamp = dccp_timestamp();\n\n\t\tif (!between48(DCCP_SKB_CB(skb)->dccpd_ack_seq,\n\t\t\t       dp->dccps_awl, dp->dccps_awh)) {\n\t\t\tdccp_pr_debug(\"invalid ackno: S.AWL=%llu, \"\n\t\t\t\t      \"P.ackno=%llu, S.AWH=%llu\\n\",\n\t\t\t\t      (unsigned long long)dp->dccps_awl,\n\t\t\t   (unsigned long long)DCCP_SKB_CB(skb)->dccpd_ack_seq,\n\t\t\t\t      (unsigned long long)dp->dccps_awh);\n\t\t\tgoto out_invalid_packet;\n\t\t}\n\n\t\t/*\n\t\t * If option processing (Step 8) failed, return 1 here so that\n\t\t * dccp_v4_do_rcv() sends a Reset. The Reset code depends on\n\t\t * the option type and is set in dccp_parse_options().\n\t\t */\n\t\tif (dccp_parse_options(sk, NULL, skb))\n\t\t\treturn 1;\n\n\t\t/* Obtain usec RTT sample from SYN exchange (used by TFRC). */\n\t\tif (likely(dp->dccps_options_received.dccpor_timestamp_echo))\n\t\t\tdp->dccps_syn_rtt = dccp_sample_rtt(sk, 10 * (tstamp -\n\t\t\t    dp->dccps_options_received.dccpor_timestamp_echo));\n\n\t\t/* Stop the REQUEST timer */\n\t\tinet_csk_clear_xmit_timer(sk, ICSK_TIME_RETRANS);\n\t\tWARN_ON(sk->sk_send_head == NULL);\n\t\tkfree_skb(sk->sk_send_head);\n\t\tsk->sk_send_head = NULL;\n\n\t\t/*\n\t\t * Set ISR, GSR from packet. ISS was set in dccp_v{4,6}_connect\n\t\t * and GSS in dccp_transmit_skb(). Setting AWL/AWH and SWL/SWH\n\t\t * is done as part of activating the feature values below, since\n\t\t * these settings depend on the local/remote Sequence Window\n\t\t * features, which were undefined or not confirmed until now.\n\t\t */\n\t\tdp->dccps_gsr = dp->dccps_isr = DCCP_SKB_CB(skb)->dccpd_seq;\n\n\t\tdccp_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\n\t\t/*\n\t\t *    Step 10: Process REQUEST state (second part)\n\t\t *       If S.state == REQUEST,\n\t\t *\t  / * If we get here, P is a valid Response from the\n\t\t *\t      server (see Step 4), and we should move to\n\t\t *\t      PARTOPEN state. PARTOPEN means send an Ack,\n\t\t *\t      don't send Data packets, retransmit Acks\n\t\t *\t      periodically, and always include any Init Cookie\n\t\t *\t      from the Response * /\n\t\t *\t  S.state := PARTOPEN\n\t\t *\t  Set PARTOPEN timer\n\t\t *\t  Continue with S.state == PARTOPEN\n\t\t *\t  / * Step 12 will send the Ack completing the\n\t\t *\t      three-way handshake * /\n\t\t */\n\t\tdccp_set_state(sk, DCCP_PARTOPEN);\n\n\t\t/*\n\t\t * If feature negotiation was successful, activate features now;\n\t\t * an activation failure means that this host could not activate\n\t\t * one ore more features (e.g. insufficient memory), which would\n\t\t * leave at least one feature in an undefined state.\n\t\t */\n\t\tif (dccp_feat_activate_values(sk, &dp->dccps_featneg))\n\t\t\tgoto unable_to_proceed;\n\n\t\t/* Make sure socket is routed, for correct metrics. */\n\t\ticsk->icsk_af_ops->rebuild_header(sk);\n\n\t\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\t\tsk->sk_state_change(sk);\n\t\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);\n\t\t}\n\n\t\tif (sk->sk_write_pending || icsk->icsk_ack.pingpong ||\n\t\t    icsk->icsk_accept_queue.rskq_defer_accept) {\n\t\t\t/* Save one ACK. Data will be ready after\n\t\t\t * several ticks, if write_pending is set.\n\t\t\t *\n\t\t\t * It may be deleted, but with this feature tcpdumps\n\t\t\t * look so _wonderfully_ clever, that I was not able\n\t\t\t * to stand against the temptation 8)     --ANK\n\t\t\t */\n\t\t\t/*\n\t\t\t * OK, in DCCP we can as well do a similar trick, its\n\t\t\t * even in the draft, but there is no need for us to\n\t\t\t * schedule an ack here, as dccp_sendmsg does this for\n\t\t\t * us, also stated in the draft. -acme\n\t\t\t */\n\t\t\t__kfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\tdccp_send_ack(sk);\n\t\treturn -1;\n\t}\n\nout_invalid_packet:\n\t/* dccp_v4_do_rcv will send a reset */\n\tDCCP_SKB_CB(skb)->dccpd_reset_code = DCCP_RESET_CODE_PACKET_ERROR;\n\treturn 1;\n\nunable_to_proceed:\n\tDCCP_SKB_CB(skb)->dccpd_reset_code = DCCP_RESET_CODE_ABORTED;\n\t/*\n\t * We mark this socket as no longer usable, so that the loop in\n\t * dccp_sendmsg() terminates and the application gets notified.\n\t */\n\tdccp_set_state(sk, DCCP_CLOSED);\n\tsk->sk_err = ECOMM;\n\treturn 1;\n}\n\nstatic int dccp_rcv_respond_partopen_state_process(struct sock *sk,\n\t\t\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t\t\t   const struct dccp_hdr *dh,\n\t\t\t\t\t\t   const unsigned int len)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tu32 sample = dp->dccps_options_received.dccpor_timestamp_echo;\n\tint queued = 0;\n\n\tswitch (dh->dccph_type) {\n\tcase DCCP_PKT_RESET:\n\t\tinet_csk_clear_xmit_timer(sk, ICSK_TIME_DACK);\n\t\tbreak;\n\tcase DCCP_PKT_DATA:\n\t\tif (sk->sk_state == DCCP_RESPOND)\n\t\t\tbreak;\n\tcase DCCP_PKT_DATAACK:\n\tcase DCCP_PKT_ACK:\n\t\t/*\n\t\t * FIXME: we should be resetting the PARTOPEN (DELACK) timer\n\t\t * here but only if we haven't used the DELACK timer for\n\t\t * something else, like sending a delayed ack for a TIMESTAMP\n\t\t * echo, etc, for now were not clearing it, sending an extra\n\t\t * ACK when there is nothing else to do in DELACK is not a big\n\t\t * deal after all.\n\t\t */\n\n\t\t/* Stop the PARTOPEN timer */\n\t\tif (sk->sk_state == DCCP_PARTOPEN)\n\t\t\tinet_csk_clear_xmit_timer(sk, ICSK_TIME_DACK);\n\n\t\t/* Obtain usec RTT sample from SYN exchange (used by TFRC). */\n\t\tif (likely(sample)) {\n\t\t\tlong delta = dccp_timestamp() - sample;\n\n\t\t\tdp->dccps_syn_rtt = dccp_sample_rtt(sk, 10 * delta);\n\t\t}\n\n\t\tdp->dccps_osr = DCCP_SKB_CB(skb)->dccpd_seq;\n\t\tdccp_set_state(sk, DCCP_OPEN);\n\n\t\tif (dh->dccph_type == DCCP_PKT_DATAACK ||\n\t\t    dh->dccph_type == DCCP_PKT_DATA) {\n\t\t\t__dccp_rcv_established(sk, skb, dh, len);\n\t\t\tqueued = 1; /* packet was queued\n\t\t\t\t       (by __dccp_rcv_established) */\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn queued;\n}\n\nint dccp_rcv_state_process(struct sock *sk, struct sk_buff *skb,\n\t\t\t   struct dccp_hdr *dh, unsigned int len)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tstruct dccp_skb_cb *dcb = DCCP_SKB_CB(skb);\n\tconst int old_state = sk->sk_state;\n\tint queued = 0;\n\n\t/*\n\t *  Step 3: Process LISTEN state\n\t *\n\t *     If S.state == LISTEN,\n\t *\t If P.type == Request or P contains a valid Init Cookie option,\n\t *\t      (* Must scan the packet's options to check for Init\n\t *\t\t Cookies.  Only Init Cookies are processed here,\n\t *\t\t however; other options are processed in Step 8.  This\n\t *\t\t scan need only be performed if the endpoint uses Init\n\t *\t\t Cookies *)\n\t *\t      (* Generate a new socket and switch to that socket *)\n\t *\t      Set S := new socket for this port pair\n\t *\t      S.state = RESPOND\n\t *\t      Choose S.ISS (initial seqno) or set from Init Cookies\n\t *\t      Initialize S.GAR := S.ISS\n\t *\t      Set S.ISR, S.GSR, S.SWL, S.SWH from packet or Init\n\t *\t      Cookies Continue with S.state == RESPOND\n\t *\t      (* A Response packet will be generated in Step 11 *)\n\t *\t Otherwise,\n\t *\t      Generate Reset(No Connection) unless P.type == Reset\n\t *\t      Drop packet and return\n\t */\n\tif (sk->sk_state == DCCP_LISTEN) {\n\t\tif (dh->dccph_type == DCCP_PKT_REQUEST) {\n\t\t\tif (inet_csk(sk)->icsk_af_ops->conn_request(sk,\n\t\t\t\t\t\t\t\t    skb) < 0)\n\t\t\t\treturn 1;\n\t\t\tgoto discard;\n\t\t}\n\t\tif (dh->dccph_type == DCCP_PKT_RESET)\n\t\t\tgoto discard;\n\n\t\t/* Caller (dccp_v4_do_rcv) will send Reset */\n\t\tdcb->dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION;\n\t\treturn 1;\n\t} else if (sk->sk_state == DCCP_CLOSED) {\n\t\tdcb->dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION;\n\t\treturn 1;\n\t}\n\n\t/* Step 6: Check sequence numbers (omitted in LISTEN/REQUEST state) */\n\tif (sk->sk_state != DCCP_REQUESTING && dccp_check_seqno(sk, skb))\n\t\tgoto discard;\n\n\t/*\n\t *   Step 7: Check for unexpected packet types\n\t *      If (S.is_server and P.type == Response)\n\t *\t    or (S.is_client and P.type == Request)\n\t *\t    or (S.state == RESPOND and P.type == Data),\n\t *\t  Send Sync packet acknowledging P.seqno\n\t *\t  Drop packet and return\n\t */\n\tif ((dp->dccps_role != DCCP_ROLE_CLIENT &&\n\t     dh->dccph_type == DCCP_PKT_RESPONSE) ||\n\t    (dp->dccps_role == DCCP_ROLE_CLIENT &&\n\t     dh->dccph_type == DCCP_PKT_REQUEST) ||\n\t    (sk->sk_state == DCCP_RESPOND && dh->dccph_type == DCCP_PKT_DATA)) {\n\t\tdccp_send_sync(sk, dcb->dccpd_seq, DCCP_PKT_SYNC);\n\t\tgoto discard;\n\t}\n\n\t/*  Step 8: Process options */\n\tif (dccp_parse_options(sk, NULL, skb))\n\t\treturn 1;\n\n\t/*\n\t *  Step 9: Process Reset\n\t *\tIf P.type == Reset,\n\t *\t\tTear down connection\n\t *\t\tS.state := TIMEWAIT\n\t *\t\tSet TIMEWAIT timer\n\t *\t\tDrop packet and return\n\t */\n\tif (dh->dccph_type == DCCP_PKT_RESET) {\n\t\tdccp_rcv_reset(sk, skb);\n\t\treturn 0;\n\t} else if (dh->dccph_type == DCCP_PKT_CLOSEREQ) {\t/* Step 13 */\n\t\tif (dccp_rcv_closereq(sk, skb))\n\t\t\treturn 0;\n\t\tgoto discard;\n\t} else if (dh->dccph_type == DCCP_PKT_CLOSE) {\t\t/* Step 14 */\n\t\tif (dccp_rcv_close(sk, skb))\n\t\t\treturn 0;\n\t\tgoto discard;\n\t}\n\n\tswitch (sk->sk_state) {\n\tcase DCCP_REQUESTING:\n\t\tqueued = dccp_rcv_request_sent_state_process(sk, skb, dh, len);\n\t\tif (queued >= 0)\n\t\t\treturn queued;\n\n\t\t__kfree_skb(skb);\n\t\treturn 0;\n\n\tcase DCCP_PARTOPEN:\n\t\t/* Step 8: if using Ack Vectors, mark packet acknowledgeable */\n\t\tdccp_handle_ackvec_processing(sk, skb);\n\t\tdccp_deliver_input_to_ccids(sk, skb);\n\t\t/* fall through */\n\tcase DCCP_RESPOND:\n\t\tqueued = dccp_rcv_respond_partopen_state_process(sk, skb,\n\t\t\t\t\t\t\t\t dh, len);\n\t\tbreak;\n\t}\n\n\tif (dh->dccph_type == DCCP_PKT_ACK ||\n\t    dh->dccph_type == DCCP_PKT_DATAACK) {\n\t\tswitch (old_state) {\n\t\tcase DCCP_PARTOPEN:\n\t\t\tsk->sk_state_change(sk);\n\t\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);\n\t\t\tbreak;\n\t\t}\n\t} else if (unlikely(dh->dccph_type == DCCP_PKT_SYNC)) {\n\t\tdccp_send_sync(sk, dcb->dccpd_seq, DCCP_PKT_SYNCACK);\n\t\tgoto discard;\n\t}\n\n\tif (!queued) {\ndiscard:\n\t\t__kfree_skb(skb);\n\t}\n\treturn 0;\n}\n\nEXPORT_SYMBOL_GPL(dccp_rcv_state_process);\n\n/**\n *  dccp_sample_rtt  -  Validate and finalise computation of RTT sample\n *  @delta:\tnumber of microseconds between packet and acknowledgment\n *\n *  The routine is kept generic to work in different contexts. It should be\n *  called immediately when the ACK used for the RTT sample arrives.\n */\nu32 dccp_sample_rtt(struct sock *sk, long delta)\n{\n\t/* dccpor_elapsed_time is either zeroed out or set and > 0 */\n\tdelta -= dccp_sk(sk)->dccps_options_received.dccpor_elapsed_time * 10;\n\n\tif (unlikely(delta <= 0)) {\n\t\tDCCP_WARN(\"unusable RTT sample %ld, using min\\n\", delta);\n\t\treturn DCCP_SANE_RTT_MIN;\n\t}\n\tif (unlikely(delta > DCCP_SANE_RTT_MAX)) {\n\t\tDCCP_WARN(\"RTT sample %ld too large, using max\\n\", delta);\n\t\treturn DCCP_SANE_RTT_MAX;\n\t}\n\n\treturn delta;\n}\n"], "fixing_code": ["/*\n *  net/dccp/input.c\n *\n *  An implementation of the DCCP protocol\n *  Arnaldo Carvalho de Melo <acme@conectiva.com.br>\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License\n *\tas published by the Free Software Foundation; either version\n *\t2 of the License, or (at your option) any later version.\n */\n\n#include <linux/dccp.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n\n#include <net/sock.h>\n\n#include \"ackvec.h\"\n#include \"ccid.h\"\n#include \"dccp.h\"\n\n/* rate-limit for syncs in reply to sequence-invalid packets; RFC 4340, 7.5.4 */\nint sysctl_dccp_sync_ratelimit\t__read_mostly = HZ / 8;\n\nstatic void dccp_enqueue_skb(struct sock *sk, struct sk_buff *skb)\n{\n\t__skb_pull(skb, dccp_hdr(skb)->dccph_doff * 4);\n\t__skb_queue_tail(&sk->sk_receive_queue, skb);\n\tskb_set_owner_r(skb, sk);\n\tsk->sk_data_ready(sk);\n}\n\nstatic void dccp_fin(struct sock *sk, struct sk_buff *skb)\n{\n\t/*\n\t * On receiving Close/CloseReq, both RD/WR shutdown are performed.\n\t * RFC 4340, 8.3 says that we MAY send further Data/DataAcks after\n\t * receiving the closing segment, but there is no guarantee that such\n\t * data will be processed at all.\n\t */\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tsock_set_flag(sk, SOCK_DONE);\n\tdccp_enqueue_skb(sk, skb);\n}\n\nstatic int dccp_rcv_close(struct sock *sk, struct sk_buff *skb)\n{\n\tint queued = 0;\n\n\tswitch (sk->sk_state) {\n\t/*\n\t * We ignore Close when received in one of the following states:\n\t *  - CLOSED\t\t(may be a late or duplicate packet)\n\t *  - PASSIVE_CLOSEREQ\t(the peer has sent a CloseReq earlier)\n\t *  - RESPOND\t\t(already handled by dccp_check_req)\n\t */\n\tcase DCCP_CLOSING:\n\t\t/*\n\t\t * Simultaneous-close: receiving a Close after sending one. This\n\t\t * can happen if both client and server perform active-close and\n\t\t * will result in an endless ping-pong of crossing and retrans-\n\t\t * mitted Close packets, which only terminates when one of the\n\t\t * nodes times out (min. 64 seconds). Quicker convergence can be\n\t\t * achieved when one of the nodes acts as tie-breaker.\n\t\t * This is ok as both ends are done with data transfer and each\n\t\t * end is just waiting for the other to acknowledge termination.\n\t\t */\n\t\tif (dccp_sk(sk)->dccps_role != DCCP_ROLE_CLIENT)\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase DCCP_REQUESTING:\n\tcase DCCP_ACTIVE_CLOSEREQ:\n\t\tdccp_send_reset(sk, DCCP_RESET_CODE_CLOSED);\n\t\tdccp_done(sk);\n\t\tbreak;\n\tcase DCCP_OPEN:\n\tcase DCCP_PARTOPEN:\n\t\t/* Give waiting application a chance to read pending data */\n\t\tqueued = 1;\n\t\tdccp_fin(sk, skb);\n\t\tdccp_set_state(sk, DCCP_PASSIVE_CLOSE);\n\t\t/* fall through */\n\tcase DCCP_PASSIVE_CLOSE:\n\t\t/*\n\t\t * Retransmitted Close: we have already enqueued the first one.\n\t\t */\n\t\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_HUP);\n\t}\n\treturn queued;\n}\n\nstatic int dccp_rcv_closereq(struct sock *sk, struct sk_buff *skb)\n{\n\tint queued = 0;\n\n\t/*\n\t *   Step 7: Check for unexpected packet types\n\t *      If (S.is_server and P.type == CloseReq)\n\t *\t  Send Sync packet acknowledging P.seqno\n\t *\t  Drop packet and return\n\t */\n\tif (dccp_sk(sk)->dccps_role != DCCP_ROLE_CLIENT) {\n\t\tdccp_send_sync(sk, DCCP_SKB_CB(skb)->dccpd_seq, DCCP_PKT_SYNC);\n\t\treturn queued;\n\t}\n\n\t/* Step 13: process relevant Client states < CLOSEREQ */\n\tswitch (sk->sk_state) {\n\tcase DCCP_REQUESTING:\n\t\tdccp_send_close(sk, 0);\n\t\tdccp_set_state(sk, DCCP_CLOSING);\n\t\tbreak;\n\tcase DCCP_OPEN:\n\tcase DCCP_PARTOPEN:\n\t\t/* Give waiting application a chance to read pending data */\n\t\tqueued = 1;\n\t\tdccp_fin(sk, skb);\n\t\tdccp_set_state(sk, DCCP_PASSIVE_CLOSEREQ);\n\t\t/* fall through */\n\tcase DCCP_PASSIVE_CLOSEREQ:\n\t\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_HUP);\n\t}\n\treturn queued;\n}\n\nstatic u16 dccp_reset_code_convert(const u8 code)\n{\n\tconst u16 error_code[] = {\n\t[DCCP_RESET_CODE_CLOSED]\t     = 0,\t/* normal termination */\n\t[DCCP_RESET_CODE_UNSPECIFIED]\t     = 0,\t/* nothing known */\n\t[DCCP_RESET_CODE_ABORTED]\t     = ECONNRESET,\n\n\t[DCCP_RESET_CODE_NO_CONNECTION]\t     = ECONNREFUSED,\n\t[DCCP_RESET_CODE_CONNECTION_REFUSED] = ECONNREFUSED,\n\t[DCCP_RESET_CODE_TOO_BUSY]\t     = EUSERS,\n\t[DCCP_RESET_CODE_AGGRESSION_PENALTY] = EDQUOT,\n\n\t[DCCP_RESET_CODE_PACKET_ERROR]\t     = ENOMSG,\n\t[DCCP_RESET_CODE_BAD_INIT_COOKIE]    = EBADR,\n\t[DCCP_RESET_CODE_BAD_SERVICE_CODE]   = EBADRQC,\n\t[DCCP_RESET_CODE_OPTION_ERROR]\t     = EILSEQ,\n\t[DCCP_RESET_CODE_MANDATORY_ERROR]    = EOPNOTSUPP,\n\t};\n\n\treturn code >= DCCP_MAX_RESET_CODES ? 0 : error_code[code];\n}\n\nstatic void dccp_rcv_reset(struct sock *sk, struct sk_buff *skb)\n{\n\tu16 err = dccp_reset_code_convert(dccp_hdr_reset(skb)->dccph_reset_code);\n\n\tsk->sk_err = err;\n\n\t/* Queue the equivalent of TCP fin so that dccp_recvmsg exits the loop */\n\tdccp_fin(sk, skb);\n\n\tif (err && !sock_flag(sk, SOCK_DEAD))\n\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_ERR);\n\tdccp_time_wait(sk, DCCP_TIME_WAIT, 0);\n}\n\nstatic void dccp_handle_ackvec_processing(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct dccp_ackvec *av = dccp_sk(sk)->dccps_hc_rx_ackvec;\n\n\tif (av == NULL)\n\t\treturn;\n\tif (DCCP_SKB_CB(skb)->dccpd_ack_seq != DCCP_PKT_WITHOUT_ACK_SEQ)\n\t\tdccp_ackvec_clear_state(av, DCCP_SKB_CB(skb)->dccpd_ack_seq);\n\tdccp_ackvec_input(av, skb);\n}\n\nstatic void dccp_deliver_input_to_ccids(struct sock *sk, struct sk_buff *skb)\n{\n\tconst struct dccp_sock *dp = dccp_sk(sk);\n\n\t/* Don't deliver to RX CCID when node has shut down read end. */\n\tif (!(sk->sk_shutdown & RCV_SHUTDOWN))\n\t\tccid_hc_rx_packet_recv(dp->dccps_hc_rx_ccid, sk, skb);\n\t/*\n\t * Until the TX queue has been drained, we can not honour SHUT_WR, since\n\t * we need received feedback as input to adjust congestion control.\n\t */\n\tif (sk->sk_write_queue.qlen > 0 || !(sk->sk_shutdown & SEND_SHUTDOWN))\n\t\tccid_hc_tx_packet_recv(dp->dccps_hc_tx_ccid, sk, skb);\n}\n\nstatic int dccp_check_seqno(struct sock *sk, struct sk_buff *skb)\n{\n\tconst struct dccp_hdr *dh = dccp_hdr(skb);\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tu64 lswl, lawl, seqno = DCCP_SKB_CB(skb)->dccpd_seq,\n\t\t\tackno = DCCP_SKB_CB(skb)->dccpd_ack_seq;\n\n\t/*\n\t *   Step 5: Prepare sequence numbers for Sync\n\t *     If P.type == Sync or P.type == SyncAck,\n\t *\t  If S.AWL <= P.ackno <= S.AWH and P.seqno >= S.SWL,\n\t *\t     / * P is valid, so update sequence number variables\n\t *\t\t accordingly.  After this update, P will pass the tests\n\t *\t\t in Step 6.  A SyncAck is generated if necessary in\n\t *\t\t Step 15 * /\n\t *\t     Update S.GSR, S.SWL, S.SWH\n\t *\t  Otherwise,\n\t *\t     Drop packet and return\n\t */\n\tif (dh->dccph_type == DCCP_PKT_SYNC ||\n\t    dh->dccph_type == DCCP_PKT_SYNCACK) {\n\t\tif (between48(ackno, dp->dccps_awl, dp->dccps_awh) &&\n\t\t    dccp_delta_seqno(dp->dccps_swl, seqno) >= 0)\n\t\t\tdccp_update_gsr(sk, seqno);\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\t/*\n\t *   Step 6: Check sequence numbers\n\t *      Let LSWL = S.SWL and LAWL = S.AWL\n\t *      If P.type == CloseReq or P.type == Close or P.type == Reset,\n\t *\t  LSWL := S.GSR + 1, LAWL := S.GAR\n\t *      If LSWL <= P.seqno <= S.SWH\n\t *\t     and (P.ackno does not exist or LAWL <= P.ackno <= S.AWH),\n\t *\t  Update S.GSR, S.SWL, S.SWH\n\t *\t  If P.type != Sync,\n\t *\t     Update S.GAR\n\t */\n\tlswl = dp->dccps_swl;\n\tlawl = dp->dccps_awl;\n\n\tif (dh->dccph_type == DCCP_PKT_CLOSEREQ ||\n\t    dh->dccph_type == DCCP_PKT_CLOSE ||\n\t    dh->dccph_type == DCCP_PKT_RESET) {\n\t\tlswl = ADD48(dp->dccps_gsr, 1);\n\t\tlawl = dp->dccps_gar;\n\t}\n\n\tif (between48(seqno, lswl, dp->dccps_swh) &&\n\t    (ackno == DCCP_PKT_WITHOUT_ACK_SEQ ||\n\t     between48(ackno, lawl, dp->dccps_awh))) {\n\t\tdccp_update_gsr(sk, seqno);\n\n\t\tif (dh->dccph_type != DCCP_PKT_SYNC &&\n\t\t    ackno != DCCP_PKT_WITHOUT_ACK_SEQ &&\n\t\t    after48(ackno, dp->dccps_gar))\n\t\t\tdp->dccps_gar = ackno;\n\t} else {\n\t\tunsigned long now = jiffies;\n\t\t/*\n\t\t *   Step 6: Check sequence numbers\n\t\t *      Otherwise,\n\t\t *         If P.type == Reset,\n\t\t *            Send Sync packet acknowledging S.GSR\n\t\t *         Otherwise,\n\t\t *            Send Sync packet acknowledging P.seqno\n\t\t *      Drop packet and return\n\t\t *\n\t\t *   These Syncs are rate-limited as per RFC 4340, 7.5.4:\n\t\t *   at most 1 / (dccp_sync_rate_limit * HZ) Syncs per second.\n\t\t */\n\t\tif (time_before(now, (dp->dccps_rate_last +\n\t\t\t\t      sysctl_dccp_sync_ratelimit)))\n\t\t\treturn -1;\n\n\t\tDCCP_WARN(\"Step 6 failed for %s packet, \"\n\t\t\t  \"(LSWL(%llu) <= P.seqno(%llu) <= S.SWH(%llu)) and \"\n\t\t\t  \"(P.ackno %s or LAWL(%llu) <= P.ackno(%llu) <= S.AWH(%llu), \"\n\t\t\t  \"sending SYNC...\\n\",  dccp_packet_name(dh->dccph_type),\n\t\t\t  (unsigned long long) lswl, (unsigned long long) seqno,\n\t\t\t  (unsigned long long) dp->dccps_swh,\n\t\t\t  (ackno == DCCP_PKT_WITHOUT_ACK_SEQ) ? \"doesn't exist\"\n\t\t\t\t\t\t\t      : \"exists\",\n\t\t\t  (unsigned long long) lawl, (unsigned long long) ackno,\n\t\t\t  (unsigned long long) dp->dccps_awh);\n\n\t\tdp->dccps_rate_last = now;\n\n\t\tif (dh->dccph_type == DCCP_PKT_RESET)\n\t\t\tseqno = dp->dccps_gsr;\n\t\tdccp_send_sync(sk, seqno, DCCP_PKT_SYNC);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int __dccp_rcv_established(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  const struct dccp_hdr *dh, const unsigned int len)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\n\tswitch (dccp_hdr(skb)->dccph_type) {\n\tcase DCCP_PKT_DATAACK:\n\tcase DCCP_PKT_DATA:\n\t\t/*\n\t\t * FIXME: schedule DATA_DROPPED (RFC 4340, 11.7.2) if and when\n\t\t * - sk_shutdown == RCV_SHUTDOWN, use Code 1, \"Not Listening\"\n\t\t * - sk_receive_queue is full, use Code 2, \"Receive Buffer\"\n\t\t */\n\t\tdccp_enqueue_skb(sk, skb);\n\t\treturn 0;\n\tcase DCCP_PKT_ACK:\n\t\tgoto discard;\n\tcase DCCP_PKT_RESET:\n\t\t/*\n\t\t *  Step 9: Process Reset\n\t\t *\tIf P.type == Reset,\n\t\t *\t\tTear down connection\n\t\t *\t\tS.state := TIMEWAIT\n\t\t *\t\tSet TIMEWAIT timer\n\t\t *\t\tDrop packet and return\n\t\t */\n\t\tdccp_rcv_reset(sk, skb);\n\t\treturn 0;\n\tcase DCCP_PKT_CLOSEREQ:\n\t\tif (dccp_rcv_closereq(sk, skb))\n\t\t\treturn 0;\n\t\tgoto discard;\n\tcase DCCP_PKT_CLOSE:\n\t\tif (dccp_rcv_close(sk, skb))\n\t\t\treturn 0;\n\t\tgoto discard;\n\tcase DCCP_PKT_REQUEST:\n\t\t/* Step 7\n\t\t *   or (S.is_server and P.type == Response)\n\t\t *   or (S.is_client and P.type == Request)\n\t\t *   or (S.state >= OPEN and P.type == Request\n\t\t *\tand P.seqno >= S.OSR)\n\t\t *    or (S.state >= OPEN and P.type == Response\n\t\t *\tand P.seqno >= S.OSR)\n\t\t *    or (S.state == RESPOND and P.type == Data),\n\t\t *  Send Sync packet acknowledging P.seqno\n\t\t *  Drop packet and return\n\t\t */\n\t\tif (dp->dccps_role != DCCP_ROLE_LISTEN)\n\t\t\tgoto send_sync;\n\t\tgoto check_seq;\n\tcase DCCP_PKT_RESPONSE:\n\t\tif (dp->dccps_role != DCCP_ROLE_CLIENT)\n\t\t\tgoto send_sync;\ncheck_seq:\n\t\tif (dccp_delta_seqno(dp->dccps_osr,\n\t\t\t\t     DCCP_SKB_CB(skb)->dccpd_seq) >= 0) {\nsend_sync:\n\t\t\tdccp_send_sync(sk, DCCP_SKB_CB(skb)->dccpd_seq,\n\t\t\t\t       DCCP_PKT_SYNC);\n\t\t}\n\t\tbreak;\n\tcase DCCP_PKT_SYNC:\n\t\tdccp_send_sync(sk, DCCP_SKB_CB(skb)->dccpd_seq,\n\t\t\t       DCCP_PKT_SYNCACK);\n\t\t/*\n\t\t * From RFC 4340, sec. 5.7\n\t\t *\n\t\t * As with DCCP-Ack packets, DCCP-Sync and DCCP-SyncAck packets\n\t\t * MAY have non-zero-length application data areas, whose\n\t\t * contents receivers MUST ignore.\n\t\t */\n\t\tgoto discard;\n\t}\n\n\tDCCP_INC_STATS(DCCP_MIB_INERRS);\ndiscard:\n\t__kfree_skb(skb);\n\treturn 0;\n}\n\nint dccp_rcv_established(struct sock *sk, struct sk_buff *skb,\n\t\t\t const struct dccp_hdr *dh, const unsigned int len)\n{\n\tif (dccp_check_seqno(sk, skb))\n\t\tgoto discard;\n\n\tif (dccp_parse_options(sk, NULL, skb))\n\t\treturn 1;\n\n\tdccp_handle_ackvec_processing(sk, skb);\n\tdccp_deliver_input_to_ccids(sk, skb);\n\n\treturn __dccp_rcv_established(sk, skb, dh, len);\ndiscard:\n\t__kfree_skb(skb);\n\treturn 0;\n}\n\nEXPORT_SYMBOL_GPL(dccp_rcv_established);\n\nstatic int dccp_rcv_request_sent_state_process(struct sock *sk,\n\t\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t\t       const struct dccp_hdr *dh,\n\t\t\t\t\t       const unsigned int len)\n{\n\t/*\n\t *  Step 4: Prepare sequence numbers in REQUEST\n\t *     If S.state == REQUEST,\n\t *\t  If (P.type == Response or P.type == Reset)\n\t *\t\tand S.AWL <= P.ackno <= S.AWH,\n\t *\t     / * Set sequence number variables corresponding to the\n\t *\t\tother endpoint, so P will pass the tests in Step 6 * /\n\t *\t     Set S.GSR, S.ISR, S.SWL, S.SWH\n\t *\t     / * Response processing continues in Step 10; Reset\n\t *\t\tprocessing continues in Step 9 * /\n\t*/\n\tif (dh->dccph_type == DCCP_PKT_RESPONSE) {\n\t\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\t\tstruct dccp_sock *dp = dccp_sk(sk);\n\t\tlong tstamp = dccp_timestamp();\n\n\t\tif (!between48(DCCP_SKB_CB(skb)->dccpd_ack_seq,\n\t\t\t       dp->dccps_awl, dp->dccps_awh)) {\n\t\t\tdccp_pr_debug(\"invalid ackno: S.AWL=%llu, \"\n\t\t\t\t      \"P.ackno=%llu, S.AWH=%llu\\n\",\n\t\t\t\t      (unsigned long long)dp->dccps_awl,\n\t\t\t   (unsigned long long)DCCP_SKB_CB(skb)->dccpd_ack_seq,\n\t\t\t\t      (unsigned long long)dp->dccps_awh);\n\t\t\tgoto out_invalid_packet;\n\t\t}\n\n\t\t/*\n\t\t * If option processing (Step 8) failed, return 1 here so that\n\t\t * dccp_v4_do_rcv() sends a Reset. The Reset code depends on\n\t\t * the option type and is set in dccp_parse_options().\n\t\t */\n\t\tif (dccp_parse_options(sk, NULL, skb))\n\t\t\treturn 1;\n\n\t\t/* Obtain usec RTT sample from SYN exchange (used by TFRC). */\n\t\tif (likely(dp->dccps_options_received.dccpor_timestamp_echo))\n\t\t\tdp->dccps_syn_rtt = dccp_sample_rtt(sk, 10 * (tstamp -\n\t\t\t    dp->dccps_options_received.dccpor_timestamp_echo));\n\n\t\t/* Stop the REQUEST timer */\n\t\tinet_csk_clear_xmit_timer(sk, ICSK_TIME_RETRANS);\n\t\tWARN_ON(sk->sk_send_head == NULL);\n\t\tkfree_skb(sk->sk_send_head);\n\t\tsk->sk_send_head = NULL;\n\n\t\t/*\n\t\t * Set ISR, GSR from packet. ISS was set in dccp_v{4,6}_connect\n\t\t * and GSS in dccp_transmit_skb(). Setting AWL/AWH and SWL/SWH\n\t\t * is done as part of activating the feature values below, since\n\t\t * these settings depend on the local/remote Sequence Window\n\t\t * features, which were undefined or not confirmed until now.\n\t\t */\n\t\tdp->dccps_gsr = dp->dccps_isr = DCCP_SKB_CB(skb)->dccpd_seq;\n\n\t\tdccp_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\n\t\t/*\n\t\t *    Step 10: Process REQUEST state (second part)\n\t\t *       If S.state == REQUEST,\n\t\t *\t  / * If we get here, P is a valid Response from the\n\t\t *\t      server (see Step 4), and we should move to\n\t\t *\t      PARTOPEN state. PARTOPEN means send an Ack,\n\t\t *\t      don't send Data packets, retransmit Acks\n\t\t *\t      periodically, and always include any Init Cookie\n\t\t *\t      from the Response * /\n\t\t *\t  S.state := PARTOPEN\n\t\t *\t  Set PARTOPEN timer\n\t\t *\t  Continue with S.state == PARTOPEN\n\t\t *\t  / * Step 12 will send the Ack completing the\n\t\t *\t      three-way handshake * /\n\t\t */\n\t\tdccp_set_state(sk, DCCP_PARTOPEN);\n\n\t\t/*\n\t\t * If feature negotiation was successful, activate features now;\n\t\t * an activation failure means that this host could not activate\n\t\t * one ore more features (e.g. insufficient memory), which would\n\t\t * leave at least one feature in an undefined state.\n\t\t */\n\t\tif (dccp_feat_activate_values(sk, &dp->dccps_featneg))\n\t\t\tgoto unable_to_proceed;\n\n\t\t/* Make sure socket is routed, for correct metrics. */\n\t\ticsk->icsk_af_ops->rebuild_header(sk);\n\n\t\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\t\tsk->sk_state_change(sk);\n\t\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);\n\t\t}\n\n\t\tif (sk->sk_write_pending || icsk->icsk_ack.pingpong ||\n\t\t    icsk->icsk_accept_queue.rskq_defer_accept) {\n\t\t\t/* Save one ACK. Data will be ready after\n\t\t\t * several ticks, if write_pending is set.\n\t\t\t *\n\t\t\t * It may be deleted, but with this feature tcpdumps\n\t\t\t * look so _wonderfully_ clever, that I was not able\n\t\t\t * to stand against the temptation 8)     --ANK\n\t\t\t */\n\t\t\t/*\n\t\t\t * OK, in DCCP we can as well do a similar trick, its\n\t\t\t * even in the draft, but there is no need for us to\n\t\t\t * schedule an ack here, as dccp_sendmsg does this for\n\t\t\t * us, also stated in the draft. -acme\n\t\t\t */\n\t\t\t__kfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\tdccp_send_ack(sk);\n\t\treturn -1;\n\t}\n\nout_invalid_packet:\n\t/* dccp_v4_do_rcv will send a reset */\n\tDCCP_SKB_CB(skb)->dccpd_reset_code = DCCP_RESET_CODE_PACKET_ERROR;\n\treturn 1;\n\nunable_to_proceed:\n\tDCCP_SKB_CB(skb)->dccpd_reset_code = DCCP_RESET_CODE_ABORTED;\n\t/*\n\t * We mark this socket as no longer usable, so that the loop in\n\t * dccp_sendmsg() terminates and the application gets notified.\n\t */\n\tdccp_set_state(sk, DCCP_CLOSED);\n\tsk->sk_err = ECOMM;\n\treturn 1;\n}\n\nstatic int dccp_rcv_respond_partopen_state_process(struct sock *sk,\n\t\t\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t\t\t   const struct dccp_hdr *dh,\n\t\t\t\t\t\t   const unsigned int len)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tu32 sample = dp->dccps_options_received.dccpor_timestamp_echo;\n\tint queued = 0;\n\n\tswitch (dh->dccph_type) {\n\tcase DCCP_PKT_RESET:\n\t\tinet_csk_clear_xmit_timer(sk, ICSK_TIME_DACK);\n\t\tbreak;\n\tcase DCCP_PKT_DATA:\n\t\tif (sk->sk_state == DCCP_RESPOND)\n\t\t\tbreak;\n\tcase DCCP_PKT_DATAACK:\n\tcase DCCP_PKT_ACK:\n\t\t/*\n\t\t * FIXME: we should be resetting the PARTOPEN (DELACK) timer\n\t\t * here but only if we haven't used the DELACK timer for\n\t\t * something else, like sending a delayed ack for a TIMESTAMP\n\t\t * echo, etc, for now were not clearing it, sending an extra\n\t\t * ACK when there is nothing else to do in DELACK is not a big\n\t\t * deal after all.\n\t\t */\n\n\t\t/* Stop the PARTOPEN timer */\n\t\tif (sk->sk_state == DCCP_PARTOPEN)\n\t\t\tinet_csk_clear_xmit_timer(sk, ICSK_TIME_DACK);\n\n\t\t/* Obtain usec RTT sample from SYN exchange (used by TFRC). */\n\t\tif (likely(sample)) {\n\t\t\tlong delta = dccp_timestamp() - sample;\n\n\t\t\tdp->dccps_syn_rtt = dccp_sample_rtt(sk, 10 * delta);\n\t\t}\n\n\t\tdp->dccps_osr = DCCP_SKB_CB(skb)->dccpd_seq;\n\t\tdccp_set_state(sk, DCCP_OPEN);\n\n\t\tif (dh->dccph_type == DCCP_PKT_DATAACK ||\n\t\t    dh->dccph_type == DCCP_PKT_DATA) {\n\t\t\t__dccp_rcv_established(sk, skb, dh, len);\n\t\t\tqueued = 1; /* packet was queued\n\t\t\t\t       (by __dccp_rcv_established) */\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn queued;\n}\n\nint dccp_rcv_state_process(struct sock *sk, struct sk_buff *skb,\n\t\t\t   struct dccp_hdr *dh, unsigned int len)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tstruct dccp_skb_cb *dcb = DCCP_SKB_CB(skb);\n\tconst int old_state = sk->sk_state;\n\tint queued = 0;\n\n\t/*\n\t *  Step 3: Process LISTEN state\n\t *\n\t *     If S.state == LISTEN,\n\t *\t If P.type == Request or P contains a valid Init Cookie option,\n\t *\t      (* Must scan the packet's options to check for Init\n\t *\t\t Cookies.  Only Init Cookies are processed here,\n\t *\t\t however; other options are processed in Step 8.  This\n\t *\t\t scan need only be performed if the endpoint uses Init\n\t *\t\t Cookies *)\n\t *\t      (* Generate a new socket and switch to that socket *)\n\t *\t      Set S := new socket for this port pair\n\t *\t      S.state = RESPOND\n\t *\t      Choose S.ISS (initial seqno) or set from Init Cookies\n\t *\t      Initialize S.GAR := S.ISS\n\t *\t      Set S.ISR, S.GSR, S.SWL, S.SWH from packet or Init\n\t *\t      Cookies Continue with S.state == RESPOND\n\t *\t      (* A Response packet will be generated in Step 11 *)\n\t *\t Otherwise,\n\t *\t      Generate Reset(No Connection) unless P.type == Reset\n\t *\t      Drop packet and return\n\t */\n\tif (sk->sk_state == DCCP_LISTEN) {\n\t\tif (dh->dccph_type == DCCP_PKT_REQUEST) {\n\t\t\tif (inet_csk(sk)->icsk_af_ops->conn_request(sk,\n\t\t\t\t\t\t\t\t    skb) < 0)\n\t\t\t\treturn 1;\n\t\t\tconsume_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\tif (dh->dccph_type == DCCP_PKT_RESET)\n\t\t\tgoto discard;\n\n\t\t/* Caller (dccp_v4_do_rcv) will send Reset */\n\t\tdcb->dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION;\n\t\treturn 1;\n\t} else if (sk->sk_state == DCCP_CLOSED) {\n\t\tdcb->dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION;\n\t\treturn 1;\n\t}\n\n\t/* Step 6: Check sequence numbers (omitted in LISTEN/REQUEST state) */\n\tif (sk->sk_state != DCCP_REQUESTING && dccp_check_seqno(sk, skb))\n\t\tgoto discard;\n\n\t/*\n\t *   Step 7: Check for unexpected packet types\n\t *      If (S.is_server and P.type == Response)\n\t *\t    or (S.is_client and P.type == Request)\n\t *\t    or (S.state == RESPOND and P.type == Data),\n\t *\t  Send Sync packet acknowledging P.seqno\n\t *\t  Drop packet and return\n\t */\n\tif ((dp->dccps_role != DCCP_ROLE_CLIENT &&\n\t     dh->dccph_type == DCCP_PKT_RESPONSE) ||\n\t    (dp->dccps_role == DCCP_ROLE_CLIENT &&\n\t     dh->dccph_type == DCCP_PKT_REQUEST) ||\n\t    (sk->sk_state == DCCP_RESPOND && dh->dccph_type == DCCP_PKT_DATA)) {\n\t\tdccp_send_sync(sk, dcb->dccpd_seq, DCCP_PKT_SYNC);\n\t\tgoto discard;\n\t}\n\n\t/*  Step 8: Process options */\n\tif (dccp_parse_options(sk, NULL, skb))\n\t\treturn 1;\n\n\t/*\n\t *  Step 9: Process Reset\n\t *\tIf P.type == Reset,\n\t *\t\tTear down connection\n\t *\t\tS.state := TIMEWAIT\n\t *\t\tSet TIMEWAIT timer\n\t *\t\tDrop packet and return\n\t */\n\tif (dh->dccph_type == DCCP_PKT_RESET) {\n\t\tdccp_rcv_reset(sk, skb);\n\t\treturn 0;\n\t} else if (dh->dccph_type == DCCP_PKT_CLOSEREQ) {\t/* Step 13 */\n\t\tif (dccp_rcv_closereq(sk, skb))\n\t\t\treturn 0;\n\t\tgoto discard;\n\t} else if (dh->dccph_type == DCCP_PKT_CLOSE) {\t\t/* Step 14 */\n\t\tif (dccp_rcv_close(sk, skb))\n\t\t\treturn 0;\n\t\tgoto discard;\n\t}\n\n\tswitch (sk->sk_state) {\n\tcase DCCP_REQUESTING:\n\t\tqueued = dccp_rcv_request_sent_state_process(sk, skb, dh, len);\n\t\tif (queued >= 0)\n\t\t\treturn queued;\n\n\t\t__kfree_skb(skb);\n\t\treturn 0;\n\n\tcase DCCP_PARTOPEN:\n\t\t/* Step 8: if using Ack Vectors, mark packet acknowledgeable */\n\t\tdccp_handle_ackvec_processing(sk, skb);\n\t\tdccp_deliver_input_to_ccids(sk, skb);\n\t\t/* fall through */\n\tcase DCCP_RESPOND:\n\t\tqueued = dccp_rcv_respond_partopen_state_process(sk, skb,\n\t\t\t\t\t\t\t\t dh, len);\n\t\tbreak;\n\t}\n\n\tif (dh->dccph_type == DCCP_PKT_ACK ||\n\t    dh->dccph_type == DCCP_PKT_DATAACK) {\n\t\tswitch (old_state) {\n\t\tcase DCCP_PARTOPEN:\n\t\t\tsk->sk_state_change(sk);\n\t\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);\n\t\t\tbreak;\n\t\t}\n\t} else if (unlikely(dh->dccph_type == DCCP_PKT_SYNC)) {\n\t\tdccp_send_sync(sk, dcb->dccpd_seq, DCCP_PKT_SYNCACK);\n\t\tgoto discard;\n\t}\n\n\tif (!queued) {\ndiscard:\n\t\t__kfree_skb(skb);\n\t}\n\treturn 0;\n}\n\nEXPORT_SYMBOL_GPL(dccp_rcv_state_process);\n\n/**\n *  dccp_sample_rtt  -  Validate and finalise computation of RTT sample\n *  @delta:\tnumber of microseconds between packet and acknowledgment\n *\n *  The routine is kept generic to work in different contexts. It should be\n *  called immediately when the ACK used for the RTT sample arrives.\n */\nu32 dccp_sample_rtt(struct sock *sk, long delta)\n{\n\t/* dccpor_elapsed_time is either zeroed out or set and > 0 */\n\tdelta -= dccp_sk(sk)->dccps_options_received.dccpor_elapsed_time * 10;\n\n\tif (unlikely(delta <= 0)) {\n\t\tDCCP_WARN(\"unusable RTT sample %ld, using min\\n\", delta);\n\t\treturn DCCP_SANE_RTT_MIN;\n\t}\n\tif (unlikely(delta > DCCP_SANE_RTT_MAX)) {\n\t\tDCCP_WARN(\"RTT sample %ld too large, using max\\n\", delta);\n\t\treturn DCCP_SANE_RTT_MAX;\n\t}\n\n\treturn delta;\n}\n"], "filenames": ["net/dccp/input.c"], "buggy_code_start_loc": [609], "buggy_code_end_loc": [610], "fixing_code_start_loc": [609], "fixing_code_end_loc": [611], "type": "CWE-415", "message": "The dccp_rcv_state_process function in net/dccp/input.c in the Linux kernel through 4.9.11 mishandles DCCP_PKT_REQUEST packet data structures in the LISTEN state, which allows local users to obtain root privileges or cause a denial of service (double free) via an application that makes an IPV6_RECVPKTINFO setsockopt system call.", "other": {"cve": {"id": "CVE-2017-6074", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-18T21:59:00.237", "lastModified": "2023-02-10T00:53:37.297", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The dccp_rcv_state_process function in net/dccp/input.c in the Linux kernel through 4.9.11 mishandles DCCP_PKT_REQUEST packet data structures in the LISTEN state, which allows local users to obtain root privileges or cause a denial of service (double free) via an application that makes an IPV6_RECVPKTINFO setsockopt system call."}, {"lang": "es", "value": "La funci\u00f3n dccp_rcv_state_process en net/dccp/input.c en el kernel de Linux hasta la versi\u00f3n 4.9.11 no maneja adecuadamente estructuras de paquetes de datos DCCP_PKT_REQUEST en el estado LISTEN, lo que permite a usuarios locales obtener privilegios root o provocar una denegaci\u00f3n de servicio (liberaci\u00f3n doble) a trav\u00e9s de una aplicaci\u00f3n que hace una llamada de sistema IPV6_RECVPKTINFO setsockopt."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2.86", "matchCriteriaId": "93414DAF-13C5-4F37-8F16-486DDEFFE6AC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.3", "versionEndExcluding": "3.10.106", "matchCriteriaId": "3116EF11-56E7-4D40-9FD0-6109280D0247"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.11", "versionEndExcluding": "3.12.71", "matchCriteriaId": "714101BC-5F00-4257-A007-F21269AE5AC1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.13", "versionEndExcluding": "3.16.41", "matchCriteriaId": "F5CF2C65-6A2A-44EE-A67B-5DB1663C2B2A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.17", "versionEndExcluding": "3.18.49", "matchCriteriaId": "5AA77834-089F-4556-A00B-CAC1E08444BF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.19", "versionEndExcluding": "4.1.41", "matchCriteriaId": "9019BEC9-FE77-4506-A019-B8B4D8BCEBAE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2", "versionEndExcluding": "4.4.52", "matchCriteriaId": "87F9D322-C14F-4E7A-BA48-87789CAC2DA7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.9.13", "matchCriteriaId": "B5EFB5B2-2EEC-4D04-925A-77FBE0E5E76C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://rhn.redhat.com/errata/RHSA-2017-0293.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2017-0294.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2017-0295.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2017-0316.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2017-0323.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2017-0324.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2017-0345.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2017-0346.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2017-0347.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2017-0365.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2017-0366.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2017-0403.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2017-0501.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2017/dsa-3791", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/02/22/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/security-advisory/cpujul2018-4258247.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/96310", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1037876", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:0932", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1209", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/5edabca9d4cff7f1f2b68f0bac55ef99d9798ba4", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://source.android.com/security/bulletin/2017-07-01", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/41457/", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://www.exploit-db.com/exploits/41458/", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://www.tenable.com/security/tns-2017-07", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/5edabca9d4cff7f1f2b68f0bac55ef99d9798ba4"}}