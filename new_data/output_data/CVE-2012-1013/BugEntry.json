{"buggy_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n * Copyright 1993 OpenVision Technologies, Inc., All Rights Reserved\n *\n * $Header$\n */\n#include \"k5-int.h\"\n#include        <sys/time.h>\n#include        <kadm5/admin.h>\n#include        <kdb.h>\n#include        \"server_internal.h\"\n#ifdef USE_PASSWORD_SERVER\n#include        <sys/wait.h>\n#include        <signal.h>\n#endif\n\n#include <krb5/kadm5_hook_plugin.h>\n\n#ifdef USE_VALGRIND\n#include <valgrind/memcheck.h>\n#else\n#define VALGRIND_CHECK_DEFINED(LVALUE) ((void)0)\n#endif\n\nextern  krb5_principal      master_princ;\nextern  krb5_principal      hist_princ;\nextern  krb5_keyblock       master_keyblock;\nextern  krb5_actkvno_node  *active_mkey_list;\nextern  krb5_db_entry       master_db;\n\nstatic int decrypt_key_data(krb5_context context,\n                            int n_key_data, krb5_key_data *key_data,\n                            krb5_keyblock **keyblocks, int *n_keys);\n\nstatic krb5_error_code\nkadm5_copy_principal(krb5_context context, krb5_const_principal inprinc, krb5_principal *outprinc)\n{\n    register krb5_principal tempprinc;\n    register int i, nelems;\n\n    tempprinc = (krb5_principal)krb5_db_alloc(context, NULL, sizeof(krb5_principal_data));\n\n    if (tempprinc == 0)\n        return ENOMEM;\n\n    VALGRIND_CHECK_DEFINED(*inprinc);\n    *tempprinc = *inprinc;\n\n    nelems = (int) krb5_princ_size(context, inprinc);\n    tempprinc->data = krb5_db_alloc(context, NULL, nelems * sizeof(krb5_data));\n    if (tempprinc->data == 0) {\n        krb5_db_free(context, (char *)tempprinc);\n        return ENOMEM;\n    }\n\n    for (i = 0; i < nelems; i++) {\n        unsigned int len = krb5_princ_component(context, inprinc, i)->length;\n        krb5_princ_component(context, tempprinc, i)->length = len;\n        if (((krb5_princ_component(context, tempprinc, i)->data =\n              krb5_db_alloc(context, NULL, len)) == 0) && len) {\n            while (--i >= 0)\n                krb5_db_free(context, krb5_princ_component(context, tempprinc, i)->data);\n            krb5_db_free (context, tempprinc->data);\n            krb5_db_free (context, tempprinc);\n            return ENOMEM;\n        }\n        if (len)\n            memcpy(krb5_princ_component(context, tempprinc, i)->data,\n                   krb5_princ_component(context, inprinc, i)->data, len);\n        krb5_princ_component(context, tempprinc, i)->magic = KV5M_DATA;\n    }\n\n    tempprinc->realm.data =\n        krb5_db_alloc(context, NULL, tempprinc->realm.length = inprinc->realm.length);\n    if (!tempprinc->realm.data && tempprinc->realm.length) {\n        for (i = 0; i < nelems; i++)\n            krb5_db_free(context, krb5_princ_component(context, tempprinc, i)->data);\n        krb5_db_free(context, tempprinc->data);\n        krb5_db_free(context, tempprinc);\n        return ENOMEM;\n    }\n    if (tempprinc->realm.length)\n        memcpy(tempprinc->realm.data, inprinc->realm.data,\n               inprinc->realm.length);\n\n    *outprinc = tempprinc;\n    return 0;\n}\n\nstatic void\nkadm5_free_principal(krb5_context context, krb5_principal val)\n{\n    register krb5_int32 i;\n\n    if (!val)\n        return;\n\n    if (val->data) {\n        i = krb5_princ_size(context, val);\n        while(--i >= 0)\n            krb5_db_free(context, krb5_princ_component(context, val, i)->data);\n        krb5_db_free(context, val->data);\n    }\n    if (val->realm.data)\n        krb5_db_free(context, val->realm.data);\n    krb5_db_free(context, val);\n}\n\n/*\n * XXX Functions that ought to be in libkrb5.a, but aren't.\n */\nkadm5_ret_t krb5_copy_key_data_contents(context, from, to)\n    krb5_context context;\n    krb5_key_data *from, *to;\n{\n    int i, idx;\n\n    *to = *from;\n\n    idx = (from->key_data_ver == 1 ? 1 : 2);\n\n    for (i = 0; i < idx; i++) {\n        if ( from->key_data_length[i] ) {\n            to->key_data_contents[i] = malloc(from->key_data_length[i]);\n            if (to->key_data_contents[i] == NULL) {\n                for (i = 0; i < idx; i++) {\n                    if (to->key_data_contents[i]) {\n                        memset(to->key_data_contents[i], 0,\n                               to->key_data_length[i]);\n                        free(to->key_data_contents[i]);\n                    }\n                }\n                return ENOMEM;\n            }\n            memcpy(to->key_data_contents[i], from->key_data_contents[i],\n                   from->key_data_length[i]);\n        }\n    }\n    return 0;\n}\n\nstatic krb5_tl_data *dup_tl_data(krb5_tl_data *tl)\n{\n    krb5_tl_data *n;\n\n    n = (krb5_tl_data *) malloc(sizeof(krb5_tl_data));\n    if (n == NULL)\n        return NULL;\n    n->tl_data_contents = malloc(tl->tl_data_length);\n    if (n->tl_data_contents == NULL) {\n        free(n);\n        return NULL;\n    }\n    memcpy(n->tl_data_contents, tl->tl_data_contents, tl->tl_data_length);\n    n->tl_data_type = tl->tl_data_type;\n    n->tl_data_length = tl->tl_data_length;\n    n->tl_data_next = NULL;\n    return n;\n}\n\n/* This is in lib/kdb/kdb_cpw.c, but is static */\nstatic void cleanup_key_data(context, count, data)\n    krb5_context   context;\n    int                    count;\n    krb5_key_data        * data;\n{\n    int i, j;\n\n    for (i = 0; i < count; i++)\n        for (j = 0; j < data[i].key_data_ver; j++)\n            if (data[i].key_data_length[j])\n                krb5_db_free(context, data[i].key_data_contents[j]);\n    krb5_db_free(context, data);\n}\n\n/*\n * Set *passptr to NULL if the request looks like the first part of a krb5 1.6\n * addprinc -randkey operation.  The krb5 1.6 dummy password for these requests\n * was invalid UTF-8, which runs afoul of the arcfour string-to-key.\n */\nstatic void\ncheck_1_6_dummy(kadm5_principal_ent_t entry, long mask,\n                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)\n{\n    int i;\n    char *password = *passptr;\n\n    /* Old-style randkey operations disallowed tickets to start. */\n    if (!(mask & KADM5_ATTRIBUTES) ||\n        !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))\n        return;\n\n    /* The 1.6 dummy password was the octets 1..255. */\n    for (i = 0; (unsigned char) password[i] == i + 1; i++);\n    if (password[i] != '\\0' || i != 255)\n        return;\n\n    /* This will make the caller use a random password instead. */\n    *passptr = NULL;\n}\n\nkadm5_ret_t\nkadm5_create_principal(void *server_handle,\n                       kadm5_principal_ent_t entry, long mask,\n                       char *password)\n{\n    return\n        kadm5_create_principal_3(server_handle, entry, mask,\n                                 0, NULL, password);\n}\nkadm5_ret_t\nkadm5_create_principal_3(void *server_handle,\n                         kadm5_principal_ent_t entry, long mask,\n                         int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                         char *password)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    kadm5_policy_ent_rec        polent;\n    krb5_boolean                have_polent = FALSE;\n    krb5_int32                  now;\n    krb5_tl_data                *tl_data_orig, *tl_data_tail;\n    unsigned int                ret;\n    kadm5_server_handle_t handle = server_handle;\n    krb5_keyblock               *act_mkey;\n    krb5_kvno                   act_kvno;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    check_1_6_dummy(entry, mask, n_ks_tuple, ks_tuple, &password);\n\n    /*\n     * Argument sanity checking, and opening up the DB\n     */\n    if(!(mask & KADM5_PRINCIPAL) || (mask & KADM5_MOD_NAME) ||\n       (mask & KADM5_MOD_TIME) || (mask & KADM5_LAST_PWD_CHANGE) ||\n       (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||\n       (mask & KADM5_KEY_DATA) || (mask & KADM5_LAST_SUCCESS) ||\n       (mask & KADM5_LAST_FAILED) || (mask & KADM5_FAIL_AUTH_COUNT))\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))\n        return KADM5_BAD_MASK;\n    if((mask & ~ALL_PRINC_MASK))\n        return KADM5_BAD_MASK;\n    if (entry == NULL)\n        return EINVAL;\n\n    /* Use default keysalts if caller did not provide any. */\n    if (n_ks_tuple == 0) {\n        ks_tuple = handle->params.keysalts;\n        n_ks_tuple = handle->params.num_keysalts;\n    }\n\n    /*\n     * Check to see if the principal exists\n     */\n    ret = kdb_get_entry(handle, entry->principal, &kdb, &adb);\n\n    switch(ret) {\n    case KADM5_UNK_PRINC:\n        break;\n    case 0:\n        kdb_free_entry(handle, kdb, &adb);\n        return KADM5_DUP;\n    default:\n        return ret;\n    }\n\n    kdb = krb5_db_alloc(handle->context, NULL, sizeof(*kdb));\n    if (kdb == NULL)\n        return ENOMEM;\n    memset(kdb, 0, sizeof(*kdb));\n    memset(&adb, 0, sizeof(osa_princ_ent_rec));\n\n    /*\n     * If a policy was specified, load it.\n     * If we can not find the one specified return an error\n     */\n    if ((mask & KADM5_POLICY)) {\n        if ((ret = kadm5_get_policy(handle->lhandle, entry->policy,\n                                    &polent)) != KADM5_OK) {\n            if (ret == EINVAL)\n                ret = KADM5_BAD_POLICY;\n            if (ret)\n                goto cleanup;\n        }\n        have_polent = TRUE;\n    }\n    if (password) {\n        ret = passwd_check(handle, password, have_polent ? &polent : NULL,\n                           entry->principal);\n        if (ret)\n            goto cleanup;\n    }\n    /*\n     * Start populating the various DB fields, using the\n     * \"defaults\" for fields that were not specified by the\n     * mask.\n     */\n    if ((ret = krb5_timeofday(handle->context, &now)))\n        goto cleanup;\n\n    kdb->magic = KRB5_KDB_MAGIC_NUMBER;\n    kdb->len = KRB5_KDB_V1_BASE_LENGTH; /* gag me with a chainsaw */\n\n    if ((mask & KADM5_ATTRIBUTES))\n        kdb->attributes = entry->attributes;\n    else\n        kdb->attributes = handle->params.flags;\n\n    if ((mask & KADM5_MAX_LIFE))\n        kdb->max_life = entry->max_life;\n    else\n        kdb->max_life = handle->params.max_life;\n\n    if (mask & KADM5_MAX_RLIFE)\n        kdb->max_renewable_life = entry->max_renewable_life;\n    else\n        kdb->max_renewable_life = handle->params.max_rlife;\n\n    if ((mask & KADM5_PRINC_EXPIRE_TIME))\n        kdb->expiration = entry->princ_expire_time;\n    else\n        kdb->expiration = handle->params.expiration;\n\n    kdb->pw_expiration = 0;\n    if (have_polent) {\n        if(polent.pw_max_life)\n            kdb->pw_expiration = now + polent.pw_max_life;\n        else\n            kdb->pw_expiration = 0;\n    }\n    if ((mask & KADM5_PW_EXPIRATION))\n        kdb->pw_expiration = entry->pw_expiration;\n\n    kdb->last_success = 0;\n    kdb->last_failed = 0;\n    kdb->fail_auth_count = 0;\n\n    /* this is kind of gross, but in order to free the tl data, I need\n       to free the entire kdb entry, and that will try to free the\n       principal. */\n\n    if ((ret = kadm5_copy_principal(handle->context,\n                                    entry->principal, &(kdb->princ))))\n        goto cleanup;\n\n    if ((ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now)))\n        goto cleanup;\n\n    if (mask & KADM5_TL_DATA) {\n        /* splice entry->tl_data onto the front of kdb->tl_data */\n        tl_data_orig = kdb->tl_data;\n        for (tl_data_tail = entry->tl_data; tl_data_tail;\n             tl_data_tail = tl_data_tail->tl_data_next)\n        {\n            ret = krb5_dbe_update_tl_data(handle->context, kdb, tl_data_tail);\n            if( ret )\n                goto cleanup;\n        }\n    }\n\n    /* initialize the keys */\n\n    ret = krb5_dbe_find_act_mkey(handle->context, active_mkey_list, &act_kvno,\n                                 &act_mkey);\n    if (ret)\n        goto cleanup;\n\n    if (password) {\n        ret = krb5_dbe_cpw(handle->context, act_mkey, ks_tuple, n_ks_tuple,\n                           password, (mask & KADM5_KVNO)?entry->kvno:1,\n                           FALSE, kdb);\n    } else {\n        /* Null password means create with random key (new in 1.8). */\n        ret = krb5_dbe_crk(handle->context, &master_keyblock,\n                           ks_tuple, n_ks_tuple, FALSE, kdb);\n    }\n    if (ret)\n        goto cleanup;\n\n    /* Record the master key VNO used to encrypt this entry's keys */\n    ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);\n    if (ret)\n        goto cleanup;\n\n    ret = k5_kadm5_hook_create(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, entry, mask,\n                               n_ks_tuple, ks_tuple, password);\n    if (ret)\n        goto cleanup;\n\n    /* populate the admin-server-specific fields.  In the OV server,\n       this used to be in a separate database.  Since there's already\n       marshalling code for the admin fields, to keep things simple,\n       I'm going to keep it, and make all the admin stuff occupy a\n       single tl_data record, */\n\n    adb.admin_history_kvno = INITIAL_HIST_KVNO;\n    if (have_polent) {\n        adb.aux_attributes = KADM5_POLICY;\n\n        /* this does *not* need to be strdup'ed, because adb is xdr */\n        /* encoded in osa_adb_create_princ, and not ever freed */\n\n        adb.policy = entry->policy;\n    }\n\n    /* increment the policy ref count, if any */\n\n    if (have_polent) {\n        polent.policy_refcnt++;\n        if ((ret = kadm5_modify_policy_internal(handle->lhandle, &polent,\n                                                KADM5_REF_COUNT))\n            != KADM5_OK)\n            goto cleanup;\n    }\n\n    /* In all cases key and the principal data is set, let the database provider know */\n    kdb->mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ;\n\n    /* store the new db entry */\n    ret = kdb_put_entry(handle, kdb, &adb);\n\n\n    if (ret) {\n        if (have_polent) {\n            /* decrement the policy ref count */\n\n            polent.policy_refcnt--;\n            /*\n             * if this fails, there's nothing we can do anyway.  the\n             * policy refcount wil be too high.\n             */\n            (void) kadm5_modify_policy_internal(handle->lhandle, &polent,\n                                                KADM5_REF_COUNT);\n        }\n    }\n\n    (void) k5_kadm5_hook_create(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, entry, mask,\n                                n_ks_tuple, ks_tuple, password);\n\ncleanup:\n    krb5_db_free_principal(handle->context, kdb);\n    if (have_polent)\n        (void) kadm5_free_policy_ent(handle->lhandle, &polent);\n    return ret;\n}\n\n\nkadm5_ret_t\nkadm5_delete_principal(void *server_handle, krb5_principal principal)\n{\n    unsigned int                ret;\n    kadm5_policy_ent_rec        polent;\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    kadm5_server_handle_t handle = server_handle;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if (principal == NULL)\n        return EINVAL;\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return(ret);\n    ret = k5_kadm5_hook_remove(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, principal);\n    if (ret) {\n        kdb_free_entry(handle, kdb, &adb);\n        return ret;\n    }\n\n    if ((adb.aux_attributes & KADM5_POLICY)) {\n        if ((ret = kadm5_get_policy(handle->lhandle,\n                                    adb.policy, &polent))\n            == KADM5_OK) {\n            polent.policy_refcnt--;\n            if ((ret = kadm5_modify_policy_internal(handle->lhandle, &polent,\n                                                    KADM5_REF_COUNT))\n                != KADM5_OK) {\n                (void) kadm5_free_policy_ent(handle->lhandle, &polent);\n                kdb_free_entry(handle, kdb, &adb);\n                return(ret);\n            }\n        }\n        if ((ret = kadm5_free_policy_ent(handle->lhandle, &polent))) {\n            kdb_free_entry(handle, kdb, &adb);\n            return ret;\n        }\n    }\n\n    ret = kdb_delete_entry(handle, principal);\n\n    kdb_free_entry(handle, kdb, &adb);\n\n    if (ret == 0)\n        (void) k5_kadm5_hook_remove(handle->context,\n                                    handle->hook_handles,\n                                    KADM5_HOOK_STAGE_POSTCOMMIT, principal);\n\n    return ret;\n}\n\nkadm5_ret_t\nkadm5_modify_principal(void *server_handle,\n                       kadm5_principal_ent_t entry, long mask)\n{\n    int                     ret, ret2, i;\n    kadm5_policy_ent_rec    npol, opol;\n    int                     have_npol = 0, have_opol = 0;\n    krb5_db_entry           *kdb;\n    krb5_tl_data            *tl_data_orig;\n    osa_princ_ent_rec       adb;\n    kadm5_server_handle_t handle = server_handle;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if((mask & KADM5_PRINCIPAL) || (mask & KADM5_LAST_PWD_CHANGE) ||\n       (mask & KADM5_MOD_TIME) || (mask & KADM5_MOD_NAME) ||\n       (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||\n       (mask & KADM5_KEY_DATA) || (mask & KADM5_LAST_SUCCESS) ||\n       (mask & KADM5_LAST_FAILED))\n        return KADM5_BAD_MASK;\n    if((mask & ~ALL_PRINC_MASK))\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))\n        return KADM5_BAD_MASK;\n    if(entry == (kadm5_principal_ent_t) NULL)\n        return EINVAL;\n    if (mask & KADM5_TL_DATA) {\n        tl_data_orig = entry->tl_data;\n        while (tl_data_orig) {\n            if (tl_data_orig->tl_data_type < 256)\n                return KADM5_BAD_TL_TYPE;\n            tl_data_orig = tl_data_orig->tl_data_next;\n        }\n    }\n\n    ret = kdb_get_entry(handle, entry->principal, &kdb, &adb);\n    if (ret)\n        return(ret);\n\n    /*\n     * This is pretty much the same as create ...\n     */\n\n    if ((mask & KADM5_POLICY)) {\n        /* get the new policy */\n        ret = kadm5_get_policy(handle->lhandle, entry->policy, &npol);\n        if (ret) {\n            switch (ret) {\n            case EINVAL:\n                ret = KADM5_BAD_POLICY;\n                break;\n            case KADM5_UNK_POLICY:\n            case KADM5_BAD_POLICY:\n                ret =  KADM5_UNK_POLICY;\n                break;\n            }\n            goto done;\n        }\n        have_npol = 1;\n\n        /* if we already have a policy, get it to decrement the refcnt */\n        if(adb.aux_attributes & KADM5_POLICY) {\n            /* ... but not if the old and new are the same */\n            if(strcmp(adb.policy, entry->policy)) {\n                ret = kadm5_get_policy(handle->lhandle,\n                                       adb.policy, &opol);\n                switch(ret) {\n                case EINVAL:\n                case KADM5_BAD_POLICY:\n                case KADM5_UNK_POLICY:\n                    break;\n                case KADM5_OK:\n                    have_opol = 1;\n                    opol.policy_refcnt--;\n                    break;\n                default:\n                    goto done;\n                    break;\n                }\n                npol.policy_refcnt++;\n            }\n        } else npol.policy_refcnt++;\n\n        /* set us up to use the new policy */\n        adb.aux_attributes |= KADM5_POLICY;\n        if (adb.policy)\n            free(adb.policy);\n        adb.policy = strdup(entry->policy);\n\n        /* set pw_max_life based on new policy */\n        if (npol.pw_max_life) {\n            ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb,\n                                                  &(kdb->pw_expiration));\n            if (ret)\n                goto done;\n            kdb->pw_expiration += npol.pw_max_life;\n        } else {\n            kdb->pw_expiration = 0;\n        }\n    }\n\n    if ((mask & KADM5_POLICY_CLR) &&\n        (adb.aux_attributes & KADM5_POLICY)) {\n        ret = kadm5_get_policy(handle->lhandle, adb.policy, &opol);\n        switch(ret) {\n        case EINVAL:\n        case KADM5_BAD_POLICY:\n        case KADM5_UNK_POLICY:\n            ret = KADM5_BAD_DB;\n            goto done;\n            break;\n        case KADM5_OK:\n            have_opol = 1;\n            if (adb.policy)\n                free(adb.policy);\n            adb.policy = NULL;\n            adb.aux_attributes &= ~KADM5_POLICY;\n            kdb->pw_expiration = 0;\n            opol.policy_refcnt--;\n            break;\n        default:\n            goto done;\n            break;\n        }\n    }\n\n    if (((mask & KADM5_POLICY) || (mask & KADM5_POLICY_CLR)) &&\n        (((have_opol) &&\n          (ret =\n           kadm5_modify_policy_internal(handle->lhandle, &opol,\n                                        KADM5_REF_COUNT))) ||\n         ((have_npol) &&\n          (ret =\n           kadm5_modify_policy_internal(handle->lhandle, &npol,\n                                        KADM5_REF_COUNT)))))\n        goto done;\n\n    if ((mask & KADM5_ATTRIBUTES))\n        kdb->attributes = entry->attributes;\n    if ((mask & KADM5_MAX_LIFE))\n        kdb->max_life = entry->max_life;\n    if ((mask & KADM5_PRINC_EXPIRE_TIME))\n        kdb->expiration = entry->princ_expire_time;\n    if (mask & KADM5_PW_EXPIRATION)\n        kdb->pw_expiration = entry->pw_expiration;\n    if (mask & KADM5_MAX_RLIFE)\n        kdb->max_renewable_life = entry->max_renewable_life;\n\n    if((mask & KADM5_KVNO)) {\n        for (i = 0; i < kdb->n_key_data; i++)\n            kdb->key_data[i].key_data_kvno = entry->kvno;\n    }\n\n    if (mask & KADM5_TL_DATA) {\n        krb5_tl_data *tl;\n\n        /* may have to change the version number of the API. Updates the list with the given tl_data rather than over-writting */\n\n        for (tl = entry->tl_data; tl;\n             tl = tl->tl_data_next)\n        {\n            ret = krb5_dbe_update_tl_data(handle->context, kdb, tl);\n            if( ret )\n            {\n                goto done;\n            }\n        }\n    }\n\n    /*\n     * Setting entry->fail_auth_count to 0 can be used to manually unlock\n     * an account. It is not possible to set fail_auth_count to any other\n     * value using kadmin.\n     */\n    if (mask & KADM5_FAIL_AUTH_COUNT) {\n        if (entry->fail_auth_count != 0) {\n            ret = KADM5_BAD_SERVER_PARAMS;\n            goto done;\n        }\n\n        kdb->fail_auth_count = 0;\n    }\n\n    /* let the mask propagate to the database provider */\n    kdb->mask = mask;\n\n    ret = k5_kadm5_hook_modify(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, entry, mask);\n    if (ret)\n        goto done;\n\n    ret = kdb_put_entry(handle, kdb, &adb);\n    if (ret) goto done;\n    (void) k5_kadm5_hook_modify(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, entry, mask);\n\n    ret = KADM5_OK;\ndone:\n    if (have_opol) {\n        ret2 = kadm5_free_policy_ent(handle->lhandle, &opol);\n        ret = ret ? ret : ret2;\n    }\n    if (have_npol) {\n        ret2 = kadm5_free_policy_ent(handle->lhandle, &npol);\n        ret = ret ? ret : ret2;\n    }\n    kdb_free_entry(handle, kdb, &adb);\n    return ret;\n}\n\nkadm5_ret_t\nkadm5_rename_principal(void *server_handle,\n                       krb5_principal source, krb5_principal target)\n{\n    krb5_db_entry *kdb;\n    osa_princ_ent_rec adb;\n    krb5_error_code ret;\n    kadm5_server_handle_t handle = server_handle;\n    krb5_int16 stype, i;\n    krb5_data *salt = NULL;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if (source == NULL || target == NULL)\n        return EINVAL;\n\n    if ((ret = kdb_get_entry(handle, target, &kdb, &adb)) == 0) {\n        kdb_free_entry(handle, kdb, &adb);\n        return(KADM5_DUP);\n    }\n\n    if ((ret = kdb_get_entry(handle, source, &kdb, &adb)))\n        return ret;\n\n    /* Transform salts as necessary. */\n    for (i = 0; i < kdb->n_key_data; i++) {\n        ret = krb5_dbe_compute_salt(handle->context, &kdb->key_data[i],\n                                    kdb->princ, &stype, &salt);\n        if (ret == KRB5_KDB_BAD_SALTTYPE)\n            ret = KADM5_NO_RENAME_SALT;\n        if (ret)\n            goto done;\n        kdb->key_data[i].key_data_type[1] = KRB5_KDB_SALTTYPE_SPECIAL;\n        free(kdb->key_data[i].key_data_contents[1]);\n        kdb->key_data[i].key_data_contents[1] = (krb5_octet *)salt->data;\n        kdb->key_data[i].key_data_length[1] = salt->length;\n        kdb->key_data[i].key_data_ver = 2;\n        free(salt);\n        salt = NULL;\n    }\n\n    kadm5_free_principal(handle->context, kdb->princ);\n    ret = kadm5_copy_principal(handle->context, target, &kdb->princ);\n    if (ret) {\n        kdb->princ = NULL; /* so freeing the dbe doesn't lose */\n        goto done;\n    }\n\n    if ((ret = kdb_put_entry(handle, kdb, &adb)))\n        goto done;\n\n    ret = kdb_delete_entry(handle, source);\n\ndone:\n    krb5_free_data(handle->context, salt);\n    kdb_free_entry(handle, kdb, &adb);\n    return ret;\n}\n\nkadm5_ret_t\nkadm5_get_principal(void *server_handle, krb5_principal principal,\n                    kadm5_principal_ent_t entry,\n                    long in_mask)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    krb5_error_code             ret = 0;\n    long                        mask;\n    int i;\n    kadm5_server_handle_t handle = server_handle;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    /*\n     * In version 1, all the defined fields are always returned.\n     * entry is a pointer to a kadm5_principal_ent_t_v1 that should be\n     * filled with allocated memory.\n     */\n    mask = in_mask;\n\n    memset(entry, 0, sizeof(*entry));\n\n    if (principal == NULL)\n        return EINVAL;\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return ret;\n\n    if ((mask & KADM5_POLICY) &&\n        adb.policy && (adb.aux_attributes & KADM5_POLICY)) {\n        if ((entry->policy = strdup(adb.policy)) == NULL) {\n            ret = ENOMEM;\n            goto done;\n        }\n    }\n\n    if (mask & KADM5_AUX_ATTRIBUTES)\n        entry->aux_attributes = adb.aux_attributes;\n\n    if ((mask & KADM5_PRINCIPAL) &&\n        (ret = krb5_copy_principal(handle->context, kdb->princ,\n                                   &entry->principal))) {\n        goto done;\n    }\n\n    if (mask & KADM5_PRINC_EXPIRE_TIME)\n        entry->princ_expire_time = kdb->expiration;\n\n    if ((mask & KADM5_LAST_PWD_CHANGE) &&\n        (ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb,\n                                               &(entry->last_pwd_change)))) {\n        goto done;\n    }\n\n    if (mask & KADM5_PW_EXPIRATION)\n        entry->pw_expiration = kdb->pw_expiration;\n    if (mask & KADM5_MAX_LIFE)\n        entry->max_life = kdb->max_life;\n\n    /* this is a little non-sensical because the function returns two */\n    /* values that must be checked separately against the mask */\n    if ((mask & KADM5_MOD_NAME) || (mask & KADM5_MOD_TIME)) {\n        ret = krb5_dbe_lookup_mod_princ_data(handle->context, kdb,\n                                             &(entry->mod_date),\n                                             &(entry->mod_name));\n        if (ret) {\n            goto done;\n        }\n\n        if (! (mask & KADM5_MOD_TIME))\n            entry->mod_date = 0;\n        if (! (mask & KADM5_MOD_NAME)) {\n            krb5_free_principal(handle->context, entry->mod_name);\n            entry->mod_name = NULL;\n        }\n    }\n\n    if (mask & KADM5_ATTRIBUTES)\n        entry->attributes = kdb->attributes;\n\n    if (mask & KADM5_KVNO)\n        for (entry->kvno = 0, i=0; i<kdb->n_key_data; i++)\n            if ((krb5_kvno) kdb->key_data[i].key_data_kvno > entry->kvno)\n                entry->kvno = kdb->key_data[i].key_data_kvno;\n\n    if (mask & KADM5_MKVNO) {\n        ret = krb5_dbe_get_mkvno(handle->context, kdb, &entry->mkvno);\n        if (ret)\n            goto done;\n    }\n\n    if (mask & KADM5_MAX_RLIFE)\n        entry->max_renewable_life = kdb->max_renewable_life;\n    if (mask & KADM5_LAST_SUCCESS)\n        entry->last_success = kdb->last_success;\n    if (mask & KADM5_LAST_FAILED)\n        entry->last_failed = kdb->last_failed;\n    if (mask & KADM5_FAIL_AUTH_COUNT)\n        entry->fail_auth_count = kdb->fail_auth_count;\n    if (mask & KADM5_TL_DATA) {\n        krb5_tl_data *tl, *tl2;\n\n        entry->tl_data = NULL;\n\n        tl = kdb->tl_data;\n        while (tl) {\n            if (tl->tl_data_type > 255) {\n                if ((tl2 = dup_tl_data(tl)) == NULL) {\n                    ret = ENOMEM;\n                    goto done;\n                }\n                tl2->tl_data_next = entry->tl_data;\n                entry->tl_data = tl2;\n                entry->n_tl_data++;\n            }\n\n            tl = tl->tl_data_next;\n        }\n    }\n    if (mask & KADM5_KEY_DATA) {\n        entry->n_key_data = kdb->n_key_data;\n        if(entry->n_key_data) {\n            entry->key_data = malloc(entry->n_key_data*sizeof(krb5_key_data));\n            if (entry->key_data == NULL) {\n                ret = ENOMEM;\n                goto done;\n            }\n        } else\n            entry->key_data = NULL;\n\n        for (i = 0; i < entry->n_key_data; i++)\n            ret = krb5_copy_key_data_contents(handle->context,\n                                              &kdb->key_data[i],\n                                              &entry->key_data[i]);\n        if (ret)\n            goto done;\n    }\n\n    ret = KADM5_OK;\n\ndone:\n    if (ret && entry->principal) {\n        krb5_free_principal(handle->context, entry->principal);\n        entry->principal = NULL;\n    }\n    kdb_free_entry(handle, kdb, &adb);\n\n    return ret;\n}\n\n/*\n * Function: check_pw_reuse\n *\n * Purpose: Check if a key appears in a list of keys, in order to\n * enforce password history.\n *\n * Arguments:\n *\n *      context                 (r) the krb5 context\n *      hist_keyblock           (r) the key that hist_key_data is\n *                              encrypted in\n *      n_new_key_data          (r) length of new_key_data\n *      new_key_data            (r) keys to check against\n *                              pw_hist_data, encrypted in hist_keyblock\n *      n_pw_hist_data          (r) length of pw_hist_data\n *      pw_hist_data            (r) passwords to check new_key_data against\n *\n * Effects:\n * For each new_key in new_key_data:\n *      decrypt new_key with the master_keyblock\n *      for each password in pw_hist_data:\n *              for each hist_key in password:\n *                      decrypt hist_key with hist_keyblock\n *                      compare the new_key and hist_key\n *\n * Returns krb5 errors, KADM5_PASS_RESUSE if a key in\n * new_key_data is the same as a key in pw_hist_data, or 0.\n */\nstatic kadm5_ret_t\ncheck_pw_reuse(krb5_context context,\n               krb5_keyblock *hist_keyblocks,\n               int n_new_key_data, krb5_key_data *new_key_data,\n               unsigned int n_pw_hist_data, osa_pw_hist_ent *pw_hist_data)\n{\n    unsigned int x, y, z;\n    krb5_keyblock newkey, histkey, *kb;\n    krb5_key_data *key_data;\n    krb5_error_code ret;\n\n    assert (n_new_key_data >= 0);\n    for (x = 0; x < (unsigned) n_new_key_data; x++) {\n        /* Check only entries with the most recent kvno. */\n        if (new_key_data[x].key_data_kvno != new_key_data[0].key_data_kvno)\n            break;\n        ret = krb5_dbe_decrypt_key_data(context, NULL, &(new_key_data[x]),\n                                        &newkey, NULL);\n        if (ret)\n            return(ret);\n        for (y = 0; y < n_pw_hist_data; y++) {\n            for (z = 0; z < (unsigned int) pw_hist_data[y].n_key_data; z++) {\n                for (kb = hist_keyblocks; kb->enctype != 0; kb++) {\n                    key_data = &pw_hist_data[y].key_data[z];\n                    ret = krb5_dbe_decrypt_key_data(context, kb, key_data,\n                                                    &histkey, NULL);\n                    if (ret)\n                        continue;\n                    if (newkey.length == histkey.length &&\n                        newkey.enctype == histkey.enctype &&\n                        memcmp(newkey.contents, histkey.contents,\n                               histkey.length) == 0) {\n                        krb5_free_keyblock_contents(context, &histkey);\n                        krb5_free_keyblock_contents(context, &newkey);\n                        return KADM5_PASS_REUSE;\n                    }\n                    krb5_free_keyblock_contents(context, &histkey);\n                }\n            }\n        }\n        krb5_free_keyblock_contents(context, &newkey);\n    }\n\n    return(0);\n}\n\n/*\n * Function: create_history_entry\n *\n * Purpose: Creates a password history entry from an array of\n * key_data.\n *\n * Arguments:\n *\n *      context         (r) krb5_context to use\n *      mkey            (r) master keyblock to decrypt key data with\n *      hist_key        (r) history keyblock to encrypt key data with\n *      n_key_data      (r) number of elements in key_data\n *      key_data        (r) keys to add to the history entry\n *      hist            (w) history entry to fill in\n *\n * Effects:\n *\n * hist->key_data is allocated to store n_key_data key_datas.  Each\n * element of key_data is decrypted with master_keyblock, re-encrypted\n * in hist_key, and added to hist->key_data.  hist->n_key_data is\n * set to n_key_data.\n */\nstatic\nint create_history_entry(krb5_context context,\n                         krb5_keyblock *hist_key, int n_key_data,\n                         krb5_key_data *key_data, osa_pw_hist_ent *hist)\n{\n    int i, ret;\n    krb5_keyblock key;\n    krb5_keysalt salt;\n\n    hist->key_data = (krb5_key_data*)malloc(n_key_data*sizeof(krb5_key_data));\n    if (hist->key_data == NULL)\n        return ENOMEM;\n    memset(hist->key_data, 0, n_key_data*sizeof(krb5_key_data));\n\n    for (i = 0; i < n_key_data; i++) {\n        ret = krb5_dbe_decrypt_key_data(context, NULL, &key_data[i], &key,\n                                        &salt);\n        if (ret)\n            return ret;\n\n        ret = krb5_dbe_encrypt_key_data(context, hist_key, &key, &salt,\n                                        key_data[i].key_data_kvno,\n                                        &hist->key_data[i]);\n        if (ret)\n            return ret;\n\n        krb5_free_keyblock_contents(context, &key);\n        /* krb5_free_keysalt(context, &salt); */\n    }\n\n    hist->n_key_data = n_key_data;\n    return 0;\n}\n\nstatic\nvoid free_history_entry(krb5_context context, osa_pw_hist_ent *hist)\n{\n    int i;\n\n    for (i = 0; i < hist->n_key_data; i++)\n        krb5_free_key_data_contents(context, &hist->key_data[i]);\n    free(hist->key_data);\n}\n\n/*\n * Function: add_to_history\n *\n * Purpose: Adds a password to a principal's password history.\n *\n * Arguments:\n *\n *      context         (r) krb5_context to use\n *      hist_kvno       (r) kvno of current history key\n *      adb             (r/w) admin principal entry to add keys to\n *      pol             (r) adb's policy\n *      pw              (r) keys for the password to add to adb's key history\n *\n * Effects:\n *\n * add_to_history adds a single password to adb's password history.\n * pw contains n_key_data keys in its key_data, in storage should be\n * allocated but not freed by the caller (XXX blech!).\n *\n * This function maintains adb->old_keys as a circular queue.  It\n * starts empty, and grows each time this function is called until it\n * is pol->pw_history_num items long.  adb->old_key_len holds the\n * number of allocated entries in the array, and must therefore be [0,\n * pol->pw_history_num).  adb->old_key_next is the index into the\n * array where the next element should be written, and must be [0,\n * adb->old_key_len).\n */\nstatic kadm5_ret_t add_to_history(krb5_context context,\n                                  krb5_kvno hist_kvno,\n                                  osa_princ_ent_t adb,\n                                  kadm5_policy_ent_t pol,\n                                  osa_pw_hist_ent *pw)\n{\n    osa_pw_hist_ent *histp;\n    uint32_t nhist;\n    unsigned int i, knext, nkeys;\n\n    nhist = pol->pw_history_num;\n    /* A history of 1 means just check the current password */\n    if (nhist <= 1)\n        return 0;\n\n    if (adb->admin_history_kvno != hist_kvno) {\n        /* The history key has changed since the last password change, so we\n         * have to reset the password history. */\n        free(adb->old_keys);\n        adb->old_keys = NULL;\n        adb->old_key_len = 0;\n        adb->old_key_next = 0;\n        adb->admin_history_kvno = hist_kvno;\n    }\n\n    nkeys = adb->old_key_len;\n    knext = adb->old_key_next;\n    /* resize the adb->old_keys array if necessary */\n    if (nkeys + 1 < nhist) {\n        if (adb->old_keys == NULL) {\n            adb->old_keys = (osa_pw_hist_ent *)\n                malloc((nkeys + 1) * sizeof (osa_pw_hist_ent));\n        } else {\n            adb->old_keys = (osa_pw_hist_ent *)\n                realloc(adb->old_keys,\n                        (nkeys + 1) * sizeof (osa_pw_hist_ent));\n        }\n        if (adb->old_keys == NULL)\n            return(ENOMEM);\n\n        memset(&adb->old_keys[nkeys], 0, sizeof(osa_pw_hist_ent));\n        nkeys = ++adb->old_key_len;\n        /*\n         * To avoid losing old keys, shift forward each entry after\n         * knext.\n         */\n        for (i = nkeys - 1; i > knext; i--) {\n            adb->old_keys[i] = adb->old_keys[i - 1];\n        }\n        memset(&adb->old_keys[knext], 0, sizeof(osa_pw_hist_ent));\n    } else if (nkeys + 1 > nhist) {\n        /*\n         * The policy must have changed!  Shrink the array.\n         * Can't simply realloc() down, since it might be wrapped.\n         * To understand the arithmetic below, note that we are\n         * copying into new positions 0 .. N-1 from old positions\n         * old_key_next-N .. old_key_next-1, modulo old_key_len,\n         * where N = pw_history_num - 1 is the length of the\n         * shortened list.        Matt Crawford, FNAL\n         */\n        /*\n         * M = adb->old_key_len, N = pol->pw_history_num - 1\n         *\n         * tmp[0] .. tmp[N-1] = old[(knext-N)%M] .. old[(knext-1)%M]\n         */\n        int j;\n        osa_pw_hist_t tmp;\n\n        tmp = (osa_pw_hist_ent *)\n            malloc((nhist - 1) * sizeof (osa_pw_hist_ent));\n        if (tmp == NULL)\n            return ENOMEM;\n        for (i = 0; i < nhist - 1; i++) {\n            /*\n             * Add nkeys once before taking remainder to avoid\n             * negative values.\n             */\n            j = (i + nkeys + knext - (nhist - 1)) % nkeys;\n            tmp[i] = adb->old_keys[j];\n        }\n        /* Now free the ones we don't keep (the oldest ones) */\n        for (i = 0; i < nkeys - (nhist - 1); i++) {\n            j = (i + nkeys + knext) % nkeys;\n            histp = &adb->old_keys[j];\n            for (j = 0; j < histp->n_key_data; j++) {\n                krb5_free_key_data_contents(context, &histp->key_data[j]);\n            }\n            free(histp->key_data);\n        }\n        free(adb->old_keys);\n        adb->old_keys = tmp;\n        nkeys = adb->old_key_len = nhist - 1;\n        knext = adb->old_key_next = 0;\n    }\n\n    /*\n     * If nhist decreased since the last password change, and nkeys+1\n     * is less than the previous nhist, it is possible for knext to\n     * index into unallocated space.  This condition would not be\n     * caught by the resizing code above.\n     */\n    if (knext + 1 > nkeys)\n        knext = adb->old_key_next = 0;\n    /* free the old pw history entry if it contains data */\n    histp = &adb->old_keys[knext];\n    for (i = 0; i < (unsigned int) histp->n_key_data; i++)\n        krb5_free_key_data_contents(context, &histp->key_data[i]);\n    free(histp->key_data);\n\n    /* store the new entry */\n    adb->old_keys[knext] = *pw;\n\n    /* update the next pointer */\n    if (++adb->old_key_next == nhist - 1)\n        adb->old_key_next = 0;\n\n    return(0);\n}\n\n/* FIXME: don't use global variable for this */\nkrb5_boolean use_password_server = 0;\n\n#ifdef USE_PASSWORD_SERVER\nstatic krb5_boolean\nkadm5_use_password_server (void)\n{\n    return use_password_server;\n}\n#endif\n\nvoid\nkadm5_set_use_password_server (void)\n{\n    use_password_server = 1;\n}\n\n#ifdef USE_PASSWORD_SERVER\n\n/*\n * kadm5_launch_task () runs a program (task_path) to synchronize the\n * Apple password server with the Kerberos database.  Password server\n * programs can receive arguments on the command line (task_argv)\n * and a block of data via stdin (data_buffer).\n *\n * Because a failure to communicate with the tool results in the\n * password server falling out of sync with the database,\n * kadm5_launch_task() always fails if it can't talk to the tool.\n */\n\nstatic kadm5_ret_t\nkadm5_launch_task (krb5_context context,\n                   const char *task_path, char * const task_argv[],\n                   const char *buffer)\n{\n    kadm5_ret_t ret;\n    int data_pipe[2];\n\n    ret = pipe (data_pipe);\n    if (ret)\n        ret = errno;\n\n    if (!ret) {\n        pid_t pid = fork ();\n        if (pid == -1) {\n            ret = errno;\n            close (data_pipe[0]);\n            close (data_pipe[1]);\n        } else if (pid == 0) {\n            /* The child: */\n\n            if (dup2 (data_pipe[0], STDIN_FILENO) == -1)\n                _exit (1);\n\n            close (data_pipe[0]);\n            close (data_pipe[1]);\n\n            execv (task_path, task_argv);\n\n            _exit (1); /* Fail if execv fails */\n        } else {\n            /* The parent: */\n            int status;\n\n            ret = 0;\n\n            close (data_pipe[0]);\n\n            /* Write out the buffer to the child, add \\n */\n            if (buffer) {\n                if (krb5_net_write (context, data_pipe[1], buffer, strlen (buffer)) < 0\n                    || krb5_net_write (context, data_pipe[1], \"\\n\", 1) < 0)\n                {\n                    /* kill the child to make sure waitpid() won't hang later */\n                    ret = errno;\n                    kill (pid, SIGKILL);\n                }\n            }\n            close (data_pipe[1]);\n\n            waitpid (pid, &status, 0);\n\n            if (!ret) {\n                if (WIFEXITED (status)) {\n                    /* child read password and exited.  Check the return value. */\n                    if ((WEXITSTATUS (status) != 0) && (WEXITSTATUS (status) != 252)) {\n                        ret = KRB5KDC_ERR_POLICY; /* password change rejected */\n                    }\n                } else {\n                    /* child read password but crashed or was killed */\n                    ret = KRB5KRB_ERR_GENERIC; /* FIXME: better error */\n                }\n            }\n        }\n    }\n\n    return ret;\n}\n\n#endif\n\nkadm5_ret_t\nkadm5_chpass_principal(void *server_handle,\n                       krb5_principal principal, char *password)\n{\n    return\n        kadm5_chpass_principal_3(server_handle, principal, FALSE,\n                                 0, NULL, password);\n}\n\nkadm5_ret_t\nkadm5_chpass_principal_3(void *server_handle,\n                         krb5_principal principal, krb5_boolean keepold,\n                         int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                         char *password)\n{\n    krb5_int32                  now;\n    kadm5_policy_ent_rec        pol;\n    osa_princ_ent_rec           adb;\n    krb5_db_entry               *kdb;\n    int                         ret, ret2, last_pwd, hist_added;\n    int                         have_pol = 0;\n    kadm5_server_handle_t       handle = server_handle;\n    osa_pw_hist_ent             hist;\n    krb5_keyblock               *act_mkey, *hist_keyblocks = NULL;\n    krb5_kvno                   act_kvno, hist_kvno;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    hist_added = 0;\n    memset(&hist, 0, sizeof(hist));\n\n    if (principal == NULL || password == NULL)\n        return EINVAL;\n    if ((krb5_principal_compare(handle->context,\n                                principal, hist_princ)) == TRUE)\n        return KADM5_PROTECT_PRINCIPAL;\n\n    /* Use default keysalts if caller did not provide any. */\n    if (n_ks_tuple == 0) {\n        ks_tuple = handle->params.keysalts;\n        n_ks_tuple = handle->params.num_keysalts;\n    }\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return(ret);\n\n    if ((adb.aux_attributes & KADM5_POLICY)) {\n        if ((ret = kadm5_get_policy(handle->lhandle, adb.policy, &pol)))\n            goto done;\n        have_pol = 1;\n\n        /* Create a password history entry before we change kdb's key_data. */\n        ret = kdb_get_hist_key(handle, &hist_keyblocks, &hist_kvno);\n        if (ret)\n            goto done;\n        ret = create_history_entry(handle->context, &hist_keyblocks[0],\n                                   kdb->n_key_data, kdb->key_data, &hist);\n        if (ret)\n            goto done;\n    }\n\n    if ((ret = passwd_check(handle, password, have_pol ? &pol : NULL,\n                            principal)))\n        goto done;\n\n    ret = krb5_dbe_find_act_mkey(handle->context, active_mkey_list, &act_kvno,\n                                 &act_mkey);\n    if (ret)\n        goto done;\n\n    ret = krb5_dbe_cpw(handle->context, act_mkey, ks_tuple, n_ks_tuple,\n                       password, 0 /* increment kvno */,\n                       keepold, kdb);\n    if (ret)\n        goto done;\n\n    ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);\n    if (ret)\n        goto done;\n\n    kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;\n\n    ret = krb5_timeofday(handle->context, &now);\n    if (ret)\n        goto done;\n\n    if ((adb.aux_attributes & KADM5_POLICY)) {\n        /* the policy was loaded before */\n\n        ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb, &last_pwd);\n        if (ret)\n            goto done;\n\n#if 0\n        /*\n         * The spec says this check is overridden if the caller has\n         * modify privilege.  The admin server therefore makes this\n         * check itself (in chpass_principal_wrapper, misc.c). A\n         * local caller implicitly has all authorization bits.\n         */\n        if ((now - last_pwd) < pol.pw_min_life &&\n            !(kdb->attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {\n            ret = KADM5_PASS_TOOSOON;\n            goto done;\n        }\n#endif\n\n        ret = check_pw_reuse(handle->context, hist_keyblocks,\n                             kdb->n_key_data, kdb->key_data,\n                             1, &hist);\n        if (ret)\n            goto done;\n\n        if (pol.pw_history_num > 1) {\n            /* If hist_kvno has changed since the last password change, we\n             * can't check the history. */\n            if (adb.admin_history_kvno == hist_kvno) {\n                ret = check_pw_reuse(handle->context, hist_keyblocks,\n                                     kdb->n_key_data, kdb->key_data,\n                                     adb.old_key_len, adb.old_keys);\n                if (ret)\n                    goto done;\n            }\n\n            ret = add_to_history(handle->context, hist_kvno, &adb, &pol,\n                                 &hist);\n            if (ret)\n                goto done;\n            hist_added = 1;\n        }\n\n        if (pol.pw_max_life)\n            kdb->pw_expiration = now + pol.pw_max_life;\n        else\n            kdb->pw_expiration = 0;\n    } else {\n        kdb->pw_expiration = 0;\n    }\n\n#ifdef USE_PASSWORD_SERVER\n    if (kadm5_use_password_server () &&\n        (krb5_princ_size (handle->context, principal) == 1)) {\n        krb5_data *princ = krb5_princ_component (handle->context, principal, 0);\n        const char *path = \"/usr/sbin/mkpassdb\";\n        char *argv[] = { \"mkpassdb\", \"-setpassword\", NULL, NULL };\n        char *pstring = NULL;\n\n        if (!ret) {\n            pstring = malloc ((princ->length + 1) * sizeof (char));\n            if (pstring == NULL) { ret = ENOMEM; }\n        }\n\n        if (!ret) {\n            memcpy (pstring, princ->data, princ->length);\n            pstring [princ->length] = '\\0';\n            argv[2] = pstring;\n\n            ret = kadm5_launch_task (handle->context, path, argv, password);\n        }\n\n        if (pstring != NULL)\n            free (pstring);\n\n        if (ret)\n            goto done;\n    }\n#endif\n\n    ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);\n    if (ret)\n        goto done;\n\n    /* unlock principal on this KDC */\n    kdb->fail_auth_count = 0;\n\n    /* key data and attributes changed, let the database provider know */\n    kdb->mask = KADM5_KEY_DATA | KADM5_ATTRIBUTES |\n        KADM5_FAIL_AUTH_COUNT;\n    /* | KADM5_CPW_FUNCTION */\n\n    ret = k5_kadm5_hook_chpass(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, principal, keepold,\n                               n_ks_tuple, ks_tuple, password);\n    if (ret)\n        goto done;\n\n    if ((ret = kdb_put_entry(handle, kdb, &adb)))\n        goto done;\n\n    (void) k5_kadm5_hook_chpass(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, principal,\n                                keepold, n_ks_tuple, ks_tuple, password);\n    ret = KADM5_OK;\ndone:\n    if (!hist_added && hist.key_data)\n        free_history_entry(handle->context, &hist);\n    kdb_free_entry(handle, kdb, &adb);\n    kdb_free_keyblocks(handle, hist_keyblocks);\n\n    if (have_pol && (ret2 = kadm5_free_policy_ent(handle->lhandle, &pol))\n        && !ret)\n        ret = ret2;\n\n    return ret;\n}\n\nkadm5_ret_t\nkadm5_randkey_principal(void *server_handle,\n                        krb5_principal principal,\n                        krb5_keyblock **keyblocks,\n                        int *n_keys)\n{\n    return\n        kadm5_randkey_principal_3(server_handle, principal,\n                                  FALSE, 0, NULL,\n                                  keyblocks, n_keys);\n}\nkadm5_ret_t\nkadm5_randkey_principal_3(void *server_handle,\n                          krb5_principal principal,\n                          krb5_boolean keepold,\n                          int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                          krb5_keyblock **keyblocks,\n                          int *n_keys)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    krb5_int32                  now;\n    kadm5_policy_ent_rec        pol;\n    int                         ret, last_pwd, have_pol = 0;\n    kadm5_server_handle_t       handle = server_handle;\n    krb5_keyblock               *act_mkey;\n\n    if (keyblocks)\n        *keyblocks = NULL;\n\n    CHECK_HANDLE(server_handle);\n\n    /* Use default keysalts if caller did not provide any. */\n    if (n_ks_tuple == 0) {\n        ks_tuple = handle->params.keysalts;\n        n_ks_tuple = handle->params.num_keysalts;\n    }\n\n    krb5_clear_error_message(handle->context);\n\n    if (principal == NULL)\n        return EINVAL;\n    if (krb5_principal_compare(handle->context, principal, hist_princ)) {\n        /* If changing the history entry, the new entry must have exactly one\n         * key. */\n        if (keepold)\n            return KADM5_PROTECT_PRINCIPAL;\n        n_ks_tuple = 1;\n    }\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return(ret);\n\n    ret = krb5_dbe_find_act_mkey(handle->context, active_mkey_list, NULL,\n                                 &act_mkey);\n    if (ret)\n        goto done;\n\n    ret = krb5_dbe_crk(handle->context, act_mkey, ks_tuple, n_ks_tuple,\n                       keepold, kdb);\n    if (ret)\n        goto done;\n\n    kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;\n\n    ret = krb5_timeofday(handle->context, &now);\n    if (ret)\n        goto done;\n\n    if ((adb.aux_attributes & KADM5_POLICY)) {\n        if ((ret = kadm5_get_policy(handle->lhandle, adb.policy,\n                                    &pol)) != KADM5_OK)\n            goto done;\n        have_pol = 1;\n\n        ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb, &last_pwd);\n        if (ret)\n            goto done;\n\n#if 0\n        /*\n         * The spec says this check is overridden if the caller has\n         * modify privilege.  The admin server therefore makes this\n         * check itself (in chpass_principal_wrapper, misc.c).  A\n         * local caller implicitly has all authorization bits.\n         */\n        if((now - last_pwd) < pol.pw_min_life &&\n           !(kdb->attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {\n            ret = KADM5_PASS_TOOSOON;\n            goto done;\n        }\n#endif\n\n        if (pol.pw_max_life)\n            kdb->pw_expiration = now + pol.pw_max_life;\n        else\n            kdb->pw_expiration = 0;\n    } else {\n        kdb->pw_expiration = 0;\n    }\n\n    ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);\n    if (ret)\n        goto done;\n\n    /* unlock principal on this KDC */\n    kdb->fail_auth_count = 0;\n\n    if (keyblocks) {\n        ret = decrypt_key_data(handle->context,\n                               kdb->n_key_data, kdb->key_data,\n                               keyblocks, n_keys);\n        if (ret)\n            goto done;\n    }\n\n    /* key data changed, let the database provider know */\n    kdb->mask = KADM5_KEY_DATA | KADM5_FAIL_AUTH_COUNT;\n    /* | KADM5_RANDKEY_USED */;\n\n    ret = k5_kadm5_hook_chpass(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, principal, keepold,\n                               n_ks_tuple, ks_tuple, NULL);\n    if (ret)\n        goto done;\n    if ((ret = kdb_put_entry(handle, kdb, &adb)))\n        goto done;\n\n    (void) k5_kadm5_hook_chpass(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, principal,\n                                keepold, n_ks_tuple, ks_tuple, NULL);\n    ret = KADM5_OK;\ndone:\n    kdb_free_entry(handle, kdb, &adb);\n    if (have_pol)\n        kadm5_free_policy_ent(handle->lhandle, &pol);\n\n    return ret;\n}\n\n/*\n * kadm5_setv4key_principal:\n *\n * Set only ONE key of the principal, removing all others.  This key\n * must have the DES_CBC_CRC enctype and is entered as having the\n * krb4 salttype.  This is to enable things like kadmind4 to work.\n */\nkadm5_ret_t\nkadm5_setv4key_principal(void *server_handle,\n                         krb5_principal principal,\n                         krb5_keyblock *keyblock)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    krb5_int32                  now;\n    kadm5_policy_ent_rec        pol;\n    krb5_keysalt                keysalt;\n    int                         i, k, kvno, ret, have_pol = 0;\n#if 0\n    int                         last_pwd;\n#endif\n    kadm5_server_handle_t       handle = server_handle;\n    krb5_key_data               tmp_key_data;\n    krb5_keyblock               *act_mkey;\n\n    memset( &tmp_key_data, 0, sizeof(tmp_key_data));\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if (principal == NULL || keyblock == NULL)\n        return EINVAL;\n    if (hist_princ && /* this will be NULL when initializing the databse */\n        ((krb5_principal_compare(handle->context,\n                                 principal, hist_princ)) == TRUE))\n        return KADM5_PROTECT_PRINCIPAL;\n\n    if (keyblock->enctype != ENCTYPE_DES_CBC_CRC)\n        return KADM5_SETV4KEY_INVAL_ENCTYPE;\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return(ret);\n\n    for (kvno = 0, i=0; i<kdb->n_key_data; i++)\n        if (kdb->key_data[i].key_data_kvno > kvno)\n            kvno = kdb->key_data[i].key_data_kvno;\n\n    if (kdb->key_data != NULL)\n        cleanup_key_data(handle->context, kdb->n_key_data, kdb->key_data);\n\n    kdb->key_data = (krb5_key_data*)krb5_db_alloc(handle->context, NULL, sizeof(krb5_key_data));\n    if (kdb->key_data == NULL)\n        return ENOMEM;\n    memset(kdb->key_data, 0, sizeof(krb5_key_data));\n    kdb->n_key_data = 1;\n    keysalt.type = KRB5_KDB_SALTTYPE_V4;\n    /* XXX data.magic? */\n    keysalt.data.length = 0;\n    keysalt.data.data = NULL;\n\n    ret = krb5_dbe_find_act_mkey(handle->context, active_mkey_list, NULL,\n                                 &act_mkey);\n    if (ret)\n        goto done;\n\n    /* use tmp_key_data as temporary location and reallocate later */\n    ret = krb5_dbe_encrypt_key_data(handle->context, act_mkey, keyblock,\n                                    &keysalt, kvno + 1, &tmp_key_data);\n    if (ret) {\n        goto done;\n    }\n\n    for (k = 0; k < tmp_key_data.key_data_ver; k++) {\n        kdb->key_data->key_data_type[k] = tmp_key_data.key_data_type[k];\n        kdb->key_data->key_data_length[k] = tmp_key_data.key_data_length[k];\n        if (tmp_key_data.key_data_contents[k]) {\n            kdb->key_data->key_data_contents[k] = krb5_db_alloc(handle->context, NULL, tmp_key_data.key_data_length[k]);\n            if (kdb->key_data->key_data_contents[k] == NULL) {\n                cleanup_key_data(handle->context, kdb->n_key_data, kdb->key_data);\n                kdb->key_data = NULL;\n                kdb->n_key_data = 0;\n                ret = ENOMEM;\n                goto done;\n            }\n            memcpy (kdb->key_data->key_data_contents[k], tmp_key_data.key_data_contents[k], tmp_key_data.key_data_length[k]);\n\n            memset (tmp_key_data.key_data_contents[k], 0, tmp_key_data.key_data_length[k]);\n            free (tmp_key_data.key_data_contents[k]);\n            tmp_key_data.key_data_contents[k] = NULL;\n        }\n    }\n\n\n\n    kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;\n\n    ret = krb5_timeofday(handle->context, &now);\n    if (ret)\n        goto done;\n\n    if ((adb.aux_attributes & KADM5_POLICY)) {\n        if ((ret = kadm5_get_policy(handle->lhandle, adb.policy,\n                                    &pol)) != KADM5_OK)\n            goto done;\n        have_pol = 1;\n\n#if 0\n        /*\n         * The spec says this check is overridden if the caller has\n         * modify privilege.  The admin server therefore makes this\n         * check itself (in chpass_principal_wrapper, misc.c).  A\n         * local caller implicitly has all authorization bits.\n         */\n        if (ret = krb5_dbe_lookup_last_pwd_change(handle->context,\n                                                  kdb, &last_pwd))\n            goto done;\n        if((now - last_pwd) < pol.pw_min_life &&\n           !(kdb->attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {\n            ret = KADM5_PASS_TOOSOON;\n            goto done;\n        }\n#endif\n\n        if (pol.pw_max_life)\n            kdb->pw_expiration = now + pol.pw_max_life;\n        else\n            kdb->pw_expiration = 0;\n    } else {\n        kdb->pw_expiration = 0;\n    }\n\n    ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);\n    if (ret)\n        goto done;\n\n    /* unlock principal on this KDC */\n    kdb->fail_auth_count = 0;\n\n    if ((ret = kdb_put_entry(handle, kdb, &adb)))\n        goto done;\n\n    ret = KADM5_OK;\ndone:\n    for (i = 0; i < tmp_key_data.key_data_ver; i++) {\n        if (tmp_key_data.key_data_contents[i]) {\n            memset (tmp_key_data.key_data_contents[i], 0, tmp_key_data.key_data_length[i]);\n            free (tmp_key_data.key_data_contents[i]);\n        }\n    }\n\n    kdb_free_entry(handle, kdb, &adb);\n    if (have_pol)\n        kadm5_free_policy_ent(handle->lhandle, &pol);\n\n    return ret;\n}\n\nkadm5_ret_t\nkadm5_setkey_principal(void *server_handle,\n                       krb5_principal principal,\n                       krb5_keyblock *keyblocks,\n                       int n_keys)\n{\n    return\n        kadm5_setkey_principal_3(server_handle, principal,\n                                 FALSE, 0, NULL,\n                                 keyblocks, n_keys);\n}\n\nkadm5_ret_t\nkadm5_setkey_principal_3(void *server_handle,\n                         krb5_principal principal,\n                         krb5_boolean keepold,\n                         int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                         krb5_keyblock *keyblocks,\n                         int n_keys)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    krb5_int32                  now;\n    kadm5_policy_ent_rec        pol;\n    krb5_key_data               *old_key_data;\n    int                         n_old_keys;\n    int                         i, j, k, kvno, ret, have_pol = 0;\n#if 0\n    int                         last_pwd;\n#endif\n    kadm5_server_handle_t       handle = server_handle;\n    krb5_boolean                similar;\n    krb5_keysalt                keysalt;\n    krb5_key_data         tmp_key_data;\n    krb5_key_data        *tptr;\n    krb5_keyblock               *act_mkey;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if (principal == NULL || keyblocks == NULL)\n        return EINVAL;\n    if (hist_princ && /* this will be NULL when initializing the databse */\n        ((krb5_principal_compare(handle->context,\n                                 principal, hist_princ)) == TRUE))\n        return KADM5_PROTECT_PRINCIPAL;\n\n    for (i = 0; i < n_keys; i++) {\n        for (j = i+1; j < n_keys; j++) {\n            if ((ret = krb5_c_enctype_compare(handle->context,\n                                              keyblocks[i].enctype,\n                                              keyblocks[j].enctype,\n                                              &similar)))\n                return(ret);\n            if (similar) {\n                if (n_ks_tuple) {\n                    if (ks_tuple[i].ks_salttype == ks_tuple[j].ks_salttype)\n                        return KADM5_SETKEY_DUP_ENCTYPES;\n                } else\n                    return KADM5_SETKEY_DUP_ENCTYPES;\n            }\n        }\n    }\n\n    if (n_ks_tuple && n_ks_tuple != n_keys)\n        return KADM5_SETKEY3_ETYPE_MISMATCH;\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return(ret);\n\n    for (kvno = 0, i=0; i<kdb->n_key_data; i++)\n        if (kdb->key_data[i].key_data_kvno > kvno)\n            kvno = kdb->key_data[i].key_data_kvno;\n\n    if (keepold) {\n        old_key_data = kdb->key_data;\n        n_old_keys = kdb->n_key_data;\n    } else {\n        if (kdb->key_data != NULL)\n            cleanup_key_data(handle->context, kdb->n_key_data, kdb->key_data);\n        n_old_keys = 0;\n        old_key_data = NULL;\n    }\n\n    kdb->key_data = (krb5_key_data*)krb5_db_alloc(handle->context, NULL, (n_keys+n_old_keys)\n                                                  *sizeof(krb5_key_data));\n    if (kdb->key_data == NULL) {\n        ret = ENOMEM;\n        goto done;\n    }\n\n    memset(kdb->key_data, 0, (n_keys+n_old_keys)*sizeof(krb5_key_data));\n    kdb->n_key_data = 0;\n\n    for (i = 0; i < n_keys; i++) {\n        if (n_ks_tuple) {\n            keysalt.type = ks_tuple[i].ks_salttype;\n            keysalt.data.length = 0;\n            keysalt.data.data = NULL;\n            if (ks_tuple[i].ks_enctype != keyblocks[i].enctype) {\n                ret = KADM5_SETKEY3_ETYPE_MISMATCH;\n                goto done;\n            }\n        }\n        memset (&tmp_key_data, 0, sizeof(tmp_key_data));\n\n        ret = krb5_dbe_find_act_mkey(handle->context, active_mkey_list, NULL,\n                                     &act_mkey);\n        if (ret)\n            goto done;\n\n        ret = krb5_dbe_encrypt_key_data(handle->context, act_mkey,\n                                        &keyblocks[i],\n                                        n_ks_tuple ? &keysalt : NULL, kvno + 1,\n                                        &tmp_key_data);\n        if (ret)\n            goto done;\n\n        tptr = &kdb->key_data[i];\n        tptr->key_data_ver = tmp_key_data.key_data_ver;\n        tptr->key_data_kvno = tmp_key_data.key_data_kvno;\n        for (k = 0; k < tmp_key_data.key_data_ver; k++) {\n            tptr->key_data_type[k] = tmp_key_data.key_data_type[k];\n            tptr->key_data_length[k] = tmp_key_data.key_data_length[k];\n            if (tmp_key_data.key_data_contents[k]) {\n                tptr->key_data_contents[k] = krb5_db_alloc(handle->context, NULL, tmp_key_data.key_data_length[k]);\n                if (tptr->key_data_contents[k] == NULL) {\n                    int i1;\n                    for (i1 = k; i1 < tmp_key_data.key_data_ver; i1++) {\n                        if (tmp_key_data.key_data_contents[i1]) {\n                            memset (tmp_key_data.key_data_contents[i1], 0, tmp_key_data.key_data_length[i1]);\n                            free (tmp_key_data.key_data_contents[i1]);\n                        }\n                    }\n\n                    ret =  ENOMEM;\n                    goto done;\n                }\n                memcpy (tptr->key_data_contents[k], tmp_key_data.key_data_contents[k], tmp_key_data.key_data_length[k]);\n\n                memset (tmp_key_data.key_data_contents[k], 0, tmp_key_data.key_data_length[k]);\n                free (tmp_key_data.key_data_contents[k]);\n                tmp_key_data.key_data_contents[k] = NULL;\n            }\n        }\n        kdb->n_key_data++;\n    }\n\n    /* copy old key data if necessary */\n    for (i = 0; i < n_old_keys; i++) {\n        kdb->key_data[i+n_keys] = old_key_data[i];\n        memset(&old_key_data[i], 0, sizeof (krb5_key_data));\n        kdb->n_key_data++;\n    }\n\n    if (old_key_data)\n        krb5_db_free(handle->context, old_key_data);\n\n    /* assert(kdb->n_key_data == n_keys + n_old_keys) */\n    kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;\n\n    if ((ret = krb5_timeofday(handle->context, &now)))\n        goto done;\n\n    if ((adb.aux_attributes & KADM5_POLICY)) {\n        if ((ret = kadm5_get_policy(handle->lhandle, adb.policy,\n                                    &pol)) != KADM5_OK)\n            goto done;\n        have_pol = 1;\n\n#if 0\n        /*\n         * The spec says this check is overridden if the caller has\n         * modify privilege.  The admin server therefore makes this\n         * check itself (in chpass_principal_wrapper, misc.c).  A\n         * local caller implicitly has all authorization bits.\n         */\n        if (ret = krb5_dbe_lookup_last_pwd_change(handle->context,\n                                                  kdb, &last_pwd))\n            goto done;\n        if((now - last_pwd) < pol.pw_min_life &&\n           !(kdb->attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {\n            ret = KADM5_PASS_TOOSOON;\n            goto done;\n        }\n#endif\n\n        if (pol.pw_max_life)\n            kdb->pw_expiration = now + pol.pw_max_life;\n        else\n            kdb->pw_expiration = 0;\n    } else {\n        kdb->pw_expiration = 0;\n    }\n\n    if ((ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now)))\n        goto done;\n\n    /* unlock principal on this KDC */\n    kdb->fail_auth_count = 0;\n\n    if ((ret = kdb_put_entry(handle, kdb, &adb)))\n        goto done;\n\n    ret = KADM5_OK;\ndone:\n    kdb_free_entry(handle, kdb, &adb);\n    if (have_pol)\n        kadm5_free_policy_ent(handle->lhandle, &pol);\n\n    return ret;\n}\n\n/*\n * Return the list of keys like kadm5_randkey_principal,\n * but don't modify the principal.\n */\nkadm5_ret_t\nkadm5_get_principal_keys(void *server_handle /* IN */,\n                         krb5_principal principal /* IN */,\n                         krb5_keyblock **keyblocks /* OUT */,\n                         int *n_keys /* OUT */)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    kadm5_ret_t                 ret;\n    kadm5_server_handle_t       handle = server_handle;\n\n    if (keyblocks)\n        *keyblocks = NULL;\n\n    CHECK_HANDLE(server_handle);\n\n    if (principal == NULL)\n        return EINVAL;\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return(ret);\n\n    if (keyblocks) {\n        ret = decrypt_key_data(handle->context,\n                               kdb->n_key_data, kdb->key_data,\n                               keyblocks, n_keys);\n        if (ret)\n            goto done;\n    }\n\n    ret = KADM5_OK;\ndone:\n    kdb_free_entry(handle, kdb, &adb);\n\n    return ret;\n}\n\n\n/*\n * Allocate an array of n_key_data krb5_keyblocks, fill in each\n * element with the results of decrypting the nth key in key_data,\n * and if n_keys is not NULL fill it in with the\n * number of keys decrypted.\n */\nstatic int decrypt_key_data(krb5_context context,\n                            int n_key_data, krb5_key_data *key_data,\n                            krb5_keyblock **keyblocks, int *n_keys)\n{\n    krb5_keyblock *keys;\n    int ret, i;\n\n    keys = (krb5_keyblock *) malloc(n_key_data*sizeof(krb5_keyblock));\n    if (keys == NULL)\n        return ENOMEM;\n    memset(keys, 0, n_key_data*sizeof(krb5_keyblock));\n\n    for (i = 0; i < n_key_data; i++) {\n        ret = krb5_dbe_decrypt_key_data(context, NULL, &key_data[i], &keys[i],\n                                        NULL);\n        if (ret) {\n            for (; i >= 0; i--) {\n                if (keys[i].contents) {\n                    memset (keys[i].contents, 0, keys[i].length);\n                    free( keys[i].contents );\n                }\n            }\n\n            memset(keys, 0, n_key_data*sizeof(krb5_keyblock));\n            free(keys);\n            return ret;\n        }\n    }\n\n    *keyblocks = keys;\n    if (n_keys)\n        *n_keys = n_key_data;\n\n    return 0;\n}\n\n/*\n * Function: kadm5_decrypt_key\n *\n * Purpose: Retrieves and decrypts a principal key.\n *\n * Arguments:\n *\n *      server_handle   (r) kadm5 handle\n *      entry           (r) principal retrieved with kadm5_get_principal\n *      ktype           (r) enctype to search for, or -1 to ignore\n *      stype           (r) salt type to search for, or -1 to ignore\n *      kvno            (r) kvno to search for, -1 for max, 0 for max\n *                      only if it also matches ktype and stype\n *      keyblock        (w) keyblock to fill in\n *      keysalt         (w) keysalt to fill in, or NULL\n *      kvnop           (w) kvno to fill in, or NULL\n *\n * Effects: Searches the key_data array of entry, which must have been\n * retrived with kadm5_get_principal with the KADM5_KEY_DATA mask, to\n * find a key with a specified enctype, salt type, and kvno in a\n * principal entry.  If not found, return ENOENT.  Otherwise, decrypt\n * it with the master key, and return the key in keyblock, the salt\n * in salttype, and the key version number in kvno.\n *\n * If ktype or stype is -1, it is ignored for the search.  If kvno is\n * -1, ktype and stype are ignored and the key with the max kvno is\n * returned.  If kvno is 0, only the key with the max kvno is returned\n * and only if it matches the ktype and stype; otherwise, ENOENT is\n * returned.\n */\nkadm5_ret_t kadm5_decrypt_key(void *server_handle,\n                              kadm5_principal_ent_t entry, krb5_int32\n                              ktype, krb5_int32 stype, krb5_int32\n                              kvno, krb5_keyblock *keyblock,\n                              krb5_keysalt *keysalt, int *kvnop)\n{\n    kadm5_server_handle_t handle = server_handle;\n    krb5_db_entry dbent;\n    krb5_key_data *key_data;\n    krb5_keyblock *mkey_ptr;\n    int ret;\n\n    CHECK_HANDLE(server_handle);\n\n    if (entry->n_key_data == 0 || entry->key_data == NULL)\n        return EINVAL;\n\n    /* find_enctype only uses these two fields */\n    dbent.n_key_data = entry->n_key_data;\n    dbent.key_data = entry->key_data;\n    if ((ret = krb5_dbe_find_enctype(handle->context, &dbent, ktype,\n                                     stype, kvno, &key_data)))\n        return ret;\n\n    /* find_mkey only uses this field */\n    dbent.tl_data = entry->tl_data;\n    if ((ret = krb5_dbe_find_mkey(handle->context, &dbent, &mkey_ptr))) {\n        /* try refreshing master key list */\n        /* XXX it would nice if we had the mkvno here for optimization */\n        if (krb5_db_fetch_mkey_list(handle->context, master_princ,\n                                    &master_keyblock) == 0) {\n            if ((ret = krb5_dbe_find_mkey(handle->context, &dbent,\n                                          &mkey_ptr))) {\n                return ret;\n            }\n        } else {\n            return ret;\n        }\n    }\n\n    if ((ret = krb5_dbe_decrypt_key_data(handle->context, NULL, key_data,\n                                         keyblock, keysalt)))\n        return ret;\n\n    /*\n     * Coerce the enctype of the output keyblock in case we got an\n     * inexact match on the enctype; this behavior will go away when\n     * the key storage architecture gets redesigned for 1.3.\n     */\n    if (ktype != -1)\n        keyblock->enctype = ktype;\n\n    if (kvnop)\n        *kvnop = key_data->key_data_kvno;\n\n    return KADM5_OK;\n}\n\nkadm5_ret_t\nkadm5_purgekeys(void *server_handle,\n                krb5_principal principal,\n                int keepkvno)\n{\n    kadm5_server_handle_t handle = server_handle;\n    kadm5_ret_t ret;\n    krb5_db_entry *kdb;\n    osa_princ_ent_rec adb;\n    krb5_key_data *old_keydata;\n    int n_old_keydata;\n    int i, j, k;\n\n    CHECK_HANDLE(server_handle);\n\n    if (principal == NULL)\n        return EINVAL;\n\n    ret = kdb_get_entry(handle, principal, &kdb, &adb);\n    if (ret)\n        return(ret);\n\n    if (keepkvno <= 0) {\n        keepkvno = krb5_db_get_key_data_kvno(handle->context, kdb->n_key_data,\n                                             kdb->key_data);\n    }\n\n    old_keydata = kdb->key_data;\n    n_old_keydata = kdb->n_key_data;\n    kdb->n_key_data = 0;\n    kdb->key_data = krb5_db_alloc(handle->context, NULL,\n                                  n_old_keydata * sizeof(krb5_key_data));\n    if (kdb->key_data == NULL) {\n        ret = ENOMEM;\n        goto done;\n    }\n    memset(kdb->key_data, 0, n_old_keydata * sizeof(krb5_key_data));\n    for (i = 0, j = 0; i < n_old_keydata; i++) {\n        if (old_keydata[i].key_data_kvno < keepkvno)\n            continue;\n\n        /* Alias the key_data_contents pointers; we null them out in the\n         * source array immediately after. */\n        kdb->key_data[j] = old_keydata[i];\n        for (k = 0; k < old_keydata[i].key_data_ver; k++) {\n            old_keydata[i].key_data_contents[k] = NULL;\n        }\n        j++;\n    }\n    kdb->n_key_data = j;\n    cleanup_key_data(handle->context, n_old_keydata, old_keydata);\n\n    kdb->mask = KADM5_KEY_DATA;\n    ret = kdb_put_entry(handle, kdb, &adb);\n    if (ret)\n        goto done;\n\ndone:\n    kdb_free_entry(handle, kdb, &adb);\n    return ret;\n}\n\nkadm5_ret_t\nkadm5_get_strings(void *server_handle, krb5_principal principal,\n                  krb5_string_attr **strings_out, int *count_out)\n{\n    kadm5_server_handle_t handle = server_handle;\n    kadm5_ret_t ret;\n    krb5_db_entry *kdb = NULL;\n\n    *strings_out = NULL;\n    *count_out = 0;\n    CHECK_HANDLE(server_handle);\n    if (principal == NULL)\n        return EINVAL;\n\n    ret = kdb_get_entry(handle, principal, &kdb, NULL);\n    if (ret)\n        return ret;\n\n    ret = krb5_dbe_get_strings(handle->context, kdb, strings_out, count_out);\n    kdb_free_entry(handle, kdb, NULL);\n    return ret;\n}\n\nkadm5_ret_t\nkadm5_set_string(void *server_handle, krb5_principal principal,\n                 const char *key, const char *value)\n{\n    kadm5_server_handle_t handle = server_handle;\n    kadm5_ret_t ret;\n    krb5_db_entry *kdb;\n    osa_princ_ent_rec adb;\n\n    CHECK_HANDLE(server_handle);\n    if (principal == NULL || key == NULL)\n        return EINVAL;\n\n    ret = kdb_get_entry(handle, principal, &kdb, &adb);\n    if (ret)\n        return ret;\n\n    ret = krb5_dbe_set_string(handle->context, kdb, key, value);\n    if (ret)\n        goto done;\n\n    kdb->mask = KADM5_TL_DATA;\n    ret = kdb_put_entry(handle, kdb, &adb);\n\ndone:\n    kdb_free_entry(handle, kdb, &adb);\n    return ret;\n}\n"], "fixing_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n * Copyright 1993 OpenVision Technologies, Inc., All Rights Reserved\n *\n * $Header$\n */\n#include \"k5-int.h\"\n#include        <sys/time.h>\n#include        <kadm5/admin.h>\n#include        <kdb.h>\n#include        \"server_internal.h\"\n#ifdef USE_PASSWORD_SERVER\n#include        <sys/wait.h>\n#include        <signal.h>\n#endif\n\n#include <krb5/kadm5_hook_plugin.h>\n\n#ifdef USE_VALGRIND\n#include <valgrind/memcheck.h>\n#else\n#define VALGRIND_CHECK_DEFINED(LVALUE) ((void)0)\n#endif\n\nextern  krb5_principal      master_princ;\nextern  krb5_principal      hist_princ;\nextern  krb5_keyblock       master_keyblock;\nextern  krb5_actkvno_node  *active_mkey_list;\nextern  krb5_db_entry       master_db;\n\nstatic int decrypt_key_data(krb5_context context,\n                            int n_key_data, krb5_key_data *key_data,\n                            krb5_keyblock **keyblocks, int *n_keys);\n\nstatic krb5_error_code\nkadm5_copy_principal(krb5_context context, krb5_const_principal inprinc, krb5_principal *outprinc)\n{\n    register krb5_principal tempprinc;\n    register int i, nelems;\n\n    tempprinc = (krb5_principal)krb5_db_alloc(context, NULL, sizeof(krb5_principal_data));\n\n    if (tempprinc == 0)\n        return ENOMEM;\n\n    VALGRIND_CHECK_DEFINED(*inprinc);\n    *tempprinc = *inprinc;\n\n    nelems = (int) krb5_princ_size(context, inprinc);\n    tempprinc->data = krb5_db_alloc(context, NULL, nelems * sizeof(krb5_data));\n    if (tempprinc->data == 0) {\n        krb5_db_free(context, (char *)tempprinc);\n        return ENOMEM;\n    }\n\n    for (i = 0; i < nelems; i++) {\n        unsigned int len = krb5_princ_component(context, inprinc, i)->length;\n        krb5_princ_component(context, tempprinc, i)->length = len;\n        if (((krb5_princ_component(context, tempprinc, i)->data =\n              krb5_db_alloc(context, NULL, len)) == 0) && len) {\n            while (--i >= 0)\n                krb5_db_free(context, krb5_princ_component(context, tempprinc, i)->data);\n            krb5_db_free (context, tempprinc->data);\n            krb5_db_free (context, tempprinc);\n            return ENOMEM;\n        }\n        if (len)\n            memcpy(krb5_princ_component(context, tempprinc, i)->data,\n                   krb5_princ_component(context, inprinc, i)->data, len);\n        krb5_princ_component(context, tempprinc, i)->magic = KV5M_DATA;\n    }\n\n    tempprinc->realm.data =\n        krb5_db_alloc(context, NULL, tempprinc->realm.length = inprinc->realm.length);\n    if (!tempprinc->realm.data && tempprinc->realm.length) {\n        for (i = 0; i < nelems; i++)\n            krb5_db_free(context, krb5_princ_component(context, tempprinc, i)->data);\n        krb5_db_free(context, tempprinc->data);\n        krb5_db_free(context, tempprinc);\n        return ENOMEM;\n    }\n    if (tempprinc->realm.length)\n        memcpy(tempprinc->realm.data, inprinc->realm.data,\n               inprinc->realm.length);\n\n    *outprinc = tempprinc;\n    return 0;\n}\n\nstatic void\nkadm5_free_principal(krb5_context context, krb5_principal val)\n{\n    register krb5_int32 i;\n\n    if (!val)\n        return;\n\n    if (val->data) {\n        i = krb5_princ_size(context, val);\n        while(--i >= 0)\n            krb5_db_free(context, krb5_princ_component(context, val, i)->data);\n        krb5_db_free(context, val->data);\n    }\n    if (val->realm.data)\n        krb5_db_free(context, val->realm.data);\n    krb5_db_free(context, val);\n}\n\n/*\n * XXX Functions that ought to be in libkrb5.a, but aren't.\n */\nkadm5_ret_t krb5_copy_key_data_contents(context, from, to)\n    krb5_context context;\n    krb5_key_data *from, *to;\n{\n    int i, idx;\n\n    *to = *from;\n\n    idx = (from->key_data_ver == 1 ? 1 : 2);\n\n    for (i = 0; i < idx; i++) {\n        if ( from->key_data_length[i] ) {\n            to->key_data_contents[i] = malloc(from->key_data_length[i]);\n            if (to->key_data_contents[i] == NULL) {\n                for (i = 0; i < idx; i++) {\n                    if (to->key_data_contents[i]) {\n                        memset(to->key_data_contents[i], 0,\n                               to->key_data_length[i]);\n                        free(to->key_data_contents[i]);\n                    }\n                }\n                return ENOMEM;\n            }\n            memcpy(to->key_data_contents[i], from->key_data_contents[i],\n                   from->key_data_length[i]);\n        }\n    }\n    return 0;\n}\n\nstatic krb5_tl_data *dup_tl_data(krb5_tl_data *tl)\n{\n    krb5_tl_data *n;\n\n    n = (krb5_tl_data *) malloc(sizeof(krb5_tl_data));\n    if (n == NULL)\n        return NULL;\n    n->tl_data_contents = malloc(tl->tl_data_length);\n    if (n->tl_data_contents == NULL) {\n        free(n);\n        return NULL;\n    }\n    memcpy(n->tl_data_contents, tl->tl_data_contents, tl->tl_data_length);\n    n->tl_data_type = tl->tl_data_type;\n    n->tl_data_length = tl->tl_data_length;\n    n->tl_data_next = NULL;\n    return n;\n}\n\n/* This is in lib/kdb/kdb_cpw.c, but is static */\nstatic void cleanup_key_data(context, count, data)\n    krb5_context   context;\n    int                    count;\n    krb5_key_data        * data;\n{\n    int i, j;\n\n    for (i = 0; i < count; i++)\n        for (j = 0; j < data[i].key_data_ver; j++)\n            if (data[i].key_data_length[j])\n                krb5_db_free(context, data[i].key_data_contents[j]);\n    krb5_db_free(context, data);\n}\n\n/*\n * Set *passptr to NULL if the request looks like the first part of a krb5 1.6\n * addprinc -randkey operation.  The krb5 1.6 dummy password for these requests\n * was invalid UTF-8, which runs afoul of the arcfour string-to-key.\n */\nstatic void\ncheck_1_6_dummy(kadm5_principal_ent_t entry, long mask,\n                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)\n{\n    int i;\n    char *password = *passptr;\n\n    /* Old-style randkey operations disallowed tickets to start. */\n    if (password == NULL || !(mask & KADM5_ATTRIBUTES) ||\n        !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))\n        return;\n\n    /* The 1.6 dummy password was the octets 1..255. */\n    for (i = 0; (unsigned char) password[i] == i + 1; i++);\n    if (password[i] != '\\0' || i != 255)\n        return;\n\n    /* This will make the caller use a random password instead. */\n    *passptr = NULL;\n}\n\nkadm5_ret_t\nkadm5_create_principal(void *server_handle,\n                       kadm5_principal_ent_t entry, long mask,\n                       char *password)\n{\n    return\n        kadm5_create_principal_3(server_handle, entry, mask,\n                                 0, NULL, password);\n}\nkadm5_ret_t\nkadm5_create_principal_3(void *server_handle,\n                         kadm5_principal_ent_t entry, long mask,\n                         int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                         char *password)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    kadm5_policy_ent_rec        polent;\n    krb5_boolean                have_polent = FALSE;\n    krb5_int32                  now;\n    krb5_tl_data                *tl_data_orig, *tl_data_tail;\n    unsigned int                ret;\n    kadm5_server_handle_t handle = server_handle;\n    krb5_keyblock               *act_mkey;\n    krb5_kvno                   act_kvno;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    check_1_6_dummy(entry, mask, n_ks_tuple, ks_tuple, &password);\n\n    /*\n     * Argument sanity checking, and opening up the DB\n     */\n    if(!(mask & KADM5_PRINCIPAL) || (mask & KADM5_MOD_NAME) ||\n       (mask & KADM5_MOD_TIME) || (mask & KADM5_LAST_PWD_CHANGE) ||\n       (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||\n       (mask & KADM5_KEY_DATA) || (mask & KADM5_LAST_SUCCESS) ||\n       (mask & KADM5_LAST_FAILED) || (mask & KADM5_FAIL_AUTH_COUNT))\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))\n        return KADM5_BAD_MASK;\n    if((mask & ~ALL_PRINC_MASK))\n        return KADM5_BAD_MASK;\n    if (entry == NULL)\n        return EINVAL;\n\n    /* Use default keysalts if caller did not provide any. */\n    if (n_ks_tuple == 0) {\n        ks_tuple = handle->params.keysalts;\n        n_ks_tuple = handle->params.num_keysalts;\n    }\n\n    /*\n     * Check to see if the principal exists\n     */\n    ret = kdb_get_entry(handle, entry->principal, &kdb, &adb);\n\n    switch(ret) {\n    case KADM5_UNK_PRINC:\n        break;\n    case 0:\n        kdb_free_entry(handle, kdb, &adb);\n        return KADM5_DUP;\n    default:\n        return ret;\n    }\n\n    kdb = krb5_db_alloc(handle->context, NULL, sizeof(*kdb));\n    if (kdb == NULL)\n        return ENOMEM;\n    memset(kdb, 0, sizeof(*kdb));\n    memset(&adb, 0, sizeof(osa_princ_ent_rec));\n\n    /*\n     * If a policy was specified, load it.\n     * If we can not find the one specified return an error\n     */\n    if ((mask & KADM5_POLICY)) {\n        if ((ret = kadm5_get_policy(handle->lhandle, entry->policy,\n                                    &polent)) != KADM5_OK) {\n            if (ret == EINVAL)\n                ret = KADM5_BAD_POLICY;\n            if (ret)\n                goto cleanup;\n        }\n        have_polent = TRUE;\n    }\n    if (password) {\n        ret = passwd_check(handle, password, have_polent ? &polent : NULL,\n                           entry->principal);\n        if (ret)\n            goto cleanup;\n    }\n    /*\n     * Start populating the various DB fields, using the\n     * \"defaults\" for fields that were not specified by the\n     * mask.\n     */\n    if ((ret = krb5_timeofday(handle->context, &now)))\n        goto cleanup;\n\n    kdb->magic = KRB5_KDB_MAGIC_NUMBER;\n    kdb->len = KRB5_KDB_V1_BASE_LENGTH; /* gag me with a chainsaw */\n\n    if ((mask & KADM5_ATTRIBUTES))\n        kdb->attributes = entry->attributes;\n    else\n        kdb->attributes = handle->params.flags;\n\n    if ((mask & KADM5_MAX_LIFE))\n        kdb->max_life = entry->max_life;\n    else\n        kdb->max_life = handle->params.max_life;\n\n    if (mask & KADM5_MAX_RLIFE)\n        kdb->max_renewable_life = entry->max_renewable_life;\n    else\n        kdb->max_renewable_life = handle->params.max_rlife;\n\n    if ((mask & KADM5_PRINC_EXPIRE_TIME))\n        kdb->expiration = entry->princ_expire_time;\n    else\n        kdb->expiration = handle->params.expiration;\n\n    kdb->pw_expiration = 0;\n    if (have_polent) {\n        if(polent.pw_max_life)\n            kdb->pw_expiration = now + polent.pw_max_life;\n        else\n            kdb->pw_expiration = 0;\n    }\n    if ((mask & KADM5_PW_EXPIRATION))\n        kdb->pw_expiration = entry->pw_expiration;\n\n    kdb->last_success = 0;\n    kdb->last_failed = 0;\n    kdb->fail_auth_count = 0;\n\n    /* this is kind of gross, but in order to free the tl data, I need\n       to free the entire kdb entry, and that will try to free the\n       principal. */\n\n    if ((ret = kadm5_copy_principal(handle->context,\n                                    entry->principal, &(kdb->princ))))\n        goto cleanup;\n\n    if ((ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now)))\n        goto cleanup;\n\n    if (mask & KADM5_TL_DATA) {\n        /* splice entry->tl_data onto the front of kdb->tl_data */\n        tl_data_orig = kdb->tl_data;\n        for (tl_data_tail = entry->tl_data; tl_data_tail;\n             tl_data_tail = tl_data_tail->tl_data_next)\n        {\n            ret = krb5_dbe_update_tl_data(handle->context, kdb, tl_data_tail);\n            if( ret )\n                goto cleanup;\n        }\n    }\n\n    /* initialize the keys */\n\n    ret = krb5_dbe_find_act_mkey(handle->context, active_mkey_list, &act_kvno,\n                                 &act_mkey);\n    if (ret)\n        goto cleanup;\n\n    if (password) {\n        ret = krb5_dbe_cpw(handle->context, act_mkey, ks_tuple, n_ks_tuple,\n                           password, (mask & KADM5_KVNO)?entry->kvno:1,\n                           FALSE, kdb);\n    } else {\n        /* Null password means create with random key (new in 1.8). */\n        ret = krb5_dbe_crk(handle->context, &master_keyblock,\n                           ks_tuple, n_ks_tuple, FALSE, kdb);\n    }\n    if (ret)\n        goto cleanup;\n\n    /* Record the master key VNO used to encrypt this entry's keys */\n    ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);\n    if (ret)\n        goto cleanup;\n\n    ret = k5_kadm5_hook_create(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, entry, mask,\n                               n_ks_tuple, ks_tuple, password);\n    if (ret)\n        goto cleanup;\n\n    /* populate the admin-server-specific fields.  In the OV server,\n       this used to be in a separate database.  Since there's already\n       marshalling code for the admin fields, to keep things simple,\n       I'm going to keep it, and make all the admin stuff occupy a\n       single tl_data record, */\n\n    adb.admin_history_kvno = INITIAL_HIST_KVNO;\n    if (have_polent) {\n        adb.aux_attributes = KADM5_POLICY;\n\n        /* this does *not* need to be strdup'ed, because adb is xdr */\n        /* encoded in osa_adb_create_princ, and not ever freed */\n\n        adb.policy = entry->policy;\n    }\n\n    /* increment the policy ref count, if any */\n\n    if (have_polent) {\n        polent.policy_refcnt++;\n        if ((ret = kadm5_modify_policy_internal(handle->lhandle, &polent,\n                                                KADM5_REF_COUNT))\n            != KADM5_OK)\n            goto cleanup;\n    }\n\n    /* In all cases key and the principal data is set, let the database provider know */\n    kdb->mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ;\n\n    /* store the new db entry */\n    ret = kdb_put_entry(handle, kdb, &adb);\n\n\n    if (ret) {\n        if (have_polent) {\n            /* decrement the policy ref count */\n\n            polent.policy_refcnt--;\n            /*\n             * if this fails, there's nothing we can do anyway.  the\n             * policy refcount wil be too high.\n             */\n            (void) kadm5_modify_policy_internal(handle->lhandle, &polent,\n                                                KADM5_REF_COUNT);\n        }\n    }\n\n    (void) k5_kadm5_hook_create(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, entry, mask,\n                                n_ks_tuple, ks_tuple, password);\n\ncleanup:\n    krb5_db_free_principal(handle->context, kdb);\n    if (have_polent)\n        (void) kadm5_free_policy_ent(handle->lhandle, &polent);\n    return ret;\n}\n\n\nkadm5_ret_t\nkadm5_delete_principal(void *server_handle, krb5_principal principal)\n{\n    unsigned int                ret;\n    kadm5_policy_ent_rec        polent;\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    kadm5_server_handle_t handle = server_handle;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if (principal == NULL)\n        return EINVAL;\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return(ret);\n    ret = k5_kadm5_hook_remove(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, principal);\n    if (ret) {\n        kdb_free_entry(handle, kdb, &adb);\n        return ret;\n    }\n\n    if ((adb.aux_attributes & KADM5_POLICY)) {\n        if ((ret = kadm5_get_policy(handle->lhandle,\n                                    adb.policy, &polent))\n            == KADM5_OK) {\n            polent.policy_refcnt--;\n            if ((ret = kadm5_modify_policy_internal(handle->lhandle, &polent,\n                                                    KADM5_REF_COUNT))\n                != KADM5_OK) {\n                (void) kadm5_free_policy_ent(handle->lhandle, &polent);\n                kdb_free_entry(handle, kdb, &adb);\n                return(ret);\n            }\n        }\n        if ((ret = kadm5_free_policy_ent(handle->lhandle, &polent))) {\n            kdb_free_entry(handle, kdb, &adb);\n            return ret;\n        }\n    }\n\n    ret = kdb_delete_entry(handle, principal);\n\n    kdb_free_entry(handle, kdb, &adb);\n\n    if (ret == 0)\n        (void) k5_kadm5_hook_remove(handle->context,\n                                    handle->hook_handles,\n                                    KADM5_HOOK_STAGE_POSTCOMMIT, principal);\n\n    return ret;\n}\n\nkadm5_ret_t\nkadm5_modify_principal(void *server_handle,\n                       kadm5_principal_ent_t entry, long mask)\n{\n    int                     ret, ret2, i;\n    kadm5_policy_ent_rec    npol, opol;\n    int                     have_npol = 0, have_opol = 0;\n    krb5_db_entry           *kdb;\n    krb5_tl_data            *tl_data_orig;\n    osa_princ_ent_rec       adb;\n    kadm5_server_handle_t handle = server_handle;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if((mask & KADM5_PRINCIPAL) || (mask & KADM5_LAST_PWD_CHANGE) ||\n       (mask & KADM5_MOD_TIME) || (mask & KADM5_MOD_NAME) ||\n       (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||\n       (mask & KADM5_KEY_DATA) || (mask & KADM5_LAST_SUCCESS) ||\n       (mask & KADM5_LAST_FAILED))\n        return KADM5_BAD_MASK;\n    if((mask & ~ALL_PRINC_MASK))\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))\n        return KADM5_BAD_MASK;\n    if(entry == (kadm5_principal_ent_t) NULL)\n        return EINVAL;\n    if (mask & KADM5_TL_DATA) {\n        tl_data_orig = entry->tl_data;\n        while (tl_data_orig) {\n            if (tl_data_orig->tl_data_type < 256)\n                return KADM5_BAD_TL_TYPE;\n            tl_data_orig = tl_data_orig->tl_data_next;\n        }\n    }\n\n    ret = kdb_get_entry(handle, entry->principal, &kdb, &adb);\n    if (ret)\n        return(ret);\n\n    /*\n     * This is pretty much the same as create ...\n     */\n\n    if ((mask & KADM5_POLICY)) {\n        /* get the new policy */\n        ret = kadm5_get_policy(handle->lhandle, entry->policy, &npol);\n        if (ret) {\n            switch (ret) {\n            case EINVAL:\n                ret = KADM5_BAD_POLICY;\n                break;\n            case KADM5_UNK_POLICY:\n            case KADM5_BAD_POLICY:\n                ret =  KADM5_UNK_POLICY;\n                break;\n            }\n            goto done;\n        }\n        have_npol = 1;\n\n        /* if we already have a policy, get it to decrement the refcnt */\n        if(adb.aux_attributes & KADM5_POLICY) {\n            /* ... but not if the old and new are the same */\n            if(strcmp(adb.policy, entry->policy)) {\n                ret = kadm5_get_policy(handle->lhandle,\n                                       adb.policy, &opol);\n                switch(ret) {\n                case EINVAL:\n                case KADM5_BAD_POLICY:\n                case KADM5_UNK_POLICY:\n                    break;\n                case KADM5_OK:\n                    have_opol = 1;\n                    opol.policy_refcnt--;\n                    break;\n                default:\n                    goto done;\n                    break;\n                }\n                npol.policy_refcnt++;\n            }\n        } else npol.policy_refcnt++;\n\n        /* set us up to use the new policy */\n        adb.aux_attributes |= KADM5_POLICY;\n        if (adb.policy)\n            free(adb.policy);\n        adb.policy = strdup(entry->policy);\n\n        /* set pw_max_life based on new policy */\n        if (npol.pw_max_life) {\n            ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb,\n                                                  &(kdb->pw_expiration));\n            if (ret)\n                goto done;\n            kdb->pw_expiration += npol.pw_max_life;\n        } else {\n            kdb->pw_expiration = 0;\n        }\n    }\n\n    if ((mask & KADM5_POLICY_CLR) &&\n        (adb.aux_attributes & KADM5_POLICY)) {\n        ret = kadm5_get_policy(handle->lhandle, adb.policy, &opol);\n        switch(ret) {\n        case EINVAL:\n        case KADM5_BAD_POLICY:\n        case KADM5_UNK_POLICY:\n            ret = KADM5_BAD_DB;\n            goto done;\n            break;\n        case KADM5_OK:\n            have_opol = 1;\n            if (adb.policy)\n                free(adb.policy);\n            adb.policy = NULL;\n            adb.aux_attributes &= ~KADM5_POLICY;\n            kdb->pw_expiration = 0;\n            opol.policy_refcnt--;\n            break;\n        default:\n            goto done;\n            break;\n        }\n    }\n\n    if (((mask & KADM5_POLICY) || (mask & KADM5_POLICY_CLR)) &&\n        (((have_opol) &&\n          (ret =\n           kadm5_modify_policy_internal(handle->lhandle, &opol,\n                                        KADM5_REF_COUNT))) ||\n         ((have_npol) &&\n          (ret =\n           kadm5_modify_policy_internal(handle->lhandle, &npol,\n                                        KADM5_REF_COUNT)))))\n        goto done;\n\n    if ((mask & KADM5_ATTRIBUTES))\n        kdb->attributes = entry->attributes;\n    if ((mask & KADM5_MAX_LIFE))\n        kdb->max_life = entry->max_life;\n    if ((mask & KADM5_PRINC_EXPIRE_TIME))\n        kdb->expiration = entry->princ_expire_time;\n    if (mask & KADM5_PW_EXPIRATION)\n        kdb->pw_expiration = entry->pw_expiration;\n    if (mask & KADM5_MAX_RLIFE)\n        kdb->max_renewable_life = entry->max_renewable_life;\n\n    if((mask & KADM5_KVNO)) {\n        for (i = 0; i < kdb->n_key_data; i++)\n            kdb->key_data[i].key_data_kvno = entry->kvno;\n    }\n\n    if (mask & KADM5_TL_DATA) {\n        krb5_tl_data *tl;\n\n        /* may have to change the version number of the API. Updates the list with the given tl_data rather than over-writting */\n\n        for (tl = entry->tl_data; tl;\n             tl = tl->tl_data_next)\n        {\n            ret = krb5_dbe_update_tl_data(handle->context, kdb, tl);\n            if( ret )\n            {\n                goto done;\n            }\n        }\n    }\n\n    /*\n     * Setting entry->fail_auth_count to 0 can be used to manually unlock\n     * an account. It is not possible to set fail_auth_count to any other\n     * value using kadmin.\n     */\n    if (mask & KADM5_FAIL_AUTH_COUNT) {\n        if (entry->fail_auth_count != 0) {\n            ret = KADM5_BAD_SERVER_PARAMS;\n            goto done;\n        }\n\n        kdb->fail_auth_count = 0;\n    }\n\n    /* let the mask propagate to the database provider */\n    kdb->mask = mask;\n\n    ret = k5_kadm5_hook_modify(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, entry, mask);\n    if (ret)\n        goto done;\n\n    ret = kdb_put_entry(handle, kdb, &adb);\n    if (ret) goto done;\n    (void) k5_kadm5_hook_modify(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, entry, mask);\n\n    ret = KADM5_OK;\ndone:\n    if (have_opol) {\n        ret2 = kadm5_free_policy_ent(handle->lhandle, &opol);\n        ret = ret ? ret : ret2;\n    }\n    if (have_npol) {\n        ret2 = kadm5_free_policy_ent(handle->lhandle, &npol);\n        ret = ret ? ret : ret2;\n    }\n    kdb_free_entry(handle, kdb, &adb);\n    return ret;\n}\n\nkadm5_ret_t\nkadm5_rename_principal(void *server_handle,\n                       krb5_principal source, krb5_principal target)\n{\n    krb5_db_entry *kdb;\n    osa_princ_ent_rec adb;\n    krb5_error_code ret;\n    kadm5_server_handle_t handle = server_handle;\n    krb5_int16 stype, i;\n    krb5_data *salt = NULL;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if (source == NULL || target == NULL)\n        return EINVAL;\n\n    if ((ret = kdb_get_entry(handle, target, &kdb, &adb)) == 0) {\n        kdb_free_entry(handle, kdb, &adb);\n        return(KADM5_DUP);\n    }\n\n    if ((ret = kdb_get_entry(handle, source, &kdb, &adb)))\n        return ret;\n\n    /* Transform salts as necessary. */\n    for (i = 0; i < kdb->n_key_data; i++) {\n        ret = krb5_dbe_compute_salt(handle->context, &kdb->key_data[i],\n                                    kdb->princ, &stype, &salt);\n        if (ret == KRB5_KDB_BAD_SALTTYPE)\n            ret = KADM5_NO_RENAME_SALT;\n        if (ret)\n            goto done;\n        kdb->key_data[i].key_data_type[1] = KRB5_KDB_SALTTYPE_SPECIAL;\n        free(kdb->key_data[i].key_data_contents[1]);\n        kdb->key_data[i].key_data_contents[1] = (krb5_octet *)salt->data;\n        kdb->key_data[i].key_data_length[1] = salt->length;\n        kdb->key_data[i].key_data_ver = 2;\n        free(salt);\n        salt = NULL;\n    }\n\n    kadm5_free_principal(handle->context, kdb->princ);\n    ret = kadm5_copy_principal(handle->context, target, &kdb->princ);\n    if (ret) {\n        kdb->princ = NULL; /* so freeing the dbe doesn't lose */\n        goto done;\n    }\n\n    if ((ret = kdb_put_entry(handle, kdb, &adb)))\n        goto done;\n\n    ret = kdb_delete_entry(handle, source);\n\ndone:\n    krb5_free_data(handle->context, salt);\n    kdb_free_entry(handle, kdb, &adb);\n    return ret;\n}\n\nkadm5_ret_t\nkadm5_get_principal(void *server_handle, krb5_principal principal,\n                    kadm5_principal_ent_t entry,\n                    long in_mask)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    krb5_error_code             ret = 0;\n    long                        mask;\n    int i;\n    kadm5_server_handle_t handle = server_handle;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    /*\n     * In version 1, all the defined fields are always returned.\n     * entry is a pointer to a kadm5_principal_ent_t_v1 that should be\n     * filled with allocated memory.\n     */\n    mask = in_mask;\n\n    memset(entry, 0, sizeof(*entry));\n\n    if (principal == NULL)\n        return EINVAL;\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return ret;\n\n    if ((mask & KADM5_POLICY) &&\n        adb.policy && (adb.aux_attributes & KADM5_POLICY)) {\n        if ((entry->policy = strdup(adb.policy)) == NULL) {\n            ret = ENOMEM;\n            goto done;\n        }\n    }\n\n    if (mask & KADM5_AUX_ATTRIBUTES)\n        entry->aux_attributes = adb.aux_attributes;\n\n    if ((mask & KADM5_PRINCIPAL) &&\n        (ret = krb5_copy_principal(handle->context, kdb->princ,\n                                   &entry->principal))) {\n        goto done;\n    }\n\n    if (mask & KADM5_PRINC_EXPIRE_TIME)\n        entry->princ_expire_time = kdb->expiration;\n\n    if ((mask & KADM5_LAST_PWD_CHANGE) &&\n        (ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb,\n                                               &(entry->last_pwd_change)))) {\n        goto done;\n    }\n\n    if (mask & KADM5_PW_EXPIRATION)\n        entry->pw_expiration = kdb->pw_expiration;\n    if (mask & KADM5_MAX_LIFE)\n        entry->max_life = kdb->max_life;\n\n    /* this is a little non-sensical because the function returns two */\n    /* values that must be checked separately against the mask */\n    if ((mask & KADM5_MOD_NAME) || (mask & KADM5_MOD_TIME)) {\n        ret = krb5_dbe_lookup_mod_princ_data(handle->context, kdb,\n                                             &(entry->mod_date),\n                                             &(entry->mod_name));\n        if (ret) {\n            goto done;\n        }\n\n        if (! (mask & KADM5_MOD_TIME))\n            entry->mod_date = 0;\n        if (! (mask & KADM5_MOD_NAME)) {\n            krb5_free_principal(handle->context, entry->mod_name);\n            entry->mod_name = NULL;\n        }\n    }\n\n    if (mask & KADM5_ATTRIBUTES)\n        entry->attributes = kdb->attributes;\n\n    if (mask & KADM5_KVNO)\n        for (entry->kvno = 0, i=0; i<kdb->n_key_data; i++)\n            if ((krb5_kvno) kdb->key_data[i].key_data_kvno > entry->kvno)\n                entry->kvno = kdb->key_data[i].key_data_kvno;\n\n    if (mask & KADM5_MKVNO) {\n        ret = krb5_dbe_get_mkvno(handle->context, kdb, &entry->mkvno);\n        if (ret)\n            goto done;\n    }\n\n    if (mask & KADM5_MAX_RLIFE)\n        entry->max_renewable_life = kdb->max_renewable_life;\n    if (mask & KADM5_LAST_SUCCESS)\n        entry->last_success = kdb->last_success;\n    if (mask & KADM5_LAST_FAILED)\n        entry->last_failed = kdb->last_failed;\n    if (mask & KADM5_FAIL_AUTH_COUNT)\n        entry->fail_auth_count = kdb->fail_auth_count;\n    if (mask & KADM5_TL_DATA) {\n        krb5_tl_data *tl, *tl2;\n\n        entry->tl_data = NULL;\n\n        tl = kdb->tl_data;\n        while (tl) {\n            if (tl->tl_data_type > 255) {\n                if ((tl2 = dup_tl_data(tl)) == NULL) {\n                    ret = ENOMEM;\n                    goto done;\n                }\n                tl2->tl_data_next = entry->tl_data;\n                entry->tl_data = tl2;\n                entry->n_tl_data++;\n            }\n\n            tl = tl->tl_data_next;\n        }\n    }\n    if (mask & KADM5_KEY_DATA) {\n        entry->n_key_data = kdb->n_key_data;\n        if(entry->n_key_data) {\n            entry->key_data = malloc(entry->n_key_data*sizeof(krb5_key_data));\n            if (entry->key_data == NULL) {\n                ret = ENOMEM;\n                goto done;\n            }\n        } else\n            entry->key_data = NULL;\n\n        for (i = 0; i < entry->n_key_data; i++)\n            ret = krb5_copy_key_data_contents(handle->context,\n                                              &kdb->key_data[i],\n                                              &entry->key_data[i]);\n        if (ret)\n            goto done;\n    }\n\n    ret = KADM5_OK;\n\ndone:\n    if (ret && entry->principal) {\n        krb5_free_principal(handle->context, entry->principal);\n        entry->principal = NULL;\n    }\n    kdb_free_entry(handle, kdb, &adb);\n\n    return ret;\n}\n\n/*\n * Function: check_pw_reuse\n *\n * Purpose: Check if a key appears in a list of keys, in order to\n * enforce password history.\n *\n * Arguments:\n *\n *      context                 (r) the krb5 context\n *      hist_keyblock           (r) the key that hist_key_data is\n *                              encrypted in\n *      n_new_key_data          (r) length of new_key_data\n *      new_key_data            (r) keys to check against\n *                              pw_hist_data, encrypted in hist_keyblock\n *      n_pw_hist_data          (r) length of pw_hist_data\n *      pw_hist_data            (r) passwords to check new_key_data against\n *\n * Effects:\n * For each new_key in new_key_data:\n *      decrypt new_key with the master_keyblock\n *      for each password in pw_hist_data:\n *              for each hist_key in password:\n *                      decrypt hist_key with hist_keyblock\n *                      compare the new_key and hist_key\n *\n * Returns krb5 errors, KADM5_PASS_RESUSE if a key in\n * new_key_data is the same as a key in pw_hist_data, or 0.\n */\nstatic kadm5_ret_t\ncheck_pw_reuse(krb5_context context,\n               krb5_keyblock *hist_keyblocks,\n               int n_new_key_data, krb5_key_data *new_key_data,\n               unsigned int n_pw_hist_data, osa_pw_hist_ent *pw_hist_data)\n{\n    unsigned int x, y, z;\n    krb5_keyblock newkey, histkey, *kb;\n    krb5_key_data *key_data;\n    krb5_error_code ret;\n\n    assert (n_new_key_data >= 0);\n    for (x = 0; x < (unsigned) n_new_key_data; x++) {\n        /* Check only entries with the most recent kvno. */\n        if (new_key_data[x].key_data_kvno != new_key_data[0].key_data_kvno)\n            break;\n        ret = krb5_dbe_decrypt_key_data(context, NULL, &(new_key_data[x]),\n                                        &newkey, NULL);\n        if (ret)\n            return(ret);\n        for (y = 0; y < n_pw_hist_data; y++) {\n            for (z = 0; z < (unsigned int) pw_hist_data[y].n_key_data; z++) {\n                for (kb = hist_keyblocks; kb->enctype != 0; kb++) {\n                    key_data = &pw_hist_data[y].key_data[z];\n                    ret = krb5_dbe_decrypt_key_data(context, kb, key_data,\n                                                    &histkey, NULL);\n                    if (ret)\n                        continue;\n                    if (newkey.length == histkey.length &&\n                        newkey.enctype == histkey.enctype &&\n                        memcmp(newkey.contents, histkey.contents,\n                               histkey.length) == 0) {\n                        krb5_free_keyblock_contents(context, &histkey);\n                        krb5_free_keyblock_contents(context, &newkey);\n                        return KADM5_PASS_REUSE;\n                    }\n                    krb5_free_keyblock_contents(context, &histkey);\n                }\n            }\n        }\n        krb5_free_keyblock_contents(context, &newkey);\n    }\n\n    return(0);\n}\n\n/*\n * Function: create_history_entry\n *\n * Purpose: Creates a password history entry from an array of\n * key_data.\n *\n * Arguments:\n *\n *      context         (r) krb5_context to use\n *      mkey            (r) master keyblock to decrypt key data with\n *      hist_key        (r) history keyblock to encrypt key data with\n *      n_key_data      (r) number of elements in key_data\n *      key_data        (r) keys to add to the history entry\n *      hist            (w) history entry to fill in\n *\n * Effects:\n *\n * hist->key_data is allocated to store n_key_data key_datas.  Each\n * element of key_data is decrypted with master_keyblock, re-encrypted\n * in hist_key, and added to hist->key_data.  hist->n_key_data is\n * set to n_key_data.\n */\nstatic\nint create_history_entry(krb5_context context,\n                         krb5_keyblock *hist_key, int n_key_data,\n                         krb5_key_data *key_data, osa_pw_hist_ent *hist)\n{\n    int i, ret;\n    krb5_keyblock key;\n    krb5_keysalt salt;\n\n    hist->key_data = (krb5_key_data*)malloc(n_key_data*sizeof(krb5_key_data));\n    if (hist->key_data == NULL)\n        return ENOMEM;\n    memset(hist->key_data, 0, n_key_data*sizeof(krb5_key_data));\n\n    for (i = 0; i < n_key_data; i++) {\n        ret = krb5_dbe_decrypt_key_data(context, NULL, &key_data[i], &key,\n                                        &salt);\n        if (ret)\n            return ret;\n\n        ret = krb5_dbe_encrypt_key_data(context, hist_key, &key, &salt,\n                                        key_data[i].key_data_kvno,\n                                        &hist->key_data[i]);\n        if (ret)\n            return ret;\n\n        krb5_free_keyblock_contents(context, &key);\n        /* krb5_free_keysalt(context, &salt); */\n    }\n\n    hist->n_key_data = n_key_data;\n    return 0;\n}\n\nstatic\nvoid free_history_entry(krb5_context context, osa_pw_hist_ent *hist)\n{\n    int i;\n\n    for (i = 0; i < hist->n_key_data; i++)\n        krb5_free_key_data_contents(context, &hist->key_data[i]);\n    free(hist->key_data);\n}\n\n/*\n * Function: add_to_history\n *\n * Purpose: Adds a password to a principal's password history.\n *\n * Arguments:\n *\n *      context         (r) krb5_context to use\n *      hist_kvno       (r) kvno of current history key\n *      adb             (r/w) admin principal entry to add keys to\n *      pol             (r) adb's policy\n *      pw              (r) keys for the password to add to adb's key history\n *\n * Effects:\n *\n * add_to_history adds a single password to adb's password history.\n * pw contains n_key_data keys in its key_data, in storage should be\n * allocated but not freed by the caller (XXX blech!).\n *\n * This function maintains adb->old_keys as a circular queue.  It\n * starts empty, and grows each time this function is called until it\n * is pol->pw_history_num items long.  adb->old_key_len holds the\n * number of allocated entries in the array, and must therefore be [0,\n * pol->pw_history_num).  adb->old_key_next is the index into the\n * array where the next element should be written, and must be [0,\n * adb->old_key_len).\n */\nstatic kadm5_ret_t add_to_history(krb5_context context,\n                                  krb5_kvno hist_kvno,\n                                  osa_princ_ent_t adb,\n                                  kadm5_policy_ent_t pol,\n                                  osa_pw_hist_ent *pw)\n{\n    osa_pw_hist_ent *histp;\n    uint32_t nhist;\n    unsigned int i, knext, nkeys;\n\n    nhist = pol->pw_history_num;\n    /* A history of 1 means just check the current password */\n    if (nhist <= 1)\n        return 0;\n\n    if (adb->admin_history_kvno != hist_kvno) {\n        /* The history key has changed since the last password change, so we\n         * have to reset the password history. */\n        free(adb->old_keys);\n        adb->old_keys = NULL;\n        adb->old_key_len = 0;\n        adb->old_key_next = 0;\n        adb->admin_history_kvno = hist_kvno;\n    }\n\n    nkeys = adb->old_key_len;\n    knext = adb->old_key_next;\n    /* resize the adb->old_keys array if necessary */\n    if (nkeys + 1 < nhist) {\n        if (adb->old_keys == NULL) {\n            adb->old_keys = (osa_pw_hist_ent *)\n                malloc((nkeys + 1) * sizeof (osa_pw_hist_ent));\n        } else {\n            adb->old_keys = (osa_pw_hist_ent *)\n                realloc(adb->old_keys,\n                        (nkeys + 1) * sizeof (osa_pw_hist_ent));\n        }\n        if (adb->old_keys == NULL)\n            return(ENOMEM);\n\n        memset(&adb->old_keys[nkeys], 0, sizeof(osa_pw_hist_ent));\n        nkeys = ++adb->old_key_len;\n        /*\n         * To avoid losing old keys, shift forward each entry after\n         * knext.\n         */\n        for (i = nkeys - 1; i > knext; i--) {\n            adb->old_keys[i] = adb->old_keys[i - 1];\n        }\n        memset(&adb->old_keys[knext], 0, sizeof(osa_pw_hist_ent));\n    } else if (nkeys + 1 > nhist) {\n        /*\n         * The policy must have changed!  Shrink the array.\n         * Can't simply realloc() down, since it might be wrapped.\n         * To understand the arithmetic below, note that we are\n         * copying into new positions 0 .. N-1 from old positions\n         * old_key_next-N .. old_key_next-1, modulo old_key_len,\n         * where N = pw_history_num - 1 is the length of the\n         * shortened list.        Matt Crawford, FNAL\n         */\n        /*\n         * M = adb->old_key_len, N = pol->pw_history_num - 1\n         *\n         * tmp[0] .. tmp[N-1] = old[(knext-N)%M] .. old[(knext-1)%M]\n         */\n        int j;\n        osa_pw_hist_t tmp;\n\n        tmp = (osa_pw_hist_ent *)\n            malloc((nhist - 1) * sizeof (osa_pw_hist_ent));\n        if (tmp == NULL)\n            return ENOMEM;\n        for (i = 0; i < nhist - 1; i++) {\n            /*\n             * Add nkeys once before taking remainder to avoid\n             * negative values.\n             */\n            j = (i + nkeys + knext - (nhist - 1)) % nkeys;\n            tmp[i] = adb->old_keys[j];\n        }\n        /* Now free the ones we don't keep (the oldest ones) */\n        for (i = 0; i < nkeys - (nhist - 1); i++) {\n            j = (i + nkeys + knext) % nkeys;\n            histp = &adb->old_keys[j];\n            for (j = 0; j < histp->n_key_data; j++) {\n                krb5_free_key_data_contents(context, &histp->key_data[j]);\n            }\n            free(histp->key_data);\n        }\n        free(adb->old_keys);\n        adb->old_keys = tmp;\n        nkeys = adb->old_key_len = nhist - 1;\n        knext = adb->old_key_next = 0;\n    }\n\n    /*\n     * If nhist decreased since the last password change, and nkeys+1\n     * is less than the previous nhist, it is possible for knext to\n     * index into unallocated space.  This condition would not be\n     * caught by the resizing code above.\n     */\n    if (knext + 1 > nkeys)\n        knext = adb->old_key_next = 0;\n    /* free the old pw history entry if it contains data */\n    histp = &adb->old_keys[knext];\n    for (i = 0; i < (unsigned int) histp->n_key_data; i++)\n        krb5_free_key_data_contents(context, &histp->key_data[i]);\n    free(histp->key_data);\n\n    /* store the new entry */\n    adb->old_keys[knext] = *pw;\n\n    /* update the next pointer */\n    if (++adb->old_key_next == nhist - 1)\n        adb->old_key_next = 0;\n\n    return(0);\n}\n\n/* FIXME: don't use global variable for this */\nkrb5_boolean use_password_server = 0;\n\n#ifdef USE_PASSWORD_SERVER\nstatic krb5_boolean\nkadm5_use_password_server (void)\n{\n    return use_password_server;\n}\n#endif\n\nvoid\nkadm5_set_use_password_server (void)\n{\n    use_password_server = 1;\n}\n\n#ifdef USE_PASSWORD_SERVER\n\n/*\n * kadm5_launch_task () runs a program (task_path) to synchronize the\n * Apple password server with the Kerberos database.  Password server\n * programs can receive arguments on the command line (task_argv)\n * and a block of data via stdin (data_buffer).\n *\n * Because a failure to communicate with the tool results in the\n * password server falling out of sync with the database,\n * kadm5_launch_task() always fails if it can't talk to the tool.\n */\n\nstatic kadm5_ret_t\nkadm5_launch_task (krb5_context context,\n                   const char *task_path, char * const task_argv[],\n                   const char *buffer)\n{\n    kadm5_ret_t ret;\n    int data_pipe[2];\n\n    ret = pipe (data_pipe);\n    if (ret)\n        ret = errno;\n\n    if (!ret) {\n        pid_t pid = fork ();\n        if (pid == -1) {\n            ret = errno;\n            close (data_pipe[0]);\n            close (data_pipe[1]);\n        } else if (pid == 0) {\n            /* The child: */\n\n            if (dup2 (data_pipe[0], STDIN_FILENO) == -1)\n                _exit (1);\n\n            close (data_pipe[0]);\n            close (data_pipe[1]);\n\n            execv (task_path, task_argv);\n\n            _exit (1); /* Fail if execv fails */\n        } else {\n            /* The parent: */\n            int status;\n\n            ret = 0;\n\n            close (data_pipe[0]);\n\n            /* Write out the buffer to the child, add \\n */\n            if (buffer) {\n                if (krb5_net_write (context, data_pipe[1], buffer, strlen (buffer)) < 0\n                    || krb5_net_write (context, data_pipe[1], \"\\n\", 1) < 0)\n                {\n                    /* kill the child to make sure waitpid() won't hang later */\n                    ret = errno;\n                    kill (pid, SIGKILL);\n                }\n            }\n            close (data_pipe[1]);\n\n            waitpid (pid, &status, 0);\n\n            if (!ret) {\n                if (WIFEXITED (status)) {\n                    /* child read password and exited.  Check the return value. */\n                    if ((WEXITSTATUS (status) != 0) && (WEXITSTATUS (status) != 252)) {\n                        ret = KRB5KDC_ERR_POLICY; /* password change rejected */\n                    }\n                } else {\n                    /* child read password but crashed or was killed */\n                    ret = KRB5KRB_ERR_GENERIC; /* FIXME: better error */\n                }\n            }\n        }\n    }\n\n    return ret;\n}\n\n#endif\n\nkadm5_ret_t\nkadm5_chpass_principal(void *server_handle,\n                       krb5_principal principal, char *password)\n{\n    return\n        kadm5_chpass_principal_3(server_handle, principal, FALSE,\n                                 0, NULL, password);\n}\n\nkadm5_ret_t\nkadm5_chpass_principal_3(void *server_handle,\n                         krb5_principal principal, krb5_boolean keepold,\n                         int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                         char *password)\n{\n    krb5_int32                  now;\n    kadm5_policy_ent_rec        pol;\n    osa_princ_ent_rec           adb;\n    krb5_db_entry               *kdb;\n    int                         ret, ret2, last_pwd, hist_added;\n    int                         have_pol = 0;\n    kadm5_server_handle_t       handle = server_handle;\n    osa_pw_hist_ent             hist;\n    krb5_keyblock               *act_mkey, *hist_keyblocks = NULL;\n    krb5_kvno                   act_kvno, hist_kvno;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    hist_added = 0;\n    memset(&hist, 0, sizeof(hist));\n\n    if (principal == NULL || password == NULL)\n        return EINVAL;\n    if ((krb5_principal_compare(handle->context,\n                                principal, hist_princ)) == TRUE)\n        return KADM5_PROTECT_PRINCIPAL;\n\n    /* Use default keysalts if caller did not provide any. */\n    if (n_ks_tuple == 0) {\n        ks_tuple = handle->params.keysalts;\n        n_ks_tuple = handle->params.num_keysalts;\n    }\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return(ret);\n\n    if ((adb.aux_attributes & KADM5_POLICY)) {\n        if ((ret = kadm5_get_policy(handle->lhandle, adb.policy, &pol)))\n            goto done;\n        have_pol = 1;\n\n        /* Create a password history entry before we change kdb's key_data. */\n        ret = kdb_get_hist_key(handle, &hist_keyblocks, &hist_kvno);\n        if (ret)\n            goto done;\n        ret = create_history_entry(handle->context, &hist_keyblocks[0],\n                                   kdb->n_key_data, kdb->key_data, &hist);\n        if (ret)\n            goto done;\n    }\n\n    if ((ret = passwd_check(handle, password, have_pol ? &pol : NULL,\n                            principal)))\n        goto done;\n\n    ret = krb5_dbe_find_act_mkey(handle->context, active_mkey_list, &act_kvno,\n                                 &act_mkey);\n    if (ret)\n        goto done;\n\n    ret = krb5_dbe_cpw(handle->context, act_mkey, ks_tuple, n_ks_tuple,\n                       password, 0 /* increment kvno */,\n                       keepold, kdb);\n    if (ret)\n        goto done;\n\n    ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);\n    if (ret)\n        goto done;\n\n    kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;\n\n    ret = krb5_timeofday(handle->context, &now);\n    if (ret)\n        goto done;\n\n    if ((adb.aux_attributes & KADM5_POLICY)) {\n        /* the policy was loaded before */\n\n        ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb, &last_pwd);\n        if (ret)\n            goto done;\n\n#if 0\n        /*\n         * The spec says this check is overridden if the caller has\n         * modify privilege.  The admin server therefore makes this\n         * check itself (in chpass_principal_wrapper, misc.c). A\n         * local caller implicitly has all authorization bits.\n         */\n        if ((now - last_pwd) < pol.pw_min_life &&\n            !(kdb->attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {\n            ret = KADM5_PASS_TOOSOON;\n            goto done;\n        }\n#endif\n\n        ret = check_pw_reuse(handle->context, hist_keyblocks,\n                             kdb->n_key_data, kdb->key_data,\n                             1, &hist);\n        if (ret)\n            goto done;\n\n        if (pol.pw_history_num > 1) {\n            /* If hist_kvno has changed since the last password change, we\n             * can't check the history. */\n            if (adb.admin_history_kvno == hist_kvno) {\n                ret = check_pw_reuse(handle->context, hist_keyblocks,\n                                     kdb->n_key_data, kdb->key_data,\n                                     adb.old_key_len, adb.old_keys);\n                if (ret)\n                    goto done;\n            }\n\n            ret = add_to_history(handle->context, hist_kvno, &adb, &pol,\n                                 &hist);\n            if (ret)\n                goto done;\n            hist_added = 1;\n        }\n\n        if (pol.pw_max_life)\n            kdb->pw_expiration = now + pol.pw_max_life;\n        else\n            kdb->pw_expiration = 0;\n    } else {\n        kdb->pw_expiration = 0;\n    }\n\n#ifdef USE_PASSWORD_SERVER\n    if (kadm5_use_password_server () &&\n        (krb5_princ_size (handle->context, principal) == 1)) {\n        krb5_data *princ = krb5_princ_component (handle->context, principal, 0);\n        const char *path = \"/usr/sbin/mkpassdb\";\n        char *argv[] = { \"mkpassdb\", \"-setpassword\", NULL, NULL };\n        char *pstring = NULL;\n\n        if (!ret) {\n            pstring = malloc ((princ->length + 1) * sizeof (char));\n            if (pstring == NULL) { ret = ENOMEM; }\n        }\n\n        if (!ret) {\n            memcpy (pstring, princ->data, princ->length);\n            pstring [princ->length] = '\\0';\n            argv[2] = pstring;\n\n            ret = kadm5_launch_task (handle->context, path, argv, password);\n        }\n\n        if (pstring != NULL)\n            free (pstring);\n\n        if (ret)\n            goto done;\n    }\n#endif\n\n    ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);\n    if (ret)\n        goto done;\n\n    /* unlock principal on this KDC */\n    kdb->fail_auth_count = 0;\n\n    /* key data and attributes changed, let the database provider know */\n    kdb->mask = KADM5_KEY_DATA | KADM5_ATTRIBUTES |\n        KADM5_FAIL_AUTH_COUNT;\n    /* | KADM5_CPW_FUNCTION */\n\n    ret = k5_kadm5_hook_chpass(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, principal, keepold,\n                               n_ks_tuple, ks_tuple, password);\n    if (ret)\n        goto done;\n\n    if ((ret = kdb_put_entry(handle, kdb, &adb)))\n        goto done;\n\n    (void) k5_kadm5_hook_chpass(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, principal,\n                                keepold, n_ks_tuple, ks_tuple, password);\n    ret = KADM5_OK;\ndone:\n    if (!hist_added && hist.key_data)\n        free_history_entry(handle->context, &hist);\n    kdb_free_entry(handle, kdb, &adb);\n    kdb_free_keyblocks(handle, hist_keyblocks);\n\n    if (have_pol && (ret2 = kadm5_free_policy_ent(handle->lhandle, &pol))\n        && !ret)\n        ret = ret2;\n\n    return ret;\n}\n\nkadm5_ret_t\nkadm5_randkey_principal(void *server_handle,\n                        krb5_principal principal,\n                        krb5_keyblock **keyblocks,\n                        int *n_keys)\n{\n    return\n        kadm5_randkey_principal_3(server_handle, principal,\n                                  FALSE, 0, NULL,\n                                  keyblocks, n_keys);\n}\nkadm5_ret_t\nkadm5_randkey_principal_3(void *server_handle,\n                          krb5_principal principal,\n                          krb5_boolean keepold,\n                          int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                          krb5_keyblock **keyblocks,\n                          int *n_keys)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    krb5_int32                  now;\n    kadm5_policy_ent_rec        pol;\n    int                         ret, last_pwd, have_pol = 0;\n    kadm5_server_handle_t       handle = server_handle;\n    krb5_keyblock               *act_mkey;\n\n    if (keyblocks)\n        *keyblocks = NULL;\n\n    CHECK_HANDLE(server_handle);\n\n    /* Use default keysalts if caller did not provide any. */\n    if (n_ks_tuple == 0) {\n        ks_tuple = handle->params.keysalts;\n        n_ks_tuple = handle->params.num_keysalts;\n    }\n\n    krb5_clear_error_message(handle->context);\n\n    if (principal == NULL)\n        return EINVAL;\n    if (krb5_principal_compare(handle->context, principal, hist_princ)) {\n        /* If changing the history entry, the new entry must have exactly one\n         * key. */\n        if (keepold)\n            return KADM5_PROTECT_PRINCIPAL;\n        n_ks_tuple = 1;\n    }\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return(ret);\n\n    ret = krb5_dbe_find_act_mkey(handle->context, active_mkey_list, NULL,\n                                 &act_mkey);\n    if (ret)\n        goto done;\n\n    ret = krb5_dbe_crk(handle->context, act_mkey, ks_tuple, n_ks_tuple,\n                       keepold, kdb);\n    if (ret)\n        goto done;\n\n    kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;\n\n    ret = krb5_timeofday(handle->context, &now);\n    if (ret)\n        goto done;\n\n    if ((adb.aux_attributes & KADM5_POLICY)) {\n        if ((ret = kadm5_get_policy(handle->lhandle, adb.policy,\n                                    &pol)) != KADM5_OK)\n            goto done;\n        have_pol = 1;\n\n        ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb, &last_pwd);\n        if (ret)\n            goto done;\n\n#if 0\n        /*\n         * The spec says this check is overridden if the caller has\n         * modify privilege.  The admin server therefore makes this\n         * check itself (in chpass_principal_wrapper, misc.c).  A\n         * local caller implicitly has all authorization bits.\n         */\n        if((now - last_pwd) < pol.pw_min_life &&\n           !(kdb->attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {\n            ret = KADM5_PASS_TOOSOON;\n            goto done;\n        }\n#endif\n\n        if (pol.pw_max_life)\n            kdb->pw_expiration = now + pol.pw_max_life;\n        else\n            kdb->pw_expiration = 0;\n    } else {\n        kdb->pw_expiration = 0;\n    }\n\n    ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);\n    if (ret)\n        goto done;\n\n    /* unlock principal on this KDC */\n    kdb->fail_auth_count = 0;\n\n    if (keyblocks) {\n        ret = decrypt_key_data(handle->context,\n                               kdb->n_key_data, kdb->key_data,\n                               keyblocks, n_keys);\n        if (ret)\n            goto done;\n    }\n\n    /* key data changed, let the database provider know */\n    kdb->mask = KADM5_KEY_DATA | KADM5_FAIL_AUTH_COUNT;\n    /* | KADM5_RANDKEY_USED */;\n\n    ret = k5_kadm5_hook_chpass(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, principal, keepold,\n                               n_ks_tuple, ks_tuple, NULL);\n    if (ret)\n        goto done;\n    if ((ret = kdb_put_entry(handle, kdb, &adb)))\n        goto done;\n\n    (void) k5_kadm5_hook_chpass(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, principal,\n                                keepold, n_ks_tuple, ks_tuple, NULL);\n    ret = KADM5_OK;\ndone:\n    kdb_free_entry(handle, kdb, &adb);\n    if (have_pol)\n        kadm5_free_policy_ent(handle->lhandle, &pol);\n\n    return ret;\n}\n\n/*\n * kadm5_setv4key_principal:\n *\n * Set only ONE key of the principal, removing all others.  This key\n * must have the DES_CBC_CRC enctype and is entered as having the\n * krb4 salttype.  This is to enable things like kadmind4 to work.\n */\nkadm5_ret_t\nkadm5_setv4key_principal(void *server_handle,\n                         krb5_principal principal,\n                         krb5_keyblock *keyblock)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    krb5_int32                  now;\n    kadm5_policy_ent_rec        pol;\n    krb5_keysalt                keysalt;\n    int                         i, k, kvno, ret, have_pol = 0;\n#if 0\n    int                         last_pwd;\n#endif\n    kadm5_server_handle_t       handle = server_handle;\n    krb5_key_data               tmp_key_data;\n    krb5_keyblock               *act_mkey;\n\n    memset( &tmp_key_data, 0, sizeof(tmp_key_data));\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if (principal == NULL || keyblock == NULL)\n        return EINVAL;\n    if (hist_princ && /* this will be NULL when initializing the databse */\n        ((krb5_principal_compare(handle->context,\n                                 principal, hist_princ)) == TRUE))\n        return KADM5_PROTECT_PRINCIPAL;\n\n    if (keyblock->enctype != ENCTYPE_DES_CBC_CRC)\n        return KADM5_SETV4KEY_INVAL_ENCTYPE;\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return(ret);\n\n    for (kvno = 0, i=0; i<kdb->n_key_data; i++)\n        if (kdb->key_data[i].key_data_kvno > kvno)\n            kvno = kdb->key_data[i].key_data_kvno;\n\n    if (kdb->key_data != NULL)\n        cleanup_key_data(handle->context, kdb->n_key_data, kdb->key_data);\n\n    kdb->key_data = (krb5_key_data*)krb5_db_alloc(handle->context, NULL, sizeof(krb5_key_data));\n    if (kdb->key_data == NULL)\n        return ENOMEM;\n    memset(kdb->key_data, 0, sizeof(krb5_key_data));\n    kdb->n_key_data = 1;\n    keysalt.type = KRB5_KDB_SALTTYPE_V4;\n    /* XXX data.magic? */\n    keysalt.data.length = 0;\n    keysalt.data.data = NULL;\n\n    ret = krb5_dbe_find_act_mkey(handle->context, active_mkey_list, NULL,\n                                 &act_mkey);\n    if (ret)\n        goto done;\n\n    /* use tmp_key_data as temporary location and reallocate later */\n    ret = krb5_dbe_encrypt_key_data(handle->context, act_mkey, keyblock,\n                                    &keysalt, kvno + 1, &tmp_key_data);\n    if (ret) {\n        goto done;\n    }\n\n    for (k = 0; k < tmp_key_data.key_data_ver; k++) {\n        kdb->key_data->key_data_type[k] = tmp_key_data.key_data_type[k];\n        kdb->key_data->key_data_length[k] = tmp_key_data.key_data_length[k];\n        if (tmp_key_data.key_data_contents[k]) {\n            kdb->key_data->key_data_contents[k] = krb5_db_alloc(handle->context, NULL, tmp_key_data.key_data_length[k]);\n            if (kdb->key_data->key_data_contents[k] == NULL) {\n                cleanup_key_data(handle->context, kdb->n_key_data, kdb->key_data);\n                kdb->key_data = NULL;\n                kdb->n_key_data = 0;\n                ret = ENOMEM;\n                goto done;\n            }\n            memcpy (kdb->key_data->key_data_contents[k], tmp_key_data.key_data_contents[k], tmp_key_data.key_data_length[k]);\n\n            memset (tmp_key_data.key_data_contents[k], 0, tmp_key_data.key_data_length[k]);\n            free (tmp_key_data.key_data_contents[k]);\n            tmp_key_data.key_data_contents[k] = NULL;\n        }\n    }\n\n\n\n    kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;\n\n    ret = krb5_timeofday(handle->context, &now);\n    if (ret)\n        goto done;\n\n    if ((adb.aux_attributes & KADM5_POLICY)) {\n        if ((ret = kadm5_get_policy(handle->lhandle, adb.policy,\n                                    &pol)) != KADM5_OK)\n            goto done;\n        have_pol = 1;\n\n#if 0\n        /*\n         * The spec says this check is overridden if the caller has\n         * modify privilege.  The admin server therefore makes this\n         * check itself (in chpass_principal_wrapper, misc.c).  A\n         * local caller implicitly has all authorization bits.\n         */\n        if (ret = krb5_dbe_lookup_last_pwd_change(handle->context,\n                                                  kdb, &last_pwd))\n            goto done;\n        if((now - last_pwd) < pol.pw_min_life &&\n           !(kdb->attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {\n            ret = KADM5_PASS_TOOSOON;\n            goto done;\n        }\n#endif\n\n        if (pol.pw_max_life)\n            kdb->pw_expiration = now + pol.pw_max_life;\n        else\n            kdb->pw_expiration = 0;\n    } else {\n        kdb->pw_expiration = 0;\n    }\n\n    ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);\n    if (ret)\n        goto done;\n\n    /* unlock principal on this KDC */\n    kdb->fail_auth_count = 0;\n\n    if ((ret = kdb_put_entry(handle, kdb, &adb)))\n        goto done;\n\n    ret = KADM5_OK;\ndone:\n    for (i = 0; i < tmp_key_data.key_data_ver; i++) {\n        if (tmp_key_data.key_data_contents[i]) {\n            memset (tmp_key_data.key_data_contents[i], 0, tmp_key_data.key_data_length[i]);\n            free (tmp_key_data.key_data_contents[i]);\n        }\n    }\n\n    kdb_free_entry(handle, kdb, &adb);\n    if (have_pol)\n        kadm5_free_policy_ent(handle->lhandle, &pol);\n\n    return ret;\n}\n\nkadm5_ret_t\nkadm5_setkey_principal(void *server_handle,\n                       krb5_principal principal,\n                       krb5_keyblock *keyblocks,\n                       int n_keys)\n{\n    return\n        kadm5_setkey_principal_3(server_handle, principal,\n                                 FALSE, 0, NULL,\n                                 keyblocks, n_keys);\n}\n\nkadm5_ret_t\nkadm5_setkey_principal_3(void *server_handle,\n                         krb5_principal principal,\n                         krb5_boolean keepold,\n                         int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                         krb5_keyblock *keyblocks,\n                         int n_keys)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    krb5_int32                  now;\n    kadm5_policy_ent_rec        pol;\n    krb5_key_data               *old_key_data;\n    int                         n_old_keys;\n    int                         i, j, k, kvno, ret, have_pol = 0;\n#if 0\n    int                         last_pwd;\n#endif\n    kadm5_server_handle_t       handle = server_handle;\n    krb5_boolean                similar;\n    krb5_keysalt                keysalt;\n    krb5_key_data         tmp_key_data;\n    krb5_key_data        *tptr;\n    krb5_keyblock               *act_mkey;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if (principal == NULL || keyblocks == NULL)\n        return EINVAL;\n    if (hist_princ && /* this will be NULL when initializing the databse */\n        ((krb5_principal_compare(handle->context,\n                                 principal, hist_princ)) == TRUE))\n        return KADM5_PROTECT_PRINCIPAL;\n\n    for (i = 0; i < n_keys; i++) {\n        for (j = i+1; j < n_keys; j++) {\n            if ((ret = krb5_c_enctype_compare(handle->context,\n                                              keyblocks[i].enctype,\n                                              keyblocks[j].enctype,\n                                              &similar)))\n                return(ret);\n            if (similar) {\n                if (n_ks_tuple) {\n                    if (ks_tuple[i].ks_salttype == ks_tuple[j].ks_salttype)\n                        return KADM5_SETKEY_DUP_ENCTYPES;\n                } else\n                    return KADM5_SETKEY_DUP_ENCTYPES;\n            }\n        }\n    }\n\n    if (n_ks_tuple && n_ks_tuple != n_keys)\n        return KADM5_SETKEY3_ETYPE_MISMATCH;\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return(ret);\n\n    for (kvno = 0, i=0; i<kdb->n_key_data; i++)\n        if (kdb->key_data[i].key_data_kvno > kvno)\n            kvno = kdb->key_data[i].key_data_kvno;\n\n    if (keepold) {\n        old_key_data = kdb->key_data;\n        n_old_keys = kdb->n_key_data;\n    } else {\n        if (kdb->key_data != NULL)\n            cleanup_key_data(handle->context, kdb->n_key_data, kdb->key_data);\n        n_old_keys = 0;\n        old_key_data = NULL;\n    }\n\n    kdb->key_data = (krb5_key_data*)krb5_db_alloc(handle->context, NULL, (n_keys+n_old_keys)\n                                                  *sizeof(krb5_key_data));\n    if (kdb->key_data == NULL) {\n        ret = ENOMEM;\n        goto done;\n    }\n\n    memset(kdb->key_data, 0, (n_keys+n_old_keys)*sizeof(krb5_key_data));\n    kdb->n_key_data = 0;\n\n    for (i = 0; i < n_keys; i++) {\n        if (n_ks_tuple) {\n            keysalt.type = ks_tuple[i].ks_salttype;\n            keysalt.data.length = 0;\n            keysalt.data.data = NULL;\n            if (ks_tuple[i].ks_enctype != keyblocks[i].enctype) {\n                ret = KADM5_SETKEY3_ETYPE_MISMATCH;\n                goto done;\n            }\n        }\n        memset (&tmp_key_data, 0, sizeof(tmp_key_data));\n\n        ret = krb5_dbe_find_act_mkey(handle->context, active_mkey_list, NULL,\n                                     &act_mkey);\n        if (ret)\n            goto done;\n\n        ret = krb5_dbe_encrypt_key_data(handle->context, act_mkey,\n                                        &keyblocks[i],\n                                        n_ks_tuple ? &keysalt : NULL, kvno + 1,\n                                        &tmp_key_data);\n        if (ret)\n            goto done;\n\n        tptr = &kdb->key_data[i];\n        tptr->key_data_ver = tmp_key_data.key_data_ver;\n        tptr->key_data_kvno = tmp_key_data.key_data_kvno;\n        for (k = 0; k < tmp_key_data.key_data_ver; k++) {\n            tptr->key_data_type[k] = tmp_key_data.key_data_type[k];\n            tptr->key_data_length[k] = tmp_key_data.key_data_length[k];\n            if (tmp_key_data.key_data_contents[k]) {\n                tptr->key_data_contents[k] = krb5_db_alloc(handle->context, NULL, tmp_key_data.key_data_length[k]);\n                if (tptr->key_data_contents[k] == NULL) {\n                    int i1;\n                    for (i1 = k; i1 < tmp_key_data.key_data_ver; i1++) {\n                        if (tmp_key_data.key_data_contents[i1]) {\n                            memset (tmp_key_data.key_data_contents[i1], 0, tmp_key_data.key_data_length[i1]);\n                            free (tmp_key_data.key_data_contents[i1]);\n                        }\n                    }\n\n                    ret =  ENOMEM;\n                    goto done;\n                }\n                memcpy (tptr->key_data_contents[k], tmp_key_data.key_data_contents[k], tmp_key_data.key_data_length[k]);\n\n                memset (tmp_key_data.key_data_contents[k], 0, tmp_key_data.key_data_length[k]);\n                free (tmp_key_data.key_data_contents[k]);\n                tmp_key_data.key_data_contents[k] = NULL;\n            }\n        }\n        kdb->n_key_data++;\n    }\n\n    /* copy old key data if necessary */\n    for (i = 0; i < n_old_keys; i++) {\n        kdb->key_data[i+n_keys] = old_key_data[i];\n        memset(&old_key_data[i], 0, sizeof (krb5_key_data));\n        kdb->n_key_data++;\n    }\n\n    if (old_key_data)\n        krb5_db_free(handle->context, old_key_data);\n\n    /* assert(kdb->n_key_data == n_keys + n_old_keys) */\n    kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;\n\n    if ((ret = krb5_timeofday(handle->context, &now)))\n        goto done;\n\n    if ((adb.aux_attributes & KADM5_POLICY)) {\n        if ((ret = kadm5_get_policy(handle->lhandle, adb.policy,\n                                    &pol)) != KADM5_OK)\n            goto done;\n        have_pol = 1;\n\n#if 0\n        /*\n         * The spec says this check is overridden if the caller has\n         * modify privilege.  The admin server therefore makes this\n         * check itself (in chpass_principal_wrapper, misc.c).  A\n         * local caller implicitly has all authorization bits.\n         */\n        if (ret = krb5_dbe_lookup_last_pwd_change(handle->context,\n                                                  kdb, &last_pwd))\n            goto done;\n        if((now - last_pwd) < pol.pw_min_life &&\n           !(kdb->attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {\n            ret = KADM5_PASS_TOOSOON;\n            goto done;\n        }\n#endif\n\n        if (pol.pw_max_life)\n            kdb->pw_expiration = now + pol.pw_max_life;\n        else\n            kdb->pw_expiration = 0;\n    } else {\n        kdb->pw_expiration = 0;\n    }\n\n    if ((ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now)))\n        goto done;\n\n    /* unlock principal on this KDC */\n    kdb->fail_auth_count = 0;\n\n    if ((ret = kdb_put_entry(handle, kdb, &adb)))\n        goto done;\n\n    ret = KADM5_OK;\ndone:\n    kdb_free_entry(handle, kdb, &adb);\n    if (have_pol)\n        kadm5_free_policy_ent(handle->lhandle, &pol);\n\n    return ret;\n}\n\n/*\n * Return the list of keys like kadm5_randkey_principal,\n * but don't modify the principal.\n */\nkadm5_ret_t\nkadm5_get_principal_keys(void *server_handle /* IN */,\n                         krb5_principal principal /* IN */,\n                         krb5_keyblock **keyblocks /* OUT */,\n                         int *n_keys /* OUT */)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    kadm5_ret_t                 ret;\n    kadm5_server_handle_t       handle = server_handle;\n\n    if (keyblocks)\n        *keyblocks = NULL;\n\n    CHECK_HANDLE(server_handle);\n\n    if (principal == NULL)\n        return EINVAL;\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return(ret);\n\n    if (keyblocks) {\n        ret = decrypt_key_data(handle->context,\n                               kdb->n_key_data, kdb->key_data,\n                               keyblocks, n_keys);\n        if (ret)\n            goto done;\n    }\n\n    ret = KADM5_OK;\ndone:\n    kdb_free_entry(handle, kdb, &adb);\n\n    return ret;\n}\n\n\n/*\n * Allocate an array of n_key_data krb5_keyblocks, fill in each\n * element with the results of decrypting the nth key in key_data,\n * and if n_keys is not NULL fill it in with the\n * number of keys decrypted.\n */\nstatic int decrypt_key_data(krb5_context context,\n                            int n_key_data, krb5_key_data *key_data,\n                            krb5_keyblock **keyblocks, int *n_keys)\n{\n    krb5_keyblock *keys;\n    int ret, i;\n\n    keys = (krb5_keyblock *) malloc(n_key_data*sizeof(krb5_keyblock));\n    if (keys == NULL)\n        return ENOMEM;\n    memset(keys, 0, n_key_data*sizeof(krb5_keyblock));\n\n    for (i = 0; i < n_key_data; i++) {\n        ret = krb5_dbe_decrypt_key_data(context, NULL, &key_data[i], &keys[i],\n                                        NULL);\n        if (ret) {\n            for (; i >= 0; i--) {\n                if (keys[i].contents) {\n                    memset (keys[i].contents, 0, keys[i].length);\n                    free( keys[i].contents );\n                }\n            }\n\n            memset(keys, 0, n_key_data*sizeof(krb5_keyblock));\n            free(keys);\n            return ret;\n        }\n    }\n\n    *keyblocks = keys;\n    if (n_keys)\n        *n_keys = n_key_data;\n\n    return 0;\n}\n\n/*\n * Function: kadm5_decrypt_key\n *\n * Purpose: Retrieves and decrypts a principal key.\n *\n * Arguments:\n *\n *      server_handle   (r) kadm5 handle\n *      entry           (r) principal retrieved with kadm5_get_principal\n *      ktype           (r) enctype to search for, or -1 to ignore\n *      stype           (r) salt type to search for, or -1 to ignore\n *      kvno            (r) kvno to search for, -1 for max, 0 for max\n *                      only if it also matches ktype and stype\n *      keyblock        (w) keyblock to fill in\n *      keysalt         (w) keysalt to fill in, or NULL\n *      kvnop           (w) kvno to fill in, or NULL\n *\n * Effects: Searches the key_data array of entry, which must have been\n * retrived with kadm5_get_principal with the KADM5_KEY_DATA mask, to\n * find a key with a specified enctype, salt type, and kvno in a\n * principal entry.  If not found, return ENOENT.  Otherwise, decrypt\n * it with the master key, and return the key in keyblock, the salt\n * in salttype, and the key version number in kvno.\n *\n * If ktype or stype is -1, it is ignored for the search.  If kvno is\n * -1, ktype and stype are ignored and the key with the max kvno is\n * returned.  If kvno is 0, only the key with the max kvno is returned\n * and only if it matches the ktype and stype; otherwise, ENOENT is\n * returned.\n */\nkadm5_ret_t kadm5_decrypt_key(void *server_handle,\n                              kadm5_principal_ent_t entry, krb5_int32\n                              ktype, krb5_int32 stype, krb5_int32\n                              kvno, krb5_keyblock *keyblock,\n                              krb5_keysalt *keysalt, int *kvnop)\n{\n    kadm5_server_handle_t handle = server_handle;\n    krb5_db_entry dbent;\n    krb5_key_data *key_data;\n    krb5_keyblock *mkey_ptr;\n    int ret;\n\n    CHECK_HANDLE(server_handle);\n\n    if (entry->n_key_data == 0 || entry->key_data == NULL)\n        return EINVAL;\n\n    /* find_enctype only uses these two fields */\n    dbent.n_key_data = entry->n_key_data;\n    dbent.key_data = entry->key_data;\n    if ((ret = krb5_dbe_find_enctype(handle->context, &dbent, ktype,\n                                     stype, kvno, &key_data)))\n        return ret;\n\n    /* find_mkey only uses this field */\n    dbent.tl_data = entry->tl_data;\n    if ((ret = krb5_dbe_find_mkey(handle->context, &dbent, &mkey_ptr))) {\n        /* try refreshing master key list */\n        /* XXX it would nice if we had the mkvno here for optimization */\n        if (krb5_db_fetch_mkey_list(handle->context, master_princ,\n                                    &master_keyblock) == 0) {\n            if ((ret = krb5_dbe_find_mkey(handle->context, &dbent,\n                                          &mkey_ptr))) {\n                return ret;\n            }\n        } else {\n            return ret;\n        }\n    }\n\n    if ((ret = krb5_dbe_decrypt_key_data(handle->context, NULL, key_data,\n                                         keyblock, keysalt)))\n        return ret;\n\n    /*\n     * Coerce the enctype of the output keyblock in case we got an\n     * inexact match on the enctype; this behavior will go away when\n     * the key storage architecture gets redesigned for 1.3.\n     */\n    if (ktype != -1)\n        keyblock->enctype = ktype;\n\n    if (kvnop)\n        *kvnop = key_data->key_data_kvno;\n\n    return KADM5_OK;\n}\n\nkadm5_ret_t\nkadm5_purgekeys(void *server_handle,\n                krb5_principal principal,\n                int keepkvno)\n{\n    kadm5_server_handle_t handle = server_handle;\n    kadm5_ret_t ret;\n    krb5_db_entry *kdb;\n    osa_princ_ent_rec adb;\n    krb5_key_data *old_keydata;\n    int n_old_keydata;\n    int i, j, k;\n\n    CHECK_HANDLE(server_handle);\n\n    if (principal == NULL)\n        return EINVAL;\n\n    ret = kdb_get_entry(handle, principal, &kdb, &adb);\n    if (ret)\n        return(ret);\n\n    if (keepkvno <= 0) {\n        keepkvno = krb5_db_get_key_data_kvno(handle->context, kdb->n_key_data,\n                                             kdb->key_data);\n    }\n\n    old_keydata = kdb->key_data;\n    n_old_keydata = kdb->n_key_data;\n    kdb->n_key_data = 0;\n    kdb->key_data = krb5_db_alloc(handle->context, NULL,\n                                  n_old_keydata * sizeof(krb5_key_data));\n    if (kdb->key_data == NULL) {\n        ret = ENOMEM;\n        goto done;\n    }\n    memset(kdb->key_data, 0, n_old_keydata * sizeof(krb5_key_data));\n    for (i = 0, j = 0; i < n_old_keydata; i++) {\n        if (old_keydata[i].key_data_kvno < keepkvno)\n            continue;\n\n        /* Alias the key_data_contents pointers; we null them out in the\n         * source array immediately after. */\n        kdb->key_data[j] = old_keydata[i];\n        for (k = 0; k < old_keydata[i].key_data_ver; k++) {\n            old_keydata[i].key_data_contents[k] = NULL;\n        }\n        j++;\n    }\n    kdb->n_key_data = j;\n    cleanup_key_data(handle->context, n_old_keydata, old_keydata);\n\n    kdb->mask = KADM5_KEY_DATA;\n    ret = kdb_put_entry(handle, kdb, &adb);\n    if (ret)\n        goto done;\n\ndone:\n    kdb_free_entry(handle, kdb, &adb);\n    return ret;\n}\n\nkadm5_ret_t\nkadm5_get_strings(void *server_handle, krb5_principal principal,\n                  krb5_string_attr **strings_out, int *count_out)\n{\n    kadm5_server_handle_t handle = server_handle;\n    kadm5_ret_t ret;\n    krb5_db_entry *kdb = NULL;\n\n    *strings_out = NULL;\n    *count_out = 0;\n    CHECK_HANDLE(server_handle);\n    if (principal == NULL)\n        return EINVAL;\n\n    ret = kdb_get_entry(handle, principal, &kdb, NULL);\n    if (ret)\n        return ret;\n\n    ret = krb5_dbe_get_strings(handle->context, kdb, strings_out, count_out);\n    kdb_free_entry(handle, kdb, NULL);\n    return ret;\n}\n\nkadm5_ret_t\nkadm5_set_string(void *server_handle, krb5_principal principal,\n                 const char *key, const char *value)\n{\n    kadm5_server_handle_t handle = server_handle;\n    kadm5_ret_t ret;\n    krb5_db_entry *kdb;\n    osa_princ_ent_rec adb;\n\n    CHECK_HANDLE(server_handle);\n    if (principal == NULL || key == NULL)\n        return EINVAL;\n\n    ret = kdb_get_entry(handle, principal, &kdb, &adb);\n    if (ret)\n        return ret;\n\n    ret = krb5_dbe_set_string(handle->context, kdb, key, value);\n    if (ret)\n        goto done;\n\n    kdb->mask = KADM5_TL_DATA;\n    ret = kdb_put_entry(handle, kdb, &adb);\n\ndone:\n    kdb_free_entry(handle, kdb, &adb);\n    return ret;\n}\n"], "filenames": ["src/lib/kadm5/srv/svr_principal.c"], "buggy_code_start_loc": [189], "buggy_code_end_loc": [190], "fixing_code_start_loc": [189], "fixing_code_end_loc": [190], "type": "NVD-CWE-Other", "message": "The check_1_6_dummy function in lib/kadm5/srv/svr_principal.c in kadmind in MIT Kerberos 5 (aka krb5) 1.8.x, 1.9.x, and 1.10.x before 1.10.2 allows remote authenticated administrators to cause a denial of service (NULL pointer dereference and daemon crash) via a KRB5_KDB_DISALLOW_ALL_TIX create request that lacks a password.", "other": {"cve": {"id": "CVE-2012-1013", "sourceIdentifier": "cve@mitre.org", "published": "2012-06-07T19:55:07.930", "lastModified": "2020-01-21T15:46:22.213", "vulnStatus": "Modified", "evaluatorComment": "Per: http://cwe.mitre.org/data/definitions/476.html\r\n\r\n'CWE-476: NULL Pointer Dereference'", "descriptions": [{"lang": "en", "value": "The check_1_6_dummy function in lib/kadm5/srv/svr_principal.c in kadmind in MIT Kerberos 5 (aka krb5) 1.8.x, 1.9.x, and 1.10.x before 1.10.2 allows remote authenticated administrators to cause a denial of service (NULL pointer dereference and daemon crash) via a KRB5_KDB_DISALLOW_ALL_TIX create request that lacks a password."}, {"lang": "es", "value": "La funci\u00f3n check_1_6_dummy en lib/kadm5/srv/svr_principal.c en kadmind en MIT Kerberos 5 (tambi\u00e9n conocido como krb5) v1.8.x, v1.9.x y v1.10.x antes de v1.10.2 permite provocar una denegaci\u00f3n de servicio (eliminaci\u00f3n de referencia a puntero NULL y ca\u00edda del demonio) a los administradores remotos autenticados a trav\u00e9s de una solicitud de creaci\u00f3n KRB5_KDB_DISALLOW_ALL_TIX que carece de contrase\u00f1a."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.8:*:*:*:*:*:*:*", "matchCriteriaId": "36823B2B-5C72-4FF3-9301-FB263EB8CE09"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "59AFA33E-FEBC-45F5-9EC6-8AA363163FB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "04D83332-B2FD-4E86-A76C-C3F1CD3B3A31"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.8.3:*:*:*:*:*:*:*", "matchCriteriaId": "758A0011-20ED-414A-9DF3-50A161DF8BC2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.8.4:*:*:*:*:*:*:*", "matchCriteriaId": "7768AED0-AE4C-4D4E-8D5D-5B618AB82966"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "534104C5-966E-4740-A354-4F6C210FF25B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "78AF5659-C0E3-49C4-9CA7-FC3917C8AC49"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.9:*:*:*:*:*:*:*", "matchCriteriaId": "86738633-C081-4440-9F75-A775D6DF2228"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "C7BCFFEE-EA7A-4F26-97AA-31128A179745"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "91A2D7F5-EBDE-4000-AC78-8DD6472E685A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "8E92BFA5-723E-4843-A8D8-BC1D32F34569"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.10:*:*:*:*:*:*:*", "matchCriteriaId": "FC504264-A9E9-4433-B7AA-6D5015A93FF3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "77FA352F-520C-4C05-AD52-FC8586DB16B1"}]}]}], "references": [{"url": "http://krbdev.mit.edu/rt/Ticket/Display.html?user=guest&pass=guest&id=7152", "source": "cve@mitre.org"}, {"url": "http://mailman.mit.edu/pipermail/kerberos-announce/2012q2/000136.html", "source": "cve@mitre.org"}, {"url": "http://rhn.redhat.com/errata/RHSA-2012-1131.html", "source": "cve@mitre.org"}, {"url": "http://web.mit.edu/kerberos/krb5-1.10/", "source": "cve@mitre.org"}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2012:102", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/53784", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=827517", "source": "cve@mitre.org"}, {"url": "https://github.com/krb5/krb5/commit/c5be6209311d4a8f10fda37d0d3f876c1b33b77b", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}, {"url": "https://hermes.opensuse.org/messages/15083635", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/krb5/krb5/commit/c5be6209311d4a8f10fda37d0d3f876c1b33b77b"}}