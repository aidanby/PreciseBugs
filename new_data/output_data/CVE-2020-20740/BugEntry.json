{"buggy_code": ["Matt Davis (enferex): Original pdfresurrect, modified man page\n\nFrancois Marier: Original man page, modified Makefile.in\n                 and modified configure.ac, potential security bug identifying\n                 (e.g., bad code detection).\n\nDavid Binderman: Finding a bug and offering a correction suggestion\n\nRyan Schmidt: MacPorts Makefile work\n\nxambroz: Suggestions and Makefile enhancement.\n\nj0lamma: Identified a bug that can cause a corrupted buffer.\n\ncapcorpscert0188, LeeSunWoo, ParkInChul: Identified a bug that can cause\n                                         a corrupted buffer.\n\nrtfingc: Reported bugs regarding memory corruption and a leak.\n\nrwhitworth: Reported and helped isolate bugs. Created initial .gitignore.\n\ncarter-yagemann: Reported and helped isolate a memory issue.\n\nrootup: Reporting and helped isolate a memory issue.\n\nZanderChang: Reported and identified bad code in kid page loading.\n", "/******************************************************************************\n * pdf.c \n *\n * pdfresurrect - PDF history extraction tool\n *\n * Copyright (C) 2008-2010, 2012-2013, 2017-20, Matt Davis (enferex).\n *\n * Special thanks to all of the contributors:  See AUTHORS.\n *\n * Special thanks to 757labs (757 crew), they are a great group\n * of people to hack on projects and brainstorm with.\n *\n * pdf.c is part of pdfresurrect.\n * pdfresurrect is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * pdfresurrect is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with pdfresurrect.  If not, see <http://www.gnu.org/licenses/>.\n *****************************************************************************/\n\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include \"pdf.h\"\n#include \"main.h\"\n\n\n/* \n * Macros\n */\n\n/* SAFE_F\n *\n * Safe file read: use for fgetc() calls, this is really ugly looking. \n * _fp:   FILE * handle\n * _expr: The expression with fgetc() in it:\n * \n *  example: If we get a character from the file and it is ascii character 'a'\n *           This assumes the coder wants to store the 'a' in variable ch\n *           Kinda pointless if you already know that you have 'a', but for\n *           illustrative purposes.\n *\n *  if (SAFE_F(my_fp, ((c=fgetc(my_fp)) == 'a')))\n *              do_way_cool_stuff();\n */\n#define SAFE_F(_fp, _expr) \\\n    ((!ferror(_fp) && !feof(_fp) && (_expr)))\n\n\n/* FAIL\n *\n * Emit the diagnostic '_msg' and exit.\n * _msg: Message to emit prior to exiting.\n */\n#define FAIL(_msg)      \\\n  do {                  \\\n    ERR(_msg);          \\\n    exit(EXIT_FAILURE); \\\n  } while (0)\n\n\n/* SAFE_E\n *\n * Safe expression handling.  This macro is a wrapper\n * that compares the result of an expression (_expr) to the expected\n * value (_cmp).\n *\n * _expr: Expression to test.\n * _cmp:  Expected value, error if this returns false.\n * _msg:  What to say when an error occurs.\n */\n#define SAFE_E(_expr, _cmp, _msg) \\\n do {                             \\\n    if ((_expr) != (_cmp)) {      \\\n      FAIL(_msg);                  \\\n    }                             \\\n  } while (0)\n\n\n/*\n * Forwards\n */\n\nstatic int is_valid_xref(FILE *fp, pdf_t *pdf, xref_t *xref);\nstatic void load_xref_entries(FILE *fp, xref_t *xref);\nstatic void load_xref_from_plaintext(FILE *fp, xref_t *xref);\nstatic void load_xref_from_stream(FILE *fp, xref_t *xref);\nstatic void get_xref_linear_skipped(FILE *fp, xref_t *xref);\nstatic void resolve_linearized_pdf(pdf_t *pdf);\n\nstatic pdf_creator_t *new_creator(int *n_elements);\nstatic void load_creator(FILE *fp, pdf_t *pdf);\nstatic void load_creator_from_buf(\n    FILE       *fp,\n    xref_t     *xref,\n    const char *buf,\n    size_t      buf_size);\nstatic void load_creator_from_xml(xref_t *xref, const char *buf);\nstatic void load_creator_from_old_format(\n    FILE       *fp,\n    xref_t     *xref,\n    const char *buf,\n    size_t      buf_size);\n\nstatic char *get_object_from_here(FILE *fp, size_t *size, int *is_stream);\n\nstatic char *get_object(\n    FILE         *fp,\n    int           obj_id,\n    const xref_t *xref,\n    size_t       *size,\n    int          *is_stream);\n\nstatic const char *get_type(FILE *fp, int obj_id, const xref_t *xref);\n/* static int get_page(int obj_id, const xref_t *xref); */\nstatic char *get_header(FILE *fp);\n\nstatic char *decode_text_string(const char *str, size_t str_len);\nstatic int get_next_eof(FILE *fp);\n\n\n/*\n * Defined\n */\n\npdf_t *pdf_new(const char *name)\n{\n    const char *n;\n    pdf_t      *pdf;\n   \n    pdf = safe_calloc(sizeof(pdf_t));\n\n    if (name)\n    {\n        /* Just get the file name (not path) */\n        if ((n = strrchr(name, '/')))\n          ++n;\n        else\n          n = name;\n\n        pdf->name = safe_calloc(strlen(n) + 1);\n        strcpy(pdf->name, n);\n    }\n    else /* !name */\n    {\n        pdf->name = safe_calloc(strlen(\"Unknown\") + 1);\n        strcpy(pdf->name, \"Unknown\");\n    }\n\n    return pdf;\n}\n\n\nvoid pdf_delete(pdf_t *pdf)\n{\n    int i;\n\n    for (i=0; i<pdf->n_xrefs; i++)\n    {\n        free(pdf->xrefs[i].creator);\n        free(pdf->xrefs[i].entries);\n    }\n\n    free(pdf->name);\n    free(pdf->xrefs);\n    free(pdf);\n}\n\n\nint pdf_is_pdf(FILE *fp)\n{\n    int   is_pdf;\n    char *header;\n\n    header = get_header(fp);\n\n    if (header && strstr(header, \"%PDF-\"))\n      is_pdf = 1;\n    else \n      is_pdf = 0;\n\n    free(header);\n    return is_pdf;\n}\n\n\nvoid pdf_get_version(FILE *fp, pdf_t *pdf)\n{\n    char *header, *c;\n\n    header = get_header(fp);\n\n    /* Locate version string start and make sure we dont go past header */\n    if ((c = strstr(header, \"%PDF-\")) && \n        (c + strlen(\"%PDF-M.m\") + 2))\n    {\n        pdf->pdf_major_version = atoi(c + strlen(\"%PDF-\"));\n        pdf->pdf_minor_version = atoi(c + strlen(\"%PDF-M.\"));\n    }\n\n    free(header);\n}\n\n\nint pdf_load_xrefs(FILE *fp, pdf_t *pdf)\n{\n    int  i, ver, is_linear;\n    long pos, pos_count;\n    char x, *c, buf[256];\n    \n    c = NULL;\n\n    /* Count number of xrefs */\n    pdf->n_xrefs = 0;\n    fseek(fp, 0, SEEK_SET);\n    while (get_next_eof(fp) >= 0)\n      ++pdf->n_xrefs;\n\n    if (!pdf->n_xrefs)\n      return 0;\n\n    /* Load in the start/end positions */\n    fseek(fp, 0, SEEK_SET);\n    pdf->xrefs = safe_calloc(sizeof(xref_t) * pdf->n_xrefs);\n    ver = 1;\n    for (i=0; i<pdf->n_xrefs; i++)\n    {\n        /* Seek to %%EOF */\n        if ((pos = get_next_eof(fp)) < 0)\n          break;\n\n        /* Set and increment the version */\n        pdf->xrefs[i].version = ver++;\n\n        /* Rewind until we find end of \"startxref\" */\n        pos_count = 0;\n        while (SAFE_F(fp, ((x = fgetc(fp)) != 'f')))\n          fseek(fp, pos - (++pos_count), SEEK_SET);\n        \n        /* Suck in end of \"startxref\" to start of %%EOF */\n        if (pos_count >= sizeof(buf)) {\n          FAIL(\"Failed to locate the startxref token. \"\n              \"This might be a corrupt PDF.\\n\");\n        }\n        memset(buf, 0, sizeof(buf));\n        SAFE_E(fread(buf, 1, pos_count, fp), pos_count,\n               \"Failed to read startxref.\\n\");\n        c = buf;\n        while (*c == ' ' || *c == '\\n' || *c == '\\r')\n          ++c;\n    \n        /* xref start position */\n        pdf->xrefs[i].start = atol(c);\n\n        /* If xref is 0 handle linear xref table */\n        if (pdf->xrefs[i].start == 0)\n          get_xref_linear_skipped(fp, &pdf->xrefs[i]);\n\n        /* Non-linear, normal operation, so just find the end of the xref */\n        else\n        {\n            /* xref end position */\n            pos = ftell(fp);\n            fseek(fp, pdf->xrefs[i].start, SEEK_SET);\n            pdf->xrefs[i].end = get_next_eof(fp);\n\n            /* Look for next EOF and xref data */\n            fseek(fp, pos, SEEK_SET);\n        }\n\n        /* Check validity */\n        if (!is_valid_xref(fp, pdf, &pdf->xrefs[i]))\n        {\n            is_linear = pdf->xrefs[i].is_linear;\n            memset(&pdf->xrefs[i], 0, sizeof(xref_t));\n            pdf->xrefs[i].is_linear = is_linear;\n            rewind(fp);\n            get_next_eof(fp);\n            continue;\n        }\n\n        /*  Load the entries from the xref */\n        load_xref_entries(fp, &pdf->xrefs[i]);\n    }\n\n    /* Now we have all xref tables, if this is linearized, we need\n     * to make adjustments so that things spit out properly\n     */\n    if (pdf->xrefs[0].is_linear)\n      resolve_linearized_pdf(pdf);\n\n    /* Ok now we have all xref data.  Go through those versions of the \n     * PDF and try to obtain creator information\n     */\n    load_creator(fp, pdf);\n\n    return pdf->n_xrefs;\n}\n\n\n/* Load page information */\nchar pdf_get_object_status(\n    const pdf_t *pdf,\n    int          xref_idx,\n    int          entry_idx)\n{\n    int                 i, curr_ver;\n    const xref_t       *prev_xref;\n    const xref_entry_t *prev, *curr;\n\n    curr = &pdf->xrefs[xref_idx].entries[entry_idx];\n    curr_ver = pdf->xrefs[xref_idx].version;\n\n    if (curr_ver == 1)\n      return 'A';\n\n    /* Deleted (freed) */\n    if (curr->f_or_n == 'f')\n      return 'D';\n\n    /* Get previous version */\n    prev_xref = NULL;\n    for (i=xref_idx; i>-1; --i)\n      if (pdf->xrefs[i].version < curr_ver)\n      {\n          prev_xref = &pdf->xrefs[i];\n          break;\n      }\n\n    if (!prev_xref)\n      return '?';\n\n    /* Locate the object in the previous one that matches current one */\n    prev = NULL;\n    for (i=0; i<prev_xref->n_entries; ++i)\n      if (prev_xref->entries[i].obj_id == curr->obj_id)\n      {\n          prev = &prev_xref->entries[i];\n          break;\n      }\n\n    /* Added in place of a previously freed id */\n    if (!prev || ((prev->f_or_n == 'f') && (curr->f_or_n == 'n')))\n      return 'A';\n\n    /* Modified */\n    else if (prev->offset != curr->offset)\n      return 'M';\n    \n    return '?';\n}\n\n\nvoid pdf_zero_object(\n    FILE        *fp,\n    const pdf_t *pdf,\n    int          xref_idx,\n    int          entry_idx)\n{\n    int           i;\n    char         *obj;\n    size_t        obj_sz;\n    xref_entry_t *entry;\n\n    entry = &pdf->xrefs[xref_idx].entries[entry_idx];\n    fseek(fp, entry->offset, SEEK_SET);\n\n    /* Get object and size */\n    obj = get_object(fp, entry->obj_id, &pdf->xrefs[xref_idx], NULL, NULL);\n    i = obj_sz = 0;\n    while (strncmp((++i)+obj, \"endobj\", 6))\n      ++obj_sz;\n\n    if (obj_sz)\n      obj_sz += strlen(\"endobj\") + 1;\n\n    /* Zero object */\n    for (i=0; i<obj_sz; i++)\n      fputc('0', fp);\n\n    printf(\"Zeroed object %d\\n\", entry->obj_id);\n    free(obj);\n}\n\n\n/* Output information per version */\nvoid pdf_summarize(\n    FILE        *fp,\n    const pdf_t *pdf,\n    const char  *name,\n    pdf_flag_t   flags)\n{\n    int   i, j, page, n_versions, n_entries;\n    FILE *dst, *out;\n    char *dst_name, *c;\n\n    dst = NULL;\n    dst_name = NULL;\n\n    if (name)\n    {\n        dst_name = safe_calloc(strlen(name) * 2 + 16);\n        sprintf(dst_name, \"%s/%s\", name, name);\n\n        if ((c = strrchr(dst_name, '.')) && (strncmp(c, \".pdf\", 4) == 0))\n          *c = '\\0';\n\n        strcat(dst_name, \".summary\");\n        if (!(dst = fopen(dst_name, \"w\")))\n        {\n            ERR(\"Could not open file '%s' for writing\\n\", dst_name);\n            return;\n        }\n    }\n    \n    /* Send output to file or stdout */\n    out = (dst) ? dst : stdout;\n\n    /* Count versions */\n    n_versions = pdf->n_xrefs;\n    if (n_versions && pdf->xrefs[0].is_linear)\n      --n_versions;\n\n    /* Ignore bad xref entry */\n    for (i=1; i<pdf->n_xrefs; ++i)\n      if (pdf->xrefs[i].end == 0)\n        --n_versions;\n\n    /* If we have no valid versions but linear, count that */\n    if (!pdf->n_xrefs || (!n_versions && pdf->xrefs[0].is_linear))\n      n_versions = 1;\n\n    /* Compare each object (if we dont have xref streams) */\n    n_entries = 0;\n    for (i=0; !(const int)pdf->has_xref_streams && i<pdf->n_xrefs; i++)\n    {\n        if (flags & PDF_FLAG_QUIET)\n          continue;\n\n        for (j=0; j<pdf->xrefs[i].n_entries; j++)\n        {\n            ++n_entries;\n            fprintf(out,\n                    \"%s: --%c-- Version %d -- Object %d (%s)\",\n                    pdf->name,\n                    pdf_get_object_status(pdf, i, j),\n                    pdf->xrefs[i].version,\n                    pdf->xrefs[i].entries[j].obj_id,\n                    get_type(fp, pdf->xrefs[i].entries[j].obj_id,\n                             &pdf->xrefs[i]));\n\n            /* TODO\n            page = get_page(pdf->xrefs[i].entries[j].obj_id, &pdf->xrefs[i]);\n            */\n\n            if (0 /*page*/)\n              fprintf(out, \" Page(%d)\\n\", page);\n            else\n              fprintf(out, \"\\n\");\n        }\n    }\n\n    /* Trailing summary */\n    if (!(flags & PDF_FLAG_QUIET))\n    {\n        /* Let the user know that we cannot we print a per-object summary.\n         * If we have a 1.5 PDF using streams for xref, we have not objects\n         * to display, so let the user know whats up.\n         */\n        if (pdf->has_xref_streams || !n_entries)\n           fprintf(out,\n               \"%s: This PDF contains potential cross reference streams.\\n\"\n               \"%s: An object summary is not available.\\n\",\n               pdf->name,\n               pdf->name);\n\n        fprintf(out,\n                \"---------- %s ----------\\n\"\n                \"Versions: %d\\n\", \n                pdf->name,\n                n_versions);\n\n        /* Count entries for summary */\n        if (!pdf->has_xref_streams)\n          for (i=0; i<pdf->n_xrefs; i++)\n          {\n              if (pdf->xrefs[i].is_linear)\n                continue;\n\n              n_entries = pdf->xrefs[i].n_entries;\n\n              /* If we are a linearized PDF, all versions are made from those\n               * objects too.  So count em'\n               */\n              if (pdf->xrefs[0].is_linear)\n                n_entries += pdf->xrefs[0].n_entries; \n\n              if (pdf->xrefs[i].version && n_entries)\n                fprintf(out,\n                        \"Version %d -- %d objects\\n\",\n                        pdf->xrefs[i].version, \n                        n_entries);\n           }\n    }\n    else /* Quiet output */\n      fprintf(out, \"%s: %d\\n\", pdf->name, n_versions);\n\n    if (dst)\n    {\n        fclose(dst);\n        free(dst_name);\n    }\n}\n\n\n/* Returns '1' if we successfully display data (means its probably not xml) */\nint pdf_display_creator(const pdf_t *pdf, int xref_idx)\n{\n    int i;\n\n    if (!pdf->xrefs[xref_idx].creator)\n      return 0;\n\n    for (i=0; i<pdf->xrefs[xref_idx].n_creator_entries; ++i)\n      printf(\"%s: %s\\n\",\n             pdf->xrefs[xref_idx].creator[i].key,\n             pdf->xrefs[xref_idx].creator[i].value);\n\n    return (i > 0);\n}\n\n\n/* Checks if the xref is valid and sets 'is_stream' flag if the xref is a\n * stream (PDF 1.5 or higher)\n */\nstatic int is_valid_xref(FILE *fp, pdf_t *pdf, xref_t *xref)\n{\n    int   is_valid;\n    long  start;\n    char *c, buf[16];\n    \n    memset(buf, 0, sizeof(buf));\n    is_valid = 0;\n    start = ftell(fp);\n    fseek(fp, xref->start, SEEK_SET);\n\n    if (fgets(buf, 16, fp) == NULL) {\n      ERR(\"Failed to load xref string.\");\n      exit(EXIT_FAILURE);\n    }\n\n    if (strncmp(buf, \"xref\", strlen(\"xref\")) == 0)\n      is_valid = 1;\n    else\n    {  \n        /* PDFv1.5+ allows for xref data to be stored in streams vs plaintext */\n        fseek(fp, xref->start, SEEK_SET);\n        c = get_object_from_here(fp, NULL, &xref->is_stream);\n\n        if (c && xref->is_stream)\n        {\n            pdf->has_xref_streams = 1;\n            is_valid = 1;\n        }\n        free(c);\n    }\n\n    fseek(fp, start, SEEK_SET);\n    return is_valid;\n}\n\n\nstatic void load_xref_entries(FILE *fp, xref_t *xref)\n{\n    if (xref->is_stream)\n      load_xref_from_stream(fp, xref);\n    else\n      load_xref_from_plaintext(fp, xref);\n}\n\n\nstatic void load_xref_from_plaintext(FILE *fp, xref_t *xref)\n{\n    int  i, obj_id, added_entries;\n    char c, buf[32] = {0};\n    long start, pos;\n    size_t buf_idx;\n\n    start = ftell(fp);\n\n    /* Get number of entries */\n    pos = xref->end;\n    fseek(fp, pos, SEEK_SET);\n    while (ftell(fp) != 0)\n      if (SAFE_F(fp, (fgetc(fp) == '/' && fgetc(fp) == 'S')))\n        break;\n      else\n        SAFE_E(fseek(fp, --pos, SEEK_SET), 0, \"Failed seek to xref /Size.\\n\");\n\n    SAFE_E(fread(buf, 1, 21, fp), 21, \"Failed to load entry Size string.\\n\");\n    xref->n_entries = atoi(buf + strlen(\"ize \"));\n    xref->entries = safe_calloc(xref->n_entries * sizeof(struct _xref_entry));\n\n    /* Load entry data */\n    obj_id = 0;\n    fseek(fp, xref->start + strlen(\"xref\"), SEEK_SET);\n    added_entries = 0;\n    for (i=0; i<xref->n_entries; i++)\n    {\n        /* Advance past newlines. */\n        c = fgetc(fp);\n        while (c == '\\n' || c == '\\r')\n          c = fgetc(fp);\n\n        /* Collect data up until the following newline. */\n        buf_idx = 0;\n        while (c != '\\n' && c != '\\r' && !feof(fp) &&\n               !ferror(fp) && buf_idx < sizeof(buf))\n        {\n            buf[buf_idx++] = c;\n            c = fgetc(fp);\n        }\n        if (buf_idx >= sizeof(buf)) {\n            FAIL(\"Failed to locate newline character. \"\n                 \"This might be a corrupt PDF.\\n\");\n        }\n        buf[buf_idx] = '\\0';\n\n        /* Went to far and hit start of trailer */\n        if (strchr(buf, 't'))\n          break;\n\n        /* Entry or object id */\n        if (strlen(buf) > 17)\n        {\n            const char *token = NULL;\n            xref->entries[i].obj_id = obj_id++;\n            token = strtok(buf, \" \");\n            if (!token) {\n              FAIL(\"Failed to parse xref entry. \"\n                   \"This might be a corrupt PDF.\\n\");\n            }\n            xref->entries[i].offset = atol(token);\n            token = strtok(NULL, \" \");\n            if (!token) {\n              FAIL(\"Failed to parse xref entry. \"\n                   \"This might be a corrupt PDF.\\n\");\n            }\n            xref->entries[i].gen_num = atoi(token);\n            xref->entries[i].f_or_n = buf[17];\n            ++added_entries;\n        }\n        else\n        {\n            obj_id = atoi(buf);\n            --i;\n        }\n    }\n\n    xref->n_entries = added_entries;\n    fseek(fp, start, SEEK_SET);\n}\n\n\n/* Load an xref table from a stream (PDF v1.5 +) */\nstatic void load_xref_from_stream(FILE *fp, xref_t *xref)\n{\n    long    start;\n    int     is_stream;\n    char   *stream;\n    size_t  size;\n\n    start = ftell(fp);\n    fseek(fp, xref->start, SEEK_SET);\n\n    stream = NULL;\n    stream = get_object_from_here(fp, &size, &is_stream);\n    fseek(fp, start, SEEK_SET);\n\n    /* TODO: decode and analyize stream */\n    free(stream);\n    return;\n}\n\n\nstatic void get_xref_linear_skipped(FILE *fp, xref_t *xref)\n{\n    int  err;\n    char ch, buf[256];\n\n    if (xref->start != 0)\n      return;\n\n    /* Special case (Linearized PDF with initial startxref at 0) */\n    xref->is_linear = 1;\n\n    /* Seek to %%EOF */\n    if ((xref->end = get_next_eof(fp)) < 0)\n      return;\n\n    /* Locate the trailer */ \n    err = 0; \n    while (!(err = ferror(fp)) && fread(buf, 1, 8, fp))\n    {\n        if (strncmp(buf, \"trailer\", strlen(\"trailer\")) == 0)\n          break;\n        else if ((ftell(fp) - 9) < 0)\n          return;\n\n        fseek(fp, -9, SEEK_CUR);\n    }\n\n    if (err)\n      return;\n\n    /* If we found 'trailer' look backwards for 'xref' */\n    ch = 0;\n    while (SAFE_F(fp, ((ch = fgetc(fp)) != 'x')))\n      fseek(fp, -2, SEEK_CUR);\n\n    if (ch == 'x')\n    {\n        xref->start = ftell(fp) - 1;\n        fseek(fp, -1, SEEK_CUR);\n    }\n\n    /* Now continue to next eof ... */\n    fseek(fp, xref->start, SEEK_SET);\n}\n\n\n/* This must only be called after all xref and entries have been acquired */\nstatic void resolve_linearized_pdf(pdf_t *pdf)\n{\n    int    i;\n    xref_t buf;\n\n    if (pdf->n_xrefs < 2)\n      return;\n\n    if (!pdf->xrefs[0].is_linear)\n      return;\n\n    /* Swap Linear with Version 1 */\n    buf = pdf->xrefs[0];\n    pdf->xrefs[0] = pdf->xrefs[1];\n    pdf->xrefs[1] = buf;\n\n    /* Resolve is_linear flag and version */\n    pdf->xrefs[0].is_linear = 1;\n    pdf->xrefs[0].version = 1;\n    pdf->xrefs[1].is_linear = 0;\n    pdf->xrefs[1].version = 1;\n\n    /* Adjust the other version values now */\n    for (i=2; i<pdf->n_xrefs; ++i)\n      --pdf->xrefs[i].version;\n}\n\n\nstatic pdf_creator_t *new_creator(int *n_elements)\n{\n    pdf_creator_t *daddy;\n\n    static const pdf_creator_t creator_template[] = \n    {\n        {\"Title\",        \"\"},\n        {\"Author\",       \"\"},\n        {\"Subject\",      \"\"},\n        {\"Keywords\",     \"\"},\n        {\"Creator\",      \"\"},\n        {\"Producer\",     \"\"},\n        {\"CreationDate\", \"\"},\n        {\"ModDate\",      \"\"},\n        {\"Trapped\",      \"\"},\n    };\n\n    daddy = safe_calloc(sizeof(creator_template));\n    memcpy(daddy, creator_template, sizeof(creator_template));\n\n    if (n_elements)\n      *n_elements = sizeof(creator_template) / sizeof(creator_template[0]);\n\n    return daddy;\n}\n\n\n#define END_OF_TRAILER(_c, _st, _fp) \\\n{                                    \\\n    if (_c == '>')                   \\\n    {                                \\\n        fseek(_fp, _st, SEEK_SET);   \\\n        continue;                    \\\n    }                                \\\n}\nstatic void load_creator(FILE *fp, pdf_t *pdf)\n{\n    int    i, buf_idx;\n    char   c, *buf, obj_id_buf[32] = {0};\n    long   start;\n    size_t sz;\n\n    start = ftell(fp);\n\n    /* For each PDF version */\n    for (i=0; i<pdf->n_xrefs; ++i)\n    {\n        if (!pdf->xrefs[i].version)\n          continue;\n\n        /* Find trailer */\n        fseek(fp, pdf->xrefs[i].start, SEEK_SET);\n        while (SAFE_F(fp, (fgetc(fp) != 't')))\n            ; /* Iterate to \"trailer\" */\n\n        /* Look for \"<< ....... /Info ......\" */\n        c = '\\0';\n        while (SAFE_F(fp, ((c = fgetc(fp)) != '>')))\n          if (SAFE_F(fp, ((c == '/') &&\n                          (fgetc(fp) == 'I') && ((fgetc(fp) == 'n')))))\n            break;\n\n        /* Could not find /Info in trailer */\n        END_OF_TRAILER(c, start, fp);\n\n        while (SAFE_F(fp, (!isspace(c = fgetc(fp)) && (c != '>'))))\n            ; /* Iterate to first white space /Info<space><data> */\n\n        /* No space between /Info and its data */\n        END_OF_TRAILER(c, start, fp);\n\n        while (SAFE_F(fp, (isspace(c = fgetc(fp)) && (c != '>'))))\n            ; /* Iterate right on top of first non-whitespace /Info data */\n\n        /* No data for /Info */\n        END_OF_TRAILER(c, start, fp);\n\n        /* Get obj id as number */\n        buf_idx = 0;\n        obj_id_buf[buf_idx++] = c;\n        while ((buf_idx < (sizeof(obj_id_buf) - 1)) &&\n               SAFE_F(fp, (!isspace(c = fgetc(fp)) && (c != '>'))))\n          obj_id_buf[buf_idx++] = c;\n\n        END_OF_TRAILER(c, start, fp);\n     \n        /* Get the object for the creator data.  If linear, try both xrefs */ \n        buf = get_object(fp, atoll(obj_id_buf), &pdf->xrefs[i], &sz, NULL);\n        if (!buf && pdf->xrefs[i].is_linear && (i+1 < pdf->n_xrefs))\n          buf = get_object(fp, atoll(obj_id_buf), &pdf->xrefs[i+1], &sz, NULL);\n\n        load_creator_from_buf(fp, &pdf->xrefs[i], buf, sz);\n        free(buf);\n    }\n\n    fseek(fp, start, SEEK_SET);\n}\n\n\nstatic void load_creator_from_buf(\n    FILE       *fp,\n    xref_t     *xref,\n    const char *buf,\n    size_t      buf_size)\n{\n    int   is_xml;\n    char *c;\n\n    if (!buf)\n      return;\n\n    /* Check to see if this is xml or old-school */\n    if ((c = strstr(buf, \"/Type\")))\n      while (*c && !isspace(*c))\n        ++c;\n\n    /* Probably \"Metadata\" */\n    is_xml = 0;\n    if (c && (*c == 'M'))\n      is_xml = 1;\n\n    /* Is the buffer XML(PDF 1.4+) or old format? */\n    if (is_xml)\n      load_creator_from_xml(xref, buf);\n    else\n      load_creator_from_old_format(fp, xref, buf, buf_size);\n}\n\n\nstatic void load_creator_from_xml(xref_t *xref, const char *buf)\n{\n    /* TODO */\n}\n\n\nstatic void load_creator_from_old_format(\n    FILE       *fp,\n    xref_t     *xref,\n    const char *buf,\n    size_t      buf_size)\n{\n    int            i, n_eles, length, is_escaped, obj_id;\n    char          *c, *ascii, *start, *s, *saved_buf_search, *obj;\n    size_t         obj_size;\n    pdf_creator_t *info;\n\n    info = new_creator(&n_eles);\n\n    /* Mark the end of buf, so that we do not crawl past it */\n    if (buf_size < 1) return;\n    const char *buf_end = buf + buf_size - 1;\n\n    /* Treat 'end' as either the end of 'buf' or the end of 'obj'.  Obj is if\n     * the creator element (e.g., ModDate, Producer, etc) is an object and not\n     * part of 'buf'.\n     */\n    const char *end = buf_end;\n\n    for (i=0; i<n_eles; ++i)\n    {\n        if (!(c = strstr(buf, info[i].key)))\n          continue;\n\n        /* Find the value (skipping whitespace) */\n        c += strlen(info[i].key);\n        while (isspace(*c))\n          ++c;\n        if (c >= buf_end) {\n          FAIL(\"Failed to locate space, likely a corrupt PDF.\");\n        }\n\n        /* If looking at the start of a pdf token, we have gone too far */\n        if (*c == '/')\n          continue;\n\n        /* If the value is a number and not a '(' then the data is located in\n         * an object we need to fetch, and not inline\n         */\n        obj = saved_buf_search = NULL;\n        obj_size = 0;\n        end = buf_end; /* Init to be the buffer, this might not be an obj. */\n        if (isdigit(*c))\n        {\n            obj_id = atoi(c);\n            saved_buf_search = c;\n            s = saved_buf_search;\n\n            obj = get_object(fp, obj_id, xref, &obj_size, NULL);\n            end = obj + obj_size;\n            c = obj;\n\n            /* Iterate to '(' */\n            while (c && (*c != '(') && (c < end))\n              ++c;\n            if (c >= end)  {\n              FAIL(\"Failed to locate a '(' character. \"\n                  \"This might be a corrupt PDF.\\n\");\n            }\n\n            /* Advance the search to the next token */\n            while (s && (*s == '/') && (s < buf_end))\n              ++s;\n            if (s >= buf_end)  {\n              FAIL(\"Failed to locate a '/' character. \"\n                  \"This might be a corrupt PDF.\\n\");\n            }\n            saved_buf_search = s;\n        }\n          \n        /* Find the end of the value */\n        start = c;\n        length = is_escaped = 0;\n        while (c && ((*c != '\\r') && (*c != '\\n') && (*c != '<')))\n        {\n            /* Bail out if we see an un-escaped ')' closing character */\n            if (!is_escaped && (*c == ')'))\n              break;\n            else if (*c == '\\\\')\n              is_escaped = 1;\n            else\n              is_escaped = 0;\n            ++c;\n            ++length;\n            if (c > end) {\n              FAIL(\"Failed to locate the end of a value. \"\n                   \"This might be a corrupt PDF.\\n\");\n            }\n        }\n\n        if (length == 0)\n          continue;\n\n        /* Add 1 to length so it gets the closing ')' when we copy */\n        if (length)\n          length += 1;\n        length = (length > KV_MAX_VALUE_LENGTH) ? KV_MAX_VALUE_LENGTH : length;\n        strncpy(info[i].value, start, length);\n        info[i].value[KV_MAX_VALUE_LENGTH - 1] = '\\0';\n\n        /* Restore where we were searching from */\n        if (saved_buf_search)\n        {\n            /* Release memory from get_object() called earlier */\n            free(obj);\n            c = saved_buf_search;\n        }\n    } /* For all creation information tags */\n\n    /* Go through the values and convert if encoded */\n    for (i = 0; i < n_eles; ++i) {\n      const size_t val_str_len = strnlen(info[i].value, KV_MAX_VALUE_LENGTH);\n      if ((ascii = decode_text_string(info[i].value, val_str_len))) {\n        strncpy(info[i].value, ascii, val_str_len);\n        free(ascii);\n      }\n    }\n\n    xref->creator = info;\n    xref->n_creator_entries = n_eles;\n}\n\n\n/* Returns object data at the start of the file pointer\n * This interfaces to 'get_object'\n */\nstatic char *get_object_from_here(FILE *fp, size_t *size, int *is_stream)\n{\n    long         start;\n    char         buf[256];\n    int          obj_id;\n    xref_t       xref;\n    xref_entry_t entry;\n\n    start = ftell(fp);\n\n    /* Object ID */\n    memset(buf, 0, 256);\n    SAFE_E(fread(buf, 1, 255, fp), 255, \"Failed to load object ID.\\n\");\n    if (!(obj_id = atoi(buf)))\n    {\n        fseek(fp, start, SEEK_SET);\n        return NULL;\n    }\n    \n    /* Create xref entry to pass to the get_object routine */\n    memset(&entry, 0, sizeof(xref_entry_t));\n    entry.obj_id = obj_id;\n    entry.offset = start;\n\n    /* Xref and single entry for the object we want data from */\n    memset(&xref, 0, sizeof(xref_t));\n    xref.n_entries = 1;\n    xref.entries = &entry;\n\n    fseek(fp, start, SEEK_SET);\n    return get_object(fp, obj_id, &xref, size, is_stream);\n}\n\n\nstatic char *get_object(\n    FILE         *fp,\n    int           obj_id,\n    const xref_t *xref,\n    size_t       *size,\n    int          *is_stream)\n{\n    static const int    blk_sz = 256;\n    int                 i, total_sz, read_sz, n_blks, search, stream;\n    size_t              obj_sz;\n    char               *c, *data;\n    long                start;\n    const xref_entry_t *entry;\n\n    if (size)\n      *size = 0;\n\n    if (is_stream)\n      *is_stream = 0;\n\n    start = ftell(fp);\n\n    /* Find object */\n    entry = NULL;\n    for (i=0; i<xref->n_entries; i++)\n      if (xref->entries[i].obj_id == obj_id)\n      {\n          entry = &xref->entries[i];\n          break;\n      }\n\n    if (!entry)\n      return NULL;\n\n    /* Jump to object start */\n    fseek(fp, entry->offset, SEEK_SET);\n\n    /* Initial allocation */\n    obj_sz = 0;    /* Bytes in object */\n    total_sz = 0;  /* Bytes read in   */\n    n_blks = 1;\n    data = safe_calloc(blk_sz * n_blks);\n\n    /* Suck in data */\n    stream = 0;\n    while ((read_sz = fread(data+total_sz, 1, blk_sz-1, fp)) && !ferror(fp))\n    {\n        total_sz += read_sz;\n\n        *(data + total_sz) = '\\0';\n\n        if (total_sz + blk_sz >= (blk_sz * n_blks))\n          data = realloc(data, blk_sz * (++n_blks));\n        if (!data) {\n          ERR(\"Failed to reallocate buffer.\\n\");\n          exit(EXIT_FAILURE);\n        }\n\n        search = total_sz - read_sz;\n        if (search < 0)\n          search = 0;\n\n        if ((c = strstr(data + search, \"endobj\")))\n        {\n            *(c + strlen(\"endobj\") + 1) = '\\0';\n            obj_sz = (char *)strstr(data + search, \"endobj\") - (char *)data;\n            obj_sz += strlen(\"endobj\") + 1;\n            break;\n        }\n        else if (strstr(data, \"stream\"))\n          stream = 1;\n    }\n\n    clearerr(fp);\n    fseek(fp, start, SEEK_SET);\n\n    if (size) {\n      *size = obj_sz;\n      if (!obj_sz && data) {\n        free(data);\n        data = NULL;\n      }\n    }\n            \n    if (is_stream)\n      *is_stream = stream;\n\n    return data;\n}\n\n\nstatic const char *get_type(FILE *fp, int obj_id, const xref_t *xref)\n{\n    int          is_stream;\n    char        *c, *obj, *endobj;\n    static char  buf[32];\n    long         start;\n\n    start = ftell(fp);\n\n    if (!(obj = get_object(fp, obj_id, xref, NULL, &is_stream)) || \n        is_stream                                               ||\n        !(endobj = strstr(obj, \"endobj\")))\n    {\n        free(obj);\n        fseek(fp, start, SEEK_SET);\n\n        if (is_stream)\n          return \"Stream\";\n        else\n          return \"Unknown\";\n    }\n\n    /* Get the Type value (avoiding font names like Type1) */\n    c = obj;\n    while ((c = strstr(c, \"/Type\")) && (c < endobj))\n      if (isdigit(*(c + strlen(\"/Type\"))))\n      {\n          ++c;\n          continue;\n      }\n      else\n        break;\n\n    if (!c || (c && (c > endobj)))\n    {\n        free(obj);\n        fseek(fp, start, SEEK_SET);\n        return \"Unknown\";\n    }\n\n    /* Skip to first blank/whitespace */\n    c += strlen(\"/Type\");\n    while (isspace(*c) || *c == '/')\n      ++c;\n\n    /* 'c' should be pointing to the type name.  Find the end of the name. */\n    size_t n_chars = 0;\n    const char *name_itr = c;\n    while ((name_itr < endobj) &&\n           !(isspace(*name_itr) || *name_itr == '/' || *name_itr == '>')) {\n        ++name_itr;\n        ++n_chars;\n    }\n    if (n_chars >= sizeof(buf))\n    {\n        free(obj);\n        fseek(fp, start, SEEK_SET);\n        return \"Unknown\";\n    }\n\n    /* Return the value by storing it in static mem. */\n    memcpy(buf, c, n_chars);\n    buf[n_chars] = '\\0';\n    free(obj);\n    fseek(fp, start, SEEK_SET);\n    return buf;\n}\n\n\nstatic char *get_header(FILE *fp)\n{\n    /* First 1024 bytes of doc must be header (1.7 spec pg 1102) */\n    char *header = safe_calloc(1024);\n    long start = ftell(fp);\n    fseek(fp, 0, SEEK_SET);\n    SAFE_E(fread(header, 1, 1023, fp), 1023, \"Failed to load PDF header.\\n\");\n    fseek(fp, start, SEEK_SET);\n    return header;\n}\n\n\nstatic char *decode_text_string(const char *str, size_t str_len)\n{\n    int   idx, is_hex, is_utf16be, ascii_idx;\n    char *ascii, hex_buf[5] = {0};\n\n    is_hex = is_utf16be = idx = ascii_idx = 0;\n\n    /* Regular encoding */\n    if (str[0] == '(')\n    {\n        ascii = safe_calloc(str_len + 1);\n        strncpy(ascii, str, str_len + 1);\n        return ascii;\n    }\n    else if (str[0] == '<')\n    {\n        is_hex = 1;\n        ++idx;\n    }\n    \n    /* Text strings can be either PDFDocEncoding or UTF-16BE */\n    if (is_hex && (str_len > 5) && \n        (str[idx] == 'F') && (str[idx+1] == 'E') &&\n        (str[idx+2] == 'F') && (str[idx+3] == 'F'))\n    {\n        is_utf16be = 1;\n        idx += 4;\n    }\n    else\n      return NULL;\n\n    /* Now decode as hex */\n    ascii = safe_calloc(str_len);\n    for ( ; idx<str_len; ++idx)\n    {\n        hex_buf[0] = str[idx++];\n        hex_buf[1] = str[idx++];\n        hex_buf[2] = str[idx++];\n        hex_buf[3] = str[idx];\n        ascii[ascii_idx++] = strtol(hex_buf, NULL, 16);\n    }\n\n    return ascii;\n}\n\n\n/* Return the offset to the beginning of the %%EOF string.\n * A negative value is returned when done scanning.\n */\nstatic int get_next_eof(FILE *fp)\n{\n    int match, c;\n    const char buf[] = \"%%EOF\";\n\n    match = 0;\n    while ((c = fgetc(fp)) != EOF)\n    {\n        if (c == buf[match])\n          ++match;\n        else\n          match = 0;\n\n        if (match == 5) /* strlen(\"%%EOF\") */\n          return ftell(fp) - 5;\n    }\n\n    return -1;\n}\n"], "fixing_code": ["Matt Davis (enferex): Original pdfresurrect, modified man page\n\nFrancois Marier: Original man page, modified Makefile.in\n                 and modified configure.ac, potential security bug identifying\n                 (e.g., bad code detection).\n\nDavid Binderman: Finding a bug and offering a correction suggestion\n\nRyan Schmidt: MacPorts Makefile work\n\nxambroz: Suggestions and Makefile enhancement.\n\nj0lamma: Identified a bug that can cause a corrupted buffer.\n\ncapcorpscert0188, LeeSunWoo, ParkInChul: Identified a bug that can cause\n                                         a corrupted buffer.\n\nrtfingc: Reported bugs regarding memory corruption and a leak.\n\nrwhitworth: Reported and helped isolate bugs. Created initial .gitignore.\n\ncarter-yagemann: Reported and helped isolate a memory issue.\n\nrootup: Reporting and helped isolate a memory issue.\n\nZanderChang: Reported and identified bad code in kid page loading.\n\nyifengchen-cc: Reported a header parsing bug.\n", "/******************************************************************************\n * pdf.c \n *\n * pdfresurrect - PDF history extraction tool\n *\n * Copyright (C) 2008-2010, 2012-2013, 2017-20, Matt Davis (enferex).\n *\n * Special thanks to all of the contributors:  See AUTHORS.\n *\n * Special thanks to 757labs (757 crew), they are a great group\n * of people to hack on projects and brainstorm with.\n *\n * pdf.c is part of pdfresurrect.\n * pdfresurrect is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * pdfresurrect is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with pdfresurrect.  If not, see <http://www.gnu.org/licenses/>.\n *****************************************************************************/\n\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include \"pdf.h\"\n#include \"main.h\"\n\n\n/* \n * Macros\n */\n\n/* SAFE_F\n *\n * Safe file read: use for fgetc() calls, this is really ugly looking. \n * _fp:   FILE * handle\n * _expr: The expression with fgetc() in it:\n * \n *  example: If we get a character from the file and it is ascii character 'a'\n *           This assumes the coder wants to store the 'a' in variable ch\n *           Kinda pointless if you already know that you have 'a', but for\n *           illustrative purposes.\n *\n *  if (SAFE_F(my_fp, ((c=fgetc(my_fp)) == 'a')))\n *              do_way_cool_stuff();\n */\n#define SAFE_F(_fp, _expr) \\\n    ((!ferror(_fp) && !feof(_fp) && (_expr)))\n\n\n/* FAIL\n *\n * Emit the diagnostic '_msg' and exit.\n * _msg: Message to emit prior to exiting.\n */\n#define FAIL(_msg)      \\\n  do {                  \\\n    ERR(_msg);          \\\n    exit(EXIT_FAILURE); \\\n  } while (0)\n\n\n/* SAFE_E\n *\n * Safe expression handling.  This macro is a wrapper\n * that compares the result of an expression (_expr) to the expected\n * value (_cmp).\n *\n * _expr: Expression to test.\n * _cmp:  Expected value, error if this returns false.\n * _msg:  What to say when an error occurs.\n */\n#define SAFE_E(_expr, _cmp, _msg) \\\n do {                             \\\n    if ((_expr) != (_cmp)) {      \\\n      FAIL(_msg);                  \\\n    }                             \\\n  } while (0)\n\n\n/*\n * Forwards\n */\n\nstatic int is_valid_xref(FILE *fp, pdf_t *pdf, xref_t *xref);\nstatic void load_xref_entries(FILE *fp, xref_t *xref);\nstatic void load_xref_from_plaintext(FILE *fp, xref_t *xref);\nstatic void load_xref_from_stream(FILE *fp, xref_t *xref);\nstatic void get_xref_linear_skipped(FILE *fp, xref_t *xref);\nstatic void resolve_linearized_pdf(pdf_t *pdf);\n\nstatic pdf_creator_t *new_creator(int *n_elements);\nstatic void load_creator(FILE *fp, pdf_t *pdf);\nstatic void load_creator_from_buf(\n    FILE       *fp,\n    xref_t     *xref,\n    const char *buf,\n    size_t      buf_size);\nstatic void load_creator_from_xml(xref_t *xref, const char *buf);\nstatic void load_creator_from_old_format(\n    FILE       *fp,\n    xref_t     *xref,\n    const char *buf,\n    size_t      buf_size);\n\nstatic char *get_object_from_here(FILE *fp, size_t *size, int *is_stream);\n\nstatic char *get_object(\n    FILE         *fp,\n    int           obj_id,\n    const xref_t *xref,\n    size_t       *size,\n    int          *is_stream);\n\nstatic const char *get_type(FILE *fp, int obj_id, const xref_t *xref);\n/* static int get_page(int obj_id, const xref_t *xref); */\nstatic char *get_header(FILE *fp);\n\nstatic char *decode_text_string(const char *str, size_t str_len);\nstatic int get_next_eof(FILE *fp);\n\n\n/*\n * Defined\n */\n\npdf_t *pdf_new(const char *name)\n{\n    const char *n;\n    pdf_t      *pdf;\n   \n    pdf = safe_calloc(sizeof(pdf_t));\n\n    if (name)\n    {\n        /* Just get the file name (not path) */\n        if ((n = strrchr(name, '/')))\n          ++n;\n        else\n          n = name;\n\n        pdf->name = safe_calloc(strlen(n) + 1);\n        strcpy(pdf->name, n);\n    }\n    else /* !name */\n    {\n        pdf->name = safe_calloc(strlen(\"Unknown\") + 1);\n        strcpy(pdf->name, \"Unknown\");\n    }\n\n    return pdf;\n}\n\n\nvoid pdf_delete(pdf_t *pdf)\n{\n    int i;\n\n    for (i=0; i<pdf->n_xrefs; i++)\n    {\n        free(pdf->xrefs[i].creator);\n        free(pdf->xrefs[i].entries);\n    }\n\n    free(pdf->name);\n    free(pdf->xrefs);\n    free(pdf);\n}\n\n\nint pdf_is_pdf(FILE *fp)\n{\n    char *header;\n    if (!(header = get_header(fp)))\n      return 0;\n\n    /* First 1024 bytes of doc must be header (1.7 spec pg 1102) */\n    const char *c = strstr(header, \"%PDF-\");\n    const int is_pdf = c && ((c - header+strlen(\"%PDF-M.m\")) < 1024);\n    free(header);\n    return is_pdf;\n}\n\n\nvoid pdf_get_version(FILE *fp, pdf_t *pdf)\n{\n    char *header = get_header(fp);\n\n    /* Locate version string start and make sure we dont go past header\n     * The format is %PDF-M.m, where 'M' is the major number and 'm' minor.\n     */\n    const char *c;\n    if ((c = strstr(header, \"%PDF-\")) && \n        ((c + 6)[0] == '.') && // Separator\n        isdigit((c + 5)[0]) && // Major number\n        isdigit((c + 7)[0]))   // Minor number\n    {\n        pdf->pdf_major_version = atoi(c + strlen(\"%PDF-\"));\n        pdf->pdf_minor_version = atoi(c + strlen(\"%PDF-M.\"));\n    }\n\n    free(header);\n}\n\n\nint pdf_load_xrefs(FILE *fp, pdf_t *pdf)\n{\n    int  i, ver, is_linear;\n    long pos, pos_count;\n    char x, *c, buf[256];\n    \n    c = NULL;\n\n    /* Count number of xrefs */\n    pdf->n_xrefs = 0;\n    fseek(fp, 0, SEEK_SET);\n    while (get_next_eof(fp) >= 0)\n      ++pdf->n_xrefs;\n\n    if (!pdf->n_xrefs)\n      return 0;\n\n    /* Load in the start/end positions */\n    fseek(fp, 0, SEEK_SET);\n    pdf->xrefs = safe_calloc(sizeof(xref_t) * pdf->n_xrefs);\n    ver = 1;\n    for (i=0; i<pdf->n_xrefs; i++)\n    {\n        /* Seek to %%EOF */\n        if ((pos = get_next_eof(fp)) < 0)\n          break;\n\n        /* Set and increment the version */\n        pdf->xrefs[i].version = ver++;\n\n        /* Rewind until we find end of \"startxref\" */\n        pos_count = 0;\n        while (SAFE_F(fp, ((x = fgetc(fp)) != 'f')))\n          fseek(fp, pos - (++pos_count), SEEK_SET);\n        \n        /* Suck in end of \"startxref\" to start of %%EOF */\n        if (pos_count >= sizeof(buf)) {\n          FAIL(\"Failed to locate the startxref token. \"\n              \"This might be a corrupt PDF.\\n\");\n        }\n        memset(buf, 0, sizeof(buf));\n        SAFE_E(fread(buf, 1, pos_count, fp), pos_count,\n               \"Failed to read startxref.\\n\");\n        c = buf;\n        while (*c == ' ' || *c == '\\n' || *c == '\\r')\n          ++c;\n    \n        /* xref start position */\n        pdf->xrefs[i].start = atol(c);\n\n        /* If xref is 0 handle linear xref table */\n        if (pdf->xrefs[i].start == 0)\n          get_xref_linear_skipped(fp, &pdf->xrefs[i]);\n\n        /* Non-linear, normal operation, so just find the end of the xref */\n        else\n        {\n            /* xref end position */\n            pos = ftell(fp);\n            fseek(fp, pdf->xrefs[i].start, SEEK_SET);\n            pdf->xrefs[i].end = get_next_eof(fp);\n\n            /* Look for next EOF and xref data */\n            fseek(fp, pos, SEEK_SET);\n        }\n\n        /* Check validity */\n        if (!is_valid_xref(fp, pdf, &pdf->xrefs[i]))\n        {\n            is_linear = pdf->xrefs[i].is_linear;\n            memset(&pdf->xrefs[i], 0, sizeof(xref_t));\n            pdf->xrefs[i].is_linear = is_linear;\n            rewind(fp);\n            get_next_eof(fp);\n            continue;\n        }\n\n        /*  Load the entries from the xref */\n        load_xref_entries(fp, &pdf->xrefs[i]);\n    }\n\n    /* Now we have all xref tables, if this is linearized, we need\n     * to make adjustments so that things spit out properly\n     */\n    if (pdf->xrefs[0].is_linear)\n      resolve_linearized_pdf(pdf);\n\n    /* Ok now we have all xref data.  Go through those versions of the \n     * PDF and try to obtain creator information\n     */\n    load_creator(fp, pdf);\n\n    return pdf->n_xrefs;\n}\n\n\n/* Load page information */\nchar pdf_get_object_status(\n    const pdf_t *pdf,\n    int          xref_idx,\n    int          entry_idx)\n{\n    int                 i, curr_ver;\n    const xref_t       *prev_xref;\n    const xref_entry_t *prev, *curr;\n\n    curr = &pdf->xrefs[xref_idx].entries[entry_idx];\n    curr_ver = pdf->xrefs[xref_idx].version;\n\n    if (curr_ver == 1)\n      return 'A';\n\n    /* Deleted (freed) */\n    if (curr->f_or_n == 'f')\n      return 'D';\n\n    /* Get previous version */\n    prev_xref = NULL;\n    for (i=xref_idx; i>-1; --i)\n      if (pdf->xrefs[i].version < curr_ver)\n      {\n          prev_xref = &pdf->xrefs[i];\n          break;\n      }\n\n    if (!prev_xref)\n      return '?';\n\n    /* Locate the object in the previous one that matches current one */\n    prev = NULL;\n    for (i=0; i<prev_xref->n_entries; ++i)\n      if (prev_xref->entries[i].obj_id == curr->obj_id)\n      {\n          prev = &prev_xref->entries[i];\n          break;\n      }\n\n    /* Added in place of a previously freed id */\n    if (!prev || ((prev->f_or_n == 'f') && (curr->f_or_n == 'n')))\n      return 'A';\n\n    /* Modified */\n    else if (prev->offset != curr->offset)\n      return 'M';\n    \n    return '?';\n}\n\n\nvoid pdf_zero_object(\n    FILE        *fp,\n    const pdf_t *pdf,\n    int          xref_idx,\n    int          entry_idx)\n{\n    int           i;\n    char         *obj;\n    size_t        obj_sz;\n    xref_entry_t *entry;\n\n    entry = &pdf->xrefs[xref_idx].entries[entry_idx];\n    fseek(fp, entry->offset, SEEK_SET);\n\n    /* Get object and size */\n    obj = get_object(fp, entry->obj_id, &pdf->xrefs[xref_idx], NULL, NULL);\n    i = obj_sz = 0;\n    while (strncmp((++i)+obj, \"endobj\", 6))\n      ++obj_sz;\n\n    if (obj_sz)\n      obj_sz += strlen(\"endobj\") + 1;\n\n    /* Zero object */\n    for (i=0; i<obj_sz; i++)\n      fputc('0', fp);\n\n    printf(\"Zeroed object %d\\n\", entry->obj_id);\n    free(obj);\n}\n\n\n/* Output information per version */\nvoid pdf_summarize(\n    FILE        *fp,\n    const pdf_t *pdf,\n    const char  *name,\n    pdf_flag_t   flags)\n{\n    int   i, j, page, n_versions, n_entries;\n    FILE *dst, *out;\n    char *dst_name, *c;\n\n    dst = NULL;\n    dst_name = NULL;\n\n    if (name)\n    {\n        dst_name = safe_calloc(strlen(name) * 2 + 16);\n        sprintf(dst_name, \"%s/%s\", name, name);\n\n        if ((c = strrchr(dst_name, '.')) && (strncmp(c, \".pdf\", 4) == 0))\n          *c = '\\0';\n\n        strcat(dst_name, \".summary\");\n        if (!(dst = fopen(dst_name, \"w\")))\n        {\n            ERR(\"Could not open file '%s' for writing\\n\", dst_name);\n            return;\n        }\n    }\n    \n    /* Send output to file or stdout */\n    out = (dst) ? dst : stdout;\n\n    /* Count versions */\n    n_versions = pdf->n_xrefs;\n    if (n_versions && pdf->xrefs[0].is_linear)\n      --n_versions;\n\n    /* Ignore bad xref entry */\n    for (i=1; i<pdf->n_xrefs; ++i)\n      if (pdf->xrefs[i].end == 0)\n        --n_versions;\n\n    /* If we have no valid versions but linear, count that */\n    if (!pdf->n_xrefs || (!n_versions && pdf->xrefs[0].is_linear))\n      n_versions = 1;\n\n    /* Compare each object (if we dont have xref streams) */\n    n_entries = 0;\n    for (i=0; !(const int)pdf->has_xref_streams && i<pdf->n_xrefs; i++)\n    {\n        if (flags & PDF_FLAG_QUIET)\n          continue;\n\n        for (j=0; j<pdf->xrefs[i].n_entries; j++)\n        {\n            ++n_entries;\n            fprintf(out,\n                    \"%s: --%c-- Version %d -- Object %d (%s)\",\n                    pdf->name,\n                    pdf_get_object_status(pdf, i, j),\n                    pdf->xrefs[i].version,\n                    pdf->xrefs[i].entries[j].obj_id,\n                    get_type(fp, pdf->xrefs[i].entries[j].obj_id,\n                             &pdf->xrefs[i]));\n\n            /* TODO\n            page = get_page(pdf->xrefs[i].entries[j].obj_id, &pdf->xrefs[i]);\n            */\n\n            if (0 /*page*/)\n              fprintf(out, \" Page(%d)\\n\", page);\n            else\n              fprintf(out, \"\\n\");\n        }\n    }\n\n    /* Trailing summary */\n    if (!(flags & PDF_FLAG_QUIET))\n    {\n        /* Let the user know that we cannot we print a per-object summary.\n         * If we have a 1.5 PDF using streams for xref, we have not objects\n         * to display, so let the user know whats up.\n         */\n        if (pdf->has_xref_streams || !n_entries)\n           fprintf(out,\n               \"%s: This PDF contains potential cross reference streams.\\n\"\n               \"%s: An object summary is not available.\\n\",\n               pdf->name,\n               pdf->name);\n\n        fprintf(out,\n                \"---------- %s ----------\\n\"\n                \"Versions: %d\\n\", \n                pdf->name,\n                n_versions);\n\n        /* Count entries for summary */\n        if (!pdf->has_xref_streams)\n          for (i=0; i<pdf->n_xrefs; i++)\n          {\n              if (pdf->xrefs[i].is_linear)\n                continue;\n\n              n_entries = pdf->xrefs[i].n_entries;\n\n              /* If we are a linearized PDF, all versions are made from those\n               * objects too.  So count em'\n               */\n              if (pdf->xrefs[0].is_linear)\n                n_entries += pdf->xrefs[0].n_entries; \n\n              if (pdf->xrefs[i].version && n_entries)\n                fprintf(out,\n                        \"Version %d -- %d objects\\n\",\n                        pdf->xrefs[i].version, \n                        n_entries);\n           }\n    }\n    else /* Quiet output */\n      fprintf(out, \"%s: %d\\n\", pdf->name, n_versions);\n\n    if (dst)\n    {\n        fclose(dst);\n        free(dst_name);\n    }\n}\n\n\n/* Returns '1' if we successfully display data (means its probably not xml) */\nint pdf_display_creator(const pdf_t *pdf, int xref_idx)\n{\n    int i;\n\n    if (!pdf->xrefs[xref_idx].creator)\n      return 0;\n\n    for (i=0; i<pdf->xrefs[xref_idx].n_creator_entries; ++i)\n      printf(\"%s: %s\\n\",\n             pdf->xrefs[xref_idx].creator[i].key,\n             pdf->xrefs[xref_idx].creator[i].value);\n\n    return (i > 0);\n}\n\n\n/* Checks if the xref is valid and sets 'is_stream' flag if the xref is a\n * stream (PDF 1.5 or higher)\n */\nstatic int is_valid_xref(FILE *fp, pdf_t *pdf, xref_t *xref)\n{\n    int   is_valid;\n    long  start;\n    char *c, buf[16];\n    \n    memset(buf, 0, sizeof(buf));\n    is_valid = 0;\n    start = ftell(fp);\n    fseek(fp, xref->start, SEEK_SET);\n\n    if (fgets(buf, 16, fp) == NULL) {\n      ERR(\"Failed to load xref string.\");\n      exit(EXIT_FAILURE);\n    }\n\n    if (strncmp(buf, \"xref\", strlen(\"xref\")) == 0)\n      is_valid = 1;\n    else\n    {  \n        /* PDFv1.5+ allows for xref data to be stored in streams vs plaintext */\n        fseek(fp, xref->start, SEEK_SET);\n        c = get_object_from_here(fp, NULL, &xref->is_stream);\n\n        if (c && xref->is_stream)\n        {\n            pdf->has_xref_streams = 1;\n            is_valid = 1;\n        }\n        free(c);\n    }\n\n    fseek(fp, start, SEEK_SET);\n    return is_valid;\n}\n\n\nstatic void load_xref_entries(FILE *fp, xref_t *xref)\n{\n    if (xref->is_stream)\n      load_xref_from_stream(fp, xref);\n    else\n      load_xref_from_plaintext(fp, xref);\n}\n\n\nstatic void load_xref_from_plaintext(FILE *fp, xref_t *xref)\n{\n    int  i, obj_id, added_entries;\n    char c, buf[32] = {0};\n    long start, pos;\n    size_t buf_idx;\n\n    start = ftell(fp);\n\n    /* Get number of entries */\n    pos = xref->end;\n    fseek(fp, pos, SEEK_SET);\n    while (ftell(fp) != 0)\n      if (SAFE_F(fp, (fgetc(fp) == '/' && fgetc(fp) == 'S')))\n        break;\n      else\n        SAFE_E(fseek(fp, --pos, SEEK_SET), 0, \"Failed seek to xref /Size.\\n\");\n\n    SAFE_E(fread(buf, 1, 21, fp), 21, \"Failed to load entry Size string.\\n\");\n    xref->n_entries = atoi(buf + strlen(\"ize \"));\n    xref->entries = safe_calloc(xref->n_entries * sizeof(struct _xref_entry));\n\n    /* Load entry data */\n    obj_id = 0;\n    fseek(fp, xref->start + strlen(\"xref\"), SEEK_SET);\n    added_entries = 0;\n    for (i=0; i<xref->n_entries; i++)\n    {\n        /* Advance past newlines. */\n        c = fgetc(fp);\n        while (c == '\\n' || c == '\\r')\n          c = fgetc(fp);\n\n        /* Collect data up until the following newline. */\n        buf_idx = 0;\n        while (c != '\\n' && c != '\\r' && !feof(fp) &&\n               !ferror(fp) && buf_idx < sizeof(buf))\n        {\n            buf[buf_idx++] = c;\n            c = fgetc(fp);\n        }\n        if (buf_idx >= sizeof(buf)) {\n            FAIL(\"Failed to locate newline character. \"\n                 \"This might be a corrupt PDF.\\n\");\n        }\n        buf[buf_idx] = '\\0';\n\n        /* Went to far and hit start of trailer */\n        if (strchr(buf, 't'))\n          break;\n\n        /* Entry or object id */\n        if (strlen(buf) > 17)\n        {\n            const char *token = NULL;\n            xref->entries[i].obj_id = obj_id++;\n            token = strtok(buf, \" \");\n            if (!token) {\n              FAIL(\"Failed to parse xref entry. \"\n                   \"This might be a corrupt PDF.\\n\");\n            }\n            xref->entries[i].offset = atol(token);\n            token = strtok(NULL, \" \");\n            if (!token) {\n              FAIL(\"Failed to parse xref entry. \"\n                   \"This might be a corrupt PDF.\\n\");\n            }\n            xref->entries[i].gen_num = atoi(token);\n            xref->entries[i].f_or_n = buf[17];\n            ++added_entries;\n        }\n        else\n        {\n            obj_id = atoi(buf);\n            --i;\n        }\n    }\n\n    xref->n_entries = added_entries;\n    fseek(fp, start, SEEK_SET);\n}\n\n\n/* Load an xref table from a stream (PDF v1.5 +) */\nstatic void load_xref_from_stream(FILE *fp, xref_t *xref)\n{\n    long    start;\n    int     is_stream;\n    char   *stream;\n    size_t  size;\n\n    start = ftell(fp);\n    fseek(fp, xref->start, SEEK_SET);\n\n    stream = NULL;\n    stream = get_object_from_here(fp, &size, &is_stream);\n    fseek(fp, start, SEEK_SET);\n\n    /* TODO: decode and analyize stream */\n    free(stream);\n    return;\n}\n\n\nstatic void get_xref_linear_skipped(FILE *fp, xref_t *xref)\n{\n    int  err;\n    char ch, buf[256];\n\n    if (xref->start != 0)\n      return;\n\n    /* Special case (Linearized PDF with initial startxref at 0) */\n    xref->is_linear = 1;\n\n    /* Seek to %%EOF */\n    if ((xref->end = get_next_eof(fp)) < 0)\n      return;\n\n    /* Locate the trailer */ \n    err = 0; \n    while (!(err = ferror(fp)) && fread(buf, 1, 8, fp))\n    {\n        if (strncmp(buf, \"trailer\", strlen(\"trailer\")) == 0)\n          break;\n        else if ((ftell(fp) - 9) < 0)\n          return;\n\n        fseek(fp, -9, SEEK_CUR);\n    }\n\n    if (err)\n      return;\n\n    /* If we found 'trailer' look backwards for 'xref' */\n    ch = 0;\n    while (SAFE_F(fp, ((ch = fgetc(fp)) != 'x')))\n      fseek(fp, -2, SEEK_CUR);\n\n    if (ch == 'x')\n    {\n        xref->start = ftell(fp) - 1;\n        fseek(fp, -1, SEEK_CUR);\n    }\n\n    /* Now continue to next eof ... */\n    fseek(fp, xref->start, SEEK_SET);\n}\n\n\n/* This must only be called after all xref and entries have been acquired */\nstatic void resolve_linearized_pdf(pdf_t *pdf)\n{\n    int    i;\n    xref_t buf;\n\n    if (pdf->n_xrefs < 2)\n      return;\n\n    if (!pdf->xrefs[0].is_linear)\n      return;\n\n    /* Swap Linear with Version 1 */\n    buf = pdf->xrefs[0];\n    pdf->xrefs[0] = pdf->xrefs[1];\n    pdf->xrefs[1] = buf;\n\n    /* Resolve is_linear flag and version */\n    pdf->xrefs[0].is_linear = 1;\n    pdf->xrefs[0].version = 1;\n    pdf->xrefs[1].is_linear = 0;\n    pdf->xrefs[1].version = 1;\n\n    /* Adjust the other version values now */\n    for (i=2; i<pdf->n_xrefs; ++i)\n      --pdf->xrefs[i].version;\n}\n\n\nstatic pdf_creator_t *new_creator(int *n_elements)\n{\n    pdf_creator_t *daddy;\n\n    static const pdf_creator_t creator_template[] = \n    {\n        {\"Title\",        \"\"},\n        {\"Author\",       \"\"},\n        {\"Subject\",      \"\"},\n        {\"Keywords\",     \"\"},\n        {\"Creator\",      \"\"},\n        {\"Producer\",     \"\"},\n        {\"CreationDate\", \"\"},\n        {\"ModDate\",      \"\"},\n        {\"Trapped\",      \"\"},\n    };\n\n    daddy = safe_calloc(sizeof(creator_template));\n    memcpy(daddy, creator_template, sizeof(creator_template));\n\n    if (n_elements)\n      *n_elements = sizeof(creator_template) / sizeof(creator_template[0]);\n\n    return daddy;\n}\n\n\n#define END_OF_TRAILER(_c, _st, _fp) \\\n{                                    \\\n    if (_c == '>')                   \\\n    {                                \\\n        fseek(_fp, _st, SEEK_SET);   \\\n        continue;                    \\\n    }                                \\\n}\nstatic void load_creator(FILE *fp, pdf_t *pdf)\n{\n    int    i, buf_idx;\n    char   c, *buf, obj_id_buf[32] = {0};\n    long   start;\n    size_t sz;\n\n    start = ftell(fp);\n\n    /* For each PDF version */\n    for (i=0; i<pdf->n_xrefs; ++i)\n    {\n        if (!pdf->xrefs[i].version)\n          continue;\n\n        /* Find trailer */\n        fseek(fp, pdf->xrefs[i].start, SEEK_SET);\n        while (SAFE_F(fp, (fgetc(fp) != 't')))\n            ; /* Iterate to \"trailer\" */\n\n        /* Look for \"<< ....... /Info ......\" */\n        c = '\\0';\n        while (SAFE_F(fp, ((c = fgetc(fp)) != '>')))\n          if (SAFE_F(fp, ((c == '/') &&\n                          (fgetc(fp) == 'I') && ((fgetc(fp) == 'n')))))\n            break;\n\n        /* Could not find /Info in trailer */\n        END_OF_TRAILER(c, start, fp);\n\n        while (SAFE_F(fp, (!isspace(c = fgetc(fp)) && (c != '>'))))\n            ; /* Iterate to first white space /Info<space><data> */\n\n        /* No space between /Info and its data */\n        END_OF_TRAILER(c, start, fp);\n\n        while (SAFE_F(fp, (isspace(c = fgetc(fp)) && (c != '>'))))\n            ; /* Iterate right on top of first non-whitespace /Info data */\n\n        /* No data for /Info */\n        END_OF_TRAILER(c, start, fp);\n\n        /* Get obj id as number */\n        buf_idx = 0;\n        obj_id_buf[buf_idx++] = c;\n        while ((buf_idx < (sizeof(obj_id_buf) - 1)) &&\n               SAFE_F(fp, (!isspace(c = fgetc(fp)) && (c != '>'))))\n          obj_id_buf[buf_idx++] = c;\n\n        END_OF_TRAILER(c, start, fp);\n     \n        /* Get the object for the creator data.  If linear, try both xrefs */ \n        buf = get_object(fp, atoll(obj_id_buf), &pdf->xrefs[i], &sz, NULL);\n        if (!buf && pdf->xrefs[i].is_linear && (i+1 < pdf->n_xrefs))\n          buf = get_object(fp, atoll(obj_id_buf), &pdf->xrefs[i+1], &sz, NULL);\n\n        load_creator_from_buf(fp, &pdf->xrefs[i], buf, sz);\n        free(buf);\n    }\n\n    fseek(fp, start, SEEK_SET);\n}\n\n\nstatic void load_creator_from_buf(\n    FILE       *fp,\n    xref_t     *xref,\n    const char *buf,\n    size_t      buf_size)\n{\n    int   is_xml;\n    char *c;\n\n    if (!buf)\n      return;\n\n    /* Check to see if this is xml or old-school */\n    if ((c = strstr(buf, \"/Type\")))\n      while (*c && !isspace(*c))\n        ++c;\n\n    /* Probably \"Metadata\" */\n    is_xml = 0;\n    if (c && (*c == 'M'))\n      is_xml = 1;\n\n    /* Is the buffer XML(PDF 1.4+) or old format? */\n    if (is_xml)\n      load_creator_from_xml(xref, buf);\n    else\n      load_creator_from_old_format(fp, xref, buf, buf_size);\n}\n\n\nstatic void load_creator_from_xml(xref_t *xref, const char *buf)\n{\n    /* TODO */\n}\n\n\nstatic void load_creator_from_old_format(\n    FILE       *fp,\n    xref_t     *xref,\n    const char *buf,\n    size_t      buf_size)\n{\n    int            i, n_eles, length, is_escaped, obj_id;\n    char          *c, *ascii, *start, *s, *saved_buf_search, *obj;\n    size_t         obj_size;\n    pdf_creator_t *info;\n\n    info = new_creator(&n_eles);\n\n    /* Mark the end of buf, so that we do not crawl past it */\n    if (buf_size < 1) return;\n    const char *buf_end = buf + buf_size - 1;\n\n    /* Treat 'end' as either the end of 'buf' or the end of 'obj'.  Obj is if\n     * the creator element (e.g., ModDate, Producer, etc) is an object and not\n     * part of 'buf'.\n     */\n    const char *end = buf_end;\n\n    for (i=0; i<n_eles; ++i)\n    {\n        if (!(c = strstr(buf, info[i].key)))\n          continue;\n\n        /* Find the value (skipping whitespace) */\n        c += strlen(info[i].key);\n        while (isspace(*c))\n          ++c;\n        if (c >= buf_end) {\n          FAIL(\"Failed to locate space, likely a corrupt PDF.\");\n        }\n\n        /* If looking at the start of a pdf token, we have gone too far */\n        if (*c == '/')\n          continue;\n\n        /* If the value is a number and not a '(' then the data is located in\n         * an object we need to fetch, and not inline\n         */\n        obj = saved_buf_search = NULL;\n        obj_size = 0;\n        end = buf_end; /* Init to be the buffer, this might not be an obj. */\n        if (isdigit(*c))\n        {\n            obj_id = atoi(c);\n            saved_buf_search = c;\n            s = saved_buf_search;\n\n            obj = get_object(fp, obj_id, xref, &obj_size, NULL);\n            end = obj + obj_size;\n            c = obj;\n\n            /* Iterate to '(' */\n            while (c && (*c != '(') && (c < end))\n              ++c;\n            if (c >= end)  {\n              FAIL(\"Failed to locate a '(' character. \"\n                  \"This might be a corrupt PDF.\\n\");\n            }\n\n            /* Advance the search to the next token */\n            while (s && (*s == '/') && (s < buf_end))\n              ++s;\n            if (s >= buf_end)  {\n              FAIL(\"Failed to locate a '/' character. \"\n                  \"This might be a corrupt PDF.\\n\");\n            }\n            saved_buf_search = s;\n        }\n          \n        /* Find the end of the value */\n        start = c;\n        length = is_escaped = 0;\n        while (c && ((*c != '\\r') && (*c != '\\n') && (*c != '<')))\n        {\n            /* Bail out if we see an un-escaped ')' closing character */\n            if (!is_escaped && (*c == ')'))\n              break;\n            else if (*c == '\\\\')\n              is_escaped = 1;\n            else\n              is_escaped = 0;\n            ++c;\n            ++length;\n            if (c > end) {\n              FAIL(\"Failed to locate the end of a value. \"\n                   \"This might be a corrupt PDF.\\n\");\n            }\n        }\n\n        if (length == 0)\n          continue;\n\n        /* Add 1 to length so it gets the closing ')' when we copy */\n        if (length)\n          length += 1;\n        length = (length > KV_MAX_VALUE_LENGTH) ? KV_MAX_VALUE_LENGTH : length;\n        strncpy(info[i].value, start, length);\n        info[i].value[KV_MAX_VALUE_LENGTH - 1] = '\\0';\n\n        /* Restore where we were searching from */\n        if (saved_buf_search)\n        {\n            /* Release memory from get_object() called earlier */\n            free(obj);\n            c = saved_buf_search;\n        }\n    } /* For all creation information tags */\n\n    /* Go through the values and convert if encoded */\n    for (i = 0; i < n_eles; ++i) {\n      const size_t val_str_len = strnlen(info[i].value, KV_MAX_VALUE_LENGTH);\n      if ((ascii = decode_text_string(info[i].value, val_str_len))) {\n        strncpy(info[i].value, ascii, val_str_len);\n        free(ascii);\n      }\n    }\n\n    xref->creator = info;\n    xref->n_creator_entries = n_eles;\n}\n\n\n/* Returns object data at the start of the file pointer\n * This interfaces to 'get_object'\n */\nstatic char *get_object_from_here(FILE *fp, size_t *size, int *is_stream)\n{\n    long         start;\n    char         buf[256];\n    int          obj_id;\n    xref_t       xref;\n    xref_entry_t entry;\n\n    start = ftell(fp);\n\n    /* Object ID */\n    memset(buf, 0, 256);\n    SAFE_E(fread(buf, 1, 255, fp), 255, \"Failed to load object ID.\\n\");\n    if (!(obj_id = atoi(buf)))\n    {\n        fseek(fp, start, SEEK_SET);\n        return NULL;\n    }\n    \n    /* Create xref entry to pass to the get_object routine */\n    memset(&entry, 0, sizeof(xref_entry_t));\n    entry.obj_id = obj_id;\n    entry.offset = start;\n\n    /* Xref and single entry for the object we want data from */\n    memset(&xref, 0, sizeof(xref_t));\n    xref.n_entries = 1;\n    xref.entries = &entry;\n\n    fseek(fp, start, SEEK_SET);\n    return get_object(fp, obj_id, &xref, size, is_stream);\n}\n\n\nstatic char *get_object(\n    FILE         *fp,\n    int           obj_id,\n    const xref_t *xref,\n    size_t       *size,\n    int          *is_stream)\n{\n    static const int    blk_sz = 256;\n    int                 i, total_sz, read_sz, n_blks, search, stream;\n    size_t              obj_sz;\n    char               *c, *data;\n    long                start;\n    const xref_entry_t *entry;\n\n    if (size)\n      *size = 0;\n\n    if (is_stream)\n      *is_stream = 0;\n\n    start = ftell(fp);\n\n    /* Find object */\n    entry = NULL;\n    for (i=0; i<xref->n_entries; i++)\n      if (xref->entries[i].obj_id == obj_id)\n      {\n          entry = &xref->entries[i];\n          break;\n      }\n\n    if (!entry)\n      return NULL;\n\n    /* Jump to object start */\n    fseek(fp, entry->offset, SEEK_SET);\n\n    /* Initial allocation */\n    obj_sz = 0;    /* Bytes in object */\n    total_sz = 0;  /* Bytes read in   */\n    n_blks = 1;\n    data = safe_calloc(blk_sz * n_blks);\n\n    /* Suck in data */\n    stream = 0;\n    while ((read_sz = fread(data+total_sz, 1, blk_sz-1, fp)) && !ferror(fp))\n    {\n        total_sz += read_sz;\n\n        *(data + total_sz) = '\\0';\n\n        if (total_sz + blk_sz >= (blk_sz * n_blks))\n          data = realloc(data, blk_sz * (++n_blks));\n        if (!data) {\n          ERR(\"Failed to reallocate buffer.\\n\");\n          exit(EXIT_FAILURE);\n        }\n\n        search = total_sz - read_sz;\n        if (search < 0)\n          search = 0;\n\n        if ((c = strstr(data + search, \"endobj\")))\n        {\n            *(c + strlen(\"endobj\") + 1) = '\\0';\n            obj_sz = (char *)strstr(data + search, \"endobj\") - (char *)data;\n            obj_sz += strlen(\"endobj\") + 1;\n            break;\n        }\n        else if (strstr(data, \"stream\"))\n          stream = 1;\n    }\n\n    clearerr(fp);\n    fseek(fp, start, SEEK_SET);\n\n    if (size) {\n      *size = obj_sz;\n      if (!obj_sz && data) {\n        free(data);\n        data = NULL;\n      }\n    }\n            \n    if (is_stream)\n      *is_stream = stream;\n\n    return data;\n}\n\n\nstatic const char *get_type(FILE *fp, int obj_id, const xref_t *xref)\n{\n    int          is_stream;\n    char        *c, *obj, *endobj;\n    static char  buf[32];\n    long         start;\n\n    start = ftell(fp);\n\n    if (!(obj = get_object(fp, obj_id, xref, NULL, &is_stream)) || \n        is_stream                                               ||\n        !(endobj = strstr(obj, \"endobj\")))\n    {\n        free(obj);\n        fseek(fp, start, SEEK_SET);\n\n        if (is_stream)\n          return \"Stream\";\n        else\n          return \"Unknown\";\n    }\n\n    /* Get the Type value (avoiding font names like Type1) */\n    c = obj;\n    while ((c = strstr(c, \"/Type\")) && (c < endobj))\n      if (isdigit(*(c + strlen(\"/Type\"))))\n      {\n          ++c;\n          continue;\n      }\n      else\n        break;\n\n    if (!c || (c && (c > endobj)))\n    {\n        free(obj);\n        fseek(fp, start, SEEK_SET);\n        return \"Unknown\";\n    }\n\n    /* Skip to first blank/whitespace */\n    c += strlen(\"/Type\");\n    while (isspace(*c) || *c == '/')\n      ++c;\n\n    /* 'c' should be pointing to the type name.  Find the end of the name. */\n    size_t n_chars = 0;\n    const char *name_itr = c;\n    while ((name_itr < endobj) &&\n           !(isspace(*name_itr) || *name_itr == '/' || *name_itr == '>')) {\n        ++name_itr;\n        ++n_chars;\n    }\n    if (n_chars >= sizeof(buf))\n    {\n        free(obj);\n        fseek(fp, start, SEEK_SET);\n        return \"Unknown\";\n    }\n\n    /* Return the value by storing it in static mem. */\n    memcpy(buf, c, n_chars);\n    buf[n_chars] = '\\0';\n    free(obj);\n    fseek(fp, start, SEEK_SET);\n    return buf;\n}\n\n\nstatic char *get_header(FILE *fp)\n{\n    /* First 1024 bytes of doc must be header (1.7 spec pg 1102) */\n    char *header = safe_calloc(1024);\n    long start = ftell(fp);\n    fseek(fp, 0, SEEK_SET);\n    SAFE_E(fread(header, 1, 1023, fp), 1023, \"Failed to load PDF header.\\n\");\n    fseek(fp, start, SEEK_SET);\n    return header;\n}\n\n\nstatic char *decode_text_string(const char *str, size_t str_len)\n{\n    int   idx, is_hex, is_utf16be, ascii_idx;\n    char *ascii, hex_buf[5] = {0};\n\n    is_hex = is_utf16be = idx = ascii_idx = 0;\n\n    /* Regular encoding */\n    if (str[0] == '(')\n    {\n        ascii = safe_calloc(str_len + 1);\n        strncpy(ascii, str, str_len + 1);\n        return ascii;\n    }\n    else if (str[0] == '<')\n    {\n        is_hex = 1;\n        ++idx;\n    }\n    \n    /* Text strings can be either PDFDocEncoding or UTF-16BE */\n    if (is_hex && (str_len > 5) && \n        (str[idx] == 'F') && (str[idx+1] == 'E') &&\n        (str[idx+2] == 'F') && (str[idx+3] == 'F'))\n    {\n        is_utf16be = 1;\n        idx += 4;\n    }\n    else\n      return NULL;\n\n    /* Now decode as hex */\n    ascii = safe_calloc(str_len);\n    for ( ; idx<str_len; ++idx)\n    {\n        hex_buf[0] = str[idx++];\n        hex_buf[1] = str[idx++];\n        hex_buf[2] = str[idx++];\n        hex_buf[3] = str[idx];\n        ascii[ascii_idx++] = strtol(hex_buf, NULL, 16);\n    }\n\n    return ascii;\n}\n\n\n/* Return the offset to the beginning of the %%EOF string.\n * A negative value is returned when done scanning.\n */\nstatic int get_next_eof(FILE *fp)\n{\n    int match, c;\n    const char buf[] = \"%%EOF\";\n\n    match = 0;\n    while ((c = fgetc(fp)) != EOF)\n    {\n        if (c == buf[match])\n          ++match;\n        else\n          match = 0;\n\n        if (match == 5) /* strlen(\"%%EOF\") */\n          return ftell(fp) - 5;\n    }\n\n    return -1;\n}\n"], "filenames": ["AUTHORS", "pdf.c"], "buggy_code_start_loc": [26, 179], "buggy_code_end_loc": [26, 203], "fixing_code_start_loc": [27, 178], "fixing_code_end_loc": [29, 203], "type": "CWE-787", "message": "PDFResurrect before 0.20 lack of header validation checks causes heap-buffer-overflow in pdf_get_version().", "other": {"cve": {"id": "CVE-2020-20740", "sourceIdentifier": "cve@mitre.org", "published": "2020-11-20T19:15:11.803", "lastModified": "2022-01-01T18:10:03.300", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PDFResurrect before 0.20 lack of header validation checks causes heap-buffer-overflow in pdf_get_version()."}, {"lang": "es", "value": "PDFResurrect versiones anteriores a  0,20, una falta de comprobaciones de la validaci\u00f3n del encabezado causa un desbordamiento del b\u00fafer en la regi\u00f3n heap de la memoria en la funci\u00f3n pdf_get_version()"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pdfresurrect_project:pdfresurrect:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.20", "matchCriteriaId": "9CD7B045-978E-465D-89A2-2E386D9F556E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}]}]}], "references": [{"url": "https://github.com/enferex/pdfresurrect/commit/1b422459f07353adce2878806d5247d9e91fb397", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/enferex/pdfresurrect/issues/14", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/12/msg00002.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/JMEEEPBBGER5LPABBRVZLMCC6Z24RBXW/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZOIEVFM3SIMAEOFJKKMYH2TLZ7PXLSUD/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/enferex/pdfresurrect/commit/1b422459f07353adce2878806d5247d9e91fb397"}}