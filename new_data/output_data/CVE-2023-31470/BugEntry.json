{"buggy_code": ["/*************************************************************************\n *\n * Copyright (C) 2018-2023 Ruilin Peng (Nick) <pymumu@gmail.com>.\n *\n * smartdns is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * smartdns is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#define _GNU_SOURCE\n#include \"dns.h\"\n#include \"stringutil.h\"\n#include \"tlog.h\"\n#include <arpa/inet.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define QR_MASK 0x8000\n#define OPCODE_MASK 0x7800\n#define AA_MASK 0x0400\n#define TC_MASK 0x0200\n#define RD_MASK 0x0100\n#define RA_MASK 0x0080\n#define RCODE_MASK 0x000F\n#define DNS_RR_END (0XFFFF)\n\n#define UNUSED(expr)                                                                                                   \\\n\tdo {                                                                                                               \\\n\t\t(void)(expr);                                                                                                  \\\n\t} while (0)\n\n#define member_size(type, member) sizeof(((type *)0)->member)\n\n/* read short and move pointer */\nstatic unsigned short _dns_read_short(unsigned char **buffer)\n{\n\tunsigned short value = 0;\n\n\tvalue = ntohs(*((unsigned short *)(*buffer)));\n\t*buffer += 2;\n\treturn value;\n}\n\n/* write char and move pointer */\nstatic __attribute__((unused)) void _dns_write_char(unsigned char **buffer, unsigned char value)\n{\n\t**buffer = value;\n\t*buffer += 1;\n}\n\n/* read char and move pointer */\nstatic unsigned char _dns_read_char(unsigned char **buffer)\n{\n\tunsigned char value = **buffer;\n\t*buffer += 1;\n\treturn value;\n}\n\n/* write short and move pointer */\nstatic void _dns_write_short(unsigned char **buffer, unsigned short value)\n{\n\tvalue = htons(value);\n\t*((unsigned short *)(*buffer)) = value;\n\t*buffer += 2;\n}\n\n/* write int and move pointer */\nstatic void _dns_write_int(unsigned char **buffer, unsigned int value)\n{\n\tvalue = htonl(value);\n\t*((unsigned int *)(*buffer)) = value;\n\t*buffer += 4;\n}\n\n/* read int and move pointer */\nstatic unsigned int _dns_read_int(unsigned char **buffer)\n{\n\tunsigned int value = 0;\n\n\tvalue = ntohl(*((unsigned int *)(*buffer)));\n\t*buffer += 4;\n\n\treturn value;\n}\n\nstatic inline int _dns_left_len(struct dns_context *context)\n{\n\treturn context->maxsize - (context->ptr - context->data);\n}\n\nstatic int _dns_get_domain_from_packet(unsigned char *packet, int packet_size, unsigned char **domain_ptr, char *output,\n\t\t\t\t\t\t\t\t\t   int size)\n{\n\tint output_len = 0;\n\tint copy_len = 0;\n\tint len = 0;\n\tunsigned char *ptr = *domain_ptr;\n\tint is_compressed = 0;\n\tint ptr_jump = 0;\n\n\t/*[len]string[len]string...[0]0 */\n\twhile (1) {\n\t\tif (ptr >= packet + packet_size || ptr < packet || output_len >= size - 1 || ptr_jump > 32) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen = *ptr;\n\t\tif (len == 0) {\n\t\t\t*output = 0;\n\t\t\tptr++;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* compressed domain */\n\t\tif (len >= 0xC0) {\n\t\t\tif ((ptr + 2) > (packet + packet_size)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/*\n\t\t\t0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n\t\t\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t\t\t| 1  1|                OFFSET                   |\n\t\t\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t\t\t*/\n\t\t\t/* read offset */\n\t\t\tlen = _dns_read_short(&ptr) & 0x3FFF;\n\t\t\tif (is_compressed == 0) {\n\t\t\t\t*domain_ptr = ptr;\n\t\t\t}\n\n\t\t\tptr = packet + len;\n\t\t\tif (ptr > packet + packet_size) {\n\t\t\t\ttlog(TLOG_DEBUG, \"length is not enough %u:%ld, %p, %p\", packet_size, (long)(ptr - packet), *domain_ptr,\n\t\t\t\t\t packet);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tis_compressed = 1;\n\t\t\tptr_jump++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tptr_jump = 0;\n\n\t\t/* change [len] to '.' */\n\t\tif (output_len > 0) {\n\t\t\t*output = '.';\n\t\t\toutput++;\n\t\t\toutput_len += 1;\n\t\t}\n\n\t\tif (ptr > packet + packet_size) {\n\t\t\ttlog(TLOG_DEBUG, \"length is not enough %u:%ld, %p, %p\", packet_size, (long)(ptr - packet), *domain_ptr,\n\t\t\t\t packet);\n\t\t\treturn -1;\n\t\t}\n\n\t\tptr++;\n\t\tif (output_len < size - 1) {\n\t\t\t/* copy sub string */\n\t\t\tcopy_len = (len < size - output_len) ? len : size - 1 - output_len;\n\t\t\tif ((ptr + copy_len) > (packet + packet_size)) {\n\t\t\t\ttlog(TLOG_DEBUG, \"length is not enough %u:%ld, %p, %p\", packet_size, (long)(ptr - packet), *domain_ptr,\n\t\t\t\t\t packet);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmemcpy(output, ptr, copy_len);\n\t\t}\n\n\t\tptr += len;\n\t\toutput += len;\n\t\toutput_len += len;\n\t}\n\n\tif (is_compressed == 0) {\n\t\t*domain_ptr = ptr;\n\t}\n\n\treturn 0;\n}\n\nstatic int _dns_decode_domain(struct dns_context *context, char *output, int size)\n{\n\treturn _dns_get_domain_from_packet(context->data, context->maxsize, &(context->ptr), output, size);\n}\n\nstatic unsigned int dict_hash(const char *s)\n{\n\tunsigned int hashval = 0;\n\tfor (hashval = 0; *s != '\\0'; s++) {\n\t\thashval = *s + 31 * hashval;\n\t}\n\treturn hashval;\n}\n\nstatic int _dns_add_domain_dict(struct dns_context *context, unsigned int hash, int pos)\n{\n\tstruct dns_packet_dict *dict = context->namedict;\n\n\tif (dict->dict_count >= DNS_PACKET_DICT_SIZE) {\n\t\treturn -1;\n\t}\n\n\tif (hash == 0) {\n\t\treturn -1;\n\t}\n\n\tif (pos >= context->maxsize) {\n\t\treturn -1;\n\t}\n\n\tint index = dict->dict_count;\n\tdict->names[index].hash = hash;\n\tdict->names[index].pos = pos;\n\tdict->dict_count++;\n\n\treturn 0;\n}\n\nstatic int _dns_get_domain_offset(struct dns_context *context, const char *domain)\n{\n\tint i = 0;\n\n\tchar domain_check[DNS_MAX_CNAME_LEN];\n\tstruct dns_packet_dict *dict = context->namedict;\n\n\tif (*domain == '\\0') {\n\t\treturn -1;\n\t}\n\n\tunsigned int hash = dict_hash(domain);\n\tfor (i = 0; i < dict->dict_count; i++) {\n\t\tif (dict->names[i].hash != hash) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tunsigned char *domain_check_ptr = dict->names[i].pos + context->data;\n\t\tif (_dns_get_domain_from_packet(context->data, context->maxsize, &domain_check_ptr, domain_check,\n\t\t\t\t\t\t\t\t\t\tDNS_MAX_CNAME_LEN) != 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn dict->names[i].pos;\n\t}\n\n\t_dns_add_domain_dict(context, hash, context->ptr - 1 - context->data);\n\treturn -1;\n}\n\nstatic int _dns_encode_domain(struct dns_context *context, const char *domain)\n{\n\tint num = 0;\n\tint total_len = 0;\n\tunsigned char *ptr_num = context->ptr++;\n\tint dict_offset = 0;\n\n\tdict_offset = _dns_get_domain_offset(context, domain);\n\ttotal_len++;\n\n\t/*[len]string[len]string...[0]0 */\n\twhile (_dns_left_len(context) > 1 && *domain != 0) {\n\t\ttotal_len++;\n\t\tif (dict_offset >= 0) {\n\t\t\tint offset = 0xc000 | dict_offset;\n\t\t\t_dns_write_short(&ptr_num, offset);\n\t\t\tcontext->ptr++;\n\t\t\tptr_num = NULL;\n\t\t\treturn total_len;\n\t\t}\n\n\t\tif (*domain == '.') {\n\t\t\t*ptr_num = num;\n\t\t\tnum = 0;\n\t\t\tptr_num = context->ptr;\n\t\t\tdomain++;\n\t\t\tcontext->ptr++;\n\t\t\tdict_offset = _dns_get_domain_offset(context, domain);\n\t\t\tcontinue;\n\t\t}\n\t\t*context->ptr = *domain;\n\t\tnum++;\n\t\tcontext->ptr++;\n\t\tdomain++;\n\t}\n\n\t*ptr_num = num;\n\n\tif (total_len > 1) {\n\t\t/* if domain is '\\0', [domain] is '\\0' */\n\t\t*(context->ptr) = 0;\n\t\ttotal_len++;\n\t\tcontext->ptr++;\n\t}\n\n\tif (_dns_left_len(context) <= 0) {\n\t\treturn -1;\n\t}\n\n\treturn total_len;\n}\n\n/* iterator get rrs begin */\nstruct dns_rrs *dns_get_rrs_start(struct dns_packet *packet, dns_rr_type type, int *count)\n{\n\tunsigned short start = 0;\n\tstruct dns_head *head = &packet->head;\n\n\t/* get rrs count by rrs type */\n\tswitch (type) {\n\tcase DNS_RRS_QD:\n\t\t*count = head->qdcount;\n\t\tstart = packet->questions;\n\t\tbreak;\n\tcase DNS_RRS_AN:\n\t\t*count = head->ancount;\n\t\tstart = packet->answers;\n\t\tbreak;\n\tcase DNS_RRS_NS:\n\t\t*count = head->nscount;\n\t\tstart = packet->nameservers;\n\t\tbreak;\n\tcase DNS_RRS_NR:\n\t\t*count = head->nrcount;\n\t\tstart = packet->additional;\n\t\tbreak;\n\tcase DNS_RRS_OPT:\n\t\t*count = packet->optcount;\n\t\tstart = packet->optional;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t\tbreak;\n\t}\n\n\t/* if not resource record, return null */\n\tif (start == DNS_RR_END) {\n\t\treturn NULL;\n\t}\n\n\t/* return rrs data start address */\n\treturn (struct dns_rrs *)(packet->data + start);\n}\n\n/* iterator next rrs */\nstruct dns_rrs *dns_get_rrs_next(struct dns_packet *packet, struct dns_rrs *rrs)\n{\n\tif (rrs->next == DNS_RR_END) {\n\t\treturn NULL;\n\t}\n\n\treturn (struct dns_rrs *)(packet->data + rrs->next);\n}\n\nstatic void _dns_init_context_by_rrs(struct dns_rrs *rrs, struct dns_context *context)\n{\n\tcontext->packet = rrs->packet;\n\tcontext->data = rrs->packet->data;\n\tcontext->ptr = rrs->data;\n\tcontext->namedict = &rrs->packet->namedict;\n\tcontext->maxsize = rrs->data - rrs->packet->data + rrs->len;\n}\n\n/* iterator add rrs begin */\nstatic int _dns_add_rrs_start(struct dns_packet *packet, struct dns_context *context)\n{\n\tstruct dns_rrs *rrs = NULL;\n\tunsigned char *end = packet->data + packet->len;\n\n\tif ((packet->len + (int)sizeof(*rrs)) >= packet->size) {\n\t\treturn -1;\n\t}\n\trrs = (struct dns_rrs *)end;\n\n\tcontext->ptr = rrs->data;\n\tcontext->packet = packet;\n\tcontext->maxsize = packet->size - sizeof(*packet);\n\tcontext->data = packet->data;\n\tcontext->namedict = &packet->namedict;\n\n\treturn 0;\n}\n\n/* iterator add rrs end */\nstatic int _dns_rr_add_end(struct dns_packet *packet, int type, dns_type_t rtype, int len)\n{\n\tstruct dns_rrs *rrs = NULL;\n\tstruct dns_rrs *rrs_next = NULL;\n\tstruct dns_head *head = &packet->head;\n\tunsigned char *end = packet->data + packet->len;\n\tunsigned short *count = NULL;\n\tunsigned short *start = NULL;\n\n\trrs = (struct dns_rrs *)end;\n\tif (packet->len + len > packet->size - (int)sizeof(*packet) - (int)sizeof(*rrs)) {\n\t\treturn -1;\n\t}\n\n\tswitch (type) {\n\tcase DNS_RRS_QD:\n\t\tcount = &head->qdcount;\n\t\tstart = &packet->questions;\n\t\tbreak;\n\tcase DNS_RRS_AN:\n\t\tcount = &head->ancount;\n\t\tstart = &packet->answers;\n\t\tbreak;\n\tcase DNS_RRS_NS:\n\t\tcount = &head->nscount;\n\t\tstart = &packet->nameservers;\n\t\tbreak;\n\tcase DNS_RRS_NR:\n\t\tcount = &head->nrcount;\n\t\tstart = &packet->additional;\n\t\tbreak;\n\tcase DNS_RRS_OPT:\n\t\tcount = &packet->optcount;\n\t\tstart = &packet->optional;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t\tbreak;\n\t}\n\n\t/* add data to end of dns_packet, and set previous rrs point to this rrs */\n\tif (*start != DNS_RR_END) {\n\t\trrs_next = (struct dns_rrs *)(packet->data + *start);\n\t\twhile (rrs_next->next != DNS_RR_END) {\n\t\t\trrs_next = (struct dns_rrs *)(packet->data + rrs_next->next);\n\t\t}\n\t\trrs_next->next = packet->len;\n\t} else {\n\t\t*start = packet->len;\n\t}\n\n\t/* update rrs head info */\n\trrs->packet = packet;\n\trrs->len = len;\n\trrs->type = rtype;\n\trrs->next = DNS_RR_END;\n\n\t/* update total data length */\n\t*count += 1;\n\tpacket->len += len + sizeof(*rrs);\n\treturn 0;\n}\n\nstatic int _dns_add_qr_head(struct dns_context *context, const char *domain, int qtype, int qclass)\n{\n\tint ret = _dns_encode_domain(context, domain);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tif (_dns_left_len(context) < 4) {\n\t\treturn -1;\n\t}\n\n\t_dns_write_short(&context->ptr, qtype);\n\t_dns_write_short(&context->ptr, qclass);\n\n\treturn ret + 4;\n}\n\nstatic int _dns_get_qr_head(struct dns_context *context, char *domain, int maxsize, int *qtype, int *qclass)\n{\n\tint ret = 0;\n\n\tif (domain == NULL || context == NULL) {\n\t\treturn -1;\n\t}\n\n\tret = _dns_decode_domain(context, domain, maxsize);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tif (_dns_left_len(context) < 4) {\n\t\treturn -1;\n\t}\n\n\t*qtype = _dns_read_short(&context->ptr);\n\t*qclass = _dns_read_short(&context->ptr);\n\n\treturn 0;\n}\n\nstatic int _dns_add_rr_head(struct dns_context *context, const char *domain, int qtype, int qclass, int ttl, int rr_len)\n{\n\tint len = 0;\n\n\t/* resource record head */\n\t/* |domain          |\n\t * |qtype  | qclass |\n\t * |       ttl      |\n\t * | rrlen | rrdata |\n\t */\n\tlen = _dns_add_qr_head(context, domain, qtype, qclass);\n\tif (len < 0) {\n\t\treturn -1;\n\t}\n\n\tif (_dns_left_len(context) < 6) {\n\t\treturn -1;\n\t}\n\n\t_dns_write_int(&context->ptr, ttl);\n\t_dns_write_short(&context->ptr, rr_len);\n\n\treturn len + 6;\n}\n\nstatic int _dns_get_rr_head(struct dns_context *context, char *domain, int maxsize, int *qtype, int *qclass, int *ttl,\n\t\t\t\t\t\t\tint *rr_len)\n{\n\tint len = 0;\n\n\t/* resource record head */\n\t/* |domain          |\n\t * |qtype  | qclass |\n\t * |       ttl      |\n\t * | rrlen | rrdata |\n\t */\n\tlen = _dns_get_qr_head(context, domain, maxsize, qtype, qclass);\n\n\tif (_dns_left_len(context) < 6) {\n\t\treturn -1;\n\t}\n\n\t*ttl = _dns_read_int(&context->ptr);\n\t*rr_len = _dns_read_short(&context->ptr);\n\n\treturn len;\n}\n\nstruct dns_rr_nested *dns_add_rr_nested_start(struct dns_rr_nested *rr_nested_buffer, struct dns_packet *packet,\n\t\t\t\t\t\t\t\t\t\t\t  dns_rr_type type, dns_type_t rtype, const char *domain, int ttl)\n{\n\tint len = 0;\n\tmemset(rr_nested_buffer, 0, sizeof(*rr_nested_buffer));\n\trr_nested_buffer->type = type;\n\tint ret = 0;\n\n\t/* resource record */\n\t/* |domain          |\n\t * |qtype  | qclass |\n\t * |       ttl      |\n\t * | rrlen | rrdata |\n\t */\n\tret = _dns_add_rrs_start(packet, &rr_nested_buffer->context);\n\tif (ret < 0) {\n\t\treturn NULL;\n\t}\n\trr_nested_buffer->rr_start = rr_nested_buffer->context.ptr;\n\n\t/* add rr head */\n\tlen = _dns_add_rr_head(&rr_nested_buffer->context, domain, rtype, DNS_C_IN, ttl, 0);\n\tif (len < 0) {\n\t\treturn NULL;\n\t}\n\trr_nested_buffer->rr_len_ptr = rr_nested_buffer->context.ptr - 2;\n\trr_nested_buffer->rr_head_len = len;\n\n\treturn rr_nested_buffer;\n}\n\nint dns_add_rr_nested_memcpy(struct dns_rr_nested *rr_nested, void *data, int data_len)\n{\n\tif (rr_nested == NULL || data == NULL || data_len <= 0) {\n\t\treturn -1;\n\t}\n\n\tif (_dns_left_len(&rr_nested->context) < data_len) {\n\t\treturn -1;\n\t}\n\n\tmemcpy(rr_nested->context.ptr, data, data_len);\n\trr_nested->context.ptr += data_len;\n\n\treturn 0;\n}\n\nint dns_add_rr_nested_end(struct dns_rr_nested *rr_nested, dns_type_t rtype)\n{\n\tif (rr_nested == NULL || rr_nested->rr_start == NULL) {\n\t\treturn -1;\n\t}\n\n\tint len = rr_nested->context.ptr - rr_nested->rr_start;\n\tunsigned char *ptr = rr_nested->rr_len_ptr;\n\tif (ptr == NULL || _dns_left_len(&rr_nested->context) < 2) {\n\t\treturn -1;\n\t}\n\n\t_dns_write_short(&ptr, len - rr_nested->rr_head_len);\n\n\treturn _dns_rr_add_end(rr_nested->context.packet, rr_nested->type, rtype, len);\n}\n\nvoid *dns_get_rr_nested_start(struct dns_rrs *rrs, char *domain, int maxsize, int *qtype, int *ttl, int *rr_len)\n{\n\tstruct dns_context data_context;\n\tint qclass = 0;\n\tint ret = 0;\n\n\t_dns_init_context_by_rrs(rrs, &data_context);\n\tret = _dns_get_rr_head(&data_context, domain, DNS_MAX_CNAME_LEN, qtype, &qclass, ttl, rr_len);\n\tif (ret < 0) {\n\t\treturn NULL;\n\t}\n\n\tif (qclass != DNS_C_IN) {\n\t\treturn NULL;\n\t}\n\n\tif (*rr_len < 2) {\n\t\treturn NULL;\n\t}\n\n\treturn data_context.ptr;\n}\n\nvoid *dns_get_rr_nested_next(struct dns_rrs *rrs, void *rr_nested, int rr_nested_len)\n{\n\tvoid *end = rrs->data + rrs->len;\n\tvoid *p = rr_nested + rr_nested_len;\n\tif (p == end) {\n\t\treturn NULL;\n\t} else if (p > end) {\n\t\treturn NULL;\n\t}\n\n\treturn p;\n}\n\nstatic int _dns_add_RAW(struct dns_packet *packet, dns_rr_type rrtype, dns_type_t rtype, const char *domain, int ttl,\n\t\t\t\t\t\tconst void *raw, int raw_len)\n{\n\tint len = 0;\n\tstruct dns_context context;\n\tint ret = 0;\n\n\tif (raw_len < 0) {\n\t\treturn -1;\n\t}\n\n\t/* resource record */\n\t/* |domain          |\n\t * |qtype  | qclass |\n\t * |       ttl      |\n\t * | rrlen | rrdata |\n\t */\n\tret = _dns_add_rrs_start(packet, &context);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\t/* add rr head */\n\tlen = _dns_add_rr_head(&context, domain, rtype, DNS_C_IN, ttl, raw_len);\n\tif (len < 0) {\n\t\treturn -1;\n\t}\n\n\tif (_dns_left_len(&context) < raw_len) {\n\t\treturn -1;\n\t}\n\n\t/* add rr data */\n\tmemcpy(context.ptr, raw, raw_len);\n\tcontext.ptr += raw_len;\n\tlen += raw_len;\n\n\treturn _dns_rr_add_end(packet, rrtype, rtype, len);\n}\n\nstatic int _dns_get_RAW(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl, void *raw, int *raw_len)\n{\n\tint qtype = 0;\n\tint qclass = 0;\n\tint rr_len = 0;\n\tint ret = 0;\n\tstruct dns_context context;\n\n\t/* resource record head */\n\t/* |domain          |\n\t * |qtype  | qclass |\n\t * |       ttl      |\n\t * | rrlen | rrdata |\n\t */\n\t_dns_init_context_by_rrs(rrs, &context);\n\n\t/* get rr head */\n\tret = _dns_get_rr_head(&context, domain, maxsize, &qtype, &qclass, ttl, &rr_len);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tif (qtype != rrs->type || rr_len > *raw_len) {\n\t\treturn -1;\n\t}\n\n\t/* get rr data */\n\tmemcpy(raw, context.ptr, rr_len);\n\tcontext.ptr += rr_len;\n\t*raw_len = rr_len;\n\n\treturn 0;\n}\n\nstatic int _dns_add_opt_RAW(struct dns_packet *packet, dns_opt_code_t opt_rrtype, void *raw, int raw_len)\n{\n\tunsigned char opt_data[DNS_MAX_OPT_LEN];\n\tstruct dns_opt *opt = (struct dns_opt *)opt_data;\n\tint len = 0;\n\n\topt->code = DNS_OPT_T_TCP_KEEPALIVE;\n\topt->length = sizeof(unsigned short);\n\n\tmemcpy(opt->data, raw, raw_len);\n\tlen += raw_len;\n\tlen += sizeof(*opt);\n\n\treturn _dns_add_RAW(packet, DNS_RRS_OPT, (dns_type_t)DNS_OPT_T_TCP_KEEPALIVE, \"\", 0, opt_data, len);\n}\n\nstatic int _dns_get_opt_RAW(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl, struct dns_opt *dns_opt,\n\t\t\t\t\t\t\tint *dns_optlen)\n{\n\t*dns_optlen = DNS_MAX_OPT_LEN;\n\n\treturn _dns_get_RAW(rrs, domain, maxsize, ttl, dns_opt, dns_optlen);\n}\n\nstatic int __attribute__((unused)) _dns_add_OPT(struct dns_packet *packet, dns_rr_type type, unsigned short opt_code,\n\t\t\t\t\t\t\t\t\t\t\t\tunsigned short opt_len, struct dns_opt *opt)\n{\n\t// TODO\n\n\tint ret = 0;\n\tint len = 0;\n\tstruct dns_context context;\n\tint total_len = sizeof(*opt) + opt->length;\n\tint ttl = 0;\n\n\t/*\n\t+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n  0: |                          OPTION-CODE                          |\n\t +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n  2: |                         OPTION-LENGTH                         |\n\t +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n  4: |                                                               |\n\t /                          OPTION-DATA                          /\n\t /                                                               /\n\t +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\t*/\n\tret = _dns_add_rrs_start(packet, &context);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tif (_dns_left_len(&context) < total_len) {\n\t\treturn -1;\n\t}\n\n\tttl = (opt_code << 16) | opt_len;\n\n\t/* add rr head */\n\tlen = _dns_add_rr_head(&context, \"\", type, DNS_C_IN, ttl, total_len);\n\tif (len < 0) {\n\t\treturn -1;\n\t}\n\n\t/* add rr data */\n\tmemcpy(context.ptr, opt, total_len);\n\tcontext.ptr += total_len;\n\tlen = context.ptr - context.data - packet->len;\n\n\treturn _dns_rr_add_end(packet, type, DNS_T_OPT, len);\n}\n\nstatic int __attribute__((unused)) _dns_get_OPT(struct dns_rrs *rrs, unsigned short *opt_code, unsigned short *opt_len,\n\t\t\t\t\t\t\t\t\t\t\t\tstruct dns_opt *opt, int *opt_maxlen)\n{\n\t// TODO\n\n\tint qtype = 0;\n\tint qclass = 0;\n\tint rr_len = 0;\n\tint ret = 0;\n\tstruct dns_context context;\n\tchar domain[DNS_MAX_CNAME_LEN];\n\tint maxsize = DNS_MAX_CNAME_LEN;\n\tint ttl = 0;\n\n\t_dns_init_context_by_rrs(rrs, &context);\n\n\t/* get rr head */\n\tret = _dns_get_rr_head(&context, domain, maxsize, &qtype, &qclass, &ttl, &rr_len);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tif (qtype != rrs->type || rr_len > *opt_len) {\n\t\treturn -1;\n\t}\n\n\t/* get rr data */\n\t*opt_code = ttl >> 16;\n\t*opt_len = ttl & 0xFFFF;\n\tmemcpy(opt, context.ptr, rr_len);\n\tcontext.ptr += rr_len;\n\t*opt_maxlen = rr_len;\n\n\treturn 0;\n}\n\nint dns_add_CNAME(struct dns_packet *packet, dns_rr_type type, const char *domain, int ttl, const char *cname)\n{\n\tint rr_len = strnlen(cname, DNS_MAX_CNAME_LEN) + 1;\n\treturn _dns_add_RAW(packet, type, DNS_T_CNAME, domain, ttl, cname, rr_len);\n}\n\nint dns_get_CNAME(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl, char *cname, int cname_size)\n{\n\tint len = cname_size;\n\treturn _dns_get_RAW(rrs, domain, maxsize, ttl, cname, &len);\n}\n\nint dns_add_A(struct dns_packet *packet, dns_rr_type type, const char *domain, int ttl,\n\t\t\t  unsigned char addr[DNS_RR_A_LEN])\n{\n\treturn _dns_add_RAW(packet, type, DNS_T_A, domain, ttl, addr, DNS_RR_A_LEN);\n}\n\nint dns_get_A(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl, unsigned char addr[DNS_RR_A_LEN])\n{\n\tint len = DNS_RR_A_LEN;\n\treturn _dns_get_RAW(rrs, domain, maxsize, ttl, addr, &len);\n}\n\nint dns_add_PTR(struct dns_packet *packet, dns_rr_type type, const char *domain, int ttl, const char *cname)\n{\n\tint rr_len = strnlen(cname, DNS_MAX_CNAME_LEN) + 1;\n\treturn _dns_add_RAW(packet, type, DNS_T_PTR, domain, ttl, cname, rr_len);\n}\n\nint dns_get_PTR(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl, char *cname, int cname_size)\n{\n\tint len = cname_size;\n\treturn _dns_get_RAW(rrs, domain, maxsize, ttl, cname, &len);\n}\n\nint dns_add_NS(struct dns_packet *packet, dns_rr_type type, const char *domain, int ttl, const char *cname)\n{\n\tint rr_len = strnlen(cname, DNS_MAX_CNAME_LEN) + 1;\n\treturn _dns_add_RAW(packet, type, DNS_T_NS, domain, ttl, cname, rr_len);\n}\n\nint dns_get_NS(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl, char *cname, int cname_size)\n{\n\tint len = cname_size;\n\treturn _dns_get_RAW(rrs, domain, maxsize, ttl, cname, &len);\n}\n\nint dns_add_AAAA(struct dns_packet *packet, dns_rr_type type, const char *domain, int ttl,\n\t\t\t\t unsigned char addr[DNS_RR_AAAA_LEN])\n{\n\treturn _dns_add_RAW(packet, type, DNS_T_AAAA, domain, ttl, addr, DNS_RR_AAAA_LEN);\n}\n\nint dns_get_AAAA(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl, unsigned char addr[DNS_RR_AAAA_LEN])\n{\n\tint len = DNS_RR_AAAA_LEN;\n\treturn _dns_get_RAW(rrs, domain, maxsize, ttl, addr, &len);\n}\n\nint dns_add_SOA(struct dns_packet *packet, dns_rr_type type, const char *domain, int ttl, struct dns_soa *soa)\n{\n\t/* SOA */\n\t/*| mname        |\n\t *| rname        |\n\t *| serial       |\n\t *| refresh      |\n\t *| retry        |\n\t *| expire       |\n\t *| minimum      |\n\t */\n\tunsigned char data[sizeof(*soa)];\n\tunsigned char *ptr = data;\n\tint len = 0;\n\tsafe_strncpy((char *)ptr, soa->mname, DNS_MAX_CNAME_LEN);\n\tptr += strnlen(soa->mname, DNS_MAX_CNAME_LEN - 1) + 1;\n\tsafe_strncpy((char *)ptr, soa->rname, DNS_MAX_CNAME_LEN);\n\tptr += strnlen(soa->rname, DNS_MAX_CNAME_LEN - 1) + 1;\n\tmemcpy(ptr, &soa->serial, sizeof(unsigned int));\n\tptr += 4;\n\tmemcpy(ptr, &soa->refresh, sizeof(unsigned int));\n\tptr += 4;\n\tmemcpy(ptr, &soa->retry, sizeof(unsigned int));\n\tptr += 4;\n\tmemcpy(ptr, &soa->expire, sizeof(unsigned int));\n\tptr += 4;\n\tmemcpy(ptr, &soa->minimum, sizeof(unsigned int));\n\tptr += 4;\n\tlen = ptr - data;\n\n\treturn _dns_add_RAW(packet, type, DNS_T_SOA, domain, ttl, data, len);\n}\n\nint dns_get_SOA(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl, struct dns_soa *soa)\n{\n\tunsigned char data[sizeof(*soa)];\n\tunsigned char *ptr = data;\n\tint len = sizeof(data);\n\n\t/* SOA */\n\t/*| mname        |\n\t *| rname        |\n\t *| serial       |\n\t *| refresh      |\n\t *| retry        |\n\t *| expire       |\n\t *| minimum      |\n\t */\n\tif (_dns_get_RAW(rrs, domain, maxsize, ttl, data, &len) != 0) {\n\t\treturn -1;\n\t}\n\n\tsafe_strncpy(soa->mname, (char *)ptr, DNS_MAX_CNAME_LEN - 1);\n\tptr += strnlen(soa->mname, DNS_MAX_CNAME_LEN - 1) + 1;\n\tif (ptr - data >= len) {\n\t\treturn -1;\n\t}\n\tsafe_strncpy(soa->rname, (char *)ptr, DNS_MAX_CNAME_LEN - 1);\n\tptr += strnlen(soa->rname, DNS_MAX_CNAME_LEN - 1) + 1;\n\tif (ptr - data + 20 > len) {\n\t\treturn -1;\n\t}\n\tmemcpy(&soa->serial, ptr, 4);\n\tptr += 4;\n\tmemcpy(&soa->refresh, ptr, 4);\n\tptr += 4;\n\tmemcpy(&soa->retry, ptr, 4);\n\tptr += 4;\n\tmemcpy(&soa->expire, ptr, 4);\n\tptr += 4;\n\tmemcpy(&soa->minimum, ptr, 4);\n\n\treturn 0;\n}\n\nint dns_set_OPT_payload_size(struct dns_packet *packet, int payload_size)\n{\n\tif (payload_size < 512) {\n\t\tpayload_size = 512;\n\t}\n\n\tpacket->payloadsize = payload_size;\n\treturn 0;\n}\n\nint dns_get_OPT_payload_size(struct dns_packet *packet)\n{\n\treturn packet->payloadsize;\n}\n\nint dns_add_OPT_ECS(struct dns_packet *packet, struct dns_opt_ecs *ecs)\n{\n\tunsigned char opt_data[DNS_MAX_OPT_LEN];\n\tstruct dns_opt *opt = (struct dns_opt *)opt_data;\n\tint len = 0;\n\n\t/* ecs size 4 + bit of address*/\n\tlen = 4;\n\tlen += (ecs->source_prefix / 8);\n\tlen += (ecs->source_prefix % 8 > 0) ? 1 : 0;\n\n\topt->length = len;\n\topt->code = DNS_OPT_T_ECS;\n\tmemcpy(opt->data, ecs, len);\n\tlen += sizeof(*opt);\n\n\treturn _dns_add_RAW(packet, DNS_RRS_OPT, (dns_type_t)DNS_OPT_T_ECS, \"\", 0, opt_data, len);\n}\n\nint dns_get_OPT_ECS(struct dns_rrs *rrs, unsigned short *opt_code, unsigned short *opt_len, struct dns_opt_ecs *ecs)\n{\n\tunsigned char opt_data[DNS_MAX_OPT_LEN];\n\tchar domain[DNS_MAX_CNAME_LEN] = {0};\n\tstruct dns_opt *opt = (struct dns_opt *)opt_data;\n\tint len = DNS_MAX_OPT_LEN;\n\tint ttl = 0;\n\n\tif (_dns_get_RAW(rrs, domain, DNS_MAX_CNAME_LEN, &ttl, opt_data, &len) != 0) {\n\t\treturn -1;\n\t}\n\n\tif (len < (int)sizeof(*opt)) {\n\t\treturn -1;\n\t}\n\n\tif (opt->code != DNS_OPT_T_ECS) {\n\t\treturn -1;\n\t}\n\n\tmemcpy(ecs, opt->data, opt->length);\n\n\treturn 0;\n}\n\nint dns_add_OPT_TCP_KEEPALIVE(struct dns_packet *packet, unsigned short timeout)\n{\n\tunsigned short timeout_net = htons(timeout);\n\tint data_len = 0;\n\n\tif (timeout > 0) {\n\t\tdata_len = sizeof(timeout);\n\t}\n\n\treturn _dns_add_opt_RAW(packet, DNS_OPT_T_TCP_KEEPALIVE, &timeout_net, data_len);\n}\n\nint dns_get_OPT_TCP_KEEPALIVE(struct dns_rrs *rrs, unsigned short *opt_code, unsigned short *opt_len,\n\t\t\t\t\t\t\t  unsigned short *timeout)\n{\n\tunsigned char opt_data[DNS_MAX_OPT_LEN];\n\tstruct dns_opt *opt = (struct dns_opt *)opt_data;\n\tint len = DNS_MAX_OPT_LEN;\n\tint ttl = 0;\n\tunsigned char *data = NULL;\n\n\tif (_dns_get_opt_RAW(rrs, NULL, 0, &ttl, opt, &len) != 0) {\n\t\treturn -1;\n\t}\n\n\tif (len < (int)sizeof(*opt)) {\n\t\treturn -1;\n\t}\n\n\tif (opt->code != DNS_OPT_T_TCP_KEEPALIVE) {\n\t\treturn -1;\n\t}\n\n\tif (opt->length == 0) {\n\t\t*timeout = 0;\n\t\treturn 0;\n\t}\n\n\tif (opt->length != sizeof(unsigned short)) {\n\t\treturn -1;\n\t}\n\n\tdata = opt->data;\n\n\t*timeout = _dns_read_short(&data);\n\n\treturn 0;\n}\n\nint dns_add_HTTPS_start(struct dns_rr_nested *svcparam_buffer, struct dns_packet *packet, dns_rr_type type,\n\t\t\t\t\t\tconst char *domain, int ttl, int priority, const char *target)\n{\n\tsvcparam_buffer = dns_add_rr_nested_start(svcparam_buffer, packet, type, DNS_T_HTTPS, domain, ttl);\n\tif (svcparam_buffer == NULL) {\n\t\treturn -1;\n\t}\n\n\tint target_len = strnlen(target, DNS_MAX_CNAME_LEN) + 1;\n\tif (_dns_left_len(&svcparam_buffer->context) < 2 + target_len) {\n\t\treturn -1;\n\t}\n\n\t/* add rr data */\n\t_dns_write_short(&svcparam_buffer->context.ptr, priority);\n\tsafe_strncpy((char *)svcparam_buffer->context.ptr, target, target_len);\n\tsvcparam_buffer->context.ptr += target_len;\n\n\treturn 0;\n}\n\nint dns_HTTPS_add_raw(struct dns_rr_nested *svcparam, unsigned short key, unsigned char *value, unsigned short len)\n{\n\tif (_dns_left_len(&svcparam->context) < 2 + len) {\n\t\treturn -1;\n\t}\n\n\tdns_add_rr_nested_memcpy(svcparam, &key, 2);\n\tdns_add_rr_nested_memcpy(svcparam, &len, 2);\n\tdns_add_rr_nested_memcpy(svcparam, value, len);\n\treturn 0;\n}\n\nint dns_HTTPS_add_port(struct dns_rr_nested *svcparam, unsigned short port)\n{\n\tif (_dns_left_len(&svcparam->context) < 6) {\n\t\treturn -1;\n\t}\n\n\tunsigned short value = DNS_HTTPS_T_PORT;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tvalue = 2;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tvalue = htons(port);\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\n\treturn 0;\n}\n\nint dns_HTTPS_add_ech(struct dns_rr_nested *svcparam, void *ech, int ech_len)\n{\n\tif (_dns_left_len(&svcparam->context) < 2 + 2 + ech_len) {\n\t\treturn -1;\n\t}\n\n\tunsigned short value = DNS_HTTPS_T_ECH;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\n\tvalue = ech_len;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tdns_add_rr_nested_memcpy(svcparam, ech, ech_len);\n\n\treturn 0;\n}\n\nint dns_HTTPS_add_ipv4hint(struct dns_rr_nested *svcparam, unsigned char addr[][DNS_RR_A_LEN], int addr_num)\n{\n\tif (_dns_left_len(&svcparam->context) < 4 + addr_num * DNS_RR_A_LEN) {\n\t\treturn -1;\n\t}\n\n\tunsigned short value = DNS_HTTPS_T_IPV4HINT;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\n\tvalue = addr_num * DNS_RR_A_LEN;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\n\tfor (int i = 0; i < addr_num; i++) {\n\t\tdns_add_rr_nested_memcpy(svcparam, addr[i], DNS_RR_A_LEN);\n\t}\n\n\treturn 0;\n}\nint dns_HTTPS_add_ipv6hint(struct dns_rr_nested *svcparam, unsigned char addr[][DNS_RR_AAAA_LEN], int addr_num)\n{\n\tif (_dns_left_len(&svcparam->context) < 4 + addr_num * DNS_RR_AAAA_LEN) {\n\t\treturn -1;\n\t}\n\n\tunsigned short value = DNS_HTTPS_T_IPV6HINT;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\n\tvalue = addr_num * DNS_RR_AAAA_LEN;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\n\tfor (int i = 0; i < addr_num; i++) {\n\t\tdns_add_rr_nested_memcpy(svcparam, addr[i], DNS_RR_AAAA_LEN);\n\t}\n\n\treturn 0;\n}\n\nint dns_add_HTTPS_end(struct dns_rr_nested *svcparam)\n{\n\treturn dns_add_rr_nested_end(svcparam, DNS_T_HTTPS);\n}\n\nstruct dns_https_param *dns_get_HTTPS_svcparm_start(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl,\n\t\t\t\t\t\t\t\t\t\t\t\t\tint *priority, char *target, int target_size)\n{\n\tint qtype = 0;\n\tunsigned char *data = NULL;\n\tint rr_len = 0;\n\n\tdata = dns_get_rr_nested_start(rrs, domain, maxsize, &qtype, ttl, &rr_len);\n\tif (data == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (qtype != DNS_T_HTTPS) {\n\t\treturn NULL;\n\t}\n\n\tif (rr_len < 2) {\n\t\treturn NULL;\n\t}\n\n\t*priority = _dns_read_short(&data);\n\trr_len -= 2;\n\tif (rr_len <= 0) {\n\t\treturn NULL;\n\t}\n\n\tint len = strnlen((char *)data, rr_len);\n\tsafe_strncpy(target, (char *)data, target_size);\n\tdata += len + 1;\n\trr_len -= len + 1;\n\tif (rr_len <= 0) {\n\t\treturn NULL;\n\t}\n\n\treturn (struct dns_https_param *)data;\n}\n\nstruct dns_https_param *dns_get_HTTPS_svcparm_next(struct dns_rrs *rrs, struct dns_https_param *param)\n{\n\treturn dns_get_rr_nested_next(rrs, param, sizeof(struct dns_https_param) + param->len);\n}\n\n/*\n * Format:\n * |DNS_NAME\\0(string)|qtype(short)|qclass(short)|\n */\nint dns_add_domain(struct dns_packet *packet, const char *domain, int qtype, int qclass)\n{\n\tint len = 0;\n\tint ret = 0;\n\tstruct dns_context context;\n\n\tret = _dns_add_rrs_start(packet, &context);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tlen = _dns_add_qr_head(&context, domain, qtype, qclass);\n\tif (len < 0) {\n\t\treturn -1;\n\t}\n\n\treturn _dns_rr_add_end(packet, DNS_RRS_QD, DNS_T_CNAME, len);\n}\n\nint dns_get_domain(struct dns_rrs *rrs, char *domain, int maxsize, int *qtype, int *qclass)\n{\n\tstruct dns_context context;\n\n\t_dns_init_context_by_rrs(rrs, &context);\n\treturn _dns_get_qr_head(&context, domain, maxsize, qtype, qclass);\n}\n\nstatic int _dns_decode_head(struct dns_context *context)\n{\n\tunsigned int fields = 0;\n\tint len = 12;\n\tstruct dns_head *head = &context->packet->head;\n\n\tif (_dns_left_len(context) < len) {\n\t\treturn -1;\n\t}\n\n\t/*\n\t0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t|                      ID                       |\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t|QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t|                    QDCOUNT                    |\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t|                    ANCOUNT                    |\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t|                    NSCOUNT                    |\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t|                    ARCOUNT                    |\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t*/\n\n\thead->id = _dns_read_short(&context->ptr);\n\tfields = _dns_read_short(&context->ptr);\n\thead->qr = (fields & QR_MASK) >> 15;\n\thead->opcode = (fields & OPCODE_MASK) >> 11;\n\thead->aa = (fields & AA_MASK) >> 10;\n\thead->tc = (fields & TC_MASK) >> 9;\n\thead->rd = (fields & RD_MASK) >> 8;\n\thead->ra = (fields & RA_MASK) >> 7;\n\thead->rcode = (fields & RCODE_MASK) >> 0;\n\thead->qdcount = _dns_read_short(&context->ptr);\n\thead->ancount = _dns_read_short(&context->ptr);\n\thead->nscount = _dns_read_short(&context->ptr);\n\thead->nrcount = _dns_read_short(&context->ptr);\n\n\treturn 0;\n}\n\nstatic int _dns_encode_head(struct dns_context *context)\n{\n\tint len = 12;\n\tstruct dns_head *head = &context->packet->head;\n\n\tif (_dns_left_len(context) < len) {\n\t\treturn -1;\n\t}\n\n\t_dns_write_short(&context->ptr, head->id);\n\n\tint fields = 0;\n\tfields |= (head->qr << 15) & QR_MASK;\n\tfields |= (head->opcode << 11) & OPCODE_MASK;\n\tfields |= (head->aa << 10) & AA_MASK;\n\tfields |= (head->tc << 9) & TC_MASK;\n\tfields |= (head->rd << 8) & RD_MASK;\n\tfields |= (head->ra << 7) & RA_MASK;\n\tfields |= (head->rcode << 0) & RCODE_MASK;\n\t_dns_write_short(&context->ptr, fields);\n\n\t_dns_write_short(&context->ptr, head->qdcount);\n\t_dns_write_short(&context->ptr, head->ancount);\n\t_dns_write_short(&context->ptr, head->nscount);\n\t_dns_write_short(&context->ptr, head->nrcount);\n\treturn len;\n}\n\nstatic int _dns_encode_head_count(struct dns_context *context)\n{\n\tint len = 12;\n\tstruct dns_head *head = &context->packet->head;\n\tunsigned char *ptr = context->data;\n\n\tptr += 4;\n\t_dns_write_short(&ptr, head->qdcount);\n\t_dns_write_short(&ptr, head->ancount);\n\t_dns_write_short(&ptr, head->nscount);\n\t_dns_write_short(&ptr, head->nrcount);\n\treturn len;\n}\n\nstatic int _dns_decode_qr_head(struct dns_context *context, char *domain, int domain_size, int *qtype, int *qclass)\n{\n\tint ret = 0;\n\t/*\n\t0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t|                                               |\n\t/                                               /\n\t/                      NAME                     /\n\t|                                               |\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t|                      TYPE                     |\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t|                     CLASS                     |\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t*/\n\tret = _dns_decode_domain(context, domain, domain_size);\n\tif (ret < 0) {\n\t\ttlog(TLOG_DEBUG, \"decode domain failed.\");\n\t\treturn -1;\n\t}\n\n\tif (_dns_left_len(context) < 4) {\n\t\ttlog(TLOG_DEBUG, \"left length is not enough, %s.\", domain);\n\t\treturn -1;\n\t}\n\n\t*qtype = _dns_read_short(&context->ptr);\n\t*qclass = _dns_read_short(&context->ptr);\n\n\treturn 0;\n}\n\nstatic int _dns_encode_qr_head(struct dns_context *context, char *domain, int qtype, int qclass)\n{\n\tint ret = 0;\n\tret = _dns_encode_domain(context, domain);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tif (_dns_left_len(context) < 4) {\n\t\treturn -1;\n\t}\n\n\t_dns_write_short(&context->ptr, qtype);\n\t_dns_write_short(&context->ptr, qclass);\n\n\treturn 0;\n}\n\nstatic int _dns_decode_rr_head(struct dns_context *context, char *domain, int domain_size, int *qtype, int *qclass,\n\t\t\t\t\t\t\t   int *ttl, int *rr_len)\n{\n\tint len = 0;\n\n\tlen = _dns_decode_qr_head(context, domain, domain_size, qtype, qclass);\n\tif (len < 0) {\n\t\ttlog(TLOG_DEBUG, \"decode qr head failed.\");\n\t\treturn -1;\n\t}\n\n\tif (_dns_left_len(context) < 6) {\n\t\ttlog(TLOG_DEBUG, \"left length is not enough.\");\n\t\treturn -1;\n\t}\n\n\t*ttl = _dns_read_int(&context->ptr);\n\t*rr_len = _dns_read_short(&context->ptr);\n\n\tif (*rr_len < 0 || *ttl < 0) {\n\t\ttlog(TLOG_DEBUG, \"rr len or ttl is invalid.\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int _dns_encode_rr_head(struct dns_context *context, char *domain, int qtype, int qclass, int ttl, int rr_len,\n\t\t\t\t\t\t\t   unsigned char **rr_len_ptr)\n{\n\tint ret = 0;\n\tret = _dns_encode_qr_head(context, domain, qtype, qclass);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tif (_dns_left_len(context) < 6) {\n\t\treturn -1;\n\t}\n\n\t_dns_write_int(&context->ptr, ttl);\n\tif (rr_len_ptr) {\n\t\t*rr_len_ptr = context->ptr;\n\t}\n\t_dns_write_short(&context->ptr, rr_len);\n\n\treturn 0;\n}\n\nstatic int _dns_encode_raw(struct dns_context *context, struct dns_rrs *rrs)\n{\n\tint ret = 0;\n\tint qtype = 0;\n\tint qclass = 0;\n\tint ttl = 0;\n\tchar domain[DNS_MAX_CNAME_LEN];\n\tint rr_len = 0;\n\tunsigned char *rr_len_ptr = NULL;\n\tstruct dns_context data_context;\n\t/*\n\t0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t|                                               |\n\t/                                               /\n\t/                      NAME                     /\n\t|                                               |\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t|                      TYPE                     |\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t|                     CLASS                     |\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t|                      TTL                      |\n\t|                                               |\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t|                   RDLENGTH                    |\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|\n\t/                     RDATA                     /\n\t/                                               /\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t*/\n\t_dns_init_context_by_rrs(rrs, &data_context);\n\tret = _dns_get_rr_head(&data_context, domain, DNS_MAX_CNAME_LEN, &qtype, &qclass, &ttl, &rr_len);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tret = _dns_encode_rr_head(context, domain, qtype, qclass, ttl, rr_len, &rr_len_ptr);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tif (_dns_left_len(context) < rr_len) {\n\t\treturn -1;\n\t}\n\n\tmemcpy(context->ptr, data_context.ptr, rr_len);\n\tcontext->ptr += rr_len;\n\tdata_context.ptr += rr_len;\n\n\treturn 0;\n}\n\nstatic int _dns_decode_raw(struct dns_context *context, unsigned char *raw, int len)\n{\n\tif (_dns_left_len(context) < len || len < 0) {\n\t\treturn -1;\n\t}\n\n\tmemcpy(raw, context->ptr, len);\n\tcontext->ptr += len;\n\treturn 0;\n}\n\nstatic int _dns_decode_CNAME(struct dns_context *context, char *cname, int cname_size)\n{\n\tint ret = 0;\n\tret = _dns_decode_domain(context, cname, cname_size);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int _dns_encode_CNAME(struct dns_context *context, struct dns_rrs *rrs)\n{\n\tint ret = 0;\n\tint qtype = 0;\n\tint qclass = 0;\n\tint ttl = 0;\n\tchar domain[DNS_MAX_CNAME_LEN];\n\tint rr_len = 0;\n\tunsigned char *rr_len_ptr = NULL;\n\tstruct dns_context data_context;\n\n\t_dns_init_context_by_rrs(rrs, &data_context);\n\tret = _dns_get_rr_head(&data_context, domain, DNS_MAX_CNAME_LEN, &qtype, &qclass, &ttl, &rr_len);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\t/* when code domain, len must plus 1, because of length at the beginning */\n\trr_len = 1;\n\tret = _dns_encode_rr_head(context, domain, qtype, qclass, ttl, rr_len, &rr_len_ptr);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tret = _dns_encode_domain(context, (char *)data_context.ptr);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\trr_len += ret;\n\tdata_context.ptr += strnlen((char *)(data_context.ptr), DNS_MAX_CNAME_LEN) + 1;\n\n\tif (rr_len > rrs->len) {\n\t\treturn -1;\n\t}\n\t_dns_write_short(&rr_len_ptr, ret);\n\n\treturn 0;\n}\n\nstatic int _dns_decode_SOA(struct dns_context *context, struct dns_soa *soa)\n{\n\tint ret = 0;\n\tret = _dns_decode_domain(context, soa->mname, DNS_MAX_CNAME_LEN - 1);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tret = _dns_decode_domain(context, soa->rname, DNS_MAX_CNAME_LEN - 1);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tif (_dns_left_len(context) < 20) {\n\t\treturn -1;\n\t}\n\n\tsoa->serial = _dns_read_int(&context->ptr);\n\tsoa->refresh = _dns_read_int(&context->ptr);\n\tsoa->retry = _dns_read_int(&context->ptr);\n\tsoa->expire = _dns_read_int(&context->ptr);\n\tsoa->minimum = _dns_read_int(&context->ptr);\n\n\treturn 0;\n}\n\nstatic int _dns_encode_SOA(struct dns_context *context, struct dns_rrs *rrs)\n{\n\tint ret = 0;\n\tint qtype = 0;\n\tint qclass = 0;\n\tint ttl = 0;\n\tchar domain[DNS_MAX_CNAME_LEN];\n\tint rr_len = 0;\n\tunsigned char *rr_len_ptr = NULL;\n\tstruct dns_context data_context;\n\n\t_dns_init_context_by_rrs(rrs, &data_context);\n\tret = _dns_get_rr_head(&data_context, domain, DNS_MAX_CNAME_LEN, &qtype, &qclass, &ttl, &rr_len);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tret = _dns_encode_rr_head(context, domain, qtype, qclass, ttl, rr_len, &rr_len_ptr);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\trr_len = 0;\n\t/* mname */\n\tret = _dns_encode_domain(context, (char *)data_context.ptr);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\trr_len += ret;\n\tdata_context.ptr += strnlen((char *)(data_context.ptr), DNS_MAX_CNAME_LEN) + 1;\n\n\t/* rname */\n\tret = _dns_encode_domain(context, (char *)data_context.ptr);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\trr_len += ret;\n\tdata_context.ptr += strnlen((char *)(data_context.ptr), DNS_MAX_CNAME_LEN) + 1;\n\tif (rr_len > rrs->len) {\n\t\treturn -1;\n\t}\n\n\trr_len += 20;\n\t_dns_write_short(&rr_len_ptr, rr_len);\n\tif (_dns_left_len(context) < 20) {\n\t\treturn -1;\n\t}\n\n\t_dns_write_int(&context->ptr, *(unsigned int *)data_context.ptr);\n\tdata_context.ptr += 4;\n\t_dns_write_int(&context->ptr, *(unsigned int *)data_context.ptr);\n\tdata_context.ptr += 4;\n\t_dns_write_int(&context->ptr, *(unsigned int *)data_context.ptr);\n\tdata_context.ptr += 4;\n\t_dns_write_int(&context->ptr, *(unsigned int *)data_context.ptr);\n\tdata_context.ptr += 4;\n\t_dns_write_int(&context->ptr, *(unsigned int *)data_context.ptr);\n\tdata_context.ptr += 4;\n\n\treturn 0;\n}\n\nstatic int _dns_decode_opt_ecs(struct dns_context *context, struct dns_opt_ecs *ecs, int opt_len)\n{\n\t// TODO\n\n\tint len = 0;\n\tif (opt_len < 4) {\n\t\treturn -1;\n\t}\n\n\tecs->family = _dns_read_short(&context->ptr);\n\tecs->source_prefix = _dns_read_char(&context->ptr);\n\tecs->scope_prefix = _dns_read_char(&context->ptr);\n\tlen = (ecs->source_prefix / 8);\n\tlen += (ecs->source_prefix % 8 > 0) ? 1 : 0;\n\n\tif (_dns_left_len(context) < len || len > (int)sizeof(ecs->addr)) {\n\t\treturn -1;\n\t}\n\n\tmemcpy(ecs->addr, context->ptr, len);\n\tcontext->ptr += len;\n\n\ttlog(TLOG_DEBUG, \"ECS: family:%d, source_prefix:%d, scope_prefix:%d, len:%d\", ecs->family, ecs->source_prefix,\n\t\t ecs->scope_prefix, len);\n\ttlog(TLOG_DEBUG, \"%d.%d.%d.%d\", ecs->addr[0], ecs->addr[1], ecs->addr[2], ecs->addr[3]);\n\n\treturn 0;\n}\n\nstatic int _dns_decode_opt_cookie(struct dns_context *context, struct dns_opt_cookie *cookie, int opt_len)\n{\n\t// TODO\n\tif (opt_len < (int)member_size(struct dns_opt_cookie, client_cookie)) {\n\t\treturn -1;\n\t}\n\n\tint len = 8;\n\tmemcpy(cookie->client_cookie, context->ptr, len);\n\tcontext->ptr += len;\n\n\topt_len -= len;\n\tif (opt_len <= 0) {\n\t\tcookie->server_cookie_len = 0;\n\t\treturn 0;\n\t}\n\n\tif (opt_len < 8 || opt_len > (int)member_size(struct dns_opt_cookie, server_cookie)) {\n\t\treturn -1;\n\t}\n\n\tmemcpy(cookie->server_cookie, context->ptr, opt_len);\n\tcookie->server_cookie_len = opt_len;\n\tcontext->ptr += opt_len;\n\n\ttlog(TLOG_DEBUG, \"OPT COOKIE\");\n\treturn 0;\n}\n\nstatic int _dns_encode_OPT(struct dns_context *context, struct dns_rrs *rrs)\n{\n\tint ret = 0;\n\tint opt_code = 0;\n\tint qclass = 0;\n\tchar domain[DNS_MAX_CNAME_LEN];\n\tstruct dns_context data_context;\n\tint rr_len = 0;\n\tint ttl = 0;\n\tstruct dns_opt *dns_opt = NULL;\n\n\t_dns_init_context_by_rrs(rrs, &data_context);\n\tret = _dns_get_rr_head(&data_context, domain, DNS_MAX_CNAME_LEN, &opt_code, &qclass, &ttl, &rr_len);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tif (rr_len < (int)sizeof(*dns_opt)) {\n\t\treturn -1;\n\t}\n\n\tif (_dns_left_len(context) < (rr_len)) {\n\t\treturn -1;\n\t}\n\n\tdns_opt = (struct dns_opt *)data_context.ptr;\n\t_dns_write_short(&context->ptr, dns_opt->code);\n\t_dns_write_short(&context->ptr, dns_opt->length);\n\n\tif (_dns_left_len(context) < dns_opt->length) {\n\t\treturn -1;\n\t}\n\n\tswitch (dns_opt->code) {\n\tcase DNS_OPT_T_ECS: {\n\t\tstruct dns_opt_ecs *ecs = (struct dns_opt_ecs *)&(dns_opt->data);\n\t\t_dns_write_short(&context->ptr, ecs->family);\n\t\t_dns_write_char(&context->ptr, ecs->source_prefix);\n\t\t_dns_write_char(&context->ptr, ecs->scope_prefix);\n\t\tmemcpy(context->ptr, ecs->addr, dns_opt->length - 4);\n\t\tcontext->ptr += dns_opt->length - 4;\n\t} break;\n\tdefault:\n\t\tmemcpy(context->ptr, dns_opt->data, dns_opt->length);\n\t\tcontext->ptr += dns_opt->length;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int _dns_get_opts_data_len(struct dns_packet *packet, struct dns_rrs *rrs, int count)\n{\n\tint i = 0;\n\tint len = 0;\n\tint opt_code = 0;\n\tint qclass = 0;\n\tint ttl = 0;\n\tint ret = 0;\n\tchar domain[DNS_MAX_CNAME_LEN];\n\tstruct dns_context data_context;\n\tint rr_len = 0;\n\n\tfor (i = 0; i < count && rrs; i++, rrs = dns_get_rrs_next(packet, rrs)) {\n\t\t_dns_init_context_by_rrs(rrs, &data_context);\n\t\tret = _dns_get_rr_head(&data_context, domain, DNS_MAX_CNAME_LEN, &opt_code, &qclass, &ttl, &rr_len);\n\t\tif (ret < 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen += rr_len;\n\t}\n\n\treturn len;\n}\n\nstatic int _dns_encode_opts(struct dns_packet *packet, struct dns_context *context, struct dns_rrs *rrs, int count)\n{\n\tint i = 0;\n\tint len = 0;\n\tint ret = 0;\n\tunsigned int rcode = 0;\n\tint rr_len = 0;\n\tint payloadsize = packet->payloadsize;\n\tunsigned char *rr_len_ptr = NULL;\n\n\trr_len = _dns_get_opts_data_len(packet, rrs, count);\n\tif (rr_len < 0) {\n\t\treturn -1;\n\t}\n\n\tif (payloadsize < DNS_DEFAULT_PACKET_SIZE) {\n\t\tpayloadsize = DNS_DEFAULT_PACKET_SIZE;\n\t}\n\n\tret = _dns_encode_rr_head(context, \"\", DNS_T_OPT, payloadsize, rcode, rr_len, &rr_len_ptr);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tif (_dns_left_len(context) < rr_len) {\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < count && rrs; i++, rrs = dns_get_rrs_next(packet, rrs)) {\n\t\tlen = _dns_encode_OPT(context, rrs);\n\t\tif (len < 0) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int _dns_decode_opt(struct dns_context *context, dns_rr_type type, unsigned int ttl, int rr_len)\n{\n\tunsigned short opt_code = 0;\n\tunsigned short opt_len = 0;\n\tunsigned short errcode = (ttl >> 16) & 0xFFFF;\n\tunsigned short ever = (ttl)&0xFFFF;\n\tunsigned char *start = context->ptr;\n\tstruct dns_packet *packet = context->packet;\n\tint ret = 0;\n\n\tUNUSED(ever);\n\n\t/*\n\t\t Field Name   Field Type     Description\n\t ------------------------------------------------------\n\t NAME         domain name    empty (root domain)\n\t TYPE         u_int16_t      OPT\n\t CLASS        u_int16_t      sender's UDP payload size\n\t TTL          u_int32_t      extended RCODE and flags\n\t RDLEN        u_int16_t      describes RDATA\n\t RDATA        octet stream   {attribute,value} pairs\n\n\t\t\t\t\t +0 (MSB)                            +1 (LSB)\n\t +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n  0: |                          OPTION-CODE                          |\n\t +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n  2: |                         OPTION-LENGTH                         |\n\t +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n  4: |                                                               |\n\t /                          OPTION-DATA                          /\n\t /                                                               /\n\t +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n\tTTL\n\t\t\t\t +0 (MSB)                            +1 (LSB)\n\t  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n   0: |         EXTENDED-RCODE        |            VERSION            |\n\t  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n   2: |                               Z                               |\n\t  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\t*/\n\n\tif (rr_len < 0) {\n\t\ttlog(TLOG_DEBUG, \"opt len is invalid.\");\n\t\treturn -1;\n\t}\n\n\tif (errcode != 0) {\n\t\ttlog(TLOG_DEBUG, \"extend rcode invalid, %d\", errcode);\n\t\treturn 0;\n\t}\n\n\twhile (context->ptr - start < rr_len) {\n\t\tif (_dns_left_len(context) < 4) {\n\t\t\ttlog(TLOG_DEBUG, \"data length is invalid, %d:%d\", _dns_left_len(context),\n\t\t\t\t (int)(context->ptr - context->data));\n\t\t\treturn -1;\n\t\t}\n\t\topt_code = _dns_read_short(&context->ptr);\n\t\topt_len = _dns_read_short(&context->ptr);\n\n\t\tif (_dns_left_len(context) < opt_len) {\n\t\t\ttlog(TLOG_DEBUG, \"read opt data failed, opt_code = %d, opt_len = %d\", opt_code, opt_len);\n\t\t\treturn -1;\n\t\t}\n\n\t\ttlog(TLOG_DEBUG, \"opt type %d\", opt_code);\n\t\tswitch (opt_code) {\n\t\tcase DNS_OPT_T_ECS: {\n\t\t\tstruct dns_opt_ecs ecs;\n\t\t\tret = _dns_decode_opt_ecs(context, &ecs, opt_len);\n\t\t\tif (ret != 0) {\n\t\t\t\ttlog(TLOG_ERROR, \"decode ecs failed.\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tret = dns_add_OPT_ECS(packet, &ecs);\n\t\t\tif (ret != 0) {\n\t\t\t\ttlog(TLOG_ERROR, \"add ecs failed.\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} break;\n\t\tcase DNS_OPT_T_COOKIE: {\n\t\t\tstruct dns_opt_cookie cookie;\n\t\t\tret = _dns_decode_opt_cookie(context, &cookie, opt_len);\n\t\t\tif (ret != 0) {\n\t\t\t\ttlog(TLOG_ERROR, \"decode cookie failed.\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} break;\n\t\tcase DNS_OPT_T_PADDING:\n\t\t\tcontext->ptr += opt_len;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontext->ptr += opt_len;\n\t\t\ttlog(TLOG_DEBUG, \"DNS opt type = %d not supported\", opt_code);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int _dns_encode_HTTPS(struct dns_context *context, struct dns_rrs *rrs)\n{\n\tint ret = 0;\n\tint qtype = 0;\n\tint qclass = 0;\n\tchar domain[DNS_MAX_CNAME_LEN];\n\tchar target[DNS_MAX_CNAME_LEN] = {0};\n\tunsigned char *rr_len_ptr = NULL;\n\tunsigned char *start = NULL;\n\tunsigned char *rr_start = NULL;\n\tint ttl = 0;\n\tint priority = 0;\n\tstruct dns_https_param *param = NULL;\n\n\tparam = dns_get_HTTPS_svcparm_start(rrs, domain, DNS_MAX_CNAME_LEN, &ttl, &priority, target, DNS_MAX_CNAME_LEN);\n\tif (param == NULL) {\n\t\ttlog(TLOG_ERROR, \"get https param failed.\");\n\t\treturn -1;\n\t}\n\n\tret = _dns_encode_rr_head(context, domain, qtype, qclass, ttl, 0, &rr_len_ptr);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\trr_start = context->ptr;\n\tif (_dns_left_len(context) < 2) {\n\t\ttlog(TLOG_ERROR, \"left len is invalid.\");\n\t\treturn -1;\n\t}\n\n\t_dns_write_short(&context->ptr, priority);\n\tret = _dns_encode_domain(context, target);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tstart = context->ptr;\n\tfor (; param != NULL; param = dns_get_HTTPS_svcparm_next(rrs, param)) {\n\t\tif (context->ptr - start > rrs->len || _dns_left_len(context) <= 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t_dns_write_short(&context->ptr, param->key);\n\t\t_dns_write_short(&context->ptr, param->len);\n\t\tswitch (param->key) {\n\t\tcase DNS_HTTPS_T_MANDATORY:\n\t\tcase DNS_HTTPS_T_NO_DEFAULT_ALPN:\n\t\tcase DNS_HTTPS_T_ALPN:\n\t\tcase DNS_HTTPS_T_PORT:\n\t\tcase DNS_HTTPS_T_IPV4HINT:\n\t\tcase DNS_HTTPS_T_ECH:\n\t\tcase DNS_HTTPS_T_IPV6HINT: {\n\t\t\tmemcpy(context->ptr, param->value, param->len);\n\t\t\tcontext->ptr += param->len;\n\t\t} break;\n\t\tdefault:\n\t\t\t/* skip unknown key */\n\t\t\tcontext->ptr -= 4;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t_dns_write_short(&rr_len_ptr, context->ptr - rr_start);\n\n\treturn 0;\n}\n\nstatic int _dns_decode_HTTPS(struct dns_context *context, const char *domain, dns_rr_type type, unsigned int ttl,\n\t\t\t\t\t\t\t int rr_len)\n{\n\tunsigned char *start = context->ptr;\n\n\tstruct dns_packet *packet = context->packet;\n\tint ret = 0;\n\tunsigned short priority;\n\tunsigned short key;\n\tunsigned short value_len;\n\tunsigned char *value = NULL;\n\tchar target[DNS_MAX_CNAME_LEN] = {0};\n\tstruct dns_rr_nested param;\n\n\tif (rr_len < 2) {\n\t\ttlog(TLOG_DEBUG, \"https len is invalid.\");\n\t\treturn -1;\n\t}\n\n\tpriority = _dns_read_short(&context->ptr);\n\tret = _dns_decode_domain(context, target, sizeof(target));\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tdns_add_HTTPS_start(&param, packet, DNS_RRS_AN, domain, ttl, priority, target);\n\n\twhile (context->ptr - start < rr_len) {\n\t\tif (_dns_left_len(context) < 4) {\n\t\t\ttlog(TLOG_WARN, \"data length is invalid, %d:%d\", _dns_left_len(context),\n\t\t\t\t (int)(context->ptr - context->data));\n\t\t\treturn -1;\n\t\t}\n\t\tkey = _dns_read_short(&context->ptr);\n\t\tvalue_len = _dns_read_short(&context->ptr);\n\t\tvalue = context->ptr;\n\n\t\tif (_dns_left_len(context) < value_len) {\n\t\t\ttlog(TLOG_ERROR, \"read https data failed, svcParam key = %d, https_len = %d\", key, value_len);\n\t\t\treturn -1;\n\t\t}\n\n\t\tswitch (key) {\n\t\tcase DNS_HTTPS_T_MANDATORY:\n\t\tcase DNS_HTTPS_T_ALPN:\n\t\tcase DNS_HTTPS_T_NO_DEFAULT_ALPN:\n\t\tcase DNS_HTTPS_T_PORT:\n\t\tcase DNS_HTTPS_T_IPV4HINT:\n\t\tcase DNS_HTTPS_T_ECH:\n\t\tcase DNS_HTTPS_T_IPV6HINT: {\n\t\t\tdns_HTTPS_add_raw(&param, key, value, value_len);\n\t\t} break;\n\t\tdefault:\n\t\t\ttlog(TLOG_DEBUG, \"DNS HTTPS key = %d not supported\", key);\n\t\t\tbreak;\n\t\t}\n\n\t\tcontext->ptr += value_len;\n\t}\n\n\tdns_add_HTTPS_end(&param);\n\n\treturn 0;\n}\n\nstatic int _dns_decode_qd(struct dns_context *context)\n{\n\tstruct dns_packet *packet = context->packet;\n\tint len = 0;\n\tint qtype = 0;\n\tint qclass = 0;\n\tchar domain[DNS_MAX_CNAME_LEN];\n\n\tlen = _dns_decode_qr_head(context, domain, DNS_MAX_CNAME_LEN, &qtype, &qclass);\n\tif (len < 0) {\n\t\treturn -1;\n\t}\n\n\tlen = dns_add_domain(packet, domain, qtype, qclass);\n\tif (len < 0) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int _dns_decode_an(struct dns_context *context, dns_rr_type type)\n{\n\tint ret = 0;\n\tint qtype = 0;\n\tint qclass = 0;\n\tint ttl = 0;\n\tint rr_len = 0;\n\tchar domain[DNS_MAX_CNAME_LEN];\n\tstruct dns_packet *packet = context->packet;\n\tunsigned char *start = NULL;\n\n\t/* decode rr head */\n\tret = _dns_decode_rr_head(context, domain, DNS_MAX_CNAME_LEN, &qtype, &qclass, &ttl, &rr_len);\n\tif (ret < 0 || qclass < 0) {\n\t\ttlog(TLOG_DEBUG, \"decode head failed.\");\n\t\treturn -1;\n\t}\n\tstart = context->ptr;\n\n\t/* decode answer */\n\tswitch (qtype) {\n\tcase DNS_T_A: {\n\t\tunsigned char addr[DNS_RR_A_LEN];\n\t\tret = _dns_decode_raw(context, addr, sizeof(addr));\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"decode A failed, %s, len: %d:%d\", domain, (int)(context->ptr - context->data),\n\t\t\t\t _dns_left_len(context));\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = dns_add_A(packet, type, domain, ttl, addr);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_ERROR, \"add A failed, %s\", domain);\n\t\t\treturn -1;\n\t\t}\n\t} break;\n\tcase DNS_T_CNAME: {\n\t\tchar cname[DNS_MAX_CNAME_LEN];\n\t\tret = _dns_decode_CNAME(context, cname, DNS_MAX_CNAME_LEN);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"decode CNAME failed, %s, len: %d:%d\", domain, (int)(context->ptr - context->data),\n\t\t\t\t _dns_left_len(context));\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = dns_add_CNAME(packet, type, domain, ttl, cname);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_ERROR, \"add CNAME failed, %s\", domain);\n\t\t\treturn -1;\n\t\t}\n\t} break;\n\tcase DNS_T_SOA: {\n\t\tstruct dns_soa soa;\n\t\tret = _dns_decode_SOA(context, &soa);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"decode SOA failed, %s\", domain);\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = dns_add_SOA(packet, type, domain, ttl, &soa);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_ERROR, \"add SOA failed, %s\", domain);\n\t\t\treturn -1;\n\t\t}\n\t} break;\n\tcase DNS_T_NS: {\n\t\tchar ns[DNS_MAX_CNAME_LEN];\n\t\tret = _dns_decode_CNAME(context, ns, DNS_MAX_CNAME_LEN);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"decode NS failed, %s\", domain);\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = dns_add_NS(packet, type, domain, ttl, ns);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_ERROR, \"add NS failed, %s\", domain);\n\t\t\treturn -1;\n\t\t}\n\t} break;\n\tcase DNS_T_PTR: {\n\t\tchar name[DNS_MAX_CNAME_LEN];\n\t\tret = _dns_decode_CNAME(context, name, DNS_MAX_CNAME_LEN);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"decode PTR failed, %s\", domain);\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = dns_add_PTR(packet, type, domain, ttl, name);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_ERROR, \"add PTR failed, %s\", domain);\n\t\t\treturn -1;\n\t\t}\n\t} break;\n\tcase DNS_T_AAAA: {\n\t\tunsigned char addr[DNS_RR_AAAA_LEN];\n\t\tret = _dns_decode_raw(context, addr, sizeof(addr));\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"decode AAAA failed, %s\", domain);\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = dns_add_AAAA(packet, type, domain, ttl, addr);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_ERROR, \"add AAAA failed, %s\", domain);\n\t\t\treturn -1;\n\t\t}\n\t} break;\n\tcase DNS_T_OPT: {\n\t\tunsigned char *opt_start = context->ptr;\n\t\tret = _dns_decode_opt(context, type, ttl, rr_len);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"decode opt failed, %s\", domain);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (context->ptr - opt_start != rr_len) {\n\t\t\ttlog(TLOG_DEBUG, \"opt length mismatch, %s\\n\", domain);\n\t\t\treturn -1;\n\t\t}\n\n\t\tdns_set_OPT_payload_size(packet, qclass);\n\t} break;\n\tcase DNS_T_HTTPS: {\n\t\tunsigned char *https_start = context->ptr;\n\t\tret = _dns_decode_HTTPS(context, domain, type, ttl, rr_len);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"decode HTTPS failed, %s\", domain);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (context->ptr - https_start != rr_len) {\n\t\t\ttlog(TLOG_DEBUG, \"opt length mismatch, %s\\n\", domain);\n\t\t\treturn -1;\n\t\t}\n\t} break;\n\tdefault: {\n\t\tunsigned char raw_data[1024];\n\t\tif (_dns_left_len(context) < rr_len || rr_len >= (int)sizeof(raw_data)) {\n\t\t\ttlog(TLOG_DEBUG, \"length mismatch\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = _dns_decode_raw(context, raw_data, rr_len);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"decode A failed, %s\", domain);\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = _dns_add_RAW(packet, type, qtype, domain, ttl, raw_data, rr_len);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_ERROR, \"add raw failed, %s\", domain);\n\t\t\treturn -1;\n\t\t}\n\n\t\ttlog(TLOG_DEBUG, \"DNS type = %d not supported\", qtype);\n\t\tbreak;\n\t}\n\t}\n\n\tif (context->ptr - start != rr_len) {\n\t\ttlog(TLOG_ERROR, \"length mismatch, %s, %ld:%d\", domain, (long)(context->ptr - start), rr_len);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int _dns_encode_qd(struct dns_context *context, struct dns_rrs *rrs)\n{\n\tint ret = 0;\n\tint qtype = 0;\n\tint qclass = 0;\n\tchar domain[DNS_MAX_CNAME_LEN];\n\tstruct dns_context data_context;\n\n\t_dns_init_context_by_rrs(rrs, &data_context);\n\tret = _dns_get_qr_head(&data_context, domain, DNS_MAX_CNAME_LEN, &qtype, &qclass);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tret = _dns_encode_qr_head(context, domain, qtype, qclass);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tif (domain[0] == '-') {\n\t\t/* for google and cloudflare */\n\t\tunsigned char *ptr = context->ptr - 7;\n\t\tmemcpy(ptr, \"\\xC0\\x12\", 2);\n\t\tptr += 2;\n\t\t_dns_write_short(&ptr, qtype);\n\t\t_dns_write_short(&ptr, qclass);\n\t\tcontext->ptr = ptr;\n\t}\n\n\treturn 0;\n}\n\nstatic int _dns_encode_an(struct dns_context *context, struct dns_rrs *rrs)\n{\n\tint ret = 0;\n\tswitch (rrs->type) {\n\tcase DNS_T_A:\n\tcase DNS_T_AAAA: {\n\t\tret = _dns_encode_raw(context, rrs);\n\t\tif (ret < 0) {\n\t\t\treturn -1;\n\t\t}\n\t} break;\n\tcase DNS_T_CNAME:\n\tcase DNS_T_PTR:\n\t\tret = _dns_encode_CNAME(context, rrs);\n\t\tif (ret < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase DNS_T_SOA:\n\t\tret = _dns_encode_SOA(context, rrs);\n\t\tif (ret < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase DNS_T_HTTPS:\n\t\tret = _dns_encode_HTTPS(context, rrs);\n\t\tif (ret < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = _dns_encode_raw(context, rrs);\n\t\tif (ret < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int _dns_decode_body(struct dns_context *context)\n{\n\tstruct dns_packet *packet = context->packet;\n\tstruct dns_head *head = &packet->head;\n\tint i = 0;\n\tint ret = 0;\n\tint count = 0;\n\n\tcount = head->qdcount;\n\thead->qdcount = 0;\n\tfor (i = 0; i < count; i++) {\n\t\tret = _dns_decode_qd(context);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"decode qd failed.\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tcount = head->ancount;\n\thead->ancount = 0;\n\tfor (i = 0; i < count; i++) {\n\t\tret = _dns_decode_an(context, DNS_RRS_AN);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"decode an failed.\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tcount = head->nscount;\n\thead->nscount = 0;\n\tfor (i = 0; i < count; i++) {\n\t\tret = _dns_decode_an(context, DNS_RRS_NS);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"decode ns failed.\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tcount = head->nrcount;\n\thead->nrcount = 0;\n\tfor (i = 0; i < count; i++) {\n\t\tret = _dns_decode_an(context, DNS_RRS_NR);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"decode nr failed.\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int _dns_encode_body(struct dns_context *context)\n{\n\tstruct dns_packet *packet = context->packet;\n\tstruct dns_head *head = &packet->head;\n\tint i = 0;\n\tint len = 0;\n\tstruct dns_rrs *rrs = NULL;\n\tint count = 0;\n\n\trrs = dns_get_rrs_start(packet, DNS_RRS_QD, &count);\n\thead->qdcount = count;\n\tfor (i = 0; i < count && rrs; i++, rrs = dns_get_rrs_next(packet, rrs)) {\n\t\tlen = _dns_encode_qd(context, rrs);\n\t\tif (len < 0) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\trrs = dns_get_rrs_start(packet, DNS_RRS_AN, &count);\n\thead->ancount = count;\n\tfor (i = 0; i < count && rrs; i++, rrs = dns_get_rrs_next(packet, rrs)) {\n\t\tlen = _dns_encode_an(context, rrs);\n\t\tif (len < 0) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\trrs = dns_get_rrs_start(packet, DNS_RRS_NS, &count);\n\thead->nscount = count;\n\tfor (i = 0; i < count && rrs; i++, rrs = dns_get_rrs_next(packet, rrs)) {\n\t\tlen = _dns_encode_an(context, rrs);\n\t\tif (len < 0) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\trrs = dns_get_rrs_start(packet, DNS_RRS_NR, &count);\n\thead->nrcount = count;\n\tfor (i = 0; i < count && rrs; i++, rrs = dns_get_rrs_next(packet, rrs)) {\n\t\tlen = _dns_encode_an(context, rrs);\n\t\tif (len < 0) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\trrs = dns_get_rrs_start(packet, DNS_RRS_OPT, &count);\n\tif (count > 0 || packet->payloadsize > 0) {\n\t\tlen = _dns_encode_opts(packet, context, rrs, count);\n\t\tif (len < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\thead->nrcount++;\n\t}\n\n\treturn 0;\n}\n\nint dns_packet_init(struct dns_packet *packet, int size, struct dns_head *head)\n{\n\tstruct dns_head *init_head = &packet->head;\n\tif (size < (int)sizeof(*packet)) {\n\t\treturn -1;\n\t}\n\n\tmemset(packet, 0, size);\n\tpacket->size = size;\n\tinit_head->id = head->id;\n\tinit_head->qr = head->qr;\n\tinit_head->opcode = head->opcode;\n\tinit_head->aa = head->aa;\n\tinit_head->tc = head->tc;\n\tinit_head->rd = head->rd;\n\tinit_head->ra = head->ra;\n\tinit_head->rcode = head->rcode;\n\tpacket->questions = DNS_RR_END;\n\tpacket->answers = DNS_RR_END;\n\tpacket->nameservers = DNS_RR_END;\n\tpacket->additional = DNS_RR_END;\n\tpacket->optional = DNS_RR_END;\n\tpacket->optcount = 0;\n\tpacket->payloadsize = 0;\n\n\treturn 0;\n}\n\nint dns_decode(struct dns_packet *packet, int maxsize, unsigned char *data, int size)\n{\n\tstruct dns_head *head = &packet->head;\n\tstruct dns_context context;\n\tint ret = 0;\n\n\tmemset(&context, 0, sizeof(context));\n\tmemset(packet, 0, sizeof(*packet));\n\n\tcontext.data = data;\n\tcontext.packet = packet;\n\tcontext.ptr = data;\n\tcontext.maxsize = size;\n\tcontext.namedict = &packet->namedict;\n\n\tret = dns_packet_init(packet, maxsize, head);\n\tif (ret != 0) {\n\t\treturn -1;\n\t}\n\n\tret = _dns_decode_head(&context);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tret = _dns_decode_body(&context);\n\tif (ret < 0) {\n\t\ttlog(TLOG_DEBUG, \"decode body failed.\\n\");\n\t\treturn -1;\n\t}\n\n\tpacket->size = context.ptr - context.data + sizeof(*packet);\n\n\treturn 0;\n}\n\nint dns_encode(unsigned char *data, int size, struct dns_packet *packet)\n{\n\tint ret = 0;\n\tstruct dns_context context;\n\tstruct dns_packet_dict namedict;\n\n\tmemset(&context, 0, sizeof(context));\n\tmemset(&namedict, 0, sizeof(namedict));\n\tcontext.data = data;\n\tcontext.packet = packet;\n\tcontext.ptr = data;\n\tcontext.maxsize = size;\n\tcontext.namedict = &namedict;\n\n\tret = _dns_encode_head(&context);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tret = _dns_encode_body(&context);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tret = _dns_encode_head_count(&context);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\treturn context.ptr - context.data;\n}\n\nstatic int _dns_update_an(struct dns_context *context, dns_rr_type type, struct dns_update_param *param)\n{\n\tint ret = 0;\n\tint qtype = 0;\n\tint qclass = 0;\n\tint ttl = 0;\n\tint rr_len = 0;\n\tchar domain[DNS_MAX_CNAME_LEN];\n\tunsigned char *start = NULL;\n\n\t/* decode rr head */\n\tret = _dns_decode_rr_head(context, domain, DNS_MAX_CNAME_LEN, &qtype, &qclass, &ttl, &rr_len);\n\tif (ret < 0) {\n\t\ttlog(TLOG_DEBUG, \"decode head failed.\");\n\t\treturn -1;\n\t}\n\n\tstart = context->ptr;\n\tswitch (qtype) {\n\tcase DNS_T_OPT:\n\t\tbreak;\n\tdefault: {\n\t\tunsigned char *ttl_ptr = start - sizeof(int) - sizeof(short);\n\t\tif (param->ip_ttl < 0) {\n\t\t\tbreak;\n\t\t}\n\t\t_dns_write_int(&ttl_ptr, param->ip_ttl);\n\t} break;\n\t}\n\tcontext->ptr += rr_len;\n\tif (context->ptr - start != rr_len) {\n\t\ttlog(TLOG_ERROR, \"length mismatch , %s, %ld:%d\", domain, (long)(context->ptr - start), rr_len);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int _dns_update_body(struct dns_context *context, struct dns_update_param *param)\n{\n\tstruct dns_packet *packet = context->packet;\n\tstruct dns_head *head = &packet->head;\n\tint i = 0;\n\tint ret = 0;\n\tint count = 0;\n\n\tcount = head->qdcount;\n\thead->qdcount = 0;\n\tfor (i = 0; i < count; i++) {\n\t\tchar domain[DNS_MAX_CNAME_LEN];\n\t\tint qtype = 0;\n\t\tint qclass = 0;\n\t\tint len = 0;\n\t\tlen = _dns_decode_qr_head(context, domain, DNS_MAX_CNAME_LEN, &qtype, &qclass);\n\t\tif (len < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"update qd failed.\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tcount = head->ancount;\n\thead->ancount = 0;\n\tfor (i = 0; i < count; i++) {\n\t\tret = _dns_update_an(context, DNS_RRS_AN, param);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"update an failed.\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tcount = head->nscount;\n\thead->nscount = 0;\n\tfor (i = 0; i < count; i++) {\n\t\tret = _dns_update_an(context, DNS_RRS_NS, param);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"update ns failed.\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tcount = head->nrcount;\n\thead->nrcount = 0;\n\tfor (i = 0; i < count; i++) {\n\t\tret = _dns_update_an(context, DNS_RRS_NR, param);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"update nr failed.\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int _dns_update_id(unsigned char *data, int size, struct dns_update_param *param)\n{\n\tunsigned char *ptr = data;\n\t_dns_write_short(&ptr, param->id);\n\treturn 0;\n}\n\nint dns_packet_update(unsigned char *data, int size, struct dns_update_param *param)\n{\n\tstruct dns_packet packet;\n\tint maxsize = sizeof(packet);\n\tstruct dns_head *head = &packet.head;\n\tstruct dns_context context;\n\tint ret = 0;\n\n\tmemset(&context, 0, sizeof(context));\n\tmemset(&packet, 0, sizeof(packet));\n\n\tcontext.data = data;\n\tcontext.packet = &packet;\n\tcontext.ptr = data;\n\tcontext.maxsize = size;\n\n\tret = dns_packet_init(&packet, maxsize, head);\n\tif (ret != 0) {\n\t\treturn -1;\n\t}\n\n\tret = _dns_decode_head(&context);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tret = _dns_update_id(data, size, param);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tret = _dns_update_body(&context, param);\n\tif (ret < 0) {\n\t\ttlog(TLOG_DEBUG, \"decode body failed.\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n", "/*************************************************************************\n *\n * Copyright (C) 2018-2023 Ruilin Peng (Nick) <pymumu@gmail.com>.\n *\n * smartdns is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * smartdns is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _DNS_HEAD_H\n#define _DNS_HEAD_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /*__cplusplus */\n\n#define DNS_RR_A_LEN 4\n#define DNS_RR_AAAA_LEN 16\n#define DNS_MAX_CNAME_LEN 256\n#define DNS_MAX_OPT_LEN 256\n#define DNS_IN_PACKSIZE (512 * 8)\n#define DNS_PACKSIZE (512 * 12)\n#define DNS_DEFAULT_PACKET_SIZE 512\n\n#define DNS_ADDR_FAMILY_IP 1\n#define DNS_ADDR_FAMILY_IPV6 2\n\n/*\nDNS parameters:\nhttps://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml\n*/\n\ntypedef enum dns_qr {\n\tDNS_QR_QUERY = 0,\n\tDNS_QR_ANSWER = 1,\n} dns_qr;\n\ntypedef enum dns_rr_type {\n\tDNS_RRS_QD = 0,\n\tDNS_RRS_AN = 1,\n\tDNS_RRS_NS = 2,\n\tDNS_RRS_NR = 3,\n\tDNS_RRS_OPT = 4,\n\tDNS_RRS_END,\n} dns_rr_type;\n\ntypedef enum dns_class {\n\tDNS_C_IN = 1, // DNS C IN\n\tDNS_C_ANY = 255\n} dns_class_t;\n\ntypedef enum dns_type {\n\tDNS_T_A = 1,\n\tDNS_T_NS = 2,\n\tDNS_T_CNAME = 5,\n\tDNS_T_SOA = 6,\n\tDNS_T_PTR = 12,\n\tDNS_T_MX = 15,\n\tDNS_T_TXT = 16,\n\tDNS_T_AAAA = 28,\n\tDNS_T_SRV = 33,\n\tDNS_T_OPT = 41,\n\tDNS_T_SSHFP = 44,\n\tDNS_T_HTTPS = 65,\n\tDNS_T_SPF = 99,\n\tDNS_T_AXFR = 252,\n\tDNS_T_ALL = 255\n} dns_type_t;\n\ntypedef enum dns_opt_code {\n\tDNS_OPT_T_ECS = 8,     // OPT ECS\n\tDNS_OPT_T_COOKIE = 10, // OPT Cookie\n\tDNS_OPT_T_TCP_KEEPALIVE = 11,\n\tDNS_OPT_T_PADDING = 12,\n\tDNS_OPT_T_ALL = 255\n} dns_opt_code_t;\n\n/* https://datatracker.ietf.org/doc/draft-ietf-dnsop-svcb-https/11/ */\ntypedef enum dns_https_svcparam {\n\tDNS_HTTPS_T_MANDATORY = 0,\n\tDNS_HTTPS_T_ALPN = 1,\n\tDNS_HTTPS_T_NO_DEFAULT_ALPN = 2,\n\tDNS_HTTPS_T_PORT = 3,\n\tDNS_HTTPS_T_IPV4HINT = 4,\n\tDNS_HTTPS_T_ECH = 5,\n\tDNS_HTTPS_T_IPV6HINT = 6,\n\tDNS_HTTPS_T_ALL = 255\n} dns_https_svcparam_t;\n\ntypedef enum dns_opcode {\n\tDNS_OP_QUERY = 0,\n\tDNS_OP_IQUERY = 1,\n\tDNS_OP_STATUS = 2,\n\tDNS_OP_NOTIFY = 4,\n\tDNS_OP_UPDATE = 5,\n} dns_opcode_t; /* dns_opcode */\n\ntypedef enum dns_rtcode {\n\tDNS_RC_NOERROR = 0,\n\tDNS_RC_FORMERR = 1,\n\tDNS_RC_SERVFAIL = 2,\n\tDNS_RC_NXDOMAIN = 3,\n\tDNS_RC_NOTIMP = 4,\n\tDNS_RC_REFUSED = 5,\n\tDNS_RC_YXDOMAIN = 6,\n\tDNS_RC_YXRRSET = 7,\n\tDNS_RC_NXRRSET = 8,\n\tDNS_RC_NOTAUTH = 9,\n\tDNS_RC_NOTZONE = 10,\n\t/* EDNS(0) extended RCODEs */\n\tDNS_RC_BADVERS = 16,\n} dns_rtcode_t; /* dns_rcode */\n\n/* dns packet head */\nstruct dns_head {\n\tunsigned short id;      /* identification number */\n\tunsigned short qr;      /* Query/Response Flag */\n\tunsigned short opcode;  /* Operation Code */\n\tunsigned char aa;       /* Authoritative Answer Flag */\n\tunsigned char tc;       /* Truncation Flag */\n\tunsigned char rd;       /* Recursion Desired */\n\tunsigned char ra;       /* Recursion Available */\n\tunsigned short rcode;   /* Response Code */\n\tunsigned short qdcount; /* number of question entries */\n\tunsigned short ancount; /* number of answer entries */\n\tunsigned short nscount; /* number of authority entries */\n\tunsigned short nrcount; /* number of additional resource entries */\n} __attribute__((packed, aligned(2)));\n\n#define DNS_PACKET_DICT_SIZE 16\nstruct dns_packet_dict_item {\n\tunsigned short pos;\n\tunsigned int hash;\n};\n\nstruct dns_packet_dict {\n\tshort dict_count;\n\tstruct dns_packet_dict_item names[DNS_PACKET_DICT_SIZE];\n};\n\n/* packet head */\nstruct dns_packet {\n\tstruct dns_head head;\n\tunsigned short questions;\n\tunsigned short answers;\n\tunsigned short nameservers;\n\tunsigned short additional;\n\tunsigned short optcount;\n\tunsigned short optional;\n\tunsigned short payloadsize;\n\tstruct dns_packet_dict namedict;\n\tint size;\n\tint len;\n\tunsigned char data[0];\n};\n\nstruct dns_rrs {\n\tstruct dns_packet *packet;\n\tunsigned short next;\n\tunsigned short len;\n\tint type;\n\tunsigned char data[0];\n};\n\n/* packet encode/decode context */\nstruct dns_context {\n\tstruct dns_packet *packet;\n\tstruct dns_packet_dict *namedict;\n\tunsigned char *data;\n\tint maxsize;\n\tunsigned char *ptr;\n};\n\n/* SOA data */\nstruct dns_soa {\n\tchar mname[DNS_MAX_CNAME_LEN];\n\tchar rname[DNS_MAX_CNAME_LEN];\n\tunsigned int serial;\n\tunsigned int refresh;\n\tunsigned int retry;\n\tunsigned int expire;\n\tunsigned int minimum;\n} __attribute__((packed));\n\n#define DNS_OPT_ECS_FAMILY_IPV4 1\n#define DNS_OPT_ECS_FAMILY_IPV6 2\n\n/* OPT ECS */\nstruct dns_opt_ecs {\n\tunsigned short family;\n\tunsigned char source_prefix;\n\tunsigned char scope_prefix;\n\tunsigned char addr[DNS_RR_AAAA_LEN];\n} __attribute__((packed));\n\n/* OPT COOKIE */\nstruct dns_opt_cookie {\n\tchar server_cookie_len;\n\tunsigned char client_cookie[8];\n\tunsigned char server_cookie[32];\n};\n\n/* OPT */\nstruct dns_opt {\n\tunsigned short code;\n\tunsigned short length;\n\tunsigned char data[0];\n} __attribute__((packed));\n\nstruct dns_rr_nested {\n\tstruct dns_context context;\n\tunsigned char *rr_start;\n\tunsigned char *rr_len_ptr;\n\tunsigned short rr_head_len;\n\tdns_rr_type type;\n};\n\nstruct dns_https_param {\n\tunsigned short key;\n\tunsigned short len;\n\tunsigned char value[0];\n};\n\nstruct dns_rrs *dns_get_rrs_next(struct dns_packet *packet, struct dns_rrs *rrs);\nstruct dns_rrs *dns_get_rrs_start(struct dns_packet *packet, dns_rr_type type, int *count);\n\nstruct dns_rr_nested *dns_add_rr_nested_start(struct dns_rr_nested *rr_nested_buffer, struct dns_packet *packet,\n\t\t\t\t\t\t\t\t\t\t\t  dns_rr_type type, dns_type_t rtype, const char *domain, int ttl);\nint dns_add_rr_nested_end(struct dns_rr_nested *rr_nested, dns_type_t rtype);\nint dns_add_rr_nested_memcpy(struct dns_rr_nested *rr_nested, void *data, int data_len);\n\nvoid *dns_get_rr_nested_start(struct dns_rrs *rrs, char *domain, int maxsize, int *qtype, int *ttl, int *rr_len);\nvoid *dns_get_rr_nested_next(struct dns_rrs *rrs, void *rr_nested, int rr_nested_len);\n\n/*\n * Question\n */\nint dns_add_domain(struct dns_packet *packet, const char *domain, int qtype, int qclass);\nint dns_get_domain(struct dns_rrs *rrs, char *domain, int maxsize, int *qtype, int *qclass);\n\n/*\n * Answers\n */\nint dns_add_CNAME(struct dns_packet *packet, dns_rr_type type, const char *domain, int ttl, const char *cname);\nint dns_get_CNAME(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl, char *cname, int cname_size);\n\nint dns_add_A(struct dns_packet *packet, dns_rr_type type, const char *domain, int ttl,\n\t\t\t  unsigned char addr[DNS_RR_A_LEN]);\nint dns_get_A(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl, unsigned char addr[DNS_RR_A_LEN]);\n\nint dns_add_PTR(struct dns_packet *packet, dns_rr_type type, const char *domain, int ttl, const char *cname);\nint dns_get_PTR(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl, char *cname, int cname_size);\n\nint dns_add_AAAA(struct dns_packet *packet, dns_rr_type type, const char *domain, int ttl,\n\t\t\t\t unsigned char addr[DNS_RR_AAAA_LEN]);\nint dns_get_AAAA(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl, unsigned char addr[DNS_RR_AAAA_LEN]);\n\nint dns_add_SOA(struct dns_packet *packet, dns_rr_type type, const char *domain, int ttl, struct dns_soa *soa);\nint dns_get_SOA(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl, struct dns_soa *soa);\n\nint dns_add_NS(struct dns_packet *packet, dns_rr_type type, const char *domain, int ttl, const char *cname);\nint dns_get_NS(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl, char *cname, int cname_size);\n\nint dns_set_OPT_payload_size(struct dns_packet *packet, int payload_size);\nint dns_get_OPT_payload_size(struct dns_packet *packet);\n\nint dns_add_OPT_ECS(struct dns_packet *packet, struct dns_opt_ecs *ecs);\nint dns_get_OPT_ECS(struct dns_rrs *rrs, unsigned short *opt_code, unsigned short *opt_len, struct dns_opt_ecs *ecs);\n\nint dns_add_OPT_TCP_KEEPALIVE(struct dns_packet *packet, unsigned short timeout);\nint dns_get_OPT_TCP_KEEPALIVE(struct dns_rrs *rrs, unsigned short *opt_code, unsigned short *opt_len,\n\t\t\t\t\t\t\t  unsigned short *timeout);\n\nint dns_add_HTTPS_start(struct dns_rr_nested *svcparam_buffer, struct dns_packet *packet, dns_rr_type type,\n\t\t\t\t\t\tconst char *domain, int ttl, int priority, const char *target);\nint dns_HTTPS_add_raw(struct dns_rr_nested *svcparam, unsigned short key, unsigned char *value, unsigned short len);\nint dns_HTTPS_add_port(struct dns_rr_nested *svcparam, unsigned short port);\nint dns_HTTPS_add_alpn(struct dns_rr_nested *svcparam, const char *alpn);\nint dns_HTTPS_add_no_default_alpn(struct dns_rr_nested *svcparam);\nint dns_HTTPS_add_ipv4hint(struct dns_rr_nested *svcparam, unsigned char addr[][DNS_RR_A_LEN], int addr_num);\nint dns_HTTPS_add_ipv6hint(struct dns_rr_nested *svcparam, unsigned char addr[][DNS_RR_AAAA_LEN], int addr_num);\nint dns_HTTPS_add_ech(struct dns_rr_nested *svcparam, void *ech, int ech_len);\nint dns_add_HTTPS_end(struct dns_rr_nested *svcparam);\n\nstruct dns_https_param *dns_get_HTTPS_svcparm_start(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl,\n\t\t\t\t\t\t\t\t\t\t\t\t\tint *priority, char *target, int target_size);\nstruct dns_https_param *dns_get_HTTPS_svcparm_next(struct dns_rrs *rrs, struct dns_https_param *parm);\n\n/*\n * Packet operation\n */\nint dns_decode(struct dns_packet *packet, int maxsize, unsigned char *data, int size);\nint dns_encode(unsigned char *data, int size, struct dns_packet *packet);\n\nint dns_packet_init(struct dns_packet *packet, int size, struct dns_head *head);\n\nstruct dns_update_param {\n\tint id;\n\tint ip_ttl;\n\tint cname_ttl;\n};\n\nint dns_packet_update(unsigned char *data, int size, struct dns_update_param *param);\n\n#ifdef __cplusplus\n}\n#endif /*__cplusplus */\n#endif\n", "/*************************************************************************\n *\n * Copyright (C) 2018-2023 Ruilin Peng (Nick) <pymumu@gmail.com>.\n *\n * smartdns is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * smartdns is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#include <stdio.h>\n#endif\n#include \"dns_conf.h\"\n#include \"tlog.h\"\n#include \"util.h\"\n#include <arpa/inet.h>\n#include <ctype.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <libgen.h>\n#include <linux/capability.h>\n#include <linux/limits.h>\n#include <linux/netlink.h>\n#include <linux/rtnetlink.h>\n#include <netinet/tcp.h>\n#include <openssl/crypto.h>\n#include <openssl/ssl.h>\n#include <openssl/x509v3.h>\n#include <pthread.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <sys/sysinfo.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <time.h>\n#include <unistd.h>\n#include <unwind.h>\n\n#define TMP_BUFF_LEN_32 32\n\n#define NFNL_SUBSYS_IPSET 6\n\n#define IPSET_ATTR_DATA 7\n#define IPSET_ATTR_IP 1\n#define IPSET_ATTR_IPADDR_IPV4 1\n#define IPSET_ATTR_IPADDR_IPV6 2\n#define IPSET_ATTR_PROTOCOL 1\n#define IPSET_ATTR_SETNAME 2\n#define IPSET_ATTR_TIMEOUT 6\n#define IPSET_ADD 9\n#define IPSET_DEL 10\n#define IPSET_MAXNAMELEN 32\n#define IPSET_PROTOCOL 6\n\n#define IPV6_ADDR_LEN 16\n#define IPV4_ADDR_LEN 4\n\n#ifndef NFNETLINK_V0\n#define NFNETLINK_V0 0\n#endif\n\n#ifndef NLA_F_NESTED\n#define NLA_F_NESTED (1 << 15)\n#endif\n\n#ifndef NLA_F_NET_BYTEORDER\n#define NLA_F_NET_BYTEORDER (1 << 14)\n#endif\n\n#define NETLINK_ALIGN(len) (((len) + 3) & ~(3))\n\n#define BUFF_SZ 1024\n#define PACKET_BUF_SIZE 8192\n#define PACKET_MAGIC 0X11040918\n\nstruct ipset_netlink_attr {\n\tunsigned short len;\n\tunsigned short type;\n};\n\nstruct ipset_netlink_msg {\n\tunsigned char family;\n\tunsigned char version;\n\t__be16 res_id;\n};\n\nstatic int ipset_fd;\nstatic int pidfile_fd;\n\nunsigned long get_tick_count(void)\n{\n\tstruct timespec ts;\n\n\tclock_gettime(CLOCK_MONOTONIC, &ts);\n\n\treturn (ts.tv_sec * 1000 + ts.tv_nsec / 1000000);\n}\n\nchar *dir_name(char *path)\n{\n\tif (strstr(path, \"/\") == NULL) {\n\t\tsafe_strncpy(path, \"./\", PATH_MAX);\n\t\treturn path;\n\t}\n\n\treturn dirname(path);\n}\n\nchar *get_host_by_addr(char *host, int maxsize, struct sockaddr *addr)\n{\n\tstruct sockaddr_storage *addr_store = (struct sockaddr_storage *)addr;\n\thost[0] = 0;\n\tswitch (addr_store->ss_family) {\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *addr_in = NULL;\n\t\taddr_in = (struct sockaddr_in *)addr;\n\t\tinet_ntop(AF_INET, &addr_in->sin_addr, host, maxsize);\n\t} break;\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *addr_in6 = NULL;\n\t\taddr_in6 = (struct sockaddr_in6 *)addr;\n\t\tif (IN6_IS_ADDR_V4MAPPED(&addr_in6->sin6_addr)) {\n\t\t\tstruct sockaddr_in addr_in4;\n\t\t\tmemset(&addr_in4, 0, sizeof(addr_in4));\n\t\t\tmemcpy(&addr_in4.sin_addr.s_addr, addr_in6->sin6_addr.s6_addr + 12, sizeof(addr_in4.sin_addr.s_addr));\n\t\t\tinet_ntop(AF_INET, &addr_in4.sin_addr, host, maxsize);\n\t\t} else {\n\t\t\tinet_ntop(AF_INET6, &addr_in6->sin6_addr, host, maxsize);\n\t\t}\n\t} break;\n\tdefault:\n\t\tgoto errout;\n\t\tbreak;\n\t}\n\treturn host;\nerrout:\n\treturn NULL;\n}\n\nint getaddr_by_host(const char *host, struct sockaddr *addr, socklen_t *addr_len)\n{\n\tstruct addrinfo hints;\n\tstruct addrinfo *result = NULL;\n\tint ret = 0;\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = AF_UNSPEC;\n\thints.ai_socktype = SOCK_STREAM;\n\n\tret = getaddrinfo(host, \"53\", &hints, &result);\n\tif (ret != 0) {\n\t\tgoto errout;\n\t}\n\n\tif (result->ai_addrlen > *addr_len) {\n\t\tresult->ai_addrlen = *addr_len;\n\t}\n\n\taddr->sa_family = result->ai_family;\n\tmemcpy(addr, result->ai_addr, result->ai_addrlen);\n\t*addr_len = result->ai_addrlen;\n\n\tfreeaddrinfo(result);\n\n\treturn 0;\nerrout:\n\tif (result) {\n\t\tfreeaddrinfo(result);\n\t}\n\treturn -1;\n}\n\nint getsocket_inet(int fd, struct sockaddr *addr, socklen_t *addr_len)\n{\n\tstruct sockaddr_storage addr_store;\n\tsocklen_t addr_store_len = sizeof(addr_store);\n\tif (getsockname(fd, (struct sockaddr *)&addr_store, &addr_store_len) != 0) {\n\t\tgoto errout;\n\t}\n\n\tswitch (addr_store.ss_family) {\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *addr_in = NULL;\n\t\taddr_in = (struct sockaddr_in *)addr;\n\t\taddr_in->sin_family = AF_INET;\n\t\t*addr_len = sizeof(struct sockaddr_in);\n\t\tmemcpy(addr, addr_in, sizeof(struct sockaddr_in));\n\t} break;\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *addr_in6 = NULL;\n\t\taddr_in6 = (struct sockaddr_in6 *)addr;\n\t\tif (IN6_IS_ADDR_V4MAPPED(&addr_in6->sin6_addr)) {\n\t\t\tstruct sockaddr_in addr_in4;\n\t\t\tmemset(&addr_in4, 0, sizeof(addr_in4));\n\t\t\tmemcpy(&addr_in4.sin_addr.s_addr, addr_in6->sin6_addr.s6_addr + 12, sizeof(addr_in4.sin_addr.s_addr));\n\t\t\taddr_in4.sin_family = AF_INET;\n\t\t\taddr_in4.sin_port = 0;\n\t\t\t*addr_len = sizeof(struct sockaddr_in);\n\t\t\tmemcpy(addr, &addr_in4, sizeof(struct sockaddr_in));\n\t\t} else {\n\t\t\taddr_in6->sin6_family = AF_INET6;\n\t\t\t*addr_len = sizeof(struct sockaddr_in6);\n\t\t\tmemcpy(addr, addr_in6, sizeof(struct sockaddr_in6));\n\t\t}\n\t} break;\n\tdefault:\n\t\tgoto errout;\n\t\tbreak;\n\t}\n\treturn 0;\nerrout:\n\treturn -1;\n}\n\nint fill_sockaddr_by_ip(unsigned char *ip, int ip_len, int port, struct sockaddr *addr, socklen_t *addr_len)\n{\n\tif (ip == NULL || addr == NULL || addr_len == NULL) {\n\t\treturn -1;\n\t}\n\n\tif (ip_len == IPV4_ADDR_LEN) {\n\t\tstruct sockaddr_in *addr_in = NULL;\n\t\taddr->sa_family = AF_INET;\n\t\taddr_in = (struct sockaddr_in *)addr;\n\t\taddr_in->sin_port = htons(port);\n\t\taddr_in->sin_family = AF_INET;\n\t\tmemcpy(&addr_in->sin_addr.s_addr, ip, ip_len);\n\t\t*addr_len = 16;\n\t} else if (ip_len == IPV6_ADDR_LEN) {\n\t\tstruct sockaddr_in6 *addr_in6 = NULL;\n\t\taddr->sa_family = AF_INET6;\n\t\taddr_in6 = (struct sockaddr_in6 *)addr;\n\t\taddr_in6->sin6_port = htons(port);\n\t\taddr_in6->sin6_family = AF_INET6;\n\t\tmemcpy(addr_in6->sin6_addr.s6_addr, ip, ip_len);\n\t\t*addr_len = 28;\n\t}\n\n\treturn -1;\n}\n\nint parse_ip(const char *value, char *ip, int *port)\n{\n\tint offset = 0;\n\tchar *colon = NULL;\n\n\tcolon = strstr(value, \":\");\n\n\tif (strstr(value, \"[\")) {\n\t\t/* ipv6 with port */\n\t\tchar *bracket_end = strstr(value, \"]\");\n\t\tif (bracket_end == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\toffset = bracket_end - value - 1;\n\t\tmemcpy(ip, value + 1, offset);\n\t\tip[offset] = 0;\n\n\t\tcolon = strstr(bracket_end, \":\");\n\t\tif (colon) {\n\t\t\tcolon++;\n\t\t}\n\t} else if (colon && strstr(colon + 1, \":\")) {\n\t\t/* ipv6 without port */\n\t\tstrncpy(ip, value, MAX_IP_LEN);\n\t\tcolon = NULL;\n\t} else {\n\t\t/* ipv4 */\n\t\tcolon = strstr(value, \":\");\n\t\tif (colon == NULL) {\n\t\t\t/* without port */\n\t\t\tstrncpy(ip, value, MAX_IP_LEN);\n\t\t} else {\n\t\t\t/* with port */\n\t\t\toffset = colon - value;\n\t\t\tcolon++;\n\t\t\tmemcpy(ip, value, offset);\n\t\t\tip[offset] = 0;\n\t\t}\n\t}\n\n\tif (colon) {\n\t\t/* get port num */\n\t\t*port = atoi(colon);\n\t} else {\n\t\t*port = PORT_NOT_DEFINED;\n\t}\n\n\tif (ip[0] == 0) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint check_is_ipv4(const char *ip)\n{\n\tconst char *ptr = ip;\n\tchar c = 0;\n\tint dot_num = 0;\n\tint dig_num = 0;\n\n\twhile ((c = *ptr++) != '\\0') {\n\t\tif (c == '.') {\n\t\t\tdot_num++;\n\t\t\tdig_num = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* check number count of one field */\n\t\tif (dig_num >= 4) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (c >= '0' && c <= '9') {\n\t\t\tdig_num++;\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\t/* check field number */\n\tif (dot_num != 3) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint check_is_ipv6(const char *ip)\n{\n\tconst char *ptr = ip;\n\tchar c = 0;\n\tint colon_num = 0;\n\tint dig_num = 0;\n\n\twhile ((c = *ptr++) != '\\0') {\n\t\tif (c == '[' || c == ']') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (c == ':') {\n\t\t\tcolon_num++;\n\t\t\tdig_num = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* check number count of one field */\n\t\tif (dig_num >= 5) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tdig_num++;\n\t\tif (c >= '0' && c <= '9') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (c >= 'a' && c <= 'f') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (c >= 'A' && c <= 'F') {\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\t/* check field number */\n\tif (colon_num > 7) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\nint check_is_ipaddr(const char *ip)\n{\n\tif (strstr(ip, \".\")) {\n\t\t/* IPV4 */\n\t\treturn check_is_ipv4(ip);\n\t} else if (strstr(ip, \":\")) {\n\t\t/* IPV6 */\n\t\treturn check_is_ipv6(ip);\n\t}\n\treturn -1;\n}\n\nint parse_uri(const char *value, char *scheme, char *host, int *port, char *path)\n{\n\treturn parse_uri_ext(value, scheme, NULL, NULL, host, port, path);\n}\n\nvoid urldecode(char *dst, const char *src)\n{\n\tchar a, b;\n\twhile (*src) {\n\t\tif ((*src == '%') && ((a = src[1]) && (b = src[2])) && (isxdigit(a) && isxdigit(b))) {\n\t\t\tif (a >= 'a') {\n\t\t\t\ta -= 'a' - 'A';\n\t\t\t}\n\n\t\t\tif (a >= 'A') {\n\t\t\t\ta -= ('A' - 10);\n\t\t\t} else {\n\t\t\t\ta -= '0';\n\t\t\t}\n\n\t\t\tif (b >= 'a') {\n\t\t\t\tb -= 'a' - 'A';\n\t\t\t}\n\n\t\t\tif (b >= 'A') {\n\t\t\t\tb -= ('A' - 10);\n\t\t\t} else {\n\t\t\t\tb -= '0';\n\t\t\t}\n\t\t\t*dst++ = 16 * a + b;\n\t\t\tsrc += 3;\n\t\t} else if (*src == '+') {\n\t\t\t*dst++ = ' ';\n\t\t\tsrc++;\n\t\t} else {\n\t\t\t*dst++ = *src++;\n\t\t}\n\t}\n\t*dst++ = '\\0';\n}\n\nint parse_uri_ext(const char *value, char *scheme, char *user, char *password, char *host, int *port, char *path)\n{\n\tchar *scheme_end = NULL;\n\tint field_len = 0;\n\tconst char *process_ptr = value;\n\tchar user_pass_host_part[PATH_MAX];\n\tchar *user_password = NULL;\n\tchar *host_part = NULL;\n\n\tconst char *host_end = NULL;\n\n\tscheme_end = strstr(value, \"://\");\n\tif (scheme_end) {\n\t\tfield_len = scheme_end - value;\n\t\tif (scheme) {\n\t\t\tmemcpy(scheme, value, field_len);\n\t\t\tscheme[field_len] = 0;\n\t\t}\n\t\tprocess_ptr += field_len + 3;\n\t} else {\n\t\tif (scheme) {\n\t\t\tscheme[0] = '\\0';\n\t\t}\n\t}\n\n\thost_end = strstr(process_ptr, \"/\");\n\tif (host_end == NULL) {\n\t\thost_end = process_ptr + strlen(process_ptr);\n\t};\n\n\tfield_len = host_end - process_ptr;\n\tif (field_len >= (int)sizeof(user_pass_host_part)) {\n\t\treturn -1;\n\t}\n\tmemcpy(user_pass_host_part, process_ptr, field_len);\n\tuser_pass_host_part[field_len] = 0;\n\n\thost_part = strstr(user_pass_host_part, \"@\");\n\tif (host_part != NULL) {\n\t\t*host_part = '\\0';\n\t\thost_part = host_part + 1;\n\t\tuser_password = user_pass_host_part;\n\t\tchar *sep = strstr(user_password, \":\");\n\t\tif (sep != NULL) {\n\t\t\t*sep = '\\0';\n\t\t\tsep = sep + 1;\n\t\t\tif (password) {\n\t\t\t\turldecode(password, sep);\n\t\t\t}\n\t\t}\n\t\tif (user) {\n\t\t\turldecode(user, user_password);\n\t\t}\n\t} else {\n\t\thost_part = user_pass_host_part;\n\t}\n\n\tif (host != NULL && parse_ip(host_part, host, port) != 0) {\n\t\treturn -1;\n\t}\n\n\tprocess_ptr += field_len;\n\n\tif (path) {\n\t\tstrcpy(path, process_ptr);\n\t}\n\treturn 0;\n}\n\nint set_fd_nonblock(int fd, int nonblock)\n{\n\tint ret = 0;\n\tint flags = fcntl(fd, F_GETFL);\n\n\tif (flags == -1) {\n\t\treturn -1;\n\t}\n\n\tflags = (nonblock) ? (flags | O_NONBLOCK) : (flags & ~O_NONBLOCK);\n\tret = fcntl(fd, F_SETFL, flags);\n\tif (ret == -1) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nchar *reverse_string(char *output, const char *input, int len, int to_lower_case)\n{\n\tchar *begin = output;\n\tif (len <= 0) {\n\t\t*output = 0;\n\t\treturn output;\n\t}\n\n\tlen--;\n\twhile (len >= 0) {\n\t\t*output = *(input + len);\n\t\tif (to_lower_case) {\n\t\t\tif (*output >= 'A' && *output <= 'Z') {\n\t\t\t\t/* To lower case */\n\t\t\t\t*output = *output + 32;\n\t\t\t}\n\t\t}\n\t\toutput++;\n\t\tlen--;\n\t}\n\n\t*output = 0;\n\n\treturn begin;\n}\n\nchar *to_lower_case(char *output, const char *input, int len)\n{\n\tchar *begin = output;\n\tint i = 0;\n\tif (len <= 0) {\n\t\t*output = 0;\n\t\treturn output;\n\t}\n\n\tlen--;\n\twhile (i < len && *(input + i) != '\\0') {\n\t\t*output = *(input + i);\n\t\tif (*output >= 'A' && *output <= 'Z') {\n\t\t\t/* To lower case */\n\t\t\t*output = *output + 32;\n\t\t}\n\t\toutput++;\n\t\ti++;\n\t}\n\n\t*output = 0;\n\n\treturn begin;\n}\n\nstatic inline void _ipset_add_attr(struct nlmsghdr *netlink_head, uint16_t type, size_t len, const void *data)\n{\n\tstruct ipset_netlink_attr *attr = (void *)netlink_head + NETLINK_ALIGN(netlink_head->nlmsg_len);\n\tuint16_t payload_len = NETLINK_ALIGN(sizeof(struct ipset_netlink_attr)) + len;\n\tattr->type = type;\n\tattr->len = payload_len;\n\tmemcpy((void *)attr + NETLINK_ALIGN(sizeof(struct ipset_netlink_attr)), data, len);\n\tnetlink_head->nlmsg_len += NETLINK_ALIGN(payload_len);\n}\n\nstatic int _ipset_socket_init(void)\n{\n\tif (ipset_fd > 0) {\n\t\treturn 0;\n\t}\n\n\tipset_fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_NETFILTER);\n\n\tif (ipset_fd < 0) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int _ipset_support_timeout(void)\n{\n\tif (dns_conf_ipset_timeout_enable) {\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\nstatic int _ipset_operate(const char *ipset_name, const unsigned char addr[], int addr_len, unsigned long timeout,\n\t\t\t\t\t\t  int operate)\n{\n\tstruct nlmsghdr *netlink_head = NULL;\n\tstruct ipset_netlink_msg *netlink_msg = NULL;\n\tstruct ipset_netlink_attr *nested[3];\n\tchar buffer[BUFF_SZ];\n\tuint8_t proto = 0;\n\tssize_t rc = 0;\n\tint af = 0;\n\tstatic const struct sockaddr_nl snl = {.nl_family = AF_NETLINK};\n\tuint32_t expire = 0;\n\n\tif (addr_len != IPV4_ADDR_LEN && addr_len != IPV6_ADDR_LEN) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif (addr_len == IPV4_ADDR_LEN) {\n\t\taf = AF_INET;\n\t} else if (addr_len == IPV6_ADDR_LEN) {\n\t\taf = AF_INET6;\n\t} else {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif (_ipset_socket_init() != 0) {\n\t\treturn -1;\n\t}\n\n\tif (strlen(ipset_name) >= IPSET_MAXNAMELEN) {\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\n\tmemset(buffer, 0, BUFF_SZ);\n\n\tnetlink_head = (struct nlmsghdr *)buffer;\n\tnetlink_head->nlmsg_len = NETLINK_ALIGN(sizeof(struct nlmsghdr));\n\tnetlink_head->nlmsg_type = operate | (NFNL_SUBSYS_IPSET << 8);\n\tnetlink_head->nlmsg_flags = NLM_F_REQUEST | NLM_F_REPLACE;\n\n\tnetlink_msg = (struct ipset_netlink_msg *)(buffer + netlink_head->nlmsg_len);\n\tnetlink_head->nlmsg_len += NETLINK_ALIGN(sizeof(struct ipset_netlink_msg));\n\tnetlink_msg->family = af;\n\tnetlink_msg->version = NFNETLINK_V0;\n\tnetlink_msg->res_id = htons(0);\n\n\tproto = IPSET_PROTOCOL;\n\t_ipset_add_attr(netlink_head, IPSET_ATTR_PROTOCOL, sizeof(proto), &proto);\n\t_ipset_add_attr(netlink_head, IPSET_ATTR_SETNAME, strlen(ipset_name) + 1, ipset_name);\n\n\tnested[0] = (struct ipset_netlink_attr *)(buffer + NETLINK_ALIGN(netlink_head->nlmsg_len));\n\tnetlink_head->nlmsg_len += NETLINK_ALIGN(sizeof(struct ipset_netlink_attr));\n\tnested[0]->type = NLA_F_NESTED | IPSET_ATTR_DATA;\n\tnested[1] = (struct ipset_netlink_attr *)(buffer + NETLINK_ALIGN(netlink_head->nlmsg_len));\n\tnetlink_head->nlmsg_len += NETLINK_ALIGN(sizeof(struct ipset_netlink_attr));\n\tnested[1]->type = NLA_F_NESTED | IPSET_ATTR_IP;\n\n\t_ipset_add_attr(netlink_head,\n\t\t\t\t\t(af == AF_INET ? IPSET_ATTR_IPADDR_IPV4 : IPSET_ATTR_IPADDR_IPV6) | NLA_F_NET_BYTEORDER, addr_len,\n\t\t\t\t\taddr);\n\tnested[1]->len = (void *)buffer + NETLINK_ALIGN(netlink_head->nlmsg_len) - (void *)nested[1];\n\n\tif (timeout > 0 && _ipset_support_timeout() == 0) {\n\t\texpire = htonl(timeout);\n\t\t_ipset_add_attr(netlink_head, IPSET_ATTR_TIMEOUT | NLA_F_NET_BYTEORDER, sizeof(expire), &expire);\n\t}\n\n\tnested[0]->len = (void *)buffer + NETLINK_ALIGN(netlink_head->nlmsg_len) - (void *)nested[0];\n\n\tfor (;;) {\n\t\trc = sendto(ipset_fd, buffer, netlink_head->nlmsg_len, 0, (const struct sockaddr *)&snl, sizeof(snl));\n\t\tif (rc >= 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR) {\n\t\t\tstruct timespec waiter;\n\t\t\twaiter.tv_sec = 0;\n\t\t\twaiter.tv_nsec = 10000;\n\t\t\tnanosleep(&waiter, NULL);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nint ipset_add(const char *ipset_name, const unsigned char addr[], int addr_len, unsigned long timeout)\n{\n\treturn _ipset_operate(ipset_name, addr, addr_len, timeout, IPSET_ADD);\n}\n\nint ipset_del(const char *ipset_name, const unsigned char addr[], int addr_len)\n{\n\treturn _ipset_operate(ipset_name, addr, addr_len, 0, IPSET_DEL);\n}\n\nunsigned char *SSL_SHA256(const unsigned char *d, size_t n, unsigned char *md)\n{\n\tstatic unsigned char m[SHA256_DIGEST_LENGTH];\n\n\tif (md == NULL) {\n\t\tmd = m;\n\t}\n\n\tEVP_MD_CTX *ctx = EVP_MD_CTX_create();\n\tif (ctx == NULL) {\n\t\treturn NULL;\n\t}\n\n\tEVP_MD_CTX_init(ctx);\n\tEVP_DigestInit_ex(ctx, EVP_sha256(), NULL);\n\tEVP_DigestUpdate(ctx, d, n);\n\tEVP_DigestFinal_ex(ctx, m, NULL);\n\tEVP_MD_CTX_destroy(ctx);\n\n\treturn (md);\n}\n\nint SSL_base64_decode(const char *in, unsigned char *out)\n{\n\tsize_t inlen = strlen(in);\n\tint outlen = 0;\n\n\tif (inlen == 0) {\n\t\treturn 0;\n\t}\n\n\toutlen = EVP_DecodeBlock(out, (unsigned char *)in, inlen);\n\tif (outlen < 0) {\n\t\tgoto errout;\n\t}\n\n\t/* Subtract padding bytes from |outlen| */\n\twhile (in[--inlen] == '=') {\n\t\t--outlen;\n\t}\n\n\treturn outlen;\nerrout:\n\treturn -1;\n}\n\nint SSL_base64_encode(const void *in, int in_len, char *out)\n{\n\tint outlen = 0;\n\n\tif (in_len == 0) {\n\t\treturn 0;\n\t}\n\n\toutlen = EVP_EncodeBlock((unsigned char *)out, in, in_len);\n\tif (outlen < 0) {\n\t\tgoto errout;\n\t}\n\n\treturn outlen;\nerrout:\n\treturn -1;\n}\n\nint create_pid_file(const char *pid_file)\n{\n\tint fd = 0;\n\tint flags = 0;\n\tchar buff[TMP_BUFF_LEN_32];\n\n\t/*  create pid file, and lock this file */\n\tfd = open(pid_file, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);\n\tif (fd == -1) {\n\t\tfprintf(stderr, \"create pid file failed, %s\\n\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tflags = fcntl(fd, F_GETFD);\n\tif (flags < 0) {\n\t\tfprintf(stderr, \"Could not get flags for PID file %s\\n\", pid_file);\n\t\tgoto errout;\n\t}\n\n\tflags |= FD_CLOEXEC;\n\tif (fcntl(fd, F_SETFD, flags) == -1) {\n\t\tfprintf(stderr, \"Could not set flags for PID file %s\\n\", pid_file);\n\t\tgoto errout;\n\t}\n\n\tif (lockf(fd, F_TLOCK, 0) < 0) {\n\t\tfprintf(stderr, \"Server is already running.\\n\");\n\t\tgoto errout;\n\t}\n\n\tsnprintf(buff, TMP_BUFF_LEN_32, \"%d\\n\", getpid());\n\n\tif (write(fd, buff, strnlen(buff, TMP_BUFF_LEN_32)) < 0) {\n\t\tfprintf(stderr, \"write pid to file failed, %s.\\n\", strerror(errno));\n\t\tgoto errout;\n\t}\n\n\tif (pidfile_fd > 0) {\n\t\tclose(pidfile_fd);\n\t}\n\n\tpidfile_fd = fd;\n\n\treturn 0;\nerrout:\n\tif (fd > 0) {\n\t\tclose(fd);\n\t}\n\treturn -1;\n}\n\nint generate_cert_key(const char *key_path, const char *cert_path, const char *san, int days)\n{\n\tint ret = -1;\n#if (OPENSSL_VERSION_NUMBER <= 0x30000000L)\n\tRSA *rsa = NULL;\n\tBIGNUM *bn = NULL;\n#endif\n\tX509_EXTENSION *cert_ext = NULL;\n\tBIO *cert_file = NULL;\n\tBIO *key_file = NULL;\n\tX509 *cert = NULL;\n\tEVP_PKEY *pkey = NULL;\n\tconst int RSA_KEY_LENGTH = 2048;\n\n\tif (key_path == NULL || cert_path == NULL) {\n\t\treturn ret;\n\t}\n\n\tkey_file = BIO_new_file(key_path, \"wb\");\n\tcert_file = BIO_new_file(cert_path, \"wb\");\n\tcert = X509_new();\n#if (OPENSSL_VERSION_NUMBER >= 0x30000000L)\n\tpkey = EVP_RSA_gen(RSA_KEY_LENGTH);\n#else\n\tbn = BN_new();\n\trsa = RSA_new();\n\tpkey = EVP_PKEY_new();\n\tif (rsa == NULL || pkey == NULL || bn == NULL) {\n\t\tgoto out;\n\t}\n\n\tEVP_PKEY_assign(pkey, EVP_PKEY_RSA, rsa);\n\tBN_set_word(bn, RSA_F4);\n\tif (RSA_generate_key_ex(rsa, RSA_KEY_LENGTH, bn, NULL) != 1) {\n\t\tgoto out;\n\t}\n#endif\n\n\tif (key_file == NULL || cert_file == NULL || cert == NULL || pkey == NULL) {\n\t\tgoto out;\n\t}\n\n\tASN1_INTEGER_set(X509_get_serialNumber(cert), 1);           // serial number\n\tX509_gmtime_adj(X509_get_notBefore(cert), 0);               // now\n\tX509_gmtime_adj(X509_get_notAfter(cert), days * 24 * 3600); // accepts secs\n\n\tX509_set_pubkey(cert, pkey);\n\n\tX509_NAME *name = X509_get_subject_name(cert);\n\n\tconst unsigned char *country = (unsigned char *)\"smartdns\";\n\tconst unsigned char *company = (unsigned char *)\"smartdns\";\n\tconst unsigned char *common_name = (unsigned char *)\"smartdns\";\n\n\tX509_NAME_add_entry_by_txt(name, \"C\", MBSTRING_ASC, country, -1, -1, 0);\n\tX509_NAME_add_entry_by_txt(name, \"O\", MBSTRING_ASC, company, -1, -1, 0);\n\tX509_NAME_add_entry_by_txt(name, \"CN\", MBSTRING_ASC, common_name, -1, -1, 0);\n\n\tif (san != NULL) {\n\t\tcert_ext = X509V3_EXT_conf_nid(NULL, NULL, NID_subject_alt_name, san);\n\t\tif (cert_ext == NULL) {\n\t\t\tgoto out;\n\t\t}\n\t\tX509_add_ext(cert, cert_ext, -1);\n\t}\n\n\tX509_set_issuer_name(cert, name);\n\tX509_sign(cert, pkey, EVP_sha256());\n\n\tret = PEM_write_bio_PrivateKey(key_file, pkey, NULL, NULL, 0, NULL, NULL);\n\tif (ret != 1) {\n\t\tgoto out;\n\t}\n\n\tret = PEM_write_bio_X509(cert_file, cert);\n\tif (ret != 1) {\n\t\tgoto out;\n\t}\n\n\tchmod(key_path, S_IRUSR);\n\tchmod(cert_path, S_IRUSR);\n\n\tret = 0;\nout:\n\tif (cert_ext) {\n\t\tX509_EXTENSION_free(cert_ext);\n\t}\n\n\tif (pkey) {\n\t\tEVP_PKEY_free(pkey);\n\t}\n\n#if (OPENSSL_VERSION_NUMBER <= 0x30000000L)\n\tif (rsa && pkey == NULL) {\n\t\tRSA_free(rsa);\n\t}\n\n\tif (bn) {\n\t\tBN_free(bn);\n\t}\n#endif\n\n\tif (cert_file) {\n\t\tBIO_free_all(cert_file);\n\t}\n\n\tif (key_file) {\n\t\tBIO_free_all(key_file);\n\t}\n\n\tif (cert) {\n\t\tX509_free(cert);\n\t}\n\n\treturn ret;\n}\n\n#if OPENSSL_API_COMPAT < 0x10100000\n#define THREAD_STACK_SIZE (16 * 1024)\nstatic pthread_mutex_t *lock_cs;\nstatic long *lock_count;\n\nstatic __attribute__((unused)) void _pthreads_locking_callback(int mode, int type, const char *file, int line)\n{\n\tif (mode & CRYPTO_LOCK) {\n\t\tpthread_mutex_lock(&(lock_cs[type]));\n\t\tlock_count[type]++;\n\t} else {\n\t\tpthread_mutex_unlock(&(lock_cs[type]));\n\t}\n}\n\nstatic __attribute__((unused)) unsigned long _pthreads_thread_id(void)\n{\n\tunsigned long ret = 0;\n\n\tret = (unsigned long)pthread_self();\n\treturn (ret);\n}\n\nvoid SSL_CRYPTO_thread_setup(void)\n{\n\tint i = 0;\n\n\tlock_cs = OPENSSL_malloc(CRYPTO_num_locks() * sizeof(pthread_mutex_t));\n\tlock_count = OPENSSL_malloc(CRYPTO_num_locks() * sizeof(long));\n\tif (!lock_cs || !lock_count) {\n\t\t/* Nothing we can do about this...void function! */\n\t\tif (lock_cs) {\n\t\t\tOPENSSL_free(lock_cs);\n\t\t}\n\t\tif (lock_count) {\n\t\t\tOPENSSL_free(lock_count);\n\t\t}\n\t\treturn;\n\t}\n\tfor (i = 0; i < CRYPTO_num_locks(); i++) {\n\t\tlock_count[i] = 0;\n\t\tpthread_mutex_init(&(lock_cs[i]), NULL);\n\t}\n\n#if OPENSSL_API_COMPAT < 0x10000000\n\tCRYPTO_set_id_callback(_pthreads_thread_id);\n#else\n\tCRYPTO_THREADID_set_callback(_pthreads_thread_id);\n#endif\n\tCRYPTO_set_locking_callback(_pthreads_locking_callback);\n}\n\nvoid SSL_CRYPTO_thread_cleanup(void)\n{\n\tint i = 0;\n\n\tCRYPTO_set_locking_callback(NULL);\n\tfor (i = 0; i < CRYPTO_num_locks(); i++) {\n\t\tpthread_mutex_destroy(&(lock_cs[i]));\n\t}\n\tOPENSSL_free(lock_cs);\n\tOPENSSL_free(lock_count);\n}\n#endif\n\n#define SERVER_NAME_LEN 256\n#define TLS_HEADER_LEN 5\n#define TLS_HANDSHAKE_CONTENT_TYPE 0x16\n#define TLS_HANDSHAKE_TYPE_CLIENT_HELLO 0x01\n#ifndef MIN\n#define MIN(X, Y) ((X) < (Y) ? (X) : (Y))\n#endif\n\nstatic int parse_extensions(const char *, size_t, char *, const char **);\nstatic int parse_server_name_extension(const char *, size_t, char *, const char **);\n\n/* Parse a TLS packet for the Server Name Indication extension in the client\n * hello handshake, returning the first server name found (pointer to static\n * array)\n *\n * Returns:\n *  >=0  - length of the hostname and updates *hostname\n *         caller is responsible for freeing *hostname\n *  -1   - Incomplete request\n *  -2   - No Host header included in this request\n *  -3   - Invalid hostname pointer\n *  -4   - malloc failure\n *  < -4 - Invalid TLS client hello\n */\nint parse_tls_header(const char *data, size_t data_len, char *hostname, const char **hostname_ptr)\n{\n\tchar tls_content_type = 0;\n\tchar tls_version_major = 0;\n\tchar tls_version_minor = 0;\n\tsize_t pos = TLS_HEADER_LEN;\n\tsize_t len = 0;\n\n\tif (hostname == NULL) {\n\t\treturn -3;\n\t}\n\n\t/* Check that our TCP payload is at least large enough for a TLS header */\n\tif (data_len < TLS_HEADER_LEN) {\n\t\treturn -1;\n\t}\n\n\t/* SSL 2.0 compatible Client Hello\n\t *\n\t * High bit of first byte (length) and content type is Client Hello\n\t *\n\t * See RFC5246 Appendix E.2\n\t */\n\tif (data[0] & 0x80 && data[2] == 1) {\n\t\treturn -2;\n\t}\n\n\ttls_content_type = data[0];\n\tif (tls_content_type != TLS_HANDSHAKE_CONTENT_TYPE) {\n\t\treturn -5;\n\t}\n\n\ttls_version_major = data[1];\n\ttls_version_minor = data[2];\n\tif (tls_version_major < 3) {\n\t\treturn -2;\n\t}\n\n\t/* TLS record length */\n\tlen = ((unsigned char)data[3] << 8) + (unsigned char)data[4] + TLS_HEADER_LEN;\n\tdata_len = MIN(data_len, len);\n\n\t/* Check we received entire TLS record length */\n\tif (data_len < len) {\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Handshake\n\t */\n\tif (pos + 1 > data_len) {\n\t\treturn -5;\n\t}\n\tif (data[pos] != TLS_HANDSHAKE_TYPE_CLIENT_HELLO) {\n\t\treturn -5;\n\t}\n\n\t/* Skip past fixed length records:\n\t * 1\tHandshake Type\n\t * 3\tLength\n\t * 2\tVersion (again)\n\t * 32\tRandom\n\t * to\tSession ID Length\n\t */\n\tpos += 38;\n\n\t/* Session ID */\n\tif (pos + 1 > data_len) {\n\t\treturn -5;\n\t}\n\tlen = (unsigned char)data[pos];\n\tpos += 1 + len;\n\n\t/* Cipher Suites */\n\tif (pos + 2 > data_len) {\n\t\treturn -5;\n\t}\n\tlen = ((unsigned char)data[pos] << 8) + (unsigned char)data[pos + 1];\n\tpos += 2 + len;\n\n\t/* Compression Methods */\n\tif (pos + 1 > data_len) {\n\t\treturn -5;\n\t}\n\tlen = (unsigned char)data[pos];\n\tpos += 1 + len;\n\n\tif (pos == data_len && tls_version_major == 3 && tls_version_minor == 0) {\n\t\treturn -2;\n\t}\n\n\t/* Extensions */\n\tif (pos + 2 > data_len) {\n\t\treturn -5;\n\t}\n\tlen = ((unsigned char)data[pos] << 8) + (unsigned char)data[pos + 1];\n\tpos += 2;\n\n\tif (pos + len > data_len) {\n\t\treturn -5;\n\t}\n\treturn parse_extensions(data + pos, len, hostname, hostname_ptr);\n}\n\nstatic int parse_extensions(const char *data, size_t data_len, char *hostname, const char **hostname_ptr)\n{\n\tsize_t pos = 0;\n\tsize_t len = 0;\n\n\t/* Parse each 4 bytes for the extension header */\n\twhile (pos + 4 <= data_len) {\n\t\t/* Extension Length */\n\t\tlen = ((unsigned char)data[pos + 2] << 8) + (unsigned char)data[pos + 3];\n\n\t\t/* Check if it's a server name extension */\n\t\tif (data[pos] == 0x00 && data[pos + 1] == 0x00) {\n\t\t\t/* There can be only one extension of each type, so we break\n\t\t\t * our state and move p to beginning of the extension here */\n\t\t\tif (pos + 4 + len > data_len) {\n\t\t\t\treturn -5;\n\t\t\t}\n\t\t\treturn parse_server_name_extension(data + pos + 4, len, hostname, hostname_ptr);\n\t\t}\n\t\tpos += 4 + len; /* Advance to the next extension header */\n\t}\n\t/* Check we ended where we expected to */\n\tif (pos != data_len) {\n\t\treturn -5;\n\t}\n\n\treturn -2;\n}\n\nstatic int parse_server_name_extension(const char *data, size_t data_len, char *hostname, const char **hostname_ptr)\n{\n\tsize_t pos = 2; /* skip server name list length */\n\tsize_t len = 0;\n\n\twhile (pos + 3 < data_len) {\n\t\tlen = ((unsigned char)data[pos + 1] << 8) + (unsigned char)data[pos + 2];\n\n\t\tif (pos + 3 + len > data_len) {\n\t\t\treturn -5;\n\t\t}\n\n\t\tswitch (data[pos]) { /* name type */\n\t\tcase 0x00:           /* host_name */\n\t\t\tstrncpy(hostname, data + pos + 3, len);\n\t\t\tif (hostname_ptr) {\n\t\t\t\t*hostname_ptr = data + pos + 3;\n\t\t\t}\n\t\t\thostname[len] = '\\0';\n\n\t\t\treturn len;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tpos += 3 + len;\n\t}\n\t/* Check we ended where we expected to */\n\tif (pos != data_len) {\n\t\treturn -5;\n\t}\n\n\treturn -2;\n}\n\nvoid get_compiled_time(struct tm *tm)\n{\n\tchar s_month[5];\n\tint month = 0;\n\tint day = 0;\n\tint year = 0;\n\tint hour = 0;\n\tint min = 0;\n\tint sec = 0;\n\tstatic const char *month_names = \"JanFebMarAprMayJunJulAugSepOctNovDec\";\n\n\tsscanf(__DATE__, \"%4s %d %d\", s_month, &day, &year);\n\tmonth = (strstr(month_names, s_month) - month_names) / 3;\n\tsscanf(__TIME__, \"%d:%d:%d\", &hour, &min, &sec);\n\ttm->tm_year = year - 1900;\n\ttm->tm_mon = month;\n\ttm->tm_mday = day;\n\ttm->tm_isdst = -1;\n\ttm->tm_hour = hour;\n\ttm->tm_min = min;\n\ttm->tm_sec = sec;\n}\n\nunsigned long get_system_mem_size(void)\n{\n\tstruct sysinfo memInfo;\n\tsysinfo(&memInfo);\n\tlong long totalMem = memInfo.totalram;\n\ttotalMem *= memInfo.mem_unit;\n\n\treturn totalMem;\n}\n\nint is_numeric(const char *str)\n{\n\twhile (*str != '\\0') {\n\t\tif (*str < '0' || *str > '9') {\n\t\t\treturn -1;\n\t\t}\n\t\tstr++;\n\t}\n\treturn 0;\n}\n\nint has_network_raw_cap(void)\n{\n\tint fd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);\n\tif (fd < 0) {\n\t\treturn 0;\n\t}\n\n\tclose(fd);\n\treturn 1;\n}\n\nint has_unprivileged_ping(void)\n{\n\tint fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP);\n\tif (fd < 0) {\n\t\treturn 0;\n\t}\n\n\tclose(fd);\n\n\tfd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_ICMPV6);\n\tif (fd < 0) {\n\t\treturn 0;\n\t}\n\n\tclose(fd);\n\n\treturn 1;\n}\n\nint set_sock_keepalive(int fd, int keepidle, int keepinterval, int keepcnt)\n{\n\tconst int yes = 1;\n\tif (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &yes, sizeof(yes)) != 0) {\n\t\treturn -1;\n\t}\n\n\tsetsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &keepidle, sizeof(keepidle));\n\tsetsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &keepinterval, sizeof(keepinterval));\n\tsetsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &keepcnt, sizeof(keepcnt));\n\n\treturn 0;\n}\n\nint set_sock_lingertime(int fd, int time)\n{\n\tstruct linger l;\n\n\tl.l_onoff = 1;\n\tl.l_linger = 0;\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_LINGER, (const char *)&l, sizeof(l)) != 0) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nuint64_t get_free_space(const char *path)\n{\n\tuint64_t size = 0;\n\tstruct statvfs buf;\n\tif (statvfs(path, &buf) != 0) {\n\t\treturn 0;\n\t}\n\n\tsize = (uint64_t)buf.f_frsize * buf.f_bavail;\n\n\treturn size;\n}\n\nstruct backtrace_state {\n\tvoid **current;\n\tvoid **end;\n};\n\nstatic _Unwind_Reason_Code unwind_callback(struct _Unwind_Context *context, void *arg)\n{\n\tstruct backtrace_state *state = (struct backtrace_state *)(arg);\n\tuintptr_t pc = _Unwind_GetIP(context);\n\tif (pc) {\n\t\tif (state->current == state->end) {\n\t\t\treturn _URC_END_OF_STACK;\n\t\t}\n\n\t\t*state->current++ = (void *)(pc);\n\t}\n\treturn _URC_NO_REASON;\n}\n\nvoid print_stack(void)\n{\n\tconst size_t max_buffer = 30;\n\tvoid *buffer[max_buffer];\n\tint idx = 0;\n\n\tstruct backtrace_state state = {buffer, buffer + max_buffer};\n\t_Unwind_Backtrace(unwind_callback, &state);\n\tint frame_num = state.current - buffer;\n\tif (frame_num == 0) {\n\t\treturn;\n\t}\n\n\ttlog(TLOG_FATAL, \"Stack:\");\n\tfor (idx = 0; idx < frame_num; ++idx) {\n\t\tconst void *addr = buffer[idx];\n\t\tconst char *symbol = \"\";\n\n\t\tDl_info info;\n\t\tmemset(&info, 0, sizeof(info));\n\t\tif (dladdr(addr, &info) && info.dli_sname) {\n\t\t\tsymbol = info.dli_sname;\n\t\t}\n\n\t\tvoid *offset = (void *)((char *)(addr) - (char *)(info.dli_fbase));\n\t\ttlog(TLOG_FATAL, \"#%.2d: %p %s() from %s+%p\", idx + 1, addr, symbol, info.dli_fname, offset);\n\t}\n}\n\nvoid bug_ext(const char *file, int line, const char *func, const char *errfmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, errfmt);\n\ttlog_vext(TLOG_FATAL, file, line, func, NULL, errfmt, ap);\n\tva_end(ap);\n\n\tprint_stack();\n\t/* trigger BUG */\n\tsleep(1);\n\traise(SIGSEGV);\n\n\twhile (true) {\n\t\tsleep(1);\n\t};\n}\n\nint write_file(const char *filename, void *data, int data_len)\n{\n\tint fd = open(filename, O_WRONLY | O_CREAT, 0644);\n\tif (fd < 0) {\n\t\treturn -1;\n\t}\n\n\tint len = write(fd, data, data_len);\n\tif (len < 0) {\n\t\tgoto errout;\n\t}\n\n\tclose(fd);\n\treturn 0;\nerrout:\n\tif (fd > 0) {\n\t\tclose(fd);\n\t}\n\n\treturn -1;\n}\n\nint dns_packet_save(const char *dir, const char *type, const char *from, const void *packet, int packet_len)\n{\n\tchar *data = NULL;\n\tint data_len = 0;\n\tchar filename[BUFF_SZ];\n\tchar time_s[BUFF_SZ];\n\tint ret = -1;\n\n\tstruct tm *ptm;\n\tstruct tm tm;\n\tstruct timeval tm_val;\n\tstruct stat sb;\n\n\tif (stat(dir, &sb) != 0) {\n\t\tmkdir(dir, 0750);\n\t}\n\n\tif (gettimeofday(&tm_val, NULL) != 0) {\n\t\treturn -1;\n\t}\n\n\tptm = localtime_r(&tm_val.tv_sec, &tm);\n\tif (ptm == NULL) {\n\t\treturn -1;\n\t}\n\n\tsnprintf(time_s, sizeof(time_s) - 1, \"%.4d-%.2d-%.2d %.2d:%.2d:%.2d.%.3d\", ptm->tm_year + 1900, ptm->tm_mon + 1,\n\t\t\t ptm->tm_mday, ptm->tm_hour, ptm->tm_min, ptm->tm_sec, (int)(tm_val.tv_usec / 1000));\n\tsnprintf(filename, sizeof(filename) - 1, \"%s/%s-%.4d%.2d%.2d-%.2d%.2d%.2d%.1d.packet\", dir, type,\n\t\t\t ptm->tm_year + 1900, ptm->tm_mon + 1, ptm->tm_mday, ptm->tm_hour, ptm->tm_min, ptm->tm_sec,\n\t\t\t (int)(tm_val.tv_usec / 100000));\n\n\tdata = malloc(PACKET_BUF_SIZE);\n\tif (data == NULL) {\n\t\treturn -1;\n\t}\n\n\tdata_len = snprintf(data, PACKET_BUF_SIZE,\n\t\t\t\t\t\t\"type: %s\\n\"\n\t\t\t\t\t\t\"from: %s\\n\"\n\t\t\t\t\t\t\"time: %s\\n\"\n\t\t\t\t\t\t\"packet-len: %d\\n\",\n\t\t\t\t\t\ttype, from, time_s, packet_len);\n\tif (data_len <= 0 || data_len >= PACKET_BUF_SIZE) {\n\t\tgoto out;\n\t}\n\n\tdata[data_len] = 0;\n\tdata_len++;\n\tuint32_t magic = htonl(PACKET_MAGIC);\n\tmemcpy(data + data_len, &magic, sizeof(magic));\n\tdata_len += sizeof(magic);\n\tint len_in_h = htonl(packet_len);\n\tmemcpy(data + data_len, &len_in_h, sizeof(len_in_h));\n\tdata_len += 4;\n\tmemcpy(data + data_len, packet, packet_len);\n\tdata_len += packet_len;\n\n\tret = write_file(filename, data, data_len);\n\tif (ret != 0) {\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tif (data) {\n\t\tfree(data);\n\t}\n\n\treturn ret;\n}\n\n#ifdef DEBUG\nstruct _dns_read_packet_info {\n\tint data_len;\n\tint message_len;\n\tchar *message;\n\tint packet_len;\n\tuint8_t *packet;\n\tuint8_t data[0];\n};\n\nstatic struct _dns_read_packet_info *_dns_read_packet_file(const char *packet_file)\n{\n\tstruct _dns_read_packet_info *info = NULL;\n\tint fd = 0;\n\tint len = 0;\n\tint message_len = 0;\n\tuint8_t *ptr = NULL;\n\n\tinfo = malloc(sizeof(struct _dns_read_packet_info) + PACKET_BUF_SIZE);\n\tfd = open(packet_file, O_RDONLY);\n\tif (fd < 0) {\n\t\tprintf(\"open file %s failed, %s\\n\", packet_file, strerror(errno));\n\t\tgoto errout;\n\t}\n\n\tlen = read(fd, info->data, PACKET_BUF_SIZE);\n\tif (len < 0) {\n\t\tprintf(\"read file %s failed, %s\\n\", packet_file, strerror(errno));\n\t\tgoto errout;\n\t}\n\n\tmessage_len = strnlen((char *)info->data, PACKET_BUF_SIZE);\n\tif (message_len >= 512 || message_len >= len) {\n\t\tprintf(\"invalid packet file, bad message len\\n\");\n\t\tgoto errout;\n\t}\n\n\tinfo->message_len = message_len;\n\tinfo->message = (char *)info->data;\n\n\tptr = info->data + message_len + 1;\n\tuint32_t magic = 0;\n\tif (ptr - (uint8_t *)info + sizeof(magic) >= (size_t)len) {\n\t\tprintf(\"invalid packet file, magic length is invalid.\\n\");\n\t\tgoto errout;\n\t}\n\n\tmemcpy(&magic, ptr, sizeof(magic));\n\tif (magic != htonl(PACKET_MAGIC)) {\n\t\tprintf(\"invalid packet file, bad magic\\n\");\n\t\tgoto errout;\n\t}\n\tptr += sizeof(magic);\n\n\tuint32_t packet_len = 0;\n\tif (ptr - info->data + sizeof(packet_len) >= (size_t)len) {\n\t\tprintf(\"invalid packet file, packet length is invalid.\\n\");\n\t\tgoto errout;\n\t}\n\n\tmemcpy(&packet_len, ptr, sizeof(packet_len));\n\tpacket_len = ntohl(packet_len);\n\tptr += sizeof(packet_len);\n\tif (packet_len != (size_t)len - (ptr - info->data)) {\n\t\tprintf(\"invalid packet file, packet length is invalid\\n\");\n\t\tgoto errout;\n\t}\n\n\tinfo->packet_len = packet_len;\n\tinfo->packet = ptr;\n\n\tclose(fd);\n\treturn info;\nerrout:\n\n\tif (fd > 0) {\n\t\tclose(fd);\n\t}\n\n\tif (info) {\n\t\tfree(info);\n\t}\n\n\treturn NULL;\n}\n\nstatic int _dns_debug_display(struct dns_packet *packet)\n{\n\tint i = 0;\n\tint j = 0;\n\tint ttl = 0;\n\tstruct dns_rrs *rrs = NULL;\n\tint rr_count = 0;\n\tchar req_host[MAX_IP_LEN];\n\n\tfor (j = 1; j < DNS_RRS_END; j++) {\n\t\trrs = dns_get_rrs_start(packet, j, &rr_count);\n\t\tprintf(\"section: %d\\n\", j);\n\t\tfor (i = 0; i < rr_count && rrs; i++, rrs = dns_get_rrs_next(packet, rrs)) {\n\t\t\tswitch (rrs->type) {\n\t\t\tcase DNS_T_A: {\n\t\t\t\tunsigned char addr[4];\n\t\t\t\tchar name[DNS_MAX_CNAME_LEN] = {0};\n\t\t\t\t/* get A result */\n\t\t\t\tdns_get_A(rrs, name, DNS_MAX_CNAME_LEN, &ttl, addr);\n\t\t\t\treq_host[0] = '\\0';\n\t\t\t\tinet_ntop(AF_INET, addr, req_host, sizeof(req_host));\n\t\t\t\tprintf(\"domain: %s A: %s TTL: %d\\n\", name, req_host, ttl);\n\t\t\t} break;\n\t\t\tcase DNS_T_AAAA: {\n\t\t\t\tunsigned char addr[16];\n\t\t\t\tchar name[DNS_MAX_CNAME_LEN] = {0};\n\t\t\t\tdns_get_AAAA(rrs, name, DNS_MAX_CNAME_LEN, &ttl, addr);\n\t\t\t\treq_host[0] = '\\0';\n\t\t\t\tinet_ntop(AF_INET6, addr, req_host, sizeof(req_host));\n\t\t\t\tprintf(\"domain: %s AAAA: %s TTL:%d\\n\", name, req_host, ttl);\n\t\t\t} break;\n\t\t\tcase DNS_T_HTTPS: {\n\t\t\t\tchar name[DNS_MAX_CNAME_LEN] = {0};\n\t\t\t\tchar target[DNS_MAX_CNAME_LEN] = {0};\n\t\t\t\tstruct dns_https_param *p = NULL;\n\t\t\t\tint priority = 0;\n\n\t\t\t\tp = dns_get_HTTPS_svcparm_start(rrs, name, DNS_MAX_CNAME_LEN, &ttl, &priority, target,\n\t\t\t\t\t\t\t\t\t\t\t\tDNS_MAX_CNAME_LEN);\n\t\t\t\tif (p == NULL) {\n\t\t\t\t\tprintf(\"get HTTPS svcparm failed\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tprintf(\"domain: %s HTTPS: %s TTL: %d priority: %d\\n\", name, target, ttl, priority);\n\n\t\t\t\tfor (; p; p = dns_get_HTTPS_svcparm_next(rrs, p)) {\n\t\t\t\t\tswitch (p->key) {\n\t\t\t\t\tcase DNS_HTTPS_T_MANDATORY: {\n\t\t\t\t\t\tprintf(\"  HTTPS: mandatory: %s\\n\", p->value);\n\t\t\t\t\t} break;\n\t\t\t\t\tcase DNS_HTTPS_T_ALPN: {\n\t\t\t\t\t\tprintf(\"  HTTPS: alpn: %s\\n\", p->value);\n\t\t\t\t\t} break;\n\t\t\t\t\tcase DNS_HTTPS_T_NO_DEFAULT_ALPN: {\n\t\t\t\t\t\tprintf(\"  HTTPS: no_default_alpn: %s\\n\", p->value);\n\t\t\t\t\t} break;\n\t\t\t\t\tcase DNS_HTTPS_T_PORT: {\n\t\t\t\t\t\tint port = *(unsigned short *)(p->value);\n\t\t\t\t\t\tprintf(\"  HTTPS: port: %d\\n\", port);\n\t\t\t\t\t} break;\n\t\t\t\t\tcase DNS_HTTPS_T_IPV4HINT: {\n\t\t\t\t\t\tprintf(\"  HTTPS: ipv4hint: %d\\n\", p->len / 4);\n\t\t\t\t\t\tfor (int k = 0; k < p->len / 4; k++) {\n\t\t\t\t\t\t\tchar ip[16] = {0};\n\t\t\t\t\t\t\tinet_ntop(AF_INET, p->value + k * 4, ip, sizeof(ip));\n\t\t\t\t\t\t\tprintf(\"    ipv4: %s\\n\", ip);\n\t\t\t\t\t\t}\n\t\t\t\t\t} break;\n\t\t\t\t\tcase DNS_HTTPS_T_ECH: {\n\t\t\t\t\t\tprintf(\"  HTTPS: ech: \");\n\t\t\t\t\t\tfor (int k = 0; k < p->len; k++) {\n\t\t\t\t\t\t\tprintf(\"%02x \", p->value[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t\t} break;\n\t\t\t\t\tcase DNS_HTTPS_T_IPV6HINT: {\n\t\t\t\t\t\tprintf(\"  HTTPS: ipv6hint: %d\\n\", p->len / 16);\n\t\t\t\t\t\tfor (int k = 0; k < p->len / 16; k++) {\n\t\t\t\t\t\t\tchar ip[64] = {0};\n\t\t\t\t\t\t\tinet_ntop(AF_INET6, p->value + k * 16, ip, sizeof(ip));\n\t\t\t\t\t\t\tprintf(\"    ipv6: %s\\n\", ip);\n\t\t\t\t\t\t}\n\t\t\t\t\t} break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} break;\n\t\t\tcase DNS_T_NS: {\n\t\t\t\tchar cname[DNS_MAX_CNAME_LEN];\n\t\t\t\tchar name[DNS_MAX_CNAME_LEN] = {0};\n\t\t\t\tdns_get_CNAME(rrs, name, DNS_MAX_CNAME_LEN, &ttl, cname, DNS_MAX_CNAME_LEN);\n\t\t\t\tprintf(\"domain: %s TTL: %d NS: %s\\n\", name, ttl, cname);\n\t\t\t} break;\n\t\t\tcase DNS_T_CNAME: {\n\t\t\t\tchar cname[DNS_MAX_CNAME_LEN];\n\t\t\t\tchar name[DNS_MAX_CNAME_LEN] = {0};\n\t\t\t\tif (dns_conf_force_no_cname) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdns_get_CNAME(rrs, name, DNS_MAX_CNAME_LEN, &ttl, cname, DNS_MAX_CNAME_LEN);\n\t\t\t\tprintf(\"domain: %s TTL: %d CNAME: %s\\n\", name, ttl, cname);\n\t\t\t} break;\n\t\t\tcase DNS_T_SOA: {\n\t\t\t\tchar name[DNS_MAX_CNAME_LEN] = {0};\n\t\t\t\tstruct dns_soa soa;\n\t\t\t\tdns_get_SOA(rrs, name, 128, &ttl, &soa);\n\t\t\t\tprintf(\"domain: %s SOA: mname: %s, rname: %s, serial: %d, refresh: %d, retry: %d, expire: \"\n\t\t\t\t\t   \"%d, minimum: %d\",\n\t\t\t\t\t   name, soa.mname, soa.rname, soa.serial, soa.refresh, soa.retry, soa.expire, soa.minimum);\n\t\t\t} break;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn 0;\n}\n\nint dns_packet_debug(const char *packet_file)\n{\n\tstruct _dns_read_packet_info *info = NULL;\n\tchar buff[DNS_PACKSIZE];\n\n\ttlog_set_maxlog_count(0);\n\ttlog_setlogscreen(1);\n\ttlog_setlevel(TLOG_DEBUG);\n\n\tinfo = _dns_read_packet_file(packet_file);\n\tif (info == NULL) {\n\t\tgoto errout;\n\t}\n\n\tconst char *send_env = getenv(\"SMARTDNS_DEBUG_SEND\");\n\tif (send_env != NULL) {\n\t\tchar ip[32];\n\t\tint port = 53;\n\t\tif (parse_ip(send_env, ip, &port) == 0) {\n\t\t\tint sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n\t\t\tif (sockfd > 0) {\n\t\t\t\tstruct sockaddr_in server;\n\t\t\t\tserver.sin_family = AF_INET;\n\t\t\t\tserver.sin_port = htons(port);\n\t\t\t\tserver.sin_addr.s_addr = inet_addr(ip);\n\t\t\t\tsendto(sockfd, info->packet, info->packet_len, 0, (struct sockaddr *)&server, sizeof(server));\n\t\t\t\tclose(sockfd);\n\t\t\t}\n\t\t}\n\t}\n\n\tstruct dns_packet *packet = (struct dns_packet *)buff;\n\tif (dns_decode(packet, DNS_PACKSIZE, info->packet, info->packet_len) != 0) {\n\t\tprintf(\"decode failed.\\n\");\n\t\tgoto errout;\n\t}\n\n\t_dns_debug_display(packet);\n\n\tfree(info);\n\treturn 0;\n\nerrout:\n\tif (info) {\n\t\tfree(info);\n\t}\n\n\treturn -1;\n}\n\n#endif\n"], "fixing_code": ["/*************************************************************************\n *\n * Copyright (C) 2018-2023 Ruilin Peng (Nick) <pymumu@gmail.com>.\n *\n * smartdns is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * smartdns is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#define _GNU_SOURCE\n#include \"dns.h\"\n#include \"stringutil.h\"\n#include \"tlog.h\"\n#include <arpa/inet.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define QR_MASK 0x8000\n#define OPCODE_MASK 0x7800\n#define AA_MASK 0x0400\n#define TC_MASK 0x0200\n#define RD_MASK 0x0100\n#define RA_MASK 0x0080\n#define RCODE_MASK 0x000F\n#define DNS_RR_END (0XFFFF)\n\n#define UNUSED(expr)                                                                                                   \\\n\tdo {                                                                                                               \\\n\t\t(void)(expr);                                                                                                  \\\n\t} while (0)\n\n#define member_size(type, member) sizeof(((type *)0)->member)\n\n/* read short and move pointer */\nstatic unsigned short _dns_read_short(unsigned char **buffer)\n{\n\tunsigned short value = 0;\n\n\tvalue = ntohs(*((unsigned short *)(*buffer)));\n\t*buffer += 2;\n\treturn value;\n}\n\n/* write char and move pointer */\nstatic __attribute__((unused)) void _dns_write_char(unsigned char **buffer, unsigned char value)\n{\n\t**buffer = value;\n\t*buffer += 1;\n}\n\n/* read char and move pointer */\nstatic unsigned char _dns_read_char(unsigned char **buffer)\n{\n\tunsigned char value = **buffer;\n\t*buffer += 1;\n\treturn value;\n}\n\n/* write short and move pointer */\nstatic void _dns_write_short(unsigned char **buffer, unsigned short value)\n{\n\tvalue = htons(value);\n\t*((unsigned short *)(*buffer)) = value;\n\t*buffer += 2;\n}\n\n/* write int and move pointer */\nstatic void _dns_write_int(unsigned char **buffer, unsigned int value)\n{\n\tvalue = htonl(value);\n\t*((unsigned int *)(*buffer)) = value;\n\t*buffer += 4;\n}\n\n/* read int and move pointer */\nstatic unsigned int _dns_read_int(unsigned char **buffer)\n{\n\tunsigned int value = 0;\n\n\tvalue = ntohl(*((unsigned int *)(*buffer)));\n\t*buffer += 4;\n\n\treturn value;\n}\n\nstatic inline int _dns_left_len(struct dns_context *context)\n{\n\treturn context->maxsize - (context->ptr - context->data);\n}\n\nstatic int _dns_get_domain_from_packet(unsigned char *packet, int packet_size, unsigned char **domain_ptr, char *output,\n\t\t\t\t\t\t\t\t\t   int size)\n{\n\tint output_len = 0;\n\tint copy_len = 0;\n\tint len = 0;\n\tunsigned char *ptr = *domain_ptr;\n\tint is_compressed = 0;\n\tint ptr_jump = 0;\n\n\t/*[len]string[len]string...[0]0 */\n\twhile (1) {\n\t\tif (ptr >= packet + packet_size || ptr < packet || output_len >= size - 1 || ptr_jump > 32) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen = *ptr;\n\t\tif (len == 0) {\n\t\t\t*output = 0;\n\t\t\tptr++;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* compressed domain */\n\t\tif (len >= 0xC0) {\n\t\t\tif ((ptr + 2) > (packet + packet_size)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/*\n\t\t\t0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n\t\t\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t\t\t| 1  1|                OFFSET                   |\n\t\t\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t\t\t*/\n\t\t\t/* read offset */\n\t\t\tlen = _dns_read_short(&ptr) & 0x3FFF;\n\t\t\tif (is_compressed == 0) {\n\t\t\t\t*domain_ptr = ptr;\n\t\t\t}\n\n\t\t\tptr = packet + len;\n\t\t\tif (ptr > packet + packet_size) {\n\t\t\t\ttlog(TLOG_DEBUG, \"length is not enough %u:%ld, %p, %p\", packet_size, (long)(ptr - packet), *domain_ptr,\n\t\t\t\t\t packet);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tis_compressed = 1;\n\t\t\tptr_jump++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tptr_jump = 0;\n\n\t\t/* change [len] to '.' */\n\t\tif (output_len > 0) {\n\t\t\t*output = '.';\n\t\t\toutput++;\n\t\t\toutput_len += 1;\n\t\t}\n\n\t\tif (ptr > packet + packet_size) {\n\t\t\ttlog(TLOG_DEBUG, \"length is not enough %u:%ld, %p, %p\", packet_size, (long)(ptr - packet), *domain_ptr,\n\t\t\t\t packet);\n\t\t\treturn -1;\n\t\t}\n\n\t\tptr++;\n\t\tif (output_len < size - 1) {\n\t\t\t/* copy sub string */\n\t\t\tcopy_len = (len < size - output_len) ? len : size - 1 - output_len;\n\t\t\tif ((ptr + copy_len) > (packet + packet_size)) {\n\t\t\t\ttlog(TLOG_DEBUG, \"length is not enough %u:%ld, %p, %p\", packet_size, (long)(ptr - packet), *domain_ptr,\n\t\t\t\t\t packet);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmemcpy(output, ptr, copy_len);\n\t\t}\n\n\t\tptr += len;\n\t\toutput += len;\n\t\toutput_len += len;\n\t}\n\n\tif (is_compressed == 0) {\n\t\t*domain_ptr = ptr;\n\t}\n\n\treturn 0;\n}\n\nstatic int _dns_decode_domain(struct dns_context *context, char *output, int size)\n{\n\treturn _dns_get_domain_from_packet(context->data, context->maxsize, &(context->ptr), output, size);\n}\n\nstatic unsigned int dict_hash(const char *s)\n{\n\tunsigned int hashval = 0;\n\tfor (hashval = 0; *s != '\\0'; s++) {\n\t\thashval = *s + 31 * hashval;\n\t}\n\treturn hashval;\n}\n\nstatic int _dns_add_domain_dict(struct dns_context *context, unsigned int hash, int pos)\n{\n\tstruct dns_packet_dict *dict = context->namedict;\n\n\tif (dict->dict_count >= DNS_PACKET_DICT_SIZE) {\n\t\treturn -1;\n\t}\n\n\tif (hash == 0) {\n\t\treturn -1;\n\t}\n\n\tif (pos >= context->maxsize) {\n\t\treturn -1;\n\t}\n\n\tint index = dict->dict_count;\n\tdict->names[index].hash = hash;\n\tdict->names[index].pos = pos;\n\tdict->dict_count++;\n\n\treturn 0;\n}\n\nstatic int _dns_get_domain_offset(struct dns_context *context, const char *domain)\n{\n\tint i = 0;\n\n\tchar domain_check[DNS_MAX_CNAME_LEN];\n\tstruct dns_packet_dict *dict = context->namedict;\n\n\tif (*domain == '\\0') {\n\t\treturn -1;\n\t}\n\n\tunsigned int hash = dict_hash(domain);\n\tfor (i = 0; i < dict->dict_count; i++) {\n\t\tif (dict->names[i].hash != hash) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tunsigned char *domain_check_ptr = dict->names[i].pos + context->data;\n\t\tif (_dns_get_domain_from_packet(context->data, context->maxsize, &domain_check_ptr, domain_check,\n\t\t\t\t\t\t\t\t\t\tDNS_MAX_CNAME_LEN) != 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn dict->names[i].pos;\n\t}\n\n\t_dns_add_domain_dict(context, hash, context->ptr - 1 - context->data);\n\treturn -1;\n}\n\nstatic int _dns_encode_domain(struct dns_context *context, const char *domain)\n{\n\tint num = 0;\n\tint total_len = 0;\n\tunsigned char *ptr_num = context->ptr++;\n\tint dict_offset = 0;\n\n\tdict_offset = _dns_get_domain_offset(context, domain);\n\ttotal_len++;\n\n\t/*[len]string[len]string...[0]0 */\n\twhile (_dns_left_len(context) > 1 && *domain != 0) {\n\t\ttotal_len++;\n\t\tif (dict_offset >= 0) {\n\t\t\tint offset = 0xc000 | dict_offset;\n\t\t\tif (_dns_left_len(context) < 2) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t_dns_write_short(&ptr_num, offset);\n\t\t\tcontext->ptr++;\n\t\t\tptr_num = NULL;\n\t\t\treturn total_len;\n\t\t}\n\n\t\tif (*domain == '.') {\n\t\t\t*ptr_num = num;\n\t\t\tnum = 0;\n\t\t\tptr_num = context->ptr;\n\t\t\tdomain++;\n\t\t\tcontext->ptr++;\n\t\t\tdict_offset = _dns_get_domain_offset(context, domain);\n\t\t\tcontinue;\n\t\t}\n\t\t*context->ptr = *domain;\n\t\tnum++;\n\t\tcontext->ptr++;\n\t\tdomain++;\n\t}\n\n\tif (_dns_left_len(context) < 1) {\n\t\treturn -1;\n\t}\n\n\t*ptr_num = num;\n\n\tif (total_len > 1) {\n\t\t/* if domain is '\\0', [domain] is '\\0' */\n\t\t*(context->ptr) = 0;\n\t\ttotal_len++;\n\t\tcontext->ptr++;\n\t}\n\n\tif (_dns_left_len(context) <= 0) {\n\t\treturn -1;\n\t}\n\n\treturn total_len;\n}\n\n/* iterator get rrs begin */\nstruct dns_rrs *dns_get_rrs_start(struct dns_packet *packet, dns_rr_type type, int *count)\n{\n\tunsigned short start = 0;\n\tstruct dns_head *head = &packet->head;\n\n\t/* get rrs count by rrs type */\n\tswitch (type) {\n\tcase DNS_RRS_QD:\n\t\t*count = head->qdcount;\n\t\tstart = packet->questions;\n\t\tbreak;\n\tcase DNS_RRS_AN:\n\t\t*count = head->ancount;\n\t\tstart = packet->answers;\n\t\tbreak;\n\tcase DNS_RRS_NS:\n\t\t*count = head->nscount;\n\t\tstart = packet->nameservers;\n\t\tbreak;\n\tcase DNS_RRS_NR:\n\t\t*count = head->nrcount;\n\t\tstart = packet->additional;\n\t\tbreak;\n\tcase DNS_RRS_OPT:\n\t\t*count = packet->optcount;\n\t\tstart = packet->optional;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t\tbreak;\n\t}\n\n\t/* if not resource record, return null */\n\tif (start == DNS_RR_END) {\n\t\treturn NULL;\n\t}\n\n\t/* return rrs data start address */\n\treturn (struct dns_rrs *)(packet->data + start);\n}\n\n/* iterator next rrs */\nstruct dns_rrs *dns_get_rrs_next(struct dns_packet *packet, struct dns_rrs *rrs)\n{\n\tif (rrs->next == DNS_RR_END) {\n\t\treturn NULL;\n\t}\n\n\treturn (struct dns_rrs *)(packet->data + rrs->next);\n}\n\nstatic void _dns_init_context_by_rrs(struct dns_rrs *rrs, struct dns_context *context)\n{\n\tcontext->packet = rrs->packet;\n\tcontext->data = rrs->packet->data;\n\tcontext->ptr = rrs->data;\n\tcontext->namedict = &rrs->packet->namedict;\n\tcontext->maxsize = rrs->data - rrs->packet->data + rrs->len;\n}\n\n/* iterator add rrs begin */\nstatic int _dns_add_rrs_start(struct dns_packet *packet, struct dns_context *context)\n{\n\tstruct dns_rrs *rrs = NULL;\n\tunsigned char *end = packet->data + packet->len;\n\n\tif ((packet->len + (int)sizeof(*rrs)) >= packet->size) {\n\t\treturn -1;\n\t}\n\trrs = (struct dns_rrs *)end;\n\n\tcontext->ptr = rrs->data;\n\tcontext->packet = packet;\n\tcontext->maxsize = packet->size - sizeof(*packet);\n\tcontext->data = packet->data;\n\tcontext->namedict = &packet->namedict;\n\n\treturn 0;\n}\n\n/* iterator add rrs end */\nstatic int _dns_rr_add_end(struct dns_packet *packet, int type, dns_type_t rtype, int len)\n{\n\tstruct dns_rrs *rrs = NULL;\n\tstruct dns_rrs *rrs_next = NULL;\n\tstruct dns_head *head = &packet->head;\n\tunsigned char *end = packet->data + packet->len;\n\tunsigned short *count = NULL;\n\tunsigned short *start = NULL;\n\n\trrs = (struct dns_rrs *)end;\n\tif (packet->len + len > packet->size - (int)sizeof(*packet) - (int)sizeof(*rrs)) {\n\t\treturn -1;\n\t}\n\n\tswitch (type) {\n\tcase DNS_RRS_QD:\n\t\tcount = &head->qdcount;\n\t\tstart = &packet->questions;\n\t\tbreak;\n\tcase DNS_RRS_AN:\n\t\tcount = &head->ancount;\n\t\tstart = &packet->answers;\n\t\tbreak;\n\tcase DNS_RRS_NS:\n\t\tcount = &head->nscount;\n\t\tstart = &packet->nameservers;\n\t\tbreak;\n\tcase DNS_RRS_NR:\n\t\tcount = &head->nrcount;\n\t\tstart = &packet->additional;\n\t\tbreak;\n\tcase DNS_RRS_OPT:\n\t\tcount = &packet->optcount;\n\t\tstart = &packet->optional;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t\tbreak;\n\t}\n\n\t/* add data to end of dns_packet, and set previous rrs point to this rrs */\n\tif (*start != DNS_RR_END) {\n\t\trrs_next = (struct dns_rrs *)(packet->data + *start);\n\t\twhile (rrs_next->next != DNS_RR_END) {\n\t\t\trrs_next = (struct dns_rrs *)(packet->data + rrs_next->next);\n\t\t}\n\t\trrs_next->next = packet->len;\n\t} else {\n\t\t*start = packet->len;\n\t}\n\n\t/* update rrs head info */\n\trrs->packet = packet;\n\trrs->len = len;\n\trrs->type = rtype;\n\trrs->next = DNS_RR_END;\n\n\t/* update total data length */\n\t*count += 1;\n\tpacket->len += len + sizeof(*rrs);\n\treturn 0;\n}\n\nstatic int _dns_add_qr_head(struct dns_context *context, const char *domain, int qtype, int qclass)\n{\n\tint ret = _dns_encode_domain(context, domain);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tif (_dns_left_len(context) < 4) {\n\t\treturn -1;\n\t}\n\n\t_dns_write_short(&context->ptr, qtype);\n\t_dns_write_short(&context->ptr, qclass);\n\n\treturn ret + 4;\n}\n\nstatic int _dns_get_qr_head(struct dns_context *context, char *domain, int maxsize, int *qtype, int *qclass)\n{\n\tint ret = 0;\n\n\tif (domain == NULL || context == NULL) {\n\t\treturn -1;\n\t}\n\n\tret = _dns_decode_domain(context, domain, maxsize);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tif (_dns_left_len(context) < 4) {\n\t\treturn -1;\n\t}\n\n\t*qtype = _dns_read_short(&context->ptr);\n\t*qclass = _dns_read_short(&context->ptr);\n\n\treturn 0;\n}\n\nstatic int _dns_add_rr_head(struct dns_context *context, const char *domain, int qtype, int qclass, int ttl, int rr_len)\n{\n\tint len = 0;\n\n\t/* resource record head */\n\t/* |domain          |\n\t * |qtype  | qclass |\n\t * |       ttl      |\n\t * | rrlen | rrdata |\n\t */\n\tlen = _dns_add_qr_head(context, domain, qtype, qclass);\n\tif (len < 0) {\n\t\treturn -1;\n\t}\n\n\tif (_dns_left_len(context) < 6) {\n\t\treturn -1;\n\t}\n\n\t_dns_write_int(&context->ptr, ttl);\n\t_dns_write_short(&context->ptr, rr_len);\n\n\treturn len + 6;\n}\n\nstatic int _dns_get_rr_head(struct dns_context *context, char *domain, int maxsize, int *qtype, int *qclass, int *ttl,\n\t\t\t\t\t\t\tint *rr_len)\n{\n\tint len = 0;\n\n\t/* resource record head */\n\t/* |domain          |\n\t * |qtype  | qclass |\n\t * |       ttl      |\n\t * | rrlen | rrdata |\n\t */\n\tlen = _dns_get_qr_head(context, domain, maxsize, qtype, qclass);\n\n\tif (_dns_left_len(context) < 6) {\n\t\treturn -1;\n\t}\n\n\t*ttl = _dns_read_int(&context->ptr);\n\t*rr_len = _dns_read_short(&context->ptr);\n\n\treturn len;\n}\n\nstruct dns_rr_nested *dns_add_rr_nested_start(struct dns_rr_nested *rr_nested_buffer, struct dns_packet *packet,\n\t\t\t\t\t\t\t\t\t\t\t  dns_rr_type type, dns_type_t rtype, const char *domain, int ttl)\n{\n\tint len = 0;\n\tmemset(rr_nested_buffer, 0, sizeof(*rr_nested_buffer));\n\trr_nested_buffer->type = type;\n\tint ret = 0;\n\n\t/* resource record */\n\t/* |domain          |\n\t * |qtype  | qclass |\n\t * |       ttl      |\n\t * | rrlen | rrdata |\n\t */\n\tret = _dns_add_rrs_start(packet, &rr_nested_buffer->context);\n\tif (ret < 0) {\n\t\treturn NULL;\n\t}\n\trr_nested_buffer->rr_start = rr_nested_buffer->context.ptr;\n\n\t/* add rr head */\n\tlen = _dns_add_rr_head(&rr_nested_buffer->context, domain, rtype, DNS_C_IN, ttl, 0);\n\tif (len < 0) {\n\t\treturn NULL;\n\t}\n\trr_nested_buffer->rr_len_ptr = rr_nested_buffer->context.ptr - 2;\n\trr_nested_buffer->rr_head_len = len;\n\n\treturn rr_nested_buffer;\n}\n\nint dns_add_rr_nested_memcpy(struct dns_rr_nested *rr_nested, const void *data, int data_len)\n{\n\tif (rr_nested == NULL || data == NULL || data_len <= 0) {\n\t\treturn -1;\n\t}\n\n\tif (_dns_left_len(&rr_nested->context) < data_len) {\n\t\treturn -1;\n\t}\n\n\tmemcpy(rr_nested->context.ptr, data, data_len);\n\trr_nested->context.ptr += data_len;\n\n\treturn 0;\n}\n\nint dns_add_rr_nested_end(struct dns_rr_nested *rr_nested, dns_type_t rtype)\n{\n\tif (rr_nested == NULL || rr_nested->rr_start == NULL) {\n\t\treturn -1;\n\t}\n\n\tint len = rr_nested->context.ptr - rr_nested->rr_start;\n\tunsigned char *ptr = rr_nested->rr_len_ptr;\n\tif (ptr == NULL || _dns_left_len(&rr_nested->context) < 2) {\n\t\treturn -1;\n\t}\n\n\t/* NO SVC keys, reset ptr */\n\tif (len <= 14) {\n\t\trr_nested->context.ptr = rr_nested->rr_start;\n\t\treturn 0;\n\t}\n\n\t_dns_write_short(&ptr, len - rr_nested->rr_head_len);\n\n\treturn _dns_rr_add_end(rr_nested->context.packet, rr_nested->type, rtype, len);\n}\n\nvoid *dns_get_rr_nested_start(struct dns_rrs *rrs, char *domain, int maxsize, int *qtype, int *ttl, int *rr_len)\n{\n\tstruct dns_context data_context;\n\tint qclass = 0;\n\tint ret = 0;\n\n\t_dns_init_context_by_rrs(rrs, &data_context);\n\tret = _dns_get_rr_head(&data_context, domain, DNS_MAX_CNAME_LEN, qtype, &qclass, ttl, rr_len);\n\tif (ret < 0) {\n\t\treturn NULL;\n\t}\n\n\tif (qclass != DNS_C_IN) {\n\t\treturn NULL;\n\t}\n\n\tif (*rr_len < 2) {\n\t\treturn NULL;\n\t}\n\n\treturn data_context.ptr;\n}\n\nvoid *dns_get_rr_nested_next(struct dns_rrs *rrs, void *rr_nested, int rr_nested_len)\n{\n\tvoid *end = rrs->data + rrs->len;\n\tvoid *p = rr_nested + rr_nested_len;\n\tif (p == end) {\n\t\treturn NULL;\n\t} else if (p > end) {\n\t\treturn NULL;\n\t}\n\n\treturn p;\n}\n\nstatic int _dns_add_RAW(struct dns_packet *packet, dns_rr_type rrtype, dns_type_t rtype, const char *domain, int ttl,\n\t\t\t\t\t\tconst void *raw, int raw_len)\n{\n\tint len = 0;\n\tstruct dns_context context;\n\tint ret = 0;\n\n\tif (raw_len < 0) {\n\t\treturn -1;\n\t}\n\n\t/* resource record */\n\t/* |domain          |\n\t * |qtype  | qclass |\n\t * |       ttl      |\n\t * | rrlen | rrdata |\n\t */\n\tret = _dns_add_rrs_start(packet, &context);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\t/* add rr head */\n\tlen = _dns_add_rr_head(&context, domain, rtype, DNS_C_IN, ttl, raw_len);\n\tif (len < 0) {\n\t\treturn -1;\n\t}\n\n\tif (_dns_left_len(&context) < raw_len) {\n\t\treturn -1;\n\t}\n\n\t/* add rr data */\n\tmemcpy(context.ptr, raw, raw_len);\n\tcontext.ptr += raw_len;\n\tlen += raw_len;\n\n\treturn _dns_rr_add_end(packet, rrtype, rtype, len);\n}\n\nstatic int _dns_get_RAW(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl, void *raw, int *raw_len)\n{\n\tint qtype = 0;\n\tint qclass = 0;\n\tint rr_len = 0;\n\tint ret = 0;\n\tstruct dns_context context;\n\n\t/* resource record head */\n\t/* |domain          |\n\t * |qtype  | qclass |\n\t * |       ttl      |\n\t * | rrlen | rrdata |\n\t */\n\t_dns_init_context_by_rrs(rrs, &context);\n\n\t/* get rr head */\n\tret = _dns_get_rr_head(&context, domain, maxsize, &qtype, &qclass, ttl, &rr_len);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tif (qtype != rrs->type || rr_len > *raw_len) {\n\t\treturn -1;\n\t}\n\n\t/* get rr data */\n\tmemcpy(raw, context.ptr, rr_len);\n\tcontext.ptr += rr_len;\n\t*raw_len = rr_len;\n\n\treturn 0;\n}\n\nstatic int _dns_add_opt_RAW(struct dns_packet *packet, dns_opt_code_t opt_rrtype, void *raw, int raw_len)\n{\n\tunsigned char opt_data[DNS_MAX_OPT_LEN];\n\tstruct dns_opt *opt = (struct dns_opt *)opt_data;\n\tint len = 0;\n\n\topt->code = DNS_OPT_T_TCP_KEEPALIVE;\n\topt->length = sizeof(unsigned short);\n\n\tmemcpy(opt->data, raw, raw_len);\n\tlen += raw_len;\n\tlen += sizeof(*opt);\n\n\treturn _dns_add_RAW(packet, DNS_RRS_OPT, (dns_type_t)DNS_OPT_T_TCP_KEEPALIVE, \"\", 0, opt_data, len);\n}\n\nstatic int _dns_get_opt_RAW(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl, struct dns_opt *dns_opt,\n\t\t\t\t\t\t\tint *dns_optlen)\n{\n\t*dns_optlen = DNS_MAX_OPT_LEN;\n\n\treturn _dns_get_RAW(rrs, domain, maxsize, ttl, dns_opt, dns_optlen);\n}\n\nstatic int __attribute__((unused)) _dns_add_OPT(struct dns_packet *packet, dns_rr_type type, unsigned short opt_code,\n\t\t\t\t\t\t\t\t\t\t\t\tunsigned short opt_len, struct dns_opt *opt)\n{\n\t// TODO\n\n\tint ret = 0;\n\tint len = 0;\n\tstruct dns_context context;\n\tint total_len = sizeof(*opt) + opt->length;\n\tint ttl = 0;\n\n\t/*\n\t+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n  0: |                          OPTION-CODE                          |\n\t +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n  2: |                         OPTION-LENGTH                         |\n\t +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n  4: |                                                               |\n\t /                          OPTION-DATA                          /\n\t /                                                               /\n\t +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\t*/\n\tret = _dns_add_rrs_start(packet, &context);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tif (_dns_left_len(&context) < total_len) {\n\t\treturn -1;\n\t}\n\n\tttl = (opt_code << 16) | opt_len;\n\n\t/* add rr head */\n\tlen = _dns_add_rr_head(&context, \"\", type, DNS_C_IN, ttl, total_len);\n\tif (len < 0) {\n\t\treturn -1;\n\t}\n\n\t/* add rr data */\n\tmemcpy(context.ptr, opt, total_len);\n\tcontext.ptr += total_len;\n\tlen = context.ptr - context.data - packet->len;\n\n\treturn _dns_rr_add_end(packet, type, DNS_T_OPT, len);\n}\n\nstatic int __attribute__((unused)) _dns_get_OPT(struct dns_rrs *rrs, unsigned short *opt_code, unsigned short *opt_len,\n\t\t\t\t\t\t\t\t\t\t\t\tstruct dns_opt *opt, int *opt_maxlen)\n{\n\t// TODO\n\n\tint qtype = 0;\n\tint qclass = 0;\n\tint rr_len = 0;\n\tint ret = 0;\n\tstruct dns_context context;\n\tchar domain[DNS_MAX_CNAME_LEN];\n\tint maxsize = DNS_MAX_CNAME_LEN;\n\tint ttl = 0;\n\n\t_dns_init_context_by_rrs(rrs, &context);\n\n\t/* get rr head */\n\tret = _dns_get_rr_head(&context, domain, maxsize, &qtype, &qclass, &ttl, &rr_len);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tif (qtype != rrs->type || rr_len > *opt_len) {\n\t\treturn -1;\n\t}\n\n\t/* get rr data */\n\t*opt_code = ttl >> 16;\n\t*opt_len = ttl & 0xFFFF;\n\tmemcpy(opt, context.ptr, rr_len);\n\tcontext.ptr += rr_len;\n\t*opt_maxlen = rr_len;\n\n\treturn 0;\n}\n\nint dns_add_CNAME(struct dns_packet *packet, dns_rr_type type, const char *domain, int ttl, const char *cname)\n{\n\tint rr_len = strnlen(cname, DNS_MAX_CNAME_LEN) + 1;\n\treturn _dns_add_RAW(packet, type, DNS_T_CNAME, domain, ttl, cname, rr_len);\n}\n\nint dns_get_CNAME(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl, char *cname, int cname_size)\n{\n\tint len = cname_size;\n\treturn _dns_get_RAW(rrs, domain, maxsize, ttl, cname, &len);\n}\n\nint dns_add_A(struct dns_packet *packet, dns_rr_type type, const char *domain, int ttl,\n\t\t\t  unsigned char addr[DNS_RR_A_LEN])\n{\n\treturn _dns_add_RAW(packet, type, DNS_T_A, domain, ttl, addr, DNS_RR_A_LEN);\n}\n\nint dns_get_A(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl, unsigned char addr[DNS_RR_A_LEN])\n{\n\tint len = DNS_RR_A_LEN;\n\treturn _dns_get_RAW(rrs, domain, maxsize, ttl, addr, &len);\n}\n\nint dns_add_PTR(struct dns_packet *packet, dns_rr_type type, const char *domain, int ttl, const char *cname)\n{\n\tint rr_len = strnlen(cname, DNS_MAX_CNAME_LEN) + 1;\n\treturn _dns_add_RAW(packet, type, DNS_T_PTR, domain, ttl, cname, rr_len);\n}\n\nint dns_get_PTR(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl, char *cname, int cname_size)\n{\n\tint len = cname_size;\n\treturn _dns_get_RAW(rrs, domain, maxsize, ttl, cname, &len);\n}\n\nint dns_add_NS(struct dns_packet *packet, dns_rr_type type, const char *domain, int ttl, const char *cname)\n{\n\tint rr_len = strnlen(cname, DNS_MAX_CNAME_LEN) + 1;\n\treturn _dns_add_RAW(packet, type, DNS_T_NS, domain, ttl, cname, rr_len);\n}\n\nint dns_get_NS(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl, char *cname, int cname_size)\n{\n\tint len = cname_size;\n\treturn _dns_get_RAW(rrs, domain, maxsize, ttl, cname, &len);\n}\n\nint dns_add_AAAA(struct dns_packet *packet, dns_rr_type type, const char *domain, int ttl,\n\t\t\t\t unsigned char addr[DNS_RR_AAAA_LEN])\n{\n\treturn _dns_add_RAW(packet, type, DNS_T_AAAA, domain, ttl, addr, DNS_RR_AAAA_LEN);\n}\n\nint dns_get_AAAA(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl, unsigned char addr[DNS_RR_AAAA_LEN])\n{\n\tint len = DNS_RR_AAAA_LEN;\n\treturn _dns_get_RAW(rrs, domain, maxsize, ttl, addr, &len);\n}\n\nint dns_add_SOA(struct dns_packet *packet, dns_rr_type type, const char *domain, int ttl, struct dns_soa *soa)\n{\n\t/* SOA */\n\t/*| mname        |\n\t *| rname        |\n\t *| serial       |\n\t *| refresh      |\n\t *| retry        |\n\t *| expire       |\n\t *| minimum      |\n\t */\n\tunsigned char data[sizeof(*soa)];\n\tunsigned char *ptr = data;\n\tint len = 0;\n\tsafe_strncpy((char *)ptr, soa->mname, DNS_MAX_CNAME_LEN);\n\tptr += strnlen(soa->mname, DNS_MAX_CNAME_LEN - 1) + 1;\n\tsafe_strncpy((char *)ptr, soa->rname, DNS_MAX_CNAME_LEN);\n\tptr += strnlen(soa->rname, DNS_MAX_CNAME_LEN - 1) + 1;\n\tmemcpy(ptr, &soa->serial, sizeof(unsigned int));\n\tptr += 4;\n\tmemcpy(ptr, &soa->refresh, sizeof(unsigned int));\n\tptr += 4;\n\tmemcpy(ptr, &soa->retry, sizeof(unsigned int));\n\tptr += 4;\n\tmemcpy(ptr, &soa->expire, sizeof(unsigned int));\n\tptr += 4;\n\tmemcpy(ptr, &soa->minimum, sizeof(unsigned int));\n\tptr += 4;\n\tlen = ptr - data;\n\n\treturn _dns_add_RAW(packet, type, DNS_T_SOA, domain, ttl, data, len);\n}\n\nint dns_get_SOA(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl, struct dns_soa *soa)\n{\n\tunsigned char data[sizeof(*soa)];\n\tunsigned char *ptr = data;\n\tint len = sizeof(data);\n\n\t/* SOA */\n\t/*| mname        |\n\t *| rname        |\n\t *| serial       |\n\t *| refresh      |\n\t *| retry        |\n\t *| expire       |\n\t *| minimum      |\n\t */\n\tif (_dns_get_RAW(rrs, domain, maxsize, ttl, data, &len) != 0) {\n\t\treturn -1;\n\t}\n\n\tsafe_strncpy(soa->mname, (char *)ptr, DNS_MAX_CNAME_LEN - 1);\n\tptr += strnlen(soa->mname, DNS_MAX_CNAME_LEN - 1) + 1;\n\tif (ptr - data >= len) {\n\t\treturn -1;\n\t}\n\tsafe_strncpy(soa->rname, (char *)ptr, DNS_MAX_CNAME_LEN - 1);\n\tptr += strnlen(soa->rname, DNS_MAX_CNAME_LEN - 1) + 1;\n\tif (ptr - data + 20 > len) {\n\t\treturn -1;\n\t}\n\tmemcpy(&soa->serial, ptr, 4);\n\tptr += 4;\n\tmemcpy(&soa->refresh, ptr, 4);\n\tptr += 4;\n\tmemcpy(&soa->retry, ptr, 4);\n\tptr += 4;\n\tmemcpy(&soa->expire, ptr, 4);\n\tptr += 4;\n\tmemcpy(&soa->minimum, ptr, 4);\n\n\treturn 0;\n}\n\nint dns_set_OPT_payload_size(struct dns_packet *packet, int payload_size)\n{\n\tif (payload_size < 512) {\n\t\tpayload_size = 512;\n\t}\n\n\tpacket->payloadsize = payload_size;\n\treturn 0;\n}\n\nint dns_get_OPT_payload_size(struct dns_packet *packet)\n{\n\treturn packet->payloadsize;\n}\n\nint dns_add_OPT_ECS(struct dns_packet *packet, struct dns_opt_ecs *ecs)\n{\n\tunsigned char opt_data[DNS_MAX_OPT_LEN];\n\tstruct dns_opt *opt = (struct dns_opt *)opt_data;\n\tint len = 0;\n\n\t/* ecs size 4 + bit of address*/\n\tlen = 4;\n\tlen += (ecs->source_prefix / 8);\n\tlen += (ecs->source_prefix % 8 > 0) ? 1 : 0;\n\n\topt->length = len;\n\topt->code = DNS_OPT_T_ECS;\n\tmemcpy(opt->data, ecs, len);\n\tlen += sizeof(*opt);\n\n\treturn _dns_add_RAW(packet, DNS_RRS_OPT, (dns_type_t)DNS_OPT_T_ECS, \"\", 0, opt_data, len);\n}\n\nint dns_get_OPT_ECS(struct dns_rrs *rrs, unsigned short *opt_code, unsigned short *opt_len, struct dns_opt_ecs *ecs)\n{\n\tunsigned char opt_data[DNS_MAX_OPT_LEN];\n\tchar domain[DNS_MAX_CNAME_LEN] = {0};\n\tstruct dns_opt *opt = (struct dns_opt *)opt_data;\n\tint len = DNS_MAX_OPT_LEN;\n\tint ttl = 0;\n\n\tif (_dns_get_RAW(rrs, domain, DNS_MAX_CNAME_LEN, &ttl, opt_data, &len) != 0) {\n\t\treturn -1;\n\t}\n\n\tif (len < (int)sizeof(*opt)) {\n\t\treturn -1;\n\t}\n\n\tif (opt->code != DNS_OPT_T_ECS) {\n\t\treturn -1;\n\t}\n\n\tmemcpy(ecs, opt->data, opt->length);\n\n\treturn 0;\n}\n\nint dns_add_OPT_TCP_KEEPALIVE(struct dns_packet *packet, unsigned short timeout)\n{\n\tunsigned short timeout_net = htons(timeout);\n\tint data_len = 0;\n\n\tif (timeout > 0) {\n\t\tdata_len = sizeof(timeout);\n\t}\n\n\treturn _dns_add_opt_RAW(packet, DNS_OPT_T_TCP_KEEPALIVE, &timeout_net, data_len);\n}\n\nint dns_get_OPT_TCP_KEEPALIVE(struct dns_rrs *rrs, unsigned short *opt_code, unsigned short *opt_len,\n\t\t\t\t\t\t\t  unsigned short *timeout)\n{\n\tunsigned char opt_data[DNS_MAX_OPT_LEN];\n\tstruct dns_opt *opt = (struct dns_opt *)opt_data;\n\tint len = DNS_MAX_OPT_LEN;\n\tint ttl = 0;\n\tunsigned char *data = NULL;\n\n\tif (_dns_get_opt_RAW(rrs, NULL, 0, &ttl, opt, &len) != 0) {\n\t\treturn -1;\n\t}\n\n\tif (len < (int)sizeof(*opt)) {\n\t\treturn -1;\n\t}\n\n\tif (opt->code != DNS_OPT_T_TCP_KEEPALIVE) {\n\t\treturn -1;\n\t}\n\n\tif (opt->length == 0) {\n\t\t*timeout = 0;\n\t\treturn 0;\n\t}\n\n\tif (opt->length != sizeof(unsigned short)) {\n\t\treturn -1;\n\t}\n\n\tdata = opt->data;\n\n\t*timeout = _dns_read_short(&data);\n\n\treturn 0;\n}\n\nint dns_add_HTTPS_start(struct dns_rr_nested *svcparam_buffer, struct dns_packet *packet, dns_rr_type type,\n\t\t\t\t\t\tconst char *domain, int ttl, int priority, const char *target)\n{\n\tsvcparam_buffer = dns_add_rr_nested_start(svcparam_buffer, packet, type, DNS_T_HTTPS, domain, ttl);\n\tif (svcparam_buffer == NULL) {\n\t\treturn -1;\n\t}\n\n\tint target_len = 0;\n\tif (target == NULL) {\n\t\ttarget = \"\";\n\t}\n\n\ttarget_len = strnlen(target, DNS_MAX_CNAME_LEN) + 1;\n\tif (_dns_left_len(&svcparam_buffer->context) < 2 + target_len) {\n\t\treturn -1;\n\t}\n\n\t/* add rr data */\n\t_dns_write_short(&svcparam_buffer->context.ptr, priority);\n\tsafe_strncpy((char *)svcparam_buffer->context.ptr, target, target_len);\n\tsvcparam_buffer->context.ptr += target_len;\n\n\treturn 0;\n}\n\nint dns_HTTPS_add_raw(struct dns_rr_nested *svcparam, unsigned short key, unsigned char *value, unsigned short len)\n{\n\tif (_dns_left_len(&svcparam->context) < 2 + len) {\n\t\treturn -1;\n\t}\n\n\tdns_add_rr_nested_memcpy(svcparam, &key, 2);\n\tdns_add_rr_nested_memcpy(svcparam, &len, 2);\n\tdns_add_rr_nested_memcpy(svcparam, value, len);\n\treturn 0;\n}\n\nint dns_HTTPS_add_port(struct dns_rr_nested *svcparam, unsigned short port)\n{\n\tif (_dns_left_len(&svcparam->context) < 6) {\n\t\treturn -1;\n\t}\n\n\tunsigned short value = DNS_HTTPS_T_PORT;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tvalue = 2;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tvalue = htons(port);\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\n\treturn 0;\n}\n\nint dns_HTTPS_add_alpn(struct dns_rr_nested *svcparam, const char *alpn, int alpn_len)\n{\n\tif (_dns_left_len(&svcparam->context) < 2 + 2 + alpn_len) {\n\t\treturn -1;\n\t}\n\n\tunsigned short value = DNS_HTTPS_T_ALPN;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\n\tvalue = alpn_len;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tdns_add_rr_nested_memcpy(svcparam, alpn, alpn_len);\n\n\treturn 0;\n}\n\nint dns_HTTPS_add_ech(struct dns_rr_nested *svcparam, void *ech, int ech_len)\n{\n\tif (_dns_left_len(&svcparam->context) < 2 + 2 + ech_len) {\n\t\treturn -1;\n\t}\n\n\tunsigned short value = DNS_HTTPS_T_ECH;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\n\tvalue = ech_len;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tdns_add_rr_nested_memcpy(svcparam, ech, ech_len);\n\n\treturn 0;\n}\n\nint dns_HTTPS_add_ipv4hint(struct dns_rr_nested *svcparam, unsigned char *addr[], int addr_num)\n{\n\tif (_dns_left_len(&svcparam->context) < 4 + addr_num * DNS_RR_A_LEN) {\n\t\treturn -1;\n\t}\n\n\tunsigned short value = DNS_HTTPS_T_IPV4HINT;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\n\tvalue = addr_num * DNS_RR_A_LEN;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\n\tfor (int i = 0; i < addr_num; i++) {\n\t\tdns_add_rr_nested_memcpy(svcparam, addr[i], DNS_RR_A_LEN);\n\t}\n\n\treturn 0;\n}\n\nint dns_HTTPS_add_ipv6hint(struct dns_rr_nested *svcparam, unsigned char *addr[], int addr_num)\n{\n\tif (_dns_left_len(&svcparam->context) < 4 + addr_num * DNS_RR_AAAA_LEN) {\n\t\treturn -1;\n\t}\n\n\tunsigned short value = DNS_HTTPS_T_IPV6HINT;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\n\tvalue = addr_num * DNS_RR_AAAA_LEN;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\n\tfor (int i = 0; i < addr_num; i++) {\n\t\tdns_add_rr_nested_memcpy(svcparam, addr[i], DNS_RR_AAAA_LEN);\n\t}\n\n\treturn 0;\n}\n\nint dns_add_HTTPS_end(struct dns_rr_nested *svcparam)\n{\n\treturn dns_add_rr_nested_end(svcparam, DNS_T_HTTPS);\n}\n\nint dns_get_HTTPS_svcparm_start(struct dns_rrs *rrs, struct dns_https_param **https_param, char *domain, int maxsize,\n\t\t\t\t\t\t\t\tint *ttl, int *priority, char *target, int target_size)\n{\n\tint qtype = 0;\n\tunsigned char *data = NULL;\n\tint rr_len = 0;\n\n\tdata = dns_get_rr_nested_start(rrs, domain, maxsize, &qtype, ttl, &rr_len);\n\tif (data == NULL) {\n\t\treturn -1;\n\t}\n\n\tif (qtype != DNS_T_HTTPS) {\n\t\treturn -1;\n\t}\n\n\tif (rr_len < 2) {\n\t\treturn -1;\n\t}\n\n\t*priority = _dns_read_short(&data);\n\trr_len -= 2;\n\tif (rr_len <= 0) {\n\t\treturn -1;\n\t}\n\n\tint len = strnlen((char *)data, rr_len);\n\tsafe_strncpy(target, (char *)data, target_size);\n\tdata += len + 1;\n\trr_len -= len + 1;\n\tif (rr_len < 0) {\n\t\treturn -1;\n\t}\n\n\tif (rr_len == 0) {\n\t\t*https_param = NULL;\n\t\treturn 0;\n\t}\n\n\t*https_param = (struct dns_https_param *)data;\n\n\treturn 0;\n}\n\nstruct dns_https_param *dns_get_HTTPS_svcparm_next(struct dns_rrs *rrs, struct dns_https_param *param)\n{\n\treturn dns_get_rr_nested_next(rrs, param, sizeof(struct dns_https_param) + param->len);\n}\n\n/*\n * Format:\n * |DNS_NAME\\0(string)|qtype(short)|qclass(short)|\n */\nint dns_add_domain(struct dns_packet *packet, const char *domain, int qtype, int qclass)\n{\n\tint len = 0;\n\tint ret = 0;\n\tstruct dns_context context;\n\n\tret = _dns_add_rrs_start(packet, &context);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tlen = _dns_add_qr_head(&context, domain, qtype, qclass);\n\tif (len < 0) {\n\t\treturn -1;\n\t}\n\n\treturn _dns_rr_add_end(packet, DNS_RRS_QD, DNS_T_CNAME, len);\n}\n\nint dns_get_domain(struct dns_rrs *rrs, char *domain, int maxsize, int *qtype, int *qclass)\n{\n\tstruct dns_context context;\n\n\t_dns_init_context_by_rrs(rrs, &context);\n\treturn _dns_get_qr_head(&context, domain, maxsize, qtype, qclass);\n}\n\nstatic int _dns_decode_head(struct dns_context *context)\n{\n\tunsigned int fields = 0;\n\tint len = 12;\n\tstruct dns_head *head = &context->packet->head;\n\n\tif (_dns_left_len(context) < len) {\n\t\treturn -1;\n\t}\n\n\t/*\n\t0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t|                      ID                       |\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t|QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t|                    QDCOUNT                    |\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t|                    ANCOUNT                    |\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t|                    NSCOUNT                    |\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t|                    ARCOUNT                    |\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t*/\n\n\thead->id = _dns_read_short(&context->ptr);\n\tfields = _dns_read_short(&context->ptr);\n\thead->qr = (fields & QR_MASK) >> 15;\n\thead->opcode = (fields & OPCODE_MASK) >> 11;\n\thead->aa = (fields & AA_MASK) >> 10;\n\thead->tc = (fields & TC_MASK) >> 9;\n\thead->rd = (fields & RD_MASK) >> 8;\n\thead->ra = (fields & RA_MASK) >> 7;\n\thead->rcode = (fields & RCODE_MASK) >> 0;\n\thead->qdcount = _dns_read_short(&context->ptr);\n\thead->ancount = _dns_read_short(&context->ptr);\n\thead->nscount = _dns_read_short(&context->ptr);\n\thead->nrcount = _dns_read_short(&context->ptr);\n\n\treturn 0;\n}\n\nstatic int _dns_encode_head(struct dns_context *context)\n{\n\tint len = 12;\n\tstruct dns_head *head = &context->packet->head;\n\n\tif (_dns_left_len(context) < len) {\n\t\treturn -1;\n\t}\n\n\t_dns_write_short(&context->ptr, head->id);\n\n\tint fields = 0;\n\tfields |= (head->qr << 15) & QR_MASK;\n\tfields |= (head->opcode << 11) & OPCODE_MASK;\n\tfields |= (head->aa << 10) & AA_MASK;\n\tfields |= (head->tc << 9) & TC_MASK;\n\tfields |= (head->rd << 8) & RD_MASK;\n\tfields |= (head->ra << 7) & RA_MASK;\n\tfields |= (head->rcode << 0) & RCODE_MASK;\n\t_dns_write_short(&context->ptr, fields);\n\n\t_dns_write_short(&context->ptr, head->qdcount);\n\t_dns_write_short(&context->ptr, head->ancount);\n\t_dns_write_short(&context->ptr, head->nscount);\n\t_dns_write_short(&context->ptr, head->nrcount);\n\treturn len;\n}\n\nstatic int _dns_encode_head_count(struct dns_context *context)\n{\n\tint len = 12;\n\tstruct dns_head *head = &context->packet->head;\n\tunsigned char *ptr = context->data;\n\n\tptr += 4;\n\t_dns_write_short(&ptr, head->qdcount);\n\t_dns_write_short(&ptr, head->ancount);\n\t_dns_write_short(&ptr, head->nscount);\n\t_dns_write_short(&ptr, head->nrcount);\n\treturn len;\n}\n\nstatic int _dns_decode_qr_head(struct dns_context *context, char *domain, int domain_size, int *qtype, int *qclass)\n{\n\tint ret = 0;\n\t/*\n\t0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t|                                               |\n\t/                                               /\n\t/                      NAME                     /\n\t|                                               |\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t|                      TYPE                     |\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t|                     CLASS                     |\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t*/\n\tret = _dns_decode_domain(context, domain, domain_size);\n\tif (ret < 0) {\n\t\ttlog(TLOG_DEBUG, \"decode domain failed.\");\n\t\treturn -1;\n\t}\n\n\tif (_dns_left_len(context) < 4) {\n\t\ttlog(TLOG_DEBUG, \"left length is not enough, %s.\", domain);\n\t\treturn -1;\n\t}\n\n\t*qtype = _dns_read_short(&context->ptr);\n\t*qclass = _dns_read_short(&context->ptr);\n\n\treturn 0;\n}\n\nstatic int _dns_encode_qr_head(struct dns_context *context, char *domain, int qtype, int qclass)\n{\n\tint ret = 0;\n\tret = _dns_encode_domain(context, domain);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tif (_dns_left_len(context) < 4) {\n\t\treturn -1;\n\t}\n\n\t_dns_write_short(&context->ptr, qtype);\n\t_dns_write_short(&context->ptr, qclass);\n\n\treturn 0;\n}\n\nstatic int _dns_decode_rr_head(struct dns_context *context, char *domain, int domain_size, int *qtype, int *qclass,\n\t\t\t\t\t\t\t   int *ttl, int *rr_len)\n{\n\tint len = 0;\n\n\tlen = _dns_decode_qr_head(context, domain, domain_size, qtype, qclass);\n\tif (len < 0) {\n\t\ttlog(TLOG_DEBUG, \"decode qr head failed.\");\n\t\treturn -1;\n\t}\n\n\tif (_dns_left_len(context) < 6) {\n\t\ttlog(TLOG_DEBUG, \"left length is not enough.\");\n\t\treturn -1;\n\t}\n\n\t*ttl = _dns_read_int(&context->ptr);\n\t*rr_len = _dns_read_short(&context->ptr);\n\n\tif (*rr_len < 0 || *ttl < 0) {\n\t\ttlog(TLOG_DEBUG, \"rr len or ttl is invalid.\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int _dns_encode_rr_head(struct dns_context *context, char *domain, int qtype, int qclass, int ttl, int rr_len,\n\t\t\t\t\t\t\t   unsigned char **rr_len_ptr)\n{\n\tint ret = 0;\n\tret = _dns_encode_qr_head(context, domain, qtype, qclass);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tif (_dns_left_len(context) < 6) {\n\t\treturn -1;\n\t}\n\n\t_dns_write_int(&context->ptr, ttl);\n\tif (rr_len_ptr) {\n\t\t*rr_len_ptr = context->ptr;\n\t}\n\t_dns_write_short(&context->ptr, rr_len);\n\n\treturn 0;\n}\n\nstatic int _dns_encode_raw(struct dns_context *context, struct dns_rrs *rrs)\n{\n\tint ret = 0;\n\tint qtype = 0;\n\tint qclass = 0;\n\tint ttl = 0;\n\tchar domain[DNS_MAX_CNAME_LEN];\n\tint rr_len = 0;\n\tunsigned char *rr_len_ptr = NULL;\n\tstruct dns_context data_context;\n\t/*\n\t0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t|                                               |\n\t/                                               /\n\t/                      NAME                     /\n\t|                                               |\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t|                      TYPE                     |\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t|                     CLASS                     |\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t|                      TTL                      |\n\t|                                               |\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t|                   RDLENGTH                    |\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|\n\t/                     RDATA                     /\n\t/                                               /\n\t+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\t*/\n\t_dns_init_context_by_rrs(rrs, &data_context);\n\tret = _dns_get_rr_head(&data_context, domain, DNS_MAX_CNAME_LEN, &qtype, &qclass, &ttl, &rr_len);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tret = _dns_encode_rr_head(context, domain, qtype, qclass, ttl, rr_len, &rr_len_ptr);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tif (_dns_left_len(context) < rr_len) {\n\t\treturn -1;\n\t}\n\n\tmemcpy(context->ptr, data_context.ptr, rr_len);\n\tcontext->ptr += rr_len;\n\tdata_context.ptr += rr_len;\n\n\treturn 0;\n}\n\nstatic int _dns_decode_raw(struct dns_context *context, unsigned char *raw, int len)\n{\n\tif (_dns_left_len(context) < len || len < 0) {\n\t\treturn -1;\n\t}\n\n\tmemcpy(raw, context->ptr, len);\n\tcontext->ptr += len;\n\treturn 0;\n}\n\nstatic int _dns_decode_CNAME(struct dns_context *context, char *cname, int cname_size)\n{\n\tint ret = 0;\n\tret = _dns_decode_domain(context, cname, cname_size);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int _dns_encode_CNAME(struct dns_context *context, struct dns_rrs *rrs)\n{\n\tint ret = 0;\n\tint qtype = 0;\n\tint qclass = 0;\n\tint ttl = 0;\n\tchar domain[DNS_MAX_CNAME_LEN];\n\tint rr_len = 0;\n\tunsigned char *rr_len_ptr = NULL;\n\tstruct dns_context data_context;\n\n\t_dns_init_context_by_rrs(rrs, &data_context);\n\tret = _dns_get_rr_head(&data_context, domain, DNS_MAX_CNAME_LEN, &qtype, &qclass, &ttl, &rr_len);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\t/* when code domain, len must plus 1, because of length at the beginning */\n\trr_len = 1;\n\tret = _dns_encode_rr_head(context, domain, qtype, qclass, ttl, rr_len, &rr_len_ptr);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tret = _dns_encode_domain(context, (char *)data_context.ptr);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\trr_len += ret;\n\tdata_context.ptr += strnlen((char *)(data_context.ptr), DNS_MAX_CNAME_LEN) + 1;\n\n\tif (rr_len > rrs->len) {\n\t\treturn -1;\n\t}\n\t_dns_write_short(&rr_len_ptr, ret);\n\n\treturn 0;\n}\n\nstatic int _dns_decode_SOA(struct dns_context *context, struct dns_soa *soa)\n{\n\tint ret = 0;\n\tret = _dns_decode_domain(context, soa->mname, DNS_MAX_CNAME_LEN - 1);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tret = _dns_decode_domain(context, soa->rname, DNS_MAX_CNAME_LEN - 1);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tif (_dns_left_len(context) < 20) {\n\t\treturn -1;\n\t}\n\n\tsoa->serial = _dns_read_int(&context->ptr);\n\tsoa->refresh = _dns_read_int(&context->ptr);\n\tsoa->retry = _dns_read_int(&context->ptr);\n\tsoa->expire = _dns_read_int(&context->ptr);\n\tsoa->minimum = _dns_read_int(&context->ptr);\n\n\treturn 0;\n}\n\nstatic int _dns_encode_SOA(struct dns_context *context, struct dns_rrs *rrs)\n{\n\tint ret = 0;\n\tint qtype = 0;\n\tint qclass = 0;\n\tint ttl = 0;\n\tchar domain[DNS_MAX_CNAME_LEN];\n\tint rr_len = 0;\n\tunsigned char *rr_len_ptr = NULL;\n\tstruct dns_context data_context;\n\n\t_dns_init_context_by_rrs(rrs, &data_context);\n\tret = _dns_get_rr_head(&data_context, domain, DNS_MAX_CNAME_LEN, &qtype, &qclass, &ttl, &rr_len);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tret = _dns_encode_rr_head(context, domain, qtype, qclass, ttl, rr_len, &rr_len_ptr);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\trr_len = 0;\n\t/* mname */\n\tret = _dns_encode_domain(context, (char *)data_context.ptr);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\trr_len += ret;\n\tdata_context.ptr += strnlen((char *)(data_context.ptr), DNS_MAX_CNAME_LEN) + 1;\n\n\t/* rname */\n\tret = _dns_encode_domain(context, (char *)data_context.ptr);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\trr_len += ret;\n\tdata_context.ptr += strnlen((char *)(data_context.ptr), DNS_MAX_CNAME_LEN) + 1;\n\tif (rr_len > rrs->len) {\n\t\treturn -1;\n\t}\n\n\trr_len += 20;\n\t_dns_write_short(&rr_len_ptr, rr_len);\n\tif (_dns_left_len(context) < 20) {\n\t\treturn -1;\n\t}\n\n\t_dns_write_int(&context->ptr, *(unsigned int *)data_context.ptr);\n\tdata_context.ptr += 4;\n\t_dns_write_int(&context->ptr, *(unsigned int *)data_context.ptr);\n\tdata_context.ptr += 4;\n\t_dns_write_int(&context->ptr, *(unsigned int *)data_context.ptr);\n\tdata_context.ptr += 4;\n\t_dns_write_int(&context->ptr, *(unsigned int *)data_context.ptr);\n\tdata_context.ptr += 4;\n\t_dns_write_int(&context->ptr, *(unsigned int *)data_context.ptr);\n\tdata_context.ptr += 4;\n\n\treturn 0;\n}\n\nstatic int _dns_decode_opt_ecs(struct dns_context *context, struct dns_opt_ecs *ecs, int opt_len)\n{\n\t// TODO\n\n\tint len = 0;\n\tif (opt_len < 4) {\n\t\treturn -1;\n\t}\n\n\tecs->family = _dns_read_short(&context->ptr);\n\tecs->source_prefix = _dns_read_char(&context->ptr);\n\tecs->scope_prefix = _dns_read_char(&context->ptr);\n\tlen = (ecs->source_prefix / 8);\n\tlen += (ecs->source_prefix % 8 > 0) ? 1 : 0;\n\n\tif (_dns_left_len(context) < len || len > (int)sizeof(ecs->addr)) {\n\t\treturn -1;\n\t}\n\n\tmemcpy(ecs->addr, context->ptr, len);\n\tcontext->ptr += len;\n\n\ttlog(TLOG_DEBUG, \"ECS: family:%d, source_prefix:%d, scope_prefix:%d, len:%d\", ecs->family, ecs->source_prefix,\n\t\t ecs->scope_prefix, len);\n\ttlog(TLOG_DEBUG, \"%d.%d.%d.%d\", ecs->addr[0], ecs->addr[1], ecs->addr[2], ecs->addr[3]);\n\n\treturn 0;\n}\n\nstatic int _dns_decode_opt_cookie(struct dns_context *context, struct dns_opt_cookie *cookie, int opt_len)\n{\n\t// TODO\n\tif (opt_len < (int)member_size(struct dns_opt_cookie, client_cookie)) {\n\t\treturn -1;\n\t}\n\n\tint len = 8;\n\tmemcpy(cookie->client_cookie, context->ptr, len);\n\tcontext->ptr += len;\n\n\topt_len -= len;\n\tif (opt_len <= 0) {\n\t\tcookie->server_cookie_len = 0;\n\t\treturn 0;\n\t}\n\n\tif (opt_len < 8 || opt_len > (int)member_size(struct dns_opt_cookie, server_cookie)) {\n\t\treturn -1;\n\t}\n\n\tmemcpy(cookie->server_cookie, context->ptr, opt_len);\n\tcookie->server_cookie_len = opt_len;\n\tcontext->ptr += opt_len;\n\n\ttlog(TLOG_DEBUG, \"OPT COOKIE\");\n\treturn 0;\n}\n\nstatic int _dns_encode_OPT(struct dns_context *context, struct dns_rrs *rrs)\n{\n\tint ret = 0;\n\tint opt_code = 0;\n\tint qclass = 0;\n\tchar domain[DNS_MAX_CNAME_LEN];\n\tstruct dns_context data_context;\n\tint rr_len = 0;\n\tint ttl = 0;\n\tstruct dns_opt *dns_opt = NULL;\n\n\t_dns_init_context_by_rrs(rrs, &data_context);\n\tret = _dns_get_rr_head(&data_context, domain, DNS_MAX_CNAME_LEN, &opt_code, &qclass, &ttl, &rr_len);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tif (rr_len < (int)sizeof(*dns_opt)) {\n\t\treturn -1;\n\t}\n\n\tif (_dns_left_len(context) < (rr_len)) {\n\t\treturn -1;\n\t}\n\n\tdns_opt = (struct dns_opt *)data_context.ptr;\n\t_dns_write_short(&context->ptr, dns_opt->code);\n\t_dns_write_short(&context->ptr, dns_opt->length);\n\n\tif (_dns_left_len(context) < dns_opt->length) {\n\t\treturn -1;\n\t}\n\n\tswitch (dns_opt->code) {\n\tcase DNS_OPT_T_ECS: {\n\t\tstruct dns_opt_ecs *ecs = (struct dns_opt_ecs *)&(dns_opt->data);\n\t\t_dns_write_short(&context->ptr, ecs->family);\n\t\t_dns_write_char(&context->ptr, ecs->source_prefix);\n\t\t_dns_write_char(&context->ptr, ecs->scope_prefix);\n\t\tmemcpy(context->ptr, ecs->addr, dns_opt->length - 4);\n\t\tcontext->ptr += dns_opt->length - 4;\n\t} break;\n\tdefault:\n\t\tmemcpy(context->ptr, dns_opt->data, dns_opt->length);\n\t\tcontext->ptr += dns_opt->length;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int _dns_get_opts_data_len(struct dns_packet *packet, struct dns_rrs *rrs, int count)\n{\n\tint i = 0;\n\tint len = 0;\n\tint opt_code = 0;\n\tint qclass = 0;\n\tint ttl = 0;\n\tint ret = 0;\n\tchar domain[DNS_MAX_CNAME_LEN];\n\tstruct dns_context data_context;\n\tint rr_len = 0;\n\n\tfor (i = 0; i < count && rrs; i++, rrs = dns_get_rrs_next(packet, rrs)) {\n\t\t_dns_init_context_by_rrs(rrs, &data_context);\n\t\tret = _dns_get_rr_head(&data_context, domain, DNS_MAX_CNAME_LEN, &opt_code, &qclass, &ttl, &rr_len);\n\t\tif (ret < 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen += rr_len;\n\t}\n\n\treturn len;\n}\n\nstatic int _dns_encode_opts(struct dns_packet *packet, struct dns_context *context, struct dns_rrs *rrs, int count)\n{\n\tint i = 0;\n\tint len = 0;\n\tint ret = 0;\n\tunsigned int rcode = 0;\n\tint rr_len = 0;\n\tint payloadsize = packet->payloadsize;\n\tunsigned char *rr_len_ptr = NULL;\n\n\trr_len = _dns_get_opts_data_len(packet, rrs, count);\n\tif (rr_len < 0) {\n\t\treturn -1;\n\t}\n\n\tif (payloadsize < DNS_DEFAULT_PACKET_SIZE) {\n\t\tpayloadsize = DNS_DEFAULT_PACKET_SIZE;\n\t}\n\n\tret = _dns_encode_rr_head(context, \"\", DNS_T_OPT, payloadsize, rcode, rr_len, &rr_len_ptr);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tif (_dns_left_len(context) < rr_len) {\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < count && rrs; i++, rrs = dns_get_rrs_next(packet, rrs)) {\n\t\tlen = _dns_encode_OPT(context, rrs);\n\t\tif (len < 0) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int _dns_decode_opt(struct dns_context *context, dns_rr_type type, unsigned int ttl, int rr_len)\n{\n\tunsigned short opt_code = 0;\n\tunsigned short opt_len = 0;\n\tunsigned short errcode = (ttl >> 16) & 0xFFFF;\n\tunsigned short ever = (ttl)&0xFFFF;\n\tunsigned char *start = context->ptr;\n\tstruct dns_packet *packet = context->packet;\n\tint ret = 0;\n\n\tUNUSED(ever);\n\n\t/*\n\t\t Field Name   Field Type     Description\n\t ------------------------------------------------------\n\t NAME         domain name    empty (root domain)\n\t TYPE         u_int16_t      OPT\n\t CLASS        u_int16_t      sender's UDP payload size\n\t TTL          u_int32_t      extended RCODE and flags\n\t RDLEN        u_int16_t      describes RDATA\n\t RDATA        octet stream   {attribute,value} pairs\n\n\t\t\t\t\t +0 (MSB)                            +1 (LSB)\n\t +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n  0: |                          OPTION-CODE                          |\n\t +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n  2: |                         OPTION-LENGTH                         |\n\t +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n  4: |                                                               |\n\t /                          OPTION-DATA                          /\n\t /                                                               /\n\t +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n\tTTL\n\t\t\t\t +0 (MSB)                            +1 (LSB)\n\t  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n   0: |         EXTENDED-RCODE        |            VERSION            |\n\t  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n   2: |                               Z                               |\n\t  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\t*/\n\n\tif (rr_len < 0) {\n\t\ttlog(TLOG_DEBUG, \"opt len is invalid.\");\n\t\treturn -1;\n\t}\n\n\tif (errcode != 0) {\n\t\ttlog(TLOG_DEBUG, \"extend rcode invalid, %d\", errcode);\n\t\treturn 0;\n\t}\n\n\twhile (context->ptr - start < rr_len) {\n\t\tif (_dns_left_len(context) < 4) {\n\t\t\ttlog(TLOG_DEBUG, \"data length is invalid, %d:%d\", _dns_left_len(context),\n\t\t\t\t (int)(context->ptr - context->data));\n\t\t\treturn -1;\n\t\t}\n\t\topt_code = _dns_read_short(&context->ptr);\n\t\topt_len = _dns_read_short(&context->ptr);\n\n\t\tif (_dns_left_len(context) < opt_len) {\n\t\t\ttlog(TLOG_DEBUG, \"read opt data failed, opt_code = %d, opt_len = %d\", opt_code, opt_len);\n\t\t\treturn -1;\n\t\t}\n\n\t\ttlog(TLOG_DEBUG, \"opt type %d\", opt_code);\n\t\tswitch (opt_code) {\n\t\tcase DNS_OPT_T_ECS: {\n\t\t\tstruct dns_opt_ecs ecs;\n\t\t\tret = _dns_decode_opt_ecs(context, &ecs, opt_len);\n\t\t\tif (ret != 0) {\n\t\t\t\ttlog(TLOG_ERROR, \"decode ecs failed.\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tret = dns_add_OPT_ECS(packet, &ecs);\n\t\t\tif (ret != 0) {\n\t\t\t\ttlog(TLOG_ERROR, \"add ecs failed.\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} break;\n\t\tcase DNS_OPT_T_COOKIE: {\n\t\t\tstruct dns_opt_cookie cookie;\n\t\t\tret = _dns_decode_opt_cookie(context, &cookie, opt_len);\n\t\t\tif (ret != 0) {\n\t\t\t\ttlog(TLOG_ERROR, \"decode cookie failed.\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} break;\n\t\tcase DNS_OPT_T_PADDING:\n\t\t\tcontext->ptr += opt_len;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontext->ptr += opt_len;\n\t\t\ttlog(TLOG_DEBUG, \"DNS opt type = %d not supported\", opt_code);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int _dns_encode_HTTPS(struct dns_context *context, struct dns_rrs *rrs)\n{\n\tint ret = 0;\n\tint qtype = 0;\n\tint qclass = 0;\n\tchar domain[DNS_MAX_CNAME_LEN];\n\tchar target[DNS_MAX_CNAME_LEN] = {0};\n\tunsigned char *rr_len_ptr = NULL;\n\tunsigned char *start = NULL;\n\tunsigned char *rr_start = NULL;\n\tint ttl = 0;\n\tint priority = 0;\n\tstruct dns_https_param *param = NULL;\n\n\tret =\n\t\tdns_get_HTTPS_svcparm_start(rrs, &param, domain, DNS_MAX_CNAME_LEN, &ttl, &priority, target, DNS_MAX_CNAME_LEN);\n\tif (ret < 0) {\n\t\ttlog(TLOG_DEBUG, \"get https param failed.\");\n\t\treturn 0;\n\t}\n\n\tqtype = DNS_T_HTTPS;\n\tqclass = DNS_C_IN;\n\n\tret = _dns_encode_rr_head(context, domain, qtype, qclass, ttl, 0, &rr_len_ptr);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\trr_start = context->ptr;\n\tif (_dns_left_len(context) < 2) {\n\t\ttlog(TLOG_ERROR, \"left len is invalid.\");\n\t\treturn -1;\n\t}\n\n\t_dns_write_short(&context->ptr, priority);\n\tret = _dns_encode_domain(context, target);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tstart = context->ptr;\n\tfor (; param != NULL; param = dns_get_HTTPS_svcparm_next(rrs, param)) {\n\t\tif (context->ptr - start > rrs->len || _dns_left_len(context) <= 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (param->len + 4 > _dns_left_len(context)) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t_dns_write_short(&context->ptr, param->key);\n\t\t_dns_write_short(&context->ptr, param->len);\n\t\tswitch (param->key) {\n\t\tcase DNS_HTTPS_T_MANDATORY:\n\t\tcase DNS_HTTPS_T_NO_DEFAULT_ALPN:\n\t\tcase DNS_HTTPS_T_ALPN:\n\t\tcase DNS_HTTPS_T_PORT:\n\t\tcase DNS_HTTPS_T_IPV4HINT:\n\t\tcase DNS_HTTPS_T_ECH:\n\t\tcase DNS_HTTPS_T_IPV6HINT: {\n\t\t\tmemcpy(context->ptr, param->value, param->len);\n\t\t\tcontext->ptr += param->len;\n\t\t} break;\n\t\tdefault:\n\t\t\t/* skip unknown key */\n\t\t\tcontext->ptr -= 4;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (_dns_left_len(context) < 2) {\n\t\treturn -1;\n\t}\n\n\t_dns_write_short(&rr_len_ptr, context->ptr - rr_start);\n\n\treturn 0;\n}\n\nstatic int _dns_decode_HTTPS(struct dns_context *context, const char *domain, dns_rr_type type, unsigned int ttl,\n\t\t\t\t\t\t\t int rr_len)\n{\n\tunsigned char *start = context->ptr;\n\n\tstruct dns_packet *packet = context->packet;\n\tint ret = 0;\n\tunsigned short priority;\n\tunsigned short key;\n\tunsigned short value_len;\n\tunsigned char *value = NULL;\n\tchar target[DNS_MAX_CNAME_LEN] = {0};\n\tstruct dns_rr_nested param;\n\n\tif (rr_len < 2) {\n\t\ttlog(TLOG_DEBUG, \"https len is invalid.\");\n\t\treturn -1;\n\t}\n\n\tpriority = _dns_read_short(&context->ptr);\n\tret = _dns_decode_domain(context, target, sizeof(target));\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tdns_add_HTTPS_start(&param, packet, DNS_RRS_AN, domain, ttl, priority, target);\n\n\twhile (context->ptr - start < rr_len) {\n\t\tif (_dns_left_len(context) < 4) {\n\t\t\ttlog(TLOG_WARN, \"data length is invalid, %d:%d\", _dns_left_len(context),\n\t\t\t\t (int)(context->ptr - context->data));\n\t\t\treturn -1;\n\t\t}\n\t\tkey = _dns_read_short(&context->ptr);\n\t\tvalue_len = _dns_read_short(&context->ptr);\n\t\tvalue = context->ptr;\n\n\t\tif (_dns_left_len(context) < value_len) {\n\t\t\ttlog(TLOG_ERROR, \"read https data failed, svcParam key = %d, https_len = %d\", key, value_len);\n\t\t\treturn -1;\n\t\t}\n\n\t\tswitch (key) {\n\t\tcase DNS_HTTPS_T_MANDATORY:\n\t\tcase DNS_HTTPS_T_ALPN:\n\t\tcase DNS_HTTPS_T_NO_DEFAULT_ALPN:\n\t\tcase DNS_HTTPS_T_PORT:\n\t\tcase DNS_HTTPS_T_IPV4HINT:\n\t\tcase DNS_HTTPS_T_ECH:\n\t\tcase DNS_HTTPS_T_IPV6HINT: {\n\t\t\tdns_HTTPS_add_raw(&param, key, value, value_len);\n\t\t} break;\n\t\tdefault:\n\t\t\ttlog(TLOG_DEBUG, \"DNS HTTPS key = %d not supported\", key);\n\t\t\tbreak;\n\t\t}\n\n\t\tcontext->ptr += value_len;\n\t}\n\n\tdns_add_HTTPS_end(&param);\n\n\treturn 0;\n}\n\nstatic int _dns_decode_qd(struct dns_context *context)\n{\n\tstruct dns_packet *packet = context->packet;\n\tint len = 0;\n\tint qtype = 0;\n\tint qclass = 0;\n\tchar domain[DNS_MAX_CNAME_LEN];\n\n\tlen = _dns_decode_qr_head(context, domain, DNS_MAX_CNAME_LEN, &qtype, &qclass);\n\tif (len < 0) {\n\t\treturn -1;\n\t}\n\n\tlen = dns_add_domain(packet, domain, qtype, qclass);\n\tif (len < 0) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int _dns_decode_an(struct dns_context *context, dns_rr_type type)\n{\n\tint ret = 0;\n\tint qtype = 0;\n\tint qclass = 0;\n\tint ttl = 0;\n\tint rr_len = 0;\n\tchar domain[DNS_MAX_CNAME_LEN];\n\tstruct dns_packet *packet = context->packet;\n\tunsigned char *start = NULL;\n\n\t/* decode rr head */\n\tret = _dns_decode_rr_head(context, domain, DNS_MAX_CNAME_LEN, &qtype, &qclass, &ttl, &rr_len);\n\tif (ret < 0 || qclass < 0) {\n\t\ttlog(TLOG_DEBUG, \"decode head failed.\");\n\t\treturn -1;\n\t}\n\tstart = context->ptr;\n\n\t/* decode answer */\n\tswitch (qtype) {\n\tcase DNS_T_A: {\n\t\tunsigned char addr[DNS_RR_A_LEN];\n\t\tret = _dns_decode_raw(context, addr, sizeof(addr));\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"decode A failed, %s, len: %d:%d\", domain, (int)(context->ptr - context->data),\n\t\t\t\t _dns_left_len(context));\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = dns_add_A(packet, type, domain, ttl, addr);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_ERROR, \"add A failed, %s\", domain);\n\t\t\treturn -1;\n\t\t}\n\t} break;\n\tcase DNS_T_CNAME: {\n\t\tchar cname[DNS_MAX_CNAME_LEN];\n\t\tret = _dns_decode_CNAME(context, cname, DNS_MAX_CNAME_LEN);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"decode CNAME failed, %s, len: %d:%d\", domain, (int)(context->ptr - context->data),\n\t\t\t\t _dns_left_len(context));\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = dns_add_CNAME(packet, type, domain, ttl, cname);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_ERROR, \"add CNAME failed, %s\", domain);\n\t\t\treturn -1;\n\t\t}\n\t} break;\n\tcase DNS_T_SOA: {\n\t\tstruct dns_soa soa;\n\t\tret = _dns_decode_SOA(context, &soa);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"decode SOA failed, %s\", domain);\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = dns_add_SOA(packet, type, domain, ttl, &soa);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_ERROR, \"add SOA failed, %s\", domain);\n\t\t\treturn -1;\n\t\t}\n\t} break;\n\tcase DNS_T_NS: {\n\t\tchar ns[DNS_MAX_CNAME_LEN];\n\t\tret = _dns_decode_CNAME(context, ns, DNS_MAX_CNAME_LEN);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"decode NS failed, %s\", domain);\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = dns_add_NS(packet, type, domain, ttl, ns);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_ERROR, \"add NS failed, %s\", domain);\n\t\t\treturn -1;\n\t\t}\n\t} break;\n\tcase DNS_T_PTR: {\n\t\tchar name[DNS_MAX_CNAME_LEN];\n\t\tret = _dns_decode_CNAME(context, name, DNS_MAX_CNAME_LEN);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"decode PTR failed, %s\", domain);\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = dns_add_PTR(packet, type, domain, ttl, name);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_ERROR, \"add PTR failed, %s\", domain);\n\t\t\treturn -1;\n\t\t}\n\t} break;\n\tcase DNS_T_AAAA: {\n\t\tunsigned char addr[DNS_RR_AAAA_LEN];\n\t\tret = _dns_decode_raw(context, addr, sizeof(addr));\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"decode AAAA failed, %s\", domain);\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = dns_add_AAAA(packet, type, domain, ttl, addr);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_ERROR, \"add AAAA failed, %s\", domain);\n\t\t\treturn -1;\n\t\t}\n\t} break;\n\tcase DNS_T_OPT: {\n\t\tunsigned char *opt_start = context->ptr;\n\t\tret = _dns_decode_opt(context, type, ttl, rr_len);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"decode opt failed, %s\", domain);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (context->ptr - opt_start != rr_len) {\n\t\t\ttlog(TLOG_DEBUG, \"opt length mismatch, %s\\n\", domain);\n\t\t\treturn -1;\n\t\t}\n\n\t\tdns_set_OPT_payload_size(packet, qclass);\n\t} break;\n\tcase DNS_T_HTTPS: {\n\t\tunsigned char *https_start = context->ptr;\n\t\tret = _dns_decode_HTTPS(context, domain, type, ttl, rr_len);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"decode HTTPS failed, %s\", domain);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (context->ptr - https_start != rr_len) {\n\t\t\ttlog(TLOG_DEBUG, \"opt length mismatch, %s\\n\", domain);\n\t\t\treturn -1;\n\t\t}\n\t} break;\n\tdefault: {\n\t\tunsigned char raw_data[1024];\n\t\tif (_dns_left_len(context) < rr_len || rr_len >= (int)sizeof(raw_data)) {\n\t\t\ttlog(TLOG_DEBUG, \"length mismatch\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = _dns_decode_raw(context, raw_data, rr_len);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"decode A failed, %s\", domain);\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = _dns_add_RAW(packet, type, qtype, domain, ttl, raw_data, rr_len);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_ERROR, \"add raw failed, %s\", domain);\n\t\t\treturn -1;\n\t\t}\n\n\t\ttlog(TLOG_DEBUG, \"DNS type = %d not supported\", qtype);\n\t\tbreak;\n\t}\n\t}\n\n\tif (context->ptr - start != rr_len) {\n\t\ttlog(TLOG_ERROR, \"length mismatch, %s, %ld:%d\", domain, (long)(context->ptr - start), rr_len);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int _dns_encode_qd(struct dns_context *context, struct dns_rrs *rrs)\n{\n\tint ret = 0;\n\tint qtype = 0;\n\tint qclass = 0;\n\tchar domain[DNS_MAX_CNAME_LEN];\n\tstruct dns_context data_context;\n\n\t_dns_init_context_by_rrs(rrs, &data_context);\n\tret = _dns_get_qr_head(&data_context, domain, DNS_MAX_CNAME_LEN, &qtype, &qclass);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tret = _dns_encode_qr_head(context, domain, qtype, qclass);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tif (domain[0] == '-') {\n\t\t/* for google and cloudflare */\n\t\tunsigned char *ptr = context->ptr - 7;\n\t\tmemcpy(ptr, \"\\xC0\\x12\", 2);\n\t\tptr += 2;\n\t\t_dns_write_short(&ptr, qtype);\n\t\t_dns_write_short(&ptr, qclass);\n\t\tcontext->ptr = ptr;\n\t}\n\n\treturn 0;\n}\n\nstatic int _dns_encode_an(struct dns_context *context, struct dns_rrs *rrs)\n{\n\tint ret = 0;\n\tswitch (rrs->type) {\n\tcase DNS_T_A:\n\tcase DNS_T_AAAA: {\n\t\tret = _dns_encode_raw(context, rrs);\n\t\tif (ret < 0) {\n\t\t\treturn -1;\n\t\t}\n\t} break;\n\tcase DNS_T_CNAME:\n\tcase DNS_T_PTR:\n\t\tret = _dns_encode_CNAME(context, rrs);\n\t\tif (ret < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase DNS_T_SOA:\n\t\tret = _dns_encode_SOA(context, rrs);\n\t\tif (ret < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase DNS_T_HTTPS:\n\t\tret = _dns_encode_HTTPS(context, rrs);\n\t\tif (ret < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = _dns_encode_raw(context, rrs);\n\t\tif (ret < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int _dns_decode_body(struct dns_context *context)\n{\n\tstruct dns_packet *packet = context->packet;\n\tstruct dns_head *head = &packet->head;\n\tint i = 0;\n\tint ret = 0;\n\tint count = 0;\n\n\tcount = head->qdcount;\n\thead->qdcount = 0;\n\tfor (i = 0; i < count; i++) {\n\t\tret = _dns_decode_qd(context);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"decode qd failed.\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tcount = head->ancount;\n\thead->ancount = 0;\n\tfor (i = 0; i < count; i++) {\n\t\tret = _dns_decode_an(context, DNS_RRS_AN);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"decode an failed.\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tcount = head->nscount;\n\thead->nscount = 0;\n\tfor (i = 0; i < count; i++) {\n\t\tret = _dns_decode_an(context, DNS_RRS_NS);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"decode ns failed.\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tcount = head->nrcount;\n\thead->nrcount = 0;\n\tfor (i = 0; i < count; i++) {\n\t\tret = _dns_decode_an(context, DNS_RRS_NR);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"decode nr failed.\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int _dns_encode_body(struct dns_context *context)\n{\n\tstruct dns_packet *packet = context->packet;\n\tstruct dns_head *head = &packet->head;\n\tint i = 0;\n\tint len = 0;\n\tstruct dns_rrs *rrs = NULL;\n\tint count = 0;\n\n\trrs = dns_get_rrs_start(packet, DNS_RRS_QD, &count);\n\thead->qdcount = count;\n\tfor (i = 0; i < count && rrs; i++, rrs = dns_get_rrs_next(packet, rrs)) {\n\t\tlen = _dns_encode_qd(context, rrs);\n\t\tif (len < 0) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\trrs = dns_get_rrs_start(packet, DNS_RRS_AN, &count);\n\thead->ancount = count;\n\tfor (i = 0; i < count && rrs; i++, rrs = dns_get_rrs_next(packet, rrs)) {\n\t\tlen = _dns_encode_an(context, rrs);\n\t\tif (len < 0) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\trrs = dns_get_rrs_start(packet, DNS_RRS_NS, &count);\n\thead->nscount = count;\n\tfor (i = 0; i < count && rrs; i++, rrs = dns_get_rrs_next(packet, rrs)) {\n\t\tlen = _dns_encode_an(context, rrs);\n\t\tif (len < 0) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\trrs = dns_get_rrs_start(packet, DNS_RRS_NR, &count);\n\thead->nrcount = count;\n\tfor (i = 0; i < count && rrs; i++, rrs = dns_get_rrs_next(packet, rrs)) {\n\t\tlen = _dns_encode_an(context, rrs);\n\t\tif (len < 0) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\trrs = dns_get_rrs_start(packet, DNS_RRS_OPT, &count);\n\tif (count > 0 || packet->payloadsize > 0) {\n\t\tlen = _dns_encode_opts(packet, context, rrs, count);\n\t\tif (len < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\thead->nrcount++;\n\t}\n\n\treturn 0;\n}\n\nint dns_packet_init(struct dns_packet *packet, int size, struct dns_head *head)\n{\n\tstruct dns_head *init_head = &packet->head;\n\tif (size < (int)sizeof(*packet)) {\n\t\treturn -1;\n\t}\n\n\tmemset(packet, 0, size);\n\tpacket->size = size;\n\tinit_head->id = head->id;\n\tinit_head->qr = head->qr;\n\tinit_head->opcode = head->opcode;\n\tinit_head->aa = head->aa;\n\tinit_head->tc = head->tc;\n\tinit_head->rd = head->rd;\n\tinit_head->ra = head->ra;\n\tinit_head->rcode = head->rcode;\n\tpacket->questions = DNS_RR_END;\n\tpacket->answers = DNS_RR_END;\n\tpacket->nameservers = DNS_RR_END;\n\tpacket->additional = DNS_RR_END;\n\tpacket->optional = DNS_RR_END;\n\tpacket->optcount = 0;\n\tpacket->payloadsize = 0;\n\n\treturn 0;\n}\n\nint dns_decode(struct dns_packet *packet, int maxsize, unsigned char *data, int size)\n{\n\tstruct dns_head *head = &packet->head;\n\tstruct dns_context context;\n\tint ret = 0;\n\n\tmemset(&context, 0, sizeof(context));\n\tmemset(packet, 0, sizeof(*packet));\n\n\tcontext.data = data;\n\tcontext.packet = packet;\n\tcontext.ptr = data;\n\tcontext.maxsize = size;\n\tcontext.namedict = &packet->namedict;\n\n\tret = dns_packet_init(packet, maxsize, head);\n\tif (ret != 0) {\n\t\treturn -1;\n\t}\n\n\tret = _dns_decode_head(&context);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tret = _dns_decode_body(&context);\n\tif (ret < 0) {\n\t\ttlog(TLOG_DEBUG, \"decode body failed.\\n\");\n\t\treturn -1;\n\t}\n\n\tpacket->size = context.ptr - context.data + sizeof(*packet);\n\n\treturn 0;\n}\n\nint dns_encode(unsigned char *data, int size, struct dns_packet *packet)\n{\n\tint ret = 0;\n\tstruct dns_context context;\n\tstruct dns_packet_dict namedict;\n\n\tmemset(&context, 0, sizeof(context));\n\tmemset(&namedict, 0, sizeof(namedict));\n\tcontext.data = data;\n\tcontext.packet = packet;\n\tcontext.ptr = data;\n\tcontext.maxsize = size;\n\tcontext.namedict = &namedict;\n\n\tret = _dns_encode_head(&context);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tret = _dns_encode_body(&context);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tret = _dns_encode_head_count(&context);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\treturn context.ptr - context.data;\n}\n\nstatic int _dns_update_an(struct dns_context *context, dns_rr_type type, struct dns_update_param *param)\n{\n\tint ret = 0;\n\tint qtype = 0;\n\tint qclass = 0;\n\tint ttl = 0;\n\tint rr_len = 0;\n\tchar domain[DNS_MAX_CNAME_LEN];\n\tunsigned char *start = NULL;\n\n\t/* decode rr head */\n\tret = _dns_decode_rr_head(context, domain, DNS_MAX_CNAME_LEN, &qtype, &qclass, &ttl, &rr_len);\n\tif (ret < 0) {\n\t\ttlog(TLOG_DEBUG, \"decode head failed.\");\n\t\treturn -1;\n\t}\n\n\tstart = context->ptr;\n\tswitch (qtype) {\n\tcase DNS_T_OPT:\n\t\tbreak;\n\tdefault: {\n\t\tunsigned char *ttl_ptr = start - sizeof(int) - sizeof(short);\n\t\tif (param->ip_ttl < 0) {\n\t\t\tbreak;\n\t\t}\n\t\t_dns_write_int(&ttl_ptr, param->ip_ttl);\n\t} break;\n\t}\n\tcontext->ptr += rr_len;\n\tif (context->ptr - start != rr_len) {\n\t\ttlog(TLOG_ERROR, \"length mismatch , %s, %ld:%d\", domain, (long)(context->ptr - start), rr_len);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int _dns_update_body(struct dns_context *context, struct dns_update_param *param)\n{\n\tstruct dns_packet *packet = context->packet;\n\tstruct dns_head *head = &packet->head;\n\tint i = 0;\n\tint ret = 0;\n\tint count = 0;\n\n\tcount = head->qdcount;\n\thead->qdcount = 0;\n\tfor (i = 0; i < count; i++) {\n\t\tchar domain[DNS_MAX_CNAME_LEN];\n\t\tint qtype = 0;\n\t\tint qclass = 0;\n\t\tint len = 0;\n\t\tlen = _dns_decode_qr_head(context, domain, DNS_MAX_CNAME_LEN, &qtype, &qclass);\n\t\tif (len < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"update qd failed.\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tcount = head->ancount;\n\thead->ancount = 0;\n\tfor (i = 0; i < count; i++) {\n\t\tret = _dns_update_an(context, DNS_RRS_AN, param);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"update an failed.\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tcount = head->nscount;\n\thead->nscount = 0;\n\tfor (i = 0; i < count; i++) {\n\t\tret = _dns_update_an(context, DNS_RRS_NS, param);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"update ns failed.\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tcount = head->nrcount;\n\thead->nrcount = 0;\n\tfor (i = 0; i < count; i++) {\n\t\tret = _dns_update_an(context, DNS_RRS_NR, param);\n\t\tif (ret < 0) {\n\t\t\ttlog(TLOG_DEBUG, \"update nr failed.\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int _dns_update_id(unsigned char *data, int size, struct dns_update_param *param)\n{\n\tunsigned char *ptr = data;\n\t_dns_write_short(&ptr, param->id);\n\treturn 0;\n}\n\nint dns_packet_update(unsigned char *data, int size, struct dns_update_param *param)\n{\n\tstruct dns_packet packet;\n\tint maxsize = sizeof(packet);\n\tstruct dns_head *head = &packet.head;\n\tstruct dns_context context;\n\tint ret = 0;\n\n\tmemset(&context, 0, sizeof(context));\n\tmemset(&packet, 0, sizeof(packet));\n\n\tcontext.data = data;\n\tcontext.packet = &packet;\n\tcontext.ptr = data;\n\tcontext.maxsize = size;\n\n\tret = dns_packet_init(&packet, maxsize, head);\n\tif (ret != 0) {\n\t\treturn -1;\n\t}\n\n\tret = _dns_decode_head(&context);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tret = _dns_update_id(data, size, param);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\n\tret = _dns_update_body(&context, param);\n\tif (ret < 0) {\n\t\ttlog(TLOG_DEBUG, \"decode body failed.\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n", "/*************************************************************************\n *\n * Copyright (C) 2018-2023 Ruilin Peng (Nick) <pymumu@gmail.com>.\n *\n * smartdns is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * smartdns is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _DNS_HEAD_H\n#define _DNS_HEAD_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /*__cplusplus */\n\n#define DNS_RR_A_LEN 4\n#define DNS_RR_AAAA_LEN 16\n#define DNS_MAX_CNAME_LEN 256\n#define DNS_MAX_OPT_LEN 256\n#define DNS_IN_PACKSIZE (512 * 8)\n#define DNS_PACKSIZE (512 * 12)\n#define DNS_DEFAULT_PACKET_SIZE 512\n#define DNS_MAX_ALPN_LEN 32\n#define DNS_MAX_ECH_LEN 256\n\n#define DNS_ADDR_FAMILY_IP 1\n#define DNS_ADDR_FAMILY_IPV6 2\n\n/*\nDNS parameters:\nhttps://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml\n*/\n\ntypedef enum dns_qr {\n\tDNS_QR_QUERY = 0,\n\tDNS_QR_ANSWER = 1,\n} dns_qr;\n\ntypedef enum dns_rr_type {\n\tDNS_RRS_QD = 0,\n\tDNS_RRS_AN = 1,\n\tDNS_RRS_NS = 2,\n\tDNS_RRS_NR = 3,\n\tDNS_RRS_OPT = 4,\n\tDNS_RRS_END,\n} dns_rr_type;\n\ntypedef enum dns_class {\n\tDNS_C_IN = 1, // DNS C IN\n\tDNS_C_ANY = 255\n} dns_class_t;\n\ntypedef enum dns_type {\n\tDNS_T_A = 1,\n\tDNS_T_NS = 2,\n\tDNS_T_CNAME = 5,\n\tDNS_T_SOA = 6,\n\tDNS_T_PTR = 12,\n\tDNS_T_MX = 15,\n\tDNS_T_TXT = 16,\n\tDNS_T_AAAA = 28,\n\tDNS_T_SRV = 33,\n\tDNS_T_OPT = 41,\n\tDNS_T_SSHFP = 44,\n\tDNS_T_HTTPS = 65,\n\tDNS_T_SPF = 99,\n\tDNS_T_AXFR = 252,\n\tDNS_T_ALL = 255\n} dns_type_t;\n\ntypedef enum dns_opt_code {\n\tDNS_OPT_T_ECS = 8,     // OPT ECS\n\tDNS_OPT_T_COOKIE = 10, // OPT Cookie\n\tDNS_OPT_T_TCP_KEEPALIVE = 11,\n\tDNS_OPT_T_PADDING = 12,\n\tDNS_OPT_T_ALL = 255\n} dns_opt_code_t;\n\n/* https://datatracker.ietf.org/doc/draft-ietf-dnsop-svcb-https/11/ */\ntypedef enum dns_https_svcparam {\n\tDNS_HTTPS_T_MANDATORY = 0,\n\tDNS_HTTPS_T_ALPN = 1,\n\tDNS_HTTPS_T_NO_DEFAULT_ALPN = 2,\n\tDNS_HTTPS_T_PORT = 3,\n\tDNS_HTTPS_T_IPV4HINT = 4,\n\tDNS_HTTPS_T_ECH = 5,\n\tDNS_HTTPS_T_IPV6HINT = 6,\n\tDNS_HTTPS_T_ALL = 255\n} dns_https_svcparam_t;\n\ntypedef enum dns_opcode {\n\tDNS_OP_QUERY = 0,\n\tDNS_OP_IQUERY = 1,\n\tDNS_OP_STATUS = 2,\n\tDNS_OP_NOTIFY = 4,\n\tDNS_OP_UPDATE = 5,\n} dns_opcode_t; /* dns_opcode */\n\ntypedef enum dns_rtcode {\n\tDNS_RC_NOERROR = 0,\n\tDNS_RC_FORMERR = 1,\n\tDNS_RC_SERVFAIL = 2,\n\tDNS_RC_NXDOMAIN = 3,\n\tDNS_RC_NOTIMP = 4,\n\tDNS_RC_REFUSED = 5,\n\tDNS_RC_YXDOMAIN = 6,\n\tDNS_RC_YXRRSET = 7,\n\tDNS_RC_NXRRSET = 8,\n\tDNS_RC_NOTAUTH = 9,\n\tDNS_RC_NOTZONE = 10,\n\t/* EDNS(0) extended RCODEs */\n\tDNS_RC_BADVERS = 16,\n} dns_rtcode_t; /* dns_rcode */\n\n/* dns packet head */\nstruct dns_head {\n\tunsigned short id;      /* identification number */\n\tunsigned short qr;      /* Query/Response Flag */\n\tunsigned short opcode;  /* Operation Code */\n\tunsigned char aa;       /* Authoritative Answer Flag */\n\tunsigned char tc;       /* Truncation Flag */\n\tunsigned char rd;       /* Recursion Desired */\n\tunsigned char ra;       /* Recursion Available */\n\tunsigned short rcode;   /* Response Code */\n\tunsigned short qdcount; /* number of question entries */\n\tunsigned short ancount; /* number of answer entries */\n\tunsigned short nscount; /* number of authority entries */\n\tunsigned short nrcount; /* number of additional resource entries */\n} __attribute__((packed, aligned(2)));\n\n#define DNS_PACKET_DICT_SIZE 16\nstruct dns_packet_dict_item {\n\tunsigned short pos;\n\tunsigned int hash;\n};\n\nstruct dns_packet_dict {\n\tshort dict_count;\n\tstruct dns_packet_dict_item names[DNS_PACKET_DICT_SIZE];\n};\n\n/* packet head */\nstruct dns_packet {\n\tstruct dns_head head;\n\tunsigned short questions;\n\tunsigned short answers;\n\tunsigned short nameservers;\n\tunsigned short additional;\n\tunsigned short optcount;\n\tunsigned short optional;\n\tunsigned short payloadsize;\n\tstruct dns_packet_dict namedict;\n\tint size;\n\tint len;\n\tunsigned char data[0];\n};\n\nstruct dns_rrs {\n\tstruct dns_packet *packet;\n\tunsigned short next;\n\tunsigned short len;\n\tint type;\n\tunsigned char data[0];\n};\n\n/* packet encode/decode context */\nstruct dns_context {\n\tstruct dns_packet *packet;\n\tstruct dns_packet_dict *namedict;\n\tunsigned char *data;\n\tint maxsize;\n\tunsigned char *ptr;\n};\n\n/* SOA data */\nstruct dns_soa {\n\tchar mname[DNS_MAX_CNAME_LEN];\n\tchar rname[DNS_MAX_CNAME_LEN];\n\tunsigned int serial;\n\tunsigned int refresh;\n\tunsigned int retry;\n\tunsigned int expire;\n\tunsigned int minimum;\n} __attribute__((packed));\n\n#define DNS_OPT_ECS_FAMILY_IPV4 1\n#define DNS_OPT_ECS_FAMILY_IPV6 2\n\n/* OPT ECS */\nstruct dns_opt_ecs {\n\tunsigned short family;\n\tunsigned char source_prefix;\n\tunsigned char scope_prefix;\n\tunsigned char addr[DNS_RR_AAAA_LEN];\n} __attribute__((packed));\n\n/* OPT COOKIE */\nstruct dns_opt_cookie {\n\tchar server_cookie_len;\n\tunsigned char client_cookie[8];\n\tunsigned char server_cookie[32];\n};\n\n/* OPT */\nstruct dns_opt {\n\tunsigned short code;\n\tunsigned short length;\n\tunsigned char data[0];\n} __attribute__((packed));\n\nstruct dns_rr_nested {\n\tstruct dns_context context;\n\tunsigned char *rr_start;\n\tunsigned char *rr_len_ptr;\n\tunsigned short rr_head_len;\n\tdns_rr_type type;\n};\n\nstruct dns_https_param {\n\tunsigned short key;\n\tunsigned short len;\n\tunsigned char value[0];\n};\n\nstruct dns_rrs *dns_get_rrs_next(struct dns_packet *packet, struct dns_rrs *rrs);\nstruct dns_rrs *dns_get_rrs_start(struct dns_packet *packet, dns_rr_type type, int *count);\n\nstruct dns_rr_nested *dns_add_rr_nested_start(struct dns_rr_nested *rr_nested_buffer, struct dns_packet *packet,\n\t\t\t\t\t\t\t\t\t\t\t  dns_rr_type type, dns_type_t rtype, const char *domain, int ttl);\nint dns_add_rr_nested_end(struct dns_rr_nested *rr_nested, dns_type_t rtype);\nint dns_add_rr_nested_memcpy(struct dns_rr_nested *rr_nested, const void *data, int data_len);\n\nvoid *dns_get_rr_nested_start(struct dns_rrs *rrs, char *domain, int maxsize, int *qtype, int *ttl, int *rr_len);\nvoid *dns_get_rr_nested_next(struct dns_rrs *rrs, void *rr_nested, int rr_nested_len);\n\n/*\n * Question\n */\nint dns_add_domain(struct dns_packet *packet, const char *domain, int qtype, int qclass);\nint dns_get_domain(struct dns_rrs *rrs, char *domain, int maxsize, int *qtype, int *qclass);\n\n/*\n * Answers\n */\nint dns_add_CNAME(struct dns_packet *packet, dns_rr_type type, const char *domain, int ttl, const char *cname);\nint dns_get_CNAME(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl, char *cname, int cname_size);\n\nint dns_add_A(struct dns_packet *packet, dns_rr_type type, const char *domain, int ttl,\n\t\t\t  unsigned char addr[DNS_RR_A_LEN]);\nint dns_get_A(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl, unsigned char addr[DNS_RR_A_LEN]);\n\nint dns_add_PTR(struct dns_packet *packet, dns_rr_type type, const char *domain, int ttl, const char *cname);\nint dns_get_PTR(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl, char *cname, int cname_size);\n\nint dns_add_AAAA(struct dns_packet *packet, dns_rr_type type, const char *domain, int ttl,\n\t\t\t\t unsigned char addr[DNS_RR_AAAA_LEN]);\nint dns_get_AAAA(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl, unsigned char addr[DNS_RR_AAAA_LEN]);\n\nint dns_add_SOA(struct dns_packet *packet, dns_rr_type type, const char *domain, int ttl, struct dns_soa *soa);\nint dns_get_SOA(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl, struct dns_soa *soa);\n\nint dns_add_NS(struct dns_packet *packet, dns_rr_type type, const char *domain, int ttl, const char *cname);\nint dns_get_NS(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl, char *cname, int cname_size);\n\nint dns_set_OPT_payload_size(struct dns_packet *packet, int payload_size);\nint dns_get_OPT_payload_size(struct dns_packet *packet);\n\nint dns_add_OPT_ECS(struct dns_packet *packet, struct dns_opt_ecs *ecs);\nint dns_get_OPT_ECS(struct dns_rrs *rrs, unsigned short *opt_code, unsigned short *opt_len, struct dns_opt_ecs *ecs);\n\nint dns_add_OPT_TCP_KEEPALIVE(struct dns_packet *packet, unsigned short timeout);\nint dns_get_OPT_TCP_KEEPALIVE(struct dns_rrs *rrs, unsigned short *opt_code, unsigned short *opt_len,\n\t\t\t\t\t\t\t  unsigned short *timeout);\n\n/* the key must be added in orders, or dig will report FORMERR */\nint dns_add_HTTPS_start(struct dns_rr_nested *svcparam_buffer, struct dns_packet *packet, dns_rr_type type,\n\t\t\t\t\t\tconst char *domain, int ttl, int priority, const char *target);\nint dns_HTTPS_add_raw(struct dns_rr_nested *svcparam, unsigned short key, unsigned char *value, unsigned short len);\n/* key 1, alph */\nint dns_HTTPS_add_alpn(struct dns_rr_nested *svcparam, const char *alpn, int alpn_len);\n/* key 2, no default alph */\nint dns_HTTPS_add_no_default_alpn(struct dns_rr_nested *svcparam);\n/* key 3, port */\nint dns_HTTPS_add_port(struct dns_rr_nested *svcparam, unsigned short port);\n/* key 4, ipv4 */\nint dns_HTTPS_add_ipv4hint(struct dns_rr_nested *svcparam, unsigned char *addr[], int addr_num);\n/* key 5, ech */\nint dns_HTTPS_add_ech(struct dns_rr_nested *svcparam, void *ech, int ech_len);\n/* key 6, ipv6*/\nint dns_HTTPS_add_ipv6hint(struct dns_rr_nested *svcparam, unsigned char *addr[], int addr_num);\nint dns_add_HTTPS_end(struct dns_rr_nested *svcparam);\n\nint dns_get_HTTPS_svcparm_start(struct dns_rrs *rrs, struct dns_https_param **https_param, char *domain, int maxsize,\n\t\t\t\t\t\t\t\tint *ttl, int *priority, char *target, int target_size);\nstruct dns_https_param *dns_get_HTTPS_svcparm_next(struct dns_rrs *rrs, struct dns_https_param *parm);\n\n/*\n * Packet operation\n */\nint dns_decode(struct dns_packet *packet, int maxsize, unsigned char *data, int size);\nint dns_encode(unsigned char *data, int size, struct dns_packet *packet);\n\nint dns_packet_init(struct dns_packet *packet, int size, struct dns_head *head);\n\nstruct dns_update_param {\n\tint id;\n\tint ip_ttl;\n\tint cname_ttl;\n};\n\nint dns_packet_update(unsigned char *data, int size, struct dns_update_param *param);\n\n#ifdef __cplusplus\n}\n#endif /*__cplusplus */\n#endif\n", "/*************************************************************************\n *\n * Copyright (C) 2018-2023 Ruilin Peng (Nick) <pymumu@gmail.com>.\n *\n * smartdns is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * smartdns is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#include <stdio.h>\n#endif\n#include \"dns_conf.h\"\n#include \"tlog.h\"\n#include \"util.h\"\n#include <arpa/inet.h>\n#include <ctype.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <libgen.h>\n#include <linux/capability.h>\n#include <linux/limits.h>\n#include <linux/netlink.h>\n#include <linux/rtnetlink.h>\n#include <netinet/tcp.h>\n#include <openssl/crypto.h>\n#include <openssl/ssl.h>\n#include <openssl/x509v3.h>\n#include <pthread.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <sys/sysinfo.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <time.h>\n#include <unistd.h>\n#include <unwind.h>\n\n#define TMP_BUFF_LEN_32 32\n\n#define NFNL_SUBSYS_IPSET 6\n\n#define IPSET_ATTR_DATA 7\n#define IPSET_ATTR_IP 1\n#define IPSET_ATTR_IPADDR_IPV4 1\n#define IPSET_ATTR_IPADDR_IPV6 2\n#define IPSET_ATTR_PROTOCOL 1\n#define IPSET_ATTR_SETNAME 2\n#define IPSET_ATTR_TIMEOUT 6\n#define IPSET_ADD 9\n#define IPSET_DEL 10\n#define IPSET_MAXNAMELEN 32\n#define IPSET_PROTOCOL 6\n\n#define IPV6_ADDR_LEN 16\n#define IPV4_ADDR_LEN 4\n\n#ifndef NFNETLINK_V0\n#define NFNETLINK_V0 0\n#endif\n\n#ifndef NLA_F_NESTED\n#define NLA_F_NESTED (1 << 15)\n#endif\n\n#ifndef NLA_F_NET_BYTEORDER\n#define NLA_F_NET_BYTEORDER (1 << 14)\n#endif\n\n#define NETLINK_ALIGN(len) (((len) + 3) & ~(3))\n\n#define BUFF_SZ 1024\n#define PACKET_BUF_SIZE 8192\n#define PACKET_MAGIC 0X11040918\n\nstruct ipset_netlink_attr {\n\tunsigned short len;\n\tunsigned short type;\n};\n\nstruct ipset_netlink_msg {\n\tunsigned char family;\n\tunsigned char version;\n\t__be16 res_id;\n};\n\nstatic int ipset_fd;\nstatic int pidfile_fd;\n\nunsigned long get_tick_count(void)\n{\n\tstruct timespec ts;\n\n\tclock_gettime(CLOCK_MONOTONIC, &ts);\n\n\treturn (ts.tv_sec * 1000 + ts.tv_nsec / 1000000);\n}\n\nchar *dir_name(char *path)\n{\n\tif (strstr(path, \"/\") == NULL) {\n\t\tsafe_strncpy(path, \"./\", PATH_MAX);\n\t\treturn path;\n\t}\n\n\treturn dirname(path);\n}\n\nchar *get_host_by_addr(char *host, int maxsize, struct sockaddr *addr)\n{\n\tstruct sockaddr_storage *addr_store = (struct sockaddr_storage *)addr;\n\thost[0] = 0;\n\tswitch (addr_store->ss_family) {\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *addr_in = NULL;\n\t\taddr_in = (struct sockaddr_in *)addr;\n\t\tinet_ntop(AF_INET, &addr_in->sin_addr, host, maxsize);\n\t} break;\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *addr_in6 = NULL;\n\t\taddr_in6 = (struct sockaddr_in6 *)addr;\n\t\tif (IN6_IS_ADDR_V4MAPPED(&addr_in6->sin6_addr)) {\n\t\t\tstruct sockaddr_in addr_in4;\n\t\t\tmemset(&addr_in4, 0, sizeof(addr_in4));\n\t\t\tmemcpy(&addr_in4.sin_addr.s_addr, addr_in6->sin6_addr.s6_addr + 12, sizeof(addr_in4.sin_addr.s_addr));\n\t\t\tinet_ntop(AF_INET, &addr_in4.sin_addr, host, maxsize);\n\t\t} else {\n\t\t\tinet_ntop(AF_INET6, &addr_in6->sin6_addr, host, maxsize);\n\t\t}\n\t} break;\n\tdefault:\n\t\tgoto errout;\n\t\tbreak;\n\t}\n\treturn host;\nerrout:\n\treturn NULL;\n}\n\nint getaddr_by_host(const char *host, struct sockaddr *addr, socklen_t *addr_len)\n{\n\tstruct addrinfo hints;\n\tstruct addrinfo *result = NULL;\n\tint ret = 0;\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = AF_UNSPEC;\n\thints.ai_socktype = SOCK_STREAM;\n\n\tret = getaddrinfo(host, \"53\", &hints, &result);\n\tif (ret != 0) {\n\t\tgoto errout;\n\t}\n\n\tif (result->ai_addrlen > *addr_len) {\n\t\tresult->ai_addrlen = *addr_len;\n\t}\n\n\taddr->sa_family = result->ai_family;\n\tmemcpy(addr, result->ai_addr, result->ai_addrlen);\n\t*addr_len = result->ai_addrlen;\n\n\tfreeaddrinfo(result);\n\n\treturn 0;\nerrout:\n\tif (result) {\n\t\tfreeaddrinfo(result);\n\t}\n\treturn -1;\n}\n\nint getsocket_inet(int fd, struct sockaddr *addr, socklen_t *addr_len)\n{\n\tstruct sockaddr_storage addr_store;\n\tsocklen_t addr_store_len = sizeof(addr_store);\n\tif (getsockname(fd, (struct sockaddr *)&addr_store, &addr_store_len) != 0) {\n\t\tgoto errout;\n\t}\n\n\tswitch (addr_store.ss_family) {\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *addr_in = NULL;\n\t\taddr_in = (struct sockaddr_in *)addr;\n\t\taddr_in->sin_family = AF_INET;\n\t\t*addr_len = sizeof(struct sockaddr_in);\n\t\tmemcpy(addr, addr_in, sizeof(struct sockaddr_in));\n\t} break;\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *addr_in6 = NULL;\n\t\taddr_in6 = (struct sockaddr_in6 *)addr;\n\t\tif (IN6_IS_ADDR_V4MAPPED(&addr_in6->sin6_addr)) {\n\t\t\tstruct sockaddr_in addr_in4;\n\t\t\tmemset(&addr_in4, 0, sizeof(addr_in4));\n\t\t\tmemcpy(&addr_in4.sin_addr.s_addr, addr_in6->sin6_addr.s6_addr + 12, sizeof(addr_in4.sin_addr.s_addr));\n\t\t\taddr_in4.sin_family = AF_INET;\n\t\t\taddr_in4.sin_port = 0;\n\t\t\t*addr_len = sizeof(struct sockaddr_in);\n\t\t\tmemcpy(addr, &addr_in4, sizeof(struct sockaddr_in));\n\t\t} else {\n\t\t\taddr_in6->sin6_family = AF_INET6;\n\t\t\t*addr_len = sizeof(struct sockaddr_in6);\n\t\t\tmemcpy(addr, addr_in6, sizeof(struct sockaddr_in6));\n\t\t}\n\t} break;\n\tdefault:\n\t\tgoto errout;\n\t\tbreak;\n\t}\n\treturn 0;\nerrout:\n\treturn -1;\n}\n\nint fill_sockaddr_by_ip(unsigned char *ip, int ip_len, int port, struct sockaddr *addr, socklen_t *addr_len)\n{\n\tif (ip == NULL || addr == NULL || addr_len == NULL) {\n\t\treturn -1;\n\t}\n\n\tif (ip_len == IPV4_ADDR_LEN) {\n\t\tstruct sockaddr_in *addr_in = NULL;\n\t\taddr->sa_family = AF_INET;\n\t\taddr_in = (struct sockaddr_in *)addr;\n\t\taddr_in->sin_port = htons(port);\n\t\taddr_in->sin_family = AF_INET;\n\t\tmemcpy(&addr_in->sin_addr.s_addr, ip, ip_len);\n\t\t*addr_len = 16;\n\t} else if (ip_len == IPV6_ADDR_LEN) {\n\t\tstruct sockaddr_in6 *addr_in6 = NULL;\n\t\taddr->sa_family = AF_INET6;\n\t\taddr_in6 = (struct sockaddr_in6 *)addr;\n\t\taddr_in6->sin6_port = htons(port);\n\t\taddr_in6->sin6_family = AF_INET6;\n\t\tmemcpy(addr_in6->sin6_addr.s6_addr, ip, ip_len);\n\t\t*addr_len = 28;\n\t}\n\n\treturn -1;\n}\n\nint parse_ip(const char *value, char *ip, int *port)\n{\n\tint offset = 0;\n\tchar *colon = NULL;\n\n\tcolon = strstr(value, \":\");\n\n\tif (strstr(value, \"[\")) {\n\t\t/* ipv6 with port */\n\t\tchar *bracket_end = strstr(value, \"]\");\n\t\tif (bracket_end == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\toffset = bracket_end - value - 1;\n\t\tmemcpy(ip, value + 1, offset);\n\t\tip[offset] = 0;\n\n\t\tcolon = strstr(bracket_end, \":\");\n\t\tif (colon) {\n\t\t\tcolon++;\n\t\t}\n\t} else if (colon && strstr(colon + 1, \":\")) {\n\t\t/* ipv6 without port */\n\t\tstrncpy(ip, value, MAX_IP_LEN);\n\t\tcolon = NULL;\n\t} else {\n\t\t/* ipv4 */\n\t\tcolon = strstr(value, \":\");\n\t\tif (colon == NULL) {\n\t\t\t/* without port */\n\t\t\tstrncpy(ip, value, MAX_IP_LEN);\n\t\t} else {\n\t\t\t/* with port */\n\t\t\toffset = colon - value;\n\t\t\tcolon++;\n\t\t\tmemcpy(ip, value, offset);\n\t\t\tip[offset] = 0;\n\t\t}\n\t}\n\n\tif (colon) {\n\t\t/* get port num */\n\t\t*port = atoi(colon);\n\t} else {\n\t\t*port = PORT_NOT_DEFINED;\n\t}\n\n\tif (ip[0] == 0) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint check_is_ipv4(const char *ip)\n{\n\tconst char *ptr = ip;\n\tchar c = 0;\n\tint dot_num = 0;\n\tint dig_num = 0;\n\n\twhile ((c = *ptr++) != '\\0') {\n\t\tif (c == '.') {\n\t\t\tdot_num++;\n\t\t\tdig_num = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* check number count of one field */\n\t\tif (dig_num >= 4) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (c >= '0' && c <= '9') {\n\t\t\tdig_num++;\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\t/* check field number */\n\tif (dot_num != 3) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint check_is_ipv6(const char *ip)\n{\n\tconst char *ptr = ip;\n\tchar c = 0;\n\tint colon_num = 0;\n\tint dig_num = 0;\n\n\twhile ((c = *ptr++) != '\\0') {\n\t\tif (c == '[' || c == ']') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (c == ':') {\n\t\t\tcolon_num++;\n\t\t\tdig_num = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* check number count of one field */\n\t\tif (dig_num >= 5) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tdig_num++;\n\t\tif (c >= '0' && c <= '9') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (c >= 'a' && c <= 'f') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (c >= 'A' && c <= 'F') {\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\t/* check field number */\n\tif (colon_num > 7) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\nint check_is_ipaddr(const char *ip)\n{\n\tif (strstr(ip, \".\")) {\n\t\t/* IPV4 */\n\t\treturn check_is_ipv4(ip);\n\t} else if (strstr(ip, \":\")) {\n\t\t/* IPV6 */\n\t\treturn check_is_ipv6(ip);\n\t}\n\treturn -1;\n}\n\nint parse_uri(const char *value, char *scheme, char *host, int *port, char *path)\n{\n\treturn parse_uri_ext(value, scheme, NULL, NULL, host, port, path);\n}\n\nvoid urldecode(char *dst, const char *src)\n{\n\tchar a, b;\n\twhile (*src) {\n\t\tif ((*src == '%') && ((a = src[1]) && (b = src[2])) && (isxdigit(a) && isxdigit(b))) {\n\t\t\tif (a >= 'a') {\n\t\t\t\ta -= 'a' - 'A';\n\t\t\t}\n\n\t\t\tif (a >= 'A') {\n\t\t\t\ta -= ('A' - 10);\n\t\t\t} else {\n\t\t\t\ta -= '0';\n\t\t\t}\n\n\t\t\tif (b >= 'a') {\n\t\t\t\tb -= 'a' - 'A';\n\t\t\t}\n\n\t\t\tif (b >= 'A') {\n\t\t\t\tb -= ('A' - 10);\n\t\t\t} else {\n\t\t\t\tb -= '0';\n\t\t\t}\n\t\t\t*dst++ = 16 * a + b;\n\t\t\tsrc += 3;\n\t\t} else if (*src == '+') {\n\t\t\t*dst++ = ' ';\n\t\t\tsrc++;\n\t\t} else {\n\t\t\t*dst++ = *src++;\n\t\t}\n\t}\n\t*dst++ = '\\0';\n}\n\nint parse_uri_ext(const char *value, char *scheme, char *user, char *password, char *host, int *port, char *path)\n{\n\tchar *scheme_end = NULL;\n\tint field_len = 0;\n\tconst char *process_ptr = value;\n\tchar user_pass_host_part[PATH_MAX];\n\tchar *user_password = NULL;\n\tchar *host_part = NULL;\n\n\tconst char *host_end = NULL;\n\n\tscheme_end = strstr(value, \"://\");\n\tif (scheme_end) {\n\t\tfield_len = scheme_end - value;\n\t\tif (scheme) {\n\t\t\tmemcpy(scheme, value, field_len);\n\t\t\tscheme[field_len] = 0;\n\t\t}\n\t\tprocess_ptr += field_len + 3;\n\t} else {\n\t\tif (scheme) {\n\t\t\tscheme[0] = '\\0';\n\t\t}\n\t}\n\n\thost_end = strstr(process_ptr, \"/\");\n\tif (host_end == NULL) {\n\t\thost_end = process_ptr + strlen(process_ptr);\n\t};\n\n\tfield_len = host_end - process_ptr;\n\tif (field_len >= (int)sizeof(user_pass_host_part)) {\n\t\treturn -1;\n\t}\n\tmemcpy(user_pass_host_part, process_ptr, field_len);\n\tuser_pass_host_part[field_len] = 0;\n\n\thost_part = strstr(user_pass_host_part, \"@\");\n\tif (host_part != NULL) {\n\t\t*host_part = '\\0';\n\t\thost_part = host_part + 1;\n\t\tuser_password = user_pass_host_part;\n\t\tchar *sep = strstr(user_password, \":\");\n\t\tif (sep != NULL) {\n\t\t\t*sep = '\\0';\n\t\t\tsep = sep + 1;\n\t\t\tif (password) {\n\t\t\t\turldecode(password, sep);\n\t\t\t}\n\t\t}\n\t\tif (user) {\n\t\t\turldecode(user, user_password);\n\t\t}\n\t} else {\n\t\thost_part = user_pass_host_part;\n\t}\n\n\tif (host != NULL && parse_ip(host_part, host, port) != 0) {\n\t\treturn -1;\n\t}\n\n\tprocess_ptr += field_len;\n\n\tif (path) {\n\t\tstrcpy(path, process_ptr);\n\t}\n\treturn 0;\n}\n\nint set_fd_nonblock(int fd, int nonblock)\n{\n\tint ret = 0;\n\tint flags = fcntl(fd, F_GETFL);\n\n\tif (flags == -1) {\n\t\treturn -1;\n\t}\n\n\tflags = (nonblock) ? (flags | O_NONBLOCK) : (flags & ~O_NONBLOCK);\n\tret = fcntl(fd, F_SETFL, flags);\n\tif (ret == -1) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nchar *reverse_string(char *output, const char *input, int len, int to_lower_case)\n{\n\tchar *begin = output;\n\tif (len <= 0) {\n\t\t*output = 0;\n\t\treturn output;\n\t}\n\n\tlen--;\n\twhile (len >= 0) {\n\t\t*output = *(input + len);\n\t\tif (to_lower_case) {\n\t\t\tif (*output >= 'A' && *output <= 'Z') {\n\t\t\t\t/* To lower case */\n\t\t\t\t*output = *output + 32;\n\t\t\t}\n\t\t}\n\t\toutput++;\n\t\tlen--;\n\t}\n\n\t*output = 0;\n\n\treturn begin;\n}\n\nchar *to_lower_case(char *output, const char *input, int len)\n{\n\tchar *begin = output;\n\tint i = 0;\n\tif (len <= 0) {\n\t\t*output = 0;\n\t\treturn output;\n\t}\n\n\tlen--;\n\twhile (i < len && *(input + i) != '\\0') {\n\t\t*output = *(input + i);\n\t\tif (*output >= 'A' && *output <= 'Z') {\n\t\t\t/* To lower case */\n\t\t\t*output = *output + 32;\n\t\t}\n\t\toutput++;\n\t\ti++;\n\t}\n\n\t*output = 0;\n\n\treturn begin;\n}\n\nstatic inline void _ipset_add_attr(struct nlmsghdr *netlink_head, uint16_t type, size_t len, const void *data)\n{\n\tstruct ipset_netlink_attr *attr = (void *)netlink_head + NETLINK_ALIGN(netlink_head->nlmsg_len);\n\tuint16_t payload_len = NETLINK_ALIGN(sizeof(struct ipset_netlink_attr)) + len;\n\tattr->type = type;\n\tattr->len = payload_len;\n\tmemcpy((void *)attr + NETLINK_ALIGN(sizeof(struct ipset_netlink_attr)), data, len);\n\tnetlink_head->nlmsg_len += NETLINK_ALIGN(payload_len);\n}\n\nstatic int _ipset_socket_init(void)\n{\n\tif (ipset_fd > 0) {\n\t\treturn 0;\n\t}\n\n\tipset_fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_NETFILTER);\n\n\tif (ipset_fd < 0) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int _ipset_support_timeout(void)\n{\n\tif (dns_conf_ipset_timeout_enable) {\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\nstatic int _ipset_operate(const char *ipset_name, const unsigned char addr[], int addr_len, unsigned long timeout,\n\t\t\t\t\t\t  int operate)\n{\n\tstruct nlmsghdr *netlink_head = NULL;\n\tstruct ipset_netlink_msg *netlink_msg = NULL;\n\tstruct ipset_netlink_attr *nested[3];\n\tchar buffer[BUFF_SZ];\n\tuint8_t proto = 0;\n\tssize_t rc = 0;\n\tint af = 0;\n\tstatic const struct sockaddr_nl snl = {.nl_family = AF_NETLINK};\n\tuint32_t expire = 0;\n\n\tif (addr_len != IPV4_ADDR_LEN && addr_len != IPV6_ADDR_LEN) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif (addr_len == IPV4_ADDR_LEN) {\n\t\taf = AF_INET;\n\t} else if (addr_len == IPV6_ADDR_LEN) {\n\t\taf = AF_INET6;\n\t} else {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif (_ipset_socket_init() != 0) {\n\t\treturn -1;\n\t}\n\n\tif (strlen(ipset_name) >= IPSET_MAXNAMELEN) {\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\n\tmemset(buffer, 0, BUFF_SZ);\n\n\tnetlink_head = (struct nlmsghdr *)buffer;\n\tnetlink_head->nlmsg_len = NETLINK_ALIGN(sizeof(struct nlmsghdr));\n\tnetlink_head->nlmsg_type = operate | (NFNL_SUBSYS_IPSET << 8);\n\tnetlink_head->nlmsg_flags = NLM_F_REQUEST | NLM_F_REPLACE;\n\n\tnetlink_msg = (struct ipset_netlink_msg *)(buffer + netlink_head->nlmsg_len);\n\tnetlink_head->nlmsg_len += NETLINK_ALIGN(sizeof(struct ipset_netlink_msg));\n\tnetlink_msg->family = af;\n\tnetlink_msg->version = NFNETLINK_V0;\n\tnetlink_msg->res_id = htons(0);\n\n\tproto = IPSET_PROTOCOL;\n\t_ipset_add_attr(netlink_head, IPSET_ATTR_PROTOCOL, sizeof(proto), &proto);\n\t_ipset_add_attr(netlink_head, IPSET_ATTR_SETNAME, strlen(ipset_name) + 1, ipset_name);\n\n\tnested[0] = (struct ipset_netlink_attr *)(buffer + NETLINK_ALIGN(netlink_head->nlmsg_len));\n\tnetlink_head->nlmsg_len += NETLINK_ALIGN(sizeof(struct ipset_netlink_attr));\n\tnested[0]->type = NLA_F_NESTED | IPSET_ATTR_DATA;\n\tnested[1] = (struct ipset_netlink_attr *)(buffer + NETLINK_ALIGN(netlink_head->nlmsg_len));\n\tnetlink_head->nlmsg_len += NETLINK_ALIGN(sizeof(struct ipset_netlink_attr));\n\tnested[1]->type = NLA_F_NESTED | IPSET_ATTR_IP;\n\n\t_ipset_add_attr(netlink_head,\n\t\t\t\t\t(af == AF_INET ? IPSET_ATTR_IPADDR_IPV4 : IPSET_ATTR_IPADDR_IPV6) | NLA_F_NET_BYTEORDER, addr_len,\n\t\t\t\t\taddr);\n\tnested[1]->len = (void *)buffer + NETLINK_ALIGN(netlink_head->nlmsg_len) - (void *)nested[1];\n\n\tif (timeout > 0 && _ipset_support_timeout() == 0) {\n\t\texpire = htonl(timeout);\n\t\t_ipset_add_attr(netlink_head, IPSET_ATTR_TIMEOUT | NLA_F_NET_BYTEORDER, sizeof(expire), &expire);\n\t}\n\n\tnested[0]->len = (void *)buffer + NETLINK_ALIGN(netlink_head->nlmsg_len) - (void *)nested[0];\n\n\tfor (;;) {\n\t\trc = sendto(ipset_fd, buffer, netlink_head->nlmsg_len, 0, (const struct sockaddr *)&snl, sizeof(snl));\n\t\tif (rc >= 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR) {\n\t\t\tstruct timespec waiter;\n\t\t\twaiter.tv_sec = 0;\n\t\t\twaiter.tv_nsec = 10000;\n\t\t\tnanosleep(&waiter, NULL);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nint ipset_add(const char *ipset_name, const unsigned char addr[], int addr_len, unsigned long timeout)\n{\n\treturn _ipset_operate(ipset_name, addr, addr_len, timeout, IPSET_ADD);\n}\n\nint ipset_del(const char *ipset_name, const unsigned char addr[], int addr_len)\n{\n\treturn _ipset_operate(ipset_name, addr, addr_len, 0, IPSET_DEL);\n}\n\nunsigned char *SSL_SHA256(const unsigned char *d, size_t n, unsigned char *md)\n{\n\tstatic unsigned char m[SHA256_DIGEST_LENGTH];\n\n\tif (md == NULL) {\n\t\tmd = m;\n\t}\n\n\tEVP_MD_CTX *ctx = EVP_MD_CTX_create();\n\tif (ctx == NULL) {\n\t\treturn NULL;\n\t}\n\n\tEVP_MD_CTX_init(ctx);\n\tEVP_DigestInit_ex(ctx, EVP_sha256(), NULL);\n\tEVP_DigestUpdate(ctx, d, n);\n\tEVP_DigestFinal_ex(ctx, m, NULL);\n\tEVP_MD_CTX_destroy(ctx);\n\n\treturn (md);\n}\n\nint SSL_base64_decode(const char *in, unsigned char *out)\n{\n\tsize_t inlen = strlen(in);\n\tint outlen = 0;\n\n\tif (inlen == 0) {\n\t\treturn 0;\n\t}\n\n\toutlen = EVP_DecodeBlock(out, (unsigned char *)in, inlen);\n\tif (outlen < 0) {\n\t\tgoto errout;\n\t}\n\n\t/* Subtract padding bytes from |outlen| */\n\twhile (in[--inlen] == '=') {\n\t\t--outlen;\n\t}\n\n\treturn outlen;\nerrout:\n\treturn -1;\n}\n\nint SSL_base64_encode(const void *in, int in_len, char *out)\n{\n\tint outlen = 0;\n\n\tif (in_len == 0) {\n\t\treturn 0;\n\t}\n\n\toutlen = EVP_EncodeBlock((unsigned char *)out, in, in_len);\n\tif (outlen < 0) {\n\t\tgoto errout;\n\t}\n\n\treturn outlen;\nerrout:\n\treturn -1;\n}\n\nint create_pid_file(const char *pid_file)\n{\n\tint fd = 0;\n\tint flags = 0;\n\tchar buff[TMP_BUFF_LEN_32];\n\n\t/*  create pid file, and lock this file */\n\tfd = open(pid_file, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);\n\tif (fd == -1) {\n\t\tfprintf(stderr, \"create pid file failed, %s\\n\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tflags = fcntl(fd, F_GETFD);\n\tif (flags < 0) {\n\t\tfprintf(stderr, \"Could not get flags for PID file %s\\n\", pid_file);\n\t\tgoto errout;\n\t}\n\n\tflags |= FD_CLOEXEC;\n\tif (fcntl(fd, F_SETFD, flags) == -1) {\n\t\tfprintf(stderr, \"Could not set flags for PID file %s\\n\", pid_file);\n\t\tgoto errout;\n\t}\n\n\tif (lockf(fd, F_TLOCK, 0) < 0) {\n\t\tfprintf(stderr, \"Server is already running.\\n\");\n\t\tgoto errout;\n\t}\n\n\tsnprintf(buff, TMP_BUFF_LEN_32, \"%d\\n\", getpid());\n\n\tif (write(fd, buff, strnlen(buff, TMP_BUFF_LEN_32)) < 0) {\n\t\tfprintf(stderr, \"write pid to file failed, %s.\\n\", strerror(errno));\n\t\tgoto errout;\n\t}\n\n\tif (pidfile_fd > 0) {\n\t\tclose(pidfile_fd);\n\t}\n\n\tpidfile_fd = fd;\n\n\treturn 0;\nerrout:\n\tif (fd > 0) {\n\t\tclose(fd);\n\t}\n\treturn -1;\n}\n\nint generate_cert_key(const char *key_path, const char *cert_path, const char *san, int days)\n{\n\tint ret = -1;\n#if (OPENSSL_VERSION_NUMBER <= 0x30000000L)\n\tRSA *rsa = NULL;\n\tBIGNUM *bn = NULL;\n#endif\n\tX509_EXTENSION *cert_ext = NULL;\n\tBIO *cert_file = NULL;\n\tBIO *key_file = NULL;\n\tX509 *cert = NULL;\n\tEVP_PKEY *pkey = NULL;\n\tconst int RSA_KEY_LENGTH = 2048;\n\n\tif (key_path == NULL || cert_path == NULL) {\n\t\treturn ret;\n\t}\n\n\tkey_file = BIO_new_file(key_path, \"wb\");\n\tcert_file = BIO_new_file(cert_path, \"wb\");\n\tcert = X509_new();\n#if (OPENSSL_VERSION_NUMBER >= 0x30000000L)\n\tpkey = EVP_RSA_gen(RSA_KEY_LENGTH);\n#else\n\tbn = BN_new();\n\trsa = RSA_new();\n\tpkey = EVP_PKEY_new();\n\tif (rsa == NULL || pkey == NULL || bn == NULL) {\n\t\tgoto out;\n\t}\n\n\tEVP_PKEY_assign(pkey, EVP_PKEY_RSA, rsa);\n\tBN_set_word(bn, RSA_F4);\n\tif (RSA_generate_key_ex(rsa, RSA_KEY_LENGTH, bn, NULL) != 1) {\n\t\tgoto out;\n\t}\n#endif\n\n\tif (key_file == NULL || cert_file == NULL || cert == NULL || pkey == NULL) {\n\t\tgoto out;\n\t}\n\n\tASN1_INTEGER_set(X509_get_serialNumber(cert), 1);           // serial number\n\tX509_gmtime_adj(X509_get_notBefore(cert), 0);               // now\n\tX509_gmtime_adj(X509_get_notAfter(cert), days * 24 * 3600); // accepts secs\n\n\tX509_set_pubkey(cert, pkey);\n\n\tX509_NAME *name = X509_get_subject_name(cert);\n\n\tconst unsigned char *country = (unsigned char *)\"smartdns\";\n\tconst unsigned char *company = (unsigned char *)\"smartdns\";\n\tconst unsigned char *common_name = (unsigned char *)\"smartdns\";\n\n\tX509_NAME_add_entry_by_txt(name, \"C\", MBSTRING_ASC, country, -1, -1, 0);\n\tX509_NAME_add_entry_by_txt(name, \"O\", MBSTRING_ASC, company, -1, -1, 0);\n\tX509_NAME_add_entry_by_txt(name, \"CN\", MBSTRING_ASC, common_name, -1, -1, 0);\n\n\tif (san != NULL) {\n\t\tcert_ext = X509V3_EXT_conf_nid(NULL, NULL, NID_subject_alt_name, san);\n\t\tif (cert_ext == NULL) {\n\t\t\tgoto out;\n\t\t}\n\t\tX509_add_ext(cert, cert_ext, -1);\n\t}\n\n\tX509_set_issuer_name(cert, name);\n\tX509_sign(cert, pkey, EVP_sha256());\n\n\tret = PEM_write_bio_PrivateKey(key_file, pkey, NULL, NULL, 0, NULL, NULL);\n\tif (ret != 1) {\n\t\tgoto out;\n\t}\n\n\tret = PEM_write_bio_X509(cert_file, cert);\n\tif (ret != 1) {\n\t\tgoto out;\n\t}\n\n\tchmod(key_path, S_IRUSR);\n\tchmod(cert_path, S_IRUSR);\n\n\tret = 0;\nout:\n\tif (cert_ext) {\n\t\tX509_EXTENSION_free(cert_ext);\n\t}\n\n\tif (pkey) {\n\t\tEVP_PKEY_free(pkey);\n\t}\n\n#if (OPENSSL_VERSION_NUMBER <= 0x30000000L)\n\tif (rsa && pkey == NULL) {\n\t\tRSA_free(rsa);\n\t}\n\n\tif (bn) {\n\t\tBN_free(bn);\n\t}\n#endif\n\n\tif (cert_file) {\n\t\tBIO_free_all(cert_file);\n\t}\n\n\tif (key_file) {\n\t\tBIO_free_all(key_file);\n\t}\n\n\tif (cert) {\n\t\tX509_free(cert);\n\t}\n\n\treturn ret;\n}\n\n#if OPENSSL_API_COMPAT < 0x10100000\n#define THREAD_STACK_SIZE (16 * 1024)\nstatic pthread_mutex_t *lock_cs;\nstatic long *lock_count;\n\nstatic __attribute__((unused)) void _pthreads_locking_callback(int mode, int type, const char *file, int line)\n{\n\tif (mode & CRYPTO_LOCK) {\n\t\tpthread_mutex_lock(&(lock_cs[type]));\n\t\tlock_count[type]++;\n\t} else {\n\t\tpthread_mutex_unlock(&(lock_cs[type]));\n\t}\n}\n\nstatic __attribute__((unused)) unsigned long _pthreads_thread_id(void)\n{\n\tunsigned long ret = 0;\n\n\tret = (unsigned long)pthread_self();\n\treturn (ret);\n}\n\nvoid SSL_CRYPTO_thread_setup(void)\n{\n\tint i = 0;\n\n\tlock_cs = OPENSSL_malloc(CRYPTO_num_locks() * sizeof(pthread_mutex_t));\n\tlock_count = OPENSSL_malloc(CRYPTO_num_locks() * sizeof(long));\n\tif (!lock_cs || !lock_count) {\n\t\t/* Nothing we can do about this...void function! */\n\t\tif (lock_cs) {\n\t\t\tOPENSSL_free(lock_cs);\n\t\t}\n\t\tif (lock_count) {\n\t\t\tOPENSSL_free(lock_count);\n\t\t}\n\t\treturn;\n\t}\n\tfor (i = 0; i < CRYPTO_num_locks(); i++) {\n\t\tlock_count[i] = 0;\n\t\tpthread_mutex_init(&(lock_cs[i]), NULL);\n\t}\n\n#if OPENSSL_API_COMPAT < 0x10000000\n\tCRYPTO_set_id_callback(_pthreads_thread_id);\n#else\n\tCRYPTO_THREADID_set_callback(_pthreads_thread_id);\n#endif\n\tCRYPTO_set_locking_callback(_pthreads_locking_callback);\n}\n\nvoid SSL_CRYPTO_thread_cleanup(void)\n{\n\tint i = 0;\n\n\tCRYPTO_set_locking_callback(NULL);\n\tfor (i = 0; i < CRYPTO_num_locks(); i++) {\n\t\tpthread_mutex_destroy(&(lock_cs[i]));\n\t}\n\tOPENSSL_free(lock_cs);\n\tOPENSSL_free(lock_count);\n}\n#endif\n\n#define SERVER_NAME_LEN 256\n#define TLS_HEADER_LEN 5\n#define TLS_HANDSHAKE_CONTENT_TYPE 0x16\n#define TLS_HANDSHAKE_TYPE_CLIENT_HELLO 0x01\n#ifndef MIN\n#define MIN(X, Y) ((X) < (Y) ? (X) : (Y))\n#endif\n\nstatic int parse_extensions(const char *, size_t, char *, const char **);\nstatic int parse_server_name_extension(const char *, size_t, char *, const char **);\n\n/* Parse a TLS packet for the Server Name Indication extension in the client\n * hello handshake, returning the first server name found (pointer to static\n * array)\n *\n * Returns:\n *  >=0  - length of the hostname and updates *hostname\n *         caller is responsible for freeing *hostname\n *  -1   - Incomplete request\n *  -2   - No Host header included in this request\n *  -3   - Invalid hostname pointer\n *  -4   - malloc failure\n *  < -4 - Invalid TLS client hello\n */\nint parse_tls_header(const char *data, size_t data_len, char *hostname, const char **hostname_ptr)\n{\n\tchar tls_content_type = 0;\n\tchar tls_version_major = 0;\n\tchar tls_version_minor = 0;\n\tsize_t pos = TLS_HEADER_LEN;\n\tsize_t len = 0;\n\n\tif (hostname == NULL) {\n\t\treturn -3;\n\t}\n\n\t/* Check that our TCP payload is at least large enough for a TLS header */\n\tif (data_len < TLS_HEADER_LEN) {\n\t\treturn -1;\n\t}\n\n\t/* SSL 2.0 compatible Client Hello\n\t *\n\t * High bit of first byte (length) and content type is Client Hello\n\t *\n\t * See RFC5246 Appendix E.2\n\t */\n\tif (data[0] & 0x80 && data[2] == 1) {\n\t\treturn -2;\n\t}\n\n\ttls_content_type = data[0];\n\tif (tls_content_type != TLS_HANDSHAKE_CONTENT_TYPE) {\n\t\treturn -5;\n\t}\n\n\ttls_version_major = data[1];\n\ttls_version_minor = data[2];\n\tif (tls_version_major < 3) {\n\t\treturn -2;\n\t}\n\n\t/* TLS record length */\n\tlen = ((unsigned char)data[3] << 8) + (unsigned char)data[4] + TLS_HEADER_LEN;\n\tdata_len = MIN(data_len, len);\n\n\t/* Check we received entire TLS record length */\n\tif (data_len < len) {\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Handshake\n\t */\n\tif (pos + 1 > data_len) {\n\t\treturn -5;\n\t}\n\tif (data[pos] != TLS_HANDSHAKE_TYPE_CLIENT_HELLO) {\n\t\treturn -5;\n\t}\n\n\t/* Skip past fixed length records:\n\t * 1\tHandshake Type\n\t * 3\tLength\n\t * 2\tVersion (again)\n\t * 32\tRandom\n\t * to\tSession ID Length\n\t */\n\tpos += 38;\n\n\t/* Session ID */\n\tif (pos + 1 > data_len) {\n\t\treturn -5;\n\t}\n\tlen = (unsigned char)data[pos];\n\tpos += 1 + len;\n\n\t/* Cipher Suites */\n\tif (pos + 2 > data_len) {\n\t\treturn -5;\n\t}\n\tlen = ((unsigned char)data[pos] << 8) + (unsigned char)data[pos + 1];\n\tpos += 2 + len;\n\n\t/* Compression Methods */\n\tif (pos + 1 > data_len) {\n\t\treturn -5;\n\t}\n\tlen = (unsigned char)data[pos];\n\tpos += 1 + len;\n\n\tif (pos == data_len && tls_version_major == 3 && tls_version_minor == 0) {\n\t\treturn -2;\n\t}\n\n\t/* Extensions */\n\tif (pos + 2 > data_len) {\n\t\treturn -5;\n\t}\n\tlen = ((unsigned char)data[pos] << 8) + (unsigned char)data[pos + 1];\n\tpos += 2;\n\n\tif (pos + len > data_len) {\n\t\treturn -5;\n\t}\n\treturn parse_extensions(data + pos, len, hostname, hostname_ptr);\n}\n\nstatic int parse_extensions(const char *data, size_t data_len, char *hostname, const char **hostname_ptr)\n{\n\tsize_t pos = 0;\n\tsize_t len = 0;\n\n\t/* Parse each 4 bytes for the extension header */\n\twhile (pos + 4 <= data_len) {\n\t\t/* Extension Length */\n\t\tlen = ((unsigned char)data[pos + 2] << 8) + (unsigned char)data[pos + 3];\n\n\t\t/* Check if it's a server name extension */\n\t\tif (data[pos] == 0x00 && data[pos + 1] == 0x00) {\n\t\t\t/* There can be only one extension of each type, so we break\n\t\t\t * our state and move p to beginning of the extension here */\n\t\t\tif (pos + 4 + len > data_len) {\n\t\t\t\treturn -5;\n\t\t\t}\n\t\t\treturn parse_server_name_extension(data + pos + 4, len, hostname, hostname_ptr);\n\t\t}\n\t\tpos += 4 + len; /* Advance to the next extension header */\n\t}\n\t/* Check we ended where we expected to */\n\tif (pos != data_len) {\n\t\treturn -5;\n\t}\n\n\treturn -2;\n}\n\nstatic int parse_server_name_extension(const char *data, size_t data_len, char *hostname, const char **hostname_ptr)\n{\n\tsize_t pos = 2; /* skip server name list length */\n\tsize_t len = 0;\n\n\twhile (pos + 3 < data_len) {\n\t\tlen = ((unsigned char)data[pos + 1] << 8) + (unsigned char)data[pos + 2];\n\n\t\tif (pos + 3 + len > data_len) {\n\t\t\treturn -5;\n\t\t}\n\n\t\tswitch (data[pos]) { /* name type */\n\t\tcase 0x00:           /* host_name */\n\t\t\tstrncpy(hostname, data + pos + 3, len);\n\t\t\tif (hostname_ptr) {\n\t\t\t\t*hostname_ptr = data + pos + 3;\n\t\t\t}\n\t\t\thostname[len] = '\\0';\n\n\t\t\treturn len;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tpos += 3 + len;\n\t}\n\t/* Check we ended where we expected to */\n\tif (pos != data_len) {\n\t\treturn -5;\n\t}\n\n\treturn -2;\n}\n\nvoid get_compiled_time(struct tm *tm)\n{\n\tchar s_month[5];\n\tint month = 0;\n\tint day = 0;\n\tint year = 0;\n\tint hour = 0;\n\tint min = 0;\n\tint sec = 0;\n\tstatic const char *month_names = \"JanFebMarAprMayJunJulAugSepOctNovDec\";\n\n\tsscanf(__DATE__, \"%4s %d %d\", s_month, &day, &year);\n\tmonth = (strstr(month_names, s_month) - month_names) / 3;\n\tsscanf(__TIME__, \"%d:%d:%d\", &hour, &min, &sec);\n\ttm->tm_year = year - 1900;\n\ttm->tm_mon = month;\n\ttm->tm_mday = day;\n\ttm->tm_isdst = -1;\n\ttm->tm_hour = hour;\n\ttm->tm_min = min;\n\ttm->tm_sec = sec;\n}\n\nunsigned long get_system_mem_size(void)\n{\n\tstruct sysinfo memInfo;\n\tsysinfo(&memInfo);\n\tlong long totalMem = memInfo.totalram;\n\ttotalMem *= memInfo.mem_unit;\n\n\treturn totalMem;\n}\n\nint is_numeric(const char *str)\n{\n\twhile (*str != '\\0') {\n\t\tif (*str < '0' || *str > '9') {\n\t\t\treturn -1;\n\t\t}\n\t\tstr++;\n\t}\n\treturn 0;\n}\n\nint has_network_raw_cap(void)\n{\n\tint fd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);\n\tif (fd < 0) {\n\t\treturn 0;\n\t}\n\n\tclose(fd);\n\treturn 1;\n}\n\nint has_unprivileged_ping(void)\n{\n\tint fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP);\n\tif (fd < 0) {\n\t\treturn 0;\n\t}\n\n\tclose(fd);\n\n\tfd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_ICMPV6);\n\tif (fd < 0) {\n\t\treturn 0;\n\t}\n\n\tclose(fd);\n\n\treturn 1;\n}\n\nint set_sock_keepalive(int fd, int keepidle, int keepinterval, int keepcnt)\n{\n\tconst int yes = 1;\n\tif (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &yes, sizeof(yes)) != 0) {\n\t\treturn -1;\n\t}\n\n\tsetsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &keepidle, sizeof(keepidle));\n\tsetsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &keepinterval, sizeof(keepinterval));\n\tsetsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &keepcnt, sizeof(keepcnt));\n\n\treturn 0;\n}\n\nint set_sock_lingertime(int fd, int time)\n{\n\tstruct linger l;\n\n\tl.l_onoff = 1;\n\tl.l_linger = 0;\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_LINGER, (const char *)&l, sizeof(l)) != 0) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nuint64_t get_free_space(const char *path)\n{\n\tuint64_t size = 0;\n\tstruct statvfs buf;\n\tif (statvfs(path, &buf) != 0) {\n\t\treturn 0;\n\t}\n\n\tsize = (uint64_t)buf.f_frsize * buf.f_bavail;\n\n\treturn size;\n}\n\nstruct backtrace_state {\n\tvoid **current;\n\tvoid **end;\n};\n\nstatic _Unwind_Reason_Code unwind_callback(struct _Unwind_Context *context, void *arg)\n{\n\tstruct backtrace_state *state = (struct backtrace_state *)(arg);\n\tuintptr_t pc = _Unwind_GetIP(context);\n\tif (pc) {\n\t\tif (state->current == state->end) {\n\t\t\treturn _URC_END_OF_STACK;\n\t\t}\n\n\t\t*state->current++ = (void *)(pc);\n\t}\n\treturn _URC_NO_REASON;\n}\n\nvoid print_stack(void)\n{\n\tconst size_t max_buffer = 30;\n\tvoid *buffer[max_buffer];\n\tint idx = 0;\n\n\tstruct backtrace_state state = {buffer, buffer + max_buffer};\n\t_Unwind_Backtrace(unwind_callback, &state);\n\tint frame_num = state.current - buffer;\n\tif (frame_num == 0) {\n\t\treturn;\n\t}\n\n\ttlog(TLOG_FATAL, \"Stack:\");\n\tfor (idx = 0; idx < frame_num; ++idx) {\n\t\tconst void *addr = buffer[idx];\n\t\tconst char *symbol = \"\";\n\n\t\tDl_info info;\n\t\tmemset(&info, 0, sizeof(info));\n\t\tif (dladdr(addr, &info) && info.dli_sname) {\n\t\t\tsymbol = info.dli_sname;\n\t\t}\n\n\t\tvoid *offset = (void *)((char *)(addr) - (char *)(info.dli_fbase));\n\t\ttlog(TLOG_FATAL, \"#%.2d: %p %s() from %s+%p\", idx + 1, addr, symbol, info.dli_fname, offset);\n\t}\n}\n\nvoid bug_ext(const char *file, int line, const char *func, const char *errfmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, errfmt);\n\ttlog_vext(TLOG_FATAL, file, line, func, NULL, errfmt, ap);\n\tva_end(ap);\n\n\tprint_stack();\n\t/* trigger BUG */\n\tsleep(1);\n\traise(SIGSEGV);\n\n\twhile (true) {\n\t\tsleep(1);\n\t};\n}\n\nint write_file(const char *filename, void *data, int data_len)\n{\n\tint fd = open(filename, O_WRONLY | O_CREAT, 0644);\n\tif (fd < 0) {\n\t\treturn -1;\n\t}\n\n\tint len = write(fd, data, data_len);\n\tif (len < 0) {\n\t\tgoto errout;\n\t}\n\n\tclose(fd);\n\treturn 0;\nerrout:\n\tif (fd > 0) {\n\t\tclose(fd);\n\t}\n\n\treturn -1;\n}\n\nint dns_packet_save(const char *dir, const char *type, const char *from, const void *packet, int packet_len)\n{\n\tchar *data = NULL;\n\tint data_len = 0;\n\tchar filename[BUFF_SZ];\n\tchar time_s[BUFF_SZ];\n\tint ret = -1;\n\n\tstruct tm *ptm;\n\tstruct tm tm;\n\tstruct timeval tm_val;\n\tstruct stat sb;\n\n\tif (stat(dir, &sb) != 0) {\n\t\tmkdir(dir, 0750);\n\t}\n\n\tif (gettimeofday(&tm_val, NULL) != 0) {\n\t\treturn -1;\n\t}\n\n\tptm = localtime_r(&tm_val.tv_sec, &tm);\n\tif (ptm == NULL) {\n\t\treturn -1;\n\t}\n\n\tsnprintf(time_s, sizeof(time_s) - 1, \"%.4d-%.2d-%.2d %.2d:%.2d:%.2d.%.3d\", ptm->tm_year + 1900, ptm->tm_mon + 1,\n\t\t\t ptm->tm_mday, ptm->tm_hour, ptm->tm_min, ptm->tm_sec, (int)(tm_val.tv_usec / 1000));\n\tsnprintf(filename, sizeof(filename) - 1, \"%s/%s-%.4d%.2d%.2d-%.2d%.2d%.2d%.1d.packet\", dir, type,\n\t\t\t ptm->tm_year + 1900, ptm->tm_mon + 1, ptm->tm_mday, ptm->tm_hour, ptm->tm_min, ptm->tm_sec,\n\t\t\t (int)(tm_val.tv_usec / 100000));\n\n\tdata = malloc(PACKET_BUF_SIZE);\n\tif (data == NULL) {\n\t\treturn -1;\n\t}\n\n\tdata_len = snprintf(data, PACKET_BUF_SIZE,\n\t\t\t\t\t\t\"type: %s\\n\"\n\t\t\t\t\t\t\"from: %s\\n\"\n\t\t\t\t\t\t\"time: %s\\n\"\n\t\t\t\t\t\t\"packet-len: %d\\n\",\n\t\t\t\t\t\ttype, from, time_s, packet_len);\n\tif (data_len <= 0 || data_len >= PACKET_BUF_SIZE) {\n\t\tgoto out;\n\t}\n\n\tdata[data_len] = 0;\n\tdata_len++;\n\tuint32_t magic = htonl(PACKET_MAGIC);\n\tmemcpy(data + data_len, &magic, sizeof(magic));\n\tdata_len += sizeof(magic);\n\tint len_in_h = htonl(packet_len);\n\tmemcpy(data + data_len, &len_in_h, sizeof(len_in_h));\n\tdata_len += 4;\n\tmemcpy(data + data_len, packet, packet_len);\n\tdata_len += packet_len;\n\n\tret = write_file(filename, data, data_len);\n\tif (ret != 0) {\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tif (data) {\n\t\tfree(data);\n\t}\n\n\treturn ret;\n}\n\n#ifdef DEBUG\nstruct _dns_read_packet_info {\n\tint data_len;\n\tint message_len;\n\tchar *message;\n\tint packet_len;\n\tuint8_t *packet;\n\tuint8_t data[0];\n};\n\nstatic struct _dns_read_packet_info *_dns_read_packet_file(const char *packet_file)\n{\n\tstruct _dns_read_packet_info *info = NULL;\n\tint fd = 0;\n\tint len = 0;\n\tint message_len = 0;\n\tuint8_t *ptr = NULL;\n\n\tinfo = malloc(sizeof(struct _dns_read_packet_info) + PACKET_BUF_SIZE);\n\tfd = open(packet_file, O_RDONLY);\n\tif (fd < 0) {\n\t\tprintf(\"open file %s failed, %s\\n\", packet_file, strerror(errno));\n\t\tgoto errout;\n\t}\n\n\tlen = read(fd, info->data, PACKET_BUF_SIZE);\n\tif (len < 0) {\n\t\tprintf(\"read file %s failed, %s\\n\", packet_file, strerror(errno));\n\t\tgoto errout;\n\t}\n\n\tmessage_len = strnlen((char *)info->data, PACKET_BUF_SIZE);\n\tif (message_len >= 512 || message_len >= len) {\n\t\tprintf(\"invalid packet file, bad message len\\n\");\n\t\tgoto errout;\n\t}\n\n\tinfo->message_len = message_len;\n\tinfo->message = (char *)info->data;\n\n\tptr = info->data + message_len + 1;\n\tuint32_t magic = 0;\n\tif (ptr - (uint8_t *)info + sizeof(magic) >= (size_t)len) {\n\t\tprintf(\"invalid packet file, magic length is invalid.\\n\");\n\t\tgoto errout;\n\t}\n\n\tmemcpy(&magic, ptr, sizeof(magic));\n\tif (magic != htonl(PACKET_MAGIC)) {\n\t\tprintf(\"invalid packet file, bad magic\\n\");\n\t\tgoto errout;\n\t}\n\tptr += sizeof(magic);\n\n\tuint32_t packet_len = 0;\n\tif (ptr - info->data + sizeof(packet_len) >= (size_t)len) {\n\t\tprintf(\"invalid packet file, packet length is invalid.\\n\");\n\t\tgoto errout;\n\t}\n\n\tmemcpy(&packet_len, ptr, sizeof(packet_len));\n\tpacket_len = ntohl(packet_len);\n\tptr += sizeof(packet_len);\n\tif (packet_len != (size_t)len - (ptr - info->data)) {\n\t\tprintf(\"invalid packet file, packet length is invalid\\n\");\n\t\tgoto errout;\n\t}\n\n\tinfo->packet_len = packet_len;\n\tinfo->packet = ptr;\n\n\tclose(fd);\n\treturn info;\nerrout:\n\n\tif (fd > 0) {\n\t\tclose(fd);\n\t}\n\n\tif (info) {\n\t\tfree(info);\n\t}\n\n\treturn NULL;\n}\n\nstatic int _dns_debug_display(struct dns_packet *packet)\n{\n\tint i = 0;\n\tint j = 0;\n\tint ttl = 0;\n\tstruct dns_rrs *rrs = NULL;\n\tint rr_count = 0;\n\tchar req_host[MAX_IP_LEN];\n\n\tfor (j = 1; j < DNS_RRS_END; j++) {\n\t\trrs = dns_get_rrs_start(packet, j, &rr_count);\n\t\tprintf(\"section: %d\\n\", j);\n\t\tfor (i = 0; i < rr_count && rrs; i++, rrs = dns_get_rrs_next(packet, rrs)) {\n\t\t\tswitch (rrs->type) {\n\t\t\tcase DNS_T_A: {\n\t\t\t\tunsigned char addr[4];\n\t\t\t\tchar name[DNS_MAX_CNAME_LEN] = {0};\n\t\t\t\t/* get A result */\n\t\t\t\tdns_get_A(rrs, name, DNS_MAX_CNAME_LEN, &ttl, addr);\n\t\t\t\treq_host[0] = '\\0';\n\t\t\t\tinet_ntop(AF_INET, addr, req_host, sizeof(req_host));\n\t\t\t\tprintf(\"domain: %s A: %s TTL: %d\\n\", name, req_host, ttl);\n\t\t\t} break;\n\t\t\tcase DNS_T_AAAA: {\n\t\t\t\tunsigned char addr[16];\n\t\t\t\tchar name[DNS_MAX_CNAME_LEN] = {0};\n\t\t\t\tdns_get_AAAA(rrs, name, DNS_MAX_CNAME_LEN, &ttl, addr);\n\t\t\t\treq_host[0] = '\\0';\n\t\t\t\tinet_ntop(AF_INET6, addr, req_host, sizeof(req_host));\n\t\t\t\tprintf(\"domain: %s AAAA: %s TTL:%d\\n\", name, req_host, ttl);\n\t\t\t} break;\n\t\t\tcase DNS_T_HTTPS: {\n\t\t\t\tchar name[DNS_MAX_CNAME_LEN] = {0};\n\t\t\t\tchar target[DNS_MAX_CNAME_LEN] = {0};\n\t\t\t\tstruct dns_https_param *p = NULL;\n\t\t\t\tint priority = 0;\n\t\t\t\tint ret = 0;\n\n\t\t\t\tret = dns_get_HTTPS_svcparm_start(rrs, &p, name, DNS_MAX_CNAME_LEN, &ttl, &priority, target,\n\t\t\t\t\t\t\t\t\t\t\t\tDNS_MAX_CNAME_LEN);\n\t\t\t\tif (ret != 0) {\n\t\t\t\t\tprintf(\"get HTTPS svcparm failed\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tprintf(\"domain: %s HTTPS: %s TTL: %d priority: %d\\n\", name, target, ttl, priority);\n\n\t\t\t\tfor (; p; p = dns_get_HTTPS_svcparm_next(rrs, p)) {\n\t\t\t\t\tswitch (p->key) {\n\t\t\t\t\tcase DNS_HTTPS_T_MANDATORY: {\n\t\t\t\t\t\tprintf(\"  HTTPS: mandatory: %s\\n\", p->value);\n\t\t\t\t\t} break;\n\t\t\t\t\tcase DNS_HTTPS_T_ALPN: {\n\t\t\t\t\t\tchar alph[64] = {0};\n\t\t\t\t\t\tint total_alph_len = 0;\n\t\t\t\t\t\tchar *ptr = (char *)p->value;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tint alphlen = *ptr;\n\t\t\t\t\t\t\tmemcpy(alph + total_alph_len, ptr + 1, alphlen);\n\t\t\t\t\t\t\ttotal_alph_len += alphlen;\n\t\t\t\t\t\t\tptr += alphlen + 1;\n\t\t\t\t\t\t\talph[total_alph_len] = ',';\n\t\t\t\t\t\t\ttotal_alph_len++;\n\t\t\t\t\t\t\talph[total_alph_len] = ' ';\n\t\t\t\t\t\t\ttotal_alph_len++;\n\t\t\t\t\t\t} while (ptr - (char *)p->value < p->len);\n\t\t\t\t\t\tif (total_alph_len > 2) {\n\t\t\t\t\t\t\talph[total_alph_len - 2] = '\\0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"  HTTPS: alpn: %s\\n\", alph);\n\t\t\t\t\t} break;\n\t\t\t\t\tcase DNS_HTTPS_T_NO_DEFAULT_ALPN: {\n\t\t\t\t\t\tprintf(\"  HTTPS: no_default_alpn: %s\\n\", p->value);\n\t\t\t\t\t} break;\n\t\t\t\t\tcase DNS_HTTPS_T_PORT: {\n\t\t\t\t\t\tint port = *(unsigned short *)(p->value);\n\t\t\t\t\t\tprintf(\"  HTTPS: port: %d\\n\", port);\n\t\t\t\t\t} break;\n\t\t\t\t\tcase DNS_HTTPS_T_IPV4HINT: {\n\t\t\t\t\t\tprintf(\"  HTTPS: ipv4hint: %d\\n\", p->len / 4);\n\t\t\t\t\t\tfor (int k = 0; k < p->len / 4; k++) {\n\t\t\t\t\t\t\tchar ip[16] = {0};\n\t\t\t\t\t\t\tinet_ntop(AF_INET, p->value + k * 4, ip, sizeof(ip));\n\t\t\t\t\t\t\tprintf(\"    ipv4: %s\\n\", ip);\n\t\t\t\t\t\t}\n\t\t\t\t\t} break;\n\t\t\t\t\tcase DNS_HTTPS_T_ECH: {\n\t\t\t\t\t\tprintf(\"  HTTPS: ech: \");\n\t\t\t\t\t\tfor (int k = 0; k < p->len; k++) {\n\t\t\t\t\t\t\tprintf(\"%02x \", p->value[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t\t} break;\n\t\t\t\t\tcase DNS_HTTPS_T_IPV6HINT: {\n\t\t\t\t\t\tprintf(\"  HTTPS: ipv6hint: %d\\n\", p->len / 16);\n\t\t\t\t\t\tfor (int k = 0; k < p->len / 16; k++) {\n\t\t\t\t\t\t\tchar ip[64] = {0};\n\t\t\t\t\t\t\tinet_ntop(AF_INET6, p->value + k * 16, ip, sizeof(ip));\n\t\t\t\t\t\t\tprintf(\"    ipv6: %s\\n\", ip);\n\t\t\t\t\t\t}\n\t\t\t\t\t} break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} break;\n\t\t\tcase DNS_T_NS: {\n\t\t\t\tchar cname[DNS_MAX_CNAME_LEN];\n\t\t\t\tchar name[DNS_MAX_CNAME_LEN] = {0};\n\t\t\t\tdns_get_CNAME(rrs, name, DNS_MAX_CNAME_LEN, &ttl, cname, DNS_MAX_CNAME_LEN);\n\t\t\t\tprintf(\"domain: %s TTL: %d NS: %s\\n\", name, ttl, cname);\n\t\t\t} break;\n\t\t\tcase DNS_T_CNAME: {\n\t\t\t\tchar cname[DNS_MAX_CNAME_LEN];\n\t\t\t\tchar name[DNS_MAX_CNAME_LEN] = {0};\n\t\t\t\tif (dns_conf_force_no_cname) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdns_get_CNAME(rrs, name, DNS_MAX_CNAME_LEN, &ttl, cname, DNS_MAX_CNAME_LEN);\n\t\t\t\tprintf(\"domain: %s TTL: %d CNAME: %s\\n\", name, ttl, cname);\n\t\t\t} break;\n\t\t\tcase DNS_T_SOA: {\n\t\t\t\tchar name[DNS_MAX_CNAME_LEN] = {0};\n\t\t\t\tstruct dns_soa soa;\n\t\t\t\tdns_get_SOA(rrs, name, 128, &ttl, &soa);\n\t\t\t\tprintf(\"domain: %s SOA: mname: %s, rname: %s, serial: %d, refresh: %d, retry: %d, expire: \"\n\t\t\t\t\t   \"%d, minimum: %d\",\n\t\t\t\t\t   name, soa.mname, soa.rname, soa.serial, soa.refresh, soa.retry, soa.expire, soa.minimum);\n\t\t\t} break;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn 0;\n}\n\nint dns_packet_debug(const char *packet_file)\n{\n\tstruct _dns_read_packet_info *info = NULL;\n\tchar buff[DNS_PACKSIZE];\n\n\ttlog_set_maxlog_count(0);\n\ttlog_setlogscreen(1);\n\ttlog_setlevel(TLOG_DEBUG);\n\n\tinfo = _dns_read_packet_file(packet_file);\n\tif (info == NULL) {\n\t\tgoto errout;\n\t}\n\n\tconst char *send_env = getenv(\"SMARTDNS_DEBUG_SEND\");\n\tif (send_env != NULL) {\n\t\tchar ip[32];\n\t\tint port = 53;\n\t\tif (parse_ip(send_env, ip, &port) == 0) {\n\t\t\tint sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n\t\t\tif (sockfd > 0) {\n\t\t\t\tstruct sockaddr_in server;\n\t\t\t\tserver.sin_family = AF_INET;\n\t\t\t\tserver.sin_port = htons(port);\n\t\t\t\tserver.sin_addr.s_addr = inet_addr(ip);\n\t\t\t\tsendto(sockfd, info->packet, info->packet_len, 0, (struct sockaddr *)&server, sizeof(server));\n\t\t\t\tclose(sockfd);\n\t\t\t}\n\t\t}\n\t}\n\n\tstruct dns_packet *packet = (struct dns_packet *)buff;\n\tif (dns_decode(packet, DNS_PACKSIZE, info->packet, info->packet_len) != 0) {\n\t\tprintf(\"decode failed.\\n\");\n\t\tgoto errout;\n\t}\n\n\t_dns_debug_display(packet);\n\n\tfree(info);\n\treturn 0;\n\nerrout:\n\tif (info) {\n\t\tfree(info);\n\t}\n\n\treturn -1;\n}\n\n#endif\n"], "filenames": ["src/dns.c", "src/dns.h", "src/util.c"], "buggy_code_start_loc": [276, 32, 1604], "buggy_code_end_loc": [1976, 296, 1621], "fixing_code_start_loc": [277, 33, 1604], "fixing_code_end_loc": [2032, 305, 1638], "type": "CWE-787", "message": "SmartDNS through 41 before 56d0332 allows an out-of-bounds write because of a stack-based buffer overflow in the _dns_encode_domain function in the dns.c file, via a crafted DNS request.", "other": {"cve": {"id": "CVE-2023-31470", "sourceIdentifier": "cve@mitre.org", "published": "2023-04-28T21:15:09.307", "lastModified": "2023-05-08T17:42:00.757", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "SmartDNS through 41 before 56d0332 allows an out-of-bounds write because of a stack-based buffer overflow in the _dns_encode_domain function in the dns.c file, via a crafted DNS request."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:smartdns_project:smartdns:*:*:*:*:*:*:*:*", "versionEndIncluding": "41", "matchCriteriaId": "D5368DF9-87D5-4CC3-BCCA-5E7DF8098097"}]}]}], "references": [{"url": "https://github.com/pymumu/smartdns/commit/56d0332bf91104cfc877635f6c82e9348587df04", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/pymumu/smartdns/issues/1378", "source": "cve@mitre.org", "tags": ["Exploit"]}]}, "github_commit_url": "https://github.com/pymumu/smartdns/commit/56d0332bf91104cfc877635f6c82e9348587df04"}}