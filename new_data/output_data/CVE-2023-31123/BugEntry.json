{"buggy_code": ["// SPDX-FileCopyrightText: 2023 froggie <legal@frogg.ie>\n//\n// SPDX-License-Identifier: OSL-3.0\n\npackage api\n\nimport (\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/effectindex/tripreporter/models\"\n\t\"github.com/effectindex/tripreporter/types\"\n\t\"github.com/gorilla/mux\"\n)\n\nfunc SetupAccountEndpoints(v1 *mux.Router) {\n\ta1 := v1.Methods(http.MethodGet, http.MethodPatch, http.MethodDelete).Subrouter()\n\ta1.Use(AuthMiddleware())\n\n\tv1.HandleFunc(\"/account\", AccountPost).Methods(http.MethodPost)\n\ta1.HandleFunc(\"/account\", AccountGet).Methods(http.MethodGet)\n\ta1.HandleFunc(\"/account\", AccountPatch).Methods(http.MethodPatch)\n\ta1.HandleFunc(\"/account\", AccountDelete).Methods(http.MethodDelete)\n\tv1.HandleFunc(\"/account/login\", AccountPostLogin).Methods(http.MethodPost)\n\tv1.HandleFunc(\"/account/validate\", AccountValidate).Methods(http.MethodPost)\n}\n\n// AccountPost path is /api/v1/account\nfunc AccountPost(w http.ResponseWriter, r *http.Request) {\n\taccount, err := (&models.Account{Context: ctx.Context}).FromBody(r)\n\tif err != nil {\n\t\tctx.HandleStatus(w, r, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\taccount = account.ClearImmutable()\n\taccount.Default(account) // We don't want to let users set the ID and so on when creating an account\n\taccount, err = account.Post()\n\tif err != nil {\n\t\tctx.HandleStatus(w, r, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// If a new user is not provided when making an account, we default to making a blank one\n\tif account.NewUser == nil {\n\t\taccount.NewUser = &models.User{Context: ctx.Context, Unique: account.Unique}\n\t} else {\n\t\taccount.NewUser.Unique = account.Unique\n\t}\n\n\t// Create the associated user for the account.\n\taccount.NewUser, err = account.NewUser.Post()\n\tif err != nil {\n\t\tctx.HandleStatus(w, r, \"user: \"+err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Create an auth session.\n\tsession, err := (&models.Session{Context: ctx.Context, Unique: account.Unique}).Post()\n\tif err != nil {\n\t\tctx.HandleStatus(w, r, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\texpiry := time.Now().Add(time.Hour * 15) // TODO: Change this once we've implemented refreshing\n\tSetAuthCookie(w, types.CookieSessionID, session.Key.ID.String(), expiry)\n\tSetAuthCookie(w, types.CookieRefreshToken, session.Refresh, expiry)\n\n\tctx.HandleJson(w, r, account.CopyPublic(), http.StatusCreated)\n}\n\nfunc AccountPostLogin(w http.ResponseWriter, r *http.Request) {\n\taccount, err := (&models.Account{Context: ctx.Context}).FromBody(r)\n\tif err != nil {\n\t\tctx.HandleStatus(w, r, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tvar a1 = &models.Account{Context: ctx.Context}\n\ta1.FromData(account)\n\ta1, err = a1.Get()\n\tif err != nil {\n\t\tctx.HandleStatus(w, r, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\taccount, err = a1.ValidatePassword(account.Password, \"Password\")\n\tif err != nil {\n\t\tctx.HandleStatus(w, r, \"Invalid username or password!\", http.StatusForbidden)\n\t\treturn\n\t}\n\n\tsession, err := (&models.Session{Context: ctx.Context, Unique: account.Unique}).Post()\n\tif err != nil {\n\t\tctx.HandleStatus(w, r, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\texpiry := time.Now().Add(time.Hour * 15) // TODO: Change this once we've implemented refreshing\n\tSetAuthCookie(w, types.CookieSessionID, session.Key.ID.String(), expiry)\n\tSetAuthCookie(w, types.CookieRefreshToken, session.Refresh, expiry)\n\n\tctx.HandleJson(w, r, account.CopyPublic(), http.StatusOK)\n}\n\n// AccountGet path is /api/v1/account\nfunc AccountGet(w http.ResponseWriter, r *http.Request) {\n\tctxVal, ok := ctx.GetCtxValOrHandle(w, r)\n\tif !ok {\n\t\treturn\n\t}\n\n\taccount, err := (&models.Account{Context: ctx.Context, Unique: models.Unique{ID: ctxVal.Account}}).Get()\n\tif err != nil {\n\t\tif err == types.ErrorAccountNotSpecified || err == types.ErrorAccountNotFound {\n\t\t\tctx.HandleStatus(w, r, err.Error(), http.StatusBadRequest)\n\t\t} else {\n\t\t\tctx.HandleStatus(w, r, err.Error(), http.StatusInternalServerError)\n\t\t}\n\t\treturn\n\t}\n\n\tctx.HandleJson(w, r, account.CopyPublic(), http.StatusOK)\n}\n\n// AccountPatch path is /api/v1/account\nfunc AccountPatch(w http.ResponseWriter, r *http.Request) {\n\taccount, err := (&models.Account{Context: ctx.Context}).FromBody(r)\n\tif err != nil {\n\t\tctx.HandleStatus(w, r, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\taccount = account.ClearImmutable()\n\taccount, err = account.Patch()\n\tif err != nil {\n\t\tctx.HandleStatus(w, r, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tctx.HandleJson(w, r, account.CopyPublic(), http.StatusOK)\n}\n\n// AccountDelete path is /api/v1/account\nfunc AccountDelete(w http.ResponseWriter, r *http.Request) {\n\tctxVal, ok := ctx.GetCtxValOrHandle(w, r)\n\tif !ok {\n\t\treturn\n\t}\n\n\taccount, err := (&models.Account{Context: ctx.Context}).FromBody(r)\n\tif err != nil {\n\t\tctx.HandleStatus(w, r, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Set account ID from session context\n\taccount.Unique = models.Unique{ID: ctxVal.Account}\n\taccount, err = account.Delete()\n\tif err != nil {\n\t\tctx.HandleStatus(w, r, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tDeleteAuthCookies(w, types.CookieSessionID, types.CookieRefreshToken, types.CookieJwtToken)\n\n\tctx.HandleJson(w, r, account.ClearAll(), http.StatusOK)\n}\n\n// AccountValidate path is /api/v1/account/validate\nfunc AccountValidate(w http.ResponseWriter, r *http.Request) {\n\taccount, err := (&models.Account{Context: ctx.Context}).FromBody(r)\n\tif err != nil {\n\t\tctx.HandleStatus(w, r, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Check if we have fields to validate, to avoid making an unnecessary DB GET.\n\tif len(account.Email) == 0 && len(account.Username) == 0 && len(account.Password) == 0 {\n\t\tctx.HandleStatus(w, r, \"Account validation data required.\", http.StatusNotAcceptable)\n\t\treturn\n\t}\n\n\t// Validate password first, because we don't need to check the DB for it.\n\tif len(account.Password) > 0 {\n\t\t_, err = (&models.Account{Context: ctx.Context}).ValidatePassword(account.Password, \"Password\")\n\t\tif err != nil {\n\t\t\tctx.HandleStatus(w, r, err.Error(), http.StatusNotAcceptable)\n\t\t\treturn\n\t\t}\n\n\t\tctx.Handle(w, r, MsgOk)\n\t\treturn\n\t}\n\n\t// Validate email\n\tif len(account.Email) > 0 {\n\t\t_, err = account.ValidateEmail()\n\t\tif err != nil {\n\t\t\tctx.HandleStatus(w, r, err.Error(), http.StatusNotAcceptable)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Validate username\n\tif len(account.Username) > 0 {\n\t\t_, err = account.ValidateUsername()\n\t\tif err != nil {\n\t\t\tctx.HandleStatus(w, r, err.Error(), http.StatusNotAcceptable)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Now that either or email or username exist and are valid, we can check if it's in use already.\n\t// Because we don't want to allow anyone to GET an account by its ID, we only want to copy the email and username.\n\t// Then, we GET the account to see if we catch any errors.\n\t_, err = (&models.Account{Context: ctx.Context, Email: account.Email, Username: account.Username}).Get()\n\tif err == nil || err != types.ErrorAccountNotFound {\n\t\tctx.HandleStatus(w, r, \"Email or username already in use!\", http.StatusNotAcceptable)\n\t\treturn\n\t}\n\n\tctx.Handle(w, r, MsgOk)\n}\n"], "fixing_code": ["// SPDX-FileCopyrightText: 2023 froggie <legal@frogg.ie>\n//\n// SPDX-License-Identifier: OSL-3.0\n\npackage api\n\nimport (\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/effectindex/tripreporter/models\"\n\t\"github.com/effectindex/tripreporter/types\"\n\t\"github.com/gorilla/mux\"\n)\n\nfunc SetupAccountEndpoints(v1 *mux.Router) {\n\ta1 := v1.Methods(http.MethodGet, http.MethodPatch, http.MethodDelete).Subrouter()\n\ta1.Use(AuthMiddleware())\n\n\tv1.HandleFunc(\"/account\", AccountPost).Methods(http.MethodPost)\n\ta1.HandleFunc(\"/account\", AccountGet).Methods(http.MethodGet)\n\ta1.HandleFunc(\"/account\", AccountPatch).Methods(http.MethodPatch)\n\ta1.HandleFunc(\"/account\", AccountDelete).Methods(http.MethodDelete)\n\tv1.HandleFunc(\"/account/login\", AccountPostLogin).Methods(http.MethodPost)\n\tv1.HandleFunc(\"/account/validate\", AccountValidate).Methods(http.MethodPost)\n}\n\n// AccountPost path is /api/v1/account\nfunc AccountPost(w http.ResponseWriter, r *http.Request) {\n\taccount, err := (&models.Account{Context: ctx.Context}).FromBody(r)\n\tif err != nil {\n\t\tctx.HandleStatus(w, r, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\taccount = account.ClearImmutable()\n\taccount.Default(account) // We don't want to let users set the ID and so on when creating an account\n\taccount, err = account.Post()\n\tif err != nil {\n\t\tctx.HandleStatus(w, r, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// If a new user is not provided when making an account, we default to making a blank one\n\tif account.NewUser == nil {\n\t\taccount.NewUser = &models.User{Context: ctx.Context, Unique: account.Unique}\n\t} else {\n\t\taccount.NewUser.Unique = account.Unique\n\t}\n\n\t// Create the associated user for the account.\n\taccount.NewUser, err = account.NewUser.Post()\n\tif err != nil {\n\t\tctx.HandleStatus(w, r, \"user: \"+err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Create an auth session.\n\tsession, err := (&models.Session{Context: ctx.Context, Unique: account.Unique}).Post()\n\tif err != nil {\n\t\tctx.HandleStatus(w, r, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\texpiry := time.Now().Add(time.Hour * 15) // TODO: Change this once we've implemented refreshing\n\tSetAuthCookie(w, types.CookieSessionID, session.Key.ID.String(), expiry)\n\tSetAuthCookie(w, types.CookieRefreshToken, session.Refresh, expiry)\n\n\tctx.HandleJson(w, r, account.CopyPublic(), http.StatusCreated)\n}\n\nfunc AccountPostLogin(w http.ResponseWriter, r *http.Request) {\n\taccount, err := (&models.Account{Context: ctx.Context}).FromBody(r)\n\tif err != nil {\n\t\tctx.HandleStatus(w, r, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tvar a1 = &models.Account{Context: ctx.Context}\n\ta1.FromData(account)\n\ta1, err = a1.Get()\n\tif err != nil {\n\t\tctx.HandleStatus(w, r, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\taccount, err = a1.VerifyPassword(account.Password)\n\tif err != nil {\n\t\tctx.HandleStatus(w, r, \"Invalid username or password!\", http.StatusForbidden)\n\t\treturn\n\t}\n\n\tsession, err := (&models.Session{Context: ctx.Context, Unique: account.Unique}).Post()\n\tif err != nil {\n\t\tctx.HandleStatus(w, r, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\texpiry := time.Now().Add(time.Hour * 15) // TODO: Change this once we've implemented refreshing\n\tSetAuthCookie(w, types.CookieSessionID, session.Key.ID.String(), expiry)\n\tSetAuthCookie(w, types.CookieRefreshToken, session.Refresh, expiry)\n\n\tctx.HandleJson(w, r, account.CopyPublic(), http.StatusOK)\n}\n\n// AccountGet path is /api/v1/account\nfunc AccountGet(w http.ResponseWriter, r *http.Request) {\n\tctxVal, ok := ctx.GetCtxValOrHandle(w, r)\n\tif !ok {\n\t\treturn\n\t}\n\n\taccount, err := (&models.Account{Context: ctx.Context, Unique: models.Unique{ID: ctxVal.Account}}).Get()\n\tif err != nil {\n\t\tif err == types.ErrorAccountNotSpecified || err == types.ErrorAccountNotFound {\n\t\t\tctx.HandleStatus(w, r, err.Error(), http.StatusBadRequest)\n\t\t} else {\n\t\t\tctx.HandleStatus(w, r, err.Error(), http.StatusInternalServerError)\n\t\t}\n\t\treturn\n\t}\n\n\tctx.HandleJson(w, r, account.CopyPublic(), http.StatusOK)\n}\n\n// AccountPatch path is /api/v1/account\nfunc AccountPatch(w http.ResponseWriter, r *http.Request) {\n\taccount, err := (&models.Account{Context: ctx.Context}).FromBody(r)\n\tif err != nil {\n\t\tctx.HandleStatus(w, r, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\taccount = account.ClearImmutable()\n\taccount, err = account.Patch()\n\tif err != nil {\n\t\tctx.HandleStatus(w, r, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tctx.HandleJson(w, r, account.CopyPublic(), http.StatusOK)\n}\n\n// AccountDelete path is /api/v1/account\nfunc AccountDelete(w http.ResponseWriter, r *http.Request) {\n\tctxVal, ok := ctx.GetCtxValOrHandle(w, r)\n\tif !ok {\n\t\treturn\n\t}\n\n\taccount, err := (&models.Account{Context: ctx.Context}).FromBody(r)\n\tif err != nil {\n\t\tctx.HandleStatus(w, r, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Set account ID from session context\n\taccount.Unique = models.Unique{ID: ctxVal.Account}\n\taccount, err = account.Delete()\n\tif err != nil {\n\t\tctx.HandleStatus(w, r, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tDeleteAuthCookies(w, types.CookieSessionID, types.CookieRefreshToken, types.CookieJwtToken)\n\n\tctx.HandleJson(w, r, account.ClearAll(), http.StatusOK)\n}\n\n// AccountValidate path is /api/v1/account/validate\nfunc AccountValidate(w http.ResponseWriter, r *http.Request) {\n\taccount, err := (&models.Account{Context: ctx.Context}).FromBody(r)\n\tif err != nil {\n\t\tctx.HandleStatus(w, r, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Check if we have fields to validate, to avoid making an unnecessary DB GET.\n\tif len(account.Email) == 0 && len(account.Username) == 0 && len(account.Password) == 0 {\n\t\tctx.HandleStatus(w, r, \"Account validation data required.\", http.StatusNotAcceptable)\n\t\treturn\n\t}\n\n\t// Validate password first, because we don't need to check the DB for it.\n\tif len(account.Password) > 0 {\n\t\t_, err = (&models.Account{Context: ctx.Context}).ValidatePassword(account.Password, \"Password\")\n\t\tif err != nil {\n\t\t\tctx.HandleStatus(w, r, err.Error(), http.StatusNotAcceptable)\n\t\t\treturn\n\t\t}\n\n\t\tctx.Handle(w, r, MsgOk)\n\t\treturn\n\t}\n\n\t// Validate email\n\tif len(account.Email) > 0 {\n\t\t_, err = account.ValidateEmail()\n\t\tif err != nil {\n\t\t\tctx.HandleStatus(w, r, err.Error(), http.StatusNotAcceptable)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Validate username\n\tif len(account.Username) > 0 {\n\t\t_, err = account.ValidateUsername()\n\t\tif err != nil {\n\t\t\tctx.HandleStatus(w, r, err.Error(), http.StatusNotAcceptable)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Now that either or email or username exist and are valid, we can check if it's in use already.\n\t// Because we don't want to allow anyone to GET an account by its ID, we only want to copy the email and username.\n\t// Then, we GET the account to see if we catch any errors.\n\t_, err = (&models.Account{Context: ctx.Context, Email: account.Email, Username: account.Username}).Get()\n\tif err == nil || err != types.ErrorAccountNotFound {\n\t\tctx.HandleStatus(w, r, \"Email or username already in use!\", http.StatusNotAcceptable)\n\t\treturn\n\t}\n\n\tctx.Handle(w, r, MsgOk)\n}\n"], "filenames": ["api/account.go"], "buggy_code_start_loc": [87], "buggy_code_end_loc": [88], "fixing_code_start_loc": [87], "fixing_code_end_loc": [88], "type": "CWE-287", "message": "`effectindex/tripreporter` is a community-powered, universal platform for submitting and analyzing trip reports. Prior to commit bd80ba833b9023d39ca22e29874296c8729dd53b, any user with an account on an instance of `effectindex/tripreporter`, e.g. `subjective.report`, may be affected by an improper password verification vulnerability. The vulnerability allows any user with a password matching the password requirements to log in as any user. This allows access to accounts / data loss of the user. This issue is patched in commit bd80ba833b9023d39ca22e29874296c8729dd53b. No action necessary for users of `subjective.report`, and anyone running their own instance should update to this commit or newer as soon as possible. As a workaround, someone running their own instance may apply the patch manually.", "other": {"cve": {"id": "CVE-2023-31123", "sourceIdentifier": "security-advisories@github.com", "published": "2023-05-08T21:15:11.263", "lastModified": "2023-05-15T17:13:24.947", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "`effectindex/tripreporter` is a community-powered, universal platform for submitting and analyzing trip reports. Prior to commit bd80ba833b9023d39ca22e29874296c8729dd53b, any user with an account on an instance of `effectindex/tripreporter`, e.g. `subjective.report`, may be affected by an improper password verification vulnerability. The vulnerability allows any user with a password matching the password requirements to log in as any user. This allows access to accounts / data loss of the user. This issue is patched in commit bd80ba833b9023d39ca22e29874296c8729dd53b. No action necessary for users of `subjective.report`, and anyone running their own instance should update to this commit or newer as soon as possible. As a workaround, someone running their own instance may apply the patch manually."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:effectindex:tripreporter:*:*:*:*:*:*:*:*", "versionEndExcluding": "2023-04-30", "matchCriteriaId": "94AAC4BC-0731-43E8-99D0-BDEA996D1BFE"}]}]}], "references": [{"url": "https://github.com/effectindex/tripreporter/commit/bd80ba833b9023d39ca22e29874296c8729dd53b", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/effectindex/tripreporter/security/advisories/GHSA-356r-rwp8-h6m6", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/effectindex/tripreporter/commit/bd80ba833b9023d39ca22e29874296c8729dd53b"}}