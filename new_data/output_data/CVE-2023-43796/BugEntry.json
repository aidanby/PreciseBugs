{"buggy_code": ["# Copyright 2015, 2016 OpenMarket Ltd\n# Copyright 2018 New Vector Ltd\n# Copyright 2019-2021 Matrix.org Federation C.I.C\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport logging\nimport random\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Awaitable,\n    Callable,\n    Collection,\n    Dict,\n    List,\n    Mapping,\n    Optional,\n    Tuple,\n    Union,\n)\n\nfrom prometheus_client import Counter, Gauge, Histogram\n\nfrom twisted.python import failure\n\nfrom synapse.api.constants import (\n    Direction,\n    EduTypes,\n    EventContentFields,\n    EventTypes,\n    Membership,\n)\nfrom synapse.api.errors import (\n    AuthError,\n    Codes,\n    FederationError,\n    IncompatibleRoomVersionError,\n    NotFoundError,\n    PartialStateConflictError,\n    SynapseError,\n    UnsupportedRoomVersionError,\n)\nfrom synapse.api.room_versions import KNOWN_ROOM_VERSIONS, RoomVersion\nfrom synapse.crypto.event_signing import compute_event_signature\nfrom synapse.events import EventBase\nfrom synapse.events.snapshot import EventContext\nfrom synapse.federation.federation_base import (\n    FederationBase,\n    InvalidEventSignatureError,\n    event_from_pdu_json,\n)\nfrom synapse.federation.persistence import TransactionActions\nfrom synapse.federation.units import Edu, Transaction\nfrom synapse.handlers.worker_lock import NEW_EVENT_DURING_PURGE_LOCK_NAME\nfrom synapse.http.servlet import assert_params_in_dict\nfrom synapse.logging.context import (\n    make_deferred_yieldable,\n    nested_logging_context,\n    run_in_background,\n)\nfrom synapse.logging.opentracing import (\n    SynapseTags,\n    log_kv,\n    set_tag,\n    start_active_span_from_edu,\n    tag_args,\n    trace,\n)\nfrom synapse.metrics.background_process_metrics import wrap_as_background_process\nfrom synapse.replication.http.federation import (\n    ReplicationFederationSendEduRestServlet,\n    ReplicationGetQueryRestServlet,\n)\nfrom synapse.storage.databases.main.lock import Lock\nfrom synapse.storage.databases.main.roommember import extract_heroes_from_room_summary\nfrom synapse.storage.roommember import MemberSummary\nfrom synapse.types import JsonDict, StateMap, get_domain_from_id\nfrom synapse.util import unwrapFirstError\nfrom synapse.util.async_helpers import Linearizer, concurrently_execute, gather_results\nfrom synapse.util.caches.response_cache import ResponseCache\nfrom synapse.util.stringutils import parse_server_name\n\nif TYPE_CHECKING:\n    from synapse.server import HomeServer\n\n# when processing incoming transactions, we try to handle multiple rooms in\n# parallel, up to this limit.\nTRANSACTION_CONCURRENCY_LIMIT = 10\n\nlogger = logging.getLogger(__name__)\n\nreceived_pdus_counter = Counter(\"synapse_federation_server_received_pdus\", \"\")\n\nreceived_edus_counter = Counter(\"synapse_federation_server_received_edus\", \"\")\n\nreceived_queries_counter = Counter(\n    \"synapse_federation_server_received_queries\", \"\", [\"type\"]\n)\n\npdu_process_time = Histogram(\n    \"synapse_federation_server_pdu_process_time\",\n    \"Time taken to process an event\",\n)\n\nlast_pdu_ts_metric = Gauge(\n    \"synapse_federation_last_received_pdu_time\",\n    \"The timestamp of the last PDU which was successfully received from the given domain\",\n    labelnames=(\"server_name\",),\n)\n\n\n# The name of the lock to use when process events in a room received over\n# federation.\n_INBOUND_EVENT_HANDLING_LOCK_NAME = \"federation_inbound_pdu\"\n\n\nclass FederationServer(FederationBase):\n    def __init__(self, hs: \"HomeServer\"):\n        super().__init__(hs)\n\n        self.server_name = hs.hostname\n        self.handler = hs.get_federation_handler()\n        self._spam_checker_module_callbacks = hs.get_module_api_callbacks().spam_checker\n        self._federation_event_handler = hs.get_federation_event_handler()\n        self.state = hs.get_state_handler()\n        self._event_auth_handler = hs.get_event_auth_handler()\n        self._room_member_handler = hs.get_room_member_handler()\n        self._e2e_keys_handler = hs.get_e2e_keys_handler()\n        self._worker_lock_handler = hs.get_worker_locks_handler()\n\n        self._state_storage_controller = hs.get_storage_controllers().state\n\n        self.device_handler = hs.get_device_handler()\n\n        # Ensure the following handlers are loaded since they register callbacks\n        # with FederationHandlerRegistry.\n        hs.get_directory_handler()\n\n        self._server_linearizer = Linearizer(\"fed_server\")\n\n        # origins that we are currently processing a transaction from.\n        # a dict from origin to txn id.\n        self._active_transactions: Dict[str, str] = {}\n\n        # We cache results for transaction with the same ID\n        self._transaction_resp_cache: ResponseCache[Tuple[str, str]] = ResponseCache(\n            hs.get_clock(), \"fed_txn_handler\", timeout_ms=30000\n        )\n\n        self.transaction_actions = TransactionActions(self.store)\n\n        self.registry = hs.get_federation_registry()\n\n        # We cache responses to state queries, as they take a while and often\n        # come in waves.\n        self._state_resp_cache: ResponseCache[\n            Tuple[str, Optional[str]]\n        ] = ResponseCache(hs.get_clock(), \"state_resp\", timeout_ms=30000)\n        self._state_ids_resp_cache: ResponseCache[Tuple[str, str]] = ResponseCache(\n            hs.get_clock(), \"state_ids_resp\", timeout_ms=30000\n        )\n\n        self._federation_metrics_domains = (\n            hs.config.federation.federation_metrics_domains\n        )\n\n        self._room_prejoin_state_types = hs.config.api.room_prejoin_state\n\n        # Whether we have started handling old events in the staging area.\n        self._started_handling_of_staged_events = False\n\n    @wrap_as_background_process(\"_handle_old_staged_events\")\n    async def _handle_old_staged_events(self) -> None:\n        \"\"\"Handle old staged events by fetching all rooms that have staged\n        events and start the processing of each of those rooms.\n        \"\"\"\n\n        # Get all the rooms IDs with staged events.\n        room_ids = await self.store.get_all_rooms_with_staged_incoming_events()\n\n        # We then shuffle them so that if there are multiple instances doing\n        # this work they're less likely to collide.\n        random.shuffle(room_ids)\n\n        for room_id in room_ids:\n            room_version = await self.store.get_room_version(room_id)\n\n            # Try and acquire the processing lock for the room, if we get it start a\n            # background process for handling the events in the room.\n            lock = await self.store.try_acquire_lock(\n                _INBOUND_EVENT_HANDLING_LOCK_NAME, room_id\n            )\n            if lock:\n                logger.info(\"Handling old staged inbound events in %s\", room_id)\n                self._process_incoming_pdus_in_room_inner(\n                    room_id,\n                    room_version,\n                    lock,\n                )\n\n            # We pause a bit so that we don't start handling all rooms at once.\n            await self._clock.sleep(random.uniform(0, 0.1))\n\n    async def on_backfill_request(\n        self, origin: str, room_id: str, versions: List[str], limit: int\n    ) -> Tuple[int, Dict[str, Any]]:\n        async with self._server_linearizer.queue((origin, room_id)):\n            origin_host, _ = parse_server_name(origin)\n            await self.check_server_matches_acl(origin_host, room_id)\n\n            pdus = await self.handler.on_backfill_request(\n                origin, room_id, versions, limit\n            )\n\n            res = self._transaction_dict_from_pdus(pdus)\n\n        return 200, res\n\n    async def on_timestamp_to_event_request(\n        self, origin: str, room_id: str, timestamp: int, direction: Direction\n    ) -> Tuple[int, Dict[str, Any]]:\n        \"\"\"When we receive a federated `/timestamp_to_event` request,\n        handle all of the logic for validating and fetching the event.\n\n        Args:\n            origin: The server we received the event from\n            room_id: Room to fetch the event from\n            timestamp: The point in time (inclusive) we should navigate from in\n                the given direction to find the closest event.\n            direction: indicates whether we should navigate forward\n                or backward from the given timestamp to find the closest event.\n\n        Returns:\n            Tuple indicating the response status code and dictionary response\n            body including `event_id`.\n        \"\"\"\n        async with self._server_linearizer.queue((origin, room_id)):\n            origin_host, _ = parse_server_name(origin)\n            await self.check_server_matches_acl(origin_host, room_id)\n\n            # We only try to fetch data from the local database\n            event_id = await self.store.get_event_id_for_timestamp(\n                room_id, timestamp, direction\n            )\n            if event_id:\n                event = await self.store.get_event(\n                    event_id, allow_none=False, allow_rejected=False\n                )\n\n                return 200, {\n                    \"event_id\": event_id,\n                    \"origin_server_ts\": event.origin_server_ts,\n                }\n\n        raise SynapseError(\n            404,\n            \"Unable to find event from %s in direction %s\" % (timestamp, direction),\n            errcode=Codes.NOT_FOUND,\n        )\n\n    async def on_incoming_transaction(\n        self,\n        origin: str,\n        transaction_id: str,\n        destination: str,\n        transaction_data: JsonDict,\n    ) -> Tuple[int, JsonDict]:\n        # If we receive a transaction we should make sure that kick off handling\n        # any old events in the staging area.\n        if not self._started_handling_of_staged_events:\n            self._started_handling_of_staged_events = True\n            self._handle_old_staged_events()\n\n            # Start a periodic check for old staged events. This is to handle\n            # the case where locks time out, e.g. if another process gets killed\n            # without dropping its locks.\n            self._clock.looping_call(self._handle_old_staged_events, 60 * 1000)\n\n        # keep this as early as possible to make the calculated origin ts as\n        # accurate as possible.\n        request_time = self._clock.time_msec()\n\n        transaction = Transaction(\n            transaction_id=transaction_id,\n            destination=destination,\n            origin=origin,\n            origin_server_ts=transaction_data.get(\"origin_server_ts\"),  # type: ignore[arg-type]\n            pdus=transaction_data.get(\"pdus\"),\n            edus=transaction_data.get(\"edus\"),\n        )\n\n        if not transaction_id:\n            raise Exception(\"Transaction missing transaction_id\")\n\n        logger.debug(\"[%s] Got transaction\", transaction_id)\n\n        # Reject malformed transactions early: reject if too many PDUs/EDUs\n        if len(transaction.pdus) > 50 or len(transaction.edus) > 100:\n            logger.info(\"Transaction PDU or EDU count too large. Returning 400\")\n            return 400, {}\n\n        # we only process one transaction from each origin at a time. We need to do\n        # this check here, rather than in _on_incoming_transaction_inner so that we\n        # don't cache the rejection in _transaction_resp_cache (so that if the txn\n        # arrives again later, we can process it).\n        current_transaction = self._active_transactions.get(origin)\n        if current_transaction and current_transaction != transaction_id:\n            logger.warning(\n                \"Received another txn %s from %s while still processing %s\",\n                transaction_id,\n                origin,\n                current_transaction,\n            )\n            return 429, {\n                \"errcode\": Codes.UNKNOWN,\n                \"error\": \"Too many concurrent transactions\",\n            }\n\n        # CRITICAL SECTION: we must now not await until we populate _active_transactions\n        # in _on_incoming_transaction_inner.\n\n        # We wrap in a ResponseCache so that we de-duplicate retried\n        # transactions.\n        return await self._transaction_resp_cache.wrap(\n            (origin, transaction_id),\n            self._on_incoming_transaction_inner,\n            origin,\n            transaction,\n            request_time,\n        )\n\n    async def _on_incoming_transaction_inner(\n        self, origin: str, transaction: Transaction, request_time: int\n    ) -> Tuple[int, Dict[str, Any]]:\n        # CRITICAL SECTION: the first thing we must do (before awaiting) is\n        # add an entry to _active_transactions.\n        assert origin not in self._active_transactions\n        self._active_transactions[origin] = transaction.transaction_id\n\n        try:\n            result = await self._handle_incoming_transaction(\n                origin, transaction, request_time\n            )\n            return result\n        finally:\n            del self._active_transactions[origin]\n\n    async def _handle_incoming_transaction(\n        self, origin: str, transaction: Transaction, request_time: int\n    ) -> Tuple[int, Dict[str, Any]]:\n        \"\"\"Process an incoming transaction and return the HTTP response\n\n        Args:\n            origin: the server making the request\n            transaction: incoming transaction\n            request_time: timestamp that the HTTP request arrived at\n\n        Returns:\n            HTTP response code and body\n        \"\"\"\n        existing_response = await self.transaction_actions.have_responded(\n            origin, transaction\n        )\n\n        if existing_response:\n            logger.debug(\n                \"[%s] We've already responded to this request\",\n                transaction.transaction_id,\n            )\n            return existing_response\n\n        logger.debug(\"[%s] Transaction is new\", transaction.transaction_id)\n\n        # We process PDUs and EDUs in parallel. This is important as we don't\n        # want to block things like to device messages from reaching clients\n        # behind the potentially expensive handling of PDUs.\n        pdu_results, _ = await make_deferred_yieldable(\n            gather_results(\n                (\n                    run_in_background(\n                        self._handle_pdus_in_txn, origin, transaction, request_time\n                    ),\n                    run_in_background(self._handle_edus_in_txn, origin, transaction),\n                ),\n                consumeErrors=True,\n            ).addErrback(unwrapFirstError)\n        )\n\n        response = {\"pdus\": pdu_results}\n\n        logger.debug(\"Returning: %s\", str(response))\n\n        await self.transaction_actions.set_response(origin, transaction, 200, response)\n        return 200, response\n\n    async def _handle_pdus_in_txn(\n        self, origin: str, transaction: Transaction, request_time: int\n    ) -> Dict[str, dict]:\n        \"\"\"Process the PDUs in a received transaction.\n\n        Args:\n            origin: the server making the request\n            transaction: incoming transaction\n            request_time: timestamp that the HTTP request arrived at\n\n        Returns:\n            A map from event ID of a processed PDU to any errors we should\n            report back to the sending server.\n        \"\"\"\n\n        received_pdus_counter.inc(len(transaction.pdus))\n\n        origin_host, _ = parse_server_name(origin)\n\n        pdus_by_room: Dict[str, List[EventBase]] = {}\n\n        newest_pdu_ts = 0\n\n        for p in transaction.pdus:\n            # FIXME (richardv): I don't think this works:\n            #  https://github.com/matrix-org/synapse/issues/8429\n            if \"unsigned\" in p:\n                unsigned = p[\"unsigned\"]\n                if \"age\" in unsigned:\n                    p[\"age\"] = unsigned[\"age\"]\n            if \"age\" in p:\n                p[\"age_ts\"] = request_time - int(p[\"age\"])\n                del p[\"age\"]\n\n            # We try and pull out an event ID so that if later checks fail we\n            # can log something sensible. We don't mandate an event ID here in\n            # case future event formats get rid of the key.\n            possible_event_id = p.get(\"event_id\", \"<Unknown>\")\n\n            # Now we get the room ID so that we can check that we know the\n            # version of the room.\n            room_id = p.get(\"room_id\")\n            if not room_id:\n                logger.info(\n                    \"Ignoring PDU as does not have a room_id. Event ID: %s\",\n                    possible_event_id,\n                )\n                continue\n\n            try:\n                room_version = await self.store.get_room_version(room_id)\n            except NotFoundError:\n                logger.info(\"Ignoring PDU for unknown room_id: %s\", room_id)\n                continue\n            except UnsupportedRoomVersionError as e:\n                # this can happen if support for a given room version is withdrawn,\n                # so that we still get events for said room.\n                logger.info(\"Ignoring PDU: %s\", e)\n                continue\n\n            event = event_from_pdu_json(p, room_version)\n            pdus_by_room.setdefault(room_id, []).append(event)\n\n            if event.origin_server_ts > newest_pdu_ts:\n                newest_pdu_ts = event.origin_server_ts\n\n        pdu_results = {}\n\n        # we can process different rooms in parallel (which is useful if they\n        # require callouts to other servers to fetch missing events), but\n        # impose a limit to avoid going too crazy with ram/cpu.\n\n        async def process_pdus_for_room(room_id: str) -> None:\n            with nested_logging_context(room_id):\n                logger.debug(\"Processing PDUs for %s\", room_id)\n\n                try:\n                    await self.check_server_matches_acl(origin_host, room_id)\n                except AuthError as e:\n                    logger.warning(\n                        \"Ignoring PDUs for room %s from banned server\", room_id\n                    )\n                    for pdu in pdus_by_room[room_id]:\n                        event_id = pdu.event_id\n                        pdu_results[event_id] = e.error_dict(self.hs.config)\n                    return\n\n                for pdu in pdus_by_room[room_id]:\n                    pdu_results[pdu.event_id] = await process_pdu(pdu)\n\n        async def process_pdu(pdu: EventBase) -> JsonDict:\n            \"\"\"\n            Processes a pushed PDU sent to us via a `/send` transaction\n\n            Returns:\n                JsonDict representing a \"PDU Processing Result\" that will be bundled up\n                with the other processed PDU's in the `/send` transaction and sent back\n                to remote homeserver.\n            \"\"\"\n            event_id = pdu.event_id\n            with nested_logging_context(event_id):\n                try:\n                    await self._handle_received_pdu(origin, pdu)\n                    return {}\n                except FederationError as e:\n                    logger.warning(\"Error handling PDU %s: %s\", event_id, e)\n                    return {\"error\": str(e)}\n                except Exception as e:\n                    f = failure.Failure()\n                    logger.error(\n                        \"Failed to handle PDU %s\",\n                        event_id,\n                        exc_info=(f.type, f.value, f.getTracebackObject()),\n                    )\n                    return {\"error\": str(e)}\n\n        await concurrently_execute(\n            process_pdus_for_room, pdus_by_room.keys(), TRANSACTION_CONCURRENCY_LIMIT\n        )\n\n        if newest_pdu_ts and origin in self._federation_metrics_domains:\n            last_pdu_ts_metric.labels(server_name=origin).set(newest_pdu_ts / 1000)\n\n        return pdu_results\n\n    async def _handle_edus_in_txn(self, origin: str, transaction: Transaction) -> None:\n        \"\"\"Process the EDUs in a received transaction.\"\"\"\n\n        async def _process_edu(edu_dict: JsonDict) -> None:\n            received_edus_counter.inc()\n\n            edu = Edu(\n                origin=origin,\n                destination=self.server_name,\n                edu_type=edu_dict[\"edu_type\"],\n                content=edu_dict[\"content\"],\n            )\n            await self.registry.on_edu(edu.edu_type, origin, edu.content)\n\n        await concurrently_execute(\n            _process_edu,\n            transaction.edus,\n            TRANSACTION_CONCURRENCY_LIMIT,\n        )\n\n    async def on_room_state_request(\n        self, origin: str, room_id: str, event_id: str\n    ) -> Tuple[int, JsonDict]:\n        await self._event_auth_handler.assert_host_in_room(room_id, origin)\n        origin_host, _ = parse_server_name(origin)\n        await self.check_server_matches_acl(origin_host, room_id)\n\n        # we grab the linearizer to protect ourselves from servers which hammer\n        # us. In theory we might already have the response to this query\n        # in the cache so we could return it without waiting for the linearizer\n        # - but that's non-trivial to get right, and anyway somewhat defeats\n        # the point of the linearizer.\n        async with self._server_linearizer.queue((origin, room_id)):\n            resp = await self._state_resp_cache.wrap(\n                (room_id, event_id),\n                self._on_context_state_request_compute,\n                room_id,\n                event_id,\n            )\n\n        return 200, resp\n\n    @trace\n    @tag_args\n    async def on_state_ids_request(\n        self, origin: str, room_id: str, event_id: str\n    ) -> Tuple[int, JsonDict]:\n        if not event_id:\n            raise NotImplementedError(\"Specify an event\")\n\n        await self._event_auth_handler.assert_host_in_room(room_id, origin)\n        origin_host, _ = parse_server_name(origin)\n        await self.check_server_matches_acl(origin_host, room_id)\n\n        resp = await self._state_ids_resp_cache.wrap(\n            (room_id, event_id),\n            self._on_state_ids_request_compute,\n            room_id,\n            event_id,\n        )\n\n        return 200, resp\n\n    @trace\n    @tag_args\n    async def _on_state_ids_request_compute(\n        self, room_id: str, event_id: str\n    ) -> JsonDict:\n        state_ids = await self.handler.get_state_ids_for_pdu(room_id, event_id)\n        auth_chain_ids = await self.store.get_auth_chain_ids(room_id, state_ids)\n        return {\"pdu_ids\": state_ids, \"auth_chain_ids\": list(auth_chain_ids)}\n\n    async def _on_context_state_request_compute(\n        self, room_id: str, event_id: str\n    ) -> Dict[str, list]:\n        pdus: Collection[EventBase]\n        event_ids = await self.handler.get_state_ids_for_pdu(room_id, event_id)\n        pdus = await self.store.get_events_as_list(event_ids)\n\n        auth_chain = await self.store.get_auth_chain(\n            room_id, [pdu.event_id for pdu in pdus]\n        )\n\n        return {\n            \"pdus\": [pdu.get_pdu_json() for pdu in pdus],\n            \"auth_chain\": [pdu.get_pdu_json() for pdu in auth_chain],\n        }\n\n    async def on_pdu_request(\n        self, origin: str, event_id: str\n    ) -> Tuple[int, Union[JsonDict, str]]:\n        pdu = await self.handler.get_persisted_pdu(origin, event_id)\n\n        if pdu:\n            return 200, self._transaction_dict_from_pdus([pdu])\n        else:\n            return 404, \"\"\n\n    async def on_query_request(\n        self, query_type: str, args: Dict[str, str]\n    ) -> Tuple[int, Dict[str, Any]]:\n        received_queries_counter.labels(query_type).inc()\n        resp = await self.registry.on_query(query_type, args)\n        return 200, resp\n\n    async def on_make_join_request(\n        self, origin: str, room_id: str, user_id: str, supported_versions: List[str]\n    ) -> Dict[str, Any]:\n        origin_host, _ = parse_server_name(origin)\n        await self.check_server_matches_acl(origin_host, room_id)\n\n        room_version = await self.store.get_room_version_id(room_id)\n        if room_version not in supported_versions:\n            logger.warning(\n                \"Room version %s not in %s\", room_version, supported_versions\n            )\n            raise IncompatibleRoomVersionError(room_version=room_version)\n\n        # Refuse the request if that room has seen too many joins recently.\n        # This is in addition to the HS-level rate limiting applied by\n        # BaseFederationServlet.\n        # type-ignore: mypy doesn't seem able to deduce the type of the limiter(!?)\n        await self._room_member_handler._join_rate_per_room_limiter.ratelimit(  # type: ignore[has-type]\n            requester=None,\n            key=room_id,\n            update=False,\n        )\n        pdu = await self.handler.on_make_join_request(origin, room_id, user_id)\n        return {\"event\": pdu.get_templated_pdu_json(), \"room_version\": room_version}\n\n    async def on_invite_request(\n        self, origin: str, content: JsonDict, room_version_id: str\n    ) -> Dict[str, Any]:\n        room_version = KNOWN_ROOM_VERSIONS.get(room_version_id)\n        if not room_version:\n            raise SynapseError(\n                400,\n                \"Homeserver does not support this room version\",\n                Codes.UNSUPPORTED_ROOM_VERSION,\n            )\n\n        pdu = event_from_pdu_json(content, room_version)\n        origin_host, _ = parse_server_name(origin)\n        await self.check_server_matches_acl(origin_host, pdu.room_id)\n        try:\n            pdu = await self._check_sigs_and_hash(room_version, pdu)\n        except InvalidEventSignatureError as e:\n            errmsg = f\"event id {pdu.event_id}: {e}\"\n            logger.warning(\"%s\", errmsg)\n            raise SynapseError(403, errmsg, Codes.FORBIDDEN)\n        ret_pdu = await self.handler.on_invite_request(origin, pdu, room_version)\n        time_now = self._clock.time_msec()\n        return {\"event\": ret_pdu.get_pdu_json(time_now)}\n\n    async def on_send_join_request(\n        self,\n        origin: str,\n        content: JsonDict,\n        room_id: str,\n        caller_supports_partial_state: bool = False,\n    ) -> Dict[str, Any]:\n        set_tag(\n            SynapseTags.SEND_JOIN_RESPONSE_IS_PARTIAL_STATE,\n            caller_supports_partial_state,\n        )\n        await self._room_member_handler._join_rate_per_room_limiter.ratelimit(  # type: ignore[has-type]\n            requester=None,\n            key=room_id,\n            update=False,\n        )\n\n        event, context = await self._on_send_membership_event(\n            origin, content, Membership.JOIN, room_id\n        )\n\n        prev_state_ids = await context.get_prev_state_ids()\n\n        state_event_ids: Collection[str]\n        servers_in_room: Optional[Collection[str]]\n        if caller_supports_partial_state:\n            summary = await self.store.get_room_summary(room_id)\n            state_event_ids = _get_event_ids_for_partial_state_join(\n                event, prev_state_ids, summary\n            )\n            servers_in_room = await self.state.get_hosts_in_room_at_events(\n                room_id, event_ids=event.prev_event_ids()\n            )\n        else:\n            state_event_ids = prev_state_ids.values()\n            servers_in_room = None\n\n        auth_chain_event_ids = await self.store.get_auth_chain_ids(\n            room_id, state_event_ids\n        )\n\n        # if the caller has opted in, we can omit any auth_chain events which are\n        # already in state_event_ids\n        if caller_supports_partial_state:\n            auth_chain_event_ids.difference_update(state_event_ids)\n\n        auth_chain_events = await self.store.get_events_as_list(auth_chain_event_ids)\n        state_events = await self.store.get_events_as_list(state_event_ids)\n\n        # we try to do all the async stuff before this point, so that time_now is as\n        # accurate as possible.\n        time_now = self._clock.time_msec()\n        event_json = event.get_pdu_json(time_now)\n        resp = {\n            \"event\": event_json,\n            \"state\": [p.get_pdu_json(time_now) for p in state_events],\n            \"auth_chain\": [p.get_pdu_json(time_now) for p in auth_chain_events],\n            \"members_omitted\": caller_supports_partial_state,\n        }\n\n        if servers_in_room is not None:\n            resp[\"servers_in_room\"] = list(servers_in_room)\n\n        return resp\n\n    async def on_make_leave_request(\n        self, origin: str, room_id: str, user_id: str\n    ) -> Dict[str, Any]:\n        origin_host, _ = parse_server_name(origin)\n        await self.check_server_matches_acl(origin_host, room_id)\n        pdu = await self.handler.on_make_leave_request(origin, room_id, user_id)\n\n        room_version = await self.store.get_room_version_id(room_id)\n\n        return {\"event\": pdu.get_templated_pdu_json(), \"room_version\": room_version}\n\n    async def on_send_leave_request(\n        self, origin: str, content: JsonDict, room_id: str\n    ) -> dict:\n        logger.debug(\"on_send_leave_request: content: %s\", content)\n        await self._on_send_membership_event(origin, content, Membership.LEAVE, room_id)\n        return {}\n\n    async def on_make_knock_request(\n        self, origin: str, room_id: str, user_id: str, supported_versions: List[str]\n    ) -> JsonDict:\n        \"\"\"We've received a /make_knock/ request, so we create a partial knock\n        event for the room and hand that back, along with the room version, to the knocking\n        homeserver. We do *not* persist or process this event until the other server has\n        signed it and sent it back.\n\n        Args:\n            origin: The (verified) server name of the requesting server.\n            room_id: The room to create the knock event in.\n            user_id: The user to create the knock for.\n            supported_versions: The room versions supported by the requesting server.\n\n        Returns:\n            The partial knock event.\n        \"\"\"\n        origin_host, _ = parse_server_name(origin)\n\n        if await self.store.is_partial_state_room(room_id):\n            # Before we do anything: check if the room is partial-stated.\n            # Note that at the time this check was added, `on_make_knock_request` would\n            # block due to https://github.com/matrix-org/synapse/issues/12997.\n            raise SynapseError(\n                404,\n                \"Unable to handle /make_knock right now; this server is not fully joined.\",\n                errcode=Codes.NOT_FOUND,\n            )\n\n        await self.check_server_matches_acl(origin_host, room_id)\n\n        room_version = await self.store.get_room_version(room_id)\n\n        # Check that this room version is supported by the remote homeserver\n        if room_version.identifier not in supported_versions:\n            logger.warning(\n                \"Room version %s not in %s\", room_version.identifier, supported_versions\n            )\n            raise IncompatibleRoomVersionError(room_version=room_version.identifier)\n\n        # Check that this room supports knocking as defined by its room version\n        if not room_version.knock_join_rule:\n            raise SynapseError(\n                403,\n                \"This room version does not support knocking\",\n                errcode=Codes.FORBIDDEN,\n            )\n\n        pdu = await self.handler.on_make_knock_request(origin, room_id, user_id)\n        return {\n            \"event\": pdu.get_templated_pdu_json(),\n            \"room_version\": room_version.identifier,\n        }\n\n    async def on_send_knock_request(\n        self,\n        origin: str,\n        content: JsonDict,\n        room_id: str,\n    ) -> Dict[str, List[JsonDict]]:\n        \"\"\"\n        We have received a knock event for a room. Verify and send the event into the room\n        on the knocking homeserver's behalf. Then reply with some stripped state from the\n        room for the knockee.\n\n        Args:\n            origin: The remote homeserver of the knocking user.\n            content: The content of the request.\n            room_id: The ID of the room to knock on.\n\n        Returns:\n            The stripped room state.\n        \"\"\"\n        _, context = await self._on_send_membership_event(\n            origin, content, Membership.KNOCK, room_id\n        )\n\n        # Retrieve stripped state events from the room and send them back to the remote\n        # server. This will allow the remote server's clients to display information\n        # related to the room while the knock request is pending.\n        stripped_room_state = (\n            await self.store.get_stripped_room_state_from_event_context(\n                context, self._room_prejoin_state_types\n            )\n        )\n        return {\"knock_room_state\": stripped_room_state}\n\n    async def _on_send_membership_event(\n        self, origin: str, content: JsonDict, membership_type: str, room_id: str\n    ) -> Tuple[EventBase, EventContext]:\n        \"\"\"Handle an on_send_{join,leave,knock} request\n\n        Does some preliminary validation before passing the request on to the\n        federation handler.\n\n        Args:\n            origin: The (authenticated) requesting server\n            content: The body of the send_* request - a complete membership event\n            membership_type: The expected membership type (join or leave, depending\n                on the endpoint)\n            room_id: The room_id from the request, to be validated against the room_id\n                in the event\n\n        Returns:\n            The event and context of the event after inserting it into the room graph.\n\n        Raises:\n            SynapseError if there is a problem with the request, including things like\n               the room_id not matching or the event not being authorized.\n        \"\"\"\n        assert_params_in_dict(content, [\"room_id\"])\n        if content[\"room_id\"] != room_id:\n            raise SynapseError(\n                400,\n                \"Room ID in body does not match that in request path\",\n                Codes.BAD_JSON,\n            )\n\n        # Note that get_room_version throws if the room does not exist here.\n        room_version = await self.store.get_room_version(room_id)\n\n        if await self.store.is_partial_state_room(room_id):\n            # If our server is still only partially joined, we can't give a complete\n            # response to /send_join, /send_knock or /send_leave.\n            # This is because we will not be able to provide the server list (for partial\n            # joins) or the full state (for full joins).\n            # Return a 404 as we would if we weren't in the room at all.\n            logger.info(\n                f\"Rejecting /send_{membership_type} to %s because it's a partial state room\",\n                room_id,\n            )\n            raise SynapseError(\n                404,\n                f\"Unable to handle /send_{membership_type} right now; this server is not fully joined.\",\n                errcode=Codes.NOT_FOUND,\n            )\n\n        if membership_type == Membership.KNOCK and not room_version.knock_join_rule:\n            raise SynapseError(\n                403,\n                \"This room version does not support knocking\",\n                errcode=Codes.FORBIDDEN,\n            )\n\n        event = event_from_pdu_json(content, room_version)\n\n        if event.type != EventTypes.Member or not event.is_state():\n            raise SynapseError(400, \"Not an m.room.member event\", Codes.BAD_JSON)\n\n        if event.content.get(\"membership\") != membership_type:\n            raise SynapseError(400, \"Not a %s event\" % membership_type, Codes.BAD_JSON)\n\n        origin_host, _ = parse_server_name(origin)\n        await self.check_server_matches_acl(origin_host, event.room_id)\n\n        logger.debug(\"_on_send_membership_event: pdu sigs: %s\", event.signatures)\n\n        # Sign the event since we're vouching on behalf of the remote server that\n        # the event is valid to be sent into the room. Currently this is only done\n        # if the user is being joined via restricted join rules.\n        if (\n            room_version.restricted_join_rule\n            and event.membership == Membership.JOIN\n            and EventContentFields.AUTHORISING_USER in event.content\n        ):\n            # We can only authorise our own users.\n            authorising_server = get_domain_from_id(\n                event.content[EventContentFields.AUTHORISING_USER]\n            )\n            if not self._is_mine_server_name(authorising_server):\n                raise SynapseError(\n                    400,\n                    f\"Cannot authorise membership event for {authorising_server}. We can only authorise requests from our own homeserver\",\n                )\n\n            event.signatures.update(\n                compute_event_signature(\n                    room_version,\n                    event.get_pdu_json(),\n                    self.hs.hostname,\n                    self.hs.signing_key,\n                )\n            )\n\n        try:\n            event = await self._check_sigs_and_hash(room_version, event)\n        except InvalidEventSignatureError as e:\n            errmsg = f\"event id {event.event_id}: {e}\"\n            logger.warning(\"%s\", errmsg)\n            raise SynapseError(403, errmsg, Codes.FORBIDDEN)\n\n        try:\n            return await self._federation_event_handler.on_send_membership_event(\n                origin, event\n            )\n        except PartialStateConflictError:\n            # The room was un-partial stated while we were persisting the event.\n            # Try once more, with full state this time.\n            logger.info(\n                \"Room %s was un-partial stated during `on_send_membership_event`, trying again.\",\n                room_id,\n            )\n            return await self._federation_event_handler.on_send_membership_event(\n                origin, event\n            )\n\n    async def on_event_auth(\n        self, origin: str, room_id: str, event_id: str\n    ) -> Tuple[int, Dict[str, Any]]:\n        async with self._server_linearizer.queue((origin, room_id)):\n            await self._event_auth_handler.assert_host_in_room(room_id, origin)\n            origin_host, _ = parse_server_name(origin)\n            await self.check_server_matches_acl(origin_host, room_id)\n\n            time_now = self._clock.time_msec()\n            auth_pdus = await self.handler.on_event_auth(event_id)\n            res = {\"auth_chain\": [a.get_pdu_json(time_now) for a in auth_pdus]}\n        return 200, res\n\n    async def on_query_client_keys(\n        self, origin: str, content: Dict[str, str]\n    ) -> Tuple[int, Dict[str, Any]]:\n        return await self.on_query_request(\"client_keys\", content)\n\n    async def on_query_user_devices(\n        self, origin: str, user_id: str\n    ) -> Tuple[int, Dict[str, Any]]:\n        keys = await self.device_handler.on_federation_query_user_devices(user_id)\n        return 200, keys\n\n    @trace\n    async def on_claim_client_keys(\n        self, query: List[Tuple[str, str, str, int]], always_include_fallback_keys: bool\n    ) -> Dict[str, Any]:\n        log_kv({\"message\": \"Claiming one time keys.\", \"user, device pairs\": query})\n        results = await self._e2e_keys_handler.claim_local_one_time_keys(\n            query, always_include_fallback_keys=always_include_fallback_keys\n        )\n\n        json_result: Dict[str, Dict[str, Dict[str, JsonDict]]] = {}\n        for result in results:\n            for user_id, device_keys in result.items():\n                for device_id, keys in device_keys.items():\n                    for key_id, key in keys.items():\n                        json_result.setdefault(user_id, {}).setdefault(device_id, {})[\n                            key_id\n                        ] = key\n\n        logger.info(\n            \"Claimed one-time-keys: %s\",\n            \",\".join(\n                (\n                    \"%s for %s:%s\" % (key_id, user_id, device_id)\n                    for user_id, user_keys in json_result.items()\n                    for device_id, device_keys in user_keys.items()\n                    for key_id, _ in device_keys.items()\n                )\n            ),\n        )\n\n        return {\"one_time_keys\": json_result}\n\n    async def on_get_missing_events(\n        self,\n        origin: str,\n        room_id: str,\n        earliest_events: List[str],\n        latest_events: List[str],\n        limit: int,\n    ) -> Dict[str, list]:\n        async with self._server_linearizer.queue((origin, room_id)):\n            origin_host, _ = parse_server_name(origin)\n            await self.check_server_matches_acl(origin_host, room_id)\n\n            logger.debug(\n                \"on_get_missing_events: earliest_events: %r, latest_events: %r,\"\n                \" limit: %d\",\n                earliest_events,\n                latest_events,\n                limit,\n            )\n\n            missing_events = await self.handler.on_get_missing_events(\n                origin, room_id, earliest_events, latest_events, limit\n            )\n\n            if len(missing_events) < 5:\n                logger.debug(\n                    \"Returning %d events: %r\", len(missing_events), missing_events\n                )\n            else:\n                logger.debug(\"Returning %d events\", len(missing_events))\n\n            time_now = self._clock.time_msec()\n\n        return {\"events\": [ev.get_pdu_json(time_now) for ev in missing_events]}\n\n    async def on_openid_userinfo(self, token: str) -> Optional[str]:\n        ts_now_ms = self._clock.time_msec()\n        return await self.store.get_user_id_for_open_id_token(token, ts_now_ms)\n\n    def _transaction_dict_from_pdus(self, pdu_list: List[EventBase]) -> JsonDict:\n        \"\"\"Returns a new Transaction containing the given PDUs suitable for\n        transmission.\n        \"\"\"\n        time_now = self._clock.time_msec()\n        pdus = [p.get_pdu_json(time_now) for p in pdu_list]\n        return Transaction(\n            # Just need a dummy transaction ID and destination since it won't be used.\n            transaction_id=\"\",\n            origin=self.server_name,\n            pdus=pdus,\n            origin_server_ts=int(time_now),\n            destination=\"\",\n        ).get_dict()\n\n    async def _handle_received_pdu(self, origin: str, pdu: EventBase) -> None:\n        \"\"\"Process a PDU received in a federation /send/ transaction.\n\n        If the event is invalid, then this method throws a FederationError.\n        (The error will then be logged and sent back to the sender (which\n        probably won't do anything with it), and other events in the\n        transaction will be processed as normal).\n\n        It is likely that we'll then receive other events which refer to\n        this rejected_event in their prev_events, etc.  When that happens,\n        we'll attempt to fetch the rejected event again, which will presumably\n        fail, so those second-generation events will also get rejected.\n\n        Eventually, we get to the point where there are more than 10 events\n        between any new events and the original rejected event. Since we\n        only try to backfill 10 events deep on received pdu, we then accept the\n        new event, possibly introducing a discontinuity in the DAG, with new\n        forward extremities, so normal service is approximately returned,\n        until we try to backfill across the discontinuity.\n\n        Args:\n            origin: server which sent the pdu\n            pdu: received pdu\n\n        Raises: FederationError if the signatures / hash do not match, or\n            if the event was unacceptable for any other reason (eg, too large,\n            too many prev_events, couldn't find the prev_events)\n        \"\"\"\n\n        # We've already checked that we know the room version by this point\n        room_version = await self.store.get_room_version(pdu.room_id)\n\n        # Check signature.\n        try:\n            pdu = await self._check_sigs_and_hash(room_version, pdu)\n        except InvalidEventSignatureError as e:\n            logger.warning(\"event id %s: %s\", pdu.event_id, e)\n            raise FederationError(\"ERROR\", 403, str(e), affected=pdu.event_id)\n\n        if await self._spam_checker_module_callbacks.should_drop_federated_event(pdu):\n            logger.warning(\n                \"Unstaged federated event contains spam, dropping %s\", pdu.event_id\n            )\n            return\n\n        # Add the event to our staging area\n        await self.store.insert_received_event_to_staging(origin, pdu)\n\n        # Try and acquire the processing lock for the room, if we get it start a\n        # background process for handling the events in the room.\n        lock = await self.store.try_acquire_lock(\n            _INBOUND_EVENT_HANDLING_LOCK_NAME, pdu.room_id\n        )\n        if lock:\n            self._process_incoming_pdus_in_room_inner(\n                pdu.room_id, room_version, lock, origin, pdu\n            )\n\n    async def _get_next_nonspam_staged_event_for_room(\n        self, room_id: str, room_version: RoomVersion\n    ) -> Optional[Tuple[str, EventBase]]:\n        \"\"\"Fetch the first non-spam event from staging queue.\n\n        Args:\n            room_id: the room to fetch the first non-spam event in.\n            room_version: the version of the room.\n\n        Returns:\n            The first non-spam event in that room.\n        \"\"\"\n\n        while True:\n            # We need to do this check outside the lock to avoid a race between\n            # a new event being inserted by another instance and it attempting\n            # to acquire the lock.\n            next = await self.store.get_next_staged_event_for_room(\n                room_id, room_version\n            )\n\n            if next is None:\n                return None\n\n            origin, event = next\n\n            if await self._spam_checker_module_callbacks.should_drop_federated_event(\n                event\n            ):\n                logger.warning(\n                    \"Staged federated event contains spam, dropping %s\",\n                    event.event_id,\n                )\n                continue\n\n            return next\n\n    @wrap_as_background_process(\"_process_incoming_pdus_in_room_inner\")\n    async def _process_incoming_pdus_in_room_inner(\n        self,\n        room_id: str,\n        room_version: RoomVersion,\n        lock: Lock,\n        latest_origin: Optional[str] = None,\n        latest_event: Optional[EventBase] = None,\n    ) -> None:\n        \"\"\"Process events in the staging area for the given room.\n\n        The latest_origin and latest_event args are the latest origin and event\n        received (or None to simply pull the next event from the database).\n        \"\"\"\n\n        # The common path is for the event we just received be the only event in\n        # the room, so instead of pulling the event out of the DB and parsing\n        # the event we just pull out the next event ID and check if that matches.\n        if latest_event is not None and latest_origin is not None:\n            result = await self.store.get_next_staged_event_id_for_room(room_id)\n            if result is None:\n                latest_origin = None\n                latest_event = None\n            else:\n                next_origin, next_event_id = result\n                if (\n                    next_origin != latest_origin\n                    or next_event_id != latest_event.event_id\n                ):\n                    latest_origin = None\n                    latest_event = None\n\n        if latest_origin is None or latest_event is None:\n            next = await self.store.get_next_staged_event_for_room(\n                room_id, room_version\n            )\n            if not next:\n                await lock.release()\n                return\n\n            origin, event = next\n        else:\n            origin = latest_origin\n            event = latest_event\n\n        # We loop round until there are no more events in the room in the\n        # staging area, or we fail to get the lock (which means another process\n        # has started processing).\n        while True:\n            async with lock:\n                logger.info(\"handling received PDU in room %s: %s\", room_id, event)\n                try:\n                    with nested_logging_context(event.event_id):\n                        # We're taking out a lock within a lock, which could\n                        # lead to deadlocks if we're not careful. However, it is\n                        # safe on this occasion as we only ever take a write\n                        # lock when deleting a room, which we would never do\n                        # while holding the `_INBOUND_EVENT_HANDLING_LOCK_NAME`\n                        # lock.\n                        async with self._worker_lock_handler.acquire_read_write_lock(\n                            NEW_EVENT_DURING_PURGE_LOCK_NAME, room_id, write=False\n                        ):\n                            await self._federation_event_handler.on_receive_pdu(\n                                origin, event\n                            )\n                except FederationError as e:\n                    # XXX: Ideally we'd inform the remote we failed to process\n                    # the event, but we can't return an error in the transaction\n                    # response (as we've already responded).\n                    logger.warning(\"Error handling PDU %s: %s\", event.event_id, e)\n                except Exception:\n                    f = failure.Failure()\n                    logger.error(\n                        \"Failed to handle PDU %s\",\n                        event.event_id,\n                        exc_info=(f.type, f.value, f.getTracebackObject()),\n                    )\n\n                received_ts = await self.store.remove_received_event_from_staging(\n                    origin, event.event_id\n                )\n                if received_ts is not None:\n                    pdu_process_time.observe(\n                        (self._clock.time_msec() - received_ts) / 1000\n                    )\n\n            next = await self._get_next_nonspam_staged_event_for_room(\n                room_id, room_version\n            )\n\n            if not next:\n                break\n\n            origin, event = next\n\n            # Prune the event queue if it's getting large.\n            #\n            # We do this *after* handling the first event as the common case is\n            # that the queue is empty (/has the single event in), and so there's\n            # no need to do this check.\n            pruned = await self.store.prune_staged_events_in_room(room_id, room_version)\n            if pruned:\n                # If we have pruned the queue check we need to refetch the next\n                # event to handle.\n                next = await self.store.get_next_staged_event_for_room(\n                    room_id, room_version\n                )\n                if not next:\n                    break\n\n                origin, event = next\n\n            new_lock = await self.store.try_acquire_lock(\n                _INBOUND_EVENT_HANDLING_LOCK_NAME, room_id\n            )\n            if not new_lock:\n                return\n            lock = new_lock\n\n    async def exchange_third_party_invite(\n        self, sender_user_id: str, target_user_id: str, room_id: str, signed: Dict\n    ) -> None:\n        await self.handler.exchange_third_party_invite(\n            sender_user_id, target_user_id, room_id, signed\n        )\n\n    async def on_exchange_third_party_invite_request(self, event_dict: Dict) -> None:\n        await self.handler.on_exchange_third_party_invite_request(event_dict)\n\n    async def check_server_matches_acl(self, server_name: str, room_id: str) -> None:\n        \"\"\"Check if the given server is allowed by the server ACLs in the room\n\n        Args:\n            server_name: name of server, *without any port part*\n            room_id: ID of the room to check\n\n        Raises:\n            AuthError if the server does not match the ACL\n        \"\"\"\n        server_acl_evaluator = (\n            await self._storage_controllers.state.get_server_acl_for_room(room_id)\n        )\n        if server_acl_evaluator and not server_acl_evaluator.server_matches_acl_event(\n            server_name\n        ):\n            raise AuthError(code=403, msg=\"Server is banned from room\")\n\n\nclass FederationHandlerRegistry:\n    \"\"\"Allows classes to register themselves as handlers for a given EDU or\n    query type for incoming federation traffic.\n    \"\"\"\n\n    def __init__(self, hs: \"HomeServer\"):\n        self.config = hs.config\n        self.clock = hs.get_clock()\n        self._instance_name = hs.get_instance_name()\n\n        # These are safe to load in monolith mode, but will explode if we try\n        # and use them. However we have guards before we use them to ensure that\n        # we don't route to ourselves, and in monolith mode that will always be\n        # the case.\n        self._get_query_client = ReplicationGetQueryRestServlet.make_client(hs)\n        self._send_edu = ReplicationFederationSendEduRestServlet.make_client(hs)\n\n        self.edu_handlers: Dict[str, Callable[[str, dict], Awaitable[None]]] = {}\n        self.query_handlers: Dict[str, Callable[[dict], Awaitable[JsonDict]]] = {}\n\n        # Map from type to instance names that we should route EDU handling to.\n        # We randomly choose one instance from the list to route to for each new\n        # EDU received.\n        self._edu_type_to_instance: Dict[str, List[str]] = {}\n\n    def register_edu_handler(\n        self, edu_type: str, handler: Callable[[str, JsonDict], Awaitable[None]]\n    ) -> None:\n        \"\"\"Sets the handler callable that will be used to handle an incoming\n        federation EDU of the given type.\n\n        Args:\n            edu_type: The type of the incoming EDU to register handler for\n            handler: A callable invoked on incoming EDU\n                of the given type. The arguments are the origin server name and\n                the EDU contents.\n        \"\"\"\n        if edu_type in self.edu_handlers:\n            raise KeyError(\"Already have an EDU handler for %s\" % (edu_type,))\n\n        logger.info(\"Registering federation EDU handler for %r\", edu_type)\n\n        self.edu_handlers[edu_type] = handler\n\n    def register_query_handler(\n        self, query_type: str, handler: Callable[[dict], Awaitable[JsonDict]]\n    ) -> None:\n        \"\"\"Sets the handler callable that will be used to handle an incoming\n        federation query of the given type.\n\n        Args:\n            query_type: Category name of the query, which should match\n                the string used by make_query.\n            handler: Invoked to handle\n                incoming queries of this type. The return will be yielded\n                on and the result used as the response to the query request.\n        \"\"\"\n        if query_type in self.query_handlers:\n            raise KeyError(\"Already have a Query handler for %s\" % (query_type,))\n\n        logger.info(\"Registering federation query handler for %r\", query_type)\n\n        self.query_handlers[query_type] = handler\n\n    def register_instances_for_edu(\n        self, edu_type: str, instance_names: List[str]\n    ) -> None:\n        \"\"\"Register that the EDU handler is on multiple instances.\"\"\"\n        self._edu_type_to_instance[edu_type] = instance_names\n\n    async def on_edu(self, edu_type: str, origin: str, content: dict) -> None:\n        if not self.config.server.use_presence and edu_type == EduTypes.PRESENCE:\n            return\n\n        # Check if we have a handler on this instance\n        handler = self.edu_handlers.get(edu_type)\n        if handler:\n            with start_active_span_from_edu(content, \"handle_edu\"):\n                try:\n                    await handler(origin, content)\n                except SynapseError as e:\n                    logger.info(\"Failed to handle edu %r: %r\", edu_type, e)\n                except Exception:\n                    logger.exception(\"Failed to handle edu %r\", edu_type)\n            return\n\n        # Check if we can route it somewhere else that isn't us\n        instances = self._edu_type_to_instance.get(edu_type, [\"master\"])\n        if self._instance_name not in instances:\n            # Pick an instance randomly so that we don't overload one.\n            route_to = random.choice(instances)\n\n            try:\n                await self._send_edu(\n                    instance_name=route_to,\n                    edu_type=edu_type,\n                    origin=origin,\n                    content=content,\n                )\n            except SynapseError as e:\n                logger.info(\"Failed to handle edu %r: %r\", edu_type, e)\n            except Exception:\n                logger.exception(\"Failed to handle edu %r\", edu_type)\n            return\n\n        # Oh well, let's just log and move on.\n        logger.warning(\"No handler registered for EDU type %s\", edu_type)\n\n    async def on_query(self, query_type: str, args: dict) -> JsonDict:\n        handler = self.query_handlers.get(query_type)\n        if handler:\n            return await handler(args)\n\n        # Check if we can route it somewhere else that isn't us\n        if self._instance_name == \"master\":\n            return await self._get_query_client(query_type=query_type, args=args)\n\n        # Uh oh, no handler! Let's raise an exception so the request returns an\n        # error.\n        logger.warning(\"No handler registered for query type %s\", query_type)\n        raise NotFoundError(\"No handler for Query type '%s'\" % (query_type,))\n\n\ndef _get_event_ids_for_partial_state_join(\n    join_event: EventBase,\n    prev_state_ids: StateMap[str],\n    summary: Mapping[str, MemberSummary],\n) -> Collection[str]:\n    \"\"\"Calculate state to be returned in a partial_state send_join\n\n    Args:\n        join_event: the join event being send_joined\n        prev_state_ids: the event ids of the state before the join\n\n    Returns:\n        the event ids to be returned\n    \"\"\"\n\n    # return all non-member events\n    state_event_ids = {\n        event_id\n        for (event_type, state_key), event_id in prev_state_ids.items()\n        if event_type != EventTypes.Member\n    }\n\n    # we also need the current state of the current user (it's going to\n    # be an auth event for the new join, so we may as well return it)\n    current_membership_event_id = prev_state_ids.get(\n        (EventTypes.Member, join_event.state_key)\n    )\n    if current_membership_event_id is not None:\n        state_event_ids.add(current_membership_event_id)\n\n    name_id = prev_state_ids.get((EventTypes.Name, \"\"))\n    canonical_alias_id = prev_state_ids.get((EventTypes.CanonicalAlias, \"\"))\n    if not name_id and not canonical_alias_id:\n        # Also include the hero members of the room (for DM rooms without a title).\n        # To do this properly, we should select the correct subset of membership events\n        # from `prev_state_ids`. Instead, we are lazier and use the (cached)\n        # `get_room_summary` function, which is based on the current state of the room.\n        # This introduces races; we choose to ignore them because a) they should be rare\n        # and b) even if it's wrong, joining servers will get the full state eventually.\n        heroes = extract_heroes_from_room_summary(summary, join_event.state_key)\n        for hero in heroes:\n            membership_event_id = prev_state_ids.get((EventTypes.Member, hero))\n            if membership_event_id:\n                state_event_ids.add(membership_event_id)\n\n    return state_event_ids\n", "# Copyright 2016 OpenMarket Ltd\n# Copyright 2019 New Vector Ltd\n# Copyright 2019,2020 The Matrix.org Foundation C.I.C.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport logging\nfrom typing import TYPE_CHECKING, Dict, Iterable, List, Mapping, Optional, Set, Tuple\n\nfrom synapse.api import errors\nfrom synapse.api.constants import EduTypes, EventTypes\nfrom synapse.api.errors import (\n    Codes,\n    FederationDeniedError,\n    HttpResponseException,\n    InvalidAPICallError,\n    RequestSendFailed,\n    SynapseError,\n)\nfrom synapse.logging.opentracing import log_kv, set_tag, trace\nfrom synapse.metrics.background_process_metrics import (\n    run_as_background_process,\n    wrap_as_background_process,\n)\nfrom synapse.storage.databases.main.client_ips import DeviceLastConnectionInfo\nfrom synapse.types import (\n    JsonDict,\n    JsonMapping,\n    ScheduledTask,\n    StrCollection,\n    StreamKeyType,\n    StreamToken,\n    TaskStatus,\n    UserID,\n    get_domain_from_id,\n    get_verify_key_from_cross_signing_key,\n)\nfrom synapse.util import stringutils\nfrom synapse.util.async_helpers import Linearizer\nfrom synapse.util.caches.expiringcache import ExpiringCache\nfrom synapse.util.cancellation import cancellable\nfrom synapse.util.metrics import measure_func\nfrom synapse.util.retryutils import (\n    NotRetryingDestination,\n    filter_destinations_by_retry_limiter,\n)\n\nif TYPE_CHECKING:\n    from synapse.server import HomeServer\n\nlogger = logging.getLogger(__name__)\n\nDELETE_DEVICE_MSGS_TASK_NAME = \"delete_device_messages\"\nMAX_DEVICE_DISPLAY_NAME_LEN = 100\nDELETE_STALE_DEVICES_INTERVAL_MS = 24 * 60 * 60 * 1000\n\n\nclass DeviceWorkerHandler:\n    device_list_updater: \"DeviceListWorkerUpdater\"\n\n    def __init__(self, hs: \"HomeServer\"):\n        self.clock = hs.get_clock()\n        self.hs = hs\n        self.store = hs.get_datastores().main\n        self.notifier = hs.get_notifier()\n        self.state = hs.get_state_handler()\n        self._appservice_handler = hs.get_application_service_handler()\n        self._state_storage = hs.get_storage_controllers().state\n        self._auth_handler = hs.get_auth_handler()\n        self._event_sources = hs.get_event_sources()\n        self.server_name = hs.hostname\n        self._msc3852_enabled = hs.config.experimental.msc3852_enabled\n        self._query_appservices_for_keys = (\n            hs.config.experimental.msc3984_appservice_key_query\n        )\n        self._task_scheduler = hs.get_task_scheduler()\n\n        self.device_list_updater = DeviceListWorkerUpdater(hs)\n\n        self._task_scheduler.register_action(\n            self._delete_device_messages, DELETE_DEVICE_MSGS_TASK_NAME\n        )\n\n    @trace\n    async def get_devices_by_user(self, user_id: str) -> List[JsonDict]:\n        \"\"\"\n        Retrieve the given user's devices\n\n        Args:\n            user_id: The user ID to query for devices.\n        Returns:\n            info on each device\n        \"\"\"\n\n        set_tag(\"user_id\", user_id)\n        device_map = await self.store.get_devices_by_user(user_id)\n\n        ips = await self.store.get_last_client_ip_by_device(user_id, device_id=None)\n\n        devices = list(device_map.values())\n        for device in devices:\n            _update_device_from_client_ips(device, ips)\n\n        log_kv(device_map)\n        return devices\n\n    async def get_dehydrated_device(\n        self, user_id: str\n    ) -> Optional[Tuple[str, JsonDict]]:\n        \"\"\"Retrieve the information for a dehydrated device.\n\n        Args:\n            user_id: the user whose dehydrated device we are looking for\n        Returns:\n            a tuple whose first item is the device ID, and the second item is\n            the dehydrated device information\n        \"\"\"\n        return await self.store.get_dehydrated_device(user_id)\n\n    @trace\n    async def get_device(self, user_id: str, device_id: str) -> JsonDict:\n        \"\"\"Retrieve the given device\n\n        Args:\n            user_id: The user to get the device from\n            device_id: The device to fetch.\n\n        Returns:\n            info on the device\n        Raises:\n            errors.NotFoundError: if the device was not found\n        \"\"\"\n        device = await self.store.get_device(user_id, device_id)\n        if device is None:\n            raise errors.NotFoundError()\n\n        ips = await self.store.get_last_client_ip_by_device(user_id, device_id)\n        _update_device_from_client_ips(device, ips)\n\n        set_tag(\"device\", str(device))\n        set_tag(\"ips\", str(ips))\n\n        return device\n\n    @cancellable\n    async def get_device_changes_in_shared_rooms(\n        self, user_id: str, room_ids: StrCollection, from_token: StreamToken\n    ) -> Set[str]:\n        \"\"\"Get the set of users whose devices have changed who share a room with\n        the given user.\n        \"\"\"\n        changed_users = await self.store.get_device_list_changes_in_rooms(\n            room_ids, from_token.device_list_key\n        )\n\n        if changed_users is not None:\n            # We also check if the given user has changed their device. If\n            # they're in no rooms then the above query won't include them.\n            changed = await self.store.get_users_whose_devices_changed(\n                from_token.device_list_key, [user_id]\n            )\n            changed_users.update(changed)\n            return changed_users\n\n        # If the DB returned None then the `from_token` is too old, so we fall\n        # back on looking for device updates for all users.\n\n        users_who_share_room = await self.store.get_users_who_share_room_with_user(\n            user_id\n        )\n\n        tracked_users = set(users_who_share_room)\n\n        # Always tell the user about their own devices\n        tracked_users.add(user_id)\n\n        changed = await self.store.get_users_whose_devices_changed(\n            from_token.device_list_key, tracked_users\n        )\n\n        return changed\n\n    @trace\n    @measure_func(\"device.get_user_ids_changed\")\n    @cancellable\n    async def get_user_ids_changed(\n        self, user_id: str, from_token: StreamToken\n    ) -> JsonDict:\n        \"\"\"Get list of users that have had the devices updated, or have newly\n        joined a room, that `user_id` may be interested in.\n        \"\"\"\n\n        set_tag(\"user_id\", user_id)\n        set_tag(\"from_token\", str(from_token))\n        now_room_key = self.store.get_room_max_token()\n\n        room_ids = await self.store.get_rooms_for_user(user_id)\n\n        changed = await self.get_device_changes_in_shared_rooms(\n            user_id, room_ids, from_token\n        )\n\n        # Then work out if any users have since joined\n        rooms_changed = self.store.get_rooms_that_changed(room_ids, from_token.room_key)\n\n        member_events = await self.store.get_membership_changes_for_user(\n            user_id, from_token.room_key, now_room_key\n        )\n        rooms_changed.update(event.room_id for event in member_events)\n\n        stream_ordering = from_token.room_key.stream\n\n        possibly_changed = set(changed)\n        possibly_left = set()\n        for room_id in rooms_changed:\n            # Check if the forward extremities have changed. If not then we know\n            # the current state won't have changed, and so we can skip this room.\n            try:\n                if not await self.store.have_room_forward_extremities_changed_since(\n                    room_id, stream_ordering\n                ):\n                    continue\n            except errors.StoreError:\n                pass\n\n            current_state_ids = await self._state_storage.get_current_state_ids(\n                room_id, await_full_state=False\n            )\n\n            # The user may have left the room\n            # TODO: Check if they actually did or if we were just invited.\n            if room_id not in room_ids:\n                for etype, state_key in current_state_ids.keys():\n                    if etype != EventTypes.Member:\n                        continue\n                    possibly_left.add(state_key)\n                continue\n\n            # Fetch the current state at the time.\n            try:\n                event_ids = await self.store.get_forward_extremities_for_room_at_stream_ordering(\n                    room_id, stream_ordering=stream_ordering\n                )\n            except errors.StoreError:\n                # we have purged the stream_ordering index since the stream\n                # ordering: treat it the same as a new room\n                event_ids = []\n\n            # special-case for an empty prev state: include all members\n            # in the changed list\n            if not event_ids:\n                log_kv(\n                    {\"event\": \"encountered empty previous state\", \"room_id\": room_id}\n                )\n                for etype, state_key in current_state_ids.keys():\n                    if etype != EventTypes.Member:\n                        continue\n                    possibly_changed.add(state_key)\n                continue\n\n            current_member_id = current_state_ids.get((EventTypes.Member, user_id))\n            if not current_member_id:\n                continue\n\n            # mapping from event_id -> state_dict\n            prev_state_ids = await self._state_storage.get_state_ids_for_events(\n                event_ids,\n                await_full_state=False,\n            )\n\n            # Check if we've joined the room? If so we just blindly add all the users to\n            # the \"possibly changed\" users.\n            for state_dict in prev_state_ids.values():\n                member_event = state_dict.get((EventTypes.Member, user_id), None)\n                if not member_event or member_event != current_member_id:\n                    for etype, state_key in current_state_ids.keys():\n                        if etype != EventTypes.Member:\n                            continue\n                        possibly_changed.add(state_key)\n                    break\n\n            # If there has been any change in membership, include them in the\n            # possibly changed list. We'll check if they are joined below,\n            # and we're not toooo worried about spuriously adding users.\n            for key, event_id in current_state_ids.items():\n                etype, state_key = key\n                if etype != EventTypes.Member:\n                    continue\n\n                # check if this member has changed since any of the extremities\n                # at the stream_ordering, and add them to the list if so.\n                for state_dict in prev_state_ids.values():\n                    prev_event_id = state_dict.get(key, None)\n                    if not prev_event_id or prev_event_id != event_id:\n                        if state_key != user_id:\n                            possibly_changed.add(state_key)\n                        break\n\n        if possibly_changed or possibly_left:\n            possibly_joined = possibly_changed\n            possibly_left = possibly_changed | possibly_left\n\n            # Double check if we still share rooms with the given user.\n            users_rooms = await self.store.get_rooms_for_users(possibly_left)\n            for changed_user_id, entries in users_rooms.items():\n                if any(rid in room_ids for rid in entries):\n                    possibly_left.discard(changed_user_id)\n                else:\n                    possibly_joined.discard(changed_user_id)\n\n        else:\n            possibly_joined = set()\n            possibly_left = set()\n\n        result = {\"changed\": list(possibly_joined), \"left\": list(possibly_left)}\n\n        log_kv(result)\n\n        return result\n\n    async def on_federation_query_user_devices(self, user_id: str) -> JsonDict:\n        stream_id, devices = await self.store.get_e2e_device_keys_for_federation_query(\n            user_id\n        )\n        master_key = await self.store.get_e2e_cross_signing_key(user_id, \"master\")\n        self_signing_key = await self.store.get_e2e_cross_signing_key(\n            user_id, \"self_signing\"\n        )\n\n        # Check if the application services have any results.\n        if self._query_appservices_for_keys:\n            # Query the appservice for all devices for this user.\n            query: Dict[str, Optional[List[str]]] = {user_id: None}\n\n            # Query the appservices for any keys.\n            appservice_results = await self._appservice_handler.query_keys(query)\n\n            # Merge results, overriding anything from the database.\n            appservice_devices = appservice_results.get(\"device_keys\", {}).get(\n                user_id, {}\n            )\n\n            # Filter the database results to only those devices that the appservice has\n            # *not* responded with.\n            devices = [d for d in devices if d[\"device_id\"] not in appservice_devices]\n            # Append the appservice response by wrapping each result in another dictionary.\n            devices.extend(\n                {\"device_id\": device_id, \"keys\": device}\n                for device_id, device in appservice_devices.items()\n            )\n\n            # TODO Handle cross-signing keys.\n\n        return {\n            \"user_id\": user_id,\n            \"stream_id\": stream_id,\n            \"devices\": devices,\n            \"master_key\": master_key,\n            \"self_signing_key\": self_signing_key,\n        }\n\n    async def handle_room_un_partial_stated(self, room_id: str) -> None:\n        \"\"\"Handles sending appropriate device list updates in a room that has\n        gone from partial to full state.\n        \"\"\"\n\n        # TODO(faster_joins): worker mode support\n        #   https://github.com/matrix-org/synapse/issues/12994\n        logger.error(\n            \"Trying handling device list state for partial join: not supported on workers.\"\n        )\n\n    DEVICE_MSGS_DELETE_BATCH_LIMIT = 1000\n    DEVICE_MSGS_DELETE_SLEEP_MS = 1000\n\n    async def _delete_device_messages(\n        self,\n        task: ScheduledTask,\n    ) -> Tuple[TaskStatus, Optional[JsonMapping], Optional[str]]:\n        \"\"\"Scheduler task to delete device messages in batch of `DEVICE_MSGS_DELETE_BATCH_LIMIT`.\"\"\"\n        assert task.params is not None\n        user_id = task.params[\"user_id\"]\n        device_id = task.params[\"device_id\"]\n        up_to_stream_id = task.params[\"up_to_stream_id\"]\n\n        # Delete the messages in batches to avoid too much DB load.\n        while True:\n            res = await self.store.delete_messages_for_device(\n                user_id=user_id,\n                device_id=device_id,\n                up_to_stream_id=up_to_stream_id,\n                limit=DeviceHandler.DEVICE_MSGS_DELETE_BATCH_LIMIT,\n            )\n\n            if res < DeviceHandler.DEVICE_MSGS_DELETE_BATCH_LIMIT:\n                return TaskStatus.COMPLETE, None, None\n\n            await self.clock.sleep(DeviceHandler.DEVICE_MSGS_DELETE_SLEEP_MS / 1000.0)\n\n\nclass DeviceHandler(DeviceWorkerHandler):\n    device_list_updater: \"DeviceListUpdater\"\n\n    def __init__(self, hs: \"HomeServer\"):\n        super().__init__(hs)\n\n        self.federation_sender = hs.get_federation_sender()\n        self._account_data_handler = hs.get_account_data_handler()\n        self._storage_controllers = hs.get_storage_controllers()\n        self.db_pool = hs.get_datastores().main.db_pool\n\n        self.device_list_updater = DeviceListUpdater(hs, self)\n\n        federation_registry = hs.get_federation_registry()\n\n        federation_registry.register_edu_handler(\n            EduTypes.DEVICE_LIST_UPDATE,\n            self.device_list_updater.incoming_device_list_update,\n        )\n\n        # Whether `_handle_new_device_update_async` is currently processing.\n        self._handle_new_device_update_is_processing = False\n\n        # If a new device update may have happened while the loop was\n        # processing.\n        self._handle_new_device_update_new_data = False\n\n        # On start up check if there are any updates pending.\n        hs.get_reactor().callWhenRunning(self._handle_new_device_update_async)\n\n        self._delete_stale_devices_after = hs.config.server.delete_stale_devices_after\n\n        # Ideally we would run this on a worker and condition this on the\n        # \"run_background_tasks_on\" setting, but this would mean making the notification\n        # of device list changes over federation work on workers, which is nontrivial.\n        if self._delete_stale_devices_after is not None:\n            self.clock.looping_call(\n                run_as_background_process,\n                DELETE_STALE_DEVICES_INTERVAL_MS,\n                \"delete_stale_devices\",\n                self._delete_stale_devices,\n            )\n\n    def _check_device_name_length(self, name: Optional[str]) -> None:\n        \"\"\"\n        Checks whether a device name is longer than the maximum allowed length.\n\n        Args:\n            name: The name of the device.\n\n        Raises:\n            SynapseError: if the device name is too long.\n        \"\"\"\n        if name and len(name) > MAX_DEVICE_DISPLAY_NAME_LEN:\n            raise SynapseError(\n                400,\n                \"Device display name is too long (max %i)\"\n                % (MAX_DEVICE_DISPLAY_NAME_LEN,),\n                errcode=Codes.TOO_LARGE,\n            )\n\n    async def check_device_registered(\n        self,\n        user_id: str,\n        device_id: Optional[str],\n        initial_device_display_name: Optional[str] = None,\n        auth_provider_id: Optional[str] = None,\n        auth_provider_session_id: Optional[str] = None,\n    ) -> str:\n        \"\"\"\n        If the given device has not been registered, register it with the\n        supplied display name.\n\n        If no device_id is supplied, we make one up.\n\n        Args:\n            user_id:  @user:id\n            device_id: device id supplied by client\n            initial_device_display_name: device display name from client\n            auth_provider_id: The SSO IdP the user used, if any.\n            auth_provider_session_id: The session ID (sid) got from the SSO IdP.\n        Returns:\n            device id (generated if none was supplied)\n        \"\"\"\n\n        self._check_device_name_length(initial_device_display_name)\n\n        if device_id is not None:\n            new_device = await self.store.store_device(\n                user_id=user_id,\n                device_id=device_id,\n                initial_device_display_name=initial_device_display_name,\n                auth_provider_id=auth_provider_id,\n                auth_provider_session_id=auth_provider_session_id,\n            )\n            if new_device:\n                await self.notify_device_update(user_id, [device_id])\n            return device_id\n\n        # if the device id is not specified, we'll autogen one, but loop a few\n        # times in case of a clash.\n        attempts = 0\n        while attempts < 5:\n            new_device_id = stringutils.random_string(10).upper()\n            new_device = await self.store.store_device(\n                user_id=user_id,\n                device_id=new_device_id,\n                initial_device_display_name=initial_device_display_name,\n                auth_provider_id=auth_provider_id,\n                auth_provider_session_id=auth_provider_session_id,\n            )\n            if new_device:\n                await self.notify_device_update(user_id, [new_device_id])\n                return new_device_id\n            attempts += 1\n\n        raise errors.StoreError(500, \"Couldn't generate a device ID.\")\n\n    async def _delete_stale_devices(self) -> None:\n        \"\"\"Background task that deletes devices which haven't been accessed for more than\n        a configured time period.\n        \"\"\"\n        # We should only be running this job if the config option is defined.\n        assert self._delete_stale_devices_after is not None\n        now_ms = self.clock.time_msec()\n        since_ms = now_ms - self._delete_stale_devices_after\n        devices = await self.store.get_local_devices_not_accessed_since(since_ms)\n\n        for user_id, user_devices in devices.items():\n            await self.delete_devices(user_id, user_devices)\n\n    @trace\n    async def delete_all_devices_for_user(\n        self, user_id: str, except_device_id: Optional[str] = None\n    ) -> None:\n        \"\"\"Delete all of the user's devices\n\n        Args:\n            user_id: The user to remove all devices from\n            except_device_id: optional device id which should not be deleted\n        \"\"\"\n        device_map = await self.store.get_devices_by_user(user_id)\n        device_ids = list(device_map)\n        if except_device_id is not None:\n            device_ids = [d for d in device_ids if d != except_device_id]\n        await self.delete_devices(user_id, device_ids)\n\n    async def delete_devices(self, user_id: str, device_ids: List[str]) -> None:\n        \"\"\"Delete several devices\n\n        Args:\n            user_id: The user to delete devices from.\n            device_ids: The list of device IDs to delete\n        \"\"\"\n        to_device_stream_id = self._event_sources.get_current_token().to_device_key\n\n        try:\n            await self.store.delete_devices(user_id, device_ids)\n        except errors.StoreError as e:\n            if e.code == 404:\n                # no match\n                set_tag(\"error\", True)\n                set_tag(\"reason\", \"User doesn't have that device id.\")\n            else:\n                raise\n\n        # Delete data specific to each device. Not optimised as it is not\n        # considered as part of a critical path.\n        for device_id in device_ids:\n            await self._auth_handler.delete_access_tokens_for_user(\n                user_id, device_id=device_id\n            )\n            await self.store.delete_e2e_keys_by_device(\n                user_id=user_id, device_id=device_id\n            )\n\n            if self.hs.config.experimental.msc3890_enabled:\n                # Remove any local notification settings for this device in accordance\n                # with MSC3890.\n                await self._account_data_handler.remove_account_data_for_user(\n                    user_id,\n                    f\"org.matrix.msc3890.local_notification_settings.{device_id}\",\n                )\n\n            # Delete device messages asynchronously and in batches using the task scheduler\n            await self._task_scheduler.schedule_task(\n                DELETE_DEVICE_MSGS_TASK_NAME,\n                resource_id=device_id,\n                params={\n                    \"user_id\": user_id,\n                    \"device_id\": device_id,\n                    \"up_to_stream_id\": to_device_stream_id,\n                },\n            )\n\n        # Pushers are deleted after `delete_access_tokens_for_user` is called so that\n        # modules using `on_logged_out` hook can use them if needed.\n        await self.hs.get_pusherpool().remove_pushers_by_devices(user_id, device_ids)\n\n        await self.notify_device_update(user_id, device_ids)\n\n    async def update_device(self, user_id: str, device_id: str, content: dict) -> None:\n        \"\"\"Update the given device\n\n        Args:\n            user_id: The user to update devices of.\n            device_id: The device to update.\n            content: body of update request\n        \"\"\"\n\n        # Reject a new displayname which is too long.\n        new_display_name = content.get(\"display_name\")\n\n        self._check_device_name_length(new_display_name)\n\n        try:\n            await self.store.update_device(\n                user_id, device_id, new_display_name=new_display_name\n            )\n            await self.notify_device_update(user_id, [device_id])\n        except errors.StoreError as e:\n            if e.code == 404:\n                raise errors.NotFoundError()\n            else:\n                raise\n\n    @trace\n    @measure_func(\"notify_device_update\")\n    async def notify_device_update(\n        self, user_id: str, device_ids: StrCollection\n    ) -> None:\n        \"\"\"Notify that a user's device(s) has changed. Pokes the notifier, and\n        remote servers if the user is local.\n\n        Args:\n            user_id: The Matrix ID of the user who's device list has been updated.\n            device_ids: The device IDs that have changed.\n        \"\"\"\n        if not device_ids:\n            # No changes to notify about, so this is a no-op.\n            return\n\n        room_ids = await self.store.get_rooms_for_user(user_id)\n\n        position = await self.store.add_device_change_to_streams(\n            user_id,\n            device_ids,\n            room_ids=room_ids,\n        )\n\n        if not position:\n            # This should only happen if there are no updates, so we bail.\n            return\n\n        for device_id in device_ids:\n            logger.debug(\n                \"Notifying about update %r/%r, ID: %r\", user_id, device_id, position\n            )\n\n        # specify the user ID too since the user should always get their own device list\n        # updates, even if they aren't in any rooms.\n        self.notifier.on_new_event(\n            StreamKeyType.DEVICE_LIST, position, users={user_id}, rooms=room_ids\n        )\n\n        # We may need to do some processing asynchronously for local user IDs.\n        if self.hs.is_mine_id(user_id):\n            self._handle_new_device_update_async()\n\n    async def notify_user_signature_update(\n        self, from_user_id: str, user_ids: List[str]\n    ) -> None:\n        \"\"\"Notify a user that they have made new signatures of other users.\n\n        Args:\n            from_user_id: the user who made the signature\n            user_ids: the users IDs that have new signatures\n        \"\"\"\n\n        position = await self.store.add_user_signature_change_to_streams(\n            from_user_id, user_ids\n        )\n\n        self.notifier.on_new_event(\n            StreamKeyType.DEVICE_LIST, position, users=[from_user_id]\n        )\n\n    async def store_dehydrated_device(\n        self,\n        user_id: str,\n        device_id: Optional[str],\n        device_data: JsonDict,\n        initial_device_display_name: Optional[str] = None,\n        keys_for_device: Optional[JsonDict] = None,\n    ) -> str:\n        \"\"\"Store a dehydrated device for a user, optionally storing the keys associated with\n        it as well.  If the user had a previous dehydrated device, it is removed.\n\n        Args:\n            user_id: the user that we are storing the device for\n            device_id: device id supplied by client\n            device_data: the dehydrated device information\n            initial_device_display_name: The display name to use for the device\n            keys_for_device: keys for the dehydrated device\n        Returns:\n            device id of the dehydrated device\n        \"\"\"\n        device_id = await self.check_device_registered(\n            user_id,\n            device_id,\n            initial_device_display_name,\n        )\n\n        time_now = self.clock.time_msec()\n\n        old_device_id = await self.store.store_dehydrated_device(\n            user_id, device_id, device_data, time_now, keys_for_device\n        )\n\n        if old_device_id is not None:\n            await self.delete_devices(user_id, [old_device_id])\n\n        return device_id\n\n    async def rehydrate_device(\n        self, user_id: str, access_token: str, device_id: str\n    ) -> dict:\n        \"\"\"Process a rehydration request from the user.\n\n        Args:\n            user_id: the user who is rehydrating the device\n            access_token: the access token used for the request\n            device_id: the ID of the device that will be rehydrated\n        Returns:\n            a dict containing {\"success\": True}\n        \"\"\"\n        success = await self.store.remove_dehydrated_device(user_id, device_id)\n\n        if not success:\n            raise errors.NotFoundError()\n\n        # If the dehydrated device was successfully deleted (the device ID\n        # matched the stored dehydrated device), then modify the access\n        # token and refresh token to use the dehydrated device's ID and\n        # copy the old device display name to the dehydrated device,\n        # and destroy the old device ID\n        old_device_id = await self.store.set_device_for_access_token(\n            access_token, device_id\n        )\n        await self.store.set_device_for_refresh_token(user_id, old_device_id, device_id)\n        old_device = await self.store.get_device(user_id, old_device_id)\n        if old_device is None:\n            raise errors.NotFoundError()\n        await self.store.update_device(user_id, device_id, old_device[\"display_name\"])\n        # can't call self.delete_device because that will clobber the\n        # access token so call the storage layer directly\n        await self.store.delete_devices(user_id, [old_device_id])\n        await self.store.delete_e2e_keys_by_device(\n            user_id=user_id, device_id=old_device_id\n        )\n\n        # tell everyone that the old device is gone and that the dehydrated\n        # device has a new display name\n        await self.notify_device_update(user_id, [old_device_id, device_id])\n\n        return {\"success\": True}\n\n    async def delete_dehydrated_device(self, user_id: str, device_id: str) -> None:\n        \"\"\"\n        Delete a stored dehydrated device.\n\n        Args:\n            user_id: the user_id to delete the device from\n            device_id: id of the dehydrated device to delete\n        \"\"\"\n        success = await self.store.remove_dehydrated_device(user_id, device_id)\n\n        if not success:\n            raise errors.NotFoundError()\n\n        await self.delete_devices(user_id, [device_id])\n        await self.store.delete_e2e_keys_by_device(user_id=user_id, device_id=device_id)\n\n    @wrap_as_background_process(\"_handle_new_device_update_async\")\n    async def _handle_new_device_update_async(self) -> None:\n        \"\"\"Called when we have a new local device list update that we need to\n        send out over federation.\n\n        This happens in the background so as not to block the original request\n        that generated the device update.\n        \"\"\"\n        if self._handle_new_device_update_is_processing:\n            self._handle_new_device_update_new_data = True\n            return\n\n        self._handle_new_device_update_is_processing = True\n\n        # The stream ID we processed previous iteration (if any), and the set of\n        # hosts we've already poked about for this update. This is so that we\n        # don't poke the same remote server about the same update repeatedly.\n        current_stream_id = None\n        hosts_already_sent_to: Set[str] = set()\n\n        try:\n            stream_id, room_id = await self.store.get_device_change_last_converted_pos()\n\n            while True:\n                self._handle_new_device_update_new_data = False\n                max_stream_id = self.store.get_device_stream_token()\n                rows = await self.store.get_uncoverted_outbound_room_pokes(\n                    stream_id, room_id\n                )\n                if not rows:\n                    # If the DB returned nothing then there is nothing left to\n                    # do, *unless* a new device list update happened during the\n                    # DB query.\n\n                    # Advance `(stream_id, room_id)`.\n                    # `max_stream_id` comes from *before* the query for unconverted\n                    # rows, which means that any unconverted rows must have a larger\n                    # stream ID.\n                    if max_stream_id > stream_id:\n                        stream_id, room_id = max_stream_id, \"\"\n                        await self.store.set_device_change_last_converted_pos(\n                            stream_id, room_id\n                        )\n                    else:\n                        assert max_stream_id == stream_id\n                        # Avoid moving `room_id` backwards.\n\n                    if self._handle_new_device_update_new_data:\n                        continue\n                    else:\n                        return\n\n                for user_id, device_id, room_id, stream_id, opentracing_context in rows:\n                    hosts = set()\n\n                    # Ignore any users that aren't ours\n                    if self.hs.is_mine_id(user_id):\n                        hosts = set(\n                            await self._storage_controllers.state.get_current_hosts_in_room_or_partial_state_approximation(\n                                room_id\n                            )\n                        )\n                        hosts.discard(self.server_name)\n                        # For rooms with partial state, `hosts` is merely an\n                        # approximation. When we transition to a full state room, we\n                        # will have to send out device list updates to any servers we\n                        # missed.\n\n                    # Check if we've already sent this update to some hosts\n                    if current_stream_id == stream_id:\n                        hosts -= hosts_already_sent_to\n\n                    await self.store.add_device_list_outbound_pokes(\n                        user_id=user_id,\n                        device_id=device_id,\n                        room_id=room_id,\n                        hosts=hosts,\n                        context=opentracing_context,\n                    )\n\n                    # Notify replication that we've updated the device list stream.\n                    self.notifier.notify_replication()\n\n                    if hosts:\n                        logger.info(\n                            \"Sending device list update notif for %r to: %r\",\n                            user_id,\n                            hosts,\n                        )\n                        await self.federation_sender.send_device_messages(\n                            hosts, immediate=False\n                        )\n                        # TODO: when called, this isn't in a logging context.\n                        # This leads to log spam, sentry event spam, and massive\n                        # memory usage.\n                        # See https://github.com/matrix-org/synapse/issues/12552.\n                        # log_kv(\n                        #     {\"message\": \"sent device update to host\", \"host\": host}\n                        # )\n\n                    if current_stream_id != stream_id:\n                        # Clear the set of hosts we've already sent to as we're\n                        # processing a new update.\n                        hosts_already_sent_to.clear()\n\n                    hosts_already_sent_to.update(hosts)\n                    current_stream_id = stream_id\n\n                # Advance `(stream_id, room_id)`.\n                _, _, room_id, stream_id, _ = rows[-1]\n                await self.store.set_device_change_last_converted_pos(\n                    stream_id, room_id\n                )\n\n        finally:\n            self._handle_new_device_update_is_processing = False\n\n    async def handle_room_un_partial_stated(self, room_id: str) -> None:\n        \"\"\"Handles sending appropriate device list updates in a room that has\n        gone from partial to full state.\n        \"\"\"\n\n        # We defer to the device list updater to handle pending remote device\n        # list updates.\n        await self.device_list_updater.handle_room_un_partial_stated(room_id)\n\n        # Replay local updates.\n        (\n            join_event_id,\n            device_lists_stream_id,\n        ) = await self.store.get_join_event_id_and_device_lists_stream_id_for_partial_state(\n            room_id\n        )\n\n        # Get the local device list changes that have happened in the room since\n        # we started joining. If there are no updates there's nothing left to do.\n        changes = await self.store.get_device_list_changes_in_room(\n            room_id, device_lists_stream_id\n        )\n        local_changes = {(u, d) for u, d in changes if self.hs.is_mine_id(u)}\n        if not local_changes:\n            return\n\n        # Note: We have persisted the full state at this point, we just haven't\n        # cleared the `partial_room` flag.\n        join_state_ids = await self._state_storage.get_state_ids_for_event(\n            join_event_id, await_full_state=False\n        )\n        current_state_ids = await self.store.get_partial_current_state_ids(room_id)\n\n        # Now we need to work out all servers that might have been in the room\n        # at any point during our join.\n\n        # First we look for any membership states that have changed between the\n        # initial join and now...\n        all_keys = set(join_state_ids)\n        all_keys.update(current_state_ids)\n\n        potentially_changed_hosts = set()\n        for etype, state_key in all_keys:\n            if etype != EventTypes.Member:\n                continue\n\n            prev = join_state_ids.get((etype, state_key))\n            current = current_state_ids.get((etype, state_key))\n\n            if prev != current:\n                potentially_changed_hosts.add(get_domain_from_id(state_key))\n\n        # ... then we add all the hosts that are currently joined to the room...\n        current_hosts_in_room = await self.store.get_current_hosts_in_room(room_id)\n        potentially_changed_hosts.update(current_hosts_in_room)\n\n        # ... and finally we remove any hosts that we were told about, as we\n        # will have sent device list updates to those hosts when they happened.\n        known_hosts_at_join = await self.store.get_partial_state_servers_at_join(\n            room_id\n        )\n        assert known_hosts_at_join is not None\n        potentially_changed_hosts.difference_update(known_hosts_at_join)\n\n        potentially_changed_hosts.discard(self.server_name)\n\n        if not potentially_changed_hosts:\n            # Nothing to do.\n            return\n\n        logger.info(\n            \"Found %d changed hosts to send device list updates to\",\n            len(potentially_changed_hosts),\n        )\n\n        for user_id, device_id in local_changes:\n            await self.store.add_device_list_outbound_pokes(\n                user_id=user_id,\n                device_id=device_id,\n                room_id=room_id,\n                hosts=potentially_changed_hosts,\n                context=None,\n            )\n\n        # Notify things that device lists need to be sent out.\n        self.notifier.notify_replication()\n        await self.federation_sender.send_device_messages(\n            potentially_changed_hosts, immediate=False\n        )\n\n\ndef _update_device_from_client_ips(\n    device: JsonDict, client_ips: Mapping[Tuple[str, str], DeviceLastConnectionInfo]\n) -> None:\n    ip = client_ips.get((device[\"user_id\"], device[\"device_id\"]))\n    device.update(\n        {\n            \"last_seen_user_agent\": ip.user_agent if ip else None,\n            \"last_seen_ts\": ip.last_seen if ip else None,\n            \"last_seen_ip\": ip.ip if ip else None,\n        }\n    )\n\n\nclass DeviceListWorkerUpdater:\n    \"Handles incoming device list updates from federation and contacts the main process over replication\"\n\n    def __init__(self, hs: \"HomeServer\"):\n        from synapse.replication.http.devices import (\n            ReplicationMultiUserDevicesResyncRestServlet,\n        )\n\n        self._multi_user_device_resync_client = (\n            ReplicationMultiUserDevicesResyncRestServlet.make_client(hs)\n        )\n\n    async def multi_user_device_resync(\n        self, user_ids: List[str], mark_failed_as_stale: bool = True\n    ) -> Dict[str, Optional[JsonMapping]]:\n        \"\"\"\n        Like `user_device_resync` but operates on multiple users **from the same origin**\n        at once.\n\n        Returns:\n            Dict from User ID to the same Dict as `user_device_resync`.\n        \"\"\"\n        # mark_failed_as_stale is not sent. Ensure this doesn't break expectations.\n        assert mark_failed_as_stale\n\n        if not user_ids:\n            # Shortcut empty requests\n            return {}\n\n        return await self._multi_user_device_resync_client(user_ids=user_ids)\n\n\nclass DeviceListUpdater(DeviceListWorkerUpdater):\n    \"Handles incoming device list updates from federation and updates the DB\"\n\n    def __init__(self, hs: \"HomeServer\", device_handler: DeviceHandler):\n        self.store = hs.get_datastores().main\n        self.federation = hs.get_federation_client()\n        self.clock = hs.get_clock()\n        self.device_handler = device_handler\n        self._notifier = hs.get_notifier()\n\n        self._remote_edu_linearizer = Linearizer(name=\"remote_device_list\")\n        self._resync_linearizer = Linearizer(name=\"remote_device_resync\")\n\n        # user_id -> list of updates waiting to be handled.\n        self._pending_updates: Dict[\n            str, List[Tuple[str, str, Iterable[str], JsonDict]]\n        ] = {}\n\n        # Recently seen stream ids. We don't bother keeping these in the DB,\n        # but they're useful to have them about to reduce the number of spurious\n        # resyncs.\n        self._seen_updates: ExpiringCache[str, Set[str]] = ExpiringCache(\n            cache_name=\"device_update_edu\",\n            clock=self.clock,\n            max_len=10000,\n            expiry_ms=30 * 60 * 1000,\n            iterable=True,\n        )\n\n        # Attempt to resync out of sync device lists every 30s.\n        self._resync_retry_in_progress = False\n        self.clock.looping_call(\n            run_as_background_process,\n            30 * 1000,\n            func=self._maybe_retry_device_resync,\n            desc=\"_maybe_retry_device_resync\",\n        )\n\n    @trace\n    async def incoming_device_list_update(\n        self, origin: str, edu_content: JsonDict\n    ) -> None:\n        \"\"\"Called on incoming device list update from federation. Responsible\n        for parsing the EDU and adding to pending updates list.\n        \"\"\"\n\n        set_tag(\"origin\", origin)\n        set_tag(\"edu_content\", str(edu_content))\n        user_id = edu_content.pop(\"user_id\")\n        device_id = edu_content.pop(\"device_id\")\n        stream_id = str(edu_content.pop(\"stream_id\"))  # They may come as ints\n        prev_ids = edu_content.pop(\"prev_id\", [])\n        if not isinstance(prev_ids, list):\n            raise SynapseError(\n                400, \"Device list update had an invalid 'prev_ids' field\"\n            )\n        prev_ids = [str(p) for p in prev_ids]  # They may come as ints\n\n        if get_domain_from_id(user_id) != origin:\n            # TODO: Raise?\n            logger.warning(\n                \"Got device list update edu for %r/%r from %r\",\n                user_id,\n                device_id,\n                origin,\n            )\n\n            set_tag(\"error\", True)\n            log_kv(\n                {\n                    \"message\": \"Got a device list update edu from a user and \"\n                    \"device which does not match the origin of the request.\",\n                    \"user_id\": user_id,\n                    \"device_id\": device_id,\n                }\n            )\n            return\n\n        # Check if we are partially joining any rooms. If so we need to store\n        # all device list updates so that we can handle them correctly once we\n        # know who is in the room.\n        # TODO(faster_joins): this fetches and processes a bunch of data that we don't\n        # use. Could be replaced by a tighter query e.g.\n        #   SELECT EXISTS(SELECT 1 FROM partial_state_rooms)\n        partial_rooms = await self.store.get_partial_state_room_resync_info()\n        if partial_rooms:\n            await self.store.add_remote_device_list_to_pending(\n                user_id,\n                device_id,\n            )\n            self._notifier.notify_replication()\n\n        room_ids = await self.store.get_rooms_for_user(user_id)\n        if not room_ids:\n            # We don't share any rooms with this user. Ignore update, as we\n            # probably won't get any further updates.\n            set_tag(\"error\", True)\n            log_kv(\n                {\n                    \"message\": \"Got an update from a user for which \"\n                    \"we don't share any rooms\",\n                    \"other user_id\": user_id,\n                }\n            )\n            logger.warning(\n                \"Got device list update edu for %r/%r, but don't share a room\",\n                user_id,\n                device_id,\n            )\n            return\n\n        logger.debug(\"Received device list update for %r/%r\", user_id, device_id)\n\n        self._pending_updates.setdefault(user_id, []).append(\n            (device_id, stream_id, prev_ids, edu_content)\n        )\n\n        await self._handle_device_updates(user_id)\n\n    @measure_func(\"_incoming_device_list_update\")\n    async def _handle_device_updates(self, user_id: str) -> None:\n        \"Actually handle pending updates.\"\n\n        async with self._remote_edu_linearizer.queue(user_id):\n            pending_updates = self._pending_updates.pop(user_id, [])\n            if not pending_updates:\n                # This can happen since we batch updates\n                return\n\n            for device_id, stream_id, prev_ids, _ in pending_updates:\n                logger.debug(\n                    \"Handling update %r/%r, ID: %r, prev: %r \",\n                    user_id,\n                    device_id,\n                    stream_id,\n                    prev_ids,\n                )\n\n            # Given a list of updates we check if we need to resync. This\n            # happens if we've missed updates.\n            resync = await self._need_to_do_resync(user_id, pending_updates)\n\n            if logger.isEnabledFor(logging.INFO):\n                logger.info(\n                    \"Received device list update for %s, requiring resync: %s. Devices: %s\",\n                    user_id,\n                    resync,\n                    \", \".join(u[0] for u in pending_updates),\n                )\n\n            if resync:\n                # We mark as stale up front in case we get restarted.\n                await self.store.mark_remote_users_device_caches_as_stale([user_id])\n                run_as_background_process(\n                    \"_maybe_retry_device_resync\",\n                    self.multi_user_device_resync,\n                    [user_id],\n                    False,\n                )\n            else:\n                # Simply update the single device, since we know that is the only\n                # change (because of the single prev_id matching the current cache)\n                for device_id, stream_id, _, content in pending_updates:\n                    await self.store.update_remote_device_list_cache_entry(\n                        user_id, device_id, content, stream_id\n                    )\n\n                await self.device_handler.notify_device_update(\n                    user_id, [device_id for device_id, _, _, _ in pending_updates]\n                )\n\n                self._seen_updates.setdefault(user_id, set()).update(\n                    stream_id for _, stream_id, _, _ in pending_updates\n                )\n\n    async def _need_to_do_resync(\n        self, user_id: str, updates: Iterable[Tuple[str, str, Iterable[str], JsonDict]]\n    ) -> bool:\n        \"\"\"Given a list of updates for a user figure out if we need to do a full\n        resync, or whether we have enough data that we can just apply the delta.\n        \"\"\"\n        seen_updates: Set[str] = self._seen_updates.get(user_id, set())\n\n        extremity = await self.store.get_device_list_last_stream_id_for_remote(user_id)\n\n        logger.debug(\"Current extremity for %r: %r\", user_id, extremity)\n\n        stream_id_in_updates = set()  # stream_ids in updates list\n        for _, stream_id, prev_ids, _ in updates:\n            if not prev_ids:\n                # We always do a resync if there are no previous IDs\n                return True\n\n            for prev_id in prev_ids:\n                if prev_id == extremity:\n                    continue\n                elif prev_id in seen_updates:\n                    continue\n                elif prev_id in stream_id_in_updates:\n                    continue\n                else:\n                    return True\n\n            stream_id_in_updates.add(stream_id)\n\n        return False\n\n    @trace\n    async def _maybe_retry_device_resync(self) -> None:\n        \"\"\"Retry to resync device lists that are out of sync, except if another retry is\n        in progress.\n        \"\"\"\n        if self._resync_retry_in_progress:\n            return\n\n        try:\n            # Prevent another call of this function to retry resyncing device lists so\n            # we don't send too many requests.\n            self._resync_retry_in_progress = True\n            # Get all of the users that need resyncing.\n            need_resync = await self.store.get_user_ids_requiring_device_list_resync()\n\n            # Filter out users whose host is marked as \"down\" up front.\n            hosts = await filter_destinations_by_retry_limiter(\n                {get_domain_from_id(u) for u in need_resync}, self.clock, self.store\n            )\n            hosts = set(hosts)\n\n            # Iterate over the set of user IDs.\n            for user_id in need_resync:\n                if get_domain_from_id(user_id) not in hosts:\n                    continue\n\n                try:\n                    # Try to resync the current user's devices list.\n                    result = (await self.multi_user_device_resync([user_id], False))[\n                        user_id\n                    ]\n\n                    # user_device_resync only returns a result if it managed to\n                    # successfully resync and update the database. Updating the table\n                    # of users requiring resync isn't necessary here as\n                    # user_device_resync already does it (through\n                    # self.store.update_remote_device_list_cache).\n                    if result:\n                        logger.debug(\n                            \"Successfully resynced the device list for %s\",\n                            user_id,\n                        )\n                except Exception as e:\n                    # If there was an issue resyncing this user, e.g. if the remote\n                    # server sent a malformed result, just log the error instead of\n                    # aborting all the subsequent resyncs.\n                    logger.debug(\n                        \"Could not resync the device list for %s: %s\",\n                        user_id,\n                        e,\n                    )\n        finally:\n            # Allow future calls to retry resyncinc out of sync device lists.\n            self._resync_retry_in_progress = False\n\n    async def multi_user_device_resync(\n        self, user_ids: List[str], mark_failed_as_stale: bool = True\n    ) -> Dict[str, Optional[JsonMapping]]:\n        \"\"\"\n        Like `user_device_resync` but operates on multiple users **from the same origin**\n        at once.\n\n        Returns:\n            Dict from User ID to the same Dict as `user_device_resync`.\n        \"\"\"\n        if not user_ids:\n            return {}\n\n        origins = {UserID.from_string(user_id).domain for user_id in user_ids}\n\n        if len(origins) != 1:\n            raise InvalidAPICallError(f\"Only one origin permitted, got {origins!r}\")\n\n        result = {}\n        failed = set()\n        # TODO(Perf): Actually batch these up\n        for user_id in user_ids:\n            async with self._resync_linearizer.queue(user_id):\n                (\n                    user_result,\n                    user_failed,\n                ) = await self._user_device_resync_returning_failed(user_id)\n            result[user_id] = user_result\n            if user_failed:\n                failed.add(user_id)\n\n        if mark_failed_as_stale:\n            await self.store.mark_remote_users_device_caches_as_stale(failed)\n\n        return result\n\n    async def _user_device_resync_returning_failed(\n        self, user_id: str\n    ) -> Tuple[Optional[JsonMapping], bool]:\n        \"\"\"Fetches all devices for a user and updates the device cache with them.\n\n        Args:\n            user_id: The user's id whose device_list will be updated.\n        Returns:\n            - A dict with device info as under the \"devices\" in the result of this\n              request:\n              https://matrix.org/docs/spec/server_server/r0.1.2#get-matrix-federation-v1-user-devices-userid\n              None when we weren't able to fetch the device info for some reason,\n              e.g. due to a connection problem.\n            - True iff the resync failed and the device list should be marked as stale.\n        \"\"\"\n        # Check that we haven't gone and fetched the devices since we last\n        # checked if we needed to resync these device lists.\n        if await self.store.get_users_whose_devices_are_cached([user_id]):\n            cached = await self.store.get_cached_devices_for_user(user_id)\n            return cached, False\n\n        logger.debug(\"Attempting to resync the device list for %s\", user_id)\n        log_kv({\"message\": \"Doing resync to update device list.\"})\n        # Fetch all devices for the user.\n        origin = get_domain_from_id(user_id)\n        try:\n            result = await self.federation.query_user_devices(origin, user_id)\n        except NotRetryingDestination:\n            return None, True\n        except (RequestSendFailed, HttpResponseException) as e:\n            logger.warning(\n                \"Failed to handle device list update for %s: %s\",\n                user_id,\n                e,\n            )\n\n            # We abort on exceptions rather than accepting the update\n            # as otherwise synapse will 'forget' that its device list\n            # is out of date. If we bail then we will retry the resync\n            # next time we get a device list update for this user_id.\n            # This makes it more likely that the device lists will\n            # eventually become consistent.\n            return None, True\n        except FederationDeniedError as e:\n            set_tag(\"error\", True)\n            log_kv({\"reason\": \"FederationDeniedError\"})\n            logger.info(e)\n            return None, False\n        except Exception as e:\n            set_tag(\"error\", True)\n            log_kv(\n                {\"message\": \"Exception raised by federation request\", \"exception\": e}\n            )\n            logger.exception(\"Failed to handle device list update for %s\", user_id)\n\n            return None, True\n        log_kv({\"result\": result})\n        stream_id = result[\"stream_id\"]\n        devices = result[\"devices\"]\n\n        # Get the master key and the self-signing key for this user if provided in the\n        # response (None if not in the response).\n        # The response will not contain the user signing key, as this key is only used by\n        # its owner, thus it doesn't make sense to send it over federation.\n        master_key = result.get(\"master_key\")\n        self_signing_key = result.get(\"self_signing_key\")\n\n        ignore_devices = False\n        # If the remote server has more than ~1000 devices for this user\n        # we assume that something is going horribly wrong (e.g. a bot\n        # that logs in and creates a new device every time it tries to\n        # send a message).  Maintaining lots of devices per user in the\n        # cache can cause serious performance issues as if this request\n        # takes more than 60s to complete, internal replication from the\n        # inbound federation worker to the synapse master may time out\n        # causing the inbound federation to fail and causing the remote\n        # server to retry, causing a DoS.  So in this scenario we give\n        # up on storing the total list of devices and only handle the\n        # delta instead.\n        if len(devices) > 1000:\n            logger.warning(\n                \"Ignoring device list snapshot for %s as it has >1K devs (%d)\",\n                user_id,\n                len(devices),\n            )\n            devices = []\n            ignore_devices = True\n        else:\n            prev_stream_id = await self.store.get_device_list_last_stream_id_for_remote(\n                user_id\n            )\n            cached_devices = await self.store.get_cached_devices_for_user(user_id)\n\n            # To ensure that a user with no devices is cached, we skip the resync only\n            # if we have a stream_id from previously writing a cache entry.\n            if prev_stream_id is not None and cached_devices == {\n                d[\"device_id\"]: d for d in devices\n            }:\n                logging.info(\n                    \"Skipping device list resync for %s, as our cache matches already\",\n                    user_id,\n                )\n                devices = []\n                ignore_devices = True\n\n        for device in devices:\n            logger.debug(\n                \"Handling resync update %r/%r, ID: %r\",\n                user_id,\n                device[\"device_id\"],\n                stream_id,\n            )\n\n        if not ignore_devices:\n            await self.store.update_remote_device_list_cache(\n                user_id, devices, stream_id\n            )\n        # mark the cache as valid, whether or not we actually processed any device\n        # list updates.\n        await self.store.mark_remote_user_device_cache_as_valid(user_id)\n        device_ids = [device[\"device_id\"] for device in devices]\n\n        # Handle cross-signing keys.\n        cross_signing_device_ids = await self.process_cross_signing_key_update(\n            user_id,\n            master_key,\n            self_signing_key,\n        )\n        device_ids = device_ids + cross_signing_device_ids\n\n        if device_ids:\n            await self.device_handler.notify_device_update(user_id, device_ids)\n\n        # We clobber the seen updates since we've re-synced from a given\n        # point.\n        self._seen_updates[user_id] = {stream_id}\n\n        return result, False\n\n    async def process_cross_signing_key_update(\n        self,\n        user_id: str,\n        master_key: Optional[JsonDict],\n        self_signing_key: Optional[JsonDict],\n    ) -> List[str]:\n        \"\"\"Process the given new master and self-signing key for the given remote user.\n\n        Args:\n            user_id: The ID of the user these keys are for.\n            master_key: The dict of the cross-signing master key as returned by the\n                remote server.\n            self_signing_key: The dict of the cross-signing self-signing key as returned\n                by the remote server.\n\n        Return:\n            The device IDs for the given keys.\n        \"\"\"\n        device_ids = []\n\n        current_keys_map = await self.store.get_e2e_cross_signing_keys_bulk([user_id])\n        current_keys = current_keys_map.get(user_id) or {}\n\n        if master_key and master_key != current_keys.get(\"master\"):\n            await self.store.set_e2e_cross_signing_key(user_id, \"master\", master_key)\n            _, verify_key = get_verify_key_from_cross_signing_key(master_key)\n            # verify_key is a VerifyKey from signedjson, which uses\n            # .version to denote the portion of the key ID after the\n            # algorithm and colon, which is the device ID\n            device_ids.append(verify_key.version)\n        if self_signing_key and self_signing_key != current_keys.get(\"self_signing\"):\n            await self.store.set_e2e_cross_signing_key(\n                user_id, \"self_signing\", self_signing_key\n            )\n            _, verify_key = get_verify_key_from_cross_signing_key(self_signing_key)\n            device_ids.append(verify_key.version)\n\n        return device_ids\n\n    async def handle_room_un_partial_stated(self, room_id: str) -> None:\n        \"\"\"Handles sending appropriate device list updates in a room that has\n        gone from partial to full state.\n        \"\"\"\n\n        pending_updates = (\n            await self.store.get_pending_remote_device_list_updates_for_room(room_id)\n        )\n\n        for user_id, device_id in pending_updates:\n            logger.info(\n                \"Got pending device list update in room %s: %s / %s\",\n                room_id,\n                user_id,\n                device_id,\n            )\n            position = await self.store.add_device_change_to_streams(\n                user_id,\n                [device_id],\n                room_ids=[room_id],\n            )\n\n            if not position:\n                # This should only happen if there are no updates, which\n                # shouldn't happen when we've passed in a non-empty set of\n                # device IDs.\n                continue\n\n            self.device_handler.notifier.on_new_event(\n                StreamKeyType.DEVICE_LIST, position, rooms=[room_id]\n            )\n", "# Copyright 2016 OpenMarket Ltd\n# Copyright 2018-2019 New Vector Ltd\n# Copyright 2019 The Matrix.org Foundation C.I.C.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport logging\nfrom typing import TYPE_CHECKING, Dict, Iterable, List, Mapping, Optional, Tuple\n\nimport attr\nfrom canonicaljson import encode_canonical_json\nfrom signedjson.key import VerifyKey, decode_verify_key_bytes\nfrom signedjson.sign import SignatureVerifyException, verify_signed_json\nfrom unpaddedbase64 import decode_base64\n\nfrom twisted.internet import defer\n\nfrom synapse.api.constants import EduTypes\nfrom synapse.api.errors import CodeMessageException, Codes, NotFoundError, SynapseError\nfrom synapse.handlers.device import DeviceHandler\nfrom synapse.logging.context import make_deferred_yieldable, run_in_background\nfrom synapse.logging.opentracing import log_kv, set_tag, tag_args, trace\nfrom synapse.types import (\n    JsonDict,\n    JsonMapping,\n    UserID,\n    get_domain_from_id,\n    get_verify_key_from_cross_signing_key,\n)\nfrom synapse.util import json_decoder\nfrom synapse.util.async_helpers import Linearizer, concurrently_execute\nfrom synapse.util.cancellation import cancellable\nfrom synapse.util.retryutils import NotRetryingDestination\n\nif TYPE_CHECKING:\n    from synapse.server import HomeServer\n\nlogger = logging.getLogger(__name__)\n\n\nclass E2eKeysHandler:\n    def __init__(self, hs: \"HomeServer\"):\n        self.config = hs.config\n        self.store = hs.get_datastores().main\n        self.federation = hs.get_federation_client()\n        self.device_handler = hs.get_device_handler()\n        self._appservice_handler = hs.get_application_service_handler()\n        self.is_mine = hs.is_mine\n        self.clock = hs.get_clock()\n\n        federation_registry = hs.get_federation_registry()\n\n        is_master = hs.config.worker.worker_app is None\n        if is_master:\n            edu_updater = SigningKeyEduUpdater(hs)\n\n            # Only register this edu handler on master as it requires writing\n            # device updates to the db\n            federation_registry.register_edu_handler(\n                EduTypes.SIGNING_KEY_UPDATE,\n                edu_updater.incoming_signing_key_update,\n            )\n            # also handle the unstable version\n            # FIXME: remove this when enough servers have upgraded\n            federation_registry.register_edu_handler(\n                EduTypes.UNSTABLE_SIGNING_KEY_UPDATE,\n                edu_updater.incoming_signing_key_update,\n            )\n\n        # doesn't really work as part of the generic query API, because the\n        # query request requires an object POST, but we abuse the\n        # \"query handler\" interface.\n        federation_registry.register_query_handler(\n            \"client_keys\", self.on_federation_query_client_keys\n        )\n\n        # Limit the number of in-flight requests from a single device.\n        self._query_devices_linearizer = Linearizer(\n            name=\"query_devices\",\n            max_count=10,\n        )\n\n        self._query_appservices_for_otks = (\n            hs.config.experimental.msc3983_appservice_otk_claims\n        )\n        self._query_appservices_for_keys = (\n            hs.config.experimental.msc3984_appservice_key_query\n        )\n\n    @trace\n    @cancellable\n    async def query_devices(\n        self,\n        query_body: JsonDict,\n        timeout: int,\n        from_user_id: str,\n        from_device_id: Optional[str],\n    ) -> JsonDict:\n        \"\"\"Handle a device key query from a client\n\n        {\n            \"device_keys\": {\n                \"<user_id>\": [\"<device_id>\"]\n            }\n        }\n        ->\n        {\n            \"device_keys\": {\n                \"<user_id>\": {\n                    \"<device_id>\": {\n                        ...\n                    }\n                }\n            }\n        }\n\n        Args:\n            from_user_id: the user making the query.  This is used when\n                adding cross-signing signatures to limit what signatures users\n                can see.\n            from_device_id: the device making the query. This is used to limit\n                the number of in-flight queries at a time.\n        \"\"\"\n        async with self._query_devices_linearizer.queue((from_user_id, from_device_id)):\n            device_keys_query: Dict[str, List[str]] = query_body.get(\"device_keys\", {})\n\n            # separate users by domain.\n            # make a map from domain to user_id to device_ids\n            local_query = {}\n            remote_queries = {}\n\n            for user_id, device_ids in device_keys_query.items():\n                # we use UserID.from_string to catch invalid user ids\n                if self.is_mine(UserID.from_string(user_id)):\n                    local_query[user_id] = device_ids\n                else:\n                    remote_queries[user_id] = device_ids\n\n            set_tag(\"local_key_query\", str(local_query))\n            set_tag(\"remote_key_query\", str(remote_queries))\n\n            # First get local devices.\n            # A map of destination -> failure response.\n            failures: Dict[str, JsonDict] = {}\n            results = {}\n            if local_query:\n                local_result = await self.query_local_devices(local_query)\n                for user_id, keys in local_result.items():\n                    if user_id in local_query:\n                        results[user_id] = keys\n\n            # Get cached cross-signing keys\n            cross_signing_keys = await self.get_cross_signing_keys_from_cache(\n                device_keys_query, from_user_id\n            )\n\n            # Now attempt to get any remote devices from our local cache.\n            # A map of destination -> user ID -> device IDs.\n            remote_queries_not_in_cache: Dict[str, Dict[str, Iterable[str]]] = {}\n            if remote_queries:\n                user_ids = set()\n                user_and_device_ids: List[Tuple[str, str]] = []\n                for user_id, device_ids in remote_queries.items():\n                    if device_ids:\n                        user_and_device_ids.extend(\n                            (user_id, device_id) for device_id in device_ids\n                        )\n                    else:\n                        user_ids.add(user_id)\n\n                (\n                    user_ids_not_in_cache,\n                    remote_results,\n                ) = await self.store.get_user_devices_from_cache(\n                    user_ids, user_and_device_ids\n                )\n\n                # Check that the homeserver still shares a room with all cached users.\n                # Note that this check may be slightly racy when a remote user leaves a\n                # room after we have fetched their cached device list. In the worst case\n                # we will do extra federation queries for devices that we had cached.\n                cached_users = set(remote_results.keys())\n                valid_cached_users = (\n                    await self.store.get_users_server_still_shares_room_with(\n                        remote_results.keys()\n                    )\n                )\n                invalid_cached_users = cached_users - valid_cached_users\n                if invalid_cached_users:\n                    # Fix up results. If we get here, it means there was either a bug in\n                    # device list tracking, or we hit the race mentioned above.\n                    # TODO: In practice, this path is hit fairly often in existing\n                    #       deployments when clients query the keys of departed remote\n                    #       users. A background update to mark the appropriate device\n                    #       lists as unsubscribed is needed.\n                    #       https://github.com/matrix-org/synapse/issues/13651\n                    # Note that this currently introduces a failure mode when clients\n                    # are trying to decrypt old messages from a remote user whose\n                    # homeserver is no longer available. We may want to consider falling\n                    # back to the cached data when we fail to retrieve a device list\n                    # over federation for such remote users.\n                    user_ids_not_in_cache.update(invalid_cached_users)\n                    for invalid_user_id in invalid_cached_users:\n                        remote_results.pop(invalid_user_id)\n\n                for user_id, devices in remote_results.items():\n                    user_devices = results.setdefault(user_id, {})\n                    for device_id, device in devices.items():\n                        keys = device.get(\"keys\", None)\n                        device_display_name = device.get(\"device_display_name\", None)\n                        if keys:\n                            result = dict(keys)\n                            unsigned = result.setdefault(\"unsigned\", {})\n                            if device_display_name:\n                                unsigned[\"device_display_name\"] = device_display_name\n                            user_devices[device_id] = result\n\n                # check for missing cross-signing keys.\n                for user_id in remote_queries.keys():\n                    cached_cross_master = user_id in cross_signing_keys[\"master_keys\"]\n                    cached_cross_selfsigning = (\n                        user_id in cross_signing_keys[\"self_signing_keys\"]\n                    )\n\n                    # check if we are missing only one of cross-signing master or\n                    # self-signing key, but the other one is cached.\n                    # as we need both, this will issue a federation request.\n                    # if we don't have any of the keys, either the user doesn't have\n                    # cross-signing set up, or the cached device list\n                    # is not (yet) updated.\n                    if cached_cross_master ^ cached_cross_selfsigning:\n                        user_ids_not_in_cache.add(user_id)\n\n                # add those users to the list to fetch over federation.\n                for user_id in user_ids_not_in_cache:\n                    domain = get_domain_from_id(user_id)\n                    r = remote_queries_not_in_cache.setdefault(domain, {})\n                    r[user_id] = remote_queries[user_id]\n\n            # Now fetch any devices that we don't have in our cache\n            # TODO It might make sense to propagate cancellations into the\n            #      deferreds which are querying remote homeservers.\n            logger.debug(\n                \"%d destinations to query devices for\", len(remote_queries_not_in_cache)\n            )\n\n            async def _query(\n                destination_queries: Tuple[str, Dict[str, Iterable[str]]]\n            ) -> None:\n                destination, queries = destination_queries\n                return await self._query_devices_for_destination(\n                    results,\n                    cross_signing_keys,\n                    failures,\n                    destination,\n                    queries,\n                    timeout,\n                )\n\n            await concurrently_execute(\n                _query,\n                remote_queries_not_in_cache.items(),\n                10,\n                delay_cancellation=True,\n            )\n\n            return {\"device_keys\": results, \"failures\": failures, **cross_signing_keys}\n\n    @trace\n    async def _query_devices_for_destination(\n        self,\n        results: JsonDict,\n        cross_signing_keys: JsonDict,\n        failures: Dict[str, JsonDict],\n        destination: str,\n        destination_query: Dict[str, Iterable[str]],\n        timeout: int,\n    ) -> None:\n        \"\"\"This is called when we are querying the device list of a user on\n        a remote homeserver and their device list is not in the device list\n        cache. If we share a room with this user and we're not querying for\n        specific user we will update the cache with their device list.\n\n        Args:\n            results: A map from user ID to their device keys, which gets\n                updated with the newly fetched keys.\n            cross_signing_keys: Map from user ID to their cross signing keys,\n                which gets updated with the newly fetched keys.\n            failures: Map of destinations to failures that have occurred while\n                attempting to fetch keys.\n            destination: The remote server to query\n            destination_query: The query dict of devices to query the remote\n                server for.\n            timeout: The timeout for remote HTTP requests.\n        \"\"\"\n\n        # We first consider whether we wish to update the device list cache with\n        # the users device list. We want to track a user's devices when the\n        # authenticated user shares a room with the queried user and the query\n        # has not specified a particular device.\n        # If we update the cache for the queried user we remove them from further\n        # queries. We use the more efficient batched query_client_keys for all\n        # remaining users\n        user_ids_updated = []\n\n        # Perform a user device resync for each user only once and only as long as:\n        # - they have an empty device_list\n        # - they are in some rooms that this server can see\n        users_to_resync_devices = {\n            user_id\n            for (user_id, device_list) in destination_query.items()\n            if (not device_list) and (await self.store.get_rooms_for_user(user_id))\n        }\n\n        logger.debug(\n            \"%d users to resync devices for from destination %s\",\n            len(users_to_resync_devices),\n            destination,\n        )\n\n        try:\n            user_resync_results = (\n                await self.device_handler.device_list_updater.multi_user_device_resync(\n                    list(users_to_resync_devices)\n                )\n            )\n            for user_id in users_to_resync_devices:\n                resync_results = user_resync_results[user_id]\n\n                if resync_results is None:\n                    # TODO: It's weird that we'll store a failure against a\n                    #       destination, yet continue processing users from that\n                    #       destination.\n                    #       We might want to consider changing this, but for now\n                    #       I'm leaving it as I found it.\n                    failures[destination] = _exception_to_failure(\n                        ValueError(f\"Device resync failed for {user_id!r}\")\n                    )\n                    continue\n\n                # Add the device keys to the results.\n                user_devices = resync_results[\"devices\"]\n                user_results = results.setdefault(user_id, {})\n                for device in user_devices:\n                    user_results[device[\"device_id\"]] = device[\"keys\"]\n                user_ids_updated.append(user_id)\n\n                # Add any cross signing keys to the results.\n                master_key = resync_results.get(\"master_key\")\n                self_signing_key = resync_results.get(\"self_signing_key\")\n\n                if master_key:\n                    cross_signing_keys[\"master_keys\"][user_id] = master_key\n\n                if self_signing_key:\n                    cross_signing_keys[\"self_signing_keys\"][user_id] = self_signing_key\n        except Exception as e:\n            failures[destination] = _exception_to_failure(e)\n\n        if len(destination_query) == len(user_ids_updated):\n            # We've updated all the users in the query and we do not need to\n            # make any further remote calls.\n            return\n\n        # Remove all the users from the query which we have updated\n        for user_id in user_ids_updated:\n            destination_query.pop(user_id)\n\n        try:\n            remote_result = await self.federation.query_client_keys(\n                destination, {\"device_keys\": destination_query}, timeout=timeout\n            )\n\n            for user_id, keys in remote_result[\"device_keys\"].items():\n                if user_id in destination_query:\n                    results[user_id] = keys\n\n            if \"master_keys\" in remote_result:\n                for user_id, key in remote_result[\"master_keys\"].items():\n                    if user_id in destination_query:\n                        cross_signing_keys[\"master_keys\"][user_id] = key\n\n            if \"self_signing_keys\" in remote_result:\n                for user_id, key in remote_result[\"self_signing_keys\"].items():\n                    if user_id in destination_query:\n                        cross_signing_keys[\"self_signing_keys\"][user_id] = key\n\n        except Exception as e:\n            failure = _exception_to_failure(e)\n            failures[destination] = failure\n            set_tag(\"error\", True)\n            set_tag(\"reason\", str(failure))\n\n        return\n\n    @cancellable\n    async def get_cross_signing_keys_from_cache(\n        self, query: Iterable[str], from_user_id: Optional[str]\n    ) -> Dict[str, Dict[str, JsonMapping]]:\n        \"\"\"Get cross-signing keys for users from the database\n\n        Args:\n            query: an iterable of user IDs.  A dict whose keys\n                are user IDs satisfies this, so the query format used for\n                query_devices can be used here.\n            from_user_id: the user making the query.  This is used when\n                adding cross-signing signatures to limit what signatures users\n                can see.\n\n        Returns:\n            A map from (master_keys|self_signing_keys|user_signing_keys) -> user_id -> key\n        \"\"\"\n        master_keys = {}\n        self_signing_keys = {}\n        user_signing_keys = {}\n\n        user_ids = list(query)\n\n        keys = await self.store.get_e2e_cross_signing_keys_bulk(user_ids, from_user_id)\n\n        for user_id, user_info in keys.items():\n            if user_info is None:\n                continue\n            if \"master\" in user_info:\n                master_keys[user_id] = user_info[\"master\"]\n            if \"self_signing\" in user_info:\n                self_signing_keys[user_id] = user_info[\"self_signing\"]\n\n        # users can see other users' master and self-signing keys, but can\n        # only see their own user-signing keys\n        if from_user_id:\n            from_user_key = keys.get(from_user_id)\n            if from_user_key and \"user_signing\" in from_user_key:\n                user_signing_keys[from_user_id] = from_user_key[\"user_signing\"]\n\n        return {\n            \"master_keys\": master_keys,\n            \"self_signing_keys\": self_signing_keys,\n            \"user_signing_keys\": user_signing_keys,\n        }\n\n    @trace\n    @cancellable\n    async def query_local_devices(\n        self,\n        query: Mapping[str, Optional[List[str]]],\n        include_displaynames: bool = True,\n    ) -> Dict[str, Dict[str, dict]]:\n        \"\"\"Get E2E device keys for local users\n\n        Args:\n            query: map from user_id to a list\n                 of devices to query (None for all devices)\n            include_displaynames: Whether to include device displaynames in the returned\n                device details.\n\n        Returns:\n            A map from user_id -> device_id -> device details\n        \"\"\"\n        set_tag(\"local_query\", str(query))\n        local_query: List[Tuple[str, Optional[str]]] = []\n\n        result_dict: Dict[str, Dict[str, dict]] = {}\n        for user_id, device_ids in query.items():\n            # we use UserID.from_string to catch invalid user ids\n            if not self.is_mine(UserID.from_string(user_id)):\n                logger.warning(\"Request for keys for non-local user %s\", user_id)\n                log_kv(\n                    {\n                        \"message\": \"Requested a local key for a user which\"\n                        \" was not local to the homeserver\",\n                        \"user_id\": user_id,\n                    }\n                )\n                set_tag(\"error\", True)\n                raise SynapseError(400, \"Not a user here\")\n\n            if not device_ids:\n                local_query.append((user_id, None))\n            else:\n                for device_id in device_ids:\n                    local_query.append((user_id, device_id))\n\n            # make sure that each queried user appears in the result dict\n            result_dict[user_id] = {}\n\n        results = await self.store.get_e2e_device_keys_for_cs_api(\n            local_query, include_displaynames\n        )\n\n        # Check if the application services have any additional results.\n        if self._query_appservices_for_keys:\n            # Query the appservices for any keys.\n            appservice_results = await self._appservice_handler.query_keys(query)\n\n            # Merge results, overriding with what the appservice returned.\n            for user_id, devices in appservice_results.get(\"device_keys\", {}).items():\n                # Copy the appservice device info over the homeserver device info, but\n                # don't completely overwrite it.\n                results.setdefault(user_id, {}).update(devices)\n\n            # TODO Handle cross-signing keys.\n\n        # Build the result structure\n        for user_id, device_keys in results.items():\n            for device_id, device_info in device_keys.items():\n                result_dict[user_id][device_id] = device_info\n\n        log_kv(results)\n        return result_dict\n\n    async def on_federation_query_client_keys(\n        self, query_body: Dict[str, Dict[str, Optional[List[str]]]]\n    ) -> JsonDict:\n        \"\"\"Handle a device key query from a federated server:\n\n        Handles the path: GET /_matrix/federation/v1/users/keys/query\n\n        Args:\n            query_body: The body of the query request. Should contain a key\n                \"device_keys\" that map to a dictionary of user ID's -> list of\n                device IDs. If the list of device IDs is empty, all devices of\n                that user will be queried.\n\n        Returns:\n            A json dictionary containing the following:\n                - device_keys: A dictionary containing the requested device information.\n                - master_keys: An optional dictionary of user ID -> master cross-signing\n                   key info.\n                - self_signing_key: An optional dictionary of user ID -> self-signing\n                    key info.\n        \"\"\"\n        device_keys_query: Dict[str, Optional[List[str]]] = query_body.get(\n            \"device_keys\", {}\n        )\n        res = await self.query_local_devices(\n            device_keys_query,\n            include_displaynames=(\n                self.config.federation.allow_device_name_lookup_over_federation\n            ),\n        )\n\n        # add in the cross-signing keys\n        cross_signing_keys = await self.get_cross_signing_keys_from_cache(\n            device_keys_query, None\n        )\n\n        return {\"device_keys\": res, **cross_signing_keys}\n\n    async def claim_local_one_time_keys(\n        self,\n        local_query: List[Tuple[str, str, str, int]],\n        always_include_fallback_keys: bool,\n    ) -> Iterable[Dict[str, Dict[str, Dict[str, JsonDict]]]]:\n        \"\"\"Claim one time keys for local users.\n\n        1. Attempt to claim OTKs from the database.\n        2. Ask application services if they provide OTKs.\n        3. Attempt to fetch fallback keys from the database.\n\n        Args:\n            local_query: An iterable of tuples of (user ID, device ID, algorithm).\n            always_include_fallback_keys: True to always include fallback keys.\n\n        Returns:\n            An iterable of maps of user ID -> a map device ID -> a map of key ID -> JSON bytes.\n        \"\"\"\n\n        # Cap the number of OTKs that can be claimed at once to avoid abuse.\n        local_query = [\n            (user_id, device_id, algorithm, min(count, 5))\n            for user_id, device_id, algorithm, count in local_query\n        ]\n\n        otk_results, not_found = await self.store.claim_e2e_one_time_keys(local_query)\n\n        # If the application services have not provided any keys via the C-S\n        # API, query it directly for one-time keys.\n        if self._query_appservices_for_otks:\n            # TODO Should this query for fallback keys of uploaded OTKs if\n            #      always_include_fallback_keys is True? The MSC is ambiguous.\n            (\n                appservice_results,\n                not_found,\n            ) = await self._appservice_handler.claim_e2e_one_time_keys(not_found)\n        else:\n            appservice_results = {}\n\n        # Calculate which user ID / device ID / algorithm tuples to get fallback\n        # keys for. This can be either only missing results *or* all results\n        # (which don't already have a fallback key).\n        if always_include_fallback_keys:\n            # Build the fallback query as any part of the original query where\n            # the appservice didn't respond with a fallback key.\n            fallback_query = []\n\n            # Iterate each item in the original query and search the results\n            # from the appservice for that user ID / device ID. If it is found,\n            # check if any of the keys match the requested algorithm & are a\n            # fallback key.\n            for user_id, device_id, algorithm, _count in local_query:\n                # Check if the appservice responded for this query.\n                as_result = appservice_results.get(user_id, {}).get(device_id, {})\n                found_otk = False\n                for key_id, key_json in as_result.items():\n                    if key_id.startswith(f\"{algorithm}:\"):\n                        # A OTK or fallback key was found for this query.\n                        found_otk = True\n                        # A fallback key was found for this query, no need to\n                        # query further.\n                        if key_json.get(\"fallback\", False):\n                            break\n\n                else:\n                    # No fallback key was found from appservices, query for it.\n                    # Only mark the fallback key as used if no OTK was found\n                    # (from either the database or appservices).\n                    mark_as_used = not found_otk and not any(\n                        key_id.startswith(f\"{algorithm}:\")\n                        for key_id in otk_results.get(user_id, {})\n                        .get(device_id, {})\n                        .keys()\n                    )\n                    # Note that it doesn't make sense to request more than 1 fallback key\n                    # per (user_id, device_id, algorithm).\n                    fallback_query.append((user_id, device_id, algorithm, mark_as_used))\n\n        else:\n            # All fallback keys get marked as used.\n            fallback_query = [\n                # Note that it doesn't make sense to request more than 1 fallback key\n                # per (user_id, device_id, algorithm).\n                (user_id, device_id, algorithm, True)\n                for user_id, device_id, algorithm, count in not_found\n            ]\n\n        # For each user that does not have a one-time keys available, see if\n        # there is a fallback key.\n        fallback_results = await self.store.claim_e2e_fallback_keys(fallback_query)\n\n        # Return the results in order, each item from the input query should\n        # only appear once in the combined list.\n        return (otk_results, appservice_results, fallback_results)\n\n    @trace\n    async def claim_one_time_keys(\n        self,\n        query: Dict[str, Dict[str, Dict[str, int]]],\n        user: UserID,\n        timeout: Optional[int],\n        always_include_fallback_keys: bool,\n    ) -> JsonDict:\n        local_query: List[Tuple[str, str, str, int]] = []\n        remote_queries: Dict[str, Dict[str, Dict[str, Dict[str, int]]]] = {}\n\n        for user_id, one_time_keys in query.items():\n            # we use UserID.from_string to catch invalid user ids\n            if self.is_mine(UserID.from_string(user_id)):\n                for device_id, algorithms in one_time_keys.items():\n                    for algorithm, count in algorithms.items():\n                        local_query.append((user_id, device_id, algorithm, count))\n            else:\n                domain = get_domain_from_id(user_id)\n                remote_queries.setdefault(domain, {})[user_id] = one_time_keys\n\n        set_tag(\"local_key_query\", str(local_query))\n        set_tag(\"remote_key_query\", str(remote_queries))\n\n        results = await self.claim_local_one_time_keys(\n            local_query, always_include_fallback_keys\n        )\n\n        # A map of user ID -> device ID -> key ID -> key.\n        json_result: Dict[str, Dict[str, Dict[str, JsonDict]]] = {}\n        for result in results:\n            for user_id, device_keys in result.items():\n                for device_id, keys in device_keys.items():\n                    for key_id, key in keys.items():\n                        json_result.setdefault(user_id, {}).setdefault(\n                            device_id, {}\n                        ).update({key_id: key})\n\n        # Remote failures.\n        failures: Dict[str, JsonDict] = {}\n\n        @trace\n        async def claim_client_keys(destination: str) -> None:\n            set_tag(\"destination\", destination)\n            device_keys = remote_queries[destination]\n            try:\n                remote_result = await self.federation.claim_client_keys(\n                    user, destination, device_keys, timeout=timeout\n                )\n                for user_id, keys in remote_result[\"one_time_keys\"].items():\n                    if user_id in device_keys:\n                        json_result[user_id] = keys\n\n            except Exception as e:\n                failure = _exception_to_failure(e)\n                failures[destination] = failure\n                set_tag(\"error\", True)\n                set_tag(\"reason\", str(failure))\n\n        await make_deferred_yieldable(\n            defer.gatherResults(\n                [\n                    run_in_background(claim_client_keys, destination)\n                    for destination in remote_queries\n                ],\n                consumeErrors=True,\n            )\n        )\n\n        logger.info(\n            \"Claimed one-time-keys: %s\",\n            \",\".join(\n                (\n                    \"%s for %s:%s\" % (key_id, user_id, device_id)\n                    for user_id, user_keys in json_result.items()\n                    for device_id, device_keys in user_keys.items()\n                    for key_id, _ in device_keys.items()\n                )\n            ),\n        )\n\n        log_kv({\"one_time_keys\": json_result, \"failures\": failures})\n        return {\"one_time_keys\": json_result, \"failures\": failures}\n\n    @tag_args\n    async def upload_keys_for_user(\n        self, user_id: str, device_id: str, keys: JsonDict\n    ) -> JsonDict:\n        # This can only be called from the main process.\n        assert isinstance(self.device_handler, DeviceHandler)\n\n        time_now = self.clock.time_msec()\n\n        # TODO: Validate the JSON to make sure it has the right keys.\n        device_keys = keys.get(\"device_keys\", None)\n        if device_keys:\n            logger.info(\n                \"Updating device_keys for device %r for user %s at %d\",\n                device_id,\n                user_id,\n                time_now,\n            )\n            log_kv(\n                {\n                    \"message\": \"Updating device_keys for user.\",\n                    \"user_id\": user_id,\n                    \"device_id\": device_id,\n                }\n            )\n            # TODO: Sign the JSON with the server key\n            changed = await self.store.set_e2e_device_keys(\n                user_id, device_id, time_now, device_keys\n            )\n            if changed:\n                # Only notify about device updates *if* the keys actually changed\n                await self.device_handler.notify_device_update(user_id, [device_id])\n        else:\n            log_kv({\"message\": \"Not updating device_keys for user\", \"user_id\": user_id})\n        one_time_keys = keys.get(\"one_time_keys\", None)\n        if one_time_keys:\n            log_kv(\n                {\n                    \"message\": \"Updating one_time_keys for device.\",\n                    \"user_id\": user_id,\n                    \"device_id\": device_id,\n                }\n            )\n            await self._upload_one_time_keys_for_user(\n                user_id, device_id, time_now, one_time_keys\n            )\n        else:\n            log_kv(\n                {\"message\": \"Did not update one_time_keys\", \"reason\": \"no keys given\"}\n            )\n        fallback_keys = keys.get(\"fallback_keys\") or keys.get(\n            \"org.matrix.msc2732.fallback_keys\"\n        )\n        if fallback_keys and isinstance(fallback_keys, dict):\n            log_kv(\n                {\n                    \"message\": \"Updating fallback_keys for device.\",\n                    \"user_id\": user_id,\n                    \"device_id\": device_id,\n                }\n            )\n            await self.store.set_e2e_fallback_keys(user_id, device_id, fallback_keys)\n        elif fallback_keys:\n            log_kv({\"message\": \"Did not update fallback_keys\", \"reason\": \"not a dict\"})\n        else:\n            log_kv(\n                {\"message\": \"Did not update fallback_keys\", \"reason\": \"no keys given\"}\n            )\n\n        # the device should have been registered already, but it may have been\n        # deleted due to a race with a DELETE request. Or we may be using an\n        # old access_token without an associated device_id. Either way, we\n        # need to double-check the device is registered to avoid ending up with\n        # keys without a corresponding device.\n        await self.device_handler.check_device_registered(user_id, device_id)\n\n        result = await self.store.count_e2e_one_time_keys(user_id, device_id)\n\n        set_tag(\"one_time_key_counts\", str(result))\n        return {\"one_time_key_counts\": result}\n\n    async def _upload_one_time_keys_for_user(\n        self, user_id: str, device_id: str, time_now: int, one_time_keys: JsonDict\n    ) -> None:\n        logger.info(\n            \"Adding one_time_keys %r for device %r for user %r at %d\",\n            one_time_keys.keys(),\n            device_id,\n            user_id,\n            time_now,\n        )\n\n        # make a list of (alg, id, key) tuples\n        key_list = []\n        for key_id, key_obj in one_time_keys.items():\n            algorithm, key_id = key_id.split(\":\")\n            key_list.append((algorithm, key_id, key_obj))\n\n        # First we check if we have already persisted any of the keys.\n        existing_key_map = await self.store.get_e2e_one_time_keys(\n            user_id, device_id, [k_id for _, k_id, _ in key_list]\n        )\n\n        new_keys = []  # Keys that we need to insert. (alg, id, json) tuples.\n        for algorithm, key_id, key in key_list:\n            ex_json = existing_key_map.get((algorithm, key_id), None)\n            if ex_json:\n                if not _one_time_keys_match(ex_json, key):\n                    raise SynapseError(\n                        400,\n                        (\n                            \"One time key %s:%s already exists. \"\n                            \"Old key: %s; new key: %r\"\n                        )\n                        % (algorithm, key_id, ex_json, key),\n                    )\n            else:\n                new_keys.append(\n                    (algorithm, key_id, encode_canonical_json(key).decode(\"ascii\"))\n                )\n\n        log_kv({\"message\": \"Inserting new one_time_keys.\", \"keys\": new_keys})\n        await self.store.add_e2e_one_time_keys(user_id, device_id, time_now, new_keys)\n\n    async def upload_signing_keys_for_user(\n        self, user_id: str, keys: JsonDict\n    ) -> JsonDict:\n        \"\"\"Upload signing keys for cross-signing\n\n        Args:\n            user_id: the user uploading the keys\n            keys: the signing keys\n        \"\"\"\n        # This can only be called from the main process.\n        assert isinstance(self.device_handler, DeviceHandler)\n\n        # if a master key is uploaded, then check it.  Otherwise, load the\n        # stored master key, to check signatures on other keys\n        if \"master_key\" in keys:\n            master_key = keys[\"master_key\"]\n\n            _check_cross_signing_key(master_key, user_id, \"master\")\n        else:\n            master_key = await self.store.get_e2e_cross_signing_key(user_id, \"master\")\n\n        # if there is no master key, then we can't do anything, because all the\n        # other cross-signing keys need to be signed by the master key\n        if not master_key:\n            raise SynapseError(400, \"No master key available\", Codes.MISSING_PARAM)\n\n        try:\n            master_key_id, master_verify_key = get_verify_key_from_cross_signing_key(\n                master_key\n            )\n        except ValueError:\n            if \"master_key\" in keys:\n                # the invalid key came from the request\n                raise SynapseError(400, \"Invalid master key\", Codes.INVALID_PARAM)\n            else:\n                # the invalid key came from the database\n                logger.error(\"Invalid master key found for user %s\", user_id)\n                raise SynapseError(500, \"Invalid master key\")\n\n        # for the other cross-signing keys, make sure that they have valid\n        # signatures from the master key\n        if \"self_signing_key\" in keys:\n            self_signing_key = keys[\"self_signing_key\"]\n\n            _check_cross_signing_key(\n                self_signing_key, user_id, \"self_signing\", master_verify_key\n            )\n\n        if \"user_signing_key\" in keys:\n            user_signing_key = keys[\"user_signing_key\"]\n\n            _check_cross_signing_key(\n                user_signing_key, user_id, \"user_signing\", master_verify_key\n            )\n\n        # if everything checks out, then store the keys and send notifications\n        deviceids = []\n        if \"master_key\" in keys:\n            await self.store.set_e2e_cross_signing_key(user_id, \"master\", master_key)\n            deviceids.append(master_verify_key.version)\n        if \"self_signing_key\" in keys:\n            await self.store.set_e2e_cross_signing_key(\n                user_id, \"self_signing\", self_signing_key\n            )\n            try:\n                deviceids.append(\n                    get_verify_key_from_cross_signing_key(self_signing_key)[1].version\n                )\n            except ValueError:\n                raise SynapseError(400, \"Invalid self-signing key\", Codes.INVALID_PARAM)\n        if \"user_signing_key\" in keys:\n            await self.store.set_e2e_cross_signing_key(\n                user_id, \"user_signing\", user_signing_key\n            )\n            # the signature stream matches the semantics that we want for\n            # user-signing key updates: only the user themselves is notified of\n            # their own user-signing key updates\n            await self.device_handler.notify_user_signature_update(user_id, [user_id])\n\n        # master key and self-signing key updates match the semantics of device\n        # list updates: all users who share an encrypted room are notified\n        if len(deviceids):\n            await self.device_handler.notify_device_update(user_id, deviceids)\n\n        return {}\n\n    async def upload_signatures_for_device_keys(\n        self, user_id: str, signatures: JsonDict\n    ) -> JsonDict:\n        \"\"\"Upload device signatures for cross-signing\n\n        Args:\n            user_id: the user uploading the signatures\n            signatures: map of users to devices to signed keys. This is the submission\n            from the user; an exception will be raised if it is malformed.\n        Returns:\n            The response to be sent back to the client.  The response will have\n                a \"failures\" key, which will be a dict mapping users to devices\n                to errors for the signatures that failed.\n        Raises:\n            SynapseError: if the signatures dict is not valid.\n        \"\"\"\n        # This can only be called from the main process.\n        assert isinstance(self.device_handler, DeviceHandler)\n\n        failures = {}\n\n        # signatures to be stored.  Each item will be a SignatureListItem\n        signature_list = []\n\n        # split between checking signatures for own user and signatures for\n        # other users, since we verify them with different keys\n        self_signatures = signatures.get(user_id, {})\n        other_signatures = {k: v for k, v in signatures.items() if k != user_id}\n\n        self_signature_list, self_failures = await self._process_self_signatures(\n            user_id, self_signatures\n        )\n        signature_list.extend(self_signature_list)\n        failures.update(self_failures)\n\n        other_signature_list, other_failures = await self._process_other_signatures(\n            user_id, other_signatures\n        )\n        signature_list.extend(other_signature_list)\n        failures.update(other_failures)\n\n        # store the signature, and send the appropriate notifications for sync\n        logger.debug(\"upload signature failures: %r\", failures)\n        await self.store.store_e2e_cross_signing_signatures(user_id, signature_list)\n\n        self_device_ids = [item.target_device_id for item in self_signature_list]\n        if self_device_ids:\n            await self.device_handler.notify_device_update(user_id, self_device_ids)\n        signed_users = [item.target_user_id for item in other_signature_list]\n        if signed_users:\n            await self.device_handler.notify_user_signature_update(\n                user_id, signed_users\n            )\n\n        return {\"failures\": failures}\n\n    async def _process_self_signatures(\n        self, user_id: str, signatures: JsonDict\n    ) -> Tuple[List[\"SignatureListItem\"], Dict[str, Dict[str, dict]]]:\n        \"\"\"Process uploaded signatures of the user's own keys.\n\n        Signatures of the user's own keys from this API come in two forms:\n        - signatures of the user's devices by the user's self-signing key,\n        - signatures of the user's master key by the user's devices.\n\n        Args:\n            user_id: the user uploading the keys\n            signatures (dict[string, dict]): map of devices to signed keys\n\n        Returns:\n            A tuple of a list of signatures to store, and a map of users to\n            devices to failure reasons\n\n        Raises:\n            SynapseError: if the input is malformed\n        \"\"\"\n        signature_list: List[\"SignatureListItem\"] = []\n        failures: Dict[str, Dict[str, JsonDict]] = {}\n        if not signatures:\n            return signature_list, failures\n\n        if not isinstance(signatures, dict):\n            raise SynapseError(400, \"Invalid parameter\", Codes.INVALID_PARAM)\n\n        try:\n            # get our self-signing key to verify the signatures\n            (\n                _,\n                self_signing_key_id,\n                self_signing_verify_key,\n            ) = await self._get_e2e_cross_signing_verify_key(user_id, \"self_signing\")\n\n            # get our master key, since we may have received a signature of it.\n            # We need to fetch it here so that we know what its key ID is, so\n            # that we can check if a signature that was sent is a signature of\n            # the master key or of a device\n            (\n                master_key,\n                _,\n                master_verify_key,\n            ) = await self._get_e2e_cross_signing_verify_key(user_id, \"master\")\n\n            # fetch our stored devices.  This is used to 1. verify\n            # signatures on the master key, and 2. to compare with what\n            # was sent if the device was signed\n            devices = await self.store.get_e2e_device_keys_for_cs_api([(user_id, None)])\n\n            if user_id not in devices:\n                raise NotFoundError(\"No device keys found\")\n\n            devices = devices[user_id]\n        except SynapseError as e:\n            failure = _exception_to_failure(e)\n            failures[user_id] = {device: failure for device in signatures.keys()}\n            return signature_list, failures\n\n        for device_id, device in signatures.items():\n            # make sure submitted data is in the right form\n            if not isinstance(device, dict):\n                raise SynapseError(400, \"Invalid parameter\", Codes.INVALID_PARAM)\n\n            try:\n                if \"signatures\" not in device or user_id not in device[\"signatures\"]:\n                    # no signature was sent\n                    raise SynapseError(\n                        400, \"Invalid signature\", Codes.INVALID_SIGNATURE\n                    )\n\n                if device_id == master_verify_key.version:\n                    # The signature is of the master key. This needs to be\n                    # handled differently from signatures of normal devices.\n                    master_key_signature_list = self._check_master_key_signature(\n                        user_id, device_id, device, master_key, devices\n                    )\n                    signature_list.extend(master_key_signature_list)\n                    continue\n\n                # at this point, we have a device that should be signed\n                # by the self-signing key\n                if self_signing_key_id not in device[\"signatures\"][user_id]:\n                    # no signature was sent\n                    raise SynapseError(\n                        400, \"Invalid signature\", Codes.INVALID_SIGNATURE\n                    )\n\n                try:\n                    stored_device = devices[device_id]\n                except KeyError:\n                    raise NotFoundError(\"Unknown device\")\n                if self_signing_key_id in stored_device.get(\"signatures\", {}).get(\n                    user_id, {}\n                ):\n                    # we already have a signature on this device, so we\n                    # can skip it, since it should be exactly the same\n                    continue\n\n                _check_device_signature(\n                    user_id, self_signing_verify_key, device, stored_device\n                )\n\n                signature = device[\"signatures\"][user_id][self_signing_key_id]\n                signature_list.append(\n                    SignatureListItem(\n                        self_signing_key_id, user_id, device_id, signature\n                    )\n                )\n            except SynapseError as e:\n                failures.setdefault(user_id, {})[device_id] = _exception_to_failure(e)\n\n        return signature_list, failures\n\n    def _check_master_key_signature(\n        self,\n        user_id: str,\n        master_key_id: str,\n        signed_master_key: JsonDict,\n        stored_master_key: JsonMapping,\n        devices: Dict[str, Dict[str, JsonDict]],\n    ) -> List[\"SignatureListItem\"]:\n        \"\"\"Check signatures of a user's master key made by their devices.\n\n        Args:\n            user_id: the user whose master key is being checked\n            master_key_id: the ID of the user's master key\n            signed_master_key: the user's signed master key that was uploaded\n            stored_master_key: our previously-stored copy of the user's master key\n            devices: the user's devices\n\n        Returns:\n            A list of signatures to store\n\n        Raises:\n            SynapseError: if a signature is invalid\n        \"\"\"\n        # for each device that signed the master key, check the signature.\n        master_key_signature_list = []\n        sigs = signed_master_key[\"signatures\"]\n        for signing_key_id, signature in sigs[user_id].items():\n            _, signing_device_id = signing_key_id.split(\":\", 1)\n            if (\n                signing_device_id not in devices\n                or signing_key_id not in devices[signing_device_id][\"keys\"]\n            ):\n                # signed by an unknown device, or the\n                # device does not have the key\n                raise SynapseError(400, \"Invalid signature\", Codes.INVALID_SIGNATURE)\n\n            # get the key and check the signature\n            pubkey = devices[signing_device_id][\"keys\"][signing_key_id]\n            verify_key = decode_verify_key_bytes(signing_key_id, decode_base64(pubkey))\n            _check_device_signature(\n                user_id, verify_key, signed_master_key, stored_master_key\n            )\n\n            master_key_signature_list.append(\n                SignatureListItem(signing_key_id, user_id, master_key_id, signature)\n            )\n\n        return master_key_signature_list\n\n    async def _process_other_signatures(\n        self, user_id: str, signatures: Dict[str, dict]\n    ) -> Tuple[List[\"SignatureListItem\"], Dict[str, Dict[str, dict]]]:\n        \"\"\"Process uploaded signatures of other users' keys.  These will be the\n        target user's master keys, signed by the uploading user's user-signing\n        key.\n\n        Args:\n            user_id: the user uploading the keys\n            signatures: map of users to devices to signed keys\n\n        Returns:\n            A list of signatures to store, and a map of users to devices to failure\n            reasons\n\n        Raises:\n            SynapseError: if the input is malformed\n        \"\"\"\n        signature_list: List[\"SignatureListItem\"] = []\n        failures: Dict[str, Dict[str, JsonDict]] = {}\n        if not signatures:\n            return signature_list, failures\n\n        try:\n            # get our user-signing key to verify the signatures\n            (\n                user_signing_key,\n                user_signing_key_id,\n                user_signing_verify_key,\n            ) = await self._get_e2e_cross_signing_verify_key(user_id, \"user_signing\")\n        except SynapseError as e:\n            failure = _exception_to_failure(e)\n            for user, devicemap in signatures.items():\n                failures[user] = {device_id: failure for device_id in devicemap.keys()}\n            return signature_list, failures\n\n        for target_user, devicemap in signatures.items():\n            # make sure submitted data is in the right form\n            if not isinstance(devicemap, dict):\n                raise SynapseError(400, \"Invalid parameter\", Codes.INVALID_PARAM)\n            for device in devicemap.values():\n                if not isinstance(device, dict):\n                    raise SynapseError(400, \"Invalid parameter\", Codes.INVALID_PARAM)\n\n            device_id = None\n            try:\n                # get the target user's master key, to make sure it matches\n                # what was sent\n                (\n                    master_key,\n                    master_key_id,\n                    _,\n                ) = await self._get_e2e_cross_signing_verify_key(\n                    target_user, \"master\", user_id\n                )\n\n                # make sure that the target user's master key is the one that\n                # was signed (and no others)\n                device_id = master_key_id.split(\":\", 1)[1]\n                if device_id not in devicemap:\n                    logger.debug(\n                        \"upload signature: could not find signature for device %s\",\n                        device_id,\n                    )\n                    # set device to None so that the failure gets\n                    # marked on all the signatures\n                    device_id = None\n                    raise NotFoundError(\"Unknown device\")\n                key = devicemap[device_id]\n                other_devices = [k for k in devicemap.keys() if k != device_id]\n                if other_devices:\n                    # other devices were signed -- mark those as failures\n                    logger.debug(\"upload signature: too many devices specified\")\n                    failure = _exception_to_failure(NotFoundError(\"Unknown device\"))\n                    failures[target_user] = {\n                        device: failure for device in other_devices\n                    }\n\n                if user_signing_key_id in master_key.get(\"signatures\", {}).get(\n                    user_id, {}\n                ):\n                    # we already have the signature, so we can skip it\n                    continue\n\n                _check_device_signature(\n                    user_id, user_signing_verify_key, key, master_key\n                )\n\n                signature = key[\"signatures\"][user_id][user_signing_key_id]\n                signature_list.append(\n                    SignatureListItem(\n                        user_signing_key_id, target_user, device_id, signature\n                    )\n                )\n            except SynapseError as e:\n                failure = _exception_to_failure(e)\n                if device_id is None:\n                    failures[target_user] = {\n                        device_id: failure for device_id in devicemap.keys()\n                    }\n                else:\n                    failures.setdefault(target_user, {})[device_id] = failure\n\n        return signature_list, failures\n\n    async def _get_e2e_cross_signing_verify_key(\n        self, user_id: str, key_type: str, from_user_id: Optional[str] = None\n    ) -> Tuple[JsonMapping, str, VerifyKey]:\n        \"\"\"Fetch locally or remotely query for a cross-signing public key.\n\n        First, attempt to fetch the cross-signing public key from storage.\n        If that fails, query the keys from the homeserver they belong to\n        and update our local copy.\n\n        Args:\n            user_id: the user whose key should be fetched\n            key_type: the type of key to fetch\n            from_user_id: the user that we are fetching the keys for.\n                This affects what signatures are fetched.\n\n        Returns:\n            The raw key data, the key ID, and the signedjson verify key\n\n        Raises:\n            NotFoundError: if the key is not found\n            SynapseError: if `user_id` is invalid\n        \"\"\"\n        user = UserID.from_string(user_id)\n        key = await self.store.get_e2e_cross_signing_key(\n            user_id, key_type, from_user_id\n        )\n\n        if key:\n            # We found a copy of this key in our database. Decode and return it\n            key_id, verify_key = get_verify_key_from_cross_signing_key(key)\n            return key, key_id, verify_key\n\n        # If we couldn't find the key locally, and we're looking for keys of\n        # another user then attempt to fetch the missing key from the remote\n        # user's server.\n        #\n        # We may run into this in possible edge cases where a user tries to\n        # cross-sign a remote user, but does not share any rooms with them yet.\n        # Thus, we would not have their key list yet. We instead fetch the key,\n        # store it and notify clients of new, associated device IDs.\n        if self.is_mine(user) or key_type not in [\"master\", \"self_signing\"]:\n            # Note that master and self_signing keys are the only cross-signing keys we\n            # can request over federation\n            raise NotFoundError(\"No %s key found for %s\" % (key_type, user_id))\n\n        cross_signing_keys = await self._retrieve_cross_signing_keys_for_remote_user(\n            user, key_type\n        )\n        if cross_signing_keys is None:\n            raise NotFoundError(\"No %s key found for %s\" % (key_type, user_id))\n\n        return cross_signing_keys\n\n    async def _retrieve_cross_signing_keys_for_remote_user(\n        self,\n        user: UserID,\n        desired_key_type: str,\n    ) -> Optional[Tuple[JsonMapping, str, VerifyKey]]:\n        \"\"\"Queries cross-signing keys for a remote user and saves them to the database\n\n        Only the key specified by `key_type` will be returned, while all retrieved keys\n        will be saved regardless\n\n        Args:\n            user: The user to query remote keys for\n            desired_key_type: The type of key to receive. One of \"master\", \"self_signing\"\n\n        Returns:\n            A tuple of the retrieved key content, the key's ID and the matching VerifyKey.\n            If the key cannot be retrieved, all values in the tuple will instead be None.\n        \"\"\"\n        # This can only be called from the main process.\n        assert isinstance(self.device_handler, DeviceHandler)\n\n        try:\n            remote_result = await self.federation.query_user_devices(\n                user.domain, user.to_string()\n            )\n        except Exception as e:\n            logger.warning(\n                \"Unable to query %s for cross-signing keys of user %s: %s %s\",\n                user.domain,\n                user.to_string(),\n                type(e),\n                e,\n            )\n            return None\n\n        # Process each of the retrieved cross-signing keys\n        desired_key_data = None\n        retrieved_device_ids = []\n        for key_type in [\"master\", \"self_signing\"]:\n            key_content = remote_result.get(key_type + \"_key\")\n            if not key_content:\n                continue\n\n            # Ensure these keys belong to the correct user\n            if \"user_id\" not in key_content:\n                logger.warning(\n                    \"Invalid %s key retrieved, missing user_id field: %s\",\n                    key_type,\n                    key_content,\n                )\n                continue\n            if user.to_string() != key_content[\"user_id\"]:\n                logger.warning(\n                    \"Found %s key of user %s when querying for keys of user %s\",\n                    key_type,\n                    key_content[\"user_id\"],\n                    user.to_string(),\n                )\n                continue\n\n            # Validate the key contents\n            try:\n                # verify_key is a VerifyKey from signedjson, which uses\n                # .version to denote the portion of the key ID after the\n                # algorithm and colon, which is the device ID\n                key_id, verify_key = get_verify_key_from_cross_signing_key(key_content)\n            except ValueError as e:\n                logger.warning(\n                    \"Invalid %s key retrieved: %s - %s %s\",\n                    key_type,\n                    key_content,\n                    type(e),\n                    e,\n                )\n                continue\n\n            # Note down the device ID attached to this key\n            retrieved_device_ids.append(verify_key.version)\n\n            # If this is the desired key type, save it and its ID/VerifyKey\n            if key_type == desired_key_type:\n                desired_key_data = key_content, key_id, verify_key\n\n            # At the same time, store this key in the db for subsequent queries\n            await self.store.set_e2e_cross_signing_key(\n                user.to_string(), key_type, key_content\n            )\n\n        # Notify clients that new devices for this user have been discovered\n        if retrieved_device_ids:\n            # XXX is this necessary?\n            await self.device_handler.notify_device_update(\n                user.to_string(), retrieved_device_ids\n            )\n\n        return desired_key_data\n\n    async def is_cross_signing_set_up_for_user(self, user_id: str) -> bool:\n        \"\"\"Checks if the user has cross-signing set up\n\n        Args:\n            user_id: The user to check\n\n        Returns:\n            True if the user has cross-signing set up, False otherwise\n        \"\"\"\n        existing_master_key = await self.store.get_e2e_cross_signing_key(\n            user_id, \"master\"\n        )\n        return existing_master_key is not None\n\n\ndef _check_cross_signing_key(\n    key: JsonDict, user_id: str, key_type: str, signing_key: Optional[VerifyKey] = None\n) -> None:\n    \"\"\"Check a cross-signing key uploaded by a user.  Performs some basic sanity\n    checking, and ensures that it is signed, if a signature is required.\n\n    Args:\n        key: the key data to verify\n        user_id: the user whose key is being checked\n        key_type: the type of key that the key should be\n        signing_key: the signing key that the key should be signed with.  If\n            omitted, signatures will not be checked.\n    \"\"\"\n    if (\n        key.get(\"user_id\") != user_id\n        or key_type not in key.get(\"usage\", [])\n        or len(key.get(\"keys\", {})) != 1\n    ):\n        raise SynapseError(400, (\"Invalid %s key\" % (key_type,)), Codes.INVALID_PARAM)\n\n    if signing_key:\n        try:\n            verify_signed_json(key, user_id, signing_key)\n        except SignatureVerifyException:\n            raise SynapseError(\n                400, (\"Invalid signature on %s key\" % key_type), Codes.INVALID_SIGNATURE\n            )\n\n\ndef _check_device_signature(\n    user_id: str,\n    verify_key: VerifyKey,\n    signed_device: JsonDict,\n    stored_device: JsonMapping,\n) -> None:\n    \"\"\"Check that a signature on a device or cross-signing key is correct and\n    matches the copy of the device/key that we have stored.  Throws an\n    exception if an error is detected.\n\n    Args:\n        user_id: the user ID whose signature is being checked\n        verify_key: the key to verify the device with\n        signed_device: the uploaded signed device data\n        stored_device: our previously stored copy of the device\n\n    Raises:\n        SynapseError: if the signature was invalid or the sent device is not the\n            same as the stored device\n\n    \"\"\"\n\n    # make sure that the device submitted matches what we have stored\n    stripped_signed_device = {\n        k: v for k, v in signed_device.items() if k not in [\"signatures\", \"unsigned\"]\n    }\n    stripped_stored_device = {\n        k: v for k, v in stored_device.items() if k not in [\"signatures\", \"unsigned\"]\n    }\n    if stripped_signed_device != stripped_stored_device:\n        logger.debug(\n            \"upload signatures: key does not match %s vs %s\",\n            signed_device,\n            stored_device,\n        )\n        raise SynapseError(400, \"Key does not match\")\n\n    try:\n        verify_signed_json(signed_device, user_id, verify_key)\n    except SignatureVerifyException:\n        logger.debug(\"invalid signature on key\")\n        raise SynapseError(400, \"Invalid signature\", Codes.INVALID_SIGNATURE)\n\n\ndef _exception_to_failure(e: Exception) -> JsonDict:\n    if isinstance(e, SynapseError):\n        return {\"status\": e.code, \"errcode\": e.errcode, \"message\": str(e)}\n\n    if isinstance(e, CodeMessageException):\n        return {\"status\": e.code, \"message\": str(e)}\n\n    if isinstance(e, NotRetryingDestination):\n        return {\"status\": 503, \"message\": \"Not ready for retry\"}\n\n    # include ConnectionRefused and other errors\n    #\n    # Note that some Exceptions (notably twisted's ResponseFailed etc) don't\n    # give a string for e.message, which json then fails to serialize.\n    return {\"status\": 503, \"message\": str(e)}\n\n\ndef _one_time_keys_match(old_key_json: str, new_key: JsonDict) -> bool:\n    old_key = json_decoder.decode(old_key_json)\n\n    # if either is a string rather than an object, they must match exactly\n    if not isinstance(old_key, dict) or not isinstance(new_key, dict):\n        return old_key == new_key\n\n    # otherwise, we strip off the 'signatures' if any, because it's legitimate\n    # for different upload attempts to have different signatures.\n    old_key.pop(\"signatures\", None)\n    new_key_copy = dict(new_key)\n    new_key_copy.pop(\"signatures\", None)\n\n    return old_key == new_key_copy\n\n\n@attr.s(slots=True, auto_attribs=True)\nclass SignatureListItem:\n    \"\"\"An item in the signature list as used by upload_signatures_for_device_keys.\"\"\"\n\n    signing_key_id: str\n    target_user_id: str\n    target_device_id: str\n    signature: JsonDict\n\n\nclass SigningKeyEduUpdater:\n    \"\"\"Handles incoming signing key updates from federation and updates the DB\"\"\"\n\n    def __init__(self, hs: \"HomeServer\"):\n        self.store = hs.get_datastores().main\n        self.federation = hs.get_federation_client()\n        self.clock = hs.get_clock()\n\n        device_handler = hs.get_device_handler()\n        assert isinstance(device_handler, DeviceHandler)\n        self._device_handler = device_handler\n\n        self._remote_edu_linearizer = Linearizer(name=\"remote_signing_key\")\n\n        # user_id -> list of updates waiting to be handled.\n        self._pending_updates: Dict[str, List[Tuple[JsonDict, JsonDict]]] = {}\n\n    async def incoming_signing_key_update(\n        self, origin: str, edu_content: JsonDict\n    ) -> None:\n        \"\"\"Called on incoming signing key update from federation. Responsible for\n        parsing the EDU and adding to pending updates list.\n\n        Args:\n            origin: the server that sent the EDU\n            edu_content: the contents of the EDU\n        \"\"\"\n\n        user_id = edu_content.pop(\"user_id\")\n        master_key = edu_content.pop(\"master_key\", None)\n        self_signing_key = edu_content.pop(\"self_signing_key\", None)\n\n        if get_domain_from_id(user_id) != origin:\n            logger.warning(\"Got signing key update edu for %r from %r\", user_id, origin)\n            return\n\n        room_ids = await self.store.get_rooms_for_user(user_id)\n        if not room_ids:\n            # We don't share any rooms with this user. Ignore update, as we\n            # probably won't get any further updates.\n            return\n\n        self._pending_updates.setdefault(user_id, []).append(\n            (master_key, self_signing_key)\n        )\n\n        await self._handle_signing_key_updates(user_id)\n\n    async def _handle_signing_key_updates(self, user_id: str) -> None:\n        \"\"\"Actually handle pending updates.\n\n        Args:\n            user_id: the user whose updates we are processing\n        \"\"\"\n\n        async with self._remote_edu_linearizer.queue(user_id):\n            pending_updates = self._pending_updates.pop(user_id, [])\n            if not pending_updates:\n                # This can happen since we batch updates\n                return\n\n            device_ids: List[str] = []\n\n            logger.info(\"pending updates: %r\", pending_updates)\n\n            for master_key, self_signing_key in pending_updates:\n                new_device_ids = await self._device_handler.device_list_updater.process_cross_signing_key_update(\n                    user_id,\n                    master_key,\n                    self_signing_key,\n                )\n                device_ids = device_ids + new_device_ids\n\n            await self._device_handler.notify_device_update(user_id, device_ids)\n"], "fixing_code": ["# Copyright 2015, 2016 OpenMarket Ltd\n# Copyright 2018 New Vector Ltd\n# Copyright 2019-2021 Matrix.org Federation C.I.C\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport logging\nimport random\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Awaitable,\n    Callable,\n    Collection,\n    Dict,\n    List,\n    Mapping,\n    Optional,\n    Tuple,\n    Union,\n)\n\nfrom prometheus_client import Counter, Gauge, Histogram\n\nfrom twisted.python import failure\n\nfrom synapse.api.constants import (\n    Direction,\n    EduTypes,\n    EventContentFields,\n    EventTypes,\n    Membership,\n)\nfrom synapse.api.errors import (\n    AuthError,\n    Codes,\n    FederationError,\n    IncompatibleRoomVersionError,\n    NotFoundError,\n    PartialStateConflictError,\n    SynapseError,\n    UnsupportedRoomVersionError,\n)\nfrom synapse.api.room_versions import KNOWN_ROOM_VERSIONS, RoomVersion\nfrom synapse.crypto.event_signing import compute_event_signature\nfrom synapse.events import EventBase\nfrom synapse.events.snapshot import EventContext\nfrom synapse.federation.federation_base import (\n    FederationBase,\n    InvalidEventSignatureError,\n    event_from_pdu_json,\n)\nfrom synapse.federation.persistence import TransactionActions\nfrom synapse.federation.units import Edu, Transaction\nfrom synapse.handlers.worker_lock import NEW_EVENT_DURING_PURGE_LOCK_NAME\nfrom synapse.http.servlet import assert_params_in_dict\nfrom synapse.logging.context import (\n    make_deferred_yieldable,\n    nested_logging_context,\n    run_in_background,\n)\nfrom synapse.logging.opentracing import (\n    SynapseTags,\n    log_kv,\n    set_tag,\n    start_active_span_from_edu,\n    tag_args,\n    trace,\n)\nfrom synapse.metrics.background_process_metrics import wrap_as_background_process\nfrom synapse.replication.http.federation import (\n    ReplicationFederationSendEduRestServlet,\n    ReplicationGetQueryRestServlet,\n)\nfrom synapse.storage.databases.main.lock import Lock\nfrom synapse.storage.databases.main.roommember import extract_heroes_from_room_summary\nfrom synapse.storage.roommember import MemberSummary\nfrom synapse.types import JsonDict, StateMap, get_domain_from_id, UserID\nfrom synapse.util import unwrapFirstError\nfrom synapse.util.async_helpers import Linearizer, concurrently_execute, gather_results\nfrom synapse.util.caches.response_cache import ResponseCache\nfrom synapse.util.stringutils import parse_server_name\n\nif TYPE_CHECKING:\n    from synapse.server import HomeServer\n\n# when processing incoming transactions, we try to handle multiple rooms in\n# parallel, up to this limit.\nTRANSACTION_CONCURRENCY_LIMIT = 10\n\nlogger = logging.getLogger(__name__)\n\nreceived_pdus_counter = Counter(\"synapse_federation_server_received_pdus\", \"\")\n\nreceived_edus_counter = Counter(\"synapse_federation_server_received_edus\", \"\")\n\nreceived_queries_counter = Counter(\n    \"synapse_federation_server_received_queries\", \"\", [\"type\"]\n)\n\npdu_process_time = Histogram(\n    \"synapse_federation_server_pdu_process_time\",\n    \"Time taken to process an event\",\n)\n\nlast_pdu_ts_metric = Gauge(\n    \"synapse_federation_last_received_pdu_time\",\n    \"The timestamp of the last PDU which was successfully received from the given domain\",\n    labelnames=(\"server_name\",),\n)\n\n\n# The name of the lock to use when process events in a room received over\n# federation.\n_INBOUND_EVENT_HANDLING_LOCK_NAME = \"federation_inbound_pdu\"\n\n\nclass FederationServer(FederationBase):\n    def __init__(self, hs: \"HomeServer\"):\n        super().__init__(hs)\n\n        self.server_name = hs.hostname\n        self.handler = hs.get_federation_handler()\n        self._spam_checker_module_callbacks = hs.get_module_api_callbacks().spam_checker\n        self._federation_event_handler = hs.get_federation_event_handler()\n        self.state = hs.get_state_handler()\n        self._event_auth_handler = hs.get_event_auth_handler()\n        self._room_member_handler = hs.get_room_member_handler()\n        self._e2e_keys_handler = hs.get_e2e_keys_handler()\n        self._worker_lock_handler = hs.get_worker_locks_handler()\n\n        self._state_storage_controller = hs.get_storage_controllers().state\n\n        self.device_handler = hs.get_device_handler()\n\n        # Ensure the following handlers are loaded since they register callbacks\n        # with FederationHandlerRegistry.\n        hs.get_directory_handler()\n\n        self._server_linearizer = Linearizer(\"fed_server\")\n\n        # origins that we are currently processing a transaction from.\n        # a dict from origin to txn id.\n        self._active_transactions: Dict[str, str] = {}\n\n        # We cache results for transaction with the same ID\n        self._transaction_resp_cache: ResponseCache[Tuple[str, str]] = ResponseCache(\n            hs.get_clock(), \"fed_txn_handler\", timeout_ms=30000\n        )\n\n        self.transaction_actions = TransactionActions(self.store)\n\n        self.registry = hs.get_federation_registry()\n\n        # We cache responses to state queries, as they take a while and often\n        # come in waves.\n        self._state_resp_cache: ResponseCache[\n            Tuple[str, Optional[str]]\n        ] = ResponseCache(hs.get_clock(), \"state_resp\", timeout_ms=30000)\n        self._state_ids_resp_cache: ResponseCache[Tuple[str, str]] = ResponseCache(\n            hs.get_clock(), \"state_ids_resp\", timeout_ms=30000\n        )\n\n        self._federation_metrics_domains = (\n            hs.config.federation.federation_metrics_domains\n        )\n\n        self._room_prejoin_state_types = hs.config.api.room_prejoin_state\n\n        # Whether we have started handling old events in the staging area.\n        self._started_handling_of_staged_events = False\n\n    @wrap_as_background_process(\"_handle_old_staged_events\")\n    async def _handle_old_staged_events(self) -> None:\n        \"\"\"Handle old staged events by fetching all rooms that have staged\n        events and start the processing of each of those rooms.\n        \"\"\"\n\n        # Get all the rooms IDs with staged events.\n        room_ids = await self.store.get_all_rooms_with_staged_incoming_events()\n\n        # We then shuffle them so that if there are multiple instances doing\n        # this work they're less likely to collide.\n        random.shuffle(room_ids)\n\n        for room_id in room_ids:\n            room_version = await self.store.get_room_version(room_id)\n\n            # Try and acquire the processing lock for the room, if we get it start a\n            # background process for handling the events in the room.\n            lock = await self.store.try_acquire_lock(\n                _INBOUND_EVENT_HANDLING_LOCK_NAME, room_id\n            )\n            if lock:\n                logger.info(\"Handling old staged inbound events in %s\", room_id)\n                self._process_incoming_pdus_in_room_inner(\n                    room_id,\n                    room_version,\n                    lock,\n                )\n\n            # We pause a bit so that we don't start handling all rooms at once.\n            await self._clock.sleep(random.uniform(0, 0.1))\n\n    async def on_backfill_request(\n        self, origin: str, room_id: str, versions: List[str], limit: int\n    ) -> Tuple[int, Dict[str, Any]]:\n        async with self._server_linearizer.queue((origin, room_id)):\n            origin_host, _ = parse_server_name(origin)\n            await self.check_server_matches_acl(origin_host, room_id)\n\n            pdus = await self.handler.on_backfill_request(\n                origin, room_id, versions, limit\n            )\n\n            res = self._transaction_dict_from_pdus(pdus)\n\n        return 200, res\n\n    async def on_timestamp_to_event_request(\n        self, origin: str, room_id: str, timestamp: int, direction: Direction\n    ) -> Tuple[int, Dict[str, Any]]:\n        \"\"\"When we receive a federated `/timestamp_to_event` request,\n        handle all of the logic for validating and fetching the event.\n\n        Args:\n            origin: The server we received the event from\n            room_id: Room to fetch the event from\n            timestamp: The point in time (inclusive) we should navigate from in\n                the given direction to find the closest event.\n            direction: indicates whether we should navigate forward\n                or backward from the given timestamp to find the closest event.\n\n        Returns:\n            Tuple indicating the response status code and dictionary response\n            body including `event_id`.\n        \"\"\"\n        async with self._server_linearizer.queue((origin, room_id)):\n            origin_host, _ = parse_server_name(origin)\n            await self.check_server_matches_acl(origin_host, room_id)\n\n            # We only try to fetch data from the local database\n            event_id = await self.store.get_event_id_for_timestamp(\n                room_id, timestamp, direction\n            )\n            if event_id:\n                event = await self.store.get_event(\n                    event_id, allow_none=False, allow_rejected=False\n                )\n\n                return 200, {\n                    \"event_id\": event_id,\n                    \"origin_server_ts\": event.origin_server_ts,\n                }\n\n        raise SynapseError(\n            404,\n            \"Unable to find event from %s in direction %s\" % (timestamp, direction),\n            errcode=Codes.NOT_FOUND,\n        )\n\n    async def on_incoming_transaction(\n        self,\n        origin: str,\n        transaction_id: str,\n        destination: str,\n        transaction_data: JsonDict,\n    ) -> Tuple[int, JsonDict]:\n        # If we receive a transaction we should make sure that kick off handling\n        # any old events in the staging area.\n        if not self._started_handling_of_staged_events:\n            self._started_handling_of_staged_events = True\n            self._handle_old_staged_events()\n\n            # Start a periodic check for old staged events. This is to handle\n            # the case where locks time out, e.g. if another process gets killed\n            # without dropping its locks.\n            self._clock.looping_call(self._handle_old_staged_events, 60 * 1000)\n\n        # keep this as early as possible to make the calculated origin ts as\n        # accurate as possible.\n        request_time = self._clock.time_msec()\n\n        transaction = Transaction(\n            transaction_id=transaction_id,\n            destination=destination,\n            origin=origin,\n            origin_server_ts=transaction_data.get(\"origin_server_ts\"),  # type: ignore[arg-type]\n            pdus=transaction_data.get(\"pdus\"),\n            edus=transaction_data.get(\"edus\"),\n        )\n\n        if not transaction_id:\n            raise Exception(\"Transaction missing transaction_id\")\n\n        logger.debug(\"[%s] Got transaction\", transaction_id)\n\n        # Reject malformed transactions early: reject if too many PDUs/EDUs\n        if len(transaction.pdus) > 50 or len(transaction.edus) > 100:\n            logger.info(\"Transaction PDU or EDU count too large. Returning 400\")\n            return 400, {}\n\n        # we only process one transaction from each origin at a time. We need to do\n        # this check here, rather than in _on_incoming_transaction_inner so that we\n        # don't cache the rejection in _transaction_resp_cache (so that if the txn\n        # arrives again later, we can process it).\n        current_transaction = self._active_transactions.get(origin)\n        if current_transaction and current_transaction != transaction_id:\n            logger.warning(\n                \"Received another txn %s from %s while still processing %s\",\n                transaction_id,\n                origin,\n                current_transaction,\n            )\n            return 429, {\n                \"errcode\": Codes.UNKNOWN,\n                \"error\": \"Too many concurrent transactions\",\n            }\n\n        # CRITICAL SECTION: we must now not await until we populate _active_transactions\n        # in _on_incoming_transaction_inner.\n\n        # We wrap in a ResponseCache so that we de-duplicate retried\n        # transactions.\n        return await self._transaction_resp_cache.wrap(\n            (origin, transaction_id),\n            self._on_incoming_transaction_inner,\n            origin,\n            transaction,\n            request_time,\n        )\n\n    async def _on_incoming_transaction_inner(\n        self, origin: str, transaction: Transaction, request_time: int\n    ) -> Tuple[int, Dict[str, Any]]:\n        # CRITICAL SECTION: the first thing we must do (before awaiting) is\n        # add an entry to _active_transactions.\n        assert origin not in self._active_transactions\n        self._active_transactions[origin] = transaction.transaction_id\n\n        try:\n            result = await self._handle_incoming_transaction(\n                origin, transaction, request_time\n            )\n            return result\n        finally:\n            del self._active_transactions[origin]\n\n    async def _handle_incoming_transaction(\n        self, origin: str, transaction: Transaction, request_time: int\n    ) -> Tuple[int, Dict[str, Any]]:\n        \"\"\"Process an incoming transaction and return the HTTP response\n\n        Args:\n            origin: the server making the request\n            transaction: incoming transaction\n            request_time: timestamp that the HTTP request arrived at\n\n        Returns:\n            HTTP response code and body\n        \"\"\"\n        existing_response = await self.transaction_actions.have_responded(\n            origin, transaction\n        )\n\n        if existing_response:\n            logger.debug(\n                \"[%s] We've already responded to this request\",\n                transaction.transaction_id,\n            )\n            return existing_response\n\n        logger.debug(\"[%s] Transaction is new\", transaction.transaction_id)\n\n        # We process PDUs and EDUs in parallel. This is important as we don't\n        # want to block things like to device messages from reaching clients\n        # behind the potentially expensive handling of PDUs.\n        pdu_results, _ = await make_deferred_yieldable(\n            gather_results(\n                (\n                    run_in_background(\n                        self._handle_pdus_in_txn, origin, transaction, request_time\n                    ),\n                    run_in_background(self._handle_edus_in_txn, origin, transaction),\n                ),\n                consumeErrors=True,\n            ).addErrback(unwrapFirstError)\n        )\n\n        response = {\"pdus\": pdu_results}\n\n        logger.debug(\"Returning: %s\", str(response))\n\n        await self.transaction_actions.set_response(origin, transaction, 200, response)\n        return 200, response\n\n    async def _handle_pdus_in_txn(\n        self, origin: str, transaction: Transaction, request_time: int\n    ) -> Dict[str, dict]:\n        \"\"\"Process the PDUs in a received transaction.\n\n        Args:\n            origin: the server making the request\n            transaction: incoming transaction\n            request_time: timestamp that the HTTP request arrived at\n\n        Returns:\n            A map from event ID of a processed PDU to any errors we should\n            report back to the sending server.\n        \"\"\"\n\n        received_pdus_counter.inc(len(transaction.pdus))\n\n        origin_host, _ = parse_server_name(origin)\n\n        pdus_by_room: Dict[str, List[EventBase]] = {}\n\n        newest_pdu_ts = 0\n\n        for p in transaction.pdus:\n            # FIXME (richardv): I don't think this works:\n            #  https://github.com/matrix-org/synapse/issues/8429\n            if \"unsigned\" in p:\n                unsigned = p[\"unsigned\"]\n                if \"age\" in unsigned:\n                    p[\"age\"] = unsigned[\"age\"]\n            if \"age\" in p:\n                p[\"age_ts\"] = request_time - int(p[\"age\"])\n                del p[\"age\"]\n\n            # We try and pull out an event ID so that if later checks fail we\n            # can log something sensible. We don't mandate an event ID here in\n            # case future event formats get rid of the key.\n            possible_event_id = p.get(\"event_id\", \"<Unknown>\")\n\n            # Now we get the room ID so that we can check that we know the\n            # version of the room.\n            room_id = p.get(\"room_id\")\n            if not room_id:\n                logger.info(\n                    \"Ignoring PDU as does not have a room_id. Event ID: %s\",\n                    possible_event_id,\n                )\n                continue\n\n            try:\n                room_version = await self.store.get_room_version(room_id)\n            except NotFoundError:\n                logger.info(\"Ignoring PDU for unknown room_id: %s\", room_id)\n                continue\n            except UnsupportedRoomVersionError as e:\n                # this can happen if support for a given room version is withdrawn,\n                # so that we still get events for said room.\n                logger.info(\"Ignoring PDU: %s\", e)\n                continue\n\n            event = event_from_pdu_json(p, room_version)\n            pdus_by_room.setdefault(room_id, []).append(event)\n\n            if event.origin_server_ts > newest_pdu_ts:\n                newest_pdu_ts = event.origin_server_ts\n\n        pdu_results = {}\n\n        # we can process different rooms in parallel (which is useful if they\n        # require callouts to other servers to fetch missing events), but\n        # impose a limit to avoid going too crazy with ram/cpu.\n\n        async def process_pdus_for_room(room_id: str) -> None:\n            with nested_logging_context(room_id):\n                logger.debug(\"Processing PDUs for %s\", room_id)\n\n                try:\n                    await self.check_server_matches_acl(origin_host, room_id)\n                except AuthError as e:\n                    logger.warning(\n                        \"Ignoring PDUs for room %s from banned server\", room_id\n                    )\n                    for pdu in pdus_by_room[room_id]:\n                        event_id = pdu.event_id\n                        pdu_results[event_id] = e.error_dict(self.hs.config)\n                    return\n\n                for pdu in pdus_by_room[room_id]:\n                    pdu_results[pdu.event_id] = await process_pdu(pdu)\n\n        async def process_pdu(pdu: EventBase) -> JsonDict:\n            \"\"\"\n            Processes a pushed PDU sent to us via a `/send` transaction\n\n            Returns:\n                JsonDict representing a \"PDU Processing Result\" that will be bundled up\n                with the other processed PDU's in the `/send` transaction and sent back\n                to remote homeserver.\n            \"\"\"\n            event_id = pdu.event_id\n            with nested_logging_context(event_id):\n                try:\n                    await self._handle_received_pdu(origin, pdu)\n                    return {}\n                except FederationError as e:\n                    logger.warning(\"Error handling PDU %s: %s\", event_id, e)\n                    return {\"error\": str(e)}\n                except Exception as e:\n                    f = failure.Failure()\n                    logger.error(\n                        \"Failed to handle PDU %s\",\n                        event_id,\n                        exc_info=(f.type, f.value, f.getTracebackObject()),\n                    )\n                    return {\"error\": str(e)}\n\n        await concurrently_execute(\n            process_pdus_for_room, pdus_by_room.keys(), TRANSACTION_CONCURRENCY_LIMIT\n        )\n\n        if newest_pdu_ts and origin in self._federation_metrics_domains:\n            last_pdu_ts_metric.labels(server_name=origin).set(newest_pdu_ts / 1000)\n\n        return pdu_results\n\n    async def _handle_edus_in_txn(self, origin: str, transaction: Transaction) -> None:\n        \"\"\"Process the EDUs in a received transaction.\"\"\"\n\n        async def _process_edu(edu_dict: JsonDict) -> None:\n            received_edus_counter.inc()\n\n            edu = Edu(\n                origin=origin,\n                destination=self.server_name,\n                edu_type=edu_dict[\"edu_type\"],\n                content=edu_dict[\"content\"],\n            )\n            await self.registry.on_edu(edu.edu_type, origin, edu.content)\n\n        await concurrently_execute(\n            _process_edu,\n            transaction.edus,\n            TRANSACTION_CONCURRENCY_LIMIT,\n        )\n\n    async def on_room_state_request(\n        self, origin: str, room_id: str, event_id: str\n    ) -> Tuple[int, JsonDict]:\n        await self._event_auth_handler.assert_host_in_room(room_id, origin)\n        origin_host, _ = parse_server_name(origin)\n        await self.check_server_matches_acl(origin_host, room_id)\n\n        # we grab the linearizer to protect ourselves from servers which hammer\n        # us. In theory we might already have the response to this query\n        # in the cache so we could return it without waiting for the linearizer\n        # - but that's non-trivial to get right, and anyway somewhat defeats\n        # the point of the linearizer.\n        async with self._server_linearizer.queue((origin, room_id)):\n            resp = await self._state_resp_cache.wrap(\n                (room_id, event_id),\n                self._on_context_state_request_compute,\n                room_id,\n                event_id,\n            )\n\n        return 200, resp\n\n    @trace\n    @tag_args\n    async def on_state_ids_request(\n        self, origin: str, room_id: str, event_id: str\n    ) -> Tuple[int, JsonDict]:\n        if not event_id:\n            raise NotImplementedError(\"Specify an event\")\n\n        await self._event_auth_handler.assert_host_in_room(room_id, origin)\n        origin_host, _ = parse_server_name(origin)\n        await self.check_server_matches_acl(origin_host, room_id)\n\n        resp = await self._state_ids_resp_cache.wrap(\n            (room_id, event_id),\n            self._on_state_ids_request_compute,\n            room_id,\n            event_id,\n        )\n\n        return 200, resp\n\n    @trace\n    @tag_args\n    async def _on_state_ids_request_compute(\n        self, room_id: str, event_id: str\n    ) -> JsonDict:\n        state_ids = await self.handler.get_state_ids_for_pdu(room_id, event_id)\n        auth_chain_ids = await self.store.get_auth_chain_ids(room_id, state_ids)\n        return {\"pdu_ids\": state_ids, \"auth_chain_ids\": list(auth_chain_ids)}\n\n    async def _on_context_state_request_compute(\n        self, room_id: str, event_id: str\n    ) -> Dict[str, list]:\n        pdus: Collection[EventBase]\n        event_ids = await self.handler.get_state_ids_for_pdu(room_id, event_id)\n        pdus = await self.store.get_events_as_list(event_ids)\n\n        auth_chain = await self.store.get_auth_chain(\n            room_id, [pdu.event_id for pdu in pdus]\n        )\n\n        return {\n            \"pdus\": [pdu.get_pdu_json() for pdu in pdus],\n            \"auth_chain\": [pdu.get_pdu_json() for pdu in auth_chain],\n        }\n\n    async def on_pdu_request(\n        self, origin: str, event_id: str\n    ) -> Tuple[int, Union[JsonDict, str]]:\n        pdu = await self.handler.get_persisted_pdu(origin, event_id)\n\n        if pdu:\n            return 200, self._transaction_dict_from_pdus([pdu])\n        else:\n            return 404, \"\"\n\n    async def on_query_request(\n        self, query_type: str, args: Dict[str, str]\n    ) -> Tuple[int, Dict[str, Any]]:\n        received_queries_counter.labels(query_type).inc()\n        resp = await self.registry.on_query(query_type, args)\n        return 200, resp\n\n    async def on_make_join_request(\n        self, origin: str, room_id: str, user_id: str, supported_versions: List[str]\n    ) -> Dict[str, Any]:\n        origin_host, _ = parse_server_name(origin)\n        await self.check_server_matches_acl(origin_host, room_id)\n\n        room_version = await self.store.get_room_version_id(room_id)\n        if room_version not in supported_versions:\n            logger.warning(\n                \"Room version %s not in %s\", room_version, supported_versions\n            )\n            raise IncompatibleRoomVersionError(room_version=room_version)\n\n        # Refuse the request if that room has seen too many joins recently.\n        # This is in addition to the HS-level rate limiting applied by\n        # BaseFederationServlet.\n        # type-ignore: mypy doesn't seem able to deduce the type of the limiter(!?)\n        await self._room_member_handler._join_rate_per_room_limiter.ratelimit(  # type: ignore[has-type]\n            requester=None,\n            key=room_id,\n            update=False,\n        )\n        pdu = await self.handler.on_make_join_request(origin, room_id, user_id)\n        return {\"event\": pdu.get_templated_pdu_json(), \"room_version\": room_version}\n\n    async def on_invite_request(\n        self, origin: str, content: JsonDict, room_version_id: str\n    ) -> Dict[str, Any]:\n        room_version = KNOWN_ROOM_VERSIONS.get(room_version_id)\n        if not room_version:\n            raise SynapseError(\n                400,\n                \"Homeserver does not support this room version\",\n                Codes.UNSUPPORTED_ROOM_VERSION,\n            )\n\n        pdu = event_from_pdu_json(content, room_version)\n        origin_host, _ = parse_server_name(origin)\n        await self.check_server_matches_acl(origin_host, pdu.room_id)\n        try:\n            pdu = await self._check_sigs_and_hash(room_version, pdu)\n        except InvalidEventSignatureError as e:\n            errmsg = f\"event id {pdu.event_id}: {e}\"\n            logger.warning(\"%s\", errmsg)\n            raise SynapseError(403, errmsg, Codes.FORBIDDEN)\n        ret_pdu = await self.handler.on_invite_request(origin, pdu, room_version)\n        time_now = self._clock.time_msec()\n        return {\"event\": ret_pdu.get_pdu_json(time_now)}\n\n    async def on_send_join_request(\n        self,\n        origin: str,\n        content: JsonDict,\n        room_id: str,\n        caller_supports_partial_state: bool = False,\n    ) -> Dict[str, Any]:\n        set_tag(\n            SynapseTags.SEND_JOIN_RESPONSE_IS_PARTIAL_STATE,\n            caller_supports_partial_state,\n        )\n        await self._room_member_handler._join_rate_per_room_limiter.ratelimit(  # type: ignore[has-type]\n            requester=None,\n            key=room_id,\n            update=False,\n        )\n\n        event, context = await self._on_send_membership_event(\n            origin, content, Membership.JOIN, room_id\n        )\n\n        prev_state_ids = await context.get_prev_state_ids()\n\n        state_event_ids: Collection[str]\n        servers_in_room: Optional[Collection[str]]\n        if caller_supports_partial_state:\n            summary = await self.store.get_room_summary(room_id)\n            state_event_ids = _get_event_ids_for_partial_state_join(\n                event, prev_state_ids, summary\n            )\n            servers_in_room = await self.state.get_hosts_in_room_at_events(\n                room_id, event_ids=event.prev_event_ids()\n            )\n        else:\n            state_event_ids = prev_state_ids.values()\n            servers_in_room = None\n\n        auth_chain_event_ids = await self.store.get_auth_chain_ids(\n            room_id, state_event_ids\n        )\n\n        # if the caller has opted in, we can omit any auth_chain events which are\n        # already in state_event_ids\n        if caller_supports_partial_state:\n            auth_chain_event_ids.difference_update(state_event_ids)\n\n        auth_chain_events = await self.store.get_events_as_list(auth_chain_event_ids)\n        state_events = await self.store.get_events_as_list(state_event_ids)\n\n        # we try to do all the async stuff before this point, so that time_now is as\n        # accurate as possible.\n        time_now = self._clock.time_msec()\n        event_json = event.get_pdu_json(time_now)\n        resp = {\n            \"event\": event_json,\n            \"state\": [p.get_pdu_json(time_now) for p in state_events],\n            \"auth_chain\": [p.get_pdu_json(time_now) for p in auth_chain_events],\n            \"members_omitted\": caller_supports_partial_state,\n        }\n\n        if servers_in_room is not None:\n            resp[\"servers_in_room\"] = list(servers_in_room)\n\n        return resp\n\n    async def on_make_leave_request(\n        self, origin: str, room_id: str, user_id: str\n    ) -> Dict[str, Any]:\n        origin_host, _ = parse_server_name(origin)\n        await self.check_server_matches_acl(origin_host, room_id)\n        pdu = await self.handler.on_make_leave_request(origin, room_id, user_id)\n\n        room_version = await self.store.get_room_version_id(room_id)\n\n        return {\"event\": pdu.get_templated_pdu_json(), \"room_version\": room_version}\n\n    async def on_send_leave_request(\n        self, origin: str, content: JsonDict, room_id: str\n    ) -> dict:\n        logger.debug(\"on_send_leave_request: content: %s\", content)\n        await self._on_send_membership_event(origin, content, Membership.LEAVE, room_id)\n        return {}\n\n    async def on_make_knock_request(\n        self, origin: str, room_id: str, user_id: str, supported_versions: List[str]\n    ) -> JsonDict:\n        \"\"\"We've received a /make_knock/ request, so we create a partial knock\n        event for the room and hand that back, along with the room version, to the knocking\n        homeserver. We do *not* persist or process this event until the other server has\n        signed it and sent it back.\n\n        Args:\n            origin: The (verified) server name of the requesting server.\n            room_id: The room to create the knock event in.\n            user_id: The user to create the knock for.\n            supported_versions: The room versions supported by the requesting server.\n\n        Returns:\n            The partial knock event.\n        \"\"\"\n        origin_host, _ = parse_server_name(origin)\n\n        if await self.store.is_partial_state_room(room_id):\n            # Before we do anything: check if the room is partial-stated.\n            # Note that at the time this check was added, `on_make_knock_request` would\n            # block due to https://github.com/matrix-org/synapse/issues/12997.\n            raise SynapseError(\n                404,\n                \"Unable to handle /make_knock right now; this server is not fully joined.\",\n                errcode=Codes.NOT_FOUND,\n            )\n\n        await self.check_server_matches_acl(origin_host, room_id)\n\n        room_version = await self.store.get_room_version(room_id)\n\n        # Check that this room version is supported by the remote homeserver\n        if room_version.identifier not in supported_versions:\n            logger.warning(\n                \"Room version %s not in %s\", room_version.identifier, supported_versions\n            )\n            raise IncompatibleRoomVersionError(room_version=room_version.identifier)\n\n        # Check that this room supports knocking as defined by its room version\n        if not room_version.knock_join_rule:\n            raise SynapseError(\n                403,\n                \"This room version does not support knocking\",\n                errcode=Codes.FORBIDDEN,\n            )\n\n        pdu = await self.handler.on_make_knock_request(origin, room_id, user_id)\n        return {\n            \"event\": pdu.get_templated_pdu_json(),\n            \"room_version\": room_version.identifier,\n        }\n\n    async def on_send_knock_request(\n        self,\n        origin: str,\n        content: JsonDict,\n        room_id: str,\n    ) -> Dict[str, List[JsonDict]]:\n        \"\"\"\n        We have received a knock event for a room. Verify and send the event into the room\n        on the knocking homeserver's behalf. Then reply with some stripped state from the\n        room for the knockee.\n\n        Args:\n            origin: The remote homeserver of the knocking user.\n            content: The content of the request.\n            room_id: The ID of the room to knock on.\n\n        Returns:\n            The stripped room state.\n        \"\"\"\n        _, context = await self._on_send_membership_event(\n            origin, content, Membership.KNOCK, room_id\n        )\n\n        # Retrieve stripped state events from the room and send them back to the remote\n        # server. This will allow the remote server's clients to display information\n        # related to the room while the knock request is pending.\n        stripped_room_state = (\n            await self.store.get_stripped_room_state_from_event_context(\n                context, self._room_prejoin_state_types\n            )\n        )\n        return {\"knock_room_state\": stripped_room_state}\n\n    async def _on_send_membership_event(\n        self, origin: str, content: JsonDict, membership_type: str, room_id: str\n    ) -> Tuple[EventBase, EventContext]:\n        \"\"\"Handle an on_send_{join,leave,knock} request\n\n        Does some preliminary validation before passing the request on to the\n        federation handler.\n\n        Args:\n            origin: The (authenticated) requesting server\n            content: The body of the send_* request - a complete membership event\n            membership_type: The expected membership type (join or leave, depending\n                on the endpoint)\n            room_id: The room_id from the request, to be validated against the room_id\n                in the event\n\n        Returns:\n            The event and context of the event after inserting it into the room graph.\n\n        Raises:\n            SynapseError if there is a problem with the request, including things like\n               the room_id not matching or the event not being authorized.\n        \"\"\"\n        assert_params_in_dict(content, [\"room_id\"])\n        if content[\"room_id\"] != room_id:\n            raise SynapseError(\n                400,\n                \"Room ID in body does not match that in request path\",\n                Codes.BAD_JSON,\n            )\n\n        # Note that get_room_version throws if the room does not exist here.\n        room_version = await self.store.get_room_version(room_id)\n\n        if await self.store.is_partial_state_room(room_id):\n            # If our server is still only partially joined, we can't give a complete\n            # response to /send_join, /send_knock or /send_leave.\n            # This is because we will not be able to provide the server list (for partial\n            # joins) or the full state (for full joins).\n            # Return a 404 as we would if we weren't in the room at all.\n            logger.info(\n                f\"Rejecting /send_{membership_type} to %s because it's a partial state room\",\n                room_id,\n            )\n            raise SynapseError(\n                404,\n                f\"Unable to handle /send_{membership_type} right now; this server is not fully joined.\",\n                errcode=Codes.NOT_FOUND,\n            )\n\n        if membership_type == Membership.KNOCK and not room_version.knock_join_rule:\n            raise SynapseError(\n                403,\n                \"This room version does not support knocking\",\n                errcode=Codes.FORBIDDEN,\n            )\n\n        event = event_from_pdu_json(content, room_version)\n\n        if event.type != EventTypes.Member or not event.is_state():\n            raise SynapseError(400, \"Not an m.room.member event\", Codes.BAD_JSON)\n\n        if event.content.get(\"membership\") != membership_type:\n            raise SynapseError(400, \"Not a %s event\" % membership_type, Codes.BAD_JSON)\n\n        origin_host, _ = parse_server_name(origin)\n        await self.check_server_matches_acl(origin_host, event.room_id)\n\n        logger.debug(\"_on_send_membership_event: pdu sigs: %s\", event.signatures)\n\n        # Sign the event since we're vouching on behalf of the remote server that\n        # the event is valid to be sent into the room. Currently this is only done\n        # if the user is being joined via restricted join rules.\n        if (\n            room_version.restricted_join_rule\n            and event.membership == Membership.JOIN\n            and EventContentFields.AUTHORISING_USER in event.content\n        ):\n            # We can only authorise our own users.\n            authorising_server = get_domain_from_id(\n                event.content[EventContentFields.AUTHORISING_USER]\n            )\n            if not self._is_mine_server_name(authorising_server):\n                raise SynapseError(\n                    400,\n                    f\"Cannot authorise membership event for {authorising_server}. We can only authorise requests from our own homeserver\",\n                )\n\n            event.signatures.update(\n                compute_event_signature(\n                    room_version,\n                    event.get_pdu_json(),\n                    self.hs.hostname,\n                    self.hs.signing_key,\n                )\n            )\n\n        try:\n            event = await self._check_sigs_and_hash(room_version, event)\n        except InvalidEventSignatureError as e:\n            errmsg = f\"event id {event.event_id}: {e}\"\n            logger.warning(\"%s\", errmsg)\n            raise SynapseError(403, errmsg, Codes.FORBIDDEN)\n\n        try:\n            return await self._federation_event_handler.on_send_membership_event(\n                origin, event\n            )\n        except PartialStateConflictError:\n            # The room was un-partial stated while we were persisting the event.\n            # Try once more, with full state this time.\n            logger.info(\n                \"Room %s was un-partial stated during `on_send_membership_event`, trying again.\",\n                room_id,\n            )\n            return await self._federation_event_handler.on_send_membership_event(\n                origin, event\n            )\n\n    async def on_event_auth(\n        self, origin: str, room_id: str, event_id: str\n    ) -> Tuple[int, Dict[str, Any]]:\n        async with self._server_linearizer.queue((origin, room_id)):\n            await self._event_auth_handler.assert_host_in_room(room_id, origin)\n            origin_host, _ = parse_server_name(origin)\n            await self.check_server_matches_acl(origin_host, room_id)\n\n            time_now = self._clock.time_msec()\n            auth_pdus = await self.handler.on_event_auth(event_id)\n            res = {\"auth_chain\": [a.get_pdu_json(time_now) for a in auth_pdus]}\n        return 200, res\n\n    async def on_query_client_keys(\n        self, origin: str, content: Dict[str, str]\n    ) -> Tuple[int, Dict[str, Any]]:\n        return await self.on_query_request(\"client_keys\", content)\n\n    async def on_query_user_devices(\n        self, origin: str, user_id: str\n    ) -> Tuple[int, Dict[str, Any]]:\n        keys = await self.device_handler.on_federation_query_user_devices(user_id)\n        return 200, keys\n\n    @trace\n    async def on_claim_client_keys(\n        self, query: List[Tuple[str, str, str, int]], always_include_fallback_keys: bool\n    ) -> Dict[str, Any]:\n        if any(\n            not self.hs.is_mine(UserID.from_string(user_id))\n            for user_id, _, _, _ in query\n        ):\n            raise SynapseError(400, \"User is not hosted on this homeserver\")\n\n        log_kv({\"message\": \"Claiming one time keys.\", \"user, device pairs\": query})\n        results = await self._e2e_keys_handler.claim_local_one_time_keys(\n            query, always_include_fallback_keys=always_include_fallback_keys\n        )\n\n        json_result: Dict[str, Dict[str, Dict[str, JsonDict]]] = {}\n        for result in results:\n            for user_id, device_keys in result.items():\n                for device_id, keys in device_keys.items():\n                    for key_id, key in keys.items():\n                        json_result.setdefault(user_id, {}).setdefault(device_id, {})[\n                            key_id\n                        ] = key\n\n        logger.info(\n            \"Claimed one-time-keys: %s\",\n            \",\".join(\n                (\n                    \"%s for %s:%s\" % (key_id, user_id, device_id)\n                    for user_id, user_keys in json_result.items()\n                    for device_id, device_keys in user_keys.items()\n                    for key_id, _ in device_keys.items()\n                )\n            ),\n        )\n\n        return {\"one_time_keys\": json_result}\n\n    async def on_get_missing_events(\n        self,\n        origin: str,\n        room_id: str,\n        earliest_events: List[str],\n        latest_events: List[str],\n        limit: int,\n    ) -> Dict[str, list]:\n        async with self._server_linearizer.queue((origin, room_id)):\n            origin_host, _ = parse_server_name(origin)\n            await self.check_server_matches_acl(origin_host, room_id)\n\n            logger.debug(\n                \"on_get_missing_events: earliest_events: %r, latest_events: %r,\"\n                \" limit: %d\",\n                earliest_events,\n                latest_events,\n                limit,\n            )\n\n            missing_events = await self.handler.on_get_missing_events(\n                origin, room_id, earliest_events, latest_events, limit\n            )\n\n            if len(missing_events) < 5:\n                logger.debug(\n                    \"Returning %d events: %r\", len(missing_events), missing_events\n                )\n            else:\n                logger.debug(\"Returning %d events\", len(missing_events))\n\n            time_now = self._clock.time_msec()\n\n        return {\"events\": [ev.get_pdu_json(time_now) for ev in missing_events]}\n\n    async def on_openid_userinfo(self, token: str) -> Optional[str]:\n        ts_now_ms = self._clock.time_msec()\n        return await self.store.get_user_id_for_open_id_token(token, ts_now_ms)\n\n    def _transaction_dict_from_pdus(self, pdu_list: List[EventBase]) -> JsonDict:\n        \"\"\"Returns a new Transaction containing the given PDUs suitable for\n        transmission.\n        \"\"\"\n        time_now = self._clock.time_msec()\n        pdus = [p.get_pdu_json(time_now) for p in pdu_list]\n        return Transaction(\n            # Just need a dummy transaction ID and destination since it won't be used.\n            transaction_id=\"\",\n            origin=self.server_name,\n            pdus=pdus,\n            origin_server_ts=int(time_now),\n            destination=\"\",\n        ).get_dict()\n\n    async def _handle_received_pdu(self, origin: str, pdu: EventBase) -> None:\n        \"\"\"Process a PDU received in a federation /send/ transaction.\n\n        If the event is invalid, then this method throws a FederationError.\n        (The error will then be logged and sent back to the sender (which\n        probably won't do anything with it), and other events in the\n        transaction will be processed as normal).\n\n        It is likely that we'll then receive other events which refer to\n        this rejected_event in their prev_events, etc.  When that happens,\n        we'll attempt to fetch the rejected event again, which will presumably\n        fail, so those second-generation events will also get rejected.\n\n        Eventually, we get to the point where there are more than 10 events\n        between any new events and the original rejected event. Since we\n        only try to backfill 10 events deep on received pdu, we then accept the\n        new event, possibly introducing a discontinuity in the DAG, with new\n        forward extremities, so normal service is approximately returned,\n        until we try to backfill across the discontinuity.\n\n        Args:\n            origin: server which sent the pdu\n            pdu: received pdu\n\n        Raises: FederationError if the signatures / hash do not match, or\n            if the event was unacceptable for any other reason (eg, too large,\n            too many prev_events, couldn't find the prev_events)\n        \"\"\"\n\n        # We've already checked that we know the room version by this point\n        room_version = await self.store.get_room_version(pdu.room_id)\n\n        # Check signature.\n        try:\n            pdu = await self._check_sigs_and_hash(room_version, pdu)\n        except InvalidEventSignatureError as e:\n            logger.warning(\"event id %s: %s\", pdu.event_id, e)\n            raise FederationError(\"ERROR\", 403, str(e), affected=pdu.event_id)\n\n        if await self._spam_checker_module_callbacks.should_drop_federated_event(pdu):\n            logger.warning(\n                \"Unstaged federated event contains spam, dropping %s\", pdu.event_id\n            )\n            return\n\n        # Add the event to our staging area\n        await self.store.insert_received_event_to_staging(origin, pdu)\n\n        # Try and acquire the processing lock for the room, if we get it start a\n        # background process for handling the events in the room.\n        lock = await self.store.try_acquire_lock(\n            _INBOUND_EVENT_HANDLING_LOCK_NAME, pdu.room_id\n        )\n        if lock:\n            self._process_incoming_pdus_in_room_inner(\n                pdu.room_id, room_version, lock, origin, pdu\n            )\n\n    async def _get_next_nonspam_staged_event_for_room(\n        self, room_id: str, room_version: RoomVersion\n    ) -> Optional[Tuple[str, EventBase]]:\n        \"\"\"Fetch the first non-spam event from staging queue.\n\n        Args:\n            room_id: the room to fetch the first non-spam event in.\n            room_version: the version of the room.\n\n        Returns:\n            The first non-spam event in that room.\n        \"\"\"\n\n        while True:\n            # We need to do this check outside the lock to avoid a race between\n            # a new event being inserted by another instance and it attempting\n            # to acquire the lock.\n            next = await self.store.get_next_staged_event_for_room(\n                room_id, room_version\n            )\n\n            if next is None:\n                return None\n\n            origin, event = next\n\n            if await self._spam_checker_module_callbacks.should_drop_federated_event(\n                event\n            ):\n                logger.warning(\n                    \"Staged federated event contains spam, dropping %s\",\n                    event.event_id,\n                )\n                continue\n\n            return next\n\n    @wrap_as_background_process(\"_process_incoming_pdus_in_room_inner\")\n    async def _process_incoming_pdus_in_room_inner(\n        self,\n        room_id: str,\n        room_version: RoomVersion,\n        lock: Lock,\n        latest_origin: Optional[str] = None,\n        latest_event: Optional[EventBase] = None,\n    ) -> None:\n        \"\"\"Process events in the staging area for the given room.\n\n        The latest_origin and latest_event args are the latest origin and event\n        received (or None to simply pull the next event from the database).\n        \"\"\"\n\n        # The common path is for the event we just received be the only event in\n        # the room, so instead of pulling the event out of the DB and parsing\n        # the event we just pull out the next event ID and check if that matches.\n        if latest_event is not None and latest_origin is not None:\n            result = await self.store.get_next_staged_event_id_for_room(room_id)\n            if result is None:\n                latest_origin = None\n                latest_event = None\n            else:\n                next_origin, next_event_id = result\n                if (\n                    next_origin != latest_origin\n                    or next_event_id != latest_event.event_id\n                ):\n                    latest_origin = None\n                    latest_event = None\n\n        if latest_origin is None or latest_event is None:\n            next = await self.store.get_next_staged_event_for_room(\n                room_id, room_version\n            )\n            if not next:\n                await lock.release()\n                return\n\n            origin, event = next\n        else:\n            origin = latest_origin\n            event = latest_event\n\n        # We loop round until there are no more events in the room in the\n        # staging area, or we fail to get the lock (which means another process\n        # has started processing).\n        while True:\n            async with lock:\n                logger.info(\"handling received PDU in room %s: %s\", room_id, event)\n                try:\n                    with nested_logging_context(event.event_id):\n                        # We're taking out a lock within a lock, which could\n                        # lead to deadlocks if we're not careful. However, it is\n                        # safe on this occasion as we only ever take a write\n                        # lock when deleting a room, which we would never do\n                        # while holding the `_INBOUND_EVENT_HANDLING_LOCK_NAME`\n                        # lock.\n                        async with self._worker_lock_handler.acquire_read_write_lock(\n                            NEW_EVENT_DURING_PURGE_LOCK_NAME, room_id, write=False\n                        ):\n                            await self._federation_event_handler.on_receive_pdu(\n                                origin, event\n                            )\n                except FederationError as e:\n                    # XXX: Ideally we'd inform the remote we failed to process\n                    # the event, but we can't return an error in the transaction\n                    # response (as we've already responded).\n                    logger.warning(\"Error handling PDU %s: %s\", event.event_id, e)\n                except Exception:\n                    f = failure.Failure()\n                    logger.error(\n                        \"Failed to handle PDU %s\",\n                        event.event_id,\n                        exc_info=(f.type, f.value, f.getTracebackObject()),\n                    )\n\n                received_ts = await self.store.remove_received_event_from_staging(\n                    origin, event.event_id\n                )\n                if received_ts is not None:\n                    pdu_process_time.observe(\n                        (self._clock.time_msec() - received_ts) / 1000\n                    )\n\n            next = await self._get_next_nonspam_staged_event_for_room(\n                room_id, room_version\n            )\n\n            if not next:\n                break\n\n            origin, event = next\n\n            # Prune the event queue if it's getting large.\n            #\n            # We do this *after* handling the first event as the common case is\n            # that the queue is empty (/has the single event in), and so there's\n            # no need to do this check.\n            pruned = await self.store.prune_staged_events_in_room(room_id, room_version)\n            if pruned:\n                # If we have pruned the queue check we need to refetch the next\n                # event to handle.\n                next = await self.store.get_next_staged_event_for_room(\n                    room_id, room_version\n                )\n                if not next:\n                    break\n\n                origin, event = next\n\n            new_lock = await self.store.try_acquire_lock(\n                _INBOUND_EVENT_HANDLING_LOCK_NAME, room_id\n            )\n            if not new_lock:\n                return\n            lock = new_lock\n\n    async def exchange_third_party_invite(\n        self, sender_user_id: str, target_user_id: str, room_id: str, signed: Dict\n    ) -> None:\n        await self.handler.exchange_third_party_invite(\n            sender_user_id, target_user_id, room_id, signed\n        )\n\n    async def on_exchange_third_party_invite_request(self, event_dict: Dict) -> None:\n        await self.handler.on_exchange_third_party_invite_request(event_dict)\n\n    async def check_server_matches_acl(self, server_name: str, room_id: str) -> None:\n        \"\"\"Check if the given server is allowed by the server ACLs in the room\n\n        Args:\n            server_name: name of server, *without any port part*\n            room_id: ID of the room to check\n\n        Raises:\n            AuthError if the server does not match the ACL\n        \"\"\"\n        server_acl_evaluator = (\n            await self._storage_controllers.state.get_server_acl_for_room(room_id)\n        )\n        if server_acl_evaluator and not server_acl_evaluator.server_matches_acl_event(\n            server_name\n        ):\n            raise AuthError(code=403, msg=\"Server is banned from room\")\n\n\nclass FederationHandlerRegistry:\n    \"\"\"Allows classes to register themselves as handlers for a given EDU or\n    query type for incoming federation traffic.\n    \"\"\"\n\n    def __init__(self, hs: \"HomeServer\"):\n        self.config = hs.config\n        self.clock = hs.get_clock()\n        self._instance_name = hs.get_instance_name()\n\n        # These are safe to load in monolith mode, but will explode if we try\n        # and use them. However we have guards before we use them to ensure that\n        # we don't route to ourselves, and in monolith mode that will always be\n        # the case.\n        self._get_query_client = ReplicationGetQueryRestServlet.make_client(hs)\n        self._send_edu = ReplicationFederationSendEduRestServlet.make_client(hs)\n\n        self.edu_handlers: Dict[str, Callable[[str, dict], Awaitable[None]]] = {}\n        self.query_handlers: Dict[str, Callable[[dict], Awaitable[JsonDict]]] = {}\n\n        # Map from type to instance names that we should route EDU handling to.\n        # We randomly choose one instance from the list to route to for each new\n        # EDU received.\n        self._edu_type_to_instance: Dict[str, List[str]] = {}\n\n    def register_edu_handler(\n        self, edu_type: str, handler: Callable[[str, JsonDict], Awaitable[None]]\n    ) -> None:\n        \"\"\"Sets the handler callable that will be used to handle an incoming\n        federation EDU of the given type.\n\n        Args:\n            edu_type: The type of the incoming EDU to register handler for\n            handler: A callable invoked on incoming EDU\n                of the given type. The arguments are the origin server name and\n                the EDU contents.\n        \"\"\"\n        if edu_type in self.edu_handlers:\n            raise KeyError(\"Already have an EDU handler for %s\" % (edu_type,))\n\n        logger.info(\"Registering federation EDU handler for %r\", edu_type)\n\n        self.edu_handlers[edu_type] = handler\n\n    def register_query_handler(\n        self, query_type: str, handler: Callable[[dict], Awaitable[JsonDict]]\n    ) -> None:\n        \"\"\"Sets the handler callable that will be used to handle an incoming\n        federation query of the given type.\n\n        Args:\n            query_type: Category name of the query, which should match\n                the string used by make_query.\n            handler: Invoked to handle\n                incoming queries of this type. The return will be yielded\n                on and the result used as the response to the query request.\n        \"\"\"\n        if query_type in self.query_handlers:\n            raise KeyError(\"Already have a Query handler for %s\" % (query_type,))\n\n        logger.info(\"Registering federation query handler for %r\", query_type)\n\n        self.query_handlers[query_type] = handler\n\n    def register_instances_for_edu(\n        self, edu_type: str, instance_names: List[str]\n    ) -> None:\n        \"\"\"Register that the EDU handler is on multiple instances.\"\"\"\n        self._edu_type_to_instance[edu_type] = instance_names\n\n    async def on_edu(self, edu_type: str, origin: str, content: dict) -> None:\n        if not self.config.server.use_presence and edu_type == EduTypes.PRESENCE:\n            return\n\n        # Check if we have a handler on this instance\n        handler = self.edu_handlers.get(edu_type)\n        if handler:\n            with start_active_span_from_edu(content, \"handle_edu\"):\n                try:\n                    await handler(origin, content)\n                except SynapseError as e:\n                    logger.info(\"Failed to handle edu %r: %r\", edu_type, e)\n                except Exception:\n                    logger.exception(\"Failed to handle edu %r\", edu_type)\n            return\n\n        # Check if we can route it somewhere else that isn't us\n        instances = self._edu_type_to_instance.get(edu_type, [\"master\"])\n        if self._instance_name not in instances:\n            # Pick an instance randomly so that we don't overload one.\n            route_to = random.choice(instances)\n\n            try:\n                await self._send_edu(\n                    instance_name=route_to,\n                    edu_type=edu_type,\n                    origin=origin,\n                    content=content,\n                )\n            except SynapseError as e:\n                logger.info(\"Failed to handle edu %r: %r\", edu_type, e)\n            except Exception:\n                logger.exception(\"Failed to handle edu %r\", edu_type)\n            return\n\n        # Oh well, let's just log and move on.\n        logger.warning(\"No handler registered for EDU type %s\", edu_type)\n\n    async def on_query(self, query_type: str, args: dict) -> JsonDict:\n        handler = self.query_handlers.get(query_type)\n        if handler:\n            return await handler(args)\n\n        # Check if we can route it somewhere else that isn't us\n        if self._instance_name == \"master\":\n            return await self._get_query_client(query_type=query_type, args=args)\n\n        # Uh oh, no handler! Let's raise an exception so the request returns an\n        # error.\n        logger.warning(\"No handler registered for query type %s\", query_type)\n        raise NotFoundError(\"No handler for Query type '%s'\" % (query_type,))\n\n\ndef _get_event_ids_for_partial_state_join(\n    join_event: EventBase,\n    prev_state_ids: StateMap[str],\n    summary: Mapping[str, MemberSummary],\n) -> Collection[str]:\n    \"\"\"Calculate state to be returned in a partial_state send_join\n\n    Args:\n        join_event: the join event being send_joined\n        prev_state_ids: the event ids of the state before the join\n\n    Returns:\n        the event ids to be returned\n    \"\"\"\n\n    # return all non-member events\n    state_event_ids = {\n        event_id\n        for (event_type, state_key), event_id in prev_state_ids.items()\n        if event_type != EventTypes.Member\n    }\n\n    # we also need the current state of the current user (it's going to\n    # be an auth event for the new join, so we may as well return it)\n    current_membership_event_id = prev_state_ids.get(\n        (EventTypes.Member, join_event.state_key)\n    )\n    if current_membership_event_id is not None:\n        state_event_ids.add(current_membership_event_id)\n\n    name_id = prev_state_ids.get((EventTypes.Name, \"\"))\n    canonical_alias_id = prev_state_ids.get((EventTypes.CanonicalAlias, \"\"))\n    if not name_id and not canonical_alias_id:\n        # Also include the hero members of the room (for DM rooms without a title).\n        # To do this properly, we should select the correct subset of membership events\n        # from `prev_state_ids`. Instead, we are lazier and use the (cached)\n        # `get_room_summary` function, which is based on the current state of the room.\n        # This introduces races; we choose to ignore them because a) they should be rare\n        # and b) even if it's wrong, joining servers will get the full state eventually.\n        heroes = extract_heroes_from_room_summary(summary, join_event.state_key)\n        for hero in heroes:\n            membership_event_id = prev_state_ids.get((EventTypes.Member, hero))\n            if membership_event_id:\n                state_event_ids.add(membership_event_id)\n\n    return state_event_ids\n", "# Copyright 2016 OpenMarket Ltd\n# Copyright 2019 New Vector Ltd\n# Copyright 2019,2020 The Matrix.org Foundation C.I.C.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport logging\nfrom typing import TYPE_CHECKING, Dict, Iterable, List, Mapping, Optional, Set, Tuple\n\nfrom synapse.api import errors\nfrom synapse.api.constants import EduTypes, EventTypes\nfrom synapse.api.errors import (\n    Codes,\n    FederationDeniedError,\n    HttpResponseException,\n    InvalidAPICallError,\n    RequestSendFailed,\n    SynapseError,\n)\nfrom synapse.logging.opentracing import log_kv, set_tag, trace\nfrom synapse.metrics.background_process_metrics import (\n    run_as_background_process,\n    wrap_as_background_process,\n)\nfrom synapse.storage.databases.main.client_ips import DeviceLastConnectionInfo\nfrom synapse.types import (\n    JsonDict,\n    JsonMapping,\n    ScheduledTask,\n    StrCollection,\n    StreamKeyType,\n    StreamToken,\n    TaskStatus,\n    UserID,\n    get_domain_from_id,\n    get_verify_key_from_cross_signing_key,\n)\nfrom synapse.util import stringutils\nfrom synapse.util.async_helpers import Linearizer\nfrom synapse.util.caches.expiringcache import ExpiringCache\nfrom synapse.util.cancellation import cancellable\nfrom synapse.util.metrics import measure_func\nfrom synapse.util.retryutils import (\n    NotRetryingDestination,\n    filter_destinations_by_retry_limiter,\n)\n\nif TYPE_CHECKING:\n    from synapse.server import HomeServer\n\nlogger = logging.getLogger(__name__)\n\nDELETE_DEVICE_MSGS_TASK_NAME = \"delete_device_messages\"\nMAX_DEVICE_DISPLAY_NAME_LEN = 100\nDELETE_STALE_DEVICES_INTERVAL_MS = 24 * 60 * 60 * 1000\n\n\nclass DeviceWorkerHandler:\n    device_list_updater: \"DeviceListWorkerUpdater\"\n\n    def __init__(self, hs: \"HomeServer\"):\n        self.clock = hs.get_clock()\n        self.hs = hs\n        self.store = hs.get_datastores().main\n        self.notifier = hs.get_notifier()\n        self.state = hs.get_state_handler()\n        self._appservice_handler = hs.get_application_service_handler()\n        self._state_storage = hs.get_storage_controllers().state\n        self._auth_handler = hs.get_auth_handler()\n        self._event_sources = hs.get_event_sources()\n        self.server_name = hs.hostname\n        self._msc3852_enabled = hs.config.experimental.msc3852_enabled\n        self._query_appservices_for_keys = (\n            hs.config.experimental.msc3984_appservice_key_query\n        )\n        self._task_scheduler = hs.get_task_scheduler()\n\n        self.device_list_updater = DeviceListWorkerUpdater(hs)\n\n        self._task_scheduler.register_action(\n            self._delete_device_messages, DELETE_DEVICE_MSGS_TASK_NAME\n        )\n\n    @trace\n    async def get_devices_by_user(self, user_id: str) -> List[JsonDict]:\n        \"\"\"\n        Retrieve the given user's devices\n\n        Args:\n            user_id: The user ID to query for devices.\n        Returns:\n            info on each device\n        \"\"\"\n\n        set_tag(\"user_id\", user_id)\n        device_map = await self.store.get_devices_by_user(user_id)\n\n        ips = await self.store.get_last_client_ip_by_device(user_id, device_id=None)\n\n        devices = list(device_map.values())\n        for device in devices:\n            _update_device_from_client_ips(device, ips)\n\n        log_kv(device_map)\n        return devices\n\n    async def get_dehydrated_device(\n        self, user_id: str\n    ) -> Optional[Tuple[str, JsonDict]]:\n        \"\"\"Retrieve the information for a dehydrated device.\n\n        Args:\n            user_id: the user whose dehydrated device we are looking for\n        Returns:\n            a tuple whose first item is the device ID, and the second item is\n            the dehydrated device information\n        \"\"\"\n        return await self.store.get_dehydrated_device(user_id)\n\n    @trace\n    async def get_device(self, user_id: str, device_id: str) -> JsonDict:\n        \"\"\"Retrieve the given device\n\n        Args:\n            user_id: The user to get the device from\n            device_id: The device to fetch.\n\n        Returns:\n            info on the device\n        Raises:\n            errors.NotFoundError: if the device was not found\n        \"\"\"\n        device = await self.store.get_device(user_id, device_id)\n        if device is None:\n            raise errors.NotFoundError()\n\n        ips = await self.store.get_last_client_ip_by_device(user_id, device_id)\n        _update_device_from_client_ips(device, ips)\n\n        set_tag(\"device\", str(device))\n        set_tag(\"ips\", str(ips))\n\n        return device\n\n    @cancellable\n    async def get_device_changes_in_shared_rooms(\n        self, user_id: str, room_ids: StrCollection, from_token: StreamToken\n    ) -> Set[str]:\n        \"\"\"Get the set of users whose devices have changed who share a room with\n        the given user.\n        \"\"\"\n        changed_users = await self.store.get_device_list_changes_in_rooms(\n            room_ids, from_token.device_list_key\n        )\n\n        if changed_users is not None:\n            # We also check if the given user has changed their device. If\n            # they're in no rooms then the above query won't include them.\n            changed = await self.store.get_users_whose_devices_changed(\n                from_token.device_list_key, [user_id]\n            )\n            changed_users.update(changed)\n            return changed_users\n\n        # If the DB returned None then the `from_token` is too old, so we fall\n        # back on looking for device updates for all users.\n\n        users_who_share_room = await self.store.get_users_who_share_room_with_user(\n            user_id\n        )\n\n        tracked_users = set(users_who_share_room)\n\n        # Always tell the user about their own devices\n        tracked_users.add(user_id)\n\n        changed = await self.store.get_users_whose_devices_changed(\n            from_token.device_list_key, tracked_users\n        )\n\n        return changed\n\n    @trace\n    @measure_func(\"device.get_user_ids_changed\")\n    @cancellable\n    async def get_user_ids_changed(\n        self, user_id: str, from_token: StreamToken\n    ) -> JsonDict:\n        \"\"\"Get list of users that have had the devices updated, or have newly\n        joined a room, that `user_id` may be interested in.\n        \"\"\"\n\n        set_tag(\"user_id\", user_id)\n        set_tag(\"from_token\", str(from_token))\n        now_room_key = self.store.get_room_max_token()\n\n        room_ids = await self.store.get_rooms_for_user(user_id)\n\n        changed = await self.get_device_changes_in_shared_rooms(\n            user_id, room_ids, from_token\n        )\n\n        # Then work out if any users have since joined\n        rooms_changed = self.store.get_rooms_that_changed(room_ids, from_token.room_key)\n\n        member_events = await self.store.get_membership_changes_for_user(\n            user_id, from_token.room_key, now_room_key\n        )\n        rooms_changed.update(event.room_id for event in member_events)\n\n        stream_ordering = from_token.room_key.stream\n\n        possibly_changed = set(changed)\n        possibly_left = set()\n        for room_id in rooms_changed:\n            # Check if the forward extremities have changed. If not then we know\n            # the current state won't have changed, and so we can skip this room.\n            try:\n                if not await self.store.have_room_forward_extremities_changed_since(\n                    room_id, stream_ordering\n                ):\n                    continue\n            except errors.StoreError:\n                pass\n\n            current_state_ids = await self._state_storage.get_current_state_ids(\n                room_id, await_full_state=False\n            )\n\n            # The user may have left the room\n            # TODO: Check if they actually did or if we were just invited.\n            if room_id not in room_ids:\n                for etype, state_key in current_state_ids.keys():\n                    if etype != EventTypes.Member:\n                        continue\n                    possibly_left.add(state_key)\n                continue\n\n            # Fetch the current state at the time.\n            try:\n                event_ids = await self.store.get_forward_extremities_for_room_at_stream_ordering(\n                    room_id, stream_ordering=stream_ordering\n                )\n            except errors.StoreError:\n                # we have purged the stream_ordering index since the stream\n                # ordering: treat it the same as a new room\n                event_ids = []\n\n            # special-case for an empty prev state: include all members\n            # in the changed list\n            if not event_ids:\n                log_kv(\n                    {\"event\": \"encountered empty previous state\", \"room_id\": room_id}\n                )\n                for etype, state_key in current_state_ids.keys():\n                    if etype != EventTypes.Member:\n                        continue\n                    possibly_changed.add(state_key)\n                continue\n\n            current_member_id = current_state_ids.get((EventTypes.Member, user_id))\n            if not current_member_id:\n                continue\n\n            # mapping from event_id -> state_dict\n            prev_state_ids = await self._state_storage.get_state_ids_for_events(\n                event_ids,\n                await_full_state=False,\n            )\n\n            # Check if we've joined the room? If so we just blindly add all the users to\n            # the \"possibly changed\" users.\n            for state_dict in prev_state_ids.values():\n                member_event = state_dict.get((EventTypes.Member, user_id), None)\n                if not member_event or member_event != current_member_id:\n                    for etype, state_key in current_state_ids.keys():\n                        if etype != EventTypes.Member:\n                            continue\n                        possibly_changed.add(state_key)\n                    break\n\n            # If there has been any change in membership, include them in the\n            # possibly changed list. We'll check if they are joined below,\n            # and we're not toooo worried about spuriously adding users.\n            for key, event_id in current_state_ids.items():\n                etype, state_key = key\n                if etype != EventTypes.Member:\n                    continue\n\n                # check if this member has changed since any of the extremities\n                # at the stream_ordering, and add them to the list if so.\n                for state_dict in prev_state_ids.values():\n                    prev_event_id = state_dict.get(key, None)\n                    if not prev_event_id or prev_event_id != event_id:\n                        if state_key != user_id:\n                            possibly_changed.add(state_key)\n                        break\n\n        if possibly_changed or possibly_left:\n            possibly_joined = possibly_changed\n            possibly_left = possibly_changed | possibly_left\n\n            # Double check if we still share rooms with the given user.\n            users_rooms = await self.store.get_rooms_for_users(possibly_left)\n            for changed_user_id, entries in users_rooms.items():\n                if any(rid in room_ids for rid in entries):\n                    possibly_left.discard(changed_user_id)\n                else:\n                    possibly_joined.discard(changed_user_id)\n\n        else:\n            possibly_joined = set()\n            possibly_left = set()\n\n        result = {\"changed\": list(possibly_joined), \"left\": list(possibly_left)}\n\n        log_kv(result)\n\n        return result\n\n    async def on_federation_query_user_devices(self, user_id: str) -> JsonDict:\n        if not self.hs.is_mine(UserID.from_string(user_id)):\n            raise SynapseError(400, \"User is not hosted on this homeserver\")\n\n        stream_id, devices = await self.store.get_e2e_device_keys_for_federation_query(\n            user_id\n        )\n        master_key = await self.store.get_e2e_cross_signing_key(user_id, \"master\")\n        self_signing_key = await self.store.get_e2e_cross_signing_key(\n            user_id, \"self_signing\"\n        )\n\n        # Check if the application services have any results.\n        if self._query_appservices_for_keys:\n            # Query the appservice for all devices for this user.\n            query: Dict[str, Optional[List[str]]] = {user_id: None}\n\n            # Query the appservices for any keys.\n            appservice_results = await self._appservice_handler.query_keys(query)\n\n            # Merge results, overriding anything from the database.\n            appservice_devices = appservice_results.get(\"device_keys\", {}).get(\n                user_id, {}\n            )\n\n            # Filter the database results to only those devices that the appservice has\n            # *not* responded with.\n            devices = [d for d in devices if d[\"device_id\"] not in appservice_devices]\n            # Append the appservice response by wrapping each result in another dictionary.\n            devices.extend(\n                {\"device_id\": device_id, \"keys\": device}\n                for device_id, device in appservice_devices.items()\n            )\n\n            # TODO Handle cross-signing keys.\n\n        return {\n            \"user_id\": user_id,\n            \"stream_id\": stream_id,\n            \"devices\": devices,\n            \"master_key\": master_key,\n            \"self_signing_key\": self_signing_key,\n        }\n\n    async def handle_room_un_partial_stated(self, room_id: str) -> None:\n        \"\"\"Handles sending appropriate device list updates in a room that has\n        gone from partial to full state.\n        \"\"\"\n\n        # TODO(faster_joins): worker mode support\n        #   https://github.com/matrix-org/synapse/issues/12994\n        logger.error(\n            \"Trying handling device list state for partial join: not supported on workers.\"\n        )\n\n    DEVICE_MSGS_DELETE_BATCH_LIMIT = 1000\n    DEVICE_MSGS_DELETE_SLEEP_MS = 1000\n\n    async def _delete_device_messages(\n        self,\n        task: ScheduledTask,\n    ) -> Tuple[TaskStatus, Optional[JsonMapping], Optional[str]]:\n        \"\"\"Scheduler task to delete device messages in batch of `DEVICE_MSGS_DELETE_BATCH_LIMIT`.\"\"\"\n        assert task.params is not None\n        user_id = task.params[\"user_id\"]\n        device_id = task.params[\"device_id\"]\n        up_to_stream_id = task.params[\"up_to_stream_id\"]\n\n        # Delete the messages in batches to avoid too much DB load.\n        while True:\n            res = await self.store.delete_messages_for_device(\n                user_id=user_id,\n                device_id=device_id,\n                up_to_stream_id=up_to_stream_id,\n                limit=DeviceHandler.DEVICE_MSGS_DELETE_BATCH_LIMIT,\n            )\n\n            if res < DeviceHandler.DEVICE_MSGS_DELETE_BATCH_LIMIT:\n                return TaskStatus.COMPLETE, None, None\n\n            await self.clock.sleep(DeviceHandler.DEVICE_MSGS_DELETE_SLEEP_MS / 1000.0)\n\n\nclass DeviceHandler(DeviceWorkerHandler):\n    device_list_updater: \"DeviceListUpdater\"\n\n    def __init__(self, hs: \"HomeServer\"):\n        super().__init__(hs)\n\n        self.federation_sender = hs.get_federation_sender()\n        self._account_data_handler = hs.get_account_data_handler()\n        self._storage_controllers = hs.get_storage_controllers()\n        self.db_pool = hs.get_datastores().main.db_pool\n\n        self.device_list_updater = DeviceListUpdater(hs, self)\n\n        federation_registry = hs.get_federation_registry()\n\n        federation_registry.register_edu_handler(\n            EduTypes.DEVICE_LIST_UPDATE,\n            self.device_list_updater.incoming_device_list_update,\n        )\n\n        # Whether `_handle_new_device_update_async` is currently processing.\n        self._handle_new_device_update_is_processing = False\n\n        # If a new device update may have happened while the loop was\n        # processing.\n        self._handle_new_device_update_new_data = False\n\n        # On start up check if there are any updates pending.\n        hs.get_reactor().callWhenRunning(self._handle_new_device_update_async)\n\n        self._delete_stale_devices_after = hs.config.server.delete_stale_devices_after\n\n        # Ideally we would run this on a worker and condition this on the\n        # \"run_background_tasks_on\" setting, but this would mean making the notification\n        # of device list changes over federation work on workers, which is nontrivial.\n        if self._delete_stale_devices_after is not None:\n            self.clock.looping_call(\n                run_as_background_process,\n                DELETE_STALE_DEVICES_INTERVAL_MS,\n                \"delete_stale_devices\",\n                self._delete_stale_devices,\n            )\n\n    def _check_device_name_length(self, name: Optional[str]) -> None:\n        \"\"\"\n        Checks whether a device name is longer than the maximum allowed length.\n\n        Args:\n            name: The name of the device.\n\n        Raises:\n            SynapseError: if the device name is too long.\n        \"\"\"\n        if name and len(name) > MAX_DEVICE_DISPLAY_NAME_LEN:\n            raise SynapseError(\n                400,\n                \"Device display name is too long (max %i)\"\n                % (MAX_DEVICE_DISPLAY_NAME_LEN,),\n                errcode=Codes.TOO_LARGE,\n            )\n\n    async def check_device_registered(\n        self,\n        user_id: str,\n        device_id: Optional[str],\n        initial_device_display_name: Optional[str] = None,\n        auth_provider_id: Optional[str] = None,\n        auth_provider_session_id: Optional[str] = None,\n    ) -> str:\n        \"\"\"\n        If the given device has not been registered, register it with the\n        supplied display name.\n\n        If no device_id is supplied, we make one up.\n\n        Args:\n            user_id:  @user:id\n            device_id: device id supplied by client\n            initial_device_display_name: device display name from client\n            auth_provider_id: The SSO IdP the user used, if any.\n            auth_provider_session_id: The session ID (sid) got from the SSO IdP.\n        Returns:\n            device id (generated if none was supplied)\n        \"\"\"\n\n        self._check_device_name_length(initial_device_display_name)\n\n        if device_id is not None:\n            new_device = await self.store.store_device(\n                user_id=user_id,\n                device_id=device_id,\n                initial_device_display_name=initial_device_display_name,\n                auth_provider_id=auth_provider_id,\n                auth_provider_session_id=auth_provider_session_id,\n            )\n            if new_device:\n                await self.notify_device_update(user_id, [device_id])\n            return device_id\n\n        # if the device id is not specified, we'll autogen one, but loop a few\n        # times in case of a clash.\n        attempts = 0\n        while attempts < 5:\n            new_device_id = stringutils.random_string(10).upper()\n            new_device = await self.store.store_device(\n                user_id=user_id,\n                device_id=new_device_id,\n                initial_device_display_name=initial_device_display_name,\n                auth_provider_id=auth_provider_id,\n                auth_provider_session_id=auth_provider_session_id,\n            )\n            if new_device:\n                await self.notify_device_update(user_id, [new_device_id])\n                return new_device_id\n            attempts += 1\n\n        raise errors.StoreError(500, \"Couldn't generate a device ID.\")\n\n    async def _delete_stale_devices(self) -> None:\n        \"\"\"Background task that deletes devices which haven't been accessed for more than\n        a configured time period.\n        \"\"\"\n        # We should only be running this job if the config option is defined.\n        assert self._delete_stale_devices_after is not None\n        now_ms = self.clock.time_msec()\n        since_ms = now_ms - self._delete_stale_devices_after\n        devices = await self.store.get_local_devices_not_accessed_since(since_ms)\n\n        for user_id, user_devices in devices.items():\n            await self.delete_devices(user_id, user_devices)\n\n    @trace\n    async def delete_all_devices_for_user(\n        self, user_id: str, except_device_id: Optional[str] = None\n    ) -> None:\n        \"\"\"Delete all of the user's devices\n\n        Args:\n            user_id: The user to remove all devices from\n            except_device_id: optional device id which should not be deleted\n        \"\"\"\n        device_map = await self.store.get_devices_by_user(user_id)\n        device_ids = list(device_map)\n        if except_device_id is not None:\n            device_ids = [d for d in device_ids if d != except_device_id]\n        await self.delete_devices(user_id, device_ids)\n\n    async def delete_devices(self, user_id: str, device_ids: List[str]) -> None:\n        \"\"\"Delete several devices\n\n        Args:\n            user_id: The user to delete devices from.\n            device_ids: The list of device IDs to delete\n        \"\"\"\n        to_device_stream_id = self._event_sources.get_current_token().to_device_key\n\n        try:\n            await self.store.delete_devices(user_id, device_ids)\n        except errors.StoreError as e:\n            if e.code == 404:\n                # no match\n                set_tag(\"error\", True)\n                set_tag(\"reason\", \"User doesn't have that device id.\")\n            else:\n                raise\n\n        # Delete data specific to each device. Not optimised as it is not\n        # considered as part of a critical path.\n        for device_id in device_ids:\n            await self._auth_handler.delete_access_tokens_for_user(\n                user_id, device_id=device_id\n            )\n            await self.store.delete_e2e_keys_by_device(\n                user_id=user_id, device_id=device_id\n            )\n\n            if self.hs.config.experimental.msc3890_enabled:\n                # Remove any local notification settings for this device in accordance\n                # with MSC3890.\n                await self._account_data_handler.remove_account_data_for_user(\n                    user_id,\n                    f\"org.matrix.msc3890.local_notification_settings.{device_id}\",\n                )\n\n            # Delete device messages asynchronously and in batches using the task scheduler\n            await self._task_scheduler.schedule_task(\n                DELETE_DEVICE_MSGS_TASK_NAME,\n                resource_id=device_id,\n                params={\n                    \"user_id\": user_id,\n                    \"device_id\": device_id,\n                    \"up_to_stream_id\": to_device_stream_id,\n                },\n            )\n\n        # Pushers are deleted after `delete_access_tokens_for_user` is called so that\n        # modules using `on_logged_out` hook can use them if needed.\n        await self.hs.get_pusherpool().remove_pushers_by_devices(user_id, device_ids)\n\n        await self.notify_device_update(user_id, device_ids)\n\n    async def update_device(self, user_id: str, device_id: str, content: dict) -> None:\n        \"\"\"Update the given device\n\n        Args:\n            user_id: The user to update devices of.\n            device_id: The device to update.\n            content: body of update request\n        \"\"\"\n\n        # Reject a new displayname which is too long.\n        new_display_name = content.get(\"display_name\")\n\n        self._check_device_name_length(new_display_name)\n\n        try:\n            await self.store.update_device(\n                user_id, device_id, new_display_name=new_display_name\n            )\n            await self.notify_device_update(user_id, [device_id])\n        except errors.StoreError as e:\n            if e.code == 404:\n                raise errors.NotFoundError()\n            else:\n                raise\n\n    @trace\n    @measure_func(\"notify_device_update\")\n    async def notify_device_update(\n        self, user_id: str, device_ids: StrCollection\n    ) -> None:\n        \"\"\"Notify that a user's device(s) has changed. Pokes the notifier, and\n        remote servers if the user is local.\n\n        Args:\n            user_id: The Matrix ID of the user who's device list has been updated.\n            device_ids: The device IDs that have changed.\n        \"\"\"\n        if not device_ids:\n            # No changes to notify about, so this is a no-op.\n            return\n\n        room_ids = await self.store.get_rooms_for_user(user_id)\n\n        position = await self.store.add_device_change_to_streams(\n            user_id,\n            device_ids,\n            room_ids=room_ids,\n        )\n\n        if not position:\n            # This should only happen if there are no updates, so we bail.\n            return\n\n        for device_id in device_ids:\n            logger.debug(\n                \"Notifying about update %r/%r, ID: %r\", user_id, device_id, position\n            )\n\n        # specify the user ID too since the user should always get their own device list\n        # updates, even if they aren't in any rooms.\n        self.notifier.on_new_event(\n            StreamKeyType.DEVICE_LIST, position, users={user_id}, rooms=room_ids\n        )\n\n        # We may need to do some processing asynchronously for local user IDs.\n        if self.hs.is_mine_id(user_id):\n            self._handle_new_device_update_async()\n\n    async def notify_user_signature_update(\n        self, from_user_id: str, user_ids: List[str]\n    ) -> None:\n        \"\"\"Notify a user that they have made new signatures of other users.\n\n        Args:\n            from_user_id: the user who made the signature\n            user_ids: the users IDs that have new signatures\n        \"\"\"\n\n        position = await self.store.add_user_signature_change_to_streams(\n            from_user_id, user_ids\n        )\n\n        self.notifier.on_new_event(\n            StreamKeyType.DEVICE_LIST, position, users=[from_user_id]\n        )\n\n    async def store_dehydrated_device(\n        self,\n        user_id: str,\n        device_id: Optional[str],\n        device_data: JsonDict,\n        initial_device_display_name: Optional[str] = None,\n        keys_for_device: Optional[JsonDict] = None,\n    ) -> str:\n        \"\"\"Store a dehydrated device for a user, optionally storing the keys associated with\n        it as well.  If the user had a previous dehydrated device, it is removed.\n\n        Args:\n            user_id: the user that we are storing the device for\n            device_id: device id supplied by client\n            device_data: the dehydrated device information\n            initial_device_display_name: The display name to use for the device\n            keys_for_device: keys for the dehydrated device\n        Returns:\n            device id of the dehydrated device\n        \"\"\"\n        device_id = await self.check_device_registered(\n            user_id,\n            device_id,\n            initial_device_display_name,\n        )\n\n        time_now = self.clock.time_msec()\n\n        old_device_id = await self.store.store_dehydrated_device(\n            user_id, device_id, device_data, time_now, keys_for_device\n        )\n\n        if old_device_id is not None:\n            await self.delete_devices(user_id, [old_device_id])\n\n        return device_id\n\n    async def rehydrate_device(\n        self, user_id: str, access_token: str, device_id: str\n    ) -> dict:\n        \"\"\"Process a rehydration request from the user.\n\n        Args:\n            user_id: the user who is rehydrating the device\n            access_token: the access token used for the request\n            device_id: the ID of the device that will be rehydrated\n        Returns:\n            a dict containing {\"success\": True}\n        \"\"\"\n        success = await self.store.remove_dehydrated_device(user_id, device_id)\n\n        if not success:\n            raise errors.NotFoundError()\n\n        # If the dehydrated device was successfully deleted (the device ID\n        # matched the stored dehydrated device), then modify the access\n        # token and refresh token to use the dehydrated device's ID and\n        # copy the old device display name to the dehydrated device,\n        # and destroy the old device ID\n        old_device_id = await self.store.set_device_for_access_token(\n            access_token, device_id\n        )\n        await self.store.set_device_for_refresh_token(user_id, old_device_id, device_id)\n        old_device = await self.store.get_device(user_id, old_device_id)\n        if old_device is None:\n            raise errors.NotFoundError()\n        await self.store.update_device(user_id, device_id, old_device[\"display_name\"])\n        # can't call self.delete_device because that will clobber the\n        # access token so call the storage layer directly\n        await self.store.delete_devices(user_id, [old_device_id])\n        await self.store.delete_e2e_keys_by_device(\n            user_id=user_id, device_id=old_device_id\n        )\n\n        # tell everyone that the old device is gone and that the dehydrated\n        # device has a new display name\n        await self.notify_device_update(user_id, [old_device_id, device_id])\n\n        return {\"success\": True}\n\n    async def delete_dehydrated_device(self, user_id: str, device_id: str) -> None:\n        \"\"\"\n        Delete a stored dehydrated device.\n\n        Args:\n            user_id: the user_id to delete the device from\n            device_id: id of the dehydrated device to delete\n        \"\"\"\n        success = await self.store.remove_dehydrated_device(user_id, device_id)\n\n        if not success:\n            raise errors.NotFoundError()\n\n        await self.delete_devices(user_id, [device_id])\n        await self.store.delete_e2e_keys_by_device(user_id=user_id, device_id=device_id)\n\n    @wrap_as_background_process(\"_handle_new_device_update_async\")\n    async def _handle_new_device_update_async(self) -> None:\n        \"\"\"Called when we have a new local device list update that we need to\n        send out over federation.\n\n        This happens in the background so as not to block the original request\n        that generated the device update.\n        \"\"\"\n        if self._handle_new_device_update_is_processing:\n            self._handle_new_device_update_new_data = True\n            return\n\n        self._handle_new_device_update_is_processing = True\n\n        # The stream ID we processed previous iteration (if any), and the set of\n        # hosts we've already poked about for this update. This is so that we\n        # don't poke the same remote server about the same update repeatedly.\n        current_stream_id = None\n        hosts_already_sent_to: Set[str] = set()\n\n        try:\n            stream_id, room_id = await self.store.get_device_change_last_converted_pos()\n\n            while True:\n                self._handle_new_device_update_new_data = False\n                max_stream_id = self.store.get_device_stream_token()\n                rows = await self.store.get_uncoverted_outbound_room_pokes(\n                    stream_id, room_id\n                )\n                if not rows:\n                    # If the DB returned nothing then there is nothing left to\n                    # do, *unless* a new device list update happened during the\n                    # DB query.\n\n                    # Advance `(stream_id, room_id)`.\n                    # `max_stream_id` comes from *before* the query for unconverted\n                    # rows, which means that any unconverted rows must have a larger\n                    # stream ID.\n                    if max_stream_id > stream_id:\n                        stream_id, room_id = max_stream_id, \"\"\n                        await self.store.set_device_change_last_converted_pos(\n                            stream_id, room_id\n                        )\n                    else:\n                        assert max_stream_id == stream_id\n                        # Avoid moving `room_id` backwards.\n\n                    if self._handle_new_device_update_new_data:\n                        continue\n                    else:\n                        return\n\n                for user_id, device_id, room_id, stream_id, opentracing_context in rows:\n                    hosts = set()\n\n                    # Ignore any users that aren't ours\n                    if self.hs.is_mine_id(user_id):\n                        hosts = set(\n                            await self._storage_controllers.state.get_current_hosts_in_room_or_partial_state_approximation(\n                                room_id\n                            )\n                        )\n                        hosts.discard(self.server_name)\n                        # For rooms with partial state, `hosts` is merely an\n                        # approximation. When we transition to a full state room, we\n                        # will have to send out device list updates to any servers we\n                        # missed.\n\n                    # Check if we've already sent this update to some hosts\n                    if current_stream_id == stream_id:\n                        hosts -= hosts_already_sent_to\n\n                    await self.store.add_device_list_outbound_pokes(\n                        user_id=user_id,\n                        device_id=device_id,\n                        room_id=room_id,\n                        hosts=hosts,\n                        context=opentracing_context,\n                    )\n\n                    # Notify replication that we've updated the device list stream.\n                    self.notifier.notify_replication()\n\n                    if hosts:\n                        logger.info(\n                            \"Sending device list update notif for %r to: %r\",\n                            user_id,\n                            hosts,\n                        )\n                        await self.federation_sender.send_device_messages(\n                            hosts, immediate=False\n                        )\n                        # TODO: when called, this isn't in a logging context.\n                        # This leads to log spam, sentry event spam, and massive\n                        # memory usage.\n                        # See https://github.com/matrix-org/synapse/issues/12552.\n                        # log_kv(\n                        #     {\"message\": \"sent device update to host\", \"host\": host}\n                        # )\n\n                    if current_stream_id != stream_id:\n                        # Clear the set of hosts we've already sent to as we're\n                        # processing a new update.\n                        hosts_already_sent_to.clear()\n\n                    hosts_already_sent_to.update(hosts)\n                    current_stream_id = stream_id\n\n                # Advance `(stream_id, room_id)`.\n                _, _, room_id, stream_id, _ = rows[-1]\n                await self.store.set_device_change_last_converted_pos(\n                    stream_id, room_id\n                )\n\n        finally:\n            self._handle_new_device_update_is_processing = False\n\n    async def handle_room_un_partial_stated(self, room_id: str) -> None:\n        \"\"\"Handles sending appropriate device list updates in a room that has\n        gone from partial to full state.\n        \"\"\"\n\n        # We defer to the device list updater to handle pending remote device\n        # list updates.\n        await self.device_list_updater.handle_room_un_partial_stated(room_id)\n\n        # Replay local updates.\n        (\n            join_event_id,\n            device_lists_stream_id,\n        ) = await self.store.get_join_event_id_and_device_lists_stream_id_for_partial_state(\n            room_id\n        )\n\n        # Get the local device list changes that have happened in the room since\n        # we started joining. If there are no updates there's nothing left to do.\n        changes = await self.store.get_device_list_changes_in_room(\n            room_id, device_lists_stream_id\n        )\n        local_changes = {(u, d) for u, d in changes if self.hs.is_mine_id(u)}\n        if not local_changes:\n            return\n\n        # Note: We have persisted the full state at this point, we just haven't\n        # cleared the `partial_room` flag.\n        join_state_ids = await self._state_storage.get_state_ids_for_event(\n            join_event_id, await_full_state=False\n        )\n        current_state_ids = await self.store.get_partial_current_state_ids(room_id)\n\n        # Now we need to work out all servers that might have been in the room\n        # at any point during our join.\n\n        # First we look for any membership states that have changed between the\n        # initial join and now...\n        all_keys = set(join_state_ids)\n        all_keys.update(current_state_ids)\n\n        potentially_changed_hosts = set()\n        for etype, state_key in all_keys:\n            if etype != EventTypes.Member:\n                continue\n\n            prev = join_state_ids.get((etype, state_key))\n            current = current_state_ids.get((etype, state_key))\n\n            if prev != current:\n                potentially_changed_hosts.add(get_domain_from_id(state_key))\n\n        # ... then we add all the hosts that are currently joined to the room...\n        current_hosts_in_room = await self.store.get_current_hosts_in_room(room_id)\n        potentially_changed_hosts.update(current_hosts_in_room)\n\n        # ... and finally we remove any hosts that we were told about, as we\n        # will have sent device list updates to those hosts when they happened.\n        known_hosts_at_join = await self.store.get_partial_state_servers_at_join(\n            room_id\n        )\n        assert known_hosts_at_join is not None\n        potentially_changed_hosts.difference_update(known_hosts_at_join)\n\n        potentially_changed_hosts.discard(self.server_name)\n\n        if not potentially_changed_hosts:\n            # Nothing to do.\n            return\n\n        logger.info(\n            \"Found %d changed hosts to send device list updates to\",\n            len(potentially_changed_hosts),\n        )\n\n        for user_id, device_id in local_changes:\n            await self.store.add_device_list_outbound_pokes(\n                user_id=user_id,\n                device_id=device_id,\n                room_id=room_id,\n                hosts=potentially_changed_hosts,\n                context=None,\n            )\n\n        # Notify things that device lists need to be sent out.\n        self.notifier.notify_replication()\n        await self.federation_sender.send_device_messages(\n            potentially_changed_hosts, immediate=False\n        )\n\n\ndef _update_device_from_client_ips(\n    device: JsonDict, client_ips: Mapping[Tuple[str, str], DeviceLastConnectionInfo]\n) -> None:\n    ip = client_ips.get((device[\"user_id\"], device[\"device_id\"]))\n    device.update(\n        {\n            \"last_seen_user_agent\": ip.user_agent if ip else None,\n            \"last_seen_ts\": ip.last_seen if ip else None,\n            \"last_seen_ip\": ip.ip if ip else None,\n        }\n    )\n\n\nclass DeviceListWorkerUpdater:\n    \"Handles incoming device list updates from federation and contacts the main process over replication\"\n\n    def __init__(self, hs: \"HomeServer\"):\n        from synapse.replication.http.devices import (\n            ReplicationMultiUserDevicesResyncRestServlet,\n        )\n\n        self._multi_user_device_resync_client = (\n            ReplicationMultiUserDevicesResyncRestServlet.make_client(hs)\n        )\n\n    async def multi_user_device_resync(\n        self, user_ids: List[str], mark_failed_as_stale: bool = True\n    ) -> Dict[str, Optional[JsonMapping]]:\n        \"\"\"\n        Like `user_device_resync` but operates on multiple users **from the same origin**\n        at once.\n\n        Returns:\n            Dict from User ID to the same Dict as `user_device_resync`.\n        \"\"\"\n        # mark_failed_as_stale is not sent. Ensure this doesn't break expectations.\n        assert mark_failed_as_stale\n\n        if not user_ids:\n            # Shortcut empty requests\n            return {}\n\n        return await self._multi_user_device_resync_client(user_ids=user_ids)\n\n\nclass DeviceListUpdater(DeviceListWorkerUpdater):\n    \"Handles incoming device list updates from federation and updates the DB\"\n\n    def __init__(self, hs: \"HomeServer\", device_handler: DeviceHandler):\n        self.store = hs.get_datastores().main\n        self.federation = hs.get_federation_client()\n        self.clock = hs.get_clock()\n        self.device_handler = device_handler\n        self._notifier = hs.get_notifier()\n\n        self._remote_edu_linearizer = Linearizer(name=\"remote_device_list\")\n        self._resync_linearizer = Linearizer(name=\"remote_device_resync\")\n\n        # user_id -> list of updates waiting to be handled.\n        self._pending_updates: Dict[\n            str, List[Tuple[str, str, Iterable[str], JsonDict]]\n        ] = {}\n\n        # Recently seen stream ids. We don't bother keeping these in the DB,\n        # but they're useful to have them about to reduce the number of spurious\n        # resyncs.\n        self._seen_updates: ExpiringCache[str, Set[str]] = ExpiringCache(\n            cache_name=\"device_update_edu\",\n            clock=self.clock,\n            max_len=10000,\n            expiry_ms=30 * 60 * 1000,\n            iterable=True,\n        )\n\n        # Attempt to resync out of sync device lists every 30s.\n        self._resync_retry_in_progress = False\n        self.clock.looping_call(\n            run_as_background_process,\n            30 * 1000,\n            func=self._maybe_retry_device_resync,\n            desc=\"_maybe_retry_device_resync\",\n        )\n\n    @trace\n    async def incoming_device_list_update(\n        self, origin: str, edu_content: JsonDict\n    ) -> None:\n        \"\"\"Called on incoming device list update from federation. Responsible\n        for parsing the EDU and adding to pending updates list.\n        \"\"\"\n\n        set_tag(\"origin\", origin)\n        set_tag(\"edu_content\", str(edu_content))\n        user_id = edu_content.pop(\"user_id\")\n        device_id = edu_content.pop(\"device_id\")\n        stream_id = str(edu_content.pop(\"stream_id\"))  # They may come as ints\n        prev_ids = edu_content.pop(\"prev_id\", [])\n        if not isinstance(prev_ids, list):\n            raise SynapseError(\n                400, \"Device list update had an invalid 'prev_ids' field\"\n            )\n        prev_ids = [str(p) for p in prev_ids]  # They may come as ints\n\n        if get_domain_from_id(user_id) != origin:\n            # TODO: Raise?\n            logger.warning(\n                \"Got device list update edu for %r/%r from %r\",\n                user_id,\n                device_id,\n                origin,\n            )\n\n            set_tag(\"error\", True)\n            log_kv(\n                {\n                    \"message\": \"Got a device list update edu from a user and \"\n                    \"device which does not match the origin of the request.\",\n                    \"user_id\": user_id,\n                    \"device_id\": device_id,\n                }\n            )\n            return\n\n        # Check if we are partially joining any rooms. If so we need to store\n        # all device list updates so that we can handle them correctly once we\n        # know who is in the room.\n        # TODO(faster_joins): this fetches and processes a bunch of data that we don't\n        # use. Could be replaced by a tighter query e.g.\n        #   SELECT EXISTS(SELECT 1 FROM partial_state_rooms)\n        partial_rooms = await self.store.get_partial_state_room_resync_info()\n        if partial_rooms:\n            await self.store.add_remote_device_list_to_pending(\n                user_id,\n                device_id,\n            )\n            self._notifier.notify_replication()\n\n        room_ids = await self.store.get_rooms_for_user(user_id)\n        if not room_ids:\n            # We don't share any rooms with this user. Ignore update, as we\n            # probably won't get any further updates.\n            set_tag(\"error\", True)\n            log_kv(\n                {\n                    \"message\": \"Got an update from a user for which \"\n                    \"we don't share any rooms\",\n                    \"other user_id\": user_id,\n                }\n            )\n            logger.warning(\n                \"Got device list update edu for %r/%r, but don't share a room\",\n                user_id,\n                device_id,\n            )\n            return\n\n        logger.debug(\"Received device list update for %r/%r\", user_id, device_id)\n\n        self._pending_updates.setdefault(user_id, []).append(\n            (device_id, stream_id, prev_ids, edu_content)\n        )\n\n        await self._handle_device_updates(user_id)\n\n    @measure_func(\"_incoming_device_list_update\")\n    async def _handle_device_updates(self, user_id: str) -> None:\n        \"Actually handle pending updates.\"\n\n        async with self._remote_edu_linearizer.queue(user_id):\n            pending_updates = self._pending_updates.pop(user_id, [])\n            if not pending_updates:\n                # This can happen since we batch updates\n                return\n\n            for device_id, stream_id, prev_ids, _ in pending_updates:\n                logger.debug(\n                    \"Handling update %r/%r, ID: %r, prev: %r \",\n                    user_id,\n                    device_id,\n                    stream_id,\n                    prev_ids,\n                )\n\n            # Given a list of updates we check if we need to resync. This\n            # happens if we've missed updates.\n            resync = await self._need_to_do_resync(user_id, pending_updates)\n\n            if logger.isEnabledFor(logging.INFO):\n                logger.info(\n                    \"Received device list update for %s, requiring resync: %s. Devices: %s\",\n                    user_id,\n                    resync,\n                    \", \".join(u[0] for u in pending_updates),\n                )\n\n            if resync:\n                # We mark as stale up front in case we get restarted.\n                await self.store.mark_remote_users_device_caches_as_stale([user_id])\n                run_as_background_process(\n                    \"_maybe_retry_device_resync\",\n                    self.multi_user_device_resync,\n                    [user_id],\n                    False,\n                )\n            else:\n                # Simply update the single device, since we know that is the only\n                # change (because of the single prev_id matching the current cache)\n                for device_id, stream_id, _, content in pending_updates:\n                    await self.store.update_remote_device_list_cache_entry(\n                        user_id, device_id, content, stream_id\n                    )\n\n                await self.device_handler.notify_device_update(\n                    user_id, [device_id for device_id, _, _, _ in pending_updates]\n                )\n\n                self._seen_updates.setdefault(user_id, set()).update(\n                    stream_id for _, stream_id, _, _ in pending_updates\n                )\n\n    async def _need_to_do_resync(\n        self, user_id: str, updates: Iterable[Tuple[str, str, Iterable[str], JsonDict]]\n    ) -> bool:\n        \"\"\"Given a list of updates for a user figure out if we need to do a full\n        resync, or whether we have enough data that we can just apply the delta.\n        \"\"\"\n        seen_updates: Set[str] = self._seen_updates.get(user_id, set())\n\n        extremity = await self.store.get_device_list_last_stream_id_for_remote(user_id)\n\n        logger.debug(\"Current extremity for %r: %r\", user_id, extremity)\n\n        stream_id_in_updates = set()  # stream_ids in updates list\n        for _, stream_id, prev_ids, _ in updates:\n            if not prev_ids:\n                # We always do a resync if there are no previous IDs\n                return True\n\n            for prev_id in prev_ids:\n                if prev_id == extremity:\n                    continue\n                elif prev_id in seen_updates:\n                    continue\n                elif prev_id in stream_id_in_updates:\n                    continue\n                else:\n                    return True\n\n            stream_id_in_updates.add(stream_id)\n\n        return False\n\n    @trace\n    async def _maybe_retry_device_resync(self) -> None:\n        \"\"\"Retry to resync device lists that are out of sync, except if another retry is\n        in progress.\n        \"\"\"\n        if self._resync_retry_in_progress:\n            return\n\n        try:\n            # Prevent another call of this function to retry resyncing device lists so\n            # we don't send too many requests.\n            self._resync_retry_in_progress = True\n            # Get all of the users that need resyncing.\n            need_resync = await self.store.get_user_ids_requiring_device_list_resync()\n\n            # Filter out users whose host is marked as \"down\" up front.\n            hosts = await filter_destinations_by_retry_limiter(\n                {get_domain_from_id(u) for u in need_resync}, self.clock, self.store\n            )\n            hosts = set(hosts)\n\n            # Iterate over the set of user IDs.\n            for user_id in need_resync:\n                if get_domain_from_id(user_id) not in hosts:\n                    continue\n\n                try:\n                    # Try to resync the current user's devices list.\n                    result = (await self.multi_user_device_resync([user_id], False))[\n                        user_id\n                    ]\n\n                    # user_device_resync only returns a result if it managed to\n                    # successfully resync and update the database. Updating the table\n                    # of users requiring resync isn't necessary here as\n                    # user_device_resync already does it (through\n                    # self.store.update_remote_device_list_cache).\n                    if result:\n                        logger.debug(\n                            \"Successfully resynced the device list for %s\",\n                            user_id,\n                        )\n                except Exception as e:\n                    # If there was an issue resyncing this user, e.g. if the remote\n                    # server sent a malformed result, just log the error instead of\n                    # aborting all the subsequent resyncs.\n                    logger.debug(\n                        \"Could not resync the device list for %s: %s\",\n                        user_id,\n                        e,\n                    )\n        finally:\n            # Allow future calls to retry resyncinc out of sync device lists.\n            self._resync_retry_in_progress = False\n\n    async def multi_user_device_resync(\n        self, user_ids: List[str], mark_failed_as_stale: bool = True\n    ) -> Dict[str, Optional[JsonMapping]]:\n        \"\"\"\n        Like `user_device_resync` but operates on multiple users **from the same origin**\n        at once.\n\n        Returns:\n            Dict from User ID to the same Dict as `user_device_resync`.\n        \"\"\"\n        if not user_ids:\n            return {}\n\n        origins = {UserID.from_string(user_id).domain for user_id in user_ids}\n\n        if len(origins) != 1:\n            raise InvalidAPICallError(f\"Only one origin permitted, got {origins!r}\")\n\n        result = {}\n        failed = set()\n        # TODO(Perf): Actually batch these up\n        for user_id in user_ids:\n            async with self._resync_linearizer.queue(user_id):\n                (\n                    user_result,\n                    user_failed,\n                ) = await self._user_device_resync_returning_failed(user_id)\n            result[user_id] = user_result\n            if user_failed:\n                failed.add(user_id)\n\n        if mark_failed_as_stale:\n            await self.store.mark_remote_users_device_caches_as_stale(failed)\n\n        return result\n\n    async def _user_device_resync_returning_failed(\n        self, user_id: str\n    ) -> Tuple[Optional[JsonMapping], bool]:\n        \"\"\"Fetches all devices for a user and updates the device cache with them.\n\n        Args:\n            user_id: The user's id whose device_list will be updated.\n        Returns:\n            - A dict with device info as under the \"devices\" in the result of this\n              request:\n              https://matrix.org/docs/spec/server_server/r0.1.2#get-matrix-federation-v1-user-devices-userid\n              None when we weren't able to fetch the device info for some reason,\n              e.g. due to a connection problem.\n            - True iff the resync failed and the device list should be marked as stale.\n        \"\"\"\n        # Check that we haven't gone and fetched the devices since we last\n        # checked if we needed to resync these device lists.\n        if await self.store.get_users_whose_devices_are_cached([user_id]):\n            cached = await self.store.get_cached_devices_for_user(user_id)\n            return cached, False\n\n        logger.debug(\"Attempting to resync the device list for %s\", user_id)\n        log_kv({\"message\": \"Doing resync to update device list.\"})\n        # Fetch all devices for the user.\n        origin = get_domain_from_id(user_id)\n        try:\n            result = await self.federation.query_user_devices(origin, user_id)\n        except NotRetryingDestination:\n            return None, True\n        except (RequestSendFailed, HttpResponseException) as e:\n            logger.warning(\n                \"Failed to handle device list update for %s: %s\",\n                user_id,\n                e,\n            )\n\n            # We abort on exceptions rather than accepting the update\n            # as otherwise synapse will 'forget' that its device list\n            # is out of date. If we bail then we will retry the resync\n            # next time we get a device list update for this user_id.\n            # This makes it more likely that the device lists will\n            # eventually become consistent.\n            return None, True\n        except FederationDeniedError as e:\n            set_tag(\"error\", True)\n            log_kv({\"reason\": \"FederationDeniedError\"})\n            logger.info(e)\n            return None, False\n        except Exception as e:\n            set_tag(\"error\", True)\n            log_kv(\n                {\"message\": \"Exception raised by federation request\", \"exception\": e}\n            )\n            logger.exception(\"Failed to handle device list update for %s\", user_id)\n\n            return None, True\n        log_kv({\"result\": result})\n        stream_id = result[\"stream_id\"]\n        devices = result[\"devices\"]\n\n        # Get the master key and the self-signing key for this user if provided in the\n        # response (None if not in the response).\n        # The response will not contain the user signing key, as this key is only used by\n        # its owner, thus it doesn't make sense to send it over federation.\n        master_key = result.get(\"master_key\")\n        self_signing_key = result.get(\"self_signing_key\")\n\n        ignore_devices = False\n        # If the remote server has more than ~1000 devices for this user\n        # we assume that something is going horribly wrong (e.g. a bot\n        # that logs in and creates a new device every time it tries to\n        # send a message).  Maintaining lots of devices per user in the\n        # cache can cause serious performance issues as if this request\n        # takes more than 60s to complete, internal replication from the\n        # inbound federation worker to the synapse master may time out\n        # causing the inbound federation to fail and causing the remote\n        # server to retry, causing a DoS.  So in this scenario we give\n        # up on storing the total list of devices and only handle the\n        # delta instead.\n        if len(devices) > 1000:\n            logger.warning(\n                \"Ignoring device list snapshot for %s as it has >1K devs (%d)\",\n                user_id,\n                len(devices),\n            )\n            devices = []\n            ignore_devices = True\n        else:\n            prev_stream_id = await self.store.get_device_list_last_stream_id_for_remote(\n                user_id\n            )\n            cached_devices = await self.store.get_cached_devices_for_user(user_id)\n\n            # To ensure that a user with no devices is cached, we skip the resync only\n            # if we have a stream_id from previously writing a cache entry.\n            if prev_stream_id is not None and cached_devices == {\n                d[\"device_id\"]: d for d in devices\n            }:\n                logging.info(\n                    \"Skipping device list resync for %s, as our cache matches already\",\n                    user_id,\n                )\n                devices = []\n                ignore_devices = True\n\n        for device in devices:\n            logger.debug(\n                \"Handling resync update %r/%r, ID: %r\",\n                user_id,\n                device[\"device_id\"],\n                stream_id,\n            )\n\n        if not ignore_devices:\n            await self.store.update_remote_device_list_cache(\n                user_id, devices, stream_id\n            )\n        # mark the cache as valid, whether or not we actually processed any device\n        # list updates.\n        await self.store.mark_remote_user_device_cache_as_valid(user_id)\n        device_ids = [device[\"device_id\"] for device in devices]\n\n        # Handle cross-signing keys.\n        cross_signing_device_ids = await self.process_cross_signing_key_update(\n            user_id,\n            master_key,\n            self_signing_key,\n        )\n        device_ids = device_ids + cross_signing_device_ids\n\n        if device_ids:\n            await self.device_handler.notify_device_update(user_id, device_ids)\n\n        # We clobber the seen updates since we've re-synced from a given\n        # point.\n        self._seen_updates[user_id] = {stream_id}\n\n        return result, False\n\n    async def process_cross_signing_key_update(\n        self,\n        user_id: str,\n        master_key: Optional[JsonDict],\n        self_signing_key: Optional[JsonDict],\n    ) -> List[str]:\n        \"\"\"Process the given new master and self-signing key for the given remote user.\n\n        Args:\n            user_id: The ID of the user these keys are for.\n            master_key: The dict of the cross-signing master key as returned by the\n                remote server.\n            self_signing_key: The dict of the cross-signing self-signing key as returned\n                by the remote server.\n\n        Return:\n            The device IDs for the given keys.\n        \"\"\"\n        device_ids = []\n\n        current_keys_map = await self.store.get_e2e_cross_signing_keys_bulk([user_id])\n        current_keys = current_keys_map.get(user_id) or {}\n\n        if master_key and master_key != current_keys.get(\"master\"):\n            await self.store.set_e2e_cross_signing_key(user_id, \"master\", master_key)\n            _, verify_key = get_verify_key_from_cross_signing_key(master_key)\n            # verify_key is a VerifyKey from signedjson, which uses\n            # .version to denote the portion of the key ID after the\n            # algorithm and colon, which is the device ID\n            device_ids.append(verify_key.version)\n        if self_signing_key and self_signing_key != current_keys.get(\"self_signing\"):\n            await self.store.set_e2e_cross_signing_key(\n                user_id, \"self_signing\", self_signing_key\n            )\n            _, verify_key = get_verify_key_from_cross_signing_key(self_signing_key)\n            device_ids.append(verify_key.version)\n\n        return device_ids\n\n    async def handle_room_un_partial_stated(self, room_id: str) -> None:\n        \"\"\"Handles sending appropriate device list updates in a room that has\n        gone from partial to full state.\n        \"\"\"\n\n        pending_updates = (\n            await self.store.get_pending_remote_device_list_updates_for_room(room_id)\n        )\n\n        for user_id, device_id in pending_updates:\n            logger.info(\n                \"Got pending device list update in room %s: %s / %s\",\n                room_id,\n                user_id,\n                device_id,\n            )\n            position = await self.store.add_device_change_to_streams(\n                user_id,\n                [device_id],\n                room_ids=[room_id],\n            )\n\n            if not position:\n                # This should only happen if there are no updates, which\n                # shouldn't happen when we've passed in a non-empty set of\n                # device IDs.\n                continue\n\n            self.device_handler.notifier.on_new_event(\n                StreamKeyType.DEVICE_LIST, position, rooms=[room_id]\n            )\n", "# Copyright 2016 OpenMarket Ltd\n# Copyright 2018-2019 New Vector Ltd\n# Copyright 2019 The Matrix.org Foundation C.I.C.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport logging\nfrom typing import TYPE_CHECKING, Dict, Iterable, List, Mapping, Optional, Tuple\n\nimport attr\nfrom canonicaljson import encode_canonical_json\nfrom signedjson.key import VerifyKey, decode_verify_key_bytes\nfrom signedjson.sign import SignatureVerifyException, verify_signed_json\nfrom unpaddedbase64 import decode_base64\n\nfrom twisted.internet import defer\n\nfrom synapse.api.constants import EduTypes\nfrom synapse.api.errors import CodeMessageException, Codes, NotFoundError, SynapseError\nfrom synapse.handlers.device import DeviceHandler\nfrom synapse.logging.context import make_deferred_yieldable, run_in_background\nfrom synapse.logging.opentracing import log_kv, set_tag, tag_args, trace\nfrom synapse.types import (\n    JsonDict,\n    JsonMapping,\n    UserID,\n    get_domain_from_id,\n    get_verify_key_from_cross_signing_key,\n)\nfrom synapse.util import json_decoder\nfrom synapse.util.async_helpers import Linearizer, concurrently_execute\nfrom synapse.util.cancellation import cancellable\nfrom synapse.util.retryutils import NotRetryingDestination\n\nif TYPE_CHECKING:\n    from synapse.server import HomeServer\n\nlogger = logging.getLogger(__name__)\n\n\nclass E2eKeysHandler:\n    def __init__(self, hs: \"HomeServer\"):\n        self.config = hs.config\n        self.store = hs.get_datastores().main\n        self.federation = hs.get_federation_client()\n        self.device_handler = hs.get_device_handler()\n        self._appservice_handler = hs.get_application_service_handler()\n        self.is_mine = hs.is_mine\n        self.clock = hs.get_clock()\n\n        federation_registry = hs.get_federation_registry()\n\n        is_master = hs.config.worker.worker_app is None\n        if is_master:\n            edu_updater = SigningKeyEduUpdater(hs)\n\n            # Only register this edu handler on master as it requires writing\n            # device updates to the db\n            federation_registry.register_edu_handler(\n                EduTypes.SIGNING_KEY_UPDATE,\n                edu_updater.incoming_signing_key_update,\n            )\n            # also handle the unstable version\n            # FIXME: remove this when enough servers have upgraded\n            federation_registry.register_edu_handler(\n                EduTypes.UNSTABLE_SIGNING_KEY_UPDATE,\n                edu_updater.incoming_signing_key_update,\n            )\n\n        # doesn't really work as part of the generic query API, because the\n        # query request requires an object POST, but we abuse the\n        # \"query handler\" interface.\n        federation_registry.register_query_handler(\n            \"client_keys\", self.on_federation_query_client_keys\n        )\n\n        # Limit the number of in-flight requests from a single device.\n        self._query_devices_linearizer = Linearizer(\n            name=\"query_devices\",\n            max_count=10,\n        )\n\n        self._query_appservices_for_otks = (\n            hs.config.experimental.msc3983_appservice_otk_claims\n        )\n        self._query_appservices_for_keys = (\n            hs.config.experimental.msc3984_appservice_key_query\n        )\n\n    @trace\n    @cancellable\n    async def query_devices(\n        self,\n        query_body: JsonDict,\n        timeout: int,\n        from_user_id: str,\n        from_device_id: Optional[str],\n    ) -> JsonDict:\n        \"\"\"Handle a device key query from a client\n\n        {\n            \"device_keys\": {\n                \"<user_id>\": [\"<device_id>\"]\n            }\n        }\n        ->\n        {\n            \"device_keys\": {\n                \"<user_id>\": {\n                    \"<device_id>\": {\n                        ...\n                    }\n                }\n            }\n        }\n\n        Args:\n            from_user_id: the user making the query.  This is used when\n                adding cross-signing signatures to limit what signatures users\n                can see.\n            from_device_id: the device making the query. This is used to limit\n                the number of in-flight queries at a time.\n        \"\"\"\n        async with self._query_devices_linearizer.queue((from_user_id, from_device_id)):\n            device_keys_query: Dict[str, List[str]] = query_body.get(\"device_keys\", {})\n\n            # separate users by domain.\n            # make a map from domain to user_id to device_ids\n            local_query = {}\n            remote_queries = {}\n\n            for user_id, device_ids in device_keys_query.items():\n                # we use UserID.from_string to catch invalid user ids\n                if self.is_mine(UserID.from_string(user_id)):\n                    local_query[user_id] = device_ids\n                else:\n                    remote_queries[user_id] = device_ids\n\n            set_tag(\"local_key_query\", str(local_query))\n            set_tag(\"remote_key_query\", str(remote_queries))\n\n            # First get local devices.\n            # A map of destination -> failure response.\n            failures: Dict[str, JsonDict] = {}\n            results = {}\n            if local_query:\n                local_result = await self.query_local_devices(local_query)\n                for user_id, keys in local_result.items():\n                    if user_id in local_query:\n                        results[user_id] = keys\n\n            # Get cached cross-signing keys\n            cross_signing_keys = await self.get_cross_signing_keys_from_cache(\n                device_keys_query, from_user_id\n            )\n\n            # Now attempt to get any remote devices from our local cache.\n            # A map of destination -> user ID -> device IDs.\n            remote_queries_not_in_cache: Dict[str, Dict[str, Iterable[str]]] = {}\n            if remote_queries:\n                user_ids = set()\n                user_and_device_ids: List[Tuple[str, str]] = []\n                for user_id, device_ids in remote_queries.items():\n                    if device_ids:\n                        user_and_device_ids.extend(\n                            (user_id, device_id) for device_id in device_ids\n                        )\n                    else:\n                        user_ids.add(user_id)\n\n                (\n                    user_ids_not_in_cache,\n                    remote_results,\n                ) = await self.store.get_user_devices_from_cache(\n                    user_ids, user_and_device_ids\n                )\n\n                # Check that the homeserver still shares a room with all cached users.\n                # Note that this check may be slightly racy when a remote user leaves a\n                # room after we have fetched their cached device list. In the worst case\n                # we will do extra federation queries for devices that we had cached.\n                cached_users = set(remote_results.keys())\n                valid_cached_users = (\n                    await self.store.get_users_server_still_shares_room_with(\n                        remote_results.keys()\n                    )\n                )\n                invalid_cached_users = cached_users - valid_cached_users\n                if invalid_cached_users:\n                    # Fix up results. If we get here, it means there was either a bug in\n                    # device list tracking, or we hit the race mentioned above.\n                    # TODO: In practice, this path is hit fairly often in existing\n                    #       deployments when clients query the keys of departed remote\n                    #       users. A background update to mark the appropriate device\n                    #       lists as unsubscribed is needed.\n                    #       https://github.com/matrix-org/synapse/issues/13651\n                    # Note that this currently introduces a failure mode when clients\n                    # are trying to decrypt old messages from a remote user whose\n                    # homeserver is no longer available. We may want to consider falling\n                    # back to the cached data when we fail to retrieve a device list\n                    # over federation for such remote users.\n                    user_ids_not_in_cache.update(invalid_cached_users)\n                    for invalid_user_id in invalid_cached_users:\n                        remote_results.pop(invalid_user_id)\n\n                for user_id, devices in remote_results.items():\n                    user_devices = results.setdefault(user_id, {})\n                    for device_id, device in devices.items():\n                        keys = device.get(\"keys\", None)\n                        device_display_name = device.get(\"device_display_name\", None)\n                        if keys:\n                            result = dict(keys)\n                            unsigned = result.setdefault(\"unsigned\", {})\n                            if device_display_name:\n                                unsigned[\"device_display_name\"] = device_display_name\n                            user_devices[device_id] = result\n\n                # check for missing cross-signing keys.\n                for user_id in remote_queries.keys():\n                    cached_cross_master = user_id in cross_signing_keys[\"master_keys\"]\n                    cached_cross_selfsigning = (\n                        user_id in cross_signing_keys[\"self_signing_keys\"]\n                    )\n\n                    # check if we are missing only one of cross-signing master or\n                    # self-signing key, but the other one is cached.\n                    # as we need both, this will issue a federation request.\n                    # if we don't have any of the keys, either the user doesn't have\n                    # cross-signing set up, or the cached device list\n                    # is not (yet) updated.\n                    if cached_cross_master ^ cached_cross_selfsigning:\n                        user_ids_not_in_cache.add(user_id)\n\n                # add those users to the list to fetch over federation.\n                for user_id in user_ids_not_in_cache:\n                    domain = get_domain_from_id(user_id)\n                    r = remote_queries_not_in_cache.setdefault(domain, {})\n                    r[user_id] = remote_queries[user_id]\n\n            # Now fetch any devices that we don't have in our cache\n            # TODO It might make sense to propagate cancellations into the\n            #      deferreds which are querying remote homeservers.\n            logger.debug(\n                \"%d destinations to query devices for\", len(remote_queries_not_in_cache)\n            )\n\n            async def _query(\n                destination_queries: Tuple[str, Dict[str, Iterable[str]]]\n            ) -> None:\n                destination, queries = destination_queries\n                return await self._query_devices_for_destination(\n                    results,\n                    cross_signing_keys,\n                    failures,\n                    destination,\n                    queries,\n                    timeout,\n                )\n\n            await concurrently_execute(\n                _query,\n                remote_queries_not_in_cache.items(),\n                10,\n                delay_cancellation=True,\n            )\n\n            return {\"device_keys\": results, \"failures\": failures, **cross_signing_keys}\n\n    @trace\n    async def _query_devices_for_destination(\n        self,\n        results: JsonDict,\n        cross_signing_keys: JsonDict,\n        failures: Dict[str, JsonDict],\n        destination: str,\n        destination_query: Dict[str, Iterable[str]],\n        timeout: int,\n    ) -> None:\n        \"\"\"This is called when we are querying the device list of a user on\n        a remote homeserver and their device list is not in the device list\n        cache. If we share a room with this user and we're not querying for\n        specific user we will update the cache with their device list.\n\n        Args:\n            results: A map from user ID to their device keys, which gets\n                updated with the newly fetched keys.\n            cross_signing_keys: Map from user ID to their cross signing keys,\n                which gets updated with the newly fetched keys.\n            failures: Map of destinations to failures that have occurred while\n                attempting to fetch keys.\n            destination: The remote server to query\n            destination_query: The query dict of devices to query the remote\n                server for.\n            timeout: The timeout for remote HTTP requests.\n        \"\"\"\n\n        # We first consider whether we wish to update the device list cache with\n        # the users device list. We want to track a user's devices when the\n        # authenticated user shares a room with the queried user and the query\n        # has not specified a particular device.\n        # If we update the cache for the queried user we remove them from further\n        # queries. We use the more efficient batched query_client_keys for all\n        # remaining users\n        user_ids_updated = []\n\n        # Perform a user device resync for each user only once and only as long as:\n        # - they have an empty device_list\n        # - they are in some rooms that this server can see\n        users_to_resync_devices = {\n            user_id\n            for (user_id, device_list) in destination_query.items()\n            if (not device_list) and (await self.store.get_rooms_for_user(user_id))\n        }\n\n        logger.debug(\n            \"%d users to resync devices for from destination %s\",\n            len(users_to_resync_devices),\n            destination,\n        )\n\n        try:\n            user_resync_results = (\n                await self.device_handler.device_list_updater.multi_user_device_resync(\n                    list(users_to_resync_devices)\n                )\n            )\n            for user_id in users_to_resync_devices:\n                resync_results = user_resync_results[user_id]\n\n                if resync_results is None:\n                    # TODO: It's weird that we'll store a failure against a\n                    #       destination, yet continue processing users from that\n                    #       destination.\n                    #       We might want to consider changing this, but for now\n                    #       I'm leaving it as I found it.\n                    failures[destination] = _exception_to_failure(\n                        ValueError(f\"Device resync failed for {user_id!r}\")\n                    )\n                    continue\n\n                # Add the device keys to the results.\n                user_devices = resync_results[\"devices\"]\n                user_results = results.setdefault(user_id, {})\n                for device in user_devices:\n                    user_results[device[\"device_id\"]] = device[\"keys\"]\n                user_ids_updated.append(user_id)\n\n                # Add any cross signing keys to the results.\n                master_key = resync_results.get(\"master_key\")\n                self_signing_key = resync_results.get(\"self_signing_key\")\n\n                if master_key:\n                    cross_signing_keys[\"master_keys\"][user_id] = master_key\n\n                if self_signing_key:\n                    cross_signing_keys[\"self_signing_keys\"][user_id] = self_signing_key\n        except Exception as e:\n            failures[destination] = _exception_to_failure(e)\n\n        if len(destination_query) == len(user_ids_updated):\n            # We've updated all the users in the query and we do not need to\n            # make any further remote calls.\n            return\n\n        # Remove all the users from the query which we have updated\n        for user_id in user_ids_updated:\n            destination_query.pop(user_id)\n\n        try:\n            remote_result = await self.federation.query_client_keys(\n                destination, {\"device_keys\": destination_query}, timeout=timeout\n            )\n\n            for user_id, keys in remote_result[\"device_keys\"].items():\n                if user_id in destination_query:\n                    results[user_id] = keys\n\n            if \"master_keys\" in remote_result:\n                for user_id, key in remote_result[\"master_keys\"].items():\n                    if user_id in destination_query:\n                        cross_signing_keys[\"master_keys\"][user_id] = key\n\n            if \"self_signing_keys\" in remote_result:\n                for user_id, key in remote_result[\"self_signing_keys\"].items():\n                    if user_id in destination_query:\n                        cross_signing_keys[\"self_signing_keys\"][user_id] = key\n\n        except Exception as e:\n            failure = _exception_to_failure(e)\n            failures[destination] = failure\n            set_tag(\"error\", True)\n            set_tag(\"reason\", str(failure))\n\n        return\n\n    @cancellable\n    async def get_cross_signing_keys_from_cache(\n        self, query: Iterable[str], from_user_id: Optional[str]\n    ) -> Dict[str, Dict[str, JsonMapping]]:\n        \"\"\"Get cross-signing keys for users from the database\n\n        Args:\n            query: an iterable of user IDs.  A dict whose keys\n                are user IDs satisfies this, so the query format used for\n                query_devices can be used here.\n            from_user_id: the user making the query.  This is used when\n                adding cross-signing signatures to limit what signatures users\n                can see.\n\n        Returns:\n            A map from (master_keys|self_signing_keys|user_signing_keys) -> user_id -> key\n        \"\"\"\n        master_keys = {}\n        self_signing_keys = {}\n        user_signing_keys = {}\n\n        user_ids = list(query)\n\n        keys = await self.store.get_e2e_cross_signing_keys_bulk(user_ids, from_user_id)\n\n        for user_id, user_info in keys.items():\n            if user_info is None:\n                continue\n            if \"master\" in user_info:\n                master_keys[user_id] = user_info[\"master\"]\n            if \"self_signing\" in user_info:\n                self_signing_keys[user_id] = user_info[\"self_signing\"]\n\n        # users can see other users' master and self-signing keys, but can\n        # only see their own user-signing keys\n        if from_user_id:\n            from_user_key = keys.get(from_user_id)\n            if from_user_key and \"user_signing\" in from_user_key:\n                user_signing_keys[from_user_id] = from_user_key[\"user_signing\"]\n\n        return {\n            \"master_keys\": master_keys,\n            \"self_signing_keys\": self_signing_keys,\n            \"user_signing_keys\": user_signing_keys,\n        }\n\n    @trace\n    @cancellable\n    async def query_local_devices(\n        self,\n        query: Mapping[str, Optional[List[str]]],\n        include_displaynames: bool = True,\n    ) -> Dict[str, Dict[str, dict]]:\n        \"\"\"Get E2E device keys for local users\n\n        Args:\n            query: map from user_id to a list\n                 of devices to query (None for all devices)\n            include_displaynames: Whether to include device displaynames in the returned\n                device details.\n\n        Returns:\n            A map from user_id -> device_id -> device details\n        \"\"\"\n        set_tag(\"local_query\", str(query))\n        local_query: List[Tuple[str, Optional[str]]] = []\n\n        result_dict: Dict[str, Dict[str, dict]] = {}\n        for user_id, device_ids in query.items():\n            # we use UserID.from_string to catch invalid user ids\n            if not self.is_mine(UserID.from_string(user_id)):\n                logger.warning(\"Request for keys for non-local user %s\", user_id)\n                log_kv(\n                    {\n                        \"message\": \"Requested a local key for a user which\"\n                        \" was not local to the homeserver\",\n                        \"user_id\": user_id,\n                    }\n                )\n                set_tag(\"error\", True)\n                raise SynapseError(400, \"Not a user here\")\n\n            if not device_ids:\n                local_query.append((user_id, None))\n            else:\n                for device_id in device_ids:\n                    local_query.append((user_id, device_id))\n\n            # make sure that each queried user appears in the result dict\n            result_dict[user_id] = {}\n\n        results = await self.store.get_e2e_device_keys_for_cs_api(\n            local_query, include_displaynames\n        )\n\n        # Check if the application services have any additional results.\n        if self._query_appservices_for_keys:\n            # Query the appservices for any keys.\n            appservice_results = await self._appservice_handler.query_keys(query)\n\n            # Merge results, overriding with what the appservice returned.\n            for user_id, devices in appservice_results.get(\"device_keys\", {}).items():\n                # Copy the appservice device info over the homeserver device info, but\n                # don't completely overwrite it.\n                results.setdefault(user_id, {}).update(devices)\n\n            # TODO Handle cross-signing keys.\n\n        # Build the result structure\n        for user_id, device_keys in results.items():\n            for device_id, device_info in device_keys.items():\n                result_dict[user_id][device_id] = device_info\n\n        log_kv(results)\n        return result_dict\n\n    async def on_federation_query_client_keys(\n        self, query_body: Dict[str, Dict[str, Optional[List[str]]]]\n    ) -> JsonDict:\n        \"\"\"Handle a device key query from a federated server:\n\n        Handles the path: GET /_matrix/federation/v1/users/keys/query\n\n        Args:\n            query_body: The body of the query request. Should contain a key\n                \"device_keys\" that map to a dictionary of user ID's -> list of\n                device IDs. If the list of device IDs is empty, all devices of\n                that user will be queried.\n\n        Returns:\n            A json dictionary containing the following:\n                - device_keys: A dictionary containing the requested device information.\n                - master_keys: An optional dictionary of user ID -> master cross-signing\n                   key info.\n                - self_signing_key: An optional dictionary of user ID -> self-signing\n                    key info.\n        \"\"\"\n        device_keys_query: Dict[str, Optional[List[str]]] = query_body.get(\n            \"device_keys\", {}\n        )\n        if any(\n            not self.is_mine(UserID.from_string(user_id))\n            for user_id in device_keys_query\n        ):\n            raise SynapseError(400, \"User is not hosted on this homeserver\")\n\n        res = await self.query_local_devices(\n            device_keys_query,\n            include_displaynames=(\n                self.config.federation.allow_device_name_lookup_over_federation\n            ),\n        )\n\n        # add in the cross-signing keys\n        cross_signing_keys = await self.get_cross_signing_keys_from_cache(\n            device_keys_query, None\n        )\n\n        return {\"device_keys\": res, **cross_signing_keys}\n\n    async def claim_local_one_time_keys(\n        self,\n        local_query: List[Tuple[str, str, str, int]],\n        always_include_fallback_keys: bool,\n    ) -> Iterable[Dict[str, Dict[str, Dict[str, JsonDict]]]]:\n        \"\"\"Claim one time keys for local users.\n\n        1. Attempt to claim OTKs from the database.\n        2. Ask application services if they provide OTKs.\n        3. Attempt to fetch fallback keys from the database.\n\n        Args:\n            local_query: An iterable of tuples of (user ID, device ID, algorithm).\n            always_include_fallback_keys: True to always include fallback keys.\n\n        Returns:\n            An iterable of maps of user ID -> a map device ID -> a map of key ID -> JSON bytes.\n        \"\"\"\n\n        # Cap the number of OTKs that can be claimed at once to avoid abuse.\n        local_query = [\n            (user_id, device_id, algorithm, min(count, 5))\n            for user_id, device_id, algorithm, count in local_query\n        ]\n\n        otk_results, not_found = await self.store.claim_e2e_one_time_keys(local_query)\n\n        # If the application services have not provided any keys via the C-S\n        # API, query it directly for one-time keys.\n        if self._query_appservices_for_otks:\n            # TODO Should this query for fallback keys of uploaded OTKs if\n            #      always_include_fallback_keys is True? The MSC is ambiguous.\n            (\n                appservice_results,\n                not_found,\n            ) = await self._appservice_handler.claim_e2e_one_time_keys(not_found)\n        else:\n            appservice_results = {}\n\n        # Calculate which user ID / device ID / algorithm tuples to get fallback\n        # keys for. This can be either only missing results *or* all results\n        # (which don't already have a fallback key).\n        if always_include_fallback_keys:\n            # Build the fallback query as any part of the original query where\n            # the appservice didn't respond with a fallback key.\n            fallback_query = []\n\n            # Iterate each item in the original query and search the results\n            # from the appservice for that user ID / device ID. If it is found,\n            # check if any of the keys match the requested algorithm & are a\n            # fallback key.\n            for user_id, device_id, algorithm, _count in local_query:\n                # Check if the appservice responded for this query.\n                as_result = appservice_results.get(user_id, {}).get(device_id, {})\n                found_otk = False\n                for key_id, key_json in as_result.items():\n                    if key_id.startswith(f\"{algorithm}:\"):\n                        # A OTK or fallback key was found for this query.\n                        found_otk = True\n                        # A fallback key was found for this query, no need to\n                        # query further.\n                        if key_json.get(\"fallback\", False):\n                            break\n\n                else:\n                    # No fallback key was found from appservices, query for it.\n                    # Only mark the fallback key as used if no OTK was found\n                    # (from either the database or appservices).\n                    mark_as_used = not found_otk and not any(\n                        key_id.startswith(f\"{algorithm}:\")\n                        for key_id in otk_results.get(user_id, {})\n                        .get(device_id, {})\n                        .keys()\n                    )\n                    # Note that it doesn't make sense to request more than 1 fallback key\n                    # per (user_id, device_id, algorithm).\n                    fallback_query.append((user_id, device_id, algorithm, mark_as_used))\n\n        else:\n            # All fallback keys get marked as used.\n            fallback_query = [\n                # Note that it doesn't make sense to request more than 1 fallback key\n                # per (user_id, device_id, algorithm).\n                (user_id, device_id, algorithm, True)\n                for user_id, device_id, algorithm, count in not_found\n            ]\n\n        # For each user that does not have a one-time keys available, see if\n        # there is a fallback key.\n        fallback_results = await self.store.claim_e2e_fallback_keys(fallback_query)\n\n        # Return the results in order, each item from the input query should\n        # only appear once in the combined list.\n        return (otk_results, appservice_results, fallback_results)\n\n    @trace\n    async def claim_one_time_keys(\n        self,\n        query: Dict[str, Dict[str, Dict[str, int]]],\n        user: UserID,\n        timeout: Optional[int],\n        always_include_fallback_keys: bool,\n    ) -> JsonDict:\n        local_query: List[Tuple[str, str, str, int]] = []\n        remote_queries: Dict[str, Dict[str, Dict[str, Dict[str, int]]]] = {}\n\n        for user_id, one_time_keys in query.items():\n            # we use UserID.from_string to catch invalid user ids\n            if self.is_mine(UserID.from_string(user_id)):\n                for device_id, algorithms in one_time_keys.items():\n                    for algorithm, count in algorithms.items():\n                        local_query.append((user_id, device_id, algorithm, count))\n            else:\n                domain = get_domain_from_id(user_id)\n                remote_queries.setdefault(domain, {})[user_id] = one_time_keys\n\n        set_tag(\"local_key_query\", str(local_query))\n        set_tag(\"remote_key_query\", str(remote_queries))\n\n        results = await self.claim_local_one_time_keys(\n            local_query, always_include_fallback_keys\n        )\n\n        # A map of user ID -> device ID -> key ID -> key.\n        json_result: Dict[str, Dict[str, Dict[str, JsonDict]]] = {}\n        for result in results:\n            for user_id, device_keys in result.items():\n                for device_id, keys in device_keys.items():\n                    for key_id, key in keys.items():\n                        json_result.setdefault(user_id, {}).setdefault(\n                            device_id, {}\n                        ).update({key_id: key})\n\n        # Remote failures.\n        failures: Dict[str, JsonDict] = {}\n\n        @trace\n        async def claim_client_keys(destination: str) -> None:\n            set_tag(\"destination\", destination)\n            device_keys = remote_queries[destination]\n            try:\n                remote_result = await self.federation.claim_client_keys(\n                    user, destination, device_keys, timeout=timeout\n                )\n                for user_id, keys in remote_result[\"one_time_keys\"].items():\n                    if user_id in device_keys:\n                        json_result[user_id] = keys\n\n            except Exception as e:\n                failure = _exception_to_failure(e)\n                failures[destination] = failure\n                set_tag(\"error\", True)\n                set_tag(\"reason\", str(failure))\n\n        await make_deferred_yieldable(\n            defer.gatherResults(\n                [\n                    run_in_background(claim_client_keys, destination)\n                    for destination in remote_queries\n                ],\n                consumeErrors=True,\n            )\n        )\n\n        logger.info(\n            \"Claimed one-time-keys: %s\",\n            \",\".join(\n                (\n                    \"%s for %s:%s\" % (key_id, user_id, device_id)\n                    for user_id, user_keys in json_result.items()\n                    for device_id, device_keys in user_keys.items()\n                    for key_id, _ in device_keys.items()\n                )\n            ),\n        )\n\n        log_kv({\"one_time_keys\": json_result, \"failures\": failures})\n        return {\"one_time_keys\": json_result, \"failures\": failures}\n\n    @tag_args\n    async def upload_keys_for_user(\n        self, user_id: str, device_id: str, keys: JsonDict\n    ) -> JsonDict:\n        # This can only be called from the main process.\n        assert isinstance(self.device_handler, DeviceHandler)\n\n        time_now = self.clock.time_msec()\n\n        # TODO: Validate the JSON to make sure it has the right keys.\n        device_keys = keys.get(\"device_keys\", None)\n        if device_keys:\n            logger.info(\n                \"Updating device_keys for device %r for user %s at %d\",\n                device_id,\n                user_id,\n                time_now,\n            )\n            log_kv(\n                {\n                    \"message\": \"Updating device_keys for user.\",\n                    \"user_id\": user_id,\n                    \"device_id\": device_id,\n                }\n            )\n            # TODO: Sign the JSON with the server key\n            changed = await self.store.set_e2e_device_keys(\n                user_id, device_id, time_now, device_keys\n            )\n            if changed:\n                # Only notify about device updates *if* the keys actually changed\n                await self.device_handler.notify_device_update(user_id, [device_id])\n        else:\n            log_kv({\"message\": \"Not updating device_keys for user\", \"user_id\": user_id})\n        one_time_keys = keys.get(\"one_time_keys\", None)\n        if one_time_keys:\n            log_kv(\n                {\n                    \"message\": \"Updating one_time_keys for device.\",\n                    \"user_id\": user_id,\n                    \"device_id\": device_id,\n                }\n            )\n            await self._upload_one_time_keys_for_user(\n                user_id, device_id, time_now, one_time_keys\n            )\n        else:\n            log_kv(\n                {\"message\": \"Did not update one_time_keys\", \"reason\": \"no keys given\"}\n            )\n        fallback_keys = keys.get(\"fallback_keys\") or keys.get(\n            \"org.matrix.msc2732.fallback_keys\"\n        )\n        if fallback_keys and isinstance(fallback_keys, dict):\n            log_kv(\n                {\n                    \"message\": \"Updating fallback_keys for device.\",\n                    \"user_id\": user_id,\n                    \"device_id\": device_id,\n                }\n            )\n            await self.store.set_e2e_fallback_keys(user_id, device_id, fallback_keys)\n        elif fallback_keys:\n            log_kv({\"message\": \"Did not update fallback_keys\", \"reason\": \"not a dict\"})\n        else:\n            log_kv(\n                {\"message\": \"Did not update fallback_keys\", \"reason\": \"no keys given\"}\n            )\n\n        # the device should have been registered already, but it may have been\n        # deleted due to a race with a DELETE request. Or we may be using an\n        # old access_token without an associated device_id. Either way, we\n        # need to double-check the device is registered to avoid ending up with\n        # keys without a corresponding device.\n        await self.device_handler.check_device_registered(user_id, device_id)\n\n        result = await self.store.count_e2e_one_time_keys(user_id, device_id)\n\n        set_tag(\"one_time_key_counts\", str(result))\n        return {\"one_time_key_counts\": result}\n\n    async def _upload_one_time_keys_for_user(\n        self, user_id: str, device_id: str, time_now: int, one_time_keys: JsonDict\n    ) -> None:\n        logger.info(\n            \"Adding one_time_keys %r for device %r for user %r at %d\",\n            one_time_keys.keys(),\n            device_id,\n            user_id,\n            time_now,\n        )\n\n        # make a list of (alg, id, key) tuples\n        key_list = []\n        for key_id, key_obj in one_time_keys.items():\n            algorithm, key_id = key_id.split(\":\")\n            key_list.append((algorithm, key_id, key_obj))\n\n        # First we check if we have already persisted any of the keys.\n        existing_key_map = await self.store.get_e2e_one_time_keys(\n            user_id, device_id, [k_id for _, k_id, _ in key_list]\n        )\n\n        new_keys = []  # Keys that we need to insert. (alg, id, json) tuples.\n        for algorithm, key_id, key in key_list:\n            ex_json = existing_key_map.get((algorithm, key_id), None)\n            if ex_json:\n                if not _one_time_keys_match(ex_json, key):\n                    raise SynapseError(\n                        400,\n                        (\n                            \"One time key %s:%s already exists. \"\n                            \"Old key: %s; new key: %r\"\n                        )\n                        % (algorithm, key_id, ex_json, key),\n                    )\n            else:\n                new_keys.append(\n                    (algorithm, key_id, encode_canonical_json(key).decode(\"ascii\"))\n                )\n\n        log_kv({\"message\": \"Inserting new one_time_keys.\", \"keys\": new_keys})\n        await self.store.add_e2e_one_time_keys(user_id, device_id, time_now, new_keys)\n\n    async def upload_signing_keys_for_user(\n        self, user_id: str, keys: JsonDict\n    ) -> JsonDict:\n        \"\"\"Upload signing keys for cross-signing\n\n        Args:\n            user_id: the user uploading the keys\n            keys: the signing keys\n        \"\"\"\n        # This can only be called from the main process.\n        assert isinstance(self.device_handler, DeviceHandler)\n\n        # if a master key is uploaded, then check it.  Otherwise, load the\n        # stored master key, to check signatures on other keys\n        if \"master_key\" in keys:\n            master_key = keys[\"master_key\"]\n\n            _check_cross_signing_key(master_key, user_id, \"master\")\n        else:\n            master_key = await self.store.get_e2e_cross_signing_key(user_id, \"master\")\n\n        # if there is no master key, then we can't do anything, because all the\n        # other cross-signing keys need to be signed by the master key\n        if not master_key:\n            raise SynapseError(400, \"No master key available\", Codes.MISSING_PARAM)\n\n        try:\n            master_key_id, master_verify_key = get_verify_key_from_cross_signing_key(\n                master_key\n            )\n        except ValueError:\n            if \"master_key\" in keys:\n                # the invalid key came from the request\n                raise SynapseError(400, \"Invalid master key\", Codes.INVALID_PARAM)\n            else:\n                # the invalid key came from the database\n                logger.error(\"Invalid master key found for user %s\", user_id)\n                raise SynapseError(500, \"Invalid master key\")\n\n        # for the other cross-signing keys, make sure that they have valid\n        # signatures from the master key\n        if \"self_signing_key\" in keys:\n            self_signing_key = keys[\"self_signing_key\"]\n\n            _check_cross_signing_key(\n                self_signing_key, user_id, \"self_signing\", master_verify_key\n            )\n\n        if \"user_signing_key\" in keys:\n            user_signing_key = keys[\"user_signing_key\"]\n\n            _check_cross_signing_key(\n                user_signing_key, user_id, \"user_signing\", master_verify_key\n            )\n\n        # if everything checks out, then store the keys and send notifications\n        deviceids = []\n        if \"master_key\" in keys:\n            await self.store.set_e2e_cross_signing_key(user_id, \"master\", master_key)\n            deviceids.append(master_verify_key.version)\n        if \"self_signing_key\" in keys:\n            await self.store.set_e2e_cross_signing_key(\n                user_id, \"self_signing\", self_signing_key\n            )\n            try:\n                deviceids.append(\n                    get_verify_key_from_cross_signing_key(self_signing_key)[1].version\n                )\n            except ValueError:\n                raise SynapseError(400, \"Invalid self-signing key\", Codes.INVALID_PARAM)\n        if \"user_signing_key\" in keys:\n            await self.store.set_e2e_cross_signing_key(\n                user_id, \"user_signing\", user_signing_key\n            )\n            # the signature stream matches the semantics that we want for\n            # user-signing key updates: only the user themselves is notified of\n            # their own user-signing key updates\n            await self.device_handler.notify_user_signature_update(user_id, [user_id])\n\n        # master key and self-signing key updates match the semantics of device\n        # list updates: all users who share an encrypted room are notified\n        if len(deviceids):\n            await self.device_handler.notify_device_update(user_id, deviceids)\n\n        return {}\n\n    async def upload_signatures_for_device_keys(\n        self, user_id: str, signatures: JsonDict\n    ) -> JsonDict:\n        \"\"\"Upload device signatures for cross-signing\n\n        Args:\n            user_id: the user uploading the signatures\n            signatures: map of users to devices to signed keys. This is the submission\n            from the user; an exception will be raised if it is malformed.\n        Returns:\n            The response to be sent back to the client.  The response will have\n                a \"failures\" key, which will be a dict mapping users to devices\n                to errors for the signatures that failed.\n        Raises:\n            SynapseError: if the signatures dict is not valid.\n        \"\"\"\n        # This can only be called from the main process.\n        assert isinstance(self.device_handler, DeviceHandler)\n\n        failures = {}\n\n        # signatures to be stored.  Each item will be a SignatureListItem\n        signature_list = []\n\n        # split between checking signatures for own user and signatures for\n        # other users, since we verify them with different keys\n        self_signatures = signatures.get(user_id, {})\n        other_signatures = {k: v for k, v in signatures.items() if k != user_id}\n\n        self_signature_list, self_failures = await self._process_self_signatures(\n            user_id, self_signatures\n        )\n        signature_list.extend(self_signature_list)\n        failures.update(self_failures)\n\n        other_signature_list, other_failures = await self._process_other_signatures(\n            user_id, other_signatures\n        )\n        signature_list.extend(other_signature_list)\n        failures.update(other_failures)\n\n        # store the signature, and send the appropriate notifications for sync\n        logger.debug(\"upload signature failures: %r\", failures)\n        await self.store.store_e2e_cross_signing_signatures(user_id, signature_list)\n\n        self_device_ids = [item.target_device_id for item in self_signature_list]\n        if self_device_ids:\n            await self.device_handler.notify_device_update(user_id, self_device_ids)\n        signed_users = [item.target_user_id for item in other_signature_list]\n        if signed_users:\n            await self.device_handler.notify_user_signature_update(\n                user_id, signed_users\n            )\n\n        return {\"failures\": failures}\n\n    async def _process_self_signatures(\n        self, user_id: str, signatures: JsonDict\n    ) -> Tuple[List[\"SignatureListItem\"], Dict[str, Dict[str, dict]]]:\n        \"\"\"Process uploaded signatures of the user's own keys.\n\n        Signatures of the user's own keys from this API come in two forms:\n        - signatures of the user's devices by the user's self-signing key,\n        - signatures of the user's master key by the user's devices.\n\n        Args:\n            user_id: the user uploading the keys\n            signatures (dict[string, dict]): map of devices to signed keys\n\n        Returns:\n            A tuple of a list of signatures to store, and a map of users to\n            devices to failure reasons\n\n        Raises:\n            SynapseError: if the input is malformed\n        \"\"\"\n        signature_list: List[\"SignatureListItem\"] = []\n        failures: Dict[str, Dict[str, JsonDict]] = {}\n        if not signatures:\n            return signature_list, failures\n\n        if not isinstance(signatures, dict):\n            raise SynapseError(400, \"Invalid parameter\", Codes.INVALID_PARAM)\n\n        try:\n            # get our self-signing key to verify the signatures\n            (\n                _,\n                self_signing_key_id,\n                self_signing_verify_key,\n            ) = await self._get_e2e_cross_signing_verify_key(user_id, \"self_signing\")\n\n            # get our master key, since we may have received a signature of it.\n            # We need to fetch it here so that we know what its key ID is, so\n            # that we can check if a signature that was sent is a signature of\n            # the master key or of a device\n            (\n                master_key,\n                _,\n                master_verify_key,\n            ) = await self._get_e2e_cross_signing_verify_key(user_id, \"master\")\n\n            # fetch our stored devices.  This is used to 1. verify\n            # signatures on the master key, and 2. to compare with what\n            # was sent if the device was signed\n            devices = await self.store.get_e2e_device_keys_for_cs_api([(user_id, None)])\n\n            if user_id not in devices:\n                raise NotFoundError(\"No device keys found\")\n\n            devices = devices[user_id]\n        except SynapseError as e:\n            failure = _exception_to_failure(e)\n            failures[user_id] = {device: failure for device in signatures.keys()}\n            return signature_list, failures\n\n        for device_id, device in signatures.items():\n            # make sure submitted data is in the right form\n            if not isinstance(device, dict):\n                raise SynapseError(400, \"Invalid parameter\", Codes.INVALID_PARAM)\n\n            try:\n                if \"signatures\" not in device or user_id not in device[\"signatures\"]:\n                    # no signature was sent\n                    raise SynapseError(\n                        400, \"Invalid signature\", Codes.INVALID_SIGNATURE\n                    )\n\n                if device_id == master_verify_key.version:\n                    # The signature is of the master key. This needs to be\n                    # handled differently from signatures of normal devices.\n                    master_key_signature_list = self._check_master_key_signature(\n                        user_id, device_id, device, master_key, devices\n                    )\n                    signature_list.extend(master_key_signature_list)\n                    continue\n\n                # at this point, we have a device that should be signed\n                # by the self-signing key\n                if self_signing_key_id not in device[\"signatures\"][user_id]:\n                    # no signature was sent\n                    raise SynapseError(\n                        400, \"Invalid signature\", Codes.INVALID_SIGNATURE\n                    )\n\n                try:\n                    stored_device = devices[device_id]\n                except KeyError:\n                    raise NotFoundError(\"Unknown device\")\n                if self_signing_key_id in stored_device.get(\"signatures\", {}).get(\n                    user_id, {}\n                ):\n                    # we already have a signature on this device, so we\n                    # can skip it, since it should be exactly the same\n                    continue\n\n                _check_device_signature(\n                    user_id, self_signing_verify_key, device, stored_device\n                )\n\n                signature = device[\"signatures\"][user_id][self_signing_key_id]\n                signature_list.append(\n                    SignatureListItem(\n                        self_signing_key_id, user_id, device_id, signature\n                    )\n                )\n            except SynapseError as e:\n                failures.setdefault(user_id, {})[device_id] = _exception_to_failure(e)\n\n        return signature_list, failures\n\n    def _check_master_key_signature(\n        self,\n        user_id: str,\n        master_key_id: str,\n        signed_master_key: JsonDict,\n        stored_master_key: JsonMapping,\n        devices: Dict[str, Dict[str, JsonDict]],\n    ) -> List[\"SignatureListItem\"]:\n        \"\"\"Check signatures of a user's master key made by their devices.\n\n        Args:\n            user_id: the user whose master key is being checked\n            master_key_id: the ID of the user's master key\n            signed_master_key: the user's signed master key that was uploaded\n            stored_master_key: our previously-stored copy of the user's master key\n            devices: the user's devices\n\n        Returns:\n            A list of signatures to store\n\n        Raises:\n            SynapseError: if a signature is invalid\n        \"\"\"\n        # for each device that signed the master key, check the signature.\n        master_key_signature_list = []\n        sigs = signed_master_key[\"signatures\"]\n        for signing_key_id, signature in sigs[user_id].items():\n            _, signing_device_id = signing_key_id.split(\":\", 1)\n            if (\n                signing_device_id not in devices\n                or signing_key_id not in devices[signing_device_id][\"keys\"]\n            ):\n                # signed by an unknown device, or the\n                # device does not have the key\n                raise SynapseError(400, \"Invalid signature\", Codes.INVALID_SIGNATURE)\n\n            # get the key and check the signature\n            pubkey = devices[signing_device_id][\"keys\"][signing_key_id]\n            verify_key = decode_verify_key_bytes(signing_key_id, decode_base64(pubkey))\n            _check_device_signature(\n                user_id, verify_key, signed_master_key, stored_master_key\n            )\n\n            master_key_signature_list.append(\n                SignatureListItem(signing_key_id, user_id, master_key_id, signature)\n            )\n\n        return master_key_signature_list\n\n    async def _process_other_signatures(\n        self, user_id: str, signatures: Dict[str, dict]\n    ) -> Tuple[List[\"SignatureListItem\"], Dict[str, Dict[str, dict]]]:\n        \"\"\"Process uploaded signatures of other users' keys.  These will be the\n        target user's master keys, signed by the uploading user's user-signing\n        key.\n\n        Args:\n            user_id: the user uploading the keys\n            signatures: map of users to devices to signed keys\n\n        Returns:\n            A list of signatures to store, and a map of users to devices to failure\n            reasons\n\n        Raises:\n            SynapseError: if the input is malformed\n        \"\"\"\n        signature_list: List[\"SignatureListItem\"] = []\n        failures: Dict[str, Dict[str, JsonDict]] = {}\n        if not signatures:\n            return signature_list, failures\n\n        try:\n            # get our user-signing key to verify the signatures\n            (\n                user_signing_key,\n                user_signing_key_id,\n                user_signing_verify_key,\n            ) = await self._get_e2e_cross_signing_verify_key(user_id, \"user_signing\")\n        except SynapseError as e:\n            failure = _exception_to_failure(e)\n            for user, devicemap in signatures.items():\n                failures[user] = {device_id: failure for device_id in devicemap.keys()}\n            return signature_list, failures\n\n        for target_user, devicemap in signatures.items():\n            # make sure submitted data is in the right form\n            if not isinstance(devicemap, dict):\n                raise SynapseError(400, \"Invalid parameter\", Codes.INVALID_PARAM)\n            for device in devicemap.values():\n                if not isinstance(device, dict):\n                    raise SynapseError(400, \"Invalid parameter\", Codes.INVALID_PARAM)\n\n            device_id = None\n            try:\n                # get the target user's master key, to make sure it matches\n                # what was sent\n                (\n                    master_key,\n                    master_key_id,\n                    _,\n                ) = await self._get_e2e_cross_signing_verify_key(\n                    target_user, \"master\", user_id\n                )\n\n                # make sure that the target user's master key is the one that\n                # was signed (and no others)\n                device_id = master_key_id.split(\":\", 1)[1]\n                if device_id not in devicemap:\n                    logger.debug(\n                        \"upload signature: could not find signature for device %s\",\n                        device_id,\n                    )\n                    # set device to None so that the failure gets\n                    # marked on all the signatures\n                    device_id = None\n                    raise NotFoundError(\"Unknown device\")\n                key = devicemap[device_id]\n                other_devices = [k for k in devicemap.keys() if k != device_id]\n                if other_devices:\n                    # other devices were signed -- mark those as failures\n                    logger.debug(\"upload signature: too many devices specified\")\n                    failure = _exception_to_failure(NotFoundError(\"Unknown device\"))\n                    failures[target_user] = {\n                        device: failure for device in other_devices\n                    }\n\n                if user_signing_key_id in master_key.get(\"signatures\", {}).get(\n                    user_id, {}\n                ):\n                    # we already have the signature, so we can skip it\n                    continue\n\n                _check_device_signature(\n                    user_id, user_signing_verify_key, key, master_key\n                )\n\n                signature = key[\"signatures\"][user_id][user_signing_key_id]\n                signature_list.append(\n                    SignatureListItem(\n                        user_signing_key_id, target_user, device_id, signature\n                    )\n                )\n            except SynapseError as e:\n                failure = _exception_to_failure(e)\n                if device_id is None:\n                    failures[target_user] = {\n                        device_id: failure for device_id in devicemap.keys()\n                    }\n                else:\n                    failures.setdefault(target_user, {})[device_id] = failure\n\n        return signature_list, failures\n\n    async def _get_e2e_cross_signing_verify_key(\n        self, user_id: str, key_type: str, from_user_id: Optional[str] = None\n    ) -> Tuple[JsonMapping, str, VerifyKey]:\n        \"\"\"Fetch locally or remotely query for a cross-signing public key.\n\n        First, attempt to fetch the cross-signing public key from storage.\n        If that fails, query the keys from the homeserver they belong to\n        and update our local copy.\n\n        Args:\n            user_id: the user whose key should be fetched\n            key_type: the type of key to fetch\n            from_user_id: the user that we are fetching the keys for.\n                This affects what signatures are fetched.\n\n        Returns:\n            The raw key data, the key ID, and the signedjson verify key\n\n        Raises:\n            NotFoundError: if the key is not found\n            SynapseError: if `user_id` is invalid\n        \"\"\"\n        user = UserID.from_string(user_id)\n        key = await self.store.get_e2e_cross_signing_key(\n            user_id, key_type, from_user_id\n        )\n\n        if key:\n            # We found a copy of this key in our database. Decode and return it\n            key_id, verify_key = get_verify_key_from_cross_signing_key(key)\n            return key, key_id, verify_key\n\n        # If we couldn't find the key locally, and we're looking for keys of\n        # another user then attempt to fetch the missing key from the remote\n        # user's server.\n        #\n        # We may run into this in possible edge cases where a user tries to\n        # cross-sign a remote user, but does not share any rooms with them yet.\n        # Thus, we would not have their key list yet. We instead fetch the key,\n        # store it and notify clients of new, associated device IDs.\n        if self.is_mine(user) or key_type not in [\"master\", \"self_signing\"]:\n            # Note that master and self_signing keys are the only cross-signing keys we\n            # can request over federation\n            raise NotFoundError(\"No %s key found for %s\" % (key_type, user_id))\n\n        cross_signing_keys = await self._retrieve_cross_signing_keys_for_remote_user(\n            user, key_type\n        )\n        if cross_signing_keys is None:\n            raise NotFoundError(\"No %s key found for %s\" % (key_type, user_id))\n\n        return cross_signing_keys\n\n    async def _retrieve_cross_signing_keys_for_remote_user(\n        self,\n        user: UserID,\n        desired_key_type: str,\n    ) -> Optional[Tuple[JsonMapping, str, VerifyKey]]:\n        \"\"\"Queries cross-signing keys for a remote user and saves them to the database\n\n        Only the key specified by `key_type` will be returned, while all retrieved keys\n        will be saved regardless\n\n        Args:\n            user: The user to query remote keys for\n            desired_key_type: The type of key to receive. One of \"master\", \"self_signing\"\n\n        Returns:\n            A tuple of the retrieved key content, the key's ID and the matching VerifyKey.\n            If the key cannot be retrieved, all values in the tuple will instead be None.\n        \"\"\"\n        # This can only be called from the main process.\n        assert isinstance(self.device_handler, DeviceHandler)\n\n        try:\n            remote_result = await self.federation.query_user_devices(\n                user.domain, user.to_string()\n            )\n        except Exception as e:\n            logger.warning(\n                \"Unable to query %s for cross-signing keys of user %s: %s %s\",\n                user.domain,\n                user.to_string(),\n                type(e),\n                e,\n            )\n            return None\n\n        # Process each of the retrieved cross-signing keys\n        desired_key_data = None\n        retrieved_device_ids = []\n        for key_type in [\"master\", \"self_signing\"]:\n            key_content = remote_result.get(key_type + \"_key\")\n            if not key_content:\n                continue\n\n            # Ensure these keys belong to the correct user\n            if \"user_id\" not in key_content:\n                logger.warning(\n                    \"Invalid %s key retrieved, missing user_id field: %s\",\n                    key_type,\n                    key_content,\n                )\n                continue\n            if user.to_string() != key_content[\"user_id\"]:\n                logger.warning(\n                    \"Found %s key of user %s when querying for keys of user %s\",\n                    key_type,\n                    key_content[\"user_id\"],\n                    user.to_string(),\n                )\n                continue\n\n            # Validate the key contents\n            try:\n                # verify_key is a VerifyKey from signedjson, which uses\n                # .version to denote the portion of the key ID after the\n                # algorithm and colon, which is the device ID\n                key_id, verify_key = get_verify_key_from_cross_signing_key(key_content)\n            except ValueError as e:\n                logger.warning(\n                    \"Invalid %s key retrieved: %s - %s %s\",\n                    key_type,\n                    key_content,\n                    type(e),\n                    e,\n                )\n                continue\n\n            # Note down the device ID attached to this key\n            retrieved_device_ids.append(verify_key.version)\n\n            # If this is the desired key type, save it and its ID/VerifyKey\n            if key_type == desired_key_type:\n                desired_key_data = key_content, key_id, verify_key\n\n            # At the same time, store this key in the db for subsequent queries\n            await self.store.set_e2e_cross_signing_key(\n                user.to_string(), key_type, key_content\n            )\n\n        # Notify clients that new devices for this user have been discovered\n        if retrieved_device_ids:\n            # XXX is this necessary?\n            await self.device_handler.notify_device_update(\n                user.to_string(), retrieved_device_ids\n            )\n\n        return desired_key_data\n\n    async def is_cross_signing_set_up_for_user(self, user_id: str) -> bool:\n        \"\"\"Checks if the user has cross-signing set up\n\n        Args:\n            user_id: The user to check\n\n        Returns:\n            True if the user has cross-signing set up, False otherwise\n        \"\"\"\n        existing_master_key = await self.store.get_e2e_cross_signing_key(\n            user_id, \"master\"\n        )\n        return existing_master_key is not None\n\n\ndef _check_cross_signing_key(\n    key: JsonDict, user_id: str, key_type: str, signing_key: Optional[VerifyKey] = None\n) -> None:\n    \"\"\"Check a cross-signing key uploaded by a user.  Performs some basic sanity\n    checking, and ensures that it is signed, if a signature is required.\n\n    Args:\n        key: the key data to verify\n        user_id: the user whose key is being checked\n        key_type: the type of key that the key should be\n        signing_key: the signing key that the key should be signed with.  If\n            omitted, signatures will not be checked.\n    \"\"\"\n    if (\n        key.get(\"user_id\") != user_id\n        or key_type not in key.get(\"usage\", [])\n        or len(key.get(\"keys\", {})) != 1\n    ):\n        raise SynapseError(400, (\"Invalid %s key\" % (key_type,)), Codes.INVALID_PARAM)\n\n    if signing_key:\n        try:\n            verify_signed_json(key, user_id, signing_key)\n        except SignatureVerifyException:\n            raise SynapseError(\n                400, (\"Invalid signature on %s key\" % key_type), Codes.INVALID_SIGNATURE\n            )\n\n\ndef _check_device_signature(\n    user_id: str,\n    verify_key: VerifyKey,\n    signed_device: JsonDict,\n    stored_device: JsonMapping,\n) -> None:\n    \"\"\"Check that a signature on a device or cross-signing key is correct and\n    matches the copy of the device/key that we have stored.  Throws an\n    exception if an error is detected.\n\n    Args:\n        user_id: the user ID whose signature is being checked\n        verify_key: the key to verify the device with\n        signed_device: the uploaded signed device data\n        stored_device: our previously stored copy of the device\n\n    Raises:\n        SynapseError: if the signature was invalid or the sent device is not the\n            same as the stored device\n\n    \"\"\"\n\n    # make sure that the device submitted matches what we have stored\n    stripped_signed_device = {\n        k: v for k, v in signed_device.items() if k not in [\"signatures\", \"unsigned\"]\n    }\n    stripped_stored_device = {\n        k: v for k, v in stored_device.items() if k not in [\"signatures\", \"unsigned\"]\n    }\n    if stripped_signed_device != stripped_stored_device:\n        logger.debug(\n            \"upload signatures: key does not match %s vs %s\",\n            signed_device,\n            stored_device,\n        )\n        raise SynapseError(400, \"Key does not match\")\n\n    try:\n        verify_signed_json(signed_device, user_id, verify_key)\n    except SignatureVerifyException:\n        logger.debug(\"invalid signature on key\")\n        raise SynapseError(400, \"Invalid signature\", Codes.INVALID_SIGNATURE)\n\n\ndef _exception_to_failure(e: Exception) -> JsonDict:\n    if isinstance(e, SynapseError):\n        return {\"status\": e.code, \"errcode\": e.errcode, \"message\": str(e)}\n\n    if isinstance(e, CodeMessageException):\n        return {\"status\": e.code, \"message\": str(e)}\n\n    if isinstance(e, NotRetryingDestination):\n        return {\"status\": 503, \"message\": \"Not ready for retry\"}\n\n    # include ConnectionRefused and other errors\n    #\n    # Note that some Exceptions (notably twisted's ResponseFailed etc) don't\n    # give a string for e.message, which json then fails to serialize.\n    return {\"status\": 503, \"message\": str(e)}\n\n\ndef _one_time_keys_match(old_key_json: str, new_key: JsonDict) -> bool:\n    old_key = json_decoder.decode(old_key_json)\n\n    # if either is a string rather than an object, they must match exactly\n    if not isinstance(old_key, dict) or not isinstance(new_key, dict):\n        return old_key == new_key\n\n    # otherwise, we strip off the 'signatures' if any, because it's legitimate\n    # for different upload attempts to have different signatures.\n    old_key.pop(\"signatures\", None)\n    new_key_copy = dict(new_key)\n    new_key_copy.pop(\"signatures\", None)\n\n    return old_key == new_key_copy\n\n\n@attr.s(slots=True, auto_attribs=True)\nclass SignatureListItem:\n    \"\"\"An item in the signature list as used by upload_signatures_for_device_keys.\"\"\"\n\n    signing_key_id: str\n    target_user_id: str\n    target_device_id: str\n    signature: JsonDict\n\n\nclass SigningKeyEduUpdater:\n    \"\"\"Handles incoming signing key updates from federation and updates the DB\"\"\"\n\n    def __init__(self, hs: \"HomeServer\"):\n        self.store = hs.get_datastores().main\n        self.federation = hs.get_federation_client()\n        self.clock = hs.get_clock()\n\n        device_handler = hs.get_device_handler()\n        assert isinstance(device_handler, DeviceHandler)\n        self._device_handler = device_handler\n\n        self._remote_edu_linearizer = Linearizer(name=\"remote_signing_key\")\n\n        # user_id -> list of updates waiting to be handled.\n        self._pending_updates: Dict[str, List[Tuple[JsonDict, JsonDict]]] = {}\n\n    async def incoming_signing_key_update(\n        self, origin: str, edu_content: JsonDict\n    ) -> None:\n        \"\"\"Called on incoming signing key update from federation. Responsible for\n        parsing the EDU and adding to pending updates list.\n\n        Args:\n            origin: the server that sent the EDU\n            edu_content: the contents of the EDU\n        \"\"\"\n\n        user_id = edu_content.pop(\"user_id\")\n        master_key = edu_content.pop(\"master_key\", None)\n        self_signing_key = edu_content.pop(\"self_signing_key\", None)\n\n        if get_domain_from_id(user_id) != origin:\n            logger.warning(\"Got signing key update edu for %r from %r\", user_id, origin)\n            return\n\n        room_ids = await self.store.get_rooms_for_user(user_id)\n        if not room_ids:\n            # We don't share any rooms with this user. Ignore update, as we\n            # probably won't get any further updates.\n            return\n\n        self._pending_updates.setdefault(user_id, []).append(\n            (master_key, self_signing_key)\n        )\n\n        await self._handle_signing_key_updates(user_id)\n\n    async def _handle_signing_key_updates(self, user_id: str) -> None:\n        \"\"\"Actually handle pending updates.\n\n        Args:\n            user_id: the user whose updates we are processing\n        \"\"\"\n\n        async with self._remote_edu_linearizer.queue(user_id):\n            pending_updates = self._pending_updates.pop(user_id, [])\n            if not pending_updates:\n                # This can happen since we batch updates\n                return\n\n            device_ids: List[str] = []\n\n            logger.info(\"pending updates: %r\", pending_updates)\n\n            for master_key, self_signing_key in pending_updates:\n                new_device_ids = await self._device_handler.device_list_updater.process_cross_signing_key_update(\n                    user_id,\n                    master_key,\n                    self_signing_key,\n                )\n                device_ids = device_ids + new_device_ids\n\n            await self._device_handler.notify_device_update(user_id, device_ids)\n"], "filenames": ["synapse/federation/federation_server.py", "synapse/handlers/device.py", "synapse/handlers/e2e_keys.py"], "buggy_code_start_loc": [87, 330, 544], "buggy_code_end_loc": [1001, 330, 544], "fixing_code_start_loc": [87, 331, 545], "fixing_code_end_loc": [1008, 334, 551], "type": "NVD-CWE-noinfo", "message": "Synapse is an open-source Matrix homeserver Prior to versions 1.95.1 and 1.96.0rc1, cached device information of remote users can be queried from Synapse. This can be used to enumerate the remote users known to a homeserver. System administrators are encouraged to upgrade to Synapse 1.95.1 or 1.96.0rc1 to receive a patch. As a workaround, the `federation_domain_whitelist` can be used to limit federation traffic with a homeserver.\n", "other": {"cve": {"id": "CVE-2023-43796", "sourceIdentifier": "security-advisories@github.com", "published": "2023-10-31T17:15:23.270", "lastModified": "2024-01-07T11:15:13.123", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Synapse is an open-source Matrix homeserver Prior to versions 1.95.1 and 1.96.0rc1, cached device information of remote users can be queried from Synapse. This can be used to enumerate the remote users known to a homeserver. System administrators are encouraged to upgrade to Synapse 1.95.1 or 1.96.0rc1 to receive a patch. As a workaround, the `federation_domain_whitelist` can be used to limit federation traffic with a homeserver.\n"}, {"lang": "es", "value": "Synapse es un servidor dom\u00e9stico Matrix de c\u00f3digo abierto. Antes de las versiones 1.95.1 y 1.96.0rc1, la informaci\u00f3n del dispositivo almacenado en cach\u00e9 de usuarios remotos se puede consultar desde Synapse. Esto se puede utilizar para enumerar los usuarios remotos conocidos por un servidor dom\u00e9stico. Se recomienda a los administradores del sistema que actualicen a Synapse 1.95.1 o 1.96.0rc1 para recibir un parche. Como workaround, se puede utilizar `federation_domain_whitelist` para limitar el tr\u00e1fico de federaci\u00f3n con un servidor dom\u00e9stico."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:matrix:synapse:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.95.1", "matchCriteriaId": "F205A9BF-C734-415C-A9D9-84E721A53C07"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:38:*:*:*:*:*:*:*", "matchCriteriaId": "CC559B26-5DFC-4B7A-A27C-B77DE755DFF9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:39:*:*:*:*:*:*:*", "matchCriteriaId": "B8EDB836-4E6A-4B71-B9B2-AA3E03E0F646"}]}]}], "references": [{"url": "https://github.com/matrix-org/synapse/commit/daec55e1fe120c564240c5386e77941372bf458f", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/matrix-org/synapse/security/advisories/GHSA-mp92-3jfm-3575", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/2IDEEZMFJBDLTFHQUTZRJJNCOZGQ2ZVS/", "source": "security-advisories@github.com", "tags": ["Mailing List"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VH3RNC5ZPQZ4OKPSL4E6BBJSZOQLGDEY/", "source": "security-advisories@github.com", "tags": ["Mailing List"]}, {"url": "https://security.gentoo.org/glsa/202401-12", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/matrix-org/synapse/commit/daec55e1fe120c564240c5386e77941372bf458f"}}