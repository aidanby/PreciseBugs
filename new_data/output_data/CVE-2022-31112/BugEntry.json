{"buggy_code": ["'use strict';\nconst UserController = require('../lib/Controllers/UserController').UserController;\nconst Config = require('../lib/Config');\nconst validatorFail = () => {\n  throw 'you are not authorized';\n};\n\ndescribe('ParseLiveQuery', function () {\n  it('access user on onLiveQueryEvent disconnect', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.CoreManager.getLiveQueryController().setDefaultLiveQueryClient(null);\n    const requestedUser = new Parse.User();\n    requestedUser.setUsername('username');\n    requestedUser.setPassword('password');\n    Parse.Cloud.onLiveQueryEvent(req => {\n      const { event, sessionToken } = req;\n      if (event === 'ws_disconnect') {\n        Parse.Cloud._removeAllHooks();\n        expect(sessionToken).toBeDefined();\n        expect(sessionToken).toBe(requestedUser.getSessionToken());\n        done();\n      }\n    });\n    await requestedUser.signUp();\n    const query = new Parse.Query(TestObject);\n    await query.subscribe();\n    const client = await Parse.CoreManager.getLiveQueryController().getDefaultLiveQueryClient();\n    client.close();\n  });\n\n  it('can subscribe to query', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n\n  it('can use patterns in className', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['Test.*'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n\n  it('expect afterEvent create', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('create');\n      expect(req.user).toBeUndefined();\n      expect(req.object.get('foo')).toBe('bar');\n    });\n\n    const query = new Parse.Query(TestObject);\n    const subscription = await query.subscribe();\n    subscription.on('create', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n  });\n\n  it('expect afterEvent payload', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('update');\n      expect(req.user).toBeUndefined();\n      expect(req.object.get('foo')).toBe('bar');\n      expect(req.original.get('foo')).toBeUndefined();\n      done();\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    await query.subscribe();\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n\n  it('expect afterEvent enter', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('enter');\n      expect(req.user).toBeUndefined();\n      expect(req.object.get('foo')).toBe('bar');\n      expect(req.original.get('foo')).toBeUndefined();\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('foo', 'bar');\n    const subscription = await query.subscribe();\n    subscription.on('enter', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n\n    object.set('foo', 'bar');\n    await object.save();\n  });\n\n  it('expect afterEvent leave', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('leave');\n      expect(req.user).toBeUndefined();\n      expect(req.object.get('foo')).toBeUndefined();\n      expect(req.original.get('foo')).toBe('bar');\n    });\n\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('foo', 'bar');\n    const subscription = await query.subscribe();\n    subscription.on('leave', object => {\n      expect(object.get('foo')).toBeUndefined();\n      done();\n    });\n\n    object.unset('foo');\n    await object.save();\n  });\n\n  it('expect afterEvent delete', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('delete');\n      expect(req.user).toBeUndefined();\n      req.object.set('foo', 'bar');\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n\n    const subscription = await query.subscribe();\n    subscription.on('delete', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n\n    await object.destroy();\n  });\n\n  it('can handle afterEvent modification', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      const current = req.object;\n      current.set('foo', 'yolo');\n\n      const original = req.original;\n      original.set('yolo', 'foo');\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', (object, original) => {\n      expect(object.get('foo')).toBe('yolo');\n      expect(original.get('yolo')).toBe('foo');\n      done();\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n\n  it('can return different object in afterEvent', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      const object = new Parse.Object('Yolo');\n      req.object = object;\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', object => {\n      expect(object.className).toBe('Yolo');\n      done();\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n\n  it('can handle afterEvent throw', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.afterLiveQueryEvent('TestObject', () => {\n      throw 'Throw error from LQ afterEvent.';\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', () => {\n      fail('update should not have been called.');\n    });\n    subscription.on('error', e => {\n      expect(e).toBe('Throw error from LQ afterEvent.');\n      done();\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n\n  it('can log on afterLiveQueryEvent throw', async () => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    const logger = require('../lib/logger').logger;\n    spyOn(logger, 'error').and.callFake(() => {});\n\n    let session = undefined;\n    Parse.Cloud.afterLiveQueryEvent('TestObject', ({ sessionToken }) => {\n      session = sessionToken;\n      /* eslint-disable no-undef */\n      foo.bar();\n      /* eslint-enable no-undef */\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    object.set({ foo: 'bar' });\n    await object.save();\n    await new Promise(resolve => subscription.on('error', resolve));\n    expect(logger.error).toHaveBeenCalledWith(\n      `Failed running afterLiveQueryEvent on class TestObject for event update with session ${session} with:\\n Error: {\"message\":\"foo is not defined\",\"code\":141}`\n    );\n  });\n\n  it('can handle afterEvent sendEvent to false', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      const current = req.object;\n      const original = req.original;\n\n      setTimeout(() => {\n        done();\n      }, 2000);\n\n      if (current.get('foo') != original.get('foo')) {\n        req.sendEvent = false;\n      }\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', () => {\n      fail('update should not have been called.');\n    });\n    subscription.on('error', () => {\n      fail('error should not have been called.');\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n\n  it('can handle afterEvent set pointers', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    const secondObject = new Parse.Object('Test2');\n    secondObject.set('foo', 'bar');\n    await secondObject.save();\n\n    Parse.Cloud.afterLiveQueryEvent('TestObject', async ({ object }) => {\n      const query = new Parse.Query('Test2');\n      const obj = await query.first();\n      object.set('obj', obj);\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', object => {\n      expect(object.get('obj')).toBeDefined();\n      expect(object.get('obj').get('foo')).toBe('bar');\n      done();\n    });\n    subscription.on('error', () => {\n      fail('error should not have been called.');\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n\n  it('can handle async afterEvent modification', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const parent = new TestObject();\n    const child = new TestObject();\n    child.set('bar', 'foo');\n    await Parse.Object.saveAll([parent, child]);\n\n    Parse.Cloud.afterLiveQueryEvent('TestObject', async req => {\n      const current = req.object;\n      const pointer = current.get('child');\n      await pointer.fetch();\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', parent.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', object => {\n      expect(object.get('child')).toBeDefined();\n      expect(object.get('child').get('bar')).toBe('foo');\n      done();\n    });\n    parent.set('child', child);\n    await parent.save();\n  });\n\n  it('can handle beforeConnect / beforeSubscribe hooks', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.beforeSubscribe('TestObject', req => {\n      expect(req.op).toBe('subscribe');\n      expect(req.requestId).toBe(1);\n      expect(req.query).toBeDefined();\n      expect(req.user).toBeUndefined();\n    });\n\n    Parse.Cloud.beforeConnect(req => {\n      expect(req.event).toBe('connect');\n      expect(req.clients).toBe(0);\n      expect(req.subscriptions).toBe(0);\n      expect(req.useMasterKey).toBe(false);\n      expect(req.installationId).toBeDefined();\n      expect(req.user).toBeUndefined();\n      expect(req.client).toBeDefined();\n    });\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n\n  it('can handle beforeConnect validation function', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.beforeConnect(() => {}, validatorFail);\n    let complete = false;\n    Parse.LiveQuery.on('error', error => {\n      Parse.LiveQuery.removeAllListeners('error');\n      if (complete) {\n        return;\n      }\n      complete = true;\n      expect(error).toBe('you are not authorized');\n      done();\n    });\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    await query.subscribe();\n  });\n\n  it('can handle beforeSubscribe validation function', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.beforeSubscribe(TestObject, () => {}, validatorFail);\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('error', error => {\n      expect(error).toBe('you are not authorized');\n      done();\n    });\n  });\n\n  it('can handle afterEvent validation function', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', () => {}, validatorFail);\n\n    const query = new Parse.Query(TestObject);\n    const subscription = await query.subscribe();\n    subscription.on('error', error => {\n      expect(error).toBe('you are not authorized');\n      done();\n    });\n\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n  });\n\n  it('can handle beforeConnect error', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.beforeConnect(() => {\n      throw new Error('You shall not pass!');\n    });\n    Parse.LiveQuery.on('error', error => {\n      Parse.LiveQuery.removeAllListeners('error');\n      expect(error).toBe('You shall not pass!');\n      done();\n    });\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    await query.subscribe();\n  });\n\n  it('can log on beforeConnect throw', async () => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n\n    const logger = require('../lib/logger').logger;\n    spyOn(logger, 'error').and.callFake(() => {});\n    let token = undefined;\n    Parse.Cloud.beforeConnect(({ sessionToken }) => {\n      token = sessionToken;\n      /* eslint-disable no-undef */\n      foo.bar();\n      /* eslint-enable no-undef */\n    });\n    new Parse.Query(TestObject).subscribe();\n    await new Promise(resolve => Parse.LiveQuery.on('error', resolve));\n    Parse.LiveQuery.removeAllListeners('error');\n    expect(logger.error).toHaveBeenCalledWith(\n      `Failed running beforeConnect for session ${token} with:\\n Error: {\"message\":\"foo is not defined\",\"code\":141}`\n    );\n  });\n\n  it('can handle beforeSubscribe error', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.beforeSubscribe(TestObject, () => {\n      throw new Error('You shall not subscribe!');\n    });\n    Parse.LiveQuery.on('error', error => {\n      expect(error).toBe('You shall not subscribe!');\n    });\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('error', error => {\n      Parse.LiveQuery.removeAllListeners('error');\n      expect(error).toBe('You shall not subscribe!');\n      done();\n    });\n  });\n\n  it('can log on beforeSubscribe error', async () => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n\n    const logger = require('../lib/logger').logger;\n    spyOn(logger, 'error').and.callFake(() => {});\n\n    Parse.Cloud.beforeSubscribe(TestObject, () => {\n      /* eslint-disable no-undef */\n      foo.bar();\n      /* eslint-enable no-undef */\n    });\n\n    const query = new Parse.Query(TestObject);\n    const subscription = await query.subscribe();\n    await new Promise(resolve => subscription.on('error', resolve));\n\n    expect(logger.error).toHaveBeenCalledWith(\n      `Failed running beforeSubscribe on TestObject for session undefined with:\\n Error: {\"message\":\"foo is not defined\",\"code\":141}`\n    );\n  });\n\n  it('can handle mutate beforeSubscribe query', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.beforeSubscribe(TestObject, request => {\n      const query = request.query;\n      query.equalTo('yolo', 'abc');\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n\n    subscription.on('update', () => {\n      fail();\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n    setTimeout(async () => {\n      done();\n    }, 1000);\n  });\n\n  it('can return a new beforeSubscribe query', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.beforeSubscribe(TestObject, request => {\n      const query = new Parse.Query(TestObject);\n      query.equalTo('foo', 'yolo');\n      request.query = query;\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('foo', 'bar');\n    const subscription = await query.subscribe();\n\n    subscription.on('create', object => {\n      expect(object.get('foo')).toBe('yolo');\n      done();\n    });\n    const object = new TestObject();\n    object.set({ foo: 'yolo' });\n    await object.save();\n  });\n\n  it('can handle select beforeSubscribe query', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.beforeSubscribe(TestObject, request => {\n      const query = request.query;\n      query.select('yolo');\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n\n    subscription.on('update', object => {\n      expect(object.get('foo')).toBeUndefined();\n      expect(object.get('yolo')).toBe('abc');\n      done();\n    });\n    object.set({ foo: 'bar', yolo: 'abc' });\n    await object.save();\n  });\n\n  it('LiveQuery with ACL', async () => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['Chat'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const user = new Parse.User();\n    user.setUsername('username');\n    user.setPassword('password');\n    await user.signUp();\n\n    const calls = {\n      beforeConnect(req) {\n        expect(req.event).toBe('connect');\n        expect(req.clients).toBe(0);\n        expect(req.subscriptions).toBe(0);\n        expect(req.useMasterKey).toBe(false);\n        expect(req.installationId).toBeDefined();\n        expect(req.client).toBeDefined();\n      },\n      beforeSubscribe(req) {\n        expect(req.op).toBe('subscribe');\n        expect(req.requestId).toBe(1);\n        expect(req.query).toBeDefined();\n        expect(req.user).toBeDefined();\n      },\n      afterLiveQueryEvent(req) {\n        expect(req.user).toBeDefined();\n        expect(req.object.get('foo')).toBe('bar');\n      },\n      create(object) {\n        expect(object.get('foo')).toBe('bar');\n      },\n      delete(object) {\n        expect(object.get('foo')).toBe('bar');\n      },\n    };\n    for (const key in calls) {\n      spyOn(calls, key).and.callThrough();\n    }\n    Parse.Cloud.beforeConnect(calls.beforeConnect);\n    Parse.Cloud.beforeSubscribe('Chat', calls.beforeSubscribe);\n    Parse.Cloud.afterLiveQueryEvent('Chat', calls.afterLiveQueryEvent);\n\n    const chatQuery = new Parse.Query('Chat');\n    const subscription = await chatQuery.subscribe();\n    subscription.on('create', calls.create);\n    subscription.on('delete', calls.delete);\n    const object = new Parse.Object('Chat');\n    const acl = new Parse.ACL(user);\n    object.setACL(acl);\n    object.set({ foo: 'bar' });\n    await object.save();\n    await object.destroy();\n    await new Promise(resolve => setTimeout(resolve, 200));\n    for (const key in calls) {\n      expect(calls[key]).toHaveBeenCalled();\n    }\n  });\n\n  it('liveQuery on Session class', async done => {\n    await reconfigureServer({\n      liveQuery: { classNames: [Parse.Session] },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n\n    const user = new Parse.User();\n    user.setUsername('username');\n    user.setPassword('password');\n    await user.signUp();\n\n    const query = new Parse.Query(Parse.Session);\n    const subscription = await query.subscribe();\n\n    subscription.on('create', async obj => {\n      await new Promise(resolve => setTimeout(resolve, 200));\n      expect(obj.get('user').id).toBe(user.id);\n      expect(obj.get('createdWith')).toEqual({ action: 'login', authProvider: 'password' });\n      expect(obj.get('expiresAt')).toBeInstanceOf(Date);\n      expect(obj.get('installationId')).toBeDefined();\n      expect(obj.get('createdAt')).toBeInstanceOf(Date);\n      expect(obj.get('updatedAt')).toBeInstanceOf(Date);\n      done();\n    });\n\n    await Parse.User.logIn('username', 'password');\n  });\n\n  it('prevent liveQuery on Session class when not logged in', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: [Parse.Session],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n\n    Parse.LiveQuery.on('error', error => {\n      expect(error).toBe('Invalid session token');\n    });\n    const query = new Parse.Query(Parse.Session);\n    const subscription = await query.subscribe();\n    subscription.on('error', error => {\n      Parse.LiveQuery.removeAllListeners('error');\n      expect(error).toBe('Invalid session token');\n      done();\n    });\n  });\n\n  it('handle invalid websocket payload length', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n      websocketTimeout: 100,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n\n    // All control frames must have a payload length of 125 bytes or less.\n    // https://tools.ietf.org/html/rfc6455#section-5.5\n    //\n    // 0x89 = 10001001 = ping\n    // 0xfe = 11111110 = first bit is masking the remaining 7 are 1111110 or 126 the payload length\n    // https://tools.ietf.org/html/rfc6455#section-5.2\n    const client = await Parse.CoreManager.getLiveQueryController().getDefaultLiveQueryClient();\n    client.socket._socket.write(Buffer.from([0x89, 0xfe]));\n\n    subscription.on('update', async object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n    // Wait for Websocket timeout to reconnect\n    setTimeout(async () => {\n      object.set({ foo: 'bar' });\n      await object.save();\n    }, 1000);\n  });\n\n  it('should execute live query update on email validation', async done => {\n    const emailAdapter = {\n      sendVerificationEmail: () => {},\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => {},\n    };\n\n    await reconfigureServer({\n      liveQuery: {\n        classNames: [Parse.User],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n      websocketTimeout: 100,\n      appName: 'liveQueryEmailValidation',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      emailVerifyTokenValidityDuration: 20, // 0.5 second\n      publicServerURL: 'http://localhost:8378/1',\n    }).then(() => {\n      const user = new Parse.User();\n      user.set('password', 'asdf');\n      user.set('email', 'asdf@example.com');\n      user.set('username', 'zxcv');\n      user\n        .signUp()\n        .then(() => {\n          const config = Config.get('test');\n          return config.database.find('_User', {\n            username: 'zxcv',\n          });\n        })\n        .then(async results => {\n          const foundUser = results[0];\n          const query = new Parse.Query('_User');\n          query.equalTo('objectId', foundUser.objectId);\n          const subscription = await query.subscribe();\n\n          subscription.on('update', async object => {\n            expect(object).toBeDefined();\n            expect(object.get('emailVerified')).toBe(true);\n            done();\n          });\n\n          const userController = new UserController(emailAdapter, 'test', {\n            verifyUserEmails: true,\n          });\n          userController.verifyEmail(foundUser.username, foundUser._email_verify_token);\n        });\n    });\n  });\n\n  it('should not broadcast event to client with invalid session token - avisory GHSA-2xm2-xj2q-qgpj', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      liveQueryServerOptions: {\n        cacheTimeout: 100,\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n      cacheTTL: 100,\n    });\n    const user = new Parse.User();\n    user.setUsername('username');\n    user.setPassword('password');\n    await user.signUp();\n    const obj1 = new Parse.Object('TestObject');\n    const obj1ACL = new Parse.ACL();\n    obj1ACL.setPublicReadAccess(false);\n    obj1ACL.setReadAccess(user, true);\n    obj1.setACL(obj1ACL);\n    const obj2 = new Parse.Object('TestObject');\n    const obj2ACL = new Parse.ACL();\n    obj2ACL.setPublicReadAccess(false);\n    obj2ACL.setReadAccess(user, true);\n    obj2.setACL(obj2ACL);\n    const query = new Parse.Query('TestObject');\n    const subscription = await query.subscribe();\n    subscription.on('create', obj => {\n      if (obj.id !== obj1.id) {\n        done.fail('should not fire');\n      }\n    });\n    await obj1.save();\n    await Parse.User.logOut();\n    await new Promise(resolve => setTimeout(resolve, 200));\n    await obj2.save();\n    await new Promise(resolve => setTimeout(resolve, 200));\n    done();\n  });\n\n  it('should strip out session token in LiveQuery', async () => {\n    await reconfigureServer({\n      liveQuery: { classNames: ['_User'] },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n\n    const user = new Parse.User();\n    user.setUsername('username');\n    user.setPassword('password');\n    user.set('foo', 'bar');\n\n    const query = new Parse.Query(Parse.User);\n    query.equalTo('foo', 'bar');\n    const subscription = await query.subscribe();\n\n    const events = ['create', 'update', 'enter', 'leave', 'delete'];\n    const response = (obj, prev) => {\n      expect(obj.get('sessionToken')).toBeUndefined();\n      expect(obj.sessionToken).toBeUndefined();\n      expect(prev && prev.sessionToken).toBeUndefined();\n      if (prev && prev.get) {\n        expect(prev.get('sessionToken')).toBeUndefined();\n      }\n    };\n    const calls = {};\n    for (const key of events) {\n      calls[key] = response;\n      spyOn(calls, key).and.callThrough();\n      subscription.on(key, calls[key]);\n    }\n    await user.signUp();\n    user.unset('foo');\n    await user.save();\n    user.set('foo', 'bar');\n    await user.save();\n    user.set('yolo', 'bar');\n    await user.save();\n    await user.destroy();\n    await new Promise(resolve => setTimeout(resolve, 10));\n    for (const key of events) {\n      expect(calls[key]).toHaveBeenCalled();\n    }\n  });\n\n  afterEach(async function (done) {\n    const client = await Parse.CoreManager.getLiveQueryController().getDefaultLiveQueryClient();\n    client.close();\n    // Wait for live query client to disconnect\n    setTimeout(() => {\n      done();\n    }, 1000);\n  });\n});\n", "\ufeff// @flow\n// A database adapter that works with data exported from the hosted\n// Parse database.\n\n// @flow-disable-next\nimport { Parse } from 'parse/node';\n// @flow-disable-next\nimport _ from 'lodash';\n// @flow-disable-next\nimport intersect from 'intersect';\n// @flow-disable-next\nimport deepcopy from 'deepcopy';\nimport logger from '../logger';\nimport Utils from '../Utils';\nimport * as SchemaController from './SchemaController';\nimport { StorageAdapter } from '../Adapters/Storage/StorageAdapter';\nimport MongoStorageAdapter from '../Adapters/Storage/Mongo/MongoStorageAdapter';\nimport PostgresStorageAdapter from '../Adapters/Storage/Postgres/PostgresStorageAdapter';\nimport SchemaCache from '../Adapters/Cache/SchemaCache';\nimport type { LoadSchemaOptions } from './types';\nimport type { ParseServerOptions } from '../Options';\nimport type { QueryOptions, FullQueryOptions } from '../Adapters/Storage/StorageAdapter';\n\nfunction addWriteACL(query, acl) {\n  const newQuery = _.cloneDeep(query);\n  //Can't be any existing '_wperm' query, we don't allow client queries on that, no need to $and\n  newQuery._wperm = { $in: [null, ...acl] };\n  return newQuery;\n}\n\nfunction addReadACL(query, acl) {\n  const newQuery = _.cloneDeep(query);\n  //Can't be any existing '_rperm' query, we don't allow client queries on that, no need to $and\n  newQuery._rperm = { $in: [null, '*', ...acl] };\n  return newQuery;\n}\n\n// Transforms a REST API formatted ACL object to our two-field mongo format.\nconst transformObjectACL = ({ ACL, ...result }) => {\n  if (!ACL) {\n    return result;\n  }\n\n  result._wperm = [];\n  result._rperm = [];\n\n  for (const entry in ACL) {\n    if (ACL[entry].read) {\n      result._rperm.push(entry);\n    }\n    if (ACL[entry].write) {\n      result._wperm.push(entry);\n    }\n  }\n  return result;\n};\n\nconst specialQuerykeys = [\n  '$and',\n  '$or',\n  '$nor',\n  '_rperm',\n  '_wperm',\n  '_perishable_token',\n  '_email_verify_token',\n  '_email_verify_token_expires_at',\n  '_account_lockout_expires_at',\n  '_failed_login_count',\n];\n\nconst isSpecialQueryKey = key => {\n  return specialQuerykeys.indexOf(key) >= 0;\n};\n\nconst validateQuery = (query: any): void => {\n  if (query.ACL) {\n    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Cannot query on ACL.');\n  }\n\n  if (query.$or) {\n    if (query.$or instanceof Array) {\n      query.$or.forEach(validateQuery);\n    } else {\n      throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Bad $or format - use an array value.');\n    }\n  }\n\n  if (query.$and) {\n    if (query.$and instanceof Array) {\n      query.$and.forEach(validateQuery);\n    } else {\n      throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Bad $and format - use an array value.');\n    }\n  }\n\n  if (query.$nor) {\n    if (query.$nor instanceof Array && query.$nor.length > 0) {\n      query.$nor.forEach(validateQuery);\n    } else {\n      throw new Parse.Error(\n        Parse.Error.INVALID_QUERY,\n        'Bad $nor format - use an array of at least 1 value.'\n      );\n    }\n  }\n\n  Object.keys(query).forEach(key => {\n    if (query && query[key] && query[key].$regex) {\n      if (typeof query[key].$options === 'string') {\n        if (!query[key].$options.match(/^[imxs]+$/)) {\n          throw new Parse.Error(\n            Parse.Error.INVALID_QUERY,\n            `Bad $options value for query: ${query[key].$options}`\n          );\n        }\n      }\n    }\n    if (!isSpecialQueryKey(key) && !key.match(/^[a-zA-Z][a-zA-Z0-9_\\.]*$/)) {\n      throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, `Invalid key name: ${key}`);\n    }\n  });\n};\n\n// Filters out any data that shouldn't be on this REST-formatted object.\nconst filterSensitiveData = (\n  isMaster: boolean,\n  aclGroup: any[],\n  auth: any,\n  operation: any,\n  schema: SchemaController.SchemaController,\n  className: string,\n  protectedFields: null | Array<any>,\n  object: any\n) => {\n  let userId = null;\n  if (auth && auth.user) userId = auth.user.id;\n\n  // replace protectedFields when using pointer-permissions\n  const perms = schema.getClassLevelPermissions(className);\n  if (perms) {\n    const isReadOperation = ['get', 'find'].indexOf(operation) > -1;\n\n    if (isReadOperation && perms.protectedFields) {\n      // extract protectedFields added with the pointer-permission prefix\n      const protectedFieldsPointerPerm = Object.keys(perms.protectedFields)\n        .filter(key => key.startsWith('userField:'))\n        .map(key => {\n          return { key: key.substring(10), value: perms.protectedFields[key] };\n        });\n\n      const newProtectedFields: Array<string>[] = [];\n      let overrideProtectedFields = false;\n\n      // check if the object grants the current user access based on the extracted fields\n      protectedFieldsPointerPerm.forEach(pointerPerm => {\n        let pointerPermIncludesUser = false;\n        const readUserFieldValue = object[pointerPerm.key];\n        if (readUserFieldValue) {\n          if (Array.isArray(readUserFieldValue)) {\n            pointerPermIncludesUser = readUserFieldValue.some(\n              user => user.objectId && user.objectId === userId\n            );\n          } else {\n            pointerPermIncludesUser =\n              readUserFieldValue.objectId && readUserFieldValue.objectId === userId;\n          }\n        }\n\n        if (pointerPermIncludesUser) {\n          overrideProtectedFields = true;\n          newProtectedFields.push(pointerPerm.value);\n        }\n      });\n\n      // if at least one pointer-permission affected the current user\n      // intersect vs protectedFields from previous stage (@see addProtectedFields)\n      // Sets theory (intersections): A x (B x C) == (A x B) x C\n      if (overrideProtectedFields && protectedFields) {\n        newProtectedFields.push(protectedFields);\n      }\n      // intersect all sets of protectedFields\n      newProtectedFields.forEach(fields => {\n        if (fields) {\n          // if there're no protctedFields by other criteria ( id / role / auth)\n          // then we must intersect each set (per userField)\n          if (!protectedFields) {\n            protectedFields = fields;\n          } else {\n            protectedFields = protectedFields.filter(v => fields.includes(v));\n          }\n        }\n      });\n    }\n  }\n\n  const isUserClass = className === '_User';\n\n  /* special treat for the user class: don't filter protectedFields if currently loggedin user is\n  the retrieved user */\n  if (!(isUserClass && userId && object.objectId === userId)) {\n    protectedFields && protectedFields.forEach(k => delete object[k]);\n\n    // fields not requested by client (excluded),\n    //but were needed to apply protecttedFields\n    perms.protectedFields &&\n      perms.protectedFields.temporaryKeys &&\n      perms.protectedFields.temporaryKeys.forEach(k => delete object[k]);\n  }\n\n  if (!isUserClass) {\n    return object;\n  }\n\n  object.password = object._hashed_password;\n  delete object._hashed_password;\n\n  delete object.sessionToken;\n\n  if (isMaster) {\n    return object;\n  }\n  delete object._email_verify_token;\n  delete object._perishable_token;\n  delete object._perishable_token_expires_at;\n  delete object._tombstone;\n  delete object._email_verify_token_expires_at;\n  delete object._failed_login_count;\n  delete object._account_lockout_expires_at;\n  delete object._password_changed_at;\n  delete object._password_history;\n\n  if (aclGroup.indexOf(object.objectId) > -1) {\n    return object;\n  }\n  delete object.authData;\n  return object;\n};\n\n// Runs an update on the database.\n// Returns a promise for an object with the new values for field\n// modifications that don't know their results ahead of time, like\n// 'increment'.\n// Options:\n//   acl:  a list of strings. If the object to be updated has an ACL,\n//         one of the provided strings must provide the caller with\n//         write permissions.\nconst specialKeysForUpdate = [\n  '_hashed_password',\n  '_perishable_token',\n  '_email_verify_token',\n  '_email_verify_token_expires_at',\n  '_account_lockout_expires_at',\n  '_failed_login_count',\n  '_perishable_token_expires_at',\n  '_password_changed_at',\n  '_password_history',\n];\n\nconst isSpecialUpdateKey = key => {\n  return specialKeysForUpdate.indexOf(key) >= 0;\n};\n\nfunction joinTableName(className, key) {\n  return `_Join:${key}:${className}`;\n}\n\nconst flattenUpdateOperatorsForCreate = object => {\n  for (const key in object) {\n    if (object[key] && object[key].__op) {\n      switch (object[key].__op) {\n        case 'Increment':\n          if (typeof object[key].amount !== 'number') {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = object[key].amount;\n          break;\n        case 'Add':\n          if (!(object[key].objects instanceof Array)) {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = object[key].objects;\n          break;\n        case 'AddUnique':\n          if (!(object[key].objects instanceof Array)) {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = object[key].objects;\n          break;\n        case 'Remove':\n          if (!(object[key].objects instanceof Array)) {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = [];\n          break;\n        case 'Delete':\n          delete object[key];\n          break;\n        default:\n          throw new Parse.Error(\n            Parse.Error.COMMAND_UNAVAILABLE,\n            `The ${object[key].__op} operator is not supported yet.`\n          );\n      }\n    }\n  }\n};\n\nconst transformAuthData = (className, object, schema) => {\n  if (object.authData && className === '_User') {\n    Object.keys(object.authData).forEach(provider => {\n      const providerData = object.authData[provider];\n      const fieldName = `_auth_data_${provider}`;\n      if (providerData == null) {\n        object[fieldName] = {\n          __op: 'Delete',\n        };\n      } else {\n        object[fieldName] = providerData;\n        schema.fields[fieldName] = { type: 'Object' };\n      }\n    });\n    delete object.authData;\n  }\n};\n// Transforms a Database format ACL to a REST API format ACL\nconst untransformObjectACL = ({ _rperm, _wperm, ...output }) => {\n  if (_rperm || _wperm) {\n    output.ACL = {};\n\n    (_rperm || []).forEach(entry => {\n      if (!output.ACL[entry]) {\n        output.ACL[entry] = { read: true };\n      } else {\n        output.ACL[entry]['read'] = true;\n      }\n    });\n\n    (_wperm || []).forEach(entry => {\n      if (!output.ACL[entry]) {\n        output.ACL[entry] = { write: true };\n      } else {\n        output.ACL[entry]['write'] = true;\n      }\n    });\n  }\n  return output;\n};\n\n/**\n * When querying, the fieldName may be compound, extract the root fieldName\n *     `temperature.celsius` becomes `temperature`\n * @param {string} fieldName that may be a compound field name\n * @returns {string} the root name of the field\n */\nconst getRootFieldName = (fieldName: string): string => {\n  return fieldName.split('.')[0];\n};\n\nconst relationSchema = {\n  fields: { relatedId: { type: 'String' }, owningId: { type: 'String' } },\n};\n\nclass DatabaseController {\n  adapter: StorageAdapter;\n  schemaCache: any;\n  schemaPromise: ?Promise<SchemaController.SchemaController>;\n  _transactionalSession: ?any;\n  options: ParseServerOptions;\n  idempotencyOptions: any;\n\n  constructor(adapter: StorageAdapter, options: ParseServerOptions) {\n    this.adapter = adapter;\n    this.options = options || {};\n    this.idempotencyOptions = this.options.idempotencyOptions || {};\n    // Prevent mutable this.schema, otherwise one request could use\n    // multiple schemas, so instead use loadSchema to get a schema.\n    this.schemaPromise = null;\n    this._transactionalSession = null;\n    this.options = options;\n  }\n\n  collectionExists(className: string): Promise<boolean> {\n    return this.adapter.classExists(className);\n  }\n\n  purgeCollection(className: string): Promise<void> {\n    return this.loadSchema()\n      .then(schemaController => schemaController.getOneSchema(className))\n      .then(schema => this.adapter.deleteObjectsByQuery(className, schema, {}));\n  }\n\n  validateClassName(className: string): Promise<void> {\n    if (!SchemaController.classNameIsValid(className)) {\n      return Promise.reject(\n        new Parse.Error(Parse.Error.INVALID_CLASS_NAME, 'invalid className: ' + className)\n      );\n    }\n    return Promise.resolve();\n  }\n\n  // Returns a promise for a schemaController.\n  loadSchema(\n    options: LoadSchemaOptions = { clearCache: false }\n  ): Promise<SchemaController.SchemaController> {\n    if (this.schemaPromise != null) {\n      return this.schemaPromise;\n    }\n    this.schemaPromise = SchemaController.load(this.adapter, options);\n    this.schemaPromise.then(\n      () => delete this.schemaPromise,\n      () => delete this.schemaPromise\n    );\n    return this.loadSchema(options);\n  }\n\n  loadSchemaIfNeeded(\n    schemaController: SchemaController.SchemaController,\n    options: LoadSchemaOptions = { clearCache: false }\n  ): Promise<SchemaController.SchemaController> {\n    return schemaController ? Promise.resolve(schemaController) : this.loadSchema(options);\n  }\n\n  // Returns a promise for the classname that is related to the given\n  // classname through the key.\n  // TODO: make this not in the DatabaseController interface\n  redirectClassNameForKey(className: string, key: string): Promise<?string> {\n    return this.loadSchema().then(schema => {\n      var t = schema.getExpectedType(className, key);\n      if (t != null && typeof t !== 'string' && t.type === 'Relation') {\n        return t.targetClass;\n      }\n      return className;\n    });\n  }\n\n  // Uses the schema to validate the object (REST API format).\n  // Returns a promise that resolves to the new schema.\n  // This does not update this.schema, because in a situation like a\n  // batch request, that could confuse other users of the schema.\n  validateObject(\n    className: string,\n    object: any,\n    query: any,\n    runOptions: QueryOptions\n  ): Promise<boolean> {\n    let schema;\n    const acl = runOptions.acl;\n    const isMaster = acl === undefined;\n    var aclGroup: string[] = acl || [];\n    return this.loadSchema()\n      .then(s => {\n        schema = s;\n        if (isMaster) {\n          return Promise.resolve();\n        }\n        return this.canAddField(schema, className, object, aclGroup, runOptions);\n      })\n      .then(() => {\n        return schema.validateObject(className, object, query);\n      });\n  }\n\n  update(\n    className: string,\n    query: any,\n    update: any,\n    { acl, many, upsert, addsField }: FullQueryOptions = {},\n    skipSanitization: boolean = false,\n    validateOnly: boolean = false,\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    const originalQuery = query;\n    const originalUpdate = update;\n    // Make a copy of the object, so we don't mutate the incoming data.\n    update = deepcopy(update);\n    var relationUpdates = [];\n    var isMaster = acl === undefined;\n    var aclGroup = acl || [];\n\n    return this.loadSchemaIfNeeded(validSchemaController).then(schemaController => {\n      return (isMaster\n        ? Promise.resolve()\n        : schemaController.validatePermission(className, aclGroup, 'update')\n      )\n        .then(() => {\n          relationUpdates = this.collectRelationUpdates(className, originalQuery.objectId, update);\n          if (!isMaster) {\n            query = this.addPointerPermissions(\n              schemaController,\n              className,\n              'update',\n              query,\n              aclGroup\n            );\n\n            if (addsField) {\n              query = {\n                $and: [\n                  query,\n                  this.addPointerPermissions(\n                    schemaController,\n                    className,\n                    'addField',\n                    query,\n                    aclGroup\n                  ),\n                ],\n              };\n            }\n          }\n          if (!query) {\n            return Promise.resolve();\n          }\n          if (acl) {\n            query = addWriteACL(query, acl);\n          }\n          validateQuery(query);\n          return schemaController\n            .getOneSchema(className, true)\n            .catch(error => {\n              // If the schema doesn't exist, pretend it exists with no fields. This behavior\n              // will likely need revisiting.\n              if (error === undefined) {\n                return { fields: {} };\n              }\n              throw error;\n            })\n            .then(schema => {\n              Object.keys(update).forEach(fieldName => {\n                if (fieldName.match(/^authData\\.([a-zA-Z0-9_]+)\\.id$/)) {\n                  throw new Parse.Error(\n                    Parse.Error.INVALID_KEY_NAME,\n                    `Invalid field name for update: ${fieldName}`\n                  );\n                }\n                const rootFieldName = getRootFieldName(fieldName);\n                if (\n                  !SchemaController.fieldNameIsValid(rootFieldName, className) &&\n                  !isSpecialUpdateKey(rootFieldName)\n                ) {\n                  throw new Parse.Error(\n                    Parse.Error.INVALID_KEY_NAME,\n                    `Invalid field name for update: ${fieldName}`\n                  );\n                }\n              });\n              for (const updateOperation in update) {\n                if (\n                  update[updateOperation] &&\n                  typeof update[updateOperation] === 'object' &&\n                  Object.keys(update[updateOperation]).some(\n                    innerKey => innerKey.includes('$') || innerKey.includes('.')\n                  )\n                ) {\n                  throw new Parse.Error(\n                    Parse.Error.INVALID_NESTED_KEY,\n                    \"Nested keys should not contain the '$' or '.' characters\"\n                  );\n                }\n              }\n              update = transformObjectACL(update);\n              transformAuthData(className, update, schema);\n              if (validateOnly) {\n                return this.adapter.find(className, schema, query, {}).then(result => {\n                  if (!result || !result.length) {\n                    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n                  }\n                  return {};\n                });\n              }\n              if (many) {\n                return this.adapter.updateObjectsByQuery(\n                  className,\n                  schema,\n                  query,\n                  update,\n                  this._transactionalSession\n                );\n              } else if (upsert) {\n                return this.adapter.upsertOneObject(\n                  className,\n                  schema,\n                  query,\n                  update,\n                  this._transactionalSession\n                );\n              } else {\n                return this.adapter.findOneAndUpdate(\n                  className,\n                  schema,\n                  query,\n                  update,\n                  this._transactionalSession\n                );\n              }\n            });\n        })\n        .then((result: any) => {\n          if (!result) {\n            throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n          }\n          if (validateOnly) {\n            return result;\n          }\n          return this.handleRelationUpdates(\n            className,\n            originalQuery.objectId,\n            update,\n            relationUpdates\n          ).then(() => {\n            return result;\n          });\n        })\n        .then(result => {\n          if (skipSanitization) {\n            return Promise.resolve(result);\n          }\n          return this._sanitizeDatabaseResult(originalUpdate, result);\n        });\n    });\n  }\n\n  // Collect all relation-updating operations from a REST-format update.\n  // Returns a list of all relation updates to perform\n  // This mutates update.\n  collectRelationUpdates(className: string, objectId: ?string, update: any) {\n    var ops = [];\n    var deleteMe = [];\n    objectId = update.objectId || objectId;\n\n    var process = (op, key) => {\n      if (!op) {\n        return;\n      }\n      if (op.__op == 'AddRelation') {\n        ops.push({ key, op });\n        deleteMe.push(key);\n      }\n\n      if (op.__op == 'RemoveRelation') {\n        ops.push({ key, op });\n        deleteMe.push(key);\n      }\n\n      if (op.__op == 'Batch') {\n        for (var x of op.ops) {\n          process(x, key);\n        }\n      }\n    };\n\n    for (const key in update) {\n      process(update[key], key);\n    }\n    for (const key of deleteMe) {\n      delete update[key];\n    }\n    return ops;\n  }\n\n  // Processes relation-updating operations from a REST-format update.\n  // Returns a promise that resolves when all updates have been performed\n  handleRelationUpdates(className: string, objectId: string, update: any, ops: any) {\n    var pending = [];\n    objectId = update.objectId || objectId;\n    ops.forEach(({ key, op }) => {\n      if (!op) {\n        return;\n      }\n      if (op.__op == 'AddRelation') {\n        for (const object of op.objects) {\n          pending.push(this.addRelation(key, className, objectId, object.objectId));\n        }\n      }\n\n      if (op.__op == 'RemoveRelation') {\n        for (const object of op.objects) {\n          pending.push(this.removeRelation(key, className, objectId, object.objectId));\n        }\n      }\n    });\n\n    return Promise.all(pending);\n  }\n\n  // Adds a relation.\n  // Returns a promise that resolves successfully iff the add was successful.\n  addRelation(key: string, fromClassName: string, fromId: string, toId: string) {\n    const doc = {\n      relatedId: toId,\n      owningId: fromId,\n    };\n    return this.adapter.upsertOneObject(\n      `_Join:${key}:${fromClassName}`,\n      relationSchema,\n      doc,\n      doc,\n      this._transactionalSession\n    );\n  }\n\n  // Removes a relation.\n  // Returns a promise that resolves successfully iff the remove was\n  // successful.\n  removeRelation(key: string, fromClassName: string, fromId: string, toId: string) {\n    var doc = {\n      relatedId: toId,\n      owningId: fromId,\n    };\n    return this.adapter\n      .deleteObjectsByQuery(\n        `_Join:${key}:${fromClassName}`,\n        relationSchema,\n        doc,\n        this._transactionalSession\n      )\n      .catch(error => {\n        // We don't care if they try to delete a non-existent relation.\n        if (error.code == Parse.Error.OBJECT_NOT_FOUND) {\n          return;\n        }\n        throw error;\n      });\n  }\n\n  // Removes objects matches this query from the database.\n  // Returns a promise that resolves successfully iff the object was\n  // deleted.\n  // Options:\n  //   acl:  a list of strings. If the object to be updated has an ACL,\n  //         one of the provided strings must provide the caller with\n  //         write permissions.\n  destroy(\n    className: string,\n    query: any,\n    { acl }: QueryOptions = {},\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    const isMaster = acl === undefined;\n    const aclGroup = acl || [];\n\n    return this.loadSchemaIfNeeded(validSchemaController).then(schemaController => {\n      return (isMaster\n        ? Promise.resolve()\n        : schemaController.validatePermission(className, aclGroup, 'delete')\n      ).then(() => {\n        if (!isMaster) {\n          query = this.addPointerPermissions(\n            schemaController,\n            className,\n            'delete',\n            query,\n            aclGroup\n          );\n          if (!query) {\n            throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n          }\n        }\n        // delete by query\n        if (acl) {\n          query = addWriteACL(query, acl);\n        }\n        validateQuery(query);\n        return schemaController\n          .getOneSchema(className)\n          .catch(error => {\n            // If the schema doesn't exist, pretend it exists with no fields. This behavior\n            // will likely need revisiting.\n            if (error === undefined) {\n              return { fields: {} };\n            }\n            throw error;\n          })\n          .then(parseFormatSchema =>\n            this.adapter.deleteObjectsByQuery(\n              className,\n              parseFormatSchema,\n              query,\n              this._transactionalSession\n            )\n          )\n          .catch(error => {\n            // When deleting sessions while changing passwords, don't throw an error if they don't have any sessions.\n            if (className === '_Session' && error.code === Parse.Error.OBJECT_NOT_FOUND) {\n              return Promise.resolve({});\n            }\n            throw error;\n          });\n      });\n    });\n  }\n\n  // Inserts an object into the database.\n  // Returns a promise that resolves successfully iff the object saved.\n  create(\n    className: string,\n    object: any,\n    { acl }: QueryOptions = {},\n    validateOnly: boolean = false,\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    // Make a copy of the object, so we don't mutate the incoming data.\n    const originalObject = object;\n    object = transformObjectACL(object);\n\n    object.createdAt = { iso: object.createdAt, __type: 'Date' };\n    object.updatedAt = { iso: object.updatedAt, __type: 'Date' };\n\n    var isMaster = acl === undefined;\n    var aclGroup = acl || [];\n    const relationUpdates = this.collectRelationUpdates(className, null, object);\n\n    return this.validateClassName(className)\n      .then(() => this.loadSchemaIfNeeded(validSchemaController))\n      .then(schemaController => {\n        return (isMaster\n          ? Promise.resolve()\n          : schemaController.validatePermission(className, aclGroup, 'create')\n        )\n          .then(() => schemaController.enforceClassExists(className))\n          .then(() => schemaController.getOneSchema(className, true))\n          .then(schema => {\n            transformAuthData(className, object, schema);\n            flattenUpdateOperatorsForCreate(object);\n            if (validateOnly) {\n              return {};\n            }\n            return this.adapter.createObject(\n              className,\n              SchemaController.convertSchemaToAdapterSchema(schema),\n              object,\n              this._transactionalSession\n            );\n          })\n          .then(result => {\n            if (validateOnly) {\n              return originalObject;\n            }\n            return this.handleRelationUpdates(\n              className,\n              object.objectId,\n              object,\n              relationUpdates\n            ).then(() => {\n              return this._sanitizeDatabaseResult(originalObject, result.ops[0]);\n            });\n          });\n      });\n  }\n\n  canAddField(\n    schema: SchemaController.SchemaController,\n    className: string,\n    object: any,\n    aclGroup: string[],\n    runOptions: QueryOptions\n  ): Promise<void> {\n    const classSchema = schema.schemaData[className];\n    if (!classSchema) {\n      return Promise.resolve();\n    }\n    const fields = Object.keys(object);\n    const schemaFields = Object.keys(classSchema.fields);\n    const newKeys = fields.filter(field => {\n      // Skip fields that are unset\n      if (object[field] && object[field].__op && object[field].__op === 'Delete') {\n        return false;\n      }\n      return schemaFields.indexOf(getRootFieldName(field)) < 0;\n    });\n    if (newKeys.length > 0) {\n      // adds a marker that new field is being adding during update\n      runOptions.addsField = true;\n\n      const action = runOptions.action;\n      return schema.validatePermission(className, aclGroup, 'addField', action);\n    }\n    return Promise.resolve();\n  }\n\n  // Won't delete collections in the system namespace\n  /**\n   * Delete all classes and clears the schema cache\n   *\n   * @param {boolean} fast set to true if it's ok to just delete rows and not indexes\n   * @returns {Promise<void>} when the deletions completes\n   */\n  deleteEverything(fast: boolean = false): Promise<any> {\n    this.schemaPromise = null;\n    SchemaCache.clear();\n    return this.adapter.deleteAllClasses(fast);\n  }\n\n  // Returns a promise for a list of related ids given an owning id.\n  // className here is the owning className.\n  relatedIds(\n    className: string,\n    key: string,\n    owningId: string,\n    queryOptions: QueryOptions\n  ): Promise<Array<string>> {\n    const { skip, limit, sort } = queryOptions;\n    const findOptions = {};\n    if (sort && sort.createdAt && this.adapter.canSortOnJoinTables) {\n      findOptions.sort = { _id: sort.createdAt };\n      findOptions.limit = limit;\n      findOptions.skip = skip;\n      queryOptions.skip = 0;\n    }\n    return this.adapter\n      .find(joinTableName(className, key), relationSchema, { owningId }, findOptions)\n      .then(results => results.map(result => result.relatedId));\n  }\n\n  // Returns a promise for a list of owning ids given some related ids.\n  // className here is the owning className.\n  owningIds(className: string, key: string, relatedIds: string[]): Promise<string[]> {\n    return this.adapter\n      .find(\n        joinTableName(className, key),\n        relationSchema,\n        { relatedId: { $in: relatedIds } },\n        { keys: ['owningId'] }\n      )\n      .then(results => results.map(result => result.owningId));\n  }\n\n  // Modifies query so that it no longer has $in on relation fields, or\n  // equal-to-pointer constraints on relation fields.\n  // Returns a promise that resolves when query is mutated\n  reduceInRelation(className: string, query: any, schema: any): Promise<any> {\n    // Search for an in-relation or equal-to-relation\n    // Make it sequential for now, not sure of paralleization side effects\n    if (query['$or']) {\n      const ors = query['$or'];\n      return Promise.all(\n        ors.map((aQuery, index) => {\n          return this.reduceInRelation(className, aQuery, schema).then(aQuery => {\n            query['$or'][index] = aQuery;\n          });\n        })\n      ).then(() => {\n        return Promise.resolve(query);\n      });\n    }\n    if (query['$and']) {\n      const ands = query['$and'];\n      return Promise.all(\n        ands.map((aQuery, index) => {\n          return this.reduceInRelation(className, aQuery, schema).then(aQuery => {\n            query['$and'][index] = aQuery;\n          });\n        })\n      ).then(() => {\n        return Promise.resolve(query);\n      });\n    }\n\n    const promises = Object.keys(query).map(key => {\n      const t = schema.getExpectedType(className, key);\n      if (!t || t.type !== 'Relation') {\n        return Promise.resolve(query);\n      }\n      let queries: ?(any[]) = null;\n      if (\n        query[key] &&\n        (query[key]['$in'] ||\n          query[key]['$ne'] ||\n          query[key]['$nin'] ||\n          query[key].__type == 'Pointer')\n      ) {\n        // Build the list of queries\n        queries = Object.keys(query[key]).map(constraintKey => {\n          let relatedIds;\n          let isNegation = false;\n          if (constraintKey === 'objectId') {\n            relatedIds = [query[key].objectId];\n          } else if (constraintKey == '$in') {\n            relatedIds = query[key]['$in'].map(r => r.objectId);\n          } else if (constraintKey == '$nin') {\n            isNegation = true;\n            relatedIds = query[key]['$nin'].map(r => r.objectId);\n          } else if (constraintKey == '$ne') {\n            isNegation = true;\n            relatedIds = [query[key]['$ne'].objectId];\n          } else {\n            return;\n          }\n          return {\n            isNegation,\n            relatedIds,\n          };\n        });\n      } else {\n        queries = [{ isNegation: false, relatedIds: [] }];\n      }\n\n      // remove the current queryKey as we don,t need it anymore\n      delete query[key];\n      // execute each query independently to build the list of\n      // $in / $nin\n      const promises = queries.map(q => {\n        if (!q) {\n          return Promise.resolve();\n        }\n        return this.owningIds(className, key, q.relatedIds).then(ids => {\n          if (q.isNegation) {\n            this.addNotInObjectIdsIds(ids, query);\n          } else {\n            this.addInObjectIdsIds(ids, query);\n          }\n          return Promise.resolve();\n        });\n      });\n\n      return Promise.all(promises).then(() => {\n        return Promise.resolve();\n      });\n    });\n\n    return Promise.all(promises).then(() => {\n      return Promise.resolve(query);\n    });\n  }\n\n  // Modifies query so that it no longer has $relatedTo\n  // Returns a promise that resolves when query is mutated\n  reduceRelationKeys(className: string, query: any, queryOptions: any): ?Promise<void> {\n    if (query['$or']) {\n      return Promise.all(\n        query['$or'].map(aQuery => {\n          return this.reduceRelationKeys(className, aQuery, queryOptions);\n        })\n      );\n    }\n    if (query['$and']) {\n      return Promise.all(\n        query['$and'].map(aQuery => {\n          return this.reduceRelationKeys(className, aQuery, queryOptions);\n        })\n      );\n    }\n    var relatedTo = query['$relatedTo'];\n    if (relatedTo) {\n      return this.relatedIds(\n        relatedTo.object.className,\n        relatedTo.key,\n        relatedTo.object.objectId,\n        queryOptions\n      )\n        .then(ids => {\n          delete query['$relatedTo'];\n          this.addInObjectIdsIds(ids, query);\n          return this.reduceRelationKeys(className, query, queryOptions);\n        })\n        .then(() => {});\n    }\n  }\n\n  addInObjectIdsIds(ids: ?Array<string> = null, query: any) {\n    const idsFromString: ?Array<string> =\n      typeof query.objectId === 'string' ? [query.objectId] : null;\n    const idsFromEq: ?Array<string> =\n      query.objectId && query.objectId['$eq'] ? [query.objectId['$eq']] : null;\n    const idsFromIn: ?Array<string> =\n      query.objectId && query.objectId['$in'] ? query.objectId['$in'] : null;\n\n    // @flow-disable-next\n    const allIds: Array<Array<string>> = [idsFromString, idsFromEq, idsFromIn, ids].filter(\n      list => list !== null\n    );\n    const totalLength = allIds.reduce((memo, list) => memo + list.length, 0);\n\n    let idsIntersection = [];\n    if (totalLength > 125) {\n      idsIntersection = intersect.big(allIds);\n    } else {\n      idsIntersection = intersect(allIds);\n    }\n\n    // Need to make sure we don't clobber existing shorthand $eq constraints on objectId.\n    if (!('objectId' in query)) {\n      query.objectId = {\n        $in: undefined,\n      };\n    } else if (typeof query.objectId === 'string') {\n      query.objectId = {\n        $in: undefined,\n        $eq: query.objectId,\n      };\n    }\n    query.objectId['$in'] = idsIntersection;\n\n    return query;\n  }\n\n  addNotInObjectIdsIds(ids: string[] = [], query: any) {\n    const idsFromNin = query.objectId && query.objectId['$nin'] ? query.objectId['$nin'] : [];\n    let allIds = [...idsFromNin, ...ids].filter(list => list !== null);\n\n    // make a set and spread to remove duplicates\n    allIds = [...new Set(allIds)];\n\n    // Need to make sure we don't clobber existing shorthand $eq constraints on objectId.\n    if (!('objectId' in query)) {\n      query.objectId = {\n        $nin: undefined,\n      };\n    } else if (typeof query.objectId === 'string') {\n      query.objectId = {\n        $nin: undefined,\n        $eq: query.objectId,\n      };\n    }\n\n    query.objectId['$nin'] = allIds;\n    return query;\n  }\n\n  // Runs a query on the database.\n  // Returns a promise that resolves to a list of items.\n  // Options:\n  //   skip    number of results to skip.\n  //   limit   limit to this number of results.\n  //   sort    an object where keys are the fields to sort by.\n  //           the value is +1 for ascending, -1 for descending.\n  //   count   run a count instead of returning results.\n  //   acl     restrict this operation with an ACL for the provided array\n  //           of user objectIds and roles. acl: null means no user.\n  //           when this field is not present, don't do anything regarding ACLs.\n  //  caseInsensitive make string comparisons case insensitive\n  // TODO: make userIds not needed here. The db adapter shouldn't know\n  // anything about users, ideally. Then, improve the format of the ACL\n  // arg to work like the others.\n  find(\n    className: string,\n    query: any,\n    {\n      skip,\n      limit,\n      acl,\n      sort = {},\n      count,\n      keys,\n      op,\n      distinct,\n      pipeline,\n      readPreference,\n      hint,\n      caseInsensitive = false,\n      explain,\n    }: any = {},\n    auth: any = {},\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    const isMaster = acl === undefined;\n    const aclGroup = acl || [];\n    op =\n      op || (typeof query.objectId == 'string' && Object.keys(query).length === 1 ? 'get' : 'find');\n    // Count operation if counting\n    op = count === true ? 'count' : op;\n\n    let classExists = true;\n    return this.loadSchemaIfNeeded(validSchemaController).then(schemaController => {\n      //Allow volatile classes if querying with Master (for _PushStatus)\n      //TODO: Move volatile classes concept into mongo adapter, postgres adapter shouldn't care\n      //that api.parse.com breaks when _PushStatus exists in mongo.\n      return schemaController\n        .getOneSchema(className, isMaster)\n        .catch(error => {\n          // Behavior for non-existent classes is kinda weird on Parse.com. Probably doesn't matter too much.\n          // For now, pretend the class exists but has no objects,\n          if (error === undefined) {\n            classExists = false;\n            return { fields: {} };\n          }\n          throw error;\n        })\n        .then(schema => {\n          // Parse.com treats queries on _created_at and _updated_at as if they were queries on createdAt and updatedAt,\n          // so duplicate that behavior here. If both are specified, the correct behavior to match Parse.com is to\n          // use the one that appears first in the sort list.\n          if (sort._created_at) {\n            sort.createdAt = sort._created_at;\n            delete sort._created_at;\n          }\n          if (sort._updated_at) {\n            sort.updatedAt = sort._updated_at;\n            delete sort._updated_at;\n          }\n          const queryOptions = {\n            skip,\n            limit,\n            sort,\n            keys,\n            readPreference,\n            hint,\n            caseInsensitive,\n            explain,\n          };\n          Object.keys(sort).forEach(fieldName => {\n            if (fieldName.match(/^authData\\.([a-zA-Z0-9_]+)\\.id$/)) {\n              throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, `Cannot sort by ${fieldName}`);\n            }\n            const rootFieldName = getRootFieldName(fieldName);\n            if (!SchemaController.fieldNameIsValid(rootFieldName, className)) {\n              throw new Parse.Error(\n                Parse.Error.INVALID_KEY_NAME,\n                `Invalid field name: ${fieldName}.`\n              );\n            }\n          });\n          return (isMaster\n            ? Promise.resolve()\n            : schemaController.validatePermission(className, aclGroup, op)\n          )\n            .then(() => this.reduceRelationKeys(className, query, queryOptions))\n            .then(() => this.reduceInRelation(className, query, schemaController))\n            .then(() => {\n              let protectedFields;\n              if (!isMaster) {\n                query = this.addPointerPermissions(\n                  schemaController,\n                  className,\n                  op,\n                  query,\n                  aclGroup\n                );\n                /* Don't use projections to optimize the protectedFields since the protectedFields\n                  based on pointer-permissions are determined after querying. The filtering can\n                  overwrite the protected fields. */\n                protectedFields = this.addProtectedFields(\n                  schemaController,\n                  className,\n                  query,\n                  aclGroup,\n                  auth,\n                  queryOptions\n                );\n              }\n              if (!query) {\n                if (op === 'get') {\n                  throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n                } else {\n                  return [];\n                }\n              }\n              if (!isMaster) {\n                if (op === 'update' || op === 'delete') {\n                  query = addWriteACL(query, aclGroup);\n                } else {\n                  query = addReadACL(query, aclGroup);\n                }\n              }\n              validateQuery(query);\n              if (count) {\n                if (!classExists) {\n                  return 0;\n                } else {\n                  return this.adapter.count(\n                    className,\n                    schema,\n                    query,\n                    readPreference,\n                    undefined,\n                    hint\n                  );\n                }\n              } else if (distinct) {\n                if (!classExists) {\n                  return [];\n                } else {\n                  return this.adapter.distinct(className, schema, query, distinct);\n                }\n              } else if (pipeline) {\n                if (!classExists) {\n                  return [];\n                } else {\n                  return this.adapter.aggregate(\n                    className,\n                    schema,\n                    pipeline,\n                    readPreference,\n                    hint,\n                    explain\n                  );\n                }\n              } else if (explain) {\n                return this.adapter.find(className, schema, query, queryOptions);\n              } else {\n                return this.adapter\n                  .find(className, schema, query, queryOptions)\n                  .then(objects =>\n                    objects.map(object => {\n                      object = untransformObjectACL(object);\n                      return filterSensitiveData(\n                        isMaster,\n                        aclGroup,\n                        auth,\n                        op,\n                        schemaController,\n                        className,\n                        protectedFields,\n                        object\n                      );\n                    })\n                  )\n                  .catch(error => {\n                    throw new Parse.Error(Parse.Error.INTERNAL_SERVER_ERROR, error);\n                  });\n              }\n            });\n        });\n    });\n  }\n\n  deleteSchema(className: string): Promise<void> {\n    let schemaController;\n    return this.loadSchema({ clearCache: true })\n      .then(s => {\n        schemaController = s;\n        return schemaController.getOneSchema(className, true);\n      })\n      .catch(error => {\n        if (error === undefined) {\n          return { fields: {} };\n        } else {\n          throw error;\n        }\n      })\n      .then((schema: any) => {\n        return this.collectionExists(className)\n          .then(() => this.adapter.count(className, { fields: {} }, null, '', false))\n          .then(count => {\n            if (count > 0) {\n              throw new Parse.Error(\n                255,\n                `Class ${className} is not empty, contains ${count} objects, cannot drop schema.`\n              );\n            }\n            return this.adapter.deleteClass(className);\n          })\n          .then(wasParseCollection => {\n            if (wasParseCollection) {\n              const relationFieldNames = Object.keys(schema.fields).filter(\n                fieldName => schema.fields[fieldName].type === 'Relation'\n              );\n              return Promise.all(\n                relationFieldNames.map(name =>\n                  this.adapter.deleteClass(joinTableName(className, name))\n                )\n              ).then(() => {\n                SchemaCache.del(className);\n                return schemaController.reloadData();\n              });\n            } else {\n              return Promise.resolve();\n            }\n          });\n      });\n  }\n\n  // This helps to create intermediate objects for simpler comparison of\n  // key value pairs used in query objects. Each key value pair will represented\n  // in a similar way to json\n  objectToEntriesStrings(query: any): Array<string> {\n    return Object.entries(query).map(a => a.map(s => JSON.stringify(s)).join(':'));\n  }\n\n  // Naive logic reducer for OR operations meant to be used only for pointer permissions.\n  reduceOrOperation(query: { $or: Array<any> }): any {\n    if (!query.$or) {\n      return query;\n    }\n    const queries = query.$or.map(q => this.objectToEntriesStrings(q));\n    let repeat = false;\n    do {\n      repeat = false;\n      for (let i = 0; i < queries.length - 1; i++) {\n        for (let j = i + 1; j < queries.length; j++) {\n          const [shorter, longer] = queries[i].length > queries[j].length ? [j, i] : [i, j];\n          const foundEntries = queries[shorter].reduce(\n            (acc, entry) => acc + (queries[longer].includes(entry) ? 1 : 0),\n            0\n          );\n          const shorterEntries = queries[shorter].length;\n          if (foundEntries === shorterEntries) {\n            // If the shorter query is completely contained in the longer one, we can strike\n            // out the longer query.\n            query.$or.splice(longer, 1);\n            queries.splice(longer, 1);\n            repeat = true;\n            break;\n          }\n        }\n      }\n    } while (repeat);\n    if (query.$or.length === 1) {\n      query = { ...query, ...query.$or[0] };\n      delete query.$or;\n    }\n    return query;\n  }\n\n  // Naive logic reducer for AND operations meant to be used only for pointer permissions.\n  reduceAndOperation(query: { $and: Array<any> }): any {\n    if (!query.$and) {\n      return query;\n    }\n    const queries = query.$and.map(q => this.objectToEntriesStrings(q));\n    let repeat = false;\n    do {\n      repeat = false;\n      for (let i = 0; i < queries.length - 1; i++) {\n        for (let j = i + 1; j < queries.length; j++) {\n          const [shorter, longer] = queries[i].length > queries[j].length ? [j, i] : [i, j];\n          const foundEntries = queries[shorter].reduce(\n            (acc, entry) => acc + (queries[longer].includes(entry) ? 1 : 0),\n            0\n          );\n          const shorterEntries = queries[shorter].length;\n          if (foundEntries === shorterEntries) {\n            // If the shorter query is completely contained in the longer one, we can strike\n            // out the shorter query.\n            query.$and.splice(shorter, 1);\n            queries.splice(shorter, 1);\n            repeat = true;\n            break;\n          }\n        }\n      }\n    } while (repeat);\n    if (query.$and.length === 1) {\n      query = { ...query, ...query.$and[0] };\n      delete query.$and;\n    }\n    return query;\n  }\n\n  // Constraints query using CLP's pointer permissions (PP) if any.\n  // 1. Etract the user id from caller's ACLgroup;\n  // 2. Exctract a list of field names that are PP for target collection and operation;\n  // 3. Constraint the original query so that each PP field must\n  // point to caller's id (or contain it in case of PP field being an array)\n  addPointerPermissions(\n    schema: SchemaController.SchemaController,\n    className: string,\n    operation: string,\n    query: any,\n    aclGroup: any[] = []\n  ): any {\n    // Check if class has public permission for operation\n    // If the BaseCLP pass, let go through\n    if (schema.testPermissionsForClassName(className, aclGroup, operation)) {\n      return query;\n    }\n    const perms = schema.getClassLevelPermissions(className);\n\n    const userACL = aclGroup.filter(acl => {\n      return acl.indexOf('role:') != 0 && acl != '*';\n    });\n\n    const groupKey =\n      ['get', 'find', 'count'].indexOf(operation) > -1 ? 'readUserFields' : 'writeUserFields';\n\n    const permFields = [];\n\n    if (perms[operation] && perms[operation].pointerFields) {\n      permFields.push(...perms[operation].pointerFields);\n    }\n\n    if (perms[groupKey]) {\n      for (const field of perms[groupKey]) {\n        if (!permFields.includes(field)) {\n          permFields.push(field);\n        }\n      }\n    }\n    // the ACL should have exactly 1 user\n    if (permFields.length > 0) {\n      // the ACL should have exactly 1 user\n      // No user set return undefined\n      // If the length is > 1, that means we didn't de-dupe users correctly\n      if (userACL.length != 1) {\n        return;\n      }\n      const userId = userACL[0];\n      const userPointer = {\n        __type: 'Pointer',\n        className: '_User',\n        objectId: userId,\n      };\n\n      const queries = permFields.map(key => {\n        const fieldDescriptor = schema.getExpectedType(className, key);\n        const fieldType =\n          fieldDescriptor &&\n          typeof fieldDescriptor === 'object' &&\n          Object.prototype.hasOwnProperty.call(fieldDescriptor, 'type')\n            ? fieldDescriptor.type\n            : null;\n\n        let queryClause;\n\n        if (fieldType === 'Pointer') {\n          // constraint for single pointer setup\n          queryClause = { [key]: userPointer };\n        } else if (fieldType === 'Array') {\n          // constraint for users-array setup\n          queryClause = { [key]: { $all: [userPointer] } };\n        } else if (fieldType === 'Object') {\n          // constraint for object setup\n          queryClause = { [key]: userPointer };\n        } else {\n          // This means that there is a CLP field of an unexpected type. This condition should not happen, which is\n          // why is being treated as an error.\n          throw Error(\n            `An unexpected condition occurred when resolving pointer permissions: ${className} ${key}`\n          );\n        }\n        // if we already have a constraint on the key, use the $and\n        if (Object.prototype.hasOwnProperty.call(query, key)) {\n          return this.reduceAndOperation({ $and: [queryClause, query] });\n        }\n        // otherwise just add the constaint\n        return Object.assign({}, query, queryClause);\n      });\n\n      return queries.length === 1 ? queries[0] : this.reduceOrOperation({ $or: queries });\n    } else {\n      return query;\n    }\n  }\n\n  addProtectedFields(\n    schema: SchemaController.SchemaController,\n    className: string,\n    query: any = {},\n    aclGroup: any[] = [],\n    auth: any = {},\n    queryOptions: FullQueryOptions = {}\n  ): null | string[] {\n    const perms = schema.getClassLevelPermissions(className);\n    if (!perms) return null;\n\n    const protectedFields = perms.protectedFields;\n    if (!protectedFields) return null;\n\n    if (aclGroup.indexOf(query.objectId) > -1) return null;\n\n    // for queries where \"keys\" are set and do not include all 'userField':{field},\n    // we have to transparently include it, and then remove before returning to client\n    // Because if such key not projected the permission won't be enforced properly\n    // PS this is called when 'excludeKeys' already reduced to 'keys'\n    const preserveKeys = queryOptions.keys;\n\n    // these are keys that need to be included only\n    // to be able to apply protectedFields by pointer\n    // and then unset before returning to client (later in  filterSensitiveFields)\n    const serverOnlyKeys = [];\n\n    const authenticated = auth.user;\n\n    // map to allow check without array search\n    const roles = (auth.userRoles || []).reduce((acc, r) => {\n      acc[r] = protectedFields[r];\n      return acc;\n    }, {});\n\n    // array of sets of protected fields. separate item for each applicable criteria\n    const protectedKeysSets = [];\n\n    for (const key in protectedFields) {\n      // skip userFields\n      if (key.startsWith('userField:')) {\n        if (preserveKeys) {\n          const fieldName = key.substring(10);\n          if (!preserveKeys.includes(fieldName)) {\n            // 1. put it there temporarily\n            queryOptions.keys && queryOptions.keys.push(fieldName);\n            // 2. preserve it delete later\n            serverOnlyKeys.push(fieldName);\n          }\n        }\n        continue;\n      }\n\n      // add public tier\n      if (key === '*') {\n        protectedKeysSets.push(protectedFields[key]);\n        continue;\n      }\n\n      if (authenticated) {\n        if (key === 'authenticated') {\n          // for logged in users\n          protectedKeysSets.push(protectedFields[key]);\n          continue;\n        }\n\n        if (roles[key] && key.startsWith('role:')) {\n          // add applicable roles\n          protectedKeysSets.push(roles[key]);\n        }\n      }\n    }\n\n    // check if there's a rule for current user's id\n    if (authenticated) {\n      const userId = auth.user.id;\n      if (perms.protectedFields[userId]) {\n        protectedKeysSets.push(perms.protectedFields[userId]);\n      }\n    }\n\n    // preserve fields to be removed before sending response to client\n    if (serverOnlyKeys.length > 0) {\n      perms.protectedFields.temporaryKeys = serverOnlyKeys;\n    }\n\n    let protectedKeys = protectedKeysSets.reduce((acc, next) => {\n      if (next) {\n        acc.push(...next);\n      }\n      return acc;\n    }, []);\n\n    // intersect all sets of protectedFields\n    protectedKeysSets.forEach(fields => {\n      if (fields) {\n        protectedKeys = protectedKeys.filter(v => fields.includes(v));\n      }\n    });\n\n    return protectedKeys;\n  }\n\n  createTransactionalSession() {\n    return this.adapter.createTransactionalSession().then(transactionalSession => {\n      this._transactionalSession = transactionalSession;\n    });\n  }\n\n  commitTransactionalSession() {\n    if (!this._transactionalSession) {\n      throw new Error('There is no transactional session to commit');\n    }\n    return this.adapter.commitTransactionalSession(this._transactionalSession).then(() => {\n      this._transactionalSession = null;\n    });\n  }\n\n  abortTransactionalSession() {\n    if (!this._transactionalSession) {\n      throw new Error('There is no transactional session to abort');\n    }\n    return this.adapter.abortTransactionalSession(this._transactionalSession).then(() => {\n      this._transactionalSession = null;\n    });\n  }\n\n  // TODO: create indexes on first creation of a _User object. Otherwise it's impossible to\n  // have a Parse app without it having a _User collection.\n  async performInitialization() {\n    await this.adapter.performInitialization({\n      VolatileClassesSchemas: SchemaController.VolatileClassesSchemas,\n    });\n    const requiredUserFields = {\n      fields: {\n        ...SchemaController.defaultColumns._Default,\n        ...SchemaController.defaultColumns._User,\n      },\n    };\n    const requiredRoleFields = {\n      fields: {\n        ...SchemaController.defaultColumns._Default,\n        ...SchemaController.defaultColumns._Role,\n      },\n    };\n    const requiredIdempotencyFields = {\n      fields: {\n        ...SchemaController.defaultColumns._Default,\n        ...SchemaController.defaultColumns._Idempotency,\n      },\n    };\n    await this.loadSchema().then(schema => schema.enforceClassExists('_User'));\n    await this.loadSchema().then(schema => schema.enforceClassExists('_Role'));\n    await this.loadSchema().then(schema => schema.enforceClassExists('_Idempotency'));\n\n    await this.adapter.ensureUniqueness('_User', requiredUserFields, ['username']).catch(error => {\n      logger.warn('Unable to ensure uniqueness for usernames: ', error);\n      throw error;\n    });\n\n    await this.adapter\n      .ensureIndex('_User', requiredUserFields, ['username'], 'case_insensitive_username', true)\n      .catch(error => {\n        logger.warn('Unable to create case insensitive username index: ', error);\n        throw error;\n      });\n    await this.adapter\n      .ensureIndex('_User', requiredUserFields, ['username'], 'case_insensitive_username', true)\n      .catch(error => {\n        logger.warn('Unable to create case insensitive username index: ', error);\n        throw error;\n      });\n\n    await this.adapter.ensureUniqueness('_User', requiredUserFields, ['email']).catch(error => {\n      logger.warn('Unable to ensure uniqueness for user email addresses: ', error);\n      throw error;\n    });\n\n    await this.adapter\n      .ensureIndex('_User', requiredUserFields, ['email'], 'case_insensitive_email', true)\n      .catch(error => {\n        logger.warn('Unable to create case insensitive email index: ', error);\n        throw error;\n      });\n\n    await this.adapter.ensureUniqueness('_Role', requiredRoleFields, ['name']).catch(error => {\n      logger.warn('Unable to ensure uniqueness for role name: ', error);\n      throw error;\n    });\n\n    await this.adapter\n      .ensureUniqueness('_Idempotency', requiredIdempotencyFields, ['reqId'])\n      .catch(error => {\n        logger.warn('Unable to ensure uniqueness for idempotency request ID: ', error);\n        throw error;\n      });\n\n    const isMongoAdapter = this.adapter instanceof MongoStorageAdapter;\n    const isPostgresAdapter = this.adapter instanceof PostgresStorageAdapter;\n    if (isMongoAdapter || isPostgresAdapter) {\n      let options = {};\n      if (isMongoAdapter) {\n        options = {\n          ttl: 0,\n        };\n      } else if (isPostgresAdapter) {\n        options = this.idempotencyOptions;\n        options.setIdempotencyFunction = true;\n      }\n      await this.adapter\n        .ensureIndex('_Idempotency', requiredIdempotencyFields, ['expire'], 'ttl', false, options)\n        .catch(error => {\n          logger.warn('Unable to create TTL index for idempotency expire date: ', error);\n          throw error;\n        });\n    }\n    await this.adapter.updateSchemaWithIndexes();\n  }\n\n  _expandResultOnKeyPath(object: any, key: string, value: any): any {\n    if (key.indexOf('.') < 0) {\n      object[key] = value[key];\n      return object;\n    }\n    const path = key.split('.');\n    const firstKey = path[0];\n    const nextPath = path.slice(1).join('.');\n\n    // Scan request data for denied keywords\n    if (this.options && this.options.requestKeywordDenylist) {\n      // Scan request data for denied keywords\n      for (const keyword of this.options.requestKeywordDenylist) {\n        const match = Utils.objectContainsKeyValue({ firstKey: undefined }, keyword.key, undefined);\n        if (match) {\n          throw new Parse.Error(\n            Parse.Error.INVALID_KEY_NAME,\n            `Prohibited keyword in request data: ${JSON.stringify(keyword)}.`\n          );\n        }\n      }\n    }\n\n    object[firstKey] = this._expandResultOnKeyPath(\n      object[firstKey] || {},\n      nextPath,\n      value[firstKey]\n    );\n    delete object[key];\n    return object;\n  }\n\n  _sanitizeDatabaseResult(originalObject: any, result: any): Promise<any> {\n    const response = {};\n    if (!result) {\n      return Promise.resolve(response);\n    }\n    Object.keys(originalObject).forEach(key => {\n      const keyUpdate = originalObject[key];\n      // determine if that was an op\n      if (\n        keyUpdate &&\n        typeof keyUpdate === 'object' &&\n        keyUpdate.__op &&\n        ['Add', 'AddUnique', 'Remove', 'Increment'].indexOf(keyUpdate.__op) > -1\n      ) {\n        // only valid ops that produce an actionable result\n        // the op may have happened on a keypath\n        this._expandResultOnKeyPath(response, key, result);\n      }\n    });\n    return Promise.resolve(response);\n  }\n\n  static _validateQuery: any => void;\n}\n\nmodule.exports = DatabaseController;\n// Expose validateQuery for tests\nmodule.exports._validateQuery = validateQuery;\n", "import { ParsePubSub } from './ParsePubSub';\nimport Parse from 'parse/node';\nimport logger from '../logger';\n\nclass ParseCloudCodePublisher {\n  parsePublisher: Object;\n\n  // config object of the publisher, right now it only contains the redisURL,\n  // but we may extend it later.\n  constructor(config: any = {}) {\n    this.parsePublisher = ParsePubSub.createPublisher(config);\n  }\n\n  onCloudCodeAfterSave(request: any): void {\n    this._onCloudCodeMessage(Parse.applicationId + 'afterSave', request);\n  }\n\n  onCloudCodeAfterDelete(request: any): void {\n    this._onCloudCodeMessage(Parse.applicationId + 'afterDelete', request);\n  }\n\n  // Request is the request object from cloud code functions. request.object is a ParseObject.\n  _onCloudCodeMessage(type: string, request: any): void {\n    logger.verbose(\n      'Raw request from cloud code current : %j | original : %j',\n      request.object,\n      request.original\n    );\n    // We need the full JSON which includes className\n    const message = {\n      currentParseObject: request.object._toFullJSON(),\n    };\n    if (request.original) {\n      message.originalParseObject = request.original._toFullJSON();\n    }\n    this.parsePublisher.publish(type, JSON.stringify(message));\n  }\n}\n\nexport { ParseCloudCodePublisher };\n", "import tv4 from 'tv4';\nimport Parse from 'parse/node';\nimport { Subscription } from './Subscription';\nimport { Client } from './Client';\nimport { ParseWebSocketServer } from './ParseWebSocketServer';\nimport logger from '../logger';\nimport RequestSchema from './RequestSchema';\nimport { matchesQuery, queryHash } from './QueryTools';\nimport { ParsePubSub } from './ParsePubSub';\nimport SchemaController from '../Controllers/SchemaController';\nimport _ from 'lodash';\nimport { v4 as uuidv4 } from 'uuid';\nimport { runLiveQueryEventHandlers, getTrigger, runTrigger, resolveError, toJSONwithObjects } from '../triggers';\nimport { getAuthForSessionToken, Auth } from '../Auth';\nimport { getCacheController } from '../Controllers';\nimport LRU from 'lru-cache';\nimport UserRouter from '../Routers/UsersRouter';\n\nclass ParseLiveQueryServer {\n  clients: Map;\n  // className -> (queryHash -> subscription)\n  subscriptions: Object;\n  parseWebSocketServer: Object;\n  keyPairs: any;\n  // The subscriber we use to get object update from publisher\n  subscriber: Object;\n\n  constructor(server: any, config: any = {}, parseServerConfig: any = {}) {\n    this.server = server;\n    this.clients = new Map();\n    this.subscriptions = new Map();\n    this.config = config;\n\n    config.appId = config.appId || Parse.applicationId;\n    config.masterKey = config.masterKey || Parse.masterKey;\n\n    // Store keys, convert obj to map\n    const keyPairs = config.keyPairs || {};\n    this.keyPairs = new Map();\n    for (const key of Object.keys(keyPairs)) {\n      this.keyPairs.set(key, keyPairs[key]);\n    }\n    logger.verbose('Support key pairs', this.keyPairs);\n\n    // Initialize Parse\n    Parse.Object.disableSingleInstance();\n    const serverURL = config.serverURL || Parse.serverURL;\n    Parse.serverURL = serverURL;\n    Parse.initialize(config.appId, Parse.javaScriptKey, config.masterKey);\n\n    // The cache controller is a proper cache controller\n    // with access to User and Roles\n    this.cacheController = getCacheController(parseServerConfig);\n\n    config.cacheTimeout = config.cacheTimeout || 5 * 1000; // 5s\n\n    // This auth cache stores the promises for each auth resolution.\n    // The main benefit is to be able to reuse the same user / session token resolution.\n    this.authCache = new LRU({\n      max: 500, // 500 concurrent\n      maxAge: config.cacheTimeout,\n    });\n    // Initialize websocket server\n    this.parseWebSocketServer = new ParseWebSocketServer(\n      server,\n      parseWebsocket => this._onConnect(parseWebsocket),\n      config\n    );\n\n    // Initialize subscriber\n    this.subscriber = ParsePubSub.createSubscriber(config);\n    this.subscriber.subscribe(Parse.applicationId + 'afterSave');\n    this.subscriber.subscribe(Parse.applicationId + 'afterDelete');\n    // Register message handler for subscriber. When publisher get messages, it will publish message\n    // to the subscribers and the handler will be called.\n    this.subscriber.on('message', (channel, messageStr) => {\n      logger.verbose('Subscribe message %j', messageStr);\n      let message;\n      try {\n        message = JSON.parse(messageStr);\n      } catch (e) {\n        logger.error('unable to parse message', messageStr, e);\n        return;\n      }\n      this._inflateParseObject(message);\n      if (channel === Parse.applicationId + 'afterSave') {\n        this._onAfterSave(message);\n      } else if (channel === Parse.applicationId + 'afterDelete') {\n        this._onAfterDelete(message);\n      } else {\n        logger.error('Get message %s from unknown channel %j', message, channel);\n      }\n    });\n  }\n\n  // Message is the JSON object from publisher. Message.currentParseObject is the ParseObject JSON after changes.\n  // Message.originalParseObject is the original ParseObject JSON.\n  _inflateParseObject(message: any): void {\n    // Inflate merged object\n    const currentParseObject = message.currentParseObject;\n    UserRouter.removeHiddenProperties(currentParseObject);\n    let className = currentParseObject.className;\n    let parseObject = new Parse.Object(className);\n    parseObject._finishFetch(currentParseObject);\n    message.currentParseObject = parseObject;\n    // Inflate original object\n    const originalParseObject = message.originalParseObject;\n    if (originalParseObject) {\n      UserRouter.removeHiddenProperties(originalParseObject);\n      className = originalParseObject.className;\n      parseObject = new Parse.Object(className);\n      parseObject._finishFetch(originalParseObject);\n      message.originalParseObject = parseObject;\n    }\n  }\n\n  // Message is the JSON object from publisher after inflated. Message.currentParseObject is the ParseObject after changes.\n  // Message.originalParseObject is the original ParseObject.\n  async _onAfterDelete(message: any): void {\n    logger.verbose(Parse.applicationId + 'afterDelete is triggered');\n\n    let deletedParseObject = message.currentParseObject.toJSON();\n    const classLevelPermissions = message.classLevelPermissions;\n    const className = deletedParseObject.className;\n    logger.verbose('ClassName: %j | ObjectId: %s', className, deletedParseObject.id);\n    logger.verbose('Current client number : %d', this.clients.size);\n\n    const classSubscriptions = this.subscriptions.get(className);\n    if (typeof classSubscriptions === 'undefined') {\n      logger.debug('Can not find subscriptions under this class ' + className);\n      return;\n    }\n\n    for (const subscription of classSubscriptions.values()) {\n      const isSubscriptionMatched = this._matchesSubscription(deletedParseObject, subscription);\n      if (!isSubscriptionMatched) {\n        continue;\n      }\n      for (const [clientId, requestIds] of _.entries(subscription.clientRequestIds)) {\n        const client = this.clients.get(clientId);\n        if (typeof client === 'undefined') {\n          continue;\n        }\n        requestIds.forEach(async requestId => {\n          const acl = message.currentParseObject.getACL();\n          // Check CLP\n          const op = this._getCLPOperation(subscription.query);\n          let res = {};\n          try {\n            await this._matchesCLP(\n              classLevelPermissions,\n              message.currentParseObject,\n              client,\n              requestId,\n              op\n            );\n            const isMatched = await this._matchesACL(acl, client, requestId);\n            if (!isMatched) {\n              return null;\n            }\n            res = {\n              event: 'delete',\n              sessionToken: client.sessionToken,\n              object: deletedParseObject,\n              clients: this.clients.size,\n              subscriptions: this.subscriptions.size,\n              useMasterKey: client.hasMasterKey,\n              installationId: client.installationId,\n              sendEvent: true,\n            };\n            const trigger = getTrigger(className, 'afterEvent', Parse.applicationId);\n            if (trigger) {\n              const auth = await this.getAuthFromClient(client, requestId);\n              if (auth && auth.user) {\n                res.user = auth.user;\n              }\n              if (res.object) {\n                res.object = Parse.Object.fromJSON(res.object);\n              }\n              await runTrigger(trigger, `afterEvent.${className}`, res, auth);\n            }\n            if (!res.sendEvent) {\n              return;\n            }\n            if (res.object && typeof res.object.toJSON === 'function') {\n              deletedParseObject = toJSONwithObjects(res.object, res.object.className || className);\n            }\n            if (\n              (deletedParseObject.className === '_User' ||\n                deletedParseObject.className === '_Session') &&\n              !client.hasMasterKey\n            ) {\n              delete deletedParseObject.sessionToken;\n              delete deletedParseObject.authData;\n            }\n            client.pushDelete(requestId, deletedParseObject);\n          } catch (e) {\n            const error = resolveError(e);\n            Client.pushError(client.parseWebSocket, error.code, error.message, false, requestId);\n            logger.error(\n              `Failed running afterLiveQueryEvent on class ${className} for event ${res.event} with session ${res.sessionToken} with:\\n Error: ` +\n                JSON.stringify(error)\n            );\n          }\n        });\n      }\n    }\n  }\n\n  // Message is the JSON object from publisher after inflated. Message.currentParseObject is the ParseObject after changes.\n  // Message.originalParseObject is the original ParseObject.\n  async _onAfterSave(message: any): void {\n    logger.verbose(Parse.applicationId + 'afterSave is triggered');\n\n    let originalParseObject = null;\n    if (message.originalParseObject) {\n      originalParseObject = message.originalParseObject.toJSON();\n    }\n    const classLevelPermissions = message.classLevelPermissions;\n    let currentParseObject = message.currentParseObject.toJSON();\n    const className = currentParseObject.className;\n    logger.verbose('ClassName: %s | ObjectId: %s', className, currentParseObject.id);\n    logger.verbose('Current client number : %d', this.clients.size);\n\n    const classSubscriptions = this.subscriptions.get(className);\n    if (typeof classSubscriptions === 'undefined') {\n      logger.debug('Can not find subscriptions under this class ' + className);\n      return;\n    }\n    for (const subscription of classSubscriptions.values()) {\n      const isOriginalSubscriptionMatched = this._matchesSubscription(\n        originalParseObject,\n        subscription\n      );\n      const isCurrentSubscriptionMatched = this._matchesSubscription(\n        currentParseObject,\n        subscription\n      );\n      for (const [clientId, requestIds] of _.entries(subscription.clientRequestIds)) {\n        const client = this.clients.get(clientId);\n        if (typeof client === 'undefined') {\n          continue;\n        }\n        requestIds.forEach(async requestId => {\n          // Set orignal ParseObject ACL checking promise, if the object does not match\n          // subscription, we do not need to check ACL\n          let originalACLCheckingPromise;\n          if (!isOriginalSubscriptionMatched) {\n            originalACLCheckingPromise = Promise.resolve(false);\n          } else {\n            let originalACL;\n            if (message.originalParseObject) {\n              originalACL = message.originalParseObject.getACL();\n            }\n            originalACLCheckingPromise = this._matchesACL(originalACL, client, requestId);\n          }\n          // Set current ParseObject ACL checking promise, if the object does not match\n          // subscription, we do not need to check ACL\n          let currentACLCheckingPromise;\n          let res = {};\n          if (!isCurrentSubscriptionMatched) {\n            currentACLCheckingPromise = Promise.resolve(false);\n          } else {\n            const currentACL = message.currentParseObject.getACL();\n            currentACLCheckingPromise = this._matchesACL(currentACL, client, requestId);\n          }\n          try {\n            const op = this._getCLPOperation(subscription.query);\n            await this._matchesCLP(\n              classLevelPermissions,\n              message.currentParseObject,\n              client,\n              requestId,\n              op\n            );\n            const [isOriginalMatched, isCurrentMatched] = await Promise.all([\n              originalACLCheckingPromise,\n              currentACLCheckingPromise,\n            ]);\n            logger.verbose(\n              'Original %j | Current %j | Match: %s, %s, %s, %s | Query: %s',\n              originalParseObject,\n              currentParseObject,\n              isOriginalSubscriptionMatched,\n              isCurrentSubscriptionMatched,\n              isOriginalMatched,\n              isCurrentMatched,\n              subscription.hash\n            );\n            // Decide event type\n            let type;\n            if (isOriginalMatched && isCurrentMatched) {\n              type = 'update';\n            } else if (isOriginalMatched && !isCurrentMatched) {\n              type = 'leave';\n            } else if (!isOriginalMatched && isCurrentMatched) {\n              if (originalParseObject) {\n                type = 'enter';\n              } else {\n                type = 'create';\n              }\n            } else {\n              return null;\n            }\n            res = {\n              event: type,\n              sessionToken: client.sessionToken,\n              object: currentParseObject,\n              original: originalParseObject,\n              clients: this.clients.size,\n              subscriptions: this.subscriptions.size,\n              useMasterKey: client.hasMasterKey,\n              installationId: client.installationId,\n              sendEvent: true,\n            };\n            const trigger = getTrigger(className, 'afterEvent', Parse.applicationId);\n            if (trigger) {\n              if (res.object) {\n                res.object = Parse.Object.fromJSON(res.object);\n              }\n              if (res.original) {\n                res.original = Parse.Object.fromJSON(res.original);\n              }\n              const auth = await this.getAuthFromClient(client, requestId);\n              if (auth && auth.user) {\n                res.user = auth.user;\n              }\n              await runTrigger(trigger, `afterEvent.${className}`, res, auth);\n            }\n            if (!res.sendEvent) {\n              return;\n            }\n            if (res.object && typeof res.object.toJSON === 'function') {\n              currentParseObject = toJSONwithObjects(res.object, res.object.className || className);\n            }\n            if (res.original && typeof res.original.toJSON === 'function') {\n              originalParseObject = toJSONwithObjects(\n                res.original,\n                res.original.className || className\n              );\n            }\n            if (\n              (currentParseObject.className === '_User' ||\n                currentParseObject.className === '_Session') &&\n              !client.hasMasterKey\n            ) {\n              delete currentParseObject.sessionToken;\n              delete originalParseObject?.sessionToken;\n              delete currentParseObject.authData;\n              delete originalParseObject?.authData;\n            }\n            const functionName = 'push' + res.event.charAt(0).toUpperCase() + res.event.slice(1);\n            if (client[functionName]) {\n              client[functionName](requestId, currentParseObject, originalParseObject);\n            }\n          } catch (e) {\n            const error = resolveError(e);\n            Client.pushError(client.parseWebSocket, error.code, error.message, false, requestId);\n            logger.error(\n              `Failed running afterLiveQueryEvent on class ${className} for event ${res.event} with session ${res.sessionToken} with:\\n Error: ` +\n                JSON.stringify(error)\n            );\n          }\n        });\n      }\n    }\n  }\n\n  _onConnect(parseWebsocket: any): void {\n    parseWebsocket.on('message', request => {\n      if (typeof request === 'string') {\n        try {\n          request = JSON.parse(request);\n        } catch (e) {\n          logger.error('unable to parse request', request, e);\n          return;\n        }\n      }\n      logger.verbose('Request: %j', request);\n\n      // Check whether this request is a valid request, return error directly if not\n      if (\n        !tv4.validate(request, RequestSchema['general']) ||\n        !tv4.validate(request, RequestSchema[request.op])\n      ) {\n        Client.pushError(parseWebsocket, 1, tv4.error.message);\n        logger.error('Connect message error %s', tv4.error.message);\n        return;\n      }\n\n      switch (request.op) {\n        case 'connect':\n          this._handleConnect(parseWebsocket, request);\n          break;\n        case 'subscribe':\n          this._handleSubscribe(parseWebsocket, request);\n          break;\n        case 'update':\n          this._handleUpdateSubscription(parseWebsocket, request);\n          break;\n        case 'unsubscribe':\n          this._handleUnsubscribe(parseWebsocket, request);\n          break;\n        default:\n          Client.pushError(parseWebsocket, 3, 'Get unknown operation');\n          logger.error('Get unknown operation', request.op);\n      }\n    });\n\n    parseWebsocket.on('disconnect', () => {\n      logger.info(`Client disconnect: ${parseWebsocket.clientId}`);\n      const clientId = parseWebsocket.clientId;\n      if (!this.clients.has(clientId)) {\n        runLiveQueryEventHandlers({\n          event: 'ws_disconnect_error',\n          clients: this.clients.size,\n          subscriptions: this.subscriptions.size,\n          error: `Unable to find client ${clientId}`,\n        });\n        logger.error(`Can not find client ${clientId} on disconnect`);\n        return;\n      }\n\n      // Delete client\n      const client = this.clients.get(clientId);\n      this.clients.delete(clientId);\n\n      // Delete client from subscriptions\n      for (const [requestId, subscriptionInfo] of _.entries(client.subscriptionInfos)) {\n        const subscription = subscriptionInfo.subscription;\n        subscription.deleteClientSubscription(clientId, requestId);\n\n        // If there is no client which is subscribing this subscription, remove it from subscriptions\n        const classSubscriptions = this.subscriptions.get(subscription.className);\n        if (!subscription.hasSubscribingClient()) {\n          classSubscriptions.delete(subscription.hash);\n        }\n        // If there is no subscriptions under this class, remove it from subscriptions\n        if (classSubscriptions.size === 0) {\n          this.subscriptions.delete(subscription.className);\n        }\n      }\n\n      logger.verbose('Current clients %d', this.clients.size);\n      logger.verbose('Current subscriptions %d', this.subscriptions.size);\n      runLiveQueryEventHandlers({\n        event: 'ws_disconnect',\n        clients: this.clients.size,\n        subscriptions: this.subscriptions.size,\n        useMasterKey: client.hasMasterKey,\n        installationId: client.installationId,\n        sessionToken: client.sessionToken,\n      });\n    });\n\n    runLiveQueryEventHandlers({\n      event: 'ws_connect',\n      clients: this.clients.size,\n      subscriptions: this.subscriptions.size,\n    });\n  }\n\n  _matchesSubscription(parseObject: any, subscription: any): boolean {\n    // Object is undefined or null, not match\n    if (!parseObject) {\n      return false;\n    }\n    return matchesQuery(parseObject, subscription.query);\n  }\n\n  getAuthForSessionToken(sessionToken: ?string): Promise<{ auth: ?Auth, userId: ?string }> {\n    if (!sessionToken) {\n      return Promise.resolve({});\n    }\n    const fromCache = this.authCache.get(sessionToken);\n    if (fromCache) {\n      return fromCache;\n    }\n    const authPromise = getAuthForSessionToken({\n      cacheController: this.cacheController,\n      sessionToken: sessionToken,\n    })\n      .then(auth => {\n        return { auth, userId: auth && auth.user && auth.user.id };\n      })\n      .catch(error => {\n        // There was an error with the session token\n        const result = {};\n        if (error && error.code === Parse.Error.INVALID_SESSION_TOKEN) {\n          result.error = error;\n          this.authCache.set(sessionToken, Promise.resolve(result), this.config.cacheTimeout);\n        } else {\n          this.authCache.del(sessionToken);\n        }\n        return result;\n      });\n    this.authCache.set(sessionToken, authPromise);\n    return authPromise;\n  }\n\n  async _matchesCLP(\n    classLevelPermissions: ?any,\n    object: any,\n    client: any,\n    requestId: number,\n    op: string\n  ): any {\n    // try to match on user first, less expensive than with roles\n    const subscriptionInfo = client.getSubscriptionInfo(requestId);\n    const aclGroup = ['*'];\n    let userId;\n    if (typeof subscriptionInfo !== 'undefined') {\n      const { userId } = await this.getAuthForSessionToken(subscriptionInfo.sessionToken);\n      if (userId) {\n        aclGroup.push(userId);\n      }\n    }\n    try {\n      await SchemaController.validatePermission(\n        classLevelPermissions,\n        object.className,\n        aclGroup,\n        op\n      );\n      return true;\n    } catch (e) {\n      logger.verbose(`Failed matching CLP for ${object.id} ${userId} ${e}`);\n      return false;\n    }\n    // TODO: handle roles permissions\n    // Object.keys(classLevelPermissions).forEach((key) => {\n    //   const perm = classLevelPermissions[key];\n    //   Object.keys(perm).forEach((key) => {\n    //     if (key.indexOf('role'))\n    //   });\n    // })\n    // // it's rejected here, check the roles\n    // var rolesQuery = new Parse.Query(Parse.Role);\n    // rolesQuery.equalTo(\"users\", user);\n    // return rolesQuery.find({useMasterKey:true});\n  }\n\n  _getCLPOperation(query: any) {\n    return typeof query === 'object' &&\n      Object.keys(query).length == 1 &&\n      typeof query.objectId === 'string'\n      ? 'get'\n      : 'find';\n  }\n\n  async _verifyACL(acl: any, token: string) {\n    if (!token) {\n      return false;\n    }\n\n    const { auth, userId } = await this.getAuthForSessionToken(token);\n\n    // Getting the session token failed\n    // This means that no additional auth is available\n    // At this point, just bail out as no additional visibility can be inferred.\n    if (!auth || !userId) {\n      return false;\n    }\n    const isSubscriptionSessionTokenMatched = acl.getReadAccess(userId);\n    if (isSubscriptionSessionTokenMatched) {\n      return true;\n    }\n\n    // Check if the user has any roles that match the ACL\n    return Promise.resolve()\n      .then(async () => {\n        // Resolve false right away if the acl doesn't have any roles\n        const acl_has_roles = Object.keys(acl.permissionsById).some(key => key.startsWith('role:'));\n        if (!acl_has_roles) {\n          return false;\n        }\n\n        const roleNames = await auth.getUserRoles();\n        // Finally, see if any of the user's roles allow them read access\n        for (const role of roleNames) {\n          // We use getReadAccess as `role` is in the form `role:roleName`\n          if (acl.getReadAccess(role)) {\n            return true;\n          }\n        }\n        return false;\n      })\n      .catch(() => {\n        return false;\n      });\n  }\n\n  async getAuthFromClient(client: any, requestId: number, sessionToken: string) {\n    const getSessionFromClient = () => {\n      const subscriptionInfo = client.getSubscriptionInfo(requestId);\n      if (typeof subscriptionInfo === 'undefined') {\n        return client.sessionToken;\n      }\n      return subscriptionInfo.sessionToken || client.sessionToken;\n    };\n    if (!sessionToken) {\n      sessionToken = getSessionFromClient();\n    }\n    if (!sessionToken) {\n      return;\n    }\n    const { auth } = await this.getAuthForSessionToken(sessionToken);\n    return auth;\n  }\n\n  async _matchesACL(acl: any, client: any, requestId: number): Promise<boolean> {\n    // Return true directly if ACL isn't present, ACL is public read, or client has master key\n    if (!acl || acl.getPublicReadAccess() || client.hasMasterKey) {\n      return true;\n    }\n    // Check subscription sessionToken matches ACL first\n    const subscriptionInfo = client.getSubscriptionInfo(requestId);\n    if (typeof subscriptionInfo === 'undefined') {\n      return false;\n    }\n\n    const subscriptionToken = subscriptionInfo.sessionToken;\n    const clientSessionToken = client.sessionToken;\n\n    if (await this._verifyACL(acl, subscriptionToken)) {\n      return true;\n    }\n\n    if (await this._verifyACL(acl, clientSessionToken)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  async _handleConnect(parseWebsocket: any, request: any): any {\n    if (!this._validateKeys(request, this.keyPairs)) {\n      Client.pushError(parseWebsocket, 4, 'Key in request is not valid');\n      logger.error('Key in request is not valid');\n      return;\n    }\n    const hasMasterKey = this._hasMasterKey(request, this.keyPairs);\n    const clientId = uuidv4();\n    const client = new Client(\n      clientId,\n      parseWebsocket,\n      hasMasterKey,\n      request.sessionToken,\n      request.installationId\n    );\n    try {\n      const req = {\n        client,\n        event: 'connect',\n        clients: this.clients.size,\n        subscriptions: this.subscriptions.size,\n        sessionToken: request.sessionToken,\n        useMasterKey: client.hasMasterKey,\n        installationId: request.installationId,\n      };\n      const trigger = getTrigger('@Connect', 'beforeConnect', Parse.applicationId);\n      if (trigger) {\n        const auth = await this.getAuthFromClient(client, request.requestId, req.sessionToken);\n        if (auth && auth.user) {\n          req.user = auth.user;\n        }\n        await runTrigger(trigger, `beforeConnect.@Connect`, req, auth);\n      }\n      parseWebsocket.clientId = clientId;\n      this.clients.set(parseWebsocket.clientId, client);\n      logger.info(`Create new client: ${parseWebsocket.clientId}`);\n      client.pushConnect();\n      runLiveQueryEventHandlers(req);\n    } catch (e) {\n      const error = resolveError(e);\n      Client.pushError(parseWebsocket, error.code, error.message, false);\n      logger.error(\n        `Failed running beforeConnect for session ${request.sessionToken} with:\\n Error: ` +\n          JSON.stringify(error)\n      );\n    }\n  }\n\n  _hasMasterKey(request: any, validKeyPairs: any): boolean {\n    if (!validKeyPairs || validKeyPairs.size == 0 || !validKeyPairs.has('masterKey')) {\n      return false;\n    }\n    if (!request || !Object.prototype.hasOwnProperty.call(request, 'masterKey')) {\n      return false;\n    }\n    return request.masterKey === validKeyPairs.get('masterKey');\n  }\n\n  _validateKeys(request: any, validKeyPairs: any): boolean {\n    if (!validKeyPairs || validKeyPairs.size == 0) {\n      return true;\n    }\n    let isValid = false;\n    for (const [key, secret] of validKeyPairs) {\n      if (!request[key] || request[key] !== secret) {\n        continue;\n      }\n      isValid = true;\n      break;\n    }\n    return isValid;\n  }\n\n  async _handleSubscribe(parseWebsocket: any, request: any): any {\n    // If we can not find this client, return error to client\n    if (!Object.prototype.hasOwnProperty.call(parseWebsocket, 'clientId')) {\n      Client.pushError(\n        parseWebsocket,\n        2,\n        'Can not find this client, make sure you connect to server before subscribing'\n      );\n      logger.error('Can not find this client, make sure you connect to server before subscribing');\n      return;\n    }\n    const client = this.clients.get(parseWebsocket.clientId);\n    const className = request.query.className;\n    let authCalled = false;\n    try {\n      const trigger = getTrigger(className, 'beforeSubscribe', Parse.applicationId);\n      if (trigger) {\n        const auth = await this.getAuthFromClient(client, request.requestId, request.sessionToken);\n        authCalled = true;\n        if (auth && auth.user) {\n          request.user = auth.user;\n        }\n\n        const parseQuery = new Parse.Query(className);\n        parseQuery.withJSON(request.query);\n        request.query = parseQuery;\n        await runTrigger(trigger, `beforeSubscribe.${className}`, request, auth);\n\n        const query = request.query.toJSON();\n        if (query.keys) {\n          query.fields = query.keys.split(',');\n        }\n        request.query = query;\n      }\n\n      if (className === '_Session') {\n        if (!authCalled) {\n          const auth = await this.getAuthFromClient(\n            client,\n            request.requestId,\n            request.sessionToken\n          );\n          if (auth && auth.user) {\n            request.user = auth.user;\n          }\n        }\n        if (request.user) {\n          request.query.where.user = request.user.toPointer();\n        } else if (!request.master) {\n          Client.pushError(\n            parseWebsocket,\n            Parse.Error.INVALID_SESSION_TOKEN,\n            'Invalid session token',\n            false,\n            request.requestId\n          );\n          return;\n        }\n      }\n      // Get subscription from subscriptions, create one if necessary\n      const subscriptionHash = queryHash(request.query);\n      // Add className to subscriptions if necessary\n\n      if (!this.subscriptions.has(className)) {\n        this.subscriptions.set(className, new Map());\n      }\n      const classSubscriptions = this.subscriptions.get(className);\n      let subscription;\n      if (classSubscriptions.has(subscriptionHash)) {\n        subscription = classSubscriptions.get(subscriptionHash);\n      } else {\n        subscription = new Subscription(className, request.query.where, subscriptionHash);\n        classSubscriptions.set(subscriptionHash, subscription);\n      }\n\n      // Add subscriptionInfo to client\n      const subscriptionInfo = {\n        subscription: subscription,\n      };\n      // Add selected fields, sessionToken and installationId for this subscription if necessary\n      if (request.query.fields) {\n        subscriptionInfo.fields = request.query.fields;\n      }\n      if (request.sessionToken) {\n        subscriptionInfo.sessionToken = request.sessionToken;\n      }\n      client.addSubscriptionInfo(request.requestId, subscriptionInfo);\n\n      // Add clientId to subscription\n      subscription.addClientSubscription(parseWebsocket.clientId, request.requestId);\n\n      client.pushSubscribe(request.requestId);\n\n      logger.verbose(\n        `Create client ${parseWebsocket.clientId} new subscription: ${request.requestId}`\n      );\n      logger.verbose('Current client number: %d', this.clients.size);\n      runLiveQueryEventHandlers({\n        client,\n        event: 'subscribe',\n        clients: this.clients.size,\n        subscriptions: this.subscriptions.size,\n        sessionToken: request.sessionToken,\n        useMasterKey: client.hasMasterKey,\n        installationId: client.installationId,\n      });\n    } catch (e) {\n      const error = resolveError(e);\n      Client.pushError(parseWebsocket, error.code, error.message, false, request.requestId);\n      logger.error(\n        `Failed running beforeSubscribe on ${className} for session ${request.sessionToken} with:\\n Error: ` +\n          JSON.stringify(error)\n      );\n    }\n  }\n\n  _handleUpdateSubscription(parseWebsocket: any, request: any): any {\n    this._handleUnsubscribe(parseWebsocket, request, false);\n    this._handleSubscribe(parseWebsocket, request);\n  }\n\n  _handleUnsubscribe(parseWebsocket: any, request: any, notifyClient: boolean = true): any {\n    // If we can not find this client, return error to client\n    if (!Object.prototype.hasOwnProperty.call(parseWebsocket, 'clientId')) {\n      Client.pushError(\n        parseWebsocket,\n        2,\n        'Can not find this client, make sure you connect to server before unsubscribing'\n      );\n      logger.error(\n        'Can not find this client, make sure you connect to server before unsubscribing'\n      );\n      return;\n    }\n    const requestId = request.requestId;\n    const client = this.clients.get(parseWebsocket.clientId);\n    if (typeof client === 'undefined') {\n      Client.pushError(\n        parseWebsocket,\n        2,\n        'Cannot find client with clientId ' +\n          parseWebsocket.clientId +\n          '. Make sure you connect to live query server before unsubscribing.'\n      );\n      logger.error('Can not find this client ' + parseWebsocket.clientId);\n      return;\n    }\n\n    const subscriptionInfo = client.getSubscriptionInfo(requestId);\n    if (typeof subscriptionInfo === 'undefined') {\n      Client.pushError(\n        parseWebsocket,\n        2,\n        'Cannot find subscription with clientId ' +\n          parseWebsocket.clientId +\n          ' subscriptionId ' +\n          requestId +\n          '. Make sure you subscribe to live query server before unsubscribing.'\n      );\n      logger.error(\n        'Can not find subscription with clientId ' +\n          parseWebsocket.clientId +\n          ' subscriptionId ' +\n          requestId\n      );\n      return;\n    }\n\n    // Remove subscription from client\n    client.deleteSubscriptionInfo(requestId);\n    // Remove client from subscription\n    const subscription = subscriptionInfo.subscription;\n    const className = subscription.className;\n    subscription.deleteClientSubscription(parseWebsocket.clientId, requestId);\n    // If there is no client which is subscribing this subscription, remove it from subscriptions\n    const classSubscriptions = this.subscriptions.get(className);\n    if (!subscription.hasSubscribingClient()) {\n      classSubscriptions.delete(subscription.hash);\n    }\n    // If there is no subscriptions under this class, remove it from subscriptions\n    if (classSubscriptions.size === 0) {\n      this.subscriptions.delete(className);\n    }\n    runLiveQueryEventHandlers({\n      client,\n      event: 'unsubscribe',\n      clients: this.clients.size,\n      subscriptions: this.subscriptions.size,\n      sessionToken: subscriptionInfo.sessionToken,\n      useMasterKey: client.hasMasterKey,\n      installationId: client.installationId,\n    });\n\n    if (!notifyClient) {\n      return;\n    }\n\n    client.pushUnsubscribe(request.requestId);\n\n    logger.verbose(\n      `Delete client: ${parseWebsocket.clientId} | subscription: ${request.requestId}`\n    );\n  }\n}\n\nexport { ParseLiveQueryServer };\n"], "fixing_code": ["'use strict';\nconst UserController = require('../lib/Controllers/UserController').UserController;\nconst Config = require('../lib/Config');\nconst validatorFail = () => {\n  throw 'you are not authorized';\n};\n\ndescribe('ParseLiveQuery', function () {\n  it('access user on onLiveQueryEvent disconnect', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.CoreManager.getLiveQueryController().setDefaultLiveQueryClient(null);\n    const requestedUser = new Parse.User();\n    requestedUser.setUsername('username');\n    requestedUser.setPassword('password');\n    Parse.Cloud.onLiveQueryEvent(req => {\n      const { event, sessionToken } = req;\n      if (event === 'ws_disconnect') {\n        Parse.Cloud._removeAllHooks();\n        expect(sessionToken).toBeDefined();\n        expect(sessionToken).toBe(requestedUser.getSessionToken());\n        done();\n      }\n    });\n    await requestedUser.signUp();\n    const query = new Parse.Query(TestObject);\n    await query.subscribe();\n    const client = await Parse.CoreManager.getLiveQueryController().getDefaultLiveQueryClient();\n    client.close();\n  });\n\n  it('can subscribe to query', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n\n  it('can use patterns in className', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['Test.*'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n\n  it('expect afterEvent create', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('create');\n      expect(req.user).toBeUndefined();\n      expect(req.object.get('foo')).toBe('bar');\n    });\n\n    const query = new Parse.Query(TestObject);\n    const subscription = await query.subscribe();\n    subscription.on('create', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n  });\n\n  it('expect afterEvent payload', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('update');\n      expect(req.user).toBeUndefined();\n      expect(req.object.get('foo')).toBe('bar');\n      expect(req.original.get('foo')).toBeUndefined();\n      done();\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    await query.subscribe();\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n\n  it('expect afterEvent enter', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('enter');\n      expect(req.user).toBeUndefined();\n      expect(req.object.get('foo')).toBe('bar');\n      expect(req.original.get('foo')).toBeUndefined();\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('foo', 'bar');\n    const subscription = await query.subscribe();\n    subscription.on('enter', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n\n    object.set('foo', 'bar');\n    await object.save();\n  });\n\n  it('expect afterEvent leave', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('leave');\n      expect(req.user).toBeUndefined();\n      expect(req.object.get('foo')).toBeUndefined();\n      expect(req.original.get('foo')).toBe('bar');\n    });\n\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('foo', 'bar');\n    const subscription = await query.subscribe();\n    subscription.on('leave', object => {\n      expect(object.get('foo')).toBeUndefined();\n      done();\n    });\n\n    object.unset('foo');\n    await object.save();\n  });\n\n  it('expect afterEvent delete', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      expect(req.event).toBe('delete');\n      expect(req.user).toBeUndefined();\n      req.object.set('foo', 'bar');\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n\n    const subscription = await query.subscribe();\n    subscription.on('delete', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n\n    await object.destroy();\n  });\n\n  it('can handle afterEvent modification', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      const current = req.object;\n      current.set('foo', 'yolo');\n\n      const original = req.original;\n      original.set('yolo', 'foo');\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', (object, original) => {\n      expect(object.get('foo')).toBe('yolo');\n      expect(original.get('yolo')).toBe('foo');\n      done();\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n\n  it('can return different object in afterEvent', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      const object = new Parse.Object('Yolo');\n      req.object = object;\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', object => {\n      expect(object.className).toBe('Yolo');\n      done();\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n\n  it('can handle afterEvent throw', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.afterLiveQueryEvent('TestObject', () => {\n      throw 'Throw error from LQ afterEvent.';\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', () => {\n      fail('update should not have been called.');\n    });\n    subscription.on('error', e => {\n      expect(e).toBe('Throw error from LQ afterEvent.');\n      done();\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n\n  it('can log on afterLiveQueryEvent throw', async () => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    const logger = require('../lib/logger').logger;\n    spyOn(logger, 'error').and.callFake(() => {});\n\n    let session = undefined;\n    Parse.Cloud.afterLiveQueryEvent('TestObject', ({ sessionToken }) => {\n      session = sessionToken;\n      /* eslint-disable no-undef */\n      foo.bar();\n      /* eslint-enable no-undef */\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    object.set({ foo: 'bar' });\n    await object.save();\n    await new Promise(resolve => subscription.on('error', resolve));\n    expect(logger.error).toHaveBeenCalledWith(\n      `Failed running afterLiveQueryEvent on class TestObject for event update with session ${session} with:\\n Error: {\"message\":\"foo is not defined\",\"code\":141}`\n    );\n  });\n\n  it('can handle afterEvent sendEvent to false', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.afterLiveQueryEvent('TestObject', req => {\n      const current = req.object;\n      const original = req.original;\n\n      setTimeout(() => {\n        done();\n      }, 2000);\n\n      if (current.get('foo') != original.get('foo')) {\n        req.sendEvent = false;\n      }\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', () => {\n      fail('update should not have been called.');\n    });\n    subscription.on('error', () => {\n      fail('error should not have been called.');\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n\n  it('can handle afterEvent set pointers', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    const secondObject = new Parse.Object('Test2');\n    secondObject.set('foo', 'bar');\n    await secondObject.save();\n\n    Parse.Cloud.afterLiveQueryEvent('TestObject', async ({ object }) => {\n      const query = new Parse.Query('Test2');\n      const obj = await query.first();\n      object.set('obj', obj);\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', object => {\n      expect(object.get('obj')).toBeDefined();\n      expect(object.get('obj').get('foo')).toBe('bar');\n      done();\n    });\n    subscription.on('error', () => {\n      fail('error should not have been called.');\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n\n  it('can handle async afterEvent modification', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const parent = new TestObject();\n    const child = new TestObject();\n    child.set('bar', 'foo');\n    await Parse.Object.saveAll([parent, child]);\n\n    Parse.Cloud.afterLiveQueryEvent('TestObject', async req => {\n      const current = req.object;\n      const pointer = current.get('child');\n      await pointer.fetch();\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', parent.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', object => {\n      expect(object.get('child')).toBeDefined();\n      expect(object.get('child').get('bar')).toBe('foo');\n      done();\n    });\n    parent.set('child', child);\n    await parent.save();\n  });\n\n  it('can handle beforeConnect / beforeSubscribe hooks', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.beforeSubscribe('TestObject', req => {\n      expect(req.op).toBe('subscribe');\n      expect(req.requestId).toBe(1);\n      expect(req.query).toBeDefined();\n      expect(req.user).toBeUndefined();\n    });\n\n    Parse.Cloud.beforeConnect(req => {\n      expect(req.event).toBe('connect');\n      expect(req.clients).toBe(0);\n      expect(req.subscriptions).toBe(0);\n      expect(req.useMasterKey).toBe(false);\n      expect(req.installationId).toBeDefined();\n      expect(req.user).toBeUndefined();\n      expect(req.client).toBeDefined();\n    });\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('update', object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n  });\n\n  it('can handle beforeConnect validation function', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.beforeConnect(() => {}, validatorFail);\n    let complete = false;\n    Parse.LiveQuery.on('error', error => {\n      Parse.LiveQuery.removeAllListeners('error');\n      if (complete) {\n        return;\n      }\n      complete = true;\n      expect(error).toBe('you are not authorized');\n      done();\n    });\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    await query.subscribe();\n  });\n\n  it('can handle beforeSubscribe validation function', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.beforeSubscribe(TestObject, () => {}, validatorFail);\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('error', error => {\n      expect(error).toBe('you are not authorized');\n      done();\n    });\n  });\n\n  it('can handle afterEvent validation function', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.afterLiveQueryEvent('TestObject', () => {}, validatorFail);\n\n    const query = new Parse.Query(TestObject);\n    const subscription = await query.subscribe();\n    subscription.on('error', error => {\n      expect(error).toBe('you are not authorized');\n      done();\n    });\n\n    const object = new TestObject();\n    object.set('foo', 'bar');\n    await object.save();\n  });\n\n  it('can handle beforeConnect error', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.beforeConnect(() => {\n      throw new Error('You shall not pass!');\n    });\n    Parse.LiveQuery.on('error', error => {\n      Parse.LiveQuery.removeAllListeners('error');\n      expect(error).toBe('You shall not pass!');\n      done();\n    });\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    await query.subscribe();\n  });\n\n  it('can log on beforeConnect throw', async () => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n\n    const logger = require('../lib/logger').logger;\n    spyOn(logger, 'error').and.callFake(() => {});\n    let token = undefined;\n    Parse.Cloud.beforeConnect(({ sessionToken }) => {\n      token = sessionToken;\n      /* eslint-disable no-undef */\n      foo.bar();\n      /* eslint-enable no-undef */\n    });\n    new Parse.Query(TestObject).subscribe();\n    await new Promise(resolve => Parse.LiveQuery.on('error', resolve));\n    Parse.LiveQuery.removeAllListeners('error');\n    expect(logger.error).toHaveBeenCalledWith(\n      `Failed running beforeConnect for session ${token} with:\\n Error: {\"message\":\"foo is not defined\",\"code\":141}`\n    );\n  });\n\n  it('can handle beforeSubscribe error', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    Parse.Cloud.beforeSubscribe(TestObject, () => {\n      throw new Error('You shall not subscribe!');\n    });\n    Parse.LiveQuery.on('error', error => {\n      expect(error).toBe('You shall not subscribe!');\n    });\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n    subscription.on('error', error => {\n      Parse.LiveQuery.removeAllListeners('error');\n      expect(error).toBe('You shall not subscribe!');\n      done();\n    });\n  });\n\n  it('can log on beforeSubscribe error', async () => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n\n    const logger = require('../lib/logger').logger;\n    spyOn(logger, 'error').and.callFake(() => {});\n\n    Parse.Cloud.beforeSubscribe(TestObject, () => {\n      /* eslint-disable no-undef */\n      foo.bar();\n      /* eslint-enable no-undef */\n    });\n\n    const query = new Parse.Query(TestObject);\n    const subscription = await query.subscribe();\n    await new Promise(resolve => subscription.on('error', resolve));\n\n    expect(logger.error).toHaveBeenCalledWith(\n      `Failed running beforeSubscribe on TestObject for session undefined with:\\n Error: {\"message\":\"foo is not defined\",\"code\":141}`\n    );\n  });\n\n  it('can handle mutate beforeSubscribe query', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.beforeSubscribe(TestObject, request => {\n      const query = request.query;\n      query.equalTo('yolo', 'abc');\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n\n    subscription.on('update', () => {\n      fail();\n    });\n    object.set({ foo: 'bar' });\n    await object.save();\n    setTimeout(async () => {\n      done();\n    }, 1000);\n  });\n\n  it('can return a new beforeSubscribe query', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.beforeSubscribe(TestObject, request => {\n      const query = new Parse.Query(TestObject);\n      query.equalTo('foo', 'yolo');\n      request.query = query;\n    });\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('foo', 'bar');\n    const subscription = await query.subscribe();\n\n    subscription.on('create', object => {\n      expect(object.get('foo')).toBe('yolo');\n      done();\n    });\n    const object = new TestObject();\n    object.set({ foo: 'yolo' });\n    await object.save();\n  });\n\n  it('can handle select beforeSubscribe query', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    Parse.Cloud.beforeSubscribe(TestObject, request => {\n      const query = request.query;\n      query.select('yolo');\n    });\n\n    const object = new TestObject();\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n\n    subscription.on('update', object => {\n      expect(object.get('foo')).toBeUndefined();\n      expect(object.get('yolo')).toBe('abc');\n      done();\n    });\n    object.set({ foo: 'bar', yolo: 'abc' });\n    await object.save();\n  });\n\n  it('LiveQuery with ACL', async () => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['Chat'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n    const user = new Parse.User();\n    user.setUsername('username');\n    user.setPassword('password');\n    await user.signUp();\n\n    const calls = {\n      beforeConnect(req) {\n        expect(req.event).toBe('connect');\n        expect(req.clients).toBe(0);\n        expect(req.subscriptions).toBe(0);\n        expect(req.useMasterKey).toBe(false);\n        expect(req.installationId).toBeDefined();\n        expect(req.client).toBeDefined();\n      },\n      beforeSubscribe(req) {\n        expect(req.op).toBe('subscribe');\n        expect(req.requestId).toBe(1);\n        expect(req.query).toBeDefined();\n        expect(req.user).toBeDefined();\n      },\n      afterLiveQueryEvent(req) {\n        expect(req.user).toBeDefined();\n        expect(req.object.get('foo')).toBe('bar');\n      },\n      create(object) {\n        expect(object.get('foo')).toBe('bar');\n      },\n      delete(object) {\n        expect(object.get('foo')).toBe('bar');\n      },\n    };\n    for (const key in calls) {\n      spyOn(calls, key).and.callThrough();\n    }\n    Parse.Cloud.beforeConnect(calls.beforeConnect);\n    Parse.Cloud.beforeSubscribe('Chat', calls.beforeSubscribe);\n    Parse.Cloud.afterLiveQueryEvent('Chat', calls.afterLiveQueryEvent);\n\n    const chatQuery = new Parse.Query('Chat');\n    const subscription = await chatQuery.subscribe();\n    subscription.on('create', calls.create);\n    subscription.on('delete', calls.delete);\n    const object = new Parse.Object('Chat');\n    const acl = new Parse.ACL(user);\n    object.setACL(acl);\n    object.set({ foo: 'bar' });\n    await object.save();\n    await object.destroy();\n    await new Promise(resolve => setTimeout(resolve, 200));\n    for (const key in calls) {\n      expect(calls[key]).toHaveBeenCalled();\n    }\n  });\n\n  it('liveQuery on Session class', async done => {\n    await reconfigureServer({\n      liveQuery: { classNames: [Parse.Session] },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n\n    const user = new Parse.User();\n    user.setUsername('username');\n    user.setPassword('password');\n    await user.signUp();\n\n    const query = new Parse.Query(Parse.Session);\n    const subscription = await query.subscribe();\n\n    subscription.on('create', async obj => {\n      await new Promise(resolve => setTimeout(resolve, 200));\n      expect(obj.get('user').id).toBe(user.id);\n      expect(obj.get('createdWith')).toEqual({ action: 'login', authProvider: 'password' });\n      expect(obj.get('expiresAt')).toBeInstanceOf(Date);\n      expect(obj.get('installationId')).toBeDefined();\n      expect(obj.get('createdAt')).toBeInstanceOf(Date);\n      expect(obj.get('updatedAt')).toBeInstanceOf(Date);\n      done();\n    });\n\n    await Parse.User.logIn('username', 'password');\n  });\n\n  it('prevent liveQuery on Session class when not logged in', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: [Parse.Session],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n\n    Parse.LiveQuery.on('error', error => {\n      expect(error).toBe('Invalid session token');\n    });\n    const query = new Parse.Query(Parse.Session);\n    const subscription = await query.subscribe();\n    subscription.on('error', error => {\n      Parse.LiveQuery.removeAllListeners('error');\n      expect(error).toBe('Invalid session token');\n      done();\n    });\n  });\n\n  it('handle invalid websocket payload length', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n      websocketTimeout: 100,\n    });\n    const object = new TestObject();\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', object.id);\n    const subscription = await query.subscribe();\n\n    // All control frames must have a payload length of 125 bytes or less.\n    // https://tools.ietf.org/html/rfc6455#section-5.5\n    //\n    // 0x89 = 10001001 = ping\n    // 0xfe = 11111110 = first bit is masking the remaining 7 are 1111110 or 126 the payload length\n    // https://tools.ietf.org/html/rfc6455#section-5.2\n    const client = await Parse.CoreManager.getLiveQueryController().getDefaultLiveQueryClient();\n    client.socket._socket.write(Buffer.from([0x89, 0xfe]));\n\n    subscription.on('update', async object => {\n      expect(object.get('foo')).toBe('bar');\n      done();\n    });\n    // Wait for Websocket timeout to reconnect\n    setTimeout(async () => {\n      object.set({ foo: 'bar' });\n      await object.save();\n    }, 1000);\n  });\n\n  it('should execute live query update on email validation', async done => {\n    const emailAdapter = {\n      sendVerificationEmail: () => {},\n      sendPasswordResetEmail: () => Promise.resolve(),\n      sendMail: () => {},\n    };\n\n    await reconfigureServer({\n      liveQuery: {\n        classNames: [Parse.User],\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n      websocketTimeout: 100,\n      appName: 'liveQueryEmailValidation',\n      verifyUserEmails: true,\n      emailAdapter: emailAdapter,\n      emailVerifyTokenValidityDuration: 20, // 0.5 second\n      publicServerURL: 'http://localhost:8378/1',\n    }).then(() => {\n      const user = new Parse.User();\n      user.set('password', 'asdf');\n      user.set('email', 'asdf@example.com');\n      user.set('username', 'zxcv');\n      user\n        .signUp()\n        .then(() => {\n          const config = Config.get('test');\n          return config.database.find('_User', {\n            username: 'zxcv',\n          });\n        })\n        .then(async results => {\n          const foundUser = results[0];\n          const query = new Parse.Query('_User');\n          query.equalTo('objectId', foundUser.objectId);\n          const subscription = await query.subscribe();\n\n          subscription.on('update', async object => {\n            expect(object).toBeDefined();\n            expect(object.get('emailVerified')).toBe(true);\n            done();\n          });\n\n          const userController = new UserController(emailAdapter, 'test', {\n            verifyUserEmails: true,\n          });\n          userController.verifyEmail(foundUser.username, foundUser._email_verify_token);\n        });\n    });\n  });\n\n  it('should not broadcast event to client with invalid session token - avisory GHSA-2xm2-xj2q-qgpj', async done => {\n    await reconfigureServer({\n      liveQuery: {\n        classNames: ['TestObject'],\n      },\n      liveQueryServerOptions: {\n        cacheTimeout: 100,\n      },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n      cacheTTL: 100,\n    });\n    const user = new Parse.User();\n    user.setUsername('username');\n    user.setPassword('password');\n    await user.signUp();\n    const obj1 = new Parse.Object('TestObject');\n    const obj1ACL = new Parse.ACL();\n    obj1ACL.setPublicReadAccess(false);\n    obj1ACL.setReadAccess(user, true);\n    obj1.setACL(obj1ACL);\n    const obj2 = new Parse.Object('TestObject');\n    const obj2ACL = new Parse.ACL();\n    obj2ACL.setPublicReadAccess(false);\n    obj2ACL.setReadAccess(user, true);\n    obj2.setACL(obj2ACL);\n    const query = new Parse.Query('TestObject');\n    const subscription = await query.subscribe();\n    subscription.on('create', obj => {\n      if (obj.id !== obj1.id) {\n        done.fail('should not fire');\n      }\n    });\n    await obj1.save();\n    await Parse.User.logOut();\n    await new Promise(resolve => setTimeout(resolve, 200));\n    await obj2.save();\n    await new Promise(resolve => setTimeout(resolve, 200));\n    done();\n  });\n\n  it('should strip out session token in LiveQuery', async () => {\n    await reconfigureServer({\n      liveQuery: { classNames: ['_User'] },\n      startLiveQueryServer: true,\n      verbose: false,\n      silent: true,\n    });\n\n    const user = new Parse.User();\n    user.setUsername('username');\n    user.setPassword('password');\n    user.set('foo', 'bar');\n\n    const query = new Parse.Query(Parse.User);\n    query.equalTo('foo', 'bar');\n    const subscription = await query.subscribe();\n\n    const events = ['create', 'update', 'enter', 'leave', 'delete'];\n    const response = (obj, prev) => {\n      expect(obj.get('sessionToken')).toBeUndefined();\n      expect(obj.sessionToken).toBeUndefined();\n      expect(prev && prev.sessionToken).toBeUndefined();\n      if (prev && prev.get) {\n        expect(prev.get('sessionToken')).toBeUndefined();\n      }\n    };\n    const calls = {};\n    for (const key of events) {\n      calls[key] = response;\n      spyOn(calls, key).and.callThrough();\n      subscription.on(key, calls[key]);\n    }\n    await user.signUp();\n    user.unset('foo');\n    await user.save();\n    user.set('foo', 'bar');\n    await user.save();\n    user.set('yolo', 'bar');\n    await user.save();\n    await user.destroy();\n    await new Promise(resolve => setTimeout(resolve, 10));\n    for (const key of events) {\n      expect(calls[key]).toHaveBeenCalled();\n    }\n  });\n\n  it('should strip out protected fields', async () => {\n    await reconfigureServer({\n      liveQuery: { classNames: ['Test'] },\n      startLiveQueryServer: true,\n    });\n    const obj1 = new Parse.Object('Test');\n    obj1.set('foo', 'foo');\n    obj1.set('bar', 'bar');\n    obj1.set('qux', 'qux');\n    await obj1.save();\n    const config = Config.get(Parse.applicationId);\n    const schemaController = await config.database.loadSchema();\n    await schemaController.updateClass(\n      'Test',\n      {},\n      {\n        get: { '*': true },\n        find: { '*': true },\n        update: { '*': true },\n        protectedFields: {\n          '*': ['foo'],\n        },\n      }\n    );\n    const object = await obj1.fetch();\n    expect(object.get('foo')).toBe(undefined);\n    expect(object.get('bar')).toBeDefined();\n    expect(object.get('qux')).toBeDefined();\n\n    const subscription = await new Parse.Query('Test').subscribe();\n    await Promise.all([\n      new Promise(resolve => {\n        subscription.on('update', (obj, original) => {\n          expect(obj.get('foo')).toBe(undefined);\n          expect(obj.get('bar')).toBeDefined();\n          expect(obj.get('qux')).toBeDefined();\n          expect(original.get('foo')).toBe(undefined);\n          expect(original.get('bar')).toBeDefined();\n          expect(original.get('qux')).toBeDefined();\n          resolve();\n        });\n      }),\n      obj1.save({ foo: 'abc' }),\n    ]);\n  });\n\n  afterEach(async function (done) {\n    const client = await Parse.CoreManager.getLiveQueryController().getDefaultLiveQueryClient();\n    client.close();\n    // Wait for live query client to disconnect\n    setTimeout(() => {\n      done();\n    }, 1000);\n  });\n});\n", "\ufeff// @flow\n// A database adapter that works with data exported from the hosted\n// Parse database.\n\n// @flow-disable-next\nimport { Parse } from 'parse/node';\n// @flow-disable-next\nimport _ from 'lodash';\n// @flow-disable-next\nimport intersect from 'intersect';\n// @flow-disable-next\nimport deepcopy from 'deepcopy';\nimport logger from '../logger';\nimport Utils from '../Utils';\nimport * as SchemaController from './SchemaController';\nimport { StorageAdapter } from '../Adapters/Storage/StorageAdapter';\nimport MongoStorageAdapter from '../Adapters/Storage/Mongo/MongoStorageAdapter';\nimport PostgresStorageAdapter from '../Adapters/Storage/Postgres/PostgresStorageAdapter';\nimport SchemaCache from '../Adapters/Cache/SchemaCache';\nimport type { LoadSchemaOptions } from './types';\nimport type { ParseServerOptions } from '../Options';\nimport type { QueryOptions, FullQueryOptions } from '../Adapters/Storage/StorageAdapter';\n\nfunction addWriteACL(query, acl) {\n  const newQuery = _.cloneDeep(query);\n  //Can't be any existing '_wperm' query, we don't allow client queries on that, no need to $and\n  newQuery._wperm = { $in: [null, ...acl] };\n  return newQuery;\n}\n\nfunction addReadACL(query, acl) {\n  const newQuery = _.cloneDeep(query);\n  //Can't be any existing '_rperm' query, we don't allow client queries on that, no need to $and\n  newQuery._rperm = { $in: [null, '*', ...acl] };\n  return newQuery;\n}\n\n// Transforms a REST API formatted ACL object to our two-field mongo format.\nconst transformObjectACL = ({ ACL, ...result }) => {\n  if (!ACL) {\n    return result;\n  }\n\n  result._wperm = [];\n  result._rperm = [];\n\n  for (const entry in ACL) {\n    if (ACL[entry].read) {\n      result._rperm.push(entry);\n    }\n    if (ACL[entry].write) {\n      result._wperm.push(entry);\n    }\n  }\n  return result;\n};\n\nconst specialQuerykeys = [\n  '$and',\n  '$or',\n  '$nor',\n  '_rperm',\n  '_wperm',\n  '_perishable_token',\n  '_email_verify_token',\n  '_email_verify_token_expires_at',\n  '_account_lockout_expires_at',\n  '_failed_login_count',\n];\n\nconst isSpecialQueryKey = key => {\n  return specialQuerykeys.indexOf(key) >= 0;\n};\n\nconst validateQuery = (query: any): void => {\n  if (query.ACL) {\n    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Cannot query on ACL.');\n  }\n\n  if (query.$or) {\n    if (query.$or instanceof Array) {\n      query.$or.forEach(validateQuery);\n    } else {\n      throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Bad $or format - use an array value.');\n    }\n  }\n\n  if (query.$and) {\n    if (query.$and instanceof Array) {\n      query.$and.forEach(validateQuery);\n    } else {\n      throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Bad $and format - use an array value.');\n    }\n  }\n\n  if (query.$nor) {\n    if (query.$nor instanceof Array && query.$nor.length > 0) {\n      query.$nor.forEach(validateQuery);\n    } else {\n      throw new Parse.Error(\n        Parse.Error.INVALID_QUERY,\n        'Bad $nor format - use an array of at least 1 value.'\n      );\n    }\n  }\n\n  Object.keys(query).forEach(key => {\n    if (query && query[key] && query[key].$regex) {\n      if (typeof query[key].$options === 'string') {\n        if (!query[key].$options.match(/^[imxs]+$/)) {\n          throw new Parse.Error(\n            Parse.Error.INVALID_QUERY,\n            `Bad $options value for query: ${query[key].$options}`\n          );\n        }\n      }\n    }\n    if (!isSpecialQueryKey(key) && !key.match(/^[a-zA-Z][a-zA-Z0-9_\\.]*$/)) {\n      throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, `Invalid key name: ${key}`);\n    }\n  });\n};\n\n// Filters out any data that shouldn't be on this REST-formatted object.\nconst filterSensitiveData = (\n  isMaster: boolean,\n  aclGroup: any[],\n  auth: any,\n  operation: any,\n  schema: SchemaController.SchemaController | any,\n  className: string,\n  protectedFields: null | Array<any>,\n  object: any\n) => {\n  let userId = null;\n  if (auth && auth.user) userId = auth.user.id;\n\n  // replace protectedFields when using pointer-permissions\n  const perms =\n    schema && schema.getClassLevelPermissions ? schema.getClassLevelPermissions(className) : {};\n  if (perms) {\n    const isReadOperation = ['get', 'find'].indexOf(operation) > -1;\n\n    if (isReadOperation && perms.protectedFields) {\n      // extract protectedFields added with the pointer-permission prefix\n      const protectedFieldsPointerPerm = Object.keys(perms.protectedFields)\n        .filter(key => key.startsWith('userField:'))\n        .map(key => {\n          return { key: key.substring(10), value: perms.protectedFields[key] };\n        });\n\n      const newProtectedFields: Array<string>[] = [];\n      let overrideProtectedFields = false;\n\n      // check if the object grants the current user access based on the extracted fields\n      protectedFieldsPointerPerm.forEach(pointerPerm => {\n        let pointerPermIncludesUser = false;\n        const readUserFieldValue = object[pointerPerm.key];\n        if (readUserFieldValue) {\n          if (Array.isArray(readUserFieldValue)) {\n            pointerPermIncludesUser = readUserFieldValue.some(\n              user => user.objectId && user.objectId === userId\n            );\n          } else {\n            pointerPermIncludesUser =\n              readUserFieldValue.objectId && readUserFieldValue.objectId === userId;\n          }\n        }\n\n        if (pointerPermIncludesUser) {\n          overrideProtectedFields = true;\n          newProtectedFields.push(pointerPerm.value);\n        }\n      });\n\n      // if at least one pointer-permission affected the current user\n      // intersect vs protectedFields from previous stage (@see addProtectedFields)\n      // Sets theory (intersections): A x (B x C) == (A x B) x C\n      if (overrideProtectedFields && protectedFields) {\n        newProtectedFields.push(protectedFields);\n      }\n      // intersect all sets of protectedFields\n      newProtectedFields.forEach(fields => {\n        if (fields) {\n          // if there're no protctedFields by other criteria ( id / role / auth)\n          // then we must intersect each set (per userField)\n          if (!protectedFields) {\n            protectedFields = fields;\n          } else {\n            protectedFields = protectedFields.filter(v => fields.includes(v));\n          }\n        }\n      });\n    }\n  }\n\n  const isUserClass = className === '_User';\n\n  /* special treat for the user class: don't filter protectedFields if currently loggedin user is\n  the retrieved user */\n  if (!(isUserClass && userId && object.objectId === userId)) {\n    protectedFields && protectedFields.forEach(k => delete object[k]);\n\n    // fields not requested by client (excluded),\n    //but were needed to apply protecttedFields\n    perms.protectedFields &&\n      perms.protectedFields.temporaryKeys &&\n      perms.protectedFields.temporaryKeys.forEach(k => delete object[k]);\n  }\n\n  if (!isUserClass) {\n    return object;\n  }\n\n  object.password = object._hashed_password;\n  delete object._hashed_password;\n\n  delete object.sessionToken;\n\n  if (isMaster) {\n    return object;\n  }\n  delete object._email_verify_token;\n  delete object._perishable_token;\n  delete object._perishable_token_expires_at;\n  delete object._tombstone;\n  delete object._email_verify_token_expires_at;\n  delete object._failed_login_count;\n  delete object._account_lockout_expires_at;\n  delete object._password_changed_at;\n  delete object._password_history;\n\n  if (aclGroup.indexOf(object.objectId) > -1) {\n    return object;\n  }\n  delete object.authData;\n  return object;\n};\n\n// Runs an update on the database.\n// Returns a promise for an object with the new values for field\n// modifications that don't know their results ahead of time, like\n// 'increment'.\n// Options:\n//   acl:  a list of strings. If the object to be updated has an ACL,\n//         one of the provided strings must provide the caller with\n//         write permissions.\nconst specialKeysForUpdate = [\n  '_hashed_password',\n  '_perishable_token',\n  '_email_verify_token',\n  '_email_verify_token_expires_at',\n  '_account_lockout_expires_at',\n  '_failed_login_count',\n  '_perishable_token_expires_at',\n  '_password_changed_at',\n  '_password_history',\n];\n\nconst isSpecialUpdateKey = key => {\n  return specialKeysForUpdate.indexOf(key) >= 0;\n};\n\nfunction joinTableName(className, key) {\n  return `_Join:${key}:${className}`;\n}\n\nconst flattenUpdateOperatorsForCreate = object => {\n  for (const key in object) {\n    if (object[key] && object[key].__op) {\n      switch (object[key].__op) {\n        case 'Increment':\n          if (typeof object[key].amount !== 'number') {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = object[key].amount;\n          break;\n        case 'Add':\n          if (!(object[key].objects instanceof Array)) {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = object[key].objects;\n          break;\n        case 'AddUnique':\n          if (!(object[key].objects instanceof Array)) {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = object[key].objects;\n          break;\n        case 'Remove':\n          if (!(object[key].objects instanceof Array)) {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = [];\n          break;\n        case 'Delete':\n          delete object[key];\n          break;\n        default:\n          throw new Parse.Error(\n            Parse.Error.COMMAND_UNAVAILABLE,\n            `The ${object[key].__op} operator is not supported yet.`\n          );\n      }\n    }\n  }\n};\n\nconst transformAuthData = (className, object, schema) => {\n  if (object.authData && className === '_User') {\n    Object.keys(object.authData).forEach(provider => {\n      const providerData = object.authData[provider];\n      const fieldName = `_auth_data_${provider}`;\n      if (providerData == null) {\n        object[fieldName] = {\n          __op: 'Delete',\n        };\n      } else {\n        object[fieldName] = providerData;\n        schema.fields[fieldName] = { type: 'Object' };\n      }\n    });\n    delete object.authData;\n  }\n};\n// Transforms a Database format ACL to a REST API format ACL\nconst untransformObjectACL = ({ _rperm, _wperm, ...output }) => {\n  if (_rperm || _wperm) {\n    output.ACL = {};\n\n    (_rperm || []).forEach(entry => {\n      if (!output.ACL[entry]) {\n        output.ACL[entry] = { read: true };\n      } else {\n        output.ACL[entry]['read'] = true;\n      }\n    });\n\n    (_wperm || []).forEach(entry => {\n      if (!output.ACL[entry]) {\n        output.ACL[entry] = { write: true };\n      } else {\n        output.ACL[entry]['write'] = true;\n      }\n    });\n  }\n  return output;\n};\n\n/**\n * When querying, the fieldName may be compound, extract the root fieldName\n *     `temperature.celsius` becomes `temperature`\n * @param {string} fieldName that may be a compound field name\n * @returns {string} the root name of the field\n */\nconst getRootFieldName = (fieldName: string): string => {\n  return fieldName.split('.')[0];\n};\n\nconst relationSchema = {\n  fields: { relatedId: { type: 'String' }, owningId: { type: 'String' } },\n};\n\nclass DatabaseController {\n  adapter: StorageAdapter;\n  schemaCache: any;\n  schemaPromise: ?Promise<SchemaController.SchemaController>;\n  _transactionalSession: ?any;\n  options: ParseServerOptions;\n  idempotencyOptions: any;\n\n  constructor(adapter: StorageAdapter, options: ParseServerOptions) {\n    this.adapter = adapter;\n    this.options = options || {};\n    this.idempotencyOptions = this.options.idempotencyOptions || {};\n    // Prevent mutable this.schema, otherwise one request could use\n    // multiple schemas, so instead use loadSchema to get a schema.\n    this.schemaPromise = null;\n    this._transactionalSession = null;\n    this.options = options;\n  }\n\n  collectionExists(className: string): Promise<boolean> {\n    return this.adapter.classExists(className);\n  }\n\n  purgeCollection(className: string): Promise<void> {\n    return this.loadSchema()\n      .then(schemaController => schemaController.getOneSchema(className))\n      .then(schema => this.adapter.deleteObjectsByQuery(className, schema, {}));\n  }\n\n  validateClassName(className: string): Promise<void> {\n    if (!SchemaController.classNameIsValid(className)) {\n      return Promise.reject(\n        new Parse.Error(Parse.Error.INVALID_CLASS_NAME, 'invalid className: ' + className)\n      );\n    }\n    return Promise.resolve();\n  }\n\n  // Returns a promise for a schemaController.\n  loadSchema(\n    options: LoadSchemaOptions = { clearCache: false }\n  ): Promise<SchemaController.SchemaController> {\n    if (this.schemaPromise != null) {\n      return this.schemaPromise;\n    }\n    this.schemaPromise = SchemaController.load(this.adapter, options);\n    this.schemaPromise.then(\n      () => delete this.schemaPromise,\n      () => delete this.schemaPromise\n    );\n    return this.loadSchema(options);\n  }\n\n  loadSchemaIfNeeded(\n    schemaController: SchemaController.SchemaController,\n    options: LoadSchemaOptions = { clearCache: false }\n  ): Promise<SchemaController.SchemaController> {\n    return schemaController ? Promise.resolve(schemaController) : this.loadSchema(options);\n  }\n\n  // Returns a promise for the classname that is related to the given\n  // classname through the key.\n  // TODO: make this not in the DatabaseController interface\n  redirectClassNameForKey(className: string, key: string): Promise<?string> {\n    return this.loadSchema().then(schema => {\n      var t = schema.getExpectedType(className, key);\n      if (t != null && typeof t !== 'string' && t.type === 'Relation') {\n        return t.targetClass;\n      }\n      return className;\n    });\n  }\n\n  // Uses the schema to validate the object (REST API format).\n  // Returns a promise that resolves to the new schema.\n  // This does not update this.schema, because in a situation like a\n  // batch request, that could confuse other users of the schema.\n  validateObject(\n    className: string,\n    object: any,\n    query: any,\n    runOptions: QueryOptions\n  ): Promise<boolean> {\n    let schema;\n    const acl = runOptions.acl;\n    const isMaster = acl === undefined;\n    var aclGroup: string[] = acl || [];\n    return this.loadSchema()\n      .then(s => {\n        schema = s;\n        if (isMaster) {\n          return Promise.resolve();\n        }\n        return this.canAddField(schema, className, object, aclGroup, runOptions);\n      })\n      .then(() => {\n        return schema.validateObject(className, object, query);\n      });\n  }\n\n  update(\n    className: string,\n    query: any,\n    update: any,\n    { acl, many, upsert, addsField }: FullQueryOptions = {},\n    skipSanitization: boolean = false,\n    validateOnly: boolean = false,\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    const originalQuery = query;\n    const originalUpdate = update;\n    // Make a copy of the object, so we don't mutate the incoming data.\n    update = deepcopy(update);\n    var relationUpdates = [];\n    var isMaster = acl === undefined;\n    var aclGroup = acl || [];\n\n    return this.loadSchemaIfNeeded(validSchemaController).then(schemaController => {\n      return (isMaster\n        ? Promise.resolve()\n        : schemaController.validatePermission(className, aclGroup, 'update')\n      )\n        .then(() => {\n          relationUpdates = this.collectRelationUpdates(className, originalQuery.objectId, update);\n          if (!isMaster) {\n            query = this.addPointerPermissions(\n              schemaController,\n              className,\n              'update',\n              query,\n              aclGroup\n            );\n\n            if (addsField) {\n              query = {\n                $and: [\n                  query,\n                  this.addPointerPermissions(\n                    schemaController,\n                    className,\n                    'addField',\n                    query,\n                    aclGroup\n                  ),\n                ],\n              };\n            }\n          }\n          if (!query) {\n            return Promise.resolve();\n          }\n          if (acl) {\n            query = addWriteACL(query, acl);\n          }\n          validateQuery(query);\n          return schemaController\n            .getOneSchema(className, true)\n            .catch(error => {\n              // If the schema doesn't exist, pretend it exists with no fields. This behavior\n              // will likely need revisiting.\n              if (error === undefined) {\n                return { fields: {} };\n              }\n              throw error;\n            })\n            .then(schema => {\n              Object.keys(update).forEach(fieldName => {\n                if (fieldName.match(/^authData\\.([a-zA-Z0-9_]+)\\.id$/)) {\n                  throw new Parse.Error(\n                    Parse.Error.INVALID_KEY_NAME,\n                    `Invalid field name for update: ${fieldName}`\n                  );\n                }\n                const rootFieldName = getRootFieldName(fieldName);\n                if (\n                  !SchemaController.fieldNameIsValid(rootFieldName, className) &&\n                  !isSpecialUpdateKey(rootFieldName)\n                ) {\n                  throw new Parse.Error(\n                    Parse.Error.INVALID_KEY_NAME,\n                    `Invalid field name for update: ${fieldName}`\n                  );\n                }\n              });\n              for (const updateOperation in update) {\n                if (\n                  update[updateOperation] &&\n                  typeof update[updateOperation] === 'object' &&\n                  Object.keys(update[updateOperation]).some(\n                    innerKey => innerKey.includes('$') || innerKey.includes('.')\n                  )\n                ) {\n                  throw new Parse.Error(\n                    Parse.Error.INVALID_NESTED_KEY,\n                    \"Nested keys should not contain the '$' or '.' characters\"\n                  );\n                }\n              }\n              update = transformObjectACL(update);\n              transformAuthData(className, update, schema);\n              if (validateOnly) {\n                return this.adapter.find(className, schema, query, {}).then(result => {\n                  if (!result || !result.length) {\n                    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n                  }\n                  return {};\n                });\n              }\n              if (many) {\n                return this.adapter.updateObjectsByQuery(\n                  className,\n                  schema,\n                  query,\n                  update,\n                  this._transactionalSession\n                );\n              } else if (upsert) {\n                return this.adapter.upsertOneObject(\n                  className,\n                  schema,\n                  query,\n                  update,\n                  this._transactionalSession\n                );\n              } else {\n                return this.adapter.findOneAndUpdate(\n                  className,\n                  schema,\n                  query,\n                  update,\n                  this._transactionalSession\n                );\n              }\n            });\n        })\n        .then((result: any) => {\n          if (!result) {\n            throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n          }\n          if (validateOnly) {\n            return result;\n          }\n          return this.handleRelationUpdates(\n            className,\n            originalQuery.objectId,\n            update,\n            relationUpdates\n          ).then(() => {\n            return result;\n          });\n        })\n        .then(result => {\n          if (skipSanitization) {\n            return Promise.resolve(result);\n          }\n          return this._sanitizeDatabaseResult(originalUpdate, result);\n        });\n    });\n  }\n\n  // Collect all relation-updating operations from a REST-format update.\n  // Returns a list of all relation updates to perform\n  // This mutates update.\n  collectRelationUpdates(className: string, objectId: ?string, update: any) {\n    var ops = [];\n    var deleteMe = [];\n    objectId = update.objectId || objectId;\n\n    var process = (op, key) => {\n      if (!op) {\n        return;\n      }\n      if (op.__op == 'AddRelation') {\n        ops.push({ key, op });\n        deleteMe.push(key);\n      }\n\n      if (op.__op == 'RemoveRelation') {\n        ops.push({ key, op });\n        deleteMe.push(key);\n      }\n\n      if (op.__op == 'Batch') {\n        for (var x of op.ops) {\n          process(x, key);\n        }\n      }\n    };\n\n    for (const key in update) {\n      process(update[key], key);\n    }\n    for (const key of deleteMe) {\n      delete update[key];\n    }\n    return ops;\n  }\n\n  // Processes relation-updating operations from a REST-format update.\n  // Returns a promise that resolves when all updates have been performed\n  handleRelationUpdates(className: string, objectId: string, update: any, ops: any) {\n    var pending = [];\n    objectId = update.objectId || objectId;\n    ops.forEach(({ key, op }) => {\n      if (!op) {\n        return;\n      }\n      if (op.__op == 'AddRelation') {\n        for (const object of op.objects) {\n          pending.push(this.addRelation(key, className, objectId, object.objectId));\n        }\n      }\n\n      if (op.__op == 'RemoveRelation') {\n        for (const object of op.objects) {\n          pending.push(this.removeRelation(key, className, objectId, object.objectId));\n        }\n      }\n    });\n\n    return Promise.all(pending);\n  }\n\n  // Adds a relation.\n  // Returns a promise that resolves successfully iff the add was successful.\n  addRelation(key: string, fromClassName: string, fromId: string, toId: string) {\n    const doc = {\n      relatedId: toId,\n      owningId: fromId,\n    };\n    return this.adapter.upsertOneObject(\n      `_Join:${key}:${fromClassName}`,\n      relationSchema,\n      doc,\n      doc,\n      this._transactionalSession\n    );\n  }\n\n  // Removes a relation.\n  // Returns a promise that resolves successfully iff the remove was\n  // successful.\n  removeRelation(key: string, fromClassName: string, fromId: string, toId: string) {\n    var doc = {\n      relatedId: toId,\n      owningId: fromId,\n    };\n    return this.adapter\n      .deleteObjectsByQuery(\n        `_Join:${key}:${fromClassName}`,\n        relationSchema,\n        doc,\n        this._transactionalSession\n      )\n      .catch(error => {\n        // We don't care if they try to delete a non-existent relation.\n        if (error.code == Parse.Error.OBJECT_NOT_FOUND) {\n          return;\n        }\n        throw error;\n      });\n  }\n\n  // Removes objects matches this query from the database.\n  // Returns a promise that resolves successfully iff the object was\n  // deleted.\n  // Options:\n  //   acl:  a list of strings. If the object to be updated has an ACL,\n  //         one of the provided strings must provide the caller with\n  //         write permissions.\n  destroy(\n    className: string,\n    query: any,\n    { acl }: QueryOptions = {},\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    const isMaster = acl === undefined;\n    const aclGroup = acl || [];\n\n    return this.loadSchemaIfNeeded(validSchemaController).then(schemaController => {\n      return (isMaster\n        ? Promise.resolve()\n        : schemaController.validatePermission(className, aclGroup, 'delete')\n      ).then(() => {\n        if (!isMaster) {\n          query = this.addPointerPermissions(\n            schemaController,\n            className,\n            'delete',\n            query,\n            aclGroup\n          );\n          if (!query) {\n            throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n          }\n        }\n        // delete by query\n        if (acl) {\n          query = addWriteACL(query, acl);\n        }\n        validateQuery(query);\n        return schemaController\n          .getOneSchema(className)\n          .catch(error => {\n            // If the schema doesn't exist, pretend it exists with no fields. This behavior\n            // will likely need revisiting.\n            if (error === undefined) {\n              return { fields: {} };\n            }\n            throw error;\n          })\n          .then(parseFormatSchema =>\n            this.adapter.deleteObjectsByQuery(\n              className,\n              parseFormatSchema,\n              query,\n              this._transactionalSession\n            )\n          )\n          .catch(error => {\n            // When deleting sessions while changing passwords, don't throw an error if they don't have any sessions.\n            if (className === '_Session' && error.code === Parse.Error.OBJECT_NOT_FOUND) {\n              return Promise.resolve({});\n            }\n            throw error;\n          });\n      });\n    });\n  }\n\n  // Inserts an object into the database.\n  // Returns a promise that resolves successfully iff the object saved.\n  create(\n    className: string,\n    object: any,\n    { acl }: QueryOptions = {},\n    validateOnly: boolean = false,\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    // Make a copy of the object, so we don't mutate the incoming data.\n    const originalObject = object;\n    object = transformObjectACL(object);\n\n    object.createdAt = { iso: object.createdAt, __type: 'Date' };\n    object.updatedAt = { iso: object.updatedAt, __type: 'Date' };\n\n    var isMaster = acl === undefined;\n    var aclGroup = acl || [];\n    const relationUpdates = this.collectRelationUpdates(className, null, object);\n\n    return this.validateClassName(className)\n      .then(() => this.loadSchemaIfNeeded(validSchemaController))\n      .then(schemaController => {\n        return (isMaster\n          ? Promise.resolve()\n          : schemaController.validatePermission(className, aclGroup, 'create')\n        )\n          .then(() => schemaController.enforceClassExists(className))\n          .then(() => schemaController.getOneSchema(className, true))\n          .then(schema => {\n            transformAuthData(className, object, schema);\n            flattenUpdateOperatorsForCreate(object);\n            if (validateOnly) {\n              return {};\n            }\n            return this.adapter.createObject(\n              className,\n              SchemaController.convertSchemaToAdapterSchema(schema),\n              object,\n              this._transactionalSession\n            );\n          })\n          .then(result => {\n            if (validateOnly) {\n              return originalObject;\n            }\n            return this.handleRelationUpdates(\n              className,\n              object.objectId,\n              object,\n              relationUpdates\n            ).then(() => {\n              return this._sanitizeDatabaseResult(originalObject, result.ops[0]);\n            });\n          });\n      });\n  }\n\n  canAddField(\n    schema: SchemaController.SchemaController,\n    className: string,\n    object: any,\n    aclGroup: string[],\n    runOptions: QueryOptions\n  ): Promise<void> {\n    const classSchema = schema.schemaData[className];\n    if (!classSchema) {\n      return Promise.resolve();\n    }\n    const fields = Object.keys(object);\n    const schemaFields = Object.keys(classSchema.fields);\n    const newKeys = fields.filter(field => {\n      // Skip fields that are unset\n      if (object[field] && object[field].__op && object[field].__op === 'Delete') {\n        return false;\n      }\n      return schemaFields.indexOf(getRootFieldName(field)) < 0;\n    });\n    if (newKeys.length > 0) {\n      // adds a marker that new field is being adding during update\n      runOptions.addsField = true;\n\n      const action = runOptions.action;\n      return schema.validatePermission(className, aclGroup, 'addField', action);\n    }\n    return Promise.resolve();\n  }\n\n  // Won't delete collections in the system namespace\n  /**\n   * Delete all classes and clears the schema cache\n   *\n   * @param {boolean} fast set to true if it's ok to just delete rows and not indexes\n   * @returns {Promise<void>} when the deletions completes\n   */\n  deleteEverything(fast: boolean = false): Promise<any> {\n    this.schemaPromise = null;\n    SchemaCache.clear();\n    return this.adapter.deleteAllClasses(fast);\n  }\n\n  // Returns a promise for a list of related ids given an owning id.\n  // className here is the owning className.\n  relatedIds(\n    className: string,\n    key: string,\n    owningId: string,\n    queryOptions: QueryOptions\n  ): Promise<Array<string>> {\n    const { skip, limit, sort } = queryOptions;\n    const findOptions = {};\n    if (sort && sort.createdAt && this.adapter.canSortOnJoinTables) {\n      findOptions.sort = { _id: sort.createdAt };\n      findOptions.limit = limit;\n      findOptions.skip = skip;\n      queryOptions.skip = 0;\n    }\n    return this.adapter\n      .find(joinTableName(className, key), relationSchema, { owningId }, findOptions)\n      .then(results => results.map(result => result.relatedId));\n  }\n\n  // Returns a promise for a list of owning ids given some related ids.\n  // className here is the owning className.\n  owningIds(className: string, key: string, relatedIds: string[]): Promise<string[]> {\n    return this.adapter\n      .find(\n        joinTableName(className, key),\n        relationSchema,\n        { relatedId: { $in: relatedIds } },\n        { keys: ['owningId'] }\n      )\n      .then(results => results.map(result => result.owningId));\n  }\n\n  // Modifies query so that it no longer has $in on relation fields, or\n  // equal-to-pointer constraints on relation fields.\n  // Returns a promise that resolves when query is mutated\n  reduceInRelation(className: string, query: any, schema: any): Promise<any> {\n    // Search for an in-relation or equal-to-relation\n    // Make it sequential for now, not sure of paralleization side effects\n    if (query['$or']) {\n      const ors = query['$or'];\n      return Promise.all(\n        ors.map((aQuery, index) => {\n          return this.reduceInRelation(className, aQuery, schema).then(aQuery => {\n            query['$or'][index] = aQuery;\n          });\n        })\n      ).then(() => {\n        return Promise.resolve(query);\n      });\n    }\n    if (query['$and']) {\n      const ands = query['$and'];\n      return Promise.all(\n        ands.map((aQuery, index) => {\n          return this.reduceInRelation(className, aQuery, schema).then(aQuery => {\n            query['$and'][index] = aQuery;\n          });\n        })\n      ).then(() => {\n        return Promise.resolve(query);\n      });\n    }\n\n    const promises = Object.keys(query).map(key => {\n      const t = schema.getExpectedType(className, key);\n      if (!t || t.type !== 'Relation') {\n        return Promise.resolve(query);\n      }\n      let queries: ?(any[]) = null;\n      if (\n        query[key] &&\n        (query[key]['$in'] ||\n          query[key]['$ne'] ||\n          query[key]['$nin'] ||\n          query[key].__type == 'Pointer')\n      ) {\n        // Build the list of queries\n        queries = Object.keys(query[key]).map(constraintKey => {\n          let relatedIds;\n          let isNegation = false;\n          if (constraintKey === 'objectId') {\n            relatedIds = [query[key].objectId];\n          } else if (constraintKey == '$in') {\n            relatedIds = query[key]['$in'].map(r => r.objectId);\n          } else if (constraintKey == '$nin') {\n            isNegation = true;\n            relatedIds = query[key]['$nin'].map(r => r.objectId);\n          } else if (constraintKey == '$ne') {\n            isNegation = true;\n            relatedIds = [query[key]['$ne'].objectId];\n          } else {\n            return;\n          }\n          return {\n            isNegation,\n            relatedIds,\n          };\n        });\n      } else {\n        queries = [{ isNegation: false, relatedIds: [] }];\n      }\n\n      // remove the current queryKey as we don,t need it anymore\n      delete query[key];\n      // execute each query independently to build the list of\n      // $in / $nin\n      const promises = queries.map(q => {\n        if (!q) {\n          return Promise.resolve();\n        }\n        return this.owningIds(className, key, q.relatedIds).then(ids => {\n          if (q.isNegation) {\n            this.addNotInObjectIdsIds(ids, query);\n          } else {\n            this.addInObjectIdsIds(ids, query);\n          }\n          return Promise.resolve();\n        });\n      });\n\n      return Promise.all(promises).then(() => {\n        return Promise.resolve();\n      });\n    });\n\n    return Promise.all(promises).then(() => {\n      return Promise.resolve(query);\n    });\n  }\n\n  // Modifies query so that it no longer has $relatedTo\n  // Returns a promise that resolves when query is mutated\n  reduceRelationKeys(className: string, query: any, queryOptions: any): ?Promise<void> {\n    if (query['$or']) {\n      return Promise.all(\n        query['$or'].map(aQuery => {\n          return this.reduceRelationKeys(className, aQuery, queryOptions);\n        })\n      );\n    }\n    if (query['$and']) {\n      return Promise.all(\n        query['$and'].map(aQuery => {\n          return this.reduceRelationKeys(className, aQuery, queryOptions);\n        })\n      );\n    }\n    var relatedTo = query['$relatedTo'];\n    if (relatedTo) {\n      return this.relatedIds(\n        relatedTo.object.className,\n        relatedTo.key,\n        relatedTo.object.objectId,\n        queryOptions\n      )\n        .then(ids => {\n          delete query['$relatedTo'];\n          this.addInObjectIdsIds(ids, query);\n          return this.reduceRelationKeys(className, query, queryOptions);\n        })\n        .then(() => {});\n    }\n  }\n\n  addInObjectIdsIds(ids: ?Array<string> = null, query: any) {\n    const idsFromString: ?Array<string> =\n      typeof query.objectId === 'string' ? [query.objectId] : null;\n    const idsFromEq: ?Array<string> =\n      query.objectId && query.objectId['$eq'] ? [query.objectId['$eq']] : null;\n    const idsFromIn: ?Array<string> =\n      query.objectId && query.objectId['$in'] ? query.objectId['$in'] : null;\n\n    // @flow-disable-next\n    const allIds: Array<Array<string>> = [idsFromString, idsFromEq, idsFromIn, ids].filter(\n      list => list !== null\n    );\n    const totalLength = allIds.reduce((memo, list) => memo + list.length, 0);\n\n    let idsIntersection = [];\n    if (totalLength > 125) {\n      idsIntersection = intersect.big(allIds);\n    } else {\n      idsIntersection = intersect(allIds);\n    }\n\n    // Need to make sure we don't clobber existing shorthand $eq constraints on objectId.\n    if (!('objectId' in query)) {\n      query.objectId = {\n        $in: undefined,\n      };\n    } else if (typeof query.objectId === 'string') {\n      query.objectId = {\n        $in: undefined,\n        $eq: query.objectId,\n      };\n    }\n    query.objectId['$in'] = idsIntersection;\n\n    return query;\n  }\n\n  addNotInObjectIdsIds(ids: string[] = [], query: any) {\n    const idsFromNin = query.objectId && query.objectId['$nin'] ? query.objectId['$nin'] : [];\n    let allIds = [...idsFromNin, ...ids].filter(list => list !== null);\n\n    // make a set and spread to remove duplicates\n    allIds = [...new Set(allIds)];\n\n    // Need to make sure we don't clobber existing shorthand $eq constraints on objectId.\n    if (!('objectId' in query)) {\n      query.objectId = {\n        $nin: undefined,\n      };\n    } else if (typeof query.objectId === 'string') {\n      query.objectId = {\n        $nin: undefined,\n        $eq: query.objectId,\n      };\n    }\n\n    query.objectId['$nin'] = allIds;\n    return query;\n  }\n\n  // Runs a query on the database.\n  // Returns a promise that resolves to a list of items.\n  // Options:\n  //   skip    number of results to skip.\n  //   limit   limit to this number of results.\n  //   sort    an object where keys are the fields to sort by.\n  //           the value is +1 for ascending, -1 for descending.\n  //   count   run a count instead of returning results.\n  //   acl     restrict this operation with an ACL for the provided array\n  //           of user objectIds and roles. acl: null means no user.\n  //           when this field is not present, don't do anything regarding ACLs.\n  //  caseInsensitive make string comparisons case insensitive\n  // TODO: make userIds not needed here. The db adapter shouldn't know\n  // anything about users, ideally. Then, improve the format of the ACL\n  // arg to work like the others.\n  find(\n    className: string,\n    query: any,\n    {\n      skip,\n      limit,\n      acl,\n      sort = {},\n      count,\n      keys,\n      op,\n      distinct,\n      pipeline,\n      readPreference,\n      hint,\n      caseInsensitive = false,\n      explain,\n    }: any = {},\n    auth: any = {},\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    const isMaster = acl === undefined;\n    const aclGroup = acl || [];\n    op =\n      op || (typeof query.objectId == 'string' && Object.keys(query).length === 1 ? 'get' : 'find');\n    // Count operation if counting\n    op = count === true ? 'count' : op;\n\n    let classExists = true;\n    return this.loadSchemaIfNeeded(validSchemaController).then(schemaController => {\n      //Allow volatile classes if querying with Master (for _PushStatus)\n      //TODO: Move volatile classes concept into mongo adapter, postgres adapter shouldn't care\n      //that api.parse.com breaks when _PushStatus exists in mongo.\n      return schemaController\n        .getOneSchema(className, isMaster)\n        .catch(error => {\n          // Behavior for non-existent classes is kinda weird on Parse.com. Probably doesn't matter too much.\n          // For now, pretend the class exists but has no objects,\n          if (error === undefined) {\n            classExists = false;\n            return { fields: {} };\n          }\n          throw error;\n        })\n        .then(schema => {\n          // Parse.com treats queries on _created_at and _updated_at as if they were queries on createdAt and updatedAt,\n          // so duplicate that behavior here. If both are specified, the correct behavior to match Parse.com is to\n          // use the one that appears first in the sort list.\n          if (sort._created_at) {\n            sort.createdAt = sort._created_at;\n            delete sort._created_at;\n          }\n          if (sort._updated_at) {\n            sort.updatedAt = sort._updated_at;\n            delete sort._updated_at;\n          }\n          const queryOptions = {\n            skip,\n            limit,\n            sort,\n            keys,\n            readPreference,\n            hint,\n            caseInsensitive,\n            explain,\n          };\n          Object.keys(sort).forEach(fieldName => {\n            if (fieldName.match(/^authData\\.([a-zA-Z0-9_]+)\\.id$/)) {\n              throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, `Cannot sort by ${fieldName}`);\n            }\n            const rootFieldName = getRootFieldName(fieldName);\n            if (!SchemaController.fieldNameIsValid(rootFieldName, className)) {\n              throw new Parse.Error(\n                Parse.Error.INVALID_KEY_NAME,\n                `Invalid field name: ${fieldName}.`\n              );\n            }\n          });\n          return (isMaster\n            ? Promise.resolve()\n            : schemaController.validatePermission(className, aclGroup, op)\n          )\n            .then(() => this.reduceRelationKeys(className, query, queryOptions))\n            .then(() => this.reduceInRelation(className, query, schemaController))\n            .then(() => {\n              let protectedFields;\n              if (!isMaster) {\n                query = this.addPointerPermissions(\n                  schemaController,\n                  className,\n                  op,\n                  query,\n                  aclGroup\n                );\n                /* Don't use projections to optimize the protectedFields since the protectedFields\n                  based on pointer-permissions are determined after querying. The filtering can\n                  overwrite the protected fields. */\n                protectedFields = this.addProtectedFields(\n                  schemaController,\n                  className,\n                  query,\n                  aclGroup,\n                  auth,\n                  queryOptions\n                );\n              }\n              if (!query) {\n                if (op === 'get') {\n                  throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n                } else {\n                  return [];\n                }\n              }\n              if (!isMaster) {\n                if (op === 'update' || op === 'delete') {\n                  query = addWriteACL(query, aclGroup);\n                } else {\n                  query = addReadACL(query, aclGroup);\n                }\n              }\n              validateQuery(query);\n              if (count) {\n                if (!classExists) {\n                  return 0;\n                } else {\n                  return this.adapter.count(\n                    className,\n                    schema,\n                    query,\n                    readPreference,\n                    undefined,\n                    hint\n                  );\n                }\n              } else if (distinct) {\n                if (!classExists) {\n                  return [];\n                } else {\n                  return this.adapter.distinct(className, schema, query, distinct);\n                }\n              } else if (pipeline) {\n                if (!classExists) {\n                  return [];\n                } else {\n                  return this.adapter.aggregate(\n                    className,\n                    schema,\n                    pipeline,\n                    readPreference,\n                    hint,\n                    explain\n                  );\n                }\n              } else if (explain) {\n                return this.adapter.find(className, schema, query, queryOptions);\n              } else {\n                return this.adapter\n                  .find(className, schema, query, queryOptions)\n                  .then(objects =>\n                    objects.map(object => {\n                      object = untransformObjectACL(object);\n                      return filterSensitiveData(\n                        isMaster,\n                        aclGroup,\n                        auth,\n                        op,\n                        schemaController,\n                        className,\n                        protectedFields,\n                        object\n                      );\n                    })\n                  )\n                  .catch(error => {\n                    throw new Parse.Error(Parse.Error.INTERNAL_SERVER_ERROR, error);\n                  });\n              }\n            });\n        });\n    });\n  }\n\n  deleteSchema(className: string): Promise<void> {\n    let schemaController;\n    return this.loadSchema({ clearCache: true })\n      .then(s => {\n        schemaController = s;\n        return schemaController.getOneSchema(className, true);\n      })\n      .catch(error => {\n        if (error === undefined) {\n          return { fields: {} };\n        } else {\n          throw error;\n        }\n      })\n      .then((schema: any) => {\n        return this.collectionExists(className)\n          .then(() => this.adapter.count(className, { fields: {} }, null, '', false))\n          .then(count => {\n            if (count > 0) {\n              throw new Parse.Error(\n                255,\n                `Class ${className} is not empty, contains ${count} objects, cannot drop schema.`\n              );\n            }\n            return this.adapter.deleteClass(className);\n          })\n          .then(wasParseCollection => {\n            if (wasParseCollection) {\n              const relationFieldNames = Object.keys(schema.fields).filter(\n                fieldName => schema.fields[fieldName].type === 'Relation'\n              );\n              return Promise.all(\n                relationFieldNames.map(name =>\n                  this.adapter.deleteClass(joinTableName(className, name))\n                )\n              ).then(() => {\n                SchemaCache.del(className);\n                return schemaController.reloadData();\n              });\n            } else {\n              return Promise.resolve();\n            }\n          });\n      });\n  }\n\n  // This helps to create intermediate objects for simpler comparison of\n  // key value pairs used in query objects. Each key value pair will represented\n  // in a similar way to json\n  objectToEntriesStrings(query: any): Array<string> {\n    return Object.entries(query).map(a => a.map(s => JSON.stringify(s)).join(':'));\n  }\n\n  // Naive logic reducer for OR operations meant to be used only for pointer permissions.\n  reduceOrOperation(query: { $or: Array<any> }): any {\n    if (!query.$or) {\n      return query;\n    }\n    const queries = query.$or.map(q => this.objectToEntriesStrings(q));\n    let repeat = false;\n    do {\n      repeat = false;\n      for (let i = 0; i < queries.length - 1; i++) {\n        for (let j = i + 1; j < queries.length; j++) {\n          const [shorter, longer] = queries[i].length > queries[j].length ? [j, i] : [i, j];\n          const foundEntries = queries[shorter].reduce(\n            (acc, entry) => acc + (queries[longer].includes(entry) ? 1 : 0),\n            0\n          );\n          const shorterEntries = queries[shorter].length;\n          if (foundEntries === shorterEntries) {\n            // If the shorter query is completely contained in the longer one, we can strike\n            // out the longer query.\n            query.$or.splice(longer, 1);\n            queries.splice(longer, 1);\n            repeat = true;\n            break;\n          }\n        }\n      }\n    } while (repeat);\n    if (query.$or.length === 1) {\n      query = { ...query, ...query.$or[0] };\n      delete query.$or;\n    }\n    return query;\n  }\n\n  // Naive logic reducer for AND operations meant to be used only for pointer permissions.\n  reduceAndOperation(query: { $and: Array<any> }): any {\n    if (!query.$and) {\n      return query;\n    }\n    const queries = query.$and.map(q => this.objectToEntriesStrings(q));\n    let repeat = false;\n    do {\n      repeat = false;\n      for (let i = 0; i < queries.length - 1; i++) {\n        for (let j = i + 1; j < queries.length; j++) {\n          const [shorter, longer] = queries[i].length > queries[j].length ? [j, i] : [i, j];\n          const foundEntries = queries[shorter].reduce(\n            (acc, entry) => acc + (queries[longer].includes(entry) ? 1 : 0),\n            0\n          );\n          const shorterEntries = queries[shorter].length;\n          if (foundEntries === shorterEntries) {\n            // If the shorter query is completely contained in the longer one, we can strike\n            // out the shorter query.\n            query.$and.splice(shorter, 1);\n            queries.splice(shorter, 1);\n            repeat = true;\n            break;\n          }\n        }\n      }\n    } while (repeat);\n    if (query.$and.length === 1) {\n      query = { ...query, ...query.$and[0] };\n      delete query.$and;\n    }\n    return query;\n  }\n\n  // Constraints query using CLP's pointer permissions (PP) if any.\n  // 1. Etract the user id from caller's ACLgroup;\n  // 2. Exctract a list of field names that are PP for target collection and operation;\n  // 3. Constraint the original query so that each PP field must\n  // point to caller's id (or contain it in case of PP field being an array)\n  addPointerPermissions(\n    schema: SchemaController.SchemaController,\n    className: string,\n    operation: string,\n    query: any,\n    aclGroup: any[] = []\n  ): any {\n    // Check if class has public permission for operation\n    // If the BaseCLP pass, let go through\n    if (schema.testPermissionsForClassName(className, aclGroup, operation)) {\n      return query;\n    }\n    const perms = schema.getClassLevelPermissions(className);\n\n    const userACL = aclGroup.filter(acl => {\n      return acl.indexOf('role:') != 0 && acl != '*';\n    });\n\n    const groupKey =\n      ['get', 'find', 'count'].indexOf(operation) > -1 ? 'readUserFields' : 'writeUserFields';\n\n    const permFields = [];\n\n    if (perms[operation] && perms[operation].pointerFields) {\n      permFields.push(...perms[operation].pointerFields);\n    }\n\n    if (perms[groupKey]) {\n      for (const field of perms[groupKey]) {\n        if (!permFields.includes(field)) {\n          permFields.push(field);\n        }\n      }\n    }\n    // the ACL should have exactly 1 user\n    if (permFields.length > 0) {\n      // the ACL should have exactly 1 user\n      // No user set return undefined\n      // If the length is > 1, that means we didn't de-dupe users correctly\n      if (userACL.length != 1) {\n        return;\n      }\n      const userId = userACL[0];\n      const userPointer = {\n        __type: 'Pointer',\n        className: '_User',\n        objectId: userId,\n      };\n\n      const queries = permFields.map(key => {\n        const fieldDescriptor = schema.getExpectedType(className, key);\n        const fieldType =\n          fieldDescriptor &&\n          typeof fieldDescriptor === 'object' &&\n          Object.prototype.hasOwnProperty.call(fieldDescriptor, 'type')\n            ? fieldDescriptor.type\n            : null;\n\n        let queryClause;\n\n        if (fieldType === 'Pointer') {\n          // constraint for single pointer setup\n          queryClause = { [key]: userPointer };\n        } else if (fieldType === 'Array') {\n          // constraint for users-array setup\n          queryClause = { [key]: { $all: [userPointer] } };\n        } else if (fieldType === 'Object') {\n          // constraint for object setup\n          queryClause = { [key]: userPointer };\n        } else {\n          // This means that there is a CLP field of an unexpected type. This condition should not happen, which is\n          // why is being treated as an error.\n          throw Error(\n            `An unexpected condition occurred when resolving pointer permissions: ${className} ${key}`\n          );\n        }\n        // if we already have a constraint on the key, use the $and\n        if (Object.prototype.hasOwnProperty.call(query, key)) {\n          return this.reduceAndOperation({ $and: [queryClause, query] });\n        }\n        // otherwise just add the constaint\n        return Object.assign({}, query, queryClause);\n      });\n\n      return queries.length === 1 ? queries[0] : this.reduceOrOperation({ $or: queries });\n    } else {\n      return query;\n    }\n  }\n\n  addProtectedFields(\n    schema: SchemaController.SchemaController | any,\n    className: string,\n    query: any = {},\n    aclGroup: any[] = [],\n    auth: any = {},\n    queryOptions: FullQueryOptions = {}\n  ): null | string[] {\n    const perms =\n      schema && schema.getClassLevelPermissions\n        ? schema.getClassLevelPermissions(className)\n        : schema;\n    if (!perms) return null;\n\n    const protectedFields = perms.protectedFields;\n    if (!protectedFields) return null;\n\n    if (aclGroup.indexOf(query.objectId) > -1) return null;\n\n    // for queries where \"keys\" are set and do not include all 'userField':{field},\n    // we have to transparently include it, and then remove before returning to client\n    // Because if such key not projected the permission won't be enforced properly\n    // PS this is called when 'excludeKeys' already reduced to 'keys'\n    const preserveKeys = queryOptions.keys;\n\n    // these are keys that need to be included only\n    // to be able to apply protectedFields by pointer\n    // and then unset before returning to client (later in  filterSensitiveFields)\n    const serverOnlyKeys = [];\n\n    const authenticated = auth.user;\n\n    // map to allow check without array search\n    const roles = (auth.userRoles || []).reduce((acc, r) => {\n      acc[r] = protectedFields[r];\n      return acc;\n    }, {});\n\n    // array of sets of protected fields. separate item for each applicable criteria\n    const protectedKeysSets = [];\n\n    for (const key in protectedFields) {\n      // skip userFields\n      if (key.startsWith('userField:')) {\n        if (preserveKeys) {\n          const fieldName = key.substring(10);\n          if (!preserveKeys.includes(fieldName)) {\n            // 1. put it there temporarily\n            queryOptions.keys && queryOptions.keys.push(fieldName);\n            // 2. preserve it delete later\n            serverOnlyKeys.push(fieldName);\n          }\n        }\n        continue;\n      }\n\n      // add public tier\n      if (key === '*') {\n        protectedKeysSets.push(protectedFields[key]);\n        continue;\n      }\n\n      if (authenticated) {\n        if (key === 'authenticated') {\n          // for logged in users\n          protectedKeysSets.push(protectedFields[key]);\n          continue;\n        }\n\n        if (roles[key] && key.startsWith('role:')) {\n          // add applicable roles\n          protectedKeysSets.push(roles[key]);\n        }\n      }\n    }\n\n    // check if there's a rule for current user's id\n    if (authenticated) {\n      const userId = auth.user.id;\n      if (perms.protectedFields[userId]) {\n        protectedKeysSets.push(perms.protectedFields[userId]);\n      }\n    }\n\n    // preserve fields to be removed before sending response to client\n    if (serverOnlyKeys.length > 0) {\n      perms.protectedFields.temporaryKeys = serverOnlyKeys;\n    }\n\n    let protectedKeys = protectedKeysSets.reduce((acc, next) => {\n      if (next) {\n        acc.push(...next);\n      }\n      return acc;\n    }, []);\n\n    // intersect all sets of protectedFields\n    protectedKeysSets.forEach(fields => {\n      if (fields) {\n        protectedKeys = protectedKeys.filter(v => fields.includes(v));\n      }\n    });\n\n    return protectedKeys;\n  }\n\n  createTransactionalSession() {\n    return this.adapter.createTransactionalSession().then(transactionalSession => {\n      this._transactionalSession = transactionalSession;\n    });\n  }\n\n  commitTransactionalSession() {\n    if (!this._transactionalSession) {\n      throw new Error('There is no transactional session to commit');\n    }\n    return this.adapter.commitTransactionalSession(this._transactionalSession).then(() => {\n      this._transactionalSession = null;\n    });\n  }\n\n  abortTransactionalSession() {\n    if (!this._transactionalSession) {\n      throw new Error('There is no transactional session to abort');\n    }\n    return this.adapter.abortTransactionalSession(this._transactionalSession).then(() => {\n      this._transactionalSession = null;\n    });\n  }\n\n  // TODO: create indexes on first creation of a _User object. Otherwise it's impossible to\n  // have a Parse app without it having a _User collection.\n  async performInitialization() {\n    await this.adapter.performInitialization({\n      VolatileClassesSchemas: SchemaController.VolatileClassesSchemas,\n    });\n    const requiredUserFields = {\n      fields: {\n        ...SchemaController.defaultColumns._Default,\n        ...SchemaController.defaultColumns._User,\n      },\n    };\n    const requiredRoleFields = {\n      fields: {\n        ...SchemaController.defaultColumns._Default,\n        ...SchemaController.defaultColumns._Role,\n      },\n    };\n    const requiredIdempotencyFields = {\n      fields: {\n        ...SchemaController.defaultColumns._Default,\n        ...SchemaController.defaultColumns._Idempotency,\n      },\n    };\n    await this.loadSchema().then(schema => schema.enforceClassExists('_User'));\n    await this.loadSchema().then(schema => schema.enforceClassExists('_Role'));\n    await this.loadSchema().then(schema => schema.enforceClassExists('_Idempotency'));\n\n    await this.adapter.ensureUniqueness('_User', requiredUserFields, ['username']).catch(error => {\n      logger.warn('Unable to ensure uniqueness for usernames: ', error);\n      throw error;\n    });\n\n    await this.adapter\n      .ensureIndex('_User', requiredUserFields, ['username'], 'case_insensitive_username', true)\n      .catch(error => {\n        logger.warn('Unable to create case insensitive username index: ', error);\n        throw error;\n      });\n    await this.adapter\n      .ensureIndex('_User', requiredUserFields, ['username'], 'case_insensitive_username', true)\n      .catch(error => {\n        logger.warn('Unable to create case insensitive username index: ', error);\n        throw error;\n      });\n\n    await this.adapter.ensureUniqueness('_User', requiredUserFields, ['email']).catch(error => {\n      logger.warn('Unable to ensure uniqueness for user email addresses: ', error);\n      throw error;\n    });\n\n    await this.adapter\n      .ensureIndex('_User', requiredUserFields, ['email'], 'case_insensitive_email', true)\n      .catch(error => {\n        logger.warn('Unable to create case insensitive email index: ', error);\n        throw error;\n      });\n\n    await this.adapter.ensureUniqueness('_Role', requiredRoleFields, ['name']).catch(error => {\n      logger.warn('Unable to ensure uniqueness for role name: ', error);\n      throw error;\n    });\n\n    await this.adapter\n      .ensureUniqueness('_Idempotency', requiredIdempotencyFields, ['reqId'])\n      .catch(error => {\n        logger.warn('Unable to ensure uniqueness for idempotency request ID: ', error);\n        throw error;\n      });\n\n    const isMongoAdapter = this.adapter instanceof MongoStorageAdapter;\n    const isPostgresAdapter = this.adapter instanceof PostgresStorageAdapter;\n    if (isMongoAdapter || isPostgresAdapter) {\n      let options = {};\n      if (isMongoAdapter) {\n        options = {\n          ttl: 0,\n        };\n      } else if (isPostgresAdapter) {\n        options = this.idempotencyOptions;\n        options.setIdempotencyFunction = true;\n      }\n      await this.adapter\n        .ensureIndex('_Idempotency', requiredIdempotencyFields, ['expire'], 'ttl', false, options)\n        .catch(error => {\n          logger.warn('Unable to create TTL index for idempotency expire date: ', error);\n          throw error;\n        });\n    }\n    await this.adapter.updateSchemaWithIndexes();\n  }\n\n  _expandResultOnKeyPath(object: any, key: string, value: any): any {\n    if (key.indexOf('.') < 0) {\n      object[key] = value[key];\n      return object;\n    }\n    const path = key.split('.');\n    const firstKey = path[0];\n    const nextPath = path.slice(1).join('.');\n\n    // Scan request data for denied keywords\n    if (this.options && this.options.requestKeywordDenylist) {\n      // Scan request data for denied keywords\n      for (const keyword of this.options.requestKeywordDenylist) {\n        const match = Utils.objectContainsKeyValue({ firstKey: undefined }, keyword.key, undefined);\n        if (match) {\n          throw new Parse.Error(\n            Parse.Error.INVALID_KEY_NAME,\n            `Prohibited keyword in request data: ${JSON.stringify(keyword)}.`\n          );\n        }\n      }\n    }\n\n    object[firstKey] = this._expandResultOnKeyPath(\n      object[firstKey] || {},\n      nextPath,\n      value[firstKey]\n    );\n    delete object[key];\n    return object;\n  }\n\n  _sanitizeDatabaseResult(originalObject: any, result: any): Promise<any> {\n    const response = {};\n    if (!result) {\n      return Promise.resolve(response);\n    }\n    Object.keys(originalObject).forEach(key => {\n      const keyUpdate = originalObject[key];\n      // determine if that was an op\n      if (\n        keyUpdate &&\n        typeof keyUpdate === 'object' &&\n        keyUpdate.__op &&\n        ['Add', 'AddUnique', 'Remove', 'Increment'].indexOf(keyUpdate.__op) > -1\n      ) {\n        // only valid ops that produce an actionable result\n        // the op may have happened on a keypath\n        this._expandResultOnKeyPath(response, key, result);\n      }\n    });\n    return Promise.resolve(response);\n  }\n\n  static _validateQuery: any => void;\n  static filterSensitiveData: (boolean, any[], any, any, any, string, any[], any) => void;\n}\n\nmodule.exports = DatabaseController;\n// Expose validateQuery for tests\nmodule.exports._validateQuery = validateQuery;\nmodule.exports.filterSensitiveData = filterSensitiveData;\n", "import { ParsePubSub } from './ParsePubSub';\nimport Parse from 'parse/node';\nimport logger from '../logger';\n\nclass ParseCloudCodePublisher {\n  parsePublisher: Object;\n\n  // config object of the publisher, right now it only contains the redisURL,\n  // but we may extend it later.\n  constructor(config: any = {}) {\n    this.parsePublisher = ParsePubSub.createPublisher(config);\n  }\n\n  onCloudCodeAfterSave(request: any): void {\n    this._onCloudCodeMessage(Parse.applicationId + 'afterSave', request);\n  }\n\n  onCloudCodeAfterDelete(request: any): void {\n    this._onCloudCodeMessage(Parse.applicationId + 'afterDelete', request);\n  }\n\n  // Request is the request object from cloud code functions. request.object is a ParseObject.\n  _onCloudCodeMessage(type: string, request: any): void {\n    logger.verbose(\n      'Raw request from cloud code current : %j | original : %j',\n      request.object,\n      request.original\n    );\n    // We need the full JSON which includes className\n    const message = {\n      currentParseObject: request.object._toFullJSON(),\n    };\n    if (request.original) {\n      message.originalParseObject = request.original._toFullJSON();\n    }\n    if (request.classLevelPermissions) {\n      message.classLevelPermissions = request.classLevelPermissions;\n    }\n    this.parsePublisher.publish(type, JSON.stringify(message));\n  }\n}\n\nexport { ParseCloudCodePublisher };\n", "import tv4 from 'tv4';\nimport Parse from 'parse/node';\nimport { Subscription } from './Subscription';\nimport { Client } from './Client';\nimport { ParseWebSocketServer } from './ParseWebSocketServer';\nimport logger from '../logger';\nimport RequestSchema from './RequestSchema';\nimport { matchesQuery, queryHash } from './QueryTools';\nimport { ParsePubSub } from './ParsePubSub';\nimport SchemaController from '../Controllers/SchemaController';\nimport _ from 'lodash';\nimport { v4 as uuidv4 } from 'uuid';\nimport {\n  runLiveQueryEventHandlers,\n  getTrigger,\n  runTrigger,\n  resolveError,\n  toJSONwithObjects,\n} from '../triggers';\nimport { getAuthForSessionToken, Auth } from '../Auth';\nimport { getCacheController, getDatabaseController } from '../Controllers';\nimport LRU from 'lru-cache';\nimport UserRouter from '../Routers/UsersRouter';\nimport DatabaseController from '../Controllers/DatabaseController';\n\nclass ParseLiveQueryServer {\n  clients: Map;\n  // className -> (queryHash -> subscription)\n  subscriptions: Object;\n  parseWebSocketServer: Object;\n  keyPairs: any;\n  // The subscriber we use to get object update from publisher\n  subscriber: Object;\n\n  constructor(server: any, config: any = {}, parseServerConfig: any = {}) {\n    this.server = server;\n    this.clients = new Map();\n    this.subscriptions = new Map();\n    this.config = config;\n\n    config.appId = config.appId || Parse.applicationId;\n    config.masterKey = config.masterKey || Parse.masterKey;\n\n    // Store keys, convert obj to map\n    const keyPairs = config.keyPairs || {};\n    this.keyPairs = new Map();\n    for (const key of Object.keys(keyPairs)) {\n      this.keyPairs.set(key, keyPairs[key]);\n    }\n    logger.verbose('Support key pairs', this.keyPairs);\n\n    // Initialize Parse\n    Parse.Object.disableSingleInstance();\n    const serverURL = config.serverURL || Parse.serverURL;\n    Parse.serverURL = serverURL;\n    Parse.initialize(config.appId, Parse.javaScriptKey, config.masterKey);\n\n    // The cache controller is a proper cache controller\n    // with access to User and Roles\n    this.cacheController = getCacheController(parseServerConfig);\n\n    config.cacheTimeout = config.cacheTimeout || 5 * 1000; // 5s\n\n    // This auth cache stores the promises for each auth resolution.\n    // The main benefit is to be able to reuse the same user / session token resolution.\n    this.authCache = new LRU({\n      max: 500, // 500 concurrent\n      maxAge: config.cacheTimeout,\n    });\n    // Initialize websocket server\n    this.parseWebSocketServer = new ParseWebSocketServer(\n      server,\n      parseWebsocket => this._onConnect(parseWebsocket),\n      config\n    );\n\n    // Initialize subscriber\n    this.subscriber = ParsePubSub.createSubscriber(config);\n    this.subscriber.subscribe(Parse.applicationId + 'afterSave');\n    this.subscriber.subscribe(Parse.applicationId + 'afterDelete');\n    // Register message handler for subscriber. When publisher get messages, it will publish message\n    // to the subscribers and the handler will be called.\n    this.subscriber.on('message', (channel, messageStr) => {\n      logger.verbose('Subscribe message %j', messageStr);\n      let message;\n      try {\n        message = JSON.parse(messageStr);\n      } catch (e) {\n        logger.error('unable to parse message', messageStr, e);\n        return;\n      }\n      this._inflateParseObject(message);\n      if (channel === Parse.applicationId + 'afterSave') {\n        this._onAfterSave(message);\n      } else if (channel === Parse.applicationId + 'afterDelete') {\n        this._onAfterDelete(message);\n      } else {\n        logger.error('Get message %s from unknown channel %j', message, channel);\n      }\n    });\n  }\n\n  // Message is the JSON object from publisher. Message.currentParseObject is the ParseObject JSON after changes.\n  // Message.originalParseObject is the original ParseObject JSON.\n  _inflateParseObject(message: any): void {\n    // Inflate merged object\n    const currentParseObject = message.currentParseObject;\n    UserRouter.removeHiddenProperties(currentParseObject);\n    let className = currentParseObject.className;\n    let parseObject = new Parse.Object(className);\n    parseObject._finishFetch(currentParseObject);\n    message.currentParseObject = parseObject;\n    // Inflate original object\n    const originalParseObject = message.originalParseObject;\n    if (originalParseObject) {\n      UserRouter.removeHiddenProperties(originalParseObject);\n      className = originalParseObject.className;\n      parseObject = new Parse.Object(className);\n      parseObject._finishFetch(originalParseObject);\n      message.originalParseObject = parseObject;\n    }\n  }\n\n  // Message is the JSON object from publisher after inflated. Message.currentParseObject is the ParseObject after changes.\n  // Message.originalParseObject is the original ParseObject.\n  async _onAfterDelete(message: any): void {\n    logger.verbose(Parse.applicationId + 'afterDelete is triggered');\n\n    let deletedParseObject = message.currentParseObject.toJSON();\n    const classLevelPermissions = message.classLevelPermissions;\n    const className = deletedParseObject.className;\n    logger.verbose('ClassName: %j | ObjectId: %s', className, deletedParseObject.id);\n    logger.verbose('Current client number : %d', this.clients.size);\n\n    const classSubscriptions = this.subscriptions.get(className);\n    if (typeof classSubscriptions === 'undefined') {\n      logger.debug('Can not find subscriptions under this class ' + className);\n      return;\n    }\n\n    for (const subscription of classSubscriptions.values()) {\n      const isSubscriptionMatched = this._matchesSubscription(deletedParseObject, subscription);\n      if (!isSubscriptionMatched) {\n        continue;\n      }\n      for (const [clientId, requestIds] of _.entries(subscription.clientRequestIds)) {\n        const client = this.clients.get(clientId);\n        if (typeof client === 'undefined') {\n          continue;\n        }\n        requestIds.forEach(async requestId => {\n          const acl = message.currentParseObject.getACL();\n          // Check CLP\n          const op = this._getCLPOperation(subscription.query);\n          let res = {};\n          try {\n            await this._matchesCLP(\n              classLevelPermissions,\n              message.currentParseObject,\n              client,\n              requestId,\n              op\n            );\n            const isMatched = await this._matchesACL(acl, client, requestId);\n            if (!isMatched) {\n              return null;\n            }\n            res = {\n              event: 'delete',\n              sessionToken: client.sessionToken,\n              object: deletedParseObject,\n              clients: this.clients.size,\n              subscriptions: this.subscriptions.size,\n              useMasterKey: client.hasMasterKey,\n              installationId: client.installationId,\n              sendEvent: true,\n            };\n            const trigger = getTrigger(className, 'afterEvent', Parse.applicationId);\n            if (trigger) {\n              const auth = await this.getAuthFromClient(client, requestId);\n              if (auth && auth.user) {\n                res.user = auth.user;\n              }\n              if (res.object) {\n                res.object = Parse.Object.fromJSON(res.object);\n              }\n              await runTrigger(trigger, `afterEvent.${className}`, res, auth);\n            }\n            if (!res.sendEvent) {\n              return;\n            }\n            if (res.object && typeof res.object.toJSON === 'function') {\n              deletedParseObject = toJSONwithObjects(res.object, res.object.className || className);\n            }\n            await this._filterSensitiveData(\n              classLevelPermissions,\n              res,\n              client,\n              requestId,\n              op,\n              subscription.query\n            );\n            client.pushDelete(requestId, deletedParseObject);\n          } catch (e) {\n            const error = resolveError(e);\n            Client.pushError(client.parseWebSocket, error.code, error.message, false, requestId);\n            logger.error(\n              `Failed running afterLiveQueryEvent on class ${className} for event ${res.event} with session ${res.sessionToken} with:\\n Error: ` +\n                JSON.stringify(error)\n            );\n          }\n        });\n      }\n    }\n  }\n\n  // Message is the JSON object from publisher after inflated. Message.currentParseObject is the ParseObject after changes.\n  // Message.originalParseObject is the original ParseObject.\n  async _onAfterSave(message: any): void {\n    logger.verbose(Parse.applicationId + 'afterSave is triggered');\n\n    let originalParseObject = null;\n    if (message.originalParseObject) {\n      originalParseObject = message.originalParseObject.toJSON();\n    }\n    const classLevelPermissions = message.classLevelPermissions;\n    let currentParseObject = message.currentParseObject.toJSON();\n    const className = currentParseObject.className;\n    logger.verbose('ClassName: %s | ObjectId: %s', className, currentParseObject.id);\n    logger.verbose('Current client number : %d', this.clients.size);\n\n    const classSubscriptions = this.subscriptions.get(className);\n    if (typeof classSubscriptions === 'undefined') {\n      logger.debug('Can not find subscriptions under this class ' + className);\n      return;\n    }\n    for (const subscription of classSubscriptions.values()) {\n      const isOriginalSubscriptionMatched = this._matchesSubscription(\n        originalParseObject,\n        subscription\n      );\n      const isCurrentSubscriptionMatched = this._matchesSubscription(\n        currentParseObject,\n        subscription\n      );\n      for (const [clientId, requestIds] of _.entries(subscription.clientRequestIds)) {\n        const client = this.clients.get(clientId);\n        if (typeof client === 'undefined') {\n          continue;\n        }\n        requestIds.forEach(async requestId => {\n          // Set orignal ParseObject ACL checking promise, if the object does not match\n          // subscription, we do not need to check ACL\n          let originalACLCheckingPromise;\n          if (!isOriginalSubscriptionMatched) {\n            originalACLCheckingPromise = Promise.resolve(false);\n          } else {\n            let originalACL;\n            if (message.originalParseObject) {\n              originalACL = message.originalParseObject.getACL();\n            }\n            originalACLCheckingPromise = this._matchesACL(originalACL, client, requestId);\n          }\n          // Set current ParseObject ACL checking promise, if the object does not match\n          // subscription, we do not need to check ACL\n          let currentACLCheckingPromise;\n          let res = {};\n          if (!isCurrentSubscriptionMatched) {\n            currentACLCheckingPromise = Promise.resolve(false);\n          } else {\n            const currentACL = message.currentParseObject.getACL();\n            currentACLCheckingPromise = this._matchesACL(currentACL, client, requestId);\n          }\n          try {\n            const op = this._getCLPOperation(subscription.query);\n            await this._matchesCLP(\n              classLevelPermissions,\n              message.currentParseObject,\n              client,\n              requestId,\n              op\n            );\n            const [isOriginalMatched, isCurrentMatched] = await Promise.all([\n              originalACLCheckingPromise,\n              currentACLCheckingPromise,\n            ]);\n            logger.verbose(\n              'Original %j | Current %j | Match: %s, %s, %s, %s | Query: %s',\n              originalParseObject,\n              currentParseObject,\n              isOriginalSubscriptionMatched,\n              isCurrentSubscriptionMatched,\n              isOriginalMatched,\n              isCurrentMatched,\n              subscription.hash\n            );\n            // Decide event type\n            let type;\n            if (isOriginalMatched && isCurrentMatched) {\n              type = 'update';\n            } else if (isOriginalMatched && !isCurrentMatched) {\n              type = 'leave';\n            } else if (!isOriginalMatched && isCurrentMatched) {\n              if (originalParseObject) {\n                type = 'enter';\n              } else {\n                type = 'create';\n              }\n            } else {\n              return null;\n            }\n            res = {\n              event: type,\n              sessionToken: client.sessionToken,\n              object: currentParseObject,\n              original: originalParseObject,\n              clients: this.clients.size,\n              subscriptions: this.subscriptions.size,\n              useMasterKey: client.hasMasterKey,\n              installationId: client.installationId,\n              sendEvent: true,\n            };\n            const trigger = getTrigger(className, 'afterEvent', Parse.applicationId);\n            if (trigger) {\n              if (res.object) {\n                res.object = Parse.Object.fromJSON(res.object);\n              }\n              if (res.original) {\n                res.original = Parse.Object.fromJSON(res.original);\n              }\n              const auth = await this.getAuthFromClient(client, requestId);\n              if (auth && auth.user) {\n                res.user = auth.user;\n              }\n              await runTrigger(trigger, `afterEvent.${className}`, res, auth);\n            }\n            if (!res.sendEvent) {\n              return;\n            }\n            if (res.object && typeof res.object.toJSON === 'function') {\n              currentParseObject = toJSONwithObjects(res.object, res.object.className || className);\n            }\n            if (res.original && typeof res.original.toJSON === 'function') {\n              originalParseObject = toJSONwithObjects(\n                res.original,\n                res.original.className || className\n              );\n            }\n            await this._filterSensitiveData(\n              classLevelPermissions,\n              res,\n              client,\n              requestId,\n              op,\n              subscription.query\n            );\n            const functionName = 'push' + res.event.charAt(0).toUpperCase() + res.event.slice(1);\n            if (client[functionName]) {\n              client[functionName](requestId, currentParseObject, originalParseObject);\n            }\n          } catch (e) {\n            const error = resolveError(e);\n            Client.pushError(client.parseWebSocket, error.code, error.message, false, requestId);\n            logger.error(\n              `Failed running afterLiveQueryEvent on class ${className} for event ${res.event} with session ${res.sessionToken} with:\\n Error: ` +\n                JSON.stringify(error)\n            );\n          }\n        });\n      }\n    }\n  }\n\n  _onConnect(parseWebsocket: any): void {\n    parseWebsocket.on('message', request => {\n      if (typeof request === 'string') {\n        try {\n          request = JSON.parse(request);\n        } catch (e) {\n          logger.error('unable to parse request', request, e);\n          return;\n        }\n      }\n      logger.verbose('Request: %j', request);\n\n      // Check whether this request is a valid request, return error directly if not\n      if (\n        !tv4.validate(request, RequestSchema['general']) ||\n        !tv4.validate(request, RequestSchema[request.op])\n      ) {\n        Client.pushError(parseWebsocket, 1, tv4.error.message);\n        logger.error('Connect message error %s', tv4.error.message);\n        return;\n      }\n\n      switch (request.op) {\n        case 'connect':\n          this._handleConnect(parseWebsocket, request);\n          break;\n        case 'subscribe':\n          this._handleSubscribe(parseWebsocket, request);\n          break;\n        case 'update':\n          this._handleUpdateSubscription(parseWebsocket, request);\n          break;\n        case 'unsubscribe':\n          this._handleUnsubscribe(parseWebsocket, request);\n          break;\n        default:\n          Client.pushError(parseWebsocket, 3, 'Get unknown operation');\n          logger.error('Get unknown operation', request.op);\n      }\n    });\n\n    parseWebsocket.on('disconnect', () => {\n      logger.info(`Client disconnect: ${parseWebsocket.clientId}`);\n      const clientId = parseWebsocket.clientId;\n      if (!this.clients.has(clientId)) {\n        runLiveQueryEventHandlers({\n          event: 'ws_disconnect_error',\n          clients: this.clients.size,\n          subscriptions: this.subscriptions.size,\n          error: `Unable to find client ${clientId}`,\n        });\n        logger.error(`Can not find client ${clientId} on disconnect`);\n        return;\n      }\n\n      // Delete client\n      const client = this.clients.get(clientId);\n      this.clients.delete(clientId);\n\n      // Delete client from subscriptions\n      for (const [requestId, subscriptionInfo] of _.entries(client.subscriptionInfos)) {\n        const subscription = subscriptionInfo.subscription;\n        subscription.deleteClientSubscription(clientId, requestId);\n\n        // If there is no client which is subscribing this subscription, remove it from subscriptions\n        const classSubscriptions = this.subscriptions.get(subscription.className);\n        if (!subscription.hasSubscribingClient()) {\n          classSubscriptions.delete(subscription.hash);\n        }\n        // If there is no subscriptions under this class, remove it from subscriptions\n        if (classSubscriptions.size === 0) {\n          this.subscriptions.delete(subscription.className);\n        }\n      }\n\n      logger.verbose('Current clients %d', this.clients.size);\n      logger.verbose('Current subscriptions %d', this.subscriptions.size);\n      runLiveQueryEventHandlers({\n        event: 'ws_disconnect',\n        clients: this.clients.size,\n        subscriptions: this.subscriptions.size,\n        useMasterKey: client.hasMasterKey,\n        installationId: client.installationId,\n        sessionToken: client.sessionToken,\n      });\n    });\n\n    runLiveQueryEventHandlers({\n      event: 'ws_connect',\n      clients: this.clients.size,\n      subscriptions: this.subscriptions.size,\n    });\n  }\n\n  _matchesSubscription(parseObject: any, subscription: any): boolean {\n    // Object is undefined or null, not match\n    if (!parseObject) {\n      return false;\n    }\n    return matchesQuery(parseObject, subscription.query);\n  }\n\n  getAuthForSessionToken(sessionToken: ?string): Promise<{ auth: ?Auth, userId: ?string }> {\n    if (!sessionToken) {\n      return Promise.resolve({});\n    }\n    const fromCache = this.authCache.get(sessionToken);\n    if (fromCache) {\n      return fromCache;\n    }\n    const authPromise = getAuthForSessionToken({\n      cacheController: this.cacheController,\n      sessionToken: sessionToken,\n    })\n      .then(auth => {\n        return { auth, userId: auth && auth.user && auth.user.id };\n      })\n      .catch(error => {\n        // There was an error with the session token\n        const result = {};\n        if (error && error.code === Parse.Error.INVALID_SESSION_TOKEN) {\n          result.error = error;\n          this.authCache.set(sessionToken, Promise.resolve(result), this.config.cacheTimeout);\n        } else {\n          this.authCache.del(sessionToken);\n        }\n        return result;\n      });\n    this.authCache.set(sessionToken, authPromise);\n    return authPromise;\n  }\n\n  async _matchesCLP(\n    classLevelPermissions: ?any,\n    object: any,\n    client: any,\n    requestId: number,\n    op: string\n  ): any {\n    // try to match on user first, less expensive than with roles\n    const subscriptionInfo = client.getSubscriptionInfo(requestId);\n    const aclGroup = ['*'];\n    let userId;\n    if (typeof subscriptionInfo !== 'undefined') {\n      const { userId } = await this.getAuthForSessionToken(subscriptionInfo.sessionToken);\n      if (userId) {\n        aclGroup.push(userId);\n      }\n    }\n    try {\n      await SchemaController.validatePermission(\n        classLevelPermissions,\n        object.className,\n        aclGroup,\n        op\n      );\n      return true;\n    } catch (e) {\n      logger.verbose(`Failed matching CLP for ${object.id} ${userId} ${e}`);\n      return false;\n    }\n    // TODO: handle roles permissions\n    // Object.keys(classLevelPermissions).forEach((key) => {\n    //   const perm = classLevelPermissions[key];\n    //   Object.keys(perm).forEach((key) => {\n    //     if (key.indexOf('role'))\n    //   });\n    // })\n    // // it's rejected here, check the roles\n    // var rolesQuery = new Parse.Query(Parse.Role);\n    // rolesQuery.equalTo(\"users\", user);\n    // return rolesQuery.find({useMasterKey:true});\n  }\n\n  async _filterSensitiveData(\n    classLevelPermissions: ?any,\n    res: any,\n    client: any,\n    requestId: number,\n    op: string,\n    query: any\n  ) {\n    const subscriptionInfo = client.getSubscriptionInfo(requestId);\n    const aclGroup = ['*'];\n    let clientAuth;\n    if (typeof subscriptionInfo !== 'undefined') {\n      const { userId, auth } = await this.getAuthForSessionToken(subscriptionInfo.sessionToken);\n      if (userId) {\n        aclGroup.push(userId);\n      }\n      clientAuth = auth;\n    }\n    const filter = obj => {\n      if (!obj) {\n        return;\n      }\n      let protectedFields = classLevelPermissions?.protectedFields || [];\n      if (!client.hasMasterKey && !Array.isArray(protectedFields)) {\n        protectedFields = getDatabaseController(this.config).addProtectedFields(\n          classLevelPermissions,\n          res.object.className,\n          query,\n          aclGroup,\n          clientAuth\n        );\n      }\n      return DatabaseController.filterSensitiveData(\n        client.hasMasterKey,\n        aclGroup,\n        clientAuth,\n        op,\n        classLevelPermissions,\n        res.object.className,\n        protectedFields,\n        obj,\n        query\n      );\n    };\n    res.object = filter(res.object);\n    res.original = filter(res.original);\n  }\n\n  _getCLPOperation(query: any) {\n    return typeof query === 'object' &&\n      Object.keys(query).length == 1 &&\n      typeof query.objectId === 'string'\n      ? 'get'\n      : 'find';\n  }\n\n  async _verifyACL(acl: any, token: string) {\n    if (!token) {\n      return false;\n    }\n\n    const { auth, userId } = await this.getAuthForSessionToken(token);\n\n    // Getting the session token failed\n    // This means that no additional auth is available\n    // At this point, just bail out as no additional visibility can be inferred.\n    if (!auth || !userId) {\n      return false;\n    }\n    const isSubscriptionSessionTokenMatched = acl.getReadAccess(userId);\n    if (isSubscriptionSessionTokenMatched) {\n      return true;\n    }\n\n    // Check if the user has any roles that match the ACL\n    return Promise.resolve()\n      .then(async () => {\n        // Resolve false right away if the acl doesn't have any roles\n        const acl_has_roles = Object.keys(acl.permissionsById).some(key => key.startsWith('role:'));\n        if (!acl_has_roles) {\n          return false;\n        }\n\n        const roleNames = await auth.getUserRoles();\n        // Finally, see if any of the user's roles allow them read access\n        for (const role of roleNames) {\n          // We use getReadAccess as `role` is in the form `role:roleName`\n          if (acl.getReadAccess(role)) {\n            return true;\n          }\n        }\n        return false;\n      })\n      .catch(() => {\n        return false;\n      });\n  }\n\n  async getAuthFromClient(client: any, requestId: number, sessionToken: string) {\n    const getSessionFromClient = () => {\n      const subscriptionInfo = client.getSubscriptionInfo(requestId);\n      if (typeof subscriptionInfo === 'undefined') {\n        return client.sessionToken;\n      }\n      return subscriptionInfo.sessionToken || client.sessionToken;\n    };\n    if (!sessionToken) {\n      sessionToken = getSessionFromClient();\n    }\n    if (!sessionToken) {\n      return;\n    }\n    const { auth } = await this.getAuthForSessionToken(sessionToken);\n    return auth;\n  }\n\n  async _matchesACL(acl: any, client: any, requestId: number): Promise<boolean> {\n    // Return true directly if ACL isn't present, ACL is public read, or client has master key\n    if (!acl || acl.getPublicReadAccess() || client.hasMasterKey) {\n      return true;\n    }\n    // Check subscription sessionToken matches ACL first\n    const subscriptionInfo = client.getSubscriptionInfo(requestId);\n    if (typeof subscriptionInfo === 'undefined') {\n      return false;\n    }\n\n    const subscriptionToken = subscriptionInfo.sessionToken;\n    const clientSessionToken = client.sessionToken;\n\n    if (await this._verifyACL(acl, subscriptionToken)) {\n      return true;\n    }\n\n    if (await this._verifyACL(acl, clientSessionToken)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  async _handleConnect(parseWebsocket: any, request: any): any {\n    if (!this._validateKeys(request, this.keyPairs)) {\n      Client.pushError(parseWebsocket, 4, 'Key in request is not valid');\n      logger.error('Key in request is not valid');\n      return;\n    }\n    const hasMasterKey = this._hasMasterKey(request, this.keyPairs);\n    const clientId = uuidv4();\n    const client = new Client(\n      clientId,\n      parseWebsocket,\n      hasMasterKey,\n      request.sessionToken,\n      request.installationId\n    );\n    try {\n      const req = {\n        client,\n        event: 'connect',\n        clients: this.clients.size,\n        subscriptions: this.subscriptions.size,\n        sessionToken: request.sessionToken,\n        useMasterKey: client.hasMasterKey,\n        installationId: request.installationId,\n      };\n      const trigger = getTrigger('@Connect', 'beforeConnect', Parse.applicationId);\n      if (trigger) {\n        const auth = await this.getAuthFromClient(client, request.requestId, req.sessionToken);\n        if (auth && auth.user) {\n          req.user = auth.user;\n        }\n        await runTrigger(trigger, `beforeConnect.@Connect`, req, auth);\n      }\n      parseWebsocket.clientId = clientId;\n      this.clients.set(parseWebsocket.clientId, client);\n      logger.info(`Create new client: ${parseWebsocket.clientId}`);\n      client.pushConnect();\n      runLiveQueryEventHandlers(req);\n    } catch (e) {\n      const error = resolveError(e);\n      Client.pushError(parseWebsocket, error.code, error.message, false);\n      logger.error(\n        `Failed running beforeConnect for session ${request.sessionToken} with:\\n Error: ` +\n          JSON.stringify(error)\n      );\n    }\n  }\n\n  _hasMasterKey(request: any, validKeyPairs: any): boolean {\n    if (!validKeyPairs || validKeyPairs.size == 0 || !validKeyPairs.has('masterKey')) {\n      return false;\n    }\n    if (!request || !Object.prototype.hasOwnProperty.call(request, 'masterKey')) {\n      return false;\n    }\n    return request.masterKey === validKeyPairs.get('masterKey');\n  }\n\n  _validateKeys(request: any, validKeyPairs: any): boolean {\n    if (!validKeyPairs || validKeyPairs.size == 0) {\n      return true;\n    }\n    let isValid = false;\n    for (const [key, secret] of validKeyPairs) {\n      if (!request[key] || request[key] !== secret) {\n        continue;\n      }\n      isValid = true;\n      break;\n    }\n    return isValid;\n  }\n\n  async _handleSubscribe(parseWebsocket: any, request: any): any {\n    // If we can not find this client, return error to client\n    if (!Object.prototype.hasOwnProperty.call(parseWebsocket, 'clientId')) {\n      Client.pushError(\n        parseWebsocket,\n        2,\n        'Can not find this client, make sure you connect to server before subscribing'\n      );\n      logger.error('Can not find this client, make sure you connect to server before subscribing');\n      return;\n    }\n    const client = this.clients.get(parseWebsocket.clientId);\n    const className = request.query.className;\n    let authCalled = false;\n    try {\n      const trigger = getTrigger(className, 'beforeSubscribe', Parse.applicationId);\n      if (trigger) {\n        const auth = await this.getAuthFromClient(client, request.requestId, request.sessionToken);\n        authCalled = true;\n        if (auth && auth.user) {\n          request.user = auth.user;\n        }\n\n        const parseQuery = new Parse.Query(className);\n        parseQuery.withJSON(request.query);\n        request.query = parseQuery;\n        await runTrigger(trigger, `beforeSubscribe.${className}`, request, auth);\n\n        const query = request.query.toJSON();\n        if (query.keys) {\n          query.fields = query.keys.split(',');\n        }\n        request.query = query;\n      }\n\n      if (className === '_Session') {\n        if (!authCalled) {\n          const auth = await this.getAuthFromClient(\n            client,\n            request.requestId,\n            request.sessionToken\n          );\n          if (auth && auth.user) {\n            request.user = auth.user;\n          }\n        }\n        if (request.user) {\n          request.query.where.user = request.user.toPointer();\n        } else if (!request.master) {\n          Client.pushError(\n            parseWebsocket,\n            Parse.Error.INVALID_SESSION_TOKEN,\n            'Invalid session token',\n            false,\n            request.requestId\n          );\n          return;\n        }\n      }\n      // Get subscription from subscriptions, create one if necessary\n      const subscriptionHash = queryHash(request.query);\n      // Add className to subscriptions if necessary\n\n      if (!this.subscriptions.has(className)) {\n        this.subscriptions.set(className, new Map());\n      }\n      const classSubscriptions = this.subscriptions.get(className);\n      let subscription;\n      if (classSubscriptions.has(subscriptionHash)) {\n        subscription = classSubscriptions.get(subscriptionHash);\n      } else {\n        subscription = new Subscription(className, request.query.where, subscriptionHash);\n        classSubscriptions.set(subscriptionHash, subscription);\n      }\n\n      // Add subscriptionInfo to client\n      const subscriptionInfo = {\n        subscription: subscription,\n      };\n      // Add selected fields, sessionToken and installationId for this subscription if necessary\n      if (request.query.fields) {\n        subscriptionInfo.fields = request.query.fields;\n      }\n      if (request.sessionToken) {\n        subscriptionInfo.sessionToken = request.sessionToken;\n      }\n      client.addSubscriptionInfo(request.requestId, subscriptionInfo);\n\n      // Add clientId to subscription\n      subscription.addClientSubscription(parseWebsocket.clientId, request.requestId);\n\n      client.pushSubscribe(request.requestId);\n\n      logger.verbose(\n        `Create client ${parseWebsocket.clientId} new subscription: ${request.requestId}`\n      );\n      logger.verbose('Current client number: %d', this.clients.size);\n      runLiveQueryEventHandlers({\n        client,\n        event: 'subscribe',\n        clients: this.clients.size,\n        subscriptions: this.subscriptions.size,\n        sessionToken: request.sessionToken,\n        useMasterKey: client.hasMasterKey,\n        installationId: client.installationId,\n      });\n    } catch (e) {\n      const error = resolveError(e);\n      Client.pushError(parseWebsocket, error.code, error.message, false, request.requestId);\n      logger.error(\n        `Failed running beforeSubscribe on ${className} for session ${request.sessionToken} with:\\n Error: ` +\n          JSON.stringify(error)\n      );\n    }\n  }\n\n  _handleUpdateSubscription(parseWebsocket: any, request: any): any {\n    this._handleUnsubscribe(parseWebsocket, request, false);\n    this._handleSubscribe(parseWebsocket, request);\n  }\n\n  _handleUnsubscribe(parseWebsocket: any, request: any, notifyClient: boolean = true): any {\n    // If we can not find this client, return error to client\n    if (!Object.prototype.hasOwnProperty.call(parseWebsocket, 'clientId')) {\n      Client.pushError(\n        parseWebsocket,\n        2,\n        'Can not find this client, make sure you connect to server before unsubscribing'\n      );\n      logger.error(\n        'Can not find this client, make sure you connect to server before unsubscribing'\n      );\n      return;\n    }\n    const requestId = request.requestId;\n    const client = this.clients.get(parseWebsocket.clientId);\n    if (typeof client === 'undefined') {\n      Client.pushError(\n        parseWebsocket,\n        2,\n        'Cannot find client with clientId ' +\n          parseWebsocket.clientId +\n          '. Make sure you connect to live query server before unsubscribing.'\n      );\n      logger.error('Can not find this client ' + parseWebsocket.clientId);\n      return;\n    }\n\n    const subscriptionInfo = client.getSubscriptionInfo(requestId);\n    if (typeof subscriptionInfo === 'undefined') {\n      Client.pushError(\n        parseWebsocket,\n        2,\n        'Cannot find subscription with clientId ' +\n          parseWebsocket.clientId +\n          ' subscriptionId ' +\n          requestId +\n          '. Make sure you subscribe to live query server before unsubscribing.'\n      );\n      logger.error(\n        'Can not find subscription with clientId ' +\n          parseWebsocket.clientId +\n          ' subscriptionId ' +\n          requestId\n      );\n      return;\n    }\n\n    // Remove subscription from client\n    client.deleteSubscriptionInfo(requestId);\n    // Remove client from subscription\n    const subscription = subscriptionInfo.subscription;\n    const className = subscription.className;\n    subscription.deleteClientSubscription(parseWebsocket.clientId, requestId);\n    // If there is no client which is subscribing this subscription, remove it from subscriptions\n    const classSubscriptions = this.subscriptions.get(className);\n    if (!subscription.hasSubscribingClient()) {\n      classSubscriptions.delete(subscription.hash);\n    }\n    // If there is no subscriptions under this class, remove it from subscriptions\n    if (classSubscriptions.size === 0) {\n      this.subscriptions.delete(className);\n    }\n    runLiveQueryEventHandlers({\n      client,\n      event: 'unsubscribe',\n      clients: this.clients.size,\n      subscriptions: this.subscriptions.size,\n      sessionToken: subscriptionInfo.sessionToken,\n      useMasterKey: client.hasMasterKey,\n      installationId: client.installationId,\n    });\n\n    if (!notifyClient) {\n      return;\n    }\n\n    client.pushUnsubscribe(request.requestId);\n\n    logger.verbose(\n      `Delete client: ${parseWebsocket.clientId} | subscription: ${request.requestId}`\n    );\n  }\n}\n\nexport { ParseLiveQueryServer };\n"], "filenames": ["spec/ParseLiveQuery.spec.js", "src/Controllers/DatabaseController.js", "src/LiveQuery/ParseCloudCodePublisher.js", "src/LiveQuery/ParseLiveQueryServer.js"], "buggy_code_start_loc": [1068, 130, 35, 13], "buggy_code_end_loc": [1068, 1813, 35, 540], "fixing_code_start_loc": [1069, 130, 36, 13], "fixing_code_end_loc": [1115, 1820, 39, 594], "type": "CWE-200", "message": "Parse Server is an open source backend that can be deployed to any infrastructure that can run Node.js. In affected versions parse Server LiveQuery does not remove protected fields in classes, passing them to the client. The LiveQueryController now removes protected fields from the client response. Users are advised to upgrade. Users unable t upgrade should use `Parse.Cloud.afterLiveQueryEvent` to manually remove protected fields.", "other": {"cve": {"id": "CVE-2022-31112", "sourceIdentifier": "security-advisories@github.com", "published": "2022-06-30T17:15:07.977", "lastModified": "2022-07-11T17:16:10.613", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Parse Server is an open source backend that can be deployed to any infrastructure that can run Node.js. In affected versions parse Server LiveQuery does not remove protected fields in classes, passing them to the client. The LiveQueryController now removes protected fields from the client response. Users are advised to upgrade. Users unable t upgrade should use `Parse.Cloud.afterLiveQueryEvent` to manually remove protected fields."}, {"lang": "es", "value": "Parse Server es un backend de c\u00f3digo abierto que puede ser desplegado en cualquier infraestructura que pueda ejecutar Node.js. En versiones afectadas, Parse Server LiveQuery no elimina los campos protegidos en las clases, pas\u00e1ndolos al cliente. El LiveQueryController ahora elimina los campos protegidos de la respuesta del cliente. Es recomendado a usuarios actualizar. Los usuarios que no puedan actualizar deber\u00e1n usar \"Parse.Cloud.afterLiveQueryEvent\" para eliminar manualmente los campos protegidos"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:parseplatform:parse-server:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "4.10.13", "matchCriteriaId": "9C3D4EDC-0BE1-411C-93E3-2351A4E7B3D6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:parseplatform:parse-server:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.2.4", "matchCriteriaId": "19505592-808A-437A-8893-FA009C4CA575"}]}]}], "references": [{"url": "https://github.com/parse-community/parse-server/commit/309f64ced8700321df056fb3cc97f15007a00df1", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/parse-community/parse-server/commit/9fd4516cde5c742f9f29dd05468b4a43a85639a6", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/parse-community/parse-server/issues/8073", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch", "Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/parse-community/parse-server/pull/8074", "source": "security-advisories@github.com", "tags": ["Patch", "Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/parse-community/parse-server/releases/tag/5.2.4", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/parse-community/parse-server/security/advisories/GHSA-crrq-vr9j-fxxh", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/parse-community/parse-server/commit/309f64ced8700321df056fb3cc97f15007a00df1"}}