{"buggy_code": ["// SPDX-FileCopyrightText: 2016-2020 c0riolis\n// SPDX-FileCopyrightText: 2016-2020 Tardy\n// SPDX-FileCopyrightText: 2016-2020 l0stb1t\n// SPDX-License-Identifier: LGPL-3.0-only\n\n#include <rz_io.h>\n#include <rz_bin.h>\n#include \"marshal.h\"\n#include \"pyc_magic.h\"\n\n// avoiding using rizin internals asserts\n#define if_true_return(cond, ret) \\\n\tif (cond) { \\\n\t\treturn (ret); \\\n\t}\n\nstatic pyc_object *get_object(RzBinPycObj *pyc, RzBuffer *buffer);\nstatic pyc_object *copy_object(pyc_object *object);\nstatic void free_object(pyc_object *object);\n\nstatic ut8 get_ut8(RzBuffer *buffer, bool *error) {\n\tut8 ret = 0;\n\tint size = rz_buf_read(buffer, &ret, sizeof(ret));\n\tif (size < sizeof(ret)) {\n\t\t*error = true;\n\t}\n\treturn ret;\n}\n\nstatic ut16 get_ut16(RzBuffer *buffer, bool *error) {\n\tut16 ret = 0;\n\n\tif (!rz_buf_read_le16(buffer, &ret)) {\n\t\t*error = true;\n\t}\n\treturn ret;\n}\n\nstatic ut32 get_ut32(RzBuffer *buffer, bool *error) {\n\tut32 ret = 0;\n\tif (!rz_buf_read_le32(buffer, &ret)) {\n\t\t*error = true;\n\t}\n\treturn ret;\n}\n\nstatic st32 get_st32(RzBuffer *buffer, bool *error) {\n\tst32 ret = 0;\n\tif (!rz_buf_read_le32(buffer, (ut32 *)&ret)) {\n\t\t*error = true;\n\t}\n\treturn ret;\n}\n\nstatic st64 get_st64(RzBuffer *buffer, bool *error) {\n\tst64 ret = 0;\n\tif (!rz_buf_read_le64(buffer, (ut64 *)&ret)) {\n\t\t*error = true;\n\t}\n\treturn ret;\n}\n\nstatic double get_float64(RzBuffer *buffer, bool *error) {\n\tdouble ret = 0;\n\tif (!rz_buf_read_le64(buffer, (ut64 *)&ret)) {\n\t\t*error = true;\n\t}\n\treturn ret;\n}\n\nstatic ut8 *get_bytes(RzBuffer *buffer, ut32 size) {\n\tut8 *ret = RZ_NEWS0(ut8, size + 1);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tif (rz_buf_read(buffer, ret, size) < size) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_none_object(void) {\n\tpyc_object *ret;\n\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_NONE;\n\tret->data = strdup(\"None\");\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_false_object(void) {\n\tpyc_object *ret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_FALSE;\n\tret->data = strdup(\"False\");\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_true_object(void) {\n\tpyc_object *ret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_TRUE;\n\tret->data = strdup(\"True\");\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_int_object(RzBuffer *buffer) {\n\tbool error = false;\n\tpyc_object *ret = NULL;\n\n\tst32 i = get_st32(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_INT;\n\tret->data = rz_str_newf(\"%d\", i);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_int64_object(RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tst64 i;\n\n\ti = get_st64(buffer, &error);\n\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_INT64;\n\tret->data = rz_str_newf(\"%lld\", i);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t}\n\treturn ret;\n}\n\n/* long is used when the number is > MAX_INT64 */\nstatic pyc_object *get_long_object(RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tbool neg = false;\n\tut32 tmp = 0;\n\tsize_t size;\n\tsize_t i, j = 0, left = 0;\n\tut32 n;\n\tchar *hexstr;\n\tchar digist2hex[] = \"0123456789abcdef\";\n\n\tst32 ndigits = get_st32(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_LONG;\n\tif (ndigits < 0) {\n\t\tndigits = -ndigits;\n\t\tneg = true;\n\t}\n\tif (ndigits == 0) {\n\t\tret->data = strdup(\"0x0\");\n\t} else {\n\t\t// the explicit cast is safe since ndigits is positive\n\t\tsize = (size_t)ndigits * 15;\n\t\tsize = (size - 1) / 4 + 1;\n\t\tsize += 4 + (neg ? 1 : 0);\n\t\thexstr = malloc(size);\n\t\tif (!hexstr) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tmemset(hexstr, 0x20, size);\n\t\tj = size - 1;\n\t\thexstr[j] = 0;\n\t\tfor (i = 0; i < ndigits; i++) {\n\t\t\tn = get_ut16(buffer, &error);\n\t\t\ttmp |= n << left;\n\t\t\tleft += 15;\n\n\t\t\twhile (left >= 4) {\n\t\t\t\thexstr[--j] = digist2hex[tmp & 0xf];\n\t\t\t\ttmp >>= 4;\n\t\t\t\tleft -= 4;\n\t\t\t}\n\t\t}\n\n\t\tif (tmp) {\n\t\t\thexstr[--j] = digist2hex[tmp & 0xf];\n\t\t}\n\n\t\thexstr[--j] = 'x';\n\t\thexstr[--j] = '0';\n\t\tif (neg) {\n\t\t\thexstr[--j] = '-';\n\t\t}\n\n\t\trz_str_trim(hexstr);\n\t\tret->data = hexstr;\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_stringref_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_st32(buffer, &error);\n\tif (n >= rz_list_length(pyc->interned_table)) {\n\t\tRZ_LOG_ERROR(\"bad marshal data (string ref out of range)\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_STRINGREF;\n\tret->data = rz_list_get_n(pyc->interned_table, n);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_float_object(RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 size = 0;\n\tut8 n = 0;\n\n\tn = get_ut8(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tut8 *s = malloc(n + 1);\n\tif (!s) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\t/* object contain string representation of the number */\n\tsize = rz_buf_read(buffer, s, n);\n\tif (size != n) {\n\t\tRZ_FREE(s);\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\ts[n] = '\\0';\n\tret->type = TYPE_FLOAT;\n\tret->data = s;\n\treturn ret;\n}\n\nstatic pyc_object *get_binary_float_object(RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tdouble f;\n\n\tf = get_float64(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_FLOAT;\n\tret->data = rz_str_newf(\"%.15g\", f);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_complex_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 size = 0;\n\tut32 n1 = 0;\n\tut32 n2 = 0;\n\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tif ((pyc->magic_int & 0xffff) <= 62061) {\n\t\tn1 = get_ut8(buffer, &error);\n\t} else {\n\t\tn1 = get_st32(buffer, &error);\n\t}\n\tif (error) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tut8 *s1 = malloc(n1 + 1);\n\tif (!s1) {\n\t\treturn NULL;\n\t}\n\t/* object contain string representation of the number */\n\tsize = rz_buf_read(buffer, s1, n1);\n\tif (size != n1) {\n\t\tRZ_FREE(s1);\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\ts1[n1] = '\\0';\n\n\tif ((pyc->magic_int & 0xffff) <= 62061) {\n\t\tn2 = get_ut8(buffer, &error);\n\t} else\n\t\tn2 = get_st32(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tut8 *s2 = malloc(n2 + 1);\n\tif (!s2) {\n\t\treturn NULL;\n\t}\n\t/* object contain string representation of the number */\n\tsize = rz_buf_read(buffer, s2, n2);\n\tif (size != n2) {\n\t\tRZ_FREE(s1);\n\t\tRZ_FREE(s2);\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\ts2[n2] = '\\0';\n\n\tret->type = TYPE_COMPLEX;\n\tret->data = rz_str_newf(\"%s+%sj\", s1, s2);\n\tRZ_FREE(s1);\n\tRZ_FREE(s2);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_binary_complex_object(RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tdouble a, b;\n\n\t// a + bj\n\ta = get_float64(buffer, &error);\n\tb = get_float64(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_BINARY_COMPLEX;\n\tret->data = rz_str_newf(\"%.15g+%.15gj\", a, b);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_string_object(RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32(buffer, &error);\n\tif (n > ST32_MAX) {\n\t\tRZ_LOG_ERROR(\"bad marshal data (string size out of range)\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_STRING;\n\tret->data = get_bytes(buffer, n);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_unicode_object(RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32(buffer, &error);\n\tif (n > ST32_MAX) {\n\t\tRZ_LOG_ERROR(\"bad marshal data (unicode size out of range)\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = RZ_NEW0(pyc_object);\n\tret->type = TYPE_UNICODE;\n\tret->data = get_bytes(buffer, n);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_interned_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32(buffer, &error);\n\tif (n > ST32_MAX) {\n\t\tRZ_LOG_ERROR(\"bad marshal data (string size out of range)\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_INTERNED;\n\tret->data = get_bytes(buffer, n);\n\t/* add data pointer to interned table */\n\trz_list_append(pyc->interned_table, ret->data);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_array_object_generic(RzBinPycObj *pyc, RzBuffer *buffer, ut32 size) {\n\tpyc_object *tmp = NULL;\n\tpyc_object *ret = NULL;\n\tut32 i = 0;\n\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->data = rz_list_newf((RzListFree)free_object);\n\tif (!ret->data) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < size; i++) {\n\t\ttmp = get_object(pyc, buffer);\n\t\tif (!tmp) {\n\t\t\trz_list_free(ret->data);\n\t\t\tRZ_FREE(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!rz_list_append(ret->data, tmp)) {\n\t\t\tfree_object(tmp);\n\t\t\trz_list_free(ret->data);\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn ret;\n}\n\n/* small TYPE_SMALL_TUPLE doesn't exist in python2 */\n/* */\nstatic pyc_object *get_small_tuple_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut8 n = 0;\n\n\tn = get_ut8(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic(pyc, buffer, n);\n\tif (ret) {\n\t\tret->type = TYPE_SMALL_TUPLE;\n\t\treturn ret;\n\t}\n\treturn NULL;\n}\n\nstatic pyc_object *get_tuple_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32(buffer, &error);\n\tif (n > ST32_MAX) {\n\t\tRZ_LOG_ERROR(\"bad marshal data (tuple size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic(pyc, buffer, n);\n\tif (ret) {\n\t\tret->type = TYPE_TUPLE;\n\t\treturn ret;\n\t}\n\treturn NULL;\n}\n\nstatic pyc_object *get_list_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32(buffer, &error);\n\tif (n > ST32_MAX) {\n\t\tRZ_LOG_ERROR(\"bad marshal data (list size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic(pyc, buffer, n);\n\tif (ret) {\n\t\tret->type = TYPE_LIST;\n\t\treturn ret;\n\t}\n\treturn NULL;\n}\n\nstatic pyc_object *get_dict_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tpyc_object *ret = NULL,\n\t\t   *key = NULL,\n\t\t   *val = NULL;\n\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->data = rz_list_newf((RzListFree)free_object);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\tfor (;;) {\n\t\tkey = get_object(pyc, buffer);\n\t\tif (!key) {\n\t\t\tbreak;\n\t\t}\n\t\tif (!rz_list_append(ret->data, key)) {\n\t\t\trz_list_free(ret->data);\n\t\t\tRZ_FREE(ret);\n\t\t\tfree_object(key);\n\t\t\treturn NULL;\n\t\t}\n\t\tval = get_object(pyc, buffer);\n\t\tif (!val) {\n\t\t\tbreak;\n\t\t}\n\t\tif (!rz_list_append(ret->data, val)) {\n\t\t\trz_list_free(ret->data);\n\t\t\tRZ_FREE(ret);\n\t\t\tfree_object(val);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tret->type = TYPE_DICT;\n\treturn ret;\n}\n\nstatic pyc_object *get_set_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32(buffer, &error);\n\tif (n > ST32_MAX) {\n\t\tRZ_LOG_ERROR(\"bad marshal data (set size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic(pyc, buffer, n);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_SET;\n\treturn ret;\n}\n\nstatic pyc_object *get_ascii_object_generic(RzBuffer *buffer, ut32 size, bool interned) {\n\tpyc_object *ret = NULL;\n\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_ASCII;\n\tret->data = get_bytes(buffer, size);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_ascii_object(RzBuffer *buffer) {\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\treturn get_ascii_object_generic(buffer, n, true);\n}\n\nstatic pyc_object *get_ascii_interned_object(RzBuffer *buffer) {\n\tbool error = false;\n\tut32 n;\n\n\tn = get_ut32(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\treturn get_ascii_object_generic(buffer, n, true);\n}\n\nstatic pyc_object *get_short_ascii_object(RzBuffer *buffer) {\n\tbool error = false;\n\tut8 n;\n\n\tn = get_ut8(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\treturn get_ascii_object_generic(buffer, n, false);\n}\n\nstatic pyc_object *get_short_ascii_interned_object(RzBuffer *buffer) {\n\tbool error = false;\n\tut8 n;\n\n\tn = get_ut8(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\treturn get_ascii_object_generic(buffer, n, true);\n}\n\nstatic pyc_object *get_ref_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tbool error = false;\n\tpyc_object *ret;\n\tpyc_object *obj;\n\tut32 index;\n\n\tindex = get_ut32(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tif (index >= rz_list_length(pyc->refs)) {\n\t\treturn NULL;\n\t}\n\tobj = rz_list_get_n(pyc->refs, index);\n\tif (!obj) {\n\t\treturn NULL;\n\t}\n\tret = copy_object(obj);\n\treturn ret;\n}\n\nstatic void free_object(pyc_object *object) {\n\tif (!object) {\n\t\treturn;\n\t}\n\tswitch (object->type) {\n\tcase TYPE_SMALL_TUPLE:\n\tcase TYPE_TUPLE:\n\t\trz_list_free(object->data);\n\t\tbreak;\n\tcase TYPE_STRING:\n\tcase TYPE_TRUE:\n\tcase TYPE_FALSE:\n\tcase TYPE_INT:\n\tcase TYPE_NONE:\n\tcase TYPE_NULL:\n\tcase TYPE_ASCII_INTERNED:\n\tcase TYPE_SHORT_ASCII:\n\tcase TYPE_ASCII:\n\tcase TYPE_SHORT_ASCII_INTERNED:\n\t\tfree(object->data);\n\t\tbreak;\n\tcase TYPE_CODE_v0:\n\tcase TYPE_CODE_v1: {\n\t\tpyc_code_object *cobj = object->data;\n\t\tfree_object(cobj->code);\n\t\tfree_object(cobj->consts);\n\t\tfree_object(cobj->names);\n\t\tfree_object(cobj->varnames);\n\t\tfree_object(cobj->freevars);\n\t\tfree_object(cobj->cellvars);\n\t\tfree_object(cobj->filename);\n\t\tfree_object(cobj->name);\n\t\tfree_object(cobj->lnotab);\n\t\tfree(object->data);\n\t} break;\n\tcase TYPE_REF:\n\t\tfree_object(object->data);\n\t\tbreak;\n\tcase TYPE_SET:\n\tcase TYPE_FROZENSET:\n\tcase TYPE_ELLIPSIS:\n\tcase TYPE_STOPITER:\n\tcase TYPE_BINARY_COMPLEX:\n\tcase TYPE_BINARY_FLOAT:\n\tcase TYPE_COMPLEX:\n\tcase TYPE_STRINGREF:\n\tcase TYPE_DICT:\n\tcase TYPE_FLOAT:\n\tcase TYPE_INT64:\n\tcase TYPE_INTERNED:\n\tcase TYPE_LIST:\n\tcase TYPE_LONG:\n\tcase TYPE_UNICODE:\n\tcase TYPE_UNKNOWN:\n\t\tRZ_LOG_ERROR(\"Free not implemented for type %x\\n\", object->type);\n\t\tbreak;\n\tdefault:\n\t\tRZ_LOG_ERROR(\"Undefined type in free_object (%x)\\n\", object->type);\n\t\tbreak;\n\t}\n\tfree(object);\n}\n\nstatic pyc_object *copy_object(pyc_object *object) {\n\tpyc_object *copy = RZ_NEW0(pyc_object);\n\tif (!copy || !object) {\n\t\tfree(copy);\n\t\treturn NULL;\n\t}\n\tcopy->type = object->type;\n\tswitch (object->type) {\n\tcase TYPE_NULL:\n\t\tbreak;\n\tcase TYPE_TUPLE:\n\tcase TYPE_SMALL_TUPLE:\n\t\tcopy->data = rz_list_clone(object->data);\n\t\tbreak;\n\tcase TYPE_INT:\n\tcase TYPE_INT64:\n\tcase TYPE_NONE:\n\tcase TYPE_TRUE:\n\tcase TYPE_FALSE:\n\tcase TYPE_STRING:\n\tcase TYPE_ASCII:\n\tcase TYPE_SHORT_ASCII:\n\tcase TYPE_ASCII_INTERNED:\n\tcase TYPE_SHORT_ASCII_INTERNED:\n\t\tcopy->data = strdup(object->data);\n\t\tbreak;\n\tcase TYPE_CODE_v0:\n\tcase TYPE_CODE_v1: {\n\t\tpyc_code_object *src = object->data;\n\t\tpyc_code_object *dst = RZ_NEW0(pyc_code_object);\n\t\tif (!dst) {\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(dst, src, sizeof(*dst));\n\t\tdst->code = copy_object(src->code);\n\t\tdst->consts = copy_object(src->consts);\n\t\tdst->names = copy_object(src->names);\n\t\tdst->varnames = copy_object(src->varnames);\n\t\tdst->freevars = copy_object(src->freevars);\n\t\tdst->cellvars = copy_object(src->cellvars);\n\t\tdst->filename = copy_object(src->filename);\n\t\tdst->name = copy_object(src->name);\n\t\tdst->lnotab = copy_object(src->lnotab);\n\t\tcopy->data = dst;\n\t} break;\n\tcase TYPE_REF:\n\t\tcopy->data = copy_object(object->data);\n\t\tbreak;\n\tcase TYPE_ELLIPSIS:\n\tcase TYPE_STOPITER:\n\tcase TYPE_BINARY_COMPLEX:\n\tcase TYPE_BINARY_FLOAT:\n\tcase TYPE_COMPLEX:\n\tcase TYPE_STRINGREF:\n\tcase TYPE_DICT:\n\tcase TYPE_FLOAT:\n\tcase TYPE_FROZENSET:\n\tcase TYPE_INTERNED:\n\tcase TYPE_LIST:\n\tcase TYPE_LONG:\n\tcase TYPE_SET:\n\tcase TYPE_UNICODE:\n\tcase TYPE_UNKNOWN:\n\t\tRZ_LOG_ERROR(\"Copy not implemented for type %x\\n\", object->type);\n\t\tbreak;\n\tdefault:\n\t\tRZ_LOG_ERROR(\"Undefined type in copy_object (%x)\\n\", object->type);\n\t\tbreak;\n\t}\n\tif (!copy->data) {\n\t\tRZ_FREE(copy);\n\t}\n\treturn copy;\n}\n\nstatic pyc_object *get_code_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tbool error = false;\n\n\tpyc_object *ret = RZ_NEW0(pyc_object);\n\tpyc_code_object *cobj = RZ_NEW0(pyc_code_object);\n\tif (!ret || !cobj) {\n\t\tfree(ret);\n\t\tfree(cobj);\n\t\treturn NULL;\n\t}\n\n\t// ret->type = TYPE_CODE_v1;\n\t//  support start from v1.0\n\tret->data = cobj;\n\n\tbool v10_to_12 = magic_int_within(pyc->magic_int, 39170, 16679, &error); // 1.0.1 - 1.2\n\tbool v13_to_22 = magic_int_within(pyc->magic_int, 11913, 60718, &error); // 1.3b1 - 2.2a1\n\tbool v11_to_14 = magic_int_within(pyc->magic_int, 39170, 20117, &error); // 1.0.1 - 1.4\n\tbool v15_to_22 = magic_int_within(pyc->magic_int, 20121, 60718, &error); // 1.5a1 - 2.2a1\n\tbool v13_to_20 = magic_int_within(pyc->magic_int, 11913, 50824, &error); // 1.3b1 - 2.0b1\n\t// bool v21_to_27 = (!v13_to_20) && magic_int_within (magic_int, 60124, 62212, &error);\n\tbool has_posonlyargcount = magic_int_within(pyc->magic_int, 3410, 3424, &error); // v3.8.0a4 - latest\n\tif (error) {\n\t\tfree(ret);\n\t\tfree(cobj);\n\t\treturn NULL;\n\t}\n\n\tif (v13_to_22) {\n\t\tcobj->argcount = get_ut16(buffer, &error);\n\t} else if (v10_to_12) {\n\t\tcobj->argcount = 0;\n\t} else {\n\t\tcobj->argcount = get_ut32(buffer, &error);\n\t}\n\n\tif (has_posonlyargcount) {\n\t\tcobj->posonlyargcount = get_ut32(buffer, &error); // Included in argcount\n\t} else {\n\t\tcobj->posonlyargcount = 0; // None\n\t}\n\n\tif (((3020 < (pyc->magic_int & 0xffff)) && ((pyc->magic_int & 0xffff) < 20121)) && (!v11_to_14)) {\n\t\tcobj->kwonlyargcount = get_ut32(buffer, &error); // Not included in argcount\n\t} else {\n\t\tcobj->kwonlyargcount = 0;\n\t}\n\n\tif (v13_to_22) {\n\t\tcobj->nlocals = get_ut16(buffer, &error);\n\t} else if (v10_to_12) {\n\t\tcobj->nlocals = 0;\n\t} else {\n\t\tcobj->nlocals = get_ut32(buffer, &error);\n\t}\n\n\tif (v15_to_22) {\n\t\tcobj->stacksize = get_ut16(buffer, &error);\n\t} else if (v11_to_14 || v10_to_12) {\n\t\tcobj->stacksize = 0;\n\t} else {\n\t\tcobj->stacksize = get_ut32(buffer, &error);\n\t}\n\n\tif (v13_to_22) {\n\t\tcobj->flags = get_ut16(buffer, &error);\n\t} else if (v10_to_12) {\n\t\tcobj->flags = 0;\n\t} else {\n\t\tcobj->flags = get_ut32(buffer, &error);\n\t}\n\n\t// to help disassemble the code\n\tcobj->start_offset = rz_buf_tell(buffer) + 5; // 1 from get_object() and 4 from get_string_object()\n\tif (!pyc->refs) {\n\t\treturn ret; // return for entried part to get the root object of this file\n\t}\n\tcobj->code = get_object(pyc, buffer);\n\tcobj->end_offset = rz_buf_tell(buffer);\n\n\tcobj->consts = get_object(pyc, buffer);\n\tcobj->names = get_object(pyc, buffer);\n\n\tif (v10_to_12) {\n\t\tcobj->varnames = NULL;\n\t} else {\n\t\tcobj->varnames = get_object(pyc, buffer);\n\t}\n\n\tif (!(v10_to_12 || v13_to_20)) {\n\t\tcobj->freevars = get_object(pyc, buffer);\n\t\tcobj->cellvars = get_object(pyc, buffer);\n\t} else {\n\t\tcobj->freevars = NULL;\n\t\tcobj->cellvars = NULL;\n\t}\n\n\tcobj->filename = get_object(pyc, buffer);\n\tcobj->name = get_object(pyc, buffer);\n\n\tif (v15_to_22) {\n\t\tcobj->firstlineno = get_ut16(buffer, &error);\n\t} else if (v11_to_14) {\n\t\tcobj->firstlineno = 0;\n\t} else {\n\t\tcobj->firstlineno = get_ut32(buffer, &error);\n\t}\n\n\tif (v11_to_14) {\n\t\tcobj->lnotab = NULL;\n\t} else {\n\t\tcobj->lnotab = get_object(pyc, buffer);\n\t}\n\n\tif (error) {\n\t\tfree_object(cobj->code);\n\t\tfree_object(cobj->consts);\n\t\tfree_object(cobj->names);\n\t\tfree_object(cobj->varnames);\n\t\tfree_object(cobj->freevars);\n\t\tfree_object(cobj->cellvars);\n\t\tfree_object(cobj->filename);\n\t\tfree_object(cobj->name);\n\t\tfree_object(cobj->lnotab);\n\t\tfree(cobj);\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nut64 get_code_object_addr(RzBinPycObj *pyc, RzBuffer *buffer, ut32 magic) {\n\tpyc->magic_int = magic;\n\tpyc_object *co = get_code_object(pyc, buffer);\n\tut64 result = 0;\n\tif (!co) {\n\t\treturn 0;\n\t}\n\n\tpyc_code_object *cobj = co->data;\n\tresult = cobj->start_offset;\n\tfree_object(co);\n\n\treturn result;\n}\n\nstatic pyc_object *get_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tbool error = false;\n\tpyc_object *ret = NULL;\n\tut8 code = get_ut8(buffer, &error);\n\tut8 flag = code & FLAG_REF;\n\tRzListIter *ref_idx = NULL;\n\tut8 type = code & ~FLAG_REF;\n\n\tif (error) {\n\t\treturn NULL;\n\t}\n\n\tif (flag) {\n\t\tret = get_none_object();\n\t\tif (!ret) {\n\t\t\treturn NULL;\n\t\t}\n\t\tref_idx = rz_list_append(pyc->refs, ret);\n\t\tif (!ref_idx) {\n\t\t\tfree_object(ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tswitch (type) {\n\tcase TYPE_NULL:\n\t\treturn NULL;\n\tcase TYPE_TRUE:\n\t\treturn get_true_object();\n\tcase TYPE_FALSE:\n\t\treturn get_false_object();\n\tcase TYPE_NONE:\n\t\treturn get_none_object();\n\tcase TYPE_REF:\n\t\treturn get_ref_object(pyc, buffer);\n\tcase TYPE_SMALL_TUPLE:\n\t\tret = get_small_tuple_object(pyc, buffer);\n\t\tbreak;\n\tcase TYPE_TUPLE:\n\t\tret = get_tuple_object(pyc, buffer);\n\t\tbreak;\n\tcase TYPE_STRING:\n\t\tret = get_string_object(buffer);\n\t\tbreak;\n\tcase TYPE_CODE_v0:\n\t\tret = get_code_object(pyc, buffer);\n\t\tif (ret) {\n\t\t\tret->type = TYPE_CODE_v0;\n\t\t}\n\t\tbreak;\n\tcase TYPE_CODE_v1:\n\t\tret = get_code_object(pyc, buffer);\n\t\tif (ret) {\n\t\t\tret->type = TYPE_CODE_v1;\n\t\t}\n\t\tbreak;\n\tcase TYPE_INT:\n\t\tret = get_int_object(buffer);\n\t\tbreak;\n\tcase TYPE_ASCII_INTERNED:\n\t\tret = get_ascii_interned_object(buffer);\n\t\tbreak;\n\tcase TYPE_SHORT_ASCII:\n\t\tret = get_short_ascii_object(buffer);\n\t\tbreak;\n\tcase TYPE_ASCII:\n\t\tret = get_ascii_object(buffer);\n\t\tbreak;\n\tcase TYPE_SHORT_ASCII_INTERNED:\n\t\tret = get_short_ascii_interned_object(buffer);\n\t\tbreak;\n\tcase TYPE_INT64:\n\t\tret = get_int64_object(buffer);\n\t\tbreak;\n\tcase TYPE_INTERNED:\n\t\tret = get_interned_object(pyc, buffer);\n\t\tbreak;\n\tcase TYPE_STRINGREF:\n\t\tret = get_stringref_object(pyc, buffer);\n\t\tbreak;\n\tcase TYPE_FLOAT:\n\t\tret = get_float_object(buffer);\n\t\tbreak;\n\tcase TYPE_BINARY_FLOAT:\n\t\tret = get_binary_float_object(buffer);\n\t\tbreak;\n\tcase TYPE_COMPLEX:\n\t\tret = get_complex_object(pyc, buffer); // behaviour depends on Python version\n\t\tbreak;\n\tcase TYPE_BINARY_COMPLEX:\n\t\tret = get_binary_complex_object(buffer);\n\t\tbreak;\n\tcase TYPE_LIST:\n\t\tret = get_list_object(pyc, buffer);\n\t\tbreak;\n\tcase TYPE_LONG:\n\t\tret = get_long_object(buffer);\n\t\tbreak;\n\tcase TYPE_UNICODE:\n\t\tret = get_unicode_object(buffer);\n\t\tbreak;\n\tcase TYPE_DICT:\n\t\tret = get_dict_object(pyc, buffer);\n\t\tbreak;\n\tcase TYPE_FROZENSET:\n\tcase TYPE_SET:\n\t\tret = get_set_object(pyc, buffer);\n\t\tbreak;\n\tcase TYPE_STOPITER:\n\t\tret = RZ_NEW0(pyc_object);\n\t\tbreak;\n\tcase TYPE_ELLIPSIS:\n\t\tret = RZ_NEW0(pyc_object);\n\t\tbreak;\n\tcase TYPE_UNKNOWN:\n\t\tRZ_LOG_ERROR(\"Get not implemented for type 0x%x\\n\", type);\n\t\treturn NULL;\n\tdefault:\n\t\tRZ_LOG_ERROR(\"Undefined type in get_object (0x%x)\\n\", type);\n\t\treturn NULL;\n\t}\n\n\tif (flag && ref_idx) {\n\t\tfree_object(ref_idx->data);\n\t\tref_idx->data = copy_object(ret);\n\t}\n\treturn ret;\n}\n\nstatic bool extract_sections_symbols(RzBinPycObj *pyc, pyc_object *obj, RzList *sections, RzList *symbols, RzList *cobjs, char *prefix) {\n\tpyc_code_object *cobj = NULL;\n\tRzBinSection *section = NULL;\n\tRzBinSymbol *symbol = NULL;\n\tRzListIter *i = NULL;\n\n\t// each code object is a section\n\tif_true_return(!obj || (obj->type != TYPE_CODE_v1 && obj->type != TYPE_CODE_v0), false);\n\n\tcobj = obj->data;\n\n\tif_true_return(!cobj || !cobj->name, false);\n\tif_true_return(cobj->name->type != TYPE_ASCII && cobj->name->type != TYPE_STRING && cobj->name->type != TYPE_INTERNED, false);\n\tif_true_return(!cobj->name->data, false);\n\tif_true_return(!cobj->consts, false);\n\n\t// add the cobj to objs list\n\tif (!rz_list_append(cobjs, cobj)) {\n\t\tgoto fail;\n\t}\n\tsection = RZ_NEW0(RzBinSection);\n\tsymbol = RZ_NEW0(RzBinSymbol);\n\tprefix = rz_str_newf(\"%s%s%s\", prefix ? prefix : \"\",\n\t\tprefix ? \".\" : \"\", (const char *)cobj->name->data);\n\tif (!prefix || !section || !symbol) {\n\t\tgoto fail;\n\t}\n\tsection->name = strdup(prefix);\n\tif (!section->name) {\n\t\tgoto fail;\n\t}\n\tsection->paddr = cobj->start_offset;\n\tsection->vaddr = cobj->start_offset;\n\tsection->size = cobj->end_offset - cobj->start_offset;\n\tsection->vsize = cobj->end_offset - cobj->start_offset;\n\tif (!rz_list_append(sections, section)) {\n\t\tgoto fail;\n\t}\n\tsection = NULL;\n\t// start building symbol\n\tsymbol->name = strdup(prefix);\n\t// symbol->bind;\n\tsymbol->type = RZ_BIN_TYPE_FUNC_STR;\n\tsymbol->size = cobj->end_offset - cobj->start_offset;\n\tsymbol->vaddr = cobj->start_offset;\n\tsymbol->paddr = cobj->start_offset;\n\tsymbol->ordinal = pyc->symbols_ordinal++;\n\tif (cobj->consts->type != TYPE_TUPLE && cobj->consts->type != TYPE_SMALL_TUPLE) {\n\t\tgoto fail;\n\t}\n\tif (!rz_list_append(symbols, symbol)) {\n\t\tgoto fail;\n\t}\n\trz_list_foreach (((RzList *)(cobj->consts->data)), i, obj)\n\t\textract_sections_symbols(pyc, obj, sections, symbols, cobjs, prefix);\n\tfree(prefix);\n\treturn true;\nfail:\n\n\tfree(section);\n\tfree(prefix);\n\tfree(symbol);\n\treturn false;\n}\n\nbool get_sections_symbols_from_code_objects(RzBinPycObj *pyc, RzBuffer *buffer, RzList *sections, RzList *symbols, RzList *cobjs, ut32 magic) {\n\tbool ret;\n\tpyc->magic_int = magic;\n\tpyc->refs = rz_list_newf((RzListFree)free_object);\n\tif (!pyc->refs) {\n\t\treturn false;\n\t}\n\tret = extract_sections_symbols(pyc, get_object(pyc, buffer), sections, symbols, cobjs, NULL);\n\trz_list_free(pyc->refs);\n\treturn ret;\n}\n"], "fixing_code": ["// SPDX-FileCopyrightText: 2016-2020 c0riolis\n// SPDX-FileCopyrightText: 2016-2020 Tardy\n// SPDX-FileCopyrightText: 2016-2020 l0stb1t\n// SPDX-License-Identifier: LGPL-3.0-only\n\n#include <rz_io.h>\n#include <rz_bin.h>\n#include \"marshal.h\"\n#include \"pyc_magic.h\"\n\n// avoiding using rizin internals asserts\n#define if_true_return(cond, ret) \\\n\tif (cond) { \\\n\t\treturn (ret); \\\n\t}\n\nstatic pyc_object *get_object(RzBinPycObj *pyc, RzBuffer *buffer);\nstatic pyc_object *copy_object(pyc_object *object);\nstatic void free_object(pyc_object *object);\n\nstatic ut8 get_ut8(RzBuffer *buffer, bool *error) {\n\tut8 ret = 0;\n\tint size = rz_buf_read(buffer, &ret, sizeof(ret));\n\tif (size < sizeof(ret)) {\n\t\t*error = true;\n\t}\n\treturn ret;\n}\n\nstatic ut16 get_ut16(RzBuffer *buffer, bool *error) {\n\tut16 ret = 0;\n\n\tif (!rz_buf_read_le16(buffer, &ret)) {\n\t\t*error = true;\n\t}\n\treturn ret;\n}\n\nstatic ut32 get_ut32(RzBuffer *buffer, bool *error) {\n\tut32 ret = 0;\n\tif (!rz_buf_read_le32(buffer, &ret)) {\n\t\t*error = true;\n\t}\n\treturn ret;\n}\n\nstatic st32 get_st32(RzBuffer *buffer, bool *error) {\n\tst32 ret = 0;\n\tif (!rz_buf_read_le32(buffer, (ut32 *)&ret)) {\n\t\t*error = true;\n\t}\n\treturn ret;\n}\n\nstatic st64 get_st64(RzBuffer *buffer, bool *error) {\n\tst64 ret = 0;\n\tif (!rz_buf_read_le64(buffer, (ut64 *)&ret)) {\n\t\t*error = true;\n\t}\n\treturn ret;\n}\n\nstatic double get_float64(RzBuffer *buffer, bool *error) {\n\tdouble ret = 0;\n\tif (!rz_buf_read_le64(buffer, (ut64 *)&ret)) {\n\t\t*error = true;\n\t}\n\treturn ret;\n}\n\nstatic ut8 *get_bytes(RzBuffer *buffer, ut32 size) {\n\tut8 *ret = RZ_NEWS0(ut8, size + 1);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tif (rz_buf_read(buffer, ret, size) < size) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_none_object(void) {\n\tpyc_object *ret;\n\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_NONE;\n\tret->data = strdup(\"None\");\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_false_object(void) {\n\tpyc_object *ret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_FALSE;\n\tret->data = strdup(\"False\");\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_true_object(void) {\n\tpyc_object *ret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_TRUE;\n\tret->data = strdup(\"True\");\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_int_object(RzBuffer *buffer) {\n\tbool error = false;\n\tpyc_object *ret = NULL;\n\n\tst32 i = get_st32(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_INT;\n\tret->data = rz_str_newf(\"%d\", i);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_int64_object(RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tst64 i;\n\n\ti = get_st64(buffer, &error);\n\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_INT64;\n\tret->data = rz_str_newf(\"%lld\", i);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t}\n\treturn ret;\n}\n\n/* long is used when the number is > MAX_INT64 */\nstatic pyc_object *get_long_object(RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tbool neg = false;\n\tut32 tmp = 0;\n\tsize_t size;\n\tsize_t i, j = 0, left = 0;\n\tut32 n;\n\tchar *hexstr;\n\tchar digist2hex[] = \"0123456789abcdef\";\n\n\tst32 ndigits = get_st32(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_LONG;\n\tif (ndigits < 0) {\n\t\tndigits = -ndigits;\n\t\tneg = true;\n\t}\n\tif (ndigits == 0) {\n\t\tret->data = strdup(\"0x0\");\n\t} else {\n\t\t// the explicit cast is safe since ndigits is positive\n\t\tsize = (size_t)ndigits * 15;\n\t\tsize = (size - 1) / 4 + 1;\n\t\tsize += 4 + (neg ? 1 : 0);\n\t\thexstr = malloc(size);\n\t\tif (!hexstr) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tmemset(hexstr, 0x20, size);\n\t\tj = size - 1;\n\t\thexstr[j] = 0;\n\t\tfor (i = 0; i < ndigits; i++) {\n\t\t\tn = get_ut16(buffer, &error);\n\t\t\ttmp |= n << left;\n\t\t\tleft += 15;\n\n\t\t\twhile (left >= 4) {\n\t\t\t\thexstr[--j] = digist2hex[tmp & 0xf];\n\t\t\t\ttmp >>= 4;\n\t\t\t\tleft -= 4;\n\t\t\t}\n\t\t}\n\n\t\tif (tmp) {\n\t\t\thexstr[--j] = digist2hex[tmp & 0xf];\n\t\t}\n\n\t\thexstr[--j] = 'x';\n\t\thexstr[--j] = '0';\n\t\tif (neg) {\n\t\t\thexstr[--j] = '-';\n\t\t}\n\n\t\trz_str_trim(hexstr);\n\t\tret->data = hexstr;\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_stringref_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_st32(buffer, &error);\n\tif (n >= rz_list_length(pyc->interned_table)) {\n\t\tRZ_LOG_ERROR(\"bad marshal data (string ref out of range)\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_STRINGREF;\n\tret->data = rz_list_get_n(pyc->interned_table, n);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_float_object(RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 size = 0;\n\tut8 n = 0;\n\n\tn = get_ut8(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tut8 *s = malloc(n + 1);\n\tif (!s) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\t/* object contain string representation of the number */\n\tsize = rz_buf_read(buffer, s, n);\n\tif (size != n) {\n\t\tRZ_FREE(s);\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\ts[n] = '\\0';\n\tret->type = TYPE_FLOAT;\n\tret->data = s;\n\treturn ret;\n}\n\nstatic pyc_object *get_binary_float_object(RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tdouble f;\n\n\tf = get_float64(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_FLOAT;\n\tret->data = rz_str_newf(\"%.15g\", f);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_complex_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n1 = 0;\n\tut32 n2 = 0;\n\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tif ((pyc->magic_int & 0xffff) <= 62061) {\n\t\tn1 = get_ut8(buffer, &error);\n\t} else {\n\t\tn1 = get_st32(buffer, &error);\n\t}\n\tif (error || UT32_ADD_OVFCHK(n1, 1)) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tut8 *s1 = malloc(n1 + 1);\n\tif (!s1) {\n\t\treturn NULL;\n\t}\n\t/* object contain string representation of the number */\n\tif (rz_buf_read(buffer, s1, n1) != n1) {\n\t\tRZ_FREE(s1);\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\ts1[n1] = '\\0';\n\n\tif ((pyc->magic_int & 0xffff) <= 62061) {\n\t\tn2 = get_ut8(buffer, &error);\n\t} else {\n\t\tn2 = get_st32(buffer, &error);\n\t}\n\tif (error || UT32_ADD_OVFCHK(n2, 1)) {\n\t\treturn NULL;\n\t}\n\tut8 *s2 = malloc(n2 + 1);\n\tif (!s2) {\n\t\treturn NULL;\n\t}\n\t/* object contain string representation of the number */\n\tif (rz_buf_read(buffer, s2, n2) != n2) {\n\t\tRZ_FREE(s1);\n\t\tRZ_FREE(s2);\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\ts2[n2] = '\\0';\n\n\tret->type = TYPE_COMPLEX;\n\tret->data = rz_str_newf(\"%s+%sj\", s1, s2);\n\tRZ_FREE(s1);\n\tRZ_FREE(s2);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_binary_complex_object(RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tdouble a, b;\n\n\t// a + bj\n\ta = get_float64(buffer, &error);\n\tb = get_float64(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_BINARY_COMPLEX;\n\tret->data = rz_str_newf(\"%.15g+%.15gj\", a, b);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_string_object(RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32(buffer, &error);\n\tif (n > ST32_MAX) {\n\t\tRZ_LOG_ERROR(\"bad marshal data (string size out of range)\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_STRING;\n\tret->data = get_bytes(buffer, n);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_unicode_object(RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32(buffer, &error);\n\tif (n > ST32_MAX) {\n\t\tRZ_LOG_ERROR(\"bad marshal data (unicode size out of range)\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = RZ_NEW0(pyc_object);\n\tret->type = TYPE_UNICODE;\n\tret->data = get_bytes(buffer, n);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_interned_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32(buffer, &error);\n\tif (n > ST32_MAX) {\n\t\tRZ_LOG_ERROR(\"bad marshal data (string size out of range)\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_INTERNED;\n\tret->data = get_bytes(buffer, n);\n\t/* add data pointer to interned table */\n\trz_list_append(pyc->interned_table, ret->data);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_array_object_generic(RzBinPycObj *pyc, RzBuffer *buffer, ut32 size) {\n\tpyc_object *tmp = NULL;\n\tpyc_object *ret = NULL;\n\tut32 i = 0;\n\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->data = rz_list_newf((RzListFree)free_object);\n\tif (!ret->data) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < size; i++) {\n\t\ttmp = get_object(pyc, buffer);\n\t\tif (!tmp) {\n\t\t\trz_list_free(ret->data);\n\t\t\tRZ_FREE(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!rz_list_append(ret->data, tmp)) {\n\t\t\tfree_object(tmp);\n\t\t\trz_list_free(ret->data);\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn ret;\n}\n\n/* small TYPE_SMALL_TUPLE doesn't exist in python2 */\n/* */\nstatic pyc_object *get_small_tuple_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut8 n = 0;\n\n\tn = get_ut8(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic(pyc, buffer, n);\n\tif (ret) {\n\t\tret->type = TYPE_SMALL_TUPLE;\n\t\treturn ret;\n\t}\n\treturn NULL;\n}\n\nstatic pyc_object *get_tuple_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32(buffer, &error);\n\tif (n > ST32_MAX) {\n\t\tRZ_LOG_ERROR(\"bad marshal data (tuple size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic(pyc, buffer, n);\n\tif (ret) {\n\t\tret->type = TYPE_TUPLE;\n\t\treturn ret;\n\t}\n\treturn NULL;\n}\n\nstatic pyc_object *get_list_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32(buffer, &error);\n\tif (n > ST32_MAX) {\n\t\tRZ_LOG_ERROR(\"bad marshal data (list size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic(pyc, buffer, n);\n\tif (ret) {\n\t\tret->type = TYPE_LIST;\n\t\treturn ret;\n\t}\n\treturn NULL;\n}\n\nstatic pyc_object *get_dict_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tpyc_object *ret = NULL,\n\t\t   *key = NULL,\n\t\t   *val = NULL;\n\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->data = rz_list_newf((RzListFree)free_object);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\tfor (;;) {\n\t\tkey = get_object(pyc, buffer);\n\t\tif (!key) {\n\t\t\tbreak;\n\t\t}\n\t\tif (!rz_list_append(ret->data, key)) {\n\t\t\trz_list_free(ret->data);\n\t\t\tRZ_FREE(ret);\n\t\t\tfree_object(key);\n\t\t\treturn NULL;\n\t\t}\n\t\tval = get_object(pyc, buffer);\n\t\tif (!val) {\n\t\t\tbreak;\n\t\t}\n\t\tif (!rz_list_append(ret->data, val)) {\n\t\t\trz_list_free(ret->data);\n\t\t\tRZ_FREE(ret);\n\t\t\tfree_object(val);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tret->type = TYPE_DICT;\n\treturn ret;\n}\n\nstatic pyc_object *get_set_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32(buffer, &error);\n\tif (n > ST32_MAX) {\n\t\tRZ_LOG_ERROR(\"bad marshal data (set size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic(pyc, buffer, n);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_SET;\n\treturn ret;\n}\n\nstatic pyc_object *get_ascii_object_generic(RzBuffer *buffer, ut32 size, bool interned) {\n\tpyc_object *ret = NULL;\n\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_ASCII;\n\tret->data = get_bytes(buffer, size);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_ascii_object(RzBuffer *buffer) {\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\treturn get_ascii_object_generic(buffer, n, true);\n}\n\nstatic pyc_object *get_ascii_interned_object(RzBuffer *buffer) {\n\tbool error = false;\n\tut32 n;\n\n\tn = get_ut32(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\treturn get_ascii_object_generic(buffer, n, true);\n}\n\nstatic pyc_object *get_short_ascii_object(RzBuffer *buffer) {\n\tbool error = false;\n\tut8 n;\n\n\tn = get_ut8(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\treturn get_ascii_object_generic(buffer, n, false);\n}\n\nstatic pyc_object *get_short_ascii_interned_object(RzBuffer *buffer) {\n\tbool error = false;\n\tut8 n;\n\n\tn = get_ut8(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\treturn get_ascii_object_generic(buffer, n, true);\n}\n\nstatic pyc_object *get_ref_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tbool error = false;\n\tpyc_object *ret;\n\tpyc_object *obj;\n\tut32 index;\n\n\tindex = get_ut32(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tif (index >= rz_list_length(pyc->refs)) {\n\t\treturn NULL;\n\t}\n\tobj = rz_list_get_n(pyc->refs, index);\n\tif (!obj) {\n\t\treturn NULL;\n\t}\n\tret = copy_object(obj);\n\treturn ret;\n}\n\nstatic void free_object(pyc_object *object) {\n\tif (!object) {\n\t\treturn;\n\t}\n\tswitch (object->type) {\n\tcase TYPE_SMALL_TUPLE:\n\tcase TYPE_TUPLE:\n\t\trz_list_free(object->data);\n\t\tbreak;\n\tcase TYPE_STRING:\n\tcase TYPE_TRUE:\n\tcase TYPE_FALSE:\n\tcase TYPE_INT:\n\tcase TYPE_NONE:\n\tcase TYPE_NULL:\n\tcase TYPE_ASCII_INTERNED:\n\tcase TYPE_SHORT_ASCII:\n\tcase TYPE_ASCII:\n\tcase TYPE_SHORT_ASCII_INTERNED:\n\t\tfree(object->data);\n\t\tbreak;\n\tcase TYPE_CODE_v0:\n\tcase TYPE_CODE_v1: {\n\t\tpyc_code_object *cobj = object->data;\n\t\tfree_object(cobj->code);\n\t\tfree_object(cobj->consts);\n\t\tfree_object(cobj->names);\n\t\tfree_object(cobj->varnames);\n\t\tfree_object(cobj->freevars);\n\t\tfree_object(cobj->cellvars);\n\t\tfree_object(cobj->filename);\n\t\tfree_object(cobj->name);\n\t\tfree_object(cobj->lnotab);\n\t\tfree(object->data);\n\t} break;\n\tcase TYPE_REF:\n\t\tfree_object(object->data);\n\t\tbreak;\n\tcase TYPE_SET:\n\tcase TYPE_FROZENSET:\n\tcase TYPE_ELLIPSIS:\n\tcase TYPE_STOPITER:\n\tcase TYPE_BINARY_COMPLEX:\n\tcase TYPE_BINARY_FLOAT:\n\tcase TYPE_COMPLEX:\n\tcase TYPE_STRINGREF:\n\tcase TYPE_DICT:\n\tcase TYPE_FLOAT:\n\tcase TYPE_INT64:\n\tcase TYPE_INTERNED:\n\tcase TYPE_LIST:\n\tcase TYPE_LONG:\n\tcase TYPE_UNICODE:\n\tcase TYPE_UNKNOWN:\n\t\tRZ_LOG_ERROR(\"Free not implemented for type %x\\n\", object->type);\n\t\tbreak;\n\tdefault:\n\t\tRZ_LOG_ERROR(\"Undefined type in free_object (%x)\\n\", object->type);\n\t\tbreak;\n\t}\n\tfree(object);\n}\n\nstatic pyc_object *copy_object(pyc_object *object) {\n\tpyc_object *copy = RZ_NEW0(pyc_object);\n\tif (!copy || !object) {\n\t\tfree(copy);\n\t\treturn NULL;\n\t}\n\tcopy->type = object->type;\n\tswitch (object->type) {\n\tcase TYPE_NULL:\n\t\tbreak;\n\tcase TYPE_TUPLE:\n\tcase TYPE_SMALL_TUPLE:\n\t\tcopy->data = rz_list_clone(object->data);\n\t\tbreak;\n\tcase TYPE_INT:\n\tcase TYPE_INT64:\n\tcase TYPE_NONE:\n\tcase TYPE_TRUE:\n\tcase TYPE_FALSE:\n\tcase TYPE_STRING:\n\tcase TYPE_ASCII:\n\tcase TYPE_SHORT_ASCII:\n\tcase TYPE_ASCII_INTERNED:\n\tcase TYPE_SHORT_ASCII_INTERNED:\n\t\tcopy->data = strdup(object->data);\n\t\tbreak;\n\tcase TYPE_CODE_v0:\n\tcase TYPE_CODE_v1: {\n\t\tpyc_code_object *src = object->data;\n\t\tpyc_code_object *dst = RZ_NEW0(pyc_code_object);\n\t\tif (!dst) {\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(dst, src, sizeof(*dst));\n\t\tdst->code = copy_object(src->code);\n\t\tdst->consts = copy_object(src->consts);\n\t\tdst->names = copy_object(src->names);\n\t\tdst->varnames = copy_object(src->varnames);\n\t\tdst->freevars = copy_object(src->freevars);\n\t\tdst->cellvars = copy_object(src->cellvars);\n\t\tdst->filename = copy_object(src->filename);\n\t\tdst->name = copy_object(src->name);\n\t\tdst->lnotab = copy_object(src->lnotab);\n\t\tcopy->data = dst;\n\t} break;\n\tcase TYPE_REF:\n\t\tcopy->data = copy_object(object->data);\n\t\tbreak;\n\tcase TYPE_ELLIPSIS:\n\tcase TYPE_STOPITER:\n\tcase TYPE_BINARY_COMPLEX:\n\tcase TYPE_BINARY_FLOAT:\n\tcase TYPE_COMPLEX:\n\tcase TYPE_STRINGREF:\n\tcase TYPE_DICT:\n\tcase TYPE_FLOAT:\n\tcase TYPE_FROZENSET:\n\tcase TYPE_INTERNED:\n\tcase TYPE_LIST:\n\tcase TYPE_LONG:\n\tcase TYPE_SET:\n\tcase TYPE_UNICODE:\n\tcase TYPE_UNKNOWN:\n\t\tRZ_LOG_ERROR(\"Copy not implemented for type %x\\n\", object->type);\n\t\tbreak;\n\tdefault:\n\t\tRZ_LOG_ERROR(\"Undefined type in copy_object (%x)\\n\", object->type);\n\t\tbreak;\n\t}\n\tif (!copy->data) {\n\t\tRZ_FREE(copy);\n\t}\n\treturn copy;\n}\n\nstatic pyc_object *get_code_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tbool error = false;\n\n\tpyc_object *ret = RZ_NEW0(pyc_object);\n\tpyc_code_object *cobj = RZ_NEW0(pyc_code_object);\n\tif (!ret || !cobj) {\n\t\tfree(ret);\n\t\tfree(cobj);\n\t\treturn NULL;\n\t}\n\n\t// ret->type = TYPE_CODE_v1;\n\t//  support start from v1.0\n\tret->data = cobj;\n\n\tbool v10_to_12 = magic_int_within(pyc->magic_int, 39170, 16679, &error); // 1.0.1 - 1.2\n\tbool v13_to_22 = magic_int_within(pyc->magic_int, 11913, 60718, &error); // 1.3b1 - 2.2a1\n\tbool v11_to_14 = magic_int_within(pyc->magic_int, 39170, 20117, &error); // 1.0.1 - 1.4\n\tbool v15_to_22 = magic_int_within(pyc->magic_int, 20121, 60718, &error); // 1.5a1 - 2.2a1\n\tbool v13_to_20 = magic_int_within(pyc->magic_int, 11913, 50824, &error); // 1.3b1 - 2.0b1\n\t// bool v21_to_27 = (!v13_to_20) && magic_int_within (magic_int, 60124, 62212, &error);\n\tbool has_posonlyargcount = magic_int_within(pyc->magic_int, 3410, 3424, &error); // v3.8.0a4 - latest\n\tif (error) {\n\t\tfree(ret);\n\t\tfree(cobj);\n\t\treturn NULL;\n\t}\n\n\tif (v13_to_22) {\n\t\tcobj->argcount = get_ut16(buffer, &error);\n\t} else if (v10_to_12) {\n\t\tcobj->argcount = 0;\n\t} else {\n\t\tcobj->argcount = get_ut32(buffer, &error);\n\t}\n\n\tif (has_posonlyargcount) {\n\t\tcobj->posonlyargcount = get_ut32(buffer, &error); // Included in argcount\n\t} else {\n\t\tcobj->posonlyargcount = 0; // None\n\t}\n\n\tif (((3020 < (pyc->magic_int & 0xffff)) && ((pyc->magic_int & 0xffff) < 20121)) && (!v11_to_14)) {\n\t\tcobj->kwonlyargcount = get_ut32(buffer, &error); // Not included in argcount\n\t} else {\n\t\tcobj->kwonlyargcount = 0;\n\t}\n\n\tif (v13_to_22) {\n\t\tcobj->nlocals = get_ut16(buffer, &error);\n\t} else if (v10_to_12) {\n\t\tcobj->nlocals = 0;\n\t} else {\n\t\tcobj->nlocals = get_ut32(buffer, &error);\n\t}\n\n\tif (v15_to_22) {\n\t\tcobj->stacksize = get_ut16(buffer, &error);\n\t} else if (v11_to_14 || v10_to_12) {\n\t\tcobj->stacksize = 0;\n\t} else {\n\t\tcobj->stacksize = get_ut32(buffer, &error);\n\t}\n\n\tif (v13_to_22) {\n\t\tcobj->flags = get_ut16(buffer, &error);\n\t} else if (v10_to_12) {\n\t\tcobj->flags = 0;\n\t} else {\n\t\tcobj->flags = get_ut32(buffer, &error);\n\t}\n\n\t// to help disassemble the code\n\tcobj->start_offset = rz_buf_tell(buffer) + 5; // 1 from get_object() and 4 from get_string_object()\n\tif (!pyc->refs) {\n\t\treturn ret; // return for entried part to get the root object of this file\n\t}\n\tcobj->code = get_object(pyc, buffer);\n\tcobj->end_offset = rz_buf_tell(buffer);\n\n\tcobj->consts = get_object(pyc, buffer);\n\tcobj->names = get_object(pyc, buffer);\n\n\tif (v10_to_12) {\n\t\tcobj->varnames = NULL;\n\t} else {\n\t\tcobj->varnames = get_object(pyc, buffer);\n\t}\n\n\tif (!(v10_to_12 || v13_to_20)) {\n\t\tcobj->freevars = get_object(pyc, buffer);\n\t\tcobj->cellvars = get_object(pyc, buffer);\n\t} else {\n\t\tcobj->freevars = NULL;\n\t\tcobj->cellvars = NULL;\n\t}\n\n\tcobj->filename = get_object(pyc, buffer);\n\tcobj->name = get_object(pyc, buffer);\n\n\tif (v15_to_22) {\n\t\tcobj->firstlineno = get_ut16(buffer, &error);\n\t} else if (v11_to_14) {\n\t\tcobj->firstlineno = 0;\n\t} else {\n\t\tcobj->firstlineno = get_ut32(buffer, &error);\n\t}\n\n\tif (v11_to_14) {\n\t\tcobj->lnotab = NULL;\n\t} else {\n\t\tcobj->lnotab = get_object(pyc, buffer);\n\t}\n\n\tif (error) {\n\t\tfree_object(cobj->code);\n\t\tfree_object(cobj->consts);\n\t\tfree_object(cobj->names);\n\t\tfree_object(cobj->varnames);\n\t\tfree_object(cobj->freevars);\n\t\tfree_object(cobj->cellvars);\n\t\tfree_object(cobj->filename);\n\t\tfree_object(cobj->name);\n\t\tfree_object(cobj->lnotab);\n\t\tfree(cobj);\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nut64 get_code_object_addr(RzBinPycObj *pyc, RzBuffer *buffer, ut32 magic) {\n\tpyc->magic_int = magic;\n\tpyc_object *co = get_code_object(pyc, buffer);\n\tut64 result = 0;\n\tif (!co) {\n\t\treturn 0;\n\t}\n\n\tpyc_code_object *cobj = co->data;\n\tresult = cobj->start_offset;\n\tfree_object(co);\n\n\treturn result;\n}\n\nstatic pyc_object *get_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tbool error = false;\n\tpyc_object *ret = NULL;\n\tut8 code = get_ut8(buffer, &error);\n\tut8 flag = code & FLAG_REF;\n\tRzListIter *ref_idx = NULL;\n\tut8 type = code & ~FLAG_REF;\n\n\tif (error) {\n\t\treturn NULL;\n\t}\n\n\tif (flag) {\n\t\tret = get_none_object();\n\t\tif (!ret) {\n\t\t\treturn NULL;\n\t\t}\n\t\tref_idx = rz_list_append(pyc->refs, ret);\n\t\tif (!ref_idx) {\n\t\t\tfree_object(ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tswitch (type) {\n\tcase TYPE_NULL:\n\t\treturn NULL;\n\tcase TYPE_TRUE:\n\t\treturn get_true_object();\n\tcase TYPE_FALSE:\n\t\treturn get_false_object();\n\tcase TYPE_NONE:\n\t\treturn get_none_object();\n\tcase TYPE_REF:\n\t\treturn get_ref_object(pyc, buffer);\n\tcase TYPE_SMALL_TUPLE:\n\t\tret = get_small_tuple_object(pyc, buffer);\n\t\tbreak;\n\tcase TYPE_TUPLE:\n\t\tret = get_tuple_object(pyc, buffer);\n\t\tbreak;\n\tcase TYPE_STRING:\n\t\tret = get_string_object(buffer);\n\t\tbreak;\n\tcase TYPE_CODE_v0:\n\t\tret = get_code_object(pyc, buffer);\n\t\tif (ret) {\n\t\t\tret->type = TYPE_CODE_v0;\n\t\t}\n\t\tbreak;\n\tcase TYPE_CODE_v1:\n\t\tret = get_code_object(pyc, buffer);\n\t\tif (ret) {\n\t\t\tret->type = TYPE_CODE_v1;\n\t\t}\n\t\tbreak;\n\tcase TYPE_INT:\n\t\tret = get_int_object(buffer);\n\t\tbreak;\n\tcase TYPE_ASCII_INTERNED:\n\t\tret = get_ascii_interned_object(buffer);\n\t\tbreak;\n\tcase TYPE_SHORT_ASCII:\n\t\tret = get_short_ascii_object(buffer);\n\t\tbreak;\n\tcase TYPE_ASCII:\n\t\tret = get_ascii_object(buffer);\n\t\tbreak;\n\tcase TYPE_SHORT_ASCII_INTERNED:\n\t\tret = get_short_ascii_interned_object(buffer);\n\t\tbreak;\n\tcase TYPE_INT64:\n\t\tret = get_int64_object(buffer);\n\t\tbreak;\n\tcase TYPE_INTERNED:\n\t\tret = get_interned_object(pyc, buffer);\n\t\tbreak;\n\tcase TYPE_STRINGREF:\n\t\tret = get_stringref_object(pyc, buffer);\n\t\tbreak;\n\tcase TYPE_FLOAT:\n\t\tret = get_float_object(buffer);\n\t\tbreak;\n\tcase TYPE_BINARY_FLOAT:\n\t\tret = get_binary_float_object(buffer);\n\t\tbreak;\n\tcase TYPE_COMPLEX:\n\t\tret = get_complex_object(pyc, buffer); // behaviour depends on Python version\n\t\tbreak;\n\tcase TYPE_BINARY_COMPLEX:\n\t\tret = get_binary_complex_object(buffer);\n\t\tbreak;\n\tcase TYPE_LIST:\n\t\tret = get_list_object(pyc, buffer);\n\t\tbreak;\n\tcase TYPE_LONG:\n\t\tret = get_long_object(buffer);\n\t\tbreak;\n\tcase TYPE_UNICODE:\n\t\tret = get_unicode_object(buffer);\n\t\tbreak;\n\tcase TYPE_DICT:\n\t\tret = get_dict_object(pyc, buffer);\n\t\tbreak;\n\tcase TYPE_FROZENSET:\n\tcase TYPE_SET:\n\t\tret = get_set_object(pyc, buffer);\n\t\tbreak;\n\tcase TYPE_STOPITER:\n\t\tret = RZ_NEW0(pyc_object);\n\t\tbreak;\n\tcase TYPE_ELLIPSIS:\n\t\tret = RZ_NEW0(pyc_object);\n\t\tbreak;\n\tcase TYPE_UNKNOWN:\n\t\tRZ_LOG_ERROR(\"Get not implemented for type 0x%x\\n\", type);\n\t\treturn NULL;\n\tdefault:\n\t\tRZ_LOG_ERROR(\"Undefined type in get_object (0x%x)\\n\", type);\n\t\treturn NULL;\n\t}\n\n\tif (flag && ref_idx) {\n\t\tfree_object(ref_idx->data);\n\t\tref_idx->data = copy_object(ret);\n\t}\n\treturn ret;\n}\n\nstatic bool extract_sections_symbols(RzBinPycObj *pyc, pyc_object *obj, RzList *sections, RzList *symbols, RzList *cobjs, char *prefix) {\n\tpyc_code_object *cobj = NULL;\n\tRzBinSection *section = NULL;\n\tRzBinSymbol *symbol = NULL;\n\tRzListIter *i = NULL;\n\n\t// each code object is a section\n\tif_true_return(!obj || (obj->type != TYPE_CODE_v1 && obj->type != TYPE_CODE_v0), false);\n\n\tcobj = obj->data;\n\n\tif_true_return(!cobj || !cobj->name, false);\n\tif_true_return(cobj->name->type != TYPE_ASCII && cobj->name->type != TYPE_STRING && cobj->name->type != TYPE_INTERNED, false);\n\tif_true_return(!cobj->name->data, false);\n\tif_true_return(!cobj->consts, false);\n\n\t// add the cobj to objs list\n\tif (!rz_list_append(cobjs, cobj)) {\n\t\tgoto fail;\n\t}\n\tsection = RZ_NEW0(RzBinSection);\n\tsymbol = RZ_NEW0(RzBinSymbol);\n\tprefix = rz_str_newf(\"%s%s%s\", prefix ? prefix : \"\",\n\t\tprefix ? \".\" : \"\", (const char *)cobj->name->data);\n\tif (!prefix || !section || !symbol) {\n\t\tgoto fail;\n\t}\n\tsection->name = strdup(prefix);\n\tif (!section->name) {\n\t\tgoto fail;\n\t}\n\tsection->paddr = cobj->start_offset;\n\tsection->vaddr = cobj->start_offset;\n\tsection->size = cobj->end_offset - cobj->start_offset;\n\tsection->vsize = cobj->end_offset - cobj->start_offset;\n\tif (!rz_list_append(sections, section)) {\n\t\tgoto fail;\n\t}\n\tsection = NULL;\n\t// start building symbol\n\tsymbol->name = strdup(prefix);\n\t// symbol->bind;\n\tsymbol->type = RZ_BIN_TYPE_FUNC_STR;\n\tsymbol->size = cobj->end_offset - cobj->start_offset;\n\tsymbol->vaddr = cobj->start_offset;\n\tsymbol->paddr = cobj->start_offset;\n\tsymbol->ordinal = pyc->symbols_ordinal++;\n\tif (cobj->consts->type != TYPE_TUPLE && cobj->consts->type != TYPE_SMALL_TUPLE) {\n\t\tgoto fail;\n\t}\n\tif (!rz_list_append(symbols, symbol)) {\n\t\tgoto fail;\n\t}\n\trz_list_foreach (((RzList *)(cobj->consts->data)), i, obj)\n\t\textract_sections_symbols(pyc, obj, sections, symbols, cobjs, prefix);\n\tfree(prefix);\n\treturn true;\nfail:\n\n\tfree(section);\n\tfree(prefix);\n\tfree(symbol);\n\treturn false;\n}\n\nbool get_sections_symbols_from_code_objects(RzBinPycObj *pyc, RzBuffer *buffer, RzList *sections, RzList *symbols, RzList *cobjs, ut32 magic) {\n\tbool ret;\n\tpyc->magic_int = magic;\n\tpyc->refs = rz_list_newf((RzListFree)free_object);\n\tif (!pyc->refs) {\n\t\treturn false;\n\t}\n\tret = extract_sections_symbols(pyc, get_object(pyc, buffer), sections, symbols, cobjs, NULL);\n\trz_list_free(pyc->refs);\n\treturn ret;\n}\n"], "filenames": ["librz/bin/format/pyc/marshal.c"], "buggy_code_start_loc": [316], "buggy_code_end_loc": [361], "fixing_code_start_loc": [315], "fixing_code_end_loc": [359], "type": "CWE-787", "message": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when getting data from PYC(python) files. A user opening a malicious PYC file could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commit number 68948017423a12786704e54227b8b2f918c2fd27 contains a patch.", "other": {"cve": {"id": "CVE-2022-36040", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-06T20:15:08.603", "lastModified": "2023-03-30T04:15:09.283", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when getting data from PYC(python) files. A user opening a malicious PYC file could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commit number 68948017423a12786704e54227b8b2f918c2fd27 contains a patch."}, {"lang": "es", "value": "Rizin es un marco de trabajo de ingenier\u00eda inversa tipo UNIX y un conjunto de herramientas de l\u00ednea de comandos. Las versiones 0.4.0 y anteriores son vulnerables a una escritura fuera de l\u00edmites cuando obtienen datos de archivos PYC(python). Un usuario que abra un archivo PYC malicioso podr\u00eda verse afectado por esta vulnerabilidad, permitiendo a un atacante ejecutar c\u00f3digo en la m\u00e1quina del usuario. El n\u00famero de compromiso 68948017423a12786704e54227b8b2f918c2fd27 contiene un parche."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rizin:rizin:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.4.0", "matchCriteriaId": "5E797DF4-7DCA-46AA-9A36-5C0064FE79CA"}]}]}], "references": [{"url": "https://github.com/rizinorg/rizin/commit/68948017423a12786704e54227b8b2f918c2fd27", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rizinorg/rizin/issues/2963", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/rizinorg/rizin/security/advisories/GHSA-h897-rhm9-rpmw", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WQZLMHEI5D7EJASA5UW6XN4ODHLRHK6N/", "source": "security-advisories@github.com"}, {"url": "https://security.gentoo.org/glsa/202209-06", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rizinorg/rizin/commit/68948017423a12786704e54227b8b2f918c2fd27"}}