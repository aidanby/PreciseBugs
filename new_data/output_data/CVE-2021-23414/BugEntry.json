{"buggy_code": ["/**\n * @file url.js\n * @module url\n */\nimport document from 'global/document';\nimport window from 'global/window';\n\n/**\n * @typedef {Object} url:URLObject\n *\n * @property {string} protocol\n *           The protocol of the url that was parsed.\n *\n * @property {string} hostname\n *           The hostname of the url that was parsed.\n *\n * @property {string} port\n *           The port of the url that was parsed.\n *\n * @property {string} pathname\n *           The pathname of the url that was parsed.\n *\n * @property {string} search\n *           The search query of the url that was parsed.\n *\n * @property {string} hash\n *           The hash of the url that was parsed.\n *\n * @property {string} host\n *           The host of the url that was parsed.\n */\n\n/**\n * Resolve and parse the elements of a URL.\n *\n * @function\n * @param    {String} url\n *           The url to parse\n *\n * @return   {url:URLObject}\n *           An object of url details\n */\nexport const parseUrl = function(url) {\n  const props = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'host'];\n\n  // add the url to an anchor and let the browser parse the URL\n  let a = document.createElement('a');\n\n  a.href = url;\n\n  // IE8 (and 9?) Fix\n  // ie8 doesn't parse the URL correctly until the anchor is actually\n  // added to the body, and an innerHTML is needed to trigger the parsing\n  const addToBody = (a.host === '' && a.protocol !== 'file:');\n  let div;\n\n  if (addToBody) {\n    div = document.createElement('div');\n    div.innerHTML = `<a href=\"${url}\"></a>`;\n    a = div.firstChild;\n    // prevent the div from affecting layout\n    div.setAttribute('style', 'display:none; position:absolute;');\n    document.body.appendChild(div);\n  }\n\n  // Copy the specific URL properties to a new object\n  // This is also needed for IE8 because the anchor loses its\n  // properties when it's removed from the dom\n  const details = {};\n\n  for (let i = 0; i < props.length; i++) {\n    details[props[i]] = a[props[i]];\n  }\n\n  // IE9 adds the port to the host property unlike everyone else. If\n  // a port identifier is added for standard ports, strip it.\n  if (details.protocol === 'http:') {\n    details.host = details.host.replace(/:80$/, '');\n  }\n\n  if (details.protocol === 'https:') {\n    details.host = details.host.replace(/:443$/, '');\n  }\n\n  if (!details.protocol) {\n    details.protocol = window.location.protocol;\n  }\n\n  if (addToBody) {\n    document.body.removeChild(div);\n  }\n\n  return details;\n};\n\n/**\n * Get absolute version of relative URL. Used to tell Flash the correct URL.\n *\n * @function\n * @param    {string} url\n *           URL to make absolute\n *\n * @return   {string}\n *           Absolute URL\n *\n * @see      http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue\n */\nexport const getAbsoluteURL = function(url) {\n  // Check if absolute URL\n  if (!url.match(/^https?:\\/\\//)) {\n    // Convert to absolute URL. Flash hosted off-site needs an absolute URL.\n    const div = document.createElement('div');\n\n    div.innerHTML = `<a href=\"${url}\">x</a>`;\n    url = div.firstChild.href;\n  }\n\n  return url;\n};\n\n/**\n * Returns the extension of the passed file name. It will return an empty string\n * if passed an invalid path.\n *\n * @function\n * @param    {string} path\n *           The fileName path like '/path/to/file.mp4'\n *\n * @return  {string}\n *           The extension in lower case or an empty string if no\n *           extension could be found.\n */\nexport const getFileExtension = function(path) {\n  if (typeof path === 'string') {\n    const splitPathRe = /^(\\/?)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?)(\\.([^\\.\\/\\?]+)))(?:[\\/]*|[\\?].*)$/;\n    const pathParts = splitPathRe.exec(path);\n\n    if (pathParts) {\n      return pathParts.pop().toLowerCase();\n    }\n  }\n\n  return '';\n};\n\n/**\n * Returns whether the url passed is a cross domain request or not.\n *\n * @function\n * @param    {string} url\n *           The url to check.\n *\n * @param    {Object} [winLoc]\n *           the domain to check the url against, defaults to window.location\n *\n * @param    {string} [winLoc.protocol]\n *           The window location protocol defaults to window.location.protocol\n *\n * @param    {string} [winLoc.host]\n *           The window location host defaults to window.location.host\n *\n * @return   {boolean}\n *           Whether it is a cross domain request or not.\n */\nexport const isCrossOrigin = function(url, winLoc = window.location) {\n  const urlInfo = parseUrl(url);\n\n  // IE8 protocol relative urls will return ':' for protocol\n  const srcProtocol = urlInfo.protocol === ':' ? winLoc.protocol : urlInfo.protocol;\n\n  // Check if url is for another domain/origin\n  // IE8 doesn't know location.origin, so we won't rely on it here\n  const crossOrigin = (srcProtocol + urlInfo.host) !== (winLoc.protocol + winLoc.host);\n\n  return crossOrigin;\n};\n", "/* eslint-env qunit */\nimport document from 'global/document';\nimport window from 'global/window';\nimport * as Url from '../../../src/js/utils/url.js';\n\nQUnit.module('url');\nQUnit.test('should parse the details of a url correctly', function(assert) {\n  assert.equal(\n    Url.parseUrl('#').protocol,\n    window.location.protocol,\n    'parsed relative url protocol'\n  );\n  assert.equal(Url.parseUrl('#').host, window.location.host, 'parsed relative url host');\n\n  assert.equal(Url.parseUrl('http://example.com').protocol, 'http:', 'parsed example url protocol');\n  assert.equal(Url.parseUrl('http://example.com').hostname, 'example.com', 'parsed example url hostname');\n\n  assert.equal(Url.parseUrl('http://example.com:1234').port, '1234', 'parsed example url port');\n});\n\nQUnit.test('should strip port from hosts using http or https', function(assert) {\n  const origDocCreate = document.createElement;\n\n  // attempts to create elements will return an anchor tag that\n  // misbehaves like IE9\n  document.createElement = function() {\n    return {\n      hostname: 'example.com',\n      host: 'example.com:80',\n      protocol: 'http:',\n      port: '80',\n      pathname: '/domain/relative/url',\n      hash: ''\n    };\n  };\n\n  const url = Url.parseUrl('/domain/relative/url');\n\n  document.createElement = origDocCreate;\n\n  assert.ok(!(/.*:80$/).test(url.host), ':80 is not appended to the host');\n\n});\n\nQUnit.test('should get an absolute URL', function(assert) {\n  // Errors on compiled tests that don't use unit.html. Need a better solution.\n  // assert.ok(Url.getAbsoluteURL('unit.html') === window.location.href);\n  assert.ok(Url.getAbsoluteURL('http://asdf.com') === 'http://asdf.com');\n  assert.ok(Url.getAbsoluteURL('https://asdf.com/index.html') === 'https://asdf.com/index.html');\n});\n\n// getFileExtension tests\nQUnit.test('should get the file extension of the passed path', function(assert) {\n  assert.equal(Url.getFileExtension('/foo/bar/test.video.wgg'), 'wgg');\n  assert.equal(Url.getFileExtension('test./video.mp4'), 'mp4');\n  assert.equal(Url.getFileExtension('.bar/test.video.m4v'), 'm4v');\n  assert.equal(Url.getFileExtension('foo/.bar/test.video.flv'), 'flv');\n  assert.equal(Url.getFileExtension('foo/.bar/test.video.flv?foo=bar'), 'flv');\n  assert.equal(Url.getFileExtension('http://www.test.com/video.mp4'), 'mp4');\n  assert.equal(Url.getFileExtension('http://foo/bar/test.video.wgg'), 'wgg');\n\n  // edge cases\n  assert.equal(Url.getFileExtension('http://...'), '');\n  assert.equal(Url.getFileExtension('foo/.bar/testvideo'), '');\n  assert.equal(Url.getFileExtension(''), '');\n  assert.equal(Url.getFileExtension(null), '');\n  assert.equal(Url.getFileExtension(undefined), '');\n\n  // with capital letters\n  assert.equal(Url.getFileExtension('test.video.MP4'), 'mp4');\n  assert.equal(Url.getFileExtension('test.video.FLV'), 'flv');\n});\n\n// isCrossOrigin tests\nQUnit.test('isCrossOrigin can identify cross origin urls', function(assert) {\n\n  assert.ok(!Url.isCrossOrigin(`http://${window.location.host}/example.vtt`), 'http://google.com from http://google.com is not cross origin');\n  assert.ok(Url.isCrossOrigin(`https://${window.location.host}/example.vtt`), 'https://google.com from http://google.com is cross origin');\n  assert.ok(!Url.isCrossOrigin(`//${window.location.host}/example.vtt`), '//google.com from http://google.com is not cross origin');\n  assert.ok(Url.isCrossOrigin('http://example.com/example.vtt'), 'http://example.com from http://google.com is cross origin');\n  assert.ok(Url.isCrossOrigin('https://example.com/example.vtt'), 'https://example.com from http://google.com is cross origin');\n  assert.ok(Url.isCrossOrigin('//example.com/example.vtt'), '//example.com from http://google.com is cross origin');\n  // we cannot test that relative urls work on https, though\n  assert.ok(!Url.isCrossOrigin('example.vtt'), 'relative url is not cross origin');\n\n  const location = {\n    protocol: 'https:',\n    host: 'google.com'\n  };\n\n  assert.ok(!Url.isCrossOrigin('https://google.com/example.vtt', location), 'http://google.com from https://google.com is not cross origin');\n  assert.ok(Url.isCrossOrigin('http://google.com/example.vtt', location), 'http://google.com from https://google.com is cross origin');\n  assert.ok(Url.isCrossOrigin('http://example.com/example.vtt', location), 'http://example.com from https://google.com is cross origin');\n  assert.ok(Url.isCrossOrigin('https://example.com/example.vtt', location), 'https://example.com from https://google.com is cross origin');\n  assert.ok(Url.isCrossOrigin('//example.com/example.vtt', location), '//example.com from https://google.com is cross origin');\n});\n"], "fixing_code": ["/**\n * @file url.js\n * @module url\n */\nimport document from 'global/document';\nimport window from 'global/window';\n\n/**\n * @typedef {Object} url:URLObject\n *\n * @property {string} protocol\n *           The protocol of the url that was parsed.\n *\n * @property {string} hostname\n *           The hostname of the url that was parsed.\n *\n * @property {string} port\n *           The port of the url that was parsed.\n *\n * @property {string} pathname\n *           The pathname of the url that was parsed.\n *\n * @property {string} search\n *           The search query of the url that was parsed.\n *\n * @property {string} hash\n *           The hash of the url that was parsed.\n *\n * @property {string} host\n *           The host of the url that was parsed.\n */\n\n/**\n * Resolve and parse the elements of a URL.\n *\n * @function\n * @param    {String} url\n *           The url to parse\n *\n * @return   {url:URLObject}\n *           An object of url details\n */\nexport const parseUrl = function(url) {\n  // This entire method can be replace with URL once we are able to drop IE11\n\n  const props = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'host'];\n\n  // add the url to an anchor and let the browser parse the URL\n  const a = document.createElement('a');\n\n  a.href = url;\n\n  // Copy the specific URL properties to a new object\n  // This is also needed for IE because the anchor loses its\n  // properties when it's removed from the dom\n  const details = {};\n\n  for (let i = 0; i < props.length; i++) {\n    details[props[i]] = a[props[i]];\n  }\n\n  // IE adds the port to the host property unlike everyone else. If\n  // a port identifier is added for standard ports, strip it.\n  if (details.protocol === 'http:') {\n    details.host = details.host.replace(/:80$/, '');\n  }\n\n  if (details.protocol === 'https:') {\n    details.host = details.host.replace(/:443$/, '');\n  }\n\n  if (!details.protocol) {\n    details.protocol = window.location.protocol;\n  }\n\n  /* istanbul ignore if */\n  if (!details.host) {\n    details.host = window.location.host;\n  }\n\n  return details;\n};\n\n/**\n * Get absolute version of relative URL. Used to tell Flash the correct URL.\n *\n * @function\n * @param    {string} url\n *           URL to make absolute\n *\n * @return   {string}\n *           Absolute URL\n *\n * @see      http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue\n */\nexport const getAbsoluteURL = function(url) {\n  // Check if absolute URL\n  if (!url.match(/^https?:\\/\\//)) {\n    // Convert to absolute URL. Flash hosted off-site needs an absolute URL.\n    const div = document.createElement('div');\n\n    div.innerHTML = `<a href=\"${url}\">x</a>`;\n    url = div.firstChild.href;\n  }\n\n  return url;\n};\n\n/**\n * Returns the extension of the passed file name. It will return an empty string\n * if passed an invalid path.\n *\n * @function\n * @param    {string} path\n *           The fileName path like '/path/to/file.mp4'\n *\n * @return  {string}\n *           The extension in lower case or an empty string if no\n *           extension could be found.\n */\nexport const getFileExtension = function(path) {\n  if (typeof path === 'string') {\n    const splitPathRe = /^(\\/?)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?)(\\.([^\\.\\/\\?]+)))(?:[\\/]*|[\\?].*)$/;\n    const pathParts = splitPathRe.exec(path);\n\n    if (pathParts) {\n      return pathParts.pop().toLowerCase();\n    }\n  }\n\n  return '';\n};\n\n/**\n * Returns whether the url passed is a cross domain request or not.\n *\n * @function\n * @param    {string} url\n *           The url to check.\n *\n * @param    {Object} [winLoc]\n *           the domain to check the url against, defaults to window.location\n *\n * @param    {string} [winLoc.protocol]\n *           The window location protocol defaults to window.location.protocol\n *\n * @param    {string} [winLoc.host]\n *           The window location host defaults to window.location.host\n *\n * @return   {boolean}\n *           Whether it is a cross domain request or not.\n */\nexport const isCrossOrigin = function(url, winLoc = window.location) {\n  const urlInfo = parseUrl(url);\n\n  // IE8 protocol relative urls will return ':' for protocol\n  const srcProtocol = urlInfo.protocol === ':' ? winLoc.protocol : urlInfo.protocol;\n\n  // Check if url is for another domain/origin\n  // IE8 doesn't know location.origin, so we won't rely on it here\n  const crossOrigin = (srcProtocol + urlInfo.host) !== (winLoc.protocol + winLoc.host);\n\n  return crossOrigin;\n};\n", "/* eslint-env qunit */\nimport document from 'global/document';\nimport window from 'global/window';\nimport * as Url from '../../../src/js/utils/url.js';\n\nQUnit.module('url');\nQUnit.test('should parse the details of a url correctly', function(assert) {\n  assert.equal(Url.parseUrl('#').protocol, window.location.protocol, 'parsed relative url protocol');\n  assert.equal(Url.parseUrl('#').host, window.location.host, 'parsed relative url host');\n  assert.equal(Url.parseUrl('#foo').hash, '#foo', 'parsed relative url hash');\n\n  assert.equal(Url.parseUrl('http://example.com').protocol, 'http:', 'parsed example url protocol');\n  assert.equal(Url.parseUrl('http://example.com').hostname, 'example.com', 'parsed example url hostname');\n\n  assert.equal(Url.parseUrl('http://example.com:1234').port, '1234', 'parsed example url port');\n});\n\nQUnit.test('should strip port from hosts using http or https', function(assert) {\n  const origDocCreate = document.createElement;\n\n  // attempts to create elements will return an anchor tag that\n  // misbehaves like IE9\n  document.createElement = function() {\n    return {\n      hostname: 'example.com',\n      host: 'example.com:80',\n      protocol: 'http:',\n      port: '80',\n      pathname: '/domain/relative/url',\n      hash: ''\n    };\n  };\n\n  const url = Url.parseUrl('/domain/relative/url');\n\n  document.createElement = origDocCreate;\n\n  assert.ok(!(/.*:80$/).test(url.host), ':80 is not appended to the host');\n\n});\n\nQUnit.test('should get an absolute URL', function(assert) {\n  // Errors on compiled tests that don't use unit.html. Need a better solution.\n  // assert.ok(Url.getAbsoluteURL('unit.html') === window.location.href);\n  assert.ok(Url.getAbsoluteURL('http://asdf.com') === 'http://asdf.com');\n  assert.ok(Url.getAbsoluteURL('https://asdf.com/index.html') === 'https://asdf.com/index.html');\n});\n\n// getFileExtension tests\nQUnit.test('should get the file extension of the passed path', function(assert) {\n  assert.equal(Url.getFileExtension('/foo/bar/test.video.wgg'), 'wgg');\n  assert.equal(Url.getFileExtension('test./video.mp4'), 'mp4');\n  assert.equal(Url.getFileExtension('.bar/test.video.m4v'), 'm4v');\n  assert.equal(Url.getFileExtension('foo/.bar/test.video.flv'), 'flv');\n  assert.equal(Url.getFileExtension('foo/.bar/test.video.flv?foo=bar'), 'flv');\n  assert.equal(Url.getFileExtension('http://www.test.com/video.mp4'), 'mp4');\n  assert.equal(Url.getFileExtension('http://foo/bar/test.video.wgg'), 'wgg');\n\n  // edge cases\n  assert.equal(Url.getFileExtension('http://...'), '');\n  assert.equal(Url.getFileExtension('foo/.bar/testvideo'), '');\n  assert.equal(Url.getFileExtension(''), '');\n  assert.equal(Url.getFileExtension(null), '');\n  assert.equal(Url.getFileExtension(undefined), '');\n\n  // with capital letters\n  assert.equal(Url.getFileExtension('test.video.MP4'), 'mp4');\n  assert.equal(Url.getFileExtension('test.video.FLV'), 'flv');\n});\n\n// isCrossOrigin tests\nQUnit.test('isCrossOrigin can identify cross origin urls', function(assert) {\n\n  assert.ok(!Url.isCrossOrigin(`http://${window.location.host}/example.vtt`), 'http://google.com from http://google.com is not cross origin');\n  assert.ok(Url.isCrossOrigin(`https://${window.location.host}/example.vtt`), 'https://google.com from http://google.com is cross origin');\n  assert.ok(!Url.isCrossOrigin(`//${window.location.host}/example.vtt`), '//google.com from http://google.com is not cross origin');\n  assert.ok(Url.isCrossOrigin('http://example.com/example.vtt'), 'http://example.com from http://google.com is cross origin');\n  assert.ok(Url.isCrossOrigin('https://example.com/example.vtt'), 'https://example.com from http://google.com is cross origin');\n  assert.ok(Url.isCrossOrigin('//example.com/example.vtt'), '//example.com from http://google.com is cross origin');\n  // we cannot test that relative urls work on https, though\n  assert.ok(!Url.isCrossOrigin('example.vtt'), 'relative url is not cross origin');\n\n  const location = {\n    protocol: 'https:',\n    host: 'google.com'\n  };\n\n  assert.ok(!Url.isCrossOrigin('https://google.com/example.vtt', location), 'http://google.com from https://google.com is not cross origin');\n  assert.ok(Url.isCrossOrigin('http://google.com/example.vtt', location), 'http://google.com from https://google.com is cross origin');\n  assert.ok(Url.isCrossOrigin('http://example.com/example.vtt', location), 'http://example.com from https://google.com is cross origin');\n  assert.ok(Url.isCrossOrigin('https://example.com/example.vtt', location), 'https://example.com from https://google.com is cross origin');\n  assert.ok(Url.isCrossOrigin('//example.com/example.vtt', location), '//example.com from https://google.com is cross origin');\n});\n"], "filenames": ["src/js/utils/url.js", "test/unit/utils/url.test.js"], "buggy_code_start_loc": [43, 8], "buggy_code_end_loc": [91, 13], "fixing_code_start_loc": [44, 8], "fixing_code_end_loc": [79, 11], "type": "CWE-79", "message": "This affects the package video.js before 7.14.3. The src attribute of track tag allows to bypass HTML escaping and execute arbitrary code.", "other": {"cve": {"id": "CVE-2021-23414", "sourceIdentifier": "report@snyk.io", "published": "2021-07-28T08:15:07.077", "lastModified": "2023-02-03T19:12:28.220", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects the package video.js before 7.14.3. The src attribute of track tag allows to bypass HTML escaping and execute arbitrary code."}, {"lang": "es", "value": "Esto afecta al paquete video.js antes de la versi\u00f3n 7.14.3. El atributo src de la etiqueta track permite eludir el escape de HTML y ejecutar c\u00f3digo arbitrario"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:videojs:video.js:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "7.14.3", "matchCriteriaId": "9C8A0ACD-9D58-427A-8C76-C4D471039512"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}], "references": [{"url": "https://github.com/videojs/video.js/commit/b3acf663641fca0f7a966525a72845af7ec5fab2", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/2DHYIIAUXUBHMBEDYU7TYNZXEN2W2SA2/", "source": "report@snyk.io", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/74SXNGA5RIWM7QNX7H3G7SYIQLP4UUGV/", "source": "report@snyk.io", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/NLRJB5JNKK3VVBLV3NH3RI7COEDAXSAB/", "source": "report@snyk.io", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JAVA-ORGWEBJARSBOWER-1533588", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JAVA-ORGWEBJARSNPM-1533587", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-VIDEOJS-1533429", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/videojs/video.js/commit/b3acf663641fca0f7a966525a72845af7ec5fab2"}}