{"buggy_code": ["# Notation Threat Model\n\n## Overview\n\nNotation is a comprehensive tool for generating and verifying signatures associated with software artifacts. Its purpose is to validate the integrity and authenticity, accomplishing this through the implementation of fine-grained policies.\n\nThe following diagram illustrates the architecture and components.\n\n![Notation system overview](../media/notation-system.svg)\n\n- **User**: The actor could be a signer or a verifier. A signer interacts with Notation CLI to sign artifacts. A verifier interacts with Notation CLI to verify artifacts against signatures.\n- **Artifact Builder**: The actor who is responsible for producing software artifacts using build systems. Notation supports signing and verification of software artifacts including but are not limited to container images, helm charts, Software Bill of Materials (SBOMs). These artifacts can be stored either in remote registries or locally on disk using [OCI image layout](https://github.com/opencontainers/image-spec/blob/v1.0.0/image-layout.md).\n- **Execution Environment**: The execution environment includes the host and **File System** where notation CLI will be installed and executed. Notation works with a shared responsibility model which means users/organizations are responsible for securing the notation execution environment. Following are the various directories and files used by the Notation:\n  - `config.json` file is used to store various configurations such as credential store information, etc.\n  - `trustpolicy.json` file is used to store trust policy related data.\n  - `truststore` directory is used to store various trusted certificates used for signature verification.\n  - `localkeys` directory is used to store test keys.\n  - `plugins` directory is used to store various plugins.\n  \n  Notation uses credential stores to securely store the registry credentials.\n- **Notation Plugin**: An external component/binary that can integrate as one of the steps in Notation\u2019s workflow for signature generation or verification, see [plugin spec](https://github.com/notaryproject/notaryproject/blob/v1.0.0-rc.2/specs/plugin-extensibility.md) for details.\n- **Registry**: An OCI-compliant registry that stores OCI artifacts, like container images, Helm charts or other OCI artifacts. Registries are outside Notation trust boundary.\n- **KMS**: A Key Management System or a signing service that manages the the certificate along with private key that used for signing artifacts. KMS are outside Notation trust boundary.\n- **OCSP Responder**: The [Online Certificate Status Protocol (OCSP)](https://www.rfc-editor.org/rfc/rfc6960) is an Internet protocol used for obtaining the revocation status of an X.509 digital certificate. Notation uses OCSP to check the certificate's revocation status.\n\n## Notation sign artifacts using remote key\n\n### Data flow\n\nA signer uses Notation to sign the artifacts and store signatures either locally on the disk or in a registry.\n\nThe following diagram illustrates Notation signing artifacts stored in registries with keys stored in KMS:\n\n![Notation signs artifacts stored in registries](../media/notation-sign-remote.svg)\n\nThe following diagram illustrates Notation signing artifacts as OCI image layout with keys stored in KMS:\n\n![Notation signs artifacts as OCI image layout in the filesystem](../media/notation-sign-local.svg)\n\nAs per the [Notary signature specification](../specs/signature-specification.md), the signature payload is a JSON document which requires the [OCI descriptor](https://github.com/opencontainers/image-spec/blob/v1.0.0/descriptor.md) of the target artifact. For artifacts stored in a registry, the descriptor info can be retrieved from [image manifest](https://github.com/opencontainers/image-spec/blob/v1.1.0-rc2/manifest.md) stored in the registry. For artifacts stored as an [OCI Image layout](https://github.com/opencontainers/image-spec/blob/v1.0.0/image-layout.md), the descriptor info can be retrieved by inspecting the `index.json` file of OCI Image layout.\n\n### Threats and Mitigation\n\n|   Title                      | STRIDE threat type     | Threat Status | Priority | Entity          | Description   | Mitigation   |\n| ---------------------------- | ---------------------- | ------------- | -------- | --------------- | ------------- | ------------ |\n| Compromised signing key         | Information disclosure | Mitigated     | High     | Signer          | Signing keys are compromised, and this may lead to arbitrary artifacts being signed by attackers | Users store the signing keys in hardware security module (HSM) and rotate them periodically. In case a signing key is compromised, users must revoke associated certificates.  |\n| Inaccessible Registry           | Denial of Service      | Mitigated     | High     | Registry        | Registry is not able to service incoming requests or perform up to spec, thus users are unable to publish any artifacts | Notation supports signing artifacts stored locally on disk |\n| Serving tampered artifacts      | Tampering              | Mitigated     | High     | Registry        | Data stored in registries are tampered, this may lead to malicious artifacts being signed | Notation encourages user to sign artifacts using digest (and discourages signing using tag by emitting warnings), or Notation recommends signing artifacts stored in local file system, and stores signatures locally or in the registry |\n| Disclosure of signature info    | Information disclosure | Mitigated     | High     | Registry        | Man-in-the-middle attack | Notation interacts with trusted registries via TLS or signs artifacts stored in local file system, and then stores signatures locally |\n| Tampered files                  | Tampering              | Not Mitigated     | High     | File System     | Files read by Notation are tampered, this may lead to failure of notation sign operation | Notation must be installed on secure and trusted infrastructure(shared responsibility with users)|\n| Disclosure of files             | Information disclosure | Mitigated     | High     | File System     | Files are accessed by attackers, this may lead to disclosure of notation config files and credential files | Notation must be installed on secure and trusted infrastructure(shared responsibility mode). Notation stores the credentials securely using credential store. Notation interacts with notation plugin to access signing keys via remote KMS or a HSM device |\n| Malicious plugin                | Tampering              | Mitigated     | High     | Notation Plugin | A malicious plugin is installed, this may lead to arbitrary code being executed by attackers | Verify the integrity and authenticity of the plugin before using the plugin |\n| Using weak crypto algorithms during the signing | Repudiation         | Mitigated     | High     | Notation Plugin | Bypass of signature verification | Notation restricts the signing algorithm to the following [set](https://github.com/notaryproject/notaryproject/blob/main/specs/signature-specification.md#algorithm-selection) |\n| Compromised Notation dependencies | Tampering              | Mitigated  | High     | Notation       | The dependencies that built into Notation binary was compromised, this may lead to arbitrary code being executed | Notation keeps dependencies up-to-date and adds new dependency after careful consideration and only if it's absolutely required. Always use static build instead of dynamic linking |\n\n## Notation verify artifacts against signatures\n\n### Data flow\n\nA verifier uses Notation to verify artifacts against signatures stored in the file system or in a registry to ensure the authenticity and integrity of the artifacts before deploying the artifacts.\n\nThe following diagram illustrates Notation verifying artifacts stored in a registry:\n\n![Notation verifies artifacts stored in registries](../media/notation-verify-remote.svg)\n\nThe following diagram illustrates Notation verifying artifacts stored in a registry with a verification plugin:\n\n![Notation verifies artifacts stored in registries using verification plugin](../media/notation-verify-plugin.svg)\n\nThe following diagram illustrates Notation verifying artifacts stored as OCI image layout in the file system:\n\n![Notation verifies artifacts as OCI image layout in the filesystem](../media/notation-verify-local.svg)\n\nThe certificates trusted by the verifier are stored in Notation trust store in the file system. Users can download the certificates from KMS or request CA vendor for CA certificates.\n\n### Threats and Mitigation\n\n|   Title                                                        | STRIDE threat type     | Threat Status | Priority | Entity          | Description   | Mitigation   |\n| -------------------------------------------------------------- | ---------------------- | ------------- | -------- | --------------- | ------------- | ------------ |\n| Inaccessible Registry                                          | Denial of Service      | Mitigated     | High     | Registry        | Registry is not able to service incoming requests or perform up to spec, thus users are unable to verify artifacts | Notation supports verification of signatures stored locally on disk|\n| Serving tampered artifacts                                     | Tampering              | Mitigated     | High     | Registry        | Data stored in registries are tampered, this may lead to malicious artifacts being consumed | Notation verifies the digest specified by the user and the digest store in the signature are the same. Notation does support verification using tag but its highly discouraged by emitting a warning |\n| Disclosure of signature info                                   | Information disclosure | Mitigated     | High     | Registry        | Man-in-the-middle attack | Notation interacts with trusted registries via TLS by default or Notation signs artifacts stored in local file system, and then stores signatures locally |\n| Tampered files                                                 | Tampering              | Not Mitigated     | High     | File System      | Files read by Notation are tampered, this may lead to failure of notation verify operation or verification bypassed | Notation must be installed on secure and trusted infrastructure(shared responsibility mode) |\n| Disclosure of files                                            | Information disclosure | Mitigated     | High     | File System      | Files are accessed by attackers, this may lead to disclosure of notation config files and credential files | Notation must be installed on secure and trusted infrastructure(shared responsibility mode). Notation stores the credentials securely using credential store |\n| Malicious plugin                                               | Tampering              | Mitigated     | High     | Notation Plugin | A malicious plugin is installed, this may lead to arbitrary code being executed by attackers | Verify plugin package before installation or plugin is installed by authorized users |\n| Compromised trust policies by the weakest CA                   | Tampering              | Mitigated     | High     | Notation        | An attacker can make the signature verification for any signatures succeed by exploiting a vulnerability in the weakest CA\u2019s infrastructure that exists in the trust store | Notation supports scoping trust policies per a registry. That means, users can write their policies to scope a CA to only to the registry that uses that CA, hence not affecting signatures of other registries signed by other CAs |\n| Malicious signature faking to be signed by a signing authority | Tampering      | Mitigated | High   | Notation     | Unlike notary.x509 signing scheme, trusted timestamps are not checked against RFC#3161 TSA servers for notary.x509.signingAuthority signing scheme. An attacker can use this and bypass trusted timestamp checks by crafting a signature that uses notary.x509 keys but with signingAuthority as the signing scheme. | To prevent this threat, notary.x509.signingAuthority signing scheme requires trusted roots to be present in a trust store type called signingAuthority as opposed to CA trust store type for notary.x509 signing scheme |\n| Inaccessible OCSP Responder                                    | Denial of Service      | Not Mitigated | High     | OCSP Responder  | OCSP Responder is not able to service incoming requests or perform up to spec, thus users are unable to validate certificate revocation status | It cannot be mitigated, since revocation status should be retrieved from OCSP responder, which requires network access. Notation verification should fail if revocation check is configured as `enforced` and OCSP responder is inaccessible. Users can configure trust policy to log or skip revocation check if OCSP responder is not reliable. |\n| Compromised Notation dependencies                              | Tampering              | Mitigated | High     | Notation       | The dependencies that built into Notation binary was compromised, this may lead to arbitrary code being executed | Notation keeps dependencies up-to-date and adds new dependency after careful consideration and only if it's absolutely required. Always use static build instead of dynamic linking |\n"], "fixing_code": ["# Notation Threat Model\n\n## Overview\n\nNotation is a comprehensive tool for generating and verifying signatures associated with software artifacts. Its purpose is to validate the integrity and authenticity, accomplishing this through the implementation of fine-grained policies.\n\nThe following diagram illustrates the architecture and components.\n\n![Notation system overview](../media/notation-system.svg)\n\n- **User**: The actor could be a signer or a verifier. A signer interacts with Notation CLI to sign artifacts. A verifier interacts with Notation CLI to verify artifacts against signatures.\n- **Artifact Builder**: The actor who is responsible for producing software artifacts using build systems. Notation supports signing and verification of software artifacts including but are not limited to container images, helm charts, Software Bill of Materials (SBOMs). These artifacts can be stored either in remote registries or locally on disk using [OCI image layout](https://github.com/opencontainers/image-spec/blob/v1.0.0/image-layout.md).\n- **Execution Environment**: The execution environment includes the host and **File System** where notation CLI will be installed and executed. Notation works with a shared responsibility model which means users/organizations are responsible for securing the notation execution environment. Following are the various directories and files used by the Notation:\n  - `config.json` file is used to store various configurations such as credential store information, etc.\n  - `trustpolicy.json` file is used to store trust policy related data.\n  - `truststore` directory is used to store various trusted certificates used for signature verification.\n  - `localkeys` directory is used to store test keys.\n  - `plugins` directory is used to store various plugins.\n  \n  Notation uses credential stores to securely store the registry credentials.\n- **Notation Plugin**: An external component/binary that can integrate as one of the steps in Notation\u2019s workflow for signature generation or verification, see [plugin spec](https://github.com/notaryproject/notaryproject/blob/v1.0.0-rc.2/specs/plugin-extensibility.md) for details.\n- **Registry**: An OCI-compliant registry that stores OCI artifacts, like container images, Helm charts or other OCI artifacts. Registries are outside Notation trust boundary.\n- **KMS**: A Key Management System or a signing service that manages the the certificate along with private key that used for signing artifacts. KMS are outside Notation trust boundary.\n- **OCSP Responder**: The [Online Certificate Status Protocol (OCSP)](https://www.rfc-editor.org/rfc/rfc6960) is an Internet protocol used for obtaining the revocation status of an X.509 digital certificate. Notation uses OCSP to check the certificate's revocation status.\n\n## Notation sign artifacts using remote key\n\n### Data flow\n\nA signer uses Notation to sign the artifacts and store signatures either locally on the disk or in a registry.\n\nThe following diagram illustrates Notation signing artifacts stored in registries with keys stored in KMS:\n\n![Notation signs artifacts stored in registries](../media/notation-sign-remote.svg)\n\nThe following diagram illustrates Notation signing artifacts as OCI image layout with keys stored in KMS:\n\n![Notation signs artifacts as OCI image layout in the filesystem](../media/notation-sign-local.svg)\n\nAs per the [Notary signature specification](../specs/signature-specification.md), the signature payload is a JSON document which requires the [OCI descriptor](https://github.com/opencontainers/image-spec/blob/v1.0.0/descriptor.md) of the target artifact. For artifacts stored in a registry, the descriptor info can be retrieved from [image manifest](https://github.com/opencontainers/image-spec/blob/v1.1.0-rc2/manifest.md) stored in the registry. For artifacts stored as an [OCI Image layout](https://github.com/opencontainers/image-spec/blob/v1.0.0/image-layout.md), the descriptor info can be retrieved by inspecting the `index.json` file of OCI Image layout.\n\n### Threats and Mitigation\n\n|   Title                      | STRIDE threat type     | Threat Status | Priority | Entity          | Description   | Mitigation   |\n| ---------------------------- | ---------------------- | ------------- | -------- | --------------- | ------------- | ------------ |\n| Compromised signing key         | Information disclosure | Mitigated     | High     | Signer          | Signing keys are compromised, and this may lead to arbitrary artifacts being signed by attackers | Users store the signing keys in hardware security module (HSM) and rotate them periodically. In case a signing key is compromised, users must revoke associated certificates.  |\n| Inaccessible Registry           | Denial of Service      | Mitigated     | High     | Registry        | Registry is not able to service incoming requests or perform up to spec, thus users are unable to publish any artifacts | Notation supports signing artifacts stored locally on disk |\n| Serving tampered artifacts      | Tampering              | Mitigated     | High     | Registry        | Data stored in registries are tampered, this may lead to malicious artifacts being signed | Notation encourages user to sign artifacts using digest (and discourages signing using tag by emitting warnings), or Notation recommends signing artifacts stored in local file system, and stores signatures locally or in the registry |\n| Disclosure of signature info    | Information disclosure | Mitigated     | High     | Registry        | Man-in-the-middle attack | Notation interacts with trusted registries via TLS or signs artifacts stored in local file system, and then stores signatures locally |\n| Tampered files                  | Tampering              | Not Mitigated     | High     | File System     | Files read by Notation are tampered, this may lead to failure of notation sign operation | Notation must be installed on secure and trusted infrastructure(shared responsibility with users)|\n| Disclosure of files             | Information disclosure | Mitigated     | High     | File System     | Files are accessed by attackers, this may lead to disclosure of notation config files and credential files | Notation must be installed on secure and trusted infrastructure(shared responsibility mode). Notation stores the credentials securely using credential store. Notation interacts with notation plugin to access signing keys via remote KMS or a HSM device |\n| Malicious plugin                | Tampering              | Mitigated     | High     | Notation Plugin | A malicious plugin is installed, this may lead to arbitrary code being executed by attackers | Verify the integrity and authenticity of the plugin before using the plugin |\n| Using weak crypto algorithms during the signing | Repudiation         | Mitigated     | High     | Notation Plugin | Bypass of signature verification | Notation restricts the signing algorithm to the following [set](https://github.com/notaryproject/notaryproject/blob/main/specs/signature-specification.md#algorithm-selection) |\n| Compromised Notation dependencies | Tampering              | Mitigated  | High     | Notation       | The dependencies that built into Notation binary was compromised, this may lead to arbitrary code being executed | Notation keeps dependencies up-to-date and adds new dependency after careful consideration and only if it's absolutely required. Always use static build instead of dynamic linking |\n\n## Notation verify artifacts against signatures\n\n### Data flow\n\nA verifier uses Notation to verify artifacts against signatures stored in the file system or in a registry to ensure the authenticity and integrity of the artifacts before deploying the artifacts.\n\nThe following diagram illustrates Notation verifying artifacts stored in a registry:\n\n![Notation verifies artifacts stored in registries](../media/notation-verify-remote.svg)\n\nThe following diagram illustrates Notation verifying artifacts stored in a registry with a verification plugin:\n\n![Notation verifies artifacts stored in registries using verification plugin](../media/notation-verify-plugin.svg)\n\nThe following diagram illustrates Notation verifying artifacts stored as OCI image layout in the file system:\n\n![Notation verifies artifacts as OCI image layout in the filesystem](../media/notation-verify-local.svg)\n\nThe certificates trusted by the verifier are stored in Notation trust store in the file system. Users can download the certificates from KMS or request CA vendor for CA certificates.\n\n### Threats and Mitigation\n\n|   Title                                                        | STRIDE threat type     | Threat Status | Priority | Entity          | Description   | Mitigation   |\n| -------------------------------------------------------------- | ---------------------- | ------------- | -------- | --------------- | ------------- | ------------ |\n| Inaccessible Registry                                          | Denial of Service      | Mitigated     | High     | Registry        | Registry is not able to service incoming requests or perform up to spec, thus users are unable to verify artifacts | Notation supports verification of signatures stored locally on disk|\n| Serving tampered artifacts                                     | Tampering              | Mitigated     | High     | Registry        | Data stored in registries are tampered, this may lead to malicious artifacts being consumed | Notation verifies the digest specified by the user and the digest store in the signature are the same. Notation does support verification using tag but its highly discouraged by emitting a warning |\n| Disclosure of signature info                                   | Information disclosure | Mitigated     | High     | Registry        | Man-in-the-middle attack | Notation interacts with trusted registries via TLS by default or Notation signs artifacts stored in local file system, and then stores signatures locally |\n| Tampered files                                                 | Tampering              | Not Mitigated     | High     | File System      | Files read by Notation are tampered, this may lead to failure of notation verify operation or verification bypassed | Notation must be installed on secure and trusted infrastructure(shared responsibility mode) |\n| Disclosure of files                                            | Information disclosure | Mitigated     | High     | File System      | Files are accessed by attackers, this may lead to disclosure of notation config files and credential files | Notation must be installed on secure and trusted infrastructure(shared responsibility mode). Notation stores the credentials securely using credential store |\n| Malicious plugin                                               | Tampering              | Mitigated     | High     | Notation Plugin | A malicious plugin is installed, this may lead to arbitrary code being executed by attackers | Verify plugin package before installation or plugin is installed by authorized users |\n| Compromised trust policies by the weakest CA                   | Tampering              | Mitigated     | High     | Notation        | An attacker can make the signature verification for any signatures succeed by exploiting a vulnerability in the weakest CA\u2019s infrastructure that exists in the trust store | Notation supports scoping trust policies per a registry. That means, users can write their policies to scope a CA to only to the registry that uses that CA, hence not affecting signatures of other registries signed by other CAs |\n| Malicious signature faking to be signed by a signing authority | Tampering      | Mitigated | High   | Notation     | Unlike notary.x509 signing scheme, trusted timestamps are not checked against RFC#3161 TSA servers for notary.x509.signingAuthority signing scheme. An attacker can use this and bypass trusted timestamp checks by crafting a signature that uses notary.x509 keys but with signingAuthority as the signing scheme. | To prevent this threat, notary.x509.signingAuthority signing scheme requires trusted roots to be present in a trust store type called signingAuthority as opposed to CA trust store type for notary.x509 signing scheme |\n| Inaccessible OCSP Responder                                    | Denial of Service      | Not Mitigated | High     | OCSP Responder  | OCSP Responder is not able to service incoming requests or perform up to spec, thus users are unable to validate certificate revocation status | It cannot be mitigated, since revocation status should be retrieved from OCSP responder, which requires network access. Notation verification should fail if revocation check is configured as `enforced` and OCSP responder is inaccessible. Users can configure trust policy to log or skip revocation check if OCSP responder is not reliable. |\n| Compromised Notation dependencies                              | Tampering              | Mitigated | High     | Notation       | The dependencies that built into Notation binary was compromised, this may lead to arbitrary code being executed | Notation keeps dependencies up-to-date and adds new dependency after careful consideration and only if it's absolutely required. Always use static build instead of dynamic linking |\n| Rollback Attack                              | Tampering              | Mitigated | High     | Notation       | Attacker can exploit a compromised repository to return outdated vulnerable artifacts | Signer can employ short signature expiration periods (and periodically re-sign artifacts) or revoke outdated vulnerable artifacts |"], "filenames": ["threatmodels/notation-threatmodel.md"], "buggy_code_start_loc": [89], "buggy_code_end_loc": [89], "fixing_code_start_loc": [90], "fixing_code_end_loc": [91], "type": "CWE-672", "message": "The Notary Project is a set of specifications and tools intended to provide a cross-industry standard for securing software supply chains by using authentic container images and other OCI artifacts. An external actor with control of a compromised container registry can provide outdated versions of OCI artifacts, such as Images. This could lead artifact consumers with relaxed trust policies (such as `permissive` instead of `strict`) to potentially use artifacts with signatures that are no longer valid, making them susceptible to any exploits those artifacts may contain. In Notary Project, an artifact publisher can control the validity period of artifact by specifying signature expiry during the signing process. Using shorter signature validity periods along with processes to periodically resign artifacts, allows artifact producers to ensure that their consumers will only receive up-to-date artifacts. Artifact consumers should correspondingly use a `strict` or equivalent trust policy that enforces signature expiry. Together these steps enable use of up-to-date artifacts and safeguard against rollback attack in the event of registry compromise. The Notary Project offers various signature validation options such as `permissive`, `audit` and `skip` to support various scenarios. These scenarios includes 1) situations demanding urgent workload deployment, necessitating the bypassing of expired or revoked signatures; 2) auditing of artifacts lacking signatures without interrupting workload; and 3) skipping of verification for specific images that might have undergone validation through alternative mechanisms. Additionally, the Notary Project supports revocation to ensure the signature freshness. Artifact publishers can sign with short-lived certificates and revoke older certificates when necessary. This revocation serves as a signal to inform artifact consumers that the corresponding unexpired artifact is no longer approved by the publisher. This enables the artifact publisher to control the validity of the signature independently of their ability to manage artifacts in a compromised registry.", "other": {"cve": {"id": "CVE-2024-23332", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-19T23:15:07.930", "lastModified": "2024-02-29T21:16:49.777", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Notary Project is a set of specifications and tools intended to provide a cross-industry standard for securing software supply chains by using authentic container images and other OCI artifacts. An external actor with control of a compromised container registry can provide outdated versions of OCI artifacts, such as Images. This could lead artifact consumers with relaxed trust policies (such as `permissive` instead of `strict`) to potentially use artifacts with signatures that are no longer valid, making them susceptible to any exploits those artifacts may contain. In Notary Project, an artifact publisher can control the validity period of artifact by specifying signature expiry during the signing process. Using shorter signature validity periods along with processes to periodically resign artifacts, allows artifact producers to ensure that their consumers will only receive up-to-date artifacts. Artifact consumers should correspondingly use a `strict` or equivalent trust policy that enforces signature expiry. Together these steps enable use of up-to-date artifacts and safeguard against rollback attack in the event of registry compromise. The Notary Project offers various signature validation options such as `permissive`, `audit` and `skip` to support various scenarios. These scenarios includes 1) situations demanding urgent workload deployment, necessitating the bypassing of expired or revoked signatures; 2) auditing of artifacts lacking signatures without interrupting workload; and 3) skipping of verification for specific images that might have undergone validation through alternative mechanisms. Additionally, the Notary Project supports revocation to ensure the signature freshness. Artifact publishers can sign with short-lived certificates and revoke older certificates when necessary. This revocation serves as a signal to inform artifact consumers that the corresponding unexpired artifact is no longer approved by the publisher. This enables the artifact publisher to control the validity of the signature independently of their ability to manage artifacts in a compromised registry."}, {"lang": "es", "value": "Notary Project es un conjunto de especificaciones y herramientas destinadas a proporcionar un est\u00e1ndar intersectorial para proteger las cadenas de suministro de software mediante el uso de im\u00e1genes de contenedores aut\u00e9nticas y otros artefactos OCI. Un actor externo con control de un registro de contenedor comprometido puede proporcionar versiones obsoletas de artefactos OCI, como im\u00e1genes. Esto podr\u00eda llevar a los consumidores de artefactos con pol\u00edticas de confianza relajadas (como \"permisivas\" en lugar de \"estrictas\") a utilizar potencialmente artefactos con firmas que ya no son v\u00e1lidas, haci\u00e9ndolos susceptibles a cualquier vulnerabilidad que esos artefactos puedan contener. En Notary Project, un editor de artefactos puede controlar el per\u00edodo de validez del artefacto especificando la caducidad de la firma durante el proceso de firma. El uso de per\u00edodos de validez de firma m\u00e1s cortos junto con procesos para renunciar peri\u00f3dicamente a los artefactos permite a los productores de artefactos garantizar que sus consumidores solo recibir\u00e1n artefactos actualizados. En consecuencia, los consumidores de artefactos deber\u00edan utilizar una pol\u00edtica de confianza \"estricta\" o equivalente que imponga la caducidad de la firma. En conjunto, estos pasos permiten el uso de artefactos actualizados y protegen contra ataques de reversi\u00f3n en caso de que el registro se vea comprometido. Notary Project ofrece varias opciones de validaci\u00f3n de firmas, como \"permisivo\", \"auditor\u00eda\" y \"omitir\" para admitir varios escenarios. Estos escenarios incluyen 1) situaciones que exigen una implementaci\u00f3n urgente de cargas de trabajo, que requieren eludir firmas caducadas o revocadas; 2) auditor\u00eda de artefactos que carecen de firmas sin interrumpir la carga de trabajo; y 3) omitir la verificaci\u00f3n de im\u00e1genes espec\u00edficas que podr\u00edan haber sido validadas a trav\u00e9s de mecanismos alternativos. Adem\u00e1s, Notary Project admite la revocaci\u00f3n para garantizar la frescura de la firma. Los editores de artefactos pueden firmar con certificados de corta duraci\u00f3n y revocar certificados m\u00e1s antiguos cuando sea necesario. Esta revocaci\u00f3n sirve como se\u00f1al para informar a los consumidores de artefactos que el artefacto vigente correspondiente ya no est\u00e1 aprobado por el editor. Esto permite al editor de artefactos controlar la validez de la firma independientemente de su capacidad para administrar artefactos en un registro comprometido."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:R/S:C/C:N/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 4.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 2.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-672"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:notaryproject:notation-go:*:*:*:*:*:*:*:*", "matchCriteriaId": "3F6147D6-33B0-41A8-B928-2E7FE75BBF0A"}]}]}], "references": [{"url": "https://github.com/notaryproject/specifications/commit/cdabdd1042de2999c685fa5d422a785ded9c983a", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/notaryproject/specifications/security/advisories/GHSA-57wx-m636-g3g8", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/notaryproject/specifications/commit/cdabdd1042de2999c685fa5d422a785ded9c983a"}}