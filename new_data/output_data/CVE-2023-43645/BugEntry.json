{"buggy_code": ["# Changelog\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\nTry to keep listed changes to a concise bulleted list of simple explanations of changes. Aim for the amount of information needed so that readers can understand where they would look in the codebase to investigate the changes' implementation, or where they would look in the documentation to understand how to make use of the change in practice - better yet, link directly to the docs and provide detailed information there. Only elaborate if doing so is required to avoid breaking changes or experimental features from ruining someone's day.\n\n## [Unreleased]\n\n## [1.3.1] - 2023-08-23\n\n### Added\n* Count datastore queries involved in Check resolution metadata ([#880](https://github.com/openfga/openfga/pull/880))\n\n  OpenFGA request logs and traces will now include a field `datastore_query_count` that shows how many queries were involved in a single Check resolution.\n\n* Histogram metric to report the `datastore_query_count` per Check ([#924](https://github.com/openfga/openfga/pull/932))\n\n  This new metric can be used to report percentiles of the number of database queries required to resolve Check requests.\n\n* Check request duration histogram labeled by method and datastore query count ([#950](https://github.com/openfga/openfga/pull/950))\n\n  The `request_duration_by_query_count_ms` metric reports the total request duration (in ms) labelled by the RPC method and ranges of observations for the `datastore_query_count`. This metrics allows operators of an OpenFGA server to report request duration percentiles for Check requests based on the number of database queries that were required to resolve the query.\n\n* Optimize Check to avoid database lookups in some scenarios ([#932](https://github.com/openfga/openfga/pull/932))\n\n* CachedCheckResolver for caching Check subproblems ([#891](https://github.com/openfga/openfga/pull/891))\n\n  This experimental feature adds new caching capabilities to the OpenFGA server. It is an \"opt-in\" feature and thus must be enabled. To enable this feature you must specify the experimental flag `check-query-cache` and set the  `--check-query-cache-enabled=true` flag.\n\n  ```shell\n  openfga run --experimentals check-query-cache --check-query-cache-enabled=true\n  ```\n\n* Server request logs now include the `user-agent` ([#943](https://github.com/openfga/openfga/pull/943))\n\n### Changed\n* Default Check and ListObjects concurrency read limits ([#916](https://github.com/openfga/openfga/pull/916))\n\n  In our last release [v1.3.0](https://github.com/openfga/openfga/releases/tag/v1.3.0) we modified the default behavior of Check and ListObjects such that it limits/restricts the degree of concurrency that is allowed for a single request. This change was unintended. This release reverts the default behavior back to unbounded concurrency limits (the prior default). The change mostly affects those using OpenFGA as a library.\n\n* Bumped up to Go 1.21 ([#952](https://github.com/openfga/openfga/pull/952))\n\n### Security\n* Patches [CVE-2023-40579](https://github.com/openfga/openfga/security/advisories/GHSA-jcf2-mxr2-gmqp) - see the CVE for more details\n\n## [1.3.0] - 2023-08-01\n\n[Full changelog](https://github.com/openfga/openfga/compare/v1.2.0...v1.3.0)\n\n### Added\n* Bounded concurrency limiter for Check and ListObjects queries ([#860](https://github.com/openfga/openfga/pull/860), [#887](https://github.com/openfga/openfga/pull/887))\n  New server configurations can be provided to limit/bound the amount of concurrency that is allowed during query evaluation. These settings can help reduce the impact/burden that a single query (e.g. Check, ListObjects, etc..) can have on the underlying database and OpenFGA server.\n\n  * `--maxConcurrentReadsForListObjects` - The maximum allowed number of concurrent reads in a single ListObjects query.\n\n  * `--maxConcurrentReadsForCheck` - The maximum allowed number of concurrent reads in a single Check query.\n\n  * `--resolveNodeBreadthLimit` - Defines how many nodes on a given level can be evaluated concurrently in a Check resolution tree.\n\n* Jaeger persistent storage for traces in `docker-compose.yaml` ([#888](https://github.com/openfga/openfga/pull/888)) - thanks @Azanul\n\n### Fixed\n* Disable default debug level-logging in `retryablehttp` client ([#882](https://github.com/openfga/openfga/pull/882)) - thanks @KlausVii\n\n### Changed\n* [BREAKING] Imports for OpenFGA protobuf API dependencies ([#898](https://github.com/openfga/openfga/pull/898))\n  * **Problem** - Previously we depended on [Buf remote generated packages](https://buf.build/docs/bsr/remote-packages/overview), but they recently deprecated protobuf imports served from the `go.buf.build` domain (see [Migrate from remote generation alpha](https://buf.build/docs/migration-guides/migrate-remote-generation-alpha)). OpenFGA builds are currently broken as a result of this.\n  * **Change** - We switched our protobuf API dependency from `go.buf.build/openfga/go/openfga/api/openfga/v1` to `github.com/openfga/api/proto/openfga/v1`. So we no longer use Buf remote generated packages in favor of packages we managed in the [`openfga/api`](https://github.com/openfga/api) repository. This fixes existing build issues.\n  * **Impact** - Developers using the OpenFGA as a library or the gRPC API must change their protobuf dependency from `go.buf.build/openfga/go/openfga/api/openfga/v1` to `github.com/openfga/api/proto/openfga/v1`. A global find/replace and package depedency update should fix it. Here's a diff demonstrating the changes for a Go app, for example:\n\n    ```go\n    import (\n      ...\n    - openfgav1 \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n    + openfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n    )\n    ```\n\n* Refactor the `Server` constructor to use the options builder pattern ([#833](https://github.com/openfga/openfga/pull/833))\n\n  ```go\n  import (\n    openfga \"github.com/openfga/openfga/pkg/server\"\n  )\n\n  s := openfga.New(\n    &server.Dependencies{...},\n    &server.Config{...},\n  )\n  ```\n  becomes\n  ```go\n  import (\n    openfga \"github.com/openfga/openfga/pkg/server\"\n  )\n\n  var opts []openfga.OpenFGAServiceV1Option\n  s := openfga.MustNewServerWithOpts(opts...)\n  ```\n## [1.2.0] - 2023-06-30\n\n[Full changelog](https://github.com/openfga/openfga/compare/v1.1.1...v1.2.0)\n\n### Added\n* Optimizations for [ListObjects](https://openfga.dev/api/service#/Relationship%20Queries/ListObjects) and [StreamedListObjects](https://openfga.dev/api/service#/Relationship%20Queries/StreamedListObjects) for models involving intersection (`and`) and exclusion (`but not`) ([#797](https://github.com/openfga/openfga/pull/797))\n\n### Changed\n* Cache model validation results on first model load ([#831](https://github.com/openfga/openfga/pull/831))\n* Cache inflight requests when looking up any authorization model ([#831](https://github.com/openfga/openfga/pull/831))\n* Update postgres max connections in docker compose file ([#829](https://github.com/openfga/openfga/pull/829))\n\n## [1.1.1] - 2023-06-26\n\n[Full changelog](https://github.com/openfga/openfga/compare/v1.1.0...v1.1.1)\n\n### Added\n* Official Homebrew installation instructions ([#781](https://github.com/openfga/openfga/pull/781)) - thanks @chenrui333\n* The `--verbose` flag has been added to the `openfga migrate` command ([#776](https://github.com/openfga/openfga/pull/776))\n* The `openfga validate-models` CLI command has been introduced to validate all models across all stores ([#817](https://github.com/openfga/openfga/pull/817))\n\n### Changed\n* Updated the version of the `grpc-health-probe` binary included in OpenFGA builds ([#784](https://github.com/openfga/openfga/pull/784))\n* Cache inflight requests when looking up the latest authorization model ([#820](https://github.com/openfga/openfga/pull/820))\n\n### Fixed\n* Validation of models with non-zero entrypoints ([#802](https://github.com/openfga/openfga/pull/802))\n* Remove unintended newlines in model validation error messages ([#816](https://github.com/openfga/openfga/pull/816)) - thanks @Galzzly\n\n### Security\n* Patches [CVE-2023-35933](https://github.com/openfga/openfga/security/advisories/GHSA-hr9r-8phq-5x8j) - additional model validations are now applied to models that can lead to the vulnerability. See the CVE report for more details, and don't hesitate to reach out if you have questions.\n\n## [1.1.0] - 2023-05-15\n\n[Full changelog](https://github.com/openfga/openfga/compare/v1.0.1...v1.1.0)\n\n## Added\n* Streaming ListObjects has no limit in number of results returned ([#733](https://github.com/openfga/openfga/pull/733))\n* Add Homebrew release stage to goreleaser's release process ([#716](https://github.com/openfga/openfga/pull/716))\n\n## Fixed\n* Avoid DB connection churning in unoptimized ListObjects ([#711](https://github.com/openfga/openfga/pull/711))\n* Ensure ListObjects respects configurable ListObjectsDeadline ([#704](https://github.com/openfga/openfga/pull/704))\n* In Write, throw 400 instead of 500 error if auth model ID not found ([#725](https://github.com/openfga/openfga/pull/725))\n* Performance improvements when loading the authorization model ([#726](https://github.com/openfga/openfga/pull/726))\n* Ensure Check evaluates deterministically on the eval boundary case ([#732](https://github.com/openfga/openfga/pull/732))\n\n## Changed\n* [BREAKING] The flags to turn on writing and evaluation of `v1.0` models have been dropped ([#763](https://github.com/openfga/openfga/pull/763))\n\n## [1.0.1] - 2023-04-18\n\n[Full changelog](https://github.com/openfga/openfga/compare/v1.0.0...v1.0.1)\n\n## Fixed\n* Correct permission and location for gRPC health probe in Docker image (#697)\n\n## [1.0.0] - 2023-04-14\n\n[Full changelog](https://github.com/openfga/openfga/compare/v0.4.3...v1.0.0)\n\n## Ready for Production with Postgres \nOpenFGA with Postgres is now considered stable and ready for production usage.\n\n## Fixed\n* MySQL migration script errors during downgrade (#664)\n\n## [0.4.3] - 2023-04-12\n\n[Full changelog](https://github.com/openfga/openfga/compare/v0.4.2...v0.4.3)\n\n## Added\n* Release artifacts are now signed and include a Software Bill of Materials (SBOM) ([#683](https://github.com/openfga/openfga/pull/683))\n\n  The SBOM (Software Bill of Materials) is included in each Github release using [Syft](https://github.com/anchore/syft) and is exported in [SPDX](https://spdx.dev) format.\n\n  Developers will be able to verify the signature of the release artifacts with the following workflow(s):\n\n  ```shell\n  wget https://github.com/openfga/openfga/releases/download/<tag>/checksums.txt\n\n  cosign verify-blob \\\n    --certificate-identity 'https://github.com/openfga/openfga/.github/workflows/release.yml@refs/tags/<tag>' \\\n    --certificate-oidc-issuer 'https://token.actions.githubusercontent.com' \\\n    --cert https://github.com/openfga/openfga/releases/download/<tag>/checksums.txt.pem \\\n    --signature https://github.com/openfga/openfga/releases/download/<tag>/checksums.txt.sig \\\n    ./checksums.txt\n  ```\n\n  If the `checksums.txt` validation succeeds, it means the checksums included in the release were not tampered with, so we can use it to verify the hashes of other files using the `sha256sum` utility. You can then download any file you want from the release, and verify it with, for example:\n\n  ```shell\n  wget https://github.com/openfga/openfga/releases/download/<tag>/openfga_<version>_linux_amd64.tar.gz.sbom\n  wget https://github.com/openfga/openfga/releases/download/<tag>/openfga_<version>_linux_amd64.tar.gz\n\n  sha256sum --ignore-missing -c checksums.txt\n  ```\n\n  And both should say \"OK\".\n\n  You can then inspect the .sbom file to see the entire dependency tree of the binary.\n\n  Developers can also verify the Docker image signature. Cosign actually embeds the signature in the image manifest, so we only need the public key used to sign it in order to verify its authenticity:\n\n  ```shell\n  cosign verify -key cosign.pub openfga/openfga:<tag>\n  ```\n\n* `openfga migrate` now accepts reading configuration from a config file and environment variables like the `openfga run` command ([#655](https://github.com/openfga/openfga/pull/655)) - thanks @suttod!\n\n* The `--trace-service-name` command-line flag has been added to allow for customizing the service name in traces ([#652](https://github.com/openfga/openfga/pull/652)) - thanks @jmiettinen\n\n## Fixed\n* Postgres and MySQL implementations have been fixed to avoid ordering relationship tuple queries by `ulid` when it is not needed. This can improve read query performance on larger OpenFGA stores ([#677](https://github.com/openfga/openfga/pull/677))\n* Synchronize concurrent access to in-memory storage iterators ([#587](https://github.com/openfga/openfga/pull/587))\n* Improve error logging in the `openfga migrate` command ([#663](https://github.com/openfga/openfga/pull/663))\n* Fix middleware ordering so that `requestid` middleware is registered earlier ([#662](https://github.com/openfga/openfga/pull/662))\n\n## Changed\n* Bumped up to Go version 1.20 ([#664](https://github.com/openfga/openfga/pull/664))\n* Default model schema versions to 1.1 ([#669](https://github.com/openfga/openfga/pull/669))\n\n  In preparation for sunsetting support for models with schema version 1.0, the [WriteAuthorizationModel API](https://openfga.dev/api/service#/Authorization%20Models/WriteAuthorizationModel) will now interpret any model provided to it as a 1.1 model if the `schema_version` field is omitted in the request. This shouldn't affect default behavior since 1.0 model support is enabled by default.\n\n## [0.4.2] - 2023-03-17\n\n[Full changelog](https://github.com/openfga/openfga/compare/v0.4.1...v0.4.2)\n\n### Fixed\n* Correct migration path for mysql in `openfga migrate` ([#644](https://github.com/openfga/openfga/pull/664))\n\n## [0.4.1] - 2023-03-16\n\n[Full changelog](https://github.com/openfga/openfga/compare/v0.4.0...v0.4.1)\n\n\nThe `v0.4.1` release includes everything in `v0.4.0` which includes breaking changes, please read the [`v0.4.0` changelog entry](#040---2023-03-15) for more details.\n\n### Fixed\n\n* Fix ListObjects not returning objects a user has access to in some cases (openfga/openfga#637)\n\n## [0.4.0] - 2023-03-15\n\n[Full changelog](https://github.com/openfga/openfga/compare/v0.3.7...v0.4.0)\n\n> Note: the 0.4.0 release was held due to issues discovered after the release was cut.\n\n### Removed\n\n* [BREAKING] Disable schema 1.0 support, except if appropriate flags are set (openfga/openfga#613)\n  * As of this release, OpenFGA no longer allows writing or evaluating schema `v1.0` models by default. If you need support for it for now, you can use the:\n    * `OPENFGA_ALLOW_WRITING_1_0_MODELS`: set to `true` to allow `WriteAuthorizationModel` to accept schema `v1.0` models.\n    * `OPENFGA_ALLOW_EVALUATING_1_0_MODELS`: set to `true` to allow `Check`, `Expand`, `ListObjects`, `Write` and `WriteAssertions` that target schema `v1.0` models.\n    * `ReadAuthorizationModel`, `ReadAuthorizationModels` and `ReadAssertions` are unaffected and will continue to work regardless of the target model schema version.\n  * Note that these flags will be removed and support fully dropped in a future release. Read the [Schema v1.0 Deprecation Timeline](https://openfga.dev/docs/modeling/migrating/migrating-schema-1-1#deprecation-timeline) for more details.\n\n### Added\n* Add OpenFGA version command to the CLI ([#625](https://github.com/openfga/openfga/pull/625))\n* Add `timeout` flag to `migrate` command ([#634](https://github.com/openfga/openfga/pull/634))\n\n### Fixed\n\n* Improve the speed of Check for 1.1 models by using type restrictions (([#545](https://github.com/openfga/openfga/pull/545), ([#596](https://github.com/openfga/openfga/pull/596))\n* Various important fixes to the experimental ListObjects endpoint\n  * Improve readUsersets query by dropping unnecessary sorting ([#631](https://github.com/openfga/openfga/pull/631),([#633](https://github.com/openfga/openfga/pull/633))\n  * Fix null pointer exception if computed userset does not exist ([#572](https://github.com/openfga/openfga/pull/572))\n  * Fix race condition in memory store ([#585](https://github.com/openfga/openfga/pull/585))\n  * Ensure no objects returned that would not have been allowed in Checks ([#577](https://github.com/openfga/openfga/pull/577))\n  * Reverse expansion with indirect computed userset relationship ([#611](https://github.com/openfga/openfga/pull/611))\n  * Improved tests ([#582](https://github.com/openfga/openfga/pull/582), [#599](https://github.com/openfga/openfga/pull/599), [#601](https://github.com/openfga/openfga/pull/601), [#620](https://github.com/openfga/openfga/pull/620))\n* Tuning of OTEL parameters ([#570](https://github.com/openfga/openfga/pull/570))\n* Fix tracing in Check API ([#627](https://github.com/openfga/openfga/pull/627))\n* Use chainguard images in Dockerfile ([#628](https://github.com/openfga/openfga/pull/628))\n\n\n## [0.3.7] - 2023-02-21\n\n[Full changelog](https://github.com/openfga/openfga/compare/v0.3.6...v0.3.7)\n\n### Fixed\n* Contextual tuple propagation in the unoptimized ListObjects implementation ([#565](https://github.com/openfga/openfga/pull/565))\n\n## [0.3.6] - 2023-02-16\n\n[Full changelog](https://github.com/openfga/openfga/compare/v0.3.5...v0.3.6)\n\nRe-release of `v0.3.5` because the go module proxy cached a prior commit of the `v0.3.5` tag.\n\n## [0.3.5] - 2023-02-14\n\n[Full changelog](https://github.com/openfga/openfga/compare/v0.3.4...v0.3.5)\n\n### Added\n* [`grpc-health-probe`](https://github.com/grpc-ecosystem/grpc-health-probe) for Health Checks ([#520](https://github.com/openfga/openfga/pull/520))\n\n  OpenFGA containers now include an embedded `grpc_health_probe` binary that can be used to probe the Health Check endpoints of OpenFGA servers. Take a look at the [docker-compose.yaml](https://github.com/openfga/openfga/blob/main/docker-compose.yaml) file for an example.\n\n* Improvements to telemetry: logging, tracing, and metrics ([#468](https://github.com/openfga/openfga/pull/468), [#514](https://github.com/openfga/openfga/pull/514), [#517](https://github.com/openfga/openfga/pull/517), [#522](https://github.com/openfga/openfga/pull/522))\n\n  * We have added Prometheus as the standard metrics provided for OpenFGA and provide a way to launch Grafana to view the metrics locally. See [docker-compose.yaml](https://github.com/openfga/openfga/blob/main/docker-compose.yaml) for more information.\n\n  * We've improved the attributes of various trace spans and made sure that trace span names align with the functions they decorate.\n\n  * Our logging has been enhanced with more logged fields including request level logging which includes a `request_id` and `store_id` field in the log message.\n\n  These features will allow operators of OpenFGA to improve their monitoring and observability processes.\n\n* Nightly releases ([#508](https://github.com/openfga/openfga/pull/508)) - thanks @Siddhant-K-code!\n\n  You should now be able to run nightly releases of OpenFGA using `docker pull openfga/openfga:nightly`\n\n### Fixed\n* Undefined computed relations on tuplesets now behave properly ([#532](https://github.com/openfga/openfga/pull/532))\n\n  If you had a model involing two different computed relations on the same tupleset, then it's possible you may have received an internal server error if one of the computed relations was undefined. For example,\n  ```\n  type document\n    relations\n      define parent as self\n      define viewer as x from parent or y from parent\n\n  type folder\n    relations\n      define x as self\n\n  type org\n    relations\n      define y as self\n  ```\n  Given the tuple `{ user: \"org:contoso\", relation: \"parent\", object: \"document:1\" }`, then `Check({ user: \"jon\", relation: \"viewer\", object: \"document:1\" })` would return an error prior to this fix because the `x` computed relation on the `document#parent` tupleset relation is not defined for the `org` object type.\n\n* Eliminate duplicate objects in ListObjects response ([#528](https://github.com/openfga/openfga/pull/528))\n\n## [0.3.4] - 2023-02-02\n\n[Full changelog](https://github.com/openfga/openfga/compare/v0.3.3...v0.3.4)\n\n### Fixed\n\n* Fixed the environment variable mapping ([#498](https://github.com/openfga/openfga/pull/498)). For the full list of environment variables see [.config-schema.json](https://github.com/openfga/openfga/blob/main/.config-schema.json).\n* Fix for stack overflow error in ListObjects ([#506](https://github.com/openfga/openfga/pull/506)). Thank you for reporting the issue @wonderbeyond!\n\n### Added\n\n* Added OpenTelemetry tracing ([#499](https://github.com/openfga/openfga/pull/499))\n\n### Removed\n\n* The ReadTuples endpoint has been removed ([#495](https://github.com/openfga/openfga/pull/495)). Please use [Read](https://openfga.dev/api/service#/Relationship%20Tuples/Read) with no tuple key instead (e.g. `POST /stores/<store_id>/read` with `{}` as the body).\n\n## [0.3.3] - 2023-01-31\n\n[Full changelog](https://github.com/openfga/openfga/compare/v0.3.2...v0.3.3)\n\n### Added\n\n* Environment variable names have been updated ([#472](https://github.com/openfga/openfga/pull/472)).\n\n  For example, `OPENFGA_MAX_TUPLES_PER_WRITE` instead of `OPENFGA_MAXTUPLESPERWRITE`.\n\n  For the full list please see [.config-schema.json](https://github.com/openfga/openfga/blob/main/.config-schema.json).\n\n  The old form still works but is considered deprecated and should not be used anymore.\n\n* Optimized ListObjects is now on by default ([#489](https://github.com/openfga/openfga/pull/489)) (`--experimentals=\"list-objects-optimized\"` is no longer needed)\n\n* Avoid connection churn in our datastore implementations ([#474](https://github.com/openfga/openfga/pull/474))\n\n* The default values for `OPENFGA_DATASTORE_MAX_OPEN_CONNS` and `OPENFGA_DATASTORE_MAX_IDLE_CONNS` have been set to 30 and 10 respectively ([#492](https://github.com/openfga/openfga/pull/492))\n\n### Fixed\n\n* ListObjects should no longer return duplicates ([#475](https://github.com/openfga/openfga/pull/475))\n\n## [0.3.2] - 2023-01-18\n\n[Full changelog](https://github.com/openfga/openfga/compare/v0.3.1...v0.3.2)\n\n\n### Added\n* OpenTelemetry metrics integration with an `otlp` exporter ([#360](https://github.com/openfga/openfga/pull/360)) - thanks @AlexandreBrg!\n\n  To export OpenTelemetry metrics from an OpenFGA instance you can now provide the `otel-metrics` experimental flag along with the `--otel-telemetry-endpoint` and `--otel-telemetry-protocol` flags. For example,\n\n  ```\n  ./openfga run --experimentals=otel-metrics --otel-telemetry-endpoint=127.0.0.1:4317 --otel-telemetry-protocol=http\n  ```\n\n  For more information see the official documentation on [Experimental Features](https://openfga.dev/docs/getting-started/setup-openfga/docker#experimental-features) and [Telemetry](https://openfga.dev/docs/getting-started/setup-openfga/docker#telemetry).\n\n* Type-bound public access support in the optimized ListObjects implementation (when the `list-objects-optimized` experimental feature is enabled) ([#444](https://github.com/openfga/openfga/pull/444))\n\n### Fixed\n* Tuple validations for models with schema version 1.1 ([#446](https://github.com/openfga/openfga/pull/446), [#457](https://github.com/openfga/openfga/pull/457))\n* Evaluate rewrites on nested usersets in the optimized ListObjects implementation ([#432](https://github.com/openfga/openfga/pull/432))\n\n## [0.3.1] - 2022-12-19\n\n[Full changelog](https://github.com/openfga/openfga/compare/v0.3.0...v0.3.1)\n\n### Added\n* Datastore configuration flags to control connection pool settings\n  `--datastore-max-open-conns`\n  `--datastore-max-idle-conns`\n  `--datastore-conn-max-idle-time`\n  `--datastore-conn-max-lifetime`\n  These flags can be used to fine-tune database connections for your specific deployment of OpenFGA.\n\n* Log level configuration flags\n  `--log-level` (can be one of ['none', 'debug', 'info', 'warn', 'error', 'panic', 'fatal'])\n\n* Support for Experimental Feature flags\n  A new flag `--experimentals` has been added to enable certain experimental features in OpenFGA. For more information see [Experimental Features](https://openfga.dev/docs/getting-started/setup-openfga/docker#experimental-features).\n\n### Security\n* Patches [CVE-2022-23542](https://github.com/openfga/openfga/security/advisories/GHSA-m3q4-7qmj-657m) - relationship reads now respect type restrictions from prior models ([#422](https://github.com/openfga/openfga/pull/422)).\n\n## [0.3.0] - 2022-12-12\n\n[Full changelog](https://github.com/openfga/openfga/compare/v0.2.5...v0.3.0)\n\nThis release comes with a few big changes:\n\n### Support for [v1.1 JSON Schema](https://github.com/openfga/rfcs/blob/feat/add-type-restrictions-to-json-syntax/20220831-add-type-restrictions-to-json-syntax.md)\n\n- You can now write your models in the [new DSL](https://github.com/openfga/rfcs/blob/type-restriction-dsl/20221012-add-type-restrictions-to-dsl-syntax.md)\nwhich the Playground and the [syntax transformer](https://github.com/openfga/syntax-transformer) can convert to the\nJSON syntax. Schema v1.1 allows for adding type restrictions to each assignable relation, and it can be used to\nindicate cases such as \"The folder's parent must be a folder\" (and so not a user or a document).\n  - This change also comes with breaking changes to how `*` and `<type>:*` are treated:\n  - `<type>:*` is interpreted differently according to the model version. v1.0 will interpret it as a object of type\n    `<type>` and id `*`, whereas v1.1 will interpret is as all objects of type `<type>`.\n  - `*` is still supported in v1.0 models, but not supported in v1.1 models. A validation error will be thrown when\n    used in checks or writes and it will be ignored when evaluating.\n- Additionally, the change to v1.1 models allows us to provide more consistent validation when writing the model\ninstead of when issuing checks.\n\n:warning: Note that with this release **models with schema version 1.0 are now considered deprecated**, with the plan to\ndrop support for them over the next couple of months, please migrate to version 1.1 when you can. Read more about\n[migrating to the new syntax](https://openfga.dev/docs/modeling/migrating/migrating-schema-1-1).\n\n### ListObjects changes\n\nThe response has changed to include the object type, for example:\n```json\n{ \"object_ids\": [ \"a\", \"b\", \"c\" ] }\n```\nto\n```json\n{ \"objects\": [ \"document:a\", \"document:b\", \"document:c\" ] }\n```\n\nWe have also improved validation and fixed support for Contextual Tuples that were causing inaccurate responses to be\nreturned.\n\n### ReadTuples deprecation\n\n:warning:This endpoint is now marked as deprecated, and support for it will be dropped shortly. Please use Read with\nno tuple key instead.\n\n\n## [0.2.5] - 2022-11-07\n### Security\n* Patches [CVE-2022-39352](https://github.com/openfga/openfga/security/advisories/GHSA-3gfj-fxx4-f22w)\n\n### Added\n* Multi-platform container build manifests to releases ([#323](https://github.com/openfga/openfga/pull/323))\n\n### Fixed\n* Read RPC returns correct error when authorization model id is not found ([#312](https://github.com/openfga/openfga/pull/312))\n* Throw error if `http.upstreamTimeout` config is less than `listObjectsDeadline` ([#315](https://github.com/openfga/openfga/pull/315))\n\n## [0.2.4] - 2022-10-24\n### Security\n* Patches [CVE-2022-39340](https://github.com/openfga/openfga/security/advisories/GHSA-95x7-mh78-7w2r), [CVE-2022-39341](https://github.com/openfga/openfga/security/advisories/GHSA-vj4m-83m8-xpw5), and [CVE-2022-39342](https://github.com/openfga/openfga/security/advisories/GHSA-f4mm-2r69-mg5f)\n\n### Fixed\n* TLS certificate config path mappings ([#285](https://github.com/openfga/openfga/pull/285))\n* Error message when a `user` field is invalid ([#278](https://github.com/openfga/openfga/pull/278))\n* host:port mapping with unspecified host ([#275](https://github.com/openfga/openfga/pull/275))\n* Wait for connection to postgres before starting ([#270](https://github.com/openfga/openfga/pull/270))\n\n\n### Added\n* Update Go to 1.19\n\n## [0.2.3] - 2022-10-05\n### Added\n* Support for MySQL storage backend ([#210](https://github.com/openfga/openfga/pull/210)). Thank you @MidasLamb!\n* Allow specification of type restrictions in authorization models ([#223](https://github.com/openfga/openfga/pull/223)). Note: Type restriction is not enforced yet, this just allows storing them.\n* Tuple validation against type restrictions in Write API ([#232](https://github.com/openfga/openfga/pull/232))\n* Upgraded the Postgres storage backend to use pgx v5 ([#225](https://github.com/openfga/openfga/pull/225))\n\n### Fixed\n* Close database connections after migration ([#252](https://github.com/openfga/openfga/pull/252))\n* Race condition in streaming ListObjects ([#255](https://github.com/openfga/openfga/pull/255), [#256](https://github.com/openfga/openfga/pull/256))\n\n\n## [0.2.2] - 2022-09-15\n### Fixed\n* Reject direct writes if only indirect relationship allowed ([#114](https://github.com/openfga/openfga/pull/114)). Thanks @dblclik!\n* Log internal errors at the grpc layer ([#222](https://github.com/openfga/openfga/pull/222))\n* Authorization model validation ([#224](https://github.com/openfga/openfga/pull/224))\n* Bug in `migrate` command ([#236](https://github.com/openfga/openfga/pull/236))\n* Skip malformed tuples involving tuple to userset definitions ([#234](https://github.com/openfga/openfga/pull/234))\n\n## [0.2.1] - 2022-08-30\n### Added\n* Support Check API calls on userset types of users ([#146](https://github.com/openfga/openfga/pull/146))\n* Add backoff when connecting to Postgres ([#188](https://github.com/openfga/openfga/pull/188))\n\n### Fixed\n* Improve logging of internal server errors ([#193](https://github.com/openfga/openfga/pull/193))\n* Use Postgres in the sample Docker Compose file ([#195](https://github.com/openfga/openfga/pull/195))\n* Emit authorization errors ([#144](https://github.com/openfga/openfga/pull/144))\n* Telemetry in Check and ListObjects APIs ([#177](https://github.com/openfga/openfga/pull/177))\n* ListObjects API: respect the value of ListObjectsMaxResults ([#181](https://github.com/openfga/openfga/pull/181))\n\n\n## [0.2.0] - 2022-08-12\n### Added\n* [ListObjects API](https://openfga.dev/api/service#/Relationship%20Queries/ListObjects)\n\n  The ListObjects API provides a way to list all of the objects (of a particular type) that a user has a relationship with. It provides a solution to the [Search with Permissions (Option 3)](https://openfga.dev/docs/interacting/search-with-permissions#option-3-build-a-list-of-ids-then-search) use case for access-aware filtering on smaller object collections. It implements the [ListObjects RFC](https://github.com/openfga/rfcs/blob/main/20220714-listObjects-api.md).\n\n  This addition brings with it two new server configuration options `--listObjects-deadline` and `--listObjects-max-results`. These configurations help protect the server from excessively long lived and large responses.\n\n  > \u26a0\ufe0f If `--listObjects-deadline` or `--listObjects-max-results` are provided, the endpoint may only return a subset of the data. If you provide the deadline but returning all of the results would take longer than the deadline, then you may not get all of the results. If you limit the max results to 1, then you'll get at most 1 result.\n\n* Support for presharedkey authentication in the Playground ([#141](https://github.com/openfga/openfga/pull/141))\n\n  The embedded Playground now works if you run OpenFGA using one or more preshared keys for authentication. OIDC authentication remains unsupported for the Playground at this time.\n\n\n## [0.1.7] - 2022-07-29\n### Added\n* `migrate` CLI command ([#56](https://github.com/openfga/openfga/pull/56))\n\n  The `migrate` command has been added to the OpenFGA CLI to assist with bootstrapping and managing database schema migrations. See the usage for more info.\n\n  ```\n  \u279c openfga migrate -h\n  The migrate command is used to migrate the database schema needed for OpenFGA.\n\n  Usage:\n    openfga migrate [flags]\n\n  Flags:\n        --datastore-engine string   (required) the database engine to run the migrations for\n        --datastore-uri string      (required) the connection uri of the database to run the migrations against (e.g. 'postgres://postgres:password@localhost:5432/postgres')\n    -h, --help                      help for migrate\n        --version uint              the version to migrate to (if omitted the latest schema will be used)\n  ```\n\n## [0.1.6] - 2022-07-27\n### Fixed\n* Issue with embedded Playground assets found in the `v0.1.5` released docker image ([#129](https://github.com/openfga/openfga/pull/129))\n\n## [0.1.5] - 2022-07-27\n### Added\n* Support for defining server configuration in `config.yaml`, CLI flags, or env variables ([#63](https://github.com/openfga/openfga/pull/63), [#92](https://github.com/openfga/openfga/pull/92), [#100](https://github.com/openfga/openfga/pull/100))\n\n  `v0.1.5` introduces multiple ways to support a variety of server configuration strategies. You can configure the server with CLI flags, env variables, or a `config.yaml` file.\n\n  Server config will be loaded in the following order of precedence:\n\n    * CLI flags (e.g. `--datastore-engine`)\n    * env variables (e.g. `OPENFGA_DATASTORE_ENGINE`)\n    * `config.yaml`\n\n  If a `config.yaml` file is provided, the OpenFGA server will look for it in `\"/etc/openfga\"`, `\"$HOME/.openfga\"`, or `\".\"` (the current working directory), in that order.\n\n* Support for grpc health checks ([#86](https://github.com/openfga/openfga/pull/86))\n\n  `v0.1.5` introduces support for the [GRPC Health Checking Protocol](https://github.com/grpc/grpc/blob/master/doc/health-checking.md). The server's health can be checked with the grpc or HTTP health check endpoints (the `/healthz` endpoint is just a proxy to the grpc health check RPC).\n\n  For example,\n  ```\n  grpcurl -plaintext \\\n    -d '{\"service\":\"openfga.v1.OpenFGAService\"}' \\\n    localhost:8081 grpc.health.v1.Health/Check\n  ```\n  or, if the HTTP server is enabled, with the `/healthz` endpoint:\n  ```\n  curl --request GET -d '{\"service\":\"openfga.v1.OpenFGAService\"}' http://localhost:8080/healthz\n  ```\n\n* Profiling support (pprof) ([#111](https://github.com/openfga/openfga/pull/111))\n\n  You can now profile the OpenFGA server while it's running using the [pprof](https://github.com/google/pprof/blob/main/doc/README.md) profiler. To enable the pprof profiler set `profiler.enabled=true`. It is served on the `/debug/pprof` endpoint and port `3001` by default.\n\n* Configuration to enable/disable the HTTP server ([#84](https://github.com/openfga/openfga/pull/84))\n\n  You can now enable/disable the HTTP server by setting `http.enabled=true/false`. It is enabled by default.\n\n### Changed\n* Env variables have a new mappings.\n\n  Please refer to the [`.config-schema.json`](https://github.com/openfga/openfga/blob/main/.config-schema.json) file for a description of the new configurations or `openfga run -h` for the CLI flags. Env variables are   mapped by prefixing `OPENFGA` and converting dot notation into underscores (e.g. `datastore.uri` becomes `OPENFGA_DATASTORE_URI`). \n\n### Fixed\n* goroutine leaks in Check resolution. ([#113](https://github.com/openfga/openfga/pull/113))\n\n## [0.1.4] - 2022-06-27\n### Added\n* OpenFGA Playground support ([#68](https://github.com/openfga/openfga/pull/68))\n* CORS policy configuration ([#65](https://github.com/openfga/openfga/pull/65))\n\n## [0.1.2] - 2022-06-20\n### Added\n* Request validation middleware\n* Postgres startup script\n\n## [0.1.1] - 2022-06-16\n### Added\n* TLS support for both the grpc and HTTP servers\n* Configurable logging formats including `text` and `json` formats\n* OpenFGA CLI with a preliminary `run` command to run the server\n\n## [0.1.0] - 2022-06-08\n### Added\n* Initial working implementation of OpenFGA APIs (Check, Expand, Write, Read, Authorization Models, etc..)\n* Postgres storage adapter implementation\n* Memory storage adapter implementation\n* Early support for preshared key or OIDC authentication methods\n\n[Unreleased]: https://github.com/openfga/openfga/compare/v1.3.1...HEAD\n[1.3.1]: https://github.com/openfga/openfga/releases/tag/v1.3.1\n[1.3.0]: https://github.com/openfga/openfga/releases/tag/v1.3.0\n[1.2.0]: https://github.com/openfga/openfga/releases/tag/v1.2.0\n[1.1.1]: https://github.com/openfga/openfga/releases/tag/v1.1.1\n[1.1.0]: https://github.com/openfga/openfga/releases/tag/v1.1.0\n[1.0.1]: https://github.com/openfga/openfga/releases/tag/v1.0.1\n[1.0.0]: https://github.com/openfga/openfga/releases/tag/v1.0.0\n[0.4.3]: https://github.com/openfga/openfga/releases/tag/v0.4.3\n[0.4.2]: https://github.com/openfga/openfga/releases/tag/v0.4.2\n[0.4.1]: https://github.com/openfga/openfga/releases/tag/v0.4.1\n[0.4.0]: https://github.com/openfga/openfga/releases/tag/v0.4.0\n[0.3.7]: https://github.com/openfga/openfga/releases/tag/v0.3.7\n[0.3.6]: https://github.com/openfga/openfga/releases/tag/v0.3.6\n[0.3.5]: https://github.com/openfga/openfga/releases/tag/v0.3.5\n[0.3.4]: https://github.com/openfga/openfga/releases/tag/v0.3.4\n[0.3.3]: https://github.com/openfga/openfga/releases/tag/v0.3.3\n[0.3.2]: https://github.com/openfga/openfga/releases/tag/v0.3.2\n[0.3.1]: https://github.com/openfga/openfga/releases/tag/v0.3.1\n[0.3.0]: https://github.com/openfga/openfga/releases/tag/v0.3.0\n[0.2.5]: https://github.com/openfga/openfga/releases/tag/v0.2.5\n[0.2.4]: https://github.com/openfga/openfga/releases/tag/v0.2.4\n[0.2.3]: https://github.com/openfga/openfga/releases/tag/v0.2.3\n[0.2.2]: https://github.com/openfga/openfga/releases/tag/v0.2.2\n[0.2.1]: https://github.com/openfga/openfga/releases/tag/v0.2.1\n[0.2.0]: https://github.com/openfga/openfga/releases/tag/v0.2.0\n[0.1.7]: https://github.com/openfga/openfga/releases/tag/v0.1.7\n[0.1.6]: https://github.com/openfga/openfga/releases/tag/v0.1.6\n[0.1.5]: https://github.com/openfga/openfga/releases/tag/v0.1.5\n[0.1.4]: https://github.com/openfga/openfga/releases/tag/v0.1.4\n[0.1.2]: https://github.com/openfga/openfga/releases/tag/v0.1.2\n[0.1.1]: https://github.com/openfga/openfga/releases/tag/v0.1.1\n[0.1.0]: https://github.com/openfga/openfga/releases/tag/v0.1.0\n", "package graph\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"sync\"\n\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\t\"github.com/openfga/openfga/internal/validation\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/storage/storagewrappers\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"go.opentelemetry.io/otel\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.opentelemetry.io/otel/trace\"\n)\n\nvar tracer = otel.Tracer(\"internal/graph/check\")\n\nconst (\n\t// same values as run.DefaultConfig() (TODO break the import cycle, remove these hardcoded values and import those constants here)\n\tdefaultResolveNodeBreadthLimit    = 25\n\tdefaultMaxConcurrentReadsForCheck = math.MaxUint32\n)\n\ntype ResolveCheckRequest struct {\n\tStoreID              string\n\tAuthorizationModelID string\n\tTupleKey             *openfgav1.TupleKey\n\tContextualTuples     []*openfgav1.TupleKey\n\tResolutionMetadata   *ResolutionMetadata\n}\n\ntype ResolveCheckResponse struct {\n\tAllowed            bool\n\tResolutionMetadata *ResolutionMetadata\n}\n\nfunc (r *ResolveCheckResponse) GetAllowed() bool {\n\tif r != nil {\n\t\treturn r.Allowed\n\t}\n\n\treturn false\n}\n\nfunc (r *ResolveCheckResponse) GetResolutionMetadata() *ResolutionMetadata {\n\tif r != nil {\n\t\treturn r.ResolutionMetadata\n\t}\n\n\treturn nil\n}\n\nfunc (r *ResolveCheckRequest) GetStoreID() string {\n\tif r != nil {\n\t\treturn r.StoreID\n\t}\n\n\treturn \"\"\n}\n\nfunc (r *ResolveCheckRequest) GetAuthorizationModelID() string {\n\tif r != nil {\n\t\treturn r.AuthorizationModelID\n\t}\n\n\treturn \"\"\n}\n\nfunc (r *ResolveCheckRequest) GetTupleKey() *openfgav1.TupleKey {\n\tif r != nil {\n\t\treturn r.TupleKey\n\t}\n\n\treturn nil\n}\n\nfunc (r *ResolveCheckRequest) GetContextualTuples() []*openfgav1.TupleKey {\n\tif r != nil {\n\t\treturn r.ContextualTuples\n\t}\n\n\treturn nil\n}\n\nfunc (r *ResolveCheckRequest) GetResolutionMetadata() *ResolutionMetadata {\n\tif r != nil {\n\t\treturn r.ResolutionMetadata\n\t}\n\n\treturn nil\n}\n\ntype setOperatorType int\n\nconst (\n\tunionSetOperator setOperatorType = iota\n\tintersectionSetOperator\n\texclusionSetOperator\n)\n\ntype checkOutcome struct {\n\tresp *ResolveCheckResponse\n\terr  error\n}\n\ntype LocalChecker struct {\n\tds                 storage.RelationshipTupleReader\n\tdelegate           CheckResolver\n\tconcurrencyLimit   uint32\n\tmaxConcurrentReads uint32\n}\n\ntype LocalCheckerOption func(d *LocalChecker)\n\n// WithResolveNodeBreadthLimit see server.WithResolveNodeBreadthLimit\nfunc WithResolveNodeBreadthLimit(limit uint32) LocalCheckerOption {\n\treturn func(d *LocalChecker) {\n\t\td.concurrencyLimit = limit\n\t}\n}\n\n// WithMaxConcurrentReads see server.WithMaxConcurrentReadsForCheck\nfunc WithMaxConcurrentReads(limit uint32) LocalCheckerOption {\n\treturn func(d *LocalChecker) {\n\t\td.maxConcurrentReads = limit\n\t}\n}\n\nfunc WithDelegate(delegate CheckResolver) LocalCheckerOption {\n\treturn func(d *LocalChecker) {\n\t\td.delegate = delegate\n\t}\n}\n\nfunc WithCachedResolver(opts ...CachedCheckResolverOpt) LocalCheckerOption {\n\treturn func(d *LocalChecker) {\n\t\tcachedCheckResolver := NewCachedCheckResolver(\n\t\t\td,\n\t\t\topts...,\n\t\t)\n\t\td.SetDelegate(cachedCheckResolver)\n\t}\n}\n\n// NewLocalChecker constructs a LocalChecker that can be used to evaluate a Check\n// request locally.\nfunc NewLocalChecker(ds storage.RelationshipTupleReader, opts ...LocalCheckerOption) CheckResolver {\n\tchecker := &LocalChecker{\n\t\tds:                 ds,\n\t\tconcurrencyLimit:   defaultResolveNodeBreadthLimit,\n\t\tmaxConcurrentReads: defaultMaxConcurrentReadsForCheck,\n\t}\n\tchecker.delegate = checker // by default, a LocalChecker delegates/dispatchs subproblems to itself (e.g. local dispatch) unless otherwise configured.\n\n\tfor _, opt := range opts {\n\t\topt(checker)\n\t}\n\n\tchecker.ds = storagewrappers.NewBoundedConcurrencyTupleReader(checker.ds, checker.maxConcurrentReads)\n\n\t// Depending on whether cached check resolver is used,\n\t// we either return the newly created checker or the delegate (i.e., cached check resolver).\n\treturn checker.delegate\n}\n\n// CheckHandlerFunc defines a function that evaluates a CheckResponse or returns an error\n// otherwise.\ntype CheckHandlerFunc func(ctx context.Context) (*ResolveCheckResponse, error)\n\n// CheckFuncReducer defines a function that combines or reduces one or more CheckHandlerFunc into\n// a single CheckResponse with a maximum limit on the number of concurrent evaluations that can be\n// in flight at any given time.\ntype CheckFuncReducer func(ctx context.Context, concurrencyLimit uint32, handlers ...CheckHandlerFunc) (*ResolveCheckResponse, error)\n\n// resolver concurrently resolves one or more CheckHandlerFunc and yields the results on the provided resultChan.\n// Callers of the 'resolver' function should be sure to invoke the callback returned from this function to ensure\n// every concurrent check is evaluated. The concurrencyLimit can be set to provide a maximum number of concurrent\n// evaluations in flight at any point.\nfunc resolver(ctx context.Context, concurrencyLimit uint32, resultChan chan<- checkOutcome, handlers ...CheckHandlerFunc) func() {\n\tlimiter := make(chan struct{}, concurrencyLimit)\n\n\tvar wg sync.WaitGroup\n\n\tchecker := func(fn CheckHandlerFunc) {\n\t\tdefer wg.Done()\n\n\t\tresolved := make(chan checkOutcome, 1)\n\n\t\tgo func() {\n\t\t\tresp, err := fn(ctx)\n\t\t\tresolved <- checkOutcome{resp, err}\n\t\t\t<-limiter\n\t\t}()\n\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tcase res := <-resolved:\n\t\t\tresultChan <- res\n\t\t}\n\t}\n\n\twg.Add(1)\n\tgo func() {\n\touter:\n\t\tfor _, handler := range handlers {\n\t\t\tfn := handler // capture loop var\n\n\t\t\tselect {\n\t\t\tcase limiter <- struct{}{}:\n\t\t\t\twg.Add(1)\n\t\t\t\tgo checker(fn)\n\t\t\tcase <-ctx.Done():\n\t\t\t\tbreak outer\n\t\t\t}\n\t\t}\n\n\t\twg.Done()\n\t}()\n\n\treturn func() {\n\t\twg.Wait()\n\t\tclose(limiter)\n\t}\n}\n\n// union implements a CheckFuncReducer that requires any of the provided CheckHandlerFunc to resolve\n// to an allowed outcome. The first allowed outcome causes premature termination of the reducer.\nfunc union(ctx context.Context, concurrencyLimit uint32, handlers ...CheckHandlerFunc) (*ResolveCheckResponse, error) {\n\n\tctx, cancel := context.WithCancel(ctx)\n\tresultChan := make(chan checkOutcome, len(handlers))\n\n\tdrain := resolver(ctx, concurrencyLimit, resultChan, handlers...)\n\n\tdefer func() {\n\t\tcancel()\n\t\tdrain()\n\t\tclose(resultChan)\n\t}()\n\n\tvar dbReads uint32\n\tvar err error\n\tfor i := 0; i < len(handlers); i++ {\n\t\tselect {\n\t\tcase result := <-resultChan:\n\t\t\tif result.err != nil {\n\t\t\t\terr = result.err\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdbReads += result.resp.GetResolutionMetadata().DatastoreQueryCount\n\n\t\t\tif result.resp.GetAllowed() {\n\t\t\t\tresult.resp.GetResolutionMetadata().DatastoreQueryCount = dbReads\n\t\t\t\treturn result.resp, nil\n\t\t\t}\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ctx.Err()\n\t\t}\n\t}\n\n\treturn &ResolveCheckResponse{\n\t\tAllowed: false,\n\t\tResolutionMetadata: &ResolutionMetadata{\n\t\t\tDatastoreQueryCount: dbReads,\n\t\t},\n\t}, err\n}\n\n// intersection implements a CheckFuncReducer that requires all of the provided CheckHandlerFunc to resolve\n// to an allowed outcome. The first falsey or erroneous outcome causes premature termination of the reducer.\nfunc intersection(ctx context.Context, concurrencyLimit uint32, handlers ...CheckHandlerFunc) (*ResolveCheckResponse, error) {\n\n\tctx, cancel := context.WithCancel(ctx)\n\tresultChan := make(chan checkOutcome, len(handlers))\n\n\tdrain := resolver(ctx, concurrencyLimit, resultChan, handlers...)\n\n\tdefer func() {\n\t\tcancel()\n\t\tdrain()\n\t\tclose(resultChan)\n\t}()\n\n\tvar dbReads uint32\n\tvar err error\n\tfor i := 0; i < len(handlers); i++ {\n\t\tselect {\n\t\tcase result := <-resultChan:\n\t\t\tif result.err != nil {\n\t\t\t\terr = result.err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tdbReads += result.resp.GetResolutionMetadata().DatastoreQueryCount\n\t\t\tif !result.resp.GetAllowed() {\n\t\t\t\tresult.resp.GetResolutionMetadata().DatastoreQueryCount = dbReads\n\t\t\t\treturn result.resp, nil\n\t\t\t}\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ctx.Err()\n\t\t}\n\t}\n\n\tif err != nil {\n\t\treturn &ResolveCheckResponse{\n\t\t\tAllowed: false,\n\t\t\tResolutionMetadata: &ResolutionMetadata{\n\t\t\t\tDatastoreQueryCount: dbReads,\n\t\t\t},\n\t\t}, err\n\t}\n\n\treturn &ResolveCheckResponse{\n\t\tAllowed: true,\n\t\tResolutionMetadata: &ResolutionMetadata{\n\t\t\tDatastoreQueryCount: dbReads,\n\t\t},\n\t}, nil\n}\n\n// exclusion implements a CheckFuncReducer that requires a 'base' CheckHandlerFunc to resolve to an allowed\n// outcome and a 'sub' CheckHandlerFunc to resolve to a falsey outcome. The base and sub computations are\n// handled concurrently relative to one another.\nfunc exclusion(ctx context.Context, concurrencyLimit uint32, handlers ...CheckHandlerFunc) (*ResolveCheckResponse, error) {\n\n\tif len(handlers) != 2 {\n\t\tpanic(fmt.Sprintf(\"expected two rewrite operands for exclusion operator, but got '%d'\", len(handlers)))\n\t}\n\n\tlimiter := make(chan struct{}, concurrencyLimit)\n\n\tctx, cancel := context.WithCancel(ctx)\n\tbaseChan := make(chan checkOutcome, 1)\n\tsubChan := make(chan checkOutcome, 1)\n\n\tvar wg sync.WaitGroup\n\n\tdefer func() {\n\t\tcancel()\n\t\twg.Wait()\n\t\tclose(baseChan)\n\t\tclose(subChan)\n\t}()\n\n\tbaseHandler := handlers[0]\n\tsubHandler := handlers[1]\n\n\tlimiter <- struct{}{}\n\twg.Add(1)\n\tgo func() {\n\t\tresp, err := baseHandler(ctx)\n\t\tbaseChan <- checkOutcome{resp, err}\n\t\t<-limiter\n\t\twg.Done()\n\t}()\n\n\tlimiter <- struct{}{}\n\twg.Add(1)\n\tgo func() {\n\t\tresp, err := subHandler(ctx)\n\t\tsubChan <- checkOutcome{resp, err}\n\t\t<-limiter\n\t\twg.Done()\n\t}()\n\n\tresponse := &ResolveCheckResponse{\n\t\tAllowed: false,\n\t\tResolutionMetadata: &ResolutionMetadata{\n\t\t\tDatastoreQueryCount: 0,\n\t\t},\n\t}\n\tvar dbReads uint32\n\tfor i := 0; i < len(handlers); i++ {\n\t\tselect {\n\t\tcase baseResult := <-baseChan:\n\t\t\tif baseResult.err != nil {\n\t\t\t\treturn response, baseResult.err\n\t\t\t}\n\n\t\t\tdbReads += baseResult.resp.GetResolutionMetadata().DatastoreQueryCount\n\n\t\t\tif !baseResult.resp.GetAllowed() {\n\t\t\t\tresponse.GetResolutionMetadata().DatastoreQueryCount = dbReads\n\t\t\t\treturn response, nil\n\t\t\t}\n\n\t\tcase subResult := <-subChan:\n\t\t\tif subResult.err != nil {\n\t\t\t\treturn response, subResult.err\n\t\t\t}\n\n\t\t\tdbReads += subResult.resp.GetResolutionMetadata().DatastoreQueryCount\n\n\t\t\tif subResult.resp.GetAllowed() {\n\t\t\t\tresponse.GetResolutionMetadata().DatastoreQueryCount = dbReads\n\t\t\t\treturn response, nil\n\t\t\t}\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ctx.Err()\n\t\t}\n\t}\n\n\treturn &ResolveCheckResponse{\n\t\tAllowed: true,\n\t\tResolutionMetadata: &ResolutionMetadata{\n\t\t\tDatastoreQueryCount: dbReads,\n\t\t},\n\t}, nil\n}\n\n// Close is a noop\nfunc (c *LocalChecker) Close() {\n}\n\nfunc (c *LocalChecker) SetDelegate(delegate CheckResolver) {\n\tc.delegate = delegate\n}\n\n// dispatch dispatches the provided Check request to the CheckResolver this LocalChecker\n// was constructed with.\nfunc (c *LocalChecker) dispatch(ctx context.Context, req *ResolveCheckRequest) CheckHandlerFunc {\n\treturn func(ctx context.Context) (*ResolveCheckResponse, error) {\n\t\treturn c.delegate.ResolveCheck(ctx, req)\n\t}\n}\n\n// ResolveCheck resolves a node out of a tree of evaluations. If the depth of the tree has gotten too large,\n// evaluation is aborted and an error is returned. The depth is NOT increased on computed usersets.\nfunc (c *LocalChecker) ResolveCheck(\n\tctx context.Context,\n\treq *ResolveCheckRequest,\n) (*ResolveCheckResponse, error) {\n\tctx, span := tracer.Start(ctx, \"ResolveCheck\")\n\tdefer span.End()\n\n\tspan.SetAttributes(attribute.String(\"tuple_key\", req.GetTupleKey().String()))\n\n\tif req.GetResolutionMetadata().Depth == 0 {\n\t\treturn nil, ErrResolutionDepthExceeded\n\t}\n\n\ttypesys, ok := typesystem.TypesystemFromContext(ctx)\n\tif !ok {\n\t\tpanic(\"typesystem missing in context\")\n\t}\n\n\tobject := req.GetTupleKey().GetObject()\n\trelation := req.GetTupleKey().GetRelation()\n\n\tobjectType, _ := tuple.SplitObject(object)\n\trel, err := typesys.GetRelation(objectType, relation)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"relation '%s' undefined for object type '%s'\", relation, objectType)\n\t}\n\n\tresp, err := union(ctx, c.concurrencyLimit, c.checkRewrite(ctx, req, rel.GetRewrite()))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn resp, nil\n}\n\n// checkDirect composes two CheckHandlerFunc which evaluate direct relationships with the provided\n// 'object#relation'. The first handler looks up direct matches on the provided 'object#relation@user',\n// while the second handler looks up relationships between the target 'object#relation' and any usersets\n// related to it.\nfunc (c *LocalChecker) checkDirect(parentctx context.Context, req *ResolveCheckRequest) CheckHandlerFunc {\n\n\treturn func(ctx context.Context) (*ResolveCheckResponse, error) {\n\t\ttypesys, ok := typesystem.TypesystemFromContext(parentctx) // note: use of 'parentctx' not 'ctx' - this is important\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(\"typesystem missing in context\")\n\t\t}\n\n\t\tctx, span := tracer.Start(ctx, \"checkDirect\")\n\t\tdefer span.End()\n\n\t\tstoreID := req.GetStoreID()\n\t\ttk := req.GetTupleKey()\n\t\tobjectType := tuple.GetType(tk.GetObject())\n\t\trelation := tk.GetRelation()\n\n\t\t// directlyRelatedUsersetTypes could be \"user:*\" or \"group#member\"\n\t\tdirectlyRelatedUsersetTypes, _ := typesys.DirectlyRelatedUsersets(objectType, relation)\n\n\t\tfn1 := func(ctx context.Context) (*ResolveCheckResponse, error) {\n\t\t\tctx, span := tracer.Start(ctx, \"checkDirectUserTuple\", trace.WithAttributes(attribute.String(\"tuple_key\", tk.String())))\n\t\t\tdefer span.End()\n\n\t\t\tresponse := &ResolveCheckResponse{\n\t\t\t\tAllowed: false,\n\t\t\t\tResolutionMetadata: &ResolutionMetadata{\n\t\t\t\t\tDatastoreQueryCount: req.GetResolutionMetadata().DatastoreQueryCount + 1,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tt, err := c.ds.ReadUserTuple(ctx, storeID, tk)\n\t\t\tif err != nil {\n\t\t\t\tif errors.Is(err, storage.ErrNotFound) {\n\t\t\t\t\treturn response, nil\n\t\t\t\t}\n\n\t\t\t\treturn response, err\n\t\t\t}\n\n\t\t\t// filter out invalid tuples yielded by the database query\n\t\t\terr = validation.ValidateTuple(typesys, tk)\n\n\t\t\tif t != nil && err == nil {\n\t\t\t\tspan.SetAttributes(attribute.Bool(\"allowed\", true))\n\t\t\t\tresponse.Allowed = true\n\t\t\t\treturn response, nil\n\t\t\t}\n\t\t\treturn response, nil\n\t\t}\n\n\t\tfn2 := func(ctx context.Context) (*ResolveCheckResponse, error) {\n\t\t\tctx, span := tracer.Start(ctx, \"checkDirectUsersetTuples\", trace.WithAttributes(attribute.String(\"userset\", tuple.ToObjectRelationString(tk.Object, tk.Relation))))\n\t\t\tdefer span.End()\n\n\t\t\tresponse := &ResolveCheckResponse{\n\t\t\t\tAllowed: false,\n\t\t\t\tResolutionMetadata: &ResolutionMetadata{\n\t\t\t\t\tDatastoreQueryCount: req.GetResolutionMetadata().DatastoreQueryCount + 1,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\titer, err := c.ds.ReadUsersetTuples(ctx, storeID, storage.ReadUsersetTuplesFilter{\n\t\t\t\tObject:                      tk.Object,\n\t\t\t\tRelation:                    tk.Relation,\n\t\t\t\tAllowedUserTypeRestrictions: directlyRelatedUsersetTypes,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn response, err\n\t\t\t}\n\t\t\tdefer iter.Stop()\n\n\t\t\t// filter out invalid tuples yielded by the database iterator\n\t\t\tfilteredIter := storage.NewFilteredTupleKeyIterator(\n\t\t\t\tstorage.NewTupleKeyIteratorFromTupleIterator(iter),\n\t\t\t\tvalidation.FilterInvalidTuples(typesys),\n\t\t\t)\n\t\t\tdefer filteredIter.Stop()\n\n\t\t\tvar handlers []CheckHandlerFunc\n\t\t\tfor {\n\t\t\t\tt, err := filteredIter.Next()\n\t\t\t\tif err != nil {\n\t\t\t\t\tif errors.Is(err, storage.ErrIteratorDone) {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\n\t\t\t\t\treturn response, err\n\t\t\t\t}\n\n\t\t\t\tusersetObject, usersetRelation := tuple.SplitObjectRelation(t.GetUser())\n\n\t\t\t\t// for 1.0 models, if the user is '*' then we're done searching\n\t\t\t\tif usersetObject == tuple.Wildcard && typesys.GetSchemaVersion() == typesystem.SchemaVersion1_0 {\n\t\t\t\t\tspan.SetAttributes(attribute.Bool(\"allowed\", true))\n\t\t\t\t\tresponse.Allowed = true\n\t\t\t\t\treturn response, nil\n\t\t\t\t}\n\n\t\t\t\t// for 1.1 models, if the user value is a typed wildcard and the type of the wildcard\n\t\t\t\t// matches the target user objectType, then we're done searching\n\t\t\t\tif tuple.IsTypedWildcard(usersetObject) && typesys.GetSchemaVersion() == typesystem.SchemaVersion1_1 {\n\n\t\t\t\t\twildcardType := tuple.GetType(usersetObject)\n\n\t\t\t\t\tif tuple.GetType(tk.GetUser()) == wildcardType {\n\t\t\t\t\t\tspan.SetAttributes(attribute.Bool(\"allowed\", true))\n\t\t\t\t\t\tresponse.Allowed = true\n\t\t\t\t\t\treturn response, nil\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tif usersetRelation != \"\" {\n\t\t\t\t\thandlers = append(handlers, c.dispatch(\n\t\t\t\t\t\tctx,\n\t\t\t\t\t\t&ResolveCheckRequest{\n\t\t\t\t\t\t\tStoreID:              storeID,\n\t\t\t\t\t\t\tAuthorizationModelID: req.GetAuthorizationModelID(),\n\t\t\t\t\t\t\tTupleKey:             tuple.NewTupleKey(usersetObject, usersetRelation, tk.GetUser()),\n\t\t\t\t\t\t\tResolutionMetadata: &ResolutionMetadata{\n\t\t\t\t\t\t\t\tDepth:               req.GetResolutionMetadata().Depth - 1,\n\t\t\t\t\t\t\t\tDatastoreQueryCount: response.GetResolutionMetadata().DatastoreQueryCount,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}))\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif len(handlers) == 0 {\n\t\t\t\treturn response, nil\n\t\t\t}\n\n\t\t\treturn union(ctx, c.concurrencyLimit, handlers...)\n\t\t}\n\n\t\tvar checkFuncs []CheckHandlerFunc\n\n\t\tshouldCheckDirectTuple, _ := typesys.IsDirectlyRelated(\n\t\t\ttypesystem.DirectRelationReference(objectType, relation),                                         //target\n\t\t\ttypesystem.DirectRelationReference(tuple.GetType(tk.GetUser()), tuple.GetRelation(tk.GetUser())), //source\n\t\t)\n\n\t\tif shouldCheckDirectTuple {\n\t\t\tcheckFuncs = []CheckHandlerFunc{fn1}\n\t\t}\n\n\t\tif len(directlyRelatedUsersetTypes) > 0 {\n\t\t\tcheckFuncs = append(checkFuncs, fn2)\n\n\t\t}\n\n\t\treturn union(ctx, c.concurrencyLimit, checkFuncs...)\n\t}\n}\n\n// checkComputedUserset evaluates the Check request with the rewritten relation (e.g. the computed userset relation).\nfunc (c *LocalChecker) checkComputedUserset(parentctx context.Context, req *ResolveCheckRequest, rewrite *openfgav1.Userset_ComputedUserset) CheckHandlerFunc {\n\treturn func(ctx context.Context) (*ResolveCheckResponse, error) {\n\t\tctx, span := tracer.Start(ctx, \"checkComputedUserset\")\n\t\tdefer span.End()\n\n\t\treturn c.dispatch(\n\t\t\tctx,\n\t\t\t&ResolveCheckRequest{\n\t\t\t\tStoreID:              req.GetStoreID(),\n\t\t\t\tAuthorizationModelID: req.GetAuthorizationModelID(),\n\t\t\t\tTupleKey: tuple.NewTupleKey(\n\t\t\t\t\treq.TupleKey.GetObject(),\n\t\t\t\t\trewrite.ComputedUserset.GetRelation(),\n\t\t\t\t\treq.TupleKey.GetUser(),\n\t\t\t\t),\n\t\t\t\tResolutionMetadata: &ResolutionMetadata{\n\t\t\t\t\tDepth:               req.GetResolutionMetadata().Depth - 1,\n\t\t\t\t\tDatastoreQueryCount: req.GetResolutionMetadata().DatastoreQueryCount,\n\t\t\t\t},\n\t\t\t})(ctx)\n\t}\n}\n\n// checkTTU looks up all tuples of the target tupleset relation on the provided object and for each one\n// of them evaluates the computed userset of the TTU rewrite rule for them.\nfunc (c *LocalChecker) checkTTU(parentctx context.Context, req *ResolveCheckRequest, rewrite *openfgav1.Userset) CheckHandlerFunc {\n\n\treturn func(ctx context.Context) (*ResolveCheckResponse, error) {\n\t\ttypesys, ok := typesystem.TypesystemFromContext(parentctx) // note: use of 'parentctx' not 'ctx' - this is important\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(\"typesystem missing in context\")\n\t\t}\n\n\t\tctx, span := tracer.Start(ctx, \"checkTTU\")\n\t\tdefer span.End()\n\n\t\tctx = typesystem.ContextWithTypesystem(ctx, typesys)\n\n\t\ttuplesetRelation := rewrite.GetTupleToUserset().GetTupleset().GetRelation()\n\t\tcomputedRelation := rewrite.GetTupleToUserset().GetComputedUserset().GetRelation()\n\n\t\ttk := req.GetTupleKey()\n\t\tobject := tk.GetObject()\n\n\t\tspan.SetAttributes(attribute.String(\"tupleset_relation\", fmt.Sprintf(\"%s#%s\", tuple.GetType(object), tuplesetRelation)))\n\t\tspan.SetAttributes(attribute.String(\"computed_relation\", computedRelation))\n\n\t\tresponse := &ResolveCheckResponse{\n\t\t\tAllowed: false,\n\t\t\tResolutionMetadata: &ResolutionMetadata{\n\t\t\t\tDatastoreQueryCount: req.GetResolutionMetadata().DatastoreQueryCount + 1,\n\t\t\t},\n\t\t}\n\t\titer, err := c.ds.Read(\n\t\t\tctx,\n\t\t\treq.GetStoreID(),\n\t\t\ttuple.NewTupleKey(object, tuplesetRelation, \"\"),\n\t\t)\n\t\tif err != nil {\n\t\t\treturn response, err\n\t\t}\n\t\tdefer iter.Stop()\n\n\t\t// filter out invalid tuples yielded by the database iterator\n\t\tfilteredIter := storage.NewFilteredTupleKeyIterator(\n\t\t\tstorage.NewTupleKeyIteratorFromTupleIterator(iter),\n\t\t\tvalidation.FilterInvalidTuples(typesys),\n\t\t)\n\t\tdefer filteredIter.Stop()\n\n\t\tvar handlers []CheckHandlerFunc\n\t\tfor {\n\t\t\tt, err := filteredIter.Next()\n\t\t\tif err != nil {\n\t\t\t\tif err == storage.ErrIteratorDone {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\treturn response, err\n\t\t\t}\n\n\t\t\tuserObj, _ := tuple.SplitObjectRelation(t.GetUser())\n\n\t\t\ttupleKey := &openfgav1.TupleKey{\n\t\t\t\tObject:   userObj,\n\t\t\t\tRelation: computedRelation,\n\t\t\t\tUser:     tk.GetUser(),\n\t\t\t}\n\n\t\t\tif _, err := typesys.GetRelation(tuple.GetType(userObj), computedRelation); err != nil {\n\t\t\t\tif errors.Is(err, typesystem.ErrRelationUndefined) {\n\t\t\t\t\tcontinue // skip computed relations on tupleset relationships if they are undefined\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thandlers = append(handlers, c.dispatch(\n\t\t\t\tctx,\n\t\t\t\t&ResolveCheckRequest{\n\t\t\t\t\tStoreID:              req.GetStoreID(),\n\t\t\t\t\tAuthorizationModelID: req.GetAuthorizationModelID(),\n\t\t\t\t\tTupleKey:             tupleKey,\n\t\t\t\t\tResolutionMetadata: &ResolutionMetadata{\n\t\t\t\t\t\tDepth:               req.GetResolutionMetadata().Depth - 1,\n\t\t\t\t\t\tDatastoreQueryCount: req.GetResolutionMetadata().DatastoreQueryCount, // add TTU read below\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t}\n\n\t\tif len(handlers) == 0 {\n\t\t\treturn response, nil\n\t\t}\n\n\t\tunionResponse, err := union(ctx, c.concurrencyLimit, handlers...)\n\n\t\tif err == nil {\n\t\t\t// if we had 3 dispatched requests, and the final result is \"allowed = false\",\n\t\t\t// we want final reads to be (N1 + N2 + N3 + 1) and not (N1 + 1) + (N2 + 1) + (N3 + 1)\n\t\t\t// if final result is \"allowed = true\", we want final reads to be N1 + 1\n\t\t\tunionResponse.GetResolutionMetadata().DatastoreQueryCount++\n\t\t}\n\n\t\treturn unionResponse, err\n\n\t}\n}\n\nfunc (c *LocalChecker) checkSetOperation(\n\tctx context.Context,\n\treq *ResolveCheckRequest,\n\tsetOpType setOperatorType,\n\treducer CheckFuncReducer,\n\tchildren ...*openfgav1.Userset,\n) CheckHandlerFunc {\n\n\tvar handlers []CheckHandlerFunc\n\n\tvar reducerKey string\n\tswitch setOpType {\n\tcase unionSetOperator, intersectionSetOperator, exclusionSetOperator:\n\t\tif setOpType == unionSetOperator {\n\t\t\treducerKey = \"union\"\n\t\t}\n\n\t\tif setOpType == intersectionSetOperator {\n\t\t\treducerKey = \"intersection\"\n\t\t}\n\n\t\tif setOpType == exclusionSetOperator {\n\t\t\treducerKey = \"exclusion\"\n\t\t}\n\n\t\tfor _, child := range children {\n\t\t\thandlers = append(handlers, c.checkRewrite(ctx, req, child))\n\t\t}\n\tdefault:\n\t\tpanic(\"unexpected set operator type encountered\")\n\t}\n\n\treturn func(ctx context.Context) (*ResolveCheckResponse, error) {\n\t\tctx, span := tracer.Start(ctx, reducerKey)\n\t\tdefer span.End()\n\n\t\treturn reducer(ctx, c.concurrencyLimit, handlers...)\n\t}\n}\n\nfunc (c *LocalChecker) checkRewrite(\n\tctx context.Context,\n\treq *ResolveCheckRequest,\n\trewrite *openfgav1.Userset,\n) CheckHandlerFunc {\n\n\tswitch rw := rewrite.Userset.(type) {\n\tcase *openfgav1.Userset_This:\n\t\treturn c.checkDirect(ctx, req)\n\tcase *openfgav1.Userset_ComputedUserset:\n\t\treturn c.checkComputedUserset(ctx, req, rw)\n\tcase *openfgav1.Userset_TupleToUserset:\n\t\treturn c.checkTTU(ctx, req, rewrite)\n\tcase *openfgav1.Userset_Union:\n\t\treturn c.checkSetOperation(ctx, req, unionSetOperator, union, rw.Union.GetChild()...)\n\tcase *openfgav1.Userset_Intersection:\n\t\treturn c.checkSetOperation(ctx, req, intersectionSetOperator, intersection, rw.Intersection.GetChild()...)\n\tcase *openfgav1.Userset_Difference:\n\t\treturn c.checkSetOperation(ctx, req, exclusionSetOperator, exclusion, rw.Difference.GetBase(), rw.Difference.GetSubtract())\n\tdefault:\n\t\tpanic(\"unexpected userset rewrite encountered\")\n\t}\n}\n", "package graph\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"testing\"\n\n\tparser \"github.com/craigpastro/openfga-dsl-parser/v2\"\n\t\"github.com/oklog/ulid/v2\"\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\t\"github.com/openfga/openfga/pkg/storage/memory\"\n\t\"github.com/openfga/openfga/pkg/storage/storagewrappers\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestResolveCheckDeterministic(t *testing.T) {\n\n\tds := memory.New()\n\n\tstoreID := ulid.Make().String()\n\n\terr := ds.Write(context.Background(), storeID, nil, []*openfgav1.TupleKey{\n\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\ttuple.NewTupleKey(\"document:1\", \"editor\", \"group:other1#member\"),\n\t\ttuple.NewTupleKey(\"document:2\", \"editor\", \"group:eng#member\"),\n\t\ttuple.NewTupleKey(\"document:2\", \"allowed\", \"user:jon\"),\n\t\ttuple.NewTupleKey(\"document:2\", \"allowed\", \"user:x\"),\n\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"group:fga#member\"),\n\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"user:jon\"),\n\t\ttuple.NewTupleKey(\"group:other1\", \"member\", \"group:other2#member\"),\n\t})\n\trequire.NoError(t, err)\n\n\tchecker := NewLocalChecker(ds)\n\n\ttypedefs := parser.MustParse(`\n\ttype user\n\n\ttype group\n\t  relations\n\t    define member: [user, group#member] as self\n\n\ttype document\n\t  relations\n\t    define allowed: [user] as self\n\t    define viewer: [group#member] as self or editor\n\t    define editor: [group#member] as self and allowed\n\t    \n\t`)\n\n\tctx := typesystem.ContextWithTypesystem(context.Background(), typesystem.New(\n\t\t&openfgav1.AuthorizationModel{\n\t\t\tId:              ulid.Make().String(),\n\t\t\tTypeDefinitions: typedefs,\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t},\n\t))\n\n\tresp, err := checker.ResolveCheck(ctx, &ResolveCheckRequest{\n\t\tStoreID:            storeID,\n\t\tTupleKey:           tuple.NewTupleKey(\"document:1\", \"viewer\", \"user:jon\"),\n\t\tResolutionMetadata: &ResolutionMetadata{Depth: 2},\n\t})\n\trequire.NoError(t, err)\n\trequire.True(t, resp.Allowed)\n\n\tresp, err = checker.ResolveCheck(ctx, &ResolveCheckRequest{\n\t\tStoreID:            storeID,\n\t\tTupleKey:           tuple.NewTupleKey(\"document:2\", \"editor\", \"user:x\"),\n\t\tResolutionMetadata: &ResolutionMetadata{Depth: 2},\n\t})\n\trequire.ErrorIs(t, err, ErrResolutionDepthExceeded)\n\trequire.Nil(t, resp)\n}\n\nfunc TestCheckWithOneConcurrentGoroutineCausesNoDeadlock(t *testing.T) {\n\tconst concurrencyLimit = 1\n\tds := memory.New()\n\tdefer ds.Close()\n\n\tstoreID := ulid.Make().String()\n\n\terr := ds.Write(context.Background(), storeID, nil, []*openfgav1.TupleKey{\n\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:1#member\"),\n\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:2#member\"),\n\t\ttuple.NewTupleKey(\"group:1\", \"member\", \"group:1a#member\"),\n\t\ttuple.NewTupleKey(\"group:1\", \"member\", \"group:1b#member\"),\n\t\ttuple.NewTupleKey(\"group:2\", \"member\", \"group:2a#member\"),\n\t\ttuple.NewTupleKey(\"group:2\", \"member\", \"group:2b#member\"),\n\t\ttuple.NewTupleKey(\"group:2b\", \"member\", \"user:jon\"),\n\t})\n\trequire.NoError(t, err)\n\n\tchecker := NewLocalChecker(ds, WithResolveNodeBreadthLimit(concurrencyLimit))\n\n\ttypedefs := parser.MustParse(`\n\ttype user\n\ttype group\n\t  relations\n\t\tdefine member: [user, group#member] as self\n\ttype document\n\t  relations\n\t\tdefine viewer: [group#member] as self\n\t`)\n\n\tctx := typesystem.ContextWithTypesystem(context.Background(), typesystem.New(\n\t\t&openfgav1.AuthorizationModel{\n\t\t\tId:              ulid.Make().String(),\n\t\t\tTypeDefinitions: typedefs,\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t},\n\t))\n\n\tresp, err := checker.ResolveCheck(ctx, &ResolveCheckRequest{\n\t\tStoreID:            storeID,\n\t\tTupleKey:           tuple.NewTupleKey(\"document:1\", \"viewer\", \"user:jon\"),\n\t\tResolutionMetadata: &ResolutionMetadata{Depth: 25},\n\t})\n\trequire.NoError(t, err)\n\trequire.True(t, resp.Allowed)\n}\n\nfunc TestCheckDatastoreQueryCount(t *testing.T) {\n\tds := memory.New()\n\tdefer ds.Close()\n\n\tstoreID := ulid.Make().String()\n\n\terr := ds.Write(context.Background(), storeID, nil, []*openfgav1.TupleKey{\n\t\ttuple.NewTupleKey(\"document:x\", \"a\", \"user:jon\"),\n\t\ttuple.NewTupleKey(\"document:x\", \"a\", \"user:maria\"),\n\t\ttuple.NewTupleKey(\"document:x\", \"b\", \"user:maria\"),\n\t\ttuple.NewTupleKey(\"document:x\", \"parent\", \"org:fga\"),\n\t\ttuple.NewTupleKey(\"org:fga\", \"member\", \"user:maria\"),\n\t})\n\trequire.NoError(t, err)\n\n\ttypedefs := parser.MustParse(`\n\ttype user\n\n\ttype org\n      relations\n\t\tdefine member: [user] as self\n\n\ttype document\n\t  relations\n\t\tdefine a: [user] as self\n\t\tdefine b: [user] as self\n\t\tdefine union as a or b\n\t\tdefine union_rewrite as union\n\t\tdefine intersection as a and b\n\t\tdefine difference as a but not b\n\t\tdefine ttu as member from parent\n        define union_and_ttu as union and ttu\n\t\tdefine union_or_ttu as union or ttu or union_rewrite\n\t\tdefine intersection_of_ttus as union_or_ttu and union_and_ttu\n\t\tdefine parent: [org] as self\n\t`)\n\n\tctx := typesystem.ContextWithTypesystem(context.Background(), typesystem.New(\n\t\t&openfgav1.AuthorizationModel{\n\t\t\tId:              ulid.Make().String(),\n\t\t\tTypeDefinitions: typedefs,\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t},\n\t))\n\n\ttests := []struct {\n\t\tname             string\n\t\tcheck            *openfgav1.TupleKey\n\t\tcontextualTuples []*openfgav1.TupleKey\n\t\tallowed          bool\n\t\tminDBReads       uint32\n\t\tmaxDBReads       uint32\n\t}{\n\t\t{\n\t\t\tname:       \"no_direct_access\",\n\t\t\tcheck:      tuple.NewTupleKey(\"document:x\", \"a\", \"user:unknown\"),\n\t\t\tallowed:    false,\n\t\t\tminDBReads: 1, // both checkDirectUserTuple\n\t\t\tmaxDBReads: 1,\n\t\t},\n\t\t{\n\t\t\tname:       \"direct_access\",\n\t\t\tcheck:      tuple.NewTupleKey(\"document:x\", \"a\", \"user:maria\"),\n\t\t\tallowed:    true,\n\t\t\tminDBReads: 1, // checkDirectUserTuple needs to run\n\t\t\tmaxDBReads: 1,\n\t\t},\n\t\t{\n\t\t\tname:             \"direct_access_thanks_to_contextual_tuple\", // NOTE: this is counting the read from memory as a database read!\n\t\t\tcheck:            tuple.NewTupleKey(\"document:x\", \"a\", \"user:unknown\"),\n\t\t\tcontextualTuples: []*openfgav1.TupleKey{tuple.NewTupleKey(\"document:x\", \"a\", \"user:unknown\")},\n\t\t\tallowed:          true,\n\t\t\tminDBReads:       1, // checkDirectUserTuple needs to run\n\t\t\tmaxDBReads:       1,\n\t\t},\n\t\t{\n\t\t\tname:       \"union\",\n\t\t\tcheck:      tuple.NewTupleKey(\"document:x\", \"union\", \"user:maria\"),\n\t\t\tallowed:    true,\n\t\t\tminDBReads: 1, // checkDirectUserTuple needs to run\n\t\t\tmaxDBReads: 1,\n\t\t},\n\t\t{\n\t\t\tname:       \"union_no_access\",\n\t\t\tcheck:      tuple.NewTupleKey(\"document:x\", \"union\", \"user:unknown\"),\n\t\t\tallowed:    false,\n\t\t\tminDBReads: 2, // need to check all the conditions in the union\n\t\t\tmaxDBReads: 2,\n\t\t},\n\t\t{\n\t\t\tname:       \"intersection\",\n\t\t\tcheck:      tuple.NewTupleKey(\"document:x\", \"intersection\", \"user:maria\"),\n\t\t\tallowed:    true,\n\t\t\tminDBReads: 2, // need at minimum two direct tuple checks\n\t\t\tmaxDBReads: 2, // at most two tuple checks\n\t\t},\n\t\t{\n\t\t\tname:       \"intersection_no_access\",\n\t\t\tcheck:      tuple.NewTupleKey(\"document:x\", \"intersection\", \"user:unknown\"),\n\t\t\tallowed:    false,\n\t\t\tminDBReads: 1, // need at minimum one direct tuple checks (short circuit the ohter path)\n\t\t\tmaxDBReads: 1,\n\t\t},\n\t\t{\n\t\t\tname:       \"difference\",\n\t\t\tcheck:      tuple.NewTupleKey(\"document:x\", \"difference\", \"user:jon\"),\n\t\t\tallowed:    true,\n\t\t\tminDBReads: 2, // need at minimum two direct tuple checks\n\t\t\tmaxDBReads: 2,\n\t\t},\n\t\t{\n\t\t\tname:       \"difference_no_access\",\n\t\t\tcheck:      tuple.NewTupleKey(\"document:x\", \"difference\", \"user:maria\"),\n\t\t\tallowed:    false,\n\t\t\tminDBReads: 1, // if the \"but not\" condition returns quickly with \"false\", no need to evaluate the first branch\n\t\t\tmaxDBReads: 2, // at most two tuple checks\n\t\t},\n\t\t{\n\t\t\tname:       \"ttu\",\n\t\t\tcheck:      tuple.NewTupleKey(\"document:x\", \"ttu\", \"user:maria\"),\n\t\t\tallowed:    true,\n\t\t\tminDBReads: 2, // one read to find org:fga + one direct check if user:maria is a member of org:fga\n\t\t\tmaxDBReads: 3, // one read to find org:fga + (one direct check + userset check) if user:maria is a member of org:fga\n\t\t},\n\t\t{\n\t\t\tname:       \"ttu_no_access\",\n\t\t\tcheck:      tuple.NewTupleKey(\"document:x\", \"ttu\", \"user:jon\"),\n\t\t\tallowed:    false,\n\t\t\tminDBReads: 2, // one read to find org:fga + (one direct check) to see if user:jon is a member of org:fga\n\t\t\tmaxDBReads: 2,\n\t\t},\n\t\t// more complex scenarios\n\t\t{\n\t\t\tname:       \"union_and_ttu\",\n\t\t\tcheck:      tuple.NewTupleKey(\"document:x\", \"union_and_ttu\", \"user:maria\"),\n\t\t\tallowed:    true,\n\t\t\tminDBReads: 3, // union (1 read) + ttu (2 reads)\n\t\t\tmaxDBReads: 5, // union (2 reads) + ttu (3 reads)\n\t\t},\n\t\t{\n\t\t\tname:       \"union_and_ttu_no_access\",\n\t\t\tcheck:      tuple.NewTupleKey(\"document:x\", \"union_and_ttu\", \"user:unknown\"),\n\t\t\tallowed:    false,\n\t\t\tminDBReads: 2, // min(union (2 reads), ttu (4 reads))\n\t\t\tmaxDBReads: 4, // max(union (2 reads), ttu (4 reads))\n\t\t},\n\t\t{\n\t\t\tname:       \"union_or_ttu\",\n\t\t\tcheck:      tuple.NewTupleKey(\"document:x\", \"union_or_ttu\", \"user:maria\"),\n\t\t\tallowed:    true,\n\t\t\tminDBReads: 1, // min(union (1 read), ttu (2 reads))\n\t\t\tmaxDBReads: 3, // max(union (2 reads), ttu (3 reads))\n\t\t},\n\t\t{\n\t\t\tname:       \"union_or_ttu_no_access\",\n\t\t\tcheck:      tuple.NewTupleKey(\"document:x\", \"union_or_ttu\", \"user:unknown\"),\n\t\t\tallowed:    false,\n\t\t\tminDBReads: 6, // union (2 reads) + ttu (2 reads) + union rewrite (2 reads)\n\t\t\tmaxDBReads: 6,\n\t\t},\n\t\t{\n\t\t\tname:       \"intersection_of_ttus\", //union_or_ttu and union_and_ttu\n\t\t\tcheck:      tuple.NewTupleKey(\"document:x\", \"intersection_of_ttus\", \"user:maria\"),\n\t\t\tallowed:    true,\n\t\t\tminDBReads: 4, // union_or_ttu (1 read) + union_and_ttu (3 reads)\n\t\t\tmaxDBReads: 8, // union_or_ttu (3 reads) + union_and_ttu (5 reads)\n\t\t},\n\t}\n\n\t// run the test many times to exercise all the possible DBReads\n\tfor i := 1; i < 1000; i++ {\n\n\t\tt.Run(fmt.Sprintf(\"iteration_%v\", i), func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tfor _, test := range tests {\n\t\t\t\ttest := test\n\t\t\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t\t\tt.Parallel()\n\n\t\t\t\t\tchecker := NewLocalChecker(\n\t\t\t\t\t\t// TODO build this wrapper inside ResolveCheck so that we don't need to construct a new Checker per test\n\t\t\t\t\t\tstoragewrappers.NewCombinedTupleReader(ds, test.contextualTuples),\n\t\t\t\t\t\tWithMaxConcurrentReads(1))\n\n\t\t\t\t\tres, err := checker.ResolveCheck(ctx, &ResolveCheckRequest{\n\t\t\t\t\t\tStoreID:            storeID,\n\t\t\t\t\t\tTupleKey:           test.check,\n\t\t\t\t\t\tContextualTuples:   test.contextualTuples,\n\t\t\t\t\t\tResolutionMetadata: &ResolutionMetadata{Depth: 25},\n\t\t\t\t\t})\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\trequire.Equal(t, res.Allowed, test.allowed)\n\t\t\t\t\t// minDBReads <= dbReads <= maxDBReads\n\t\t\t\t\trequire.GreaterOrEqual(t, res.ResolutionMetadata.DatastoreQueryCount, test.minDBReads)\n\t\t\t\t\trequire.LessOrEqual(t, res.ResolutionMetadata.DatastoreQueryCount, test.maxDBReads)\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t}\n}\n", "package commands\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\t\"github.com/openfga/openfga/internal/graph\"\n\t\"github.com/openfga/openfga/internal/validation\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\t\"github.com/openfga/openfga/pkg/server/commands/reverseexpand\"\n\tserverErrors \"github.com/openfga/openfga/pkg/server/errors\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/storage/storagewrappers\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promauto\"\n)\n\nconst (\n\tstreamedBufferSize = 100\n\n\t// same values as run.DefaultConfig() (TODO break the import cycle, remove these hardcoded values and import those constants here)\n\tdefaultResolveNodeLimit                 = 25\n\tdefaultResolveNodeBreadthLimit          = 100\n\tdefaultListObjectsDeadline              = 3 * time.Second\n\tdefaultListObjectsMaxResults            = 1000\n\tdefaultMaxConcurrentReadsForListObjects = math.MaxUint32\n)\n\nvar (\n\tfurtherEvalRequiredCounter = promauto.NewCounter(prometheus.CounterOpts{\n\t\tName: \"list_objects_further_eval_required_count\",\n\t\tHelp: \"Number of objects in a ListObjects call that needed to issue a Check call to determine a final result\",\n\t})\n\n\tnoFurtherEvalRequiredCounter = promauto.NewCounter(prometheus.CounterOpts{\n\t\tName: \"list_objects_no_further_eval_required_count\",\n\t\tHelp: \"Number of objects in a ListObjects call that needed to issue a Check call to determine a final result\",\n\t})\n)\n\ntype ListObjectsQuery struct {\n\tdatastore               storage.RelationshipTupleReader\n\tlogger                  logger.Logger\n\tlistObjectsDeadline     time.Duration\n\tlistObjectsMaxResults   uint32\n\tresolveNodeLimit        uint32\n\tresolveNodeBreadthLimit uint32\n\tmaxConcurrentReads      uint32\n\n\tcheckOptions []graph.LocalCheckerOption\n}\n\ntype ListObjectsResponse struct {\n\tObjects            []string\n\tResolutionMetadata reverseexpand.ResolutionMetadata\n}\n\ntype ListObjectsQueryOption func(d *ListObjectsQuery)\n\nfunc WithListObjectsDeadline(deadline time.Duration) ListObjectsQueryOption {\n\treturn func(d *ListObjectsQuery) {\n\t\td.listObjectsDeadline = deadline\n\t}\n}\n\nfunc WithListObjectsMaxResults(max uint32) ListObjectsQueryOption {\n\treturn func(d *ListObjectsQuery) {\n\t\td.listObjectsMaxResults = max\n\t}\n}\n\n// WithResolveNodeLimit see server.WithResolveNodeLimit\nfunc WithResolveNodeLimit(limit uint32) ListObjectsQueryOption {\n\treturn func(d *ListObjectsQuery) {\n\t\td.resolveNodeLimit = limit\n\t}\n}\n\n// WithResolveNodeBreadthLimit see server.WithResolveNodeBreadthLimit\nfunc WithResolveNodeBreadthLimit(limit uint32) ListObjectsQueryOption {\n\treturn func(d *ListObjectsQuery) {\n\t\td.resolveNodeBreadthLimit = limit\n\t}\n}\n\nfunc WithLogger(l logger.Logger) ListObjectsQueryOption {\n\treturn func(d *ListObjectsQuery) {\n\t\td.logger = l\n\t}\n}\n\nfunc WithCheckOptions(checkOptions []graph.LocalCheckerOption) ListObjectsQueryOption {\n\treturn func(d *ListObjectsQuery) {\n\t\td.checkOptions = checkOptions\n\t}\n}\n\n// WithMaxConcurrentReads see server.WithMaxConcurrentReadsForListObjects\nfunc WithMaxConcurrentReads(limit uint32) ListObjectsQueryOption {\n\treturn func(d *ListObjectsQuery) {\n\t\td.maxConcurrentReads = limit\n\t}\n}\n\nfunc NewListObjectsQuery(ds storage.RelationshipTupleReader, opts ...ListObjectsQueryOption) *ListObjectsQuery {\n\tquery := &ListObjectsQuery{\n\t\tdatastore:               ds,\n\t\tlogger:                  logger.NewNoopLogger(),\n\t\tlistObjectsDeadline:     defaultListObjectsDeadline,\n\t\tlistObjectsMaxResults:   defaultListObjectsMaxResults,\n\t\tresolveNodeLimit:        defaultResolveNodeLimit,\n\t\tresolveNodeBreadthLimit: defaultResolveNodeBreadthLimit,\n\t\tmaxConcurrentReads:      defaultMaxConcurrentReadsForListObjects,\n\t\tcheckOptions:            []graph.LocalCheckerOption{},\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(query)\n\t}\n\n\tquery.datastore = storagewrappers.NewBoundedConcurrencyTupleReader(query.datastore, query.maxConcurrentReads)\n\n\treturn query\n}\n\ntype ListObjectsResult struct {\n\tObjectID string\n\tErr      error\n}\n\n// listObjectsRequest captures the RPC request definition interface for the ListObjects API.\n// The unary and streaming RPC definitions implement this interface, and so it can be used\n// interchangeably for a canonical representation between the two.\ntype listObjectsRequest interface {\n\tGetStoreId() string\n\tGetAuthorizationModelId() string\n\tGetType() string\n\tGetRelation() string\n\tGetUser() string\n\tGetContextualTuples() *openfgav1.ContextualTupleKeys\n}\n\nfunc (q *ListObjectsQuery) evaluate(\n\tctx context.Context,\n\treq listObjectsRequest,\n\tresultsChan chan<- ListObjectsResult,\n\tmaxResults uint32,\n\tresolutionMetadata *reverseexpand.ResolutionMetadata,\n) error {\n\n\ttargetObjectType := req.GetType()\n\ttargetRelation := req.GetRelation()\n\n\ttypesys, ok := typesystem.TypesystemFromContext(ctx)\n\tif !ok {\n\t\tpanic(\"typesystem missing in context\")\n\t}\n\n\tif !typesystem.IsSchemaVersionSupported(typesys.GetSchemaVersion()) {\n\t\treturn serverErrors.ValidationError(typesystem.ErrInvalidSchemaVersion)\n\t}\n\n\tfor _, ctxTuple := range req.GetContextualTuples().GetTupleKeys() {\n\t\tif err := validation.ValidateTuple(typesys, ctxTuple); err != nil {\n\t\t\treturn serverErrors.HandleTupleValidateError(err)\n\t\t}\n\t}\n\n\t_, err := typesys.GetRelation(targetObjectType, targetRelation)\n\tif err != nil {\n\t\tif errors.Is(err, typesystem.ErrObjectTypeUndefined) {\n\t\t\treturn serverErrors.TypeNotFound(targetObjectType)\n\t\t}\n\n\t\tif errors.Is(err, typesystem.ErrRelationUndefined) {\n\t\t\treturn serverErrors.RelationNotFound(targetRelation, targetObjectType, nil)\n\t\t}\n\n\t\treturn serverErrors.NewInternalError(\"\", err)\n\t}\n\n\tif err := validation.ValidateUser(typesys, req.GetUser()); err != nil {\n\t\treturn serverErrors.ValidationError(fmt.Errorf(\"invalid 'user' value: %s\", err))\n\t}\n\n\thandler := func() {\n\t\tuserObj, userRel := tuple.SplitObjectRelation(req.GetUser())\n\t\tuserObjType, userObjID := tuple.SplitObject(userObj)\n\n\t\tvar sourceUserRef reverseexpand.IsUserRef\n\t\tsourceUserRef = &reverseexpand.UserRefObject{\n\t\t\tObject: &openfgav1.Object{\n\t\t\t\tType: userObjType,\n\t\t\t\tId:   userObjID,\n\t\t\t},\n\t\t}\n\n\t\tif tuple.IsTypedWildcard(userObj) {\n\t\t\tsourceUserRef = &reverseexpand.UserRefTypedWildcard{Type: tuple.GetType(userObj)}\n\n\t\t}\n\n\t\tif userRel != \"\" {\n\t\t\tsourceUserRef = &reverseexpand.UserRefObjectRelation{\n\t\t\t\tObjectRelation: &openfgav1.ObjectRelation{\n\t\t\t\t\tObject:   userObj,\n\t\t\t\t\tRelation: userRel,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\treverseExpandResultsChan := make(chan *reverseexpand.ReverseExpandResult, 1)\n\t\tvar objectsFound = new(uint32)\n\n\t\treverseExpandQuery := reverseexpand.NewReverseExpandQuery(q.datastore, typesys,\n\t\t\treverseexpand.WithResolveNodeLimit(q.resolveNodeLimit),\n\t\t\treverseexpand.WithResolveNodeBreadthLimit(q.resolveNodeBreadthLimit),\n\t\t)\n\n\t\tgo func() {\n\t\t\terr = reverseExpandQuery.Execute(ctx, &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:          req.GetStoreId(),\n\t\t\t\tObjectType:       targetObjectType,\n\t\t\t\tRelation:         targetRelation,\n\t\t\t\tUser:             sourceUserRef,\n\t\t\t\tContextualTuples: req.GetContextualTuples().GetTupleKeys(),\n\t\t\t}, reverseExpandResultsChan, resolutionMetadata)\n\t\t\tif err != nil {\n\t\t\t\tresultsChan <- ListObjectsResult{Err: err}\n\t\t\t}\n\n\t\t\t// this is necessary to terminate the range loop below\n\t\t\tclose(reverseExpandResultsChan)\n\t\t}()\n\n\t\tcheckResolver := graph.NewLocalChecker(\n\t\t\tstoragewrappers.NewCombinedTupleReader(q.datastore, req.GetContextualTuples().GetTupleKeys()),\n\t\t\tq.checkOptions...,\n\t\t)\n\t\tdefer checkResolver.Close()\n\n\t\tconcurrencyLimiterCh := make(chan struct{}, q.resolveNodeBreadthLimit)\n\n\t\twg := sync.WaitGroup{}\n\n\t\tfor res := range reverseExpandResultsChan {\n\t\t\tif atomic.LoadUint32(objectsFound) >= maxResults {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif res.ResultStatus == reverseexpand.NoFurtherEvalStatus {\n\t\t\t\tnoFurtherEvalRequiredCounter.Inc()\n\t\t\t\ttrySendObject(res.Object, objectsFound, maxResults, resultsChan)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfurtherEvalRequiredCounter.Inc()\n\n\t\t\twg.Add(1)\n\t\t\tgo func(res *reverseexpand.ReverseExpandResult) {\n\t\t\t\tdefer func() {\n\t\t\t\t\t<-concurrencyLimiterCh\n\t\t\t\t\twg.Done()\n\t\t\t\t}()\n\n\t\t\t\tconcurrencyLimiterCh <- struct{}{}\n\n\t\t\t\tresp, err := checkResolver.ResolveCheck(ctx, &graph.ResolveCheckRequest{\n\t\t\t\t\tStoreID:              req.GetStoreId(),\n\t\t\t\t\tAuthorizationModelID: req.GetAuthorizationModelId(),\n\t\t\t\t\tTupleKey:             tuple.NewTupleKey(res.Object, req.GetRelation(), req.GetUser()),\n\t\t\t\t\tContextualTuples:     req.GetContextualTuples().GetTupleKeys(),\n\t\t\t\t\tResolutionMetadata: &graph.ResolutionMetadata{\n\t\t\t\t\t\tDepth: q.resolveNodeLimit,\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\tresultsChan <- ListObjectsResult{Err: err}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tatomic.AddUint32(resolutionMetadata.QueryCount, resp.GetResolutionMetadata().DatastoreQueryCount)\n\n\t\t\t\tif resp.Allowed {\n\t\t\t\t\ttrySendObject(res.Object, objectsFound, maxResults, resultsChan)\n\t\t\t\t}\n\t\t\t}(res)\n\t\t}\n\n\t\twg.Wait()\n\n\t\tclose(resultsChan)\n\t}\n\n\tgo handler()\n\n\treturn nil\n}\n\nfunc trySendObject(object string, objectsFound *uint32, maxResults uint32, resultsChan chan<- ListObjectsResult) {\n\tif objectsFound != nil && atomic.AddUint32(objectsFound, 1) > maxResults {\n\t\treturn\n\t}\n\tresultsChan <- ListObjectsResult{ObjectID: object}\n}\n\n// Execute the ListObjectsQuery, returning a list of object IDs up to a maximum of q.listObjectsMaxResults\n// or until q.listObjectsDeadline is hit, whichever happens first.\nfunc (q *ListObjectsQuery) Execute(\n\tctx context.Context,\n\treq *openfgav1.ListObjectsRequest,\n) (*ListObjectsResponse, error) {\n\n\tresultsChan := make(chan ListObjectsResult, 1)\n\tmaxResults := q.listObjectsMaxResults\n\tif maxResults > 0 {\n\t\tresultsChan = make(chan ListObjectsResult, maxResults)\n\t}\n\n\ttimeoutCtx := ctx\n\tif q.listObjectsDeadline != 0 {\n\t\tvar cancel context.CancelFunc\n\t\ttimeoutCtx, cancel = context.WithTimeout(ctx, q.listObjectsDeadline)\n\t\tdefer cancel()\n\t}\n\n\tresolutionMetadata := reverseexpand.NewResolutionMetadata()\n\n\terr := q.evaluate(timeoutCtx, req, resultsChan, maxResults, resolutionMetadata)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tobjects := make([]string, 0)\n\n\tfor {\n\t\tselect {\n\n\t\tcase <-timeoutCtx.Done():\n\t\t\tq.logger.WarnWithContext(\n\t\t\t\tctx, fmt.Sprintf(\"list objects timeout after %s\", q.listObjectsDeadline.String()),\n\t\t\t)\n\t\t\treturn &ListObjectsResponse{\n\t\t\t\tObjects:            objects,\n\t\t\t\tResolutionMetadata: *resolutionMetadata,\n\t\t\t}, nil\n\n\t\tcase result, channelOpen := <-resultsChan:\n\t\t\tif result.Err != nil {\n\t\t\t\tif errors.Is(result.Err, serverErrors.AuthorizationModelResolutionTooComplex) {\n\t\t\t\t\treturn nil, result.Err\n\t\t\t\t}\n\t\t\t\treturn nil, serverErrors.HandleError(\"\", result.Err)\n\t\t\t}\n\n\t\t\tif !channelOpen {\n\t\t\t\treturn &ListObjectsResponse{\n\t\t\t\t\tObjects:            objects,\n\t\t\t\t\tResolutionMetadata: *resolutionMetadata,\n\t\t\t\t}, nil\n\t\t\t}\n\t\t\tobjects = append(objects, result.ObjectID)\n\t\t}\n\t}\n}\n\n// ExecuteStreamed executes the ListObjectsQuery, returning a stream of object IDs.\n// It ignores the value of q.listObjectsMaxResults and returns all available results\n// until q.listObjectsDeadline is hit\nfunc (q *ListObjectsQuery) ExecuteStreamed(ctx context.Context, req *openfgav1.StreamedListObjectsRequest, srv openfgav1.OpenFGAService_StreamedListObjectsServer) (*reverseexpand.ResolutionMetadata, error) {\n\n\tmaxResults := uint32(math.MaxUint32)\n\t// make a buffered channel so that writer goroutines aren't blocked when attempting to send a result\n\tresultsChan := make(chan ListObjectsResult, streamedBufferSize)\n\n\ttimeoutCtx := ctx\n\tif q.listObjectsDeadline != 0 {\n\t\tvar cancel context.CancelFunc\n\t\ttimeoutCtx, cancel = context.WithTimeout(ctx, q.listObjectsDeadline)\n\t\tdefer cancel()\n\t}\n\n\tresolutionMetadata := reverseexpand.NewResolutionMetadata()\n\n\terr := q.evaluate(timeoutCtx, req, resultsChan, maxResults, resolutionMetadata)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor {\n\t\tselect {\n\n\t\tcase <-timeoutCtx.Done():\n\t\t\tq.logger.WarnWithContext(\n\t\t\t\tctx, fmt.Sprintf(\"list objects timeout after %s\", q.listObjectsDeadline.String()),\n\t\t\t)\n\t\t\treturn resolutionMetadata, nil\n\n\t\tcase result, channelOpen := <-resultsChan:\n\t\t\tif !channelOpen {\n\t\t\t\t// Channel closed! No more results.\n\t\t\t\treturn resolutionMetadata, nil\n\t\t\t}\n\n\t\t\tif result.Err != nil {\n\t\t\t\tif errors.Is(result.Err, serverErrors.AuthorizationModelResolutionTooComplex) {\n\t\t\t\t\treturn nil, result.Err\n\t\t\t\t}\n\n\t\t\t\treturn nil, serverErrors.HandleError(\"\", result.Err)\n\t\t\t}\n\n\t\t\tif err := srv.Send(&openfgav1.StreamedListObjectsResponse{\n\t\t\t\tObject: result.ObjectID,\n\t\t\t}); err != nil {\n\t\t\t\treturn nil, serverErrors.NewInternalError(\"\", err)\n\t\t\t}\n\t\t}\n\t}\n}\n", "// Package reverseexpand contains the code that handles the ReverseExpand API\npackage reverseexpand\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\"\n\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\t\"github.com/openfga/openfga/internal/graph\"\n\tserverErrors \"github.com/openfga/openfga/pkg/server/errors\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/storage/storagewrappers\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"go.opentelemetry.io/otel\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"golang.org/x/sync/errgroup\"\n)\n\nvar tracer = otel.Tracer(\"openfga/pkg/server/commands/reverse_expand\")\n\nconst (\n\t// same values as run.DefaultConfig() (TODO break the import cycle, remove these hardcoded values and import those constants here)\n\tdefaultResolveNodeLimit        = 25\n\tdefaultResolveNodeBreadthLimit = 100\n)\n\ntype ReverseExpandRequest struct {\n\tStoreID          string\n\tObjectType       string\n\tRelation         string\n\tUser             IsUserRef\n\tContextualTuples []*openfgav1.TupleKey\n}\n\n// TODO combine with above?\ntype reverseExpandRequest struct {\n\tstoreID          string\n\tedge             *graph.RelationshipEdge\n\ttargetObjectRef  *openfgav1.RelationReference\n\tsourceUserRef    IsUserRef\n\tcontextualTuples []*openfgav1.TupleKey\n}\n\ntype IsUserRef interface {\n\tisUserRef()\n\tGetObjectType() string\n\tString() string\n}\n\ntype UserRefObject struct {\n\tObject *openfgav1.Object\n}\n\nvar _ IsUserRef = (*UserRefObject)(nil)\n\nfunc (u *UserRefObject) isUserRef() {}\n\nfunc (u *UserRefObject) GetObjectType() string {\n\treturn u.Object.Type\n}\n\nfunc (u *UserRefObject) String() string {\n\treturn tuple.BuildObject(u.Object.GetType(), u.Object.GetId())\n}\n\ntype UserRefTypedWildcard struct {\n\tType string\n}\n\nvar _ IsUserRef = (*UserRefTypedWildcard)(nil)\n\nfunc (*UserRefTypedWildcard) isUserRef() {}\n\nfunc (u *UserRefTypedWildcard) GetObjectType() string {\n\treturn u.Type\n}\n\nfunc (u *UserRefTypedWildcard) String() string {\n\treturn fmt.Sprintf(\"%s:*\", u.Type)\n}\n\ntype UserRefObjectRelation struct {\n\tObjectRelation *openfgav1.ObjectRelation\n}\n\nfunc (*UserRefObjectRelation) isUserRef() {}\n\nfunc (u *UserRefObjectRelation) GetObjectType() string {\n\treturn tuple.GetType(u.ObjectRelation.Object)\n}\n\nfunc (u *UserRefObjectRelation) String() string {\n\treturn tuple.ToObjectRelationString(\n\t\tu.ObjectRelation.GetObject(),\n\t\tu.ObjectRelation.GetRelation(),\n\t)\n}\n\ntype UserRef struct {\n\n\t// Types that are assignable to Ref\n\t//  *UserRef_Object\n\t//  *UserRef_TypedWildcard\n\t//  *UserRef_ObjectRelation\n\tRef IsUserRef\n}\n\ntype ReverseExpandQuery struct {\n\tdatastore               storage.RelationshipTupleReader\n\ttypesystem              *typesystem.TypeSystem\n\tresolveNodeLimit        uint32\n\tresolveNodeBreadthLimit uint32\n\n\t// visitedUsersetsMap map prevents visiting the same userset through the same edge twice\n\tvisitedUsersetsMap *sync.Map\n\t// candidateObjectsMap map prevents returning the same object twice\n\tcandidateObjectsMap *sync.Map\n}\n\ntype ReverseExpandQueryOption func(d *ReverseExpandQuery)\n\nfunc WithResolveNodeLimit(limit uint32) ReverseExpandQueryOption {\n\treturn func(d *ReverseExpandQuery) {\n\t\td.resolveNodeLimit = limit\n\t}\n}\n\nfunc WithResolveNodeBreadthLimit(limit uint32) ReverseExpandQueryOption {\n\treturn func(d *ReverseExpandQuery) {\n\t\td.resolveNodeBreadthLimit = limit\n\t}\n}\n\nfunc NewReverseExpandQuery(ds storage.RelationshipTupleReader, ts *typesystem.TypeSystem, opts ...ReverseExpandQueryOption) *ReverseExpandQuery {\n\tquery := &ReverseExpandQuery{\n\t\tdatastore:               ds,\n\t\ttypesystem:              ts,\n\t\tresolveNodeLimit:        defaultResolveNodeLimit,\n\t\tresolveNodeBreadthLimit: defaultResolveNodeBreadthLimit,\n\t\tcandidateObjectsMap:     new(sync.Map),\n\t\tvisitedUsersetsMap:      new(sync.Map),\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(query)\n\t}\n\n\treturn query\n}\n\ntype ConditionalResultStatus int\n\nconst (\n\tRequiresFurtherEvalStatus ConditionalResultStatus = iota\n\tNoFurtherEvalStatus\n)\n\ntype ReverseExpandResult struct {\n\tObject       string\n\tResultStatus ConditionalResultStatus\n}\n\ntype ResolutionMetadata struct {\n\tQueryCount *uint32\n}\n\nfunc NewResolutionMetadata() *ResolutionMetadata {\n\treturn &ResolutionMetadata{\n\t\tQueryCount: new(uint32),\n\t}\n}\n\n// Execute yields all the objects of the provided objectType that the given user has, possibly, a specific relation with\n// and sends those objects to resultChan. It MUST guarantee no duplicate objects sent.\nfunc (c *ReverseExpandQuery) Execute(\n\tctx context.Context,\n\treq *ReverseExpandRequest,\n\tresultChan chan<- *ReverseExpandResult,\n\tresolutionMetadata *ResolutionMetadata,\n) error {\n\treturn c.execute(ctx, req, resultChan, nil, resolutionMetadata)\n}\n\nfunc (c *ReverseExpandQuery) execute(\n\tctx context.Context,\n\treq *ReverseExpandRequest,\n\tresultChan chan<- *ReverseExpandResult,\n\tcurrentEdge *graph.RelationshipEdge,\n\tresolutionMetadata *ResolutionMetadata,\n) error {\n\tctx, span := tracer.Start(ctx, \"reverseExpand.Execute\", trace.WithAttributes(\n\t\tattribute.String(\"target_type\", req.ObjectType),\n\t\tattribute.String(\"target_relation\", req.Relation),\n\t\tattribute.String(\"source\", req.User.String()),\n\t))\n\tdefer span.End()\n\n\tif currentEdge != nil {\n\t\tspan.SetAttributes(attribute.String(\"edge\", currentEdge.String()))\n\t}\n\n\tdepth, ok := graph.ResolutionDepthFromContext(ctx)\n\tif !ok {\n\t\tctx = graph.ContextWithResolutionDepth(ctx, 0)\n\t} else {\n\t\tif depth >= c.resolveNodeLimit {\n\t\t\treturn serverErrors.AuthorizationModelResolutionTooComplex\n\t\t}\n\n\t\tctx = graph.ContextWithResolutionDepth(ctx, depth+1)\n\t}\n\n\tstoreID := req.StoreID\n\n\tvar sourceUserRef *openfgav1.RelationReference\n\tvar sourceUserType, sourceUserObj string\n\n\t// e.g. 'user:bob'\n\tif val, ok := req.User.(*UserRefObject); ok {\n\t\tsourceUserType = val.Object.GetType()\n\t\tsourceUserObj = tuple.BuildObject(sourceUserType, val.Object.GetId())\n\t\tsourceUserRef = typesystem.DirectRelationReference(sourceUserType, \"\")\n\t}\n\n\t// e.g. 'user:*'\n\tif val, ok := req.User.(*UserRefTypedWildcard); ok {\n\t\tsourceUserType = val.Type\n\t\tsourceUserRef = typesystem.WildcardRelationReference(sourceUserType)\n\t}\n\n\t// e.g. 'group:eng#member'\n\tif val, ok := req.User.(*UserRefObjectRelation); ok {\n\t\tsourceUserType = tuple.GetType(val.ObjectRelation.GetObject())\n\t\tsourceUserObj = val.ObjectRelation.Object\n\t\tsourceUserRef = typesystem.DirectRelationReference(sourceUserType, val.ObjectRelation.GetRelation())\n\t\tsourceUserRel := val.ObjectRelation.GetRelation()\n\n\t\tif currentEdge != nil {\n\t\t\tkey := fmt.Sprintf(\"%s#%s\", sourceUserObj, currentEdge.String())\n\t\t\tif _, loaded := c.visitedUsersetsMap.LoadOrStore(key, struct{}{}); loaded {\n\t\t\t\t// we've already visited this userset through this edge, exit to avoid an infinite cycle\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tif sourceUserType == req.ObjectType && sourceUserRel == req.Relation {\n\t\t\t\tc.trySendCandidate(ctx, currentEdge, sourceUserObj, resultChan)\n\t\t\t}\n\t\t}\n\t}\n\n\ttargetObjRef := typesystem.DirectRelationReference(req.ObjectType, req.Relation)\n\n\tg := graph.New(c.typesystem)\n\n\tedges, err := g.GetPrunedRelationshipEdges(targetObjRef, sourceUserRef)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsubg, subgctx := errgroup.WithContext(ctx)\n\tsubg.SetLimit(int(c.resolveNodeBreadthLimit))\n\n\tfor _, edge := range edges {\n\t\tinnerLoopEdge := edge\n\t\tif currentEdge != nil && currentEdge.Condition == graph.RequiresFurtherEvalCondition {\n\t\t\t// propagate the condition to upcoming reverse expansions\n\t\t\t// TODO don't mutate the edge, keep track of the previous edge's condition and use it in trySendCandidate\n\t\t\tinnerLoopEdge.Condition = graph.RequiresFurtherEvalCondition\n\t\t}\n\t\tsubg.Go(func() error {\n\t\t\tr := &reverseExpandRequest{\n\t\t\t\tstoreID:          storeID,\n\t\t\t\tedge:             innerLoopEdge,\n\t\t\t\ttargetObjectRef:  targetObjRef,\n\t\t\t\tsourceUserRef:    req.User,\n\t\t\t\tcontextualTuples: req.ContextualTuples,\n\t\t\t}\n\n\t\t\tswitch innerLoopEdge.Type {\n\t\t\tcase graph.DirectEdge:\n\t\t\t\treturn c.reverseExpandDirect(subgctx, r, resultChan, resolutionMetadata)\n\t\t\tcase graph.ComputedUsersetEdge:\n\t\t\t\t// lookup the rewritten target relation on the computed_userset ingress\n\t\t\t\treturn c.execute(subgctx, &ReverseExpandRequest{\n\t\t\t\t\tStoreID:    storeID,\n\t\t\t\t\tObjectType: req.ObjectType,\n\t\t\t\t\tRelation:   req.Relation,\n\t\t\t\t\tUser: &UserRefObjectRelation{\n\t\t\t\t\t\tObjectRelation: &openfgav1.ObjectRelation{\n\t\t\t\t\t\t\tObject:   sourceUserObj,\n\t\t\t\t\t\t\tRelation: innerLoopEdge.TargetReference.GetRelation(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tContextualTuples: r.contextualTuples,\n\t\t\t\t}, resultChan, innerLoopEdge, resolutionMetadata)\n\t\t\tcase graph.TupleToUsersetEdge:\n\t\t\t\treturn c.reverseExpandTupleToUserset(subgctx, r, resultChan, resolutionMetadata)\n\t\t\tdefault:\n\t\t\t\treturn fmt.Errorf(\"unsupported edge type\")\n\t\t\t}\n\t\t})\n\t}\n\n\treturn subg.Wait()\n}\n\nfunc (c *ReverseExpandQuery) reverseExpandTupleToUserset(\n\tctx context.Context,\n\treq *reverseExpandRequest,\n\tresultChan chan<- *ReverseExpandResult,\n\tresolutionMetadata *ResolutionMetadata,\n) error {\n\tctx, span := tracer.Start(ctx, \"reverseExpandTupleToUserset\", trace.WithAttributes(\n\t\tattribute.String(\"edge\", req.edge.String()),\n\t\tattribute.String(\"source.user\", req.sourceUserRef.String()),\n\t))\n\tdefer span.End()\n\n\tstore := req.storeID\n\n\ttargetObjectType := req.targetObjectRef.GetType()\n\ttargetObjectRel := req.targetObjectRef.GetRelation()\n\n\tvar userFilter []*openfgav1.ObjectRelation\n\n\t// a TTU edge can only have a userset as a source node\n\t// e.g. 'group:eng#member'\n\tif val, ok := req.sourceUserRef.(*UserRefObjectRelation); ok {\n\t\tuserFilter = append(userFilter, &openfgav1.ObjectRelation{\n\t\t\tObject: val.ObjectRelation.Object,\n\t\t})\n\t} else {\n\t\tpanic(\"unexpected source for reverse expansion of tuple to userset\")\n\t}\n\n\tcombinedTupleReader := storagewrappers.NewCombinedTupleReader(c.datastore, req.contextualTuples)\n\n\t// find all tuples of the form req.edge.TargetReference.Type:...#req.edge.TuplesetRelation@req.sourceUserRef\n\titer, err := combinedTupleReader.ReadStartingWithUser(ctx, store, storage.ReadStartingWithUserFilter{\n\t\tObjectType: req.edge.TargetReference.GetType(),\n\t\tRelation:   req.edge.TuplesetRelation.GetRelation(),\n\t\tUserFilter: userFilter,\n\t})\n\tatomic.AddUint32(resolutionMetadata.QueryCount, 1)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer iter.Stop()\n\n\tsubg, subgctx := errgroup.WithContext(ctx)\n\tsubg.SetLimit(int(c.resolveNodeBreadthLimit))\n\n\tfor {\n\t\tt, err := iter.Next()\n\t\tif err != nil {\n\t\t\tif errors.Is(err, storage.ErrIteratorDone) {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\treturn err\n\t\t}\n\n\t\ttk := t.GetKey()\n\n\t\tfoundObject := tk.GetObject()\n\n\t\tsourceUserRef := &UserRefObjectRelation{\n\t\t\tObjectRelation: &openfgav1.ObjectRelation{\n\t\t\t\tObject:   foundObject,\n\t\t\t\tRelation: req.edge.TargetReference.GetRelation(),\n\t\t\t},\n\t\t}\n\n\t\tsubg.Go(func() error {\n\t\t\treturn c.execute(subgctx, &ReverseExpandRequest{\n\t\t\t\tStoreID:          store,\n\t\t\t\tObjectType:       targetObjectType,\n\t\t\t\tRelation:         targetObjectRel,\n\t\t\t\tUser:             sourceUserRef,\n\t\t\t\tContextualTuples: req.contextualTuples,\n\t\t\t}, resultChan, req.edge, resolutionMetadata)\n\t\t})\n\t}\n\n\treturn subg.Wait()\n}\n\nfunc (c *ReverseExpandQuery) reverseExpandDirect(\n\tctx context.Context,\n\treq *reverseExpandRequest,\n\tresultChan chan<- *ReverseExpandResult,\n\tresolutionMetadata *ResolutionMetadata,\n) error {\n\tctx, span := tracer.Start(ctx, \"reverseExpandDirect\", trace.WithAttributes(\n\t\tattribute.String(\"edge\", req.edge.String()),\n\t\tattribute.String(\"source.user\", req.sourceUserRef.String()),\n\t))\n\tdefer span.End()\n\n\tstore := req.storeID\n\n\ttargetObjectType := req.targetObjectRef.GetType()\n\ttargetObjectRel := req.targetObjectRef.GetRelation()\n\n\tvar userFilter []*openfgav1.ObjectRelation\n\n\ttargetUserObjectType := req.sourceUserRef.GetObjectType()\n\n\tpubliclyAssignable, err := c.typesystem.IsPubliclyAssignable(req.edge.TargetReference, targetUserObjectType)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif publiclyAssignable {\n\t\t// e.g. 'user:*'\n\t\tuserFilter = append(userFilter, &openfgav1.ObjectRelation{\n\t\t\tObject: fmt.Sprintf(\"%s:*\", targetUserObjectType),\n\t\t})\n\t}\n\n\tsourceRelationRef := &openfgav1.RelationReference{\n\t\tType: req.sourceUserRef.GetObjectType(),\n\t}\n\n\t// e.g. 'user:bob'\n\tif val, ok := req.sourceUserRef.(*UserRefObject); ok {\n\t\tuserFilter = append(userFilter, &openfgav1.ObjectRelation{\n\t\t\tObject: tuple.BuildObject(val.Object.Type, val.Object.Id),\n\t\t})\n\t}\n\n\t// e.g. 'group:eng#member'\n\tif val, ok := req.sourceUserRef.(*UserRefObjectRelation); ok {\n\t\tsourceRelationRef.RelationOrWildcard = &openfgav1.RelationReference_Relation{\n\t\t\tRelation: val.ObjectRelation.Relation,\n\t\t}\n\n\t\tuserFilter = append(userFilter, val.ObjectRelation)\n\t}\n\n\tcombinedTupleReader := storagewrappers.NewCombinedTupleReader(c.datastore, req.contextualTuples)\n\n\t// find all tuples of the form req.edge.TargetReference.Type:...#req.edge.TargetReference.Relation@req.sourceUserRef\n\titer, err := combinedTupleReader.ReadStartingWithUser(ctx, store, storage.ReadStartingWithUserFilter{\n\t\tObjectType: req.edge.TargetReference.GetType(),\n\t\tRelation:   req.edge.TargetReference.GetRelation(),\n\t\tUserFilter: userFilter,\n\t})\n\tatomic.AddUint32(resolutionMetadata.QueryCount, 1)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer iter.Stop()\n\n\tsubg, subgctx := errgroup.WithContext(ctx)\n\tsubg.SetLimit(int(c.resolveNodeBreadthLimit))\n\n\tfor {\n\t\tt, err := iter.Next()\n\t\tif err != nil {\n\t\t\tif errors.Is(err, storage.ErrIteratorDone) {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\treturn err\n\t\t}\n\n\t\ttk := t.GetKey()\n\n\t\tfoundObject := tk.GetObject()\n\n\t\tsourceUserRef := &UserRefObjectRelation{\n\t\t\tObjectRelation: &openfgav1.ObjectRelation{\n\t\t\t\tObject:   foundObject,\n\t\t\t\tRelation: tk.GetRelation(),\n\t\t\t},\n\t\t}\n\n\t\tsubg.Go(func() error {\n\t\t\treturn c.execute(subgctx, &ReverseExpandRequest{\n\t\t\t\tStoreID:          store,\n\t\t\t\tObjectType:       targetObjectType,\n\t\t\t\tRelation:         targetObjectRel,\n\t\t\t\tUser:             sourceUserRef,\n\t\t\t\tContextualTuples: req.contextualTuples,\n\t\t\t}, resultChan, req.edge, resolutionMetadata)\n\t\t})\n\t}\n\n\treturn subg.Wait()\n}\n\nfunc (c *ReverseExpandQuery) trySendCandidate(ctx context.Context, edge *graph.RelationshipEdge, candidateObject string, candidateChan chan<- *ReverseExpandResult) {\n\t_, span := tracer.Start(ctx, \"trySendCandidate\", trace.WithAttributes(\n\t\tattribute.String(\"object\", candidateObject),\n\t\tattribute.Bool(\"sent\", false),\n\t))\n\tdefer span.End()\n\tif _, ok := c.candidateObjectsMap.LoadOrStore(candidateObject, struct{}{}); !ok {\n\t\tresultStatus := NoFurtherEvalStatus\n\t\tif edge != nil && edge.Condition == graph.RequiresFurtherEvalCondition {\n\t\t\tspan.SetAttributes(attribute.Bool(\"requires_further_eval\", true))\n\t\t\tresultStatus = RequiresFurtherEvalStatus\n\t\t}\n\t\tcandidateChan <- &ReverseExpandResult{\n\t\t\tObject:       candidateObject,\n\t\t\tResultStatus: resultStatus,\n\t\t}\n\t\tspan.SetAttributes(attribute.Bool(\"sent\", true))\n\t}\n}\n", "// Package server contains the endpoint handlers.\npackage server\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"net/http\"\n\t\"slices\"\n\t\"sort\"\n\t\"strconv\"\n\t\"time\"\n\n\tgrpc_ctxtags \"github.com/grpc-ecosystem/go-grpc-middleware/tags\"\n\t\"github.com/karlseguin/ccache/v3\"\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\t\"github.com/openfga/openfga/internal/gateway\"\n\t\"github.com/openfga/openfga/internal/graph\"\n\t\"github.com/openfga/openfga/internal/utils\"\n\t\"github.com/openfga/openfga/internal/validation\"\n\t\"github.com/openfga/openfga/pkg/encoder\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\thttpmiddleware \"github.com/openfga/openfga/pkg/middleware/http\"\n\t\"github.com/openfga/openfga/pkg/middleware/validator\"\n\t\"github.com/openfga/openfga/pkg/server/commands\"\n\tserverErrors \"github.com/openfga/openfga/pkg/server/errors\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/storage/storagewrappers\"\n\t\"github.com/openfga/openfga/pkg/telemetry\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promauto\"\n\t\"go.opentelemetry.io/otel\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"go.uber.org/zap\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"google.golang.org/grpc/status\"\n)\n\ntype ExperimentalFeatureFlag string\n\nconst (\n\tAuthorizationModelIDHeader                          = \"openfga-authorization-model-id\"\n\tauthorizationModelIDKey                             = \"authorization_model_id\"\n\tExperimentalCheckQueryCache ExperimentalFeatureFlag = \"check-query-cache\"\n\n\t// same values as run.DefaultConfig() (TODO break the import cycle, remove these hardcoded values and import those constants here)\n\tdefaultChangelogHorizonOffset           = 0\n\tdefaultResolveNodeLimit                 = 25\n\tdefaultResolveNodeBreadthLimit          = 100\n\tdefaultListObjectsDeadline              = 3 * time.Second\n\tdefaultListObjectsMaxResults            = 1000\n\tdefaultMaxConcurrentReadsForCheck       = math.MaxUint32\n\tdefaultMaxConcurrentReadsForListObjects = math.MaxUint32\n\tdefaultCheckQueryCacheLimit             = 10000\n\tdefaultCheckQueryCacheTTL               = 10 * time.Second\n\tdefaultCheckQueryCacheEnable            = false\n)\n\nvar tracer = otel.Tracer(\"openfga/pkg/server\")\n\nvar (\n\tdatastoreQueryCountHistogramName = \"datastore_query_count\"\n\n\tdatastoreQueryCountHistogram = promauto.NewHistogramVec(prometheus.HistogramOpts{\n\t\tName:                            datastoreQueryCountHistogramName,\n\t\tHelp:                            \"The number of database queries required to resolve a query (e.g. Check or ListObjects).\",\n\t\tBuckets:                         []float64{1, 5, 20, 50, 100, 150, 225, 400, 500, 750, 1000},\n\t\tNativeHistogramBucketFactor:     1.1,\n\t\tNativeHistogramMaxBucketNumber:  100,\n\t\tNativeHistogramMinResetDuration: time.Hour,\n\t}, []string{\"grpc_service\", \"grpc_method\"})\n\n\trequestDurationByQueryHistogramName = \"request_duration_by_query_count_ms\"\n\n\trequestDurationByQueryHistogram = promauto.NewHistogramVec(prometheus.HistogramOpts{\n\t\tName:                            requestDurationByQueryHistogramName,\n\t\tHelp:                            \"The request duration (in ms) labeled by method and buckets of datastore query counts. This allows for reporting percentiles based on the number of datastore queries required to resolve the request.\",\n\t\tBuckets:                         []float64{1, 5, 10, 25, 50, 80, 100, 150, 200, 300, 1000, 2000, 5000},\n\t\tNativeHistogramBucketFactor:     1.1,\n\t\tNativeHistogramMaxBucketNumber:  100,\n\t\tNativeHistogramMinResetDuration: time.Hour,\n\t}, []string{\"grpc_service\", \"grpc_method\", \"datastore_query_count\"})\n)\n\n// A Server implements the OpenFGA service backend as both\n// a GRPC and HTTP server.\ntype Server struct {\n\topenfgav1.UnimplementedOpenFGAServiceServer\n\n\tlogger                           logger.Logger\n\tdatastore                        storage.OpenFGADatastore\n\tencoder                          encoder.Encoder\n\ttransport                        gateway.Transport\n\tresolveNodeLimit                 uint32\n\tresolveNodeBreadthLimit          uint32\n\tchangelogHorizonOffset           int\n\tlistObjectsDeadline              time.Duration\n\tlistObjectsMaxResults            uint32\n\tmaxConcurrentReadsForListObjects uint32\n\tmaxConcurrentReadsForCheck       uint32\n\texperimentals                    []ExperimentalFeatureFlag\n\n\ttypesystemResolver typesystem.TypesystemResolverFunc\n\n\tcheckOptions           []graph.LocalCheckerOption\n\tcheckQueryCacheEnabled bool\n\tcheckQueryCacheLimit   uint32\n\tcheckQueryCacheTTL     time.Duration\n\tcheckCache             *ccache.Cache[*graph.CachedResolveCheckResponse] // checkCache has to be shared across requests\n\n\trequestDurationByQueryHistogramBuckets []uint\n}\n\ntype OpenFGAServiceV1Option func(s *Server)\n\nfunc WithDatastore(ds storage.OpenFGADatastore) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\ts.datastore = ds\n\t}\n}\n\nfunc WithLogger(l logger.Logger) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\ts.logger = l\n\t}\n}\n\nfunc WithTokenEncoder(encoder encoder.Encoder) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\ts.encoder = encoder\n\t}\n}\n\nfunc WithTransport(t gateway.Transport) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\ts.transport = t\n\t}\n}\n\n// WithResolveNodeLimit sets a limit on the number of recursive calls that one Check or ListObjects call will allow.\n// Thinking of a request as a tree of evaluations, this option controls\n// how many levels we will evaluate before throwing an error that the authorization model is too complex.\nfunc WithResolveNodeLimit(limit uint32) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\ts.resolveNodeLimit = limit\n\t}\n}\n\n// WithResolveNodeBreadthLimit sets a limit on the number of goroutines that can be created\n// when evaluating a subtree of a Check or ListObjects call.\n// Thinking of a Check request as a tree of evaluations, this option controls,\n// on a given level of the tree, the maximum number of nodes that can be evaluated concurrently (the breadth).\n// If your authorization models are very complex (e.g. one relation is a union of many relations, or one relation\n// is deeply nested), or if you have lots of users for (object, relation) pairs,\n// you should set this option to be a low number (e.g. 1000)\nfunc WithResolveNodeBreadthLimit(limit uint32) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\ts.resolveNodeBreadthLimit = limit\n\t}\n}\n\nfunc WithChangelogHorizonOffset(offset int) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\ts.changelogHorizonOffset = offset\n\t}\n}\n\nfunc WithListObjectsDeadline(deadline time.Duration) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\ts.listObjectsDeadline = deadline\n\t}\n}\n\nfunc WithListObjectsMaxResults(limit uint32) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\ts.listObjectsMaxResults = limit\n\t}\n}\n\n// WithMaxConcurrentReadsForListObjects sets a limit on the number of datastore reads that can be in flight for a given ListObjects call.\n// This number should be set depending on the RPS expected for Check and ListObjects APIs, the number of OpenFGA replicas running,\n// and the number of connections the datastore allows.\n// E.g. if Datastore.MaxOpenConns = 100 and assuming that each ListObjects call takes 1 second and no traffic to Check API:\n// - One OpenFGA replica and expected traffic of 100 RPS => set it to 1.\n// - One OpenFGA replica and expected traffic of 1 RPS => set it to 100.\n// - Two OpenFGA replicas and expected traffic of 1 RPS => set it to 50.\nfunc WithMaxConcurrentReadsForListObjects(max uint32) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\ts.maxConcurrentReadsForListObjects = max\n\t}\n}\n\n// WithMaxConcurrentReadsForCheck sets a limit on the number of datastore reads that can be in flight for a given Check call.\n// This number should be set depending on the RPS expected for Check and ListObjects APIs, the number of OpenFGA replicas running,\n// and the number of connections the datastore allows.\n// E.g. if Datastore.MaxOpenConns = 100 and assuming that each Check call takes 1 second and no traffic to ListObjects API:\n// - One OpenFGA replica and expected traffic of 100 RPS => set it to 1.\n// - One OpenFGA replica and expected traffic of 1 RPS => set it to 100.\n// - Two OpenFGA replicas and expected traffic of 1 RPS => set it to 50.\nfunc WithMaxConcurrentReadsForCheck(max uint32) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\ts.maxConcurrentReadsForCheck = max\n\t}\n}\n\nfunc WithExperimentals(experimentals ...ExperimentalFeatureFlag) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\ts.experimentals = experimentals\n\t}\n}\n\n// WithCheckQueryCacheEnabled enables/disables caching of check and list objects partial results.\nfunc WithCheckQueryCacheEnabled(enabled bool) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\ts.checkQueryCacheEnabled = enabled\n\t}\n}\n\n// WithCheckQueryCacheLimit sets the cache size limit (in items)\nfunc WithCheckQueryCacheLimit(limit uint32) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\ts.checkQueryCacheLimit = limit\n\t}\n}\n\n// WithCheckQueryCacheTTL sets the TTL of cached checks and list objects partial results\nfunc WithCheckQueryCacheTTL(ttl time.Duration) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\ts.checkQueryCacheTTL = ttl\n\t}\n}\n\n// WithRequestDurationByQueryHistogramBuckets sets the buckets used in labelling the requestDurationByQueryHistogram\nfunc WithRequestDurationByQueryHistogramBuckets(buckets []uint) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\tsort.Slice(buckets, func(i, j int) bool { return buckets[i] < buckets[j] })\n\t\ts.requestDurationByQueryHistogramBuckets = buckets\n\t}\n}\n\nfunc MustNewServerWithOpts(opts ...OpenFGAServiceV1Option) *Server {\n\ts, err := NewServerWithOpts(opts...)\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\"failed to construct the OpenFGA server: %w\", err))\n\t}\n\n\treturn s\n}\n\nfunc NewServerWithOpts(opts ...OpenFGAServiceV1Option) (*Server, error) {\n\n\ts := &Server{\n\t\tlogger:                           logger.NewNoopLogger(),\n\t\tencoder:                          encoder.NewBase64Encoder(),\n\t\ttransport:                        gateway.NewNoopTransport(),\n\t\tchangelogHorizonOffset:           defaultChangelogHorizonOffset,\n\t\tresolveNodeLimit:                 defaultResolveNodeLimit,\n\t\tresolveNodeBreadthLimit:          defaultResolveNodeBreadthLimit,\n\t\tlistObjectsDeadline:              defaultListObjectsDeadline,\n\t\tlistObjectsMaxResults:            defaultListObjectsMaxResults,\n\t\tmaxConcurrentReadsForCheck:       defaultMaxConcurrentReadsForCheck,\n\t\tmaxConcurrentReadsForListObjects: defaultMaxConcurrentReadsForListObjects,\n\t\texperimentals:                    make([]ExperimentalFeatureFlag, 0, 10),\n\n\t\tcheckQueryCacheEnabled: defaultCheckQueryCacheEnable,\n\t\tcheckQueryCacheLimit:   defaultCheckQueryCacheLimit,\n\t\tcheckQueryCacheTTL:     defaultCheckQueryCacheTTL,\n\t\tcheckCache:             nil,\n\n\t\trequestDurationByQueryHistogramBuckets: []uint{50, 200},\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(s)\n\t}\n\n\ts.checkOptions = []graph.LocalCheckerOption{\n\t\tgraph.WithResolveNodeBreadthLimit(s.resolveNodeBreadthLimit),\n\t\tgraph.WithMaxConcurrentReads(s.maxConcurrentReadsForCheck),\n\t}\n\n\tif slices.Contains(s.experimentals, ExperimentalCheckQueryCache) && s.checkQueryCacheEnabled {\n\t\ts.logger.Info(\"Check query cache is enabled and may lead to stale query results up to the configured query cache TTL\",\n\t\t\tzap.Duration(\"CheckQueryCacheTTL\", s.checkQueryCacheTTL),\n\t\t\tzap.Uint32(\"CheckQueryCacheLimit\", s.checkQueryCacheLimit))\n\t\ts.checkCache = ccache.New(\n\t\t\tccache.Configure[*graph.CachedResolveCheckResponse]().MaxSize(int64(s.checkQueryCacheLimit)),\n\t\t)\n\t\ts.checkOptions = append(s.checkOptions, graph.WithCachedResolver(\n\t\t\tgraph.WithExistingCache(s.checkCache),\n\t\t\tgraph.WithCacheTTL(s.checkQueryCacheTTL),\n\t\t))\n\t}\n\n\tif s.datastore == nil {\n\t\treturn nil, fmt.Errorf(\"a datastore option must be provided\")\n\t}\n\n\tif len(s.requestDurationByQueryHistogramBuckets) == 0 {\n\t\treturn nil, fmt.Errorf(\"request duration datastore count buckets must not be empty\")\n\t}\n\n\ts.typesystemResolver = typesystem.MemoizedTypesystemResolverFunc(s.datastore)\n\n\treturn s, nil\n}\n\nfunc (s *Server) ListObjects(ctx context.Context, req *openfgav1.ListObjectsRequest) (*openfgav1.ListObjectsResponse, error) {\n\n\ttargetObjectType := req.GetType()\n\n\tctx, span := tracer.Start(ctx, \"ListObjects\", trace.WithAttributes(\n\t\tattribute.String(\"object_type\", targetObjectType),\n\t\tattribute.String(\"relation\", req.GetRelation()),\n\t\tattribute.String(\"user\", req.GetUser()),\n\t))\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tconst methodName = \"listobjects\"\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  methodName,\n\t})\n\n\tstoreID := req.GetStoreId()\n\n\ttypesys, err := s.resolveTypesystem(ctx, storeID, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcheckOptions := []graph.LocalCheckerOption{\n\t\tgraph.WithResolveNodeBreadthLimit(s.resolveNodeBreadthLimit),\n\t\tgraph.WithMaxConcurrentReads(s.maxConcurrentReadsForListObjects),\n\t}\n\tif s.checkCache != nil {\n\t\tcheckOptions = append(checkOptions, graph.WithCachedResolver(\n\t\t\tgraph.WithExistingCache(s.checkCache),\n\t\t\tgraph.WithCacheTTL(s.checkQueryCacheTTL),\n\t\t))\n\t}\n\n\tq := commands.NewListObjectsQuery(s.datastore,\n\t\tcommands.WithLogger(s.logger),\n\t\tcommands.WithListObjectsDeadline(s.listObjectsDeadline),\n\t\tcommands.WithListObjectsMaxResults(s.listObjectsMaxResults),\n\t\tcommands.WithResolveNodeLimit(s.resolveNodeLimit),\n\t\tcommands.WithResolveNodeBreadthLimit(s.resolveNodeBreadthLimit),\n\t\tcommands.WithCheckOptions(checkOptions),\n\t\tcommands.WithMaxConcurrentReads(s.maxConcurrentReadsForListObjects),\n\t)\n\n\tresult, err := q.Execute(\n\t\ttypesystem.ContextWithTypesystem(ctx, typesys),\n\t\t&openfgav1.ListObjectsRequest{\n\t\t\tStoreId:              storeID,\n\t\t\tContextualTuples:     req.GetContextualTuples(),\n\t\t\tAuthorizationModelId: typesys.GetAuthorizationModelID(), // the resolved model id\n\t\t\tType:                 targetObjectType,\n\t\t\tRelation:             req.Relation,\n\t\t\tUser:                 req.User,\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tqueryCount := float64(*result.ResolutionMetadata.QueryCount)\n\n\tgrpc_ctxtags.Extract(ctx).Set(datastoreQueryCountHistogramName, queryCount)\n\tspan.SetAttributes(attribute.Float64(datastoreQueryCountHistogramName, queryCount))\n\tdatastoreQueryCountHistogram.WithLabelValues(\n\t\topenfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tmethodName,\n\t).Observe(queryCount)\n\n\treturn &openfgav1.ListObjectsResponse{\n\t\tObjects: result.Objects,\n\t}, nil\n\n}\n\nfunc (s *Server) StreamedListObjects(req *openfgav1.StreamedListObjectsRequest, srv openfgav1.OpenFGAService_StreamedListObjectsServer) error {\n\tctx := srv.Context()\n\tctx, span := tracer.Start(ctx, \"StreamedListObjects\", trace.WithAttributes(\n\t\tattribute.String(\"object_type\", req.GetType()),\n\t\tattribute.String(\"relation\", req.GetRelation()),\n\t\tattribute.String(\"user\", req.GetUser()),\n\t))\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tconst methodName = \"streamedlistobjects\"\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  methodName,\n\t})\n\n\tstoreID := req.GetStoreId()\n\n\ttypesys, err := s.resolveTypesystem(ctx, storeID, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcheckOptions := []graph.LocalCheckerOption{\n\t\tgraph.WithResolveNodeBreadthLimit(s.resolveNodeBreadthLimit),\n\t\tgraph.WithMaxConcurrentReads(s.maxConcurrentReadsForListObjects),\n\t}\n\tif s.checkCache != nil {\n\t\tcheckOptions = append(checkOptions, graph.WithCachedResolver(\n\t\t\tgraph.WithExistingCache(s.checkCache),\n\t\t\tgraph.WithCacheTTL(s.checkQueryCacheTTL),\n\t\t))\n\t}\n\n\tq := commands.NewListObjectsQuery(s.datastore,\n\t\tcommands.WithLogger(s.logger),\n\t\tcommands.WithListObjectsDeadline(s.listObjectsDeadline),\n\t\tcommands.WithListObjectsMaxResults(s.listObjectsMaxResults),\n\t\tcommands.WithResolveNodeLimit(s.resolveNodeLimit),\n\t\tcommands.WithResolveNodeBreadthLimit(s.resolveNodeBreadthLimit),\n\t\tcommands.WithCheckOptions(checkOptions),\n\t\tcommands.WithMaxConcurrentReads(s.maxConcurrentReadsForListObjects),\n\t)\n\n\treq.AuthorizationModelId = typesys.GetAuthorizationModelID() // the resolved model id\n\n\tresolutionMetadata, err := q.ExecuteStreamed(\n\t\ttypesystem.ContextWithTypesystem(ctx, typesys),\n\t\treq,\n\t\tsrv,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\tqueryCount := float64(*resolutionMetadata.QueryCount)\n\n\tgrpc_ctxtags.Extract(ctx).Set(datastoreQueryCountHistogramName, queryCount)\n\tspan.SetAttributes(attribute.Float64(datastoreQueryCountHistogramName, queryCount))\n\tdatastoreQueryCountHistogram.WithLabelValues(\n\t\topenfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tmethodName,\n\t).Observe(queryCount)\n\n\treturn nil\n}\n\nfunc (s *Server) Read(ctx context.Context, req *openfgav1.ReadRequest) (*openfgav1.ReadResponse, error) {\n\n\ttk := req.GetTupleKey()\n\tctx, span := tracer.Start(ctx, \"Read\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"object\", Value: attribute.StringValue(tk.GetObject())},\n\t\tattribute.KeyValue{Key: \"relation\", Value: attribute.StringValue(tk.GetRelation())},\n\t\tattribute.KeyValue{Key: \"user\", Value: attribute.StringValue(tk.GetUser())},\n\t))\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  \"Read\",\n\t})\n\n\tq := commands.NewReadQuery(s.datastore, s.logger, s.encoder)\n\treturn q.Execute(ctx, &openfgav1.ReadRequest{\n\t\tStoreId:           req.GetStoreId(),\n\t\tTupleKey:          tk,\n\t\tPageSize:          req.GetPageSize(),\n\t\tContinuationToken: req.GetContinuationToken(),\n\t})\n}\n\nfunc (s *Server) Write(ctx context.Context, req *openfgav1.WriteRequest) (*openfgav1.WriteResponse, error) {\n\tctx, span := tracer.Start(ctx, \"Write\")\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  \"Write\",\n\t})\n\n\tstoreID := req.GetStoreId()\n\n\ttypesys, err := s.resolveTypesystem(ctx, storeID, req.AuthorizationModelId)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcmd := commands.NewWriteCommand(s.datastore, s.logger)\n\treturn cmd.Execute(ctx, &openfgav1.WriteRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: typesys.GetAuthorizationModelID(), // the resolved model id\n\t\tWrites:               req.GetWrites(),\n\t\tDeletes:              req.GetDeletes(),\n\t})\n}\n\nfunc (s *Server) Check(ctx context.Context, req *openfgav1.CheckRequest) (*openfgav1.CheckResponse, error) {\n\tstart := time.Now()\n\n\ttk := req.GetTupleKey()\n\tctx, span := tracer.Start(ctx, \"Check\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"object\", Value: attribute.StringValue(tk.GetObject())},\n\t\tattribute.KeyValue{Key: \"relation\", Value: attribute.StringValue(tk.GetRelation())},\n\t\tattribute.KeyValue{Key: \"user\", Value: attribute.StringValue(tk.GetUser())},\n\t))\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  \"Check\",\n\t})\n\n\tif tk.GetUser() == \"\" || tk.GetRelation() == \"\" || tk.GetObject() == \"\" {\n\t\treturn nil, serverErrors.InvalidCheckInput\n\t}\n\n\tstoreID := req.GetStoreId()\n\n\ttypesys, err := s.resolveTypesystem(ctx, storeID, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := validation.ValidateUserObjectRelation(typesys, tk); err != nil {\n\t\treturn nil, serverErrors.ValidationError(err)\n\t}\n\n\tfor _, ctxTuple := range req.GetContextualTuples().GetTupleKeys() {\n\t\tif err := validation.ValidateTuple(typesys, ctxTuple); err != nil {\n\t\t\treturn nil, serverErrors.HandleTupleValidateError(err)\n\t\t}\n\t}\n\n\tctx = typesystem.ContextWithTypesystem(ctx, typesys)\n\n\tcheckResolver := graph.NewLocalChecker(\n\t\tstoragewrappers.NewCombinedTupleReader(s.datastore, req.ContextualTuples.GetTupleKeys()),\n\t\ts.checkOptions...,\n\t)\n\tdefer checkResolver.Close()\n\n\tresp, err := checkResolver.ResolveCheck(ctx, &graph.ResolveCheckRequest{\n\t\tStoreID:              req.GetStoreId(),\n\t\tAuthorizationModelID: typesys.GetAuthorizationModelID(), // the resolved model id\n\t\tTupleKey:             req.GetTupleKey(),\n\t\tContextualTuples:     req.ContextualTuples.GetTupleKeys(),\n\t\tResolutionMetadata: &graph.ResolutionMetadata{\n\t\t\tDepth:               s.resolveNodeLimit,\n\t\t\tDatastoreQueryCount: 0,\n\t\t},\n\t})\n\tif err != nil {\n\t\tif errors.Is(err, graph.ErrResolutionDepthExceeded) {\n\t\t\treturn nil, serverErrors.AuthorizationModelResolutionTooComplex\n\t\t}\n\n\t\treturn nil, serverErrors.HandleError(\"\", err)\n\t}\n\n\tqueryCount := float64(resp.GetResolutionMetadata().DatastoreQueryCount)\n\tconst methodName = \"check\"\n\n\tgrpc_ctxtags.Extract(ctx).Set(datastoreQueryCountHistogramName, queryCount)\n\tspan.SetAttributes(attribute.Float64(datastoreQueryCountHistogramName, queryCount))\n\tdatastoreQueryCountHistogram.WithLabelValues(\n\t\topenfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tmethodName,\n\t).Observe(queryCount)\n\n\tres := &openfgav1.CheckResponse{\n\t\tAllowed: resp.Allowed,\n\t}\n\n\tspan.SetAttributes(attribute.KeyValue{Key: \"allowed\", Value: attribute.BoolValue(res.GetAllowed())})\n\trequestDurationByQueryHistogram.WithLabelValues(\n\t\topenfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tmethodName,\n\t\tutils.Bucketize(uint(resp.GetResolutionMetadata().DatastoreQueryCount), s.requestDurationByQueryHistogramBuckets),\n\t).Observe(float64(time.Since(start).Milliseconds()))\n\n\treturn res, nil\n}\n\nfunc (s *Server) Expand(ctx context.Context, req *openfgav1.ExpandRequest) (*openfgav1.ExpandResponse, error) {\n\ttk := req.GetTupleKey()\n\tctx, span := tracer.Start(ctx, \"Expand\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"object\", Value: attribute.StringValue(tk.GetObject())},\n\t\tattribute.KeyValue{Key: \"relation\", Value: attribute.StringValue(tk.GetRelation())},\n\t\tattribute.KeyValue{Key: \"user\", Value: attribute.StringValue(tk.GetUser())},\n\t))\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  \"Expand\",\n\t})\n\n\tstoreID := req.GetStoreId()\n\n\ttypesys, err := s.resolveTypesystem(ctx, storeID, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tq := commands.NewExpandQuery(s.datastore, s.logger)\n\treturn q.Execute(ctx, &openfgav1.ExpandRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: typesys.GetAuthorizationModelID(), // the resolved model id\n\t\tTupleKey:             tk,\n\t})\n}\n\nfunc (s *Server) ReadAuthorizationModel(ctx context.Context, req *openfgav1.ReadAuthorizationModelRequest) (*openfgav1.ReadAuthorizationModelResponse, error) {\n\tctx, span := tracer.Start(ctx, \"ReadAuthorizationModel\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: authorizationModelIDKey, Value: attribute.StringValue(req.GetId())},\n\t))\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  \"ReadAuthorizationModels\",\n\t})\n\n\tq := commands.NewReadAuthorizationModelQuery(s.datastore, s.logger)\n\treturn q.Execute(ctx, req)\n}\n\nfunc (s *Server) WriteAuthorizationModel(ctx context.Context, req *openfgav1.WriteAuthorizationModelRequest) (*openfgav1.WriteAuthorizationModelResponse, error) {\n\tctx, span := tracer.Start(ctx, \"WriteAuthorizationModel\")\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  \"WriteAuthorizationModel\",\n\t})\n\n\tc := commands.NewWriteAuthorizationModelCommand(s.datastore, s.logger)\n\tres, err := c.Execute(ctx, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.transport.SetHeader(ctx, httpmiddleware.XHttpCode, strconv.Itoa(http.StatusCreated))\n\n\treturn res, nil\n}\n\nfunc (s *Server) ReadAuthorizationModels(ctx context.Context, req *openfgav1.ReadAuthorizationModelsRequest) (*openfgav1.ReadAuthorizationModelsResponse, error) {\n\tctx, span := tracer.Start(ctx, \"ReadAuthorizationModels\")\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  \"ReadAuthorizationModels\",\n\t})\n\n\tc := commands.NewReadAuthorizationModelsQuery(s.datastore, s.logger, s.encoder)\n\treturn c.Execute(ctx, req)\n}\n\nfunc (s *Server) WriteAssertions(ctx context.Context, req *openfgav1.WriteAssertionsRequest) (*openfgav1.WriteAssertionsResponse, error) {\n\tctx, span := tracer.Start(ctx, \"WriteAssertions\")\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  \"WriteAssertions\",\n\t})\n\n\tstoreID := req.GetStoreId()\n\n\ttypesys, err := s.resolveTypesystem(ctx, storeID, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tc := commands.NewWriteAssertionsCommand(s.datastore, s.logger)\n\tres, err := c.Execute(ctx, &openfgav1.WriteAssertionsRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: typesys.GetAuthorizationModelID(), // the resolved model id\n\t\tAssertions:           req.GetAssertions(),\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.transport.SetHeader(ctx, httpmiddleware.XHttpCode, strconv.Itoa(http.StatusNoContent))\n\n\treturn res, nil\n}\n\nfunc (s *Server) ReadAssertions(ctx context.Context, req *openfgav1.ReadAssertionsRequest) (*openfgav1.ReadAssertionsResponse, error) {\n\tctx, span := tracer.Start(ctx, \"ReadAssertions\")\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  \"ReadAssertions\",\n\t})\n\n\ttypesys, err := s.resolveTypesystem(ctx, req.GetStoreId(), req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tq := commands.NewReadAssertionsQuery(s.datastore, s.logger)\n\treturn q.Execute(ctx, req.GetStoreId(), typesys.GetAuthorizationModelID())\n}\n\nfunc (s *Server) ReadChanges(ctx context.Context, req *openfgav1.ReadChangesRequest) (*openfgav1.ReadChangesResponse, error) {\n\tctx, span := tracer.Start(ctx, \"ReadChangesQuery\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"type\", Value: attribute.StringValue(req.GetType())},\n\t))\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  \"ReadChanges\",\n\t})\n\n\tq := commands.NewReadChangesQuery(s.datastore, s.logger, s.encoder, s.changelogHorizonOffset)\n\treturn q.Execute(ctx, req)\n}\n\nfunc (s *Server) CreateStore(ctx context.Context, req *openfgav1.CreateStoreRequest) (*openfgav1.CreateStoreResponse, error) {\n\tctx, span := tracer.Start(ctx, \"CreateStore\")\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  \"CreateStore\",\n\t})\n\n\tc := commands.NewCreateStoreCommand(s.datastore, s.logger)\n\tres, err := c.Execute(ctx, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.transport.SetHeader(ctx, httpmiddleware.XHttpCode, strconv.Itoa(http.StatusCreated))\n\n\treturn res, nil\n}\n\nfunc (s *Server) DeleteStore(ctx context.Context, req *openfgav1.DeleteStoreRequest) (*openfgav1.DeleteStoreResponse, error) {\n\tctx, span := tracer.Start(ctx, \"DeleteStore\")\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  \"DeleteStore\",\n\t})\n\n\tcmd := commands.NewDeleteStoreCommand(s.datastore, s.logger)\n\tres, err := cmd.Execute(ctx, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.transport.SetHeader(ctx, httpmiddleware.XHttpCode, strconv.Itoa(http.StatusNoContent))\n\n\treturn res, nil\n}\n\nfunc (s *Server) GetStore(ctx context.Context, req *openfgav1.GetStoreRequest) (*openfgav1.GetStoreResponse, error) {\n\tctx, span := tracer.Start(ctx, \"GetStore\")\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  \"GetStore\",\n\t})\n\n\tq := commands.NewGetStoreQuery(s.datastore, s.logger)\n\treturn q.Execute(ctx, req)\n}\n\nfunc (s *Server) ListStores(ctx context.Context, req *openfgav1.ListStoresRequest) (*openfgav1.ListStoresResponse, error) {\n\tctx, span := tracer.Start(ctx, \"ListStores\")\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  \"ListStores\",\n\t})\n\n\tq := commands.NewListStoresQuery(s.datastore, s.logger, s.encoder)\n\treturn q.Execute(ctx, req)\n}\n\n// IsReady reports whether this OpenFGA server instance is ready to accept\n// traffic.\nfunc (s *Server) IsReady(ctx context.Context) (bool, error) {\n\n\t// for now we only depend on the datastore being ready, but in the future\n\t// server readiness may also depend on other criteria in addition to the\n\t// datastore being ready.\n\treturn s.datastore.IsReady(ctx)\n}\n\n// resolveTypesystem resolves the underlying TypeSystem given the storeID and modelID and\n// it sets some response metadata based on the model resolution.\nfunc (s *Server) resolveTypesystem(ctx context.Context, storeID, modelID string) (*typesystem.TypeSystem, error) {\n\tctx, span := tracer.Start(ctx, \"resolveTypesystem\")\n\tdefer span.End()\n\n\ttypesys, err := s.typesystemResolver(ctx, storeID, modelID)\n\tif err != nil {\n\t\tif errors.Is(err, typesystem.ErrModelNotFound) {\n\t\t\tif modelID == \"\" {\n\t\t\t\treturn nil, serverErrors.LatestAuthorizationModelNotFound(storeID)\n\t\t\t}\n\n\t\t\treturn nil, serverErrors.AuthorizationModelNotFound(modelID)\n\t\t}\n\n\t\tif errors.Is(err, typesystem.ErrInvalidModel) {\n\t\t\treturn nil, serverErrors.ValidationError(err)\n\t\t}\n\n\t\treturn nil, serverErrors.HandleError(\"\", err)\n\t}\n\n\tresolvedModelID := typesys.GetAuthorizationModelID()\n\n\tspan.SetAttributes(attribute.KeyValue{Key: authorizationModelIDKey, Value: attribute.StringValue(resolvedModelID)})\n\tgrpc_ctxtags.Extract(ctx).Set(authorizationModelIDKey, resolvedModelID)\n\t_ = grpc.SetHeader(ctx, metadata.Pairs(AuthorizationModelIDHeader, resolvedModelID))\n\n\treturn typesys, nil\n}\n", "package server\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"path\"\n\t\"runtime\"\n\t\"testing\"\n\t\"time\"\n\n\tparser \"github.com/craigpastro/openfga-dsl-parser/v2\"\n\t\"github.com/golang/mock/gomock\"\n\t\"github.com/oklog/ulid/v2\"\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\tmockstorage \"github.com/openfga/openfga/internal/mocks\"\n\tserverErrors \"github.com/openfga/openfga/pkg/server/errors\"\n\t\"github.com/openfga/openfga/pkg/server/test\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/storage/memory\"\n\t\"github.com/openfga/openfga/pkg/storage/mysql\"\n\t\"github.com/openfga/openfga/pkg/storage/postgres\"\n\t\"github.com/openfga/openfga/pkg/storage/sqlcommon\"\n\tstoragefixtures \"github.com/openfga/openfga/pkg/testfixtures/storage\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"github.com/stretchr/testify/require\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n)\n\nfunc init() {\n\t_, filename, _, _ := runtime.Caller(0)\n\tdir := path.Join(path.Dir(filename), \"..\", \"..\")\n\terr := os.Chdir(dir)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TestServerPanicIfNoDatastore(t *testing.T) {\n\trequire.PanicsWithError(t, \"failed to construct the OpenFGA server: a datastore option must be provided\", func() {\n\t\t_ = MustNewServerWithOpts()\n\t})\n}\n\nfunc TestServerPanicIfEmptyRequestDurationDatastoreCountBuckets(t *testing.T) {\n\trequire.PanicsWithError(t, \"failed to construct the OpenFGA server: request duration datastore count buckets must not be empty\", func() {\n\t\tmockController := gomock.NewController(t)\n\t\tdefer mockController.Finish()\n\t\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\t\t_ = MustNewServerWithOpts(\n\t\t\tWithDatastore(mockDatastore),\n\t\t\tWithRequestDurationByQueryHistogramBuckets([]uint{}),\n\t\t)\n\t})\n}\n\nfunc TestServerWithPostgresDatastore(t *testing.T) {\n\tds := MustBootstrapDatastore(t, \"postgres\")\n\tdefer ds.Close()\n\n\ttest.RunAllTests(t, ds)\n}\n\nfunc TestServerWithPostgresDatastoreAndExplicitCredentials(t *testing.T) {\n\ttestDatastore := storagefixtures.RunDatastoreTestContainer(t, \"postgres\")\n\n\turi := testDatastore.GetConnectionURI(false)\n\tds, err := postgres.New(\n\t\turi,\n\t\tsqlcommon.NewConfig(\n\t\t\tsqlcommon.WithUsername(testDatastore.GetUsername()),\n\t\t\tsqlcommon.WithPassword(testDatastore.GetPassword()),\n\t\t),\n\t)\n\trequire.NoError(t, err)\n\tdefer ds.Close()\n\n\ttest.RunAllTests(t, ds)\n}\n\nfunc TestServerWithMemoryDatastore(t *testing.T) {\n\tds := MustBootstrapDatastore(t, \"memory\")\n\tdefer ds.Close()\n\n\ttest.RunAllTests(t, ds)\n}\n\nfunc TestServerWithMySQLDatastore(t *testing.T) {\n\tds := MustBootstrapDatastore(t, \"mysql\")\n\tdefer ds.Close()\n\n\ttest.RunAllTests(t, ds)\n}\n\nfunc TestServerWithMySQLDatastoreAndExplicitCredentials(t *testing.T) {\n\ttestDatastore := storagefixtures.RunDatastoreTestContainer(t, \"mysql\")\n\n\turi := testDatastore.GetConnectionURI(false)\n\tds, err := mysql.New(\n\t\turi,\n\t\tsqlcommon.NewConfig(\n\t\t\tsqlcommon.WithUsername(testDatastore.GetUsername()),\n\t\t\tsqlcommon.WithPassword(testDatastore.GetPassword()),\n\t\t),\n\t)\n\trequire.NoError(t, err)\n\tdefer ds.Close()\n\n\ttest.RunAllTests(t, ds)\n}\n\nfunc BenchmarkOpenFGAServer(b *testing.B) {\n\n\tb.Run(\"BenchmarkPostgresDatastore\", func(b *testing.B) {\n\t\ttestDatastore := storagefixtures.RunDatastoreTestContainer(b, \"postgres\")\n\n\t\turi := testDatastore.GetConnectionURI(true)\n\t\tds, err := postgres.New(uri, sqlcommon.NewConfig())\n\t\trequire.NoError(b, err)\n\t\tdefer ds.Close()\n\t\ttest.RunAllBenchmarks(b, ds)\n\t})\n\n\tb.Run(\"BenchmarkMemoryDatastore\", func(b *testing.B) {\n\t\tds := memory.New()\n\t\tdefer ds.Close()\n\t\ttest.RunAllBenchmarks(b, ds)\n\t})\n\n\tb.Run(\"BenchmarkMySQLDatastore\", func(b *testing.B) {\n\t\ttestDatastore := storagefixtures.RunDatastoreTestContainer(b, \"mysql\")\n\n\t\turi := testDatastore.GetConnectionURI(true)\n\t\tds, err := mysql.New(uri, sqlcommon.NewConfig())\n\t\trequire.NoError(b, err)\n\t\tdefer ds.Close()\n\t\ttest.RunAllBenchmarks(b, ds)\n\t})\n}\n\nfunc TestCheckDoesNotThrowBecauseDirectTupleWasFound(t *testing.T) {\n\tctx := context.Background()\n\tstoreID := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\ttypedefs := parser.MustParse(`\n\ttype user\n\n\ttype repo\n\t  relations\n\t    define reader: [user] as self\n\t`)\n\n\ttk := tuple.NewTupleKey(\"repo:openfga\", \"reader\", \"user:anne\")\n\ttuple := &openfgav1.Tuple{Key: tk}\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().\n\t\tReadAuthorizationModel(gomock.Any(), storeID, modelID).\n\t\tAnyTimes().\n\t\tReturn(&openfgav1.AuthorizationModel{\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\tTypeDefinitions: typedefs,\n\t\t}, nil)\n\n\t// it could happen that one of the following two mocks won't be necessary because the goroutine will be short-circuited\n\tmockDatastore.EXPECT().\n\t\tReadUserTuple(gomock.Any(), storeID, gomock.Any()).\n\t\tAnyTimes().\n\t\tReturn(tuple, nil)\n\n\tmockDatastore.EXPECT().\n\t\tReadUsersetTuples(gomock.Any(), storeID, gomock.Any()).\n\t\tAnyTimes().\n\t\tDoAndReturn(\n\t\t\tfunc(_ context.Context, _ string, _ storage.ReadUsersetTuplesFilter) (storage.TupleIterator, error) {\n\t\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t\t\treturn nil, errors.New(\"some error\")\n\t\t\t})\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(mockDatastore),\n\t)\n\n\tcheckResponse, err := s.Check(ctx, &openfgav1.CheckRequest{\n\t\tStoreId:              storeID,\n\t\tTupleKey:             tk,\n\t\tAuthorizationModelId: modelID,\n\t})\n\trequire.NoError(t, err)\n\trequire.Equal(t, true, checkResponse.Allowed)\n}\n\nfunc TestOperationsWithInvalidModel(t *testing.T) {\n\tctx := context.Background()\n\tstoreID := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\t// The model is invalid\n\ttypedefs := parser.MustParse(`\n\ttype user\n\n\ttype repo\n\t  relations\n        define admin: [user] as self\n\t    define r1: [user] as self and r2 and r3\n\t    define r2: [user] as self and r1 and r3\n\t    define r3: [user] as self and r1 and r2\n\t`)\n\n\ttk := tuple.NewTupleKey(\"repo:openfga\", \"r1\", \"user:anne\")\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().\n\t\tReadAuthorizationModel(gomock.Any(), storeID, modelID).\n\t\tAnyTimes().\n\t\tReturn(&openfgav1.AuthorizationModel{\n\t\t\tId:              modelID,\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\tTypeDefinitions: typedefs,\n\t\t}, nil)\n\n\t// the model is error and err should return\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(mockDatastore),\n\t)\n\n\t_, err := s.Check(ctx, &openfgav1.CheckRequest{\n\t\tStoreId:              storeID,\n\t\tTupleKey:             tk,\n\t\tAuthorizationModelId: modelID,\n\t})\n\trequire.Error(t, err)\n\te, ok := status.FromError(err)\n\trequire.True(t, ok)\n\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\n\t_, err = s.ListObjects(ctx, &openfgav1.ListObjectsRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: modelID,\n\t\tType:                 \"repo\",\n\t\tRelation:             \"r1\",\n\t\tUser:                 \"user:anne\",\n\t})\n\trequire.Error(t, err)\n\te, ok = status.FromError(err)\n\trequire.True(t, ok)\n\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\n\terr = s.StreamedListObjects(&openfgav1.StreamedListObjectsRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: modelID,\n\t\tType:                 \"repo\",\n\t\tRelation:             \"r1\",\n\t\tUser:                 \"user:anne\",\n\t}, NewMockStreamServer())\n\trequire.Error(t, err)\n\te, ok = status.FromError(err)\n\trequire.True(t, ok)\n\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\n\t_, err = s.Expand(ctx, &openfgav1.ExpandRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: modelID,\n\t\tTupleKey:             tk,\n\t})\n\trequire.Error(t, err)\n\te, ok = status.FromError(err)\n\trequire.True(t, ok)\n\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\n}\n\nfunc TestShortestPathToSolutionWins(t *testing.T) {\n\tctx := context.Background()\n\n\tstoreID := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\ttypedefs := parser.MustParse(`\n\ttype user\n\n\ttype repo\n\t  relations\n\t    define reader: [user:*] as self\n\t`)\n\n\ttk := tuple.NewTupleKey(\"repo:openfga\", \"reader\", \"user:*\")\n\ttuple := &openfgav1.Tuple{Key: tk}\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().\n\t\tReadAuthorizationModel(gomock.Any(), storeID, modelID).\n\t\tAnyTimes().\n\t\tReturn(&openfgav1.AuthorizationModel{\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\tTypeDefinitions: typedefs,\n\t\t}, nil)\n\n\t// it could happen that one of the following two mocks won't be necessary because the goroutine will be short-circuited\n\tmockDatastore.EXPECT().\n\t\tReadUserTuple(gomock.Any(), storeID, gomock.Any()).\n\t\tAnyTimes().\n\t\tDoAndReturn(\n\t\t\tfunc(ctx context.Context, _ string, _ *openfgav1.TupleKey) (storage.TupleIterator, error) {\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\treturn nil, ctx.Err()\n\t\t\t\tcase <-time.After(500 * time.Millisecond):\n\t\t\t\t\treturn nil, storage.ErrNotFound\n\t\t\t\t}\n\t\t\t})\n\n\tmockDatastore.EXPECT().\n\t\tReadUsersetTuples(gomock.Any(), storeID, gomock.Any()).\n\t\tAnyTimes().\n\t\tDoAndReturn(\n\t\t\tfunc(_ context.Context, _ string, _ storage.ReadUsersetTuplesFilter) (storage.TupleIterator, error) {\n\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\treturn storage.NewStaticTupleIterator([]*openfgav1.Tuple{tuple}), nil\n\t\t\t})\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(mockDatastore),\n\t)\n\n\tstart := time.Now()\n\tcheckResponse, err := s.Check(ctx, &openfgav1.CheckRequest{\n\t\tStoreId:              storeID,\n\t\tTupleKey:             tk,\n\t\tAuthorizationModelId: modelID,\n\t})\n\tend := time.Since(start)\n\n\t// we expect the Check call to be short-circuited after ReadUsersetTuples runs\n\trequire.Truef(t, end < 200*time.Millisecond, fmt.Sprintf(\"end was %s\", end))\n\trequire.NoError(t, err)\n\trequire.Equal(t, true, checkResponse.Allowed)\n}\n\nfunc TestCheckWithCachedResolution(t *testing.T) {\n\tctx := context.Background()\n\n\tstoreID := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\ttypedefs := parser.MustParse(`\n\ttype user\n\n\ttype repo\n\t  relations\n\t    define reader: [user] as self\n\t`)\n\n\ttk := tuple.NewTupleKey(\"repo:openfga\", \"reader\", \"user:mike\")\n\ttuple := &openfgav1.Tuple{Key: tk}\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().\n\t\tReadAuthorizationModel(gomock.Any(), storeID, modelID).\n\t\tAnyTimes().\n\t\tReturn(&openfgav1.AuthorizationModel{\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\tTypeDefinitions: typedefs,\n\t\t}, nil)\n\n\tmockDatastore.EXPECT().\n\t\tReadUserTuple(gomock.Any(), storeID, gomock.Any()).\n\t\tTimes(1).\n\t\tReturn(tuple, nil)\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(mockDatastore),\n\t\tWithCheckQueryCacheEnabled(true),\n\t\tWithCheckQueryCacheLimit(10),\n\t\tWithCheckQueryCacheTTL(1*time.Minute),\n\t\tWithExperimentals(ExperimentalCheckQueryCache),\n\t)\n\n\tcheckResponse, err := s.Check(ctx, &openfgav1.CheckRequest{\n\t\tStoreId:              storeID,\n\t\tTupleKey:             tk,\n\t\tAuthorizationModelId: modelID,\n\t})\n\n\trequire.NoError(t, err)\n\trequire.True(t, checkResponse.Allowed)\n\n\t// If we check for the same request, data should come from cache and number of ReadUserTuple should still be 1\n\tcheckResponse, err = s.Check(ctx, &openfgav1.CheckRequest{\n\t\tStoreId:              storeID,\n\t\tTupleKey:             tk,\n\t\tAuthorizationModelId: modelID,\n\t})\n\n\trequire.NoError(t, err)\n\trequire.True(t, checkResponse.Allowed)\n}\n\nfunc TestResolveAuthorizationModel(t *testing.T) {\n\tctx := context.Background()\n\n\tt.Run(\"no_latest_authorization_model_id_found\", func(t *testing.T) {\n\n\t\tstore := ulid.Make().String()\n\n\t\tmockController := gomock.NewController(t)\n\t\tdefer mockController.Finish()\n\n\t\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\t\tmockDatastore.EXPECT().FindLatestAuthorizationModelID(gomock.Any(), store).Return(\"\", storage.ErrNotFound)\n\n\t\ts := MustNewServerWithOpts(\n\t\t\tWithDatastore(mockDatastore),\n\t\t)\n\n\t\texpectedError := serverErrors.LatestAuthorizationModelNotFound(store)\n\n\t\t_, err := s.resolveTypesystem(ctx, store, \"\")\n\t\trequire.ErrorIs(t, err, expectedError)\n\t})\n\n\tt.Run(\"read_existing_authorization_model\", func(t *testing.T) {\n\t\tstore := ulid.Make().String()\n\t\tmodelID := ulid.Make().String()\n\n\t\tmockController := gomock.NewController(t)\n\t\tdefer mockController.Finish()\n\n\t\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\t\tmockDatastore.EXPECT().FindLatestAuthorizationModelID(gomock.Any(), store).Return(modelID, nil)\n\t\tmockDatastore.EXPECT().ReadAuthorizationModel(gomock.Any(), store, modelID).Return(\n\t\t\t&openfgav1.AuthorizationModel{\n\t\t\t\tId:            modelID,\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t},\n\t\t\tnil,\n\t\t)\n\n\t\ts := MustNewServerWithOpts(\n\t\t\tWithDatastore(mockDatastore),\n\t\t)\n\n\t\ttypesys, err := s.resolveTypesystem(ctx, store, \"\")\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, modelID, typesys.GetAuthorizationModelID())\n\t})\n\n\tt.Run(\"non-valid_modelID_returns_error\", func(t *testing.T) {\n\t\tstore := ulid.Make().String()\n\t\tmodelID := \"foo\"\n\t\twant := serverErrors.AuthorizationModelNotFound(modelID)\n\n\t\tmockController := gomock.NewController(t)\n\t\tdefer mockController.Finish()\n\n\t\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\t\ts := MustNewServerWithOpts(\n\t\t\tWithDatastore(mockDatastore),\n\t\t)\n\n\t\t_, err := s.resolveTypesystem(ctx, store, modelID)\n\t\trequire.Equal(t, want, err)\n\t})\n}\n\ntype mockStreamServer struct {\n\tgrpc.ServerStream\n}\n\nfunc NewMockStreamServer() *mockStreamServer {\n\treturn &mockStreamServer{}\n}\n\nfunc (m *mockStreamServer) Context() context.Context {\n\treturn context.Background()\n}\n\nfunc (m *mockStreamServer) Send(*openfgav1.StreamedListObjectsResponse) error {\n\treturn nil\n}\n\n// This runs ListObjects and StreamedListObjects many times over to ensure no race conditions (see https://github.com/openfga/openfga/pull/762)\nfunc BenchmarkListObjectsNoRaceCondition(b *testing.B) {\n\tctx := context.Background()\n\tstore := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\tmockController := gomock.NewController(b)\n\tdefer mockController.Finish()\n\n\ttypedefs := parser.MustParse(`\n\ttype user\n\n\ttype repo\n\t  relations\n\t    define allowed: [user] as self\n\t    define viewer: [user] as self and allowed\n    `)\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().ReadAuthorizationModel(gomock.Any(), store, modelID).AnyTimes().Return(&openfgav1.AuthorizationModel{\n\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\tTypeDefinitions: typedefs,\n\t}, nil)\n\tmockDatastore.EXPECT().ReadStartingWithUser(gomock.Any(), store, gomock.Any()).AnyTimes().Return(nil, errors.New(\"error reading from storage\"))\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(mockDatastore),\n\t)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, err := s.ListObjects(ctx, &openfgav1.ListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"repo\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:bob\",\n\t\t})\n\n\t\trequire.ErrorIs(b, err, serverErrors.NewInternalError(\"\", errors.New(\"error reading from storage\")))\n\n\t\terr = s.StreamedListObjects(&openfgav1.StreamedListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"repo\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:bob\",\n\t\t}, NewMockStreamServer())\n\n\t\trequire.ErrorIs(b, err, serverErrors.NewInternalError(\"\", errors.New(\"error reading from storage\")))\n\t}\n}\n\n// This test ensures that when the data storage fails, ListObjects v0 throws an error\nfunc TestListObjects_Unoptimized_UnhappyPaths(t *testing.T) {\n\tctx := context.Background()\n\tstore := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().ReadAuthorizationModel(gomock.Any(), store, modelID).AnyTimes().Return(&openfgav1.AuthorizationModel{\n\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\tTypeDefinitions: parser.MustParse(`\n\t\ttype user\n\n\t\ttype repo\n\t\t  relations\n\t\t    define allowed: [user] as self\n\t\t    define viewer: [user] as self and allowed\n\t\t`),\n\t}, nil)\n\tmockDatastore.EXPECT().ReadStartingWithUser(gomock.Any(), store, gomock.Any()).AnyTimes().Return(nil, errors.New(\"error reading from storage\"))\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(mockDatastore),\n\t)\n\n\tt.Run(\"error_listing_objects_from_storage_in_non-streaming_version\", func(t *testing.T) {\n\t\tres, err := s.ListObjects(ctx, &openfgav1.ListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"repo\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:bob\",\n\t\t})\n\n\t\trequire.Nil(t, res)\n\t\trequire.ErrorIs(t, err, serverErrors.NewInternalError(\"\", errors.New(\"error reading from storage\")))\n\t})\n\n\tt.Run(\"error_listing_objects_from_storage_in_streaming_version\", func(t *testing.T) {\n\t\terr := s.StreamedListObjects(&openfgav1.StreamedListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"repo\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:bob\",\n\t\t}, NewMockStreamServer())\n\n\t\trequire.ErrorIs(t, err, serverErrors.NewInternalError(\"\", errors.New(\"error reading from storage\")))\n\t})\n}\n\n// This test ensures that when the data storage fails for known eror, ListObjects v0 throws the correct error\nfunc TestListObjects_Unoptimized_UnhappyPaths_Known_Error(t *testing.T) {\n\tctx := context.Background()\n\tstore := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().ReadAuthorizationModel(gomock.Any(), store, modelID).AnyTimes().Return(&openfgav1.AuthorizationModel{\n\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\tTypeDefinitions: parser.MustParse(`\n\t\ttype user\n\n\t\ttype repo\n\t\t  relations\n\t\t    define allowed: [user] as self\n\t\t    define viewer: [user] as self and allowed\n\t\t`),\n\t}, nil)\n\tmockDatastore.EXPECT().ReadStartingWithUser(gomock.Any(), store, gomock.Any()).AnyTimes().Return(nil, serverErrors.AuthorizationModelResolutionTooComplex)\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(mockDatastore),\n\t)\n\n\tt.Run(\"error_listing_objects_from_storage_in_non-streaming_version\", func(t *testing.T) {\n\t\tres, err := s.ListObjects(ctx, &openfgav1.ListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"repo\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:bob\",\n\t\t})\n\n\t\trequire.Nil(t, res)\n\t\trequire.ErrorIs(t, err, serverErrors.AuthorizationModelResolutionTooComplex)\n\t})\n\n\tt.Run(\"error_listing_objects_from_storage_in_streaming_version\", func(t *testing.T) {\n\t\terr := s.StreamedListObjects(&openfgav1.StreamedListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"repo\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:bob\",\n\t\t}, NewMockStreamServer())\n\n\t\trequire.ErrorIs(t, err, serverErrors.AuthorizationModelResolutionTooComplex)\n\t})\n}\n\n// This test ensures that when the data storage fails, ListObjects v1 throws an error\nfunc TestListObjects_UnhappyPaths(t *testing.T) {\n\tctx := context.Background()\n\tstore := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().ReadAuthorizationModel(gomock.Any(), store, modelID).AnyTimes().Return(&openfgav1.AuthorizationModel{\n\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t{\n\t\t\t\tType: \"user\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tType: \"document\",\n\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\"viewer\": typesystem.This(),\n\t\t\t\t},\n\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\ttypesystem.DirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t\ttypesystem.WildcardRelationReference(\"user\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil)\n\tmockDatastore.EXPECT().ReadStartingWithUser(gomock.Any(), store, storage.ReadStartingWithUserFilter{\n\t\tObjectType: \"document\",\n\t\tRelation:   \"viewer\",\n\t\tUserFilter: []*openfgav1.ObjectRelation{\n\t\t\t{Object: \"user:*\"},\n\t\t\t{Object: \"user:bob\"},\n\t\t}}).AnyTimes().Return(nil, errors.New(\"error reading from storage\"))\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(mockDatastore),\n\t)\n\n\tt.Run(\"error_listing_objects_from_storage_in_non-streaming_version\", func(t *testing.T) {\n\t\tres, err := s.ListObjects(ctx, &openfgav1.ListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"document\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:bob\",\n\t\t})\n\n\t\trequire.Nil(t, res)\n\t\trequire.ErrorIs(t, err, serverErrors.NewInternalError(\"\", errors.New(\"error reading from storage\")))\n\t})\n\n\tt.Run(\"error_listing_objects_from_storage_in_streaming_version\", func(t *testing.T) {\n\t\terr := s.StreamedListObjects(&openfgav1.StreamedListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"document\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:bob\",\n\t\t}, NewMockStreamServer())\n\n\t\trequire.ErrorIs(t, err, serverErrors.NewInternalError(\"\", errors.New(\"error reading from storage\")))\n\t})\n}\n\n// This test ensures that when the data storage fails with known errors, ListObjects v1 throws an error\nfunc TestListObjects_UnhappyPaths_Known_Error(t *testing.T) {\n\tctx := context.Background()\n\tstore := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().ReadAuthorizationModel(gomock.Any(), store, modelID).AnyTimes().Return(&openfgav1.AuthorizationModel{\n\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t{\n\t\t\t\tType: \"user\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tType: \"document\",\n\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\"viewer\": typesystem.This(),\n\t\t\t\t},\n\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\ttypesystem.DirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t\ttypesystem.WildcardRelationReference(\"user\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil)\n\tmockDatastore.EXPECT().ReadStartingWithUser(gomock.Any(), store, storage.ReadStartingWithUserFilter{\n\t\tObjectType: \"document\",\n\t\tRelation:   \"viewer\",\n\t\tUserFilter: []*openfgav1.ObjectRelation{\n\t\t\t{Object: \"user:*\"},\n\t\t\t{Object: \"user:bob\"},\n\t\t}}).AnyTimes().Return(nil, serverErrors.AuthorizationModelResolutionTooComplex)\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(mockDatastore),\n\t)\n\n\tt.Run(\"error_listing_objects_from_storage_in_non-streaming_version\", func(t *testing.T) {\n\t\tres, err := s.ListObjects(ctx, &openfgav1.ListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"document\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:bob\",\n\t\t})\n\n\t\trequire.Nil(t, res)\n\t\trequire.ErrorIs(t, err, serverErrors.AuthorizationModelResolutionTooComplex)\n\t})\n\n\tt.Run(\"error_listing_objects_from_storage_in_streaming_version\", func(t *testing.T) {\n\t\terr := s.StreamedListObjects(&openfgav1.StreamedListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"document\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:bob\",\n\t\t}, NewMockStreamServer())\n\n\t\trequire.ErrorIs(t, err, serverErrors.AuthorizationModelResolutionTooComplex)\n\t})\n}\n\nfunc TestAuthorizationModelInvalidSchemaVersion(t *testing.T) {\n\tctx := context.Background()\n\tstore := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().ReadAuthorizationModel(gomock.Any(), store, modelID).AnyTimes().Return(&openfgav1.AuthorizationModel{\n\t\tSchemaVersion: typesystem.SchemaVersion1_0,\n\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t{\n\t\t\t\tType: \"user\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tType: \"team\",\n\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\"member\": typesystem.This(),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil)\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(mockDatastore),\n\t)\n\n\tt.Run(\"invalid_schema_error_in_check\", func(t *testing.T) {\n\t\t_, err := s.Check(ctx, &openfgav1.CheckRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tTupleKey: tuple.NewTupleKey(\n\t\t\t\t\"team:abc\",\n\t\t\t\t\"member\",\n\t\t\t\t\"user:anne\"),\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\t})\n\n\tt.Run(\"invalid_schema_error_in_list_objects\", func(t *testing.T) {\n\t\t_, err := s.ListObjects(ctx, &openfgav1.ListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"team\",\n\t\t\tRelation:             \"member\",\n\t\t\tUser:                 \"user:anne\",\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\t})\n\n\tt.Run(\"invalid_schema_error_in_streamed_list_objects\", func(t *testing.T) {\n\t\terr := s.StreamedListObjects(&openfgav1.StreamedListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"team\",\n\t\t\tRelation:             \"member\",\n\t\t\tUser:                 \"user:anne\",\n\t\t}, NewMockStreamServer())\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\t})\n\n\tt.Run(\"invalid_schema_error_in_expand\", func(t *testing.T) {\n\t\t_, err := s.Expand(ctx, &openfgav1.ExpandRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga\",\n\t\t\t\t\"reader\",\n\t\t\t\t\"user:anne\"),\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\t})\n\n\tt.Run(\"invalid_schema_error_in_write\", func(t *testing.T) {\n\t\t_, err := s.Write(ctx, &openfgav1.WriteRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tWrites: &openfgav1.TupleKeys{TupleKeys: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/openfga\",\n\t\t\t\t\t\"reader\",\n\t\t\t\t\t\"user:anne\"),\n\t\t\t}},\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\t})\n\n\tt.Run(\"invalid_schema_error_in_write_model\", func(t *testing.T) {\n\t\tmockDatastore.EXPECT().MaxTypesPerAuthorizationModel().Return(100)\n\n\t\t_, err := s.WriteAuthorizationModel(ctx, &openfgav1.WriteAuthorizationModelRequest{\n\t\t\tStoreId:         store,\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_0,\n\t\t\tTypeDefinitions: parser.MustParse(`type repo`),\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_invalid_authorization_model), e.Code(), err)\n\t})\n\n\tt.Run(\"invalid_schema_error_in_write_assertion\", func(t *testing.T) {\n\t\t_, err := s.WriteAssertions(ctx, &openfgav1.WriteAssertionsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tAssertions: []*openfgav1.Assertion{{\n\t\t\t\tTupleKey:    tuple.NewTupleKey(\"repo:test\", \"reader\", \"user:elbuo\"),\n\t\t\t\tExpectation: false,\n\t\t\t}},\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\t})\n}\n\nfunc TestDefaultMaxConcurrentReadSettings(t *testing.T) {\n\trequire.EqualValues(t, math.MaxUint32, defaultMaxConcurrentReadsForCheck)\n\trequire.EqualValues(t, math.MaxUint32, defaultMaxConcurrentReadsForListObjects)\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(memory.New()),\n\t)\n\trequire.EqualValues(t, math.MaxUint32, s.maxConcurrentReadsForCheck)\n\trequire.EqualValues(t, math.MaxUint32, s.maxConcurrentReadsForListObjects)\n}\n\nfunc MustBootstrapDatastore(t testing.TB, engine string) storage.OpenFGADatastore {\n\ttestDatastore := storagefixtures.RunDatastoreTestContainer(t, engine)\n\n\turi := testDatastore.GetConnectionURI(true)\n\n\tvar ds storage.OpenFGADatastore\n\tvar err error\n\n\tswitch engine {\n\tcase \"memory\":\n\t\tds = memory.New()\n\tcase \"postgres\":\n\t\tds, err = postgres.New(uri, sqlcommon.NewConfig())\n\tcase \"mysql\":\n\t\tds, err = mysql.New(uri, sqlcommon.NewConfig())\n\tdefault:\n\t\tt.Fatalf(\"'%s' is not a supported datastore engine\", engine)\n\t}\n\trequire.NoError(t, err)\n\n\treturn ds\n}\n", "package test\n\nimport (\n\t\"context\"\n\t\"testing\"\n\t\"time\"\n\n\tparser \"github.com/craigpastro/openfga-dsl-parser/v2\"\n\t\"github.com/oklog/ulid/v2\"\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\t\"github.com/openfga/openfga/pkg/server/commands/reverseexpand\"\n\tserverErrors \"github.com/openfga/openfga/pkg/server/errors\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestReverseExpand(t *testing.T, ds storage.OpenFGADatastore) {\n\n\ttests := []struct {\n\t\tname                 string\n\t\tmodel                string\n\t\ttuples               []*openfgav1.TupleKey\n\t\trequest              *reverseexpand.ReverseExpandRequest\n\t\tresolveNodeLimit     uint32\n\t\texpectedResult       []*reverseexpand.ReverseExpandResult\n\t\texpectedError        error\n\t\texpectedDSQueryCount uint32\n\t}{\n\t\t{\n\t\t\tname: \"basic_intersection\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgav1.TupleKey{},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define allowed: [user] as self\n\t\t\t\t    define viewer: [user] as self and allowed\n\t\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"document:3\", \"allowed\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.RequiresFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:2\",\n\t\t\t\t\tResultStatus: reverseexpand.RequiresFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"indirect_intersection\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgav1.TupleKey{},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t\tdefine writer: [user] as self\n\t\t\t\tdefine editor: [user] as self\n\t\t\t\tdefine viewer as writer and editor\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t\tdefine parent: [folder] as self\n\t\t\t\tdefine viewer as viewer from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"folder:X\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:X\", \"writer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:X\", \"editor\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.RequiresFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\n\t\t{\n\t\t\tname: \"resolve_direct_relationships_with_tuples_and_contextual_tuples\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgav1.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"document:doc2\", \"viewer\", \"user:bob\"),\n\t\t\t\t\ttuple.NewTupleKey(\"document:doc3\", \"viewer\", \"user:jon\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"viewer\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc3\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"direct_relations_involving_relationships_with_users_and_usersets\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user, group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc2\", \"viewer\", \"user:bob\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc3\", \"viewer\", \"group:openfga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:openfga\", \"member\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc3\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"success_with_direct_relationships_and_computed_usersets\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define owner: [user, group#member] as self\n\t\t\t    define viewer as owner\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"owner\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc2\", \"owner\", \"user:bob\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc3\", \"owner\", \"group:openfga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:openfga\", \"member\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc3\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"success_with_many_tuples\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgav1.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"folder:folder5\", \"parent\", \"folder:folder4\"),\n\t\t\t\t\ttuple.NewTupleKey(\"folder:folder6\", \"viewer\", \"user:bob\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user, group#member] as self\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer: [user, group#member] as self or viewer from parent\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer as viewer from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"folder:folder1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder2\", \"parent\", \"folder:folder1\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder3\", \"parent\", \"folder:folder2\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder4\", \"viewer\", \"group:eng#member\"),\n\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"parent\", \"folder:folder3\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc2\", \"parent\", \"folder:folder5\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc3\", \"parent\", \"folder:folder6\"),\n\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"group:openfga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:openfga\", \"member\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 16,\n\t\t},\n\t\t{\n\t\t\tname: \"resolve_objects_involved_in_recursive_hierarchy\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"folder\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer: [user] as self or viewer from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"folder:folder1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder2\", \"parent\", \"folder:folder1\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder3\", \"parent\", \"folder:folder2\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"folder:folder1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"folder:folder2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"folder:folder3\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"resolution_depth_exceeded_failure\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"folder\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tresolveNodeLimit: 2,\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer: [user] as self or viewer from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"folder:folder1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder2\", \"parent\", \"folder:folder1\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder3\", \"parent\", \"folder:folder2\"),\n\t\t\t},\n\t\t\texpectedError:        serverErrors.AuthorizationModelResolutionTooComplex,\n\t\t\texpectedDSQueryCount: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_to_a_userset\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"group\",\n\t\t\t\tRelation:   \"member\",\n\t\t\t\tUser: &reverseexpand.UserRefObjectRelation{\n\t\t\t\t\tObjectRelation: &openfgav1.ObjectRelation{\n\t\t\t\t\t\tObject:   \"group:iam\",\n\t\t\t\t\t\tRelation: \"member\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user, group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"group:opensource\", \"member\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"group:iam#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:iam\", \"member\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"group:opensource\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"group:eng\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_to_a_userset_self_referencing\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"group\",\n\t\t\t\tRelation:   \"member\",\n\t\t\t\tUser: &reverseexpand.UserRefObjectRelation{\n\t\t\t\t\tObjectRelation: &openfgav1.ObjectRelation{\n\t\t\t\t\t\tObject:   \"group:iam\",\n\t\t\t\t\t\tRelation: \"member\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"group:iam\", \"member\", \"group:iam#member\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"group:iam\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_through_a_computed_userset_1\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define owner: [user] as self\n\t\t\t    define editor as owner\n\t\t\t    define viewer: [document#editor] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"document:1#editor\"),\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"owner\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_through_a_computed_userset_2\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define manager: [user] as self\n\t\t\t    define member as manager\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"manager\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_through_a_computed_userset_3\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"trial\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"fede\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype team\n\t\t\t  relations\n\t\t\t    define admin: [user] as self\n\t\t\t    define member as admin\n\n\t\t\ttype trial\n\t\t\t  relations\n\t\t\t    define editor: [team#member] as self\n\t\t\t    define viewer as editor\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"trial:1\", \"editor\", \"team:devs#member\"),\n\t\t\t\ttuple.NewTupleKey(\"team:devs\", \"admin\", \"user:fede\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"trial:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_indirectly_through_a_ttu\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"view\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"organization\",\n\t\t\t\t\t\tId:   \"2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype organization\n\t\t\t  relations\n\t\t\t    define viewer: [organization] as self\n\t\t\t    define can_view as viewer\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [organization] as self\n\t\t\t    define view as can_view from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"organization:1\"),\n\t\t\t\ttuple.NewTupleKey(\"organization:1\", \"viewer\", \"organization:2\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"directly_related_typed_wildcard\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser:       &reverseexpand.UserRefTypedWildcard{Type: \"user\"},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user, user:*] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"document:3\", \"viewer\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"indirectly_related_typed_wildcard\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser:       &reverseexpand.UserRefTypedWildcard{Type: \"user\"},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user:*] as self\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"group:fga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"user:*\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"relationship_through_multiple_indirections\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype team\n\t\t\t  relations\n\t\t\t    define member: [user] as self\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [team#member] as self\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"team:tigers\", \"member\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"team:tigers#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"typed_wildcard_relationship_through_multiple_indirections\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [team#member] as self\n\t\t\ttype team\n\t\t\t  relations\n\t\t\t    define member: [user:*] as self\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"team:tigers\", \"member\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"team:tigers#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"simple_typed_wildcard_and_direct_relation\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{Type: \"user\", Id: \"jon\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user, user:*] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"simple_typed_wildcard_and_indirect_relation\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user, user:*] as self\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"group:fga\", \"member\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"group:fga#member\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"with_public_user_access_1\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"*\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user:*] as self\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"group:other\", \"member\", \"employee:*\"), // assume this comes from a prior model\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"group:fga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:3\", \"viewer\", \"group:other#member\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"with_public_user_access_2\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"resource\",\n\t\t\t\tRelation:   \"reader\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"bev\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user] as self\n\t\t\ttype resource\n\t\t\t  relations\n\t\t\t    define reader: [user, user:*, group#member] as self or writer\n\t\t\t\tdefine writer: [user, user:*, group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"resource:x\", \"writer\", \"user:*\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"resource:x\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"simple_typed_wildcard_with_contextual_tuples_1\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{Type: \"user\", Id: \"jon\"},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgav1.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"user:*\"),\n\t\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"user:jon\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user, user:*] as self\n\t\t\t`,\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"simple_typed_wildcard_with_contextual_tuples_2\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser:       &reverseexpand.UserRefTypedWildcard{Type: \"user\"},\n\t\t\t\tContextualTuples: []*openfgav1.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"employee:*\"),\n\t\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"user:*\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype employee\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user:*] as self\n\t\t\t`,\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"simple_typed_wildcard_with_contextual_tuples_3\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObjectRelation{\n\t\t\t\t\tObjectRelation: &openfgav1.ObjectRelation{\n\t\t\t\t\t\tObject:   \"group:eng\",\n\t\t\t\t\t\tRelation: \"member\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgav1.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_ttu_relationship\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define viewer: [user, user:*] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer as viewer from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"folder:1\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"parent\", \"folder:2\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:2\", \"viewer\", \"user:*\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_ttu_relationship_without_wildcard_connectivity\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype employee\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define viewer: [user, employee:*] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer as viewer from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"folder:1\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"parent\", \"folder:2\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:2\", \"viewer\", \"user:*\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_ttu_relationship_through_indirection_1\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user:*] as self\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer as viewer from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"folder:1\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"user:*\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_ttu_relationship_through_indirection_2\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"resource\",\n\t\t\t\tRelation:   \"writer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"anne\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype org\n\t\t\t  relations\n\t\t\t    define dept: [group] as self\n\t\t\t    define dept_member as member from dept\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user] as self\n\n\t\t\ttype resource\n\t\t\t  relations\n\t\t\t    define writer: [org#dept_member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"resource:eng_handbook\", \"writer\", \"org:eng#dept_member\"),\n\t\t\t\ttuple.NewTupleKey(\"org:eng\", \"dept\", \"group:fga\"),\n\t\t\t\ttuple.NewTupleKey(\"group:fga\", \"member\", \"user:anne\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"resource:eng_handbook\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_ttu_relationship_through_indirection_3\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"resource\",\n\t\t\t\tRelation:   \"reader\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"anne\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype org\n\t\t\t  relations\n\t\t\t    define dept: [group] as self\n\t\t\t    define dept_member as member from dept\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user] as self\n\n\t\t\ttype resource\n\t\t\t  relations\n\t\t\t    define writer: [org#dept_member] as self\n\t\t\t    define reader: [org#dept_member] as self or writer\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"resource:eng_handbook\", \"writer\", \"org:eng#dept_member\"),\n\t\t\t\ttuple.NewTupleKey(\"org:eng\", \"dept\", \"group:fga\"),\n\t\t\t\ttuple.NewTupleKey(\"group:fga\", \"member\", \"user:anne\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"resource:eng_handbook\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"cyclical_tupleset_relation_terminates\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"node\",\n\t\t\t\tRelation:   \"editor\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"wonder\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype node\n\t\t\t  relations\n\t\t\t    define parent: [node] as self\n\t\t\t    define editor: [user] as self or editor from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"node:abc\", \"editor\", \"user:wonder\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"node:abc\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"does_not_send_duplicate_even_though_there_are_two_paths_to_same_solution\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t\tdefine member: [user] as self\n\t\t\t\tdefine maintainer: [user] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t\tdefine viewer: [group#member,group#maintainer] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:example1#maintainer\"),\n\t\t\t\ttuple.NewTupleKey(\"group:example1\", \"maintainer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"group:example1\", \"member\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 4,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\trequire := require.New(t)\n\n\t\t\tctx := context.Background()\n\t\t\tstore := ulid.Make().String()\n\t\t\ttest.request.StoreID = store\n\n\t\t\tmodel := &openfgav1.AuthorizationModel{\n\t\t\t\tId:              ulid.Make().String(),\n\t\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: parser.MustParse(test.model),\n\t\t\t}\n\t\t\terr := ds.WriteAuthorizationModel(ctx, store, model)\n\t\t\trequire.NoError(err)\n\n\t\t\terr = ds.Write(ctx, store, nil, test.tuples)\n\t\t\trequire.NoError(err)\n\n\t\t\tvar opts []reverseexpand.ReverseExpandQueryOption\n\n\t\t\tif test.resolveNodeLimit != 0 {\n\t\t\t\topts = append(opts, reverseexpand.WithResolveNodeLimit(test.resolveNodeLimit))\n\t\t\t}\n\n\t\t\treverseExpandQuery := reverseexpand.NewReverseExpandQuery(ds, typesystem.New(model), opts...)\n\n\t\t\tresultChan := make(chan *reverseexpand.ReverseExpandResult, 100)\n\t\t\tdone := make(chan struct{})\n\n\t\t\tvar results []*reverseexpand.ReverseExpandResult\n\t\t\tgo func() {\n\t\t\t\tfor result := range resultChan {\n\t\t\t\t\tresults = append(results, result)\n\t\t\t\t}\n\n\t\t\t\tdone <- struct{}{}\n\t\t\t}()\n\n\t\t\ttimeoutCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\t\t\tdefer cancel()\n\n\t\t\tresolutionMetadata := reverseexpand.NewResolutionMetadata()\n\n\t\t\tgo func() {\n\t\t\t\terr = reverseExpandQuery.Execute(timeoutCtx, test.request, resultChan, resolutionMetadata)\n\t\t\t\trequire.ErrorIs(err, test.expectedError)\n\t\t\t\tclose(resultChan)\n\t\t\t}()\n\n\t\t\tselect {\n\t\t\tcase <-timeoutCtx.Done():\n\t\t\t\trequire.FailNow(\"timed out waiting for response\")\n\t\t\tcase <-done:\n\t\t\t}\n\n\t\t\tif test.expectedError == nil {\n\t\t\t\trequire.ElementsMatch(test.expectedResult, results)\n\t\t\t\trequire.Equal(test.expectedDSQueryCount, *resolutionMetadata.QueryCount)\n\t\t\t}\n\t\t})\n\t}\n}\n", "package test\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"testing\"\n\n\tparser \"github.com/craigpastro/openfga-dsl-parser/v2\"\n\t\"github.com/oklog/ulid/v2\"\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\t\"github.com/openfga/openfga/pkg/server/commands\"\n\tserverErrors \"github.com/openfga/openfga/pkg/server/errors\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc WriteAuthorizationModelTest(t *testing.T, datastore storage.OpenFGADatastore) {\n\tstoreID := ulid.Make().String()\n\n\titems := make([]*openfgav1.TypeDefinition, datastore.MaxTypesPerAuthorizationModel()+1)\n\titems[0] = &openfgav1.TypeDefinition{\n\t\tType: \"user\",\n\t}\n\tfor i := 1; i < datastore.MaxTypesPerAuthorizationModel(); i++ {\n\t\titems[i] = &openfgav1.TypeDefinition{\n\t\t\tType: fmt.Sprintf(\"type%v\", i),\n\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\"admin\": {Userset: &openfgav1.Userset_This{}},\n\t\t\t},\n\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\ttypesystem.DirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t}\n\n\tvar tests = []struct {\n\t\tname          string\n\t\trequest       *openfgav1.WriteAuthorizationModelRequest\n\t\tallowSchema10 bool\n\t\terr           error\n\t}{\n\t\t{\n\t\t\tname: \"fails_if_too_many_types\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId:         storeID,\n\t\t\t\tTypeDefinitions: items,\n\t\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\t},\n\t\t\tallowSchema10: false,\n\t\t\terr:           serverErrors.ExceededEntityLimit(\"type definitions in an authorization model\", datastore.MaxTypesPerAuthorizationModel()),\n\t\t},\n\t\t{\n\t\t\tname: \"fails_if_a_relation_is_not_defined\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"owner\": {},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t},\n\t\t\tallowSchema10: false,\n\t\t\terr:           serverErrors.InvalidAuthorizationModelInput(&typesystem.InvalidRelationError{ObjectType: \"repo\", Relation: \"owner\", Cause: typesystem.ErrInvalidUsersetRewrite}),\n\t\t},\n\t\t{\n\t\t\tname: \"Fails_if_type_info_metadata_is_omitted_in_1.1_model\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId:       storeID,\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tallowSchema10: false,\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(\n\t\t\t\terrors.New(\"the assignable relation 'reader' in object type 'document' must contain at least one relation type\"),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname: \"Fails_if_writing_1_0_model_because_it_will_be_interpreted_as_1_1\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tallowSchema10: true,\n\t\t\terr:           serverErrors.InvalidAuthorizationModelInput(typesystem.AssignableRelationError(\"document\", \"reader\")),\n\t\t},\n\t\t{\n\t\t\tname: \"Works_if_no_schema_version\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"viewer\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\ttypesystem.WildcardRelationReference(\"user\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"self_referencing_type_restriction_with_entrypoint\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define editor: [user] as self\n\t\t\t\t    define viewer: [document#viewer] as self or editor\n\t\t\t\t`),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"self_referencing_type_restriction_without_entrypoint_1\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define viewer: [document#viewer] as self\n\t\t\t\t`),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(&typesystem.InvalidRelationError{\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tCause:      typesystem.ErrNoEntrypoints},\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname: \"self_referencing_type_restriction_without_entrypoint_2\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define editor: [user] as self\n\t\t\t\t    define viewer: [document#viewer] as self and editor\n\t\t\t\t`),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(&typesystem.InvalidRelationError{\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tCause:      typesystem.ErrNoEntrypoints,\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tname: \"self_referencing_type_restriction_without_entrypoint_3\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define restricted: [user] as self\n\t\t\t\t    define viewer: [document#viewer] as self but not restricted\n\t\t\t\t`),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(&typesystem.InvalidRelationError{\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tCause:      typesystem.ErrNoEntrypoints,\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tname: \"rewritten_relation_in_intersection_unresolvable\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define admin: [user] as self\n\t\t\t\t    define action1 as admin and action2 and action3\n\t\t\t\t    define action2 as admin and action1 and action3\n\t\t\t\t    define action3 as admin and action1 and action2\n\t\t\t\t`),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(&typesystem.InvalidRelationError{\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"action1\",\n\t\t\t\tCause:      typesystem.ErrNoEntryPointsLoop,\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tname: \"direct_relationship_with_entrypoint\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define viewer: [user] as self\n\t\t\t\t`),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"computed_relationship_with_entrypoint\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define editor: [user] as self\n\t\t\t\t    define viewer as editor\n\t\t\t\t`),\n\t\t\t},\n\t\t},\n\n\t\t{\n\t\t\tname: \"rewritten_relation_in_exclusion_unresolvable\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define admin: [user] as self\n\t\t\t\t    define action1 as admin but not action2\n\t\t\t\t    define action2 as admin but not action3\n\t\t\t\t    define action3 as admin but not action1\n\t\t\t\t`),\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(&typesystem.InvalidRelationError{\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"action1\",\n\t\t\t\tCause:      typesystem.ErrNoEntryPointsLoop,\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tname: \"no_entrypoint_3a\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define viewer: [document#viewer] as self and editor\n\t\t\t\t    define editor: [user] as self\n\t\t\t\t`),\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(&typesystem.InvalidRelationError{\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tCause:      typesystem.ErrNoEntrypoints,\n\t\t\t}),\n\t\t},\n\n\t\t{\n\t\t\tname: \"no_entrypoint_3b\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define viewer: [document#viewer] as self but not editor\n\t\t\t\t    define editor: [user] as self\n\t\t\t\t`),\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(&typesystem.InvalidRelationError{\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tCause:      typesystem.ErrNoEntrypoints,\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tname: \"no_entrypoint_4\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype folder\n\t\t\t\t  relations\n\t\t\t\t    define parent: [document] as self\n\t\t\t\t    define viewer as editor from parent\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define parent: [folder] as self\n\t\t\t\t    define editor as viewer\n\t\t\t\t    define viewer as editor from parent\n\t\t\t\t`),\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(&typesystem.InvalidRelationError{\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"editor\",\n\t\t\t\tCause:      typesystem.ErrNoEntrypoints,\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tname: \"self_referencing_type_restriction_with_entrypoint_1\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define restricted: [user] as self\n\t\t\t\t    define editor: [user] as self\n\t\t\t\t    define viewer: [document#viewer] as self or editor\n\t\t\t\t    define can_view as viewer but not restricted\n\t\t\t\t    define can_view_actual as can_view\n\t\t\t\t`),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"self_referencing_type_restriction_with_entrypoint_2\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define editor: [user] as self\n\t\t\t\t    define viewer: [document#viewer] as self or editor\n\t\t\t\t`),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"relation_with_union_of_ttu_rewrites\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\t\t\t\ttype org\n\t\t\t\t  relations\n\t\t\t\t    define admin: [user] as self\n\t\t\t\t    define member: [user] as self\n\t\t\t\ttype group\n\t\t\t\t  relations\n\t\t\t\t    define member: [user] as self\n\t\t\t\ttype feature\n\t\t\t\t  relations\n\t\t\t\t    define accessible as admin from subscriber_org or member from subscriber_group\n\t\t\t\t    define subscriber_group: [group] as self\n\t\t\t\t    define subscriber_org: [org] as self\n\t\t\t\t`),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"type_name_is_empty_string\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(\n\t\t\t\tfmt.Errorf(\"the type name of a type definition cannot be an empty string\"),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname: \"relation_name_is_empty_string\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"other\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(\n\t\t\t\tfmt.Errorf(\"type 'user' defines a relation with an empty string for a name\"),\n\t\t\t),\n\t\t},\n\t}\n\n\tctx := context.Background()\n\tlogger := logger.NewNoopLogger()\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tcmd := commands.NewWriteAuthorizationModelCommand(datastore, logger)\n\t\t\tresp, err := cmd.Execute(ctx, test.request)\n\t\t\trequire.ErrorIs(t, err, test.err)\n\n\t\t\tif err == nil {\n\t\t\t\t_, err = ulid.Parse(resp.AuthorizationModelId)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n", "// Package typesystem contains code to manipulate authorization models\npackage typesystem\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"maps\"\n\t\"reflect\"\n\t\"sort\"\n\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"go.opentelemetry.io/otel\"\n)\n\nvar tracer = otel.Tracer(\"openfga/pkg/typesystem\")\n\ntype ctxKey string\n\nconst (\n\tSchemaVersion1_0 string = \"1.0\"\n\tSchemaVersion1_1 string = \"1.1\"\n\n\ttypesystemCtxKey ctxKey = \"typesystem-context-key\"\n)\n\nvar (\n\tErrModelNotFound         = errors.New(\"authorization model not found\")\n\tErrDuplicateTypes        = errors.New(\"an authorization model cannot contain duplicate types\")\n\tErrInvalidSchemaVersion  = errors.New(\"invalid schema version\")\n\tErrInvalidModel          = errors.New(\"invalid authorization model encountered\")\n\tErrRelationUndefined     = errors.New(\"undefined relation\")\n\tErrObjectTypeUndefined   = errors.New(\"undefined object type\")\n\tErrInvalidUsersetRewrite = errors.New(\"invalid userset rewrite definition\")\n\tErrReservedKeywords      = errors.New(\"self and this are reserved keywords\")\n\tErrCycle                 = errors.New(\"an authorization model cannot contain a cycle\")\n\tErrNoEntrypoints         = errors.New(\"no entrypoints defined\")\n\tErrNoEntryPointsLoop     = errors.New(\"potential loop\")\n)\n\nfunc IsSchemaVersionSupported(version string) bool {\n\tswitch version {\n\tcase SchemaVersion1_1:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// ContextWithTypesystem attaches the provided TypeSystem to the parent context.\nfunc ContextWithTypesystem(parent context.Context, typesys *TypeSystem) context.Context {\n\treturn context.WithValue(parent, typesystemCtxKey, typesys)\n}\n\n// TypesystemFromContext returns the TypeSystem from the provided context (if any).\nfunc TypesystemFromContext(ctx context.Context) (*TypeSystem, bool) {\n\ttypesys, ok := ctx.Value(typesystemCtxKey).(*TypeSystem)\n\treturn typesys, ok\n}\n\nfunc DirectRelationReference(objectType, relation string) *openfgav1.RelationReference {\n\trelationReference := &openfgav1.RelationReference{\n\t\tType: objectType,\n\t}\n\tif relation != \"\" {\n\t\trelationReference.RelationOrWildcard = &openfgav1.RelationReference_Relation{\n\t\t\tRelation: relation,\n\t\t}\n\t}\n\n\treturn relationReference\n}\n\nfunc WildcardRelationReference(objectType string) *openfgav1.RelationReference {\n\treturn &openfgav1.RelationReference{\n\t\tType: objectType,\n\t\tRelationOrWildcard: &openfgav1.RelationReference_Wildcard{\n\t\t\tWildcard: &openfgav1.Wildcard{},\n\t\t},\n\t}\n}\n\nfunc This() *openfgav1.Userset {\n\treturn &openfgav1.Userset{\n\t\tUserset: &openfgav1.Userset_This{},\n\t}\n}\n\nfunc ComputedUserset(relation string) *openfgav1.Userset {\n\treturn &openfgav1.Userset{\n\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\tComputedUserset: &openfgav1.ObjectRelation{\n\t\t\t\tRelation: relation,\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc TupleToUserset(tupleset, computedUserset string) *openfgav1.Userset {\n\treturn &openfgav1.Userset{\n\t\tUserset: &openfgav1.Userset_TupleToUserset{\n\t\t\tTupleToUserset: &openfgav1.TupleToUserset{\n\t\t\t\tTupleset: &openfgav1.ObjectRelation{\n\t\t\t\t\tRelation: tupleset,\n\t\t\t\t},\n\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{\n\t\t\t\t\tRelation: computedUserset,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc Union(children ...*openfgav1.Userset) *openfgav1.Userset {\n\treturn &openfgav1.Userset{\n\t\tUserset: &openfgav1.Userset_Union{\n\t\t\tUnion: &openfgav1.Usersets{\n\t\t\t\tChild: children,\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc Intersection(children ...*openfgav1.Userset) *openfgav1.Userset {\n\treturn &openfgav1.Userset{\n\t\tUserset: &openfgav1.Userset_Intersection{\n\t\t\tIntersection: &openfgav1.Usersets{\n\t\t\t\tChild: children,\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc Difference(base *openfgav1.Userset, sub *openfgav1.Userset) *openfgav1.Userset {\n\treturn &openfgav1.Userset{\n\t\tUserset: &openfgav1.Userset_Difference{\n\t\t\tDifference: &openfgav1.Difference{\n\t\t\t\tBase:     base,\n\t\t\t\tSubtract: sub,\n\t\t\t},\n\t\t},\n\t}\n}\n\n// TypeSystem is a wrapper over an [openfgav1.AuthorizationModel].\ntype TypeSystem struct {\n\t// [objectType] => typeDefinition\n\ttypeDefinitions map[string]*openfgav1.TypeDefinition\n\t// [objectType] => [relationName] => relation\n\trelations     map[string]map[string]*openfgav1.Relation\n\tmodelID       string\n\tschemaVersion string\n}\n\n// New creates a *TypeSystem from an *openfgav1.AuthorizationModel.\n// It assumes that the input model is valid. If you need to run validations, use NewAndValidate.\nfunc New(model *openfgav1.AuthorizationModel) *TypeSystem {\n\ttds := make(map[string]*openfgav1.TypeDefinition, len(model.GetTypeDefinitions()))\n\trelations := make(map[string]map[string]*openfgav1.Relation, len(model.GetTypeDefinitions()))\n\n\tfor _, td := range model.GetTypeDefinitions() {\n\t\ttypeName := td.GetType()\n\n\t\ttds[typeName] = td\n\t\ttdRelations := make(map[string]*openfgav1.Relation, len(td.GetRelations()))\n\n\t\tfor relation, rewrite := range td.GetRelations() {\n\t\t\tr := &openfgav1.Relation{\n\t\t\t\tName:     relation,\n\t\t\t\tRewrite:  rewrite,\n\t\t\t\tTypeInfo: &openfgav1.RelationTypeInfo{},\n\t\t\t}\n\n\t\t\tif metadata, ok := td.GetMetadata().GetRelations()[relation]; ok {\n\t\t\t\tr.TypeInfo.DirectlyRelatedUserTypes = metadata.GetDirectlyRelatedUserTypes()\n\t\t\t}\n\n\t\t\ttdRelations[relation] = r\n\t\t}\n\t\trelations[typeName] = tdRelations\n\t}\n\n\treturn &TypeSystem{\n\t\tmodelID:         model.GetId(),\n\t\tschemaVersion:   model.GetSchemaVersion(),\n\t\ttypeDefinitions: tds,\n\t\trelations:       relations,\n\t}\n}\n\n// GetAuthorizationModelID returns the id for the authorization model this\n// TypeSystem was constructed for.\nfunc (t *TypeSystem) GetAuthorizationModelID() string {\n\treturn t.modelID\n}\n\nfunc (t *TypeSystem) GetSchemaVersion() string {\n\treturn t.schemaVersion\n}\n\nfunc (t *TypeSystem) GetTypeDefinition(objectType string) (*openfgav1.TypeDefinition, bool) {\n\tif typeDefinition, ok := t.typeDefinitions[objectType]; ok {\n\t\treturn typeDefinition, true\n\t}\n\treturn nil, false\n}\n\n// GetRelations returns all relations in the TypeSystem for a given type\nfunc (t *TypeSystem) GetRelations(objectType string) (map[string]*openfgav1.Relation, error) {\n\t_, ok := t.GetTypeDefinition(objectType)\n\tif !ok {\n\t\treturn nil, &ObjectTypeUndefinedError{\n\t\t\tObjectType: objectType,\n\t\t\tErr:        ErrObjectTypeUndefined,\n\t\t}\n\t}\n\n\treturn t.relations[objectType], nil\n}\n\nfunc (t *TypeSystem) GetRelation(objectType, relation string) (*openfgav1.Relation, error) {\n\trelations, err := t.GetRelations(objectType)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tr, ok := relations[relation]\n\tif !ok {\n\t\treturn nil, &RelationUndefinedError{\n\t\t\tObjectType: objectType,\n\t\t\tRelation:   relation,\n\t\t\tErr:        ErrRelationUndefined,\n\t\t}\n\t}\n\n\treturn r, nil\n}\n\n// GetRelationReferenceAsString returns team#member, or team:*, or an empty string if the input is nil.\nfunc GetRelationReferenceAsString(rr *openfgav1.RelationReference) string {\n\tif rr == nil {\n\t\treturn \"\"\n\t}\n\tif _, ok := rr.RelationOrWildcard.(*openfgav1.RelationReference_Relation); ok {\n\t\treturn fmt.Sprintf(\"%s#%s\", rr.GetType(), rr.GetRelation())\n\t}\n\tif _, ok := rr.RelationOrWildcard.(*openfgav1.RelationReference_Wildcard); ok {\n\t\treturn fmt.Sprintf(\"%s:*\", rr.GetType())\n\t}\n\n\tpanic(\"unexpected relation reference\")\n}\n\nfunc (t *TypeSystem) GetDirectlyRelatedUserTypes(objectType, relation string) ([]*openfgav1.RelationReference, error) {\n\n\tr, err := t.GetRelation(objectType, relation)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn r.GetTypeInfo().GetDirectlyRelatedUserTypes(), nil\n}\n\n// DirectlyRelatedUsersets returns a list of the directly user related types that are usersets\nfunc (t *TypeSystem) DirectlyRelatedUsersets(objectType, relation string) ([]*openfgav1.RelationReference, error) {\n\trefs, err := t.GetDirectlyRelatedUserTypes(objectType, relation)\n\tvar usersetRelationReferences []*openfgav1.RelationReference\n\tif err != nil {\n\t\treturn usersetRelationReferences, err\n\t}\n\n\tfor _, ref := range refs {\n\t\tif ref.GetRelation() != \"\" || ref.GetWildcard() != nil {\n\t\t\tusersetRelationReferences = append(usersetRelationReferences, ref)\n\t\t}\n\t}\n\treturn usersetRelationReferences, nil\n}\n\n// IsDirectlyRelated determines whether the type of the target DirectRelationReference contains the source DirectRelationReference.\nfunc (t *TypeSystem) IsDirectlyRelated(target *openfgav1.RelationReference, source *openfgav1.RelationReference) (bool, error) {\n\n\trelation, err := t.GetRelation(target.GetType(), target.GetRelation())\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tfor _, typeRestriction := range relation.GetTypeInfo().GetDirectlyRelatedUserTypes() {\n\t\tif source.GetType() == typeRestriction.GetType() {\n\n\t\t\t// type with no relation or wildcard (e.g. 'user')\n\t\t\tif typeRestriction.GetRelationOrWildcard() == nil && source.GetRelationOrWildcard() == nil {\n\t\t\t\treturn true, nil\n\t\t\t}\n\n\t\t\t// typed wildcard (e.g. 'user:*')\n\t\t\tif typeRestriction.GetWildcard() != nil && source.GetWildcard() != nil {\n\t\t\t\treturn true, nil\n\t\t\t}\n\n\t\t\tif typeRestriction.GetRelation() != \"\" && source.GetRelation() != \"\" &&\n\t\t\t\ttypeRestriction.GetRelation() == source.GetRelation() {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\n/*\n * IsPubliclyAssignable returns true if the provided objectType is part of a typed wildcard type restriction\n * on the target relation.\n *\n * type user\n *\n * type document\n *   relations\n *     define viewer: [user:*]\n *\n * In the example above, the 'user' objectType is publicly assignable to the 'document#viewer' relation.\n */\nfunc (t *TypeSystem) IsPubliclyAssignable(target *openfgav1.RelationReference, objectType string) (bool, error) {\n\n\trelation, err := t.GetRelation(target.GetType(), target.GetRelation())\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tfor _, typeRestriction := range relation.GetTypeInfo().GetDirectlyRelatedUserTypes() {\n\t\tif typeRestriction.GetType() == objectType {\n\t\t\tif typeRestriction.GetWildcard() != nil {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\nfunc (t *TypeSystem) HasTypeInfo(objectType, relation string) (bool, error) {\n\tr, err := t.GetRelation(objectType, relation)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tif t.GetSchemaVersion() == SchemaVersion1_1 && r.GetTypeInfo() != nil {\n\t\treturn true, nil\n\t}\n\n\treturn false, nil\n}\n\n// RelationInvolvesIntersection returns true if the provided relation's userset rewrite\n// is defined by one or more direct or indirect intersections or any of the types related to\n// the provided relation are defined by one or more direct or indirect intersections.\nfunc (t *TypeSystem) RelationInvolvesIntersection(objectType, relation string) (bool, error) {\n\tvisited := map[string]struct{}{}\n\treturn t.relationInvolvesIntersection(objectType, relation, visited)\n}\n\nfunc (t *TypeSystem) relationInvolvesIntersection(objectType, relation string, visited map[string]struct{}) (bool, error) {\n\n\tkey := tuple.ToObjectRelationString(objectType, relation)\n\tif _, ok := visited[key]; ok {\n\t\treturn false, nil\n\t}\n\n\tvisited[key] = struct{}{}\n\n\trel, err := t.GetRelation(objectType, relation)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\trewrite := rel.GetRewrite()\n\n\tresult, err := WalkUsersetRewrite(rewrite, func(r *openfgav1.Userset) interface{} {\n\n\t\tswitch rw := r.GetUserset().(type) {\n\t\tcase *openfgav1.Userset_ComputedUserset:\n\t\t\trewrittenRelation := rw.ComputedUserset.GetRelation()\n\t\t\trewritten, err := t.GetRelation(objectType, rewrittenRelation)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tcontainsIntersection, err := t.relationInvolvesIntersection(\n\t\t\t\tobjectType,\n\t\t\t\trewritten.GetName(),\n\t\t\t\tvisited,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif containsIntersection {\n\t\t\t\treturn true\n\t\t\t}\n\n\t\tcase *openfgav1.Userset_TupleToUserset:\n\t\t\ttupleset := rw.TupleToUserset.GetTupleset().GetRelation()\n\t\t\trewrittenRelation := rw.TupleToUserset.ComputedUserset.GetRelation()\n\n\t\t\ttuplesetRel, err := t.GetRelation(objectType, tupleset)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tdirectlyRelatedTypes := tuplesetRel.GetTypeInfo().GetDirectlyRelatedUserTypes()\n\t\t\tfor _, relatedType := range directlyRelatedTypes {\n\t\t\t\t// must be of the form 'objectType' by this point since we disallow `tupleset` relations of the form `objectType:id#relation`\n\t\t\t\tr := relatedType.GetRelation()\n\t\t\t\tif r != \"\" {\n\t\t\t\t\treturn fmt.Errorf(\n\t\t\t\t\t\t\"invalid type restriction '%s#%s' specified on tupleset relation '%s#%s': %w\",\n\t\t\t\t\t\trelatedType.GetType(),\n\t\t\t\t\t\trelatedType.GetRelation(),\n\t\t\t\t\t\tobjectType,\n\t\t\t\t\t\ttupleset,\n\t\t\t\t\t\tErrInvalidModel,\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\trel, err := t.GetRelation(relatedType.GetType(), rewrittenRelation)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif errors.Is(err, ErrObjectTypeUndefined) || errors.Is(err, ErrRelationUndefined) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tcontainsIntersection, err := t.relationInvolvesIntersection(\n\t\t\t\t\trelatedType.GetType(),\n\t\t\t\t\trel.GetName(),\n\t\t\t\t\tvisited,\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tif containsIntersection {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn nil\n\n\t\tcase *openfgav1.Userset_Intersection:\n\t\t\treturn true\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tif result != nil && result.(bool) {\n\t\treturn true, nil\n\t}\n\n\tfor _, typeRestriction := range rel.GetTypeInfo().GetDirectlyRelatedUserTypes() {\n\t\tif typeRestriction.GetRelation() != \"\" {\n\n\t\t\tkey := tuple.ToObjectRelationString(typeRestriction.GetType(), typeRestriction.GetRelation())\n\t\t\tif _, ok := visited[key]; ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tcontainsIntersection, err := t.relationInvolvesIntersection(\n\t\t\t\ttypeRestriction.GetType(),\n\t\t\t\ttypeRestriction.GetRelation(),\n\t\t\t\tvisited,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\n\t\t\tif containsIntersection {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\n// RelationInvolvesExclusion returns true if the provided relation's userset rewrite\n// is defined by one or more direct or indirect exclusions or any of the types related to\n// the provided relation are defined by one or more direct or indirect exclusions.\nfunc (t *TypeSystem) RelationInvolvesExclusion(objectType, relation string) (bool, error) {\n\tvisited := map[string]struct{}{}\n\treturn t.relationInvolvesExclusion(objectType, relation, visited)\n\n}\n\nfunc (t *TypeSystem) relationInvolvesExclusion(objectType, relation string, visited map[string]struct{}) (bool, error) {\n\n\tkey := tuple.ToObjectRelationString(objectType, relation)\n\tif _, ok := visited[key]; ok {\n\t\treturn false, nil\n\t}\n\n\tvisited[key] = struct{}{}\n\n\trel, err := t.GetRelation(objectType, relation)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\trewrite := rel.GetRewrite()\n\n\tresult, err := WalkUsersetRewrite(rewrite, func(r *openfgav1.Userset) interface{} {\n\t\tswitch rw := r.GetUserset().(type) {\n\t\tcase *openfgav1.Userset_ComputedUserset:\n\t\t\trewrittenRelation := rw.ComputedUserset.GetRelation()\n\t\t\trewritten, err := t.GetRelation(objectType, rewrittenRelation)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tcontainsExclusion, err := t.relationInvolvesExclusion(\n\t\t\t\tobjectType,\n\t\t\t\trewritten.GetName(),\n\t\t\t\tvisited,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif containsExclusion {\n\t\t\t\treturn true\n\t\t\t}\n\n\t\tcase *openfgav1.Userset_TupleToUserset:\n\t\t\ttupleset := rw.TupleToUserset.GetTupleset().GetRelation()\n\t\t\trewrittenRelation := rw.TupleToUserset.ComputedUserset.GetRelation()\n\n\t\t\ttuplesetRel, err := t.GetRelation(objectType, tupleset)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tdirectlyRelatedTypes := tuplesetRel.GetTypeInfo().GetDirectlyRelatedUserTypes()\n\t\t\tfor _, relatedType := range directlyRelatedTypes {\n\t\t\t\t// must be of the form 'objectType' by this point since we disallow `tupleset` relations of the form `objectType:id#relation`\n\t\t\t\tr := relatedType.GetRelation()\n\t\t\t\tif r != \"\" {\n\t\t\t\t\treturn fmt.Errorf(\n\t\t\t\t\t\t\"invalid type restriction '%s#%s' specified on tupleset relation '%s#%s': %w\",\n\t\t\t\t\t\trelatedType.GetType(),\n\t\t\t\t\t\trelatedType.GetRelation(),\n\t\t\t\t\t\tobjectType,\n\t\t\t\t\t\ttupleset,\n\t\t\t\t\t\tErrInvalidModel,\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\trel, err := t.GetRelation(relatedType.GetType(), rewrittenRelation)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif errors.Is(err, ErrObjectTypeUndefined) || errors.Is(err, ErrRelationUndefined) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tcontainsExclusion, err := t.relationInvolvesExclusion(\n\t\t\t\t\trelatedType.GetType(),\n\t\t\t\t\trel.GetName(),\n\t\t\t\t\tvisited,\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tif containsExclusion {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn nil\n\n\t\tcase *openfgav1.Userset_Difference:\n\t\t\treturn true\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tif result != nil && result.(bool) {\n\t\treturn true, nil\n\t}\n\n\tfor _, typeRestriction := range rel.GetTypeInfo().GetDirectlyRelatedUserTypes() {\n\t\tif typeRestriction.GetRelation() != \"\" {\n\n\t\t\tkey := tuple.ToObjectRelationString(typeRestriction.GetType(), typeRestriction.GetRelation())\n\t\t\tif _, ok := visited[key]; ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tcontainsExclusion, err := t.relationInvolvesExclusion(\n\t\t\t\ttypeRestriction.GetType(),\n\t\t\t\ttypeRestriction.GetRelation(),\n\t\t\t\tvisited,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\n\t\t\tif containsExclusion {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\n// hasEntrypoints recursively walks the rewrite definition for the given relation to determine if there is at least\n// one path in the rewrite rule that could relate to at least one concrete object type. If there is no such path that\n// could lead to at least one relationship with some object type, then false is returned along with an error indicating\n// no entrypoints were found. If at least one relationship with a specific object type is found while walking the rewrite,\n// then true is returned along with a nil error.\nfunc hasEntrypoints(\n\ttypedefs map[string]map[string]*openfgav1.Relation,\n\ttypeName, relationName string,\n\trewrite *openfgav1.Userset,\n\tvisitedRelations map[string]map[string]struct{},\n) (bool, bool, error) {\n\n\tv := maps.Clone(visitedRelations)\n\n\tif val, ok := v[typeName]; ok {\n\t\tval[relationName] = struct{}{}\n\t} else {\n\t\tv[typeName] = map[string]struct{}{\n\t\t\trelationName: {},\n\t\t}\n\t}\n\n\trelation, ok := typedefs[typeName][relationName]\n\tif !ok {\n\t\treturn false, false, fmt.Errorf(\"undefined type definition for '%s#%s'\", typeName, relationName)\n\t}\n\n\tswitch rw := rewrite.Userset.(type) {\n\tcase *openfgav1.Userset_This:\n\t\tfor _, assignableType := range relation.GetTypeInfo().GetDirectlyRelatedUserTypes() {\n\t\t\tif assignableType.GetRelationOrWildcard() == nil || assignableType.GetWildcard() != nil {\n\t\t\t\treturn true, false, nil\n\t\t\t}\n\n\t\t\tassignableTypeName := assignableType.GetType()\n\t\t\tassignableRelationName := assignableType.GetRelation()\n\n\t\t\tassignableRelation, ok := typedefs[assignableTypeName][assignableRelationName]\n\t\t\tif !ok {\n\t\t\t\treturn false, false, fmt.Errorf(\"undefined type definition for '%s#%s'\", assignableTypeName, assignableRelationName)\n\t\t\t}\n\n\t\t\tif _, ok := v[assignableTypeName][assignableRelationName]; ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\thasEntrypoint, _, err := hasEntrypoints(typedefs, assignableTypeName, assignableRelationName, assignableRelation.GetRewrite(), v)\n\t\t\tif err != nil {\n\t\t\t\treturn false, false, err\n\t\t\t}\n\n\t\t\tif hasEntrypoint {\n\t\t\t\treturn true, false, nil\n\t\t\t}\n\t\t}\n\n\t\treturn false, false, nil\n\tcase *openfgav1.Userset_ComputedUserset:\n\n\t\tcomputedRelationName := rw.ComputedUserset.GetRelation()\n\t\tcomputedRelation, ok := typedefs[typeName][computedRelationName]\n\t\tif !ok {\n\t\t\treturn false, false, fmt.Errorf(\"undefined type definition for '%s#%s'\", typeName, computedRelationName)\n\t\t}\n\n\t\tif _, ok := v[typeName][computedRelationName]; ok {\n\t\t\treturn false, true, nil\n\t\t}\n\n\t\thasEntrypoint, loop, err := hasEntrypoints(typedefs, typeName, computedRelationName, computedRelation.GetRewrite(), v)\n\t\tif err != nil {\n\t\t\treturn false, false, err\n\t\t}\n\n\t\treturn hasEntrypoint, loop, nil\n\tcase *openfgav1.Userset_TupleToUserset:\n\t\ttuplesetRelationName := rw.TupleToUserset.GetTupleset().GetRelation()\n\t\tcomputedRelationName := rw.TupleToUserset.ComputedUserset.GetRelation()\n\n\t\ttuplesetRelation, ok := typedefs[typeName][tuplesetRelationName]\n\t\tif !ok {\n\t\t\treturn false, false, fmt.Errorf(\"undefined type definition for '%s#%s'\", typeName, tuplesetRelationName)\n\t\t}\n\n\t\tfor _, assignableType := range tuplesetRelation.GetTypeInfo().GetDirectlyRelatedUserTypes() {\n\t\t\tassignableTypeName := assignableType.GetType()\n\n\t\t\tif assignableRelation, ok := typedefs[assignableTypeName][computedRelationName]; ok {\n\t\t\t\tif _, ok := v[assignableTypeName][computedRelationName]; ok {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\thasEntrypoint, _, err := hasEntrypoints(typedefs, assignableTypeName, computedRelationName, assignableRelation.GetRewrite(), v)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn false, false, err\n\t\t\t\t}\n\n\t\t\t\tif hasEntrypoint {\n\t\t\t\t\treturn true, false, nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false, false, nil\n\n\tcase *openfgav1.Userset_Union:\n\n\t\tloop := false\n\t\tfor _, child := range rw.Union.Child {\n\n\t\t\thasEntrypoints, childLoop, err := hasEntrypoints(typedefs, typeName, relationName, child, maps.Clone(visitedRelations))\n\t\t\tif err != nil {\n\t\t\t\treturn false, false, err\n\t\t\t}\n\n\t\t\tif hasEntrypoints {\n\t\t\t\treturn true, false, nil\n\t\t\t}\n\t\t\tloop = loop || childLoop\n\t\t}\n\n\t\treturn false, loop, nil\n\tcase *openfgav1.Userset_Intersection:\n\n\t\tfor _, child := range rw.Intersection.Child {\n\n\t\t\t// all of the children must have an entrypoint\n\t\t\thasEntrypoints, childLoop, err := hasEntrypoints(typedefs, typeName, relationName, child, maps.Clone(visitedRelations))\n\t\t\tif err != nil {\n\t\t\t\treturn false, false, err\n\t\t\t}\n\n\t\t\tif !hasEntrypoints {\n\t\t\t\treturn false, childLoop, nil\n\t\t\t}\n\t\t}\n\n\t\treturn true, false, nil\n\tcase *openfgav1.Userset_Difference:\n\n\t\tv := maps.Clone(visitedRelations)\n\n\t\thasEntrypoint, loop, err := hasEntrypoints(typedefs, typeName, relationName, rw.Difference.GetBase(), v)\n\t\tif err != nil {\n\t\t\treturn false, false, err\n\t\t}\n\n\t\tif !hasEntrypoint {\n\t\t\treturn false, loop, nil\n\t\t}\n\n\t\thasEntrypoint, loop, err = hasEntrypoints(typedefs, typeName, relationName, rw.Difference.GetSubtract(), v)\n\t\tif err != nil {\n\t\t\treturn false, false, err\n\t\t}\n\n\t\tif !hasEntrypoint {\n\t\t\treturn false, loop, nil\n\t\t}\n\n\t\treturn true, false, nil\n\t}\n\n\treturn false, false, nil\n}\n\n// NewAndValidate is like New but also validates the model according to the following rules:\n//  1. Checks that the *TypeSystem have a valid schema version.\n//  2. For every rewrite the relations in the rewrite must:\n//     a. Be valid relations on the same type in the *TypeSystem (in cases of computedUserset)\n//     b. Be valid relations on another existing type (in cases of tupleToUserset)\n//  3. Do not allow duplicate types or duplicate relations (only need to check types as relations are\n//     in a map so cannot contain duplicates)\n//\n// If the *TypeSystem has a v1.1 schema version (with types on relations), then additionally\n// validate the *TypeSystem according to the following rules:\n//  3. Every type restriction on a relation must be a valid type:\n//     a. For a type (e.g. user) this means checking that this type is in the *TypeSystem\n//     b. For a type#relation this means checking that this type with this relation is in the *TypeSystem\n//  4. Check that a relation is assignable if and only if it has a non-zero list of types\nfunc NewAndValidate(ctx context.Context, model *openfgav1.AuthorizationModel) (*TypeSystem, error) {\n\t_, span := tracer.Start(ctx, \"typesystem.NewAndValidate\")\n\tdefer span.End()\n\n\tt := New(model)\n\tschemaVersion := t.GetSchemaVersion()\n\n\tif !IsSchemaVersionSupported(schemaVersion) {\n\t\treturn nil, ErrInvalidSchemaVersion\n\t}\n\n\tif containsDuplicateType(model) {\n\t\treturn nil, ErrDuplicateTypes\n\t}\n\n\tif err := t.validateNames(); err != nil {\n\t\treturn nil, err\n\t}\n\n\ttypedefsMap := t.typeDefinitions\n\n\ttypeNames := make([]string, 0, len(typedefsMap))\n\tfor typeName := range typedefsMap {\n\t\ttypeNames = append(typeNames, typeName)\n\t}\n\n\t// range over the type definitions in sorted order to produce a deterministic outcome\n\tsort.Strings(typeNames)\n\n\tfor _, typeName := range typeNames {\n\t\ttypedef := typedefsMap[typeName]\n\n\t\trelationMap := typedef.GetRelations()\n\t\trelationNames := make([]string, 0, len(relationMap))\n\t\tfor relationName := range relationMap {\n\t\t\trelationNames = append(relationNames, relationName)\n\t\t}\n\n\t\t// range over the relations in sorted order to produce a deterministic outcome\n\t\tsort.Strings(relationNames)\n\n\t\tfor _, relationName := range relationNames {\n\n\t\t\terr := t.validateRelation(typeName, relationName, relationMap)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn t, nil\n}\n\n// validateRelation applies all the validation rules to a relation definition in a model. A relation\n// must meet all the rewrite validation, type restriction validation, and entrypoint validation criteria\n// for it to be valid. Otherwise, an error is returned.\nfunc (t *TypeSystem) validateRelation(typeName, relationName string, relationMap map[string]*openfgav1.Userset) error {\n\n\trewrite := relationMap[relationName]\n\n\terr := t.isUsersetRewriteValid(typeName, relationName, rewrite)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = t.validateTypeRestrictions(typeName, relationName)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvisitedRelations := map[string]map[string]struct{}{}\n\n\thasEntrypoints, loop, err := hasEntrypoints(t.relations, typeName, relationName, rewrite, visitedRelations)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !hasEntrypoints {\n\t\tcause := ErrNoEntrypoints\n\t\tif loop {\n\t\t\tcause = ErrNoEntryPointsLoop\n\t\t}\n\t\treturn &InvalidRelationError{\n\t\t\tObjectType: typeName,\n\t\t\tRelation:   relationName,\n\t\t\tCause:      cause,\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc containsDuplicateType(model *openfgav1.AuthorizationModel) bool {\n\tseen := make(map[string]struct{}, len(model.GetTypeDefinitions()))\n\tfor _, td := range model.GetTypeDefinitions() {\n\t\tobjectType := td.GetType()\n\t\tif _, ok := seen[objectType]; ok {\n\t\t\treturn true\n\t\t}\n\t\tseen[objectType] = struct{}{}\n\t}\n\treturn false\n}\n\n// validateNames ensures that a model doesn't have object types or relations\n// called \"self\" or \"this\"\nfunc (t *TypeSystem) validateNames() error {\n\tfor _, td := range t.typeDefinitions {\n\t\tobjectType := td.GetType()\n\n\t\tif objectType == \"\" {\n\t\t\treturn fmt.Errorf(\"the type name of a type definition cannot be an empty string\")\n\t\t}\n\n\t\tif objectType == \"self\" || objectType == \"this\" {\n\t\t\treturn &InvalidTypeError{ObjectType: objectType, Cause: ErrReservedKeywords}\n\t\t}\n\n\t\tfor relation := range td.GetRelations() {\n\t\t\tif relation == \"\" {\n\t\t\t\treturn fmt.Errorf(\"type '%s' defines a relation with an empty string for a name\", objectType)\n\t\t\t}\n\n\t\t\tif relation == \"self\" || relation == \"this\" {\n\t\t\t\treturn &InvalidRelationError{ObjectType: objectType, Relation: relation, Cause: ErrReservedKeywords}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// isUsersetRewriteValid checks if the rewrite on objectType#relation is valid.\nfunc (t *TypeSystem) isUsersetRewriteValid(objectType, relation string, rewrite *openfgav1.Userset) error {\n\tif rewrite.GetUserset() == nil {\n\t\treturn &InvalidRelationError{ObjectType: objectType, Relation: relation, Cause: ErrInvalidUsersetRewrite}\n\t}\n\n\tswitch r := rewrite.GetUserset().(type) {\n\tcase *openfgav1.Userset_ComputedUserset:\n\t\tcomputedUserset := r.ComputedUserset.GetRelation()\n\t\tif computedUserset == relation {\n\t\t\treturn &InvalidRelationError{ObjectType: objectType, Relation: relation, Cause: ErrInvalidUsersetRewrite}\n\t\t}\n\t\tif _, err := t.GetRelation(objectType, computedUserset); err != nil {\n\t\t\treturn &RelationUndefinedError{ObjectType: objectType, Relation: computedUserset, Err: ErrRelationUndefined}\n\t\t}\n\tcase *openfgav1.Userset_TupleToUserset:\n\t\ttupleset := r.TupleToUserset.GetTupleset().GetRelation()\n\n\t\ttuplesetRelation, err := t.GetRelation(objectType, tupleset)\n\t\tif err != nil {\n\t\t\treturn &RelationUndefinedError{ObjectType: objectType, Relation: tupleset, Err: ErrRelationUndefined}\n\t\t}\n\n\t\t// tupleset relations must only be direct relationships, no rewrites are allowed on them\n\t\ttuplesetRewrite := tuplesetRelation.GetRewrite()\n\t\tif reflect.TypeOf(tuplesetRewrite.GetUserset()) != reflect.TypeOf(&openfgav1.Userset_This{}) {\n\t\t\treturn fmt.Errorf(\"the '%s#%s' relation is referenced in at least one tupleset and thus must be a direct relation\", objectType, tupleset)\n\t\t}\n\n\t\tcomputedUserset := r.TupleToUserset.GetComputedUserset().GetRelation()\n\n\t\tif t.GetSchemaVersion() == SchemaVersion1_1 {\n\t\t\t// for 1.1 models, relation `computedUserset` has to be defined in one of the types declared by the tupleset's list of allowed types\n\t\t\tuserTypes := tuplesetRelation.GetTypeInfo().GetDirectlyRelatedUserTypes()\n\t\t\tfor _, rr := range userTypes {\n\t\t\t\tif _, err := t.GetRelation(rr.GetType(), computedUserset); err == nil {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"%w: %s does not appear as a relation in any of the directly related user types %s\", ErrRelationUndefined, computedUserset, userTypes)\n\t\t} else {\n\t\t\t// for 1.0 models, relation `computedUserset` has to be defined _somewhere_ in the model\n\t\t\tfor typeName := range t.relations {\n\t\t\t\tif _, err := t.GetRelation(typeName, computedUserset); err == nil {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn &RelationUndefinedError{ObjectType: \"\", Relation: computedUserset, Err: ErrRelationUndefined}\n\t\t}\n\tcase *openfgav1.Userset_Union:\n\t\tfor _, child := range r.Union.GetChild() {\n\t\t\terr := t.isUsersetRewriteValid(objectType, relation, child)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\tcase *openfgav1.Userset_Intersection:\n\t\tfor _, child := range r.Intersection.GetChild() {\n\t\t\terr := t.isUsersetRewriteValid(objectType, relation, child)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\tcase *openfgav1.Userset_Difference:\n\t\terr := t.isUsersetRewriteValid(objectType, relation, r.Difference.Base)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = t.isUsersetRewriteValid(objectType, relation, r.Difference.Subtract)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// validateTypeRestrictions validates the type restrictions of a given relation using the following rules:\n//  1. An assignable relation must have one or more type restrictions.\n//  2. A non-assignable relation must not have any type restrictions.\n//  3. For each type restriction referenced for an assignable relation, each of the referenced types and relations\n//     must be defined in the model.\n//  4. If the provided relation is a tupleset relation, then the type restriction must be on a direct object.\nfunc (t *TypeSystem) validateTypeRestrictions(objectType string, relationName string) error {\n\n\trelation, err := t.GetRelation(objectType, relationName)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trelatedTypes := relation.GetTypeInfo().GetDirectlyRelatedUserTypes()\n\tassignable := t.IsDirectlyAssignable(relation)\n\n\tif assignable && len(relatedTypes) == 0 {\n\t\treturn AssignableRelationError(objectType, relationName)\n\t}\n\n\tif !assignable && len(relatedTypes) != 0 {\n\t\treturn NonAssignableRelationError(objectType, relationName)\n\t}\n\n\tfor _, related := range relatedTypes {\n\t\trelatedObjectType := related.GetType()\n\t\trelatedRelation := related.GetRelation()\n\n\t\tif _, err := t.GetRelations(relatedObjectType); err != nil {\n\t\t\treturn InvalidRelationTypeError(objectType, relationName, relatedObjectType, relatedRelation)\n\t\t}\n\n\t\tif related.GetRelationOrWildcard() != nil {\n\t\t\t// The type of the relation cannot contain a userset or wildcard if the relation is a tupleset relation.\n\t\t\tif ok, _ := t.IsTuplesetRelation(objectType, relationName); ok {\n\t\t\t\treturn InvalidRelationTypeError(objectType, relationName, relatedObjectType, relatedRelation)\n\t\t\t}\n\n\t\t\tif relatedRelation != \"\" {\n\t\t\t\tif _, err := t.GetRelation(relatedObjectType, relatedRelation); err != nil {\n\t\t\t\t\treturn InvalidRelationTypeError(objectType, relationName, relatedObjectType, relatedRelation)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (t *TypeSystem) IsDirectlyAssignable(relation *openfgav1.Relation) bool {\n\treturn RewriteContainsSelf(relation.GetRewrite())\n}\n\n// RewriteContainsSelf returns true if the provided userset rewrite\n// is defined by one or more self referencing definitions.\nfunc RewriteContainsSelf(rewrite *openfgav1.Userset) bool {\n\n\tresult, err := WalkUsersetRewrite(rewrite, func(r *openfgav1.Userset) interface{} {\n\t\tif _, ok := r.Userset.(*openfgav1.Userset_This); ok {\n\t\t\treturn true\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tpanic(\"unexpected error during rewrite evaluation\")\n\t}\n\n\treturn result != nil && result.(bool) // type-cast matches the return from the WalkRelationshipRewriteHandler above\n}\n\n// RewriteContainsIntersection returns true if the provided userset rewrite\n// is defined by one or more direct or indirect intersections.\nfunc RewriteContainsIntersection(rewrite *openfgav1.Userset) bool {\n\n\tresult, err := WalkUsersetRewrite(rewrite, func(r *openfgav1.Userset) interface{} {\n\t\tif _, ok := r.Userset.(*openfgav1.Userset_Intersection); ok {\n\t\t\treturn true\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tpanic(\"unexpected error during rewrite evaluation\")\n\t}\n\n\treturn result != nil && result.(bool) // type-cast matches the return from the WalkRelationshipRewriteHandler above\n}\n\n// RewriteContainsExclusion returns true if the provided userset rewrite\n// is defined by one or more direct or indirect exclusions.\nfunc RewriteContainsExclusion(rewrite *openfgav1.Userset) bool {\n\n\tresult, err := WalkUsersetRewrite(rewrite, func(r *openfgav1.Userset) interface{} {\n\t\tif _, ok := r.Userset.(*openfgav1.Userset_Difference); ok {\n\t\t\treturn true\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tpanic(\"unexpected error during rewrite evaluation\")\n\t}\n\n\treturn result != nil && result.(bool) // type-cast matches the return from the WalkRelationshipRewriteHandler above\n}\n\ntype InvalidTypeError struct {\n\tObjectType string\n\tCause      error\n}\n\nfunc (e *InvalidTypeError) Error() string {\n\treturn fmt.Sprintf(\"the definition of type '%s' is invalid\", e.ObjectType)\n}\n\nfunc (e *InvalidTypeError) Unwrap() error {\n\treturn e.Cause\n}\n\ntype InvalidRelationError struct {\n\tObjectType string\n\tRelation   string\n\tCause      error\n}\n\nfunc (e *InvalidRelationError) Error() string {\n\treturn fmt.Sprintf(\"the definition of relation '%s' in object type '%s' is invalid: %s\", e.Relation, e.ObjectType, e.Cause)\n}\n\nfunc (e *InvalidRelationError) Unwrap() error {\n\treturn e.Cause\n}\n\ntype ObjectTypeUndefinedError struct {\n\tObjectType string\n\tErr        error\n}\n\nfunc (e *ObjectTypeUndefinedError) Error() string {\n\treturn fmt.Sprintf(\"'%s' is an undefined object type\", e.ObjectType)\n}\n\nfunc (e *ObjectTypeUndefinedError) Unwrap() error {\n\treturn e.Err\n}\n\ntype RelationUndefinedError struct {\n\tObjectType string\n\tRelation   string\n\tErr        error\n}\n\nfunc (e *RelationUndefinedError) Error() string {\n\n\tif e.ObjectType != \"\" {\n\t\treturn fmt.Sprintf(\"'%s#%s' relation is undefined\", e.ObjectType, e.Relation)\n\t}\n\n\treturn fmt.Sprintf(\"'%s' relation is undefined\", e.Relation)\n}\n\nfunc (e *RelationUndefinedError) Unwrap() error {\n\treturn e.Err\n}\n\nfunc AssignableRelationError(objectType, relation string) error {\n\treturn fmt.Errorf(\"the assignable relation '%s' in object type '%s' must contain at least one relation type\", relation, objectType)\n}\n\nfunc NonAssignableRelationError(objectType, relation string) error {\n\treturn fmt.Errorf(\"the non-assignable relation '%s' in object type '%s' should not contain a relation type\", objectType, relation)\n}\n\nfunc InvalidRelationTypeError(objectType, relation, relatedObjectType, relatedRelation string) error {\n\trelationType := relatedObjectType\n\tif relatedRelation != \"\" {\n\t\trelationType = tuple.ToObjectRelationString(relatedObjectType, relatedRelation)\n\t}\n\n\treturn fmt.Errorf(\"the relation type '%s' on '%s' in object type '%s' is not valid\", relationType, relation, objectType)\n}\n\n// getAllTupleToUsersetsDefinitions returns a map where the key is the object type and the value\n// is another map where key=relationName, value=list of tuple to usersets declared in that relation\nfunc (t *TypeSystem) getAllTupleToUsersetsDefinitions() map[string]map[string][]*openfgav1.TupleToUserset {\n\tresponse := make(map[string]map[string][]*openfgav1.TupleToUserset, 0)\n\tfor typeName, typeDef := range t.typeDefinitions {\n\t\tresponse[typeName] = make(map[string][]*openfgav1.TupleToUserset, 0)\n\t\tfor relationName, relationDef := range typeDef.GetRelations() {\n\t\t\tttus := make([]*openfgav1.TupleToUserset, 0)\n\t\t\tresponse[typeName][relationName] = t.tupleToUsersetsDefinitions(relationDef, &ttus)\n\t\t}\n\t}\n\n\treturn response\n}\n\n// IsTuplesetRelation returns a boolean indicating if the provided relation is defined under a\n// TupleToUserset rewrite as a tupleset relation (i.e. the right hand side of a `X from Y`).\nfunc (t *TypeSystem) IsTuplesetRelation(objectType, relation string) (bool, error) {\n\n\t_, err := t.GetRelation(objectType, relation)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tfor _, ttuDefinitions := range t.getAllTupleToUsersetsDefinitions()[objectType] {\n\t\tfor _, ttuDef := range ttuDefinitions {\n\t\t\tif ttuDef.Tupleset.Relation == relation {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\nfunc (t *TypeSystem) tupleToUsersetsDefinitions(relationDef *openfgav1.Userset, resp *[]*openfgav1.TupleToUserset) []*openfgav1.TupleToUserset {\n\tif relationDef.GetTupleToUserset() != nil {\n\t\t*resp = append(*resp, relationDef.GetTupleToUserset())\n\t}\n\tif relationDef.GetUnion() != nil {\n\t\tfor _, child := range relationDef.GetUnion().GetChild() {\n\t\t\tt.tupleToUsersetsDefinitions(child, resp)\n\t\t}\n\t}\n\tif relationDef.GetIntersection() != nil {\n\t\tfor _, child := range relationDef.GetIntersection().GetChild() {\n\t\t\tt.tupleToUsersetsDefinitions(child, resp)\n\t\t}\n\t}\n\tif relationDef.GetDifference() != nil {\n\t\tt.tupleToUsersetsDefinitions(relationDef.GetDifference().GetBase(), resp)\n\t\tt.tupleToUsersetsDefinitions(relationDef.GetDifference().GetSubtract(), resp)\n\t}\n\treturn *resp\n}\n\n// WalkUsersetRewriteHandler is a userset rewrite handler that is applied to a node in a userset rewrite\n// tree. Implementations of the WalkUsersetRewriteHandler should return a non-nil value when the traversal\n// over the rewrite tree should terminate and nil if traversal should proceed to other nodes in the tree.\ntype WalkUsersetRewriteHandler func(rewrite *openfgav1.Userset) interface{}\n\n// WalkUsersetRewrite recursively walks the provided userset rewrite and invokes the provided WalkUsersetRewriteHandler\n// to each node in the userset rewrite tree until the first non-nil response is encountered.\nfunc WalkUsersetRewrite(rewrite *openfgav1.Userset, handler WalkUsersetRewriteHandler) (interface{}, error) {\n\n\tvar children []*openfgav1.Userset\n\n\tif result := handler(rewrite); result != nil {\n\t\treturn result, nil\n\t}\n\n\tswitch t := rewrite.Userset.(type) {\n\tcase *openfgav1.Userset_This:\n\t\treturn handler(rewrite), nil\n\tcase *openfgav1.Userset_ComputedUserset:\n\t\treturn handler(rewrite), nil\n\tcase *openfgav1.Userset_TupleToUserset:\n\t\treturn handler(rewrite), nil\n\tcase *openfgav1.Userset_Union:\n\t\tchildren = t.Union.GetChild()\n\tcase *openfgav1.Userset_Intersection:\n\t\tchildren = t.Intersection.GetChild()\n\tcase *openfgav1.Userset_Difference:\n\t\tchildren = append(children, t.Difference.GetBase(), t.Difference.GetSubtract())\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unexpected userset rewrite type encountered\")\n\t}\n\n\tfor _, child := range children {\n\t\tresult, err := WalkUsersetRewrite(child, handler)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif result != nil {\n\t\t\treturn result, nil\n\t\t}\n\t}\n\n\treturn nil, nil\n}\n", "package typesystem\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\tparser \"github.com/craigpastro/openfga-dsl-parser/v2\"\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestNewAndValidate(t *testing.T) {\n\n\ttests := []struct {\n\t\tname          string\n\t\tmodel         string\n\t\texpectedError error\n\t}{\n\t\t{\n\t\t\tname: \"direct_relationship_with_entrypoint\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user] as self\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tname: \"computed_relationship_with_entrypoint\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define editor: [user] as self\n\t\t\t    define viewer as editor\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tname: \"no_entrypoint_1\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define admin: [user] as self\n\t\t\t    define action1 as admin and action2 and action3\n\t\t\t    define action2 as admin and action1 and action3\n\t\t\t    define action3 as admin and action1 and action2\n\t\t\t`,\n\t\t\texpectedError: ErrNoEntryPointsLoop,\n\t\t},\n\t\t{\n\t\t\tname: \"no_entrypoint_2\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t\tdefine admin: [user] as self\n\t\t\t\tdefine action1 as admin but not action2\n\t\t\t\tdefine action2 as admin but not action3\n\t\t\t\tdefine action3 as admin but not action1\n\t\t\t`,\n\t\t\texpectedError: ErrNoEntryPointsLoop,\n\t\t},\n\t\t{\n\t\t\tname: \"no_entrypoint_3a\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [document#viewer] as self and editor\n\t\t\t    define editor: [user] as self\n\t\t\t`,\n\t\t\texpectedError: ErrNoEntrypoints,\n\t\t},\n\t\t{\n\t\t\tname: \"no_entrypoint_3b\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [document#viewer] as self but not editor\n\t\t\t    define editor: [user] as self\n\t\t\t`,\n\t\t\texpectedError: ErrNoEntrypoints,\n\t\t},\n\t\t{\n\t\t\tname: \"no_entrypoint_4\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define parent: [document] as self\n\t\t\t    define viewer as editor from parent\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t\tdefine editor as viewer\n\t\t\t    define viewer as editor from parent\n\t\t\t`,\n\t\t\texpectedError: ErrNoEntrypoints,\n\t\t},\n\t\t{\n\t\t\tname: \"self_referencing_type_restriction_with_entrypoint_1\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define restricted: [user] as self\n\t\t\t    define editor: [user] as self\n\t\t\t    define viewer: [document#viewer] as self or editor\n\t\t\t    define can_view as viewer but not restricted\n\t\t\t    define can_view_actual as can_view\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tname: \"self_referencing_type_restriction_with_entrypoint_2\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define editor: [user] as self\n\t\t\t    define viewer: [document#viewer] as self or editor\n\t\t\t`,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t_, err := NewAndValidate(context.Background(), &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion:   SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: parser.MustParse(test.model),\n\t\t\t})\n\t\t\trequire.ErrorIs(t, err, test.expectedError)\n\t\t})\n\t}\n}\n\nfunc TestSuccessfulRewriteValidations(t *testing.T) {\n\tvar tests = []struct {\n\t\tname  string\n\t\tmodel *openfgav1.AuthorizationModel\n\t}{\n\t\t{\n\t\t\tname: \"empty_relations\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"zero_length_relations_is_valid\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType:      \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"self_referencing_type_restriction_with_entrypoint\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define editor: [user] as self\n\t\t\t\t    define viewer: [document#viewer] as self or editor\n\t\t\t\t`),\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"intersection_may_contain_repeated_relations\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t\tdefine editor: [user] as self\n\t\t\t\t\tdefine viewer as editor and editor\n\t\t\t\t`),\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"exclusion_may_contain_repeated_relations\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t\tdefine editor: [user] as self\n\t\t\t\t\tdefine viewer as editor but not editor\n\t\t\t\t`),\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t_, err := NewAndValidate(context.Background(), test.model)\n\t\t\trequire.NoError(t, err)\n\t\t})\n\t}\n}\n\nfunc TestInvalidRewriteValidations(t *testing.T) {\n\tvar tests = []struct {\n\t\tname  string\n\t\tmodel *openfgav1.AuthorizationModel\n\t\terr   error\n\t}{\n\t\t{\n\t\t\tname: \"empty_rewrites\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrInvalidUsersetRewrite,\n\t\t},\n\t\t{\n\t\t\tname: \"duplicate_types_is_invalid\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType:      \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType:      \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrDuplicateTypes,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_self_reference_in_computedUserset\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{Relation: \"reader\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrInvalidUsersetRewrite,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_self_reference_in_union\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_Union{\n\t\t\t\t\t\t\t\t\tUnion: &openfgav1.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{Relation: \"reader\"},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrInvalidUsersetRewrite,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_self_reference_in_intersection\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_Intersection{\n\t\t\t\t\t\t\t\t\tIntersection: &openfgav1.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{Relation: \"reader\"},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrInvalidUsersetRewrite,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_self_reference_in_difference_base\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_Difference{\n\t\t\t\t\t\t\t\t\tDifference: &openfgav1.Difference{\n\t\t\t\t\t\t\t\t\t\tBase: &openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{Relation: \"reader\"},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tSubtract: &openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrInvalidUsersetRewrite,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_self_reference_in_difference_subtract\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_Difference{\n\t\t\t\t\t\t\t\t\tDifference: &openfgav1.Difference{\n\t\t\t\t\t\t\t\t\t\tBase: &openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tSubtract: &openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{Relation: \"reader\"},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrInvalidUsersetRewrite,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_computedUserset_to_relation_which_does_not_exist\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{Relation: \"writer\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_computedUserset_in_a_union\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_Union{\n\t\t\t\t\t\t\t\t\tUnion: &openfgav1.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{Relation: \"writer\"},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_computedUserset_in_a_intersection\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_Intersection{\n\t\t\t\t\t\t\t\t\tIntersection: &openfgav1.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{Relation: \"writer\"},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_computedUserset_in_a_difference_base\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_Difference{\n\t\t\t\t\t\t\t\t\tDifference: &openfgav1.Difference{\n\t\t\t\t\t\t\t\t\t\tBase: &openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{Relation: \"writer\"},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tSubtract: &openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_computedUserset_in_a_difference_subtract\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_Difference{\n\t\t\t\t\t\t\t\t\tDifference: &openfgav1.Difference{\n\t\t\t\t\t\t\t\t\t\tBase: &openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tSubtract: &openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{Relation: \"writer\"},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_tupleToUserset_where_tupleset_is_not_valid\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"group\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"member\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_Union{\n\t\t\t\t\t\t\t\t\tUnion: &openfgav1.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgav1.TupleToUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tTupleset: &openfgav1.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"notavalidrelation\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"member\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_tupleToUserset_where_computed_userset_is_not_valid\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define reader as notavalidrelation from writer\n\t\t\t\t\tdefine writer: [user] as self\n\t\t\t\t`),\n\t\t\t},\n\t\t\terr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"Fails_If_Using_This_As_Relation_Name\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"this\": This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrReservedKeywords,\n\t\t},\n\t\t{\n\t\t\tname: \"Fails_If_Using_Self_As_Relation_Name\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"self\": This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrReservedKeywords,\n\t\t},\n\t\t{\n\t\t\tname: \"Fails_If_Using_This_As_Type_Name\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"this\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"viewer\": This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrReservedKeywords,\n\t\t},\n\t\t{\n\t\t\tname: \"Fails_If_Using_Self_As_Type_Name\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"self\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"viewer\": This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrReservedKeywords,\n\t\t},\n\t\t{\n\t\t\tname: \"Fails_If_Auth_Model_1.1_Has_A_Cycle_And_Only_One_Type\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype folder\n\t\t\t\t  relations\n\t\t\t\t    define parent: [folder] as self\n\t\t\t\t\tdefine viewer as viewer from parent\n\t\t\t\t`),\n\t\t\t},\n\t\t\terr: ErrNoEntrypoints,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t_, err := NewAndValidate(context.Background(), test.model)\n\t\t\trequire.ErrorIs(t, err, test.err)\n\t\t})\n\t}\n}\nfunc TestSuccessfulRelationTypeRestrictionsValidations(t *testing.T) {\n\tvar tests = []struct {\n\t\tname  string\n\t\tmodel *openfgav1.AuthorizationModel\n\t}{\n\t\t{\n\t\t\tname: \"succeeds_on_a_valid_typeSystem_with_an_objectType_type\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {Userset: &openfgav1.Userset_This{}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"succeeds_on_a_valid_typeSystem_with_a_type_and_type#relation_type\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"group\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"admin\":  {Userset: &openfgav1.Userset_This{}},\n\t\t\t\t\t\t\t\"member\": {Userset: &openfgav1.Userset_This{}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"member\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {Userset: &openfgav1.Userset_This{}},\n\t\t\t\t\t\t\t\"writer\": {Userset: &openfgav1.Userset_This{}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"group\", \"member\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"group\", \"admin\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t_, err := NewAndValidate(context.Background(), test.model)\n\t\t\trequire.NoError(t, err)\n\t\t})\n\t}\n}\n\nfunc TestInvalidRelationTypeRestrictionsValidations(t *testing.T) {\n\tvar tests = []struct {\n\t\tname  string\n\t\tmodel *openfgav1.AuthorizationModel\n\t\terr   error\n\t}{\n\t\t{\n\t\t\tname: \"relational_type_which_does_not_exist\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {Userset: &openfgav1.Userset_This{}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"group\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: InvalidRelationTypeError(\"document\", \"reader\", \"group\", \"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"relation_type_of_form_type#relation_where_relation_doesn't_exist\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"group\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {Userset: &openfgav1.Userset_This{}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType:               \"group\",\n\t\t\t\t\t\t\t\t\t\t\tRelationOrWildcard: &openfgav1.RelationReference_Relation{Relation: \"admin\"},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: InvalidRelationTypeError(\"document\", \"reader\", \"group\", \"admin\"),\n\t\t},\n\t\t{\n\t\t\tname: \"assignable_relation_with_no_type:_this\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: AssignableRelationError(\"document\", \"reader\"),\n\t\t},\n\t\t{\n\t\t\tname: \"assignable_relation_with_no_type:_union\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_Union{\n\t\t\t\t\t\t\t\t\tUnion: &openfgav1.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: AssignableRelationError(\"document\", \"reader\"),\n\t\t},\n\t\t{\n\t\t\tname: \"assignable_relation_wit_no_type:_intersection\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_Intersection{\n\t\t\t\t\t\t\t\t\tIntersection: &openfgav1.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: AssignableRelationError(\"document\", \"reader\"),\n\t\t},\n\t\t{\n\t\t\tname: \"assignable_relation_with_no_type:_difference base\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_Difference{\n\t\t\t\t\t\t\t\t\tDifference: &openfgav1.Difference{\n\t\t\t\t\t\t\t\t\t\tBase: &openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tSubtract: &openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: AssignableRelationError(\"document\", \"reader\"),\n\t\t},\n\t\t{\n\t\t\tname: \"assignable_relation_with_no_type:_difference_subtract\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_Difference{\n\t\t\t\t\t\t\t\t\tDifference: &openfgav1.Difference{\n\t\t\t\t\t\t\t\t\t\tBase: &openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tSubtract: &openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: AssignableRelationError(\"document\", \"reader\"),\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_relation_with_a_type\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{Relation: \"writer\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: NonAssignableRelationError(\"document\", \"reader\"),\n\t\t},\n\t\t{\n\t\t\tname: \"userset_specified_as_allowed_type_but_the_relation_is_used_in_a_TTU_rewrite\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"folder\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"member\": This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"member\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"parent\":   This(),\n\t\t\t\t\t\t\t\"can_view\": TupleToUserset(\"parent\", \"member\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"parent\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"folder\", \"member\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: InvalidRelationTypeError(\"document\", \"parent\", \"folder\", \"member\"),\n\t\t},\n\t\t{\n\t\t\tname: \"userset_specified_as_allowed_type_but_the_relation_is_used_in_a_TTU_rewrite_included_in_a_union\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"folder\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"parent\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"folder\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Union(TupleToUserset(\"parent\", \"viewer\"), This()),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"parent\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"folder\", \"parent\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"folder\", \"parent\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: InvalidRelationTypeError(\"document\", \"parent\", \"folder\", \"parent\"),\n\t\t},\n\t\t{\n\t\t\tname: \"WildcardNotAllowedInTheTuplesetPartOfTTU\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"folder\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"viewer\": This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Union(This(), TupleToUserset(\"parent\", \"viewer\")),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"parent\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\tWildcardRelationReference(\"folder\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: InvalidRelationTypeError(\"document\", \"parent\", \"folder\", \"\"),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t_, err := NewAndValidate(context.Background(), test.model)\n\t\t\trequire.EqualError(t, err, test.err.Error())\n\t\t})\n\t}\n}\n\nfunc TestRelationInvolvesIntersection(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tmodel       string\n\t\trr          *openfgav1.RelationReference\n\t\texpected    bool\n\t\texpectedErr error\n\t}{\n\t\t{\n\t\t\tname: \"indirect_computeduserset_through_ttu_containing_intersection\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define manage: [user] as self\n\t\t\t    define editor: [user] as self and manage\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define editor as editor from parent\n\t\t\t    define viewer as editor\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"ttu_relations_containing_intersection\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define editor: [user] as self\n\t\t\t    define viewer: [user] as self and editor\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer as viewer from parent\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"indirect_relations_containing_intersection\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define editor: [user] as self\n\t\t\t    define viewer: [user] as self and editor\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"undefined_type\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\t`,\n\t\t\trr:          DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected:    false,\n\t\t\texpectedErr: ErrObjectTypeUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"undefined_relation\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\t`,\n\t\t\trr:          DirectRelationReference(\"user\", \"viewer\"),\n\t\t\texpected:    false,\n\t\t\texpectedErr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_indirect_type_restriction_involving_intersection\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype org\n\t\t\t  relations\n\t\t\t    define allowed: [user] as self\n\t\t\t    define dept: [group] as self\n\t\t\t    define dept_member as member from dept\n\t\t\t    define dept_allowed_member as dept_member and allowed\n\n\t\t\ttype resource\n\t\t\t  relations\n\t\t\t    define reader: [user] as self or writer\n\t\t\t    define writer: [org#dept_allowed_member] as self\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"resource\", \"reader\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"indirect_relationship_through_type_restriction\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define allowed: [user] as self\n\t\t\t    define editor: [user] as self and allowed\n\t\t\t    define viewer: [document#editor] as self\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"github_model\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype organization\n\t\t\t  relations\n\t\t\t    define member: [user] as self or owner\n\t\t\t\tdefine owner: [user] as self\n\t\t\t\tdefine repo_admin: [user, organization#member] as self\n\t\t\t\tdefine repo_reader: [user, organization#member] as self\n\t\t\t\tdefine repo_writer: [user, organization#member] as self\n\n\t\t\ttype team\n\t\t\t  relations\n\t\t\t    define member: [user, team#member] as self\n\n\t\t\ttype repo\n\t\t\t  relations\n\t\t\t    define admin: [user, team#member] as self or repo_admin from owner\n\t\t\t\tdefine maintainer: [user, team#member] as self or admin\n\t\t\t\tdefine owner: [organization] as self\n\t\t\t\tdefine reader: [user, team#member] as self or triager or repo_reader from owner\n\t\t\t\tdefine triager: [user, team#member] as self or writer\n\t\t\t\tdefine writer: [user, team#member] as self or maintainer or repo_writer from owner\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"repo\", \"admin\"),\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname: \"github_model\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype organization\n\t\t\t  relations\n\t\t\t    define member: [user] as self or owner\n\t\t\t\tdefine owner: [user] as self\n\t\t\t\tdefine repo_admin: [user, organization#member] as self\n\t\t\t\tdefine repo_reader: [user, organization#member] as self\n\t\t\t\tdefine repo_writer: [user, organization#member] as self\n\n\t\t\ttype team\n\t\t\t  relations\n\t\t\t    define member: [user, team#member] as self\n\n\t\t\ttype repo\n\t\t\t  relations\n\t\t\t    define admin: [user, team#member] as self or repo_admin from owner\n\t\t\t\tdefine maintainer: [user, team#member] as self or admin\n\t\t\t\tdefine owner: [organization] as self\n\t\t\t\tdefine reader: [user, team#member] as self or triager or repo_reader from owner\n\t\t\t\tdefine triager: [user, team#member] as self or writer\n\t\t\t\tdefine writer: [user, team#member] as self or maintainer or repo_writer from owner\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"repo\", \"admin\"),\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname: \"direct_relations_related_to_each_other\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype example\n\t\t\t  relations\n\t\t\t    define editor: [example#viewer] as self\n\t\t\t    define viewer: [example#editor] as self\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"example\", \"editor\"),\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname: \"cyclical_evaluation_of_tupleset\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype node\n\t\t\t  relations\n\t\t\t    define parent: [node] as self\n\t\t\t    define editor: [user] as self or editor from parent\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"node\", \"editor\"),\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested_intersection_1\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define allowed: [user] as self\n\t\t\t    define viewer: [user] as self and allowed\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t\tdefine viewer as viewer from parent\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\ttypedefs := parser.MustParse(test.model)\n\n\t\t\ttypesys := New(&openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: typedefs,\n\t\t\t})\n\n\t\t\tobjectType := test.rr.GetType()\n\t\t\trelationStr := test.rr.GetRelation()\n\n\t\t\tactual, err := typesys.RelationInvolvesIntersection(objectType, relationStr)\n\t\t\trequire.ErrorIs(t, err, test.expectedErr)\n\t\t\trequire.Equal(t, test.expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestRelationInvolvesExclusion(t *testing.T) {\n\n\ttests := []struct {\n\t\tname        string\n\t\tmodel       string\n\t\trr          *openfgav1.RelationReference\n\t\texpected    bool\n\t\texpectedErr error\n\t}{\n\t\t{\n\t\t\tname: \"indirect_computed_userset_through_ttu_containing_exclusion\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define restricted: [user] as self\n\t\t\t    define editor: [user] as self but not restricted\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define editor as editor from parent\n\t\t\t    define viewer as editor\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"ttu_relations_containing_exclusion\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define restricted: [user] as self\n\t\t\t    define viewer: [user] as self but not restricted\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer as viewer from parent\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"indirect_relations_containing_exclusion\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define restricted: [user] as self\n\t\t\t    define editor: [user] as self but not restricted\n\t\t\t    define viewer as editor\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"undefined_type\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\t`,\n\t\t\trr:          DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected:    false,\n\t\t\texpectedErr: ErrObjectTypeUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"undefined_relation\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\t`,\n\t\t\trr:          DirectRelationReference(\"user\", \"viewer\"),\n\t\t\texpected:    false,\n\t\t\texpectedErr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_indirect_type_restriction_involving_exclusion\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype org\n\t\t\t  relations\n\t\t\t    define removed: [user] as self\n\t\t\t    define dept: [group] as self\n\t\t\t    define dept_member as member from dept\n\t\t\t    define dept_allowed_member as dept_member but not removed\n\n\t\t\ttype resource\n\t\t\t  relations\n\t\t\t    define reader: [user] as self or writer\n\t\t\t    define writer: [org#dept_allowed_member] as self\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"resource\", \"reader\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"indirect_relationship_through_type_restriction\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define restricted: [user] as self\n\t\t\t    define editor: [user] as self but not restricted\n\t\t\t    define viewer: [document#editor] as self\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"direct_relations_related_to_each_other\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype example\n\t\t\t  relations\n\t\t\t    define editor: [example#viewer] as self\n\t\t\t    define viewer: [example#editor] as self\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"example\", \"editor\"),\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname: \"cyclical_evaluation_of_tupleset\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype node\n\t\t\t  relations\n\t\t\t    define parent: [node] as self\n\t\t\t    define editor: [user] as self or editor from parent\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"node\", \"editor\"),\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\ttypedefs := parser.MustParse(test.model)\n\n\t\t\ttypesys := New(&openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: typedefs,\n\t\t\t})\n\n\t\t\tobjectType := test.rr.GetType()\n\t\t\trelationStr := test.rr.GetRelation()\n\n\t\t\tactual, err := typesys.RelationInvolvesExclusion(objectType, relationStr)\n\t\t\trequire.ErrorIs(t, err, test.expectedErr)\n\t\t\trequire.Equal(t, test.expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestIsTuplesetRelation(t *testing.T) {\n\n\ttests := []struct {\n\t\tname          string\n\t\tmodel         *openfgav1.AuthorizationModel\n\t\tobjectType    string\n\t\trelation      string\n\t\texpected      bool\n\t\texpectedError error\n\t}{\n\t\t{\n\t\t\tname:          \"undefined_object_type_returns_error\",\n\t\t\tobjectType:    \"document\",\n\t\t\trelation:      \"viewer\",\n\t\t\texpected:      false,\n\t\t\texpectedError: ErrObjectTypeUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"undefined_relation_returns_error\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType:    \"document\",\n\t\t\trelation:      \"viewer\",\n\t\t\texpected:      false,\n\t\t\texpectedError: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"direct_tupleset_relation\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": TupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"parent\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"tupleset_relation_under_union\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Union(\n\t\t\t\t\t\t\t\tThis(),\n\t\t\t\t\t\t\t\tTupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"parent\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"tupleset_relation_under_intersection\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Intersection(\n\t\t\t\t\t\t\t\tThis(),\n\t\t\t\t\t\t\t\tTupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"parent\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"tupleset_relation_under_exclusion\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Difference(\n\t\t\t\t\t\t\t\tThis(),\n\t\t\t\t\t\t\t\tTupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"parent\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"tupleset_relation_under_nested_union\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Intersection(\n\t\t\t\t\t\t\t\tThis(),\n\t\t\t\t\t\t\t\tUnion(TupleToUserset(\"parent\", \"viewer\")),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"parent\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"tupleset_relation_under_nested_intersection\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Union(\n\t\t\t\t\t\t\t\tThis(),\n\t\t\t\t\t\t\t\tIntersection(TupleToUserset(\"parent\", \"viewer\")),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"parent\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"tupleset_relation_under_nested_exclusion\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Union(\n\t\t\t\t\t\t\t\tThis(),\n\t\t\t\t\t\t\t\tDifference(This(), TupleToUserset(\"parent\", \"viewer\")),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"parent\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"not_a_tupleset_relation\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": TupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"viewer\",\n\t\t\texpected:   false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ttypesys := New(test.model)\n\n\t\t\tactual, err := typesys.IsTuplesetRelation(test.objectType, test.relation)\n\t\t\trequire.ErrorIs(t, err, test.expectedError)\n\t\t\trequire.Equal(t, test.expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestIsDirectlyRelated(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tmodel  string\n\t\ttarget *openfgav1.RelationReference\n\t\tsource *openfgav1.RelationReference\n\t\tresult bool\n\t}{\n\t\t{\n\t\t\tname: \"wildcard_and_wildcard\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user:*] as self\n\t\t\t`,\n\t\t\ttarget: DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tsource: WildcardRelationReference(\"user\"),\n\t\t\tresult: true,\n\t\t},\n\t\t{\n\t\t\tname: \"wildcard_and_direct\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user:*] as self\n\t\t\t`,\n\t\t\ttarget: DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tsource: DirectRelationReference(\"user\", \"\"),\n\t\t\tresult: false,\n\t\t},\n\t\t{\n\t\t\tname: \"direct_and_wildcard\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\t\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user] as self\n\t\t\t`,\n\t\t\ttarget: DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tsource: WildcardRelationReference(\"user\"),\n\t\t\tresult: false,\n\t\t},\n\t\t{\n\t\t\tname: \"direct_type\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\t\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user] as self\n\t\t\t`,\n\t\t\ttarget: DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tsource: DirectRelationReference(\"user\", \"\"),\n\t\t\tresult: true,\n\t\t},\n\t\t{\n\t\t\tname: \"relation_not_related\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\t  relations\n\t\t\t    define manager: [user] as self\n\t\t\t\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user] as self\n\t\t\t`,\n\t\t\ttarget: DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tsource: DirectRelationReference(\"user\", \"manager\"),\n\t\t\tresult: false,\n\t\t},\n\t\t{\n\t\t\tname: \"direct_and_userset\",\n\t\t\tmodel: `\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [group#member] as self\n\t\t\t\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttarget: DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tsource: DirectRelationReference(\"group\", \"member\"),\n\t\t\tresult: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\ttypedefs := parser.MustParse(test.model)\n\t\t\ttypesys := New(&openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion:   SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: typedefs,\n\t\t\t})\n\n\t\t\tok, err := typesys.IsDirectlyRelated(test.target, test.source)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, test.result, ok)\n\t\t})\n\t}\n}\n\nfunc TestIsPubliclyAssignable(t *testing.T) {\n\ttests := []struct {\n\t\tname       string\n\t\tmodel      string\n\t\ttarget     *openfgav1.RelationReference\n\t\tobjectType string\n\t\tresult     bool\n\t}{\n\t\t{\n\t\t\tname: \"1\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user:*] as self\n\t\t\t`,\n\t\t\ttarget:     DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tobjectType: \"user\",\n\t\t\tresult:     true,\n\t\t},\n\t\t{\n\t\t\tname: \"2\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user] as self\n\t\t\t`,\n\t\t\ttarget:     DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tobjectType: \"user\",\n\t\t\tresult:     false,\n\t\t},\n\t\t{\n\t\t\tname: \"3\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype employee\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [employee:*] as self\n\t\t\t`,\n\t\t\ttarget:     DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tobjectType: \"user\",\n\t\t\tresult:     false,\n\t\t},\n\t\t{\n\t\t\tname: \"4\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user:*] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttarget:     DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tobjectType: \"user\",\n\t\t\tresult:     false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\ttypedefs := parser.MustParse(test.model)\n\t\t\ttypesys := New(&openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion:   SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: typedefs,\n\t\t\t})\n\n\t\t\tok, err := typesys.IsPubliclyAssignable(test.target, test.objectType)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, ok, test.result)\n\t\t})\n\t}\n}\n\nfunc TestRewriteContainsExclusion(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tmodel    string\n\t\trr       *openfgav1.RelationReference\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname: \"simple_exclusion\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define restricted: [user] as self\n\t\t\t    define editor: [user] as self\n\t\t\t    define viewer: [user] as (self or editor) but not restricted\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"folder\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\ttypedefs := parser.MustParse(test.model)\n\n\t\t\ttypesys := New(&openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: typedefs,\n\t\t\t})\n\n\t\t\trel, err := typesys.GetRelation(test.rr.GetType(), test.rr.GetRelation())\n\t\t\trequire.NoError(t, err)\n\n\t\t\tactual := RewriteContainsExclusion(rel.GetRewrite())\n\t\t\trequire.Equal(t, test.expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestRewriteContainsIntersection(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tmodel    string\n\t\trr       *openfgav1.RelationReference\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname: \"simple_intersection\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define allowed: [user] as self\n\t\t\t    define editor: [user] as self\n\t\t\t    define viewer: [user] as (self or editor) and allowed\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"folder\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\ttypedefs := parser.MustParse(test.model)\n\n\t\t\ttypesys := New(&openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: typedefs,\n\t\t\t})\n\n\t\t\trel, err := typesys.GetRelation(test.rr.GetType(), test.rr.GetRelation())\n\t\t\trequire.NoError(t, err)\n\n\t\t\tactual := RewriteContainsIntersection(rel.GetRewrite())\n\t\t\trequire.Equal(t, test.expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestGetRelationReferenceAsString(t *testing.T) {\n\trequire.Equal(t, \"\", GetRelationReferenceAsString(nil))\n\trequire.Equal(t, \"team#member\", GetRelationReferenceAsString(DirectRelationReference(\"team\", \"member\")))\n\trequire.Equal(t, \"team:*\", GetRelationReferenceAsString(WildcardRelationReference(\"team\")))\n}\n\nfunc TestDirectlyRelatedUsersets(t *testing.T) {\n\ttests := []struct {\n\t\tname       string\n\t\tmodel      string\n\t\tobjectType string\n\t\trelation   string\n\t\texpected   []*openfgav1.RelationReference\n\t}{\n\t\t{\n\t\t\tname: \"only_direct_relation\",\n\t\t\tmodel: `type user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define allowed: [user] as self`,\n\t\t\tobjectType: \"folder\",\n\t\t\trelation:   \"allowed\",\n\t\t\texpected:   nil,\n\t\t},\n\t\t{\n\t\t\tname: \"with_public_relation\",\n\t\t\tmodel: `type user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define allowed: [user, user:*] as self`,\n\t\t\tobjectType: \"folder\",\n\t\t\trelation:   \"allowed\",\n\t\t\texpected: []*openfgav1.RelationReference{\n\t\t\t\tWildcardRelationReference(\"user\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"with_ttu_relation\",\n\t\t\tmodel: `type user\n            type group\n              relations\n                define member: [user] as self\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define allowed: [group#member] as self`,\n\t\t\tobjectType: \"folder\",\n\t\t\trelation:   \"allowed\",\n\t\t\texpected: []*openfgav1.RelationReference{\n\t\t\t\tDirectRelationReference(\"group\", \"member\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"mix_direct_and_public_relation\",\n\t\t\tmodel: `type user\n            type group\n              relations\n                define member: [user] as self\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define allowed: [group#member, user] as self`,\n\t\t\tobjectType: \"folder\",\n\t\t\trelation:   \"allowed\",\n\t\t\texpected: []*openfgav1.RelationReference{\n\t\t\t\tDirectRelationReference(\"group\", \"member\"),\n\t\t\t},\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\ttypedefs := parser.MustParse(test.model)\n\n\t\t\ttypesys := New(&openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: typedefs,\n\t\t\t})\n\t\t\tresult, err := typesys.DirectlyRelatedUsersets(test.objectType, test.relation)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, test.expected, result)\n\t\t})\n\t}\n}\n\nfunc TestHasTypeInfo(t *testing.T) {\n\ttests := []struct {\n\t\tname       string\n\t\tschema     string\n\t\tmodel      string\n\t\tobjectType string\n\t\trelation   string\n\t\texpected   bool\n\t}{\n\t\t{\n\t\t\tname:   \"has_type_info_true\",\n\t\t\tschema: SchemaVersion1_1,\n\t\t\tmodel: `type user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define allowed: [user] as self`,\n\t\t\tobjectType: \"folder\",\n\t\t\trelation:   \"allowed\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"has_type_info_false\",\n\t\t\tschema: SchemaVersion1_0,\n\t\t\tmodel: `type user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define allowed as self`,\n\t\t\tobjectType: \"folder\",\n\t\t\trelation:   \"allowed\",\n\t\t\texpected:   false,\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ttypesys := New(&openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion:   test.schema,\n\t\t\t\tTypeDefinitions: parser.MustParse(test.model),\n\t\t\t})\n\t\t\tresult, err := typesys.HasTypeInfo(test.objectType, test.relation)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, test.expected, result)\n\t\t})\n\t}\n}\n"], "fixing_code": ["# Changelog\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\nTry to keep listed changes to a concise bulleted list of simple explanations of changes. Aim for the amount of information needed so that readers can understand where they would look in the codebase to investigate the changes' implementation, or where they would look in the documentation to understand how to make use of the change in practice - better yet, link directly to the docs and provide detailed information there. Only elaborate if doing so is required to avoid breaking changes or experimental features from ruining someone's day.\n\n## [Unreleased]\n\n## [1.3.2] - 2023-08-25\n### Added\n* Support TLS for OTLP trace endpoint ([#885](https://github.com/openfga/openfga/pull/885)) - thanks @matoous\n* Configurable limits to database reads per ListObjects query ([#967](https://github.com/openfga/openfga/pull/967))\n* Datastore query count labels to traces and query latency histogram in ListObjects ([#959](https://github.com/openfga/openfga/pull/959))\n* Github workflow to check markdown links ([#1016](https://github.com/openfga/openfga/pull/1016)) - thanks @sanketrai1\n\n### Fixed\n* Change response code to internal error for concurrency conflicts ([#1011](https://github.com/openfga/openfga/pull/1011))\n\n### Changed\n* Use slices and maps packages from go1.21 ([#969](https://github.com/openfga/openfga/pull/969)) - thanks @tranngoclam\n* Moved request validations to RPC handlers so library integrations benefit ([#975](https://github.com/openfga/openfga/pull/975), [#998](https://github.com/openfga/openfga/pull/998))\n* Refactored internal usages of ConnectedObjects to ReverseExpand ([#968](https://github.com/openfga/openfga/pull/968))\n* Expose validation middleware ([#1005](https://github.com/openfga/openfga/pull/1005))\n* Upgrade grpc validator middleware to the latest v2 package ([#1019](https://github.com/openfga/openfga/pull/1019)) - thanks @tranngoclam\n\n### Security\n* Patches [CVE-2023-43645](https://github.com/openfga/openfga/security/advisories/GHSA-2hm9-h873-pgqh) - see the CVE for more details\n\n  **[BREAKING]** If your model contained cycles or a relation definition that has the relation itself in its evaluation path, then Checks and queries that require evaluation will no longer be evaluated on v1.3.2+ and will return errors instead. You will need to update your models to remove the cycles.\n\n## [1.3.1] - 2023-08-23\n\n### Added\n* Count datastore queries involved in Check resolution metadata ([#880](https://github.com/openfga/openfga/pull/880))\n\n  OpenFGA request logs and traces will now include a field `datastore_query_count` that shows how many queries were involved in a single Check resolution.\n\n* Histogram metric to report the `datastore_query_count` per Check ([#924](https://github.com/openfga/openfga/pull/932))\n\n  This new metric can be used to report percentiles of the number of database queries required to resolve Check requests.\n\n* Check request duration histogram labeled by method and datastore query count ([#950](https://github.com/openfga/openfga/pull/950))\n\n  The `request_duration_by_query_count_ms` metric reports the total request duration (in ms) labelled by the RPC method and ranges of observations for the `datastore_query_count`. This metrics allows operators of an OpenFGA server to report request duration percentiles for Check requests based on the number of database queries that were required to resolve the query.\n\n* Optimize Check to avoid database lookups in some scenarios ([#932](https://github.com/openfga/openfga/pull/932))\n\n* CachedCheckResolver for caching Check subproblems ([#891](https://github.com/openfga/openfga/pull/891))\n\n  This experimental feature adds new caching capabilities to the OpenFGA server. It is an \"opt-in\" feature and thus must be enabled. To enable this feature you must specify the experimental flag `check-query-cache` and set the  `--check-query-cache-enabled=true` flag.\n\n  ```shell\n  openfga run --experimentals check-query-cache --check-query-cache-enabled=true\n  ```\n\n* Server request logs now include the `user-agent` ([#943](https://github.com/openfga/openfga/pull/943))\n\n### Changed\n* Default Check and ListObjects concurrency read limits ([#916](https://github.com/openfga/openfga/pull/916))\n\n  In our last release [v1.3.0](https://github.com/openfga/openfga/releases/tag/v1.3.0) we modified the default behavior of Check and ListObjects such that it limits/restricts the degree of concurrency that is allowed for a single request. This change was unintended. This release reverts the default behavior back to unbounded concurrency limits (the prior default). The change mostly affects those using OpenFGA as a library.\n\n* Bumped up to Go 1.21 ([#952](https://github.com/openfga/openfga/pull/952))\n\n### Security\n* Patches [CVE-2023-40579](https://github.com/openfga/openfga/security/advisories/GHSA-jcf2-mxr2-gmqp) - see the CVE for more details\n\n## [1.3.0] - 2023-08-01\n\n[Full changelog](https://github.com/openfga/openfga/compare/v1.2.0...v1.3.0)\n\n### Added\n* Bounded concurrency limiter for Check and ListObjects queries ([#860](https://github.com/openfga/openfga/pull/860), [#887](https://github.com/openfga/openfga/pull/887))\n  New server configurations can be provided to limit/bound the amount of concurrency that is allowed during query evaluation. These settings can help reduce the impact/burden that a single query (e.g. Check, ListObjects, etc..) can have on the underlying database and OpenFGA server.\n\n  * `--maxConcurrentReadsForListObjects` - The maximum allowed number of concurrent reads in a single ListObjects query.\n\n  * `--maxConcurrentReadsForCheck` - The maximum allowed number of concurrent reads in a single Check query.\n\n  * `--resolveNodeBreadthLimit` - Defines how many nodes on a given level can be evaluated concurrently in a Check resolution tree.\n\n* Jaeger persistent storage for traces in `docker-compose.yaml` ([#888](https://github.com/openfga/openfga/pull/888)) - thanks @Azanul\n\n### Fixed\n* Disable default debug level-logging in `retryablehttp` client ([#882](https://github.com/openfga/openfga/pull/882)) - thanks @KlausVii\n\n### Changed\n* [BREAKING] Imports for OpenFGA protobuf API dependencies ([#898](https://github.com/openfga/openfga/pull/898))\n  * **Problem** - Previously we depended on [Buf remote generated packages](https://buf.build/docs/bsr/remote-packages/overview), but they recently deprecated protobuf imports served from the `go.buf.build` domain (see [Migrate from remote generation alpha](https://buf.build/docs/migration-guides/migrate-remote-generation-alpha)). OpenFGA builds are currently broken as a result of this.\n  * **Change** - We switched our protobuf API dependency from `go.buf.build/openfga/go/openfga/api/openfga/v1` to `github.com/openfga/api/proto/openfga/v1`. So we no longer use Buf remote generated packages in favor of packages we managed in the [`openfga/api`](https://github.com/openfga/api) repository. This fixes existing build issues.\n  * **Impact** - Developers using the OpenFGA as a library or the gRPC API must change their protobuf dependency from `go.buf.build/openfga/go/openfga/api/openfga/v1` to `github.com/openfga/api/proto/openfga/v1`. A global find/replace and package depedency update should fix it. Here's a diff demonstrating the changes for a Go app, for example:\n\n    ```go\n    import (\n      ...\n    - openfgav1 \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n    + openfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n    )\n    ```\n\n* Refactor the `Server` constructor to use the options builder pattern ([#833](https://github.com/openfga/openfga/pull/833))\n\n  ```go\n  import (\n    openfga \"github.com/openfga/openfga/pkg/server\"\n  )\n\n  s := openfga.New(\n    &server.Dependencies{...},\n    &server.Config{...},\n  )\n  ```\n  becomes\n  ```go\n  import (\n    openfga \"github.com/openfga/openfga/pkg/server\"\n  )\n\n  var opts []openfga.OpenFGAServiceV1Option\n  s := openfga.MustNewServerWithOpts(opts...)\n  ```\n## [1.2.0] - 2023-06-30\n\n[Full changelog](https://github.com/openfga/openfga/compare/v1.1.1...v1.2.0)\n\n### Added\n* Optimizations for [ListObjects](https://openfga.dev/api/service#/Relationship%20Queries/ListObjects) and [StreamedListObjects](https://openfga.dev/api/service#/Relationship%20Queries/StreamedListObjects) for models involving intersection (`and`) and exclusion (`but not`) ([#797](https://github.com/openfga/openfga/pull/797))\n\n### Changed\n* Cache model validation results on first model load ([#831](https://github.com/openfga/openfga/pull/831))\n* Cache inflight requests when looking up any authorization model ([#831](https://github.com/openfga/openfga/pull/831))\n* Update postgres max connections in docker compose file ([#829](https://github.com/openfga/openfga/pull/829))\n\n## [1.1.1] - 2023-06-26\n\n[Full changelog](https://github.com/openfga/openfga/compare/v1.1.0...v1.1.1)\n\n### Added\n* Official Homebrew installation instructions ([#781](https://github.com/openfga/openfga/pull/781)) - thanks @chenrui333\n* The `--verbose` flag has been added to the `openfga migrate` command ([#776](https://github.com/openfga/openfga/pull/776))\n* The `openfga validate-models` CLI command has been introduced to validate all models across all stores ([#817](https://github.com/openfga/openfga/pull/817))\n\n### Changed\n* Updated the version of the `grpc-health-probe` binary included in OpenFGA builds ([#784](https://github.com/openfga/openfga/pull/784))\n* Cache inflight requests when looking up the latest authorization model ([#820](https://github.com/openfga/openfga/pull/820))\n\n### Fixed\n* Validation of models with non-zero entrypoints ([#802](https://github.com/openfga/openfga/pull/802))\n* Remove unintended newlines in model validation error messages ([#816](https://github.com/openfga/openfga/pull/816)) - thanks @Galzzly\n\n### Security\n* Patches [CVE-2023-35933](https://github.com/openfga/openfga/security/advisories/GHSA-hr9r-8phq-5x8j) - additional model validations are now applied to models that can lead to the vulnerability. See the CVE report for more details, and don't hesitate to reach out if you have questions.\n\n## [1.1.0] - 2023-05-15\n\n[Full changelog](https://github.com/openfga/openfga/compare/v1.0.1...v1.1.0)\n\n## Added\n* Streaming ListObjects has no limit in number of results returned ([#733](https://github.com/openfga/openfga/pull/733))\n* Add Homebrew release stage to goreleaser's release process ([#716](https://github.com/openfga/openfga/pull/716))\n\n## Fixed\n* Avoid DB connection churning in unoptimized ListObjects ([#711](https://github.com/openfga/openfga/pull/711))\n* Ensure ListObjects respects configurable ListObjectsDeadline ([#704](https://github.com/openfga/openfga/pull/704))\n* In Write, throw 400 instead of 500 error if auth model ID not found ([#725](https://github.com/openfga/openfga/pull/725))\n* Performance improvements when loading the authorization model ([#726](https://github.com/openfga/openfga/pull/726))\n* Ensure Check evaluates deterministically on the eval boundary case ([#732](https://github.com/openfga/openfga/pull/732))\n\n## Changed\n* [BREAKING] The flags to turn on writing and evaluation of `v1.0` models have been dropped ([#763](https://github.com/openfga/openfga/pull/763))\n\n## [1.0.1] - 2023-04-18\n\n[Full changelog](https://github.com/openfga/openfga/compare/v1.0.0...v1.0.1)\n\n## Fixed\n* Correct permission and location for gRPC health probe in Docker image (#697)\n\n## [1.0.0] - 2023-04-14\n\n[Full changelog](https://github.com/openfga/openfga/compare/v0.4.3...v1.0.0)\n\n## Ready for Production with Postgres \nOpenFGA with Postgres is now considered stable and ready for production usage.\n\n## Fixed\n* MySQL migration script errors during downgrade (#664)\n\n## [0.4.3] - 2023-04-12\n\n[Full changelog](https://github.com/openfga/openfga/compare/v0.4.2...v0.4.3)\n\n## Added\n* Release artifacts are now signed and include a Software Bill of Materials (SBOM) ([#683](https://github.com/openfga/openfga/pull/683))\n\n  The SBOM (Software Bill of Materials) is included in each Github release using [Syft](https://github.com/anchore/syft) and is exported in [SPDX](https://spdx.dev) format.\n\n  Developers will be able to verify the signature of the release artifacts with the following workflow(s):\n\n  ```shell\n  wget https://github.com/openfga/openfga/releases/download/<tag>/checksums.txt\n\n  cosign verify-blob \\\n    --certificate-identity 'https://github.com/openfga/openfga/.github/workflows/release.yml@refs/tags/<tag>' \\\n    --certificate-oidc-issuer 'https://token.actions.githubusercontent.com' \\\n    --cert https://github.com/openfga/openfga/releases/download/<tag>/checksums.txt.pem \\\n    --signature https://github.com/openfga/openfga/releases/download/<tag>/checksums.txt.sig \\\n    ./checksums.txt\n  ```\n\n  If the `checksums.txt` validation succeeds, it means the checksums included in the release were not tampered with, so we can use it to verify the hashes of other files using the `sha256sum` utility. You can then download any file you want from the release, and verify it with, for example:\n\n  ```shell\n  wget https://github.com/openfga/openfga/releases/download/<tag>/openfga_<version>_linux_amd64.tar.gz.sbom\n  wget https://github.com/openfga/openfga/releases/download/<tag>/openfga_<version>_linux_amd64.tar.gz\n\n  sha256sum --ignore-missing -c checksums.txt\n  ```\n\n  And both should say \"OK\".\n\n  You can then inspect the .sbom file to see the entire dependency tree of the binary.\n\n  Developers can also verify the Docker image signature. Cosign actually embeds the signature in the image manifest, so we only need the public key used to sign it in order to verify its authenticity:\n\n  ```shell\n  cosign verify -key cosign.pub openfga/openfga:<tag>\n  ```\n\n* `openfga migrate` now accepts reading configuration from a config file and environment variables like the `openfga run` command ([#655](https://github.com/openfga/openfga/pull/655)) - thanks @suttod!\n\n* The `--trace-service-name` command-line flag has been added to allow for customizing the service name in traces ([#652](https://github.com/openfga/openfga/pull/652)) - thanks @jmiettinen\n\n## Fixed\n* Postgres and MySQL implementations have been fixed to avoid ordering relationship tuple queries by `ulid` when it is not needed. This can improve read query performance on larger OpenFGA stores ([#677](https://github.com/openfga/openfga/pull/677))\n* Synchronize concurrent access to in-memory storage iterators ([#587](https://github.com/openfga/openfga/pull/587))\n* Improve error logging in the `openfga migrate` command ([#663](https://github.com/openfga/openfga/pull/663))\n* Fix middleware ordering so that `requestid` middleware is registered earlier ([#662](https://github.com/openfga/openfga/pull/662))\n\n## Changed\n* Bumped up to Go version 1.20 ([#664](https://github.com/openfga/openfga/pull/664))\n* Default model schema versions to 1.1 ([#669](https://github.com/openfga/openfga/pull/669))\n\n  In preparation for sunsetting support for models with schema version 1.0, the [WriteAuthorizationModel API](https://openfga.dev/api/service#/Authorization%20Models/WriteAuthorizationModel) will now interpret any model provided to it as a 1.1 model if the `schema_version` field is omitted in the request. This shouldn't affect default behavior since 1.0 model support is enabled by default.\n\n## [0.4.2] - 2023-03-17\n\n[Full changelog](https://github.com/openfga/openfga/compare/v0.4.1...v0.4.2)\n\n### Fixed\n* Correct migration path for mysql in `openfga migrate` ([#644](https://github.com/openfga/openfga/pull/664))\n\n## [0.4.1] - 2023-03-16\n\n[Full changelog](https://github.com/openfga/openfga/compare/v0.4.0...v0.4.1)\n\n\nThe `v0.4.1` release includes everything in `v0.4.0` which includes breaking changes, please read the [`v0.4.0` changelog entry](#040---2023-03-15) for more details.\n\n### Fixed\n\n* Fix ListObjects not returning objects a user has access to in some cases (openfga/openfga#637)\n\n## [0.4.0] - 2023-03-15\n\n[Full changelog](https://github.com/openfga/openfga/compare/v0.3.7...v0.4.0)\n\n> Note: the 0.4.0 release was held due to issues discovered after the release was cut.\n\n### Removed\n\n* [BREAKING] Disable schema 1.0 support, except if appropriate flags are set (openfga/openfga#613)\n  * As of this release, OpenFGA no longer allows writing or evaluating schema `v1.0` models by default. If you need support for it for now, you can use the:\n    * `OPENFGA_ALLOW_WRITING_1_0_MODELS`: set to `true` to allow `WriteAuthorizationModel` to accept schema `v1.0` models.\n    * `OPENFGA_ALLOW_EVALUATING_1_0_MODELS`: set to `true` to allow `Check`, `Expand`, `ListObjects`, `Write` and `WriteAssertions` that target schema `v1.0` models.\n    * `ReadAuthorizationModel`, `ReadAuthorizationModels` and `ReadAssertions` are unaffected and will continue to work regardless of the target model schema version.\n  * Note that these flags will be removed and support fully dropped in a future release. Read the [Schema v1.0 Deprecation Timeline](https://openfga.dev/docs/modeling/migrating/migrating-schema-1-1#deprecation-timeline) for more details.\n\n### Added\n* Add OpenFGA version command to the CLI ([#625](https://github.com/openfga/openfga/pull/625))\n* Add `timeout` flag to `migrate` command ([#634](https://github.com/openfga/openfga/pull/634))\n\n### Fixed\n\n* Improve the speed of Check for 1.1 models by using type restrictions (([#545](https://github.com/openfga/openfga/pull/545), ([#596](https://github.com/openfga/openfga/pull/596))\n* Various important fixes to the experimental ListObjects endpoint\n  * Improve readUsersets query by dropping unnecessary sorting ([#631](https://github.com/openfga/openfga/pull/631),([#633](https://github.com/openfga/openfga/pull/633))\n  * Fix null pointer exception if computed userset does not exist ([#572](https://github.com/openfga/openfga/pull/572))\n  * Fix race condition in memory store ([#585](https://github.com/openfga/openfga/pull/585))\n  * Ensure no objects returned that would not have been allowed in Checks ([#577](https://github.com/openfga/openfga/pull/577))\n  * Reverse expansion with indirect computed userset relationship ([#611](https://github.com/openfga/openfga/pull/611))\n  * Improved tests ([#582](https://github.com/openfga/openfga/pull/582), [#599](https://github.com/openfga/openfga/pull/599), [#601](https://github.com/openfga/openfga/pull/601), [#620](https://github.com/openfga/openfga/pull/620))\n* Tuning of OTEL parameters ([#570](https://github.com/openfga/openfga/pull/570))\n* Fix tracing in Check API ([#627](https://github.com/openfga/openfga/pull/627))\n* Use chainguard images in Dockerfile ([#628](https://github.com/openfga/openfga/pull/628))\n\n\n## [0.3.7] - 2023-02-21\n\n[Full changelog](https://github.com/openfga/openfga/compare/v0.3.6...v0.3.7)\n\n### Fixed\n* Contextual tuple propagation in the unoptimized ListObjects implementation ([#565](https://github.com/openfga/openfga/pull/565))\n\n## [0.3.6] - 2023-02-16\n\n[Full changelog](https://github.com/openfga/openfga/compare/v0.3.5...v0.3.6)\n\nRe-release of `v0.3.5` because the go module proxy cached a prior commit of the `v0.3.5` tag.\n\n## [0.3.5] - 2023-02-14\n\n[Full changelog](https://github.com/openfga/openfga/compare/v0.3.4...v0.3.5)\n\n### Added\n* [`grpc-health-probe`](https://github.com/grpc-ecosystem/grpc-health-probe) for Health Checks ([#520](https://github.com/openfga/openfga/pull/520))\n\n  OpenFGA containers now include an embedded `grpc_health_probe` binary that can be used to probe the Health Check endpoints of OpenFGA servers. Take a look at the [docker-compose.yaml](https://github.com/openfga/openfga/blob/main/docker-compose.yaml) file for an example.\n\n* Improvements to telemetry: logging, tracing, and metrics ([#468](https://github.com/openfga/openfga/pull/468), [#514](https://github.com/openfga/openfga/pull/514), [#517](https://github.com/openfga/openfga/pull/517), [#522](https://github.com/openfga/openfga/pull/522))\n\n  * We have added Prometheus as the standard metrics provided for OpenFGA and provide a way to launch Grafana to view the metrics locally. See [docker-compose.yaml](https://github.com/openfga/openfga/blob/main/docker-compose.yaml) for more information.\n\n  * We've improved the attributes of various trace spans and made sure that trace span names align with the functions they decorate.\n\n  * Our logging has been enhanced with more logged fields including request level logging which includes a `request_id` and `store_id` field in the log message.\n\n  These features will allow operators of OpenFGA to improve their monitoring and observability processes.\n\n* Nightly releases ([#508](https://github.com/openfga/openfga/pull/508)) - thanks @Siddhant-K-code!\n\n  You should now be able to run nightly releases of OpenFGA using `docker pull openfga/openfga:nightly`\n\n### Fixed\n* Undefined computed relations on tuplesets now behave properly ([#532](https://github.com/openfga/openfga/pull/532))\n\n  If you had a model involing two different computed relations on the same tupleset, then it's possible you may have received an internal server error if one of the computed relations was undefined. For example,\n  ```\n  type document\n    relations\n      define parent as self\n      define viewer as x from parent or y from parent\n\n  type folder\n    relations\n      define x as self\n\n  type org\n    relations\n      define y as self\n  ```\n  Given the tuple `{ user: \"org:contoso\", relation: \"parent\", object: \"document:1\" }`, then `Check({ user: \"jon\", relation: \"viewer\", object: \"document:1\" })` would return an error prior to this fix because the `x` computed relation on the `document#parent` tupleset relation is not defined for the `org` object type.\n\n* Eliminate duplicate objects in ListObjects response ([#528](https://github.com/openfga/openfga/pull/528))\n\n## [0.3.4] - 2023-02-02\n\n[Full changelog](https://github.com/openfga/openfga/compare/v0.3.3...v0.3.4)\n\n### Fixed\n\n* Fixed the environment variable mapping ([#498](https://github.com/openfga/openfga/pull/498)). For the full list of environment variables see [.config-schema.json](https://github.com/openfga/openfga/blob/main/.config-schema.json).\n* Fix for stack overflow error in ListObjects ([#506](https://github.com/openfga/openfga/pull/506)). Thank you for reporting the issue @wonderbeyond!\n\n### Added\n\n* Added OpenTelemetry tracing ([#499](https://github.com/openfga/openfga/pull/499))\n\n### Removed\n\n* The ReadTuples endpoint has been removed ([#495](https://github.com/openfga/openfga/pull/495)). Please use [Read](https://openfga.dev/api/service#/Relationship%20Tuples/Read) with no tuple key instead (e.g. `POST /stores/<store_id>/read` with `{}` as the body).\n\n## [0.3.3] - 2023-01-31\n\n[Full changelog](https://github.com/openfga/openfga/compare/v0.3.2...v0.3.3)\n\n### Added\n\n* Environment variable names have been updated ([#472](https://github.com/openfga/openfga/pull/472)).\n\n  For example, `OPENFGA_MAX_TUPLES_PER_WRITE` instead of `OPENFGA_MAXTUPLESPERWRITE`.\n\n  For the full list please see [.config-schema.json](https://github.com/openfga/openfga/blob/main/.config-schema.json).\n\n  The old form still works but is considered deprecated and should not be used anymore.\n\n* Optimized ListObjects is now on by default ([#489](https://github.com/openfga/openfga/pull/489)) (`--experimentals=\"list-objects-optimized\"` is no longer needed)\n\n* Avoid connection churn in our datastore implementations ([#474](https://github.com/openfga/openfga/pull/474))\n\n* The default values for `OPENFGA_DATASTORE_MAX_OPEN_CONNS` and `OPENFGA_DATASTORE_MAX_IDLE_CONNS` have been set to 30 and 10 respectively ([#492](https://github.com/openfga/openfga/pull/492))\n\n### Fixed\n\n* ListObjects should no longer return duplicates ([#475](https://github.com/openfga/openfga/pull/475))\n\n## [0.3.2] - 2023-01-18\n\n[Full changelog](https://github.com/openfga/openfga/compare/v0.3.1...v0.3.2)\n\n\n### Added\n* OpenTelemetry metrics integration with an `otlp` exporter ([#360](https://github.com/openfga/openfga/pull/360)) - thanks @AlexandreBrg!\n\n  To export OpenTelemetry metrics from an OpenFGA instance you can now provide the `otel-metrics` experimental flag along with the `--otel-telemetry-endpoint` and `--otel-telemetry-protocol` flags. For example,\n\n  ```\n  ./openfga run --experimentals=otel-metrics --otel-telemetry-endpoint=127.0.0.1:4317 --otel-telemetry-protocol=http\n  ```\n\n  For more information see the official documentation on [Experimental Features](https://openfga.dev/docs/getting-started/setup-openfga/docker#experimental-features) and [Telemetry](https://openfga.dev/docs/getting-started/setup-openfga/docker#telemetry).\n\n* Type-bound public access support in the optimized ListObjects implementation (when the `list-objects-optimized` experimental feature is enabled) ([#444](https://github.com/openfga/openfga/pull/444))\n\n### Fixed\n* Tuple validations for models with schema version 1.1 ([#446](https://github.com/openfga/openfga/pull/446), [#457](https://github.com/openfga/openfga/pull/457))\n* Evaluate rewrites on nested usersets in the optimized ListObjects implementation ([#432](https://github.com/openfga/openfga/pull/432))\n\n## [0.3.1] - 2022-12-19\n\n[Full changelog](https://github.com/openfga/openfga/compare/v0.3.0...v0.3.1)\n\n### Added\n* Datastore configuration flags to control connection pool settings\n  `--datastore-max-open-conns`\n  `--datastore-max-idle-conns`\n  `--datastore-conn-max-idle-time`\n  `--datastore-conn-max-lifetime`\n  These flags can be used to fine-tune database connections for your specific deployment of OpenFGA.\n\n* Log level configuration flags\n  `--log-level` (can be one of ['none', 'debug', 'info', 'warn', 'error', 'panic', 'fatal'])\n\n* Support for Experimental Feature flags\n  A new flag `--experimentals` has been added to enable certain experimental features in OpenFGA. For more information see [Experimental Features](https://openfga.dev/docs/getting-started/setup-openfga/docker#experimental-features).\n\n### Security\n* Patches [CVE-2022-23542](https://github.com/openfga/openfga/security/advisories/GHSA-m3q4-7qmj-657m) - relationship reads now respect type restrictions from prior models ([#422](https://github.com/openfga/openfga/pull/422)).\n\n## [0.3.0] - 2022-12-12\n\n[Full changelog](https://github.com/openfga/openfga/compare/v0.2.5...v0.3.0)\n\nThis release comes with a few big changes:\n\n### Support for [v1.1 JSON Schema](https://github.com/openfga/rfcs/blob/feat/add-type-restrictions-to-json-syntax/20220831-add-type-restrictions-to-json-syntax.md)\n\n- You can now write your models in the [new DSL](https://github.com/openfga/rfcs/blob/type-restriction-dsl/20221012-add-type-restrictions-to-dsl-syntax.md)\nwhich the Playground and the [syntax transformer](https://github.com/openfga/syntax-transformer) can convert to the\nJSON syntax. Schema v1.1 allows for adding type restrictions to each assignable relation, and it can be used to\nindicate cases such as \"The folder's parent must be a folder\" (and so not a user or a document).\n  - This change also comes with breaking changes to how `*` and `<type>:*` are treated:\n  - `<type>:*` is interpreted differently according to the model version. v1.0 will interpret it as a object of type\n    `<type>` and id `*`, whereas v1.1 will interpret is as all objects of type `<type>`.\n  - `*` is still supported in v1.0 models, but not supported in v1.1 models. A validation error will be thrown when\n    used in checks or writes and it will be ignored when evaluating.\n- Additionally, the change to v1.1 models allows us to provide more consistent validation when writing the model\ninstead of when issuing checks.\n\n:warning: Note that with this release **models with schema version 1.0 are now considered deprecated**, with the plan to\ndrop support for them over the next couple of months, please migrate to version 1.1 when you can. Read more about\n[migrating to the new syntax](https://openfga.dev/docs/modeling/migrating/migrating-schema-1-1).\n\n### ListObjects changes\n\nThe response has changed to include the object type, for example:\n```json\n{ \"object_ids\": [ \"a\", \"b\", \"c\" ] }\n```\nto\n```json\n{ \"objects\": [ \"document:a\", \"document:b\", \"document:c\" ] }\n```\n\nWe have also improved validation and fixed support for Contextual Tuples that were causing inaccurate responses to be\nreturned.\n\n### ReadTuples deprecation\n\n:warning:This endpoint is now marked as deprecated, and support for it will be dropped shortly. Please use Read with\nno tuple key instead.\n\n\n## [0.2.5] - 2022-11-07\n### Security\n* Patches [CVE-2022-39352](https://github.com/openfga/openfga/security/advisories/GHSA-3gfj-fxx4-f22w)\n\n### Added\n* Multi-platform container build manifests to releases ([#323](https://github.com/openfga/openfga/pull/323))\n\n### Fixed\n* Read RPC returns correct error when authorization model id is not found ([#312](https://github.com/openfga/openfga/pull/312))\n* Throw error if `http.upstreamTimeout` config is less than `listObjectsDeadline` ([#315](https://github.com/openfga/openfga/pull/315))\n\n## [0.2.4] - 2022-10-24\n### Security\n* Patches [CVE-2022-39340](https://github.com/openfga/openfga/security/advisories/GHSA-95x7-mh78-7w2r), [CVE-2022-39341](https://github.com/openfga/openfga/security/advisories/GHSA-vj4m-83m8-xpw5), and [CVE-2022-39342](https://github.com/openfga/openfga/security/advisories/GHSA-f4mm-2r69-mg5f)\n\n### Fixed\n* TLS certificate config path mappings ([#285](https://github.com/openfga/openfga/pull/285))\n* Error message when a `user` field is invalid ([#278](https://github.com/openfga/openfga/pull/278))\n* host:port mapping with unspecified host ([#275](https://github.com/openfga/openfga/pull/275))\n* Wait for connection to postgres before starting ([#270](https://github.com/openfga/openfga/pull/270))\n\n\n### Added\n* Update Go to 1.19\n\n## [0.2.3] - 2022-10-05\n### Added\n* Support for MySQL storage backend ([#210](https://github.com/openfga/openfga/pull/210)). Thank you @MidasLamb!\n* Allow specification of type restrictions in authorization models ([#223](https://github.com/openfga/openfga/pull/223)). Note: Type restriction is not enforced yet, this just allows storing them.\n* Tuple validation against type restrictions in Write API ([#232](https://github.com/openfga/openfga/pull/232))\n* Upgraded the Postgres storage backend to use pgx v5 ([#225](https://github.com/openfga/openfga/pull/225))\n\n### Fixed\n* Close database connections after migration ([#252](https://github.com/openfga/openfga/pull/252))\n* Race condition in streaming ListObjects ([#255](https://github.com/openfga/openfga/pull/255), [#256](https://github.com/openfga/openfga/pull/256))\n\n\n## [0.2.2] - 2022-09-15\n### Fixed\n* Reject direct writes if only indirect relationship allowed ([#114](https://github.com/openfga/openfga/pull/114)). Thanks @dblclik!\n* Log internal errors at the grpc layer ([#222](https://github.com/openfga/openfga/pull/222))\n* Authorization model validation ([#224](https://github.com/openfga/openfga/pull/224))\n* Bug in `migrate` command ([#236](https://github.com/openfga/openfga/pull/236))\n* Skip malformed tuples involving tuple to userset definitions ([#234](https://github.com/openfga/openfga/pull/234))\n\n## [0.2.1] - 2022-08-30\n### Added\n* Support Check API calls on userset types of users ([#146](https://github.com/openfga/openfga/pull/146))\n* Add backoff when connecting to Postgres ([#188](https://github.com/openfga/openfga/pull/188))\n\n### Fixed\n* Improve logging of internal server errors ([#193](https://github.com/openfga/openfga/pull/193))\n* Use Postgres in the sample Docker Compose file ([#195](https://github.com/openfga/openfga/pull/195))\n* Emit authorization errors ([#144](https://github.com/openfga/openfga/pull/144))\n* Telemetry in Check and ListObjects APIs ([#177](https://github.com/openfga/openfga/pull/177))\n* ListObjects API: respect the value of ListObjectsMaxResults ([#181](https://github.com/openfga/openfga/pull/181))\n\n\n## [0.2.0] - 2022-08-12\n### Added\n* [ListObjects API](https://openfga.dev/api/service#/Relationship%20Queries/ListObjects)\n\n  The ListObjects API provides a way to list all of the objects (of a particular type) that a user has a relationship with. It provides a solution to the [Search with Permissions (Option 3)](https://openfga.dev/docs/interacting/search-with-permissions#option-3-build-a-list-of-ids-then-search) use case for access-aware filtering on smaller object collections. It implements the [ListObjects RFC](https://github.com/openfga/rfcs/blob/main/20220714-listObjects-api.md).\n\n  This addition brings with it two new server configuration options `--listObjects-deadline` and `--listObjects-max-results`. These configurations help protect the server from excessively long lived and large responses.\n\n  > \u26a0\ufe0f If `--listObjects-deadline` or `--listObjects-max-results` are provided, the endpoint may only return a subset of the data. If you provide the deadline but returning all of the results would take longer than the deadline, then you may not get all of the results. If you limit the max results to 1, then you'll get at most 1 result.\n\n* Support for presharedkey authentication in the Playground ([#141](https://github.com/openfga/openfga/pull/141))\n\n  The embedded Playground now works if you run OpenFGA using one or more preshared keys for authentication. OIDC authentication remains unsupported for the Playground at this time.\n\n\n## [0.1.7] - 2022-07-29\n### Added\n* `migrate` CLI command ([#56](https://github.com/openfga/openfga/pull/56))\n\n  The `migrate` command has been added to the OpenFGA CLI to assist with bootstrapping and managing database schema migrations. See the usage for more info.\n\n  ```\n  \u279c openfga migrate -h\n  The migrate command is used to migrate the database schema needed for OpenFGA.\n\n  Usage:\n    openfga migrate [flags]\n\n  Flags:\n        --datastore-engine string   (required) the database engine to run the migrations for\n        --datastore-uri string      (required) the connection uri of the database to run the migrations against (e.g. 'postgres://postgres:password@localhost:5432/postgres')\n    -h, --help                      help for migrate\n        --version uint              the version to migrate to (if omitted the latest schema will be used)\n  ```\n\n## [0.1.6] - 2022-07-27\n### Fixed\n* Issue with embedded Playground assets found in the `v0.1.5` released docker image ([#129](https://github.com/openfga/openfga/pull/129))\n\n## [0.1.5] - 2022-07-27\n### Added\n* Support for defining server configuration in `config.yaml`, CLI flags, or env variables ([#63](https://github.com/openfga/openfga/pull/63), [#92](https://github.com/openfga/openfga/pull/92), [#100](https://github.com/openfga/openfga/pull/100))\n\n  `v0.1.5` introduces multiple ways to support a variety of server configuration strategies. You can configure the server with CLI flags, env variables, or a `config.yaml` file.\n\n  Server config will be loaded in the following order of precedence:\n\n    * CLI flags (e.g. `--datastore-engine`)\n    * env variables (e.g. `OPENFGA_DATASTORE_ENGINE`)\n    * `config.yaml`\n\n  If a `config.yaml` file is provided, the OpenFGA server will look for it in `\"/etc/openfga\"`, `\"$HOME/.openfga\"`, or `\".\"` (the current working directory), in that order.\n\n* Support for grpc health checks ([#86](https://github.com/openfga/openfga/pull/86))\n\n  `v0.1.5` introduces support for the [GRPC Health Checking Protocol](https://github.com/grpc/grpc/blob/master/doc/health-checking.md). The server's health can be checked with the grpc or HTTP health check endpoints (the `/healthz` endpoint is just a proxy to the grpc health check RPC).\n\n  For example,\n  ```\n  grpcurl -plaintext \\\n    -d '{\"service\":\"openfga.v1.OpenFGAService\"}' \\\n    localhost:8081 grpc.health.v1.Health/Check\n  ```\n  or, if the HTTP server is enabled, with the `/healthz` endpoint:\n  ```\n  curl --request GET -d '{\"service\":\"openfga.v1.OpenFGAService\"}' http://localhost:8080/healthz\n  ```\n\n* Profiling support (pprof) ([#111](https://github.com/openfga/openfga/pull/111))\n\n  You can now profile the OpenFGA server while it's running using the [pprof](https://github.com/google/pprof/blob/main/doc/README.md) profiler. To enable the pprof profiler set `profiler.enabled=true`. It is served on the `/debug/pprof` endpoint and port `3001` by default.\n\n* Configuration to enable/disable the HTTP server ([#84](https://github.com/openfga/openfga/pull/84))\n\n  You can now enable/disable the HTTP server by setting `http.enabled=true/false`. It is enabled by default.\n\n### Changed\n* Env variables have a new mappings.\n\n  Please refer to the [`.config-schema.json`](https://github.com/openfga/openfga/blob/main/.config-schema.json) file for a description of the new configurations or `openfga run -h` for the CLI flags. Env variables are   mapped by prefixing `OPENFGA` and converting dot notation into underscores (e.g. `datastore.uri` becomes `OPENFGA_DATASTORE_URI`). \n\n### Fixed\n* goroutine leaks in Check resolution. ([#113](https://github.com/openfga/openfga/pull/113))\n\n## [0.1.4] - 2022-06-27\n### Added\n* OpenFGA Playground support ([#68](https://github.com/openfga/openfga/pull/68))\n* CORS policy configuration ([#65](https://github.com/openfga/openfga/pull/65))\n\n## [0.1.2] - 2022-06-20\n### Added\n* Request validation middleware\n* Postgres startup script\n\n## [0.1.1] - 2022-06-16\n### Added\n* TLS support for both the grpc and HTTP servers\n* Configurable logging formats including `text` and `json` formats\n* OpenFGA CLI with a preliminary `run` command to run the server\n\n## [0.1.0] - 2022-06-08\n### Added\n* Initial working implementation of OpenFGA APIs (Check, Expand, Write, Read, Authorization Models, etc..)\n* Postgres storage adapter implementation\n* Memory storage adapter implementation\n* Early support for preshared key or OIDC authentication methods\n\n[Unreleased]: https://github.com/openfga/openfga/compare/v1.3.2...HEAD\n[1.3.2]: https://github.com/openfga/openfga/releases/tag/v1.3.2\n[1.3.1]: https://github.com/openfga/openfga/releases/tag/v1.3.1\n[1.3.0]: https://github.com/openfga/openfga/releases/tag/v1.3.0\n[1.2.0]: https://github.com/openfga/openfga/releases/tag/v1.2.0\n[1.1.1]: https://github.com/openfga/openfga/releases/tag/v1.1.1\n[1.1.0]: https://github.com/openfga/openfga/releases/tag/v1.1.0\n[1.0.1]: https://github.com/openfga/openfga/releases/tag/v1.0.1\n[1.0.0]: https://github.com/openfga/openfga/releases/tag/v1.0.0\n[0.4.3]: https://github.com/openfga/openfga/releases/tag/v0.4.3\n[0.4.2]: https://github.com/openfga/openfga/releases/tag/v0.4.2\n[0.4.1]: https://github.com/openfga/openfga/releases/tag/v0.4.1\n[0.4.0]: https://github.com/openfga/openfga/releases/tag/v0.4.0\n[0.3.7]: https://github.com/openfga/openfga/releases/tag/v0.3.7\n[0.3.6]: https://github.com/openfga/openfga/releases/tag/v0.3.6\n[0.3.5]: https://github.com/openfga/openfga/releases/tag/v0.3.5\n[0.3.4]: https://github.com/openfga/openfga/releases/tag/v0.3.4\n[0.3.3]: https://github.com/openfga/openfga/releases/tag/v0.3.3\n[0.3.2]: https://github.com/openfga/openfga/releases/tag/v0.3.2\n[0.3.1]: https://github.com/openfga/openfga/releases/tag/v0.3.1\n[0.3.0]: https://github.com/openfga/openfga/releases/tag/v0.3.0\n[0.2.5]: https://github.com/openfga/openfga/releases/tag/v0.2.5\n[0.2.4]: https://github.com/openfga/openfga/releases/tag/v0.2.4\n[0.2.3]: https://github.com/openfga/openfga/releases/tag/v0.2.3\n[0.2.2]: https://github.com/openfga/openfga/releases/tag/v0.2.2\n[0.2.1]: https://github.com/openfga/openfga/releases/tag/v0.2.1\n[0.2.0]: https://github.com/openfga/openfga/releases/tag/v0.2.0\n[0.1.7]: https://github.com/openfga/openfga/releases/tag/v0.1.7\n[0.1.6]: https://github.com/openfga/openfga/releases/tag/v0.1.6\n[0.1.5]: https://github.com/openfga/openfga/releases/tag/v0.1.5\n[0.1.4]: https://github.com/openfga/openfga/releases/tag/v0.1.4\n[0.1.2]: https://github.com/openfga/openfga/releases/tag/v0.1.2\n[0.1.1]: https://github.com/openfga/openfga/releases/tag/v0.1.1\n[0.1.0]: https://github.com/openfga/openfga/releases/tag/v0.1.0\n", "package graph\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"sync\"\n\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\t\"github.com/openfga/openfga/internal/validation\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/storage/storagewrappers\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"go.opentelemetry.io/otel\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"golang.org/x/exp/maps\"\n)\n\nvar tracer = otel.Tracer(\"internal/graph/check\")\n\nconst (\n\t// same values as run.DefaultConfig() (TODO break the import cycle, remove these hardcoded values and import those constants here)\n\tdefaultResolveNodeBreadthLimit    = 25\n\tdefaultMaxConcurrentReadsForCheck = math.MaxUint32\n)\n\nvar (\n\tErrCycleDetected = errors.New(\"a cycle has been detected\")\n)\n\nvar cycleDetectedCheckHandler = func(ctx context.Context) (*ResolveCheckResponse, error) {\n\treturn nil, ErrCycleDetected\n}\n\ntype ResolveCheckRequest struct {\n\tStoreID              string\n\tAuthorizationModelID string\n\tTupleKey             *openfgav1.TupleKey\n\tContextualTuples     []*openfgav1.TupleKey\n\tResolutionMetadata   *ResolutionMetadata\n\tVisitedPaths         map[string]struct{}\n}\n\ntype ResolveCheckResponse struct {\n\tAllowed            bool\n\tResolutionMetadata *ResolutionMetadata\n}\n\nfunc (r *ResolveCheckResponse) GetAllowed() bool {\n\tif r != nil {\n\t\treturn r.Allowed\n\t}\n\n\treturn false\n}\n\nfunc (r *ResolveCheckResponse) GetResolutionMetadata() *ResolutionMetadata {\n\tif r != nil {\n\t\treturn r.ResolutionMetadata\n\t}\n\n\treturn nil\n}\n\nfunc (r *ResolveCheckRequest) GetStoreID() string {\n\tif r != nil {\n\t\treturn r.StoreID\n\t}\n\n\treturn \"\"\n}\n\nfunc (r *ResolveCheckRequest) GetAuthorizationModelID() string {\n\tif r != nil {\n\t\treturn r.AuthorizationModelID\n\t}\n\n\treturn \"\"\n}\n\nfunc (r *ResolveCheckRequest) GetTupleKey() *openfgav1.TupleKey {\n\tif r != nil {\n\t\treturn r.TupleKey\n\t}\n\n\treturn nil\n}\n\nfunc (r *ResolveCheckRequest) GetContextualTuples() []*openfgav1.TupleKey {\n\tif r != nil {\n\t\treturn r.ContextualTuples\n\t}\n\n\treturn nil\n}\n\nfunc (r *ResolveCheckRequest) GetResolutionMetadata() *ResolutionMetadata {\n\tif r != nil {\n\t\treturn r.ResolutionMetadata\n\t}\n\n\treturn nil\n}\n\ntype setOperatorType int\n\nconst (\n\tunionSetOperator setOperatorType = iota\n\tintersectionSetOperator\n\texclusionSetOperator\n)\n\ntype checkOutcome struct {\n\tresp *ResolveCheckResponse\n\terr  error\n}\n\ntype LocalChecker struct {\n\tds                 storage.RelationshipTupleReader\n\tdelegate           CheckResolver\n\tconcurrencyLimit   uint32\n\tmaxConcurrentReads uint32\n}\n\ntype LocalCheckerOption func(d *LocalChecker)\n\n// WithResolveNodeBreadthLimit see server.WithResolveNodeBreadthLimit\nfunc WithResolveNodeBreadthLimit(limit uint32) LocalCheckerOption {\n\treturn func(d *LocalChecker) {\n\t\td.concurrencyLimit = limit\n\t}\n}\n\n// WithMaxConcurrentReads see server.WithMaxConcurrentReadsForCheck\nfunc WithMaxConcurrentReads(limit uint32) LocalCheckerOption {\n\treturn func(d *LocalChecker) {\n\t\td.maxConcurrentReads = limit\n\t}\n}\n\nfunc WithDelegate(delegate CheckResolver) LocalCheckerOption {\n\treturn func(d *LocalChecker) {\n\t\td.delegate = delegate\n\t}\n}\n\nfunc WithCachedResolver(opts ...CachedCheckResolverOpt) LocalCheckerOption {\n\treturn func(d *LocalChecker) {\n\t\tcachedCheckResolver := NewCachedCheckResolver(\n\t\t\td,\n\t\t\topts...,\n\t\t)\n\t\td.SetDelegate(cachedCheckResolver)\n\t}\n}\n\n// NewLocalChecker constructs a LocalChecker that can be used to evaluate a Check\n// request locally.\nfunc NewLocalChecker(ds storage.RelationshipTupleReader, opts ...LocalCheckerOption) CheckResolver {\n\tchecker := &LocalChecker{\n\t\tds:                 ds,\n\t\tconcurrencyLimit:   defaultResolveNodeBreadthLimit,\n\t\tmaxConcurrentReads: defaultMaxConcurrentReadsForCheck,\n\t}\n\tchecker.delegate = checker // by default, a LocalChecker delegates/dispatchs subproblems to itself (e.g. local dispatch) unless otherwise configured.\n\n\tfor _, opt := range opts {\n\t\topt(checker)\n\t}\n\n\tchecker.ds = storagewrappers.NewBoundedConcurrencyTupleReader(checker.ds, checker.maxConcurrentReads)\n\n\t// Depending on whether cached check resolver is used,\n\t// we either return the newly created checker or the delegate (i.e., cached check resolver).\n\treturn checker.delegate\n}\n\n// CheckHandlerFunc defines a function that evaluates a CheckResponse or returns an error\n// otherwise.\ntype CheckHandlerFunc func(ctx context.Context) (*ResolveCheckResponse, error)\n\n// CheckFuncReducer defines a function that combines or reduces one or more CheckHandlerFunc into\n// a single CheckResponse with a maximum limit on the number of concurrent evaluations that can be\n// in flight at any given time.\ntype CheckFuncReducer func(ctx context.Context, concurrencyLimit uint32, handlers ...CheckHandlerFunc) (*ResolveCheckResponse, error)\n\n// resolver concurrently resolves one or more CheckHandlerFunc and yields the results on the provided resultChan.\n// Callers of the 'resolver' function should be sure to invoke the callback returned from this function to ensure\n// every concurrent check is evaluated. The concurrencyLimit can be set to provide a maximum number of concurrent\n// evaluations in flight at any point.\nfunc resolver(ctx context.Context, concurrencyLimit uint32, resultChan chan<- checkOutcome, handlers ...CheckHandlerFunc) func() {\n\tlimiter := make(chan struct{}, concurrencyLimit)\n\n\tvar wg sync.WaitGroup\n\n\tchecker := func(fn CheckHandlerFunc) {\n\t\tdefer wg.Done()\n\n\t\tresolved := make(chan checkOutcome, 1)\n\n\t\tgo func() {\n\t\t\tresp, err := fn(ctx)\n\t\t\tresolved <- checkOutcome{resp, err}\n\t\t\t<-limiter\n\t\t}()\n\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tcase res := <-resolved:\n\t\t\tresultChan <- res\n\t\t}\n\t}\n\n\twg.Add(1)\n\tgo func() {\n\touter:\n\t\tfor _, handler := range handlers {\n\t\t\tfn := handler // capture loop var\n\n\t\t\tselect {\n\t\t\tcase limiter <- struct{}{}:\n\t\t\t\twg.Add(1)\n\t\t\t\tgo checker(fn)\n\t\t\tcase <-ctx.Done():\n\t\t\t\tbreak outer\n\t\t\t}\n\t\t}\n\n\t\twg.Done()\n\t}()\n\n\treturn func() {\n\t\twg.Wait()\n\t\tclose(limiter)\n\t}\n}\n\n// union implements a CheckFuncReducer that requires any of the provided CheckHandlerFunc to resolve\n// to an allowed outcome. The first allowed outcome causes premature termination of the reducer.\nfunc union(ctx context.Context, concurrencyLimit uint32, handlers ...CheckHandlerFunc) (*ResolveCheckResponse, error) {\n\n\tctx, cancel := context.WithCancel(ctx)\n\tresultChan := make(chan checkOutcome, len(handlers))\n\n\tdrain := resolver(ctx, concurrencyLimit, resultChan, handlers...)\n\n\tdefer func() {\n\t\tcancel()\n\t\tdrain()\n\t\tclose(resultChan)\n\t}()\n\n\tvar dbReads uint32\n\tvar err error\n\tfor i := 0; i < len(handlers); i++ {\n\t\tselect {\n\t\tcase result := <-resultChan:\n\t\t\tif result.err != nil {\n\t\t\t\terr = result.err\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdbReads += result.resp.GetResolutionMetadata().DatastoreQueryCount\n\n\t\t\tif result.resp.GetAllowed() {\n\t\t\t\tresult.resp.GetResolutionMetadata().DatastoreQueryCount = dbReads\n\t\t\t\treturn result.resp, nil\n\t\t\t}\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ctx.Err()\n\t\t}\n\t}\n\n\treturn &ResolveCheckResponse{\n\t\tAllowed: false,\n\t\tResolutionMetadata: &ResolutionMetadata{\n\t\t\tDatastoreQueryCount: dbReads,\n\t\t},\n\t}, err\n}\n\n// intersection implements a CheckFuncReducer that requires all of the provided CheckHandlerFunc to resolve\n// to an allowed outcome. The first falsey or erroneous outcome causes premature termination of the reducer.\nfunc intersection(ctx context.Context, concurrencyLimit uint32, handlers ...CheckHandlerFunc) (*ResolveCheckResponse, error) {\n\n\tctx, cancel := context.WithCancel(ctx)\n\tresultChan := make(chan checkOutcome, len(handlers))\n\n\tdrain := resolver(ctx, concurrencyLimit, resultChan, handlers...)\n\n\tdefer func() {\n\t\tcancel()\n\t\tdrain()\n\t\tclose(resultChan)\n\t}()\n\n\tvar dbReads uint32\n\tvar err error\n\tfor i := 0; i < len(handlers); i++ {\n\t\tselect {\n\t\tcase result := <-resultChan:\n\t\t\tif result.err != nil {\n\t\t\t\terr = result.err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tdbReads += result.resp.GetResolutionMetadata().DatastoreQueryCount\n\t\t\tif !result.resp.GetAllowed() {\n\t\t\t\tresult.resp.GetResolutionMetadata().DatastoreQueryCount = dbReads\n\t\t\t\treturn result.resp, nil\n\t\t\t}\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ctx.Err()\n\t\t}\n\t}\n\n\tif err != nil {\n\t\treturn &ResolveCheckResponse{\n\t\t\tAllowed: false,\n\t\t\tResolutionMetadata: &ResolutionMetadata{\n\t\t\t\tDatastoreQueryCount: dbReads,\n\t\t\t},\n\t\t}, err\n\t}\n\n\treturn &ResolveCheckResponse{\n\t\tAllowed: true,\n\t\tResolutionMetadata: &ResolutionMetadata{\n\t\t\tDatastoreQueryCount: dbReads,\n\t\t},\n\t}, nil\n}\n\n// exclusion implements a CheckFuncReducer that requires a 'base' CheckHandlerFunc to resolve to an allowed\n// outcome and a 'sub' CheckHandlerFunc to resolve to a falsey outcome. The base and sub computations are\n// handled concurrently relative to one another.\nfunc exclusion(ctx context.Context, concurrencyLimit uint32, handlers ...CheckHandlerFunc) (*ResolveCheckResponse, error) {\n\n\tif len(handlers) != 2 {\n\t\tpanic(fmt.Sprintf(\"expected two rewrite operands for exclusion operator, but got '%d'\", len(handlers)))\n\t}\n\n\tlimiter := make(chan struct{}, concurrencyLimit)\n\n\tctx, cancel := context.WithCancel(ctx)\n\tbaseChan := make(chan checkOutcome, 1)\n\tsubChan := make(chan checkOutcome, 1)\n\n\tvar wg sync.WaitGroup\n\n\tdefer func() {\n\t\tcancel()\n\t\twg.Wait()\n\t\tclose(baseChan)\n\t\tclose(subChan)\n\t}()\n\n\tbaseHandler := handlers[0]\n\tsubHandler := handlers[1]\n\n\tlimiter <- struct{}{}\n\twg.Add(1)\n\tgo func() {\n\t\tresp, err := baseHandler(ctx)\n\t\tbaseChan <- checkOutcome{resp, err}\n\t\t<-limiter\n\t\twg.Done()\n\t}()\n\n\tlimiter <- struct{}{}\n\twg.Add(1)\n\tgo func() {\n\t\tresp, err := subHandler(ctx)\n\t\tsubChan <- checkOutcome{resp, err}\n\t\t<-limiter\n\t\twg.Done()\n\t}()\n\n\tresponse := &ResolveCheckResponse{\n\t\tAllowed: false,\n\t\tResolutionMetadata: &ResolutionMetadata{\n\t\t\tDatastoreQueryCount: 0,\n\t\t},\n\t}\n\tvar dbReads uint32\n\tfor i := 0; i < len(handlers); i++ {\n\t\tselect {\n\t\tcase baseResult := <-baseChan:\n\t\t\tif baseResult.err != nil {\n\t\t\t\treturn response, baseResult.err\n\t\t\t}\n\n\t\t\tdbReads += baseResult.resp.GetResolutionMetadata().DatastoreQueryCount\n\n\t\t\tif !baseResult.resp.GetAllowed() {\n\t\t\t\tresponse.GetResolutionMetadata().DatastoreQueryCount = dbReads\n\t\t\t\treturn response, nil\n\t\t\t}\n\n\t\tcase subResult := <-subChan:\n\t\t\tif subResult.err != nil {\n\t\t\t\treturn response, subResult.err\n\t\t\t}\n\n\t\t\tdbReads += subResult.resp.GetResolutionMetadata().DatastoreQueryCount\n\n\t\t\tif subResult.resp.GetAllowed() {\n\t\t\t\tresponse.GetResolutionMetadata().DatastoreQueryCount = dbReads\n\t\t\t\treturn response, nil\n\t\t\t}\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ctx.Err()\n\t\t}\n\t}\n\n\treturn &ResolveCheckResponse{\n\t\tAllowed: true,\n\t\tResolutionMetadata: &ResolutionMetadata{\n\t\t\tDatastoreQueryCount: dbReads,\n\t\t},\n\t}, nil\n}\n\n// Close is a noop\nfunc (c *LocalChecker) Close() {\n}\n\nfunc (c *LocalChecker) SetDelegate(delegate CheckResolver) {\n\tc.delegate = delegate\n}\n\n// dispatch dispatches the provided Check request to the CheckResolver this LocalChecker\n// was constructed with.\nfunc (c *LocalChecker) dispatch(ctx context.Context, req *ResolveCheckRequest) CheckHandlerFunc {\n\treturn func(ctx context.Context) (*ResolveCheckResponse, error) {\n\t\treturn c.delegate.ResolveCheck(ctx, req)\n\t}\n}\n\n// ResolveCheck resolves a node out of a tree of evaluations. If the depth of the tree has gotten too large,\n// evaluation is aborted and an error is returned. The depth is NOT increased on computed usersets.\nfunc (c *LocalChecker) ResolveCheck(\n\tctx context.Context,\n\treq *ResolveCheckRequest,\n) (*ResolveCheckResponse, error) {\n\tctx, span := tracer.Start(ctx, \"ResolveCheck\")\n\tdefer span.End()\n\n\tspan.SetAttributes(attribute.String(\"tuple_key\", req.GetTupleKey().String()))\n\n\tif req.GetResolutionMetadata().Depth == 0 {\n\t\treturn nil, ErrResolutionDepthExceeded\n\t}\n\n\ttypesys, ok := typesystem.TypesystemFromContext(ctx)\n\tif !ok {\n\t\tpanic(\"typesystem missing in context\")\n\t}\n\n\tobject := req.GetTupleKey().GetObject()\n\trelation := req.GetTupleKey().GetRelation()\n\n\tobjectType, _ := tuple.SplitObject(object)\n\trel, err := typesys.GetRelation(objectType, relation)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"relation '%s' undefined for object type '%s'\", relation, objectType)\n\t}\n\n\tif req.VisitedPaths != nil {\n\n\t\tif _, visited := req.VisitedPaths[tuple.TupleKeyToString(req.GetTupleKey())]; visited {\n\t\t\treturn nil, ErrCycleDetected\n\t\t}\n\n\t\treq.VisitedPaths[tuple.TupleKeyToString(req.GetTupleKey())] = struct{}{}\n\t} else {\n\t\treq.VisitedPaths = map[string]struct{}{\n\t\t\ttuple.TupleKeyToString(req.GetTupleKey()): {},\n\t\t}\n\t}\n\n\tresp, err := union(ctx, c.concurrencyLimit, c.checkRewrite(ctx, req, rel.GetRewrite()))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn resp, nil\n}\n\n// checkDirect composes two CheckHandlerFunc which evaluate direct relationships with the provided\n// 'object#relation'. The first handler looks up direct matches on the provided 'object#relation@user',\n// while the second handler looks up relationships between the target 'object#relation' and any usersets\n// related to it.\nfunc (c *LocalChecker) checkDirect(parentctx context.Context, req *ResolveCheckRequest) CheckHandlerFunc {\n\n\treturn func(ctx context.Context) (*ResolveCheckResponse, error) {\n\t\ttypesys, ok := typesystem.TypesystemFromContext(parentctx) // note: use of 'parentctx' not 'ctx' - this is important\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(\"typesystem missing in context\")\n\t\t}\n\n\t\tctx, span := tracer.Start(ctx, \"checkDirect\")\n\t\tdefer span.End()\n\n\t\tstoreID := req.GetStoreID()\n\t\ttk := req.GetTupleKey()\n\t\tobjectType := tuple.GetType(tk.GetObject())\n\t\trelation := tk.GetRelation()\n\n\t\t// directlyRelatedUsersetTypes could be \"user:*\" or \"group#member\"\n\t\tdirectlyRelatedUsersetTypes, _ := typesys.DirectlyRelatedUsersets(objectType, relation)\n\n\t\tfn1 := func(ctx context.Context) (*ResolveCheckResponse, error) {\n\t\t\tctx, span := tracer.Start(ctx, \"checkDirectUserTuple\", trace.WithAttributes(attribute.String(\"tuple_key\", tk.String())))\n\t\t\tdefer span.End()\n\n\t\t\tresponse := &ResolveCheckResponse{\n\t\t\t\tAllowed: false,\n\t\t\t\tResolutionMetadata: &ResolutionMetadata{\n\t\t\t\t\tDatastoreQueryCount: req.GetResolutionMetadata().DatastoreQueryCount + 1,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tt, err := c.ds.ReadUserTuple(ctx, storeID, tk)\n\t\t\tif err != nil {\n\t\t\t\tif errors.Is(err, storage.ErrNotFound) {\n\t\t\t\t\treturn response, nil\n\t\t\t\t}\n\n\t\t\t\treturn response, err\n\t\t\t}\n\n\t\t\t// filter out invalid tuples yielded by the database query\n\t\t\terr = validation.ValidateTuple(typesys, tk)\n\n\t\t\tif t != nil && err == nil {\n\t\t\t\tspan.SetAttributes(attribute.Bool(\"allowed\", true))\n\t\t\t\tresponse.Allowed = true\n\t\t\t\treturn response, nil\n\t\t\t}\n\t\t\treturn response, nil\n\t\t}\n\n\t\tfn2 := func(ctx context.Context) (*ResolveCheckResponse, error) {\n\t\t\tctx, span := tracer.Start(ctx, \"checkDirectUsersetTuples\", trace.WithAttributes(attribute.String(\"userset\", tuple.ToObjectRelationString(tk.Object, tk.Relation))))\n\t\t\tdefer span.End()\n\n\t\t\tresponse := &ResolveCheckResponse{\n\t\t\t\tAllowed: false,\n\t\t\t\tResolutionMetadata: &ResolutionMetadata{\n\t\t\t\t\tDatastoreQueryCount: req.GetResolutionMetadata().DatastoreQueryCount + 1,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\titer, err := c.ds.ReadUsersetTuples(ctx, storeID, storage.ReadUsersetTuplesFilter{\n\t\t\t\tObject:                      tk.Object,\n\t\t\t\tRelation:                    tk.Relation,\n\t\t\t\tAllowedUserTypeRestrictions: directlyRelatedUsersetTypes,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn response, err\n\t\t\t}\n\t\t\tdefer iter.Stop()\n\n\t\t\t// filter out invalid tuples yielded by the database iterator\n\t\t\tfilteredIter := storage.NewFilteredTupleKeyIterator(\n\t\t\t\tstorage.NewTupleKeyIteratorFromTupleIterator(iter),\n\t\t\t\tvalidation.FilterInvalidTuples(typesys),\n\t\t\t)\n\t\t\tdefer filteredIter.Stop()\n\n\t\t\tvar handlers []CheckHandlerFunc\n\t\t\tfor {\n\t\t\t\tt, err := filteredIter.Next()\n\t\t\t\tif err != nil {\n\t\t\t\t\tif errors.Is(err, storage.ErrIteratorDone) {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\n\t\t\t\t\treturn response, err\n\t\t\t\t}\n\n\t\t\t\tusersetObject, usersetRelation := tuple.SplitObjectRelation(t.GetUser())\n\n\t\t\t\t// for 1.0 models, if the user is '*' then we're done searching\n\t\t\t\tif usersetObject == tuple.Wildcard && typesys.GetSchemaVersion() == typesystem.SchemaVersion1_0 {\n\t\t\t\t\tspan.SetAttributes(attribute.Bool(\"allowed\", true))\n\t\t\t\t\tresponse.Allowed = true\n\t\t\t\t\treturn response, nil\n\t\t\t\t}\n\n\t\t\t\t// for 1.1 models, if the user value is a typed wildcard and the type of the wildcard\n\t\t\t\t// matches the target user objectType, then we're done searching\n\t\t\t\tif tuple.IsTypedWildcard(usersetObject) && typesys.GetSchemaVersion() == typesystem.SchemaVersion1_1 {\n\n\t\t\t\t\twildcardType := tuple.GetType(usersetObject)\n\n\t\t\t\t\tif tuple.GetType(tk.GetUser()) == wildcardType {\n\t\t\t\t\t\tspan.SetAttributes(attribute.Bool(\"allowed\", true))\n\t\t\t\t\t\tresponse.Allowed = true\n\t\t\t\t\t\treturn response, nil\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tif usersetRelation != \"\" {\n\t\t\t\t\ttupleKey := tuple.NewTupleKey(usersetObject, usersetRelation, tk.GetUser())\n\n\t\t\t\t\tif _, visited := req.VisitedPaths[tuple.TupleKeyToString(tupleKey)]; visited {\n\t\t\t\t\t\treturn nil, ErrCycleDetected\n\t\t\t\t\t}\n\n\t\t\t\t\thandlers = append(handlers, c.dispatch(\n\t\t\t\t\t\tctx,\n\t\t\t\t\t\t&ResolveCheckRequest{\n\t\t\t\t\t\t\tStoreID:              storeID,\n\t\t\t\t\t\t\tAuthorizationModelID: req.GetAuthorizationModelID(),\n\t\t\t\t\t\t\tTupleKey:             tupleKey,\n\t\t\t\t\t\t\tResolutionMetadata: &ResolutionMetadata{\n\t\t\t\t\t\t\t\tDepth:               req.GetResolutionMetadata().Depth - 1,\n\t\t\t\t\t\t\t\tDatastoreQueryCount: response.GetResolutionMetadata().DatastoreQueryCount,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tVisitedPaths: maps.Clone(req.VisitedPaths),\n\t\t\t\t\t\t}))\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif len(handlers) == 0 {\n\t\t\t\treturn response, nil\n\t\t\t}\n\n\t\t\treturn union(ctx, c.concurrencyLimit, handlers...)\n\t\t}\n\n\t\tvar checkFuncs []CheckHandlerFunc\n\n\t\tshouldCheckDirectTuple, _ := typesys.IsDirectlyRelated(\n\t\t\ttypesystem.DirectRelationReference(objectType, relation),                                         //target\n\t\t\ttypesystem.DirectRelationReference(tuple.GetType(tk.GetUser()), tuple.GetRelation(tk.GetUser())), //source\n\t\t)\n\n\t\tif shouldCheckDirectTuple {\n\t\t\tcheckFuncs = []CheckHandlerFunc{fn1}\n\t\t}\n\n\t\tif len(directlyRelatedUsersetTypes) > 0 {\n\t\t\tcheckFuncs = append(checkFuncs, fn2)\n\n\t\t}\n\n\t\treturn union(ctx, c.concurrencyLimit, checkFuncs...)\n\t}\n}\n\n// checkComputedUserset evaluates the Check request with the rewritten relation (e.g. the computed userset relation).\nfunc (c *LocalChecker) checkComputedUserset(parentctx context.Context, req *ResolveCheckRequest, rewrite *openfgav1.Userset_ComputedUserset) CheckHandlerFunc {\n\n\treturn func(ctx context.Context) (*ResolveCheckResponse, error) {\n\t\tctx, span := tracer.Start(ctx, \"checkComputedUserset\")\n\t\tdefer span.End()\n\n\t\trewrittenTupleKey := tuple.NewTupleKey(\n\t\t\treq.TupleKey.GetObject(),\n\t\t\trewrite.ComputedUserset.GetRelation(),\n\t\t\treq.TupleKey.GetUser(),\n\t\t)\n\n\t\tif _, visited := req.VisitedPaths[tuple.TupleKeyToString(rewrittenTupleKey)]; visited {\n\t\t\treturn nil, ErrCycleDetected\n\t\t}\n\n\t\treturn c.dispatch(\n\t\t\tctx,\n\t\t\t&ResolveCheckRequest{\n\t\t\t\tStoreID:              req.GetStoreID(),\n\t\t\t\tAuthorizationModelID: req.GetAuthorizationModelID(),\n\t\t\t\tTupleKey:             rewrittenTupleKey,\n\t\t\t\tResolutionMetadata: &ResolutionMetadata{\n\t\t\t\t\tDepth:               req.GetResolutionMetadata().Depth - 1,\n\t\t\t\t\tDatastoreQueryCount: req.GetResolutionMetadata().DatastoreQueryCount,\n\t\t\t\t},\n\t\t\t\tVisitedPaths: maps.Clone(req.VisitedPaths),\n\t\t\t})(ctx)\n\t}\n}\n\n// checkTTU looks up all tuples of the target tupleset relation on the provided object and for each one\n// of them evaluates the computed userset of the TTU rewrite rule for them.\nfunc (c *LocalChecker) checkTTU(parentctx context.Context, req *ResolveCheckRequest, rewrite *openfgav1.Userset) CheckHandlerFunc {\n\n\treturn func(ctx context.Context) (*ResolveCheckResponse, error) {\n\t\ttypesys, ok := typesystem.TypesystemFromContext(parentctx) // note: use of 'parentctx' not 'ctx' - this is important\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(\"typesystem missing in context\")\n\t\t}\n\n\t\tctx, span := tracer.Start(ctx, \"checkTTU\")\n\t\tdefer span.End()\n\n\t\tctx = typesystem.ContextWithTypesystem(ctx, typesys)\n\n\t\ttuplesetRelation := rewrite.GetTupleToUserset().GetTupleset().GetRelation()\n\t\tcomputedRelation := rewrite.GetTupleToUserset().GetComputedUserset().GetRelation()\n\n\t\ttk := req.GetTupleKey()\n\t\tobject := tk.GetObject()\n\n\t\tspan.SetAttributes(attribute.String(\"tupleset_relation\", fmt.Sprintf(\"%s#%s\", tuple.GetType(object), tuplesetRelation)))\n\t\tspan.SetAttributes(attribute.String(\"computed_relation\", computedRelation))\n\n\t\tresponse := &ResolveCheckResponse{\n\t\t\tAllowed: false,\n\t\t\tResolutionMetadata: &ResolutionMetadata{\n\t\t\t\tDatastoreQueryCount: req.GetResolutionMetadata().DatastoreQueryCount + 1,\n\t\t\t},\n\t\t}\n\t\titer, err := c.ds.Read(\n\t\t\tctx,\n\t\t\treq.GetStoreID(),\n\t\t\ttuple.NewTupleKey(object, tuplesetRelation, \"\"),\n\t\t)\n\t\tif err != nil {\n\t\t\treturn response, err\n\t\t}\n\t\tdefer iter.Stop()\n\n\t\t// filter out invalid tuples yielded by the database iterator\n\t\tfilteredIter := storage.NewFilteredTupleKeyIterator(\n\t\t\tstorage.NewTupleKeyIteratorFromTupleIterator(iter),\n\t\t\tvalidation.FilterInvalidTuples(typesys),\n\t\t)\n\t\tdefer filteredIter.Stop()\n\n\t\tvar handlers []CheckHandlerFunc\n\t\tfor {\n\t\t\tt, err := filteredIter.Next()\n\t\t\tif err != nil {\n\t\t\t\tif err == storage.ErrIteratorDone {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\treturn response, err\n\t\t\t}\n\n\t\t\tuserObj, _ := tuple.SplitObjectRelation(t.GetUser())\n\n\t\t\ttupleKey := &openfgav1.TupleKey{\n\t\t\t\tObject:   userObj,\n\t\t\t\tRelation: computedRelation,\n\t\t\t\tUser:     tk.GetUser(),\n\t\t\t}\n\n\t\t\tif _, err := typesys.GetRelation(tuple.GetType(userObj), computedRelation); err != nil {\n\t\t\t\tif errors.Is(err, typesystem.ErrRelationUndefined) {\n\t\t\t\t\tcontinue // skip computed relations on tupleset relationships if they are undefined\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif _, visited := req.VisitedPaths[tuple.TupleKeyToString(tupleKey)]; visited {\n\t\t\t\treturn nil, ErrCycleDetected\n\t\t\t}\n\n\t\t\thandlers = append(handlers, c.dispatch(\n\t\t\t\tctx,\n\t\t\t\t&ResolveCheckRequest{\n\t\t\t\t\tStoreID:              req.GetStoreID(),\n\t\t\t\t\tAuthorizationModelID: req.GetAuthorizationModelID(),\n\t\t\t\t\tTupleKey:             tupleKey,\n\t\t\t\t\tResolutionMetadata: &ResolutionMetadata{\n\t\t\t\t\t\tDepth:               req.GetResolutionMetadata().Depth - 1,\n\t\t\t\t\t\tDatastoreQueryCount: req.GetResolutionMetadata().DatastoreQueryCount, // add TTU read below\n\t\t\t\t\t},\n\t\t\t\t\tVisitedPaths: maps.Clone(req.VisitedPaths),\n\t\t\t\t}))\n\t\t}\n\n\t\tif len(handlers) == 0 {\n\t\t\treturn response, nil\n\t\t}\n\n\t\tunionResponse, err := union(ctx, c.concurrencyLimit, handlers...)\n\n\t\tif err == nil {\n\t\t\t// if we had 3 dispatched requests, and the final result is \"allowed = false\",\n\t\t\t// we want final reads to be (N1 + N2 + N3 + 1) and not (N1 + 1) + (N2 + 1) + (N3 + 1)\n\t\t\t// if final result is \"allowed = true\", we want final reads to be N1 + 1\n\t\t\tunionResponse.GetResolutionMetadata().DatastoreQueryCount++\n\t\t}\n\n\t\treturn unionResponse, err\n\n\t}\n}\n\nfunc (c *LocalChecker) checkSetOperation(\n\tctx context.Context,\n\treq *ResolveCheckRequest,\n\tsetOpType setOperatorType,\n\treducer CheckFuncReducer,\n\tchildren ...*openfgav1.Userset,\n) CheckHandlerFunc {\n\n\tvar handlers []CheckHandlerFunc\n\n\tvar reducerKey string\n\tswitch setOpType {\n\tcase unionSetOperator, intersectionSetOperator, exclusionSetOperator:\n\t\tif setOpType == unionSetOperator {\n\t\t\treducerKey = \"union\"\n\t\t}\n\n\t\tif setOpType == intersectionSetOperator {\n\t\t\treducerKey = \"intersection\"\n\t\t}\n\n\t\tif setOpType == exclusionSetOperator {\n\t\t\treducerKey = \"exclusion\"\n\t\t}\n\n\t\tfor _, child := range children {\n\t\t\thandlers = append(handlers, c.checkRewrite(ctx, req, child))\n\t\t}\n\tdefault:\n\t\tpanic(\"unexpected set operator type encountered\")\n\t}\n\n\treturn func(ctx context.Context) (*ResolveCheckResponse, error) {\n\t\tctx, span := tracer.Start(ctx, reducerKey)\n\t\tdefer span.End()\n\n\t\treturn reducer(ctx, c.concurrencyLimit, handlers...)\n\t}\n}\n\nfunc (c *LocalChecker) checkRewrite(\n\tctx context.Context,\n\treq *ResolveCheckRequest,\n\trewrite *openfgav1.Userset,\n) CheckHandlerFunc {\n\n\tswitch rw := rewrite.Userset.(type) {\n\tcase *openfgav1.Userset_This:\n\t\treturn c.checkDirect(ctx, req)\n\tcase *openfgav1.Userset_ComputedUserset:\n\t\treturn c.checkComputedUserset(ctx, req, rw)\n\tcase *openfgav1.Userset_TupleToUserset:\n\t\treturn c.checkTTU(ctx, req, rewrite)\n\tcase *openfgav1.Userset_Union:\n\t\treturn c.checkSetOperation(ctx, req, unionSetOperator, union, rw.Union.GetChild()...)\n\tcase *openfgav1.Userset_Intersection:\n\t\treturn c.checkSetOperation(ctx, req, intersectionSetOperator, intersection, rw.Intersection.GetChild()...)\n\tcase *openfgav1.Userset_Difference:\n\t\treturn c.checkSetOperation(ctx, req, exclusionSetOperator, exclusion, rw.Difference.GetBase(), rw.Difference.GetSubtract())\n\tdefault:\n\t\tpanic(\"unexpected userset rewrite encountered\")\n\t}\n}\n", "package graph\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"testing\"\n\n\tparser \"github.com/craigpastro/openfga-dsl-parser/v2\"\n\t\"github.com/oklog/ulid/v2\"\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\t\"github.com/openfga/openfga/pkg/storage/memory\"\n\t\"github.com/openfga/openfga/pkg/storage/storagewrappers\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestResolveCheckDeterministic(t *testing.T) {\n\n\tds := memory.New()\n\n\tstoreID := ulid.Make().String()\n\n\terr := ds.Write(context.Background(), storeID, nil, []*openfgav1.TupleKey{\n\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\ttuple.NewTupleKey(\"document:1\", \"editor\", \"group:other1#member\"),\n\t\ttuple.NewTupleKey(\"document:2\", \"editor\", \"group:eng#member\"),\n\t\ttuple.NewTupleKey(\"document:2\", \"allowed\", \"user:jon\"),\n\t\ttuple.NewTupleKey(\"document:2\", \"allowed\", \"user:x\"),\n\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"group:fga#member\"),\n\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"user:jon\"),\n\t\ttuple.NewTupleKey(\"group:other1\", \"member\", \"group:other2#member\"),\n\t})\n\trequire.NoError(t, err)\n\n\tchecker := NewLocalChecker(ds)\n\n\ttypedefs := parser.MustParse(`\n\ttype user\n\n\ttype group\n\t  relations\n\t    define member: [user, group#member] as self\n\n\ttype document\n\t  relations\n\t    define allowed: [user] as self\n\t    define viewer: [group#member] as self or editor\n\t    define editor: [group#member] as self and allowed\n\t    \n\t`)\n\n\tctx := typesystem.ContextWithTypesystem(context.Background(), typesystem.New(\n\t\t&openfgav1.AuthorizationModel{\n\t\t\tId:              ulid.Make().String(),\n\t\t\tTypeDefinitions: typedefs,\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t},\n\t))\n\n\tresp, err := checker.ResolveCheck(ctx, &ResolveCheckRequest{\n\t\tStoreID:            storeID,\n\t\tTupleKey:           tuple.NewTupleKey(\"document:1\", \"viewer\", \"user:jon\"),\n\t\tResolutionMetadata: &ResolutionMetadata{Depth: 2},\n\t})\n\trequire.NoError(t, err)\n\trequire.True(t, resp.Allowed)\n\n\tresp, err = checker.ResolveCheck(ctx, &ResolveCheckRequest{\n\t\tStoreID:            storeID,\n\t\tTupleKey:           tuple.NewTupleKey(\"document:2\", \"editor\", \"user:x\"),\n\t\tResolutionMetadata: &ResolutionMetadata{Depth: 2},\n\t})\n\trequire.ErrorIs(t, err, ErrResolutionDepthExceeded)\n\trequire.Nil(t, resp)\n}\n\nfunc TestCheckWithOneConcurrentGoroutineCausesNoDeadlock(t *testing.T) {\n\tconst concurrencyLimit = 1\n\tds := memory.New()\n\tdefer ds.Close()\n\n\tstoreID := ulid.Make().String()\n\n\terr := ds.Write(context.Background(), storeID, nil, []*openfgav1.TupleKey{\n\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:1#member\"),\n\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:2#member\"),\n\t\ttuple.NewTupleKey(\"group:1\", \"member\", \"group:1a#member\"),\n\t\ttuple.NewTupleKey(\"group:1\", \"member\", \"group:1b#member\"),\n\t\ttuple.NewTupleKey(\"group:2\", \"member\", \"group:2a#member\"),\n\t\ttuple.NewTupleKey(\"group:2\", \"member\", \"group:2b#member\"),\n\t\ttuple.NewTupleKey(\"group:2b\", \"member\", \"user:jon\"),\n\t})\n\trequire.NoError(t, err)\n\n\tchecker := NewLocalChecker(ds, WithResolveNodeBreadthLimit(concurrencyLimit))\n\n\ttypedefs := parser.MustParse(`\n\ttype user\n\ttype group\n\t  relations\n\t\tdefine member: [user, group#member] as self\n\ttype document\n\t  relations\n\t\tdefine viewer: [group#member] as self\n\t`)\n\n\tctx := typesystem.ContextWithTypesystem(context.Background(), typesystem.New(\n\t\t&openfgav1.AuthorizationModel{\n\t\t\tId:              ulid.Make().String(),\n\t\t\tTypeDefinitions: typedefs,\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t},\n\t))\n\n\tresp, err := checker.ResolveCheck(ctx, &ResolveCheckRequest{\n\t\tStoreID:            storeID,\n\t\tTupleKey:           tuple.NewTupleKey(\"document:1\", \"viewer\", \"user:jon\"),\n\t\tResolutionMetadata: &ResolutionMetadata{Depth: 25},\n\t})\n\trequire.NoError(t, err)\n\trequire.True(t, resp.Allowed)\n}\n\nfunc TestCheckDatastoreQueryCount(t *testing.T) {\n\tds := memory.New()\n\tdefer ds.Close()\n\n\tstoreID := ulid.Make().String()\n\n\terr := ds.Write(context.Background(), storeID, nil, []*openfgav1.TupleKey{\n\t\ttuple.NewTupleKey(\"document:x\", \"a\", \"user:jon\"),\n\t\ttuple.NewTupleKey(\"document:x\", \"a\", \"user:maria\"),\n\t\ttuple.NewTupleKey(\"document:x\", \"b\", \"user:maria\"),\n\t\ttuple.NewTupleKey(\"document:x\", \"parent\", \"org:fga\"),\n\t\ttuple.NewTupleKey(\"org:fga\", \"member\", \"user:maria\"),\n\t})\n\trequire.NoError(t, err)\n\n\ttypedefs := parser.MustParse(`\n\ttype user\n\n\ttype org\n      relations\n\t\tdefine member: [user] as self\n\n\ttype document\n\t  relations\n\t\tdefine a: [user] as self\n\t\tdefine b: [user] as self\n\t\tdefine union as a or b\n\t\tdefine union_rewrite as union\n\t\tdefine intersection as a and b\n\t\tdefine difference as a but not b\n\t\tdefine ttu as member from parent\n        define union_and_ttu as union and ttu\n\t\tdefine union_or_ttu as union or ttu or union_rewrite\n\t\tdefine intersection_of_ttus as union_or_ttu and union_and_ttu\n\t\tdefine parent: [org] as self\n\t`)\n\n\tctx := typesystem.ContextWithTypesystem(context.Background(), typesystem.New(\n\t\t&openfgav1.AuthorizationModel{\n\t\t\tId:              ulid.Make().String(),\n\t\t\tTypeDefinitions: typedefs,\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t},\n\t))\n\n\ttests := []struct {\n\t\tname             string\n\t\tcheck            *openfgav1.TupleKey\n\t\tcontextualTuples []*openfgav1.TupleKey\n\t\tallowed          bool\n\t\tminDBReads       uint32\n\t\tmaxDBReads       uint32\n\t}{\n\t\t{\n\t\t\tname:       \"no_direct_access\",\n\t\t\tcheck:      tuple.NewTupleKey(\"document:x\", \"a\", \"user:unknown\"),\n\t\t\tallowed:    false,\n\t\t\tminDBReads: 1, // both checkDirectUserTuple\n\t\t\tmaxDBReads: 1,\n\t\t},\n\t\t{\n\t\t\tname:       \"direct_access\",\n\t\t\tcheck:      tuple.NewTupleKey(\"document:x\", \"a\", \"user:maria\"),\n\t\t\tallowed:    true,\n\t\t\tminDBReads: 1, // checkDirectUserTuple needs to run\n\t\t\tmaxDBReads: 1,\n\t\t},\n\t\t{\n\t\t\tname:             \"direct_access_thanks_to_contextual_tuple\", // NOTE: this is counting the read from memory as a database read!\n\t\t\tcheck:            tuple.NewTupleKey(\"document:x\", \"a\", \"user:unknown\"),\n\t\t\tcontextualTuples: []*openfgav1.TupleKey{tuple.NewTupleKey(\"document:x\", \"a\", \"user:unknown\")},\n\t\t\tallowed:          true,\n\t\t\tminDBReads:       1, // checkDirectUserTuple needs to run\n\t\t\tmaxDBReads:       1,\n\t\t},\n\t\t{\n\t\t\tname:       \"union\",\n\t\t\tcheck:      tuple.NewTupleKey(\"document:x\", \"union\", \"user:maria\"),\n\t\t\tallowed:    true,\n\t\t\tminDBReads: 1, // checkDirectUserTuple needs to run\n\t\t\tmaxDBReads: 1,\n\t\t},\n\t\t{\n\t\t\tname:       \"union_no_access\",\n\t\t\tcheck:      tuple.NewTupleKey(\"document:x\", \"union\", \"user:unknown\"),\n\t\t\tallowed:    false,\n\t\t\tminDBReads: 2, // need to check all the conditions in the union\n\t\t\tmaxDBReads: 2,\n\t\t},\n\t\t{\n\t\t\tname:       \"intersection\",\n\t\t\tcheck:      tuple.NewTupleKey(\"document:x\", \"intersection\", \"user:maria\"),\n\t\t\tallowed:    true,\n\t\t\tminDBReads: 2, // need at minimum two direct tuple checks\n\t\t\tmaxDBReads: 2, // at most two tuple checks\n\t\t},\n\t\t{\n\t\t\tname:       \"intersection_no_access\",\n\t\t\tcheck:      tuple.NewTupleKey(\"document:x\", \"intersection\", \"user:unknown\"),\n\t\t\tallowed:    false,\n\t\t\tminDBReads: 1, // need at minimum one direct tuple checks (short circuit the ohter path)\n\t\t\tmaxDBReads: 1,\n\t\t},\n\t\t{\n\t\t\tname:       \"difference\",\n\t\t\tcheck:      tuple.NewTupleKey(\"document:x\", \"difference\", \"user:jon\"),\n\t\t\tallowed:    true,\n\t\t\tminDBReads: 2, // need at minimum two direct tuple checks\n\t\t\tmaxDBReads: 2,\n\t\t},\n\t\t{\n\t\t\tname:       \"difference_no_access\",\n\t\t\tcheck:      tuple.NewTupleKey(\"document:x\", \"difference\", \"user:maria\"),\n\t\t\tallowed:    false,\n\t\t\tminDBReads: 1, // if the \"but not\" condition returns quickly with \"false\", no need to evaluate the first branch\n\t\t\tmaxDBReads: 2, // at most two tuple checks\n\t\t},\n\t\t{\n\t\t\tname:       \"ttu\",\n\t\t\tcheck:      tuple.NewTupleKey(\"document:x\", \"ttu\", \"user:maria\"),\n\t\t\tallowed:    true,\n\t\t\tminDBReads: 2, // one read to find org:fga + one direct check if user:maria is a member of org:fga\n\t\t\tmaxDBReads: 3, // one read to find org:fga + (one direct check + userset check) if user:maria is a member of org:fga\n\t\t},\n\t\t{\n\t\t\tname:       \"ttu_no_access\",\n\t\t\tcheck:      tuple.NewTupleKey(\"document:x\", \"ttu\", \"user:jon\"),\n\t\t\tallowed:    false,\n\t\t\tminDBReads: 2, // one read to find org:fga + (one direct check) to see if user:jon is a member of org:fga\n\t\t\tmaxDBReads: 2,\n\t\t},\n\t\t// more complex scenarios\n\t\t{\n\t\t\tname:       \"union_and_ttu\",\n\t\t\tcheck:      tuple.NewTupleKey(\"document:x\", \"union_and_ttu\", \"user:maria\"),\n\t\t\tallowed:    true,\n\t\t\tminDBReads: 3, // union (1 read) + ttu (2 reads)\n\t\t\tmaxDBReads: 5, // union (2 reads) + ttu (3 reads)\n\t\t},\n\t\t{\n\t\t\tname:       \"union_and_ttu_no_access\",\n\t\t\tcheck:      tuple.NewTupleKey(\"document:x\", \"union_and_ttu\", \"user:unknown\"),\n\t\t\tallowed:    false,\n\t\t\tminDBReads: 2, // min(union (2 reads), ttu (4 reads))\n\t\t\tmaxDBReads: 4, // max(union (2 reads), ttu (4 reads))\n\t\t},\n\t\t{\n\t\t\tname:       \"union_or_ttu\",\n\t\t\tcheck:      tuple.NewTupleKey(\"document:x\", \"union_or_ttu\", \"user:maria\"),\n\t\t\tallowed:    true,\n\t\t\tminDBReads: 1, // min(union (1 read), ttu (2 reads))\n\t\t\tmaxDBReads: 3, // max(union (2 reads), ttu (3 reads))\n\t\t},\n\t\t{\n\t\t\tname:       \"union_or_ttu_no_access\",\n\t\t\tcheck:      tuple.NewTupleKey(\"document:x\", \"union_or_ttu\", \"user:unknown\"),\n\t\t\tallowed:    false,\n\t\t\tminDBReads: 6, // union (2 reads) + ttu (2 reads) + union rewrite (2 reads)\n\t\t\tmaxDBReads: 6,\n\t\t},\n\t\t{\n\t\t\tname:       \"intersection_of_ttus\", //union_or_ttu and union_and_ttu\n\t\t\tcheck:      tuple.NewTupleKey(\"document:x\", \"intersection_of_ttus\", \"user:maria\"),\n\t\t\tallowed:    true,\n\t\t\tminDBReads: 4, // union_or_ttu (1 read) + union_and_ttu (3 reads)\n\t\t\tmaxDBReads: 8, // union_or_ttu (3 reads) + union_and_ttu (5 reads)\n\t\t},\n\t}\n\n\t// run the test many times to exercise all the possible DBReads\n\tfor i := 1; i < 1000; i++ {\n\n\t\tt.Run(fmt.Sprintf(\"iteration_%v\", i), func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tfor _, test := range tests {\n\t\t\t\ttest := test\n\t\t\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t\t\tt.Parallel()\n\n\t\t\t\t\tchecker := NewLocalChecker(\n\t\t\t\t\t\t// TODO build this wrapper inside ResolveCheck so that we don't need to construct a new Checker per test\n\t\t\t\t\t\tstoragewrappers.NewCombinedTupleReader(ds, test.contextualTuples),\n\t\t\t\t\t\tWithMaxConcurrentReads(1))\n\n\t\t\t\t\tres, err := checker.ResolveCheck(ctx, &ResolveCheckRequest{\n\t\t\t\t\t\tStoreID:            storeID,\n\t\t\t\t\t\tTupleKey:           test.check,\n\t\t\t\t\t\tContextualTuples:   test.contextualTuples,\n\t\t\t\t\t\tResolutionMetadata: &ResolutionMetadata{Depth: 25},\n\t\t\t\t\t})\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\trequire.Equal(t, res.Allowed, test.allowed)\n\t\t\t\t\t// minDBReads <= dbReads <= maxDBReads\n\t\t\t\t\trequire.GreaterOrEqual(t, res.ResolutionMetadata.DatastoreQueryCount, test.minDBReads)\n\t\t\t\t\trequire.LessOrEqual(t, res.ResolutionMetadata.DatastoreQueryCount, test.maxDBReads)\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestCheckWithUnexpectedCycle tests the LocalChecker to make sure that if a model includes a cycle\n// that should have otherwise been invalid according to the typesystem, then the check resolution will\n// avoid the cycle and return an error indicating a cycle was detected.\nfunc TestCheckWithUnexpectedCycle(t *testing.T) {\n\tds := memory.New()\n\tdefer ds.Close()\n\n\tstoreID := ulid.Make().String()\n\n\terr := ds.Write(context.Background(), storeID, nil, []*openfgav1.TupleKey{\n\t\ttuple.NewTupleKey(\"resource:1\", \"parent\", \"resource:1\"),\n\t})\n\trequire.NoError(t, err)\n\n\ttests := []struct {\n\t\tname     string\n\t\tmodel    string\n\t\ttupleKey *openfgav1.TupleKey\n\t}{\n\t\t{\n\t\t\tname: \"test_1\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype resource\n\t\t\t  relations\n\t\t\t\tdefine x: [user] as self but not y\n\t\t\t\tdefine y: [user] as self but not z\n\t\t\t\tdefine z: [user] as self or x\n\t\t\t`,\n\t\t\ttupleKey: tuple.NewTupleKey(\"resource:1\", \"x\", \"user:jon\"),\n\t\t},\n\t\t{\n\t\t\tname: \"test_2\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype resource\n\t\t\t  relations\n\t\t\t\tdefine x: [user] as self and y\n\t\t\t\tdefine y: [user] as self and z\n\t\t\t\tdefine z: [user] as self or x\n\t\t\t`,\n\t\t\ttupleKey: tuple.NewTupleKey(\"resource:1\", \"x\", \"user:jon\"),\n\t\t},\n\t\t{\n\t\t\tname: \"test_3\",\n\t\t\tmodel: `\n\t\t\ttype resource\n\t\t\t  relations\n\t\t\t\tdefine x as y\n\t\t\t\tdefine y as x\n\t\t\t`,\n\t\t\ttupleKey: tuple.NewTupleKey(\"resource:1\", \"x\", \"user:jon\"),\n\t\t},\n\t\t{\n\t\t\tname: \"test_4\",\n\t\t\tmodel: `\n\t\t\ttype resource\n\t\t\t  relations\n\t\t\t    define parent: [resource] as self\n\t\t\t\tdefine x: [user] as self or x from parent\n\t\t\t`,\n\t\t\ttupleKey: tuple.NewTupleKey(\"resource:1\", \"x\", \"user:jon\"),\n\t\t},\n\t}\n\n\tchecker := NewLocalChecker(ds)\n\n\tfor _, test := range tests {\n\t\ttypedefs := parser.MustParse(test.model)\n\n\t\tctx := typesystem.ContextWithTypesystem(context.Background(), typesystem.New(\n\t\t\t&openfgav1.AuthorizationModel{\n\t\t\t\tId:              ulid.Make().String(),\n\t\t\t\tTypeDefinitions: typedefs,\n\t\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\t},\n\t\t))\n\n\t\tresp, err := checker.ResolveCheck(ctx, &ResolveCheckRequest{\n\t\t\tStoreID:            storeID,\n\t\t\tTupleKey:           test.tupleKey,\n\t\t\tResolutionMetadata: &ResolutionMetadata{Depth: 25},\n\t\t})\n\n\t\t// if the branch producing the cycle is reached first, then an error is returned, otherwise\n\t\t// a result is returned if some other terminal path of evaluation was reached before the cycle\n\t\tif err != nil {\n\t\t\trequire.ErrorIs(t, err, ErrCycleDetected)\n\t\t} else {\n\t\t\trequire.False(t, resp.GetAllowed())\n\t\t\trequire.GreaterOrEqual(t, resp.ResolutionMetadata.DatastoreQueryCount, uint32(1)) // min of 1 (x) if x isn't found and it returns quickly\n\t\t\trequire.LessOrEqual(t, resp.ResolutionMetadata.DatastoreQueryCount, uint32(3))    // max of 3 (x, y, z) before the cycle\n\t\t}\n\t}\n}\n", "package commands\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\t\"github.com/openfga/openfga/internal/graph\"\n\t\"github.com/openfga/openfga/internal/validation\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\t\"github.com/openfga/openfga/pkg/server/commands/reverseexpand\"\n\tserverErrors \"github.com/openfga/openfga/pkg/server/errors\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/storage/storagewrappers\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promauto\"\n)\n\nconst (\n\tstreamedBufferSize = 100\n\n\t// same values as run.DefaultConfig() (TODO break the import cycle, remove these hardcoded values and import those constants here)\n\tdefaultResolveNodeLimit                 = 25\n\tdefaultResolveNodeBreadthLimit          = 100\n\tdefaultListObjectsDeadline              = 3 * time.Second\n\tdefaultListObjectsMaxResults            = 1000\n\tdefaultMaxConcurrentReadsForListObjects = math.MaxUint32\n)\n\nvar (\n\tfurtherEvalRequiredCounter = promauto.NewCounter(prometheus.CounterOpts{\n\t\tName: \"list_objects_further_eval_required_count\",\n\t\tHelp: \"Number of objects in a ListObjects call that needed to issue a Check call to determine a final result\",\n\t})\n\n\tnoFurtherEvalRequiredCounter = promauto.NewCounter(prometheus.CounterOpts{\n\t\tName: \"list_objects_no_further_eval_required_count\",\n\t\tHelp: \"Number of objects in a ListObjects call that needed to issue a Check call to determine a final result\",\n\t})\n)\n\ntype ListObjectsQuery struct {\n\tdatastore               storage.RelationshipTupleReader\n\tlogger                  logger.Logger\n\tlistObjectsDeadline     time.Duration\n\tlistObjectsMaxResults   uint32\n\tresolveNodeLimit        uint32\n\tresolveNodeBreadthLimit uint32\n\tmaxConcurrentReads      uint32\n\n\tcheckOptions []graph.LocalCheckerOption\n}\n\ntype ListObjectsResponse struct {\n\tObjects            []string\n\tResolutionMetadata reverseexpand.ResolutionMetadata\n}\n\ntype ListObjectsQueryOption func(d *ListObjectsQuery)\n\nfunc WithListObjectsDeadline(deadline time.Duration) ListObjectsQueryOption {\n\treturn func(d *ListObjectsQuery) {\n\t\td.listObjectsDeadline = deadline\n\t}\n}\n\nfunc WithListObjectsMaxResults(max uint32) ListObjectsQueryOption {\n\treturn func(d *ListObjectsQuery) {\n\t\td.listObjectsMaxResults = max\n\t}\n}\n\n// WithResolveNodeLimit see server.WithResolveNodeLimit\nfunc WithResolveNodeLimit(limit uint32) ListObjectsQueryOption {\n\treturn func(d *ListObjectsQuery) {\n\t\td.resolveNodeLimit = limit\n\t}\n}\n\n// WithResolveNodeBreadthLimit see server.WithResolveNodeBreadthLimit\nfunc WithResolveNodeBreadthLimit(limit uint32) ListObjectsQueryOption {\n\treturn func(d *ListObjectsQuery) {\n\t\td.resolveNodeBreadthLimit = limit\n\t}\n}\n\nfunc WithLogger(l logger.Logger) ListObjectsQueryOption {\n\treturn func(d *ListObjectsQuery) {\n\t\td.logger = l\n\t}\n}\n\nfunc WithCheckOptions(checkOptions []graph.LocalCheckerOption) ListObjectsQueryOption {\n\treturn func(d *ListObjectsQuery) {\n\t\td.checkOptions = checkOptions\n\t}\n}\n\n// WithMaxConcurrentReads see server.WithMaxConcurrentReadsForListObjects\nfunc WithMaxConcurrentReads(limit uint32) ListObjectsQueryOption {\n\treturn func(d *ListObjectsQuery) {\n\t\td.maxConcurrentReads = limit\n\t}\n}\n\nfunc NewListObjectsQuery(ds storage.RelationshipTupleReader, opts ...ListObjectsQueryOption) *ListObjectsQuery {\n\tquery := &ListObjectsQuery{\n\t\tdatastore:               ds,\n\t\tlogger:                  logger.NewNoopLogger(),\n\t\tlistObjectsDeadline:     defaultListObjectsDeadline,\n\t\tlistObjectsMaxResults:   defaultListObjectsMaxResults,\n\t\tresolveNodeLimit:        defaultResolveNodeLimit,\n\t\tresolveNodeBreadthLimit: defaultResolveNodeBreadthLimit,\n\t\tmaxConcurrentReads:      defaultMaxConcurrentReadsForListObjects,\n\t\tcheckOptions:            []graph.LocalCheckerOption{},\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(query)\n\t}\n\n\tquery.datastore = storagewrappers.NewBoundedConcurrencyTupleReader(query.datastore, query.maxConcurrentReads)\n\n\treturn query\n}\n\ntype ListObjectsResult struct {\n\tObjectID string\n\tErr      error\n}\n\n// listObjectsRequest captures the RPC request definition interface for the ListObjects API.\n// The unary and streaming RPC definitions implement this interface, and so it can be used\n// interchangeably for a canonical representation between the two.\ntype listObjectsRequest interface {\n\tGetStoreId() string\n\tGetAuthorizationModelId() string\n\tGetType() string\n\tGetRelation() string\n\tGetUser() string\n\tGetContextualTuples() *openfgav1.ContextualTupleKeys\n}\n\nfunc (q *ListObjectsQuery) evaluate(\n\tctx context.Context,\n\treq listObjectsRequest,\n\tresultsChan chan<- ListObjectsResult,\n\tmaxResults uint32,\n\tresolutionMetadata *reverseexpand.ResolutionMetadata,\n) error {\n\n\ttargetObjectType := req.GetType()\n\ttargetRelation := req.GetRelation()\n\n\ttypesys, ok := typesystem.TypesystemFromContext(ctx)\n\tif !ok {\n\t\tpanic(\"typesystem missing in context\")\n\t}\n\n\tif !typesystem.IsSchemaVersionSupported(typesys.GetSchemaVersion()) {\n\t\treturn serverErrors.ValidationError(typesystem.ErrInvalidSchemaVersion)\n\t}\n\n\tfor _, ctxTuple := range req.GetContextualTuples().GetTupleKeys() {\n\t\tif err := validation.ValidateTuple(typesys, ctxTuple); err != nil {\n\t\t\treturn serverErrors.HandleTupleValidateError(err)\n\t\t}\n\t}\n\n\t_, err := typesys.GetRelation(targetObjectType, targetRelation)\n\tif err != nil {\n\t\tif errors.Is(err, typesystem.ErrObjectTypeUndefined) {\n\t\t\treturn serverErrors.TypeNotFound(targetObjectType)\n\t\t}\n\n\t\tif errors.Is(err, typesystem.ErrRelationUndefined) {\n\t\t\treturn serverErrors.RelationNotFound(targetRelation, targetObjectType, nil)\n\t\t}\n\n\t\treturn serverErrors.NewInternalError(\"\", err)\n\t}\n\n\tif err := validation.ValidateUser(typesys, req.GetUser()); err != nil {\n\t\treturn serverErrors.ValidationError(fmt.Errorf(\"invalid 'user' value: %s\", err))\n\t}\n\n\thandler := func() {\n\t\tuserObj, userRel := tuple.SplitObjectRelation(req.GetUser())\n\t\tuserObjType, userObjID := tuple.SplitObject(userObj)\n\n\t\tvar sourceUserRef reverseexpand.IsUserRef\n\t\tsourceUserRef = &reverseexpand.UserRefObject{\n\t\t\tObject: &openfgav1.Object{\n\t\t\t\tType: userObjType,\n\t\t\t\tId:   userObjID,\n\t\t\t},\n\t\t}\n\n\t\tif tuple.IsTypedWildcard(userObj) {\n\t\t\tsourceUserRef = &reverseexpand.UserRefTypedWildcard{Type: tuple.GetType(userObj)}\n\n\t\t}\n\n\t\tif userRel != \"\" {\n\t\t\tsourceUserRef = &reverseexpand.UserRefObjectRelation{\n\t\t\t\tObjectRelation: &openfgav1.ObjectRelation{\n\t\t\t\t\tObject:   userObj,\n\t\t\t\t\tRelation: userRel,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\treverseExpandResultsChan := make(chan *reverseexpand.ReverseExpandResult, 1)\n\t\tvar objectsFound = new(uint32)\n\n\t\treverseExpandQuery := reverseexpand.NewReverseExpandQuery(q.datastore, typesys,\n\t\t\treverseexpand.WithResolveNodeLimit(q.resolveNodeLimit),\n\t\t\treverseexpand.WithResolveNodeBreadthLimit(q.resolveNodeBreadthLimit),\n\t\t)\n\n\t\tgo func() {\n\t\t\terr = reverseExpandQuery.Execute(ctx, &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:          req.GetStoreId(),\n\t\t\t\tObjectType:       targetObjectType,\n\t\t\t\tRelation:         targetRelation,\n\t\t\t\tUser:             sourceUserRef,\n\t\t\t\tContextualTuples: req.GetContextualTuples().GetTupleKeys(),\n\t\t\t}, reverseExpandResultsChan, resolutionMetadata)\n\t\t\tif err != nil {\n\t\t\t\tif errors.Is(err, graph.ErrResolutionDepthExceeded) || errors.Is(err, graph.ErrCycleDetected) {\n\t\t\t\t\tresultsChan <- ListObjectsResult{Err: serverErrors.AuthorizationModelResolutionTooComplex}\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tresultsChan <- ListObjectsResult{Err: err}\n\t\t\t}\n\n\t\t\t// this is necessary to terminate the range loop below\n\t\t\tclose(reverseExpandResultsChan)\n\t\t}()\n\n\t\tcheckResolver := graph.NewLocalChecker(\n\t\t\tstoragewrappers.NewCombinedTupleReader(q.datastore, req.GetContextualTuples().GetTupleKeys()),\n\t\t\tq.checkOptions...,\n\t\t)\n\t\tdefer checkResolver.Close()\n\n\t\tconcurrencyLimiterCh := make(chan struct{}, q.resolveNodeBreadthLimit)\n\n\t\twg := sync.WaitGroup{}\n\n\t\tfor res := range reverseExpandResultsChan {\n\t\t\tif atomic.LoadUint32(objectsFound) >= maxResults {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif res.ResultStatus == reverseexpand.NoFurtherEvalStatus {\n\t\t\t\tnoFurtherEvalRequiredCounter.Inc()\n\t\t\t\ttrySendObject(res.Object, objectsFound, maxResults, resultsChan)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfurtherEvalRequiredCounter.Inc()\n\n\t\t\twg.Add(1)\n\t\t\tgo func(res *reverseexpand.ReverseExpandResult) {\n\t\t\t\tdefer func() {\n\t\t\t\t\t<-concurrencyLimiterCh\n\t\t\t\t\twg.Done()\n\t\t\t\t}()\n\n\t\t\t\tconcurrencyLimiterCh <- struct{}{}\n\n\t\t\t\tresp, err := checkResolver.ResolveCheck(ctx, &graph.ResolveCheckRequest{\n\t\t\t\t\tStoreID:              req.GetStoreId(),\n\t\t\t\t\tAuthorizationModelID: req.GetAuthorizationModelId(),\n\t\t\t\t\tTupleKey:             tuple.NewTupleKey(res.Object, req.GetRelation(), req.GetUser()),\n\t\t\t\t\tContextualTuples:     req.GetContextualTuples().GetTupleKeys(),\n\t\t\t\t\tResolutionMetadata: &graph.ResolutionMetadata{\n\t\t\t\t\t\tDepth: q.resolveNodeLimit,\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\tif errors.Is(err, graph.ErrResolutionDepthExceeded) || errors.Is(err, graph.ErrCycleDetected) {\n\t\t\t\t\t\tresultsChan <- ListObjectsResult{Err: serverErrors.AuthorizationModelResolutionTooComplex}\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tresultsChan <- ListObjectsResult{Err: err}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tatomic.AddUint32(resolutionMetadata.QueryCount, resp.GetResolutionMetadata().DatastoreQueryCount)\n\n\t\t\t\tif resp.Allowed {\n\t\t\t\t\ttrySendObject(res.Object, objectsFound, maxResults, resultsChan)\n\t\t\t\t}\n\t\t\t}(res)\n\t\t}\n\n\t\twg.Wait()\n\n\t\tclose(resultsChan)\n\t}\n\n\tgo handler()\n\n\treturn nil\n}\n\nfunc trySendObject(object string, objectsFound *uint32, maxResults uint32, resultsChan chan<- ListObjectsResult) {\n\tif objectsFound != nil && atomic.AddUint32(objectsFound, 1) > maxResults {\n\t\treturn\n\t}\n\tresultsChan <- ListObjectsResult{ObjectID: object}\n}\n\n// Execute the ListObjectsQuery, returning a list of object IDs up to a maximum of q.listObjectsMaxResults\n// or until q.listObjectsDeadline is hit, whichever happens first.\nfunc (q *ListObjectsQuery) Execute(\n\tctx context.Context,\n\treq *openfgav1.ListObjectsRequest,\n) (*ListObjectsResponse, error) {\n\n\tresultsChan := make(chan ListObjectsResult, 1)\n\tmaxResults := q.listObjectsMaxResults\n\tif maxResults > 0 {\n\t\tresultsChan = make(chan ListObjectsResult, maxResults)\n\t}\n\n\ttimeoutCtx := ctx\n\tif q.listObjectsDeadline != 0 {\n\t\tvar cancel context.CancelFunc\n\t\ttimeoutCtx, cancel = context.WithTimeout(ctx, q.listObjectsDeadline)\n\t\tdefer cancel()\n\t}\n\n\tresolutionMetadata := reverseexpand.NewResolutionMetadata()\n\n\terr := q.evaluate(timeoutCtx, req, resultsChan, maxResults, resolutionMetadata)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tobjects := make([]string, 0)\n\n\tfor {\n\t\tselect {\n\n\t\tcase <-timeoutCtx.Done():\n\t\t\tq.logger.WarnWithContext(\n\t\t\t\tctx, fmt.Sprintf(\"list objects timeout after %s\", q.listObjectsDeadline.String()),\n\t\t\t)\n\t\t\treturn &ListObjectsResponse{\n\t\t\t\tObjects:            objects,\n\t\t\t\tResolutionMetadata: *resolutionMetadata,\n\t\t\t}, nil\n\n\t\tcase result, channelOpen := <-resultsChan:\n\t\t\tif result.Err != nil {\n\t\t\t\tif errors.Is(result.Err, serverErrors.AuthorizationModelResolutionTooComplex) {\n\t\t\t\t\treturn nil, result.Err\n\t\t\t\t}\n\n\t\t\t\treturn nil, serverErrors.HandleError(\"\", result.Err)\n\t\t\t}\n\n\t\t\tif !channelOpen {\n\t\t\t\treturn &ListObjectsResponse{\n\t\t\t\t\tObjects:            objects,\n\t\t\t\t\tResolutionMetadata: *resolutionMetadata,\n\t\t\t\t}, nil\n\t\t\t}\n\t\t\tobjects = append(objects, result.ObjectID)\n\t\t}\n\t}\n}\n\n// ExecuteStreamed executes the ListObjectsQuery, returning a stream of object IDs.\n// It ignores the value of q.listObjectsMaxResults and returns all available results\n// until q.listObjectsDeadline is hit\nfunc (q *ListObjectsQuery) ExecuteStreamed(ctx context.Context, req *openfgav1.StreamedListObjectsRequest, srv openfgav1.OpenFGAService_StreamedListObjectsServer) (*reverseexpand.ResolutionMetadata, error) {\n\n\tmaxResults := uint32(math.MaxUint32)\n\t// make a buffered channel so that writer goroutines aren't blocked when attempting to send a result\n\tresultsChan := make(chan ListObjectsResult, streamedBufferSize)\n\n\ttimeoutCtx := ctx\n\tif q.listObjectsDeadline != 0 {\n\t\tvar cancel context.CancelFunc\n\t\ttimeoutCtx, cancel = context.WithTimeout(ctx, q.listObjectsDeadline)\n\t\tdefer cancel()\n\t}\n\n\tresolutionMetadata := reverseexpand.NewResolutionMetadata()\n\n\terr := q.evaluate(timeoutCtx, req, resultsChan, maxResults, resolutionMetadata)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor {\n\t\tselect {\n\n\t\tcase <-timeoutCtx.Done():\n\t\t\tq.logger.WarnWithContext(\n\t\t\t\tctx, fmt.Sprintf(\"list objects timeout after %s\", q.listObjectsDeadline.String()),\n\t\t\t)\n\t\t\treturn resolutionMetadata, nil\n\n\t\tcase result, channelOpen := <-resultsChan:\n\t\t\tif !channelOpen {\n\t\t\t\t// Channel closed! No more results.\n\t\t\t\treturn resolutionMetadata, nil\n\t\t\t}\n\n\t\t\tif result.Err != nil {\n\t\t\t\tif errors.Is(result.Err, serverErrors.AuthorizationModelResolutionTooComplex) {\n\t\t\t\t\treturn nil, result.Err\n\t\t\t\t}\n\n\t\t\t\treturn nil, serverErrors.HandleError(\"\", result.Err)\n\t\t\t}\n\n\t\t\tif err := srv.Send(&openfgav1.StreamedListObjectsResponse{\n\t\t\t\tObject: result.ObjectID,\n\t\t\t}); err != nil {\n\t\t\t\treturn nil, serverErrors.NewInternalError(\"\", err)\n\t\t\t}\n\t\t}\n\t}\n}\n", "// Package reverseexpand contains the code that handles the ReverseExpand API\npackage reverseexpand\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\"\n\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\t\"github.com/openfga/openfga/internal/graph\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/storage/storagewrappers\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"go.opentelemetry.io/otel\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"golang.org/x/sync/errgroup\"\n)\n\nvar tracer = otel.Tracer(\"openfga/pkg/server/commands/reverse_expand\")\n\nconst (\n\t// same values as run.DefaultConfig() (TODO break the import cycle, remove these hardcoded values and import those constants here)\n\tdefaultResolveNodeLimit        = 25\n\tdefaultResolveNodeBreadthLimit = 100\n)\n\ntype ReverseExpandRequest struct {\n\tStoreID          string\n\tObjectType       string\n\tRelation         string\n\tUser             IsUserRef\n\tContextualTuples []*openfgav1.TupleKey\n}\n\n// TODO combine with above?\ntype reverseExpandRequest struct {\n\tstoreID          string\n\tedge             *graph.RelationshipEdge\n\ttargetObjectRef  *openfgav1.RelationReference\n\tsourceUserRef    IsUserRef\n\tcontextualTuples []*openfgav1.TupleKey\n}\n\ntype IsUserRef interface {\n\tisUserRef()\n\tGetObjectType() string\n\tString() string\n}\n\ntype UserRefObject struct {\n\tObject *openfgav1.Object\n}\n\nvar _ IsUserRef = (*UserRefObject)(nil)\n\nfunc (u *UserRefObject) isUserRef() {}\n\nfunc (u *UserRefObject) GetObjectType() string {\n\treturn u.Object.Type\n}\n\nfunc (u *UserRefObject) String() string {\n\treturn tuple.BuildObject(u.Object.GetType(), u.Object.GetId())\n}\n\ntype UserRefTypedWildcard struct {\n\tType string\n}\n\nvar _ IsUserRef = (*UserRefTypedWildcard)(nil)\n\nfunc (*UserRefTypedWildcard) isUserRef() {}\n\nfunc (u *UserRefTypedWildcard) GetObjectType() string {\n\treturn u.Type\n}\n\nfunc (u *UserRefTypedWildcard) String() string {\n\treturn fmt.Sprintf(\"%s:*\", u.Type)\n}\n\ntype UserRefObjectRelation struct {\n\tObjectRelation *openfgav1.ObjectRelation\n}\n\nfunc (*UserRefObjectRelation) isUserRef() {}\n\nfunc (u *UserRefObjectRelation) GetObjectType() string {\n\treturn tuple.GetType(u.ObjectRelation.Object)\n}\n\nfunc (u *UserRefObjectRelation) String() string {\n\treturn tuple.ToObjectRelationString(\n\t\tu.ObjectRelation.GetObject(),\n\t\tu.ObjectRelation.GetRelation(),\n\t)\n}\n\ntype UserRef struct {\n\n\t// Types that are assignable to Ref\n\t//  *UserRef_Object\n\t//  *UserRef_TypedWildcard\n\t//  *UserRef_ObjectRelation\n\tRef IsUserRef\n}\n\ntype ReverseExpandQuery struct {\n\tdatastore               storage.RelationshipTupleReader\n\ttypesystem              *typesystem.TypeSystem\n\tresolveNodeLimit        uint32\n\tresolveNodeBreadthLimit uint32\n\n\t// visitedUsersetsMap map prevents visiting the same userset through the same edge twice\n\tvisitedUsersetsMap *sync.Map\n\t// candidateObjectsMap map prevents returning the same object twice\n\tcandidateObjectsMap *sync.Map\n}\n\ntype ReverseExpandQueryOption func(d *ReverseExpandQuery)\n\nfunc WithResolveNodeLimit(limit uint32) ReverseExpandQueryOption {\n\treturn func(d *ReverseExpandQuery) {\n\t\td.resolveNodeLimit = limit\n\t}\n}\n\nfunc WithResolveNodeBreadthLimit(limit uint32) ReverseExpandQueryOption {\n\treturn func(d *ReverseExpandQuery) {\n\t\td.resolveNodeBreadthLimit = limit\n\t}\n}\n\nfunc NewReverseExpandQuery(ds storage.RelationshipTupleReader, ts *typesystem.TypeSystem, opts ...ReverseExpandQueryOption) *ReverseExpandQuery {\n\tquery := &ReverseExpandQuery{\n\t\tdatastore:               ds,\n\t\ttypesystem:              ts,\n\t\tresolveNodeLimit:        defaultResolveNodeLimit,\n\t\tresolveNodeBreadthLimit: defaultResolveNodeBreadthLimit,\n\t\tcandidateObjectsMap:     new(sync.Map),\n\t\tvisitedUsersetsMap:      new(sync.Map),\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(query)\n\t}\n\n\treturn query\n}\n\ntype ConditionalResultStatus int\n\nconst (\n\tRequiresFurtherEvalStatus ConditionalResultStatus = iota\n\tNoFurtherEvalStatus\n)\n\ntype ReverseExpandResult struct {\n\tObject       string\n\tResultStatus ConditionalResultStatus\n}\n\ntype ResolutionMetadata struct {\n\tQueryCount *uint32\n}\n\nfunc NewResolutionMetadata() *ResolutionMetadata {\n\treturn &ResolutionMetadata{\n\t\tQueryCount: new(uint32),\n\t}\n}\n\n// Execute yields all the objects of the provided objectType that the given user has, possibly, a specific relation with\n// and sends those objects to resultChan. It MUST guarantee no duplicate objects sent.\nfunc (c *ReverseExpandQuery) Execute(\n\tctx context.Context,\n\treq *ReverseExpandRequest,\n\tresultChan chan<- *ReverseExpandResult,\n\tresolutionMetadata *ResolutionMetadata,\n) error {\n\treturn c.execute(ctx, req, resultChan, nil, resolutionMetadata)\n}\n\nfunc (c *ReverseExpandQuery) execute(\n\tctx context.Context,\n\treq *ReverseExpandRequest,\n\tresultChan chan<- *ReverseExpandResult,\n\tcurrentEdge *graph.RelationshipEdge,\n\tresolutionMetadata *ResolutionMetadata,\n) error {\n\tctx, span := tracer.Start(ctx, \"reverseExpand.Execute\", trace.WithAttributes(\n\t\tattribute.String(\"target_type\", req.ObjectType),\n\t\tattribute.String(\"target_relation\", req.Relation),\n\t\tattribute.String(\"source\", req.User.String()),\n\t))\n\tdefer span.End()\n\n\tif currentEdge != nil {\n\t\tspan.SetAttributes(attribute.String(\"edge\", currentEdge.String()))\n\t}\n\n\tdepth, ok := graph.ResolutionDepthFromContext(ctx)\n\tif !ok {\n\t\tctx = graph.ContextWithResolutionDepth(ctx, 0)\n\t} else {\n\t\tif depth >= c.resolveNodeLimit {\n\t\t\treturn graph.ErrResolutionDepthExceeded\n\t\t}\n\n\t\tctx = graph.ContextWithResolutionDepth(ctx, depth+1)\n\t}\n\n\tstoreID := req.StoreID\n\n\tvar sourceUserRef *openfgav1.RelationReference\n\tvar sourceUserType, sourceUserObj string\n\n\t// e.g. 'user:bob'\n\tif val, ok := req.User.(*UserRefObject); ok {\n\t\tsourceUserType = val.Object.GetType()\n\t\tsourceUserObj = tuple.BuildObject(sourceUserType, val.Object.GetId())\n\t\tsourceUserRef = typesystem.DirectRelationReference(sourceUserType, \"\")\n\t}\n\n\t// e.g. 'user:*'\n\tif val, ok := req.User.(*UserRefTypedWildcard); ok {\n\t\tsourceUserType = val.Type\n\t\tsourceUserRef = typesystem.WildcardRelationReference(sourceUserType)\n\t}\n\n\t// e.g. 'group:eng#member'\n\tif val, ok := req.User.(*UserRefObjectRelation); ok {\n\t\tsourceUserType = tuple.GetType(val.ObjectRelation.GetObject())\n\t\tsourceUserObj = val.ObjectRelation.Object\n\t\tsourceUserRef = typesystem.DirectRelationReference(sourceUserType, val.ObjectRelation.GetRelation())\n\t\tsourceUserRel := val.ObjectRelation.GetRelation()\n\n\t\tif currentEdge != nil {\n\t\t\tkey := fmt.Sprintf(\"%s#%s\", sourceUserObj, currentEdge.String())\n\t\t\tif _, loaded := c.visitedUsersetsMap.LoadOrStore(key, struct{}{}); loaded {\n\t\t\t\t// we've already visited this userset through this edge, exit to avoid an infinite cycle\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tif sourceUserType == req.ObjectType && sourceUserRel == req.Relation {\n\t\t\t\tc.trySendCandidate(ctx, currentEdge, sourceUserObj, resultChan)\n\t\t\t}\n\t\t}\n\t}\n\n\ttargetObjRef := typesystem.DirectRelationReference(req.ObjectType, req.Relation)\n\n\tg := graph.New(c.typesystem)\n\n\tedges, err := g.GetPrunedRelationshipEdges(targetObjRef, sourceUserRef)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsubg, subgctx := errgroup.WithContext(ctx)\n\tsubg.SetLimit(int(c.resolveNodeBreadthLimit))\n\n\tfor _, edge := range edges {\n\t\tinnerLoopEdge := edge\n\t\tif currentEdge != nil && currentEdge.Condition == graph.RequiresFurtherEvalCondition {\n\t\t\t// propagate the condition to upcoming reverse expansions\n\t\t\t// TODO don't mutate the edge, keep track of the previous edge's condition and use it in trySendCandidate\n\t\t\tinnerLoopEdge.Condition = graph.RequiresFurtherEvalCondition\n\t\t}\n\t\tsubg.Go(func() error {\n\t\t\tr := &reverseExpandRequest{\n\t\t\t\tstoreID:          storeID,\n\t\t\t\tedge:             innerLoopEdge,\n\t\t\t\ttargetObjectRef:  targetObjRef,\n\t\t\t\tsourceUserRef:    req.User,\n\t\t\t\tcontextualTuples: req.ContextualTuples,\n\t\t\t}\n\n\t\t\tswitch innerLoopEdge.Type {\n\t\t\tcase graph.DirectEdge:\n\t\t\t\treturn c.reverseExpandDirect(subgctx, r, resultChan, resolutionMetadata)\n\t\t\tcase graph.ComputedUsersetEdge:\n\t\t\t\t// lookup the rewritten target relation on the computed_userset ingress\n\t\t\t\treturn c.execute(subgctx, &ReverseExpandRequest{\n\t\t\t\t\tStoreID:    storeID,\n\t\t\t\t\tObjectType: req.ObjectType,\n\t\t\t\t\tRelation:   req.Relation,\n\t\t\t\t\tUser: &UserRefObjectRelation{\n\t\t\t\t\t\tObjectRelation: &openfgav1.ObjectRelation{\n\t\t\t\t\t\t\tObject:   sourceUserObj,\n\t\t\t\t\t\t\tRelation: innerLoopEdge.TargetReference.GetRelation(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tContextualTuples: r.contextualTuples,\n\t\t\t\t}, resultChan, innerLoopEdge, resolutionMetadata)\n\t\t\tcase graph.TupleToUsersetEdge:\n\t\t\t\treturn c.reverseExpandTupleToUserset(subgctx, r, resultChan, resolutionMetadata)\n\t\t\tdefault:\n\t\t\t\treturn fmt.Errorf(\"unsupported edge type\")\n\t\t\t}\n\t\t})\n\t}\n\n\treturn subg.Wait()\n}\n\nfunc (c *ReverseExpandQuery) reverseExpandTupleToUserset(\n\tctx context.Context,\n\treq *reverseExpandRequest,\n\tresultChan chan<- *ReverseExpandResult,\n\tresolutionMetadata *ResolutionMetadata,\n) error {\n\tctx, span := tracer.Start(ctx, \"reverseExpandTupleToUserset\", trace.WithAttributes(\n\t\tattribute.String(\"edge\", req.edge.String()),\n\t\tattribute.String(\"source.user\", req.sourceUserRef.String()),\n\t))\n\tdefer span.End()\n\n\tstore := req.storeID\n\n\ttargetObjectType := req.targetObjectRef.GetType()\n\ttargetObjectRel := req.targetObjectRef.GetRelation()\n\n\tvar userFilter []*openfgav1.ObjectRelation\n\n\t// a TTU edge can only have a userset as a source node\n\t// e.g. 'group:eng#member'\n\tif val, ok := req.sourceUserRef.(*UserRefObjectRelation); ok {\n\t\tuserFilter = append(userFilter, &openfgav1.ObjectRelation{\n\t\t\tObject: val.ObjectRelation.Object,\n\t\t})\n\t} else {\n\t\tpanic(\"unexpected source for reverse expansion of tuple to userset\")\n\t}\n\n\tcombinedTupleReader := storagewrappers.NewCombinedTupleReader(c.datastore, req.contextualTuples)\n\n\t// find all tuples of the form req.edge.TargetReference.Type:...#req.edge.TuplesetRelation@req.sourceUserRef\n\titer, err := combinedTupleReader.ReadStartingWithUser(ctx, store, storage.ReadStartingWithUserFilter{\n\t\tObjectType: req.edge.TargetReference.GetType(),\n\t\tRelation:   req.edge.TuplesetRelation.GetRelation(),\n\t\tUserFilter: userFilter,\n\t})\n\tatomic.AddUint32(resolutionMetadata.QueryCount, 1)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer iter.Stop()\n\n\tsubg, subgctx := errgroup.WithContext(ctx)\n\tsubg.SetLimit(int(c.resolveNodeBreadthLimit))\n\n\tfor {\n\t\tt, err := iter.Next()\n\t\tif err != nil {\n\t\t\tif errors.Is(err, storage.ErrIteratorDone) {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\treturn err\n\t\t}\n\n\t\ttk := t.GetKey()\n\n\t\tfoundObject := tk.GetObject()\n\n\t\tsourceUserRef := &UserRefObjectRelation{\n\t\t\tObjectRelation: &openfgav1.ObjectRelation{\n\t\t\t\tObject:   foundObject,\n\t\t\t\tRelation: req.edge.TargetReference.GetRelation(),\n\t\t\t},\n\t\t}\n\n\t\tsubg.Go(func() error {\n\t\t\treturn c.execute(subgctx, &ReverseExpandRequest{\n\t\t\t\tStoreID:          store,\n\t\t\t\tObjectType:       targetObjectType,\n\t\t\t\tRelation:         targetObjectRel,\n\t\t\t\tUser:             sourceUserRef,\n\t\t\t\tContextualTuples: req.contextualTuples,\n\t\t\t}, resultChan, req.edge, resolutionMetadata)\n\t\t})\n\t}\n\n\treturn subg.Wait()\n}\n\nfunc (c *ReverseExpandQuery) reverseExpandDirect(\n\tctx context.Context,\n\treq *reverseExpandRequest,\n\tresultChan chan<- *ReverseExpandResult,\n\tresolutionMetadata *ResolutionMetadata,\n) error {\n\tctx, span := tracer.Start(ctx, \"reverseExpandDirect\", trace.WithAttributes(\n\t\tattribute.String(\"edge\", req.edge.String()),\n\t\tattribute.String(\"source.user\", req.sourceUserRef.String()),\n\t))\n\tdefer span.End()\n\n\tstore := req.storeID\n\n\ttargetObjectType := req.targetObjectRef.GetType()\n\ttargetObjectRel := req.targetObjectRef.GetRelation()\n\n\tvar userFilter []*openfgav1.ObjectRelation\n\n\ttargetUserObjectType := req.sourceUserRef.GetObjectType()\n\n\tpubliclyAssignable, err := c.typesystem.IsPubliclyAssignable(req.edge.TargetReference, targetUserObjectType)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif publiclyAssignable {\n\t\t// e.g. 'user:*'\n\t\tuserFilter = append(userFilter, &openfgav1.ObjectRelation{\n\t\t\tObject: fmt.Sprintf(\"%s:*\", targetUserObjectType),\n\t\t})\n\t}\n\n\tsourceRelationRef := &openfgav1.RelationReference{\n\t\tType: req.sourceUserRef.GetObjectType(),\n\t}\n\n\t// e.g. 'user:bob'\n\tif val, ok := req.sourceUserRef.(*UserRefObject); ok {\n\t\tuserFilter = append(userFilter, &openfgav1.ObjectRelation{\n\t\t\tObject: tuple.BuildObject(val.Object.Type, val.Object.Id),\n\t\t})\n\t}\n\n\t// e.g. 'group:eng#member'\n\tif val, ok := req.sourceUserRef.(*UserRefObjectRelation); ok {\n\t\tsourceRelationRef.RelationOrWildcard = &openfgav1.RelationReference_Relation{\n\t\t\tRelation: val.ObjectRelation.Relation,\n\t\t}\n\n\t\tuserFilter = append(userFilter, val.ObjectRelation)\n\t}\n\n\tcombinedTupleReader := storagewrappers.NewCombinedTupleReader(c.datastore, req.contextualTuples)\n\n\t// find all tuples of the form req.edge.TargetReference.Type:...#req.edge.TargetReference.Relation@req.sourceUserRef\n\titer, err := combinedTupleReader.ReadStartingWithUser(ctx, store, storage.ReadStartingWithUserFilter{\n\t\tObjectType: req.edge.TargetReference.GetType(),\n\t\tRelation:   req.edge.TargetReference.GetRelation(),\n\t\tUserFilter: userFilter,\n\t})\n\tatomic.AddUint32(resolutionMetadata.QueryCount, 1)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer iter.Stop()\n\n\tsubg, subgctx := errgroup.WithContext(ctx)\n\tsubg.SetLimit(int(c.resolveNodeBreadthLimit))\n\n\tfor {\n\t\tt, err := iter.Next()\n\t\tif err != nil {\n\t\t\tif errors.Is(err, storage.ErrIteratorDone) {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\treturn err\n\t\t}\n\n\t\ttk := t.GetKey()\n\n\t\tfoundObject := tk.GetObject()\n\n\t\tsourceUserRef := &UserRefObjectRelation{\n\t\t\tObjectRelation: &openfgav1.ObjectRelation{\n\t\t\t\tObject:   foundObject,\n\t\t\t\tRelation: tk.GetRelation(),\n\t\t\t},\n\t\t}\n\n\t\tsubg.Go(func() error {\n\t\t\treturn c.execute(subgctx, &ReverseExpandRequest{\n\t\t\t\tStoreID:          store,\n\t\t\t\tObjectType:       targetObjectType,\n\t\t\t\tRelation:         targetObjectRel,\n\t\t\t\tUser:             sourceUserRef,\n\t\t\t\tContextualTuples: req.contextualTuples,\n\t\t\t}, resultChan, req.edge, resolutionMetadata)\n\t\t})\n\t}\n\n\treturn subg.Wait()\n}\n\nfunc (c *ReverseExpandQuery) trySendCandidate(ctx context.Context, edge *graph.RelationshipEdge, candidateObject string, candidateChan chan<- *ReverseExpandResult) {\n\t_, span := tracer.Start(ctx, \"trySendCandidate\", trace.WithAttributes(\n\t\tattribute.String(\"object\", candidateObject),\n\t\tattribute.Bool(\"sent\", false),\n\t))\n\tdefer span.End()\n\tif _, ok := c.candidateObjectsMap.LoadOrStore(candidateObject, struct{}{}); !ok {\n\t\tresultStatus := NoFurtherEvalStatus\n\t\tif edge != nil && edge.Condition == graph.RequiresFurtherEvalCondition {\n\t\t\tspan.SetAttributes(attribute.Bool(\"requires_further_eval\", true))\n\t\t\tresultStatus = RequiresFurtherEvalStatus\n\t\t}\n\t\tcandidateChan <- &ReverseExpandResult{\n\t\t\tObject:       candidateObject,\n\t\t\tResultStatus: resultStatus,\n\t\t}\n\t\tspan.SetAttributes(attribute.Bool(\"sent\", true))\n\t}\n}\n", "// Package server contains the endpoint handlers.\npackage server\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"net/http\"\n\t\"slices\"\n\t\"sort\"\n\t\"strconv\"\n\t\"time\"\n\n\tgrpc_ctxtags \"github.com/grpc-ecosystem/go-grpc-middleware/tags\"\n\t\"github.com/karlseguin/ccache/v3\"\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\t\"github.com/openfga/openfga/internal/gateway\"\n\t\"github.com/openfga/openfga/internal/graph\"\n\t\"github.com/openfga/openfga/internal/utils\"\n\t\"github.com/openfga/openfga/internal/validation\"\n\t\"github.com/openfga/openfga/pkg/encoder\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\thttpmiddleware \"github.com/openfga/openfga/pkg/middleware/http\"\n\t\"github.com/openfga/openfga/pkg/middleware/validator\"\n\t\"github.com/openfga/openfga/pkg/server/commands\"\n\tserverErrors \"github.com/openfga/openfga/pkg/server/errors\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/storage/storagewrappers\"\n\t\"github.com/openfga/openfga/pkg/telemetry\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promauto\"\n\t\"go.opentelemetry.io/otel\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"go.uber.org/zap\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"google.golang.org/grpc/status\"\n)\n\ntype ExperimentalFeatureFlag string\n\nconst (\n\tAuthorizationModelIDHeader                          = \"openfga-authorization-model-id\"\n\tauthorizationModelIDKey                             = \"authorization_model_id\"\n\tExperimentalCheckQueryCache ExperimentalFeatureFlag = \"check-query-cache\"\n\n\t// same values as run.DefaultConfig() (TODO break the import cycle, remove these hardcoded values and import those constants here)\n\tdefaultChangelogHorizonOffset           = 0\n\tdefaultResolveNodeLimit                 = 25\n\tdefaultResolveNodeBreadthLimit          = 100\n\tdefaultListObjectsDeadline              = 3 * time.Second\n\tdefaultListObjectsMaxResults            = 1000\n\tdefaultMaxConcurrentReadsForCheck       = math.MaxUint32\n\tdefaultMaxConcurrentReadsForListObjects = math.MaxUint32\n\tdefaultCheckQueryCacheLimit             = 10000\n\tdefaultCheckQueryCacheTTL               = 10 * time.Second\n\tdefaultCheckQueryCacheEnable            = false\n)\n\nvar tracer = otel.Tracer(\"openfga/pkg/server\")\n\nvar (\n\tdatastoreQueryCountHistogramName = \"datastore_query_count\"\n\n\tdatastoreQueryCountHistogram = promauto.NewHistogramVec(prometheus.HistogramOpts{\n\t\tName:                            datastoreQueryCountHistogramName,\n\t\tHelp:                            \"The number of database queries required to resolve a query (e.g. Check or ListObjects).\",\n\t\tBuckets:                         []float64{1, 5, 20, 50, 100, 150, 225, 400, 500, 750, 1000},\n\t\tNativeHistogramBucketFactor:     1.1,\n\t\tNativeHistogramMaxBucketNumber:  100,\n\t\tNativeHistogramMinResetDuration: time.Hour,\n\t}, []string{\"grpc_service\", \"grpc_method\"})\n\n\trequestDurationByQueryHistogramName = \"request_duration_by_query_count_ms\"\n\n\trequestDurationByQueryHistogram = promauto.NewHistogramVec(prometheus.HistogramOpts{\n\t\tName:                            requestDurationByQueryHistogramName,\n\t\tHelp:                            \"The request duration (in ms) labeled by method and buckets of datastore query counts. This allows for reporting percentiles based on the number of datastore queries required to resolve the request.\",\n\t\tBuckets:                         []float64{1, 5, 10, 25, 50, 80, 100, 150, 200, 300, 1000, 2000, 5000},\n\t\tNativeHistogramBucketFactor:     1.1,\n\t\tNativeHistogramMaxBucketNumber:  100,\n\t\tNativeHistogramMinResetDuration: time.Hour,\n\t}, []string{\"grpc_service\", \"grpc_method\", \"datastore_query_count\"})\n)\n\n// A Server implements the OpenFGA service backend as both\n// a GRPC and HTTP server.\ntype Server struct {\n\topenfgav1.UnimplementedOpenFGAServiceServer\n\n\tlogger                           logger.Logger\n\tdatastore                        storage.OpenFGADatastore\n\tencoder                          encoder.Encoder\n\ttransport                        gateway.Transport\n\tresolveNodeLimit                 uint32\n\tresolveNodeBreadthLimit          uint32\n\tchangelogHorizonOffset           int\n\tlistObjectsDeadline              time.Duration\n\tlistObjectsMaxResults            uint32\n\tmaxConcurrentReadsForListObjects uint32\n\tmaxConcurrentReadsForCheck       uint32\n\texperimentals                    []ExperimentalFeatureFlag\n\n\ttypesystemResolver typesystem.TypesystemResolverFunc\n\n\tcheckOptions           []graph.LocalCheckerOption\n\tcheckQueryCacheEnabled bool\n\tcheckQueryCacheLimit   uint32\n\tcheckQueryCacheTTL     time.Duration\n\tcheckCache             *ccache.Cache[*graph.CachedResolveCheckResponse] // checkCache has to be shared across requests\n\n\trequestDurationByQueryHistogramBuckets []uint\n}\n\ntype OpenFGAServiceV1Option func(s *Server)\n\nfunc WithDatastore(ds storage.OpenFGADatastore) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\ts.datastore = ds\n\t}\n}\n\nfunc WithLogger(l logger.Logger) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\ts.logger = l\n\t}\n}\n\nfunc WithTokenEncoder(encoder encoder.Encoder) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\ts.encoder = encoder\n\t}\n}\n\nfunc WithTransport(t gateway.Transport) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\ts.transport = t\n\t}\n}\n\n// WithResolveNodeLimit sets a limit on the number of recursive calls that one Check or ListObjects call will allow.\n// Thinking of a request as a tree of evaluations, this option controls\n// how many levels we will evaluate before throwing an error that the authorization model is too complex.\nfunc WithResolveNodeLimit(limit uint32) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\ts.resolveNodeLimit = limit\n\t}\n}\n\n// WithResolveNodeBreadthLimit sets a limit on the number of goroutines that can be created\n// when evaluating a subtree of a Check or ListObjects call.\n// Thinking of a Check request as a tree of evaluations, this option controls,\n// on a given level of the tree, the maximum number of nodes that can be evaluated concurrently (the breadth).\n// If your authorization models are very complex (e.g. one relation is a union of many relations, or one relation\n// is deeply nested), or if you have lots of users for (object, relation) pairs,\n// you should set this option to be a low number (e.g. 1000)\nfunc WithResolveNodeBreadthLimit(limit uint32) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\ts.resolveNodeBreadthLimit = limit\n\t}\n}\n\nfunc WithChangelogHorizonOffset(offset int) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\ts.changelogHorizonOffset = offset\n\t}\n}\n\nfunc WithListObjectsDeadline(deadline time.Duration) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\ts.listObjectsDeadline = deadline\n\t}\n}\n\nfunc WithListObjectsMaxResults(limit uint32) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\ts.listObjectsMaxResults = limit\n\t}\n}\n\n// WithMaxConcurrentReadsForListObjects sets a limit on the number of datastore reads that can be in flight for a given ListObjects call.\n// This number should be set depending on the RPS expected for Check and ListObjects APIs, the number of OpenFGA replicas running,\n// and the number of connections the datastore allows.\n// E.g. if Datastore.MaxOpenConns = 100 and assuming that each ListObjects call takes 1 second and no traffic to Check API:\n// - One OpenFGA replica and expected traffic of 100 RPS => set it to 1.\n// - One OpenFGA replica and expected traffic of 1 RPS => set it to 100.\n// - Two OpenFGA replicas and expected traffic of 1 RPS => set it to 50.\nfunc WithMaxConcurrentReadsForListObjects(max uint32) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\ts.maxConcurrentReadsForListObjects = max\n\t}\n}\n\n// WithMaxConcurrentReadsForCheck sets a limit on the number of datastore reads that can be in flight for a given Check call.\n// This number should be set depending on the RPS expected for Check and ListObjects APIs, the number of OpenFGA replicas running,\n// and the number of connections the datastore allows.\n// E.g. if Datastore.MaxOpenConns = 100 and assuming that each Check call takes 1 second and no traffic to ListObjects API:\n// - One OpenFGA replica and expected traffic of 100 RPS => set it to 1.\n// - One OpenFGA replica and expected traffic of 1 RPS => set it to 100.\n// - Two OpenFGA replicas and expected traffic of 1 RPS => set it to 50.\nfunc WithMaxConcurrentReadsForCheck(max uint32) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\ts.maxConcurrentReadsForCheck = max\n\t}\n}\n\nfunc WithExperimentals(experimentals ...ExperimentalFeatureFlag) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\ts.experimentals = experimentals\n\t}\n}\n\n// WithCheckQueryCacheEnabled enables/disables caching of check and list objects partial results.\nfunc WithCheckQueryCacheEnabled(enabled bool) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\ts.checkQueryCacheEnabled = enabled\n\t}\n}\n\n// WithCheckQueryCacheLimit sets the cache size limit (in items)\nfunc WithCheckQueryCacheLimit(limit uint32) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\ts.checkQueryCacheLimit = limit\n\t}\n}\n\n// WithCheckQueryCacheTTL sets the TTL of cached checks and list objects partial results\nfunc WithCheckQueryCacheTTL(ttl time.Duration) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\ts.checkQueryCacheTTL = ttl\n\t}\n}\n\n// WithRequestDurationByQueryHistogramBuckets sets the buckets used in labelling the requestDurationByQueryHistogram\nfunc WithRequestDurationByQueryHistogramBuckets(buckets []uint) OpenFGAServiceV1Option {\n\treturn func(s *Server) {\n\t\tsort.Slice(buckets, func(i, j int) bool { return buckets[i] < buckets[j] })\n\t\ts.requestDurationByQueryHistogramBuckets = buckets\n\t}\n}\n\nfunc MustNewServerWithOpts(opts ...OpenFGAServiceV1Option) *Server {\n\ts, err := NewServerWithOpts(opts...)\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\"failed to construct the OpenFGA server: %w\", err))\n\t}\n\n\treturn s\n}\n\nfunc NewServerWithOpts(opts ...OpenFGAServiceV1Option) (*Server, error) {\n\n\ts := &Server{\n\t\tlogger:                           logger.NewNoopLogger(),\n\t\tencoder:                          encoder.NewBase64Encoder(),\n\t\ttransport:                        gateway.NewNoopTransport(),\n\t\tchangelogHorizonOffset:           defaultChangelogHorizonOffset,\n\t\tresolveNodeLimit:                 defaultResolveNodeLimit,\n\t\tresolveNodeBreadthLimit:          defaultResolveNodeBreadthLimit,\n\t\tlistObjectsDeadline:              defaultListObjectsDeadline,\n\t\tlistObjectsMaxResults:            defaultListObjectsMaxResults,\n\t\tmaxConcurrentReadsForCheck:       defaultMaxConcurrentReadsForCheck,\n\t\tmaxConcurrentReadsForListObjects: defaultMaxConcurrentReadsForListObjects,\n\t\texperimentals:                    make([]ExperimentalFeatureFlag, 0, 10),\n\n\t\tcheckQueryCacheEnabled: defaultCheckQueryCacheEnable,\n\t\tcheckQueryCacheLimit:   defaultCheckQueryCacheLimit,\n\t\tcheckQueryCacheTTL:     defaultCheckQueryCacheTTL,\n\t\tcheckCache:             nil,\n\n\t\trequestDurationByQueryHistogramBuckets: []uint{50, 200},\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(s)\n\t}\n\n\ts.checkOptions = []graph.LocalCheckerOption{\n\t\tgraph.WithResolveNodeBreadthLimit(s.resolveNodeBreadthLimit),\n\t\tgraph.WithMaxConcurrentReads(s.maxConcurrentReadsForCheck),\n\t}\n\n\tif slices.Contains(s.experimentals, ExperimentalCheckQueryCache) && s.checkQueryCacheEnabled {\n\t\ts.logger.Info(\"Check query cache is enabled and may lead to stale query results up to the configured query cache TTL\",\n\t\t\tzap.Duration(\"CheckQueryCacheTTL\", s.checkQueryCacheTTL),\n\t\t\tzap.Uint32(\"CheckQueryCacheLimit\", s.checkQueryCacheLimit))\n\t\ts.checkCache = ccache.New(\n\t\t\tccache.Configure[*graph.CachedResolveCheckResponse]().MaxSize(int64(s.checkQueryCacheLimit)),\n\t\t)\n\t\ts.checkOptions = append(s.checkOptions, graph.WithCachedResolver(\n\t\t\tgraph.WithExistingCache(s.checkCache),\n\t\t\tgraph.WithCacheTTL(s.checkQueryCacheTTL),\n\t\t))\n\t}\n\n\tif s.datastore == nil {\n\t\treturn nil, fmt.Errorf(\"a datastore option must be provided\")\n\t}\n\n\tif len(s.requestDurationByQueryHistogramBuckets) == 0 {\n\t\treturn nil, fmt.Errorf(\"request duration datastore count buckets must not be empty\")\n\t}\n\n\ts.typesystemResolver = typesystem.MemoizedTypesystemResolverFunc(s.datastore)\n\n\treturn s, nil\n}\n\nfunc (s *Server) ListObjects(ctx context.Context, req *openfgav1.ListObjectsRequest) (*openfgav1.ListObjectsResponse, error) {\n\n\ttargetObjectType := req.GetType()\n\n\tctx, span := tracer.Start(ctx, \"ListObjects\", trace.WithAttributes(\n\t\tattribute.String(\"object_type\", targetObjectType),\n\t\tattribute.String(\"relation\", req.GetRelation()),\n\t\tattribute.String(\"user\", req.GetUser()),\n\t))\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tconst methodName = \"listobjects\"\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  methodName,\n\t})\n\n\tstoreID := req.GetStoreId()\n\n\ttypesys, err := s.resolveTypesystem(ctx, storeID, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcheckOptions := []graph.LocalCheckerOption{\n\t\tgraph.WithResolveNodeBreadthLimit(s.resolveNodeBreadthLimit),\n\t\tgraph.WithMaxConcurrentReads(s.maxConcurrentReadsForListObjects),\n\t}\n\tif s.checkCache != nil {\n\t\tcheckOptions = append(checkOptions, graph.WithCachedResolver(\n\t\t\tgraph.WithExistingCache(s.checkCache),\n\t\t\tgraph.WithCacheTTL(s.checkQueryCacheTTL),\n\t\t))\n\t}\n\n\tq := commands.NewListObjectsQuery(s.datastore,\n\t\tcommands.WithLogger(s.logger),\n\t\tcommands.WithListObjectsDeadline(s.listObjectsDeadline),\n\t\tcommands.WithListObjectsMaxResults(s.listObjectsMaxResults),\n\t\tcommands.WithResolveNodeLimit(s.resolveNodeLimit),\n\t\tcommands.WithResolveNodeBreadthLimit(s.resolveNodeBreadthLimit),\n\t\tcommands.WithCheckOptions(checkOptions),\n\t\tcommands.WithMaxConcurrentReads(s.maxConcurrentReadsForListObjects),\n\t)\n\n\tresult, err := q.Execute(\n\t\ttypesystem.ContextWithTypesystem(ctx, typesys),\n\t\t&openfgav1.ListObjectsRequest{\n\t\t\tStoreId:              storeID,\n\t\t\tContextualTuples:     req.GetContextualTuples(),\n\t\t\tAuthorizationModelId: typesys.GetAuthorizationModelID(), // the resolved model id\n\t\t\tType:                 targetObjectType,\n\t\t\tRelation:             req.Relation,\n\t\t\tUser:                 req.User,\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tqueryCount := float64(*result.ResolutionMetadata.QueryCount)\n\n\tgrpc_ctxtags.Extract(ctx).Set(datastoreQueryCountHistogramName, queryCount)\n\tspan.SetAttributes(attribute.Float64(datastoreQueryCountHistogramName, queryCount))\n\tdatastoreQueryCountHistogram.WithLabelValues(\n\t\topenfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tmethodName,\n\t).Observe(queryCount)\n\n\treturn &openfgav1.ListObjectsResponse{\n\t\tObjects: result.Objects,\n\t}, nil\n\n}\n\nfunc (s *Server) StreamedListObjects(req *openfgav1.StreamedListObjectsRequest, srv openfgav1.OpenFGAService_StreamedListObjectsServer) error {\n\tctx := srv.Context()\n\tctx, span := tracer.Start(ctx, \"StreamedListObjects\", trace.WithAttributes(\n\t\tattribute.String(\"object_type\", req.GetType()),\n\t\tattribute.String(\"relation\", req.GetRelation()),\n\t\tattribute.String(\"user\", req.GetUser()),\n\t))\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tconst methodName = \"streamedlistobjects\"\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  methodName,\n\t})\n\n\tstoreID := req.GetStoreId()\n\n\ttypesys, err := s.resolveTypesystem(ctx, storeID, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcheckOptions := []graph.LocalCheckerOption{\n\t\tgraph.WithResolveNodeBreadthLimit(s.resolveNodeBreadthLimit),\n\t\tgraph.WithMaxConcurrentReads(s.maxConcurrentReadsForListObjects),\n\t}\n\tif s.checkCache != nil {\n\t\tcheckOptions = append(checkOptions, graph.WithCachedResolver(\n\t\t\tgraph.WithExistingCache(s.checkCache),\n\t\t\tgraph.WithCacheTTL(s.checkQueryCacheTTL),\n\t\t))\n\t}\n\n\tq := commands.NewListObjectsQuery(s.datastore,\n\t\tcommands.WithLogger(s.logger),\n\t\tcommands.WithListObjectsDeadline(s.listObjectsDeadline),\n\t\tcommands.WithListObjectsMaxResults(s.listObjectsMaxResults),\n\t\tcommands.WithResolveNodeLimit(s.resolveNodeLimit),\n\t\tcommands.WithResolveNodeBreadthLimit(s.resolveNodeBreadthLimit),\n\t\tcommands.WithCheckOptions(checkOptions),\n\t\tcommands.WithMaxConcurrentReads(s.maxConcurrentReadsForListObjects),\n\t)\n\n\treq.AuthorizationModelId = typesys.GetAuthorizationModelID() // the resolved model id\n\n\tresolutionMetadata, err := q.ExecuteStreamed(\n\t\ttypesystem.ContextWithTypesystem(ctx, typesys),\n\t\treq,\n\t\tsrv,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\tqueryCount := float64(*resolutionMetadata.QueryCount)\n\n\tgrpc_ctxtags.Extract(ctx).Set(datastoreQueryCountHistogramName, queryCount)\n\tspan.SetAttributes(attribute.Float64(datastoreQueryCountHistogramName, queryCount))\n\tdatastoreQueryCountHistogram.WithLabelValues(\n\t\topenfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tmethodName,\n\t).Observe(queryCount)\n\n\treturn nil\n}\n\nfunc (s *Server) Read(ctx context.Context, req *openfgav1.ReadRequest) (*openfgav1.ReadResponse, error) {\n\n\ttk := req.GetTupleKey()\n\tctx, span := tracer.Start(ctx, \"Read\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"object\", Value: attribute.StringValue(tk.GetObject())},\n\t\tattribute.KeyValue{Key: \"relation\", Value: attribute.StringValue(tk.GetRelation())},\n\t\tattribute.KeyValue{Key: \"user\", Value: attribute.StringValue(tk.GetUser())},\n\t))\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  \"Read\",\n\t})\n\n\tq := commands.NewReadQuery(s.datastore, s.logger, s.encoder)\n\treturn q.Execute(ctx, &openfgav1.ReadRequest{\n\t\tStoreId:           req.GetStoreId(),\n\t\tTupleKey:          tk,\n\t\tPageSize:          req.GetPageSize(),\n\t\tContinuationToken: req.GetContinuationToken(),\n\t})\n}\n\nfunc (s *Server) Write(ctx context.Context, req *openfgav1.WriteRequest) (*openfgav1.WriteResponse, error) {\n\tctx, span := tracer.Start(ctx, \"Write\")\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  \"Write\",\n\t})\n\n\tstoreID := req.GetStoreId()\n\n\ttypesys, err := s.resolveTypesystem(ctx, storeID, req.AuthorizationModelId)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcmd := commands.NewWriteCommand(s.datastore, s.logger)\n\treturn cmd.Execute(ctx, &openfgav1.WriteRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: typesys.GetAuthorizationModelID(), // the resolved model id\n\t\tWrites:               req.GetWrites(),\n\t\tDeletes:              req.GetDeletes(),\n\t})\n}\n\nfunc (s *Server) Check(ctx context.Context, req *openfgav1.CheckRequest) (*openfgav1.CheckResponse, error) {\n\tstart := time.Now()\n\n\ttk := req.GetTupleKey()\n\tctx, span := tracer.Start(ctx, \"Check\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"object\", Value: attribute.StringValue(tk.GetObject())},\n\t\tattribute.KeyValue{Key: \"relation\", Value: attribute.StringValue(tk.GetRelation())},\n\t\tattribute.KeyValue{Key: \"user\", Value: attribute.StringValue(tk.GetUser())},\n\t))\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  \"Check\",\n\t})\n\n\tif tk.GetUser() == \"\" || tk.GetRelation() == \"\" || tk.GetObject() == \"\" {\n\t\treturn nil, serverErrors.InvalidCheckInput\n\t}\n\n\tstoreID := req.GetStoreId()\n\n\ttypesys, err := s.resolveTypesystem(ctx, storeID, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := validation.ValidateUserObjectRelation(typesys, tk); err != nil {\n\t\treturn nil, serverErrors.ValidationError(err)\n\t}\n\n\tfor _, ctxTuple := range req.GetContextualTuples().GetTupleKeys() {\n\t\tif err := validation.ValidateTuple(typesys, ctxTuple); err != nil {\n\t\t\treturn nil, serverErrors.HandleTupleValidateError(err)\n\t\t}\n\t}\n\n\tctx = typesystem.ContextWithTypesystem(ctx, typesys)\n\n\tcheckResolver := graph.NewLocalChecker(\n\t\tstoragewrappers.NewCombinedTupleReader(s.datastore, req.ContextualTuples.GetTupleKeys()),\n\t\ts.checkOptions...,\n\t)\n\tdefer checkResolver.Close()\n\n\tresp, err := checkResolver.ResolveCheck(ctx, &graph.ResolveCheckRequest{\n\t\tStoreID:              req.GetStoreId(),\n\t\tAuthorizationModelID: typesys.GetAuthorizationModelID(), // the resolved model id\n\t\tTupleKey:             req.GetTupleKey(),\n\t\tContextualTuples:     req.ContextualTuples.GetTupleKeys(),\n\t\tResolutionMetadata: &graph.ResolutionMetadata{\n\t\t\tDepth:               s.resolveNodeLimit,\n\t\t\tDatastoreQueryCount: 0,\n\t\t},\n\t})\n\tif err != nil {\n\t\tif errors.Is(err, graph.ErrResolutionDepthExceeded) || errors.Is(err, graph.ErrCycleDetected) {\n\t\t\treturn nil, serverErrors.AuthorizationModelResolutionTooComplex\n\t\t}\n\n\t\treturn nil, serverErrors.HandleError(\"\", err)\n\t}\n\n\tqueryCount := float64(resp.GetResolutionMetadata().DatastoreQueryCount)\n\tconst methodName = \"check\"\n\n\tgrpc_ctxtags.Extract(ctx).Set(datastoreQueryCountHistogramName, queryCount)\n\tspan.SetAttributes(attribute.Float64(datastoreQueryCountHistogramName, queryCount))\n\tdatastoreQueryCountHistogram.WithLabelValues(\n\t\topenfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tmethodName,\n\t).Observe(queryCount)\n\n\tres := &openfgav1.CheckResponse{\n\t\tAllowed: resp.Allowed,\n\t}\n\n\tspan.SetAttributes(attribute.KeyValue{Key: \"allowed\", Value: attribute.BoolValue(res.GetAllowed())})\n\trequestDurationByQueryHistogram.WithLabelValues(\n\t\topenfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tmethodName,\n\t\tutils.Bucketize(uint(resp.GetResolutionMetadata().DatastoreQueryCount), s.requestDurationByQueryHistogramBuckets),\n\t).Observe(float64(time.Since(start).Milliseconds()))\n\n\treturn res, nil\n}\n\nfunc (s *Server) Expand(ctx context.Context, req *openfgav1.ExpandRequest) (*openfgav1.ExpandResponse, error) {\n\ttk := req.GetTupleKey()\n\tctx, span := tracer.Start(ctx, \"Expand\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"object\", Value: attribute.StringValue(tk.GetObject())},\n\t\tattribute.KeyValue{Key: \"relation\", Value: attribute.StringValue(tk.GetRelation())},\n\t\tattribute.KeyValue{Key: \"user\", Value: attribute.StringValue(tk.GetUser())},\n\t))\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  \"Expand\",\n\t})\n\n\tstoreID := req.GetStoreId()\n\n\ttypesys, err := s.resolveTypesystem(ctx, storeID, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tq := commands.NewExpandQuery(s.datastore, s.logger)\n\treturn q.Execute(ctx, &openfgav1.ExpandRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: typesys.GetAuthorizationModelID(), // the resolved model id\n\t\tTupleKey:             tk,\n\t})\n}\n\nfunc (s *Server) ReadAuthorizationModel(ctx context.Context, req *openfgav1.ReadAuthorizationModelRequest) (*openfgav1.ReadAuthorizationModelResponse, error) {\n\tctx, span := tracer.Start(ctx, \"ReadAuthorizationModel\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: authorizationModelIDKey, Value: attribute.StringValue(req.GetId())},\n\t))\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  \"ReadAuthorizationModels\",\n\t})\n\n\tq := commands.NewReadAuthorizationModelQuery(s.datastore, s.logger)\n\treturn q.Execute(ctx, req)\n}\n\nfunc (s *Server) WriteAuthorizationModel(ctx context.Context, req *openfgav1.WriteAuthorizationModelRequest) (*openfgav1.WriteAuthorizationModelResponse, error) {\n\tctx, span := tracer.Start(ctx, \"WriteAuthorizationModel\")\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  \"WriteAuthorizationModel\",\n\t})\n\n\tc := commands.NewWriteAuthorizationModelCommand(s.datastore, s.logger)\n\tres, err := c.Execute(ctx, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.transport.SetHeader(ctx, httpmiddleware.XHttpCode, strconv.Itoa(http.StatusCreated))\n\n\treturn res, nil\n}\n\nfunc (s *Server) ReadAuthorizationModels(ctx context.Context, req *openfgav1.ReadAuthorizationModelsRequest) (*openfgav1.ReadAuthorizationModelsResponse, error) {\n\tctx, span := tracer.Start(ctx, \"ReadAuthorizationModels\")\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  \"ReadAuthorizationModels\",\n\t})\n\n\tc := commands.NewReadAuthorizationModelsQuery(s.datastore, s.logger, s.encoder)\n\treturn c.Execute(ctx, req)\n}\n\nfunc (s *Server) WriteAssertions(ctx context.Context, req *openfgav1.WriteAssertionsRequest) (*openfgav1.WriteAssertionsResponse, error) {\n\tctx, span := tracer.Start(ctx, \"WriteAssertions\")\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  \"WriteAssertions\",\n\t})\n\n\tstoreID := req.GetStoreId()\n\n\ttypesys, err := s.resolveTypesystem(ctx, storeID, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tc := commands.NewWriteAssertionsCommand(s.datastore, s.logger)\n\tres, err := c.Execute(ctx, &openfgav1.WriteAssertionsRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: typesys.GetAuthorizationModelID(), // the resolved model id\n\t\tAssertions:           req.GetAssertions(),\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.transport.SetHeader(ctx, httpmiddleware.XHttpCode, strconv.Itoa(http.StatusNoContent))\n\n\treturn res, nil\n}\n\nfunc (s *Server) ReadAssertions(ctx context.Context, req *openfgav1.ReadAssertionsRequest) (*openfgav1.ReadAssertionsResponse, error) {\n\tctx, span := tracer.Start(ctx, \"ReadAssertions\")\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  \"ReadAssertions\",\n\t})\n\n\ttypesys, err := s.resolveTypesystem(ctx, req.GetStoreId(), req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tq := commands.NewReadAssertionsQuery(s.datastore, s.logger)\n\treturn q.Execute(ctx, req.GetStoreId(), typesys.GetAuthorizationModelID())\n}\n\nfunc (s *Server) ReadChanges(ctx context.Context, req *openfgav1.ReadChangesRequest) (*openfgav1.ReadChangesResponse, error) {\n\tctx, span := tracer.Start(ctx, \"ReadChangesQuery\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"type\", Value: attribute.StringValue(req.GetType())},\n\t))\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  \"ReadChanges\",\n\t})\n\n\tq := commands.NewReadChangesQuery(s.datastore, s.logger, s.encoder, s.changelogHorizonOffset)\n\treturn q.Execute(ctx, req)\n}\n\nfunc (s *Server) CreateStore(ctx context.Context, req *openfgav1.CreateStoreRequest) (*openfgav1.CreateStoreResponse, error) {\n\tctx, span := tracer.Start(ctx, \"CreateStore\")\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  \"CreateStore\",\n\t})\n\n\tc := commands.NewCreateStoreCommand(s.datastore, s.logger)\n\tres, err := c.Execute(ctx, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.transport.SetHeader(ctx, httpmiddleware.XHttpCode, strconv.Itoa(http.StatusCreated))\n\n\treturn res, nil\n}\n\nfunc (s *Server) DeleteStore(ctx context.Context, req *openfgav1.DeleteStoreRequest) (*openfgav1.DeleteStoreResponse, error) {\n\tctx, span := tracer.Start(ctx, \"DeleteStore\")\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  \"DeleteStore\",\n\t})\n\n\tcmd := commands.NewDeleteStoreCommand(s.datastore, s.logger)\n\tres, err := cmd.Execute(ctx, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.transport.SetHeader(ctx, httpmiddleware.XHttpCode, strconv.Itoa(http.StatusNoContent))\n\n\treturn res, nil\n}\n\nfunc (s *Server) GetStore(ctx context.Context, req *openfgav1.GetStoreRequest) (*openfgav1.GetStoreResponse, error) {\n\tctx, span := tracer.Start(ctx, \"GetStore\")\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  \"GetStore\",\n\t})\n\n\tq := commands.NewGetStoreQuery(s.datastore, s.logger)\n\treturn q.Execute(ctx, req)\n}\n\nfunc (s *Server) ListStores(ctx context.Context, req *openfgav1.ListStoresRequest) (*openfgav1.ListStoresResponse, error) {\n\tctx, span := tracer.Start(ctx, \"ListStores\")\n\tdefer span.End()\n\n\tif !validator.RequestIsValidatedFromContext(ctx) {\n\t\tif err := req.Validate(); err != nil {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, err.Error())\n\t\t}\n\t}\n\n\tctx = telemetry.ContextWithRPCInfo(ctx, telemetry.RPCInfo{\n\t\tService: openfgav1.OpenFGAService_ServiceDesc.ServiceName,\n\t\tMethod:  \"ListStores\",\n\t})\n\n\tq := commands.NewListStoresQuery(s.datastore, s.logger, s.encoder)\n\treturn q.Execute(ctx, req)\n}\n\n// IsReady reports whether this OpenFGA server instance is ready to accept\n// traffic.\nfunc (s *Server) IsReady(ctx context.Context) (bool, error) {\n\n\t// for now we only depend on the datastore being ready, but in the future\n\t// server readiness may also depend on other criteria in addition to the\n\t// datastore being ready.\n\treturn s.datastore.IsReady(ctx)\n}\n\n// resolveTypesystem resolves the underlying TypeSystem given the storeID and modelID and\n// it sets some response metadata based on the model resolution.\nfunc (s *Server) resolveTypesystem(ctx context.Context, storeID, modelID string) (*typesystem.TypeSystem, error) {\n\tctx, span := tracer.Start(ctx, \"resolveTypesystem\")\n\tdefer span.End()\n\n\ttypesys, err := s.typesystemResolver(ctx, storeID, modelID)\n\tif err != nil {\n\t\tif errors.Is(err, typesystem.ErrModelNotFound) {\n\t\t\tif modelID == \"\" {\n\t\t\t\treturn nil, serverErrors.LatestAuthorizationModelNotFound(storeID)\n\t\t\t}\n\n\t\t\treturn nil, serverErrors.AuthorizationModelNotFound(modelID)\n\t\t}\n\n\t\tif errors.Is(err, typesystem.ErrInvalidModel) {\n\t\t\treturn nil, serverErrors.ValidationError(err)\n\t\t}\n\n\t\treturn nil, serverErrors.HandleError(\"\", err)\n\t}\n\n\tresolvedModelID := typesys.GetAuthorizationModelID()\n\n\tspan.SetAttributes(attribute.KeyValue{Key: authorizationModelIDKey, Value: attribute.StringValue(resolvedModelID)})\n\tgrpc_ctxtags.Extract(ctx).Set(authorizationModelIDKey, resolvedModelID)\n\t_ = grpc.SetHeader(ctx, metadata.Pairs(AuthorizationModelIDHeader, resolvedModelID))\n\n\treturn typesys, nil\n}\n", "package server\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"path\"\n\t\"runtime\"\n\t\"testing\"\n\t\"time\"\n\n\tparser \"github.com/craigpastro/openfga-dsl-parser/v2\"\n\t\"github.com/golang/mock/gomock\"\n\t\"github.com/oklog/ulid/v2\"\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\tmockstorage \"github.com/openfga/openfga/internal/mocks\"\n\tserverErrors \"github.com/openfga/openfga/pkg/server/errors\"\n\t\"github.com/openfga/openfga/pkg/server/test\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/storage/memory\"\n\t\"github.com/openfga/openfga/pkg/storage/mysql\"\n\t\"github.com/openfga/openfga/pkg/storage/postgres\"\n\t\"github.com/openfga/openfga/pkg/storage/sqlcommon\"\n\tstoragefixtures \"github.com/openfga/openfga/pkg/testfixtures/storage\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"github.com/stretchr/testify/require\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n)\n\nfunc init() {\n\t_, filename, _, _ := runtime.Caller(0)\n\tdir := path.Join(path.Dir(filename), \"..\", \"..\")\n\terr := os.Chdir(dir)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TestServerPanicIfNoDatastore(t *testing.T) {\n\trequire.PanicsWithError(t, \"failed to construct the OpenFGA server: a datastore option must be provided\", func() {\n\t\t_ = MustNewServerWithOpts()\n\t})\n}\n\nfunc TestServerPanicIfEmptyRequestDurationDatastoreCountBuckets(t *testing.T) {\n\trequire.PanicsWithError(t, \"failed to construct the OpenFGA server: request duration datastore count buckets must not be empty\", func() {\n\t\tmockController := gomock.NewController(t)\n\t\tdefer mockController.Finish()\n\t\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\t\t_ = MustNewServerWithOpts(\n\t\t\tWithDatastore(mockDatastore),\n\t\t\tWithRequestDurationByQueryHistogramBuckets([]uint{}),\n\t\t)\n\t})\n}\n\nfunc TestServerWithPostgresDatastore(t *testing.T) {\n\tds := MustBootstrapDatastore(t, \"postgres\")\n\tdefer ds.Close()\n\n\ttest.RunAllTests(t, ds)\n}\n\nfunc TestServerWithPostgresDatastoreAndExplicitCredentials(t *testing.T) {\n\ttestDatastore := storagefixtures.RunDatastoreTestContainer(t, \"postgres\")\n\n\turi := testDatastore.GetConnectionURI(false)\n\tds, err := postgres.New(\n\t\turi,\n\t\tsqlcommon.NewConfig(\n\t\t\tsqlcommon.WithUsername(testDatastore.GetUsername()),\n\t\t\tsqlcommon.WithPassword(testDatastore.GetPassword()),\n\t\t),\n\t)\n\trequire.NoError(t, err)\n\tdefer ds.Close()\n\n\ttest.RunAllTests(t, ds)\n}\n\nfunc TestServerWithMemoryDatastore(t *testing.T) {\n\tds := MustBootstrapDatastore(t, \"memory\")\n\tdefer ds.Close()\n\n\ttest.RunAllTests(t, ds)\n}\n\nfunc TestServerWithMySQLDatastore(t *testing.T) {\n\tds := MustBootstrapDatastore(t, \"mysql\")\n\tdefer ds.Close()\n\n\ttest.RunAllTests(t, ds)\n}\n\nfunc TestServerWithMySQLDatastoreAndExplicitCredentials(t *testing.T) {\n\ttestDatastore := storagefixtures.RunDatastoreTestContainer(t, \"mysql\")\n\n\turi := testDatastore.GetConnectionURI(false)\n\tds, err := mysql.New(\n\t\turi,\n\t\tsqlcommon.NewConfig(\n\t\t\tsqlcommon.WithUsername(testDatastore.GetUsername()),\n\t\t\tsqlcommon.WithPassword(testDatastore.GetPassword()),\n\t\t),\n\t)\n\trequire.NoError(t, err)\n\tdefer ds.Close()\n\n\ttest.RunAllTests(t, ds)\n}\n\nfunc BenchmarkOpenFGAServer(b *testing.B) {\n\n\tb.Run(\"BenchmarkPostgresDatastore\", func(b *testing.B) {\n\t\ttestDatastore := storagefixtures.RunDatastoreTestContainer(b, \"postgres\")\n\n\t\turi := testDatastore.GetConnectionURI(true)\n\t\tds, err := postgres.New(uri, sqlcommon.NewConfig())\n\t\trequire.NoError(b, err)\n\t\tdefer ds.Close()\n\t\ttest.RunAllBenchmarks(b, ds)\n\t})\n\n\tb.Run(\"BenchmarkMemoryDatastore\", func(b *testing.B) {\n\t\tds := memory.New()\n\t\tdefer ds.Close()\n\t\ttest.RunAllBenchmarks(b, ds)\n\t})\n\n\tb.Run(\"BenchmarkMySQLDatastore\", func(b *testing.B) {\n\t\ttestDatastore := storagefixtures.RunDatastoreTestContainer(b, \"mysql\")\n\n\t\turi := testDatastore.GetConnectionURI(true)\n\t\tds, err := mysql.New(uri, sqlcommon.NewConfig())\n\t\trequire.NoError(b, err)\n\t\tdefer ds.Close()\n\t\ttest.RunAllBenchmarks(b, ds)\n\t})\n}\n\nfunc TestCheckDoesNotThrowBecauseDirectTupleWasFound(t *testing.T) {\n\tctx := context.Background()\n\tstoreID := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\ttypedefs := parser.MustParse(`\n\ttype user\n\n\ttype repo\n\t  relations\n\t    define reader: [user] as self\n\t`)\n\n\ttk := tuple.NewTupleKey(\"repo:openfga\", \"reader\", \"user:anne\")\n\ttuple := &openfgav1.Tuple{Key: tk}\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().\n\t\tReadAuthorizationModel(gomock.Any(), storeID, modelID).\n\t\tAnyTimes().\n\t\tReturn(&openfgav1.AuthorizationModel{\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\tTypeDefinitions: typedefs,\n\t\t}, nil)\n\n\t// it could happen that one of the following two mocks won't be necessary because the goroutine will be short-circuited\n\tmockDatastore.EXPECT().\n\t\tReadUserTuple(gomock.Any(), storeID, gomock.Any()).\n\t\tAnyTimes().\n\t\tReturn(tuple, nil)\n\n\tmockDatastore.EXPECT().\n\t\tReadUsersetTuples(gomock.Any(), storeID, gomock.Any()).\n\t\tAnyTimes().\n\t\tDoAndReturn(\n\t\t\tfunc(_ context.Context, _ string, _ storage.ReadUsersetTuplesFilter) (storage.TupleIterator, error) {\n\t\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t\t\treturn nil, errors.New(\"some error\")\n\t\t\t})\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(mockDatastore),\n\t)\n\n\tcheckResponse, err := s.Check(ctx, &openfgav1.CheckRequest{\n\t\tStoreId:              storeID,\n\t\tTupleKey:             tk,\n\t\tAuthorizationModelId: modelID,\n\t})\n\trequire.NoError(t, err)\n\trequire.Equal(t, true, checkResponse.Allowed)\n}\n\nfunc TestOperationsWithInvalidModel(t *testing.T) {\n\tctx := context.Background()\n\tstoreID := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\t// The model is invalid\n\ttypedefs := parser.MustParse(`\n\ttype user\n\n\ttype repo\n\t  relations\n        define admin: [user] as self\n\t    define r1: [user] as self and r2 and r3\n\t    define r2: [user] as self and r1 and r3\n\t    define r3: [user] as self and r1 and r2\n\t`)\n\n\ttk := tuple.NewTupleKey(\"repo:openfga\", \"r1\", \"user:anne\")\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().\n\t\tReadAuthorizationModel(gomock.Any(), storeID, modelID).\n\t\tAnyTimes().\n\t\tReturn(&openfgav1.AuthorizationModel{\n\t\t\tId:              modelID,\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\tTypeDefinitions: typedefs,\n\t\t}, nil)\n\n\t// the model is error and err should return\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(mockDatastore),\n\t)\n\n\t_, err := s.Check(ctx, &openfgav1.CheckRequest{\n\t\tStoreId:              storeID,\n\t\tTupleKey:             tk,\n\t\tAuthorizationModelId: modelID,\n\t})\n\trequire.Error(t, err)\n\te, ok := status.FromError(err)\n\trequire.True(t, ok)\n\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\n\t_, err = s.ListObjects(ctx, &openfgav1.ListObjectsRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: modelID,\n\t\tType:                 \"repo\",\n\t\tRelation:             \"r1\",\n\t\tUser:                 \"user:anne\",\n\t})\n\trequire.Error(t, err)\n\te, ok = status.FromError(err)\n\trequire.True(t, ok)\n\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\n\terr = s.StreamedListObjects(&openfgav1.StreamedListObjectsRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: modelID,\n\t\tType:                 \"repo\",\n\t\tRelation:             \"r1\",\n\t\tUser:                 \"user:anne\",\n\t}, NewMockStreamServer())\n\trequire.Error(t, err)\n\te, ok = status.FromError(err)\n\trequire.True(t, ok)\n\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\n\t_, err = s.Expand(ctx, &openfgav1.ExpandRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: modelID,\n\t\tTupleKey:             tk,\n\t})\n\trequire.Error(t, err)\n\te, ok = status.FromError(err)\n\trequire.True(t, ok)\n\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\n}\n\nfunc TestShortestPathToSolutionWins(t *testing.T) {\n\tctx := context.Background()\n\n\tstoreID := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\ttypedefs := parser.MustParse(`\n\ttype user\n\n\ttype repo\n\t  relations\n\t    define reader: [user:*] as self\n\t`)\n\n\ttk := tuple.NewTupleKey(\"repo:openfga\", \"reader\", \"user:*\")\n\ttuple := &openfgav1.Tuple{Key: tk}\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().\n\t\tReadAuthorizationModel(gomock.Any(), storeID, modelID).\n\t\tAnyTimes().\n\t\tReturn(&openfgav1.AuthorizationModel{\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\tTypeDefinitions: typedefs,\n\t\t}, nil)\n\n\t// it could happen that one of the following two mocks won't be necessary because the goroutine will be short-circuited\n\tmockDatastore.EXPECT().\n\t\tReadUserTuple(gomock.Any(), storeID, gomock.Any()).\n\t\tAnyTimes().\n\t\tDoAndReturn(\n\t\t\tfunc(ctx context.Context, _ string, _ *openfgav1.TupleKey) (storage.TupleIterator, error) {\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\treturn nil, ctx.Err()\n\t\t\t\tcase <-time.After(500 * time.Millisecond):\n\t\t\t\t\treturn nil, storage.ErrNotFound\n\t\t\t\t}\n\t\t\t})\n\n\tmockDatastore.EXPECT().\n\t\tReadUsersetTuples(gomock.Any(), storeID, gomock.Any()).\n\t\tAnyTimes().\n\t\tDoAndReturn(\n\t\t\tfunc(_ context.Context, _ string, _ storage.ReadUsersetTuplesFilter) (storage.TupleIterator, error) {\n\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\treturn storage.NewStaticTupleIterator([]*openfgav1.Tuple{tuple}), nil\n\t\t\t})\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(mockDatastore),\n\t)\n\n\tstart := time.Now()\n\tcheckResponse, err := s.Check(ctx, &openfgav1.CheckRequest{\n\t\tStoreId:              storeID,\n\t\tTupleKey:             tk,\n\t\tAuthorizationModelId: modelID,\n\t})\n\tend := time.Since(start)\n\n\t// we expect the Check call to be short-circuited after ReadUsersetTuples runs\n\trequire.Truef(t, end < 200*time.Millisecond, fmt.Sprintf(\"end was %s\", end))\n\trequire.NoError(t, err)\n\trequire.Equal(t, true, checkResponse.Allowed)\n}\n\nfunc TestCheckWithCachedResolution(t *testing.T) {\n\tctx := context.Background()\n\n\tstoreID := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\ttypedefs := parser.MustParse(`\n\ttype user\n\n\ttype repo\n\t  relations\n\t    define reader: [user] as self\n\t`)\n\n\ttk := tuple.NewTupleKey(\"repo:openfga\", \"reader\", \"user:mike\")\n\ttuple := &openfgav1.Tuple{Key: tk}\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().\n\t\tReadAuthorizationModel(gomock.Any(), storeID, modelID).\n\t\tAnyTimes().\n\t\tReturn(&openfgav1.AuthorizationModel{\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\tTypeDefinitions: typedefs,\n\t\t}, nil)\n\n\tmockDatastore.EXPECT().\n\t\tReadUserTuple(gomock.Any(), storeID, gomock.Any()).\n\t\tTimes(1).\n\t\tReturn(tuple, nil)\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(mockDatastore),\n\t\tWithCheckQueryCacheEnabled(true),\n\t\tWithCheckQueryCacheLimit(10),\n\t\tWithCheckQueryCacheTTL(1*time.Minute),\n\t\tWithExperimentals(ExperimentalCheckQueryCache),\n\t)\n\n\tcheckResponse, err := s.Check(ctx, &openfgav1.CheckRequest{\n\t\tStoreId:              storeID,\n\t\tTupleKey:             tk,\n\t\tAuthorizationModelId: modelID,\n\t})\n\n\trequire.NoError(t, err)\n\trequire.True(t, checkResponse.Allowed)\n\n\t// If we check for the same request, data should come from cache and number of ReadUserTuple should still be 1\n\tcheckResponse, err = s.Check(ctx, &openfgav1.CheckRequest{\n\t\tStoreId:              storeID,\n\t\tTupleKey:             tk,\n\t\tAuthorizationModelId: modelID,\n\t})\n\n\trequire.NoError(t, err)\n\trequire.True(t, checkResponse.Allowed)\n}\n\nfunc TestResolveAuthorizationModel(t *testing.T) {\n\tctx := context.Background()\n\n\tt.Run(\"no_latest_authorization_model_id_found\", func(t *testing.T) {\n\n\t\tstore := ulid.Make().String()\n\n\t\tmockController := gomock.NewController(t)\n\t\tdefer mockController.Finish()\n\n\t\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\t\tmockDatastore.EXPECT().FindLatestAuthorizationModelID(gomock.Any(), store).Return(\"\", storage.ErrNotFound)\n\n\t\ts := MustNewServerWithOpts(\n\t\t\tWithDatastore(mockDatastore),\n\t\t)\n\n\t\texpectedError := serverErrors.LatestAuthorizationModelNotFound(store)\n\n\t\t_, err := s.resolveTypesystem(ctx, store, \"\")\n\t\trequire.ErrorIs(t, err, expectedError)\n\t})\n\n\tt.Run(\"read_existing_authorization_model\", func(t *testing.T) {\n\t\tstore := ulid.Make().String()\n\t\tmodelID := ulid.Make().String()\n\n\t\tmockController := gomock.NewController(t)\n\t\tdefer mockController.Finish()\n\n\t\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\t\tmockDatastore.EXPECT().FindLatestAuthorizationModelID(gomock.Any(), store).Return(modelID, nil)\n\t\tmockDatastore.EXPECT().ReadAuthorizationModel(gomock.Any(), store, modelID).Return(\n\t\t\t&openfgav1.AuthorizationModel{\n\t\t\t\tId:            modelID,\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t},\n\t\t\tnil,\n\t\t)\n\n\t\ts := MustNewServerWithOpts(\n\t\t\tWithDatastore(mockDatastore),\n\t\t)\n\n\t\ttypesys, err := s.resolveTypesystem(ctx, store, \"\")\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, modelID, typesys.GetAuthorizationModelID())\n\t})\n\n\tt.Run(\"non-valid_modelID_returns_error\", func(t *testing.T) {\n\t\tstore := ulid.Make().String()\n\t\tmodelID := \"foo\"\n\t\twant := serverErrors.AuthorizationModelNotFound(modelID)\n\n\t\tmockController := gomock.NewController(t)\n\t\tdefer mockController.Finish()\n\n\t\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\t\ts := MustNewServerWithOpts(\n\t\t\tWithDatastore(mockDatastore),\n\t\t)\n\n\t\t_, err := s.resolveTypesystem(ctx, store, modelID)\n\t\trequire.Equal(t, want, err)\n\t})\n}\n\ntype mockStreamServer struct {\n\tgrpc.ServerStream\n}\n\nfunc NewMockStreamServer() *mockStreamServer {\n\treturn &mockStreamServer{}\n}\n\nfunc (m *mockStreamServer) Context() context.Context {\n\treturn context.Background()\n}\n\nfunc (m *mockStreamServer) Send(*openfgav1.StreamedListObjectsResponse) error {\n\treturn nil\n}\n\n// This runs ListObjects and StreamedListObjects many times over to ensure no race conditions (see https://github.com/openfga/openfga/pull/762)\nfunc BenchmarkListObjectsNoRaceCondition(b *testing.B) {\n\tctx := context.Background()\n\tstore := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\tmockController := gomock.NewController(b)\n\tdefer mockController.Finish()\n\n\ttypedefs := parser.MustParse(`\n\ttype user\n\n\ttype repo\n\t  relations\n\t    define allowed: [user] as self\n\t    define viewer: [user] as self and allowed\n    `)\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().ReadAuthorizationModel(gomock.Any(), store, modelID).AnyTimes().Return(&openfgav1.AuthorizationModel{\n\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\tTypeDefinitions: typedefs,\n\t}, nil)\n\tmockDatastore.EXPECT().ReadStartingWithUser(gomock.Any(), store, gomock.Any()).AnyTimes().Return(nil, errors.New(\"error reading from storage\"))\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(mockDatastore),\n\t)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, err := s.ListObjects(ctx, &openfgav1.ListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"repo\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:bob\",\n\t\t})\n\n\t\trequire.ErrorIs(b, err, serverErrors.NewInternalError(\"\", errors.New(\"error reading from storage\")))\n\n\t\terr = s.StreamedListObjects(&openfgav1.StreamedListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"repo\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:bob\",\n\t\t}, NewMockStreamServer())\n\n\t\trequire.ErrorIs(b, err, serverErrors.NewInternalError(\"\", errors.New(\"error reading from storage\")))\n\t}\n}\n\nfunc TestListObjects_ErrorCases(t *testing.T) {\n\tctx := context.Background()\n\tstore := ulid.Make().String()\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tt.Run(\"database_errors\", func(t *testing.T) {\n\t\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\t\ts := MustNewServerWithOpts(\n\t\t\tWithDatastore(mockDatastore),\n\t\t)\n\n\t\tmodelID := ulid.Make().String()\n\n\t\tmockDatastore.EXPECT().ReadAuthorizationModel(gomock.Any(), store, modelID).AnyTimes().Return(&openfgav1.AuthorizationModel{\n\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\ttype user\n\t\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t\tdefine viewer: [user, user:*] as self\n\t\t\t`),\n\t\t}, nil)\n\n\t\tmockDatastore.EXPECT().ReadStartingWithUser(gomock.Any(), store, storage.ReadStartingWithUserFilter{\n\t\t\tObjectType: \"document\",\n\t\t\tRelation:   \"viewer\",\n\t\t\tUserFilter: []*openfgav1.ObjectRelation{\n\t\t\t\t{Object: \"user:*\"},\n\t\t\t\t{Object: \"user:bob\"},\n\t\t\t}}).AnyTimes().Return(nil, errors.New(\"error reading from storage\"))\n\n\t\tt.Run(\"error_listing_objects_from_storage_in_non-streaming_version\", func(t *testing.T) {\n\t\t\tres, err := s.ListObjects(ctx, &openfgav1.ListObjectsRequest{\n\t\t\t\tStoreId:              store,\n\t\t\t\tAuthorizationModelId: modelID,\n\t\t\t\tType:                 \"document\",\n\t\t\t\tRelation:             \"viewer\",\n\t\t\t\tUser:                 \"user:bob\",\n\t\t\t})\n\n\t\t\trequire.Nil(t, res)\n\t\t\trequire.ErrorIs(t, err, serverErrors.NewInternalError(\"\", errors.New(\"error reading from storage\")))\n\t\t})\n\n\t\tt.Run(\"error_listing_objects_from_storage_in_streaming_version\", func(t *testing.T) {\n\t\t\terr := s.StreamedListObjects(&openfgav1.StreamedListObjectsRequest{\n\t\t\t\tStoreId:              store,\n\t\t\t\tAuthorizationModelId: modelID,\n\t\t\t\tType:                 \"document\",\n\t\t\t\tRelation:             \"viewer\",\n\t\t\t\tUser:                 \"user:bob\",\n\t\t\t}, NewMockStreamServer())\n\n\t\t\trequire.ErrorIs(t, err, serverErrors.NewInternalError(\"\", errors.New(\"error reading from storage\")))\n\t\t})\n\t})\n\n\tt.Run(\"graph_resolution_errors\", func(t *testing.T) {\n\n\t\ts := MustNewServerWithOpts(\n\t\t\tWithDatastore(memory.New()),\n\t\t\tWithResolveNodeLimit(2),\n\t\t)\n\n\t\twriteModelResp, err := s.WriteAuthorizationModel(ctx, &openfgav1.WriteAuthorizationModelRequest{\n\t\t\tStoreId:       store,\n\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user, group#member] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t\tdefine viewer: [group#member] as self\n\t\t\t`),\n\t\t})\n\t\trequire.NoError(t, err)\n\n\t\t_, err = s.Write(ctx, &openfgav1.WriteRequest{\n\t\t\tStoreId: store,\n\t\t\tWrites: &openfgav1.TupleKeys{\n\t\t\t\tTupleKeys: []*openfgav1.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:1#member\"),\n\t\t\t\t\ttuple.NewTupleKey(\"group:1\", \"member\", \"group:2#member\"),\n\t\t\t\t\ttuple.NewTupleKey(\"group:2\", \"member\", \"group:3#member\"),\n\t\t\t\t\ttuple.NewTupleKey(\"group:3\", \"member\", \"user:jon\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\trequire.NoError(t, err)\n\n\t\tt.Run(\"resolution_depth_exceeded_error_unary\", func(t *testing.T) {\n\t\t\tres, err := s.ListObjects(ctx, &openfgav1.ListObjectsRequest{\n\t\t\t\tStoreId:              store,\n\t\t\t\tAuthorizationModelId: writeModelResp.GetAuthorizationModelId(),\n\t\t\t\tType:                 \"document\",\n\t\t\t\tRelation:             \"viewer\",\n\t\t\t\tUser:                 \"user:jon\",\n\t\t\t})\n\n\t\t\trequire.Nil(t, res)\n\t\t\trequire.ErrorIs(t, err, serverErrors.AuthorizationModelResolutionTooComplex)\n\t\t})\n\n\t\tt.Run(\"resolution_depth_exceeded_error_streaming\", func(t *testing.T) {\n\t\t\terr := s.StreamedListObjects(&openfgav1.StreamedListObjectsRequest{\n\t\t\t\tStoreId:              store,\n\t\t\t\tAuthorizationModelId: writeModelResp.GetAuthorizationModelId(),\n\t\t\t\tType:                 \"document\",\n\t\t\t\tRelation:             \"viewer\",\n\t\t\t\tUser:                 \"user:jon\",\n\t\t\t}, NewMockStreamServer())\n\n\t\t\trequire.ErrorIs(t, err, serverErrors.AuthorizationModelResolutionTooComplex)\n\t\t})\n\t})\n}\n\nfunc TestAuthorizationModelInvalidSchemaVersion(t *testing.T) {\n\tctx := context.Background()\n\tstore := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().ReadAuthorizationModel(gomock.Any(), store, modelID).AnyTimes().Return(&openfgav1.AuthorizationModel{\n\t\tSchemaVersion: typesystem.SchemaVersion1_0,\n\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t{\n\t\t\t\tType: \"user\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tType: \"team\",\n\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\"member\": typesystem.This(),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil)\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(mockDatastore),\n\t)\n\n\tt.Run(\"invalid_schema_error_in_check\", func(t *testing.T) {\n\t\t_, err := s.Check(ctx, &openfgav1.CheckRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tTupleKey: tuple.NewTupleKey(\n\t\t\t\t\"team:abc\",\n\t\t\t\t\"member\",\n\t\t\t\t\"user:anne\"),\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\t})\n\n\tt.Run(\"invalid_schema_error_in_list_objects\", func(t *testing.T) {\n\t\t_, err := s.ListObjects(ctx, &openfgav1.ListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"team\",\n\t\t\tRelation:             \"member\",\n\t\t\tUser:                 \"user:anne\",\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\t})\n\n\tt.Run(\"invalid_schema_error_in_streamed_list_objects\", func(t *testing.T) {\n\t\terr := s.StreamedListObjects(&openfgav1.StreamedListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"team\",\n\t\t\tRelation:             \"member\",\n\t\t\tUser:                 \"user:anne\",\n\t\t}, NewMockStreamServer())\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\t})\n\n\tt.Run(\"invalid_schema_error_in_expand\", func(t *testing.T) {\n\t\t_, err := s.Expand(ctx, &openfgav1.ExpandRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tTupleKey: tuple.NewTupleKey(\"repo:openfga\",\n\t\t\t\t\"reader\",\n\t\t\t\t\"user:anne\"),\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\t})\n\n\tt.Run(\"invalid_schema_error_in_write\", func(t *testing.T) {\n\t\t_, err := s.Write(ctx, &openfgav1.WriteRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tWrites: &openfgav1.TupleKeys{TupleKeys: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:openfga/openfga\",\n\t\t\t\t\t\"reader\",\n\t\t\t\t\t\"user:anne\"),\n\t\t\t}},\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\t})\n\n\tt.Run(\"invalid_schema_error_in_write_model\", func(t *testing.T) {\n\t\tmockDatastore.EXPECT().MaxTypesPerAuthorizationModel().Return(100)\n\n\t\t_, err := s.WriteAuthorizationModel(ctx, &openfgav1.WriteAuthorizationModelRequest{\n\t\t\tStoreId:         store,\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_0,\n\t\t\tTypeDefinitions: parser.MustParse(`type repo`),\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_invalid_authorization_model), e.Code(), err)\n\t})\n\n\tt.Run(\"invalid_schema_error_in_write_assertion\", func(t *testing.T) {\n\t\t_, err := s.WriteAssertions(ctx, &openfgav1.WriteAssertionsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tAssertions: []*openfgav1.Assertion{{\n\t\t\t\tTupleKey:    tuple.NewTupleKey(\"repo:test\", \"reader\", \"user:elbuo\"),\n\t\t\t\tExpectation: false,\n\t\t\t}},\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\t})\n}\n\nfunc TestDefaultMaxConcurrentReadSettings(t *testing.T) {\n\trequire.EqualValues(t, math.MaxUint32, defaultMaxConcurrentReadsForCheck)\n\trequire.EqualValues(t, math.MaxUint32, defaultMaxConcurrentReadsForListObjects)\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(memory.New()),\n\t)\n\trequire.EqualValues(t, math.MaxUint32, s.maxConcurrentReadsForCheck)\n\trequire.EqualValues(t, math.MaxUint32, s.maxConcurrentReadsForListObjects)\n}\n\nfunc MustBootstrapDatastore(t testing.TB, engine string) storage.OpenFGADatastore {\n\ttestDatastore := storagefixtures.RunDatastoreTestContainer(t, engine)\n\n\turi := testDatastore.GetConnectionURI(true)\n\n\tvar ds storage.OpenFGADatastore\n\tvar err error\n\n\tswitch engine {\n\tcase \"memory\":\n\t\tds = memory.New()\n\tcase \"postgres\":\n\t\tds, err = postgres.New(uri, sqlcommon.NewConfig())\n\tcase \"mysql\":\n\t\tds, err = mysql.New(uri, sqlcommon.NewConfig())\n\tdefault:\n\t\tt.Fatalf(\"'%s' is not a supported datastore engine\", engine)\n\t}\n\trequire.NoError(t, err)\n\n\treturn ds\n}\n", "package test\n\nimport (\n\t\"context\"\n\t\"testing\"\n\t\"time\"\n\n\tparser \"github.com/craigpastro/openfga-dsl-parser/v2\"\n\t\"github.com/oklog/ulid/v2\"\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\t\"github.com/openfga/openfga/internal/graph\"\n\t\"github.com/openfga/openfga/pkg/server/commands/reverseexpand\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestReverseExpand(t *testing.T, ds storage.OpenFGADatastore) {\n\n\ttests := []struct {\n\t\tname                 string\n\t\tmodel                string\n\t\ttuples               []*openfgav1.TupleKey\n\t\trequest              *reverseexpand.ReverseExpandRequest\n\t\tresolveNodeLimit     uint32\n\t\texpectedResult       []*reverseexpand.ReverseExpandResult\n\t\texpectedError        error\n\t\texpectedDSQueryCount uint32\n\t}{\n\t\t{\n\t\t\tname: \"basic_intersection\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgav1.TupleKey{},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define allowed: [user] as self\n\t\t\t\t    define viewer: [user] as self and allowed\n\t\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"document:3\", \"allowed\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.RequiresFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:2\",\n\t\t\t\t\tResultStatus: reverseexpand.RequiresFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"indirect_intersection\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgav1.TupleKey{},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t\tdefine writer: [user] as self\n\t\t\t\tdefine editor: [user] as self\n\t\t\t\tdefine viewer as writer and editor\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t\tdefine parent: [folder] as self\n\t\t\t\tdefine viewer as viewer from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"folder:X\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:X\", \"writer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:X\", \"editor\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.RequiresFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\n\t\t{\n\t\t\tname: \"resolve_direct_relationships_with_tuples_and_contextual_tuples\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgav1.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"document:doc2\", \"viewer\", \"user:bob\"),\n\t\t\t\t\ttuple.NewTupleKey(\"document:doc3\", \"viewer\", \"user:jon\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"viewer\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc3\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"direct_relations_involving_relationships_with_users_and_usersets\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user, group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc2\", \"viewer\", \"user:bob\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc3\", \"viewer\", \"group:openfga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:openfga\", \"member\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc3\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"success_with_direct_relationships_and_computed_usersets\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define owner: [user, group#member] as self\n\t\t\t    define viewer as owner\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"owner\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc2\", \"owner\", \"user:bob\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc3\", \"owner\", \"group:openfga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:openfga\", \"member\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc3\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"success_with_many_tuples\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgav1.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"folder:folder5\", \"parent\", \"folder:folder4\"),\n\t\t\t\t\ttuple.NewTupleKey(\"folder:folder6\", \"viewer\", \"user:bob\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user, group#member] as self\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer: [user, group#member] as self or viewer from parent\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer as viewer from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"folder:folder1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder2\", \"parent\", \"folder:folder1\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder3\", \"parent\", \"folder:folder2\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder4\", \"viewer\", \"group:eng#member\"),\n\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"parent\", \"folder:folder3\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc2\", \"parent\", \"folder:folder5\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc3\", \"parent\", \"folder:folder6\"),\n\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"group:openfga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:openfga\", \"member\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 16,\n\t\t},\n\t\t{\n\t\t\tname: \"resolve_objects_involved_in_recursive_hierarchy\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"folder\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer: [user] as self or viewer from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"folder:folder1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder2\", \"parent\", \"folder:folder1\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder3\", \"parent\", \"folder:folder2\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"folder:folder1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"folder:folder2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"folder:folder3\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"resolution_depth_exceeded_failure\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"folder\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tresolveNodeLimit: 2,\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer: [user] as self or viewer from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"folder:folder1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder2\", \"parent\", \"folder:folder1\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder3\", \"parent\", \"folder:folder2\"),\n\t\t\t},\n\t\t\texpectedError:        graph.ErrResolutionDepthExceeded,\n\t\t\texpectedDSQueryCount: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_to_a_userset\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"group\",\n\t\t\t\tRelation:   \"member\",\n\t\t\t\tUser: &reverseexpand.UserRefObjectRelation{\n\t\t\t\t\tObjectRelation: &openfgav1.ObjectRelation{\n\t\t\t\t\t\tObject:   \"group:iam\",\n\t\t\t\t\t\tRelation: \"member\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user, group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"group:opensource\", \"member\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"group:iam#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:iam\", \"member\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"group:opensource\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"group:eng\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_to_a_userset_self_referencing\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"group\",\n\t\t\t\tRelation:   \"member\",\n\t\t\t\tUser: &reverseexpand.UserRefObjectRelation{\n\t\t\t\t\tObjectRelation: &openfgav1.ObjectRelation{\n\t\t\t\t\t\tObject:   \"group:iam\",\n\t\t\t\t\t\tRelation: \"member\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"group:iam\", \"member\", \"group:iam#member\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"group:iam\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_through_a_computed_userset_1\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define owner: [user] as self\n\t\t\t    define editor as owner\n\t\t\t    define viewer: [document#editor] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"document:1#editor\"),\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"owner\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_through_a_computed_userset_2\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define manager: [user] as self\n\t\t\t    define member as manager\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"manager\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_through_a_computed_userset_3\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"trial\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"fede\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype team\n\t\t\t  relations\n\t\t\t    define admin: [user] as self\n\t\t\t    define member as admin\n\n\t\t\ttype trial\n\t\t\t  relations\n\t\t\t    define editor: [team#member] as self\n\t\t\t    define viewer as editor\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"trial:1\", \"editor\", \"team:devs#member\"),\n\t\t\t\ttuple.NewTupleKey(\"team:devs\", \"admin\", \"user:fede\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"trial:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_indirectly_through_a_ttu\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"view\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"organization\",\n\t\t\t\t\t\tId:   \"2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype organization\n\t\t\t  relations\n\t\t\t    define viewer: [organization] as self\n\t\t\t    define can_view as viewer\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [organization] as self\n\t\t\t    define view as can_view from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"organization:1\"),\n\t\t\t\ttuple.NewTupleKey(\"organization:1\", \"viewer\", \"organization:2\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"directly_related_typed_wildcard\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser:       &reverseexpand.UserRefTypedWildcard{Type: \"user\"},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user, user:*] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"document:3\", \"viewer\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"indirectly_related_typed_wildcard\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser:       &reverseexpand.UserRefTypedWildcard{Type: \"user\"},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user:*] as self\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"group:fga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"user:*\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"relationship_through_multiple_indirections\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype team\n\t\t\t  relations\n\t\t\t    define member: [user] as self\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [team#member] as self\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"team:tigers\", \"member\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"team:tigers#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"typed_wildcard_relationship_through_multiple_indirections\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [team#member] as self\n\t\t\ttype team\n\t\t\t  relations\n\t\t\t    define member: [user:*] as self\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"team:tigers\", \"member\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"team:tigers#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"simple_typed_wildcard_and_direct_relation\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{Type: \"user\", Id: \"jon\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user, user:*] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"simple_typed_wildcard_and_indirect_relation\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user, user:*] as self\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"group:fga\", \"member\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"group:fga#member\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"with_public_user_access_1\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"*\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user:*] as self\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"group:other\", \"member\", \"employee:*\"), // assume this comes from a prior model\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"group:fga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:3\", \"viewer\", \"group:other#member\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"with_public_user_access_2\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"resource\",\n\t\t\t\tRelation:   \"reader\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"bev\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user] as self\n\t\t\ttype resource\n\t\t\t  relations\n\t\t\t    define reader: [user, user:*, group#member] as self or writer\n\t\t\t\tdefine writer: [user, user:*, group#member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"resource:x\", \"writer\", \"user:*\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"resource:x\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"simple_typed_wildcard_with_contextual_tuples_1\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{Type: \"user\", Id: \"jon\"},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgav1.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"user:*\"),\n\t\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"user:jon\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user, user:*] as self\n\t\t\t`,\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"simple_typed_wildcard_with_contextual_tuples_2\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser:       &reverseexpand.UserRefTypedWildcard{Type: \"user\"},\n\t\t\t\tContextualTuples: []*openfgav1.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"employee:*\"),\n\t\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"user:*\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype employee\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user:*] as self\n\t\t\t`,\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"simple_typed_wildcard_with_contextual_tuples_3\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObjectRelation{\n\t\t\t\t\tObjectRelation: &openfgav1.ObjectRelation{\n\t\t\t\t\t\tObject:   \"group:eng\",\n\t\t\t\t\t\tRelation: \"member\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgav1.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_ttu_relationship\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define viewer: [user, user:*] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer as viewer from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"folder:1\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"parent\", \"folder:2\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:2\", \"viewer\", \"user:*\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_ttu_relationship_without_wildcard_connectivity\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype employee\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define viewer: [user, employee:*] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer as viewer from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"folder:1\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"parent\", \"folder:2\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:2\", \"viewer\", \"user:*\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_ttu_relationship_through_indirection_1\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user:*] as self\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer as viewer from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"folder:1\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"user:*\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_ttu_relationship_through_indirection_2\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"resource\",\n\t\t\t\tRelation:   \"writer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"anne\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype org\n\t\t\t  relations\n\t\t\t    define dept: [group] as self\n\t\t\t    define dept_member as member from dept\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user] as self\n\n\t\t\ttype resource\n\t\t\t  relations\n\t\t\t    define writer: [org#dept_member] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"resource:eng_handbook\", \"writer\", \"org:eng#dept_member\"),\n\t\t\t\ttuple.NewTupleKey(\"org:eng\", \"dept\", \"group:fga\"),\n\t\t\t\ttuple.NewTupleKey(\"group:fga\", \"member\", \"user:anne\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"resource:eng_handbook\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_ttu_relationship_through_indirection_3\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"resource\",\n\t\t\t\tRelation:   \"reader\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"anne\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype org\n\t\t\t  relations\n\t\t\t    define dept: [group] as self\n\t\t\t    define dept_member as member from dept\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user] as self\n\n\t\t\ttype resource\n\t\t\t  relations\n\t\t\t    define writer: [org#dept_member] as self\n\t\t\t    define reader: [org#dept_member] as self or writer\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"resource:eng_handbook\", \"writer\", \"org:eng#dept_member\"),\n\t\t\t\ttuple.NewTupleKey(\"org:eng\", \"dept\", \"group:fga\"),\n\t\t\t\ttuple.NewTupleKey(\"group:fga\", \"member\", \"user:anne\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"resource:eng_handbook\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"cyclical_tupleset_relation_terminates\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"node\",\n\t\t\t\tRelation:   \"editor\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"wonder\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype node\n\t\t\t  relations\n\t\t\t    define parent: [node] as self\n\t\t\t    define editor: [user] as self or editor from parent\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"node:abc\", \"editor\", \"user:wonder\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"node:abc\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"does_not_send_duplicate_even_though_there_are_two_paths_to_same_solution\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t\tdefine member: [user] as self\n\t\t\t\tdefine maintainer: [user] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t\tdefine viewer: [group#member,group#maintainer] as self\n\t\t\t`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:example1#maintainer\"),\n\t\t\t\ttuple.NewTupleKey(\"group:example1\", \"maintainer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"group:example1\", \"member\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 4,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\trequire := require.New(t)\n\n\t\t\tctx := context.Background()\n\t\t\tstore := ulid.Make().String()\n\t\t\ttest.request.StoreID = store\n\n\t\t\tmodel := &openfgav1.AuthorizationModel{\n\t\t\t\tId:              ulid.Make().String(),\n\t\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: parser.MustParse(test.model),\n\t\t\t}\n\t\t\terr := ds.WriteAuthorizationModel(ctx, store, model)\n\t\t\trequire.NoError(err)\n\n\t\t\terr = ds.Write(ctx, store, nil, test.tuples)\n\t\t\trequire.NoError(err)\n\n\t\t\tvar opts []reverseexpand.ReverseExpandQueryOption\n\n\t\t\tif test.resolveNodeLimit != 0 {\n\t\t\t\topts = append(opts, reverseexpand.WithResolveNodeLimit(test.resolveNodeLimit))\n\t\t\t}\n\n\t\t\treverseExpandQuery := reverseexpand.NewReverseExpandQuery(ds, typesystem.New(model), opts...)\n\n\t\t\tresultChan := make(chan *reverseexpand.ReverseExpandResult, 100)\n\t\t\tdone := make(chan struct{})\n\n\t\t\tvar results []*reverseexpand.ReverseExpandResult\n\t\t\tgo func() {\n\t\t\t\tfor result := range resultChan {\n\t\t\t\t\tresults = append(results, result)\n\t\t\t\t}\n\n\t\t\t\tdone <- struct{}{}\n\t\t\t}()\n\n\t\t\ttimeoutCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\t\t\tdefer cancel()\n\n\t\t\tresolutionMetadata := reverseexpand.NewResolutionMetadata()\n\n\t\t\tgo func() {\n\t\t\t\terr = reverseExpandQuery.Execute(timeoutCtx, test.request, resultChan, resolutionMetadata)\n\t\t\t\trequire.ErrorIs(err, test.expectedError)\n\t\t\t\tclose(resultChan)\n\t\t\t}()\n\n\t\t\tselect {\n\t\t\tcase <-timeoutCtx.Done():\n\t\t\t\trequire.FailNow(\"timed out waiting for response\")\n\t\t\tcase <-done:\n\t\t\t}\n\n\t\t\tif test.expectedError == nil {\n\t\t\t\trequire.ElementsMatch(test.expectedResult, results)\n\t\t\t\trequire.Equal(test.expectedDSQueryCount, *resolutionMetadata.QueryCount)\n\t\t\t}\n\t\t})\n\t}\n}\n", "package test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"testing\"\n\n\tparser \"github.com/craigpastro/openfga-dsl-parser/v2\"\n\t\"github.com/oklog/ulid/v2\"\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\t\"github.com/openfga/openfga/pkg/server/commands\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"github.com/stretchr/testify/require\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n)\n\nfunc WriteAuthorizationModelTest(t *testing.T, datastore storage.OpenFGADatastore) {\n\tstoreID := ulid.Make().String()\n\n\titems := make([]*openfgav1.TypeDefinition, datastore.MaxTypesPerAuthorizationModel()+1)\n\titems[0] = &openfgav1.TypeDefinition{\n\t\tType: \"user\",\n\t}\n\tfor i := 1; i < datastore.MaxTypesPerAuthorizationModel(); i++ {\n\t\titems[i] = &openfgav1.TypeDefinition{\n\t\t\tType: fmt.Sprintf(\"type%v\", i),\n\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\"admin\": {Userset: &openfgav1.Userset_This{}},\n\t\t\t},\n\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\ttypesystem.DirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t}\n\n\tvar tests = []struct {\n\t\tname          string\n\t\trequest       *openfgav1.WriteAuthorizationModelRequest\n\t\tallowSchema10 bool\n\t\terrCode       codes.Code\n\t}{\n\t\t{\n\t\t\tname: \"fails_if_too_many_types\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId:         storeID,\n\t\t\t\tTypeDefinitions: items,\n\t\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\t},\n\t\t\tallowSchema10: false,\n\t\t\terrCode:       codes.Code(openfgav1.ErrorCode_exceeded_entity_limit),\n\t\t},\n\t\t{\n\t\t\tname: \"fails_if_a_relation_is_not_defined\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"owner\": {},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t},\n\t\t\tallowSchema10: false,\n\t\t\terrCode:       codes.Code(openfgav1.ErrorCode_invalid_authorization_model),\n\t\t},\n\t\t{\n\t\t\tname: \"Fails_if_type_info_metadata_is_omitted_in_1.1_model\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId:       storeID,\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tallowSchema10: false,\n\t\t\terrCode:       codes.Code(openfgav1.ErrorCode_invalid_authorization_model),\n\t\t},\n\t\t{\n\t\t\tname: \"Fails_if_writing_1_0_model_because_it_will_be_interpreted_as_1_1\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tallowSchema10: true,\n\t\t\terrCode:       codes.Code(openfgav1.ErrorCode_invalid_authorization_model),\n\t\t},\n\t\t{\n\t\t\tname: \"Works_if_no_schema_version\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"viewer\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\ttypesystem.WildcardRelationReference(\"user\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"self_referencing_type_restriction_with_entrypoint\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define editor: [user] as self\n\t\t\t\t    define viewer: [document#viewer] as self or editor\n\t\t\t\t`),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"self_referencing_type_restriction_without_entrypoint_1\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define viewer: [document#viewer] as self\n\t\t\t\t`),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t},\n\t\t\terrCode: codes.Code(openfgav1.ErrorCode_invalid_authorization_model),\n\t\t},\n\t\t{\n\t\t\tname: \"self_referencing_type_restriction_without_entrypoint_2\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define editor: [user] as self\n\t\t\t\t    define viewer: [document#viewer] as self and editor\n\t\t\t\t`),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t},\n\t\t\terrCode: codes.Code(openfgav1.ErrorCode_invalid_authorization_model),\n\t\t},\n\t\t{\n\t\t\tname: \"self_referencing_type_restriction_without_entrypoint_3\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define restricted: [user] as self\n\t\t\t\t    define viewer: [document#viewer] as self but not restricted\n\t\t\t\t`),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t},\n\t\t\terrCode: codes.Code(openfgav1.ErrorCode_invalid_authorization_model),\n\t\t},\n\t\t{\n\t\t\tname: \"rewritten_relation_in_intersection_unresolvable\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define admin: [user] as self\n\t\t\t\t    define action1 as admin and action2 and action3\n\t\t\t\t    define action2 as admin and action1 and action3\n\t\t\t\t    define action3 as admin and action1 and action2\n\t\t\t\t`),\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t},\n\t\t\terrCode: codes.Code(openfgav1.ErrorCode_invalid_authorization_model),\n\t\t},\n\t\t{\n\t\t\tname: \"direct_relationship_with_entrypoint\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define viewer: [user] as self\n\t\t\t\t`),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"computed_relationship_with_entrypoint\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define editor: [user] as self\n\t\t\t\t    define viewer as editor\n\t\t\t\t`),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"rewritten_relation_in_exclusion_unresolvable\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define admin: [user] as self\n\t\t\t\t    define action1 as admin but not action2\n\t\t\t\t    define action2 as admin but not action3\n\t\t\t\t    define action3 as admin but not action1\n\t\t\t\t`),\n\t\t\t},\n\t\t\terrCode: codes.Code(openfgav1.ErrorCode_invalid_authorization_model),\n\t\t},\n\t\t{\n\t\t\tname: \"no_entrypoint_3a\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define viewer: [document#viewer] as self and editor\n\t\t\t\t    define editor: [user] as self\n\t\t\t\t`),\n\t\t\t},\n\t\t\terrCode: codes.Code(openfgav1.ErrorCode_invalid_authorization_model),\n\t\t},\n\t\t{\n\t\t\tname: \"no_entrypoint_3b\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define viewer: [document#viewer] as self but not editor\n\t\t\t\t    define editor: [user] as self\n\t\t\t\t`),\n\t\t\t},\n\t\t\terrCode: codes.Code(openfgav1.ErrorCode_invalid_authorization_model),\n\t\t},\n\t\t{\n\t\t\tname: \"no_entrypoint_4\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype folder\n\t\t\t\t  relations\n\t\t\t\t    define parent: [document] as self\n\t\t\t\t    define viewer as editor from parent\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define parent: [folder] as self\n\t\t\t\t    define editor as viewer\n\t\t\t\t    define viewer as editor from parent\n\t\t\t\t`),\n\t\t\t},\n\t\t\terrCode: codes.Code(openfgav1.ErrorCode_invalid_authorization_model),\n\t\t},\n\t\t{\n\t\t\tname: \"self_referencing_type_restriction_with_entrypoint_1\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define restricted: [user] as self\n\t\t\t\t    define editor: [user] as self\n\t\t\t\t    define viewer: [document#viewer] as self or editor\n\t\t\t\t    define can_view as viewer but not restricted\n\t\t\t\t    define can_view_actual as can_view\n\t\t\t\t`),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"self_referencing_type_restriction_with_entrypoint_2\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define editor: [user] as self\n\t\t\t\t    define viewer: [document#viewer] as self or editor\n\t\t\t\t`),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"relation_with_union_of_ttu_rewrites\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\t\t\t\ttype org\n\t\t\t\t  relations\n\t\t\t\t    define admin: [user] as self\n\t\t\t\t    define member: [user] as self\n\t\t\t\ttype group\n\t\t\t\t  relations\n\t\t\t\t    define member: [user] as self\n\t\t\t\ttype feature\n\t\t\t\t  relations\n\t\t\t\t    define accessible as admin from subscriber_org or member from subscriber_group\n\t\t\t\t    define subscriber_group: [group] as self\n\t\t\t\t    define subscriber_org: [org] as self\n\t\t\t\t`),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"type_name_is_empty_string\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terrCode: codes.Code(openfgav1.ErrorCode_invalid_authorization_model),\n\t\t},\n\t\t{\n\t\t\tname: \"relation_name_is_empty_string\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"\": typesystem.This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"other\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terrCode: codes.Code(openfgav1.ErrorCode_invalid_authorization_model),\n\t\t},\n\t\t{\n\t\t\tname: \"many_circular_computed_relations\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype canvas\n\t\t\t\t  relations\n\t\t\t\t\tdefine can_edit as editor or owner\n\t\t\t\t\tdefine editor: [user, account#member] as self\n\t\t\t\t\tdefine owner: [user] as self\n\t\t\t\t\tdefine viewer: [user, account#member] as self\n\t  \n\t\t\t\ttype account\n\t\t\t\t  relations\n\t\t\t\t\tdefine admin: [user] as self or member or super_admin or owner\n\t\t\t\t\tdefine member: [user] as self or owner or admin or super_admin\n\t\t\t\t\tdefine owner: [user] as self\n\t\t\t\t\tdefine super_admin: [user] as self or admin or member\n\t\t\t\t`),\n\t\t\t},\n\t\t\terrCode: codes.Code(openfgav1.ErrorCode_invalid_authorization_model),\n\t\t},\n\t\t{\n\t\t\tname: \"circular_relations_involving_intersection\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype other\n\t\t\t\t  relations\n\t\t\t\t\tdefine x: [user] as self and y\n\t\t\t\t\tdefine y: [user] as self and z\n\t\t\t\t\tdefine z: [user] as self or x\n\t\t\t\t`),\n\t\t\t},\n\t\t\terrCode: codes.Code(openfgav1.ErrorCode_invalid_authorization_model),\n\t\t},\n\t\t{\n\t\t\tname: \"circular_relations_involving_exclusion\",\n\t\t\trequest: &openfgav1.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype other\n\t\t\t\t  relations\n\t\t\t\t\tdefine x: [user] as self but not y\n\t\t\t\t\tdefine y: [user] as self but not z\n\t\t\t\t\tdefine z: [user] as self or x\n\t\t\t\t`),\n\t\t\t},\n\t\t\terrCode: codes.Code(openfgav1.ErrorCode_invalid_authorization_model),\n\t\t},\n\t}\n\n\tctx := context.Background()\n\tlogger := logger.NewNoopLogger()\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tcmd := commands.NewWriteAuthorizationModelCommand(datastore, logger)\n\t\t\tresp, err := cmd.Execute(ctx, test.request)\n\t\t\tstatus, ok := status.FromError(err)\n\t\t\trequire.True(t, ok)\n\t\t\trequire.Equal(t, test.errCode, status.Code())\n\n\t\t\tif err == nil {\n\t\t\t\t_, err = ulid.Parse(resp.AuthorizationModelId)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n", "// Package typesystem contains code to manipulate authorization models\npackage typesystem\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"maps\"\n\t\"reflect\"\n\t\"sort\"\n\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"go.opentelemetry.io/otel\"\n)\n\nvar tracer = otel.Tracer(\"openfga/pkg/typesystem\")\n\ntype ctxKey string\n\nconst (\n\tSchemaVersion1_0 string = \"1.0\"\n\tSchemaVersion1_1 string = \"1.1\"\n\n\ttypesystemCtxKey ctxKey = \"typesystem-context-key\"\n)\n\nvar (\n\tErrModelNotFound         = errors.New(\"authorization model not found\")\n\tErrDuplicateTypes        = errors.New(\"an authorization model cannot contain duplicate types\")\n\tErrInvalidSchemaVersion  = errors.New(\"invalid schema version\")\n\tErrInvalidModel          = errors.New(\"invalid authorization model encountered\")\n\tErrRelationUndefined     = errors.New(\"undefined relation\")\n\tErrObjectTypeUndefined   = errors.New(\"undefined object type\")\n\tErrInvalidUsersetRewrite = errors.New(\"invalid userset rewrite definition\")\n\tErrReservedKeywords      = errors.New(\"self and this are reserved keywords\")\n\tErrCycle                 = errors.New(\"an authorization model cannot contain a cycle\")\n\tErrNoEntrypoints         = errors.New(\"no entrypoints defined\")\n\tErrNoEntryPointsLoop     = errors.New(\"potential loop\")\n)\n\nfunc IsSchemaVersionSupported(version string) bool {\n\tswitch version {\n\tcase SchemaVersion1_1:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// ContextWithTypesystem attaches the provided TypeSystem to the parent context.\nfunc ContextWithTypesystem(parent context.Context, typesys *TypeSystem) context.Context {\n\treturn context.WithValue(parent, typesystemCtxKey, typesys)\n}\n\n// TypesystemFromContext returns the TypeSystem from the provided context (if any).\nfunc TypesystemFromContext(ctx context.Context) (*TypeSystem, bool) {\n\ttypesys, ok := ctx.Value(typesystemCtxKey).(*TypeSystem)\n\treturn typesys, ok\n}\n\nfunc DirectRelationReference(objectType, relation string) *openfgav1.RelationReference {\n\trelationReference := &openfgav1.RelationReference{\n\t\tType: objectType,\n\t}\n\tif relation != \"\" {\n\t\trelationReference.RelationOrWildcard = &openfgav1.RelationReference_Relation{\n\t\t\tRelation: relation,\n\t\t}\n\t}\n\n\treturn relationReference\n}\n\nfunc WildcardRelationReference(objectType string) *openfgav1.RelationReference {\n\treturn &openfgav1.RelationReference{\n\t\tType: objectType,\n\t\tRelationOrWildcard: &openfgav1.RelationReference_Wildcard{\n\t\t\tWildcard: &openfgav1.Wildcard{},\n\t\t},\n\t}\n}\n\nfunc This() *openfgav1.Userset {\n\treturn &openfgav1.Userset{\n\t\tUserset: &openfgav1.Userset_This{},\n\t}\n}\n\nfunc ComputedUserset(relation string) *openfgav1.Userset {\n\treturn &openfgav1.Userset{\n\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\tComputedUserset: &openfgav1.ObjectRelation{\n\t\t\t\tRelation: relation,\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc TupleToUserset(tupleset, computedUserset string) *openfgav1.Userset {\n\treturn &openfgav1.Userset{\n\t\tUserset: &openfgav1.Userset_TupleToUserset{\n\t\t\tTupleToUserset: &openfgav1.TupleToUserset{\n\t\t\t\tTupleset: &openfgav1.ObjectRelation{\n\t\t\t\t\tRelation: tupleset,\n\t\t\t\t},\n\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{\n\t\t\t\t\tRelation: computedUserset,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc Union(children ...*openfgav1.Userset) *openfgav1.Userset {\n\treturn &openfgav1.Userset{\n\t\tUserset: &openfgav1.Userset_Union{\n\t\t\tUnion: &openfgav1.Usersets{\n\t\t\t\tChild: children,\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc Intersection(children ...*openfgav1.Userset) *openfgav1.Userset {\n\treturn &openfgav1.Userset{\n\t\tUserset: &openfgav1.Userset_Intersection{\n\t\t\tIntersection: &openfgav1.Usersets{\n\t\t\t\tChild: children,\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc Difference(base *openfgav1.Userset, sub *openfgav1.Userset) *openfgav1.Userset {\n\treturn &openfgav1.Userset{\n\t\tUserset: &openfgav1.Userset_Difference{\n\t\t\tDifference: &openfgav1.Difference{\n\t\t\t\tBase:     base,\n\t\t\t\tSubtract: sub,\n\t\t\t},\n\t\t},\n\t}\n}\n\n// TypeSystem is a wrapper over an [openfgav1.AuthorizationModel].\ntype TypeSystem struct {\n\t// [objectType] => typeDefinition\n\ttypeDefinitions map[string]*openfgav1.TypeDefinition\n\t// [objectType] => [relationName] => relation\n\trelations     map[string]map[string]*openfgav1.Relation\n\tmodelID       string\n\tschemaVersion string\n}\n\n// New creates a *TypeSystem from an *openfgav1.AuthorizationModel.\n// It assumes that the input model is valid. If you need to run validations, use NewAndValidate.\nfunc New(model *openfgav1.AuthorizationModel) *TypeSystem {\n\ttds := make(map[string]*openfgav1.TypeDefinition, len(model.GetTypeDefinitions()))\n\trelations := make(map[string]map[string]*openfgav1.Relation, len(model.GetTypeDefinitions()))\n\n\tfor _, td := range model.GetTypeDefinitions() {\n\t\ttypeName := td.GetType()\n\n\t\ttds[typeName] = td\n\t\ttdRelations := make(map[string]*openfgav1.Relation, len(td.GetRelations()))\n\n\t\tfor relation, rewrite := range td.GetRelations() {\n\t\t\tr := &openfgav1.Relation{\n\t\t\t\tName:     relation,\n\t\t\t\tRewrite:  rewrite,\n\t\t\t\tTypeInfo: &openfgav1.RelationTypeInfo{},\n\t\t\t}\n\n\t\t\tif metadata, ok := td.GetMetadata().GetRelations()[relation]; ok {\n\t\t\t\tr.TypeInfo.DirectlyRelatedUserTypes = metadata.GetDirectlyRelatedUserTypes()\n\t\t\t}\n\n\t\t\ttdRelations[relation] = r\n\t\t}\n\t\trelations[typeName] = tdRelations\n\t}\n\n\treturn &TypeSystem{\n\t\tmodelID:         model.GetId(),\n\t\tschemaVersion:   model.GetSchemaVersion(),\n\t\ttypeDefinitions: tds,\n\t\trelations:       relations,\n\t}\n}\n\n// GetAuthorizationModelID returns the id for the authorization model this\n// TypeSystem was constructed for.\nfunc (t *TypeSystem) GetAuthorizationModelID() string {\n\treturn t.modelID\n}\n\nfunc (t *TypeSystem) GetSchemaVersion() string {\n\treturn t.schemaVersion\n}\n\nfunc (t *TypeSystem) GetTypeDefinition(objectType string) (*openfgav1.TypeDefinition, bool) {\n\tif typeDefinition, ok := t.typeDefinitions[objectType]; ok {\n\t\treturn typeDefinition, true\n\t}\n\treturn nil, false\n}\n\n// GetRelations returns all relations in the TypeSystem for a given type\nfunc (t *TypeSystem) GetRelations(objectType string) (map[string]*openfgav1.Relation, error) {\n\t_, ok := t.GetTypeDefinition(objectType)\n\tif !ok {\n\t\treturn nil, &ObjectTypeUndefinedError{\n\t\t\tObjectType: objectType,\n\t\t\tErr:        ErrObjectTypeUndefined,\n\t\t}\n\t}\n\n\treturn t.relations[objectType], nil\n}\n\nfunc (t *TypeSystem) GetRelation(objectType, relation string) (*openfgav1.Relation, error) {\n\trelations, err := t.GetRelations(objectType)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tr, ok := relations[relation]\n\tif !ok {\n\t\treturn nil, &RelationUndefinedError{\n\t\t\tObjectType: objectType,\n\t\t\tRelation:   relation,\n\t\t\tErr:        ErrRelationUndefined,\n\t\t}\n\t}\n\n\treturn r, nil\n}\n\n// GetRelationReferenceAsString returns team#member, or team:*, or an empty string if the input is nil.\nfunc GetRelationReferenceAsString(rr *openfgav1.RelationReference) string {\n\tif rr == nil {\n\t\treturn \"\"\n\t}\n\tif _, ok := rr.RelationOrWildcard.(*openfgav1.RelationReference_Relation); ok {\n\t\treturn fmt.Sprintf(\"%s#%s\", rr.GetType(), rr.GetRelation())\n\t}\n\tif _, ok := rr.RelationOrWildcard.(*openfgav1.RelationReference_Wildcard); ok {\n\t\treturn fmt.Sprintf(\"%s:*\", rr.GetType())\n\t}\n\n\tpanic(\"unexpected relation reference\")\n}\n\nfunc (t *TypeSystem) GetDirectlyRelatedUserTypes(objectType, relation string) ([]*openfgav1.RelationReference, error) {\n\n\tr, err := t.GetRelation(objectType, relation)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn r.GetTypeInfo().GetDirectlyRelatedUserTypes(), nil\n}\n\n// DirectlyRelatedUsersets returns a list of the directly user related types that are usersets\nfunc (t *TypeSystem) DirectlyRelatedUsersets(objectType, relation string) ([]*openfgav1.RelationReference, error) {\n\trefs, err := t.GetDirectlyRelatedUserTypes(objectType, relation)\n\tvar usersetRelationReferences []*openfgav1.RelationReference\n\tif err != nil {\n\t\treturn usersetRelationReferences, err\n\t}\n\n\tfor _, ref := range refs {\n\t\tif ref.GetRelation() != \"\" || ref.GetWildcard() != nil {\n\t\t\tusersetRelationReferences = append(usersetRelationReferences, ref)\n\t\t}\n\t}\n\treturn usersetRelationReferences, nil\n}\n\n// IsDirectlyRelated determines whether the type of the target DirectRelationReference contains the source DirectRelationReference.\nfunc (t *TypeSystem) IsDirectlyRelated(target *openfgav1.RelationReference, source *openfgav1.RelationReference) (bool, error) {\n\n\trelation, err := t.GetRelation(target.GetType(), target.GetRelation())\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tfor _, typeRestriction := range relation.GetTypeInfo().GetDirectlyRelatedUserTypes() {\n\t\tif source.GetType() == typeRestriction.GetType() {\n\n\t\t\t// type with no relation or wildcard (e.g. 'user')\n\t\t\tif typeRestriction.GetRelationOrWildcard() == nil && source.GetRelationOrWildcard() == nil {\n\t\t\t\treturn true, nil\n\t\t\t}\n\n\t\t\t// typed wildcard (e.g. 'user:*')\n\t\t\tif typeRestriction.GetWildcard() != nil && source.GetWildcard() != nil {\n\t\t\t\treturn true, nil\n\t\t\t}\n\n\t\t\tif typeRestriction.GetRelation() != \"\" && source.GetRelation() != \"\" &&\n\t\t\t\ttypeRestriction.GetRelation() == source.GetRelation() {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\n/*\n * IsPubliclyAssignable returns true if the provided objectType is part of a typed wildcard type restriction\n * on the target relation.\n *\n * type user\n *\n * type document\n *   relations\n *     define viewer: [user:*]\n *\n * In the example above, the 'user' objectType is publicly assignable to the 'document#viewer' relation.\n */\nfunc (t *TypeSystem) IsPubliclyAssignable(target *openfgav1.RelationReference, objectType string) (bool, error) {\n\n\trelation, err := t.GetRelation(target.GetType(), target.GetRelation())\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tfor _, typeRestriction := range relation.GetTypeInfo().GetDirectlyRelatedUserTypes() {\n\t\tif typeRestriction.GetType() == objectType {\n\t\t\tif typeRestriction.GetWildcard() != nil {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\nfunc (t *TypeSystem) HasTypeInfo(objectType, relation string) (bool, error) {\n\tr, err := t.GetRelation(objectType, relation)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tif t.GetSchemaVersion() == SchemaVersion1_1 && r.GetTypeInfo() != nil {\n\t\treturn true, nil\n\t}\n\n\treturn false, nil\n}\n\n// RelationInvolvesIntersection returns true if the provided relation's userset rewrite\n// is defined by one or more direct or indirect intersections or any of the types related to\n// the provided relation are defined by one or more direct or indirect intersections.\nfunc (t *TypeSystem) RelationInvolvesIntersection(objectType, relation string) (bool, error) {\n\tvisited := map[string]struct{}{}\n\treturn t.relationInvolvesIntersection(objectType, relation, visited)\n}\n\nfunc (t *TypeSystem) relationInvolvesIntersection(objectType, relation string, visited map[string]struct{}) (bool, error) {\n\n\tkey := tuple.ToObjectRelationString(objectType, relation)\n\tif _, ok := visited[key]; ok {\n\t\treturn false, nil\n\t}\n\n\tvisited[key] = struct{}{}\n\n\trel, err := t.GetRelation(objectType, relation)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\trewrite := rel.GetRewrite()\n\n\tresult, err := WalkUsersetRewrite(rewrite, func(r *openfgav1.Userset) interface{} {\n\n\t\tswitch rw := r.GetUserset().(type) {\n\t\tcase *openfgav1.Userset_ComputedUserset:\n\t\t\trewrittenRelation := rw.ComputedUserset.GetRelation()\n\t\t\trewritten, err := t.GetRelation(objectType, rewrittenRelation)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tcontainsIntersection, err := t.relationInvolvesIntersection(\n\t\t\t\tobjectType,\n\t\t\t\trewritten.GetName(),\n\t\t\t\tvisited,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif containsIntersection {\n\t\t\t\treturn true\n\t\t\t}\n\n\t\tcase *openfgav1.Userset_TupleToUserset:\n\t\t\ttupleset := rw.TupleToUserset.GetTupleset().GetRelation()\n\t\t\trewrittenRelation := rw.TupleToUserset.ComputedUserset.GetRelation()\n\n\t\t\ttuplesetRel, err := t.GetRelation(objectType, tupleset)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tdirectlyRelatedTypes := tuplesetRel.GetTypeInfo().GetDirectlyRelatedUserTypes()\n\t\t\tfor _, relatedType := range directlyRelatedTypes {\n\t\t\t\t// must be of the form 'objectType' by this point since we disallow `tupleset` relations of the form `objectType:id#relation`\n\t\t\t\tr := relatedType.GetRelation()\n\t\t\t\tif r != \"\" {\n\t\t\t\t\treturn fmt.Errorf(\n\t\t\t\t\t\t\"invalid type restriction '%s#%s' specified on tupleset relation '%s#%s': %w\",\n\t\t\t\t\t\trelatedType.GetType(),\n\t\t\t\t\t\trelatedType.GetRelation(),\n\t\t\t\t\t\tobjectType,\n\t\t\t\t\t\ttupleset,\n\t\t\t\t\t\tErrInvalidModel,\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\trel, err := t.GetRelation(relatedType.GetType(), rewrittenRelation)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif errors.Is(err, ErrObjectTypeUndefined) || errors.Is(err, ErrRelationUndefined) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tcontainsIntersection, err := t.relationInvolvesIntersection(\n\t\t\t\t\trelatedType.GetType(),\n\t\t\t\t\trel.GetName(),\n\t\t\t\t\tvisited,\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tif containsIntersection {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn nil\n\n\t\tcase *openfgav1.Userset_Intersection:\n\t\t\treturn true\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tif result != nil && result.(bool) {\n\t\treturn true, nil\n\t}\n\n\tfor _, typeRestriction := range rel.GetTypeInfo().GetDirectlyRelatedUserTypes() {\n\t\tif typeRestriction.GetRelation() != \"\" {\n\n\t\t\tkey := tuple.ToObjectRelationString(typeRestriction.GetType(), typeRestriction.GetRelation())\n\t\t\tif _, ok := visited[key]; ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tcontainsIntersection, err := t.relationInvolvesIntersection(\n\t\t\t\ttypeRestriction.GetType(),\n\t\t\t\ttypeRestriction.GetRelation(),\n\t\t\t\tvisited,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\n\t\t\tif containsIntersection {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\n// RelationInvolvesExclusion returns true if the provided relation's userset rewrite\n// is defined by one or more direct or indirect exclusions or any of the types related to\n// the provided relation are defined by one or more direct or indirect exclusions.\nfunc (t *TypeSystem) RelationInvolvesExclusion(objectType, relation string) (bool, error) {\n\tvisited := map[string]struct{}{}\n\treturn t.relationInvolvesExclusion(objectType, relation, visited)\n\n}\n\nfunc (t *TypeSystem) relationInvolvesExclusion(objectType, relation string, visited map[string]struct{}) (bool, error) {\n\n\tkey := tuple.ToObjectRelationString(objectType, relation)\n\tif _, ok := visited[key]; ok {\n\t\treturn false, nil\n\t}\n\n\tvisited[key] = struct{}{}\n\n\trel, err := t.GetRelation(objectType, relation)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\trewrite := rel.GetRewrite()\n\n\tresult, err := WalkUsersetRewrite(rewrite, func(r *openfgav1.Userset) interface{} {\n\t\tswitch rw := r.GetUserset().(type) {\n\t\tcase *openfgav1.Userset_ComputedUserset:\n\t\t\trewrittenRelation := rw.ComputedUserset.GetRelation()\n\t\t\trewritten, err := t.GetRelation(objectType, rewrittenRelation)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tcontainsExclusion, err := t.relationInvolvesExclusion(\n\t\t\t\tobjectType,\n\t\t\t\trewritten.GetName(),\n\t\t\t\tvisited,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif containsExclusion {\n\t\t\t\treturn true\n\t\t\t}\n\n\t\tcase *openfgav1.Userset_TupleToUserset:\n\t\t\ttupleset := rw.TupleToUserset.GetTupleset().GetRelation()\n\t\t\trewrittenRelation := rw.TupleToUserset.ComputedUserset.GetRelation()\n\n\t\t\ttuplesetRel, err := t.GetRelation(objectType, tupleset)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tdirectlyRelatedTypes := tuplesetRel.GetTypeInfo().GetDirectlyRelatedUserTypes()\n\t\t\tfor _, relatedType := range directlyRelatedTypes {\n\t\t\t\t// must be of the form 'objectType' by this point since we disallow `tupleset` relations of the form `objectType:id#relation`\n\t\t\t\tr := relatedType.GetRelation()\n\t\t\t\tif r != \"\" {\n\t\t\t\t\treturn fmt.Errorf(\n\t\t\t\t\t\t\"invalid type restriction '%s#%s' specified on tupleset relation '%s#%s': %w\",\n\t\t\t\t\t\trelatedType.GetType(),\n\t\t\t\t\t\trelatedType.GetRelation(),\n\t\t\t\t\t\tobjectType,\n\t\t\t\t\t\ttupleset,\n\t\t\t\t\t\tErrInvalidModel,\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\trel, err := t.GetRelation(relatedType.GetType(), rewrittenRelation)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif errors.Is(err, ErrObjectTypeUndefined) || errors.Is(err, ErrRelationUndefined) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tcontainsExclusion, err := t.relationInvolvesExclusion(\n\t\t\t\t\trelatedType.GetType(),\n\t\t\t\t\trel.GetName(),\n\t\t\t\t\tvisited,\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tif containsExclusion {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn nil\n\n\t\tcase *openfgav1.Userset_Difference:\n\t\t\treturn true\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tif result != nil && result.(bool) {\n\t\treturn true, nil\n\t}\n\n\tfor _, typeRestriction := range rel.GetTypeInfo().GetDirectlyRelatedUserTypes() {\n\t\tif typeRestriction.GetRelation() != \"\" {\n\n\t\t\tkey := tuple.ToObjectRelationString(typeRestriction.GetType(), typeRestriction.GetRelation())\n\t\t\tif _, ok := visited[key]; ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tcontainsExclusion, err := t.relationInvolvesExclusion(\n\t\t\t\ttypeRestriction.GetType(),\n\t\t\t\ttypeRestriction.GetRelation(),\n\t\t\t\tvisited,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\n\t\t\tif containsExclusion {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\n// hasEntrypoints recursively walks the rewrite definition for the given relation to determine if there is at least\n// one path in the rewrite rule that could relate to at least one concrete object type. If there is no such path that\n// could lead to at least one relationship with some object type, then false is returned along with an error indicating\n// no entrypoints were found. If at least one relationship with a specific object type is found while walking the rewrite,\n// then true is returned along with a nil error.\nfunc hasEntrypoints(\n\ttypedefs map[string]map[string]*openfgav1.Relation,\n\ttypeName, relationName string,\n\trewrite *openfgav1.Userset,\n\tvisitedRelations map[string]map[string]struct{},\n) (bool, bool, error) {\n\n\tv := maps.Clone(visitedRelations)\n\n\tif val, ok := v[typeName]; ok {\n\t\tval[relationName] = struct{}{}\n\t} else {\n\t\tv[typeName] = map[string]struct{}{\n\t\t\trelationName: {},\n\t\t}\n\t}\n\n\trelation, ok := typedefs[typeName][relationName]\n\tif !ok {\n\t\treturn false, false, fmt.Errorf(\"undefined type definition for '%s#%s'\", typeName, relationName)\n\t}\n\n\tswitch rw := rewrite.Userset.(type) {\n\tcase *openfgav1.Userset_This:\n\t\tfor _, assignableType := range relation.GetTypeInfo().GetDirectlyRelatedUserTypes() {\n\t\t\tif assignableType.GetRelationOrWildcard() == nil || assignableType.GetWildcard() != nil {\n\t\t\t\treturn true, false, nil\n\t\t\t}\n\n\t\t\tassignableTypeName := assignableType.GetType()\n\t\t\tassignableRelationName := assignableType.GetRelation()\n\n\t\t\tassignableRelation, ok := typedefs[assignableTypeName][assignableRelationName]\n\t\t\tif !ok {\n\t\t\t\treturn false, false, fmt.Errorf(\"undefined type definition for '%s#%s'\", assignableTypeName, assignableRelationName)\n\t\t\t}\n\n\t\t\tif _, ok := v[assignableTypeName][assignableRelationName]; ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\thasEntrypoint, _, err := hasEntrypoints(typedefs, assignableTypeName, assignableRelationName, assignableRelation.GetRewrite(), v)\n\t\t\tif err != nil {\n\t\t\t\treturn false, false, err\n\t\t\t}\n\n\t\t\tif hasEntrypoint {\n\t\t\t\treturn true, false, nil\n\t\t\t}\n\t\t}\n\n\t\treturn false, false, nil\n\tcase *openfgav1.Userset_ComputedUserset:\n\n\t\tcomputedRelationName := rw.ComputedUserset.GetRelation()\n\t\tcomputedRelation, ok := typedefs[typeName][computedRelationName]\n\t\tif !ok {\n\t\t\treturn false, false, fmt.Errorf(\"undefined type definition for '%s#%s'\", typeName, computedRelationName)\n\t\t}\n\n\t\tif _, ok := v[typeName][computedRelationName]; ok {\n\t\t\treturn false, true, nil\n\t\t}\n\n\t\thasEntrypoint, loop, err := hasEntrypoints(typedefs, typeName, computedRelationName, computedRelation.GetRewrite(), v)\n\t\tif err != nil {\n\t\t\treturn false, false, err\n\t\t}\n\n\t\treturn hasEntrypoint, loop, nil\n\tcase *openfgav1.Userset_TupleToUserset:\n\t\ttuplesetRelationName := rw.TupleToUserset.GetTupleset().GetRelation()\n\t\tcomputedRelationName := rw.TupleToUserset.ComputedUserset.GetRelation()\n\n\t\ttuplesetRelation, ok := typedefs[typeName][tuplesetRelationName]\n\t\tif !ok {\n\t\t\treturn false, false, fmt.Errorf(\"undefined type definition for '%s#%s'\", typeName, tuplesetRelationName)\n\t\t}\n\n\t\tfor _, assignableType := range tuplesetRelation.GetTypeInfo().GetDirectlyRelatedUserTypes() {\n\t\t\tassignableTypeName := assignableType.GetType()\n\n\t\t\tif assignableRelation, ok := typedefs[assignableTypeName][computedRelationName]; ok {\n\t\t\t\tif _, ok := v[assignableTypeName][computedRelationName]; ok {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\thasEntrypoint, _, err := hasEntrypoints(typedefs, assignableTypeName, computedRelationName, assignableRelation.GetRewrite(), v)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn false, false, err\n\t\t\t\t}\n\n\t\t\t\tif hasEntrypoint {\n\t\t\t\t\treturn true, false, nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false, false, nil\n\n\tcase *openfgav1.Userset_Union:\n\n\t\tloop := false\n\t\tfor _, child := range rw.Union.Child {\n\n\t\t\thasEntrypoints, childLoop, err := hasEntrypoints(typedefs, typeName, relationName, child, maps.Clone(visitedRelations))\n\t\t\tif err != nil {\n\t\t\t\treturn false, false, err\n\t\t\t}\n\n\t\t\tif hasEntrypoints {\n\t\t\t\treturn true, false, nil\n\t\t\t}\n\t\t\tloop = loop || childLoop\n\t\t}\n\n\t\treturn false, loop, nil\n\tcase *openfgav1.Userset_Intersection:\n\n\t\tfor _, child := range rw.Intersection.Child {\n\n\t\t\t// all of the children must have an entrypoint\n\t\t\thasEntrypoints, childLoop, err := hasEntrypoints(typedefs, typeName, relationName, child, maps.Clone(visitedRelations))\n\t\t\tif err != nil {\n\t\t\t\treturn false, false, err\n\t\t\t}\n\n\t\t\tif !hasEntrypoints {\n\t\t\t\treturn false, childLoop, nil\n\t\t\t}\n\t\t}\n\n\t\treturn true, false, nil\n\tcase *openfgav1.Userset_Difference:\n\n\t\tv := maps.Clone(visitedRelations)\n\n\t\thasEntrypoint, loop, err := hasEntrypoints(typedefs, typeName, relationName, rw.Difference.GetBase(), v)\n\t\tif err != nil {\n\t\t\treturn false, false, err\n\t\t}\n\n\t\tif !hasEntrypoint {\n\t\t\treturn false, loop, nil\n\t\t}\n\n\t\thasEntrypoint, loop, err = hasEntrypoints(typedefs, typeName, relationName, rw.Difference.GetSubtract(), v)\n\t\tif err != nil {\n\t\t\treturn false, false, err\n\t\t}\n\n\t\tif !hasEntrypoint {\n\t\t\treturn false, loop, nil\n\t\t}\n\n\t\treturn true, false, nil\n\t}\n\n\treturn false, false, nil\n}\n\n// NewAndValidate is like New but also validates the model according to the following rules:\n//  1. Checks that the *TypeSystem have a valid schema version.\n//  2. For every rewrite the relations in the rewrite must:\n//     a. Be valid relations on the same type in the *TypeSystem (in cases of computedUserset)\n//     b. Be valid relations on another existing type (in cases of tupleToUserset)\n//  3. Do not allow duplicate types or duplicate relations (only need to check types as relations are\n//     in a map so cannot contain duplicates)\n//\n// If the *TypeSystem has a v1.1 schema version (with types on relations), then additionally\n// validate the *TypeSystem according to the following rules:\n//  3. Every type restriction on a relation must be a valid type:\n//     a. For a type (e.g. user) this means checking that this type is in the *TypeSystem\n//     b. For a type#relation this means checking that this type with this relation is in the *TypeSystem\n//  4. Check that a relation is assignable if and only if it has a non-zero list of types\nfunc NewAndValidate(ctx context.Context, model *openfgav1.AuthorizationModel) (*TypeSystem, error) {\n\t_, span := tracer.Start(ctx, \"typesystem.NewAndValidate\")\n\tdefer span.End()\n\n\tt := New(model)\n\tschemaVersion := t.GetSchemaVersion()\n\n\tif !IsSchemaVersionSupported(schemaVersion) {\n\t\treturn nil, ErrInvalidSchemaVersion\n\t}\n\n\tif containsDuplicateType(model) {\n\t\treturn nil, ErrDuplicateTypes\n\t}\n\n\tif err := t.validateNames(); err != nil {\n\t\treturn nil, err\n\t}\n\n\ttypedefsMap := t.typeDefinitions\n\n\ttypeNames := make([]string, 0, len(typedefsMap))\n\tfor typeName := range typedefsMap {\n\t\ttypeNames = append(typeNames, typeName)\n\t}\n\n\t// range over the type definitions in sorted order to produce a deterministic outcome\n\tsort.Strings(typeNames)\n\n\tfor _, typeName := range typeNames {\n\t\ttypedef := typedefsMap[typeName]\n\n\t\trelationMap := typedef.GetRelations()\n\t\trelationNames := make([]string, 0, len(relationMap))\n\t\tfor relationName := range relationMap {\n\t\t\trelationNames = append(relationNames, relationName)\n\t\t}\n\n\t\t// range over the relations in sorted order to produce a deterministic outcome\n\t\tsort.Strings(relationNames)\n\n\t\tfor _, relationName := range relationNames {\n\n\t\t\terr := t.validateRelation(typeName, relationName, relationMap)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn t, nil\n}\n\n// validateRelation applies all the validation rules to a relation definition in a model. A relation\n// must meet all the rewrite validation, type restriction validation, and entrypoint validation criteria\n// for it to be valid. Otherwise, an error is returned.\nfunc (t *TypeSystem) validateRelation(typeName, relationName string, relationMap map[string]*openfgav1.Userset) error {\n\n\trewrite := relationMap[relationName]\n\n\terr := t.isUsersetRewriteValid(typeName, relationName, rewrite)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = t.validateTypeRestrictions(typeName, relationName)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvisitedRelations := map[string]map[string]struct{}{}\n\n\thasEntrypoints, loop, err := hasEntrypoints(t.relations, typeName, relationName, rewrite, visitedRelations)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !hasEntrypoints {\n\t\tcause := ErrNoEntrypoints\n\t\tif loop {\n\t\t\tcause = ErrNoEntryPointsLoop\n\t\t}\n\t\treturn &InvalidRelationError{\n\t\t\tObjectType: typeName,\n\t\t\tRelation:   relationName,\n\t\t\tCause:      cause,\n\t\t}\n\t}\n\n\thasCycle, err := t.HasCycle(typeName, relationName)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif hasCycle {\n\t\treturn &InvalidRelationError{\n\t\t\tObjectType: typeName,\n\t\t\tRelation:   relationName,\n\t\t\tCause:      ErrCycle,\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc containsDuplicateType(model *openfgav1.AuthorizationModel) bool {\n\tseen := make(map[string]struct{}, len(model.GetTypeDefinitions()))\n\tfor _, td := range model.GetTypeDefinitions() {\n\t\tobjectType := td.GetType()\n\t\tif _, ok := seen[objectType]; ok {\n\t\t\treturn true\n\t\t}\n\t\tseen[objectType] = struct{}{}\n\t}\n\treturn false\n}\n\n// validateNames ensures that a model doesn't have object types or relations\n// called \"self\" or \"this\"\nfunc (t *TypeSystem) validateNames() error {\n\tfor _, td := range t.typeDefinitions {\n\t\tobjectType := td.GetType()\n\n\t\tif objectType == \"\" {\n\t\t\treturn fmt.Errorf(\"the type name of a type definition cannot be an empty string\")\n\t\t}\n\n\t\tif objectType == \"self\" || objectType == \"this\" {\n\t\t\treturn &InvalidTypeError{ObjectType: objectType, Cause: ErrReservedKeywords}\n\t\t}\n\n\t\tfor relation := range td.GetRelations() {\n\t\t\tif relation == \"\" {\n\t\t\t\treturn fmt.Errorf(\"type '%s' defines a relation with an empty string for a name\", objectType)\n\t\t\t}\n\n\t\t\tif relation == \"self\" || relation == \"this\" {\n\t\t\t\treturn &InvalidRelationError{ObjectType: objectType, Relation: relation, Cause: ErrReservedKeywords}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// isUsersetRewriteValid checks if the rewrite on objectType#relation is valid.\nfunc (t *TypeSystem) isUsersetRewriteValid(objectType, relation string, rewrite *openfgav1.Userset) error {\n\tif rewrite.GetUserset() == nil {\n\t\treturn &InvalidRelationError{ObjectType: objectType, Relation: relation, Cause: ErrInvalidUsersetRewrite}\n\t}\n\n\tswitch r := rewrite.GetUserset().(type) {\n\tcase *openfgav1.Userset_ComputedUserset:\n\t\tcomputedUserset := r.ComputedUserset.GetRelation()\n\t\tif computedUserset == relation {\n\t\t\treturn &InvalidRelationError{ObjectType: objectType, Relation: relation, Cause: ErrInvalidUsersetRewrite}\n\t\t}\n\t\tif _, err := t.GetRelation(objectType, computedUserset); err != nil {\n\t\t\treturn &RelationUndefinedError{ObjectType: objectType, Relation: computedUserset, Err: ErrRelationUndefined}\n\t\t}\n\tcase *openfgav1.Userset_TupleToUserset:\n\t\ttupleset := r.TupleToUserset.GetTupleset().GetRelation()\n\n\t\ttuplesetRelation, err := t.GetRelation(objectType, tupleset)\n\t\tif err != nil {\n\t\t\treturn &RelationUndefinedError{ObjectType: objectType, Relation: tupleset, Err: ErrRelationUndefined}\n\t\t}\n\n\t\t// tupleset relations must only be direct relationships, no rewrites are allowed on them\n\t\ttuplesetRewrite := tuplesetRelation.GetRewrite()\n\t\tif reflect.TypeOf(tuplesetRewrite.GetUserset()) != reflect.TypeOf(&openfgav1.Userset_This{}) {\n\t\t\treturn fmt.Errorf(\"the '%s#%s' relation is referenced in at least one tupleset and thus must be a direct relation\", objectType, tupleset)\n\t\t}\n\n\t\tcomputedUserset := r.TupleToUserset.GetComputedUserset().GetRelation()\n\n\t\tif t.GetSchemaVersion() == SchemaVersion1_1 {\n\t\t\t// for 1.1 models, relation `computedUserset` has to be defined in one of the types declared by the tupleset's list of allowed types\n\t\t\tuserTypes := tuplesetRelation.GetTypeInfo().GetDirectlyRelatedUserTypes()\n\t\t\tfor _, rr := range userTypes {\n\t\t\t\tif _, err := t.GetRelation(rr.GetType(), computedUserset); err == nil {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"%w: %s does not appear as a relation in any of the directly related user types %s\", ErrRelationUndefined, computedUserset, userTypes)\n\t\t} else {\n\t\t\t// for 1.0 models, relation `computedUserset` has to be defined _somewhere_ in the model\n\t\t\tfor typeName := range t.relations {\n\t\t\t\tif _, err := t.GetRelation(typeName, computedUserset); err == nil {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn &RelationUndefinedError{ObjectType: \"\", Relation: computedUserset, Err: ErrRelationUndefined}\n\t\t}\n\tcase *openfgav1.Userset_Union:\n\t\tfor _, child := range r.Union.GetChild() {\n\t\t\terr := t.isUsersetRewriteValid(objectType, relation, child)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\tcase *openfgav1.Userset_Intersection:\n\t\tfor _, child := range r.Intersection.GetChild() {\n\t\t\terr := t.isUsersetRewriteValid(objectType, relation, child)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\tcase *openfgav1.Userset_Difference:\n\t\terr := t.isUsersetRewriteValid(objectType, relation, r.Difference.Base)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = t.isUsersetRewriteValid(objectType, relation, r.Difference.Subtract)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// validateTypeRestrictions validates the type restrictions of a given relation using the following rules:\n//  1. An assignable relation must have one or more type restrictions.\n//  2. A non-assignable relation must not have any type restrictions.\n//  3. For each type restriction referenced for an assignable relation, each of the referenced types and relations\n//     must be defined in the model.\n//  4. If the provided relation is a tupleset relation, then the type restriction must be on a direct object.\nfunc (t *TypeSystem) validateTypeRestrictions(objectType string, relationName string) error {\n\n\trelation, err := t.GetRelation(objectType, relationName)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trelatedTypes := relation.GetTypeInfo().GetDirectlyRelatedUserTypes()\n\tassignable := t.IsDirectlyAssignable(relation)\n\n\tif assignable && len(relatedTypes) == 0 {\n\t\treturn AssignableRelationError(objectType, relationName)\n\t}\n\n\tif !assignable && len(relatedTypes) != 0 {\n\t\treturn NonAssignableRelationError(objectType, relationName)\n\t}\n\n\tfor _, related := range relatedTypes {\n\t\trelatedObjectType := related.GetType()\n\t\trelatedRelation := related.GetRelation()\n\n\t\tif _, err := t.GetRelations(relatedObjectType); err != nil {\n\t\t\treturn InvalidRelationTypeError(objectType, relationName, relatedObjectType, relatedRelation)\n\t\t}\n\n\t\tif related.GetRelationOrWildcard() != nil {\n\t\t\t// The type of the relation cannot contain a userset or wildcard if the relation is a tupleset relation.\n\t\t\tif ok, _ := t.IsTuplesetRelation(objectType, relationName); ok {\n\t\t\t\treturn InvalidRelationTypeError(objectType, relationName, relatedObjectType, relatedRelation)\n\t\t\t}\n\n\t\t\tif relatedRelation != \"\" {\n\t\t\t\tif _, err := t.GetRelation(relatedObjectType, relatedRelation); err != nil {\n\t\t\t\t\treturn InvalidRelationTypeError(objectType, relationName, relatedObjectType, relatedRelation)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (t *TypeSystem) IsDirectlyAssignable(relation *openfgav1.Relation) bool {\n\treturn RewriteContainsSelf(relation.GetRewrite())\n}\n\n// RewriteContainsSelf returns true if the provided userset rewrite\n// is defined by one or more self referencing definitions.\nfunc RewriteContainsSelf(rewrite *openfgav1.Userset) bool {\n\n\tresult, err := WalkUsersetRewrite(rewrite, func(r *openfgav1.Userset) interface{} {\n\t\tif _, ok := r.Userset.(*openfgav1.Userset_This); ok {\n\t\t\treturn true\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tpanic(\"unexpected error during rewrite evaluation\")\n\t}\n\n\treturn result != nil && result.(bool) // type-cast matches the return from the WalkRelationshipRewriteHandler above\n}\n\n// RewriteContainsIntersection returns true if the provided userset rewrite\n// is defined by one or more direct or indirect intersections.\nfunc RewriteContainsIntersection(rewrite *openfgav1.Userset) bool {\n\n\tresult, err := WalkUsersetRewrite(rewrite, func(r *openfgav1.Userset) interface{} {\n\t\tif _, ok := r.Userset.(*openfgav1.Userset_Intersection); ok {\n\t\t\treturn true\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tpanic(\"unexpected error during rewrite evaluation\")\n\t}\n\n\treturn result != nil && result.(bool) // type-cast matches the return from the WalkRelationshipRewriteHandler above\n}\n\n// RewriteContainsExclusion returns true if the provided userset rewrite\n// is defined by one or more direct or indirect exclusions.\nfunc RewriteContainsExclusion(rewrite *openfgav1.Userset) bool {\n\n\tresult, err := WalkUsersetRewrite(rewrite, func(r *openfgav1.Userset) interface{} {\n\t\tif _, ok := r.Userset.(*openfgav1.Userset_Difference); ok {\n\t\t\treturn true\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tpanic(\"unexpected error during rewrite evaluation\")\n\t}\n\n\treturn result != nil && result.(bool) // type-cast matches the return from the WalkRelationshipRewriteHandler above\n}\n\ntype InvalidTypeError struct {\n\tObjectType string\n\tCause      error\n}\n\nfunc (e *InvalidTypeError) Error() string {\n\treturn fmt.Sprintf(\"the definition of type '%s' is invalid\", e.ObjectType)\n}\n\nfunc (e *InvalidTypeError) Unwrap() error {\n\treturn e.Cause\n}\n\ntype InvalidRelationError struct {\n\tObjectType string\n\tRelation   string\n\tCause      error\n}\n\nfunc (e *InvalidRelationError) Error() string {\n\treturn fmt.Sprintf(\"the definition of relation '%s' in object type '%s' is invalid: %s\", e.Relation, e.ObjectType, e.Cause)\n}\n\nfunc (e *InvalidRelationError) Unwrap() error {\n\treturn e.Cause\n}\n\ntype ObjectTypeUndefinedError struct {\n\tObjectType string\n\tErr        error\n}\n\nfunc (e *ObjectTypeUndefinedError) Error() string {\n\treturn fmt.Sprintf(\"'%s' is an undefined object type\", e.ObjectType)\n}\n\nfunc (e *ObjectTypeUndefinedError) Unwrap() error {\n\treturn e.Err\n}\n\ntype RelationUndefinedError struct {\n\tObjectType string\n\tRelation   string\n\tErr        error\n}\n\nfunc (e *RelationUndefinedError) Error() string {\n\n\tif e.ObjectType != \"\" {\n\t\treturn fmt.Sprintf(\"'%s#%s' relation is undefined\", e.ObjectType, e.Relation)\n\t}\n\n\treturn fmt.Sprintf(\"'%s' relation is undefined\", e.Relation)\n}\n\nfunc (e *RelationUndefinedError) Unwrap() error {\n\treturn e.Err\n}\n\nfunc AssignableRelationError(objectType, relation string) error {\n\treturn fmt.Errorf(\"the assignable relation '%s' in object type '%s' must contain at least one relation type\", relation, objectType)\n}\n\nfunc NonAssignableRelationError(objectType, relation string) error {\n\treturn fmt.Errorf(\"the non-assignable relation '%s' in object type '%s' should not contain a relation type\", objectType, relation)\n}\n\nfunc InvalidRelationTypeError(objectType, relation, relatedObjectType, relatedRelation string) error {\n\trelationType := relatedObjectType\n\tif relatedRelation != \"\" {\n\t\trelationType = tuple.ToObjectRelationString(relatedObjectType, relatedRelation)\n\t}\n\n\treturn fmt.Errorf(\"the relation type '%s' on '%s' in object type '%s' is not valid\", relationType, relation, objectType)\n}\n\nfunc (t *TypeSystem) hasCycle(\n\tobjectType, relationName string,\n\trewrite *openfgav1.Userset,\n\tvisited map[string]struct{},\n) (bool, error) {\n\n\tvisited[fmt.Sprintf(\"%s#%s\", objectType, relationName)] = struct{}{}\n\n\tvisitedCopy := maps.Clone(visited)\n\n\tvar children []*openfgav1.Userset\n\n\tswitch rw := rewrite.Userset.(type) {\n\tcase *openfgav1.Userset_This, *openfgav1.Userset_TupleToUserset:\n\t\treturn false, nil\n\tcase *openfgav1.Userset_ComputedUserset:\n\t\trewrittenRelation := rw.ComputedUserset.Relation\n\n\t\tif _, ok := visited[fmt.Sprintf(\"%s#%s\", objectType, rewrittenRelation)]; ok {\n\t\t\treturn true, nil\n\t\t}\n\n\t\trewrittenRewrite, err := t.GetRelation(objectType, rewrittenRelation)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\n\t\treturn t.hasCycle(objectType, rewrittenRelation, rewrittenRewrite.GetRewrite(), visitedCopy)\n\tcase *openfgav1.Userset_Union:\n\t\tchildren = append(children, rw.Union.GetChild()...)\n\tcase *openfgav1.Userset_Intersection:\n\t\tchildren = append(children, rw.Intersection.GetChild()...)\n\tcase *openfgav1.Userset_Difference:\n\t\tchildren = append(children, rw.Difference.GetBase(), rw.Difference.GetSubtract())\n\t}\n\n\tfor _, child := range children {\n\n\t\thasCycle, err := t.hasCycle(objectType, relationName, child, visitedCopy)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\n\t\tif hasCycle {\n\t\t\treturn true, nil\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\n// HasCycle runs a cycle detection test on the provided `objectType#relation` to see if the relation\n// defines a rewrite rule that is self-referencing in any way (through computed relationships).\nfunc (t *TypeSystem) HasCycle(objectType, relationName string) (bool, error) {\n\tvisited := map[string]struct{}{}\n\n\trelation, err := t.GetRelation(objectType, relationName)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\treturn t.hasCycle(objectType, relationName, relation.GetRewrite(), visited)\n}\n\n// getAllTupleToUsersetsDefinitions returns a map where the key is the object type and the value\n// is another map where key=relationName, value=list of tuple to usersets declared in that relation\nfunc (t *TypeSystem) getAllTupleToUsersetsDefinitions() map[string]map[string][]*openfgav1.TupleToUserset {\n\tresponse := make(map[string]map[string][]*openfgav1.TupleToUserset, 0)\n\tfor typeName, typeDef := range t.typeDefinitions {\n\t\tresponse[typeName] = make(map[string][]*openfgav1.TupleToUserset, 0)\n\t\tfor relationName, relationDef := range typeDef.GetRelations() {\n\t\t\tttus := make([]*openfgav1.TupleToUserset, 0)\n\t\t\tresponse[typeName][relationName] = t.tupleToUsersetsDefinitions(relationDef, &ttus)\n\t\t}\n\t}\n\n\treturn response\n}\n\n// IsTuplesetRelation returns a boolean indicating if the provided relation is defined under a\n// TupleToUserset rewrite as a tupleset relation (i.e. the right hand side of a `X from Y`).\nfunc (t *TypeSystem) IsTuplesetRelation(objectType, relation string) (bool, error) {\n\n\t_, err := t.GetRelation(objectType, relation)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tfor _, ttuDefinitions := range t.getAllTupleToUsersetsDefinitions()[objectType] {\n\t\tfor _, ttuDef := range ttuDefinitions {\n\t\t\tif ttuDef.Tupleset.Relation == relation {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\nfunc (t *TypeSystem) tupleToUsersetsDefinitions(relationDef *openfgav1.Userset, resp *[]*openfgav1.TupleToUserset) []*openfgav1.TupleToUserset {\n\tif relationDef.GetTupleToUserset() != nil {\n\t\t*resp = append(*resp, relationDef.GetTupleToUserset())\n\t}\n\tif relationDef.GetUnion() != nil {\n\t\tfor _, child := range relationDef.GetUnion().GetChild() {\n\t\t\tt.tupleToUsersetsDefinitions(child, resp)\n\t\t}\n\t}\n\tif relationDef.GetIntersection() != nil {\n\t\tfor _, child := range relationDef.GetIntersection().GetChild() {\n\t\t\tt.tupleToUsersetsDefinitions(child, resp)\n\t\t}\n\t}\n\tif relationDef.GetDifference() != nil {\n\t\tt.tupleToUsersetsDefinitions(relationDef.GetDifference().GetBase(), resp)\n\t\tt.tupleToUsersetsDefinitions(relationDef.GetDifference().GetSubtract(), resp)\n\t}\n\treturn *resp\n}\n\n// WalkUsersetRewriteHandler is a userset rewrite handler that is applied to a node in a userset rewrite\n// tree. Implementations of the WalkUsersetRewriteHandler should return a non-nil value when the traversal\n// over the rewrite tree should terminate and nil if traversal should proceed to other nodes in the tree.\ntype WalkUsersetRewriteHandler func(rewrite *openfgav1.Userset) interface{}\n\n// WalkUsersetRewrite recursively walks the provided userset rewrite and invokes the provided WalkUsersetRewriteHandler\n// to each node in the userset rewrite tree until the first non-nil response is encountered.\nfunc WalkUsersetRewrite(rewrite *openfgav1.Userset, handler WalkUsersetRewriteHandler) (interface{}, error) {\n\n\tvar children []*openfgav1.Userset\n\n\tif result := handler(rewrite); result != nil {\n\t\treturn result, nil\n\t}\n\n\tswitch t := rewrite.Userset.(type) {\n\tcase *openfgav1.Userset_This:\n\t\treturn handler(rewrite), nil\n\tcase *openfgav1.Userset_ComputedUserset:\n\t\treturn handler(rewrite), nil\n\tcase *openfgav1.Userset_TupleToUserset:\n\t\treturn handler(rewrite), nil\n\tcase *openfgav1.Userset_Union:\n\t\tchildren = t.Union.GetChild()\n\tcase *openfgav1.Userset_Intersection:\n\t\tchildren = t.Intersection.GetChild()\n\tcase *openfgav1.Userset_Difference:\n\t\tchildren = append(children, t.Difference.GetBase(), t.Difference.GetSubtract())\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unexpected userset rewrite type encountered\")\n\t}\n\n\tfor _, child := range children {\n\t\tresult, err := WalkUsersetRewrite(child, handler)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif result != nil {\n\t\t\treturn result, nil\n\t\t}\n\t}\n\n\treturn nil, nil\n}\n", "package typesystem\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\tparser \"github.com/craigpastro/openfga-dsl-parser/v2\"\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestHasCycle(t *testing.T) {\n\n\ttests := []struct {\n\t\tname       string\n\t\tmodel      string\n\t\tobjectType string\n\t\trelation   string\n\t\texpected   bool\n\t}{\n\t\t{\n\t\t\tname: \"test_1\",\n\t\t\tmodel: `\n\t\t\ttype resource\n\t\t\t  relations\n\t\t\t    define x as y\n\t\t\t    define y as x\n\t\t\t`,\n\t\t\tobjectType: \"resource\",\n\t\t\trelation:   \"x\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"test_2\",\n\t\t\tmodel: `\n\t\t\ttype resource\n\t\t\t  relations\n\t\t\t    define x as y\n\t\t\t    define y as z\n\t\t\t\tdefine z as x\n\t\t\t`,\n\t\t\tobjectType: \"resource\",\n\t\t\trelation:   \"y\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"test_3\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype resource\n\t\t\t  relations\n\t\t\t    define x: [user] as self or y\n\t\t\t    define y: [user] as self or z\n\t\t\t\tdefine z: [user] as self or x\n\t\t\t`,\n\t\t\tobjectType: \"resource\",\n\t\t\trelation:   \"z\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"test_4\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype resource\n\t\t\t  relations\n\t\t\t    define x: [user] as self or y\n\t\t\t    define y: [user] as self or z\n\t\t\t\tdefine z: [user] as self or x\n\t\t\t`,\n\t\t\tobjectType: \"resource\",\n\t\t\trelation:   \"z\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"test_5\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype resource\n\t\t\t  relations\n\t\t\t\tdefine x: [user] as self but not y\n\t\t\t\tdefine y: [user] as self but not z\n\t\t\t\tdefine z: [user] as self or x\n\t\t\t`,\n\t\t\tobjectType: \"resource\",\n\t\t\trelation:   \"x\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"test_6\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t\tdefine member: [user] as self or memberA or memberB or memberC\n\t\t\t\tdefine memberA: [user] as self or member or memberB or memberC\n\t\t\t\tdefine memberB: [user] as self or member or memberA or memberC\n\t\t\t\tdefine memberC: [user] as self or member or memberA or memberB\n\t\t\t`,\n\t\t\tobjectType: \"group\",\n\t\t\trelation:   \"member\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"test_7\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype account\n\t\t\trelations\n\t\t\t\tdefine admin: [user] as self or member or super_admin or owner\n\t\t\t\tdefine member: [user] as self or owner or admin or super_admin\n\t\t\t\tdefine super_admin: [user] as self or admin or member or owner\n\t\t\t\tdefine owner: [user] as self\n\t\t\t`,\n\t\t\tobjectType: \"account\",\n\t\t\trelation:   \"member\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"test_8\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype account\n\t\t\trelations\n\t\t\t\tdefine admin: [user] as self or member or super_admin or owner\n\t\t\t\tdefine member: [user] as self or owner or admin or super_admin\n\t\t\t\tdefine super_admin: [user] as self or admin or member or owner\n\t\t\t\tdefine owner: [user] as self\n\t\t\t`,\n\t\t\tobjectType: \"account\",\n\t\t\trelation:   \"owner\",\n\t\t\texpected:   false,\n\t\t},\n\t\t{\n\t\t\tname: \"test_9\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t\tdefine editor: [user] as self\n\t\t\t\tdefine viewer: [document#viewer] as self or editor\n\t\t\t`,\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"viewer\",\n\t\t\texpected:   false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\ttypesys := New(&openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion:   SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: parser.MustParse(test.model),\n\t\t\t})\n\n\t\t\thasCycle, err := typesys.HasCycle(test.objectType, test.relation)\n\t\t\trequire.Equal(t, test.expected, hasCycle)\n\t\t\trequire.NoError(t, err)\n\t\t})\n\t}\n}\n\nfunc TestNewAndValidate(t *testing.T) {\n\n\ttests := []struct {\n\t\tname          string\n\t\tmodel         string\n\t\texpectedError error\n\t}{\n\t\t{\n\t\t\tname: \"direct_relationship_with_entrypoint\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user] as self\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tname: \"computed_relationship_with_entrypoint\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define editor: [user] as self\n\t\t\t    define viewer as editor\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tname: \"no_entrypoint_1\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define admin: [user] as self\n\t\t\t    define action1 as admin and action2 and action3\n\t\t\t    define action2 as admin and action1 and action3\n\t\t\t    define action3 as admin and action1 and action2\n\t\t\t`,\n\t\t\texpectedError: ErrNoEntryPointsLoop,\n\t\t},\n\t\t{\n\t\t\tname: \"no_entrypoint_2\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t\tdefine admin: [user] as self\n\t\t\t\tdefine action1 as admin but not action2\n\t\t\t\tdefine action2 as admin but not action3\n\t\t\t\tdefine action3 as admin but not action1\n\t\t\t`,\n\t\t\texpectedError: ErrNoEntryPointsLoop,\n\t\t},\n\t\t{\n\t\t\tname: \"no_entrypoint_3a\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [document#viewer] as self and editor\n\t\t\t    define editor: [user] as self\n\t\t\t`,\n\t\t\texpectedError: ErrNoEntrypoints,\n\t\t},\n\t\t{\n\t\t\tname: \"no_entrypoint_3b\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [document#viewer] as self but not editor\n\t\t\t    define editor: [user] as self\n\t\t\t`,\n\t\t\texpectedError: ErrNoEntrypoints,\n\t\t},\n\t\t{\n\t\t\tname: \"no_entrypoint_4\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define parent: [document] as self\n\t\t\t    define viewer as editor from parent\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t\tdefine editor as viewer\n\t\t\t    define viewer as editor from parent\n\t\t\t`,\n\t\t\texpectedError: ErrNoEntrypoints,\n\t\t},\n\t\t{\n\t\t\tname: \"self_referencing_type_restriction_with_entrypoint_1\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define restricted: [user] as self\n\t\t\t    define editor: [user] as self\n\t\t\t    define viewer: [document#viewer] as self or editor\n\t\t\t    define can_view as viewer but not restricted\n\t\t\t    define can_view_actual as can_view\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tname: \"self_referencing_type_restriction_with_entrypoint_2\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define editor: [user] as self\n\t\t\t    define viewer: [document#viewer] as self or editor\n\t\t\t`,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t_, err := NewAndValidate(context.Background(), &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion:   SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: parser.MustParse(test.model),\n\t\t\t})\n\t\t\trequire.ErrorIs(t, err, test.expectedError)\n\t\t})\n\t}\n}\n\nfunc TestSuccessfulRewriteValidations(t *testing.T) {\n\tvar tests = []struct {\n\t\tname  string\n\t\tmodel *openfgav1.AuthorizationModel\n\t}{\n\t\t{\n\t\t\tname: \"empty_relations\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"zero_length_relations_is_valid\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType:      \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"self_referencing_type_restriction_with_entrypoint\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define editor: [user] as self\n\t\t\t\t    define viewer: [document#viewer] as self or editor\n\t\t\t\t`),\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"intersection_may_contain_repeated_relations\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t\tdefine editor: [user] as self\n\t\t\t\t\tdefine viewer as editor and editor\n\t\t\t\t`),\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"exclusion_may_contain_repeated_relations\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t\tdefine editor: [user] as self\n\t\t\t\t\tdefine viewer as editor but not editor\n\t\t\t\t`),\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t_, err := NewAndValidate(context.Background(), test.model)\n\t\t\trequire.NoError(t, err)\n\t\t})\n\t}\n}\n\nfunc TestInvalidRewriteValidations(t *testing.T) {\n\tvar tests = []struct {\n\t\tname  string\n\t\tmodel *openfgav1.AuthorizationModel\n\t\terr   error\n\t}{\n\t\t{\n\t\t\tname: \"empty_rewrites\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrInvalidUsersetRewrite,\n\t\t},\n\t\t{\n\t\t\tname: \"duplicate_types_is_invalid\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType:      \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType:      \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrDuplicateTypes,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_self_reference_in_computedUserset\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{Relation: \"reader\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrInvalidUsersetRewrite,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_self_reference_in_union\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_Union{\n\t\t\t\t\t\t\t\t\tUnion: &openfgav1.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{Relation: \"reader\"},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrInvalidUsersetRewrite,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_self_reference_in_intersection\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_Intersection{\n\t\t\t\t\t\t\t\t\tIntersection: &openfgav1.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{Relation: \"reader\"},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrInvalidUsersetRewrite,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_self_reference_in_difference_base\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_Difference{\n\t\t\t\t\t\t\t\t\tDifference: &openfgav1.Difference{\n\t\t\t\t\t\t\t\t\t\tBase: &openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{Relation: \"reader\"},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tSubtract: &openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrInvalidUsersetRewrite,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_self_reference_in_difference_subtract\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_Difference{\n\t\t\t\t\t\t\t\t\tDifference: &openfgav1.Difference{\n\t\t\t\t\t\t\t\t\t\tBase: &openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tSubtract: &openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{Relation: \"reader\"},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrInvalidUsersetRewrite,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_computedUserset_to_relation_which_does_not_exist\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{Relation: \"writer\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_computedUserset_in_a_union\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_Union{\n\t\t\t\t\t\t\t\t\tUnion: &openfgav1.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{Relation: \"writer\"},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_computedUserset_in_a_intersection\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_Intersection{\n\t\t\t\t\t\t\t\t\tIntersection: &openfgav1.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{Relation: \"writer\"},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_computedUserset_in_a_difference_base\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_Difference{\n\t\t\t\t\t\t\t\t\tDifference: &openfgav1.Difference{\n\t\t\t\t\t\t\t\t\t\tBase: &openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{Relation: \"writer\"},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tSubtract: &openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_computedUserset_in_a_difference_subtract\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_Difference{\n\t\t\t\t\t\t\t\t\tDifference: &openfgav1.Difference{\n\t\t\t\t\t\t\t\t\t\tBase: &openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tSubtract: &openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{Relation: \"writer\"},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_tupleToUserset_where_tupleset_is_not_valid\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"group\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"member\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_Union{\n\t\t\t\t\t\t\t\t\tUnion: &openfgav1.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgav1.TupleToUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tTupleset: &openfgav1.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"notavalidrelation\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"member\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_relation:_tupleToUserset_where_computed_userset_is_not_valid\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype user\n\n\t\t\t\ttype document\n\t\t\t\t  relations\n\t\t\t\t    define reader as notavalidrelation from writer\n\t\t\t\t\tdefine writer: [user] as self\n\t\t\t\t`),\n\t\t\t},\n\t\t\terr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"Fails_If_Using_This_As_Relation_Name\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"this\": This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrReservedKeywords,\n\t\t},\n\t\t{\n\t\t\tname: \"Fails_If_Using_Self_As_Relation_Name\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"self\": This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrReservedKeywords,\n\t\t},\n\t\t{\n\t\t\tname: \"Fails_If_Using_This_As_Type_Name\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"this\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"viewer\": This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrReservedKeywords,\n\t\t},\n\t\t{\n\t\t\tname: \"Fails_If_Using_Self_As_Type_Name\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"self\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"viewer\": This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrReservedKeywords,\n\t\t},\n\t\t{\n\t\t\tname: \"Fails_If_Auth_Model_1.1_Has_A_Cycle_And_Only_One_Type\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: parser.MustParse(`\n\t\t\t\ttype folder\n\t\t\t\t  relations\n\t\t\t\t    define parent: [folder] as self\n\t\t\t\t\tdefine viewer as viewer from parent\n\t\t\t\t`),\n\t\t\t},\n\t\t\terr: ErrNoEntrypoints,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t_, err := NewAndValidate(context.Background(), test.model)\n\t\t\trequire.ErrorIs(t, err, test.err)\n\t\t})\n\t}\n}\nfunc TestSuccessfulRelationTypeRestrictionsValidations(t *testing.T) {\n\tvar tests = []struct {\n\t\tname  string\n\t\tmodel *openfgav1.AuthorizationModel\n\t}{\n\t\t{\n\t\t\tname: \"succeeds_on_a_valid_typeSystem_with_an_objectType_type\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {Userset: &openfgav1.Userset_This{}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"succeeds_on_a_valid_typeSystem_with_a_type_and_type#relation_type\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"group\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"admin\":  {Userset: &openfgav1.Userset_This{}},\n\t\t\t\t\t\t\t\"member\": {Userset: &openfgav1.Userset_This{}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"member\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {Userset: &openfgav1.Userset_This{}},\n\t\t\t\t\t\t\t\"writer\": {Userset: &openfgav1.Userset_This{}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"group\", \"member\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"group\", \"admin\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t_, err := NewAndValidate(context.Background(), test.model)\n\t\t\trequire.NoError(t, err)\n\t\t})\n\t}\n}\n\nfunc TestInvalidRelationTypeRestrictionsValidations(t *testing.T) {\n\tvar tests = []struct {\n\t\tname  string\n\t\tmodel *openfgav1.AuthorizationModel\n\t\terr   error\n\t}{\n\t\t{\n\t\t\tname: \"relational_type_which_does_not_exist\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {Userset: &openfgav1.Userset_This{}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"group\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: InvalidRelationTypeError(\"document\", \"reader\", \"group\", \"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"relation_type_of_form_type#relation_where_relation_doesn't_exist\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"group\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {Userset: &openfgav1.Userset_This{}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType:               \"group\",\n\t\t\t\t\t\t\t\t\t\t\tRelationOrWildcard: &openfgav1.RelationReference_Relation{Relation: \"admin\"},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: InvalidRelationTypeError(\"document\", \"reader\", \"group\", \"admin\"),\n\t\t},\n\t\t{\n\t\t\tname: \"assignable_relation_with_no_type:_this\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: AssignableRelationError(\"document\", \"reader\"),\n\t\t},\n\t\t{\n\t\t\tname: \"assignable_relation_with_no_type:_union\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_Union{\n\t\t\t\t\t\t\t\t\tUnion: &openfgav1.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: AssignableRelationError(\"document\", \"reader\"),\n\t\t},\n\t\t{\n\t\t\tname: \"assignable_relation_wit_no_type:_intersection\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_Intersection{\n\t\t\t\t\t\t\t\t\tIntersection: &openfgav1.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: AssignableRelationError(\"document\", \"reader\"),\n\t\t},\n\t\t{\n\t\t\tname: \"assignable_relation_with_no_type:_difference base\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_Difference{\n\t\t\t\t\t\t\t\t\tDifference: &openfgav1.Difference{\n\t\t\t\t\t\t\t\t\t\tBase: &openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tSubtract: &openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: AssignableRelationError(\"document\", \"reader\"),\n\t\t},\n\t\t{\n\t\t\tname: \"assignable_relation_with_no_type:_difference_subtract\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_Difference{\n\t\t\t\t\t\t\t\t\tDifference: &openfgav1.Difference{\n\t\t\t\t\t\t\t\t\t\tBase: &openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tSubtract: &openfgav1.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: AssignableRelationError(\"document\", \"reader\"),\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_relation_with_a_type\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgav1.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgav1.ObjectRelation{Relation: \"writer\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: NonAssignableRelationError(\"document\", \"reader\"),\n\t\t},\n\t\t{\n\t\t\tname: \"userset_specified_as_allowed_type_but_the_relation_is_used_in_a_TTU_rewrite\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"folder\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"member\": This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"member\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"parent\":   This(),\n\t\t\t\t\t\t\t\"can_view\": TupleToUserset(\"parent\", \"member\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"parent\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"folder\", \"member\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: InvalidRelationTypeError(\"document\", \"parent\", \"folder\", \"member\"),\n\t\t},\n\t\t{\n\t\t\tname: \"userset_specified_as_allowed_type_but_the_relation_is_used_in_a_TTU_rewrite_included_in_a_union\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"folder\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"parent\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"folder\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Union(TupleToUserset(\"parent\", \"viewer\"), This()),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"parent\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"folder\", \"parent\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"folder\", \"parent\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: InvalidRelationTypeError(\"document\", \"parent\", \"folder\", \"parent\"),\n\t\t},\n\t\t{\n\t\t\tname: \"WildcardNotAllowedInTheTuplesetPartOfTTU\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion: SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"folder\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"viewer\": This(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Union(This(), TupleToUserset(\"parent\", \"viewer\")),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMetadata: &openfgav1.Metadata{\n\t\t\t\t\t\t\tRelations: map[string]*openfgav1.RelationMetadata{\n\t\t\t\t\t\t\t\t\"parent\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\tWildcardRelationReference(\"folder\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgav1.RelationReference{\n\t\t\t\t\t\t\t\t\t\tDirectRelationReference(\"user\", \"\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: InvalidRelationTypeError(\"document\", \"parent\", \"folder\", \"\"),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t_, err := NewAndValidate(context.Background(), test.model)\n\t\t\trequire.EqualError(t, err, test.err.Error())\n\t\t})\n\t}\n}\n\nfunc TestRelationInvolvesIntersection(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tmodel       string\n\t\trr          *openfgav1.RelationReference\n\t\texpected    bool\n\t\texpectedErr error\n\t}{\n\t\t{\n\t\t\tname: \"indirect_computeduserset_through_ttu_containing_intersection\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define manage: [user] as self\n\t\t\t    define editor: [user] as self and manage\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define editor as editor from parent\n\t\t\t    define viewer as editor\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"ttu_relations_containing_intersection\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define editor: [user] as self\n\t\t\t    define viewer: [user] as self and editor\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer as viewer from parent\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"indirect_relations_containing_intersection\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define editor: [user] as self\n\t\t\t    define viewer: [user] as self and editor\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"undefined_type\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\t`,\n\t\t\trr:          DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected:    false,\n\t\t\texpectedErr: ErrObjectTypeUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"undefined_relation\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\t`,\n\t\t\trr:          DirectRelationReference(\"user\", \"viewer\"),\n\t\t\texpected:    false,\n\t\t\texpectedErr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_indirect_type_restriction_involving_intersection\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype org\n\t\t\t  relations\n\t\t\t    define allowed: [user] as self\n\t\t\t    define dept: [group] as self\n\t\t\t    define dept_member as member from dept\n\t\t\t    define dept_allowed_member as dept_member and allowed\n\n\t\t\ttype resource\n\t\t\t  relations\n\t\t\t    define reader: [user] as self or writer\n\t\t\t    define writer: [org#dept_allowed_member] as self\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"resource\", \"reader\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"indirect_relationship_through_type_restriction\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define allowed: [user] as self\n\t\t\t    define editor: [user] as self and allowed\n\t\t\t    define viewer: [document#editor] as self\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"github_model\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype organization\n\t\t\t  relations\n\t\t\t    define member: [user] as self or owner\n\t\t\t\tdefine owner: [user] as self\n\t\t\t\tdefine repo_admin: [user, organization#member] as self\n\t\t\t\tdefine repo_reader: [user, organization#member] as self\n\t\t\t\tdefine repo_writer: [user, organization#member] as self\n\n\t\t\ttype team\n\t\t\t  relations\n\t\t\t    define member: [user, team#member] as self\n\n\t\t\ttype repo\n\t\t\t  relations\n\t\t\t    define admin: [user, team#member] as self or repo_admin from owner\n\t\t\t\tdefine maintainer: [user, team#member] as self or admin\n\t\t\t\tdefine owner: [organization] as self\n\t\t\t\tdefine reader: [user, team#member] as self or triager or repo_reader from owner\n\t\t\t\tdefine triager: [user, team#member] as self or writer\n\t\t\t\tdefine writer: [user, team#member] as self or maintainer or repo_writer from owner\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"repo\", \"admin\"),\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname: \"github_model\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype organization\n\t\t\t  relations\n\t\t\t    define member: [user] as self or owner\n\t\t\t\tdefine owner: [user] as self\n\t\t\t\tdefine repo_admin: [user, organization#member] as self\n\t\t\t\tdefine repo_reader: [user, organization#member] as self\n\t\t\t\tdefine repo_writer: [user, organization#member] as self\n\n\t\t\ttype team\n\t\t\t  relations\n\t\t\t    define member: [user, team#member] as self\n\n\t\t\ttype repo\n\t\t\t  relations\n\t\t\t    define admin: [user, team#member] as self or repo_admin from owner\n\t\t\t\tdefine maintainer: [user, team#member] as self or admin\n\t\t\t\tdefine owner: [organization] as self\n\t\t\t\tdefine reader: [user, team#member] as self or triager or repo_reader from owner\n\t\t\t\tdefine triager: [user, team#member] as self or writer\n\t\t\t\tdefine writer: [user, team#member] as self or maintainer or repo_writer from owner\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"repo\", \"admin\"),\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname: \"direct_relations_related_to_each_other\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype example\n\t\t\t  relations\n\t\t\t    define editor: [example#viewer] as self\n\t\t\t    define viewer: [example#editor] as self\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"example\", \"editor\"),\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname: \"cyclical_evaluation_of_tupleset\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype node\n\t\t\t  relations\n\t\t\t    define parent: [node] as self\n\t\t\t    define editor: [user] as self or editor from parent\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"node\", \"editor\"),\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested_intersection_1\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define allowed: [user] as self\n\t\t\t    define viewer: [user] as self and allowed\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t\tdefine viewer as viewer from parent\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\ttypedefs := parser.MustParse(test.model)\n\n\t\t\ttypesys := New(&openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: typedefs,\n\t\t\t})\n\n\t\t\tobjectType := test.rr.GetType()\n\t\t\trelationStr := test.rr.GetRelation()\n\n\t\t\tactual, err := typesys.RelationInvolvesIntersection(objectType, relationStr)\n\t\t\trequire.ErrorIs(t, err, test.expectedErr)\n\t\t\trequire.Equal(t, test.expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestRelationInvolvesExclusion(t *testing.T) {\n\n\ttests := []struct {\n\t\tname        string\n\t\tmodel       string\n\t\trr          *openfgav1.RelationReference\n\t\texpected    bool\n\t\texpectedErr error\n\t}{\n\t\t{\n\t\t\tname: \"indirect_computed_userset_through_ttu_containing_exclusion\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define restricted: [user] as self\n\t\t\t    define editor: [user] as self but not restricted\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define editor as editor from parent\n\t\t\t    define viewer as editor\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"ttu_relations_containing_exclusion\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define restricted: [user] as self\n\t\t\t    define viewer: [user] as self but not restricted\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define parent: [folder] as self\n\t\t\t    define viewer as viewer from parent\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"indirect_relations_containing_exclusion\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define restricted: [user] as self\n\t\t\t    define editor: [user] as self but not restricted\n\t\t\t    define viewer as editor\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"undefined_type\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\t`,\n\t\t\trr:          DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected:    false,\n\t\t\texpectedErr: ErrObjectTypeUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"undefined_relation\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\t`,\n\t\t\trr:          DirectRelationReference(\"user\", \"viewer\"),\n\t\t\texpected:    false,\n\t\t\texpectedErr: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_indirect_type_restriction_involving_exclusion\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype org\n\t\t\t  relations\n\t\t\t    define removed: [user] as self\n\t\t\t    define dept: [group] as self\n\t\t\t    define dept_member as member from dept\n\t\t\t    define dept_allowed_member as dept_member but not removed\n\n\t\t\ttype resource\n\t\t\t  relations\n\t\t\t    define reader: [user] as self or writer\n\t\t\t    define writer: [org#dept_allowed_member] as self\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"resource\", \"reader\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"indirect_relationship_through_type_restriction\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define restricted: [user] as self\n\t\t\t    define editor: [user] as self but not restricted\n\t\t\t    define viewer: [document#editor] as self\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"document\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"direct_relations_related_to_each_other\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype example\n\t\t\t  relations\n\t\t\t    define editor: [example#viewer] as self\n\t\t\t    define viewer: [example#editor] as self\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"example\", \"editor\"),\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname: \"cyclical_evaluation_of_tupleset\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype node\n\t\t\t  relations\n\t\t\t    define parent: [node] as self\n\t\t\t    define editor: [user] as self or editor from parent\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"node\", \"editor\"),\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\ttypedefs := parser.MustParse(test.model)\n\n\t\t\ttypesys := New(&openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: typedefs,\n\t\t\t})\n\n\t\t\tobjectType := test.rr.GetType()\n\t\t\trelationStr := test.rr.GetRelation()\n\n\t\t\tactual, err := typesys.RelationInvolvesExclusion(objectType, relationStr)\n\t\t\trequire.ErrorIs(t, err, test.expectedErr)\n\t\t\trequire.Equal(t, test.expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestIsTuplesetRelation(t *testing.T) {\n\n\ttests := []struct {\n\t\tname          string\n\t\tmodel         *openfgav1.AuthorizationModel\n\t\tobjectType    string\n\t\trelation      string\n\t\texpected      bool\n\t\texpectedError error\n\t}{\n\t\t{\n\t\t\tname:          \"undefined_object_type_returns_error\",\n\t\t\tobjectType:    \"document\",\n\t\t\trelation:      \"viewer\",\n\t\t\texpected:      false,\n\t\t\texpectedError: ErrObjectTypeUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"undefined_relation_returns_error\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType:    \"document\",\n\t\t\trelation:      \"viewer\",\n\t\t\texpected:      false,\n\t\t\texpectedError: ErrRelationUndefined,\n\t\t},\n\t\t{\n\t\t\tname: \"direct_tupleset_relation\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": TupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"parent\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"tupleset_relation_under_union\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Union(\n\t\t\t\t\t\t\t\tThis(),\n\t\t\t\t\t\t\t\tTupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"parent\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"tupleset_relation_under_intersection\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Intersection(\n\t\t\t\t\t\t\t\tThis(),\n\t\t\t\t\t\t\t\tTupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"parent\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"tupleset_relation_under_exclusion\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Difference(\n\t\t\t\t\t\t\t\tThis(),\n\t\t\t\t\t\t\t\tTupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"parent\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"tupleset_relation_under_nested_union\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Intersection(\n\t\t\t\t\t\t\t\tThis(),\n\t\t\t\t\t\t\t\tUnion(TupleToUserset(\"parent\", \"viewer\")),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"parent\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"tupleset_relation_under_nested_intersection\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Union(\n\t\t\t\t\t\t\t\tThis(),\n\t\t\t\t\t\t\t\tIntersection(TupleToUserset(\"parent\", \"viewer\")),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"parent\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"tupleset_relation_under_nested_exclusion\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": Union(\n\t\t\t\t\t\t\t\tThis(),\n\t\t\t\t\t\t\t\tDifference(This(), TupleToUserset(\"parent\", \"viewer\")),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"parent\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname: \"not_a_tupleset_relation\",\n\t\t\tmodel: &openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\t\t\"parent\": This(),\n\t\t\t\t\t\t\t\"viewer\": TupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"viewer\",\n\t\t\texpected:   false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ttypesys := New(test.model)\n\n\t\t\tactual, err := typesys.IsTuplesetRelation(test.objectType, test.relation)\n\t\t\trequire.ErrorIs(t, err, test.expectedError)\n\t\t\trequire.Equal(t, test.expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestIsDirectlyRelated(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tmodel  string\n\t\ttarget *openfgav1.RelationReference\n\t\tsource *openfgav1.RelationReference\n\t\tresult bool\n\t}{\n\t\t{\n\t\t\tname: \"wildcard_and_wildcard\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user:*] as self\n\t\t\t`,\n\t\t\ttarget: DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tsource: WildcardRelationReference(\"user\"),\n\t\t\tresult: true,\n\t\t},\n\t\t{\n\t\t\tname: \"wildcard_and_direct\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user:*] as self\n\t\t\t`,\n\t\t\ttarget: DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tsource: DirectRelationReference(\"user\", \"\"),\n\t\t\tresult: false,\n\t\t},\n\t\t{\n\t\t\tname: \"direct_and_wildcard\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\t\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user] as self\n\t\t\t`,\n\t\t\ttarget: DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tsource: WildcardRelationReference(\"user\"),\n\t\t\tresult: false,\n\t\t},\n\t\t{\n\t\t\tname: \"direct_type\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\t\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user] as self\n\t\t\t`,\n\t\t\ttarget: DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tsource: DirectRelationReference(\"user\", \"\"),\n\t\t\tresult: true,\n\t\t},\n\t\t{\n\t\t\tname: \"relation_not_related\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\t  relations\n\t\t\t    define manager: [user] as self\n\t\t\t\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user] as self\n\t\t\t`,\n\t\t\ttarget: DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tsource: DirectRelationReference(\"user\", \"manager\"),\n\t\t\tresult: false,\n\t\t},\n\t\t{\n\t\t\tname: \"direct_and_userset\",\n\t\t\tmodel: `\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [group#member] as self\n\t\t\t\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttarget: DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tsource: DirectRelationReference(\"group\", \"member\"),\n\t\t\tresult: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\ttypedefs := parser.MustParse(test.model)\n\t\t\ttypesys := New(&openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion:   SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: typedefs,\n\t\t\t})\n\n\t\t\tok, err := typesys.IsDirectlyRelated(test.target, test.source)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, test.result, ok)\n\t\t})\n\t}\n}\n\nfunc TestIsPubliclyAssignable(t *testing.T) {\n\ttests := []struct {\n\t\tname       string\n\t\tmodel      string\n\t\ttarget     *openfgav1.RelationReference\n\t\tobjectType string\n\t\tresult     bool\n\t}{\n\t\t{\n\t\t\tname: \"1\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user:*] as self\n\t\t\t`,\n\t\t\ttarget:     DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tobjectType: \"user\",\n\t\t\tresult:     true,\n\t\t},\n\t\t{\n\t\t\tname: \"2\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [user] as self\n\t\t\t`,\n\t\t\ttarget:     DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tobjectType: \"user\",\n\t\t\tresult:     false,\n\t\t},\n\t\t{\n\t\t\tname: \"3\",\n\t\t\tmodel: `\n\t\t\ttype user\n\t\t\ttype employee\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [employee:*] as self\n\t\t\t`,\n\t\t\ttarget:     DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tobjectType: \"user\",\n\t\t\tresult:     false,\n\t\t},\n\t\t{\n\t\t\tname: \"4\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype group\n\t\t\t  relations\n\t\t\t    define member: [user:*] as self\n\n\t\t\ttype document\n\t\t\t  relations\n\t\t\t    define viewer: [group#member] as self\n\t\t\t`,\n\t\t\ttarget:     DirectRelationReference(\"document\", \"viewer\"),\n\t\t\tobjectType: \"user\",\n\t\t\tresult:     false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\ttypedefs := parser.MustParse(test.model)\n\t\t\ttypesys := New(&openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion:   SchemaVersion1_1,\n\t\t\t\tTypeDefinitions: typedefs,\n\t\t\t})\n\n\t\t\tok, err := typesys.IsPubliclyAssignable(test.target, test.objectType)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, ok, test.result)\n\t\t})\n\t}\n}\n\nfunc TestRewriteContainsExclusion(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tmodel    string\n\t\trr       *openfgav1.RelationReference\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname: \"simple_exclusion\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define restricted: [user] as self\n\t\t\t    define editor: [user] as self\n\t\t\t    define viewer: [user] as (self or editor) but not restricted\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"folder\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\ttypedefs := parser.MustParse(test.model)\n\n\t\t\ttypesys := New(&openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: typedefs,\n\t\t\t})\n\n\t\t\trel, err := typesys.GetRelation(test.rr.GetType(), test.rr.GetRelation())\n\t\t\trequire.NoError(t, err)\n\n\t\t\tactual := RewriteContainsExclusion(rel.GetRewrite())\n\t\t\trequire.Equal(t, test.expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestRewriteContainsIntersection(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tmodel    string\n\t\trr       *openfgav1.RelationReference\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname: \"simple_intersection\",\n\t\t\tmodel: `\n\t\t\ttype user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define allowed: [user] as self\n\t\t\t    define editor: [user] as self\n\t\t\t    define viewer: [user] as (self or editor) and allowed\n\t\t\t`,\n\t\t\trr:       DirectRelationReference(\"folder\", \"viewer\"),\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\ttypedefs := parser.MustParse(test.model)\n\n\t\t\ttypesys := New(&openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: typedefs,\n\t\t\t})\n\n\t\t\trel, err := typesys.GetRelation(test.rr.GetType(), test.rr.GetRelation())\n\t\t\trequire.NoError(t, err)\n\n\t\t\tactual := RewriteContainsIntersection(rel.GetRewrite())\n\t\t\trequire.Equal(t, test.expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestGetRelationReferenceAsString(t *testing.T) {\n\trequire.Equal(t, \"\", GetRelationReferenceAsString(nil))\n\trequire.Equal(t, \"team#member\", GetRelationReferenceAsString(DirectRelationReference(\"team\", \"member\")))\n\trequire.Equal(t, \"team:*\", GetRelationReferenceAsString(WildcardRelationReference(\"team\")))\n}\n\nfunc TestDirectlyRelatedUsersets(t *testing.T) {\n\ttests := []struct {\n\t\tname       string\n\t\tmodel      string\n\t\tobjectType string\n\t\trelation   string\n\t\texpected   []*openfgav1.RelationReference\n\t}{\n\t\t{\n\t\t\tname: \"only_direct_relation\",\n\t\t\tmodel: `type user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define allowed: [user] as self`,\n\t\t\tobjectType: \"folder\",\n\t\t\trelation:   \"allowed\",\n\t\t\texpected:   nil,\n\t\t},\n\t\t{\n\t\t\tname: \"with_public_relation\",\n\t\t\tmodel: `type user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define allowed: [user, user:*] as self`,\n\t\t\tobjectType: \"folder\",\n\t\t\trelation:   \"allowed\",\n\t\t\texpected: []*openfgav1.RelationReference{\n\t\t\t\tWildcardRelationReference(\"user\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"with_ttu_relation\",\n\t\t\tmodel: `type user\n            type group\n              relations\n                define member: [user] as self\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define allowed: [group#member] as self`,\n\t\t\tobjectType: \"folder\",\n\t\t\trelation:   \"allowed\",\n\t\t\texpected: []*openfgav1.RelationReference{\n\t\t\t\tDirectRelationReference(\"group\", \"member\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"mix_direct_and_public_relation\",\n\t\t\tmodel: `type user\n            type group\n              relations\n                define member: [user] as self\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define allowed: [group#member, user] as self`,\n\t\t\tobjectType: \"folder\",\n\t\t\trelation:   \"allowed\",\n\t\t\texpected: []*openfgav1.RelationReference{\n\t\t\t\tDirectRelationReference(\"group\", \"member\"),\n\t\t\t},\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\ttypedefs := parser.MustParse(test.model)\n\n\t\t\ttypesys := New(&openfgav1.AuthorizationModel{\n\t\t\t\tTypeDefinitions: typedefs,\n\t\t\t})\n\t\t\tresult, err := typesys.DirectlyRelatedUsersets(test.objectType, test.relation)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, test.expected, result)\n\t\t})\n\t}\n}\n\nfunc TestHasTypeInfo(t *testing.T) {\n\ttests := []struct {\n\t\tname       string\n\t\tschema     string\n\t\tmodel      string\n\t\tobjectType string\n\t\trelation   string\n\t\texpected   bool\n\t}{\n\t\t{\n\t\t\tname:   \"has_type_info_true\",\n\t\t\tschema: SchemaVersion1_1,\n\t\t\tmodel: `type user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define allowed: [user] as self`,\n\t\t\tobjectType: \"folder\",\n\t\t\trelation:   \"allowed\",\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"has_type_info_false\",\n\t\t\tschema: SchemaVersion1_0,\n\t\t\tmodel: `type user\n\n\t\t\ttype folder\n\t\t\t  relations\n\t\t\t    define allowed as self`,\n\t\t\tobjectType: \"folder\",\n\t\t\trelation:   \"allowed\",\n\t\t\texpected:   false,\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ttypesys := New(&openfgav1.AuthorizationModel{\n\t\t\t\tSchemaVersion:   test.schema,\n\t\t\t\tTypeDefinitions: parser.MustParse(test.model),\n\t\t\t})\n\t\t\tresult, err := typesys.HasTypeInfo(test.objectType, test.relation)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, test.expected, result)\n\t\t})\n\t}\n}\n"], "filenames": ["CHANGELOG.md", "internal/graph/check.go", "internal/graph/check_test.go", "pkg/server/commands/list_objects.go", "pkg/server/commands/reverseexpand/reverse_expand.go", "pkg/server/server.go", "pkg/server/server_test.go", "pkg/server/test/reverse_expand.go", "pkg/server/test/write_authzmodel.go", "pkg/typesystem/typesystem.go", "pkg/typesystem/typesystem_test.go"], "buggy_code_start_loc": [9, 18, 324, 236, 13, 589, 559, 10, 5, 895, 10], "buggy_code_end_loc": [630, 734, 324, 358, 213, 590, 810, 361, 441, 1197, 10], "fixing_code_start_loc": [10, 19, 325, 237, 12, 589, 559, 11, 4, 896, 11], "fixing_code_end_loc": [653, 778, 423, 370, 212, 590, 681, 361, 459, 1275, 169], "type": "CWE-835", "message": "OpenFGA is an authorization/permission engine built for developers and inspired by Google Zanzibar. OpenFGA is vulnerable to a denial of service attack when certain Check calls are executed against authorization models that contain circular relationship definitions. When the call is made, it's possible for the server to exhaust resources and die. Users are advised to upgrade to v1.3.2 and update any offending models. There are no known workarounds for this vulnerability. Note that for models which contained cycles or a relation definition that has the relation itself in its evaluation path, checks and queries that require evaluation will no longer be evaluated on v1.3.2+ and will return errors instead. Users who do not have cyclic models are unaffected.", "other": {"cve": {"id": "CVE-2023-43645", "sourceIdentifier": "security-advisories@github.com", "published": "2023-09-27T15:19:34.330", "lastModified": "2023-10-02T16:41:36.527", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OpenFGA is an authorization/permission engine built for developers and inspired by Google Zanzibar. OpenFGA is vulnerable to a denial of service attack when certain Check calls are executed against authorization models that contain circular relationship definitions. When the call is made, it's possible for the server to exhaust resources and die. Users are advised to upgrade to v1.3.2 and update any offending models. There are no known workarounds for this vulnerability. Note that for models which contained cycles or a relation definition that has the relation itself in its evaluation path, checks and queries that require evaluation will no longer be evaluated on v1.3.2+ and will return errors instead. Users who do not have cyclic models are unaffected."}, {"lang": "es", "value": "OpenFGA es un motor de autorizaci\u00f3n/permisos creado para desarrolladores e inspirado en Google Zanzibar. OpenFGA es vulnerable a un ataque de denegaci\u00f3n de servicio cuando ciertas llamadas de verificaci\u00f3n se ejecutan contra modelos de autorizaci\u00f3n que contienen definiciones de relaciones circulares. Cuando se realiza la llamada, es posible que el servidor agote los recursos y muera. Se recomienda a los usuarios que actualicen a la versi\u00f3n 1.3.2 y actualicen cualquier modelo infractor. No se conocen workarounds para esta vulnerabilidad. Tenga en cuenta que para los modelos que contienen ciclos o una definici\u00f3n de relaci\u00f3n que tiene la relaci\u00f3n misma en su ruta de evaluaci\u00f3n, las comprobaciones y consultas que requieren evaluaci\u00f3n ya no se evaluar\u00e1n en la versi\u00f3n 1.3.2+ y, en su lugar, devolver\u00e1n errores. Los usuarios que no tienen modelos c\u00edclicos no se ven afectados."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openfga:openfga:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.3.2", "matchCriteriaId": "96CAB7D1-0960-4345-AE65-6BCC577FAA24"}]}]}], "references": [{"url": "https://github.com/openfga/openfga/commit/725296025fd81227c89525808652c6acd4a605f6", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/openfga/openfga/security/advisories/GHSA-2hm9-h873-pgqh", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/openfga/openfga/commit/725296025fd81227c89525808652c6acd4a605f6"}}