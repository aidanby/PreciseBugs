{"buggy_code": ["// Copyright 2018-2023 the Deno authors. All rights reserved. MIT license.\nconst core = globalThis.Deno.core;\nconst primordials = globalThis.__bootstrap.primordials;\nconst { BadResourcePrototype, InterruptedPrototype, ops } = core;\nimport * as webidl from \"internal:deno_webidl/00_webidl.js\";\nimport { InnerBody } from \"internal:deno_fetch/22_body.js\";\nimport { Event, setEventTargetData } from \"internal:deno_web/02_event.js\";\nimport { BlobPrototype } from \"internal:deno_web/09_file.js\";\nimport {\n  fromInnerResponse,\n  newInnerResponse,\n  ResponsePrototype,\n  toInnerResponse,\n} from \"internal:deno_fetch/23_response.js\";\nimport {\n  _flash,\n  fromInnerRequest,\n  newInnerRequest,\n} from \"internal:deno_fetch/23_request.js\";\nimport * as abortSignal from \"internal:deno_web/03_abort_signal.js\";\nimport {\n  _eventLoop,\n  _idleTimeoutDuration,\n  _idleTimeoutTimeout,\n  _protocol,\n  _readyState,\n  _rid,\n  _server,\n  _serverHandleIdleTimeout,\n  WebSocket,\n} from \"internal:deno_websocket/01_websocket.js\";\nimport { TcpConn, UnixConn } from \"internal:deno_net/01_net.js\";\nimport { TlsConn } from \"internal:deno_net/02_tls.js\";\nimport {\n  Deferred,\n  getReadableStreamResourceBacking,\n  readableStreamClose,\n  readableStreamForRid,\n  ReadableStreamPrototype,\n} from \"internal:deno_web/06_streams.js\";\nconst {\n  ArrayPrototypeIncludes,\n  ArrayPrototypePush,\n  ArrayPrototypeSome,\n  Error,\n  ObjectPrototypeIsPrototypeOf,\n  SafeSetIterator,\n  Set,\n  SetPrototypeAdd,\n  SetPrototypeDelete,\n  StringPrototypeIncludes,\n  StringPrototypeToLowerCase,\n  StringPrototypeSplit,\n  Symbol,\n  SymbolAsyncIterator,\n  TypeError,\n  Uint8Array,\n  Uint8ArrayPrototype,\n} = primordials;\n\nconst connErrorSymbol = Symbol(\"connError\");\nconst _deferred = Symbol(\"upgradeHttpDeferred\");\n\nclass HttpConn {\n  #rid = 0;\n  #closed = false;\n  #remoteAddr;\n  #localAddr;\n\n  // This set holds resource ids of resources\n  // that were created during lifecycle of this request.\n  // When the connection is closed these resources should be closed\n  // as well.\n  managedResources = new Set();\n\n  constructor(rid, remoteAddr, localAddr) {\n    this.#rid = rid;\n    this.#remoteAddr = remoteAddr;\n    this.#localAddr = localAddr;\n  }\n\n  /** @returns {number} */\n  get rid() {\n    return this.#rid;\n  }\n\n  /** @returns {Promise<RequestEvent | null>} */\n  async nextRequest() {\n    let nextRequest;\n    try {\n      nextRequest = await core.opAsync(\"op_http_accept\", this.#rid);\n    } catch (error) {\n      this.close();\n      // A connection error seen here would cause disrupted responses to throw\n      // a generic `BadResource` error. Instead store this error and replace\n      // those with it.\n      this[connErrorSymbol] = error;\n      if (\n        ObjectPrototypeIsPrototypeOf(BadResourcePrototype, error) ||\n        ObjectPrototypeIsPrototypeOf(InterruptedPrototype, error) ||\n        StringPrototypeIncludes(error.message, \"connection closed\")\n      ) {\n        return null;\n      }\n      throw error;\n    }\n    if (nextRequest == null) {\n      // Work-around for servers (deno_std/http in particular) that call\n      // `nextRequest()` before upgrading a previous request which has a\n      // `connection: upgrade` header.\n      await null;\n\n      this.close();\n      return null;\n    }\n\n    const { 0: streamRid, 1: method, 2: url } = nextRequest;\n    SetPrototypeAdd(this.managedResources, streamRid);\n\n    /** @type {ReadableStream<Uint8Array> | undefined} */\n    let body = null;\n    // There might be a body, but we don't expose it for GET/HEAD requests.\n    // It will be closed automatically once the request has been handled and\n    // the response has been sent.\n    if (method !== \"GET\" && method !== \"HEAD\") {\n      body = readableStreamForRid(streamRid, false);\n    }\n\n    const innerRequest = newInnerRequest(\n      () => method,\n      url,\n      () => ops.op_http_headers(streamRid),\n      body !== null ? new InnerBody(body) : null,\n      false,\n    );\n    const signal = abortSignal.newSignal();\n    const request = fromInnerRequest(\n      innerRequest,\n      signal,\n      \"immutable\",\n      false,\n    );\n\n    const respondWith = createRespondWith(\n      this,\n      streamRid,\n      request,\n      this.#remoteAddr,\n      this.#localAddr,\n    );\n\n    return { request, respondWith };\n  }\n\n  /** @returns {void} */\n  close() {\n    if (!this.#closed) {\n      this.#closed = true;\n      core.close(this.#rid);\n      for (const rid of new SafeSetIterator(this.managedResources)) {\n        SetPrototypeDelete(this.managedResources, rid);\n        core.close(rid);\n      }\n    }\n  }\n\n  [SymbolAsyncIterator]() {\n    // deno-lint-ignore no-this-alias\n    const httpConn = this;\n    return {\n      async next() {\n        const reqEvt = await httpConn.nextRequest();\n        // Change with caution, current form avoids a v8 deopt\n        return { value: reqEvt ?? undefined, done: reqEvt === null };\n      },\n    };\n  }\n}\n\nfunction createRespondWith(\n  httpConn,\n  streamRid,\n  request,\n  remoteAddr,\n  localAddr,\n) {\n  return async function respondWith(resp) {\n    try {\n      resp = await resp;\n      if (!(ObjectPrototypeIsPrototypeOf(ResponsePrototype, resp))) {\n        throw new TypeError(\n          \"First argument to respondWith must be a Response or a promise resolving to a Response.\",\n        );\n      }\n\n      const innerResp = toInnerResponse(resp);\n\n      // If response body length is known, it will be sent synchronously in a\n      // single op, in other case a \"response body\" resource will be created and\n      // we'll be streaming it.\n      /** @type {ReadableStream<Uint8Array> | Uint8Array | null} */\n      let respBody = null;\n      if (innerResp.body !== null) {\n        if (innerResp.body.unusable()) {\n          throw new TypeError(\"Body is unusable.\");\n        }\n        if (\n          ObjectPrototypeIsPrototypeOf(\n            ReadableStreamPrototype,\n            innerResp.body.streamOrStatic,\n          )\n        ) {\n          if (\n            innerResp.body.length === null ||\n            ObjectPrototypeIsPrototypeOf(\n              BlobPrototype,\n              innerResp.body.source,\n            )\n          ) {\n            respBody = innerResp.body.stream;\n          } else {\n            const reader = innerResp.body.stream.getReader();\n            const r1 = await reader.read();\n            if (r1.done) {\n              respBody = new Uint8Array(0);\n            } else {\n              respBody = r1.value;\n              const r2 = await reader.read();\n              if (!r2.done) throw new TypeError(\"Unreachable\");\n            }\n          }\n        } else {\n          innerResp.body.streamOrStatic.consumed = true;\n          respBody = innerResp.body.streamOrStatic.body;\n        }\n      } else {\n        respBody = new Uint8Array(0);\n      }\n      const isStreamingResponseBody = !(\n        typeof respBody === \"string\" ||\n        ObjectPrototypeIsPrototypeOf(Uint8ArrayPrototype, respBody)\n      );\n      try {\n        await core.opAsync(\n          \"op_http_write_headers\",\n          streamRid,\n          innerResp.status ?? 200,\n          innerResp.headerList,\n          isStreamingResponseBody ? null : respBody,\n        );\n      } catch (error) {\n        const connError = httpConn[connErrorSymbol];\n        if (\n          ObjectPrototypeIsPrototypeOf(BadResourcePrototype, error) &&\n          connError != null\n        ) {\n          // deno-lint-ignore no-ex-assign\n          error = new connError.constructor(connError.message);\n        }\n        if (\n          respBody !== null &&\n          ObjectPrototypeIsPrototypeOf(ReadableStreamPrototype, respBody)\n        ) {\n          await respBody.cancel(error);\n        }\n        throw error;\n      }\n\n      if (isStreamingResponseBody) {\n        let success = false;\n        if (\n          respBody === null ||\n          !ObjectPrototypeIsPrototypeOf(ReadableStreamPrototype, respBody)\n        ) {\n          throw new TypeError(\"Unreachable\");\n        }\n        const resourceBacking = getReadableStreamResourceBacking(respBody);\n        let reader;\n        if (resourceBacking) {\n          if (respBody.locked) {\n            throw new TypeError(\"ReadableStream is locked.\");\n          }\n          reader = respBody.getReader(); // Aquire JS lock.\n          try {\n            await core.opAsync(\n              \"op_http_write_resource\",\n              streamRid,\n              resourceBacking.rid,\n            );\n            if (resourceBacking.autoClose) core.tryClose(resourceBacking.rid);\n            readableStreamClose(respBody); // Release JS lock.\n            success = true;\n          } catch (error) {\n            const connError = httpConn[connErrorSymbol];\n            if (\n              ObjectPrototypeIsPrototypeOf(BadResourcePrototype, error) &&\n              connError != null\n            ) {\n              // deno-lint-ignore no-ex-assign\n              error = new connError.constructor(connError.message);\n            }\n            await reader.cancel(error);\n            throw error;\n          }\n        } else {\n          reader = respBody.getReader();\n          while (true) {\n            const { value, done } = await reader.read();\n            if (done) break;\n            if (!ObjectPrototypeIsPrototypeOf(Uint8ArrayPrototype, value)) {\n              await reader.cancel(new TypeError(\"Value not a Uint8Array\"));\n              break;\n            }\n            try {\n              await core.opAsync(\"op_http_write\", streamRid, value);\n            } catch (error) {\n              const connError = httpConn[connErrorSymbol];\n              if (\n                ObjectPrototypeIsPrototypeOf(BadResourcePrototype, error) &&\n                connError != null\n              ) {\n                // deno-lint-ignore no-ex-assign\n                error = new connError.constructor(connError.message);\n              }\n              await reader.cancel(error);\n              throw error;\n            }\n          }\n          success = true;\n        }\n\n        if (success) {\n          try {\n            await core.opAsync(\"op_http_shutdown\", streamRid);\n          } catch (error) {\n            await reader.cancel(error);\n            throw error;\n          }\n        }\n      }\n\n      const deferred = request[_deferred];\n      if (deferred) {\n        const res = await core.opAsync(\"op_http_upgrade\", streamRid);\n        let conn;\n        if (res.connType === \"tcp\") {\n          conn = new TcpConn(res.connRid, remoteAddr, localAddr);\n        } else if (res.connType === \"tls\") {\n          conn = new TlsConn(res.connRid, remoteAddr, localAddr);\n        } else if (res.connType === \"unix\") {\n          conn = new UnixConn(res.connRid, remoteAddr, localAddr);\n        } else {\n          throw new Error(\"unreachable\");\n        }\n\n        deferred.resolve([conn, res.readBuf]);\n      }\n      const ws = resp[_ws];\n      if (ws) {\n        const wsRid = await core.opAsync(\n          \"op_http_upgrade_websocket\",\n          streamRid,\n        );\n        ws[_rid] = wsRid;\n        ws[_protocol] = resp.headers.get(\"sec-websocket-protocol\");\n\n        httpConn.close();\n\n        ws[_readyState] = WebSocket.OPEN;\n        const event = new Event(\"open\");\n        ws.dispatchEvent(event);\n\n        ws[_eventLoop]();\n        if (ws[_idleTimeoutDuration]) {\n          ws.addEventListener(\n            \"close\",\n            () => clearTimeout(ws[_idleTimeoutTimeout]),\n          );\n        }\n        ws[_serverHandleIdleTimeout]();\n      }\n    } finally {\n      if (SetPrototypeDelete(httpConn.managedResources, streamRid)) {\n        core.close(streamRid);\n      }\n    }\n  };\n}\n\nconst _ws = Symbol(\"[[associated_ws]]\");\n\nfunction upgradeWebSocket(request, options = {}) {\n  const upgrade = request.headers.get(\"upgrade\");\n  const upgradeHasWebSocketOption = upgrade !== null &&\n    ArrayPrototypeSome(\n      StringPrototypeSplit(upgrade, /\\s*,\\s*/),\n      (option) => StringPrototypeToLowerCase(option) === \"websocket\",\n    );\n  if (!upgradeHasWebSocketOption) {\n    throw new TypeError(\n      \"Invalid Header: 'upgrade' header must contain 'websocket'\",\n    );\n  }\n\n  const connection = request.headers.get(\"connection\");\n  const connectionHasUpgradeOption = connection !== null &&\n    ArrayPrototypeSome(\n      StringPrototypeSplit(connection, /\\s*,\\s*/),\n      (option) => StringPrototypeToLowerCase(option) === \"upgrade\",\n    );\n  if (!connectionHasUpgradeOption) {\n    throw new TypeError(\n      \"Invalid Header: 'connection' header must contain 'Upgrade'\",\n    );\n  }\n\n  const websocketKey = request.headers.get(\"sec-websocket-key\");\n  if (websocketKey === null) {\n    throw new TypeError(\n      \"Invalid Header: 'sec-websocket-key' header must be set\",\n    );\n  }\n\n  const accept = ops.op_http_websocket_accept_header(websocketKey);\n\n  const r = newInnerResponse(101);\n  r.headerList = [\n    [\"upgrade\", \"websocket\"],\n    [\"connection\", \"Upgrade\"],\n    [\"sec-websocket-accept\", accept],\n  ];\n\n  const protocolsStr = request.headers.get(\"sec-websocket-protocol\") || \"\";\n  const protocols = StringPrototypeSplit(protocolsStr, \", \");\n  if (protocols && options.protocol) {\n    if (ArrayPrototypeIncludes(protocols, options.protocol)) {\n      ArrayPrototypePush(r.headerList, [\n        \"sec-websocket-protocol\",\n        options.protocol,\n      ]);\n    } else {\n      throw new TypeError(\n        `Protocol '${options.protocol}' not in the request's protocol list (non negotiable)`,\n      );\n    }\n  }\n\n  const response = fromInnerResponse(r, \"immutable\");\n\n  const socket = webidl.createBranded(WebSocket);\n  setEventTargetData(socket);\n  socket[_server] = true;\n  response[_ws] = socket;\n  socket[_idleTimeoutDuration] = options.idleTimeout ?? 120;\n  socket[_idleTimeoutTimeout] = null;\n\n  return { response, socket };\n}\n\nfunction upgradeHttp(req) {\n  if (req[_flash]) {\n    throw new TypeError(\n      \"Flash requests can not be upgraded with `upgradeHttp`. Use `upgradeHttpRaw` instead.\",\n    );\n  }\n\n  req[_deferred] = new Deferred();\n  return req[_deferred].promise;\n}\n\nexport { _ws, HttpConn, upgradeHttp, upgradeWebSocket };\n"], "fixing_code": ["// Copyright 2018-2023 the Deno authors. All rights reserved. MIT license.\nconst core = globalThis.Deno.core;\nconst primordials = globalThis.__bootstrap.primordials;\nconst { BadResourcePrototype, InterruptedPrototype, ops } = core;\nimport * as webidl from \"internal:deno_webidl/00_webidl.js\";\nimport { InnerBody } from \"internal:deno_fetch/22_body.js\";\nimport { Event, setEventTargetData } from \"internal:deno_web/02_event.js\";\nimport { BlobPrototype } from \"internal:deno_web/09_file.js\";\nimport {\n  fromInnerResponse,\n  newInnerResponse,\n  ResponsePrototype,\n  toInnerResponse,\n} from \"internal:deno_fetch/23_response.js\";\nimport {\n  _flash,\n  fromInnerRequest,\n  newInnerRequest,\n} from \"internal:deno_fetch/23_request.js\";\nimport * as abortSignal from \"internal:deno_web/03_abort_signal.js\";\nimport {\n  _eventLoop,\n  _idleTimeoutDuration,\n  _idleTimeoutTimeout,\n  _protocol,\n  _readyState,\n  _rid,\n  _server,\n  _serverHandleIdleTimeout,\n  WebSocket,\n} from \"internal:deno_websocket/01_websocket.js\";\nimport { TcpConn, UnixConn } from \"internal:deno_net/01_net.js\";\nimport { TlsConn } from \"internal:deno_net/02_tls.js\";\nimport {\n  Deferred,\n  getReadableStreamResourceBacking,\n  readableStreamClose,\n  readableStreamForRid,\n  ReadableStreamPrototype,\n} from \"internal:deno_web/06_streams.js\";\nconst {\n  ArrayPrototypeIncludes,\n  ArrayPrototypePush,\n  ArrayPrototypeSome,\n  Error,\n  ObjectPrototypeIsPrototypeOf,\n  SafeSetIterator,\n  Set,\n  SetPrototypeAdd,\n  SetPrototypeDelete,\n  StringPrototypeIncludes,\n  StringPrototypeToLowerCase,\n  StringPrototypeSplit,\n  StringPrototypeTrim,\n  Symbol,\n  SymbolAsyncIterator,\n  TypeError,\n  Uint8Array,\n  Uint8ArrayPrototype,\n} = primordials;\n\nconst connErrorSymbol = Symbol(\"connError\");\nconst _deferred = Symbol(\"upgradeHttpDeferred\");\n\nclass HttpConn {\n  #rid = 0;\n  #closed = false;\n  #remoteAddr;\n  #localAddr;\n\n  // This set holds resource ids of resources\n  // that were created during lifecycle of this request.\n  // When the connection is closed these resources should be closed\n  // as well.\n  managedResources = new Set();\n\n  constructor(rid, remoteAddr, localAddr) {\n    this.#rid = rid;\n    this.#remoteAddr = remoteAddr;\n    this.#localAddr = localAddr;\n  }\n\n  /** @returns {number} */\n  get rid() {\n    return this.#rid;\n  }\n\n  /** @returns {Promise<RequestEvent | null>} */\n  async nextRequest() {\n    let nextRequest;\n    try {\n      nextRequest = await core.opAsync(\"op_http_accept\", this.#rid);\n    } catch (error) {\n      this.close();\n      // A connection error seen here would cause disrupted responses to throw\n      // a generic `BadResource` error. Instead store this error and replace\n      // those with it.\n      this[connErrorSymbol] = error;\n      if (\n        ObjectPrototypeIsPrototypeOf(BadResourcePrototype, error) ||\n        ObjectPrototypeIsPrototypeOf(InterruptedPrototype, error) ||\n        StringPrototypeIncludes(error.message, \"connection closed\")\n      ) {\n        return null;\n      }\n      throw error;\n    }\n    if (nextRequest == null) {\n      // Work-around for servers (deno_std/http in particular) that call\n      // `nextRequest()` before upgrading a previous request which has a\n      // `connection: upgrade` header.\n      await null;\n\n      this.close();\n      return null;\n    }\n\n    const { 0: streamRid, 1: method, 2: url } = nextRequest;\n    SetPrototypeAdd(this.managedResources, streamRid);\n\n    /** @type {ReadableStream<Uint8Array> | undefined} */\n    let body = null;\n    // There might be a body, but we don't expose it for GET/HEAD requests.\n    // It will be closed automatically once the request has been handled and\n    // the response has been sent.\n    if (method !== \"GET\" && method !== \"HEAD\") {\n      body = readableStreamForRid(streamRid, false);\n    }\n\n    const innerRequest = newInnerRequest(\n      () => method,\n      url,\n      () => ops.op_http_headers(streamRid),\n      body !== null ? new InnerBody(body) : null,\n      false,\n    );\n    const signal = abortSignal.newSignal();\n    const request = fromInnerRequest(\n      innerRequest,\n      signal,\n      \"immutable\",\n      false,\n    );\n\n    const respondWith = createRespondWith(\n      this,\n      streamRid,\n      request,\n      this.#remoteAddr,\n      this.#localAddr,\n    );\n\n    return { request, respondWith };\n  }\n\n  /** @returns {void} */\n  close() {\n    if (!this.#closed) {\n      this.#closed = true;\n      core.close(this.#rid);\n      for (const rid of new SafeSetIterator(this.managedResources)) {\n        SetPrototypeDelete(this.managedResources, rid);\n        core.close(rid);\n      }\n    }\n  }\n\n  [SymbolAsyncIterator]() {\n    // deno-lint-ignore no-this-alias\n    const httpConn = this;\n    return {\n      async next() {\n        const reqEvt = await httpConn.nextRequest();\n        // Change with caution, current form avoids a v8 deopt\n        return { value: reqEvt ?? undefined, done: reqEvt === null };\n      },\n    };\n  }\n}\n\nfunction createRespondWith(\n  httpConn,\n  streamRid,\n  request,\n  remoteAddr,\n  localAddr,\n) {\n  return async function respondWith(resp) {\n    try {\n      resp = await resp;\n      if (!(ObjectPrototypeIsPrototypeOf(ResponsePrototype, resp))) {\n        throw new TypeError(\n          \"First argument to respondWith must be a Response or a promise resolving to a Response.\",\n        );\n      }\n\n      const innerResp = toInnerResponse(resp);\n\n      // If response body length is known, it will be sent synchronously in a\n      // single op, in other case a \"response body\" resource will be created and\n      // we'll be streaming it.\n      /** @type {ReadableStream<Uint8Array> | Uint8Array | null} */\n      let respBody = null;\n      if (innerResp.body !== null) {\n        if (innerResp.body.unusable()) {\n          throw new TypeError(\"Body is unusable.\");\n        }\n        if (\n          ObjectPrototypeIsPrototypeOf(\n            ReadableStreamPrototype,\n            innerResp.body.streamOrStatic,\n          )\n        ) {\n          if (\n            innerResp.body.length === null ||\n            ObjectPrototypeIsPrototypeOf(\n              BlobPrototype,\n              innerResp.body.source,\n            )\n          ) {\n            respBody = innerResp.body.stream;\n          } else {\n            const reader = innerResp.body.stream.getReader();\n            const r1 = await reader.read();\n            if (r1.done) {\n              respBody = new Uint8Array(0);\n            } else {\n              respBody = r1.value;\n              const r2 = await reader.read();\n              if (!r2.done) throw new TypeError(\"Unreachable\");\n            }\n          }\n        } else {\n          innerResp.body.streamOrStatic.consumed = true;\n          respBody = innerResp.body.streamOrStatic.body;\n        }\n      } else {\n        respBody = new Uint8Array(0);\n      }\n      const isStreamingResponseBody = !(\n        typeof respBody === \"string\" ||\n        ObjectPrototypeIsPrototypeOf(Uint8ArrayPrototype, respBody)\n      );\n      try {\n        await core.opAsync(\n          \"op_http_write_headers\",\n          streamRid,\n          innerResp.status ?? 200,\n          innerResp.headerList,\n          isStreamingResponseBody ? null : respBody,\n        );\n      } catch (error) {\n        const connError = httpConn[connErrorSymbol];\n        if (\n          ObjectPrototypeIsPrototypeOf(BadResourcePrototype, error) &&\n          connError != null\n        ) {\n          // deno-lint-ignore no-ex-assign\n          error = new connError.constructor(connError.message);\n        }\n        if (\n          respBody !== null &&\n          ObjectPrototypeIsPrototypeOf(ReadableStreamPrototype, respBody)\n        ) {\n          await respBody.cancel(error);\n        }\n        throw error;\n      }\n\n      if (isStreamingResponseBody) {\n        let success = false;\n        if (\n          respBody === null ||\n          !ObjectPrototypeIsPrototypeOf(ReadableStreamPrototype, respBody)\n        ) {\n          throw new TypeError(\"Unreachable\");\n        }\n        const resourceBacking = getReadableStreamResourceBacking(respBody);\n        let reader;\n        if (resourceBacking) {\n          if (respBody.locked) {\n            throw new TypeError(\"ReadableStream is locked.\");\n          }\n          reader = respBody.getReader(); // Aquire JS lock.\n          try {\n            await core.opAsync(\n              \"op_http_write_resource\",\n              streamRid,\n              resourceBacking.rid,\n            );\n            if (resourceBacking.autoClose) core.tryClose(resourceBacking.rid);\n            readableStreamClose(respBody); // Release JS lock.\n            success = true;\n          } catch (error) {\n            const connError = httpConn[connErrorSymbol];\n            if (\n              ObjectPrototypeIsPrototypeOf(BadResourcePrototype, error) &&\n              connError != null\n            ) {\n              // deno-lint-ignore no-ex-assign\n              error = new connError.constructor(connError.message);\n            }\n            await reader.cancel(error);\n            throw error;\n          }\n        } else {\n          reader = respBody.getReader();\n          while (true) {\n            const { value, done } = await reader.read();\n            if (done) break;\n            if (!ObjectPrototypeIsPrototypeOf(Uint8ArrayPrototype, value)) {\n              await reader.cancel(new TypeError(\"Value not a Uint8Array\"));\n              break;\n            }\n            try {\n              await core.opAsync(\"op_http_write\", streamRid, value);\n            } catch (error) {\n              const connError = httpConn[connErrorSymbol];\n              if (\n                ObjectPrototypeIsPrototypeOf(BadResourcePrototype, error) &&\n                connError != null\n              ) {\n                // deno-lint-ignore no-ex-assign\n                error = new connError.constructor(connError.message);\n              }\n              await reader.cancel(error);\n              throw error;\n            }\n          }\n          success = true;\n        }\n\n        if (success) {\n          try {\n            await core.opAsync(\"op_http_shutdown\", streamRid);\n          } catch (error) {\n            await reader.cancel(error);\n            throw error;\n          }\n        }\n      }\n\n      const deferred = request[_deferred];\n      if (deferred) {\n        const res = await core.opAsync(\"op_http_upgrade\", streamRid);\n        let conn;\n        if (res.connType === \"tcp\") {\n          conn = new TcpConn(res.connRid, remoteAddr, localAddr);\n        } else if (res.connType === \"tls\") {\n          conn = new TlsConn(res.connRid, remoteAddr, localAddr);\n        } else if (res.connType === \"unix\") {\n          conn = new UnixConn(res.connRid, remoteAddr, localAddr);\n        } else {\n          throw new Error(\"unreachable\");\n        }\n\n        deferred.resolve([conn, res.readBuf]);\n      }\n      const ws = resp[_ws];\n      if (ws) {\n        const wsRid = await core.opAsync(\n          \"op_http_upgrade_websocket\",\n          streamRid,\n        );\n        ws[_rid] = wsRid;\n        ws[_protocol] = resp.headers.get(\"sec-websocket-protocol\");\n\n        httpConn.close();\n\n        ws[_readyState] = WebSocket.OPEN;\n        const event = new Event(\"open\");\n        ws.dispatchEvent(event);\n\n        ws[_eventLoop]();\n        if (ws[_idleTimeoutDuration]) {\n          ws.addEventListener(\n            \"close\",\n            () => clearTimeout(ws[_idleTimeoutTimeout]),\n          );\n        }\n        ws[_serverHandleIdleTimeout]();\n      }\n    } finally {\n      if (SetPrototypeDelete(httpConn.managedResources, streamRid)) {\n        core.close(streamRid);\n      }\n    }\n  };\n}\n\nconst _ws = Symbol(\"[[associated_ws]]\");\n\nfunction upgradeWebSocket(request, options = {}) {\n  const upgrade = request.headers.get(\"upgrade\");\n  const upgradeHasWebSocketOption = upgrade !== null &&\n    ArrayPrototypeSome(\n      StringPrototypeSplit(upgrade, \",\"),\n      (option) =>\n        StringPrototypeToLowerCase(StringPrototypeTrim(option)) === \"websocket\",\n    );\n  if (!upgradeHasWebSocketOption) {\n    throw new TypeError(\n      \"Invalid Header: 'upgrade' header must contain 'websocket'\",\n    );\n  }\n\n  const connection = request.headers.get(\"connection\");\n  const connectionHasUpgradeOption = connection !== null &&\n    ArrayPrototypeSome(\n      StringPrototypeSplit(connection, \",\"),\n      (option) =>\n        StringPrototypeToLowerCase(StringPrototypeTrim(option)) === \"upgrade\",\n    );\n  if (!connectionHasUpgradeOption) {\n    throw new TypeError(\n      \"Invalid Header: 'connection' header must contain 'Upgrade'\",\n    );\n  }\n\n  const websocketKey = request.headers.get(\"sec-websocket-key\");\n  if (websocketKey === null) {\n    throw new TypeError(\n      \"Invalid Header: 'sec-websocket-key' header must be set\",\n    );\n  }\n\n  const accept = ops.op_http_websocket_accept_header(websocketKey);\n\n  const r = newInnerResponse(101);\n  r.headerList = [\n    [\"upgrade\", \"websocket\"],\n    [\"connection\", \"Upgrade\"],\n    [\"sec-websocket-accept\", accept],\n  ];\n\n  const protocolsStr = request.headers.get(\"sec-websocket-protocol\") || \"\";\n  const protocols = StringPrototypeSplit(protocolsStr, \", \");\n  if (protocols && options.protocol) {\n    if (ArrayPrototypeIncludes(protocols, options.protocol)) {\n      ArrayPrototypePush(r.headerList, [\n        \"sec-websocket-protocol\",\n        options.protocol,\n      ]);\n    } else {\n      throw new TypeError(\n        `Protocol '${options.protocol}' not in the request's protocol list (non negotiable)`,\n      );\n    }\n  }\n\n  const response = fromInnerResponse(r, \"immutable\");\n\n  const socket = webidl.createBranded(WebSocket);\n  setEventTargetData(socket);\n  socket[_server] = true;\n  response[_ws] = socket;\n  socket[_idleTimeoutDuration] = options.idleTimeout ?? 120;\n  socket[_idleTimeoutTimeout] = null;\n\n  return { response, socket };\n}\n\nfunction upgradeHttp(req) {\n  if (req[_flash]) {\n    throw new TypeError(\n      \"Flash requests can not be upgraded with `upgradeHttp`. Use `upgradeHttpRaw` instead.\",\n    );\n  }\n\n  req[_deferred] = new Deferred();\n  return req[_deferred].promise;\n}\n\nexport { _ws, HttpConn, upgradeHttp, upgradeWebSocket };\n"], "filenames": ["ext/http/01_http.js"], "buggy_code_start_loc": [53], "buggy_code_end_loc": [410], "fixing_code_start_loc": [54], "fixing_code_end_loc": [413], "type": "CWE-1333", "message": "Versions of the package deno before 1.31.0 are vulnerable to Regular Expression Denial of Service (ReDoS) due to the upgradeWebSocket function, which contains regexes in the form of /s*,s*/, used for splitting the Connection/Upgrade header. A specially crafted Connection/Upgrade header can be used to significantly slow down a web socket server.", "other": {"cve": {"id": "CVE-2023-26103", "sourceIdentifier": "report@snyk.io", "published": "2023-02-25T05:15:12.343", "lastModified": "2023-03-07T02:48:42.350", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Versions of the package deno before 1.31.0 are vulnerable to Regular Expression Denial of Service (ReDoS) due to the upgradeWebSocket function, which contains regexes in the form of /s*,s*/, used for splitting the Connection/Upgrade header. A specially crafted Connection/Upgrade header can be used to significantly slow down a web socket server."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1333"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:deno:deno:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.31.0", "matchCriteriaId": "EFFBE1A2-4130-4E48-B807-89F14A2D0CE4"}]}]}], "references": [{"url": "https://github.com/denoland/deno/blob/2b247be517d789a37e532849e2e40b724af0918f/ext/http/01_http.js%23L395-L409", "source": "report@snyk.io", "tags": ["Broken Link"]}, {"url": "https://github.com/denoland/deno/commit/cf06a7c7e672880e1b38598fe445e2c50b4a9d06", "source": "report@snyk.io", "tags": ["Patch"]}, {"url": "https://github.com/denoland/deno/pull/17722", "source": "report@snyk.io", "tags": ["Patch"]}, {"url": "https://github.com/denoland/deno/releases/tag/v1.31.0", "source": "report@snyk.io", "tags": ["Release Notes"]}, {"url": "https://security.snyk.io/vuln/SNYK-RUST-DENO-3315970", "source": "report@snyk.io", "tags": ["Exploit", "Technical Description", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/denoland/deno/commit/cf06a7c7e672880e1b38598fe445e2c50b4a9d06"}}