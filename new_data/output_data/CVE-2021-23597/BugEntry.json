{"buggy_code": ["'use strict'\n\nconst Busboy = require('@fastify/busboy')\nconst os = require('os')\nconst fp = require('fastify-plugin')\nconst eos = require('end-of-stream')\nconst { createWriteStream } = require('fs')\nconst { unlink } = require('fs').promises\nconst path = require('path')\nconst hexoid = require('hexoid')\nconst util = require('util')\nconst createError = require('fastify-error')\nconst sendToWormhole = require('stream-wormhole')\nconst deepmerge = require('deepmerge')\nconst { PassThrough, pipeline } = require('stream')\nconst pump = util.promisify(pipeline)\nconst secureJSON = require('secure-json-parse')\n\nconst kMultipart = Symbol('multipart')\nconst kMultipartHandler = Symbol('multipartHandler')\nconst getDescriptor = Object.getOwnPropertyDescriptor\n\nfunction setMultipart (req, payload, done) {\n  // nothing to do, it will be done by the Request.multipart object\n  req.raw[kMultipart] = true\n  done()\n}\n\nfunction attachToBody (options, req, reply, next) {\n  if (req.raw[kMultipart] !== true) {\n    next()\n    return\n  }\n\n  const consumerStream = options.onFile || defaultConsumer\n  const body = {}\n  const mp = req.multipart((field, file, filename, encoding, mimetype) => {\n    body[field] = body[field] || []\n    body[field].push({\n      data: [],\n      filename,\n      encoding,\n      mimetype,\n      limit: false\n    })\n\n    const result = consumerStream(field, file, filename, encoding, mimetype, body)\n    if (result && typeof result.then === 'function') {\n      result.catch((err) => {\n        // continue with the workflow\n        err.statusCode = 500\n        file.destroy(err)\n      })\n    }\n  }, function (err) {\n    if (!err) {\n      req.body = body\n    }\n    next(err)\n  }, options)\n\n  mp.on('field', (key, value) => {\n    if (key === '__proto__') {\n      mp.destroy(new Error('__proto__ is not allowed as field name'))\n      return\n    }\n    if (body[key] === undefined) {\n      body[key] = value\n    } else if (Array.isArray(body[key])) {\n      body[key].push(value)\n    } else {\n      body[key] = [body[key], value]\n    }\n  })\n}\n\nfunction defaultConsumer (field, file, filename, encoding, mimetype, body) {\n  const fileData = []\n  const lastFile = body[field][body[field].length - 1]\n  file.on('data', data => { if (!lastFile.limit) { fileData.push(data) } })\n  file.on('limit', () => { lastFile.limit = true })\n  file.on('end', () => {\n    if (!lastFile.limit) {\n      lastFile.data = Buffer.concat(fileData)\n    } else {\n      lastFile.data = undefined\n    }\n  })\n}\n\nfunction busboy (options) {\n  try {\n    return new Busboy(options)\n  } catch (error) {\n    const errorEmitter = new PassThrough()\n    process.nextTick(function () {\n      errorEmitter.emit('error', error)\n    })\n    return errorEmitter\n  }\n}\n\nfunction fastifyMultipart (fastify, options, done) {\n  if (options.addToBody === true) {\n    if (typeof options.sharedSchemaId === 'string') {\n      fastify.addSchema({\n        $id: options.sharedSchemaId,\n        type: 'object',\n        properties: {\n          encoding: { type: 'string' },\n          filename: { type: 'string' },\n          limit: { type: 'boolean' },\n          mimetype: { type: 'string' }\n        }\n      })\n    }\n\n    fastify.addHook('preValidation', function (req, reply, next) {\n      attachToBody(options, req, reply, next)\n    })\n  }\n\n  if (options.attachFieldsToBody === true) {\n    if (typeof options.sharedSchemaId === 'string') {\n      fastify.addSchema({\n        $id: options.sharedSchemaId,\n        type: 'object',\n        properties: {\n          fieldname: { type: 'string' },\n          encoding: { type: 'string' },\n          filename: { type: 'string' },\n          mimetype: { type: 'string' }\n        }\n      })\n    }\n    fastify.addHook('preValidation', async function (req, reply) {\n      if (!req.isMultipart()) {\n        return\n      }\n      for await (const part of req.parts()) {\n        req.body = part.fields\n        if (part.file) {\n          if (options.onFile) {\n            await options.onFile(part)\n          } else {\n            await part.toBuffer()\n          }\n        }\n      }\n    })\n  }\n\n  let throwFileSizeLimit = true\n  if (typeof options.throwFileSizeLimit === 'boolean') {\n    throwFileSizeLimit = options.throwFileSizeLimit\n  }\n\n  const PartsLimitError = createError('FST_PARTS_LIMIT', 'reach parts limit', 413)\n  const FilesLimitError = createError('FST_FILES_LIMIT', 'reach files limit', 413)\n  const FieldsLimitError = createError('FST_FIELDS_LIMIT', 'reach fields limit', 413)\n  const RequestFileTooLargeError = createError('FST_REQ_FILE_TOO_LARGE', 'request file too large, please check multipart config', 413)\n  const PrototypeViolationError = createError('FST_PROTO_VIOLATION', 'prototype property is not allowed as field name', 400)\n  const InvalidMultipartContentTypeError = createError('FST_INVALID_MULTIPART_CONTENT_TYPE', 'the request is not multipart', 406)\n  const InvalidJSONFieldError = createError('FST_INVALID_JSON_FIELD_ERROR', 'a request field is not a valid JSON as declared by its Content-Type', 406)\n\n  fastify.decorate('multipartErrors', {\n    PartsLimitError,\n    FilesLimitError,\n    FieldsLimitError,\n    PrototypeViolationError,\n    InvalidMultipartContentTypeError,\n    RequestFileTooLargeError\n  })\n\n  fastify.addContentTypeParser('multipart', setMultipart)\n  fastify.decorateRequest(kMultipartHandler, handleMultipart)\n\n  fastify.decorateRequest('parts', getMultipartIterator)\n\n  fastify.decorateRequest('isMultipart', isMultipart)\n  fastify.decorateRequest('tmpUploads', null)\n\n  // legacy\n  fastify.decorateRequest('multipart', handleLegacyMultipartApi)\n\n  // Stream mode\n  fastify.decorateRequest('file', getMultipartFile)\n  fastify.decorateRequest('files', getMultipartFiles)\n\n  // Disk mode\n  fastify.decorateRequest('saveRequestFiles', saveRequestFiles)\n  fastify.decorateRequest('cleanRequestFiles', cleanRequestFiles)\n\n  fastify.addHook('onResponse', async (request, reply) => {\n    await request.cleanRequestFiles()\n  })\n\n  const toID = hexoid()\n\n  function isMultipart () {\n    return this.raw[kMultipart] || false\n  }\n\n  // handler definition is in multipart-readstream\n  // handler(field, file, filename, encoding, mimetype)\n  // opts is a per-request override for the options object\n  function handleLegacyMultipartApi (handler, done, opts) {\n    if (typeof handler !== 'function') {\n      throw new Error('handler must be a function')\n    }\n\n    if (typeof done !== 'function') {\n      throw new Error('the callback must be a function')\n    }\n\n    if (!this.isMultipart()) {\n      done(new Error('the request is not multipart'))\n      return\n    }\n\n    const log = this.log\n\n    log.warn('the multipart callback-based api is deprecated in favour of the new promise api')\n    log.debug('starting multipart parsing')\n\n    const req = this.raw\n\n    const busboyOptions = deepmerge.all([{ headers: Object.assign({}, req.headers) }, options || {}, opts || {}])\n    const stream = busboy(busboyOptions)\n    let completed = false\n    let files = 0\n\n    req.on('error', function (err) {\n      stream.destroy()\n      if (!completed) {\n        completed = true\n        done(err)\n      }\n    })\n\n    stream.on('finish', function () {\n      log.debug('finished receiving stream, total %d files', files)\n      if (!completed) {\n        completed = true\n        setImmediate(done)\n      }\n    })\n\n    stream.on('file', wrap)\n\n    req.pipe(stream)\n      .on('error', function (error) {\n        req.emit('error', error)\n      })\n\n    function wrap (field, file, filename, encoding, mimetype) {\n      log.debug({ field, filename, encoding, mimetype }, 'parsing part')\n      files++\n      eos(file, waitForFiles)\n      if (field === '__proto__') {\n        file.destroy(new Error('__proto__ is not allowed as field name'))\n        return\n      }\n      handler(field, file, filename, encoding, mimetype)\n    }\n\n    function waitForFiles (err) {\n      if (err) {\n        completed = true\n        done(err)\n      }\n    }\n\n    return stream\n  }\n\n  function handleMultipart (opts = {}) {\n    if (!this.isMultipart()) {\n      throw new InvalidMultipartContentTypeError()\n    }\n\n    this.log.debug('starting multipart parsing')\n\n    let values = []\n    let pendingHandler = null\n\n    // only one file / field can be processed at a time\n    // \"null\" will close the consumer side\n    const ch = (val) => {\n      if (pendingHandler) {\n        pendingHandler(val)\n        pendingHandler = null\n      } else {\n        values.push(val)\n      }\n    }\n\n    const handle = (handler) => {\n      if (values.length > 0) {\n        const value = values[0]\n        values = values.slice(1)\n        handler(value)\n      } else {\n        pendingHandler = handler\n      }\n    }\n\n    const parts = () => {\n      return new Promise((resolve, reject) => {\n        handle((val) => {\n          if (val instanceof Error) return reject(val)\n          resolve(val)\n        })\n      })\n    }\n\n    const body = {}\n    let lastError = null\n    let currentFile = null\n    const request = this.raw\n    const busboyOptions = deepmerge.all([\n      { headers: Object.assign({}, request.headers) },\n      options,\n      opts\n    ])\n\n    this.log.trace({ busboyOptions }, 'Providing options to busboy')\n    const bb = busboy(busboyOptions)\n\n    request.on('close', cleanup)\n    request.on('error', cleanup)\n\n    bb\n      .on('field', onField)\n      .on('file', onFile)\n      .on('close', cleanup)\n      .on('error', onEnd)\n      .on('end', onEnd)\n      .on('finish', onEnd)\n\n    bb.on('partsLimit', function () {\n      onError(new PartsLimitError())\n    })\n\n    bb.on('filesLimit', function () {\n      onError(new FilesLimitError())\n    })\n\n    bb.on('fieldsLimit', function () {\n      onError(new FieldsLimitError())\n    })\n\n    request.pipe(bb)\n\n    function onField (name, fieldValue, fieldnameTruncated, valueTruncated, encoding, contentType) {\n      let mimetype\n\n      // don't overwrite prototypes\n      if (getDescriptor(Object.prototype, name)) {\n        onError(new PrototypeViolationError())\n        return\n      }\n\n      // If it is a JSON field, parse it\n      if (contentType.startsWith('application/json')) {\n        // If the value was truncated, it can never be a valid JSON. Don't even try to parse\n        if (valueTruncated) {\n          onError(new InvalidJSONFieldError())\n          return\n        }\n\n        try {\n          fieldValue = secureJSON.parse(fieldValue)\n          mimetype = 'application/json'\n        } catch (e) {\n          onError(new InvalidJSONFieldError())\n          return\n        }\n      }\n\n      const value = {\n        fieldname: name,\n        mimetype,\n        encoding,\n        value: fieldValue,\n        fieldnameTruncated,\n        valueTruncated,\n        fields: body\n      }\n\n      if (body[name] === undefined) {\n        body[name] = value\n      } else if (Array.isArray(body[name])) {\n        body[name].push(value)\n      } else {\n        body[name] = [body[name], value]\n      }\n\n      ch(value)\n    }\n\n    function onFile (name, file, filename, encoding, mimetype) {\n      // don't overwrite prototypes\n      if (getDescriptor(Object.prototype, name)) {\n        // ensure that stream is consumed, any error is suppressed\n        sendToWormhole(file)\n        onError(new PrototypeViolationError())\n        return\n      }\n\n      if (typeof opts.throwFileSizeLimit === 'boolean') {\n        throwFileSizeLimit = opts.throwFileSizeLimit\n      }\n\n      const value = {\n        fieldname: name,\n        filename,\n        encoding,\n        mimetype,\n        file,\n        fields: body,\n        _buf: null,\n        async toBuffer () {\n          if (this._buf) {\n            return this._buf\n          }\n          const fileChunks = []\n          for await (const chunk of this.file) {\n            fileChunks.push(chunk)\n\n            if (throwFileSizeLimit && this.file.truncated) {\n              const err = new RequestFileTooLargeError()\n              err.part = this\n\n              onError(err)\n              throw err\n            }\n          }\n          this._buf = Buffer.concat(fileChunks)\n          return this._buf\n        }\n      }\n\n      if (throwFileSizeLimit) {\n        file.on('limit', function () {\n          const err = new RequestFileTooLargeError()\n          err.part = value\n          onError(err)\n        })\n      }\n\n      if (body[name] === undefined) {\n        body[name] = value\n      } else if (Array.isArray(body[name])) {\n        body[name].push(value)\n      } else {\n        body[name] = [body[name], value]\n      }\n      currentFile = file\n      ch(value)\n    }\n\n    function onError (err) {\n      lastError = err\n      currentFile = null\n    }\n\n    function onEnd (err) {\n      cleanup()\n\n      ch(err || lastError)\n    }\n\n    function cleanup (err) {\n      request.unpipe(bb)\n      // in node 10 it seems that error handler is not called but request.aborted is set\n      if ((err || request.aborted) && currentFile) {\n        currentFile.destroy()\n      }\n    }\n\n    return parts\n  }\n\n  async function saveRequestFiles (options) {\n    const requestFiles = []\n    const tmpdir = (options && options.tmpdir) || os.tmpdir()\n\n    const files = await this.files(options)\n    this.tmpUploads = []\n    for await (const file of files) {\n      const filepath = path.join(tmpdir, toID() + path.extname(file.filename))\n      const target = createWriteStream(filepath)\n      try {\n        await pump(file.file, target)\n        requestFiles.push({ ...file, filepath })\n        this.tmpUploads.push(filepath)\n      } catch (err) {\n        this.log.error({ err }, 'save request file')\n        throw err\n      }\n    }\n\n    return requestFiles\n  }\n\n  async function cleanRequestFiles () {\n    if (!this.tmpUploads) {\n      return\n    }\n    for (const filepath of this.tmpUploads) {\n      try {\n        await unlink(filepath)\n      } catch (error) {\n        this.log.error(error, 'could not delete file')\n      }\n    }\n  }\n\n  async function getMultipartFile (options) {\n    const parts = this[kMultipartHandler](options)\n    let part\n    while ((part = await parts()) != null) {\n      if (part.file) {\n        // part.file.truncated is true when a configured file size limit is reached\n        if (part.file.truncated && throwFileSizeLimit) {\n          throw new RequestFileTooLargeError()\n        }\n        return part\n      }\n    }\n  }\n\n  async function * getMultipartFiles (options) {\n    const parts = this[kMultipartHandler](options)\n\n    let part\n    while ((part = await parts()) != null) {\n      if (part.file) {\n        yield part\n      }\n    }\n  }\n\n  async function * getMultipartIterator (options) {\n    const parts = this[kMultipartHandler](options)\n\n    let part\n    while ((part = await parts()) != null) {\n      yield part\n    }\n  }\n\n  done()\n}\n\nmodule.exports = fp(fastifyMultipart, {\n  fastify: '>= 0.39.0',\n  name: 'fastify-multipart'\n})\n", "'use strict'\nconst test = require('tap').test\nconst FormData = require('form-data')\nconst Fastify = require('fastify')\nconst multipart = require('./../..')\nconst http = require('http')\nconst path = require('path')\nconst fs = require('fs')\nconst pump = require('pump')\n\nconst filePath = path.join(__dirname, '..', '..', 'README.md')\n\ntest('addToBody option', { skip: process.platform === 'win32' }, t => {\n  t.plan(8)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.register(multipart, { addToBody: true })\n\n  fastify.post('/', function (req, reply) {\n    t.equal(req.body.myField, 'hello')\n    t.equal(req.body.myCheck, 'true')\n    t.match(req.body.myFile, [{\n      encoding: '7bit',\n      filename: 'README.md',\n      limit: false,\n      mimetype: 'text/markdown'\n    }])\n    t.type(req.body.myFile[0].data, Buffer)\n    t.equal(req.body.myFile[0].data.toString('utf8').substr(0, 19), '# fastify-multipart')\n\n    reply.send('ok')\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 200)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n\n    const rs = fs.createReadStream(filePath)\n    form.append('myField', 'hello')\n    form.append('myCheck', 'true')\n    form.append('myFile', rs)\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('addToBody with limit exceeded', { skip: process.platform === 'win32' }, t => {\n  t.plan(5)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.register(multipart, { addToBody: true, limits: { fileSize: 1 } })\n\n  fastify.post('/', function (req, reply) {\n    t.equal(req.body.myFile[0].limit, true)\n    t.equal(req.body.myFile[0].data, undefined)\n\n    reply.send('ok')\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 200)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n\n    const rs = fs.createReadStream(filePath)\n    form.append('myFile', rs)\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('addToBody option and multiple files', { skip: process.platform === 'win32' }, t => {\n  t.plan(7)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  let fileCounter = 0\n  const opts = {\n    addToBody: true,\n    onFile: (fieldName, stream, filename, encoding, mimetype) => {\n      fileCounter++\n      stream.resume()\n    }\n  }\n  fastify.register(multipart, opts)\n\n  fastify.post('/', function (req, reply) {\n    t.match(req.body.myFile, [{\n      data: [],\n      encoding: '7bit',\n      filename: 'README.md',\n      limit: false,\n      mimetype: 'text/markdown'\n    }])\n\n    t.match(req.body.myFileTwo, [{\n      data: [],\n      encoding: '7bit',\n      filename: 'README.md',\n      limit: false,\n      mimetype: 'text/markdown'\n    }])\n\n    t.match(req.body.myFileThree, [{\n      data: [],\n      encoding: '7bit',\n      filename: 'README.md',\n      limit: false,\n      mimetype: 'text/markdown'\n    }])\n\n    t.equal(fileCounter, 3, 'We must receive 3 file events')\n    reply.send('ok')\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 200)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n\n    const rs1 = fs.createReadStream(filePath)\n    const rs2 = fs.createReadStream(filePath)\n    const rs3 = fs.createReadStream(filePath)\n    form.append('myFile', rs1)\n    form.append('myFileTwo', rs2)\n    form.append('myFileThree', rs3)\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('addToBody option and multiple files in one field', { skip: process.platform === 'win32' }, t => {\n  t.plan(7)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  const opts = {\n    addToBody: true\n  }\n  fastify.register(multipart, opts)\n\n  fastify.post('/', function (req, reply) {\n    t.match(req.body.myFile, [{\n      encoding: '7bit',\n      filename: 'README.md',\n      limit: false,\n      mimetype: 'text/markdown'\n    }, {\n      encoding: '7bit',\n      filename: 'LICENSE',\n      limit: false,\n      mimetype: 'application/octet-stream'\n    }, {\n      encoding: '7bit',\n      filename: 'form.html',\n      limit: false,\n      mimetype: 'text/html'\n    }])\n    req.body.myFile.forEach(x => {\n      t.equal(Buffer.isBuffer(x.data), true)\n    })\n    reply.send('ok')\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 200)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n\n    const rs1 = fs.createReadStream(path.join(__dirname, '..', '..', 'README.md'))\n    const rs2 = fs.createReadStream(path.join(__dirname, '..', '..', 'LICENSE'))\n    const rs3 = fs.createReadStream(path.join(__dirname, '..', '..', 'form.html'))\n    form.append('myFile', rs1)\n    form.append('myFile', rs2)\n    form.append('myFile', rs3)\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('addToBody option and multiple strings in one field', { skip: process.platform === 'win32' }, t => {\n  t.plan(4)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  const opts = {\n    addToBody: true\n  }\n  fastify.register(multipart, opts)\n\n  fastify.post('/', function (req, reply) {\n    t.match(req.body.myField, ['1', '2', '3'])\n\n    reply.send('ok')\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 200)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n\n    form.append('myField', '1')\n    form.append('myField', '2')\n    form.append('myField', '3')\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('addToBody option and custom stream management', { skip: process.platform === 'win32' }, t => {\n  t.plan(7)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  const opts = {\n    addToBody: true,\n    onFile: (fieldName, stream, filename, encoding, mimetype) => {\n      t.equal(fieldName, 'myFile')\n      stream.resume()\n    }\n  }\n  fastify.register(multipart, opts)\n\n  fastify.post('/', function (req, reply) {\n    t.equal(req.body.myField, 'hello')\n    t.equal(req.body.myCheck, 'true')\n    t.match(req.body.myFile, [{\n      data: [],\n      encoding: '7bit',\n      filename: 'README.md',\n      limit: false,\n      mimetype: 'text/markdown'\n    }])\n\n    reply.send('ok')\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 200)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n\n    const rs = fs.createReadStream(filePath)\n    form.append('myField', 'hello')\n    form.append('myCheck', 'true')\n    form.append('myFile', rs)\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('addToBody option with promise', { skip: process.platform === 'win32' }, t => {\n  t.plan(5)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  const opts = {\n    addToBody: true,\n    onFile: async (fieldName, stream, filename, encoding, mimetype) => {\n      await new Promise(resolve => setTimeout(resolve, 10))\n      t.equal(fieldName, 'myFile')\n      stream.resume()\n    }\n  }\n  fastify.register(multipart, opts)\n\n  fastify.post('/', function (req, reply) {\n    t.match(req.body.myFile, [{\n      data: [],\n      encoding: '7bit',\n      filename: 'README.md',\n      limit: false,\n      mimetype: 'text/markdown'\n    }])\n\n    reply.send('ok')\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 200)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n\n    const rs = fs.createReadStream(filePath)\n    form.append('myFile', rs)\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('addToBody option with promise in error', { skip: process.platform === 'win32' }, t => {\n  t.plan(3)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  const opts = {\n    addToBody: true,\n    onFile: (fieldName, stream, filename, encoding, mimetype) => {\n      return Promise.reject(new Error('my error'))\n    }\n  }\n  fastify.register(multipart, opts)\n\n  fastify.post('/', function (req, reply) {\n    t.fail('should not execute the handler')\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 500)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n\n    const rs = fs.createReadStream(filePath)\n    form.append('myFile', rs)\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('addToBody with shared schema', { skip: process.platform === 'win32' }, (t) => {\n  t.plan(9)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.register(multipart, {\n    addToBody: true,\n    sharedSchemaId: 'mySharedSchema',\n    onFile: (fieldName, stream, filename, encoding, mimetype) => {\n      t.equal(fieldName, 'myFile')\n      t.equal(filename, 'README.md')\n      t.equal(encoding, '7bit')\n      t.equal(mimetype, 'text/markdown')\n      stream.resume()\n    }\n  })\n\n  fastify.after(() => {\n    fastify.post('/', {\n      schema: {\n        body: {\n          type: 'object',\n          required: ['myField', 'myFile'],\n          properties: {\n            myField: { type: 'string' },\n            myFile: { type: 'array', items: fastify.getSchema('mySharedSchema') }\n          }\n        }\n      }\n    }, function (req, reply) {\n      t.equal(req.body.myField, 'hello')\n      t.match(req.body.myFile, [{\n        data: [],\n        encoding: '7bit',\n        filename: 'README.md',\n        limit: false,\n        mimetype: 'text/markdown'\n      }])\n      reply.send('ok')\n    })\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 200)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n        fastify.close()\n        t.end()\n      })\n    })\n\n    const rs = fs.createReadStream(filePath)\n    form.append('myField', 'hello')\n    form.append('myFile', rs)\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('addToBody with shared schema (async/await)', { skip: process.platform === 'win32' }, async (t) => {\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  await fastify.register(multipart, {\n    addToBody: true,\n    sharedSchemaId: 'mySharedSchema',\n    onFile: (fieldName, stream, filename, encoding, mimetype) => {\n      t.equal(fieldName, 'myFile')\n      t.equal(filename, 'README.md')\n      t.equal(encoding, '7bit')\n      t.equal(mimetype, 'text/markdown')\n      stream.resume()\n    }\n  })\n\n  fastify.post('/', {\n    schema: {\n      body: {\n        type: 'object',\n        required: ['myField', 'myFile'],\n        properties: {\n          myField: { type: 'string' },\n          myFile: { type: 'array', items: fastify.getSchema('mySharedSchema') }\n        }\n      }\n    }\n  }, function (req, reply) {\n    t.equal(req.body.myField, 'hello')\n    t.match(req.body.myFile, [{\n      data: [],\n      encoding: '7bit',\n      filename: 'README.md',\n      limit: false,\n      mimetype: 'text/markdown'\n    }])\n    reply.send('ok')\n  })\n\n  await fastify.listen(0)\n\n  // request\n  const form = new FormData()\n  const opts = {\n    protocol: 'http:',\n    hostname: 'localhost',\n    port: fastify.server.address().port,\n    path: '/',\n    headers: form.getHeaders(),\n    method: 'POST'\n  }\n\n  return new Promise((resolve, reject) => {\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 200)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n        fastify.close()\n        resolve()\n      })\n    })\n\n    const rs = fs.createReadStream(filePath)\n    form.append('myField', 'hello')\n    form.append('myFile', rs)\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('addToBody with shared schema error', { skip: process.platform === 'win32' }, (t) => {\n  t.plan(3)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.register(multipart, {\n    addToBody: true,\n    sharedSchemaId: 'mySharedSchema'\n  }).then(() => {\n    fastify.post('/', {\n      schema: {\n        body: {\n          type: 'object',\n          required: ['myField', 'myFile'],\n          properties: {\n            myField: { type: 'string' },\n            myFile: { type: 'array', items: fastify.getSchema('mySharedSchema') }\n          }\n        }\n      }\n    }, function (req, reply) {\n      reply.send('ok')\n    })\n\n    fastify.listen(0, function () {\n      // request\n      const form = new FormData()\n      const opts = {\n        protocol: 'http:',\n        hostname: 'localhost',\n        port: fastify.server.address().port,\n        path: '/',\n        headers: form.getHeaders(),\n        method: 'POST'\n      }\n\n      const req = http.request(opts, (res) => {\n        t.equal(res.statusCode, 400)\n        res.resume()\n        res.on('end', () => {\n          t.pass('res ended successfully')\n        })\n      })\n\n      const rs = fs.createReadStream(filePath)\n      // missing the myField parameter\n      form.append('myFile', rs)\n      pump(form, req, function (err) {\n        t.error(err, 'client pump: no err')\n      })\n    })\n  })\n})\n\ntest('addToBody without files and shared schema', { skip: process.platform === 'win32' }, t => {\n  t.plan(5)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  const opts = {\n    addToBody: true,\n    sharedSchemaId: 'mySharedSchema',\n    onFile: (fieldName, stream, filename, encoding, mimetype) => {\n      t.fail('there are not stream')\n    }\n  }\n  fastify.register(multipart, opts)\n\n  fastify.post('/', {\n    schema: {\n      body: {\n        type: 'object',\n        required: ['myField', 'myField2'],\n        properties: {\n          myField: { type: 'string' },\n          myField2: { type: 'string' }\n        }\n      }\n    }\n  }, function (req, reply) {\n    t.equal(req.body.myField, 'hello')\n    t.equal(req.body.myField2, 'world')\n\n    reply.send('ok')\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 200)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n\n    form.append('myField', 'hello')\n    form.append('myField2', 'world')\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('addToBody option does not change behaviour on not-multipart request', { skip: process.platform === 'win32' }, t => {\n  t.plan(2)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.register(multipart, { addToBody: true })\n  fastify.get('/', async (req, rep) => { rep.send('hello') })\n  fastify.post('/', function (req, reply) { })\n\n  fastify.listen(0, function () {\n    fastify.inject({\n      method: 'GET',\n      url: '/',\n      port: fastify.server.address().port\n    }, (err, res) => {\n      t.error(err)\n      t.equal(res.payload, 'hello')\n    })\n  })\n})\n\ntest('addToBody with __proto__ field', t => {\n  t.plan(3)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  const opts = {\n    addToBody: true,\n    onFile: (fieldName, stream, filename, encoding, mimetype) => {\n      t.fail('there are not stream')\n    }\n  }\n  fastify.register(multipart, opts)\n\n  fastify.post('/', function (req, reply) {\n    t.fail('should not be called')\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 500)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n\n    form.append('myField', 'hello')\n    form.append('__proto__', 'world')\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n", "'use strict'\nconst os = require('os')\nconst test = require('tap').test\nconst FormData = require('form-data')\nconst Fastify = require('fastify')\nconst multipart = require('./../..')\nconst http = require('http')\nconst path = require('path')\nconst fs = require('fs')\nconst concat = require('concat-stream')\nconst stream = require('readable-stream')\nconst pump = stream.pipeline\nconst eos = stream.finished\n\nconst filePath = path.join(__dirname, '..', '..', 'README.md')\n\ntest('should parse forms', { skip: process.platform === 'win32' }, function (t) {\n  t.plan(14)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.register(multipart, { limits: { fields: 1 } })\n\n  fastify.post('/', function (req, reply) {\n    t.ok(req.isMultipart())\n\n    const mp = req.multipart(handler, function (err) {\n      t.error(err)\n      reply.code(200).send()\n    })\n\n    mp.on('field', function (name, value) {\n      t.not(name, 'willbe', 'Busboy fields limit ignored')\n      t.not(value, 'dropped', 'Busboy fields limit ignored')\n      t.equal(name, 'hello')\n      t.equal(value, 'world')\n    })\n\n    function handler (field, file, filename, encoding, mimetype) {\n      t.equal(filename, 'README.md')\n      t.equal(field, 'upload')\n      t.equal(encoding, '7bit')\n      t.equal(mimetype, 'text/markdown')\n      file.on('fieldsLimit', () => t.ok('field limit reached'))\n      const original = fs.readFileSync(filePath, 'utf8')\n      file.pipe(concat(function (buf) {\n        t.equal(buf.toString(), original)\n      }))\n    }\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 200)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n    const rs = fs.createReadStream(filePath)\n    form.append('upload', rs)\n    form.append('hello', 'world')\n    form.append('willbe', 'dropped')\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('should call finished when both files are pumped', { skip: process.platform === 'win32' }, function (t) {\n  t.plan(10)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.register(multipart)\n\n  fastify.post('/', function (req, reply) {\n    let fileCount = 0\n    t.ok(req.isMultipart())\n\n    req.multipart(handler, function (err) {\n      t.error(err)\n      t.equal(fileCount, 2)\n      reply.code(200).send()\n    })\n\n    function handler (field, file, filename, encoding, mimetype) {\n      const saveTo = path.join(os.tmpdir(), path.basename(filename))\n      eos(file, function (err) {\n        t.error(err)\n        fileCount++\n      })\n\n      pump(file, fs.createWriteStream(saveTo), function (err) {\n        t.error(err)\n      })\n    }\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 200)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n    form.append('upload', fs.createReadStream(filePath))\n    form.append('upload2', fs.createReadStream(filePath))\n    form.append('hello', 'world')\n    form.append('willbe', 'dropped')\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('should call finished if one of the streams closes prematurely', { skip: process.platform === 'win32' }, function (t) {\n  t.plan(5)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.register(multipart)\n\n  fastify.post('/', function (req, reply) {\n    let fileCount = 0\n    t.ok(req.isMultipart())\n\n    req.multipart(handler, function () {\n      t.equal(fileCount, 1)\n      reply.code(200).send()\n    })\n\n    function handler (field, file, filename, encoding, mimetype) {\n      const saveTo = path.join(os.tmpdir(), path.basename(filename))\n      eos(file, function () {\n        fileCount++\n      })\n\n      file.on('data', function () {\n        if (fileCount === 0) {\n          this.destroy()\n        }\n      })\n\n      pump(file, fs.createWriteStream(saveTo), () => {})\n    }\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const stream1 = fs.createReadStream(filePath)\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 200)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n\n    form.append('upload1', stream1, {\n      filename: 'random-data1'\n    })\n    form.append('upload2', stream1, {\n      filename: 'random-data2'\n    })\n\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('should error if it is not multipart', { skip: process.platform === 'win32' }, function (t) {\n  t.plan(4)\n\n  const fastify = Fastify()\n\n  t.teardown(fastify.close.bind(fastify))\n  fastify.register(multipart)\n\n  fastify.post('/', function (req, reply) {\n    t.notOk(req.isMultipart())\n\n    req.multipart(handler, function (err) {\n      t.ok(err)\n      t.equal(err.message, 'the request is not multipart')\n      reply.code(500).send()\n    })\n\n    function handler (field, file, filename, encoding, mimetype) {\n      t.fail('this should never be called')\n    }\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      headers: {\n        'content-type': 'application/json'\n      },\n      path: '/',\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 500)\n    })\n    req.end(JSON.stringify({ hello: 'world' }))\n  })\n})\n\ntest('should error if handler is not a function', { skip: process.platform === 'win32' }, function (t) {\n  t.plan(3)\n\n  const fastify = Fastify()\n\n  t.teardown(fastify.close.bind(fastify))\n  fastify.register(multipart)\n\n  fastify.post('/', function (req, reply) {\n    const handler = null\n\n    req.multipart(handler, function (err) {\n      t.ok(err)\n      reply.code(500).send()\n    })\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      res.resume()\n      res.on('end', () => {\n        t.equal(res.statusCode, 500)\n        t.pass('res ended successfully')\n      })\n    })\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('should error if callback is not a function', { skip: process.platform === 'win32' }, function (t) {\n  t.plan(3)\n\n  const fastify = Fastify()\n\n  t.teardown(fastify.close.bind(fastify))\n  fastify.register(multipart)\n\n  fastify.post('/', function (req) {\n    const callback = null\n    req.multipart(handler, callback)\n\n    function handler () {}\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      res.resume()\n      res.on('end', () => {\n        t.equal(res.statusCode, 500)\n        t.pass('res ended successfully')\n      })\n    })\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('should error if it is invalid multipart', { skip: process.platform === 'win32' }, function (t) {\n  t.plan(5)\n\n  const fastify = Fastify()\n\n  t.teardown(fastify.close.bind(fastify))\n  fastify.register(multipart)\n\n  fastify.post('/', function (req, reply) {\n    t.ok(req.isMultipart())\n\n    req.multipart(handler, function (err) {\n      t.ok(err)\n      t.equal(err.message, 'Multipart: Boundary not found')\n      reply.code(500).send()\n    })\n\n    function handler (field, file, filename, encoding, mimetype) {\n      t.fail('this should never be called')\n    }\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      headers: {\n        'content-type': 'multipart/form-data'\n      },\n      path: '/',\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 500)\n    })\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('should override options', { skip: process.platform === 'win32' }, function (t) {\n  t.plan(5)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.register(multipart, { limits: { fileSize: 1 } })\n\n  fastify.post('/', function (req, reply) {\n    const mp = req.multipart(handler, function (err) {\n      t.error(err)\n      reply.code(200).send()\n    }, { limits: { fileSize: 2 } })\n\n    t.equal(mp.opts.limits.fileSize, 2, 'options.limits.fileSize was updated successfully')\n\n    function handler (field, file, filename, encoding, mimetype) {\n      file.pipe(concat(function (buf) { }))\n    }\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 200)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n\n    const rs = fs.createReadStream(filePath)\n    form.append('upload', rs)\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('should not allow __proto__', { skip: process.platform === 'win32' }, function (t) {\n  t.plan(5)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.register(multipart, { limits: { fields: 1 } })\n\n  fastify.post('/', function (req, reply) {\n    t.ok(req.isMultipart())\n\n    const mp = req.multipart(handler, function (err) {\n      t.equal(err.message, '__proto__ is not allowed as field name')\n      reply.code(500).send()\n    })\n\n    mp.on('field', function (name, value) {\n      t.fail('should not be called')\n    })\n\n    function handler (field, file, filename, encoding, mimetype) {\n      t.fail('should not be called')\n    }\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 500)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n    const rs = fs.createReadStream(filePath)\n    form.append('__proto__', rs)\n    // form.append('hello', 'world')\n    // form.append('willbe', 'dropped')\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n"], "fixing_code": ["'use strict'\n\nconst Busboy = require('@fastify/busboy')\nconst os = require('os')\nconst fp = require('fastify-plugin')\nconst eos = require('end-of-stream')\nconst { createWriteStream } = require('fs')\nconst { unlink } = require('fs').promises\nconst path = require('path')\nconst hexoid = require('hexoid')\nconst util = require('util')\nconst createError = require('fastify-error')\nconst sendToWormhole = require('stream-wormhole')\nconst deepmerge = require('deepmerge')\nconst { PassThrough, pipeline } = require('stream')\nconst pump = util.promisify(pipeline)\nconst secureJSON = require('secure-json-parse')\n\nconst kMultipart = Symbol('multipart')\nconst kMultipartHandler = Symbol('multipartHandler')\nconst getDescriptor = Object.getOwnPropertyDescriptor\n\nfunction setMultipart (req, payload, done) {\n  // nothing to do, it will be done by the Request.multipart object\n  req.raw[kMultipart] = true\n  done()\n}\n\nfunction attachToBody (options, req, reply, next) {\n  if (req.raw[kMultipart] !== true) {\n    next()\n    return\n  }\n\n  const consumerStream = options.onFile || defaultConsumer\n  const body = {}\n  const mp = req.multipart((field, file, filename, encoding, mimetype) => {\n    body[field] = body[field] || []\n    body[field].push({\n      data: [],\n      filename,\n      encoding,\n      mimetype,\n      limit: false\n    })\n\n    const result = consumerStream(field, file, filename, encoding, mimetype, body)\n    if (result && typeof result.then === 'function') {\n      result.catch((err) => {\n        // continue with the workflow\n        err.statusCode = 500\n        file.destroy(err)\n      })\n    }\n  }, function (err) {\n    if (!err) {\n      req.body = body\n    }\n    next(err)\n  }, options)\n\n  mp.on('field', (key, value) => {\n    if (key === '__proto__' || key === 'constructor') {\n      mp.destroy(new Error(`${key} is not allowed as field name`))\n      return\n    }\n    if (body[key] === undefined) {\n      body[key] = value\n    } else if (Array.isArray(body[key])) {\n      body[key].push(value)\n    } else {\n      body[key] = [body[key], value]\n    }\n  })\n}\n\nfunction defaultConsumer (field, file, filename, encoding, mimetype, body) {\n  const fileData = []\n  const lastFile = body[field][body[field].length - 1]\n  file.on('data', data => { if (!lastFile.limit) { fileData.push(data) } })\n  file.on('limit', () => { lastFile.limit = true })\n  file.on('end', () => {\n    if (!lastFile.limit) {\n      lastFile.data = Buffer.concat(fileData)\n    } else {\n      lastFile.data = undefined\n    }\n  })\n}\n\nfunction busboy (options) {\n  try {\n    return new Busboy(options)\n  } catch (error) {\n    const errorEmitter = new PassThrough()\n    process.nextTick(function () {\n      errorEmitter.emit('error', error)\n    })\n    return errorEmitter\n  }\n}\n\nfunction fastifyMultipart (fastify, options, done) {\n  if (options.addToBody === true) {\n    if (typeof options.sharedSchemaId === 'string') {\n      fastify.addSchema({\n        $id: options.sharedSchemaId,\n        type: 'object',\n        properties: {\n          encoding: { type: 'string' },\n          filename: { type: 'string' },\n          limit: { type: 'boolean' },\n          mimetype: { type: 'string' }\n        }\n      })\n    }\n\n    fastify.addHook('preValidation', function (req, reply, next) {\n      attachToBody(options, req, reply, next)\n    })\n  }\n\n  if (options.attachFieldsToBody === true) {\n    if (typeof options.sharedSchemaId === 'string') {\n      fastify.addSchema({\n        $id: options.sharedSchemaId,\n        type: 'object',\n        properties: {\n          fieldname: { type: 'string' },\n          encoding: { type: 'string' },\n          filename: { type: 'string' },\n          mimetype: { type: 'string' }\n        }\n      })\n    }\n    fastify.addHook('preValidation', async function (req, reply) {\n      if (!req.isMultipart()) {\n        return\n      }\n      for await (const part of req.parts()) {\n        req.body = part.fields\n        if (part.file) {\n          if (options.onFile) {\n            await options.onFile(part)\n          } else {\n            await part.toBuffer()\n          }\n        }\n      }\n    })\n  }\n\n  let throwFileSizeLimit = true\n  if (typeof options.throwFileSizeLimit === 'boolean') {\n    throwFileSizeLimit = options.throwFileSizeLimit\n  }\n\n  const PartsLimitError = createError('FST_PARTS_LIMIT', 'reach parts limit', 413)\n  const FilesLimitError = createError('FST_FILES_LIMIT', 'reach files limit', 413)\n  const FieldsLimitError = createError('FST_FIELDS_LIMIT', 'reach fields limit', 413)\n  const RequestFileTooLargeError = createError('FST_REQ_FILE_TOO_LARGE', 'request file too large, please check multipart config', 413)\n  const PrototypeViolationError = createError('FST_PROTO_VIOLATION', 'prototype property is not allowed as field name', 400)\n  const InvalidMultipartContentTypeError = createError('FST_INVALID_MULTIPART_CONTENT_TYPE', 'the request is not multipart', 406)\n  const InvalidJSONFieldError = createError('FST_INVALID_JSON_FIELD_ERROR', 'a request field is not a valid JSON as declared by its Content-Type', 406)\n\n  fastify.decorate('multipartErrors', {\n    PartsLimitError,\n    FilesLimitError,\n    FieldsLimitError,\n    PrototypeViolationError,\n    InvalidMultipartContentTypeError,\n    RequestFileTooLargeError\n  })\n\n  fastify.addContentTypeParser('multipart', setMultipart)\n  fastify.decorateRequest(kMultipartHandler, handleMultipart)\n\n  fastify.decorateRequest('parts', getMultipartIterator)\n\n  fastify.decorateRequest('isMultipart', isMultipart)\n  fastify.decorateRequest('tmpUploads', null)\n\n  // legacy\n  fastify.decorateRequest('multipart', handleLegacyMultipartApi)\n\n  // Stream mode\n  fastify.decorateRequest('file', getMultipartFile)\n  fastify.decorateRequest('files', getMultipartFiles)\n\n  // Disk mode\n  fastify.decorateRequest('saveRequestFiles', saveRequestFiles)\n  fastify.decorateRequest('cleanRequestFiles', cleanRequestFiles)\n\n  fastify.addHook('onResponse', async (request, reply) => {\n    await request.cleanRequestFiles()\n  })\n\n  const toID = hexoid()\n\n  function isMultipart () {\n    return this.raw[kMultipart] || false\n  }\n\n  // handler definition is in multipart-readstream\n  // handler(field, file, filename, encoding, mimetype)\n  // opts is a per-request override for the options object\n  function handleLegacyMultipartApi (handler, done, opts) {\n    if (typeof handler !== 'function') {\n      throw new Error('handler must be a function')\n    }\n\n    if (typeof done !== 'function') {\n      throw new Error('the callback must be a function')\n    }\n\n    if (!this.isMultipart()) {\n      done(new Error('the request is not multipart'))\n      return\n    }\n\n    const log = this.log\n\n    log.warn('the multipart callback-based api is deprecated in favour of the new promise api')\n    log.debug('starting multipart parsing')\n\n    const req = this.raw\n\n    const busboyOptions = deepmerge.all([{ headers: Object.assign({}, req.headers) }, options || {}, opts || {}])\n    const stream = busboy(busboyOptions)\n    let completed = false\n    let files = 0\n\n    req.on('error', function (err) {\n      stream.destroy()\n      if (!completed) {\n        completed = true\n        done(err)\n      }\n    })\n\n    stream.on('finish', function () {\n      log.debug('finished receiving stream, total %d files', files)\n      if (!completed) {\n        completed = true\n        setImmediate(done)\n      }\n    })\n\n    stream.on('file', wrap)\n\n    req.pipe(stream)\n      .on('error', function (error) {\n        req.emit('error', error)\n      })\n\n    function wrap (field, file, filename, encoding, mimetype) {\n      log.debug({ field, filename, encoding, mimetype }, 'parsing part')\n      files++\n      eos(file, waitForFiles)\n      if (field === '__proto__' || field === 'constructor') {\n        file.destroy(new Error(`${field} is not allowed as field name`))\n        return\n      }\n      handler(field, file, filename, encoding, mimetype)\n    }\n\n    function waitForFiles (err) {\n      if (err) {\n        completed = true\n        done(err)\n      }\n    }\n\n    return stream\n  }\n\n  function handleMultipart (opts = {}) {\n    if (!this.isMultipart()) {\n      throw new InvalidMultipartContentTypeError()\n    }\n\n    this.log.debug('starting multipart parsing')\n\n    let values = []\n    let pendingHandler = null\n\n    // only one file / field can be processed at a time\n    // \"null\" will close the consumer side\n    const ch = (val) => {\n      if (pendingHandler) {\n        pendingHandler(val)\n        pendingHandler = null\n      } else {\n        values.push(val)\n      }\n    }\n\n    const handle = (handler) => {\n      if (values.length > 0) {\n        const value = values[0]\n        values = values.slice(1)\n        handler(value)\n      } else {\n        pendingHandler = handler\n      }\n    }\n\n    const parts = () => {\n      return new Promise((resolve, reject) => {\n        handle((val) => {\n          if (val instanceof Error) return reject(val)\n          resolve(val)\n        })\n      })\n    }\n\n    const body = {}\n    let lastError = null\n    let currentFile = null\n    const request = this.raw\n    const busboyOptions = deepmerge.all([\n      { headers: Object.assign({}, request.headers) },\n      options,\n      opts\n    ])\n\n    this.log.trace({ busboyOptions }, 'Providing options to busboy')\n    const bb = busboy(busboyOptions)\n\n    request.on('close', cleanup)\n    request.on('error', cleanup)\n\n    bb\n      .on('field', onField)\n      .on('file', onFile)\n      .on('close', cleanup)\n      .on('error', onEnd)\n      .on('end', onEnd)\n      .on('finish', onEnd)\n\n    bb.on('partsLimit', function () {\n      onError(new PartsLimitError())\n    })\n\n    bb.on('filesLimit', function () {\n      onError(new FilesLimitError())\n    })\n\n    bb.on('fieldsLimit', function () {\n      onError(new FieldsLimitError())\n    })\n\n    request.pipe(bb)\n\n    function onField (name, fieldValue, fieldnameTruncated, valueTruncated, encoding, contentType) {\n      let mimetype\n\n      // don't overwrite prototypes\n      if (getDescriptor(Object.prototype, name)) {\n        onError(new PrototypeViolationError())\n        return\n      }\n\n      // If it is a JSON field, parse it\n      if (contentType.startsWith('application/json')) {\n        // If the value was truncated, it can never be a valid JSON. Don't even try to parse\n        if (valueTruncated) {\n          onError(new InvalidJSONFieldError())\n          return\n        }\n\n        try {\n          fieldValue = secureJSON.parse(fieldValue)\n          mimetype = 'application/json'\n        } catch (e) {\n          onError(new InvalidJSONFieldError())\n          return\n        }\n      }\n\n      const value = {\n        fieldname: name,\n        mimetype,\n        encoding,\n        value: fieldValue,\n        fieldnameTruncated,\n        valueTruncated,\n        fields: body\n      }\n\n      if (body[name] === undefined) {\n        body[name] = value\n      } else if (Array.isArray(body[name])) {\n        body[name].push(value)\n      } else {\n        body[name] = [body[name], value]\n      }\n\n      ch(value)\n    }\n\n    function onFile (name, file, filename, encoding, mimetype) {\n      // don't overwrite prototypes\n      if (getDescriptor(Object.prototype, name)) {\n        // ensure that stream is consumed, any error is suppressed\n        sendToWormhole(file)\n        onError(new PrototypeViolationError())\n        return\n      }\n\n      if (typeof opts.throwFileSizeLimit === 'boolean') {\n        throwFileSizeLimit = opts.throwFileSizeLimit\n      }\n\n      const value = {\n        fieldname: name,\n        filename,\n        encoding,\n        mimetype,\n        file,\n        fields: body,\n        _buf: null,\n        async toBuffer () {\n          if (this._buf) {\n            return this._buf\n          }\n          const fileChunks = []\n          for await (const chunk of this.file) {\n            fileChunks.push(chunk)\n\n            if (throwFileSizeLimit && this.file.truncated) {\n              const err = new RequestFileTooLargeError()\n              err.part = this\n\n              onError(err)\n              throw err\n            }\n          }\n          this._buf = Buffer.concat(fileChunks)\n          return this._buf\n        }\n      }\n\n      if (throwFileSizeLimit) {\n        file.on('limit', function () {\n          const err = new RequestFileTooLargeError()\n          err.part = value\n          onError(err)\n        })\n      }\n\n      if (body[name] === undefined) {\n        body[name] = value\n      } else if (Array.isArray(body[name])) {\n        body[name].push(value)\n      } else {\n        body[name] = [body[name], value]\n      }\n      currentFile = file\n      ch(value)\n    }\n\n    function onError (err) {\n      lastError = err\n      currentFile = null\n    }\n\n    function onEnd (err) {\n      cleanup()\n\n      ch(err || lastError)\n    }\n\n    function cleanup (err) {\n      request.unpipe(bb)\n      // in node 10 it seems that error handler is not called but request.aborted is set\n      if ((err || request.aborted) && currentFile) {\n        currentFile.destroy()\n      }\n    }\n\n    return parts\n  }\n\n  async function saveRequestFiles (options) {\n    const requestFiles = []\n    const tmpdir = (options && options.tmpdir) || os.tmpdir()\n\n    const files = await this.files(options)\n    this.tmpUploads = []\n    for await (const file of files) {\n      const filepath = path.join(tmpdir, toID() + path.extname(file.filename))\n      const target = createWriteStream(filepath)\n      try {\n        await pump(file.file, target)\n        requestFiles.push({ ...file, filepath })\n        this.tmpUploads.push(filepath)\n      } catch (err) {\n        this.log.error({ err }, 'save request file')\n        throw err\n      }\n    }\n\n    return requestFiles\n  }\n\n  async function cleanRequestFiles () {\n    if (!this.tmpUploads) {\n      return\n    }\n    for (const filepath of this.tmpUploads) {\n      try {\n        await unlink(filepath)\n      } catch (error) {\n        this.log.error(error, 'could not delete file')\n      }\n    }\n  }\n\n  async function getMultipartFile (options) {\n    const parts = this[kMultipartHandler](options)\n    let part\n    while ((part = await parts()) != null) {\n      if (part.file) {\n        // part.file.truncated is true when a configured file size limit is reached\n        if (part.file.truncated && throwFileSizeLimit) {\n          throw new RequestFileTooLargeError()\n        }\n        return part\n      }\n    }\n  }\n\n  async function * getMultipartFiles (options) {\n    const parts = this[kMultipartHandler](options)\n\n    let part\n    while ((part = await parts()) != null) {\n      if (part.file) {\n        yield part\n      }\n    }\n  }\n\n  async function * getMultipartIterator (options) {\n    const parts = this[kMultipartHandler](options)\n\n    let part\n    while ((part = await parts()) != null) {\n      yield part\n    }\n  }\n\n  done()\n}\n\nmodule.exports = fp(fastifyMultipart, {\n  fastify: '>= 0.39.0',\n  name: 'fastify-multipart'\n})\n", "'use strict'\nconst test = require('tap').test\nconst FormData = require('form-data')\nconst Fastify = require('fastify')\nconst multipart = require('./../..')\nconst http = require('http')\nconst path = require('path')\nconst fs = require('fs')\nconst pump = require('pump')\n\nconst filePath = path.join(__dirname, '..', '..', 'README.md')\n\ntest('addToBody option', { skip: process.platform === 'win32' }, t => {\n  t.plan(8)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.register(multipart, { addToBody: true })\n\n  fastify.post('/', function (req, reply) {\n    t.equal(req.body.myField, 'hello')\n    t.equal(req.body.myCheck, 'true')\n    t.match(req.body.myFile, [{\n      encoding: '7bit',\n      filename: 'README.md',\n      limit: false,\n      mimetype: 'text/markdown'\n    }])\n    t.type(req.body.myFile[0].data, Buffer)\n    t.equal(req.body.myFile[0].data.toString('utf8').substr(0, 19), '# fastify-multipart')\n\n    reply.send('ok')\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 200)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n\n    const rs = fs.createReadStream(filePath)\n    form.append('myField', 'hello')\n    form.append('myCheck', 'true')\n    form.append('myFile', rs)\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('addToBody with limit exceeded', { skip: process.platform === 'win32' }, t => {\n  t.plan(5)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.register(multipart, { addToBody: true, limits: { fileSize: 1 } })\n\n  fastify.post('/', function (req, reply) {\n    t.equal(req.body.myFile[0].limit, true)\n    t.equal(req.body.myFile[0].data, undefined)\n\n    reply.send('ok')\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 200)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n\n    const rs = fs.createReadStream(filePath)\n    form.append('myFile', rs)\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('addToBody option and multiple files', { skip: process.platform === 'win32' }, t => {\n  t.plan(7)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  let fileCounter = 0\n  const opts = {\n    addToBody: true,\n    onFile: (fieldName, stream, filename, encoding, mimetype) => {\n      fileCounter++\n      stream.resume()\n    }\n  }\n  fastify.register(multipart, opts)\n\n  fastify.post('/', function (req, reply) {\n    t.match(req.body.myFile, [{\n      data: [],\n      encoding: '7bit',\n      filename: 'README.md',\n      limit: false,\n      mimetype: 'text/markdown'\n    }])\n\n    t.match(req.body.myFileTwo, [{\n      data: [],\n      encoding: '7bit',\n      filename: 'README.md',\n      limit: false,\n      mimetype: 'text/markdown'\n    }])\n\n    t.match(req.body.myFileThree, [{\n      data: [],\n      encoding: '7bit',\n      filename: 'README.md',\n      limit: false,\n      mimetype: 'text/markdown'\n    }])\n\n    t.equal(fileCounter, 3, 'We must receive 3 file events')\n    reply.send('ok')\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 200)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n\n    const rs1 = fs.createReadStream(filePath)\n    const rs2 = fs.createReadStream(filePath)\n    const rs3 = fs.createReadStream(filePath)\n    form.append('myFile', rs1)\n    form.append('myFileTwo', rs2)\n    form.append('myFileThree', rs3)\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('addToBody option and multiple files in one field', { skip: process.platform === 'win32' }, t => {\n  t.plan(7)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  const opts = {\n    addToBody: true\n  }\n  fastify.register(multipart, opts)\n\n  fastify.post('/', function (req, reply) {\n    t.match(req.body.myFile, [{\n      encoding: '7bit',\n      filename: 'README.md',\n      limit: false,\n      mimetype: 'text/markdown'\n    }, {\n      encoding: '7bit',\n      filename: 'LICENSE',\n      limit: false,\n      mimetype: 'application/octet-stream'\n    }, {\n      encoding: '7bit',\n      filename: 'form.html',\n      limit: false,\n      mimetype: 'text/html'\n    }])\n    req.body.myFile.forEach(x => {\n      t.equal(Buffer.isBuffer(x.data), true)\n    })\n    reply.send('ok')\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 200)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n\n    const rs1 = fs.createReadStream(path.join(__dirname, '..', '..', 'README.md'))\n    const rs2 = fs.createReadStream(path.join(__dirname, '..', '..', 'LICENSE'))\n    const rs3 = fs.createReadStream(path.join(__dirname, '..', '..', 'form.html'))\n    form.append('myFile', rs1)\n    form.append('myFile', rs2)\n    form.append('myFile', rs3)\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('addToBody option and multiple strings in one field', { skip: process.platform === 'win32' }, t => {\n  t.plan(4)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  const opts = {\n    addToBody: true\n  }\n  fastify.register(multipart, opts)\n\n  fastify.post('/', function (req, reply) {\n    t.match(req.body.myField, ['1', '2', '3'])\n\n    reply.send('ok')\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 200)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n\n    form.append('myField', '1')\n    form.append('myField', '2')\n    form.append('myField', '3')\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('addToBody option and custom stream management', { skip: process.platform === 'win32' }, t => {\n  t.plan(7)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  const opts = {\n    addToBody: true,\n    onFile: (fieldName, stream, filename, encoding, mimetype) => {\n      t.equal(fieldName, 'myFile')\n      stream.resume()\n    }\n  }\n  fastify.register(multipart, opts)\n\n  fastify.post('/', function (req, reply) {\n    t.equal(req.body.myField, 'hello')\n    t.equal(req.body.myCheck, 'true')\n    t.match(req.body.myFile, [{\n      data: [],\n      encoding: '7bit',\n      filename: 'README.md',\n      limit: false,\n      mimetype: 'text/markdown'\n    }])\n\n    reply.send('ok')\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 200)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n\n    const rs = fs.createReadStream(filePath)\n    form.append('myField', 'hello')\n    form.append('myCheck', 'true')\n    form.append('myFile', rs)\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('addToBody option with promise', { skip: process.platform === 'win32' }, t => {\n  t.plan(5)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  const opts = {\n    addToBody: true,\n    onFile: async (fieldName, stream, filename, encoding, mimetype) => {\n      await new Promise(resolve => setTimeout(resolve, 10))\n      t.equal(fieldName, 'myFile')\n      stream.resume()\n    }\n  }\n  fastify.register(multipart, opts)\n\n  fastify.post('/', function (req, reply) {\n    t.match(req.body.myFile, [{\n      data: [],\n      encoding: '7bit',\n      filename: 'README.md',\n      limit: false,\n      mimetype: 'text/markdown'\n    }])\n\n    reply.send('ok')\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 200)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n\n    const rs = fs.createReadStream(filePath)\n    form.append('myFile', rs)\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('addToBody option with promise in error', { skip: process.platform === 'win32' }, t => {\n  t.plan(3)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  const opts = {\n    addToBody: true,\n    onFile: (fieldName, stream, filename, encoding, mimetype) => {\n      return Promise.reject(new Error('my error'))\n    }\n  }\n  fastify.register(multipart, opts)\n\n  fastify.post('/', function (req, reply) {\n    t.fail('should not execute the handler')\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 500)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n\n    const rs = fs.createReadStream(filePath)\n    form.append('myFile', rs)\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('addToBody with shared schema', { skip: process.platform === 'win32' }, (t) => {\n  t.plan(9)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.register(multipart, {\n    addToBody: true,\n    sharedSchemaId: 'mySharedSchema',\n    onFile: (fieldName, stream, filename, encoding, mimetype) => {\n      t.equal(fieldName, 'myFile')\n      t.equal(filename, 'README.md')\n      t.equal(encoding, '7bit')\n      t.equal(mimetype, 'text/markdown')\n      stream.resume()\n    }\n  })\n\n  fastify.after(() => {\n    fastify.post('/', {\n      schema: {\n        body: {\n          type: 'object',\n          required: ['myField', 'myFile'],\n          properties: {\n            myField: { type: 'string' },\n            myFile: { type: 'array', items: fastify.getSchema('mySharedSchema') }\n          }\n        }\n      }\n    }, function (req, reply) {\n      t.equal(req.body.myField, 'hello')\n      t.match(req.body.myFile, [{\n        data: [],\n        encoding: '7bit',\n        filename: 'README.md',\n        limit: false,\n        mimetype: 'text/markdown'\n      }])\n      reply.send('ok')\n    })\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 200)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n        fastify.close()\n        t.end()\n      })\n    })\n\n    const rs = fs.createReadStream(filePath)\n    form.append('myField', 'hello')\n    form.append('myFile', rs)\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('addToBody with shared schema (async/await)', { skip: process.platform === 'win32' }, async (t) => {\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  await fastify.register(multipart, {\n    addToBody: true,\n    sharedSchemaId: 'mySharedSchema',\n    onFile: (fieldName, stream, filename, encoding, mimetype) => {\n      t.equal(fieldName, 'myFile')\n      t.equal(filename, 'README.md')\n      t.equal(encoding, '7bit')\n      t.equal(mimetype, 'text/markdown')\n      stream.resume()\n    }\n  })\n\n  fastify.post('/', {\n    schema: {\n      body: {\n        type: 'object',\n        required: ['myField', 'myFile'],\n        properties: {\n          myField: { type: 'string' },\n          myFile: { type: 'array', items: fastify.getSchema('mySharedSchema') }\n        }\n      }\n    }\n  }, function (req, reply) {\n    t.equal(req.body.myField, 'hello')\n    t.match(req.body.myFile, [{\n      data: [],\n      encoding: '7bit',\n      filename: 'README.md',\n      limit: false,\n      mimetype: 'text/markdown'\n    }])\n    reply.send('ok')\n  })\n\n  await fastify.listen(0)\n\n  // request\n  const form = new FormData()\n  const opts = {\n    protocol: 'http:',\n    hostname: 'localhost',\n    port: fastify.server.address().port,\n    path: '/',\n    headers: form.getHeaders(),\n    method: 'POST'\n  }\n\n  return new Promise((resolve, reject) => {\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 200)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n        fastify.close()\n        resolve()\n      })\n    })\n\n    const rs = fs.createReadStream(filePath)\n    form.append('myField', 'hello')\n    form.append('myFile', rs)\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('addToBody with shared schema error', { skip: process.platform === 'win32' }, (t) => {\n  t.plan(3)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.register(multipart, {\n    addToBody: true,\n    sharedSchemaId: 'mySharedSchema'\n  }).then(() => {\n    fastify.post('/', {\n      schema: {\n        body: {\n          type: 'object',\n          required: ['myField', 'myFile'],\n          properties: {\n            myField: { type: 'string' },\n            myFile: { type: 'array', items: fastify.getSchema('mySharedSchema') }\n          }\n        }\n      }\n    }, function (req, reply) {\n      reply.send('ok')\n    })\n\n    fastify.listen(0, function () {\n      // request\n      const form = new FormData()\n      const opts = {\n        protocol: 'http:',\n        hostname: 'localhost',\n        port: fastify.server.address().port,\n        path: '/',\n        headers: form.getHeaders(),\n        method: 'POST'\n      }\n\n      const req = http.request(opts, (res) => {\n        t.equal(res.statusCode, 400)\n        res.resume()\n        res.on('end', () => {\n          t.pass('res ended successfully')\n        })\n      })\n\n      const rs = fs.createReadStream(filePath)\n      // missing the myField parameter\n      form.append('myFile', rs)\n      pump(form, req, function (err) {\n        t.error(err, 'client pump: no err')\n      })\n    })\n  })\n})\n\ntest('addToBody without files and shared schema', { skip: process.platform === 'win32' }, t => {\n  t.plan(5)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  const opts = {\n    addToBody: true,\n    sharedSchemaId: 'mySharedSchema',\n    onFile: (fieldName, stream, filename, encoding, mimetype) => {\n      t.fail('there are not stream')\n    }\n  }\n  fastify.register(multipart, opts)\n\n  fastify.post('/', {\n    schema: {\n      body: {\n        type: 'object',\n        required: ['myField', 'myField2'],\n        properties: {\n          myField: { type: 'string' },\n          myField2: { type: 'string' }\n        }\n      }\n    }\n  }, function (req, reply) {\n    t.equal(req.body.myField, 'hello')\n    t.equal(req.body.myField2, 'world')\n\n    reply.send('ok')\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 200)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n\n    form.append('myField', 'hello')\n    form.append('myField2', 'world')\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('addToBody option does not change behaviour on not-multipart request', { skip: process.platform === 'win32' }, t => {\n  t.plan(2)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.register(multipart, { addToBody: true })\n  fastify.get('/', async (req, rep) => { rep.send('hello') })\n  fastify.post('/', function (req, reply) { })\n\n  fastify.listen(0, function () {\n    fastify.inject({\n      method: 'GET',\n      url: '/',\n      port: fastify.server.address().port\n    }, (err, res) => {\n      t.error(err)\n      t.equal(res.payload, 'hello')\n    })\n  })\n})\n\ntest('addToBody with __proto__ field', t => {\n  t.plan(3)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  const opts = {\n    addToBody: true,\n    onFile: (fieldName, stream, filename, encoding, mimetype) => {\n      t.fail('there are not stream')\n    }\n  }\n  fastify.register(multipart, opts)\n\n  fastify.post('/', function (req, reply) {\n    t.fail('should not be called')\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 500)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n\n    form.append('myField', 'hello')\n    form.append('__proto__', 'world')\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('addToBody with constructor field', t => {\n  t.plan(3)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  const opts = {\n    addToBody: true,\n    onFile: (fieldName, stream, filename, encoding, mimetype) => {\n      t.fail('there are not stream')\n    }\n  }\n  fastify.register(multipart, opts)\n\n  fastify.post('/', function (req, reply) {\n    t.fail('should not be called')\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 500)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n\n    form.append('myField', 'hello')\n    form.append('constructor', 'world')\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n", "'use strict'\nconst os = require('os')\nconst test = require('tap').test\nconst FormData = require('form-data')\nconst Fastify = require('fastify')\nconst multipart = require('./../..')\nconst http = require('http')\nconst path = require('path')\nconst fs = require('fs')\nconst concat = require('concat-stream')\nconst stream = require('readable-stream')\nconst pump = stream.pipeline\nconst eos = stream.finished\n\nconst filePath = path.join(__dirname, '..', '..', 'README.md')\n\ntest('should parse forms', { skip: process.platform === 'win32' }, function (t) {\n  t.plan(14)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.register(multipart, { limits: { fields: 1 } })\n\n  fastify.post('/', function (req, reply) {\n    t.ok(req.isMultipart())\n\n    const mp = req.multipart(handler, function (err) {\n      t.error(err)\n      reply.code(200).send()\n    })\n\n    mp.on('field', function (name, value) {\n      t.not(name, 'willbe', 'Busboy fields limit ignored')\n      t.not(value, 'dropped', 'Busboy fields limit ignored')\n      t.equal(name, 'hello')\n      t.equal(value, 'world')\n    })\n\n    function handler (field, file, filename, encoding, mimetype) {\n      t.equal(filename, 'README.md')\n      t.equal(field, 'upload')\n      t.equal(encoding, '7bit')\n      t.equal(mimetype, 'text/markdown')\n      file.on('fieldsLimit', () => t.ok('field limit reached'))\n      const original = fs.readFileSync(filePath, 'utf8')\n      file.pipe(concat(function (buf) {\n        t.equal(buf.toString(), original)\n      }))\n    }\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 200)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n    const rs = fs.createReadStream(filePath)\n    form.append('upload', rs)\n    form.append('hello', 'world')\n    form.append('willbe', 'dropped')\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('should call finished when both files are pumped', { skip: process.platform === 'win32' }, function (t) {\n  t.plan(10)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.register(multipart)\n\n  fastify.post('/', function (req, reply) {\n    let fileCount = 0\n    t.ok(req.isMultipart())\n\n    req.multipart(handler, function (err) {\n      t.error(err)\n      t.equal(fileCount, 2)\n      reply.code(200).send()\n    })\n\n    function handler (field, file, filename, encoding, mimetype) {\n      const saveTo = path.join(os.tmpdir(), path.basename(filename))\n      eos(file, function (err) {\n        t.error(err)\n        fileCount++\n      })\n\n      pump(file, fs.createWriteStream(saveTo), function (err) {\n        t.error(err)\n      })\n    }\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 200)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n    form.append('upload', fs.createReadStream(filePath))\n    form.append('upload2', fs.createReadStream(filePath))\n    form.append('hello', 'world')\n    form.append('willbe', 'dropped')\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('should call finished if one of the streams closes prematurely', { skip: process.platform === 'win32' }, function (t) {\n  t.plan(5)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.register(multipart)\n\n  fastify.post('/', function (req, reply) {\n    let fileCount = 0\n    t.ok(req.isMultipart())\n\n    req.multipart(handler, function () {\n      t.equal(fileCount, 1)\n      reply.code(200).send()\n    })\n\n    function handler (field, file, filename, encoding, mimetype) {\n      const saveTo = path.join(os.tmpdir(), path.basename(filename))\n      eos(file, function () {\n        fileCount++\n      })\n\n      file.on('data', function () {\n        if (fileCount === 0) {\n          this.destroy()\n        }\n      })\n\n      pump(file, fs.createWriteStream(saveTo), () => {})\n    }\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const stream1 = fs.createReadStream(filePath)\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 200)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n\n    form.append('upload1', stream1, {\n      filename: 'random-data1'\n    })\n    form.append('upload2', stream1, {\n      filename: 'random-data2'\n    })\n\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('should error if it is not multipart', { skip: process.platform === 'win32' }, function (t) {\n  t.plan(4)\n\n  const fastify = Fastify()\n\n  t.teardown(fastify.close.bind(fastify))\n  fastify.register(multipart)\n\n  fastify.post('/', function (req, reply) {\n    t.notOk(req.isMultipart())\n\n    req.multipart(handler, function (err) {\n      t.ok(err)\n      t.equal(err.message, 'the request is not multipart')\n      reply.code(500).send()\n    })\n\n    function handler (field, file, filename, encoding, mimetype) {\n      t.fail('this should never be called')\n    }\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      headers: {\n        'content-type': 'application/json'\n      },\n      path: '/',\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 500)\n    })\n    req.end(JSON.stringify({ hello: 'world' }))\n  })\n})\n\ntest('should error if handler is not a function', { skip: process.platform === 'win32' }, function (t) {\n  t.plan(3)\n\n  const fastify = Fastify()\n\n  t.teardown(fastify.close.bind(fastify))\n  fastify.register(multipart)\n\n  fastify.post('/', function (req, reply) {\n    const handler = null\n\n    req.multipart(handler, function (err) {\n      t.ok(err)\n      reply.code(500).send()\n    })\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      res.resume()\n      res.on('end', () => {\n        t.equal(res.statusCode, 500)\n        t.pass('res ended successfully')\n      })\n    })\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('should error if callback is not a function', { skip: process.platform === 'win32' }, function (t) {\n  t.plan(3)\n\n  const fastify = Fastify()\n\n  t.teardown(fastify.close.bind(fastify))\n  fastify.register(multipart)\n\n  fastify.post('/', function (req) {\n    const callback = null\n    req.multipart(handler, callback)\n\n    function handler () {}\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      res.resume()\n      res.on('end', () => {\n        t.equal(res.statusCode, 500)\n        t.pass('res ended successfully')\n      })\n    })\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('should error if it is invalid multipart', { skip: process.platform === 'win32' }, function (t) {\n  t.plan(5)\n\n  const fastify = Fastify()\n\n  t.teardown(fastify.close.bind(fastify))\n  fastify.register(multipart)\n\n  fastify.post('/', function (req, reply) {\n    t.ok(req.isMultipart())\n\n    req.multipart(handler, function (err) {\n      t.ok(err)\n      t.equal(err.message, 'Multipart: Boundary not found')\n      reply.code(500).send()\n    })\n\n    function handler (field, file, filename, encoding, mimetype) {\n      t.fail('this should never be called')\n    }\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      headers: {\n        'content-type': 'multipart/form-data'\n      },\n      path: '/',\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 500)\n    })\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('should override options', { skip: process.platform === 'win32' }, function (t) {\n  t.plan(5)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.register(multipart, { limits: { fileSize: 1 } })\n\n  fastify.post('/', function (req, reply) {\n    const mp = req.multipart(handler, function (err) {\n      t.error(err)\n      reply.code(200).send()\n    }, { limits: { fileSize: 2 } })\n\n    t.equal(mp.opts.limits.fileSize, 2, 'options.limits.fileSize was updated successfully')\n\n    function handler (field, file, filename, encoding, mimetype) {\n      file.pipe(concat(function (buf) { }))\n    }\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 200)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n\n    const rs = fs.createReadStream(filePath)\n    form.append('upload', rs)\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('should not allow __proto__', { skip: process.platform === 'win32' }, function (t) {\n  t.plan(5)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.register(multipart, { limits: { fields: 1 } })\n\n  fastify.post('/', function (req, reply) {\n    t.ok(req.isMultipart())\n\n    const mp = req.multipart(handler, function (err) {\n      t.equal(err.message, '__proto__ is not allowed as field name')\n      reply.code(500).send()\n    })\n\n    mp.on('field', function (name, value) {\n      t.fail('should not be called')\n    })\n\n    function handler (field, file, filename, encoding, mimetype) {\n      t.fail('should not be called')\n    }\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 500)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n    const rs = fs.createReadStream(filePath)\n    form.append('__proto__', rs)\n    // form.append('hello', 'world')\n    // form.append('willbe', 'dropped')\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n\ntest('should not allow constructor', { skip: process.platform === 'win32' }, function (t) {\n  t.plan(5)\n\n  const fastify = Fastify()\n  t.teardown(fastify.close.bind(fastify))\n\n  fastify.register(multipart, { limits: { fields: 1 } })\n\n  fastify.post('/', function (req, reply) {\n    t.ok(req.isMultipart())\n\n    const mp = req.multipart(handler, function (err) {\n      t.equal(err.message, 'constructor is not allowed as field name')\n      reply.code(500).send()\n    })\n\n    mp.on('field', function (name, value) {\n      t.fail('should not be called')\n    })\n\n    function handler (field, file, filename, encoding, mimetype) {\n      t.fail('should not be called')\n    }\n  })\n\n  fastify.listen(0, function () {\n    // request\n    const form = new FormData()\n    const opts = {\n      protocol: 'http:',\n      hostname: 'localhost',\n      port: fastify.server.address().port,\n      path: '/',\n      headers: form.getHeaders(),\n      method: 'POST'\n    }\n\n    const req = http.request(opts, (res) => {\n      t.equal(res.statusCode, 500)\n      res.resume()\n      res.on('end', () => {\n        t.pass('res ended successfully')\n      })\n    })\n    const rs = fs.createReadStream(filePath)\n    form.append('constructor', rs)\n    pump(form, req, function (err) {\n      t.error(err, 'client pump: no err')\n    })\n  })\n})\n"], "filenames": ["index.js", "test/legacy/append-body.test.js", "test/legacy/multipart.test.js"], "buggy_code_start_loc": [63, 787, 480], "buggy_code_end_loc": [262, 787, 480], "fixing_code_start_loc": [63, 788, 481], "fixing_code_end_loc": [262, 834, 533], "type": "CWE-1321", "message": "This affects the package fastify-multipart before 5.3.1. By providing a name=constructor property it is still possible to crash the application. **Note:** This is a bypass of CVE-2020-8136 (https://security.snyk.io/vuln/SNYK-JS-FASTIFYMULTIPART-1290382).", "other": {"cve": {"id": "CVE-2021-23597", "sourceIdentifier": "report@snyk.io", "published": "2022-02-11T17:15:08.023", "lastModified": "2022-07-12T17:42:04.277", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects the package fastify-multipart before 5.3.1. By providing a name=constructor property it is still possible to crash the application. **Note:** This is a bypass of CVE-2020-8136 (https://security.snyk.io/vuln/SNYK-JS-FASTIFYMULTIPART-1290382)."}, {"lang": "es", "value": "Esto afecta al paquete fastify-multipart versiones anteriores a 5.3.1. Proporcionando una propiedad name=constructor todav\u00eda es posible bloquear la aplicaci\u00f3n. **Nota:** Esto es una omisi\u00f3n de CVE-2020-8136 (https://security.snyk.io/vuln/SNYK-JS-FASTIFYMULTIPART-1290382)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fastify:fastify-multipart:*:*:*:*:*:fastify:*:*", "versionEndExcluding": "5.3.1", "matchCriteriaId": "E0342D3F-B435-4CD7-A52B-2A788B2CD1A8"}]}]}], "references": [{"url": "https://github.com/fastify/fastify-multipart/commit/a70dc7059a794589bd4fe066453141fc609e6066", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/fastify/fastify-multipart/releases/tag/v5.3.1", "source": "report@snyk.io", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-FASTIFYMULTIPART-2395480", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/fastify/fastify-multipart/commit/a70dc7059a794589bd4fe066453141fc609e6066"}}