{"buggy_code": ["<?\n\t/*\n\t\tClass: BigTreeCMS\n\t\t\tThe primary interface to BigTree that is used by the front end of the site for pulling settings, navigation, and page content.\n\t*/\n\n\tclass BigTreeCMS {\n\t\n\t\tvar $iplCache = array();\n\n\t\t/*\n\t\t\tConstructor:\n\t\t\t\tBuilds a flat file module class list so that module classes can be autoloaded instead of always in memory.\n\t\t*/\n\t\t\n\t\tfunction __construct() {\n\t\t\t// If the cache exists, just use it.\n\t\t\tif (file_exists(SERVER_ROOT.\"cache/module-class-list.btc\")) {\n\t\t\t\t$items = json_decode(file_get_contents(SERVER_ROOT.\"cache/module-class-list.btc\"),true);\n\t\t\t} else {\n\t\t\t\t// Get the Module Class List\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_modules\");\n\t\t\t\t$items = array();\n\t\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t\t$items[$f[\"class\"]] = $f[\"route\"];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Cache it so we don't hit the database.\n\t\t\t\tfile_put_contents(SERVER_ROOT.\"cache/module-class-list.btc\",json_encode($items));\n\t\t\t}\n\t\t\t\n\t\t\t$this->ModuleClassList = $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: cacheGet\n\t\t\t\tRetrieves data from BigTree's cache table.\n\n\t\t\tParameters:\n\t\t\t\tidentifier - Uniquid identifier for your data type (i.e. org.bigtreecms.geocoding)\n\t\t\t\tkey - The key for your data.\n\t\t\t\tmax_age - The maximum age (in seconds) for the data, defaults to any age.\n\n\t\t\tReturns:\n\t\t\t\tData from the table (json decoded, objects convert to keyed arrays) if it exists or false.\n\t\t*/\n\n\t\tfunction cacheGet($identifier,$key,$max_age = false) {\n\t\t\t$identifier = sqlescape($identifier);\n\t\t\t$key = sqlescape($key);\n\t\t\tif ($max_age) {\n\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_caches WHERE `identifier` = '$identifier' AND `key` = '$key' AND timestamp >= '\".date(\"Y-m-d H:i:s\",time() - $max_age).\"'\"));\n\t\t\t} else {\n\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_caches WHERE `identifier` = '$identifier' AND `key` = '$key'\"));\n\t\t\t}\n\t\t\tif (!$f) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn json_decode($f[\"value\"],true);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: cachePut\n\t\t\t\tPuts data into BigTree's cache table.\n\n\t\t\tParameters:\n\t\t\t\tidentifier - Uniquid identifier for your data type (i.e. org.bigtreecms.geocoding)\n\t\t\t\tkey - The key for your data.\n\t\t\t\tvalue - The data to store.\n\t\t\t\treplace - Whether to replace an existing value (defaults to true).\n\n\t\t\tReturns:\n\t\t\t\tTrue if successful, false if the indentifier/key combination already exists and replace was set to false.\n\t\t*/\n\n\t\tfunction cachePut($identifier,$key,$value,$replace = true) {\n\t\t\t$identifier = sqlescape($identifier);\n\t\t\t$key = sqlescape($key);\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_caches WHERE `identifier` = '$identifier' AND `key` = '$key'\"));\n\t\t\tif ($f && !$replace) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Prefer to keep this an object, but we need PHP 5.3\n\t\t\tif (strnatcmp(phpversion(),'5.3') >= 0) {\n\t\t\t\t$value = sqlescape(json_encode($value,JSON_FORCE_OBJECT));\t\t\t\n\t\t\t} else {\n\t\t\t\t$value = sqlescape(json_encode($value));\n\t\t\t}\n\t\t\t\n\t\t\tif ($f) {\n\t\t\t\tsqlquery(\"UPDATE bigtree_caches SET `value` = '$value' WHERE `identifier` = '$identifier' AND `key` = '$key'\");\n\t\t\t} else {\n\t\t\t\tsqlquery(\"INSERT INTO bigtree_caches (`identifier`,`key`,`value`) VALUES ('$identifier','$key','$value')\");\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: catch404\n\t\t\t\tManually catch and display the 404 page from a routed template; logs missing page with handle404\n\t\t*/\n\t\t\n\t\tfunction catch404() {\n\t\t\tglobal $cms,$bigtree;\n\t\t\t\n\t\t\tif ($this->handle404(str_ireplace(WWW_ROOT,\"\",BigTree::currentURL()))) {\n\t\t\t\t$bigtree[\"layout\"] = \"default\";\n\t\t\t\tob_start();\n\t\t\t\tinclude \"../templates/basic/_404.php\";\n\t\t\t\t$bigtree[\"content\"] = ob_get_clean();\n\t\t\t\tob_start();\n\t\t\t\tinclude \"../templates/layouts/\".$bigtree[\"layout\"].\".php\";\n\t\t\t\tdie();\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: checkOldRoutes\n\t\t\t\tChecks the old route table, redirects if the page is found.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tpath - An array of routes\n\t\t*/\n\t\t\n\t\tfunction checkOldRoutes($path) {\n\t\t\t$found = false;\n\t\t\t$x = count($path);\n\t\t\twhile ($x) {\n\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_route_history WHERE old_route = '\".implode(\"/\",array_slice($path,0,$x)).\"'\"));\n\t\t\t\tif ($f) {\n\t\t\t\t\t$old = $f[\"old_route\"];\n\t\t\t\t\t$new = $f[\"new_route\"];\n\t\t\t\t\t$found = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t$x--;\n\t\t\t}\n\t\t\t// If it's in the old routing table, send them to the new page.\n\t\t\tif ($found) {\n\t\t\t\t$new_url = $new.substr($_GET[\"bigtree_htaccess_url\"],strlen($old));\n\t\t\t\tBigTree::redirect(WWW_ROOT.$new_url,\"301\");\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: decodeCallouts\n\t\t\t\tTurns the JSON callout data into a PHP array of callouts with links being translated into front-end readable links.\n\t\t\t\tThis function is called by BigTree's router and is generally not a function needed to end users.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tdata - JSON encoded callout data.\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tAn array of callouts.\n\t\t*/\t\n\t\t\t\n\t\tfunction decodeCallouts($data) {\n\t\t\t$parsed = array();\n\t\t\tif (!is_array($data)) {\n\t\t\t\t$data = json_decode($data,true);\n\t\t\t}\n\t\t\t// Just in case it was empty, we do an is_array to avoid warnings\n\t\t\tif (is_array($data)) {\n\t\t\t\tforeach ($data as $key => $d) {\n\t\t\t\t\t$p = array();\n\t\t\t\t\tforeach ($d as $kk => $dd) {\n\t\t\t\t\t\tif (is_array($dd)) {\n\t\t\t\t\t\t\t// If this value is an array, untranslate it so that {wwwroot} and ipls get fixed.\n\t\t\t\t\t\t\t$p[$kk] = BigTree::untranslateArray($dd);\n\t\t\t\t\t\t} elseif (is_array(json_decode($dd,true))) {\n\t\t\t\t\t\t\t// If this value is an array, untranslate it so that {wwwroot} and ipls get fixed.\n\t\t\t\t\t\t\t$p[$kk] = BigTree::untranslateArray(json_decode($dd,true));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Otherwise it's a string, just replace the {wwwroot} and ipls.\n\t\t\t\t\t\t\t$p[$kk] = $this->replaceInternalPageLinks($dd);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t$parsed[$key] = $p;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $parsed;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: decodeResources\n\t\t\t\tTurns the JSON resources data into a PHP array of resources with links being translated into front-end readable links.\n\t\t\t\tThis function is called by BigTree's router and is generally not a function needed to end users.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tdata - JSON encoded callout data.\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tAn array of resources.\n\t\t*/\n\n\t\tfunction decodeResources($data) {\n\t\t\tif (!is_array($data)) {\n\t\t\t\t$data = json_decode($data,true);\n\t\t\t}\n\t\t\tif (is_array($data)) {\n\t\t\t\tforeach ($data as $key => $val) {\n\t\t\t\t\tif (is_array($val)) {\n\t\t\t\t\t\t// If this value is an array, untranslate it so that {wwwroot} and ipls get fixed.\n\t\t\t\t\t\t$val = BigTree::untranslateArray($val);\n\t\t\t\t\t} elseif (is_array(json_decode($val,true))) {\n\t\t\t\t\t\t// If this value is an array, untranslate it so that {wwwroot} and ipls get fixed.\n\t\t\t\t\t\t$val = BigTree::untranslateArray(json_decode($val,true));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Otherwise it's a string, just replace the {wwwroot} and ipls.\n\t\t\t\t\t\t$val = $this->replaceInternalPageLinks($val);\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t$data[$key] = $val;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $data;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: drawXMLSitemap\n\t\t\t\tOutputs an XML sitemap.\n\t\t*/\n\t\t\n\t\tfunction drawXMLSitemap() {\n\t\t\theader(\"Content-type: text/xml\");\n\t\t\techo '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>';\n\t\t\techo '<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd\">';\n\t\t\t$q = sqlquery(\"SELECT id,template,external,path FROM bigtree_pages WHERE archived = '' AND (publish_at >= NOW() OR publish_at IS NULL) ORDER BY id ASC\");\n\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\tif ($f[\"template\"] || strpos($f[\"external\"],$GLOBALS[\"domain\"])) {\t\n\t\t\t\t\tif (!$f[\"template\"]) {\n\t\t\t\t\t\t$link = $this->getInternalPageLink($f[\"external\"]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$link = WWW_ROOT.$f[\"path\"].(($f[\"id\"] > 0) ? \"/\" : \"\"); // Fix sitemap adding trailing slashes to home\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\techo \"<url><loc>\".$link.\"</loc></url>\\n\";\n\t\t\t\t\t\n\t\t\t\t\t// Added routed template support\n\t\t\t\t\t$tf = sqlfetch(sqlquery(\"SELECT bigtree_modules.class AS module_class FROM bigtree_templates JOIN bigtree_modules ON bigtree_modules.id = bigtree_templates.module WHERE bigtree_templates.id = '\".$f[\"template\"].\"'\"));\n\t\t\t\t\tif ($tf[\"module_class\"]) {\n\t\t\t\t\t\t$mod = new $tf[\"module_class\"];\n\t\t\t\t\t\tif (method_exists($mod,\"getSitemap\")) {\n\t\t\t\t\t\t\t$subnav = $mod->getSitemap($f);\n\t\t\t\t\t\t\tforeach ($subnav as $s) {\n\t\t\t\t\t\t\t\techo \"<url><loc>\".$s[\"link\"].\"</loc></url>\\n\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$mod = $subnav = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\techo '</urlset>';\n\t\t\tdie();\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getBreadcrumb\n\t\t\t\tReturns an array of titles, links, and ids for pages above the current page.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tignore_trunk - Ignores trunk settings when returning the breadcrumb\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tAn array of arrays with \"title\", \"link\", and \"id\" of each of the pages above the current (or passed in) page.\n\t\t\t\n\t\t\tSee Also:\n\t\t\t\t<getBreadcrumbByPage>\n\t\t*/\n\t\t\n\t\tfunction getBreadcrumb($ignore_trunk = false) {\n\t\t\tglobal $bigtree;\n\t\t\treturn $this->getBreadcrumbByPage($bigtree[\"page\"],$ignore_trunk);\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getBreadcrumbByPage\n\t\t\t\tReturns an array of titles, links, and ids for the pages above the given page.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tpage - A page array (containing at least the \"path\" from the database) *(optional)*\n\t\t\t\tignore_trunk - Ignores trunk settings when returning the breadcrumb\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tAn array of arrays with \"title\", \"link\", and \"id\" of each of the pages above the current (or passed in) page.\n\t\t\t\tIf a trunk is hit, $this->BreadCrumb trunk is set to the trunk.\n\t\t\t\n\t\t\tSee Also:\n\t\t\t\t<getBreadcrumb>\n\t\t*/\n\t\t\n\t\tfunction getBreadcrumbByPage($page,$ignore_trunk = false) {\n\t\t\t$bc = array();\n\t\t\t\n\t\t\t// Break up the pieces so we can get each piece of the path individually and pull all the pages above this one.\n\t\t\t$pieces = explode(\"/\",$page[\"path\"]);\n\t\t\t$paths = array();\n\t\t\t$path = \"\";\n\t\t\tforeach ($pieces as $piece) {\n\t\t\t\t$path = $path.$piece.\"/\";\n\t\t\t\t$paths[] = \"path = '\".sqlescape(trim($path,\"/\")).\"'\";\n\t\t\t}\n\t\t\t\n\t\t\t// Get all the ancestors, ordered by the page length so we get the latest first and can count backwards to the trunk.\n\t\t\t$q = sqlquery(\"SELECT id,nav_title,path,trunk FROM bigtree_pages WHERE (\".implode(\" OR \",$paths).\") ORDER BY LENGTH(path) DESC\");\n\t\t\t$trunk_hit = false;\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\tif ($f[\"trunk\"]) {\n\t\t\t\t\t$trunk_hit = true;\n\t\t\t\t\t$this->BreadcrumbTrunk = $f;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!$trunk_hit || $ignore_trunk) {\n\t\t\t\t\t$bc[] = array(\"title\" => stripslashes($f[\"nav_title\"]),\"link\" => WWW_ROOT.$f[\"path\"].\"/\",\"id\" => $f[\"id\"]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t$bc = array_reverse($bc);\n\t\t\t\n\t\t\t// Check for module breadcrumbs\n\t\t\t$mod = sqlfetch(sqlquery(\"SELECT bigtree_modules.class FROM bigtree_modules JOIN bigtree_templates ON bigtree_modules.id = bigtree_templates.module WHERE bigtree_templates.id = '\".$page[\"template\"].\"'\"));\n\t\t\tif ($mod[\"class\"]) {\n\t\t\t\tif (class_exists($mod[\"class\"])) {\n\t\t\t\t\t@eval('$module = new '.$mod[\"class\"].';');\n\t\t\t\t\tif (method_exists($module, \"getBreadcrumb\")) {\n\t\t\t\t\t\t$bc = array_merge($bc,$module->getBreadcrumb($page));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn $bc;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getFeed\n\t\t\t\tGets a feed's information from the database.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\titem - Either the ID of the feed to pull or a raw database row of the feed data\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tAn array of feed information with options and fields decoded from JSON.\n\t\t\t\t\n\t\t\tSee Also:\n\t\t\t\t<getFeedByRoute>\n\t\t*/\n\t\t\n\t\tfunction getFeed($item) {\n\t\t\tif (!is_array($item)) {\n\t\t\t\t$item = sqlescape($item);\n\t\t\t\t$item = sqlfetch(sqlquery(\"SELECT * FROM bigtree_feeds WHERE id = '$item'\"));\n\t\t\t}\n\t\t\tif (!$item) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$item[\"options\"] = json_decode($item[\"options\"],true);\n\t\t\tif (is_array($item[\"options\"])) {\n\t\t\t\tforeach ($item[\"options\"] as &$option) {\n\t\t\t\t\t$option = $this->replaceRelativeRoots($option);\n\t\t\t\t}\n\t\t\t}\n\t\t\t$item[\"fields\"] = json_decode($item[\"fields\"],true);\n\t\t\treturn $item;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getFeedByRoute\n\t\t\t\tGets a feed's information from the database\n\t\t\t\n\t\t\tParameters:\n\t\t\t\troute - The route of the feed to pull.\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tAn array of feed information with options and fields decoded from JSON.\n\t\t\t\n\t\t\tSee Also:\n\t\t\t\t<getFeed>\n\t\t*/\n\t\t\n\t\tfunction getFeedByRoute($route) {\n\t\t\t$route = sqlescape($route);\n\t\t\t$item = sqlfetch(sqlquery(\"SELECT * FROM bigtree_feeds WHERE route = '$route'\"));\n\t\t\treturn $this->getFeed($item);\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getHiddenNavByParent\n\t\t\t\tReturns an alphabetical list of pages that are not visible in navigation.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tparent - The parent ID for which to pull child pages.\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tAn array of page entries from the database (without resources or callouts).\n\t\t\t\t\n\t\t\tSee Also:\n\t\t\t\t<getNavByParent>\n\t\t*/\n\t\t\n\t\tfunction getHiddenNavByParent($parent = 0) {\n\t\t\treturn $this->getNavByParent($parent,1,false,true);\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getInternalPageLink\n\t\t\t\tReturns a hard link to the page's publicly accessible URL from its encoded soft link URL.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tipl - Internal Page Link (ipl://, {wwwroot}, or regular URL encoding)\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tPublic facing URL.\n\t\t*/\n\t\t\n\t\tfunction getInternalPageLink($ipl) {\n\t\t\tif (substr($ipl,0,6) != \"ipl://\") {\n\t\t\t\treturn $this->replaceRelativeRoots($ipl);\n\t\t\t}\n\t\t\t$ipl = explode(\"//\",$ipl);\n\t\t\t$navid = $ipl[1];\n\t\t\t\n\t\t\t// New IPLs are encoded in JSON\n\t\t\t$c = json_decode(base64_decode($ipl[2]));\n\t\t\t// Help with transitions.\n\t\t\tif (!is_array($c)) {\n\t\t\t\t$c = unserialize(base64_decode($ipl[2]));\n\t\t\t}\n\t\t\t// If it can't be rectified, we still don't want a warning.\n\t\t\tif (is_array($c)) {\n\t\t\t\t$commands = implode(\"/\",$c);\n\t\t\t} else {\n\t\t\t\t$commands = \"\";\n\t\t\t}\n\t\t\t\n\t\t\tif ($commands && strpos($commands,\"?\") === false) {\n\t\t\t\t$commands .= \"/\";\n\t\t\t}\n\t\t\t\n\t\t\t// See if it's in the cache.\n\t\t\tif (isset($this->iplCache[$navid])) {\n\t\t\t\treturn $this->iplCache[$navid].$commands;\n\t\t\t} else {\n\t\t\t\t// Get the page's path\n\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT path FROM bigtree_pages WHERE id = '\".sqlescape($navid).\"'\"));\n\t\t\t\t// Set the cache\n\t\t\t\t$this->iplCache[$navid] = WWW_ROOT.$f[\"path\"].\"/\";\n\t\t\t\treturn WWW_ROOT.$f[\"path\"].\"/\".$commands;\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getLink\n\t\t\t\tReturns the public link to a page in the database.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tid - The ID of the page.\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tPublic facing URL.\n\t\t*/\n\t\t\n\t\tfunction getLink($id) {\n\t\t\tglobal $bigtree;\n\t\t\t// Homepage, just return the web root.\n\t\t\tif ($id == 0) {\n\t\t\t\treturn WWW_ROOT;\n\t\t\t}\n\t\t\t// If someone is requesting the link of the page they're already on we don't need to request it from the database.\n\t\t\tif ($bigtree[\"page\"][\"id\"] == $id) {\n\t\t\t\treturn WWW_ROOT.$bigtree[\"page\"][\"path\"].\"/\";\n\t\t\t}\n\t\t\t// Otherwise we'll grab the page path from the db.\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT path FROM bigtree_pages WHERE id = '\".sqlescape($id).\"'\"));\n\t\t\treturn WWW_ROOT.$f[\"path\"].\"/\";\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getNavByParent\n\t\t\t\tReturns a multi-level navigation array of pages visible in navigation\n\t\t\t\t(or hidden, if $only_hidden is set to true)\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tparent - Either a single page ID or an array of page IDs -- the latter is used internally\n\t\t\t\tlevels - The number of levels of navigation depth to recurse\n\t\t\t\tfollow_module - Whether to pull module navigation or not\n\t\t\t\tonly_hidden - Whether to pull visible (false) or hidden (true) pages\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tA multi-level navigation array containing \"id\", \"parent\", \"title\", \"route\", \"link\", \"new_window\", and \"children\"\n\t\t*/\n\t\t\t\n\t\tfunction getNavByParent($parent = 0,$levels = 1,$follow_module = true,$only_hidden = false) {\n\t\t\tstatic $module_nav_count = 0;\n\t\t\t$nav = array();\n\t\t\t$find_children = array();\n\t\t\t\n\t\t\t// If the parent is an array, this is actually a recursed call.\n\t\t\t// We're finding all the children of all the parents at once -- then we'll assign them back to the proper parent instead of doing separate calls for each.\n\t\t\tif (is_array($parent)) {\n\t\t\t\t$where_parent = array();\n\t\t\t\tforeach ($parent as $p) {\n\t\t\t\t\t$where_parent[] = \"parent = '\".sqlescape($p).\"'\";\n\t\t\t\t}\n\t\t\t\t$where_parent = \"(\".implode(\" OR \",$where_parent).\")\";\n\t\t\t// If it's an integer, let's just pull the children for the provided parent.\n\t\t\t} else {\n\t\t\t\t$parent = sqlescape($parent);\n\t\t\t\t$where_parent = \"parent = '$parent'\";\n\t\t\t}\n\t\t\t\n\t\t\t$in_nav = $only_hidden ? \"\" : \"on\";\n\t\t\t$sort = $only_hidden ? \"nav_title ASC\" : \"position DESC, id ASC\";\n\t\t\t\n\t\t\t$q = sqlquery(\"SELECT id,nav_title,parent,external,new_window,template,route,path FROM bigtree_pages WHERE $where_parent AND in_nav = '$in_nav' AND archived != 'on' AND (publish_at <= NOW() OR publish_at IS NULL) AND (expire_at >= NOW() OR expire_at IS NULL) ORDER BY $sort\");\n\t\t\t\n\t\t\t// Wrangle up some kids\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$link = WWW_ROOT.$f[\"path\"].\"/\";\n\t\t\t\t$new_window = false;\n\t\t\t\t\n\t\t\t\t// If we're REALLY an external link we won't have a template, so let's get the real link and not the encoded version.  Then we'll see if we should open this thing in a new window.\n\t\t\t\tif ($f[\"external\"] && $f[\"template\"] == \"\") {\n\t\t\t\t\t$link = $this->getInternalPageLink($f[\"external\"]);\n\t\t\t\t\tif ($f[\"new_window\"] == \"Yes\") {\n\t\t\t\t\t\t$new_window = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Add it to the nav array\n\t\t\t\t$nav[$f[\"id\"]] = array(\"id\" => $f[\"id\"], \"parent\" => $f[\"parent\"], \"title\" => $f[\"nav_title\"], \"route\" => $f[\"route\"], \"link\" => $link, \"new_window\" => $new_window, \"children\" => array());\n\t\t\t\t\n\t\t\t\t// If we're going any deeper, mark down that we're looking for kids of this kid.\n\t\t\t\tif ($levels > 1) {\n\t\t\t\t\t$find_children[] = $f[\"id\"];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// If we're looking for children, send them all back into getNavByParent, decrease the depth we're looking for by one.\n\t\t\tif (count($find_children)) {\n\t\t\t\t$subnav = $this->getNavByParent($find_children,$levels - 1,$follow_module);\n\t\t\t\tforeach ($subnav as $item) {\n\t\t\t\t\t// Reassign these new children back to their parent node.\n\t\t\t\t\t$nav[$item[\"parent\"]][\"children\"][$item[\"id\"]] = $item;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// If we're pulling in module navigation...\n\t\t\tif ($follow_module) {\n\t\t\t\t// This is a recursed iteration.\n\t\t\t\tif (is_array($parent)) {\n\t\t\t\t\t$where_parent = array();\n\t\t\t\t\tforeach ($parent as $p) {\n\t\t\t\t\t\t$where_parent[] = \"bigtree_pages.id = '\".sqlescape($p).\"'\";\n\t\t\t\t\t}\n\t\t\t\t\t$q = sqlquery(\"SELECT bigtree_modules.class,bigtree_templates.routed,bigtree_templates.module,bigtree_pages.id,bigtree_pages.path,bigtree_pages.template FROM bigtree_modules JOIN bigtree_templates JOIN bigtree_pages ON bigtree_templates.id = bigtree_pages.template WHERE bigtree_modules.id = bigtree_templates.module AND (\".implode(\" OR \",$where_parent).\")\");\n\t\t\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t\t\t// If the class exists, instantiate it and call it\n\t\t\t\t\t\tif ($f[\"class\"] && class_exists($f[\"class\"])) {\n\t\t\t\t\t\t\t@eval('$module = new '.$f[\"class\"].';');\n\t\t\t\t\t\t\tif (method_exists($module,\"getNav\")) {\n\t\t\t\t\t\t\t\t$modNav = $module->getNav($f);\n\t\t\t\t\t\t\t\t// Give the parent back to each of the items it returned so they can be reassigned to the proper parent.\n\t\t\t\t\t\t\t\t$module_nav = array();\n\t\t\t\t\t\t\t\tforeach ($modNav as $item) {\n\t\t\t\t\t\t\t\t\t$item[\"parent\"] = $f[\"id\"];\n\t\t\t\t\t\t\t\t\t$item[\"id\"] = \"module_nav_\".$module_nav_count;\n\t\t\t\t\t\t\t\t\t$module_nav[] = $item;\n\t\t\t\t\t\t\t\t\t$module_nav_count++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ($module->NavPosition == \"top\") {\n\t\t\t\t\t\t\t\t\t$nav = array_merge($module_nav,$nav);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$nav = array_merge($nav,$module_nav);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t// This is the first iteration.\n\t\t\t\t} else {\n\t\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT bigtree_modules.class,bigtree_templates.routed,bigtree_templates.module,bigtree_pages.id,bigtree_pages.path,bigtree_pages.template FROM bigtree_modules JOIN bigtree_templates JOIN bigtree_pages ON bigtree_templates.id = bigtree_pages.template WHERE bigtree_modules.id = bigtree_templates.module AND bigtree_pages.id = '$parent'\"));\n\t\t\t\t\t// If the class exists, instantiate it and call it.\n\t\t\t\t\tif ($f[\"class\"] && class_exists($f[\"class\"])) {\n\t\t\t\t\t\t@eval('$module = new '.$f[\"class\"].';');\n\t\t\t\t\t\tif (method_exists($module,\"getNav\")) {\n\t\t\t\t\t\t\tif ($module->NavPosition == \"top\") {\n\t\t\t\t\t\t\t\t$nav = array_merge($module->getNav($f),$nav);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$nav = array_merge($nav,$module->getNav($f));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn $nav;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getNavId\n\t\t\t\tProvides the page ID for a given path array.\n\t\t\t\tThis is a method used by the router and the admin and can generally be ignored.\n\t\t\t\n\t\t\tParamaters:\n\t\t\t\tpath - An array of path elements from a URL\n\t\t\t\tpreviewing - Whether we are previewing or not.\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tAn array containing the page ID and any additional commands.\n\t\t*/\n\t\t\n\t\tfunction getNavId($path,$previewing = false) {\n\t\t\t$commands = array();\n\t\t\t\n\t\t\tif (!$previewing) {\n\t\t\t\t$publish_at = \"AND (publish_at <= NOW() OR publish_at IS NULL) AND (expire_at >= NOW() OR expire_at IS NULL)\";\n\t\t\t} else {\n\t\t\t\t$publish_at = \"\";\n\t\t\t}\n\t\t\t\n\t\t\t// See if we have a straight up perfect match to the path.\n\t\t\t$spath = sqlescape(implode(\"/\",$path));\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT bigtree_pages.id,bigtree_templates.routed FROM bigtree_pages LEFT JOIN bigtree_templates ON bigtree_pages.template = bigtree_templates.id WHERE path = '$spath' AND archived = '' $publish_at\"));\n\t\t\tif ($f) {\n\t\t\t\treturn array($f[\"id\"],$commands,$f[\"routed\"]);\n\t\t\t}\n\t\t\t\n\t\t\t// Guess we don't, let's chop off commands until we find a page.\n\t\t\t$x = 0;\n\t\t\twhile ($x < count($path)) {\n\t\t\t\t$x++;\n\t\t\t\t$commands[] = $path[count($path)-$x];\n\t\t\t\t$spath = sqlescape(implode(\"/\",array_slice($path,0,-1 * $x)));\n\t\t\t\t// We have additional commands, so we're now making sure the template is also routed, otherwise it's a 404.\n\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT bigtree_pages.id FROM bigtree_pages JOIN bigtree_templates ON bigtree_pages.template = bigtree_templates.id WHERE bigtree_pages.path = '$spath' AND bigtree_pages.archived = '' AND bigtree_templates.routed = 'on' $publish_at\"));\n\t\t\t\tif ($f) {\n\t\t\t\t\treturn array($f[\"id\"],array_reverse($commands),\"on\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn array(false,false,false);\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getPage\n\t\t\t\tReturns a page along with its resources and callouts decoded.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tchild - The ID of the page.\n\t\t\t\tdecode - Whether to decode resources and callouts or not (setting to false saves processing time)\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tA page array from the database.\n\t\t*/\n\t\t\n\t\tfunction getPage($child,$decode = true) {\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_pages WHERE id = '$child'\"));\n\t\t\tif (!$f) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ($f[\"external\"] && $f[\"template\"] == \"\") {\n\t\t\t\t$f[\"external\"] = $this->getInternalPageLink($f[\"external\"]);\n\t\t\t}\n\t\t\tif ($decode) {\n\t\t\t\t$f[\"resources\"] = $this->decodeResources($f[\"resources\"]);\n\t\t\t\t$f[\"callouts\"] = $this->decodeCallouts($f[\"callouts\"]);\n\t\t\t}\n\t\t\treturn $f;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getPendingPage\n\t\t\t\tReturns a page along with pending changes applied.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tchild - The ID of the page.\n\t\t\t\tdecode - Whether to decode resources and callouts or not (setting to false saves processing time, defaults true).\n\t\t\t\treturn_tags - Whether to return tags for the page (defaults false).\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tA page array from the database.\n\t\t*/\n\t\t\n\t\tfunction getPendingPage($id,$decode = true,$return_tags = false) {\n\t\t\t// Numeric id means the page is live.\n\t\t\tif (is_numeric($id)) {\n\t\t\t\t$page = $this->getPage($id);\n\t\t\t\tif (!$page) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// If we're looking for tags, apply them to the page.\n\t\t\t\tif ($return_tags) {\n\t\t\t\t\t$page[\"tags\"] = $this->getTagsForPage($id);\n\t\t\t\t}\n\t\t\t\t// Get pending changes for this page.\n\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_pending_changes WHERE `table` = 'bigtree_pages' AND item_id = '\".$page[\"id\"].\"'\"));\n\n\t\t\t// If it's prefixed with a \"p\" then it's a pending entry.\n\t\t\t} else {\n\t\t\t\t// Set the page to empty, we're going to loop through the change later and apply the fields.\n\t\t\t\t$page = array();\n\t\t\t\t// Get the changes.\n\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_pending_changes WHERE `id` = '\".sqlescape(substr($id,1)).\"'\"));\n\t\t\t\tif ($f) {\n\t\t\t\t\t$f[\"id\"] = $id;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we have changes, apply them.\n\t\t\tif ($f) {\n\t\t\t\t$page[\"changes_applied\"] = true;\n\t\t\t\t$page[\"updated_at\"] = $f[\"date\"];\n\t\t\t\t$changes = json_decode($f[\"changes\"],true);\n\t\t\t\tforeach ($changes as $key => $val) {\n\t\t\t\t\tif ($key == \"external\") {\n\t\t\t\t\t\t$val = $this->getInternalPageLink($val);\n\t\t\t\t\t}\n\t\t\t\t\t$page[$key] = $val;\n\t\t\t\t}\n\t\t\t\tif ($return_tags) {\n\t\t\t\t\t// Decode the tag changes, apply them back.\n\t\t\t\t\t$tags = array();\n\t\t\t\t\t$tags_changes = json_decode($f[\"tags_changes\"],true);\n\t\t\t\t\tif (is_array($tags_changes)) {\n\t\t\t\t\t\tforeach ($tags_changes as $tag) {\n\t\t\t\t\t\t\t$tags[] = sqlfetch(sqlquery(\"SELECT * FROM bigtree_tags WHERE id = '$tag'\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t$page[\"tags\"] = $tags;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Turn resource entities into arrays that have been IPL decoded.\n\t\t\tif ($decode) {\n\t\t\t\tif (isset($page[\"resources\"]) && is_array($page[\"resources\"])) {\n\t\t\t\t\t$page[\"resources\"] = $this->decodeResources($page[\"resources\"]);\t\n\t\t\t\t}\n\t\t\t\tif (isset($page[\"callouts\"]) && is_array($page[\"callouts\"])) {\n\t\t\t\t\t$page[\"callouts\"] = $this->decodeCallouts($page[\"callouts\"]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn $page;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getPreviewLink\n\t\t\t\tReturns a URL to where this page can be previewed.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tid - The ID of the page (or pending page)\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tA URL.\n\t\t*/\n\t\t\n\t\tfunction getPreviewLink($id) {\n\t\t\tif (substr($id,0,1) == \"p\") {\n\t\t\t\treturn WWW_ROOT.\"_preview-pending/$id/\";\n\t\t\t} elseif ($id == 0) {\n\t\t\t\treturn WWW_ROOT.\"_preview/\";\n\t\t\t} else {\n\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT path FROM bigtree_pages WHERE id = '\".sqlescape($id).\"'\"));\n\t\t\t\treturn WWW_ROOT.\"_preview/\".$f[\"path\"].\"/\";\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getRelatedPagesByTags\n\t\t\t\tReturns pages related to the given set of tags.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\ttags - An array of tags to search for.\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tAn array of related pages sorted by relevance (how many tags get matched).\n\t\t*/\n\t\t\n\t\tfunction getRelatedPagesByTags($tags = array()) {\n\t\t\t$results = array();\n\t\t\t$relevance = array();\n\t\t\tforeach ($tags as $tag) {\n\t\t\t\t$tdat = sqlfetch(sqlquery(\"SELECT * FROM bigtree_tags WHERE tag = '\".sqlescape($tag).\"'\"));\n\t\t\t\tif ($tdat) {\n\t\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_tags_rel WHERE tag = '\".$tdat[\"id\"].\"' AND `table` = 'bigtree_pages'\");\n\t\t\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t\t\t$id = $f[\"entry\"];\n\t\t\t\t\t\tif (in_array($id,$results)) {\n\t\t\t\t\t\t\t$relevance[$id]++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$results[] = $id;\n\t\t\t\t\t\t\t$relevance[$id] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tarray_multisort($relevance,SORT_DESC,$results);\n\t\t\t$items = array();\n\t\t\tforeach ($results as $result) {\n\t\t\t\t$items[] = $this->getPage($result);\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getSetting\n\t\t\t\tGets the value of a setting.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tid - The ID of the setting.\n\t\t\t\n\t\t\tReturns:\t\t\t\t\n\t\t\t\tA string or array of the setting's value.\n\t\t*/\n\t\t\n\t\tfunction getSetting($id) {\n\t\t\tglobal $bigtree;\n\t\t\t$id = sqlescape($id);\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_settings WHERE id = '$id'\"));\n\t\t\t// If the setting is encrypted, we need to re-pull just the value.\n\t\t\tif ($f[\"encrypted\"]) {\n\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT AES_DECRYPT(`value`,'\".sqlescape($bigtree[\"config\"][\"settings_key\"]).\"') AS `value`, system FROM bigtree_settings WHERE id = '$id'\"));\n\t\t\t}\n\t\t\t$value = json_decode($f[\"value\"],true);\n\n\t\t\t// Don't try to do translations and such if it's a system value.\n\t\t\tif ($f[\"system\"]) {\n\t\t\t\treturn $value;\n\t\t\t}\n\t\t\t\n\t\t\tif (is_array($value)) {\n\t\t\t\treturn BigTree::untranslateArray($value);\n\t\t\t} else {\n\t\t\t\treturn $this->replaceInternalPageLinks($value);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t/*\n\t\t\tFunction: getSettings\n\t\t\t\tGets the value of multiple settings.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tid - Array containing the ID of the settings.\n\t\t\t\n\t\t\tReturns:\t\t\t\t\n\t\t\t\tArray containing the string or array of each setting's value.\n\t\t*/\n\t\t\n\t\tfunction getSettings($ids) {\n\t\t\tglobal $bigtree;\n\t\t\tif (!is_array($ids)) {\n\t\t\t\t$ids = array($ids);\n\t\t\t}\n\t\t\t$parts = array();\n\t\t\tforeach ($ids as $id) {\n\t\t\t\t$parts[] = \"id = '\".sqlescape($id).\"'\";\n\t\t\t}\n\t\t\t$settings = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_settings WHERE (\".implode(\" OR \",$parts).\") ORDER BY id ASC\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t// If the setting is encrypted, we need to re-pull just the value.\n\t\t\t\tif ($f[\"encrypted\"]) {\n\t\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT AES_DECRYPT(`value`,'\".sqlescape($bigtree[\"config\"][\"settings_key\"]).\"') AS `value` FROM bigtree_settings WHERE id = '\".$f[\"id\"].\"'\"));\n\t\t\t\t}\n\t\t\t\t$value = json_decode($f[\"value\"],true);\n\t\t\t\tif (is_array($value)) {\n\t\t\t\t\t$settings[$f[\"id\"]] = BigTree::untranslateArray($value);\n\t\t\t\t} else {\n\t\t\t\t\t$settings[$f[\"id\"]] = $this->replaceInternalPageLinks($value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $settings;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getTag\n\t\t\t\tReturns a tag for a given tag id.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tid - The id of the tag to retrieve.\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tA tag entry from bigtree_tags.\n\t\t*/\n\t\t\n\t\tfunction getTag($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_tags WHERE id = '$id'\"));\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getTagByRoute\n\t\t\t\tReturns a tag for a given tag route.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\troute - The route of the tag to retrieve.\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tA tag entry from bigtree_tags.\n\t\t*/\n\t\t\n\t\tfunction getTagByRoute($route) {\n\t\t\t$route = sqlescape($route);\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_tags WHERE route = '$route'\"));\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getTagsForPage\n\t\t\t\tReturns a list of tags the page was tagged with.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tpage - Either a page array (containing at least the page's ID) or a page ID.\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tAn array of tags.\n\t\t*/\n\t\t\n\t\tfunction getTagsForPage($page) {\n\t\t\tif (!is_numeric($page)) {\n\t\t\t\t$page = $page[\"id\"];\n\t\t\t}\n\t\t\t$q = sqlquery(\"SELECT bigtree_tags.* FROM bigtree_tags JOIN bigtree_tags_rel ON bigtree_tags.id = bigtree_tags_rel.tag WHERE bigtree_tags_rel.`table` = 'bigtree_pages' AND bigtree_tags_rel.entry = '\".sqlescape($page).\"' ORDER BY bigtree_tags.tag\");\n\t\t\t$tags = array();\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$tags[] = $f;\n\t\t\t}\n\t\t\treturn $tags;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getTemplate\n\t\t\t\tReturns a template from the database with resources decoded.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tid - The ID of the template.\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tThe template row from the database with resources decoded.\n\t\t*/\n\t\t\n\t\tfunction getTemplate($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$template = sqlfetch(sqlquery(\"SELECT * FROM bigtree_templates WHERE id = '$id'\"));\n\t\t\tif (!$template) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$template[\"resources\"] = json_decode($template[\"resources\"],true);\n\t\t\treturn $template;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getToplevelNavigationId\n\t\t\t\tReturns the highest level ancestor for the current page.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\ttrunk_as_toplevel - Treat a trunk as top level navigation instead of a new \"site\" (will return the trunk instead of the first nav item below the trunk if encountered) - defaults to false\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tThe ID of the highest ancestor of the current page.\n\t\t\t\n\t\t\tSee Also:\n\t\t\t\t<getToplevelNavigationIdForPage>\n\t\t\t\n\t\t*/\n\t\t\n\t\tfunction getTopLevelNavigationId($trunk_as_toplevel = false) {\n\t\t\tglobal $bigtree;\n\t\t\treturn $this->getTopLevelNavigationIdForPage($bigtree[\"page\"],$trunk_as_toplevel);\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getToplevelNavigationIdForPage\n\t\t\t\tReturns the highest level ancestor for a given page.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tpage - A page array (containing at least the page's \"path\").\n\t\t\t\ttrunk_as_toplevel - Treat a trunk as top level navigation instead of a new \"site\" (will return the trunk instead of the first nav item below the trunk if encountered) - defaults to false\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tThe ID of the highest ancestor of the given page.\n\t\t\t\n\t\t\tSee Also:\n\t\t\t\t<getToplevelNavigationId>\n\t\t\t\n\t\t*/\n\t\t\n\t\tfunction getTopLevelNavigationIdForPage($page,$trunk_as_toplevel = false) {\n\t\t\t$paths = array();\n\t\t\t$path = \"\";\n\t\t\t$parts = explode(\"/\",$page[\"path\"]);\n\t\t\tforeach ($parts as $part) {\n\t\t\t\t$path .= \"/\".$part;\n\t\t\t\t$path = ltrim($path,\"/\");\n\t\t\t\t$paths[] = \"path = '\".sqlescape($path).\"'\";\n\t\t\t}\n\t\t\t// Get either the trunk or the top level nav id.\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT id,trunk,path FROM bigtree_pages WHERE (\".implode(\" OR \",$paths).\") AND (trunk = 'on' OR parent = '0') ORDER BY LENGTH(path) DESC LIMIT 1\"));\n\t\t\tif ($f[\"trunk\"] && !$trunk_as_toplevel) {\n\t\t\t\t// Get the next item in the path.\n\t\t\t\t$g = sqlfetch(sqlquery(\"SELECT id FROM bigtree_pages WHERE (\".implode(\" OR \",$paths).\") AND LENGTH(path) < \".strlen($f[\"path\"]).\" ORDER BY LENGTH(path) ASC LIMIT 1\"));\n\t\t\t\tif ($g) {\n\t\t\t\t\t$f = $g;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $f[\"id\"];\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: handle404\n\t\t\t\tHandles a 404.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\turl - The URL you hit that's a 404.\n\t\t*/\n\t\t\n\t\tfunction handle404($url) {\n\t\t\t$url = sqlescape(htmlspecialchars(strip_tags(rtrim($url,\"/\"))));\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_404s WHERE broken_url = '$url'\"));\n\t\t\tif (!$url) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif ($f[\"redirect_url\"]) {\n\t\t\t\tif ($f[\"redirect_url\"] == \"/\") {\n\t\t\t\t\t$f[\"redirect_url\"] = \"\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (substr($f[\"redirect_url\"],0,7) == \"http://\" || substr($f[\"redirect_url\"],0,8) == \"https://\") {\n\t\t\t\t\t$redirect = $f[\"redirect_url\"];\n\t\t\t\t} else {\n\t\t\t\t\t$redirect = WWW_ROOT.str_replace(WWW_ROOT,\"\",$f[\"redirect_url\"]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsqlquery(\"UPDATE bigtree_404s SET requests = (requests + 1) WHERE = '\".$f[\"id\"].\"'\");\n\t\t\t\tBigTree::redirect($redirect,\"301\");\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\theader($_SERVER[\"SERVER_PROTOCOL\"].\" 404 Not Found\");\n\t\t\t\tif ($f) {\n\t\t\t\t\tsqlquery(\"UPDATE bigtree_404s SET requests = (requests + 1) WHERE id = '\".$f[\"id\"].\"'\");\n\t\t\t\t} else {\n\t\t\t\t\tsqlquery(\"INSERT INTO bigtree_404s (`broken_url`,`requests`) VALUES ('$url','1')\");\n\t\t\t\t}\n\t\t\t\tdefine(\"BIGTREE_DO_NOT_CACHE\",true);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: makeSecure\n\t\t\t\tForces the site into Secure mode.\n\t\t\t\tWhen Secure mode is enabled, BigTree will enforce the user being at HTTPS and will rewrite all insecure resources (like CSS, JavaScript, and images) to use HTTPS.\n\t\t*/\n\t\t\n\t\tfunction makeSecure() {\n\t\t\tif (!$_SERVER[\"HTTPS\"]) {\n\t\t\t\tBigTree::redirect(\"https://\".$_SERVER[\"SERVER_NAME\"].$_SERVER[\"REQUEST_URI\"],\"301\");\n\t\t\t}\n\t\t\t$this->Secure = true;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: replaceHardRoots\n\t\t\t\tReplaces all hard roots in a URL with relative ones (i.e. {wwwroot}).\n\n\t\t\tParameters:\n\t\t\t\tstring - A string with hard roots.\n\n\t\t\tReturns:\n\t\t\t\tA string with relative roots.\n\t\t*/\n\n\t\tfunction replaceHardRoots($string) {\n\t\t\treturn str_replace(array(ADMIN_ROOT,WWW_ROOT,STATIC_ROOT),array(\"{adminroot}\",\"{wwwroot}\",\"{staticroot}\"),$string);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: replaceInternalPageLinks\n\t\t\t\tReplaces the internal page links in an HTML block with hard links.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\thtml - An HTML block\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tAn HTML block with links hard-linked.\n\t\t*/\n\t\t\n\t\tfunction replaceInternalPageLinks($html) {\n\t\t\t$drop_count = 0;\n\t\t\tif (!trim($html)) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\t\n\t\t\tif (substr($html,0,6) == \"ipl://\") {\n\t\t\t\t$html = $this->getInternalPageLink($html);\n\t\t\t} else {\n\t\t\t\t$html = $this->replaceRelativeRoots($html);\n\t\t\t\t$html = preg_replace_callback('^=\"(ipl:\\/\\/[a-zA-Z0-9\\:\\/\\.\\?\\=\\-]*)\"^',create_function('$matches','global $cms; return \\'=\"\\'.$cms->getInternalPageLink($matches[1]).\\'\"\\';'),$html);\n\t\t\t}\n\n\t\t\treturn $html;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: replaceRelativeRoots\n\t\t\t\tReplaces all relative roots in a URL (i.e. {wwwroot}) with hard links.\n\n\t\t\tParameters:\n\t\t\t\tstring - A string with relative roots.\n\n\t\t\tReturns:\n\t\t\t\tA string with hard links.\n\t\t*/\n\n\t\tfunction replaceRelativeRoots($string) {\n\t\t\treturn str_replace(array(\"{adminroot}\",\"{wwwroot}\",\"{staticroot}\"),array(ADMIN_ROOT,WWW_ROOT,STATIC_ROOT),$string);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: urlify\n\t\t\t\tTurns a string into one suited for URL routes.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\ttitle - A short string.\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tA string suited for a URL route.\n\t\t*/\n\n\t\tfunction urlify($title) {\n\t\t\t$accent_match = array('\u00c2', '\u00c3', '\u00c4', '\u00c0', '\u00c1', '\u00c5', '\u00c6', '\u00c7', '\u00c8', '\u00c9', '\u00ca', '\u00cb', '\u00cc', '\u00cd', '\u00ce', '\u00cf', '\u00d0', '\u00d1', '\u00d2', '\u00d3', '\u00d4', '\u00d5', '\u00d6', '\u00d8', '\u00d9', '\u00da', '\u00db', '\u00dc', '\u00dd', '\u00df', '\u00e0', '\u00e1', '\u00e2', '\u00e3', '\u00e4', '\u00e5', '\u00e6', '\u00e7', '\u00e8', '\u00e9', '\u00ea', '\u00eb', '\u00ec', '\u00ed', '\u00ee', '\u00ef', '\u00f0', '\u00f1', '\u00f2', '\u00f3', '\u00f4', '\u00f5', '\u00f6', '\u00f8', '\u00f9', '\u00fa', '\u00fb', '\u00fc', '\u00fd', '\u00ff');\n\t\t\t$accent_replace = array('A', 'A', 'A', 'A', 'A', 'A', 'AE', 'C', 'E', 'E', 'E', 'E', 'I', 'I', 'I', 'I', 'D', 'N', 'O', 'O', 'O', 'O', 'O', 'O', 'U', 'U', 'U', 'U', 'Y', 'B', 'a', 'a', 'a', 'a', 'a', 'a', 'ae', 'c', 'e', 'e', 'e', 'e', 'i', 'i', 'i', 'i', 'o', 'n', 'o', 'o', 'o', 'o', 'o', 'o', 'u', 'u', 'u', 'u', 'y', 'y');\n\n\t\t\t$title = str_replace($accent_match, $accent_replace, $title);\n\t\t\t$title = htmlspecialchars_decode($title);\n\t\t\t$title = strtolower(preg_replace('/\\s/', '-',preg_replace('/[^a-zA-Z0-9\\s\\-\\_]+/', '',trim($title))));\n\t\t\t$title = str_replace(\"--\",\"-\",$title);\n\t\n\t\t\treturn $title;\n\t\t}\n\t}\n?>"], "fixing_code": ["<?\n\t/*\n\t\tClass: BigTreeCMS\n\t\t\tThe primary interface to BigTree that is used by the front end of the site for pulling settings, navigation, and page content.\n\t*/\n\n\tclass BigTreeCMS {\n\t\n\t\tvar $iplCache = array();\n\n\t\t/*\n\t\t\tConstructor:\n\t\t\t\tBuilds a flat file module class list so that module classes can be autoloaded instead of always in memory.\n\t\t*/\n\t\t\n\t\tfunction __construct() {\n\t\t\t// If the cache exists, just use it.\n\t\t\tif (file_exists(SERVER_ROOT.\"cache/module-class-list.btc\")) {\n\t\t\t\t$items = json_decode(file_get_contents(SERVER_ROOT.\"cache/module-class-list.btc\"),true);\n\t\t\t} else {\n\t\t\t\t// Get the Module Class List\n\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_modules\");\n\t\t\t\t$items = array();\n\t\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t\t$items[$f[\"class\"]] = $f[\"route\"];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Cache it so we don't hit the database.\n\t\t\t\tfile_put_contents(SERVER_ROOT.\"cache/module-class-list.btc\",json_encode($items));\n\t\t\t}\n\t\t\t\n\t\t\t$this->ModuleClassList = $items;\n\t\t}\n\n\t\t/*\n\t\t\tFunction: cacheGet\n\t\t\t\tRetrieves data from BigTree's cache table.\n\n\t\t\tParameters:\n\t\t\t\tidentifier - Uniquid identifier for your data type (i.e. org.bigtreecms.geocoding)\n\t\t\t\tkey - The key for your data.\n\t\t\t\tmax_age - The maximum age (in seconds) for the data, defaults to any age.\n\n\t\t\tReturns:\n\t\t\t\tData from the table (json decoded, objects convert to keyed arrays) if it exists or false.\n\t\t*/\n\n\t\tfunction cacheGet($identifier,$key,$max_age = false) {\n\t\t\t$identifier = sqlescape($identifier);\n\t\t\t$key = sqlescape($key);\n\t\t\tif ($max_age) {\n\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_caches WHERE `identifier` = '$identifier' AND `key` = '$key' AND timestamp >= '\".date(\"Y-m-d H:i:s\",time() - $max_age).\"'\"));\n\t\t\t} else {\n\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_caches WHERE `identifier` = '$identifier' AND `key` = '$key'\"));\n\t\t\t}\n\t\t\tif (!$f) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn json_decode($f[\"value\"],true);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: cachePut\n\t\t\t\tPuts data into BigTree's cache table.\n\n\t\t\tParameters:\n\t\t\t\tidentifier - Uniquid identifier for your data type (i.e. org.bigtreecms.geocoding)\n\t\t\t\tkey - The key for your data.\n\t\t\t\tvalue - The data to store.\n\t\t\t\treplace - Whether to replace an existing value (defaults to true).\n\n\t\t\tReturns:\n\t\t\t\tTrue if successful, false if the indentifier/key combination already exists and replace was set to false.\n\t\t*/\n\n\t\tfunction cachePut($identifier,$key,$value,$replace = true) {\n\t\t\t$identifier = sqlescape($identifier);\n\t\t\t$key = sqlescape($key);\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_caches WHERE `identifier` = '$identifier' AND `key` = '$key'\"));\n\t\t\tif ($f && !$replace) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Prefer to keep this an object, but we need PHP 5.3\n\t\t\tif (strnatcmp(phpversion(),'5.3') >= 0) {\n\t\t\t\t$value = sqlescape(json_encode($value,JSON_FORCE_OBJECT));\t\t\t\n\t\t\t} else {\n\t\t\t\t$value = sqlescape(json_encode($value));\n\t\t\t}\n\t\t\t\n\t\t\tif ($f) {\n\t\t\t\tsqlquery(\"UPDATE bigtree_caches SET `value` = '$value' WHERE `identifier` = '$identifier' AND `key` = '$key'\");\n\t\t\t} else {\n\t\t\t\tsqlquery(\"INSERT INTO bigtree_caches (`identifier`,`key`,`value`) VALUES ('$identifier','$key','$value')\");\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: catch404\n\t\t\t\tManually catch and display the 404 page from a routed template; logs missing page with handle404\n\t\t*/\n\t\t\n\t\tfunction catch404() {\n\t\t\tglobal $cms,$bigtree;\n\t\t\t\n\t\t\tif ($this->handle404(str_ireplace(WWW_ROOT,\"\",BigTree::currentURL()))) {\n\t\t\t\t$bigtree[\"layout\"] = \"default\";\n\t\t\t\tob_start();\n\t\t\t\tinclude \"../templates/basic/_404.php\";\n\t\t\t\t$bigtree[\"content\"] = ob_get_clean();\n\t\t\t\tob_start();\n\t\t\t\tinclude \"../templates/layouts/\".$bigtree[\"layout\"].\".php\";\n\t\t\t\tdie();\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: checkOldRoutes\n\t\t\t\tChecks the old route table, redirects if the page is found.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tpath - An array of routes\n\t\t*/\n\t\t\n\t\tfunction checkOldRoutes($path) {\n\t\t\t$found = false;\n\t\t\t$x = count($path);\n\t\t\twhile ($x) {\n\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_route_history WHERE old_route = '\".sqlescape(implode(\"/\",array_slice($path,0,$x))).\"'\"));\n\t\t\t\tif ($f) {\n\t\t\t\t\t$old = $f[\"old_route\"];\n\t\t\t\t\t$new = $f[\"new_route\"];\n\t\t\t\t\t$found = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t$x--;\n\t\t\t}\n\t\t\t// If it's in the old routing table, send them to the new page.\n\t\t\tif ($found) {\n\t\t\t\t$new_url = $new.substr($_GET[\"bigtree_htaccess_url\"],strlen($old));\n\t\t\t\tBigTree::redirect(WWW_ROOT.$new_url,\"301\");\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: decodeCallouts\n\t\t\t\tTurns the JSON callout data into a PHP array of callouts with links being translated into front-end readable links.\n\t\t\t\tThis function is called by BigTree's router and is generally not a function needed to end users.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tdata - JSON encoded callout data.\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tAn array of callouts.\n\t\t*/\t\n\t\t\t\n\t\tfunction decodeCallouts($data) {\n\t\t\t$parsed = array();\n\t\t\tif (!is_array($data)) {\n\t\t\t\t$data = json_decode($data,true);\n\t\t\t}\n\t\t\t// Just in case it was empty, we do an is_array to avoid warnings\n\t\t\tif (is_array($data)) {\n\t\t\t\tforeach ($data as $key => $d) {\n\t\t\t\t\t$p = array();\n\t\t\t\t\tforeach ($d as $kk => $dd) {\n\t\t\t\t\t\tif (is_array($dd)) {\n\t\t\t\t\t\t\t// If this value is an array, untranslate it so that {wwwroot} and ipls get fixed.\n\t\t\t\t\t\t\t$p[$kk] = BigTree::untranslateArray($dd);\n\t\t\t\t\t\t} elseif (is_array(json_decode($dd,true))) {\n\t\t\t\t\t\t\t// If this value is an array, untranslate it so that {wwwroot} and ipls get fixed.\n\t\t\t\t\t\t\t$p[$kk] = BigTree::untranslateArray(json_decode($dd,true));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Otherwise it's a string, just replace the {wwwroot} and ipls.\n\t\t\t\t\t\t\t$p[$kk] = $this->replaceInternalPageLinks($dd);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t$parsed[$key] = $p;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $parsed;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: decodeResources\n\t\t\t\tTurns the JSON resources data into a PHP array of resources with links being translated into front-end readable links.\n\t\t\t\tThis function is called by BigTree's router and is generally not a function needed to end users.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tdata - JSON encoded callout data.\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tAn array of resources.\n\t\t*/\n\n\t\tfunction decodeResources($data) {\n\t\t\tif (!is_array($data)) {\n\t\t\t\t$data = json_decode($data,true);\n\t\t\t}\n\t\t\tif (is_array($data)) {\n\t\t\t\tforeach ($data as $key => $val) {\n\t\t\t\t\tif (is_array($val)) {\n\t\t\t\t\t\t// If this value is an array, untranslate it so that {wwwroot} and ipls get fixed.\n\t\t\t\t\t\t$val = BigTree::untranslateArray($val);\n\t\t\t\t\t} elseif (is_array(json_decode($val,true))) {\n\t\t\t\t\t\t// If this value is an array, untranslate it so that {wwwroot} and ipls get fixed.\n\t\t\t\t\t\t$val = BigTree::untranslateArray(json_decode($val,true));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Otherwise it's a string, just replace the {wwwroot} and ipls.\n\t\t\t\t\t\t$val = $this->replaceInternalPageLinks($val);\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t$data[$key] = $val;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $data;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: drawXMLSitemap\n\t\t\t\tOutputs an XML sitemap.\n\t\t*/\n\t\t\n\t\tfunction drawXMLSitemap() {\n\t\t\theader(\"Content-type: text/xml\");\n\t\t\techo '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>';\n\t\t\techo '<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd\">';\n\t\t\t$q = sqlquery(\"SELECT id,template,external,path FROM bigtree_pages WHERE archived = '' AND (publish_at >= NOW() OR publish_at IS NULL) ORDER BY id ASC\");\n\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\tif ($f[\"template\"] || strpos($f[\"external\"],$GLOBALS[\"domain\"])) {\t\n\t\t\t\t\tif (!$f[\"template\"]) {\n\t\t\t\t\t\t$link = $this->getInternalPageLink($f[\"external\"]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$link = WWW_ROOT.$f[\"path\"].(($f[\"id\"] > 0) ? \"/\" : \"\"); // Fix sitemap adding trailing slashes to home\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\techo \"<url><loc>\".$link.\"</loc></url>\\n\";\n\t\t\t\t\t\n\t\t\t\t\t// Added routed template support\n\t\t\t\t\t$tf = sqlfetch(sqlquery(\"SELECT bigtree_modules.class AS module_class FROM bigtree_templates JOIN bigtree_modules ON bigtree_modules.id = bigtree_templates.module WHERE bigtree_templates.id = '\".$f[\"template\"].\"'\"));\n\t\t\t\t\tif ($tf[\"module_class\"]) {\n\t\t\t\t\t\t$mod = new $tf[\"module_class\"];\n\t\t\t\t\t\tif (method_exists($mod,\"getSitemap\")) {\n\t\t\t\t\t\t\t$subnav = $mod->getSitemap($f);\n\t\t\t\t\t\t\tforeach ($subnav as $s) {\n\t\t\t\t\t\t\t\techo \"<url><loc>\".$s[\"link\"].\"</loc></url>\\n\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$mod = $subnav = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\techo '</urlset>';\n\t\t\tdie();\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getBreadcrumb\n\t\t\t\tReturns an array of titles, links, and ids for pages above the current page.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tignore_trunk - Ignores trunk settings when returning the breadcrumb\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tAn array of arrays with \"title\", \"link\", and \"id\" of each of the pages above the current (or passed in) page.\n\t\t\t\n\t\t\tSee Also:\n\t\t\t\t<getBreadcrumbByPage>\n\t\t*/\n\t\t\n\t\tfunction getBreadcrumb($ignore_trunk = false) {\n\t\t\tglobal $bigtree;\n\t\t\treturn $this->getBreadcrumbByPage($bigtree[\"page\"],$ignore_trunk);\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getBreadcrumbByPage\n\t\t\t\tReturns an array of titles, links, and ids for the pages above the given page.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tpage - A page array (containing at least the \"path\" from the database) *(optional)*\n\t\t\t\tignore_trunk - Ignores trunk settings when returning the breadcrumb\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tAn array of arrays with \"title\", \"link\", and \"id\" of each of the pages above the current (or passed in) page.\n\t\t\t\tIf a trunk is hit, $this->BreadCrumb trunk is set to the trunk.\n\t\t\t\n\t\t\tSee Also:\n\t\t\t\t<getBreadcrumb>\n\t\t*/\n\t\t\n\t\tfunction getBreadcrumbByPage($page,$ignore_trunk = false) {\n\t\t\t$bc = array();\n\t\t\t\n\t\t\t// Break up the pieces so we can get each piece of the path individually and pull all the pages above this one.\n\t\t\t$pieces = explode(\"/\",$page[\"path\"]);\n\t\t\t$paths = array();\n\t\t\t$path = \"\";\n\t\t\tforeach ($pieces as $piece) {\n\t\t\t\t$path = $path.$piece.\"/\";\n\t\t\t\t$paths[] = \"path = '\".sqlescape(trim($path,\"/\")).\"'\";\n\t\t\t}\n\t\t\t\n\t\t\t// Get all the ancestors, ordered by the page length so we get the latest first and can count backwards to the trunk.\n\t\t\t$q = sqlquery(\"SELECT id,nav_title,path,trunk FROM bigtree_pages WHERE (\".implode(\" OR \",$paths).\") ORDER BY LENGTH(path) DESC\");\n\t\t\t$trunk_hit = false;\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\tif ($f[\"trunk\"]) {\n\t\t\t\t\t$trunk_hit = true;\n\t\t\t\t\t$this->BreadcrumbTrunk = $f;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!$trunk_hit || $ignore_trunk) {\n\t\t\t\t\t$bc[] = array(\"title\" => stripslashes($f[\"nav_title\"]),\"link\" => WWW_ROOT.$f[\"path\"].\"/\",\"id\" => $f[\"id\"]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t$bc = array_reverse($bc);\n\t\t\t\n\t\t\t// Check for module breadcrumbs\n\t\t\t$mod = sqlfetch(sqlquery(\"SELECT bigtree_modules.class FROM bigtree_modules JOIN bigtree_templates ON bigtree_modules.id = bigtree_templates.module WHERE bigtree_templates.id = '\".$page[\"template\"].\"'\"));\n\t\t\tif ($mod[\"class\"]) {\n\t\t\t\tif (class_exists($mod[\"class\"])) {\n\t\t\t\t\t@eval('$module = new '.$mod[\"class\"].';');\n\t\t\t\t\tif (method_exists($module, \"getBreadcrumb\")) {\n\t\t\t\t\t\t$bc = array_merge($bc,$module->getBreadcrumb($page));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn $bc;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getFeed\n\t\t\t\tGets a feed's information from the database.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\titem - Either the ID of the feed to pull or a raw database row of the feed data\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tAn array of feed information with options and fields decoded from JSON.\n\t\t\t\t\n\t\t\tSee Also:\n\t\t\t\t<getFeedByRoute>\n\t\t*/\n\t\t\n\t\tfunction getFeed($item) {\n\t\t\tif (!is_array($item)) {\n\t\t\t\t$item = sqlescape($item);\n\t\t\t\t$item = sqlfetch(sqlquery(\"SELECT * FROM bigtree_feeds WHERE id = '$item'\"));\n\t\t\t}\n\t\t\tif (!$item) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$item[\"options\"] = json_decode($item[\"options\"],true);\n\t\t\tif (is_array($item[\"options\"])) {\n\t\t\t\tforeach ($item[\"options\"] as &$option) {\n\t\t\t\t\t$option = $this->replaceRelativeRoots($option);\n\t\t\t\t}\n\t\t\t}\n\t\t\t$item[\"fields\"] = json_decode($item[\"fields\"],true);\n\t\t\treturn $item;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getFeedByRoute\n\t\t\t\tGets a feed's information from the database\n\t\t\t\n\t\t\tParameters:\n\t\t\t\troute - The route of the feed to pull.\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tAn array of feed information with options and fields decoded from JSON.\n\t\t\t\n\t\t\tSee Also:\n\t\t\t\t<getFeed>\n\t\t*/\n\t\t\n\t\tfunction getFeedByRoute($route) {\n\t\t\t$route = sqlescape($route);\n\t\t\t$item = sqlfetch(sqlquery(\"SELECT * FROM bigtree_feeds WHERE route = '$route'\"));\n\t\t\treturn $this->getFeed($item);\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getHiddenNavByParent\n\t\t\t\tReturns an alphabetical list of pages that are not visible in navigation.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tparent - The parent ID for which to pull child pages.\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tAn array of page entries from the database (without resources or callouts).\n\t\t\t\t\n\t\t\tSee Also:\n\t\t\t\t<getNavByParent>\n\t\t*/\n\t\t\n\t\tfunction getHiddenNavByParent($parent = 0) {\n\t\t\treturn $this->getNavByParent($parent,1,false,true);\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getInternalPageLink\n\t\t\t\tReturns a hard link to the page's publicly accessible URL from its encoded soft link URL.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tipl - Internal Page Link (ipl://, {wwwroot}, or regular URL encoding)\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tPublic facing URL.\n\t\t*/\n\t\t\n\t\tfunction getInternalPageLink($ipl) {\n\t\t\tif (substr($ipl,0,6) != \"ipl://\") {\n\t\t\t\treturn $this->replaceRelativeRoots($ipl);\n\t\t\t}\n\t\t\t$ipl = explode(\"//\",$ipl);\n\t\t\t$navid = $ipl[1];\n\t\t\t\n\t\t\t// New IPLs are encoded in JSON\n\t\t\t$c = json_decode(base64_decode($ipl[2]));\n\t\t\t// Help with transitions.\n\t\t\tif (!is_array($c)) {\n\t\t\t\t$c = unserialize(base64_decode($ipl[2]));\n\t\t\t}\n\t\t\t// If it can't be rectified, we still don't want a warning.\n\t\t\tif (is_array($c)) {\n\t\t\t\t$commands = implode(\"/\",$c);\n\t\t\t} else {\n\t\t\t\t$commands = \"\";\n\t\t\t}\n\t\t\t\n\t\t\tif ($commands && strpos($commands,\"?\") === false) {\n\t\t\t\t$commands .= \"/\";\n\t\t\t}\n\t\t\t\n\t\t\t// See if it's in the cache.\n\t\t\tif (isset($this->iplCache[$navid])) {\n\t\t\t\treturn $this->iplCache[$navid].$commands;\n\t\t\t} else {\n\t\t\t\t// Get the page's path\n\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT path FROM bigtree_pages WHERE id = '\".sqlescape($navid).\"'\"));\n\t\t\t\t// Set the cache\n\t\t\t\t$this->iplCache[$navid] = WWW_ROOT.$f[\"path\"].\"/\";\n\t\t\t\treturn WWW_ROOT.$f[\"path\"].\"/\".$commands;\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getLink\n\t\t\t\tReturns the public link to a page in the database.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tid - The ID of the page.\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tPublic facing URL.\n\t\t*/\n\t\t\n\t\tfunction getLink($id) {\n\t\t\tglobal $bigtree;\n\t\t\t// Homepage, just return the web root.\n\t\t\tif ($id == 0) {\n\t\t\t\treturn WWW_ROOT;\n\t\t\t}\n\t\t\t// If someone is requesting the link of the page they're already on we don't need to request it from the database.\n\t\t\tif ($bigtree[\"page\"][\"id\"] == $id) {\n\t\t\t\treturn WWW_ROOT.$bigtree[\"page\"][\"path\"].\"/\";\n\t\t\t}\n\t\t\t// Otherwise we'll grab the page path from the db.\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT path FROM bigtree_pages WHERE id = '\".sqlescape($id).\"'\"));\n\t\t\treturn WWW_ROOT.$f[\"path\"].\"/\";\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getNavByParent\n\t\t\t\tReturns a multi-level navigation array of pages visible in navigation\n\t\t\t\t(or hidden, if $only_hidden is set to true)\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tparent - Either a single page ID or an array of page IDs -- the latter is used internally\n\t\t\t\tlevels - The number of levels of navigation depth to recurse\n\t\t\t\tfollow_module - Whether to pull module navigation or not\n\t\t\t\tonly_hidden - Whether to pull visible (false) or hidden (true) pages\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tA multi-level navigation array containing \"id\", \"parent\", \"title\", \"route\", \"link\", \"new_window\", and \"children\"\n\t\t*/\n\t\t\t\n\t\tfunction getNavByParent($parent = 0,$levels = 1,$follow_module = true,$only_hidden = false) {\n\t\t\tstatic $module_nav_count = 0;\n\t\t\t$nav = array();\n\t\t\t$find_children = array();\n\t\t\t\n\t\t\t// If the parent is an array, this is actually a recursed call.\n\t\t\t// We're finding all the children of all the parents at once -- then we'll assign them back to the proper parent instead of doing separate calls for each.\n\t\t\tif (is_array($parent)) {\n\t\t\t\t$where_parent = array();\n\t\t\t\tforeach ($parent as $p) {\n\t\t\t\t\t$where_parent[] = \"parent = '\".sqlescape($p).\"'\";\n\t\t\t\t}\n\t\t\t\t$where_parent = \"(\".implode(\" OR \",$where_parent).\")\";\n\t\t\t// If it's an integer, let's just pull the children for the provided parent.\n\t\t\t} else {\n\t\t\t\t$parent = sqlescape($parent);\n\t\t\t\t$where_parent = \"parent = '$parent'\";\n\t\t\t}\n\t\t\t\n\t\t\t$in_nav = $only_hidden ? \"\" : \"on\";\n\t\t\t$sort = $only_hidden ? \"nav_title ASC\" : \"position DESC, id ASC\";\n\t\t\t\n\t\t\t$q = sqlquery(\"SELECT id,nav_title,parent,external,new_window,template,route,path FROM bigtree_pages WHERE $where_parent AND in_nav = '$in_nav' AND archived != 'on' AND (publish_at <= NOW() OR publish_at IS NULL) AND (expire_at >= NOW() OR expire_at IS NULL) ORDER BY $sort\");\n\t\t\t\n\t\t\t// Wrangle up some kids\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$link = WWW_ROOT.$f[\"path\"].\"/\";\n\t\t\t\t$new_window = false;\n\t\t\t\t\n\t\t\t\t// If we're REALLY an external link we won't have a template, so let's get the real link and not the encoded version.  Then we'll see if we should open this thing in a new window.\n\t\t\t\tif ($f[\"external\"] && $f[\"template\"] == \"\") {\n\t\t\t\t\t$link = $this->getInternalPageLink($f[\"external\"]);\n\t\t\t\t\tif ($f[\"new_window\"] == \"Yes\") {\n\t\t\t\t\t\t$new_window = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Add it to the nav array\n\t\t\t\t$nav[$f[\"id\"]] = array(\"id\" => $f[\"id\"], \"parent\" => $f[\"parent\"], \"title\" => $f[\"nav_title\"], \"route\" => $f[\"route\"], \"link\" => $link, \"new_window\" => $new_window, \"children\" => array());\n\t\t\t\t\n\t\t\t\t// If we're going any deeper, mark down that we're looking for kids of this kid.\n\t\t\t\tif ($levels > 1) {\n\t\t\t\t\t$find_children[] = $f[\"id\"];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// If we're looking for children, send them all back into getNavByParent, decrease the depth we're looking for by one.\n\t\t\tif (count($find_children)) {\n\t\t\t\t$subnav = $this->getNavByParent($find_children,$levels - 1,$follow_module);\n\t\t\t\tforeach ($subnav as $item) {\n\t\t\t\t\t// Reassign these new children back to their parent node.\n\t\t\t\t\t$nav[$item[\"parent\"]][\"children\"][$item[\"id\"]] = $item;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// If we're pulling in module navigation...\n\t\t\tif ($follow_module) {\n\t\t\t\t// This is a recursed iteration.\n\t\t\t\tif (is_array($parent)) {\n\t\t\t\t\t$where_parent = array();\n\t\t\t\t\tforeach ($parent as $p) {\n\t\t\t\t\t\t$where_parent[] = \"bigtree_pages.id = '\".sqlescape($p).\"'\";\n\t\t\t\t\t}\n\t\t\t\t\t$q = sqlquery(\"SELECT bigtree_modules.class,bigtree_templates.routed,bigtree_templates.module,bigtree_pages.id,bigtree_pages.path,bigtree_pages.template FROM bigtree_modules JOIN bigtree_templates JOIN bigtree_pages ON bigtree_templates.id = bigtree_pages.template WHERE bigtree_modules.id = bigtree_templates.module AND (\".implode(\" OR \",$where_parent).\")\");\n\t\t\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t\t\t// If the class exists, instantiate it and call it\n\t\t\t\t\t\tif ($f[\"class\"] && class_exists($f[\"class\"])) {\n\t\t\t\t\t\t\t@eval('$module = new '.$f[\"class\"].';');\n\t\t\t\t\t\t\tif (method_exists($module,\"getNav\")) {\n\t\t\t\t\t\t\t\t$modNav = $module->getNav($f);\n\t\t\t\t\t\t\t\t// Give the parent back to each of the items it returned so they can be reassigned to the proper parent.\n\t\t\t\t\t\t\t\t$module_nav = array();\n\t\t\t\t\t\t\t\tforeach ($modNav as $item) {\n\t\t\t\t\t\t\t\t\t$item[\"parent\"] = $f[\"id\"];\n\t\t\t\t\t\t\t\t\t$item[\"id\"] = \"module_nav_\".$module_nav_count;\n\t\t\t\t\t\t\t\t\t$module_nav[] = $item;\n\t\t\t\t\t\t\t\t\t$module_nav_count++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ($module->NavPosition == \"top\") {\n\t\t\t\t\t\t\t\t\t$nav = array_merge($module_nav,$nav);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$nav = array_merge($nav,$module_nav);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t// This is the first iteration.\n\t\t\t\t} else {\n\t\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT bigtree_modules.class,bigtree_templates.routed,bigtree_templates.module,bigtree_pages.id,bigtree_pages.path,bigtree_pages.template FROM bigtree_modules JOIN bigtree_templates JOIN bigtree_pages ON bigtree_templates.id = bigtree_pages.template WHERE bigtree_modules.id = bigtree_templates.module AND bigtree_pages.id = '$parent'\"));\n\t\t\t\t\t// If the class exists, instantiate it and call it.\n\t\t\t\t\tif ($f[\"class\"] && class_exists($f[\"class\"])) {\n\t\t\t\t\t\t@eval('$module = new '.$f[\"class\"].';');\n\t\t\t\t\t\tif (method_exists($module,\"getNav\")) {\n\t\t\t\t\t\t\tif ($module->NavPosition == \"top\") {\n\t\t\t\t\t\t\t\t$nav = array_merge($module->getNav($f),$nav);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$nav = array_merge($nav,$module->getNav($f));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn $nav;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getNavId\n\t\t\t\tProvides the page ID for a given path array.\n\t\t\t\tThis is a method used by the router and the admin and can generally be ignored.\n\t\t\t\n\t\t\tParamaters:\n\t\t\t\tpath - An array of path elements from a URL\n\t\t\t\tpreviewing - Whether we are previewing or not.\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tAn array containing the page ID and any additional commands.\n\t\t*/\n\t\t\n\t\tfunction getNavId($path,$previewing = false) {\n\t\t\t$commands = array();\n\t\t\t\n\t\t\tif (!$previewing) {\n\t\t\t\t$publish_at = \"AND (publish_at <= NOW() OR publish_at IS NULL) AND (expire_at >= NOW() OR expire_at IS NULL)\";\n\t\t\t} else {\n\t\t\t\t$publish_at = \"\";\n\t\t\t}\n\t\t\t\n\t\t\t// See if we have a straight up perfect match to the path.\n\t\t\t$spath = sqlescape(implode(\"/\",$path));\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT bigtree_pages.id,bigtree_templates.routed FROM bigtree_pages LEFT JOIN bigtree_templates ON bigtree_pages.template = bigtree_templates.id WHERE path = '$spath' AND archived = '' $publish_at\"));\n\t\t\tif ($f) {\n\t\t\t\treturn array($f[\"id\"],$commands,$f[\"routed\"]);\n\t\t\t}\n\t\t\t\n\t\t\t// Guess we don't, let's chop off commands until we find a page.\n\t\t\t$x = 0;\n\t\t\twhile ($x < count($path)) {\n\t\t\t\t$x++;\n\t\t\t\t$commands[] = $path[count($path)-$x];\n\t\t\t\t$spath = sqlescape(implode(\"/\",array_slice($path,0,-1 * $x)));\n\t\t\t\t// We have additional commands, so we're now making sure the template is also routed, otherwise it's a 404.\n\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT bigtree_pages.id FROM bigtree_pages JOIN bigtree_templates ON bigtree_pages.template = bigtree_templates.id WHERE bigtree_pages.path = '$spath' AND bigtree_pages.archived = '' AND bigtree_templates.routed = 'on' $publish_at\"));\n\t\t\t\tif ($f) {\n\t\t\t\t\treturn array($f[\"id\"],array_reverse($commands),\"on\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn array(false,false,false);\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getPage\n\t\t\t\tReturns a page along with its resources and callouts decoded.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tchild - The ID of the page.\n\t\t\t\tdecode - Whether to decode resources and callouts or not (setting to false saves processing time)\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tA page array from the database.\n\t\t*/\n\t\t\n\t\tfunction getPage($child,$decode = true) {\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_pages WHERE id = '$child'\"));\n\t\t\tif (!$f) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ($f[\"external\"] && $f[\"template\"] == \"\") {\n\t\t\t\t$f[\"external\"] = $this->getInternalPageLink($f[\"external\"]);\n\t\t\t}\n\t\t\tif ($decode) {\n\t\t\t\t$f[\"resources\"] = $this->decodeResources($f[\"resources\"]);\n\t\t\t\t$f[\"callouts\"] = $this->decodeCallouts($f[\"callouts\"]);\n\t\t\t}\n\t\t\treturn $f;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getPendingPage\n\t\t\t\tReturns a page along with pending changes applied.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tchild - The ID of the page.\n\t\t\t\tdecode - Whether to decode resources and callouts or not (setting to false saves processing time, defaults true).\n\t\t\t\treturn_tags - Whether to return tags for the page (defaults false).\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tA page array from the database.\n\t\t*/\n\t\t\n\t\tfunction getPendingPage($id,$decode = true,$return_tags = false) {\n\t\t\t// Numeric id means the page is live.\n\t\t\tif (is_numeric($id)) {\n\t\t\t\t$page = $this->getPage($id);\n\t\t\t\tif (!$page) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// If we're looking for tags, apply them to the page.\n\t\t\t\tif ($return_tags) {\n\t\t\t\t\t$page[\"tags\"] = $this->getTagsForPage($id);\n\t\t\t\t}\n\t\t\t\t// Get pending changes for this page.\n\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_pending_changes WHERE `table` = 'bigtree_pages' AND item_id = '\".$page[\"id\"].\"'\"));\n\n\t\t\t// If it's prefixed with a \"p\" then it's a pending entry.\n\t\t\t} else {\n\t\t\t\t// Set the page to empty, we're going to loop through the change later and apply the fields.\n\t\t\t\t$page = array();\n\t\t\t\t// Get the changes.\n\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_pending_changes WHERE `id` = '\".sqlescape(substr($id,1)).\"'\"));\n\t\t\t\tif ($f) {\n\t\t\t\t\t$f[\"id\"] = $id;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we have changes, apply them.\n\t\t\tif ($f) {\n\t\t\t\t$page[\"changes_applied\"] = true;\n\t\t\t\t$page[\"updated_at\"] = $f[\"date\"];\n\t\t\t\t$changes = json_decode($f[\"changes\"],true);\n\t\t\t\tforeach ($changes as $key => $val) {\n\t\t\t\t\tif ($key == \"external\") {\n\t\t\t\t\t\t$val = $this->getInternalPageLink($val);\n\t\t\t\t\t}\n\t\t\t\t\t$page[$key] = $val;\n\t\t\t\t}\n\t\t\t\tif ($return_tags) {\n\t\t\t\t\t// Decode the tag changes, apply them back.\n\t\t\t\t\t$tags = array();\n\t\t\t\t\t$tags_changes = json_decode($f[\"tags_changes\"],true);\n\t\t\t\t\tif (is_array($tags_changes)) {\n\t\t\t\t\t\tforeach ($tags_changes as $tag) {\n\t\t\t\t\t\t\t$tags[] = sqlfetch(sqlquery(\"SELECT * FROM bigtree_tags WHERE id = '$tag'\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t$page[\"tags\"] = $tags;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Turn resource entities into arrays that have been IPL decoded.\n\t\t\tif ($decode) {\n\t\t\t\tif (isset($page[\"resources\"]) && is_array($page[\"resources\"])) {\n\t\t\t\t\t$page[\"resources\"] = $this->decodeResources($page[\"resources\"]);\t\n\t\t\t\t}\n\t\t\t\tif (isset($page[\"callouts\"]) && is_array($page[\"callouts\"])) {\n\t\t\t\t\t$page[\"callouts\"] = $this->decodeCallouts($page[\"callouts\"]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn $page;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getPreviewLink\n\t\t\t\tReturns a URL to where this page can be previewed.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tid - The ID of the page (or pending page)\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tA URL.\n\t\t*/\n\t\t\n\t\tfunction getPreviewLink($id) {\n\t\t\tif (substr($id,0,1) == \"p\") {\n\t\t\t\treturn WWW_ROOT.\"_preview-pending/$id/\";\n\t\t\t} elseif ($id == 0) {\n\t\t\t\treturn WWW_ROOT.\"_preview/\";\n\t\t\t} else {\n\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT path FROM bigtree_pages WHERE id = '\".sqlescape($id).\"'\"));\n\t\t\t\treturn WWW_ROOT.\"_preview/\".$f[\"path\"].\"/\";\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getRelatedPagesByTags\n\t\t\t\tReturns pages related to the given set of tags.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\ttags - An array of tags to search for.\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tAn array of related pages sorted by relevance (how many tags get matched).\n\t\t*/\n\t\t\n\t\tfunction getRelatedPagesByTags($tags = array()) {\n\t\t\t$results = array();\n\t\t\t$relevance = array();\n\t\t\tforeach ($tags as $tag) {\n\t\t\t\t$tdat = sqlfetch(sqlquery(\"SELECT * FROM bigtree_tags WHERE tag = '\".sqlescape($tag).\"'\"));\n\t\t\t\tif ($tdat) {\n\t\t\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_tags_rel WHERE tag = '\".$tdat[\"id\"].\"' AND `table` = 'bigtree_pages'\");\n\t\t\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t\t\t$id = $f[\"entry\"];\n\t\t\t\t\t\tif (in_array($id,$results)) {\n\t\t\t\t\t\t\t$relevance[$id]++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$results[] = $id;\n\t\t\t\t\t\t\t$relevance[$id] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tarray_multisort($relevance,SORT_DESC,$results);\n\t\t\t$items = array();\n\t\t\tforeach ($results as $result) {\n\t\t\t\t$items[] = $this->getPage($result);\n\t\t\t}\n\t\t\treturn $items;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getSetting\n\t\t\t\tGets the value of a setting.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tid - The ID of the setting.\n\t\t\t\n\t\t\tReturns:\t\t\t\t\n\t\t\t\tA string or array of the setting's value.\n\t\t*/\n\t\t\n\t\tfunction getSetting($id) {\n\t\t\tglobal $bigtree;\n\t\t\t$id = sqlescape($id);\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_settings WHERE id = '$id'\"));\n\t\t\t// If the setting is encrypted, we need to re-pull just the value.\n\t\t\tif ($f[\"encrypted\"]) {\n\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT AES_DECRYPT(`value`,'\".sqlescape($bigtree[\"config\"][\"settings_key\"]).\"') AS `value`, system FROM bigtree_settings WHERE id = '$id'\"));\n\t\t\t}\n\t\t\t$value = json_decode($f[\"value\"],true);\n\n\t\t\t// Don't try to do translations and such if it's a system value.\n\t\t\tif ($f[\"system\"]) {\n\t\t\t\treturn $value;\n\t\t\t}\n\t\t\t\n\t\t\tif (is_array($value)) {\n\t\t\t\treturn BigTree::untranslateArray($value);\n\t\t\t} else {\n\t\t\t\treturn $this->replaceInternalPageLinks($value);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t/*\n\t\t\tFunction: getSettings\n\t\t\t\tGets the value of multiple settings.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tid - Array containing the ID of the settings.\n\t\t\t\n\t\t\tReturns:\t\t\t\t\n\t\t\t\tArray containing the string or array of each setting's value.\n\t\t*/\n\t\t\n\t\tfunction getSettings($ids) {\n\t\t\tglobal $bigtree;\n\t\t\tif (!is_array($ids)) {\n\t\t\t\t$ids = array($ids);\n\t\t\t}\n\t\t\t$parts = array();\n\t\t\tforeach ($ids as $id) {\n\t\t\t\t$parts[] = \"id = '\".sqlescape($id).\"'\";\n\t\t\t}\n\t\t\t$settings = array();\n\t\t\t$q = sqlquery(\"SELECT * FROM bigtree_settings WHERE (\".implode(\" OR \",$parts).\") ORDER BY id ASC\");\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t// If the setting is encrypted, we need to re-pull just the value.\n\t\t\t\tif ($f[\"encrypted\"]) {\n\t\t\t\t\t$f = sqlfetch(sqlquery(\"SELECT AES_DECRYPT(`value`,'\".sqlescape($bigtree[\"config\"][\"settings_key\"]).\"') AS `value` FROM bigtree_settings WHERE id = '\".$f[\"id\"].\"'\"));\n\t\t\t\t}\n\t\t\t\t$value = json_decode($f[\"value\"],true);\n\t\t\t\tif (is_array($value)) {\n\t\t\t\t\t$settings[$f[\"id\"]] = BigTree::untranslateArray($value);\n\t\t\t\t} else {\n\t\t\t\t\t$settings[$f[\"id\"]] = $this->replaceInternalPageLinks($value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $settings;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getTag\n\t\t\t\tReturns a tag for a given tag id.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tid - The id of the tag to retrieve.\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tA tag entry from bigtree_tags.\n\t\t*/\n\t\t\n\t\tfunction getTag($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_tags WHERE id = '$id'\"));\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getTagByRoute\n\t\t\t\tReturns a tag for a given tag route.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\troute - The route of the tag to retrieve.\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tA tag entry from bigtree_tags.\n\t\t*/\n\t\t\n\t\tfunction getTagByRoute($route) {\n\t\t\t$route = sqlescape($route);\n\t\t\treturn sqlfetch(sqlquery(\"SELECT * FROM bigtree_tags WHERE route = '$route'\"));\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getTagsForPage\n\t\t\t\tReturns a list of tags the page was tagged with.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tpage - Either a page array (containing at least the page's ID) or a page ID.\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tAn array of tags.\n\t\t*/\n\t\t\n\t\tfunction getTagsForPage($page) {\n\t\t\tif (!is_numeric($page)) {\n\t\t\t\t$page = $page[\"id\"];\n\t\t\t}\n\t\t\t$q = sqlquery(\"SELECT bigtree_tags.* FROM bigtree_tags JOIN bigtree_tags_rel ON bigtree_tags.id = bigtree_tags_rel.tag WHERE bigtree_tags_rel.`table` = 'bigtree_pages' AND bigtree_tags_rel.entry = '\".sqlescape($page).\"' ORDER BY bigtree_tags.tag\");\n\t\t\t$tags = array();\n\t\t\twhile ($f = sqlfetch($q)) {\n\t\t\t\t$tags[] = $f;\n\t\t\t}\n\t\t\treturn $tags;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getTemplate\n\t\t\t\tReturns a template from the database with resources decoded.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tid - The ID of the template.\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tThe template row from the database with resources decoded.\n\t\t*/\n\t\t\n\t\tfunction getTemplate($id) {\n\t\t\t$id = sqlescape($id);\n\t\t\t$template = sqlfetch(sqlquery(\"SELECT * FROM bigtree_templates WHERE id = '$id'\"));\n\t\t\tif (!$template) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$template[\"resources\"] = json_decode($template[\"resources\"],true);\n\t\t\treturn $template;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getToplevelNavigationId\n\t\t\t\tReturns the highest level ancestor for the current page.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\ttrunk_as_toplevel - Treat a trunk as top level navigation instead of a new \"site\" (will return the trunk instead of the first nav item below the trunk if encountered) - defaults to false\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tThe ID of the highest ancestor of the current page.\n\t\t\t\n\t\t\tSee Also:\n\t\t\t\t<getToplevelNavigationIdForPage>\n\t\t\t\n\t\t*/\n\t\t\n\t\tfunction getTopLevelNavigationId($trunk_as_toplevel = false) {\n\t\t\tglobal $bigtree;\n\t\t\treturn $this->getTopLevelNavigationIdForPage($bigtree[\"page\"],$trunk_as_toplevel);\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: getToplevelNavigationIdForPage\n\t\t\t\tReturns the highest level ancestor for a given page.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\tpage - A page array (containing at least the page's \"path\").\n\t\t\t\ttrunk_as_toplevel - Treat a trunk as top level navigation instead of a new \"site\" (will return the trunk instead of the first nav item below the trunk if encountered) - defaults to false\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tThe ID of the highest ancestor of the given page.\n\t\t\t\n\t\t\tSee Also:\n\t\t\t\t<getToplevelNavigationId>\n\t\t\t\n\t\t*/\n\t\t\n\t\tfunction getTopLevelNavigationIdForPage($page,$trunk_as_toplevel = false) {\n\t\t\t$paths = array();\n\t\t\t$path = \"\";\n\t\t\t$parts = explode(\"/\",$page[\"path\"]);\n\t\t\tforeach ($parts as $part) {\n\t\t\t\t$path .= \"/\".$part;\n\t\t\t\t$path = ltrim($path,\"/\");\n\t\t\t\t$paths[] = \"path = '\".sqlescape($path).\"'\";\n\t\t\t}\n\t\t\t// Get either the trunk or the top level nav id.\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT id,trunk,path FROM bigtree_pages WHERE (\".implode(\" OR \",$paths).\") AND (trunk = 'on' OR parent = '0') ORDER BY LENGTH(path) DESC LIMIT 1\"));\n\t\t\tif ($f[\"trunk\"] && !$trunk_as_toplevel) {\n\t\t\t\t// Get the next item in the path.\n\t\t\t\t$g = sqlfetch(sqlquery(\"SELECT id FROM bigtree_pages WHERE (\".implode(\" OR \",$paths).\") AND LENGTH(path) < \".strlen($f[\"path\"]).\" ORDER BY LENGTH(path) ASC LIMIT 1\"));\n\t\t\t\tif ($g) {\n\t\t\t\t\t$f = $g;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $f[\"id\"];\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: handle404\n\t\t\t\tHandles a 404.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\turl - The URL you hit that's a 404.\n\t\t*/\n\t\t\n\t\tfunction handle404($url) {\n\t\t\t$url = sqlescape(htmlspecialchars(strip_tags(rtrim($url,\"/\"))));\n\t\t\t$f = sqlfetch(sqlquery(\"SELECT * FROM bigtree_404s WHERE broken_url = '$url'\"));\n\t\t\tif (!$url) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif ($f[\"redirect_url\"]) {\n\t\t\t\tif ($f[\"redirect_url\"] == \"/\") {\n\t\t\t\t\t$f[\"redirect_url\"] = \"\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (substr($f[\"redirect_url\"],0,7) == \"http://\" || substr($f[\"redirect_url\"],0,8) == \"https://\") {\n\t\t\t\t\t$redirect = $f[\"redirect_url\"];\n\t\t\t\t} else {\n\t\t\t\t\t$redirect = WWW_ROOT.str_replace(WWW_ROOT,\"\",$f[\"redirect_url\"]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsqlquery(\"UPDATE bigtree_404s SET requests = (requests + 1) WHERE = '\".$f[\"id\"].\"'\");\n\t\t\t\tBigTree::redirect($redirect,\"301\");\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\theader($_SERVER[\"SERVER_PROTOCOL\"].\" 404 Not Found\");\n\t\t\t\tif ($f) {\n\t\t\t\t\tsqlquery(\"UPDATE bigtree_404s SET requests = (requests + 1) WHERE id = '\".$f[\"id\"].\"'\");\n\t\t\t\t} else {\n\t\t\t\t\tsqlquery(\"INSERT INTO bigtree_404s (`broken_url`,`requests`) VALUES ('$url','1')\");\n\t\t\t\t}\n\t\t\t\tdefine(\"BIGTREE_DO_NOT_CACHE\",true);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: makeSecure\n\t\t\t\tForces the site into Secure mode.\n\t\t\t\tWhen Secure mode is enabled, BigTree will enforce the user being at HTTPS and will rewrite all insecure resources (like CSS, JavaScript, and images) to use HTTPS.\n\t\t*/\n\t\t\n\t\tfunction makeSecure() {\n\t\t\tif (!$_SERVER[\"HTTPS\"]) {\n\t\t\t\tBigTree::redirect(\"https://\".$_SERVER[\"SERVER_NAME\"].$_SERVER[\"REQUEST_URI\"],\"301\");\n\t\t\t}\n\t\t\t$this->Secure = true;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: replaceHardRoots\n\t\t\t\tReplaces all hard roots in a URL with relative ones (i.e. {wwwroot}).\n\n\t\t\tParameters:\n\t\t\t\tstring - A string with hard roots.\n\n\t\t\tReturns:\n\t\t\t\tA string with relative roots.\n\t\t*/\n\n\t\tfunction replaceHardRoots($string) {\n\t\t\treturn str_replace(array(ADMIN_ROOT,WWW_ROOT,STATIC_ROOT),array(\"{adminroot}\",\"{wwwroot}\",\"{staticroot}\"),$string);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: replaceInternalPageLinks\n\t\t\t\tReplaces the internal page links in an HTML block with hard links.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\thtml - An HTML block\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tAn HTML block with links hard-linked.\n\t\t*/\n\t\t\n\t\tfunction replaceInternalPageLinks($html) {\n\t\t\t$drop_count = 0;\n\t\t\tif (!trim($html)) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\t\n\t\t\tif (substr($html,0,6) == \"ipl://\") {\n\t\t\t\t$html = $this->getInternalPageLink($html);\n\t\t\t} else {\n\t\t\t\t$html = $this->replaceRelativeRoots($html);\n\t\t\t\t$html = preg_replace_callback('^=\"(ipl:\\/\\/[a-zA-Z0-9\\:\\/\\.\\?\\=\\-]*)\"^',create_function('$matches','global $cms; return \\'=\"\\'.$cms->getInternalPageLink($matches[1]).\\'\"\\';'),$html);\n\t\t\t}\n\n\t\t\treturn $html;\n\t\t}\n\t\t\n\t\t/*\n\t\t\tFunction: replaceRelativeRoots\n\t\t\t\tReplaces all relative roots in a URL (i.e. {wwwroot}) with hard links.\n\n\t\t\tParameters:\n\t\t\t\tstring - A string with relative roots.\n\n\t\t\tReturns:\n\t\t\t\tA string with hard links.\n\t\t*/\n\n\t\tfunction replaceRelativeRoots($string) {\n\t\t\treturn str_replace(array(\"{adminroot}\",\"{wwwroot}\",\"{staticroot}\"),array(ADMIN_ROOT,WWW_ROOT,STATIC_ROOT),$string);\n\t\t}\n\n\t\t/*\n\t\t\tFunction: urlify\n\t\t\t\tTurns a string into one suited for URL routes.\n\t\t\t\n\t\t\tParameters:\n\t\t\t\ttitle - A short string.\n\t\t\t\n\t\t\tReturns:\n\t\t\t\tA string suited for a URL route.\n\t\t*/\n\n\t\tfunction urlify($title) {\n\t\t\t$accent_match = array('\u00c2', '\u00c3', '\u00c4', '\u00c0', '\u00c1', '\u00c5', '\u00c6', '\u00c7', '\u00c8', '\u00c9', '\u00ca', '\u00cb', '\u00cc', '\u00cd', '\u00ce', '\u00cf', '\u00d0', '\u00d1', '\u00d2', '\u00d3', '\u00d4', '\u00d5', '\u00d6', '\u00d8', '\u00d9', '\u00da', '\u00db', '\u00dc', '\u00dd', '\u00df', '\u00e0', '\u00e1', '\u00e2', '\u00e3', '\u00e4', '\u00e5', '\u00e6', '\u00e7', '\u00e8', '\u00e9', '\u00ea', '\u00eb', '\u00ec', '\u00ed', '\u00ee', '\u00ef', '\u00f0', '\u00f1', '\u00f2', '\u00f3', '\u00f4', '\u00f5', '\u00f6', '\u00f8', '\u00f9', '\u00fa', '\u00fb', '\u00fc', '\u00fd', '\u00ff');\n\t\t\t$accent_replace = array('A', 'A', 'A', 'A', 'A', 'A', 'AE', 'C', 'E', 'E', 'E', 'E', 'I', 'I', 'I', 'I', 'D', 'N', 'O', 'O', 'O', 'O', 'O', 'O', 'U', 'U', 'U', 'U', 'Y', 'B', 'a', 'a', 'a', 'a', 'a', 'a', 'ae', 'c', 'e', 'e', 'e', 'e', 'i', 'i', 'i', 'i', 'o', 'n', 'o', 'o', 'o', 'o', 'o', 'o', 'u', 'u', 'u', 'u', 'y', 'y');\n\n\t\t\t$title = str_replace($accent_match, $accent_replace, $title);\n\t\t\t$title = htmlspecialchars_decode($title);\n\t\t\t$title = strtolower(preg_replace('/\\s/', '-',preg_replace('/[^a-zA-Z0-9\\s\\-\\_]+/', '',trim($title))));\n\t\t\t$title = str_replace(\"--\",\"-\",$title);\n\t\n\t\t\treturn $title;\n\t\t}\n\t}\n?>"], "filenames": ["core/inc/bigtree/cms.php"], "buggy_code_start_loc": [130], "buggy_code_end_loc": [131], "fixing_code_start_loc": [130], "fixing_code_end_loc": [131], "type": "CWE-89", "message": "SQL injection vulnerability in core/inc/bigtree/cms.php in BigTree CMS 4.0 RC2 and earlier allows remote attackers to execute arbitrary SQL commands via the PATH_INFO to index.php.", "other": {"cve": {"id": "CVE-2013-4879", "sourceIdentifier": "cve@mitre.org", "published": "2013-08-14T13:49:59.753", "lastModified": "2017-08-29T01:33:40.917", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "SQL injection vulnerability in core/inc/bigtree/cms.php in BigTree CMS 4.0 RC2 and earlier allows remote attackers to execute arbitrary SQL commands via the PATH_INFO to index.php."}, {"lang": "es", "value": "Vulnerabilidad de inyecci\u00f3n SQL en core/inc/bigtree/cms.php en BigTree CMS 4.0 RC2 y anteriores permite a atacantes remotos ejecutar comandos SQL arbitrarios a trav\u00e9s de PATH_INFO de index.php"}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bigtreecms:bigtree_cms:*:rc2:*:*:*:*:*:*", "versionEndIncluding": "4.0", "matchCriteriaId": "C6BFF3D3-DE9A-4D38-AA46-81C80C291C6C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bigtreecms:bigtree_cms:4.0:b1:*:*:*:*:*:*", "matchCriteriaId": "C2FE7AD4-680F-46AB-B781-19F7E4B95593"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bigtreecms:bigtree_cms:4.0:b2:*:*:*:*:*:*", "matchCriteriaId": "5EB20F45-4FD0-4BDF-926B-83A7178A16E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bigtreecms:bigtree_cms:4.0:b3:*:*:*:*:*:*", "matchCriteriaId": "5A8E73F4-6BB4-4BA7-B7DF-DC2C3DB96D3C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bigtreecms:bigtree_cms:4.0:b4:*:*:*:*:*:*", "matchCriteriaId": "EB85F2AE-F5C8-4975-A668-3F19A16611EE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bigtreecms:bigtree_cms:4.0:b5:*:*:*:*:*:*", "matchCriteriaId": "67AB2377-6B06-4962-BD58-9C33225F17BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bigtreecms:bigtree_cms:4.0:b6:*:*:*:*:*:*", "matchCriteriaId": "94F5DCD4-1538-47E2-9D74-89FCB120FB84"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bigtreecms:bigtree_cms:4.0:b7:*:*:*:*:*:*", "matchCriteriaId": "FC4B947C-3C45-424E-BEE8-F56CCBEBF384"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bigtreecms:bigtree_cms:4.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "EBA1EB0F-5860-4642-8CD6-5A871ADBDAA9"}]}]}], "references": [{"url": "http://archives.neohapsis.com/archives/bugtraq/2013-08/0039.html", "source": "cve@mitre.org", "tags": ["Exploit"]}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/86285", "source": "cve@mitre.org"}, {"url": "https://github.com/bigtreecms/BigTree-CMS/commit/c5f27bf66a7f35bd3daeb5f693f3e2493f51b1f3", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}, {"url": "https://www.htbridge.com/advisory/HTB23165", "source": "cve@mitre.org", "tags": ["Exploit"]}]}, "github_commit_url": "https://github.com/bigtreecms/BigTree-CMS/commit/c5f27bf66a7f35bd3daeb5f693f3e2493f51b1f3"}}