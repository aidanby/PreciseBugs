{"buggy_code": ["/*\n * Copyright (c) 2018, SUSE LLC.\n *\n * This program is licensed under the BSD license, read LICENSE.BSD\n * for further information\n */\n\n/*\n * repodata.c\n *\n * Manage data coming from one repository\n *\n * a repository can contain multiple repodata entries, consisting of\n * different sets of keys and different sets of solvables\n */\n\n#define _GNU_SOURCE\n#include <string.h>\n#include <fnmatch.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <assert.h>\n#include <regex.h>\n\n#include \"repo.h\"\n#include \"pool.h\"\n#include \"poolid_private.h\"\n#include \"util.h\"\n#include \"hash.h\"\n#include \"chksum.h\"\n\n#include \"repopack.h\"\n#include \"repopage.h\"\n\n#ifdef _WIN32\n  #include \"strfncs.h\"\n#endif\n\n#define REPODATA_BLOCK 255\n\nstatic unsigned char *data_skip_key(Repodata *data, unsigned char *dp, Repokey *key);\n\nvoid\nrepodata_initdata(Repodata *data, Repo *repo, int localpool)\n{\n  memset(data, 0, sizeof (*data));\n  data->repodataid = data - repo->repodata;\n  data->repo = repo;\n  data->localpool = localpool;\n  if (localpool)\n    stringpool_init_empty(&data->spool);\n  /* dirpool_init(&data->dirpool);\tjust zeros out again */\n  data->keys = solv_calloc(1, sizeof(Repokey));\n  data->nkeys = 1;\n  data->schemata = solv_calloc(1, sizeof(Id));\n  data->schemadata = solv_calloc(1, sizeof(Id));\n  data->nschemata = 1;\n  data->schemadatalen = 1;\n  repopagestore_init(&data->store);\n}\n\nvoid\nrepodata_freedata(Repodata *data)\n{\n  int i;\n\n  solv_free(data->keys);\n\n  solv_free(data->schemata);\n  solv_free(data->schemadata);\n  solv_free(data->schematahash);\n\n  stringpool_free(&data->spool);\n  dirpool_free(&data->dirpool);\n\n  solv_free(data->mainschemaoffsets);\n  solv_free(data->incoredata);\n  solv_free(data->incoreoffset);\n  solv_free(data->verticaloffset);\n\n  repopagestore_free(&data->store);\n\n  solv_free(data->vincore);\n\n  if (data->attrs)\n    for (i = 0; i < data->end - data->start; i++)\n      solv_free(data->attrs[i]);\n  solv_free(data->attrs);\n  if (data->xattrs)\n    for (i = 0; i < data->nxattrs; i++)\n      solv_free(data->xattrs[i]);\n  solv_free(data->xattrs);\n\n  solv_free(data->attrdata);\n  solv_free(data->attriddata);\n  solv_free(data->attrnum64data);\n\n  solv_free(data->dircache);\n\n  repodata_free_filelistfilter(data);\n}\n\nvoid\nrepodata_free(Repodata *data)\n{\n  Repo *repo = data->repo;\n  int i = data - repo->repodata;\n  if (i == 0)\n    return;\n  repodata_freedata(data);\n  if (i < repo->nrepodata - 1)\n    {\n      /* whoa! this changes the repodataids! */\n      memmove(repo->repodata + i, repo->repodata + i + 1, (repo->nrepodata - 1 - i) * sizeof(Repodata));\n      for (; i < repo->nrepodata - 1; i++)\n\trepo->repodata[i].repodataid = i;\n    }\n  repo->nrepodata--;\n  if (repo->nrepodata == 1)\n    {\n      repo->repodata = solv_free(repo->repodata);\n      repo->nrepodata = 0;\n    }\n}\n\nvoid\nrepodata_empty(Repodata *data, int localpool)\n{\n  void (*loadcallback)(Repodata *) = data->loadcallback;\n  int state = data->state;\n  repodata_freedata(data);\n  repodata_initdata(data, data->repo, localpool);\n  data->state = state;\n  data->loadcallback = loadcallback;\n}\n\n\n/***************************************************************\n * key pool management\n */\n\n/* this is not so time critical that we need a hash, so we do a simple\n * linear search */\nId\nrepodata_key2id(Repodata *data, Repokey *key, int create)\n{\n  Id keyid;\n\n  for (keyid = 1; keyid < data->nkeys; keyid++)\n    if (data->keys[keyid].name == key->name && data->keys[keyid].type == key->type)\n      {\n        if ((key->type == REPOKEY_TYPE_CONSTANT || key->type == REPOKEY_TYPE_CONSTANTID) && key->size != data->keys[keyid].size)\n          continue;\n        break;\n      }\n  if (keyid == data->nkeys)\n    {\n      if (!create)\n\treturn 0;\n      /* allocate new key */\n      data->keys = solv_realloc2(data->keys, data->nkeys + 1, sizeof(Repokey));\n      data->keys[data->nkeys++] = *key;\n      if (data->verticaloffset)\n        {\n          data->verticaloffset = solv_realloc2(data->verticaloffset, data->nkeys, sizeof(Id));\n          data->verticaloffset[data->nkeys - 1] = 0;\n        }\n      data->keybits[(key->name >> 3) & (sizeof(data->keybits) - 1)] |= 1 << (key->name & 7);\n    }\n  return keyid;\n}\n\n\n/***************************************************************\n * schema pool management\n */\n\n#define SCHEMATA_BLOCK 31\n#define SCHEMATADATA_BLOCK 255\n\nId\nrepodata_schema2id(Repodata *data, Id *schema, int create)\n{\n  int h, len, i;\n  Id *sp, cid;\n  Id *schematahash;\n\n  if (!*schema)\n    return 0;\t/* XXX: allow empty schema? */\n  if ((schematahash = data->schematahash) == 0)\n    {\n      data->schematahash = schematahash = solv_calloc(256, sizeof(Id));\n      for (i = 1; i < data->nschemata; i++)\n\t{\n\t  for (sp = data->schemadata + data->schemata[i], h = 0; *sp;)\n\t    h = h * 7 + *sp++;\n\t  h &= 255;\n\t  schematahash[h] = i;\n\t}\n      data->schemadata = solv_extend_resize(data->schemadata, data->schemadatalen, sizeof(Id), SCHEMATADATA_BLOCK);\n      data->schemata = solv_extend_resize(data->schemata, data->nschemata, sizeof(Id), SCHEMATA_BLOCK);\n    }\n\n  for (sp = schema, len = 0, h = 0; *sp; len++)\n    h = h * 7 + *sp++;\n  h &= 255;\n  len++;\n\n  cid = schematahash[h];\n  if (cid)\n    {\n      if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n        return cid;\n      /* cache conflict, do a slow search */\n      for (cid = 1; cid < data->nschemata; cid++)\n        if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n          return cid;\n    }\n  /* a new one */\n  if (!create)\n    return 0;\n  data->schemadata = solv_extend(data->schemadata, data->schemadatalen, len, sizeof(Id), SCHEMATADATA_BLOCK);\n  data->schemata = solv_extend(data->schemata, data->nschemata, 1, sizeof(Id), SCHEMATA_BLOCK);\n  /* add schema */\n  memcpy(data->schemadata + data->schemadatalen, schema, len * sizeof(Id));\n  data->schemata[data->nschemata] = data->schemadatalen;\n  data->schemadatalen += len;\n  schematahash[h] = data->nschemata;\n#if 0\nfprintf(stderr, \"schema2id: new schema\\n\");\n#endif\n  return data->nschemata++;\n}\n\nvoid\nrepodata_free_schemahash(Repodata *data)\n{\n  data->schematahash = solv_free(data->schematahash);\n  /* shrink arrays */\n  data->schemata = solv_realloc2(data->schemata, data->nschemata, sizeof(Id));\n  data->schemadata = solv_realloc2(data->schemadata, data->schemadatalen, sizeof(Id));\n}\n\n\n/***************************************************************\n * dir pool management\n */\n\n#ifndef HAVE_STRCHRNUL\nstatic inline const char *strchrnul(const char *str, char x)\n{\n  const char *p = strchr(str, x);\n  return p ? p : str + strlen(str);\n}\n#endif\n\n#define DIRCACHE_SIZE 41\t/* < 1k */\n\n#ifdef DIRCACHE_SIZE\nstruct dircache {\n  Id ids[DIRCACHE_SIZE];\n  char str[(DIRCACHE_SIZE * (DIRCACHE_SIZE - 1)) / 2];\n};\n#endif\n\nId\nrepodata_str2dir(Repodata *data, const char *dir, int create)\n{\n  Id id, parent;\n#ifdef DIRCACHE_SIZE\n  const char *dirs;\n#endif\n  const char *dire;\n\n  if (!*dir)\n    return data->dirpool.ndirs ? 0 : dirpool_add_dir(&data->dirpool, 0, 0, create);\n  while (*dir == '/' && dir[1] == '/')\n    dir++;\n  if (*dir == '/' && !dir[1])\n    return data->dirpool.ndirs ? 1 : dirpool_add_dir(&data->dirpool, 0, 1, create);\n  parent = 0;\n#ifdef DIRCACHE_SIZE\n  dirs = dir;\n  if (data->dircache)\n    {\n      int l;\n      struct dircache *dircache = data->dircache;\n      l = strlen(dir);\n      while (l > 0)\n\t{\n\t  if (l < DIRCACHE_SIZE && dircache->ids[l] && !memcmp(dircache->str + l * (l - 1) / 2, dir, l))\n\t    {\n\t      parent = dircache->ids[l];\n\t      dir += l;\n\t      if (!*dir)\n\t\treturn parent;\n\t      while (*dir == '/')\n\t\tdir++;\n\t      break;\n\t    }\n\t  while (--l)\n\t    if (dir[l] == '/')\n\t      break;\n\t}\n    }\n#endif\n  while (*dir)\n    {\n      dire = strchrnul(dir, '/');\n      if (data->localpool)\n        id = stringpool_strn2id(&data->spool, dir, dire - dir, create);\n      else\n\tid = pool_strn2id(data->repo->pool, dir, dire - dir, create);\n      if (!id)\n\treturn 0;\n      parent = dirpool_add_dir(&data->dirpool, parent, id, create);\n      if (!parent)\n\treturn 0;\n#ifdef DIRCACHE_SIZE\n      if (!data->dircache)\n\tdata->dircache = solv_calloc(1, sizeof(struct dircache));\n      if (data->dircache)\n\t{\n\t  int l = dire - dirs;\n\t  if (l < DIRCACHE_SIZE)\n\t    {\n\t      data->dircache->ids[l] = parent;\n\t      memcpy(data->dircache->str + l * (l - 1) / 2, dirs, l);\n\t    }\n\t}\n#endif\n      if (!*dire)\n\tbreak;\n      dir = dire + 1;\n      while (*dir == '/')\n\tdir++;\n    }\n  return parent;\n}\n\nvoid\nrepodata_free_dircache(Repodata *data)\n{\n  data->dircache = solv_free(data->dircache);\n}\n\nconst char *\nrepodata_dir2str(Repodata *data, Id did, const char *suf)\n{\n  Pool *pool = data->repo->pool;\n  int l = 0;\n  Id parent, comp;\n  const char *comps;\n  char *p;\n\n  if (!did)\n    return suf ? suf : \"\";\n  if (did == 1 && !suf)\n    return \"/\";\n  parent = did;\n  while (parent)\n    {\n      comp = dirpool_compid(&data->dirpool, parent);\n      comps = stringpool_id2str(data->localpool ? &data->spool : &pool->ss, comp);\n      l += strlen(comps);\n      parent = dirpool_parent(&data->dirpool, parent);\n      if (parent)\n\tl++;\n    }\n  if (suf)\n    l += strlen(suf) + 1;\n  p = pool_alloctmpspace(pool, l + 1) + l;\n  *p = 0;\n  if (suf)\n    {\n      p -= strlen(suf);\n      strcpy(p, suf);\n      *--p = '/';\n    }\n  parent = did;\n  while (parent)\n    {\n      comp = dirpool_compid(&data->dirpool, parent);\n      comps = stringpool_id2str(data->localpool ? &data->spool : &pool->ss, comp);\n      l = strlen(comps);\n      p -= l;\n      strncpy(p, comps, l);\n      parent = dirpool_parent(&data->dirpool, parent);\n      if (parent)\n        *--p = '/';\n    }\n  return p;\n}\n\n\n/***************************************************************\n * data management\n */\n\nstatic inline unsigned char *\ndata_skip_schema(Repodata *data, unsigned char *dp, Id schema)\n{\n  Id *keyp = data->schemadata + data->schemata[schema];\n  for (; *keyp; keyp++)\n    dp = data_skip_key(data, dp, data->keys + *keyp);\n  return dp;\n}\n\nstatic unsigned char *\ndata_skip_key(Repodata *data, unsigned char *dp, Repokey *key)\n{\n  int nentries, schema;\n  switch(key->type)\n    {\n    case REPOKEY_TYPE_FIXARRAY:\n      dp = data_read_id(dp, &nentries);\n      if (!nentries)\n\treturn dp;\n      dp = data_read_id(dp, &schema);\n      while (nentries--)\n\tdp = data_skip_schema(data, dp, schema);\n      return dp;\n    case REPOKEY_TYPE_FLEXARRAY:\n      dp = data_read_id(dp, &nentries);\n      while (nentries--)\n\t{\n\t  dp = data_read_id(dp, &schema);\n\t  dp = data_skip_schema(data, dp, schema);\n\t}\n      return dp;\n    default:\n      if (key->storage == KEY_STORAGE_INCORE)\n        dp = data_skip(dp, key->type);\n      else if (key->storage == KEY_STORAGE_VERTICAL_OFFSET)\n\t{\n\t  dp = data_skip(dp, REPOKEY_TYPE_ID);\n\t  dp = data_skip(dp, REPOKEY_TYPE_ID);\n\t}\n      return dp;\n    }\n}\n\nstatic unsigned char *\nforward_to_key(Repodata *data, Id keyid, Id *keyp, unsigned char *dp)\n{\n  Id k;\n\n  if (!keyid)\n    return 0;\n  if (data->mainschemaoffsets && dp == data->incoredata + data->mainschemaoffsets[0] && keyp == data->schemadata + data->schemata[data->mainschema])\n    {\n      int i;\n      for (i = 0; (k = *keyp++) != 0; i++)\n        if (k == keyid)\n\t  return data->incoredata + data->mainschemaoffsets[i];\n      return 0;\n    }\n  while ((k = *keyp++) != 0)\n    {\n      if (k == keyid)\n\treturn dp;\n      if (data->keys[k].storage == KEY_STORAGE_VERTICAL_OFFSET)\n\t{\n\t  dp = data_skip(dp, REPOKEY_TYPE_ID);\t/* skip offset */\n\t  dp = data_skip(dp, REPOKEY_TYPE_ID);\t/* skip length */\n\t  continue;\n\t}\n      if (data->keys[k].storage != KEY_STORAGE_INCORE)\n\tcontinue;\n      dp = data_skip_key(data, dp, data->keys + k);\n    }\n  return 0;\n}\n\nstatic unsigned char *\nget_vertical_data(Repodata *data, Repokey *key, Id off, Id len)\n{\n  unsigned char *dp;\n  if (len <= 0)\n    return 0;\n  if (off >= data->lastverticaloffset)\n    {\n      off -= data->lastverticaloffset;\n      if ((unsigned int)off + len > data->vincorelen)\n\treturn 0;\n      return data->vincore + off;\n    }\n  if ((unsigned int)off + len > key->size)\n    return 0;\n  /* we now have the offset, go into vertical */\n  off += data->verticaloffset[key - data->keys];\n  /* fprintf(stderr, \"key %d page %d\\n\", key->name, off / REPOPAGE_BLOBSIZE); */\n  dp = repopagestore_load_page_range(&data->store, off / REPOPAGE_BLOBSIZE, (off + len - 1) / REPOPAGE_BLOBSIZE);\n  data->storestate++;\n  if (dp)\n    dp += off % REPOPAGE_BLOBSIZE;\n  return dp;\n}\n\nstatic inline unsigned char *\nget_data(Repodata *data, Repokey *key, unsigned char **dpp, int advance)\n{\n  unsigned char *dp = *dpp;\n\n  if (!dp)\n    return 0;\n  if (key->storage == KEY_STORAGE_INCORE)\n    {\n      if (advance)\n        *dpp = data_skip_key(data, dp, key);\n      return dp;\n    }\n  else if (key->storage == KEY_STORAGE_VERTICAL_OFFSET)\n    {\n      Id off, len;\n      dp = data_read_id(dp, &off);\n      dp = data_read_id(dp, &len);\n      if (advance)\n        *dpp = dp;\n      return get_vertical_data(data, key, off, len);\n    }\n  return 0;\n}\n\nvoid\nrepodata_load(Repodata *data)\n{\n  if (data->state != REPODATA_STUB)\n    return;\n  if (data->loadcallback)\n    data->loadcallback(data);\n  else\n    data->state = REPODATA_ERROR;\n}\n\nstatic int\nmaybe_load_repodata_stub(Repodata *data, Id keyname)\n{\n  if (data->state != REPODATA_STUB)\n    {\n      data->state = REPODATA_ERROR;\n      return 0;\n    }\n  if (keyname)\n    {\n      int i;\n      for (i = 1; i < data->nkeys; i++)\n\tif (keyname == data->keys[i].name)\n\t  break;\n      if (i == data->nkeys)\n\treturn 0;\n    }\n  repodata_load(data);\n  return data->state == REPODATA_AVAILABLE ? 1 : 0;\n}\n\nstatic inline int\nmaybe_load_repodata(Repodata *data, Id keyname)\n{\n  if (keyname && !repodata_precheck_keyname(data, keyname))\n    return 0;\t/* do not bother... */\n  if (data->state == REPODATA_AVAILABLE || data->state == REPODATA_LOADING)\n    return 1;\n  if (data->state == REPODATA_ERROR)\n    return 0;\n  return maybe_load_repodata_stub(data, keyname);\n}\n\nstatic inline unsigned char *\nsolvid2data(Repodata *data, Id solvid, Id *schemap)\n{\n  unsigned char *dp = data->incoredata;\n  if (!dp)\n    return 0;\n  if (solvid == SOLVID_META)\n    dp += 1;\t/* offset of \"meta\" solvable */\n  else if (solvid == SOLVID_POS)\n    {\n      Pool *pool = data->repo->pool;\n      if (data->repo != pool->pos.repo)\n\treturn 0;\n      if (data != data->repo->repodata + pool->pos.repodataid)\n\treturn 0;\n      dp += pool->pos.dp;\n      if (pool->pos.dp != 1)\n        {\n          *schemap = pool->pos.schema;\n          return dp;\n\t}\n    }\n  else\n    {\n      if (solvid < data->start || solvid >= data->end)\n\treturn 0;\n      dp += data->incoreoffset[solvid - data->start];\n    }\n  return data_read_id(dp, schemap);\n}\n\n/************************************************************************\n * data lookup\n */\n\nstatic unsigned char *\nfind_key_data(Repodata *data, Id solvid, Id keyname, Repokey **keypp)\n{\n  unsigned char *dp;\n  Id schema, *keyp, *kp;\n  Repokey *key;\n\n  if (!maybe_load_repodata(data, keyname))\n    return 0;\n  dp = solvid2data(data, solvid, &schema);\n  if (!dp)\n    return 0;\n  keyp = data->schemadata + data->schemata[schema];\n  for (kp = keyp; *kp; kp++)\n    if (data->keys[*kp].name == keyname)\n      break;\n  if (!*kp)\n    return 0;\n  *keypp = key = data->keys + *kp;\n  if (key->type == REPOKEY_TYPE_DELETED)\n    return 0;\n  if (key->type == REPOKEY_TYPE_VOID || key->type == REPOKEY_TYPE_CONSTANT || key->type == REPOKEY_TYPE_CONSTANTID)\n    return dp;\t/* no need to forward... */\n  if (key->storage != KEY_STORAGE_INCORE && key->storage != KEY_STORAGE_VERTICAL_OFFSET)\n    return 0;\t/* get_data will not work, no need to forward */\n  dp = forward_to_key(data, *kp, keyp, dp);\n  if (!dp)\n    return 0;\n  return get_data(data, key, &dp, 0);\n}\n\nstatic const Id *\nrepodata_lookup_schemakeys(Repodata *data, Id solvid)\n{\n  Id schema;\n  if (!maybe_load_repodata(data, 0))\n    return 0;\n  if (!solvid2data(data, solvid, &schema))\n    return 0;\n  return data->schemadata + data->schemata[schema];\n}\n\nstatic Id *\nalloc_keyskip()\n{\n  Id *keyskip = solv_calloc(3 + 256, sizeof(Id));\n  keyskip[0] = 256; \n  keyskip[1] = keyskip[2] = 1; \n  return keyskip;\n}\n\nId *\nrepodata_fill_keyskip(Repodata *data, Id solvid, Id *keyskip)\n{\n  const Id *keyp;\n  Id maxkeyname, value;\n  keyp = repodata_lookup_schemakeys(data, solvid);\n  if (!keyp)\n    return keyskip;\t/* no keys for this solvid */\n  if (!keyskip)\n    keyskip = alloc_keyskip();\n  maxkeyname = keyskip[0];\n  value = keyskip[1] + data->repodataid;\n  for (; *keyp; keyp++)\n    {\n      Id keyname = data->keys[*keyp].name;\n      if (keyname >= maxkeyname)\n\t{\n\t  int newmax = (keyname | 255) + 1; \n\t  keyskip = solv_realloc2(keyskip, 3 + newmax, sizeof(Id));\n\t  memset(keyskip + (3 + maxkeyname), 0, (newmax - maxkeyname) * sizeof(Id));\n\t  keyskip[0] = maxkeyname = newmax;\n\t}\n      keyskip[3 + keyname] = value;\n    }\n  return keyskip;\n}\n\nId\nrepodata_lookup_type(Repodata *data, Id solvid, Id keyname)\n{\n  Id schema, *keyp, *kp;\n  if (!maybe_load_repodata(data, keyname))\n    return 0;\n  if (!solvid2data(data, solvid, &schema))\n    return 0;\n  keyp = data->schemadata + data->schemata[schema];\n  for (kp = keyp; *kp; kp++)\n    if (data->keys[*kp].name == keyname)\n      return data->keys[*kp].type;\n  return 0;\n}\n\nId\nrepodata_lookup_id(Repodata *data, Id solvid, Id keyname)\n{\n  unsigned char *dp;\n  Repokey *key;\n  Id id;\n\n  dp = find_key_data(data, solvid, keyname, &key);\n  if (!dp)\n    return 0;\n  if (key->type == REPOKEY_TYPE_CONSTANTID)\n    return key->size;\n  if (key->type != REPOKEY_TYPE_ID)\n    return 0;\n  dp = data_read_id(dp, &id);\n  return id;\n}\n\nconst char *\nrepodata_lookup_str(Repodata *data, Id solvid, Id keyname)\n{\n  unsigned char *dp;\n  Repokey *key;\n  Id id;\n\n  dp = find_key_data(data, solvid, keyname, &key);\n  if (!dp)\n    return 0;\n  if (key->type == REPOKEY_TYPE_STR)\n    return (const char *)dp;\n  if (key->type == REPOKEY_TYPE_CONSTANTID)\n    id = key->size;\n  else if (key->type == REPOKEY_TYPE_ID)\n    dp = data_read_id(dp, &id);\n  else\n    return 0;\n  if (data->localpool)\n    return stringpool_id2str(&data->spool, id);\n  return pool_id2str(data->repo->pool, id);\n}\n\nunsigned long long\nrepodata_lookup_num(Repodata *data, Id solvid, Id keyname, unsigned long long notfound)\n{\n  unsigned char *dp;\n  Repokey *key;\n  unsigned int high, low;\n\n  dp = find_key_data(data, solvid, keyname, &key);\n  if (!dp)\n    return notfound;\n  switch (key->type)\n    {\n    case REPOKEY_TYPE_NUM:\n      data_read_num64(dp, &low, &high);\n      return (unsigned long long)high << 32 | low;\n    case REPOKEY_TYPE_CONSTANT:\n      return key->size;\n    default:\n      return notfound;\n    }\n}\n\nint\nrepodata_lookup_void(Repodata *data, Id solvid, Id keyname)\n{\n  return repodata_lookup_type(data, solvid, keyname) == REPOKEY_TYPE_VOID ? 1 : 0;\n}\n\nconst unsigned char *\nrepodata_lookup_bin_checksum(Repodata *data, Id solvid, Id keyname, Id *typep)\n{\n  unsigned char *dp;\n  Repokey *key;\n\n  dp = find_key_data(data, solvid, keyname, &key);\n  if (!dp)\n    return 0;\n  switch (key->type)\n    {\n    case_CHKSUM_TYPES:\n      break;\n    default:\n      return 0;\n    }\n  *typep = key->type;\n  return dp;\n}\n\nint\nrepodata_lookup_idarray(Repodata *data, Id solvid, Id keyname, Queue *q)\n{\n  unsigned char *dp;\n  Repokey *key;\n  Id id;\n  int eof = 0;\n\n  queue_empty(q);\n  dp = find_key_data(data, solvid, keyname, &key);\n  if (!dp)\n    return 0;\n  switch (key->type)\n    {\n    case REPOKEY_TYPE_CONSTANTID:\n      queue_push(q, key->size);\n      break;\n    case REPOKEY_TYPE_ID:\n      dp = data_read_id(dp, &id);\n      queue_push(q, id);\n      break;\n    case REPOKEY_TYPE_IDARRAY:\n      for (;;)\n\t{\n\t  dp = data_read_ideof(dp, &id, &eof);\n\t  queue_push(q, id);\n\t  if (eof)\n\t    break;\n\t}\n      break;\n    default:\n      return 0;\n    }\n  return 1;\n}\n\nconst void *\nrepodata_lookup_binary(Repodata *data, Id solvid, Id keyname, int *lenp)\n{\n  unsigned char *dp;\n  Repokey *key;\n  Id len;\n\n  dp = find_key_data(data, solvid, keyname, &key);\n  if (!dp || key->type != REPOKEY_TYPE_BINARY)\n    {\n      *lenp = 0;\n      return 0;\n    }\n  dp = data_read_id(dp, &len);\n  *lenp = len;\n  return dp;\n}\n\n/* highly specialized function to speed up fileprovides adding.\n * - repodata must be available\n * - solvid must be >= data->start and < data->end\n * - returns NULL is not found, a \"\" entry if wrong type\n * - also returns wrong type for REPOKEY_TYPE_DELETED\n */\nconst unsigned char *\nrepodata_lookup_packed_dirstrarray(Repodata *data, Id solvid, Id keyname)\n{\n  static unsigned char wrongtype[2] = { 0x00 /* dir id 0 */, 0 /* \"\" */ };\n  unsigned char *dp;\n  Id schema, *keyp, *kp;\n  Repokey *key;\n\n  if (!data->incoredata || !data->incoreoffset[solvid - data->start])\n    return 0;\n  dp = data->incoredata + data->incoreoffset[solvid - data->start];\n  dp = data_read_id(dp, &schema);\n  keyp = data->schemadata + data->schemata[schema];\n  for (kp = keyp; *kp; kp++)\n    if (data->keys[*kp].name == keyname)\n      break;\n  if (!*kp)\n    return 0;\n  key = data->keys + *kp;\n  if (key->type != REPOKEY_TYPE_DIRSTRARRAY)\n    return wrongtype;\n  dp = forward_to_key(data, *kp, keyp, dp);\n  if (key->storage == KEY_STORAGE_INCORE)\n    return dp;\n  if (key->storage == KEY_STORAGE_VERTICAL_OFFSET && dp)\n    {\n      Id off, len;\n      dp = data_read_id(dp, &off);\n      data_read_id(dp, &len);\n      return get_vertical_data(data, key, off, len);\n    }\n  return 0;\n}\n\n/* id translation functions */\n\nId\nrepodata_globalize_id(Repodata *data, Id id, int create)\n{\n  if (!id || !data || !data->localpool)\n    return id;\n  return pool_str2id(data->repo->pool, stringpool_id2str(&data->spool, id), create);\n}\n\nId\nrepodata_localize_id(Repodata *data, Id id, int create)\n{\n  if (!id || !data || !data->localpool)\n    return id;\n  return stringpool_str2id(&data->spool, pool_id2str(data->repo->pool, id), create);\n}\n\nId\nrepodata_translate_id(Repodata *data, Repodata *fromdata, Id id, int create)\n{\n  const char *s;\n  if (!id || !data || !fromdata)\n    return id;\n  if (data == fromdata || (!data->localpool && !fromdata->localpool))\n    return id;\n  if (fromdata->localpool)\n    s = stringpool_id2str(&fromdata->spool, id);\n  else\n    s = pool_id2str(data->repo->pool, id);\n  if (data->localpool)\n    return stringpool_str2id(&data->spool, s, create);\n  else\n    return pool_str2id(data->repo->pool, s, create);\n}\n\nId\nrepodata_translate_dir_slow(Repodata *data, Repodata *fromdata, Id dir, int create, Id *cache)\n{\n  Id parent, compid;\n  if (!dir)\n    {\n      /* make sure that the dirpool has an entry */\n      if (create && !data->dirpool.ndirs)\n        dirpool_add_dir(&data->dirpool, 0, 0, create);\n      return 0;\n    }\n  parent = dirpool_parent(&fromdata->dirpool, dir);\n  if (parent)\n    {\n      if (!(parent = repodata_translate_dir(data, fromdata, parent, create, cache)))\n\treturn 0;\n    }\n  compid = dirpool_compid(&fromdata->dirpool, dir);\n  if (compid > 1 && (data->localpool || fromdata->localpool))\n    {\n      if (!(compid = repodata_translate_id(data, fromdata, compid, create)))\n\treturn 0;\n    }\n  if (!(compid = dirpool_add_dir(&data->dirpool, parent, compid, create)))\n    return 0;\n  if (cache)\n    {\n      cache[(dir & 255) * 2] = dir;\n      cache[(dir & 255) * 2 + 1] = compid;\n    }\n  return compid;\n}\n\n/************************************************************************\n * uninternalized lookup / search\n */\n\nstatic void\ndata_fetch_uninternalized(Repodata *data, Repokey *key, Id value, KeyValue *kv)\n{\n  Id *array;\n  kv->eof = 1;\n  switch (key->type)\n    {\n    case REPOKEY_TYPE_STR:\n      kv->str = (const char *)data->attrdata + value;\n      return;\n    case REPOKEY_TYPE_CONSTANT:\n      kv->num2 = 0;\n      kv->num = key->size;\n      return;\n    case REPOKEY_TYPE_CONSTANTID:\n      kv->id = key->size;\n      return;\n    case REPOKEY_TYPE_NUM:\n      kv->num2 = 0;\n      kv->num = value;\n      if (value & 0x80000000)\n\t{\n\t  kv->num = (unsigned int)data->attrnum64data[value ^ 0x80000000];\n\t  kv->num2 = (unsigned int)(data->attrnum64data[value ^ 0x80000000] >> 32);\n\t}\n      return;\n    case_CHKSUM_TYPES:\n      kv->num = 0;\t/* not stringified */\n      kv->str = (const char *)data->attrdata + value;\n      return;\n    case REPOKEY_TYPE_BINARY:\n      kv->str = (const char *)data_read_id(data->attrdata + value, (Id *)&kv->num);\n      return;\n    case REPOKEY_TYPE_IDARRAY:\n      array = data->attriddata + (value + kv->entry);\n      kv->id = array[0];\n      kv->eof = array[1] ? 0 : 1;\n      return;\n    case REPOKEY_TYPE_DIRSTRARRAY:\n      kv->num = 0;\t/* not stringified */\n      array = data->attriddata + (value + kv->entry * 2);\n      kv->id = array[0];\n      kv->str = (const char *)data->attrdata + array[1];\n      kv->eof = array[2] ? 0 : 1;\n      return;\n    case REPOKEY_TYPE_DIRNUMNUMARRAY:\n      array = data->attriddata + (value + kv->entry * 3);\n      kv->id = array[0];\n      kv->num = array[1];\n      kv->num2 = array[2];\n      kv->eof = array[3] ? 0 : 1;\n      return;\n    case REPOKEY_TYPE_FIXARRAY:\n    case REPOKEY_TYPE_FLEXARRAY:\n      array = data->attriddata + (value + kv->entry);\n      kv->id = array[0];\t\t/* the handle */\n      kv->eof = array[1] ? 0 : 1;\n      return;\n    default:\n      kv->id = value;\n      return;\n    }\n}\n\nRepokey *\nrepodata_lookup_kv_uninternalized(Repodata *data, Id solvid, Id keyname, KeyValue *kv)\n{\n  Id *ap;\n  if (!data->attrs || solvid < data->start || solvid >= data->end)\n    return 0;\n  ap = data->attrs[solvid - data->start];\n  if (!ap)\n    return 0;\n  for (; *ap; ap += 2)\n    {\n      Repokey *key = data->keys + *ap;\n      if (key->name != keyname)\n\tcontinue;\n      data_fetch_uninternalized(data, key, ap[1], kv);\n      return key;\n    }\n  return 0;\n}\n\nvoid\nrepodata_search_uninternalized(Repodata *data, Id solvid, Id keyname, int flags, int (*callback)(void *cbdata, Solvable *s, Repodata *data, Repokey *key, KeyValue *kv), void *cbdata)\n{\n  Id *ap;\n  int stop;\n  Solvable *s;\n  KeyValue kv;\n\n  if (!data->attrs || solvid < data->start || solvid >= data->end)\n    return;\n  ap = data->attrs[solvid - data->start];\n  if (!ap)\n    return;\n  for (; *ap; ap += 2)\n    {\n      Repokey *key = data->keys + *ap;\n      if (keyname && key->name != keyname)\n\tcontinue;\n      s = solvid > 0 ? data->repo->pool->solvables + solvid : 0;\n      kv.entry = 0;\n      do\n\t{\n\t  data_fetch_uninternalized(data, key, ap[1], &kv);\n\t  stop = callback(cbdata, s, data, key, &kv);\n\t  kv.entry++;\n\t}\n      while (!kv.eof && !stop);\n      if (keyname || stop > SEARCH_NEXT_KEY)\n\treturn;\n    }\n}\n\n/************************************************************************\n * data search\n */\n\n\nconst char *\nrepodata_stringify(Pool *pool, Repodata *data, Repokey *key, KeyValue *kv, int flags)\n{\n  switch (key->type)\n    {\n    case REPOKEY_TYPE_ID:\n    case REPOKEY_TYPE_CONSTANTID:\n    case REPOKEY_TYPE_IDARRAY:\n      if (data && data->localpool)\n\tkv->str = stringpool_id2str(&data->spool, kv->id);\n      else\n\tkv->str = pool_id2str(pool, kv->id);\n      if ((flags & SEARCH_SKIP_KIND) != 0 && key->storage == KEY_STORAGE_SOLVABLE && (key->name == SOLVABLE_NAME || key->type == REPOKEY_TYPE_IDARRAY))\n\t{\n\t  const char *s;\n\t  for (s = kv->str; *s >= 'a' && *s <= 'z'; s++)\n\t    ;\n\t  if (*s == ':' && s > kv->str)\n\t    kv->str = s + 1;\n\t}\n      return kv->str;\n    case REPOKEY_TYPE_STR:\n      return kv->str;\n    case REPOKEY_TYPE_DIRSTRARRAY:\n      if (!(flags & SEARCH_FILES))\n\treturn kv->str;\t/* match just the basename */\n      if (kv->num)\n\treturn kv->str;\t/* already stringified */\n      /* Put the full filename into kv->str.  */\n      kv->str = repodata_dir2str(data, kv->id, kv->str);\n      kv->num = 1;\t/* mark stringification */\n      return kv->str;\n    case_CHKSUM_TYPES:\n      if (!(flags & SEARCH_CHECKSUMS))\n\treturn 0;\t/* skip em */\n      if (kv->num)\n\treturn kv->str;\t/* already stringified */\n      kv->str = repodata_chk2str(data, key->type, (const unsigned char *)kv->str);\n      kv->num = 1;\t/* mark stringification */\n      return kv->str;\n    default:\n      return 0;\n    }\n}\n\n\n/* this is an internal hack to pass the parent kv to repodata_search_keyskip */\nstruct subschema_data {\n  void *cbdata;\n  Id solvid;\n  KeyValue *parent;\n};\n\nvoid\nrepodata_search_arrayelement(Repodata *data, Id solvid, Id keyname, int flags, KeyValue *kv, int (*callback)(void *cbdata, Solvable *s, Repodata *data, Repokey *key, KeyValue *kv), void *cbdata)\n{\n  repodata_search_keyskip(data, solvid, keyname, flags | SEARCH_SUBSCHEMA, (Id *)kv, callback, cbdata);\n}\n\nstatic int\nrepodata_search_array(Repodata *data, Id solvid, Id keyname, int flags, Repokey *key, KeyValue *kv, int (*callback)(void *cbdata, Solvable *s, Repodata *data, Repokey *key, KeyValue *kv), void *cbdata)\n{\n  Solvable *s = solvid > 0 ? data->repo->pool->solvables + solvid : 0;\n  unsigned char *dp = (unsigned char *)kv->str;\n  int stop;\n  Id schema = 0;\n\n  if (!dp || kv->entry != -1)\n    return 0;\n  while (++kv->entry < (int)kv->num)\n    {\n      if (kv->entry)\n\tdp = data_skip_schema(data, dp, schema);\n      if (kv->entry == 0 || key->type == REPOKEY_TYPE_FLEXARRAY)\n\tdp = data_read_id(dp, &schema);\n      kv->id = schema;\n      kv->str = (const char *)dp;\n      kv->eof = kv->entry == kv->num - 1 ? 1 : 0;\n      stop = callback(cbdata, s, data, key, kv);\n      if (stop && stop != SEARCH_ENTERSUB)\n\treturn stop;\n      if ((flags & SEARCH_SUB) != 0 || stop == SEARCH_ENTERSUB)\n        repodata_search_keyskip(data, solvid, keyname, flags | SEARCH_SUBSCHEMA, (Id *)kv, callback, cbdata);\n    }\n  if ((flags & SEARCH_ARRAYSENTINEL) != 0)\n    {\n      if (kv->entry)\n\tdp = data_skip_schema(data, dp, schema);\n      kv->id = 0;\n      kv->str = (const char *)dp;\n      kv->eof = 2;\n      return callback(cbdata, s, data, key, kv);\n    }\n  return 0;\n}\n\n/* search a specific repodata */\nvoid\nrepodata_search_keyskip(Repodata *data, Id solvid, Id keyname, int flags, Id *keyskip, int (*callback)(void *cbdata, Solvable *s, Repodata *data, Repokey *key, KeyValue *kv), void *cbdata)\n{\n  Id schema;\n  Repokey *key;\n  Id keyid, *kp, *keyp;\n  unsigned char *dp, *ddp;\n  int onekey = 0;\n  int stop;\n  KeyValue kv;\n  Solvable *s;\n\n  if (!maybe_load_repodata(data, keyname))\n    return;\n  if ((flags & SEARCH_SUBSCHEMA) != 0)\n    {\n      flags ^= SEARCH_SUBSCHEMA;\n      kv.parent = (KeyValue *)keyskip;\n      keyskip = 0;\n      schema = kv.parent->id;\n      dp = (unsigned char *)kv.parent->str;\n    }\n  else\n    {\n      schema = 0;\n      dp = solvid2data(data, solvid, &schema);\n      if (!dp)\n\treturn;\n      kv.parent = 0;\n    }\n  s = solvid > 0 ? data->repo->pool->solvables + solvid : 0;\n  keyp = data->schemadata + data->schemata[schema];\n  if (keyname)\n    {\n      /* search for a specific key */\n      for (kp = keyp; *kp; kp++)\n\tif (data->keys[*kp].name == keyname)\n\t  break;\n      if (!*kp)\n\treturn;\n      dp = forward_to_key(data, *kp, keyp, dp);\n      if (!dp)\n\treturn;\n      keyp = kp;\n      onekey = 1;\n    }\n  while ((keyid = *keyp++) != 0)\n    {\n      stop = 0;\n      key = data->keys + keyid;\n      ddp = get_data(data, key, &dp, *keyp && !onekey ? 1 : 0);\n\n      if (keyskip && (key->name >= keyskip[0] || keyskip[3 + key->name] != keyskip[1] + data->repodataid))\n\t{\n\t  if (onekey)\n\t    return;\n\t  continue;\n\t}\n      if (key->type == REPOKEY_TYPE_DELETED && !(flags & SEARCH_KEEP_TYPE_DELETED))\n\t{\n\t  if (onekey)\n\t    return;\n\t  continue;\n\t}\n      if (key->type == REPOKEY_TYPE_FLEXARRAY || key->type == REPOKEY_TYPE_FIXARRAY)\n\t{\n\t  kv.entry = -1;\n\t  ddp = data_read_id(ddp, (Id *)&kv.num);\n\t  kv.str = (const char *)ddp;\n\t  stop = repodata_search_array(data, solvid, 0, flags, key, &kv, callback, cbdata);\n\t  if (onekey || stop > SEARCH_NEXT_KEY)\n\t    return;\n\t  continue;\n\t}\n      kv.entry = 0;\n      do\n\t{\n\t  ddp = data_fetch(ddp, &kv, key);\n\t  if (!ddp)\n\t    break;\n\t  stop = callback(cbdata, s, data, key, &kv);\n\t  kv.entry++;\n\t}\n      while (!kv.eof && !stop);\n      if (onekey || stop > SEARCH_NEXT_KEY)\n\treturn;\n    }\n}\n\nvoid\nrepodata_search(Repodata *data, Id solvid, Id keyname, int flags, int (*callback)(void *cbdata, Solvable *s, Repodata *data, Repokey *key, KeyValue *kv), void *cbdata)\n{\n  repodata_search_keyskip(data, solvid, keyname, flags, 0, callback, cbdata);\n}\n\nvoid\nrepodata_setpos_kv(Repodata *data, KeyValue *kv)\n{\n  Pool *pool = data->repo->pool;\n  if (!kv)\n    pool_clear_pos(pool);\n  else\n    {\n      pool->pos.repo = data->repo;\n      pool->pos.repodataid = data - data->repo->repodata;\n      pool->pos.dp = (unsigned char *)kv->str - data->incoredata;\n      pool->pos.schema = kv->id;\n    }\n}\n\n/************************************************************************\n * data iterator functions\n */\n\nstatic inline Id *\nsolvabledata_fetch(Solvable *s, KeyValue *kv, Id keyname)\n{\n  kv->id = keyname;\n  switch (keyname)\n    {\n    case SOLVABLE_NAME:\n      kv->eof = 1;\n      return &s->name;\n    case SOLVABLE_ARCH:\n      kv->eof = 1;\n      return &s->arch;\n    case SOLVABLE_EVR:\n      kv->eof = 1;\n      return &s->evr;\n    case SOLVABLE_VENDOR:\n      kv->eof = 1;\n      return &s->vendor;\n    case SOLVABLE_PROVIDES:\n      kv->eof = 0;\n      return s->provides ? s->repo->idarraydata + s->provides : 0;\n    case SOLVABLE_OBSOLETES:\n      kv->eof = 0;\n      return s->obsoletes ? s->repo->idarraydata + s->obsoletes : 0;\n    case SOLVABLE_CONFLICTS:\n      kv->eof = 0;\n      return s->conflicts ? s->repo->idarraydata + s->conflicts : 0;\n    case SOLVABLE_REQUIRES:\n      kv->eof = 0;\n      return s->requires ? s->repo->idarraydata + s->requires : 0;\n    case SOLVABLE_RECOMMENDS:\n      kv->eof = 0;\n      return s->recommends ? s->repo->idarraydata + s->recommends : 0;\n    case SOLVABLE_SUPPLEMENTS:\n      kv->eof = 0;\n      return s->supplements ? s->repo->idarraydata + s->supplements : 0;\n    case SOLVABLE_SUGGESTS:\n      kv->eof = 0;\n      return s->suggests ? s->repo->idarraydata + s->suggests : 0;\n    case SOLVABLE_ENHANCES:\n      kv->eof = 0;\n      return s->enhances ? s->repo->idarraydata + s->enhances : 0;\n    case RPM_RPMDBID:\n      kv->eof = 1;\n      return s->repo->rpmdbid ? s->repo->rpmdbid + (s - s->repo->pool->solvables - s->repo->start) : 0;\n    default:\n      return 0;\n    }\n}\n\nint\ndatamatcher_init(Datamatcher *ma, const char *match, int flags)\n{\n  match = match ? solv_strdup(match) : 0;\n  ma->match = match;\n  ma->flags = flags;\n  ma->error = 0;\n  ma->matchdata = 0;\n  if ((flags & SEARCH_STRINGMASK) == SEARCH_REGEX)\n    {\n      ma->matchdata = solv_calloc(1, sizeof(regex_t));\n      ma->error = regcomp((regex_t *)ma->matchdata, match, REG_EXTENDED | REG_NOSUB | REG_NEWLINE | ((flags & SEARCH_NOCASE) ? REG_ICASE : 0));\n      if (ma->error)\n\t{\n\t  solv_free(ma->matchdata);\n\t  ma->flags = (flags & ~SEARCH_STRINGMASK) | SEARCH_ERROR;\n\t}\n    }\n  if ((flags & SEARCH_FILES) != 0 && match)\n    {\n      /* prepare basename check */\n      if ((flags & SEARCH_STRINGMASK) == SEARCH_STRING || (flags & SEARCH_STRINGMASK) == SEARCH_STRINGEND)\n\t{\n\t  const char *p = strrchr(match, '/');\n\t  ma->matchdata = (void *)(p ? p + 1 : match);\n\t}\n      else if ((flags & SEARCH_STRINGMASK) == SEARCH_GLOB)\n\t{\n\t  const char *p;\n\t  for (p = match + strlen(match) - 1; p >= match; p--)\n\t    if (*p == '[' || *p == ']' || *p == '*' || *p == '?' || *p == '/')\n\t      break;\n\t  ma->matchdata = (void *)(p + 1);\n\t}\n    }\n  return ma->error;\n}\n\nvoid\ndatamatcher_free(Datamatcher *ma)\n{\n  if (ma->match)\n    ma->match = solv_free((char *)ma->match);\n  if ((ma->flags & SEARCH_STRINGMASK) == SEARCH_REGEX && ma->matchdata)\n    {\n      regfree(ma->matchdata);\n      solv_free(ma->matchdata);\n    }\n  ma->matchdata = 0;\n}\n\nint\ndatamatcher_match(Datamatcher *ma, const char *str)\n{\n  int l;\n  switch ((ma->flags & SEARCH_STRINGMASK))\n    {\n    case SEARCH_SUBSTRING:\n      if (ma->flags & SEARCH_NOCASE)\n\treturn strcasestr(str, ma->match) != 0;\n      else\n\treturn strstr(str, ma->match) != 0;\n    case SEARCH_STRING:\n      if (ma->flags & SEARCH_NOCASE)\n\treturn !strcasecmp(ma->match, str);\n      else\n\treturn !strcmp(ma->match, str);\n    case SEARCH_STRINGSTART:\n      if (ma->flags & SEARCH_NOCASE)\n        return !strncasecmp(ma->match, str, strlen(ma->match));\n      else\n        return !strncmp(ma->match, str, strlen(ma->match));\n    case SEARCH_STRINGEND:\n      l = strlen(str) - strlen(ma->match);\n      if (l < 0)\n\treturn 0;\n      if (ma->flags & SEARCH_NOCASE)\n\treturn !strcasecmp(ma->match, str + l);\n      else\n\treturn !strcmp(ma->match, str + l);\n    case SEARCH_GLOB:\n      return !fnmatch(ma->match, str, (ma->flags & SEARCH_NOCASE) ? FNM_CASEFOLD : 0);\n    case SEARCH_REGEX:\n      return !regexec((const regex_t *)ma->matchdata, str, 0, NULL, 0);\n    default:\n      return 0;\n    }\n}\n\n/* check if the matcher can match the provides basename */\n\nint\ndatamatcher_checkbasename(Datamatcher *ma, const char *basename)\n{\n  int l;\n  const char *match = ma->matchdata;\n  if (!match)\n    return 1;\n  switch (ma->flags & SEARCH_STRINGMASK)\n    {\n    case SEARCH_STRING:\n      break;\n    case SEARCH_STRINGEND:\n      if (match != ma->match)\n\tbreak;\t\t/* had slash, do exact match on basename */\n      /* FALLTHROUGH */\n    case SEARCH_GLOB:\n      /* check if the basename ends with match */\n      l = strlen(basename) - strlen(match);\n      if (l < 0)\n\treturn 0;\n      basename += l;\n      break;\n    default:\n      return 1;\t/* maybe matches */\n    }\n  if ((ma->flags & SEARCH_NOCASE) != 0)\n    return !strcasecmp(match, basename);\n  else\n    return !strcmp(match, basename);\n}\n\nenum {\n  di_bye,\n\n  di_enterrepo,\n  di_entersolvable,\n  di_enterrepodata,\n  di_enterschema,\n  di_enterkey,\n\n  di_nextattr,\n  di_nextkey,\n  di_nextrepodata,\n  di_nextsolvable,\n  di_nextrepo,\n\n  di_enterarray,\n  di_nextarrayelement,\n\n  di_entersub,\n  di_leavesub,\n\n  di_nextsolvablekey,\n  di_entersolvablekey,\n  di_nextsolvableattr\n};\n\n/* see dataiterator.h for documentation */\nint\ndataiterator_init(Dataiterator *di, Pool *pool, Repo *repo, Id p, Id keyname, const char *match, int flags)\n{\n  memset(di, 0, sizeof(*di));\n  di->pool = pool;\n  di->flags = flags & ~SEARCH_THISSOLVID;\n  if (!pool || (repo && repo->pool != pool))\n    {\n      di->state = di_bye;\n      return -1;\n    }\n  if (match)\n    {\n      int error;\n      if ((error = datamatcher_init(&di->matcher, match, flags)) != 0)\n\t{\n\t  di->state = di_bye;\n\t  return error;\n\t}\n    }\n  di->keyname = keyname;\n  di->keynames[0] = keyname;\n  dataiterator_set_search(di, repo, p);\n  return 0;\n}\n\nvoid\ndataiterator_init_clone(Dataiterator *di, Dataiterator *from)\n{\n  *di = *from;\n  if (di->dupstr)\n    {\n      if (di->dupstr == di->kv.str)\n        di->dupstr = solv_memdup(di->dupstr, di->dupstrn);\n      else\n\t{\n\t  di->dupstr = 0;\n\t  di->dupstrn = 0;\n\t}\n    }\n  memset(&di->matcher, 0, sizeof(di->matcher));\n  if (from->matcher.match)\n    datamatcher_init(&di->matcher, from->matcher.match, from->matcher.flags);\n  if (di->nparents)\n    {\n      /* fix pointers */\n      int i;\n      for (i = 1; i < di->nparents; i++)\n\tdi->parents[i].kv.parent = &di->parents[i - 1].kv;\n      di->kv.parent = &di->parents[di->nparents - 1].kv;\n    }\n  if (di->oldkeyskip)\n    di->oldkeyskip = solv_memdup2(di->oldkeyskip, 3 + di->oldkeyskip[0], sizeof(Id));\n  if (di->keyskip)\n    di->keyskip = di->oldkeyskip;\n}\n\nint\ndataiterator_set_match(Dataiterator *di, const char *match, int flags)\n{\n  di->flags = (flags & ~SEARCH_THISSOLVID) | (di->flags & SEARCH_THISSOLVID);\n  datamatcher_free(&di->matcher);\n  memset(&di->matcher, 0, sizeof(di->matcher));\n  if (match)\n    {\n      int error;\n      if ((error = datamatcher_init(&di->matcher, match, flags)) != 0)\n\t{\n\t  di->state = di_bye;\n\t  return error;\n\t}\n    }\n  return 0;\n}\n\nvoid\ndataiterator_set_search(Dataiterator *di, Repo *repo, Id p)\n{\n  di->repo = repo;\n  di->repoid = 0;\n  di->flags &= ~SEARCH_THISSOLVID;\n  di->nparents = 0;\n  di->rootlevel = 0;\n  di->repodataid = 1;\n  if (!di->pool->urepos)\n    {\n      di->state = di_bye;\n      return;\n    }\n  if (!repo)\n    {\n      di->repoid = 1;\n      di->repo = di->pool->repos[di->repoid];\n    }\n  di->state = di_enterrepo;\n  if (p)\n    dataiterator_jump_to_solvid(di, p);\n}\n\nvoid\ndataiterator_set_keyname(Dataiterator *di, Id keyname)\n{\n  di->nkeynames = 0;\n  di->keyname = keyname;\n  di->keynames[0] = keyname;\n}\n\nvoid\ndataiterator_prepend_keyname(Dataiterator *di, Id keyname)\n{\n  int i;\n\n  if (di->nkeynames >= sizeof(di->keynames)/sizeof(*di->keynames) - 2)\n    {\n      di->state = di_bye;\t/* sorry */\n      return;\n    }\n  for (i = di->nkeynames + 1; i > 0; i--)\n    di->keynames[i] = di->keynames[i - 1];\n  di->keynames[0] = di->keyname = keyname;\n  di->nkeynames++;\n}\n\nvoid\ndataiterator_free(Dataiterator *di)\n{\n  if (di->matcher.match)\n    datamatcher_free(&di->matcher);\n  if (di->dupstr)\n    solv_free(di->dupstr);\n  if (di->oldkeyskip)\n    solv_free(di->oldkeyskip);\n}\n\nstatic unsigned char *\ndataiterator_find_keyname(Dataiterator *di, Id keyname)\n{\n  Id *keyp;\n  Repokey *keys = di->data->keys, *key;\n  unsigned char *dp;\n\n  for (keyp = di->keyp; *keyp; keyp++)\n    if (keys[*keyp].name == keyname)\n      break;\n  if (!*keyp)\n    return 0;\n  key = keys + *keyp;\n  if (key->type == REPOKEY_TYPE_DELETED)\n    return 0;\n  if (key->storage != KEY_STORAGE_INCORE && key->storage != KEY_STORAGE_VERTICAL_OFFSET)\n    return 0;\t\t/* get_data will not work, no need to forward */\n  dp = forward_to_key(di->data, *keyp, di->keyp, di->dp);\n  if (!dp)\n    return 0;\n  di->keyp = keyp;\n  return dp;\n}\n\nint\ndataiterator_step(Dataiterator *di)\n{\n  Id schema;\n\n  if (di->state == di_nextattr && di->key->storage == KEY_STORAGE_VERTICAL_OFFSET && di->vert_ddp && di->vert_storestate != di->data->storestate)\n    {\n      unsigned int ddpoff = di->ddp - di->vert_ddp;\n      di->vert_off += ddpoff;\n      di->vert_len -= ddpoff;\n      di->ddp = di->vert_ddp = get_vertical_data(di->data, di->key, di->vert_off, di->vert_len);\n      di->vert_storestate = di->data->storestate;\n      if (!di->ddp)\n\tdi->state = di_nextkey;\n    }\n  for (;;)\n    {\n      switch (di->state)\n\t{\n\tcase di_enterrepo: di_enterrepo:\n\t  if (!di->repo || (di->repo->disabled && !(di->flags & SEARCH_DISABLED_REPOS)))\n\t    goto di_nextrepo;\n\t  if (!(di->flags & SEARCH_THISSOLVID))\n\t    {\n\t      di->solvid = di->repo->start - 1;\t/* reset solvid iterator */\n\t      goto di_nextsolvable;\n\t    }\n\t  /* FALLTHROUGH */\n\n\tcase di_entersolvable: di_entersolvable:\n\t  if (!di->repodataid)\n\t    goto di_enterrepodata;\t/* POS case, repodata is set */\n\t  if (di->solvid > 0 && !(di->flags & SEARCH_NO_STORAGE_SOLVABLE) && (!di->keyname || (di->keyname >= SOLVABLE_NAME && di->keyname <= RPM_RPMDBID)) && di->nparents - di->rootlevel == di->nkeynames)\n\t    {\n\t      extern Repokey repo_solvablekeys[RPM_RPMDBID - SOLVABLE_NAME + 1];\n\t      di->key = repo_solvablekeys + (di->keyname ? di->keyname - SOLVABLE_NAME : 0);\n\t      di->data = 0;\n\t      goto di_entersolvablekey;\n\t    }\n\n\t  if (di->keyname)\n\t    {\n\t      di->data = di->keyname == SOLVABLE_FILELIST ? repo_lookup_filelist_repodata(di->repo, di->solvid, &di->matcher) : repo_lookup_repodata_opt(di->repo, di->solvid, di->keyname);\n\t      if (!di->data)\n\t\tgoto di_nextsolvable;\n\t      di->repodataid = di->data - di->repo->repodata;\n\t      di->keyskip = 0;\n\t      goto di_enterrepodata;\n\t    }\n\tdi_leavesolvablekey:\n\t  di->repodataid = 1;\t/* reset repodata iterator */\n\t  di->keyskip = repo_create_keyskip(di->repo, di->solvid, &di->oldkeyskip);\n\t  /* FALLTHROUGH */\n\n\tcase di_enterrepodata: di_enterrepodata:\n\t  if (di->repodataid)\n\t    {\n\t      if (di->repodataid >= di->repo->nrepodata)\n\t\tgoto di_nextsolvable;\n\t      di->data = di->repo->repodata + di->repodataid;\n\t    }\n\t  if (!maybe_load_repodata(di->data, di->keyname))\n\t    goto di_nextrepodata;\n\t  di->dp = solvid2data(di->data, di->solvid, &schema);\n\t  if (!di->dp)\n\t    goto di_nextrepodata;\n\t  if (di->solvid == SOLVID_POS)\n\t    di->solvid = di->pool->pos.solvid;\n\t  /* reset key iterator */\n\t  di->keyp = di->data->schemadata + di->data->schemata[schema];\n\t  /* FALLTHROUGH */\n\n\tcase di_enterschema: di_enterschema:\n\t  if (di->keyname)\n\t    di->dp = dataiterator_find_keyname(di, di->keyname);\n\t  if (!di->dp || !*di->keyp)\n\t    {\n\t      if (di->kv.parent)\n\t\tgoto di_leavesub;\n\t      goto di_nextrepodata;\n\t    }\n\t  /* FALLTHROUGH */\n\n\tcase di_enterkey: di_enterkey:\n\t  di->kv.entry = -1;\n\t  di->key = di->data->keys + *di->keyp;\n\t  if (!di->dp)\n\t    goto di_nextkey;\n\t  /* this is get_data() modified to store vert_ data */\n\t  if (di->key->storage == KEY_STORAGE_VERTICAL_OFFSET)\n\t    {\n\t      Id off, len;\n\t      di->dp = data_read_id(di->dp, &off);\n\t      di->dp = data_read_id(di->dp, &len);\n\t      di->vert_ddp = di->ddp = get_vertical_data(di->data, di->key, off, len);\n\t      di->vert_off = off;\n\t      di->vert_len = len;\n\t      di->vert_storestate = di->data->storestate;\n\t    }\n\t  else if (di->key->storage == KEY_STORAGE_INCORE)\n\t    {\n\t      di->ddp = di->dp;\t\t/* start of data */\n\t      if (di->keyp[1] && (!di->keyname || (di->flags & SEARCH_SUB) != 0))\n\t\tdi->dp = data_skip_key(di->data, di->dp, di->key);\t/* advance to next key */\n\t    }\n\t  else\n\t    di->ddp = 0;\n\t  if (!di->ddp)\n\t    goto di_nextkey;\n\t  if (di->keyskip && (di->key->name >= di->keyskip[0] || di->keyskip[3 + di->key->name] != di->keyskip[1] + di->data->repodataid))\n\t    goto di_nextkey;\n          if (di->key->type == REPOKEY_TYPE_DELETED && !(di->flags & SEARCH_KEEP_TYPE_DELETED))\n\t    goto di_nextkey;\n\t  if (di->key->type == REPOKEY_TYPE_FIXARRAY || di->key->type == REPOKEY_TYPE_FLEXARRAY)\n\t    goto di_enterarray;\n\t  if (di->nkeynames && di->nparents - di->rootlevel < di->nkeynames)\n\t    goto di_nextkey;\n\t  /* FALLTHROUGH */\n\n\tcase di_nextattr:\n          di->kv.entry++;\n\t  di->ddp = data_fetch(di->ddp, &di->kv, di->key);\n\t  di->state = di->kv.eof ? di_nextkey : di_nextattr;\n\t  break;\n\n\tcase di_nextkey: di_nextkey:\n\t  if (!di->keyname && *++di->keyp)\n\t    goto di_enterkey;\n\t  if (di->kv.parent)\n\t    goto di_leavesub;\n\t  /* FALLTHROUGH */\n\n\tcase di_nextrepodata: di_nextrepodata:\n\t  if (!di->keyname && di->repodataid && ++di->repodataid < di->repo->nrepodata)\n\t      goto di_enterrepodata;\n\t  /* FALLTHROUGH */\n\n\tcase di_nextsolvable: di_nextsolvable:\n\t  if (!(di->flags & SEARCH_THISSOLVID))\n\t    {\n\t      if (di->solvid < 0)\n\t\tdi->solvid = di->repo->start;\n\t      else\n\t        di->solvid++;\n\t      for (; di->solvid < di->repo->end; di->solvid++)\n\t\t{\n\t\t  if (di->pool->solvables[di->solvid].repo == di->repo)\n\t\t    goto di_entersolvable;\n\t\t}\n\t    }\n\t  /* FALLTHROUGH */\n\n\tcase di_nextrepo: di_nextrepo:\n\t  if (di->repoid > 0)\n\t    {\n\t      di->repoid++;\n\t      di->repodataid = 1;\n\t      if (di->repoid < di->pool->nrepos)\n\t\t{\n\t\t  di->repo = di->pool->repos[di->repoid];\n\t          goto di_enterrepo;\n\t\t}\n\t    }\n\t/* FALLTHROUGH */\n\n\tcase di_bye: di_bye:\n\t  di->state = di_bye;\n\t  return 0;\n\n\tcase di_enterarray: di_enterarray:\n\t  if (di->key->name == REPOSITORY_SOLVABLES)\n\t    goto di_nextkey;\n\t  di->ddp = data_read_id(di->ddp, (Id *)&di->kv.num);\n\t  di->kv.eof = 0;\n\t  di->kv.entry = -1;\n\t  /* FALLTHROUGH */\n\n\tcase di_nextarrayelement: di_nextarrayelement:\n\t  di->kv.entry++;\n\t  if (di->kv.entry)\n\t    di->ddp = data_skip_schema(di->data, di->ddp, di->kv.id);\n\t  if (di->kv.entry == di->kv.num)\n\t    {\n\t      if (di->nkeynames && di->nparents - di->rootlevel < di->nkeynames)\n\t\tgoto di_nextkey;\n\t      if (!(di->flags & SEARCH_ARRAYSENTINEL))\n\t\tgoto di_nextkey;\n\t      di->kv.str = (char *)di->ddp;\n\t      di->kv.eof = 2;\n\t      di->state = di_nextkey;\n\t      break;\n\t    }\n\t  if (di->kv.entry == di->kv.num - 1)\n\t    di->kv.eof = 1;\n\t  if (di->key->type == REPOKEY_TYPE_FLEXARRAY || !di->kv.entry)\n\t    di->ddp = data_read_id(di->ddp, &di->kv.id);\n\t  di->kv.str = (char *)di->ddp;\n\t  if (di->nkeynames && di->nparents - di->rootlevel < di->nkeynames)\n\t    goto di_entersub;\n\t  if ((di->flags & SEARCH_SUB) != 0)\n\t    di->state = di_entersub;\n\t  else\n\t    di->state = di_nextarrayelement;\n\t  break;\n\n\tcase di_entersub: di_entersub:\n\t  if (di->nparents == sizeof(di->parents)/sizeof(*di->parents) - 1)\n\t    goto di_nextarrayelement;\t/* sorry, full */\n\t  di->parents[di->nparents].kv = di->kv;\n\t  di->parents[di->nparents].dp = di->dp;\n\t  di->parents[di->nparents].keyp = di->keyp;\n\t  di->dp = (unsigned char *)di->kv.str;\n\t  di->keyp = di->data->schemadata + di->data->schemata[di->kv.id];\n\t  memset(&di->kv, 0, sizeof(di->kv));\n\t  di->kv.parent = &di->parents[di->nparents].kv;\n\t  di->nparents++;\n\t  di->keyname = di->keynames[di->nparents - di->rootlevel];\n\t  goto di_enterschema;\n\n\tcase di_leavesub: di_leavesub:\n\t  if (di->nparents - 1 < di->rootlevel)\n\t    goto di_bye;\n\t  di->nparents--;\n\t  di->dp = di->parents[di->nparents].dp;\n\t  di->kv = di->parents[di->nparents].kv;\n\t  di->keyp = di->parents[di->nparents].keyp;\n\t  di->key = di->data->keys + *di->keyp;\n\t  di->ddp = (unsigned char *)di->kv.str;\n\t  di->keyname = di->keynames[di->nparents - di->rootlevel];\n\t  goto di_nextarrayelement;\n\n        /* special solvable attr handling follows */\n\n\tcase di_nextsolvablekey: di_nextsolvablekey:\n\t  if (di->keyname)\n\t    goto di_nextsolvable;\n\t  if (di->key->name == RPM_RPMDBID)\t/* reached end of list? */\n\t    goto di_leavesolvablekey;\n\t  di->key++;\n\t  /* FALLTHROUGH */\n\n\tcase di_entersolvablekey: di_entersolvablekey:\n\t  di->idp = solvabledata_fetch(di->pool->solvables + di->solvid, &di->kv, di->key->name);\n\t  if (!di->idp || !*di->idp)\n\t    goto di_nextsolvablekey;\n\t  if (di->kv.eof)\n\t    {\n\t      /* not an array */\n\t      di->kv.id = *di->idp;\n\t      di->kv.num = *di->idp;\t/* for rpmdbid */\n\t      di->kv.num2 = 0;\t\t/* for rpmdbid */\n\t      di->kv.entry = 0;\n\t      di->state = di_nextsolvablekey;\n\t      break;\n\t    }\n\t  di->kv.entry = -1;\n\t  /* FALLTHROUGH */\n\n\tcase di_nextsolvableattr:\n\t  di->state = di_nextsolvableattr;\n\t  di->kv.id = *di->idp++;\n\t  di->kv.entry++;\n\t  if (!*di->idp)\n\t    {\n\t      di->kv.eof = 1;\n\t      di->state = di_nextsolvablekey;\n\t    }\n\t  break;\n\n\t}\n\n      /* we have a potential match */\n      if (di->matcher.match)\n\t{\n\t  const char *str;\n\t  /* simple pre-check so that we don't need to stringify */\n\t  if (di->keyname == SOLVABLE_FILELIST && di->key->type == REPOKEY_TYPE_DIRSTRARRAY && (di->matcher.flags & SEARCH_FILES) != 0)\n\t    if (!datamatcher_checkbasename(&di->matcher, di->kv.str))\n\t      continue;\n\t  /* now stringify so that we can do the matching */\n\t  if (!(str = repodata_stringify(di->pool, di->data, di->key, &di->kv, di->flags)))\n\t    {\n\t      if (di->keyname && (di->key->type == REPOKEY_TYPE_FIXARRAY || di->key->type == REPOKEY_TYPE_FLEXARRAY))\n\t\treturn 1;\n\t      continue;\n\t    }\n\t  if (!datamatcher_match(&di->matcher, str))\n\t    continue;\n\t}\n      else\n\t{\n\t  /* stringify filelist if requested */\n\t  if (di->keyname == SOLVABLE_FILELIST && di->key->type == REPOKEY_TYPE_DIRSTRARRAY && (di->flags & SEARCH_FILES) != 0)\n\t    repodata_stringify(di->pool, di->data, di->key, &di->kv, di->flags);\n\t}\n      /* found something! */\n      return 1;\n    }\n}\n\nvoid\ndataiterator_entersub(Dataiterator *di)\n{\n  if (di->state == di_nextarrayelement)\n    di->state = di_entersub;\n}\n\nvoid\ndataiterator_setpos(Dataiterator *di)\n{\n  if (di->kv.eof == 2)\n    {\n      pool_clear_pos(di->pool);\n      return;\n    }\n  di->pool->pos.solvid = di->solvid;\n  di->pool->pos.repo = di->repo;\n  di->pool->pos.repodataid = di->data - di->repo->repodata;\n  di->pool->pos.schema = di->kv.id;\n  di->pool->pos.dp = (unsigned char *)di->kv.str - di->data->incoredata;\n}\n\nvoid\ndataiterator_setpos_parent(Dataiterator *di)\n{\n  if (!di->kv.parent || di->kv.parent->eof == 2)\n    {\n      pool_clear_pos(di->pool);\n      return;\n    }\n  di->pool->pos.solvid = di->solvid;\n  di->pool->pos.repo = di->repo;\n  di->pool->pos.repodataid = di->data - di->repo->repodata;\n  di->pool->pos.schema = di->kv.parent->id;\n  di->pool->pos.dp = (unsigned char *)di->kv.parent->str - di->data->incoredata;\n}\n\n/* clones just the position, not the search keys/matcher */\nvoid\ndataiterator_clonepos(Dataiterator *di, Dataiterator *from)\n{\n  di->state = from->state;\n  di->flags &= ~SEARCH_THISSOLVID;\n  di->flags |= (from->flags & SEARCH_THISSOLVID);\n  di->repo = from->repo;\n  di->data = from->data;\n  di->dp = from->dp;\n  di->ddp = from->ddp;\n  di->idp = from->idp;\n  di->keyp = from->keyp;\n  di->key = from->key;\n  di->kv = from->kv;\n  di->repodataid = from->repodataid;\n  di->solvid = from->solvid;\n  di->repoid = from->repoid;\n  di->rootlevel = from->rootlevel;\n  memcpy(di->parents, from->parents, sizeof(from->parents));\n  di->nparents = from->nparents;\n  if (di->nparents)\n    {\n      int i;\n      for (i = 1; i < di->nparents; i++)\n\tdi->parents[i].kv.parent = &di->parents[i - 1].kv;\n      di->kv.parent = &di->parents[di->nparents - 1].kv;\n    }\n  di->dupstr = 0;\n  di->dupstrn = 0;\n  if (from->dupstr && from->dupstr == from->kv.str)\n    {\n      di->dupstrn = from->dupstrn;\n      di->dupstr = solv_memdup(from->dupstr, from->dupstrn);\n    }\n}\n\nvoid\ndataiterator_seek(Dataiterator *di, int whence)\n{\n  if ((whence & DI_SEEK_STAY) != 0)\n    di->rootlevel = di->nparents;\n  switch (whence & ~DI_SEEK_STAY)\n    {\n    case DI_SEEK_CHILD:\n      if (di->state != di_nextarrayelement)\n\tbreak;\n      if ((whence & DI_SEEK_STAY) != 0)\n\tdi->rootlevel = di->nparents + 1;\t/* XXX: dangerous! */\n      di->state = di_entersub;\n      break;\n    case DI_SEEK_PARENT:\n      if (!di->nparents)\n\t{\n\t  di->state = di_bye;\n\t  break;\n\t}\n      di->nparents--;\n      if (di->rootlevel > di->nparents)\n\tdi->rootlevel = di->nparents;\n      di->dp = di->parents[di->nparents].dp;\n      di->kv = di->parents[di->nparents].kv;\n      di->keyp = di->parents[di->nparents].keyp;\n      di->key = di->data->keys + *di->keyp;\n      di->ddp = (unsigned char *)di->kv.str;\n      di->keyname = di->keynames[di->nparents - di->rootlevel];\n      di->state = di_nextarrayelement;\n      break;\n    case DI_SEEK_REWIND:\n      if (!di->nparents)\n\t{\n\t  di->state = di_bye;\n\t  break;\n\t}\n      di->dp = (unsigned char *)di->kv.parent->str;\n      di->keyp = di->data->schemadata + di->data->schemata[di->kv.parent->id];\n      di->state = di_enterschema;\n      break;\n    default:\n      break;\n    }\n}\n\nvoid\ndataiterator_skip_attribute(Dataiterator *di)\n{\n  if (di->state == di_nextsolvableattr)\n    di->state = di_nextsolvablekey;\n  else\n    di->state = di_nextkey;\n}\n\nvoid\ndataiterator_skip_solvable(Dataiterator *di)\n{\n  di->nparents = 0;\n  di->kv.parent = 0;\n  di->rootlevel = 0;\n  di->keyname = di->keynames[0];\n  di->state = di_nextsolvable;\n}\n\nvoid\ndataiterator_skip_repo(Dataiterator *di)\n{\n  di->nparents = 0;\n  di->kv.parent = 0;\n  di->rootlevel = 0;\n  di->keyname = di->keynames[0];\n  di->state = di_nextrepo;\n}\n\nvoid\ndataiterator_jump_to_solvid(Dataiterator *di, Id solvid)\n{\n  di->nparents = 0;\n  di->kv.parent = 0;\n  di->rootlevel = 0;\n  di->keyname = di->keynames[0];\n  if (solvid == SOLVID_POS)\n    {\n      di->repo = di->pool->pos.repo;\n      if (!di->repo)\n\t{\n\t  di->state = di_bye;\n\t  return;\n\t}\n      di->repoid = 0;\n      if (!di->pool->pos.repodataid && di->pool->pos.solvid == SOLVID_META) {\n\tsolvid = SOLVID_META;\t\t/* META pos hack */\n      } else {\n        di->data = di->repo->repodata + di->pool->pos.repodataid;\n        di->repodataid = 0;\n      }\n    }\n  else if (solvid > 0)\n    {\n      di->repo = di->pool->solvables[solvid].repo;\n      di->repoid = 0;\n    }\n  if (di->repoid > 0)\n    {\n      if (!di->pool->urepos)\n\t{\n\t  di->state = di_bye;\n\t  return;\n\t}\n      di->repoid = 1;\n      di->repo = di->pool->repos[di->repoid];\n    }\n  if (solvid != SOLVID_POS)\n    di->repodataid = 1;\n  di->solvid = solvid;\n  if (solvid)\n    di->flags |= SEARCH_THISSOLVID;\n  di->state = di_enterrepo;\n}\n\nvoid\ndataiterator_jump_to_repo(Dataiterator *di, Repo *repo)\n{\n  di->nparents = 0;\n  di->kv.parent = 0;\n  di->rootlevel = 0;\n  di->repo = repo;\n  di->repoid = 0;\t/* 0 means stay at repo */\n  di->repodataid = 1;\n  di->solvid = 0;\n  di->flags &= ~SEARCH_THISSOLVID;\n  di->state = di_enterrepo;\n}\n\nint\ndataiterator_match(Dataiterator *di, Datamatcher *ma)\n{\n  const char *str;\n  if (!(str = repodata_stringify(di->pool, di->data, di->key, &di->kv, di->flags)))\n    return 0;\n  return ma ? datamatcher_match(ma, str) : 1;\n}\n\nvoid\ndataiterator_strdup(Dataiterator *di)\n{\n  int l = -1;\n\n  if (!di->kv.str || di->kv.str == di->dupstr)\n    return;\n  switch (di->key->type)\n    {\n    case_CHKSUM_TYPES:\n    case REPOKEY_TYPE_DIRSTRARRAY:\n      if (di->kv.num)\t/* was it stringified into tmp space? */\n        l = strlen(di->kv.str) + 1;\n      break;\n    default:\n      break;\n    }\n  if (l < 0 && di->key->storage == KEY_STORAGE_VERTICAL_OFFSET)\n    {\n      switch (di->key->type)\n\t{\n\tcase REPOKEY_TYPE_STR:\n\tcase REPOKEY_TYPE_DIRSTRARRAY:\n\t  l = strlen(di->kv.str) + 1;\n\t  break;\n\tcase_CHKSUM_TYPES:\n\t  l = solv_chksum_len(di->key->type);\n\t  break;\n\tcase REPOKEY_TYPE_BINARY:\n\t  l = di->kv.num;\n\t  break;\n\t}\n    }\n  if (l >= 0)\n    {\n      if (!di->dupstrn || di->dupstrn < l)\n\t{\n\t  di->dupstrn = l + 16;\n\t  di->dupstr = solv_realloc(di->dupstr, di->dupstrn);\n\t}\n      if (l)\n        memcpy(di->dupstr, di->kv.str, l);\n      di->kv.str = di->dupstr;\n    }\n}\n\n/************************************************************************\n * data modify functions\n */\n\n/* extend repodata so that it includes solvables p */\nvoid\nrepodata_extend(Repodata *data, Id p)\n{\n  if (data->start == data->end)\n    data->start = data->end = p;\n  if (p >= data->end)\n    {\n      int old = data->end - data->start;\n      int new = p - data->end + 1;\n      if (data->attrs)\n\t{\n\t  data->attrs = solv_extend(data->attrs, old, new, sizeof(Id *), REPODATA_BLOCK);\n\t  memset(data->attrs + old, 0, new * sizeof(Id *));\n\t}\n      data->incoreoffset = solv_extend(data->incoreoffset, old, new, sizeof(Id), REPODATA_BLOCK);\n      memset(data->incoreoffset + old, 0, new * sizeof(Id));\n      data->end = p + 1;\n    }\n  if (p < data->start)\n    {\n      int old = data->end - data->start;\n      int new = data->start - p;\n      if (data->attrs)\n\t{\n\t  data->attrs = solv_extend_resize(data->attrs, old + new, sizeof(Id *), REPODATA_BLOCK);\n\t  memmove(data->attrs + new, data->attrs, old * sizeof(Id *));\n\t  memset(data->attrs, 0, new * sizeof(Id *));\n\t}\n      data->incoreoffset = solv_extend_resize(data->incoreoffset, old + new, sizeof(Id), REPODATA_BLOCK);\n      memmove(data->incoreoffset + new, data->incoreoffset, old * sizeof(Id));\n      memset(data->incoreoffset, 0, new * sizeof(Id));\n      data->start = p;\n    }\n}\n\n/* shrink end of repodata */\nvoid\nrepodata_shrink(Repodata *data, int end)\n{\n  int i;\n\n  if (data->end <= end)\n    return;\n  if (data->start >= end)\n    {\n      if (data->attrs)\n\t{\n\t  for (i = 0; i < data->end - data->start; i++)\n\t    solv_free(data->attrs[i]);\n          data->attrs = solv_free(data->attrs);\n\t}\n      data->incoreoffset = solv_free(data->incoreoffset);\n      data->start = data->end = 0;\n      return;\n    }\n  if (data->attrs)\n    {\n      for (i = end; i < data->end; i++)\n\tsolv_free(data->attrs[i - data->start]);\n      data->attrs = solv_extend_resize(data->attrs, end - data->start, sizeof(Id *), REPODATA_BLOCK);\n    }\n  if (data->incoreoffset)\n    data->incoreoffset = solv_extend_resize(data->incoreoffset, end - data->start, sizeof(Id), REPODATA_BLOCK);\n  data->end = end;\n}\n\n/* extend repodata so that it includes solvables from start to start + num - 1 */\nvoid\nrepodata_extend_block(Repodata *data, Id start, Id num)\n{\n  if (!num)\n    return;\n  if (!data->incoreoffset)\n    {\n      /* this also means that data->attrs is NULL */\n      data->incoreoffset = solv_calloc_block(num, sizeof(Id), REPODATA_BLOCK);\n      data->start = start;\n      data->end = start + num;\n      return;\n    }\n  repodata_extend(data, start);\n  if (num > 1)\n    repodata_extend(data, start + num - 1);\n}\n\n/**********************************************************************/\n\n\n#define REPODATA_ATTRS_BLOCK 31\n#define REPODATA_ATTRDATA_BLOCK 1023\n#define REPODATA_ATTRIDDATA_BLOCK 63\n#define REPODATA_ATTRNUM64DATA_BLOCK 15\n\n\nId\nrepodata_new_handle(Repodata *data)\n{\n  if (!data->nxattrs)\n    {\n      data->xattrs = solv_calloc_block(1, sizeof(Id *), REPODATA_BLOCK);\n      data->nxattrs = 2;\t/* -1: SOLVID_META */\n    }\n  data->xattrs = solv_extend(data->xattrs, data->nxattrs, 1, sizeof(Id *), REPODATA_BLOCK);\n  data->xattrs[data->nxattrs] = 0;\n  return -(data->nxattrs++);\n}\n\nstatic inline Id **\nrepodata_get_attrp(Repodata *data, Id handle)\n{\n  if (handle < 0)\n    {\n      if (handle == SOLVID_META && !data->xattrs)\n\t{\n\t  data->xattrs = solv_calloc_block(1, sizeof(Id *), REPODATA_BLOCK);\n          data->nxattrs = 2;\n\t}\n      return data->xattrs - handle;\n    }\n  if (handle < data->start || handle >= data->end)\n    repodata_extend(data, handle);\n  if (!data->attrs)\n    data->attrs = solv_calloc_block(data->end - data->start, sizeof(Id *), REPODATA_BLOCK);\n  return data->attrs + (handle - data->start);\n}\n\nstatic void\nrepodata_insert_keyid(Repodata *data, Id handle, Id keyid, Id val, int overwrite)\n{\n  Id *pp;\n  Id *ap, **app;\n  int i;\n\n  app = repodata_get_attrp(data, handle);\n  ap = *app;\n  i = 0;\n  if (ap)\n    {\n      /* Determine equality based on the name only, allows us to change\n         type (when overwrite is set), and makes TYPE_CONSTANT work.  */\n      for (pp = ap; *pp; pp += 2)\n        if (data->keys[*pp].name == data->keys[keyid].name)\n          break;\n      if (*pp)\n        {\n\t  if (overwrite || data->keys[*pp].type == REPOKEY_TYPE_DELETED)\n\t    {\n\t      pp[0] = keyid;\n              pp[1] = val;\n\t    }\n          return;\n        }\n      i = pp - ap;\n    }\n  ap = solv_extend(ap, i, 3, sizeof(Id), REPODATA_ATTRS_BLOCK);\n  *app = ap;\n  pp = ap + i;\n  *pp++ = keyid;\n  *pp++ = val;\n  *pp = 0;\n}\n\n\nstatic void\nrepodata_set(Repodata *data, Id solvid, Repokey *key, Id val)\n{\n  Id keyid;\n\n  keyid = repodata_key2id(data, key, 1);\n  repodata_insert_keyid(data, solvid, keyid, val, 1);\n}\n\nvoid\nrepodata_set_id(Repodata *data, Id solvid, Id keyname, Id id)\n{\n  Repokey key;\n  key.name = keyname;\n  key.type = REPOKEY_TYPE_ID;\n  key.size = 0;\n  key.storage = KEY_STORAGE_INCORE;\n  repodata_set(data, solvid, &key, id);\n}\n\nvoid\nrepodata_set_num(Repodata *data, Id solvid, Id keyname, unsigned long long num)\n{\n  Repokey key;\n  key.name = keyname;\n  key.type = REPOKEY_TYPE_NUM;\n  key.size = 0;\n  key.storage = KEY_STORAGE_INCORE;\n  if (num >= 0x80000000)\n    {\n      data->attrnum64data = solv_extend(data->attrnum64data, data->attrnum64datalen, 1, sizeof(unsigned long long), REPODATA_ATTRNUM64DATA_BLOCK);\n      data->attrnum64data[data->attrnum64datalen] = num;\n      num = 0x80000000 | data->attrnum64datalen++;\n    }\n  repodata_set(data, solvid, &key, (Id)num);\n}\n\nvoid\nrepodata_set_poolstr(Repodata *data, Id solvid, Id keyname, const char *str)\n{\n  Repokey key;\n  Id id;\n  if (data->localpool)\n    id = stringpool_str2id(&data->spool, str, 1);\n  else\n    id = pool_str2id(data->repo->pool, str, 1);\n  key.name = keyname;\n  key.type = REPOKEY_TYPE_ID;\n  key.size = 0;\n  key.storage = KEY_STORAGE_INCORE;\n  repodata_set(data, solvid, &key, id);\n}\n\nvoid\nrepodata_set_constant(Repodata *data, Id solvid, Id keyname, unsigned int constant)\n{\n  Repokey key;\n  key.name = keyname;\n  key.type = REPOKEY_TYPE_CONSTANT;\n  key.size = constant;\n  key.storage = KEY_STORAGE_INCORE;\n  repodata_set(data, solvid, &key, 0);\n}\n\nvoid\nrepodata_set_constantid(Repodata *data, Id solvid, Id keyname, Id id)\n{\n  Repokey key;\n  key.name = keyname;\n  key.type = REPOKEY_TYPE_CONSTANTID;\n  key.size = id;\n  key.storage = KEY_STORAGE_INCORE;\n  repodata_set(data, solvid, &key, 0);\n}\n\nvoid\nrepodata_set_void(Repodata *data, Id solvid, Id keyname)\n{\n  Repokey key;\n  key.name = keyname;\n  key.type = REPOKEY_TYPE_VOID;\n  key.size = 0;\n  key.storage = KEY_STORAGE_INCORE;\n  repodata_set(data, solvid, &key, 0);\n}\n\nvoid\nrepodata_set_str(Repodata *data, Id solvid, Id keyname, const char *str)\n{\n  Repokey key;\n  int l;\n\n  l = strlen(str) + 1;\n  key.name = keyname;\n  key.type = REPOKEY_TYPE_STR;\n  key.size = 0;\n  key.storage = KEY_STORAGE_INCORE;\n  data->attrdata = solv_extend(data->attrdata, data->attrdatalen, l, 1, REPODATA_ATTRDATA_BLOCK);\n  memcpy(data->attrdata + data->attrdatalen, str, l);\n  repodata_set(data, solvid, &key, data->attrdatalen);\n  data->attrdatalen += l;\n}\n\nvoid\nrepodata_set_binary(Repodata *data, Id solvid, Id keyname, void *buf, int len)\n{\n  Repokey key;\n  unsigned char *dp;\n\n  if (len < 0)\n    return;\n  key.name = keyname;\n  key.type = REPOKEY_TYPE_BINARY;\n  key.size = 0;\n  key.storage = KEY_STORAGE_INCORE;\n  data->attrdata = solv_extend(data->attrdata, data->attrdatalen, len + 5, 1, REPODATA_ATTRDATA_BLOCK);\n  dp = data->attrdata + data->attrdatalen;\n  if (len >= (1 << 14))\n    {\n      if (len >= (1 << 28))\n        *dp++ = (len >> 28) | 128;\n      if (len >= (1 << 21))\n        *dp++ = (len >> 21) | 128;\n      *dp++ = (len >> 14) | 128;\n    }\n  if (len >= (1 << 7))\n    *dp++ = (len >> 7) | 128;\n  *dp++ = len & 127;\n  if (len)\n    memcpy(dp, buf, len);\n  repodata_set(data, solvid, &key, data->attrdatalen);\n  data->attrdatalen = dp + len - data->attrdata;\n}\n\n/* add an array element consisting of entrysize Ids to the repodata. modifies attriddata\n * so that the caller can append entrysize new elements plus the termination zero there */\nstatic void\nrepodata_add_array(Repodata *data, Id handle, Id keyname, Id keytype, int entrysize)\n{\n  int oldsize;\n  Id *ida, *pp, **ppp;\n\n  /* check if it is the same as last time, this speeds things up a lot */\n  if (handle == data->lasthandle && data->keys[data->lastkey].name == keyname && data->keys[data->lastkey].type == keytype && data->attriddatalen == data->lastdatalen)\n    {\n      /* great! just append the new data */\n      data->attriddata = solv_extend(data->attriddata, data->attriddatalen, entrysize, sizeof(Id), REPODATA_ATTRIDDATA_BLOCK);\n      data->attriddatalen--;\t/* overwrite terminating 0  */\n      data->lastdatalen += entrysize;\n      return;\n    }\n\n  ppp = repodata_get_attrp(data, handle);\n  pp = *ppp;\n  if (pp)\n    {\n      for (; *pp; pp += 2)\n        if (data->keys[*pp].name == keyname)\n          break;\n    }\n  if (!pp || !*pp || data->keys[*pp].type != keytype)\n    {\n      /* not found. allocate new key */\n      Repokey key;\n      Id keyid;\n      key.name = keyname;\n      key.type = keytype;\n      key.size = 0;\n      key.storage = KEY_STORAGE_INCORE;\n      data->attriddata = solv_extend(data->attriddata, data->attriddatalen, entrysize + 1, sizeof(Id), REPODATA_ATTRIDDATA_BLOCK);\n      keyid = repodata_key2id(data, &key, 1);\n      repodata_insert_keyid(data, handle, keyid, data->attriddatalen, 1);\n      data->lasthandle = handle;\n      data->lastkey = keyid;\n      data->lastdatalen = data->attriddatalen + entrysize + 1;\n      return;\n    }\n  oldsize = 0;\n  for (ida = data->attriddata + pp[1]; *ida; ida += entrysize)\n    oldsize += entrysize;\n  if (ida + 1 == data->attriddata + data->attriddatalen)\n    {\n      /* this was the last entry, just append it */\n      data->attriddata = solv_extend(data->attriddata, data->attriddatalen, entrysize, sizeof(Id), REPODATA_ATTRIDDATA_BLOCK);\n      data->attriddatalen--;\t/* overwrite terminating 0  */\n    }\n  else\n    {\n      /* too bad. move to back. */\n      data->attriddata = solv_extend(data->attriddata, data->attriddatalen,  oldsize + entrysize + 1, sizeof(Id), REPODATA_ATTRIDDATA_BLOCK);\n      memcpy(data->attriddata + data->attriddatalen, data->attriddata + pp[1], oldsize * sizeof(Id));\n      pp[1] = data->attriddatalen;\n      data->attriddatalen += oldsize;\n    }\n  data->lasthandle = handle;\n  data->lastkey = *pp;\n  data->lastdatalen = data->attriddatalen + entrysize + 1;\n}\n\nvoid\nrepodata_set_bin_checksum(Repodata *data, Id solvid, Id keyname, Id type,\n\t\t      const unsigned char *str)\n{\n  Repokey key;\n  int l;\n\n  if (!(l = solv_chksum_len(type)))\n    return;\n  key.name = keyname;\n  key.type = type;\n  key.size = 0;\n  key.storage = KEY_STORAGE_INCORE;\n  data->attrdata = solv_extend(data->attrdata, data->attrdatalen, l, 1, REPODATA_ATTRDATA_BLOCK);\n  memcpy(data->attrdata + data->attrdatalen, str, l);\n  repodata_set(data, solvid, &key, data->attrdatalen);\n  data->attrdatalen += l;\n}\n\nvoid\nrepodata_set_checksum(Repodata *data, Id solvid, Id keyname, Id type,\n\t\t      const char *str)\n{\n  unsigned char buf[64];\n  int l;\n\n  if (!(l = solv_chksum_len(type)))\n    return;\n  if (l > sizeof(buf) || solv_hex2bin(&str, buf, l) != l)\n    return;\n  repodata_set_bin_checksum(data, solvid, keyname, type, buf);\n}\n\nconst char *\nrepodata_chk2str(Repodata *data, Id type, const unsigned char *buf)\n{\n  int l;\n\n  if (!(l = solv_chksum_len(type)))\n    return \"\";\n  return pool_bin2hex(data->repo->pool, buf, l);\n}\n\n/* rpm filenames don't contain the epoch, so strip it */\nstatic inline const char *\nevrid2vrstr(Pool *pool, Id evrid)\n{\n  const char *p, *evr = pool_id2str(pool, evrid);\n  if (!evr)\n    return evr;\n  for (p = evr; *p >= '0' && *p <= '9'; p++)\n    ;\n  return p != evr && *p == ':' && p[1] ? p + 1 : evr;\n}\n\nstatic inline void\nrepodata_set_poolstrn(Repodata *data, Id solvid, Id keyname, const char *str, int l)\n{\n  Id id;\n  if (data->localpool)\n    id = stringpool_strn2id(&data->spool, str, l, 1);\n  else\n    id = pool_strn2id(data->repo->pool, str, l, 1);\n  repodata_set_id(data, solvid, keyname, id);\n}\n\nstatic inline void\nrepodata_set_strn(Repodata *data, Id solvid, Id keyname, const char *str, int l)\n{\n  if (!str[l])\n    repodata_set_str(data, solvid, keyname, str);\n  else\n    {\n      char *s = solv_strdup(str);\n      s[l] = 0;\n      repodata_set_str(data, solvid, keyname, s);\n      free(s);\n    }\n}\n\nvoid\nrepodata_set_location(Repodata *data, Id solvid, int medianr, const char *dir, const char *file)\n{\n  Pool *pool = data->repo->pool;\n  Solvable *s;\n  const char *str, *fp;\n  int l = 0;\n\n  if (medianr)\n    repodata_set_constant(data, solvid, SOLVABLE_MEDIANR, medianr);\n  if (!dir)\n    {\n      if ((dir = strrchr(file, '/')) != 0)\n\t{\n          l = dir - file;\n\t  dir = file;\n\t  file = dir + l + 1;\n\t  if (!l)\n\t    l++;\n\t}\n    }\n  else\n    l = strlen(dir);\n  if (l >= 2 && dir[0] == '.' && dir[1] == '/' && (l == 2 || dir[2] != '/'))\n    {\n      dir += 2;\n      l -= 2;\n    }\n  if (l == 1 && dir[0] == '.')\n    l = 0;\n  s = pool->solvables + solvid;\n  if (dir && l)\n    {\n      str = pool_id2str(pool, s->arch);\n      if (!strncmp(dir, str, l) && !str[l])\n\trepodata_set_void(data, solvid, SOLVABLE_MEDIADIR);\n      else\n\trepodata_set_strn(data, solvid, SOLVABLE_MEDIADIR, dir, l);\n    }\n  fp = file;\n  str = pool_id2str(pool, s->name);\n  l = strlen(str);\n  if ((!l || !strncmp(fp, str, l)) && fp[l] == '-')\n    {\n      fp += l + 1;\n      str = evrid2vrstr(pool, s->evr);\n      l = strlen(str);\n      if ((!l || !strncmp(fp, str, l)) && fp[l] == '.')\n\t{\n\t  fp += l + 1;\n\t  str = pool_id2str(pool, s->arch);\n\t  l = strlen(str);\n\t  if ((!l || !strncmp(fp, str, l)) && !strcmp(fp + l, \".rpm\"))\n\t    {\n\t      repodata_set_void(data, solvid, SOLVABLE_MEDIAFILE);\n\t      return;\n\t    }\n\t}\n    }\n  repodata_set_str(data, solvid, SOLVABLE_MEDIAFILE, file);\n}\n\n/* XXX: medianr is currently not stored */\nvoid\nrepodata_set_deltalocation(Repodata *data, Id handle, int medianr, const char *dir, const char *file)\n{\n  int l = 0;\n  const char *evr, *suf, *s;\n\n  if (!dir)\n    {\n      if ((dir = strrchr(file, '/')) != 0)\n\t{\n          l = dir - file;\n\t  dir = file;\n\t  file = dir + l + 1;\n\t  if (!l)\n\t    l++;\n\t}\n    }\n  else\n    l = strlen(dir);\n  if (l >= 2 && dir[0] == '.' && dir[1] == '/' && (l == 2 || dir[2] != '/'))\n    {\n      dir += 2;\n      l -= 2;\n    }\n  if (l == 1 && dir[0] == '.')\n    l = 0;\n  if (dir && l)\n    repodata_set_poolstrn(data, handle, DELTA_LOCATION_DIR, dir, l);\n  evr = strchr(file, '-');\n  if (evr)\n    {\n      for (s = evr - 1; s > file; s--)\n\tif (*s == '-')\n\t  {\n\t    evr = s;\n\t    break;\n\t  }\n    }\n  suf = strrchr(file, '.');\n  if (suf)\n    {\n      for (s = suf - 1; s > file; s--)\n\tif (*s == '.')\n\t  {\n\t    suf = s;\n\t    break;\n\t  }\n      if (!strcmp(suf, \".delta.rpm\") || !strcmp(suf, \".patch.rpm\"))\n\t{\n\t  /* We accept one more item as suffix.  */\n\t  for (s = suf - 1; s > file; s--)\n\t    if (*s == '.')\n\t      {\n\t\tsuf = s;\n\t        break;\n\t      }\n\t}\n    }\n  if (!evr)\n    suf = 0;\n  if (suf && evr && suf < evr)\n    suf = 0;\n  repodata_set_poolstrn(data, handle, DELTA_LOCATION_NAME, file, evr ? evr - file : strlen(file));\n  if (evr)\n    repodata_set_poolstrn(data, handle, DELTA_LOCATION_EVR, evr + 1, suf ? suf - evr - 1: strlen(evr + 1));\n  if (suf)\n    repodata_set_poolstr(data, handle, DELTA_LOCATION_SUFFIX, suf + 1);\n}\n\nvoid\nrepodata_set_sourcepkg(Repodata *data, Id solvid, const char *sourcepkg)\n{\n  Pool *pool = data->repo->pool;\n  Solvable *s = pool->solvables + solvid;\n  const char *p, *sevr, *sarch, *name, *evr;\n\n  p = strrchr(sourcepkg, '.');\n  if (!p || strcmp(p, \".rpm\") != 0)\n    {\n      if (*sourcepkg)\n        repodata_set_str(data, solvid, SOLVABLE_SOURCENAME, sourcepkg);\n      return;\n    }\n  p--;\n  while (p > sourcepkg && *p != '.')\n    p--;\n  if (*p != '.' || p == sourcepkg)\n    return;\n  sarch = p-- + 1;\n  while (p > sourcepkg && *p != '-')\n    p--;\n  if (*p != '-' || p == sourcepkg)\n    return;\n  p--;\n  while (p > sourcepkg && *p != '-')\n    p--;\n  if (*p != '-' || p == sourcepkg)\n    return;\n  sevr = p + 1;\n  pool = s->repo->pool;\n\n  name = pool_id2str(pool, s->name);\n  if (name && !strncmp(sourcepkg, name, sevr - sourcepkg - 1) && name[sevr - sourcepkg - 1] == 0)\n    repodata_set_void(data, solvid, SOLVABLE_SOURCENAME);\n  else\n    repodata_set_id(data, solvid, SOLVABLE_SOURCENAME, pool_strn2id(pool, sourcepkg, sevr - sourcepkg - 1, 1));\n\n  evr = evrid2vrstr(pool, s->evr);\n  if (evr && !strncmp(sevr, evr, sarch - sevr - 1) && evr[sarch - sevr - 1] == 0)\n    repodata_set_void(data, solvid, SOLVABLE_SOURCEEVR);\n  else\n    repodata_set_id(data, solvid, SOLVABLE_SOURCEEVR, pool_strn2id(pool, sevr, sarch - sevr - 1, 1));\n\n  if (!strcmp(sarch, \"src.rpm\"))\n    repodata_set_constantid(data, solvid, SOLVABLE_SOURCEARCH, ARCH_SRC);\n  else if (!strcmp(sarch, \"nosrc.rpm\"))\n    repodata_set_constantid(data, solvid, SOLVABLE_SOURCEARCH, ARCH_NOSRC);\n  else\n    repodata_set_constantid(data, solvid, SOLVABLE_SOURCEARCH, pool_strn2id(pool, sarch, strlen(sarch) - 4, 1));\n}\n\nvoid\nrepodata_set_idarray(Repodata *data, Id solvid, Id keyname, Queue *q)\n{\n  Repokey key;\n  int i;\n\n  key.name = keyname;\n  key.type = REPOKEY_TYPE_IDARRAY;\n  key.size = 0;\n  key.storage = KEY_STORAGE_INCORE;\n  repodata_set(data, solvid, &key, data->attriddatalen);\n  data->attriddata = solv_extend(data->attriddata, data->attriddatalen, q->count + 1, sizeof(Id), REPODATA_ATTRIDDATA_BLOCK);\n  for (i = 0; i < q->count; i++)\n    data->attriddata[data->attriddatalen++] = q->elements[i];\n  data->attriddata[data->attriddatalen++] = 0;\n}\n\nvoid\nrepodata_add_dirnumnum(Repodata *data, Id solvid, Id keyname, Id dir, Id num, Id num2)\n{\n  assert(dir);\n#if 0\nfprintf(stderr, \"repodata_add_dirnumnum %d %d %d %d (%d)\\n\", solvid, dir, num, num2, data->attriddatalen);\n#endif\n  repodata_add_array(data, solvid, keyname, REPOKEY_TYPE_DIRNUMNUMARRAY, 3);\n  data->attriddata[data->attriddatalen++] = dir;\n  data->attriddata[data->attriddatalen++] = num;\n  data->attriddata[data->attriddatalen++] = num2;\n  data->attriddata[data->attriddatalen++] = 0;\n}\n\nvoid\nrepodata_add_dirstr(Repodata *data, Id solvid, Id keyname, Id dir, const char *str)\n{\n  Id stroff;\n  int l;\n\n  assert(dir);\n  l = strlen(str) + 1;\n  data->attrdata = solv_extend(data->attrdata, data->attrdatalen, l, 1, REPODATA_ATTRDATA_BLOCK);\n  memcpy(data->attrdata + data->attrdatalen, str, l);\n  stroff = data->attrdatalen;\n  data->attrdatalen += l;\n\n#if 0\nfprintf(stderr, \"repodata_add_dirstr %d %d %s (%d)\\n\", solvid, dir, str,  data->attriddatalen);\n#endif\n  repodata_add_array(data, solvid, keyname, REPOKEY_TYPE_DIRSTRARRAY, 2);\n  data->attriddata[data->attriddatalen++] = dir;\n  data->attriddata[data->attriddatalen++] = stroff;\n  data->attriddata[data->attriddatalen++] = 0;\n}\n\nvoid\nrepodata_add_idarray(Repodata *data, Id solvid, Id keyname, Id id)\n{\n#if 0\nfprintf(stderr, \"repodata_add_idarray %d %d (%d)\\n\", solvid, id, data->attriddatalen);\n#endif\n  repodata_add_array(data, solvid, keyname, REPOKEY_TYPE_IDARRAY, 1);\n  data->attriddata[data->attriddatalen++] = id;\n  data->attriddata[data->attriddatalen++] = 0;\n}\n\nvoid\nrepodata_add_poolstr_array(Repodata *data, Id solvid, Id keyname,\n\t\t\t   const char *str)\n{\n  Id id;\n  if (data->localpool)\n    id = stringpool_str2id(&data->spool, str, 1);\n  else\n    id = pool_str2id(data->repo->pool, str, 1);\n  repodata_add_idarray(data, solvid, keyname, id);\n}\n\nvoid\nrepodata_add_fixarray(Repodata *data, Id solvid, Id keyname, Id handle)\n{\n  repodata_add_array(data, solvid, keyname, REPOKEY_TYPE_FIXARRAY, 1);\n  data->attriddata[data->attriddatalen++] = handle;\n  data->attriddata[data->attriddatalen++] = 0;\n}\n\nvoid\nrepodata_add_flexarray(Repodata *data, Id solvid, Id keyname, Id handle)\n{\n  repodata_add_array(data, solvid, keyname, REPOKEY_TYPE_FLEXARRAY, 1);\n  data->attriddata[data->attriddatalen++] = handle;\n  data->attriddata[data->attriddatalen++] = 0;\n}\n\nvoid\nrepodata_set_kv(Repodata *data, Id solvid, Id keyname, Id keytype, KeyValue *kv)\n{\n  switch (keytype)\n    {\n    case REPOKEY_TYPE_ID:\n      repodata_set_id(data, solvid, keyname, kv->id);\n      break;\n    case REPOKEY_TYPE_CONSTANTID:\n      repodata_set_constantid(data, solvid, keyname, kv->id);\n      break;\n    case REPOKEY_TYPE_IDARRAY:\n      repodata_add_idarray(data, solvid, keyname, kv->id);\n      break;\n    case REPOKEY_TYPE_STR:\n      repodata_set_str(data, solvid, keyname, kv->str);\n      break;\n    case REPOKEY_TYPE_VOID:\n      repodata_set_void(data, solvid, keyname);\n      break;\n    case REPOKEY_TYPE_NUM:\n      repodata_set_num(data, solvid, keyname, SOLV_KV_NUM64(kv));\n      break;\n    case REPOKEY_TYPE_CONSTANT:\n      repodata_set_constant(data, solvid, keyname, kv->num);\n      break;\n    case REPOKEY_TYPE_DIRNUMNUMARRAY:\n      if (kv->id)\n        repodata_add_dirnumnum(data, solvid, keyname, kv->id, kv->num, kv->num2);\n      break;\n    case REPOKEY_TYPE_DIRSTRARRAY:\n      repodata_add_dirstr(data, solvid, keyname, kv->id, kv->str);\n      break;\n    case_CHKSUM_TYPES:\n      repodata_set_bin_checksum(data, solvid, keyname, keytype, (const unsigned char *)kv->str);\n      break;\n    default:\n      break;\n    }\n}\n\nvoid\nrepodata_unset_uninternalized(Repodata *data, Id solvid, Id keyname)\n{\n  Id *pp, *ap, **app;\n  app = repodata_get_attrp(data, solvid);\n  ap = *app;\n  if (!ap)\n    return;\n  if (!keyname)\n    {\n      *app = 0;\t\t/* delete all attributes */\n      return;\n    }\n  for (; *ap; ap += 2)\n    if (data->keys[*ap].name == keyname)\n      break;\n  if (!*ap)\n    return;\n  pp = ap;\n  ap += 2;\n  for (; *ap; ap += 2)\n    {\n      if (data->keys[*ap].name == keyname)\n\tcontinue;\n      *pp++ = ap[0];\n      *pp++ = ap[1];\n    }\n  *pp = 0;\n}\n\nvoid\nrepodata_unset(Repodata *data, Id solvid, Id keyname)\n{\n  Repokey key;\n  key.name = keyname;\n  key.type = REPOKEY_TYPE_DELETED;\n  key.size = 0;\n  key.storage = KEY_STORAGE_INCORE;\n  repodata_set(data, solvid, &key, 0);\n}\n\n/* add all (uninternalized) attrs from src to dest */\nvoid\nrepodata_merge_attrs(Repodata *data, Id dest, Id src)\n{\n  Id *keyp;\n  if (dest == src || !data->attrs || !(keyp = data->attrs[src - data->start]))\n    return;\n  for (; *keyp; keyp += 2)\n    repodata_insert_keyid(data, dest, keyp[0], keyp[1], 0);\n}\n\n/* add some (uninternalized) attrs from src to dest */\nvoid\nrepodata_merge_some_attrs(Repodata *data, Id dest, Id src, Map *keyidmap, int overwrite)\n{\n  Id *keyp;\n  if (dest == src || !data->attrs || !(keyp = data->attrs[src - data->start]))\n    return;\n  for (; *keyp; keyp += 2)\n    if (!keyidmap || MAPTST(keyidmap, keyp[0]))\n      repodata_insert_keyid(data, dest, keyp[0], keyp[1], overwrite);\n}\n\n/* swap (uninternalized) attrs from src and dest */\nvoid\nrepodata_swap_attrs(Repodata *data, Id dest, Id src)\n{\n  Id *tmpattrs;\n  if (!data->attrs || dest == src)\n    return;\n  if (dest < data->start || dest >= data->end)\n    repodata_extend(data, dest);\n  if (src < data->start || src >= data->end)\n    repodata_extend(data, src);\n  tmpattrs = data->attrs[dest - data->start];\n  data->attrs[dest - data->start] = data->attrs[src - data->start];\n  data->attrs[src - data->start] = tmpattrs;\n}\n\n\n/**********************************************************************/\n\n/* TODO: unify with repo_write and repo_solv! */\n\n#define EXTDATA_BLOCK 1023\n\nstruct extdata {\n  unsigned char *buf;\n  int len;\n};\n\nstatic void\ndata_addid(struct extdata *xd, Id sx)\n{\n  unsigned int x = (unsigned int)sx;\n  unsigned char *dp;\n\n  xd->buf = solv_extend(xd->buf, xd->len, 5, 1, EXTDATA_BLOCK);\n  dp = xd->buf + xd->len;\n\n  if (x >= (1 << 14))\n    {\n      if (x >= (1 << 28))\n        *dp++ = (x >> 28) | 128;\n      if (x >= (1 << 21))\n        *dp++ = (x >> 21) | 128;\n      *dp++ = (x >> 14) | 128;\n    }\n  if (x >= (1 << 7))\n    *dp++ = (x >> 7) | 128;\n  *dp++ = x & 127;\n  xd->len = dp - xd->buf;\n}\n\nstatic void\ndata_addid64(struct extdata *xd, unsigned long long x)\n{\n  if (x >= 0x100000000)\n    {\n      if ((x >> 35) != 0)\n\t{\n\t  data_addid(xd, (Id)(x >> 35));\n\t  xd->buf[xd->len - 1] |= 128;\n\t}\n      data_addid(xd, (Id)((unsigned int)x | 0x80000000));\n      xd->buf[xd->len - 5] = (x >> 28) | 128;\n    }\n  else\n    data_addid(xd, (Id)x);\n}\n\nstatic void\ndata_addideof(struct extdata *xd, Id sx, int eof)\n{\n  unsigned int x = (unsigned int)sx;\n  unsigned char *dp;\n\n  xd->buf = solv_extend(xd->buf, xd->len, 5, 1, EXTDATA_BLOCK);\n  dp = xd->buf + xd->len;\n\n  if (x >= (1 << 13))\n    {\n      if (x >= (1 << 27))\n        *dp++ = (x >> 27) | 128;\n      if (x >= (1 << 20))\n        *dp++ = (x >> 20) | 128;\n      *dp++ = (x >> 13) | 128;\n    }\n  if (x >= (1 << 6))\n    *dp++ = (x >> 6) | 128;\n  *dp++ = eof ? (x & 63) : (x & 63) | 64;\n  xd->len = dp - xd->buf;\n}\n\nstatic void\ndata_addblob(struct extdata *xd, unsigned char *blob, int len)\n{\n  xd->buf = solv_extend(xd->buf, xd->len, len, 1, EXTDATA_BLOCK);\n  memcpy(xd->buf + xd->len, blob, len);\n  xd->len += len;\n}\n\n/*********************************/\n\n/* this is to reduct memory usage when internalizing oversized repos */\nstatic void\ncompact_attrdata(Repodata *data, int entry, int nentry)\n{\n  int i;\n  unsigned int attrdatastart = data->attrdatalen;\n  unsigned int attriddatastart = data->attriddatalen;\n  if (attrdatastart < 1024 * 1024 * 4 && attriddatastart < 1024 * 1024)\n    return;\n  for (i = entry; i < nentry; i++)\n    {\n      Id v, *attrs = data->attrs[i];\n      if (!attrs)\n\tcontinue;\n      for (; *attrs; attrs += 2)\n\t{\n\t  switch (data->keys[*attrs].type)\n\t    {\n\t    case REPOKEY_TYPE_STR:\n\t    case REPOKEY_TYPE_BINARY:\n\t    case_CHKSUM_TYPES:\n\t      if ((unsigned int)attrs[1] < attrdatastart)\n\t\t attrdatastart = attrs[1];\n\t      break;\n\t    case REPOKEY_TYPE_DIRSTRARRAY:\n\t      for (v = attrs[1]; data->attriddata[v] ; v += 2)\n\t\tif ((unsigned int)data->attriddata[v + 1] < attrdatastart)\n\t\t  attrdatastart = data->attriddata[v + 1];\n\t      /* FALLTHROUGH */\n\t    case REPOKEY_TYPE_IDARRAY:\n\t    case REPOKEY_TYPE_DIRNUMNUMARRAY:\n\t      if ((unsigned int)attrs[1] < attriddatastart)\n\t\tattriddatastart = attrs[1];\n\t      break;\n\t    case REPOKEY_TYPE_FIXARRAY:\n\t    case REPOKEY_TYPE_FLEXARRAY:\n\t      return;\n\t    default:\n\t      break;\n\t    }\n\t}\n    }\n#if 0\n  printf(\"compact_attrdata %d %d\\n\", entry, nentry);\n  printf(\"attrdatastart: %d\\n\", attrdatastart);\n  printf(\"attriddatastart: %d\\n\", attriddatastart);\n#endif\n  if (attrdatastart < 1024 * 1024 * 4 && attriddatastart < 1024 * 1024)\n    return;\n  for (i = entry; i < nentry; i++)\n    {\n      Id v, *attrs = data->attrs[i];\n      if (!attrs)\n\tcontinue;\n      for (; *attrs; attrs += 2)\n\t{\n\t  switch (data->keys[*attrs].type)\n\t    {\n\t    case REPOKEY_TYPE_STR:\n\t    case REPOKEY_TYPE_BINARY:\n\t    case_CHKSUM_TYPES:\n\t      attrs[1] -= attrdatastart;\n\t      break;\n\t    case REPOKEY_TYPE_DIRSTRARRAY:\n\t      for (v = attrs[1]; data->attriddata[v] ; v += 2)\n\t\tdata->attriddata[v + 1] -= attrdatastart;\n\t      /* FALLTHROUGH */\n\t    case REPOKEY_TYPE_IDARRAY:\n\t    case REPOKEY_TYPE_DIRNUMNUMARRAY:\n\t      attrs[1] -= attriddatastart;\n\t      break;\n\t    default:\n\t      break;\n\t    }\n\t}\n    }\n  if (attrdatastart)\n    {\n      data->attrdatalen -= attrdatastart;\n      memmove(data->attrdata, data->attrdata + attrdatastart, data->attrdatalen);\n      data->attrdata = solv_extend_resize(data->attrdata, data->attrdatalen, 1, REPODATA_ATTRDATA_BLOCK);\n    }\n  if (attriddatastart)\n    {\n      data->attriddatalen -= attriddatastart;\n      memmove(data->attriddata, data->attriddata + attriddatastart, data->attriddatalen * sizeof(Id));\n      data->attriddata = solv_extend_resize(data->attriddata, data->attriddatalen, sizeof(Id), REPODATA_ATTRIDDATA_BLOCK);\n    }\n}\n\n/* internalalize some key into incore/vincore data */\n\nstatic void\nrepodata_serialize_key(Repodata *data, struct extdata *newincore,\n\t\t       struct extdata *newvincore,\n\t\t       Id *schema,\n\t\t       Repokey *key, Id val)\n{\n  Id *ida;\n  struct extdata *xd;\n  unsigned int oldvincorelen = 0;\n  Id schemaid, *sp;\n\n  xd = newincore;\n  if (key->storage == KEY_STORAGE_VERTICAL_OFFSET)\n    {\n      xd = newvincore;\n      oldvincorelen = xd->len;\n    }\n  switch (key->type)\n    {\n    case REPOKEY_TYPE_VOID:\n    case REPOKEY_TYPE_CONSTANT:\n    case REPOKEY_TYPE_CONSTANTID:\n    case REPOKEY_TYPE_DELETED:\n      break;\n    case REPOKEY_TYPE_STR:\n      data_addblob(xd, data->attrdata + val, strlen((char *)(data->attrdata + val)) + 1);\n      break;\n    case REPOKEY_TYPE_MD5:\n      data_addblob(xd, data->attrdata + val, SIZEOF_MD5);\n      break;\n    case REPOKEY_TYPE_SHA1:\n      data_addblob(xd, data->attrdata + val, SIZEOF_SHA1);\n      break;\n    case REPOKEY_TYPE_SHA224:\n      data_addblob(xd, data->attrdata + val, SIZEOF_SHA224);\n      break;\n    case REPOKEY_TYPE_SHA256:\n      data_addblob(xd, data->attrdata + val, SIZEOF_SHA256);\n      break;\n    case REPOKEY_TYPE_SHA384:\n      data_addblob(xd, data->attrdata + val, SIZEOF_SHA384);\n      break;\n    case REPOKEY_TYPE_SHA512:\n      data_addblob(xd, data->attrdata + val, SIZEOF_SHA512);\n      break;\n    case REPOKEY_TYPE_NUM:\n      if (val & 0x80000000)\n\t{\n\t  data_addid64(xd, data->attrnum64data[val ^ 0x80000000]);\n\t  break;\n\t}\n      /* FALLTHROUGH */\n    case REPOKEY_TYPE_ID:\n    case REPOKEY_TYPE_DIR:\n      data_addid(xd, val);\n      break;\n    case REPOKEY_TYPE_BINARY:\n      {\n\tId len;\n\tunsigned char *dp = data_read_id(data->attrdata + val, &len);\n\tdp += (unsigned int)len;\n\tdata_addblob(xd, data->attrdata + val, dp - (data->attrdata + val));\n      }\n      break;\n    case REPOKEY_TYPE_IDARRAY:\n      for (ida = data->attriddata + val; *ida; ida++)\n\tdata_addideof(xd, ida[0], ida[1] ? 0 : 1);\n      break;\n    case REPOKEY_TYPE_DIRNUMNUMARRAY:\n      for (ida = data->attriddata + val; *ida; ida += 3)\n\t{\n\t  data_addid(xd, ida[0]);\n\t  data_addid(xd, ida[1]);\n\t  data_addideof(xd, ida[2], ida[3] ? 0 : 1);\n\t}\n      break;\n    case REPOKEY_TYPE_DIRSTRARRAY:\n      for (ida = data->attriddata + val; *ida; ida += 2)\n\t{\n\t  data_addideof(xd, ida[0], ida[2] ? 0 : 1);\n\t  data_addblob(xd, data->attrdata + ida[1], strlen((char *)(data->attrdata + ida[1])) + 1);\n\t}\n      break;\n    case REPOKEY_TYPE_FIXARRAY:\n      {\n\tint num = 0;\n\tschemaid = 0;\n\tfor (ida = data->attriddata + val; *ida; ida++)\n\t  {\n\t    Id *kp;\n\t    sp = schema;\n\t    kp = data->xattrs[-*ida];\n\t    if (!kp)\n\t      continue;\t\t/* ignore empty elements */\n\t    num++;\n\t    for (; *kp; kp += 2)\n\t      *sp++ = *kp;\n\t    *sp = 0;\n\t    if (!schemaid)\n\t      schemaid = repodata_schema2id(data, schema, 1);\n\t    else if (schemaid != repodata_schema2id(data, schema, 0))\n\t      {\n\t \tpool_debug(data->repo->pool, SOLV_ERROR, \"repodata_serialize_key: fixarray substructs with different schemas\\n\");\n\t\tnum = 0;\n\t\tbreak;\n\t      }\n\t  }\n\tdata_addid(xd, num);\n\tif (!num)\n\t  break;\n\tdata_addid(xd, schemaid);\n\tfor (ida = data->attriddata + val; *ida; ida++)\n\t  {\n\t    Id *kp = data->xattrs[-*ida];\n\t    if (!kp)\n\t      continue;\n\t    for (; *kp; kp += 2)\n\t      repodata_serialize_key(data, newincore, newvincore, schema, data->keys + *kp, kp[1]);\n\t  }\n\tbreak;\n      }\n    case REPOKEY_TYPE_FLEXARRAY:\n      {\n\tint num = 0;\n\tfor (ida = data->attriddata + val; *ida; ida++)\n\t  num++;\n\tdata_addid(xd, num);\n\tfor (ida = data->attriddata + val; *ida; ida++)\n\t  {\n\t    Id *kp = data->xattrs[-*ida];\n\t    if (!kp)\n\t      {\n\t        data_addid(xd, 0);\t/* XXX */\n\t        continue;\n\t      }\n\t    sp = schema;\n\t    for (;*kp; kp += 2)\n\t      *sp++ = *kp;\n\t    *sp = 0;\n\t    schemaid = repodata_schema2id(data, schema, 1);\n\t    data_addid(xd, schemaid);\n\t    kp = data->xattrs[-*ida];\n\t    for (;*kp; kp += 2)\n\t      repodata_serialize_key(data, newincore, newvincore, schema, data->keys + *kp, kp[1]);\n\t  }\n\tbreak;\n      }\n    default:\n      pool_debug(data->repo->pool, SOLV_FATAL, \"repodata_serialize_key: don't know how to handle type %d\\n\", key->type);\n      exit(1);\n    }\n  if (key->storage == KEY_STORAGE_VERTICAL_OFFSET)\n    {\n      /* put offset/len in incore */\n      data_addid(newincore, data->lastverticaloffset + oldvincorelen);\n      oldvincorelen = xd->len - oldvincorelen;\n      data_addid(newincore, oldvincorelen);\n    }\n}\n\n/* create a circular linked list of all keys that share\n * the same keyname */\nstatic Id *\ncalculate_keylink(Repodata *data)\n{\n  int i, j;\n  Id *link;\n  Id maxkeyname = 0, *keytable = 0;\n  link = solv_calloc(data->nkeys, sizeof(Id));\n  if (data->nkeys <= 2)\n    return link;\n  for (i = 1; i < data->nkeys; i++)\n    {\n      Id n = data->keys[i].name;\n      if (n >= maxkeyname)\n\t{\n\t  keytable = solv_realloc2(keytable, n + 128, sizeof(Id));\n\t  memset(keytable + maxkeyname, 0, (n + 128 - maxkeyname) * sizeof(Id));\n\t  maxkeyname = n + 128;\n\t}\n      j = keytable[n];\n      if (j)\n\tlink[i] = link[j];\n      else\n\tj = i;\n      link[j] = i;\n      keytable[n] = i;\n    }\n  /* remove links that just point to themselfs */\n  for (i = 1; i < data->nkeys; i++)\n    if (link[i] == i)\n      link[i] = 0;\n  solv_free(keytable);\n  return link;\n}\n\nvoid\nrepodata_internalize(Repodata *data)\n{\n  Repokey *key, solvkey;\n  Id entry, nentry;\n  Id schemaid, keyid, *schema, *sp, oldschemaid, *keyp, *seen;\n  Offset *oldincoreoffs = 0;\n  int schemaidx;\n  unsigned char *dp, *ndp;\n  int neednewschema;\n  struct extdata newincore;\n  struct extdata newvincore;\n  Id solvkeyid;\n  Id *keylink;\n  int haveoldkl;\n\n  if (!data->attrs && !data->xattrs)\n    return;\n\n#if 0\n  printf(\"repodata_internalize %d\\n\", data->repodataid);\n  printf(\"  attr data: %d K\\n\", data->attrdatalen / 1024);\n  printf(\"  attrid data: %d K\\n\", data->attriddatalen / (1024 / 4));\n#endif\n  newvincore.buf = data->vincore;\n  newvincore.len = data->vincorelen;\n\n  /* find the solvables key, create if needed */\n  memset(&solvkey, 0, sizeof(solvkey));\n  solvkey.name = REPOSITORY_SOLVABLES;\n  solvkey.type = REPOKEY_TYPE_FLEXARRAY;\n  solvkey.size = 0;\n  solvkey.storage = KEY_STORAGE_INCORE;\n  solvkeyid = repodata_key2id(data, &solvkey, data->end != data->start ? 1 : 0);\n\n  schema = solv_malloc2(data->nkeys, sizeof(Id));\n  seen = solv_malloc2(data->nkeys, sizeof(Id));\n\n  /* Merge the data already existing (in data->schemata, ->incoredata and\n     friends) with the new attributes in data->attrs[].  */\n  nentry = data->end - data->start;\n  memset(&newincore, 0, sizeof(newincore));\n  data_addid(&newincore, 0);\t/* start data at offset 1 */\n\n  data->mainschema = 0;\n  data->mainschemaoffsets = solv_free(data->mainschemaoffsets);\n\n  keylink = calculate_keylink(data);\n  /* join entry data */\n  /* we start with the meta data, entry -1 */\n  for (entry = -1; entry < nentry; entry++)\n    {\n      oldschemaid = 0;\n      dp = data->incoredata;\n      if (dp)\n\t{\n\t  dp += entry >= 0 ? data->incoreoffset[entry] : 1;\n          dp = data_read_id(dp, &oldschemaid);\n\t}\n      memset(seen, 0, data->nkeys * sizeof(Id));\n#if 0\nfprintf(stderr, \"oldschemaid %d\\n\", oldschemaid);\nfprintf(stderr, \"schemata %d\\n\", data->schemata[oldschemaid]);\nfprintf(stderr, \"schemadata %p\\n\", data->schemadata);\n#endif\n\n      /* seen: -1: old data,  0: skipped,  >0: id + 1 */\n      neednewschema = 0;\n      sp = schema;\n      haveoldkl = 0;\n      for (keyp = data->schemadata + data->schemata[oldschemaid]; *keyp; keyp++)\n\t{\n\t  if (seen[*keyp])\n\t    {\n\t      /* oops, should not happen */\n\t      neednewschema = 1;\n\t      continue;\n\t    }\n\t  seen[*keyp] = -1;\t/* use old marker */\n\t  *sp++ = *keyp;\n\t  if (keylink[*keyp])\n\t    haveoldkl = 1;\t/* potential keylink conflict */\n\t}\n\n      /* strip solvables key */\n      if (entry < 0 && solvkeyid && seen[solvkeyid])\n\t{\n\t  *sp = 0;\n\t  for (sp = keyp = schema; *sp; sp++)\n\t    if (*sp != solvkeyid)\n\t      *keyp++ = *sp;\n\t  sp = keyp;\n\t  seen[solvkeyid] = 0;\n\t  neednewschema = 1;\n\t}\n\n      /* add new entries */\n      if (entry >= 0)\n\tkeyp = data->attrs ? data->attrs[entry] : 0;\n      else\n        keyp = data->xattrs ? data->xattrs[1] : 0;\n      if (keyp)\n        for (; *keyp; keyp += 2)\n\t  {\n\t    if (!seen[*keyp])\n\t      {\n\t        neednewschema = 1;\n\t        *sp++ = *keyp;\n\t\tif (haveoldkl && keylink[*keyp])\t\t/* this should be pretty rare */\n\t\t  {\n\t\t    Id kl;\n\t\t    for (kl = keylink[*keyp]; kl != *keyp; kl = keylink[kl])\n\t\t      if (seen[kl] == -1)\n\t\t        {\n\t\t\t  /* replacing old key kl, remove from schema and seen */\n\t\t\t  Id *osp;\n\t\t\t  for (osp = schema; osp < sp; osp++)\n\t\t\t    if (*osp == kl)\n\t\t\t      {\n\t\t\t        memmove(osp, osp + 1, (sp - osp) * sizeof(Id));\n\t\t\t        sp--;\n\t\t\t        seen[kl] = 0;\n\t\t\t\tbreak;\n\t\t\t      }\n\t\t        }\n\t\t  }\n\t      }\n\t    seen[*keyp] = keyp[1] + 1;\n\t  }\n\n      /* add solvables key if needed */\n      if (entry < 0 && data->end != data->start)\n\t{\n\t  *sp++ = solvkeyid;\t/* always last in schema */\n\t  neednewschema = 1;\n\t}\n\n      /* commit schema */\n      *sp = 0;\n      if (neednewschema)\n        /* Ideally we'd like to sort the new schema here, to ensure\n\t   schema equality independend of the ordering. */\n\tschemaid = repodata_schema2id(data, schema, 1);\n      else\n\tschemaid = oldschemaid;\n\n      if (entry < 0)\n\t{\n\t  data->mainschemaoffsets = solv_calloc(sp - schema, sizeof(Id));\n\t  data->mainschema = schemaid;\n\t}\n\n      /* find offsets in old incore data */\n      if (oldschemaid)\n\t{\n\t  Id *lastneeded = 0;\n\t  for (sp = data->schemadata + data->schemata[oldschemaid]; *sp; sp++)\n\t    if (seen[*sp] == -1)\n\t      lastneeded = sp + 1;\n\t  if (lastneeded)\n\t    {\n\t      if (!oldincoreoffs)\n\t        oldincoreoffs = solv_malloc2(data->nkeys, 2 * sizeof(Offset));\n\t      for (sp = data->schemadata + data->schemata[oldschemaid]; sp != lastneeded; sp++)\n\t\t{\n\t\t  /* Skip the data associated with this old key.  */\n\t\t  key = data->keys + *sp;\n\t\t  ndp = dp;\n\t\t  if (key->storage == KEY_STORAGE_VERTICAL_OFFSET)\n\t\t    {\n\t\t      ndp = data_skip(ndp, REPOKEY_TYPE_ID);\n\t\t      ndp = data_skip(ndp, REPOKEY_TYPE_ID);\n\t\t    }\n\t\t  else if (key->storage == KEY_STORAGE_INCORE)\n\t\t    ndp = data_skip_key(data, ndp, key);\n\t\t  oldincoreoffs[*sp * 2] = dp - data->incoredata;\n\t\t  oldincoreoffs[*sp * 2 + 1] = ndp - dp;\n\t\t  dp = ndp;\n\t\t}\n\t    }\n\t}\n\n      /* just copy over the complete old entry (including the schemaid) if there was no new data */\n      if (entry >= 0 && !neednewschema && oldschemaid && (!data->attrs || !data->attrs[entry]) && dp)\n\t{\n\t  ndp = data->incoredata + data->incoreoffset[entry];\n\t  data->incoreoffset[entry] = newincore.len;\n\t  data_addblob(&newincore, ndp, dp - ndp);\n\t  goto entrydone;\n\t}\n\n      /* Now create data blob.  We walk through the (possibly new) schema\n\t and either copy over old data, or insert the new.  */\n      if (entry >= 0)\n        data->incoreoffset[entry] = newincore.len;\n      data_addid(&newincore, schemaid);\n\n      /* we don't use a pointer to the schemadata here as repodata_serialize_key\n       * may call repodata_schema2id() which might realloc our schemadata */\n      for (schemaidx = data->schemata[schemaid]; (keyid = data->schemadata[schemaidx]) != 0; schemaidx++)\n\t{\n\t  if (entry < 0)\n\t    {\n\t      data->mainschemaoffsets[schemaidx - data->schemata[schemaid]] = newincore.len;\n\t      if (keyid == solvkeyid)\n\t\t{\n\t\t  /* add flexarray entry count */\n\t\t  data_addid(&newincore, data->end - data->start);\n\t\t  break;\t/* always the last entry */\n\t\t}\n\t    }\n\t  if (seen[keyid] == -1)\n\t    {\n\t      if (oldincoreoffs[keyid * 2 + 1])\n\t\tdata_addblob(&newincore, data->incoredata + oldincoreoffs[keyid * 2], oldincoreoffs[keyid * 2 + 1]);\n\t    }\n\t  else if (seen[keyid])\n\t    repodata_serialize_key(data, &newincore, &newvincore, schema, data->keys + keyid, seen[keyid] - 1);\n\t}\n\nentrydone:\n      /* free memory */\n      if (entry >= 0 && data->attrs)\n\t{\n\t  if (data->attrs[entry])\n\t    data->attrs[entry] = solv_free(data->attrs[entry]);\n\t  if (entry && entry % 4096 == 0 && data->nxattrs <= 2 && entry + 64 < nentry)\n\t    {\n\t      compact_attrdata(data, entry + 1, nentry);\t/* try to free some memory */\n#if 0\n\t      printf(\"  attr data: %d K\\n\", data->attrdatalen / 1024);\n\t      printf(\"  attrid data: %d K\\n\", data->attriddatalen / (1024 / 4));\n\t      printf(\"  incore data: %d K\\n\", newincore.len / 1024);\n\t      printf(\"  sum: %d K\\n\", (newincore.len + data->attrdatalen + data->attriddatalen * 4) / 1024);\n\t      /* malloc_stats(); */\n#endif\n\t    }\n\t}\n    }\n  /* free all xattrs */\n  for (entry = 0; entry < data->nxattrs; entry++)\n    if (data->xattrs[entry])\n      solv_free(data->xattrs[entry]);\n  data->xattrs = solv_free(data->xattrs);\n  data->nxattrs = 0;\n\n  data->lasthandle = 0;\n  data->lastkey = 0;\n  data->lastdatalen = 0;\n  solv_free(schema);\n  solv_free(seen);\n  solv_free(keylink);\n  solv_free(oldincoreoffs);\n  repodata_free_schemahash(data);\n\n  solv_free(data->incoredata);\n  data->incoredata = newincore.buf;\n  data->incoredatalen = newincore.len;\n  data->incoredatafree = 0;\n\n  data->vincore = newvincore.buf;\n  data->vincorelen = newvincore.len;\n\n  data->attrs = solv_free(data->attrs);\n  data->attrdata = solv_free(data->attrdata);\n  data->attriddata = solv_free(data->attriddata);\n  data->attrnum64data = solv_free(data->attrnum64data);\n  data->attrdatalen = 0;\n  data->attriddatalen = 0;\n  data->attrnum64datalen = 0;\n#if 0\n  printf(\"repodata_internalize %d done\\n\", data->repodataid);\n  printf(\"  incore data: %d K\\n\", data->incoredatalen / 1024);\n#endif\n}\n\nvoid\nrepodata_disable_paging(Repodata *data)\n{\n  if (maybe_load_repodata(data, 0))\n    {\n      repopagestore_disable_paging(&data->store);\n      data->storestate++;\n    }\n}\n\n/* call the pool's loadcallback to load a stub repodata */\nstatic void\nrepodata_stub_loader(Repodata *data)\n{\n  Repo *repo = data->repo;\n  Pool *pool = repo->pool;\n  int r, i;\n  struct s_Pool_tmpspace oldtmpspace;\n  Datapos oldpos;\n\n  if (!pool->loadcallback)\n    {\n      data->state = REPODATA_ERROR;\n      return;\n    }\n  data->state = REPODATA_LOADING;\n\n  /* save tmp space and pos */\n  oldtmpspace = pool->tmpspace;\n  memset(&pool->tmpspace, 0, sizeof(pool->tmpspace));\n  oldpos = pool->pos;\n\n  r = pool->loadcallback(pool, data, pool->loadcallbackdata);\n\n  /* restore tmp space and pos */\n  for (i = 0; i < POOL_TMPSPACEBUF; i++)\n    solv_free(pool->tmpspace.buf[i]);\n  pool->tmpspace = oldtmpspace;\n  if (r && oldpos.repo == repo && oldpos.repodataid == data->repodataid)\n    memset(&oldpos, 0, sizeof(oldpos));\n  pool->pos = oldpos;\n\n  data->state = r ? REPODATA_AVAILABLE : REPODATA_ERROR;\n}\n\nstatic inline void\nrepodata_add_stubkey(Repodata *data, Id keyname, Id keytype)\n{\n  Repokey xkey;\n\n  xkey.name = keyname;\n  xkey.type = keytype;\n  xkey.storage = KEY_STORAGE_INCORE;\n  xkey.size = 0;\n  repodata_key2id(data, &xkey, 1);\n}\n\nstatic Repodata *\nrepodata_add_stub(Repodata **datap)\n{\n  Repodata *data = *datap;\n  Repo *repo = data->repo;\n  Id repodataid = data - repo->repodata;\n  Repodata *sdata = repo_add_repodata(repo, 0);\n  data = repo->repodata + repodataid;\n  if (data->end > data->start)\n    repodata_extend_block(sdata, data->start, data->end - data->start);\n  sdata->state = REPODATA_STUB;\n  sdata->loadcallback = repodata_stub_loader;\n  *datap = data;\n  return sdata;\n}\n\nRepodata *\nrepodata_create_stubs(Repodata *data)\n{\n  Repo *repo = data->repo;\n  Pool *pool = repo->pool;\n  Repodata *sdata;\n  int *stubdataids;\n  Dataiterator di;\n  Id xkeyname = 0;\n  int i, cnt = 0;\n\n  dataiterator_init(&di, pool, repo, SOLVID_META, REPOSITORY_EXTERNAL, 0, 0);\n  while (dataiterator_step(&di))\n    if (di.data == data)\n      cnt++;\n  dataiterator_free(&di);\n  if (!cnt)\n    return data;\n  stubdataids = solv_calloc(cnt, sizeof(*stubdataids));\n  for (i = 0; i < cnt; i++)\n    {\n      sdata = repodata_add_stub(&data);\n      stubdataids[i] = sdata - repo->repodata;\n    }\n  i = 0;\n  dataiterator_init(&di, pool, repo, SOLVID_META, REPOSITORY_EXTERNAL, 0, 0);\n  sdata = 0;\n  while (dataiterator_step(&di))\n    {\n      if (di.data != data)\n\tcontinue;\n      if (di.key->name == REPOSITORY_EXTERNAL && !di.nparents)\n\t{\n\t  dataiterator_entersub(&di);\n\t  sdata = repo->repodata + stubdataids[i++];\n\t  xkeyname = 0;\n\t  continue;\n\t}\n      repodata_set_kv(sdata, SOLVID_META, di.key->name, di.key->type, &di.kv);\n      if (di.key->name == REPOSITORY_KEYS && di.key->type == REPOKEY_TYPE_IDARRAY)\n\t{\n\t  if (!xkeyname)\n\t    {\n\t      if (!di.kv.eof)\n\t\txkeyname = di.kv.id;\n\t    }\n\t  else\n\t    {\n\t      repodata_add_stubkey(sdata, xkeyname, di.kv.id);\n\t      if (xkeyname == SOLVABLE_FILELIST)\n\t        repodata_set_filelisttype(sdata, REPODATA_FILELIST_EXTENSION);\n\t      xkeyname = 0;\n\t    }\n\t}\n    }\n  dataiterator_free(&di);\n  for (i = 0; i < cnt; i++)\n    repodata_internalize(repo->repodata + stubdataids[i]);\n  solv_free(stubdataids);\n  return data;\n}\n\nvoid\nrepodata_set_filelisttype(Repodata *data, int type)\n{\n  data->filelisttype = type;\n}\n\nunsigned int\nrepodata_memused(Repodata *data)\n{\n  return data->incoredatalen + data->vincorelen;\n}\n\n"], "fixing_code": ["/*\n * Copyright (c) 2018, SUSE LLC.\n *\n * This program is licensed under the BSD license, read LICENSE.BSD\n * for further information\n */\n\n/*\n * repodata.c\n *\n * Manage data coming from one repository\n *\n * a repository can contain multiple repodata entries, consisting of\n * different sets of keys and different sets of solvables\n */\n\n#define _GNU_SOURCE\n#include <string.h>\n#include <fnmatch.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <assert.h>\n#include <regex.h>\n\n#include \"repo.h\"\n#include \"pool.h\"\n#include \"poolid_private.h\"\n#include \"util.h\"\n#include \"hash.h\"\n#include \"chksum.h\"\n\n#include \"repopack.h\"\n#include \"repopage.h\"\n\n#ifdef _WIN32\n  #include \"strfncs.h\"\n#endif\n\n#define REPODATA_BLOCK 255\n\nstatic unsigned char *data_skip_key(Repodata *data, unsigned char *dp, Repokey *key);\n\nvoid\nrepodata_initdata(Repodata *data, Repo *repo, int localpool)\n{\n  memset(data, 0, sizeof (*data));\n  data->repodataid = data - repo->repodata;\n  data->repo = repo;\n  data->localpool = localpool;\n  if (localpool)\n    stringpool_init_empty(&data->spool);\n  /* dirpool_init(&data->dirpool);\tjust zeros out again */\n  data->keys = solv_calloc(1, sizeof(Repokey));\n  data->nkeys = 1;\n  data->schemata = solv_calloc(1, sizeof(Id));\n  data->schemadata = solv_calloc(1, sizeof(Id));\n  data->nschemata = 1;\n  data->schemadatalen = 1;\n  repopagestore_init(&data->store);\n}\n\nvoid\nrepodata_freedata(Repodata *data)\n{\n  int i;\n\n  solv_free(data->keys);\n\n  solv_free(data->schemata);\n  solv_free(data->schemadata);\n  solv_free(data->schematahash);\n\n  stringpool_free(&data->spool);\n  dirpool_free(&data->dirpool);\n\n  solv_free(data->mainschemaoffsets);\n  solv_free(data->incoredata);\n  solv_free(data->incoreoffset);\n  solv_free(data->verticaloffset);\n\n  repopagestore_free(&data->store);\n\n  solv_free(data->vincore);\n\n  if (data->attrs)\n    for (i = 0; i < data->end - data->start; i++)\n      solv_free(data->attrs[i]);\n  solv_free(data->attrs);\n  if (data->xattrs)\n    for (i = 0; i < data->nxattrs; i++)\n      solv_free(data->xattrs[i]);\n  solv_free(data->xattrs);\n\n  solv_free(data->attrdata);\n  solv_free(data->attriddata);\n  solv_free(data->attrnum64data);\n\n  solv_free(data->dircache);\n\n  repodata_free_filelistfilter(data);\n}\n\nvoid\nrepodata_free(Repodata *data)\n{\n  Repo *repo = data->repo;\n  int i = data - repo->repodata;\n  if (i == 0)\n    return;\n  repodata_freedata(data);\n  if (i < repo->nrepodata - 1)\n    {\n      /* whoa! this changes the repodataids! */\n      memmove(repo->repodata + i, repo->repodata + i + 1, (repo->nrepodata - 1 - i) * sizeof(Repodata));\n      for (; i < repo->nrepodata - 1; i++)\n\trepo->repodata[i].repodataid = i;\n    }\n  repo->nrepodata--;\n  if (repo->nrepodata == 1)\n    {\n      repo->repodata = solv_free(repo->repodata);\n      repo->nrepodata = 0;\n    }\n}\n\nvoid\nrepodata_empty(Repodata *data, int localpool)\n{\n  void (*loadcallback)(Repodata *) = data->loadcallback;\n  int state = data->state;\n  repodata_freedata(data);\n  repodata_initdata(data, data->repo, localpool);\n  data->state = state;\n  data->loadcallback = loadcallback;\n}\n\n\n/***************************************************************\n * key pool management\n */\n\n/* this is not so time critical that we need a hash, so we do a simple\n * linear search */\nId\nrepodata_key2id(Repodata *data, Repokey *key, int create)\n{\n  Id keyid;\n\n  for (keyid = 1; keyid < data->nkeys; keyid++)\n    if (data->keys[keyid].name == key->name && data->keys[keyid].type == key->type)\n      {\n        if ((key->type == REPOKEY_TYPE_CONSTANT || key->type == REPOKEY_TYPE_CONSTANTID) && key->size != data->keys[keyid].size)\n          continue;\n        break;\n      }\n  if (keyid == data->nkeys)\n    {\n      if (!create)\n\treturn 0;\n      /* allocate new key */\n      data->keys = solv_realloc2(data->keys, data->nkeys + 1, sizeof(Repokey));\n      data->keys[data->nkeys++] = *key;\n      if (data->verticaloffset)\n        {\n          data->verticaloffset = solv_realloc2(data->verticaloffset, data->nkeys, sizeof(Id));\n          data->verticaloffset[data->nkeys - 1] = 0;\n        }\n      data->keybits[(key->name >> 3) & (sizeof(data->keybits) - 1)] |= 1 << (key->name & 7);\n    }\n  return keyid;\n}\n\n\n/***************************************************************\n * schema pool management\n */\n\n#define SCHEMATA_BLOCK 31\n#define SCHEMATADATA_BLOCK 255\n\nId\nrepodata_schema2id(Repodata *data, Id *schema, int create)\n{\n  int h, len, i;\n  Id *sp, cid;\n  Id *schematahash;\n\n  if (!*schema)\n    return 0;\t/* XXX: allow empty schema? */\n  if ((schematahash = data->schematahash) == 0)\n    {\n      data->schematahash = schematahash = solv_calloc(256, sizeof(Id));\n      for (i = 1; i < data->nschemata; i++)\n\t{\n\t  for (sp = data->schemadata + data->schemata[i], h = 0; *sp;)\n\t    h = h * 7 + *sp++;\n\t  h &= 255;\n\t  schematahash[h] = i;\n\t}\n      data->schemadata = solv_extend_resize(data->schemadata, data->schemadatalen, sizeof(Id), SCHEMATADATA_BLOCK);\n      data->schemata = solv_extend_resize(data->schemata, data->nschemata, sizeof(Id), SCHEMATA_BLOCK);\n    }\n\n  for (sp = schema, len = 0, h = 0; *sp; len++)\n    h = h * 7 + *sp++;\n  h &= 255;\n  len++;\n\n  cid = schematahash[h];\n  if (cid)\n    {\n      if ((data->schemata[cid] + len <= data->schemadatalen) &&\n\t\t\t  !memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n        return cid;\n      /* cache conflict, do a slow search */\n      for (cid = 1; cid < data->nschemata; cid++)\n        if ((data->schemata[cid] + len <= data->schemadatalen) &&\n\t\t\t\t!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n          return cid;\n    }\n  /* a new one */\n  if (!create)\n    return 0;\n  data->schemadata = solv_extend(data->schemadata, data->schemadatalen, len, sizeof(Id), SCHEMATADATA_BLOCK);\n  data->schemata = solv_extend(data->schemata, data->nschemata, 1, sizeof(Id), SCHEMATA_BLOCK);\n  /* add schema */\n  memcpy(data->schemadata + data->schemadatalen, schema, len * sizeof(Id));\n  data->schemata[data->nschemata] = data->schemadatalen;\n  data->schemadatalen += len;\n  schematahash[h] = data->nschemata;\n#if 0\nfprintf(stderr, \"schema2id: new schema\\n\");\n#endif\n  return data->nschemata++;\n}\n\nvoid\nrepodata_free_schemahash(Repodata *data)\n{\n  data->schematahash = solv_free(data->schematahash);\n  /* shrink arrays */\n  data->schemata = solv_realloc2(data->schemata, data->nschemata, sizeof(Id));\n  data->schemadata = solv_realloc2(data->schemadata, data->schemadatalen, sizeof(Id));\n}\n\n\n/***************************************************************\n * dir pool management\n */\n\n#ifndef HAVE_STRCHRNUL\nstatic inline const char *strchrnul(const char *str, char x)\n{\n  const char *p = strchr(str, x);\n  return p ? p : str + strlen(str);\n}\n#endif\n\n#define DIRCACHE_SIZE 41\t/* < 1k */\n\n#ifdef DIRCACHE_SIZE\nstruct dircache {\n  Id ids[DIRCACHE_SIZE];\n  char str[(DIRCACHE_SIZE * (DIRCACHE_SIZE - 1)) / 2];\n};\n#endif\n\nId\nrepodata_str2dir(Repodata *data, const char *dir, int create)\n{\n  Id id, parent;\n#ifdef DIRCACHE_SIZE\n  const char *dirs;\n#endif\n  const char *dire;\n\n  if (!*dir)\n    return data->dirpool.ndirs ? 0 : dirpool_add_dir(&data->dirpool, 0, 0, create);\n  while (*dir == '/' && dir[1] == '/')\n    dir++;\n  if (*dir == '/' && !dir[1])\n    return data->dirpool.ndirs ? 1 : dirpool_add_dir(&data->dirpool, 0, 1, create);\n  parent = 0;\n#ifdef DIRCACHE_SIZE\n  dirs = dir;\n  if (data->dircache)\n    {\n      int l;\n      struct dircache *dircache = data->dircache;\n      l = strlen(dir);\n      while (l > 0)\n\t{\n\t  if (l < DIRCACHE_SIZE && dircache->ids[l] && !memcmp(dircache->str + l * (l - 1) / 2, dir, l))\n\t    {\n\t      parent = dircache->ids[l];\n\t      dir += l;\n\t      if (!*dir)\n\t\treturn parent;\n\t      while (*dir == '/')\n\t\tdir++;\n\t      break;\n\t    }\n\t  while (--l)\n\t    if (dir[l] == '/')\n\t      break;\n\t}\n    }\n#endif\n  while (*dir)\n    {\n      dire = strchrnul(dir, '/');\n      if (data->localpool)\n        id = stringpool_strn2id(&data->spool, dir, dire - dir, create);\n      else\n\tid = pool_strn2id(data->repo->pool, dir, dire - dir, create);\n      if (!id)\n\treturn 0;\n      parent = dirpool_add_dir(&data->dirpool, parent, id, create);\n      if (!parent)\n\treturn 0;\n#ifdef DIRCACHE_SIZE\n      if (!data->dircache)\n\tdata->dircache = solv_calloc(1, sizeof(struct dircache));\n      if (data->dircache)\n\t{\n\t  int l = dire - dirs;\n\t  if (l < DIRCACHE_SIZE)\n\t    {\n\t      data->dircache->ids[l] = parent;\n\t      memcpy(data->dircache->str + l * (l - 1) / 2, dirs, l);\n\t    }\n\t}\n#endif\n      if (!*dire)\n\tbreak;\n      dir = dire + 1;\n      while (*dir == '/')\n\tdir++;\n    }\n  return parent;\n}\n\nvoid\nrepodata_free_dircache(Repodata *data)\n{\n  data->dircache = solv_free(data->dircache);\n}\n\nconst char *\nrepodata_dir2str(Repodata *data, Id did, const char *suf)\n{\n  Pool *pool = data->repo->pool;\n  int l = 0;\n  Id parent, comp;\n  const char *comps;\n  char *p;\n\n  if (!did)\n    return suf ? suf : \"\";\n  if (did == 1 && !suf)\n    return \"/\";\n  parent = did;\n  while (parent)\n    {\n      comp = dirpool_compid(&data->dirpool, parent);\n      comps = stringpool_id2str(data->localpool ? &data->spool : &pool->ss, comp);\n      l += strlen(comps);\n      parent = dirpool_parent(&data->dirpool, parent);\n      if (parent)\n\tl++;\n    }\n  if (suf)\n    l += strlen(suf) + 1;\n  p = pool_alloctmpspace(pool, l + 1) + l;\n  *p = 0;\n  if (suf)\n    {\n      p -= strlen(suf);\n      strcpy(p, suf);\n      *--p = '/';\n    }\n  parent = did;\n  while (parent)\n    {\n      comp = dirpool_compid(&data->dirpool, parent);\n      comps = stringpool_id2str(data->localpool ? &data->spool : &pool->ss, comp);\n      l = strlen(comps);\n      p -= l;\n      strncpy(p, comps, l);\n      parent = dirpool_parent(&data->dirpool, parent);\n      if (parent)\n        *--p = '/';\n    }\n  return p;\n}\n\n\n/***************************************************************\n * data management\n */\n\nstatic inline unsigned char *\ndata_skip_schema(Repodata *data, unsigned char *dp, Id schema)\n{\n  Id *keyp = data->schemadata + data->schemata[schema];\n  for (; *keyp; keyp++)\n    dp = data_skip_key(data, dp, data->keys + *keyp);\n  return dp;\n}\n\nstatic unsigned char *\ndata_skip_key(Repodata *data, unsigned char *dp, Repokey *key)\n{\n  int nentries, schema;\n  switch(key->type)\n    {\n    case REPOKEY_TYPE_FIXARRAY:\n      dp = data_read_id(dp, &nentries);\n      if (!nentries)\n\treturn dp;\n      dp = data_read_id(dp, &schema);\n      while (nentries--)\n\tdp = data_skip_schema(data, dp, schema);\n      return dp;\n    case REPOKEY_TYPE_FLEXARRAY:\n      dp = data_read_id(dp, &nentries);\n      while (nentries--)\n\t{\n\t  dp = data_read_id(dp, &schema);\n\t  dp = data_skip_schema(data, dp, schema);\n\t}\n      return dp;\n    default:\n      if (key->storage == KEY_STORAGE_INCORE)\n        dp = data_skip(dp, key->type);\n      else if (key->storage == KEY_STORAGE_VERTICAL_OFFSET)\n\t{\n\t  dp = data_skip(dp, REPOKEY_TYPE_ID);\n\t  dp = data_skip(dp, REPOKEY_TYPE_ID);\n\t}\n      return dp;\n    }\n}\n\nstatic unsigned char *\nforward_to_key(Repodata *data, Id keyid, Id *keyp, unsigned char *dp)\n{\n  Id k;\n\n  if (!keyid)\n    return 0;\n  if (data->mainschemaoffsets && dp == data->incoredata + data->mainschemaoffsets[0] && keyp == data->schemadata + data->schemata[data->mainschema])\n    {\n      int i;\n      for (i = 0; (k = *keyp++) != 0; i++)\n        if (k == keyid)\n\t  return data->incoredata + data->mainschemaoffsets[i];\n      return 0;\n    }\n  while ((k = *keyp++) != 0)\n    {\n      if (k == keyid)\n\treturn dp;\n      if (data->keys[k].storage == KEY_STORAGE_VERTICAL_OFFSET)\n\t{\n\t  dp = data_skip(dp, REPOKEY_TYPE_ID);\t/* skip offset */\n\t  dp = data_skip(dp, REPOKEY_TYPE_ID);\t/* skip length */\n\t  continue;\n\t}\n      if (data->keys[k].storage != KEY_STORAGE_INCORE)\n\tcontinue;\n      dp = data_skip_key(data, dp, data->keys + k);\n    }\n  return 0;\n}\n\nstatic unsigned char *\nget_vertical_data(Repodata *data, Repokey *key, Id off, Id len)\n{\n  unsigned char *dp;\n  if (len <= 0)\n    return 0;\n  if (off >= data->lastverticaloffset)\n    {\n      off -= data->lastverticaloffset;\n      if ((unsigned int)off + len > data->vincorelen)\n\treturn 0;\n      return data->vincore + off;\n    }\n  if ((unsigned int)off + len > key->size)\n    return 0;\n  /* we now have the offset, go into vertical */\n  off += data->verticaloffset[key - data->keys];\n  /* fprintf(stderr, \"key %d page %d\\n\", key->name, off / REPOPAGE_BLOBSIZE); */\n  dp = repopagestore_load_page_range(&data->store, off / REPOPAGE_BLOBSIZE, (off + len - 1) / REPOPAGE_BLOBSIZE);\n  data->storestate++;\n  if (dp)\n    dp += off % REPOPAGE_BLOBSIZE;\n  return dp;\n}\n\nstatic inline unsigned char *\nget_data(Repodata *data, Repokey *key, unsigned char **dpp, int advance)\n{\n  unsigned char *dp = *dpp;\n\n  if (!dp)\n    return 0;\n  if (key->storage == KEY_STORAGE_INCORE)\n    {\n      if (advance)\n        *dpp = data_skip_key(data, dp, key);\n      return dp;\n    }\n  else if (key->storage == KEY_STORAGE_VERTICAL_OFFSET)\n    {\n      Id off, len;\n      dp = data_read_id(dp, &off);\n      dp = data_read_id(dp, &len);\n      if (advance)\n        *dpp = dp;\n      return get_vertical_data(data, key, off, len);\n    }\n  return 0;\n}\n\nvoid\nrepodata_load(Repodata *data)\n{\n  if (data->state != REPODATA_STUB)\n    return;\n  if (data->loadcallback)\n    data->loadcallback(data);\n  else\n    data->state = REPODATA_ERROR;\n}\n\nstatic int\nmaybe_load_repodata_stub(Repodata *data, Id keyname)\n{\n  if (data->state != REPODATA_STUB)\n    {\n      data->state = REPODATA_ERROR;\n      return 0;\n    }\n  if (keyname)\n    {\n      int i;\n      for (i = 1; i < data->nkeys; i++)\n\tif (keyname == data->keys[i].name)\n\t  break;\n      if (i == data->nkeys)\n\treturn 0;\n    }\n  repodata_load(data);\n  return data->state == REPODATA_AVAILABLE ? 1 : 0;\n}\n\nstatic inline int\nmaybe_load_repodata(Repodata *data, Id keyname)\n{\n  if (keyname && !repodata_precheck_keyname(data, keyname))\n    return 0;\t/* do not bother... */\n  if (data->state == REPODATA_AVAILABLE || data->state == REPODATA_LOADING)\n    return 1;\n  if (data->state == REPODATA_ERROR)\n    return 0;\n  return maybe_load_repodata_stub(data, keyname);\n}\n\nstatic inline unsigned char *\nsolvid2data(Repodata *data, Id solvid, Id *schemap)\n{\n  unsigned char *dp = data->incoredata;\n  if (!dp)\n    return 0;\n  if (solvid == SOLVID_META)\n    dp += 1;\t/* offset of \"meta\" solvable */\n  else if (solvid == SOLVID_POS)\n    {\n      Pool *pool = data->repo->pool;\n      if (data->repo != pool->pos.repo)\n\treturn 0;\n      if (data != data->repo->repodata + pool->pos.repodataid)\n\treturn 0;\n      dp += pool->pos.dp;\n      if (pool->pos.dp != 1)\n        {\n          *schemap = pool->pos.schema;\n          return dp;\n\t}\n    }\n  else\n    {\n      if (solvid < data->start || solvid >= data->end)\n\treturn 0;\n      dp += data->incoreoffset[solvid - data->start];\n    }\n  return data_read_id(dp, schemap);\n}\n\n/************************************************************************\n * data lookup\n */\n\nstatic unsigned char *\nfind_key_data(Repodata *data, Id solvid, Id keyname, Repokey **keypp)\n{\n  unsigned char *dp;\n  Id schema, *keyp, *kp;\n  Repokey *key;\n\n  if (!maybe_load_repodata(data, keyname))\n    return 0;\n  dp = solvid2data(data, solvid, &schema);\n  if (!dp)\n    return 0;\n  keyp = data->schemadata + data->schemata[schema];\n  for (kp = keyp; *kp; kp++)\n    if (data->keys[*kp].name == keyname)\n      break;\n  if (!*kp)\n    return 0;\n  *keypp = key = data->keys + *kp;\n  if (key->type == REPOKEY_TYPE_DELETED)\n    return 0;\n  if (key->type == REPOKEY_TYPE_VOID || key->type == REPOKEY_TYPE_CONSTANT || key->type == REPOKEY_TYPE_CONSTANTID)\n    return dp;\t/* no need to forward... */\n  if (key->storage != KEY_STORAGE_INCORE && key->storage != KEY_STORAGE_VERTICAL_OFFSET)\n    return 0;\t/* get_data will not work, no need to forward */\n  dp = forward_to_key(data, *kp, keyp, dp);\n  if (!dp)\n    return 0;\n  return get_data(data, key, &dp, 0);\n}\n\nstatic const Id *\nrepodata_lookup_schemakeys(Repodata *data, Id solvid)\n{\n  Id schema;\n  if (!maybe_load_repodata(data, 0))\n    return 0;\n  if (!solvid2data(data, solvid, &schema))\n    return 0;\n  return data->schemadata + data->schemata[schema];\n}\n\nstatic Id *\nalloc_keyskip()\n{\n  Id *keyskip = solv_calloc(3 + 256, sizeof(Id));\n  keyskip[0] = 256; \n  keyskip[1] = keyskip[2] = 1; \n  return keyskip;\n}\n\nId *\nrepodata_fill_keyskip(Repodata *data, Id solvid, Id *keyskip)\n{\n  const Id *keyp;\n  Id maxkeyname, value;\n  keyp = repodata_lookup_schemakeys(data, solvid);\n  if (!keyp)\n    return keyskip;\t/* no keys for this solvid */\n  if (!keyskip)\n    keyskip = alloc_keyskip();\n  maxkeyname = keyskip[0];\n  value = keyskip[1] + data->repodataid;\n  for (; *keyp; keyp++)\n    {\n      Id keyname = data->keys[*keyp].name;\n      if (keyname >= maxkeyname)\n\t{\n\t  int newmax = (keyname | 255) + 1; \n\t  keyskip = solv_realloc2(keyskip, 3 + newmax, sizeof(Id));\n\t  memset(keyskip + (3 + maxkeyname), 0, (newmax - maxkeyname) * sizeof(Id));\n\t  keyskip[0] = maxkeyname = newmax;\n\t}\n      keyskip[3 + keyname] = value;\n    }\n  return keyskip;\n}\n\nId\nrepodata_lookup_type(Repodata *data, Id solvid, Id keyname)\n{\n  Id schema, *keyp, *kp;\n  if (!maybe_load_repodata(data, keyname))\n    return 0;\n  if (!solvid2data(data, solvid, &schema))\n    return 0;\n  keyp = data->schemadata + data->schemata[schema];\n  for (kp = keyp; *kp; kp++)\n    if (data->keys[*kp].name == keyname)\n      return data->keys[*kp].type;\n  return 0;\n}\n\nId\nrepodata_lookup_id(Repodata *data, Id solvid, Id keyname)\n{\n  unsigned char *dp;\n  Repokey *key;\n  Id id;\n\n  dp = find_key_data(data, solvid, keyname, &key);\n  if (!dp)\n    return 0;\n  if (key->type == REPOKEY_TYPE_CONSTANTID)\n    return key->size;\n  if (key->type != REPOKEY_TYPE_ID)\n    return 0;\n  dp = data_read_id(dp, &id);\n  return id;\n}\n\nconst char *\nrepodata_lookup_str(Repodata *data, Id solvid, Id keyname)\n{\n  unsigned char *dp;\n  Repokey *key;\n  Id id;\n\n  dp = find_key_data(data, solvid, keyname, &key);\n  if (!dp)\n    return 0;\n  if (key->type == REPOKEY_TYPE_STR)\n    return (const char *)dp;\n  if (key->type == REPOKEY_TYPE_CONSTANTID)\n    id = key->size;\n  else if (key->type == REPOKEY_TYPE_ID)\n    dp = data_read_id(dp, &id);\n  else\n    return 0;\n  if (data->localpool)\n    return stringpool_id2str(&data->spool, id);\n  return pool_id2str(data->repo->pool, id);\n}\n\nunsigned long long\nrepodata_lookup_num(Repodata *data, Id solvid, Id keyname, unsigned long long notfound)\n{\n  unsigned char *dp;\n  Repokey *key;\n  unsigned int high, low;\n\n  dp = find_key_data(data, solvid, keyname, &key);\n  if (!dp)\n    return notfound;\n  switch (key->type)\n    {\n    case REPOKEY_TYPE_NUM:\n      data_read_num64(dp, &low, &high);\n      return (unsigned long long)high << 32 | low;\n    case REPOKEY_TYPE_CONSTANT:\n      return key->size;\n    default:\n      return notfound;\n    }\n}\n\nint\nrepodata_lookup_void(Repodata *data, Id solvid, Id keyname)\n{\n  return repodata_lookup_type(data, solvid, keyname) == REPOKEY_TYPE_VOID ? 1 : 0;\n}\n\nconst unsigned char *\nrepodata_lookup_bin_checksum(Repodata *data, Id solvid, Id keyname, Id *typep)\n{\n  unsigned char *dp;\n  Repokey *key;\n\n  dp = find_key_data(data, solvid, keyname, &key);\n  if (!dp)\n    return 0;\n  switch (key->type)\n    {\n    case_CHKSUM_TYPES:\n      break;\n    default:\n      return 0;\n    }\n  *typep = key->type;\n  return dp;\n}\n\nint\nrepodata_lookup_idarray(Repodata *data, Id solvid, Id keyname, Queue *q)\n{\n  unsigned char *dp;\n  Repokey *key;\n  Id id;\n  int eof = 0;\n\n  queue_empty(q);\n  dp = find_key_data(data, solvid, keyname, &key);\n  if (!dp)\n    return 0;\n  switch (key->type)\n    {\n    case REPOKEY_TYPE_CONSTANTID:\n      queue_push(q, key->size);\n      break;\n    case REPOKEY_TYPE_ID:\n      dp = data_read_id(dp, &id);\n      queue_push(q, id);\n      break;\n    case REPOKEY_TYPE_IDARRAY:\n      for (;;)\n\t{\n\t  dp = data_read_ideof(dp, &id, &eof);\n\t  queue_push(q, id);\n\t  if (eof)\n\t    break;\n\t}\n      break;\n    default:\n      return 0;\n    }\n  return 1;\n}\n\nconst void *\nrepodata_lookup_binary(Repodata *data, Id solvid, Id keyname, int *lenp)\n{\n  unsigned char *dp;\n  Repokey *key;\n  Id len;\n\n  dp = find_key_data(data, solvid, keyname, &key);\n  if (!dp || key->type != REPOKEY_TYPE_BINARY)\n    {\n      *lenp = 0;\n      return 0;\n    }\n  dp = data_read_id(dp, &len);\n  *lenp = len;\n  return dp;\n}\n\n/* highly specialized function to speed up fileprovides adding.\n * - repodata must be available\n * - solvid must be >= data->start and < data->end\n * - returns NULL is not found, a \"\" entry if wrong type\n * - also returns wrong type for REPOKEY_TYPE_DELETED\n */\nconst unsigned char *\nrepodata_lookup_packed_dirstrarray(Repodata *data, Id solvid, Id keyname)\n{\n  static unsigned char wrongtype[2] = { 0x00 /* dir id 0 */, 0 /* \"\" */ };\n  unsigned char *dp;\n  Id schema, *keyp, *kp;\n  Repokey *key;\n\n  if (!data->incoredata || !data->incoreoffset[solvid - data->start])\n    return 0;\n  dp = data->incoredata + data->incoreoffset[solvid - data->start];\n  dp = data_read_id(dp, &schema);\n  keyp = data->schemadata + data->schemata[schema];\n  for (kp = keyp; *kp; kp++)\n    if (data->keys[*kp].name == keyname)\n      break;\n  if (!*kp)\n    return 0;\n  key = data->keys + *kp;\n  if (key->type != REPOKEY_TYPE_DIRSTRARRAY)\n    return wrongtype;\n  dp = forward_to_key(data, *kp, keyp, dp);\n  if (key->storage == KEY_STORAGE_INCORE)\n    return dp;\n  if (key->storage == KEY_STORAGE_VERTICAL_OFFSET && dp)\n    {\n      Id off, len;\n      dp = data_read_id(dp, &off);\n      data_read_id(dp, &len);\n      return get_vertical_data(data, key, off, len);\n    }\n  return 0;\n}\n\n/* id translation functions */\n\nId\nrepodata_globalize_id(Repodata *data, Id id, int create)\n{\n  if (!id || !data || !data->localpool)\n    return id;\n  return pool_str2id(data->repo->pool, stringpool_id2str(&data->spool, id), create);\n}\n\nId\nrepodata_localize_id(Repodata *data, Id id, int create)\n{\n  if (!id || !data || !data->localpool)\n    return id;\n  return stringpool_str2id(&data->spool, pool_id2str(data->repo->pool, id), create);\n}\n\nId\nrepodata_translate_id(Repodata *data, Repodata *fromdata, Id id, int create)\n{\n  const char *s;\n  if (!id || !data || !fromdata)\n    return id;\n  if (data == fromdata || (!data->localpool && !fromdata->localpool))\n    return id;\n  if (fromdata->localpool)\n    s = stringpool_id2str(&fromdata->spool, id);\n  else\n    s = pool_id2str(data->repo->pool, id);\n  if (data->localpool)\n    return stringpool_str2id(&data->spool, s, create);\n  else\n    return pool_str2id(data->repo->pool, s, create);\n}\n\nId\nrepodata_translate_dir_slow(Repodata *data, Repodata *fromdata, Id dir, int create, Id *cache)\n{\n  Id parent, compid;\n  if (!dir)\n    {\n      /* make sure that the dirpool has an entry */\n      if (create && !data->dirpool.ndirs)\n        dirpool_add_dir(&data->dirpool, 0, 0, create);\n      return 0;\n    }\n  parent = dirpool_parent(&fromdata->dirpool, dir);\n  if (parent)\n    {\n      if (!(parent = repodata_translate_dir(data, fromdata, parent, create, cache)))\n\treturn 0;\n    }\n  compid = dirpool_compid(&fromdata->dirpool, dir);\n  if (compid > 1 && (data->localpool || fromdata->localpool))\n    {\n      if (!(compid = repodata_translate_id(data, fromdata, compid, create)))\n\treturn 0;\n    }\n  if (!(compid = dirpool_add_dir(&data->dirpool, parent, compid, create)))\n    return 0;\n  if (cache)\n    {\n      cache[(dir & 255) * 2] = dir;\n      cache[(dir & 255) * 2 + 1] = compid;\n    }\n  return compid;\n}\n\n/************************************************************************\n * uninternalized lookup / search\n */\n\nstatic void\ndata_fetch_uninternalized(Repodata *data, Repokey *key, Id value, KeyValue *kv)\n{\n  Id *array;\n  kv->eof = 1;\n  switch (key->type)\n    {\n    case REPOKEY_TYPE_STR:\n      kv->str = (const char *)data->attrdata + value;\n      return;\n    case REPOKEY_TYPE_CONSTANT:\n      kv->num2 = 0;\n      kv->num = key->size;\n      return;\n    case REPOKEY_TYPE_CONSTANTID:\n      kv->id = key->size;\n      return;\n    case REPOKEY_TYPE_NUM:\n      kv->num2 = 0;\n      kv->num = value;\n      if (value & 0x80000000)\n\t{\n\t  kv->num = (unsigned int)data->attrnum64data[value ^ 0x80000000];\n\t  kv->num2 = (unsigned int)(data->attrnum64data[value ^ 0x80000000] >> 32);\n\t}\n      return;\n    case_CHKSUM_TYPES:\n      kv->num = 0;\t/* not stringified */\n      kv->str = (const char *)data->attrdata + value;\n      return;\n    case REPOKEY_TYPE_BINARY:\n      kv->str = (const char *)data_read_id(data->attrdata + value, (Id *)&kv->num);\n      return;\n    case REPOKEY_TYPE_IDARRAY:\n      array = data->attriddata + (value + kv->entry);\n      kv->id = array[0];\n      kv->eof = array[1] ? 0 : 1;\n      return;\n    case REPOKEY_TYPE_DIRSTRARRAY:\n      kv->num = 0;\t/* not stringified */\n      array = data->attriddata + (value + kv->entry * 2);\n      kv->id = array[0];\n      kv->str = (const char *)data->attrdata + array[1];\n      kv->eof = array[2] ? 0 : 1;\n      return;\n    case REPOKEY_TYPE_DIRNUMNUMARRAY:\n      array = data->attriddata + (value + kv->entry * 3);\n      kv->id = array[0];\n      kv->num = array[1];\n      kv->num2 = array[2];\n      kv->eof = array[3] ? 0 : 1;\n      return;\n    case REPOKEY_TYPE_FIXARRAY:\n    case REPOKEY_TYPE_FLEXARRAY:\n      array = data->attriddata + (value + kv->entry);\n      kv->id = array[0];\t\t/* the handle */\n      kv->eof = array[1] ? 0 : 1;\n      return;\n    default:\n      kv->id = value;\n      return;\n    }\n}\n\nRepokey *\nrepodata_lookup_kv_uninternalized(Repodata *data, Id solvid, Id keyname, KeyValue *kv)\n{\n  Id *ap;\n  if (!data->attrs || solvid < data->start || solvid >= data->end)\n    return 0;\n  ap = data->attrs[solvid - data->start];\n  if (!ap)\n    return 0;\n  for (; *ap; ap += 2)\n    {\n      Repokey *key = data->keys + *ap;\n      if (key->name != keyname)\n\tcontinue;\n      data_fetch_uninternalized(data, key, ap[1], kv);\n      return key;\n    }\n  return 0;\n}\n\nvoid\nrepodata_search_uninternalized(Repodata *data, Id solvid, Id keyname, int flags, int (*callback)(void *cbdata, Solvable *s, Repodata *data, Repokey *key, KeyValue *kv), void *cbdata)\n{\n  Id *ap;\n  int stop;\n  Solvable *s;\n  KeyValue kv;\n\n  if (!data->attrs || solvid < data->start || solvid >= data->end)\n    return;\n  ap = data->attrs[solvid - data->start];\n  if (!ap)\n    return;\n  for (; *ap; ap += 2)\n    {\n      Repokey *key = data->keys + *ap;\n      if (keyname && key->name != keyname)\n\tcontinue;\n      s = solvid > 0 ? data->repo->pool->solvables + solvid : 0;\n      kv.entry = 0;\n      do\n\t{\n\t  data_fetch_uninternalized(data, key, ap[1], &kv);\n\t  stop = callback(cbdata, s, data, key, &kv);\n\t  kv.entry++;\n\t}\n      while (!kv.eof && !stop);\n      if (keyname || stop > SEARCH_NEXT_KEY)\n\treturn;\n    }\n}\n\n/************************************************************************\n * data search\n */\n\n\nconst char *\nrepodata_stringify(Pool *pool, Repodata *data, Repokey *key, KeyValue *kv, int flags)\n{\n  switch (key->type)\n    {\n    case REPOKEY_TYPE_ID:\n    case REPOKEY_TYPE_CONSTANTID:\n    case REPOKEY_TYPE_IDARRAY:\n      if (data && data->localpool)\n\tkv->str = stringpool_id2str(&data->spool, kv->id);\n      else\n\tkv->str = pool_id2str(pool, kv->id);\n      if ((flags & SEARCH_SKIP_KIND) != 0 && key->storage == KEY_STORAGE_SOLVABLE && (key->name == SOLVABLE_NAME || key->type == REPOKEY_TYPE_IDARRAY))\n\t{\n\t  const char *s;\n\t  for (s = kv->str; *s >= 'a' && *s <= 'z'; s++)\n\t    ;\n\t  if (*s == ':' && s > kv->str)\n\t    kv->str = s + 1;\n\t}\n      return kv->str;\n    case REPOKEY_TYPE_STR:\n      return kv->str;\n    case REPOKEY_TYPE_DIRSTRARRAY:\n      if (!(flags & SEARCH_FILES))\n\treturn kv->str;\t/* match just the basename */\n      if (kv->num)\n\treturn kv->str;\t/* already stringified */\n      /* Put the full filename into kv->str.  */\n      kv->str = repodata_dir2str(data, kv->id, kv->str);\n      kv->num = 1;\t/* mark stringification */\n      return kv->str;\n    case_CHKSUM_TYPES:\n      if (!(flags & SEARCH_CHECKSUMS))\n\treturn 0;\t/* skip em */\n      if (kv->num)\n\treturn kv->str;\t/* already stringified */\n      kv->str = repodata_chk2str(data, key->type, (const unsigned char *)kv->str);\n      kv->num = 1;\t/* mark stringification */\n      return kv->str;\n    default:\n      return 0;\n    }\n}\n\n\n/* this is an internal hack to pass the parent kv to repodata_search_keyskip */\nstruct subschema_data {\n  void *cbdata;\n  Id solvid;\n  KeyValue *parent;\n};\n\nvoid\nrepodata_search_arrayelement(Repodata *data, Id solvid, Id keyname, int flags, KeyValue *kv, int (*callback)(void *cbdata, Solvable *s, Repodata *data, Repokey *key, KeyValue *kv), void *cbdata)\n{\n  repodata_search_keyskip(data, solvid, keyname, flags | SEARCH_SUBSCHEMA, (Id *)kv, callback, cbdata);\n}\n\nstatic int\nrepodata_search_array(Repodata *data, Id solvid, Id keyname, int flags, Repokey *key, KeyValue *kv, int (*callback)(void *cbdata, Solvable *s, Repodata *data, Repokey *key, KeyValue *kv), void *cbdata)\n{\n  Solvable *s = solvid > 0 ? data->repo->pool->solvables + solvid : 0;\n  unsigned char *dp = (unsigned char *)kv->str;\n  int stop;\n  Id schema = 0;\n\n  if (!dp || kv->entry != -1)\n    return 0;\n  while (++kv->entry < (int)kv->num)\n    {\n      if (kv->entry)\n\tdp = data_skip_schema(data, dp, schema);\n      if (kv->entry == 0 || key->type == REPOKEY_TYPE_FLEXARRAY)\n\tdp = data_read_id(dp, &schema);\n      kv->id = schema;\n      kv->str = (const char *)dp;\n      kv->eof = kv->entry == kv->num - 1 ? 1 : 0;\n      stop = callback(cbdata, s, data, key, kv);\n      if (stop && stop != SEARCH_ENTERSUB)\n\treturn stop;\n      if ((flags & SEARCH_SUB) != 0 || stop == SEARCH_ENTERSUB)\n        repodata_search_keyskip(data, solvid, keyname, flags | SEARCH_SUBSCHEMA, (Id *)kv, callback, cbdata);\n    }\n  if ((flags & SEARCH_ARRAYSENTINEL) != 0)\n    {\n      if (kv->entry)\n\tdp = data_skip_schema(data, dp, schema);\n      kv->id = 0;\n      kv->str = (const char *)dp;\n      kv->eof = 2;\n      return callback(cbdata, s, data, key, kv);\n    }\n  return 0;\n}\n\n/* search a specific repodata */\nvoid\nrepodata_search_keyskip(Repodata *data, Id solvid, Id keyname, int flags, Id *keyskip, int (*callback)(void *cbdata, Solvable *s, Repodata *data, Repokey *key, KeyValue *kv), void *cbdata)\n{\n  Id schema;\n  Repokey *key;\n  Id keyid, *kp, *keyp;\n  unsigned char *dp, *ddp;\n  int onekey = 0;\n  int stop;\n  KeyValue kv;\n  Solvable *s;\n\n  if (!maybe_load_repodata(data, keyname))\n    return;\n  if ((flags & SEARCH_SUBSCHEMA) != 0)\n    {\n      flags ^= SEARCH_SUBSCHEMA;\n      kv.parent = (KeyValue *)keyskip;\n      keyskip = 0;\n      schema = kv.parent->id;\n      dp = (unsigned char *)kv.parent->str;\n    }\n  else\n    {\n      schema = 0;\n      dp = solvid2data(data, solvid, &schema);\n      if (!dp)\n\treturn;\n      kv.parent = 0;\n    }\n  s = solvid > 0 ? data->repo->pool->solvables + solvid : 0;\n  keyp = data->schemadata + data->schemata[schema];\n  if (keyname)\n    {\n      /* search for a specific key */\n      for (kp = keyp; *kp; kp++)\n\tif (data->keys[*kp].name == keyname)\n\t  break;\n      if (!*kp)\n\treturn;\n      dp = forward_to_key(data, *kp, keyp, dp);\n      if (!dp)\n\treturn;\n      keyp = kp;\n      onekey = 1;\n    }\n  while ((keyid = *keyp++) != 0)\n    {\n      stop = 0;\n      key = data->keys + keyid;\n      ddp = get_data(data, key, &dp, *keyp && !onekey ? 1 : 0);\n\n      if (keyskip && (key->name >= keyskip[0] || keyskip[3 + key->name] != keyskip[1] + data->repodataid))\n\t{\n\t  if (onekey)\n\t    return;\n\t  continue;\n\t}\n      if (key->type == REPOKEY_TYPE_DELETED && !(flags & SEARCH_KEEP_TYPE_DELETED))\n\t{\n\t  if (onekey)\n\t    return;\n\t  continue;\n\t}\n      if (key->type == REPOKEY_TYPE_FLEXARRAY || key->type == REPOKEY_TYPE_FIXARRAY)\n\t{\n\t  kv.entry = -1;\n\t  ddp = data_read_id(ddp, (Id *)&kv.num);\n\t  kv.str = (const char *)ddp;\n\t  stop = repodata_search_array(data, solvid, 0, flags, key, &kv, callback, cbdata);\n\t  if (onekey || stop > SEARCH_NEXT_KEY)\n\t    return;\n\t  continue;\n\t}\n      kv.entry = 0;\n      do\n\t{\n\t  ddp = data_fetch(ddp, &kv, key);\n\t  if (!ddp)\n\t    break;\n\t  stop = callback(cbdata, s, data, key, &kv);\n\t  kv.entry++;\n\t}\n      while (!kv.eof && !stop);\n      if (onekey || stop > SEARCH_NEXT_KEY)\n\treturn;\n    }\n}\n\nvoid\nrepodata_search(Repodata *data, Id solvid, Id keyname, int flags, int (*callback)(void *cbdata, Solvable *s, Repodata *data, Repokey *key, KeyValue *kv), void *cbdata)\n{\n  repodata_search_keyskip(data, solvid, keyname, flags, 0, callback, cbdata);\n}\n\nvoid\nrepodata_setpos_kv(Repodata *data, KeyValue *kv)\n{\n  Pool *pool = data->repo->pool;\n  if (!kv)\n    pool_clear_pos(pool);\n  else\n    {\n      pool->pos.repo = data->repo;\n      pool->pos.repodataid = data - data->repo->repodata;\n      pool->pos.dp = (unsigned char *)kv->str - data->incoredata;\n      pool->pos.schema = kv->id;\n    }\n}\n\n/************************************************************************\n * data iterator functions\n */\n\nstatic inline Id *\nsolvabledata_fetch(Solvable *s, KeyValue *kv, Id keyname)\n{\n  kv->id = keyname;\n  switch (keyname)\n    {\n    case SOLVABLE_NAME:\n      kv->eof = 1;\n      return &s->name;\n    case SOLVABLE_ARCH:\n      kv->eof = 1;\n      return &s->arch;\n    case SOLVABLE_EVR:\n      kv->eof = 1;\n      return &s->evr;\n    case SOLVABLE_VENDOR:\n      kv->eof = 1;\n      return &s->vendor;\n    case SOLVABLE_PROVIDES:\n      kv->eof = 0;\n      return s->provides ? s->repo->idarraydata + s->provides : 0;\n    case SOLVABLE_OBSOLETES:\n      kv->eof = 0;\n      return s->obsoletes ? s->repo->idarraydata + s->obsoletes : 0;\n    case SOLVABLE_CONFLICTS:\n      kv->eof = 0;\n      return s->conflicts ? s->repo->idarraydata + s->conflicts : 0;\n    case SOLVABLE_REQUIRES:\n      kv->eof = 0;\n      return s->requires ? s->repo->idarraydata + s->requires : 0;\n    case SOLVABLE_RECOMMENDS:\n      kv->eof = 0;\n      return s->recommends ? s->repo->idarraydata + s->recommends : 0;\n    case SOLVABLE_SUPPLEMENTS:\n      kv->eof = 0;\n      return s->supplements ? s->repo->idarraydata + s->supplements : 0;\n    case SOLVABLE_SUGGESTS:\n      kv->eof = 0;\n      return s->suggests ? s->repo->idarraydata + s->suggests : 0;\n    case SOLVABLE_ENHANCES:\n      kv->eof = 0;\n      return s->enhances ? s->repo->idarraydata + s->enhances : 0;\n    case RPM_RPMDBID:\n      kv->eof = 1;\n      return s->repo->rpmdbid ? s->repo->rpmdbid + (s - s->repo->pool->solvables - s->repo->start) : 0;\n    default:\n      return 0;\n    }\n}\n\nint\ndatamatcher_init(Datamatcher *ma, const char *match, int flags)\n{\n  match = match ? solv_strdup(match) : 0;\n  ma->match = match;\n  ma->flags = flags;\n  ma->error = 0;\n  ma->matchdata = 0;\n  if ((flags & SEARCH_STRINGMASK) == SEARCH_REGEX)\n    {\n      ma->matchdata = solv_calloc(1, sizeof(regex_t));\n      ma->error = regcomp((regex_t *)ma->matchdata, match, REG_EXTENDED | REG_NOSUB | REG_NEWLINE | ((flags & SEARCH_NOCASE) ? REG_ICASE : 0));\n      if (ma->error)\n\t{\n\t  solv_free(ma->matchdata);\n\t  ma->flags = (flags & ~SEARCH_STRINGMASK) | SEARCH_ERROR;\n\t}\n    }\n  if ((flags & SEARCH_FILES) != 0 && match)\n    {\n      /* prepare basename check */\n      if ((flags & SEARCH_STRINGMASK) == SEARCH_STRING || (flags & SEARCH_STRINGMASK) == SEARCH_STRINGEND)\n\t{\n\t  const char *p = strrchr(match, '/');\n\t  ma->matchdata = (void *)(p ? p + 1 : match);\n\t}\n      else if ((flags & SEARCH_STRINGMASK) == SEARCH_GLOB)\n\t{\n\t  const char *p;\n\t  for (p = match + strlen(match) - 1; p >= match; p--)\n\t    if (*p == '[' || *p == ']' || *p == '*' || *p == '?' || *p == '/')\n\t      break;\n\t  ma->matchdata = (void *)(p + 1);\n\t}\n    }\n  return ma->error;\n}\n\nvoid\ndatamatcher_free(Datamatcher *ma)\n{\n  if (ma->match)\n    ma->match = solv_free((char *)ma->match);\n  if ((ma->flags & SEARCH_STRINGMASK) == SEARCH_REGEX && ma->matchdata)\n    {\n      regfree(ma->matchdata);\n      solv_free(ma->matchdata);\n    }\n  ma->matchdata = 0;\n}\n\nint\ndatamatcher_match(Datamatcher *ma, const char *str)\n{\n  int l;\n  switch ((ma->flags & SEARCH_STRINGMASK))\n    {\n    case SEARCH_SUBSTRING:\n      if (ma->flags & SEARCH_NOCASE)\n\treturn strcasestr(str, ma->match) != 0;\n      else\n\treturn strstr(str, ma->match) != 0;\n    case SEARCH_STRING:\n      if (ma->flags & SEARCH_NOCASE)\n\treturn !strcasecmp(ma->match, str);\n      else\n\treturn !strcmp(ma->match, str);\n    case SEARCH_STRINGSTART:\n      if (ma->flags & SEARCH_NOCASE)\n        return !strncasecmp(ma->match, str, strlen(ma->match));\n      else\n        return !strncmp(ma->match, str, strlen(ma->match));\n    case SEARCH_STRINGEND:\n      l = strlen(str) - strlen(ma->match);\n      if (l < 0)\n\treturn 0;\n      if (ma->flags & SEARCH_NOCASE)\n\treturn !strcasecmp(ma->match, str + l);\n      else\n\treturn !strcmp(ma->match, str + l);\n    case SEARCH_GLOB:\n      return !fnmatch(ma->match, str, (ma->flags & SEARCH_NOCASE) ? FNM_CASEFOLD : 0);\n    case SEARCH_REGEX:\n      return !regexec((const regex_t *)ma->matchdata, str, 0, NULL, 0);\n    default:\n      return 0;\n    }\n}\n\n/* check if the matcher can match the provides basename */\n\nint\ndatamatcher_checkbasename(Datamatcher *ma, const char *basename)\n{\n  int l;\n  const char *match = ma->matchdata;\n  if (!match)\n    return 1;\n  switch (ma->flags & SEARCH_STRINGMASK)\n    {\n    case SEARCH_STRING:\n      break;\n    case SEARCH_STRINGEND:\n      if (match != ma->match)\n\tbreak;\t\t/* had slash, do exact match on basename */\n      /* FALLTHROUGH */\n    case SEARCH_GLOB:\n      /* check if the basename ends with match */\n      l = strlen(basename) - strlen(match);\n      if (l < 0)\n\treturn 0;\n      basename += l;\n      break;\n    default:\n      return 1;\t/* maybe matches */\n    }\n  if ((ma->flags & SEARCH_NOCASE) != 0)\n    return !strcasecmp(match, basename);\n  else\n    return !strcmp(match, basename);\n}\n\nenum {\n  di_bye,\n\n  di_enterrepo,\n  di_entersolvable,\n  di_enterrepodata,\n  di_enterschema,\n  di_enterkey,\n\n  di_nextattr,\n  di_nextkey,\n  di_nextrepodata,\n  di_nextsolvable,\n  di_nextrepo,\n\n  di_enterarray,\n  di_nextarrayelement,\n\n  di_entersub,\n  di_leavesub,\n\n  di_nextsolvablekey,\n  di_entersolvablekey,\n  di_nextsolvableattr\n};\n\n/* see dataiterator.h for documentation */\nint\ndataiterator_init(Dataiterator *di, Pool *pool, Repo *repo, Id p, Id keyname, const char *match, int flags)\n{\n  memset(di, 0, sizeof(*di));\n  di->pool = pool;\n  di->flags = flags & ~SEARCH_THISSOLVID;\n  if (!pool || (repo && repo->pool != pool))\n    {\n      di->state = di_bye;\n      return -1;\n    }\n  if (match)\n    {\n      int error;\n      if ((error = datamatcher_init(&di->matcher, match, flags)) != 0)\n\t{\n\t  di->state = di_bye;\n\t  return error;\n\t}\n    }\n  di->keyname = keyname;\n  di->keynames[0] = keyname;\n  dataiterator_set_search(di, repo, p);\n  return 0;\n}\n\nvoid\ndataiterator_init_clone(Dataiterator *di, Dataiterator *from)\n{\n  *di = *from;\n  if (di->dupstr)\n    {\n      if (di->dupstr == di->kv.str)\n        di->dupstr = solv_memdup(di->dupstr, di->dupstrn);\n      else\n\t{\n\t  di->dupstr = 0;\n\t  di->dupstrn = 0;\n\t}\n    }\n  memset(&di->matcher, 0, sizeof(di->matcher));\n  if (from->matcher.match)\n    datamatcher_init(&di->matcher, from->matcher.match, from->matcher.flags);\n  if (di->nparents)\n    {\n      /* fix pointers */\n      int i;\n      for (i = 1; i < di->nparents; i++)\n\tdi->parents[i].kv.parent = &di->parents[i - 1].kv;\n      di->kv.parent = &di->parents[di->nparents - 1].kv;\n    }\n  if (di->oldkeyskip)\n    di->oldkeyskip = solv_memdup2(di->oldkeyskip, 3 + di->oldkeyskip[0], sizeof(Id));\n  if (di->keyskip)\n    di->keyskip = di->oldkeyskip;\n}\n\nint\ndataiterator_set_match(Dataiterator *di, const char *match, int flags)\n{\n  di->flags = (flags & ~SEARCH_THISSOLVID) | (di->flags & SEARCH_THISSOLVID);\n  datamatcher_free(&di->matcher);\n  memset(&di->matcher, 0, sizeof(di->matcher));\n  if (match)\n    {\n      int error;\n      if ((error = datamatcher_init(&di->matcher, match, flags)) != 0)\n\t{\n\t  di->state = di_bye;\n\t  return error;\n\t}\n    }\n  return 0;\n}\n\nvoid\ndataiterator_set_search(Dataiterator *di, Repo *repo, Id p)\n{\n  di->repo = repo;\n  di->repoid = 0;\n  di->flags &= ~SEARCH_THISSOLVID;\n  di->nparents = 0;\n  di->rootlevel = 0;\n  di->repodataid = 1;\n  if (!di->pool->urepos)\n    {\n      di->state = di_bye;\n      return;\n    }\n  if (!repo)\n    {\n      di->repoid = 1;\n      di->repo = di->pool->repos[di->repoid];\n    }\n  di->state = di_enterrepo;\n  if (p)\n    dataiterator_jump_to_solvid(di, p);\n}\n\nvoid\ndataiterator_set_keyname(Dataiterator *di, Id keyname)\n{\n  di->nkeynames = 0;\n  di->keyname = keyname;\n  di->keynames[0] = keyname;\n}\n\nvoid\ndataiterator_prepend_keyname(Dataiterator *di, Id keyname)\n{\n  int i;\n\n  if (di->nkeynames >= sizeof(di->keynames)/sizeof(*di->keynames) - 2)\n    {\n      di->state = di_bye;\t/* sorry */\n      return;\n    }\n  for (i = di->nkeynames + 1; i > 0; i--)\n    di->keynames[i] = di->keynames[i - 1];\n  di->keynames[0] = di->keyname = keyname;\n  di->nkeynames++;\n}\n\nvoid\ndataiterator_free(Dataiterator *di)\n{\n  if (di->matcher.match)\n    datamatcher_free(&di->matcher);\n  if (di->dupstr)\n    solv_free(di->dupstr);\n  if (di->oldkeyskip)\n    solv_free(di->oldkeyskip);\n}\n\nstatic unsigned char *\ndataiterator_find_keyname(Dataiterator *di, Id keyname)\n{\n  Id *keyp;\n  Repokey *keys = di->data->keys, *key;\n  unsigned char *dp;\n\n  for (keyp = di->keyp; *keyp; keyp++)\n    if (keys[*keyp].name == keyname)\n      break;\n  if (!*keyp)\n    return 0;\n  key = keys + *keyp;\n  if (key->type == REPOKEY_TYPE_DELETED)\n    return 0;\n  if (key->storage != KEY_STORAGE_INCORE && key->storage != KEY_STORAGE_VERTICAL_OFFSET)\n    return 0;\t\t/* get_data will not work, no need to forward */\n  dp = forward_to_key(di->data, *keyp, di->keyp, di->dp);\n  if (!dp)\n    return 0;\n  di->keyp = keyp;\n  return dp;\n}\n\nint\ndataiterator_step(Dataiterator *di)\n{\n  Id schema;\n\n  if (di->state == di_nextattr && di->key->storage == KEY_STORAGE_VERTICAL_OFFSET && di->vert_ddp && di->vert_storestate != di->data->storestate)\n    {\n      unsigned int ddpoff = di->ddp - di->vert_ddp;\n      di->vert_off += ddpoff;\n      di->vert_len -= ddpoff;\n      di->ddp = di->vert_ddp = get_vertical_data(di->data, di->key, di->vert_off, di->vert_len);\n      di->vert_storestate = di->data->storestate;\n      if (!di->ddp)\n\tdi->state = di_nextkey;\n    }\n  for (;;)\n    {\n      switch (di->state)\n\t{\n\tcase di_enterrepo: di_enterrepo:\n\t  if (!di->repo || (di->repo->disabled && !(di->flags & SEARCH_DISABLED_REPOS)))\n\t    goto di_nextrepo;\n\t  if (!(di->flags & SEARCH_THISSOLVID))\n\t    {\n\t      di->solvid = di->repo->start - 1;\t/* reset solvid iterator */\n\t      goto di_nextsolvable;\n\t    }\n\t  /* FALLTHROUGH */\n\n\tcase di_entersolvable: di_entersolvable:\n\t  if (!di->repodataid)\n\t    goto di_enterrepodata;\t/* POS case, repodata is set */\n\t  if (di->solvid > 0 && !(di->flags & SEARCH_NO_STORAGE_SOLVABLE) && (!di->keyname || (di->keyname >= SOLVABLE_NAME && di->keyname <= RPM_RPMDBID)) && di->nparents - di->rootlevel == di->nkeynames)\n\t    {\n\t      extern Repokey repo_solvablekeys[RPM_RPMDBID - SOLVABLE_NAME + 1];\n\t      di->key = repo_solvablekeys + (di->keyname ? di->keyname - SOLVABLE_NAME : 0);\n\t      di->data = 0;\n\t      goto di_entersolvablekey;\n\t    }\n\n\t  if (di->keyname)\n\t    {\n\t      di->data = di->keyname == SOLVABLE_FILELIST ? repo_lookup_filelist_repodata(di->repo, di->solvid, &di->matcher) : repo_lookup_repodata_opt(di->repo, di->solvid, di->keyname);\n\t      if (!di->data)\n\t\tgoto di_nextsolvable;\n\t      di->repodataid = di->data - di->repo->repodata;\n\t      di->keyskip = 0;\n\t      goto di_enterrepodata;\n\t    }\n\tdi_leavesolvablekey:\n\t  di->repodataid = 1;\t/* reset repodata iterator */\n\t  di->keyskip = repo_create_keyskip(di->repo, di->solvid, &di->oldkeyskip);\n\t  /* FALLTHROUGH */\n\n\tcase di_enterrepodata: di_enterrepodata:\n\t  if (di->repodataid)\n\t    {\n\t      if (di->repodataid >= di->repo->nrepodata)\n\t\tgoto di_nextsolvable;\n\t      di->data = di->repo->repodata + di->repodataid;\n\t    }\n\t  if (!maybe_load_repodata(di->data, di->keyname))\n\t    goto di_nextrepodata;\n\t  di->dp = solvid2data(di->data, di->solvid, &schema);\n\t  if (!di->dp)\n\t    goto di_nextrepodata;\n\t  if (di->solvid == SOLVID_POS)\n\t    di->solvid = di->pool->pos.solvid;\n\t  /* reset key iterator */\n\t  di->keyp = di->data->schemadata + di->data->schemata[schema];\n\t  /* FALLTHROUGH */\n\n\tcase di_enterschema: di_enterschema:\n\t  if (di->keyname)\n\t    di->dp = dataiterator_find_keyname(di, di->keyname);\n\t  if (!di->dp || !*di->keyp)\n\t    {\n\t      if (di->kv.parent)\n\t\tgoto di_leavesub;\n\t      goto di_nextrepodata;\n\t    }\n\t  /* FALLTHROUGH */\n\n\tcase di_enterkey: di_enterkey:\n\t  di->kv.entry = -1;\n\t  di->key = di->data->keys + *di->keyp;\n\t  if (!di->dp)\n\t    goto di_nextkey;\n\t  /* this is get_data() modified to store vert_ data */\n\t  if (di->key->storage == KEY_STORAGE_VERTICAL_OFFSET)\n\t    {\n\t      Id off, len;\n\t      di->dp = data_read_id(di->dp, &off);\n\t      di->dp = data_read_id(di->dp, &len);\n\t      di->vert_ddp = di->ddp = get_vertical_data(di->data, di->key, off, len);\n\t      di->vert_off = off;\n\t      di->vert_len = len;\n\t      di->vert_storestate = di->data->storestate;\n\t    }\n\t  else if (di->key->storage == KEY_STORAGE_INCORE)\n\t    {\n\t      di->ddp = di->dp;\t\t/* start of data */\n\t      if (di->keyp[1] && (!di->keyname || (di->flags & SEARCH_SUB) != 0))\n\t\tdi->dp = data_skip_key(di->data, di->dp, di->key);\t/* advance to next key */\n\t    }\n\t  else\n\t    di->ddp = 0;\n\t  if (!di->ddp)\n\t    goto di_nextkey;\n\t  if (di->keyskip && (di->key->name >= di->keyskip[0] || di->keyskip[3 + di->key->name] != di->keyskip[1] + di->data->repodataid))\n\t    goto di_nextkey;\n          if (di->key->type == REPOKEY_TYPE_DELETED && !(di->flags & SEARCH_KEEP_TYPE_DELETED))\n\t    goto di_nextkey;\n\t  if (di->key->type == REPOKEY_TYPE_FIXARRAY || di->key->type == REPOKEY_TYPE_FLEXARRAY)\n\t    goto di_enterarray;\n\t  if (di->nkeynames && di->nparents - di->rootlevel < di->nkeynames)\n\t    goto di_nextkey;\n\t  /* FALLTHROUGH */\n\n\tcase di_nextattr:\n          di->kv.entry++;\n\t  di->ddp = data_fetch(di->ddp, &di->kv, di->key);\n\t  di->state = di->kv.eof ? di_nextkey : di_nextattr;\n\t  break;\n\n\tcase di_nextkey: di_nextkey:\n\t  if (!di->keyname && *++di->keyp)\n\t    goto di_enterkey;\n\t  if (di->kv.parent)\n\t    goto di_leavesub;\n\t  /* FALLTHROUGH */\n\n\tcase di_nextrepodata: di_nextrepodata:\n\t  if (!di->keyname && di->repodataid && ++di->repodataid < di->repo->nrepodata)\n\t      goto di_enterrepodata;\n\t  /* FALLTHROUGH */\n\n\tcase di_nextsolvable: di_nextsolvable:\n\t  if (!(di->flags & SEARCH_THISSOLVID))\n\t    {\n\t      if (di->solvid < 0)\n\t\tdi->solvid = di->repo->start;\n\t      else\n\t        di->solvid++;\n\t      for (; di->solvid < di->repo->end; di->solvid++)\n\t\t{\n\t\t  if (di->pool->solvables[di->solvid].repo == di->repo)\n\t\t    goto di_entersolvable;\n\t\t}\n\t    }\n\t  /* FALLTHROUGH */\n\n\tcase di_nextrepo: di_nextrepo:\n\t  if (di->repoid > 0)\n\t    {\n\t      di->repoid++;\n\t      di->repodataid = 1;\n\t      if (di->repoid < di->pool->nrepos)\n\t\t{\n\t\t  di->repo = di->pool->repos[di->repoid];\n\t          goto di_enterrepo;\n\t\t}\n\t    }\n\t/* FALLTHROUGH */\n\n\tcase di_bye: di_bye:\n\t  di->state = di_bye;\n\t  return 0;\n\n\tcase di_enterarray: di_enterarray:\n\t  if (di->key->name == REPOSITORY_SOLVABLES)\n\t    goto di_nextkey;\n\t  di->ddp = data_read_id(di->ddp, (Id *)&di->kv.num);\n\t  di->kv.eof = 0;\n\t  di->kv.entry = -1;\n\t  /* FALLTHROUGH */\n\n\tcase di_nextarrayelement: di_nextarrayelement:\n\t  di->kv.entry++;\n\t  if (di->kv.entry)\n\t    di->ddp = data_skip_schema(di->data, di->ddp, di->kv.id);\n\t  if (di->kv.entry == di->kv.num)\n\t    {\n\t      if (di->nkeynames && di->nparents - di->rootlevel < di->nkeynames)\n\t\tgoto di_nextkey;\n\t      if (!(di->flags & SEARCH_ARRAYSENTINEL))\n\t\tgoto di_nextkey;\n\t      di->kv.str = (char *)di->ddp;\n\t      di->kv.eof = 2;\n\t      di->state = di_nextkey;\n\t      break;\n\t    }\n\t  if (di->kv.entry == di->kv.num - 1)\n\t    di->kv.eof = 1;\n\t  if (di->key->type == REPOKEY_TYPE_FLEXARRAY || !di->kv.entry)\n\t    di->ddp = data_read_id(di->ddp, &di->kv.id);\n\t  di->kv.str = (char *)di->ddp;\n\t  if (di->nkeynames && di->nparents - di->rootlevel < di->nkeynames)\n\t    goto di_entersub;\n\t  if ((di->flags & SEARCH_SUB) != 0)\n\t    di->state = di_entersub;\n\t  else\n\t    di->state = di_nextarrayelement;\n\t  break;\n\n\tcase di_entersub: di_entersub:\n\t  if (di->nparents == sizeof(di->parents)/sizeof(*di->parents) - 1)\n\t    goto di_nextarrayelement;\t/* sorry, full */\n\t  di->parents[di->nparents].kv = di->kv;\n\t  di->parents[di->nparents].dp = di->dp;\n\t  di->parents[di->nparents].keyp = di->keyp;\n\t  di->dp = (unsigned char *)di->kv.str;\n\t  di->keyp = di->data->schemadata + di->data->schemata[di->kv.id];\n\t  memset(&di->kv, 0, sizeof(di->kv));\n\t  di->kv.parent = &di->parents[di->nparents].kv;\n\t  di->nparents++;\n\t  di->keyname = di->keynames[di->nparents - di->rootlevel];\n\t  goto di_enterschema;\n\n\tcase di_leavesub: di_leavesub:\n\t  if (di->nparents - 1 < di->rootlevel)\n\t    goto di_bye;\n\t  di->nparents--;\n\t  di->dp = di->parents[di->nparents].dp;\n\t  di->kv = di->parents[di->nparents].kv;\n\t  di->keyp = di->parents[di->nparents].keyp;\n\t  di->key = di->data->keys + *di->keyp;\n\t  di->ddp = (unsigned char *)di->kv.str;\n\t  di->keyname = di->keynames[di->nparents - di->rootlevel];\n\t  goto di_nextarrayelement;\n\n        /* special solvable attr handling follows */\n\n\tcase di_nextsolvablekey: di_nextsolvablekey:\n\t  if (di->keyname)\n\t    goto di_nextsolvable;\n\t  if (di->key->name == RPM_RPMDBID)\t/* reached end of list? */\n\t    goto di_leavesolvablekey;\n\t  di->key++;\n\t  /* FALLTHROUGH */\n\n\tcase di_entersolvablekey: di_entersolvablekey:\n\t  di->idp = solvabledata_fetch(di->pool->solvables + di->solvid, &di->kv, di->key->name);\n\t  if (!di->idp || !*di->idp)\n\t    goto di_nextsolvablekey;\n\t  if (di->kv.eof)\n\t    {\n\t      /* not an array */\n\t      di->kv.id = *di->idp;\n\t      di->kv.num = *di->idp;\t/* for rpmdbid */\n\t      di->kv.num2 = 0;\t\t/* for rpmdbid */\n\t      di->kv.entry = 0;\n\t      di->state = di_nextsolvablekey;\n\t      break;\n\t    }\n\t  di->kv.entry = -1;\n\t  /* FALLTHROUGH */\n\n\tcase di_nextsolvableattr:\n\t  di->state = di_nextsolvableattr;\n\t  di->kv.id = *di->idp++;\n\t  di->kv.entry++;\n\t  if (!*di->idp)\n\t    {\n\t      di->kv.eof = 1;\n\t      di->state = di_nextsolvablekey;\n\t    }\n\t  break;\n\n\t}\n\n      /* we have a potential match */\n      if (di->matcher.match)\n\t{\n\t  const char *str;\n\t  /* simple pre-check so that we don't need to stringify */\n\t  if (di->keyname == SOLVABLE_FILELIST && di->key->type == REPOKEY_TYPE_DIRSTRARRAY && (di->matcher.flags & SEARCH_FILES) != 0)\n\t    if (!datamatcher_checkbasename(&di->matcher, di->kv.str))\n\t      continue;\n\t  /* now stringify so that we can do the matching */\n\t  if (!(str = repodata_stringify(di->pool, di->data, di->key, &di->kv, di->flags)))\n\t    {\n\t      if (di->keyname && (di->key->type == REPOKEY_TYPE_FIXARRAY || di->key->type == REPOKEY_TYPE_FLEXARRAY))\n\t\treturn 1;\n\t      continue;\n\t    }\n\t  if (!datamatcher_match(&di->matcher, str))\n\t    continue;\n\t}\n      else\n\t{\n\t  /* stringify filelist if requested */\n\t  if (di->keyname == SOLVABLE_FILELIST && di->key->type == REPOKEY_TYPE_DIRSTRARRAY && (di->flags & SEARCH_FILES) != 0)\n\t    repodata_stringify(di->pool, di->data, di->key, &di->kv, di->flags);\n\t}\n      /* found something! */\n      return 1;\n    }\n}\n\nvoid\ndataiterator_entersub(Dataiterator *di)\n{\n  if (di->state == di_nextarrayelement)\n    di->state = di_entersub;\n}\n\nvoid\ndataiterator_setpos(Dataiterator *di)\n{\n  if (di->kv.eof == 2)\n    {\n      pool_clear_pos(di->pool);\n      return;\n    }\n  di->pool->pos.solvid = di->solvid;\n  di->pool->pos.repo = di->repo;\n  di->pool->pos.repodataid = di->data - di->repo->repodata;\n  di->pool->pos.schema = di->kv.id;\n  di->pool->pos.dp = (unsigned char *)di->kv.str - di->data->incoredata;\n}\n\nvoid\ndataiterator_setpos_parent(Dataiterator *di)\n{\n  if (!di->kv.parent || di->kv.parent->eof == 2)\n    {\n      pool_clear_pos(di->pool);\n      return;\n    }\n  di->pool->pos.solvid = di->solvid;\n  di->pool->pos.repo = di->repo;\n  di->pool->pos.repodataid = di->data - di->repo->repodata;\n  di->pool->pos.schema = di->kv.parent->id;\n  di->pool->pos.dp = (unsigned char *)di->kv.parent->str - di->data->incoredata;\n}\n\n/* clones just the position, not the search keys/matcher */\nvoid\ndataiterator_clonepos(Dataiterator *di, Dataiterator *from)\n{\n  di->state = from->state;\n  di->flags &= ~SEARCH_THISSOLVID;\n  di->flags |= (from->flags & SEARCH_THISSOLVID);\n  di->repo = from->repo;\n  di->data = from->data;\n  di->dp = from->dp;\n  di->ddp = from->ddp;\n  di->idp = from->idp;\n  di->keyp = from->keyp;\n  di->key = from->key;\n  di->kv = from->kv;\n  di->repodataid = from->repodataid;\n  di->solvid = from->solvid;\n  di->repoid = from->repoid;\n  di->rootlevel = from->rootlevel;\n  memcpy(di->parents, from->parents, sizeof(from->parents));\n  di->nparents = from->nparents;\n  if (di->nparents)\n    {\n      int i;\n      for (i = 1; i < di->nparents; i++)\n\tdi->parents[i].kv.parent = &di->parents[i - 1].kv;\n      di->kv.parent = &di->parents[di->nparents - 1].kv;\n    }\n  di->dupstr = 0;\n  di->dupstrn = 0;\n  if (from->dupstr && from->dupstr == from->kv.str)\n    {\n      di->dupstrn = from->dupstrn;\n      di->dupstr = solv_memdup(from->dupstr, from->dupstrn);\n    }\n}\n\nvoid\ndataiterator_seek(Dataiterator *di, int whence)\n{\n  if ((whence & DI_SEEK_STAY) != 0)\n    di->rootlevel = di->nparents;\n  switch (whence & ~DI_SEEK_STAY)\n    {\n    case DI_SEEK_CHILD:\n      if (di->state != di_nextarrayelement)\n\tbreak;\n      if ((whence & DI_SEEK_STAY) != 0)\n\tdi->rootlevel = di->nparents + 1;\t/* XXX: dangerous! */\n      di->state = di_entersub;\n      break;\n    case DI_SEEK_PARENT:\n      if (!di->nparents)\n\t{\n\t  di->state = di_bye;\n\t  break;\n\t}\n      di->nparents--;\n      if (di->rootlevel > di->nparents)\n\tdi->rootlevel = di->nparents;\n      di->dp = di->parents[di->nparents].dp;\n      di->kv = di->parents[di->nparents].kv;\n      di->keyp = di->parents[di->nparents].keyp;\n      di->key = di->data->keys + *di->keyp;\n      di->ddp = (unsigned char *)di->kv.str;\n      di->keyname = di->keynames[di->nparents - di->rootlevel];\n      di->state = di_nextarrayelement;\n      break;\n    case DI_SEEK_REWIND:\n      if (!di->nparents)\n\t{\n\t  di->state = di_bye;\n\t  break;\n\t}\n      di->dp = (unsigned char *)di->kv.parent->str;\n      di->keyp = di->data->schemadata + di->data->schemata[di->kv.parent->id];\n      di->state = di_enterschema;\n      break;\n    default:\n      break;\n    }\n}\n\nvoid\ndataiterator_skip_attribute(Dataiterator *di)\n{\n  if (di->state == di_nextsolvableattr)\n    di->state = di_nextsolvablekey;\n  else\n    di->state = di_nextkey;\n}\n\nvoid\ndataiterator_skip_solvable(Dataiterator *di)\n{\n  di->nparents = 0;\n  di->kv.parent = 0;\n  di->rootlevel = 0;\n  di->keyname = di->keynames[0];\n  di->state = di_nextsolvable;\n}\n\nvoid\ndataiterator_skip_repo(Dataiterator *di)\n{\n  di->nparents = 0;\n  di->kv.parent = 0;\n  di->rootlevel = 0;\n  di->keyname = di->keynames[0];\n  di->state = di_nextrepo;\n}\n\nvoid\ndataiterator_jump_to_solvid(Dataiterator *di, Id solvid)\n{\n  di->nparents = 0;\n  di->kv.parent = 0;\n  di->rootlevel = 0;\n  di->keyname = di->keynames[0];\n  if (solvid == SOLVID_POS)\n    {\n      di->repo = di->pool->pos.repo;\n      if (!di->repo)\n\t{\n\t  di->state = di_bye;\n\t  return;\n\t}\n      di->repoid = 0;\n      if (!di->pool->pos.repodataid && di->pool->pos.solvid == SOLVID_META) {\n\tsolvid = SOLVID_META;\t\t/* META pos hack */\n      } else {\n        di->data = di->repo->repodata + di->pool->pos.repodataid;\n        di->repodataid = 0;\n      }\n    }\n  else if (solvid > 0)\n    {\n      di->repo = di->pool->solvables[solvid].repo;\n      di->repoid = 0;\n    }\n  if (di->repoid > 0)\n    {\n      if (!di->pool->urepos)\n\t{\n\t  di->state = di_bye;\n\t  return;\n\t}\n      di->repoid = 1;\n      di->repo = di->pool->repos[di->repoid];\n    }\n  if (solvid != SOLVID_POS)\n    di->repodataid = 1;\n  di->solvid = solvid;\n  if (solvid)\n    di->flags |= SEARCH_THISSOLVID;\n  di->state = di_enterrepo;\n}\n\nvoid\ndataiterator_jump_to_repo(Dataiterator *di, Repo *repo)\n{\n  di->nparents = 0;\n  di->kv.parent = 0;\n  di->rootlevel = 0;\n  di->repo = repo;\n  di->repoid = 0;\t/* 0 means stay at repo */\n  di->repodataid = 1;\n  di->solvid = 0;\n  di->flags &= ~SEARCH_THISSOLVID;\n  di->state = di_enterrepo;\n}\n\nint\ndataiterator_match(Dataiterator *di, Datamatcher *ma)\n{\n  const char *str;\n  if (!(str = repodata_stringify(di->pool, di->data, di->key, &di->kv, di->flags)))\n    return 0;\n  return ma ? datamatcher_match(ma, str) : 1;\n}\n\nvoid\ndataiterator_strdup(Dataiterator *di)\n{\n  int l = -1;\n\n  if (!di->kv.str || di->kv.str == di->dupstr)\n    return;\n  switch (di->key->type)\n    {\n    case_CHKSUM_TYPES:\n    case REPOKEY_TYPE_DIRSTRARRAY:\n      if (di->kv.num)\t/* was it stringified into tmp space? */\n        l = strlen(di->kv.str) + 1;\n      break;\n    default:\n      break;\n    }\n  if (l < 0 && di->key->storage == KEY_STORAGE_VERTICAL_OFFSET)\n    {\n      switch (di->key->type)\n\t{\n\tcase REPOKEY_TYPE_STR:\n\tcase REPOKEY_TYPE_DIRSTRARRAY:\n\t  l = strlen(di->kv.str) + 1;\n\t  break;\n\tcase_CHKSUM_TYPES:\n\t  l = solv_chksum_len(di->key->type);\n\t  break;\n\tcase REPOKEY_TYPE_BINARY:\n\t  l = di->kv.num;\n\t  break;\n\t}\n    }\n  if (l >= 0)\n    {\n      if (!di->dupstrn || di->dupstrn < l)\n\t{\n\t  di->dupstrn = l + 16;\n\t  di->dupstr = solv_realloc(di->dupstr, di->dupstrn);\n\t}\n      if (l)\n        memcpy(di->dupstr, di->kv.str, l);\n      di->kv.str = di->dupstr;\n    }\n}\n\n/************************************************************************\n * data modify functions\n */\n\n/* extend repodata so that it includes solvables p */\nvoid\nrepodata_extend(Repodata *data, Id p)\n{\n  if (data->start == data->end)\n    data->start = data->end = p;\n  if (p >= data->end)\n    {\n      int old = data->end - data->start;\n      int new = p - data->end + 1;\n      if (data->attrs)\n\t{\n\t  data->attrs = solv_extend(data->attrs, old, new, sizeof(Id *), REPODATA_BLOCK);\n\t  memset(data->attrs + old, 0, new * sizeof(Id *));\n\t}\n      data->incoreoffset = solv_extend(data->incoreoffset, old, new, sizeof(Id), REPODATA_BLOCK);\n      memset(data->incoreoffset + old, 0, new * sizeof(Id));\n      data->end = p + 1;\n    }\n  if (p < data->start)\n    {\n      int old = data->end - data->start;\n      int new = data->start - p;\n      if (data->attrs)\n\t{\n\t  data->attrs = solv_extend_resize(data->attrs, old + new, sizeof(Id *), REPODATA_BLOCK);\n\t  memmove(data->attrs + new, data->attrs, old * sizeof(Id *));\n\t  memset(data->attrs, 0, new * sizeof(Id *));\n\t}\n      data->incoreoffset = solv_extend_resize(data->incoreoffset, old + new, sizeof(Id), REPODATA_BLOCK);\n      memmove(data->incoreoffset + new, data->incoreoffset, old * sizeof(Id));\n      memset(data->incoreoffset, 0, new * sizeof(Id));\n      data->start = p;\n    }\n}\n\n/* shrink end of repodata */\nvoid\nrepodata_shrink(Repodata *data, int end)\n{\n  int i;\n\n  if (data->end <= end)\n    return;\n  if (data->start >= end)\n    {\n      if (data->attrs)\n\t{\n\t  for (i = 0; i < data->end - data->start; i++)\n\t    solv_free(data->attrs[i]);\n          data->attrs = solv_free(data->attrs);\n\t}\n      data->incoreoffset = solv_free(data->incoreoffset);\n      data->start = data->end = 0;\n      return;\n    }\n  if (data->attrs)\n    {\n      for (i = end; i < data->end; i++)\n\tsolv_free(data->attrs[i - data->start]);\n      data->attrs = solv_extend_resize(data->attrs, end - data->start, sizeof(Id *), REPODATA_BLOCK);\n    }\n  if (data->incoreoffset)\n    data->incoreoffset = solv_extend_resize(data->incoreoffset, end - data->start, sizeof(Id), REPODATA_BLOCK);\n  data->end = end;\n}\n\n/* extend repodata so that it includes solvables from start to start + num - 1 */\nvoid\nrepodata_extend_block(Repodata *data, Id start, Id num)\n{\n  if (!num)\n    return;\n  if (!data->incoreoffset)\n    {\n      /* this also means that data->attrs is NULL */\n      data->incoreoffset = solv_calloc_block(num, sizeof(Id), REPODATA_BLOCK);\n      data->start = start;\n      data->end = start + num;\n      return;\n    }\n  repodata_extend(data, start);\n  if (num > 1)\n    repodata_extend(data, start + num - 1);\n}\n\n/**********************************************************************/\n\n\n#define REPODATA_ATTRS_BLOCK 31\n#define REPODATA_ATTRDATA_BLOCK 1023\n#define REPODATA_ATTRIDDATA_BLOCK 63\n#define REPODATA_ATTRNUM64DATA_BLOCK 15\n\n\nId\nrepodata_new_handle(Repodata *data)\n{\n  if (!data->nxattrs)\n    {\n      data->xattrs = solv_calloc_block(1, sizeof(Id *), REPODATA_BLOCK);\n      data->nxattrs = 2;\t/* -1: SOLVID_META */\n    }\n  data->xattrs = solv_extend(data->xattrs, data->nxattrs, 1, sizeof(Id *), REPODATA_BLOCK);\n  data->xattrs[data->nxattrs] = 0;\n  return -(data->nxattrs++);\n}\n\nstatic inline Id **\nrepodata_get_attrp(Repodata *data, Id handle)\n{\n  if (handle < 0)\n    {\n      if (handle == SOLVID_META && !data->xattrs)\n\t{\n\t  data->xattrs = solv_calloc_block(1, sizeof(Id *), REPODATA_BLOCK);\n          data->nxattrs = 2;\n\t}\n      return data->xattrs - handle;\n    }\n  if (handle < data->start || handle >= data->end)\n    repodata_extend(data, handle);\n  if (!data->attrs)\n    data->attrs = solv_calloc_block(data->end - data->start, sizeof(Id *), REPODATA_BLOCK);\n  return data->attrs + (handle - data->start);\n}\n\nstatic void\nrepodata_insert_keyid(Repodata *data, Id handle, Id keyid, Id val, int overwrite)\n{\n  Id *pp;\n  Id *ap, **app;\n  int i;\n\n  app = repodata_get_attrp(data, handle);\n  ap = *app;\n  i = 0;\n  if (ap)\n    {\n      /* Determine equality based on the name only, allows us to change\n         type (when overwrite is set), and makes TYPE_CONSTANT work.  */\n      for (pp = ap; *pp; pp += 2)\n        if (data->keys[*pp].name == data->keys[keyid].name)\n          break;\n      if (*pp)\n        {\n\t  if (overwrite || data->keys[*pp].type == REPOKEY_TYPE_DELETED)\n\t    {\n\t      pp[0] = keyid;\n              pp[1] = val;\n\t    }\n          return;\n        }\n      i = pp - ap;\n    }\n  ap = solv_extend(ap, i, 3, sizeof(Id), REPODATA_ATTRS_BLOCK);\n  *app = ap;\n  pp = ap + i;\n  *pp++ = keyid;\n  *pp++ = val;\n  *pp = 0;\n}\n\n\nstatic void\nrepodata_set(Repodata *data, Id solvid, Repokey *key, Id val)\n{\n  Id keyid;\n\n  keyid = repodata_key2id(data, key, 1);\n  repodata_insert_keyid(data, solvid, keyid, val, 1);\n}\n\nvoid\nrepodata_set_id(Repodata *data, Id solvid, Id keyname, Id id)\n{\n  Repokey key;\n  key.name = keyname;\n  key.type = REPOKEY_TYPE_ID;\n  key.size = 0;\n  key.storage = KEY_STORAGE_INCORE;\n  repodata_set(data, solvid, &key, id);\n}\n\nvoid\nrepodata_set_num(Repodata *data, Id solvid, Id keyname, unsigned long long num)\n{\n  Repokey key;\n  key.name = keyname;\n  key.type = REPOKEY_TYPE_NUM;\n  key.size = 0;\n  key.storage = KEY_STORAGE_INCORE;\n  if (num >= 0x80000000)\n    {\n      data->attrnum64data = solv_extend(data->attrnum64data, data->attrnum64datalen, 1, sizeof(unsigned long long), REPODATA_ATTRNUM64DATA_BLOCK);\n      data->attrnum64data[data->attrnum64datalen] = num;\n      num = 0x80000000 | data->attrnum64datalen++;\n    }\n  repodata_set(data, solvid, &key, (Id)num);\n}\n\nvoid\nrepodata_set_poolstr(Repodata *data, Id solvid, Id keyname, const char *str)\n{\n  Repokey key;\n  Id id;\n  if (data->localpool)\n    id = stringpool_str2id(&data->spool, str, 1);\n  else\n    id = pool_str2id(data->repo->pool, str, 1);\n  key.name = keyname;\n  key.type = REPOKEY_TYPE_ID;\n  key.size = 0;\n  key.storage = KEY_STORAGE_INCORE;\n  repodata_set(data, solvid, &key, id);\n}\n\nvoid\nrepodata_set_constant(Repodata *data, Id solvid, Id keyname, unsigned int constant)\n{\n  Repokey key;\n  key.name = keyname;\n  key.type = REPOKEY_TYPE_CONSTANT;\n  key.size = constant;\n  key.storage = KEY_STORAGE_INCORE;\n  repodata_set(data, solvid, &key, 0);\n}\n\nvoid\nrepodata_set_constantid(Repodata *data, Id solvid, Id keyname, Id id)\n{\n  Repokey key;\n  key.name = keyname;\n  key.type = REPOKEY_TYPE_CONSTANTID;\n  key.size = id;\n  key.storage = KEY_STORAGE_INCORE;\n  repodata_set(data, solvid, &key, 0);\n}\n\nvoid\nrepodata_set_void(Repodata *data, Id solvid, Id keyname)\n{\n  Repokey key;\n  key.name = keyname;\n  key.type = REPOKEY_TYPE_VOID;\n  key.size = 0;\n  key.storage = KEY_STORAGE_INCORE;\n  repodata_set(data, solvid, &key, 0);\n}\n\nvoid\nrepodata_set_str(Repodata *data, Id solvid, Id keyname, const char *str)\n{\n  Repokey key;\n  int l;\n\n  l = strlen(str) + 1;\n  key.name = keyname;\n  key.type = REPOKEY_TYPE_STR;\n  key.size = 0;\n  key.storage = KEY_STORAGE_INCORE;\n  data->attrdata = solv_extend(data->attrdata, data->attrdatalen, l, 1, REPODATA_ATTRDATA_BLOCK);\n  memcpy(data->attrdata + data->attrdatalen, str, l);\n  repodata_set(data, solvid, &key, data->attrdatalen);\n  data->attrdatalen += l;\n}\n\nvoid\nrepodata_set_binary(Repodata *data, Id solvid, Id keyname, void *buf, int len)\n{\n  Repokey key;\n  unsigned char *dp;\n\n  if (len < 0)\n    return;\n  key.name = keyname;\n  key.type = REPOKEY_TYPE_BINARY;\n  key.size = 0;\n  key.storage = KEY_STORAGE_INCORE;\n  data->attrdata = solv_extend(data->attrdata, data->attrdatalen, len + 5, 1, REPODATA_ATTRDATA_BLOCK);\n  dp = data->attrdata + data->attrdatalen;\n  if (len >= (1 << 14))\n    {\n      if (len >= (1 << 28))\n        *dp++ = (len >> 28) | 128;\n      if (len >= (1 << 21))\n        *dp++ = (len >> 21) | 128;\n      *dp++ = (len >> 14) | 128;\n    }\n  if (len >= (1 << 7))\n    *dp++ = (len >> 7) | 128;\n  *dp++ = len & 127;\n  if (len)\n    memcpy(dp, buf, len);\n  repodata_set(data, solvid, &key, data->attrdatalen);\n  data->attrdatalen = dp + len - data->attrdata;\n}\n\n/* add an array element consisting of entrysize Ids to the repodata. modifies attriddata\n * so that the caller can append entrysize new elements plus the termination zero there */\nstatic void\nrepodata_add_array(Repodata *data, Id handle, Id keyname, Id keytype, int entrysize)\n{\n  int oldsize;\n  Id *ida, *pp, **ppp;\n\n  /* check if it is the same as last time, this speeds things up a lot */\n  if (handle == data->lasthandle && data->keys[data->lastkey].name == keyname && data->keys[data->lastkey].type == keytype && data->attriddatalen == data->lastdatalen)\n    {\n      /* great! just append the new data */\n      data->attriddata = solv_extend(data->attriddata, data->attriddatalen, entrysize, sizeof(Id), REPODATA_ATTRIDDATA_BLOCK);\n      data->attriddatalen--;\t/* overwrite terminating 0  */\n      data->lastdatalen += entrysize;\n      return;\n    }\n\n  ppp = repodata_get_attrp(data, handle);\n  pp = *ppp;\n  if (pp)\n    {\n      for (; *pp; pp += 2)\n        if (data->keys[*pp].name == keyname)\n          break;\n    }\n  if (!pp || !*pp || data->keys[*pp].type != keytype)\n    {\n      /* not found. allocate new key */\n      Repokey key;\n      Id keyid;\n      key.name = keyname;\n      key.type = keytype;\n      key.size = 0;\n      key.storage = KEY_STORAGE_INCORE;\n      data->attriddata = solv_extend(data->attriddata, data->attriddatalen, entrysize + 1, sizeof(Id), REPODATA_ATTRIDDATA_BLOCK);\n      keyid = repodata_key2id(data, &key, 1);\n      repodata_insert_keyid(data, handle, keyid, data->attriddatalen, 1);\n      data->lasthandle = handle;\n      data->lastkey = keyid;\n      data->lastdatalen = data->attriddatalen + entrysize + 1;\n      return;\n    }\n  oldsize = 0;\n  for (ida = data->attriddata + pp[1]; *ida; ida += entrysize)\n    oldsize += entrysize;\n  if (ida + 1 == data->attriddata + data->attriddatalen)\n    {\n      /* this was the last entry, just append it */\n      data->attriddata = solv_extend(data->attriddata, data->attriddatalen, entrysize, sizeof(Id), REPODATA_ATTRIDDATA_BLOCK);\n      data->attriddatalen--;\t/* overwrite terminating 0  */\n    }\n  else\n    {\n      /* too bad. move to back. */\n      data->attriddata = solv_extend(data->attriddata, data->attriddatalen,  oldsize + entrysize + 1, sizeof(Id), REPODATA_ATTRIDDATA_BLOCK);\n      memcpy(data->attriddata + data->attriddatalen, data->attriddata + pp[1], oldsize * sizeof(Id));\n      pp[1] = data->attriddatalen;\n      data->attriddatalen += oldsize;\n    }\n  data->lasthandle = handle;\n  data->lastkey = *pp;\n  data->lastdatalen = data->attriddatalen + entrysize + 1;\n}\n\nvoid\nrepodata_set_bin_checksum(Repodata *data, Id solvid, Id keyname, Id type,\n\t\t      const unsigned char *str)\n{\n  Repokey key;\n  int l;\n\n  if (!(l = solv_chksum_len(type)))\n    return;\n  key.name = keyname;\n  key.type = type;\n  key.size = 0;\n  key.storage = KEY_STORAGE_INCORE;\n  data->attrdata = solv_extend(data->attrdata, data->attrdatalen, l, 1, REPODATA_ATTRDATA_BLOCK);\n  memcpy(data->attrdata + data->attrdatalen, str, l);\n  repodata_set(data, solvid, &key, data->attrdatalen);\n  data->attrdatalen += l;\n}\n\nvoid\nrepodata_set_checksum(Repodata *data, Id solvid, Id keyname, Id type,\n\t\t      const char *str)\n{\n  unsigned char buf[64];\n  int l;\n\n  if (!(l = solv_chksum_len(type)))\n    return;\n  if (l > sizeof(buf) || solv_hex2bin(&str, buf, l) != l)\n    return;\n  repodata_set_bin_checksum(data, solvid, keyname, type, buf);\n}\n\nconst char *\nrepodata_chk2str(Repodata *data, Id type, const unsigned char *buf)\n{\n  int l;\n\n  if (!(l = solv_chksum_len(type)))\n    return \"\";\n  return pool_bin2hex(data->repo->pool, buf, l);\n}\n\n/* rpm filenames don't contain the epoch, so strip it */\nstatic inline const char *\nevrid2vrstr(Pool *pool, Id evrid)\n{\n  const char *p, *evr = pool_id2str(pool, evrid);\n  if (!evr)\n    return evr;\n  for (p = evr; *p >= '0' && *p <= '9'; p++)\n    ;\n  return p != evr && *p == ':' && p[1] ? p + 1 : evr;\n}\n\nstatic inline void\nrepodata_set_poolstrn(Repodata *data, Id solvid, Id keyname, const char *str, int l)\n{\n  Id id;\n  if (data->localpool)\n    id = stringpool_strn2id(&data->spool, str, l, 1);\n  else\n    id = pool_strn2id(data->repo->pool, str, l, 1);\n  repodata_set_id(data, solvid, keyname, id);\n}\n\nstatic inline void\nrepodata_set_strn(Repodata *data, Id solvid, Id keyname, const char *str, int l)\n{\n  if (!str[l])\n    repodata_set_str(data, solvid, keyname, str);\n  else\n    {\n      char *s = solv_strdup(str);\n      s[l] = 0;\n      repodata_set_str(data, solvid, keyname, s);\n      free(s);\n    }\n}\n\nvoid\nrepodata_set_location(Repodata *data, Id solvid, int medianr, const char *dir, const char *file)\n{\n  Pool *pool = data->repo->pool;\n  Solvable *s;\n  const char *str, *fp;\n  int l = 0;\n\n  if (medianr)\n    repodata_set_constant(data, solvid, SOLVABLE_MEDIANR, medianr);\n  if (!dir)\n    {\n      if ((dir = strrchr(file, '/')) != 0)\n\t{\n          l = dir - file;\n\t  dir = file;\n\t  file = dir + l + 1;\n\t  if (!l)\n\t    l++;\n\t}\n    }\n  else\n    l = strlen(dir);\n  if (l >= 2 && dir[0] == '.' && dir[1] == '/' && (l == 2 || dir[2] != '/'))\n    {\n      dir += 2;\n      l -= 2;\n    }\n  if (l == 1 && dir[0] == '.')\n    l = 0;\n  s = pool->solvables + solvid;\n  if (dir && l)\n    {\n      str = pool_id2str(pool, s->arch);\n      if (!strncmp(dir, str, l) && !str[l])\n\trepodata_set_void(data, solvid, SOLVABLE_MEDIADIR);\n      else\n\trepodata_set_strn(data, solvid, SOLVABLE_MEDIADIR, dir, l);\n    }\n  fp = file;\n  str = pool_id2str(pool, s->name);\n  l = strlen(str);\n  if ((!l || !strncmp(fp, str, l)) && fp[l] == '-')\n    {\n      fp += l + 1;\n      str = evrid2vrstr(pool, s->evr);\n      l = strlen(str);\n      if ((!l || !strncmp(fp, str, l)) && fp[l] == '.')\n\t{\n\t  fp += l + 1;\n\t  str = pool_id2str(pool, s->arch);\n\t  l = strlen(str);\n\t  if ((!l || !strncmp(fp, str, l)) && !strcmp(fp + l, \".rpm\"))\n\t    {\n\t      repodata_set_void(data, solvid, SOLVABLE_MEDIAFILE);\n\t      return;\n\t    }\n\t}\n    }\n  repodata_set_str(data, solvid, SOLVABLE_MEDIAFILE, file);\n}\n\n/* XXX: medianr is currently not stored */\nvoid\nrepodata_set_deltalocation(Repodata *data, Id handle, int medianr, const char *dir, const char *file)\n{\n  int l = 0;\n  const char *evr, *suf, *s;\n\n  if (!dir)\n    {\n      if ((dir = strrchr(file, '/')) != 0)\n\t{\n          l = dir - file;\n\t  dir = file;\n\t  file = dir + l + 1;\n\t  if (!l)\n\t    l++;\n\t}\n    }\n  else\n    l = strlen(dir);\n  if (l >= 2 && dir[0] == '.' && dir[1] == '/' && (l == 2 || dir[2] != '/'))\n    {\n      dir += 2;\n      l -= 2;\n    }\n  if (l == 1 && dir[0] == '.')\n    l = 0;\n  if (dir && l)\n    repodata_set_poolstrn(data, handle, DELTA_LOCATION_DIR, dir, l);\n  evr = strchr(file, '-');\n  if (evr)\n    {\n      for (s = evr - 1; s > file; s--)\n\tif (*s == '-')\n\t  {\n\t    evr = s;\n\t    break;\n\t  }\n    }\n  suf = strrchr(file, '.');\n  if (suf)\n    {\n      for (s = suf - 1; s > file; s--)\n\tif (*s == '.')\n\t  {\n\t    suf = s;\n\t    break;\n\t  }\n      if (!strcmp(suf, \".delta.rpm\") || !strcmp(suf, \".patch.rpm\"))\n\t{\n\t  /* We accept one more item as suffix.  */\n\t  for (s = suf - 1; s > file; s--)\n\t    if (*s == '.')\n\t      {\n\t\tsuf = s;\n\t        break;\n\t      }\n\t}\n    }\n  if (!evr)\n    suf = 0;\n  if (suf && evr && suf < evr)\n    suf = 0;\n  repodata_set_poolstrn(data, handle, DELTA_LOCATION_NAME, file, evr ? evr - file : strlen(file));\n  if (evr)\n    repodata_set_poolstrn(data, handle, DELTA_LOCATION_EVR, evr + 1, suf ? suf - evr - 1: strlen(evr + 1));\n  if (suf)\n    repodata_set_poolstr(data, handle, DELTA_LOCATION_SUFFIX, suf + 1);\n}\n\nvoid\nrepodata_set_sourcepkg(Repodata *data, Id solvid, const char *sourcepkg)\n{\n  Pool *pool = data->repo->pool;\n  Solvable *s = pool->solvables + solvid;\n  const char *p, *sevr, *sarch, *name, *evr;\n\n  p = strrchr(sourcepkg, '.');\n  if (!p || strcmp(p, \".rpm\") != 0)\n    {\n      if (*sourcepkg)\n        repodata_set_str(data, solvid, SOLVABLE_SOURCENAME, sourcepkg);\n      return;\n    }\n  p--;\n  while (p > sourcepkg && *p != '.')\n    p--;\n  if (*p != '.' || p == sourcepkg)\n    return;\n  sarch = p-- + 1;\n  while (p > sourcepkg && *p != '-')\n    p--;\n  if (*p != '-' || p == sourcepkg)\n    return;\n  p--;\n  while (p > sourcepkg && *p != '-')\n    p--;\n  if (*p != '-' || p == sourcepkg)\n    return;\n  sevr = p + 1;\n  pool = s->repo->pool;\n\n  name = pool_id2str(pool, s->name);\n  if (name && !strncmp(sourcepkg, name, sevr - sourcepkg - 1) && name[sevr - sourcepkg - 1] == 0)\n    repodata_set_void(data, solvid, SOLVABLE_SOURCENAME);\n  else\n    repodata_set_id(data, solvid, SOLVABLE_SOURCENAME, pool_strn2id(pool, sourcepkg, sevr - sourcepkg - 1, 1));\n\n  evr = evrid2vrstr(pool, s->evr);\n  if (evr && !strncmp(sevr, evr, sarch - sevr - 1) && evr[sarch - sevr - 1] == 0)\n    repodata_set_void(data, solvid, SOLVABLE_SOURCEEVR);\n  else\n    repodata_set_id(data, solvid, SOLVABLE_SOURCEEVR, pool_strn2id(pool, sevr, sarch - sevr - 1, 1));\n\n  if (!strcmp(sarch, \"src.rpm\"))\n    repodata_set_constantid(data, solvid, SOLVABLE_SOURCEARCH, ARCH_SRC);\n  else if (!strcmp(sarch, \"nosrc.rpm\"))\n    repodata_set_constantid(data, solvid, SOLVABLE_SOURCEARCH, ARCH_NOSRC);\n  else\n    repodata_set_constantid(data, solvid, SOLVABLE_SOURCEARCH, pool_strn2id(pool, sarch, strlen(sarch) - 4, 1));\n}\n\nvoid\nrepodata_set_idarray(Repodata *data, Id solvid, Id keyname, Queue *q)\n{\n  Repokey key;\n  int i;\n\n  key.name = keyname;\n  key.type = REPOKEY_TYPE_IDARRAY;\n  key.size = 0;\n  key.storage = KEY_STORAGE_INCORE;\n  repodata_set(data, solvid, &key, data->attriddatalen);\n  data->attriddata = solv_extend(data->attriddata, data->attriddatalen, q->count + 1, sizeof(Id), REPODATA_ATTRIDDATA_BLOCK);\n  for (i = 0; i < q->count; i++)\n    data->attriddata[data->attriddatalen++] = q->elements[i];\n  data->attriddata[data->attriddatalen++] = 0;\n}\n\nvoid\nrepodata_add_dirnumnum(Repodata *data, Id solvid, Id keyname, Id dir, Id num, Id num2)\n{\n  assert(dir);\n#if 0\nfprintf(stderr, \"repodata_add_dirnumnum %d %d %d %d (%d)\\n\", solvid, dir, num, num2, data->attriddatalen);\n#endif\n  repodata_add_array(data, solvid, keyname, REPOKEY_TYPE_DIRNUMNUMARRAY, 3);\n  data->attriddata[data->attriddatalen++] = dir;\n  data->attriddata[data->attriddatalen++] = num;\n  data->attriddata[data->attriddatalen++] = num2;\n  data->attriddata[data->attriddatalen++] = 0;\n}\n\nvoid\nrepodata_add_dirstr(Repodata *data, Id solvid, Id keyname, Id dir, const char *str)\n{\n  Id stroff;\n  int l;\n\n  assert(dir);\n  l = strlen(str) + 1;\n  data->attrdata = solv_extend(data->attrdata, data->attrdatalen, l, 1, REPODATA_ATTRDATA_BLOCK);\n  memcpy(data->attrdata + data->attrdatalen, str, l);\n  stroff = data->attrdatalen;\n  data->attrdatalen += l;\n\n#if 0\nfprintf(stderr, \"repodata_add_dirstr %d %d %s (%d)\\n\", solvid, dir, str,  data->attriddatalen);\n#endif\n  repodata_add_array(data, solvid, keyname, REPOKEY_TYPE_DIRSTRARRAY, 2);\n  data->attriddata[data->attriddatalen++] = dir;\n  data->attriddata[data->attriddatalen++] = stroff;\n  data->attriddata[data->attriddatalen++] = 0;\n}\n\nvoid\nrepodata_add_idarray(Repodata *data, Id solvid, Id keyname, Id id)\n{\n#if 0\nfprintf(stderr, \"repodata_add_idarray %d %d (%d)\\n\", solvid, id, data->attriddatalen);\n#endif\n  repodata_add_array(data, solvid, keyname, REPOKEY_TYPE_IDARRAY, 1);\n  data->attriddata[data->attriddatalen++] = id;\n  data->attriddata[data->attriddatalen++] = 0;\n}\n\nvoid\nrepodata_add_poolstr_array(Repodata *data, Id solvid, Id keyname,\n\t\t\t   const char *str)\n{\n  Id id;\n  if (data->localpool)\n    id = stringpool_str2id(&data->spool, str, 1);\n  else\n    id = pool_str2id(data->repo->pool, str, 1);\n  repodata_add_idarray(data, solvid, keyname, id);\n}\n\nvoid\nrepodata_add_fixarray(Repodata *data, Id solvid, Id keyname, Id handle)\n{\n  repodata_add_array(data, solvid, keyname, REPOKEY_TYPE_FIXARRAY, 1);\n  data->attriddata[data->attriddatalen++] = handle;\n  data->attriddata[data->attriddatalen++] = 0;\n}\n\nvoid\nrepodata_add_flexarray(Repodata *data, Id solvid, Id keyname, Id handle)\n{\n  repodata_add_array(data, solvid, keyname, REPOKEY_TYPE_FLEXARRAY, 1);\n  data->attriddata[data->attriddatalen++] = handle;\n  data->attriddata[data->attriddatalen++] = 0;\n}\n\nvoid\nrepodata_set_kv(Repodata *data, Id solvid, Id keyname, Id keytype, KeyValue *kv)\n{\n  switch (keytype)\n    {\n    case REPOKEY_TYPE_ID:\n      repodata_set_id(data, solvid, keyname, kv->id);\n      break;\n    case REPOKEY_TYPE_CONSTANTID:\n      repodata_set_constantid(data, solvid, keyname, kv->id);\n      break;\n    case REPOKEY_TYPE_IDARRAY:\n      repodata_add_idarray(data, solvid, keyname, kv->id);\n      break;\n    case REPOKEY_TYPE_STR:\n      repodata_set_str(data, solvid, keyname, kv->str);\n      break;\n    case REPOKEY_TYPE_VOID:\n      repodata_set_void(data, solvid, keyname);\n      break;\n    case REPOKEY_TYPE_NUM:\n      repodata_set_num(data, solvid, keyname, SOLV_KV_NUM64(kv));\n      break;\n    case REPOKEY_TYPE_CONSTANT:\n      repodata_set_constant(data, solvid, keyname, kv->num);\n      break;\n    case REPOKEY_TYPE_DIRNUMNUMARRAY:\n      if (kv->id)\n        repodata_add_dirnumnum(data, solvid, keyname, kv->id, kv->num, kv->num2);\n      break;\n    case REPOKEY_TYPE_DIRSTRARRAY:\n      repodata_add_dirstr(data, solvid, keyname, kv->id, kv->str);\n      break;\n    case_CHKSUM_TYPES:\n      repodata_set_bin_checksum(data, solvid, keyname, keytype, (const unsigned char *)kv->str);\n      break;\n    default:\n      break;\n    }\n}\n\nvoid\nrepodata_unset_uninternalized(Repodata *data, Id solvid, Id keyname)\n{\n  Id *pp, *ap, **app;\n  app = repodata_get_attrp(data, solvid);\n  ap = *app;\n  if (!ap)\n    return;\n  if (!keyname)\n    {\n      *app = 0;\t\t/* delete all attributes */\n      return;\n    }\n  for (; *ap; ap += 2)\n    if (data->keys[*ap].name == keyname)\n      break;\n  if (!*ap)\n    return;\n  pp = ap;\n  ap += 2;\n  for (; *ap; ap += 2)\n    {\n      if (data->keys[*ap].name == keyname)\n\tcontinue;\n      *pp++ = ap[0];\n      *pp++ = ap[1];\n    }\n  *pp = 0;\n}\n\nvoid\nrepodata_unset(Repodata *data, Id solvid, Id keyname)\n{\n  Repokey key;\n  key.name = keyname;\n  key.type = REPOKEY_TYPE_DELETED;\n  key.size = 0;\n  key.storage = KEY_STORAGE_INCORE;\n  repodata_set(data, solvid, &key, 0);\n}\n\n/* add all (uninternalized) attrs from src to dest */\nvoid\nrepodata_merge_attrs(Repodata *data, Id dest, Id src)\n{\n  Id *keyp;\n  if (dest == src || !data->attrs || !(keyp = data->attrs[src - data->start]))\n    return;\n  for (; *keyp; keyp += 2)\n    repodata_insert_keyid(data, dest, keyp[0], keyp[1], 0);\n}\n\n/* add some (uninternalized) attrs from src to dest */\nvoid\nrepodata_merge_some_attrs(Repodata *data, Id dest, Id src, Map *keyidmap, int overwrite)\n{\n  Id *keyp;\n  if (dest == src || !data->attrs || !(keyp = data->attrs[src - data->start]))\n    return;\n  for (; *keyp; keyp += 2)\n    if (!keyidmap || MAPTST(keyidmap, keyp[0]))\n      repodata_insert_keyid(data, dest, keyp[0], keyp[1], overwrite);\n}\n\n/* swap (uninternalized) attrs from src and dest */\nvoid\nrepodata_swap_attrs(Repodata *data, Id dest, Id src)\n{\n  Id *tmpattrs;\n  if (!data->attrs || dest == src)\n    return;\n  if (dest < data->start || dest >= data->end)\n    repodata_extend(data, dest);\n  if (src < data->start || src >= data->end)\n    repodata_extend(data, src);\n  tmpattrs = data->attrs[dest - data->start];\n  data->attrs[dest - data->start] = data->attrs[src - data->start];\n  data->attrs[src - data->start] = tmpattrs;\n}\n\n\n/**********************************************************************/\n\n/* TODO: unify with repo_write and repo_solv! */\n\n#define EXTDATA_BLOCK 1023\n\nstruct extdata {\n  unsigned char *buf;\n  int len;\n};\n\nstatic void\ndata_addid(struct extdata *xd, Id sx)\n{\n  unsigned int x = (unsigned int)sx;\n  unsigned char *dp;\n\n  xd->buf = solv_extend(xd->buf, xd->len, 5, 1, EXTDATA_BLOCK);\n  dp = xd->buf + xd->len;\n\n  if (x >= (1 << 14))\n    {\n      if (x >= (1 << 28))\n        *dp++ = (x >> 28) | 128;\n      if (x >= (1 << 21))\n        *dp++ = (x >> 21) | 128;\n      *dp++ = (x >> 14) | 128;\n    }\n  if (x >= (1 << 7))\n    *dp++ = (x >> 7) | 128;\n  *dp++ = x & 127;\n  xd->len = dp - xd->buf;\n}\n\nstatic void\ndata_addid64(struct extdata *xd, unsigned long long x)\n{\n  if (x >= 0x100000000)\n    {\n      if ((x >> 35) != 0)\n\t{\n\t  data_addid(xd, (Id)(x >> 35));\n\t  xd->buf[xd->len - 1] |= 128;\n\t}\n      data_addid(xd, (Id)((unsigned int)x | 0x80000000));\n      xd->buf[xd->len - 5] = (x >> 28) | 128;\n    }\n  else\n    data_addid(xd, (Id)x);\n}\n\nstatic void\ndata_addideof(struct extdata *xd, Id sx, int eof)\n{\n  unsigned int x = (unsigned int)sx;\n  unsigned char *dp;\n\n  xd->buf = solv_extend(xd->buf, xd->len, 5, 1, EXTDATA_BLOCK);\n  dp = xd->buf + xd->len;\n\n  if (x >= (1 << 13))\n    {\n      if (x >= (1 << 27))\n        *dp++ = (x >> 27) | 128;\n      if (x >= (1 << 20))\n        *dp++ = (x >> 20) | 128;\n      *dp++ = (x >> 13) | 128;\n    }\n  if (x >= (1 << 6))\n    *dp++ = (x >> 6) | 128;\n  *dp++ = eof ? (x & 63) : (x & 63) | 64;\n  xd->len = dp - xd->buf;\n}\n\nstatic void\ndata_addblob(struct extdata *xd, unsigned char *blob, int len)\n{\n  xd->buf = solv_extend(xd->buf, xd->len, len, 1, EXTDATA_BLOCK);\n  memcpy(xd->buf + xd->len, blob, len);\n  xd->len += len;\n}\n\n/*********************************/\n\n/* this is to reduct memory usage when internalizing oversized repos */\nstatic void\ncompact_attrdata(Repodata *data, int entry, int nentry)\n{\n  int i;\n  unsigned int attrdatastart = data->attrdatalen;\n  unsigned int attriddatastart = data->attriddatalen;\n  if (attrdatastart < 1024 * 1024 * 4 && attriddatastart < 1024 * 1024)\n    return;\n  for (i = entry; i < nentry; i++)\n    {\n      Id v, *attrs = data->attrs[i];\n      if (!attrs)\n\tcontinue;\n      for (; *attrs; attrs += 2)\n\t{\n\t  switch (data->keys[*attrs].type)\n\t    {\n\t    case REPOKEY_TYPE_STR:\n\t    case REPOKEY_TYPE_BINARY:\n\t    case_CHKSUM_TYPES:\n\t      if ((unsigned int)attrs[1] < attrdatastart)\n\t\t attrdatastart = attrs[1];\n\t      break;\n\t    case REPOKEY_TYPE_DIRSTRARRAY:\n\t      for (v = attrs[1]; data->attriddata[v] ; v += 2)\n\t\tif ((unsigned int)data->attriddata[v + 1] < attrdatastart)\n\t\t  attrdatastart = data->attriddata[v + 1];\n\t      /* FALLTHROUGH */\n\t    case REPOKEY_TYPE_IDARRAY:\n\t    case REPOKEY_TYPE_DIRNUMNUMARRAY:\n\t      if ((unsigned int)attrs[1] < attriddatastart)\n\t\tattriddatastart = attrs[1];\n\t      break;\n\t    case REPOKEY_TYPE_FIXARRAY:\n\t    case REPOKEY_TYPE_FLEXARRAY:\n\t      return;\n\t    default:\n\t      break;\n\t    }\n\t}\n    }\n#if 0\n  printf(\"compact_attrdata %d %d\\n\", entry, nentry);\n  printf(\"attrdatastart: %d\\n\", attrdatastart);\n  printf(\"attriddatastart: %d\\n\", attriddatastart);\n#endif\n  if (attrdatastart < 1024 * 1024 * 4 && attriddatastart < 1024 * 1024)\n    return;\n  for (i = entry; i < nentry; i++)\n    {\n      Id v, *attrs = data->attrs[i];\n      if (!attrs)\n\tcontinue;\n      for (; *attrs; attrs += 2)\n\t{\n\t  switch (data->keys[*attrs].type)\n\t    {\n\t    case REPOKEY_TYPE_STR:\n\t    case REPOKEY_TYPE_BINARY:\n\t    case_CHKSUM_TYPES:\n\t      attrs[1] -= attrdatastart;\n\t      break;\n\t    case REPOKEY_TYPE_DIRSTRARRAY:\n\t      for (v = attrs[1]; data->attriddata[v] ; v += 2)\n\t\tdata->attriddata[v + 1] -= attrdatastart;\n\t      /* FALLTHROUGH */\n\t    case REPOKEY_TYPE_IDARRAY:\n\t    case REPOKEY_TYPE_DIRNUMNUMARRAY:\n\t      attrs[1] -= attriddatastart;\n\t      break;\n\t    default:\n\t      break;\n\t    }\n\t}\n    }\n  if (attrdatastart)\n    {\n      data->attrdatalen -= attrdatastart;\n      memmove(data->attrdata, data->attrdata + attrdatastart, data->attrdatalen);\n      data->attrdata = solv_extend_resize(data->attrdata, data->attrdatalen, 1, REPODATA_ATTRDATA_BLOCK);\n    }\n  if (attriddatastart)\n    {\n      data->attriddatalen -= attriddatastart;\n      memmove(data->attriddata, data->attriddata + attriddatastart, data->attriddatalen * sizeof(Id));\n      data->attriddata = solv_extend_resize(data->attriddata, data->attriddatalen, sizeof(Id), REPODATA_ATTRIDDATA_BLOCK);\n    }\n}\n\n/* internalalize some key into incore/vincore data */\n\nstatic void\nrepodata_serialize_key(Repodata *data, struct extdata *newincore,\n\t\t       struct extdata *newvincore,\n\t\t       Id *schema,\n\t\t       Repokey *key, Id val)\n{\n  Id *ida;\n  struct extdata *xd;\n  unsigned int oldvincorelen = 0;\n  Id schemaid, *sp;\n\n  xd = newincore;\n  if (key->storage == KEY_STORAGE_VERTICAL_OFFSET)\n    {\n      xd = newvincore;\n      oldvincorelen = xd->len;\n    }\n  switch (key->type)\n    {\n    case REPOKEY_TYPE_VOID:\n    case REPOKEY_TYPE_CONSTANT:\n    case REPOKEY_TYPE_CONSTANTID:\n    case REPOKEY_TYPE_DELETED:\n      break;\n    case REPOKEY_TYPE_STR:\n      data_addblob(xd, data->attrdata + val, strlen((char *)(data->attrdata + val)) + 1);\n      break;\n    case REPOKEY_TYPE_MD5:\n      data_addblob(xd, data->attrdata + val, SIZEOF_MD5);\n      break;\n    case REPOKEY_TYPE_SHA1:\n      data_addblob(xd, data->attrdata + val, SIZEOF_SHA1);\n      break;\n    case REPOKEY_TYPE_SHA224:\n      data_addblob(xd, data->attrdata + val, SIZEOF_SHA224);\n      break;\n    case REPOKEY_TYPE_SHA256:\n      data_addblob(xd, data->attrdata + val, SIZEOF_SHA256);\n      break;\n    case REPOKEY_TYPE_SHA384:\n      data_addblob(xd, data->attrdata + val, SIZEOF_SHA384);\n      break;\n    case REPOKEY_TYPE_SHA512:\n      data_addblob(xd, data->attrdata + val, SIZEOF_SHA512);\n      break;\n    case REPOKEY_TYPE_NUM:\n      if (val & 0x80000000)\n\t{\n\t  data_addid64(xd, data->attrnum64data[val ^ 0x80000000]);\n\t  break;\n\t}\n      /* FALLTHROUGH */\n    case REPOKEY_TYPE_ID:\n    case REPOKEY_TYPE_DIR:\n      data_addid(xd, val);\n      break;\n    case REPOKEY_TYPE_BINARY:\n      {\n\tId len;\n\tunsigned char *dp = data_read_id(data->attrdata + val, &len);\n\tdp += (unsigned int)len;\n\tdata_addblob(xd, data->attrdata + val, dp - (data->attrdata + val));\n      }\n      break;\n    case REPOKEY_TYPE_IDARRAY:\n      for (ida = data->attriddata + val; *ida; ida++)\n\tdata_addideof(xd, ida[0], ida[1] ? 0 : 1);\n      break;\n    case REPOKEY_TYPE_DIRNUMNUMARRAY:\n      for (ida = data->attriddata + val; *ida; ida += 3)\n\t{\n\t  data_addid(xd, ida[0]);\n\t  data_addid(xd, ida[1]);\n\t  data_addideof(xd, ida[2], ida[3] ? 0 : 1);\n\t}\n      break;\n    case REPOKEY_TYPE_DIRSTRARRAY:\n      for (ida = data->attriddata + val; *ida; ida += 2)\n\t{\n\t  data_addideof(xd, ida[0], ida[2] ? 0 : 1);\n\t  data_addblob(xd, data->attrdata + ida[1], strlen((char *)(data->attrdata + ida[1])) + 1);\n\t}\n      break;\n    case REPOKEY_TYPE_FIXARRAY:\n      {\n\tint num = 0;\n\tschemaid = 0;\n\tfor (ida = data->attriddata + val; *ida; ida++)\n\t  {\n\t    Id *kp;\n\t    sp = schema;\n\t    kp = data->xattrs[-*ida];\n\t    if (!kp)\n\t      continue;\t\t/* ignore empty elements */\n\t    num++;\n\t    for (; *kp; kp += 2)\n\t      *sp++ = *kp;\n\t    *sp = 0;\n\t    if (!schemaid)\n\t      schemaid = repodata_schema2id(data, schema, 1);\n\t    else if (schemaid != repodata_schema2id(data, schema, 0))\n\t      {\n\t \tpool_debug(data->repo->pool, SOLV_ERROR, \"repodata_serialize_key: fixarray substructs with different schemas\\n\");\n\t\tnum = 0;\n\t\tbreak;\n\t      }\n\t  }\n\tdata_addid(xd, num);\n\tif (!num)\n\t  break;\n\tdata_addid(xd, schemaid);\n\tfor (ida = data->attriddata + val; *ida; ida++)\n\t  {\n\t    Id *kp = data->xattrs[-*ida];\n\t    if (!kp)\n\t      continue;\n\t    for (; *kp; kp += 2)\n\t      repodata_serialize_key(data, newincore, newvincore, schema, data->keys + *kp, kp[1]);\n\t  }\n\tbreak;\n      }\n    case REPOKEY_TYPE_FLEXARRAY:\n      {\n\tint num = 0;\n\tfor (ida = data->attriddata + val; *ida; ida++)\n\t  num++;\n\tdata_addid(xd, num);\n\tfor (ida = data->attriddata + val; *ida; ida++)\n\t  {\n\t    Id *kp = data->xattrs[-*ida];\n\t    if (!kp)\n\t      {\n\t        data_addid(xd, 0);\t/* XXX */\n\t        continue;\n\t      }\n\t    sp = schema;\n\t    for (;*kp; kp += 2)\n\t      *sp++ = *kp;\n\t    *sp = 0;\n\t    schemaid = repodata_schema2id(data, schema, 1);\n\t    data_addid(xd, schemaid);\n\t    kp = data->xattrs[-*ida];\n\t    for (;*kp; kp += 2)\n\t      repodata_serialize_key(data, newincore, newvincore, schema, data->keys + *kp, kp[1]);\n\t  }\n\tbreak;\n      }\n    default:\n      pool_debug(data->repo->pool, SOLV_FATAL, \"repodata_serialize_key: don't know how to handle type %d\\n\", key->type);\n      exit(1);\n    }\n  if (key->storage == KEY_STORAGE_VERTICAL_OFFSET)\n    {\n      /* put offset/len in incore */\n      data_addid(newincore, data->lastverticaloffset + oldvincorelen);\n      oldvincorelen = xd->len - oldvincorelen;\n      data_addid(newincore, oldvincorelen);\n    }\n}\n\n/* create a circular linked list of all keys that share\n * the same keyname */\nstatic Id *\ncalculate_keylink(Repodata *data)\n{\n  int i, j;\n  Id *link;\n  Id maxkeyname = 0, *keytable = 0;\n  link = solv_calloc(data->nkeys, sizeof(Id));\n  if (data->nkeys <= 2)\n    return link;\n  for (i = 1; i < data->nkeys; i++)\n    {\n      Id n = data->keys[i].name;\n      if (n >= maxkeyname)\n\t{\n\t  keytable = solv_realloc2(keytable, n + 128, sizeof(Id));\n\t  memset(keytable + maxkeyname, 0, (n + 128 - maxkeyname) * sizeof(Id));\n\t  maxkeyname = n + 128;\n\t}\n      j = keytable[n];\n      if (j)\n\tlink[i] = link[j];\n      else\n\tj = i;\n      link[j] = i;\n      keytable[n] = i;\n    }\n  /* remove links that just point to themselfs */\n  for (i = 1; i < data->nkeys; i++)\n    if (link[i] == i)\n      link[i] = 0;\n  solv_free(keytable);\n  return link;\n}\n\nvoid\nrepodata_internalize(Repodata *data)\n{\n  Repokey *key, solvkey;\n  Id entry, nentry;\n  Id schemaid, keyid, *schema, *sp, oldschemaid, *keyp, *seen;\n  Offset *oldincoreoffs = 0;\n  int schemaidx;\n  unsigned char *dp, *ndp;\n  int neednewschema;\n  struct extdata newincore;\n  struct extdata newvincore;\n  Id solvkeyid;\n  Id *keylink;\n  int haveoldkl;\n\n  if (!data->attrs && !data->xattrs)\n    return;\n\n#if 0\n  printf(\"repodata_internalize %d\\n\", data->repodataid);\n  printf(\"  attr data: %d K\\n\", data->attrdatalen / 1024);\n  printf(\"  attrid data: %d K\\n\", data->attriddatalen / (1024 / 4));\n#endif\n  newvincore.buf = data->vincore;\n  newvincore.len = data->vincorelen;\n\n  /* find the solvables key, create if needed */\n  memset(&solvkey, 0, sizeof(solvkey));\n  solvkey.name = REPOSITORY_SOLVABLES;\n  solvkey.type = REPOKEY_TYPE_FLEXARRAY;\n  solvkey.size = 0;\n  solvkey.storage = KEY_STORAGE_INCORE;\n  solvkeyid = repodata_key2id(data, &solvkey, data->end != data->start ? 1 : 0);\n\n  schema = solv_malloc2(data->nkeys, sizeof(Id));\n  seen = solv_malloc2(data->nkeys, sizeof(Id));\n\n  /* Merge the data already existing (in data->schemata, ->incoredata and\n     friends) with the new attributes in data->attrs[].  */\n  nentry = data->end - data->start;\n  memset(&newincore, 0, sizeof(newincore));\n  data_addid(&newincore, 0);\t/* start data at offset 1 */\n\n  data->mainschema = 0;\n  data->mainschemaoffsets = solv_free(data->mainschemaoffsets);\n\n  keylink = calculate_keylink(data);\n  /* join entry data */\n  /* we start with the meta data, entry -1 */\n  for (entry = -1; entry < nentry; entry++)\n    {\n      oldschemaid = 0;\n      dp = data->incoredata;\n      if (dp)\n\t{\n\t  dp += entry >= 0 ? data->incoreoffset[entry] : 1;\n          dp = data_read_id(dp, &oldschemaid);\n\t}\n      memset(seen, 0, data->nkeys * sizeof(Id));\n#if 0\nfprintf(stderr, \"oldschemaid %d\\n\", oldschemaid);\nfprintf(stderr, \"schemata %d\\n\", data->schemata[oldschemaid]);\nfprintf(stderr, \"schemadata %p\\n\", data->schemadata);\n#endif\n\n      /* seen: -1: old data,  0: skipped,  >0: id + 1 */\n      neednewschema = 0;\n      sp = schema;\n      haveoldkl = 0;\n      for (keyp = data->schemadata + data->schemata[oldschemaid]; *keyp; keyp++)\n\t{\n\t  if (seen[*keyp])\n\t    {\n\t      /* oops, should not happen */\n\t      neednewschema = 1;\n\t      continue;\n\t    }\n\t  seen[*keyp] = -1;\t/* use old marker */\n\t  *sp++ = *keyp;\n\t  if (keylink[*keyp])\n\t    haveoldkl = 1;\t/* potential keylink conflict */\n\t}\n\n      /* strip solvables key */\n      if (entry < 0 && solvkeyid && seen[solvkeyid])\n\t{\n\t  *sp = 0;\n\t  for (sp = keyp = schema; *sp; sp++)\n\t    if (*sp != solvkeyid)\n\t      *keyp++ = *sp;\n\t  sp = keyp;\n\t  seen[solvkeyid] = 0;\n\t  neednewschema = 1;\n\t}\n\n      /* add new entries */\n      if (entry >= 0)\n\tkeyp = data->attrs ? data->attrs[entry] : 0;\n      else\n        keyp = data->xattrs ? data->xattrs[1] : 0;\n      if (keyp)\n        for (; *keyp; keyp += 2)\n\t  {\n\t    if (!seen[*keyp])\n\t      {\n\t        neednewschema = 1;\n\t        *sp++ = *keyp;\n\t\tif (haveoldkl && keylink[*keyp])\t\t/* this should be pretty rare */\n\t\t  {\n\t\t    Id kl;\n\t\t    for (kl = keylink[*keyp]; kl != *keyp; kl = keylink[kl])\n\t\t      if (seen[kl] == -1)\n\t\t        {\n\t\t\t  /* replacing old key kl, remove from schema and seen */\n\t\t\t  Id *osp;\n\t\t\t  for (osp = schema; osp < sp; osp++)\n\t\t\t    if (*osp == kl)\n\t\t\t      {\n\t\t\t        memmove(osp, osp + 1, (sp - osp) * sizeof(Id));\n\t\t\t        sp--;\n\t\t\t        seen[kl] = 0;\n\t\t\t\tbreak;\n\t\t\t      }\n\t\t        }\n\t\t  }\n\t      }\n\t    seen[*keyp] = keyp[1] + 1;\n\t  }\n\n      /* add solvables key if needed */\n      if (entry < 0 && data->end != data->start)\n\t{\n\t  *sp++ = solvkeyid;\t/* always last in schema */\n\t  neednewschema = 1;\n\t}\n\n      /* commit schema */\n      *sp = 0;\n      if (neednewschema)\n        /* Ideally we'd like to sort the new schema here, to ensure\n\t   schema equality independend of the ordering. */\n\tschemaid = repodata_schema2id(data, schema, 1);\n      else\n\tschemaid = oldschemaid;\n\n      if (entry < 0)\n\t{\n\t  data->mainschemaoffsets = solv_calloc(sp - schema, sizeof(Id));\n\t  data->mainschema = schemaid;\n\t}\n\n      /* find offsets in old incore data */\n      if (oldschemaid)\n\t{\n\t  Id *lastneeded = 0;\n\t  for (sp = data->schemadata + data->schemata[oldschemaid]; *sp; sp++)\n\t    if (seen[*sp] == -1)\n\t      lastneeded = sp + 1;\n\t  if (lastneeded)\n\t    {\n\t      if (!oldincoreoffs)\n\t        oldincoreoffs = solv_malloc2(data->nkeys, 2 * sizeof(Offset));\n\t      for (sp = data->schemadata + data->schemata[oldschemaid]; sp != lastneeded; sp++)\n\t\t{\n\t\t  /* Skip the data associated with this old key.  */\n\t\t  key = data->keys + *sp;\n\t\t  ndp = dp;\n\t\t  if (key->storage == KEY_STORAGE_VERTICAL_OFFSET)\n\t\t    {\n\t\t      ndp = data_skip(ndp, REPOKEY_TYPE_ID);\n\t\t      ndp = data_skip(ndp, REPOKEY_TYPE_ID);\n\t\t    }\n\t\t  else if (key->storage == KEY_STORAGE_INCORE)\n\t\t    ndp = data_skip_key(data, ndp, key);\n\t\t  oldincoreoffs[*sp * 2] = dp - data->incoredata;\n\t\t  oldincoreoffs[*sp * 2 + 1] = ndp - dp;\n\t\t  dp = ndp;\n\t\t}\n\t    }\n\t}\n\n      /* just copy over the complete old entry (including the schemaid) if there was no new data */\n      if (entry >= 0 && !neednewschema && oldschemaid && (!data->attrs || !data->attrs[entry]) && dp)\n\t{\n\t  ndp = data->incoredata + data->incoreoffset[entry];\n\t  data->incoreoffset[entry] = newincore.len;\n\t  data_addblob(&newincore, ndp, dp - ndp);\n\t  goto entrydone;\n\t}\n\n      /* Now create data blob.  We walk through the (possibly new) schema\n\t and either copy over old data, or insert the new.  */\n      if (entry >= 0)\n        data->incoreoffset[entry] = newincore.len;\n      data_addid(&newincore, schemaid);\n\n      /* we don't use a pointer to the schemadata here as repodata_serialize_key\n       * may call repodata_schema2id() which might realloc our schemadata */\n      for (schemaidx = data->schemata[schemaid]; (keyid = data->schemadata[schemaidx]) != 0; schemaidx++)\n\t{\n\t  if (entry < 0)\n\t    {\n\t      data->mainschemaoffsets[schemaidx - data->schemata[schemaid]] = newincore.len;\n\t      if (keyid == solvkeyid)\n\t\t{\n\t\t  /* add flexarray entry count */\n\t\t  data_addid(&newincore, data->end - data->start);\n\t\t  break;\t/* always the last entry */\n\t\t}\n\t    }\n\t  if (seen[keyid] == -1)\n\t    {\n\t      if (oldincoreoffs[keyid * 2 + 1])\n\t\tdata_addblob(&newincore, data->incoredata + oldincoreoffs[keyid * 2], oldincoreoffs[keyid * 2 + 1]);\n\t    }\n\t  else if (seen[keyid])\n\t    repodata_serialize_key(data, &newincore, &newvincore, schema, data->keys + keyid, seen[keyid] - 1);\n\t}\n\nentrydone:\n      /* free memory */\n      if (entry >= 0 && data->attrs)\n\t{\n\t  if (data->attrs[entry])\n\t    data->attrs[entry] = solv_free(data->attrs[entry]);\n\t  if (entry && entry % 4096 == 0 && data->nxattrs <= 2 && entry + 64 < nentry)\n\t    {\n\t      compact_attrdata(data, entry + 1, nentry);\t/* try to free some memory */\n#if 0\n\t      printf(\"  attr data: %d K\\n\", data->attrdatalen / 1024);\n\t      printf(\"  attrid data: %d K\\n\", data->attriddatalen / (1024 / 4));\n\t      printf(\"  incore data: %d K\\n\", newincore.len / 1024);\n\t      printf(\"  sum: %d K\\n\", (newincore.len + data->attrdatalen + data->attriddatalen * 4) / 1024);\n\t      /* malloc_stats(); */\n#endif\n\t    }\n\t}\n    }\n  /* free all xattrs */\n  for (entry = 0; entry < data->nxattrs; entry++)\n    if (data->xattrs[entry])\n      solv_free(data->xattrs[entry]);\n  data->xattrs = solv_free(data->xattrs);\n  data->nxattrs = 0;\n\n  data->lasthandle = 0;\n  data->lastkey = 0;\n  data->lastdatalen = 0;\n  solv_free(schema);\n  solv_free(seen);\n  solv_free(keylink);\n  solv_free(oldincoreoffs);\n  repodata_free_schemahash(data);\n\n  solv_free(data->incoredata);\n  data->incoredata = newincore.buf;\n  data->incoredatalen = newincore.len;\n  data->incoredatafree = 0;\n\n  data->vincore = newvincore.buf;\n  data->vincorelen = newvincore.len;\n\n  data->attrs = solv_free(data->attrs);\n  data->attrdata = solv_free(data->attrdata);\n  data->attriddata = solv_free(data->attriddata);\n  data->attrnum64data = solv_free(data->attrnum64data);\n  data->attrdatalen = 0;\n  data->attriddatalen = 0;\n  data->attrnum64datalen = 0;\n#if 0\n  printf(\"repodata_internalize %d done\\n\", data->repodataid);\n  printf(\"  incore data: %d K\\n\", data->incoredatalen / 1024);\n#endif\n}\n\nvoid\nrepodata_disable_paging(Repodata *data)\n{\n  if (maybe_load_repodata(data, 0))\n    {\n      repopagestore_disable_paging(&data->store);\n      data->storestate++;\n    }\n}\n\n/* call the pool's loadcallback to load a stub repodata */\nstatic void\nrepodata_stub_loader(Repodata *data)\n{\n  Repo *repo = data->repo;\n  Pool *pool = repo->pool;\n  int r, i;\n  struct s_Pool_tmpspace oldtmpspace;\n  Datapos oldpos;\n\n  if (!pool->loadcallback)\n    {\n      data->state = REPODATA_ERROR;\n      return;\n    }\n  data->state = REPODATA_LOADING;\n\n  /* save tmp space and pos */\n  oldtmpspace = pool->tmpspace;\n  memset(&pool->tmpspace, 0, sizeof(pool->tmpspace));\n  oldpos = pool->pos;\n\n  r = pool->loadcallback(pool, data, pool->loadcallbackdata);\n\n  /* restore tmp space and pos */\n  for (i = 0; i < POOL_TMPSPACEBUF; i++)\n    solv_free(pool->tmpspace.buf[i]);\n  pool->tmpspace = oldtmpspace;\n  if (r && oldpos.repo == repo && oldpos.repodataid == data->repodataid)\n    memset(&oldpos, 0, sizeof(oldpos));\n  pool->pos = oldpos;\n\n  data->state = r ? REPODATA_AVAILABLE : REPODATA_ERROR;\n}\n\nstatic inline void\nrepodata_add_stubkey(Repodata *data, Id keyname, Id keytype)\n{\n  Repokey xkey;\n\n  xkey.name = keyname;\n  xkey.type = keytype;\n  xkey.storage = KEY_STORAGE_INCORE;\n  xkey.size = 0;\n  repodata_key2id(data, &xkey, 1);\n}\n\nstatic Repodata *\nrepodata_add_stub(Repodata **datap)\n{\n  Repodata *data = *datap;\n  Repo *repo = data->repo;\n  Id repodataid = data - repo->repodata;\n  Repodata *sdata = repo_add_repodata(repo, 0);\n  data = repo->repodata + repodataid;\n  if (data->end > data->start)\n    repodata_extend_block(sdata, data->start, data->end - data->start);\n  sdata->state = REPODATA_STUB;\n  sdata->loadcallback = repodata_stub_loader;\n  *datap = data;\n  return sdata;\n}\n\nRepodata *\nrepodata_create_stubs(Repodata *data)\n{\n  Repo *repo = data->repo;\n  Pool *pool = repo->pool;\n  Repodata *sdata;\n  int *stubdataids;\n  Dataiterator di;\n  Id xkeyname = 0;\n  int i, cnt = 0;\n\n  dataiterator_init(&di, pool, repo, SOLVID_META, REPOSITORY_EXTERNAL, 0, 0);\n  while (dataiterator_step(&di))\n    if (di.data == data)\n      cnt++;\n  dataiterator_free(&di);\n  if (!cnt)\n    return data;\n  stubdataids = solv_calloc(cnt, sizeof(*stubdataids));\n  for (i = 0; i < cnt; i++)\n    {\n      sdata = repodata_add_stub(&data);\n      stubdataids[i] = sdata - repo->repodata;\n    }\n  i = 0;\n  dataiterator_init(&di, pool, repo, SOLVID_META, REPOSITORY_EXTERNAL, 0, 0);\n  sdata = 0;\n  while (dataiterator_step(&di))\n    {\n      if (di.data != data)\n\tcontinue;\n      if (di.key->name == REPOSITORY_EXTERNAL && !di.nparents)\n\t{\n\t  dataiterator_entersub(&di);\n\t  sdata = repo->repodata + stubdataids[i++];\n\t  xkeyname = 0;\n\t  continue;\n\t}\n      repodata_set_kv(sdata, SOLVID_META, di.key->name, di.key->type, &di.kv);\n      if (di.key->name == REPOSITORY_KEYS && di.key->type == REPOKEY_TYPE_IDARRAY)\n\t{\n\t  if (!xkeyname)\n\t    {\n\t      if (!di.kv.eof)\n\t\txkeyname = di.kv.id;\n\t    }\n\t  else\n\t    {\n\t      repodata_add_stubkey(sdata, xkeyname, di.kv.id);\n\t      if (xkeyname == SOLVABLE_FILELIST)\n\t        repodata_set_filelisttype(sdata, REPODATA_FILELIST_EXTENSION);\n\t      xkeyname = 0;\n\t    }\n\t}\n    }\n  dataiterator_free(&di);\n  for (i = 0; i < cnt; i++)\n    repodata_internalize(repo->repodata + stubdataids[i]);\n  solv_free(stubdataids);\n  return data;\n}\n\nvoid\nrepodata_set_filelisttype(Repodata *data, int type)\n{\n  data->filelisttype = type;\n}\n\nunsigned int\nrepodata_memused(Repodata *data)\n{\n  return data->incoredatalen + data->vincorelen;\n}\n\n"], "filenames": ["src/repodata.c"], "buggy_code_start_loc": [214], "buggy_code_end_loc": [219], "fixing_code_start_loc": [214], "fixing_code_end_loc": [221], "type": "CWE-125", "message": "repodata_schema2id in repodata.c in libsolv before 0.7.6 has a heap-based buffer over-read via a last schema whose length is less than the length of the input schema.", "other": {"cve": {"id": "CVE-2019-20387", "sourceIdentifier": "cve@mitre.org", "published": "2020-01-21T23:15:13.443", "lastModified": "2023-01-31T20:49:33.477", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "repodata_schema2id in repodata.c in libsolv before 0.7.6 has a heap-based buffer over-read via a last schema whose length is less than the length of the input schema."}, {"lang": "es", "value": "La funci\u00f3n repodata_schema2id en el archivo repodata.c en libsolv versiones anteriores a 0.7.6, presenta una lectura excesiva del b\u00fafer en la regi\u00f3n heap de la memoria por medio de un \u00faltimo esquema cuya longitud es menor que la longitud del esquema de entrada."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensuse:libsolv:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.7.6", "matchCriteriaId": "F01002F4-871E-4948-A57B-F8C0D6D04267"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "https://github.com/openSUSE/libsolv/commit/fdb9c9c03508990e4583046b590c30d958f272da", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/openSUSE/libsolv/compare/0.7.5...0.7.6", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/01/msg00034.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openSUSE/libsolv/commit/fdb9c9c03508990e4583046b590c30d958f272da"}}