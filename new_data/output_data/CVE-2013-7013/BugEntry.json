{"buggy_code": ["/*\n * Go2Webinar decoder\n * Copyright (c) 2012 Konstantin Shishkov\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * Go2Webinar decoder\n */\n\n#include <zlib.h>\n\n#include \"libavutil/intreadwrite.h\"\n#include \"avcodec.h\"\n#include \"bytestream.h\"\n#include \"dsputil.h\"\n#include \"get_bits.h\"\n#include \"internal.h\"\n#include \"mjpeg.h\"\n\nenum ChunkType {\n    FRAME_INFO = 0xC8,\n    TILE_DATA,\n    CURSOR_POS,\n    CURSOR_SHAPE,\n    CHUNK_CC,\n    CHUNK_CD\n};\n\nenum Compression {\n    COMPR_EPIC_J_B = 2,\n    COMPR_KEMPF_J_B,\n};\n\nstatic const uint8_t luma_quant[64] = {\n     8,  6,  5,  8, 12, 20, 26, 31,\n     6,  6,  7, 10, 13, 29, 30, 28,\n     7,  7,  8, 12, 20, 29, 35, 28,\n     7,  9, 11, 15, 26, 44, 40, 31,\n     9, 11, 19, 28, 34, 55, 52, 39,\n    12, 18, 28, 32, 41, 52, 57, 46,\n    25, 32, 39, 44, 52, 61, 60, 51,\n    36, 46, 48, 49, 56, 50, 52, 50\n};\n\nstatic const uint8_t chroma_quant[64] = {\n     9,  9, 12, 24, 50, 50, 50, 50,\n     9, 11, 13, 33, 50, 50, 50, 50,\n    12, 13, 28, 50, 50, 50, 50, 50,\n    24, 33, 50, 50, 50, 50, 50, 50,\n    50, 50, 50, 50, 50, 50, 50, 50,\n    50, 50, 50, 50, 50, 50, 50, 50,\n    50, 50, 50, 50, 50, 50, 50, 50,\n    50, 50, 50, 50, 50, 50, 50, 50,\n};\n\ntypedef struct JPGContext {\n    DSPContext dsp;\n    ScanTable  scantable;\n\n    VLC        dc_vlc[2], ac_vlc[2];\n    int        prev_dc[3];\n    DECLARE_ALIGNED(16, int16_t, block)[6][64];\n\n    uint8_t    *buf;\n} JPGContext;\n\ntypedef struct G2MContext {\n    JPGContext jc;\n    int        version;\n\n    int        compression;\n    int        width, height, bpp;\n    int        tile_width, tile_height;\n    int        tiles_x, tiles_y, tile_x, tile_y;\n\n    int        got_header;\n\n    uint8_t    *framebuf;\n    int        framebuf_stride, old_width, old_height;\n\n    uint8_t    *synth_tile, *jpeg_tile;\n    int        tile_stride, old_tile_w, old_tile_h;\n\n    uint8_t    *kempf_buf, *kempf_flags;\n\n    uint8_t    *cursor;\n    int        cursor_stride;\n    int        cursor_fmt;\n    int        cursor_w, cursor_h, cursor_x, cursor_y;\n    int        cursor_hot_x, cursor_hot_y;\n} G2MContext;\n\nstatic av_cold int build_vlc(VLC *vlc, const uint8_t *bits_table,\n                             const uint8_t *val_table, int nb_codes,\n                             int is_ac)\n{\n    uint8_t  huff_size[256] = { 0 };\n    uint16_t huff_code[256];\n    uint16_t huff_sym[256];\n    int i;\n\n    ff_mjpeg_build_huffman_codes(huff_size, huff_code, bits_table, val_table);\n\n    for (i = 0; i < 256; i++)\n        huff_sym[i] = i + 16 * is_ac;\n\n    if (is_ac)\n        huff_sym[0] = 16 * 256;\n\n    return ff_init_vlc_sparse(vlc, 9, nb_codes, huff_size, 1, 1,\n                              huff_code, 2, 2, huff_sym, 2, 2, 0);\n}\n\nstatic av_cold int jpg_init(AVCodecContext *avctx, JPGContext *c)\n{\n    int ret;\n\n    ret = build_vlc(&c->dc_vlc[0], avpriv_mjpeg_bits_dc_luminance,\n                    avpriv_mjpeg_val_dc, 12, 0);\n    if (ret)\n        return ret;\n    ret = build_vlc(&c->dc_vlc[1], avpriv_mjpeg_bits_dc_chrominance,\n                    avpriv_mjpeg_val_dc, 12, 0);\n    if (ret)\n        return ret;\n    ret = build_vlc(&c->ac_vlc[0], avpriv_mjpeg_bits_ac_luminance,\n                    avpriv_mjpeg_val_ac_luminance, 251, 1);\n    if (ret)\n        return ret;\n    ret = build_vlc(&c->ac_vlc[1], avpriv_mjpeg_bits_ac_chrominance,\n                    avpriv_mjpeg_val_ac_chrominance, 251, 1);\n    if (ret)\n        return ret;\n\n    ff_dsputil_init(&c->dsp, avctx);\n    ff_init_scantable(c->dsp.idct_permutation, &c->scantable,\n                      ff_zigzag_direct);\n\n    return 0;\n}\n\nstatic av_cold void jpg_free_context(JPGContext *ctx)\n{\n    int i;\n\n    for (i = 0; i < 2; i++) {\n        ff_free_vlc(&ctx->dc_vlc[i]);\n        ff_free_vlc(&ctx->ac_vlc[i]);\n    }\n\n    av_freep(&ctx->buf);\n}\n\nstatic void jpg_unescape(const uint8_t *src, int src_size,\n                         uint8_t *dst, int *dst_size)\n{\n    const uint8_t *src_end = src + src_size;\n    uint8_t *dst_start = dst;\n\n    while (src < src_end) {\n        uint8_t x = *src++;\n\n        *dst++ = x;\n\n        if (x == 0xFF && !*src)\n            src++;\n    }\n    *dst_size = dst - dst_start;\n}\n\nstatic int jpg_decode_block(JPGContext *c, GetBitContext *gb,\n                            int plane, int16_t *block)\n{\n    int dc, val, pos;\n    const int is_chroma = !!plane;\n    const uint8_t *qmat = is_chroma ? chroma_quant : luma_quant;\n\n    c->dsp.clear_block(block);\n    dc = get_vlc2(gb, c->dc_vlc[is_chroma].table, 9, 3);\n    if (dc < 0)\n        return AVERROR_INVALIDDATA;\n    if (dc)\n        dc = get_xbits(gb, dc);\n    dc = dc * qmat[0] + c->prev_dc[plane];\n    block[0] = dc;\n    c->prev_dc[plane] = dc;\n\n    pos = 0;\n    while (pos < 63) {\n        val = get_vlc2(gb, c->ac_vlc[is_chroma].table, 9, 3);\n        if (val < 0)\n            return AVERROR_INVALIDDATA;\n        pos += val >> 4;\n        val &= 0xF;\n        if (pos > 63)\n            return val ? AVERROR_INVALIDDATA : 0;\n        if (val) {\n            int nbits = val;\n\n            val = get_xbits(gb, nbits);\n            val *= qmat[ff_zigzag_direct[pos]];\n            block[c->scantable.permutated[pos]] = val;\n        }\n    }\n    return 0;\n}\n\nstatic inline void yuv2rgb(uint8_t *out, int Y, int U, int V)\n{\n    out[0] = av_clip_uint8(Y + (             91881 * V + 32768 >> 16));\n    out[1] = av_clip_uint8(Y + (-22554 * U - 46802 * V + 32768 >> 16));\n    out[2] = av_clip_uint8(Y + (116130 * U             + 32768 >> 16));\n}\n\nstatic int jpg_decode_data(JPGContext *c, int width, int height,\n                           const uint8_t *src, int src_size,\n                           uint8_t *dst, int dst_stride,\n                           const uint8_t *mask, int mask_stride, int num_mbs,\n                           int swapuv)\n{\n    GetBitContext gb;\n    uint8_t *tmp;\n    int mb_w, mb_h, mb_x, mb_y, i, j;\n    int bx, by;\n    int unesc_size;\n    int ret;\n\n    tmp = av_realloc(c->buf, src_size + FF_INPUT_BUFFER_PADDING_SIZE);\n    if (!tmp)\n        return AVERROR(ENOMEM);\n    c->buf = tmp;\n    jpg_unescape(src, src_size, c->buf, &unesc_size);\n    memset(c->buf + unesc_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n    init_get_bits(&gb, c->buf, unesc_size * 8);\n\n    width = FFALIGN(width, 16);\n    mb_w  =  width        >> 4;\n    mb_h  = (height + 15) >> 4;\n\n    if (!num_mbs)\n        num_mbs = mb_w * mb_h;\n\n    for (i = 0; i < 3; i++)\n        c->prev_dc[i] = 1024;\n    bx = by = 0;\n    for (mb_y = 0; mb_y < mb_h; mb_y++) {\n        for (mb_x = 0; mb_x < mb_w; mb_x++) {\n            if (mask && !mask[mb_x]) {\n                bx += 16;\n                continue;\n            }\n            for (j = 0; j < 2; j++) {\n                for (i = 0; i < 2; i++) {\n                    if ((ret = jpg_decode_block(c, &gb, 0,\n                                                c->block[i + j * 2])) != 0)\n                        return ret;\n                    c->dsp.idct(c->block[i + j * 2]);\n                }\n            }\n            for (i = 1; i < 3; i++) {\n                if ((ret = jpg_decode_block(c, &gb, i, c->block[i + 3])) != 0)\n                    return ret;\n                c->dsp.idct(c->block[i + 3]);\n            }\n\n            for (j = 0; j < 16; j++) {\n                uint8_t *out = dst + bx * 3 + (by + j) * dst_stride;\n                for (i = 0; i < 16; i++) {\n                    int Y, U, V;\n\n                    Y = c->block[(j >> 3) * 2 + (i >> 3)][(i & 7) + (j & 7) * 8];\n                    U = c->block[4 ^ swapuv][(i >> 1) + (j >> 1) * 8] - 128;\n                    V = c->block[5 ^ swapuv][(i >> 1) + (j >> 1) * 8] - 128;\n                    yuv2rgb(out + i * 3, Y, U, V);\n                }\n            }\n\n            if (!--num_mbs)\n                return 0;\n            bx += 16;\n        }\n        bx  = 0;\n        by += 16;\n        if (mask)\n            mask += mask_stride;\n    }\n\n    return 0;\n}\n\nstatic void kempf_restore_buf(const uint8_t *src, int len,\n                              uint8_t *dst, int stride,\n                              const uint8_t *jpeg_tile, int tile_stride,\n                              int width, int height,\n                              const uint8_t *pal, int npal, int tidx)\n{\n    GetBitContext gb;\n    int i, j, nb, col;\n\n    init_get_bits(&gb, src, len * 8);\n\n    if (npal <= 2)       nb = 1;\n    else if (npal <= 4)  nb = 2;\n    else if (npal <= 16) nb = 4;\n    else                 nb = 8;\n\n    for (j = 0; j < height; j++, dst += stride, jpeg_tile += tile_stride) {\n        if (get_bits(&gb, 8))\n            continue;\n        for (i = 0; i < width; i++) {\n            col = get_bits(&gb, nb);\n            if (col != tidx)\n                memcpy(dst + i * 3, pal + col * 3, 3);\n            else\n                memcpy(dst + i * 3, jpeg_tile + i * 3, 3);\n        }\n    }\n}\n\nstatic int kempf_decode_tile(G2MContext *c, int tile_x, int tile_y,\n                             const uint8_t *src, int src_size)\n{\n    int width, height;\n    int hdr, zsize, npal, tidx = -1, ret;\n    int i, j;\n    const uint8_t *src_end = src + src_size;\n    uint8_t pal[768], transp[3];\n    uLongf dlen = (c->tile_width + 1) * c->tile_height;\n    int sub_type;\n    int nblocks, cblocks, bstride;\n    int bits, bitbuf, coded;\n    uint8_t *dst = c->framebuf + tile_x * c->tile_width * 3 +\n                   tile_y * c->tile_height * c->framebuf_stride;\n\n    if (src_size < 2)\n        return AVERROR_INVALIDDATA;\n\n    width  = FFMIN(c->width  - tile_x * c->tile_width,  c->tile_width);\n    height = FFMIN(c->height - tile_y * c->tile_height, c->tile_height);\n\n    hdr = *src++;\n    sub_type = hdr >> 5;\n    if (sub_type == 0) {\n        int j;\n        memcpy(transp, src, 3);\n        src += 3;\n        for (j = 0; j < height; j++, dst += c->framebuf_stride)\n            for (i = 0; i < width; i++)\n                memcpy(dst + i * 3, transp, 3);\n        return 0;\n    } else if (sub_type == 1) {\n        return jpg_decode_data(&c->jc, width, height, src, src_end - src,\n                               dst, c->framebuf_stride, NULL, 0, 0, 0);\n    }\n\n    if (sub_type != 2) {\n        memcpy(transp, src, 3);\n        src += 3;\n    }\n    npal = *src++ + 1;\n    memcpy(pal, src, npal * 3); src += npal * 3;\n    if (sub_type != 2) {\n        for (i = 0; i < npal; i++) {\n            if (!memcmp(pal + i * 3, transp, 3)) {\n               tidx = i;\n               break;\n            }\n        }\n    }\n\n    if (src_end - src < 2)\n        return 0;\n    zsize = (src[0] << 8) | src[1]; src += 2;\n\n    if (src_end - src < zsize + (sub_type != 2))\n        return AVERROR_INVALIDDATA;\n\n    ret = uncompress(c->kempf_buf, &dlen, src, zsize);\n    if (ret)\n        return AVERROR_INVALIDDATA;\n    src += zsize;\n\n    if (sub_type == 2) {\n        kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,\n                          NULL, 0, width, height, pal, npal, tidx);\n        return 0;\n    }\n\n    nblocks = *src++ + 1;\n    cblocks = 0;\n    bstride = FFALIGN(width, 16) >> 4;\n    // blocks are coded LSB and we need normal bitreader for JPEG data\n    bits = 0;\n    for (i = 0; i < (FFALIGN(height, 16) >> 4); i++) {\n        for (j = 0; j < (FFALIGN(width, 16) >> 4); j++) {\n            if (!bits) {\n                if (src >= src_end)\n                    return AVERROR_INVALIDDATA;\n                bitbuf = *src++;\n                bits   = 8;\n            }\n            coded = bitbuf & 1;\n            bits--;\n            bitbuf >>= 1;\n            cblocks += coded;\n            if (cblocks > nblocks)\n                return AVERROR_INVALIDDATA;\n            c->kempf_flags[j + i * bstride] = coded;\n        }\n    }\n\n    memset(c->jpeg_tile, 0, c->tile_stride * height);\n    jpg_decode_data(&c->jc, width, height, src, src_end - src,\n                    c->jpeg_tile, c->tile_stride,\n                    c->kempf_flags, bstride, nblocks, 0);\n\n    kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,\n                      c->jpeg_tile, c->tile_stride,\n                      width, height, pal, npal, tidx);\n\n    return 0;\n}\n\nstatic int g2m_init_buffers(G2MContext *c)\n{\n    int aligned_height;\n\n    if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n        c->framebuf_stride = FFALIGN(c->width * 3, 16);\n        aligned_height     = FFALIGN(c->height,    16);\n        av_free(c->framebuf);\n        c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n        if (!c->framebuf)\n            return AVERROR(ENOMEM);\n    }\n    if (!c->synth_tile || !c->jpeg_tile ||\n        c->old_tile_w < c->tile_width ||\n        c->old_tile_h < c->tile_height) {\n        c->tile_stride = FFALIGN(c->tile_width * 3, 16);\n        aligned_height = FFALIGN(c->tile_height,    16);\n        av_free(c->synth_tile);\n        av_free(c->jpeg_tile);\n        av_free(c->kempf_buf);\n        av_free(c->kempf_flags);\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n        if (!c->synth_tile || !c->jpeg_tile ||\n            !c->kempf_buf || !c->kempf_flags)\n            return AVERROR(ENOMEM);\n    }\n\n    return 0;\n}\n\nstatic int g2m_load_cursor(AVCodecContext *avctx, G2MContext *c,\n                           GetByteContext *gb)\n{\n    int i, j, k;\n    uint8_t *dst;\n    uint32_t bits;\n    uint32_t cur_size, cursor_w, cursor_h, cursor_stride;\n    uint32_t cursor_hot_x, cursor_hot_y;\n    int cursor_fmt;\n    uint8_t *tmp;\n\n    cur_size      = bytestream2_get_be32(gb);\n    cursor_w      = bytestream2_get_byte(gb);\n    cursor_h      = bytestream2_get_byte(gb);\n    cursor_hot_x  = bytestream2_get_byte(gb);\n    cursor_hot_y  = bytestream2_get_byte(gb);\n    cursor_fmt    = bytestream2_get_byte(gb);\n\n    cursor_stride = FFALIGN(cursor_w, 32) * 4;\n\n    if (cursor_w < 1 || cursor_w > 256 ||\n        cursor_h < 1 || cursor_h > 256) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid cursor dimensions %dx%d\\n\",\n               cursor_w, cursor_h);\n        return AVERROR_INVALIDDATA;\n    }\n    if (cursor_hot_x > cursor_w || cursor_hot_y > cursor_h) {\n        av_log(avctx, AV_LOG_WARNING, \"Invalid hotspot position %d,%d\\n\",\n               cursor_hot_x, cursor_hot_y);\n        cursor_hot_x = FFMIN(cursor_hot_x, cursor_w - 1);\n        cursor_hot_y = FFMIN(cursor_hot_y, cursor_h - 1);\n    }\n    if (cur_size - 9 > bytestream2_get_bytes_left(gb) ||\n        c->cursor_w * c->cursor_h / 4 > cur_size) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid cursor data size %d/%d\\n\",\n               cur_size, bytestream2_get_bytes_left(gb));\n        return AVERROR_INVALIDDATA;\n    }\n    if (cursor_fmt != 1 && cursor_fmt != 32) {\n        avpriv_report_missing_feature(avctx, \"Cursor format %d\",\n                                      cursor_fmt);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    tmp = av_realloc(c->cursor, cursor_stride * cursor_h);\n    if (!tmp) {\n        av_log(avctx, AV_LOG_ERROR, \"Cannot allocate cursor buffer\\n\");\n        return AVERROR(ENOMEM);\n    }\n\n    c->cursor        = tmp;\n    c->cursor_w      = cursor_w;\n    c->cursor_h      = cursor_h;\n    c->cursor_hot_x  = cursor_hot_x;\n    c->cursor_hot_y  = cursor_hot_y;\n    c->cursor_fmt    = cursor_fmt;\n    c->cursor_stride = cursor_stride;\n\n    dst = c->cursor;\n    switch (c->cursor_fmt) {\n    case 1: // old monochrome\n        for (j = 0; j < c->cursor_h; j++) {\n            for (i = 0; i < c->cursor_w; i += 32) {\n                bits = bytestream2_get_be32(gb);\n                for (k = 0; k < 32; k++) {\n                    dst[0] = !!(bits & 0x80000000);\n                    dst += 4;\n                    bits <<= 1;\n                }\n            }\n        }\n\n        dst = c->cursor;\n        for (j = 0; j < c->cursor_h; j++) {\n            for (i = 0; i < c->cursor_w; i += 32) {\n                bits = bytestream2_get_be32(gb);\n                for (k = 0; k < 32; k++) {\n                    int mask_bit = !!(bits & 0x80000000);\n                    switch (dst[0] * 2 + mask_bit) {\n                    case 0:\n                        dst[0] = 0xFF; dst[1] = 0x00;\n                        dst[2] = 0x00; dst[3] = 0x00;\n                        break;\n                    case 1:\n                        dst[0] = 0xFF; dst[1] = 0xFF;\n                        dst[2] = 0xFF; dst[3] = 0xFF;\n                        break;\n                    default:\n                        dst[0] = 0x00; dst[1] = 0x00;\n                        dst[2] = 0x00; dst[3] = 0x00;\n                    }\n                    dst += 4;\n                    bits <<= 1;\n                }\n            }\n        }\n        break;\n    case 32: // full colour\n        /* skip monochrome version of the cursor and decode RGBA instead */\n        bytestream2_skip(gb, c->cursor_h * (FFALIGN(c->cursor_w, 32) >> 3));\n        for (j = 0; j < c->cursor_h; j++) {\n            for (i = 0; i < c->cursor_w; i++) {\n                int val = bytestream2_get_be32(gb);\n                *dst++ = val >>  0;\n                *dst++ = val >>  8;\n                *dst++ = val >> 16;\n                *dst++ = val >> 24;\n            }\n        }\n        break;\n    default:\n        return AVERROR_PATCHWELCOME;\n    }\n    return 0;\n}\n\n#define APPLY_ALPHA(src, new, alpha) \\\n    src = (src * (256 - alpha) + new * alpha) >> 8\n\nstatic void g2m_paint_cursor(G2MContext *c, uint8_t *dst, int stride)\n{\n    int i, j;\n    int x, y, w, h;\n    const uint8_t *cursor;\n\n    if (!c->cursor)\n        return;\n\n    x = c->cursor_x - c->cursor_hot_x;\n    y = c->cursor_y - c->cursor_hot_y;\n\n    cursor = c->cursor;\n    w      = c->cursor_w;\n    h      = c->cursor_h;\n\n    if (x + w > c->width)\n        w = c->width - x;\n    if (y + h > c->height)\n        h = c->height - y;\n    if (x < 0) {\n        w      +=  x;\n        cursor += -x * 4;\n    } else {\n        dst    +=  x * 3;\n    }\n    if (y < 0) {\n        h      +=  y;\n        cursor += -y * c->cursor_stride;\n    } else {\n        dst    +=  y * stride;\n    }\n    if (w < 0 || h < 0)\n        return;\n\n    for (j = 0; j < h; j++) {\n        for (i = 0; i < w; i++) {\n            uint8_t alpha = cursor[i * 4];\n            APPLY_ALPHA(dst[i * 3 + 0], cursor[i * 4 + 1], alpha);\n            APPLY_ALPHA(dst[i * 3 + 1], cursor[i * 4 + 2], alpha);\n            APPLY_ALPHA(dst[i * 3 + 2], cursor[i * 4 + 3], alpha);\n        }\n        dst    += stride;\n        cursor += c->cursor_stride;\n    }\n}\n\nstatic int g2m_decode_frame(AVCodecContext *avctx, void *data,\n                            int *got_picture_ptr, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    G2MContext *c = avctx->priv_data;\n    AVFrame *pic = data;\n    GetByteContext bc, tbc;\n    int magic;\n    int got_header = 0;\n    uint32_t chunk_size;\n    int chunk_type;\n    int i;\n    int ret;\n\n    if (buf_size < 12) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Frame should have at least 12 bytes, got %d instead\\n\",\n               buf_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    bytestream2_init(&bc, buf, buf_size);\n\n    magic = bytestream2_get_be32(&bc);\n    if ((magic & ~0xF) != MKBETAG('G', '2', 'M', '0') ||\n        (magic & 0xF) < 2 || (magic & 0xF) > 4) {\n        av_log(avctx, AV_LOG_ERROR, \"Wrong magic %08X\\n\", magic);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((magic & 0xF) != 4) {\n        av_log(avctx, AV_LOG_ERROR, \"G2M2 and G2M3 are not yet supported\\n\");\n        return AVERROR(ENOSYS);\n    }\n\n    while (bytestream2_get_bytes_left(&bc) > 5) {\n        chunk_size = bytestream2_get_le32(&bc) - 1;\n        chunk_type = bytestream2_get_byte(&bc);\n        if (chunk_size > bytestream2_get_bytes_left(&bc)) {\n            av_log(avctx, AV_LOG_ERROR, \"Invalid chunk size %d type %02X\\n\",\n                   chunk_size, chunk_type);\n            break;\n        }\n        switch (chunk_type) {\n        case FRAME_INFO:\n            c->got_header = 0;\n            if (chunk_size < 21) {\n                av_log(avctx, AV_LOG_ERROR, \"Invalid frame info size %d\\n\",\n                       chunk_size);\n                break;\n            }\n            c->width  = bytestream2_get_be32(&bc);\n            c->height = bytestream2_get_be32(&bc);\n            if (c->width  < 16 || c->width  > avctx->width ||\n                c->height < 16 || c->height > avctx->height) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Invalid frame dimensions %dx%d\\n\",\n                       c->width, c->height);\n                ret = AVERROR_INVALIDDATA;\n                goto header_fail;\n            }\n            if (c->width != avctx->width || c->height != avctx->height)\n                avcodec_set_dimensions(avctx, c->width, c->height);\n            c->compression = bytestream2_get_be32(&bc);\n            if (c->compression != 2 && c->compression != 3) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Unknown compression method %d\\n\",\n                       c->compression);\n                return AVERROR_PATCHWELCOME;\n            }\n            c->tile_width  = bytestream2_get_be32(&bc);\n            c->tile_height = bytestream2_get_be32(&bc);\n            if (!c->tile_width || !c->tile_height) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Invalid tile dimensions %dx%d\\n\",\n                       c->tile_width, c->tile_height);\n                ret = AVERROR_INVALIDDATA;\n                goto header_fail;\n            }\n            c->tiles_x = (c->width  + c->tile_width  - 1) / c->tile_width;\n            c->tiles_y = (c->height + c->tile_height - 1) / c->tile_height;\n            c->bpp = bytestream2_get_byte(&bc);\n            chunk_size -= 21;\n            bytestream2_skip(&bc, chunk_size);\n            if (g2m_init_buffers(c)) {\n                ret = AVERROR(ENOMEM);\n                goto header_fail;\n            }\n            got_header = 1;\n            break;\n        case TILE_DATA:\n            if (!c->tiles_x || !c->tiles_y) {\n                av_log(avctx, AV_LOG_WARNING,\n                       \"No frame header - skipping tile\\n\");\n                bytestream2_skip(&bc, bytestream2_get_bytes_left(&bc));\n                break;\n            }\n            if (chunk_size < 2) {\n                av_log(avctx, AV_LOG_ERROR, \"Invalid tile data size %d\\n\",\n                       chunk_size);\n                break;\n            }\n            c->tile_x = bytestream2_get_byte(&bc);\n            c->tile_y = bytestream2_get_byte(&bc);\n            if (c->tile_x >= c->tiles_x || c->tile_y >= c->tiles_y) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Invalid tile pos %d,%d (in %dx%d grid)\\n\",\n                       c->tile_x, c->tile_y, c->tiles_x, c->tiles_y);\n                break;\n            }\n            chunk_size -= 2;\n            ret = 0;\n            switch (c->compression) {\n            case COMPR_EPIC_J_B:\n                av_log(avctx, AV_LOG_ERROR,\n                       \"ePIC j-b compression is not implemented yet\\n\");\n                return AVERROR(ENOSYS);\n            case COMPR_KEMPF_J_B:\n                ret = kempf_decode_tile(c, c->tile_x, c->tile_y,\n                                        buf + bytestream2_tell(&bc),\n                                        chunk_size);\n                break;\n            }\n            if (ret && c->framebuf)\n                av_log(avctx, AV_LOG_ERROR, \"Error decoding tile %d,%d\\n\",\n                       c->tile_x, c->tile_y);\n            bytestream2_skip(&bc, chunk_size);\n            break;\n        case CURSOR_POS:\n            if (chunk_size < 5) {\n                av_log(avctx, AV_LOG_ERROR, \"Invalid cursor pos size %d\\n\",\n                       chunk_size);\n                break;\n            }\n            c->cursor_x = bytestream2_get_be16(&bc);\n            c->cursor_y = bytestream2_get_be16(&bc);\n            bytestream2_skip(&bc, chunk_size - 4);\n            break;\n        case CURSOR_SHAPE:\n            if (chunk_size < 8) {\n                av_log(avctx, AV_LOG_ERROR, \"Invalid cursor data size %d\\n\",\n                       chunk_size);\n                break;\n            }\n            bytestream2_init(&tbc, buf + bytestream2_tell(&bc),\n                             chunk_size - 4);\n            g2m_load_cursor(avctx, c, &tbc);\n            bytestream2_skip(&bc, chunk_size);\n            break;\n        case CHUNK_CC:\n        case CHUNK_CD:\n            bytestream2_skip(&bc, chunk_size);\n            break;\n        default:\n            av_log(avctx, AV_LOG_WARNING, \"Skipping chunk type %02X\\n\",\n                   chunk_type);\n            bytestream2_skip(&bc, chunk_size);\n        }\n    }\n    if (got_header)\n        c->got_header = 1;\n\n    if (c->width && c->height && c->framebuf) {\n        if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n            return ret;\n\n        pic->key_frame = got_header;\n        pic->pict_type = got_header ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P;\n\n        for (i = 0; i < avctx->height; i++)\n            memcpy(pic->data[0] + i * pic->linesize[0],\n                   c->framebuf  + i * c->framebuf_stride,\n                   c->width * 3);\n        g2m_paint_cursor(c, pic->data[0], pic->linesize[0]);\n\n        *got_picture_ptr = 1;\n    }\n\n    return buf_size;\nheader_fail:\n    c->width   = c->height  = 0;\n    c->tiles_x = c->tiles_y = 0;\n    return ret;\n}\n\nstatic av_cold int g2m_decode_init(AVCodecContext *avctx)\n{\n    G2MContext * const c = avctx->priv_data;\n    int ret;\n\n    if ((ret = jpg_init(avctx, &c->jc)) != 0) {\n        av_log(avctx, AV_LOG_ERROR, \"Cannot initialise VLCs\\n\");\n        jpg_free_context(&c->jc);\n        return AVERROR(ENOMEM);\n    }\n\n    avctx->pix_fmt = AV_PIX_FMT_RGB24;\n\n    return 0;\n}\n\nstatic av_cold int g2m_decode_end(AVCodecContext *avctx)\n{\n    G2MContext * const c = avctx->priv_data;\n\n    jpg_free_context(&c->jc);\n\n    av_freep(&c->kempf_buf);\n    av_freep(&c->kempf_flags);\n    av_freep(&c->synth_tile);\n    av_freep(&c->jpeg_tile);\n    av_freep(&c->cursor);\n    av_freep(&c->framebuf);\n\n    return 0;\n}\n\nAVCodec ff_g2m_decoder = {\n    .name           = \"g2m\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Go2Meeting\"),\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_G2M,\n    .priv_data_size = sizeof(G2MContext),\n    .init           = g2m_decode_init,\n    .close          = g2m_decode_end,\n    .decode         = g2m_decode_frame,\n    .capabilities   = CODEC_CAP_DR1,\n};\n"], "fixing_code": ["/*\n * Go2Webinar decoder\n * Copyright (c) 2012 Konstantin Shishkov\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * Go2Webinar decoder\n */\n\n#include <zlib.h>\n\n#include \"libavutil/intreadwrite.h\"\n#include \"avcodec.h\"\n#include \"bytestream.h\"\n#include \"dsputil.h\"\n#include \"get_bits.h\"\n#include \"internal.h\"\n#include \"mjpeg.h\"\n\nenum ChunkType {\n    FRAME_INFO = 0xC8,\n    TILE_DATA,\n    CURSOR_POS,\n    CURSOR_SHAPE,\n    CHUNK_CC,\n    CHUNK_CD\n};\n\nenum Compression {\n    COMPR_EPIC_J_B = 2,\n    COMPR_KEMPF_J_B,\n};\n\nstatic const uint8_t luma_quant[64] = {\n     8,  6,  5,  8, 12, 20, 26, 31,\n     6,  6,  7, 10, 13, 29, 30, 28,\n     7,  7,  8, 12, 20, 29, 35, 28,\n     7,  9, 11, 15, 26, 44, 40, 31,\n     9, 11, 19, 28, 34, 55, 52, 39,\n    12, 18, 28, 32, 41, 52, 57, 46,\n    25, 32, 39, 44, 52, 61, 60, 51,\n    36, 46, 48, 49, 56, 50, 52, 50\n};\n\nstatic const uint8_t chroma_quant[64] = {\n     9,  9, 12, 24, 50, 50, 50, 50,\n     9, 11, 13, 33, 50, 50, 50, 50,\n    12, 13, 28, 50, 50, 50, 50, 50,\n    24, 33, 50, 50, 50, 50, 50, 50,\n    50, 50, 50, 50, 50, 50, 50, 50,\n    50, 50, 50, 50, 50, 50, 50, 50,\n    50, 50, 50, 50, 50, 50, 50, 50,\n    50, 50, 50, 50, 50, 50, 50, 50,\n};\n\ntypedef struct JPGContext {\n    DSPContext dsp;\n    ScanTable  scantable;\n\n    VLC        dc_vlc[2], ac_vlc[2];\n    int        prev_dc[3];\n    DECLARE_ALIGNED(16, int16_t, block)[6][64];\n\n    uint8_t    *buf;\n} JPGContext;\n\ntypedef struct G2MContext {\n    JPGContext jc;\n    int        version;\n\n    int        compression;\n    int        width, height, bpp;\n    int        tile_width, tile_height;\n    int        tiles_x, tiles_y, tile_x, tile_y;\n\n    int        got_header;\n\n    uint8_t    *framebuf;\n    int        framebuf_stride, old_width, old_height;\n\n    uint8_t    *synth_tile, *jpeg_tile;\n    int        tile_stride, old_tile_w, old_tile_h;\n\n    uint8_t    *kempf_buf, *kempf_flags;\n\n    uint8_t    *cursor;\n    int        cursor_stride;\n    int        cursor_fmt;\n    int        cursor_w, cursor_h, cursor_x, cursor_y;\n    int        cursor_hot_x, cursor_hot_y;\n} G2MContext;\n\nstatic av_cold int build_vlc(VLC *vlc, const uint8_t *bits_table,\n                             const uint8_t *val_table, int nb_codes,\n                             int is_ac)\n{\n    uint8_t  huff_size[256] = { 0 };\n    uint16_t huff_code[256];\n    uint16_t huff_sym[256];\n    int i;\n\n    ff_mjpeg_build_huffman_codes(huff_size, huff_code, bits_table, val_table);\n\n    for (i = 0; i < 256; i++)\n        huff_sym[i] = i + 16 * is_ac;\n\n    if (is_ac)\n        huff_sym[0] = 16 * 256;\n\n    return ff_init_vlc_sparse(vlc, 9, nb_codes, huff_size, 1, 1,\n                              huff_code, 2, 2, huff_sym, 2, 2, 0);\n}\n\nstatic av_cold int jpg_init(AVCodecContext *avctx, JPGContext *c)\n{\n    int ret;\n\n    ret = build_vlc(&c->dc_vlc[0], avpriv_mjpeg_bits_dc_luminance,\n                    avpriv_mjpeg_val_dc, 12, 0);\n    if (ret)\n        return ret;\n    ret = build_vlc(&c->dc_vlc[1], avpriv_mjpeg_bits_dc_chrominance,\n                    avpriv_mjpeg_val_dc, 12, 0);\n    if (ret)\n        return ret;\n    ret = build_vlc(&c->ac_vlc[0], avpriv_mjpeg_bits_ac_luminance,\n                    avpriv_mjpeg_val_ac_luminance, 251, 1);\n    if (ret)\n        return ret;\n    ret = build_vlc(&c->ac_vlc[1], avpriv_mjpeg_bits_ac_chrominance,\n                    avpriv_mjpeg_val_ac_chrominance, 251, 1);\n    if (ret)\n        return ret;\n\n    ff_dsputil_init(&c->dsp, avctx);\n    ff_init_scantable(c->dsp.idct_permutation, &c->scantable,\n                      ff_zigzag_direct);\n\n    return 0;\n}\n\nstatic av_cold void jpg_free_context(JPGContext *ctx)\n{\n    int i;\n\n    for (i = 0; i < 2; i++) {\n        ff_free_vlc(&ctx->dc_vlc[i]);\n        ff_free_vlc(&ctx->ac_vlc[i]);\n    }\n\n    av_freep(&ctx->buf);\n}\n\nstatic void jpg_unescape(const uint8_t *src, int src_size,\n                         uint8_t *dst, int *dst_size)\n{\n    const uint8_t *src_end = src + src_size;\n    uint8_t *dst_start = dst;\n\n    while (src < src_end) {\n        uint8_t x = *src++;\n\n        *dst++ = x;\n\n        if (x == 0xFF && !*src)\n            src++;\n    }\n    *dst_size = dst - dst_start;\n}\n\nstatic int jpg_decode_block(JPGContext *c, GetBitContext *gb,\n                            int plane, int16_t *block)\n{\n    int dc, val, pos;\n    const int is_chroma = !!plane;\n    const uint8_t *qmat = is_chroma ? chroma_quant : luma_quant;\n\n    c->dsp.clear_block(block);\n    dc = get_vlc2(gb, c->dc_vlc[is_chroma].table, 9, 3);\n    if (dc < 0)\n        return AVERROR_INVALIDDATA;\n    if (dc)\n        dc = get_xbits(gb, dc);\n    dc = dc * qmat[0] + c->prev_dc[plane];\n    block[0] = dc;\n    c->prev_dc[plane] = dc;\n\n    pos = 0;\n    while (pos < 63) {\n        val = get_vlc2(gb, c->ac_vlc[is_chroma].table, 9, 3);\n        if (val < 0)\n            return AVERROR_INVALIDDATA;\n        pos += val >> 4;\n        val &= 0xF;\n        if (pos > 63)\n            return val ? AVERROR_INVALIDDATA : 0;\n        if (val) {\n            int nbits = val;\n\n            val = get_xbits(gb, nbits);\n            val *= qmat[ff_zigzag_direct[pos]];\n            block[c->scantable.permutated[pos]] = val;\n        }\n    }\n    return 0;\n}\n\nstatic inline void yuv2rgb(uint8_t *out, int Y, int U, int V)\n{\n    out[0] = av_clip_uint8(Y + (             91881 * V + 32768 >> 16));\n    out[1] = av_clip_uint8(Y + (-22554 * U - 46802 * V + 32768 >> 16));\n    out[2] = av_clip_uint8(Y + (116130 * U             + 32768 >> 16));\n}\n\nstatic int jpg_decode_data(JPGContext *c, int width, int height,\n                           const uint8_t *src, int src_size,\n                           uint8_t *dst, int dst_stride,\n                           const uint8_t *mask, int mask_stride, int num_mbs,\n                           int swapuv)\n{\n    GetBitContext gb;\n    uint8_t *tmp;\n    int mb_w, mb_h, mb_x, mb_y, i, j;\n    int bx, by;\n    int unesc_size;\n    int ret;\n\n    tmp = av_realloc(c->buf, src_size + FF_INPUT_BUFFER_PADDING_SIZE);\n    if (!tmp)\n        return AVERROR(ENOMEM);\n    c->buf = tmp;\n    jpg_unescape(src, src_size, c->buf, &unesc_size);\n    memset(c->buf + unesc_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n    init_get_bits(&gb, c->buf, unesc_size * 8);\n\n    width = FFALIGN(width, 16);\n    mb_w  =  width        >> 4;\n    mb_h  = (height + 15) >> 4;\n\n    if (!num_mbs)\n        num_mbs = mb_w * mb_h;\n\n    for (i = 0; i < 3; i++)\n        c->prev_dc[i] = 1024;\n    bx = by = 0;\n    for (mb_y = 0; mb_y < mb_h; mb_y++) {\n        for (mb_x = 0; mb_x < mb_w; mb_x++) {\n            if (mask && !mask[mb_x]) {\n                bx += 16;\n                continue;\n            }\n            for (j = 0; j < 2; j++) {\n                for (i = 0; i < 2; i++) {\n                    if ((ret = jpg_decode_block(c, &gb, 0,\n                                                c->block[i + j * 2])) != 0)\n                        return ret;\n                    c->dsp.idct(c->block[i + j * 2]);\n                }\n            }\n            for (i = 1; i < 3; i++) {\n                if ((ret = jpg_decode_block(c, &gb, i, c->block[i + 3])) != 0)\n                    return ret;\n                c->dsp.idct(c->block[i + 3]);\n            }\n\n            for (j = 0; j < 16; j++) {\n                uint8_t *out = dst + bx * 3 + (by + j) * dst_stride;\n                for (i = 0; i < 16; i++) {\n                    int Y, U, V;\n\n                    Y = c->block[(j >> 3) * 2 + (i >> 3)][(i & 7) + (j & 7) * 8];\n                    U = c->block[4 ^ swapuv][(i >> 1) + (j >> 1) * 8] - 128;\n                    V = c->block[5 ^ swapuv][(i >> 1) + (j >> 1) * 8] - 128;\n                    yuv2rgb(out + i * 3, Y, U, V);\n                }\n            }\n\n            if (!--num_mbs)\n                return 0;\n            bx += 16;\n        }\n        bx  = 0;\n        by += 16;\n        if (mask)\n            mask += mask_stride;\n    }\n\n    return 0;\n}\n\nstatic void kempf_restore_buf(const uint8_t *src, int len,\n                              uint8_t *dst, int stride,\n                              const uint8_t *jpeg_tile, int tile_stride,\n                              int width, int height,\n                              const uint8_t *pal, int npal, int tidx)\n{\n    GetBitContext gb;\n    int i, j, nb, col;\n\n    init_get_bits(&gb, src, len * 8);\n\n    if (npal <= 2)       nb = 1;\n    else if (npal <= 4)  nb = 2;\n    else if (npal <= 16) nb = 4;\n    else                 nb = 8;\n\n    for (j = 0; j < height; j++, dst += stride, jpeg_tile += tile_stride) {\n        if (get_bits(&gb, 8))\n            continue;\n        for (i = 0; i < width; i++) {\n            col = get_bits(&gb, nb);\n            if (col != tidx)\n                memcpy(dst + i * 3, pal + col * 3, 3);\n            else\n                memcpy(dst + i * 3, jpeg_tile + i * 3, 3);\n        }\n    }\n}\n\nstatic int kempf_decode_tile(G2MContext *c, int tile_x, int tile_y,\n                             const uint8_t *src, int src_size)\n{\n    int width, height;\n    int hdr, zsize, npal, tidx = -1, ret;\n    int i, j;\n    const uint8_t *src_end = src + src_size;\n    uint8_t pal[768], transp[3];\n    uLongf dlen = (c->tile_width + 1) * c->tile_height;\n    int sub_type;\n    int nblocks, cblocks, bstride;\n    int bits, bitbuf, coded;\n    uint8_t *dst = c->framebuf + tile_x * c->tile_width * 3 +\n                   tile_y * c->tile_height * c->framebuf_stride;\n\n    if (src_size < 2)\n        return AVERROR_INVALIDDATA;\n\n    width  = FFMIN(c->width  - tile_x * c->tile_width,  c->tile_width);\n    height = FFMIN(c->height - tile_y * c->tile_height, c->tile_height);\n\n    hdr = *src++;\n    sub_type = hdr >> 5;\n    if (sub_type == 0) {\n        int j;\n        memcpy(transp, src, 3);\n        src += 3;\n        for (j = 0; j < height; j++, dst += c->framebuf_stride)\n            for (i = 0; i < width; i++)\n                memcpy(dst + i * 3, transp, 3);\n        return 0;\n    } else if (sub_type == 1) {\n        return jpg_decode_data(&c->jc, width, height, src, src_end - src,\n                               dst, c->framebuf_stride, NULL, 0, 0, 0);\n    }\n\n    if (sub_type != 2) {\n        memcpy(transp, src, 3);\n        src += 3;\n    }\n    npal = *src++ + 1;\n    memcpy(pal, src, npal * 3); src += npal * 3;\n    if (sub_type != 2) {\n        for (i = 0; i < npal; i++) {\n            if (!memcmp(pal + i * 3, transp, 3)) {\n               tidx = i;\n               break;\n            }\n        }\n    }\n\n    if (src_end - src < 2)\n        return 0;\n    zsize = (src[0] << 8) | src[1]; src += 2;\n\n    if (src_end - src < zsize + (sub_type != 2))\n        return AVERROR_INVALIDDATA;\n\n    ret = uncompress(c->kempf_buf, &dlen, src, zsize);\n    if (ret)\n        return AVERROR_INVALIDDATA;\n    src += zsize;\n\n    if (sub_type == 2) {\n        kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,\n                          NULL, 0, width, height, pal, npal, tidx);\n        return 0;\n    }\n\n    nblocks = *src++ + 1;\n    cblocks = 0;\n    bstride = FFALIGN(width, 16) >> 4;\n    // blocks are coded LSB and we need normal bitreader for JPEG data\n    bits = 0;\n    for (i = 0; i < (FFALIGN(height, 16) >> 4); i++) {\n        for (j = 0; j < (FFALIGN(width, 16) >> 4); j++) {\n            if (!bits) {\n                if (src >= src_end)\n                    return AVERROR_INVALIDDATA;\n                bitbuf = *src++;\n                bits   = 8;\n            }\n            coded = bitbuf & 1;\n            bits--;\n            bitbuf >>= 1;\n            cblocks += coded;\n            if (cblocks > nblocks)\n                return AVERROR_INVALIDDATA;\n            c->kempf_flags[j + i * bstride] = coded;\n        }\n    }\n\n    memset(c->jpeg_tile, 0, c->tile_stride * height);\n    jpg_decode_data(&c->jc, width, height, src, src_end - src,\n                    c->jpeg_tile, c->tile_stride,\n                    c->kempf_flags, bstride, nblocks, 0);\n\n    kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,\n                      c->jpeg_tile, c->tile_stride,\n                      width, height, pal, npal, tidx);\n\n    return 0;\n}\n\nstatic int g2m_init_buffers(G2MContext *c)\n{\n    int aligned_height;\n\n    if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n        c->framebuf_stride = FFALIGN(c->width * 3, 16);\n        aligned_height     = FFALIGN(c->height,    16);\n        av_free(c->framebuf);\n        c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n        if (!c->framebuf)\n            return AVERROR(ENOMEM);\n    }\n    if (!c->synth_tile || !c->jpeg_tile ||\n        c->old_tile_w < c->tile_width ||\n        c->old_tile_h < c->tile_height) {\n        c->tile_stride = FFALIGN(c->tile_width, 16) * 3;\n        aligned_height = FFALIGN(c->tile_height,    16);\n        av_free(c->synth_tile);\n        av_free(c->jpeg_tile);\n        av_free(c->kempf_buf);\n        av_free(c->kempf_flags);\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n        if (!c->synth_tile || !c->jpeg_tile ||\n            !c->kempf_buf || !c->kempf_flags)\n            return AVERROR(ENOMEM);\n    }\n\n    return 0;\n}\n\nstatic int g2m_load_cursor(AVCodecContext *avctx, G2MContext *c,\n                           GetByteContext *gb)\n{\n    int i, j, k;\n    uint8_t *dst;\n    uint32_t bits;\n    uint32_t cur_size, cursor_w, cursor_h, cursor_stride;\n    uint32_t cursor_hot_x, cursor_hot_y;\n    int cursor_fmt;\n    uint8_t *tmp;\n\n    cur_size      = bytestream2_get_be32(gb);\n    cursor_w      = bytestream2_get_byte(gb);\n    cursor_h      = bytestream2_get_byte(gb);\n    cursor_hot_x  = bytestream2_get_byte(gb);\n    cursor_hot_y  = bytestream2_get_byte(gb);\n    cursor_fmt    = bytestream2_get_byte(gb);\n\n    cursor_stride = FFALIGN(cursor_w, 32) * 4;\n\n    if (cursor_w < 1 || cursor_w > 256 ||\n        cursor_h < 1 || cursor_h > 256) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid cursor dimensions %dx%d\\n\",\n               cursor_w, cursor_h);\n        return AVERROR_INVALIDDATA;\n    }\n    if (cursor_hot_x > cursor_w || cursor_hot_y > cursor_h) {\n        av_log(avctx, AV_LOG_WARNING, \"Invalid hotspot position %d,%d\\n\",\n               cursor_hot_x, cursor_hot_y);\n        cursor_hot_x = FFMIN(cursor_hot_x, cursor_w - 1);\n        cursor_hot_y = FFMIN(cursor_hot_y, cursor_h - 1);\n    }\n    if (cur_size - 9 > bytestream2_get_bytes_left(gb) ||\n        c->cursor_w * c->cursor_h / 4 > cur_size) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid cursor data size %d/%d\\n\",\n               cur_size, bytestream2_get_bytes_left(gb));\n        return AVERROR_INVALIDDATA;\n    }\n    if (cursor_fmt != 1 && cursor_fmt != 32) {\n        avpriv_report_missing_feature(avctx, \"Cursor format %d\",\n                                      cursor_fmt);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    tmp = av_realloc(c->cursor, cursor_stride * cursor_h);\n    if (!tmp) {\n        av_log(avctx, AV_LOG_ERROR, \"Cannot allocate cursor buffer\\n\");\n        return AVERROR(ENOMEM);\n    }\n\n    c->cursor        = tmp;\n    c->cursor_w      = cursor_w;\n    c->cursor_h      = cursor_h;\n    c->cursor_hot_x  = cursor_hot_x;\n    c->cursor_hot_y  = cursor_hot_y;\n    c->cursor_fmt    = cursor_fmt;\n    c->cursor_stride = cursor_stride;\n\n    dst = c->cursor;\n    switch (c->cursor_fmt) {\n    case 1: // old monochrome\n        for (j = 0; j < c->cursor_h; j++) {\n            for (i = 0; i < c->cursor_w; i += 32) {\n                bits = bytestream2_get_be32(gb);\n                for (k = 0; k < 32; k++) {\n                    dst[0] = !!(bits & 0x80000000);\n                    dst += 4;\n                    bits <<= 1;\n                }\n            }\n        }\n\n        dst = c->cursor;\n        for (j = 0; j < c->cursor_h; j++) {\n            for (i = 0; i < c->cursor_w; i += 32) {\n                bits = bytestream2_get_be32(gb);\n                for (k = 0; k < 32; k++) {\n                    int mask_bit = !!(bits & 0x80000000);\n                    switch (dst[0] * 2 + mask_bit) {\n                    case 0:\n                        dst[0] = 0xFF; dst[1] = 0x00;\n                        dst[2] = 0x00; dst[3] = 0x00;\n                        break;\n                    case 1:\n                        dst[0] = 0xFF; dst[1] = 0xFF;\n                        dst[2] = 0xFF; dst[3] = 0xFF;\n                        break;\n                    default:\n                        dst[0] = 0x00; dst[1] = 0x00;\n                        dst[2] = 0x00; dst[3] = 0x00;\n                    }\n                    dst += 4;\n                    bits <<= 1;\n                }\n            }\n        }\n        break;\n    case 32: // full colour\n        /* skip monochrome version of the cursor and decode RGBA instead */\n        bytestream2_skip(gb, c->cursor_h * (FFALIGN(c->cursor_w, 32) >> 3));\n        for (j = 0; j < c->cursor_h; j++) {\n            for (i = 0; i < c->cursor_w; i++) {\n                int val = bytestream2_get_be32(gb);\n                *dst++ = val >>  0;\n                *dst++ = val >>  8;\n                *dst++ = val >> 16;\n                *dst++ = val >> 24;\n            }\n        }\n        break;\n    default:\n        return AVERROR_PATCHWELCOME;\n    }\n    return 0;\n}\n\n#define APPLY_ALPHA(src, new, alpha) \\\n    src = (src * (256 - alpha) + new * alpha) >> 8\n\nstatic void g2m_paint_cursor(G2MContext *c, uint8_t *dst, int stride)\n{\n    int i, j;\n    int x, y, w, h;\n    const uint8_t *cursor;\n\n    if (!c->cursor)\n        return;\n\n    x = c->cursor_x - c->cursor_hot_x;\n    y = c->cursor_y - c->cursor_hot_y;\n\n    cursor = c->cursor;\n    w      = c->cursor_w;\n    h      = c->cursor_h;\n\n    if (x + w > c->width)\n        w = c->width - x;\n    if (y + h > c->height)\n        h = c->height - y;\n    if (x < 0) {\n        w      +=  x;\n        cursor += -x * 4;\n    } else {\n        dst    +=  x * 3;\n    }\n    if (y < 0) {\n        h      +=  y;\n        cursor += -y * c->cursor_stride;\n    } else {\n        dst    +=  y * stride;\n    }\n    if (w < 0 || h < 0)\n        return;\n\n    for (j = 0; j < h; j++) {\n        for (i = 0; i < w; i++) {\n            uint8_t alpha = cursor[i * 4];\n            APPLY_ALPHA(dst[i * 3 + 0], cursor[i * 4 + 1], alpha);\n            APPLY_ALPHA(dst[i * 3 + 1], cursor[i * 4 + 2], alpha);\n            APPLY_ALPHA(dst[i * 3 + 2], cursor[i * 4 + 3], alpha);\n        }\n        dst    += stride;\n        cursor += c->cursor_stride;\n    }\n}\n\nstatic int g2m_decode_frame(AVCodecContext *avctx, void *data,\n                            int *got_picture_ptr, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    G2MContext *c = avctx->priv_data;\n    AVFrame *pic = data;\n    GetByteContext bc, tbc;\n    int magic;\n    int got_header = 0;\n    uint32_t chunk_size;\n    int chunk_type;\n    int i;\n    int ret;\n\n    if (buf_size < 12) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Frame should have at least 12 bytes, got %d instead\\n\",\n               buf_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    bytestream2_init(&bc, buf, buf_size);\n\n    magic = bytestream2_get_be32(&bc);\n    if ((magic & ~0xF) != MKBETAG('G', '2', 'M', '0') ||\n        (magic & 0xF) < 2 || (magic & 0xF) > 4) {\n        av_log(avctx, AV_LOG_ERROR, \"Wrong magic %08X\\n\", magic);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((magic & 0xF) != 4) {\n        av_log(avctx, AV_LOG_ERROR, \"G2M2 and G2M3 are not yet supported\\n\");\n        return AVERROR(ENOSYS);\n    }\n\n    while (bytestream2_get_bytes_left(&bc) > 5) {\n        chunk_size = bytestream2_get_le32(&bc) - 1;\n        chunk_type = bytestream2_get_byte(&bc);\n        if (chunk_size > bytestream2_get_bytes_left(&bc)) {\n            av_log(avctx, AV_LOG_ERROR, \"Invalid chunk size %d type %02X\\n\",\n                   chunk_size, chunk_type);\n            break;\n        }\n        switch (chunk_type) {\n        case FRAME_INFO:\n            c->got_header = 0;\n            if (chunk_size < 21) {\n                av_log(avctx, AV_LOG_ERROR, \"Invalid frame info size %d\\n\",\n                       chunk_size);\n                break;\n            }\n            c->width  = bytestream2_get_be32(&bc);\n            c->height = bytestream2_get_be32(&bc);\n            if (c->width  < 16 || c->width  > avctx->width ||\n                c->height < 16 || c->height > avctx->height) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Invalid frame dimensions %dx%d\\n\",\n                       c->width, c->height);\n                ret = AVERROR_INVALIDDATA;\n                goto header_fail;\n            }\n            if (c->width != avctx->width || c->height != avctx->height)\n                avcodec_set_dimensions(avctx, c->width, c->height);\n            c->compression = bytestream2_get_be32(&bc);\n            if (c->compression != 2 && c->compression != 3) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Unknown compression method %d\\n\",\n                       c->compression);\n                return AVERROR_PATCHWELCOME;\n            }\n            c->tile_width  = bytestream2_get_be32(&bc);\n            c->tile_height = bytestream2_get_be32(&bc);\n            if (!c->tile_width || !c->tile_height) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Invalid tile dimensions %dx%d\\n\",\n                       c->tile_width, c->tile_height);\n                ret = AVERROR_INVALIDDATA;\n                goto header_fail;\n            }\n            c->tiles_x = (c->width  + c->tile_width  - 1) / c->tile_width;\n            c->tiles_y = (c->height + c->tile_height - 1) / c->tile_height;\n            c->bpp = bytestream2_get_byte(&bc);\n            chunk_size -= 21;\n            bytestream2_skip(&bc, chunk_size);\n            if (g2m_init_buffers(c)) {\n                ret = AVERROR(ENOMEM);\n                goto header_fail;\n            }\n            got_header = 1;\n            break;\n        case TILE_DATA:\n            if (!c->tiles_x || !c->tiles_y) {\n                av_log(avctx, AV_LOG_WARNING,\n                       \"No frame header - skipping tile\\n\");\n                bytestream2_skip(&bc, bytestream2_get_bytes_left(&bc));\n                break;\n            }\n            if (chunk_size < 2) {\n                av_log(avctx, AV_LOG_ERROR, \"Invalid tile data size %d\\n\",\n                       chunk_size);\n                break;\n            }\n            c->tile_x = bytestream2_get_byte(&bc);\n            c->tile_y = bytestream2_get_byte(&bc);\n            if (c->tile_x >= c->tiles_x || c->tile_y >= c->tiles_y) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Invalid tile pos %d,%d (in %dx%d grid)\\n\",\n                       c->tile_x, c->tile_y, c->tiles_x, c->tiles_y);\n                break;\n            }\n            chunk_size -= 2;\n            ret = 0;\n            switch (c->compression) {\n            case COMPR_EPIC_J_B:\n                av_log(avctx, AV_LOG_ERROR,\n                       \"ePIC j-b compression is not implemented yet\\n\");\n                return AVERROR(ENOSYS);\n            case COMPR_KEMPF_J_B:\n                ret = kempf_decode_tile(c, c->tile_x, c->tile_y,\n                                        buf + bytestream2_tell(&bc),\n                                        chunk_size);\n                break;\n            }\n            if (ret && c->framebuf)\n                av_log(avctx, AV_LOG_ERROR, \"Error decoding tile %d,%d\\n\",\n                       c->tile_x, c->tile_y);\n            bytestream2_skip(&bc, chunk_size);\n            break;\n        case CURSOR_POS:\n            if (chunk_size < 5) {\n                av_log(avctx, AV_LOG_ERROR, \"Invalid cursor pos size %d\\n\",\n                       chunk_size);\n                break;\n            }\n            c->cursor_x = bytestream2_get_be16(&bc);\n            c->cursor_y = bytestream2_get_be16(&bc);\n            bytestream2_skip(&bc, chunk_size - 4);\n            break;\n        case CURSOR_SHAPE:\n            if (chunk_size < 8) {\n                av_log(avctx, AV_LOG_ERROR, \"Invalid cursor data size %d\\n\",\n                       chunk_size);\n                break;\n            }\n            bytestream2_init(&tbc, buf + bytestream2_tell(&bc),\n                             chunk_size - 4);\n            g2m_load_cursor(avctx, c, &tbc);\n            bytestream2_skip(&bc, chunk_size);\n            break;\n        case CHUNK_CC:\n        case CHUNK_CD:\n            bytestream2_skip(&bc, chunk_size);\n            break;\n        default:\n            av_log(avctx, AV_LOG_WARNING, \"Skipping chunk type %02X\\n\",\n                   chunk_type);\n            bytestream2_skip(&bc, chunk_size);\n        }\n    }\n    if (got_header)\n        c->got_header = 1;\n\n    if (c->width && c->height && c->framebuf) {\n        if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n            return ret;\n\n        pic->key_frame = got_header;\n        pic->pict_type = got_header ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P;\n\n        for (i = 0; i < avctx->height; i++)\n            memcpy(pic->data[0] + i * pic->linesize[0],\n                   c->framebuf  + i * c->framebuf_stride,\n                   c->width * 3);\n        g2m_paint_cursor(c, pic->data[0], pic->linesize[0]);\n\n        *got_picture_ptr = 1;\n    }\n\n    return buf_size;\nheader_fail:\n    c->width   = c->height  = 0;\n    c->tiles_x = c->tiles_y = 0;\n    return ret;\n}\n\nstatic av_cold int g2m_decode_init(AVCodecContext *avctx)\n{\n    G2MContext * const c = avctx->priv_data;\n    int ret;\n\n    if ((ret = jpg_init(avctx, &c->jc)) != 0) {\n        av_log(avctx, AV_LOG_ERROR, \"Cannot initialise VLCs\\n\");\n        jpg_free_context(&c->jc);\n        return AVERROR(ENOMEM);\n    }\n\n    avctx->pix_fmt = AV_PIX_FMT_RGB24;\n\n    return 0;\n}\n\nstatic av_cold int g2m_decode_end(AVCodecContext *avctx)\n{\n    G2MContext * const c = avctx->priv_data;\n\n    jpg_free_context(&c->jc);\n\n    av_freep(&c->kempf_buf);\n    av_freep(&c->kempf_flags);\n    av_freep(&c->synth_tile);\n    av_freep(&c->jpeg_tile);\n    av_freep(&c->cursor);\n    av_freep(&c->framebuf);\n\n    return 0;\n}\n\nAVCodec ff_g2m_decoder = {\n    .name           = \"g2m\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Go2Meeting\"),\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_G2M,\n    .priv_data_size = sizeof(G2MContext),\n    .init           = g2m_decode_init,\n    .close          = g2m_decode_end,\n    .decode         = g2m_decode_frame,\n    .capabilities   = CODEC_CAP_DR1,\n};\n"], "filenames": ["libavcodec/g2meet.c"], "buggy_code_start_loc": [456], "buggy_code_end_loc": [457], "fixing_code_start_loc": [456], "fixing_code_end_loc": [457], "type": "CWE-189", "message": "The g2m_init_buffers function in libavcodec/g2meet.c in FFmpeg before 2.1 uses an incorrect ordering of arithmetic operations, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Go2Webinar data.", "other": {"cve": {"id": "CVE-2013-7013", "sourceIdentifier": "cve@mitre.org", "published": "2013-12-09T16:36:48.627", "lastModified": "2016-12-03T03:00:38.707", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The g2m_init_buffers function in libavcodec/g2meet.c in FFmpeg before 2.1 uses an incorrect ordering of arithmetic operations, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Go2Webinar data."}, {"lang": "es", "value": "La funci\u00f3n g2m_init_buffers en libavcodec/g2meet.c en FFmpeg anterior a v2.1 utiliza un incorrecto orden de las operaciones arim\u00e9ticas, lo que permite a atacantes remotos provocar una denegaci\u00f3n de servicio (acceso a array fuera de rango) o posiblemente tener otro impacto no especificado a trav\u00e9s de informaci\u00f3n Go2Webinar manipulada."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-189"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.0.1", "matchCriteriaId": "C41A1983-BA74-4806-A227-EBBF7989112C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3:*:*:*:*:*:*:*", "matchCriteriaId": "B2649A80-4739-4BBB-AB0B-99AD435BE7CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "D4A2E77D-B826-4B49-ADC8-7F704E149A5A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "18157837-4550-45E3-A12E-AE06E047E253"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "E9F42611-C3E2-416B-9AE7-A5AE83E4DEF7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "3A20789F-26E3-4871-B24E-25E922BADDF0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "67C6C243-3ACC-49C3-80CA-D7CA8FEFF0D8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "6AE6D368-0BA6-4499-B7E1-EE16C03012E9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "26C0F6EF-0452-4AFE-AF3E-B88F963A0938"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "5B4DD372-4D3B-445C-8C38-E083A3C0D4A7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "733C03D7-2780-4D69-A98D-BCFB91D1119A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "0AEE1977-E9E0-4BFF-B33B-B083E49E51F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "E6979C17-0BC6-47D1-9B73-254D84306A96"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "204C7C05-3441-4DB0-8702-D99C8FCB381E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.9:pre1:*:*:*:*:*:*", "matchCriteriaId": "2E1A7011-B992-4E35-B306-45772DACB23C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5:*:*:*:*:*:*:*", "matchCriteriaId": "8D486C17-FC4A-4AEE-A430-1B1FBCC2C27C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "632BC7C2-FE59-47B0-885C-0EB8C74DF041"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "5D1AE0BF-A6FD-4EBA-BF61-07AC81EA560D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "5B8FA106-FE65-4BB0-92A7-E8A5AF978A9B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "514669DA-8D02-44CE-BE18-8783F69AE394"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "8041E6ED-472A-40DF-AA90-F3509D90D47A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "D2C64382-9259-4D61-B352-7F123527289C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "32A152D9-947E-4198-9C2D-2A582F09AB75"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6:*:*:*:*:*:*:*", "matchCriteriaId": "37FBB817-A186-4517-9DA7-B3638576AAE7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "157ABA40-6101-4E9C-A24C-84F8E23D374D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "C7EA46DD-2CC4-426F-8709-821B7572C94A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "3DE12C59-4409-4F7A-9759-7B26FA9DAC34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7:*:*:*:*:*:*:*", "matchCriteriaId": "30FE6578-F031-4F5B-B955-8F912CFCA1B0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "07669E0E-8C4B-430E-802F-F64EEA2B5A0B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "F3EB7F17-F25D-4E48-8A43-F799619CE71F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.3:*:*:*:*:*:*:*", "matchCriteriaId": "60705A3B-7136-45D1-8068-E2DC9E01EB04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "C722B143-2648-4EB2-A090-7B788F41F300"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.5:*:*:*:*:*:*:*", "matchCriteriaId": "B31AFDBC-A782-4C18-8EAA-6D927397BEA3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.6:*:*:*:*:*:*:*", "matchCriteriaId": "73E9E8F4-A942-4F34-BCE2-82A180F1DD1F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.7:*:*:*:*:*:*:*", "matchCriteriaId": "AAA31D75-C3FB-4D89-8B2D-21372AAEB78B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.8:*:*:*:*:*:*:*", "matchCriteriaId": "B20E5358-826C-47A2-B39F-ED4E9213BA95"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.9:*:*:*:*:*:*:*", "matchCriteriaId": "26321888-E140-4F09-AAA0-7392AA7F6307"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.11:*:*:*:*:*:*:*", "matchCriteriaId": "7E46B9F3-A9C0-4B8A-A119-40CA4CBBD0EE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.12:*:*:*:*:*:*:*", "matchCriteriaId": "44800572-71C5-4AA1-9CB6-30AA902B0353"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "87090477-1D36-48B3-88AE-5CD5EE8F89D7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "2096FF8B-9B57-4C59-84DB-9CC0DEAB47AC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "34C99254-776C-4AAD-BDA2-3F544256AA67"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "CE9D7B73-9CDA-4BAE-8DD9-8E1E34C20648"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "4FDBF2C0-8E33-4575-8A19-4F1CABA3023F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "72040664-077A-48FB-9E6B-B69EA8D26CB4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "F428A2E4-A54F-4296-A00F-1A4E160253D7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.7:*:*:*:*:*:*:*", "matchCriteriaId": "5239E4FA-0359-49F1-93D4-24AB013FAC20"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.8:*:*:*:*:*:*:*", "matchCriteriaId": "F0C8230D-4E89-45F9-B0F7-E317119E0FA0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.10:*:*:*:*:*:*:*", "matchCriteriaId": "585CE7D2-1CE8-44AB-AE67-07D7D3721F68"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.11:*:*:*:*:*:*:*", "matchCriteriaId": "EE81C339-A794-4303-B829-BE743DF0B132"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.9:*:*:*:*:*:*:*", "matchCriteriaId": "5CE0A27B-66D7-4D1B-8E6A-F4722C070BD3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "864DC4A2-A378-4389-B62E-9E785879A744"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.10:*:*:*:*:*:*:*", "matchCriteriaId": "16304267-C808-4B6B-9903-2DEAB40AD899"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "CEEBBA83-1BFC-45A8-B34A-AB3A9B8A9414"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.10.4:*:*:*:*:*:*:*", "matchCriteriaId": "F559B34E-23EE-4E09-A044-E7F54C55B05E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.11:*:*:*:*:*:*:*", "matchCriteriaId": "62BA2708-BE77-42B7-B51A-C1B58632462C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "23E57BB1-DF1E-4173-BE52-72E2B3E6BA23"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "A3E30DB1-0CFC-4EAA-BF07-CE7551ABDCB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "DBA7D745-DC16-43B9-8A2D-4D6944A6BFD0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "87A511A5-2040-433A-9B32-B89332214FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "0C01DD9C-98C9-4896-8D66-A8336582298B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.2:*:*:*:*:*:*:*", "matchCriteriaId": "BBE7723A-3D6B-4390-B82E-6A5A6992141A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "1ED8FF93-5AA7-443C-BBDB-845736BB337B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:2.0:*:*:*:*:*:*:*", "matchCriteriaId": "A1337F5B-E9D9-4335-9E05-50018E59E530"}]}]}], "references": [{"url": "http://ffmpeg.org/security.html", "source": "cve@mitre.org"}, {"url": "http://openwall.com/lists/oss-security/2013/11/26/7", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://openwall.com/lists/oss-security/2013/12/08/3", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/821a5938d100458f4d09d634041b05c860554ce0", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}, {"url": "https://security.gentoo.org/glsa/201603-06", "source": "cve@mitre.org"}, {"url": "https://trac.ffmpeg.org/ticket/2922", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/821a5938d100458f4d09d634041b05c860554ce0"}}