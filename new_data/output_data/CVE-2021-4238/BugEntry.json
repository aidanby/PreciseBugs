{"buggy_code": ["/*\nCopyright 2014 Alexander Okoli\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage goutils\n\nimport (\n\t\"crypto/rand\"\n\t\"fmt\"\n\t\"math\"\n\t\"math/big\"\n\t\"regexp\"\n\t\"unicode\"\n)\n\n/*\nCryptoRandomNonAlphaNumeric creates a random string whose length is the number of characters specified.\nCharacters will be chosen from the set of all characters (ASCII/Unicode values between 0 to 2,147,483,647 (math.MaxInt32)).\n\nParameter:\n\tcount - the length of random string to create\n\nReturns:\n\tstring - the random string\n\terror - an error stemming from an invalid parameter within underlying function, CryptoRandom(...)\n*/\nfunc CryptoRandomNonAlphaNumeric(count int) (string, error) {\n\treturn CryptoRandomAlphaNumericCustom(count, false, false)\n}\n\n/*\nCryptoRandomAscii creates a random string whose length is the number of characters specified.\nCharacters will be chosen from the set of characters whose ASCII value is between 32 and 126 (inclusive).\n\nParameter:\n\tcount - the length of random string to create\n\nReturns:\n\tstring - the random string\n\terror - an error stemming from an invalid parameter within underlying function, CryptoRandom(...)\n*/\nfunc CryptoRandomAscii(count int) (string, error) {\n\treturn CryptoRandom(count, 32, 127, false, false)\n}\n\n/*\nCryptoRandomNumeric creates a random string whose length is the number of characters specified.\nCharacters will be chosen from the set of numeric characters.\n\nParameter:\n\tcount - the length of random string to create\n\nReturns:\n\tstring - the random string\n\terror - an error stemming from an invalid parameter within underlying function, CryptoRandom(...)\n*/\nfunc CryptoRandomNumeric(count int) (string, error) {\n\treturn CryptoRandom(count, 0, 0, false, true)\n}\n\n/*\nCryptoRandomAlphabetic creates a random string whose length is the number of characters specified.\nCharacters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n\nParameters:\n\tcount - the length of random string to create\n\tletters - if true, generated string may include alphabetic characters\n\tnumbers - if true, generated string may include numeric characters\n\nReturns:\n\tstring - the random string\n\terror - an error stemming from an invalid parameter within underlying function, CryptoRandom(...)\n*/\nfunc CryptoRandomAlphabetic(count int) (string, error) {\n\treturn CryptoRandom(count, 0, 0, true, false)\n}\n\n/*\nCryptoRandomAlphaNumeric creates a random string whose length is the number of characters specified.\nCharacters will be chosen from the set of alpha-numeric characters.\n\nParameter:\n\tcount - the length of random string to create\n\nReturns:\n\tstring - the random string\n\terror - an error stemming from an invalid parameter within underlying function, CryptoRandom(...)\n*/\nfunc CryptoRandomAlphaNumeric(count int) (string, error) {\n\tif count == 0 {\n\t\treturn \"\", nil\n\t}\n\tRandomString, err := CryptoRandom(count, 0, 0, true, true)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"Error: %s\", err)\n\t}\n\tmatch, err := regexp.MatchString(\"([0-9]+)\", RandomString)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif !match {\n\t\t//Get the position between 0 and the length of the string-1  to insert a random number\n\t\tposition := getCryptoRandomInt(count)\n\t\t//Insert a random number between [0-9] in the position\n\t\tRandomString = RandomString[:position] + string('0' + getCryptoRandomInt(10)) + RandomString[position + 1:]\n\t\treturn RandomString, err\n\t}\n\treturn RandomString, err\n\n}\n\n/*\nCryptoRandomAlphaNumericCustom creates a random string whose length is the number of characters specified.\nCharacters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n\nParameters:\n\tcount - the length of random string to create\n\tletters - if true, generated string may include alphabetic characters\n\tnumbers - if true, generated string may include numeric characters\n\nReturns:\n\tstring - the random string\n\terror - an error stemming from an invalid parameter within underlying function, CryptoRandom(...)\n*/\nfunc CryptoRandomAlphaNumericCustom(count int, letters bool, numbers bool) (string, error) {\n\treturn CryptoRandom(count, 0, 0, letters, numbers)\n}\n\n/*\nCryptoRandom creates a random string based on a variety of options, using using golang's crypto/rand source of randomness.\nIf the parameters start and end are both 0, start and end are set to ' ' and 'z', the ASCII printable characters, will be used,\nunless letters and numbers are both false, in which case, start and end are set to 0 and math.MaxInt32, respectively.\nIf chars is not nil, characters stored in chars that are between start and end are chosen.\n\nParameters:\n\tcount - the length of random string to create\n\tstart - the position in set of chars (ASCII/Unicode int) to start at\n\tend - the position in set of chars (ASCII/Unicode int) to end before\n\tletters - if true, generated string may include alphabetic characters\n\tnumbers - if true, generated string may include numeric characters\n\tchars - the set of chars to choose randoms from. If nil, then it will use the set of all chars.\n\nReturns:\n\tstring - the random string\n\terror - an error stemming from invalid parameters: if count < 0; or the provided chars array is empty; or end <= start; or end > len(chars)\n*/\nfunc CryptoRandom(count int, start int, end int, letters bool, numbers bool, chars ...rune) (string, error) {\n\tif count == 0 {\n\t\treturn \"\", nil\n\t} else if count < 0 {\n\t\terr := fmt.Errorf(\"randomstringutils illegal argument: Requested random string length %v is less than 0.\", count) // equiv to err := errors.New(\"...\")\n\t\treturn \"\", err\n\t}\n\tif chars != nil && len(chars) == 0 {\n\t\terr := fmt.Errorf(\"randomstringutils illegal argument: The chars array must not be empty\")\n\t\treturn \"\", err\n\t}\n\n\tif start == 0 && end == 0 {\n\t\tif chars != nil {\n\t\t\tend = len(chars)\n\t\t} else {\n\t\t\tif !letters && !numbers {\n\t\t\t\tend = math.MaxInt32\n\t\t\t} else {\n\t\t\t\tend = 'z' + 1\n\t\t\t\tstart = ' '\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif end <= start {\n\t\t\terr := fmt.Errorf(\"randomstringutils illegal argument: Parameter end (%v) must be greater than start (%v)\", end, start)\n\t\t\treturn \"\", err\n\t\t}\n\n\t\tif chars != nil && end > len(chars) {\n\t\t\terr := fmt.Errorf(\"randomstringutils illegal argument: Parameter end (%v) cannot be greater than len(chars) (%v)\", end, len(chars))\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\n\tbuffer := make([]rune, count)\n\tgap := end - start\n\n\t// high-surrogates range, (\\uD800-\\uDBFF) = 55296 - 56319\n\t//  low-surrogates range, (\\uDC00-\\uDFFF) = 56320 - 57343\n\n\tfor count != 0 {\n\t\tcount--\n\t\tvar ch rune\n\t\tif chars == nil {\n\t\t\tch = rune(getCryptoRandomInt(gap) + int64(start))\n\t\t} else {\n\t\t\tch = chars[getCryptoRandomInt(gap) + int64(start)]\n\t\t}\n\n\t\tif letters && unicode.IsLetter(ch) || numbers && unicode.IsDigit(ch) || !letters && !numbers {\n\t\t\tif ch >= 56320 && ch <= 57343 { // low surrogate range\n\t\t\t\tif count == 0 {\n\t\t\t\t\tcount++\n\t\t\t\t} else {\n\t\t\t\t\t// Insert low surrogate\n\t\t\t\t\tbuffer[count] = ch\n\t\t\t\t\tcount--\n\t\t\t\t\t// Insert high surrogate\n\t\t\t\t\tbuffer[count] = rune(55296 + getCryptoRandomInt(128))\n\t\t\t\t}\n\t\t\t} else if ch >= 55296 && ch <= 56191 { // High surrogates range (Partial)\n\t\t\t\tif count == 0 {\n\t\t\t\t\tcount++\n\t\t\t\t} else {\n\t\t\t\t\t// Insert low surrogate\n\t\t\t\t\tbuffer[count] = rune(56320 + getCryptoRandomInt(128))\n\t\t\t\t\tcount--\n\t\t\t\t\t// Insert high surrogate\n\t\t\t\t\tbuffer[count] = ch\n\t\t\t\t}\n\t\t\t} else if ch >= 56192 && ch <= 56319 {\n\t\t\t\t// private high surrogate, skip it\n\t\t\t\tcount++\n\t\t\t} else {\n\t\t\t\t// not one of the surrogates*\n\t\t\t\tbuffer[count] = ch\n\t\t\t}\n\t\t} else {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn string(buffer), nil\n}\n\nfunc getCryptoRandomInt(count int) int64 {\n\tnBig, err := rand.Int(rand.Reader, big.NewInt(int64(count)))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn nBig.Int64()\n}\n", "package goutils\n\nimport (\n\t\"testing\"\n\t\"unicode/utf8\"\n)\n\nfunc TestCryptoRandomNonAlphaNumeric(t *testing.T) {\n\t// If asked for a string 0 characters long, CryptoRandomNonAlphaNumeric should provide an empty string.\n\tif x, _ := CryptoRandomNonAlphaNumeric(0); utf8.RuneCountInString(x) != 0 {\n\t\tt.Errorf(\"String should be 0 characters; string was %v characters\", utf8.RuneCountInString(x))\n\t}\n\n\t// Test CryptoRandomNonAlphaNumeric's ability to generate strings 1 through 100 characters in length.\n\tfor i := 1; i < 101; i++ {\n\t\tif x, _ := CryptoRandomNonAlphaNumeric(i); utf8.RuneCountInString(x) != i {\n\t\t\tt.Errorf(\"String should be %v characters; string was %v characters\", i, utf8.RuneCountInString(x))\n\t\t}\n\t}\n}\n\nfunc TestCryptoRandomAscii(t *testing.T) {\n\t// If asked for a string 0 characters long, CryptoRandomAscii should provide an empty string.\n\tif x, _ := CryptoRandomAscii(0); len(x) != 0 {\n\t\tt.Errorf(\"String should be 0 characters; string was %v characters\", len(x))\n\t}\n\n\t// Test CryptoRandomAscii's ability to generate strings 1 through 100 characters in length.\n\tfor i := 1; i < 101; i++ {\n\t\tif x, _ := CryptoRandomAscii(i); len(x) != i {\n\t\t\tt.Errorf(\"String should be %v characters; string was %v characters\", i, len(x))\n\t\t}\n\t}\n}\n\nfunc TestCryptoRandomNumeric(t *testing.T) {\n\t// If asked for a string 0 characters long, CryptoRandomNumeric should provide an empty string.\n\tif x, _ := CryptoRandomNumeric(0); len(x) != 0 {\n\t\tt.Errorf(\"String should be 0 characters; string was %v characters\", len(x))\n\t}\n\n\t// Test CryptoRandomNumeric's ability to generate strings 1 through 100 characters in length.\n\tfor i := 1; i < 101; i++ {\n\t\tif x, _ := CryptoRandomNumeric(i); len(x) != i {\n\t\t\tt.Errorf(\"String should be %v characters; string was %v characters\", i, len(x))\n\t\t}\n\t}\n}\n\nfunc TestCryptoRandomAlphabetic(t *testing.T) {\n\t// If asked for a string 0 characters long, CryptoRandomAlphabetic should provide an empty string.\n\tif x, _ := CryptoRandomAlphabetic(0); len(x) != 0 {\n\t\tt.Errorf(\"String should be 0 characters; string was %v characters\", len(x))\n\t}\n\n\t// Test CryptoRandomAlphabetic's ability to generate strings 1 through 100 characters in length.\n\tfor i := 1; i < 101; i++ {\n\t\tif x, _ := CryptoRandomAlphabetic(i); len(x) != i {\n\t\t\tt.Errorf(\"String should be %v characters; string was %v characters\", i, len(x))\n\t\t}\n\t}\n}\n\nfunc TestCryptoRandomAlphaNumeric(t *testing.T) {\n\t// If asked for a string 0 characters long, CryptoRandomAlphaNumeric should provide an empty string.\n\tif x, _ := CryptoRandomAlphaNumeric(0); len(x) != 0 {\n\t\tt.Errorf(\"String should be 0 characters; string was %v characters\", len(x))\n\t}\n\n\t// Test CryptoRandomAlphaNumeric's ability to generate strings 1 through 100 characters in length.\n\tfor i := 1; i < 101; i++ {\n\t\tif x, _ := CryptoRandomAlphaNumeric(i); len(x) != i {\n\t\t\tt.Errorf(\"String should be %v characters; string was %v characters\", i, len(x))\n\t\t}\n\t}\n}\n", "/*\nCopyright 2014 Alexander Okoli\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage goutils\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"math/rand\"\n\t\"regexp\"\n\t\"time\"\n\t\"unicode\"\n)\n\n// RANDOM provides the time-based seed used to generate random numbers\nvar RANDOM = rand.New(rand.NewSource(time.Now().UnixNano()))\n\n/*\nRandomNonAlphaNumeric creates a random string whose length is the number of characters specified.\nCharacters will be chosen from the set of all characters (ASCII/Unicode values between 0 to 2,147,483,647 (math.MaxInt32)).\n\nParameter:\n\tcount - the length of random string to create\n\nReturns:\n\tstring - the random string\n\terror - an error stemming from an invalid parameter within underlying function, RandomSeed(...)\n*/\nfunc RandomNonAlphaNumeric(count int) (string, error) {\n\treturn RandomAlphaNumericCustom(count, false, false)\n}\n\n/*\nRandomAscii creates a random string whose length is the number of characters specified.\nCharacters will be chosen from the set of characters whose ASCII value is between 32 and 126 (inclusive).\n\nParameter:\n\tcount - the length of random string to create\n\nReturns:\n\tstring - the random string\n\terror - an error stemming from an invalid parameter within underlying function, RandomSeed(...)\n*/\nfunc RandomAscii(count int) (string, error) {\n\treturn Random(count, 32, 127, false, false)\n}\n\n/*\nRandomNumeric creates a random string whose length is the number of characters specified.\nCharacters will be chosen from the set of numeric characters.\n\nParameter:\n\tcount - the length of random string to create\n\nReturns:\n\tstring - the random string\n\terror - an error stemming from an invalid parameter within underlying function, RandomSeed(...)\n*/\nfunc RandomNumeric(count int) (string, error) {\n\treturn Random(count, 0, 0, false, true)\n}\n\n/*\nRandomAlphabetic creates a random string whose length is the number of characters specified.\nCharacters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n\nParameters:\n\tcount - the length of random string to create\n\tletters - if true, generated string may include alphabetic characters\n\tnumbers - if true, generated string may include numeric characters\n\nReturns:\n\tstring - the random string\n\terror - an error stemming from an invalid parameter within underlying function, RandomSeed(...)\n*/\nfunc RandomAlphabetic(count int) (string, error) {\n\treturn Random(count, 0, 0, true, false)\n}\n\n/*\nRandomAlphaNumeric creates a random string whose length is the number of characters specified.\nCharacters will be chosen from the set of alpha-numeric characters.\n\nParameter:\n\tcount - the length of random string to create\n\nReturns:\n\tstring - the random string\n\terror - an error stemming from an invalid parameter within underlying function, RandomSeed(...)\n*/\nfunc RandomAlphaNumeric(count int) (string, error) {\n\tRandomString, err := Random(count, 0, 0, true, true)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"Error: %s\", err)\n\t}\n\tmatch, err := regexp.MatchString(\"([0-9]+)\", RandomString)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif !match {\n\t\t//Get the position between 0 and the length of the string-1  to insert a random number\n\t\tposition := rand.Intn(count)\n\t\t//Insert a random number between [0-9] in the position\n\t\tRandomString = RandomString[:position] + string('0'+rand.Intn(10)) + RandomString[position+1:]\n\t\treturn RandomString, err\n\t}\n\treturn RandomString, err\n\n}\n\n/*\nRandomAlphaNumericCustom creates a random string whose length is the number of characters specified.\nCharacters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n\nParameters:\n\tcount - the length of random string to create\n\tletters - if true, generated string may include alphabetic characters\n\tnumbers - if true, generated string may include numeric characters\n\nReturns:\n\tstring - the random string\n\terror - an error stemming from an invalid parameter within underlying function, RandomSeed(...)\n*/\nfunc RandomAlphaNumericCustom(count int, letters bool, numbers bool) (string, error) {\n\treturn Random(count, 0, 0, letters, numbers)\n}\n\n/*\nRandom creates a random string based on a variety of options, using default source of randomness.\nThis method has exactly the same semantics as RandomSeed(int, int, int, bool, bool, []char, *rand.Rand), but\ninstead of using an externally supplied source of randomness, it uses the internal *rand.Rand instance.\n\nParameters:\n\tcount - the length of random string to create\n\tstart - the position in set of chars (ASCII/Unicode int) to start at\n\tend - the position in set of chars (ASCII/Unicode int) to end before\n\tletters - if true, generated string may include alphabetic characters\n\tnumbers - if true, generated string may include numeric characters\n\tchars - the set of chars to choose randoms from. If nil, then it will use the set of all chars.\n\nReturns:\n\tstring - the random string\n\terror - an error stemming from an invalid parameter within underlying function, RandomSeed(...)\n*/\nfunc Random(count int, start int, end int, letters bool, numbers bool, chars ...rune) (string, error) {\n\treturn RandomSeed(count, start, end, letters, numbers, chars, RANDOM)\n}\n\n/*\nRandomSeed creates a random string based on a variety of options, using supplied source of randomness.\nIf the parameters start and end are both 0, start and end are set to ' ' and 'z', the ASCII printable characters, will be used,\nunless letters and numbers are both false, in which case, start and end are set to 0 and math.MaxInt32, respectively.\nIf chars is not nil, characters stored in chars that are between start and end are chosen.\nThis method accepts a user-supplied *rand.Rand instance to use as a source of randomness. By seeding a single *rand.Rand instance\nwith a fixed seed and using it for each call, the same random sequence of strings can be generated repeatedly and predictably.\n\nParameters:\n\tcount - the length of random string to create\n\tstart - the position in set of chars (ASCII/Unicode decimals) to start at\n\tend - the position in set of chars (ASCII/Unicode decimals) to end before\n\tletters - if true, generated string may include alphabetic characters\n\tnumbers - if true, generated string may include numeric characters\n\tchars - the set of chars to choose randoms from. If nil, then it will use the set of all chars.\n\trandom - a source of randomness.\n\nReturns:\n\tstring - the random string\n\terror - an error stemming from invalid parameters: if count < 0; or the provided chars array is empty; or end <= start; or end > len(chars)\n*/\nfunc RandomSeed(count int, start int, end int, letters bool, numbers bool, chars []rune, random *rand.Rand) (string, error) {\n\n\tif count == 0 {\n\t\treturn \"\", nil\n\t} else if count < 0 {\n\t\terr := fmt.Errorf(\"randomstringutils illegal argument: Requested random string length %v is less than 0.\", count) // equiv to err := errors.New(\"...\")\n\t\treturn \"\", err\n\t}\n\tif chars != nil && len(chars) == 0 {\n\t\terr := fmt.Errorf(\"randomstringutils illegal argument: The chars array must not be empty\")\n\t\treturn \"\", err\n\t}\n\n\tif start == 0 && end == 0 {\n\t\tif chars != nil {\n\t\t\tend = len(chars)\n\t\t} else {\n\t\t\tif !letters && !numbers {\n\t\t\t\tend = math.MaxInt32\n\t\t\t} else {\n\t\t\t\tend = 'z' + 1\n\t\t\t\tstart = ' '\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif end <= start {\n\t\t\terr := fmt.Errorf(\"randomstringutils illegal argument: Parameter end (%v) must be greater than start (%v)\", end, start)\n\t\t\treturn \"\", err\n\t\t}\n\n\t\tif chars != nil && end > len(chars) {\n\t\t\terr := fmt.Errorf(\"randomstringutils illegal argument: Parameter end (%v) cannot be greater than len(chars) (%v)\", end, len(chars))\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\n\tbuffer := make([]rune, count)\n\tgap := end - start\n\n\t// high-surrogates range, (\\uD800-\\uDBFF) = 55296 - 56319\n\t//  low-surrogates range, (\\uDC00-\\uDFFF) = 56320 - 57343\n\n\tfor count != 0 {\n\t\tcount--\n\t\tvar ch rune\n\t\tif chars == nil {\n\t\t\tch = rune(random.Intn(gap) + start)\n\t\t} else {\n\t\t\tch = chars[random.Intn(gap)+start]\n\t\t}\n\n\t\tif letters && unicode.IsLetter(ch) || numbers && unicode.IsDigit(ch) || !letters && !numbers {\n\t\t\tif ch >= 56320 && ch <= 57343 { // low surrogate range\n\t\t\t\tif count == 0 {\n\t\t\t\t\tcount++\n\t\t\t\t} else {\n\t\t\t\t\t// Insert low surrogate\n\t\t\t\t\tbuffer[count] = ch\n\t\t\t\t\tcount--\n\t\t\t\t\t// Insert high surrogate\n\t\t\t\t\tbuffer[count] = rune(55296 + random.Intn(128))\n\t\t\t\t}\n\t\t\t} else if ch >= 55296 && ch <= 56191 { // High surrogates range (Partial)\n\t\t\t\tif count == 0 {\n\t\t\t\t\tcount++\n\t\t\t\t} else {\n\t\t\t\t\t// Insert low surrogate\n\t\t\t\t\tbuffer[count] = rune(56320 + random.Intn(128))\n\t\t\t\t\tcount--\n\t\t\t\t\t// Insert high surrogate\n\t\t\t\t\tbuffer[count] = ch\n\t\t\t\t}\n\t\t\t} else if ch >= 56192 && ch <= 56319 {\n\t\t\t\t// private high surrogate, skip it\n\t\t\t\tcount++\n\t\t\t} else {\n\t\t\t\t// not one of the surrogates*\n\t\t\t\tbuffer[count] = ch\n\t\t\t}\n\t\t} else {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn string(buffer), nil\n}\n", "package goutils\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"testing\"\n)\n\n// ****************************** TESTS ********************************************\n\nfunc TestRandomSeed(t *testing.T) {\n\n\t// count, start, end, letters, numbers := 5, 0, 0, true, true\n\trandom := rand.New(rand.NewSource(10))\n\tout := \"3ip9v\"\n\n\t// Test 1: Simulating RandomAlphaNumeric(count int)\n\tif x, _ := RandomSeed(5, 0, 0, true, true, nil, random); x != out {\n\t\tt.Errorf(\"RandomSeed(%v, %v, %v, %v, %v, %v, %v) = %v, want %v\", 5, 0, 0, true, true, nil, random, x, out)\n\t}\n\n\t// Test 2: Simulating RandomAlphabetic(count int)\n\tout = \"MBrbj\"\n\n\tif x, _ := RandomSeed(5, 0, 0, true, false, nil, random); x != out {\n\t\tt.Errorf(\"RandomSeed(%v, %v, %v, %v, %v, %v, %v) = %v, want %v\", 5, 0, 0, true, false, nil, random, x, out)\n\t}\n\n\t// Test 3: Simulating RandomNumeric(count int)\n\tout = \"88935\"\n\n\tif x, _ := RandomSeed(5, 0, 0, false, true, nil, random); x != out {\n\t\tt.Errorf(\"RandomSeed(%v, %v, %v, %v, %v, %v, %v) = %v, want %v\", 5, 0, 0, false, true, nil, random, x, out)\n\t}\n\n\t// Test 4: Simulating RandomAscii(count int)\n\tout = \"H_I;E\"\n\n\tif x, _ := RandomSeed(5, 32, 127, false, false, nil, random); x != out {\n\t\tt.Errorf(\"RandomSeed(%v, %v, %v, %v, %v, %v, %v) = %v, want %v\", 5, 32, 127, false, false, nil, random, x, out)\n\t}\n\n\t// Test 5: Simulating RandomSeed(...) with custom chars\n\tchars := []rune{'1', '2', '3', 'a', 'b', 'c'}\n\tout = \"2b2ca\"\n\n\tif x, _ := RandomSeed(5, 0, 0, false, false, chars, random); x != out {\n\t\tt.Errorf(\"RandomSeed(%v, %v, %v, %v, %v, %v, %v) = %v, want %v\", 5, 0, 0, false, false, chars, random, x, out)\n\t}\n\n}\n\n// ****************************** EXAMPLES ********************************************\n\nfunc ExampleRandomSeed() {\n\n\tvar seed int64 = 10 // If you change this seed #, the random sequence below will change\n\trandom := rand.New(rand.NewSource(seed))\n\tchars := []rune{'1', '2', '3', 'a', 'b', 'c'}\n\n\trand1, _ := RandomSeed(5, 0, 0, true, true, nil, random)      // RandomAlphaNumeric (Alphabets and numbers possible)\n\trand2, _ := RandomSeed(5, 0, 0, true, false, nil, random)     // RandomAlphabetic (Only alphabets)\n\trand3, _ := RandomSeed(5, 0, 0, false, true, nil, random)     // RandomNumeric (Only numbers)\n\trand4, _ := RandomSeed(5, 32, 127, false, false, nil, random) // RandomAscii (Alphabets, numbers, and other ASCII chars)\n\trand5, _ := RandomSeed(5, 0, 0, true, true, chars, random)    // RandomSeed with custom characters\n\n\tfmt.Println(rand1)\n\tfmt.Println(rand2)\n\tfmt.Println(rand3)\n\tfmt.Println(rand4)\n\tfmt.Println(rand5)\n\t// Output:\n\t// 3ip9v\n\t// MBrbj\n\t// 88935\n\t// H_I;E\n\t// 2b2ca\n}\n"], "fixing_code": ["/*\nCopyright 2014 Alexander Okoli\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage goutils\n\nimport (\n\t\"crypto/rand\"\n\t\"fmt\"\n\t\"math\"\n\t\"math/big\"\n\t\"unicode\"\n)\n\n/*\nCryptoRandomNonAlphaNumeric creates a random string whose length is the number of characters specified.\nCharacters will be chosen from the set of all characters (ASCII/Unicode values between 0 to 2,147,483,647 (math.MaxInt32)).\n\nParameter:\n\tcount - the length of random string to create\n\nReturns:\n\tstring - the random string\n\terror - an error stemming from an invalid parameter within underlying function, CryptoRandom(...)\n*/\nfunc CryptoRandomNonAlphaNumeric(count int) (string, error) {\n\treturn CryptoRandomAlphaNumericCustom(count, false, false)\n}\n\n/*\nCryptoRandomAscii creates a random string whose length is the number of characters specified.\nCharacters will be chosen from the set of characters whose ASCII value is between 32 and 126 (inclusive).\n\nParameter:\n\tcount - the length of random string to create\n\nReturns:\n\tstring - the random string\n\terror - an error stemming from an invalid parameter within underlying function, CryptoRandom(...)\n*/\nfunc CryptoRandomAscii(count int) (string, error) {\n\treturn CryptoRandom(count, 32, 127, false, false)\n}\n\n/*\nCryptoRandomNumeric creates a random string whose length is the number of characters specified.\nCharacters will be chosen from the set of numeric characters.\n\nParameter:\n\tcount - the length of random string to create\n\nReturns:\n\tstring - the random string\n\terror - an error stemming from an invalid parameter within underlying function, CryptoRandom(...)\n*/\nfunc CryptoRandomNumeric(count int) (string, error) {\n\treturn CryptoRandom(count, 0, 0, false, true)\n}\n\n/*\nCryptoRandomAlphabetic creates a random string whose length is the number of characters specified.\nCharacters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n\nParameters:\n\tcount - the length of random string to create\n\tletters - if true, generated string may include alphabetic characters\n\tnumbers - if true, generated string may include numeric characters\n\nReturns:\n\tstring - the random string\n\terror - an error stemming from an invalid parameter within underlying function, CryptoRandom(...)\n*/\nfunc CryptoRandomAlphabetic(count int) (string, error) {\n\treturn CryptoRandom(count, 0, 0, true, false)\n}\n\n/*\nCryptoRandomAlphaNumeric creates a random string whose length is the number of characters specified.\nCharacters will be chosen from the set of alpha-numeric characters.\n\nParameter:\n\tcount - the length of random string to create\n\nReturns:\n\tstring - the random string\n\terror - an error stemming from an invalid parameter within underlying function, CryptoRandom(...)\n*/\nfunc CryptoRandomAlphaNumeric(count int) (string, error) {\n\tif count == 0 {\n\t\treturn \"\", nil\n\t}\n\n\treturn CryptoRandom(count, 0, 0, true, true)\n}\n\n/*\nCryptoRandomAlphaNumericCustom creates a random string whose length is the number of characters specified.\nCharacters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n\nParameters:\n\tcount - the length of random string to create\n\tletters - if true, generated string may include alphabetic characters\n\tnumbers - if true, generated string may include numeric characters\n\nReturns:\n\tstring - the random string\n\terror - an error stemming from an invalid parameter within underlying function, CryptoRandom(...)\n*/\nfunc CryptoRandomAlphaNumericCustom(count int, letters bool, numbers bool) (string, error) {\n\treturn CryptoRandom(count, 0, 0, letters, numbers)\n}\n\n/*\nCryptoRandom creates a random string based on a variety of options, using using golang's crypto/rand source of randomness.\nIf the parameters start and end are both 0, start and end are set to ' ' and 'z', the ASCII printable characters, will be used,\nunless letters and numbers are both false, in which case, start and end are set to 0 and math.MaxInt32, respectively.\nIf chars is not nil, characters stored in chars that are between start and end are chosen.\n\nParameters:\n\tcount - the length of random string to create\n\tstart - the position in set of chars (ASCII/Unicode int) to start at\n\tend - the position in set of chars (ASCII/Unicode int) to end before\n\tletters - if true, generated string may include alphabetic characters\n\tnumbers - if true, generated string may include numeric characters\n\tchars - the set of chars to choose randoms from. If nil, then it will use the set of all chars.\n\nReturns:\n\tstring - the random string\n\terror - an error stemming from invalid parameters: if count < 0; or the provided chars array is empty; or end <= start; or end > len(chars)\n*/\nfunc CryptoRandom(count int, start int, end int, letters bool, numbers bool, chars ...rune) (string, error) {\n\tif count == 0 {\n\t\treturn \"\", nil\n\t} else if count < 0 {\n\t\terr := fmt.Errorf(\"randomstringutils illegal argument: Requested random string length %v is less than 0.\", count) // equiv to err := errors.New(\"...\")\n\t\treturn \"\", err\n\t}\n\tif chars != nil && len(chars) == 0 {\n\t\terr := fmt.Errorf(\"randomstringutils illegal argument: The chars array must not be empty\")\n\t\treturn \"\", err\n\t}\n\n\tif start == 0 && end == 0 {\n\t\tif chars != nil {\n\t\t\tend = len(chars)\n\t\t} else {\n\t\t\tif !letters && !numbers {\n\t\t\t\tend = math.MaxInt32\n\t\t\t} else {\n\t\t\t\tend = 'z' + 1\n\t\t\t\tstart = ' '\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif end <= start {\n\t\t\terr := fmt.Errorf(\"randomstringutils illegal argument: Parameter end (%v) must be greater than start (%v)\", end, start)\n\t\t\treturn \"\", err\n\t\t}\n\n\t\tif chars != nil && end > len(chars) {\n\t\t\terr := fmt.Errorf(\"randomstringutils illegal argument: Parameter end (%v) cannot be greater than len(chars) (%v)\", end, len(chars))\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\n\tbuffer := make([]rune, count)\n\tgap := end - start\n\n\t// high-surrogates range, (\\uD800-\\uDBFF) = 55296 - 56319\n\t//  low-surrogates range, (\\uDC00-\\uDFFF) = 56320 - 57343\n\n\tfor count != 0 {\n\t\tcount--\n\t\tvar ch rune\n\t\tif chars == nil {\n\t\t\tch = rune(getCryptoRandomInt(gap) + int64(start))\n\t\t} else {\n\t\t\tch = chars[getCryptoRandomInt(gap)+int64(start)]\n\t\t}\n\n\t\tif letters && unicode.IsLetter(ch) || numbers && unicode.IsDigit(ch) || !letters && !numbers {\n\t\t\tif ch >= 56320 && ch <= 57343 { // low surrogate range\n\t\t\t\tif count == 0 {\n\t\t\t\t\tcount++\n\t\t\t\t} else {\n\t\t\t\t\t// Insert low surrogate\n\t\t\t\t\tbuffer[count] = ch\n\t\t\t\t\tcount--\n\t\t\t\t\t// Insert high surrogate\n\t\t\t\t\tbuffer[count] = rune(55296 + getCryptoRandomInt(128))\n\t\t\t\t}\n\t\t\t} else if ch >= 55296 && ch <= 56191 { // High surrogates range (Partial)\n\t\t\t\tif count == 0 {\n\t\t\t\t\tcount++\n\t\t\t\t} else {\n\t\t\t\t\t// Insert low surrogate\n\t\t\t\t\tbuffer[count] = rune(56320 + getCryptoRandomInt(128))\n\t\t\t\t\tcount--\n\t\t\t\t\t// Insert high surrogate\n\t\t\t\t\tbuffer[count] = ch\n\t\t\t\t}\n\t\t\t} else if ch >= 56192 && ch <= 56319 {\n\t\t\t\t// private high surrogate, skip it\n\t\t\t\tcount++\n\t\t\t} else {\n\t\t\t\t// not one of the surrogates*\n\t\t\t\tbuffer[count] = ch\n\t\t\t}\n\t\t} else {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn string(buffer), nil\n}\n\nfunc getCryptoRandomInt(count int) int64 {\n\tnBig, err := rand.Int(rand.Reader, big.NewInt(int64(count)))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn nBig.Int64()\n}\n", "package goutils\n\nimport (\n\t\"regexp\"\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf8\"\n)\n\nfunc TestCryptoRandomNonAlphaNumeric(t *testing.T) {\n\t// If asked for a string 0 characters long, CryptoRandomNonAlphaNumeric should provide an empty string.\n\tif x, _ := CryptoRandomNonAlphaNumeric(0); utf8.RuneCountInString(x) != 0 {\n\t\tt.Errorf(\"String should be 0 characters; string was %v characters\", utf8.RuneCountInString(x))\n\t}\n\n\t// Test CryptoRandomNonAlphaNumeric's ability to generate strings 1 through 100 characters in length.\n\tfor i := 1; i < 101; i++ {\n\t\tif x, _ := CryptoRandomNonAlphaNumeric(i); utf8.RuneCountInString(x) != i {\n\t\t\tt.Errorf(\"String should be %v characters; string was %v characters\", i, utf8.RuneCountInString(x))\n\t\t}\n\t}\n}\n\nfunc TestCryptoRandomAscii(t *testing.T) {\n\t// If asked for a string 0 characters long, CryptoRandomAscii should provide an empty string.\n\tif x, _ := CryptoRandomAscii(0); len(x) != 0 {\n\t\tt.Errorf(\"String should be 0 characters; string was %v characters\", len(x))\n\t}\n\n\t// Test CryptoRandomAscii's ability to generate strings 1 through 100 characters in length.\n\tfor i := 1; i < 101; i++ {\n\t\tif x, _ := CryptoRandomAscii(i); len(x) != i {\n\t\t\tt.Errorf(\"String should be %v characters; string was %v characters\", i, len(x))\n\t\t}\n\t}\n}\n\nfunc TestCryptoRandomNumeric(t *testing.T) {\n\t// If asked for a string 0 characters long, CryptoRandomNumeric should provide an empty string.\n\tif x, _ := CryptoRandomNumeric(0); len(x) != 0 {\n\t\tt.Errorf(\"String should be 0 characters; string was %v characters\", len(x))\n\t}\n\n\t// Test CryptoRandomNumeric's ability to generate strings 1 through 100 characters in length.\n\tfor i := 1; i < 101; i++ {\n\t\tif x, _ := CryptoRandomNumeric(i); len(x) != i {\n\t\t\tt.Errorf(\"String should be %v characters; string was %v characters\", i, len(x))\n\t\t}\n\t}\n}\n\nfunc TestCryptoRandomAlphabetic(t *testing.T) {\n\t// If asked for a string 0 characters long, CryptoRandomAlphabetic should provide an empty string.\n\tif x, _ := CryptoRandomAlphabetic(0); len(x) != 0 {\n\t\tt.Errorf(\"String should be 0 characters; string was %v characters\", len(x))\n\t}\n\n\t// Test CryptoRandomAlphabetic's ability to generate strings 1 through 100 characters in length.\n\tfor i := 1; i < 101; i++ {\n\t\tif x, _ := CryptoRandomAlphabetic(i); len(x) != i {\n\t\t\tt.Errorf(\"String should be %v characters; string was %v characters\", i, len(x))\n\t\t}\n\t}\n}\n\nfunc TestCryptoRandomAlphaNumeric(t *testing.T) {\n\t// If asked for a string 0 characters long, CryptoRandomAlphaNumeric should provide an empty string.\n\tif x, _ := CryptoRandomAlphaNumeric(0); len(x) != 0 {\n\t\tt.Errorf(\"String should be 0 characters; string was %v characters\", len(x))\n\t}\n\n\t// Test CryptoRandomAlphaNumeric's ability to generate strings 1 through 100 characters in length.\n\tfor i := 1; i < 101; i++ {\n\t\tif x, _ := CryptoRandomAlphaNumeric(i); len(x) != i {\n\t\t\tt.Errorf(\"String should be %v characters; string was %v characters\", i, len(x))\n\t\t}\n\t}\n}\n\nfunc TestCryptoRandAlphaNumeric_FuzzOnlyNumeric(t *testing.T) {\n\n\t// Testing for a reported regression in which some versions produced\n\t// a predictably small set of chars.\n\titers := 1000\n\tcharlen := 0\n\tfor i := 0; i < 16; i++ {\n\t\tnumOnly := 0\n\t\tcharlen++\n\t\tfor i := 0; i < iters; i++ {\n\t\t\tout, err := CryptoRandomAlphaNumeric(charlen)\n\t\t\tprintln(out)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(\"func failed to produce a random thinger\")\n\t\t\t}\n\t\t\tif _, err := strconv.Atoi(out); err == nil {\n\t\t\t\tnumOnly++\n\t\t\t}\n\n\t\t\tm, err := regexp.MatchString(\"^[0-9a-zA-Z]+$\", out)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif !m {\n\t\t\t\tt.Fatal(\"Character is not alphanum\")\n\t\t\t}\n\t\t}\n\n\t\tif numOnly == iters {\n\t\t\tt.Fatalf(\"Got %d numeric-only random sequences\", numOnly)\n\t\t}\n\t}\n\n}\n", "/*\nCopyright 2014 Alexander Okoli\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage goutils\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"math/rand\"\n\t\"time\"\n\t\"unicode\"\n)\n\n// RANDOM provides the time-based seed used to generate random numbers\nvar RANDOM = rand.New(rand.NewSource(time.Now().UnixNano()))\n\n/*\nRandomNonAlphaNumeric creates a random string whose length is the number of characters specified.\nCharacters will be chosen from the set of all characters (ASCII/Unicode values between 0 to 2,147,483,647 (math.MaxInt32)).\n\nParameter:\n\tcount - the length of random string to create\n\nReturns:\n\tstring - the random string\n\terror - an error stemming from an invalid parameter within underlying function, RandomSeed(...)\n*/\nfunc RandomNonAlphaNumeric(count int) (string, error) {\n\treturn RandomAlphaNumericCustom(count, false, false)\n}\n\n/*\nRandomAscii creates a random string whose length is the number of characters specified.\nCharacters will be chosen from the set of characters whose ASCII value is between 32 and 126 (inclusive).\n\nParameter:\n\tcount - the length of random string to create\n\nReturns:\n\tstring - the random string\n\terror - an error stemming from an invalid parameter within underlying function, RandomSeed(...)\n*/\nfunc RandomAscii(count int) (string, error) {\n\treturn Random(count, 32, 127, false, false)\n}\n\n/*\nRandomNumeric creates a random string whose length is the number of characters specified.\nCharacters will be chosen from the set of numeric characters.\n\nParameter:\n\tcount - the length of random string to create\n\nReturns:\n\tstring - the random string\n\terror - an error stemming from an invalid parameter within underlying function, RandomSeed(...)\n*/\nfunc RandomNumeric(count int) (string, error) {\n\treturn Random(count, 0, 0, false, true)\n}\n\n/*\nRandomAlphabetic creates a random string whose length is the number of characters specified.\nCharacters will be chosen from the set of alphabetic characters.\n\nParameters:\n\tcount - the length of random string to create\n\nReturns:\n\tstring - the random string\n\terror - an error stemming from an invalid parameter within underlying function, RandomSeed(...)\n*/\nfunc RandomAlphabetic(count int) (string, error) {\n\treturn Random(count, 0, 0, true, false)\n}\n\n/*\nRandomAlphaNumeric creates a random string whose length is the number of characters specified.\nCharacters will be chosen from the set of alpha-numeric characters.\n\nParameter:\n\tcount - the length of random string to create\n\nReturns:\n\tstring - the random string\n\terror - an error stemming from an invalid parameter within underlying function, RandomSeed(...)\n*/\nfunc RandomAlphaNumeric(count int) (string, error) {\n\tRandomString, err := Random(count, 0, 0, true, true)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"Error: %s\", err)\n\t}\n\n\treturn RandomString[:count], nil\n\n}\n\n/*\nRandomAlphaNumericCustom creates a random string whose length is the number of characters specified.\nCharacters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n\nParameters:\n\tcount - the length of random string to create\n\tletters - if true, generated string may include alphabetic characters\n\tnumbers - if true, generated string may include numeric characters\n\nReturns:\n\tstring - the random string\n\terror - an error stemming from an invalid parameter within underlying function, RandomSeed(...)\n*/\nfunc RandomAlphaNumericCustom(count int, letters bool, numbers bool) (string, error) {\n\treturn Random(count, 0, 0, letters, numbers)\n}\n\n/*\nRandom creates a random string based on a variety of options, using default source of randomness.\nThis method has exactly the same semantics as RandomSeed(int, int, int, bool, bool, []char, *rand.Rand), but\ninstead of using an externally supplied source of randomness, it uses the internal *rand.Rand instance.\n\nParameters:\n\tcount - the length of random string to create\n\tstart - the position in set of chars (ASCII/Unicode int) to start at\n\tend - the position in set of chars (ASCII/Unicode int) to end before\n\tletters - if true, generated string may include alphabetic characters\n\tnumbers - if true, generated string may include numeric characters\n\tchars - the set of chars to choose randoms from. If nil, then it will use the set of all chars.\n\nReturns:\n\tstring - the random string\n\terror - an error stemming from an invalid parameter within underlying function, RandomSeed(...)\n*/\nfunc Random(count int, start int, end int, letters bool, numbers bool, chars ...rune) (string, error) {\n\treturn RandomSeed(count, start, end, letters, numbers, chars, RANDOM)\n}\n\n/*\nRandomSeed creates a random string based on a variety of options, using supplied source of randomness.\nIf the parameters start and end are both 0, start and end are set to ' ' and 'z', the ASCII printable characters, will be used,\nunless letters and numbers are both false, in which case, start and end are set to 0 and math.MaxInt32, respectively.\nIf chars is not nil, characters stored in chars that are between start and end are chosen.\nThis method accepts a user-supplied *rand.Rand instance to use as a source of randomness. By seeding a single *rand.Rand instance\nwith a fixed seed and using it for each call, the same random sequence of strings can be generated repeatedly and predictably.\n\nParameters:\n\tcount - the length of random string to create\n\tstart - the position in set of chars (ASCII/Unicode decimals) to start at\n\tend - the position in set of chars (ASCII/Unicode decimals) to end before\n\tletters - if true, generated string may include alphabetic characters\n\tnumbers - if true, generated string may include numeric characters\n\tchars - the set of chars to choose randoms from. If nil, then it will use the set of all chars.\n\trandom - a source of randomness.\n\nReturns:\n\tstring - the random string\n\terror - an error stemming from invalid parameters: if count < 0; or the provided chars array is empty; or end <= start; or end > len(chars)\n*/\nfunc RandomSeed(count int, start int, end int, letters bool, numbers bool, chars []rune, random *rand.Rand) (string, error) {\n\n\tif count == 0 {\n\t\treturn \"\", nil\n\t} else if count < 0 {\n\t\terr := fmt.Errorf(\"randomstringutils illegal argument: Requested random string length %v is less than 0.\", count) // equiv to err := errors.New(\"...\")\n\t\treturn \"\", err\n\t}\n\tif chars != nil && len(chars) == 0 {\n\t\terr := fmt.Errorf(\"randomstringutils illegal argument: The chars array must not be empty\")\n\t\treturn \"\", err\n\t}\n\n\tif start == 0 && end == 0 {\n\t\tif chars != nil {\n\t\t\tend = len(chars)\n\t\t} else {\n\t\t\tif !letters && !numbers {\n\t\t\t\tend = math.MaxInt32\n\t\t\t} else {\n\t\t\t\tend = 'z' + 1\n\t\t\t\tstart = ' '\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif end <= start {\n\t\t\terr := fmt.Errorf(\"randomstringutils illegal argument: Parameter end (%v) must be greater than start (%v)\", end, start)\n\t\t\treturn \"\", err\n\t\t}\n\n\t\tif chars != nil && end > len(chars) {\n\t\t\terr := fmt.Errorf(\"randomstringutils illegal argument: Parameter end (%v) cannot be greater than len(chars) (%v)\", end, len(chars))\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\n\tbuffer := make([]rune, count)\n\tgap := end - start\n\n\t// high-surrogates range, (\\uD800-\\uDBFF) = 55296 - 56319\n\t//  low-surrogates range, (\\uDC00-\\uDFFF) = 56320 - 57343\n\n\tfor count != 0 {\n\t\tcount--\n\t\tvar ch rune\n\t\tif chars == nil {\n\t\t\tch = rune(random.Intn(gap) + start)\n\t\t} else {\n\t\t\tch = chars[random.Intn(gap)+start]\n\t\t}\n\n\t\tif letters && unicode.IsLetter(ch) || numbers && unicode.IsDigit(ch) || !letters && !numbers {\n\t\t\tif ch >= 56320 && ch <= 57343 { // low surrogate range\n\t\t\t\tif count == 0 {\n\t\t\t\t\tcount++\n\t\t\t\t} else {\n\t\t\t\t\t// Insert low surrogate\n\t\t\t\t\tbuffer[count] = ch\n\t\t\t\t\tcount--\n\t\t\t\t\t// Insert high surrogate\n\t\t\t\t\tbuffer[count] = rune(55296 + random.Intn(128))\n\t\t\t\t}\n\t\t\t} else if ch >= 55296 && ch <= 56191 { // High surrogates range (Partial)\n\t\t\t\tif count == 0 {\n\t\t\t\t\tcount++\n\t\t\t\t} else {\n\t\t\t\t\t// Insert low surrogate\n\t\t\t\t\tbuffer[count] = rune(56320 + random.Intn(128))\n\t\t\t\t\tcount--\n\t\t\t\t\t// Insert high surrogate\n\t\t\t\t\tbuffer[count] = ch\n\t\t\t\t}\n\t\t\t} else if ch >= 56192 && ch <= 56319 {\n\t\t\t\t// private high surrogate, skip it\n\t\t\t\tcount++\n\t\t\t} else {\n\t\t\t\t// not one of the surrogates*\n\t\t\t\tbuffer[count] = ch\n\t\t\t}\n\t\t} else {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn string(buffer), nil\n}\n", "package goutils\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"testing\"\n)\n\n// ****************************** TESTS ********************************************\n\nfunc TestRandomSeed(t *testing.T) {\n\n\t// count, start, end, letters, numbers := 5, 0, 0, true, true\n\trandom := rand.New(rand.NewSource(10))\n\tout := \"3ip9v\"\n\n\t// Test 1: Simulating RandomAlphaNumeric(count int)\n\tif x, _ := RandomSeed(5, 0, 0, true, true, nil, random); x != out {\n\t\tt.Errorf(\"RandomSeed(%v, %v, %v, %v, %v, %v, %v) = %v, want %v\", 5, 0, 0, true, true, nil, random, x, out)\n\t}\n\n\t// Test 2: Simulating RandomAlphabetic(count int)\n\tout = \"MBrbj\"\n\n\tif x, _ := RandomSeed(5, 0, 0, true, false, nil, random); x != out {\n\t\tt.Errorf(\"RandomSeed(%v, %v, %v, %v, %v, %v, %v) = %v, want %v\", 5, 0, 0, true, false, nil, random, x, out)\n\t}\n\n\t// Test 3: Simulating RandomNumeric(count int)\n\tout = \"88935\"\n\n\tif x, _ := RandomSeed(5, 0, 0, false, true, nil, random); x != out {\n\t\tt.Errorf(\"RandomSeed(%v, %v, %v, %v, %v, %v, %v) = %v, want %v\", 5, 0, 0, false, true, nil, random, x, out)\n\t}\n\n\t// Test 4: Simulating RandomAscii(count int)\n\tout = \"H_I;E\"\n\n\tif x, _ := RandomSeed(5, 32, 127, false, false, nil, random); x != out {\n\t\tt.Errorf(\"RandomSeed(%v, %v, %v, %v, %v, %v, %v) = %v, want %v\", 5, 32, 127, false, false, nil, random, x, out)\n\t}\n\n\t// Test 5: Simulating RandomSeed(...) with custom chars\n\tchars := []rune{'1', '2', '3', 'a', 'b', 'c'}\n\tout = \"2b2ca\"\n\n\tif x, _ := RandomSeed(5, 0, 0, false, false, chars, random); x != out {\n\t\tt.Errorf(\"RandomSeed(%v, %v, %v, %v, %v, %v, %v) = %v, want %v\", 5, 0, 0, false, false, chars, random, x, out)\n\t}\n\n}\n\n// ****************************** EXAMPLES ********************************************\n\nfunc ExampleRandomSeed() {\n\n\tvar seed int64 = 10 // If you change this seed #, the random sequence below will change\n\trandom := rand.New(rand.NewSource(seed))\n\tchars := []rune{'1', '2', '3', 'a', 'b', 'c'}\n\n\trand1, _ := RandomSeed(5, 0, 0, true, true, nil, random)      // RandomAlphaNumeric (Alphabets and numbers possible)\n\trand2, _ := RandomSeed(5, 0, 0, true, false, nil, random)     // RandomAlphabetic (Only alphabets)\n\trand3, _ := RandomSeed(5, 0, 0, false, true, nil, random)     // RandomNumeric (Only numbers)\n\trand4, _ := RandomSeed(5, 32, 127, false, false, nil, random) // RandomAscii (Alphabets, numbers, and other ASCII chars)\n\trand5, _ := RandomSeed(5, 0, 0, true, true, chars, random)    // RandomSeed with custom characters\n\n\tfmt.Println(rand1)\n\tfmt.Println(rand2)\n\tfmt.Println(rand3)\n\tfmt.Println(rand4)\n\tfmt.Println(rand5)\n\t// Output:\n\t// 3ip9v\n\t// MBrbj\n\t// 88935\n\t// H_I;E\n\t// 2b2ca\n}\n\nfunc TestRandAlphaNumeric_FuzzOnlyNumeric(t *testing.T) {\n\n\t// Testing for a reported regression in which some versions produced\n\t// a predictably small set of chars.\n\titers := 1000\n\tcharlen := 0\n\tfor i := 0; i < 16; i++ {\n\t\tnumOnly := 0\n\t\tcharlen++\n\t\tfor i := 0; i < iters; i++ {\n\t\t\tout, err := RandomAlphaNumeric(charlen)\n\t\t\tprintln(out)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(\"func failed to produce a random thinger\")\n\t\t\t}\n\t\t\tif _, err := strconv.Atoi(out); err == nil {\n\t\t\t\tnumOnly++\n\t\t\t}\n\n\t\t\tm, err := regexp.MatchString(\"^[0-9a-zA-Z]+$\", out)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif !m {\n\t\t\t\tt.Fatal(\"Character is not alphanum\")\n\t\t\t}\n\t\t}\n\n\t\tif numOnly == iters {\n\t\t\tt.Fatalf(\"Got %d numeric-only random sequences\", numOnly)\n\t\t}\n\t}\n\n}\n"], "filenames": ["cryptorandomstringutils.go", "cryptorandomstringutils_test.go", "randomstringutils.go", "randomstringutils_test.go"], "buggy_code_start_loc": [24, 3, 23, 5], "buggy_code_end_loc": [208, 76, 122, 78], "fixing_code_start_loc": [23, 4, 22, 6], "fixing_code_end_loc": [191, 114, 108, 116], "type": "CWE-331", "message": "Randomly-generated alphanumeric strings contain significantly less entropy than expected. The RandomAlphaNumeric and CryptoRandomAlphaNumeric functions always return strings containing at least one digit from 0 to 9. This significantly reduces the amount of entropy in short strings generated by these functions.", "other": {"cve": {"id": "CVE-2021-4238", "sourceIdentifier": "security@golang.org", "published": "2022-12-27T22:15:12.073", "lastModified": "2023-01-05T04:43:06.587", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Randomly-generated alphanumeric strings contain significantly less entropy than expected. The RandomAlphaNumeric and CryptoRandomAlphaNumeric functions always return strings containing at least one digit from 0 to 9. This significantly reduces the amount of entropy in short strings generated by these functions."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-331"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:goutils_project:goutils:*:*:*:*:*:go:*:*", "versionEndExcluding": "1.1.1", "matchCriteriaId": "92BD6F91-B4BD-48C8-9897-E8A09CDAFCFF"}]}]}], "references": [{"url": "https://github.com/Masterminds/goutils/commit/869801f20f9f1e7ecdbdb6422049d8241270d5e1", "source": "security@golang.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://pkg.go.dev/vuln/GO-2022-0411", "source": "security@golang.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Masterminds/goutils/commit/869801f20f9f1e7ecdbdb6422049d8241270d5e1"}}