{"buggy_code": ["#include \"first.h\"\n#include \"burl.h\"\n\n#include <string.h>\n\n#include \"buffer.h\"\n#include \"base64.h\"\n\nstatic const char hex_chars_uc[] = \"0123456789ABCDEF\";\n\n/* everything except: ! $ & ' ( ) * + , - . / 0-9 : ; = ? @ A-Z _ a-z ~ */\nstatic const char encoded_chars_http_uri_reqd[] = {\n  /*\n  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n  */\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /*  00 -  0F control chars */\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /*  10 -  1F */\n  1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /*  20 -  2F space \" # % */\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0,  /*  30 -  3F < > */\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /*  40 -  4F */\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,  /*  50 -  5F [ \\ ] ^ */\n  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /*  60 -  6F ` */\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1,  /*  70 -  7F { | } DEL */\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /*  80 -  8F */\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /*  90 -  9F */\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /*  A0 -  AF */\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /*  B0 -  BF */\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /*  C0 -  CF */\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /*  D0 -  DF */\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /*  E0 -  EF */\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /*  F0 -  FF */\n};\n\n\n/* c (char) and n (nibble) MUST be unsigned integer types */\n#define li_cton(c,n) \\\n  (((n) = (c) - '0') <= 9 || (((n) = ((c)&0xdf) - 'A') <= 5 ? ((n) += 10) : 0))\n\n/* b (byte) MUST be unsigned integer type\n * https://en.wikipedia.org/wiki/UTF-8\n * reject overlong encodings of 7-byte ASCII and invalid UTF-8\n * (but does not detect other overlong multi-byte encodings) */\n#define li_utf8_invalid_byte(b) ((b) >= 0xF5 || ((b)|0x1) == 0xC1)\n\n\nstatic int burl_is_unreserved (const int c)\n{\n    return (light_isalnum(c) || c == '-' || c == '.' || c == '_' || c == '~');\n}\n\n\nstatic int burl_normalize_basic_unreserved_fix (buffer *b, buffer *t, int i, int qs)\n{\n    int j = i;\n    const int used = (int)buffer_string_length(b);\n    const unsigned char * const s = (unsigned char *)b->ptr;\n    unsigned char * const p =\n      (unsigned char *)buffer_string_prepare_copy(t,i+(used-i)*3+1);\n    unsigned int n1, n2;\n    memcpy(p, s, (size_t)i);\n    for (; i < used; ++i, ++j) {\n        if (!encoded_chars_http_uri_reqd[s[i]]) {\n            if (s[i] == '?' && -1 == qs) qs = j;\n            p[j] = s[i];\n        }\n        else if (s[i]=='%' && li_cton(s[i+1], n1) && li_cton(s[i+2], n2)) {\n            const unsigned int x = (n1 << 4) | n2;\n            if (burl_is_unreserved(x)) {\n                p[j] = x;\n            }\n            else {\n                p[j]   = '%';\n                p[++j] = hex_chars_uc[n1]; /*(s[i+1] & 0xdf)*/\n                p[++j] = hex_chars_uc[n2]; /*(s[i+2] & 0xdf)*/\n                if (li_utf8_invalid_byte(x)) qs = -2;\n            }\n            i+=2;\n        }\n        else if (s[i] == '#') break; /* ignore fragment */\n        else {\n            p[j]   = '%';\n            p[++j] = hex_chars_uc[(s[i] >> 4) & 0xF];\n            p[++j] = hex_chars_uc[s[i] & 0xF];\n            if (li_utf8_invalid_byte(s[i])) qs = -2;\n        }\n    }\n    buffer_commit(t, (size_t)j);\n    buffer_copy_buffer(b, t);\n    return qs;\n}\n\n\nstatic int burl_normalize_basic_unreserved (buffer *b, buffer *t)\n{\n    const unsigned char * const s = (unsigned char *)b->ptr;\n    const int used = (int)buffer_string_length(b);\n    unsigned int n1, n2, x;\n    int qs = -1;\n\n    for (int i = 0; i < used; ++i) {\n        if (!encoded_chars_http_uri_reqd[s[i]]) {\n            if (s[i] == '?' && -1 == qs) qs = i;\n        }\n        else if (s[i]=='%' && li_cton(s[i+1], n1) && li_cton(s[i+2], n2)\n                 && !burl_is_unreserved((x = (n1 << 4) | n2))) {\n            if (li_utf8_invalid_byte(x)) qs = -2;\n            if (s[i+1] >= 'a') b->ptr[i+1] &= 0xdf; /* uppercase hex */\n            if (s[i+2] >= 'a') b->ptr[i+2] &= 0xdf; /* uppercase hex */\n            i+=2;\n        }\n        else if (s[i] == '#') { /* ignore fragment */\n            buffer_string_set_length(b, (size_t)i);\n            break;\n        }\n        else {\n            qs = burl_normalize_basic_unreserved_fix(b, t, i, qs);\n            break;\n        }\n    }\n\n    return qs;\n}\n\n\nstatic int burl_normalize_basic_required_fix (buffer *b, buffer *t, int i, int qs)\n{\n    int j = i;\n    const int used = (int)buffer_string_length(b);\n    const unsigned char * const s = (unsigned char *)b->ptr;\n    unsigned char * const p =\n      (unsigned char *)buffer_string_prepare_copy(t,i+(used-i)*3+1);\n    unsigned int n1, n2;\n    memcpy(p, s, (size_t)i);\n    for (; i < used; ++i, ++j) {\n        if (!encoded_chars_http_uri_reqd[s[i]]) {\n            if (s[i] == '?' && -1 == qs) qs = j;\n            p[j] = s[i];\n        }\n        else if (s[i]=='%' && li_cton(s[i+1], n1) && li_cton(s[i+2], n2)) {\n            const unsigned int x = (n1 << 4) | n2;\n            if (!encoded_chars_http_uri_reqd[x]\n                && (qs < 0 ? (x!='/'&&x!='?') : (x!='&'&&x!='='&&x!=';'))) {\n                p[j] = x;\n            }\n            else {\n                p[j]   = '%';\n                p[++j] = hex_chars_uc[n1]; /*(s[i+1] & 0xdf)*/\n                p[++j] = hex_chars_uc[n2]; /*(s[i+2] & 0xdf)*/\n                if (li_utf8_invalid_byte(x)) qs = -2;\n            }\n            i+=2;\n        }\n        else if (s[i] == '#') break; /* ignore fragment */\n        else {\n            p[j]   = '%';\n            p[++j] = hex_chars_uc[(s[i] >> 4) & 0xF];\n            p[++j] = hex_chars_uc[s[i] & 0xF];\n            if (li_utf8_invalid_byte(s[i])) qs = -2;\n        }\n    }\n    buffer_commit(t, (size_t)j);\n    buffer_copy_buffer(b, t);\n    return qs;\n}\n\n\nstatic int burl_normalize_basic_required (buffer *b, buffer *t)\n{\n    const unsigned char * const s = (unsigned char *)b->ptr;\n    const int used = (int)buffer_string_length(b);\n    unsigned int n1, n2, x;\n    int qs = -1;\n\n    for (int i = 0; i < used; ++i) {\n        if (!encoded_chars_http_uri_reqd[s[i]]) {\n            if (s[i] == '?' && -1 == qs) qs = i;\n        }\n        else if (s[i]=='%' && li_cton(s[i+1], n1) && li_cton(s[i+2], n2)\n                 && (encoded_chars_http_uri_reqd[(x = (n1 << 4) | n2)]\n                     ||(qs < 0 ? (x=='/'||x=='?') : (x=='&'||x=='='||x==';')))){\n            if (li_utf8_invalid_byte(x)) qs = -2;\n            if (s[i+1] >= 'a') b->ptr[i+1] &= 0xdf; /* uppercase hex */\n            if (s[i+2] >= 'a') b->ptr[i+2] &= 0xdf; /* uppercase hex */\n            i+=2;\n        }\n        else if (s[i] == '#') { /* ignore fragment */\n            buffer_string_set_length(b, (size_t)i);\n            break;\n        }\n        else {\n            qs = burl_normalize_basic_required_fix(b, t, i, qs);\n            break;\n        }\n    }\n\n    return qs;\n}\n\n\nstatic int burl_contains_ctrls (const buffer *b)\n{\n    const char * const s = b->ptr;\n    const int used = (int)buffer_string_length(b);\n    for (int i = 0; i < used; ++i) {\n        if (s[i] == '%' && (s[i+1] < '2' || (s[i+1] == '7' && s[i+2] == 'F')))\n            return 1;\n    }\n    return 0;\n}\n\n\nstatic void burl_normalize_qs20_to_plus_fix (buffer *b, int i)\n{\n    char * const s = b->ptr;\n    const int used = (int)buffer_string_length(b);\n    int j = i;\n    for (; i < used; ++i, ++j) {\n        s[j] = s[i];\n        if (s[i] == '%' && s[i+1] == '2' && s[i+2] == '0') {\n            s[j] = '+';\n            i+=2;\n        }\n    }\n    buffer_string_set_length(b, j);\n}\n\n\nstatic void burl_normalize_qs20_to_plus (buffer *b, int qs)\n{\n    const char * const s = b->ptr;\n    const int used = qs < 0 ? 0 : (int)buffer_string_length(b);\n    int i;\n    if (qs < 0) return;\n    for (i = qs+1; i < used; ++i) {\n        if (s[i] == '%' && s[i+1] == '2' && s[i+2] == '0') break;\n    }\n    if (i != used) burl_normalize_qs20_to_plus_fix(b, i);\n}\n\n\nstatic int burl_normalize_2F_to_slash_fix (buffer *b, int qs, int i)\n{\n    char * const s = b->ptr;\n    const int blen = (int)buffer_string_length(b);\n    const int used = qs < 0 ? blen : qs;\n    int j = i;\n    for (; i < used; ++i, ++j) {\n        s[j] = s[i];\n        if (s[i] == '%' && s[i+1] == '2' && s[i+2] == 'F') {\n            s[j] = '/';\n            i+=2;\n        }\n    }\n    if (qs >= 0) {\n        memmove(s+j, s+qs, blen - qs);\n        j += blen - qs;\n    }\n    buffer_string_set_length(b, j);\n    return qs;\n}\n\n\nstatic int burl_normalize_2F_to_slash (buffer *b, int qs, int flags)\n{\n    /*(\"%2F\" must already have been uppercased during normalization)*/\n    const char * const s = b->ptr;\n    const int used = qs < 0 ? (int)buffer_string_length(b) : qs;\n    for (int i = 0; i < used; ++i) {\n        if (s[i] == '%' && s[i+1] == '2' && s[i+2] == 'F') {\n            return (flags & HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE)\n              ? burl_normalize_2F_to_slash_fix(b, qs, i)\n              : -2; /*(flags & HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT)*/\n        }\n    }\n    return qs;\n}\n\n\nstatic int burl_normalize_path (buffer *b, buffer *t, int qs, int flags)\n{\n    const unsigned char * const s = (unsigned char *)b->ptr;\n    const int used = (int)buffer_string_length(b);\n    int path_simplify = 0;\n    for (int i = 0, len = qs < 0 ? used : qs; i < len; ++i) {\n        if (s[i] == '.' && (s[i+1] != '.' || ++i)\n            && (s[i+1] == '/' || s[i+1] == '?' || s[i+1] == '\\0')) {\n            path_simplify = 1;\n            break;\n        }\n        do { ++i; } while (i < len && s[i] != '/');\n        if (s[i] == '/' && s[i+1] == '/') { /*(s[len] != '/')*/\n            path_simplify = 1;\n            break;\n        }\n    }\n\n    if (path_simplify) {\n        if (flags & HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT) return -2;\n        if (qs >= 0) {\n            buffer_copy_string_len(t, b->ptr+qs, used - qs);\n            buffer_string_set_length(b, qs);\n        }\n\n        buffer_path_simplify(b, b);\n\n        if (qs >= 0) {\n            qs = (int)buffer_string_length(b);\n            buffer_append_string_len(b, CONST_BUF_LEN(t));\n        }\n    }\n\n    return qs;\n}\n\n\nint burl_normalize (buffer *b, buffer *t, int flags)\n{\n    int qs;\n\n  #if defined(__WIN32) || defined(__CYGWIN__)\n    /* Windows and Cygwin treat '\\\\' as '/' if '\\\\' is present in path;\n     * convert to '/' for consistency before percent-encoding\n     * normalization which will convert '\\\\' to \"%5C\" in the URL.\n     * (Clients still should not be sending '\\\\' unencoded in requests.) */\n    if (flags & HTTP_PARSEOPT_URL_NORMALIZE_PATH_BACKSLASH_TRANS) {\n        for (char *p = b->ptr; *p != '?' && *p != '\\0'; ++p) {\n            if (*p == '\\\\') *p = '/';\n        }\n    }\n  #endif\n\n    qs = (flags & HTTP_PARSEOPT_URL_NORMALIZE_REQUIRED)\n      ? burl_normalize_basic_required(b, t)\n      : burl_normalize_basic_unreserved(b, t);\n    if (-2 == qs) return -2;\n\n    if (flags & HTTP_PARSEOPT_URL_NORMALIZE_CTRLS_REJECT) {\n        if (burl_contains_ctrls(b)) return -2;\n    }\n\n    if (flags & (HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE\n                |HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT)) {\n        qs = burl_normalize_2F_to_slash(b, qs, flags);\n        if (-2 == qs) return -2;\n    }\n\n    if (flags & (HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REMOVE\n                |HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT)) {\n        qs = burl_normalize_path(b, t, qs, flags);\n        if (-2 == qs) return -2;\n    }\n\n    if (flags & HTTP_PARSEOPT_URL_NORMALIZE_QUERY_20_PLUS) {\n        if (qs >= 0) burl_normalize_qs20_to_plus(b, qs);\n    }\n\n    return qs;\n}\n\n\nstatic void burl_append_encode_nde (buffer * const b, const char * const str, const size_t len)\n{\n    /* percent-encodes everything except unreserved  - . 0-9 A-Z _ a-z ~\n     * unless already percent-encoded (does not double-encode) */\n    /* Note: not checking for invalid UTF-8 */\n    char * const p = buffer_string_prepare_append(b, len*3);\n    unsigned int n1, n2;\n    int j = 0;\n    for (unsigned int i = 0; i < len; ++i, ++j) {\n        if (str[i]=='%' && li_cton(str[i+1], n1) && li_cton(str[i+2], n2)) {\n            const unsigned int x = (n1 << 4) | n2;\n            if (burl_is_unreserved((int)x)) {\n                p[j] = (char)x;\n            }\n            else { /* leave UTF-8, control chars, and required chars encoded */\n                p[j]   = '%';\n                p[++j] = str[i+1];\n                p[++j] = str[i+2];\n            }\n            i+=2;\n        }\n        else if (burl_is_unreserved(str[i])) {\n            p[j] = str[i];\n        }\n        else {\n            p[j]   = '%';\n            p[++j] = hex_chars_uc[(str[i] >> 4) & 0xF];\n            p[++j] = hex_chars_uc[str[i] & 0xF];\n        }\n    }\n    buffer_commit(b, j);\n}\n\n\nstatic void burl_append_encode_psnde (buffer * const b, const char * const str, const size_t len)\n{\n    /* percent-encodes everything except unreserved  - . 0-9 A-Z _ a-z ~ plus /\n     * unless already percent-encoded (does not double-encode) */\n    /* Note: not checking for invalid UTF-8 */\n    char * const p = buffer_string_prepare_append(b, len*3);\n    unsigned int n1, n2;\n    int j = 0;\n    for (unsigned int i = 0; i < len; ++i, ++j) {\n        if (str[i]=='%' && li_cton(str[i+1], n1) && li_cton(str[i+2], n2)) {\n            const unsigned int x = (n1 << 4) | n2;\n            if (burl_is_unreserved((int)x)) {\n                p[j] = (char)x;\n            }\n            else { /* leave UTF-8, control chars, and required chars encoded */\n                p[j]   = '%';\n                p[++j] = str[i+1];\n                p[++j] = str[i+2];\n            }\n            i+=2;\n        }\n        else if (burl_is_unreserved(str[i]) || str[i] == '/') {\n            p[j] = str[i];\n        }\n        else {\n            p[j]   = '%';\n            p[++j] = hex_chars_uc[(str[i] >> 4) & 0xF];\n            p[++j] = hex_chars_uc[str[i] & 0xF];\n        }\n    }\n    buffer_commit(b, j);\n}\n\n\nstatic void burl_append_encode_all (buffer * const b, const char * const str, const size_t len)\n{\n    /* percent-encodes everything except unreserved  - . 0-9 A-Z _ a-z ~\n     * Note: double-encodes any existing '%') */\n    /* Note: not checking for invalid UTF-8 */\n    char * const p = buffer_string_prepare_append(b, len*3);\n    int j = 0;\n    for (unsigned int i = 0; i < len; ++i, ++j) {\n        if (burl_is_unreserved(str[i])) {\n            p[j] = str[i];\n        }\n        else {\n            p[j]   = '%';\n            p[++j] = hex_chars_uc[(str[i] >> 4) & 0xF];\n            p[++j] = hex_chars_uc[str[i] & 0xF];\n        }\n    }\n    buffer_commit(b, j);\n}\n\n\nstatic void burl_offset_tolower (buffer * const b, const size_t off)\n{\n    /*(skips over all percent-encodings, including encoding of alpha chars)*/\n    for (char *p = b->ptr+off; p[0]; ++p) {\n        if (p[0] >= 'A' && p[0] <= 'Z') p[0] |= 0x20;\n        else if (p[0]=='%' && light_isxdigit(p[1]) && light_isxdigit(p[2]))\n            p+=2;\n    }\n}\n\n\nstatic void burl_offset_toupper (buffer * const b, const size_t off)\n{\n    /*(skips over all percent-encodings, including encoding of alpha chars)*/\n    for (char *p = b->ptr+off; p[0]; ++p) {\n        if (p[0] >= 'a' && p[0] <= 'z') p[0] &= 0xdf;\n        else if (p[0]=='%' && light_isxdigit(p[1]) && light_isxdigit(p[2]))\n            p+=2;\n    }\n}\n\n\nvoid burl_append (buffer * const b, const char * const str, const size_t len, const int flags)\n{\n    size_t off = 0;\n\n    if (0 == len) return;\n\n    if (0 == flags) {\n        buffer_append_string_len(b, str, len);\n        return;\n    }\n\n    if (flags & (BURL_TOUPPER|BURL_TOLOWER)) off = buffer_string_length(b);\n\n    if (flags & BURL_ENCODE_NONE) {\n        buffer_append_string_len(b, str, len);\n    }\n    else if (flags & BURL_ENCODE_ALL) {\n        burl_append_encode_all(b, str, len);\n    }\n    else if (flags & BURL_ENCODE_NDE) {\n        burl_append_encode_nde(b, str, len);\n    }\n    else if (flags & BURL_ENCODE_PSNDE) {\n        burl_append_encode_psnde(b, str, len);\n    }\n    else if (flags & BURL_ENCODE_B64U) {\n        const unsigned char *s = (const unsigned char *)str;\n        buffer_append_base64_encode_no_padding(b, s, len, BASE64_URL);\n    }\n    else if (flags & BURL_DECODE_B64U) {\n        buffer_append_base64_decode(b, str, len, BASE64_URL);\n    }\n\n    /* note: not normalizing str, which could come from arbitrary header,\n     * so it is possible that alpha chars are percent-encoded upper/lowercase */\n    if (flags & (BURL_TOLOWER|BURL_TOUPPER)) {\n        (flags & BURL_TOLOWER)\n          ? burl_offset_tolower(b, off)  /*(flags & BURL_TOLOWER)*/\n          : burl_offset_toupper(b, off); /*(flags & BURL_TOUPPER)*/\n    }\n}\n", "#include \"first.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"burl.h\"\n\nstatic void run_burl_normalize (buffer *psrc, buffer *ptmp, int flags, int line, const char *in, size_t in_len, const char *out, size_t out_len) {\n    int qs;\n    buffer_copy_string_len(psrc, in, in_len);\n    qs = burl_normalize(psrc, ptmp, flags);\n    if (out_len == (size_t)-2) {\n        if (-2 == qs) return;\n        fprintf(stderr,\n                \"%s.%d: %s('%s') failed: expected error, got '%s'\\n\",\n                __FILE__, line, __func__+4, in, psrc->ptr);\n    }\n    else {\n        if (buffer_is_equal_string(psrc, out, out_len)) return;\n        fprintf(stderr,\n                \"%s.%d: %s('%s') failed: expected '%s', got '%s'\\n\",\n                __FILE__, line, __func__+4, in, out, psrc->ptr);\n    }\n    fflush(stderr);\n    abort();\n}\n\nstatic void test_burl_normalize (void) {\n    buffer *psrc = buffer_init();\n    buffer *ptmp = buffer_init();\n    int flags;\n\n    flags = HTTP_PARSEOPT_URL_NORMALIZE_UNRESERVED;\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"no-slash\"), CONST_STR_LEN(\"no-slash\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\"), CONST_STR_LEN(\"/\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc\"), CONST_STR_LEN(\"/abc\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc/\"), CONST_STR_LEN(\"/abc/\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc/def\"), CONST_STR_LEN(\"/abc/def\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?\"), CONST_STR_LEN(\"/abc?\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d\"), CONST_STR_LEN(\"/abc?d\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=\"), CONST_STR_LEN(\"/abc?d=\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e\"), CONST_STR_LEN(\"/abc?d=e\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e&\"), CONST_STR_LEN(\"/abc?d=e&\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e&f\"), CONST_STR_LEN(\"/abc?d=e&f\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e&f=g\"), CONST_STR_LEN(\"/abc?d=e&f=g\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e&f=g#\"), CONST_STR_LEN(\"/abc?d=e&f=g\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e&f=g#any\"), CONST_STR_LEN(\"/abc?d=e&f=g\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%2F\"), CONST_STR_LEN(\"/%2F\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%2f\"), CONST_STR_LEN(\"/%2F\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%20\"), CONST_STR_LEN(\"/%20\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%2b\"), CONST_STR_LEN(\"/%2B\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%2B\"), CONST_STR_LEN(\"/%2B\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%3a\"), CONST_STR_LEN(\"/%3A\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%3A\"), CONST_STR_LEN(\"/%3A\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/~test%20\u00e4_\"), CONST_STR_LEN(\"/~test%20%C3%A4_\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\\375\"), \"\", (size_t)-2);\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\\376\"), \"\", (size_t)-2);\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\\377\"), \"\", (size_t)-2);\n\n    flags = HTTP_PARSEOPT_URL_NORMALIZE_REQUIRED;\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\"), CONST_STR_LEN(\"/\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc\"), CONST_STR_LEN(\"/abc\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc/\"), CONST_STR_LEN(\"/abc/\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc/def\"), CONST_STR_LEN(\"/abc/def\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?\"), CONST_STR_LEN(\"/abc?\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d\"), CONST_STR_LEN(\"/abc?d\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=\"), CONST_STR_LEN(\"/abc?d=\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e\"), CONST_STR_LEN(\"/abc?d=e\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e&\"), CONST_STR_LEN(\"/abc?d=e&\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e&f\"), CONST_STR_LEN(\"/abc?d=e&f\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e&f=g\"), CONST_STR_LEN(\"/abc?d=e&f=g\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e&f=g#\"), CONST_STR_LEN(\"/abc?d=e&f=g\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e&f=g#any\"), CONST_STR_LEN(\"/abc?d=e&f=g\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%2F\"), CONST_STR_LEN(\"/%2F\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%2f\"), CONST_STR_LEN(\"/%2F\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%20\"), CONST_STR_LEN(\"/%20\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%2b\"), CONST_STR_LEN(\"/+\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%2B\"), CONST_STR_LEN(\"/+\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%3a\"), CONST_STR_LEN(\"/:\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%3A\"), CONST_STR_LEN(\"/:\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/~test%20\u00e4_\"), CONST_STR_LEN(\"/~test%20%C3%A4_\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\\375\"), \"\", (size_t)-2);\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\\376\"), \"\", (size_t)-2);\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\\377\"), \"\", (size_t)-2);\n\n    flags |= HTTP_PARSEOPT_URL_NORMALIZE_CTRLS_REJECT;\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\\a\"), \"\", (size_t)-2);\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\\t\"), \"\", (size_t)-2);\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\\r\"), \"\", (size_t)-2);\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\\177\"), \"\", (size_t)-2);\n\n  #if defined(__WIN32) || defined(__CYGWIN__)\n    flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_BACKSLASH_TRANS;\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a\\\\b\"), CONST_STR_LEN(\"/a/b\"));\n  #endif\n\n    flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE;\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/b?c=/\"), CONST_STR_LEN(\"/a/b?c=/\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/b?c=%2f\"), CONST_STR_LEN(\"/a/b?c=/\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a%2fb\"), CONST_STR_LEN(\"/a/b\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a%2Fb\"), CONST_STR_LEN(\"/a/b\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a%2fb?c=/\"), CONST_STR_LEN(\"/a/b?c=/\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a%2fb?c=%2f\"), CONST_STR_LEN(\"/a/b?c=/\"));\n    flags &= ~HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE;\n\n    flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT;\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a%2fb\"), \"\", (size_t)-2);\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a%2Fb\"), \"\", (size_t)-2);\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/b?c=%2f\"), CONST_STR_LEN(\"/a/b?c=/\"));\n    flags &= ~HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT;\n\n    flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REMOVE;\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"./a/b\"), CONST_STR_LEN(\"/a/b\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"../a/b\"), CONST_STR_LEN(\"/a/b\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/./b\"), CONST_STR_LEN(\"/a/b\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/../b\"), CONST_STR_LEN(\"/b\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/b/.\"), CONST_STR_LEN(\"/a/b/\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/b/..\"), CONST_STR_LEN(\"/a/\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/../b/..\"), CONST_STR_LEN(\"/\"));\n    flags &= ~HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REMOVE;\n\n    flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT;\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"./a/b\"), \"\", (size_t)-2);\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"../a/b\"), \"\", (size_t)-2);\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/./b\"), \"\", (size_t)-2);\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/../b\"), \"\", (size_t)-2);\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/b/.\"), \"\", (size_t)-2);\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/b/..\"), \"\", (size_t)-2);\n    flags &= ~HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT;\n\n    flags |= HTTP_PARSEOPT_URL_NORMALIZE_QUERY_20_PLUS;\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/b?c=d+e\"), CONST_STR_LEN(\"/a/b?c=d+e\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/b?c=d%20e\"), CONST_STR_LEN(\"/a/b?c=d+e\"));\n    flags &= ~HTTP_PARSEOPT_URL_NORMALIZE_QUERY_20_PLUS;\n\n    buffer_free(psrc);\n    buffer_free(ptmp);\n}\n\nint main (void) {\n    test_burl_normalize();\n    return 0;\n}\n"], "fixing_code": ["#include \"first.h\"\n#include \"burl.h\"\n\n#include <string.h>\n\n#include \"buffer.h\"\n#include \"base64.h\"\n\nstatic const char hex_chars_uc[] = \"0123456789ABCDEF\";\n\n/* everything except: ! $ & ' ( ) * + , - . / 0-9 : ; = ? @ A-Z _ a-z ~ */\nstatic const char encoded_chars_http_uri_reqd[] = {\n  /*\n  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n  */\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /*  00 -  0F control chars */\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /*  10 -  1F */\n  1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /*  20 -  2F space \" # % */\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0,  /*  30 -  3F < > */\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /*  40 -  4F */\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,  /*  50 -  5F [ \\ ] ^ */\n  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /*  60 -  6F ` */\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1,  /*  70 -  7F { | } DEL */\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /*  80 -  8F */\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /*  90 -  9F */\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /*  A0 -  AF */\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /*  B0 -  BF */\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /*  C0 -  CF */\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /*  D0 -  DF */\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /*  E0 -  EF */\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /*  F0 -  FF */\n};\n\n\n/* c (char) and n (nibble) MUST be unsigned integer types */\n#define li_cton(c,n) \\\n  (((n) = (c) - '0') <= 9 || (((n) = ((c)&0xdf) - 'A') <= 5 ? ((n) += 10) : 0))\n\n/* b (byte) MUST be unsigned integer type\n * https://en.wikipedia.org/wiki/UTF-8\n * reject overlong encodings of 7-byte ASCII and invalid UTF-8\n * (but does not detect other overlong multi-byte encodings) */\n#define li_utf8_invalid_byte(b) ((b) >= 0xF5 || ((b)|0x1) == 0xC1)\n\n\nstatic int burl_is_unreserved (const int c)\n{\n    return (light_isalnum(c) || c == '-' || c == '.' || c == '_' || c == '~');\n}\n\n\nstatic int burl_normalize_basic_unreserved_fix (buffer *b, buffer *t, int i, int qs)\n{\n    int j = i;\n    const int used = (int)buffer_string_length(b);\n    const unsigned char * const s = (unsigned char *)b->ptr;\n    unsigned char * const p =\n      (unsigned char *)buffer_string_prepare_copy(t,i+(used-i)*3+1);\n    unsigned int n1, n2;\n    memcpy(p, s, (size_t)i);\n    for (; i < used; ++i, ++j) {\n        if (!encoded_chars_http_uri_reqd[s[i]]) {\n            if (s[i] == '?' && -1 == qs) qs = j;\n            p[j] = s[i];\n        }\n        else if (s[i]=='%' && li_cton(s[i+1], n1) && li_cton(s[i+2], n2)) {\n            const unsigned int x = (n1 << 4) | n2;\n            if (burl_is_unreserved(x)) {\n                p[j] = x;\n            }\n            else {\n                p[j]   = '%';\n                p[++j] = hex_chars_uc[n1]; /*(s[i+1] & 0xdf)*/\n                p[++j] = hex_chars_uc[n2]; /*(s[i+2] & 0xdf)*/\n                if (li_utf8_invalid_byte(x)) qs = -2;\n            }\n            i+=2;\n        }\n        else if (s[i] == '#') break; /* ignore fragment */\n        else {\n            p[j]   = '%';\n            p[++j] = hex_chars_uc[(s[i] >> 4) & 0xF];\n            p[++j] = hex_chars_uc[s[i] & 0xF];\n            if (li_utf8_invalid_byte(s[i])) qs = -2;\n        }\n    }\n    buffer_commit(t, (size_t)j);\n    buffer_copy_buffer(b, t);\n    return qs;\n}\n\n\nstatic int burl_normalize_basic_unreserved (buffer *b, buffer *t)\n{\n    const unsigned char * const s = (unsigned char *)b->ptr;\n    const int used = (int)buffer_string_length(b);\n    unsigned int n1, n2, x;\n    int qs = -1;\n\n    for (int i = 0; i < used; ++i) {\n        if (!encoded_chars_http_uri_reqd[s[i]]) {\n            if (s[i] == '?' && -1 == qs) qs = i;\n        }\n        else if (s[i]=='%' && li_cton(s[i+1], n1) && li_cton(s[i+2], n2)\n                 && !burl_is_unreserved((x = (n1 << 4) | n2))) {\n            if (li_utf8_invalid_byte(x)) qs = -2;\n            if (s[i+1] >= 'a') b->ptr[i+1] &= 0xdf; /* uppercase hex */\n            if (s[i+2] >= 'a') b->ptr[i+2] &= 0xdf; /* uppercase hex */\n            i+=2;\n        }\n        else if (s[i] == '#') { /* ignore fragment */\n            buffer_string_set_length(b, (size_t)i);\n            break;\n        }\n        else {\n            qs = burl_normalize_basic_unreserved_fix(b, t, i, qs);\n            break;\n        }\n    }\n\n    return qs;\n}\n\n\nstatic int burl_normalize_basic_required_fix (buffer *b, buffer *t, int i, int qs)\n{\n    int j = i;\n    const int used = (int)buffer_string_length(b);\n    const unsigned char * const s = (unsigned char *)b->ptr;\n    unsigned char * const p =\n      (unsigned char *)buffer_string_prepare_copy(t,i+(used-i)*3+1);\n    unsigned int n1, n2;\n    memcpy(p, s, (size_t)i);\n    for (; i < used; ++i, ++j) {\n        if (!encoded_chars_http_uri_reqd[s[i]]) {\n            if (s[i] == '?' && -1 == qs) qs = j;\n            p[j] = s[i];\n        }\n        else if (s[i]=='%' && li_cton(s[i+1], n1) && li_cton(s[i+2], n2)) {\n            const unsigned int x = (n1 << 4) | n2;\n            if (!encoded_chars_http_uri_reqd[x]\n                && (qs < 0 ? (x!='/'&&x!='?') : (x!='&'&&x!='='&&x!=';'))) {\n                p[j] = x;\n            }\n            else {\n                p[j]   = '%';\n                p[++j] = hex_chars_uc[n1]; /*(s[i+1] & 0xdf)*/\n                p[++j] = hex_chars_uc[n2]; /*(s[i+2] & 0xdf)*/\n                if (li_utf8_invalid_byte(x)) qs = -2;\n            }\n            i+=2;\n        }\n        else if (s[i] == '#') break; /* ignore fragment */\n        else {\n            p[j]   = '%';\n            p[++j] = hex_chars_uc[(s[i] >> 4) & 0xF];\n            p[++j] = hex_chars_uc[s[i] & 0xF];\n            if (li_utf8_invalid_byte(s[i])) qs = -2;\n        }\n    }\n    buffer_commit(t, (size_t)j);\n    buffer_copy_buffer(b, t);\n    return qs;\n}\n\n\nstatic int burl_normalize_basic_required (buffer *b, buffer *t)\n{\n    const unsigned char * const s = (unsigned char *)b->ptr;\n    const int used = (int)buffer_string_length(b);\n    unsigned int n1, n2, x;\n    int qs = -1;\n\n    for (int i = 0; i < used; ++i) {\n        if (!encoded_chars_http_uri_reqd[s[i]]) {\n            if (s[i] == '?' && -1 == qs) qs = i;\n        }\n        else if (s[i]=='%' && li_cton(s[i+1], n1) && li_cton(s[i+2], n2)\n                 && (encoded_chars_http_uri_reqd[(x = (n1 << 4) | n2)]\n                     ||(qs < 0 ? (x=='/'||x=='?') : (x=='&'||x=='='||x==';')))){\n            if (li_utf8_invalid_byte(x)) qs = -2;\n            if (s[i+1] >= 'a') b->ptr[i+1] &= 0xdf; /* uppercase hex */\n            if (s[i+2] >= 'a') b->ptr[i+2] &= 0xdf; /* uppercase hex */\n            i+=2;\n        }\n        else if (s[i] == '#') { /* ignore fragment */\n            buffer_string_set_length(b, (size_t)i);\n            break;\n        }\n        else {\n            qs = burl_normalize_basic_required_fix(b, t, i, qs);\n            break;\n        }\n    }\n\n    return qs;\n}\n\n\nstatic int burl_contains_ctrls (const buffer *b)\n{\n    const char * const s = b->ptr;\n    const int used = (int)buffer_string_length(b);\n    for (int i = 0; i < used; ++i) {\n        if (s[i] == '%' && (s[i+1] < '2' || (s[i+1] == '7' && s[i+2] == 'F')))\n            return 1;\n    }\n    return 0;\n}\n\n\nstatic void burl_normalize_qs20_to_plus_fix (buffer *b, int i)\n{\n    char * const s = b->ptr;\n    const int used = (int)buffer_string_length(b);\n    int j = i;\n    for (; i < used; ++i, ++j) {\n        s[j] = s[i];\n        if (s[i] == '%' && s[i+1] == '2' && s[i+2] == '0') {\n            s[j] = '+';\n            i+=2;\n        }\n    }\n    buffer_string_set_length(b, j);\n}\n\n\nstatic void burl_normalize_qs20_to_plus (buffer *b, int qs)\n{\n    const char * const s = b->ptr;\n    const int used = qs < 0 ? 0 : (int)buffer_string_length(b);\n    int i;\n    if (qs < 0) return;\n    for (i = qs+1; i < used; ++i) {\n        if (s[i] == '%' && s[i+1] == '2' && s[i+2] == '0') break;\n    }\n    if (i != used) burl_normalize_qs20_to_plus_fix(b, i);\n}\n\n\nstatic int burl_normalize_2F_to_slash_fix (buffer *b, int qs, int i)\n{\n    char * const s = b->ptr;\n    const int blen = (int)buffer_string_length(b);\n    const int used = qs < 0 ? blen : qs;\n    int j = i;\n    for (; i < used; ++i, ++j) {\n        s[j] = s[i];\n        if (s[i] == '%' && s[i+1] == '2' && s[i+2] == 'F') {\n            s[j] = '/';\n            i+=2;\n        }\n    }\n    if (qs >= 0) {\n        const int qslen = blen - qs;\n        memmove(s+j, s+qs, (size_t)qslen);\n        qs = j;\n        j += qslen;\n    }\n    buffer_string_set_length(b, j);\n    return qs;\n}\n\n\nstatic int burl_normalize_2F_to_slash (buffer *b, int qs, int flags)\n{\n    /*(\"%2F\" must already have been uppercased during normalization)*/\n    const char * const s = b->ptr;\n    const int used = qs < 0 ? (int)buffer_string_length(b) : qs;\n    for (int i = 0; i < used; ++i) {\n        if (s[i] == '%' && s[i+1] == '2' && s[i+2] == 'F') {\n            return (flags & HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE)\n              ? burl_normalize_2F_to_slash_fix(b, qs, i)\n              : -2; /*(flags & HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT)*/\n        }\n    }\n    return qs;\n}\n\n\nstatic int burl_normalize_path (buffer *b, buffer *t, int qs, int flags)\n{\n    const unsigned char * const s = (unsigned char *)b->ptr;\n    const int used = (int)buffer_string_length(b);\n    int path_simplify = 0;\n    for (int i = 0, len = qs < 0 ? used : qs; i < len; ++i) {\n        if (s[i] == '.' && (s[i+1] != '.' || ++i)\n            && (s[i+1] == '/' || s[i+1] == '?' || s[i+1] == '\\0')) {\n            path_simplify = 1;\n            break;\n        }\n        do { ++i; } while (i < len && s[i] != '/');\n        if (s[i] == '/' && s[i+1] == '/') { /*(s[len] != '/')*/\n            path_simplify = 1;\n            break;\n        }\n    }\n\n    if (path_simplify) {\n        if (flags & HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT) return -2;\n        if (qs >= 0) {\n            buffer_copy_string_len(t, b->ptr+qs, used - qs);\n            buffer_string_set_length(b, qs);\n        }\n\n        buffer_path_simplify(b, b);\n\n        if (qs >= 0) {\n            qs = (int)buffer_string_length(b);\n            buffer_append_string_len(b, CONST_BUF_LEN(t));\n        }\n    }\n\n    return qs;\n}\n\n\nint burl_normalize (buffer *b, buffer *t, int flags)\n{\n    int qs;\n\n  #if defined(__WIN32) || defined(__CYGWIN__)\n    /* Windows and Cygwin treat '\\\\' as '/' if '\\\\' is present in path;\n     * convert to '/' for consistency before percent-encoding\n     * normalization which will convert '\\\\' to \"%5C\" in the URL.\n     * (Clients still should not be sending '\\\\' unencoded in requests.) */\n    if (flags & HTTP_PARSEOPT_URL_NORMALIZE_PATH_BACKSLASH_TRANS) {\n        for (char *p = b->ptr; *p != '?' && *p != '\\0'; ++p) {\n            if (*p == '\\\\') *p = '/';\n        }\n    }\n  #endif\n\n    qs = (flags & HTTP_PARSEOPT_URL_NORMALIZE_REQUIRED)\n      ? burl_normalize_basic_required(b, t)\n      : burl_normalize_basic_unreserved(b, t);\n    if (-2 == qs) return -2;\n\n    if (flags & HTTP_PARSEOPT_URL_NORMALIZE_CTRLS_REJECT) {\n        if (burl_contains_ctrls(b)) return -2;\n    }\n\n    if (flags & (HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE\n                |HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT)) {\n        qs = burl_normalize_2F_to_slash(b, qs, flags);\n        if (-2 == qs) return -2;\n    }\n\n    if (flags & (HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REMOVE\n                |HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT)) {\n        qs = burl_normalize_path(b, t, qs, flags);\n        if (-2 == qs) return -2;\n    }\n\n    if (flags & HTTP_PARSEOPT_URL_NORMALIZE_QUERY_20_PLUS) {\n        if (qs >= 0) burl_normalize_qs20_to_plus(b, qs);\n    }\n\n    return qs;\n}\n\n\nstatic void burl_append_encode_nde (buffer * const b, const char * const str, const size_t len)\n{\n    /* percent-encodes everything except unreserved  - . 0-9 A-Z _ a-z ~\n     * unless already percent-encoded (does not double-encode) */\n    /* Note: not checking for invalid UTF-8 */\n    char * const p = buffer_string_prepare_append(b, len*3);\n    unsigned int n1, n2;\n    int j = 0;\n    for (unsigned int i = 0; i < len; ++i, ++j) {\n        if (str[i]=='%' && li_cton(str[i+1], n1) && li_cton(str[i+2], n2)) {\n            const unsigned int x = (n1 << 4) | n2;\n            if (burl_is_unreserved((int)x)) {\n                p[j] = (char)x;\n            }\n            else { /* leave UTF-8, control chars, and required chars encoded */\n                p[j]   = '%';\n                p[++j] = str[i+1];\n                p[++j] = str[i+2];\n            }\n            i+=2;\n        }\n        else if (burl_is_unreserved(str[i])) {\n            p[j] = str[i];\n        }\n        else {\n            p[j]   = '%';\n            p[++j] = hex_chars_uc[(str[i] >> 4) & 0xF];\n            p[++j] = hex_chars_uc[str[i] & 0xF];\n        }\n    }\n    buffer_commit(b, j);\n}\n\n\nstatic void burl_append_encode_psnde (buffer * const b, const char * const str, const size_t len)\n{\n    /* percent-encodes everything except unreserved  - . 0-9 A-Z _ a-z ~ plus /\n     * unless already percent-encoded (does not double-encode) */\n    /* Note: not checking for invalid UTF-8 */\n    char * const p = buffer_string_prepare_append(b, len*3);\n    unsigned int n1, n2;\n    int j = 0;\n    for (unsigned int i = 0; i < len; ++i, ++j) {\n        if (str[i]=='%' && li_cton(str[i+1], n1) && li_cton(str[i+2], n2)) {\n            const unsigned int x = (n1 << 4) | n2;\n            if (burl_is_unreserved((int)x)) {\n                p[j] = (char)x;\n            }\n            else { /* leave UTF-8, control chars, and required chars encoded */\n                p[j]   = '%';\n                p[++j] = str[i+1];\n                p[++j] = str[i+2];\n            }\n            i+=2;\n        }\n        else if (burl_is_unreserved(str[i]) || str[i] == '/') {\n            p[j] = str[i];\n        }\n        else {\n            p[j]   = '%';\n            p[++j] = hex_chars_uc[(str[i] >> 4) & 0xF];\n            p[++j] = hex_chars_uc[str[i] & 0xF];\n        }\n    }\n    buffer_commit(b, j);\n}\n\n\nstatic void burl_append_encode_all (buffer * const b, const char * const str, const size_t len)\n{\n    /* percent-encodes everything except unreserved  - . 0-9 A-Z _ a-z ~\n     * Note: double-encodes any existing '%') */\n    /* Note: not checking for invalid UTF-8 */\n    char * const p = buffer_string_prepare_append(b, len*3);\n    int j = 0;\n    for (unsigned int i = 0; i < len; ++i, ++j) {\n        if (burl_is_unreserved(str[i])) {\n            p[j] = str[i];\n        }\n        else {\n            p[j]   = '%';\n            p[++j] = hex_chars_uc[(str[i] >> 4) & 0xF];\n            p[++j] = hex_chars_uc[str[i] & 0xF];\n        }\n    }\n    buffer_commit(b, j);\n}\n\n\nstatic void burl_offset_tolower (buffer * const b, const size_t off)\n{\n    /*(skips over all percent-encodings, including encoding of alpha chars)*/\n    for (char *p = b->ptr+off; p[0]; ++p) {\n        if (p[0] >= 'A' && p[0] <= 'Z') p[0] |= 0x20;\n        else if (p[0]=='%' && light_isxdigit(p[1]) && light_isxdigit(p[2]))\n            p+=2;\n    }\n}\n\n\nstatic void burl_offset_toupper (buffer * const b, const size_t off)\n{\n    /*(skips over all percent-encodings, including encoding of alpha chars)*/\n    for (char *p = b->ptr+off; p[0]; ++p) {\n        if (p[0] >= 'a' && p[0] <= 'z') p[0] &= 0xdf;\n        else if (p[0]=='%' && light_isxdigit(p[1]) && light_isxdigit(p[2]))\n            p+=2;\n    }\n}\n\n\nvoid burl_append (buffer * const b, const char * const str, const size_t len, const int flags)\n{\n    size_t off = 0;\n\n    if (0 == len) return;\n\n    if (0 == flags) {\n        buffer_append_string_len(b, str, len);\n        return;\n    }\n\n    if (flags & (BURL_TOUPPER|BURL_TOLOWER)) off = buffer_string_length(b);\n\n    if (flags & BURL_ENCODE_NONE) {\n        buffer_append_string_len(b, str, len);\n    }\n    else if (flags & BURL_ENCODE_ALL) {\n        burl_append_encode_all(b, str, len);\n    }\n    else if (flags & BURL_ENCODE_NDE) {\n        burl_append_encode_nde(b, str, len);\n    }\n    else if (flags & BURL_ENCODE_PSNDE) {\n        burl_append_encode_psnde(b, str, len);\n    }\n    else if (flags & BURL_ENCODE_B64U) {\n        const unsigned char *s = (const unsigned char *)str;\n        buffer_append_base64_encode_no_padding(b, s, len, BASE64_URL);\n    }\n    else if (flags & BURL_DECODE_B64U) {\n        buffer_append_base64_decode(b, str, len, BASE64_URL);\n    }\n\n    /* note: not normalizing str, which could come from arbitrary header,\n     * so it is possible that alpha chars are percent-encoded upper/lowercase */\n    if (flags & (BURL_TOLOWER|BURL_TOUPPER)) {\n        (flags & BURL_TOLOWER)\n          ? burl_offset_tolower(b, off)  /*(flags & BURL_TOLOWER)*/\n          : burl_offset_toupper(b, off); /*(flags & BURL_TOUPPER)*/\n    }\n}\n", "#include \"first.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"burl.h\"\n\nstatic void run_burl_normalize (buffer *psrc, buffer *ptmp, int flags, int line, const char *in, size_t in_len, const char *out, size_t out_len) {\n    int qs;\n    buffer_copy_string_len(psrc, in, in_len);\n    qs = burl_normalize(psrc, ptmp, flags);\n    if (out_len == (size_t)-2) {\n        if (-2 == qs) return;\n        fprintf(stderr,\n                \"%s.%d: %s('%s') failed: expected error, got '%s'\\n\",\n                __FILE__, line, __func__+4, in, psrc->ptr);\n    }\n    else {\n        if (buffer_is_equal_string(psrc, out, out_len)) return;\n        fprintf(stderr,\n                \"%s.%d: %s('%s') failed: expected '%s', got '%s'\\n\",\n                __FILE__, line, __func__+4, in, out, psrc->ptr);\n    }\n    fflush(stderr);\n    abort();\n}\n\nstatic void test_burl_normalize (void) {\n    buffer *psrc = buffer_init();\n    buffer *ptmp = buffer_init();\n    int flags;\n\n    flags = HTTP_PARSEOPT_URL_NORMALIZE_UNRESERVED;\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"no-slash\"), CONST_STR_LEN(\"no-slash\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\"), CONST_STR_LEN(\"/\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc\"), CONST_STR_LEN(\"/abc\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc/\"), CONST_STR_LEN(\"/abc/\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc/def\"), CONST_STR_LEN(\"/abc/def\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?\"), CONST_STR_LEN(\"/abc?\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d\"), CONST_STR_LEN(\"/abc?d\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=\"), CONST_STR_LEN(\"/abc?d=\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e\"), CONST_STR_LEN(\"/abc?d=e\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e&\"), CONST_STR_LEN(\"/abc?d=e&\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e&f\"), CONST_STR_LEN(\"/abc?d=e&f\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e&f=g\"), CONST_STR_LEN(\"/abc?d=e&f=g\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e&f=g#\"), CONST_STR_LEN(\"/abc?d=e&f=g\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e&f=g#any\"), CONST_STR_LEN(\"/abc?d=e&f=g\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%2F\"), CONST_STR_LEN(\"/%2F\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%2f\"), CONST_STR_LEN(\"/%2F\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%20\"), CONST_STR_LEN(\"/%20\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%2b\"), CONST_STR_LEN(\"/%2B\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%2B\"), CONST_STR_LEN(\"/%2B\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%3a\"), CONST_STR_LEN(\"/%3A\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%3A\"), CONST_STR_LEN(\"/%3A\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/~test%20\u00e4_\"), CONST_STR_LEN(\"/~test%20%C3%A4_\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\\375\"), \"\", (size_t)-2);\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\\376\"), \"\", (size_t)-2);\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\\377\"), \"\", (size_t)-2);\n\n    flags = HTTP_PARSEOPT_URL_NORMALIZE_REQUIRED;\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\"), CONST_STR_LEN(\"/\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc\"), CONST_STR_LEN(\"/abc\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc/\"), CONST_STR_LEN(\"/abc/\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc/def\"), CONST_STR_LEN(\"/abc/def\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?\"), CONST_STR_LEN(\"/abc?\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d\"), CONST_STR_LEN(\"/abc?d\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=\"), CONST_STR_LEN(\"/abc?d=\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e\"), CONST_STR_LEN(\"/abc?d=e\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e&\"), CONST_STR_LEN(\"/abc?d=e&\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e&f\"), CONST_STR_LEN(\"/abc?d=e&f\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e&f=g\"), CONST_STR_LEN(\"/abc?d=e&f=g\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e&f=g#\"), CONST_STR_LEN(\"/abc?d=e&f=g\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/abc?d=e&f=g#any\"), CONST_STR_LEN(\"/abc?d=e&f=g\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%2F\"), CONST_STR_LEN(\"/%2F\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%2f\"), CONST_STR_LEN(\"/%2F\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%20\"), CONST_STR_LEN(\"/%20\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%2b\"), CONST_STR_LEN(\"/+\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%2B\"), CONST_STR_LEN(\"/+\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%3a\"), CONST_STR_LEN(\"/:\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%3A\"), CONST_STR_LEN(\"/:\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/~test%20\u00e4_\"), CONST_STR_LEN(\"/~test%20%C3%A4_\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\\375\"), \"\", (size_t)-2);\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\\376\"), \"\", (size_t)-2);\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\\377\"), \"\", (size_t)-2);\n\n    flags |= HTTP_PARSEOPT_URL_NORMALIZE_CTRLS_REJECT;\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\\a\"), \"\", (size_t)-2);\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\\t\"), \"\", (size_t)-2);\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\\r\"), \"\", (size_t)-2);\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/\\177\"), \"\", (size_t)-2);\n\n  #if defined(__WIN32) || defined(__CYGWIN__)\n    flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_BACKSLASH_TRANS;\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a\\\\b\"), CONST_STR_LEN(\"/a/b\"));\n  #endif\n\n    flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE;\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/b?c=/\"), CONST_STR_LEN(\"/a/b?c=/\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/b?c=%2f\"), CONST_STR_LEN(\"/a/b?c=/\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"%2f?\"), CONST_STR_LEN(\"/?\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/%2f?\"), CONST_STR_LEN(\"//?\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a%2fb\"), CONST_STR_LEN(\"/a/b\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a%2Fb\"), CONST_STR_LEN(\"/a/b\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a%2fb?c=/\"), CONST_STR_LEN(\"/a/b?c=/\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a%2fb?c=%2f\"), CONST_STR_LEN(\"/a/b?c=/\"));\n    flags &= ~HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE;\n\n    flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT;\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a%2fb\"), \"\", (size_t)-2);\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a%2Fb\"), \"\", (size_t)-2);\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/b?c=%2f\"), CONST_STR_LEN(\"/a/b?c=/\"));\n    flags &= ~HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT;\n\n    flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REMOVE;\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"./a/b\"), CONST_STR_LEN(\"/a/b\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"../a/b\"), CONST_STR_LEN(\"/a/b\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/./b\"), CONST_STR_LEN(\"/a/b\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/../b\"), CONST_STR_LEN(\"/b\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/b/.\"), CONST_STR_LEN(\"/a/b/\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/b/..\"), CONST_STR_LEN(\"/a/\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/../b/..\"), CONST_STR_LEN(\"/\"));\n    flags &= ~HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REMOVE;\n\n    flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT;\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"./a/b\"), \"\", (size_t)-2);\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"../a/b\"), \"\", (size_t)-2);\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/./b\"), \"\", (size_t)-2);\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/../b\"), \"\", (size_t)-2);\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/b/.\"), \"\", (size_t)-2);\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/b/..\"), \"\", (size_t)-2);\n    flags &= ~HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT;\n\n    flags |= HTTP_PARSEOPT_URL_NORMALIZE_QUERY_20_PLUS;\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/b?c=d+e\"), CONST_STR_LEN(\"/a/b?c=d+e\"));\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, CONST_STR_LEN(\"/a/b?c=d%20e\"), CONST_STR_LEN(\"/a/b?c=d+e\"));\n    flags &= ~HTTP_PARSEOPT_URL_NORMALIZE_QUERY_20_PLUS;\n\n    buffer_free(psrc);\n    buffer_free(ptmp);\n}\n\nint main (void) {\n    test_burl_normalize();\n    return 0;\n}\n"], "filenames": ["src/burl.c", "src/t/test_burl.c"], "buggy_code_start_loc": [255, 99], "buggy_code_end_loc": [257, 99], "fixing_code_start_loc": [255, 100], "fixing_code_end_loc": [259, 102], "type": "CWE-190", "message": "** DISPUTED ** lighttpd before 1.4.54 has a signed integer overflow, which might allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a malicious HTTP GET request, as demonstrated by mishandling of /%2F? in burl_normalize_2F_to_slash_fix in burl.c. NOTE: The developer states \"The feature which can be abused to cause the crash is a new feature in lighttpd 1.4.50, and is not enabled by default. It must be explicitly configured in the config file (e.g. lighttpd.conf). Certain input will trigger an abort() in lighttpd when that feature is enabled. lighttpd detects the underflow or realloc() will fail (in both 32-bit and 64-bit executables), also detected in lighttpd. Either triggers an explicit abort() by lighttpd. This is not exploitable beyond triggering the explicit abort() with subsequent application exit.\"", "other": {"cve": {"id": "CVE-2019-11072", "sourceIdentifier": "cve@mitre.org", "published": "2019-04-10T22:29:00.267", "lastModified": "2019-04-23T20:32:43.177", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "** DISPUTED ** lighttpd before 1.4.54 has a signed integer overflow, which might allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a malicious HTTP GET request, as demonstrated by mishandling of /%2F? in burl_normalize_2F_to_slash_fix in burl.c. NOTE: The developer states \"The feature which can be abused to cause the crash is a new feature in lighttpd 1.4.50, and is not enabled by default. It must be explicitly configured in the config file (e.g. lighttpd.conf). Certain input will trigger an abort() in lighttpd when that feature is enabled. lighttpd detects the underflow or realloc() will fail (in both 32-bit and 64-bit executables), also detected in lighttpd. Either triggers an explicit abort() by lighttpd. This is not exploitable beyond triggering the explicit abort() with subsequent application exit.\""}, {"lang": "es", "value": "** EN DISPUTA ** lighttpd before 1.4.54 has a signed integer overflow, which might allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a malicious HTTP GET request, as demonstrated by mishandling of /%2F? in burl_normalize_2F_to_slash_fix in burl.c. NOTA: El desarrollador afirma \"La caracter\u00edstica que puede ser abusada para causar el fallo es una nueva caracter\u00edstica en lighttpd 1.4.50, y no est\u00e1 habilitada por defecto. Debe estar configurado expl\u00edcitamente en el archivo de configuraci\u00f3n (por ejemplo, lighttpd.conf). Cierta entrada activar\u00e1 un abort() en lighttpd cuando esa caracter\u00edstica est\u00e9 activada. lighttpd detecta que el underflow o realloc() fallar\u00e1 (tanto en ejecutables de 32 bits como en ejecutables de 64 bits), tambi\u00e9n detectado en lighttpd. O bien desencadena un abort() expl\u00edcito por parte de lighttpd. Esto no es explotable m\u00e1s all\u00e1 de activar el abort() expl\u00edcito con la subsiguiente salida de la aplicaci\u00f3n\"."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lighttpd:lighttpd:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.4.53", "matchCriteriaId": "8CDE5522-6BFF-4679-8289-6A43F9749818"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/107907", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/lighttpd/lighttpd1.4/commit/32120d5b8b3203fc21ccb9eafb0eaf824bb59354", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://redmine.lighttpd.net/issues/2945", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/lighttpd/lighttpd1.4/commit/32120d5b8b3203fc21ccb9eafb0eaf824bb59354"}}