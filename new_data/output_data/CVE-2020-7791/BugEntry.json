{"buggy_code": ["using System;\nusing System.Collections.Generic;\nusing System.Collections.Concurrent;\nusing System.Globalization;\nusing System.Linq;\nusing System.Text.RegularExpressions;\nusing i18n.Domain.Abstract;\nusing i18n.Domain.Entities;\nusing i18n.Domain.Concrete;\nusing i18n.Helpers;\n\nnamespace i18n\n{\n    /// <summary>\n    /// A service for retrieving localized text from PO resource files\n    /// </summary>\n    public class TextLocalizer : ITextLocalizer\n    {\n        private i18nSettings _settings;\n\n        private ITranslationRepository _translationRepository;\n\n        private static Regex unicodeMatchRegex = new Regex(@\"\\\\U(?<Value>[0-9A-F]{4})\", RegexOptions.IgnoreCase | RegexOptions.Compiled);\n\n        public TextLocalizer(\n            i18nSettings settings,\n            ITranslationRepository translationRepository)\n        {\n            _settings = settings;\n            _translationRepository = translationRepository;\n        }\n\n\n    #region [ITextLocalizer]\n\n        public virtual ConcurrentDictionary<string, LanguageTag> GetAppLanguages()\n        {\n            ConcurrentDictionary<string, LanguageTag> AppLanguages = (ConcurrentDictionary<string, LanguageTag>)System.Web.HttpRuntime.Cache[\"i18n.AppLanguages\"];\n            if (AppLanguages != null) {\n                return AppLanguages; }\n            lock (Sync)\n            {\n                AppLanguages = (ConcurrentDictionary<string, LanguageTag>)System.Web.HttpRuntime.Cache[\"i18n.AppLanguages\"];\n                if (AppLanguages != null) {\n                    return AppLanguages; }\n                AppLanguages = new ConcurrentDictionary<string, LanguageTag>();\n\n               // Insert into cache.\n               // NB: we do this before actually populating the collection. This is so that any changes to the\n               // folders before we finish populating the collection will cause the cache item to be invalidated\n               // and hence reloaded on next request, and so will not be missed.\n                System.Web.HttpRuntime.Cache.Insert(\"i18n.AppLanguages\", AppLanguages, _translationRepository.GetCacheDependencyForAllLanguages());\n\n               // Populate the collection.\n                List<string> languages = _translationRepository.GetAvailableLanguages().Select(x => x.LanguageShortTag).ToList();\n\n                // Ensure default language is included in AppLanguages where appropriate.\n                if (LocalizedApplication.Current.MessageKeyIsValueInDefaultLanguage\n                    && !languages.Any(x => LocalizedApplication.Current.DefaultLanguageTag.Equals(x))) {\n                    languages.Add(LocalizedApplication.Current.DefaultLanguageTag.ToString()); }\n\n                foreach (var langtag in languages)\n                {\n                    if (IsLanguageValid(langtag))\n                    {\n                        AppLanguages[langtag] = LanguageTag.GetCachedInstance(langtag); \n                    }\n                }\n\n               // Done.\n                return AppLanguages;\n            }\n        }\n\n        public virtual string GetText(string msgid, string msgcomment, LanguageItem[] languages, out LanguageTag o_langtag, int maxPasses = -1)\n        {\n            // Validate arguments.\n            if (maxPasses > (int)LanguageTag.MatchGrade._MaxMatch +1) { \n                maxPasses = (int)LanguageTag.MatchGrade._MaxMatch +1; }\n            // Init.\n            bool fallbackOnDefault = maxPasses == (int)LanguageTag.MatchGrade._MaxMatch +1\n                || maxPasses == -1;\n            // Determine the key for the msg lookup. This may be either msgid or msgid+msgcomment, depending on the prevalent\n            // MessageContextEnabledFromComment setting.\n            string msgkey = msgid == null ? \n                msgid:\n                TemplateItem.KeyFromMsgidAndComment(msgid, msgcomment, _settings.MessageContextEnabledFromComment);\n            // Perform language matching based on UserLanguages, AppLanguages, and presence of\n            // resource under msgid for any particular AppLanguage.\n            string text;\n            o_langtag = LanguageMatching.MatchLists(\n                languages, \n                GetAppLanguages().Values, \n                msgkey, \n                TryGetTextFor, \n                out text, \n                Math.Min(maxPasses, (int)LanguageTag.MatchGrade._MaxMatch));\n            // If match was successfull\n            if (text != null) {\n                // If the msgkey was returned...don't output that but rather the msgid as the msgkey\n                // may be msgid+msgcomment.\n                if (text == msgkey) {\n                    return msgid; }                \n                return text;\n            }\n            // Optionally try default language.\n            if (fallbackOnDefault)\n            {\n                o_langtag = LocalizedApplication.Current.DefaultLanguageTag;\n                return msgid;\n            }\n            //\n            return null;\n        }\n\n    #endregion\n\n        internal readonly object Sync = new object();\n\n        /// <summary>\n        /// Assesses whether a language is PO-valid, that is whether or not one or more\n        /// localized messages exists for the language.\n        /// </summary>\n        /// <returns>true if one or more localized messages exist for the language; otherwise false.</returns>\n        private bool IsLanguageValid(string langtag)\n        {\n        // Note that there is no need to serialize access to System.Web.HttpRuntime.Cache when just reading from it.\n        //\n            // Default language is always valid.\n            if (LocalizedApplication.Current.MessageKeyIsValueInDefaultLanguage\n                && LocalizedApplication.Current.DefaultLanguageTag.Equals(langtag)) {\n                return true; }\n\n            ConcurrentDictionary<string, TranslationItem> messages = (ConcurrentDictionary<string, TranslationItem>)System.Web.HttpRuntime.Cache[GetCacheKey(langtag)];\n\n            // If messages not yet loaded in for the language\n            if (messages == null)\n            {\n                return _translationRepository.TranslationExists(langtag);\n            }\n\n            return true;\n        }\n\n        /// <summary>\n        /// Lookup whether any messages exist for the passed langtag, and if so attempts\n        /// to lookup the message for the passed msgid, or if the msgid is null returns indication\n        /// of whether any messages exist for the langtag.\n        /// </summary>\n        /// <param name=\"langtag\">\n        /// Language tag of the subject langtag.\n        /// </param>\n        /// <param name=\"msgkey\">\n        /// Key of the message to lookup, or null to test for any message loaded for the langtag.\n        /// When on-null, the format of the key is as generated by the TemplateItem.KeyFromMsgidAndComment\n        /// helper.\n        /// </param>\n        /// <returns>\n        /// On success, returns the translated message, or if msgkey is null returns an empty string (\"\")\n        /// to indciate that one or more messages exist for the langtag.\n        /// On failure, returns null.\n        /// </returns>\n        private string TryGetTextFor(string langtag, string msgkey)\n        {\n            // If no messages loaded for language...fail.\n            if (!IsLanguageValid(langtag)) {\n                return null; }\n\n            // If not testing for a specific message, that is just testing whether any messages \n            // are present...return positive.\n            if (msgkey == null) {\n                return \"\"; }   \n\n            // Lookup specific message text in the language PO and if found...return that.\n            string text = LookupText(langtag, msgkey);\n            if (text == null && unicodeMatchRegex.IsMatch(msgkey))\n            {\n                // If message was not found but contains escaped unicode characters, try converting those\n                // to characters and look up the message again\n                var msgkeyClean = unicodeMatchRegex.Replace(msgkey, m =>\n                {\n                    var code = int.Parse(m.Groups[\"Value\"].Value, NumberStyles.HexNumber);\n                    return char.ConvertFromUtf32(code);\n                });\n                text = LookupText(langtag, msgkeyClean);\n            }\n\n            if (text != null) {\n                return text; }\n\n            // If we are looking up in the default language, and the message keys describe values\n            // in that language...return the msgkey.\n            if (LocalizedApplication.Current.DefaultLanguageTag.Equals(langtag)\n                && LocalizedApplication.Current.MessageKeyIsValueInDefaultLanguage) {\n                return msgkey; }\n\n            // Lookup failed.\n            return null;\n        }\n\n        private bool LoadMessagesIntoCache(string langtag)\n        {\n            lock (Sync)\n            {\n                // It is possible for multiple threads to race to this method. The first to\n                // enter the above lock will insert the messages into the cache.\n                // If we lost the race...no need to duplicate the work of the winning thread.\n                if (System.Web.HttpRuntime.Cache[GetCacheKey(langtag)] != null)\n                {\n                    return true;\n                }\n\n                Translation t = _translationRepository.GetTranslation(langtag);\n\n                // Cache messages.\n                // \u00b7 In order to facilitate dynamic refreshing of translations during runtime\n                //   (without restarting the server instance) we first establish something upon \n                //   which the cache entry will be dependent: that is a 'cache dependency' object\n                //   which essentially triggers an event if/when the entry is to be considered\n                //   as 'dirty' and whihc is listened to by the cache.\n                //   In our case, we want this 'dirty' event to be triggered if/when the\n                //   translation's source PO file is updated.\n                //   NB: it is possible for GetCacheDependencyForSingleLanguage to return null in the\n                //   case of the default language where it is added to AppLanguages yet there \n                //   doesn't actually exist an underlying PO file. This is perfectly valid when\n                //   LocalizedApplication.MessageKeyIsValueInDefaultLanguage == true (default setting).\n                //   In this case the cache entry is associated with the null CacheDependency instance\n                //   which means the cache entry is effectively permanent for this server instance.\n                System.Web.Caching.CacheDependency cd = _translationRepository.GetCacheDependencyForSingleLanguage(langtag);\n                // \u00b7 Insert translation into cache associating it with any CacheDependency.\n                System.Web.HttpRuntime.Cache.Insert(GetCacheKey(langtag), t.Items, cd);\n            }\n            return true;\n        }\n\n       /// <returns>null if not found.</returns>\n        private string LookupText(string langtag, string msgkey)\n        {\n        // Note that there is no need to serialize access to System.Web.HttpRuntime.Cache when just reading from it.\n        //\n            var messages = (ConcurrentDictionary<string, TranslationItem>) System.Web.HttpRuntime.Cache[GetCacheKey(langtag)];\n            TranslationItem message = null;\n\n            //we need to populate the cache\n            if (messages == null)\n            {\n                LoadMessagesIntoCache(langtag);\n                messages = (ConcurrentDictionary<string, TranslationItem>)System.Web.HttpRuntime.Cache[GetCacheKey(langtag)];\n            }\n\n           // Normalize any CRLF in the msgid i.e. to just LF.\n           // PO only support LF so we expect strings to be stored in the repo in that form.\n           // NB: we test Contains before doing Replace in case string.Replace allocs a new\n           // string even on no change. (This method is called very often.)\n            if (msgkey.Contains(\"\\r\\n\")) {\n                msgkey = msgkey.Replace(\"\\r\\n\", \"\\n\"); }\n\n            if (messages == null\n                || !messages.TryGetValue(msgkey, out message)\n                || !message.Message.IsSet())\n            {\n                return null;\n            }\n\n            return message.Message;\n        }\n\n        /// <returns>null if not found.</returns>\n        private static CultureInfo GetCultureInfoFromLanguage(string language)\n        {\n        // TODO: replace usage of CultureInfo with the LanguageTag class.\n        // This method and the use of CultureInfo is now surpassed by the LanguageTag class,\n        // thus making this method of handling language tags redundant.\n        //\n            if (string.IsNullOrWhiteSpace(language)) {\n                return null; }\n            try {\n                var semiColonIndex = language.IndexOf(';');\n                language = semiColonIndex > -1 ? language.Substring(0, semiColonIndex) : language;\n                language = System.Globalization.CultureInfo.CreateSpecificCulture(language).Name;\n                return new CultureInfo(language, true);\n            }\n            catch (Exception) {\n                return null; }\n        }\n\n        private static string GetCacheKey(string langtag)\n        {\n            //return string.Format(\"po:{0}\", langtag).ToLowerInvariant();\n                // The above will cause a new string to be allocated.\n                // So subsituted with the following code.\n\n            // Obtain the cache key without allocating a new string (except for first time).\n            // As this method is a high-frequency method, the overhead in the (lock-free) dictionary \n            // lookup is thought to outweigh the potentially large number of temporary string allocations\n            // and the consequently hastened garbage collections.\n            return LanguageTag.GetCachedInstance(langtag).GlobalKey;\n        }\n    }\n}\n", "using System;\nusing System.Threading;\nusing System.Text.RegularExpressions;\nusing i18n.Helpers;\nusing i18n.Domain.Abstract;\nusing i18n.Domain.Concrete;\n\nnamespace i18n\n{\n    public class DefaultRootServices : IRootServices\n    {\n        private static object syncRoot = new object();\n        private Lazy<POTranslationRepository> translationRepository;\n        private IUrlLocalizer urlLocalizer;\n        private Lazy<TextLocalizer> textLocalizer;\n        private IEarlyUrlLocalizer earlyUrlLocalizer;\n        private Lazy<NuggetLocalizer> nuggetLocalizer;\n\n        public DefaultRootServices()\n        {\n            // Use Lazy to delay the creation of objects to when a request is being processed.\n            // When initializing the app thehi may throw \"Request is not available in this context\" from WebConfigService\n            translationRepository = new Lazy<POTranslationRepository>(() => new POTranslationRepository(new i18nSettings(new WebConfigSettingService())));\n            urlLocalizer = new UrlLocalizer();\n            textLocalizer = new Lazy<TextLocalizer>(() => new TextLocalizer(new i18nSettings(new WebConfigSettingService()), TranslationRepositoryForApp));\n            earlyUrlLocalizer = new EarlyUrlLocalizer(urlLocalizer);\n            nuggetLocalizer = new Lazy<NuggetLocalizer>(() => new NuggetLocalizer(new i18nSettings(new WebConfigSettingService()), TextLocalizerForApp));\n        }\n\n        #region [IRootServices]\n\n        public ITranslationRepository TranslationRepositoryForApp\n        {\n            get\n            {\n                return translationRepository.Value;\n            }\n        }\n        public IUrlLocalizer UrlLocalizerForApp\n        {\n            get\n            {\n                return urlLocalizer;\n            }\n        }\n        public ITextLocalizer TextLocalizerForApp\n        {\n            get\n            {\n                return textLocalizer.Value;\n            }\n        }\n        public IEarlyUrlLocalizer EarlyUrlLocalizerForApp\n        {\n            get\n            {\n                return earlyUrlLocalizer;\n            }\n        }\n        public INuggetLocalizer NuggetLocalizerForApp\n        {\n            get\n            {\n                return nuggetLocalizer.Value;\n            }\n        }\n\n        #endregion\n\n    }\n\n    /// <summary>\n    /// Manages the configuration of the i18n features of your localized application.\n    /// </summary>\n    public class LocalizedApplication : IRootServices\n    {\n\n        #region [IRootServices]\n\n        public ITranslationRepository TranslationRepositoryForApp { get { return RootServices.TranslationRepositoryForApp; } }\n        public IUrlLocalizer UrlLocalizerForApp { get { return RootServices.UrlLocalizerForApp; } }\n        public ITextLocalizer TextLocalizerForApp { get { return RootServices.TextLocalizerForApp; } }\n        public IEarlyUrlLocalizer EarlyUrlLocalizerForApp { get { return RootServices.EarlyUrlLocalizerForApp; } }\n        public INuggetLocalizer NuggetLocalizerForApp { get { return RootServices.NuggetLocalizerForApp; } }\n\n        #endregion\n\n        /// <summary>\n        /// The language to be used as the default for the application where no\n        /// explicit language is specified or determined for a request. Defaults to \"en\".\n        /// </summary>\n        /// <remarks>\n        /// When MessageKeyIsValueInDefaultLanguage is true, GetText may interpret\n        /// the message keys to be message values in the DefaultLanguage (where\n        /// no explicit message value is defined in the DefaultLanguage) and so\n        /// output the message key.<br/>\n        /// The DefaultLanguage is used in Url Localization Scheme2 for the default URL.<br/>\n        /// Supports a subset of BCP 47 language tag spec corresponding to the Windows\n        /// support for language names, namely the following subtags:\n        ///     language (mandatory, 2 alphachars)\n        ///     script   (optional, 4 alphachars)\n        ///     region   (optional, 2 alphachars | 3 decdigits)\n        /// Example tags supported:\n        ///     \"en\"            [language]\n        ///     \"en-US\"         [language + region]\n        ///     \"zh\"            [language]\n        ///     \"zh-HK\"         [language + region]\n        ///     \"zh-123\"        [language + region]\n        ///     \"zh-Hant\"       [language + script]\n        ///     \"zh-Hant-HK\"    [language + script + region]\n        ///     \"zh-Hant-HK-x-ABCD\"    [language + script + region + private use]\n        /// </remarks>\n        public string DefaultLanguage\n        {\n            get\n            {\n                return DefaultLanguageTag.ToString();\n            }\n            set\n            {\n                DefaultLanguageTag = LanguageTag.GetCachedInstance(value);\n            }\n        }\n        public LanguageTag DefaultLanguageTag { get; set; }\n\n        /// <summary>\n        /// Specifies whether the key for a message may be assumed to be the value for\n        /// the message in the default language. Defaults to true.\n        /// </summary>\n        /// <remarks>\n        /// When true, the i18n GetText method will take it that a translation exists\n        /// for all messages in the default language, even though in reality a translation\n        /// is not present for the message in the default language's PO file.<br/>\n        /// When false, an explicit translation is required in the default language. Typically\n        /// this can be useful where keys are not strings to be output but rather codes or mnemonics\n        /// of some kind.\n        /// </remarks>\n        public bool MessageKeyIsValueInDefaultLanguage { get; set; }\n\n        /// <summary>\n        /// The ASP.NET application's virtual application root path on the server,\n        /// used by Url Localization.\n        /// </summary>\n        /// <remarks>\n        /// This is set by the ctor automatically to the ApplicationPath of\n        /// HttpContext.Current, when available. Should that not be available\n        /// then the value defaults to \"/\".<br/>\n        /// In situations where the application is configured to run under a virtual folder\n        /// and you init this class in such a way that HttpContext.Current is not\n        /// available, it will be necessary to set this correctly manually to the application\n        /// root path.<br/>\n        /// E.g. if the application root url is \"example.com/MySite\",\n        /// set this to \"/MySite\". It is important that the string starts with a forward slash path separator\n        /// and does NOT end with a forward slash.\n        /// </remarks>\n        public string ApplicationPath { get; set; }\n\n        /// <summary>\n        /// The name for the i18n cookie. Defaults to \"i18n.langtag\".\n        /// </summary>\n        public string CookieName { get; set; }\n\n        /// <summary>\n        /// Declares a method type for handling the setting of the language.\n        /// </summary>\n        /// <param name=\"context\">Current http context.</param>\n        /// <param name=\"langtag\">Language being set.</param>\n        public delegate void SetLanguageHandler(System.Web.HttpContextBase context, ILanguageTag langtag);\n\n        /// <summary>\n        /// Describes one or more procedures to be called when the principal application\n        /// language (PAL) is set for an HTTP request.\n        /// </summary>\n        /// <remarks>\n        /// A default handlers is installed which applies the PAL setting to both the\n        /// CurrentCulture and CurrentUICulture settings of the current thread.\n        /// This behaviour can be altered by removing (nulling) the value of this property\n        /// or replacing with a new delegate.\n        /// </remarks>\n        public SetLanguageHandler SetPrincipalAppLanguageForRequestHandlers { get; set; }\n\n        /// <summary>\n        /// Declares a method type for a custom method called after a nugget has been translated\n        /// that allows the resulting message to be modified.\n        /// </summary>\n        /// <remarks>\n        /// In general it is good practice to postpone the escaping of characters until they\n        /// are about to be displayed and then according to the content type of the output.\n        /// Thus, a single quote character need not be escaped if in JSON, but should be escaped\n        /// if in HTML or Javascript.\n        /// This method allows for such conditional modification of the message.\n        /// </remarks>\n        /// <param name=\"context\">Current http context.</param>\n        /// <param name=\"nugget\">The subject nugget being translated.</param>\n        /// <param name=\"langtag\">Language being set.</param>\n        /// <param name=\"message\">The message string which may be modified.</param>\n        /// <returns>\n        /// Modified message string (or message if no modification).\n        /// </returns>\n        public delegate string TweakMessageTranslationProc(System.Web.HttpContextBase context, Nugget nugget, LanguageTag langtag, string message);\n\n        /// <summary>\n        /// Registers a custom method called after a nugget has been translated\n        /// that allows the resulting message to be modified.\n        /// </summary>\n        /// <remarks>\n        /// In general it is good practice to postpone the escaping of characters until they\n        /// are about to be displayed and then according to the content type of the output.\n        /// This, a single quote character need not be escaped if in JSON, but should be escaped\n        /// if in HTML or Javascript.\n        /// This method allows for such conditional modification of the message.\n        /// </remarks>\n        public TweakMessageTranslationProc TweakMessageTranslation { get; set; }\n\n        /// <summary>\n        /// Specifies the type of HTTP redirect to be issued by automatic language routing:\n        /// true for 301 (permanent) redirects; false for 302 (temporary) ones.\n        /// Defaults to false.\n        /// </summary>\n        public bool PermanentRedirects { get; set; }\n\n        /// <summary>\n        /// Regular expression that controls the ContextTypes elligible for response localization.\n        /// </summary>\n        /// <remarks>\n        /// Set to null to disable Late URL Localization.<br/>\n        /// Defaults to @\"^(?:(?:(?:text|application)/(?:plain|html|xml|javascript|x-javascript|json|x-json))(?:\\s*;.*)?)$.<br/>\n        /// Client may customise this member, for instance in Application_Start.<br/>\n        /// This feature requires the LocalizedModule HTTP module to be intalled in web.config.<br/>\n        /// Explanation of the default regex:<br/>\n        ///  Content-type string must begin with \"text\" or \"application\"<br/>\n        ///  This must be followed by \"/\"<br/>\n        ///  This must be followed by \"plain\" or \"html\" ...<br/>\n        ///  And finally this may be followed by the following sequence:<br/>\n        ///      zero or more whitespace then \";\" then any number of any chars up to end of string.\n        /// </remarks>\n        public Regex ContentTypesToLocalize = new Regex(@\"^(?:(?:(?:text|application)/(?:plain|html|xml|javascript|x-javascript|json|x-json))(?:\\s*;.*)?)$\");\n\n        /// <summary>\n        /// Regular expression that excludes certain URL paths from being localized.\n        /// </summary>\n        /// <remarks>\n        /// Defaults to excluding all less and css files and any URLs containing the phrases i18nSkip, glimpse, trace or elmah (case-insensitive)<br/>\n        /// Clients may customise this member in Application_Start<br/>\n        /// This feature requires the LocalizedModule HTTP module to be intalled in web.config.<br/>\n        /// </remarks>\n        public Regex UrlsToExcludeFromProcessing = new Regex(@\"(?:\\.(?:less|css)(?:\\?|$))|(?i:i18nSkip|glimpse|trace|elmah)\");\n\n        /// <summary>\n        /// Comma separated value string that lists the async postback types that should be localized.\n        /// </summary>\n        /// <remarks>\n        /// Defaults to \"updatePanel,scriptStartupBlock,pageTitle\"<br/>\n        /// Clients may customise this member in Application_Start.<br/>\n        /// </remarks>\n        public string AsyncPostbackTypesToTranslate = \"updatePanel,scriptStartupBlock,pageTitle\";\n\n        public LocalizedApplication(IRootServices i_RootServices = null)\n        {\n\n            // Default settings.\n            DefaultLanguage = (\"en\");\n            CookieName = \"i18n.langtag\";\n            MessageKeyIsValueInDefaultLanguage = true;\n            PermanentRedirects = false;\n\n            // Attempt to determine ApplicationPath.\n            // NB: if this method being called outside of a request handler, HttpContext.Current\n            // fails. Normally, this results in a null being returned; however it has been observed\n            // that it can also throw.\n            try\n            {\n                var mycontext = System.Web.HttpContext.Current;\n                if (mycontext != null && mycontext.Request.ApplicationPath != null)\n                    ApplicationPath = mycontext.Request.ApplicationPath.TrimEnd('/');\n            }\n            catch (Exception) { }\n            if (String.IsNullOrWhiteSpace(ApplicationPath))\n            {\n                ApplicationPath = \"/\";\n            }\n\n            // Use default package of root services.\n            // Host app may override this.\n            RootServices = i_RootServices ?? new DefaultRootServices();\n\n            // Install default handler for Set-PAL event.\n            // The default handler applies the setting to both the CurrentCulture and CurrentUICulture\n            // settings of the thread.\n            SetPrincipalAppLanguageForRequestHandlers = delegate(System.Web.HttpContextBase context, ILanguageTag langtag)\n            {\n                if (langtag != null)\n                {\n                    Thread.CurrentThread.CurrentCulture = Thread.CurrentThread.CurrentUICulture = langtag.GetCultureInfo();\n                }\n            };\n        }\n\n        private static LocalizedApplication current;\n\n        /// <summary>\n        /// Instance of the this LocalizedApplication class for the current AppDomain.\n        /// </summary>\n        public static LocalizedApplication Current\n        {\n            get { return current ?? (current = new LocalizedApplication()); }\n            set { current = value; }\n        }\n\n        /// <summary>\n        /// Conditionally installs the i18n response filter.\n        /// </summary>\n        /// <param name=\"context\">The HttpContext context.</param>\n        public static void InstallResponseFilter(System.Web.HttpContextBase context)\n        {\n            InstallResponseFilter(context, null);\n        }\n\n        /// <summary>\n        /// Conditionally installs the i18n response filter.\n        /// </summary>\n        /// <param name=\"context\">The HTTP context.</param>\n        /// <param name=\"rootServices\">The root services.</param>\n        public static void InstallResponseFilter(System.Web.HttpContextBase context, IRootServices rootServices)\n        {\n            if (rootServices == null)\n            {\n                rootServices = Current.RootServices;\n            }\n\n            // If the content type of the entity is eligible for processing AND the URL is not to be excluded,\n            // wire up our filter to do the processing. The entity data will be run through the filter a\n            // bit later on in the pipeline.\n            if (Current.ContentTypesToLocalize != null\n                    && Current.ContentTypesToLocalize.Match(context.Response.ContentType).Success) // Include certain content types from being processed\n            {\n                if (Current.UrlsToExcludeFromProcessing != null\n                    && Current.UrlsToExcludeFromProcessing.Match(context.Request.RawUrl).Success) // Exclude certain URLs from being processed\n                {\n                    DebugHelpers.WriteLine(\"InstallResponseFilter -- Bypassing filter, URL excluded: ({0}).\", context.Request.RawUrl);\n                }\n                else if (context.Response.Headers[\"Content-Encoding\"] != null\n                    || context.Response.Headers[\"Content-Encoding\"] == \"gzip\") // Exclude responses that have already been compressed earlier in the pipeline\n                {\n                    DebugHelpers.WriteLine(\"InstallResponseFilter -- Bypassing filter, response compressed.\");\n                }\n                else\n                {\n                    DebugHelpers.WriteLine(\"InstallResponseFilter -- Installing filter\");\n                    context.Response.Filter = new ResponseFilter(\n                        context,\n                        context.Response.Filter,\n                        UrlLocalizer.UrlLocalizationScheme == UrlLocalizationScheme.Void ? null : rootServices.EarlyUrlLocalizerForApp,\n                        rootServices.NuggetLocalizerForApp);\n                }\n            }\n            else\n            {\n                DebugHelpers.WriteLine(\"InstallResponseFilter -- Bypassing filter, No content-type match: ({0}).\", context.Response.ContentType);\n            }\n        }\n\n        /// <summary>\n        /// This object relays its implementaion of IRootServices onto the object set here.\n        /// Host app may override with its own implementation.\n        /// By default, this property is set to an instance of DefaultRootServices.\n        /// </summary>\n        public IRootServices RootServices { get; set; }\n    }\n}\n"], "fixing_code": ["using System;\nusing System.Collections.Generic;\nusing System.Collections.Concurrent;\nusing System.Globalization;\nusing System.Linq;\nusing System.Text.RegularExpressions;\nusing i18n.Domain.Abstract;\nusing i18n.Domain.Entities;\nusing i18n.Domain.Concrete;\nusing i18n.Helpers;\n\nnamespace i18n\n{\n    /// <summary>\n    /// A service for retrieving localized text from PO resource files\n    /// </summary>\n    public class TextLocalizer : ITextLocalizer\n    {\n        private i18nSettings _settings;\n\n        private ITranslationRepository _translationRepository;\n\n        private static Regex unicodeMatchRegex = new Regex(@\"\\\\U(?<Value>[0-9A-F]{4})\", RegexOptions.IgnoreCase | RegexOptions.Compiled);\n\n        public TextLocalizer(\n            i18nSettings settings,\n            ITranslationRepository translationRepository)\n        {\n            _settings = settings;\n            _translationRepository = translationRepository;\n        }\n\n\n    #region [ITextLocalizer]\n\n        public virtual ConcurrentDictionary<string, LanguageTag> GetAppLanguages()\n        {\n            ConcurrentDictionary<string, LanguageTag> AppLanguages = (ConcurrentDictionary<string, LanguageTag>)System.Web.HttpRuntime.Cache[\"i18n.AppLanguages\"];\n            if (AppLanguages != null) {\n                return AppLanguages; }\n            lock (Sync)\n            {\n                AppLanguages = (ConcurrentDictionary<string, LanguageTag>)System.Web.HttpRuntime.Cache[\"i18n.AppLanguages\"];\n                if (AppLanguages != null) {\n                    return AppLanguages; }\n                AppLanguages = new ConcurrentDictionary<string, LanguageTag>();\n\n               // Insert into cache.\n               // NB: we do this before actually populating the collection. This is so that any changes to the\n               // folders before we finish populating the collection will cause the cache item to be invalidated\n               // and hence reloaded on next request, and so will not be missed.\n                System.Web.HttpRuntime.Cache.Insert(\"i18n.AppLanguages\", AppLanguages, _translationRepository.GetCacheDependencyForAllLanguages());\n\n               // Populate the collection.\n                List<string> languages = _translationRepository.GetAvailableLanguages().Select(x => x.LanguageShortTag).ToList();\n\n                // Ensure default language is included in AppLanguages where appropriate.\n                if (LocalizedApplication.Current.MessageKeyIsValueInDefaultLanguage\n                    && !languages.Any(x => LocalizedApplication.Current.DefaultLanguageTag.Equals(x))) {\n                    languages.Add(LocalizedApplication.Current.DefaultLanguageTag.ToString()); }\n\n                foreach (var langtag in languages)\n                {\n                    if (IsLanguageValid(langtag))\n                    {\n                        AppLanguages[langtag] = LanguageTag.GetCachedInstance(langtag); \n                    }\n                }\n\n               // Done.\n                return AppLanguages;\n            }\n        }\n\n        public virtual string GetText(string msgid, string msgcomment, LanguageItem[] languages, out LanguageTag o_langtag, int maxPasses = -1)\n        {\n            // Validate arguments.\n            if (maxPasses > (int)LanguageTag.MatchGrade._MaxMatch +1) { \n                maxPasses = (int)LanguageTag.MatchGrade._MaxMatch +1; }\n            // Init.\n            bool fallbackOnDefault = maxPasses == (int)LanguageTag.MatchGrade._MaxMatch +1\n                || maxPasses == -1;\n            // Determine the key for the msg lookup. This may be either msgid or msgid+msgcomment, depending on the prevalent\n            // MessageContextEnabledFromComment setting.\n            string msgkey = msgid == null ? \n                msgid:\n                TemplateItem.KeyFromMsgidAndComment(msgid, msgcomment, _settings.MessageContextEnabledFromComment);\n            // Perform language matching based on UserLanguages, AppLanguages, and presence of\n            // resource under msgid for any particular AppLanguage.\n            string text;\n            o_langtag = LanguageMatching.MatchLists(\n                languages, \n                GetAppLanguages().Values, \n                msgkey, \n                TryGetTextFor, \n                out text, \n                Math.Min(maxPasses, (int)LanguageTag.MatchGrade._MaxMatch));\n            // If match was successfull\n            if (text != null) {\n                // If the msgkey was returned...don't output that but rather the msgid as the msgkey\n                // may be msgid+msgcomment.\n                if (text == msgkey) {\n                    return msgid; }                \n                return text;\n            }\n            // Optionally try default language.\n            if (fallbackOnDefault)\n            {\n                o_langtag = LocalizedApplication.Current.DefaultLanguageTag;\n                return msgid;\n            }\n            //\n            return null;\n        }\n\n    #endregion\n\n        internal readonly object Sync = new object();\n\n        /// <summary>\n        /// Assesses whether a language is PO-valid, that is whether or not one or more\n        /// localized messages exists for the language.\n        /// </summary>\n        /// <returns>true if one or more localized messages exist for the language; otherwise false.</returns>\n        private bool IsLanguageValid(string langtag)\n        {\n        // Note that there is no need to serialize access to System.Web.HttpRuntime.Cache when just reading from it.\n        //\n            if (!langtag.IsSet()) {\n                return false; }\n\n            // Default language is always valid.\n            if (LocalizedApplication.Current.MessageKeyIsValueInDefaultLanguage\n                && LocalizedApplication.Current.DefaultLanguageTag.Equals(langtag)) {\n                return true; }\n\n            ConcurrentDictionary<string, TranslationItem> messages = (ConcurrentDictionary<string, TranslationItem>)System.Web.HttpRuntime.Cache[GetCacheKey(langtag)];\n\n            // If messages not yet loaded in for the language\n            if (messages == null)\n            {\n                return _translationRepository.TranslationExists(langtag);\n            }\n\n            return true;\n        }\n\n        /// <summary>\n        /// Lookup whether any messages exist for the passed langtag, and if so attempts\n        /// to lookup the message for the passed msgid, or if the msgid is null returns indication\n        /// of whether any messages exist for the langtag.\n        /// </summary>\n        /// <param name=\"langtag\">\n        /// Language tag of the subject langtag.\n        /// </param>\n        /// <param name=\"msgkey\">\n        /// Key of the message to lookup, or null to test for any message loaded for the langtag.\n        /// When on-null, the format of the key is as generated by the TemplateItem.KeyFromMsgidAndComment\n        /// helper.\n        /// </param>\n        /// <returns>\n        /// On success, returns the translated message, or if msgkey is null returns an empty string (\"\")\n        /// to indciate that one or more messages exist for the langtag.\n        /// On failure, returns null.\n        /// </returns>\n        private string TryGetTextFor(string langtag, string msgkey)\n        {\n            // If no messages loaded for language...fail.\n            if (!IsLanguageValid(langtag)) {\n                return null; }\n\n            // If not testing for a specific message, that is just testing whether any messages \n            // are present...return positive.\n            if (msgkey == null) {\n                return \"\"; }   \n\n            // Lookup specific message text in the language PO and if found...return that.\n            string text = LookupText(langtag, msgkey);\n            if (text == null && unicodeMatchRegex.IsMatch(msgkey))\n            {\n                // If message was not found but contains escaped unicode characters, try converting those\n                // to characters and look up the message again\n                var msgkeyClean = unicodeMatchRegex.Replace(msgkey, m =>\n                {\n                    var code = int.Parse(m.Groups[\"Value\"].Value, NumberStyles.HexNumber);\n                    return char.ConvertFromUtf32(code);\n                });\n                text = LookupText(langtag, msgkeyClean);\n            }\n\n            if (text != null) {\n                return text; }\n\n            // If we are looking up in the default language, and the message keys describe values\n            // in that language...return the msgkey.\n            if (LocalizedApplication.Current.DefaultLanguageTag.Equals(langtag)\n                && LocalizedApplication.Current.MessageKeyIsValueInDefaultLanguage) {\n                return msgkey; }\n\n            // Lookup failed.\n            return null;\n        }\n\n        private bool LoadMessagesIntoCache(string langtag)\n        {\n            lock (Sync)\n            {\n                // It is possible for multiple threads to race to this method. The first to\n                // enter the above lock will insert the messages into the cache.\n                // If we lost the race...no need to duplicate the work of the winning thread.\n                if (System.Web.HttpRuntime.Cache[GetCacheKey(langtag)] != null)\n                {\n                    return true;\n                }\n\n                Translation t = _translationRepository.GetTranslation(langtag);\n\n                // Cache messages.\n                // \u00b7 In order to facilitate dynamic refreshing of translations during runtime\n                //   (without restarting the server instance) we first establish something upon \n                //   which the cache entry will be dependent: that is a 'cache dependency' object\n                //   which essentially triggers an event if/when the entry is to be considered\n                //   as 'dirty' and whihc is listened to by the cache.\n                //   In our case, we want this 'dirty' event to be triggered if/when the\n                //   translation's source PO file is updated.\n                //   NB: it is possible for GetCacheDependencyForSingleLanguage to return null in the\n                //   case of the default language where it is added to AppLanguages yet there \n                //   doesn't actually exist an underlying PO file. This is perfectly valid when\n                //   LocalizedApplication.MessageKeyIsValueInDefaultLanguage == true (default setting).\n                //   In this case the cache entry is associated with the null CacheDependency instance\n                //   which means the cache entry is effectively permanent for this server instance.\n                System.Web.Caching.CacheDependency cd = _translationRepository.GetCacheDependencyForSingleLanguage(langtag);\n                // \u00b7 Insert translation into cache associating it with any CacheDependency.\n                System.Web.HttpRuntime.Cache.Insert(GetCacheKey(langtag), t.Items, cd);\n            }\n            return true;\n        }\n\n       /// <returns>null if not found.</returns>\n        private string LookupText(string langtag, string msgkey)\n        {\n        // Note that there is no need to serialize access to System.Web.HttpRuntime.Cache when just reading from it.\n        //\n            var messages = (ConcurrentDictionary<string, TranslationItem>) System.Web.HttpRuntime.Cache[GetCacheKey(langtag)];\n            TranslationItem message = null;\n\n            //we need to populate the cache\n            if (messages == null)\n            {\n                LoadMessagesIntoCache(langtag);\n                messages = (ConcurrentDictionary<string, TranslationItem>)System.Web.HttpRuntime.Cache[GetCacheKey(langtag)];\n            }\n\n           // Normalize any CRLF in the msgid i.e. to just LF.\n           // PO only support LF so we expect strings to be stored in the repo in that form.\n           // NB: we test Contains before doing Replace in case string.Replace allocs a new\n           // string even on no change. (This method is called very often.)\n            if (msgkey.Contains(\"\\r\\n\")) {\n                msgkey = msgkey.Replace(\"\\r\\n\", \"\\n\"); }\n\n            if (messages == null\n                || !messages.TryGetValue(msgkey, out message)\n                || !message.Message.IsSet())\n            {\n                return null;\n            }\n\n            return message.Message;\n        }\n\n        /// <returns>null if not found.</returns>\n        private static CultureInfo GetCultureInfoFromLanguage(string language)\n        {\n        // TODO: replace usage of CultureInfo with the LanguageTag class.\n        // This method and the use of CultureInfo is now surpassed by the LanguageTag class,\n        // thus making this method of handling language tags redundant.\n        //\n            if (string.IsNullOrWhiteSpace(language)) {\n                return null; }\n            try {\n                var semiColonIndex = language.IndexOf(';');\n                language = semiColonIndex > -1 ? language.Substring(0, semiColonIndex) : language;\n                language = System.Globalization.CultureInfo.CreateSpecificCulture(language).Name;\n                return new CultureInfo(language, true);\n            }\n            catch (Exception) {\n                return null; }\n        }\n\n        private static string GetCacheKey(string langtag)\n        {\n            //return string.Format(\"po:{0}\", langtag).ToLowerInvariant();\n                // The above will cause a new string to be allocated.\n                // So subsituted with the following code.\n\n            // Obtain the cache key without allocating a new string (except for first time).\n            // As this method is a high-frequency method, the overhead in the (lock-free) dictionary \n            // lookup is thought to outweigh the potentially large number of temporary string allocations\n            // and the consequently hastened garbage collections.\n            return LanguageTag.GetCachedInstance(langtag).GlobalKey;\n        }\n    }\n}\n", "using System;\nusing System.Threading;\nusing System.Text.RegularExpressions;\nusing i18n.Helpers;\nusing i18n.Domain.Abstract;\nusing i18n.Domain.Concrete;\n\nnamespace i18n\n{\n    public class DefaultRootServices : IRootServices\n    {\n        private static object syncRoot = new object();\n        private Lazy<POTranslationRepository> translationRepository;\n        private IUrlLocalizer urlLocalizer;\n        private Lazy<TextLocalizer> textLocalizer;\n        private IEarlyUrlLocalizer earlyUrlLocalizer;\n        private Lazy<NuggetLocalizer> nuggetLocalizer;\n\n        public DefaultRootServices()\n        {\n            // Use Lazy to delay the creation of objects to when a request is being processed.\n            // When initializing the app thehi may throw \"Request is not available in this context\" from WebConfigService\n            translationRepository = new Lazy<POTranslationRepository>(() => new POTranslationRepository(new i18nSettings(new WebConfigSettingService())));\n            urlLocalizer = new UrlLocalizer();\n            textLocalizer = new Lazy<TextLocalizer>(() => new TextLocalizer(new i18nSettings(new WebConfigSettingService()), TranslationRepositoryForApp));\n            earlyUrlLocalizer = new EarlyUrlLocalizer(urlLocalizer);\n            nuggetLocalizer = new Lazy<NuggetLocalizer>(() => new NuggetLocalizer(new i18nSettings(new WebConfigSettingService()), TextLocalizerForApp));\n        }\n\n        #region [IRootServices]\n\n        public ITranslationRepository TranslationRepositoryForApp\n        {\n            get\n            {\n                return translationRepository.Value;\n            }\n        }\n        public IUrlLocalizer UrlLocalizerForApp\n        {\n            get\n            {\n                return urlLocalizer;\n            }\n        }\n        public ITextLocalizer TextLocalizerForApp\n        {\n            get\n            {\n                return textLocalizer.Value;\n            }\n        }\n        public IEarlyUrlLocalizer EarlyUrlLocalizerForApp\n        {\n            get\n            {\n                return earlyUrlLocalizer;\n            }\n        }\n        public INuggetLocalizer NuggetLocalizerForApp\n        {\n            get\n            {\n                return nuggetLocalizer.Value;\n            }\n        }\n\n        #endregion\n\n    }\n\n    /// <summary>\n    /// Manages the configuration of the i18n features of your localized application.\n    /// </summary>\n    public class LocalizedApplication : IRootServices\n    {\n\n        #region [IRootServices]\n\n        public ITranslationRepository TranslationRepositoryForApp { get { return RootServices.TranslationRepositoryForApp; } }\n        public IUrlLocalizer UrlLocalizerForApp { get { return RootServices.UrlLocalizerForApp; } }\n        public ITextLocalizer TextLocalizerForApp { get { return RootServices.TextLocalizerForApp; } }\n        public IEarlyUrlLocalizer EarlyUrlLocalizerForApp { get { return RootServices.EarlyUrlLocalizerForApp; } }\n        public INuggetLocalizer NuggetLocalizerForApp { get { return RootServices.NuggetLocalizerForApp; } }\n\n        #endregion\n\n        /// <summary>\n        /// The language to be used as the default for the application where no\n        /// explicit language is specified or determined for a request. Defaults to \"en\".\n        /// </summary>\n        /// <remarks>\n        /// When MessageKeyIsValueInDefaultLanguage is true, GetText may interpret\n        /// the message keys to be message values in the DefaultLanguage (where\n        /// no explicit message value is defined in the DefaultLanguage) and so\n        /// output the message key.<br/>\n        /// The DefaultLanguage is used in Url Localization Scheme2 for the default URL.<br/>\n        /// Supports a subset of BCP 47 language tag spec corresponding to the Windows\n        /// support for language names, namely the following subtags:\n        ///     language (mandatory, 2 alphachars)\n        ///     script   (optional, 4 alphachars)\n        ///     region   (optional, 2 alphachars | 3 decdigits)\n        /// Example tags supported:\n        ///     \"en\"            [language]\n        ///     \"en-US\"         [language + region]\n        ///     \"zh\"            [language]\n        ///     \"zh-HK\"         [language + region]\n        ///     \"zh-123\"        [language + region]\n        ///     \"zh-Hant\"       [language + script]\n        ///     \"zh-Hant-HK\"    [language + script + region]\n        ///     \"zh-Hant-HK-x-ABCD\"    [language + script + region + private use]\n        /// </remarks>\n        public string DefaultLanguage\n        {\n            get\n            {\n                return DefaultLanguageTag.ToString();\n            }\n            set\n            {\n                LanguageTag defaultLanguageTag = LanguageTag.GetCachedInstance(value);\n                if (defaultLanguageTag != null) {\n                    DefaultLanguageTag = defaultLanguageTag; }\n            }\n        }\n        public LanguageTag DefaultLanguageTag { get; private set; }\n\n        /// <summary>\n        /// Specifies whether the key for a message may be assumed to be the value for\n        /// the message in the default language. Defaults to true.\n        /// </summary>\n        /// <remarks>\n        /// When true, the i18n GetText method will take it that a translation exists\n        /// for all messages in the default language, even though in reality a translation\n        /// is not present for the message in the default language's PO file.<br/>\n        /// When false, an explicit translation is required in the default language. Typically\n        /// this can be useful where keys are not strings to be output but rather codes or mnemonics\n        /// of some kind.\n        /// </remarks>\n        public bool MessageKeyIsValueInDefaultLanguage { get; set; }\n\n        /// <summary>\n        /// The ASP.NET application's virtual application root path on the server,\n        /// used by Url Localization.\n        /// </summary>\n        /// <remarks>\n        /// This is set by the ctor automatically to the ApplicationPath of\n        /// HttpContext.Current, when available. Should that not be available\n        /// then the value defaults to \"/\".<br/>\n        /// In situations where the application is configured to run under a virtual folder\n        /// and you init this class in such a way that HttpContext.Current is not\n        /// available, it will be necessary to set this correctly manually to the application\n        /// root path.<br/>\n        /// E.g. if the application root url is \"example.com/MySite\",\n        /// set this to \"/MySite\". It is important that the string starts with a forward slash path separator\n        /// and does NOT end with a forward slash.\n        /// </remarks>\n        public string ApplicationPath { get; set; }\n\n        /// <summary>\n        /// The name for the i18n cookie. Defaults to \"i18n.langtag\".\n        /// </summary>\n        public string CookieName { get; set; }\n\n        /// <summary>\n        /// Declares a method type for handling the setting of the language.\n        /// </summary>\n        /// <param name=\"context\">Current http context.</param>\n        /// <param name=\"langtag\">Language being set.</param>\n        public delegate void SetLanguageHandler(System.Web.HttpContextBase context, ILanguageTag langtag);\n\n        /// <summary>\n        /// Describes one or more procedures to be called when the principal application\n        /// language (PAL) is set for an HTTP request.\n        /// </summary>\n        /// <remarks>\n        /// A default handlers is installed which applies the PAL setting to both the\n        /// CurrentCulture and CurrentUICulture settings of the current thread.\n        /// This behaviour can be altered by removing (nulling) the value of this property\n        /// or replacing with a new delegate.\n        /// </remarks>\n        public SetLanguageHandler SetPrincipalAppLanguageForRequestHandlers { get; set; }\n\n        /// <summary>\n        /// Declares a method type for a custom method called after a nugget has been translated\n        /// that allows the resulting message to be modified.\n        /// </summary>\n        /// <remarks>\n        /// In general it is good practice to postpone the escaping of characters until they\n        /// are about to be displayed and then according to the content type of the output.\n        /// Thus, a single quote character need not be escaped if in JSON, but should be escaped\n        /// if in HTML or Javascript.\n        /// This method allows for such conditional modification of the message.\n        /// </remarks>\n        /// <param name=\"context\">Current http context.</param>\n        /// <param name=\"nugget\">The subject nugget being translated.</param>\n        /// <param name=\"langtag\">Language being set.</param>\n        /// <param name=\"message\">The message string which may be modified.</param>\n        /// <returns>\n        /// Modified message string (or message if no modification).\n        /// </returns>\n        public delegate string TweakMessageTranslationProc(System.Web.HttpContextBase context, Nugget nugget, LanguageTag langtag, string message);\n\n        /// <summary>\n        /// Registers a custom method called after a nugget has been translated\n        /// that allows the resulting message to be modified.\n        /// </summary>\n        /// <remarks>\n        /// In general it is good practice to postpone the escaping of characters until they\n        /// are about to be displayed and then according to the content type of the output.\n        /// This, a single quote character need not be escaped if in JSON, but should be escaped\n        /// if in HTML or Javascript.\n        /// This method allows for such conditional modification of the message.\n        /// </remarks>\n        public TweakMessageTranslationProc TweakMessageTranslation { get; set; }\n\n        /// <summary>\n        /// Specifies the type of HTTP redirect to be issued by automatic language routing:\n        /// true for 301 (permanent) redirects; false for 302 (temporary) ones.\n        /// Defaults to false.\n        /// </summary>\n        public bool PermanentRedirects { get; set; }\n\n        /// <summary>\n        /// Regular expression that controls the ContextTypes elligible for response localization.\n        /// </summary>\n        /// <remarks>\n        /// Set to null to disable Late URL Localization.<br/>\n        /// Defaults to @\"^(?:(?:(?:text|application)/(?:plain|html|xml|javascript|x-javascript|json|x-json))(?:\\s*;.*)?)$.<br/>\n        /// Client may customise this member, for instance in Application_Start.<br/>\n        /// This feature requires the LocalizedModule HTTP module to be intalled in web.config.<br/>\n        /// Explanation of the default regex:<br/>\n        ///  Content-type string must begin with \"text\" or \"application\"<br/>\n        ///  This must be followed by \"/\"<br/>\n        ///  This must be followed by \"plain\" or \"html\" ...<br/>\n        ///  And finally this may be followed by the following sequence:<br/>\n        ///      zero or more whitespace then \";\" then any number of any chars up to end of string.\n        /// </remarks>\n        public Regex ContentTypesToLocalize = new Regex(@\"^(?:(?:(?:text|application)/(?:plain|html|xml|javascript|x-javascript|json|x-json))(?:\\s*;.*)?)$\");\n\n        /// <summary>\n        /// Regular expression that excludes certain URL paths from being localized.\n        /// </summary>\n        /// <remarks>\n        /// Defaults to excluding all less and css files and any URLs containing the phrases i18nSkip, glimpse, trace or elmah (case-insensitive)<br/>\n        /// Clients may customise this member in Application_Start<br/>\n        /// This feature requires the LocalizedModule HTTP module to be intalled in web.config.<br/>\n        /// </remarks>\n        public Regex UrlsToExcludeFromProcessing = new Regex(@\"(?:\\.(?:less|css)(?:\\?|$))|(?i:i18nSkip|glimpse|trace|elmah)\");\n\n        /// <summary>\n        /// Comma separated value string that lists the async postback types that should be localized.\n        /// </summary>\n        /// <remarks>\n        /// Defaults to \"updatePanel,scriptStartupBlock,pageTitle\"<br/>\n        /// Clients may customise this member in Application_Start.<br/>\n        /// </remarks>\n        public string AsyncPostbackTypesToTranslate = \"updatePanel,scriptStartupBlock,pageTitle\";\n\n        public LocalizedApplication(IRootServices i_RootServices = null)\n        {\n\n            // Default settings.\n            DefaultLanguage = (\"en\");\n            CookieName = \"i18n.langtag\";\n            MessageKeyIsValueInDefaultLanguage = true;\n            PermanentRedirects = false;\n\n            // Attempt to determine ApplicationPath.\n            // NB: if this method being called outside of a request handler, HttpContext.Current\n            // fails. Normally, this results in a null being returned; however it has been observed\n            // that it can also throw.\n            try\n            {\n                var mycontext = System.Web.HttpContext.Current;\n                if (mycontext != null && mycontext.Request.ApplicationPath != null)\n                    ApplicationPath = mycontext.Request.ApplicationPath.TrimEnd('/');\n            }\n            catch (Exception) { }\n            if (String.IsNullOrWhiteSpace(ApplicationPath))\n            {\n                ApplicationPath = \"/\";\n            }\n\n            // Use default package of root services.\n            // Host app may override this.\n            RootServices = i_RootServices ?? new DefaultRootServices();\n\n            // Install default handler for Set-PAL event.\n            // The default handler applies the setting to both the CurrentCulture and CurrentUICulture\n            // settings of the thread.\n            SetPrincipalAppLanguageForRequestHandlers = delegate(System.Web.HttpContextBase context, ILanguageTag langtag)\n            {\n                if (langtag != null)\n                {\n                    Thread.CurrentThread.CurrentCulture = Thread.CurrentThread.CurrentUICulture = langtag.GetCultureInfo();\n                }\n            };\n        }\n\n        private static LocalizedApplication current;\n\n        /// <summary>\n        /// Instance of the this LocalizedApplication class for the current AppDomain.\n        /// </summary>\n        public static LocalizedApplication Current\n        {\n            get { return current ?? (current = new LocalizedApplication()); }\n            set { current = value; }\n        }\n\n        /// <summary>\n        /// Conditionally installs the i18n response filter.\n        /// </summary>\n        /// <param name=\"context\">The HttpContext context.</param>\n        public static void InstallResponseFilter(System.Web.HttpContextBase context)\n        {\n            InstallResponseFilter(context, null);\n        }\n\n        /// <summary>\n        /// Conditionally installs the i18n response filter.\n        /// </summary>\n        /// <param name=\"context\">The HTTP context.</param>\n        /// <param name=\"rootServices\">The root services.</param>\n        public static void InstallResponseFilter(System.Web.HttpContextBase context, IRootServices rootServices)\n        {\n            if (rootServices == null)\n            {\n                rootServices = Current.RootServices;\n            }\n\n            // If the content type of the entity is eligible for processing AND the URL is not to be excluded,\n            // wire up our filter to do the processing. The entity data will be run through the filter a\n            // bit later on in the pipeline.\n            if (Current.ContentTypesToLocalize != null\n                    && Current.ContentTypesToLocalize.Match(context.Response.ContentType).Success) // Include certain content types from being processed\n            {\n                if (Current.UrlsToExcludeFromProcessing != null\n                    && Current.UrlsToExcludeFromProcessing.Match(context.Request.RawUrl).Success) // Exclude certain URLs from being processed\n                {\n                    DebugHelpers.WriteLine(\"InstallResponseFilter -- Bypassing filter, URL excluded: ({0}).\", context.Request.RawUrl);\n                }\n                else if (context.Response.Headers[\"Content-Encoding\"] != null\n                    || context.Response.Headers[\"Content-Encoding\"] == \"gzip\") // Exclude responses that have already been compressed earlier in the pipeline\n                {\n                    DebugHelpers.WriteLine(\"InstallResponseFilter -- Bypassing filter, response compressed.\");\n                }\n                else\n                {\n                    DebugHelpers.WriteLine(\"InstallResponseFilter -- Installing filter\");\n                    context.Response.Filter = new ResponseFilter(\n                        context,\n                        context.Response.Filter,\n                        UrlLocalizer.UrlLocalizationScheme == UrlLocalizationScheme.Void ? null : rootServices.EarlyUrlLocalizerForApp,\n                        rootServices.NuggetLocalizerForApp);\n                }\n            }\n            else\n            {\n                DebugHelpers.WriteLine(\"InstallResponseFilter -- Bypassing filter, No content-type match: ({0}).\", context.Response.ContentType);\n            }\n        }\n\n        /// <summary>\n        /// This object relays its implementaion of IRootServices onto the object set here.\n        /// Host app may override with its own implementation.\n        /// By default, this property is set to an instance of DefaultRootServices.\n        /// </summary>\n        public IRootServices RootServices { get; set; }\n    }\n}\n"], "filenames": ["src/i18n/Concrete/TextLocalizer.cs", "src/i18n/LocalizedApplication.cs"], "buggy_code_start_loc": [128, 121], "buggy_code_end_loc": [128, 125], "fixing_code_start_loc": [129, 121], "fixing_code_end_loc": [132, 127], "type": "NVD-CWE-noinfo", "message": "This affects the package i18n before 2.1.15. Vulnerability arises out of insufficient handling of erroneous language tags in src/i18n/Concrete/TextLocalizer.cs and src/i18n/LocalizedApplication.cs.", "other": {"cve": {"id": "CVE-2020-7791", "sourceIdentifier": "report@snyk.io", "published": "2020-12-11T17:15:13.543", "lastModified": "2022-09-02T15:32:36.457", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects the package i18n before 2.1.15. Vulnerability arises out of insufficient handling of erroneous language tags in src/i18n/Concrete/TextLocalizer.cs and src/i18n/LocalizedApplication.cs."}, {"lang": "es", "value": "Esto afecta al paquete i18n versiones anteriores a 2.1.15.&#xa0;Una vulnerabilidad surge del manejo insuficiente de etiquetas de idioma err\u00f3neas en los archivos src/i18n/Concrete/TextLocalizer.cs y src/i18n/LocalizedApplication.cs"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:i18n_project:i18n:*:*:*:*:*:asp.net:*:*", "versionEndExcluding": "2.1.15", "matchCriteriaId": "315D8CE5-835E-41D7-AFD4-D6D6365CD206"}]}]}], "references": [{"url": "https://github.com/turquoiseowl/i18n/commit/c418e3345313dc896c1951d8c46ab0b9b12fcbd3", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/turquoiseowl/i18n/issues/387", "source": "report@snyk.io", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r1573c58dc283b05f7a40a3f5ff0079b5bbde0492d406ee0fe98d40b6@%3Ccommits.druid.apache.org%3E", "source": "report@snyk.io", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r2667286c8ceffaf893b16829b9612d8f7c4ee6b30362c6c1b583e3c2@%3Ccommits.druid.apache.org%3E", "source": "report@snyk.io", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r33dc233634aedb04fa77db3eb79ea12d15ca4da89fa46a1c585ecb0b@%3Ccommits.druid.apache.org%3E", "source": "report@snyk.io", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r394b1ae54693609a60ea8aab02ff045dc92f593aa3aebff562e69958@%3Ccommits.druid.apache.org%3E", "source": "report@snyk.io", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r5e08837e695efd36be73510ce58ec05785dbcea077819d8acc2d990d@%3Ccommits.druid.apache.org%3E", "source": "report@snyk.io", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r9744574911e7e4edf5f4eeae92a4ccc83e3723cec937950062bb8775@%3Ccommits.druid.apache.org%3E", "source": "report@snyk.io", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/ra5047392edf1fecba441c9adc8807ed6c5f7d2cc71f2f3bb89f35371@%3Ccommits.druid.apache.org%3E", "source": "report@snyk.io", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rc2abba7aa0450198494bbee654fce9b97fad72a4989323e189faede4@%3Cdev.myfaces.apache.org%3E", "source": "report@snyk.io", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rc850d0fce066f9eb9e8553172d9207bad7df4d2059d93abc5c7e85c4@%3Ccommits.druid.apache.org%3E", "source": "report@snyk.io", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-DOTNET-I18N-1050179", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/turquoiseowl/i18n/commit/c418e3345313dc896c1951d8c46ab0b9b12fcbd3"}}