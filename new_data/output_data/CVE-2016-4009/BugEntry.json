{"buggy_code": ["/*\n * The Python Imaging Library\n * $Id$\n *\n * Pillow image resampling support\n *\n * history:\n * 2002-03-09 fl  Created (for PIL 1.1.3)\n * 2002-03-10 fl  Added support for mode \"F\"\n *\n * Copyright (c) 1997-2002 by Secret Labs AB\n *\n * See the README file for information on usage and redistribution.\n */\n\n#include \"Imaging.h\"\n\n#include <math.h>\n\nstruct filter {\n    float (*filter)(float x);\n    float support;\n};\n\nstatic inline float sinc_filter(float x)\n{\n    if (x == 0.0)\n        return 1.0;\n    x = x * M_PI;\n    return sin(x) / x;\n}\n\nstatic inline float lanczos_filter(float x)\n{\n    /* truncated sinc */\n    if (-3.0 <= x && x < 3.0)\n        return sinc_filter(x) * sinc_filter(x/3);\n    return 0.0;\n}\n\nstatic struct filter LANCZOS = { lanczos_filter, 3.0 };\n\nstatic inline float bilinear_filter(float x)\n{\n    if (x < 0.0)\n        x = -x;\n    if (x < 1.0)\n        return 1.0-x;\n    return 0.0;\n}\n\nstatic struct filter BILINEAR = { bilinear_filter, 1.0 };\n\nstatic inline float bicubic_filter(float x)\n{\n    /* http://en.wikipedia.org/wiki/Bicubic_interpolation#Bicubic_convolution_algorithm */\n#define a -0.5\n    if (x < 0.0)\n        x = -x;\n    if (x < 1.0)\n        return ((a + 2.0) * x - (a + 3.0)) * x*x + 1;\n    if (x < 2.0)\n        return (((x - 5) * x + 8) * x - 4) * a;\n    return 0.0;\n#undef a\n}\n\nstatic struct filter BICUBIC = { bicubic_filter, 2.0 };\n\n\nstatic inline UINT8 clip8(float in)\n{\n    int out = (int) in;\n    if (out >= 255)\n       return 255;\n    if (out <= 0)\n        return 0;\n    return (UINT8) out;\n}\n\n\n/* This is work around bug in GCC prior 4.9 in 64-bit mode.\n   GCC generates code with partial dependency which 3 times slower.\n   See: http://stackoverflow.com/a/26588074/253146 */\n#if defined(__x86_64__) && defined(__SSE__) &&  ! defined(__NO_INLINE__) && \\\n    ! defined(__clang__) && defined(GCC_VERSION) && (GCC_VERSION < 40900)\nstatic float __attribute__((always_inline)) i2f(int v) {\n    float x;\n    __asm__(\"xorps %0, %0; cvtsi2ss %1, %0\" : \"=X\"(x) : \"r\"(v) );\n    return x;\n}\n#else\nstatic float inline i2f(int v) { return (float) v; }\n#endif\n\n\nImaging\nImagingResampleHorizontal(Imaging imIn, int xsize, int filter)\n{\n    ImagingSectionCookie cookie;\n    Imaging imOut;\n    struct filter *filterp;\n    float support, scale, filterscale;\n    float center, ww, ss, ss0, ss1, ss2, ss3;\n    int xx, yy, x, kmax, xmin, xmax;\n    int *xbounds;\n    float *k, *kk;\n\n    /* check filter */\n    switch (filter) {\n    case IMAGING_TRANSFORM_LANCZOS:\n        filterp = &LANCZOS;\n        break;\n    case IMAGING_TRANSFORM_BILINEAR:\n        filterp = &BILINEAR;\n        break;\n    case IMAGING_TRANSFORM_BICUBIC:\n        filterp = &BICUBIC;\n        break;\n    default:\n        return (Imaging) ImagingError_ValueError(\n            \"unsupported resampling filter\"\n            );\n    }\n\n    /* prepare for horizontal stretch */\n    filterscale = scale = (float) imIn->xsize / xsize;\n\n    /* determine support size (length of resampling filter) */\n    support = filterp->support;\n\n    if (filterscale < 1.0) {\n        filterscale = 1.0;\n    }\n\n    support = support * filterscale;\n\n    /* maximum number of coofs */\n    kmax = (int) ceil(support) * 2 + 1;\n\n    /* coefficient buffer */\n    kk = malloc(xsize * kmax * sizeof(float));\n    if ( ! kk)\n        return (Imaging) ImagingError_MemoryError();\n\n    xbounds = malloc(xsize * 2 * sizeof(int));\n    if ( ! xbounds) {\n        free(kk);\n        return (Imaging) ImagingError_MemoryError();\n    }\n\n    for (xx = 0; xx < xsize; xx++) {\n        k = &kk[xx * kmax];\n        center = (xx + 0.5) * scale;\n        ww = 0.0;\n        ss = 1.0 / filterscale;\n        xmin = (int) floor(center - support);\n        if (xmin < 0)\n            xmin = 0;\n        xmax = (int) ceil(center + support);\n        if (xmax > imIn->xsize)\n            xmax = imIn->xsize;\n        for (x = xmin; x < xmax; x++) {\n            float w = filterp->filter((x - center + 0.5) * ss) * ss;\n            k[x - xmin] = w;\n            ww += w;\n        }\n        for (x = 0; x < xmax - xmin; x++) {\n            if (ww != 0.0)\n                k[x] /= ww;\n        }\n        xbounds[xx * 2 + 0] = xmin;\n        xbounds[xx * 2 + 1] = xmax;\n    }\n\n    imOut = ImagingNew(imIn->mode, xsize, imIn->ysize);\n    if ( ! imOut) {\n        free(kk);\n        free(xbounds);\n        return NULL;\n    }\n\n    ImagingSectionEnter(&cookie);\n    /* horizontal stretch */\n    for (yy = 0; yy < imOut->ysize; yy++) {\n        if (imIn->image8) {\n            /* 8-bit grayscale */\n            for (xx = 0; xx < xsize; xx++) {\n                xmin = xbounds[xx * 2 + 0];\n                xmax = xbounds[xx * 2 + 1];\n                k = &kk[xx * kmax];\n                ss = 0.5;\n                for (x = xmin; x < xmax; x++)\n                    ss += i2f(imIn->image8[yy][x]) * k[x - xmin];\n                imOut->image8[yy][xx] = clip8(ss);\n            }\n        } else {\n            switch(imIn->type) {\n            case IMAGING_TYPE_UINT8:\n                /* n-bit grayscale */\n                if (imIn->bands == 2) {\n                    for (xx = 0; xx < xsize; xx++) {\n                        xmin = xbounds[xx * 2 + 0];\n                        xmax = xbounds[xx * 2 + 1];\n                        k = &kk[xx * kmax];\n                        ss0 = ss1 = 0.5;\n                        for (x = xmin; x < xmax; x++) {\n                            ss0 += i2f((UINT8) imIn->image[yy][x*4 + 0]) * k[x - xmin];\n                            ss1 += i2f((UINT8) imIn->image[yy][x*4 + 3]) * k[x - xmin];\n                        }\n                        imOut->image[yy][xx*4 + 0] = clip8(ss0);\n                        imOut->image[yy][xx*4 + 3] = clip8(ss1);\n                    }\n                } else if (imIn->bands == 3) {\n                    for (xx = 0; xx < xsize; xx++) {\n                        xmin = xbounds[xx * 2 + 0];\n                        xmax = xbounds[xx * 2 + 1];\n                        k = &kk[xx * kmax];\n                        ss0 = ss1 = ss2 = 0.5;\n                        for (x = xmin; x < xmax; x++) {\n                            ss0 += i2f((UINT8) imIn->image[yy][x*4 + 0]) * k[x - xmin];\n                            ss1 += i2f((UINT8) imIn->image[yy][x*4 + 1]) * k[x - xmin];\n                            ss2 += i2f((UINT8) imIn->image[yy][x*4 + 2]) * k[x - xmin];\n                        }\n                        imOut->image[yy][xx*4 + 0] = clip8(ss0);\n                        imOut->image[yy][xx*4 + 1] = clip8(ss1);\n                        imOut->image[yy][xx*4 + 2] = clip8(ss2);\n                    }\n                } else {\n                    for (xx = 0; xx < xsize; xx++) {\n                        xmin = xbounds[xx * 2 + 0];\n                        xmax = xbounds[xx * 2 + 1];\n                        k = &kk[xx * kmax];\n                        ss0 = ss1 = ss2 = ss3 = 0.5;\n                        for (x = xmin; x < xmax; x++) {\n                            ss0 += i2f((UINT8) imIn->image[yy][x*4 + 0]) * k[x - xmin];\n                            ss1 += i2f((UINT8) imIn->image[yy][x*4 + 1]) * k[x - xmin];\n                            ss2 += i2f((UINT8) imIn->image[yy][x*4 + 2]) * k[x - xmin];\n                            ss3 += i2f((UINT8) imIn->image[yy][x*4 + 3]) * k[x - xmin];\n                        }\n                        imOut->image[yy][xx*4 + 0] = clip8(ss0);\n                        imOut->image[yy][xx*4 + 1] = clip8(ss1);\n                        imOut->image[yy][xx*4 + 2] = clip8(ss2);\n                        imOut->image[yy][xx*4 + 3] = clip8(ss3);\n                    }\n                }\n                break;\n            case IMAGING_TYPE_INT32:\n                /* 32-bit integer */\n                for (xx = 0; xx < xsize; xx++) {\n                    xmin = xbounds[xx * 2 + 0];\n                    xmax = xbounds[xx * 2 + 1];\n                    k = &kk[xx * kmax];\n                    ss = 0.0;\n                    for (x = xmin; x < xmax; x++)\n                        ss += i2f(IMAGING_PIXEL_I(imIn, x, yy)) * k[x - xmin];\n                    IMAGING_PIXEL_I(imOut, xx, yy) = (int) ss;\n                }\n                break;\n            case IMAGING_TYPE_FLOAT32:\n                /* 32-bit float */\n                for (xx = 0; xx < xsize; xx++) {\n                    xmin = xbounds[xx * 2 + 0];\n                    xmax = xbounds[xx * 2 + 1];\n                    k = &kk[xx * kmax];\n                    ss = 0.0;\n                    for (x = xmin; x < xmax; x++)\n                        ss += IMAGING_PIXEL_F(imIn, x, yy) * k[x - xmin];\n                    IMAGING_PIXEL_F(imOut, xx, yy) = ss;\n                }\n                break;\n            }\n        }\n    }\n    ImagingSectionLeave(&cookie);\n    free(kk);\n    free(xbounds);\n    return imOut;\n}\n\n\nImaging\nImagingResample(Imaging imIn, int xsize, int ysize, int filter)\n{\n    Imaging imTemp1, imTemp2, imTemp3;\n    Imaging imOut;\n\n    if (strcmp(imIn->mode, \"P\") == 0 || strcmp(imIn->mode, \"1\") == 0)\n        return (Imaging) ImagingError_ModeError();\n\n    if (imIn->type == IMAGING_TYPE_SPECIAL)\n        return (Imaging) ImagingError_ModeError();\n\n    /* two-pass resize, first pass */\n    imTemp1 = ImagingResampleHorizontal(imIn, xsize, filter);\n    if ( ! imTemp1)\n        return NULL;\n\n    /* transpose image once */\n    imTemp2 = ImagingTransposeToNew(imTemp1);\n    ImagingDelete(imTemp1);\n    if ( ! imTemp2)\n        return NULL;\n\n    /* second pass */\n    imTemp3 = ImagingResampleHorizontal(imTemp2, ysize, filter);\n    ImagingDelete(imTemp2);\n    if ( ! imTemp3)\n        return NULL;\n\n    /* transpose result */\n    imOut = ImagingTransposeToNew(imTemp3);\n    ImagingDelete(imTemp3);\n    if ( ! imOut)\n        return NULL;\n\n    return imOut;\n}\n"], "fixing_code": ["/*\n * The Python Imaging Library\n * $Id$\n *\n * Pillow image resampling support\n *\n * history:\n * 2002-03-09 fl  Created (for PIL 1.1.3)\n * 2002-03-10 fl  Added support for mode \"F\"\n *\n * Copyright (c) 1997-2002 by Secret Labs AB\n *\n * See the README file for information on usage and redistribution.\n */\n\n#include \"Imaging.h\"\n\n#include <math.h>\n\nstruct filter {\n    float (*filter)(float x);\n    float support;\n};\n\nstatic inline float sinc_filter(float x)\n{\n    if (x == 0.0)\n        return 1.0;\n    x = x * M_PI;\n    return sin(x) / x;\n}\n\nstatic inline float lanczos_filter(float x)\n{\n    /* truncated sinc */\n    if (-3.0 <= x && x < 3.0)\n        return sinc_filter(x) * sinc_filter(x/3);\n    return 0.0;\n}\n\nstatic struct filter LANCZOS = { lanczos_filter, 3.0 };\n\nstatic inline float bilinear_filter(float x)\n{\n    if (x < 0.0)\n        x = -x;\n    if (x < 1.0)\n        return 1.0-x;\n    return 0.0;\n}\n\nstatic struct filter BILINEAR = { bilinear_filter, 1.0 };\n\nstatic inline float bicubic_filter(float x)\n{\n    /* http://en.wikipedia.org/wiki/Bicubic_interpolation#Bicubic_convolution_algorithm */\n#define a -0.5\n    if (x < 0.0)\n        x = -x;\n    if (x < 1.0)\n        return ((a + 2.0) * x - (a + 3.0)) * x*x + 1;\n    if (x < 2.0)\n        return (((x - 5) * x + 8) * x - 4) * a;\n    return 0.0;\n#undef a\n}\n\nstatic struct filter BICUBIC = { bicubic_filter, 2.0 };\n\n\nstatic inline UINT8 clip8(float in)\n{\n    int out = (int) in;\n    if (out >= 255)\n       return 255;\n    if (out <= 0)\n        return 0;\n    return (UINT8) out;\n}\n\n\n/* This is work around bug in GCC prior 4.9 in 64-bit mode.\n   GCC generates code with partial dependency which 3 times slower.\n   See: http://stackoverflow.com/a/26588074/253146 */\n#if defined(__x86_64__) && defined(__SSE__) &&  ! defined(__NO_INLINE__) && \\\n    ! defined(__clang__) && defined(GCC_VERSION) && (GCC_VERSION < 40900)\nstatic float __attribute__((always_inline)) i2f(int v) {\n    float x;\n    __asm__(\"xorps %0, %0; cvtsi2ss %1, %0\" : \"=X\"(x) : \"r\"(v) );\n    return x;\n}\n#else\nstatic float inline i2f(int v) { return (float) v; }\n#endif\n\n\nImaging\nImagingResampleHorizontal(Imaging imIn, int xsize, int filter)\n{\n    ImagingSectionCookie cookie;\n    Imaging imOut;\n    struct filter *filterp;\n    float support, scale, filterscale;\n    float center, ww, ss, ss0, ss1, ss2, ss3;\n    int xx, yy, x, kmax, xmin, xmax;\n    int *xbounds;\n    float *k, *kk;\n\n    /* check filter */\n    switch (filter) {\n    case IMAGING_TRANSFORM_LANCZOS:\n        filterp = &LANCZOS;\n        break;\n    case IMAGING_TRANSFORM_BILINEAR:\n        filterp = &BILINEAR;\n        break;\n    case IMAGING_TRANSFORM_BICUBIC:\n        filterp = &BICUBIC;\n        break;\n    default:\n        return (Imaging) ImagingError_ValueError(\n            \"unsupported resampling filter\"\n            );\n    }\n\n    /* prepare for horizontal stretch */\n    filterscale = scale = (float) imIn->xsize / xsize;\n\n    /* determine support size (length of resampling filter) */\n    support = filterp->support;\n\n    if (filterscale < 1.0) {\n        filterscale = 1.0;\n    }\n\n    support = support * filterscale;\n\n    /* maximum number of coofs */\n    kmax = (int) ceil(support) * 2 + 1;\n\n    // check for overflow\n    if (kmax > 0 && xsize > SIZE_MAX / kmax)\n        return (Imaging) ImagingError_MemoryError();\n\n    // sizeof(float) should be greater than 0\n    if (xsize * kmax > SIZE_MAX / sizeof(float))\n        return (Imaging) ImagingError_MemoryError();\n\n    /* coefficient buffer */\n    kk = malloc(xsize * kmax * sizeof(float));\n    if ( ! kk)\n        return (Imaging) ImagingError_MemoryError();\n\n    // sizeof(int) should be greater than 0 as well\n    if (xsize > SIZE_MAX / (2 * sizeof(int)))\n        return (Imaging) ImagingError_MemoryError();\n\n    xbounds = malloc(xsize * 2 * sizeof(int));\n    if ( ! xbounds) {\n        free(kk);\n        return (Imaging) ImagingError_MemoryError();\n    }\n\n    for (xx = 0; xx < xsize; xx++) {\n        k = &kk[xx * kmax];\n        center = (xx + 0.5) * scale;\n        ww = 0.0;\n        ss = 1.0 / filterscale;\n        xmin = (int) floor(center - support);\n        if (xmin < 0)\n            xmin = 0;\n        xmax = (int) ceil(center + support);\n        if (xmax > imIn->xsize)\n            xmax = imIn->xsize;\n        for (x = xmin; x < xmax; x++) {\n            float w = filterp->filter((x - center + 0.5) * ss) * ss;\n            k[x - xmin] = w;\n            ww += w;\n        }\n        for (x = 0; x < xmax - xmin; x++) {\n            if (ww != 0.0)\n                k[x] /= ww;\n        }\n        xbounds[xx * 2 + 0] = xmin;\n        xbounds[xx * 2 + 1] = xmax;\n    }\n\n    imOut = ImagingNew(imIn->mode, xsize, imIn->ysize);\n    if ( ! imOut) {\n        free(kk);\n        free(xbounds);\n        return NULL;\n    }\n\n    ImagingSectionEnter(&cookie);\n    /* horizontal stretch */\n    for (yy = 0; yy < imOut->ysize; yy++) {\n        if (imIn->image8) {\n            /* 8-bit grayscale */\n            for (xx = 0; xx < xsize; xx++) {\n                xmin = xbounds[xx * 2 + 0];\n                xmax = xbounds[xx * 2 + 1];\n                k = &kk[xx * kmax];\n                ss = 0.5;\n                for (x = xmin; x < xmax; x++)\n                    ss += i2f(imIn->image8[yy][x]) * k[x - xmin];\n                imOut->image8[yy][xx] = clip8(ss);\n            }\n        } else {\n            switch(imIn->type) {\n            case IMAGING_TYPE_UINT8:\n                /* n-bit grayscale */\n                if (imIn->bands == 2) {\n                    for (xx = 0; xx < xsize; xx++) {\n                        xmin = xbounds[xx * 2 + 0];\n                        xmax = xbounds[xx * 2 + 1];\n                        k = &kk[xx * kmax];\n                        ss0 = ss1 = 0.5;\n                        for (x = xmin; x < xmax; x++) {\n                            ss0 += i2f((UINT8) imIn->image[yy][x*4 + 0]) * k[x - xmin];\n                            ss1 += i2f((UINT8) imIn->image[yy][x*4 + 3]) * k[x - xmin];\n                        }\n                        imOut->image[yy][xx*4 + 0] = clip8(ss0);\n                        imOut->image[yy][xx*4 + 3] = clip8(ss1);\n                    }\n                } else if (imIn->bands == 3) {\n                    for (xx = 0; xx < xsize; xx++) {\n                        xmin = xbounds[xx * 2 + 0];\n                        xmax = xbounds[xx * 2 + 1];\n                        k = &kk[xx * kmax];\n                        ss0 = ss1 = ss2 = 0.5;\n                        for (x = xmin; x < xmax; x++) {\n                            ss0 += i2f((UINT8) imIn->image[yy][x*4 + 0]) * k[x - xmin];\n                            ss1 += i2f((UINT8) imIn->image[yy][x*4 + 1]) * k[x - xmin];\n                            ss2 += i2f((UINT8) imIn->image[yy][x*4 + 2]) * k[x - xmin];\n                        }\n                        imOut->image[yy][xx*4 + 0] = clip8(ss0);\n                        imOut->image[yy][xx*4 + 1] = clip8(ss1);\n                        imOut->image[yy][xx*4 + 2] = clip8(ss2);\n                    }\n                } else {\n                    for (xx = 0; xx < xsize; xx++) {\n                        xmin = xbounds[xx * 2 + 0];\n                        xmax = xbounds[xx * 2 + 1];\n                        k = &kk[xx * kmax];\n                        ss0 = ss1 = ss2 = ss3 = 0.5;\n                        for (x = xmin; x < xmax; x++) {\n                            ss0 += i2f((UINT8) imIn->image[yy][x*4 + 0]) * k[x - xmin];\n                            ss1 += i2f((UINT8) imIn->image[yy][x*4 + 1]) * k[x - xmin];\n                            ss2 += i2f((UINT8) imIn->image[yy][x*4 + 2]) * k[x - xmin];\n                            ss3 += i2f((UINT8) imIn->image[yy][x*4 + 3]) * k[x - xmin];\n                        }\n                        imOut->image[yy][xx*4 + 0] = clip8(ss0);\n                        imOut->image[yy][xx*4 + 1] = clip8(ss1);\n                        imOut->image[yy][xx*4 + 2] = clip8(ss2);\n                        imOut->image[yy][xx*4 + 3] = clip8(ss3);\n                    }\n                }\n                break;\n            case IMAGING_TYPE_INT32:\n                /* 32-bit integer */\n                for (xx = 0; xx < xsize; xx++) {\n                    xmin = xbounds[xx * 2 + 0];\n                    xmax = xbounds[xx * 2 + 1];\n                    k = &kk[xx * kmax];\n                    ss = 0.0;\n                    for (x = xmin; x < xmax; x++)\n                        ss += i2f(IMAGING_PIXEL_I(imIn, x, yy)) * k[x - xmin];\n                    IMAGING_PIXEL_I(imOut, xx, yy) = (int) ss;\n                }\n                break;\n            case IMAGING_TYPE_FLOAT32:\n                /* 32-bit float */\n                for (xx = 0; xx < xsize; xx++) {\n                    xmin = xbounds[xx * 2 + 0];\n                    xmax = xbounds[xx * 2 + 1];\n                    k = &kk[xx * kmax];\n                    ss = 0.0;\n                    for (x = xmin; x < xmax; x++)\n                        ss += IMAGING_PIXEL_F(imIn, x, yy) * k[x - xmin];\n                    IMAGING_PIXEL_F(imOut, xx, yy) = ss;\n                }\n                break;\n            }\n        }\n    }\n    ImagingSectionLeave(&cookie);\n    free(kk);\n    free(xbounds);\n    return imOut;\n}\n\n\nImaging\nImagingResample(Imaging imIn, int xsize, int ysize, int filter)\n{\n    Imaging imTemp1, imTemp2, imTemp3;\n    Imaging imOut;\n\n    if (strcmp(imIn->mode, \"P\") == 0 || strcmp(imIn->mode, \"1\") == 0)\n        return (Imaging) ImagingError_ModeError();\n\n    if (imIn->type == IMAGING_TYPE_SPECIAL)\n        return (Imaging) ImagingError_ModeError();\n\n    /* two-pass resize, first pass */\n    imTemp1 = ImagingResampleHorizontal(imIn, xsize, filter);\n    if ( ! imTemp1)\n        return NULL;\n\n    /* transpose image once */\n    imTemp2 = ImagingTransposeToNew(imTemp1);\n    ImagingDelete(imTemp1);\n    if ( ! imTemp2)\n        return NULL;\n\n    /* second pass */\n    imTemp3 = ImagingResampleHorizontal(imTemp2, ysize, filter);\n    ImagingDelete(imTemp2);\n    if ( ! imTemp3)\n        return NULL;\n\n    /* transpose result */\n    imOut = ImagingTransposeToNew(imTemp3);\n    ImagingDelete(imTemp3);\n    if ( ! imOut)\n        return NULL;\n\n    return imOut;\n}\n"], "filenames": ["libImaging/Resample.c"], "buggy_code_start_loc": [140], "buggy_code_end_loc": [143], "fixing_code_start_loc": [141], "fixing_code_end_loc": [156], "type": "CWE-119", "message": "Integer overflow in the ImagingResampleHorizontal function in libImaging/Resample.c in Pillow before 3.1.1 allows remote attackers to have unspecified impact via negative values of the new size, which triggers a heap-based buffer overflow.", "other": {"cve": {"id": "CVE-2016-4009", "sourceIdentifier": "cve@mitre.org", "published": "2016-04-13T16:59:25.353", "lastModified": "2017-07-01T01:29:44.843", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Integer overflow in the ImagingResampleHorizontal function in libImaging/Resample.c in Pillow before 3.1.1 allows remote attackers to have unspecified impact via negative values of the new size, which triggers a heap-based buffer overflow."}, {"lang": "es", "value": "Desbordamiento de entero en la funci\u00f3n ImagengResampleHorizontal en libImaging/Resample.c en Pillow en versiones anteriores a 3.1.1 permite a atacantes remotos tener un impacto no especificado a trav\u00e9s de valores negativos del tama\u00f1o nuevo, lo que desencadena un desbordamiento de buffer basado en memoria din\u00e1mica."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 10.0}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 10.0, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:python:pillow:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.1.0", "matchCriteriaId": "2F573E4A-55AB-4868-8CA1-7C7E5EEAC905"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/86064", "source": "cve@mitre.org"}, {"url": "https://github.com/python-pillow/Pillow/blob/c3cb690fed5d4bf0c45576759de55d054916c165/CHANGES.rst", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/python-pillow/Pillow/commit/4e0d9b0b9740d258ade40cce248c93777362ac1e", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/python-pillow/Pillow/pull/1714", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://security.gentoo.org/glsa/201612-52", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/python-pillow/Pillow/commit/4e0d9b0b9740d258ade40cce248c93777362ac1e"}}