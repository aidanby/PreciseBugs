{"buggy_code": ["package server\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"runtime/debug\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/Azure/go-autorest/autorest/adal\"\n\t\"github.com/gorilla/mux\"\n\t\"k8s.io/klog/v2\"\n\n\t\"github.com/Azure/aad-pod-identity/pkg/auth\"\n\t\"github.com/Azure/aad-pod-identity/pkg/k8s\"\n\t\"github.com/Azure/aad-pod-identity/pkg/metrics\"\n\t\"github.com/Azure/aad-pod-identity/pkg/nmi\"\n\t\"github.com/Azure/aad-pod-identity/pkg/nmi/conntrack\"\n\t\"github.com/Azure/aad-pod-identity/pkg/nmi/iptables\"\n\t\"github.com/Azure/aad-pod-identity/pkg/pod\"\n)\n\nconst (\n\tlocalhost = \"127.0.0.1\"\n\t// \"/metadata\" portion is case-insensitive in IMDS\n\ttokenPathPrefix     = \"/{type:(?i:metadata)}/identity/oauth2/token\" // #nosec\n\thostTokenPathPrefix = \"/host/token\"\n\t// \"/metadata\" portion is case-insensitive in IMDS\n\tinstancePathPrefix = \"/{type:(?i:metadata)}/instance\" // #nosec\n\theaderRetryAfter   = \"Retry-After\"\n)\n\n// Server encapsulates all of the parameters necessary for starting up\n// the server. These can be set via command line.\ntype Server struct {\n\tKubeClient                         k8s.Client\n\tNMIHost                            string\n\tNMIPort                            string\n\tMetadataIP                         string\n\tMetadataPort                       string\n\tNodeName                           string\n\tIPTableUpdateTimeIntervalInSeconds int\n\tMICNamespace                       string\n\tInitialized                        bool\n\tBlockInstanceMetadata              bool\n\tMetadataHeaderRequired             bool\n\tSetRetryAfterHeader                bool\n\tEnableConntrackDeletion            bool\n\t// TokenClient is client that fetches identities and tokens\n\tTokenClient nmi.TokenClient\n\tReporter    *metrics.Reporter\n}\n\n// NMIResponse is the response returned to caller\ntype NMIResponse struct {\n\tToken    msiResponse `json:\"token\"`\n\tClientID string      `json:\"clientid\"`\n}\n\n// MetadataResponse represents the error returned\n// to caller when metadata header is not specified.\ntype MetadataResponse struct {\n\tError            string `json:\"error\"`\n\tErrorDescription string `json:\"error_description\"`\n}\n\n// NewServer will create a new Server with default values.\nfunc NewServer(micNamespace string, blockInstanceMetadata, metadataHeaderRequired, setRetryAfterHeader bool) *Server {\n\treporter, err := metrics.NewReporter()\n\tif err != nil {\n\t\tklog.Errorf(\"failed to create reporter for metrics, error: %+v\", err)\n\t} else {\n\t\t// keeping this reference to be used in ServeHTTP, as server is not accessible in ServeHTTP\n\t\tappHandlerReporter = reporter\n\t\tauth.InitReporter(reporter)\n\t}\n\treturn &Server{\n\t\tMICNamespace:           micNamespace,\n\t\tBlockInstanceMetadata:  blockInstanceMetadata,\n\t\tMetadataHeaderRequired: metadataHeaderRequired,\n\t\tReporter:               reporter,\n\t\tSetRetryAfterHeader:    setRetryAfterHeader,\n\t}\n}\n\n// Run runs the specified Server.\nfunc (s *Server) Run() error {\n\tgo s.updateIPTableRules()\n\n\trtr := mux.NewRouter()\n\trtr.PathPrefix(tokenPathPrefix).Handler(appHandler(s.msiHandler))\n\trtr.PathPrefix(hostTokenPathPrefix).Handler(appHandler(s.hostHandler))\n\tif s.BlockInstanceMetadata {\n\t\trtr.PathPrefix(instancePathPrefix).HandlerFunc(forbiddenHandler)\n\t}\n\trtr.PathPrefix(\"/\").HandlerFunc(s.defaultPathHandler)\n\n\tklog.Infof(\"listening on %s:%s\", s.NMIHost, s.NMIPort)\n\tif err := http.ListenAndServe(fmt.Sprintf(\"%s:%s\", s.NMIHost, s.NMIPort), rtr); err != nil {\n\t\tklog.Fatalf(\"error creating http server: %+v\", err)\n\t}\n\treturn nil\n}\n\nfunc (s *Server) updateIPTableRulesInternal() {\n\ttarget := s.NMIHost\n\tif target == \"0.0.0.0\" {\n\t\t// if we're binding to all interfaces, we still want to add iptables rules for localhost only\n\t\ttarget = localhost\n\t}\n\n\tklog.V(5).Infof(\"node(%s) ip(%s) metadata address(%s:%s) nmi port(%s)\", s.NodeName, target, s.MetadataIP, s.MetadataPort, s.NMIPort)\n\n\tif err := iptables.AddCustomChain(s.MetadataIP, s.MetadataPort, target, s.NMIPort); err != nil {\n\t\tklog.Fatalf(\"%s\", err)\n\t}\n\tif err := iptables.LogCustomChain(); err != nil {\n\t\tklog.Fatalf(\"%s\", err)\n\t}\n}\n\n// try to delete pre-existing conntrack entries for metadata endpoint\nfunc (s *Server) deleteConntrackEntries() {\n\tklog.Infof(\"deleting conntrack entries for %s:%s\", s.MetadataIP, s.MetadataPort)\n\n\tif err := conntrack.DeleteConntrackEntries(s.MetadataIP, s.MetadataPort); err != nil {\n\t\tklog.Fatalf(\"failed to delete conntrack entries for metadata ip: %s\", err)\n\t}\n}\n\n// updateIPTableRules ensures the correct iptable rules are set\n// such that metadata requests are received by nmi assigned port\n// NOT originating from HostIP destined to metadata endpoint are\n// routed to NMI endpoint\nfunc (s *Server) updateIPTableRules() {\n\tsignalChan := make(chan os.Signal, 1)\n\tsignal.Notify(signalChan, syscall.SIGTERM, syscall.SIGINT)\n\n\tticker := time.NewTicker(time.Second * time.Duration(s.IPTableUpdateTimeIntervalInSeconds))\n\tdefer ticker.Stop()\n\t// Run once before the waiting on ticker for the rules to take effect\n\t// immediately.\n\ts.updateIPTableRulesInternal()\n\t// delete conntrack entries for pre-existing connections to metadata endpoint\n\tif s.EnableConntrackDeletion {\n\t\ts.deleteConntrackEntries()\n\t}\n\ts.Initialized = true\n\nloop:\n\tfor {\n\t\tselect {\n\t\tcase <-signalChan:\n\t\t\thandleTermination()\n\t\t\tbreak loop\n\n\t\tcase <-ticker.C:\n\t\t\ts.updateIPTableRulesInternal()\n\t\t}\n\t}\n}\n\ntype appHandler func(http.ResponseWriter, *http.Request) string\n\ntype responseWriter struct {\n\thttp.ResponseWriter\n\tstatusCode int\n}\n\nfunc (rw *responseWriter) WriteHeader(code int) {\n\trw.statusCode = code\n\trw.ResponseWriter.WriteHeader(code)\n}\n\nfunc newResponseWriter(w http.ResponseWriter) *responseWriter {\n\treturn &responseWriter{w, http.StatusOK}\n}\n\nvar appHandlerReporter *metrics.Reporter\n\n// ServeHTTP implements the net/http server handler interface\n// and recovers from panics.\nfunc (fn appHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\ttracker := fmt.Sprintf(\"req.method=%s reg.path=%s req.remote=%s\", r.Method, r.URL.Path, parseRemoteAddr(r.RemoteAddr))\n\n\t// Set the header in advance so that both success as well\n\t// as error paths have it set as application/json content type.\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tstart := time.Now()\n\tdefer func() {\n\t\tvar err error\n\t\tif rec := recover(); rec != nil {\n\t\t\t_, file, line, _ := runtime.Caller(3)\n\t\t\tstack := string(debug.Stack())\n\t\t\tswitch t := rec.(type) {\n\t\t\tcase string:\n\t\t\t\terr = errors.New(t)\n\t\t\tcase error:\n\t\t\t\terr = t\n\t\t\tdefault:\n\t\t\t\terr = errors.New(\"unknown error\")\n\t\t\t}\n\t\t\tklog.Errorf(\"panic processing request: %+v, file: %s, line: %d, stacktrace: '%s' %s res.status=%d\", r, file, line, stack, tracker, http.StatusInternalServerError)\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t}\n\t}()\n\trw := newResponseWriter(w)\n\tns := fn(rw, r)\n\tlatency := time.Since(start)\n\tklog.Infof(\"status (%d) took %d ns for %s\", rw.statusCode, latency.Nanoseconds(), tracker)\n\n\ttokenRequest := parseTokenRequest(r)\n\n\tif appHandlerReporter != nil {\n\t\terr := appHandlerReporter.ReportOperationAndStatus(\n\t\t\tr.URL.Path,\n\t\t\tstrconv.Itoa(rw.statusCode),\n\t\t\tns,\n\t\t\ttokenRequest.Resource,\n\t\t\tmetrics.NMIOperationsDurationM.M(metrics.SinceInSeconds(start)))\n\t\tif err != nil {\n\t\t\tklog.Warningf(\"failed to report metrics, error: %+v\", err)\n\t\t}\n\t}\n}\n\nfunc (s *Server) hostHandler(w http.ResponseWriter, r *http.Request) (ns string) {\n\thostIP := parseRemoteAddr(r.RemoteAddr)\n\ttokenRequest := parseTokenRequest(r)\n\n\tpodns, podname := parsePodInfo(r)\n\tif podns == \"\" || podname == \"\" {\n\t\tklog.Error(\"missing podname and podns from request\")\n\t\thttp.Error(w, \"missing 'podname' and 'podns' from request header\", http.StatusBadRequest)\n\t\treturn\n\t}\n\t// set the ns so it can be used for metrics\n\tns = podns\n\tif hostIP != localhost {\n\t\tklog.Errorf(\"request remote address is not from a host\")\n\t\thttp.Error(w, \"request remote address is not from a host\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tif !tokenRequest.ValidateResourceParamExists() {\n\t\tklog.Warning(\"parameter resource cannot be empty\")\n\t\thttp.Error(w, \"parameter resource cannot be empty\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tpodID, err := s.TokenClient.GetIdentities(r.Context(), podns, podname, tokenRequest.ClientID, tokenRequest.ResourceID)\n\tif err != nil {\n\t\tklog.Errorf(\"failed to get identities, error: %+v\", err)\n\t\thttp.Error(w, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\ttokens, err := s.TokenClient.GetTokens(r.Context(), tokenRequest.ClientID, tokenRequest.Resource, *podID)\n\tif err != nil {\n\t\tklog.Errorf(\"failed to get service principal token for pod:%s/%s, error: %+v\", podns, podname, err)\n\t\thttpErrorCode := http.StatusForbidden\n\t\tif auth.IsHealthCheckError(err) {\n\t\t\t// the adal library performs a health check prior to making the token request\n\t\t\t// if the health check fails, we want to return a 503 instead of 403\n\t\t\t// for health check failures, the error is not a token refresh error\n\t\t\thttpErrorCode = http.StatusServiceUnavailable\n\t\t}\n\t\thttp.Error(w, err.Error(), httpErrorCode)\n\t\treturn\n\t}\n\tnmiResp := NMIResponse{\n\t\tToken:    newMSIResponse(*tokens[0]),\n\t\tClientID: podID.Spec.ClientID,\n\t}\n\tresponse, err := json.Marshal(nmiResp)\n\tif err != nil {\n\t\tklog.Errorf(\"failed to marshal service principal token and clientid for pod:%s/%s, error: %+v\", podns, podname, err)\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tw.Header().Set(\"Content-Length\", strconv.Itoa(len(response)))\n\t_, _ = w.Write(response)\n\treturn\n}\n\n// msiResponse marshals in a format that matches the underlying\n// metadata endpoint more closely. This increases compatibility\n// with callers built on older versions of adal client libraries.\ntype msiResponse struct {\n\tAccessToken  string `json:\"access_token\"`\n\tRefreshToken string `json:\"refresh_token\"`\n\n\tExpiresIn string `json:\"expires_in\"`\n\tExpiresOn string `json:\"expires_on\"`\n\tNotBefore string `json:\"not_before\"`\n\n\tResource string `json:\"resource\"`\n\tType     string `json:\"token_type\"`\n}\n\nfunc newMSIResponse(token adal.Token) msiResponse {\n\treturn msiResponse{\n\t\tAccessToken:  token.AccessToken,\n\t\tRefreshToken: token.RefreshToken,\n\t\tExpiresIn:    token.ExpiresIn.String(),\n\t\tExpiresOn:    token.ExpiresOn.String(),\n\t\tNotBefore:    token.NotBefore.String(),\n\t\tResource:     token.Resource,\n\t\tType:         token.Type,\n\t}\n}\n\nfunc (s *Server) isMIC(podNS, rsName string) bool {\n\tmicRegEx := regexp.MustCompile(`^mic-*`)\n\tif strings.EqualFold(podNS, s.MICNamespace) && micRegEx.MatchString(rsName) {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (s *Server) getTokenForExceptedPod(rqClientID, rqResource string) ([]byte, int, error) {\n\tvar token *adal.Token\n\tvar err error\n\t// ClientID is empty, so we are going to use System assigned MSI\n\tif rqClientID == \"\" {\n\t\tklog.Infof(\"fetching token for system assigned MSI\")\n\t\ttoken, err = auth.GetServicePrincipalTokenFromMSI(rqResource)\n\t} else { // User assigned identity usage.\n\t\tklog.Infof(\"fetching token for user assigned MSI for resource: %s\", rqResource)\n\t\ttoken, err = auth.GetServicePrincipalTokenFromMSIWithUserAssignedID(rqClientID, rqResource)\n\t}\n\tif err != nil {\n\t\t// TODO: return the right status code based on the error we got from adal.\n\t\treturn nil, http.StatusForbidden, fmt.Errorf(\"failed to get service principal token, error: %+v\", err)\n\t}\n\tresponse, err := json.Marshal(newMSIResponse(*token))\n\tif err != nil {\n\t\treturn nil, http.StatusInternalServerError, fmt.Errorf(\"failed to marshal service principal token, error: %+v\", err)\n\t}\n\treturn response, http.StatusOK, nil\n}\n\n// msiHandler uses the remote address to identify the pod ip and uses it\n// to find a matching client id, and then returns the token sourced through\n// AAD using adal\n// if the requests contains client id it validates it against the admin\n// configured id.\nfunc (s *Server) msiHandler(w http.ResponseWriter, r *http.Request) (ns string) {\n\tif s.MetadataHeaderRequired && parseMetadata(r) != \"true\" {\n\t\tklog.Errorf(\"metadata header is not specified, req.method=%s reg.path=%s req.remote=%s\", r.Method, r.URL.Path, parseRemoteAddr(r.RemoteAddr))\n\t\tmetadataNotSpecifiedError(w)\n\t\treturn\n\t}\n\n\tpodIP := parseRemoteAddr(r.RemoteAddr)\n\ttokenRequest := parseTokenRequest(r)\n\n\tif podIP == \"\" {\n\t\tklog.Error(\"request remote address is empty\")\n\t\thttp.Error(w, \"request remote address is empty\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tif !tokenRequest.ValidateResourceParamExists() {\n\t\tklog.Warning(\"parameter resource cannot be empty\")\n\t\thttp.Error(w, \"parameter resource cannot be empty\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tpodns, podname, rsName, selectors, err := s.KubeClient.GetPodInfo(podIP)\n\tif err != nil {\n\t\tklog.Errorf(\"failed to get pod info from pod IP: %s, error: %+v\", podIP, err)\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\t// set ns for using in metrics\n\tns = podns\n\texceptionList, err := s.KubeClient.ListPodIdentityExceptions(podns)\n\tif err != nil {\n\t\tklog.Errorf(\"getting list of AzurePodIdentityException in %s namespace failed with error: %+v\", podns, err)\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// If its mic, then just directly get the token and pass back.\n\tif pod.IsPodExcepted(selectors.MatchLabels, *exceptionList) || s.isMIC(podns, rsName) {\n\t\tklog.Infof(\"exception pod %s/%s token handling\", podns, podname)\n\t\tresponse, errorCode, err := s.getTokenForExceptedPod(tokenRequest.ClientID, tokenRequest.Resource)\n\t\tif err != nil {\n\t\t\tklog.Errorf(\"failed to get service principal token for pod:%s/%s with error code %d, error: %+v\", podns, podname, errorCode, err)\n\t\t\thttp.Error(w, err.Error(), errorCode)\n\t\t\treturn\n\t\t}\n\t\tw.Header().Set(\"Content-Length\", strconv.Itoa(len(response)))\n\t\t_, _ = w.Write(response)\n\t\treturn\n\t}\n\n\tpodID, err := s.TokenClient.GetIdentities(r.Context(), podns, podname, tokenRequest.ClientID, tokenRequest.ResourceID)\n\tif err != nil {\n\t\tklog.Errorf(\"failed to get matching identities for pod: %s/%s, error: %+v\", podns, podname, err)\n\t\thttpErrorCode := http.StatusNotFound\n\t\tif s.SetRetryAfterHeader {\n\t\t\thttpErrorCode = http.StatusServiceUnavailable\n\t\t\t// setting it to 20s to allow MIC to finish processing current cycle and pick up this\n\t\t\t// pod in the next sync cycle\n\t\t\tw.Header().Set(headerRetryAfter, \"20\")\n\t\t}\n\t\thttp.Error(w, err.Error(), httpErrorCode)\n\t\treturn\n\t}\n\n\ttokens, err := s.TokenClient.GetTokens(r.Context(), tokenRequest.ClientID, tokenRequest.Resource, *podID)\n\tif err != nil {\n\t\tklog.Errorf(\"failed to get service principal token for pod: %s/%s, error: %+v\", podns, podname, err)\n\t\thttpErrorCode := http.StatusForbidden\n\t\tif auth.IsHealthCheckError(err) {\n\t\t\t// the adal library performs a health check prior to making the token request\n\t\t\t// if the health check fails, we want to return a 503 instead of 403\n\t\t\t// for health check failures, the error is not a token refresh error\n\t\t\thttpErrorCode = http.StatusServiceUnavailable\n\t\t}\n\t\thttp.Error(w, err.Error(), httpErrorCode)\n\t\treturn\n\t}\n\n\tvar v interface{}\n\tif len(tokens) == 1 {\n\t\tv = newMSIResponse(*tokens[0])\n\t} else {\n\t\tvar msiResp []msiResponse\n\t\tfor _, token := range tokens {\n\t\t\tmsiResp = append(msiResp, newMSIResponse(*token))\n\t\t}\n\t\tv = msiResp\n\t}\n\n\tresponse, err := json.Marshal(v)\n\tif err != nil {\n\t\tklog.Errorf(\"failed to marshal service principal token for pod: %s/%s, error: %+v\", podns, podname, err)\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tw.Header().Set(\"Content-Length\", strconv.Itoa(len(response)))\n\t_, _ = w.Write(response)\n\treturn\n}\n\n// Error replies to the request without the specified metadata header.\n// It does not otherwise end the request; the caller should ensure no further\n// writes are done to w.\nfunc metadataNotSpecifiedError(w http.ResponseWriter) {\n\tmetadataResp := MetadataResponse{\n\t\tError:            \"invalid_request\",\n\t\tErrorDescription: \"Required metadata header not specified\",\n\t}\n\tresponse, err := json.Marshal(metadataResp)\n\tif err != nil {\n\t\tklog.Errorf(\"failed to marshal metadata response, %+v\", err)\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\tw.WriteHeader(http.StatusBadRequest)\n\tfmt.Fprintln(w, string(response))\n}\n\nfunc parseMetadata(r *http.Request) (metadata string) {\n\treturn r.Header.Get(\"metadata\")\n}\n\nfunc parsePodInfo(r *http.Request) (podns string, podname string) {\n\tpodns = r.Header.Get(\"podns\")\n\tpodname = r.Header.Get(\"podname\")\n\n\treturn podns, podname\n}\n\nfunc parseRemoteAddr(addr string) string {\n\tn := strings.IndexByte(addr, ':')\n\tif n <= 1 {\n\t\treturn \"\"\n\t}\n\thostname := addr[0:n]\n\tif net.ParseIP(hostname) == nil {\n\t\treturn \"\"\n\t}\n\treturn hostname\n}\n\n// TokenRequest contains the client and resource ID token, as well as what resource the client is trying to access.\ntype TokenRequest struct {\n\t// ClientID identifies, by Azure AD client ID, a specific identity to use\n\t// when authenticating to Azure AD. It is mutually exclusive with\n\t// MsiResourceID.\n\t// Example: 77788899-f67e-42e1-9a78-89985f6bff3e\n\tClientID string\n\n\t// MsiResourceID identifies, by urlencoded ARM resource ID, a specific\n\t// identity to use when authenticating to Azure AD. It is mutually exclusive\n\t// with ClientID.\n\t// Example: /subscriptions/<subid>/resourcegroups/<resourcegroup>/providers/Microsoft.ManagedIdentity/userAssignedIdentities/<name>\n\tResourceID string\n\n\t// Resource is the urlencoded URI of the resource for the requested AD token.\n\t// Example: https://vault.azure.net.\n\tResource string\n}\n\n// ValidateResourceParamExists returns true if there exists a resource parameter from the request.\nfunc (r TokenRequest) ValidateResourceParamExists() bool {\n\t// check if resource exists in the request\n\t// if resource doesn't exist in the request, then adal libraries will return the same error\n\t// IMDS also returns an error with 400 response code if resource parameter is empty\n\t// this is done to emulate same behavior observed while requesting token from IMDS\n\treturn len(r.Resource) != 0\n}\n\nfunc parseTokenRequest(r *http.Request) (request TokenRequest) {\n\tvals := r.URL.Query()\n\tif vals != nil {\n\t\t// These are mutually exclusive values (client_id, msi_resource_id)\n\t\trequest.ClientID = vals.Get(\"client_id\")\n\t\trequest.ResourceID = vals.Get(\"msi_res_id\")\n\n\t\trequest.Resource = vals.Get(\"resource\")\n\t}\n\treturn request\n}\n\n// defaultPathHandler creates a new request and returns the response body and code\nfunc (s *Server) defaultPathHandler(w http.ResponseWriter, r *http.Request) {\n\tif s.MetadataHeaderRequired && parseMetadata(r) != \"true\" {\n\t\tklog.Errorf(\"metadata header is not specified, req.method=%s reg.path=%s req.remote=%s\", r.Method, r.URL.Path, parseRemoteAddr(r.RemoteAddr))\n\t\tmetadataNotSpecifiedError(w)\n\t\treturn\n\t}\n\n\tclient := &http.Client{}\n\treq, err := http.NewRequest(r.Method, r.URL.String(), r.Body)\n\tif err != nil || req == nil {\n\t\tklog.Errorf(\"failed creating a new request for %s, error: %+v\", r.URL.String(), err)\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\thost := fmt.Sprintf(\"%s:%s\", s.MetadataIP, s.MetadataPort)\n\treq.Host = host\n\treq.URL.Host = host\n\treq.URL.Scheme = \"http\"\n\tif r.Header != nil {\n\t\tcopyHeader(req.Header, r.Header)\n\t}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tklog.Errorf(\"failed executing request for %s, error: %+v\", req.URL.String(), err)\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\tklog.Errorf(\"failed to read response body for %s, error: %+v\", req.URL.String(), err)\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t}\n\tcopyHeader(w.Header(), resp.Header)\n\tw.WriteHeader(resp.StatusCode)\n\t_, _ = w.Write(body)\n}\n\n// forbiddenHandler responds to any request with HTTP 403 Forbidden\nfunc forbiddenHandler(w http.ResponseWriter, r *http.Request) {\n\thttp.Error(w, \"Request blocked by AAD Pod Identity NMI\", http.StatusForbidden)\n}\n\nfunc copyHeader(dst, src http.Header) {\n\tfor k, vv := range src {\n\t\tfor _, v := range vv {\n\t\t\tdst.Add(k, v)\n\t\t}\n\t}\n}\n\nfunc handleTermination() {\n\tklog.Info(\"received SIGTERM, shutting down\")\n\n\texitCode := 0\n\t// clean up iptables\n\tif err := iptables.DeleteCustomChain(); err != nil {\n\t\tklog.Errorf(\"failed to clean up during shutdown, error: %+v\", err)\n\t\texitCode = 1\n\t}\n\n\t// wait for pod to delete\n\tklog.Info(\"handled termination, awaiting pod deletion\")\n\ttime.Sleep(10 * time.Second)\n\n\tklog.Infof(\"exiting with %v\", exitCode)\n\tos.Exit(exitCode)\n}\n", "package server\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/gorilla/mux\"\n)\n\nvar (\n\trtr       *mux.Router\n\tserver    *httptest.Server\n\ttokenPath = \"/metadata/identity/oauth2/token/\"\n)\n\nfunc setup() {\n\trtr = mux.NewRouter()\n\tserver = httptest.NewServer(rtr)\n}\n\nfunc teardown() {\n\tserver.Close()\n}\n\nfunc TestMsiHandler_NoMetadataHeader(t *testing.T) {\n\tsetup()\n\tdefer teardown()\n\n\ts := &Server{\n\t\tMetadataHeaderRequired: true,\n\t}\n\trtr.PathPrefix(\"/{type:(?i:metadata)}/identity/oauth2/token/\").Handler(appHandler(s.msiHandler))\n\n\treq, err := http.NewRequest(http.MethodGet, tokenPath, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\trecorder := httptest.NewRecorder()\n\trtr.ServeHTTP(recorder, req)\n\n\tif recorder.Code != http.StatusBadRequest {\n\t\tt.Errorf(\"Unexpected status code %d\", recorder.Code)\n\t}\n\n\tresp := &MetadataResponse{\n\t\tError:            \"invalid_request\",\n\t\tErrorDescription: \"Required metadata header not specified\",\n\t}\n\texpected, err := json.Marshal(resp)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif string(expected) != strings.TrimSpace(recorder.Body.String()) {\n\t\tt.Errorf(\"Unexpected response body %s\", recorder.Body.String())\n\t}\n}\n\nfunc TestMsiHandler_NoRemoteAddress(t *testing.T) {\n\tsetup()\n\tdefer teardown()\n\n\ts := &Server{\n\t\tMetadataHeaderRequired: false,\n\t}\n\trtr.PathPrefix(\"/{type:(?i:metadata)}/identity/oauth2/token/\").Handler(appHandler(s.msiHandler))\n\n\treq, err := http.NewRequest(http.MethodGet, tokenPath, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\trecorder := httptest.NewRecorder()\n\trtr.ServeHTTP(recorder, req)\n\n\tif recorder.Code != http.StatusInternalServerError {\n\t\tt.Errorf(\"Unexpected status code %d\", recorder.Code)\n\t}\n\n\texpected := \"request remote address is empty\"\n\tif expected != strings.TrimSpace(recorder.Body.String()) {\n\t\tt.Errorf(\"Unexpected response body %s\", recorder.Body.String())\n\t}\n}\n\nfunc TestParseTokenRequest(t *testing.T) {\n\tconst endpoint = \"http://127.0.0.1/metadata/identity/oauth2/token\"\n\n\tt.Run(\"query present\", func(t *testing.T) {\n\t\tconst resource = \"https://vault.azure.net\"\n\t\tconst clientID = \"77788899-f67e-42e1-9a78-89985f6bff3e\"\n\t\tconst resourceID = \"/subscriptions/9f2be85c-f8ae-4569-9353-38e5e8b459ef/resourcegroups/test/providers/Microsoft.ManagedIdentity/userAssignedIdentities/test\"\n\n\t\tvar r http.Request\n\t\tr.URL, _ = url.Parse(fmt.Sprintf(\"%s?client_id=%s&msi_res_id=%s&resource=%s\", endpoint, clientID, resourceID, resource))\n\n\t\tresult := parseTokenRequest(&r)\n\n\t\tif result.ClientID != clientID {\n\t\t\tt.Errorf(\"invalid ClientID - expected: %q, actual: %q\", clientID, result.ClientID)\n\t\t}\n\n\t\tif result.ResourceID != resourceID {\n\t\t\tt.Errorf(\"invalid ResourceID - expected: %q, actual: %q\", resourceID, result.ResourceID)\n\t\t}\n\n\t\tif result.Resource != resource {\n\t\t\tt.Errorf(\"invalid Resource - expected: %q, actual: %q\", resource, result.Resource)\n\t\t}\n\t})\n\n\tt.Run(\"bare endpoint\", func(t *testing.T) {\n\t\tvar r http.Request\n\t\tr.URL, _ = url.Parse(endpoint)\n\n\t\tresult := parseTokenRequest(&r)\n\n\t\tif result.ClientID != \"\" {\n\t\t\tt.Errorf(\"invalid ClientID - expected: %q, actual: %q\", \"\", result.ClientID)\n\t\t}\n\n\t\tif result.ResourceID != \"\" {\n\t\t\tt.Errorf(\"invalid ResourceID - expected: %q, actual: %q\", \"\", result.ResourceID)\n\t\t}\n\n\t\tif result.Resource != \"\" {\n\t\t\tt.Errorf(\"invalid Resource - expected: %q, actual: %q\", \"\", result.Resource)\n\t\t}\n\t})\n}\n\nfunc TestTokenRequest_ValidateResourceParamExists(t *testing.T) {\n\ttr := TokenRequest{\n\t\tResource: \"https://vault.azure.net\",\n\t}\n\n\tif !tr.ValidateResourceParamExists() {\n\t\tt.Error(\"ValidateResourceParamExists should have returned true when the resource is set\")\n\t}\n\n\ttr.Resource = \"\"\n\tif tr.ValidateResourceParamExists() {\n\t\tt.Error(\"ValidateResourceParamExists should have returned false when the resource is unset\")\n\t}\n}\n\nfunc TestRouterPathPrefix(t *testing.T) {\n\ttests := []struct {\n\t\tname               string\n\t\turl                string\n\t\texpectedStatusCode int\n\t\texpectedBody       string\n\t}{\n\t\t{\n\t\t\tname:               \"token request\",\n\t\t\turl:                \"/metadata/identity/oauth2/token/\",\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\texpectedBody:       \"token_request_handler\",\n\t\t},\n\t\t{\n\t\t\tname:               \"token request without / suffix\",\n\t\t\turl:                \"/metadata/identity/oauth2/token\",\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\texpectedBody:       \"token_request_handler\",\n\t\t},\n\t\t{\n\t\t\tname:               \"token request with upper case metadata\",\n\t\t\turl:                \"/Metadata/identity/oauth2/token/\",\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\texpectedBody:       \"token_request_handler\",\n\t\t},\n\t\t{\n\t\t\tname:               \"token request with upper case identity\",\n\t\t\turl:                \"/metadata/Identity/oauth2/token/\",\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\texpectedBody:       \"default_handler\",\n\t\t},\n\t\t{\n\t\t\tname:               \"host token request\",\n\t\t\turl:                \"/host/token/\",\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\texpectedBody:       \"host_token_request_handler\",\n\t\t},\n\t\t{\n\t\t\tname:               \"host token request without / suffix\",\n\t\t\turl:                \"/host/token\",\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\texpectedBody:       \"host_token_request_handler\",\n\t\t},\n\t\t{\n\t\t\tname:               \"instance metadata request\",\n\t\t\turl:                \"/metadata/instance\",\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\texpectedBody:       \"instance_request_handler\",\n\t\t},\n\t\t{\n\t\t\tname:               \"instance metadata request with upper case metadata\",\n\t\t\turl:                \"/Metadata/instance\",\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\texpectedBody:       \"instance_request_handler\",\n\t\t},\n\t\t{\n\t\t\tname:               \"instance metadata request / suffix\",\n\t\t\turl:                \"/Metadata/instance/\",\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\texpectedBody:       \"instance_request_handler\",\n\t\t},\n\t\t{\n\t\t\tname:               \"default metadata request\",\n\t\t\turl:                \"/metadata/\",\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\texpectedBody:       \"default_handler\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tsetup()\n\t\t\tdefer teardown()\n\n\t\t\trtr.PathPrefix(tokenPathPrefix).HandlerFunc(testTokenHandler)\n\t\t\trtr.PathPrefix(hostTokenPathPrefix).HandlerFunc(testHostTokenHandler)\n\t\t\trtr.PathPrefix(instancePathPrefix).HandlerFunc(testInstanceHandler)\n\t\t\trtr.PathPrefix(\"/\").HandlerFunc(testDefaultHandler)\n\n\t\t\treq, err := http.NewRequest(http.MethodGet, test.url, nil)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\trecorder := httptest.NewRecorder()\n\t\t\trtr.ServeHTTP(recorder, req)\n\n\t\t\tif recorder.Code != test.expectedStatusCode {\n\t\t\t\tt.Errorf(\"unexpected status code %d\", recorder.Code)\n\t\t\t}\n\n\t\t\tif test.expectedBody != strings.TrimSpace(recorder.Body.String()) {\n\t\t\t\tt.Errorf(\"unexpected response body %s\", recorder.Body.String())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc testTokenHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"token_request_handler\\n\")\n}\n\nfunc testHostTokenHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"host_token_request_handler\\n\")\n}\n\nfunc testInstanceHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"instance_request_handler\\n\")\n}\n\nfunc testDefaultHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"default_handler\\n\")\n}\n"], "fixing_code": ["package server\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"runtime/debug\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/Azure/go-autorest/autorest/adal\"\n\t\"github.com/gorilla/mux\"\n\t\"k8s.io/klog/v2\"\n\n\t\"github.com/Azure/aad-pod-identity/pkg/auth\"\n\t\"github.com/Azure/aad-pod-identity/pkg/k8s\"\n\t\"github.com/Azure/aad-pod-identity/pkg/metrics\"\n\t\"github.com/Azure/aad-pod-identity/pkg/nmi\"\n\t\"github.com/Azure/aad-pod-identity/pkg/nmi/conntrack\"\n\t\"github.com/Azure/aad-pod-identity/pkg/nmi/iptables\"\n\t\"github.com/Azure/aad-pod-identity/pkg/pod\"\n)\n\nconst (\n\tlocalhost = \"127.0.0.1\"\n\t// \"/metadata\" portion is case-insensitive in IMDS\n\ttokenPathPrefix     = \"/{type:(?i:metadata)}/identity/oauth2/token\" // #nosec\n\thostTokenPathPrefix = \"/host/token\"\n\t// \"/metadata\" portion is case-insensitive in IMDS\n\tinstancePathPrefix = \"/{type:(?i:metadata)}/instance\" // #nosec\n\theaderRetryAfter   = \"Retry-After\"\n)\n\nvar (\n\t// invalidTokenPathMatcher matches the token path that is not supported by IMDS\n\t// this handler is configured right after the token path handler to block requests with\n\t// invalid token path instead of sending it to IMDS.\n\t// we don't have to handle case sensitivity for \"/identity/\" as that's rejected by IMDS\n\tinvalidTokenPathMatcher = mux.MatcherFunc(func(req *http.Request, rm *mux.RouteMatch) bool {\n\t\tr := regexp.MustCompile(\"/(?i:metadata)/identity(.*?)oauth2(.*?)token\") // #nosec\n\t\treturn r.MatchString(req.URL.Path)\n\t})\n)\n\n// Server encapsulates all of the parameters necessary for starting up\n// the server. These can be set via command line.\ntype Server struct {\n\tKubeClient                         k8s.Client\n\tNMIHost                            string\n\tNMIPort                            string\n\tMetadataIP                         string\n\tMetadataPort                       string\n\tNodeName                           string\n\tIPTableUpdateTimeIntervalInSeconds int\n\tMICNamespace                       string\n\tInitialized                        bool\n\tBlockInstanceMetadata              bool\n\tMetadataHeaderRequired             bool\n\tSetRetryAfterHeader                bool\n\tEnableConntrackDeletion            bool\n\t// TokenClient is client that fetches identities and tokens\n\tTokenClient nmi.TokenClient\n\tReporter    *metrics.Reporter\n}\n\n// NMIResponse is the response returned to caller\ntype NMIResponse struct {\n\tToken    msiResponse `json:\"token\"`\n\tClientID string      `json:\"clientid\"`\n}\n\n// MetadataResponse represents the error returned\n// to caller when metadata header is not specified.\ntype MetadataResponse struct {\n\tError            string `json:\"error\"`\n\tErrorDescription string `json:\"error_description\"`\n}\n\n// NewServer will create a new Server with default values.\nfunc NewServer(micNamespace string, blockInstanceMetadata, metadataHeaderRequired, setRetryAfterHeader bool) *Server {\n\treporter, err := metrics.NewReporter()\n\tif err != nil {\n\t\tklog.Errorf(\"failed to create reporter for metrics, error: %+v\", err)\n\t} else {\n\t\t// keeping this reference to be used in ServeHTTP, as server is not accessible in ServeHTTP\n\t\tappHandlerReporter = reporter\n\t\tauth.InitReporter(reporter)\n\t}\n\treturn &Server{\n\t\tMICNamespace:           micNamespace,\n\t\tBlockInstanceMetadata:  blockInstanceMetadata,\n\t\tMetadataHeaderRequired: metadataHeaderRequired,\n\t\tReporter:               reporter,\n\t\tSetRetryAfterHeader:    setRetryAfterHeader,\n\t}\n}\n\n// Run runs the specified Server.\nfunc (s *Server) Run() error {\n\tgo s.updateIPTableRules()\n\n\trtr := mux.NewRouter()\n\t// Flow for the request is as follows:\n\t// 1. If the request is for token, then it will be handled by tokenHandler post validation.\n\t// 2. If the request is for token but the path is invalid, then it will be handled by invalidTokenPathHandler.\n\t// 3. If the request is for host token, then it will be handled by hostTokenHandler.\n\t// 4. If the request is for instance metadata\n\t//    4.1 If blockInstanceMetadata is set to true, then it will be handled by blockInstanceMetadataHandler (deny access to instance metadata).\n\t// 5. If the request is for any other path, it will be proxied to IMDS and the response will be returned to the caller.\n\trtr.PathPrefix(tokenPathPrefix).Handler(appHandler(s.msiHandler))\n\trtr.MatcherFunc(invalidTokenPathMatcher).HandlerFunc(invalidTokenPathHandler)\n\trtr.PathPrefix(hostTokenPathPrefix).Handler(appHandler(s.hostHandler))\n\tif s.BlockInstanceMetadata {\n\t\trtr.PathPrefix(instancePathPrefix).HandlerFunc(forbiddenHandler)\n\t}\n\trtr.PathPrefix(\"/\").HandlerFunc(s.defaultPathHandler)\n\n\tklog.Infof(\"listening on %s:%s\", s.NMIHost, s.NMIPort)\n\tif err := http.ListenAndServe(fmt.Sprintf(\"%s:%s\", s.NMIHost, s.NMIPort), rtr); err != nil {\n\t\tklog.Fatalf(\"error creating http server: %+v\", err)\n\t}\n\treturn nil\n}\n\nfunc (s *Server) updateIPTableRulesInternal() {\n\ttarget := s.NMIHost\n\tif target == \"0.0.0.0\" {\n\t\t// if we're binding to all interfaces, we still want to add iptables rules for localhost only\n\t\ttarget = localhost\n\t}\n\n\tklog.V(5).Infof(\"node(%s) ip(%s) metadata address(%s:%s) nmi port(%s)\", s.NodeName, target, s.MetadataIP, s.MetadataPort, s.NMIPort)\n\n\tif err := iptables.AddCustomChain(s.MetadataIP, s.MetadataPort, target, s.NMIPort); err != nil {\n\t\tklog.Fatalf(\"%s\", err)\n\t}\n\tif err := iptables.LogCustomChain(); err != nil {\n\t\tklog.Fatalf(\"%s\", err)\n\t}\n}\n\n// try to delete pre-existing conntrack entries for metadata endpoint\nfunc (s *Server) deleteConntrackEntries() {\n\tklog.Infof(\"deleting conntrack entries for %s:%s\", s.MetadataIP, s.MetadataPort)\n\n\tif err := conntrack.DeleteConntrackEntries(s.MetadataIP, s.MetadataPort); err != nil {\n\t\tklog.Fatalf(\"failed to delete conntrack entries for metadata ip: %s\", err)\n\t}\n}\n\n// updateIPTableRules ensures the correct iptable rules are set\n// such that metadata requests are received by nmi assigned port\n// NOT originating from HostIP destined to metadata endpoint are\n// routed to NMI endpoint\nfunc (s *Server) updateIPTableRules() {\n\tsignalChan := make(chan os.Signal, 1)\n\tsignal.Notify(signalChan, syscall.SIGTERM, syscall.SIGINT)\n\n\tticker := time.NewTicker(time.Second * time.Duration(s.IPTableUpdateTimeIntervalInSeconds))\n\tdefer ticker.Stop()\n\t// Run once before the waiting on ticker for the rules to take effect\n\t// immediately.\n\ts.updateIPTableRulesInternal()\n\t// delete conntrack entries for pre-existing connections to metadata endpoint\n\tif s.EnableConntrackDeletion {\n\t\ts.deleteConntrackEntries()\n\t}\n\ts.Initialized = true\n\nloop:\n\tfor {\n\t\tselect {\n\t\tcase <-signalChan:\n\t\t\thandleTermination()\n\t\t\tbreak loop\n\n\t\tcase <-ticker.C:\n\t\t\ts.updateIPTableRulesInternal()\n\t\t}\n\t}\n}\n\ntype appHandler func(http.ResponseWriter, *http.Request) string\n\ntype responseWriter struct {\n\thttp.ResponseWriter\n\tstatusCode int\n}\n\nfunc (rw *responseWriter) WriteHeader(code int) {\n\trw.statusCode = code\n\trw.ResponseWriter.WriteHeader(code)\n}\n\nfunc newResponseWriter(w http.ResponseWriter) *responseWriter {\n\treturn &responseWriter{w, http.StatusOK}\n}\n\nvar appHandlerReporter *metrics.Reporter\n\n// ServeHTTP implements the net/http server handler interface\n// and recovers from panics.\nfunc (fn appHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\ttracker := fmt.Sprintf(\"req.method=%s reg.path=%s req.remote=%s\", r.Method, r.URL.Path, parseRemoteAddr(r.RemoteAddr))\n\n\t// Set the header in advance so that both success as well\n\t// as error paths have it set as application/json content type.\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tstart := time.Now()\n\tdefer func() {\n\t\tvar err error\n\t\tif rec := recover(); rec != nil {\n\t\t\t_, file, line, _ := runtime.Caller(3)\n\t\t\tstack := string(debug.Stack())\n\t\t\tswitch t := rec.(type) {\n\t\t\tcase string:\n\t\t\t\terr = errors.New(t)\n\t\t\tcase error:\n\t\t\t\terr = t\n\t\t\tdefault:\n\t\t\t\terr = errors.New(\"unknown error\")\n\t\t\t}\n\t\t\tklog.Errorf(\"panic processing request: %+v, file: %s, line: %d, stacktrace: '%s' %s res.status=%d\", r, file, line, stack, tracker, http.StatusInternalServerError)\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t}\n\t}()\n\trw := newResponseWriter(w)\n\tns := fn(rw, r)\n\tlatency := time.Since(start)\n\tklog.Infof(\"status (%d) took %d ns for %s\", rw.statusCode, latency.Nanoseconds(), tracker)\n\n\ttokenRequest := parseTokenRequest(r)\n\n\tif appHandlerReporter != nil {\n\t\terr := appHandlerReporter.ReportOperationAndStatus(\n\t\t\tr.URL.Path,\n\t\t\tstrconv.Itoa(rw.statusCode),\n\t\t\tns,\n\t\t\ttokenRequest.Resource,\n\t\t\tmetrics.NMIOperationsDurationM.M(metrics.SinceInSeconds(start)))\n\t\tif err != nil {\n\t\t\tklog.Warningf(\"failed to report metrics, error: %+v\", err)\n\t\t}\n\t}\n}\n\nfunc (s *Server) hostHandler(w http.ResponseWriter, r *http.Request) (ns string) {\n\thostIP := parseRemoteAddr(r.RemoteAddr)\n\ttokenRequest := parseTokenRequest(r)\n\n\tpodns, podname := parsePodInfo(r)\n\tif podns == \"\" || podname == \"\" {\n\t\tklog.Error(\"missing podname and podns from request\")\n\t\thttp.Error(w, \"missing 'podname' and 'podns' from request header\", http.StatusBadRequest)\n\t\treturn\n\t}\n\t// set the ns so it can be used for metrics\n\tns = podns\n\tif hostIP != localhost {\n\t\tklog.Errorf(\"request remote address is not from a host\")\n\t\thttp.Error(w, \"request remote address is not from a host\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tif !tokenRequest.ValidateResourceParamExists() {\n\t\tklog.Warning(\"parameter resource cannot be empty\")\n\t\thttp.Error(w, \"parameter resource cannot be empty\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tpodID, err := s.TokenClient.GetIdentities(r.Context(), podns, podname, tokenRequest.ClientID, tokenRequest.ResourceID)\n\tif err != nil {\n\t\tklog.Errorf(\"failed to get identities, error: %+v\", err)\n\t\thttp.Error(w, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\ttokens, err := s.TokenClient.GetTokens(r.Context(), tokenRequest.ClientID, tokenRequest.Resource, *podID)\n\tif err != nil {\n\t\tklog.Errorf(\"failed to get service principal token for pod:%s/%s, error: %+v\", podns, podname, err)\n\t\thttpErrorCode := http.StatusForbidden\n\t\tif auth.IsHealthCheckError(err) {\n\t\t\t// the adal library performs a health check prior to making the token request\n\t\t\t// if the health check fails, we want to return a 503 instead of 403\n\t\t\t// for health check failures, the error is not a token refresh error\n\t\t\thttpErrorCode = http.StatusServiceUnavailable\n\t\t}\n\t\thttp.Error(w, err.Error(), httpErrorCode)\n\t\treturn\n\t}\n\tnmiResp := NMIResponse{\n\t\tToken:    newMSIResponse(*tokens[0]),\n\t\tClientID: podID.Spec.ClientID,\n\t}\n\tresponse, err := json.Marshal(nmiResp)\n\tif err != nil {\n\t\tklog.Errorf(\"failed to marshal service principal token and clientid for pod:%s/%s, error: %+v\", podns, podname, err)\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tw.Header().Set(\"Content-Length\", strconv.Itoa(len(response)))\n\t_, _ = w.Write(response)\n\treturn\n}\n\n// msiResponse marshals in a format that matches the underlying\n// metadata endpoint more closely. This increases compatibility\n// with callers built on older versions of adal client libraries.\ntype msiResponse struct {\n\tAccessToken  string `json:\"access_token\"`\n\tRefreshToken string `json:\"refresh_token\"`\n\n\tExpiresIn string `json:\"expires_in\"`\n\tExpiresOn string `json:\"expires_on\"`\n\tNotBefore string `json:\"not_before\"`\n\n\tResource string `json:\"resource\"`\n\tType     string `json:\"token_type\"`\n}\n\nfunc newMSIResponse(token adal.Token) msiResponse {\n\treturn msiResponse{\n\t\tAccessToken:  token.AccessToken,\n\t\tRefreshToken: token.RefreshToken,\n\t\tExpiresIn:    token.ExpiresIn.String(),\n\t\tExpiresOn:    token.ExpiresOn.String(),\n\t\tNotBefore:    token.NotBefore.String(),\n\t\tResource:     token.Resource,\n\t\tType:         token.Type,\n\t}\n}\n\nfunc (s *Server) isMIC(podNS, rsName string) bool {\n\tmicRegEx := regexp.MustCompile(`^mic-*`)\n\tif strings.EqualFold(podNS, s.MICNamespace) && micRegEx.MatchString(rsName) {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (s *Server) getTokenForExceptedPod(rqClientID, rqResource string) ([]byte, int, error) {\n\tvar token *adal.Token\n\tvar err error\n\t// ClientID is empty, so we are going to use System assigned MSI\n\tif rqClientID == \"\" {\n\t\tklog.Infof(\"fetching token for system assigned MSI\")\n\t\ttoken, err = auth.GetServicePrincipalTokenFromMSI(rqResource)\n\t} else { // User assigned identity usage.\n\t\tklog.Infof(\"fetching token for user assigned MSI for resource: %s\", rqResource)\n\t\ttoken, err = auth.GetServicePrincipalTokenFromMSIWithUserAssignedID(rqClientID, rqResource)\n\t}\n\tif err != nil {\n\t\t// TODO: return the right status code based on the error we got from adal.\n\t\treturn nil, http.StatusForbidden, fmt.Errorf(\"failed to get service principal token, error: %+v\", err)\n\t}\n\tresponse, err := json.Marshal(newMSIResponse(*token))\n\tif err != nil {\n\t\treturn nil, http.StatusInternalServerError, fmt.Errorf(\"failed to marshal service principal token, error: %+v\", err)\n\t}\n\treturn response, http.StatusOK, nil\n}\n\n// msiHandler uses the remote address to identify the pod ip and uses it\n// to find a matching client id, and then returns the token sourced through\n// AAD using adal\n// if the requests contains client id it validates it against the admin\n// configured id.\nfunc (s *Server) msiHandler(w http.ResponseWriter, r *http.Request) (ns string) {\n\tif s.MetadataHeaderRequired && parseMetadata(r) != \"true\" {\n\t\tklog.Errorf(\"metadata header is not specified, req.method=%s reg.path=%s req.remote=%s\", r.Method, r.URL.Path, parseRemoteAddr(r.RemoteAddr))\n\t\tmetadataNotSpecifiedError(w)\n\t\treturn\n\t}\n\n\tpodIP := parseRemoteAddr(r.RemoteAddr)\n\ttokenRequest := parseTokenRequest(r)\n\n\tif podIP == \"\" {\n\t\tklog.Error(\"request remote address is empty\")\n\t\thttp.Error(w, \"request remote address is empty\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tif !tokenRequest.ValidateResourceParamExists() {\n\t\tklog.Warning(\"parameter resource cannot be empty\")\n\t\thttp.Error(w, \"parameter resource cannot be empty\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tpodns, podname, rsName, selectors, err := s.KubeClient.GetPodInfo(podIP)\n\tif err != nil {\n\t\tklog.Errorf(\"failed to get pod info from pod IP: %s, error: %+v\", podIP, err)\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\t// set ns for using in metrics\n\tns = podns\n\texceptionList, err := s.KubeClient.ListPodIdentityExceptions(podns)\n\tif err != nil {\n\t\tklog.Errorf(\"getting list of AzurePodIdentityException in %s namespace failed with error: %+v\", podns, err)\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// If its mic, then just directly get the token and pass back.\n\tif pod.IsPodExcepted(selectors.MatchLabels, *exceptionList) || s.isMIC(podns, rsName) {\n\t\tklog.Infof(\"exception pod %s/%s token handling\", podns, podname)\n\t\tresponse, errorCode, err := s.getTokenForExceptedPod(tokenRequest.ClientID, tokenRequest.Resource)\n\t\tif err != nil {\n\t\t\tklog.Errorf(\"failed to get service principal token for pod:%s/%s with error code %d, error: %+v\", podns, podname, errorCode, err)\n\t\t\thttp.Error(w, err.Error(), errorCode)\n\t\t\treturn\n\t\t}\n\t\tw.Header().Set(\"Content-Length\", strconv.Itoa(len(response)))\n\t\t_, _ = w.Write(response)\n\t\treturn\n\t}\n\n\tpodID, err := s.TokenClient.GetIdentities(r.Context(), podns, podname, tokenRequest.ClientID, tokenRequest.ResourceID)\n\tif err != nil {\n\t\tklog.Errorf(\"failed to get matching identities for pod: %s/%s, error: %+v\", podns, podname, err)\n\t\thttpErrorCode := http.StatusNotFound\n\t\tif s.SetRetryAfterHeader {\n\t\t\thttpErrorCode = http.StatusServiceUnavailable\n\t\t\t// setting it to 20s to allow MIC to finish processing current cycle and pick up this\n\t\t\t// pod in the next sync cycle\n\t\t\tw.Header().Set(headerRetryAfter, \"20\")\n\t\t}\n\t\thttp.Error(w, err.Error(), httpErrorCode)\n\t\treturn\n\t}\n\n\ttokens, err := s.TokenClient.GetTokens(r.Context(), tokenRequest.ClientID, tokenRequest.Resource, *podID)\n\tif err != nil {\n\t\tklog.Errorf(\"failed to get service principal token for pod: %s/%s, error: %+v\", podns, podname, err)\n\t\thttpErrorCode := http.StatusForbidden\n\t\tif auth.IsHealthCheckError(err) {\n\t\t\t// the adal library performs a health check prior to making the token request\n\t\t\t// if the health check fails, we want to return a 503 instead of 403\n\t\t\t// for health check failures, the error is not a token refresh error\n\t\t\thttpErrorCode = http.StatusServiceUnavailable\n\t\t}\n\t\thttp.Error(w, err.Error(), httpErrorCode)\n\t\treturn\n\t}\n\n\tvar v interface{}\n\tif len(tokens) == 1 {\n\t\tv = newMSIResponse(*tokens[0])\n\t} else {\n\t\tvar msiResp []msiResponse\n\t\tfor _, token := range tokens {\n\t\t\tmsiResp = append(msiResp, newMSIResponse(*token))\n\t\t}\n\t\tv = msiResp\n\t}\n\n\tresponse, err := json.Marshal(v)\n\tif err != nil {\n\t\tklog.Errorf(\"failed to marshal service principal token for pod: %s/%s, error: %+v\", podns, podname, err)\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tw.Header().Set(\"Content-Length\", strconv.Itoa(len(response)))\n\t_, _ = w.Write(response)\n\treturn\n}\n\n// Error replies to the request without the specified metadata header.\n// It does not otherwise end the request; the caller should ensure no further\n// writes are done to w.\nfunc metadataNotSpecifiedError(w http.ResponseWriter) {\n\tmetadataResp := MetadataResponse{\n\t\tError:            \"invalid_request\",\n\t\tErrorDescription: \"Required metadata header not specified\",\n\t}\n\tresponse, err := json.Marshal(metadataResp)\n\tif err != nil {\n\t\tklog.Errorf(\"failed to marshal metadata response, %+v\", err)\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\tw.WriteHeader(http.StatusBadRequest)\n\tfmt.Fprintln(w, string(response))\n}\n\nfunc parseMetadata(r *http.Request) (metadata string) {\n\treturn r.Header.Get(\"metadata\")\n}\n\nfunc parsePodInfo(r *http.Request) (podns string, podname string) {\n\tpodns = r.Header.Get(\"podns\")\n\tpodname = r.Header.Get(\"podname\")\n\n\treturn podns, podname\n}\n\nfunc parseRemoteAddr(addr string) string {\n\tn := strings.IndexByte(addr, ':')\n\tif n <= 1 {\n\t\treturn \"\"\n\t}\n\thostname := addr[0:n]\n\tif net.ParseIP(hostname) == nil {\n\t\treturn \"\"\n\t}\n\treturn hostname\n}\n\n// TokenRequest contains the client and resource ID token, as well as what resource the client is trying to access.\ntype TokenRequest struct {\n\t// ClientID identifies, by Azure AD client ID, a specific identity to use\n\t// when authenticating to Azure AD. It is mutually exclusive with\n\t// MsiResourceID.\n\t// Example: 77788899-f67e-42e1-9a78-89985f6bff3e\n\tClientID string\n\n\t// MsiResourceID identifies, by urlencoded ARM resource ID, a specific\n\t// identity to use when authenticating to Azure AD. It is mutually exclusive\n\t// with ClientID.\n\t// Example: /subscriptions/<subid>/resourcegroups/<resourcegroup>/providers/Microsoft.ManagedIdentity/userAssignedIdentities/<name>\n\tResourceID string\n\n\t// Resource is the urlencoded URI of the resource for the requested AD token.\n\t// Example: https://vault.azure.net.\n\tResource string\n}\n\n// ValidateResourceParamExists returns true if there exists a resource parameter from the request.\nfunc (r TokenRequest) ValidateResourceParamExists() bool {\n\t// check if resource exists in the request\n\t// if resource doesn't exist in the request, then adal libraries will return the same error\n\t// IMDS also returns an error with 400 response code if resource parameter is empty\n\t// this is done to emulate same behavior observed while requesting token from IMDS\n\treturn len(r.Resource) != 0\n}\n\nfunc parseTokenRequest(r *http.Request) (request TokenRequest) {\n\tvals := r.URL.Query()\n\tif vals != nil {\n\t\t// These are mutually exclusive values (client_id, msi_resource_id)\n\t\trequest.ClientID = vals.Get(\"client_id\")\n\t\trequest.ResourceID = vals.Get(\"msi_res_id\")\n\n\t\trequest.Resource = vals.Get(\"resource\")\n\t}\n\treturn request\n}\n\n// defaultPathHandler creates a new request and returns the response body and code\nfunc (s *Server) defaultPathHandler(w http.ResponseWriter, r *http.Request) {\n\tif s.MetadataHeaderRequired && parseMetadata(r) != \"true\" {\n\t\tklog.Errorf(\"metadata header is not specified, req.method=%s reg.path=%s req.remote=%s\", r.Method, r.URL.Path, parseRemoteAddr(r.RemoteAddr))\n\t\tmetadataNotSpecifiedError(w)\n\t\treturn\n\t}\n\n\tclient := &http.Client{}\n\treq, err := http.NewRequest(r.Method, r.URL.String(), r.Body)\n\tif err != nil || req == nil {\n\t\tklog.Errorf(\"failed creating a new request for %s, error: %+v\", r.URL.String(), err)\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\thost := fmt.Sprintf(\"%s:%s\", s.MetadataIP, s.MetadataPort)\n\treq.Host = host\n\treq.URL.Host = host\n\treq.URL.Scheme = \"http\"\n\tif r.Header != nil {\n\t\tcopyHeader(req.Header, r.Header)\n\t}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tklog.Errorf(\"failed executing request for %s, error: %+v\", req.URL.String(), err)\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\tklog.Errorf(\"failed to read response body for %s, error: %+v\", req.URL.String(), err)\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t}\n\tcopyHeader(w.Header(), resp.Header)\n\tw.WriteHeader(resp.StatusCode)\n\t_, _ = w.Write(body)\n}\n\n// forbiddenHandler responds to any request with HTTP 403 Forbidden\nfunc forbiddenHandler(w http.ResponseWriter, r *http.Request) {\n\thttp.Error(w, \"Request blocked by AAD Pod Identity NMI\", http.StatusForbidden)\n}\n\n// invalidTokenPathHandler responds to invalid token requests with HTTP 400 Bad Request\nfunc invalidTokenPathHandler(w http.ResponseWriter, r *http.Request) {\n\thttp.Error(w, \"Invalid request\", http.StatusBadRequest)\n}\n\nfunc copyHeader(dst, src http.Header) {\n\tfor k, vv := range src {\n\t\tfor _, v := range vv {\n\t\t\tdst.Add(k, v)\n\t\t}\n\t}\n}\n\nfunc handleTermination() {\n\tklog.Info(\"received SIGTERM, shutting down\")\n\n\texitCode := 0\n\t// clean up iptables\n\tif err := iptables.DeleteCustomChain(); err != nil {\n\t\tklog.Errorf(\"failed to clean up during shutdown, error: %+v\", err)\n\t\texitCode = 1\n\t}\n\n\t// wait for pod to delete\n\tklog.Info(\"handled termination, awaiting pod deletion\")\n\ttime.Sleep(10 * time.Second)\n\n\tklog.Infof(\"exiting with %v\", exitCode)\n\tos.Exit(exitCode)\n}\n", "package server\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/gorilla/mux\"\n)\n\nvar (\n\trtr       *mux.Router\n\tserver    *httptest.Server\n\ttokenPath = \"/metadata/identity/oauth2/token/\"\n)\n\nfunc setup() {\n\trtr = mux.NewRouter()\n\tserver = httptest.NewServer(rtr)\n}\n\nfunc teardown() {\n\tserver.Close()\n}\n\nfunc TestMsiHandler_NoMetadataHeader(t *testing.T) {\n\tsetup()\n\tdefer teardown()\n\n\ts := &Server{\n\t\tMetadataHeaderRequired: true,\n\t}\n\trtr.PathPrefix(\"/{type:(?i:metadata)}/identity/oauth2/token/\").Handler(appHandler(s.msiHandler))\n\n\treq, err := http.NewRequest(http.MethodGet, tokenPath, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\trecorder := httptest.NewRecorder()\n\trtr.ServeHTTP(recorder, req)\n\n\tif recorder.Code != http.StatusBadRequest {\n\t\tt.Errorf(\"Unexpected status code %d\", recorder.Code)\n\t}\n\n\tresp := &MetadataResponse{\n\t\tError:            \"invalid_request\",\n\t\tErrorDescription: \"Required metadata header not specified\",\n\t}\n\texpected, err := json.Marshal(resp)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif string(expected) != strings.TrimSpace(recorder.Body.String()) {\n\t\tt.Errorf(\"Unexpected response body %s\", recorder.Body.String())\n\t}\n}\n\nfunc TestMsiHandler_NoRemoteAddress(t *testing.T) {\n\tsetup()\n\tdefer teardown()\n\n\ts := &Server{\n\t\tMetadataHeaderRequired: false,\n\t}\n\trtr.PathPrefix(\"/{type:(?i:metadata)}/identity/oauth2/token/\").Handler(appHandler(s.msiHandler))\n\n\treq, err := http.NewRequest(http.MethodGet, tokenPath, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\trecorder := httptest.NewRecorder()\n\trtr.ServeHTTP(recorder, req)\n\n\tif recorder.Code != http.StatusInternalServerError {\n\t\tt.Errorf(\"Unexpected status code %d\", recorder.Code)\n\t}\n\n\texpected := \"request remote address is empty\"\n\tif expected != strings.TrimSpace(recorder.Body.String()) {\n\t\tt.Errorf(\"Unexpected response body %s\", recorder.Body.String())\n\t}\n}\n\nfunc TestParseTokenRequest(t *testing.T) {\n\tconst endpoint = \"http://127.0.0.1/metadata/identity/oauth2/token\"\n\n\tt.Run(\"query present\", func(t *testing.T) {\n\t\tconst resource = \"https://vault.azure.net\"\n\t\tconst clientID = \"77788899-f67e-42e1-9a78-89985f6bff3e\"\n\t\tconst resourceID = \"/subscriptions/9f2be85c-f8ae-4569-9353-38e5e8b459ef/resourcegroups/test/providers/Microsoft.ManagedIdentity/userAssignedIdentities/test\"\n\n\t\tvar r http.Request\n\t\tr.URL, _ = url.Parse(fmt.Sprintf(\"%s?client_id=%s&msi_res_id=%s&resource=%s\", endpoint, clientID, resourceID, resource))\n\n\t\tresult := parseTokenRequest(&r)\n\n\t\tif result.ClientID != clientID {\n\t\t\tt.Errorf(\"invalid ClientID - expected: %q, actual: %q\", clientID, result.ClientID)\n\t\t}\n\n\t\tif result.ResourceID != resourceID {\n\t\t\tt.Errorf(\"invalid ResourceID - expected: %q, actual: %q\", resourceID, result.ResourceID)\n\t\t}\n\n\t\tif result.Resource != resource {\n\t\t\tt.Errorf(\"invalid Resource - expected: %q, actual: %q\", resource, result.Resource)\n\t\t}\n\t})\n\n\tt.Run(\"bare endpoint\", func(t *testing.T) {\n\t\tvar r http.Request\n\t\tr.URL, _ = url.Parse(endpoint)\n\n\t\tresult := parseTokenRequest(&r)\n\n\t\tif result.ClientID != \"\" {\n\t\t\tt.Errorf(\"invalid ClientID - expected: %q, actual: %q\", \"\", result.ClientID)\n\t\t}\n\n\t\tif result.ResourceID != \"\" {\n\t\t\tt.Errorf(\"invalid ResourceID - expected: %q, actual: %q\", \"\", result.ResourceID)\n\t\t}\n\n\t\tif result.Resource != \"\" {\n\t\t\tt.Errorf(\"invalid Resource - expected: %q, actual: %q\", \"\", result.Resource)\n\t\t}\n\t})\n}\n\nfunc TestTokenRequest_ValidateResourceParamExists(t *testing.T) {\n\ttr := TokenRequest{\n\t\tResource: \"https://vault.azure.net\",\n\t}\n\n\tif !tr.ValidateResourceParamExists() {\n\t\tt.Error(\"ValidateResourceParamExists should have returned true when the resource is set\")\n\t}\n\n\ttr.Resource = \"\"\n\tif tr.ValidateResourceParamExists() {\n\t\tt.Error(\"ValidateResourceParamExists should have returned false when the resource is unset\")\n\t}\n}\n\nfunc TestRouterPathPrefix(t *testing.T) {\n\ttests := []struct {\n\t\tname               string\n\t\turl                string\n\t\texpectedStatusCode int\n\t\texpectedBody       string\n\t}{\n\t\t{\n\t\t\tname:               \"token request\",\n\t\t\turl:                \"/metadata/identity/oauth2/token/\",\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\texpectedBody:       \"token_request_handler\",\n\t\t},\n\t\t{\n\t\t\tname:               \"token request without / suffix\",\n\t\t\turl:                \"/metadata/identity/oauth2/token\",\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\texpectedBody:       \"token_request_handler\",\n\t\t},\n\t\t{\n\t\t\tname:               \"token request with upper case metadata\",\n\t\t\turl:                \"/Metadata/identity/oauth2/token/\",\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\texpectedBody:       \"token_request_handler\",\n\t\t},\n\t\t{\n\t\t\tname:               \"token request with upper case identity\",\n\t\t\turl:                \"/metadata/Identity/oauth2/token/\",\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\texpectedBody:       \"default_handler\",\n\t\t},\n\t\t{\n\t\t\tname:               \"host token request\",\n\t\t\turl:                \"/host/token/\",\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\texpectedBody:       \"host_token_request_handler\",\n\t\t},\n\t\t{\n\t\t\tname:               \"host token request without / suffix\",\n\t\t\turl:                \"/host/token\",\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\texpectedBody:       \"host_token_request_handler\",\n\t\t},\n\t\t{\n\t\t\tname:               \"instance metadata request\",\n\t\t\turl:                \"/metadata/instance\",\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\texpectedBody:       \"instance_request_handler\",\n\t\t},\n\t\t{\n\t\t\tname:               \"instance metadata request with upper case metadata\",\n\t\t\turl:                \"/Metadata/instance\",\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\texpectedBody:       \"instance_request_handler\",\n\t\t},\n\t\t{\n\t\t\tname:               \"instance metadata request / suffix\",\n\t\t\turl:                \"/Metadata/instance/\",\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\texpectedBody:       \"instance_request_handler\",\n\t\t},\n\t\t{\n\t\t\tname:               \"default metadata request\",\n\t\t\turl:                \"/metadata/\",\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\texpectedBody:       \"default_handler\",\n\t\t},\n\t\t{\n\t\t\tname:               \"invalid token request with \\\\oauth2\",\n\t\t\turl:                `/metadata/identity\\oauth2/token/`,\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\texpectedBody:       \"invalid_request_handler\",\n\t\t},\n\t\t{\n\t\t\tname:               \"invalid token request with \\\\token\",\n\t\t\turl:                `/metadata/identity/oauth2\\token/`,\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\texpectedBody:       \"invalid_request_handler\",\n\t\t},\n\t\t{\n\t\t\tname:               \"invalid token request with \\\\oauth2\\\\token\",\n\t\t\turl:                `/metadata/identity\\oauth2\\token/`,\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\texpectedBody:       \"invalid_request_handler\",\n\t\t},\n\t\t{\n\t\t\tname:               \"invalid token request with mix of / and \\\\\",\n\t\t\turl:                `/metadata/identity/\\oauth2\\token/`,\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\texpectedBody:       \"invalid_request_handler\",\n\t\t},\n\t\t{\n\t\t\tname:               \"invalid token request with multiple \\\\\",\n\t\t\turl:                `/metadata/identity\\\\\\oauth2\\\\token/`,\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\texpectedBody:       \"invalid_request_handler\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tsetup()\n\t\t\tdefer teardown()\n\n\t\t\trtr.PathPrefix(tokenPathPrefix).HandlerFunc(testTokenHandler)\n\t\t\trtr.MatcherFunc(invalidTokenPathMatcher).HandlerFunc(testInvalidRequestHandler)\n\t\t\trtr.PathPrefix(hostTokenPathPrefix).HandlerFunc(testHostTokenHandler)\n\t\t\trtr.PathPrefix(instancePathPrefix).HandlerFunc(testInstanceHandler)\n\t\t\trtr.PathPrefix(\"/\").HandlerFunc(testDefaultHandler)\n\n\t\t\treq, err := http.NewRequest(http.MethodGet, test.url, nil)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\trecorder := httptest.NewRecorder()\n\t\t\trtr.ServeHTTP(recorder, req)\n\n\t\t\tif recorder.Code != test.expectedStatusCode {\n\t\t\t\tt.Errorf(\"unexpected status code %d\", recorder.Code)\n\t\t\t}\n\n\t\t\tif test.expectedBody != strings.TrimSpace(recorder.Body.String()) {\n\t\t\t\tt.Errorf(\"unexpected response body %s\", recorder.Body.String())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc testTokenHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"token_request_handler\\n\")\n}\n\nfunc testHostTokenHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"host_token_request_handler\\n\")\n}\n\nfunc testInstanceHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"instance_request_handler\\n\")\n}\n\nfunc testDefaultHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"default_handler\\n\")\n}\n\nfunc testInvalidRequestHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"invalid_request_handler\\n\")\n}\n"], "filenames": ["pkg/nmi/server/server.go", "pkg/nmi/server/server_test.go"], "buggy_code_start_loc": [40, 219], "buggy_code_end_loc": [583, 265], "fixing_code_start_loc": [41, 220], "fixing_code_end_loc": [608, 301], "type": "NVD-CWE-noinfo", "message": "aad-pod-identity assigns Azure Active Directory identities to Kubernetes applications and has now been deprecated as of 24 October 2022. The NMI component in AAD Pod Identity intercepts and validates token requests based on regex. In this case, a token request made with backslash in the request (example: `/metadata/identity\\oauth2\\token/`) would bypass the NMI validation and be sent to IMDS allowing a pod in the cluster to access identities that it shouldn't have access to. This issue has been fixed and has been included in AAD Pod Identity release version 1.8.13. If using the AKS pod-managed identities add-on, no action is required. The clusters should now be running the version 1.8.13 release.", "other": {"cve": {"id": "CVE-2022-23551", "sourceIdentifier": "security-advisories@github.com", "published": "2022-12-21T20:15:09.490", "lastModified": "2023-01-04T19:54:14.517", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "aad-pod-identity assigns Azure Active Directory identities to Kubernetes applications and has now been deprecated as of 24 October 2022. The NMI component in AAD Pod Identity intercepts and validates token requests based on regex. In this case, a token request made with backslash in the request (example: `/metadata/identity\\oauth2\\token/`) would bypass the NMI validation and be sent to IMDS allowing a pod in the cluster to access identities that it shouldn't have access to. This issue has been fixed and has been included in AAD Pod Identity release version 1.8.13. If using the AKS pod-managed identities add-on, no action is required. The clusters should now be running the version 1.8.13 release."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:R/S:U/C:L/I:H/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.6, "impactScore": 4.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:R/S:U/C:L/I:H/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.6, "impactScore": 4.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-1259"}, {"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:microsoft:azure_ad_pod_identity:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.8.13", "matchCriteriaId": "3428D360-1FFE-4291-80B0-9EFB6F173AE6"}]}]}], "references": [{"url": "https://github.com/Azure/aad-pod-identity/commit/7e01970391bde6c360d077066ca17d059204cb5d", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Azure/aad-pod-identity/releases/tag/v1.8.13", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/Azure/aad-pod-identity/security/advisories/GHSA-p82q-rxpm-hjpc", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Azure/aad-pod-identity/commit/7e01970391bde6c360d077066ca17d059204cb5d"}}