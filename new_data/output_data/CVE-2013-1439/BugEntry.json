{"buggy_code": ["2013-08-07 Alex Tutubalin <lexa@lexa.ru>\n  * New camera/format support:\n     Richon GR\n     Panasonic LF1\n     Canon EOS 70D\n     Sony RX100II, RX1R\n     Olympus E-P5\n  * Generalized size copy from RawSpeed data\n\n2013-07-04 Alex Tutubalin <lexa@lexa.ru>\n  * New camera/format support:\n     OmniVision OV5647 (Raspberry Pi)\n     Nikon D5200\n     Panasonic DMC-GF6\n  * Fixed decoding error for some Canon sRAW files.\n  * LibRaw 0.15.3\n\n2013-05-26 Alex Tutubalin <lexa@lexa.ru>\n  * Fixed possible double-free() on error recovery on damaged full-color\n    (Foveon, sRAW) files.\n  * wchar_t* file interface disabled for MinGW32 compilation\n  * LibRaw 0.15.2\n\n2013-05-25 Alex Tutubalin <lexa@lexa.ru>\n  * fixed wrong data maximum calculation for Panasonic files\n  * check for possible buffer overrun in exposure correction code\n  * LibRaw 0.15.1\n      \n2013-05-23 Alex Tutubalin <lexa@lexa.ru>\n\n LibRaw 0.15-Release\n \n New camera/format support:\n  * Adobe DNG:\tfast Load DNG (LightRoom 4.x), support for \n\t\tlossy-compressed DNG (LR 4.x, requires libjpeg 6+)\n  * Canon:\tG1 X, SX220 HS, EOS 5D Mark III, EOS 650D, EOS 1D-X, \n\t\t100D (Rebel SL1), 700D (Rebel T5i), 6D, EOS M, G15, S110, SX50\n  * Casio:\tEX-ZR100,EX-Z8\n  * Fujifilm:\tX-S1, HS30EXR, X1-Pro,X-E1, X20, X100S, SL1000, HS50EXR,\n  \t\tF800EXR, XF1\n  * Leica:\tD-LUX6 and V-LUX4\n  * Nikon:\tD4, D3200, D800, D800E, 1 J2, 1 V2, D600, 1 J3, 1 S1, Coolpix A,\n\t\tCoolpix P330, Coolpix P7700, D7100\n  * Olympus:\tE-M5, XZ-2, XZ-10, E-PL5, E-PM2\n  * Panasonic:\tG5, G6, DMC-GF5, FZ200, GH3, LX7\n  * Pentax:\tMX-1, K-5 II, K-5 IIs, K-30, Q10\n  * Samsung:\tEX2F, NX20, NX210, support for the new firmware for NX100\n  * Sigma:\tSD15, SD1, SD1 Merill, DP1, DP1S, DP1X, DP2, DP2S, DP2X \n\t\t(only with Demosaic-pack-GPL2)\n  * Sony:\tSLT-A58, RX-1, SLT-A99, NEX-5R, NEX-6, NEX-F3, SLT-A37, SLT-A57\n  * Multishot files:\tImacon Ixpress 39Mpix\n\nAPI changes:\n  1. dcraw_process() can now be called several times with different parameters \n     without re-opening and unpacking the file for second and consecutive \n     calls to dcraw_process\n\n  2. deleted (nobody uses those)\n   - LibRaw::dcraw_document_mode_processing  (and respective C-API)\n   - imgdata.color.color_flags data field\n\n  3. LibRaw::unpack() now decodes data into different buffers, the buffer\n     depends on the raw data type\n     - imgdata.rawdata.raw_image - 1 color component per pixel, \n       for b/w and Bayer type sensors\n     - imgdata.rawdata.color3_image - 3 color components per pixel, \n       sRAW/mRAW files, RawSpeed decoding\n     - imgdata.rawdata.color4_image - 4 components per pixel, the 4th \n       component can be void\n\n   4. Support for compiling with RawSpeed library, http://rawstudio.org/blog/?p=800\n      details are in README.RawSpeed\n\n   5. Suppression of banding\n\n   6. New API calls\n     - recycle_datastream(), \n     - open_file(wchar_t*) (Win32)\n\n\n2012-04-05 Alex Tutubalin <lexa@lexa.ru>\n        * Casio EX-Z500 support\n        * (possible) I/O exceptions on file open catched in open_datastream\n        * Fixed possible read-after-buffer in Sony ARW2 decoder\n        * Fixed mingw32 errors when compiling LibRaw_windows_datastream\n        * Makefile.msvc: support of OpenMP and LCMS (uncomment to use)\n        * Fixed decoding of some Leaf Aptus II files\n        * LibRaw 0.14.6-Release\n\n2011-12-24 Alex Tutubalin <lexa@lexa.ru>\n        * Fixed bug (uninitialized variable) in SMAL format decoding.\n\n        * Imported new dcraw 9.12 (1.446): support for Leica V-LUX 3, \n          updated color data for Canon S100, Fujifilm X10, Nikon 1 J1/V1,\n          Panasonic GX1, Samsung NX200, Sony NEX-7\n\n        * LibRaw 0.14.5-Release\n\n2011-12-12 Alex Tutubalin <lexa@lexa.ru>\n\n        * Fixes to Panasonic/Leica file parser to prevent crash\n          on broken jpegs.\n\n        * Fixes to include order in src/libraw_datastream.cpp to\n          better compile with KDEWIN\n\n        * Floating-point DNGs are rejected on early processing stage.\n\n        * Support for new cameras: Canon S100, Fuji X10, Panasonic GX1, \n          Samsung NX200, Sony NEX-7.\n\n        * LibRaw 0.14.4-Release\n          \n\n2011-10-26 Alex Tutubalin <lexa@lexa.ru>\n        * Bug fixes in black level subtraction code for PhaseOne files\n\n        * New API call LibRaw::get_internal_data_pointer() for developers\n           who need access to libraw_internal_data fields (i.e. \n           Fuji SuperCCD layout).\n\n        *  doc/API-overview fixes to reflect 0.14 changes\n\n        * LibRaw 0.14.3-Release\n\n2011-10-19 Alex Tutubalin <lexa@lexa.ru>\n        * Fixed bug in Canon 1D and 1Ds files decoding.\n        * New decoder information bit DECODER_HASRAWCURVE \n        * LibRaw 0.14.2-Release\n\n2011-10-11 Alex Tutubalin <lexa@lexa.ru>\n        * Imported dcraw 9.11/1.445:\n          + Support for new cameras added: Fujifilm F600EXR, Nikon P7100,\n            Olympus E-PL3 and E-PM1, Panasonic DMC-FZ150, Sony NEX-5N, \n            A65 and A77.\n          + Changed color data for: Olympus E-P3, Panasonic G3 and GF3,\n            PhaseOne H25, P40 and P65, Sony NEX-C3, NEX-5, NEX-3, A35 and A55.\n          + Support for dark frame extraction on Sony cameras.\n\n        * DCB demosaicing: reserving 6 pixels instead of 3 to suppress \n          colored image frame.\n        * LibRaw 0.14.1-Release\n\n2011-09-21 Alex Tutubalin <lexa@lexa.ru>\n        * Cosmetic changes to make Visual C++/OpenMP more happy\n        * Fix megapixel calculation for postprocessing_benchmark in half mode\n        * Shlib version number increment\n        * LibRaw 0.14.0-Release\n\n2011-09-04 Alex Tutubalin <lexa@lexa.ru>\n        * Fixed bug with Kodak thumbnail extraction\n        * raw2image_ex() always return value\n        * LibRaw 0.14.0-Beta2\n\n2011-09-02 Alex Tutubalin <lexa@lexa.ru>\n        * Cosmetic changes to LibRaw_file_datastream interface\n\n        * OpenMP speedup of postprocessing steps (up to 50% for\n          half mode and 4-core machine)\n\n        * LibRaw 0.14.0-Beta1\n\n2011-08-20 Alex Tutubalin <lexa@lexa.ru>\n\n        * Patch to dcraw_emu for SunStudio compiler compatibility\n\n        * Fixed crash in unprocessed_raw sample due to uninitialized\n          timestamp variable.\n\n        * Fixed crash in raw decoding if raw_width/raw_height is\n          less than resulting image width/height.\n\n        * imgdata.sizes.flip is set from user_flip only on\n          postprocessing and/or adjust_sizes_info_only()\n\n        * Fixed buffer overrun for some LJPEG-compressed files\n\n        * Most of LibRaw_datastream function bodies are moved to\n          separate source file\n\n        * LibRaw_windows_datastream is merged to main sourcetree\n\n        * LibRaw 0.14.0-Alpha5\n\n2011-08-11 Alex Tutubalin <lexa@lexa.ru>\n        * Imported dcraw 9.10 (1.444), support for new cameras added:\n          ARRIRAW format, Canon SX30 IS, Leica D-LUX 5 and V-LUX2,\n          Olympus E-P3, Panasonic G3 and GF3, Sony NEX-C3 and SLT-A35\n          \n        * Support for RedOne digital movie cameras (R3D format). \n          To enable this support you should:\n           + install libjasper JPEG2000 support library\n\n           + compile LibRaw with -DUSE_JASPER compiler switch (./configure\n             will do it for you)\n\n           + If you use own LibRaw_datastream implementation, you should\n             implement make_jas_stream() call for your datastream. See\n             bottom of src/libraw_cxx.cpp for  implementations in datafile\n             and mem-buffer LibRaw streams.\n\n        * Bugfix: green matching is turned off if output image is shrinked\n          due to wavelet filtering or aberration correction.\n\n        * fixed open_file()/adjust_sizes_info_only() code path\n\n        * Removed imgdata.sizes.bottom_margin and right_margin data fields\n          use imgdata.sizes.raw_width - width - left_margin to get right one,\n          the same with bottom_margin.\n\n        * minor ./configure cleanup\n        \n        * Qmake files and Visual Studio Project files are updated.\n\n        * New version check macros:\n          For use at runtime checks:\n           LIBRAW_RUNTIME_CHECK_VERSION_EXACT() - checks  that runtime \n            major/minor version numbers are same with compile-time values.\n\n           LIBRAW_RUNTIME_CHECK_VERSION_NOTLESS() - checks that runtime\n            version is not less that compile-time one.\n\n          For use at compile-time in preprocessor directives:\n           LIBRAW_COMPILE_CHECK_VERSION_EXACT(major,minor) - Compile-time\n            check that LibRaw version is exact major.minor.\n\n           LIBRAW_COMPILE_CHECK_VERSION_NOTLESS(major,minor) - Compile-time\n            check that version is not less than major.minor.\n\n        * all client code should be recompiled due to internals change.\n\n        * LibRaw 0.14.0-Alpha4\n\n2011-07-19 Alex Tutubalin <lexa@lexa.ru>\n        * New sample samples/postprocessing_benchmark.cpp\n          This sample measures postprocessing speed.\n          All demosaic methods, averaged white balance, median\n          filtering, wavelet filtration, highlight recovery, and\n          cropping are supported.\n\n        * Removed LibRaw::rotate_fuji_raw() call and corresponding C-API call.\n\n        * The LibRaw::adjust_sizes_info_only() call may be called repeated\n          and mixed with dcraw_process() call.\n\n        * Postprocessing speedup and optimization, especially if cropping set.\n\n        * Cropping works for FujiCCD raws. For the technical reasons, the position\n          of top-left corner of crop area will be rounded to the nearest\n          multiple of 4 (the corner is shifted top-left).\n\n        * LibRaw 0.14.0-Alpha3\n\n2011-07-15 Alex Tutubalin <lexa@lexa.ru>\n        * imported cropping code from 0.13 branch\n\n2011-07-12 Alex Tutubalin <lexa@lexa.ru>\n        * samples/multirender_test - check for different clip settings\n\n2011-07-11 Alex Tutubalin <lexa@lexa.ru>\n        * New call LibRaw::free_image(), deallocates imgdata.image buffer.\n          Use this call if current postprocessing results are not\n          needed, but it is to early to call recycle() because\n          dcraw_process() may be called later.\n\n        * New C-API calls\n          libraw_raw2image() - C API for LibRaw::raw2image()\n          libraw_free_image() - C API for LibRaw::free_image()\n          libraw_get_decoder_info() - C API for LibRaw::get_decoder_info()\n\n        * Bugfix: change of params.user_flip aftee open()/unpack()\n          calls should work.\n\n        * LibRaw 0.14.0-Alpha2\n\n2011-07-10 Alex Tutubalin <lexa@lexa.ru>\n        * Multiple rendering (LibRaw::dcraw_process() calls) allowed\n          without re-opening RAW file thrfough the sequence of open()/unpack()\n          calls.\n          You should be able to change any processing parameters (except\n          shot_select parameter) between dcraw_process() calls.\n\n          + New sample in samples/multirender_test.cpp: renders data 4 times:\n            in half and full modes with different white balance settings.\n\n          + Unprocessed RAW data is stored in separate data buffer:\n            (2 bytes per pixel for all Bayer-pattern images,\n            8 bytes per pixel for Foveon, sRAW, and other full-color raw \n            formats), so now LibRaw uses 25% more memory for full processing of \n            most common Bayer images; while for just unpack memory is reduced \n            4 times.\n\n          + New call LibRaw::raw2image() fills imgdata.image array\n            with fresh copy of data.\n            There is no need to call raw2image() separately if you use \n            dcraw_process() or dcraw_document_mode_processing() calls.\n\n          + New call LibRaw::get_decoder_info() to determine raw data\n            storage layout. See samples/unprocessed_raw.cpp for an example \n            of how to use it.\n\n        If your code uses usual open()/unpack()/dcraw_process() call\n        sequence, then NOTHING CHANGED: your program should produce same\n        results. For interactive programs you may skip open()/unpack()\n        calls after adjusting processing parameters, so user should see\n        image refreshed much faster.\n\n        If your code uses raw data (open+unpack calls), you need to call\n        LibRaw::raw2image(), and imgdata.image will contain same bitmap\n        as in LibRaw 0.13.x\n\n        If you code uses access to masked borders data, you need to\n        rewrite it. See samples/unprocessed_raw.cpp as a sample.\n\n        Unfortunately, documentation is untouched yet. This problem will be\n        fixed in next Alpha release.\n\n        Other changes:\n\n        * No separate imgdata.masked_pixels buffers, Bayer raw formats are read\n          to buffer with borders. So, no ugly add_masked_border_to_bitmap()\n          call.\n\n        * No filtering_mode parameter. Raw tone curve is applied \n          at unpack() stage; zero pixels removed on postprocesing stage.\n\n        * unprocessed_raw and 4colors samples are adjusted to use\n          new RAW data storage layout.\n\n        * all client code should be recompiled due to internals change.\n\n        * LibRaw 0.14.0-Alpha1\n\n2011-07-03 Alex Tutubalin <lexa@lexa.ru>\n        * Cosmetic cleanup in Libraw_memmgr code\n\n        * Permit OpenMP support on MS VS2008\n\n        * More general mem_image interface:\n          + New call get_mem_image_format returns bitmap size and bit depth\n          + New call copy_mem_image can copy bitmap into buffer with \n            different color order (RGB/BGR) and line stride\n          + dcraw_make_mem_image() uses calls mentioned above\n          + see documentation for info on these function parameters.\n\n        * libraw/librawwindows.h implements LibRaw_datastream class based\n          on Windows memory mapped files.Win32/64-only \n          Thanks to Linc Brookes.\n\n        * Fixed parallel make errors in configure/Makefile.am\n\n        * LibRaw 0.13.6-Release\n\n        \n2011-05-18 Alex Tutubalin <lexa@lexa.ru>\n        * Imported new dcraw 9.08/1.443:\n           + New color data for Canon 600D and 1100D, Fuji S200EXR\n           + New camera supported: Fuji HS20EXR and F550EXR, Kodak Z990, \n                                   Nikon D5100, Olympus E-PL1s and XZ-1, \n                                   Samsung NX11, Sony A230 and 290.\n        * LibRaw 0.13.5-Release\n\n2011-04-02 Alex Tutubalin <lexa@lexa.ru>\n        * Imported new dcraw 9.07/1.442:\n          + Support for Canon 600D and 1100D, Hasselblad H4D-60,\n            Olympus E-PL2\n        * Color data for Leaf Aptus II and Canon Powershot S2 IS\n        * LibRaw 0.13.4-Release\n\n2011-03-30 Alex Tutubalin <lexa@lexa.ru>\n        * Preliminary support for Leaf Aptus II cameras (no color data yet):\n          Leaf Aptus II 6,7,8,10 and 12 are tested, Aptus II 5 should work.\n        * Preliminary support for Fujifilm X100 camera (again, no color data).\n        * Fixed possible after the end of buffer read when working with\n          in-memory data.\n        * Fixed possible loss of JPEG stream sync marks in LJPEG decoder\n          (this bug was found only for Leaf Aptus II RAWs).\n        * LibRaw 0.13.3-Release\n\n2011-03-08 Alex Tutubalin <lexa@lexa.ru>\n        * Fixed broken camera white balance reading for some Sony cameras\n        * LibRaw 0.13.2-Release\n\n2011-02-25 Alex Tutubalin <lexa@lexa.ru>\n\t* Sony A390 support (colordata from A380)\n\t* Leica D-LUX 4: fixed typo in camera name in colordata\n\n2011-02-15 Alex Tutubalin <lexa@lexa.ru>\n\t* New -mem option for dcraw_emu: I/O via allocated buffer\n\t* Removed debug printf from LibRaw_memory_buffer code\n\t* Preliminary shared library support\n\n2011-02-12 Alex Tutubalin <lexa@lexa.ru>\n\t* Added qmake .pro and Visual Studio 2008 sln/vcproj project files\n2011-02-07 Alex Tutubalin <lexa@lexa.ru>\n        * dcraw_emu documentation updated\n        * ./configure stuff changed for correct linking on some systems        \n        * FBDD denoising is disabled for full-color images and 4-color bayer\n          data (including forced 4-color via four_color_rgb option)\n        * LibRaw 0.13.1-Release\n\n2011-02-05 Alex Tutubalin <lexa@lexa.ru>\n        * ./configure fixes for PACKAGE_REQUIRES\n        * Makefile.msvc: correct compiler flags for demosaic packs\n        * dcraw.c 9.06/1.440 imported:\n          + New camera support: Canon S95, Casio EX-Z1080, Panasonic GF2 \n            and GH2, Samsung NX100, Sony A-580\n          + New color data for: Canon G12, Nikon D3100, D7000 and P7000,\n            Olympus E-5, Pentax K-r and K-5, Samsung NX10 and WB2000 \n        * green_matching() code is disabled for half-size processing\n        * LibRaw 0.13.0-Release\n\n2011-01-15 Alex Tutubalin <lexa@lexa.ru>\n        * Fallback to old huffman decoder for Sony files with unspecified\n          data length (Sony A100)\n        * Fixed incomplete data fields reset in LibRaw::recycle()\n        * LibRaw 0.13.0-Beta3\n   \n2011-01-13 Alex Tutubalin <lexa@lexa.ru>\n        * Better parsing of unknown command-line params in dcraw_emu sample\n        * Brigtness table in ahd_demosaic is calculated in reversed order\n          to prevent possible (very unlikely) multithreaded app problem.\n        * New exposure correction code based on linear-cubic root combination.\n          New working correction range is from 0.25 (-2 stops) to 8 (+3 stops)\n        * LibRaw 0.13.0-Beta2\n\n2011-01-10 Alex Tutubalin <lexa@lexa.ru>\n\t* Fixed file extension in half_mt.c sample\n\n2011-01-10 Alex Tutubalin <lexa@lexa.ru>\n\t* Three patches provided by Jacques Desmis:\n          - Exposure correction before demosaic (demosaic pack GPL3)\n\t  - OpenMP speed-up in median filters (demosaic pack GPL2)\n\t  - OpenMP speed-up in green equilibration (demosaic pack GPL3)\n\t* Merged 0.12.2-0.12.3 changes:\n          - Patches for ./configure system for better LCMS2 support\n\t  - Patches for ./configure system\n\t  - math.h included before any other includes to make KDE compile\n\t    with Visual C++ happy\n\t  - Fuji FinePix S5500 size adjusted to ignore (rare?) garbage \n\t    at top of frame.\n        * all client code should be recompiled due to internals change.\n        * LibRaw 0.13.0-Beta1\n\n2010-12-22 Alex Tutubalin <lexa@lexa.ru>\n        * Zero copy huffman buffer for LibRaw_buffer_datastream\n        * Fixed memory leak in compressed NEFs handling\n        * LibRaw 0.13.0-Alpha2\n\n2010-12-20 Alex Tutubalin <lexa@lexa.ru>\n        * Demosaic-pack-GPL3 changes:\n          + New noise reduction methods before demosaic \n             - Banding suppression\n             - High-frequency noise suppression\n             - Green channel equalization\n          + New chromatic abberration correction.\n          All three methods are written by Emil Martinec for Raw Therapee.\n          Adapted to LibRaw by Jacques Desmis\n\n        * Merged Foveon code fix from LibRaw 0.12.1\n\n        * LJPEG decompressor speed-up (about 1.5 times for Canon cameras\n          and slightly less for others). Some ideas are from RawSpeed library.\n\n        * all client code should be recompiled due to internals change.\n\n        * LibRaw 0.13.0-Alpha1\n\n2010-12-12 Alex Tutubalin <lexa@lexa.ru>\n\t* Thread-safe and demosaic packs support for MinGW build\n\t* Demosaic packs support for MS VC build\n        * LibRaw 0.12.0-Release\n\n2010-12-09 Alex Tutubalin <lexa@lexa.ru>\n        * Fixed bug in add_masked_borders_to_bitmap() call for cameras\n          with odd pixels border.\n        * New command line options for unprocessed_raw sample:\n           -B - subtract black level, -M - add masked pixels to bitmap.\n        * Foveon-sensor cameras added to supported camera list if\n          compiled with demosaic pack GPL2 \n        * LibRaw 0.12.0-Beta4\n\n2010-12-05 Alex Tutubalin <lexa@lexa.ru>\n        * Demosaic packs support in Makefile.dist\n        * Foveon support in LibRaw demosaic pack GPL2 \n        * all client code should be recompiled due to internals change.\n        * LibRaw 0.12.0-Beta3\n\n2010-11-27 Alex Tutubalin <lexa@lexa.ru>\n        * Fixed allocation bug in lmmse_interpolation (demosaic-pack-GPL2)\n\t* In LMMSE and AMaZE interpolators allocation changed to calloc\n\t  to make valgrind happy with uninitialized values\n        * Changes in distribution-making scripts\n        * LibRaw 0.12.0-Beta2\n\n2010-11-21 Alex Tutubalin <lexa@lexa.ru>\n\t* Fixes to green_matching code by Sergey Pavlov\n\n2010-11-20 Alex Tutubalin <lexa@lexa.ru>\n        * Update for new demosaic-pack-GPL3\n\t* LibRaw 0.12.0-Beta1\n\n2010-11-19 Alex Tutubalin <lexa@lexa.ru>\n        * Demosaic pack(s) supported via ./configure   \n\n2010-11-17 Alex Tutubalin <lexa@lexa.ru>\n\t* LCMS2 support\n\t* afd_interpolate(2,1) instead of (5,0)\n        * dcraw_emu sample command line keys added and reordered\n          to reflect changes in LibRaw 0.12. \n\t* Nikon P7000: color matrix data and black level patch for ISO >=400\n\t  Thanks to Gunnar Thorburn \n        * Support for several industrial cameras based on Sony ICX 625/655 \n\t  sensor: JAI BB500CL/GE, SVS625CL, ptGrey GRAS-50S5C\n\t  Thanks to kaare\n\n2010-11-15 Alex Tutubalin <lexa@lexa.ru>\n\n        * Several demosaic algorithms, found in other open-source RAW processing\n          packages are implemented in LibRaw. \n\n          1) DCB demosaic and FBDD denoise by Jacek Gozdz are included in \n             main LibRaw source.\n          2) GPL2 demosaic pack with these demosaic methods:\n             * AFD and LMMSE implementations from PerfectRaw by Manuel Llorens\n             * VCD, Modified AHD, post-demosaic refinemend and median\n               filters by Paul Lee\n          3) GPL3 demosaic pack with AMaZe interpolation  by Emil Martinec\n\n          See more details in README.demosaic-packs\n        \n        * Current implementation of dcraw_emu sample allows only selection\n          of demosaic method (via -q) options. All other parameters change\n          will be implemented later.\n\n\t* LibRaw 0.12-alpha1\n\n2010-11-11 Alex Tutubalin <lexa@lexa.ru>\n\t* Imported 0.11(2) version changes:\n\t  + Fixed dcraw_emu command line processing code\n          + OpenMP is completely disabled on MacOS X if compiled with -pthread\n            due to well-known MacOS problem.\n          + dcraw 9.05 (1.439) imported, many new cameras supported:\n              Canon: G12, SX120, 60D,\n              Hasselblad H4D, Nokia X2, Olympus E-5,\n              Nikon: D3100, D7000, P7000,\n              Panasonic: FZ40, FZ100, LX5,\n              Pentax: K-r, K-5, 645D,\n              Samsung GX20, WB2000\n\t* LibRaw 0.12-alpha0\n\n2010-11-08 Alex Tutubalin <lexa@lexa.ru>\n\t* Fixes for Sun Studio compiler compatibility\n\t* Fixes for Visual Studio 2010 compatibility\n\t* All russian-language files are converted to UTF-8\n\t* LibRaw 0.11.0-Release\n\n2010-10-18 Alex Tutubalin <lexa@lexa.ru>\n           * Disabled OpenMP for wavelet_denoise under Mac OS X\n           * More Visual C++ 2003 warnings cleaned in libraw/*h files\n           * LibRaw 0.11-Beta7\n\n2010-10-16 Alex Tutubalin <lexa@lexa.ru>\n           * internal/dcraw_fileio.c can be compiled with -DDCRAW_VERBOSE again\n           * fixed comment style in libraw_datastream.h\n           * LibRaw 0.11-Beta6\n\n2010-10-15 Alex Tutubalin <lexa@lexa.ru>\n\n           * New changes to I/O layer. Three LibRaw_*datastream clasees are\n             exists: \n               + LibRaw_buffer_datastream - buffer reaging\n               + LibRaw_file_datastream - file reading using iostreams\n                 (large files are no supported on some systems)\n               + LibRaw_bigfile_datastream - FILE*-based file I/O\n\n           *  file/bigfile_datastream is selected automatically by\n              LibRaw::open_file based on input file size.\n              By default, files larger than 250Mb are opened using\n              bigfile interface, you may change this behaviour\n              by using second optional parameter of open_file()\n\n           * There is no way to use default parameter values in C API,\n             so new call libraw_open_file_ex added with two parameters\n             (file name and minimal file size for bigfile_datastream use).\n\n           * all client code should be recompiled due to internals change.\n\n           * All LibRaw_abstract_datastream functions are virtual again. You may\n             (again) use your own I/O layer.\n\n           * new -d key for dcraw_emu sample: print timings of processing stages\n\n           * simple_dcraw sample simplified: no mmap code\n\n           * LibRaw 0.11-Beta5\n\n2010-10-08 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in exception handling in OpenMP sections in \n             AHD interpolation code.\n\n           * LibRaw_datastreams are now C++ iostreams based instead of old\n             plain FILE* calls.\n             LibRaw::open_file() in multithreaded programs are WAY faster\n             on many OSes (Linux, Windows, MacOSX) because of no extra locks.\n\n           * all client code should be recompiled due to internals change.\n\n           * LibRaw 0.11-Beta4\n\n\n2010-10-01 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in LibRaw::dcraw_process() code: for half_size\n             processing, params.four_color_rgb was set to 1 internally\n             and not returned back after postprocessing.\n\n           * Several Visual Studio 2003 compatibility fixes\n\n            * AHD interpolation refactored. Now it is about 10% faster than\n              dcraw in single-process mode and up to 1.5 times faster on\n              4-core and OpenMP (total execution time counted, not AHD itself)\n              Thanks to Adam Hooper\n           * AHD interpolation refactored. Now it is about 10% faster than\n             dcraw in single-process mode and up to 1.5 times faster on\n             4-core and OpenMP (total execution time counted, not AHD itself)\n             Thanks to Adam Hooper\n              \n           * LibRaw 0.11-Beta3\n\n2010-09-07 Alex Tutubalin <lexa@lexa.ru>\n           * Phase One files: LibRaw::unpack() sets colordata.black to\n             approximately correct value. \n\n           * Fixed minor error in setting colordata.maximum value\n             for Phase One files.\n\n           * LibRaw::subtract_black() sets colordata.black and\n             colordata.cblack[] to zero to preserve data integrity.\n\n           * LibRaw 0.11-Beta2\n             \n\n2010-09-04 Alex Tutubalin <lexa@lexa.ru>\n\n           * It is now possible to crop output image on postprocessing\n            stage (dcraw_process). Coordinates and size of the output box\n            are set via imgdata.params.cropbox[4] parameter. Look into\n            LibRaw documentation for more details.\n\n              + New fatal error code LIBRAW_BAD_CROP\n\n              + New dcraw_emu sample command line switch: -B x y w h\n                (sets cropbox)\n\n             Thanks to Patrick and Jan.\n\n            * Processing pipeline has changed: the black level is subtracted\n              from data on postprocessing stage either automatically \n              (on dcraw_process() stage) or by special LibRaw API call:\n\n               + New API calls:  LibRaw::subtract_black() (C++ API) and\n                 libraw_subtract_black (C API). \n                 If you use dcraw_process() or dcraw_document_mode_processing()\n                 calls YOU DON'T NEED to call subtract_black() directly.\n               \n               + The raw preprocessing mode LIBRAW_FILTERING_NOBLACKS\n                 is deprecated and removed from LibRaw.\n\n             * New ./configure script.\n               Use ./configure -h for usage details.\n               Thanks to Siddhesh Poyarekar\n\n             * New API cals static LibRaw::dcraw_clear_mem() (C++ API)\n               and libraw_dcraw_clear_mem(..) (C API).\n               This calls are used to free memory, allocated by\n               dcraw_make_mem_image() and dcraw_make_mem_thumb() instead\n               of free() call.\n\n               In some cases LibRaw and calling process have different\n               memory managers, so free() of make_mem_image() data \n               results to program crash (especially in Win32/VisualStudio\n               enviroment).\n\n             * LibRaw::free() is now private instead of public (again).\n\n             * Minor changes and bugfixes:\n\n               + Memory allocation exceptions (std::bad_alloc) are caught,\n                 so LibRaw API calls will return reasonable error codes\n                 instead of C++ exception (possibly unhandled).\n                 This problem is very unlikely to see in wild: if application\n                 cannot allocate small data for internal structure, it will \n                 always fail on allocation for RAW image data.\n\n               + WIN32/VisualStudio 2008/2010: fopen,fscanf and sscanf calls\n                 in Libraw_datastream code are changed to *_s (secure) ones.\n\n               + Debug print removed from fatal error handler.\n\n               + Mmaped I/O for dcraw_emu sample is turned on via -E switch\n                 now (because old -B switch is used for settng cropbox).\n\n           * all client code should be recompiled due to structures size change\n           \n           * LibRaw 0.11-Beta1\n\n\n2010-07-31 Alex Tutubalin <lexa@lexa.ru>\n           * dcraw 9.04 (1.438) imported: changes in tiff metadata parser,\n            fixed a typo in Canon A720 model name\n           * small patch in Sony ARW2 unpacking code to make valgrind happy\n           * LibRaw 0.10.0-Beta3.\n\n2010-07-05 Alex Tutubalin <lexa@lexa.ru>\n           * dcraw 9.03 (1.437) imported:\n             + New cameras: Canon SX20, Nikon D3s, Olympus E-P2, Panasoni DMC-GF1,\n               Samsung EX1, Sony A450\n             + Color data changed for some cameras\n\n           * LibRaw 0.10.0-Beta2.\n\n2010-06-06 Alex Tutubalin <lexa@lexa.ru>\n           * dcraw 9.01 (1.434) imported:\n             + Separate black levels for each color channel.\n             + New cameras: Canon 550D, Casio EX-Z1050, Fuji HS10/HS11,\n               Kodak Z981, Panasonic G2 and G10, Phase One P65, \n               Samsung NX-10 and WB550, Sony NEX-3 and NEX-5.\n             + Fixed file descriptor leak in dark frame subtraction processing\n\n           * Fixed dcraw 9.01's bug in DNG black level processing\n\n           * Preliminary support for Sony A450 camera.\n\n           * New command-line switch -h in mem_image sample (half_size support)\n\n           * Some patches by Johannes Hanika (darktable author):\n              + OpenMP speedup  for PPG-interpolation\n              + green_matching  - suppress of 'color maze' on cameras with\n              different green channel sensitivity. This option is turns on\n              by  filed with same name in imgdata.params\n            \n           * all client code should be recompiled due to structures size \n             change\n\n           * LibRaw::free() is now public instead of private.\n\n           * LibRaw 0.10.0-Beta1.\n\n2010-05-15 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in 8-bit RAW processing code\n           * LibRaw 0.9.1-Release\n\n2010-04-26 Alex Tutubalin <lexa@lexa.ru>\n           * OpenMP support: OpenMP is possible under MinGW (untested)\n           * LibRaw 0.9.0-Release\n\n2010-04-21 Alex Tutubalin <lexa@lexa.ru>\n           * Finally fixed inconsistency in Fuji files processing\n           * New COLOR(row,col) call to get bayer color index in image[] array\n           * Old FC() call is deprecated and will be removed in future releases\n           * unprocessed_raw sample switched to COLOR() call\n           * LibRaw 0.9.0-Beta5\n\n\n2010-04-10 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in unpacking DNG files made from Fuji RAFs.\n           * LibRaw 0.9.0-Beta4\n\n2010-04-09 Alex Tutubalin <lexa@lexa.ru>\n\n           * Fixed typecast error (problem reported only on gcc 4.2.1/32bit)\n            in CRW files processing.\n\n           * C++ API call LibRaw::adjust_maximum() is now deprecated and\n             de-documented, use params.adjust_maximum_thr instead (on by default)\n\n           *  C-API call libraw_adjust_maximum() removed.\n\n           * New postprocessing parameter params.adjust_maximum_thr\n             This parameter replaces LibRaw::adjust_maximum(), but more flexible\n             Defaults are reasonable (0.75, same as in old adjust_maximum),\n             look into documentation for more details.\n\n           * Removed last OpenMP warning\n\n           * dcraw_emu's -c parameter now wants numeric (float) argument. This value\n             is assigned to params.adjust_maximum_thr.\n             Use -c 0.0 for dcraw compatibility.\n\n           * all client code should be recompiled due to structures size \n             change\n\n           * LibRaw 0.9.0-Beta3\n\n\n2010-03-29 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed a bug in channel_maximum[] calculation for\n             Panasonic cameras.\n           * channel_maximum[] data now calculated for ALL cameras.\n           * OpenMP warnings suppressed.\n           * Documented the -c command-line switch for dcraw_emu sample.\n           * Removed extra messages from dcraw_emu sample.\n           * LibRaw 0.9.0-Beta2\n\n2010-03-28 Alex Tutubalin <lexa@lexa.ru>\n           \n           New licensing:\n\n           * Triple licensing (selected by LibRaw user):\n\n              + LGPL 2.1 (http://www.gnu.org/licenses/lgpl-2.1.html)\n              + CDDL 1.0 (http://www.opensource.org/licenses/cddl1.txt)\n              + LibRaw Software License (27 March 2010 version)\n               (http://www.libraw.org/data/LICENSE.LibRaw.pdf)\n\n           * There is no separate LibRaw-Lite and LibRaw-Commercial versions,\n             only single LibRaw.\n             Current LibRaw-Lite and LibRaw-Commercial users should switch\n             to LibRaw without loss of functionality.\n             It is possible to change licensig too (e.g. from LGPL to CDDL\n             for LibRaw-Lite users and from LibRaw License to LGPL or CDDL\n             for LibRaw-Commercial users).\n\n           * No Foveon support :(\n             It is not possible to get good color from Foveon sensors with\n             *any* converter. So, there is no need to support these cameras.\n             Dcraw's Foveon-processing code is too strict licensed (GPL),\n             so we choose to drop it.\n             \n           New Features:\n\n           * New data field  colordata.channel_maximum[4] - per channel data\n            maximum (calculated for most cameras, 0 for others).\n\n           * New call LibRaw::adjust_maximum() (and libraw_adjust_maximum() in C API).\n             This call changes hardcoded colordata.maximum value to calculated\n             at unpack stage. This helps suppress false color in highlights\n             (magenta clouds and so).\n\n           * New command line parameter -c for dcraw_emu sample. Calls adjust_maximum()\n             for each processed file.\n\n           * all client code should be recompiled due to structures size \n             change\n\n           * LibRaw 0.9.0-Beta1\n\n2010-02-06 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed ambiguity in pow/sqrt calls (to make Sun C++ compiler happy)\n           * OpenMP is not supported under MS Visual Studio\n           * Masked a bug in RIFF format parser \n           * LibRaw 0.8.6\n\n2009-12-30 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in simple_dcraw sample parameters processing\n           * Imported dcraw 8.99 (1.432):\n             + New cameras: Canon:  1D mk IV, Canon S90; Casio Z750, \n               Nikon D3S, Pentax K-x, Sony A-500/550, Fuji S200EXR\n             + New color data for Canon G11 and Sony A850\n             + Changes in Canon sRAW processing\n             + Changes in Kodak metadata processing\n             + Changes in uncompressed Fuji files processing (FinePix S5xxx)\n           * LibRaw 0.8.5\n\n2009-11-21 Alex Tutubalin <lexa@lexa.ru>\n           + Fixed a bug in processing of uncompressed Phase One files \n           * LibRaw 0.8.4\n\n2009-10-24 Alex Tutubalin <lexa@lexa.ru>\n           + Imported dcraw 8.98/1.431:\n             * New Cameras: Canon 7D, Panasonic GF1, Sony A850 and A380, \n             Casio Z850, Nikon D300s\n           + changes in libraw_datastream.h to make compilers more happy\n           * LibRaw 0.8.3\n\n2009-09-02 Alex Tutubalin <lexa@lexa.ru>\n           + Fixed bug in Hasselblad .3FR unpacking code\n           * Imported dcraw 8.97/1.428: Nikon D3000 image width fix\n           * LibRaw 0.8.2\n           \n2009-08-31 Alex Tutubalin <lexa@lexa.ru>\n           + Enum LibRaw_thumbnail_formats (LIBRAW_IMAGE_*) values changed to\n             match values in  enum LibRaw_image_formats (LIBRAW_THUMBNAIL_*).\n             You need to recompile all sources using these constants.\n\n2009-08-30 Alex Tutubalin <lexa@lexa.ru>\n           * Imported dcraw 8.97/1.427:\n             + new cameras: Canon A470, Canon G11 (without color data),\n                Nikon D3000, Olympus E-P1, Panasonic DMC-FZ35/FZ38\n             + some changes in decoding code.\n            * Fixes for Microsoft Visual C++ 6.0 compatibility\n            * C-API dcraw_make_mem_thumb() call finally exported in API\n           * LibRaw 0.8.1\n\n2009-08-24 Alex Tutubalin <lexa@lexa.ru>\n           * Imported dcraw 8.96/1.426\n             + New cameras: Casio EX-Z60 and EX-Z75, Kodak Z980,\n               Nikon D5000,  Olympus X200, D560Z,C350Z,E620,\n               Pentax K7, Sony A330.\n             + New color data for many cameras\n             + Generalized unpacker code for Canon and Casio P&S cameras\n           * LibRaw 0.8.0-Release\n\n2009-08-13 Alex Tutubalin <lexa@lexa.ru>\n           * RAW files larger than 2Gb are supported on:\n              - Unix (all supported: FreeBSD, MacOS X, Linux)\n              - Windows (with C runtime version  >= 8.0)\n           * bzero replaced with memset to make Solaris users happy\n           * All applications on 32-bit systems should be recompiled\n             due to data structures size changes.\n           * Minor fixes in windows makefile\n           * LibRaw 0.8.0-Beta5\n\n2009-07-21 Alex Tutubalin <lexa@lexa.ru>\n           * Imported dcraw 8.95 (1.425):\n             + new huffman tree code\n             + New cameras supported: AGFAPHOTO DC-833m, Casio EX-S20,\n                Phase One P65, Samsung S850\n             + Removed hardcoded white-balance data for many P&S cameras.\n               It is recommended to set params.use_camera_wb to 1 for \n               safe WB.\n           * Fixes for Nikon D5000 files: no pink stripe at \n             right side of frame\n           * C-wrapper: added missed calls\n               libraw_dcraw_make_mem_image\n               libraw_dcraw_ make_mem_thumb\n           * Minor fixes to make non-gcc compilers more happy\n           * Internal structures changed, full recompilation of all client \n             code is needed.\n           * LibRaw 0.8.0-Beta4\n                \n2009-06-08 Alex Tutubalin <lexa@lexa.ru>\n           * Fixes: gamma  curve processing was not performed in \n              dcraw_write_mem_image()\n           * Fixes: gamma curve processing was not performed for \n              Kodak thumbnails\n           * LibRaw 0.8.0-Beta3\n\n2009-06-05 Alex Tutubalin <lexa@lexa.ru>\n           * Fixes in documentation: params.gamm[] described more precisely\n           * Fixes in version number, 0.8-beta1 was mistakenly 0.0.0-beta1\n           * LibRaw 0.8.0-Beta2\n\n2009-06-04 Alex Tutubalin <lexa@lexa.ru>\n           * Imported dcraw 8.94 (1.423):\n             + New camera support:\n                 Canon: SX1, 500D/Rebel T1i, A570, A590, SX110\n                 Kodak Z1015, Motorola PIXL, Olympus E30, Panasonic DMC-GH1\n             + Improved color data for Nikon D3X\n             + New gamma curve model\n             + Many changes in RAW unpacking code\n             + Canon cameras: black level is not subtracted if set \n               params.document_mode > 1\n\n           * API changed: params.gamma_16bit field removed. Gamma curve is\n             set via params.gamm[0]/gamm[1] values (see documentation and \n             samples for details)\n           * LibRaw::identify() splitted to avoid MS VS2008 bug (too many \n             nested blocks)\n\n           * Samples: dcraw_emu and mem_image samples supports new dcraw \n              16bit/gamma semantics:\n                -6: set 16 bit output\n                -4: set 16 bit output and linear gamma curve and no auto \n                   brighness\n           *  LibRaw 0.8.0-Beta1\n\n2009-04-28 Alex Tutubalin <lexa@lexa.ru>\n           * Identify sample renamed to raw-identify (name conflict \n             with ImageMagic)\n           * Copyright notice changes\n           * Many compiler warnings removed\n\n2009-04-07 Alex Tutubalin <lexa@lexa.ru>\n           * More accurate types conversion in libraw_datastream.h \n           * New postprocessing parameter auto_bright_thr: set portion of \n             clipped pixels for auto brightening code (instead of \n             dcraw-derived hardcoded 1%)\n           * -U  option for dcraw_emu sample sets auto_bright_thr parameter\n           * all client code should be recompiled due to structures size \n             change\n           * LibRaw 0.7.2-Release\n\n2009-03-22 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed typo in OpenMP support code\n           * MinGW support \n           * dcraw source is included in distribution\n           * LibRaw 0.7.1-Release\n\n2009-03-15 Alex Tutubalin <lexa@lexa.ru>\n           * Fuji SuperCCD RAWs: color channels unshuffled on RAW\n             read stage (moved from postprocessing stage)\n\n           * LibRaw 0.7.0-Release\n\n2009-03-13 Alex Tutubalin <lexa@lexa.ru>\n           * dcraw 8.93/1.421 imported:\n             + more accurate pentax dSLR support\n             + fixes in Kodak 620x/720x identification\n             + faster identification procedure for some formats.\n           * LibRaw 0.7.0-Beta5\n\n\n2009-03-08 Alex Tutubalin <lexa@lexa.ru>\n           * dcraw 8.92/1.420 imported:\n             + user-specified gamma curve\n             + Pentax K2000/Km support\n             + Changes in Canon sRAW processing (support for 5D2 fw 1.07)\n\n           * all client code should be recompiled\n\n           * LibRaw 0.7.0-Beta4\n\n2009-02-13 Alex Tutubalin <lexa@lexa.ru>\n           * bugfix: 4channels sample finally subtracts black by default\n           * dcraw 8.91/1.419 imported:\n              + fixes in RIFF files parsing\n\n           * LibRaw 0.7.0-Beta3\n\n2009-02-12 Alex Tutubalin <lexa@lexa.ru>\n           * Black level was not calculated for Canon RAWs in\n             some filtering modes\n\n           * 4channels sample prints calculated black level\n             (scaled if autoscaling used). \n             Also output file names for this sample now includes \n             color channel name (R/G/B/G2 or C/M/Y/G)\n\n           * LibRaw 0.7.0-Beta2\n\n2009-02-09 Alex Tutubalin <lexa@lexa.ru>\n           * New sample 4channels: splits RAW color channels into four \n             separate TIFFs\n\n           * LibRaw 0.7.0-Beta1\n\n2009-02-07 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in external jpeg metadata reading code.\n\n           * Cleaned some C++ warnings\n\n           * dcraw 8.91/1.418 imported\n             + Hasselblad V96C support\n\n           * You need to clean and recompile client code which\n             uses LibRaw_*_datastream classes.\n\n           * LibRaw 0.7.0-Alpha6\n\n2009-01-30  Alex Tutubalin <lexa@lexa.ru>\n\n           * New data input framework is created. It is possible now to\n             easyly implement your own data input interface for LibRaw\n             (e.g. for reading RAW data from network data stream)\n             \n           * All older programs using previous LibRaw versions are\n\t     compatible at source code level.\n\n           * LibRaw can read RAW data from memory buffer via\n             new LibRaw::open_buffer() API call (implemented on top of\n             new input framework). \n             This call used in sample application dcraw_emu and simple_dcraw\n             (with -B command-line switch) to test new API.\n\n           * Error handling callback functions now can be called with\n             NULL filename passed (if underlying data stream object\n             does not know file name).\n             So, client error handling callbacks should work with NULL\n             filename.\n\n           * All client code should be recompiled\n\n           * Imported dcraw 8.90/1.417:\n              + Support for loading White Balance data from\n                Sony ARW files edited with Sony IDC software.\n\n           * LibRaw 0.7.0-Alpha5\n\n2009-01-17 Alex Tutubalin <lexa@lexa.ru>\n           * Raw filtering mode LIBRAW_FILTERING_NOPOSTPROCESS has renamed\n            to LIBRAW_FILTERING_NORAWCURVE for better reflect its purpose.\n            This filtering_mode bit turns off tone curve applying on\n            RAW data on bayer-pattern cameras with raw tone curve:\n              + Adobe DNG (only RAW with bayer pattern)\n              + Nikon compressed NEF\n              + Some Kodak cameras\n              + Sony A700/A900 (tone curve applied to 8-bit raws)\n\n           * unprocessed_raw sample: added command-line key -N, this key\n             turns on LIBRAW_FILTERING_NORAWCURVE filtering mode.\n\n           * New scheme of Fuji RAW processing (introduced in 0.7-Alpha3)\n             supports DNG files generated from Fuji RAF.\n           \n           * Imported dcraw 8.90/1.416:\n              + better support for Samsung S85\n              + fixed possible integer overflow in wavelet denoising code\n\n           * LibRaw 0.7.0-Alpha4\n\n\n2009-01-14 Alex Tutubalin <lexa@lexa.ru>\n           * Black mask extraction supported for all files with bayer data\n            (one component per pixel). Black mask data not avaliable\n            for multi-component data (Foveon, Canon sRAW, Sinar 4-shot,\n            Kodak YCC/YRGB).\n\n           * Black level subtraction can be turned off for all bayer\n            cameras (added support for PhaseOne backs).\n\n           * Fujifilm camera processing model changed:\n              + RAW data is extracted without 45-degree rotation\n              + dcraw-compatible rotation is performed on postptocessing stage\n              + it is possible to rotate RAW data without postprocessing\n                by LibRaw::rotate_fuji_raw() call.\n\n           * New filtering mode setting: LIBRAW_FILTERING_NOPOSTPROCESS\n             This bits turns off RAW tone curve processing based on tone curve\n             readed from RAW metadata.\n             This mode supported only for PhaseOne backs now (to be supported\n             on all relevant cameras in nearest future releases)\n\n           * Black level data (got from RAW data) are stored for PhaseOne backs.\n\n           * Black level subtraction bug (derived from dcraw) fixed\n             for PhaseOne files.\n\n           * Fixed processing of -s parameter for dcraw_emu sample\n           \n           * Parameter  -s N (select shot number) added to \n             unprocessed_raw sample.\n\n           * Imported dcraw 8.90/1.414:\n              + changes in QuickTake 100 metadata processing\n              + changes in external jpeg processing code\n              + Samsung S85 support\n\n           * All client code should be recompiled\n\n           * LibRaw 0.7.0-Alpha3 released\n\n2009-01-10 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in add_masked_borders: crash if output dimensions\n            is already larger than raw dimensions\n            * Fixed out of bounds in samples/unprocessed_raw.cpp for files\n            with non-square pixels\n\n           * LibRaw 0.7.0-Alpha2 released\n           \n2009-01-08 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in  0.7.0-a0: black frame size has not reset, \n             so in batch processing there is an error in black frame\n             size for files without black frame.\n\n           * Implemented reading of black/masked pixels data for \n             near all cameras with masked pixels, exclding:\n              + Canon sRAW, Leaf (MOS), Sinar 4-shot - more than one \n                color component in black frame (redesign of black frame\n                data structures required).\n              + Fuji SuperCCD: need to design right methods of extraction \n                (should we rotate and resize black pixels as active ones??)\n\n            * Tested for most dSLR data formats with masked pixels: 7 of 9\n              untested formats are from old P&S cameras.\n\n           * New call LibRaw::unpack_function_name() returns unpack function name\n             (useful for testers only)\n\n           * New identify sample parameters (useful for test-suite builders\n             to check test coverage):\n                  -u - print unpack function name\n                  -f - print masked frame size\n             These parameters works only for identify run without -v parameter\n\n           * Imported dcraw 8.89/1.411\n             + changes in Panasonic FZ50 files parsing\n\n           * LibRaw 0.7.0-Alpha1 released\n\n\n2009-01-05 Alex Tutubalin <lexa@lexa.ru>\n           * It is possible to turn off RAW data filtration (black level \n             subtraction,              zero pixels averaging):\n                + supported on all cameras except Foveon and Phase One\n                + filtraction controlled by new parameter \"filtering_mode\"\n                + it is possible to expand API by filtering procedures \n                  built for specific camera model.\n\n           * Black border (masked pixels) extraction:\n                + API (data structures) for storing black mask.\n                + Black mask extraction supported only for limited list of\n                  data formats: \n                       - Canon .CRW, .CR2 (with exception of sRAW),A600, A5\n                       - Adobe DNG (both converted RAW and native DNG)\n                       - Nikon NEF (compressed only)\n                  this list to be expanded in future LibRaw versions\n           * New call add_masked_borders_to_bitmap makes full bitmap\n             'masked border' + image\n           * Usage sample for functionality listed above: \n              samples/unprocessed_raw \n           * Imported dcraw 8.89/1.410:\n              + fixed bugs in Hasselblad .fff decoding\n              + fixes in Imacon metadata decoding\n           * Documentation changes\n           * All client code should be recompiled\n           * LibRaw 0.7.0-Alpha0\n\n\n2009-01-01 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed a bug (filedescriptor and buffer memory leak)  in thumbnail \n             extraction when called before metadata analysis. \n             Thanks to Albert Astalis Cid.\n           * LibRaw 0.6.4 Release\n\n2008-12-11 Alex Tutubalin <lexa@lexa.ru>\n           * Imported new edition of dcraw 8.89 (version 1.409)\n           * Nikon NEF decoding changed\n           * LibRaw 0.6.3 Release\n           \n2008-12-03 Alex Tutubalin <lexa@lexa.ru>\n           * fixed bug in Panasonic .RW2 processing (only for thread-safe version,\n             single-threaded version was not affected)\n           * All client code should be recompiled\n           * LibRaw 0.6.2 Release\n\n2008-12-03 Alex Tutubalin <lexa@lexa.ru>\n           * Imported  dcraw 8.89 (version 1.407)\n           * New cameras:\n               Canon G10 & 5D Mk2, Leaf AFi 7, Leica D-LUX4, Panasonic FX150 & G1, \n               Fujifilm IS Pro,\n           * Changed camera support (color conversion tables):\n               Canon 50D, Nikon D90 & P6000, Panasonic LX3 & FZ28, Sony A900\n           * LibRaw 0.6.2 beta\n\n2008-09-25 Alex Tutubalin <lexa@lexa.ru>\n           * Added new data field  float LibRaw::imgdata.color.cam_xyz[4][3]. \n           This field contains constant table (different for each camera) for\n           Camera RGB->XYZ conversion.\n           * All client code should be recompiled\n           * LibRaw 0.6.1 Release\n\n2008-09-18 Alex Tutubalin <lexa@lexa.ru>\n           * dcraw 8.88 imported:\n              - new cameras (Canon 50D, Sony A900, Nikon D90 & P6000,\n                Panasonic LX3 FZ28)\n              - new method of black point subtraction for Canon cameras, \n                preliminary banding supression.\n            * Stack memory usage lowered (some thread data moved to dynamic\n            memory) \n            * some patches for MSVC compatibility\n            * LibRaw 0.6.0 Release\n\n2008-09-16 Alex Tutubalin <lexa@lexa.ru>\n           * Enum definitions changed to make gcc -pedantic happy\n           * Compiler/preprocessor flags does not affects LibRaw class field set\n           (i.e. structure for thread local storage is always allocated)                   \n           * Default library compilation mode (i.e. sources imported in another\n             project) is thread-safe \n\n2008-09-14 Alex Tutubalin <lexa@lexa.ru>\n           * OpenMP support for most CPU consuming steps of processing:\n             ahd_interpolation. wavelet_denoise\n             10-30% speed-up of full processing pipe on 2-core CPU \n             OpenMP supported only on gcc (Linux/FreeBSD and Mac OS X)\n\n           * LibRaw 0.6.0-Beta-1\n\n2008-09-10 Alex Tutubalin <lexa@lexa.ru>\n           *  All set_**handler accepts additional void* pointer, which should point to\n            callback private data. This pointer passed to user callback when it called.\n\n           * LibRaw 0.6.0-alpha5\n\n           * All client code should be recompiled\n\n2008-09-10 Alex Tutubalin <lexa@lexa.ru>\n           * New processing stages in enum LibRaw_progress: \n             LIBRAW_PROGRESS_BAD_PIXELS LIBRAW_PROGRESS_DARK_FRAME\n            (reserved stages LIBRAW_PROGRESS_RESERVED_PRE1-PRE2 has removed)\n           * libraw_strprogress() - convert progress code into string\n\n           * Added progress/cancellation user callbacks\n             + new fatal error code: CANCELLED_BY_CALLBACK\n             + sample usage in samples/dcraw_emu.cpp (try run it with -v -v -v opts)\n\n           * LibRaw 0.6.0-alpha4\n\n           * All client code should be recompiled\n\n2008-09-08 Alex Tutubalin <lexa@lexa.ru>\n           * ICC-profiles support (same as in dcraw)\n             + input/output profiles (specified as path to 'icc' file or 'embed' for \n               embedded input profile)\n             + additional warnings\n             + LCMS library used\n\n           * support of bad pixel map (caller should specify path to bad pixel file \n              in dcraw-compatible format)\n\n           * dark frame subtraction support (caller should supply path to 16-bit PGM \n              map). samples/simple_dcraw.cpp - -4 option added for dark frame file \n              generation\n\n           * support of bad pixeld map (dcraw-compatible format)\n\n           * the dcraw_emu sample supports all new features (ICC, dark frame, bad \n              pixels)\n\n           * libraw/libraw_version.h, defines, calls and macros for version checks:\n              + LibRaw::version(), LibRaw::versionNumber(), LIBRAW_CHECK_VERSION()\n\n           * List of supported cameras:\n              + LibRaw::cameraCount()\n              + LibRaw::cameraList()\n\n           * fixed error in adjust_sizes_info_only\n\n           * documentation changes\n\n           * LibRaw 0.6.0-alpha3\n\n2008-09-07 Alex Tutubalin <lexa@lexa.ru>\n           * samples/mem_image.c - bitwise equal output with dcraw -4\n             (PPMs outputted with network byte order)\n           * LibRaw 0.6.0-alpha2\n           \n2008-09-06 Alex Tutubalin <lexa@lexa.ru>\n           * Added calls dcraw_make_mem_image and dcraw_make_mem_image:\n             + functions (and supporting code)\n             + documentation changed\n             + new sample code samples/mem_image.cpp\n           * Added processing parameter  LibRaw::imgdata.params.gamma_16bit \n              (set to 1 to make gamma correction for 16-bit output)\n           * LibRaw 0.6.0-alpha1\n\n2008-08-28 Alex Tutubalin <lexa@lexa.ru>\n           * dcraw 1.404 (8.87) imported:\n             - 6 new cameras supported (Canon 1000D, A720, SD300; \n                Nikon D700, Oly E-520,Kodak C603)\n           * Licensing changed to GPL v2\n\n2008-05-02  Alex Tutubalin <lexa@lexa.ru>\n            * mmap/malloc+read IO-layer removed due to no performance gain.\n              FILE I/O returned\n\n2008-05-02  Alex Tutubalin <lexa@lexa.ru>\n            * dcraw 1.403 imported\n              - changes in ljpeg decompression (index values cut to 12 bit)\n              - changes in parse_foveon() jpeg thumbnail extraction\t\n            * LibRaw 0.5.3 released\n\n2008-04-24  Alex Tutubalin <lexa@lexa.ru>\n            * Linux build of samples/identify fixed\n            * documentation editorial\n            * LibRaw 0.5.2 released\n\n2008-04-21  Alex Tutubalin <lexa@lexa.ru>\n            * All documentation translated to English\n            * English changelog started :)\n            * minor bug (include path) fixed in samples/half_mt \n            * LibRaw 0.5.1 released\n", "all: sources library all_samples dcraw_binaries\n\nPP=./internal/preprocess.pl\n\nCC=gcc\nCXX=g++\n\n# RawSpeed Support\nCFLAGS+=-DUSE_RAWSPEED -I../RawSpeed -I/usr/local/include/libxml2\nLDADD+=-L../RawSpeed/RawSpeed/release -lrawspeed -L/usr/local/include -ljpeg -lxml2\nRAWSPEED_DATA=../RawSpeed/data/cameras.xml\n\n\nCC=gcc48\nCXX=g++48\nCFLAGS+= -O4 -g -march=corei7 -mtune=corei7 -I. -pedantic  -Wno-long-long -Wno-overflow -msse4.2 -mfpmath=sse  -fopenmp \n\n\n# LCMS support\n# For lcms2 set -DUSE_LCMS2\n#CFLAGS+=-DUSE_LCMS -I/usr/local/include\n#LDADD+=-L/usr/local/lib -llcms\n\n# Jasper support for RedCine\nCFLAGS+=-DUSE_JASPER -I/usr/local/include\nLDADD+=-L/usr/local/lib -ljasper\n\n# JPEG support for DNG\nCFLAGS+=-DUSE_JPEG -I/usr/local/include\nLDADD+=-L/usr/local/lib -ljpeg\n# LIBJPEG8:\nCFLAGS+=-DUSE_JPEG8\n\n# Demosaic Pack GPL2:\nDPCFLAGS+=-I../LibRaw-demosaic-pack-GPL2\nCFLAGS+=-DLIBRAW_DEMOSAIC_PACK_GPL2\n\n# Demosaic Pack GPL3:\nDPCFLAGS+=-I../LibRaw-demosaic-pack-GPL3\nCFLAGS+=-DLIBRAW_DEMOSAIC_PACK_GPL3\n\n\nDCRAW_GEN= internal/dcraw_common.cpp internal/dcraw_fileio.cpp\nDCRAW_LIB_OBJECTS=object/dcraw_common.o object/libraw_cxx.o object/libraw_datastream.o object/libraw_c_api.o object/dcraw_fileio.o object/demosaic_packs.o\nDCRAW_LIB_MT_OBJECTS=object/dcraw_common_mt.o object/libraw_cxx_mt.o object/libraw_datastream_mt.o object/libraw_c_api_mt.o object/dcraw_fileio_mt.o object/demosaic_packs_mt.o\nLR_INCLUDES=libraw/libraw.h libraw/libraw_alloc.h libraw/libraw_const.h libraw/libraw_datastream.h libraw/libraw_internal.h libraw/libraw_types.h libraw/libraw_version.h\n\nsources: ${DCRAW_GEN} Makefile.devel ${PP}\nlibrary: lib/libraw.a lib/libraw_r.a\n\nall_samples: bin/raw-identify bin/simple_dcraw  bin/dcraw_emu bin/dcraw_half bin/half_mt bin/mem_image \\\n        bin/unprocessed_raw bin/4channels bin/multirender_test bin/postprocessing_benchmark\n\n## RawSpeed xml file\n\nRawSpeed/rawspeed_xmldata.cpp: ${RAWSPEED_DATA}\n\t./rsxml2c.sh ${RAWSPEED_DATA} > RawSpeed/rawspeed_xmldata.cpp\n\n## Demosaic Pack(s)\n\nobject/demosaic_packs.o: internal/demosaic_packs.cpp ${LR_INCLUDES}\n\t$(CXX) -w -c -DLIBRAW_NOTHREADS ${CFLAGS} ${DPCFLAGS} -o object/demosaic_packs.o internal/demosaic_packs.cpp\n\nobject/demosaic_packs_mt.o: internal/demosaic_packs.cpp ${LR_INCLUDES}\n\t$(CXX) -w -c -pthread ${CFLAGS} ${DPCFLAGS} -o object/demosaic_packs_mt.o internal/demosaic_packs.cpp\n\n## Samples ##\nbin/raw-identify: lib/libraw.a samples/raw-identify.cpp\n\t$(CXX) ${CFLAGS} -o bin/raw-identify samples/raw-identify.cpp -L./lib -lraw  -lm  ${LDADD}\n\nbin/simple_dcraw: lib/libraw.a samples/simple_dcraw.cpp\n\t$(CXX) -DLIBRAW_NOTHREADS ${CFLAGS} -o bin/simple_dcraw samples/simple_dcraw.cpp -L./lib -lraw  -lm  ${LDADD}\n\nbin/multirender_test: lib/libraw.a samples/multirender_test.cpp\n\t$(CXX) -DLIBRAW_NOTHREADS ${CFLAGS} -o bin/multirender_test samples/multirender_test.cpp -L./lib -lraw  -lm  ${LDADD}\n\nbin/postprocessing_benchmark: lib/libraw.a samples/postprocessing_benchmark.cpp\n\t$(CXX) -DLIBRAW_NOTHREADS ${CFLAGS} -o bin/postprocessing_benchmark samples/postprocessing_benchmark.cpp -L./lib -lraw  -lm  ${LDADD}\n\nbin/unprocessed_raw: lib/libraw.a samples/unprocessed_raw.cpp\n\t$(CXX) -DLIBRAW_NOTHREADS ${CFLAGS} -o bin/unprocessed_raw samples/unprocessed_raw.cpp -L./lib -lraw  -lm  ${LDADD}\n\nbin/4channels: lib/libraw.a samples/4channels.cpp\n\t$(CXX) -DLIBRAW_NOTHREADS ${CFLAGS} -o bin/4channels samples/4channels.cpp -L./lib -lraw  -lm  ${LDADD}\n\nbin/mem_image: lib/libraw.a samples/mem_image.cpp\n\t$(CXX) ${CFLAGS} -o bin/mem_image samples/mem_image.cpp -L./lib -lraw  -lm  ${LDADD}\n\nbin/dcraw_half: lib/libraw.a samples/dcraw_half.c\n\t$(CC) ${CFLAGS} -o bin/dcraw_half samples/dcraw_half.c -L./lib -lraw  -lm -lstdc++  ${LDADD}\n\nbin/half_mt: lib/libraw_r.a samples/half_mt.c\n\t$(CC) -pthread ${CFLAGS} -o bin/half_mt samples/half_mt.c -L./lib -lraw_r  -lm -lstdc++  ${LDADD}\n\nbin/dcraw_emu: lib/libraw.a samples/dcraw_emu.cpp\n\t$(CXX) ${CFLAGS} -o bin/dcraw_emu samples/dcraw_emu.cpp -L./lib -lraw_r  -lm ${LDADD}\n\ndcraw_binaries: bin/dcraw_dist\n\nbin/dcraw_dist: dcraw/dcraw.c Makefile.devel\n\t$(CXX) -w -O4 -DLIBRAW_NOTHREADS -DNO_JPEG -DNO_LCMS -DNO_JASPER -I/usr/local/include -o bin/dcraw_dist dcraw/dcraw.c -lm -L/usr/local/lib \n\nregenerate:\n\t${PP} -N -DDEFINES dcraw/dcraw.c  >internal/defines.h\n\t${PP} -N -DCOMMON dcraw/dcraw.c >internal/dcraw_common.cpp\n\t${PP} -N -DFILEIO dcraw/dcraw.c >internal/dcraw_fileio.cpp\n\ninternal/defines.h: dcraw/dcraw.c  ${PP}\n\t${PP} -DDEFINES dcraw/dcraw.c  >internal/defines.h\n\ninternal/dcraw_common.cpp: dcraw/dcraw.c internal/defines.h  ${PP} Makefile.devel\n\t${PP} -DCOMMON dcraw/dcraw.c >internal/dcraw_common.cpp\n\ninternal/dcraw_fileio.cpp: dcraw/dcraw.c internal/defines.h  ${PP} Makefile.devel\n\t${PP} -DFILEIO dcraw/dcraw.c >internal/dcraw_fileio.cpp\n\nobject/dcraw_common.o: internal/dcraw_common.cpp ${LR_INCLUDES}\n\t$(CXX) -c -DLIBRAW_NOTHREADS ${CFLAGS} ${LCMS_DEF} -o object/dcraw_common.o internal/dcraw_common.cpp\n\nobject/dcraw_fileio.o: internal/dcraw_fileio.cpp ${LR_INCLUDES}\n\t$(CXX) -c -DLIBRAW_NOTHREADS ${CFLAGS} ${LCMS_DEF} -o object/dcraw_fileio.o internal/dcraw_fileio.cpp\n\nobject/libraw_cxx.o: src/libraw_cxx.cpp ${LR_INCLUDES} RawSpeed/rawspeed_xmldata.cpp\n\t$(CXX) -c -DLIBRAW_NOTHREADS ${LCMS_DEF} ${CFLAGS} -o object/libraw_cxx.o src/libraw_cxx.cpp\n\nobject/libraw_datastream.o: src/libraw_datastream.cpp ${LR_INCLUDES}\n\t$(CXX) -c -DLIBRAW_NOTHREADS ${LCMS_DEF} ${CFLAGS} -o object/libraw_datastream.o src/libraw_datastream.cpp\n\nobject/libraw_c_api.o: src/libraw_c_api.cpp ${LR_INCLUDES}\n\t$(CXX) -c -DLIBRAW_NOTHREADS ${LCMS_DEF}  ${CFLAGS} -o object/libraw_c_api.o src/libraw_c_api.cpp\n\nlib/libraw.a: ${DCRAW_LIB_OBJECTS}\n\trm -f lib/libraw.a\n\tar crv lib/libraw.a ${DCRAW_LIB_OBJECTS}\n\tranlib lib/libraw.a\n\nlib/libraw_r.a: ${DCRAW_LIB_MT_OBJECTS}\n\trm -f lib/libraw_r.a\n\tar crv lib/libraw_r.a ${DCRAW_LIB_MT_OBJECTS}\n\tranlib lib/libraw_r.a\n\nobject/dcraw_common_mt.o: internal/dcraw_common.cpp ${LR_INCLUDES}\n\t$(CXX) -c -pthread ${LCMS_DEF} ${CFLAGS} -o object/dcraw_common_mt.o internal/dcraw_common.cpp\n\nobject/dcraw_fileio_mt.o: internal/dcraw_fileio.cpp ${LR_INCLUDES}\n\t$(CXX)  -c -pthread ${LCMS_DEF} ${CFLAGS} -o object/dcraw_fileio_mt.o internal/dcraw_fileio.cpp\n\nobject/libraw_cxx_mt.o: src/libraw_cxx.cpp ${LR_INCLUDES}\n\t$(CXX) -c ${LCMS_DEF} -pthread ${CFLAGS} -o object/libraw_cxx_mt.o src/libraw_cxx.cpp\n\nobject/libraw_datastream_mt.o: src/libraw_datastream.cpp ${LR_INCLUDES}\n\t$(CXX) -c ${LCMS_DEF} -pthread ${CFLAGS} -o object/libraw_datastream_mt.o src/libraw_datastream.cpp\n\nobject/libraw_c_api_mt.o: src/libraw_c_api.cpp ${LR_INCLUDES}\n\t$(CXX) -c ${LCMS_DEF} -pthread ${CFLAGS} -o object/libraw_c_api_mt.o src/libraw_c_api.cpp\n\nclean:\n\trm -fr bin/*.dSYM\n\trm -f *.o *~ src/*~ samples/*~ internal/*~ libraw/*~ lib/lib*.a bin/[4a-z]* object/*o dcraw/*~ doc/*~ bin/*~\n\nfullclean: clean\n\trm -f ${DCRAW_GEN}\n", "#ifndef IGNOREALL\n/*\n   dcraw.c -- Dave Coffin's raw photo decoder\n   Copyright 1997-2012 by Dave Coffin, dcoffin a cybercom o net\n\n   This is a command-line ANSI C program to convert raw photos from\n   any digital camera on any computer running any operating system.\n\n   No license is required to download and use dcraw.c.  However,\n   to lawfully redistribute dcraw, you must either (a) offer, at\n   no extra charge, full source code* for all executable files\n   containing RESTRICTED functions, (b) distribute this code under\n   the GPL Version 2 or later, (c) remove all RESTRICTED functions,\n   re-implement them, or copy them from an earlier, unrestricted\n   Revision of dcraw.c, or (d) purchase a license from the author.\n\n   The functions that process Foveon images have been RESTRICTED\n   since Revision 1.237.  All other code remains free for all uses.\n\n   *If you have not modified dcraw.c in any way, a link to my\n   homepage qualifies as \"full source code\".\n\n   $Revision: 1.454 $\n   $Date: 2012/12/23 19:25:36 $\n */\n/*@out DEFINES\n#ifndef USE_JPEG\n#define NO_JPEG\n#endif\n#ifndef USE_JASPER\n#define NO_JASPER\n#endif\n@end DEFINES */\n\n#define NO_LCMS\n#define DCRAW_VERBOSE\n//@out DEFINES\n#define DCRAW_VERSION \"9.17\"\n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#define _USE_MATH_DEFINES\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include <setjmp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <sys/types.h>\n\n#ifdef NODEPS\n#define NO_JASPER\n#define NO_JPEG\n#define NO_LCMS\n#endif\n#ifndef NO_JASPER\n#include <jasper/jasper.h>\t/* Decode RED camera movies */\n#endif\n#ifndef NO_JPEG\n#include <jpeglib.h>\t\t/* Decode compressed Kodak DC120 photos */\n#endif\t\t\t\t/* and Adobe Lossy DNGs */\n//@end DEFINES\n#ifndef NO_LCMS\n#include <lcms.h>\t\t/* Support color profiles */\n#endif\n//@out DEFINES\n#ifdef LOCALEDIR\n#include <libintl.h>\n#define _(String) gettext(String)\n#else\n#define _(String) (String)\n#endif\n//@end DEFINES\n#if defined(DJGPP) || defined(__MINGW32__)\n#define fseeko fseek\n#define ftello ftell\n#else\n#define fgetc getc_unlocked\n#endif\n//@out DEFINES\n#ifdef __CYGWIN__\n#include <io.h>\n#endif\n#ifdef WIN32\n#include <sys/utime.h>\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32.lib\")\n#define snprintf _snprintf\n#define strcasecmp stricmp\n#define strncasecmp strnicmp\n//@end DEFINES\ntypedef __int64 INT64;\ntypedef unsigned __int64 UINT64;\n//@out DEFINES\n#else\n#include <unistd.h>\n#include <utime.h>\n#include <netinet/in.h>\ntypedef long long INT64;\ntypedef unsigned long long UINT64;\n#endif\n\n#ifdef LJPEG_DECODE\n#error Please compile dcraw.c by itself.\n#error Do not link it with ljpeg_decode.\n#endif\n\n#ifndef LONG_BIT\n#define LONG_BIT (8 * sizeof (long))\n#endif\n//@end DEFINES\n\n#if !defined(uchar)\n#define uchar unsigned char\n#endif\n#if !defined(ushort)\n#define ushort unsigned short\n#endif\n\n/*\n   All global variables are defined here, and all functions that\n   access them are prefixed with \"CLASS\".  Note that a thread-safe\n   C++ class cannot have non-const static local variables.\n */\nFILE *ifp, *ofp;\nshort order;\nconst char *ifname;\nchar *meta_data;\nchar cdesc[5], desc[512], make[64], model[64], model2[64], artist[64];\nfloat flash_used, canon_ev, iso_speed, shutter, aperture, focal_len;\ntime_t timestamp;\nunsigned shot_order, kodak_cbpp, filters, exif_cfa, unique_id;\noff_t    strip_offset, data_offset;\noff_t    thumb_offset, meta_offset, profile_offset;\nunsigned thumb_length, meta_length, profile_length;\nunsigned thumb_misc, *oprof, fuji_layout, shot_select=0, multi_out=0;\nunsigned tiff_nifds, tiff_samples, tiff_bps, tiff_compress;\nunsigned black, cblack[4], maximum, mix_green, raw_color, zero_is_bad;\nunsigned zero_after_ff, is_raw, dng_version, is_foveon, data_error;\nunsigned tile_width, tile_length, gpsdata[32], load_flags;\nushort raw_height, raw_width, height, width, top_margin, left_margin;\nushort shrink, iheight, iwidth, fuji_width, thumb_width, thumb_height;\nushort *raw_image, (*image)[4];\nushort white[8][8], curve[0x10000], cr2_slice[3], sraw_mul[4];\nint mask[8][4], flip, tiff_flip, colors;\ndouble pixel_aspect, aber[4]={1,1,1,1}, gamm[6]={ 0.45,4.5,0,0,0,0 };\nfloat bright=1, user_mul[4]={0,0,0,0}, threshold=0;\nint half_size=0, four_color_rgb=0, document_mode=0, highlight=0;\nint verbose=0, use_auto_wb=0, use_camera_wb=0, use_camera_matrix=-1;\nint output_color=1, output_bps=8, output_tiff=0, med_passes=0;\nint no_auto_bright=0;\nunsigned greybox[4] = { 0, 0, UINT_MAX, UINT_MAX };\nfloat cam_mul[4], pre_mul[4], cmatrix[3][4], rgb_cam[3][4];\nconst double xyz_rgb[3][3] = {\t\t\t/* XYZ from RGB */\n  { 0.412453, 0.357580, 0.180423 },\n  { 0.212671, 0.715160, 0.072169 },\n  { 0.019334, 0.119193, 0.950227 } };\nconst float d65_white[3] = { 0.950456, 1, 1.088754 };\nint histogram[4][0x2000];\nvoid (*write_thumb)(), (*write_fun)();\nvoid (*load_raw)(), (*thumb_load_raw)();\njmp_buf failure;\n\nstruct decode {\n  struct decode *branch[2];\n  int leaf;\n} first_decode[2048], *second_decode, *free_decode;\n\nstruct tiff_ifd {\n  int t_width, t_height, bps, comp, phint, offset, t_flip, samples, bytes;\n  int t_tile_width, t_tile_length;\n} tiff_ifd[10];\n\nstruct ph1 {\n  int format, key_off, t_black, black_off, split_col, tag_21a;\n  float tag_210;\n} ph1;\n\n#define CLASS\n\n//@out DEFINES\n#define FORC(cnt) for (c=0; c < cnt; c++)\n#define FORC3 FORC(3)\n#define FORC4 FORC(4)\n#define FORCC FORC(colors)\n\n#define SQR(x) ((x)*(x))\n#define ABS(x) (((int)(x) ^ ((int)(x) >> 31)) - ((int)(x) >> 31))\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define LIM(x,min,max) MAX(min,MIN(x,max))\n#define ULIM(x,y,z) ((y) < (z) ? LIM(x,y,z) : LIM(x,z,y))\n#define CLIP(x) LIM(x,0,65535)\n#define SWAP(a,b) { a=a+b; b=a-b; a=a-b; }\n\n/*\n   In order to inline this calculation, I make the risky\n   assumption that all filter patterns can be described\n   by a repeating pattern of eight rows and two columns\n\n   Do not use the FC or BAYER macros with the Leaf CatchLight,\n   because its pattern is 16x16, not 2x8.\n\n   Return values are either 0/1/2/3 = G/M/C/Y or 0/1/2/3 = R/G1/B/G2\n\n\tPowerShot 600\tPowerShot A50\tPowerShot Pro70\tPro90 & G1\n\t0xe1e4e1e4:\t0x1b4e4b1e:\t0x1e4b4e1b:\t0xb4b4b4b4:\n\n\t  0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\n\t0 G M G M G M\t0 C Y C Y C Y\t0 Y C Y C Y C\t0 G M G M G M\n\t1 C Y C Y C Y\t1 M G M G M G\t1 M G M G M G\t1 Y C Y C Y C\n\t2 M G M G M G\t2 Y C Y C Y C\t2 C Y C Y C Y\n\t3 C Y C Y C Y\t3 G M G M G M\t3 G M G M G M\n\t\t\t4 C Y C Y C Y\t4 Y C Y C Y C\n\tPowerShot A5\t5 G M G M G M\t5 G M G M G M\n\t0x1e4e1e4e:\t6 Y C Y C Y C\t6 C Y C Y C Y\n\t\t\t7 M G M G M G\t7 M G M G M G\n\t  0 1 2 3 4 5\n\t0 C Y C Y C Y\n\t1 G M G M G M\n\t2 C Y C Y C Y\n\t3 M G M G M G\n\n   All RGB cameras use one of these Bayer grids:\n\n\t0x16161616:\t0x61616161:\t0x49494949:\t0x94949494:\n\n\t  0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\n\t0 B G B G B G\t0 G R G R G R\t0 G B G B G B\t0 R G R G R G\n\t1 G R G R G R\t1 B G B G B G\t1 R G R G R G\t1 G B G B G B\n\t2 B G B G B G\t2 G R G R G R\t2 G B G B G B\t2 R G R G R G\n\t3 G R G R G R\t3 B G B G B G\t3 R G R G R G\t3 G B G B G B\n */\n\n#define RAW(row,col) \\\n\traw_image[(row)*raw_width+(col)]\n//@end DEFINES\n\n#define FC(row,col) \\\n\t(filters >> ((((row) << 1 & 14) + ((col) & 1)) << 1) & 3)\n\n//@out DEFINES\n#define BAYER(row,col) \\\n\timage[((row) >> shrink)*iwidth + ((col) >> shrink)][FC(row,col)]\n\n#define BAYER2(row,col) \\\n\timage[((row) >> shrink)*iwidth + ((col) >> shrink)][fcol(row,col)]\n//@end DEFINES\n\n/* @out COMMON\n#include <math.h>\n#define CLASS LibRaw::\n#include \"libraw/libraw_types.h\"\n#define LIBRAW_LIBRARY_BUILD\n#define LIBRAW_IO_REDEFINED\n#include \"libraw/libraw.h\"\n#include \"internal/defines.h\"\n#include \"internal/var_defines.h\"\n#include \"internal/libraw_bytebuffer.h\"\n@end COMMON */\n\n//@out COMMON\nint CLASS fcol (int row, int col)\n{\n  static const char filter[16][16] =\n  { { 2,1,1,3,2,3,2,0,3,2,3,0,1,2,1,0 },\n    { 0,3,0,2,0,1,3,1,0,1,1,2,0,3,3,2 },\n    { 2,3,3,2,3,1,1,3,3,1,2,1,2,0,0,3 },\n    { 0,1,0,1,0,2,0,2,2,0,3,0,1,3,2,1 },\n    { 3,1,1,2,0,1,0,2,1,3,1,3,0,1,3,0 },\n    { 2,0,0,3,3,2,3,1,2,0,2,0,3,2,2,1 },\n    { 2,3,3,1,2,1,2,1,2,1,1,2,3,0,0,1 },\n    { 1,0,0,2,3,0,0,3,0,3,0,3,2,1,2,3 },\n    { 2,3,3,1,1,2,1,0,3,2,3,0,2,3,1,3 },\n    { 1,0,2,0,3,0,3,2,0,1,1,2,0,1,0,2 },\n    { 0,1,1,3,3,2,2,1,1,3,3,0,2,1,3,2 },\n    { 2,3,2,0,0,1,3,0,2,0,1,2,3,0,1,0 },\n    { 1,3,1,2,3,2,3,2,0,2,0,1,1,0,3,0 },\n    { 0,2,0,3,1,0,0,1,1,3,3,2,3,2,2,1 },\n    { 2,1,3,2,3,1,2,1,0,3,0,2,0,2,0,2 },\n    { 0,3,1,0,0,2,0,3,2,1,3,1,1,3,1,3 } };\n  static const char filter2[6][6] =\n  { { 1,1,0,1,1,2 },\n    { 1,1,2,1,1,0 },\n    { 2,0,1,0,2,1 },\n    { 1,1,2,1,1,0 },\n    { 1,1,0,1,1,2 },\n    { 0,2,1,2,0,1 } };\n\n  if (filters == 1) return filter[(row+top_margin)&15][(col+left_margin)&15];\n  if (filters == 2) return filter2[(row+6) % 6][(col+6) % 6];\n  return FC(row,col);\n}\n\n#ifndef __GLIBC__\nchar *my_memmem (char *haystack, size_t haystacklen,\n\t      char *needle, size_t needlelen)\n{\n  char *c;\n  for (c = haystack; c <= haystack + haystacklen - needlelen; c++)\n    if (!memcmp (c, needle, needlelen))\n      return c;\n  return 0;\n}\n#define memmem my_memmem\n#endif\n//@end COMMON\n\nvoid CLASS merror (void *ptr, const char *where)\n{\n  if (ptr) return;\n  fprintf (stderr,_(\"%s: Out of memory in %s\\n\"), ifname, where);\n  longjmp (failure, 1);\n}\n\nvoid CLASS derror()\n{\n  if (!data_error) {\n    fprintf (stderr, \"%s: \", ifname);\n    if (feof(ifp))\n      fprintf (stderr,_(\"Unexpected end of file\\n\"));\n    else\n      fprintf (stderr,_(\"Corrupt data near 0x%llx\\n\"), (INT64) ftello(ifp));\n  }\n  data_error++;\n}\n\n//@out COMMON\nushort CLASS sget2 (uchar *s)\n{\n  if (order == 0x4949)\t\t/* \"II\" means little-endian */\n    return s[0] | s[1] << 8;\n  else\t\t\t\t/* \"MM\" means big-endian */\n    return s[0] << 8 | s[1];\n}\n\nushort CLASS get2()\n{\n  uchar str[2] = { 0xff,0xff };\n  fread (str, 1, 2, ifp);\n  return sget2(str);\n}\n\nunsigned CLASS sget4 (uchar *s)\n{\n  if (order == 0x4949)\n    return s[0] | s[1] << 8 | s[2] << 16 | s[3] << 24;\n  else\n    return s[0] << 24 | s[1] << 16 | s[2] << 8 | s[3];\n}\n#define sget4(s) sget4((uchar *)s)\n\nunsigned CLASS get4()\n{\n  uchar str[4] = { 0xff,0xff,0xff,0xff };\n  fread (str, 1, 4, ifp);\n  return sget4(str);\n}\n\nunsigned CLASS getint (int type)\n{\n  return type == 3 ? get2() : get4();\n}\n\nfloat CLASS int_to_float (int i)\n{\n  union { int i; float f; } u;\n  u.i = i;\n  return u.f;\n}\n\ndouble CLASS getreal (int type)\n{\n  union { char c[8]; double d; } u;\n  int i, rev;\n\n  switch (type) {\n    case 3: return (unsigned short) get2();\n    case 4: return (unsigned int) get4();\n    case 5:  u.d = (unsigned int) get4();\n      return u.d / (unsigned int) get4();\n    case 8: return (signed short) get2();\n    case 9: return (signed int) get4();\n    case 10: u.d = (signed int) get4();\n      return u.d / (signed int) get4();\n    case 11: return int_to_float (get4());\n    case 12:\n      rev = 7 * ((order == 0x4949) == (ntohs(0x1234) == 0x1234));\n      for (i=0; i < 8; i++)\n\tu.c[i ^ rev] = fgetc(ifp);\n      return u.d;\n    default: return fgetc(ifp);\n  }\n}\n\nvoid CLASS read_shorts (ushort *pixel, int count)\n{\n  if (fread (pixel, 2, count, ifp) < count) derror();\n  if ((order == 0x4949) == (ntohs(0x1234) == 0x1234))\n    swab ((char*)pixel, (char*)pixel, count*2);\n}\n\nvoid CLASS canon_600_fixed_wb (int temp)\n{\n  static const short mul[4][5] = {\n    {  667, 358,397,565,452 },\n    {  731, 390,367,499,517 },\n    { 1119, 396,348,448,537 },\n    { 1399, 485,431,508,688 } };\n  int lo, hi, i;\n  float frac=0;\n\n  for (lo=4; --lo; )\n    if (*mul[lo] <= temp) break;\n  for (hi=0; hi < 3; hi++)\n    if (*mul[hi] >= temp) break;\n  if (lo != hi)\n    frac = (float) (temp - *mul[lo]) / (*mul[hi] - *mul[lo]);\n  for (i=1; i < 5; i++)\n    pre_mul[i-1] = 1 / (frac * mul[hi][i] + (1-frac) * mul[lo][i]);\n}\n\n/* Return values:  0 = white  1 = near white  2 = not white */\nint CLASS canon_600_color (int ratio[2], int mar)\n{\n  int clipped=0, target, miss;\n\n  if (flash_used) {\n    if (ratio[1] < -104)\n      { ratio[1] = -104; clipped = 1; }\n    if (ratio[1] >   12)\n      { ratio[1] =   12; clipped = 1; }\n  } else {\n    if (ratio[1] < -264 || ratio[1] > 461) return 2;\n    if (ratio[1] < -50)\n      { ratio[1] = -50; clipped = 1; }\n    if (ratio[1] > 307)\n      { ratio[1] = 307; clipped = 1; }\n  }\n  target = flash_used || ratio[1] < 197\n\t? -38 - (398 * ratio[1] >> 10)\n\t: -123 + (48 * ratio[1] >> 10);\n  if (target - mar <= ratio[0] &&\n      target + 20  >= ratio[0] && !clipped) return 0;\n  miss = target - ratio[0];\n  if (abs(miss) >= mar*4) return 2;\n  if (miss < -20) miss = -20;\n  if (miss > mar) miss = mar;\n  ratio[0] = target - miss;\n  return 1;\n}\n\nvoid CLASS canon_600_auto_wb()\n{\n  int mar, row, col, i, j, st, count[] = { 0,0 };\n  int test[8], total[2][8], ratio[2][2], stat[2];\n\n  memset (&total, 0, sizeof total);\n  i = canon_ev + 0.5;\n  if      (i < 10) mar = 150;\n  else if (i > 12) mar = 20;\n  else mar = 280 - 20 * i;\n  if (flash_used) mar = 80;\n  for (row=14; row < height-14; row+=4)\n    for (col=10; col < width; col+=2) {\n      for (i=0; i < 8; i++)\n\ttest[(i & 4) + FC(row+(i >> 1),col+(i & 1))] =\n\t\t    BAYER(row+(i >> 1),col+(i & 1));\n      for (i=0; i < 8; i++)\n\tif (test[i] < 150 || test[i] > 1500) goto next;\n      for (i=0; i < 4; i++)\n\tif (abs(test[i] - test[i+4]) > 50) goto next;\n      for (i=0; i < 2; i++) {\n\tfor (j=0; j < 4; j+=2)\n\t  ratio[i][j >> 1] = ((test[i*4+j+1]-test[i*4+j]) << 10) / test[i*4+j];\n\tstat[i] = canon_600_color (ratio[i], mar);\n      }\n      if ((st = stat[0] | stat[1]) > 1) goto next;\n      for (i=0; i < 2; i++)\n\tif (stat[i])\n\t  for (j=0; j < 2; j++)\n\t    test[i*4+j*2+1] = test[i*4+j*2] * (0x400 + ratio[i][j]) >> 10;\n      for (i=0; i < 8; i++)\n\ttotal[st][i] += test[i];\n      count[st]++;\nnext: ;\n    }\n  if (count[0] | count[1]) {\n    st = count[0]*200 < count[1];\n    for (i=0; i < 4; i++)\n      pre_mul[i] = 1.0 / (total[st][i] + total[st][i+4]);\n  }\n}\n\nvoid CLASS canon_600_coeff()\n{\n  static const short table[6][12] = {\n    { -190,702,-1878,2390,   1861,-1349,905,-393, -432,944,2617,-2105  },\n    { -1203,1715,-1136,1648, 1388,-876,267,245,  -1641,2153,3921,-3409 },\n    { -615,1127,-1563,2075,  1437,-925,509,3,     -756,1268,2519,-2007 },\n    { -190,702,-1886,2398,   2153,-1641,763,-251, -452,964,3040,-2528  },\n    { -190,702,-1878,2390,   1861,-1349,905,-393, -432,944,2617,-2105  },\n    { -807,1319,-1785,2297,  1388,-876,769,-257,  -230,742,2067,-1555  } };\n  int t=0, i, c;\n  float mc, yc;\n\n  mc = pre_mul[1] / pre_mul[2];\n  yc = pre_mul[3] / pre_mul[2];\n  if (mc > 1 && mc <= 1.28 && yc < 0.8789) t=1;\n  if (mc > 1.28 && mc <= 2) {\n    if  (yc < 0.8789) t=3;\n    else if (yc <= 2) t=4;\n  }\n  if (flash_used) t=5;\n  for (raw_color = i=0; i < 3; i++)\n    FORCC rgb_cam[i][c] = table[t][i*4 + c] / 1024.0;\n}\n\nvoid CLASS canon_600_load_raw()\n{\n  uchar  data[1120], *dp;\n  ushort *pix;\n  int irow, row;\n\n  for (irow=row=0; irow < height; irow++) {\n    if (fread (data, 1, 1120, ifp) < 1120) derror();\n    pix = raw_image + row*raw_width;\n    for (dp=data; dp < data+1120;  dp+=10, pix+=8) {\n      pix[0] = (dp[0] << 2) + (dp[1] >> 6    );\n      pix[1] = (dp[2] << 2) + (dp[1] >> 4 & 3);\n      pix[2] = (dp[3] << 2) + (dp[1] >> 2 & 3);\n      pix[3] = (dp[4] << 2) + (dp[1]      & 3);\n      pix[4] = (dp[5] << 2) + (dp[9]      & 3);\n      pix[5] = (dp[6] << 2) + (dp[9] >> 2 & 3);\n      pix[6] = (dp[7] << 2) + (dp[9] >> 4 & 3);\n      pix[7] = (dp[8] << 2) + (dp[9] >> 6    );\n    }\n    if ((row+=2) > height) row = 1;\n  }\n}\n\nvoid CLASS canon_600_correct()\n{\n  int row, col, val;\n  static const short mul[4][2] =\n  { { 1141,1145 }, { 1128,1109 }, { 1178,1149 }, { 1128,1109 } };\n\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++) {\n      if ((val = BAYER(row,col) - black) < 0) val = 0;\n      val = val * mul[row & 3][col & 1] >> 9;\n      BAYER(row,col) = val;\n    }\n  canon_600_fixed_wb(1311);\n  canon_600_auto_wb();\n  canon_600_coeff();\n  maximum = (0x3ff - black) * 1109 >> 9;\n  black = 0;\n}\n\nint CLASS canon_s2is()\n{\n  unsigned row;\n\n  for (row=0; row < 100; row++) {\n    fseek (ifp, row*3340 + 3284, SEEK_SET);\n    if (getc(ifp) > 15) return 1;\n  }\n  return 0;\n}\n\n/*\n   getbits(-1) initializes the buffer\n   getbits(n) where 0 <= n <= 25 returns an n-bit integer\n */\nunsigned CLASS getbithuff (int nbits, ushort *huff)\n{\n#ifdef LIBRAW_NOTHREADS\n  static unsigned bitbuf=0;\n  static int vbits=0, reset=0;\n#else\n#define bitbuf tls->getbits.bitbuf\n#define vbits  tls->getbits.vbits\n#define reset  tls->getbits.reset\n#endif\n  unsigned c;\n\n  if (nbits == -1)\n    return bitbuf = vbits = reset = 0;\n  if (nbits == 0 || vbits < 0) return 0;\n  while (!reset && vbits < nbits && (c = fgetc(ifp)) != EOF &&\n    !(reset = zero_after_ff && c == 0xff && fgetc(ifp))) {\n    bitbuf = (bitbuf << 8) + (uchar) c;\n    vbits += 8;\n  }\n  c = bitbuf << (32-vbits) >> (32-nbits);\n  if (huff) {\n    vbits -= huff[c] >> 8;\n    c = (uchar) huff[c];\n  } else\n    vbits -= nbits;\n  if (vbits < 0) derror();\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#undef reset\n#endif\n}\n\n#define getbits(n) getbithuff(n,0)\n#define gethuff(h) getbithuff(*h,h+1)\n\n/*\n   Construct a decode tree according the specification in *source.\n   The first 16 bytes specify how many codes should be 1-bit, 2-bit\n   3-bit, etc.  Bytes after that are the leaf values.\n\n   For example, if the source is\n\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,\n      0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },\n\n   then the code is\n\n\t00\t\t0x04\n\t010\t\t0x03\n\t011\t\t0x05\n\t100\t\t0x06\n\t101\t\t0x02\n\t1100\t\t0x07\n\t1101\t\t0x01\n\t11100\t\t0x08\n\t11101\t\t0x09\n\t11110\t\t0x00\n\t111110\t\t0x0a\n\t1111110\t\t0x0b\n\t1111111\t\t0xff\n */\nushort * CLASS make_decoder_ref (const uchar **source)\n{\n  int max, len, h, i, j;\n  const uchar *count;\n  ushort *huff;\n\n  count = (*source += 16) - 17;\n  for (max=16; max && !count[max]; max--);\n  huff = (ushort *) calloc (1 + (1 << max), sizeof *huff);\n  merror (huff, \"make_decoder()\");\n  huff[0] = max;\n  for (h=len=1; len <= max; len++)\n    for (i=0; i < count[len]; i++, ++*source)\n      for (j=0; j < 1 << (max-len); j++)\n\tif (h <= 1 << max)\n\t  huff[h++] = len << 8 | **source;\n  return huff;\n}\n\nushort * CLASS make_decoder (const uchar *source)\n{\n  return make_decoder_ref (&source);\n}\n\nvoid CLASS crw_init_tables (unsigned table, ushort *huff[2])\n{\n  static const uchar first_tree[3][29] = {\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,\n      0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },\n    { 0,2,2,3,1,1,1,1,2,0,0,0,0,0,0,0,\n      0x03,0x02,0x04,0x01,0x05,0x00,0x06,0x07,0x09,0x08,0x0a,0x0b,0xff  },\n    { 0,0,6,3,1,1,2,0,0,0,0,0,0,0,0,0,\n      0x06,0x05,0x07,0x04,0x08,0x03,0x09,0x02,0x00,0x0a,0x01,0x0b,0xff  },\n  };\n  static const uchar second_tree[3][180] = {\n    { 0,2,2,2,1,4,2,1,2,5,1,1,0,0,0,139,\n      0x03,0x04,0x02,0x05,0x01,0x06,0x07,0x08,\n      0x12,0x13,0x11,0x14,0x09,0x15,0x22,0x00,0x21,0x16,0x0a,0xf0,\n      0x23,0x17,0x24,0x31,0x32,0x18,0x19,0x33,0x25,0x41,0x34,0x42,\n      0x35,0x51,0x36,0x37,0x38,0x29,0x79,0x26,0x1a,0x39,0x56,0x57,\n      0x28,0x27,0x52,0x55,0x58,0x43,0x76,0x59,0x77,0x54,0x61,0xf9,\n      0x71,0x78,0x75,0x96,0x97,0x49,0xb7,0x53,0xd7,0x74,0xb6,0x98,\n      0x47,0x48,0x95,0x69,0x99,0x91,0xfa,0xb8,0x68,0xb5,0xb9,0xd6,\n      0xf7,0xd8,0x67,0x46,0x45,0x94,0x89,0xf8,0x81,0xd5,0xf6,0xb4,\n      0x88,0xb1,0x2a,0x44,0x72,0xd9,0x87,0x66,0xd4,0xf5,0x3a,0xa7,\n      0x73,0xa9,0xa8,0x86,0x62,0xc7,0x65,0xc8,0xc9,0xa1,0xf4,0xd1,\n      0xe9,0x5a,0x92,0x85,0xa6,0xe7,0x93,0xe8,0xc1,0xc6,0x7a,0x64,\n      0xe1,0x4a,0x6a,0xe6,0xb3,0xf1,0xd3,0xa5,0x8a,0xb2,0x9a,0xba,\n      0x84,0xa4,0x63,0xe5,0xc5,0xf3,0xd2,0xc4,0x82,0xaa,0xda,0xe4,\n      0xf2,0xca,0x83,0xa3,0xa2,0xc3,0xea,0xc2,0xe2,0xe3,0xff,0xff  },\n    { 0,2,2,1,4,1,4,1,3,3,1,0,0,0,0,140,\n      0x02,0x03,0x01,0x04,0x05,0x12,0x11,0x06,\n      0x13,0x07,0x08,0x14,0x22,0x09,0x21,0x00,0x23,0x15,0x31,0x32,\n      0x0a,0x16,0xf0,0x24,0x33,0x41,0x42,0x19,0x17,0x25,0x18,0x51,\n      0x34,0x43,0x52,0x29,0x35,0x61,0x39,0x71,0x62,0x36,0x53,0x26,\n      0x38,0x1a,0x37,0x81,0x27,0x91,0x79,0x55,0x45,0x28,0x72,0x59,\n      0xa1,0xb1,0x44,0x69,0x54,0x58,0xd1,0xfa,0x57,0xe1,0xf1,0xb9,\n      0x49,0x47,0x63,0x6a,0xf9,0x56,0x46,0xa8,0x2a,0x4a,0x78,0x99,\n      0x3a,0x75,0x74,0x86,0x65,0xc1,0x76,0xb6,0x96,0xd6,0x89,0x85,\n      0xc9,0xf5,0x95,0xb4,0xc7,0xf7,0x8a,0x97,0xb8,0x73,0xb7,0xd8,\n      0xd9,0x87,0xa7,0x7a,0x48,0x82,0x84,0xea,0xf4,0xa6,0xc5,0x5a,\n      0x94,0xa4,0xc6,0x92,0xc3,0x68,0xb5,0xc8,0xe4,0xe5,0xe6,0xe9,\n      0xa2,0xa3,0xe3,0xc2,0x66,0x67,0x93,0xaa,0xd4,0xd5,0xe7,0xf8,\n      0x88,0x9a,0xd7,0x77,0xc4,0x64,0xe2,0x98,0xa5,0xca,0xda,0xe8,\n      0xf3,0xf6,0xa9,0xb2,0xb3,0xf2,0xd2,0x83,0xba,0xd3,0xff,0xff  },\n    { 0,0,6,2,1,3,3,2,5,1,2,2,8,10,0,117,\n      0x04,0x05,0x03,0x06,0x02,0x07,0x01,0x08,\n      0x09,0x12,0x13,0x14,0x11,0x15,0x0a,0x16,0x17,0xf0,0x00,0x22,\n      0x21,0x18,0x23,0x19,0x24,0x32,0x31,0x25,0x33,0x38,0x37,0x34,\n      0x35,0x36,0x39,0x79,0x57,0x58,0x59,0x28,0x56,0x78,0x27,0x41,\n      0x29,0x77,0x26,0x42,0x76,0x99,0x1a,0x55,0x98,0x97,0xf9,0x48,\n      0x54,0x96,0x89,0x47,0xb7,0x49,0xfa,0x75,0x68,0xb6,0x67,0x69,\n      0xb9,0xb8,0xd8,0x52,0xd7,0x88,0xb5,0x74,0x51,0x46,0xd9,0xf8,\n      0x3a,0xd6,0x87,0x45,0x7a,0x95,0xd5,0xf6,0x86,0xb4,0xa9,0x94,\n      0x53,0x2a,0xa8,0x43,0xf5,0xf7,0xd4,0x66,0xa7,0x5a,0x44,0x8a,\n      0xc9,0xe8,0xc8,0xe7,0x9a,0x6a,0x73,0x4a,0x61,0xc7,0xf4,0xc6,\n      0x65,0xe9,0x72,0xe6,0x71,0x91,0x93,0xa6,0xda,0x92,0x85,0x62,\n      0xf3,0xc5,0xb2,0xa4,0x84,0xba,0x64,0xa5,0xb3,0xd2,0x81,0xe5,\n      0xd3,0xaa,0xc4,0xca,0xf2,0xb1,0xe4,0xd1,0x83,0x63,0xea,0xc3,\n      0xe2,0x82,0xf1,0xa3,0xc2,0xa1,0xc1,0xe3,0xa2,0xe1,0xff,0xff  }\n  };\n  if (table > 2) table = 2;\n  huff[0] = make_decoder ( first_tree[table]);\n  huff[1] = make_decoder (second_tree[table]);\n}\n\n/*\n   Return 0 if the image starts with compressed data,\n   1 if it starts with uncompressed low-order bits.\n\n   In Canon compressed data, 0xff is always followed by 0x00.\n */\nint CLASS canon_has_lowbits()\n{\n  uchar test[0x4000];\n  int ret=1, i;\n\n  fseek (ifp, 0, SEEK_SET);\n  fread (test, 1, sizeof test, ifp);\n  for (i=540; i < sizeof test - 1; i++)\n    if (test[i] == 0xff) {\n      if (test[i+1]) return 1;\n      ret=0;\n    }\n  return ret;\n}\n\nvoid CLASS canon_load_raw()\n{\n  ushort *pixel, *prow, *huff[2];\n  int nblocks, lowbits, i, c, row, r, save, val;\n  int block, diffbuf[64], leaf, len, diff, carry=0, pnum=0, base[2];\n\n  crw_init_tables (tiff_compress, huff);\n  lowbits = canon_has_lowbits();\n  if (!lowbits) maximum = 0x3ff;\n  fseek (ifp, 540 + lowbits*raw_height*raw_width/4, SEEK_SET);\n  zero_after_ff = 1;\n  getbits(-1);\n  for (row=0; row < raw_height; row+=8) {\n    pixel = raw_image + row*raw_width;\n    nblocks = MIN (8, raw_height-row) * raw_width >> 6;\n    for (block=0; block < nblocks; block++) {\n      memset (diffbuf, 0, sizeof diffbuf);\n      for (i=0; i < 64; i++ ) {\n\tleaf = gethuff(huff[i > 0]);\n\tif (leaf == 0 && i) break;\n\tif (leaf == 0xff) continue;\n\ti  += leaf >> 4;\n\tlen = leaf & 15;\n\tif (len == 0) continue;\n\tdiff = getbits(len);\n\tif ((diff & (1 << (len-1))) == 0)\n\t  diff -= (1 << len) - 1;\n\tif (i < 64) diffbuf[i] = diff;\n      }\n      diffbuf[0] += carry;\n      carry = diffbuf[0];\n      for (i=0; i < 64; i++ ) {\n\tif (pnum++ % raw_width == 0)\n\t  base[0] = base[1] = 512;\n\tif ((pixel[(block << 6) + i] = base[i & 1] += diffbuf[i]) >> 10)\n\t  derror();\n      }\n    }\n    if (lowbits) {\n      save = ftell(ifp);\n      fseek (ifp, 26 + row*raw_width/4, SEEK_SET);\n      for (prow=pixel, i=0; i < raw_width*2; i++) {\n\tc = fgetc(ifp);\n\tfor (r=0; r < 8; r+=2, prow++) {\n\t  val = (*prow << 2) + ((c >> r) & 3);\n\t  if (raw_width == 2672 && val < 512) val += 2;\n\t  *prow = val;\n\t}\n      }\n      fseek (ifp, save, SEEK_SET);\n    }\n  }\n  FORC(2) free (huff[c]);\n}\n//@end COMMON\n\n/*\n   Not a full implementation of Lossless JPEG, just\n   enough to decode Canon, Kodak and Adobe DNG images.\n */\nstruct jhead {\n  int bits, high, wide, clrs, sraw, psv, restart, vpred[6];\n  ushort *huff[6], *free[4], *row;\n};\n\n//@out COMMON\nint CLASS ljpeg_start (struct jhead *jh, int info_only)\n{\n  int c, tag, len;\n  uchar data[0x10000];\n  const uchar *dp;\n\n  memset (jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  fread (data, 2, 1, ifp);\n  if (data[1] != 0xd8) return 0;\n  do {\n    fread (data, 2, 2, ifp);\n    tag =  data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00) return 0;\n    fread (data, 1, len, ifp);\n    switch (tag) {\n      case 0xffc3:\n\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n      case 0xffc0:\n\tjh->bits = data[0];\n\tjh->high = data[1] << 8 | data[2];\n\tjh->wide = data[3] << 8 | data[4];\n\tjh->clrs = data[5] + jh->sraw;\n\tif (len == 9 && !dng_version) getc(ifp);\n\tbreak;\n      case 0xffc4:\n\tif (info_only) break;\n\tfor (dp = data; dp < data+len && (c = *dp++) < 4; )\n\t  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);\n\tbreak;\n      case 0xffda:\n\tjh->psv = data[1+data[0]*2];\n\tjh->bits -= data[3+data[0]*2] & 15;\n\tbreak;\n      case 0xffdd:\n\tjh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (info_only) return 1;\n  FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];\n  if (jh->sraw) {\n    FORC(4)        jh->huff[2+c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\n  }\n  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\n  merror (jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}\n\nvoid CLASS ljpeg_end (struct jhead *jh)\n{\n  int c;\n  FORC4 if (jh->free[c]) free (jh->free[c]);\n  free (jh->row);\n}\n\nint CLASS ljpeg_diff (ushort *huff)\n{\n  int len, diff;\n\n  len = gethuff(huff);\n  if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n    return -32768;\n  diff = getbits(len);\n  if ((diff & (1 << (len-1))) == 0)\n    diff -= (1 << len) - 1;\n  return diff;\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\nint CLASS ljpeg_diff_new (LibRaw_bit_buffer& bits, LibRaw_byte_buffer* buf,ushort *huff)\n{\n  int len, diff;\n\n  len = bits._gethuff_lj(buf,*huff,huff+1);\n  if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n    return -32768;\n  diff = bits._getbits_lj(buf,len);\n  if ((diff & (1 << (len-1))) == 0)\n    diff -= (1 << len) - 1;\n  return diff;\n}\n\nushort * CLASS ljpeg_row_new (int jrow, struct jhead *jh, LibRaw_bit_buffer& bits,LibRaw_byte_buffer* bytes)\n{\n  int col, c, diff, pred, spred=0;\n  ushort mark=0, *row[3];\n\n  if (jrow * jh->wide % jh->restart == 0) {\n    FORC(6) jh->vpred[c] = 1 << (jh->bits-1);\n    if (jrow) {\n        bytes->unseek2();\n        do mark = (mark << 8) + (c = bytes->get_byte());\n        while (c != EOF && mark >> 4 != 0xffd);\n    }\n    bits.reset();\n  }\n  FORC3 row[c] = jh->row + jh->wide*jh->clrs*((jrow+c) & 1);\n  for (col=0; col < jh->wide; col++)\n    FORC(jh->clrs) {\n        diff = ljpeg_diff_new (bits,bytes,jh->huff[c]);\n      if (jh->sraw && c <= jh->sraw && (col | c))\n\t\t    pred = spred;\n      else if (col) pred = row[0][-jh->clrs];\n      else\t    pred = (jh->vpred[c] += diff) - diff;\n      if (jrow && col) switch (jh->psv) {\n\tcase 1:\tbreak;\n\tcase 2: pred = row[1][0];\t\t\t\t\tbreak;\n\tcase 3: pred = row[1][-jh->clrs];\t\t\t\tbreak;\n\tcase 4: pred = pred +   row[1][0] - row[1][-jh->clrs];\t\tbreak;\n\tcase 5: pred = pred + ((row[1][0] - row[1][-jh->clrs]) >> 1);\tbreak;\n\tcase 6: pred = row[1][0] + ((pred - row[1][-jh->clrs]) >> 1);\tbreak;\n\tcase 7: pred = (pred + row[1][0]) >> 1;\t\t\t\tbreak;\n\tdefault: pred = 0;\n      }\n      if ((**row = pred + diff) >> jh->bits) derror();\n      if (c <= jh->sraw) spred = **row;\n      row[0]++; row[1]++;\n    }\n  return row[2];\n}\n\n#endif\n\n\nushort * CLASS ljpeg_row (int jrow, struct jhead *jh)\n{\n  int col, c, diff, pred, spred=0;\n  ushort mark=0, *row[3];\n\n  if (jrow * jh->wide % jh->restart == 0) {\n    FORC(6) jh->vpred[c] = 1 << (jh->bits-1);\n    if (jrow) {\n      fseek (ifp, -2, SEEK_CUR);\n      do mark = (mark << 8) + (c = fgetc(ifp));\n      while (c != EOF && mark >> 4 != 0xffd);\n    }\n    getbits(-1);\n  }\n  FORC3 row[c] = jh->row + jh->wide*jh->clrs*((jrow+c) & 1);\n  for (col=0; col < jh->wide; col++)\n    FORC(jh->clrs) {\n      diff = ljpeg_diff (jh->huff[c]);\n      if (jh->sraw && c <= jh->sraw && (col | c))\n\t\t    pred = spred;\n      else if (col) pred = row[0][-jh->clrs];\n      else\t    pred = (jh->vpred[c] += diff) - diff;\n      if (jrow && col) switch (jh->psv) {\n\tcase 1:\tbreak;\n\tcase 2: pred = row[1][0];\t\t\t\t\tbreak;\n\tcase 3: pred = row[1][-jh->clrs];\t\t\t\tbreak;\n\tcase 4: pred = pred +   row[1][0] - row[1][-jh->clrs];\t\tbreak;\n\tcase 5: pred = pred + ((row[1][0] - row[1][-jh->clrs]) >> 1);\tbreak;\n\tcase 6: pred = row[1][0] + ((pred - row[1][-jh->clrs]) >> 1);\tbreak;\n\tcase 7: pred = (pred + row[1][0]) >> 1;\t\t\t\tbreak;\n\tdefault: pred = 0;\n      }\n      if ((**row = pred + diff) >> jh->bits) derror();\n      if (c <= jh->sraw) spred = **row;\n      row[0]++; row[1]++;\n    }\n  return row[2];\n}\n\nvoid CLASS lossless_jpeg_load_raw()\n{\n  int jwide, jrow, jcol, val, i, row=0, col=0;\n#ifndef LIBRAW_LIBRARY_BUILD\n  int jidx,j;\n#endif\n  struct jhead jh;\n  ushort *rp;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  int save_min = 0;\n  unsigned slicesW[16],slicesWcnt=0,slices;\n  unsigned *offset;\n  unsigned t_y=0,t_x=0,t_s=0,slice=0,pixelsInSlice,pixno;\n  if (!strcasecmp(make,\"KODAK\"))\n      save_min = 1;\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (cr2_slice[0]>15)\n      throw LIBRAW_EXCEPTION_IO_EOF; // change many slices\n#else\n  if (cr2_slice[0]>15)\n  {\n      fprintf(stderr,\"Too many CR2 slices: %d\\n\",cr2_slice[0]+1);\n      return;\n  }\n#endif\n\n\n  if (!ljpeg_start (&jh, 0)) return;\n  jwide = jh.wide * jh.clrs;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(cr2_slice[0])\n      {\n          for(i=0;i<cr2_slice[0];i++)\n              slicesW[slicesWcnt++] = cr2_slice[1];\n          slicesW[slicesWcnt++] = cr2_slice[2];\n      }\n  else\n      {\n          // not sliced\n          slicesW[slicesWcnt++] = raw_width; // safe fallback\n      }\n       \n  slices = slicesWcnt * jh.high;\n  offset = (unsigned*)calloc(slices+1,sizeof(offset[0]));\n\n  for(slice=0;slice<slices;slice++)\n      {\n          offset[slice] = (t_x + t_y * raw_width)| (t_s<<28);\n          if((offset[slice] & 0x0fffffff) >= raw_width * raw_height)\n              throw LIBRAW_EXCEPTION_IO_BADFILE; \n          t_y++;\n          if(t_y == jh.high)\n              {\n                  t_y = 0;\n                  t_x += slicesW[t_s++];\n              }\n      }\n  offset[slices] = offset[slices-1];\n  slice = 1; // next slice\n  pixno = offset[0]; \n  pixelsInSlice = slicesW[0];\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  LibRaw_byte_buffer *buf=NULL;\n  if(data_size)\n      buf = ifp->make_byte_buffer(data_size);\n  LibRaw_bit_buffer bits;\n#endif\n\n  for (jrow=0; jrow < jh.high; jrow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (buf)\n          rp = ljpeg_row_new (jrow, &jh,bits,buf);\n      else\n#endif\n    rp = ljpeg_row (jrow, &jh);\n    if (load_flags & 1)\n      row = jrow & 1 ? height-1-jrow/2 : jrow/2;\n    for (jcol=0; jcol < jwide; jcol++) {\n      val = curve[*rp++];\n#ifndef LIBRAW_LIBRARY_BUILD\n      // slow dcraw way to calculate row/col\n      if (cr2_slice[0]) {\n\tjidx = jrow*jwide + jcol;\n\ti = jidx / (cr2_slice[1]*jh.high);\n\tif ((j = i >= cr2_slice[0]))\n\t\t i  = cr2_slice[0];\n\tjidx -= i * (cr2_slice[1]*jh.high);\n\trow = jidx / cr2_slice[1+j];\n\tcol = jidx % cr2_slice[1+j] + i*cr2_slice[1];\n      }\n#else\n      // new fast one, but for data_size defined only (i.e. new CR2 format, not 1D/1Ds)\n      if(buf) \n          {\n              if(!(load_flags & 1))\n                  row = pixno/raw_width;\n              col = pixno % raw_width;\n              pixno++;\n              if (0 == --pixelsInSlice)\n                  {\n                      unsigned o = offset[slice++];\n                      pixno = o & 0x0fffffff;\n                      pixelsInSlice = slicesW[o>>28];\n                  }\n          }\n#endif\n      if (raw_width == 3984 && (col -= 2) < 0)\n\tcol += (row--,raw_width);\n      if (row >= 0) RAW(row,col) = val;\n#ifndef LIBRAW_LIBRARY_BUILD\n      if (++col >= raw_width)\n\tcol = (row++,0);\n#else\n      if(!buf) // 1D or 1Ds case\n         if (++col >= raw_width)\n            col = (row++,0);\n#endif\n    }\n  }\n  ljpeg_end (&jh);\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(buf)\n      delete buf;\n  free(offset);\n#endif\n}\n\nvoid CLASS canon_sraw_load_raw()\n{\n  struct jhead jh;\n  short *rp=0, (*ip)[4];\n  int jwide, slice, scol, ecol, row, col, jrow=0, jcol=0, pix[3], c;\n  int v[3]={0,0,0}, ver, hue;\n  char *cp;\n\n  if (!ljpeg_start (&jh, 0)) return;\n  jwide = (jh.wide >>= 1) * jh.clrs;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!data_size)\n      throw LIBRAW_EXCEPTION_IO_BADFILE;\n  LibRaw_byte_buffer *buf = ifp->make_byte_buffer(data_size);\n  LibRaw_bit_buffer bits;\n#endif\n\n  for (ecol=slice=0; slice <= cr2_slice[0]; slice++) {\n    scol = ecol;\n    ecol += cr2_slice[1] * 2 / jh.clrs;\n    if (!cr2_slice[0] || ecol > raw_width-1) ecol = raw_width & -2;\n    for (row=0; row < height; row += (jh.clrs >> 1) - 1) {\n      ip = (short (*)[4]) image + row*width;\n      for (col=scol; col < ecol; col+=2, jcol+=jh.clrs) {\n\tif ((jcol %= jwide) == 0)\n#ifdef LIBRAW_LIBRARY_BUILD\n            rp = (short*) ljpeg_row_new (jrow++, &jh,bits,buf);\n#else\n            rp = (short *) ljpeg_row (jrow++, &jh);\n#endif\n\tif (col >= width) continue;\n\tFORC (jh.clrs-2)\n\t  ip[col + (c >> 1)*width + (c & 1)][0] = rp[jcol+c];\n\tip[col][1] = rp[jcol+jh.clrs-2] - 16384;\n\tip[col][2] = rp[jcol+jh.clrs-1] - 16384;\n      }\n    }\n  }\n  for (cp=model2; *cp && !isdigit(*cp); cp++);\n  sscanf (cp, \"%d.%d.%d\", v, v+1, v+2);\n  ver = (v[0]*1000 + v[1])*1000 + v[2];\n  hue = (jh.sraw+1) << 2;\n  if (unique_id >= 0x80000281 || (unique_id == 0x80000218 && ver > 1000006))\n    hue = jh.sraw << 1;\n  ip = (short (*)[4]) image;\n  rp = ip[0];\n  for (row=0; row < height; row++, ip+=width) {\n    if (row & (jh.sraw >> 1))\n      for (col=0; col < width; col+=2)\n\tfor (c=1; c < 3; c++)\n\t  if (row == height-1)\n\t       ip[col][c] =  ip[col-width][c];\n\t  else ip[col][c] = (ip[col-width][c] + ip[col+width][c] + 1) >> 1;\n    for (col=1; col < width; col+=2)\n      for (c=1; c < 3; c++)\n\tif (col == width-1)\n\t     ip[col][c] =  ip[col-1][c];\n\telse ip[col][c] = (ip[col-1][c] + ip[col+1][c] + 1) >> 1;\n  }\n  for ( ; rp < ip[0]; rp+=4) {\n    if (unique_id == 0x80000218 ||\n\tunique_id == 0x80000250 ||\n\tunique_id == 0x80000261 ||\n\tunique_id == 0x80000281 ||\n\tunique_id == 0x80000287) {\n      rp[1] = (rp[1] << 2) + hue;\n      rp[2] = (rp[2] << 2) + hue;\n      pix[0] = rp[0] + ((   50*rp[1] + 22929*rp[2]) >> 14);\n      pix[1] = rp[0] + ((-5640*rp[1] - 11751*rp[2]) >> 14);\n      pix[2] = rp[0] + ((29040*rp[1] -   101*rp[2]) >> 14);\n    } else {\n      if (unique_id < 0x80000218) rp[0] -= 512;\n      pix[0] = rp[0] + rp[2];\n      pix[2] = rp[0] + rp[1];\n      pix[1] = rp[0] + ((-778*rp[1] - (rp[2] << 11)) >> 12);\n    }\n    FORC3 rp[c] = CLIP(pix[c] * sraw_mul[c] >> 10);\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  delete buf;\n#endif\n  ljpeg_end (&jh);\n  maximum = 0x3fff;\n}\n\n#ifndef LIBRAW_LIBRARY_BUILD\nvoid CLASS adobe_copy_pixel (unsigned row, unsigned col, ushort **rp)\n{\n  int c;\n\n  if (is_raw == 2 && shot_select) (*rp)++;\n  if (raw_image) {\n    if (row < raw_height && col < raw_width)\n      RAW(row,col) = curve[**rp];\n    *rp += is_raw;\n  } else {\n    if (row < height && col < width)\n      FORC(tiff_samples)\n\timage[row*width+col][c] = curve[(*rp)[c]];\n    *rp += tiff_samples;\n  }\n  if (is_raw == 2 && shot_select) (*rp)--;\n}\n#else\nvoid CLASS adobe_copy_pixel_raw (unsigned row, unsigned col, ushort **rp)\n{\n  if (is_raw == 2 && shot_select) (*rp)++;\n  if (row < raw_height && col < raw_width)\n    RAW(row,col) = curve[**rp];\n  *rp += is_raw;\n  if (is_raw == 2 && shot_select) (*rp)--;\n}\nvoid CLASS adobe_copy_pixel_color (unsigned row, unsigned col, ushort **rp)\n{\n  int c;\n\n  if (is_raw == 2 && shot_select) (*rp)++;\n  if (row < height && col < width)\n    FORC(tiff_samples)\n      image[row*width+col][c] = curve[(*rp)[c]];\n  *rp += tiff_samples;\n  if (is_raw == 2 && shot_select) (*rp)--;\n}\n#endif\n\n\nvoid CLASS lossless_dng_load_raw()\n{\n  unsigned save, trow=0, tcol=0, jwide, jrow, jcol, row, col;\n  struct jhead jh;\n  ushort *rp;\n\n  while (trow < raw_height) {\n    save = ftell(ifp);\n    if (tile_length < INT_MAX)\n      fseek (ifp, get4(), SEEK_SET);\n    if (!ljpeg_start (&jh, 0)) break;\n    jwide = jh.wide;\n    if (filters) jwide *= jh.clrs;\n    jwide /= is_raw;\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(!data_size)\n        throw LIBRAW_EXCEPTION_IO_BADFILE;\n    LibRaw_byte_buffer *buf = ifp->make_byte_buffer(data_size);\n    LibRaw_bit_buffer bits;\n#endif\n\n#ifndef LIBRAW_LIBRARY_BUILD\n    for (row=col=jrow=0; jrow < jh.high; jrow++) {\n      rp = ljpeg_row (jrow, &jh);\n      for (jcol=0; jcol < jwide; jcol++) {\n\tadobe_copy_pixel (trow+row, tcol+col, &rp);\n\tif (++col >= tile_width || col >= raw_width)\n\t  row += 1 + (col = 0);\n      }\n    }\n#else\n    if(raw_image)\n      {\n        for (row=col=jrow=0; jrow < jh.high; jrow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n          rp = ljpeg_row_new (jrow, &jh,bits,buf);\n#else\n          rp = ljpeg_row (jrow, &jh);\n#endif\n          for (jcol=0; jcol < jwide; jcol++) {\n            adobe_copy_pixel_raw (trow+row, tcol+col, &rp);\n            if (++col >= tile_width || col >= raw_width)\n              row += 1 + (col = 0);\n          }\n        }\n      }\n    else\n      {\n        for (row=col=jrow=0; jrow < jh.high; jrow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n          rp = ljpeg_row_new (jrow, &jh,bits,buf);\n#else\n          rp = ljpeg_row (jrow, &jh);\n#endif\n          for (jcol=0; jcol < jwide; jcol++) {\n            adobe_copy_pixel_color (trow+row, tcol+col, &rp);\n            if (++col >= tile_width || col >= raw_width)\n              row += 1 + (col = 0);\n          }\n        }\n      }\n#endif\n    fseek (ifp, save+4, SEEK_SET);\n    if ((tcol += tile_width) >= raw_width)\n      trow += tile_length + (tcol = 0);\n    ljpeg_end (&jh);\n#ifdef LIBRAW_LIBRARY_BUILD\n    delete buf;\n#endif\n  }\n}\n\nvoid CLASS packed_dng_load_raw()\n{\n  ushort *pixel, *rp;\n  int row, col;\n\n  pixel = (ushort *) calloc (raw_width * tiff_samples, sizeof *pixel);\n  merror (pixel, \"packed_dng_load_raw()\");\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  int dsz= raw_height*raw_width * tiff_samples * tiff_bps/8;\n  LibRaw_byte_buffer *buf = NULL;\n  if (tiff_bps != 16)\n      {\n          buf = ifp->make_byte_buffer(dsz);\n      }\n  LibRaw_bit_buffer bits;\n#endif\n\n  for (row=0; row < raw_height; row++) {\n    if (tiff_bps == 16)\n      read_shorts (pixel, raw_width * tiff_samples);\n    else {\n#ifdef LIBRAW_LIBRARY_BUILD\n        bits.reset();\n        for (col=0; col < raw_width * tiff_samples; col++)\n            pixel[col] = bits._getbits(buf,tiff_bps,zero_after_ff);\n\n#else\n      getbits(-1);\n      for (col=0; col < raw_width * tiff_samples; col++)\n\tpixel[col] = getbits(tiff_bps);\n#endif\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n    for (rp=pixel, col=0; col < raw_width; col++)\n      adobe_copy_pixel (row, col, &rp);\n#else\n    if(raw_image)\n      for (rp=pixel, col=0; col < raw_width; col++)\n        adobe_copy_pixel_raw (row, col, &rp);\n    else\n      for (rp=pixel, col=0; col < raw_width; col++)\n        adobe_copy_pixel_color (row, col, &rp);\n#endif\n  }\n  free (pixel);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(buf)\n        delete buf;\n#endif\n}\n\nvoid CLASS pentax_load_raw()\n{\n  ushort bit[2][15], huff[4097];\n  int dep, row, col, diff, c, i;\n  ushort vpred[2][2] = {{0,0},{0,0}}, hpred[2];\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  dep = (get2() + 12) & 15;\n  fseek (ifp, 12, SEEK_CUR);\n  FORC(dep) bit[0][c] = get2();\n  FORC(dep) bit[1][c] = fgetc(ifp);\n  FORC(dep)\n    for (i=bit[0][c]; i <= ((bit[0][c]+(4096 >> bit[1][c])-1) & 4095); )\n      huff[++i] = bit[1][c] << 8 | c;\n  huff[0] = 12;\n  fseek (ifp, data_offset, SEEK_SET);\n  getbits(-1);\n  for (row=0; row < raw_height; row++)\n    for (col=0; col < raw_width; col++) {\n      diff = ljpeg_diff (huff);\n      if (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n      else\t   hpred[col & 1] += diff;\n      RAW(row,col) = hpred[col & 1];\n      if (hpred[col & 1] >> tiff_bps) derror();\n    }\n}\n\nvoid CLASS nikon_load_raw()\n{\n  static const uchar nikon_tree[][32] = {\n    { 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,\t/* 12-bit lossy */\n      5,4,3,6,2,7,1,0,8,9,11,10,12 },\n    { 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,\t/* 12-bit lossy after split */\n      0x39,0x5a,0x38,0x27,0x16,5,4,3,2,1,0,11,12,12 },\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,  /* 12-bit lossless */\n      5,4,6,3,7,2,8,1,9,0,10,11,12 },\n    { 0,1,4,3,1,1,1,1,1,2,0,0,0,0,0,0,\t/* 14-bit lossy */\n      5,6,4,7,8,3,9,2,1,0,10,11,12,13,14 },\n    { 0,1,5,1,1,1,1,1,1,1,2,0,0,0,0,0,\t/* 14-bit lossy after split */\n      8,0x5c,0x4b,0x3a,0x29,7,6,5,4,3,2,1,0,13,14 },\n    { 0,1,4,2,2,3,1,2,0,0,0,0,0,0,0,0,\t/* 14-bit lossless */\n      7,6,8,5,9,4,10,3,11,12,2,0,1,13,14 } };\n  ushort *huff, ver0, ver1, vpred[2][2], hpred[2], csize;\n  int i, min, max, step=0, tree=0, split=0, row, col, len, shl, diff;\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  ver0 = fgetc(ifp);\n  ver1 = fgetc(ifp);\n  if (ver0 == 0x49 || ver1 == 0x58)\n    fseek (ifp, 2110, SEEK_CUR);\n  if (ver0 == 0x46) tree = 2;\n  if (tiff_bps == 14) tree += 3;\n  read_shorts (vpred[0], 4);\n  max = 1 << tiff_bps & 0x7fff;\n  if ((csize = get2()) > 1)\n    step = max / (csize-1);\n  if (ver0 == 0x44 && ver1 == 0x20 && step > 0) {\n    for (i=0; i < csize; i++)\n      curve[i*step] = get2();\n    for (i=0; i < max; i++)\n      curve[i] = ( curve[i-i%step]*(step-i%step) +\n\t\t   curve[i-i%step+step]*(i%step) ) / step;\n    fseek (ifp, meta_offset+562, SEEK_SET);\n    split = get2();\n  } else if (ver0 != 0x46 && csize <= 0x4001)\n    read_shorts (curve, max=csize);\n  while (curve[max-2] == curve[max-1]) max--;\n  huff = make_decoder (nikon_tree[tree]);\n  fseek (ifp, data_offset, SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!data_size)\n      throw LIBRAW_EXCEPTION_IO_BADFILE;\n  LibRaw_byte_buffer *buf = ifp->make_byte_buffer(data_size);\n  LibRaw_bit_buffer bits;\n  bits.reset();\n#else\n  getbits(-1);\n#endif\n  for (min=row=0; row < height; row++) {\n    if (split && row == split) {\n      free (huff);\n      huff = make_decoder (nikon_tree[tree+1]);\n      max += (min = 16) << 1;\n    }\n    for (col=0; col < raw_width; col++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n        i = bits._gethuff(buf,*huff,huff+1,zero_after_ff);\n#else\n      i = gethuff(huff);\n#endif\n      len = i & 15;\n      shl = i >> 4;\n#ifdef LIBRAW_LIBRARY_BUILD\n      diff = ((bits._getbits(buf,len-shl,zero_after_ff) << 1) + 1) << shl >> 1;\n#else\n      diff = ((getbits(len-shl) << 1) + 1) << shl >> 1;\n#endif\n      if ((diff & (1 << (len-1))) == 0)\n\tdiff -= (1 << len) - !shl;\n      if (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n      else\t   hpred[col & 1] += diff;\n      if ((ushort)(hpred[col & 1] + min) >= max) derror();\n      RAW(row,col) = curve[LIM((short)hpred[col & 1],0,0x3fff)];\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  delete buf;\n#endif\n  free (huff);\n}\n\n/*\n   Returns 1 for a Coolpix 995, 0 for anything else.\n */\nint CLASS nikon_e995()\n{\n  int i, histo[256];\n  const uchar often[] = { 0x00, 0x55, 0xaa, 0xff };\n\n  memset (histo, 0, sizeof histo);\n  fseek (ifp, -2000, SEEK_END);\n  for (i=0; i < 2000; i++)\n    histo[fgetc(ifp)]++;\n  for (i=0; i < 4; i++)\n    if (histo[often[i]] < 200)\n      return 0;\n  return 1;\n}\n\n/*\n   Returns 1 for a Coolpix 2100, 0 for anything else.\n */\nint CLASS nikon_e2100()\n{\n  uchar t[12];\n  int i;\n\n  fseek (ifp, 0, SEEK_SET);\n  for (i=0; i < 1024; i++) {\n    fread (t, 1, 12, ifp);\n    if (((t[2] & t[4] & t[7] & t[9]) >> 4\n\t& t[1] & t[6] & t[8] & t[11] & 3) != 3)\n      return 0;\n  }\n  return 1;\n}\n\nvoid CLASS nikon_3700()\n{\n  int bits, i;\n  uchar dp[24];\n  static const struct {\n    int bits;\n    char t_make[12], t_model[15];\n  } table[] = {\n    { 0x00, \"PENTAX\",  \"Optio 33WR\" },\n    { 0x03, \"NIKON\",   \"E3200\" },\n    { 0x32, \"NIKON\",   \"E3700\" },\n    { 0x33, \"OLYMPUS\", \"C740UZ\" } };\n\n  fseek (ifp, 3072, SEEK_SET);\n  fread (dp, 1, 24, ifp);\n  bits = (dp[8] & 3) << 4 | (dp[20] & 3);\n  for (i=0; i < sizeof table / sizeof *table; i++)\n    if (bits == table[i].bits) {\n      strcpy (make,  table[i].t_make );\n      strcpy (model, table[i].t_model);\n    }\n}\n\n/*\n   Separates a Minolta DiMAGE Z2 from a Nikon E4300.\n */\nint CLASS minolta_z2()\n{\n  int i, nz;\n  char tail[424];\n\n  fseek (ifp, -sizeof tail, SEEK_END);\n  fread (tail, 1, sizeof tail, ifp);\n  for (nz=i=0; i < sizeof tail; i++)\n    if (tail[i]) nz++;\n  return nz > 20;\n}\n//@end COMMON\n\nvoid CLASS jpeg_thumb();\n\n//@out COMMON\nvoid CLASS ppm_thumb()\n{\n  char *thumb;\n  thumb_length = thumb_width*thumb_height*3;\n  thumb = (char *) malloc (thumb_length);\n  merror (thumb, \"ppm_thumb()\");\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  fread  (thumb, 1, thumb_length, ifp);\n  fwrite (thumb, 1, thumb_length, ofp);\n  free (thumb);\n}\n\nvoid CLASS ppm16_thumb()\n{\n  int i;\n  char *thumb;\n  thumb_length = thumb_width*thumb_height*3;\n  thumb = (char *) calloc (thumb_length,2);\n  merror (thumb, \"ppm16_thumb()\");\n  read_shorts ((ushort *) thumb, thumb_length);\n  for (i=0; i < thumb_length; i++)\n    thumb[i] = ((ushort *) thumb)[i] >> 8;\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  fwrite (thumb, 1, thumb_length, ofp);\n  free (thumb);\n}\n\nvoid CLASS layer_thumb()\n{\n  int i, c;\n  char *thumb, map[][4] = { \"012\",\"102\" };\n\n  colors = thumb_misc >> 5 & 7;\n  thumb_length = thumb_width*thumb_height;\n  thumb = (char *) calloc (colors, thumb_length);\n  merror (thumb, \"layer_thumb()\");\n  fprintf (ofp, \"P%d\\n%d %d\\n255\\n\",\n\t5 + (colors >> 1), thumb_width, thumb_height);\n  fread (thumb, thumb_length, colors, ifp);\n  for (i=0; i < thumb_length; i++)\n    FORCC putc (thumb[i+thumb_length*(map[thumb_misc >> 8][c]-'0')], ofp);\n  free (thumb);\n}\n\nvoid CLASS rollei_thumb()\n{\n  unsigned i;\n  ushort *thumb;\n\n  thumb_length = thumb_width * thumb_height;\n  thumb = (ushort *) calloc (thumb_length, 2);\n  merror (thumb, \"rollei_thumb()\");\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  read_shorts (thumb, thumb_length);\n  for (i=0; i < thumb_length; i++) {\n    putc (thumb[i] << 3, ofp);\n    putc (thumb[i] >> 5  << 2, ofp);\n    putc (thumb[i] >> 11 << 3, ofp);\n  }\n  free (thumb);\n}\n\nvoid CLASS rollei_load_raw()\n{\n  uchar pixel[10];\n  unsigned iten=0, isix, i, buffer=0, todo[16];\n\n  isix = raw_width * raw_height * 5 / 8;\n  while (fread (pixel, 1, 10, ifp) == 10) {\n    for (i=0; i < 10; i+=2) {\n      todo[i]   = iten++;\n      todo[i+1] = pixel[i] << 8 | pixel[i+1];\n      buffer    = pixel[i] >> 2 | buffer << 6;\n    }\n    for (   ; i < 16; i+=2) {\n      todo[i]   = isix++;\n      todo[i+1] = buffer >> (14-i)*5;\n    }\n    for (i=0; i < 16; i+=2)\n      raw_image[todo[i]] = (todo[i+1] & 0x3ff);\n  }\n  maximum = 0x3ff;\n}\n\nint CLASS raw (unsigned row, unsigned col)\n{\n  return (row < raw_height && col < raw_width) ? RAW(row,col) : 0;\n}\n\nvoid CLASS phase_one_flat_field (int is_float, int nc)\n{\n  ushort head[8];\n  unsigned wide, y, x, c, rend, cend, row, col;\n  float *mrow, num, mult[4];\n\n  read_shorts (head, 8);\n  wide = head[2] / head[4];\n  mrow = (float *) calloc (nc*wide, sizeof *mrow);\n  merror (mrow, \"phase_one_flat_field()\");\n  for (y=0; y < head[3] / head[5]; y++) {\n    for (x=0; x < wide; x++)\n      for (c=0; c < nc; c+=2) {\n\tnum = is_float ? getreal(11) : get2()/32768.0;\n\tif (y==0) mrow[c*wide+x] = num;\n\telse mrow[(c+1)*wide+x] = (num - mrow[c*wide+x]) / head[5];\n      }\n    if (y==0) continue;\n    rend = head[1] + y*head[5];\n    for (row = rend-head[5]; row < raw_height && row < rend; row++) {\n      for (x=1; x < wide; x++) {\n\tfor (c=0; c < nc; c+=2) {\n\t  mult[c] = mrow[c*wide+x-1];\n\t  mult[c+1] = (mrow[c*wide+x] - mult[c]) / head[4];\n\t}\n\tcend = head[0] + x*head[4];\n\tfor (col = cend-head[4]; col < raw_width && col < cend; col++) {\n\t  c = nc > 2 ? FC(row-top_margin,col-left_margin) : 0;\n\t  if (!(c & 1)) {\n\t    c = RAW(row,col) * mult[c];\n\t    RAW(row,col) = LIM(c,0,65535);\n\t  }\n\t  for (c=0; c < nc; c+=2)\n\t    mult[c] += mult[c+1];\n\t}\n      }\n      for (x=0; x < wide; x++)\n\tfor (c=0; c < nc; c+=2)\n\t  mrow[c*wide+x] += mrow[(c+1)*wide+x];\n    }\n  }\n  free (mrow);\n}\n\nvoid CLASS phase_one_correct()\n{\n  unsigned entries, tag, data, save, col, row, type;\n  int len, i, j, k, cip, val[4], dev[4], sum, max;\n  int head[9], diff, mindiff=INT_MAX, off_412=0;\n  static const signed char dir[12][2] =\n    { {-1,-1}, {-1,1}, {1,-1}, {1,1}, {-2,0}, {0,-2}, {0,2}, {2,0},\n      {-2,-2}, {-2,2}, {2,-2}, {2,2} };\n  float poly[8], num, cfrac, frac, mult[2], *yval[2];\n  ushort *xval[2];\n\n  if (half_size || !meta_length) return;\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Phase One correction...\\n\"));\n#endif\n  fseek (ifp, meta_offset, SEEK_SET);\n  order = get2();\n  fseek (ifp, 6, SEEK_CUR);\n  fseek (ifp, meta_offset+get4(), SEEK_SET);\n  entries = get4();  get4();\n  while (entries--) {\n    tag  = get4();\n    len  = get4();\n    data = get4();\n    save = ftell(ifp);\n    fseek (ifp, meta_offset+data, SEEK_SET);\n    if (tag == 0x419) {\t\t\t\t/* Polynomial curve */\n      for (get4(), i=0; i < 8; i++)\n\tpoly[i] = getreal(11);\n      poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;\n      for (i=0; i < 0x10000; i++) {\n\tnum = (poly[5]*i + poly[3])*i + poly[1];\n\tcurve[i] = LIM(num,0,65535);\n      } goto apply;\t\t\t\t/* apply to right half */\n    } else if (tag == 0x41a) {\t\t\t/* Polynomial curve */\n      for (i=0; i < 4; i++)\n\tpoly[i] = getreal(11);\n      for (i=0; i < 0x10000; i++) {\n\tfor (num=0, j=4; j--; )\n\t  num = num * i + poly[j];\n\tcurve[i] = LIM(num+i,0,65535);\n      } apply:\t\t\t\t\t/* apply to whole image */\n      for (row=0; row < raw_height; row++)\n\tfor (col = (tag & 1)*ph1.split_col; col < raw_width; col++)\n\t  RAW(row,col) = curve[RAW(row,col)];\n    } else if (tag == 0x400) {\t\t\t/* Sensor defects */\n      while ((len -= 8) >= 0) {\n\tcol  = get2();\n\trow  = get2();\n\ttype = get2(); get2();\n\tif (col >= raw_width) continue;\n\tif (type == 131)\t\t\t/* Bad column */\n\t  for (row=0; row < raw_height; row++)\n\t    if (FC(row-top_margin,col-left_margin) == 1) {\n\t      for (sum=i=0; i < 4; i++)\n\t\tsum += val[i] = raw (row+dir[i][0], col+dir[i][1]);\n\t      for (max=i=0; i < 4; i++) {\n\t\tdev[i] = abs((val[i] << 2) - sum);\n\t\tif (dev[max] < dev[i]) max = i;\n\t      }\n\t      RAW(row,col) = (sum - val[max])/3.0 + 0.5;\n\t    } else {\n\t      for (sum=0, i=8; i < 12; i++)\n\t\tsum += raw (row+dir[i][0], col+dir[i][1]);\n\t      RAW(row,col) = 0.5 + sum * 0.0732233 +\n\t\t(raw(row,col-2) + raw(row,col+2)) * 0.3535534;\n\t    }\n\telse if (type == 129) {\t\t\t/* Bad pixel */\n\t  if (row >= raw_height) continue;\n\t  j = (FC(row-top_margin,col-left_margin) != 1) * 4;\n\t  for (sum=0, i=j; i < j+8; i++)\n\t    sum += raw (row+dir[i][0], col+dir[i][1]);\n\t  RAW(row,col) = (sum + 4) >> 3;\n\t}\n      }\n    } else if (tag == 0x401) {\t\t\t/* All-color flat fields */\n      phase_one_flat_field (1, 2);\n    } else if (tag == 0x416 || tag == 0x410) {\n      phase_one_flat_field (0, 2);\n    } else if (tag == 0x40b) {\t\t\t/* Red+blue flat field */\n      phase_one_flat_field (0, 4);\n    } else if (tag == 0x412) {\n      fseek (ifp, 36, SEEK_CUR);\n      diff = abs (get2() - ph1.tag_21a);\n      if (mindiff > diff) {\n\tmindiff = diff;\n\toff_412 = ftell(ifp) - 38;\n      }\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n  if (off_412) {\n    fseek (ifp, off_412, SEEK_SET);\n    for (i=0; i < 9; i++) head[i] = get4() & 0x7fff;\n    yval[0] = (float *) calloc (head[1]*head[3] + head[2]*head[4], 6);\n    merror (yval[0], \"phase_one_correct()\");\n    yval[1] = (float  *) (yval[0] + head[1]*head[3]);\n    xval[0] = (ushort *) (yval[1] + head[2]*head[4]);\n    xval[1] = (ushort *) (xval[0] + head[1]*head[3]);\n    get2();\n    for (i=0; i < 2; i++)\n      for (j=0; j < head[i+1]*head[i+3]; j++)\n\tyval[i][j] = getreal(11);\n    for (i=0; i < 2; i++)\n      for (j=0; j < head[i+1]*head[i+3]; j++)\n\txval[i][j] = get2();\n    for (row=0; row < raw_height; row++)\n      for (col=0; col < raw_width; col++) {\n\tcfrac = (float) col * head[3] / raw_width;\n\tcfrac -= cip = cfrac;\n\tnum = RAW(row,col) * 0.5;\n\tfor (i=cip; i < cip+2; i++) {\n\t  for (k=j=0; j < head[1]; j++)\n\t    if (num < xval[0][k = head[1]*i+j]) break;\n\t  frac = (j == 0 || j == head[1]) ? 0 :\n\t\t(xval[0][k] - num) / (xval[0][k] - xval[0][k-1]);\n\t  mult[i-cip] = yval[0][k-1] * frac + yval[0][k] * (1-frac);\n\t}\n\ti = ((mult[0] * (1-cfrac) + mult[1] * cfrac) * row + num) * 2;\n\tRAW(row,col) = LIM(i,0,65535);\n      }\n    free (yval[0]);\n  }\n}\n\nvoid CLASS phase_one_load_raw()\n{\n  int a, b, i;\n  ushort akey, bkey, t_mask;\n\n  fseek (ifp, ph1.key_off, SEEK_SET);\n  akey = get2();\n  bkey = get2();\n  t_mask = ph1.format == 1 ? 0x5555:0x1354;\n  fseek (ifp, data_offset, SEEK_SET);\n  read_shorts (raw_image, raw_width*raw_height);\n  if (ph1.format)\n    for (i=0; i < raw_width*raw_height; i+=2) {\n      a = raw_image[i+0] ^ akey;\n      b = raw_image[i+1] ^ bkey;\n      raw_image[i+0] = (a & t_mask) | (b & ~t_mask);\n      raw_image[i+1] = (b & t_mask) | (a & ~t_mask);\n    }\n}\n\nunsigned CLASS ph1_bithuff (int nbits, ushort *huff)\n{\n#ifndef LIBRAW_NOTHREADS\n#define bitbuf tls->ph1_bits.bitbuf\n#define vbits  tls->ph1_bits.vbits    \n#else\n  static UINT64 bitbuf=0;\n  static int vbits=0;\n#endif\n  unsigned c;\n\n  if (nbits == -1)\n    return bitbuf = vbits = 0;\n  if (nbits == 0) return 0;\n  if (vbits < nbits) {\n    bitbuf = bitbuf << 32 | get4();\n    vbits += 32;\n  }\n  c = bitbuf << (64-vbits) >> (64-nbits);\n  if (huff) {\n    vbits -= huff[c] >> 8;\n    return (uchar) huff[c];\n  }\n  vbits -= nbits;\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#endif\n}\n#define ph1_bits(n) ph1_bithuff(n,0)\n#define ph1_huff(h) ph1_bithuff(*h,h+1)\n\nvoid CLASS phase_one_load_raw_c()\n{\n  static const int length[] = { 8,7,6,9,11,10,5,12,14,13 };\n  int *offset, len[2], pred[2], row, col, i, j;\n  ushort *pixel;\n  short (*t_black)[2];\n\n  pixel = (ushort *) calloc (raw_width + raw_height*4, 2);\n  merror (pixel, \"phase_one_load_raw_c()\");\n  offset = (int *) (pixel + raw_width);\n  fseek (ifp, strip_offset, SEEK_SET);\n  for (row=0; row < raw_height; row++)\n    offset[row] = get4();\n  t_black = (short (*)[2]) offset + raw_height;\n  fseek (ifp, ph1.black_off, SEEK_SET);\n  if (ph1.black_off)\n      {\n          read_shorts ((ushort *) t_black[0], raw_height*2);\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.rawdata.ph1_black = (short (*)[2])calloc(raw_height*2,sizeof(short));\n          merror (imgdata.rawdata.ph1_black, \"phase_one_load_raw_c()\");\n          memmove(imgdata.rawdata.ph1_black,(short *) t_black[0],raw_height*2*sizeof(short));\n#endif\n      }\n  for (i=0; i < 256; i++)\n    curve[i] = i*i / 3.969 + 0.5;\n  for (row=0; row < raw_height; row++) {\n    fseek (ifp, data_offset + offset[row], SEEK_SET);\n    ph1_bits(-1);\n    pred[0] = pred[1] = 0;\n    for (col=0; col < raw_width; col++) {\n      if (col >= (raw_width & -8))\n\tlen[0] = len[1] = 14;\n      else if ((col & 7) == 0)\n\tfor (i=0; i < 2; i++) {\n\t  for (j=0; j < 5 && !ph1_bits(1); j++);\n\t  if (j--) len[i] = length[j*2 + ph1_bits(1)];\n\t}\n      if ((i = len[col & 1]) == 14)\n\tpixel[col] = pred[col & 1] = ph1_bits(16);\n      else\n\tpixel[col] = pred[col & 1] += ph1_bits(i) + 1 - (1 << (i - 1));\n      if (pred[col & 1] >> 16) derror();\n      if (ph1.format == 5 && pixel[col] < 256)\n\tpixel[col] = curve[pixel[col]];\n    }\n    for (col=0; col < raw_width; col++) {\n#ifndef LIBRAW_LIBRARY_BUILD\n      i = (pixel[col] << 2) - ph1.t_black + t_black[row][col >= ph1.split_col];\n      if (i > 0) RAW(row,col) = i;\n#else\n      RAW(row,col) = pixel[col] << 2;\n#endif\n    }\n  }\n  free (pixel);\n  maximum = 0xfffc - ph1.t_black;\n}\n\nvoid CLASS hasselblad_load_raw()\n{\n  struct jhead jh;\n  int row, col, pred[2], len[2], diff, c;\n\n  if (!ljpeg_start (&jh, 0)) return;\n  order = 0x4949;\n  ph1_bits(-1);\n  for (row=0; row < raw_height; row++) {\n    pred[0] = pred[1] = 0x8000 + load_flags;\n    for (col=0; col < raw_width; col+=2) {\n      FORC(2) len[c] = ph1_huff(jh.huff[0]);\n      FORC(2) {\n\tdiff = ph1_bits(len[c]);\n\tif ((diff & (1 << (len[c]-1))) == 0)\n\t  diff -= (1 << len[c]) - 1;\n\tif (diff == 65535) diff = -32768;\n\tRAW(row,col+c) = pred[c] += diff;\n      }\n    }\n  }\n  ljpeg_end (&jh);\n  maximum = 0xffff;\n}\n\nvoid CLASS leaf_hdr_load_raw()\n{\n  ushort *pixel=0;\n  unsigned tile=0, r, c, row, col;\n\n  if (!filters) {\n    pixel = (ushort *) calloc (raw_width, sizeof *pixel);\n    merror (pixel, \"leaf_hdr_load_raw()\");\n  }\n  FORC(tiff_samples)\n    for (r=0; r < raw_height; r++) {\n      if (r % tile_length == 0) {\n\tfseek (ifp, data_offset + 4*tile++, SEEK_SET);\n\tfseek (ifp, get4(), SEEK_SET);\n      }\n      if (filters && c != shot_select) continue;\n      if (filters) pixel = raw_image + r*raw_width;\n      read_shorts (pixel, raw_width);\n      if (!filters && (row = r - top_margin) < height)\n\tfor (col=0; col < width; col++)\n\t  image[row*width+col][c] = pixel[col+left_margin];\n    }\n  if (!filters) {\n    maximum = 0xffff;\n    raw_color = 1;\n    free (pixel);\n  }\n}\n\nvoid CLASS unpacked_load_raw()\n{\n  int row, col, bits=0;\n\n  while (1 << ++bits < maximum);\n  read_shorts (raw_image, raw_width*raw_height);\n  for (row=0; row < raw_height; row++)\n    for (col=0; col < raw_width; col++)\n      if ((RAW(row,col) >>= load_flags) >> bits\n\t&& (unsigned) (row-top_margin) < height\n\t&& (unsigned) (col-left_margin) < width) derror();\n}\n\nvoid CLASS sinar_4shot_load_raw()\n{\n  ushort *pixel;\n  unsigned shot, row, col, r, c;\n\n  if ((shot = shot_select) || half_size) {\n    if (shot) shot--;\n    if (shot > 3) shot = 3;\n    fseek (ifp, data_offset + shot*4, SEEK_SET);\n    fseek (ifp, get4(), SEEK_SET);\n    unpacked_load_raw();\n    return;\n  }\n#ifndef LIBRAW_LIBRARY_BUILD\n  free (raw_image);\n  raw_image = 0;\n  free (image);\n  image = (ushort (*)[4])\n\tcalloc ((iheight=height)*(iwidth=width), sizeof *image);\n  merror (image, \"sinar_4shot_load_raw()\");\n#endif\n  pixel = (ushort *) calloc (raw_width, sizeof *pixel);\n  merror (pixel, \"sinar_4shot_load_raw()\");\n  for (shot=0; shot < 4; shot++) {\n    fseek (ifp, data_offset + shot*4, SEEK_SET);\n    fseek (ifp, get4(), SEEK_SET);\n    for (row=0; row < raw_height; row++) {\n      read_shorts (pixel, raw_width);\n      if ((r = row-top_margin - (shot >> 1 & 1)) >= height) continue;\n      for (col=0; col < raw_width; col++) {\n\tif ((c = col-left_margin - (shot & 1)) >= width) continue;\n\timage[r*width+c][FC(row,col)] = pixel[col];\n      }\n    }\n  }\n  free (pixel);\n  shrink = filters = 0;\n}\n\nvoid CLASS imacon_full_load_raw()\n{\n  int row, col;\n\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      read_shorts (image[row*width+col], 3);\n}\n\nvoid CLASS packed_load_raw()\n{\n  int vbits=0, bwide, pwide, rbits, bite, half, irow, row, col, val, i;\n  UINT64 bitbuf=0;\n\n  if (raw_width * 8 >= width * tiff_bps)\t/* Is raw_width in bytes? */\n       pwide = (bwide = raw_width) * 8 / tiff_bps;\n  else bwide = (pwide = raw_width) * tiff_bps / 8;\n  rbits = bwide * 8 - pwide * tiff_bps;\n  if (load_flags & 1) bwide = bwide * 16 / 15;\n  bite = 8 + (load_flags & 24);\n  half = (raw_height+1) >> 1;\n  for (irow=0; irow < raw_height; irow++) {\n    row = irow;\n    if (load_flags & 2 &&\n\t(row = irow % half * 2 + irow / half) == 1 &&\n\tload_flags & 4) {\n      if (vbits=0, tiff_compress)\n\tfseek (ifp, data_offset - (-half*bwide & -2048), SEEK_SET);\n      else {\n\tfseek (ifp, 0, SEEK_END);\n\tfseek (ifp, ftell(ifp) >> 3 << 2, SEEK_SET);\n      }\n    }\n    for (col=0; col < pwide; col++) {\n      for (vbits -= tiff_bps; vbits < 0; vbits += bite) {\n\tbitbuf <<= bite;\n\tfor (i=0; i < bite; i+=8)\n\t  bitbuf |= (unsigned) (fgetc(ifp) << i);\n      }\n      val = bitbuf << (64-tiff_bps-vbits) >> (64-tiff_bps);\n      RAW(row,col ^ (load_flags >> 6)) = val;\n      if (load_flags & 1 && (col % 10) == 9 &&\n\tfgetc(ifp) && col < width+left_margin) derror();\n    }\n    vbits -= rbits;\n  }\n}\n\nvoid CLASS nokia_load_raw()\n{\n  uchar  *data,  *dp;\n  int rev, dwide, row, col, c;\n\n  rev = 3 * (order == 0x4949);\n  dwide = (raw_width * 5 +1) / 4;\n  data = (uchar *) malloc (dwide*2);\n  merror (data, \"nokia_load_raw()\");\n  for (row=0; row < raw_height; row++) {\n    if (fread (data+dwide, 1, dwide, ifp) < dwide) derror();\n    FORC(dwide) data[c] = data[dwide+(c ^ rev)];\n    for (dp=data, col=0; col < raw_width; dp+=5, col+=4)\n      FORC4 RAW(row,col+c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n  }\n  free (data);\n  maximum = 0x3ff;\n}\n\nunsigned CLASS pana_bits (int nbits)\n{\n#ifndef LIBRAW_NOTHREADS\n#define buf tls->pana_bits.buf\n#define vbits tls->pana_bits.vbits   \n#else\n  static uchar buf[0x4000];\n  static int vbits;\n#endif\n  int byte;\n\n  if (!nbits) return vbits=0;\n  if (!vbits) {\n    fread (buf+load_flags, 1, 0x4000-load_flags, ifp);\n    fread (buf, 1, load_flags, ifp);\n  }\n  vbits = (vbits - nbits) & 0x1ffff;\n  byte = vbits >> 3 ^ 0x3ff0;\n  return (buf[byte] | buf[byte+1] << 8) >> (vbits & 7) & ~(-1 << nbits);\n#ifndef LIBRAW_NOTHREADS\n#undef buf\n#undef vbits\n#endif\n}\n\nvoid CLASS panasonic_load_raw()\n{\n  int row, col, i, j, sh=0, pred[2], nonz[2];\n\n  pana_bits(0);\n  for (row=0; row < height; row++)\n    for (col=0; col < raw_width; col++) {\n      if ((i = col % 14) == 0)\n\tpred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n      if (i % 3 == 2) sh = 4 >> (3 - pana_bits(2));\n      if (nonz[i & 1]) {\n\tif ((j = pana_bits(8))) {\n\t  if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)\n\t       pred[i & 1] &= ~(-1 << sh);\n\t  pred[i & 1] += j << sh;\n\t}\n      } else if ((nonz[i & 1] = pana_bits(8)) || i > 11)\n\tpred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);\n      if ((RAW(row,col) = pred[col & 1]) > 4098 && col < width) derror();\n    }\n}\n\nvoid CLASS olympus_load_raw()\n{\n  ushort huff[4096];\n  int row, col, nbits, sign, low, high, i, c, w, n, nw;\n  int acarry[2][3], *carry, pred, diff;\n\n  huff[n=0] = 0xc0c;\n  for (i=12; i--; )\n    FORC(2048 >> i) huff[++n] = (i+1) << 8 | i;\n  fseek (ifp, 7, SEEK_CUR);\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!data_size)\n      throw LIBRAW_EXCEPTION_IO_BADFILE;\n  LibRaw_byte_buffer *buf = ifp->make_byte_buffer(data_size);\n  LibRaw_bit_buffer bits;\n  bits.reset();\n#else\n  getbits(-1);\n#endif\n  for (row=0; row < height; row++) {\n    memset (acarry, 0, sizeof acarry);\n    for (col=0; col < raw_width; col++) {\n      carry = acarry[col & 1];\n      i = 2 * (carry[2] < 3);\n      for (nbits=2+i; (ushort) carry[0] >> (nbits+i); nbits++);\n#ifdef LIBRAW_LIBRARY_BUILD\n      low = (sign = bits._getbits(buf,3,zero_after_ff)) & 3;\n      sign = sign << 29 >> 31;\n      if ((high = bits._gethuff(buf,12,huff,zero_after_ff)) == 12)\n          high = bits._getbits(buf,16-nbits,zero_after_ff) >> 1;\n      carry[0] = (high << nbits) | bits._getbits(buf,nbits,zero_after_ff);\n#else\n      low = (sign = getbits(3)) & 3;\n      sign = sign << 29 >> 31;\n      if ((high = getbithuff(12,huff)) == 12)\n\thigh = getbits(16-nbits) >> 1;\n      carry[0] = (high << nbits) | getbits(nbits);\n#endif\n      diff = (carry[0] ^ sign) + carry[1];\n      carry[1] = (diff*3 + carry[1]) >> 5;\n      carry[2] = carry[0] > 16 ? 0 : carry[2]+1;\n      if (col >= width) continue;\n      if (row < 2 && col < 2) pred = 0;\n      else if (row < 2) pred = RAW(row,col-2);\n      else if (col < 2) pred = RAW(row-2,col);\n      else {\n\tw  = RAW(row,col-2);\n\tn  = RAW(row-2,col);\n\tnw = RAW(row-2,col-2);\n\tif ((w < nw && nw < n) || (n < nw && nw < w)) {\n\t  if (ABS(w-nw) > 32 || ABS(n-nw) > 32)\n\t    pred = w + n - nw;\n\t  else pred = (w + n) >> 1;\n\t} else pred = ABS(w-nw) > ABS(n-nw) ? w : n;\n      }\n      if ((RAW(row,col) = pred + ((diff << 2) | low)) >> 12) derror();\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  delete buf;\n#endif\n}\n\nvoid CLASS minolta_rd175_load_raw()\n{\n  uchar pixel[768];\n  unsigned irow, box, row, col;\n\n  for (irow=0; irow < 1481; irow++) {\n    if (fread (pixel, 1, 768, ifp) < 768) derror();\n    box = irow / 82;\n    row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box-12)*2);\n    switch (irow) {\n      case 1477: case 1479: continue;\n      case 1476: row = 984; break;\n      case 1480: row = 985; break;\n      case 1478: row = 985; box = 1;\n    }\n    if ((box < 12) && (box & 1)) {\n      for (col=0; col < 1533; col++, row ^= 1)\n\tif (col != 1) RAW(row,col) = (col+1) & 2 ?\n\t\t   pixel[col/2-1] + pixel[col/2+1] : pixel[col/2] << 1;\n      RAW(row,1)    = pixel[1]   << 1;\n      RAW(row,1533) = pixel[765] << 1;\n    } else\n      for (col=row & 1; col < 1534; col+=2)\n\tRAW(row,col) = pixel[col/2] << 1;\n  }\n  maximum = 0xff << 1;\n}\n\nvoid CLASS quicktake_100_load_raw()\n{\n  uchar pixel[484][644];\n  static const short gstep[16] =\n  { -89,-60,-44,-32,-22,-15,-8,-2,2,8,15,22,32,44,60,89 };\n  static const short rstep[6][4] =\n  { {  -3,-1,1,3  }, {  -5,-1,1,5  }, {  -8,-2,2,8  },\n    { -13,-3,3,13 }, { -19,-4,4,19 }, { -28,-6,6,28 } };\n  static const short t_curve[256] =\n  { 0,1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,\n    28,29,30,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,53,\n    54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,74,75,76,77,78,\n    79,80,81,82,83,84,86,88,90,92,94,97,99,101,103,105,107,110,112,114,116,\n    118,120,123,125,127,129,131,134,136,138,140,142,144,147,149,151,153,155,\n    158,160,162,164,166,168,171,173,175,177,179,181,184,186,188,190,192,195,\n    197,199,201,203,205,208,210,212,214,216,218,221,223,226,230,235,239,244,\n    248,252,257,261,265,270,274,278,283,287,291,296,300,305,309,313,318,322,\n    326,331,335,339,344,348,352,357,361,365,370,374,379,383,387,392,396,400,\n    405,409,413,418,422,426,431,435,440,444,448,453,457,461,466,470,474,479,\n    483,487,492,496,500,508,519,531,542,553,564,575,587,598,609,620,631,643,\n    654,665,676,687,698,710,721,732,743,754,766,777,788,799,810,822,833,844,\n    855,866,878,889,900,911,922,933,945,956,967,978,989,1001,1012,1023 };\n  int rb, row, col, sharp, val=0;\n\n  getbits(-1);\n  memset (pixel, 0x80, sizeof pixel);\n  for (row=2; row < height+2; row++) {\n    for (col=2+(row & 1); col < width+2; col+=2) {\n      val = ((pixel[row-1][col-1] + 2*pixel[row-1][col+1] +\n\t\tpixel[row][col-2]) >> 2) + gstep[getbits(4)];\n      pixel[row][col] = val = LIM(val,0,255);\n      if (col < 4)\n\tpixel[row][col-2] = pixel[row+1][~row & 1] = val;\n      if (row == 2)\n\tpixel[row-1][col+1] = pixel[row-1][col+3] = val;\n    }\n    pixel[row][col] = val;\n  }\n  for (rb=0; rb < 2; rb++)\n    for (row=2+rb; row < height+2; row+=2)\n      for (col=3-(row & 1); col < width+2; col+=2) {\n\tif (row < 4 || col < 4) sharp = 2;\n\telse {\n\t  val = ABS(pixel[row-2][col] - pixel[row][col-2])\n\t      + ABS(pixel[row-2][col] - pixel[row-2][col-2])\n\t      + ABS(pixel[row][col-2] - pixel[row-2][col-2]);\n\t  sharp = val <  4 ? 0 : val <  8 ? 1 : val < 16 ? 2 :\n\t\t  val < 32 ? 3 : val < 48 ? 4 : 5;\n\t}\n\tval = ((pixel[row-2][col] + pixel[row][col-2]) >> 1)\n\t      + rstep[sharp][getbits(2)];\n\tpixel[row][col] = val = LIM(val,0,255);\n\tif (row < 4) pixel[row-2][col+2] = val;\n\tif (col < 4) pixel[row+2][col-2] = val;\n      }\n  for (row=2; row < height+2; row++)\n    for (col=3-(row & 1); col < width+2; col+=2) {\n      val = ((pixel[row][col-1] + (pixel[row][col] << 2) +\n\t      pixel[row][col+1]) >> 1) - 0x100;\n      pixel[row][col] = LIM(val,0,255);\n    }\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      RAW(row,col) = t_curve[pixel[row+2][col+2]];\n  maximum = 0x3ff;\n}\n\n#define radc_token(tree) ((signed char) getbithuff(8,huff[tree]))\n\n#define FORYX for (y=1; y < 3; y++) for (x=col+1; x >= col; x--)\n\n#define PREDICTOR (c ? (buf[c][y-1][x] + buf[c][y][x+1]) / 2 \\\n: (buf[c][y-1][x+1] + 2*buf[c][y-1][x] + buf[c][y][x+1]) / 4)\n\n#ifdef __GNUC__\n# if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)\n# pragma GCC optimize(\"no-aggressive-loop-optimizations\")\n# endif\n#endif\n\nvoid CLASS kodak_radc_load_raw()\n{\n  static const char src[] = {\n    1,1, 2,3, 3,4, 4,2, 5,7, 6,5, 7,6, 7,8,\n    1,0, 2,1, 3,3, 4,4, 5,2, 6,7, 7,6, 8,5, 8,8,\n    2,1, 2,3, 3,0, 3,2, 3,4, 4,6, 5,5, 6,7, 6,8,\n    2,0, 2,1, 2,3, 3,2, 4,4, 5,6, 6,7, 7,5, 7,8,\n    2,1, 2,4, 3,0, 3,2, 3,3, 4,7, 5,5, 6,6, 6,8,\n    2,3, 3,1, 3,2, 3,4, 3,5, 3,6, 4,7, 5,0, 5,8,\n    2,3, 2,6, 3,0, 3,1, 4,4, 4,5, 4,7, 5,2, 5,8,\n    2,4, 2,7, 3,3, 3,6, 4,1, 4,2, 4,5, 5,0, 5,8,\n    2,6, 3,1, 3,3, 3,5, 3,7, 3,8, 4,0, 5,2, 5,4,\n    2,0, 2,1, 3,2, 3,3, 4,4, 4,5, 5,6, 5,7, 4,8,\n    1,0, 2,2, 2,-2,\n    1,-3, 1,3,\n    2,-17, 2,-5, 2,5, 2,17,\n    2,-7, 2,2, 2,9, 2,18,\n    2,-18, 2,-9, 2,-2, 2,7,\n    2,-28, 2,28, 3,-49, 3,-9, 3,9, 4,49, 5,-79, 5,79,\n    2,-1, 2,13, 2,26, 3,39, 4,-16, 5,55, 6,-37, 6,76,\n    2,-26, 2,-13, 2,1, 3,-39, 4,16, 5,-55, 6,-76, 6,37\n  };\n  ushort huff[19][256];\n  int row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;\n  short last[3] = { 16,16,16 }, mul[3], buf[3][3][386];\n  static const ushort pt[] =\n    { 0,0, 1280,1344, 2320,3616, 3328,8000, 4095,16383, 65535,16383 };\n\n  for (i=2; i < 12; i+=2)\n    for (c=pt[i-2]; c <= pt[i]; c++)\n      curve[c] = (float)\n\t(c-pt[i-2]) / (pt[i]-pt[i-2]) * (pt[i+1]-pt[i-1]) + pt[i-1] + 0.5;\n  for (s=i=0; i < sizeof src; i+=2)\n    FORC(256 >> src[i])\n      huff[0][s++] = src[i] << 8 | (uchar) src[i+1];\n  s = kodak_cbpp == 243 ? 2 : 3;\n  FORC(256) huff[18][c] = (8-s) << 8 | c >> s << s | 1 << (s-1);\n  getbits(-1);\n  for (i=0; i < sizeof(buf)/sizeof(short); i++)\n    buf[0][0][i] = 2048;\n  for (row=0; row < height; row+=4) {\n    FORC3 mul[c] = getbits(6);\n    FORC3 {\n      val = ((0x1000000/last[c] + 0x7ff) >> 12) * mul[c];\n      s = val > 65564 ? 10:12;\n      x = ~(-1 << (s-1));\n      val <<= 12-s;\n      for (i=0; i < sizeof(buf[0])/sizeof(short); i++)\n\tbuf[c][0][i] = (buf[c][0][i] * val + x) >> s;\n      last[c] = mul[c];\n      for (r=0; r <= !c; r++) {\n\tbuf[c][1][width/2] = buf[c][2][width/2] = mul[c] << 7;\n\tfor (tree=1, col=width/2; col > 0; ) {\n\t  if ((tree = radc_token(tree))) {\n\t    col -= 2;\n\t    if (tree == 8)\n\t      FORYX buf[c][y][x] = (uchar) radc_token(18) * mul[c];\n\t    else\n\t      FORYX buf[c][y][x] = radc_token(tree+10) * 16 + PREDICTOR;\n\t  } else\n\t    do {\n\t      nreps = (col > 2) ? radc_token(9) + 1 : 1;\n\t      for (rep=0; rep < 8 && rep < nreps && col > 0; rep++) {\n\t\tcol -= 2;\n\t\tFORYX buf[c][y][x] = PREDICTOR;\n\t\tif (rep & 1) {\n\t\t  step = radc_token(10) << 4;\n\t\t  FORYX buf[c][y][x] += step;\n\t\t}\n\t      }\n\t    } while (nreps == 9);\n\t}\n\tfor (y=0; y < 2; y++)\n\t  for (x=0; x < width/2; x++) {\n\t    val = (buf[c][y+1][x] << 4) / mul[c];\n\t    if (val < 0) val = 0;\n\t    if (c) RAW(row+y*2+c-1,x*2+2-c) = val;\n\t    else   RAW(row+r*2+y,x*2+y) = val;\n\t  }\n\tmemcpy (buf[c][0]+!c, buf[c][2], sizeof buf[c][0]-2*!c);\n      }\n    }\n    for (y=row; y < row+4; y++)\n      for (x=0; x < width; x++)\n\tif ((x+y) & 1) {\n\t  r = x ? x-1 : x+1;\n\t  s = x+1 < width ? x+1 : x-1;\n\t  val = (RAW(y,x)-2048)*2 + (RAW(y,r)+RAW(y,s))/2;\n\t  if (val < 0) val = 0;\n\t  RAW(y,x) = val;\n\t}\n  }\n  for (i=0; i < height*width; i++)\n    raw_image[i] = curve[raw_image[i]];\n  maximum = 0x3fff;\n}\n\n#undef FORYX\n#undef PREDICTOR\n\n#ifdef NO_JPEG\nvoid CLASS kodak_jpeg_load_raw() {}\nvoid CLASS lossy_dng_load_raw() {}\n#else\n\n#ifdef LIBRAW_LIBRARY_BUILD\nvoid CLASS kodak_jpeg_load_raw() {}\n#else\n\nMETHODDEF(boolean)\nfill_input_buffer (j_decompress_ptr cinfo)\n{\n#ifndef LIBRAW_NOTHREADS\n#define jpeg_buffer tls->jpeg_buffer\n#else\n  static uchar jpeg_buffer[4096];\n#endif\n  size_t nbytes;\n\n  nbytes = fread (jpeg_buffer, 1, 4096, ifp);\n  swab (jpeg_buffer, jpeg_buffer, nbytes);\n  cinfo->src->next_input_byte = jpeg_buffer;\n  cinfo->src->bytes_in_buffer = nbytes;\n  return TRUE;\n#ifndef LIBRAW_NOTHREADS\n#undef jpeg_buffer\n#endif\n}\n\nvoid CLASS kodak_jpeg_load_raw()\n{\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  JSAMPARRAY buf;\n  JSAMPLE (*pixel)[3];\n  int row, col;\n\n  cinfo.err = jpeg_std_error (&jerr);\n  jpeg_create_decompress (&cinfo);\n  jpeg_stdio_src (&cinfo, ifp);\n  cinfo.src->fill_input_buffer = fill_input_buffer;\n  jpeg_read_header (&cinfo, TRUE);\n  jpeg_start_decompress (&cinfo);\n  if ((cinfo.output_width      != width  ) ||\n      (cinfo.output_height*2   != height ) ||\n      (cinfo.output_components != 3      )) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s: incorrect JPEG dimensions\\n\"), ifname);\n#endif\n    jpeg_destroy_decompress (&cinfo);\n#ifdef LIBRAW_LIBRARY_BUILD\n    throw LIBRAW_EXCEPTION_DECODE_JPEG;\n#else\n    longjmp (failure, 3);\n#endif\n  }\n  buf = (*cinfo.mem->alloc_sarray)\n\t\t((j_common_ptr) &cinfo, JPOOL_IMAGE, width*3, 1);\n\n  while (cinfo.output_scanline < cinfo.output_height) {\n    row = cinfo.output_scanline * 2;\n    jpeg_read_scanlines (&cinfo, buf, 1);\n    pixel = (JSAMPLE (*)[3]) buf[0];\n    for (col=0; col < width; col+=2) {\n      RAW(row+0,col+0) = pixel[col+0][1] << 1;\n      RAW(row+1,col+1) = pixel[col+1][1] << 1;\n      RAW(row+0,col+1) = pixel[col][0] + pixel[col+1][0];\n      RAW(row+1,col+0) = pixel[col][2] + pixel[col+1][2];\n    }\n  }\n  jpeg_finish_decompress (&cinfo);\n  jpeg_destroy_decompress (&cinfo);\n  maximum = 0xff << 1;\n}\n#endif\n\nvoid CLASS lossy_dng_load_raw()\n{\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  JSAMPARRAY buf;\n  JSAMPLE (*pixel)[3];\n  unsigned sorder=order, ntags, opcode, deg, i, j, c;\n  unsigned save=data_offset-4, trow=0, tcol=0, row, col;\n  ushort t_curve[3][256];\n  double coeff[9], tot;\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  order = 0x4d4d;\n  ntags = get4();\n  while (ntags--) {\n    opcode = get4(); get4(); get4();\n    if (opcode != 8)\n    { fseek (ifp, get4(), SEEK_CUR); continue; }\n    fseek (ifp, 20, SEEK_CUR);\n    if ((c = get4()) > 2) break;\n    fseek (ifp, 12, SEEK_CUR);\n    if ((deg = get4()) > 8) break;\n    for (i=0; i <= deg && i < 9; i++)\n      coeff[i] = getreal(12);\n    for (i=0; i < 256; i++) {\n      for (tot=j=0; j <= deg; j++)\n\ttot += coeff[j] * pow(i/255.0, (int)j);\n      t_curve[c][i] = tot*0xffff;\n    }\n  }\n  order = sorder;\n  cinfo.err = jpeg_std_error (&jerr);\n  jpeg_create_decompress (&cinfo);\n  while (trow < raw_height) {\n    fseek (ifp, save+=4, SEEK_SET);\n    if (tile_length < INT_MAX)\n      fseek (ifp, get4(), SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(libraw_internal_data.internal_data.input->jpeg_src(&cinfo) == -1)\n      {\n        jpeg_destroy_decompress(&cinfo);\n        throw LIBRAW_EXCEPTION_DECODE_JPEG;\n      }\n#else\n    jpeg_stdio_src (&cinfo, ifp);\n#endif\n    jpeg_read_header (&cinfo, TRUE);\n    jpeg_start_decompress (&cinfo);\n    buf = (*cinfo.mem->alloc_sarray)\n\t((j_common_ptr) &cinfo, JPOOL_IMAGE, cinfo.output_width*3, 1);\n    while (cinfo.output_scanline < cinfo.output_height &&\n\t(row = trow + cinfo.output_scanline) < height) {\n      jpeg_read_scanlines (&cinfo, buf, 1);\n      pixel = (JSAMPLE (*)[3]) buf[0];\n      for (col=0; col < cinfo.output_width && tcol+col < width; col++) {\n\tFORC3 image[row*width+tcol+col][c] = t_curve[c][pixel[col][c]];\n      }\n    }\n    jpeg_abort_decompress (&cinfo);\n    if ((tcol += tile_width) >= raw_width)\n      trow += tile_length + (tcol = 0);\n  }\n  jpeg_destroy_decompress (&cinfo);\n  maximum = 0xffff;\n}\n#endif\n\nvoid CLASS kodak_dc120_load_raw()\n{\n  static const int mul[4] = { 162, 192, 187,  92 };\n  static const int add[4] = {   0, 636, 424, 212 };\n  uchar pixel[848];\n  int row, shift, col;\n\n  for (row=0; row < height; row++) {\n    if (fread (pixel, 1, 848, ifp) < 848) derror();\n    shift = row * mul[row & 3] + add[row & 3];\n    for (col=0; col < width; col++)\n      RAW(row,col) = (ushort) pixel[(col + shift) % 848];\n  }\n  maximum = 0xff;\n}\n\nvoid CLASS eight_bit_load_raw()\n{\n  uchar *pixel;\n  unsigned row, col;\n\n  pixel = (uchar *) calloc (raw_width, sizeof *pixel);\n  merror (pixel, \"eight_bit_load_raw()\");\n  for (row=0; row < raw_height; row++) {\n    if (fread (pixel, 1, raw_width, ifp) < raw_width) derror();\n    for (col=0; col < raw_width; col++)\n      RAW(row,col) = curve[pixel[col]];\n  }\n  free (pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_yrgb_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *) calloc (raw_width, 3*sizeof *pixel);\n  merror (pixel, \"kodak_yrgb_load_raw()\");\n  for (row=0; row < height; row++) {\n    if (~row & 1)\n      if (fread (pixel, raw_width, 3, ifp) < 3) derror();\n    for (col=0; col < raw_width; col++) {\n      y  = pixel[width*2*(row & 1) + col];\n      cb = pixel[width + (col & -2)]   - 128;\n      cr = pixel[width + (col & -2)+1] - 128;\n      rgb[1] = y-((cb + cr + 2) >> 2);\n      rgb[2] = rgb[1] + cb;\n      rgb[0] = rgb[1] + cr;\n      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];\n    }\n  }\n  free (pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_262_load_raw()\n{\n  static const uchar kodak_tree[2][26] =\n  { { 0,1,5,1,1,2,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 },\n    { 0,3,1,1,1,1,1,2,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 } };\n  ushort *huff[2];\n  uchar *pixel;\n  int *strip, ns, c, row, col, chess, pi=0, pi1, pi2, pred, val;\n\n  FORC(2) huff[c] = make_decoder (kodak_tree[c]);\n  ns = (raw_height+63) >> 5;\n  pixel = (uchar *) malloc (raw_width*32 + ns*4);\n  merror (pixel, \"kodak_262_load_raw()\");\n  strip = (int *) (pixel + raw_width*32);\n  order = 0x4d4d;\n  FORC(ns) strip[c] = get4();\n  for (row=0; row < raw_height; row++) {\n    if ((row & 31) == 0) {\n      fseek (ifp, strip[row >> 5], SEEK_SET);\n      getbits(-1);\n      pi = 0;\n    }\n    for (col=0; col < raw_width; col++) {\n      chess = (row + col) & 1;\n      pi1 = chess ? pi-2           : pi-raw_width-1;\n      pi2 = chess ? pi-2*raw_width : pi-raw_width+1;\n      if (col <= chess) pi1 = -1;\n      if (pi1 < 0) pi1 = pi2;\n      if (pi2 < 0) pi2 = pi1;\n      if (pi1 < 0 && col > 1) pi1 = pi2 = pi-2;\n      pred = (pi1 < 0) ? 0 : (pixel[pi1] + pixel[pi2]) >> 1;\n      pixel[pi] = val = pred + ljpeg_diff (huff[chess]);\n      if (val >> 8) derror();\n      val = curve[pixel[pi++]];\n      RAW(row,col) = val;\n    }\n  }\n  free (pixel);\n  FORC(2) free (huff[c]);\n}\n\nint CLASS kodak_65000_decode (short *out, int bsize)\n{\n  uchar c, blen[768];\n  ushort raw[6];\n  INT64 bitbuf=0;\n  int save, bits=0, i, j, len, diff;\n\n  save = ftell(ifp);\n  bsize = (bsize + 3) & -4;\n  for (i=0; i < bsize; i+=2) {\n    c = fgetc(ifp);\n    if ((blen[i  ] = c & 15) > 12 ||\n\t(blen[i+1] = c >> 4) > 12 ) {\n      fseek (ifp, save, SEEK_SET);\n      for (i=0; i < bsize; i+=8) {\n\tread_shorts (raw, 6);\n\tout[i  ] = raw[0] >> 12 << 8 | raw[2] >> 12 << 4 | raw[4] >> 12;\n\tout[i+1] = raw[1] >> 12 << 8 | raw[3] >> 12 << 4 | raw[5] >> 12;\n\tfor (j=0; j < 6; j++)\n\t  out[i+2+j] = raw[j] & 0xfff;\n      }\n      return 1;\n    }\n  }\n  if ((bsize & 7) == 4) {\n    bitbuf  = fgetc(ifp) << 8;\n    bitbuf += fgetc(ifp);\n    bits = 16;\n  }\n  for (i=0; i < bsize; i++) {\n    len = blen[i];\n    if (bits < len) {\n      for (j=0; j < 32; j+=8)\n\tbitbuf += (INT64) fgetc(ifp) << (bits+(j^8));\n      bits += 32;\n    }\n    diff = bitbuf & (0xffff >> (16-len));\n    bitbuf >>= len;\n    bits -= len;\n    if ((diff & (1 << (len-1))) == 0)\n      diff -= (1 << len) - 1;\n    out[i] = diff;\n  }\n  return 0;\n}\n\nvoid CLASS kodak_65000_load_raw()\n{\n  short buf[256];\n  int row, col, len, pred[2], ret, i;\n\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col+=256) {\n      pred[0] = pred[1] = 0;\n      len = MIN (256, width-col);\n      ret = kodak_65000_decode (buf, len);\n      for (i=0; i < len; i++)\n\tif ((RAW(row,col+i) =\tcurve[ret ? buf[i] :\n\t\t(pred[i & 1] += buf[i])]) >> 12) derror();\n    }\n}\n\nvoid CLASS kodak_ycbcr_load_raw()\n{\n  short buf[384], *bp;\n  int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n  ushort *ip;\n\n  for (row=0; row < height; row+=2)\n    for (col=0; col < width; col+=128) {\n      len = MIN (128, width-col);\n      kodak_65000_decode (buf, len*3);\n      y[0][1] = y[1][1] = cb = cr = 0;\n      for (bp=buf, i=0; i < len; i+=2, bp+=2) {\n\tcb += bp[4];\n\tcr += bp[5];\n\trgb[1] = -((cb + cr + 2) >> 2);\n\trgb[2] = rgb[1] + cb;\n\trgb[0] = rgb[1] + cr;\n\tfor (j=0; j < 2; j++)\n\t  for (k=0; k < 2; k++) {\n\t    if ((y[j][k] = y[j][k^1] + *bp++) >> 10) derror();\n\t    ip = image[(row+j)*width + col+i+k];\n\t    FORC3 ip[c] = curve[LIM(y[j][k]+rgb[c], 0, 0xfff)];\n\t  }\n      }\n    }\n}\n\nvoid CLASS kodak_rgb_load_raw()\n{\n  short buf[768], *bp;\n  int row, col, len, c, i, rgb[3];\n  ushort *ip=image[0];\n\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (raw_image) free (raw_image);\n  raw_image = 0;\n#endif\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col+=256) {\n      len = MIN (256, width-col);\n      kodak_65000_decode (buf, len*3);\n      memset (rgb, 0, sizeof rgb);\n      for (bp=buf, i=0; i < len; i++, ip+=4)\n\tFORC3 if ((ip[c] = rgb[c] += *bp++) >> 12) derror();\n    }\n}\n\nvoid CLASS kodak_thumb_load_raw()\n{\n  int row, col;\n  colors = thumb_misc >> 5;\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      read_shorts (image[row*width+col], colors);\n  maximum = (1 << (thumb_misc & 31)) - 1;\n}\n\nvoid CLASS sony_decrypt (unsigned *data, int len, int start, int key)\n{\n#ifndef LIBRAW_NOTHREADS\n#define pad tls->sony_decrypt.pad\n#define p   tls->sony_decrypt.p\n#else\n  static unsigned pad[128], p;\n#endif\n  if (start) {\n    for (p=0; p < 4; p++)\n      pad[p] = key = key * 48828125 + 1;\n    pad[3] = pad[3] << 1 | (pad[0]^pad[2]) >> 31;\n    for (p=4; p < 127; p++)\n      pad[p] = (pad[p-4]^pad[p-2]) << 1 | (pad[p-3]^pad[p-1]) >> 31;\n    for (p=0; p < 127; p++)\n      pad[p] = htonl(pad[p]);\n  }\n#if 1 // Avoid gcc 4.8 bug\n  while (len--)\n    {\n      *data++ ^= pad[p & 127] = pad[(p+1) & 127] ^ pad[(p+65) & 127];\n      p++;     \n    }\n#else\n  while (len--)\n    *data++ ^= pad[p++ & 127] = pad[(p+1) & 127] ^ pad[(p+65) & 127];\n#endif\n#ifndef LIBRAW_NOTHREADS\n#undef pad\n#undef p\n#endif\n}\n\nvoid CLASS sony_load_raw()\n{\n  uchar head[40];\n  ushort *pixel;\n  unsigned i, key, row, col;\n\n  fseek (ifp, 200896, SEEK_SET);\n  fseek (ifp, (unsigned) fgetc(ifp)*4 - 1, SEEK_CUR);\n  order = 0x4d4d;\n  key = get4();\n  fseek (ifp, 164600, SEEK_SET);\n  fread (head, 1, 40, ifp);\n  sony_decrypt ((unsigned int *) head, 10, 1, key);\n  for (i=26; i-- > 22; )\n    key = key << 8 | head[i];\n  fseek (ifp, data_offset, SEEK_SET);\n  for (row=0; row < raw_height; row++) {\n    pixel = raw_image + row*raw_width;\n    if (fread (pixel, 2, raw_width, ifp) < raw_width) derror();\n    sony_decrypt ((unsigned int *) pixel, raw_width/2, !row, key);\n    for (col=0; col < raw_width; col++)\n      if ((pixel[col] = ntohs(pixel[col])) >> 14) derror();\n  }\n  maximum = 0x3ff0;\n}\n\nvoid CLASS sony_arw_load_raw()\n{\n  ushort huff[32768];\n  static const ushort tab[18] =\n  { 0xf11,0xf10,0xe0f,0xd0e,0xc0d,0xb0c,0xa0b,0x90a,0x809,\n    0x708,0x607,0x506,0x405,0x304,0x303,0x300,0x202,0x201 };\n  int i, c, n, col, row, len, diff, sum=0;\n\n  for (n=i=0; i < 18; i++)\n    FORC(32768 >> (tab[i] >> 8)) huff[n++] = tab[i];\n#ifdef LIBRAW_LIBRARY_BUILD\n  LibRaw_byte_buffer *buf=NULL;\n  if(data_size)\n      buf = ifp->make_byte_buffer(data_size);\n  else\n      getbits(-1);\n      \n  LibRaw_bit_buffer bits;\n  bits.reset();\n#else\n  getbits(-1);\n#endif\n  for (col = raw_width; col--; )\n    for (row=0; row < raw_height+1; row+=2) {\n      if (row == raw_height) row = 1;\n#ifdef LIBRAW_LIBRARY_BUILD\n      if(data_size)\n          {\n              len = bits._gethuff(buf,15,huff,zero_after_ff);\n              diff = bits._getbits(buf,len,zero_after_ff);\n          }\n      else\n          {\n              len = getbithuff(15,huff);\n              diff = getbits(len);\n          }\n#else\n      len = getbithuff(15,huff);\n      diff = getbits(len);\n#endif\n      if ((diff & (1 << (len-1))) == 0)\n\tdiff -= (1 << len) - 1;\n      if ((sum += diff) >> 12) derror();\n      if (row < height) RAW(row,col) = sum;\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(buf) delete buf;\n#endif\n}\n\nvoid CLASS sony_arw2_load_raw()\n{\n  uchar *data, *dp;\n  ushort pix[16];\n  int row, col, val, max, min, imax, imin, sh, bit, i;\n\n  data = (uchar *) malloc (raw_width);\n  merror (data, \"sony_arw2_load_raw()\");\n  for (row=0; row < height; row++) {\n    fread (data, 1, raw_width, ifp);\n    for (dp=data, col=0; col < raw_width-30; dp+=16) {\n      max = 0x7ff & (val = sget4(dp));\n      min = 0x7ff & val >> 11;\n      imax = 0x0f & val >> 22;\n      imin = 0x0f & val >> 26;\n      for (sh=0; sh < 4 && 0x80 << sh <= max-min; sh++);\n      for (bit=30, i=0; i < 16; i++)\n\tif      (i == imax) pix[i] = max;\n\telse if (i == imin) pix[i] = min;\n\telse {\n\t  pix[i] = ((sget2(dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n\t  if (pix[i] > 0x7ff) pix[i] = 0x7ff;\n\t  bit += 7;\n\t}\n#ifdef LIBRAW_LIBRARY_BUILD\n      if(imgdata.params.sony_arw2_hack)\n          {\n              for (i=0; i < 16; i++, col+=2)\n                  RAW(row,col) = curve[pix[i] << 1];\n          }\n      else\n          {\n              for (i=0; i < 16; i++, col+=2)\n                  RAW(row,col) = curve[pix[i] << 1] >> 2;\n          }\n#else\n      for (i=0; i < 16; i++, col+=2)\n\tRAW(row,col) = curve[pix[i] << 1] >> 2;\n#endif\n      col -= col & 1 ? 1:31;\n    }\n  }\n  free (data);\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(imgdata.params.sony_arw2_hack)\n  {\n\tblack <<= 2;\n\tmaximum <<=2;\n  }\n#endif\n}\n\n#define HOLE(row) ((holes >> (((row) - raw_height) & 7)) & 1)\n\n/* Kudos to Rich Taylor for figuring out SMaL's compression algorithm. */\nvoid CLASS smal_decode_segment (unsigned seg[2][2], int holes)\n{\n  uchar hist[3][13] = {\n    { 7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0 },\n    { 7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0 },\n    { 3, 3, 0, 0, 63,     47,     31,     15,    0 } };\n  int low, high=0xff, carry=0, nbits=8;\n  int pix, s, count, bin, next, i, sym[3];\n  uchar diff, pred[]={0,0};\n  ushort data=0, range=0;\n\n  fseek (ifp, seg[0][1]+1, SEEK_SET);\n  getbits(-1);\n  for (pix=seg[0][0]; pix < seg[1][0]; pix++) {\n    for (s=0; s < 3; s++) {\n      data = data << nbits | getbits(nbits);\n      if (carry < 0)\n\tcarry = (nbits += carry+1) < 1 ? nbits-1 : 0;\n      while (--nbits >= 0)\n\tif ((data >> nbits & 0xff) == 0xff) break;\n      if (nbits > 0)\n\t  data = ((data & ((1 << (nbits-1)) - 1)) << 1) |\n\t((data + (((data & (1 << (nbits-1)))) << 1)) & (-1 << nbits));\n      if (nbits >= 0) {\n\tdata += getbits(1);\n\tcarry = nbits - 8;\n      }\n      count = ((((data-range+1) & 0xffff) << 2) - 1) / (high >> 4);\n      for (bin=0; hist[s][bin+5] > count; bin++);\n\t\tlow = hist[s][bin+5] * (high >> 4) >> 2;\n      if (bin) high = hist[s][bin+4] * (high >> 4) >> 2;\n      high -= low;\n      for (nbits=0; high << nbits < 128; nbits++);\n      range = (range+low) << nbits;\n      high <<= nbits;\n      next = hist[s][1];\n      if (++hist[s][2] > hist[s][3]) {\n\tnext = (next+1) & hist[s][0];\n\thist[s][3] = (hist[s][next+4] - hist[s][next+5]) >> 2;\n\thist[s][2] = 1;\n      }\n      if (hist[s][hist[s][1]+4] - hist[s][hist[s][1]+5] > 1) {\n\tif (bin < hist[s][1])\n\t  for (i=bin; i < hist[s][1]; i++) hist[s][i+5]--;\n\telse if (next <= bin)\n\t  for (i=hist[s][1]; i < bin; i++) hist[s][i+5]++;\n      }\n      hist[s][1] = next;\n      sym[s] = bin;\n    }\n    diff = sym[2] << 5 | sym[1] << 2 | (sym[0] & 3);\n    if (sym[0] & 4)\n      diff = diff ? -diff : 0x80;\n    if (ftell(ifp) + 12 >= seg[1][1])\n      diff = 0;\n    raw_image[pix] = pred[pix & 1] += diff;\n    if (!(pix & 1) && HOLE(pix / raw_width)) pix += 2;\n  }\n  maximum = 0xff;\n}\n\nvoid CLASS smal_v6_load_raw()\n{\n  unsigned seg[2][2];\n\n  fseek (ifp, 16, SEEK_SET);\n  seg[0][0] = 0;\n  seg[0][1] = get2();\n  seg[1][0] = raw_width * raw_height;\n  seg[1][1] = INT_MAX;\n  smal_decode_segment (seg, 0);\n}\n\nint CLASS median4 (int *p)\n{\n  int min, max, sum, i;\n\n  min = max = sum = p[0];\n  for (i=1; i < 4; i++) {\n    sum += p[i];\n    if (min > p[i]) min = p[i];\n    if (max < p[i]) max = p[i];\n  }\n  return (sum - min - max) >> 1;\n}\n\nvoid CLASS fill_holes (int holes)\n{\n  int row, col, val[4];\n\n  for (row=2; row < height-2; row++) {\n    if (!HOLE(row)) continue;\n    for (col=1; col < width-1; col+=4) {\n      val[0] = RAW(row-1,col-1);\n      val[1] = RAW(row-1,col+1);\n      val[2] = RAW(row+1,col-1);\n      val[3] = RAW(row+1,col+1);\n      RAW(row,col) = median4(val);\n    }\n    for (col=2; col < width-2; col+=4)\n      if (HOLE(row-2) || HOLE(row+2))\n\tRAW(row,col) = (RAW(row,col-2) + RAW(row,col+2)) >> 1;\n      else {\n\tval[0] = RAW(row,col-2);\n\tval[1] = RAW(row,col+2);\n\tval[2] = RAW(row-2,col);\n\tval[3] = RAW(row+2,col);\n\tRAW(row,col) = median4(val);\n      }\n  }\n}\n\nvoid CLASS smal_v9_load_raw()\n{\n  unsigned seg[256][2], offset, nseg, holes, i;\n\n  fseek (ifp, 67, SEEK_SET);\n  offset = get4();\n  nseg = fgetc(ifp);\n  fseek (ifp, offset, SEEK_SET);\n  for (i=0; i < nseg*2; i++)\n    seg[0][i] = get4() + data_offset*(i & 1);\n  fseek (ifp, 78, SEEK_SET);\n  holes = fgetc(ifp);\n  fseek (ifp, 88, SEEK_SET);\n  seg[nseg][0] = raw_height * raw_width;\n  seg[nseg][1] = get4() + data_offset;\n  for (i=0; i < nseg; i++)\n    smal_decode_segment (seg+i, holes);\n  if (holes) fill_holes (holes);\n}\n\nvoid CLASS redcine_load_raw()\n{\n#ifndef NO_JASPER\n  int c, row, col;\n  jas_stream_t *in;\n  jas_image_t *jimg;\n  jas_matrix_t *jmat;\n  jas_seqent_t *data;\n  ushort *img, *pix;\n\n  jas_init();\n#ifndef LIBRAW_LIBRARY_BUILD\n  in = jas_stream_fopen (ifname, \"rb\");\n#else\n  in = (jas_stream_t*)ifp->make_jas_stream();\n  if(!in)\n          throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n#endif\n  jas_stream_seek (in, data_offset+20, SEEK_SET);\n  jimg = jas_image_decode (in, -1, 0);\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!jimg) longjmp (failure, 3);\n#else\n  if(!jimg)\n      {\n          jas_stream_close (in);\n          throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n      }\n#endif\n  jmat = jas_matrix_create (height/2, width/2);\n  merror (jmat, \"redcine_load_raw()\");\n  img = (ushort *) calloc ((height+2)*(width+2), 2);\n  merror (img, \"redcine_load_raw()\");\n  FORC4 {\n    jas_image_readcmpt (jimg, c, 0, 0, width/2, height/2, jmat);\n    data = jas_matrix_getref (jmat, 0, 0);\n    for (row = c >> 1; row < height; row+=2)\n      for (col = c & 1; col < width; col+=2)\n\timg[(row+1)*(width+2)+col+1] = data[(row/2)*(width/2)+col/2];\n  }\n  for (col=1; col <= width; col++) {\n    img[col] = img[2*(width+2)+col];\n    img[(height+1)*(width+2)+col] = img[(height-1)*(width+2)+col];\n  }\n  for (row=0; row < height+2; row++) {\n    img[row*(width+2)] = img[row*(width+2)+2];\n    img[(row+1)*(width+2)-1] = img[(row+1)*(width+2)-3];\n  }\n  for (row=1; row <= height; row++) {\n    pix = img + row*(width+2) + (col = 1 + (FC(row,1) & 1));\n    for (   ; col <= width; col+=2, pix+=2) {\n      c = (((pix[0] - 0x800) << 3) +\n\tpix[-(width+2)] + pix[width+2] + pix[-1] + pix[1]) >> 2;\n      pix[0] = LIM(c,0,4095);\n    }\n  }\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      RAW(row,col) = curve[img[(row+1)*(width+2)+col+1]];\n  free (img);\n  jas_matrix_destroy (jmat);\n  jas_image_destroy (jimg);\n  jas_stream_close (in);\n#endif\n}\n//@end COMMON\n\n/* RESTRICTED code starts here */\n\nvoid CLASS foveon_decoder (unsigned size, unsigned code)\n{\n  static unsigned huff[1024];\n  struct decode *cur;\n  int i, len;\n\n  if (!code) {\n    for (i=0; i < size; i++)\n      huff[i] = get4();\n    memset (first_decode, 0, sizeof first_decode);\n    free_decode = first_decode;\n  }\n  cur = free_decode++;\n  if (free_decode > first_decode+2048) {\n    fprintf (stderr,_(\"%s: decoder table overflow\\n\"), ifname);\n    longjmp (failure, 2);\n  }\n  if (code)\n    for (i=0; i < size; i++)\n      if (huff[i] == code) {\n\tcur->leaf = i;\n\treturn;\n      }\n  if ((len = code >> 27) > 26) return;\n  code = (len+1) << 27 | (code & 0x3ffffff) << 1;\n\n  cur->branch[0] = free_decode;\n  foveon_decoder (size, code);\n  cur->branch[1] = free_decode;\n  foveon_decoder (size, code+1);\n}\n\nvoid CLASS foveon_thumb()\n{\n  unsigned bwide, row, col, bitbuf=0, bit=1, c, i;\n  char *buf;\n  struct decode *dindex;\n  short pred[3];\n\n  bwide = get4();\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  if (bwide > 0) {\n    if (bwide < thumb_width*3) return;\n    buf = (char *) malloc (bwide);\n    merror (buf, \"foveon_thumb()\");\n    for (row=0; row < thumb_height; row++) {\n      fread  (buf, 1, bwide, ifp);\n      fwrite (buf, 3, thumb_width, ofp);\n    }\n    free (buf);\n    return;\n  }\n  foveon_decoder (256, 0);\n\n  for (row=0; row < thumb_height; row++) {\n    memset (pred, 0, sizeof pred);\n    if (!bit) get4();\n    for (bit=col=0; col < thumb_width; col++)\n      FORC3 {\n\tfor (dindex=first_decode; dindex->branch[0]; ) {\n\t  if ((bit = (bit-1) & 31) == 31)\n\t    for (i=0; i < 4; i++)\n\t      bitbuf = (bitbuf << 8) + fgetc(ifp);\n\t  dindex = dindex->branch[bitbuf >> bit & 1];\n\t}\n\tpred[c] += dindex->leaf;\n\tfputc (pred[c], ofp);\n      }\n  }\n}\n\nvoid CLASS foveon_sd_load_raw()\n{\n  struct decode *dindex;\n  short diff[1024];\n  unsigned bitbuf=0;\n  int pred[3], row, col, bit=-1, c, i;\n\n  read_shorts ((ushort *) diff, 1024);\n  if (!load_flags) foveon_decoder (1024, 0);\n\n  for (row=0; row < height; row++) {\n    memset (pred, 0, sizeof pred);\n    if (!bit && !load_flags && atoi(model+2) < 14) get4();\n    for (col=bit=0; col < width; col++) {\n      if (load_flags) {\n\tbitbuf = get4();\n\tFORC3 pred[2-c] += diff[bitbuf >> c*10 & 0x3ff];\n      }\n      else FORC3 {\n\tfor (dindex=first_decode; dindex->branch[0]; ) {\n\t  if ((bit = (bit-1) & 31) == 31)\n\t    for (i=0; i < 4; i++)\n\t      bitbuf = (bitbuf << 8) + fgetc(ifp);\n\t  dindex = dindex->branch[bitbuf >> bit & 1];\n\t}\n\tpred[c] += diff[dindex->leaf];\n\tif (pred[c] >> 16 && ~pred[c] >> 16) derror();\n      }\n      FORC3 image[row*width+col][c] = pred[c];\n    }\n  }\n}\n\nvoid CLASS foveon_huff (ushort *huff)\n{\n  int i, j, clen, code;\n\n  huff[0] = 8;\n  for (i=0; i < 13; i++) {\n    clen = getc(ifp);\n    code = getc(ifp);\n    for (j=0; j < 256 >> clen; )\n      huff[code+ ++j] = clen << 8 | i;\n  }\n  get2();\n}\n\nvoid CLASS foveon_dp_load_raw()\n{\n  unsigned c, roff[4], row, col, diff;\n  ushort huff[258], vpred[2][2], hpred[2];\n\n  fseek (ifp, 8, SEEK_CUR);\n  foveon_huff (huff);\n  roff[0] = 48;\n  FORC3 roff[c+1] = -(-(roff[c] + get4()) & -16);\n  FORC3 {\n    fseek (ifp, data_offset+roff[c], SEEK_SET);\n    getbits(-1);\n    vpred[0][0] = vpred[0][1] = vpred[1][0] = vpred[1][1] = 512;\n    for (row=0; row < height; row++) {\n      for (col=0; col < width; col++) {\n       diff = ljpeg_diff(huff);\n       if (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n       else hpred[col & 1] += diff;\n       image[row*width+col][c] = hpred[col & 1];\n      }\n    }\n  }\n}\n\n\nvoid CLASS foveon_load_camf()\n{\n  unsigned type, wide, high, i, j, row, col, diff;\n  ushort huff[258], vpred[2][2] = {{512,512},{512,512}}, hpred[2];\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  type = get4();  get4();  get4();\n  wide = get4();\n  high = get4();\n  if (type == 2) {\n    fread (meta_data, 1, meta_length, ifp);\n    for (i=0; i < meta_length; i++) {\n      high = (high * 1597 + 51749) % 244944;\n      wide = high * (INT64) 301593171 >> 24;\n      meta_data[i] ^= ((((high << 8) - wide) >> 1) + wide) >> 17;\n    }\n  } else if (type == 4) {\n    free (meta_data);\n    meta_data = (char *) malloc (meta_length = wide*high*3/2);\n    merror (meta_data, \"foveon_load_camf()\");\n    foveon_huff (huff);\n    get4();\n    getbits(-1);\n    for (j=row=0; row < high; row++) {\n      for (col=0; col < wide; col++) {\n\tdiff = ljpeg_diff(huff);\n\tif (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n\telse         hpred[col & 1] += diff;\n\tif (col & 1) {\n\t  meta_data[j++] = hpred[0] >> 4;\n\t  meta_data[j++] = hpred[0] << 4 | hpred[1] >> 8;\n\t  meta_data[j++] = hpred[1];\n        }\n      }\n    }\n  } else\n    fprintf (stderr,_(\"%s has unknown CAMF type %d.\\n\"), ifname, type);\n}\n\nconst char * CLASS foveon_camf_param (const char *block, const char *param)\n{\n  unsigned idx, num;\n  char *pos, *cp, *dp;\n\n  for (idx=0; idx < meta_length; idx += sget4(pos+8)) {\n    pos = meta_data + idx;\n    if (strncmp (pos, \"CMb\", 3)) break;\n    if (pos[3] != 'P') continue;\n    if (strcmp (block, pos+sget4(pos+12))) continue;\n    cp = pos + sget4(pos+16);\n    num = sget4(cp);\n    dp = pos + sget4(cp+4);\n    while (num--) {\n      cp += 8;\n      if (!strcmp (param, dp+sget4(cp)))\n\treturn dp+sget4(cp+4);\n    }\n  }\n  return 0;\n}\n\nvoid * CLASS foveon_camf_matrix (unsigned dim[3], const char *name)\n{\n  unsigned i, idx, type, ndim, size, *mat;\n  char *pos, *cp, *dp;\n  double dsize;\n\n  for (idx=0; idx < meta_length; idx += sget4(pos+8)) {\n    pos = meta_data + idx;\n    if (strncmp (pos, \"CMb\", 3)) break;\n    if (pos[3] != 'M') continue;\n    if (strcmp (name, pos+sget4(pos+12))) continue;\n    dim[0] = dim[1] = dim[2] = 1;\n    cp = pos + sget4(pos+16);\n    type = sget4(cp);\n    if ((ndim = sget4(cp+4)) > 3) break;\n    dp = pos + sget4(cp+8);\n    for (i=ndim; i--; ) {\n      cp += 12;\n      dim[i] = sget4(cp);\n    }\n    if ((dsize = (double) dim[0]*dim[1]*dim[2]) > meta_length/4) break;\n    mat = (unsigned *) malloc ((size = dsize) * 4);\n    merror (mat, \"foveon_camf_matrix()\");\n    for (i=0; i < size; i++)\n      if (type && type != 6)\n\tmat[i] = sget4(dp + i*4);\n      else\n\tmat[i] = sget4(dp + i*2) & 0xffff;\n    return mat;\n  }\n  fprintf (stderr,_(\"%s: \\\"%s\\\" matrix not found!\\n\"), ifname, name);\n  return 0;\n}\n\nint CLASS foveon_fixed (void *ptr, int size, const char *name)\n{\n  void *dp;\n  unsigned dim[3];\n\n  if (!name) return 0;\n  dp = foveon_camf_matrix (dim, name);\n  if (!dp) return 0;\n  memcpy (ptr, dp, size*4);\n  free (dp);\n  return 1;\n}\n\nfloat CLASS foveon_avg (short *pix, int range[2], float cfilt)\n{\n  int i;\n  float val, min=FLT_MAX, max=-FLT_MAX, sum=0;\n\n  for (i=range[0]; i <= range[1]; i++) {\n    sum += val = pix[i*4] + (pix[i*4]-pix[(i-1)*4]) * cfilt;\n    if (min > val) min = val;\n    if (max < val) max = val;\n  }\n  if (range[1] - range[0] == 1) return sum/2;\n  return (sum - min - max) / (range[1] - range[0] - 1);\n}\n\nshort * CLASS foveon_make_curve (double max, double mul, double filt)\n{\n  short *curve;\n  unsigned i, size;\n  double x;\n\n  if (!filt) filt = 0.8;\n  size = 4*M_PI*max / filt;\n  if (size == UINT_MAX) size--;\n  curve = (short *) calloc (size+1, sizeof *curve);\n  merror (curve, \"foveon_make_curve()\");\n  curve[0] = size;\n  for (i=0; i < size; i++) {\n    x = i*filt/max/4;\n    curve[i+1] = (cos(x)+1)/2 * tanh(i*filt/mul) * mul + 0.5;\n  }\n  return curve;\n}\n\nvoid CLASS foveon_make_curves\n\t(short **curvep, float dq[3], float div[3], float filt)\n{\n  double mul[3], max=0;\n  int c;\n\n  FORC3 mul[c] = dq[c]/div[c];\n  FORC3 if (max < mul[c]) max = mul[c];\n  FORC3 curvep[c] = foveon_make_curve (max, mul[c], filt);\n}\n\nint CLASS foveon_apply_curve (short *curve, int i)\n{\n  if (abs(i) >= curve[0]) return 0;\n  return i < 0 ? -curve[1-i] : curve[1+i];\n}\n\n#define image ((short (*)[4]) image)\n\nvoid CLASS foveon_interpolate()\n{\n  static const short hood[] = { -1,-1, -1,0, -1,1, 0,-1, 0,1, 1,-1, 1,0, 1,1 };\n  short *pix, prev[3], *curve[8], (*shrink)[3];\n  float cfilt=0, ddft[3][3][2], ppm[3][3][3];\n  float cam_xyz[3][3], correct[3][3], last[3][3], trans[3][3];\n  float chroma_dq[3], color_dq[3], diag[3][3], div[3];\n  float (*black)[3], (*sgain)[3], (*sgrow)[3];\n  float fsum[3], val, frow, num;\n  int row, col, c, i, j, diff, sgx, irow, sum, min, max, limit;\n  int dscr[2][2], dstb[4], (*smrow[7])[3], total[4], ipix[3];\n  int work[3][3], smlast, smred, smred_p=0, dev[3];\n  int satlev[3], keep[4], active[4];\n  unsigned dim[3], *badpix;\n  double dsum=0, trsum[3];\n  char str[128];\n  const char* cp;\n\n  if (verbose)\n    fprintf (stderr,_(\"Foveon interpolation...\\n\"));\n\n  foveon_load_camf();\n  foveon_fixed (dscr, 4, \"DarkShieldColRange\");\n  foveon_fixed (ppm[0][0], 27, \"PostPolyMatrix\");\n  foveon_fixed (satlev, 3, \"SaturationLevel\");\n  foveon_fixed (keep, 4, \"KeepImageArea\");\n  foveon_fixed (active, 4, \"ActiveImageArea\");\n  foveon_fixed (chroma_dq, 3, \"ChromaDQ\");\n  foveon_fixed (color_dq, 3,\n\tfoveon_camf_param (\"IncludeBlocks\", \"ColorDQ\") ?\n\t\t\"ColorDQ\" : \"ColorDQCamRGB\");\n  if (foveon_camf_param (\"IncludeBlocks\", \"ColumnFilter\"))\n  \t\t foveon_fixed (&cfilt, 1, \"ColumnFilter\");\n\n  memset (ddft, 0, sizeof ddft);\n  if (!foveon_camf_param (\"IncludeBlocks\", \"DarkDrift\")\n\t || !foveon_fixed (ddft[1][0], 12, \"DarkDrift\"))\n    for (i=0; i < 2; i++) {\n      foveon_fixed (dstb, 4, i ? \"DarkShieldBottom\":\"DarkShieldTop\");\n      for (row = dstb[1]; row <= dstb[3]; row++)\n\tfor (col = dstb[0]; col <= dstb[2]; col++)\n\t  FORC3 ddft[i+1][c][1] += (short) image[row*width+col][c];\n      FORC3 ddft[i+1][c][1] /= (dstb[3]-dstb[1]+1) * (dstb[2]-dstb[0]+1);\n    }\n\n  if (!(cp = foveon_camf_param (\"WhiteBalanceIlluminants\", model2)))\n  { fprintf (stderr,_(\"%s: Invalid white balance \\\"%s\\\"\\n\"), ifname, model2);\n    return; }\n  foveon_fixed (cam_xyz, 9, cp);\n  foveon_fixed (correct, 9,\n\tfoveon_camf_param (\"WhiteBalanceCorrections\", model2));\n  memset (last, 0, sizeof last);\n  for (i=0; i < 3; i++)\n    for (j=0; j < 3; j++)\n      FORC3 last[i][j] += correct[i][c] * cam_xyz[c][j];\n\n  #define LAST(x,y) last[(i+x)%3][(c+y)%3]\n  for (i=0; i < 3; i++)\n    FORC3 diag[c][i] = LAST(1,1)*LAST(2,2) - LAST(1,2)*LAST(2,1);\n  #undef LAST\n  FORC3 div[c] = diag[c][0]*0.3127 + diag[c][1]*0.329 + diag[c][2]*0.3583;\n  sprintf (str, \"%sRGBNeutral\", model2);\n  if (foveon_camf_param (\"IncludeBlocks\", str))\n    foveon_fixed (div, 3, str);\n  num = 0;\n  FORC3 if (num < div[c]) num = div[c];\n  FORC3 div[c] /= num;\n\n  memset (trans, 0, sizeof trans);\n  for (i=0; i < 3; i++)\n    for (j=0; j < 3; j++)\n      FORC3 trans[i][j] += rgb_cam[i][c] * last[c][j] * div[j];\n  FORC3 trsum[c] = trans[c][0] + trans[c][1] + trans[c][2];\n  dsum = (6*trsum[0] + 11*trsum[1] + 3*trsum[2]) / 20;\n  for (i=0; i < 3; i++)\n    FORC3 last[i][c] = trans[i][c] * dsum / trsum[i];\n  memset (trans, 0, sizeof trans);\n  for (i=0; i < 3; i++)\n    for (j=0; j < 3; j++)\n      FORC3 trans[i][j] += (i==c ? 32 : -1) * last[c][j] / 30;\n\n  foveon_make_curves (curve, color_dq, div, cfilt);\n  FORC3 chroma_dq[c] /= 3;\n  foveon_make_curves (curve+3, chroma_dq, div, cfilt);\n  FORC3 dsum += chroma_dq[c] / div[c];\n  curve[6] = foveon_make_curve (dsum, dsum, cfilt);\n  curve[7] = foveon_make_curve (dsum*2, dsum*2, cfilt);\n\n  sgain = (float (*)[3]) foveon_camf_matrix (dim, \"SpatialGain\");\n  if (!sgain) return;\n  sgrow = (float (*)[3]) calloc (dim[1], sizeof *sgrow);\n  sgx = (width + dim[1]-2) / (dim[1]-1);\n\n  black = (float (*)[3]) calloc (height, sizeof *black);\n  for (row=0; row < height; row++) {\n    for (i=0; i < 6; i++)\n      ddft[0][0][i] = ddft[1][0][i] +\n\trow / (height-1.0) * (ddft[2][0][i] - ddft[1][0][i]);\n    FORC3 black[row][c] =\n \t( foveon_avg (image[row*width]+c, dscr[0], cfilt) +\n\t  foveon_avg (image[row*width]+c, dscr[1], cfilt) * 3\n\t  - ddft[0][c][0] ) / 4 - ddft[0][c][1];\n  }\n  memcpy (black, black+8, sizeof *black*8);\n  memcpy (black+height-11, black+height-22, 11*sizeof *black);\n  memcpy (last, black, sizeof last);\n\n  for (row=1; row < height-1; row++) {\n    FORC3 if (last[1][c] > last[0][c]) {\n\tif (last[1][c] > last[2][c])\n\t  black[row][c] = (last[0][c] > last[2][c]) ? last[0][c]:last[2][c];\n      } else\n\tif (last[1][c] < last[2][c])\n\t  black[row][c] = (last[0][c] < last[2][c]) ? last[0][c]:last[2][c];\n    memmove (last, last+1, 2*sizeof last[0]);\n    memcpy (last[2], black[row+1], sizeof last[2]);\n  }\n  FORC3 black[row][c] = (last[0][c] + last[1][c])/2;\n  FORC3 black[0][c] = (black[1][c] + black[3][c])/2;\n\n  val = 1 - exp(-1/24.0);\n  memcpy (fsum, black, sizeof fsum);\n  for (row=1; row < height; row++)\n    FORC3 fsum[c] += black[row][c] =\n\t(black[row][c] - black[row-1][c])*val + black[row-1][c];\n  memcpy (last[0], black[height-1], sizeof last[0]);\n  FORC3 fsum[c] /= height;\n  for (row = height; row--; )\n    FORC3 last[0][c] = black[row][c] =\n\t(black[row][c] - fsum[c] - last[0][c])*val + last[0][c];\n\n  memset (total, 0, sizeof total);\n  for (row=2; row < height; row+=4)\n    for (col=2; col < width; col+=4) {\n      FORC3 total[c] += (short) image[row*width+col][c];\n      total[3]++;\n    }\n  for (row=0; row < height; row++)\n    FORC3 black[row][c] += fsum[c]/2 + total[c]/(total[3]*100.0);\n\n  for (row=0; row < height; row++) {\n    for (i=0; i < 6; i++)\n      ddft[0][0][i] = ddft[1][0][i] +\n\trow / (height-1.0) * (ddft[2][0][i] - ddft[1][0][i]);\n    pix = image[row*width];\n    memcpy (prev, pix, sizeof prev);\n    frow = row / (height-1.0) * (dim[2]-1);\n    if ((irow = frow) == dim[2]-1) irow--;\n    frow -= irow;\n    for (i=0; i < dim[1]; i++)\n      FORC3 sgrow[i][c] = sgain[ irow   *dim[1]+i][c] * (1-frow) +\n\t\t\t  sgain[(irow+1)*dim[1]+i][c] *    frow;\n    for (col=0; col < width; col++) {\n      FORC3 {\n\tdiff = pix[c] - prev[c];\n\tprev[c] = pix[c];\n\tipix[c] = pix[c] + floor ((diff + (diff*diff >> 14)) * cfilt\n\t\t- ddft[0][c][1] - ddft[0][c][0] * ((float) col/width - 0.5)\n\t\t- black[row][c] );\n      }\n      FORC3 {\n\twork[0][c] = ipix[c] * ipix[c] >> 14;\n\twork[2][c] = ipix[c] * work[0][c] >> 14;\n\twork[1][2-c] = ipix[(c+1) % 3] * ipix[(c+2) % 3] >> 14;\n      }\n      FORC3 {\n\tfor (val=i=0; i < 3; i++)\n\t  for (  j=0; j < 3; j++)\n\t    val += ppm[c][i][j] * work[i][j];\n\tipix[c] = floor ((ipix[c] + floor(val)) *\n\t\t( sgrow[col/sgx  ][c] * (sgx - col%sgx) +\n\t\t  sgrow[col/sgx+1][c] * (col%sgx) ) / sgx / div[c]);\n\tif (ipix[c] > 32000) ipix[c] = 32000;\n\tpix[c] = ipix[c];\n      }\n      pix += 4;\n    }\n  }\n  free (black);\n  free (sgrow);\n  free (sgain);\n\n  if ((badpix = (unsigned int *) foveon_camf_matrix (dim, \"BadPixels\"))) {\n    for (i=0; i < dim[0]; i++) {\n      col = (badpix[i] >> 8 & 0xfff) - keep[0];\n      row = (badpix[i] >> 20       ) - keep[1];\n      if ((unsigned)(row-1) > height-3 || (unsigned)(col-1) > width-3)\n\tcontinue;\n      memset (fsum, 0, sizeof fsum);\n      for (sum=j=0; j < 8; j++)\n\tif (badpix[i] & (1 << j)) {\n\t  FORC3 fsum[c] += (short)\n\t\timage[(row+hood[j*2])*width+col+hood[j*2+1]][c];\n\t  sum++;\n\t}\n      if (sum) FORC3 image[row*width+col][c] = fsum[c]/sum;\n    }\n    free (badpix);\n  }\n\n  /* Array for 5x5 Gaussian averaging of red values */\n  smrow[6] = (int (*)[3]) calloc (width*5, sizeof **smrow);\n  merror (smrow[6], \"foveon_interpolate()\");\n  for (i=0; i < 5; i++)\n    smrow[i] = smrow[6] + i*width;\n\n  /* Sharpen the reds against these Gaussian averages */\n  for (smlast=-1, row=2; row < height-2; row++) {\n    while (smlast < row+2) {\n      for (i=0; i < 6; i++)\n\tsmrow[(i+5) % 6] = smrow[i];\n      pix = image[++smlast*width+2];\n      for (col=2; col < width-2; col++) {\n\tsmrow[4][col][0] =\n\t  (pix[0]*6 + (pix[-4]+pix[4])*4 + pix[-8]+pix[8] + 8) >> 4;\n\tpix += 4;\n      }\n    }\n    pix = image[row*width+2];\n    for (col=2; col < width-2; col++) {\n      smred = ( 6 *  smrow[2][col][0]\n\t      + 4 * (smrow[1][col][0] + smrow[3][col][0])\n\t      +      smrow[0][col][0] + smrow[4][col][0] + 8 ) >> 4;\n      if (col == 2)\n\tsmred_p = smred;\n      i = pix[0] + ((pix[0] - ((smred*7 + smred_p) >> 3)) >> 3);\n      if (i > 32000) i = 32000;\n      pix[0] = i;\n      smred_p = smred;\n      pix += 4;\n    }\n  }\n\n  /* Adjust the brighter pixels for better linearity */\n  min = 0xffff;\n  FORC3 {\n    i = satlev[c] / div[c];\n    if (min > i) min = i;\n  }\n  limit = min * 9 >> 4;\n  for (pix=image[0]; pix < image[height*width]; pix+=4) {\n    if (pix[0] <= limit || pix[1] <= limit || pix[2] <= limit)\n      continue;\n    min = max = pix[0];\n    for (c=1; c < 3; c++) {\n      if (min > pix[c]) min = pix[c];\n      if (max < pix[c]) max = pix[c];\n    }\n    if (min >= limit*2) {\n      pix[0] = pix[1] = pix[2] = max;\n    } else {\n      i = 0x4000 - ((min - limit) << 14) / limit;\n      i = 0x4000 - (i*i >> 14);\n      i = i*i >> 14;\n      FORC3 pix[c] += (max - pix[c]) * i >> 14;\n    }\n  }\n/*\n   Because photons that miss one detector often hit another,\n   the sum R+G+B is much less noisy than the individual colors.\n   So smooth the hues without smoothing the total.\n */\n  for (smlast=-1, row=2; row < height-2; row++) {\n    while (smlast < row+2) {\n      for (i=0; i < 6; i++)\n\tsmrow[(i+5) % 6] = smrow[i];\n      pix = image[++smlast*width+2];\n      for (col=2; col < width-2; col++) {\n\tFORC3 smrow[4][col][c] = (pix[c-4]+2*pix[c]+pix[c+4]+2) >> 2;\n\tpix += 4;\n      }\n    }\n    pix = image[row*width+2];\n    for (col=2; col < width-2; col++) {\n      FORC3 dev[c] = -foveon_apply_curve (curve[7], pix[c] -\n\t((smrow[1][col][c] + 2*smrow[2][col][c] + smrow[3][col][c]) >> 2));\n      sum = (dev[0] + dev[1] + dev[2]) >> 3;\n      FORC3 pix[c] += dev[c] - sum;\n      pix += 4;\n    }\n  }\n  for (smlast=-1, row=2; row < height-2; row++) {\n    while (smlast < row+2) {\n      for (i=0; i < 6; i++)\n\tsmrow[(i+5) % 6] = smrow[i];\n      pix = image[++smlast*width+2];\n      for (col=2; col < width-2; col++) {\n\tFORC3 smrow[4][col][c] =\n\t\t(pix[c-8]+pix[c-4]+pix[c]+pix[c+4]+pix[c+8]+2) >> 2;\n\tpix += 4;\n      }\n    }\n    pix = image[row*width+2];\n    for (col=2; col < width-2; col++) {\n      for (total[3]=375, sum=60, c=0; c < 3; c++) {\n\tfor (total[c]=i=0; i < 5; i++)\n\t  total[c] += smrow[i][col][c];\n\ttotal[3] += total[c];\n\tsum += pix[c];\n      }\n      if (sum < 0) sum = 0;\n      j = total[3] > 375 ? (sum << 16) / total[3] : sum * 174;\n      FORC3 pix[c] += foveon_apply_curve (curve[6],\n\t\t((j*total[c] + 0x8000) >> 16) - pix[c]);\n      pix += 4;\n    }\n  }\n\n  /* Transform the image to a different colorspace */\n  for (pix=image[0]; pix < image[height*width]; pix+=4) {\n    FORC3 pix[c] -= foveon_apply_curve (curve[c], pix[c]);\n    sum = (pix[0]+pix[1]+pix[1]+pix[2]) >> 2;\n    FORC3 pix[c] -= foveon_apply_curve (curve[c], pix[c]-sum);\n    FORC3 {\n      for (dsum=i=0; i < 3; i++)\n\tdsum += trans[c][i] * pix[i];\n      if (dsum < 0)  dsum = 0;\n      if (dsum > 24000) dsum = 24000;\n      ipix[c] = dsum + 0.5;\n    }\n    FORC3 pix[c] = ipix[c];\n  }\n\n  /* Smooth the image bottom-to-top and save at 1/4 scale */\n  shrink = (short (*)[3]) calloc ((width/4) * (height/4), sizeof *shrink);\n  merror (shrink, \"foveon_interpolate()\");\n  for (row = height/4; row--; )\n    for (col=0; col < width/4; col++) {\n      ipix[0] = ipix[1] = ipix[2] = 0;\n      for (i=0; i < 4; i++)\n\tfor (j=0; j < 4; j++)\n\t  FORC3 ipix[c] += image[(row*4+i)*width+col*4+j][c];\n      FORC3\n\tif (row+2 > height/4)\n\t  shrink[row*(width/4)+col][c] = ipix[c] >> 4;\n\telse\n\t  shrink[row*(width/4)+col][c] =\n\t    (shrink[(row+1)*(width/4)+col][c]*1840 + ipix[c]*141 + 2048) >> 12;\n    }\n  /* From the 1/4-scale image, smooth right-to-left */\n  for (row=0; row < (height & ~3); row++) {\n    ipix[0] = ipix[1] = ipix[2] = 0;\n    if ((row & 3) == 0)\n      for (col = width & ~3 ; col--; )\n\tFORC3 smrow[0][col][c] = ipix[c] =\n\t  (shrink[(row/4)*(width/4)+col/4][c]*1485 + ipix[c]*6707 + 4096) >> 13;\n\n  /* Then smooth left-to-right */\n    ipix[0] = ipix[1] = ipix[2] = 0;\n    for (col=0; col < (width & ~3); col++)\n      FORC3 smrow[1][col][c] = ipix[c] =\n\t(smrow[0][col][c]*1485 + ipix[c]*6707 + 4096) >> 13;\n\n  /* Smooth top-to-bottom */\n    if (row == 0)\n      memcpy (smrow[2], smrow[1], sizeof **smrow * width);\n    else\n      for (col=0; col < (width & ~3); col++)\n\tFORC3 smrow[2][col][c] =\n\t  (smrow[2][col][c]*6707 + smrow[1][col][c]*1485 + 4096) >> 13;\n\n  /* Adjust the chroma toward the smooth values */\n    for (col=0; col < (width & ~3); col++) {\n      for (i=j=30, c=0; c < 3; c++) {\n\ti += smrow[2][col][c];\n\tj += image[row*width+col][c];\n      }\n      j = (j << 16) / i;\n      for (sum=c=0; c < 3; c++) {\n\tipix[c] = foveon_apply_curve (curve[c+3],\n\t  ((smrow[2][col][c] * j + 0x8000) >> 16) - image[row*width+col][c]);\n\tsum += ipix[c];\n      }\n      sum >>= 3;\n      FORC3 {\n\ti = image[row*width+col][c] + ipix[c] - sum;\n\tif (i < 0) i = 0;\n\timage[row*width+col][c] = i;\n      }\n    }\n  }\n  free (shrink);\n  free (smrow[6]);\n  for (i=0; i < 8; i++)\n    free (curve[i]);\n\n  /* Trim off the black border */\n  active[1] -= keep[1];\n  active[3] -= 2;\n  i = active[2] - active[0];\n  for (row=0; row < active[3]-active[1]; row++)\n    memcpy (image[row*i], image[(row+active[1])*width+active[0]],\n\t i * sizeof *image);\n  width = i;\n  height = row;\n}\n#undef image\n\n/* RESTRICTED code ends here */\n\n//@out COMMON\nvoid CLASS crop_masked_pixels()\n{\n  int row, col;\n  unsigned \n#ifndef LIBRAW_LIBRARY_BUILD\n    r, raw_pitch = raw_width*2,\n#endif\n    c, m, mblack[8], zero, val;\n\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (load_raw == &CLASS phase_one_load_raw ||\n      load_raw == &CLASS phase_one_load_raw_c)\n    phase_one_correct();\n  if (fuji_width) {\n    for (row=0; row < raw_height-top_margin*2; row++) {\n      for (col=0; col < fuji_width << !fuji_layout; col++) {\n\tif (fuji_layout) {\n\t  r = fuji_width - 1 - col + (row >> 1);\n\t  c = col + ((row+1) >> 1);\n\t} else {\n\t  r = fuji_width - 1 + row - (col >> 1);\n\t  c = row + ((col+1) >> 1);\n\t}\n\tif (r < height && c < width)\n\t  BAYER(r,c) = RAW(row+top_margin,col+left_margin);\n      }\n    }\n  } else {\n    for (row=0; row < height; row++)\n      for (col=0; col < width; col++)\n\tBAYER2(row,col) = RAW(row+top_margin,col+left_margin);\n  }\n#endif\n  if (mask[0][3]) goto mask_set;\n  if (load_raw == &CLASS canon_load_raw ||\n      load_raw == &CLASS lossless_jpeg_load_raw) {\n    mask[0][1] = mask[1][1] = 2;\n    mask[0][3] = -2;\n    goto sides;\n  }\n  if (load_raw == &CLASS canon_600_load_raw ||\n      load_raw == &CLASS sony_load_raw ||\n     (load_raw == &CLASS eight_bit_load_raw && strncmp(model,\"DC2\",3)) ||\n      load_raw == &CLASS kodak_262_load_raw ||\n     (load_raw == &CLASS packed_load_raw && (load_flags & 32))) {\nsides:\n    mask[0][0] = mask[1][0] = top_margin;\n    mask[0][2] = mask[1][2] = top_margin+height;\n    mask[0][3] += left_margin;\n    mask[1][1] += left_margin+width;\n    mask[1][3] += raw_width;\n  }\n  if (load_raw == &CLASS nokia_load_raw) {\n    mask[0][2] = top_margin;\n    mask[0][3] = width;\n  }\nmask_set:\n  memset (mblack, 0, sizeof mblack);\n  for (zero=m=0; m < 8; m++)\n    for (row=mask[m][0]; row < mask[m][2]; row++)\n      for (col=mask[m][1]; col < mask[m][3]; col++) {\n\tc = FC(row-top_margin,col-left_margin);\n\tmblack[c] += val = raw_image[(row)*raw_pitch/2+(col)];\n\tmblack[4+c]++;\n\tzero += !val;\n      }\n  if (load_raw == &CLASS canon_600_load_raw && width < raw_width) {\n    black = (mblack[0]+mblack[1]+mblack[2]+mblack[3]) /\n\t    (mblack[4]+mblack[5]+mblack[6]+mblack[7]) - 4;\n#ifndef LIBRAW_LIBRARY_BUILD\n    canon_600_correct();\n#endif\n  } else if (zero < mblack[4] && mblack[5] && mblack[6] && mblack[7])\n    FORC4 cblack[c] = mblack[c] / mblack[4+c];\n}\n\nvoid CLASS remove_zeroes()\n{\n  unsigned row, col, tot, n, r, c;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES,0,2);\n#endif\n\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      if (BAYER(row,col) == 0) {\n\ttot = n = 0;\n\tfor (r = row-2; r <= row+2; r++)\n\t  for (c = col-2; c <= col+2; c++)\n\t    if (r < height && c < width &&\n\t\tFC(r,c) == FC(row,col) && BAYER(r,c))\n\t      tot += (n++,BAYER(r,c));\n\tif (n) BAYER(row,col) = tot/n;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES,1,2);\n#endif\n}\n//@end COMMON\n\n/* @out FILEIO\n#include <math.h>\n#define CLASS LibRaw::\n#include \"libraw/libraw_types.h\"\n#define LIBRAW_LIBRARY_BUILD\n#include \"libraw/libraw.h\"\n#include \"internal/defines.h\"\n#include \"internal/var_defines.h\"\n@end FILEIO */\n\n\n// @out FILEIO\n/*\n   Seach from the current directory up to the root looking for\n   a \".badpixels\" file, and fix those pixels now.\n */\nvoid CLASS bad_pixels (const char *cfname)\n{\n  FILE *fp=NULL;\n#ifndef LIBRAW_LIBRARY_BUILD\n  char *fname, *cp, line[128];\n  int len, time, row, col, r, c, rad, tot, n, fixed=0;\n#else\n  char *cp, line[128];\n  int time, row, col, r, c, rad, tot, n;\n#ifdef DCRAW_VERBOSE\n  int fixed = 0;\n#endif\n#endif\n\n  if (!filters) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,0,2);\n#endif\n  if (cfname)\n    fp = fopen (cfname, \"r\");\n// @end FILEIO\n  else {\n    for (len=32 ; ; len *= 2) {\n      fname = (char *) malloc (len);\n      if (!fname) return;\n      if (getcwd (fname, len-16)) break;\n      free (fname);\n      if (errno != ERANGE) return;\n    }\n#if defined(WIN32) || defined(DJGPP)\n    if (fname[1] == ':')\n      memmove (fname, fname+2, len-2);\n    for (cp=fname; *cp; cp++)\n      if (*cp == '\\\\') *cp = '/';\n#endif\n    cp = fname + strlen(fname);\n    if (cp[-1] == '/') cp--;\n    while (*fname == '/') {\n      strcpy (cp, \"/.badpixels\");\n      if ((fp = fopen (fname, \"r\"))) break;\n      if (cp == fname) break;\n      while (*--cp != '/');\n    }\n    free (fname);\n  }\n// @out FILEIO\n  if (!fp)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_BADPIXELMAP;\n#endif\n          return;\n      }\n  while (fgets (line, 128, fp)) {\n    cp = strchr (line, '#');\n    if (cp) *cp = 0;\n    if (sscanf (line, \"%d %d %d\", &col, &row, &time) != 3) continue;\n    if ((unsigned) col >= width || (unsigned) row >= height) continue;\n    if (time > timestamp) continue;\n    for (tot=n=0, rad=1; rad < 3 && n==0; rad++)\n      for (r = row-rad; r <= row+rad; r++)\n\tfor (c = col-rad; c <= col+rad; c++)\n\t  if ((unsigned) r < height && (unsigned) c < width &&\n\t\t(r != row || c != col) && fcol(r,c) == fcol(row,col)) {\n\t    tot += BAYER2(r,c);\n\t    n++;\n\t  }\n    BAYER2(row,col) = tot/n;\n#ifdef DCRAW_VERBOSE\n    if (verbose) {\n      if (!fixed++)\n\tfprintf (stderr,_(\"Fixed dead pixels at:\"));\n      fprintf (stderr, \" %d,%d\", col, row);\n    }\n#endif\n  }\n#ifdef DCRAW_VERBOSE\n  if (fixed) fputc ('\\n', stderr);\n#endif\n  fclose (fp);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,1,2);\n#endif\n}\n\nvoid CLASS subtract (const char *fname)\n{\n  FILE *fp;\n  int dim[3]={0,0,0}, comment=0, number=0, error=0, nd=0, c, row, col;\n  ushort *pixel;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME,0,2);\n#endif\n\n  if (!(fp = fopen (fname, \"rb\"))) {\n#ifdef DCRAW_VERBOSE\n    perror (fname); \n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_BAD_DARKFRAME_FILE;\n#endif\n    return;\n  }\n  if (fgetc(fp) != 'P' || fgetc(fp) != '5') error = 1;\n  while (!error && nd < 3 && (c = fgetc(fp)) != EOF) {\n    if (c == '#')  comment = 1;\n    if (c == '\\n') comment = 0;\n    if (comment) continue;\n    if (isdigit(c)) number = 1;\n    if (number) {\n      if (isdigit(c)) dim[nd] = dim[nd]*10 + c -'0';\n      else if (isspace(c)) {\n\tnumber = 0;  nd++;\n      } else error = 1;\n    }\n  }\n  if (error || nd < 3) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s is not a valid PGM file!\\n\"), fname);\n#endif\n    fclose (fp);  return;\n  } else if (dim[0] != width || dim[1] != height || dim[2] != 65535) {\n#ifdef DCRAW_VERBOSE\n      fprintf (stderr,_(\"%s has the wrong dimensions!\\n\"), fname);\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.process_warnings |= LIBRAW_WARN_BAD_DARKFRAME_DIM;\n#endif\n    fclose (fp);  return;\n  }\n  pixel = (ushort *) calloc (width, sizeof *pixel);\n  merror (pixel, \"subtract()\");\n  for (row=0; row < height; row++) {\n    fread (pixel, 2, width, fp);\n    for (col=0; col < width; col++)\n      BAYER(row,col) = MAX (BAYER(row,col) - ntohs(pixel[col]), 0);\n  }\n  free (pixel);\n  fclose (fp);\n  memset (cblack, 0, sizeof cblack);\n  black = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME,1,2);\n#endif\n}\n//@end FILEIO\n\n//@out COMMON\nvoid CLASS gamma_curve (double pwr, double ts, int mode, int imax)\n{\n  int i;\n  double g[6], bnd[2]={0,0}, r;\n\n  g[0] = pwr;\n  g[1] = ts;\n  g[2] = g[3] = g[4] = 0;\n  bnd[g[1] >= 1] = 1;\n  if (g[1] && (g[1]-1)*(g[0]-1) <= 0) {\n    for (i=0; i < 48; i++) {\n      g[2] = (bnd[0] + bnd[1])/2;\n      if (g[0]) bnd[(pow(g[2]/g[1],-g[0]) - 1)/g[0] - 1/g[2] > -1] = g[2];\n      else\tbnd[g[2]/exp(1-1/g[2]) < g[1]] = g[2];\n    }\n    g[3] = g[2] / g[1];\n    if (g[0]) g[4] = g[2] * (1/g[0] - 1);\n  }\n  if (g[0]) g[5] = 1 / (g[1]*SQR(g[3])/2 - g[4]*(1 - g[3]) +\n\t\t(1 - pow(g[3],1+g[0]))*(1 + g[4])/(1 + g[0])) - 1;\n  else      g[5] = 1 / (g[1]*SQR(g[3])/2 + 1\n\t\t- g[2] - g[3] -\tg[2]*g[3]*(log(g[3]) - 1)) - 1;\n  if (!mode--) {\n    memcpy (gamm, g, sizeof gamm);\n    return;\n  }\n  for (i=0; i < 0x10000; i++) {\n    curve[i] = 0xffff;\n    if ((r = (double) i / imax) < 1)\n      curve[i] = 0x10000 * ( mode\n\t? (r < g[3] ? r*g[1] : (g[0] ? pow( r,g[0])*(1+g[4])-g[4]    : log(r)*g[2]+1))\n\t: (r < g[2] ? r/g[1] : (g[0] ? pow((r+g[4])/(1+g[4]),1/g[0]) : exp((r-1)/g[2]))));\n  }\n}\n\nvoid CLASS pseudoinverse (double (*in)[3], double (*out)[3], int size)\n{\n  double work[3][6], num;\n  int i, j, k;\n\n  for (i=0; i < 3; i++) {\n    for (j=0; j < 6; j++)\n      work[i][j] = j == i+3;\n    for (j=0; j < 3; j++)\n      for (k=0; k < size; k++)\n\twork[i][j] += in[k][i] * in[k][j];\n  }\n  for (i=0; i < 3; i++) {\n    num = work[i][i];\n    for (j=0; j < 6; j++)\n      work[i][j] /= num;\n    for (k=0; k < 3; k++) {\n      if (k==i) continue;\n      num = work[k][i];\n      for (j=0; j < 6; j++)\n\twork[k][j] -= work[i][j] * num;\n    }\n  }\n  for (i=0; i < size; i++)\n    for (j=0; j < 3; j++)\n      for (out[i][j]=k=0; k < 3; k++)\n\tout[i][j] += work[j][k+3] * in[i][k];\n}\n\nvoid CLASS cam_xyz_coeff (double cam_xyz[4][3])\n{\n  double cam_rgb[4][3], inverse[4][3], num;\n  int i, j, k;\n\n  for (i=0; i < colors; i++)\t\t/* Multiply out XYZ colorspace */\n    for (j=0; j < 3; j++)\n      for (cam_rgb[i][j] = k=0; k < 3; k++)\n\tcam_rgb[i][j] += cam_xyz[i][k] * xyz_rgb[k][j];\n\n  for (i=0; i < colors; i++) {\t\t/* Normalize cam_rgb so that */\n    for (num=j=0; j < 3; j++)\t\t/* cam_rgb * (1,1,1) is (1,1,1,1) */\n      num += cam_rgb[i][j];\n    for (j=0; j < 3; j++)\n      cam_rgb[i][j] /= num;\n    pre_mul[i] = 1 / num;\n  }\n  pseudoinverse (cam_rgb, inverse, colors);\n  for (raw_color = i=0; i < 3; i++)\n    for (j=0; j < colors; j++)\n      rgb_cam[i][j] = inverse[j][i];\n}\n\n#ifdef COLORCHECK\nvoid CLASS colorcheck()\n{\n#define NSQ 24\n// Coordinates of the GretagMacbeth ColorChecker squares\n// width, height, 1st_column, 1st_row\n  int cut[NSQ][4];\t\t\t// you must set these\n// ColorChecker Chart under 6500-kelvin illumination\n  static const double gmb_xyY[NSQ][3] = {\n    { 0.400, 0.350, 10.1 },\t\t// Dark Skin\n    { 0.377, 0.345, 35.8 },\t\t// Light Skin\n    { 0.247, 0.251, 19.3 },\t\t// Blue Sky\n    { 0.337, 0.422, 13.3 },\t\t// Foliage\n    { 0.265, 0.240, 24.3 },\t\t// Blue Flower\n    { 0.261, 0.343, 43.1 },\t\t// Bluish Green\n    { 0.506, 0.407, 30.1 },\t\t// Orange\n    { 0.211, 0.175, 12.0 },\t\t// Purplish Blue\n    { 0.453, 0.306, 19.8 },\t\t// Moderate Red\n    { 0.285, 0.202, 6.6 },\t\t// Purple\n    { 0.380, 0.489, 44.3 },\t\t// Yellow Green\n    { 0.473, 0.438, 43.1 },\t\t// Orange Yellow\n    { 0.187, 0.129, 6.1 },\t\t// Blue\n    { 0.305, 0.478, 23.4 },\t\t// Green\n    { 0.539, 0.313, 12.0 },\t\t// Red\n    { 0.448, 0.470, 59.1 },\t\t// Yellow\n    { 0.364, 0.233, 19.8 },\t\t// Magenta\n    { 0.196, 0.252, 19.8 },\t\t// Cyan\n    { 0.310, 0.316, 90.0 },\t\t// White\n    { 0.310, 0.316, 59.1 },\t\t// Neutral 8\n    { 0.310, 0.316, 36.2 },\t\t// Neutral 6.5\n    { 0.310, 0.316, 19.8 },\t\t// Neutral 5\n    { 0.310, 0.316, 9.0 },\t\t// Neutral 3.5\n    { 0.310, 0.316, 3.1 } };\t\t// Black\n  double gmb_cam[NSQ][4], gmb_xyz[NSQ][3];\n  double inverse[NSQ][3], cam_xyz[4][3], num;\n  int c, i, j, k, sq, row, col, count[4];\n\n  memset (gmb_cam, 0, sizeof gmb_cam);\n  for (sq=0; sq < NSQ; sq++) {\n    FORCC count[c] = 0;\n    for   (row=cut[sq][3]; row < cut[sq][3]+cut[sq][1]; row++)\n      for (col=cut[sq][2]; col < cut[sq][2]+cut[sq][0]; col++) {\n\tc = FC(row,col);\n\tif (c >= colors) c -= 2;\n\tgmb_cam[sq][c] += BAYER(row,col);\n\tcount[c]++;\n      }\n    FORCC gmb_cam[sq][c] = gmb_cam[sq][c]/count[c] - black;\n    gmb_xyz[sq][0] = gmb_xyY[sq][2] * gmb_xyY[sq][0] / gmb_xyY[sq][1];\n    gmb_xyz[sq][1] = gmb_xyY[sq][2];\n    gmb_xyz[sq][2] = gmb_xyY[sq][2] *\n\t\t(1 - gmb_xyY[sq][0] - gmb_xyY[sq][1]) / gmb_xyY[sq][1];\n  }\n  pseudoinverse (gmb_xyz, inverse, NSQ);\n  for (i=0; i < colors; i++)\n    for (j=0; j < 3; j++)\n      for (cam_xyz[i][j] = k=0; k < NSQ; k++)\n\tcam_xyz[i][j] += gmb_cam[k][i] * inverse[k][j];\n  cam_xyz_coeff (cam_xyz);\n  if (verbose) {\n    printf (\"    { \\\"%s %s\\\", %d,\\n\\t{\", make, model, black);\n    num = 10000 / (cam_xyz[1][0] + cam_xyz[1][1] + cam_xyz[1][2]);\n    FORCC for (j=0; j < 3; j++)\n      printf (\"%c%d\", (c | j) ? ',':' ', (int) (cam_xyz[c][j] * num + 0.5));\n    puts (\" } },\");\n  }\n#undef NSQ\n}\n#endif\n\nvoid CLASS hat_transform (float *temp, float *base, int st, int size, int sc)\n{\n  int i;\n  for (i=0; i < sc; i++)\n    temp[i] = 2*base[st*i] + base[st*(sc-i)] + base[st*(i+sc)];\n  for (; i+sc < size; i++)\n    temp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(i+sc)];\n  for (; i < size; i++)\n    temp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(2*size-2-(i+sc))];\n}\n\n#if !defined(LIBRAW_USE_OPENMP)\nvoid CLASS wavelet_denoise()\n{\n  float *fimg=0, *temp, thold, mul[2], avg, diff;\n  int scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];\n  ushort *window[4];\n  static const float noise[] =\n  { 0.8002,0.2735,0.1202,0.0585,0.0291,0.0152,0.0080,0.0044 };\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Wavelet denoising...\\n\"));\n#endif\n\n  while (maximum << scale < 0x10000) scale++;\n  maximum <<= --scale;\n  black <<= scale;\n  FORC4 cblack[c] <<= scale;\n  if ((size = iheight*iwidth) < 0x15550000)\n    fimg = (float *) malloc ((size*3 + iheight + iwidth) * sizeof *fimg);\n  merror (fimg, \"wavelet_denoise()\");\n  temp = fimg + size*3;\n  if ((nc = colors) == 3 && filters) nc++;\n  FORC(nc) {\t\t\t/* denoise R,G1,B,G3 individually */\n    for (i=0; i < size; i++)\n      fimg[i] = 256 * sqrt((double)(image[i][c] << scale));\n    for (hpass=lev=0; lev < 5; lev++) {\n      lpass = size*((lev & 1)+1);\n      for (row=0; row < iheight; row++) {\n\that_transform (temp, fimg+hpass+row*iwidth, 1, iwidth, 1 << lev);\n\tfor (col=0; col < iwidth; col++)\n\t  fimg[lpass + row*iwidth + col] = temp[col] * 0.25;\n      }\n      for (col=0; col < iwidth; col++) {\n\that_transform (temp, fimg+lpass+col, iwidth, iheight, 1 << lev);\n\tfor (row=0; row < iheight; row++)\n\t  fimg[lpass + row*iwidth + col] = temp[row] * 0.25;\n      }\n      thold = threshold * noise[lev];\n      for (i=0; i < size; i++) {\n\tfimg[hpass+i] -= fimg[lpass+i];\n\tif\t(fimg[hpass+i] < -thold) fimg[hpass+i] += thold;\n\telse if (fimg[hpass+i] >  thold) fimg[hpass+i] -= thold;\n\telse\t fimg[hpass+i] = 0;\n\tif (hpass) fimg[i] += fimg[hpass+i];\n      }\n      hpass = lpass;\n    }\n    for (i=0; i < size; i++)\n      image[i][c] = CLIP(SQR(fimg[i]+fimg[lpass+i])/0x10000);\n  }\n  if (filters && colors == 3) {  /* pull G1 and G3 closer together */\n    for (row=0; row < 2; row++) {\n      mul[row] = 0.125 * pre_mul[FC(row+1,0) | 1] / pre_mul[FC(row,0) | 1];\n      blk[row] = cblack[FC(row,0) | 1];\n    }\n    for (i=0; i < 4; i++)\n      window[i] = (ushort *) fimg + width*i;\n    for (wlast=-1, row=1; row < height-1; row++) {\n      while (wlast < row+1) {\n\tfor (wlast++, i=0; i < 4; i++)\n\t  window[(i+3) & 3] = window[i];\n\tfor (col = FC(wlast,1) & 1; col < width; col+=2)\n\t  window[2][col] = BAYER(wlast,col);\n      }\n      thold = threshold/512;\n      for (col = (FC(row,0) & 1)+1; col < width-1; col+=2) {\n\tavg = ( window[0][col-1] + window[0][col+1] +\n\t\twindow[2][col-1] + window[2][col+1] - blk[~row & 1]*4 )\n\t      * mul[row & 1] + (window[1][col] + blk[row & 1]) * 0.5;\n\tavg = avg < 0 ? 0 : sqrt(avg);\n\tdiff = sqrt((double)BAYER(row,col)) - avg;\n\tif      (diff < -thold) diff += thold;\n\telse if (diff >  thold) diff -= thold;\n\telse diff = 0;\n\tBAYER(row,col) = CLIP(SQR(avg+diff) + 0.5);\n      }\n    }\n  }\n  free (fimg);\n}\n#else /* LIBRAW_USE_OPENMP */\nvoid CLASS wavelet_denoise()\n{\n  float *fimg=0, *temp, thold, mul[2], avg, diff;\n   int scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];\n  ushort *window[4];\n  static const float noise[] =\n  { 0.8002,0.2735,0.1202,0.0585,0.0291,0.0152,0.0080,0.0044 };\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Wavelet denoising...\\n\"));\n#endif\n\n  while (maximum << scale < 0x10000) scale++;\n  maximum <<= --scale;\n  black <<= scale;\n  FORC4 cblack[c] <<= scale;\n  if ((size = iheight*iwidth) < 0x15550000)\n    fimg = (float *) malloc ((size*3 + iheight + iwidth) * sizeof *fimg);\n  merror (fimg, \"wavelet_denoise()\");\n  temp = fimg + size*3;\n  if ((nc = colors) == 3 && filters) nc++;\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp parallel default(shared) private(i,col,row,thold,lev,lpass,hpass,temp,c) firstprivate(scale,size) \n#endif\n  {\n      temp = (float*)malloc( (iheight + iwidth) * sizeof *fimg);\n    FORC(nc) {\t\t\t/* denoise R,G1,B,G3 individually */\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n      for (i=0; i < size; i++)\n        fimg[i] = 256 * sqrt((double)(image[i][c] << scale));\n      for (hpass=lev=0; lev < 5; lev++) {\n\tlpass = size*((lev & 1)+1);\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n\tfor (row=0; row < iheight; row++) {\n\t  hat_transform (temp, fimg+hpass+row*iwidth, 1, iwidth, 1 << lev);\n\t  for (col=0; col < iwidth; col++)\n\t    fimg[lpass + row*iwidth + col] = temp[col] * 0.25;\n\t}\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n\tfor (col=0; col < iwidth; col++) {\n\t  hat_transform (temp, fimg+lpass+col, iwidth, iheight, 1 << lev);\n\t  for (row=0; row < iheight; row++)\n\t    fimg[lpass + row*iwidth + col] = temp[row] * 0.25;\n\t}\n\tthold = threshold * noise[lev];\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n\tfor (i=0; i < size; i++) {\n\t  fimg[hpass+i] -= fimg[lpass+i];\n\t  if\t(fimg[hpass+i] < -thold) fimg[hpass+i] += thold;\n\t  else if (fimg[hpass+i] >  thold) fimg[hpass+i] -= thold;\n\t  else\t fimg[hpass+i] = 0;\n\t  if (hpass) fimg[i] += fimg[hpass+i];\n\t}\n\thpass = lpass;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n      for (i=0; i < size; i++)\n\timage[i][c] = CLIP(SQR(fimg[i]+fimg[lpass+i])/0x10000);\n    }\n    free(temp);\n  } /* end omp parallel */\n/* the following loops are hard to parallize, no idea yes,\n * problem is wlast which is carrying dependency\n * second part should be easyer, but did not yet get it right.\n */\n  if (filters && colors == 3) {  /* pull G1 and G3 closer together */\n   for (row=0; row < 2; row++){\n      mul[row] = 0.125 * pre_mul[FC(row+1,0) | 1] / pre_mul[FC(row,0) | 1];\n      blk[row] = cblack[FC(row,0) | 1];\n   }\n    for (i=0; i < 4; i++)\n      window[i] = (ushort *) fimg + width*i;\n    for (wlast=-1, row=1; row < height-1; row++) {\n      while (wlast < row+1) {\n\tfor (wlast++, i=0; i < 4; i++)\n\t  window[(i+3) & 3] = window[i];\n\tfor (col = FC(wlast,1) & 1; col < width; col+=2)\n\t  window[2][col] = BAYER(wlast,col);\n      }\n      thold = threshold/512;\n      for (col = (FC(row,0) & 1)+1; col < width-1; col+=2) {\n\tavg = ( window[0][col-1] + window[0][col+1] +\n\t\twindow[2][col-1] + window[2][col+1] - blk[~row & 1]*4 )\n\t      * mul[row & 1] + (window[1][col] + blk[row & 1]) * 0.5;\n\tavg = avg < 0 ? 0 : sqrt(avg);\n\tdiff = sqrt((double)BAYER(row,col)) - avg;\n\tif      (diff < -thold) diff += thold;\n\telse if (diff >  thold) diff -= thold;\n\telse diff = 0;\n\tBAYER(row,col) = CLIP(SQR(avg+diff) + 0.5);\n      }\n    }\n  }\n  free (fimg);\n}\n\n#endif\n\n// green equilibration\nvoid CLASS green_matching()\n{\n  int i,j;\n  double m1,m2,c1,c2;\n  int o1_1,o1_2,o1_3,o1_4;\n  int o2_1,o2_2,o2_3,o2_4;\n  ushort (*img)[4];\n  const int margin = 3;\n  int oj = 2, oi = 2;\n  float f;\n  const float thr = 0.01f;\n  if(half_size || shrink) return;\n  if(FC(oj, oi) != 3) oj++;\n  if(FC(oj, oi) != 3) oi++;\n  if(FC(oj, oi) != 3) oj--;\n\n  img = (ushort (*)[4]) calloc (height*width, sizeof *image);\n  merror (img, \"green_matching()\");\n  memcpy(img,image,height*width*sizeof *image);\n\n  for(j=oj;j<height-margin;j+=2)\n    for(i=oi;i<width-margin;i+=2){\n      o1_1=img[(j-1)*width+i-1][1];\n      o1_2=img[(j-1)*width+i+1][1];\n      o1_3=img[(j+1)*width+i-1][1];\n      o1_4=img[(j+1)*width+i+1][1];\n      o2_1=img[(j-2)*width+i][3];\n      o2_2=img[(j+2)*width+i][3];\n      o2_3=img[j*width+i-2][3];\n      o2_4=img[j*width+i+2][3];\n\n      m1=(o1_1+o1_2+o1_3+o1_4)/4.0;\n      m2=(o2_1+o2_2+o2_3+o2_4)/4.0;\n\n      c1=(abs(o1_1-o1_2)+abs(o1_1-o1_3)+abs(o1_1-o1_4)+abs(o1_2-o1_3)+abs(o1_3-o1_4)+abs(o1_2-o1_4))/6.0;\n      c2=(abs(o2_1-o2_2)+abs(o2_1-o2_3)+abs(o2_1-o2_4)+abs(o2_2-o2_3)+abs(o2_3-o2_4)+abs(o2_2-o2_4))/6.0;\n      if((img[j*width+i][3]<maximum*0.95)&&(c1<maximum*thr)&&(c2<maximum*thr))\n      {\n        f = image[j*width+i][3]*m1/m2;\n        image[j*width+i][3]=f>0xffff?0xffff:f;\n      }\n    }\n  free(img);\n}\n\nvoid CLASS scale_colors()\n{\n  unsigned bottom, right, size, row, col, ur, uc, i, x, y, c, sum[8];\n  int val, dark, sat;\n  double dsum[8], dmin, dmax;\n  float scale_mul[4], fr, fc;\n  ushort *img=0, *pix;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS,0,2);\n#endif\n\n  if (user_mul[0])\n    memcpy (pre_mul, user_mul, sizeof pre_mul);\n  if (use_auto_wb || (use_camera_wb && cam_mul[0] == -1)) {\n    memset (dsum, 0, sizeof dsum);\n    bottom = MIN (greybox[1]+greybox[3], height);\n    right  = MIN (greybox[0]+greybox[2], width);\n    for (row=greybox[1]; row < bottom; row += 8)\n      for (col=greybox[0]; col < right; col += 8) {\n\tmemset (sum, 0, sizeof sum);\n\tfor (y=row; y < row+8 && y < bottom; y++)\n\t  for (x=col; x < col+8 && x < right; x++)\n\t    FORC4 {\n\t      if (filters) {\n\t\tc = fcol(y,x);\n\t\tval = BAYER2(y,x);\n\t      } else\n\t\tval = image[y*width+x][c];\n\t      if (val > maximum-25) goto skip_block;\n\t      if ((val -= cblack[c]) < 0) val = 0;\n\t      sum[c] += val;\n\t      sum[c+4]++;\n\t      if (filters) break;\n\t    }\n\tFORC(8) dsum[c] += sum[c];\nskip_block: ;\n      }\n    FORC4 if (dsum[c]) pre_mul[c] = dsum[c+4] / dsum[c];\n  }\n  if (use_camera_wb && cam_mul[0] != -1) {\n    memset (sum, 0, sizeof sum);\n    for (row=0; row < 8; row++)\n      for (col=0; col < 8; col++) {\n\tc = FC(row,col);\n\tif ((val = white[row][col] - cblack[c]) > 0)\n\t  sum[c] += val;\n\tsum[c+4]++;\n      }\n    if (sum[0] && sum[1] && sum[2] && sum[3])\n      FORC4 pre_mul[c] = (float) sum[c+4] / sum[c];\n    else if (cam_mul[0] && cam_mul[2])\n      memcpy (pre_mul, cam_mul, sizeof pre_mul);\n    else\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n            imgdata.process_warnings |= LIBRAW_WARN_BAD_CAMERA_WB;\n#endif\n#ifdef DCRAW_VERBOSE\n            fprintf (stderr,_(\"%s: Cannot use camera white balance.\\n\"), ifname);\n#endif\n      }\n  }\n  if (pre_mul[3] == 0) pre_mul[3] = colors < 4 ? pre_mul[1] : 1;\n  dark = black;\n  sat = maximum;\n  if (threshold) wavelet_denoise();\n  maximum -= black;\n  for (dmin=DBL_MAX, dmax=c=0; c < 4; c++) {\n    if (dmin > pre_mul[c])\n\tdmin = pre_mul[c];\n    if (dmax < pre_mul[c])\n\tdmax = pre_mul[c];\n  }\n  if (!highlight) dmax = dmin;\n  FORC4 scale_mul[c] = (pre_mul[c] /= dmax) * 65535.0 / maximum;\n#ifdef DCRAW_VERBOSE\n  if (verbose) {\n    fprintf (stderr,\n      _(\"Scaling with darkness %d, saturation %d, and\\nmultipliers\"), dark, sat);\n    FORC4 fprintf (stderr, \" %f\", pre_mul[c]);\n    fputc ('\\n', stderr);\n  }\n#endif\n  size = iheight*iwidth;\n#ifdef LIBRAW_LIBRARY_BUILD\n  scale_colors_loop(scale_mul);\n#else\n  for (i=0; i < size*4; i++) {\n    val = image[0][i];\n    if (!val) continue;\n    val -= cblack[i & 3];\n    val *= scale_mul[i & 3];\n    image[0][i] = CLIP(val);\n  }\n#endif\n  if ((aber[0] != 1 || aber[2] != 1) && colors == 3) {\n#ifdef DCRAW_VERBOSE\n    if (verbose)\n      fprintf (stderr,_(\"Correcting chromatic aberration...\\n\"));\n#endif\n    for (c=0; c < 4; c+=2) {\n      if (aber[c] == 1) continue;\n      img = (ushort *) malloc (size * sizeof *img);\n      merror (img, \"scale_colors()\");\n      for (i=0; i < size; i++)\n\timg[i] = image[i][c];\n      for (row=0; row < iheight; row++) {\n\tur = fr = (row - iheight*0.5) * aber[c] + iheight*0.5;\n\tif (ur > iheight-2) continue;\n\tfr -= ur;\n\tfor (col=0; col < iwidth; col++) {\n\t  uc = fc = (col - iwidth*0.5) * aber[c] + iwidth*0.5;\n\t  if (uc > iwidth-2) continue;\n\t  fc -= uc;\n\t  pix = img + ur*iwidth + uc;\n\t  image[row*iwidth+col][c] =\n\t    (pix[     0]*(1-fc) + pix[       1]*fc) * (1-fr) +\n\t    (pix[iwidth]*(1-fc) + pix[iwidth+1]*fc) * fr;\n\t}\n      }\n      free(img);\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS,1,2);\n#endif\n}\n\nvoid CLASS pre_interpolate()\n{\n  ushort (*img)[4];\n  int row, col, c;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE,0,2);\n#endif\n  if (shrink) {\n    if (half_size) {\n      height = iheight;\n      width  = iwidth;\n    } else {\n      img = (ushort (*)[4]) calloc (height*width, sizeof *img);\n      merror (img, \"pre_interpolate()\");\n      for (row=0; row < height; row++)\n\tfor (col=0; col < width; col++) {\n\t  c = fcol(row,col);\n\t  img[row*width+col][c] = image[(row >> 1)*iwidth+(col >> 1)][c];\n\t}\n      free (image);\n      image = img;\n      shrink = 0;\n    }\n  }\n  if (filters > 1000 && colors == 3) {\n    if (four_color_rgb && colors++)\n      mix_green = !half_size;\n    else {\n      for (row = FC(1,0) >> 1; row < height; row+=2)\n\tfor (col = FC(row,1) & 1; col < width; col+=2)\n\t  image[row*width+col][1] = image[row*width+col][3];\n      filters &= ~((filters & 0x55555555) << 1);\n    }\n  }\n  if (half_size) filters = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE,1,2);\n#endif\n}\n\nvoid CLASS border_interpolate (int border)\n{\n  unsigned row, col, y, x, f, c, sum[8];\n\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++) {\n      if (col==border && row >= border && row < height-border)\n\tcol = width-border;\n      memset (sum, 0, sizeof sum);\n      for (y=row-1; y != row+2; y++)\n\tfor (x=col-1; x != col+2; x++)\n\t  if (y < height && x < width) {\n\t    f = fcol(y,x);\n\t    sum[f] += image[y*width+x][f];\n\t    sum[f+4]++;\n\t  }\n      f = fcol(row,col);\n      FORCC if (c != f && sum[c+4])\n\timage[row*width+col][c] = sum[c] / sum[c+4];\n    }\n}\n\nvoid CLASS lin_interpolate_loop(int code[16][16][32],int size)\n{\n  int row;\n  for (row=1; row < height-1; row++)\n    {\n      int col,*ip;\n      ushort *pix;\n      for (col=1; col < width-1; col++) {\n        int i;\n        int sum[4];\n        pix = image[row*width+col];\n        ip = code[row % size][col % size];\n        memset (sum, 0, sizeof sum);\n        for (i=*ip++; i--; ip+=3)\n          sum[ip[2]] += pix[ip[0]] << ip[1];\n        for (i=colors; --i; ip+=2)\n          pix[ip[0]] = sum[ip[0]] * ip[1] >> 8;\n      }\n    }\n}\n\nvoid CLASS lin_interpolate()\n{\n  int code[16][16][32], size=16, *ip, sum[4];\n  int f, c, x, y, row, col, shift, color;\n\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Bilinear interpolation...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,0,3);\n#endif\n\n  if (filters == 2) size = 6;\n  border_interpolate(1);\n  for (row=0; row < size; row++)\n    for (col=0; col < size; col++) {\n      ip = code[row][col]+1;\n      f = fcol(row,col);\n      memset (sum, 0, sizeof sum);\n      for (y=-1; y <= 1; y++)\n\tfor (x=-1; x <= 1; x++) {\n\t  shift = (y==0) + (x==0);\n\t  color = fcol(row+y,col+x);\n\t  if (color == f) continue;\n\t  *ip++ = (width*y + x)*4 + color;\n\t  *ip++ = shift;\n\t  *ip++ = color;\n\t  sum[color] += 1 << shift;\n\t}\n      code[row][col][0] = (ip - code[row][col]) / 3;\n      FORCC\n\tif (c != f) {\n\t  *ip++ = c;\n\t  *ip++ = 256 / sum[c];\n\t}\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,1,3);\n#endif\n  lin_interpolate_loop(code,size);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,2,3);\n#endif\n}\n\n/*\n   This algorithm is officially called:\n\n   \"Interpolation using a Threshold-based variable number of gradients\"\n\n   described in http://scien.stanford.edu/pages/labsite/1999/psych221/projects/99/tingchen/algodep/vargra.html\n\n   I've extended the basic idea to work with non-Bayer filter arrays.\n   Gradients are numbered clockwise from NW=0 to W=7.\n */\nvoid CLASS vng_interpolate()\n{\n  static const signed char *cp, terms[] = {\n    -2,-2,+0,-1,0,0x01, -2,-2,+0,+0,1,0x01, -2,-1,-1,+0,0,0x01,\n    -2,-1,+0,-1,0,0x02, -2,-1,+0,+0,0,0x03, -2,-1,+0,+1,1,0x01,\n    -2,+0,+0,-1,0,0x06, -2,+0,+0,+0,1,0x02, -2,+0,+0,+1,0,0x03,\n    -2,+1,-1,+0,0,0x04, -2,+1,+0,-1,1,0x04, -2,+1,+0,+0,0,0x06,\n    -2,+1,+0,+1,0,0x02, -2,+2,+0,+0,1,0x04, -2,+2,+0,+1,0,0x04,\n    -1,-2,-1,+0,0,0x80, -1,-2,+0,-1,0,0x01, -1,-2,+1,-1,0,0x01,\n    -1,-2,+1,+0,1,0x01, -1,-1,-1,+1,0,0x88, -1,-1,+1,-2,0,0x40,\n    -1,-1,+1,-1,0,0x22, -1,-1,+1,+0,0,0x33, -1,-1,+1,+1,1,0x11,\n    -1,+0,-1,+2,0,0x08, -1,+0,+0,-1,0,0x44, -1,+0,+0,+1,0,0x11,\n    -1,+0,+1,-2,1,0x40, -1,+0,+1,-1,0,0x66, -1,+0,+1,+0,1,0x22,\n    -1,+0,+1,+1,0,0x33, -1,+0,+1,+2,1,0x10, -1,+1,+1,-1,1,0x44,\n    -1,+1,+1,+0,0,0x66, -1,+1,+1,+1,0,0x22, -1,+1,+1,+2,0,0x10,\n    -1,+2,+0,+1,0,0x04, -1,+2,+1,+0,1,0x04, -1,+2,+1,+1,0,0x04,\n    +0,-2,+0,+0,1,0x80, +0,-1,+0,+1,1,0x88, +0,-1,+1,-2,0,0x40,\n    +0,-1,+1,+0,0,0x11, +0,-1,+2,-2,0,0x40, +0,-1,+2,-1,0,0x20,\n    +0,-1,+2,+0,0,0x30, +0,-1,+2,+1,1,0x10, +0,+0,+0,+2,1,0x08,\n    +0,+0,+2,-2,1,0x40, +0,+0,+2,-1,0,0x60, +0,+0,+2,+0,1,0x20,\n    +0,+0,+2,+1,0,0x30, +0,+0,+2,+2,1,0x10, +0,+1,+1,+0,0,0x44,\n    +0,+1,+1,+2,0,0x10, +0,+1,+2,-1,1,0x40, +0,+1,+2,+0,0,0x60,\n    +0,+1,+2,+1,0,0x20, +0,+1,+2,+2,0,0x10, +1,-2,+1,+0,0,0x80,\n    +1,-1,+1,+1,0,0x88, +1,+0,+1,+2,0,0x08, +1,+0,+2,-1,0,0x40,\n    +1,+0,+2,+1,0,0x10\n  }, chood[] = { -1,-1, -1,0, -1,+1, 0,+1, +1,+1, +1,0, +1,-1, 0,-1 };\n  ushort (*brow[5])[4], *pix;\n  int prow=8, pcol=2, *ip, *code[16][16], gval[8], gmin, gmax, sum[4];\n  int row, col, x, y, x1, x2, y1, y2, t, weight, grads, color, diag;\n  int g, diff, thold, num, c;\n\n  lin_interpolate();\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"VNG interpolation...\\n\"));\n#endif\n\n  if (filters == 1) prow = pcol = 16;\n  if (filters == 2) prow = pcol =  6;\n  ip = (int *) calloc (prow*pcol, 1280);\n  merror (ip, \"vng_interpolate()\");\n  for (row=0; row < prow; row++)\t\t/* Precalculate for VNG */\n    for (col=0; col < pcol; col++) {\n      code[row][col] = ip;\n      for (cp=terms, t=0; t < 64; t++) {\n\ty1 = *cp++;  x1 = *cp++;\n\ty2 = *cp++;  x2 = *cp++;\n\tweight = *cp++;\n\tgrads = *cp++;\n\tcolor = fcol(row+y1,col+x1);\n\tif (fcol(row+y2,col+x2) != color) continue;\n\tdiag = (fcol(row,col+1) == color && fcol(row+1,col) == color) ? 2:1;\n\tif (abs(y1-y2) == diag && abs(x1-x2) == diag) continue;\n\t*ip++ = (y1*width + x1)*4 + color;\n\t*ip++ = (y2*width + x2)*4 + color;\n\t*ip++ = weight;\n\tfor (g=0; g < 8; g++)\n\t  if (grads & 1<<g) *ip++ = g;\n\t*ip++ = -1;\n      }\n      *ip++ = INT_MAX;\n      for (cp=chood, g=0; g < 8; g++) {\n\ty = *cp++;  x = *cp++;\n\t*ip++ = (y*width + x) * 4;\n\tcolor = fcol(row,col);\n\tif (fcol(row+y,col+x) != color && fcol(row+y*2,col+x*2) == color)\n\t  *ip++ = (y*width + x) * 8 + color;\n\telse\n\t  *ip++ = 0;\n      }\n    }\n  brow[4] = (ushort (*)[4]) calloc (width*3, sizeof **brow);\n  merror (brow[4], \"vng_interpolate()\");\n  for (row=0; row < 3; row++)\n    brow[row] = brow[4] + row*width;\n  for (row=2; row < height-2; row++) {\t\t/* Do VNG interpolation */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if(!((row-2)%256))RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,(row-2)/256+1,((height-3)/256)+1);\n#endif\n    for (col=2; col < width-2; col++) {\n      pix = image[row*width+col];\n      ip = code[row % prow][col % pcol];\n      memset (gval, 0, sizeof gval);\n      while ((g = ip[0]) != INT_MAX) {\t\t/* Calculate gradients */\n\tdiff = ABS(pix[g] - pix[ip[1]]) << ip[2];\n\tgval[ip[3]] += diff;\n\tip += 5;\n\tif ((g = ip[-1]) == -1) continue;\n\tgval[g] += diff;\n\twhile ((g = *ip++) != -1)\n\t  gval[g] += diff;\n      }\n      ip++;\n      gmin = gmax = gval[0];\t\t\t/* Choose a threshold */\n      for (g=1; g < 8; g++) {\n\tif (gmin > gval[g]) gmin = gval[g];\n\tif (gmax < gval[g]) gmax = gval[g];\n      }\n      if (gmax == 0) {\n\tmemcpy (brow[2][col], pix, sizeof *image);\n\tcontinue;\n      }\n      thold = gmin + (gmax >> 1);\n      memset (sum, 0, sizeof sum);\n      color = fcol(row,col);\n      for (num=g=0; g < 8; g++,ip+=2) {\t\t/* Average the neighbors */\n\tif (gval[g] <= thold) {\n\t  FORCC\n\t    if (c == color && ip[1])\n\t      sum[c] += (pix[c] + pix[ip[1]]) >> 1;\n\t    else\n\t      sum[c] += pix[ip[0] + c];\n\t  num++;\n\t}\n      }\n      FORCC {\t\t\t\t\t/* Save to buffer */\n\tt = pix[color];\n\tif (c != color)\n\t  t += (sum[c] - sum[color]) / num;\n\tbrow[2][col][c] = CLIP(t);\n      }\n    }\n    if (row > 3)\t\t\t\t/* Write buffer to image */\n      memcpy (image[(row-2)*width+2], brow[0]+2, (width-4)*sizeof *image);\n    for (g=0; g < 4; g++)\n      brow[(g-1) & 3] = brow[g];\n  }\n  memcpy (image[(row-2)*width+2], brow[0]+2, (width-4)*sizeof *image);\n  memcpy (image[(row-1)*width+2], brow[1]+2, (width-4)*sizeof *image);\n  free (brow[4]);\n  free (code[0][0]);\n}\n\n/*\n   Patterned Pixel Grouping Interpolation by Alain Desbiolles\n*/\nvoid CLASS ppg_interpolate()\n{\n  int dir[5] = { 1, width, -1, -width, 1 };\n  int row, col, diff[2], guess[2], c, d, i;\n  ushort (*pix)[4];\n\n  border_interpolate(3);\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"PPG interpolation...\\n\"));\n#endif\n\n/*  Fill in the green layer with gradients and pattern recognition: */\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,0,3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row=3; row < height-3; row++)\n    for (col=3+(FC(row,3) & 1), c=FC(row,col); col < width-3; col+=2) {\n      pix = image + row*width+col;\n      for (i=0; (d=dir[i]) > 0; i++) {\n\tguess[i] = (pix[-d][1] + pix[0][c] + pix[d][1]) * 2\n\t\t      - pix[-2*d][c] - pix[2*d][c];\n\tdiff[i] = ( ABS(pix[-2*d][c] - pix[ 0][c]) +\n\t\t    ABS(pix[ 2*d][c] - pix[ 0][c]) +\n\t\t    ABS(pix[  -d][1] - pix[ d][1]) ) * 3 +\n\t\t  ( ABS(pix[ 3*d][1] - pix[ d][1]) +\n\t\t    ABS(pix[-3*d][1] - pix[-d][1]) ) * 2;\n      }\n      d = dir[i = diff[0] > diff[1]];\n      pix[0][1] = ULIM(guess[i] >> 2, pix[d][1], pix[-d][1]);\n    }\n/*  Calculate red and blue for each green pixel:\t\t*/\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,1,3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row=1; row < height-1; row++)\n    for (col=1+(FC(row,2) & 1), c=FC(row,col+1); col < width-1; col+=2) {\n      pix = image + row*width+col;\n      for (i=0; (d=dir[i]) > 0; c=2-c, i++)\n\tpix[0][c] = CLIP((pix[-d][c] + pix[d][c] + 2*pix[0][1]\n\t\t\t- pix[-d][1] - pix[d][1]) >> 1);\n    }\n/*  Calculate blue for red pixels and vice versa:\t\t*/\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,2,3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row=1; row < height-1; row++)\n    for (col=1+(FC(row,1) & 1), c=2-FC(row,col); col < width-1; col+=2) {\n      pix = image + row*width+col;\n      for (i=0; (d=dir[i]+dir[i+1]) > 0; i++) {\n\tdiff[i] = ABS(pix[-d][c] - pix[d][c]) +\n\t\t  ABS(pix[-d][1] - pix[0][1]) +\n\t\t  ABS(pix[ d][1] - pix[0][1]);\n\tguess[i] = pix[-d][c] + pix[d][c] + 2*pix[0][1]\n\t\t - pix[-d][1] - pix[d][1];\n      }\n      if (diff[0] != diff[1])\n\tpix[0][c] = CLIP(guess[diff[0] > diff[1]] >> 1);\n      else\n\tpix[0][c] = CLIP((guess[0]+guess[1]) >> 2);\n    }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n/*\n   Adaptive Homogeneity-Directed interpolation is based on\n   the work of Keigo Hirakawa, Thomas Parks, and Paul Lee.\n */\n#define TS 256\t\t/* Tile Size */\nstatic float dcraw_cbrt[0x10000] = {-1.0f};\n\nstatic inline float calc_64cbrt(float f)\n{\n  unsigned u;\n  static float lower = dcraw_cbrt[0];\n  static float upper = dcraw_cbrt[0xffff];\n\n  if (f <= 0) {\n    return lower;\n  }\n\n  u = (unsigned) f;\n  if (u >= 0xffff) {\n    return upper;\n  }\n  return dcraw_cbrt[u];\n}\nvoid CLASS ahd_interpolate_green_h_and_v(int top, int left, ushort (*out_rgb)[TS][TS][3])\n{\n  int row, col;\n  int c, val;\n  ushort (*pix)[4];\n  const int rowlimit = MIN(top+TS, height-2);\n  const int collimit = MIN(left+TS, width-2);\n\n  for (row = top; row < rowlimit; row++) {\n    col = left + (FC(row,left) & 1);\n    for (c = FC(row,col); col < collimit; col+=2) {\n      pix = image + row*width+col;\n      val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2\n            - pix[-2][c] - pix[2][c]) >> 2;\n      out_rgb[0][row-top][col-left][1] = ULIM(val,pix[-1][1],pix[1][1]);\n      val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2\n            - pix[-2*width][c] - pix[2*width][c]) >> 2;\n      out_rgb[1][row-top][col-left][1] = ULIM(val,pix[-width][1],pix[width][1]);\n    }\n  }\n}\nvoid CLASS ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][3], short (*out_lab)[TS][3], const float (&xyz_cam)[3][4])\n{\n  unsigned row, col;\n  int c, val;\n  ushort (*pix)[4];\n  ushort (*rix)[3];\n  short (*lix)[3];\n  float xyz[3];\n  const unsigned num_pix_per_row = 4*width;\n  const unsigned rowlimit = MIN(top+TS-1, height-3);\n  const unsigned collimit = MIN(left+TS-1, width-3);\n  ushort *pix_above;\n  ushort *pix_below;\n  int t1, t2;\n\n  for (row = top+1; row < rowlimit; row++) {\n    pix = image + row*width + left;\n    rix = &inout_rgb[row-top][0];\n    lix = &out_lab[row-top][0];\n\n    for (col = left+1; col < collimit; col++) {\n      pix++;\n      pix_above = &pix[0][0] - num_pix_per_row;\n      pix_below = &pix[0][0] + num_pix_per_row;\n      rix++;\n      lix++;\n\n      c = 2 - FC(row, col);\n\n      if (c == 1) {\n        c = FC(row+1,col);\n\tt1 = 2-c;\n        val = pix[0][1] + (( pix[-1][t1] + pix[1][t1]\n              - rix[-1][1] - rix[1][1] ) >> 1);\n        rix[0][t1] = CLIP(val);\n        val = pix[0][1] + (( pix_above[c] + pix_below[c]\n              - rix[-TS][1] - rix[TS][1] ) >> 1);\n      } else {\n\tt1 = -4+c; /* -4+c: pixel of color c to the left */\n\tt2 = 4+c; /* 4+c: pixel of color c to the right */\n        val = rix[0][1] + (( pix_above[t1] + pix_above[t2]\n              + pix_below[t1] + pix_below[t2]\n              - rix[-TS-1][1] - rix[-TS+1][1]\n              - rix[+TS-1][1] - rix[+TS+1][1] + 1) >> 2);\n      }\n      rix[0][c] = CLIP(val);\n      c = FC(row,col);\n      rix[0][c] = pix[0][c];\n      xyz[0] = xyz[1] = xyz[2] = 0.5;\n      FORC3 {\n\t/*\n\t * Technically this ought to be FORCC, but the rest of\n\t * ahd_interpolate() assumes 3 colors so let's help the compiler.\n\t */\n        xyz[0] += xyz_cam[0][c] * rix[0][c];\n        xyz[1] += xyz_cam[1][c] * rix[0][c];\n        xyz[2] += xyz_cam[2][c] * rix[0][c];\n      }\n      FORC3 {\n\txyz[c] = calc_64cbrt(xyz[c]);\n      }\n      lix[0][0] = (116 * xyz[1] - 16);\n      lix[0][1] = 500 * (xyz[0] - xyz[1]);\n      lix[0][2] = 200 * (xyz[1] - xyz[2]);\n    }\n  }\n}\nvoid CLASS ahd_interpolate_r_and_b_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][TS][3], short (*out_lab)[TS][TS][3], const float (&xyz_cam)[3][4])\n{\n  int direction;\n  for (direction = 0; direction < 2; direction++) {\n    ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(top, left, inout_rgb[direction], out_lab[direction], xyz_cam);\n  }\n}\nvoid CLASS ahd_interpolate_build_homogeneity_map(int top, int left, short (*lab)[TS][TS][3], char (*out_homogeneity_map)[TS][2])\n{\n  int row, col;\n  int tr, tc;\n  int direction;\n  int i;\n  short (*lix)[3];\n  short (*lixs[2])[3];\n  short *adjacent_lix;\n  unsigned ldiff[2][4], abdiff[2][4], leps, abeps;\n  static const int dir[4] = { -1, 1, -TS, TS };\n  const int rowlimit = MIN(top+TS-2, height-4);\n  const int collimit = MIN(left+TS-2, width-4);\n  int homogeneity;\n  char (*homogeneity_map_p)[2];\n\n  memset (out_homogeneity_map, 0, 2*TS*TS);\n\n  for (row=top+2; row < rowlimit; row++) {\n    tr = row-top;\n    homogeneity_map_p = &out_homogeneity_map[tr][1];\n    for (direction=0; direction < 2; direction++) {\n      lixs[direction] = &lab[direction][tr][1];\n    }\n\n    for (col=left+2; col < collimit; col++) {\n      tc = col-left;\n      homogeneity_map_p++;\n\n      for (direction=0; direction < 2; direction++) {\n        lix = ++lixs[direction];\n        for (i=0; i < 4; i++) {\n\t  adjacent_lix = lix[dir[i]];\n          ldiff[direction][i] = ABS(lix[0][0]-adjacent_lix[0]);\n          abdiff[direction][i] = SQR(lix[0][1]-adjacent_lix[1])\n            + SQR(lix[0][2]-adjacent_lix[2]);\n        }\n      }\n      leps = MIN(MAX(ldiff[0][0],ldiff[0][1]),\n          MAX(ldiff[1][2],ldiff[1][3]));\n      abeps = MIN(MAX(abdiff[0][0],abdiff[0][1]),\n          MAX(abdiff[1][2],abdiff[1][3]));\n      for (direction=0; direction < 2; direction++) {\n\thomogeneity = 0;\n        for (i=0; i < 4; i++) {\n          if (ldiff[direction][i] <= leps && abdiff[direction][i] <= abeps) {\n\t    homogeneity++;\n\t  }\n\t}\n\thomogeneity_map_p[0][direction] = homogeneity;\n      }\n    }\n  }\n}\nvoid CLASS ahd_interpolate_combine_homogeneous_pixels(int top, int left, ushort (*rgb)[TS][TS][3], char (*homogeneity_map)[TS][2])\n{\n  int row, col;\n  int tr, tc;\n  int i, j;\n  int direction;\n  int hm[2];\n  int c;\n  const int rowlimit = MIN(top+TS-3, height-5);\n  const int collimit = MIN(left+TS-3, width-5);\n\n  ushort (*pix)[4];\n  ushort (*rix[2])[3];\n\n  for (row=top+3; row < rowlimit; row++) {\n    tr = row-top;\n    pix = &image[row*width+left+2];\n    for (direction = 0; direction < 2; direction++) {\n      rix[direction] = &rgb[direction][tr][2];\n    }\n\n    for (col=left+3; col < collimit; col++) {\n      tc = col-left;\n      pix++;\n      for (direction = 0; direction < 2; direction++) {\n        rix[direction]++;\n      }\n\n      for (direction=0; direction < 2; direction++) {\n        hm[direction] = 0;\n        for (i=tr-1; i <= tr+1; i++) {\n          for (j=tc-1; j <= tc+1; j++) {\n            hm[direction] += homogeneity_map[i][j][direction];\n          }\n        }\n      }\n      if (hm[0] != hm[1]) {\n        memcpy(pix[0], rix[hm[1] > hm[0]][0], 3 * sizeof(ushort));\n      } else {\n        FORC3 {\n          pix[0][c] = (rix[0][0][c] + rix[1][0][c]) >> 1;\n        }\n      }\n    }\n  }\n}\nvoid CLASS ahd_interpolate()\n{\n  int i, j, k, top, left;\n  float xyz_cam[3][4],r;\n  char *buffer;\n  ushort (*rgb)[TS][TS][3];\n  short (*lab)[TS][TS][3];\n  char (*homo)[TS][2];\n  int terminate_flag = 0;\n\n  if(dcraw_cbrt[0]<-0.1){\n      for (i=0x10000-1; i >=0; i--) {\n          r = i / 65535.0;\n          dcraw_cbrt[i] = 64.0*(r > 0.008856 ? pow((double)r,1/3.0) : 7.787*r + 16/116.0);\n      }\n  }\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"AHD interpolation...\\n\"));\n#endif\n\n  for (i=0; i < 3; i++) {\n    for (j=0; j < colors; j++) {\n      xyz_cam[i][j] = 0;\n      for (k=0; k < 3; k++) {\n        xyz_cam[i][j] += xyz_rgb[i][k] * rgb_cam[k][j] / d65_white[i];\n      }\n    }\n  }\n\n  border_interpolate(5);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel private(buffer,rgb,lab,homo,top,left,i,j,k) shared(xyz_cam,terminate_flag)\n#endif\n#endif\n  {\n    buffer = (char *) malloc (26*TS*TS);\t\t/* 1664 kB */\n    merror (buffer, \"ahd_interpolate()\");\n    rgb  = (ushort(*)[TS][TS][3]) buffer;\n    lab  = (short (*)[TS][TS][3])(buffer + 12*TS*TS);\n    homo = (char  (*)[TS][2])    (buffer + 24*TS*TS);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp for schedule(dynamic)\n#endif\n#endif\n    for (top=2; top < height-5; top += TS-6){\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n        if(0== omp_get_thread_num())\n#endif\n           if(callbacks.progress_cb) {                                     \n               int rr = (*callbacks.progress_cb)(callbacks.progresscb_data,LIBRAW_PROGRESS_INTERPOLATE,top-2,height-7);\n               if(rr)\n                   terminate_flag = 1;\n           }\n#endif\n        for (left=2; !terminate_flag && (left < width-5); left += TS-6) {\n            ahd_interpolate_green_h_and_v(top, left, rgb);\n            ahd_interpolate_r_and_b_and_convert_to_cielab(top, left, rgb, lab, xyz_cam);\n            ahd_interpolate_build_homogeneity_map(top, left, lab, homo);\n            ahd_interpolate_combine_homogeneous_pixels(top, left, rgb, homo);\n      }\n    }\n    free (buffer);\n  }\n#ifdef LIBRAW_LIBRARY_BUILD \n  if(terminate_flag)\n      throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#endif\n}\n\n\n\n#undef TS\n\n#else\n/*\n   Adaptive Homogeneity-Directed interpolation is based on\n   the work of Keigo Hirakawa, Thomas Parks, and Paul Lee.\n */\n#define TS 256\t\t/* Tile Size */\n\nvoid CLASS ahd_interpolate()\n{\n  int i, j, k, top, left, row, col, tr, tc, c, d, val, hm[2];\n  ushort (*pix)[4], (*rix)[3];\n  static const int dir[4] = { -1, 1, -TS, TS };\n  unsigned ldiff[2][4], abdiff[2][4], leps, abeps;\n  float r, cbrt[0x10000], xyz[3], xyz_cam[3][4];\n  ushort (*rgb)[TS][TS][3];\n   short (*lab)[TS][TS][3], (*lix)[3];\n   char (*homo)[TS][TS], *buffer;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"AHD interpolation...\\n\"));\n#endif\n\n  for (i=0; i < 0x10000; i++) {\n    r = i / 65535.0;\n    cbrt[i] = r > 0.008856 ? pow((double)r,(double)(1/3.0)) : 7.787*r + 16/116.0;\n  }\n  for (i=0; i < 3; i++)\n    for (j=0; j < colors; j++)\n      for (xyz_cam[i][j] = k=0; k < 3; k++)\n\txyz_cam[i][j] += xyz_rgb[i][k] * rgb_cam[k][j] / d65_white[i];\n\n  border_interpolate(5);\n  buffer = (char *) malloc (26*TS*TS);\t\t/* 1664 kB */\n  merror (buffer, \"ahd_interpolate()\");\n  rgb  = (ushort(*)[TS][TS][3]) buffer;\n  lab  = (short (*)[TS][TS][3])(buffer + 12*TS*TS);\n  homo = (char  (*)[TS][TS])   (buffer + 24*TS*TS);\n\n  for (top=2; top < height-5; top += TS-6)\n    for (left=2; left < width-5; left += TS-6) {\n\n/*  Interpolate green horizontally and vertically:\t\t*/\n      for (row = top; row < top+TS && row < height-2; row++) {\n\tcol = left + (FC(row,left) & 1);\n\tfor (c = FC(row,col); col < left+TS && col < width-2; col+=2) {\n\t  pix = image + row*width+col;\n\t  val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2\n\t\t- pix[-2][c] - pix[2][c]) >> 2;\n\t  rgb[0][row-top][col-left][1] = ULIM(val,pix[-1][1],pix[1][1]);\n\t  val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2\n\t\t- pix[-2*width][c] - pix[2*width][c]) >> 2;\n\t  rgb[1][row-top][col-left][1] = ULIM(val,pix[-width][1],pix[width][1]);\n\t}\n      }\n/*  Interpolate red and blue, and convert to CIELab:\t\t*/\n      for (d=0; d < 2; d++)\n\tfor (row=top+1; row < top+TS-1 && row < height-3; row++)\n\t  for (col=left+1; col < left+TS-1 && col < width-3; col++) {\n\t    pix = image + row*width+col;\n\t    rix = &rgb[d][row-top][col-left];\n\t    lix = &lab[d][row-top][col-left];\n\t    if ((c = 2 - FC(row,col)) == 1) {\n\t      c = FC(row+1,col);\n\t      val = pix[0][1] + (( pix[-1][2-c] + pix[1][2-c]\n\t\t\t\t - rix[-1][1] - rix[1][1] ) >> 1);\n\t      rix[0][2-c] = CLIP(val);\n\t      val = pix[0][1] + (( pix[-width][c] + pix[width][c]\n\t\t\t\t - rix[-TS][1] - rix[TS][1] ) >> 1);\n\t    } else\n\t      val = rix[0][1] + (( pix[-width-1][c] + pix[-width+1][c]\n\t\t\t\t + pix[+width-1][c] + pix[+width+1][c]\n\t\t\t\t - rix[-TS-1][1] - rix[-TS+1][1]\n\t\t\t\t - rix[+TS-1][1] - rix[+TS+1][1] + 1) >> 2);\n\t    rix[0][c] = CLIP(val);\n\t    c = FC(row,col);\n\t    rix[0][c] = pix[0][c];\n\t    xyz[0] = xyz[1] = xyz[2] = 0.5;\n\t    FORCC {\n\t      xyz[0] += xyz_cam[0][c] * rix[0][c];\n\t      xyz[1] += xyz_cam[1][c] * rix[0][c];\n\t      xyz[2] += xyz_cam[2][c] * rix[0][c];\n\t    }\n\t    xyz[0] = cbrt[CLIP((int) xyz[0])];\n\t    xyz[1] = cbrt[CLIP((int) xyz[1])];\n\t    xyz[2] = cbrt[CLIP((int) xyz[2])];\n\t    lix[0][0] = 64 * (116 * xyz[1] - 16);\n\t    lix[0][1] = 64 * 500 * (xyz[0] - xyz[1]);\n\t    lix[0][2] = 64 * 200 * (xyz[1] - xyz[2]);\n\t  }\n/*  Build homogeneity maps from the CIELab images:\t\t*/\n      memset (homo, 0, 2*TS*TS);\n      for (row=top+2; row < top+TS-2 && row < height-4; row++) {\n\ttr = row-top;\n\tfor (col=left+2; col < left+TS-2 && col < width-4; col++) {\n\t  tc = col-left;\n\t  for (d=0; d < 2; d++) {\n\t    lix = &lab[d][tr][tc];\n\t    for (i=0; i < 4; i++) {\n\t       ldiff[d][i] = ABS(lix[0][0]-lix[dir[i]][0]);\n\t      abdiff[d][i] = SQR(lix[0][1]-lix[dir[i]][1])\n\t\t\t   + SQR(lix[0][2]-lix[dir[i]][2]);\n\t    }\n\t  }\n\t  leps = MIN(MAX(ldiff[0][0],ldiff[0][1]),\n\t\t     MAX(ldiff[1][2],ldiff[1][3]));\n\t  abeps = MIN(MAX(abdiff[0][0],abdiff[0][1]),\n\t\t      MAX(abdiff[1][2],abdiff[1][3]));\n\t  for (d=0; d < 2; d++)\n\t    for (i=0; i < 4; i++)\n\t      if (ldiff[d][i] <= leps && abdiff[d][i] <= abeps)\n\t\thomo[d][tr][tc]++;\n\t}\n      }\n/*  Combine the most homogenous pixels for the final result:\t*/\n      for (row=top+3; row < top+TS-3 && row < height-5; row++) {\n\ttr = row-top;\n\tfor (col=left+3; col < left+TS-3 && col < width-5; col++) {\n\t  tc = col-left;\n\t  for (d=0; d < 2; d++)\n\t    for (hm[d]=0, i=tr-1; i <= tr+1; i++)\n\t      for (j=tc-1; j <= tc+1; j++)\n\t\thm[d] += homo[d][i][j];\n\t  if (hm[0] != hm[1])\n\t    FORC3 image[row*width+col][c] = rgb[hm[1] > hm[0]][tr][tc][c];\n\t  else\n\t    FORC3 image[row*width+col][c] =\n\t\t(rgb[0][tr][tc][c] + rgb[1][tr][tc][c]) >> 1;\n\t}\n      }\n    }\n  free (buffer);\n}\n#undef TS\n#endif\n\nvoid CLASS median_filter()\n{\n  ushort (*pix)[4];\n  int pass, c, i, j, k, med[9];\n  static const uchar opt[] =\t/* Optimal 9-element median search */\n  { 1,2, 4,5, 7,8, 0,1, 3,4, 6,7, 1,2, 4,5, 7,8,\n    0,3, 5,8, 4,7, 3,6, 1,4, 2,5, 4,7, 4,2, 6,4, 4,2 };\n\n  for (pass=1; pass <= med_passes; pass++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n      RUN_CALLBACK(LIBRAW_PROGRESS_MEDIAN_FILTER,pass-1,med_passes);\n#endif\n#ifdef DCRAW_VERBOSE\n    if (verbose)\n      fprintf (stderr,_(\"Median filter pass %d...\\n\"), pass);\n#endif\n    for (c=0; c < 3; c+=2) {\n      for (pix = image; pix < image+width*height; pix++)\n\tpix[0][3] = pix[0][c];\n      for (pix = image+width; pix < image+width*(height-1); pix++) {\n\tif ((pix-image+1) % width < 2) continue;\n\tfor (k=0, i = -width; i <= width; i += width)\n\t  for (j = i-1; j <= i+1; j++)\n\t    med[k++] = pix[j][3] - pix[j][1];\n\tfor (i=0; i < sizeof opt; i+=2)\n\t  if     (med[opt[i]] > med[opt[i+1]])\n\t    SWAP (med[opt[i]] , med[opt[i+1]]);\n\tpix[0][c] = CLIP(med[4] + pix[0][1]);\n      }\n    }\n  }\n}\n\nvoid CLASS blend_highlights()\n{\n  int clip=INT_MAX, row, col, c, i, j;\n  static const float trans[2][4][4] =\n  { { { 1,1,1 }, { 1.7320508,-1.7320508,0 }, { -1,-1,2 } },\n    { { 1,1,1,1 }, { 1,-1,1,-1 }, { 1,1,-1,-1 }, { 1,-1,-1,1 } } };\n  static const float itrans[2][4][4] =\n  { { { 1,0.8660254,-0.5 }, { 1,-0.8660254,-0.5 }, { 1,0,1 } },\n    { { 1,1,1,1 }, { 1,-1,1,-1 }, { 1,1,-1,-1 }, { 1,-1,-1,1 } } };\n  float cam[2][4], lab[2][4], sum[2], chratio;\n\n  if ((unsigned) (colors-3) > 1) return;\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Blending highlights...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,0,2);\n#endif\n  FORCC if (clip > (i = 65535*pre_mul[c])) clip = i;\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++) {\n      FORCC if (image[row*width+col][c] > clip) break;\n      if (c == colors) continue;\n      FORCC {\n\tcam[0][c] = image[row*width+col][c];\n\tcam[1][c] = MIN(cam[0][c],clip);\n      }\n      for (i=0; i < 2; i++) {\n\tFORCC for (lab[i][c]=j=0; j < colors; j++)\n\t  lab[i][c] += trans[colors-3][c][j] * cam[i][j];\n\tfor (sum[i]=0,c=1; c < colors; c++)\n\t  sum[i] += SQR(lab[i][c]);\n      }\n      chratio = sqrt(sum[1]/sum[0]);\n      for (c=1; c < colors; c++)\n\tlab[0][c] *= chratio;\n      FORCC for (cam[0][c]=j=0; j < colors; j++)\n\tcam[0][c] += itrans[colors-3][c][j] * lab[0][j];\n      FORCC image[row*width+col][c] = cam[0][c] / colors;\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,1,2);\n#endif\n}\n\n#define SCALE (4 >> shrink)\nvoid CLASS recover_highlights()\n{\n  float *map, sum, wgt, grow;\n  int hsat[4], count, spread, change, val, i;\n  unsigned high, wide, mrow, mcol, row, col, kc, c, d, y, x;\n  ushort *pixel;\n  static const signed char dir[8][2] =\n    { {-1,-1}, {-1,0}, {-1,1}, {0,1}, {1,1}, {1,0}, {1,-1}, {0,-1} };\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Rebuilding highlights...\\n\"));\n#endif\n\n  grow = pow (2.0, 4-highlight);\n  FORCC hsat[c] = 32000 * pre_mul[c];\n  for (kc=0, c=1; c < colors; c++)\n    if (pre_mul[kc] < pre_mul[c]) kc = c;\n  high = height / SCALE;\n  wide =  width / SCALE;\n  map = (float *) calloc (high*wide, sizeof *map);\n  merror (map, \"recover_highlights()\");\n  FORCC if (c != kc) {\n#ifdef LIBRAW_LIBRARY_BUILD\n      RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,c-1,colors-1);\n#endif\n    memset (map, 0, high*wide*sizeof *map);\n    for (mrow=0; mrow < high; mrow++)\n      for (mcol=0; mcol < wide; mcol++) {\n\tsum = wgt = count = 0;\n\tfor (row = mrow*SCALE; row < (mrow+1)*SCALE; row++)\n\t  for (col = mcol*SCALE; col < (mcol+1)*SCALE; col++) {\n\t    pixel = image[row*width+col];\n\t    if (pixel[c] / hsat[c] == 1 && pixel[kc] > 24000) {\n\t      sum += pixel[c];\n\t      wgt += pixel[kc];\n\t      count++;\n\t    }\n\t  }\n\tif (count == SCALE*SCALE)\n\t  map[mrow*wide+mcol] = sum / wgt;\n      }\n    for (spread = 32/grow; spread--; ) {\n      for (mrow=0; mrow < high; mrow++)\n\tfor (mcol=0; mcol < wide; mcol++) {\n\t  if (map[mrow*wide+mcol]) continue;\n\t  sum = count = 0;\n\t  for (d=0; d < 8; d++) {\n\t    y = mrow + dir[d][0];\n\t    x = mcol + dir[d][1];\n\t    if (y < high && x < wide && map[y*wide+x] > 0) {\n\t      sum  += (1 + (d & 1)) * map[y*wide+x];\n\t      count += 1 + (d & 1);\n\t    }\n\t  }\n\t  if (count > 3)\n\t    map[mrow*wide+mcol] = - (sum+grow) / (count+grow);\n\t}\n      for (change=i=0; i < high*wide; i++)\n\tif (map[i] < 0) {\n\t  map[i] = -map[i];\n\t  change = 1;\n\t}\n      if (!change) break;\n    }\n    for (i=0; i < high*wide; i++)\n      if (map[i] == 0) map[i] = 1;\n    for (mrow=0; mrow < high; mrow++)\n      for (mcol=0; mcol < wide; mcol++) {\n\tfor (row = mrow*SCALE; row < (mrow+1)*SCALE; row++)\n\t  for (col = mcol*SCALE; col < (mcol+1)*SCALE; col++) {\n\t    pixel = image[row*width+col];\n\t    if (pixel[c] / hsat[c] > 1) {\n\t      val = pixel[kc] * map[mrow*wide+mcol];\n\t      if (pixel[c] < val) pixel[c] = CLIP(val);\n\t    }\n\t  }\n      }\n  }\n  free (map);\n}\n#undef SCALE\n\nvoid CLASS tiff_get (unsigned base,\n\tunsigned *tag, unsigned *type, unsigned *len, unsigned *save)\n{\n  *tag  = get2();\n  *type = get2();\n  *len  = get4();\n  *save = ftell(ifp) + 4;\n  if (*len * (\"11124811248488\"[*type < 14 ? *type:0]-'0') > 4)\n    fseek (ifp, get4()+base, SEEK_SET);\n}\n\nvoid CLASS parse_thumb_note (int base, unsigned toff, unsigned tlen)\n{\n  unsigned entries, tag, type, len, save;\n\n  entries = get2();\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    if (tag == toff) thumb_offset = get4()+base;\n    if (tag == tlen) thumb_length = get4();\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n//@end COMMON\n\nint CLASS parse_tiff_ifd (int base);\n\n//@out COMMON\nvoid CLASS parse_makernote (int base, int uptag)\n{\n  static const uchar xlat[2][256] = {\n  { 0xc1,0xbf,0x6d,0x0d,0x59,0xc5,0x13,0x9d,0x83,0x61,0x6b,0x4f,0xc7,0x7f,0x3d,0x3d,\n    0x53,0x59,0xe3,0xc7,0xe9,0x2f,0x95,0xa7,0x95,0x1f,0xdf,0x7f,0x2b,0x29,0xc7,0x0d,\n    0xdf,0x07,0xef,0x71,0x89,0x3d,0x13,0x3d,0x3b,0x13,0xfb,0x0d,0x89,0xc1,0x65,0x1f,\n    0xb3,0x0d,0x6b,0x29,0xe3,0xfb,0xef,0xa3,0x6b,0x47,0x7f,0x95,0x35,0xa7,0x47,0x4f,\n    0xc7,0xf1,0x59,0x95,0x35,0x11,0x29,0x61,0xf1,0x3d,0xb3,0x2b,0x0d,0x43,0x89,0xc1,\n    0x9d,0x9d,0x89,0x65,0xf1,0xe9,0xdf,0xbf,0x3d,0x7f,0x53,0x97,0xe5,0xe9,0x95,0x17,\n    0x1d,0x3d,0x8b,0xfb,0xc7,0xe3,0x67,0xa7,0x07,0xf1,0x71,0xa7,0x53,0xb5,0x29,0x89,\n    0xe5,0x2b,0xa7,0x17,0x29,0xe9,0x4f,0xc5,0x65,0x6d,0x6b,0xef,0x0d,0x89,0x49,0x2f,\n    0xb3,0x43,0x53,0x65,0x1d,0x49,0xa3,0x13,0x89,0x59,0xef,0x6b,0xef,0x65,0x1d,0x0b,\n    0x59,0x13,0xe3,0x4f,0x9d,0xb3,0x29,0x43,0x2b,0x07,0x1d,0x95,0x59,0x59,0x47,0xfb,\n    0xe5,0xe9,0x61,0x47,0x2f,0x35,0x7f,0x17,0x7f,0xef,0x7f,0x95,0x95,0x71,0xd3,0xa3,\n    0x0b,0x71,0xa3,0xad,0x0b,0x3b,0xb5,0xfb,0xa3,0xbf,0x4f,0x83,0x1d,0xad,0xe9,0x2f,\n    0x71,0x65,0xa3,0xe5,0x07,0x35,0x3d,0x0d,0xb5,0xe9,0xe5,0x47,0x3b,0x9d,0xef,0x35,\n    0xa3,0xbf,0xb3,0xdf,0x53,0xd3,0x97,0x53,0x49,0x71,0x07,0x35,0x61,0x71,0x2f,0x43,\n    0x2f,0x11,0xdf,0x17,0x97,0xfb,0x95,0x3b,0x7f,0x6b,0xd3,0x25,0xbf,0xad,0xc7,0xc5,\n    0xc5,0xb5,0x8b,0xef,0x2f,0xd3,0x07,0x6b,0x25,0x49,0x95,0x25,0x49,0x6d,0x71,0xc7 },\n  { 0xa7,0xbc,0xc9,0xad,0x91,0xdf,0x85,0xe5,0xd4,0x78,0xd5,0x17,0x46,0x7c,0x29,0x4c,\n    0x4d,0x03,0xe9,0x25,0x68,0x11,0x86,0xb3,0xbd,0xf7,0x6f,0x61,0x22,0xa2,0x26,0x34,\n    0x2a,0xbe,0x1e,0x46,0x14,0x68,0x9d,0x44,0x18,0xc2,0x40,0xf4,0x7e,0x5f,0x1b,0xad,\n    0x0b,0x94,0xb6,0x67,0xb4,0x0b,0xe1,0xea,0x95,0x9c,0x66,0xdc,0xe7,0x5d,0x6c,0x05,\n    0xda,0xd5,0xdf,0x7a,0xef,0xf6,0xdb,0x1f,0x82,0x4c,0xc0,0x68,0x47,0xa1,0xbd,0xee,\n    0x39,0x50,0x56,0x4a,0xdd,0xdf,0xa5,0xf8,0xc6,0xda,0xca,0x90,0xca,0x01,0x42,0x9d,\n    0x8b,0x0c,0x73,0x43,0x75,0x05,0x94,0xde,0x24,0xb3,0x80,0x34,0xe5,0x2c,0xdc,0x9b,\n    0x3f,0xca,0x33,0x45,0xd0,0xdb,0x5f,0xf5,0x52,0xc3,0x21,0xda,0xe2,0x22,0x72,0x6b,\n    0x3e,0xd0,0x5b,0xa8,0x87,0x8c,0x06,0x5d,0x0f,0xdd,0x09,0x19,0x93,0xd0,0xb9,0xfc,\n    0x8b,0x0f,0x84,0x60,0x33,0x1c,0x9b,0x45,0xf1,0xf0,0xa3,0x94,0x3a,0x12,0x77,0x33,\n    0x4d,0x44,0x78,0x28,0x3c,0x9e,0xfd,0x65,0x57,0x16,0x94,0x6b,0xfb,0x59,0xd0,0xc8,\n    0x22,0x36,0xdb,0xd2,0x63,0x98,0x43,0xa1,0x04,0x87,0x86,0xf7,0xa6,0x26,0xbb,0xd6,\n    0x59,0x4d,0xbf,0x6a,0x2e,0xaa,0x2b,0xef,0xe6,0x78,0xb6,0x4e,0xe0,0x2f,0xdc,0x7c,\n    0xbe,0x57,0x19,0x32,0x7e,0x2a,0xd0,0xb8,0xba,0x29,0x00,0x3c,0x52,0x7d,0xa8,0x49,\n    0x3b,0x2d,0xeb,0x25,0x49,0xfa,0xa3,0xaa,0x39,0xa7,0xc5,0xa7,0x50,0x11,0x36,0xfb,\n    0xc6,0x67,0x4a,0xf5,0xa5,0x12,0x65,0x7e,0xb0,0xdf,0xaf,0x4e,0xb3,0x61,0x7f,0x2f } };\n  unsigned offset=0, entries, tag, type, len, save, c;\n  unsigned ver97=0, serial=0, i, wbi=0, wb[4]={0,0,0,0};\n  uchar buf97[324], ci, cj, ck;\n  short morder, sorder=order;\n  char buf[10];\n/*\n   The MakerNote might have its own TIFF header (possibly with\n   its own byte-order!), or it might just be a table.\n */\n  if (!strcmp(make,\"Nokia\")) return;\n  fread (buf, 1, 10, ifp);\n  if (!strncmp (buf,\"KDK\" ,3) ||\t/* these aren't TIFF tables */\n      !strncmp (buf,\"VER\" ,3) ||\n      !strncmp (buf,\"IIII\",4) ||\n      !strncmp (buf,\"MMMM\",4)) return;\n  if (!strncmp (buf,\"KC\"  ,2) ||\t/* Konica KD-400Z, KD-510Z */\n      !strncmp (buf,\"MLY\" ,3)) {\t/* Minolta DiMAGE G series */\n    order = 0x4d4d;\n    while ((i=ftell(ifp)) < data_offset && i < 16384) {\n      wb[0] = wb[2];  wb[2] = wb[1];  wb[1] = wb[3];\n      wb[3] = get2();\n      if (wb[1] == 256 && wb[3] == 256 &&\n\t  wb[0] > 256 && wb[0] < 640 && wb[2] > 256 && wb[2] < 640)\n\tFORC4 cam_mul[c] = wb[c];\n    }\n    goto quit;\n  }\n  if (!strcmp (buf,\"Nikon\")) {\n    base = ftell(ifp);\n    order = get2();\n    if (get2() != 42) goto quit;\n    offset = get4();\n    fseek (ifp, offset-8, SEEK_CUR);\n  } else if (!strcmp (buf,\"OLYMPUS\")) {\n    base = ftell(ifp)-10;\n    fseek (ifp, -2, SEEK_CUR);\n    order = get2();  get2();\n  } else if (!strncmp (buf,\"SONY\",4) ||\n\t     !strcmp  (buf,\"Panasonic\")) {\n    goto nf;\n  } else if (!strncmp (buf,\"FUJIFILM\",8)) {\n    base = ftell(ifp)-10;\nnf: order = 0x4949;\n    fseek (ifp,  2, SEEK_CUR);\n  } else if (!strcmp (buf,\"OLYMP\") ||\n\t     !strcmp (buf,\"LEICA\") ||\n\t     !strcmp (buf,\"Ricoh\") ||\n\t     !strcmp (buf,\"EPSON\"))\n    fseek (ifp, -2, SEEK_CUR);\n  else if (!strcmp (buf,\"AOC\") ||\n\t   !strcmp (buf,\"QVC\"))\n    fseek (ifp, -4, SEEK_CUR);\n  else {\n    fseek (ifp, -10, SEEK_CUR);\n    if (!strncmp(make,\"SAMSUNG\",7))\n      base = ftell(ifp);\n  }\n  entries = get2();\n  if (entries > 1000) return;\n  morder = order;\n  while (entries--) {\n    order = morder;\n    tiff_get (base, &tag, &type, &len, &save);\n    tag |= uptag << 16;\n    if (tag == 2 && strstr(make,\"NIKON\") && !iso_speed)\n      iso_speed = (get2(),get2());\n    if (tag == 4 && len > 26 && len < 35) {\n      if ((i=(get4(),get2())) != 0x7fff && !iso_speed)\n\tiso_speed = 50 * pow (2, i/32.0 - 4);\n      if ((i=(get2(),get2())) != 0x7fff && !aperture)\n\taperture = pow (2, i/64.0);\n      if ((i=get2()) != 0xffff && !shutter)\n\tshutter = pow (2, (short) i/-32.0);\n      wbi = (get2(),get2());\n      shot_order = (get2(),get2());\n    }\n    if ((tag == 4 || tag == 0x114) && !strncmp(make,\"KONICA\",6)) {\n      fseek (ifp, tag == 4 ? 140:160, SEEK_CUR);\n      switch (get2()) {\n\tcase 72:  flip = 0;  break;\n\tcase 76:  flip = 6;  break;\n\tcase 82:  flip = 5;  break;\n      }\n    }\n    if (tag == 7 && type == 2 && len > 20)\n      fgets (model2, 64, ifp);\n    if (tag == 8 && type == 4)\n      shot_order = get4();\n    if (tag == 9 && !strcmp(make,\"Canon\"))\n      fread (artist, 64, 1, ifp);\n    if (tag == 0xc && len == 4) {\n      cam_mul[0] = getreal(type);\n      cam_mul[2] = getreal(type);\n    }\n    if (tag == 0xd && type == 7 && get2() == 0xaaaa) {\n      for (c=i=2; (ushort) c != 0xbbbb && i < len; i++)\n\tc = c << 8 | fgetc(ifp);\n      while ((i+=4) < len-5)\n\tif (get4() == 257 && (i=len) && (c = (get4(),fgetc(ifp))) < 3)\n\t  flip = \"065\"[c]-'0';\n    }\n    if (tag == 0x10 && type == 4)\n      unique_id = get4();\n    if (tag == 0x11 && is_raw && !strncmp(make,\"NIKON\",5)) {\n      fseek (ifp, get4()+base, SEEK_SET);\n      parse_tiff_ifd (base);\n    }\n    if (tag == 0x14 && type == 7) {\n      if (len == 2560) {\n\tfseek (ifp, 1248, SEEK_CUR);\n\tgoto get2_256;\n      }\n      fread (buf, 1, 10, ifp);\n      if (!strncmp(buf,\"NRW \",4)) {\n\tfseek (ifp, strcmp(buf+4,\"0100\") ? 46:1546, SEEK_CUR);\n\tcam_mul[0] = get4() << 2;\n\tcam_mul[1] = get4() + get4();\n\tcam_mul[2] = get4() << 2;\n      }\n    }\n    if (tag == 0x15 && type == 2 && is_raw)\n      fread (model, 64, 1, ifp);\n    if (strstr(make,\"PENTAX\")) {\n      if (tag == 0x1b) tag = 0x1018;\n      if (tag == 0x1c) tag = 0x1017;\n    }\n    if (tag == 0x1d)\n      while ((c = fgetc(ifp)) && c != EOF)\n\tserial = serial*10 + (isdigit(c) ? c - '0' : c % 10);\n    if (tag == 0x81 && type == 4) {\n      data_offset = get4();\n      fseek (ifp, data_offset + 41, SEEK_SET);\n      raw_height = get2() * 2;\n      raw_width  = get2();\n      filters = 0x61616161;\n    }\n    if (tag == 0x29 && type == 1) {\n      c = wbi < 18 ? \"012347800000005896\"[wbi]-'0' : 0;\n      fseek (ifp, 8 + c*32, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get4();\n    }\n    if ((tag == 0x81  && type == 7) ||\n\t(tag == 0x100 && type == 7) ||\n\t(tag == 0x280 && type == 1)) {\n      thumb_offset = ftell(ifp);\n      thumb_length = len;\n    }\n    if (tag == 0x88 && type == 4 && (thumb_offset = get4()))\n      thumb_offset += base;\n    if (tag == 0x89 && type == 4)\n      thumb_length = get4();\n    if (tag == 0x8c || tag == 0x96)\n      meta_offset = ftell(ifp);\n    if (tag == 0x97) {\n      for (i=0; i < 4; i++)\n\tver97 = ver97 * 10 + fgetc(ifp)-'0';\n      switch (ver97) {\n\tcase 100:\n\t  fseek (ifp, 68, SEEK_CUR);\n\t  FORC4 cam_mul[(c >> 1) | ((c & 1) << 1)] = get2();\n\t  break;\n\tcase 102:\n\t  fseek (ifp, 6, SEEK_CUR);\n\t  goto get2_rggb;\n\tcase 103:\n\t  fseek (ifp, 16, SEEK_CUR);\n\t  FORC4 cam_mul[c] = get2();\n      }\n      if (ver97 >= 200) {\n\tif (ver97 != 205) fseek (ifp, 280, SEEK_CUR);\n\tfread (buf97, 324, 1, ifp);\n      }\n    }\n    if (tag == 0xa1 && type == 7) {\n      order = 0x4949;\n      fseek (ifp, 140, SEEK_CUR);\n      FORC3 cam_mul[c] = get4();\n    }\n    if (tag == 0xa4 && type == 3) {\n      fseek (ifp, wbi*48, SEEK_CUR);\n      FORC3 cam_mul[c] = get2();\n    }\n    if (tag == 0xa7 && (unsigned) (ver97-200) < 17) {\n      ci = xlat[0][serial & 0xff];\n      cj = xlat[1][fgetc(ifp)^fgetc(ifp)^fgetc(ifp)^fgetc(ifp)];\n      ck = 0x60;\n      for (i=0; i < 324; i++)\n\tbuf97[i] ^= (cj += ci * ck++);\n      i = \"66666>666;6A;:;55\"[ver97-200] - '0';\n      FORC4 cam_mul[c ^ (c >> 1) ^ (i & 1)] =\n\tsget2 (buf97 + (i & -2) + c*2);\n    }\n    if (tag == 0x200 && len == 3)\n      shot_order = (get4(),get4());\n    if (tag == 0x200 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2();\n    if (tag == 0x201 && len == 4)\n      goto get2_rggb;\n    if (tag == 0x220 && type == 7)\n      meta_offset = ftell(ifp);\n    if (tag == 0x401 && type == 4 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get4();\n    if (tag == 0xe01) {\t\t/* Nikon Capture Note */\n      order = 0x4949;\n      fseek (ifp, 22, SEEK_CUR);\n      for (offset=22; offset+22 < len; offset += 22+i) {\n\ttag = get4();\n\tfseek (ifp, 14, SEEK_CUR);\n\ti = get4()-4;\n\tif (tag == 0x76a43207) flip = get2();\n\telse fseek (ifp, i, SEEK_CUR);\n      }\n    }\n    if (tag == 0xe80 && len == 256 && type == 7) {\n      fseek (ifp, 48, SEEK_CUR);\n      cam_mul[0] = get2() * 508 * 1.078 / 0x10000;\n      cam_mul[2] = get2() * 382 * 1.173 / 0x10000;\n    }\n    if (tag == 0xf00 && type == 7) {\n      if (len == 614)\n\tfseek (ifp, 176, SEEK_CUR);\n      else if (len == 734 || len == 1502)\n\tfseek (ifp, 148, SEEK_CUR);\n      else goto next;\n      goto get2_256;\n    }\n    if ((tag == 0x1011 && len == 9) || tag == 0x20400200)\n      for (i=0; i < 3; i++)\n\tFORC3 cmatrix[i][c] = ((short) get2()) / 256.0;\n    if ((tag == 0x1012 || tag == 0x20400600) && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2();\n    if (tag == 0x1017 || tag == 0x20400100)\n      cam_mul[0] = get2() / 256.0;\n    if (tag == 0x1018 || tag == 0x20400100)\n      cam_mul[2] = get2() / 256.0;\n    if (tag == 0x2011 && len == 2) {\nget2_256:\n      order = 0x4d4d;\n      cam_mul[0] = get2() / 256.0;\n      cam_mul[2] = get2() / 256.0;\n    }\n    if ((tag | 0x70) == 0x2070 && type == 4)\n      fseek (ifp, get4()+base, SEEK_SET);\n    if (tag == 0x2010 && type != 7)\n      load_raw = &CLASS olympus_load_raw;\n    if (tag == 0x2020)\n      parse_thumb_note (base, 257, 258);\n    if (tag == 0x2040)\n      parse_makernote (base, 0x2040);\n    if (tag == 0xb028) {\n      fseek (ifp, get4()+base, SEEK_SET);\n      parse_thumb_note (base, 136, 137);\n    }\n    if (tag == 0x4001 && len > 500) {\n      i = len == 582 ? 50 : len == 653 ? 68 : len == 5120 ? 142 : 126;\n      fseek (ifp, i, SEEK_CUR);\nget2_rggb:\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n      i = len >> 3 == 164 ? 112:22;\n      fseek (ifp, i, SEEK_CUR);\n      FORC4 sraw_mul[c ^ (c >> 1)] = get2();\n    }\n    if (tag == 0xa021)\n      FORC4 cam_mul[c ^ (c >> 1)] = get4();\n    if (tag == 0xa028)\n      FORC4 cam_mul[c ^ (c >> 1)] -= get4();\nnext:\n    fseek (ifp, save, SEEK_SET);\n  }\nquit:\n  order = sorder;\n}\n\n/*\n   Since the TIFF DateTime string has no timezone information,\n   assume that the camera's clock was set to Universal Time.\n */\nvoid CLASS get_timestamp (int reversed)\n{\n  struct tm t;\n  char str[20];\n  int i;\n\n  str[19] = 0;\n  if (reversed)\n    for (i=19; i--; ) str[i] = fgetc(ifp);\n  else\n    fread (str, 19, 1, ifp);\n  memset (&t, 0, sizeof t);\n  if (sscanf (str, \"%d:%d:%d %d:%d:%d\", &t.tm_year, &t.tm_mon,\n\t&t.tm_mday, &t.tm_hour, &t.tm_min, &t.tm_sec) != 6)\n    return;\n  t.tm_year -= 1900;\n  t.tm_mon -= 1;\n  t.tm_isdst = -1;\n  if (mktime(&t) > 0)\n    timestamp = mktime(&t);\n}\n\nvoid CLASS parse_exif (int base)\n{\n  unsigned kodak, entries, tag, type, len, save, c;\n  double expo;\n\n  kodak = !strncmp(make,\"EASTMAN\",7) && tiff_nifds < 3;\n  entries = get2();\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    switch (tag) {\n      case 33434:  shutter = getreal(type);\t\tbreak;\n      case 33437:  aperture = getreal(type);\t\tbreak;\n      case 34855:  iso_speed = get2();\t\t\tbreak;\n      case 36867:\n      case 36868:  get_timestamp(0);\t\t\tbreak;\n      case 37377:  if ((expo = -getreal(type)) < 128)\n\t\t     shutter = pow (2, expo);\t\tbreak;\n      case 37378:  aperture = pow (2, getreal(type)/2);\tbreak;\n      case 37386:  focal_len = getreal(type);\t\tbreak;\n      case 37500:  parse_makernote (base, 0);\t\tbreak;\n      case 40962:  if (kodak) raw_width  = get4();\tbreak;\n      case 40963:  if (kodak) raw_height = get4();\tbreak;\n      case 41730:\n\tif (get4() == 0x20002)\n\t  for (exif_cfa=c=0; c < 8; c+=2)\n\t    exif_cfa |= fgetc(ifp) * 0x01010101 << c;\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS parse_gps (int base)\n{\n  unsigned entries, tag, type, len, save, c;\n\n  entries = get2();\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    switch (tag) {\n      case 1: case 3: case 5:\n\tgpsdata[29+tag/2] = getc(ifp);\t\t\tbreak;\n      case 2: case 4: case 7:\n\tFORC(6) gpsdata[tag/3*6+c] = get4();\t\tbreak;\n      case 6:\n\tFORC(2) gpsdata[18+c] = get4();\t\t\tbreak;\n      case 18: case 29:\n\tfgets ((char *) (gpsdata+14+tag/3), MIN(len,12), ifp);\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS romm_coeff (float romm_cam[3][3])\n{\n  static const float rgb_romm[3][3] =\t/* ROMM == Kodak ProPhoto */\n  { {  2.034193, -0.727420, -0.306766 },\n    { -0.228811,  1.231729, -0.002922 },\n    { -0.008565, -0.153273,  1.161839 } };\n  int i, j, k;\n\n  for (i=0; i < 3; i++)\n    for (j=0; j < 3; j++)\n      for (cmatrix[i][j] = k=0; k < 3; k++)\n\tcmatrix[i][j] += rgb_romm[i][k] * romm_cam[k][j];\n}\n\nvoid CLASS parse_mos (int offset)\n{\n  char data[40];\n  int skip, from, i, c, neut[4], planes=0, frot=0;\n  static const char *mod[] =\n  { \"\",\"DCB2\",\"Volare\",\"Cantare\",\"CMost\",\"Valeo 6\",\"Valeo 11\",\"Valeo 22\",\n    \"Valeo 11p\",\"Valeo 17\",\"\",\"Aptus 17\",\"Aptus 22\",\"Aptus 75\",\"Aptus 65\",\n    \"Aptus 54S\",\"Aptus 65S\",\"Aptus 75S\",\"AFi 5\",\"AFi 6\",\"AFi 7\",\n    \"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"AFi-II 12\" };\n  float romm_cam[3][3];\n\n  fseek (ifp, offset, SEEK_SET);\n  while (1) {\n    if (get4() != 0x504b5453) break;\n    get4();\n    fread (data, 1, 40, ifp);\n    skip = get4();\n    from = ftell(ifp);\n    if (!strcmp(data,\"JPEG_preview_data\")) {\n      thumb_offset = from;\n      thumb_length = skip;\n    }\n    if (!strcmp(data,\"icc_camera_profile\")) {\n      profile_offset = from;\n      profile_length = skip;\n    }\n    if (!strcmp(data,\"ShootObj_back_type\")) {\n      fscanf (ifp, \"%d\", &i);\n      if ((unsigned) i < sizeof mod / sizeof (*mod))\n\tstrcpy (model, mod[i]);\n    }\n    if (!strcmp(data,\"icc_camera_to_tone_matrix\")) {\n      for (i=0; i < 9; i++)\n\tromm_cam[0][i] = int_to_float(get4());\n      romm_coeff (romm_cam);\n    }\n    if (!strcmp(data,\"CaptProf_color_matrix\")) {\n      for (i=0; i < 9; i++)\n\tfscanf (ifp, \"%f\", &romm_cam[0][i]);\n      romm_coeff (romm_cam);\n    }\n    if (!strcmp(data,\"CaptProf_number_of_planes\"))\n      fscanf (ifp, \"%d\", &planes);\n    if (!strcmp(data,\"CaptProf_raw_data_rotation\"))\n      fscanf (ifp, \"%d\", &flip);\n    if (!strcmp(data,\"CaptProf_mosaic_pattern\"))\n      FORC4 {\n\tfscanf (ifp, \"%d\", &i);\n\tif (i == 1) frot = c ^ (c >> 1);\n      }\n    if (!strcmp(data,\"ImgProf_rotation_angle\")) {\n      fscanf (ifp, \"%d\", &i);\n      flip = i - flip;\n    }\n    if (!strcmp(data,\"NeutObj_neutrals\") && !cam_mul[0]) {\n      FORC4 fscanf (ifp, \"%d\", neut+c);\n      FORC3 cam_mul[c] = (float) neut[0] / neut[c+1];\n    }\n    if (!strcmp(data,\"Rows_data\"))\n      load_flags = get4();\n    parse_mos (from);\n    fseek (ifp, skip+from, SEEK_SET);\n  }\n  if (planes)\n    filters = (planes == 1) * 0x01010101 *\n\t(uchar) \"\\x94\\x61\\x16\\x49\"[(flip/90 + frot) & 3];\n}\n\nvoid CLASS linear_table (unsigned len)\n{\n  int i;\n  if (len > 0x1000) len = 0x1000;\n  read_shorts (curve, len);\n  for (i=len; i < 0x1000; i++)\n    curve[i] = curve[i-1];\n  maximum = curve[0xfff];\n}\n\nvoid CLASS parse_kodak_ifd (int base)\n{\n  unsigned entries, tag, type, len, save;\n  int i, c, wbi=-2, wbtemp=6500;\n  float mul[3]={1,1,1}, num;\n  static const int wbtag[] = { 64037,64040,64039,64041,-1,-1,64042 };\n\n  entries = get2();\n  if (entries > 1024) return;\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    if (tag == 1020) wbi = getint(type);\n    if (tag == 1021 && len == 72) {\t\t/* WB set in software */\n      fseek (ifp, 40, SEEK_CUR);\n      FORC3 cam_mul[c] = 2048.0 / get2();\n      wbi = -2;\n    }\n    if (tag == 2118) wbtemp = getint(type);\n    if (tag == 2130 + wbi)\n      FORC3 mul[c] = getreal(type);\n    if (tag == 2140 + wbi && wbi >= 0)\n      FORC3 {\n\tfor (num=i=0; i < 4; i++)\n\t  num += getreal(type) * pow (wbtemp/100.0, i);\n\tcam_mul[c] = 2048 / (num * mul[c]);\n      }\n    if (tag == 2317) linear_table (len);\n    if (tag == 6020) iso_speed = getint(type);\n    if (tag == 64013) wbi = fgetc(ifp);\n    if ((unsigned) wbi < 7 && tag == wbtag[wbi])\n      FORC3 cam_mul[c] = get4();\n    if (tag == 64019) width = getint(type);\n    if (tag == 64020) height = (getint(type)+1) & -2;\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n//@end COMMON\n\nvoid CLASS parse_minolta (int base);\nint CLASS parse_tiff (int base);\n\n//@out COMMON\nint CLASS parse_tiff_ifd (int base)\n{\n  unsigned entries, tag, type, len, plen=16, save;\n  int ifd, use_cm=0, cfa, i, j, c, ima_len=0;\n  int blrr=1, blrc=1, dblack[] = { 0,0,0,0 };\n  char software[64], *cbuf, *cp;\n  uchar cfa_pat[16], cfa_pc[] = { 0,1,2,3 }, tab[256];\n  double cc[4][4], cm[4][3], cam_xyz[4][3], num;\n  double ab[]={ 1,1,1,1 }, asn[] = { 0,0,0,0 }, xyz[] = { 1,1,1 };\n  unsigned sony_curve[] = { 0,0,0,0,0,4095 };\n  unsigned *buf, sony_offset=0, sony_length=0, sony_key=0;\n  struct jhead jh;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *sfp;\n#endif\n\n  if (tiff_nifds >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n    return 1;\n  ifd = tiff_nifds++;\n  for (j=0; j < 4; j++)\n    for (i=0; i < 4; i++)\n      cc[j][i] = i == j;\n  entries = get2();\n  if (entries > 512) return 1;\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    switch (tag) {\n      case 5:   width  = get2();  break;\n      case 6:   height = get2();  break;\n      case 7:   width += get2();  break;\n      case 9:  filters = get2();  break;\n      case 17: case 18:\n\tif (type == 3 && len == 1)\n\t  cam_mul[(tag-17)*2] = get2() / 256.0;\n\tbreak;\n      case 23:\n\tif (type == 3) iso_speed = get2();\n\tbreak;\n      case 36: case 37: case 38:\n\tcam_mul[tag-0x24] = get2();\n\tbreak;\n      case 39:\n\tif (len < 50 || cam_mul[0]) break;\n\tfseek (ifp, 12, SEEK_CUR);\n\tFORC3 cam_mul[c] = get2();\n\tbreak;\n      case 46:\n\tif (type != 7 || fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8) break;\n\tthumb_offset = ftell(ifp) - 2;\n\tthumb_length = len;\n\tbreak;\n      case 61440:\t\t\t/* Fuji HS10 table */\n\tparse_tiff_ifd (base);\n\tbreak;\n      case 2: case 256: case 61441:\t/* ImageWidth */\n\ttiff_ifd[ifd].t_width = getint(type);\n\tbreak;\n      case 3: case 257: case 61442:\t/* ImageHeight */\n\ttiff_ifd[ifd].t_height = getint(type);\n\tbreak;\n      case 258:\t\t\t\t/* BitsPerSample */\n      case 61443:\n\ttiff_ifd[ifd].samples = len & 7;\n\ttiff_ifd[ifd].bps = getint(type);\n\tbreak;\n      case 61446:\n\traw_height = 0;\n\tload_raw = &CLASS packed_load_raw;\n\tload_flags = get4() && (filters=0x16161616) ? 24:80;\n\tbreak;\n      case 259:\t\t\t\t/* Compression */\n\ttiff_ifd[ifd].comp = getint(type);\n\tbreak;\n      case 262:\t\t\t\t/* PhotometricInterpretation */\n\ttiff_ifd[ifd].phint = get2();\n\tbreak;\n      case 270:\t\t\t\t/* ImageDescription */\n\tfread (desc, 512, 1, ifp);\n\tbreak;\n      case 271:\t\t\t\t/* Make */\n\tfgets (make, 64, ifp);\n\tbreak;\n      case 272:\t\t\t\t/* Model */\n\tfgets (model, 64, ifp);\n\tbreak;\n      case 280:\t\t\t\t/* Panasonic RW2 offset */\n\tif (type != 4) break;\n\tload_raw = &CLASS panasonic_load_raw;\n\tload_flags = 0x2008;\n      case 273:\t\t\t\t/* StripOffset */\n      case 513:\t\t\t\t/* JpegIFOffset */\n      case 61447:\n\ttiff_ifd[ifd].offset = get4()+base;\n\tif (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0) {\n\t  fseek (ifp, tiff_ifd[ifd].offset, SEEK_SET);\n\t  if (ljpeg_start (&jh, 1)) {\n\t    tiff_ifd[ifd].comp    = 6;\n\t    tiff_ifd[ifd].t_width   = jh.wide;\n\t    tiff_ifd[ifd].t_height  = jh.high;\n\t    tiff_ifd[ifd].bps     = jh.bits;\n\t    tiff_ifd[ifd].samples = jh.clrs;\n\t    if (!(jh.sraw || (jh.clrs & 1)))\n\t      tiff_ifd[ifd].t_width *= jh.clrs;\n\t    i = order;\n\t    parse_tiff (tiff_ifd[ifd].offset + 12);\n\t    order = i;\n\t  }\n\t}\n\tbreak;\n      case 274:\t\t\t\t/* Orientation */\n\ttiff_ifd[ifd].t_flip = \"50132467\"[get2() & 7]-'0';\n\tbreak;\n      case 277:\t\t\t\t/* SamplesPerPixel */\n\ttiff_ifd[ifd].samples = getint(type) & 7;\n\tbreak;\n      case 279:\t\t\t\t/* StripByteCounts */\n      case 514:\n      case 61448:\n\ttiff_ifd[ifd].bytes = get4();\n\tbreak;\n      case 61454:\n\tFORC3 cam_mul[(4-c) % 3] = getint(type);\n\tbreak;\n      case 305:  case 11:\t\t/* Software */\n\tfgets (software, 64, ifp);\n\tif (!strncmp(software,\"Adobe\",5) ||\n\t    !strncmp(software,\"dcraw\",5) ||\n\t    !strncmp(software,\"UFRaw\",5) ||\n\t    !strncmp(software,\"Bibble\",6) ||\n\t    !strncmp(software,\"Nikon Scan\",10) ||\n\t    !strcmp (software,\"Digital Photo Professional\"))\n\t  is_raw = 0;\n\tbreak;\n      case 306:\t\t\t\t/* DateTime */\n\tget_timestamp(0);\n\tbreak;\n      case 315:\t\t\t\t/* Artist */\n\tfread (artist, 64, 1, ifp);\n\tbreak;\n      case 322:\t\t\t\t/* TileWidth */\n\ttiff_ifd[ifd].t_tile_width = getint(type);\n\tbreak;\n      case 323:\t\t\t\t/* TileLength */\n\ttiff_ifd[ifd].t_tile_length = getint(type);\n\tbreak;\n      case 324:\t\t\t\t/* TileOffsets */\n\ttiff_ifd[ifd].offset = len > 1 ? ftell(ifp) : get4();\n\tif (len == 4) {\n\t  load_raw = &CLASS sinar_4shot_load_raw;\n\t  is_raw = 5;\n\t}\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 325:\t\t\t\t/* TileByteCount */\n          tiff_ifd[ifd].tile_maxbytes = 0;\n          for(int jj=0;jj<len;jj++)\n              {\n                  int s = get4();\n                  if(s > tiff_ifd[ifd].tile_maxbytes) tiff_ifd[ifd].tile_maxbytes=s;\n              }\n\tbreak;\n#endif\n      case 330:\t\t\t\t/* SubIFDs */\n\tif (!strcmp(model,\"DSLR-A100\") && tiff_ifd[ifd].t_width == 3872) {\n\t  load_raw = &CLASS sony_arw_load_raw;\n\t  data_offset = get4()+base;\n\t  ifd++;  break;\n\t}\n\twhile (len--) {\n\t  i = ftell(ifp);\n\t  fseek (ifp, get4()+base, SEEK_SET);\n\t  if (parse_tiff_ifd (base)) break;\n\t  fseek (ifp, i+4, SEEK_SET);\n\t}\n\tbreak;\n      case 400:\n\tstrcpy (make, \"Sarnoff\");\n\tmaximum = 0xfff;\n\tbreak;\n      case 28688:\n\tFORC4 sony_curve[c+1] = get2() >> 2 & 0xfff;\n\tfor (i=0; i < 5; i++)\n\t  for (j = sony_curve[i]+1; j <= sony_curve[i+1]; j++)\n\t    curve[j] = curve[j-1] + (1 << i);\n\tbreak;\n      case 29184: sony_offset = get4();  break;\n      case 29185: sony_length = get4();  break;\n      case 29217: sony_key    = get4();  break;\n      case 29264:\n\tparse_minolta (ftell(ifp));\n\traw_width = 0;\n\tbreak;\n      case 29443:\n\tFORC4 cam_mul[c ^ (c < 2)] = get2();\n\tbreak;\n      case 29459:\n\tFORC4 cam_mul[c] = get2();\n\ti = (cam_mul[1] == 1024 && cam_mul[2] == 1024) << 1;\n\tSWAP (cam_mul[i],cam_mul[i+1])\n\tbreak;\n      case 33405:\t\t\t/* Model2 */\n\tfgets (model2, 64, ifp);\n\tbreak;\n      case 33422:\t\t\t/* CFAPattern */\n      case 64777:\t\t\t/* Kodak P-series */\n\tif ((plen=len) > 16) plen = 16;\n\tfread (cfa_pat, 1, plen, ifp);\n\tfor (colors=cfa=i=0; i < plen; i++) {\n\t  colors += !(cfa & (1 << cfa_pat[i]));\n\t  cfa |= 1 << cfa_pat[i];\n\t}\n\tif (cfa == 070) memcpy (cfa_pc,\"\\003\\004\\005\",3);\t/* CMY */\n\tif (cfa == 072) memcpy (cfa_pc,\"\\005\\003\\004\\001\",4);\t/* GMCY */\n\tgoto guess_cfa_pc;\n      case 33424:\n      case 65024:\n\tfseek (ifp, get4()+base, SEEK_SET);\n\tparse_kodak_ifd (base);\n\tbreak;\n      case 33434:\t\t\t/* ExposureTime */\n\tshutter = getreal(type);\n\tbreak;\n      case 33437:\t\t\t/* FNumber */\n\taperture = getreal(type);\n\tbreak;\n      case 34306:\t\t\t/* Leaf white balance */\n\tFORC4 cam_mul[c ^ 1] = 4096.0 / get2();\n\tbreak;\n      case 34307:\t\t\t/* Leaf CatchLight color matrix */\n\tfread (software, 1, 7, ifp);\n\tif (strncmp(software,\"MATRIX\",6)) break;\n\tcolors = 4;\n\tfor (raw_color = i=0; i < 3; i++) {\n\t  FORC4 fscanf (ifp, \"%f\", &rgb_cam[i][c^1]);\n\t  if (!use_camera_wb) continue;\n\t  num = 0;\n\t  FORC4 num += rgb_cam[i][c];\n\t  FORC4 rgb_cam[i][c] /= num;\n\t}\n\tbreak;\n      case 34310:\t\t\t/* Leaf metadata */\n\tparse_mos (ftell(ifp));\n      case 34303:\n\tstrcpy (make, \"Leaf\");\n\tbreak;\n      case 34665:\t\t\t/* EXIF tag */\n\tfseek (ifp, get4()+base, SEEK_SET);\n\tparse_exif (base);\n\tbreak;\n      case 34853:\t\t\t/* GPSInfo tag */\n\tfseek (ifp, get4()+base, SEEK_SET);\n\tparse_gps (base);\n\tbreak;\n      case 34675:\t\t\t/* InterColorProfile */\n      case 50831:\t\t\t/* AsShotICCProfile */\n\tprofile_offset = ftell(ifp);\n\tprofile_length = len;\n\tbreak;\n      case 37122:\t\t\t/* CompressedBitsPerPixel */\n\tkodak_cbpp = get4();\n\tbreak;\n      case 37386:\t\t\t/* FocalLength */\n\tfocal_len = getreal(type);\n\tbreak;\n      case 37393:\t\t\t/* ImageNumber */\n\tshot_order = getint(type);\n\tbreak;\n      case 37400:\t\t\t/* old Kodak KDC tag */\n\tfor (raw_color = i=0; i < 3; i++) {\n\t  getreal(type);\n\t  FORC3 rgb_cam[i][c] = getreal(type);\n\t}\n\tbreak;\n      case 46275:\t\t\t/* Imacon tags */\n\tstrcpy (make, \"Imacon\");\n\tdata_offset = ftell(ifp);\n\tima_len = len;\n\tbreak;\n      case 46279:\n\tif (!ima_len) break;\n\tfseek (ifp, 38, SEEK_CUR);\n      case 46274:\n\tfseek (ifp, 40, SEEK_CUR);\n\traw_width  = get4();\n\traw_height = get4();\n\tleft_margin = get4() & 7;\n\twidth = raw_width - left_margin - (get4() & 7);\n\ttop_margin = get4() & 7;\n\theight = raw_height - top_margin - (get4() & 7);\n\tif (raw_width == 7262 && ima_len == 234317952 ) {\n\t  height = 5412;\n\t  width  = 7216;\n\t  left_margin = 7;\n          filters=0;\n\t} else \tif (raw_width == 7262) {\n\t  height = 5444;\n\t  width  = 7244;\n\t  left_margin = 7;\n\t}\n\tfseek (ifp, 52, SEEK_CUR);\n\tFORC3 cam_mul[c] = getreal(11);\n\tfseek (ifp, 114, SEEK_CUR);\n\tflip = (get2() >> 7) * 90;\n\tif (width * height * 6 == ima_len) {\n\t  if (flip % 180 == 90) SWAP(width,height);\n\t  raw_width = width;\n\t  raw_height = height;\n\t  left_margin = top_margin = filters = flip = 0;\n\t}\n\tsprintf (model, \"Ixpress %d-Mp\", height*width/1000000);\n\tload_raw = &CLASS imacon_full_load_raw;\n\tif (filters) {\n\t  if (left_margin & 1) filters = 0x61616161;\n\t  load_raw = &CLASS unpacked_load_raw;\n\t}\n\tmaximum = 0xffff;\n\tbreak;\n      case 50454:\t\t\t/* Sinar tag */\n      case 50455:\n\tif (!(cbuf = (char *) malloc(len))) break;\n\tfread (cbuf, 1, len, ifp);\n\tfor (cp = cbuf-1; cp && cp < cbuf+len; cp = strchr(cp,'\\n'))\n\t  if (!strncmp (++cp,\"Neutral \",8))\n\t    sscanf (cp+8, \"%f %f %f\", cam_mul, cam_mul+1, cam_mul+2);\n\tfree (cbuf);\n\tbreak;\n      case 50458:\n\tif (!make[0]) strcpy (make, \"Hasselblad\");\n\tbreak;\n      case 50459:\t\t\t/* Hasselblad tag */\n\ti = order;\n\tj = ftell(ifp);\n\tc = tiff_nifds;\n\torder = get2();\n\tfseek (ifp, j+(get2(),get4()), SEEK_SET);\n\tparse_tiff_ifd (j);\n\tmaximum = 0xffff;\n\ttiff_nifds = c;\n\torder = i;\n\tbreak;\n      case 50706:\t\t\t/* DNGVersion */\n\tFORC4 dng_version = (dng_version << 8) + fgetc(ifp);\n\tif (!make[0]) strcpy (make, \"DNG\");\n\tis_raw = 1;\n\tbreak;\n      case 50710:\t\t\t/* CFAPlaneColor */\n\tif (len > 4) len = 4;\n\tcolors = len;\n\tfread (cfa_pc, 1, colors, ifp);\nguess_cfa_pc:\n\tFORCC tab[cfa_pc[c]] = c;\n\tcdesc[c] = 0;\n\tfor (i=16; i--; )\n\t  filters = filters << 2 | tab[cfa_pat[i % plen]];\n\tbreak;\n      case 50711:\t\t\t/* CFALayout */\n\tif (get2() == 2) {\n\t  fuji_width = 1;\n\t  filters = 0x49494949;\n\t}\n\tbreak;\n      case 291:\n      case 50712:\t\t\t/* LinearizationTable */\n\tlinear_table (len);\n\tbreak;\n      case 50713:\t\t\t/* BlackLevelRepeatDim */\n\tblrr = get2();\n\tblrc = get2();\n\tbreak;\n      case 61450:\n\tblrr = blrc = 2;\n      case 50714:\t\t\t/* BlackLevel */\n\tblack = getreal(type);\n\tif (!filters || !~filters) break;\n\tdblack[0] = black;\n\tdblack[1] = (blrc == 2) ? getreal(type):dblack[0];\n\tdblack[2] = (blrr == 2) ? getreal(type):dblack[0];\n\tdblack[3] = (blrc == 2 && blrr == 2) ? getreal(type):dblack[1];\n\tif (colors == 3)\n\t  filters |= ((filters >> 2 & 0x22222222) |\n\t\t      (filters << 2 & 0x88888888)) & filters << 1;\n\tFORC4 cblack[filters >> (c << 1) & 3] = dblack[c];\n\tblack = 0;\n\tbreak;\n      case 50715:\t\t\t/* BlackLevelDeltaH */\n      case 50716:\t\t\t/* BlackLevelDeltaV */\n\tfor (num=i=0; i < len; i++)\n\t  num += getreal(type);\n\tblack += num/len + 0.5;\n\tbreak;\n      case 50717:\t\t\t/* WhiteLevel */\n\tmaximum = getint(type);\n\tbreak;\n      case 50718:\t\t\t/* DefaultScale */\n\tpixel_aspect  = getreal(type);\n\tpixel_aspect /= getreal(type);\n\tbreak;\n      case 50721:\t\t\t/* ColorMatrix1 */\n      case 50722:\t\t\t/* ColorMatrix2 */\n\tFORCC for (j=0; j < 3; j++)\n\t  cm[c][j] = getreal(type);\n\tuse_cm = 1;\n\tbreak;\n      case 50723:\t\t\t/* CameraCalibration1 */\n      case 50724:\t\t\t/* CameraCalibration2 */\n\tfor (i=0; i < colors; i++)\n\t  FORCC cc[i][c] = getreal(type);\n\tbreak;\n      case 50727:\t\t\t/* AnalogBalance */\n\tFORCC ab[c] = getreal(type);\n\tbreak;\n      case 50728:\t\t\t/* AsShotNeutral */\n\tFORCC asn[c] = getreal(type);\n\tbreak;\n      case 50729:\t\t\t/* AsShotWhiteXY */\n\txyz[0] = getreal(type);\n\txyz[1] = getreal(type);\n\txyz[2] = 1 - xyz[0] - xyz[1];\n\tFORC3 xyz[c] /= d65_white[c];\n\tbreak;\n      case 50740:\t\t\t/* DNGPrivateData */\n\tif (dng_version) break;\n\tparse_minolta (j = get4()+base);\n\tfseek (ifp, j, SEEK_SET);\n\tparse_tiff_ifd (base);\n\tbreak;\n      case 50752:\n\tread_shorts (cr2_slice, 3);\n\tbreak;\n      case 50829:\t\t\t/* ActiveArea */\n\ttop_margin = getint(type);\n\tleft_margin = getint(type);\n\theight = getint(type) - top_margin;\n\twidth = getint(type) - left_margin;\n\tbreak;\n      case 50830:\t\t\t/* MaskedAreas */\n        for (i=0; i < len && i < 32; i++)\n\t  mask[0][i] = getint(type);\n\tblack = 0;\n\tbreak;\n      case 51009:\t\t\t/* OpcodeList2 */\n\tmeta_offset = ftell(ifp);\n\tbreak;\n      case 64772:\t\t\t/* Kodak P-series */\n\tif (len < 13) break;\n\tfseek (ifp, 16, SEEK_CUR);\n\tdata_offset = get4();\n\tfseek (ifp, 28, SEEK_CUR);\n\tdata_offset += get4();\n\tload_raw = &CLASS packed_load_raw;\n\tbreak;\n      case 65026:\n\tif (type == 2) fgets (model2, 64, ifp);\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n  if (sony_length && (buf = (unsigned *) malloc(sony_length))) {\n    fseek (ifp, sony_offset, SEEK_SET);\n    fread (buf, sony_length, 1, ifp);\n    sony_decrypt (buf, sony_length/4, 1, sony_key);\n#ifndef LIBRAW_LIBRARY_BUILD\n    sfp = ifp;\n    if ((ifp = tmpfile())) {\n      fwrite (buf, sony_length, 1, ifp);\n      fseek (ifp, 0, SEEK_SET);\n      parse_tiff_ifd (-sony_offset);\n      fclose (ifp);\n    }\n    ifp = sfp;\n#else\n    if( !ifp->tempbuffer_open(buf,sony_length))\n        {\n            parse_tiff_ifd(-sony_offset);\n            ifp->tempbuffer_close();\n        }\n#endif\n    free (buf);\n  }\n  for (i=0; i < colors; i++)\n    FORCC cc[i][c] *= ab[i];\n  if (use_cm) {\n    FORCC for (i=0; i < 3; i++)\n      for (cam_xyz[c][i]=j=0; j < colors; j++)\n\tcam_xyz[c][i] += cc[c][j] * cm[j][i] * xyz[i];\n    cam_xyz_coeff (cam_xyz);\n  }\n  if (asn[0]) {\n    cam_mul[3] = 0;\n    FORCC cam_mul[c] = 1 / asn[c];\n  }\n  if (!use_cm)\n    FORCC pre_mul[c] /= cc[c][c];\n  return 0;\n}\n\nint CLASS parse_tiff (int base)\n{\n  int doff;\n\n  fseek (ifp, base, SEEK_SET);\n  order = get2();\n  if (order != 0x4949 && order != 0x4d4d) return 0;\n  get2();\n  while ((doff = get4())) {\n    fseek (ifp, doff+base, SEEK_SET);\n    if (parse_tiff_ifd (base)) break;\n  }\n  return 1;\n}\n\nvoid CLASS apply_tiff()\n{\n  int max_samp=0, raw=-1, thm=-1, i;\n  struct jhead jh;\n\n  thumb_misc = 16;\n  if (thumb_offset) {\n    fseek (ifp, thumb_offset, SEEK_SET);\n    if (ljpeg_start (&jh, 1)) {\n      thumb_misc   = jh.bits;\n      thumb_width  = jh.wide;\n      thumb_height = jh.high;\n    }\n  }\n  for (i=0; i < tiff_nifds; i++) {\n    if (max_samp < tiff_ifd[i].samples)\n\tmax_samp = tiff_ifd[i].samples;\n    if (max_samp > 3) max_samp = 3;\n    if ((tiff_ifd[i].comp != 6 || tiff_ifd[i].samples != 3) &&\n\t(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&\n\ttiff_ifd[i].t_width*tiff_ifd[i].t_height > raw_width*raw_height) {\n      raw_width     = tiff_ifd[i].t_width;\n      raw_height    = tiff_ifd[i].t_height;\n      tiff_bps      = tiff_ifd[i].bps;\n      tiff_compress = tiff_ifd[i].comp;\n      data_offset   = tiff_ifd[i].offset;\n      tiff_flip     = tiff_ifd[i].t_flip;\n      tiff_samples  = tiff_ifd[i].samples;\n      tile_width    = tiff_ifd[i].t_tile_width;\n      tile_length   = tiff_ifd[i].t_tile_length;\n#ifdef LIBRAW_LIBRARY_BUILD\n      data_size     = tile_length < INT_MAX && tile_length>0 ? tiff_ifd[i].tile_maxbytes: tiff_ifd[i].bytes;\n#endif\n      raw = i;\n    }\n  }\n  if (!tile_width ) tile_width  = INT_MAX;\n  if (!tile_length) tile_length = INT_MAX;\n  for (i=tiff_nifds; i--; )\n    if (tiff_ifd[i].t_flip) tiff_flip = tiff_ifd[i].t_flip;\n  if (raw >= 0 && !load_raw)\n    switch (tiff_compress) {\n      case 32767:\n\tif (tiff_ifd[raw].bytes == raw_width*raw_height) {\n\t  tiff_bps = 12;\n\t  load_raw = &CLASS sony_arw2_load_raw;\t\t\tbreak;\n\t}\n\tif (tiff_ifd[raw].bytes*8 != raw_width*raw_height*tiff_bps) {\n\t  raw_height += 8;\n\t  load_raw = &CLASS sony_arw_load_raw;\t\t\tbreak;\n\t}\n\tload_flags = 79;\n      case 32769:\n\tload_flags++;\n      case 32770:\n      case 32773: goto slr;\n      case 0:  case 1:\n\tif (tiff_ifd[raw].bytes*5 == raw_width*raw_height*8) {\n\t  load_flags = 81;\n\t  tiff_bps = 12;\n\t} slr:\n\tswitch (tiff_bps) {\n\t  case  8: load_raw = &CLASS eight_bit_load_raw;\tbreak;\n\t  case 12: if (tiff_ifd[raw].phint == 2)\n\t\t     load_flags = 6;\n\t\t   load_raw = &CLASS packed_load_raw;\t\tbreak;\n\t  case 14: load_flags = 0;\n\t  case 16: load_raw = &CLASS unpacked_load_raw;\t\tbreak;\n\t}\n\tbreak;\n      case 6:  case 7:  case 99:\n\tload_raw = &CLASS lossless_jpeg_load_raw;\t\tbreak;\n      case 262:\n\tload_raw = &CLASS kodak_262_load_raw;\t\t\tbreak;\n      case 34713:\n\tif ((raw_width+9)/10*16*raw_height == tiff_ifd[raw].bytes) {\n\t  load_raw = &CLASS packed_load_raw;\n\t  load_flags = 1;\n\t} else if (raw_width*raw_height*2 == tiff_ifd[raw].bytes) {\n\t  load_raw = &CLASS unpacked_load_raw;\n\t  load_flags = 4;\n\t  order = 0x4d4d;\n\t} else\n\t  load_raw = &CLASS nikon_load_raw;\t\t\tbreak;\n      case 34892:\n\tload_raw = &CLASS lossy_dng_load_raw;\t\t\tbreak;\n      case 65535:\n\tload_raw = &CLASS pentax_load_raw;\t\t\tbreak;\n      case 65000:\n\tswitch (tiff_ifd[raw].phint) {\n\t  case 2: load_raw = &CLASS kodak_rgb_load_raw;   filters = 0;  break;\n\t  case 6: load_raw = &CLASS kodak_ycbcr_load_raw; filters = 0;  break;\n\t  case 32803: load_raw = &CLASS kodak_65000_load_raw;\n\t}\n      case 32867: break;\n      default: is_raw = 0;\n    }\n  if (!dng_version)\n    if ( (tiff_samples == 3 && tiff_ifd[raw].bytes &&\n\t  tiff_bps != 14 && tiff_bps != 2048 && \n\t  tiff_compress != 32769 && tiff_compress != 32770)\n      || (tiff_bps == 8 && !strstr(make,\"KODAK\") && !strstr(make,\"Kodak\") &&\n\t  !strstr(model2,\"DEBUG RAW\")))\n      is_raw = 0;\n  for (i=0; i < tiff_nifds; i++)\n    if (i != raw && tiff_ifd[i].samples == max_samp &&\n\ttiff_ifd[i].t_width * tiff_ifd[i].t_height / SQR(tiff_ifd[i].bps+1) >\n\t      thumb_width *       thumb_height / SQR(thumb_misc+1)\n\t&& tiff_ifd[i].comp != 34892) {\n      thumb_width  = tiff_ifd[i].t_width;\n      thumb_height = tiff_ifd[i].t_height;\n      thumb_offset = tiff_ifd[i].offset;\n      thumb_length = tiff_ifd[i].bytes;\n      thumb_misc   = tiff_ifd[i].bps;\n      thm = i;\n    }\n  if (thm >= 0) {\n    thumb_misc |= tiff_ifd[thm].samples << 5;\n    switch (tiff_ifd[thm].comp) {\n      case 0:\n\twrite_thumb = &CLASS layer_thumb;\n\tbreak;\n      case 1:\n\tif (tiff_ifd[thm].bps <= 8)\n\t  write_thumb = &CLASS ppm_thumb;\n\telse if (!strcmp(make,\"Imacon\"))\n\t  write_thumb = &CLASS ppm16_thumb;\n\telse\n\t  thumb_load_raw = &CLASS kodak_thumb_load_raw;\n\tbreak;\n      case 65000:\n\tthumb_load_raw = tiff_ifd[thm].phint == 6 ?\n\t\t&CLASS kodak_ycbcr_load_raw : &CLASS kodak_rgb_load_raw;\n    }\n  }\n}\n\nvoid CLASS parse_minolta (int base)\n{\n  int save, tag, len, offset, high=0, wide=0, i, c;\n  short sorder=order;\n\n  fseek (ifp, base, SEEK_SET);\n  if (fgetc(ifp) || fgetc(ifp)-'M' || fgetc(ifp)-'R') return;\n  order = fgetc(ifp) * 0x101;\n  offset = base + get4() + 8;\n  while ((save=ftell(ifp)) < offset) {\n    for (tag=i=0; i < 4; i++)\n      tag = tag << 8 | fgetc(ifp);\n    len = get4();\n    switch (tag) {\n      case 0x505244:\t\t\t\t/* PRD */\n\tfseek (ifp, 8, SEEK_CUR);\n\thigh = get2();\n\twide = get2();\n\tbreak;\n      case 0x574247:\t\t\t\t/* WBG */\n\tget4();\n\ti = strcmp(model,\"DiMAGE A200\") ? 0:3;\n\tFORC4 cam_mul[c ^ (c >> 1) ^ i] = get2();\n\tbreak;\n      case 0x545457:\t\t\t\t/* TTW */\n\tparse_tiff (ftell(ifp));\n\tdata_offset = offset;\n    }\n    fseek (ifp, save+len+8, SEEK_SET);\n  }\n  raw_height = high;\n  raw_width  = wide;\n  order = sorder;\n}\n\n/*\n   Many cameras have a \"debug mode\" that writes JPEG and raw\n   at the same time.  The raw file has no header, so try to\n   to open the matching JPEG file and read its metadata.\n */\nvoid CLASS parse_external_jpeg()\n{\n  const char *file, *ext;\n  char *jname, *jfile, *jext;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *save=ifp;\n#else\n#if defined (WIN32) && !defined(__MINGW32__)\n  if(ifp->wfname())\n  {\n\t  std::wstring rawfile(ifp->wfname());\n\t  rawfile.replace(rawfile.length()-3,3,L\"JPG\");\n\t  if(!ifp->subfile_open(rawfile.c_str()))\n\t  {\n\t\t  parse_tiff (12);\n\t\t  thumb_offset = 0;\n\t\t  is_raw = 1;\n\t\t  ifp->subfile_close();\n\t  }\n\t  else\n\t\t  imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n\t return;\n  }\n#endif\n  if(!ifp->fname())\n      {\n          imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n          return;\n      }\n#endif\n\n  ext  = strrchr (ifname, '.');\n  file = strrchr (ifname, '/');\n  if (!file) file = strrchr (ifname, '\\\\');\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!file) file = ifname-1;\n#else\n  if (!file) file = (char*)ifname-1;\n#endif\n  file++;\n  if (!ext || strlen(ext) != 4 || ext-file != 8) return;\n  jname = (char *) malloc (strlen(ifname) + 1);\n  merror (jname, \"parse_external_jpeg()\");\n  strcpy (jname, ifname);\n  jfile = file - ifname + jname;\n  jext  = ext  - ifname + jname;\n  if (strcasecmp (ext, \".jpg\")) {\n    strcpy (jext, isupper(ext[1]) ? \".JPG\":\".jpg\");\n    if (isdigit(*file)) {\n      memcpy (jfile, file+4, 4);\n      memcpy (jfile+4, file, 4);\n    }\n  } else\n    while (isdigit(*--jext)) {\n      if (*jext != '9') {\n\t(*jext)++;\n\tbreak;\n      }\n      *jext = '0';\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (strcmp (jname, ifname)) {\n    if ((ifp = fopen (jname, \"rb\"))) {\n#ifdef DCRAW_VERBOSE\n      if (verbose)\n\tfprintf (stderr,_(\"Reading metadata from %s ...\\n\"), jname);\n#endif\n      parse_tiff (12);\n      thumb_offset = 0;\n      is_raw = 1;\n      fclose (ifp);\n    }\n  }\n#else\n  if (strcmp (jname, ifname)) \n      {\n          if(!ifp->subfile_open(jname))\n              {\n                  parse_tiff (12);\n                  thumb_offset = 0;\n                  is_raw = 1;\n                  ifp->subfile_close();\n              }\n          else\n              imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n      }\n#endif\n  if (!timestamp)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n#endif\n#ifdef DCRAW_VERBOSE\n          fprintf (stderr,_(\"Failed to read metadata from %s\\n\"), jname);\n#endif\n      }\n  free (jname);\n#ifndef LIBRAW_LIBRARY_BUILD\n  ifp = save;\n#endif\n}\n\n/*\n   CIFF block 0x1030 contains an 8x8 white sample.\n   Load this into white[][] for use in scale_colors().\n */\nvoid CLASS ciff_block_1030()\n{\n  static const ushort key[] = { 0x410, 0x45f3 };\n  int i, bpp, row, col, vbits=0;\n  unsigned long bitbuf=0;\n\n  if ((get2(),get4()) != 0x80008 || !get4()) return;\n  bpp = get2();\n  if (bpp != 10 && bpp != 12) return;\n  for (i=row=0; row < 8; row++)\n    for (col=0; col < 8; col++) {\n      if (vbits < bpp) {\n\tbitbuf = bitbuf << 16 | (get2() ^ key[i++ & 1]);\n\tvbits += 16;\n      }\n      white[row][col] =\n\tbitbuf << (LONG_BIT - vbits) >> (LONG_BIT - bpp);\n      vbits -= bpp;\n    }\n}\n\n/*\n   Parse a CIFF file, better known as Canon CRW format.\n */\nvoid CLASS parse_ciff (int offset, int length)\n{\n  int tboff, nrecs, c, type, len, save, wbi=-1;\n  ushort key[] = { 0x410, 0x45f3 };\n\n  fseek (ifp, offset+length-4, SEEK_SET);\n  tboff = get4() + offset;\n  fseek (ifp, tboff, SEEK_SET);\n  nrecs = get2();\n  if (nrecs > 100) return;\n  while (nrecs--) {\n    type = get2();\n    len  = get4();\n    save = ftell(ifp) + 4;\n    fseek (ifp, offset+get4(), SEEK_SET);\n    if ((((type >> 8) + 8) | 8) == 0x38)\n      parse_ciff (ftell(ifp), len);\t/* Parse a sub-table */\n\n    if (type == 0x0810)\n      fread (artist, 64, 1, ifp);\n    if (type == 0x080a) {\n      fread (make, 64, 1, ifp);\n      fseek (ifp, strlen(make) - 63, SEEK_CUR);\n      fread (model, 64, 1, ifp);\n    }\n    if (type == 0x1810) {\n      fseek (ifp, 12, SEEK_CUR);\n      flip = get4();\n    }\n    if (type == 0x1835)\t\t\t/* Get the decoder table */\n      tiff_compress = get4();\n    if (type == 0x2007) {\n      thumb_offset = ftell(ifp);\n      thumb_length = len;\n    }\n    if (type == 0x1818) {\n      shutter = pow (2, -int_to_float((get4(),get4())));\n      aperture = pow (2, int_to_float(get4())/2);\n    }\n    if (type == 0x102a) {\n      iso_speed = pow (2, (get4(),get2())/32.0 - 4) * 50;\n      aperture  = pow (2, (get2(),(short)get2())/64.0);\n      shutter   = pow (2,-((short)get2())/32.0);\n      wbi = (get2(),get2());\n      if (wbi > 17) wbi = 0;\n      fseek (ifp, 32, SEEK_CUR);\n      if (shutter > 1e6) shutter = get2()/10.0;\n    }\n    if (type == 0x102c) {\n      if (get2() > 512) {\t\t/* Pro90, G1 */\n\tfseek (ifp, 118, SEEK_CUR);\n\tFORC4 cam_mul[c ^ 2] = get2();\n      } else {\t\t\t\t/* G2, S30, S40 */\n\tfseek (ifp, 98, SEEK_CUR);\n\tFORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2();\n      }\n    }\n    if (type == 0x0032) {\n      if (len == 768) {\t\t\t/* EOS D30 */\n\tfseek (ifp, 72, SEEK_CUR);\n\tFORC4 cam_mul[c ^ (c >> 1)] = 1024.0 / get2();\n\tif (!wbi) cam_mul[0] = -1;\t/* use my auto white balance */\n      } else if (!cam_mul[0]) {\n\tif (get2() == key[0])\t\t/* Pro1, G6, S60, S70 */\n\t  c = (strstr(model,\"Pro1\") ?\n\t      \"012346000000000000\":\"01345:000000006008\")[wbi]-'0'+ 2;\n\telse {\t\t\t\t/* G3, G5, S45, S50 */\n\t  c = \"023457000000006000\"[wbi]-'0';\n\t  key[0] = key[1] = 0;\n\t}\n\tfseek (ifp, 78 + c*8, SEEK_CUR);\n\tFORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2() ^ key[c & 1];\n\tif (!wbi) cam_mul[0] = -1;\n      }\n    }\n    if (type == 0x10a9) {\t\t/* D60, 10D, 300D, and clones */\n      if (len > 66) wbi = \"0134567028\"[wbi]-'0';\n      fseek (ifp, 2 + wbi*8, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n    }\n    if (type == 0x1030 && (0x18040 >> wbi & 1))\n      ciff_block_1030();\t\t/* all that don't have 0x10a9 */\n    if (type == 0x1031) {\n      raw_width = (get2(),get2());\n      raw_height = get2();\n    }\n    if (type == 0x5029) {\n      focal_len = len >> 16;\n      if ((len & 0xffff) == 2) focal_len /= 32;\n    }\n    if (type == 0x5813) flash_used = int_to_float(len);\n    if (type == 0x5814) canon_ev   = int_to_float(len);\n    if (type == 0x5817) shot_order = len;\n    if (type == 0x5834) unique_id  = len;\n    if (type == 0x580e) timestamp  = len;\n    if (type == 0x180e) timestamp  = get4();\n#ifdef LOCALTIME\n    if ((type | 0x4000) == 0x580e)\n      timestamp = mktime (gmtime (&timestamp));\n#endif\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS parse_rollei()\n{\n  char line[128], *val;\n  struct tm t;\n\n  fseek (ifp, 0, SEEK_SET);\n  memset (&t, 0, sizeof t);\n  do {\n    fgets (line, 128, ifp);\n    if ((val = strchr(line,'=')))\n      *val++ = 0;\n    else\n      val = line + strlen(line);\n    if (!strcmp(line,\"DAT\"))\n      sscanf (val, \"%d.%d.%d\", &t.tm_mday, &t.tm_mon, &t.tm_year);\n    if (!strcmp(line,\"TIM\"))\n      sscanf (val, \"%d:%d:%d\", &t.tm_hour, &t.tm_min, &t.tm_sec);\n    if (!strcmp(line,\"HDR\"))\n      thumb_offset = atoi(val);\n    if (!strcmp(line,\"X  \"))\n      raw_width = atoi(val);\n    if (!strcmp(line,\"Y  \"))\n      raw_height = atoi(val);\n    if (!strcmp(line,\"TX \"))\n      thumb_width = atoi(val);\n    if (!strcmp(line,\"TY \"))\n      thumb_height = atoi(val);\n  } while (strncmp(line,\"EOHD\",4));\n  data_offset = thumb_offset + thumb_width * thumb_height * 2;\n  t.tm_year -= 1900;\n  t.tm_mon -= 1;\n  if (mktime(&t) > 0)\n    timestamp = mktime(&t);\n  strcpy (make, \"Rollei\");\n  strcpy (model,\"d530flex\");\n  write_thumb = &CLASS rollei_thumb;\n}\n\nvoid CLASS parse_sinar_ia()\n{\n  int entries, off;\n  char str[8], *cp;\n\n  order = 0x4949;\n  fseek (ifp, 4, SEEK_SET);\n  entries = get4();\n  fseek (ifp, get4(), SEEK_SET);\n  while (entries--) {\n    off = get4(); get4();\n    fread (str, 8, 1, ifp);\n    if (!strcmp(str,\"META\"))   meta_offset = off;\n    if (!strcmp(str,\"THUMB\")) thumb_offset = off;\n    if (!strcmp(str,\"RAW0\"))   data_offset = off;\n  }\n  fseek (ifp, meta_offset+20, SEEK_SET);\n  fread (make, 64, 1, ifp);\n  make[63] = 0;\n  if ((cp = strchr(make,' '))) {\n    strcpy (model, cp+1);\n    *cp = 0;\n  }\n  raw_width  = get2();\n  raw_height = get2();\n  load_raw = &CLASS unpacked_load_raw;\n  thumb_width = (get4(),get2());\n  thumb_height = get2();\n  write_thumb = &CLASS ppm_thumb;\n  maximum = 0x3fff;\n}\n\nvoid CLASS parse_phase_one (int base)\n{\n  unsigned entries, tag, type, len, data, save, i, c;\n  float romm_cam[3][3];\n  char *cp;\n\n  memset (&ph1, 0, sizeof ph1);\n  fseek (ifp, base, SEEK_SET);\n  order = get4() & 0xffff;\n  if (get4() >> 8 != 0x526177) return;\t\t/* \"Raw\" */\n  fseek (ifp, get4()+base, SEEK_SET);\n  entries = get4();\n  get4();\n  while (entries--) {\n    tag  = get4();\n    type = get4();\n    len  = get4();\n    data = get4();\n    save = ftell(ifp);\n    fseek (ifp, base+data, SEEK_SET);\n    switch (tag) {\n      case 0x100:  flip = \"0653\"[data & 3]-'0';  break;\n      case 0x106:\n\tfor (i=0; i < 9; i++)\n\t  romm_cam[0][i] = getreal(11);\n\tromm_coeff (romm_cam);\n\tbreak;\n      case 0x107:\n\tFORC3 cam_mul[c] = getreal(11);\n\tbreak;\n      case 0x108:  raw_width     = data;\tbreak;\n      case 0x109:  raw_height    = data;\tbreak;\n      case 0x10a:  left_margin   = data;\tbreak;\n      case 0x10b:  top_margin    = data;\tbreak;\n      case 0x10c:  width         = data;\tbreak;\n      case 0x10d:  height        = data;\tbreak;\n      case 0x10e:  ph1.format    = data;\tbreak;\n      case 0x10f:  data_offset   = data+base;\tbreak;\n      case 0x110:  meta_offset   = data+base;\n\t\t   meta_length   = len;\t\t\tbreak;\n      case 0x112:  ph1.key_off   = save - 4;\t\tbreak;\n      case 0x210:  ph1.tag_210   = int_to_float(data);\tbreak;\n      case 0x21a:  ph1.tag_21a   = data;\t\tbreak;\n      case 0x21c:  strip_offset  = data+base;\t\tbreak;\n      case 0x21d:  ph1.t_black     = data;\t\tbreak;\n      case 0x222:  ph1.split_col = data;\t\tbreak;\n      case 0x223:  ph1.black_off = data+base;\t\tbreak;\n      case 0x301:\n\tmodel[63] = 0;\n\tfread (model, 1, 63, ifp);\n\tif ((cp = strstr(model,\" camera\"))) *cp = 0;\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n  load_raw = ph1.format < 3 ?\n\t&CLASS phase_one_load_raw : &CLASS phase_one_load_raw_c;\n  maximum = 0xffff;\n  strcpy (make, \"Phase One\");\n  if (model[0]) return;\n  switch (raw_height) {\n    case 2060: strcpy (model,\"LightPhase\");\tbreak;\n    case 2682: strcpy (model,\"H 10\");\t\tbreak;\n    case 4128: strcpy (model,\"H 20\");\t\tbreak;\n    case 5488: strcpy (model,\"H 25\");\t\tbreak;\n  }\n}\n\nvoid CLASS parse_fuji (int offset)\n{\n  unsigned entries, tag, len, save, c;\n\n  fseek (ifp, offset, SEEK_SET);\n  entries = get4();\n  if (entries > 255) return;\n  while (entries--) {\n    tag = get2();\n    len = get2();\n    save = ftell(ifp);\n    if (tag == 0x100) {\n      raw_height = get2();\n      raw_width  = get2();\n    } else if (tag == 0x121) {\n      height = get2();\n      if ((width = get2()) == 4284) width += 3;\n    } else if (tag == 0x130) {\n      fuji_layout = fgetc(ifp) >> 7;\n      fuji_width = !(fgetc(ifp) & 8);\n    } else if (tag == 0x2ff0) {\n      FORC4 cam_mul[c ^ 1] = get2();\n    } else if (tag == 0xc000) {\n      c = order;\n      order = 0x4949;\n      if ((width = get4()) > 10000) width = get4();\n      height = get4();\n      order = c;\n    }\n    fseek (ifp, save+len, SEEK_SET);\n  }\n  height <<= fuji_layout;\n  width  >>= fuji_layout;\n}\n\nint CLASS parse_jpeg (int offset)\n{\n  int len, save, hlen, mark;\n\n  fseek (ifp, offset, SEEK_SET);\n  if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8) return 0;\n\n  while (fgetc(ifp) == 0xff && (mark = fgetc(ifp)) != 0xda) {\n    order = 0x4d4d;\n    len   = get2() - 2;\n    save  = ftell(ifp);\n    if (mark == 0xc0 || mark == 0xc3) {\n      fgetc(ifp);\n      raw_height = get2();\n      raw_width  = get2();\n    }\n    order = get2();\n    hlen  = get4();\n    if (get4() == 0x48454150)\t\t/* \"HEAP\" */\n      parse_ciff (save+hlen, len-hlen);\n    if (parse_tiff (save+6)) apply_tiff();\n    fseek (ifp, save+len, SEEK_SET);\n  }\n  return 1;\n}\n\nvoid CLASS parse_riff()\n{\n  unsigned i, size, end;\n  char tag[4], date[64], month[64];\n  static const char mon[12][4] =\n  { \"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\" };\n  struct tm t;\n\n  order = 0x4949;\n  fread (tag, 4, 1, ifp);\n  size = get4();\n  end = ftell(ifp) + size;\n  if (!memcmp(tag,\"RIFF\",4) || !memcmp(tag,\"LIST\",4)) {\n    get4();\n    while (ftell(ifp)+7 < end)\n      parse_riff();\n  } else if (!memcmp(tag,\"nctg\",4)) {\n    while (ftell(ifp)+7 < end) {\n      i = get2();\n      size = get2();\n      if ((i+1) >> 1 == 10 && size == 20)\n\tget_timestamp(0);\n      else fseek (ifp, size, SEEK_CUR);\n    }\n  } else if (!memcmp(tag,\"IDIT\",4) && size < 64) {\n    fread (date, 64, 1, ifp);\n    date[size] = 0;\n    memset (&t, 0, sizeof t);\n    if (sscanf (date, \"%*s %s %d %d:%d:%d %d\", month, &t.tm_mday,\n\t&t.tm_hour, &t.tm_min, &t.tm_sec, &t.tm_year) == 6) {\n      for (i=0; i < 12 && strcasecmp(mon[i],month); i++);\n      t.tm_mon = i;\n      t.tm_year -= 1900;\n      if (mktime(&t) > 0)\n\ttimestamp = mktime(&t);\n    }\n  } else\n    fseek (ifp, size, SEEK_CUR);\n}\n\nvoid CLASS parse_smal (int offset, int fsize)\n{\n  int ver;\n\n  fseek (ifp, offset+2, SEEK_SET);\n  order = 0x4949;\n  ver = fgetc(ifp);\n  if (ver == 6)\n    fseek (ifp, 5, SEEK_CUR);\n  if (get4() != fsize) return;\n  if (ver > 6) data_offset = get4();\n  raw_height = height = get2();\n  raw_width  = width  = get2();\n  strcpy (make, \"SMaL\");\n  sprintf (model, \"v%d %dx%d\", ver, width, height);\n  if (ver == 6) load_raw = &CLASS smal_v6_load_raw;\n  if (ver == 9) load_raw = &CLASS smal_v9_load_raw;\n}\n\nvoid CLASS parse_cine()\n{\n  unsigned off_head, off_setup, off_image, i;\n\n  order = 0x4949;\n  fseek (ifp, 4, SEEK_SET);\n  is_raw = get2() == 2;\n  fseek (ifp, 14, SEEK_CUR);\n  is_raw *= get4();\n  off_head = get4();\n  off_setup = get4();\n  off_image = get4();\n  timestamp = get4();\n  if ((i = get4())) timestamp = i;\n  fseek (ifp, off_head+4, SEEK_SET);\n  raw_width = get4();\n  raw_height = get4();\n  switch (get2(),get2()) {\n    case  8:  load_raw = &CLASS eight_bit_load_raw;  break;\n    case 16:  load_raw = &CLASS  unpacked_load_raw;\n  }\n  fseek (ifp, off_setup+792, SEEK_SET);\n  strcpy (make, \"CINE\");\n  sprintf (model, \"%d\", get4());\n  fseek (ifp, 12, SEEK_CUR);\n  switch ((i=get4()) & 0xffffff) {\n    case  3:  filters = 0x94949494;  break;\n    case  4:  filters = 0x49494949;  break;\n    default:  is_raw = 0;\n  }\n  fseek (ifp, 72, SEEK_CUR);\n  switch ((get4()+3600) % 360) {\n    case 270:  flip = 4;  break;\n    case 180:  flip = 1;  break;\n    case  90:  flip = 7;  break;\n    case   0:  flip = 2;\n  }\n  cam_mul[0] = getreal(11);\n  cam_mul[2] = getreal(11);\n  maximum = ~(-1 << get4());\n  fseek (ifp, 668, SEEK_CUR);\n  shutter = get4()/1000000000.0;\n  fseek (ifp, off_image, SEEK_SET);\n  if (shot_select < is_raw)\n    fseek (ifp, shot_select*8, SEEK_CUR);\n  data_offset  = (INT64) get4() + 8;\n  data_offset += (INT64) get4() << 32;\n}\n\nvoid CLASS parse_redcine()\n{\n  unsigned i, len, rdvo;\n\n  order = 0x4d4d;\n  is_raw = 0;\n  fseek (ifp, 52, SEEK_SET);\n  width  = get4();\n  height = get4();\n  fseek (ifp, 0, SEEK_END);\n  fseek (ifp, -(i = ftello(ifp) & 511), SEEK_CUR);\n  if (get4() != i || get4() != 0x52454f42) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s: Tail is missing, parsing from head...\\n\"), ifname);\n#endif\n    fseek (ifp, 0, SEEK_SET);\n    while ((len = get4()) != EOF) {\n      if (get4() == 0x52454456)\n\tif (is_raw++ == shot_select)\n\t  data_offset = ftello(ifp) - 8;\n      fseek (ifp, len-8, SEEK_CUR);\n    }\n  } else {\n    rdvo = get4();\n    fseek (ifp, 12, SEEK_CUR);\n    is_raw = get4();\n    fseeko (ifp, rdvo+8 + shot_select*4, SEEK_SET);\n    data_offset = get4();\n  }\n}\n//@end COMMON\n\n//@out COMMON\nchar * CLASS foveon_gets (int offset, char *str, int len)\n{\n  int i;\n  fseek (ifp, offset, SEEK_SET);\n  for (i=0; i < len-1; i++)\n    if ((str[i] = get2()) == 0) break;\n  str[i] = 0;\n  return str;\n}\n\nvoid CLASS parse_foveon()\n{\n  int entries, img=0, off, len, tag, save, i, wide, high, pent, poff[256][2];\n  char name[64], value[64];\n\n  order = 0x4949;\t\t\t/* Little-endian */\n  fseek (ifp, 36, SEEK_SET);\n  flip = get4();\n  fseek (ifp, -4, SEEK_END);\n  fseek (ifp, get4(), SEEK_SET);\n  if (get4() != 0x64434553) return;\t/* SECd */\n  entries = (get4(),get4());\n  while (entries--) {\n    off = get4();\n    len = get4();\n    tag = get4();\n    save = ftell(ifp);\n    fseek (ifp, off, SEEK_SET);\n    if (get4() != (0x20434553 | (tag << 24))) return;\n    switch (tag) {\n      case 0x47414d49:\t\t\t/* IMAG */\n      case 0x32414d49:\t\t\t/* IMA2 */\n\tfseek (ifp, 8, SEEK_CUR);\n\tpent = get4();\n\twide = get4();\n\thigh = get4();\n\tif (wide > raw_width && high > raw_height) {\n\t  switch (pent) {\n\t    case  5:  load_flags = 1;\n\t    case  6:  load_raw = &CLASS foveon_sd_load_raw;  break;\n\t    case 30:  load_raw = &CLASS foveon_dp_load_raw;  break;\n\t    default:  load_raw = 0;\n\t  }\n\t  raw_width  = wide;\n\t  raw_height = high;\n\t  data_offset = off+28;\n\t}\n\tfseek (ifp, off+28, SEEK_SET);\n\tif (fgetc(ifp) == 0xff && fgetc(ifp) == 0xd8\n\t\t&& thumb_length < len-28) {\n\t  thumb_offset = off+28;\n\t  thumb_length = len-28;\n\t  write_thumb = &CLASS jpeg_thumb;\n\t}\n\tif (++img == 2 && !thumb_length) {\n\t  thumb_offset = off+24;\n\t  thumb_width = wide;\n\t  thumb_height = high;\n\t  write_thumb = &CLASS foveon_thumb;\n\t}\n\tbreak;\n      case 0x464d4143:\t\t\t/* CAMF */\n\tmeta_offset = off+8;\n\tmeta_length = len-28;\n\tbreak;\n      case 0x504f5250:\t\t\t/* PROP */\n\tpent = (get4(),get4());\n\tfseek (ifp, 12, SEEK_CUR);\n\toff += pent*8 + 24;\n\tif ((unsigned) pent > 256) pent=256;\n\tfor (i=0; i < pent*2; i++)\n\t  poff[0][i] = off + get4()*2;\n\tfor (i=0; i < pent; i++) {\n\t  foveon_gets (poff[i][0], name, 64);\n\t  foveon_gets (poff[i][1], value, 64);\n\t  if (!strcmp (name, \"ISO\"))\n\t    iso_speed = atoi(value);\n\t  if (!strcmp (name, \"CAMMANUF\"))\n\t    strcpy (make, value);\n\t  if (!strcmp (name, \"CAMMODEL\"))\n\t    strcpy (model, value);\n\t  if (!strcmp (name, \"WB_DESC\"))\n\t    strcpy (model2, value);\n\t  if (!strcmp (name, \"TIME\"))\n\t    timestamp = atoi(value);\n\t  if (!strcmp (name, \"EXPTIME\"))\n\t    shutter = atoi(value) / 1000000.0;\n\t  if (!strcmp (name, \"APERTURE\"))\n\t    aperture = atof(value);\n\t  if (!strcmp (name, \"FLENGTH\"))\n\t    focal_len = atof(value);\n\t}\n#ifdef LOCALTIME\n\ttimestamp = mktime (gmtime (&timestamp));\n#endif\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n  is_foveon = 1;\n}\n//@end COMMON\n\n//@out COMMON\n/*\n   All matrices are from Adobe DNG Converter unless otherwise noted.\n */\nvoid CLASS adobe_coeff (const char *t_make, const char *t_model)\n{\n  static const struct {\n    const char *prefix;\n    short t_black, t_maximum, trans[12];\n  } table[] = {\n    { \"AGFAPHOTO DC-833m\", 0, 0,\t/* DJC */\n\t{ 11438,-3762,-1115,-2409,9914,2497,-1227,2295,5300 } },\n    { \"Apple QuickTake\", 0, 0,\t\t/* DJC */\n\t{ 21392,-5653,-3353,2406,8010,-415,7166,1427,2078 } },\n    { \"Canon EOS D2000\", 0, 0,\n\t{ 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\n    { \"Canon EOS D6000\", 0, 0,\n\t{ 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\n    { \"Canon EOS D30\", 0, 0,\n\t{ 9805,-2689,-1312,-5803,13064,3068,-2438,3075,8775 } },\n    { \"Canon EOS D60\", 0, 0xfa0,\n\t{ 6188,-1341,-890,-7168,14489,2937,-2640,3228,8483 } },\n    { \"Canon EOS 5D Mark III\", 0, 0x3c80,\n\t{ 6722,-635,-963,-4287,12460,2028,-908,2162,5668 } },\n    { \"Canon EOS 5D Mark II\", 0, 0x3cf0,\n\t{ 4716,603,-830,-7798,15474,2480,-1496,1937,6651 } },\n    { \"Canon EOS 5D\", 0, 0xe6c,\n\t{ 6347,-479,-972,-8297,15954,2480,-1968,2131,7649 } },\n    { \"Canon EOS 6D\", 0, 0x3c82,\n\t{ 7034,-804,-1014,-4420,12564,2058,-851,1994,5758 } },\n    { \"Canon EOS 7D\", 0, 0x3510,\n\t{ 6844,-996,-856,-3876,11761,2396,-593,1772,6198 } },\n    { \"Canon EOS 10D\", 0, 0xfa0,\n\t{ 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\n    { \"Canon EOS 20Da\", 0, 0,\n\t{ 14155,-5065,-1382,-6550,14633,2039,-1623,1824,6561 } },\n    { \"Canon EOS 20D\", 0, 0xfff,\n\t{ 6599,-537,-891,-8071,15783,2424,-1983,2234,7462 } },\n    { \"Canon EOS 30D\", 0, 0,\n\t{ 6257,-303,-1000,-7880,15621,2396,-1714,1904,7046 } },\n    { \"Canon EOS 40D\", 0, 0x3f60,\n\t{ 6071,-747,-856,-7653,15365,2441,-2025,2553,7315 } },\n    { \"Canon EOS 50D\", 0, 0x3d93,\n\t{ 4920,616,-593,-6493,13964,2784,-1774,3178,7005 } },\n    { \"Canon EOS 60D\", 0, 0x2ff7,\n\t{ 6719,-994,-925,-4408,12426,2211,-887,2129,6051 } },\n    { \"Canon EOS 70D\", 0, 0x3c80,\n\t{ 7034,-804,-1014,-4420,12564,2058,-851,1994,5758 } },\n    { \"Canon EOS 300D\", 0, 0xfa0,\n\t{ 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\n    { \"Canon EOS 350D\", 0, 0xfff,\n\t{ 6018,-617,-965,-8645,15881,2975,-1530,1719,7642 } },\n    { \"Canon EOS 400D\", 0, 0xe8e,\n\t{ 7054,-1501,-990,-8156,15544,2812,-1278,1414,7796 } },\n    { \"Canon EOS 450D\", 0, 0x390d,\n\t{ 5784,-262,-821,-7539,15064,2672,-1982,2681,7427 } },\n    { \"Canon EOS 500D\", 0, 0x3479,\n\t{ 4763,712,-646,-6821,14399,2640,-1921,3276,6561 } },\n    { \"Canon EOS 550D\", 0, 0x3dd7,\n\t{ 6941,-1164,-857,-3825,11597,2534,-416,1540,6039 } },\n    { \"Canon EOS 600D\", 0, 0x3510,\n\t{ 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },\n    { \"Canon EOS 650D\", 0, 0x354d,\n\t{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 700D\", 0, 0x354d,\n\t{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS REBEL T5i\", 0, 0x354d,\n\t{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 1000D\", 0, 0xe43,\n\t{ 6771,-1139,-977,-7818,15123,2928,-1244,1437,7533 } },\n    { \"Canon EOS 1100D\", 0, 0x3510,\n\t{ 6444,-904,-893,-4563,12308,2535,-903,2016,6728 } },\n    { \"Canon EOS M\", 0, 0,\n\t{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS-1Ds Mark III\", 0, 0x3bb0,\n\t{ 5859,-211,-930,-8255,16017,2353,-1732,1887,7448 } },\n    { \"Canon EOS-1Ds Mark II\", 0, 0xe80,\n\t{ 6517,-602,-867,-8180,15926,2378,-1618,1771,7633 } },\n    { \"Canon EOS-1D Mark IV\", 0, 0x3bb0,\n\t{ 6014,-220,-795,-4109,12014,2361,-561,1824,5787 } },\n    { \"Canon EOS-1D Mark III\", 0, 0x3bb0,\n\t{ 6291,-540,-976,-8350,16145,2311,-1714,1858,7326 } },\n    { \"Canon EOS-1D Mark II N\", 0, 0xe80,\n\t{ 6240,-466,-822,-8180,15825,2500,-1801,1938,8042 } },\n    { \"Canon EOS-1D Mark II\", 0, 0xe80,\n\t{ 6264,-582,-724,-8312,15948,2504,-1744,1919,8664 } },\n    { \"Canon EOS-1DS\", 0, 0xe20,\n\t{ 4374,3631,-1743,-7520,15212,2472,-2892,3632,8161 } },\n    { \"Canon EOS-1D X\", 0, 0x3c4e,\n\t{ 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },\n    { \"Canon EOS-1D\", 0, 0xe20,\n\t{ 6806,-179,-1020,-8097,16415,1687,-3267,4236,7690 } },\n    { \"Canon EOS 100D\", 0, 0x3cf0,\n\t{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS REBEL SL1\", 0, 0x3cf0,\n\t{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS\", 0, 0,\n\t{ 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\n    { \"Canon PowerShot A530\", 0, 0,\n\t{ 0 } },\t/* don't want the A5 matrix */\n    { \"Canon PowerShot A50\", 0, 0,\n\t{ -5300,9846,1776,3436,684,3939,-5540,9879,6200,-1404,11175,217 } },\n    { \"Canon PowerShot A5\", 0, 0,\n\t{ -4801,9475,1952,2926,1611,4094,-5259,10164,5947,-1554,10883,547 } },\n    { \"Canon PowerShot G10\", 0, 0,\n\t{ 11093,-3906,-1028,-5047,12492,2879,-1003,1750,5561 } },\n    { \"Canon PowerShot G11\", 0, 0,\n\t{ 12177,-4817,-1069,-1612,9864,2049,-98,850,4471 } },\n    { \"Canon PowerShot G12\", 0, 0,\n\t{ 13244,-5501,-1248,-1508,9858,1935,-270,1083,4366 } },\n    { \"Canon PowerShot G15\", 0, 0,\n\t{ 7474,-2301,-567,-4056,11456,2975,-222,716,4181 } },\n    { \"Canon PowerShot G1 X\", 0, 0,\n\t{ 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },\n    { \"Canon PowerShot G1\", 0, 0,\n\t{ -4778,9467,2172,4743,-1141,4344,-5146,9908,6077,-1566,11051,557 } },\n    { \"Canon PowerShot G2\", 0, 0,\n\t{ 9087,-2693,-1049,-6715,14382,2537,-2291,2819,7790 } },\n    { \"Canon PowerShot G3\", 0, 0,\n\t{ 9212,-2781,-1073,-6573,14189,2605,-2300,2844,7664 } },\n    { \"Canon PowerShot G5\", 0, 0,\n\t{ 9757,-2872,-933,-5972,13861,2301,-1622,2328,7212 } },\n    { \"Canon PowerShot G6\", 0, 0,\n\t{ 9877,-3775,-871,-7613,14807,3072,-1448,1305,7485 } },\n    { \"Canon PowerShot G9\", 0, 0,\n\t{ 7368,-2141,-598,-5621,13254,2625,-1418,1696,5743 } },\n    { \"Canon PowerShot Pro1\", 0, 0,\n\t{ 10062,-3522,-999,-7643,15117,2730,-765,817,7323 } },\n    { \"Canon PowerShot Pro70\", 34, 0,\n\t{ -4155,9818,1529,3939,-25,4522,-5521,9870,6610,-2238,10873,1342 } },\n    { \"Canon PowerShot Pro90\", 0, 0,\n\t{ -4963,9896,2235,4642,-987,4294,-5162,10011,5859,-1770,11230,577 } },\n    { \"Canon PowerShot S30\", 0, 0,\n\t{ 10566,-3652,-1129,-6552,14662,2006,-2197,2581,7670 } },\n    { \"Canon PowerShot S40\", 0, 0,\n\t{ 8510,-2487,-940,-6869,14231,2900,-2318,2829,9013 } },\n    { \"Canon PowerShot S45\", 0, 0,\n\t{ 8163,-2333,-955,-6682,14174,2751,-2077,2597,8041 } },\n    { \"Canon PowerShot S50\", 0, 0,\n\t{ 8882,-2571,-863,-6348,14234,2288,-1516,2172,6569 } },\n    { \"Canon PowerShot S60\", 0, 0,\n\t{ 8795,-2482,-797,-7804,15403,2573,-1422,1996,7082 } },\n    { \"Canon PowerShot S70\", 0, 0,\n\t{ 9976,-3810,-832,-7115,14463,2906,-901,989,7889 } },\n    { \"Canon PowerShot S90\", 0, 0,\n\t{ 12374,-5016,-1049,-1677,9902,2078,-83,852,4683 } },\n    { \"Canon PowerShot S95\", 0, 0,\n\t{ 13440,-5896,-1279,-1236,9598,1931,-180,1001,4651 } },\n    { \"Canon PowerShot S110\", 0, 0,\n\t{ 8039,-2643,-654,-3783,11230,2930,-206,690,4194 } },\n    { \"Canon PowerShot S100\", 0, 0,\n\t{ 7968,-2565,-636,-2873,10697,2513,180,667,4211 } },\n    { \"Canon PowerShot S110\", 0, 0,\n\t{ 8039,-2643,-654,-3783,11230,2930,-206,690,4194 } },\n    { \"Canon PowerShot SX1 IS\", 0, 0,\n\t{ 6578,-259,-502,-5974,13030,3309,-308,1058,4970 } },\n    { \"Canon PowerShot SX50 HS\", 0, 0,\n\t{ 12432,-4753,-1247,-2110,10691,1629,-412,1623,4926 } },\n    { \"Canon PowerShot A470\", 0, 0,\t/* DJC */\n\t{ 12513,-4407,-1242,-2680,10276,2405,-878,2215,4734 } },\n    { \"Canon PowerShot A610\", 0, 0,\t/* DJC */\n\t{ 15591,-6402,-1592,-5365,13198,2168,-1300,1824,5075 } },\n    { \"Canon PowerShot A620\", 0, 0,\t/* DJC */\n\t{ 15265,-6193,-1558,-4125,12116,2010,-888,1639,5220 } },\n    { \"Canon PowerShot A630\", 0, 0,\t/* DJC */\n\t{ 14201,-5308,-1757,-6087,14472,1617,-2191,3105,5348 } },\n    { \"Canon PowerShot A640\", 0, 0,\t/* DJC */\n\t{ 13124,-5329,-1390,-3602,11658,1944,-1612,2863,4885 } },\n    { \"Canon PowerShot A650\", 0, 0,\t/* DJC */\n\t{ 9427,-3036,-959,-2581,10671,1911,-1039,1982,4430 } },\n    { \"Canon PowerShot A720\", 0, 0,\t/* DJC */\n\t{ 14573,-5482,-1546,-1266,9799,1468,-1040,1912,3810 } },\n    { \"Canon PowerShot S3 IS\", 0, 0,\t/* DJC */\n\t{ 14062,-5199,-1446,-4712,12470,2243,-1286,2028,4836 } },\n    { \"Canon PowerShot SX110 IS\", 0, 0,\t/* DJC */\n\t{ 14134,-5576,-1527,-1991,10719,1273,-1158,1929,3581 } },\n    { \"Canon PowerShot SX220\", 0, 0,\t/* DJC */\n\t{ 13898,-5076,-1447,-1405,10109,1297,-244,1860,3687 } },\n    { \"Canon PowerShot SX50\", 0, 0,\n\t{ 12432,-4753,-1247,-2110,10691,1629,-412,1623,4926 } },\n    { \"CASIO EX-S20\", 0, 0,\t\t/* DJC */\n\t{ 11634,-3924,-1128,-4968,12954,2015,-1588,2648,7206 } },\n    { \"CASIO EX-Z750\", 0, 0,\t\t/* DJC */\n\t{ 10819,-3873,-1099,-4903,13730,1175,-1755,3751,4632 } },\n    { \"CASIO EX-Z10\", 128, 0xfff,\t/* DJC */\n\t{ 9790,-3338,-603,-2321,10222,2099,-344,1273,4799 } },\n    { \"CINE 650\", 0, 0,\n\t{ 3390,480,-500,-800,3610,340,-550,2336,1192 } },\n    { \"CINE 660\", 0, 0,\n\t{ 3390,480,-500,-800,3610,340,-550,2336,1192 } },\n    { \"CINE\", 0, 0,\n\t{ 20183,-4295,-423,-3940,15330,3985,-280,4870,9800 } },\n    { \"Contax N Digital\", 0, 0xf1e,\n\t{ 7777,1285,-1053,-9280,16543,2916,-3677,5679,7060 } },\n    { \"EPSON R-D1\", 0, 0,\n\t{ 6827,-1878,-732,-8429,16012,2564,-704,592,7145 } },\n    { \"FUJIFILM E550\", 0, 0,\n\t{ 11044,-3888,-1120,-7248,15168,2208,-1531,2277,8069 } },\n    { \"FUJIFILM E900\", 0, 0,\n\t{ 9183,-2526,-1078,-7461,15071,2574,-2022,2440,8639 } },\n    { \"FUJIFILM F5\", 0, 0,\n\t{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"FUJIFILM F6\", 0, 0,\n\t{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"FUJIFILM F77\", 0, 0xfe9,\n\t{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"FUJIFILM F7\", 0, 0,\n\t{ 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\n    { \"FUJIFILM F800\", 0, 0,\n\t{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"FUJIFILM F8\", 0, 0,\n\t{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"FUJIFILM S100FS\", 514, 0,\n\t{ 11521,-4355,-1065,-6524,13767,3058,-1466,1984,6045 } },\n    { \"FUJIFILM S200EXR\", 512, 0x3fff,\n\t{ 11401,-4498,-1312,-5088,12751,2613,-838,1568,5941 } },\n    { \"FUJIFILM S20Pro\", 0, 0,\n\t{ 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\n    { \"FUJIFILM S2Pro\", 128, 0,\n\t{ 12492,-4690,-1402,-7033,15423,1647,-1507,2111,7697 } },\n    { \"FUJIFILM S3Pro\", 0, 0,\n\t{ 11807,-4612,-1294,-8927,16968,1988,-2120,2741,8006 } },\n    { \"FUJIFILM S5Pro\", 0, 0,\n\t{ 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\n    { \"FUJIFILM S5000\", 0, 0,\n\t{ 8754,-2732,-1019,-7204,15069,2276,-1702,2334,6982 } },\n    { \"FUJIFILM S5100\", 0, 0,\n\t{ 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\n    { \"FUJIFILM S5500\", 0, 0,\n\t{ 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\n    { \"FUJIFILM S5200\", 0, 0,\n\t{ 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\n    { \"FUJIFILM S5600\", 0, 0,\n\t{ 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\n    { \"FUJIFILM S6\", 0, 0,\n\t{ 12628,-4887,-1401,-6861,14996,1962,-2198,2782,7091 } },\n    { \"FUJIFILM S7000\", 0, 0,\n\t{ 10190,-3506,-1312,-7153,15051,2238,-2003,2399,7505 } },\n    { \"FUJIFILM S9000\", 0, 0,\n\t{ 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\n    { \"FUJIFILM S9500\", 0, 0,\n\t{ 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\n    { \"FUJIFILM S9100\", 0, 0,\n\t{ 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\n    { \"FUJIFILM S9600\", 0, 0,\n\t{ 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\n    { \"FUJIFILM IS-1\", 0, 0,\n\t{ 21461,-10807,-1441,-2332,10599,1999,289,875,7703 } },\n    { \"FUJIFILM IS Pro\", 0, 0,\n\t{ 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\n    { \"FUJIFILM HS10 HS11\", 0, 0xf68,\n\t{ 12440,-3954,-1183,-1123,9674,1708,-83,1614,4086 } },\n    { \"FUJIFILM HS20EXR\", 0, 0,\n\t{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"FUJIFILM HS3\", 0, 0,\n\t{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"FUJIFILM HS50EXR\", 0, 0,\n\t{ 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },\n    { \"FUJIFILM SL1000\", 0, 0,\n\t{ 11705,-4262,-1107,-2282,10791,1709,-555,1713,4945 } },\n    { \"FUJIFILM X100S\", 0, 0,\n\t{ 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },\n    { \"FUJIFILM X100\", 0, 0,\n\t{ 12161,-4457,-1069,-5034,12874,2400,-795,1724,6904 } },\n    { \"FUJIFILM X10\", 0, 0,\n\t{ 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"FUJIFILM X20\", 0, 0,\n\t{ 11768,-4971,-1133,-4904,12927,2183,-480,1723,4605 } },\n    { \"FUJIFILM XF1\", 0, 0,\n\t{ 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"FUJIFILM X-Pro1\", 0, 0,\n\t{ 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },\n    { \"FUJIFILM X-E1\", 0, 0,\n\t{ 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },\n    { \"FUJIFILM XF1\", 0, 0,\n\t{ 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"FUJIFILM X-S1\", 0, 0,\n\t{ 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Imacon Ixpress\", 0, 0,\t\t/* DJC */\n\t{ 7025,-1415,-704,-5188,13765,1424,-1248,2742,6038 } },\n    { \"KODAK NC2000\", 0, 0,\n\t{ 13891,-6055,-803,-465,9919,642,2121,82,1291 } },\n    { \"Kodak DCS315C\", 8, 0,\n\t{ 17523,-4827,-2510,756,8546,-137,6113,1649,2250 } },\n    { \"Kodak DCS330C\", 8, 0,\n\t{ 20620,-7572,-2801,-103,10073,-396,3551,-233,2220 } },\n    { \"KODAK DCS420\", 0, 0,\n\t{ 10868,-1852,-644,-1537,11083,484,2343,628,2216 } },\n    { \"KODAK DCS460\", 0, 0,\n\t{ 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\n    { \"KODAK EOSDCS1\", 0, 0,\n\t{ 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\n    { \"KODAK EOSDCS3B\", 0, 0,\n\t{ 9898,-2700,-940,-2478,12219,206,1985,634,1031 } },\n    { \"Kodak DCS520C\", 178, 0,\n\t{ 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\n    { \"Kodak DCS560C\", 177, 0,\n\t{ 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\n    { \"Kodak DCS620C\", 177, 0,\n\t{ 23617,-10175,-3149,-2054,11749,-272,2586,-489,3453 } },\n    { \"Kodak DCS620X\", 176, 0,\n\t{ 13095,-6231,154,12221,-21,-2137,895,4602,2258 } },\n    { \"Kodak DCS660C\", 173, 0,\n\t{ 18244,-6351,-2739,-791,11193,-521,3711,-129,2802 } },\n    { \"Kodak DCS720X\", 0, 0,\n\t{ 11775,-5884,950,9556,1846,-1286,-1019,6221,2728 } },\n    { \"Kodak DCS760C\", 0, 0,\n\t{ 16623,-6309,-1411,-4344,13923,323,2285,274,2926 } },\n    { \"Kodak DCS Pro SLR\", 0, 0,\n\t{ 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\n    { \"Kodak DCS Pro 14nx\", 0, 0,\n\t{ 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\n    { \"Kodak DCS Pro 14\", 0, 0,\n\t{ 7791,3128,-776,-8588,16458,2039,-2455,4006,6198 } },\n    { \"Kodak ProBack645\", 0, 0,\n\t{ 16414,-6060,-1470,-3555,13037,473,2545,122,4948 } },\n    { \"Kodak ProBack\", 0, 0,\n\t{ 21179,-8316,-2918,-915,11019,-165,3477,-180,4210 } },\n    { \"KODAK P712\", 0, 0,\n\t{ 9658,-3314,-823,-5163,12695,2768,-1342,1843,6044 } },\n    { \"KODAK P850\", 0, 0xf7c,\n\t{ 10511,-3836,-1102,-6946,14587,2558,-1481,1792,6246 } },\n    { \"KODAK P880\", 0, 0xfff,\n\t{ 12805,-4662,-1376,-7480,15267,2360,-1626,2194,7904 } },\n    { \"KODAK EasyShare Z980\", 0, 0,\n\t{ 11313,-3559,-1101,-3893,11891,2257,-1214,2398,4908 } },\n    { \"KODAK EasyShare Z981\", 0, 0,\n\t{ 12729,-4717,-1188,-1367,9187,2582,274,860,4411 } },\n    { \"KODAK EasyShare Z990\", 0, 0xfed,\n\t{ 11749,-4048,-1309,-1867,10572,1489,-138,1449,4522 } },\n    { \"KODAK EASYSHARE Z1015\", 0, 0xef1,\n\t{ 11265,-4286,-992,-4694,12343,2647,-1090,1523,5447 } },\n    { \"Leaf CMost\", 0, 0,\n\t{ 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\n    { \"Leaf Valeo 6\", 0, 0,\n\t{ 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\n    { \"Leaf Aptus 54S\", 0, 0,\n\t{ 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\n    { \"Leaf Aptus 65\", 0, 0,\n\t{ 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf Aptus 75\", 0, 0,\n\t{ 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf\", 0, 0,\n\t{ 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\n    { \"Mamiya ZD\", 0, 0,\n\t{ 7645,2579,-1363,-8689,16717,2015,-3712,5941,5961 } },\n    { \"Micron 2010\", 110, 0,\t\t/* DJC */\n\t{ 16695,-3761,-2151,155,9682,163,3433,951,4904 } },\n    { \"Minolta DiMAGE 5\", 0, 0xf7d,\n\t{ 8983,-2942,-963,-6556,14476,2237,-2426,2887,8014 } },\n    { \"Minolta DiMAGE 7Hi\", 0, 0xf7d,\n\t{ 11368,-3894,-1242,-6521,14358,2339,-2475,3056,7285 } },\n    { \"Minolta DiMAGE 7\", 0, 0xf7d,\n\t{ 9144,-2777,-998,-6676,14556,2281,-2470,3019,7744 } },\n    { \"Minolta DiMAGE A1\", 0, 0xf8b,\n\t{ 9274,-2547,-1167,-8220,16323,1943,-2273,2720,8340 } },\n    { \"MINOLTA DiMAGE A200\", 0, 0,\n\t{ 8560,-2487,-986,-8112,15535,2771,-1209,1324,7743 } },\n    { \"Minolta DiMAGE A2\", 0, 0xf8f,\n\t{ 9097,-2726,-1053,-8073,15506,2762,-966,981,7763 } },\n    { \"Minolta DiMAGE Z2\", 0, 0,\t/* DJC */\n\t{ 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\n    { \"MINOLTA DYNAX 5\", 0, 0xffb,\n\t{ 10284,-3283,-1086,-7957,15762,2316,-829,882,6644 } },\n    { \"MINOLTA DYNAX 7\", 0, 0xffb,\n\t{ 10239,-3104,-1099,-8037,15727,2451,-927,925,6871 } },\n    { \"MOTOROLA PIXL\", 0, 0,\t\t/* DJC */\n\t{ 8898,-989,-1033,-3292,11619,1674,-661,3178,5216 } },\n    { \"NIKON D100\", 0, 0,\n\t{ 5902,-933,-782,-8983,16719,2354,-1402,1455,6464 } },\n    { \"NIKON D1H\", 0, 0,\n\t{ 7577,-2166,-926,-7454,15592,1934,-2377,2808,8606 } },\n    { \"NIKON D1X\", 0, 0,\n\t{ 7702,-2245,-975,-9114,17242,1875,-2679,3055,8521 } },\n    { \"NIKON D1\", 0, 0, /* multiplied by 2.218750, 1.0, 1.148438 */\n\t{ 16772,-4726,-2141,-7611,15713,1972,-2846,3494,9521 } },\n    { \"NIKON D200\", 0, 0xfbc,\n\t{ 8367,-2248,-763,-8758,16447,2422,-1527,1550,8053 } },\n    { \"NIKON D2H\", 0, 0,\n\t{ 5710,-901,-615,-8594,16617,2024,-2975,4120,6830 } },\n    { \"NIKON D2X\", 0, 0,\n\t{ 10231,-2769,-1255,-8301,15900,2552,-797,680,7148 } },\n    { \"NIKON D3000\", 0, 0,\n\t{ 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },\n    { \"NIKON D3100\", 0, 0,\n\t{ 7911,-2167,-813,-5327,13150,2408,-1288,2483,7968 } },\n    { \"NIKON D3200\", 0, 0xfb9,\n\t{ 7013,-1408,-635,-5268,12902,2640,-1470,2801,7379 } },\n    { \"NIKON D300\", 0, 0,\n\t{ 9030,-1992,-715,-8465,16302,2255,-2689,3217,8069 } },\n    { \"NIKON D3X\", 0, 0,\n\t{ 7171,-1986,-648,-8085,15555,2718,-2170,2512,7457 } },\n    { \"NIKON D3S\", 0, 0,\n\t{ 8828,-2406,-694,-4874,12603,2541,-660,1509,7587 } },\n    { \"NIKON D3\", 0, 0,\n\t{ 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\n    { \"NIKON D40X\", 0, 0,\n\t{ 8819,-2543,-911,-9025,16928,2151,-1329,1213,8449 } },\n    { \"NIKON D40\", 0, 0,\n\t{ 6992,-1668,-806,-8138,15748,2543,-874,850,7897 } },\n    { \"NIKON D4\", 0, 0,\n\t{ 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"NIKON D5000\", 0, 0xf00,\n\t{ 7309,-1403,-519,-8474,16008,2622,-2433,2826,8064 } },\n    { \"NIKON D5100\", 0, 0x3de6,\n\t{ 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"NIKON D5200\", 0, 0,\n\t{ 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"NIKON D50\", 0, 0,\n\t{ 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\n    { \"NIKON D600\", 0, 0x3e07,\n\t{ 8178,-2245,-609,-4857,12394,2776,-1207,2086,7298 } },\n    { \"NIKON D60\", 0, 0,\n\t{ 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },\n    { \"NIKON D7000\", 0, 0,\n\t{ 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"NIKON D700\", 0, 0,\n\t{ 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\n    { \"NIKON D70\", 0, 0,\n\t{ 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\n    { \"NIKON D7100\", 0, 0,\n\t{ 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"NIKON D800\", 0, 0,\n\t{ 7866,-2108,-555,-4869,12483,2681,-1176,2069,7501 } },\n    { \"NIKON D80\", 0, 0,\n\t{ 8629,-2410,-883,-9055,16940,2171,-1490,1363,8520 } },\n    { \"NIKON D90\", 0, 0xf00,\n\t{ 7309,-1403,-519,-8474,16008,2622,-2434,2826,8064 } },\n    { \"NIKON E950\", 0, 0x3dd,\t\t/* DJC */\n\t{ -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"NIKON E995\", 0, 0,\t/* copied from E5000 */\n\t{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"NIKON E2100\", 0, 0,\t/* copied from Z2, new white balance */\n\t{ 13142,-4152,-1596,-4655,12374,2282,-1769,2696,6711} },\n    { \"NIKON E2500\", 0, 0,\n\t{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"NIKON E3200\", 0, 0,\t\t/* DJC */\n\t{ 9846,-2085,-1019,-3278,11109,2170,-774,2134,5745 } },\n    { \"NIKON E4300\", 0, 0,\t/* copied from Minolta DiMAGE Z2 */\n\t{ 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\n    { \"NIKON E4500\", 0, 0,\n\t{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"NIKON E5000\", 0, 0,\n\t{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"NIKON E5400\", 0, 0,\n\t{ 9349,-2987,-1001,-7919,15766,2266,-2098,2680,6839 } },\n    { \"NIKON E5700\", 0, 0,\n\t{ -5368,11478,2368,5537,-113,3148,-4969,10021,5782,778,9028,211 } },\n    { \"NIKON E8400\", 0, 0,\n\t{ 7842,-2320,-992,-8154,15718,2599,-1098,1342,7560 } },\n    { \"NIKON E8700\", 0, 0,\n\t{ 8489,-2583,-1036,-8051,15583,2643,-1307,1407,7354 } },\n    { \"NIKON E8800\", 0, 0,\n\t{ 7971,-2314,-913,-8451,15762,2894,-1442,1520,7610 } },\n    { \"NIKON COOLPIX A\", 0, 0,\n\t{ 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"NIKON COOLPIX P330\", 0, 0,\n\t{ 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"NIKON COOLPIX P6000\", 0, 0,\n\t{ 9698,-3367,-914,-4706,12584,2368,-837,968,5801 } },\n    { \"NIKON COOLPIX P7000\", 0, 0,\n\t{ 11432,-3679,-1111,-3169,11239,2202,-791,1380,4455 } },\n    { \"NIKON COOLPIX P7100\", 0, 0,\n\t{ 11053,-4269,-1024,-1976,10182,2088,-526,1263,4469 } },\n    { \"NIKON COOLPIX P7700\", 200, 0,\n\t{ 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"NIKON 1 J3\", 0, 0,\n\t{ 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },\n    { \"NIKON 1 S1\", 0, 0,\n\t{ 8994,-2667,-865,-4594,12324,2552,-699,1786,6260 } },\n    { \"NIKON 1 V2\", 0, 0,\n\t{ 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },\n    { \"NIKON 1 \", 0, 0,\n\t{ 8994,-2667,-865,-4594,12324,2552,-699,1786,6260 } },\n    { \"OLYMPUS C5050\", 0, 0,\n\t{ 10508,-3124,-1273,-6079,14294,1901,-1653,2306,6237 } },\n    { \"OLYMPUS C5060\", 0, 0,\n\t{ 10445,-3362,-1307,-7662,15690,2058,-1135,1176,7602 } },\n    { \"OLYMPUS C7070\", 0, 0,\n\t{ 10252,-3531,-1095,-7114,14850,2436,-1451,1723,6365 } },\n    { \"OLYMPUS C70\", 0, 0,\n\t{ 10793,-3791,-1146,-7498,15177,2488,-1390,1577,7321 } },\n    { \"OLYMPUS C80\", 0, 0,\n\t{ 8606,-2509,-1014,-8238,15714,2703,-942,979,7760 } },\n    { \"OLYMPUS E-10\", 0, 0xffc,\n\t{ 12745,-4500,-1416,-6062,14542,1580,-1934,2256,6603 } },\n    { \"OLYMPUS E-1\", 0, 0,\n\t{ 11846,-4767,-945,-7027,15878,1089,-2699,4122,8311 } },\n    { \"OLYMPUS E-20\", 0, 0xffc,\n\t{ 13173,-4732,-1499,-5807,14036,1895,-2045,2452,7142 } },\n    { \"OLYMPUS E-300\", 0, 0,\n\t{ 7828,-1761,-348,-5788,14071,1830,-2853,4518,6557 } },\n    { \"OLYMPUS E-330\", 0, 0,\n\t{ 8961,-2473,-1084,-7979,15990,2067,-2319,3035,8249 } },\n    { \"OLYMPUS E-30\", 0, 0xfbc,\n\t{ 8144,-1861,-1111,-7763,15894,1929,-1865,2542,7607 } },\n    { \"OLYMPUS E-3\", 0, 0xf99,\n\t{ 9487,-2875,-1115,-7533,15606,2010,-1618,2100,7389 } },\n    { \"OLYMPUS E-400\", 0, 0,\n\t{ 6169,-1483,-21,-7107,14761,2536,-2904,3580,8568 } },\n    { \"OLYMPUS E-410\", 0, 0xf6a,\n\t{ 8856,-2582,-1026,-7761,15766,2082,-2009,2575,7469 } },\n    { \"OLYMPUS E-420\", 0, 0xfd7,\n\t{ 8746,-2425,-1095,-7594,15612,2073,-1780,2309,7416 } },\n    { \"OLYMPUS E-450\", 0, 0xfd2,\n\t{ 8745,-2425,-1095,-7594,15613,2073,-1780,2309,7416 } },\n    { \"OLYMPUS E-500\", 0, 0,\n\t{ 8136,-1968,-299,-5481,13742,1871,-2556,4205,6630 } },\n    { \"OLYMPUS E-510\", 0, 0xf6a,\n\t{ 8785,-2529,-1033,-7639,15624,2112,-1783,2300,7817 } },\n    { \"OLYMPUS E-520\", 0, 0xfd2,\n\t{ 8344,-2322,-1020,-7596,15635,2048,-1748,2269,7287 } },\n    { \"OLYMPUS E-5\", 0, 0xeec,\n\t{ 11200,-3783,-1325,-4576,12593,2206,-695,1742,7504 } },\n    { \"OLYMPUS E-600\", 0, 0xfaf,\n\t{ 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },\n    { \"OLYMPUS E-620\", 0, 0xfaf,\n\t{ 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },\n    { \"OLYMPUS E-P1\", 0, 0xffd,\n\t{ 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },\n    { \"OLYMPUS E-P2\", 0, 0xffd,\n\t{ 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },\n    { \"OLYMPUS E-P3\", 0, 0,\n\t{ 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"OLYMPUS E-P5\", 0, 0,\n\t{ 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"OLYMPUS E-PL1s\", 0, 0,\n\t{ 11409,-3872,-1393,-4572,12757,2003,-709,1810,7415 } },\n    { \"OLYMPUS E-PL1\", 0, 0,\n\t{ 11408,-4289,-1215,-4286,12385,2118,-387,1467,7787 } },\n    { \"OLYMPUS E-PL2\", 0, 0,\n\t{ 15030,-5552,-1806,-3987,12387,1767,-592,1670,7023 } },\n    { \"OLYMPUS E-PL3\", 0, 0,\n\t{ 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"OLYMPUS E-PL5\", 0, 0xfcb,\n\t{ 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"OLYMPUS E-PM1\", 0, 0,\n\t{ 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"OLYMPUS E-PM2\", 0, 0,\n\t{ 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"OLYMPUS E-M5\", 0, 0xfe1,\n\t{ 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"OLYMPUS SP350\", 0, 0,\n\t{ 12078,-4836,-1069,-6671,14306,2578,-786,939,7418 } },\n    { \"OLYMPUS SP3\", 0, 0,\n\t{ 11766,-4445,-1067,-6901,14421,2707,-1029,1217,7572 } },\n    { \"OLYMPUS SP500UZ\", 0, 0xfff,\n\t{ 9493,-3415,-666,-5211,12334,3260,-1548,2262,6482 } },\n    { \"OLYMPUS SP510UZ\", 0, 0xffe,\n\t{ 10593,-3607,-1010,-5881,13127,3084,-1200,1805,6721 } },\n    { \"OLYMPUS SP550UZ\", 0, 0xffe,\n\t{ 11597,-4006,-1049,-5432,12799,2957,-1029,1750,6516 } },\n    { \"OLYMPUS SP560UZ\", 0, 0xff9,\n\t{ 10915,-3677,-982,-5587,12986,2911,-1168,1968,6223 } },\n    { \"OLYMPUS SP570UZ\", 0, 0,\n\t{ 11522,-4044,-1146,-4736,12172,2904,-988,1829,6039 } },\n    { \"OLYMPUS XZ-10\", 0, 0,\n\t{ 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },\n    { \"OLYMPUS XZ-1\", 0, 0,\n\t{ 10901,-4095,-1074,-1141,9208,2293,-62,1417,5158 } },\n    { \"OLYMPUS XZ-2\", 0, 0,\n\t{ 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },\n    { \"OmniVision ov5647\", 0, 0,\t/* DJC */\n\t{ 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } },\n    { \"PENTAX *ist DL2\", 0, 0,\n\t{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"PENTAX *ist DL\", 0, 0,\n\t{ 10829,-2838,-1115,-8339,15817,2696,-837,680,11939 } },\n    { \"PENTAX *ist DS2\", 0, 0,\n\t{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"PENTAX *ist DS\", 0, 0,\n\t{ 10371,-2333,-1206,-8688,16231,2602,-1230,1116,11282 } },\n    { \"PENTAX *ist D\", 0, 0,\n\t{ 9651,-2059,-1189,-8881,16512,2487,-1460,1345,10687 } },\n    { \"PENTAX K10D\", 0, 0,\n\t{ 9566,-2863,-803,-7170,15172,2112,-818,803,9705 } },\n    { \"PENTAX K1\", 0, 0,\n\t{ 11095,-3157,-1324,-8377,15834,2720,-1108,947,11688 } },\n    { \"PENTAX K20D\", 0, 0,\n\t{ 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },\n    { \"PENTAX K200D\", 0, 0,\n\t{ 9186,-2678,-907,-8693,16517,2260,-1129,1094,8524 } },\n    { \"PENTAX K2000\", 0, 0,\n\t{ 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },\n    { \"PENTAX K-m\", 0, 0,\n\t{ 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },\n    { \"PENTAX K-x\", 0, 0,\n\t{ 8843,-2837,-625,-5025,12644,2668,-411,1234,7410 } },\n    { \"PENTAX K-r\", 0, 0,\n\t{ 9895,-3077,-850,-5304,13035,2521,-883,1768,6936 } },\n    { \"PENTAX K-30\", 0, 0,\n\t{ 8833,-2670,-1183,-3995,12301,1881,-979,1717,6527 } },\n    { \"PENTAX K-5 II s\", 0, 0,\n\t{ 8366,-2528,-1120,-3995,12301,1881,-998,1749,6649 } },\n    { \"PENTAX K-5 II\", 0, 0,\n\t{ 8773,-2651,-1175,-3995,12301,1881,-973,1706,6486 } },\n    { \"PENTAX K-5\", 0, 0,\n\t{ 8713,-2833,-743,-4342,11900,2772,-722,1543,6247 } },\n    { \"PENTAX K-7\", 0, 0,\n\t{ 9142,-2947,-678,-8648,16967,1663,-2224,2898,8615 } },\n    { \"PENTAX MX-1\", 0, 0,\n\t{ 8804,-2523,-1238,-2423,11627,860,-682,1774,4753 } },\n    { \"PENTAX Q10\", 0, 0,\n\t{ 12995,-5593,-1107,-1879,10139,2027,-64,1233,4919 } },\n    { \"PENTAX 645D\", 0, 0x3e00,\n\t{ 10646,-3593,-1158,-3329,11699,1831,-667,2874,6287 } },\n    { \"Panasonic DMC-FZ8\", 0, 0xf7f,\n\t{ 8986,-2755,-802,-6341,13575,3077,-1476,2144,6379 } },\n    { \"Panasonic DMC-FZ18\", 0, 0,\n\t{ 9932,-3060,-935,-5809,13331,2753,-1267,2155,5575 } },\n    { \"Panasonic DMC-FZ28\", 15, 0xf96,\n\t{ 10109,-3488,-993,-5412,12812,2916,-1305,2140,5543 } },\n    { \"Panasonic DMC-FZ30\", 0, 0xf94,\n\t{ 10976,-4029,-1141,-7918,15491,2600,-1670,2071,8246 } },\n    { \"Panasonic DMC-FZ3\", 143, 0,\n\t{ 9938,-2780,-890,-4604,12393,2480,-1117,2304,4620 } },\n    { \"Panasonic DMC-FZ4\", 143, 0,\n\t{ 13639,-5535,-1371,-1698,9633,2430,316,1152,4108 } },\n    { \"Panasonic DMC-FZ50\", 0, 0,\n\t{ 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\n    { \"LEICA V-LUX1\", 0, 0,\n\t{ 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\n    { \"Panasonic DMC-L10\", 15, 0xf96,\n\t{ 8025,-1942,-1050,-7920,15904,2100,-2456,3005,7039 } },\n    { \"Panasonic DMC-L1\", 0, 0xf7f,\n\t{ 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\n    { \"LEICA DIGILUX 3\", 0, 0xf7f,\n\t{ 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\n    { \"Panasonic DMC-LC1\", 0, 0,\n\t{ 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\n    { \"LEICA DIGILUX 2\", 0, 0,\n\t{ 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\n    { \"Panasonic DMC-LF1\", 143, 0,\n\t{ 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },\n    { \"Panasonic DMC-LX1\", 0, 0xf7f,\n\t{ 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\n    { \"LEICA D-LUX2\", 0, 0xf7f,\n\t{ 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\n    { \"Panasonic DMC-LX2\", 0, 0,\n\t{ 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\n    { \"LEICA D-LUX3\", 0, 0,\n\t{ 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\n    { \"Panasonic DMC-LX3\", 15, 0,\n\t{ 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },\n    { \"LEICA D-LUX 4\", 15, 0,\n\t{ 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },\n    { \"Panasonic DMC-LX5\", 143, 0,\n\t{ 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },\n    { \"Panasonic DMC-LX7\", 143, 0,\n\t{ 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"LEICA D-LUX 5\", 143, 0,\n\t{ 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },\n    { \"Panasonic DMC-LX7\", 143, 0,\n\t{ 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"LEICA D-LUX 6\", 143, 0,\n\t{ 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"Panasonic DMC-FZ100\", 143, 0xfff,\n\t{ 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },\n    { \"LEICA V-LUX 2\", 143, 0xfff,\n\t{ 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },\n    { \"Panasonic DMC-FZ150\", 143, 0xfff,\n\t{ 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },\n    { \"LEICA V-LUX 3\", 143, 0xfff,\n\t{ 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },\n    { \"Panasonic DMC-FZ200\", 143, 0xfff,\n\t{ 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },\n    { \"LEICA V-LUX 4\", 143, 0xfff,\n\t{ 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },\n    { \"Panasonic DMC-FX150\", 15, 0xfff,\n\t{ 9082,-2907,-925,-6119,13377,3058,-1797,2641,5609 } },\n    { \"Panasonic DMC-G10\", 0, 0,\n\t{ 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },\n    { \"Panasonic DMC-G1\", 15, 0xf94,\n\t{ 8199,-2065,-1056,-8124,16156,2033,-2458,3022,7220 } },\n    { \"Panasonic DMC-G2\", 15, 0xf3c,\n\t{ 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },\n    { \"Panasonic DMC-G3\", 143, 0xfff,\n\t{ 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },\n    { \"Panasonic DMC-G5\", 143, 0xfff,\n\t{ 7798,-2562,-740,-3879,11584,2613,-1055,2248,5434 } },\n    { \"Panasonic DMC-G6\", 143, 0xfff,\n\t{ 8294,-2891,-651,-3869,11590,2595,-1183,2267,5352 } },\n    { \"Panasonic DMC-GF1\", 15, 0xf92,\n\t{ 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },\n    { \"Panasonic DMC-GF2\", 143, 0xfff,\n\t{ 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },\n    { \"Panasonic DMC-GF3\", 143, 0xfff,\n\t{ 9051,-2468,-1204,-5212,13276,2121,-1197,2510,6890 } },\n    { \"Panasonic DMC-GF5\", 143, 0xfff,\n\t{ 8228,-2945,-660,-3938,11792,2430,-1094,2278,5793 } },\n    { \"Panasonic DMC-GF6\", 143, 0,\n\t{ 8130,-2801,-946,-3520,11289,2552,-1314,2511,5791 } },\n    { \"Panasonic DMC-GH1\", 15, 0xf92,\n\t{ 6299,-1466,-532,-6535,13852,2969,-2331,3112,5984 } },\n    { \"Panasonic DMC-GH2\", 15, 0xf95,\n\t{ 7780,-2410,-806,-3913,11724,2484,-1018,2390,5298 } },\n    { \"Panasonic DMC-GH3\", 144, 0,\n\t{ 6559,-1752,-491,-3672,11407,2586,-962,1875,5130 } },\n    { \"Panasonic DMC-GX1\", 143, 0,\n\t{ 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },\n    { \"Phase One H 20\", 0, 0,\t\t/* DJC */\n\t{ 1313,1855,-109,-6715,15908,808,-327,1840,6020 } },\n    { \"Phase One H 25\", 0, 0,\n\t{ 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One P 2\", 0, 0,\n\t{ 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One P 30\", 0, 0,\n\t{ 4516,-245,-37,-7020,14976,2173,-3206,4671,7087 } },\n    { \"Phase One P 45\", 0, 0,\n\t{ 5053,-24,-117,-5684,14076,1702,-2619,4492,5849 } },\n    { \"Phase One P40\", 0, 0,\n\t{ 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Phase One P65\", 0, 0,\n\t{ 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"RED ONE\", 704, 0xffff,\t\t/* DJC */\n\t{ 21014,-7891,-2613,-3056,12201,856,-2203,5125,8042 } },\n    { \"SAMSUNG EX1\", 0, 0x3e00,\n\t{ 8898,-2498,-994,-3144,11328,2066,-760,1381,4576 } },\n    { \"SAMSUNG EX2F\", 0, 0x7ff,\n\t{ 10648,-3897,-1055,-2022,10573,1668,-492,1611,4742 } },\n    { \"SAMSUNG NX2\", 0, 0xfff,\t/* NX20, NX200, NX210 */\n\t{ 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"SAMSUNG NX1000\", 0, 0,\n\t{ 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"SAMSUNG NX\", 0, 0,\t/* NX5, NX10, NX11, NX100 */\n\t{ 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"SAMSUNG WB2000\", 0, 0xfff,\n\t{ 12093,-3557,-1155,-1000,9534,1733,-22,1787,4576 } },\n    { \"SAMSUNG GX-1\", 0, 0,\n\t{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"SAMSUNG S85\", 0, 0xffff,\t\t/* DJC */\n\t{ 11885,-3968,-1473,-4214,12299,1916,-835,1655,5549 } },\n    { \"Sinar\", 0, 0,\t\t\t/* DJC */\n\t{ 16442,-2956,-2422,-2877,12128,750,-1136,6066,4559 } },\n    { \"SONY DSC-F828\", 0, 0,\n\t{ 7924,-1910,-777,-8226,15459,2998,-1517,2199,6818,-7242,11401,3481 } },\n    { \"SONY DSC-R1\", 512, 0,\n\t{ 8512,-2641,-694,-8042,15670,2526,-1821,2117,7414 } },\n    { \"SONY DSC-V3\", 0, 0,\n\t{ 7511,-2571,-692,-7894,15088,3060,-948,1111,8128 } },\n    { \"SONY DSC-RX100M2\", 200, 0,\n\t{ 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },\n    { \"SONY DSC-RX100\", 200, 0,\n\t{ 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },\n    { \"SONY DSC-RX1R\", 128, 0,\n\t{ 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n    { \"SONY DSC-RX1\", 128, 0,\n\t{ 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n    { \"SONY DSLR-A100\", 0, 0xfeb,\n\t{ 9437,-2811,-774,-8405,16215,2290,-710,596,7181 } },\n    { \"SONY DSLR-A290\", 0, 0,\n\t{ 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"SONY DSLR-A2\", 0, 0,\n\t{ 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\n    { \"SONY DSLR-A300\", 0, 0,\n\t{ 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\n    { \"SONY DSLR-A330\", 0, 0,\n\t{ 9847,-3091,-929,-8485,16346,2225,-714,595,7103 } },\n    { \"SONY DSLR-A350\", 0, 0xffc,\n\t{ 6038,-1484,-578,-9146,16746,2513,-875,746,7217 } },\n    { \"SONY DSLR-A380\", 0, 0,\n\t{ 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"SONY DSLR-A390\", 0, 0,\n\t{ 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"SONY DSLR-A450\", 128, 0xfeb,\n\t{ 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },\n    { \"SONY DSLR-A580\", 128, 0xfeb,\n\t{ 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },\n    { \"SONY DSLR-A5\", 128, 0xfeb,\n\t{ 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },\n    { \"SONY DSLR-A700\", 126, 0,\n\t{ 5775,-805,-359,-8574,16295,2391,-1943,2341,7249 } },\n    { \"SONY DSLR-A850\", 128, 0,\n\t{ 5413,-1162,-365,-5665,13098,2866,-608,1179,8440 } },\n    { \"SONY DSLR-A900\", 128, 0,\n\t{ 5209,-1072,-397,-8845,16120,2919,-1618,1803,8654 } },\n    { \"SONY NEX-3N\", 128, 0,\t\t/* Adobe */\n\t{ 6129,-1545,\t-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"SONY NEX-3\", 128, 0,\t\t/* Adobe */\n\t{ 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },\n    { \"SONY NEX-5N\", 128, 0,\n\t{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"SONY NEX-5R\", 128, 0,\t\t\n\t{ 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"SONY NEX-5\", 128, 0,\t\t/* Adobe */\n\t{ 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },\n    { \"SONY NEX-6\", 128, 0,\n\t{ 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"SONY NEX-7\", 128, 0,\n\t{ 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"SONY NEX\", 128, 0,\t/* NEX-C3, NEX-F3 */\n\t{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"SONY SLT-A33\", 128, 0,\n\t{ 6069,-1221,-366,-5221,12779,2734,-1024,2066,6834 } },\n    { \"SONY SLT-A35\", 128, 0,\n\t{ 5986,-1618,-415,-4557,11820,3120,-681,1404,6971 } },\n    { \"SONY SLT-A37\", 128, 0,\n\t{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"SONY SLT-A55\", 128, 0,\n\t{ 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },\n    { \"SONY SLT-A57\", 128, 0,\n\t{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"SONY SLT-A58\", 128, 0,\n\t{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"SONY SLT-A65\", 128, 0,\n\t{ 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"SONY SLT-A77\", 128, 0,\n\t{ 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"SONY SLT-A99\", 128, 0,\n\t{ 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n  };\n  double cam_xyz[4][3];\n  char name[130];\n  int i, j;\n\n  sprintf (name, \"%s %s\", t_make, t_model);\n  for (i=0; i < sizeof table / sizeof *table; i++)\n    if (!strncmp (name, table[i].prefix, strlen(table[i].prefix))) {\n      if (table[i].t_black)   black   = (ushort) table[i].t_black;\n      if (table[i].t_maximum) maximum = (ushort) table[i].t_maximum;\n      if (table[i].trans[0]) {\n\tfor (j=0; j < 12; j++)\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.color.cam_xyz[0][j] = \n#endif\n\t  cam_xyz[0][j] = table[i].trans[j] / 10000.0;\n\tcam_xyz_coeff (cam_xyz);\n      }\n      break;\n    }\n}\n\nvoid CLASS simple_coeff (int index)\n{\n  static const float table[][12] = {\n  /* index 0 -- all Foveon cameras */\n  { 1.4032,-0.2231,-0.1016,-0.5263,1.4816,0.017,-0.0112,0.0183,0.9113 },\n  /* index 1 -- Kodak DC20 and DC25 */\n  { 2.25,0.75,-1.75,-0.25,-0.25,0.75,0.75,-0.25,-0.25,-1.75,0.75,2.25 },\n  /* index 2 -- Logitech Fotoman Pixtura */\n  { 1.893,-0.418,-0.476,-0.495,1.773,-0.278,-1.017,-0.655,2.672 },\n  /* index 3 -- Nikon E880, E900, and E990 */\n  { -1.936280,  1.800443, -1.448486,  2.584324,\n     1.405365, -0.524955, -0.289090,  0.408680,\n    -1.204965,  1.082304,  2.941367, -1.818705 }\n  };\n  int i, c;\n\n  for (raw_color = i=0; i < 3; i++)\n    FORCC rgb_cam[i][c] = table[index][i*colors+c];\n}\n\nshort CLASS guess_byte_order (int words)\n{\n  uchar test[4][2];\n  int t=2, msb;\n  double diff, sum[2] = {0,0};\n\n  fread (test[0], 2, 2, ifp);\n  for (words-=2; words--; ) {\n    fread (test[t], 2, 1, ifp);\n    for (msb=0; msb < 2; msb++) {\n      diff = (test[t^2][msb] << 8 | test[t^2][!msb])\n\t   - (test[t  ][msb] << 8 | test[t  ][!msb]);\n      sum[msb] += diff*diff;\n    }\n    t = (t+1) & 3;\n  }\n  return sum[0] < sum[1] ? 0x4d4d : 0x4949;\n}\n\nfloat CLASS find_green (int bps, int bite, int off0, int off1)\n{\n  UINT64 bitbuf=0;\n  int vbits, col, i, c;\n  ushort img[2][2064];\n  double sum[]={0,0};\n\n  FORC(2) {\n    fseek (ifp, c ? off1:off0, SEEK_SET);\n    for (vbits=col=0; col < width; col++) {\n      for (vbits -= bps; vbits < 0; vbits += bite) {\n\tbitbuf <<= bite;\n\tfor (i=0; i < bite; i+=8)\n\t  bitbuf |= (unsigned) (fgetc(ifp) << i);\n      }\n      img[c][col] = bitbuf << (64-bps-vbits) >> (64-bps);\n    }\n  }\n  FORC(width-1) {\n    sum[ c & 1] += ABS(img[0][c]-img[1][c+1]);\n    sum[~c & 1] += ABS(img[1][c]-img[0][c+1]);\n  }\n  return 100 * log(sum[0]/sum[1]);\n}\n\n\n#ifndef LIBRAW_LIBRARY_BUILD\nvoid CLASS identify2(unsigned fsize, unsigned flen, char *head);\n#endif\n\n/*\n   Identify which camera created this file, and set global variables\n   accordingly.\n */\nvoid CLASS identify()\n{\n  char head[32], *cp;\n  int hlen, flen, fsize, zero_fsize=1, i, c, is_canon;\n  struct jhead jh;\n  static const struct {\n    int fsize;\n    char t_make[12], t_model[19], withjpeg;\n  } table[] = {\n    {    62464, \"Kodak\",    \"DC20\"            ,0 },\n    {   124928, \"Kodak\",    \"DC20\"            ,0 },\n    {  1652736, \"Kodak\",    \"DCS200\"          ,0 },\n    {  4159302, \"Kodak\",    \"C330\"            ,0 },\n    {  4162462, \"Kodak\",    \"C330\"            ,0 },\n    {   460800, \"Kodak\",    \"C603v\"           ,0 },\n    {   614400, \"Kodak\",    \"C603v\"           ,0 },\n    {  6163328, \"Kodak\",    \"C603\"            ,0 },\n    {  6166488, \"Kodak\",    \"C603\"            ,0 },\n    {  9116448, \"Kodak\",    \"C603y\"           ,0 },\n    {   311696, \"ST Micro\", \"STV680 VGA\"      ,0 },  /* SPYz */\n    {   787456, \"Creative\", \"PC-CAM 600\"      ,0 },\n    {  1138688, \"Minolta\",  \"RD175\"           ,0 },\n    {  3840000, \"Foculus\",  \"531C\"            ,0 },\n    {   307200, \"Generic\",  \"640x480\"         ,0 },\n    {   786432, \"AVT\",      \"F-080C\"          ,0 },\n    {  1447680, \"AVT\",      \"F-145C\"          ,0 },\n    {  1920000, \"AVT\",      \"F-201C\"          ,0 },\n    {  5067304, \"AVT\",      \"F-510C\"          ,0 },\n    {  5067316, \"AVT\",      \"F-510C\"          ,0 },\n    { 10134608, \"AVT\",      \"F-510C\"          ,0 },\n    { 10134620, \"AVT\",      \"F-510C\"          ,0 },\n    { 16157136, \"AVT\",      \"F-810C\"          ,0 },\n    {  1409024, \"Sony\",     \"XCD-SX910CR\"     ,0 },\n    {  2818048, \"Sony\",     \"XCD-SX910CR\"     ,0 },\n    {  3884928, \"Micron\",   \"2010\"            ,0 },\n    {  6624000, \"Pixelink\", \"A782\"            ,0 },\n    { 13248000, \"Pixelink\", \"A782\"            ,0 },\n    {  6291456, \"RoverShot\",\"3320AF\"          ,0 },\n    {  6553440, \"Canon\",    \"PowerShot A460\"  ,0 },\n    {  6653280, \"Canon\",    \"PowerShot A530\"  ,0 },\n    {  6573120, \"Canon\",    \"PowerShot A610\"  ,0 },\n    {  9219600, \"Canon\",    \"PowerShot A620\"  ,0 },\n    {  9243240, \"Canon\",    \"PowerShot A470\"  ,0 },\n    { 10341600, \"Canon\",    \"PowerShot A720 IS\",0 },\n    { 10383120, \"Canon\",    \"PowerShot A630\"  ,0 },\n    { 12945240, \"Canon\",    \"PowerShot A640\"  ,0 },\n    { 15636240, \"Canon\",    \"PowerShot A650\"  ,0 },\n    {  5298000, \"Canon\",    \"PowerShot SD300\" ,0 },\n    {  7710960, \"Canon\",    \"PowerShot S3 IS\" ,0 },\n    { 15467760, \"Canon\",    \"PowerShot SX110 IS\",0 },\n    { 15534576, \"Canon\",    \"PowerShot SX120 IS\",0 },\n    { 18653760, \"Canon\",    \"PowerShot SX20 IS\",0 },\n    { 19131120, \"Canon\",    \"PowerShot SX220 HS\",0 },\n    { 21936096, \"Canon\",    \"PowerShot SX30 IS\",0 },\n    {  5939200, \"OLYMPUS\",  \"C770UZ\"          ,0 },\n    {  1581060, \"NIKON\",    \"E900\"            ,1 },  /* or E900s,E910 */\n    {  2465792, \"NIKON\",    \"E950\"            ,1 },  /* or E800,E700 */\n    {  2940928, \"NIKON\",    \"E2100\"           ,1 },  /* or E2500 */\n    {  4771840, \"NIKON\",    \"E990\"            ,1 },  /* or E995, Oly C3030Z */\n    {  4775936, \"NIKON\",    \"E3700\"           ,1 },  /* or Optio 33WR */\n    {  5869568, \"NIKON\",    \"E4300\"           ,1 },  /* or DiMAGE Z2 */\n    {  5865472, \"NIKON\",    \"E4500\"           ,1 },\n    {  7438336, \"NIKON\",    \"E5000\"           ,1 },  /* or E5700 */\n    {  8998912, \"NIKON\",    \"COOLPIX S6\"      ,1 },\n    {  1976352, \"CASIO\",    \"QV-2000UX\"       ,1 },\n    {  3217760, \"CASIO\",    \"QV-3*00EX\"       ,1 },\n    {  6218368, \"CASIO\",    \"QV-5700\"         ,1 },\n    {  6054400, \"CASIO\",    \"QV-R41\"          ,1 },\n    {  7530816, \"CASIO\",    \"QV-R51\"          ,1 },\n    {  7684000, \"CASIO\",    \"QV-4000\"         ,1 },\n    {  2937856, \"CASIO\",    \"EX-S20\"          ,1 },\n    {  4948608, \"CASIO\",    \"EX-S100\"         ,1 },\n    {  7542528, \"CASIO\",    \"EX-Z50\"          ,1 },\n    {  7562048, \"CASIO\",    \"EX-Z500\"         ,1 },\n    {  7753344, \"CASIO\",    \"EX-Z55\"          ,1 },\n    {  7816704, \"CASIO\",    \"EX-Z60\"          ,1 },\n    { 10843712, \"CASIO\",    \"EX-Z75\"          ,1 },\n    { 10834368, \"CASIO\",    \"EX-Z750\"         ,1 },\n    { 12310144, \"CASIO\",    \"EX-Z850\"         ,1 },\n    { 12489984, \"CASIO\",    \"EX-Z8\"           ,1 },\n    { 15499264, \"CASIO\",    \"EX-Z1050\"        ,1 },\n    { 18702336, \"CASIO\",    \"EX-ZR100\"        ,1 },\n    {  7426656, \"CASIO\",    \"EX-P505\"         ,1 },\n    {  9313536, \"CASIO\",    \"EX-P600\"         ,1 },\n    { 10979200, \"CASIO\",    \"EX-P700\"         ,1 },\n    {  3178560, \"PENTAX\",   \"Optio S\"         ,1 },\n    {  4841984, \"PENTAX\",   \"Optio S\"         ,1 },\n    {  6114240, \"PENTAX\",   \"Optio S4\"        ,1 },  /* or S4i, CASIO EX-Z4 */\n    { 10702848, \"PENTAX\",   \"Optio 750Z\"      ,1 },\n    { 15980544, \"AGFAPHOTO\",\"DC-833m\"         ,1 },\n    { 16098048, \"SAMSUNG\",  \"S85\"             ,1 },\n    { 16215552, \"SAMSUNG\",  \"S85\"             ,1 },\n    { 20487168, \"SAMSUNG\",  \"WB550\"           ,1 },\n    { 24000000, \"SAMSUNG\",  \"WB550\"           ,1 },\n    { 9994240, \"ptGrey\", \"GRAS-50S5C\" ,0 }, // KC: SUPPORT GRASSHOPPER\n    { 10075968, \"JaiPulnix\",\"BB-500CL\" ,0 }, // KC: SUPPORT BB-500CL\n    { 10108896, \"JaiPulnix\",\"BB-500GE\" ,0 }, // KC: SUPPORT BB-500GE\n    { 10036800, \"SVS\", \"SVS625CL\" ,0 }, // KC: SUPPORT SVS625 cameralink\n    { 12582980, \"Sinar\",    \"\"                ,0 },\n    { 33292868, \"Sinar\",    \"\"                ,0 },\n    { 44390468, \"Sinar\",    \"\"                ,0 } };\n  static const char *corp[] =\n    { \"Canon\", \"NIKON\", \"EPSON\", \"KODAK\", \"Kodak\", \"OLYMPUS\", \"PENTAX\",\n      \"MINOLTA\", \"Minolta\", \"Konica\", \"CASIO\", \"Sinar\", \"Phase One\",\n      \"SAMSUNG\", \"Mamiya\", \"MOTOROLA\", \"LEICA\" };\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY,0,2);\n#endif\n\n  tiff_flip = flip = filters = -1;\t/* 0 is valid, so -1 is unknown */\n  raw_height = raw_width = fuji_width = fuji_layout = cr2_slice[0] = 0;\n  maximum = height = width = top_margin = left_margin = 0;\n  cdesc[0] = desc[0] = artist[0] = make[0] = model[0] = model2[0] = 0;\n  iso_speed = shutter = aperture = focal_len = unique_id = 0;\n  tiff_nifds = 0;\n  memset (tiff_ifd, 0, sizeof tiff_ifd);\n  memset (gpsdata, 0, sizeof gpsdata);\n  memset (cblack, 0, sizeof cblack);\n  memset (white, 0, sizeof white);\n  memset (mask, 0, sizeof mask);\n  thumb_offset = thumb_length = thumb_width = thumb_height = 0;\n  load_raw = thumb_load_raw = 0;\n  write_thumb = &CLASS jpeg_thumb;\n  data_offset = meta_length = tiff_bps = tiff_compress = 0;\n  kodak_cbpp = zero_after_ff = dng_version = load_flags = 0;\n  timestamp = shot_order = tiff_samples = black = is_foveon = 0;\n  mix_green = profile_length = data_error = zero_is_bad = 0;\n  pixel_aspect = is_raw = raw_color = 1;\n  tile_width = tile_length = 0;\n  for (i=0; i < 4; i++) {\n    cam_mul[i] = i == 1;\n    pre_mul[i] = i < 3;\n    FORC3 cmatrix[c][i] = 0;\n    FORC3 rgb_cam[c][i] = c == i;\n  }\n  colors = 3;\n  for (i=0; i < 0x10000; i++) curve[i] = i;\n\n  order = get2();\n  hlen = get4();\n  fseek (ifp, 0, SEEK_SET);\n  fread (head, 1, 32, ifp);\n  fseek (ifp, 0, SEEK_END);\n  flen = fsize = ftell(ifp);\n  if ((cp = (char *) memmem (head, 32, (char*)\"MMMM\", 4)) ||\n      (cp = (char *) memmem (head, 32, (char*)\"IIII\", 4))) {\n    parse_phase_one (cp-head);\n    if (cp-head && parse_tiff(0)) apply_tiff();\n  } else if (order == 0x4949 || order == 0x4d4d) {\n    if (!memcmp (head+6,\"HEAPCCDR\",8)) {\n      data_offset = hlen;\n      parse_ciff (hlen, flen - hlen);\n    } else if (parse_tiff(0)) apply_tiff();\n  } else if (!memcmp (head,\"\\xff\\xd8\\xff\\xe1\",4) &&\n\t     !memcmp (head+6,\"Exif\",4)) {\n    fseek (ifp, 4, SEEK_SET);\n    data_offset = 4 + get2();\n    fseek (ifp, data_offset, SEEK_SET);\n    if (fgetc(ifp) != 0xff)\n      parse_tiff(12);\n    thumb_offset = 0;\n  } else if (!memcmp (head+25,\"ARECOYK\",7)) {\n    strcpy (make, \"Contax\");\n    strcpy (model,\"N Digital\");\n    fseek (ifp, 33, SEEK_SET);\n    get_timestamp(1);\n    fseek (ifp, 60, SEEK_SET);\n    FORC4 cam_mul[c ^ (c >> 1)] = get4();\n  } else if (!strcmp (head, \"PXN\")) {\n    strcpy (make, \"Logitech\");\n    strcpy (model,\"Fotoman Pixtura\");\n  } else if (!strcmp (head, \"qktk\")) {\n    strcpy (make, \"Apple\");\n    strcpy (model,\"QuickTake 100\");\n    load_raw = &CLASS quicktake_100_load_raw;\n  } else if (!strcmp (head, \"qktn\")) {\n    strcpy (make, \"Apple\");\n    strcpy (model,\"QuickTake 150\");\n    load_raw = &CLASS kodak_radc_load_raw;\n  } else if (!memcmp (head,\"FUJIFILM\",8)) {\n    fseek (ifp, 84, SEEK_SET);\n    thumb_offset = get4();\n    thumb_length = get4();\n    fseek (ifp, 92, SEEK_SET);\n    parse_fuji (get4());\n    if (thumb_offset > 120) {\n      fseek (ifp, 120, SEEK_SET);\n      is_raw += (i = get4()) && 1;\n      if (is_raw == 2 && shot_select)\n\tparse_fuji (i);\n    }\n    load_raw = &CLASS unpacked_load_raw;\n    fseek (ifp, 100+28*(shot_select > 0), SEEK_SET);\n    parse_tiff (data_offset = get4());\n    parse_tiff (thumb_offset+12);\n    apply_tiff();\n  } else if (!memcmp (head,\"RIFF\",4)) {\n    fseek (ifp, 0, SEEK_SET);\n    parse_riff();\n  } else if (!memcmp (head,\"\\0\\001\\0\\001\\0@\",6)) {\n    fseek (ifp, 6, SEEK_SET);\n    fread (make, 1, 8, ifp);\n    fread (model, 1, 8, ifp);\n    fread (model2, 1, 16, ifp);\n    data_offset = get2();\n    get2();\n    raw_width = get2();\n    raw_height = get2();\n    load_raw = &CLASS nokia_load_raw;\n    filters = 0x61616161;\n  } else if (!memcmp (head,\"NOKIARAW\",8)) {\n    strcpy (make, \"NOKIA\");\n    strcpy (model, \"X2\");\n    order = 0x4949;\n    fseek (ifp, 300, SEEK_SET);\n    data_offset = get4();\n    i = get4();\n    width = get2();\n    height = get2();\n    data_offset += i - width * 5 / 4 * height;\n    load_raw = &CLASS nokia_load_raw;\n    filters = 0x61616161;\n  } else if (!memcmp (head,\"ARRI\",4)) {\n    order = 0x4949;\n    fseek (ifp, 20, SEEK_SET);\n    width = get4();\n    height = get4();\n    strcpy (make, \"ARRI\");\n    fseek (ifp, 668, SEEK_SET);\n    fread (model, 1, 64, ifp);\n    data_offset = 4096;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 88;\n    filters = 0x61616161;\n  } else if (!memcmp (head+4,\"RED1\",4)) {\n    strcpy (make, \"RED\");\n    strcpy (model,\"ONE\");\n    parse_redcine();\n    load_raw = &CLASS redcine_load_raw;\n    gamma_curve (1/2.4, 12.92, 1, 4095);\n    filters = 0x49494949;\n  } else if (!memcmp (head,\"DSC-Image\",9))\n    parse_rollei();\n  else if (!memcmp (head,\"PWAD\",4))\n    parse_sinar_ia();\n  else if (!memcmp (head,\"\\0MRM\",4))\n    parse_minolta(0);\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n  else if (!memcmp (head,\"FOVb\",4))\n    parse_foveon();\n#endif\n  else if (!memcmp (head,\"CI\",2))\n    parse_cine();\n  else\n    for (zero_fsize=i=0; i < sizeof table / sizeof *table; i++)\n      if (fsize == table[i].fsize) {\n\tstrcpy (make,  table[i].t_make );\n\tstrcpy (model, table[i].t_model);\n\tif (table[i].withjpeg)\n\t  parse_external_jpeg();\n      }\n  if (zero_fsize) fsize = 0;\n  if (make[0] == 0) parse_smal (0, flen);\n  if (make[0] == 0) {\n    parse_jpeg(0);\n    fseek(ifp,0,SEEK_END);\n    int sz = ftell(ifp);\n    if (!strncmp(model,\"ov\",2) && sz>=6404096 && !fseek (ifp, -6404096, SEEK_END) &&\n\tfread (head, 1, 32, ifp) && !strcmp(head,\"BRCMn\")) {\n      strcpy (make, \"OmniVision\");\n      data_offset = ftell(ifp) + 0x8000-32;\n      width = raw_width;\n      raw_width = 2611;\n      load_raw = &CLASS nokia_load_raw;\n      filters = 0x16161616;\n    } else is_raw = 0;\n  }\n\n  for (i=0; i < sizeof corp / sizeof *corp; i++)\n    if (strstr (make, corp[i]))\t\t/* Simplify company names */\n\tstrcpy (make, corp[i]);\n  if (!strncmp (make,\"KODAK\",5) &&\n\t((cp = strstr(model,\" DIGITAL CAMERA\")) ||\n\t (cp = strstr(model,\" Digital Camera\")) ||\n\t (cp = strstr(model,\"FILE VERSION\"))))\n     *cp = 0;\n  cp = make + strlen(make);\t\t/* Remove trailing spaces */\n  while (*--cp == ' ') *cp = 0;\n  cp = model + strlen(model);\n  while (*--cp == ' ') *cp = 0;\n  i = strlen(make);\t\t\t/* Remove make from model */\n  if (!strncasecmp (model, make, i) && model[i++] == ' ')\n    memmove (model, model+i, 64-i);\n  if (!strncmp (model,\"FinePix \",8))\n    strcpy (model, model+8);\n  if (!strncmp (model,\"Digital Camera \",15))\n    strcpy (model, model+15);\n  desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;\n  if (!is_raw) goto notraw;\n\n  if (!height) height = raw_height;\n  if (!width)  width  = raw_width;\n  if (height == 2624 && width == 3936)\t/* Pentax K10D and Samsung GX10 */\n    { height  = 2616;   width  = 3896; }\n  if (height == 3136 && width == 4864)  /* Pentax K20D and Samsung GX20 */\n    { height  = 3124;   width  = 4688; filters = 0x16161616; }\n  if (width == 4352 && (!strcmp(model,\"K-r\") || !strcmp(model,\"K-x\")))\n    {\t\t\twidth  = 4309; filters = 0x16161616; }\n  if (width >= 4960 && !strncmp(model,\"K-5\",3))\n    { left_margin = 10; width  = 4950; filters = 0x16161616; }\n  if (width >= 4960 && !strncmp(model,\"K-5 II\",6))\n    { left_margin = 10; width  = 4948; filters = 0x16161616; }\n  if (width == 4736 && !strcmp(model,\"K-7\"))\n    { height  = 3122;   width  = 4684; filters = 0x16161616; top_margin = 2; }\n  if (width == 7424 && !strcmp(model,\"645D\"))\n    { height  = 5502;   width  = 7328; filters = 0x61616161; top_margin = 29;\n      left_margin = 48; }\n  if (height == 3014 && width == 4096)\t/* Ricoh GX200 */\n\t\t\twidth  = 4014;\n  if (dng_version) {\n    if (filters == UINT_MAX) filters = 0;\n    if (filters) is_raw = tiff_samples;\n    else\t colors = tiff_samples;\n    if (tiff_compress == 1)\n      load_raw = &CLASS packed_dng_load_raw;\n    if (tiff_compress == 7)\n      load_raw = &CLASS lossless_dng_load_raw;\n    goto dng_skip;\n  }\n  if ((is_canon = !strcmp(make,\"Canon\")))\n    load_raw = memcmp (head+6,\"HEAPCCDR\",8) ?\n\t&CLASS lossless_jpeg_load_raw : &CLASS canon_load_raw;\n  if (!strcmp(make,\"NIKON\")) {\n    if (!load_raw)\n      load_raw = &CLASS packed_load_raw;\n    if (model[0] == 'E')\n      load_flags |= !data_offset << 2 | 2;\n  }\n  if (!strcmp(make,\"CASIO\")) {\n    load_raw = &CLASS packed_load_raw;\n    maximum = 0xf7f;\n  }\n\n/* Set parameters based on camera name (for non-DNG files). */\n\n  if (is_foveon) {\n    if (height*2 < width) pixel_aspect = 0.5;\n    if (height   > width) pixel_aspect = 2;\n    filters = 0;\n    simple_coeff(0);\n  } else if (is_canon && tiff_bps == 15) {\n    switch (width) {\n      case 3344: width -= 66;\n      case 3872: width -= 6;\n    }\n    if (height > width) SWAP(height,width);\n    filters = 0;\n    load_raw = &CLASS canon_sraw_load_raw;\n  } else if (!strcmp(model,\"PowerShot 600\")) {\n    height = 613;\n    width  = 854;\n    raw_width = 896;\n    pixel_aspect = 607/628.0;\n    colors = 4;\n    filters = 0xe1e4e1e4;\n    load_raw = &CLASS canon_600_load_raw;\n  } else if (!strcmp(model,\"PowerShot A5\") ||\n\t     !strcmp(model,\"PowerShot A5 Zoom\")) {\n    height = 773;\n    width  = 960;\n    raw_width = 992;\n    pixel_aspect = 256/235.0;\n    colors = 4;\n    filters = 0x1e4e1e4e;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A50\")) {\n    height =  968;\n    width  = 1290;\n    raw_width = 1320;\n    colors = 4;\n    filters = 0x1b4e4b1e;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot Pro70\")) {\n    height = 1024;\n    width  = 1552;\n    colors = 4;\n    filters = 0x1e4b4e1b;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot SD300\")) {\n    height = 1752;\n    width  = 2344;\n    raw_height = 1766;\n    raw_width  = 2400;\n    top_margin  = 12;\n    left_margin = 12;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A460\")) {\n    height = 1960;\n    width  = 2616;\n    raw_height = 1968;\n    raw_width  = 2664;\n    top_margin  = 4;\n    left_margin = 4;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A530\")) {\n    height = 1984;\n    width  = 2620;\n    raw_height = 1992;\n    raw_width  = 2672;\n    top_margin  = 6;\n    left_margin = 10;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A610\")) {\n    if (canon_s2is()) strcpy (model+10, \"S2 IS\");\n    height = 1960;\n    width  = 2616;\n    raw_height = 1968;\n    raw_width  = 2672;\n    top_margin  = 8;\n    left_margin = 12;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A620\")) {\n    height = 2328;\n    width  = 3112;\n    raw_height = 2340;\n    raw_width  = 3152;\n    top_margin  = 12;\n    left_margin = 36;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A470\")) {\n    height = 2328;\n    width  = 3096;\n    raw_height = 2346;\n    raw_width  = 3152;\n    top_margin  = 6;\n    left_margin = 12;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A720 IS\")) {\n    height = 2472;\n    width  = 3298;\n    raw_height = 2480;\n    raw_width  = 3336;\n    top_margin  = 5;\n    left_margin = 6;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A630\")) {\n    height = 2472;\n    width  = 3288;\n    raw_height = 2484;\n    raw_width  = 3344;\n    top_margin  = 6;\n    left_margin = 12;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A640\")) {\n    height = 2760;\n    width  = 3672;\n    raw_height = 2772;\n    raw_width  = 3736;\n    top_margin  = 6;\n    left_margin = 12;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A650\")) {\n    height = 3024;\n    width  = 4032;\n    raw_height = 3048;\n    raw_width  = 4104;\n    top_margin  = 12;\n    left_margin = 48;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot S3 IS\")) {\n    height = 2128;\n    width  = 2840;\n    raw_height = 2136;\n    raw_width  = 2888;\n    top_margin  = 8;\n    left_margin = 44;\ncanon_a5:\n    tiff_bps = 10;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 40;\n    if (raw_width > 1600) zero_is_bad = 1;\n  } else if (!strcmp(model,\"PowerShot SX110 IS\")) {\n    height = 2760;\n    width  = 3684;\n    raw_height = 2772;\n    raw_width  = 3720;\n    top_margin  = 12;\n    left_margin = 6;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 40;\n    zero_is_bad = 1;\n  } else if (!strcmp(model,\"PowerShot SX120 IS\")) {\n    height = 2742;\n    width  = 3664;\n    raw_height = 2778;\n    raw_width  = 3728;\n    top_margin  = 18;\n    left_margin = 16;\n    filters = 0x49494949;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 40;\n    zero_is_bad = 1;\n  } else if (!strcmp(model,\"PowerShot SX20 IS\")) {\n    height = 3024;\n    width  = 4032;\n    raw_height = 3048;\n    raw_width  = 4080;\n    top_margin  = 12;\n    left_margin = 24;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 40;\n    zero_is_bad = 1;\n  } else if (!strcmp(model,\"PowerShot SX220 HS\")) {\n    height = 3043;\n    width  = 4072;\n    raw_height = 3060;\n    raw_width  = 4168;\n    mask[0][0] = top_margin = 16;\n    mask[0][2] = top_margin + height;\n    mask[0][3] = left_margin = 92;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 8;\n    zero_is_bad = 1;\n  } else if (!strcmp(model,\"PowerShot SX50 HS\")) {\n    top_margin=16;\n    left_margin=94;\n    height = 3043;\n    width  = 4072;\n  } else if (!strcmp(model,\"PowerShot SX30 IS\")) {\n    height = 3254;\n    width  = 4366;\n    raw_height = 3276;\n    raw_width  = 4464;\n    top_margin  = 10;\n    left_margin = 25;\n    filters = 0x16161616;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 40;\n    zero_is_bad = 1;\n  } else if (!strcmp(model,\"PowerShot Pro90 IS\")) {\n    width  = 1896;\n    colors = 4;\n    filters = 0xb4b4b4b4;\n  } else if (is_canon && raw_width == 2144) {\n    height = 1550;\n    width  = 2088;\n    top_margin  = 8;\n    left_margin = 4;\n    if (!strcmp(model,\"PowerShot G1\")) {\n      colors = 4;\n      filters = 0xb4b4b4b4;\n    }\n  } else if (is_canon && raw_width == 2224) {\n    height = 1448;\n    width  = 2176;\n    top_margin  = 6;\n    left_margin = 48;\n  } else if (is_canon && raw_width == 2376) {\n    height = 1720;\n    width  = 2312;\n    top_margin  = 6;\n    left_margin = 12;\n  } else if (is_canon && raw_width == 2672) {\n    height = 1960;\n    width  = 2616;\n    top_margin  = 6;\n    left_margin = 12;\n  } else if (is_canon && raw_width == 3152) {\n    height = 2056;\n    width  = 3088;\n    top_margin  = 12;\n    left_margin = 64;\n    if (unique_id == 0x80000170)\n      adobe_coeff (\"Canon\",\"EOS 300D\");\n  } else if (is_canon && raw_width == 3160) {\n    height = 2328;\n    width  = 3112;\n    top_margin  = 12;\n    left_margin = 44;\n  } else if (is_canon && raw_width == 3344) {\n    height = 2472;\n    width  = 3288;\n    top_margin  = 6;\n    left_margin = 4;\n  } else if (!strcmp(model,\"EOS D2000C\")) {\n    filters = 0x61616161;\n    black = curve[200];\n  } else if (is_canon && raw_width == 3516) {\n    top_margin  = 14;\n    left_margin = 42;\n    if (unique_id == 0x80000189)\n      adobe_coeff (\"Canon\",\"EOS 350D\");\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 3596) {\n    top_margin  = 12;\n    left_margin = 74;\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 3744) {\n    height = 2760;\n    width  = 3684;\n    top_margin  = 16;\n    left_margin = 8;\n    if (unique_id > 0x2720000) {\n      top_margin  = 12;\n      left_margin = 52;\n    }\n  } else if (is_canon && raw_width == 3944) {\n    height = 2602;\n    width  = 3908;\n    top_margin  = 18;\n    left_margin = 30;\n  } else if (is_canon && raw_width == 3948) {\n    top_margin  = 18;\n    left_margin = 42;\n    height -= 2;\n    if (unique_id == 0x80000236)\n      adobe_coeff (\"Canon\",\"EOS 400D\");\n    if (unique_id == 0x80000254)\n      adobe_coeff (\"Canon\",\"EOS 1000D\");\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 3984) {\n    top_margin  = 20;\n    left_margin = 76;\n    height -= 2;\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 4104) {\n    height = 3024;\n    width  = 4032;\n    top_margin  = 12;\n    left_margin = 48;\n  } else if (is_canon && raw_width == 4152) {\n    top_margin  = 12;\n    left_margin = 192;\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 4160) {\n    height = 3048;\n    width  = 4048;\n    top_margin  = 11;\n    left_margin = 104;\n  } else if (is_canon && raw_width == 4176) {\n    height = 3045;\n    width  = 4072;\n    left_margin = 96;\n    mask[0][0] = top_margin = 17;\n    mask[0][2] = raw_height;\n    mask[0][3] = 80;\n    filters = 0x49494949;\n  } else if (is_canon && raw_width == 4312) {\n    top_margin  = 18;\n    left_margin = 22;\n    height -= 2;\n    if (unique_id == 0x80000176)\n      adobe_coeff (\"Canon\",\"EOS 450D\");\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 4352) {\n    top_margin  = 18;\n    left_margin = 62;\n    if (unique_id == 0x80000288)\n      adobe_coeff (\"Canon\",\"EOS 1100D\");\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 4476) {\n    top_margin  = 34;\n    left_margin = 90;\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 4480) {\n    height = 3326;\n    width  = 4432;\n    top_margin  = 10;\n    left_margin = 12;\n    filters = 0x49494949;\n  } else if (is_canon && raw_width == 4496) {\n    height = 3316;\n    width  = 4404;\n    top_margin  = 50;\n    left_margin = 80;\n  } else if (is_canon && raw_width == 4832) {\n    top_margin = unique_id == 0x80000261 ? 51:26;\n    left_margin = 62;\n    if (unique_id == 0x80000252)\n      adobe_coeff (\"Canon\",\"EOS 500D\");\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 5108) {\n    top_margin  = 13;\n    left_margin = 98;\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 5120) {\n    height -= top_margin = 45;\n    left_margin = 142;\n    width = 4916;\n  } else if (is_canon && raw_width == 5280) {\n    top_margin  = 52;\n    left_margin = 72;\n    if (unique_id == 0x80000301)\n      adobe_coeff (\"Canon\",\"EOS 650D\");\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 5344) {\n    top_margin = 51;\n    left_margin = 142;\n    if (unique_id == 0x80000269) {\n      top_margin = 100;\n      left_margin = 126;\n      height -= 2;\n      adobe_coeff (\"Canon\",\"EOS-1D X\");\n    }\n    if (unique_id == 0x80000270)\n      adobe_coeff (\"Canon\",\"EOS 550D\");\n    if (unique_id == 0x80000286)\n      adobe_coeff (\"Canon\",\"EOS 600D\");\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 5360) {\n    top_margin = 51;\n    left_margin = 158;\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 5568) {\n    top_margin = 38;\n    left_margin = 72;\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 5712) {\n    height = 3752;\n    width  = 5640;\n    top_margin  = 20;\n    left_margin = 62;\n  } else if (is_canon && raw_width == 5792) {\n    top_margin  = 51;\n    left_margin = 158;\ncanon_cr2:\n    height -= top_margin;\n    width  -= left_margin;\n  } else if (is_canon && raw_width == 5920) {\n    height = 3870;\n    width  = 5796;\n    top_margin  = 80;\n    left_margin = 122;\n  } else if (!strcmp(model,\"D1\")) {\n    cam_mul[0] *= 256/527.0;\n    cam_mul[2] *= 256/317.0;\n  } else if (!strcmp(model,\"D1X\")) {\n    width -= 4;\n    pixel_aspect = 0.5;\n  } else if (!strcmp(model,\"D40X\") ||\n\t     !strcmp(model,\"D60\")  ||\n\t     !strcmp(model,\"D80\")  ||\n\t     !strcmp(model,\"D3000\")) {\n    height -= 3;\n    width  -= 4;\n  } else if (!strcmp(model,\"D3\")   ||\n\t     !strcmp(model,\"D3S\")  ||\n\t     !strcmp(model,\"D700\")) {\n    width -= 4;\n    left_margin = 2;\n  } else if (!strcmp(model,\"D3100\")) {\n    width -= 28;\n    left_margin = 6;\n  } else if (!strcmp(model,\"D5000\") ||\n\t     !strcmp(model,\"D90\")) {\n    width -= 42;\n  } else if (!strcmp(model,\"D5100\") ||\n\t     !strcmp(model,\"D7000\")) {\n    width -= 44;\n  } else if (!strcmp(model,\"D3200\") ||\n\t     !strcmp(model,\"D800E\") ||\n\t     !strcmp(model,\"D600\")  ||\n\t     !strcmp(model,\"D800\")) {\n    width -= 46;\n  } else if (!strcmp(model,\"D4\")) {\n    width -= 52;\n    left_margin = 2;\n  } else if (!strcmp(model,\"D600\")) {\n    width -= 48;\n  } else if (!strncmp(model,\"D40\",3) ||\n\t     !strncmp(model,\"D50\",3) ||\n\t     !strncmp(model,\"D70\",3)) {\n    width--;\n  } else if (!strcmp(model,\"D100\")) {\n    if (load_flags)\n      raw_width = (width += 3) + 3;\n  } else if (!strcmp(model,\"D200\")) {\n    left_margin = 1;\n    width -= 4;\n    filters = 0x94949494;\n  } else if (!strncmp(model,\"D2H\",3)) {\n    left_margin = 6;\n    width -= 14;\n  } else if (!strncmp(model,\"D2X\",3)) {\n    if (width == 3264) width -= 32;\n    else width -= 8;\n  } else if (!strncmp(model,\"D300\",4)) {\n    width -= 32;\n  } else if (!strcmp(make,\"NIKON\") && raw_width == 4032) {\n    adobe_coeff (\"NIKON\",\"COOLPIX P7700\");\n  } else if (!strncmp(model,\"COOLPIX P\",9)) {\n    load_flags = 24;\n    filters = 0x94949494;\n    if (model[9] == '7' && iso_speed >= 400)\n      black = 255;\n  } else if (!strncmp(model,\"COOLPIX A\",9) && raw_width == 4992) {\n\t  width = 4948;\n  } else if (!strncmp(model,\"1 \",2)) {\n    height -= 2;\n  } else if (fsize == 1581060) {\n    height = 963;\n    width = 1287;\n    raw_width = 1632;\n    maximum = 0x3f4;\n    colors = 4;\n    filters = 0x1e1e1e1e;\n    simple_coeff(3);\n    pre_mul[0] = 1.2085;\n    pre_mul[1] = 1.0943;\n    pre_mul[3] = 1.1103;\n    goto e900;\n  } else if (fsize == 2465792) {\n    height = 1203;\n    width  = 1616;\n    raw_width = 2048;\n    colors = 4;\n    filters = 0x4b4b4b4b;\n    adobe_coeff (\"NIKON\",\"E950\");\ne900:\n    tiff_bps = 10;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 6;\n  } else if (fsize == 4771840) {\n    height = 1540;\n    width  = 2064;\n    colors = 4;\n    filters = 0xe1e1e1e1;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 6;\n    if (!timestamp && nikon_e995())\n      strcpy (model, \"E995\");\n    if (strcmp(model,\"E995\")) {\n      filters = 0xb4b4b4b4;\n      simple_coeff(3);\n      pre_mul[0] = 1.196;\n      pre_mul[1] = 1.246;\n      pre_mul[2] = 1.018;\n    }\n  } else if (!strcmp(model,\"E2100\")) {\n    if (!timestamp && !nikon_e2100()) goto cp_e2500;\n    height = 1206;\n    width  = 1616;\n    load_flags = 30;\n  } else if (!strcmp(model,\"E2500\")) {\ncp_e2500:\n    strcpy (model, \"E2500\");\n    height = 1204;\n    width  = 1616;\n    colors = 4;\n    filters = 0x4b4b4b4b;\n  } else if (fsize == 4775936) {\n    height = 1542;\n    width  = 2064;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 30;\n    if (!timestamp) nikon_3700();\n    if (model[0] == 'E' && atoi(model+1) < 3700)\n      filters = 0x49494949;\n    if (!strcmp(model,\"Optio 33WR\")) {\n      flip = 1;\n      filters = 0x16161616;\n    }\n    if (make[0] == 'O') {\n      i = find_green (12, 32, 1188864, 3576832);\n      c = find_green (12, 32, 2383920, 2387016);\n      if (abs(i) < abs(c)) {\n\tSWAP(i,c);\n\tload_flags = 24;\n      }\n      if (i < 0) filters = 0x61616161;\n    }\n  } else if (fsize == 5869568) {\n    height = 1710;\n    width  = 2288;\n    filters = 0x16161616;\n    if (!timestamp && minolta_z2()) {\n      strcpy (make, \"Minolta\");\n      strcpy (model,\"DiMAGE Z2\");\n    }\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 6 + 24*(make[0] == 'M');\n  } else if (!strcmp(model,\"E4500\")) {\n    height = 1708;\n    width  = 2288;\n    colors = 4;\n    filters = 0xb4b4b4b4;\n  } else if (fsize == 7438336) {\n    height = 1924;\n    width  = 2576;\n    colors = 4;\n    filters = 0xb4b4b4b4;\n  } else if (fsize == 8998912) {\n    height = 2118;\n    width  = 2832;\n    maximum = 0xf83;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 30;\n  } else if (!strcmp(make,\"FUJIFILM\")) {\n    if (!strcmp(model+7,\"S2Pro\")) {\n      strcpy (model,\"S2Pro\");\n      height = 2144;\n      width  = 2880;\n      flip = 6;\n    } else if (load_raw != &CLASS packed_load_raw)\n      maximum = (is_raw == 2 && shot_select) ? 0x2f00 : 0x3e00;\n    top_margin = (raw_height - height) >> 2 << 1;\n    left_margin = (raw_width - width ) >> 2 << 1;\n    if (width == 2848) filters = 0x16161616;\n    if (width == 3328) {\n      width = 3262;\n      left_margin = 34;\n    }\n    if (width == 4952) {\n      left_margin = 0;\n      filters = 2;\n    }\n\tif(!strcmp(model,\"HS50EXR\"))\n\t{\n\t\tfilters = 0x1e1e1e1e;\n\t\twidth=3230;\n\t}\n\tif(!strcmp(model,\"X20\"))\n\t{\n\t\tleft_margin = 2;\n\t\ttop_margin=2;\n\t\twidth = 4030;\n\t\theight = 3010;\n\t\traw_height = 3012;\n\t\tfilters = 2;\n\t}\n\tif(!strcmp(model,\"X100S\"))\n\t{\n\t\tleft_margin = 2;\n\t\ttop_margin = 1;\n\t\twidth = 4934;\n\t\theight = 3290;\n\t\traw_height = 3295;\n\t\tfilters = 2;\n\t\tdata_offset +=8;\n\t\tload_raw = &CLASS unpacked_load_raw;\n\t\tload_flags = 0;\n\t\tmaximum = 16383;\n\t}\n    if (fuji_layout) raw_width *= is_raw;\n  } else if (!strcmp(model,\"RD175\")) {\n    height = 986;\n    width = 1534;\n    data_offset = 513;\n    filters = 0x61616161;\n    load_raw = &CLASS minolta_rd175_load_raw;\n  } else if (!strcmp(model,\"KD-400Z\")) {\n    height = 1712;\n    width  = 2312;\n    raw_width = 2336;\n    goto konica_400z;\n  } else if (!strcmp(model,\"KD-510Z\")) {\n    goto konica_510z;\n  } else if (!strcasecmp(make,\"MINOLTA\")) {\n    load_raw = &CLASS unpacked_load_raw;\n    maximum = 0xfff;\n    if (!strncmp(model,\"DiMAGE A\",8)) {\n      if (!strcmp(model,\"DiMAGE A200\"))\n\tfilters = 0x49494949;\n      tiff_bps = 12;\n      load_raw = &CLASS packed_load_raw;\n    } else if (!strncmp(model,\"ALPHA\",5) ||\n\t       !strncmp(model,\"DYNAX\",5) ||\n\t       !strncmp(model,\"MAXXUM\",6)) {\n      sprintf (model+20, \"DYNAX %-10s\", model+6+(model[0]=='M'));\n      adobe_coeff (make, model+20);\n      load_raw = &CLASS packed_load_raw;\n    } else if (!strncmp(model,\"DiMAGE G\",8)) {\n      if (model[8] == '4') {\n\theight = 1716;\n\twidth  = 2304;\n      } else if (model[8] == '5') {\nkonica_510z:\n\theight = 1956;\n\twidth  = 2607;\n\traw_width = 2624;\n      } else if (model[8] == '6') {\n\theight = 2136;\n\twidth  = 2848;\n      }\n      data_offset += 14;\n      filters = 0x61616161;\nkonica_400z:\n      load_raw = &CLASS unpacked_load_raw;\n      maximum = 0x3df;\n      order = 0x4d4d;\n    }\n  } else if (!strcmp(model,\"*ist D\")) {\n    load_raw = &CLASS unpacked_load_raw;\n    data_error = -1;\n  } else if (!strcmp(model,\"*ist DS\")) {\n    height -= 2;\n  } else if (!strcmp(model,\"Optio S\")) {\n    if (fsize == 3178560) {\n      height = 1540;\n      width  = 2064;\n      load_raw = &CLASS eight_bit_load_raw;\n      cam_mul[0] *= 4;\n      cam_mul[2] *= 4;\n    } else {\n      height = 1544;\n      width  = 2068;\n      raw_width = 3136;\n      load_raw = &CLASS packed_load_raw;\n      maximum = 0xf7c;\n    }\n  } else if (fsize == 6114240) {\n    height = 1737;\n    width  = 2324;\n    raw_width = 3520;\n    load_raw = &CLASS packed_load_raw;\n    maximum = 0xf7a;\n  } else if (!strcmp(model,\"Optio 750Z\")) {\n    height = 2302;\n    width  = 3072;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 30;\n  } else if (!strcmp(model,\"DC-833m\")) {\n    height = 2448;\n    width  = 3264;\n    order = 0x4949;\n    filters = 0x61616161;\n    load_raw = &CLASS unpacked_load_raw;\n    maximum = 0xfc00;\n  } else if (!strncmp(model,\"S85\",3)) {\n    height = 2448;\n    width  = 3264;\n    raw_width = fsize/height/2;\n    order = 0x4d4d;\n    load_raw = &CLASS unpacked_load_raw;\n  } else if (!strcmp(make,\"SAMSUNG\") && raw_width == 4704) {\n    height -= top_margin = 8;\n    width -= 2 * (left_margin = 8);\n    load_flags = 32;\n  } else if (!strcmp(make,\"SAMSUNG\") && raw_width == 5632) {\n    order = 0x4949;\n    height = 3694;\n    top_margin = 2;\n    width  = 5574 - (left_margin = 32 + tiff_bps);\n    if (tiff_bps == 12) load_flags = 80;\n  } else if (!strcmp(make,\"SAMSUNG\") && !strcmp(model,\"NX300\")) {\n\t  is_raw =0;\n  } else if (!strcmp(model,\"EX1\")) {\n    order = 0x4949;\n    height -= 20;\n    top_margin = 2;\n    if ((width -= 6) > 3682) {\n      height -= 10;\n      width  -= 46;\n      top_margin = 8;\n    }\n  } else if (!strcmp(model,\"WB2000\")) {\n    order = 0x4949;\n    height -= 3;\n    top_margin = 2;\n    if ((width -= 10) > 3718) {\n      height -= 28;\n      width  -= 56;\n      top_margin = 8;\n    }\n  } else if (fsize == 20487168) {\n    height = 2808;\n    width  = 3648;\n    goto wb550;\n  } else if (fsize == 24000000) {\n    height = 3000;\n    width  = 4000;\nwb550:\n    strcpy (model, \"WB550\");\n    order = 0x4d4d;\n    load_raw = &CLASS unpacked_load_raw;\n    load_flags = 6;\n    maximum = 0x3df;\n  } else if (!strcmp(model,\"EX2F\")) {\n    height = 3045;\n    width  = 4070;\n    top_margin = 3;\n    order = 0x4949;\n    filters = 0x49494949;\n    load_raw = &CLASS unpacked_load_raw;\n  } else if (!strcmp(model,\"STV680 VGA\")) {\n    height = 484;\n    width  = 644;\n    load_raw = &CLASS eight_bit_load_raw;\n    flip = 2;\n    filters = 0x16161616;\n    black = 16;\n  }  else\n      identify2(fsize,flen,head); /* Avoid MS VS 2008/2010 bug */\n\n  if (!model[0])\n    sprintf (model, \"%dx%d\", width, height);\n  if (filters == UINT_MAX) filters = 0x94949494;\n  if (raw_color) adobe_coeff (make, model);\n  if (load_raw == &CLASS kodak_radc_load_raw)\n    if (raw_color) adobe_coeff (\"Apple\",\"Quicktake\");\n  if (thumb_offset && !thumb_height) {\n    fseek (ifp, thumb_offset, SEEK_SET);\n    if (ljpeg_start (&jh, 1)) {\n      thumb_width  = jh.wide;\n      thumb_height = jh.high;\n    }\n  }\ndng_skip:\n  if (fuji_width) {\n    fuji_width = width >> !fuji_layout;\n    if (~fuji_width & 1) filters = 0x49494949;\n    width = (height >> fuji_layout) + fuji_width;\n    height = width - 1;\n    pixel_aspect = 1;\n  } else {\n    if (raw_height < height) raw_height = height;\n    if (raw_width  < width ) raw_width  = width;\n  }\n  if (!tiff_bps) tiff_bps = 12;\n  if (!maximum) maximum = (1 << tiff_bps) - 1;\n  if (!load_raw || height < 22) is_raw = 0;\n#ifdef NO_JASPER\n  if (load_raw == &CLASS redcine_load_raw) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s: You must link dcraw with %s!!\\n\"),\n\tifname, \"libjasper\");\n#endif\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_JASPER;\n#endif\n  }\n#endif\n#ifdef NO_JPEG\n  if (load_raw == &CLASS kodak_jpeg_load_raw ||\n      load_raw == &CLASS lossy_dng_load_raw) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s: You must link dcraw with %s!!\\n\"),\n\tifname, \"libjpeg\");\n#endif\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_JPEGLIB;\n#endif\n  }\n#endif\n  if (!cdesc[0])\n    strcpy (cdesc, colors == 3 ? \"RGBG\":\"GMCY\");\n  if (!raw_height) raw_height = height;\n  if (!raw_width ) raw_width  = width;\n  if (filters && colors == 3)\n    filters |= ((filters >> 2 & 0x22222222) |\n\t\t(filters << 2 & 0x88888888)) & filters << 1;\nnotraw:\n  if (flip == -1) flip = tiff_flip;\n  if (flip == -1) flip = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY,1,2);\n#endif\n}\n\nvoid CLASS identify2(unsigned fsize, unsigned flen, char *head)\n{\n  short pana[][6] = {\n    { 3130, 1743,  4,  0, -6,  0 },\n    { 3130, 2055,  4,  0, -6,  0 },\n    { 3130, 2319,  4,  0, -6,  0 },\n    { 3170, 2103, 18,  0,-42, 20 },\n    { 3170, 2367, 18, 13,-42,-21 },\n    { 3177, 2367,  0,  0, -1,  0 },\n    { 3304, 2458,  0,  0, -1,  0 },\n    { 3330, 2463,  9,  0, -5,  0 },\n    { 3330, 2479,  9,  0,-17,  4 },\n    { 3370, 1899, 15,  0,-44, 20 },\n    { 3370, 2235, 15,  0,-44, 20 },\n    { 3370, 2511, 15, 10,-44,-21 },\n    { 3690, 2751,  3,  0, -8, -3 },\n    { 3710, 2751,  0,  0, -3,  0 },\n    { 3724, 2450,  0,  0,  0, -2 },\n    { 3770, 2487, 17,  0,-44, 19 },\n    { 3770, 2799, 17, 15,-44,-19 },\n    { 3880, 2170,  6,  0, -6,  0 },\n    { 4060, 3018,  0,  0,  0, -2 },\n    { 4290, 2391,  3,  0, -8, -1 },\n    { 4330, 2439, 17, 15,-44,-19 },\n    { 4508, 2962,  0,  0, -3, -4 },\n    { 4508, 3330,  0,  0, -3, -6 } };\n\n\n  struct jhead jh;\n  int i;\n if (!strcmp(model,\"N95\")) {\n    height = raw_height - (top_margin = 2);\n  } else if (!strcmp(model,\"531C\")) {\n    height = 1200;\n    width  = 1600;\n    load_raw = &CLASS unpacked_load_raw;\n    filters = 0x49494949;\n  } else if (!strcmp(model,\"640x480\")) {\n    height = 480;\n    width  = 640;\n    load_raw = &CLASS eight_bit_load_raw;\n    gamma_curve (0.45, 4.5, 1, 255);\n  } else if (!strcmp(model,\"F-080C\")) {\n    height = 768;\n    width  = 1024;\n    load_raw = &CLASS eight_bit_load_raw;\n  } else if (!strcmp(model,\"F-145C\")) {\n    height = 1040;\n    width  = 1392;\n    load_raw = &CLASS eight_bit_load_raw;\n  } else if (!strcmp(model,\"F-201C\")) {\n    height = 1200;\n    width  = 1600;\n    load_raw = &CLASS eight_bit_load_raw;\n  } else if (!strcmp(model,\"F-510C\")) {\n    height = 1958;\n    width  = 2588;\n    load_raw = fsize < 7500000 ?\n\t&CLASS eight_bit_load_raw : &CLASS unpacked_load_raw;\n    data_offset = fsize - width*height*(fsize >> 22);\n    maximum = 0xfff0;\n  } else if (!strcmp(model,\"F-810C\")) {\n    height = 2469;\n    width  = 3272;\n    load_raw = &CLASS unpacked_load_raw;\n    maximum = 0xfff0;\n  } else if (!strcmp(model,\"XCD-SX910CR\")) {\n    height = 1024;\n    width  = 1375;\n    raw_width = 1376;\n    filters = 0x49494949;\n    maximum = 0x3ff;\n    load_raw = fsize < 2000000 ?\n\t&CLASS eight_bit_load_raw : &CLASS unpacked_load_raw;\n  } else if (!strcmp(model,\"2010\")) {\n    height = 1207;\n    width  = 1608;\n    order = 0x4949;\n    filters = 0x16161616;\n    data_offset = 3212;\n    maximum = 0x3ff;\n    load_raw = &CLASS unpacked_load_raw;\n  } else if (!strcmp(model,\"A782\")) {\n    height = 3000;\n    width  = 2208;\n    filters = 0x61616161;\n    load_raw = fsize < 10000000 ?\n\t&CLASS eight_bit_load_raw : &CLASS unpacked_load_raw;\n    maximum = 0xffc0;\n  } else if (!strcmp(model,\"3320AF\")) {\n    height = 1536;\n    raw_width = width = 2048;\n    filters = 0x61616161;\n    load_raw = &CLASS unpacked_load_raw;\n    maximum = 0x3ff;\n    fseek (ifp, 0x300000, SEEK_SET);\n    if ((order = guess_byte_order(0x10000)) == 0x4d4d) {\n      height -= (top_margin = 16);\n      width -= (left_margin = 28);\n      maximum = 0xf5c0;\n      strcpy (make, \"ISG\");\n      model[0] = 0;\n    }\n  } else if (!strcmp(make,\"Hasselblad\")) {\n    if (load_raw == &CLASS lossless_jpeg_load_raw)\n      load_raw = &CLASS hasselblad_load_raw;\n    if (raw_width == 7262) {\n      height = 5444;\n      width  = 7248;\n      top_margin  = 4;\n      left_margin = 7;\n      filters = 0x61616161;\n    } else if (raw_width == 7410) {\n      height = 5502;\n      width  = 7328;\n      top_margin  = 4;\n      left_margin = 41;\n      filters = 0x61616161;\n    } else if (raw_width == 9044) {\n      height = 6716;\n      width  = 8964;\n      top_margin  = 8;\n      left_margin = 40;\n      black += load_flags = 256;\n      maximum = 0x8101;\n    } else if (raw_width == 4090) {\n      strcpy (model, \"V96C\");\n      height -= (top_margin = 6);\n      width -= (left_margin = 3) + 7;\n      filters = 0x61616161;\n    }\n  } else if (!strcmp(make,\"Sinar\")) {\n    if (!memcmp(head,\"8BPS\",4)) {\n      fseek (ifp, 14, SEEK_SET);\n      height = get4();\n      width  = get4();\n      filters = 0x61616161;\n      data_offset = 68;\n    }\n    if (!load_raw) load_raw = &CLASS unpacked_load_raw;\n    maximum = 0x3fff;\n  } else if (!strcmp(make,\"Leaf\")) {\n    maximum = 0x3fff;\n    fseek (ifp, data_offset, SEEK_SET);\n    if (ljpeg_start (&jh, 1) && jh.bits == 15)\n      maximum = 0x1fff;\n    if (tiff_samples > 1) filters = 0;\n    if (tiff_samples > 1 || tile_length < raw_height) {\n      load_raw = &CLASS leaf_hdr_load_raw;\n      raw_width = tile_width;\n    }\n    if ((width | height) == 2048) {\n      if (tiff_samples == 1) {\n\tfilters = 1;\n\tstrcpy (cdesc, \"RBTG\");\n\tstrcpy (model, \"CatchLight\");\n\ttop_margin =  8; left_margin = 18; height = 2032; width = 2016;\n      } else {\n\tstrcpy (model, \"DCB2\");\n\ttop_margin = 10; left_margin = 16; height = 2028; width = 2022;\n      }\n    } else if (width+height == 3144+2060) {\n      if (!model[0]) strcpy (model, \"Cantare\");\n      if (width > height) {\n\t top_margin = 6; left_margin = 32; height = 2048;  width = 3072;\n\tfilters = 0x61616161;\n      } else {\n\tleft_margin = 6;  top_margin = 32;  width = 2048; height = 3072;\n\tfilters = 0x16161616;\n      }\n      if (!cam_mul[0] || model[0] == 'V') filters = 0;\n      else is_raw = tiff_samples;\n    } else if (width == 2116) {\n      strcpy (model, \"Valeo 6\");\n      height -= 2 * (top_margin = 30);\n      width -= 2 * (left_margin = 55);\n      filters = 0x49494949;\n    } else if (width == 3171) {\n      strcpy (model, \"Valeo 6\");\n      height -= 2 * (top_margin = 24);\n      width -= 2 * (left_margin = 24);\n      filters = 0x16161616;\n    }\n  } else if (!strcmp(make,\"LEICA\") || !strcmp(make,\"Panasonic\")) {\n    if ((flen - data_offset) / (raw_width*8/7) == raw_height)\n      load_raw = &CLASS panasonic_load_raw;\n    if (!load_raw) {\n      load_raw = &CLASS unpacked_load_raw;\n      load_flags = 4;\n    }\n    zero_is_bad = 1;\n    if ((height += 12) > raw_height) height = raw_height;\n    for (i=0; i < sizeof pana / sizeof *pana; i++)\n      if (raw_width == pana[i][0] && raw_height == pana[i][1]) {\n\tleft_margin = pana[i][2];\n\t top_margin = pana[i][3];\n\t     width += pana[i][4];\n\t    height += pana[i][5];\n      }\n    filters = 0x01010101 * (uchar) \"\\x94\\x61\\x49\\x16\"\n\t[((filters-1) ^ (left_margin & 1) ^ (top_margin << 1)) & 3];\n  } else if (!strcmp(model,\"C770UZ\")) {\n    height = 1718;\n    width  = 2304;\n    filters = 0x16161616;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 30;\n  } else if (!strcmp(make,\"OLYMPUS\")) {\n    height += height & 1;\n    filters = exif_cfa;\n    if (width == 4100) width -= 4;\n    if (width == 4080) width -= 24;\n    if (load_raw == &CLASS unpacked_load_raw)\n      load_flags = 4;\n    tiff_bps = 12;\n    if (!strcmp(model,\"E-300\") ||\n\t!strcmp(model,\"E-500\")) {\n      width -= 20;\n      if (load_raw == &CLASS unpacked_load_raw) {\n\tmaximum = 0xfc3;\n\tmemset (cblack, 0, sizeof cblack);\n      }\n    } else if (!strcmp(model,\"E-330\")) {\n      width -= 30;\n      if (load_raw == &CLASS unpacked_load_raw)\n\tmaximum = 0xf79;\n    } else if (!strcmp(model,\"SP550UZ\")) {\n      thumb_length = flen - (thumb_offset = 0xa39800);\n      thumb_height = 480;\n      thumb_width  = 640;\n    } else if (!strcmp(model,\"XZ-2\")) {\n      load_raw = &CLASS packed_load_raw;\n      load_flags = 24;\n    } else if (!strcmp(model,\"XZ-10\")) {\n      load_raw = &CLASS packed_load_raw;\n      load_flags = 24;\n    }\n  } else if (!strcmp(model,\"N Digital\")) {\n    height = 2047;\n    width  = 3072;\n    filters = 0x61616161;\n    data_offset = 0x1a00;\n    load_raw = &CLASS packed_load_raw;\n  } else if (!strcmp(model,\"DSC-F828\")) {\n    width = 3288;\n    left_margin = 5;\n    mask[1][3] = -17;\n    data_offset = 862144;\n    load_raw = &CLASS sony_load_raw;\n    filters = 0x9c9c9c9c;\n    colors = 4;\n    strcpy (cdesc, \"RGBE\");\n  } else if (!strcmp(model,\"DSC-V3\")) {\n    width = 3109;\n    left_margin = 59;\n    mask[0][1] = 9;\n    data_offset = 787392;\n    load_raw = &CLASS sony_load_raw;\n  } else if (!strcmp(make,\"SONY\") && raw_width == 3984) {\n    adobe_coeff (\"SONY\",\"DSC-R1\");\n    width = 3925;\n    order = 0x4d4d;\n  } else if (!strcmp(make,\"SONY\") && raw_width == 5504) {\n    width -= 8;\n  } else if (!strcmp(make,\"SONY\") && raw_width == 6048) {\n    width -= 24;\n  } else if (!strcmp(model,\"DSLR-A100\")) {\n    if (width == 3880) {\n      height--;\n      width = ++raw_width;\n    } else {\n      order = 0x4d4d;\n      load_flags = 2;\n    }\n    filters = 0x61616161;\n  } else if (!strcmp(model,\"DSLR-A350\")) {\n    height -= 4;\n  } else if (!strcmp(model,\"PIXL\")) {\n    height -= top_margin = 4;\n    width -= left_margin = 32;\n    gamma_curve (0, 7, 1, 255);\n  } else if (!strcmp(model,\"C603v\")) {\n    height = 480;\n    width  = 640;\n    if (fsize < 614400 || find_green (16, 16, 3840, 5120) < 25) goto c603v;\n    strcpy (model,\"KAI-0340\");\n    height -= 3;\n    data_offset = 3840;\n    order = 0x4949;\n    load_raw = &CLASS unpacked_load_raw;\n  } else if (!strcmp(model,\"C603y\")) {\n    height = 2134;\n    width  = 2848;\nc603v:\n    filters = 0;\n    load_raw = &CLASS kodak_yrgb_load_raw;\n    gamma_curve (0, 3.875, 1, 255);\n  } else if (!strcmp(model,\"C603\")) {\n    raw_height = height = 2152;\n    raw_width  = width  = 2864;\n    goto c603;\n  } else if (!strcmp(model,\"C330\")) {\n    height = 1744;\n    width  = 2336;\n    raw_height = 1779;\n    raw_width  = 2338;\n    top_margin = 33;\n    left_margin = 1;\nc603:\n    order = 0x4949;\n    if ((data_offset = fsize - raw_height*raw_width)) {\n      fseek (ifp, 168, SEEK_SET);\n      read_shorts (curve, 256);\n    } else gamma_curve (0, 3.875, 1, 255);\n    load_raw = &CLASS eight_bit_load_raw;\n  } else if (!strncasecmp(model,\"EasyShare\",9)) {\n    data_offset = data_offset < 0x15000 ? 0x15000 : 0x17000;\n    load_raw = &CLASS packed_load_raw;\n  } else if (!strcasecmp(make,\"KODAK\")) {\n    if (filters == UINT_MAX) filters = 0x61616161;\n    if (!strncmp(model,\"NC2000\",6)) {\n      width -= 4;\n      left_margin = 2;\n    } else if (!strcmp(model,\"EOSDCS3B\")) {\n      width -= 4;\n      left_margin = 2;\n    } else if (!strcmp(model,\"EOSDCS1\")) {\n      width -= 4;\n      left_margin = 2;\n    } else if (!strcmp(model,\"DCS420\")) {\n      width -= 4;\n      left_margin = 2;\n    } else if (!strncmp(model,\"DCS460 \",7)) {\n      model[6] = 0;\n      width -= 4;\n      left_margin = 2;\n    } else if (!strcmp(model,\"DCS460A\")) {\n      width -= 4;\n      left_margin = 2;\n      colors = 1;\n      filters = 0;\n    } else if (!strcmp(model,\"DCS660M\")) {\n      black = 214;\n      colors = 1;\n      filters = 0;\n    } else if (!strcmp(model,\"DCS760M\")) {\n      colors = 1;\n      filters = 0;\n    }\n    if (!strcmp(model+4,\"20X\"))\n      strcpy (cdesc, \"MYCY\");\n    if (strstr(model,\"DC25\")) {\n      strcpy (model, \"DC25\");\n      data_offset = 15424;\n    }\n    if (!strncmp(model,\"DC2\",3)) {\n      raw_height = height = 242;\n      if (flen < 100000) {\n\traw_width = 256; width = 249;\n\tpixel_aspect = (4.0*height) / (3.0*width);\n      } else {\n\traw_width = 512; width = 501;\n\tpixel_aspect = (493.0*height) / (373.0*width);\n      }\n      data_offset += raw_width + 1;\n      colors = 4;\n      filters = 0x8d8d8d8d;\n      simple_coeff(1);\n      pre_mul[1] = 1.179;\n      pre_mul[2] = 1.209;\n      pre_mul[3] = 1.036;\n      load_raw = &CLASS eight_bit_load_raw;\n    } else if (!strcmp(model,\"40\")) {\n      strcpy (model, \"DC40\");\n      height = 512;\n      width  = 768;\n      data_offset = 1152;\n      load_raw = &CLASS kodak_radc_load_raw;\n    } else if (strstr(model,\"DC50\")) {\n      strcpy (model, \"DC50\");\n      height = 512;\n      width  = 768;\n      data_offset = 19712;\n      load_raw = &CLASS kodak_radc_load_raw;\n    } else if (strstr(model,\"DC120\")) {\n      strcpy (model, \"DC120\");\n      height = 976;\n      width  = 848;\n      pixel_aspect = height/0.75/width;\n      load_raw = tiff_compress == 7 ?\n\t&CLASS kodak_jpeg_load_raw : &CLASS kodak_dc120_load_raw;\n    } else if (!strcmp(model,\"DCS200\")) {\n      thumb_height = 128;\n      thumb_width  = 192;\n      thumb_offset = 6144;\n      thumb_misc   = 360;\n      write_thumb = &CLASS layer_thumb;\n      height = 1024;\n      width  = 1536;\n      data_offset = 79872;\n      load_raw = &CLASS eight_bit_load_raw;\n      black = 17;\n    }\n  } else if (!strcmp(model,\"Fotoman Pixtura\")) {\n    height = 512;\n    width  = 768;\n    data_offset = 3632;\n    load_raw = &CLASS kodak_radc_load_raw;\n    filters = 0x61616161;\n    simple_coeff(2);\n  } else if (!strncmp(model,\"QuickTake\",9)) {\n    if (head[5]) strcpy (model+10, \"200\");\n    fseek (ifp, 544, SEEK_SET);\n    height = get2();\n    width  = get2();\n    data_offset = (get4(),get2()) == 30 ? 738:736;\n    if (height > width) {\n      SWAP(height,width);\n      fseek (ifp, data_offset-6, SEEK_SET);\n      flip = ~get2() & 3 ? 5:6;\n    }\n    filters = 0x61616161;\n  } else if (!strcmp(make,\"Rollei\") && !load_raw) {\n    switch (raw_width) {\n      case 1316:\n\theight = 1030;\n\twidth  = 1300;\n\ttop_margin  = 1;\n\tleft_margin = 6;\n\tbreak;\n      case 2568:\n\theight = 1960;\n\twidth  = 2560;\n\ttop_margin  = 2;\n\tleft_margin = 8;\n    }\n    filters = 0x16161616;\n    load_raw = &CLASS rollei_load_raw;\n  } else if (!strcmp(model,\"PC-CAM 600\")) {\n    height = 768;\n    data_offset = width = 1024;\n    filters = 0x49494949;\n    load_raw = &CLASS eight_bit_load_raw;\n  } else if (!strcmp(model,\"QV-2000UX\")) {\n    height = 1208;\n    width  = 1632;\n    data_offset = width * 2;\n    load_raw = &CLASS eight_bit_load_raw;\n  } else if (fsize == 3217760) {\n    height = 1546;\n    width  = 2070;\n    raw_width = 2080;\n    load_raw = &CLASS eight_bit_load_raw;\n  } else if (!strcmp(model,\"QV-4000\")) {\n    height = 1700;\n    width  = 2260;\n    load_raw = &CLASS unpacked_load_raw;\n    maximum = 0xffff;\n  } else if (!strcmp(model,\"QV-5700\")) {\n    height = 1924;\n    width  = 2576;\n    raw_width = 3232;\n    tiff_bps = 10;\n  } else if (!strcmp(model,\"QV-R41\")) {\n    height = 1720;\n    width  = 2312;\n    raw_width = 3520;\n    left_margin = 2;\n  } else if (!strcmp(model,\"QV-R51\")) {\n    height = 1926;\n    width  = 2580;\n    raw_width = 3904;\n  } else if (!strcmp(model,\"EX-S20\")) {\n    height = 1208;\n    width  = 1620;\n    raw_width = 2432;\n    flip = 3;\n  } else if (!strcmp(model,\"EX-S100\")) {\n    height = 1544;\n    width  = 2058;\n    raw_width = 3136;\n  } else if (!strcmp(model,\"EX-Z50\")) {\n    height = 1931;\n    width  = 2570;\n    raw_width = 3904;\n  } else if (!strcmp(model,\"EX-Z500\")) {\n    height = 1937;\n    width  = 2577;\n    raw_width = 3904;\n    filters = 0x16161616;\n  } else if (!strcmp(model,\"EX-Z55\")) {\n    height = 1960;\n    width  = 2570;\n    raw_width = 3904;\n  } else if (!strcmp(model,\"EX-Z60\")) {\n    height = 2145;\n    width  = 2833;\n    raw_width = 3584;\n    filters = 0x16161616;\n    tiff_bps = 10;\n  } else if (!strcmp(model,\"EX-Z75\")) {\n    height = 2321;\n    width  = 3089;\n    raw_width = 4672;\n    maximum = 0xfff;\n  } else if (!strcmp(model,\"EX-Z750\")) {\n    height = 2319;\n    width  = 3087;\n    raw_width = 4672;\n    maximum = 0xfff;\n  } else if (!strcmp(model,\"EX-Z850\")) {\n    height = 2468;\n    width  = 3279;\n    raw_width = 4928;\n    maximum = 0xfff;\n  } else if (!strcmp(model,\"EX-Z8\")) {\n    height = 2467;\n    width  = 3281;\n    raw_height = 2502;\n    raw_width  = 4992;\n    maximum = 0xfff;\n  } else if (fsize == 15499264) {\t/* EX-Z1050 or EX-Z1080 */\n    height = 2752;\n    width  = 3672;\n    raw_width = 5632;\n  } else if (!strcmp(model,\"EX-ZR100\")) {\n    height = 3044;\n    width  = 4072;\n    raw_width = 4096;\n    load_flags = 80;\n  } else if (!strcmp(model,\"EX-P505\")) {\n    height = 1928;\n    width  = 2568;\n    raw_width = 3852;\n    maximum = 0xfff;\n  } else if (fsize == 9313536) {\t/* EX-P600 or QV-R61 */\n    height = 2142;\n    width  = 2844;\n    raw_width = 4288;\n  } else if (!strcmp(model,\"EX-P700\")) {\n    height = 2318;\n    width  = 3082;\n    raw_width = 4672;\n  }\n  else if (!strcmp(model,\"GRAS-50S5C\")) {\n   height = 2048;\n   width = 2440;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x49494949;\n   order = 0x4949;\n   maximum = 0xfffC;\n  } else if (!strcmp(model,\"BB-500CL\")) {\n   height = 2058;\n   width = 2448;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x94949494;\n   order = 0x4949;\n   maximum = 0x3fff;\n  } else if (!strcmp(model,\"BB-500GE\")) {\n   height = 2058;\n   width = 2456;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x94949494;\n   order = 0x4949;\n   maximum = 0x3fff;\n  } else if (!strcmp(model,\"SVS625CL\")) {\n   height = 2050;\n   width = 2448;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x94949494;\n   order = 0x4949;\n   maximum = 0x0fff;\n  }\n}\n\n\n//@end COMMON\n\n//@out FILEIO\n#ifndef NO_LCMS\nvoid CLASS apply_profile (const char *input, const char *output)\n{\n  char *prof;\n  cmsHPROFILE hInProfile=0, hOutProfile=0;\n  cmsHTRANSFORM hTransform;\n  FILE *fp;\n  unsigned size;\n\n#ifndef USE_LCMS2\n  cmsErrorAction (LCMS_ERROR_SHOW);\n#endif\n  if (strcmp (input, \"embed\"))\n    hInProfile = cmsOpenProfileFromFile (input, \"r\");\n  else if (profile_length) {\n#ifndef LIBRAW_LIBRARY_BUILD\n    prof = (char *) malloc (profile_length);\n    merror (prof, \"apply_profile()\");\n    fseek (ifp, profile_offset, SEEK_SET);\n    fread (prof, 1, profile_length, ifp);\n    hInProfile = cmsOpenProfileFromMem (prof, profile_length);\n    free (prof);\n#else\n    hInProfile = cmsOpenProfileFromMem (imgdata.color.profile, profile_length);\n#endif\n  } else\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_EMBEDDED_PROFILE;\n#endif\n#ifdef DCRAW_VERBOSE\n          fprintf (stderr,_(\"%s has no embedded profile.\\n\"), ifname);\n#endif\n    }\n  if (!hInProfile)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_INPUT_PROFILE;\n#endif\n          return;\n      }\n  if (!output)\n    hOutProfile = cmsCreate_sRGBProfile();\n  else if ((fp = fopen (output, \"rb\"))) {\n    fread (&size, 4, 1, fp);\n    fseek (fp, 0, SEEK_SET);\n    oprof = (unsigned *) malloc (size = ntohl(size));\n    merror (oprof, \"apply_profile()\");\n    fread (oprof, 1, size, fp);\n    fclose (fp);\n    if (!(hOutProfile = cmsOpenProfileFromMem (oprof, size))) {\n      free (oprof);\n      oprof = 0;\n    }\n  }\n#ifdef DCRAW_VERBOSE\n else\n    fprintf (stderr,_(\"Cannot open file %s!\\n\"), output);\n#endif\n  if (!hOutProfile)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_BAD_OUTPUT_PROFILE;\n#endif\n          goto quit;\n      }\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf (stderr,_(\"Applying color profile...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_APPLY_PROFILE,0,2);\n#endif\n  hTransform = cmsCreateTransform (hInProfile, TYPE_RGBA_16,\n\thOutProfile, TYPE_RGBA_16, INTENT_PERCEPTUAL, 0);\n  cmsDoTransform (hTransform, image, image, width*height);\n  raw_color = 1;\t\t/* Don't use rgb_cam with a profile */\n  cmsDeleteTransform (hTransform);\n  cmsCloseProfile (hOutProfile);\nquit:\n  cmsCloseProfile (hInProfile);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_APPLY_PROFILE,1,2);\n#endif\n}\n#endif\n//@end FILEIO\n\n//@out COMMON\nvoid CLASS convert_to_rgb()\n{\n#ifndef LIBRAW_LIBRARY_BUILD\n  int row, col, c;\n#endif\n  int  i, j, k;\n#ifndef LIBRAW_LIBRARY_BUILD\n  ushort *img;\n  float out[3];\n#endif\n  float out_cam[3][4];\n  double num, inverse[3][3];\n  static const double xyzd50_srgb[3][3] =\n  { { 0.436083, 0.385083, 0.143055 },\n    { 0.222507, 0.716888, 0.060608 },\n    { 0.013930, 0.097097, 0.714022 } };\n  static const double rgb_rgb[3][3] =\n  { { 1,0,0 }, { 0,1,0 }, { 0,0,1 } };\n  static const double adobe_rgb[3][3] =\n  { { 0.715146, 0.284856, 0.000000 },\n    { 0.000000, 1.000000, 0.000000 },\n    { 0.000000, 0.041166, 0.958839 } };\n  static const double wide_rgb[3][3] =\n  { { 0.593087, 0.404710, 0.002206 },\n    { 0.095413, 0.843149, 0.061439 },\n    { 0.011621, 0.069091, 0.919288 } };\n  static const double prophoto_rgb[3][3] =\n  { { 0.529317, 0.330092, 0.140588 },\n    { 0.098368, 0.873465, 0.028169 },\n    { 0.016879, 0.117663, 0.865457 } };\n  static const double (*out_rgb[])[3] =\n  { rgb_rgb, adobe_rgb, wide_rgb, prophoto_rgb, xyz_rgb };\n  static const char *name[] =\n  { \"sRGB\", \"Adobe RGB (1998)\", \"WideGamut D65\", \"ProPhoto D65\", \"XYZ\" };\n  static const unsigned phead[] =\n  { 1024, 0, 0x2100000, 0x6d6e7472, 0x52474220, 0x58595a20, 0, 0, 0,\n    0x61637370, 0, 0, 0x6e6f6e65, 0, 0, 0, 0, 0xf6d6, 0x10000, 0xd32d };\n  unsigned pbody[] =\n  { 10, 0x63707274, 0, 36,\t/* cprt */\n\t0x64657363, 0, 40,\t/* desc */\n\t0x77747074, 0, 20,\t/* wtpt */\n\t0x626b7074, 0, 20,\t/* bkpt */\n\t0x72545243, 0, 14,\t/* rTRC */\n\t0x67545243, 0, 14,\t/* gTRC */\n\t0x62545243, 0, 14,\t/* bTRC */\n\t0x7258595a, 0, 20,\t/* rXYZ */\n\t0x6758595a, 0, 20,\t/* gXYZ */\n\t0x6258595a, 0, 20 };\t/* bXYZ */\n  static const unsigned pwhite[] = { 0xf351, 0x10000, 0x116cc };\n  unsigned pcurve[] = { 0x63757276, 0, 1, 0x1000000 };\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB,0,2);\n#endif\n  gamma_curve (gamm[0], gamm[1], 0, 0);\n  memcpy (out_cam, rgb_cam, sizeof out_cam);\n#ifndef LIBRAW_LIBRARY_BUILD\n  raw_color |= colors == 1 || document_mode ||\n\t\toutput_color < 1 || output_color > 5;\n#else\n  raw_color |= colors == 1 || \n\t\toutput_color < 1 || output_color > 5;\n#endif\n  if (!raw_color) {\n    oprof = (unsigned *) calloc (phead[0], 1);\n    merror (oprof, \"convert_to_rgb()\");\n    memcpy (oprof, phead, sizeof phead);\n    if (output_color == 5) oprof[4] = oprof[5];\n    oprof[0] = 132 + 12*pbody[0];\n    for (i=0; i < pbody[0]; i++) {\n      oprof[oprof[0]/4] = i ? (i > 1 ? 0x58595a20 : 0x64657363) : 0x74657874;\n      pbody[i*3+2] = oprof[0];\n      oprof[0] += (pbody[i*3+3] + 3) & -4;\n    }\n    memcpy (oprof+32, pbody, sizeof pbody);\n    oprof[pbody[5]/4+2] = strlen(name[output_color-1]) + 1;\n    memcpy ((char *)oprof+pbody[8]+8, pwhite, sizeof pwhite);\n    pcurve[3] = (short)(256/gamm[5]+0.5) << 16;\n    for (i=4; i < 7; i++)\n      memcpy ((char *)oprof+pbody[i*3+2], pcurve, sizeof pcurve);\n    pseudoinverse ((double (*)[3]) out_rgb[output_color-1], inverse, 3);\n    for (i=0; i < 3; i++)\n      for (j=0; j < 3; j++) {\n\tfor (num = k=0; k < 3; k++)\n\t  num += xyzd50_srgb[i][k] * inverse[j][k];\n\toprof[pbody[j*3+23]/4+i+2] = num * 0x10000 + 0.5;\n      }\n    for (i=0; i < phead[0]/4; i++)\n      oprof[i] = htonl(oprof[i]);\n    strcpy ((char *)oprof+pbody[2]+8, \"auto-generated by dcraw\");\n    strcpy ((char *)oprof+pbody[5]+12, name[output_color-1]);\n    for (i=0; i < 3; i++)\n      for (j=0; j < colors; j++)\n\tfor (out_cam[i][j] = k=0; k < 3; k++)\n\t  out_cam[i][j] += out_rgb[output_color-1][i][k] * rgb_cam[k][j];\n  }\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf (stderr, raw_color ? _(\"Building histograms...\\n\") :\n\t_(\"Converting to %s colorspace...\\n\"), name[output_color-1]);\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  convert_to_rgb_loop(out_cam);\n#else\n  memset (histogram, 0, sizeof histogram);\n  for (img=image[0], row=0; row < height; row++)\n    for (col=0; col < width; col++, img+=4) {\n      if (!raw_color) {\n\tout[0] = out[1] = out[2] = 0;\n\tFORCC {\n\t  out[0] += out_cam[0][c] * img[c];\n\t  out[1] += out_cam[1][c] * img[c];\n\t  out[2] += out_cam[2][c] * img[c];\n\t}\n\tFORC3 img[c] = CLIP((int) out[c]);\n      }\n      else if (document_mode)\n\timg[0] = img[fcol(row,col)];\n      FORCC histogram[c][img[c] >> 3]++;\n    }\n#endif\n  if (colors == 4 && output_color) colors = 3;\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (document_mode && filters) colors = 1;\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB,1,2);\n#endif\n}\n\nvoid CLASS fuji_rotate()\n{\n  int i, row, col;\n  double step;\n  float r, c, fr, fc;\n  unsigned ur, uc;\n  ushort wide, high, (*img)[4], (*pix)[4];\n\n  if (!fuji_width) return;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf (stderr,_(\"Rotating image 45 degrees...\\n\"));\n#endif\n  fuji_width = (fuji_width - 1 + shrink) >> shrink;\n  step = sqrt(0.5);\n  wide = fuji_width / step;\n  high = (height - fuji_width) / step;\n  img = (ushort (*)[4]) calloc (wide*high, sizeof *img);\n  merror (img, \"fuji_rotate()\");\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE,0,2);\n#endif\n\n  for (row=0; row < high; row++)\n    for (col=0; col < wide; col++) {\n      ur = r = fuji_width + (row-col)*step;\n      uc = c = (row+col)*step;\n      if (ur > height-2 || uc > width-2) continue;\n      fr = r - ur;\n      fc = c - uc;\n      pix = image + ur*width + uc;\n      for (i=0; i < colors; i++)\n\timg[row*wide+col][i] =\n\t  (pix[    0][i]*(1-fc) + pix[      1][i]*fc) * (1-fr) +\n\t  (pix[width][i]*(1-fc) + pix[width+1][i]*fc) * fr;\n    }\n\n  free (image);\n  width  = wide;\n  height = high;\n  image  = img;\n  fuji_width = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE,1,2);\n#endif\n}\n\nvoid CLASS stretch()\n{\n  ushort newdim, (*img)[4], *pix0, *pix1;\n  int row, col, c;\n  double rc, frac;\n\n  if (pixel_aspect == 1) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH,0,2);\n#endif\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Stretching the image...\\n\"));\n#endif\n  if (pixel_aspect < 1) {\n    newdim = height / pixel_aspect + 0.5;\n    img = (ushort (*)[4]) calloc (width*newdim, sizeof *img);\n    merror (img, \"stretch()\");\n    for (rc=row=0; row < newdim; row++, rc+=pixel_aspect) {\n      frac = rc - (c = rc);\n      pix0 = pix1 = image[c*width];\n      if (c+1 < height) pix1 += width*4;\n      for (col=0; col < width; col++, pix0+=4, pix1+=4)\n\tFORCC img[row*width+col][c] = pix0[c]*(1-frac) + pix1[c]*frac + 0.5;\n    }\n    height = newdim;\n  } else {\n    newdim = width * pixel_aspect + 0.5;\n    img = (ushort (*)[4]) calloc (height*newdim, sizeof *img);\n    merror (img, \"stretch()\");\n    for (rc=col=0; col < newdim; col++, rc+=1/pixel_aspect) {\n      frac = rc - (c = rc);\n      pix0 = pix1 = image[c];\n      if (c+1 < width) pix1 += 4;\n      for (row=0; row < height; row++, pix0+=width*4, pix1+=width*4)\n\tFORCC img[row*newdim+col][c] = pix0[c]*(1-frac) + pix1[c]*frac + 0.5;\n    }\n    width = newdim;\n  }\n  free (image);\n  image = img;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH,1,2);\n#endif\n}\n\nint CLASS flip_index (int row, int col)\n{\n  if (flip & 4) SWAP(row,col);\n  if (flip & 2) row = iheight - 1 - row;\n  if (flip & 1) col = iwidth  - 1 - col;\n  return row * iwidth + col;\n}\n//@end COMMON\n\n\nstruct tiff_tag {\n  ushort tag, type;\n  int count;\n  union { char c[4]; short s[2]; int i; } val;\n};\n\nstruct tiff_hdr {\n  ushort t_order, magic;\n  int ifd;\n  ushort pad, ntag;\n  struct tiff_tag tag[23];\n  int nextifd;\n  ushort pad2, nexif;\n  struct tiff_tag exif[4];\n  ushort pad3, ngps;\n  struct tiff_tag gpst[10];\n  short bps[4];\n  int rat[10];\n  unsigned gps[26];\n  char t_desc[512], t_make[64], t_model[64], soft[32], date[20], t_artist[64];\n};\n\n//@out COMMON\nvoid CLASS tiff_set (ushort *ntag,\n\tushort tag, ushort type, int count, int val)\n{\n  struct tiff_tag *tt;\n  int c;\n\n  tt = (struct tiff_tag *)(ntag+1) + (*ntag)++;\n  tt->tag = tag;\n  tt->type = type;\n  tt->count = count;\n  if (type < 3 && count <= 4)\n    FORC(4) tt->val.c[c] = val >> (c << 3);\n  else if (type == 3 && count <= 2)\n    FORC(2) tt->val.s[c] = val >> (c << 4);\n  else tt->val.i = val;\n}\n\n#define TOFF(ptr) ((char *)(&(ptr)) - (char *)th)\n\nvoid CLASS tiff_head (struct tiff_hdr *th, int full)\n{\n  int c, psize=0;\n  struct tm *t;\n\n  memset (th, 0, sizeof *th);\n  th->t_order = htonl(0x4d4d4949) >> 16;\n  th->magic = 42;\n  th->ifd = 10;\n  if (full) {\n    tiff_set (&th->ntag, 254, 4, 1, 0);\n    tiff_set (&th->ntag, 256, 4, 1, width);\n    tiff_set (&th->ntag, 257, 4, 1, height);\n    tiff_set (&th->ntag, 258, 3, colors, output_bps);\n    if (colors > 2)\n      th->tag[th->ntag-1].val.i = TOFF(th->bps);\n    FORC4 th->bps[c] = output_bps;\n    tiff_set (&th->ntag, 259, 3, 1, 1);\n    tiff_set (&th->ntag, 262, 3, 1, 1 + (colors > 1));\n  }\n  tiff_set (&th->ntag, 270, 2, 512, TOFF(th->t_desc));\n  tiff_set (&th->ntag, 271, 2, 64, TOFF(th->t_make));\n  tiff_set (&th->ntag, 272, 2, 64, TOFF(th->t_model));\n  if (full) {\n    if (oprof) psize = ntohl(oprof[0]);\n    tiff_set (&th->ntag, 273, 4, 1, sizeof *th + psize);\n    tiff_set (&th->ntag, 277, 3, 1, colors);\n    tiff_set (&th->ntag, 278, 4, 1, height);\n    tiff_set (&th->ntag, 279, 4, 1, height*width*colors*output_bps/8);\n  } else\n    tiff_set (&th->ntag, 274, 3, 1, \"12435867\"[flip]-'0');\n  tiff_set (&th->ntag, 282, 5, 1, TOFF(th->rat[0]));\n  tiff_set (&th->ntag, 283, 5, 1, TOFF(th->rat[2]));\n  tiff_set (&th->ntag, 284, 3, 1, 1);\n  tiff_set (&th->ntag, 296, 3, 1, 2);\n  tiff_set (&th->ntag, 305, 2, 32, TOFF(th->soft));\n  tiff_set (&th->ntag, 306, 2, 20, TOFF(th->date));\n  tiff_set (&th->ntag, 315, 2, 64, TOFF(th->t_artist));\n  tiff_set (&th->ntag, 34665, 4, 1, TOFF(th->nexif));\n  if (psize) tiff_set (&th->ntag, 34675, 7, psize, sizeof *th);\n  tiff_set (&th->nexif, 33434, 5, 1, TOFF(th->rat[4]));\n  tiff_set (&th->nexif, 33437, 5, 1, TOFF(th->rat[6]));\n  tiff_set (&th->nexif, 34855, 3, 1, iso_speed);\n  tiff_set (&th->nexif, 37386, 5, 1, TOFF(th->rat[8]));\n  if (gpsdata[1]) {\n    tiff_set (&th->ntag, 34853, 4, 1, TOFF(th->ngps));\n    tiff_set (&th->ngps,  0, 1,  4, 0x202);\n    tiff_set (&th->ngps,  1, 2,  2, gpsdata[29]);\n    tiff_set (&th->ngps,  2, 5,  3, TOFF(th->gps[0]));\n    tiff_set (&th->ngps,  3, 2,  2, gpsdata[30]);\n    tiff_set (&th->ngps,  4, 5,  3, TOFF(th->gps[6]));\n    tiff_set (&th->ngps,  5, 1,  1, gpsdata[31]);\n    tiff_set (&th->ngps,  6, 5,  1, TOFF(th->gps[18]));\n    tiff_set (&th->ngps,  7, 5,  3, TOFF(th->gps[12]));\n    tiff_set (&th->ngps, 18, 2, 12, TOFF(th->gps[20]));\n    tiff_set (&th->ngps, 29, 2, 12, TOFF(th->gps[23]));\n    memcpy (th->gps, gpsdata, sizeof th->gps);\n  }\n  th->rat[0] = th->rat[2] = 300;\n  th->rat[1] = th->rat[3] = 1;\n  FORC(6) th->rat[4+c] = 1000000;\n  th->rat[4] *= shutter;\n  th->rat[6] *= aperture;\n  th->rat[8] *= focal_len;\n  strncpy (th->t_desc, desc, 512);\n  strncpy (th->t_make, make, 64);\n  strncpy (th->t_model, model, 64);\n  strcpy (th->soft, \"dcraw v\"DCRAW_VERSION);\n  t = localtime (&timestamp);\n  sprintf (th->date, \"%04d:%02d:%02d %02d:%02d:%02d\",\n      t->tm_year+1900,t->tm_mon+1,t->tm_mday,t->tm_hour,t->tm_min,t->tm_sec);\n  strncpy (th->t_artist, artist, 64);\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\nvoid CLASS jpeg_thumb_writer (FILE *tfp,char *t_humb,int t_humb_length)\n{\n  ushort exif[5];\n  struct tiff_hdr th;\n  fputc (0xff, tfp);\n  fputc (0xd8, tfp);\n  if (strcmp (t_humb+6, \"Exif\")) {\n    memcpy (exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n    exif[1] = htons (8 + sizeof th);\n    fwrite (exif, 1, sizeof exif, tfp);\n    tiff_head (&th, 0);\n    fwrite (&th, 1, sizeof th, tfp);\n  }\n  fwrite (t_humb+2, 1, t_humb_length-2, tfp);\n}\n\nvoid CLASS jpeg_thumb()\n{\n  char *thumb;\n\n  thumb = (char *) malloc (thumb_length);\n  merror (thumb, \"jpeg_thumb()\");\n  fread (thumb, 1, thumb_length, ifp);\n  jpeg_thumb_writer(ofp,thumb,thumb_length);\n  free (thumb);\n}\n#else\nvoid CLASS jpeg_thumb()\n{\n  char *thumb;\n  ushort exif[5];\n  struct tiff_hdr th;\n\n  thumb = (char *) malloc (thumb_length);\n  merror (thumb, \"jpeg_thumb()\");\n  fread (thumb, 1, thumb_length, ifp);\n  fputc (0xff, ofp);\n  fputc (0xd8, ofp);\n  if (strcmp (thumb+6, \"Exif\")) {\n    memcpy (exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n    exif[1] = htons (8 + sizeof th);\n    fwrite (exif, 1, sizeof exif, ofp);\n    tiff_head (&th, 0);\n    fwrite (&th, 1, sizeof th, ofp);\n  }\n  fwrite (thumb+2, 1, thumb_length-2, ofp);\n  free (thumb);\n}\n#endif\n\nvoid CLASS write_ppm_tiff()\n{\n  struct tiff_hdr th;\n  uchar *ppm;\n  ushort *ppm2;\n  int c, row, col, soff, rstep, cstep;\n  int perc, val, total, t_white=0x2000;\n\n  perc = width * height * 0.01;\t\t/* 99th percentile white level */\n  if (fuji_width) perc /= 2;\n  if (!((highlight & ~2) || no_auto_bright))\n    for (t_white=c=0; c < colors; c++) {\n      for (val=0x2000, total=0; --val > 32; )\n\tif ((total += histogram[c][val]) > perc) break;\n      if (t_white < val) t_white = val;\n    }\n  gamma_curve (gamm[0], gamm[1], 2, (t_white << 3)/bright);\n  iheight = height;\n  iwidth  = width;\n  if (flip & 4) SWAP(height,width);\n  ppm = (uchar *) calloc (width, colors*output_bps/8);\n  ppm2 = (ushort *) ppm;\n  merror (ppm, \"write_ppm_tiff()\");\n  if (output_tiff) {\n    tiff_head (&th, 1);\n    fwrite (&th, sizeof th, 1, ofp);\n    if (oprof)\n      fwrite (oprof, ntohl(oprof[0]), 1, ofp);\n  } else if (colors > 3)\n    fprintf (ofp,\n      \"P7\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %d\\nMAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\",\n\twidth, height, colors, (1 << output_bps)-1, cdesc);\n  else\n    fprintf (ofp, \"P%d\\n%d %d\\n%d\\n\",\n\tcolors/2+5, width, height, (1 << output_bps)-1);\n  soff  = flip_index (0, 0);\n  cstep = flip_index (0, 1) - soff;\n  rstep = flip_index (1, 0) - flip_index (0, width);\n  for (row=0; row < height; row++, soff += rstep) {\n    for (col=0; col < width; col++, soff += cstep)\n      if (output_bps == 8)\n\t   FORCC ppm [col*colors+c] = curve[image[soff][c]] >> 8;\n      else FORCC ppm2[col*colors+c] = curve[image[soff][c]];\n    if (output_bps == 16 && !output_tiff && htons(0x55aa) != 0x55aa)\n      swab ((char*)ppm2, (char*)ppm2, width*colors*2);\n    fwrite (ppm, colors*output_bps/8, width, ofp);\n  }\n  free (ppm);\n}\n//@end COMMON\n\nint CLASS main (int argc, const char **argv)\n{\n  int arg, status=0, quality, i, c;\n  int timestamp_only=0, thumbnail_only=0, identify_only=0;\n  int user_qual=-1, user_black=-1, user_sat=-1, user_flip=-1;\n  int use_fuji_rotate=1, write_to_stdout=0, read_from_stdin=0;\n  const char *sp, *bpfile=0, *dark_frame=0, *write_ext;\n  char opm, opt, *ofname, *cp;\n  struct utimbuf ut;\n#ifndef NO_LCMS\n  const char *cam_profile=0, *out_profile=0;\n#endif\n\n#ifndef LOCALTIME\n  putenv ((char *) \"TZ=UTC\");\n#endif\n#ifdef LOCALEDIR\n  setlocale (LC_CTYPE, \"\");\n  setlocale (LC_MESSAGES, \"\");\n  bindtextdomain (\"dcraw\", LOCALEDIR);\n  textdomain (\"dcraw\");\n#endif\n\n  if (argc == 1) {\n    printf(_(\"\\nRaw photo decoder \\\"dcraw\\\" v%s\"), DCRAW_VERSION);\n    printf(_(\"\\nby Dave Coffin, dcoffin a cybercom o net\\n\"));\n    printf(_(\"\\nUsage:  %s [OPTION]... [FILE]...\\n\\n\"), argv[0]);\n    puts(_(\"-v        Print verbose messages\"));\n    puts(_(\"-c        Write image data to standard output\"));\n    puts(_(\"-e        Extract embedded thumbnail image\"));\n    puts(_(\"-i        Identify files without decoding them\"));\n    puts(_(\"-i -v     Identify files and show metadata\"));\n    puts(_(\"-z        Change file dates to camera timestamp\"));\n    puts(_(\"-w        Use camera white balance, if possible\"));\n    puts(_(\"-a        Average the whole image for white balance\"));\n    puts(_(\"-A <x y w h> Average a grey box for white balance\"));\n    puts(_(\"-r <r g b g> Set custom white balance\"));\n    puts(_(\"+M/-M     Use/don't use an embedded color matrix\"));\n    puts(_(\"-C <r b>  Correct chromatic aberration\"));\n    puts(_(\"-P <file> Fix the dead pixels listed in this file\"));\n    puts(_(\"-K <file> Subtract dark frame (16-bit raw PGM)\"));\n    puts(_(\"-k <num>  Set the darkness level\"));\n    puts(_(\"-S <num>  Set the saturation level\"));\n    puts(_(\"-n <num>  Set threshold for wavelet denoising\"));\n    puts(_(\"-H [0-9]  Highlight mode (0=clip, 1=unclip, 2=blend, 3+=rebuild)\"));\n    puts(_(\"-t [0-7]  Flip image (0=none, 3=180, 5=90CCW, 6=90CW)\"));\n    puts(_(\"-o [0-5]  Output colorspace (raw,sRGB,Adobe,Wide,ProPhoto,XYZ)\"));\n#ifndef NO_LCMS\n    puts(_(\"-o <file> Apply output ICC profile from file\"));\n    puts(_(\"-p <file> Apply camera ICC profile from file or \\\"embed\\\"\"));\n#endif\n    puts(_(\"-d        Document mode (no color, no interpolation)\"));\n    puts(_(\"-D        Document mode without scaling (totally raw)\"));\n    puts(_(\"-j        Don't stretch or rotate raw pixels\"));\n    puts(_(\"-W        Don't automatically brighten the image\"));\n    puts(_(\"-b <num>  Adjust brightness (default = 1.0)\"));\n    puts(_(\"-g <p ts> Set custom gamma curve (default = 2.222 4.5)\"));\n    puts(_(\"-q [0-3]  Set the interpolation quality\"));\n    puts(_(\"-h        Half-size color image (twice as fast as \\\"-q 0\\\")\"));\n    puts(_(\"-f        Interpolate RGGB as four colors\"));\n    puts(_(\"-m <num>  Apply a 3x3 median filter to R-G and B-G\"));\n    puts(_(\"-s [0..N-1] Select one raw image or \\\"all\\\" from each file\"));\n    puts(_(\"-6        Write 16-bit instead of 8-bit\"));\n    puts(_(\"-4        Linear 16-bit, same as \\\"-6 -W -g 1 1\\\"\"));\n    puts(_(\"-T        Write TIFF instead of PPM\"));\n    puts(\"\");\n    return 1;\n  }\n  argv[argc] = \"\";\n  for (arg=1; (((opm = argv[arg][0]) - 2) | 2) == '+'; ) {\n    opt = argv[arg++][1];\n    if ((cp = (char *) strchr (sp=\"nbrkStqmHACg\", opt)))\n      for (i=0; i < \"114111111422\"[cp-sp]-'0'; i++)\n\tif (!isdigit(argv[arg+i][0])) {\n\t  fprintf (stderr,_(\"Non-numeric argument to \\\"-%c\\\"\\n\"), opt);\n\t  return 1;\n\t}\n    switch (opt) {\n      case 'n':  threshold   = atof(argv[arg++]);  break;\n      case 'b':  bright      = atof(argv[arg++]);  break;\n      case 'r':\n\t   FORC4 user_mul[c] = atof(argv[arg++]);  break;\n      case 'C':  aber[0] = 1 / atof(argv[arg++]);\n\t\t aber[2] = 1 / atof(argv[arg++]);  break;\n      case 'g':  gamm[0] =     atof(argv[arg++]);\n\t\t gamm[1] =     atof(argv[arg++]);\n\t\t if (gamm[0]) gamm[0] = 1/gamm[0]; break;\n      case 'k':  user_black  = atoi(argv[arg++]);  break;\n      case 'S':  user_sat    = atoi(argv[arg++]);  break;\n      case 't':  user_flip   = atoi(argv[arg++]);  break;\n      case 'q':  user_qual   = atoi(argv[arg++]);  break;\n      case 'm':  med_passes  = atoi(argv[arg++]);  break;\n      case 'H':  highlight   = atoi(argv[arg++]);  break;\n      case 's':\n\tshot_select = abs(atoi(argv[arg]));\n\tmulti_out = !strcmp(argv[arg++],\"all\");\n\tbreak;\n      case 'o':\n\tif (isdigit(argv[arg][0]) && !argv[arg][1])\n\t  output_color = atoi(argv[arg++]);\n#ifndef NO_LCMS\n\telse     out_profile = argv[arg++];\n\tbreak;\n      case 'p':  cam_profile = argv[arg++];\n#endif\n\tbreak;\n      case 'P':  bpfile     = argv[arg++];  break;\n      case 'K':  dark_frame = argv[arg++];  break;\n      case 'z':  timestamp_only    = 1;  break;\n      case 'e':  thumbnail_only    = 1;  break;\n      case 'i':  identify_only     = 1;  break;\n      case 'c':  write_to_stdout   = 1;  break;\n      case 'v':  verbose           = 1;  break;\n      case 'h':  half_size         = 1;\t\t/* \"-h\" implies \"-f\" */\n      case 'f':  four_color_rgb    = 1;  break;\n      case 'A':  FORC4 greybox[c]  = atoi(argv[arg++]);\n      case 'a':  use_auto_wb       = 1;  break;\n      case 'w':  use_camera_wb     = 1;  break;\n      case 'M':  use_camera_matrix = (opm == '+');  break;\n      case 'I':  read_from_stdin   = 1;  break;\n      case 'E':  document_mode++;\n      case 'D':  document_mode++;\n      case 'd':  document_mode++;\n      case 'j':  use_fuji_rotate   = 0;  break;\n      case 'W':  no_auto_bright    = 1;  break;\n      case 'T':  output_tiff       = 1;  break;\n      case '4':  gamm[0] = gamm[1] =\n\t\t no_auto_bright    = 1;\n      case '6':  output_bps       = 16;  break;\n      default:\n\tfprintf (stderr,_(\"Unknown option \\\"-%c\\\".\\n\"), opt);\n\treturn 1;\n    }\n  }\n  if (use_camera_matrix < 0)\n      use_camera_matrix = use_camera_wb;\n  if (arg == argc) {\n    fprintf (stderr,_(\"No files to process.\\n\"));\n    return 1;\n  }\n  if (write_to_stdout) {\n    if (isatty(1)) {\n      fprintf (stderr,_(\"Will not write an image to the terminal!\\n\"));\n      return 1;\n    }\n#if defined(WIN32) || defined(DJGPP) || defined(__CYGWIN__)\n    if (setmode(1,O_BINARY) < 0) {\n      perror (\"setmode()\");\n      return 1;\n    }\n#endif\n  }\n  for ( ; arg < argc; arg++) {\n    status = 1;\n    raw_image = 0;\n    image = 0;\n    oprof = 0;\n    meta_data = ofname = 0;\n    ofp = stdout;\n    if (setjmp (failure)) {\n      if (fileno(ifp) > 2) fclose(ifp);\n      if (fileno(ofp) > 2) fclose(ofp);\n      status = 1;\n      goto cleanup;\n    }\n    ifname = argv[arg];\n    if (!(ifp = fopen (ifname, \"rb\"))) {\n      perror (ifname);\n      continue;\n    }\n    status = (identify(),!is_raw);\n    if (user_flip >= 0)\n      flip = user_flip;\n    switch ((flip+3600) % 360) {\n      case 270:  flip = 5;  break;\n      case 180:  flip = 3;  break;\n      case  90:  flip = 6;\n    }\n    if (timestamp_only) {\n      if ((status = !timestamp))\n\tfprintf (stderr,_(\"%s has no timestamp.\\n\"), ifname);\n      else if (identify_only)\n\tprintf (\"%10ld%10d %s\\n\", (long) timestamp, shot_order, ifname);\n      else {\n\tif (verbose)\n\t  fprintf (stderr,_(\"%s time set to %d.\\n\"), ifname, (int) timestamp);\n\tut.actime = ut.modtime = timestamp;\n\tutime (ifname, &ut);\n      }\n      goto next;\n    }\n    write_fun = &CLASS write_ppm_tiff;\n    if (thumbnail_only) {\n      if ((status = !thumb_offset)) {\n\tfprintf (stderr,_(\"%s has no thumbnail.\\n\"), ifname);\n\tgoto next;\n      } else if (thumb_load_raw) {\n\tload_raw = thumb_load_raw;\n\tdata_offset = thumb_offset;\n\theight = thumb_height;\n\twidth  = thumb_width;\n\tfilters = 0;\n      } else {\n\tfseek (ifp, thumb_offset, SEEK_SET);\n\twrite_fun = write_thumb;\n\tgoto thumbnail;\n      }\n    }\n    if (load_raw == &CLASS kodak_ycbcr_load_raw) {\n      height += height & 1;\n      width  += width  & 1;\n    }\n    if (identify_only && verbose && make[0]) {\n      printf (_(\"\\nFilename: %s\\n\"), ifname);\n      printf (_(\"Timestamp: %s\"), ctime(&timestamp));\n      printf (_(\"Camera: %s %s\\n\"), make, model);\n      if (artist[0])\n\tprintf (_(\"Owner: %s\\n\"), artist);\n      if (dng_version) {\n\tprintf (_(\"DNG Version: \"));\n\tfor (i=24; i >= 0; i -= 8)\n\t  printf (\"%d%c\", dng_version >> i & 255, i ? '.':'\\n');\n      }\n      printf (_(\"ISO speed: %d\\n\"), (int) iso_speed);\n      printf (_(\"Shutter: \"));\n      if (shutter > 0 && shutter < 1)\n\tshutter = (printf (\"1/\"), 1 / shutter);\n      printf (_(\"%0.1f sec\\n\"), shutter);\n      printf (_(\"Aperture: f/%0.1f\\n\"), aperture);\n      printf (_(\"Focal length: %0.1f mm\\n\"), focal_len);\n      printf (_(\"Embedded ICC profile: %s\\n\"), profile_length ? _(\"yes\"):_(\"no\"));\n      printf (_(\"Number of raw images: %d\\n\"), is_raw);\n      if (pixel_aspect != 1)\n\tprintf (_(\"Pixel Aspect Ratio: %0.6f\\n\"), pixel_aspect);\n      if (thumb_offset)\n\tprintf (_(\"Thumb size:  %4d x %d\\n\"), thumb_width, thumb_height);\n      printf (_(\"Full size:   %4d x %d\\n\"), raw_width, raw_height);\n    } else if (!is_raw)\n      fprintf (stderr,_(\"Cannot decode file %s\\n\"), ifname);\n    if (!is_raw) goto next;\n    shrink = filters && (half_size || (!identify_only &&\n\t(threshold || aber[0] != 1 || aber[2] != 1)));\n    iheight = (height + shrink) >> shrink;\n    iwidth  = (width  + shrink) >> shrink;\n    if (identify_only) {\n      if (verbose) {\n\tif (document_mode == 3) {\n\t  top_margin = left_margin = fuji_width = 0;\n\t  height = raw_height;\n\t  if  (width <= raw_width * 8 / tiff_bps)\n\t       width  = raw_width * 8 / tiff_bps;\n\t  else width  = raw_width;\n\t}\n\tiheight = (height + shrink) >> shrink;\n\tiwidth  = (width  + shrink) >> shrink;\n\tif (use_fuji_rotate) {\n\t  if (fuji_width) {\n\t    fuji_width = (fuji_width - 1 + shrink) >> shrink;\n\t    iwidth = fuji_width / sqrt(0.5);\n\t    iheight = (iheight - fuji_width) / sqrt(0.5);\n\t  } else {\n\t    if (pixel_aspect < 1) iheight = iheight / pixel_aspect + 0.5;\n\t    if (pixel_aspect > 1) iwidth  = iwidth  * pixel_aspect + 0.5;\n\t  }\n\t}\n\tif (flip & 4)\n\t  SWAP(iheight,iwidth);\n\tprintf (_(\"Image size:  %4d x %d\\n\"), width, height);\n\tprintf (_(\"Output size: %4d x %d\\n\"), iwidth, iheight);\n\tprintf (_(\"Raw colors: %d\"), colors);\n\tif (filters) {\n\t  printf (_(\"\\nFilter pattern: \"));\n\t  for (i=0; i < 16; i++)\n\t    putchar (cdesc[fcol(i >> 1,i & 1)]);\n\t}\n\tprintf (_(\"\\nDaylight multipliers:\"));\n\tFORCC printf (\" %f\", pre_mul[c]);\n\tif (cam_mul[0] > 0) {\n\t  printf (_(\"\\nCamera multipliers:\"));\n\t  FORC4 printf (\" %f\", cam_mul[c]);\n\t}\n\tputchar ('\\n');\n      } else\n\tprintf (_(\"%s is a %s %s image.\\n\"), ifname, make, model);\nnext:\n      fclose(ifp);\n      continue;\n    }\n    if (use_camera_matrix && cmatrix[0][0] > 0.25) {\n      memcpy (rgb_cam, cmatrix, sizeof cmatrix);\n      raw_color = 0;\n    }\n    if (meta_length) {\n      meta_data = (char *) malloc (meta_length);\n      merror (meta_data, \"main()\");\n    }\n    if (filters || colors == 1) {\n      raw_image = (ushort *) calloc ((raw_height+7)*raw_width, 2);\n      merror (raw_image, \"main()\");\n    } else {\n      image = (ushort (*)[4]) calloc (iheight*iwidth, sizeof *image);\n      merror (image, \"main()\");\n    }\n    if (verbose)\n      fprintf (stderr,_(\"Loading %s %s image from %s ...\\n\"),\n\tmake, model, ifname);\n    if (shot_select >= is_raw)\n      fprintf (stderr,_(\"%s: \\\"-s %d\\\" requests a nonexistent image!\\n\"),\n\tifname, shot_select);\n    fseeko (ifp, data_offset, SEEK_SET);\n    if (raw_image && read_from_stdin)\n      fread (raw_image, 2, raw_height*raw_width, stdin);\n    else (*load_raw)();\n    if (document_mode == 3) {\n      top_margin = left_margin = fuji_width = 0;\n      height = raw_height;\n      if  (width <= raw_width * 8 / tiff_bps)\n           width  = raw_width * 8 / tiff_bps;\n      else width  = raw_width;\n    }\n    iheight = (height + shrink) >> shrink;\n    iwidth  = (width  + shrink) >> shrink;\n    if (raw_image) {\n      image = (ushort (*)[4]) calloc (iheight*iwidth, sizeof *image);\n      merror (image, \"main()\");\n      crop_masked_pixels();\n      free (raw_image);\n    }\n    if (zero_is_bad) remove_zeroes();\n    bad_pixels (bpfile);\n    if (dark_frame) subtract (dark_frame);\n    quality = 2 + !fuji_width;\n    if (user_qual >= 0) quality = user_qual;\n    i = cblack[3];\n    FORC3 if (i > cblack[c]) i = cblack[c];\n    FORC4 cblack[c] -= i;\n    black += i;\n    if (user_black >= 0) black = user_black;\n    FORC4 cblack[c] += black;\n    if (user_sat > 0) maximum = user_sat;\n#ifdef COLORCHECK\n    colorcheck();\n#endif\n    if (is_foveon) {\n      if (document_mode || load_raw == &CLASS foveon_dp_load_raw) {\n\tfor (i=0; i < height*width*4; i++)\n\t  if ((short) image[0][i] < 0) image[0][i] = 0;\n      } else foveon_interpolate();\n    } else if (document_mode < 2)\n      scale_colors();\n    pre_interpolate();\n    if (filters && !document_mode) {\n      if (quality == 0)\n\tlin_interpolate();\n      else if (quality == 1 || colors > 3 || filters < 1000)\n\tvng_interpolate();\n      else if (quality == 2)\n\tppg_interpolate();\n      else ahd_interpolate();\n    }\n    if (mix_green)\n      for (colors=3, i=0; i < height*width; i++)\n\timage[i][1] = (image[i][1] + image[i][3]) >> 1;\n    if (!is_foveon && colors == 3) median_filter();\n    if (!is_foveon && highlight == 2) blend_highlights();\n    if (!is_foveon && highlight > 2) recover_highlights();\n    if (use_fuji_rotate) fuji_rotate();\n#ifndef NO_LCMS\n    if (cam_profile) apply_profile (cam_profile, out_profile);\n#endif\n    convert_to_rgb();\n    if (use_fuji_rotate) stretch();\nthumbnail:\n    if (write_fun == &CLASS jpeg_thumb)\n      write_ext = \".jpg\";\n    else if (output_tiff && write_fun == &CLASS write_ppm_tiff)\n      write_ext = \".tiff\";\n    else\n      write_ext = \".pgm\\0.ppm\\0.ppm\\0.pam\" + colors*5-5;\n    ofname = (char *) malloc (strlen(ifname) + 64);\n    merror (ofname, \"main()\");\n    if (write_to_stdout)\n      strcpy (ofname,_(\"standard output\"));\n    else {\n      strcpy (ofname, ifname);\n      if ((cp = strrchr (ofname, '.'))) *cp = 0;\n      if (multi_out)\n\tsprintf (ofname+strlen(ofname), \"_%0*d\",\n\t\tsnprintf(0,0,\"%d\",is_raw-1), shot_select);\n      if (thumbnail_only)\n\tstrcat (ofname, \".thumb\");\n      strcat (ofname, write_ext);\n      ofp = fopen (ofname, \"wb\");\n      if (!ofp) {\n\tstatus = 1;\n\tperror (ofname);\n\tgoto cleanup;\n      }\n    }\n    if (verbose)\n      fprintf (stderr,_(\"Writing data to %s ...\\n\"), ofname);\n    (*write_fun)();\n    fclose(ifp);\n    if (ofp != stdout) fclose(ofp);\ncleanup:\n    if (meta_data) free (meta_data);\n    if (ofname) free (ofname);\n    if (oprof) free (oprof);\n    if (image) free (image);\n    if (multi_out) {\n      if (++shot_select < is_raw) arg--;\n      else shot_select = 0;\n    }\n  }\n  return status;\n}\n#endif\n", "/* \n  Copyright 2008-2013 LibRaw LLC (info@libraw.org)\n\nLibRaw is free software; you can redistribute it and/or modify\nit under the terms of the one of three licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n3. LibRaw Software License 27032010\n   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).\n\n   This file is generated from Dave Coffin's dcraw.c\n   dcraw.c -- Dave Coffin's raw photo decoder\n   Copyright 1997-2010 by Dave Coffin, dcoffin a cybercom o net\n\n   Look into dcraw homepage (probably http://cybercom.net/~dcoffin/dcraw/)\n   for more information\n*/\n\n#line 257 \"dcraw/dcraw.c\"\n#include <math.h>\n#define CLASS LibRaw::\n#include \"libraw/libraw_types.h\"\n#define LIBRAW_LIBRARY_BUILD\n#define LIBRAW_IO_REDEFINED\n#include \"libraw/libraw.h\"\n#include \"internal/defines.h\"\n#include \"internal/var_defines.h\"\n#include \"internal/libraw_bytebuffer.h\"\n#line 269 \"dcraw/dcraw.c\"\nint CLASS fcol (int row, int col)\n{\n  static const char filter[16][16] =\n  { { 2,1,1,3,2,3,2,0,3,2,3,0,1,2,1,0 },\n    { 0,3,0,2,0,1,3,1,0,1,1,2,0,3,3,2 },\n    { 2,3,3,2,3,1,1,3,3,1,2,1,2,0,0,3 },\n    { 0,1,0,1,0,2,0,2,2,0,3,0,1,3,2,1 },\n    { 3,1,1,2,0,1,0,2,1,3,1,3,0,1,3,0 },\n    { 2,0,0,3,3,2,3,1,2,0,2,0,3,2,2,1 },\n    { 2,3,3,1,2,1,2,1,2,1,1,2,3,0,0,1 },\n    { 1,0,0,2,3,0,0,3,0,3,0,3,2,1,2,3 },\n    { 2,3,3,1,1,2,1,0,3,2,3,0,2,3,1,3 },\n    { 1,0,2,0,3,0,3,2,0,1,1,2,0,1,0,2 },\n    { 0,1,1,3,3,2,2,1,1,3,3,0,2,1,3,2 },\n    { 2,3,2,0,0,1,3,0,2,0,1,2,3,0,1,0 },\n    { 1,3,1,2,3,2,3,2,0,2,0,1,1,0,3,0 },\n    { 0,2,0,3,1,0,0,1,1,3,3,2,3,2,2,1 },\n    { 2,1,3,2,3,1,2,1,0,3,0,2,0,2,0,2 },\n    { 0,3,1,0,0,2,0,3,2,1,3,1,1,3,1,3 } };\n  static const char filter2[6][6] =\n  { { 1,1,0,1,1,2 },\n    { 1,1,2,1,1,0 },\n    { 2,0,1,0,2,1 },\n    { 1,1,2,1,1,0 },\n    { 1,1,0,1,1,2 },\n    { 0,2,1,2,0,1 } };\n\n  if (filters == 1) return filter[(row+top_margin)&15][(col+left_margin)&15];\n  if (filters == 2) return filter2[(row+6) % 6][(col+6) % 6];\n  return FC(row,col);\n}\n\n#ifndef __GLIBC__\nchar *my_memmem (char *haystack, size_t haystacklen,\n\t      char *needle, size_t needlelen)\n{\n  char *c;\n  for (c = haystack; c <= haystack + haystacklen - needlelen; c++)\n    if (!memcmp (c, needle, needlelen))\n      return c;\n  return 0;\n}\n#define memmem my_memmem\n#endif\n#line 335 \"dcraw/dcraw.c\"\nushort CLASS sget2 (uchar *s)\n{\n  if (order == 0x4949)\t\t/* \"II\" means little-endian */\n    return s[0] | s[1] << 8;\n  else\t\t\t\t/* \"MM\" means big-endian */\n    return s[0] << 8 | s[1];\n}\n\nushort CLASS get2()\n{\n  uchar str[2] = { 0xff,0xff };\n  fread (str, 1, 2, ifp);\n  return sget2(str);\n}\n\nunsigned CLASS sget4 (uchar *s)\n{\n  if (order == 0x4949)\n    return s[0] | s[1] << 8 | s[2] << 16 | s[3] << 24;\n  else\n    return s[0] << 24 | s[1] << 16 | s[2] << 8 | s[3];\n}\n#define sget4(s) sget4((uchar *)s)\n\nunsigned CLASS get4()\n{\n  uchar str[4] = { 0xff,0xff,0xff,0xff };\n  fread (str, 1, 4, ifp);\n  return sget4(str);\n}\n\nunsigned CLASS getint (int type)\n{\n  return type == 3 ? get2() : get4();\n}\n\nfloat CLASS int_to_float (int i)\n{\n  union { int i; float f; } u;\n  u.i = i;\n  return u.f;\n}\n\ndouble CLASS getreal (int type)\n{\n  union { char c[8]; double d; } u;\n  int i, rev;\n\n  switch (type) {\n    case 3: return (unsigned short) get2();\n    case 4: return (unsigned int) get4();\n    case 5:  u.d = (unsigned int) get4();\n      return u.d / (unsigned int) get4();\n    case 8: return (signed short) get2();\n    case 9: return (signed int) get4();\n    case 10: u.d = (signed int) get4();\n      return u.d / (signed int) get4();\n    case 11: return int_to_float (get4());\n    case 12:\n      rev = 7 * ((order == 0x4949) == (ntohs(0x1234) == 0x1234));\n      for (i=0; i < 8; i++)\n\tu.c[i ^ rev] = fgetc(ifp);\n      return u.d;\n    default: return fgetc(ifp);\n  }\n}\n\nvoid CLASS read_shorts (ushort *pixel, int count)\n{\n  if (fread (pixel, 2, count, ifp) < count) derror();\n  if ((order == 0x4949) == (ntohs(0x1234) == 0x1234))\n    swab ((char*)pixel, (char*)pixel, count*2);\n}\n\nvoid CLASS canon_600_fixed_wb (int temp)\n{\n  static const short mul[4][5] = {\n    {  667, 358,397,565,452 },\n    {  731, 390,367,499,517 },\n    { 1119, 396,348,448,537 },\n    { 1399, 485,431,508,688 } };\n  int lo, hi, i;\n  float frac=0;\n\n  for (lo=4; --lo; )\n    if (*mul[lo] <= temp) break;\n  for (hi=0; hi < 3; hi++)\n    if (*mul[hi] >= temp) break;\n  if (lo != hi)\n    frac = (float) (temp - *mul[lo]) / (*mul[hi] - *mul[lo]);\n  for (i=1; i < 5; i++)\n    pre_mul[i-1] = 1 / (frac * mul[hi][i] + (1-frac) * mul[lo][i]);\n}\n\n/* Return values:  0 = white  1 = near white  2 = not white */\nint CLASS canon_600_color (int ratio[2], int mar)\n{\n  int clipped=0, target, miss;\n\n  if (flash_used) {\n    if (ratio[1] < -104)\n      { ratio[1] = -104; clipped = 1; }\n    if (ratio[1] >   12)\n      { ratio[1] =   12; clipped = 1; }\n  } else {\n    if (ratio[1] < -264 || ratio[1] > 461) return 2;\n    if (ratio[1] < -50)\n      { ratio[1] = -50; clipped = 1; }\n    if (ratio[1] > 307)\n      { ratio[1] = 307; clipped = 1; }\n  }\n  target = flash_used || ratio[1] < 197\n\t? -38 - (398 * ratio[1] >> 10)\n\t: -123 + (48 * ratio[1] >> 10);\n  if (target - mar <= ratio[0] &&\n      target + 20  >= ratio[0] && !clipped) return 0;\n  miss = target - ratio[0];\n  if (abs(miss) >= mar*4) return 2;\n  if (miss < -20) miss = -20;\n  if (miss > mar) miss = mar;\n  ratio[0] = target - miss;\n  return 1;\n}\n\nvoid CLASS canon_600_auto_wb()\n{\n  int mar, row, col, i, j, st, count[] = { 0,0 };\n  int test[8], total[2][8], ratio[2][2], stat[2];\n\n  memset (&total, 0, sizeof total);\n  i = canon_ev + 0.5;\n  if      (i < 10) mar = 150;\n  else if (i > 12) mar = 20;\n  else mar = 280 - 20 * i;\n  if (flash_used) mar = 80;\n  for (row=14; row < height-14; row+=4)\n    for (col=10; col < width; col+=2) {\n      for (i=0; i < 8; i++)\n\ttest[(i & 4) + FC(row+(i >> 1),col+(i & 1))] =\n\t\t    BAYER(row+(i >> 1),col+(i & 1));\n      for (i=0; i < 8; i++)\n\tif (test[i] < 150 || test[i] > 1500) goto next;\n      for (i=0; i < 4; i++)\n\tif (abs(test[i] - test[i+4]) > 50) goto next;\n      for (i=0; i < 2; i++) {\n\tfor (j=0; j < 4; j+=2)\n\t  ratio[i][j >> 1] = ((test[i*4+j+1]-test[i*4+j]) << 10) / test[i*4+j];\n\tstat[i] = canon_600_color (ratio[i], mar);\n      }\n      if ((st = stat[0] | stat[1]) > 1) goto next;\n      for (i=0; i < 2; i++)\n\tif (stat[i])\n\t  for (j=0; j < 2; j++)\n\t    test[i*4+j*2+1] = test[i*4+j*2] * (0x400 + ratio[i][j]) >> 10;\n      for (i=0; i < 8; i++)\n\ttotal[st][i] += test[i];\n      count[st]++;\nnext: ;\n    }\n  if (count[0] | count[1]) {\n    st = count[0]*200 < count[1];\n    for (i=0; i < 4; i++)\n      pre_mul[i] = 1.0 / (total[st][i] + total[st][i+4]);\n  }\n}\n\nvoid CLASS canon_600_coeff()\n{\n  static const short table[6][12] = {\n    { -190,702,-1878,2390,   1861,-1349,905,-393, -432,944,2617,-2105  },\n    { -1203,1715,-1136,1648, 1388,-876,267,245,  -1641,2153,3921,-3409 },\n    { -615,1127,-1563,2075,  1437,-925,509,3,     -756,1268,2519,-2007 },\n    { -190,702,-1886,2398,   2153,-1641,763,-251, -452,964,3040,-2528  },\n    { -190,702,-1878,2390,   1861,-1349,905,-393, -432,944,2617,-2105  },\n    { -807,1319,-1785,2297,  1388,-876,769,-257,  -230,742,2067,-1555  } };\n  int t=0, i, c;\n  float mc, yc;\n\n  mc = pre_mul[1] / pre_mul[2];\n  yc = pre_mul[3] / pre_mul[2];\n  if (mc > 1 && mc <= 1.28 && yc < 0.8789) t=1;\n  if (mc > 1.28 && mc <= 2) {\n    if  (yc < 0.8789) t=3;\n    else if (yc <= 2) t=4;\n  }\n  if (flash_used) t=5;\n  for (raw_color = i=0; i < 3; i++)\n    FORCC rgb_cam[i][c] = table[t][i*4 + c] / 1024.0;\n}\n\nvoid CLASS canon_600_load_raw()\n{\n  uchar  data[1120], *dp;\n  ushort *pix;\n  int irow, row;\n\n  for (irow=row=0; irow < height; irow++) {\n    if (fread (data, 1, 1120, ifp) < 1120) derror();\n    pix = raw_image + row*raw_width;\n    for (dp=data; dp < data+1120;  dp+=10, pix+=8) {\n      pix[0] = (dp[0] << 2) + (dp[1] >> 6    );\n      pix[1] = (dp[2] << 2) + (dp[1] >> 4 & 3);\n      pix[2] = (dp[3] << 2) + (dp[1] >> 2 & 3);\n      pix[3] = (dp[4] << 2) + (dp[1]      & 3);\n      pix[4] = (dp[5] << 2) + (dp[9]      & 3);\n      pix[5] = (dp[6] << 2) + (dp[9] >> 2 & 3);\n      pix[6] = (dp[7] << 2) + (dp[9] >> 4 & 3);\n      pix[7] = (dp[8] << 2) + (dp[9] >> 6    );\n    }\n    if ((row+=2) > height) row = 1;\n  }\n}\n\nvoid CLASS canon_600_correct()\n{\n  int row, col, val;\n  static const short mul[4][2] =\n  { { 1141,1145 }, { 1128,1109 }, { 1178,1149 }, { 1128,1109 } };\n\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++) {\n      if ((val = BAYER(row,col) - black) < 0) val = 0;\n      val = val * mul[row & 3][col & 1] >> 9;\n      BAYER(row,col) = val;\n    }\n  canon_600_fixed_wb(1311);\n  canon_600_auto_wb();\n  canon_600_coeff();\n  maximum = (0x3ff - black) * 1109 >> 9;\n  black = 0;\n}\n\nint CLASS canon_s2is()\n{\n  unsigned row;\n\n  for (row=0; row < 100; row++) {\n    fseek (ifp, row*3340 + 3284, SEEK_SET);\n    if (getc(ifp) > 15) return 1;\n  }\n  return 0;\n}\n\n/*\n   getbits(-1) initializes the buffer\n   getbits(n) where 0 <= n <= 25 returns an n-bit integer\n */\nunsigned CLASS getbithuff (int nbits, ushort *huff)\n{\n#ifdef LIBRAW_NOTHREADS\n  static unsigned bitbuf=0;\n  static int vbits=0, reset=0;\n#else\n#define bitbuf tls->getbits.bitbuf\n#define vbits  tls->getbits.vbits\n#define reset  tls->getbits.reset\n#endif\n  unsigned c;\n\n  if (nbits == -1)\n    return bitbuf = vbits = reset = 0;\n  if (nbits == 0 || vbits < 0) return 0;\n  while (!reset && vbits < nbits && (c = fgetc(ifp)) != EOF &&\n    !(reset = zero_after_ff && c == 0xff && fgetc(ifp))) {\n    bitbuf = (bitbuf << 8) + (uchar) c;\n    vbits += 8;\n  }\n  c = bitbuf << (32-vbits) >> (32-nbits);\n  if (huff) {\n    vbits -= huff[c] >> 8;\n    c = (uchar) huff[c];\n  } else\n    vbits -= nbits;\n  if (vbits < 0) derror();\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#undef reset\n#endif\n}\n\n#define getbits(n) getbithuff(n,0)\n#define gethuff(h) getbithuff(*h,h+1)\n\n/*\n   Construct a decode tree according the specification in *source.\n   The first 16 bytes specify how many codes should be 1-bit, 2-bit\n   3-bit, etc.  Bytes after that are the leaf values.\n\n   For example, if the source is\n\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,\n      0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },\n\n   then the code is\n\n\t00\t\t0x04\n\t010\t\t0x03\n\t011\t\t0x05\n\t100\t\t0x06\n\t101\t\t0x02\n\t1100\t\t0x07\n\t1101\t\t0x01\n\t11100\t\t0x08\n\t11101\t\t0x09\n\t11110\t\t0x00\n\t111110\t\t0x0a\n\t1111110\t\t0x0b\n\t1111111\t\t0xff\n */\nushort * CLASS make_decoder_ref (const uchar **source)\n{\n  int max, len, h, i, j;\n  const uchar *count;\n  ushort *huff;\n\n  count = (*source += 16) - 17;\n  for (max=16; max && !count[max]; max--);\n  huff = (ushort *) calloc (1 + (1 << max), sizeof *huff);\n  merror (huff, \"make_decoder()\");\n  huff[0] = max;\n  for (h=len=1; len <= max; len++)\n    for (i=0; i < count[len]; i++, ++*source)\n      for (j=0; j < 1 << (max-len); j++)\n\tif (h <= 1 << max)\n\t  huff[h++] = len << 8 | **source;\n  return huff;\n}\n\nushort * CLASS make_decoder (const uchar *source)\n{\n  return make_decoder_ref (&source);\n}\n\nvoid CLASS crw_init_tables (unsigned table, ushort *huff[2])\n{\n  static const uchar first_tree[3][29] = {\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,\n      0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },\n    { 0,2,2,3,1,1,1,1,2,0,0,0,0,0,0,0,\n      0x03,0x02,0x04,0x01,0x05,0x00,0x06,0x07,0x09,0x08,0x0a,0x0b,0xff  },\n    { 0,0,6,3,1,1,2,0,0,0,0,0,0,0,0,0,\n      0x06,0x05,0x07,0x04,0x08,0x03,0x09,0x02,0x00,0x0a,0x01,0x0b,0xff  },\n  };\n  static const uchar second_tree[3][180] = {\n    { 0,2,2,2,1,4,2,1,2,5,1,1,0,0,0,139,\n      0x03,0x04,0x02,0x05,0x01,0x06,0x07,0x08,\n      0x12,0x13,0x11,0x14,0x09,0x15,0x22,0x00,0x21,0x16,0x0a,0xf0,\n      0x23,0x17,0x24,0x31,0x32,0x18,0x19,0x33,0x25,0x41,0x34,0x42,\n      0x35,0x51,0x36,0x37,0x38,0x29,0x79,0x26,0x1a,0x39,0x56,0x57,\n      0x28,0x27,0x52,0x55,0x58,0x43,0x76,0x59,0x77,0x54,0x61,0xf9,\n      0x71,0x78,0x75,0x96,0x97,0x49,0xb7,0x53,0xd7,0x74,0xb6,0x98,\n      0x47,0x48,0x95,0x69,0x99,0x91,0xfa,0xb8,0x68,0xb5,0xb9,0xd6,\n      0xf7,0xd8,0x67,0x46,0x45,0x94,0x89,0xf8,0x81,0xd5,0xf6,0xb4,\n      0x88,0xb1,0x2a,0x44,0x72,0xd9,0x87,0x66,0xd4,0xf5,0x3a,0xa7,\n      0x73,0xa9,0xa8,0x86,0x62,0xc7,0x65,0xc8,0xc9,0xa1,0xf4,0xd1,\n      0xe9,0x5a,0x92,0x85,0xa6,0xe7,0x93,0xe8,0xc1,0xc6,0x7a,0x64,\n      0xe1,0x4a,0x6a,0xe6,0xb3,0xf1,0xd3,0xa5,0x8a,0xb2,0x9a,0xba,\n      0x84,0xa4,0x63,0xe5,0xc5,0xf3,0xd2,0xc4,0x82,0xaa,0xda,0xe4,\n      0xf2,0xca,0x83,0xa3,0xa2,0xc3,0xea,0xc2,0xe2,0xe3,0xff,0xff  },\n    { 0,2,2,1,4,1,4,1,3,3,1,0,0,0,0,140,\n      0x02,0x03,0x01,0x04,0x05,0x12,0x11,0x06,\n      0x13,0x07,0x08,0x14,0x22,0x09,0x21,0x00,0x23,0x15,0x31,0x32,\n      0x0a,0x16,0xf0,0x24,0x33,0x41,0x42,0x19,0x17,0x25,0x18,0x51,\n      0x34,0x43,0x52,0x29,0x35,0x61,0x39,0x71,0x62,0x36,0x53,0x26,\n      0x38,0x1a,0x37,0x81,0x27,0x91,0x79,0x55,0x45,0x28,0x72,0x59,\n      0xa1,0xb1,0x44,0x69,0x54,0x58,0xd1,0xfa,0x57,0xe1,0xf1,0xb9,\n      0x49,0x47,0x63,0x6a,0xf9,0x56,0x46,0xa8,0x2a,0x4a,0x78,0x99,\n      0x3a,0x75,0x74,0x86,0x65,0xc1,0x76,0xb6,0x96,0xd6,0x89,0x85,\n      0xc9,0xf5,0x95,0xb4,0xc7,0xf7,0x8a,0x97,0xb8,0x73,0xb7,0xd8,\n      0xd9,0x87,0xa7,0x7a,0x48,0x82,0x84,0xea,0xf4,0xa6,0xc5,0x5a,\n      0x94,0xa4,0xc6,0x92,0xc3,0x68,0xb5,0xc8,0xe4,0xe5,0xe6,0xe9,\n      0xa2,0xa3,0xe3,0xc2,0x66,0x67,0x93,0xaa,0xd4,0xd5,0xe7,0xf8,\n      0x88,0x9a,0xd7,0x77,0xc4,0x64,0xe2,0x98,0xa5,0xca,0xda,0xe8,\n      0xf3,0xf6,0xa9,0xb2,0xb3,0xf2,0xd2,0x83,0xba,0xd3,0xff,0xff  },\n    { 0,0,6,2,1,3,3,2,5,1,2,2,8,10,0,117,\n      0x04,0x05,0x03,0x06,0x02,0x07,0x01,0x08,\n      0x09,0x12,0x13,0x14,0x11,0x15,0x0a,0x16,0x17,0xf0,0x00,0x22,\n      0x21,0x18,0x23,0x19,0x24,0x32,0x31,0x25,0x33,0x38,0x37,0x34,\n      0x35,0x36,0x39,0x79,0x57,0x58,0x59,0x28,0x56,0x78,0x27,0x41,\n      0x29,0x77,0x26,0x42,0x76,0x99,0x1a,0x55,0x98,0x97,0xf9,0x48,\n      0x54,0x96,0x89,0x47,0xb7,0x49,0xfa,0x75,0x68,0xb6,0x67,0x69,\n      0xb9,0xb8,0xd8,0x52,0xd7,0x88,0xb5,0x74,0x51,0x46,0xd9,0xf8,\n      0x3a,0xd6,0x87,0x45,0x7a,0x95,0xd5,0xf6,0x86,0xb4,0xa9,0x94,\n      0x53,0x2a,0xa8,0x43,0xf5,0xf7,0xd4,0x66,0xa7,0x5a,0x44,0x8a,\n      0xc9,0xe8,0xc8,0xe7,0x9a,0x6a,0x73,0x4a,0x61,0xc7,0xf4,0xc6,\n      0x65,0xe9,0x72,0xe6,0x71,0x91,0x93,0xa6,0xda,0x92,0x85,0x62,\n      0xf3,0xc5,0xb2,0xa4,0x84,0xba,0x64,0xa5,0xb3,0xd2,0x81,0xe5,\n      0xd3,0xaa,0xc4,0xca,0xf2,0xb1,0xe4,0xd1,0x83,0x63,0xea,0xc3,\n      0xe2,0x82,0xf1,0xa3,0xc2,0xa1,0xc1,0xe3,0xa2,0xe1,0xff,0xff  }\n  };\n  if (table > 2) table = 2;\n  huff[0] = make_decoder ( first_tree[table]);\n  huff[1] = make_decoder (second_tree[table]);\n}\n\n/*\n   Return 0 if the image starts with compressed data,\n   1 if it starts with uncompressed low-order bits.\n\n   In Canon compressed data, 0xff is always followed by 0x00.\n */\nint CLASS canon_has_lowbits()\n{\n  uchar test[0x4000];\n  int ret=1, i;\n\n  fseek (ifp, 0, SEEK_SET);\n  fread (test, 1, sizeof test, ifp);\n  for (i=540; i < sizeof test - 1; i++)\n    if (test[i] == 0xff) {\n      if (test[i+1]) return 1;\n      ret=0;\n    }\n  return ret;\n}\n\nvoid CLASS canon_load_raw()\n{\n  ushort *pixel, *prow, *huff[2];\n  int nblocks, lowbits, i, c, row, r, save, val;\n  int block, diffbuf[64], leaf, len, diff, carry=0, pnum=0, base[2];\n\n  crw_init_tables (tiff_compress, huff);\n  lowbits = canon_has_lowbits();\n  if (!lowbits) maximum = 0x3ff;\n  fseek (ifp, 540 + lowbits*raw_height*raw_width/4, SEEK_SET);\n  zero_after_ff = 1;\n  getbits(-1);\n  for (row=0; row < raw_height; row+=8) {\n    pixel = raw_image + row*raw_width;\n    nblocks = MIN (8, raw_height-row) * raw_width >> 6;\n    for (block=0; block < nblocks; block++) {\n      memset (diffbuf, 0, sizeof diffbuf);\n      for (i=0; i < 64; i++ ) {\n\tleaf = gethuff(huff[i > 0]);\n\tif (leaf == 0 && i) break;\n\tif (leaf == 0xff) continue;\n\ti  += leaf >> 4;\n\tlen = leaf & 15;\n\tif (len == 0) continue;\n\tdiff = getbits(len);\n\tif ((diff & (1 << (len-1))) == 0)\n\t  diff -= (1 << len) - 1;\n\tif (i < 64) diffbuf[i] = diff;\n      }\n      diffbuf[0] += carry;\n      carry = diffbuf[0];\n      for (i=0; i < 64; i++ ) {\n\tif (pnum++ % raw_width == 0)\n\t  base[0] = base[1] = 512;\n\tif ((pixel[(block << 6) + i] = base[i & 1] += diffbuf[i]) >> 10)\n\t  derror();\n      }\n    }\n    if (lowbits) {\n      save = ftell(ifp);\n      fseek (ifp, 26 + row*raw_width/4, SEEK_SET);\n      for (prow=pixel, i=0; i < raw_width*2; i++) {\n\tc = fgetc(ifp);\n\tfor (r=0; r < 8; r+=2, prow++) {\n\t  val = (*prow << 2) + ((c >> r) & 3);\n\t  if (raw_width == 2672 && val < 512) val += 2;\n\t  *prow = val;\n\t}\n      }\n      fseek (ifp, save, SEEK_SET);\n    }\n  }\n  FORC(2) free (huff[c]);\n}\n#line 819 \"dcraw/dcraw.c\"\nint CLASS ljpeg_start (struct jhead *jh, int info_only)\n{\n  int c, tag, len;\n  uchar data[0x10000];\n  const uchar *dp;\n\n  memset (jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  fread (data, 2, 1, ifp);\n  if (data[1] != 0xd8) return 0;\n  do {\n    fread (data, 2, 2, ifp);\n    tag =  data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00) return 0;\n    fread (data, 1, len, ifp);\n    switch (tag) {\n      case 0xffc3:\n\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n      case 0xffc0:\n\tjh->bits = data[0];\n\tjh->high = data[1] << 8 | data[2];\n\tjh->wide = data[3] << 8 | data[4];\n\tjh->clrs = data[5] + jh->sraw;\n\tif (len == 9 && !dng_version) getc(ifp);\n\tbreak;\n      case 0xffc4:\n\tif (info_only) break;\n\tfor (dp = data; dp < data+len && (c = *dp++) < 4; )\n\t  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);\n\tbreak;\n      case 0xffda:\n\tjh->psv = data[1+data[0]*2];\n\tjh->bits -= data[3+data[0]*2] & 15;\n\tbreak;\n      case 0xffdd:\n\tjh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (info_only) return 1;\n  FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];\n  if (jh->sraw) {\n    FORC(4)        jh->huff[2+c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\n  }\n  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\n  merror (jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}\n\nvoid CLASS ljpeg_end (struct jhead *jh)\n{\n  int c;\n  FORC4 if (jh->free[c]) free (jh->free[c]);\n  free (jh->row);\n}\n\nint CLASS ljpeg_diff (ushort *huff)\n{\n  int len, diff;\n\n  len = gethuff(huff);\n  if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n    return -32768;\n  diff = getbits(len);\n  if ((diff & (1 << (len-1))) == 0)\n    diff -= (1 << len) - 1;\n  return diff;\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\nint CLASS ljpeg_diff_new (LibRaw_bit_buffer& bits, LibRaw_byte_buffer* buf,ushort *huff)\n{\n  int len, diff;\n\n  len = bits._gethuff_lj(buf,*huff,huff+1);\n  if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n    return -32768;\n  diff = bits._getbits_lj(buf,len);\n  if ((diff & (1 << (len-1))) == 0)\n    diff -= (1 << len) - 1;\n  return diff;\n}\n\nushort * CLASS ljpeg_row_new (int jrow, struct jhead *jh, LibRaw_bit_buffer& bits,LibRaw_byte_buffer* bytes)\n{\n  int col, c, diff, pred, spred=0;\n  ushort mark=0, *row[3];\n\n  if (jrow * jh->wide % jh->restart == 0) {\n    FORC(6) jh->vpred[c] = 1 << (jh->bits-1);\n    if (jrow) {\n        bytes->unseek2();\n        do mark = (mark << 8) + (c = bytes->get_byte());\n        while (c != EOF && mark >> 4 != 0xffd);\n    }\n    bits.reset();\n  }\n  FORC3 row[c] = jh->row + jh->wide*jh->clrs*((jrow+c) & 1);\n  for (col=0; col < jh->wide; col++)\n    FORC(jh->clrs) {\n        diff = ljpeg_diff_new (bits,bytes,jh->huff[c]);\n      if (jh->sraw && c <= jh->sraw && (col | c))\n\t\t    pred = spred;\n      else if (col) pred = row[0][-jh->clrs];\n      else\t    pred = (jh->vpred[c] += diff) - diff;\n      if (jrow && col) switch (jh->psv) {\n\tcase 1:\tbreak;\n\tcase 2: pred = row[1][0];\t\t\t\t\tbreak;\n\tcase 3: pred = row[1][-jh->clrs];\t\t\t\tbreak;\n\tcase 4: pred = pred +   row[1][0] - row[1][-jh->clrs];\t\tbreak;\n\tcase 5: pred = pred + ((row[1][0] - row[1][-jh->clrs]) >> 1);\tbreak;\n\tcase 6: pred = row[1][0] + ((pred - row[1][-jh->clrs]) >> 1);\tbreak;\n\tcase 7: pred = (pred + row[1][0]) >> 1;\t\t\t\tbreak;\n\tdefault: pred = 0;\n      }\n      if ((**row = pred + diff) >> jh->bits) derror();\n      if (c <= jh->sraw) spred = **row;\n      row[0]++; row[1]++;\n    }\n  return row[2];\n}\n\n#endif\n\n\nushort * CLASS ljpeg_row (int jrow, struct jhead *jh)\n{\n  int col, c, diff, pred, spred=0;\n  ushort mark=0, *row[3];\n\n  if (jrow * jh->wide % jh->restart == 0) {\n    FORC(6) jh->vpred[c] = 1 << (jh->bits-1);\n    if (jrow) {\n      fseek (ifp, -2, SEEK_CUR);\n      do mark = (mark << 8) + (c = fgetc(ifp));\n      while (c != EOF && mark >> 4 != 0xffd);\n    }\n    getbits(-1);\n  }\n  FORC3 row[c] = jh->row + jh->wide*jh->clrs*((jrow+c) & 1);\n  for (col=0; col < jh->wide; col++)\n    FORC(jh->clrs) {\n      diff = ljpeg_diff (jh->huff[c]);\n      if (jh->sraw && c <= jh->sraw && (col | c))\n\t\t    pred = spred;\n      else if (col) pred = row[0][-jh->clrs];\n      else\t    pred = (jh->vpred[c] += diff) - diff;\n      if (jrow && col) switch (jh->psv) {\n\tcase 1:\tbreak;\n\tcase 2: pred = row[1][0];\t\t\t\t\tbreak;\n\tcase 3: pred = row[1][-jh->clrs];\t\t\t\tbreak;\n\tcase 4: pred = pred +   row[1][0] - row[1][-jh->clrs];\t\tbreak;\n\tcase 5: pred = pred + ((row[1][0] - row[1][-jh->clrs]) >> 1);\tbreak;\n\tcase 6: pred = row[1][0] + ((pred - row[1][-jh->clrs]) >> 1);\tbreak;\n\tcase 7: pred = (pred + row[1][0]) >> 1;\t\t\t\tbreak;\n\tdefault: pred = 0;\n      }\n      if ((**row = pred + diff) >> jh->bits) derror();\n      if (c <= jh->sraw) spred = **row;\n      row[0]++; row[1]++;\n    }\n  return row[2];\n}\n\nvoid CLASS lossless_jpeg_load_raw()\n{\n  int jwide, jrow, jcol, val, i, row=0, col=0;\n#ifndef LIBRAW_LIBRARY_BUILD\n  int jidx,j;\n#endif\n  struct jhead jh;\n  ushort *rp;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  int save_min = 0;\n  unsigned slicesW[16],slicesWcnt=0,slices;\n  unsigned *offset;\n  unsigned t_y=0,t_x=0,t_s=0,slice=0,pixelsInSlice,pixno;\n  if (!strcasecmp(make,\"KODAK\"))\n      save_min = 1;\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (cr2_slice[0]>15)\n      throw LIBRAW_EXCEPTION_IO_EOF; // change many slices\n#else\n  if (cr2_slice[0]>15)\n  {\n      fprintf(stderr,\"Too many CR2 slices: %d\\n\",cr2_slice[0]+1);\n      return;\n  }\n#endif\n\n\n  if (!ljpeg_start (&jh, 0)) return;\n  jwide = jh.wide * jh.clrs;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(cr2_slice[0])\n      {\n          for(i=0;i<cr2_slice[0];i++)\n              slicesW[slicesWcnt++] = cr2_slice[1];\n          slicesW[slicesWcnt++] = cr2_slice[2];\n      }\n  else\n      {\n          // not sliced\n          slicesW[slicesWcnt++] = raw_width; // safe fallback\n      }\n       \n  slices = slicesWcnt * jh.high;\n  offset = (unsigned*)calloc(slices+1,sizeof(offset[0]));\n\n  for(slice=0;slice<slices;slice++)\n      {\n          offset[slice] = (t_x + t_y * raw_width)| (t_s<<28);\n          if((offset[slice] & 0x0fffffff) >= raw_width * raw_height)\n              throw LIBRAW_EXCEPTION_IO_BADFILE; \n          t_y++;\n          if(t_y == jh.high)\n              {\n                  t_y = 0;\n                  t_x += slicesW[t_s++];\n              }\n      }\n  offset[slices] = offset[slices-1];\n  slice = 1; // next slice\n  pixno = offset[0]; \n  pixelsInSlice = slicesW[0];\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  LibRaw_byte_buffer *buf=NULL;\n  if(data_size)\n      buf = ifp->make_byte_buffer(data_size);\n  LibRaw_bit_buffer bits;\n#endif\n\n  for (jrow=0; jrow < jh.high; jrow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (buf)\n          rp = ljpeg_row_new (jrow, &jh,bits,buf);\n      else\n#endif\n    rp = ljpeg_row (jrow, &jh);\n    if (load_flags & 1)\n      row = jrow & 1 ? height-1-jrow/2 : jrow/2;\n    for (jcol=0; jcol < jwide; jcol++) {\n      val = curve[*rp++];\n#ifndef LIBRAW_LIBRARY_BUILD\n      // slow dcraw way to calculate row/col\n      if (cr2_slice[0]) {\n\tjidx = jrow*jwide + jcol;\n\ti = jidx / (cr2_slice[1]*jh.high);\n\tif ((j = i >= cr2_slice[0]))\n\t\t i  = cr2_slice[0];\n\tjidx -= i * (cr2_slice[1]*jh.high);\n\trow = jidx / cr2_slice[1+j];\n\tcol = jidx % cr2_slice[1+j] + i*cr2_slice[1];\n      }\n#else\n      // new fast one, but for data_size defined only (i.e. new CR2 format, not 1D/1Ds)\n      if(buf) \n          {\n              if(!(load_flags & 1))\n                  row = pixno/raw_width;\n              col = pixno % raw_width;\n              pixno++;\n              if (0 == --pixelsInSlice)\n                  {\n                      unsigned o = offset[slice++];\n                      pixno = o & 0x0fffffff;\n                      pixelsInSlice = slicesW[o>>28];\n                  }\n          }\n#endif\n      if (raw_width == 3984 && (col -= 2) < 0)\n\tcol += (row--,raw_width);\n      if (row >= 0) RAW(row,col) = val;\n#ifndef LIBRAW_LIBRARY_BUILD\n      if (++col >= raw_width)\n\tcol = (row++,0);\n#else\n      if(!buf) // 1D or 1Ds case\n         if (++col >= raw_width)\n            col = (row++,0);\n#endif\n    }\n  }\n  ljpeg_end (&jh);\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(buf)\n      delete buf;\n  free(offset);\n#endif\n}\n\nvoid CLASS canon_sraw_load_raw()\n{\n  struct jhead jh;\n  short *rp=0, (*ip)[4];\n  int jwide, slice, scol, ecol, row, col, jrow=0, jcol=0, pix[3], c;\n  int v[3]={0,0,0}, ver, hue;\n  char *cp;\n\n  if (!ljpeg_start (&jh, 0)) return;\n  jwide = (jh.wide >>= 1) * jh.clrs;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!data_size)\n      throw LIBRAW_EXCEPTION_IO_BADFILE;\n  LibRaw_byte_buffer *buf = ifp->make_byte_buffer(data_size);\n  LibRaw_bit_buffer bits;\n#endif\n\n  for (ecol=slice=0; slice <= cr2_slice[0]; slice++) {\n    scol = ecol;\n    ecol += cr2_slice[1] * 2 / jh.clrs;\n    if (!cr2_slice[0] || ecol > raw_width-1) ecol = raw_width & -2;\n    for (row=0; row < height; row += (jh.clrs >> 1) - 1) {\n      ip = (short (*)[4]) image + row*width;\n      for (col=scol; col < ecol; col+=2, jcol+=jh.clrs) {\n\tif ((jcol %= jwide) == 0)\n#ifdef LIBRAW_LIBRARY_BUILD\n            rp = (short*) ljpeg_row_new (jrow++, &jh,bits,buf);\n#else\n            rp = (short *) ljpeg_row (jrow++, &jh);\n#endif\n\tif (col >= width) continue;\n\tFORC (jh.clrs-2)\n\t  ip[col + (c >> 1)*width + (c & 1)][0] = rp[jcol+c];\n\tip[col][1] = rp[jcol+jh.clrs-2] - 16384;\n\tip[col][2] = rp[jcol+jh.clrs-1] - 16384;\n      }\n    }\n  }\n  for (cp=model2; *cp && !isdigit(*cp); cp++);\n  sscanf (cp, \"%d.%d.%d\", v, v+1, v+2);\n  ver = (v[0]*1000 + v[1])*1000 + v[2];\n  hue = (jh.sraw+1) << 2;\n  if (unique_id >= 0x80000281 || (unique_id == 0x80000218 && ver > 1000006))\n    hue = jh.sraw << 1;\n  ip = (short (*)[4]) image;\n  rp = ip[0];\n  for (row=0; row < height; row++, ip+=width) {\n    if (row & (jh.sraw >> 1))\n      for (col=0; col < width; col+=2)\n\tfor (c=1; c < 3; c++)\n\t  if (row == height-1)\n\t       ip[col][c] =  ip[col-width][c];\n\t  else ip[col][c] = (ip[col-width][c] + ip[col+width][c] + 1) >> 1;\n    for (col=1; col < width; col+=2)\n      for (c=1; c < 3; c++)\n\tif (col == width-1)\n\t     ip[col][c] =  ip[col-1][c];\n\telse ip[col][c] = (ip[col-1][c] + ip[col+1][c] + 1) >> 1;\n  }\n  for ( ; rp < ip[0]; rp+=4) {\n    if (unique_id == 0x80000218 ||\n\tunique_id == 0x80000250 ||\n\tunique_id == 0x80000261 ||\n\tunique_id == 0x80000281 ||\n\tunique_id == 0x80000287) {\n      rp[1] = (rp[1] << 2) + hue;\n      rp[2] = (rp[2] << 2) + hue;\n      pix[0] = rp[0] + ((   50*rp[1] + 22929*rp[2]) >> 14);\n      pix[1] = rp[0] + ((-5640*rp[1] - 11751*rp[2]) >> 14);\n      pix[2] = rp[0] + ((29040*rp[1] -   101*rp[2]) >> 14);\n    } else {\n      if (unique_id < 0x80000218) rp[0] -= 512;\n      pix[0] = rp[0] + rp[2];\n      pix[2] = rp[0] + rp[1];\n      pix[1] = rp[0] + ((-778*rp[1] - (rp[2] << 11)) >> 12);\n    }\n    FORC3 rp[c] = CLIP(pix[c] * sraw_mul[c] >> 10);\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  delete buf;\n#endif\n  ljpeg_end (&jh);\n  maximum = 0x3fff;\n}\n\n#ifndef LIBRAW_LIBRARY_BUILD\nvoid CLASS adobe_copy_pixel (unsigned row, unsigned col, ushort **rp)\n{\n  int c;\n\n  if (is_raw == 2 && shot_select) (*rp)++;\n  if (raw_image) {\n    if (row < raw_height && col < raw_width)\n      RAW(row,col) = curve[**rp];\n    *rp += is_raw;\n  } else {\n    if (row < height && col < width)\n      FORC(tiff_samples)\n\timage[row*width+col][c] = curve[(*rp)[c]];\n    *rp += tiff_samples;\n  }\n  if (is_raw == 2 && shot_select) (*rp)--;\n}\n#else\nvoid CLASS adobe_copy_pixel_raw (unsigned row, unsigned col, ushort **rp)\n{\n  if (is_raw == 2 && shot_select) (*rp)++;\n  if (row < raw_height && col < raw_width)\n    RAW(row,col) = curve[**rp];\n  *rp += is_raw;\n  if (is_raw == 2 && shot_select) (*rp)--;\n}\nvoid CLASS adobe_copy_pixel_color (unsigned row, unsigned col, ushort **rp)\n{\n  int c;\n\n  if (is_raw == 2 && shot_select) (*rp)++;\n  if (row < height && col < width)\n    FORC(tiff_samples)\n      image[row*width+col][c] = curve[(*rp)[c]];\n  *rp += tiff_samples;\n  if (is_raw == 2 && shot_select) (*rp)--;\n}\n#endif\n\n\nvoid CLASS lossless_dng_load_raw()\n{\n  unsigned save, trow=0, tcol=0, jwide, jrow, jcol, row, col;\n  struct jhead jh;\n  ushort *rp;\n\n  while (trow < raw_height) {\n    save = ftell(ifp);\n    if (tile_length < INT_MAX)\n      fseek (ifp, get4(), SEEK_SET);\n    if (!ljpeg_start (&jh, 0)) break;\n    jwide = jh.wide;\n    if (filters) jwide *= jh.clrs;\n    jwide /= is_raw;\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(!data_size)\n        throw LIBRAW_EXCEPTION_IO_BADFILE;\n    LibRaw_byte_buffer *buf = ifp->make_byte_buffer(data_size);\n    LibRaw_bit_buffer bits;\n#endif\n\n#ifndef LIBRAW_LIBRARY_BUILD\n    for (row=col=jrow=0; jrow < jh.high; jrow++) {\n      rp = ljpeg_row (jrow, &jh);\n      for (jcol=0; jcol < jwide; jcol++) {\n\tadobe_copy_pixel (trow+row, tcol+col, &rp);\n\tif (++col >= tile_width || col >= raw_width)\n\t  row += 1 + (col = 0);\n      }\n    }\n#else\n    if(raw_image)\n      {\n        for (row=col=jrow=0; jrow < jh.high; jrow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n          rp = ljpeg_row_new (jrow, &jh,bits,buf);\n#else\n          rp = ljpeg_row (jrow, &jh);\n#endif\n          for (jcol=0; jcol < jwide; jcol++) {\n            adobe_copy_pixel_raw (trow+row, tcol+col, &rp);\n            if (++col >= tile_width || col >= raw_width)\n              row += 1 + (col = 0);\n          }\n        }\n      }\n    else\n      {\n        for (row=col=jrow=0; jrow < jh.high; jrow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n          rp = ljpeg_row_new (jrow, &jh,bits,buf);\n#else\n          rp = ljpeg_row (jrow, &jh);\n#endif\n          for (jcol=0; jcol < jwide; jcol++) {\n            adobe_copy_pixel_color (trow+row, tcol+col, &rp);\n            if (++col >= tile_width || col >= raw_width)\n              row += 1 + (col = 0);\n          }\n        }\n      }\n#endif\n    fseek (ifp, save+4, SEEK_SET);\n    if ((tcol += tile_width) >= raw_width)\n      trow += tile_length + (tcol = 0);\n    ljpeg_end (&jh);\n#ifdef LIBRAW_LIBRARY_BUILD\n    delete buf;\n#endif\n  }\n}\n\nvoid CLASS packed_dng_load_raw()\n{\n  ushort *pixel, *rp;\n  int row, col;\n\n  pixel = (ushort *) calloc (raw_width * tiff_samples, sizeof *pixel);\n  merror (pixel, \"packed_dng_load_raw()\");\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  int dsz= raw_height*raw_width * tiff_samples * tiff_bps/8;\n  LibRaw_byte_buffer *buf = NULL;\n  if (tiff_bps != 16)\n      {\n          buf = ifp->make_byte_buffer(dsz);\n      }\n  LibRaw_bit_buffer bits;\n#endif\n\n  for (row=0; row < raw_height; row++) {\n    if (tiff_bps == 16)\n      read_shorts (pixel, raw_width * tiff_samples);\n    else {\n#ifdef LIBRAW_LIBRARY_BUILD\n        bits.reset();\n        for (col=0; col < raw_width * tiff_samples; col++)\n            pixel[col] = bits._getbits(buf,tiff_bps,zero_after_ff);\n\n#else\n      getbits(-1);\n      for (col=0; col < raw_width * tiff_samples; col++)\n\tpixel[col] = getbits(tiff_bps);\n#endif\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n    for (rp=pixel, col=0; col < raw_width; col++)\n      adobe_copy_pixel (row, col, &rp);\n#else\n    if(raw_image)\n      for (rp=pixel, col=0; col < raw_width; col++)\n        adobe_copy_pixel_raw (row, col, &rp);\n    else\n      for (rp=pixel, col=0; col < raw_width; col++)\n        adobe_copy_pixel_color (row, col, &rp);\n#endif\n  }\n  free (pixel);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(buf)\n        delete buf;\n#endif\n}\n\nvoid CLASS pentax_load_raw()\n{\n  ushort bit[2][15], huff[4097];\n  int dep, row, col, diff, c, i;\n  ushort vpred[2][2] = {{0,0},{0,0}}, hpred[2];\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  dep = (get2() + 12) & 15;\n  fseek (ifp, 12, SEEK_CUR);\n  FORC(dep) bit[0][c] = get2();\n  FORC(dep) bit[1][c] = fgetc(ifp);\n  FORC(dep)\n    for (i=bit[0][c]; i <= ((bit[0][c]+(4096 >> bit[1][c])-1) & 4095); )\n      huff[++i] = bit[1][c] << 8 | c;\n  huff[0] = 12;\n  fseek (ifp, data_offset, SEEK_SET);\n  getbits(-1);\n  for (row=0; row < raw_height; row++)\n    for (col=0; col < raw_width; col++) {\n      diff = ljpeg_diff (huff);\n      if (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n      else\t   hpred[col & 1] += diff;\n      RAW(row,col) = hpred[col & 1];\n      if (hpred[col & 1] >> tiff_bps) derror();\n    }\n}\n\nvoid CLASS nikon_load_raw()\n{\n  static const uchar nikon_tree[][32] = {\n    { 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,\t/* 12-bit lossy */\n      5,4,3,6,2,7,1,0,8,9,11,10,12 },\n    { 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,\t/* 12-bit lossy after split */\n      0x39,0x5a,0x38,0x27,0x16,5,4,3,2,1,0,11,12,12 },\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,  /* 12-bit lossless */\n      5,4,6,3,7,2,8,1,9,0,10,11,12 },\n    { 0,1,4,3,1,1,1,1,1,2,0,0,0,0,0,0,\t/* 14-bit lossy */\n      5,6,4,7,8,3,9,2,1,0,10,11,12,13,14 },\n    { 0,1,5,1,1,1,1,1,1,1,2,0,0,0,0,0,\t/* 14-bit lossy after split */\n      8,0x5c,0x4b,0x3a,0x29,7,6,5,4,3,2,1,0,13,14 },\n    { 0,1,4,2,2,3,1,2,0,0,0,0,0,0,0,0,\t/* 14-bit lossless */\n      7,6,8,5,9,4,10,3,11,12,2,0,1,13,14 } };\n  ushort *huff, ver0, ver1, vpred[2][2], hpred[2], csize;\n  int i, min, max, step=0, tree=0, split=0, row, col, len, shl, diff;\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  ver0 = fgetc(ifp);\n  ver1 = fgetc(ifp);\n  if (ver0 == 0x49 || ver1 == 0x58)\n    fseek (ifp, 2110, SEEK_CUR);\n  if (ver0 == 0x46) tree = 2;\n  if (tiff_bps == 14) tree += 3;\n  read_shorts (vpred[0], 4);\n  max = 1 << tiff_bps & 0x7fff;\n  if ((csize = get2()) > 1)\n    step = max / (csize-1);\n  if (ver0 == 0x44 && ver1 == 0x20 && step > 0) {\n    for (i=0; i < csize; i++)\n      curve[i*step] = get2();\n    for (i=0; i < max; i++)\n      curve[i] = ( curve[i-i%step]*(step-i%step) +\n\t\t   curve[i-i%step+step]*(i%step) ) / step;\n    fseek (ifp, meta_offset+562, SEEK_SET);\n    split = get2();\n  } else if (ver0 != 0x46 && csize <= 0x4001)\n    read_shorts (curve, max=csize);\n  while (curve[max-2] == curve[max-1]) max--;\n  huff = make_decoder (nikon_tree[tree]);\n  fseek (ifp, data_offset, SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!data_size)\n      throw LIBRAW_EXCEPTION_IO_BADFILE;\n  LibRaw_byte_buffer *buf = ifp->make_byte_buffer(data_size);\n  LibRaw_bit_buffer bits;\n  bits.reset();\n#else\n  getbits(-1);\n#endif\n  for (min=row=0; row < height; row++) {\n    if (split && row == split) {\n      free (huff);\n      huff = make_decoder (nikon_tree[tree+1]);\n      max += (min = 16) << 1;\n    }\n    for (col=0; col < raw_width; col++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n        i = bits._gethuff(buf,*huff,huff+1,zero_after_ff);\n#else\n      i = gethuff(huff);\n#endif\n      len = i & 15;\n      shl = i >> 4;\n#ifdef LIBRAW_LIBRARY_BUILD\n      diff = ((bits._getbits(buf,len-shl,zero_after_ff) << 1) + 1) << shl >> 1;\n#else\n      diff = ((getbits(len-shl) << 1) + 1) << shl >> 1;\n#endif\n      if ((diff & (1 << (len-1))) == 0)\n\tdiff -= (1 << len) - !shl;\n      if (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n      else\t   hpred[col & 1] += diff;\n      if ((ushort)(hpred[col & 1] + min) >= max) derror();\n      RAW(row,col) = curve[LIM((short)hpred[col & 1],0,0x3fff)];\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  delete buf;\n#endif\n  free (huff);\n}\n\n/*\n   Returns 1 for a Coolpix 995, 0 for anything else.\n */\nint CLASS nikon_e995()\n{\n  int i, histo[256];\n  const uchar often[] = { 0x00, 0x55, 0xaa, 0xff };\n\n  memset (histo, 0, sizeof histo);\n  fseek (ifp, -2000, SEEK_END);\n  for (i=0; i < 2000; i++)\n    histo[fgetc(ifp)]++;\n  for (i=0; i < 4; i++)\n    if (histo[often[i]] < 200)\n      return 0;\n  return 1;\n}\n\n/*\n   Returns 1 for a Coolpix 2100, 0 for anything else.\n */\nint CLASS nikon_e2100()\n{\n  uchar t[12];\n  int i;\n\n  fseek (ifp, 0, SEEK_SET);\n  for (i=0; i < 1024; i++) {\n    fread (t, 1, 12, ifp);\n    if (((t[2] & t[4] & t[7] & t[9]) >> 4\n\t& t[1] & t[6] & t[8] & t[11] & 3) != 3)\n      return 0;\n  }\n  return 1;\n}\n\nvoid CLASS nikon_3700()\n{\n  int bits, i;\n  uchar dp[24];\n  static const struct {\n    int bits;\n    char t_make[12], t_model[15];\n  } table[] = {\n    { 0x00, \"PENTAX\",  \"Optio 33WR\" },\n    { 0x03, \"NIKON\",   \"E3200\" },\n    { 0x32, \"NIKON\",   \"E3700\" },\n    { 0x33, \"OLYMPUS\", \"C740UZ\" } };\n\n  fseek (ifp, 3072, SEEK_SET);\n  fread (dp, 1, 24, ifp);\n  bits = (dp[8] & 3) << 4 | (dp[20] & 3);\n  for (i=0; i < sizeof table / sizeof *table; i++)\n    if (bits == table[i].bits) {\n      strcpy (make,  table[i].t_make );\n      strcpy (model, table[i].t_model);\n    }\n}\n\n/*\n   Separates a Minolta DiMAGE Z2 from a Nikon E4300.\n */\nint CLASS minolta_z2()\n{\n  int i, nz;\n  char tail[424];\n\n  fseek (ifp, -sizeof tail, SEEK_END);\n  fread (tail, 1, sizeof tail, ifp);\n  for (nz=i=0; i < sizeof tail; i++)\n    if (tail[i]) nz++;\n  return nz > 20;\n}\n#line 1557 \"dcraw/dcraw.c\"\nvoid CLASS ppm_thumb()\n{\n  char *thumb;\n  thumb_length = thumb_width*thumb_height*3;\n  thumb = (char *) malloc (thumb_length);\n  merror (thumb, \"ppm_thumb()\");\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  fread  (thumb, 1, thumb_length, ifp);\n  fwrite (thumb, 1, thumb_length, ofp);\n  free (thumb);\n}\n\nvoid CLASS ppm16_thumb()\n{\n  int i;\n  char *thumb;\n  thumb_length = thumb_width*thumb_height*3;\n  thumb = (char *) calloc (thumb_length,2);\n  merror (thumb, \"ppm16_thumb()\");\n  read_shorts ((ushort *) thumb, thumb_length);\n  for (i=0; i < thumb_length; i++)\n    thumb[i] = ((ushort *) thumb)[i] >> 8;\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  fwrite (thumb, 1, thumb_length, ofp);\n  free (thumb);\n}\n\nvoid CLASS layer_thumb()\n{\n  int i, c;\n  char *thumb, map[][4] = { \"012\",\"102\" };\n\n  colors = thumb_misc >> 5 & 7;\n  thumb_length = thumb_width*thumb_height;\n  thumb = (char *) calloc (colors, thumb_length);\n  merror (thumb, \"layer_thumb()\");\n  fprintf (ofp, \"P%d\\n%d %d\\n255\\n\",\n\t5 + (colors >> 1), thumb_width, thumb_height);\n  fread (thumb, thumb_length, colors, ifp);\n  for (i=0; i < thumb_length; i++)\n    FORCC putc (thumb[i+thumb_length*(map[thumb_misc >> 8][c]-'0')], ofp);\n  free (thumb);\n}\n\nvoid CLASS rollei_thumb()\n{\n  unsigned i;\n  ushort *thumb;\n\n  thumb_length = thumb_width * thumb_height;\n  thumb = (ushort *) calloc (thumb_length, 2);\n  merror (thumb, \"rollei_thumb()\");\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  read_shorts (thumb, thumb_length);\n  for (i=0; i < thumb_length; i++) {\n    putc (thumb[i] << 3, ofp);\n    putc (thumb[i] >> 5  << 2, ofp);\n    putc (thumb[i] >> 11 << 3, ofp);\n  }\n  free (thumb);\n}\n\nvoid CLASS rollei_load_raw()\n{\n  uchar pixel[10];\n  unsigned iten=0, isix, i, buffer=0, todo[16];\n\n  isix = raw_width * raw_height * 5 / 8;\n  while (fread (pixel, 1, 10, ifp) == 10) {\n    for (i=0; i < 10; i+=2) {\n      todo[i]   = iten++;\n      todo[i+1] = pixel[i] << 8 | pixel[i+1];\n      buffer    = pixel[i] >> 2 | buffer << 6;\n    }\n    for (   ; i < 16; i+=2) {\n      todo[i]   = isix++;\n      todo[i+1] = buffer >> (14-i)*5;\n    }\n    for (i=0; i < 16; i+=2)\n      raw_image[todo[i]] = (todo[i+1] & 0x3ff);\n  }\n  maximum = 0x3ff;\n}\n\nint CLASS raw (unsigned row, unsigned col)\n{\n  return (row < raw_height && col < raw_width) ? RAW(row,col) : 0;\n}\n\nvoid CLASS phase_one_flat_field (int is_float, int nc)\n{\n  ushort head[8];\n  unsigned wide, y, x, c, rend, cend, row, col;\n  float *mrow, num, mult[4];\n\n  read_shorts (head, 8);\n  wide = head[2] / head[4];\n  mrow = (float *) calloc (nc*wide, sizeof *mrow);\n  merror (mrow, \"phase_one_flat_field()\");\n  for (y=0; y < head[3] / head[5]; y++) {\n    for (x=0; x < wide; x++)\n      for (c=0; c < nc; c+=2) {\n\tnum = is_float ? getreal(11) : get2()/32768.0;\n\tif (y==0) mrow[c*wide+x] = num;\n\telse mrow[(c+1)*wide+x] = (num - mrow[c*wide+x]) / head[5];\n      }\n    if (y==0) continue;\n    rend = head[1] + y*head[5];\n    for (row = rend-head[5]; row < raw_height && row < rend; row++) {\n      for (x=1; x < wide; x++) {\n\tfor (c=0; c < nc; c+=2) {\n\t  mult[c] = mrow[c*wide+x-1];\n\t  mult[c+1] = (mrow[c*wide+x] - mult[c]) / head[4];\n\t}\n\tcend = head[0] + x*head[4];\n\tfor (col = cend-head[4]; col < raw_width && col < cend; col++) {\n\t  c = nc > 2 ? FC(row-top_margin,col-left_margin) : 0;\n\t  if (!(c & 1)) {\n\t    c = RAW(row,col) * mult[c];\n\t    RAW(row,col) = LIM(c,0,65535);\n\t  }\n\t  for (c=0; c < nc; c+=2)\n\t    mult[c] += mult[c+1];\n\t}\n      }\n      for (x=0; x < wide; x++)\n\tfor (c=0; c < nc; c+=2)\n\t  mrow[c*wide+x] += mrow[(c+1)*wide+x];\n    }\n  }\n  free (mrow);\n}\n\nvoid CLASS phase_one_correct()\n{\n  unsigned entries, tag, data, save, col, row, type;\n  int len, i, j, k, cip, val[4], dev[4], sum, max;\n  int head[9], diff, mindiff=INT_MAX, off_412=0;\n  static const signed char dir[12][2] =\n    { {-1,-1}, {-1,1}, {1,-1}, {1,1}, {-2,0}, {0,-2}, {0,2}, {2,0},\n      {-2,-2}, {-2,2}, {2,-2}, {2,2} };\n  float poly[8], num, cfrac, frac, mult[2], *yval[2];\n  ushort *xval[2];\n\n  if (half_size || !meta_length) return;\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Phase One correction...\\n\"));\n#endif\n  fseek (ifp, meta_offset, SEEK_SET);\n  order = get2();\n  fseek (ifp, 6, SEEK_CUR);\n  fseek (ifp, meta_offset+get4(), SEEK_SET);\n  entries = get4();  get4();\n  while (entries--) {\n    tag  = get4();\n    len  = get4();\n    data = get4();\n    save = ftell(ifp);\n    fseek (ifp, meta_offset+data, SEEK_SET);\n    if (tag == 0x419) {\t\t\t\t/* Polynomial curve */\n      for (get4(), i=0; i < 8; i++)\n\tpoly[i] = getreal(11);\n      poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;\n      for (i=0; i < 0x10000; i++) {\n\tnum = (poly[5]*i + poly[3])*i + poly[1];\n\tcurve[i] = LIM(num,0,65535);\n      } goto apply;\t\t\t\t/* apply to right half */\n    } else if (tag == 0x41a) {\t\t\t/* Polynomial curve */\n      for (i=0; i < 4; i++)\n\tpoly[i] = getreal(11);\n      for (i=0; i < 0x10000; i++) {\n\tfor (num=0, j=4; j--; )\n\t  num = num * i + poly[j];\n\tcurve[i] = LIM(num+i,0,65535);\n      } apply:\t\t\t\t\t/* apply to whole image */\n      for (row=0; row < raw_height; row++)\n\tfor (col = (tag & 1)*ph1.split_col; col < raw_width; col++)\n\t  RAW(row,col) = curve[RAW(row,col)];\n    } else if (tag == 0x400) {\t\t\t/* Sensor defects */\n      while ((len -= 8) >= 0) {\n\tcol  = get2();\n\trow  = get2();\n\ttype = get2(); get2();\n\tif (col >= raw_width) continue;\n\tif (type == 131)\t\t\t/* Bad column */\n\t  for (row=0; row < raw_height; row++)\n\t    if (FC(row-top_margin,col-left_margin) == 1) {\n\t      for (sum=i=0; i < 4; i++)\n\t\tsum += val[i] = raw (row+dir[i][0], col+dir[i][1]);\n\t      for (max=i=0; i < 4; i++) {\n\t\tdev[i] = abs((val[i] << 2) - sum);\n\t\tif (dev[max] < dev[i]) max = i;\n\t      }\n\t      RAW(row,col) = (sum - val[max])/3.0 + 0.5;\n\t    } else {\n\t      for (sum=0, i=8; i < 12; i++)\n\t\tsum += raw (row+dir[i][0], col+dir[i][1]);\n\t      RAW(row,col) = 0.5 + sum * 0.0732233 +\n\t\t(raw(row,col-2) + raw(row,col+2)) * 0.3535534;\n\t    }\n\telse if (type == 129) {\t\t\t/* Bad pixel */\n\t  if (row >= raw_height) continue;\n\t  j = (FC(row-top_margin,col-left_margin) != 1) * 4;\n\t  for (sum=0, i=j; i < j+8; i++)\n\t    sum += raw (row+dir[i][0], col+dir[i][1]);\n\t  RAW(row,col) = (sum + 4) >> 3;\n\t}\n      }\n    } else if (tag == 0x401) {\t\t\t/* All-color flat fields */\n      phase_one_flat_field (1, 2);\n    } else if (tag == 0x416 || tag == 0x410) {\n      phase_one_flat_field (0, 2);\n    } else if (tag == 0x40b) {\t\t\t/* Red+blue flat field */\n      phase_one_flat_field (0, 4);\n    } else if (tag == 0x412) {\n      fseek (ifp, 36, SEEK_CUR);\n      diff = abs (get2() - ph1.tag_21a);\n      if (mindiff > diff) {\n\tmindiff = diff;\n\toff_412 = ftell(ifp) - 38;\n      }\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n  if (off_412) {\n    fseek (ifp, off_412, SEEK_SET);\n    for (i=0; i < 9; i++) head[i] = get4() & 0x7fff;\n    yval[0] = (float *) calloc (head[1]*head[3] + head[2]*head[4], 6);\n    merror (yval[0], \"phase_one_correct()\");\n    yval[1] = (float  *) (yval[0] + head[1]*head[3]);\n    xval[0] = (ushort *) (yval[1] + head[2]*head[4]);\n    xval[1] = (ushort *) (xval[0] + head[1]*head[3]);\n    get2();\n    for (i=0; i < 2; i++)\n      for (j=0; j < head[i+1]*head[i+3]; j++)\n\tyval[i][j] = getreal(11);\n    for (i=0; i < 2; i++)\n      for (j=0; j < head[i+1]*head[i+3]; j++)\n\txval[i][j] = get2();\n    for (row=0; row < raw_height; row++)\n      for (col=0; col < raw_width; col++) {\n\tcfrac = (float) col * head[3] / raw_width;\n\tcfrac -= cip = cfrac;\n\tnum = RAW(row,col) * 0.5;\n\tfor (i=cip; i < cip+2; i++) {\n\t  for (k=j=0; j < head[1]; j++)\n\t    if (num < xval[0][k = head[1]*i+j]) break;\n\t  frac = (j == 0 || j == head[1]) ? 0 :\n\t\t(xval[0][k] - num) / (xval[0][k] - xval[0][k-1]);\n\t  mult[i-cip] = yval[0][k-1] * frac + yval[0][k] * (1-frac);\n\t}\n\ti = ((mult[0] * (1-cfrac) + mult[1] * cfrac) * row + num) * 2;\n\tRAW(row,col) = LIM(i,0,65535);\n      }\n    free (yval[0]);\n  }\n}\n\nvoid CLASS phase_one_load_raw()\n{\n  int a, b, i;\n  ushort akey, bkey, t_mask;\n\n  fseek (ifp, ph1.key_off, SEEK_SET);\n  akey = get2();\n  bkey = get2();\n  t_mask = ph1.format == 1 ? 0x5555:0x1354;\n  fseek (ifp, data_offset, SEEK_SET);\n  read_shorts (raw_image, raw_width*raw_height);\n  if (ph1.format)\n    for (i=0; i < raw_width*raw_height; i+=2) {\n      a = raw_image[i+0] ^ akey;\n      b = raw_image[i+1] ^ bkey;\n      raw_image[i+0] = (a & t_mask) | (b & ~t_mask);\n      raw_image[i+1] = (b & t_mask) | (a & ~t_mask);\n    }\n}\n\nunsigned CLASS ph1_bithuff (int nbits, ushort *huff)\n{\n#ifndef LIBRAW_NOTHREADS\n#define bitbuf tls->ph1_bits.bitbuf\n#define vbits  tls->ph1_bits.vbits    \n#else\n  static UINT64 bitbuf=0;\n  static int vbits=0;\n#endif\n  unsigned c;\n\n  if (nbits == -1)\n    return bitbuf = vbits = 0;\n  if (nbits == 0) return 0;\n  if (vbits < nbits) {\n    bitbuf = bitbuf << 32 | get4();\n    vbits += 32;\n  }\n  c = bitbuf << (64-vbits) >> (64-nbits);\n  if (huff) {\n    vbits -= huff[c] >> 8;\n    return (uchar) huff[c];\n  }\n  vbits -= nbits;\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#endif\n}\n#define ph1_bits(n) ph1_bithuff(n,0)\n#define ph1_huff(h) ph1_bithuff(*h,h+1)\n\nvoid CLASS phase_one_load_raw_c()\n{\n  static const int length[] = { 8,7,6,9,11,10,5,12,14,13 };\n  int *offset, len[2], pred[2], row, col, i, j;\n  ushort *pixel;\n  short (*t_black)[2];\n\n  pixel = (ushort *) calloc (raw_width + raw_height*4, 2);\n  merror (pixel, \"phase_one_load_raw_c()\");\n  offset = (int *) (pixel + raw_width);\n  fseek (ifp, strip_offset, SEEK_SET);\n  for (row=0; row < raw_height; row++)\n    offset[row] = get4();\n  t_black = (short (*)[2]) offset + raw_height;\n  fseek (ifp, ph1.black_off, SEEK_SET);\n  if (ph1.black_off)\n      {\n          read_shorts ((ushort *) t_black[0], raw_height*2);\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.rawdata.ph1_black = (short (*)[2])calloc(raw_height*2,sizeof(short));\n          merror (imgdata.rawdata.ph1_black, \"phase_one_load_raw_c()\");\n          memmove(imgdata.rawdata.ph1_black,(short *) t_black[0],raw_height*2*sizeof(short));\n#endif\n      }\n  for (i=0; i < 256; i++)\n    curve[i] = i*i / 3.969 + 0.5;\n  for (row=0; row < raw_height; row++) {\n    fseek (ifp, data_offset + offset[row], SEEK_SET);\n    ph1_bits(-1);\n    pred[0] = pred[1] = 0;\n    for (col=0; col < raw_width; col++) {\n      if (col >= (raw_width & -8))\n\tlen[0] = len[1] = 14;\n      else if ((col & 7) == 0)\n\tfor (i=0; i < 2; i++) {\n\t  for (j=0; j < 5 && !ph1_bits(1); j++);\n\t  if (j--) len[i] = length[j*2 + ph1_bits(1)];\n\t}\n      if ((i = len[col & 1]) == 14)\n\tpixel[col] = pred[col & 1] = ph1_bits(16);\n      else\n\tpixel[col] = pred[col & 1] += ph1_bits(i) + 1 - (1 << (i - 1));\n      if (pred[col & 1] >> 16) derror();\n      if (ph1.format == 5 && pixel[col] < 256)\n\tpixel[col] = curve[pixel[col]];\n    }\n    for (col=0; col < raw_width; col++) {\n#ifndef LIBRAW_LIBRARY_BUILD\n      i = (pixel[col] << 2) - ph1.t_black + t_black[row][col >= ph1.split_col];\n      if (i > 0) RAW(row,col) = i;\n#else\n      RAW(row,col) = pixel[col] << 2;\n#endif\n    }\n  }\n  free (pixel);\n  maximum = 0xfffc - ph1.t_black;\n}\n\nvoid CLASS hasselblad_load_raw()\n{\n  struct jhead jh;\n  int row, col, pred[2], len[2], diff, c;\n\n  if (!ljpeg_start (&jh, 0)) return;\n  order = 0x4949;\n  ph1_bits(-1);\n  for (row=0; row < raw_height; row++) {\n    pred[0] = pred[1] = 0x8000 + load_flags;\n    for (col=0; col < raw_width; col+=2) {\n      FORC(2) len[c] = ph1_huff(jh.huff[0]);\n      FORC(2) {\n\tdiff = ph1_bits(len[c]);\n\tif ((diff & (1 << (len[c]-1))) == 0)\n\t  diff -= (1 << len[c]) - 1;\n\tif (diff == 65535) diff = -32768;\n\tRAW(row,col+c) = pred[c] += diff;\n      }\n    }\n  }\n  ljpeg_end (&jh);\n  maximum = 0xffff;\n}\n\nvoid CLASS leaf_hdr_load_raw()\n{\n  ushort *pixel=0;\n  unsigned tile=0, r, c, row, col;\n\n  if (!filters) {\n    pixel = (ushort *) calloc (raw_width, sizeof *pixel);\n    merror (pixel, \"leaf_hdr_load_raw()\");\n  }\n  FORC(tiff_samples)\n    for (r=0; r < raw_height; r++) {\n      if (r % tile_length == 0) {\n\tfseek (ifp, data_offset + 4*tile++, SEEK_SET);\n\tfseek (ifp, get4(), SEEK_SET);\n      }\n      if (filters && c != shot_select) continue;\n      if (filters) pixel = raw_image + r*raw_width;\n      read_shorts (pixel, raw_width);\n      if (!filters && (row = r - top_margin) < height)\n\tfor (col=0; col < width; col++)\n\t  image[row*width+col][c] = pixel[col+left_margin];\n    }\n  if (!filters) {\n    maximum = 0xffff;\n    raw_color = 1;\n    free (pixel);\n  }\n}\n\nvoid CLASS unpacked_load_raw()\n{\n  int row, col, bits=0;\n\n  while (1 << ++bits < maximum);\n  read_shorts (raw_image, raw_width*raw_height);\n  for (row=0; row < raw_height; row++)\n    for (col=0; col < raw_width; col++)\n      if ((RAW(row,col) >>= load_flags) >> bits\n\t&& (unsigned) (row-top_margin) < height\n\t&& (unsigned) (col-left_margin) < width) derror();\n}\n\nvoid CLASS sinar_4shot_load_raw()\n{\n  ushort *pixel;\n  unsigned shot, row, col, r, c;\n\n  if ((shot = shot_select) || half_size) {\n    if (shot) shot--;\n    if (shot > 3) shot = 3;\n    fseek (ifp, data_offset + shot*4, SEEK_SET);\n    fseek (ifp, get4(), SEEK_SET);\n    unpacked_load_raw();\n    return;\n  }\n#ifndef LIBRAW_LIBRARY_BUILD\n  free (raw_image);\n  raw_image = 0;\n  free (image);\n  image = (ushort (*)[4])\n\tcalloc ((iheight=height)*(iwidth=width), sizeof *image);\n  merror (image, \"sinar_4shot_load_raw()\");\n#endif\n  pixel = (ushort *) calloc (raw_width, sizeof *pixel);\n  merror (pixel, \"sinar_4shot_load_raw()\");\n  for (shot=0; shot < 4; shot++) {\n    fseek (ifp, data_offset + shot*4, SEEK_SET);\n    fseek (ifp, get4(), SEEK_SET);\n    for (row=0; row < raw_height; row++) {\n      read_shorts (pixel, raw_width);\n      if ((r = row-top_margin - (shot >> 1 & 1)) >= height) continue;\n      for (col=0; col < raw_width; col++) {\n\tif ((c = col-left_margin - (shot & 1)) >= width) continue;\n\timage[r*width+c][FC(row,col)] = pixel[col];\n      }\n    }\n  }\n  free (pixel);\n  shrink = filters = 0;\n}\n\nvoid CLASS imacon_full_load_raw()\n{\n  int row, col;\n\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      read_shorts (image[row*width+col], 3);\n}\n\nvoid CLASS packed_load_raw()\n{\n  int vbits=0, bwide, pwide, rbits, bite, half, irow, row, col, val, i;\n  UINT64 bitbuf=0;\n\n  if (raw_width * 8 >= width * tiff_bps)\t/* Is raw_width in bytes? */\n       pwide = (bwide = raw_width) * 8 / tiff_bps;\n  else bwide = (pwide = raw_width) * tiff_bps / 8;\n  rbits = bwide * 8 - pwide * tiff_bps;\n  if (load_flags & 1) bwide = bwide * 16 / 15;\n  bite = 8 + (load_flags & 24);\n  half = (raw_height+1) >> 1;\n  for (irow=0; irow < raw_height; irow++) {\n    row = irow;\n    if (load_flags & 2 &&\n\t(row = irow % half * 2 + irow / half) == 1 &&\n\tload_flags & 4) {\n      if (vbits=0, tiff_compress)\n\tfseek (ifp, data_offset - (-half*bwide & -2048), SEEK_SET);\n      else {\n\tfseek (ifp, 0, SEEK_END);\n\tfseek (ifp, ftell(ifp) >> 3 << 2, SEEK_SET);\n      }\n    }\n    for (col=0; col < pwide; col++) {\n      for (vbits -= tiff_bps; vbits < 0; vbits += bite) {\n\tbitbuf <<= bite;\n\tfor (i=0; i < bite; i+=8)\n\t  bitbuf |= (unsigned) (fgetc(ifp) << i);\n      }\n      val = bitbuf << (64-tiff_bps-vbits) >> (64-tiff_bps);\n      RAW(row,col ^ (load_flags >> 6)) = val;\n      if (load_flags & 1 && (col % 10) == 9 &&\n\tfgetc(ifp) && col < width+left_margin) derror();\n    }\n    vbits -= rbits;\n  }\n}\n\nvoid CLASS nokia_load_raw()\n{\n  uchar  *data,  *dp;\n  int rev, dwide, row, col, c;\n\n  rev = 3 * (order == 0x4949);\n  dwide = (raw_width * 5 +1) / 4;\n  data = (uchar *) malloc (dwide*2);\n  merror (data, \"nokia_load_raw()\");\n  for (row=0; row < raw_height; row++) {\n    if (fread (data+dwide, 1, dwide, ifp) < dwide) derror();\n    FORC(dwide) data[c] = data[dwide+(c ^ rev)];\n    for (dp=data, col=0; col < raw_width; dp+=5, col+=4)\n      FORC4 RAW(row,col+c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n  }\n  free (data);\n  maximum = 0x3ff;\n}\n\nunsigned CLASS pana_bits (int nbits)\n{\n#ifndef LIBRAW_NOTHREADS\n#define buf tls->pana_bits.buf\n#define vbits tls->pana_bits.vbits   \n#else\n  static uchar buf[0x4000];\n  static int vbits;\n#endif\n  int byte;\n\n  if (!nbits) return vbits=0;\n  if (!vbits) {\n    fread (buf+load_flags, 1, 0x4000-load_flags, ifp);\n    fread (buf, 1, load_flags, ifp);\n  }\n  vbits = (vbits - nbits) & 0x1ffff;\n  byte = vbits >> 3 ^ 0x3ff0;\n  return (buf[byte] | buf[byte+1] << 8) >> (vbits & 7) & ~(-1 << nbits);\n#ifndef LIBRAW_NOTHREADS\n#undef buf\n#undef vbits\n#endif\n}\n\nvoid CLASS panasonic_load_raw()\n{\n  int row, col, i, j, sh=0, pred[2], nonz[2];\n\n  pana_bits(0);\n  for (row=0; row < height; row++)\n    for (col=0; col < raw_width; col++) {\n      if ((i = col % 14) == 0)\n\tpred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n      if (i % 3 == 2) sh = 4 >> (3 - pana_bits(2));\n      if (nonz[i & 1]) {\n\tif ((j = pana_bits(8))) {\n\t  if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)\n\t       pred[i & 1] &= ~(-1 << sh);\n\t  pred[i & 1] += j << sh;\n\t}\n      } else if ((nonz[i & 1] = pana_bits(8)) || i > 11)\n\tpred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);\n      if ((RAW(row,col) = pred[col & 1]) > 4098 && col < width) derror();\n    }\n}\n\nvoid CLASS olympus_load_raw()\n{\n  ushort huff[4096];\n  int row, col, nbits, sign, low, high, i, c, w, n, nw;\n  int acarry[2][3], *carry, pred, diff;\n\n  huff[n=0] = 0xc0c;\n  for (i=12; i--; )\n    FORC(2048 >> i) huff[++n] = (i+1) << 8 | i;\n  fseek (ifp, 7, SEEK_CUR);\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!data_size)\n      throw LIBRAW_EXCEPTION_IO_BADFILE;\n  LibRaw_byte_buffer *buf = ifp->make_byte_buffer(data_size);\n  LibRaw_bit_buffer bits;\n  bits.reset();\n#else\n  getbits(-1);\n#endif\n  for (row=0; row < height; row++) {\n    memset (acarry, 0, sizeof acarry);\n    for (col=0; col < raw_width; col++) {\n      carry = acarry[col & 1];\n      i = 2 * (carry[2] < 3);\n      for (nbits=2+i; (ushort) carry[0] >> (nbits+i); nbits++);\n#ifdef LIBRAW_LIBRARY_BUILD\n      low = (sign = bits._getbits(buf,3,zero_after_ff)) & 3;\n      sign = sign << 29 >> 31;\n      if ((high = bits._gethuff(buf,12,huff,zero_after_ff)) == 12)\n          high = bits._getbits(buf,16-nbits,zero_after_ff) >> 1;\n      carry[0] = (high << nbits) | bits._getbits(buf,nbits,zero_after_ff);\n#else\n      low = (sign = getbits(3)) & 3;\n      sign = sign << 29 >> 31;\n      if ((high = getbithuff(12,huff)) == 12)\n\thigh = getbits(16-nbits) >> 1;\n      carry[0] = (high << nbits) | getbits(nbits);\n#endif\n      diff = (carry[0] ^ sign) + carry[1];\n      carry[1] = (diff*3 + carry[1]) >> 5;\n      carry[2] = carry[0] > 16 ? 0 : carry[2]+1;\n      if (col >= width) continue;\n      if (row < 2 && col < 2) pred = 0;\n      else if (row < 2) pred = RAW(row,col-2);\n      else if (col < 2) pred = RAW(row-2,col);\n      else {\n\tw  = RAW(row,col-2);\n\tn  = RAW(row-2,col);\n\tnw = RAW(row-2,col-2);\n\tif ((w < nw && nw < n) || (n < nw && nw < w)) {\n\t  if (ABS(w-nw) > 32 || ABS(n-nw) > 32)\n\t    pred = w + n - nw;\n\t  else pred = (w + n) >> 1;\n\t} else pred = ABS(w-nw) > ABS(n-nw) ? w : n;\n      }\n      if ((RAW(row,col) = pred + ((diff << 2) | low)) >> 12) derror();\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  delete buf;\n#endif\n}\n\nvoid CLASS minolta_rd175_load_raw()\n{\n  uchar pixel[768];\n  unsigned irow, box, row, col;\n\n  for (irow=0; irow < 1481; irow++) {\n    if (fread (pixel, 1, 768, ifp) < 768) derror();\n    box = irow / 82;\n    row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box-12)*2);\n    switch (irow) {\n      case 1477: case 1479: continue;\n      case 1476: row = 984; break;\n      case 1480: row = 985; break;\n      case 1478: row = 985; box = 1;\n    }\n    if ((box < 12) && (box & 1)) {\n      for (col=0; col < 1533; col++, row ^= 1)\n\tif (col != 1) RAW(row,col) = (col+1) & 2 ?\n\t\t   pixel[col/2-1] + pixel[col/2+1] : pixel[col/2] << 1;\n      RAW(row,1)    = pixel[1]   << 1;\n      RAW(row,1533) = pixel[765] << 1;\n    } else\n      for (col=row & 1; col < 1534; col+=2)\n\tRAW(row,col) = pixel[col/2] << 1;\n  }\n  maximum = 0xff << 1;\n}\n\nvoid CLASS quicktake_100_load_raw()\n{\n  uchar pixel[484][644];\n  static const short gstep[16] =\n  { -89,-60,-44,-32,-22,-15,-8,-2,2,8,15,22,32,44,60,89 };\n  static const short rstep[6][4] =\n  { {  -3,-1,1,3  }, {  -5,-1,1,5  }, {  -8,-2,2,8  },\n    { -13,-3,3,13 }, { -19,-4,4,19 }, { -28,-6,6,28 } };\n  static const short t_curve[256] =\n  { 0,1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,\n    28,29,30,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,53,\n    54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,74,75,76,77,78,\n    79,80,81,82,83,84,86,88,90,92,94,97,99,101,103,105,107,110,112,114,116,\n    118,120,123,125,127,129,131,134,136,138,140,142,144,147,149,151,153,155,\n    158,160,162,164,166,168,171,173,175,177,179,181,184,186,188,190,192,195,\n    197,199,201,203,205,208,210,212,214,216,218,221,223,226,230,235,239,244,\n    248,252,257,261,265,270,274,278,283,287,291,296,300,305,309,313,318,322,\n    326,331,335,339,344,348,352,357,361,365,370,374,379,383,387,392,396,400,\n    405,409,413,418,422,426,431,435,440,444,448,453,457,461,466,470,474,479,\n    483,487,492,496,500,508,519,531,542,553,564,575,587,598,609,620,631,643,\n    654,665,676,687,698,710,721,732,743,754,766,777,788,799,810,822,833,844,\n    855,866,878,889,900,911,922,933,945,956,967,978,989,1001,1012,1023 };\n  int rb, row, col, sharp, val=0;\n\n  getbits(-1);\n  memset (pixel, 0x80, sizeof pixel);\n  for (row=2; row < height+2; row++) {\n    for (col=2+(row & 1); col < width+2; col+=2) {\n      val = ((pixel[row-1][col-1] + 2*pixel[row-1][col+1] +\n\t\tpixel[row][col-2]) >> 2) + gstep[getbits(4)];\n      pixel[row][col] = val = LIM(val,0,255);\n      if (col < 4)\n\tpixel[row][col-2] = pixel[row+1][~row & 1] = val;\n      if (row == 2)\n\tpixel[row-1][col+1] = pixel[row-1][col+3] = val;\n    }\n    pixel[row][col] = val;\n  }\n  for (rb=0; rb < 2; rb++)\n    for (row=2+rb; row < height+2; row+=2)\n      for (col=3-(row & 1); col < width+2; col+=2) {\n\tif (row < 4 || col < 4) sharp = 2;\n\telse {\n\t  val = ABS(pixel[row-2][col] - pixel[row][col-2])\n\t      + ABS(pixel[row-2][col] - pixel[row-2][col-2])\n\t      + ABS(pixel[row][col-2] - pixel[row-2][col-2]);\n\t  sharp = val <  4 ? 0 : val <  8 ? 1 : val < 16 ? 2 :\n\t\t  val < 32 ? 3 : val < 48 ? 4 : 5;\n\t}\n\tval = ((pixel[row-2][col] + pixel[row][col-2]) >> 1)\n\t      + rstep[sharp][getbits(2)];\n\tpixel[row][col] = val = LIM(val,0,255);\n\tif (row < 4) pixel[row-2][col+2] = val;\n\tif (col < 4) pixel[row+2][col-2] = val;\n      }\n  for (row=2; row < height+2; row++)\n    for (col=3-(row & 1); col < width+2; col+=2) {\n      val = ((pixel[row][col-1] + (pixel[row][col] << 2) +\n\t      pixel[row][col+1]) >> 1) - 0x100;\n      pixel[row][col] = LIM(val,0,255);\n    }\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      RAW(row,col) = t_curve[pixel[row+2][col+2]];\n  maximum = 0x3ff;\n}\n\n#define radc_token(tree) ((signed char) getbithuff(8,huff[tree]))\n\n#define FORYX for (y=1; y < 3; y++) for (x=col+1; x >= col; x--)\n\n#define PREDICTOR (c ? (buf[c][y-1][x] + buf[c][y][x+1]) / 2 \\\n: (buf[c][y-1][x+1] + 2*buf[c][y-1][x] + buf[c][y][x+1]) / 4)\n\n#ifdef __GNUC__\n# if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)\n# pragma GCC optimize(\"no-aggressive-loop-optimizations\")\n# endif\n#endif\n\nvoid CLASS kodak_radc_load_raw()\n{\n  static const char src[] = {\n    1,1, 2,3, 3,4, 4,2, 5,7, 6,5, 7,6, 7,8,\n    1,0, 2,1, 3,3, 4,4, 5,2, 6,7, 7,6, 8,5, 8,8,\n    2,1, 2,3, 3,0, 3,2, 3,4, 4,6, 5,5, 6,7, 6,8,\n    2,0, 2,1, 2,3, 3,2, 4,4, 5,6, 6,7, 7,5, 7,8,\n    2,1, 2,4, 3,0, 3,2, 3,3, 4,7, 5,5, 6,6, 6,8,\n    2,3, 3,1, 3,2, 3,4, 3,5, 3,6, 4,7, 5,0, 5,8,\n    2,3, 2,6, 3,0, 3,1, 4,4, 4,5, 4,7, 5,2, 5,8,\n    2,4, 2,7, 3,3, 3,6, 4,1, 4,2, 4,5, 5,0, 5,8,\n    2,6, 3,1, 3,3, 3,5, 3,7, 3,8, 4,0, 5,2, 5,4,\n    2,0, 2,1, 3,2, 3,3, 4,4, 4,5, 5,6, 5,7, 4,8,\n    1,0, 2,2, 2,-2,\n    1,-3, 1,3,\n    2,-17, 2,-5, 2,5, 2,17,\n    2,-7, 2,2, 2,9, 2,18,\n    2,-18, 2,-9, 2,-2, 2,7,\n    2,-28, 2,28, 3,-49, 3,-9, 3,9, 4,49, 5,-79, 5,79,\n    2,-1, 2,13, 2,26, 3,39, 4,-16, 5,55, 6,-37, 6,76,\n    2,-26, 2,-13, 2,1, 3,-39, 4,16, 5,-55, 6,-76, 6,37\n  };\n  ushort huff[19][256];\n  int row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;\n  short last[3] = { 16,16,16 }, mul[3], buf[3][3][386];\n  static const ushort pt[] =\n    { 0,0, 1280,1344, 2320,3616, 3328,8000, 4095,16383, 65535,16383 };\n\n  for (i=2; i < 12; i+=2)\n    for (c=pt[i-2]; c <= pt[i]; c++)\n      curve[c] = (float)\n\t(c-pt[i-2]) / (pt[i]-pt[i-2]) * (pt[i+1]-pt[i-1]) + pt[i-1] + 0.5;\n  for (s=i=0; i < sizeof src; i+=2)\n    FORC(256 >> src[i])\n      huff[0][s++] = src[i] << 8 | (uchar) src[i+1];\n  s = kodak_cbpp == 243 ? 2 : 3;\n  FORC(256) huff[18][c] = (8-s) << 8 | c >> s << s | 1 << (s-1);\n  getbits(-1);\n  for (i=0; i < sizeof(buf)/sizeof(short); i++)\n    buf[0][0][i] = 2048;\n  for (row=0; row < height; row+=4) {\n    FORC3 mul[c] = getbits(6);\n    FORC3 {\n      val = ((0x1000000/last[c] + 0x7ff) >> 12) * mul[c];\n      s = val > 65564 ? 10:12;\n      x = ~(-1 << (s-1));\n      val <<= 12-s;\n      for (i=0; i < sizeof(buf[0])/sizeof(short); i++)\n\tbuf[c][0][i] = (buf[c][0][i] * val + x) >> s;\n      last[c] = mul[c];\n      for (r=0; r <= !c; r++) {\n\tbuf[c][1][width/2] = buf[c][2][width/2] = mul[c] << 7;\n\tfor (tree=1, col=width/2; col > 0; ) {\n\t  if ((tree = radc_token(tree))) {\n\t    col -= 2;\n\t    if (tree == 8)\n\t      FORYX buf[c][y][x] = (uchar) radc_token(18) * mul[c];\n\t    else\n\t      FORYX buf[c][y][x] = radc_token(tree+10) * 16 + PREDICTOR;\n\t  } else\n\t    do {\n\t      nreps = (col > 2) ? radc_token(9) + 1 : 1;\n\t      for (rep=0; rep < 8 && rep < nreps && col > 0; rep++) {\n\t\tcol -= 2;\n\t\tFORYX buf[c][y][x] = PREDICTOR;\n\t\tif (rep & 1) {\n\t\t  step = radc_token(10) << 4;\n\t\t  FORYX buf[c][y][x] += step;\n\t\t}\n\t      }\n\t    } while (nreps == 9);\n\t}\n\tfor (y=0; y < 2; y++)\n\t  for (x=0; x < width/2; x++) {\n\t    val = (buf[c][y+1][x] << 4) / mul[c];\n\t    if (val < 0) val = 0;\n\t    if (c) RAW(row+y*2+c-1,x*2+2-c) = val;\n\t    else   RAW(row+r*2+y,x*2+y) = val;\n\t  }\n\tmemcpy (buf[c][0]+!c, buf[c][2], sizeof buf[c][0]-2*!c);\n      }\n    }\n    for (y=row; y < row+4; y++)\n      for (x=0; x < width; x++)\n\tif ((x+y) & 1) {\n\t  r = x ? x-1 : x+1;\n\t  s = x+1 < width ? x+1 : x-1;\n\t  val = (RAW(y,x)-2048)*2 + (RAW(y,r)+RAW(y,s))/2;\n\t  if (val < 0) val = 0;\n\t  RAW(y,x) = val;\n\t}\n  }\n  for (i=0; i < height*width; i++)\n    raw_image[i] = curve[raw_image[i]];\n  maximum = 0x3fff;\n}\n\n#undef FORYX\n#undef PREDICTOR\n\n#ifdef NO_JPEG\nvoid CLASS kodak_jpeg_load_raw() {}\nvoid CLASS lossy_dng_load_raw() {}\n#else\n\n#ifdef LIBRAW_LIBRARY_BUILD\nvoid CLASS kodak_jpeg_load_raw() {}\n#else\n\nMETHODDEF(boolean)\nfill_input_buffer (j_decompress_ptr cinfo)\n{\n#ifndef LIBRAW_NOTHREADS\n#define jpeg_buffer tls->jpeg_buffer\n#else\n  static uchar jpeg_buffer[4096];\n#endif\n  size_t nbytes;\n\n  nbytes = fread (jpeg_buffer, 1, 4096, ifp);\n  swab (jpeg_buffer, jpeg_buffer, nbytes);\n  cinfo->src->next_input_byte = jpeg_buffer;\n  cinfo->src->bytes_in_buffer = nbytes;\n  return TRUE;\n#ifndef LIBRAW_NOTHREADS\n#undef jpeg_buffer\n#endif\n}\n\nvoid CLASS kodak_jpeg_load_raw()\n{\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  JSAMPARRAY buf;\n  JSAMPLE (*pixel)[3];\n  int row, col;\n\n  cinfo.err = jpeg_std_error (&jerr);\n  jpeg_create_decompress (&cinfo);\n  jpeg_stdio_src (&cinfo, ifp);\n  cinfo.src->fill_input_buffer = fill_input_buffer;\n  jpeg_read_header (&cinfo, TRUE);\n  jpeg_start_decompress (&cinfo);\n  if ((cinfo.output_width      != width  ) ||\n      (cinfo.output_height*2   != height ) ||\n      (cinfo.output_components != 3      )) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s: incorrect JPEG dimensions\\n\"), ifname);\n#endif\n    jpeg_destroy_decompress (&cinfo);\n#ifdef LIBRAW_LIBRARY_BUILD\n    throw LIBRAW_EXCEPTION_DECODE_JPEG;\n#else\n    longjmp (failure, 3);\n#endif\n  }\n  buf = (*cinfo.mem->alloc_sarray)\n\t\t((j_common_ptr) &cinfo, JPOOL_IMAGE, width*3, 1);\n\n  while (cinfo.output_scanline < cinfo.output_height) {\n    row = cinfo.output_scanline * 2;\n    jpeg_read_scanlines (&cinfo, buf, 1);\n    pixel = (JSAMPLE (*)[3]) buf[0];\n    for (col=0; col < width; col+=2) {\n      RAW(row+0,col+0) = pixel[col+0][1] << 1;\n      RAW(row+1,col+1) = pixel[col+1][1] << 1;\n      RAW(row+0,col+1) = pixel[col][0] + pixel[col+1][0];\n      RAW(row+1,col+0) = pixel[col][2] + pixel[col+1][2];\n    }\n  }\n  jpeg_finish_decompress (&cinfo);\n  jpeg_destroy_decompress (&cinfo);\n  maximum = 0xff << 1;\n}\n#endif\n\nvoid CLASS lossy_dng_load_raw()\n{\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  JSAMPARRAY buf;\n  JSAMPLE (*pixel)[3];\n  unsigned sorder=order, ntags, opcode, deg, i, j, c;\n  unsigned save=data_offset-4, trow=0, tcol=0, row, col;\n  ushort t_curve[3][256];\n  double coeff[9], tot;\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  order = 0x4d4d;\n  ntags = get4();\n  while (ntags--) {\n    opcode = get4(); get4(); get4();\n    if (opcode != 8)\n    { fseek (ifp, get4(), SEEK_CUR); continue; }\n    fseek (ifp, 20, SEEK_CUR);\n    if ((c = get4()) > 2) break;\n    fseek (ifp, 12, SEEK_CUR);\n    if ((deg = get4()) > 8) break;\n    for (i=0; i <= deg && i < 9; i++)\n      coeff[i] = getreal(12);\n    for (i=0; i < 256; i++) {\n      for (tot=j=0; j <= deg; j++)\n\ttot += coeff[j] * pow(i/255.0, (int)j);\n      t_curve[c][i] = tot*0xffff;\n    }\n  }\n  order = sorder;\n  cinfo.err = jpeg_std_error (&jerr);\n  jpeg_create_decompress (&cinfo);\n  while (trow < raw_height) {\n    fseek (ifp, save+=4, SEEK_SET);\n    if (tile_length < INT_MAX)\n      fseek (ifp, get4(), SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(libraw_internal_data.internal_data.input->jpeg_src(&cinfo) == -1)\n      {\n        jpeg_destroy_decompress(&cinfo);\n        throw LIBRAW_EXCEPTION_DECODE_JPEG;\n      }\n#else\n    jpeg_stdio_src (&cinfo, ifp);\n#endif\n    jpeg_read_header (&cinfo, TRUE);\n    jpeg_start_decompress (&cinfo);\n    buf = (*cinfo.mem->alloc_sarray)\n\t((j_common_ptr) &cinfo, JPOOL_IMAGE, cinfo.output_width*3, 1);\n    while (cinfo.output_scanline < cinfo.output_height &&\n\t(row = trow + cinfo.output_scanline) < height) {\n      jpeg_read_scanlines (&cinfo, buf, 1);\n      pixel = (JSAMPLE (*)[3]) buf[0];\n      for (col=0; col < cinfo.output_width && tcol+col < width; col++) {\n\tFORC3 image[row*width+tcol+col][c] = t_curve[c][pixel[col][c]];\n      }\n    }\n    jpeg_abort_decompress (&cinfo);\n    if ((tcol += tile_width) >= raw_width)\n      trow += tile_length + (tcol = 0);\n  }\n  jpeg_destroy_decompress (&cinfo);\n  maximum = 0xffff;\n}\n#endif\n\nvoid CLASS kodak_dc120_load_raw()\n{\n  static const int mul[4] = { 162, 192, 187,  92 };\n  static const int add[4] = {   0, 636, 424, 212 };\n  uchar pixel[848];\n  int row, shift, col;\n\n  for (row=0; row < height; row++) {\n    if (fread (pixel, 1, 848, ifp) < 848) derror();\n    shift = row * mul[row & 3] + add[row & 3];\n    for (col=0; col < width; col++)\n      RAW(row,col) = (ushort) pixel[(col + shift) % 848];\n  }\n  maximum = 0xff;\n}\n\nvoid CLASS eight_bit_load_raw()\n{\n  uchar *pixel;\n  unsigned row, col;\n\n  pixel = (uchar *) calloc (raw_width, sizeof *pixel);\n  merror (pixel, \"eight_bit_load_raw()\");\n  for (row=0; row < raw_height; row++) {\n    if (fread (pixel, 1, raw_width, ifp) < raw_width) derror();\n    for (col=0; col < raw_width; col++)\n      RAW(row,col) = curve[pixel[col]];\n  }\n  free (pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_yrgb_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *) calloc (raw_width, 3*sizeof *pixel);\n  merror (pixel, \"kodak_yrgb_load_raw()\");\n  for (row=0; row < height; row++) {\n    if (~row & 1)\n      if (fread (pixel, raw_width, 3, ifp) < 3) derror();\n    for (col=0; col < raw_width; col++) {\n      y  = pixel[width*2*(row & 1) + col];\n      cb = pixel[width + (col & -2)]   - 128;\n      cr = pixel[width + (col & -2)+1] - 128;\n      rgb[1] = y-((cb + cr + 2) >> 2);\n      rgb[2] = rgb[1] + cb;\n      rgb[0] = rgb[1] + cr;\n      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];\n    }\n  }\n  free (pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_262_load_raw()\n{\n  static const uchar kodak_tree[2][26] =\n  { { 0,1,5,1,1,2,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 },\n    { 0,3,1,1,1,1,1,2,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 } };\n  ushort *huff[2];\n  uchar *pixel;\n  int *strip, ns, c, row, col, chess, pi=0, pi1, pi2, pred, val;\n\n  FORC(2) huff[c] = make_decoder (kodak_tree[c]);\n  ns = (raw_height+63) >> 5;\n  pixel = (uchar *) malloc (raw_width*32 + ns*4);\n  merror (pixel, \"kodak_262_load_raw()\");\n  strip = (int *) (pixel + raw_width*32);\n  order = 0x4d4d;\n  FORC(ns) strip[c] = get4();\n  for (row=0; row < raw_height; row++) {\n    if ((row & 31) == 0) {\n      fseek (ifp, strip[row >> 5], SEEK_SET);\n      getbits(-1);\n      pi = 0;\n    }\n    for (col=0; col < raw_width; col++) {\n      chess = (row + col) & 1;\n      pi1 = chess ? pi-2           : pi-raw_width-1;\n      pi2 = chess ? pi-2*raw_width : pi-raw_width+1;\n      if (col <= chess) pi1 = -1;\n      if (pi1 < 0) pi1 = pi2;\n      if (pi2 < 0) pi2 = pi1;\n      if (pi1 < 0 && col > 1) pi1 = pi2 = pi-2;\n      pred = (pi1 < 0) ? 0 : (pixel[pi1] + pixel[pi2]) >> 1;\n      pixel[pi] = val = pred + ljpeg_diff (huff[chess]);\n      if (val >> 8) derror();\n      val = curve[pixel[pi++]];\n      RAW(row,col) = val;\n    }\n  }\n  free (pixel);\n  FORC(2) free (huff[c]);\n}\n\nint CLASS kodak_65000_decode (short *out, int bsize)\n{\n  uchar c, blen[768];\n  ushort raw[6];\n  INT64 bitbuf=0;\n  int save, bits=0, i, j, len, diff;\n\n  save = ftell(ifp);\n  bsize = (bsize + 3) & -4;\n  for (i=0; i < bsize; i+=2) {\n    c = fgetc(ifp);\n    if ((blen[i  ] = c & 15) > 12 ||\n\t(blen[i+1] = c >> 4) > 12 ) {\n      fseek (ifp, save, SEEK_SET);\n      for (i=0; i < bsize; i+=8) {\n\tread_shorts (raw, 6);\n\tout[i  ] = raw[0] >> 12 << 8 | raw[2] >> 12 << 4 | raw[4] >> 12;\n\tout[i+1] = raw[1] >> 12 << 8 | raw[3] >> 12 << 4 | raw[5] >> 12;\n\tfor (j=0; j < 6; j++)\n\t  out[i+2+j] = raw[j] & 0xfff;\n      }\n      return 1;\n    }\n  }\n  if ((bsize & 7) == 4) {\n    bitbuf  = fgetc(ifp) << 8;\n    bitbuf += fgetc(ifp);\n    bits = 16;\n  }\n  for (i=0; i < bsize; i++) {\n    len = blen[i];\n    if (bits < len) {\n      for (j=0; j < 32; j+=8)\n\tbitbuf += (INT64) fgetc(ifp) << (bits+(j^8));\n      bits += 32;\n    }\n    diff = bitbuf & (0xffff >> (16-len));\n    bitbuf >>= len;\n    bits -= len;\n    if ((diff & (1 << (len-1))) == 0)\n      diff -= (1 << len) - 1;\n    out[i] = diff;\n  }\n  return 0;\n}\n\nvoid CLASS kodak_65000_load_raw()\n{\n  short buf[256];\n  int row, col, len, pred[2], ret, i;\n\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col+=256) {\n      pred[0] = pred[1] = 0;\n      len = MIN (256, width-col);\n      ret = kodak_65000_decode (buf, len);\n      for (i=0; i < len; i++)\n\tif ((RAW(row,col+i) =\tcurve[ret ? buf[i] :\n\t\t(pred[i & 1] += buf[i])]) >> 12) derror();\n    }\n}\n\nvoid CLASS kodak_ycbcr_load_raw()\n{\n  short buf[384], *bp;\n  int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n  ushort *ip;\n\n  for (row=0; row < height; row+=2)\n    for (col=0; col < width; col+=128) {\n      len = MIN (128, width-col);\n      kodak_65000_decode (buf, len*3);\n      y[0][1] = y[1][1] = cb = cr = 0;\n      for (bp=buf, i=0; i < len; i+=2, bp+=2) {\n\tcb += bp[4];\n\tcr += bp[5];\n\trgb[1] = -((cb + cr + 2) >> 2);\n\trgb[2] = rgb[1] + cb;\n\trgb[0] = rgb[1] + cr;\n\tfor (j=0; j < 2; j++)\n\t  for (k=0; k < 2; k++) {\n\t    if ((y[j][k] = y[j][k^1] + *bp++) >> 10) derror();\n\t    ip = image[(row+j)*width + col+i+k];\n\t    FORC3 ip[c] = curve[LIM(y[j][k]+rgb[c], 0, 0xfff)];\n\t  }\n      }\n    }\n}\n\nvoid CLASS kodak_rgb_load_raw()\n{\n  short buf[768], *bp;\n  int row, col, len, c, i, rgb[3];\n  ushort *ip=image[0];\n\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (raw_image) free (raw_image);\n  raw_image = 0;\n#endif\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col+=256) {\n      len = MIN (256, width-col);\n      kodak_65000_decode (buf, len*3);\n      memset (rgb, 0, sizeof rgb);\n      for (bp=buf, i=0; i < len; i++, ip+=4)\n\tFORC3 if ((ip[c] = rgb[c] += *bp++) >> 12) derror();\n    }\n}\n\nvoid CLASS kodak_thumb_load_raw()\n{\n  int row, col;\n  colors = thumb_misc >> 5;\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      read_shorts (image[row*width+col], colors);\n  maximum = (1 << (thumb_misc & 31)) - 1;\n}\n\nvoid CLASS sony_decrypt (unsigned *data, int len, int start, int key)\n{\n#ifndef LIBRAW_NOTHREADS\n#define pad tls->sony_decrypt.pad\n#define p   tls->sony_decrypt.p\n#else\n  static unsigned pad[128], p;\n#endif\n  if (start) {\n    for (p=0; p < 4; p++)\n      pad[p] = key = key * 48828125 + 1;\n    pad[3] = pad[3] << 1 | (pad[0]^pad[2]) >> 31;\n    for (p=4; p < 127; p++)\n      pad[p] = (pad[p-4]^pad[p-2]) << 1 | (pad[p-3]^pad[p-1]) >> 31;\n    for (p=0; p < 127; p++)\n      pad[p] = htonl(pad[p]);\n  }\n#if 1 // Avoid gcc 4.8 bug\n  while (len--)\n    {\n      *data++ ^= pad[p & 127] = pad[(p+1) & 127] ^ pad[(p+65) & 127];\n      p++;     \n    }\n#else\n  while (len--)\n    *data++ ^= pad[p++ & 127] = pad[(p+1) & 127] ^ pad[(p+65) & 127];\n#endif\n#ifndef LIBRAW_NOTHREADS\n#undef pad\n#undef p\n#endif\n}\n\nvoid CLASS sony_load_raw()\n{\n  uchar head[40];\n  ushort *pixel;\n  unsigned i, key, row, col;\n\n  fseek (ifp, 200896, SEEK_SET);\n  fseek (ifp, (unsigned) fgetc(ifp)*4 - 1, SEEK_CUR);\n  order = 0x4d4d;\n  key = get4();\n  fseek (ifp, 164600, SEEK_SET);\n  fread (head, 1, 40, ifp);\n  sony_decrypt ((unsigned int *) head, 10, 1, key);\n  for (i=26; i-- > 22; )\n    key = key << 8 | head[i];\n  fseek (ifp, data_offset, SEEK_SET);\n  for (row=0; row < raw_height; row++) {\n    pixel = raw_image + row*raw_width;\n    if (fread (pixel, 2, raw_width, ifp) < raw_width) derror();\n    sony_decrypt ((unsigned int *) pixel, raw_width/2, !row, key);\n    for (col=0; col < raw_width; col++)\n      if ((pixel[col] = ntohs(pixel[col])) >> 14) derror();\n  }\n  maximum = 0x3ff0;\n}\n\nvoid CLASS sony_arw_load_raw()\n{\n  ushort huff[32768];\n  static const ushort tab[18] =\n  { 0xf11,0xf10,0xe0f,0xd0e,0xc0d,0xb0c,0xa0b,0x90a,0x809,\n    0x708,0x607,0x506,0x405,0x304,0x303,0x300,0x202,0x201 };\n  int i, c, n, col, row, len, diff, sum=0;\n\n  for (n=i=0; i < 18; i++)\n    FORC(32768 >> (tab[i] >> 8)) huff[n++] = tab[i];\n#ifdef LIBRAW_LIBRARY_BUILD\n  LibRaw_byte_buffer *buf=NULL;\n  if(data_size)\n      buf = ifp->make_byte_buffer(data_size);\n  else\n      getbits(-1);\n      \n  LibRaw_bit_buffer bits;\n  bits.reset();\n#else\n  getbits(-1);\n#endif\n  for (col = raw_width; col--; )\n    for (row=0; row < raw_height+1; row+=2) {\n      if (row == raw_height) row = 1;\n#ifdef LIBRAW_LIBRARY_BUILD\n      if(data_size)\n          {\n              len = bits._gethuff(buf,15,huff,zero_after_ff);\n              diff = bits._getbits(buf,len,zero_after_ff);\n          }\n      else\n          {\n              len = getbithuff(15,huff);\n              diff = getbits(len);\n          }\n#else\n      len = getbithuff(15,huff);\n      diff = getbits(len);\n#endif\n      if ((diff & (1 << (len-1))) == 0)\n\tdiff -= (1 << len) - 1;\n      if ((sum += diff) >> 12) derror();\n      if (row < height) RAW(row,col) = sum;\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(buf) delete buf;\n#endif\n}\n\nvoid CLASS sony_arw2_load_raw()\n{\n  uchar *data, *dp;\n  ushort pix[16];\n  int row, col, val, max, min, imax, imin, sh, bit, i;\n\n  data = (uchar *) malloc (raw_width);\n  merror (data, \"sony_arw2_load_raw()\");\n  for (row=0; row < height; row++) {\n    fread (data, 1, raw_width, ifp);\n    for (dp=data, col=0; col < raw_width-30; dp+=16) {\n      max = 0x7ff & (val = sget4(dp));\n      min = 0x7ff & val >> 11;\n      imax = 0x0f & val >> 22;\n      imin = 0x0f & val >> 26;\n      for (sh=0; sh < 4 && 0x80 << sh <= max-min; sh++);\n      for (bit=30, i=0; i < 16; i++)\n\tif      (i == imax) pix[i] = max;\n\telse if (i == imin) pix[i] = min;\n\telse {\n\t  pix[i] = ((sget2(dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n\t  if (pix[i] > 0x7ff) pix[i] = 0x7ff;\n\t  bit += 7;\n\t}\n#ifdef LIBRAW_LIBRARY_BUILD\n      if(imgdata.params.sony_arw2_hack)\n          {\n              for (i=0; i < 16; i++, col+=2)\n                  RAW(row,col) = curve[pix[i] << 1];\n          }\n      else\n          {\n              for (i=0; i < 16; i++, col+=2)\n                  RAW(row,col) = curve[pix[i] << 1] >> 2;\n          }\n#else\n      for (i=0; i < 16; i++, col+=2)\n\tRAW(row,col) = curve[pix[i] << 1] >> 2;\n#endif\n      col -= col & 1 ? 1:31;\n    }\n  }\n  free (data);\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(imgdata.params.sony_arw2_hack)\n  {\n\tblack <<= 2;\n\tmaximum <<=2;\n  }\n#endif\n}\n\n#define HOLE(row) ((holes >> (((row) - raw_height) & 7)) & 1)\n\n/* Kudos to Rich Taylor for figuring out SMaL's compression algorithm. */\nvoid CLASS smal_decode_segment (unsigned seg[2][2], int holes)\n{\n  uchar hist[3][13] = {\n    { 7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0 },\n    { 7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0 },\n    { 3, 3, 0, 0, 63,     47,     31,     15,    0 } };\n  int low, high=0xff, carry=0, nbits=8;\n  int pix, s, count, bin, next, i, sym[3];\n  uchar diff, pred[]={0,0};\n  ushort data=0, range=0;\n\n  fseek (ifp, seg[0][1]+1, SEEK_SET);\n  getbits(-1);\n  for (pix=seg[0][0]; pix < seg[1][0]; pix++) {\n    for (s=0; s < 3; s++) {\n      data = data << nbits | getbits(nbits);\n      if (carry < 0)\n\tcarry = (nbits += carry+1) < 1 ? nbits-1 : 0;\n      while (--nbits >= 0)\n\tif ((data >> nbits & 0xff) == 0xff) break;\n      if (nbits > 0)\n\t  data = ((data & ((1 << (nbits-1)) - 1)) << 1) |\n\t((data + (((data & (1 << (nbits-1)))) << 1)) & (-1 << nbits));\n      if (nbits >= 0) {\n\tdata += getbits(1);\n\tcarry = nbits - 8;\n      }\n      count = ((((data-range+1) & 0xffff) << 2) - 1) / (high >> 4);\n      for (bin=0; hist[s][bin+5] > count; bin++);\n\t\tlow = hist[s][bin+5] * (high >> 4) >> 2;\n      if (bin) high = hist[s][bin+4] * (high >> 4) >> 2;\n      high -= low;\n      for (nbits=0; high << nbits < 128; nbits++);\n      range = (range+low) << nbits;\n      high <<= nbits;\n      next = hist[s][1];\n      if (++hist[s][2] > hist[s][3]) {\n\tnext = (next+1) & hist[s][0];\n\thist[s][3] = (hist[s][next+4] - hist[s][next+5]) >> 2;\n\thist[s][2] = 1;\n      }\n      if (hist[s][hist[s][1]+4] - hist[s][hist[s][1]+5] > 1) {\n\tif (bin < hist[s][1])\n\t  for (i=bin; i < hist[s][1]; i++) hist[s][i+5]--;\n\telse if (next <= bin)\n\t  for (i=hist[s][1]; i < bin; i++) hist[s][i+5]++;\n      }\n      hist[s][1] = next;\n      sym[s] = bin;\n    }\n    diff = sym[2] << 5 | sym[1] << 2 | (sym[0] & 3);\n    if (sym[0] & 4)\n      diff = diff ? -diff : 0x80;\n    if (ftell(ifp) + 12 >= seg[1][1])\n      diff = 0;\n    raw_image[pix] = pred[pix & 1] += diff;\n    if (!(pix & 1) && HOLE(pix / raw_width)) pix += 2;\n  }\n  maximum = 0xff;\n}\n\nvoid CLASS smal_v6_load_raw()\n{\n  unsigned seg[2][2];\n\n  fseek (ifp, 16, SEEK_SET);\n  seg[0][0] = 0;\n  seg[0][1] = get2();\n  seg[1][0] = raw_width * raw_height;\n  seg[1][1] = INT_MAX;\n  smal_decode_segment (seg, 0);\n}\n\nint CLASS median4 (int *p)\n{\n  int min, max, sum, i;\n\n  min = max = sum = p[0];\n  for (i=1; i < 4; i++) {\n    sum += p[i];\n    if (min > p[i]) min = p[i];\n    if (max < p[i]) max = p[i];\n  }\n  return (sum - min - max) >> 1;\n}\n\nvoid CLASS fill_holes (int holes)\n{\n  int row, col, val[4];\n\n  for (row=2; row < height-2; row++) {\n    if (!HOLE(row)) continue;\n    for (col=1; col < width-1; col+=4) {\n      val[0] = RAW(row-1,col-1);\n      val[1] = RAW(row-1,col+1);\n      val[2] = RAW(row+1,col-1);\n      val[3] = RAW(row+1,col+1);\n      RAW(row,col) = median4(val);\n    }\n    for (col=2; col < width-2; col+=4)\n      if (HOLE(row-2) || HOLE(row+2))\n\tRAW(row,col) = (RAW(row,col-2) + RAW(row,col+2)) >> 1;\n      else {\n\tval[0] = RAW(row,col-2);\n\tval[1] = RAW(row,col+2);\n\tval[2] = RAW(row-2,col);\n\tval[3] = RAW(row+2,col);\n\tRAW(row,col) = median4(val);\n      }\n  }\n}\n\nvoid CLASS smal_v9_load_raw()\n{\n  unsigned seg[256][2], offset, nseg, holes, i;\n\n  fseek (ifp, 67, SEEK_SET);\n  offset = get4();\n  nseg = fgetc(ifp);\n  fseek (ifp, offset, SEEK_SET);\n  for (i=0; i < nseg*2; i++)\n    seg[0][i] = get4() + data_offset*(i & 1);\n  fseek (ifp, 78, SEEK_SET);\n  holes = fgetc(ifp);\n  fseek (ifp, 88, SEEK_SET);\n  seg[nseg][0] = raw_height * raw_width;\n  seg[nseg][1] = get4() + data_offset;\n  for (i=0; i < nseg; i++)\n    smal_decode_segment (seg+i, holes);\n  if (holes) fill_holes (holes);\n}\n\nvoid CLASS redcine_load_raw()\n{\n#ifndef NO_JASPER\n  int c, row, col;\n  jas_stream_t *in;\n  jas_image_t *jimg;\n  jas_matrix_t *jmat;\n  jas_seqent_t *data;\n  ushort *img, *pix;\n\n  jas_init();\n#ifndef LIBRAW_LIBRARY_BUILD\n  in = jas_stream_fopen (ifname, \"rb\");\n#else\n  in = (jas_stream_t*)ifp->make_jas_stream();\n  if(!in)\n          throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n#endif\n  jas_stream_seek (in, data_offset+20, SEEK_SET);\n  jimg = jas_image_decode (in, -1, 0);\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!jimg) longjmp (failure, 3);\n#else\n  if(!jimg)\n      {\n          jas_stream_close (in);\n          throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n      }\n#endif\n  jmat = jas_matrix_create (height/2, width/2);\n  merror (jmat, \"redcine_load_raw()\");\n  img = (ushort *) calloc ((height+2)*(width+2), 2);\n  merror (img, \"redcine_load_raw()\");\n  FORC4 {\n    jas_image_readcmpt (jimg, c, 0, 0, width/2, height/2, jmat);\n    data = jas_matrix_getref (jmat, 0, 0);\n    for (row = c >> 1; row < height; row+=2)\n      for (col = c & 1; col < width; col+=2)\n\timg[(row+1)*(width+2)+col+1] = data[(row/2)*(width/2)+col/2];\n  }\n  for (col=1; col <= width; col++) {\n    img[col] = img[2*(width+2)+col];\n    img[(height+1)*(width+2)+col] = img[(height-1)*(width+2)+col];\n  }\n  for (row=0; row < height+2; row++) {\n    img[row*(width+2)] = img[row*(width+2)+2];\n    img[(row+1)*(width+2)-1] = img[(row+1)*(width+2)-3];\n  }\n  for (row=1; row <= height; row++) {\n    pix = img + row*(width+2) + (col = 1 + (FC(row,1) & 1));\n    for (   ; col <= width; col+=2, pix+=2) {\n      c = (((pix[0] - 0x800) << 3) +\n\tpix[-(width+2)] + pix[width+2] + pix[-1] + pix[1]) >> 2;\n      pix[0] = LIM(c,0,4095);\n    }\n  }\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      RAW(row,col) = curve[img[(row+1)*(width+2)+col+1]];\n  free (img);\n  jas_matrix_destroy (jmat);\n  jas_image_destroy (jimg);\n  jas_stream_close (in);\n#endif\n}\n#line 3846 \"dcraw/dcraw.c\"\nvoid CLASS crop_masked_pixels()\n{\n  int row, col;\n  unsigned \n#ifndef LIBRAW_LIBRARY_BUILD\n    r, raw_pitch = raw_width*2,\n#endif\n    c, m, mblack[8], zero, val;\n\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (load_raw == &CLASS phase_one_load_raw ||\n      load_raw == &CLASS phase_one_load_raw_c)\n    phase_one_correct();\n  if (fuji_width) {\n    for (row=0; row < raw_height-top_margin*2; row++) {\n      for (col=0; col < fuji_width << !fuji_layout; col++) {\n\tif (fuji_layout) {\n\t  r = fuji_width - 1 - col + (row >> 1);\n\t  c = col + ((row+1) >> 1);\n\t} else {\n\t  r = fuji_width - 1 + row - (col >> 1);\n\t  c = row + ((col+1) >> 1);\n\t}\n\tif (r < height && c < width)\n\t  BAYER(r,c) = RAW(row+top_margin,col+left_margin);\n      }\n    }\n  } else {\n    for (row=0; row < height; row++)\n      for (col=0; col < width; col++)\n\tBAYER2(row,col) = RAW(row+top_margin,col+left_margin);\n  }\n#endif\n  if (mask[0][3]) goto mask_set;\n  if (load_raw == &CLASS canon_load_raw ||\n      load_raw == &CLASS lossless_jpeg_load_raw) {\n    mask[0][1] = mask[1][1] = 2;\n    mask[0][3] = -2;\n    goto sides;\n  }\n  if (load_raw == &CLASS canon_600_load_raw ||\n      load_raw == &CLASS sony_load_raw ||\n     (load_raw == &CLASS eight_bit_load_raw && strncmp(model,\"DC2\",3)) ||\n      load_raw == &CLASS kodak_262_load_raw ||\n     (load_raw == &CLASS packed_load_raw && (load_flags & 32))) {\nsides:\n    mask[0][0] = mask[1][0] = top_margin;\n    mask[0][2] = mask[1][2] = top_margin+height;\n    mask[0][3] += left_margin;\n    mask[1][1] += left_margin+width;\n    mask[1][3] += raw_width;\n  }\n  if (load_raw == &CLASS nokia_load_raw) {\n    mask[0][2] = top_margin;\n    mask[0][3] = width;\n  }\nmask_set:\n  memset (mblack, 0, sizeof mblack);\n  for (zero=m=0; m < 8; m++)\n    for (row=mask[m][0]; row < mask[m][2]; row++)\n      for (col=mask[m][1]; col < mask[m][3]; col++) {\n\tc = FC(row-top_margin,col-left_margin);\n\tmblack[c] += val = raw_image[(row)*raw_pitch/2+(col)];\n\tmblack[4+c]++;\n\tzero += !val;\n      }\n  if (load_raw == &CLASS canon_600_load_raw && width < raw_width) {\n    black = (mblack[0]+mblack[1]+mblack[2]+mblack[3]) /\n\t    (mblack[4]+mblack[5]+mblack[6]+mblack[7]) - 4;\n#ifndef LIBRAW_LIBRARY_BUILD\n    canon_600_correct();\n#endif\n  } else if (zero < mblack[4] && mblack[5] && mblack[6] && mblack[7])\n    FORC4 cblack[c] = mblack[c] / mblack[4+c];\n}\n\nvoid CLASS remove_zeroes()\n{\n  unsigned row, col, tot, n, r, c;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES,0,2);\n#endif\n\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      if (BAYER(row,col) == 0) {\n\ttot = n = 0;\n\tfor (r = row-2; r <= row+2; r++)\n\t  for (c = col-2; c <= col+2; c++)\n\t    if (r < height && c < width &&\n\t\tFC(r,c) == FC(row,col) && BAYER(r,c))\n\t      tot += (n++,BAYER(r,c));\n\tif (n) BAYER(row,col) = tot/n;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES,1,2);\n#endif\n}\n#line 4111 \"dcraw/dcraw.c\"\nvoid CLASS gamma_curve (double pwr, double ts, int mode, int imax)\n{\n  int i;\n  double g[6], bnd[2]={0,0}, r;\n\n  g[0] = pwr;\n  g[1] = ts;\n  g[2] = g[3] = g[4] = 0;\n  bnd[g[1] >= 1] = 1;\n  if (g[1] && (g[1]-1)*(g[0]-1) <= 0) {\n    for (i=0; i < 48; i++) {\n      g[2] = (bnd[0] + bnd[1])/2;\n      if (g[0]) bnd[(pow(g[2]/g[1],-g[0]) - 1)/g[0] - 1/g[2] > -1] = g[2];\n      else\tbnd[g[2]/exp(1-1/g[2]) < g[1]] = g[2];\n    }\n    g[3] = g[2] / g[1];\n    if (g[0]) g[4] = g[2] * (1/g[0] - 1);\n  }\n  if (g[0]) g[5] = 1 / (g[1]*SQR(g[3])/2 - g[4]*(1 - g[3]) +\n\t\t(1 - pow(g[3],1+g[0]))*(1 + g[4])/(1 + g[0])) - 1;\n  else      g[5] = 1 / (g[1]*SQR(g[3])/2 + 1\n\t\t- g[2] - g[3] -\tg[2]*g[3]*(log(g[3]) - 1)) - 1;\n  if (!mode--) {\n    memcpy (gamm, g, sizeof gamm);\n    return;\n  }\n  for (i=0; i < 0x10000; i++) {\n    curve[i] = 0xffff;\n    if ((r = (double) i / imax) < 1)\n      curve[i] = 0x10000 * ( mode\n\t? (r < g[3] ? r*g[1] : (g[0] ? pow( r,g[0])*(1+g[4])-g[4]    : log(r)*g[2]+1))\n\t: (r < g[2] ? r/g[1] : (g[0] ? pow((r+g[4])/(1+g[4]),1/g[0]) : exp((r-1)/g[2]))));\n  }\n}\n\nvoid CLASS pseudoinverse (double (*in)[3], double (*out)[3], int size)\n{\n  double work[3][6], num;\n  int i, j, k;\n\n  for (i=0; i < 3; i++) {\n    for (j=0; j < 6; j++)\n      work[i][j] = j == i+3;\n    for (j=0; j < 3; j++)\n      for (k=0; k < size; k++)\n\twork[i][j] += in[k][i] * in[k][j];\n  }\n  for (i=0; i < 3; i++) {\n    num = work[i][i];\n    for (j=0; j < 6; j++)\n      work[i][j] /= num;\n    for (k=0; k < 3; k++) {\n      if (k==i) continue;\n      num = work[k][i];\n      for (j=0; j < 6; j++)\n\twork[k][j] -= work[i][j] * num;\n    }\n  }\n  for (i=0; i < size; i++)\n    for (j=0; j < 3; j++)\n      for (out[i][j]=k=0; k < 3; k++)\n\tout[i][j] += work[j][k+3] * in[i][k];\n}\n\nvoid CLASS cam_xyz_coeff (double cam_xyz[4][3])\n{\n  double cam_rgb[4][3], inverse[4][3], num;\n  int i, j, k;\n\n  for (i=0; i < colors; i++)\t\t/* Multiply out XYZ colorspace */\n    for (j=0; j < 3; j++)\n      for (cam_rgb[i][j] = k=0; k < 3; k++)\n\tcam_rgb[i][j] += cam_xyz[i][k] * xyz_rgb[k][j];\n\n  for (i=0; i < colors; i++) {\t\t/* Normalize cam_rgb so that */\n    for (num=j=0; j < 3; j++)\t\t/* cam_rgb * (1,1,1) is (1,1,1,1) */\n      num += cam_rgb[i][j];\n    for (j=0; j < 3; j++)\n      cam_rgb[i][j] /= num;\n    pre_mul[i] = 1 / num;\n  }\n  pseudoinverse (cam_rgb, inverse, colors);\n  for (raw_color = i=0; i < 3; i++)\n    for (j=0; j < colors; j++)\n      rgb_cam[i][j] = inverse[j][i];\n}\n\n#ifdef COLORCHECK\nvoid CLASS colorcheck()\n{\n#define NSQ 24\n// Coordinates of the GretagMacbeth ColorChecker squares\n// width, height, 1st_column, 1st_row\n  int cut[NSQ][4];\t\t\t// you must set these\n// ColorChecker Chart under 6500-kelvin illumination\n  static const double gmb_xyY[NSQ][3] = {\n    { 0.400, 0.350, 10.1 },\t\t// Dark Skin\n    { 0.377, 0.345, 35.8 },\t\t// Light Skin\n    { 0.247, 0.251, 19.3 },\t\t// Blue Sky\n    { 0.337, 0.422, 13.3 },\t\t// Foliage\n    { 0.265, 0.240, 24.3 },\t\t// Blue Flower\n    { 0.261, 0.343, 43.1 },\t\t// Bluish Green\n    { 0.506, 0.407, 30.1 },\t\t// Orange\n    { 0.211, 0.175, 12.0 },\t\t// Purplish Blue\n    { 0.453, 0.306, 19.8 },\t\t// Moderate Red\n    { 0.285, 0.202, 6.6 },\t\t// Purple\n    { 0.380, 0.489, 44.3 },\t\t// Yellow Green\n    { 0.473, 0.438, 43.1 },\t\t// Orange Yellow\n    { 0.187, 0.129, 6.1 },\t\t// Blue\n    { 0.305, 0.478, 23.4 },\t\t// Green\n    { 0.539, 0.313, 12.0 },\t\t// Red\n    { 0.448, 0.470, 59.1 },\t\t// Yellow\n    { 0.364, 0.233, 19.8 },\t\t// Magenta\n    { 0.196, 0.252, 19.8 },\t\t// Cyan\n    { 0.310, 0.316, 90.0 },\t\t// White\n    { 0.310, 0.316, 59.1 },\t\t// Neutral 8\n    { 0.310, 0.316, 36.2 },\t\t// Neutral 6.5\n    { 0.310, 0.316, 19.8 },\t\t// Neutral 5\n    { 0.310, 0.316, 9.0 },\t\t// Neutral 3.5\n    { 0.310, 0.316, 3.1 } };\t\t// Black\n  double gmb_cam[NSQ][4], gmb_xyz[NSQ][3];\n  double inverse[NSQ][3], cam_xyz[4][3], num;\n  int c, i, j, k, sq, row, col, count[4];\n\n  memset (gmb_cam, 0, sizeof gmb_cam);\n  for (sq=0; sq < NSQ; sq++) {\n    FORCC count[c] = 0;\n    for   (row=cut[sq][3]; row < cut[sq][3]+cut[sq][1]; row++)\n      for (col=cut[sq][2]; col < cut[sq][2]+cut[sq][0]; col++) {\n\tc = FC(row,col);\n\tif (c >= colors) c -= 2;\n\tgmb_cam[sq][c] += BAYER(row,col);\n\tcount[c]++;\n      }\n    FORCC gmb_cam[sq][c] = gmb_cam[sq][c]/count[c] - black;\n    gmb_xyz[sq][0] = gmb_xyY[sq][2] * gmb_xyY[sq][0] / gmb_xyY[sq][1];\n    gmb_xyz[sq][1] = gmb_xyY[sq][2];\n    gmb_xyz[sq][2] = gmb_xyY[sq][2] *\n\t\t(1 - gmb_xyY[sq][0] - gmb_xyY[sq][1]) / gmb_xyY[sq][1];\n  }\n  pseudoinverse (gmb_xyz, inverse, NSQ);\n  for (i=0; i < colors; i++)\n    for (j=0; j < 3; j++)\n      for (cam_xyz[i][j] = k=0; k < NSQ; k++)\n\tcam_xyz[i][j] += gmb_cam[k][i] * inverse[k][j];\n  cam_xyz_coeff (cam_xyz);\n  if (verbose) {\n    printf (\"    { \\\"%s %s\\\", %d,\\n\\t{\", make, model, black);\n    num = 10000 / (cam_xyz[1][0] + cam_xyz[1][1] + cam_xyz[1][2]);\n    FORCC for (j=0; j < 3; j++)\n      printf (\"%c%d\", (c | j) ? ',':' ', (int) (cam_xyz[c][j] * num + 0.5));\n    puts (\" } },\");\n  }\n#undef NSQ\n}\n#endif\n\nvoid CLASS hat_transform (float *temp, float *base, int st, int size, int sc)\n{\n  int i;\n  for (i=0; i < sc; i++)\n    temp[i] = 2*base[st*i] + base[st*(sc-i)] + base[st*(i+sc)];\n  for (; i+sc < size; i++)\n    temp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(i+sc)];\n  for (; i < size; i++)\n    temp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(2*size-2-(i+sc))];\n}\n\n#if !defined(LIBRAW_USE_OPENMP)\nvoid CLASS wavelet_denoise()\n{\n  float *fimg=0, *temp, thold, mul[2], avg, diff;\n  int scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];\n  ushort *window[4];\n  static const float noise[] =\n  { 0.8002,0.2735,0.1202,0.0585,0.0291,0.0152,0.0080,0.0044 };\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Wavelet denoising...\\n\"));\n#endif\n\n  while (maximum << scale < 0x10000) scale++;\n  maximum <<= --scale;\n  black <<= scale;\n  FORC4 cblack[c] <<= scale;\n  if ((size = iheight*iwidth) < 0x15550000)\n    fimg = (float *) malloc ((size*3 + iheight + iwidth) * sizeof *fimg);\n  merror (fimg, \"wavelet_denoise()\");\n  temp = fimg + size*3;\n  if ((nc = colors) == 3 && filters) nc++;\n  FORC(nc) {\t\t\t/* denoise R,G1,B,G3 individually */\n    for (i=0; i < size; i++)\n      fimg[i] = 256 * sqrt((double)(image[i][c] << scale));\n    for (hpass=lev=0; lev < 5; lev++) {\n      lpass = size*((lev & 1)+1);\n      for (row=0; row < iheight; row++) {\n\that_transform (temp, fimg+hpass+row*iwidth, 1, iwidth, 1 << lev);\n\tfor (col=0; col < iwidth; col++)\n\t  fimg[lpass + row*iwidth + col] = temp[col] * 0.25;\n      }\n      for (col=0; col < iwidth; col++) {\n\that_transform (temp, fimg+lpass+col, iwidth, iheight, 1 << lev);\n\tfor (row=0; row < iheight; row++)\n\t  fimg[lpass + row*iwidth + col] = temp[row] * 0.25;\n      }\n      thold = threshold * noise[lev];\n      for (i=0; i < size; i++) {\n\tfimg[hpass+i] -= fimg[lpass+i];\n\tif\t(fimg[hpass+i] < -thold) fimg[hpass+i] += thold;\n\telse if (fimg[hpass+i] >  thold) fimg[hpass+i] -= thold;\n\telse\t fimg[hpass+i] = 0;\n\tif (hpass) fimg[i] += fimg[hpass+i];\n      }\n      hpass = lpass;\n    }\n    for (i=0; i < size; i++)\n      image[i][c] = CLIP(SQR(fimg[i]+fimg[lpass+i])/0x10000);\n  }\n  if (filters && colors == 3) {  /* pull G1 and G3 closer together */\n    for (row=0; row < 2; row++) {\n      mul[row] = 0.125 * pre_mul[FC(row+1,0) | 1] / pre_mul[FC(row,0) | 1];\n      blk[row] = cblack[FC(row,0) | 1];\n    }\n    for (i=0; i < 4; i++)\n      window[i] = (ushort *) fimg + width*i;\n    for (wlast=-1, row=1; row < height-1; row++) {\n      while (wlast < row+1) {\n\tfor (wlast++, i=0; i < 4; i++)\n\t  window[(i+3) & 3] = window[i];\n\tfor (col = FC(wlast,1) & 1; col < width; col+=2)\n\t  window[2][col] = BAYER(wlast,col);\n      }\n      thold = threshold/512;\n      for (col = (FC(row,0) & 1)+1; col < width-1; col+=2) {\n\tavg = ( window[0][col-1] + window[0][col+1] +\n\t\twindow[2][col-1] + window[2][col+1] - blk[~row & 1]*4 )\n\t      * mul[row & 1] + (window[1][col] + blk[row & 1]) * 0.5;\n\tavg = avg < 0 ? 0 : sqrt(avg);\n\tdiff = sqrt((double)BAYER(row,col)) - avg;\n\tif      (diff < -thold) diff += thold;\n\telse if (diff >  thold) diff -= thold;\n\telse diff = 0;\n\tBAYER(row,col) = CLIP(SQR(avg+diff) + 0.5);\n      }\n    }\n  }\n  free (fimg);\n}\n#else /* LIBRAW_USE_OPENMP */\nvoid CLASS wavelet_denoise()\n{\n  float *fimg=0, *temp, thold, mul[2], avg, diff;\n   int scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];\n  ushort *window[4];\n  static const float noise[] =\n  { 0.8002,0.2735,0.1202,0.0585,0.0291,0.0152,0.0080,0.0044 };\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Wavelet denoising...\\n\"));\n#endif\n\n  while (maximum << scale < 0x10000) scale++;\n  maximum <<= --scale;\n  black <<= scale;\n  FORC4 cblack[c] <<= scale;\n  if ((size = iheight*iwidth) < 0x15550000)\n    fimg = (float *) malloc ((size*3 + iheight + iwidth) * sizeof *fimg);\n  merror (fimg, \"wavelet_denoise()\");\n  temp = fimg + size*3;\n  if ((nc = colors) == 3 && filters) nc++;\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp parallel default(shared) private(i,col,row,thold,lev,lpass,hpass,temp,c) firstprivate(scale,size) \n#endif\n  {\n      temp = (float*)malloc( (iheight + iwidth) * sizeof *fimg);\n    FORC(nc) {\t\t\t/* denoise R,G1,B,G3 individually */\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n      for (i=0; i < size; i++)\n        fimg[i] = 256 * sqrt((double)(image[i][c] << scale));\n      for (hpass=lev=0; lev < 5; lev++) {\n\tlpass = size*((lev & 1)+1);\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n\tfor (row=0; row < iheight; row++) {\n\t  hat_transform (temp, fimg+hpass+row*iwidth, 1, iwidth, 1 << lev);\n\t  for (col=0; col < iwidth; col++)\n\t    fimg[lpass + row*iwidth + col] = temp[col] * 0.25;\n\t}\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n\tfor (col=0; col < iwidth; col++) {\n\t  hat_transform (temp, fimg+lpass+col, iwidth, iheight, 1 << lev);\n\t  for (row=0; row < iheight; row++)\n\t    fimg[lpass + row*iwidth + col] = temp[row] * 0.25;\n\t}\n\tthold = threshold * noise[lev];\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n\tfor (i=0; i < size; i++) {\n\t  fimg[hpass+i] -= fimg[lpass+i];\n\t  if\t(fimg[hpass+i] < -thold) fimg[hpass+i] += thold;\n\t  else if (fimg[hpass+i] >  thold) fimg[hpass+i] -= thold;\n\t  else\t fimg[hpass+i] = 0;\n\t  if (hpass) fimg[i] += fimg[hpass+i];\n\t}\n\thpass = lpass;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n      for (i=0; i < size; i++)\n\timage[i][c] = CLIP(SQR(fimg[i]+fimg[lpass+i])/0x10000);\n    }\n    free(temp);\n  } /* end omp parallel */\n/* the following loops are hard to parallize, no idea yes,\n * problem is wlast which is carrying dependency\n * second part should be easyer, but did not yet get it right.\n */\n  if (filters && colors == 3) {  /* pull G1 and G3 closer together */\n   for (row=0; row < 2; row++){\n      mul[row] = 0.125 * pre_mul[FC(row+1,0) | 1] / pre_mul[FC(row,0) | 1];\n      blk[row] = cblack[FC(row,0) | 1];\n   }\n    for (i=0; i < 4; i++)\n      window[i] = (ushort *) fimg + width*i;\n    for (wlast=-1, row=1; row < height-1; row++) {\n      while (wlast < row+1) {\n\tfor (wlast++, i=0; i < 4; i++)\n\t  window[(i+3) & 3] = window[i];\n\tfor (col = FC(wlast,1) & 1; col < width; col+=2)\n\t  window[2][col] = BAYER(wlast,col);\n      }\n      thold = threshold/512;\n      for (col = (FC(row,0) & 1)+1; col < width-1; col+=2) {\n\tavg = ( window[0][col-1] + window[0][col+1] +\n\t\twindow[2][col-1] + window[2][col+1] - blk[~row & 1]*4 )\n\t      * mul[row & 1] + (window[1][col] + blk[row & 1]) * 0.5;\n\tavg = avg < 0 ? 0 : sqrt(avg);\n\tdiff = sqrt((double)BAYER(row,col)) - avg;\n\tif      (diff < -thold) diff += thold;\n\telse if (diff >  thold) diff -= thold;\n\telse diff = 0;\n\tBAYER(row,col) = CLIP(SQR(avg+diff) + 0.5);\n      }\n    }\n  }\n  free (fimg);\n}\n\n#endif\n\n// green equilibration\nvoid CLASS green_matching()\n{\n  int i,j;\n  double m1,m2,c1,c2;\n  int o1_1,o1_2,o1_3,o1_4;\n  int o2_1,o2_2,o2_3,o2_4;\n  ushort (*img)[4];\n  const int margin = 3;\n  int oj = 2, oi = 2;\n  float f;\n  const float thr = 0.01f;\n  if(half_size || shrink) return;\n  if(FC(oj, oi) != 3) oj++;\n  if(FC(oj, oi) != 3) oi++;\n  if(FC(oj, oi) != 3) oj--;\n\n  img = (ushort (*)[4]) calloc (height*width, sizeof *image);\n  merror (img, \"green_matching()\");\n  memcpy(img,image,height*width*sizeof *image);\n\n  for(j=oj;j<height-margin;j+=2)\n    for(i=oi;i<width-margin;i+=2){\n      o1_1=img[(j-1)*width+i-1][1];\n      o1_2=img[(j-1)*width+i+1][1];\n      o1_3=img[(j+1)*width+i-1][1];\n      o1_4=img[(j+1)*width+i+1][1];\n      o2_1=img[(j-2)*width+i][3];\n      o2_2=img[(j+2)*width+i][3];\n      o2_3=img[j*width+i-2][3];\n      o2_4=img[j*width+i+2][3];\n\n      m1=(o1_1+o1_2+o1_3+o1_4)/4.0;\n      m2=(o2_1+o2_2+o2_3+o2_4)/4.0;\n\n      c1=(abs(o1_1-o1_2)+abs(o1_1-o1_3)+abs(o1_1-o1_4)+abs(o1_2-o1_3)+abs(o1_3-o1_4)+abs(o1_2-o1_4))/6.0;\n      c2=(abs(o2_1-o2_2)+abs(o2_1-o2_3)+abs(o2_1-o2_4)+abs(o2_2-o2_3)+abs(o2_3-o2_4)+abs(o2_2-o2_4))/6.0;\n      if((img[j*width+i][3]<maximum*0.95)&&(c1<maximum*thr)&&(c2<maximum*thr))\n      {\n        f = image[j*width+i][3]*m1/m2;\n        image[j*width+i][3]=f>0xffff?0xffff:f;\n      }\n    }\n  free(img);\n}\n\nvoid CLASS scale_colors()\n{\n  unsigned bottom, right, size, row, col, ur, uc, i, x, y, c, sum[8];\n  int val, dark, sat;\n  double dsum[8], dmin, dmax;\n  float scale_mul[4], fr, fc;\n  ushort *img=0, *pix;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS,0,2);\n#endif\n\n  if (user_mul[0])\n    memcpy (pre_mul, user_mul, sizeof pre_mul);\n  if (use_auto_wb || (use_camera_wb && cam_mul[0] == -1)) {\n    memset (dsum, 0, sizeof dsum);\n    bottom = MIN (greybox[1]+greybox[3], height);\n    right  = MIN (greybox[0]+greybox[2], width);\n    for (row=greybox[1]; row < bottom; row += 8)\n      for (col=greybox[0]; col < right; col += 8) {\n\tmemset (sum, 0, sizeof sum);\n\tfor (y=row; y < row+8 && y < bottom; y++)\n\t  for (x=col; x < col+8 && x < right; x++)\n\t    FORC4 {\n\t      if (filters) {\n\t\tc = fcol(y,x);\n\t\tval = BAYER2(y,x);\n\t      } else\n\t\tval = image[y*width+x][c];\n\t      if (val > maximum-25) goto skip_block;\n\t      if ((val -= cblack[c]) < 0) val = 0;\n\t      sum[c] += val;\n\t      sum[c+4]++;\n\t      if (filters) break;\n\t    }\n\tFORC(8) dsum[c] += sum[c];\nskip_block: ;\n      }\n    FORC4 if (dsum[c]) pre_mul[c] = dsum[c+4] / dsum[c];\n  }\n  if (use_camera_wb && cam_mul[0] != -1) {\n    memset (sum, 0, sizeof sum);\n    for (row=0; row < 8; row++)\n      for (col=0; col < 8; col++) {\n\tc = FC(row,col);\n\tif ((val = white[row][col] - cblack[c]) > 0)\n\t  sum[c] += val;\n\tsum[c+4]++;\n      }\n    if (sum[0] && sum[1] && sum[2] && sum[3])\n      FORC4 pre_mul[c] = (float) sum[c+4] / sum[c];\n    else if (cam_mul[0] && cam_mul[2])\n      memcpy (pre_mul, cam_mul, sizeof pre_mul);\n    else\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n            imgdata.process_warnings |= LIBRAW_WARN_BAD_CAMERA_WB;\n#endif\n#ifdef DCRAW_VERBOSE\n            fprintf (stderr,_(\"%s: Cannot use camera white balance.\\n\"), ifname);\n#endif\n      }\n  }\n  if (pre_mul[3] == 0) pre_mul[3] = colors < 4 ? pre_mul[1] : 1;\n  dark = black;\n  sat = maximum;\n  if (threshold) wavelet_denoise();\n  maximum -= black;\n  for (dmin=DBL_MAX, dmax=c=0; c < 4; c++) {\n    if (dmin > pre_mul[c])\n\tdmin = pre_mul[c];\n    if (dmax < pre_mul[c])\n\tdmax = pre_mul[c];\n  }\n  if (!highlight) dmax = dmin;\n  FORC4 scale_mul[c] = (pre_mul[c] /= dmax) * 65535.0 / maximum;\n#ifdef DCRAW_VERBOSE\n  if (verbose) {\n    fprintf (stderr,\n      _(\"Scaling with darkness %d, saturation %d, and\\nmultipliers\"), dark, sat);\n    FORC4 fprintf (stderr, \" %f\", pre_mul[c]);\n    fputc ('\\n', stderr);\n  }\n#endif\n  size = iheight*iwidth;\n#ifdef LIBRAW_LIBRARY_BUILD\n  scale_colors_loop(scale_mul);\n#else\n  for (i=0; i < size*4; i++) {\n    val = image[0][i];\n    if (!val) continue;\n    val -= cblack[i & 3];\n    val *= scale_mul[i & 3];\n    image[0][i] = CLIP(val);\n  }\n#endif\n  if ((aber[0] != 1 || aber[2] != 1) && colors == 3) {\n#ifdef DCRAW_VERBOSE\n    if (verbose)\n      fprintf (stderr,_(\"Correcting chromatic aberration...\\n\"));\n#endif\n    for (c=0; c < 4; c+=2) {\n      if (aber[c] == 1) continue;\n      img = (ushort *) malloc (size * sizeof *img);\n      merror (img, \"scale_colors()\");\n      for (i=0; i < size; i++)\n\timg[i] = image[i][c];\n      for (row=0; row < iheight; row++) {\n\tur = fr = (row - iheight*0.5) * aber[c] + iheight*0.5;\n\tif (ur > iheight-2) continue;\n\tfr -= ur;\n\tfor (col=0; col < iwidth; col++) {\n\t  uc = fc = (col - iwidth*0.5) * aber[c] + iwidth*0.5;\n\t  if (uc > iwidth-2) continue;\n\t  fc -= uc;\n\t  pix = img + ur*iwidth + uc;\n\t  image[row*iwidth+col][c] =\n\t    (pix[     0]*(1-fc) + pix[       1]*fc) * (1-fr) +\n\t    (pix[iwidth]*(1-fc) + pix[iwidth+1]*fc) * fr;\n\t}\n      }\n      free(img);\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS,1,2);\n#endif\n}\n\nvoid CLASS pre_interpolate()\n{\n  ushort (*img)[4];\n  int row, col, c;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE,0,2);\n#endif\n  if (shrink) {\n    if (half_size) {\n      height = iheight;\n      width  = iwidth;\n    } else {\n      img = (ushort (*)[4]) calloc (height*width, sizeof *img);\n      merror (img, \"pre_interpolate()\");\n      for (row=0; row < height; row++)\n\tfor (col=0; col < width; col++) {\n\t  c = fcol(row,col);\n\t  img[row*width+col][c] = image[(row >> 1)*iwidth+(col >> 1)][c];\n\t}\n      free (image);\n      image = img;\n      shrink = 0;\n    }\n  }\n  if (filters > 1000 && colors == 3) {\n    if (four_color_rgb && colors++)\n      mix_green = !half_size;\n    else {\n      for (row = FC(1,0) >> 1; row < height; row+=2)\n\tfor (col = FC(row,1) & 1; col < width; col+=2)\n\t  image[row*width+col][1] = image[row*width+col][3];\n      filters &= ~((filters & 0x55555555) << 1);\n    }\n  }\n  if (half_size) filters = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE,1,2);\n#endif\n}\n\nvoid CLASS border_interpolate (int border)\n{\n  unsigned row, col, y, x, f, c, sum[8];\n\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++) {\n      if (col==border && row >= border && row < height-border)\n\tcol = width-border;\n      memset (sum, 0, sizeof sum);\n      for (y=row-1; y != row+2; y++)\n\tfor (x=col-1; x != col+2; x++)\n\t  if (y < height && x < width) {\n\t    f = fcol(y,x);\n\t    sum[f] += image[y*width+x][f];\n\t    sum[f+4]++;\n\t  }\n      f = fcol(row,col);\n      FORCC if (c != f && sum[c+4])\n\timage[row*width+col][c] = sum[c] / sum[c+4];\n    }\n}\n\nvoid CLASS lin_interpolate_loop(int code[16][16][32],int size)\n{\n  int row;\n  for (row=1; row < height-1; row++)\n    {\n      int col,*ip;\n      ushort *pix;\n      for (col=1; col < width-1; col++) {\n        int i;\n        int sum[4];\n        pix = image[row*width+col];\n        ip = code[row % size][col % size];\n        memset (sum, 0, sizeof sum);\n        for (i=*ip++; i--; ip+=3)\n          sum[ip[2]] += pix[ip[0]] << ip[1];\n        for (i=colors; --i; ip+=2)\n          pix[ip[0]] = sum[ip[0]] * ip[1] >> 8;\n      }\n    }\n}\n\nvoid CLASS lin_interpolate()\n{\n  int code[16][16][32], size=16, *ip, sum[4];\n  int f, c, x, y, row, col, shift, color;\n\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Bilinear interpolation...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,0,3);\n#endif\n\n  if (filters == 2) size = 6;\n  border_interpolate(1);\n  for (row=0; row < size; row++)\n    for (col=0; col < size; col++) {\n      ip = code[row][col]+1;\n      f = fcol(row,col);\n      memset (sum, 0, sizeof sum);\n      for (y=-1; y <= 1; y++)\n\tfor (x=-1; x <= 1; x++) {\n\t  shift = (y==0) + (x==0);\n\t  color = fcol(row+y,col+x);\n\t  if (color == f) continue;\n\t  *ip++ = (width*y + x)*4 + color;\n\t  *ip++ = shift;\n\t  *ip++ = color;\n\t  sum[color] += 1 << shift;\n\t}\n      code[row][col][0] = (ip - code[row][col]) / 3;\n      FORCC\n\tif (c != f) {\n\t  *ip++ = c;\n\t  *ip++ = 256 / sum[c];\n\t}\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,1,3);\n#endif\n  lin_interpolate_loop(code,size);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,2,3);\n#endif\n}\n\n/*\n   This algorithm is officially called:\n\n   \"Interpolation using a Threshold-based variable number of gradients\"\n\n   described in http://scien.stanford.edu/pages/labsite/1999/psych221/projects/99/tingchen/algodep/vargra.html\n\n   I've extended the basic idea to work with non-Bayer filter arrays.\n   Gradients are numbered clockwise from NW=0 to W=7.\n */\nvoid CLASS vng_interpolate()\n{\n  static const signed char *cp, terms[] = {\n    -2,-2,+0,-1,0,0x01, -2,-2,+0,+0,1,0x01, -2,-1,-1,+0,0,0x01,\n    -2,-1,+0,-1,0,0x02, -2,-1,+0,+0,0,0x03, -2,-1,+0,+1,1,0x01,\n    -2,+0,+0,-1,0,0x06, -2,+0,+0,+0,1,0x02, -2,+0,+0,+1,0,0x03,\n    -2,+1,-1,+0,0,0x04, -2,+1,+0,-1,1,0x04, -2,+1,+0,+0,0,0x06,\n    -2,+1,+0,+1,0,0x02, -2,+2,+0,+0,1,0x04, -2,+2,+0,+1,0,0x04,\n    -1,-2,-1,+0,0,0x80, -1,-2,+0,-1,0,0x01, -1,-2,+1,-1,0,0x01,\n    -1,-2,+1,+0,1,0x01, -1,-1,-1,+1,0,0x88, -1,-1,+1,-2,0,0x40,\n    -1,-1,+1,-1,0,0x22, -1,-1,+1,+0,0,0x33, -1,-1,+1,+1,1,0x11,\n    -1,+0,-1,+2,0,0x08, -1,+0,+0,-1,0,0x44, -1,+0,+0,+1,0,0x11,\n    -1,+0,+1,-2,1,0x40, -1,+0,+1,-1,0,0x66, -1,+0,+1,+0,1,0x22,\n    -1,+0,+1,+1,0,0x33, -1,+0,+1,+2,1,0x10, -1,+1,+1,-1,1,0x44,\n    -1,+1,+1,+0,0,0x66, -1,+1,+1,+1,0,0x22, -1,+1,+1,+2,0,0x10,\n    -1,+2,+0,+1,0,0x04, -1,+2,+1,+0,1,0x04, -1,+2,+1,+1,0,0x04,\n    +0,-2,+0,+0,1,0x80, +0,-1,+0,+1,1,0x88, +0,-1,+1,-2,0,0x40,\n    +0,-1,+1,+0,0,0x11, +0,-1,+2,-2,0,0x40, +0,-1,+2,-1,0,0x20,\n    +0,-1,+2,+0,0,0x30, +0,-1,+2,+1,1,0x10, +0,+0,+0,+2,1,0x08,\n    +0,+0,+2,-2,1,0x40, +0,+0,+2,-1,0,0x60, +0,+0,+2,+0,1,0x20,\n    +0,+0,+2,+1,0,0x30, +0,+0,+2,+2,1,0x10, +0,+1,+1,+0,0,0x44,\n    +0,+1,+1,+2,0,0x10, +0,+1,+2,-1,1,0x40, +0,+1,+2,+0,0,0x60,\n    +0,+1,+2,+1,0,0x20, +0,+1,+2,+2,0,0x10, +1,-2,+1,+0,0,0x80,\n    +1,-1,+1,+1,0,0x88, +1,+0,+1,+2,0,0x08, +1,+0,+2,-1,0,0x40,\n    +1,+0,+2,+1,0,0x10\n  }, chood[] = { -1,-1, -1,0, -1,+1, 0,+1, +1,+1, +1,0, +1,-1, 0,-1 };\n  ushort (*brow[5])[4], *pix;\n  int prow=8, pcol=2, *ip, *code[16][16], gval[8], gmin, gmax, sum[4];\n  int row, col, x, y, x1, x2, y1, y2, t, weight, grads, color, diag;\n  int g, diff, thold, num, c;\n\n  lin_interpolate();\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"VNG interpolation...\\n\"));\n#endif\n\n  if (filters == 1) prow = pcol = 16;\n  if (filters == 2) prow = pcol =  6;\n  ip = (int *) calloc (prow*pcol, 1280);\n  merror (ip, \"vng_interpolate()\");\n  for (row=0; row < prow; row++)\t\t/* Precalculate for VNG */\n    for (col=0; col < pcol; col++) {\n      code[row][col] = ip;\n      for (cp=terms, t=0; t < 64; t++) {\n\ty1 = *cp++;  x1 = *cp++;\n\ty2 = *cp++;  x2 = *cp++;\n\tweight = *cp++;\n\tgrads = *cp++;\n\tcolor = fcol(row+y1,col+x1);\n\tif (fcol(row+y2,col+x2) != color) continue;\n\tdiag = (fcol(row,col+1) == color && fcol(row+1,col) == color) ? 2:1;\n\tif (abs(y1-y2) == diag && abs(x1-x2) == diag) continue;\n\t*ip++ = (y1*width + x1)*4 + color;\n\t*ip++ = (y2*width + x2)*4 + color;\n\t*ip++ = weight;\n\tfor (g=0; g < 8; g++)\n\t  if (grads & 1<<g) *ip++ = g;\n\t*ip++ = -1;\n      }\n      *ip++ = INT_MAX;\n      for (cp=chood, g=0; g < 8; g++) {\n\ty = *cp++;  x = *cp++;\n\t*ip++ = (y*width + x) * 4;\n\tcolor = fcol(row,col);\n\tif (fcol(row+y,col+x) != color && fcol(row+y*2,col+x*2) == color)\n\t  *ip++ = (y*width + x) * 8 + color;\n\telse\n\t  *ip++ = 0;\n      }\n    }\n  brow[4] = (ushort (*)[4]) calloc (width*3, sizeof **brow);\n  merror (brow[4], \"vng_interpolate()\");\n  for (row=0; row < 3; row++)\n    brow[row] = brow[4] + row*width;\n  for (row=2; row < height-2; row++) {\t\t/* Do VNG interpolation */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if(!((row-2)%256))RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,(row-2)/256+1,((height-3)/256)+1);\n#endif\n    for (col=2; col < width-2; col++) {\n      pix = image[row*width+col];\n      ip = code[row % prow][col % pcol];\n      memset (gval, 0, sizeof gval);\n      while ((g = ip[0]) != INT_MAX) {\t\t/* Calculate gradients */\n\tdiff = ABS(pix[g] - pix[ip[1]]) << ip[2];\n\tgval[ip[3]] += diff;\n\tip += 5;\n\tif ((g = ip[-1]) == -1) continue;\n\tgval[g] += diff;\n\twhile ((g = *ip++) != -1)\n\t  gval[g] += diff;\n      }\n      ip++;\n      gmin = gmax = gval[0];\t\t\t/* Choose a threshold */\n      for (g=1; g < 8; g++) {\n\tif (gmin > gval[g]) gmin = gval[g];\n\tif (gmax < gval[g]) gmax = gval[g];\n      }\n      if (gmax == 0) {\n\tmemcpy (brow[2][col], pix, sizeof *image);\n\tcontinue;\n      }\n      thold = gmin + (gmax >> 1);\n      memset (sum, 0, sizeof sum);\n      color = fcol(row,col);\n      for (num=g=0; g < 8; g++,ip+=2) {\t\t/* Average the neighbors */\n\tif (gval[g] <= thold) {\n\t  FORCC\n\t    if (c == color && ip[1])\n\t      sum[c] += (pix[c] + pix[ip[1]]) >> 1;\n\t    else\n\t      sum[c] += pix[ip[0] + c];\n\t  num++;\n\t}\n      }\n      FORCC {\t\t\t\t\t/* Save to buffer */\n\tt = pix[color];\n\tif (c != color)\n\t  t += (sum[c] - sum[color]) / num;\n\tbrow[2][col][c] = CLIP(t);\n      }\n    }\n    if (row > 3)\t\t\t\t/* Write buffer to image */\n      memcpy (image[(row-2)*width+2], brow[0]+2, (width-4)*sizeof *image);\n    for (g=0; g < 4; g++)\n      brow[(g-1) & 3] = brow[g];\n  }\n  memcpy (image[(row-2)*width+2], brow[0]+2, (width-4)*sizeof *image);\n  memcpy (image[(row-1)*width+2], brow[1]+2, (width-4)*sizeof *image);\n  free (brow[4]);\n  free (code[0][0]);\n}\n\n/*\n   Patterned Pixel Grouping Interpolation by Alain Desbiolles\n*/\nvoid CLASS ppg_interpolate()\n{\n  int dir[5] = { 1, width, -1, -width, 1 };\n  int row, col, diff[2], guess[2], c, d, i;\n  ushort (*pix)[4];\n\n  border_interpolate(3);\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"PPG interpolation...\\n\"));\n#endif\n\n/*  Fill in the green layer with gradients and pattern recognition: */\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,0,3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row=3; row < height-3; row++)\n    for (col=3+(FC(row,3) & 1), c=FC(row,col); col < width-3; col+=2) {\n      pix = image + row*width+col;\n      for (i=0; (d=dir[i]) > 0; i++) {\n\tguess[i] = (pix[-d][1] + pix[0][c] + pix[d][1]) * 2\n\t\t      - pix[-2*d][c] - pix[2*d][c];\n\tdiff[i] = ( ABS(pix[-2*d][c] - pix[ 0][c]) +\n\t\t    ABS(pix[ 2*d][c] - pix[ 0][c]) +\n\t\t    ABS(pix[  -d][1] - pix[ d][1]) ) * 3 +\n\t\t  ( ABS(pix[ 3*d][1] - pix[ d][1]) +\n\t\t    ABS(pix[-3*d][1] - pix[-d][1]) ) * 2;\n      }\n      d = dir[i = diff[0] > diff[1]];\n      pix[0][1] = ULIM(guess[i] >> 2, pix[d][1], pix[-d][1]);\n    }\n/*  Calculate red and blue for each green pixel:\t\t*/\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,1,3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row=1; row < height-1; row++)\n    for (col=1+(FC(row,2) & 1), c=FC(row,col+1); col < width-1; col+=2) {\n      pix = image + row*width+col;\n      for (i=0; (d=dir[i]) > 0; c=2-c, i++)\n\tpix[0][c] = CLIP((pix[-d][c] + pix[d][c] + 2*pix[0][1]\n\t\t\t- pix[-d][1] - pix[d][1]) >> 1);\n    }\n/*  Calculate blue for red pixels and vice versa:\t\t*/\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,2,3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row=1; row < height-1; row++)\n    for (col=1+(FC(row,1) & 1), c=2-FC(row,col); col < width-1; col+=2) {\n      pix = image + row*width+col;\n      for (i=0; (d=dir[i]+dir[i+1]) > 0; i++) {\n\tdiff[i] = ABS(pix[-d][c] - pix[d][c]) +\n\t\t  ABS(pix[-d][1] - pix[0][1]) +\n\t\t  ABS(pix[ d][1] - pix[0][1]);\n\tguess[i] = pix[-d][c] + pix[d][c] + 2*pix[0][1]\n\t\t - pix[-d][1] - pix[d][1];\n      }\n      if (diff[0] != diff[1])\n\tpix[0][c] = CLIP(guess[diff[0] > diff[1]] >> 1);\n      else\n\tpix[0][c] = CLIP((guess[0]+guess[1]) >> 2);\n    }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n/*\n   Adaptive Homogeneity-Directed interpolation is based on\n   the work of Keigo Hirakawa, Thomas Parks, and Paul Lee.\n */\n#define TS 256\t\t/* Tile Size */\nstatic float dcraw_cbrt[0x10000] = {-1.0f};\n\nstatic inline float calc_64cbrt(float f)\n{\n  unsigned u;\n  static float lower = dcraw_cbrt[0];\n  static float upper = dcraw_cbrt[0xffff];\n\n  if (f <= 0) {\n    return lower;\n  }\n\n  u = (unsigned) f;\n  if (u >= 0xffff) {\n    return upper;\n  }\n  return dcraw_cbrt[u];\n}\nvoid CLASS ahd_interpolate_green_h_and_v(int top, int left, ushort (*out_rgb)[TS][TS][3])\n{\n  int row, col;\n  int c, val;\n  ushort (*pix)[4];\n  const int rowlimit = MIN(top+TS, height-2);\n  const int collimit = MIN(left+TS, width-2);\n\n  for (row = top; row < rowlimit; row++) {\n    col = left + (FC(row,left) & 1);\n    for (c = FC(row,col); col < collimit; col+=2) {\n      pix = image + row*width+col;\n      val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2\n            - pix[-2][c] - pix[2][c]) >> 2;\n      out_rgb[0][row-top][col-left][1] = ULIM(val,pix[-1][1],pix[1][1]);\n      val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2\n            - pix[-2*width][c] - pix[2*width][c]) >> 2;\n      out_rgb[1][row-top][col-left][1] = ULIM(val,pix[-width][1],pix[width][1]);\n    }\n  }\n}\nvoid CLASS ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][3], short (*out_lab)[TS][3], const float (&xyz_cam)[3][4])\n{\n  unsigned row, col;\n  int c, val;\n  ushort (*pix)[4];\n  ushort (*rix)[3];\n  short (*lix)[3];\n  float xyz[3];\n  const unsigned num_pix_per_row = 4*width;\n  const unsigned rowlimit = MIN(top+TS-1, height-3);\n  const unsigned collimit = MIN(left+TS-1, width-3);\n  ushort *pix_above;\n  ushort *pix_below;\n  int t1, t2;\n\n  for (row = top+1; row < rowlimit; row++) {\n    pix = image + row*width + left;\n    rix = &inout_rgb[row-top][0];\n    lix = &out_lab[row-top][0];\n\n    for (col = left+1; col < collimit; col++) {\n      pix++;\n      pix_above = &pix[0][0] - num_pix_per_row;\n      pix_below = &pix[0][0] + num_pix_per_row;\n      rix++;\n      lix++;\n\n      c = 2 - FC(row, col);\n\n      if (c == 1) {\n        c = FC(row+1,col);\n\tt1 = 2-c;\n        val = pix[0][1] + (( pix[-1][t1] + pix[1][t1]\n              - rix[-1][1] - rix[1][1] ) >> 1);\n        rix[0][t1] = CLIP(val);\n        val = pix[0][1] + (( pix_above[c] + pix_below[c]\n              - rix[-TS][1] - rix[TS][1] ) >> 1);\n      } else {\n\tt1 = -4+c; /* -4+c: pixel of color c to the left */\n\tt2 = 4+c; /* 4+c: pixel of color c to the right */\n        val = rix[0][1] + (( pix_above[t1] + pix_above[t2]\n              + pix_below[t1] + pix_below[t2]\n              - rix[-TS-1][1] - rix[-TS+1][1]\n              - rix[+TS-1][1] - rix[+TS+1][1] + 1) >> 2);\n      }\n      rix[0][c] = CLIP(val);\n      c = FC(row,col);\n      rix[0][c] = pix[0][c];\n      xyz[0] = xyz[1] = xyz[2] = 0.5;\n      FORC3 {\n\t/*\n\t * Technically this ought to be FORCC, but the rest of\n\t * ahd_interpolate() assumes 3 colors so let's help the compiler.\n\t */\n        xyz[0] += xyz_cam[0][c] * rix[0][c];\n        xyz[1] += xyz_cam[1][c] * rix[0][c];\n        xyz[2] += xyz_cam[2][c] * rix[0][c];\n      }\n      FORC3 {\n\txyz[c] = calc_64cbrt(xyz[c]);\n      }\n      lix[0][0] = (116 * xyz[1] - 16);\n      lix[0][1] = 500 * (xyz[0] - xyz[1]);\n      lix[0][2] = 200 * (xyz[1] - xyz[2]);\n    }\n  }\n}\nvoid CLASS ahd_interpolate_r_and_b_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][TS][3], short (*out_lab)[TS][TS][3], const float (&xyz_cam)[3][4])\n{\n  int direction;\n  for (direction = 0; direction < 2; direction++) {\n    ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(top, left, inout_rgb[direction], out_lab[direction], xyz_cam);\n  }\n}\nvoid CLASS ahd_interpolate_build_homogeneity_map(int top, int left, short (*lab)[TS][TS][3], char (*out_homogeneity_map)[TS][2])\n{\n  int row, col;\n  int tr, tc;\n  int direction;\n  int i;\n  short (*lix)[3];\n  short (*lixs[2])[3];\n  short *adjacent_lix;\n  unsigned ldiff[2][4], abdiff[2][4], leps, abeps;\n  static const int dir[4] = { -1, 1, -TS, TS };\n  const int rowlimit = MIN(top+TS-2, height-4);\n  const int collimit = MIN(left+TS-2, width-4);\n  int homogeneity;\n  char (*homogeneity_map_p)[2];\n\n  memset (out_homogeneity_map, 0, 2*TS*TS);\n\n  for (row=top+2; row < rowlimit; row++) {\n    tr = row-top;\n    homogeneity_map_p = &out_homogeneity_map[tr][1];\n    for (direction=0; direction < 2; direction++) {\n      lixs[direction] = &lab[direction][tr][1];\n    }\n\n    for (col=left+2; col < collimit; col++) {\n      tc = col-left;\n      homogeneity_map_p++;\n\n      for (direction=0; direction < 2; direction++) {\n        lix = ++lixs[direction];\n        for (i=0; i < 4; i++) {\n\t  adjacent_lix = lix[dir[i]];\n          ldiff[direction][i] = ABS(lix[0][0]-adjacent_lix[0]);\n          abdiff[direction][i] = SQR(lix[0][1]-adjacent_lix[1])\n            + SQR(lix[0][2]-adjacent_lix[2]);\n        }\n      }\n      leps = MIN(MAX(ldiff[0][0],ldiff[0][1]),\n          MAX(ldiff[1][2],ldiff[1][3]));\n      abeps = MIN(MAX(abdiff[0][0],abdiff[0][1]),\n          MAX(abdiff[1][2],abdiff[1][3]));\n      for (direction=0; direction < 2; direction++) {\n\thomogeneity = 0;\n        for (i=0; i < 4; i++) {\n          if (ldiff[direction][i] <= leps && abdiff[direction][i] <= abeps) {\n\t    homogeneity++;\n\t  }\n\t}\n\thomogeneity_map_p[0][direction] = homogeneity;\n      }\n    }\n  }\n}\nvoid CLASS ahd_interpolate_combine_homogeneous_pixels(int top, int left, ushort (*rgb)[TS][TS][3], char (*homogeneity_map)[TS][2])\n{\n  int row, col;\n  int tr, tc;\n  int i, j;\n  int direction;\n  int hm[2];\n  int c;\n  const int rowlimit = MIN(top+TS-3, height-5);\n  const int collimit = MIN(left+TS-3, width-5);\n\n  ushort (*pix)[4];\n  ushort (*rix[2])[3];\n\n  for (row=top+3; row < rowlimit; row++) {\n    tr = row-top;\n    pix = &image[row*width+left+2];\n    for (direction = 0; direction < 2; direction++) {\n      rix[direction] = &rgb[direction][tr][2];\n    }\n\n    for (col=left+3; col < collimit; col++) {\n      tc = col-left;\n      pix++;\n      for (direction = 0; direction < 2; direction++) {\n        rix[direction]++;\n      }\n\n      for (direction=0; direction < 2; direction++) {\n        hm[direction] = 0;\n        for (i=tr-1; i <= tr+1; i++) {\n          for (j=tc-1; j <= tc+1; j++) {\n            hm[direction] += homogeneity_map[i][j][direction];\n          }\n        }\n      }\n      if (hm[0] != hm[1]) {\n        memcpy(pix[0], rix[hm[1] > hm[0]][0], 3 * sizeof(ushort));\n      } else {\n        FORC3 {\n          pix[0][c] = (rix[0][0][c] + rix[1][0][c]) >> 1;\n        }\n      }\n    }\n  }\n}\nvoid CLASS ahd_interpolate()\n{\n  int i, j, k, top, left;\n  float xyz_cam[3][4],r;\n  char *buffer;\n  ushort (*rgb)[TS][TS][3];\n  short (*lab)[TS][TS][3];\n  char (*homo)[TS][2];\n  int terminate_flag = 0;\n\n  if(dcraw_cbrt[0]<-0.1){\n      for (i=0x10000-1; i >=0; i--) {\n          r = i / 65535.0;\n          dcraw_cbrt[i] = 64.0*(r > 0.008856 ? pow((double)r,1/3.0) : 7.787*r + 16/116.0);\n      }\n  }\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"AHD interpolation...\\n\"));\n#endif\n\n  for (i=0; i < 3; i++) {\n    for (j=0; j < colors; j++) {\n      xyz_cam[i][j] = 0;\n      for (k=0; k < 3; k++) {\n        xyz_cam[i][j] += xyz_rgb[i][k] * rgb_cam[k][j] / d65_white[i];\n      }\n    }\n  }\n\n  border_interpolate(5);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel private(buffer,rgb,lab,homo,top,left,i,j,k) shared(xyz_cam,terminate_flag)\n#endif\n#endif\n  {\n    buffer = (char *) malloc (26*TS*TS);\t\t/* 1664 kB */\n    merror (buffer, \"ahd_interpolate()\");\n    rgb  = (ushort(*)[TS][TS][3]) buffer;\n    lab  = (short (*)[TS][TS][3])(buffer + 12*TS*TS);\n    homo = (char  (*)[TS][2])    (buffer + 24*TS*TS);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp for schedule(dynamic)\n#endif\n#endif\n    for (top=2; top < height-5; top += TS-6){\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n        if(0== omp_get_thread_num())\n#endif\n           if(callbacks.progress_cb) {                                     \n               int rr = (*callbacks.progress_cb)(callbacks.progresscb_data,LIBRAW_PROGRESS_INTERPOLATE,top-2,height-7);\n               if(rr)\n                   terminate_flag = 1;\n           }\n#endif\n        for (left=2; !terminate_flag && (left < width-5); left += TS-6) {\n            ahd_interpolate_green_h_and_v(top, left, rgb);\n            ahd_interpolate_r_and_b_and_convert_to_cielab(top, left, rgb, lab, xyz_cam);\n            ahd_interpolate_build_homogeneity_map(top, left, lab, homo);\n            ahd_interpolate_combine_homogeneous_pixels(top, left, rgb, homo);\n      }\n    }\n    free (buffer);\n  }\n#ifdef LIBRAW_LIBRARY_BUILD \n  if(terminate_flag)\n      throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#endif\n}\n\n\n\n#undef TS\n\n#else\n/*\n   Adaptive Homogeneity-Directed interpolation is based on\n   the work of Keigo Hirakawa, Thomas Parks, and Paul Lee.\n */\n#define TS 256\t\t/* Tile Size */\n\nvoid CLASS ahd_interpolate()\n{\n  int i, j, k, top, left, row, col, tr, tc, c, d, val, hm[2];\n  ushort (*pix)[4], (*rix)[3];\n  static const int dir[4] = { -1, 1, -TS, TS };\n  unsigned ldiff[2][4], abdiff[2][4], leps, abeps;\n  float r, cbrt[0x10000], xyz[3], xyz_cam[3][4];\n  ushort (*rgb)[TS][TS][3];\n   short (*lab)[TS][TS][3], (*lix)[3];\n   char (*homo)[TS][TS], *buffer;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"AHD interpolation...\\n\"));\n#endif\n\n  for (i=0; i < 0x10000; i++) {\n    r = i / 65535.0;\n    cbrt[i] = r > 0.008856 ? pow((double)r,(double)(1/3.0)) : 7.787*r + 16/116.0;\n  }\n  for (i=0; i < 3; i++)\n    for (j=0; j < colors; j++)\n      for (xyz_cam[i][j] = k=0; k < 3; k++)\n\txyz_cam[i][j] += xyz_rgb[i][k] * rgb_cam[k][j] / d65_white[i];\n\n  border_interpolate(5);\n  buffer = (char *) malloc (26*TS*TS);\t\t/* 1664 kB */\n  merror (buffer, \"ahd_interpolate()\");\n  rgb  = (ushort(*)[TS][TS][3]) buffer;\n  lab  = (short (*)[TS][TS][3])(buffer + 12*TS*TS);\n  homo = (char  (*)[TS][TS])   (buffer + 24*TS*TS);\n\n  for (top=2; top < height-5; top += TS-6)\n    for (left=2; left < width-5; left += TS-6) {\n\n/*  Interpolate green horizontally and vertically:\t\t*/\n      for (row = top; row < top+TS && row < height-2; row++) {\n\tcol = left + (FC(row,left) & 1);\n\tfor (c = FC(row,col); col < left+TS && col < width-2; col+=2) {\n\t  pix = image + row*width+col;\n\t  val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2\n\t\t- pix[-2][c] - pix[2][c]) >> 2;\n\t  rgb[0][row-top][col-left][1] = ULIM(val,pix[-1][1],pix[1][1]);\n\t  val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2\n\t\t- pix[-2*width][c] - pix[2*width][c]) >> 2;\n\t  rgb[1][row-top][col-left][1] = ULIM(val,pix[-width][1],pix[width][1]);\n\t}\n      }\n/*  Interpolate red and blue, and convert to CIELab:\t\t*/\n      for (d=0; d < 2; d++)\n\tfor (row=top+1; row < top+TS-1 && row < height-3; row++)\n\t  for (col=left+1; col < left+TS-1 && col < width-3; col++) {\n\t    pix = image + row*width+col;\n\t    rix = &rgb[d][row-top][col-left];\n\t    lix = &lab[d][row-top][col-left];\n\t    if ((c = 2 - FC(row,col)) == 1) {\n\t      c = FC(row+1,col);\n\t      val = pix[0][1] + (( pix[-1][2-c] + pix[1][2-c]\n\t\t\t\t - rix[-1][1] - rix[1][1] ) >> 1);\n\t      rix[0][2-c] = CLIP(val);\n\t      val = pix[0][1] + (( pix[-width][c] + pix[width][c]\n\t\t\t\t - rix[-TS][1] - rix[TS][1] ) >> 1);\n\t    } else\n\t      val = rix[0][1] + (( pix[-width-1][c] + pix[-width+1][c]\n\t\t\t\t + pix[+width-1][c] + pix[+width+1][c]\n\t\t\t\t - rix[-TS-1][1] - rix[-TS+1][1]\n\t\t\t\t - rix[+TS-1][1] - rix[+TS+1][1] + 1) >> 2);\n\t    rix[0][c] = CLIP(val);\n\t    c = FC(row,col);\n\t    rix[0][c] = pix[0][c];\n\t    xyz[0] = xyz[1] = xyz[2] = 0.5;\n\t    FORCC {\n\t      xyz[0] += xyz_cam[0][c] * rix[0][c];\n\t      xyz[1] += xyz_cam[1][c] * rix[0][c];\n\t      xyz[2] += xyz_cam[2][c] * rix[0][c];\n\t    }\n\t    xyz[0] = cbrt[CLIP((int) xyz[0])];\n\t    xyz[1] = cbrt[CLIP((int) xyz[1])];\n\t    xyz[2] = cbrt[CLIP((int) xyz[2])];\n\t    lix[0][0] = 64 * (116 * xyz[1] - 16);\n\t    lix[0][1] = 64 * 500 * (xyz[0] - xyz[1]);\n\t    lix[0][2] = 64 * 200 * (xyz[1] - xyz[2]);\n\t  }\n/*  Build homogeneity maps from the CIELab images:\t\t*/\n      memset (homo, 0, 2*TS*TS);\n      for (row=top+2; row < top+TS-2 && row < height-4; row++) {\n\ttr = row-top;\n\tfor (col=left+2; col < left+TS-2 && col < width-4; col++) {\n\t  tc = col-left;\n\t  for (d=0; d < 2; d++) {\n\t    lix = &lab[d][tr][tc];\n\t    for (i=0; i < 4; i++) {\n\t       ldiff[d][i] = ABS(lix[0][0]-lix[dir[i]][0]);\n\t      abdiff[d][i] = SQR(lix[0][1]-lix[dir[i]][1])\n\t\t\t   + SQR(lix[0][2]-lix[dir[i]][2]);\n\t    }\n\t  }\n\t  leps = MIN(MAX(ldiff[0][0],ldiff[0][1]),\n\t\t     MAX(ldiff[1][2],ldiff[1][3]));\n\t  abeps = MIN(MAX(abdiff[0][0],abdiff[0][1]),\n\t\t      MAX(abdiff[1][2],abdiff[1][3]));\n\t  for (d=0; d < 2; d++)\n\t    for (i=0; i < 4; i++)\n\t      if (ldiff[d][i] <= leps && abdiff[d][i] <= abeps)\n\t\thomo[d][tr][tc]++;\n\t}\n      }\n/*  Combine the most homogenous pixels for the final result:\t*/\n      for (row=top+3; row < top+TS-3 && row < height-5; row++) {\n\ttr = row-top;\n\tfor (col=left+3; col < left+TS-3 && col < width-5; col++) {\n\t  tc = col-left;\n\t  for (d=0; d < 2; d++)\n\t    for (hm[d]=0, i=tr-1; i <= tr+1; i++)\n\t      for (j=tc-1; j <= tc+1; j++)\n\t\thm[d] += homo[d][i][j];\n\t  if (hm[0] != hm[1])\n\t    FORC3 image[row*width+col][c] = rgb[hm[1] > hm[0]][tr][tc][c];\n\t  else\n\t    FORC3 image[row*width+col][c] =\n\t\t(rgb[0][tr][tc][c] + rgb[1][tr][tc][c]) >> 1;\n\t}\n      }\n    }\n  free (buffer);\n}\n#undef TS\n#endif\n\nvoid CLASS median_filter()\n{\n  ushort (*pix)[4];\n  int pass, c, i, j, k, med[9];\n  static const uchar opt[] =\t/* Optimal 9-element median search */\n  { 1,2, 4,5, 7,8, 0,1, 3,4, 6,7, 1,2, 4,5, 7,8,\n    0,3, 5,8, 4,7, 3,6, 1,4, 2,5, 4,7, 4,2, 6,4, 4,2 };\n\n  for (pass=1; pass <= med_passes; pass++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n      RUN_CALLBACK(LIBRAW_PROGRESS_MEDIAN_FILTER,pass-1,med_passes);\n#endif\n#ifdef DCRAW_VERBOSE\n    if (verbose)\n      fprintf (stderr,_(\"Median filter pass %d...\\n\"), pass);\n#endif\n    for (c=0; c < 3; c+=2) {\n      for (pix = image; pix < image+width*height; pix++)\n\tpix[0][3] = pix[0][c];\n      for (pix = image+width; pix < image+width*(height-1); pix++) {\n\tif ((pix-image+1) % width < 2) continue;\n\tfor (k=0, i = -width; i <= width; i += width)\n\t  for (j = i-1; j <= i+1; j++)\n\t    med[k++] = pix[j][3] - pix[j][1];\n\tfor (i=0; i < sizeof opt; i+=2)\n\t  if     (med[opt[i]] > med[opt[i+1]])\n\t    SWAP (med[opt[i]] , med[opt[i+1]]);\n\tpix[0][c] = CLIP(med[4] + pix[0][1]);\n      }\n    }\n  }\n}\n\nvoid CLASS blend_highlights()\n{\n  int clip=INT_MAX, row, col, c, i, j;\n  static const float trans[2][4][4] =\n  { { { 1,1,1 }, { 1.7320508,-1.7320508,0 }, { -1,-1,2 } },\n    { { 1,1,1,1 }, { 1,-1,1,-1 }, { 1,1,-1,-1 }, { 1,-1,-1,1 } } };\n  static const float itrans[2][4][4] =\n  { { { 1,0.8660254,-0.5 }, { 1,-0.8660254,-0.5 }, { 1,0,1 } },\n    { { 1,1,1,1 }, { 1,-1,1,-1 }, { 1,1,-1,-1 }, { 1,-1,-1,1 } } };\n  float cam[2][4], lab[2][4], sum[2], chratio;\n\n  if ((unsigned) (colors-3) > 1) return;\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Blending highlights...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,0,2);\n#endif\n  FORCC if (clip > (i = 65535*pre_mul[c])) clip = i;\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++) {\n      FORCC if (image[row*width+col][c] > clip) break;\n      if (c == colors) continue;\n      FORCC {\n\tcam[0][c] = image[row*width+col][c];\n\tcam[1][c] = MIN(cam[0][c],clip);\n      }\n      for (i=0; i < 2; i++) {\n\tFORCC for (lab[i][c]=j=0; j < colors; j++)\n\t  lab[i][c] += trans[colors-3][c][j] * cam[i][j];\n\tfor (sum[i]=0,c=1; c < colors; c++)\n\t  sum[i] += SQR(lab[i][c]);\n      }\n      chratio = sqrt(sum[1]/sum[0]);\n      for (c=1; c < colors; c++)\n\tlab[0][c] *= chratio;\n      FORCC for (cam[0][c]=j=0; j < colors; j++)\n\tcam[0][c] += itrans[colors-3][c][j] * lab[0][j];\n      FORCC image[row*width+col][c] = cam[0][c] / colors;\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,1,2);\n#endif\n}\n\n#define SCALE (4 >> shrink)\nvoid CLASS recover_highlights()\n{\n  float *map, sum, wgt, grow;\n  int hsat[4], count, spread, change, val, i;\n  unsigned high, wide, mrow, mcol, row, col, kc, c, d, y, x;\n  ushort *pixel;\n  static const signed char dir[8][2] =\n    { {-1,-1}, {-1,0}, {-1,1}, {0,1}, {1,1}, {1,0}, {1,-1}, {0,-1} };\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Rebuilding highlights...\\n\"));\n#endif\n\n  grow = pow (2.0, 4-highlight);\n  FORCC hsat[c] = 32000 * pre_mul[c];\n  for (kc=0, c=1; c < colors; c++)\n    if (pre_mul[kc] < pre_mul[c]) kc = c;\n  high = height / SCALE;\n  wide =  width / SCALE;\n  map = (float *) calloc (high*wide, sizeof *map);\n  merror (map, \"recover_highlights()\");\n  FORCC if (c != kc) {\n#ifdef LIBRAW_LIBRARY_BUILD\n      RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,c-1,colors-1);\n#endif\n    memset (map, 0, high*wide*sizeof *map);\n    for (mrow=0; mrow < high; mrow++)\n      for (mcol=0; mcol < wide; mcol++) {\n\tsum = wgt = count = 0;\n\tfor (row = mrow*SCALE; row < (mrow+1)*SCALE; row++)\n\t  for (col = mcol*SCALE; col < (mcol+1)*SCALE; col++) {\n\t    pixel = image[row*width+col];\n\t    if (pixel[c] / hsat[c] == 1 && pixel[kc] > 24000) {\n\t      sum += pixel[c];\n\t      wgt += pixel[kc];\n\t      count++;\n\t    }\n\t  }\n\tif (count == SCALE*SCALE)\n\t  map[mrow*wide+mcol] = sum / wgt;\n      }\n    for (spread = 32/grow; spread--; ) {\n      for (mrow=0; mrow < high; mrow++)\n\tfor (mcol=0; mcol < wide; mcol++) {\n\t  if (map[mrow*wide+mcol]) continue;\n\t  sum = count = 0;\n\t  for (d=0; d < 8; d++) {\n\t    y = mrow + dir[d][0];\n\t    x = mcol + dir[d][1];\n\t    if (y < high && x < wide && map[y*wide+x] > 0) {\n\t      sum  += (1 + (d & 1)) * map[y*wide+x];\n\t      count += 1 + (d & 1);\n\t    }\n\t  }\n\t  if (count > 3)\n\t    map[mrow*wide+mcol] = - (sum+grow) / (count+grow);\n\t}\n      for (change=i=0; i < high*wide; i++)\n\tif (map[i] < 0) {\n\t  map[i] = -map[i];\n\t  change = 1;\n\t}\n      if (!change) break;\n    }\n    for (i=0; i < high*wide; i++)\n      if (map[i] == 0) map[i] = 1;\n    for (mrow=0; mrow < high; mrow++)\n      for (mcol=0; mcol < wide; mcol++) {\n\tfor (row = mrow*SCALE; row < (mrow+1)*SCALE; row++)\n\t  for (col = mcol*SCALE; col < (mcol+1)*SCALE; col++) {\n\t    pixel = image[row*width+col];\n\t    if (pixel[c] / hsat[c] > 1) {\n\t      val = pixel[kc] * map[mrow*wide+mcol];\n\t      if (pixel[c] < val) pixel[c] = CLIP(val);\n\t    }\n\t  }\n      }\n  }\n  free (map);\n}\n#undef SCALE\n\nvoid CLASS tiff_get (unsigned base,\n\tunsigned *tag, unsigned *type, unsigned *len, unsigned *save)\n{\n  *tag  = get2();\n  *type = get2();\n  *len  = get4();\n  *save = ftell(ifp) + 4;\n  if (*len * (\"11124811248488\"[*type < 14 ? *type:0]-'0') > 4)\n    fseek (ifp, get4()+base, SEEK_SET);\n}\n\nvoid CLASS parse_thumb_note (int base, unsigned toff, unsigned tlen)\n{\n  unsigned entries, tag, type, len, save;\n\n  entries = get2();\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    if (tag == toff) thumb_offset = get4()+base;\n    if (tag == tlen) thumb_length = get4();\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n#line 5610 \"dcraw/dcraw.c\"\nvoid CLASS parse_makernote (int base, int uptag)\n{\n  static const uchar xlat[2][256] = {\n  { 0xc1,0xbf,0x6d,0x0d,0x59,0xc5,0x13,0x9d,0x83,0x61,0x6b,0x4f,0xc7,0x7f,0x3d,0x3d,\n    0x53,0x59,0xe3,0xc7,0xe9,0x2f,0x95,0xa7,0x95,0x1f,0xdf,0x7f,0x2b,0x29,0xc7,0x0d,\n    0xdf,0x07,0xef,0x71,0x89,0x3d,0x13,0x3d,0x3b,0x13,0xfb,0x0d,0x89,0xc1,0x65,0x1f,\n    0xb3,0x0d,0x6b,0x29,0xe3,0xfb,0xef,0xa3,0x6b,0x47,0x7f,0x95,0x35,0xa7,0x47,0x4f,\n    0xc7,0xf1,0x59,0x95,0x35,0x11,0x29,0x61,0xf1,0x3d,0xb3,0x2b,0x0d,0x43,0x89,0xc1,\n    0x9d,0x9d,0x89,0x65,0xf1,0xe9,0xdf,0xbf,0x3d,0x7f,0x53,0x97,0xe5,0xe9,0x95,0x17,\n    0x1d,0x3d,0x8b,0xfb,0xc7,0xe3,0x67,0xa7,0x07,0xf1,0x71,0xa7,0x53,0xb5,0x29,0x89,\n    0xe5,0x2b,0xa7,0x17,0x29,0xe9,0x4f,0xc5,0x65,0x6d,0x6b,0xef,0x0d,0x89,0x49,0x2f,\n    0xb3,0x43,0x53,0x65,0x1d,0x49,0xa3,0x13,0x89,0x59,0xef,0x6b,0xef,0x65,0x1d,0x0b,\n    0x59,0x13,0xe3,0x4f,0x9d,0xb3,0x29,0x43,0x2b,0x07,0x1d,0x95,0x59,0x59,0x47,0xfb,\n    0xe5,0xe9,0x61,0x47,0x2f,0x35,0x7f,0x17,0x7f,0xef,0x7f,0x95,0x95,0x71,0xd3,0xa3,\n    0x0b,0x71,0xa3,0xad,0x0b,0x3b,0xb5,0xfb,0xa3,0xbf,0x4f,0x83,0x1d,0xad,0xe9,0x2f,\n    0x71,0x65,0xa3,0xe5,0x07,0x35,0x3d,0x0d,0xb5,0xe9,0xe5,0x47,0x3b,0x9d,0xef,0x35,\n    0xa3,0xbf,0xb3,0xdf,0x53,0xd3,0x97,0x53,0x49,0x71,0x07,0x35,0x61,0x71,0x2f,0x43,\n    0x2f,0x11,0xdf,0x17,0x97,0xfb,0x95,0x3b,0x7f,0x6b,0xd3,0x25,0xbf,0xad,0xc7,0xc5,\n    0xc5,0xb5,0x8b,0xef,0x2f,0xd3,0x07,0x6b,0x25,0x49,0x95,0x25,0x49,0x6d,0x71,0xc7 },\n  { 0xa7,0xbc,0xc9,0xad,0x91,0xdf,0x85,0xe5,0xd4,0x78,0xd5,0x17,0x46,0x7c,0x29,0x4c,\n    0x4d,0x03,0xe9,0x25,0x68,0x11,0x86,0xb3,0xbd,0xf7,0x6f,0x61,0x22,0xa2,0x26,0x34,\n    0x2a,0xbe,0x1e,0x46,0x14,0x68,0x9d,0x44,0x18,0xc2,0x40,0xf4,0x7e,0x5f,0x1b,0xad,\n    0x0b,0x94,0xb6,0x67,0xb4,0x0b,0xe1,0xea,0x95,0x9c,0x66,0xdc,0xe7,0x5d,0x6c,0x05,\n    0xda,0xd5,0xdf,0x7a,0xef,0xf6,0xdb,0x1f,0x82,0x4c,0xc0,0x68,0x47,0xa1,0xbd,0xee,\n    0x39,0x50,0x56,0x4a,0xdd,0xdf,0xa5,0xf8,0xc6,0xda,0xca,0x90,0xca,0x01,0x42,0x9d,\n    0x8b,0x0c,0x73,0x43,0x75,0x05,0x94,0xde,0x24,0xb3,0x80,0x34,0xe5,0x2c,0xdc,0x9b,\n    0x3f,0xca,0x33,0x45,0xd0,0xdb,0x5f,0xf5,0x52,0xc3,0x21,0xda,0xe2,0x22,0x72,0x6b,\n    0x3e,0xd0,0x5b,0xa8,0x87,0x8c,0x06,0x5d,0x0f,0xdd,0x09,0x19,0x93,0xd0,0xb9,0xfc,\n    0x8b,0x0f,0x84,0x60,0x33,0x1c,0x9b,0x45,0xf1,0xf0,0xa3,0x94,0x3a,0x12,0x77,0x33,\n    0x4d,0x44,0x78,0x28,0x3c,0x9e,0xfd,0x65,0x57,0x16,0x94,0x6b,0xfb,0x59,0xd0,0xc8,\n    0x22,0x36,0xdb,0xd2,0x63,0x98,0x43,0xa1,0x04,0x87,0x86,0xf7,0xa6,0x26,0xbb,0xd6,\n    0x59,0x4d,0xbf,0x6a,0x2e,0xaa,0x2b,0xef,0xe6,0x78,0xb6,0x4e,0xe0,0x2f,0xdc,0x7c,\n    0xbe,0x57,0x19,0x32,0x7e,0x2a,0xd0,0xb8,0xba,0x29,0x00,0x3c,0x52,0x7d,0xa8,0x49,\n    0x3b,0x2d,0xeb,0x25,0x49,0xfa,0xa3,0xaa,0x39,0xa7,0xc5,0xa7,0x50,0x11,0x36,0xfb,\n    0xc6,0x67,0x4a,0xf5,0xa5,0x12,0x65,0x7e,0xb0,0xdf,0xaf,0x4e,0xb3,0x61,0x7f,0x2f } };\n  unsigned offset=0, entries, tag, type, len, save, c;\n  unsigned ver97=0, serial=0, i, wbi=0, wb[4]={0,0,0,0};\n  uchar buf97[324], ci, cj, ck;\n  short morder, sorder=order;\n  char buf[10];\n/*\n   The MakerNote might have its own TIFF header (possibly with\n   its own byte-order!), or it might just be a table.\n */\n  if (!strcmp(make,\"Nokia\")) return;\n  fread (buf, 1, 10, ifp);\n  if (!strncmp (buf,\"KDK\" ,3) ||\t/* these aren't TIFF tables */\n      !strncmp (buf,\"VER\" ,3) ||\n      !strncmp (buf,\"IIII\",4) ||\n      !strncmp (buf,\"MMMM\",4)) return;\n  if (!strncmp (buf,\"KC\"  ,2) ||\t/* Konica KD-400Z, KD-510Z */\n      !strncmp (buf,\"MLY\" ,3)) {\t/* Minolta DiMAGE G series */\n    order = 0x4d4d;\n    while ((i=ftell(ifp)) < data_offset && i < 16384) {\n      wb[0] = wb[2];  wb[2] = wb[1];  wb[1] = wb[3];\n      wb[3] = get2();\n      if (wb[1] == 256 && wb[3] == 256 &&\n\t  wb[0] > 256 && wb[0] < 640 && wb[2] > 256 && wb[2] < 640)\n\tFORC4 cam_mul[c] = wb[c];\n    }\n    goto quit;\n  }\n  if (!strcmp (buf,\"Nikon\")) {\n    base = ftell(ifp);\n    order = get2();\n    if (get2() != 42) goto quit;\n    offset = get4();\n    fseek (ifp, offset-8, SEEK_CUR);\n  } else if (!strcmp (buf,\"OLYMPUS\")) {\n    base = ftell(ifp)-10;\n    fseek (ifp, -2, SEEK_CUR);\n    order = get2();  get2();\n  } else if (!strncmp (buf,\"SONY\",4) ||\n\t     !strcmp  (buf,\"Panasonic\")) {\n    goto nf;\n  } else if (!strncmp (buf,\"FUJIFILM\",8)) {\n    base = ftell(ifp)-10;\nnf: order = 0x4949;\n    fseek (ifp,  2, SEEK_CUR);\n  } else if (!strcmp (buf,\"OLYMP\") ||\n\t     !strcmp (buf,\"LEICA\") ||\n\t     !strcmp (buf,\"Ricoh\") ||\n\t     !strcmp (buf,\"EPSON\"))\n    fseek (ifp, -2, SEEK_CUR);\n  else if (!strcmp (buf,\"AOC\") ||\n\t   !strcmp (buf,\"QVC\"))\n    fseek (ifp, -4, SEEK_CUR);\n  else {\n    fseek (ifp, -10, SEEK_CUR);\n    if (!strncmp(make,\"SAMSUNG\",7))\n      base = ftell(ifp);\n  }\n  entries = get2();\n  if (entries > 1000) return;\n  morder = order;\n  while (entries--) {\n    order = morder;\n    tiff_get (base, &tag, &type, &len, &save);\n    tag |= uptag << 16;\n    if (tag == 2 && strstr(make,\"NIKON\") && !iso_speed)\n      iso_speed = (get2(),get2());\n    if (tag == 4 && len > 26 && len < 35) {\n      if ((i=(get4(),get2())) != 0x7fff && !iso_speed)\n\tiso_speed = 50 * pow (2, i/32.0 - 4);\n      if ((i=(get2(),get2())) != 0x7fff && !aperture)\n\taperture = pow (2, i/64.0);\n      if ((i=get2()) != 0xffff && !shutter)\n\tshutter = pow (2, (short) i/-32.0);\n      wbi = (get2(),get2());\n      shot_order = (get2(),get2());\n    }\n    if ((tag == 4 || tag == 0x114) && !strncmp(make,\"KONICA\",6)) {\n      fseek (ifp, tag == 4 ? 140:160, SEEK_CUR);\n      switch (get2()) {\n\tcase 72:  flip = 0;  break;\n\tcase 76:  flip = 6;  break;\n\tcase 82:  flip = 5;  break;\n      }\n    }\n    if (tag == 7 && type == 2 && len > 20)\n      fgets (model2, 64, ifp);\n    if (tag == 8 && type == 4)\n      shot_order = get4();\n    if (tag == 9 && !strcmp(make,\"Canon\"))\n      fread (artist, 64, 1, ifp);\n    if (tag == 0xc && len == 4) {\n      cam_mul[0] = getreal(type);\n      cam_mul[2] = getreal(type);\n    }\n    if (tag == 0xd && type == 7 && get2() == 0xaaaa) {\n      for (c=i=2; (ushort) c != 0xbbbb && i < len; i++)\n\tc = c << 8 | fgetc(ifp);\n      while ((i+=4) < len-5)\n\tif (get4() == 257 && (i=len) && (c = (get4(),fgetc(ifp))) < 3)\n\t  flip = \"065\"[c]-'0';\n    }\n    if (tag == 0x10 && type == 4)\n      unique_id = get4();\n    if (tag == 0x11 && is_raw && !strncmp(make,\"NIKON\",5)) {\n      fseek (ifp, get4()+base, SEEK_SET);\n      parse_tiff_ifd (base);\n    }\n    if (tag == 0x14 && type == 7) {\n      if (len == 2560) {\n\tfseek (ifp, 1248, SEEK_CUR);\n\tgoto get2_256;\n      }\n      fread (buf, 1, 10, ifp);\n      if (!strncmp(buf,\"NRW \",4)) {\n\tfseek (ifp, strcmp(buf+4,\"0100\") ? 46:1546, SEEK_CUR);\n\tcam_mul[0] = get4() << 2;\n\tcam_mul[1] = get4() + get4();\n\tcam_mul[2] = get4() << 2;\n      }\n    }\n    if (tag == 0x15 && type == 2 && is_raw)\n      fread (model, 64, 1, ifp);\n    if (strstr(make,\"PENTAX\")) {\n      if (tag == 0x1b) tag = 0x1018;\n      if (tag == 0x1c) tag = 0x1017;\n    }\n    if (tag == 0x1d)\n      while ((c = fgetc(ifp)) && c != EOF)\n\tserial = serial*10 + (isdigit(c) ? c - '0' : c % 10);\n    if (tag == 0x81 && type == 4) {\n      data_offset = get4();\n      fseek (ifp, data_offset + 41, SEEK_SET);\n      raw_height = get2() * 2;\n      raw_width  = get2();\n      filters = 0x61616161;\n    }\n    if (tag == 0x29 && type == 1) {\n      c = wbi < 18 ? \"012347800000005896\"[wbi]-'0' : 0;\n      fseek (ifp, 8 + c*32, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get4();\n    }\n    if ((tag == 0x81  && type == 7) ||\n\t(tag == 0x100 && type == 7) ||\n\t(tag == 0x280 && type == 1)) {\n      thumb_offset = ftell(ifp);\n      thumb_length = len;\n    }\n    if (tag == 0x88 && type == 4 && (thumb_offset = get4()))\n      thumb_offset += base;\n    if (tag == 0x89 && type == 4)\n      thumb_length = get4();\n    if (tag == 0x8c || tag == 0x96)\n      meta_offset = ftell(ifp);\n    if (tag == 0x97) {\n      for (i=0; i < 4; i++)\n\tver97 = ver97 * 10 + fgetc(ifp)-'0';\n      switch (ver97) {\n\tcase 100:\n\t  fseek (ifp, 68, SEEK_CUR);\n\t  FORC4 cam_mul[(c >> 1) | ((c & 1) << 1)] = get2();\n\t  break;\n\tcase 102:\n\t  fseek (ifp, 6, SEEK_CUR);\n\t  goto get2_rggb;\n\tcase 103:\n\t  fseek (ifp, 16, SEEK_CUR);\n\t  FORC4 cam_mul[c] = get2();\n      }\n      if (ver97 >= 200) {\n\tif (ver97 != 205) fseek (ifp, 280, SEEK_CUR);\n\tfread (buf97, 324, 1, ifp);\n      }\n    }\n    if (tag == 0xa1 && type == 7) {\n      order = 0x4949;\n      fseek (ifp, 140, SEEK_CUR);\n      FORC3 cam_mul[c] = get4();\n    }\n    if (tag == 0xa4 && type == 3) {\n      fseek (ifp, wbi*48, SEEK_CUR);\n      FORC3 cam_mul[c] = get2();\n    }\n    if (tag == 0xa7 && (unsigned) (ver97-200) < 17) {\n      ci = xlat[0][serial & 0xff];\n      cj = xlat[1][fgetc(ifp)^fgetc(ifp)^fgetc(ifp)^fgetc(ifp)];\n      ck = 0x60;\n      for (i=0; i < 324; i++)\n\tbuf97[i] ^= (cj += ci * ck++);\n      i = \"66666>666;6A;:;55\"[ver97-200] - '0';\n      FORC4 cam_mul[c ^ (c >> 1) ^ (i & 1)] =\n\tsget2 (buf97 + (i & -2) + c*2);\n    }\n    if (tag == 0x200 && len == 3)\n      shot_order = (get4(),get4());\n    if (tag == 0x200 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2();\n    if (tag == 0x201 && len == 4)\n      goto get2_rggb;\n    if (tag == 0x220 && type == 7)\n      meta_offset = ftell(ifp);\n    if (tag == 0x401 && type == 4 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get4();\n    if (tag == 0xe01) {\t\t/* Nikon Capture Note */\n      order = 0x4949;\n      fseek (ifp, 22, SEEK_CUR);\n      for (offset=22; offset+22 < len; offset += 22+i) {\n\ttag = get4();\n\tfseek (ifp, 14, SEEK_CUR);\n\ti = get4()-4;\n\tif (tag == 0x76a43207) flip = get2();\n\telse fseek (ifp, i, SEEK_CUR);\n      }\n    }\n    if (tag == 0xe80 && len == 256 && type == 7) {\n      fseek (ifp, 48, SEEK_CUR);\n      cam_mul[0] = get2() * 508 * 1.078 / 0x10000;\n      cam_mul[2] = get2() * 382 * 1.173 / 0x10000;\n    }\n    if (tag == 0xf00 && type == 7) {\n      if (len == 614)\n\tfseek (ifp, 176, SEEK_CUR);\n      else if (len == 734 || len == 1502)\n\tfseek (ifp, 148, SEEK_CUR);\n      else goto next;\n      goto get2_256;\n    }\n    if ((tag == 0x1011 && len == 9) || tag == 0x20400200)\n      for (i=0; i < 3; i++)\n\tFORC3 cmatrix[i][c] = ((short) get2()) / 256.0;\n    if ((tag == 0x1012 || tag == 0x20400600) && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2();\n    if (tag == 0x1017 || tag == 0x20400100)\n      cam_mul[0] = get2() / 256.0;\n    if (tag == 0x1018 || tag == 0x20400100)\n      cam_mul[2] = get2() / 256.0;\n    if (tag == 0x2011 && len == 2) {\nget2_256:\n      order = 0x4d4d;\n      cam_mul[0] = get2() / 256.0;\n      cam_mul[2] = get2() / 256.0;\n    }\n    if ((tag | 0x70) == 0x2070 && type == 4)\n      fseek (ifp, get4()+base, SEEK_SET);\n    if (tag == 0x2010 && type != 7)\n      load_raw = &CLASS olympus_load_raw;\n    if (tag == 0x2020)\n      parse_thumb_note (base, 257, 258);\n    if (tag == 0x2040)\n      parse_makernote (base, 0x2040);\n    if (tag == 0xb028) {\n      fseek (ifp, get4()+base, SEEK_SET);\n      parse_thumb_note (base, 136, 137);\n    }\n    if (tag == 0x4001 && len > 500) {\n      i = len == 582 ? 50 : len == 653 ? 68 : len == 5120 ? 142 : 126;\n      fseek (ifp, i, SEEK_CUR);\nget2_rggb:\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n      i = len >> 3 == 164 ? 112:22;\n      fseek (ifp, i, SEEK_CUR);\n      FORC4 sraw_mul[c ^ (c >> 1)] = get2();\n    }\n    if (tag == 0xa021)\n      FORC4 cam_mul[c ^ (c >> 1)] = get4();\n    if (tag == 0xa028)\n      FORC4 cam_mul[c ^ (c >> 1)] -= get4();\nnext:\n    fseek (ifp, save, SEEK_SET);\n  }\nquit:\n  order = sorder;\n}\n\n/*\n   Since the TIFF DateTime string has no timezone information,\n   assume that the camera's clock was set to Universal Time.\n */\nvoid CLASS get_timestamp (int reversed)\n{\n  struct tm t;\n  char str[20];\n  int i;\n\n  str[19] = 0;\n  if (reversed)\n    for (i=19; i--; ) str[i] = fgetc(ifp);\n  else\n    fread (str, 19, 1, ifp);\n  memset (&t, 0, sizeof t);\n  if (sscanf (str, \"%d:%d:%d %d:%d:%d\", &t.tm_year, &t.tm_mon,\n\t&t.tm_mday, &t.tm_hour, &t.tm_min, &t.tm_sec) != 6)\n    return;\n  t.tm_year -= 1900;\n  t.tm_mon -= 1;\n  t.tm_isdst = -1;\n  if (mktime(&t) > 0)\n    timestamp = mktime(&t);\n}\n\nvoid CLASS parse_exif (int base)\n{\n  unsigned kodak, entries, tag, type, len, save, c;\n  double expo;\n\n  kodak = !strncmp(make,\"EASTMAN\",7) && tiff_nifds < 3;\n  entries = get2();\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    switch (tag) {\n      case 33434:  shutter = getreal(type);\t\tbreak;\n      case 33437:  aperture = getreal(type);\t\tbreak;\n      case 34855:  iso_speed = get2();\t\t\tbreak;\n      case 36867:\n      case 36868:  get_timestamp(0);\t\t\tbreak;\n      case 37377:  if ((expo = -getreal(type)) < 128)\n\t\t     shutter = pow (2, expo);\t\tbreak;\n      case 37378:  aperture = pow (2, getreal(type)/2);\tbreak;\n      case 37386:  focal_len = getreal(type);\t\tbreak;\n      case 37500:  parse_makernote (base, 0);\t\tbreak;\n      case 40962:  if (kodak) raw_width  = get4();\tbreak;\n      case 40963:  if (kodak) raw_height = get4();\tbreak;\n      case 41730:\n\tif (get4() == 0x20002)\n\t  for (exif_cfa=c=0; c < 8; c+=2)\n\t    exif_cfa |= fgetc(ifp) * 0x01010101 << c;\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS parse_gps (int base)\n{\n  unsigned entries, tag, type, len, save, c;\n\n  entries = get2();\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    switch (tag) {\n      case 1: case 3: case 5:\n\tgpsdata[29+tag/2] = getc(ifp);\t\t\tbreak;\n      case 2: case 4: case 7:\n\tFORC(6) gpsdata[tag/3*6+c] = get4();\t\tbreak;\n      case 6:\n\tFORC(2) gpsdata[18+c] = get4();\t\t\tbreak;\n      case 18: case 29:\n\tfgets ((char *) (gpsdata+14+tag/3), MIN(len,12), ifp);\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS romm_coeff (float romm_cam[3][3])\n{\n  static const float rgb_romm[3][3] =\t/* ROMM == Kodak ProPhoto */\n  { {  2.034193, -0.727420, -0.306766 },\n    { -0.228811,  1.231729, -0.002922 },\n    { -0.008565, -0.153273,  1.161839 } };\n  int i, j, k;\n\n  for (i=0; i < 3; i++)\n    for (j=0; j < 3; j++)\n      for (cmatrix[i][j] = k=0; k < 3; k++)\n\tcmatrix[i][j] += rgb_romm[i][k] * romm_cam[k][j];\n}\n\nvoid CLASS parse_mos (int offset)\n{\n  char data[40];\n  int skip, from, i, c, neut[4], planes=0, frot=0;\n  static const char *mod[] =\n  { \"\",\"DCB2\",\"Volare\",\"Cantare\",\"CMost\",\"Valeo 6\",\"Valeo 11\",\"Valeo 22\",\n    \"Valeo 11p\",\"Valeo 17\",\"\",\"Aptus 17\",\"Aptus 22\",\"Aptus 75\",\"Aptus 65\",\n    \"Aptus 54S\",\"Aptus 65S\",\"Aptus 75S\",\"AFi 5\",\"AFi 6\",\"AFi 7\",\n    \"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"AFi-II 12\" };\n  float romm_cam[3][3];\n\n  fseek (ifp, offset, SEEK_SET);\n  while (1) {\n    if (get4() != 0x504b5453) break;\n    get4();\n    fread (data, 1, 40, ifp);\n    skip = get4();\n    from = ftell(ifp);\n    if (!strcmp(data,\"JPEG_preview_data\")) {\n      thumb_offset = from;\n      thumb_length = skip;\n    }\n    if (!strcmp(data,\"icc_camera_profile\")) {\n      profile_offset = from;\n      profile_length = skip;\n    }\n    if (!strcmp(data,\"ShootObj_back_type\")) {\n      fscanf (ifp, \"%d\", &i);\n      if ((unsigned) i < sizeof mod / sizeof (*mod))\n\tstrcpy (model, mod[i]);\n    }\n    if (!strcmp(data,\"icc_camera_to_tone_matrix\")) {\n      for (i=0; i < 9; i++)\n\tromm_cam[0][i] = int_to_float(get4());\n      romm_coeff (romm_cam);\n    }\n    if (!strcmp(data,\"CaptProf_color_matrix\")) {\n      for (i=0; i < 9; i++)\n\tfscanf (ifp, \"%f\", &romm_cam[0][i]);\n      romm_coeff (romm_cam);\n    }\n    if (!strcmp(data,\"CaptProf_number_of_planes\"))\n      fscanf (ifp, \"%d\", &planes);\n    if (!strcmp(data,\"CaptProf_raw_data_rotation\"))\n      fscanf (ifp, \"%d\", &flip);\n    if (!strcmp(data,\"CaptProf_mosaic_pattern\"))\n      FORC4 {\n\tfscanf (ifp, \"%d\", &i);\n\tif (i == 1) frot = c ^ (c >> 1);\n      }\n    if (!strcmp(data,\"ImgProf_rotation_angle\")) {\n      fscanf (ifp, \"%d\", &i);\n      flip = i - flip;\n    }\n    if (!strcmp(data,\"NeutObj_neutrals\") && !cam_mul[0]) {\n      FORC4 fscanf (ifp, \"%d\", neut+c);\n      FORC3 cam_mul[c] = (float) neut[0] / neut[c+1];\n    }\n    if (!strcmp(data,\"Rows_data\"))\n      load_flags = get4();\n    parse_mos (from);\n    fseek (ifp, skip+from, SEEK_SET);\n  }\n  if (planes)\n    filters = (planes == 1) * 0x01010101 *\n\t(uchar) \"\\x94\\x61\\x16\\x49\"[(flip/90 + frot) & 3];\n}\n\nvoid CLASS linear_table (unsigned len)\n{\n  int i;\n  if (len > 0x1000) len = 0x1000;\n  read_shorts (curve, len);\n  for (i=len; i < 0x1000; i++)\n    curve[i] = curve[i-1];\n  maximum = curve[0xfff];\n}\n\nvoid CLASS parse_kodak_ifd (int base)\n{\n  unsigned entries, tag, type, len, save;\n  int i, c, wbi=-2, wbtemp=6500;\n  float mul[3]={1,1,1}, num;\n  static const int wbtag[] = { 64037,64040,64039,64041,-1,-1,64042 };\n\n  entries = get2();\n  if (entries > 1024) return;\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    if (tag == 1020) wbi = getint(type);\n    if (tag == 1021 && len == 72) {\t\t/* WB set in software */\n      fseek (ifp, 40, SEEK_CUR);\n      FORC3 cam_mul[c] = 2048.0 / get2();\n      wbi = -2;\n    }\n    if (tag == 2118) wbtemp = getint(type);\n    if (tag == 2130 + wbi)\n      FORC3 mul[c] = getreal(type);\n    if (tag == 2140 + wbi && wbi >= 0)\n      FORC3 {\n\tfor (num=i=0; i < 4; i++)\n\t  num += getreal(type) * pow (wbtemp/100.0, i);\n\tcam_mul[c] = 2048 / (num * mul[c]);\n      }\n    if (tag == 2317) linear_table (len);\n    if (tag == 6020) iso_speed = getint(type);\n    if (tag == 64013) wbi = fgetc(ifp);\n    if ((unsigned) wbi < 7 && tag == wbtag[wbi])\n      FORC3 cam_mul[c] = get4();\n    if (tag == 64019) width = getint(type);\n    if (tag == 64020) height = (getint(type)+1) & -2;\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n#line 6130 \"dcraw/dcraw.c\"\nint CLASS parse_tiff_ifd (int base)\n{\n  unsigned entries, tag, type, len, plen=16, save;\n  int ifd, use_cm=0, cfa, i, j, c, ima_len=0;\n  int blrr=1, blrc=1, dblack[] = { 0,0,0,0 };\n  char software[64], *cbuf, *cp;\n  uchar cfa_pat[16], cfa_pc[] = { 0,1,2,3 }, tab[256];\n  double cc[4][4], cm[4][3], cam_xyz[4][3], num;\n  double ab[]={ 1,1,1,1 }, asn[] = { 0,0,0,0 }, xyz[] = { 1,1,1 };\n  unsigned sony_curve[] = { 0,0,0,0,0,4095 };\n  unsigned *buf, sony_offset=0, sony_length=0, sony_key=0;\n  struct jhead jh;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *sfp;\n#endif\n\n  if (tiff_nifds >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n    return 1;\n  ifd = tiff_nifds++;\n  for (j=0; j < 4; j++)\n    for (i=0; i < 4; i++)\n      cc[j][i] = i == j;\n  entries = get2();\n  if (entries > 512) return 1;\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    switch (tag) {\n      case 5:   width  = get2();  break;\n      case 6:   height = get2();  break;\n      case 7:   width += get2();  break;\n      case 9:  filters = get2();  break;\n      case 17: case 18:\n\tif (type == 3 && len == 1)\n\t  cam_mul[(tag-17)*2] = get2() / 256.0;\n\tbreak;\n      case 23:\n\tif (type == 3) iso_speed = get2();\n\tbreak;\n      case 36: case 37: case 38:\n\tcam_mul[tag-0x24] = get2();\n\tbreak;\n      case 39:\n\tif (len < 50 || cam_mul[0]) break;\n\tfseek (ifp, 12, SEEK_CUR);\n\tFORC3 cam_mul[c] = get2();\n\tbreak;\n      case 46:\n\tif (type != 7 || fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8) break;\n\tthumb_offset = ftell(ifp) - 2;\n\tthumb_length = len;\n\tbreak;\n      case 61440:\t\t\t/* Fuji HS10 table */\n\tparse_tiff_ifd (base);\n\tbreak;\n      case 2: case 256: case 61441:\t/* ImageWidth */\n\ttiff_ifd[ifd].t_width = getint(type);\n\tbreak;\n      case 3: case 257: case 61442:\t/* ImageHeight */\n\ttiff_ifd[ifd].t_height = getint(type);\n\tbreak;\n      case 258:\t\t\t\t/* BitsPerSample */\n      case 61443:\n\ttiff_ifd[ifd].samples = len & 7;\n\ttiff_ifd[ifd].bps = getint(type);\n\tbreak;\n      case 61446:\n\traw_height = 0;\n\tload_raw = &CLASS packed_load_raw;\n\tload_flags = get4() && (filters=0x16161616) ? 24:80;\n\tbreak;\n      case 259:\t\t\t\t/* Compression */\n\ttiff_ifd[ifd].comp = getint(type);\n\tbreak;\n      case 262:\t\t\t\t/* PhotometricInterpretation */\n\ttiff_ifd[ifd].phint = get2();\n\tbreak;\n      case 270:\t\t\t\t/* ImageDescription */\n\tfread (desc, 512, 1, ifp);\n\tbreak;\n      case 271:\t\t\t\t/* Make */\n\tfgets (make, 64, ifp);\n\tbreak;\n      case 272:\t\t\t\t/* Model */\n\tfgets (model, 64, ifp);\n\tbreak;\n      case 280:\t\t\t\t/* Panasonic RW2 offset */\n\tif (type != 4) break;\n\tload_raw = &CLASS panasonic_load_raw;\n\tload_flags = 0x2008;\n      case 273:\t\t\t\t/* StripOffset */\n      case 513:\t\t\t\t/* JpegIFOffset */\n      case 61447:\n\ttiff_ifd[ifd].offset = get4()+base;\n\tif (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0) {\n\t  fseek (ifp, tiff_ifd[ifd].offset, SEEK_SET);\n\t  if (ljpeg_start (&jh, 1)) {\n\t    tiff_ifd[ifd].comp    = 6;\n\t    tiff_ifd[ifd].t_width   = jh.wide;\n\t    tiff_ifd[ifd].t_height  = jh.high;\n\t    tiff_ifd[ifd].bps     = jh.bits;\n\t    tiff_ifd[ifd].samples = jh.clrs;\n\t    if (!(jh.sraw || (jh.clrs & 1)))\n\t      tiff_ifd[ifd].t_width *= jh.clrs;\n\t    i = order;\n\t    parse_tiff (tiff_ifd[ifd].offset + 12);\n\t    order = i;\n\t  }\n\t}\n\tbreak;\n      case 274:\t\t\t\t/* Orientation */\n\ttiff_ifd[ifd].t_flip = \"50132467\"[get2() & 7]-'0';\n\tbreak;\n      case 277:\t\t\t\t/* SamplesPerPixel */\n\ttiff_ifd[ifd].samples = getint(type) & 7;\n\tbreak;\n      case 279:\t\t\t\t/* StripByteCounts */\n      case 514:\n      case 61448:\n\ttiff_ifd[ifd].bytes = get4();\n\tbreak;\n      case 61454:\n\tFORC3 cam_mul[(4-c) % 3] = getint(type);\n\tbreak;\n      case 305:  case 11:\t\t/* Software */\n\tfgets (software, 64, ifp);\n\tif (!strncmp(software,\"Adobe\",5) ||\n\t    !strncmp(software,\"dcraw\",5) ||\n\t    !strncmp(software,\"UFRaw\",5) ||\n\t    !strncmp(software,\"Bibble\",6) ||\n\t    !strncmp(software,\"Nikon Scan\",10) ||\n\t    !strcmp (software,\"Digital Photo Professional\"))\n\t  is_raw = 0;\n\tbreak;\n      case 306:\t\t\t\t/* DateTime */\n\tget_timestamp(0);\n\tbreak;\n      case 315:\t\t\t\t/* Artist */\n\tfread (artist, 64, 1, ifp);\n\tbreak;\n      case 322:\t\t\t\t/* TileWidth */\n\ttiff_ifd[ifd].t_tile_width = getint(type);\n\tbreak;\n      case 323:\t\t\t\t/* TileLength */\n\ttiff_ifd[ifd].t_tile_length = getint(type);\n\tbreak;\n      case 324:\t\t\t\t/* TileOffsets */\n\ttiff_ifd[ifd].offset = len > 1 ? ftell(ifp) : get4();\n\tif (len == 4) {\n\t  load_raw = &CLASS sinar_4shot_load_raw;\n\t  is_raw = 5;\n\t}\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 325:\t\t\t\t/* TileByteCount */\n          tiff_ifd[ifd].tile_maxbytes = 0;\n          for(int jj=0;jj<len;jj++)\n              {\n                  int s = get4();\n                  if(s > tiff_ifd[ifd].tile_maxbytes) tiff_ifd[ifd].tile_maxbytes=s;\n              }\n\tbreak;\n#endif\n      case 330:\t\t\t\t/* SubIFDs */\n\tif (!strcmp(model,\"DSLR-A100\") && tiff_ifd[ifd].t_width == 3872) {\n\t  load_raw = &CLASS sony_arw_load_raw;\n\t  data_offset = get4()+base;\n\t  ifd++;  break;\n\t}\n\twhile (len--) {\n\t  i = ftell(ifp);\n\t  fseek (ifp, get4()+base, SEEK_SET);\n\t  if (parse_tiff_ifd (base)) break;\n\t  fseek (ifp, i+4, SEEK_SET);\n\t}\n\tbreak;\n      case 400:\n\tstrcpy (make, \"Sarnoff\");\n\tmaximum = 0xfff;\n\tbreak;\n      case 28688:\n\tFORC4 sony_curve[c+1] = get2() >> 2 & 0xfff;\n\tfor (i=0; i < 5; i++)\n\t  for (j = sony_curve[i]+1; j <= sony_curve[i+1]; j++)\n\t    curve[j] = curve[j-1] + (1 << i);\n\tbreak;\n      case 29184: sony_offset = get4();  break;\n      case 29185: sony_length = get4();  break;\n      case 29217: sony_key    = get4();  break;\n      case 29264:\n\tparse_minolta (ftell(ifp));\n\traw_width = 0;\n\tbreak;\n      case 29443:\n\tFORC4 cam_mul[c ^ (c < 2)] = get2();\n\tbreak;\n      case 29459:\n\tFORC4 cam_mul[c] = get2();\n\ti = (cam_mul[1] == 1024 && cam_mul[2] == 1024) << 1;\n\tSWAP (cam_mul[i],cam_mul[i+1])\n\tbreak;\n      case 33405:\t\t\t/* Model2 */\n\tfgets (model2, 64, ifp);\n\tbreak;\n      case 33422:\t\t\t/* CFAPattern */\n      case 64777:\t\t\t/* Kodak P-series */\n\tif ((plen=len) > 16) plen = 16;\n\tfread (cfa_pat, 1, plen, ifp);\n\tfor (colors=cfa=i=0; i < plen; i++) {\n\t  colors += !(cfa & (1 << cfa_pat[i]));\n\t  cfa |= 1 << cfa_pat[i];\n\t}\n\tif (cfa == 070) memcpy (cfa_pc,\"\\003\\004\\005\",3);\t/* CMY */\n\tif (cfa == 072) memcpy (cfa_pc,\"\\005\\003\\004\\001\",4);\t/* GMCY */\n\tgoto guess_cfa_pc;\n      case 33424:\n      case 65024:\n\tfseek (ifp, get4()+base, SEEK_SET);\n\tparse_kodak_ifd (base);\n\tbreak;\n      case 33434:\t\t\t/* ExposureTime */\n\tshutter = getreal(type);\n\tbreak;\n      case 33437:\t\t\t/* FNumber */\n\taperture = getreal(type);\n\tbreak;\n      case 34306:\t\t\t/* Leaf white balance */\n\tFORC4 cam_mul[c ^ 1] = 4096.0 / get2();\n\tbreak;\n      case 34307:\t\t\t/* Leaf CatchLight color matrix */\n\tfread (software, 1, 7, ifp);\n\tif (strncmp(software,\"MATRIX\",6)) break;\n\tcolors = 4;\n\tfor (raw_color = i=0; i < 3; i++) {\n\t  FORC4 fscanf (ifp, \"%f\", &rgb_cam[i][c^1]);\n\t  if (!use_camera_wb) continue;\n\t  num = 0;\n\t  FORC4 num += rgb_cam[i][c];\n\t  FORC4 rgb_cam[i][c] /= num;\n\t}\n\tbreak;\n      case 34310:\t\t\t/* Leaf metadata */\n\tparse_mos (ftell(ifp));\n      case 34303:\n\tstrcpy (make, \"Leaf\");\n\tbreak;\n      case 34665:\t\t\t/* EXIF tag */\n\tfseek (ifp, get4()+base, SEEK_SET);\n\tparse_exif (base);\n\tbreak;\n      case 34853:\t\t\t/* GPSInfo tag */\n\tfseek (ifp, get4()+base, SEEK_SET);\n\tparse_gps (base);\n\tbreak;\n      case 34675:\t\t\t/* InterColorProfile */\n      case 50831:\t\t\t/* AsShotICCProfile */\n\tprofile_offset = ftell(ifp);\n\tprofile_length = len;\n\tbreak;\n      case 37122:\t\t\t/* CompressedBitsPerPixel */\n\tkodak_cbpp = get4();\n\tbreak;\n      case 37386:\t\t\t/* FocalLength */\n\tfocal_len = getreal(type);\n\tbreak;\n      case 37393:\t\t\t/* ImageNumber */\n\tshot_order = getint(type);\n\tbreak;\n      case 37400:\t\t\t/* old Kodak KDC tag */\n\tfor (raw_color = i=0; i < 3; i++) {\n\t  getreal(type);\n\t  FORC3 rgb_cam[i][c] = getreal(type);\n\t}\n\tbreak;\n      case 46275:\t\t\t/* Imacon tags */\n\tstrcpy (make, \"Imacon\");\n\tdata_offset = ftell(ifp);\n\tima_len = len;\n\tbreak;\n      case 46279:\n\tif (!ima_len) break;\n\tfseek (ifp, 38, SEEK_CUR);\n      case 46274:\n\tfseek (ifp, 40, SEEK_CUR);\n\traw_width  = get4();\n\traw_height = get4();\n\tleft_margin = get4() & 7;\n\twidth = raw_width - left_margin - (get4() & 7);\n\ttop_margin = get4() & 7;\n\theight = raw_height - top_margin - (get4() & 7);\n\tif (raw_width == 7262 && ima_len == 234317952 ) {\n\t  height = 5412;\n\t  width  = 7216;\n\t  left_margin = 7;\n          filters=0;\n\t} else \tif (raw_width == 7262) {\n\t  height = 5444;\n\t  width  = 7244;\n\t  left_margin = 7;\n\t}\n\tfseek (ifp, 52, SEEK_CUR);\n\tFORC3 cam_mul[c] = getreal(11);\n\tfseek (ifp, 114, SEEK_CUR);\n\tflip = (get2() >> 7) * 90;\n\tif (width * height * 6 == ima_len) {\n\t  if (flip % 180 == 90) SWAP(width,height);\n\t  raw_width = width;\n\t  raw_height = height;\n\t  left_margin = top_margin = filters = flip = 0;\n\t}\n\tsprintf (model, \"Ixpress %d-Mp\", height*width/1000000);\n\tload_raw = &CLASS imacon_full_load_raw;\n\tif (filters) {\n\t  if (left_margin & 1) filters = 0x61616161;\n\t  load_raw = &CLASS unpacked_load_raw;\n\t}\n\tmaximum = 0xffff;\n\tbreak;\n      case 50454:\t\t\t/* Sinar tag */\n      case 50455:\n\tif (!(cbuf = (char *) malloc(len))) break;\n\tfread (cbuf, 1, len, ifp);\n\tfor (cp = cbuf-1; cp && cp < cbuf+len; cp = strchr(cp,'\\n'))\n\t  if (!strncmp (++cp,\"Neutral \",8))\n\t    sscanf (cp+8, \"%f %f %f\", cam_mul, cam_mul+1, cam_mul+2);\n\tfree (cbuf);\n\tbreak;\n      case 50458:\n\tif (!make[0]) strcpy (make, \"Hasselblad\");\n\tbreak;\n      case 50459:\t\t\t/* Hasselblad tag */\n\ti = order;\n\tj = ftell(ifp);\n\tc = tiff_nifds;\n\torder = get2();\n\tfseek (ifp, j+(get2(),get4()), SEEK_SET);\n\tparse_tiff_ifd (j);\n\tmaximum = 0xffff;\n\ttiff_nifds = c;\n\torder = i;\n\tbreak;\n      case 50706:\t\t\t/* DNGVersion */\n\tFORC4 dng_version = (dng_version << 8) + fgetc(ifp);\n\tif (!make[0]) strcpy (make, \"DNG\");\n\tis_raw = 1;\n\tbreak;\n      case 50710:\t\t\t/* CFAPlaneColor */\n\tif (len > 4) len = 4;\n\tcolors = len;\n\tfread (cfa_pc, 1, colors, ifp);\nguess_cfa_pc:\n\tFORCC tab[cfa_pc[c]] = c;\n\tcdesc[c] = 0;\n\tfor (i=16; i--; )\n\t  filters = filters << 2 | tab[cfa_pat[i % plen]];\n\tbreak;\n      case 50711:\t\t\t/* CFALayout */\n\tif (get2() == 2) {\n\t  fuji_width = 1;\n\t  filters = 0x49494949;\n\t}\n\tbreak;\n      case 291:\n      case 50712:\t\t\t/* LinearizationTable */\n\tlinear_table (len);\n\tbreak;\n      case 50713:\t\t\t/* BlackLevelRepeatDim */\n\tblrr = get2();\n\tblrc = get2();\n\tbreak;\n      case 61450:\n\tblrr = blrc = 2;\n      case 50714:\t\t\t/* BlackLevel */\n\tblack = getreal(type);\n\tif (!filters || !~filters) break;\n\tdblack[0] = black;\n\tdblack[1] = (blrc == 2) ? getreal(type):dblack[0];\n\tdblack[2] = (blrr == 2) ? getreal(type):dblack[0];\n\tdblack[3] = (blrc == 2 && blrr == 2) ? getreal(type):dblack[1];\n\tif (colors == 3)\n\t  filters |= ((filters >> 2 & 0x22222222) |\n\t\t      (filters << 2 & 0x88888888)) & filters << 1;\n\tFORC4 cblack[filters >> (c << 1) & 3] = dblack[c];\n\tblack = 0;\n\tbreak;\n      case 50715:\t\t\t/* BlackLevelDeltaH */\n      case 50716:\t\t\t/* BlackLevelDeltaV */\n\tfor (num=i=0; i < len; i++)\n\t  num += getreal(type);\n\tblack += num/len + 0.5;\n\tbreak;\n      case 50717:\t\t\t/* WhiteLevel */\n\tmaximum = getint(type);\n\tbreak;\n      case 50718:\t\t\t/* DefaultScale */\n\tpixel_aspect  = getreal(type);\n\tpixel_aspect /= getreal(type);\n\tbreak;\n      case 50721:\t\t\t/* ColorMatrix1 */\n      case 50722:\t\t\t/* ColorMatrix2 */\n\tFORCC for (j=0; j < 3; j++)\n\t  cm[c][j] = getreal(type);\n\tuse_cm = 1;\n\tbreak;\n      case 50723:\t\t\t/* CameraCalibration1 */\n      case 50724:\t\t\t/* CameraCalibration2 */\n\tfor (i=0; i < colors; i++)\n\t  FORCC cc[i][c] = getreal(type);\n\tbreak;\n      case 50727:\t\t\t/* AnalogBalance */\n\tFORCC ab[c] = getreal(type);\n\tbreak;\n      case 50728:\t\t\t/* AsShotNeutral */\n\tFORCC asn[c] = getreal(type);\n\tbreak;\n      case 50729:\t\t\t/* AsShotWhiteXY */\n\txyz[0] = getreal(type);\n\txyz[1] = getreal(type);\n\txyz[2] = 1 - xyz[0] - xyz[1];\n\tFORC3 xyz[c] /= d65_white[c];\n\tbreak;\n      case 50740:\t\t\t/* DNGPrivateData */\n\tif (dng_version) break;\n\tparse_minolta (j = get4()+base);\n\tfseek (ifp, j, SEEK_SET);\n\tparse_tiff_ifd (base);\n\tbreak;\n      case 50752:\n\tread_shorts (cr2_slice, 3);\n\tbreak;\n      case 50829:\t\t\t/* ActiveArea */\n\ttop_margin = getint(type);\n\tleft_margin = getint(type);\n\theight = getint(type) - top_margin;\n\twidth = getint(type) - left_margin;\n\tbreak;\n      case 50830:\t\t\t/* MaskedAreas */\n        for (i=0; i < len && i < 32; i++)\n\t  mask[0][i] = getint(type);\n\tblack = 0;\n\tbreak;\n      case 51009:\t\t\t/* OpcodeList2 */\n\tmeta_offset = ftell(ifp);\n\tbreak;\n      case 64772:\t\t\t/* Kodak P-series */\n\tif (len < 13) break;\n\tfseek (ifp, 16, SEEK_CUR);\n\tdata_offset = get4();\n\tfseek (ifp, 28, SEEK_CUR);\n\tdata_offset += get4();\n\tload_raw = &CLASS packed_load_raw;\n\tbreak;\n      case 65026:\n\tif (type == 2) fgets (model2, 64, ifp);\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n  if (sony_length && (buf = (unsigned *) malloc(sony_length))) {\n    fseek (ifp, sony_offset, SEEK_SET);\n    fread (buf, sony_length, 1, ifp);\n    sony_decrypt (buf, sony_length/4, 1, sony_key);\n#ifndef LIBRAW_LIBRARY_BUILD\n    sfp = ifp;\n    if ((ifp = tmpfile())) {\n      fwrite (buf, sony_length, 1, ifp);\n      fseek (ifp, 0, SEEK_SET);\n      parse_tiff_ifd (-sony_offset);\n      fclose (ifp);\n    }\n    ifp = sfp;\n#else\n    if( !ifp->tempbuffer_open(buf,sony_length))\n        {\n            parse_tiff_ifd(-sony_offset);\n            ifp->tempbuffer_close();\n        }\n#endif\n    free (buf);\n  }\n  for (i=0; i < colors; i++)\n    FORCC cc[i][c] *= ab[i];\n  if (use_cm) {\n    FORCC for (i=0; i < 3; i++)\n      for (cam_xyz[c][i]=j=0; j < colors; j++)\n\tcam_xyz[c][i] += cc[c][j] * cm[j][i] * xyz[i];\n    cam_xyz_coeff (cam_xyz);\n  }\n  if (asn[0]) {\n    cam_mul[3] = 0;\n    FORCC cam_mul[c] = 1 / asn[c];\n  }\n  if (!use_cm)\n    FORCC pre_mul[c] /= cc[c][c];\n  return 0;\n}\n\nint CLASS parse_tiff (int base)\n{\n  int doff;\n\n  fseek (ifp, base, SEEK_SET);\n  order = get2();\n  if (order != 0x4949 && order != 0x4d4d) return 0;\n  get2();\n  while ((doff = get4())) {\n    fseek (ifp, doff+base, SEEK_SET);\n    if (parse_tiff_ifd (base)) break;\n  }\n  return 1;\n}\n\nvoid CLASS apply_tiff()\n{\n  int max_samp=0, raw=-1, thm=-1, i;\n  struct jhead jh;\n\n  thumb_misc = 16;\n  if (thumb_offset) {\n    fseek (ifp, thumb_offset, SEEK_SET);\n    if (ljpeg_start (&jh, 1)) {\n      thumb_misc   = jh.bits;\n      thumb_width  = jh.wide;\n      thumb_height = jh.high;\n    }\n  }\n  for (i=0; i < tiff_nifds; i++) {\n    if (max_samp < tiff_ifd[i].samples)\n\tmax_samp = tiff_ifd[i].samples;\n    if (max_samp > 3) max_samp = 3;\n    if ((tiff_ifd[i].comp != 6 || tiff_ifd[i].samples != 3) &&\n\t(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&\n\ttiff_ifd[i].t_width*tiff_ifd[i].t_height > raw_width*raw_height) {\n      raw_width     = tiff_ifd[i].t_width;\n      raw_height    = tiff_ifd[i].t_height;\n      tiff_bps      = tiff_ifd[i].bps;\n      tiff_compress = tiff_ifd[i].comp;\n      data_offset   = tiff_ifd[i].offset;\n      tiff_flip     = tiff_ifd[i].t_flip;\n      tiff_samples  = tiff_ifd[i].samples;\n      tile_width    = tiff_ifd[i].t_tile_width;\n      tile_length   = tiff_ifd[i].t_tile_length;\n#ifdef LIBRAW_LIBRARY_BUILD\n      data_size     = tile_length < INT_MAX && tile_length>0 ? tiff_ifd[i].tile_maxbytes: tiff_ifd[i].bytes;\n#endif\n      raw = i;\n    }\n  }\n  if (!tile_width ) tile_width  = INT_MAX;\n  if (!tile_length) tile_length = INT_MAX;\n  for (i=tiff_nifds; i--; )\n    if (tiff_ifd[i].t_flip) tiff_flip = tiff_ifd[i].t_flip;\n  if (raw >= 0 && !load_raw)\n    switch (tiff_compress) {\n      case 32767:\n\tif (tiff_ifd[raw].bytes == raw_width*raw_height) {\n\t  tiff_bps = 12;\n\t  load_raw = &CLASS sony_arw2_load_raw;\t\t\tbreak;\n\t}\n\tif (tiff_ifd[raw].bytes*8 != raw_width*raw_height*tiff_bps) {\n\t  raw_height += 8;\n\t  load_raw = &CLASS sony_arw_load_raw;\t\t\tbreak;\n\t}\n\tload_flags = 79;\n      case 32769:\n\tload_flags++;\n      case 32770:\n      case 32773: goto slr;\n      case 0:  case 1:\n\tif (tiff_ifd[raw].bytes*5 == raw_width*raw_height*8) {\n\t  load_flags = 81;\n\t  tiff_bps = 12;\n\t} slr:\n\tswitch (tiff_bps) {\n\t  case  8: load_raw = &CLASS eight_bit_load_raw;\tbreak;\n\t  case 12: if (tiff_ifd[raw].phint == 2)\n\t\t     load_flags = 6;\n\t\t   load_raw = &CLASS packed_load_raw;\t\tbreak;\n\t  case 14: load_flags = 0;\n\t  case 16: load_raw = &CLASS unpacked_load_raw;\t\tbreak;\n\t}\n\tbreak;\n      case 6:  case 7:  case 99:\n\tload_raw = &CLASS lossless_jpeg_load_raw;\t\tbreak;\n      case 262:\n\tload_raw = &CLASS kodak_262_load_raw;\t\t\tbreak;\n      case 34713:\n\tif ((raw_width+9)/10*16*raw_height == tiff_ifd[raw].bytes) {\n\t  load_raw = &CLASS packed_load_raw;\n\t  load_flags = 1;\n\t} else if (raw_width*raw_height*2 == tiff_ifd[raw].bytes) {\n\t  load_raw = &CLASS unpacked_load_raw;\n\t  load_flags = 4;\n\t  order = 0x4d4d;\n\t} else\n\t  load_raw = &CLASS nikon_load_raw;\t\t\tbreak;\n      case 34892:\n\tload_raw = &CLASS lossy_dng_load_raw;\t\t\tbreak;\n      case 65535:\n\tload_raw = &CLASS pentax_load_raw;\t\t\tbreak;\n      case 65000:\n\tswitch (tiff_ifd[raw].phint) {\n\t  case 2: load_raw = &CLASS kodak_rgb_load_raw;   filters = 0;  break;\n\t  case 6: load_raw = &CLASS kodak_ycbcr_load_raw; filters = 0;  break;\n\t  case 32803: load_raw = &CLASS kodak_65000_load_raw;\n\t}\n      case 32867: break;\n      default: is_raw = 0;\n    }\n  if (!dng_version)\n    if ( (tiff_samples == 3 && tiff_ifd[raw].bytes &&\n\t  tiff_bps != 14 && tiff_bps != 2048 && \n\t  tiff_compress != 32769 && tiff_compress != 32770)\n      || (tiff_bps == 8 && !strstr(make,\"KODAK\") && !strstr(make,\"Kodak\") &&\n\t  !strstr(model2,\"DEBUG RAW\")))\n      is_raw = 0;\n  for (i=0; i < tiff_nifds; i++)\n    if (i != raw && tiff_ifd[i].samples == max_samp &&\n\ttiff_ifd[i].t_width * tiff_ifd[i].t_height / SQR(tiff_ifd[i].bps+1) >\n\t      thumb_width *       thumb_height / SQR(thumb_misc+1)\n\t&& tiff_ifd[i].comp != 34892) {\n      thumb_width  = tiff_ifd[i].t_width;\n      thumb_height = tiff_ifd[i].t_height;\n      thumb_offset = tiff_ifd[i].offset;\n      thumb_length = tiff_ifd[i].bytes;\n      thumb_misc   = tiff_ifd[i].bps;\n      thm = i;\n    }\n  if (thm >= 0) {\n    thumb_misc |= tiff_ifd[thm].samples << 5;\n    switch (tiff_ifd[thm].comp) {\n      case 0:\n\twrite_thumb = &CLASS layer_thumb;\n\tbreak;\n      case 1:\n\tif (tiff_ifd[thm].bps <= 8)\n\t  write_thumb = &CLASS ppm_thumb;\n\telse if (!strcmp(make,\"Imacon\"))\n\t  write_thumb = &CLASS ppm16_thumb;\n\telse\n\t  thumb_load_raw = &CLASS kodak_thumb_load_raw;\n\tbreak;\n      case 65000:\n\tthumb_load_raw = tiff_ifd[thm].phint == 6 ?\n\t\t&CLASS kodak_ycbcr_load_raw : &CLASS kodak_rgb_load_raw;\n    }\n  }\n}\n\nvoid CLASS parse_minolta (int base)\n{\n  int save, tag, len, offset, high=0, wide=0, i, c;\n  short sorder=order;\n\n  fseek (ifp, base, SEEK_SET);\n  if (fgetc(ifp) || fgetc(ifp)-'M' || fgetc(ifp)-'R') return;\n  order = fgetc(ifp) * 0x101;\n  offset = base + get4() + 8;\n  while ((save=ftell(ifp)) < offset) {\n    for (tag=i=0; i < 4; i++)\n      tag = tag << 8 | fgetc(ifp);\n    len = get4();\n    switch (tag) {\n      case 0x505244:\t\t\t\t/* PRD */\n\tfseek (ifp, 8, SEEK_CUR);\n\thigh = get2();\n\twide = get2();\n\tbreak;\n      case 0x574247:\t\t\t\t/* WBG */\n\tget4();\n\ti = strcmp(model,\"DiMAGE A200\") ? 0:3;\n\tFORC4 cam_mul[c ^ (c >> 1) ^ i] = get2();\n\tbreak;\n      case 0x545457:\t\t\t\t/* TTW */\n\tparse_tiff (ftell(ifp));\n\tdata_offset = offset;\n    }\n    fseek (ifp, save+len+8, SEEK_SET);\n  }\n  raw_height = high;\n  raw_width  = wide;\n  order = sorder;\n}\n\n/*\n   Many cameras have a \"debug mode\" that writes JPEG and raw\n   at the same time.  The raw file has no header, so try to\n   to open the matching JPEG file and read its metadata.\n */\nvoid CLASS parse_external_jpeg()\n{\n  const char *file, *ext;\n  char *jname, *jfile, *jext;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *save=ifp;\n#else\n#if defined (WIN32) && !defined(__MINGW32__)\n  if(ifp->wfname())\n  {\n\t  std::wstring rawfile(ifp->wfname());\n\t  rawfile.replace(rawfile.length()-3,3,L\"JPG\");\n\t  if(!ifp->subfile_open(rawfile.c_str()))\n\t  {\n\t\t  parse_tiff (12);\n\t\t  thumb_offset = 0;\n\t\t  is_raw = 1;\n\t\t  ifp->subfile_close();\n\t  }\n\t  else\n\t\t  imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n\t return;\n  }\n#endif\n  if(!ifp->fname())\n      {\n          imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n          return;\n      }\n#endif\n\n  ext  = strrchr (ifname, '.');\n  file = strrchr (ifname, '/');\n  if (!file) file = strrchr (ifname, '\\\\');\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!file) file = ifname-1;\n#else\n  if (!file) file = (char*)ifname-1;\n#endif\n  file++;\n  if (!ext || strlen(ext) != 4 || ext-file != 8) return;\n  jname = (char *) malloc (strlen(ifname) + 1);\n  merror (jname, \"parse_external_jpeg()\");\n  strcpy (jname, ifname);\n  jfile = file - ifname + jname;\n  jext  = ext  - ifname + jname;\n  if (strcasecmp (ext, \".jpg\")) {\n    strcpy (jext, isupper(ext[1]) ? \".JPG\":\".jpg\");\n    if (isdigit(*file)) {\n      memcpy (jfile, file+4, 4);\n      memcpy (jfile+4, file, 4);\n    }\n  } else\n    while (isdigit(*--jext)) {\n      if (*jext != '9') {\n\t(*jext)++;\n\tbreak;\n      }\n      *jext = '0';\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (strcmp (jname, ifname)) {\n    if ((ifp = fopen (jname, \"rb\"))) {\n#ifdef DCRAW_VERBOSE\n      if (verbose)\n\tfprintf (stderr,_(\"Reading metadata from %s ...\\n\"), jname);\n#endif\n      parse_tiff (12);\n      thumb_offset = 0;\n      is_raw = 1;\n      fclose (ifp);\n    }\n  }\n#else\n  if (strcmp (jname, ifname)) \n      {\n          if(!ifp->subfile_open(jname))\n              {\n                  parse_tiff (12);\n                  thumb_offset = 0;\n                  is_raw = 1;\n                  ifp->subfile_close();\n              }\n          else\n              imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n      }\n#endif\n  if (!timestamp)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n#endif\n#ifdef DCRAW_VERBOSE\n          fprintf (stderr,_(\"Failed to read metadata from %s\\n\"), jname);\n#endif\n      }\n  free (jname);\n#ifndef LIBRAW_LIBRARY_BUILD\n  ifp = save;\n#endif\n}\n\n/*\n   CIFF block 0x1030 contains an 8x8 white sample.\n   Load this into white[][] for use in scale_colors().\n */\nvoid CLASS ciff_block_1030()\n{\n  static const ushort key[] = { 0x410, 0x45f3 };\n  int i, bpp, row, col, vbits=0;\n  unsigned long bitbuf=0;\n\n  if ((get2(),get4()) != 0x80008 || !get4()) return;\n  bpp = get2();\n  if (bpp != 10 && bpp != 12) return;\n  for (i=row=0; row < 8; row++)\n    for (col=0; col < 8; col++) {\n      if (vbits < bpp) {\n\tbitbuf = bitbuf << 16 | (get2() ^ key[i++ & 1]);\n\tvbits += 16;\n      }\n      white[row][col] =\n\tbitbuf << (LONG_BIT - vbits) >> (LONG_BIT - bpp);\n      vbits -= bpp;\n    }\n}\n\n/*\n   Parse a CIFF file, better known as Canon CRW format.\n */\nvoid CLASS parse_ciff (int offset, int length)\n{\n  int tboff, nrecs, c, type, len, save, wbi=-1;\n  ushort key[] = { 0x410, 0x45f3 };\n\n  fseek (ifp, offset+length-4, SEEK_SET);\n  tboff = get4() + offset;\n  fseek (ifp, tboff, SEEK_SET);\n  nrecs = get2();\n  if (nrecs > 100) return;\n  while (nrecs--) {\n    type = get2();\n    len  = get4();\n    save = ftell(ifp) + 4;\n    fseek (ifp, offset+get4(), SEEK_SET);\n    if ((((type >> 8) + 8) | 8) == 0x38)\n      parse_ciff (ftell(ifp), len);\t/* Parse a sub-table */\n\n    if (type == 0x0810)\n      fread (artist, 64, 1, ifp);\n    if (type == 0x080a) {\n      fread (make, 64, 1, ifp);\n      fseek (ifp, strlen(make) - 63, SEEK_CUR);\n      fread (model, 64, 1, ifp);\n    }\n    if (type == 0x1810) {\n      fseek (ifp, 12, SEEK_CUR);\n      flip = get4();\n    }\n    if (type == 0x1835)\t\t\t/* Get the decoder table */\n      tiff_compress = get4();\n    if (type == 0x2007) {\n      thumb_offset = ftell(ifp);\n      thumb_length = len;\n    }\n    if (type == 0x1818) {\n      shutter = pow (2, -int_to_float((get4(),get4())));\n      aperture = pow (2, int_to_float(get4())/2);\n    }\n    if (type == 0x102a) {\n      iso_speed = pow (2, (get4(),get2())/32.0 - 4) * 50;\n      aperture  = pow (2, (get2(),(short)get2())/64.0);\n      shutter   = pow (2,-((short)get2())/32.0);\n      wbi = (get2(),get2());\n      if (wbi > 17) wbi = 0;\n      fseek (ifp, 32, SEEK_CUR);\n      if (shutter > 1e6) shutter = get2()/10.0;\n    }\n    if (type == 0x102c) {\n      if (get2() > 512) {\t\t/* Pro90, G1 */\n\tfseek (ifp, 118, SEEK_CUR);\n\tFORC4 cam_mul[c ^ 2] = get2();\n      } else {\t\t\t\t/* G2, S30, S40 */\n\tfseek (ifp, 98, SEEK_CUR);\n\tFORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2();\n      }\n    }\n    if (type == 0x0032) {\n      if (len == 768) {\t\t\t/* EOS D30 */\n\tfseek (ifp, 72, SEEK_CUR);\n\tFORC4 cam_mul[c ^ (c >> 1)] = 1024.0 / get2();\n\tif (!wbi) cam_mul[0] = -1;\t/* use my auto white balance */\n      } else if (!cam_mul[0]) {\n\tif (get2() == key[0])\t\t/* Pro1, G6, S60, S70 */\n\t  c = (strstr(model,\"Pro1\") ?\n\t      \"012346000000000000\":\"01345:000000006008\")[wbi]-'0'+ 2;\n\telse {\t\t\t\t/* G3, G5, S45, S50 */\n\t  c = \"023457000000006000\"[wbi]-'0';\n\t  key[0] = key[1] = 0;\n\t}\n\tfseek (ifp, 78 + c*8, SEEK_CUR);\n\tFORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2() ^ key[c & 1];\n\tif (!wbi) cam_mul[0] = -1;\n      }\n    }\n    if (type == 0x10a9) {\t\t/* D60, 10D, 300D, and clones */\n      if (len > 66) wbi = \"0134567028\"[wbi]-'0';\n      fseek (ifp, 2 + wbi*8, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n    }\n    if (type == 0x1030 && (0x18040 >> wbi & 1))\n      ciff_block_1030();\t\t/* all that don't have 0x10a9 */\n    if (type == 0x1031) {\n      raw_width = (get2(),get2());\n      raw_height = get2();\n    }\n    if (type == 0x5029) {\n      focal_len = len >> 16;\n      if ((len & 0xffff) == 2) focal_len /= 32;\n    }\n    if (type == 0x5813) flash_used = int_to_float(len);\n    if (type == 0x5814) canon_ev   = int_to_float(len);\n    if (type == 0x5817) shot_order = len;\n    if (type == 0x5834) unique_id  = len;\n    if (type == 0x580e) timestamp  = len;\n    if (type == 0x180e) timestamp  = get4();\n#ifdef LOCALTIME\n    if ((type | 0x4000) == 0x580e)\n      timestamp = mktime (gmtime (&timestamp));\n#endif\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS parse_rollei()\n{\n  char line[128], *val;\n  struct tm t;\n\n  fseek (ifp, 0, SEEK_SET);\n  memset (&t, 0, sizeof t);\n  do {\n    fgets (line, 128, ifp);\n    if ((val = strchr(line,'=')))\n      *val++ = 0;\n    else\n      val = line + strlen(line);\n    if (!strcmp(line,\"DAT\"))\n      sscanf (val, \"%d.%d.%d\", &t.tm_mday, &t.tm_mon, &t.tm_year);\n    if (!strcmp(line,\"TIM\"))\n      sscanf (val, \"%d:%d:%d\", &t.tm_hour, &t.tm_min, &t.tm_sec);\n    if (!strcmp(line,\"HDR\"))\n      thumb_offset = atoi(val);\n    if (!strcmp(line,\"X  \"))\n      raw_width = atoi(val);\n    if (!strcmp(line,\"Y  \"))\n      raw_height = atoi(val);\n    if (!strcmp(line,\"TX \"))\n      thumb_width = atoi(val);\n    if (!strcmp(line,\"TY \"))\n      thumb_height = atoi(val);\n  } while (strncmp(line,\"EOHD\",4));\n  data_offset = thumb_offset + thumb_width * thumb_height * 2;\n  t.tm_year -= 1900;\n  t.tm_mon -= 1;\n  if (mktime(&t) > 0)\n    timestamp = mktime(&t);\n  strcpy (make, \"Rollei\");\n  strcpy (model,\"d530flex\");\n  write_thumb = &CLASS rollei_thumb;\n}\n\nvoid CLASS parse_sinar_ia()\n{\n  int entries, off;\n  char str[8], *cp;\n\n  order = 0x4949;\n  fseek (ifp, 4, SEEK_SET);\n  entries = get4();\n  fseek (ifp, get4(), SEEK_SET);\n  while (entries--) {\n    off = get4(); get4();\n    fread (str, 8, 1, ifp);\n    if (!strcmp(str,\"META\"))   meta_offset = off;\n    if (!strcmp(str,\"THUMB\")) thumb_offset = off;\n    if (!strcmp(str,\"RAW0\"))   data_offset = off;\n  }\n  fseek (ifp, meta_offset+20, SEEK_SET);\n  fread (make, 64, 1, ifp);\n  make[63] = 0;\n  if ((cp = strchr(make,' '))) {\n    strcpy (model, cp+1);\n    *cp = 0;\n  }\n  raw_width  = get2();\n  raw_height = get2();\n  load_raw = &CLASS unpacked_load_raw;\n  thumb_width = (get4(),get2());\n  thumb_height = get2();\n  write_thumb = &CLASS ppm_thumb;\n  maximum = 0x3fff;\n}\n\nvoid CLASS parse_phase_one (int base)\n{\n  unsigned entries, tag, type, len, data, save, i, c;\n  float romm_cam[3][3];\n  char *cp;\n\n  memset (&ph1, 0, sizeof ph1);\n  fseek (ifp, base, SEEK_SET);\n  order = get4() & 0xffff;\n  if (get4() >> 8 != 0x526177) return;\t\t/* \"Raw\" */\n  fseek (ifp, get4()+base, SEEK_SET);\n  entries = get4();\n  get4();\n  while (entries--) {\n    tag  = get4();\n    type = get4();\n    len  = get4();\n    data = get4();\n    save = ftell(ifp);\n    fseek (ifp, base+data, SEEK_SET);\n    switch (tag) {\n      case 0x100:  flip = \"0653\"[data & 3]-'0';  break;\n      case 0x106:\n\tfor (i=0; i < 9; i++)\n\t  romm_cam[0][i] = getreal(11);\n\tromm_coeff (romm_cam);\n\tbreak;\n      case 0x107:\n\tFORC3 cam_mul[c] = getreal(11);\n\tbreak;\n      case 0x108:  raw_width     = data;\tbreak;\n      case 0x109:  raw_height    = data;\tbreak;\n      case 0x10a:  left_margin   = data;\tbreak;\n      case 0x10b:  top_margin    = data;\tbreak;\n      case 0x10c:  width         = data;\tbreak;\n      case 0x10d:  height        = data;\tbreak;\n      case 0x10e:  ph1.format    = data;\tbreak;\n      case 0x10f:  data_offset   = data+base;\tbreak;\n      case 0x110:  meta_offset   = data+base;\n\t\t   meta_length   = len;\t\t\tbreak;\n      case 0x112:  ph1.key_off   = save - 4;\t\tbreak;\n      case 0x210:  ph1.tag_210   = int_to_float(data);\tbreak;\n      case 0x21a:  ph1.tag_21a   = data;\t\tbreak;\n      case 0x21c:  strip_offset  = data+base;\t\tbreak;\n      case 0x21d:  ph1.t_black     = data;\t\tbreak;\n      case 0x222:  ph1.split_col = data;\t\tbreak;\n      case 0x223:  ph1.black_off = data+base;\t\tbreak;\n      case 0x301:\n\tmodel[63] = 0;\n\tfread (model, 1, 63, ifp);\n\tif ((cp = strstr(model,\" camera\"))) *cp = 0;\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n  load_raw = ph1.format < 3 ?\n\t&CLASS phase_one_load_raw : &CLASS phase_one_load_raw_c;\n  maximum = 0xffff;\n  strcpy (make, \"Phase One\");\n  if (model[0]) return;\n  switch (raw_height) {\n    case 2060: strcpy (model,\"LightPhase\");\tbreak;\n    case 2682: strcpy (model,\"H 10\");\t\tbreak;\n    case 4128: strcpy (model,\"H 20\");\t\tbreak;\n    case 5488: strcpy (model,\"H 25\");\t\tbreak;\n  }\n}\n\nvoid CLASS parse_fuji (int offset)\n{\n  unsigned entries, tag, len, save, c;\n\n  fseek (ifp, offset, SEEK_SET);\n  entries = get4();\n  if (entries > 255) return;\n  while (entries--) {\n    tag = get2();\n    len = get2();\n    save = ftell(ifp);\n    if (tag == 0x100) {\n      raw_height = get2();\n      raw_width  = get2();\n    } else if (tag == 0x121) {\n      height = get2();\n      if ((width = get2()) == 4284) width += 3;\n    } else if (tag == 0x130) {\n      fuji_layout = fgetc(ifp) >> 7;\n      fuji_width = !(fgetc(ifp) & 8);\n    } else if (tag == 0x2ff0) {\n      FORC4 cam_mul[c ^ 1] = get2();\n    } else if (tag == 0xc000) {\n      c = order;\n      order = 0x4949;\n      if ((width = get4()) > 10000) width = get4();\n      height = get4();\n      order = c;\n    }\n    fseek (ifp, save+len, SEEK_SET);\n  }\n  height <<= fuji_layout;\n  width  >>= fuji_layout;\n}\n\nint CLASS parse_jpeg (int offset)\n{\n  int len, save, hlen, mark;\n\n  fseek (ifp, offset, SEEK_SET);\n  if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8) return 0;\n\n  while (fgetc(ifp) == 0xff && (mark = fgetc(ifp)) != 0xda) {\n    order = 0x4d4d;\n    len   = get2() - 2;\n    save  = ftell(ifp);\n    if (mark == 0xc0 || mark == 0xc3) {\n      fgetc(ifp);\n      raw_height = get2();\n      raw_width  = get2();\n    }\n    order = get2();\n    hlen  = get4();\n    if (get4() == 0x48454150)\t\t/* \"HEAP\" */\n      parse_ciff (save+hlen, len-hlen);\n    if (parse_tiff (save+6)) apply_tiff();\n    fseek (ifp, save+len, SEEK_SET);\n  }\n  return 1;\n}\n\nvoid CLASS parse_riff()\n{\n  unsigned i, size, end;\n  char tag[4], date[64], month[64];\n  static const char mon[12][4] =\n  { \"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\" };\n  struct tm t;\n\n  order = 0x4949;\n  fread (tag, 4, 1, ifp);\n  size = get4();\n  end = ftell(ifp) + size;\n  if (!memcmp(tag,\"RIFF\",4) || !memcmp(tag,\"LIST\",4)) {\n    get4();\n    while (ftell(ifp)+7 < end)\n      parse_riff();\n  } else if (!memcmp(tag,\"nctg\",4)) {\n    while (ftell(ifp)+7 < end) {\n      i = get2();\n      size = get2();\n      if ((i+1) >> 1 == 10 && size == 20)\n\tget_timestamp(0);\n      else fseek (ifp, size, SEEK_CUR);\n    }\n  } else if (!memcmp(tag,\"IDIT\",4) && size < 64) {\n    fread (date, 64, 1, ifp);\n    date[size] = 0;\n    memset (&t, 0, sizeof t);\n    if (sscanf (date, \"%*s %s %d %d:%d:%d %d\", month, &t.tm_mday,\n\t&t.tm_hour, &t.tm_min, &t.tm_sec, &t.tm_year) == 6) {\n      for (i=0; i < 12 && strcasecmp(mon[i],month); i++);\n      t.tm_mon = i;\n      t.tm_year -= 1900;\n      if (mktime(&t) > 0)\n\ttimestamp = mktime(&t);\n    }\n  } else\n    fseek (ifp, size, SEEK_CUR);\n}\n\nvoid CLASS parse_smal (int offset, int fsize)\n{\n  int ver;\n\n  fseek (ifp, offset+2, SEEK_SET);\n  order = 0x4949;\n  ver = fgetc(ifp);\n  if (ver == 6)\n    fseek (ifp, 5, SEEK_CUR);\n  if (get4() != fsize) return;\n  if (ver > 6) data_offset = get4();\n  raw_height = height = get2();\n  raw_width  = width  = get2();\n  strcpy (make, \"SMaL\");\n  sprintf (model, \"v%d %dx%d\", ver, width, height);\n  if (ver == 6) load_raw = &CLASS smal_v6_load_raw;\n  if (ver == 9) load_raw = &CLASS smal_v9_load_raw;\n}\n\nvoid CLASS parse_cine()\n{\n  unsigned off_head, off_setup, off_image, i;\n\n  order = 0x4949;\n  fseek (ifp, 4, SEEK_SET);\n  is_raw = get2() == 2;\n  fseek (ifp, 14, SEEK_CUR);\n  is_raw *= get4();\n  off_head = get4();\n  off_setup = get4();\n  off_image = get4();\n  timestamp = get4();\n  if ((i = get4())) timestamp = i;\n  fseek (ifp, off_head+4, SEEK_SET);\n  raw_width = get4();\n  raw_height = get4();\n  switch (get2(),get2()) {\n    case  8:  load_raw = &CLASS eight_bit_load_raw;  break;\n    case 16:  load_raw = &CLASS  unpacked_load_raw;\n  }\n  fseek (ifp, off_setup+792, SEEK_SET);\n  strcpy (make, \"CINE\");\n  sprintf (model, \"%d\", get4());\n  fseek (ifp, 12, SEEK_CUR);\n  switch ((i=get4()) & 0xffffff) {\n    case  3:  filters = 0x94949494;  break;\n    case  4:  filters = 0x49494949;  break;\n    default:  is_raw = 0;\n  }\n  fseek (ifp, 72, SEEK_CUR);\n  switch ((get4()+3600) % 360) {\n    case 270:  flip = 4;  break;\n    case 180:  flip = 1;  break;\n    case  90:  flip = 7;  break;\n    case   0:  flip = 2;\n  }\n  cam_mul[0] = getreal(11);\n  cam_mul[2] = getreal(11);\n  maximum = ~(-1 << get4());\n  fseek (ifp, 668, SEEK_CUR);\n  shutter = get4()/1000000000.0;\n  fseek (ifp, off_image, SEEK_SET);\n  if (shot_select < is_raw)\n    fseek (ifp, shot_select*8, SEEK_CUR);\n  data_offset  = (INT64) get4() + 8;\n  data_offset += (INT64) get4() << 32;\n}\n\nvoid CLASS parse_redcine()\n{\n  unsigned i, len, rdvo;\n\n  order = 0x4d4d;\n  is_raw = 0;\n  fseek (ifp, 52, SEEK_SET);\n  width  = get4();\n  height = get4();\n  fseek (ifp, 0, SEEK_END);\n  fseek (ifp, -(i = ftello(ifp) & 511), SEEK_CUR);\n  if (get4() != i || get4() != 0x52454f42) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s: Tail is missing, parsing from head...\\n\"), ifname);\n#endif\n    fseek (ifp, 0, SEEK_SET);\n    while ((len = get4()) != EOF) {\n      if (get4() == 0x52454456)\n\tif (is_raw++ == shot_select)\n\t  data_offset = ftello(ifp) - 8;\n      fseek (ifp, len-8, SEEK_CUR);\n    }\n  } else {\n    rdvo = get4();\n    fseek (ifp, 12, SEEK_CUR);\n    is_raw = get4();\n    fseeko (ifp, rdvo+8 + shot_select*4, SEEK_SET);\n    data_offset = get4();\n  }\n}\n#line 7390 \"dcraw/dcraw.c\"\nchar * CLASS foveon_gets (int offset, char *str, int len)\n{\n  int i;\n  fseek (ifp, offset, SEEK_SET);\n  for (i=0; i < len-1; i++)\n    if ((str[i] = get2()) == 0) break;\n  str[i] = 0;\n  return str;\n}\n\nvoid CLASS parse_foveon()\n{\n  int entries, img=0, off, len, tag, save, i, wide, high, pent, poff[256][2];\n  char name[64], value[64];\n\n  order = 0x4949;\t\t\t/* Little-endian */\n  fseek (ifp, 36, SEEK_SET);\n  flip = get4();\n  fseek (ifp, -4, SEEK_END);\n  fseek (ifp, get4(), SEEK_SET);\n  if (get4() != 0x64434553) return;\t/* SECd */\n  entries = (get4(),get4());\n  while (entries--) {\n    off = get4();\n    len = get4();\n    tag = get4();\n    save = ftell(ifp);\n    fseek (ifp, off, SEEK_SET);\n    if (get4() != (0x20434553 | (tag << 24))) return;\n    switch (tag) {\n      case 0x47414d49:\t\t\t/* IMAG */\n      case 0x32414d49:\t\t\t/* IMA2 */\n\tfseek (ifp, 8, SEEK_CUR);\n\tpent = get4();\n\twide = get4();\n\thigh = get4();\n\tif (wide > raw_width && high > raw_height) {\n\t  switch (pent) {\n\t    case  5:  load_flags = 1;\n\t    case  6:  load_raw = &CLASS foveon_sd_load_raw;  break;\n\t    case 30:  load_raw = &CLASS foveon_dp_load_raw;  break;\n\t    default:  load_raw = 0;\n\t  }\n\t  raw_width  = wide;\n\t  raw_height = high;\n\t  data_offset = off+28;\n\t}\n\tfseek (ifp, off+28, SEEK_SET);\n\tif (fgetc(ifp) == 0xff && fgetc(ifp) == 0xd8\n\t\t&& thumb_length < len-28) {\n\t  thumb_offset = off+28;\n\t  thumb_length = len-28;\n\t  write_thumb = &CLASS jpeg_thumb;\n\t}\n\tif (++img == 2 && !thumb_length) {\n\t  thumb_offset = off+24;\n\t  thumb_width = wide;\n\t  thumb_height = high;\n\t  write_thumb = &CLASS foveon_thumb;\n\t}\n\tbreak;\n      case 0x464d4143:\t\t\t/* CAMF */\n\tmeta_offset = off+8;\n\tmeta_length = len-28;\n\tbreak;\n      case 0x504f5250:\t\t\t/* PROP */\n\tpent = (get4(),get4());\n\tfseek (ifp, 12, SEEK_CUR);\n\toff += pent*8 + 24;\n\tif ((unsigned) pent > 256) pent=256;\n\tfor (i=0; i < pent*2; i++)\n\t  poff[0][i] = off + get4()*2;\n\tfor (i=0; i < pent; i++) {\n\t  foveon_gets (poff[i][0], name, 64);\n\t  foveon_gets (poff[i][1], value, 64);\n\t  if (!strcmp (name, \"ISO\"))\n\t    iso_speed = atoi(value);\n\t  if (!strcmp (name, \"CAMMANUF\"))\n\t    strcpy (make, value);\n\t  if (!strcmp (name, \"CAMMODEL\"))\n\t    strcpy (model, value);\n\t  if (!strcmp (name, \"WB_DESC\"))\n\t    strcpy (model2, value);\n\t  if (!strcmp (name, \"TIME\"))\n\t    timestamp = atoi(value);\n\t  if (!strcmp (name, \"EXPTIME\"))\n\t    shutter = atoi(value) / 1000000.0;\n\t  if (!strcmp (name, \"APERTURE\"))\n\t    aperture = atof(value);\n\t  if (!strcmp (name, \"FLENGTH\"))\n\t    focal_len = atof(value);\n\t}\n#ifdef LOCALTIME\n\ttimestamp = mktime (gmtime (&timestamp));\n#endif\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n  is_foveon = 1;\n}\n#line 7493 \"dcraw/dcraw.c\"\n/*\n   All matrices are from Adobe DNG Converter unless otherwise noted.\n */\nvoid CLASS adobe_coeff (const char *t_make, const char *t_model)\n{\n  static const struct {\n    const char *prefix;\n    short t_black, t_maximum, trans[12];\n  } table[] = {\n    { \"AGFAPHOTO DC-833m\", 0, 0,\t/* DJC */\n\t{ 11438,-3762,-1115,-2409,9914,2497,-1227,2295,5300 } },\n    { \"Apple QuickTake\", 0, 0,\t\t/* DJC */\n\t{ 21392,-5653,-3353,2406,8010,-415,7166,1427,2078 } },\n    { \"Canon EOS D2000\", 0, 0,\n\t{ 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\n    { \"Canon EOS D6000\", 0, 0,\n\t{ 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\n    { \"Canon EOS D30\", 0, 0,\n\t{ 9805,-2689,-1312,-5803,13064,3068,-2438,3075,8775 } },\n    { \"Canon EOS D60\", 0, 0xfa0,\n\t{ 6188,-1341,-890,-7168,14489,2937,-2640,3228,8483 } },\n    { \"Canon EOS 5D Mark III\", 0, 0x3c80,\n\t{ 6722,-635,-963,-4287,12460,2028,-908,2162,5668 } },\n    { \"Canon EOS 5D Mark II\", 0, 0x3cf0,\n\t{ 4716,603,-830,-7798,15474,2480,-1496,1937,6651 } },\n    { \"Canon EOS 5D\", 0, 0xe6c,\n\t{ 6347,-479,-972,-8297,15954,2480,-1968,2131,7649 } },\n    { \"Canon EOS 6D\", 0, 0x3c82,\n\t{ 7034,-804,-1014,-4420,12564,2058,-851,1994,5758 } },\n    { \"Canon EOS 7D\", 0, 0x3510,\n\t{ 6844,-996,-856,-3876,11761,2396,-593,1772,6198 } },\n    { \"Canon EOS 10D\", 0, 0xfa0,\n\t{ 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\n    { \"Canon EOS 20Da\", 0, 0,\n\t{ 14155,-5065,-1382,-6550,14633,2039,-1623,1824,6561 } },\n    { \"Canon EOS 20D\", 0, 0xfff,\n\t{ 6599,-537,-891,-8071,15783,2424,-1983,2234,7462 } },\n    { \"Canon EOS 30D\", 0, 0,\n\t{ 6257,-303,-1000,-7880,15621,2396,-1714,1904,7046 } },\n    { \"Canon EOS 40D\", 0, 0x3f60,\n\t{ 6071,-747,-856,-7653,15365,2441,-2025,2553,7315 } },\n    { \"Canon EOS 50D\", 0, 0x3d93,\n\t{ 4920,616,-593,-6493,13964,2784,-1774,3178,7005 } },\n    { \"Canon EOS 60D\", 0, 0x2ff7,\n\t{ 6719,-994,-925,-4408,12426,2211,-887,2129,6051 } },\n    { \"Canon EOS 70D\", 0, 0x3c80,\n\t{ 7034,-804,-1014,-4420,12564,2058,-851,1994,5758 } },\n    { \"Canon EOS 300D\", 0, 0xfa0,\n\t{ 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\n    { \"Canon EOS 350D\", 0, 0xfff,\n\t{ 6018,-617,-965,-8645,15881,2975,-1530,1719,7642 } },\n    { \"Canon EOS 400D\", 0, 0xe8e,\n\t{ 7054,-1501,-990,-8156,15544,2812,-1278,1414,7796 } },\n    { \"Canon EOS 450D\", 0, 0x390d,\n\t{ 5784,-262,-821,-7539,15064,2672,-1982,2681,7427 } },\n    { \"Canon EOS 500D\", 0, 0x3479,\n\t{ 4763,712,-646,-6821,14399,2640,-1921,3276,6561 } },\n    { \"Canon EOS 550D\", 0, 0x3dd7,\n\t{ 6941,-1164,-857,-3825,11597,2534,-416,1540,6039 } },\n    { \"Canon EOS 600D\", 0, 0x3510,\n\t{ 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },\n    { \"Canon EOS 650D\", 0, 0x354d,\n\t{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 700D\", 0, 0x354d,\n\t{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS REBEL T5i\", 0, 0x354d,\n\t{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 1000D\", 0, 0xe43,\n\t{ 6771,-1139,-977,-7818,15123,2928,-1244,1437,7533 } },\n    { \"Canon EOS 1100D\", 0, 0x3510,\n\t{ 6444,-904,-893,-4563,12308,2535,-903,2016,6728 } },\n    { \"Canon EOS M\", 0, 0,\n\t{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS-1Ds Mark III\", 0, 0x3bb0,\n\t{ 5859,-211,-930,-8255,16017,2353,-1732,1887,7448 } },\n    { \"Canon EOS-1Ds Mark II\", 0, 0xe80,\n\t{ 6517,-602,-867,-8180,15926,2378,-1618,1771,7633 } },\n    { \"Canon EOS-1D Mark IV\", 0, 0x3bb0,\n\t{ 6014,-220,-795,-4109,12014,2361,-561,1824,5787 } },\n    { \"Canon EOS-1D Mark III\", 0, 0x3bb0,\n\t{ 6291,-540,-976,-8350,16145,2311,-1714,1858,7326 } },\n    { \"Canon EOS-1D Mark II N\", 0, 0xe80,\n\t{ 6240,-466,-822,-8180,15825,2500,-1801,1938,8042 } },\n    { \"Canon EOS-1D Mark II\", 0, 0xe80,\n\t{ 6264,-582,-724,-8312,15948,2504,-1744,1919,8664 } },\n    { \"Canon EOS-1DS\", 0, 0xe20,\n\t{ 4374,3631,-1743,-7520,15212,2472,-2892,3632,8161 } },\n    { \"Canon EOS-1D X\", 0, 0x3c4e,\n\t{ 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },\n    { \"Canon EOS-1D\", 0, 0xe20,\n\t{ 6806,-179,-1020,-8097,16415,1687,-3267,4236,7690 } },\n    { \"Canon EOS 100D\", 0, 0x3cf0,\n\t{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS REBEL SL1\", 0, 0x3cf0,\n\t{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS\", 0, 0,\n\t{ 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\n    { \"Canon PowerShot A530\", 0, 0,\n\t{ 0 } },\t/* don't want the A5 matrix */\n    { \"Canon PowerShot A50\", 0, 0,\n\t{ -5300,9846,1776,3436,684,3939,-5540,9879,6200,-1404,11175,217 } },\n    { \"Canon PowerShot A5\", 0, 0,\n\t{ -4801,9475,1952,2926,1611,4094,-5259,10164,5947,-1554,10883,547 } },\n    { \"Canon PowerShot G10\", 0, 0,\n\t{ 11093,-3906,-1028,-5047,12492,2879,-1003,1750,5561 } },\n    { \"Canon PowerShot G11\", 0, 0,\n\t{ 12177,-4817,-1069,-1612,9864,2049,-98,850,4471 } },\n    { \"Canon PowerShot G12\", 0, 0,\n\t{ 13244,-5501,-1248,-1508,9858,1935,-270,1083,4366 } },\n    { \"Canon PowerShot G15\", 0, 0,\n\t{ 7474,-2301,-567,-4056,11456,2975,-222,716,4181 } },\n    { \"Canon PowerShot G1 X\", 0, 0,\n\t{ 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },\n    { \"Canon PowerShot G1\", 0, 0,\n\t{ -4778,9467,2172,4743,-1141,4344,-5146,9908,6077,-1566,11051,557 } },\n    { \"Canon PowerShot G2\", 0, 0,\n\t{ 9087,-2693,-1049,-6715,14382,2537,-2291,2819,7790 } },\n    { \"Canon PowerShot G3\", 0, 0,\n\t{ 9212,-2781,-1073,-6573,14189,2605,-2300,2844,7664 } },\n    { \"Canon PowerShot G5\", 0, 0,\n\t{ 9757,-2872,-933,-5972,13861,2301,-1622,2328,7212 } },\n    { \"Canon PowerShot G6\", 0, 0,\n\t{ 9877,-3775,-871,-7613,14807,3072,-1448,1305,7485 } },\n    { \"Canon PowerShot G9\", 0, 0,\n\t{ 7368,-2141,-598,-5621,13254,2625,-1418,1696,5743 } },\n    { \"Canon PowerShot Pro1\", 0, 0,\n\t{ 10062,-3522,-999,-7643,15117,2730,-765,817,7323 } },\n    { \"Canon PowerShot Pro70\", 34, 0,\n\t{ -4155,9818,1529,3939,-25,4522,-5521,9870,6610,-2238,10873,1342 } },\n    { \"Canon PowerShot Pro90\", 0, 0,\n\t{ -4963,9896,2235,4642,-987,4294,-5162,10011,5859,-1770,11230,577 } },\n    { \"Canon PowerShot S30\", 0, 0,\n\t{ 10566,-3652,-1129,-6552,14662,2006,-2197,2581,7670 } },\n    { \"Canon PowerShot S40\", 0, 0,\n\t{ 8510,-2487,-940,-6869,14231,2900,-2318,2829,9013 } },\n    { \"Canon PowerShot S45\", 0, 0,\n\t{ 8163,-2333,-955,-6682,14174,2751,-2077,2597,8041 } },\n    { \"Canon PowerShot S50\", 0, 0,\n\t{ 8882,-2571,-863,-6348,14234,2288,-1516,2172,6569 } },\n    { \"Canon PowerShot S60\", 0, 0,\n\t{ 8795,-2482,-797,-7804,15403,2573,-1422,1996,7082 } },\n    { \"Canon PowerShot S70\", 0, 0,\n\t{ 9976,-3810,-832,-7115,14463,2906,-901,989,7889 } },\n    { \"Canon PowerShot S90\", 0, 0,\n\t{ 12374,-5016,-1049,-1677,9902,2078,-83,852,4683 } },\n    { \"Canon PowerShot S95\", 0, 0,\n\t{ 13440,-5896,-1279,-1236,9598,1931,-180,1001,4651 } },\n    { \"Canon PowerShot S110\", 0, 0,\n\t{ 8039,-2643,-654,-3783,11230,2930,-206,690,4194 } },\n    { \"Canon PowerShot S100\", 0, 0,\n\t{ 7968,-2565,-636,-2873,10697,2513,180,667,4211 } },\n    { \"Canon PowerShot S110\", 0, 0,\n\t{ 8039,-2643,-654,-3783,11230,2930,-206,690,4194 } },\n    { \"Canon PowerShot SX1 IS\", 0, 0,\n\t{ 6578,-259,-502,-5974,13030,3309,-308,1058,4970 } },\n    { \"Canon PowerShot SX50 HS\", 0, 0,\n\t{ 12432,-4753,-1247,-2110,10691,1629,-412,1623,4926 } },\n    { \"Canon PowerShot A470\", 0, 0,\t/* DJC */\n\t{ 12513,-4407,-1242,-2680,10276,2405,-878,2215,4734 } },\n    { \"Canon PowerShot A610\", 0, 0,\t/* DJC */\n\t{ 15591,-6402,-1592,-5365,13198,2168,-1300,1824,5075 } },\n    { \"Canon PowerShot A620\", 0, 0,\t/* DJC */\n\t{ 15265,-6193,-1558,-4125,12116,2010,-888,1639,5220 } },\n    { \"Canon PowerShot A630\", 0, 0,\t/* DJC */\n\t{ 14201,-5308,-1757,-6087,14472,1617,-2191,3105,5348 } },\n    { \"Canon PowerShot A640\", 0, 0,\t/* DJC */\n\t{ 13124,-5329,-1390,-3602,11658,1944,-1612,2863,4885 } },\n    { \"Canon PowerShot A650\", 0, 0,\t/* DJC */\n\t{ 9427,-3036,-959,-2581,10671,1911,-1039,1982,4430 } },\n    { \"Canon PowerShot A720\", 0, 0,\t/* DJC */\n\t{ 14573,-5482,-1546,-1266,9799,1468,-1040,1912,3810 } },\n    { \"Canon PowerShot S3 IS\", 0, 0,\t/* DJC */\n\t{ 14062,-5199,-1446,-4712,12470,2243,-1286,2028,4836 } },\n    { \"Canon PowerShot SX110 IS\", 0, 0,\t/* DJC */\n\t{ 14134,-5576,-1527,-1991,10719,1273,-1158,1929,3581 } },\n    { \"Canon PowerShot SX220\", 0, 0,\t/* DJC */\n\t{ 13898,-5076,-1447,-1405,10109,1297,-244,1860,3687 } },\n    { \"Canon PowerShot SX50\", 0, 0,\n\t{ 12432,-4753,-1247,-2110,10691,1629,-412,1623,4926 } },\n    { \"CASIO EX-S20\", 0, 0,\t\t/* DJC */\n\t{ 11634,-3924,-1128,-4968,12954,2015,-1588,2648,7206 } },\n    { \"CASIO EX-Z750\", 0, 0,\t\t/* DJC */\n\t{ 10819,-3873,-1099,-4903,13730,1175,-1755,3751,4632 } },\n    { \"CASIO EX-Z10\", 128, 0xfff,\t/* DJC */\n\t{ 9790,-3338,-603,-2321,10222,2099,-344,1273,4799 } },\n    { \"CINE 650\", 0, 0,\n\t{ 3390,480,-500,-800,3610,340,-550,2336,1192 } },\n    { \"CINE 660\", 0, 0,\n\t{ 3390,480,-500,-800,3610,340,-550,2336,1192 } },\n    { \"CINE\", 0, 0,\n\t{ 20183,-4295,-423,-3940,15330,3985,-280,4870,9800 } },\n    { \"Contax N Digital\", 0, 0xf1e,\n\t{ 7777,1285,-1053,-9280,16543,2916,-3677,5679,7060 } },\n    { \"EPSON R-D1\", 0, 0,\n\t{ 6827,-1878,-732,-8429,16012,2564,-704,592,7145 } },\n    { \"FUJIFILM E550\", 0, 0,\n\t{ 11044,-3888,-1120,-7248,15168,2208,-1531,2277,8069 } },\n    { \"FUJIFILM E900\", 0, 0,\n\t{ 9183,-2526,-1078,-7461,15071,2574,-2022,2440,8639 } },\n    { \"FUJIFILM F5\", 0, 0,\n\t{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"FUJIFILM F6\", 0, 0,\n\t{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"FUJIFILM F77\", 0, 0xfe9,\n\t{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"FUJIFILM F7\", 0, 0,\n\t{ 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\n    { \"FUJIFILM F800\", 0, 0,\n\t{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"FUJIFILM F8\", 0, 0,\n\t{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"FUJIFILM S100FS\", 514, 0,\n\t{ 11521,-4355,-1065,-6524,13767,3058,-1466,1984,6045 } },\n    { \"FUJIFILM S200EXR\", 512, 0x3fff,\n\t{ 11401,-4498,-1312,-5088,12751,2613,-838,1568,5941 } },\n    { \"FUJIFILM S20Pro\", 0, 0,\n\t{ 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\n    { \"FUJIFILM S2Pro\", 128, 0,\n\t{ 12492,-4690,-1402,-7033,15423,1647,-1507,2111,7697 } },\n    { \"FUJIFILM S3Pro\", 0, 0,\n\t{ 11807,-4612,-1294,-8927,16968,1988,-2120,2741,8006 } },\n    { \"FUJIFILM S5Pro\", 0, 0,\n\t{ 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\n    { \"FUJIFILM S5000\", 0, 0,\n\t{ 8754,-2732,-1019,-7204,15069,2276,-1702,2334,6982 } },\n    { \"FUJIFILM S5100\", 0, 0,\n\t{ 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\n    { \"FUJIFILM S5500\", 0, 0,\n\t{ 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\n    { \"FUJIFILM S5200\", 0, 0,\n\t{ 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\n    { \"FUJIFILM S5600\", 0, 0,\n\t{ 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\n    { \"FUJIFILM S6\", 0, 0,\n\t{ 12628,-4887,-1401,-6861,14996,1962,-2198,2782,7091 } },\n    { \"FUJIFILM S7000\", 0, 0,\n\t{ 10190,-3506,-1312,-7153,15051,2238,-2003,2399,7505 } },\n    { \"FUJIFILM S9000\", 0, 0,\n\t{ 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\n    { \"FUJIFILM S9500\", 0, 0,\n\t{ 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\n    { \"FUJIFILM S9100\", 0, 0,\n\t{ 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\n    { \"FUJIFILM S9600\", 0, 0,\n\t{ 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\n    { \"FUJIFILM IS-1\", 0, 0,\n\t{ 21461,-10807,-1441,-2332,10599,1999,289,875,7703 } },\n    { \"FUJIFILM IS Pro\", 0, 0,\n\t{ 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\n    { \"FUJIFILM HS10 HS11\", 0, 0xf68,\n\t{ 12440,-3954,-1183,-1123,9674,1708,-83,1614,4086 } },\n    { \"FUJIFILM HS20EXR\", 0, 0,\n\t{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"FUJIFILM HS3\", 0, 0,\n\t{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"FUJIFILM HS50EXR\", 0, 0,\n\t{ 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },\n    { \"FUJIFILM SL1000\", 0, 0,\n\t{ 11705,-4262,-1107,-2282,10791,1709,-555,1713,4945 } },\n    { \"FUJIFILM X100S\", 0, 0,\n\t{ 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },\n    { \"FUJIFILM X100\", 0, 0,\n\t{ 12161,-4457,-1069,-5034,12874,2400,-795,1724,6904 } },\n    { \"FUJIFILM X10\", 0, 0,\n\t{ 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"FUJIFILM X20\", 0, 0,\n\t{ 11768,-4971,-1133,-4904,12927,2183,-480,1723,4605 } },\n    { \"FUJIFILM XF1\", 0, 0,\n\t{ 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"FUJIFILM X-Pro1\", 0, 0,\n\t{ 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },\n    { \"FUJIFILM X-E1\", 0, 0,\n\t{ 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },\n    { \"FUJIFILM XF1\", 0, 0,\n\t{ 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"FUJIFILM X-S1\", 0, 0,\n\t{ 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Imacon Ixpress\", 0, 0,\t\t/* DJC */\n\t{ 7025,-1415,-704,-5188,13765,1424,-1248,2742,6038 } },\n    { \"KODAK NC2000\", 0, 0,\n\t{ 13891,-6055,-803,-465,9919,642,2121,82,1291 } },\n    { \"Kodak DCS315C\", 8, 0,\n\t{ 17523,-4827,-2510,756,8546,-137,6113,1649,2250 } },\n    { \"Kodak DCS330C\", 8, 0,\n\t{ 20620,-7572,-2801,-103,10073,-396,3551,-233,2220 } },\n    { \"KODAK DCS420\", 0, 0,\n\t{ 10868,-1852,-644,-1537,11083,484,2343,628,2216 } },\n    { \"KODAK DCS460\", 0, 0,\n\t{ 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\n    { \"KODAK EOSDCS1\", 0, 0,\n\t{ 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\n    { \"KODAK EOSDCS3B\", 0, 0,\n\t{ 9898,-2700,-940,-2478,12219,206,1985,634,1031 } },\n    { \"Kodak DCS520C\", 178, 0,\n\t{ 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\n    { \"Kodak DCS560C\", 177, 0,\n\t{ 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\n    { \"Kodak DCS620C\", 177, 0,\n\t{ 23617,-10175,-3149,-2054,11749,-272,2586,-489,3453 } },\n    { \"Kodak DCS620X\", 176, 0,\n\t{ 13095,-6231,154,12221,-21,-2137,895,4602,2258 } },\n    { \"Kodak DCS660C\", 173, 0,\n\t{ 18244,-6351,-2739,-791,11193,-521,3711,-129,2802 } },\n    { \"Kodak DCS720X\", 0, 0,\n\t{ 11775,-5884,950,9556,1846,-1286,-1019,6221,2728 } },\n    { \"Kodak DCS760C\", 0, 0,\n\t{ 16623,-6309,-1411,-4344,13923,323,2285,274,2926 } },\n    { \"Kodak DCS Pro SLR\", 0, 0,\n\t{ 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\n    { \"Kodak DCS Pro 14nx\", 0, 0,\n\t{ 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\n    { \"Kodak DCS Pro 14\", 0, 0,\n\t{ 7791,3128,-776,-8588,16458,2039,-2455,4006,6198 } },\n    { \"Kodak ProBack645\", 0, 0,\n\t{ 16414,-6060,-1470,-3555,13037,473,2545,122,4948 } },\n    { \"Kodak ProBack\", 0, 0,\n\t{ 21179,-8316,-2918,-915,11019,-165,3477,-180,4210 } },\n    { \"KODAK P712\", 0, 0,\n\t{ 9658,-3314,-823,-5163,12695,2768,-1342,1843,6044 } },\n    { \"KODAK P850\", 0, 0xf7c,\n\t{ 10511,-3836,-1102,-6946,14587,2558,-1481,1792,6246 } },\n    { \"KODAK P880\", 0, 0xfff,\n\t{ 12805,-4662,-1376,-7480,15267,2360,-1626,2194,7904 } },\n    { \"KODAK EasyShare Z980\", 0, 0,\n\t{ 11313,-3559,-1101,-3893,11891,2257,-1214,2398,4908 } },\n    { \"KODAK EasyShare Z981\", 0, 0,\n\t{ 12729,-4717,-1188,-1367,9187,2582,274,860,4411 } },\n    { \"KODAK EasyShare Z990\", 0, 0xfed,\n\t{ 11749,-4048,-1309,-1867,10572,1489,-138,1449,4522 } },\n    { \"KODAK EASYSHARE Z1015\", 0, 0xef1,\n\t{ 11265,-4286,-992,-4694,12343,2647,-1090,1523,5447 } },\n    { \"Leaf CMost\", 0, 0,\n\t{ 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\n    { \"Leaf Valeo 6\", 0, 0,\n\t{ 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\n    { \"Leaf Aptus 54S\", 0, 0,\n\t{ 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\n    { \"Leaf Aptus 65\", 0, 0,\n\t{ 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf Aptus 75\", 0, 0,\n\t{ 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf\", 0, 0,\n\t{ 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\n    { \"Mamiya ZD\", 0, 0,\n\t{ 7645,2579,-1363,-8689,16717,2015,-3712,5941,5961 } },\n    { \"Micron 2010\", 110, 0,\t\t/* DJC */\n\t{ 16695,-3761,-2151,155,9682,163,3433,951,4904 } },\n    { \"Minolta DiMAGE 5\", 0, 0xf7d,\n\t{ 8983,-2942,-963,-6556,14476,2237,-2426,2887,8014 } },\n    { \"Minolta DiMAGE 7Hi\", 0, 0xf7d,\n\t{ 11368,-3894,-1242,-6521,14358,2339,-2475,3056,7285 } },\n    { \"Minolta DiMAGE 7\", 0, 0xf7d,\n\t{ 9144,-2777,-998,-6676,14556,2281,-2470,3019,7744 } },\n    { \"Minolta DiMAGE A1\", 0, 0xf8b,\n\t{ 9274,-2547,-1167,-8220,16323,1943,-2273,2720,8340 } },\n    { \"MINOLTA DiMAGE A200\", 0, 0,\n\t{ 8560,-2487,-986,-8112,15535,2771,-1209,1324,7743 } },\n    { \"Minolta DiMAGE A2\", 0, 0xf8f,\n\t{ 9097,-2726,-1053,-8073,15506,2762,-966,981,7763 } },\n    { \"Minolta DiMAGE Z2\", 0, 0,\t/* DJC */\n\t{ 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\n    { \"MINOLTA DYNAX 5\", 0, 0xffb,\n\t{ 10284,-3283,-1086,-7957,15762,2316,-829,882,6644 } },\n    { \"MINOLTA DYNAX 7\", 0, 0xffb,\n\t{ 10239,-3104,-1099,-8037,15727,2451,-927,925,6871 } },\n    { \"MOTOROLA PIXL\", 0, 0,\t\t/* DJC */\n\t{ 8898,-989,-1033,-3292,11619,1674,-661,3178,5216 } },\n    { \"NIKON D100\", 0, 0,\n\t{ 5902,-933,-782,-8983,16719,2354,-1402,1455,6464 } },\n    { \"NIKON D1H\", 0, 0,\n\t{ 7577,-2166,-926,-7454,15592,1934,-2377,2808,8606 } },\n    { \"NIKON D1X\", 0, 0,\n\t{ 7702,-2245,-975,-9114,17242,1875,-2679,3055,8521 } },\n    { \"NIKON D1\", 0, 0, /* multiplied by 2.218750, 1.0, 1.148438 */\n\t{ 16772,-4726,-2141,-7611,15713,1972,-2846,3494,9521 } },\n    { \"NIKON D200\", 0, 0xfbc,\n\t{ 8367,-2248,-763,-8758,16447,2422,-1527,1550,8053 } },\n    { \"NIKON D2H\", 0, 0,\n\t{ 5710,-901,-615,-8594,16617,2024,-2975,4120,6830 } },\n    { \"NIKON D2X\", 0, 0,\n\t{ 10231,-2769,-1255,-8301,15900,2552,-797,680,7148 } },\n    { \"NIKON D3000\", 0, 0,\n\t{ 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },\n    { \"NIKON D3100\", 0, 0,\n\t{ 7911,-2167,-813,-5327,13150,2408,-1288,2483,7968 } },\n    { \"NIKON D3200\", 0, 0xfb9,\n\t{ 7013,-1408,-635,-5268,12902,2640,-1470,2801,7379 } },\n    { \"NIKON D300\", 0, 0,\n\t{ 9030,-1992,-715,-8465,16302,2255,-2689,3217,8069 } },\n    { \"NIKON D3X\", 0, 0,\n\t{ 7171,-1986,-648,-8085,15555,2718,-2170,2512,7457 } },\n    { \"NIKON D3S\", 0, 0,\n\t{ 8828,-2406,-694,-4874,12603,2541,-660,1509,7587 } },\n    { \"NIKON D3\", 0, 0,\n\t{ 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\n    { \"NIKON D40X\", 0, 0,\n\t{ 8819,-2543,-911,-9025,16928,2151,-1329,1213,8449 } },\n    { \"NIKON D40\", 0, 0,\n\t{ 6992,-1668,-806,-8138,15748,2543,-874,850,7897 } },\n    { \"NIKON D4\", 0, 0,\n\t{ 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"NIKON D5000\", 0, 0xf00,\n\t{ 7309,-1403,-519,-8474,16008,2622,-2433,2826,8064 } },\n    { \"NIKON D5100\", 0, 0x3de6,\n\t{ 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"NIKON D5200\", 0, 0,\n\t{ 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"NIKON D50\", 0, 0,\n\t{ 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\n    { \"NIKON D600\", 0, 0x3e07,\n\t{ 8178,-2245,-609,-4857,12394,2776,-1207,2086,7298 } },\n    { \"NIKON D60\", 0, 0,\n\t{ 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },\n    { \"NIKON D7000\", 0, 0,\n\t{ 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"NIKON D700\", 0, 0,\n\t{ 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\n    { \"NIKON D70\", 0, 0,\n\t{ 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\n    { \"NIKON D7100\", 0, 0,\n\t{ 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"NIKON D800\", 0, 0,\n\t{ 7866,-2108,-555,-4869,12483,2681,-1176,2069,7501 } },\n    { \"NIKON D80\", 0, 0,\n\t{ 8629,-2410,-883,-9055,16940,2171,-1490,1363,8520 } },\n    { \"NIKON D90\", 0, 0xf00,\n\t{ 7309,-1403,-519,-8474,16008,2622,-2434,2826,8064 } },\n    { \"NIKON E950\", 0, 0x3dd,\t\t/* DJC */\n\t{ -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"NIKON E995\", 0, 0,\t/* copied from E5000 */\n\t{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"NIKON E2100\", 0, 0,\t/* copied from Z2, new white balance */\n\t{ 13142,-4152,-1596,-4655,12374,2282,-1769,2696,6711} },\n    { \"NIKON E2500\", 0, 0,\n\t{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"NIKON E3200\", 0, 0,\t\t/* DJC */\n\t{ 9846,-2085,-1019,-3278,11109,2170,-774,2134,5745 } },\n    { \"NIKON E4300\", 0, 0,\t/* copied from Minolta DiMAGE Z2 */\n\t{ 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\n    { \"NIKON E4500\", 0, 0,\n\t{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"NIKON E5000\", 0, 0,\n\t{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"NIKON E5400\", 0, 0,\n\t{ 9349,-2987,-1001,-7919,15766,2266,-2098,2680,6839 } },\n    { \"NIKON E5700\", 0, 0,\n\t{ -5368,11478,2368,5537,-113,3148,-4969,10021,5782,778,9028,211 } },\n    { \"NIKON E8400\", 0, 0,\n\t{ 7842,-2320,-992,-8154,15718,2599,-1098,1342,7560 } },\n    { \"NIKON E8700\", 0, 0,\n\t{ 8489,-2583,-1036,-8051,15583,2643,-1307,1407,7354 } },\n    { \"NIKON E8800\", 0, 0,\n\t{ 7971,-2314,-913,-8451,15762,2894,-1442,1520,7610 } },\n    { \"NIKON COOLPIX A\", 0, 0,\n\t{ 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"NIKON COOLPIX P330\", 0, 0,\n\t{ 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"NIKON COOLPIX P6000\", 0, 0,\n\t{ 9698,-3367,-914,-4706,12584,2368,-837,968,5801 } },\n    { \"NIKON COOLPIX P7000\", 0, 0,\n\t{ 11432,-3679,-1111,-3169,11239,2202,-791,1380,4455 } },\n    { \"NIKON COOLPIX P7100\", 0, 0,\n\t{ 11053,-4269,-1024,-1976,10182,2088,-526,1263,4469 } },\n    { \"NIKON COOLPIX P7700\", 200, 0,\n\t{ 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"NIKON 1 J3\", 0, 0,\n\t{ 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },\n    { \"NIKON 1 S1\", 0, 0,\n\t{ 8994,-2667,-865,-4594,12324,2552,-699,1786,6260 } },\n    { \"NIKON 1 V2\", 0, 0,\n\t{ 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },\n    { \"NIKON 1 \", 0, 0,\n\t{ 8994,-2667,-865,-4594,12324,2552,-699,1786,6260 } },\n    { \"OLYMPUS C5050\", 0, 0,\n\t{ 10508,-3124,-1273,-6079,14294,1901,-1653,2306,6237 } },\n    { \"OLYMPUS C5060\", 0, 0,\n\t{ 10445,-3362,-1307,-7662,15690,2058,-1135,1176,7602 } },\n    { \"OLYMPUS C7070\", 0, 0,\n\t{ 10252,-3531,-1095,-7114,14850,2436,-1451,1723,6365 } },\n    { \"OLYMPUS C70\", 0, 0,\n\t{ 10793,-3791,-1146,-7498,15177,2488,-1390,1577,7321 } },\n    { \"OLYMPUS C80\", 0, 0,\n\t{ 8606,-2509,-1014,-8238,15714,2703,-942,979,7760 } },\n    { \"OLYMPUS E-10\", 0, 0xffc,\n\t{ 12745,-4500,-1416,-6062,14542,1580,-1934,2256,6603 } },\n    { \"OLYMPUS E-1\", 0, 0,\n\t{ 11846,-4767,-945,-7027,15878,1089,-2699,4122,8311 } },\n    { \"OLYMPUS E-20\", 0, 0xffc,\n\t{ 13173,-4732,-1499,-5807,14036,1895,-2045,2452,7142 } },\n    { \"OLYMPUS E-300\", 0, 0,\n\t{ 7828,-1761,-348,-5788,14071,1830,-2853,4518,6557 } },\n    { \"OLYMPUS E-330\", 0, 0,\n\t{ 8961,-2473,-1084,-7979,15990,2067,-2319,3035,8249 } },\n    { \"OLYMPUS E-30\", 0, 0xfbc,\n\t{ 8144,-1861,-1111,-7763,15894,1929,-1865,2542,7607 } },\n    { \"OLYMPUS E-3\", 0, 0xf99,\n\t{ 9487,-2875,-1115,-7533,15606,2010,-1618,2100,7389 } },\n    { \"OLYMPUS E-400\", 0, 0,\n\t{ 6169,-1483,-21,-7107,14761,2536,-2904,3580,8568 } },\n    { \"OLYMPUS E-410\", 0, 0xf6a,\n\t{ 8856,-2582,-1026,-7761,15766,2082,-2009,2575,7469 } },\n    { \"OLYMPUS E-420\", 0, 0xfd7,\n\t{ 8746,-2425,-1095,-7594,15612,2073,-1780,2309,7416 } },\n    { \"OLYMPUS E-450\", 0, 0xfd2,\n\t{ 8745,-2425,-1095,-7594,15613,2073,-1780,2309,7416 } },\n    { \"OLYMPUS E-500\", 0, 0,\n\t{ 8136,-1968,-299,-5481,13742,1871,-2556,4205,6630 } },\n    { \"OLYMPUS E-510\", 0, 0xf6a,\n\t{ 8785,-2529,-1033,-7639,15624,2112,-1783,2300,7817 } },\n    { \"OLYMPUS E-520\", 0, 0xfd2,\n\t{ 8344,-2322,-1020,-7596,15635,2048,-1748,2269,7287 } },\n    { \"OLYMPUS E-5\", 0, 0xeec,\n\t{ 11200,-3783,-1325,-4576,12593,2206,-695,1742,7504 } },\n    { \"OLYMPUS E-600\", 0, 0xfaf,\n\t{ 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },\n    { \"OLYMPUS E-620\", 0, 0xfaf,\n\t{ 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },\n    { \"OLYMPUS E-P1\", 0, 0xffd,\n\t{ 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },\n    { \"OLYMPUS E-P2\", 0, 0xffd,\n\t{ 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },\n    { \"OLYMPUS E-P3\", 0, 0,\n\t{ 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"OLYMPUS E-P5\", 0, 0,\n\t{ 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"OLYMPUS E-PL1s\", 0, 0,\n\t{ 11409,-3872,-1393,-4572,12757,2003,-709,1810,7415 } },\n    { \"OLYMPUS E-PL1\", 0, 0,\n\t{ 11408,-4289,-1215,-4286,12385,2118,-387,1467,7787 } },\n    { \"OLYMPUS E-PL2\", 0, 0,\n\t{ 15030,-5552,-1806,-3987,12387,1767,-592,1670,7023 } },\n    { \"OLYMPUS E-PL3\", 0, 0,\n\t{ 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"OLYMPUS E-PL5\", 0, 0xfcb,\n\t{ 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"OLYMPUS E-PM1\", 0, 0,\n\t{ 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"OLYMPUS E-PM2\", 0, 0,\n\t{ 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"OLYMPUS E-M5\", 0, 0xfe1,\n\t{ 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"OLYMPUS SP350\", 0, 0,\n\t{ 12078,-4836,-1069,-6671,14306,2578,-786,939,7418 } },\n    { \"OLYMPUS SP3\", 0, 0,\n\t{ 11766,-4445,-1067,-6901,14421,2707,-1029,1217,7572 } },\n    { \"OLYMPUS SP500UZ\", 0, 0xfff,\n\t{ 9493,-3415,-666,-5211,12334,3260,-1548,2262,6482 } },\n    { \"OLYMPUS SP510UZ\", 0, 0xffe,\n\t{ 10593,-3607,-1010,-5881,13127,3084,-1200,1805,6721 } },\n    { \"OLYMPUS SP550UZ\", 0, 0xffe,\n\t{ 11597,-4006,-1049,-5432,12799,2957,-1029,1750,6516 } },\n    { \"OLYMPUS SP560UZ\", 0, 0xff9,\n\t{ 10915,-3677,-982,-5587,12986,2911,-1168,1968,6223 } },\n    { \"OLYMPUS SP570UZ\", 0, 0,\n\t{ 11522,-4044,-1146,-4736,12172,2904,-988,1829,6039 } },\n    { \"OLYMPUS XZ-10\", 0, 0,\n\t{ 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },\n    { \"OLYMPUS XZ-1\", 0, 0,\n\t{ 10901,-4095,-1074,-1141,9208,2293,-62,1417,5158 } },\n    { \"OLYMPUS XZ-2\", 0, 0,\n\t{ 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },\n    { \"OmniVision ov5647\", 0, 0,\t/* DJC */\n\t{ 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } },\n    { \"PENTAX *ist DL2\", 0, 0,\n\t{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"PENTAX *ist DL\", 0, 0,\n\t{ 10829,-2838,-1115,-8339,15817,2696,-837,680,11939 } },\n    { \"PENTAX *ist DS2\", 0, 0,\n\t{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"PENTAX *ist DS\", 0, 0,\n\t{ 10371,-2333,-1206,-8688,16231,2602,-1230,1116,11282 } },\n    { \"PENTAX *ist D\", 0, 0,\n\t{ 9651,-2059,-1189,-8881,16512,2487,-1460,1345,10687 } },\n    { \"PENTAX K10D\", 0, 0,\n\t{ 9566,-2863,-803,-7170,15172,2112,-818,803,9705 } },\n    { \"PENTAX K1\", 0, 0,\n\t{ 11095,-3157,-1324,-8377,15834,2720,-1108,947,11688 } },\n    { \"PENTAX K20D\", 0, 0,\n\t{ 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },\n    { \"PENTAX K200D\", 0, 0,\n\t{ 9186,-2678,-907,-8693,16517,2260,-1129,1094,8524 } },\n    { \"PENTAX K2000\", 0, 0,\n\t{ 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },\n    { \"PENTAX K-m\", 0, 0,\n\t{ 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },\n    { \"PENTAX K-x\", 0, 0,\n\t{ 8843,-2837,-625,-5025,12644,2668,-411,1234,7410 } },\n    { \"PENTAX K-r\", 0, 0,\n\t{ 9895,-3077,-850,-5304,13035,2521,-883,1768,6936 } },\n    { \"PENTAX K-30\", 0, 0,\n\t{ 8833,-2670,-1183,-3995,12301,1881,-979,1717,6527 } },\n    { \"PENTAX K-5 II s\", 0, 0,\n\t{ 8366,-2528,-1120,-3995,12301,1881,-998,1749,6649 } },\n    { \"PENTAX K-5 II\", 0, 0,\n\t{ 8773,-2651,-1175,-3995,12301,1881,-973,1706,6486 } },\n    { \"PENTAX K-5\", 0, 0,\n\t{ 8713,-2833,-743,-4342,11900,2772,-722,1543,6247 } },\n    { \"PENTAX K-7\", 0, 0,\n\t{ 9142,-2947,-678,-8648,16967,1663,-2224,2898,8615 } },\n    { \"PENTAX MX-1\", 0, 0,\n\t{ 8804,-2523,-1238,-2423,11627,860,-682,1774,4753 } },\n    { \"PENTAX Q10\", 0, 0,\n\t{ 12995,-5593,-1107,-1879,10139,2027,-64,1233,4919 } },\n    { \"PENTAX 645D\", 0, 0x3e00,\n\t{ 10646,-3593,-1158,-3329,11699,1831,-667,2874,6287 } },\n    { \"Panasonic DMC-FZ8\", 0, 0xf7f,\n\t{ 8986,-2755,-802,-6341,13575,3077,-1476,2144,6379 } },\n    { \"Panasonic DMC-FZ18\", 0, 0,\n\t{ 9932,-3060,-935,-5809,13331,2753,-1267,2155,5575 } },\n    { \"Panasonic DMC-FZ28\", 15, 0xf96,\n\t{ 10109,-3488,-993,-5412,12812,2916,-1305,2140,5543 } },\n    { \"Panasonic DMC-FZ30\", 0, 0xf94,\n\t{ 10976,-4029,-1141,-7918,15491,2600,-1670,2071,8246 } },\n    { \"Panasonic DMC-FZ3\", 143, 0,\n\t{ 9938,-2780,-890,-4604,12393,2480,-1117,2304,4620 } },\n    { \"Panasonic DMC-FZ4\", 143, 0,\n\t{ 13639,-5535,-1371,-1698,9633,2430,316,1152,4108 } },\n    { \"Panasonic DMC-FZ50\", 0, 0,\n\t{ 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\n    { \"LEICA V-LUX1\", 0, 0,\n\t{ 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\n    { \"Panasonic DMC-L10\", 15, 0xf96,\n\t{ 8025,-1942,-1050,-7920,15904,2100,-2456,3005,7039 } },\n    { \"Panasonic DMC-L1\", 0, 0xf7f,\n\t{ 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\n    { \"LEICA DIGILUX 3\", 0, 0xf7f,\n\t{ 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\n    { \"Panasonic DMC-LC1\", 0, 0,\n\t{ 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\n    { \"LEICA DIGILUX 2\", 0, 0,\n\t{ 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\n    { \"Panasonic DMC-LF1\", 143, 0,\n\t{ 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },\n    { \"Panasonic DMC-LX1\", 0, 0xf7f,\n\t{ 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\n    { \"LEICA D-LUX2\", 0, 0xf7f,\n\t{ 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\n    { \"Panasonic DMC-LX2\", 0, 0,\n\t{ 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\n    { \"LEICA D-LUX3\", 0, 0,\n\t{ 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\n    { \"Panasonic DMC-LX3\", 15, 0,\n\t{ 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },\n    { \"LEICA D-LUX 4\", 15, 0,\n\t{ 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },\n    { \"Panasonic DMC-LX5\", 143, 0,\n\t{ 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },\n    { \"Panasonic DMC-LX7\", 143, 0,\n\t{ 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"LEICA D-LUX 5\", 143, 0,\n\t{ 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },\n    { \"Panasonic DMC-LX7\", 143, 0,\n\t{ 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"LEICA D-LUX 6\", 143, 0,\n\t{ 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"Panasonic DMC-FZ100\", 143, 0xfff,\n\t{ 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },\n    { \"LEICA V-LUX 2\", 143, 0xfff,\n\t{ 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },\n    { \"Panasonic DMC-FZ150\", 143, 0xfff,\n\t{ 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },\n    { \"LEICA V-LUX 3\", 143, 0xfff,\n\t{ 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },\n    { \"Panasonic DMC-FZ200\", 143, 0xfff,\n\t{ 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },\n    { \"LEICA V-LUX 4\", 143, 0xfff,\n\t{ 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },\n    { \"Panasonic DMC-FX150\", 15, 0xfff,\n\t{ 9082,-2907,-925,-6119,13377,3058,-1797,2641,5609 } },\n    { \"Panasonic DMC-G10\", 0, 0,\n\t{ 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },\n    { \"Panasonic DMC-G1\", 15, 0xf94,\n\t{ 8199,-2065,-1056,-8124,16156,2033,-2458,3022,7220 } },\n    { \"Panasonic DMC-G2\", 15, 0xf3c,\n\t{ 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },\n    { \"Panasonic DMC-G3\", 143, 0xfff,\n\t{ 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },\n    { \"Panasonic DMC-G5\", 143, 0xfff,\n\t{ 7798,-2562,-740,-3879,11584,2613,-1055,2248,5434 } },\n    { \"Panasonic DMC-G6\", 143, 0xfff,\n\t{ 8294,-2891,-651,-3869,11590,2595,-1183,2267,5352 } },\n    { \"Panasonic DMC-GF1\", 15, 0xf92,\n\t{ 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },\n    { \"Panasonic DMC-GF2\", 143, 0xfff,\n\t{ 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },\n    { \"Panasonic DMC-GF3\", 143, 0xfff,\n\t{ 9051,-2468,-1204,-5212,13276,2121,-1197,2510,6890 } },\n    { \"Panasonic DMC-GF5\", 143, 0xfff,\n\t{ 8228,-2945,-660,-3938,11792,2430,-1094,2278,5793 } },\n    { \"Panasonic DMC-GF6\", 143, 0,\n\t{ 8130,-2801,-946,-3520,11289,2552,-1314,2511,5791 } },\n    { \"Panasonic DMC-GH1\", 15, 0xf92,\n\t{ 6299,-1466,-532,-6535,13852,2969,-2331,3112,5984 } },\n    { \"Panasonic DMC-GH2\", 15, 0xf95,\n\t{ 7780,-2410,-806,-3913,11724,2484,-1018,2390,5298 } },\n    { \"Panasonic DMC-GH3\", 144, 0,\n\t{ 6559,-1752,-491,-3672,11407,2586,-962,1875,5130 } },\n    { \"Panasonic DMC-GX1\", 143, 0,\n\t{ 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },\n    { \"Phase One H 20\", 0, 0,\t\t/* DJC */\n\t{ 1313,1855,-109,-6715,15908,808,-327,1840,6020 } },\n    { \"Phase One H 25\", 0, 0,\n\t{ 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One P 2\", 0, 0,\n\t{ 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One P 30\", 0, 0,\n\t{ 4516,-245,-37,-7020,14976,2173,-3206,4671,7087 } },\n    { \"Phase One P 45\", 0, 0,\n\t{ 5053,-24,-117,-5684,14076,1702,-2619,4492,5849 } },\n    { \"Phase One P40\", 0, 0,\n\t{ 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Phase One P65\", 0, 0,\n\t{ 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"RED ONE\", 704, 0xffff,\t\t/* DJC */\n\t{ 21014,-7891,-2613,-3056,12201,856,-2203,5125,8042 } },\n    { \"SAMSUNG EX1\", 0, 0x3e00,\n\t{ 8898,-2498,-994,-3144,11328,2066,-760,1381,4576 } },\n    { \"SAMSUNG EX2F\", 0, 0x7ff,\n\t{ 10648,-3897,-1055,-2022,10573,1668,-492,1611,4742 } },\n    { \"SAMSUNG NX2\", 0, 0xfff,\t/* NX20, NX200, NX210 */\n\t{ 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"SAMSUNG NX1000\", 0, 0,\n\t{ 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"SAMSUNG NX\", 0, 0,\t/* NX5, NX10, NX11, NX100 */\n\t{ 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"SAMSUNG WB2000\", 0, 0xfff,\n\t{ 12093,-3557,-1155,-1000,9534,1733,-22,1787,4576 } },\n    { \"SAMSUNG GX-1\", 0, 0,\n\t{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"SAMSUNG S85\", 0, 0xffff,\t\t/* DJC */\n\t{ 11885,-3968,-1473,-4214,12299,1916,-835,1655,5549 } },\n    { \"Sinar\", 0, 0,\t\t\t/* DJC */\n\t{ 16442,-2956,-2422,-2877,12128,750,-1136,6066,4559 } },\n    { \"SONY DSC-F828\", 0, 0,\n\t{ 7924,-1910,-777,-8226,15459,2998,-1517,2199,6818,-7242,11401,3481 } },\n    { \"SONY DSC-R1\", 512, 0,\n\t{ 8512,-2641,-694,-8042,15670,2526,-1821,2117,7414 } },\n    { \"SONY DSC-V3\", 0, 0,\n\t{ 7511,-2571,-692,-7894,15088,3060,-948,1111,8128 } },\n    { \"SONY DSC-RX100M2\", 200, 0,\n\t{ 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },\n    { \"SONY DSC-RX100\", 200, 0,\n\t{ 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },\n    { \"SONY DSC-RX1R\", 128, 0,\n\t{ 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n    { \"SONY DSC-RX1\", 128, 0,\n\t{ 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n    { \"SONY DSLR-A100\", 0, 0xfeb,\n\t{ 9437,-2811,-774,-8405,16215,2290,-710,596,7181 } },\n    { \"SONY DSLR-A290\", 0, 0,\n\t{ 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"SONY DSLR-A2\", 0, 0,\n\t{ 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\n    { \"SONY DSLR-A300\", 0, 0,\n\t{ 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\n    { \"SONY DSLR-A330\", 0, 0,\n\t{ 9847,-3091,-929,-8485,16346,2225,-714,595,7103 } },\n    { \"SONY DSLR-A350\", 0, 0xffc,\n\t{ 6038,-1484,-578,-9146,16746,2513,-875,746,7217 } },\n    { \"SONY DSLR-A380\", 0, 0,\n\t{ 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"SONY DSLR-A390\", 0, 0,\n\t{ 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"SONY DSLR-A450\", 128, 0xfeb,\n\t{ 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },\n    { \"SONY DSLR-A580\", 128, 0xfeb,\n\t{ 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },\n    { \"SONY DSLR-A5\", 128, 0xfeb,\n\t{ 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },\n    { \"SONY DSLR-A700\", 126, 0,\n\t{ 5775,-805,-359,-8574,16295,2391,-1943,2341,7249 } },\n    { \"SONY DSLR-A850\", 128, 0,\n\t{ 5413,-1162,-365,-5665,13098,2866,-608,1179,8440 } },\n    { \"SONY DSLR-A900\", 128, 0,\n\t{ 5209,-1072,-397,-8845,16120,2919,-1618,1803,8654 } },\n    { \"SONY NEX-3N\", 128, 0,\t\t/* Adobe */\n\t{ 6129,-1545,\t-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"SONY NEX-3\", 128, 0,\t\t/* Adobe */\n\t{ 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },\n    { \"SONY NEX-5N\", 128, 0,\n\t{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"SONY NEX-5R\", 128, 0,\t\t\n\t{ 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"SONY NEX-5\", 128, 0,\t\t/* Adobe */\n\t{ 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },\n    { \"SONY NEX-6\", 128, 0,\n\t{ 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"SONY NEX-7\", 128, 0,\n\t{ 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"SONY NEX\", 128, 0,\t/* NEX-C3, NEX-F3 */\n\t{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"SONY SLT-A33\", 128, 0,\n\t{ 6069,-1221,-366,-5221,12779,2734,-1024,2066,6834 } },\n    { \"SONY SLT-A35\", 128, 0,\n\t{ 5986,-1618,-415,-4557,11820,3120,-681,1404,6971 } },\n    { \"SONY SLT-A37\", 128, 0,\n\t{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"SONY SLT-A55\", 128, 0,\n\t{ 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },\n    { \"SONY SLT-A57\", 128, 0,\n\t{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"SONY SLT-A58\", 128, 0,\n\t{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"SONY SLT-A65\", 128, 0,\n\t{ 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"SONY SLT-A77\", 128, 0,\n\t{ 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"SONY SLT-A99\", 128, 0,\n\t{ 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n  };\n  double cam_xyz[4][3];\n  char name[130];\n  int i, j;\n\n  sprintf (name, \"%s %s\", t_make, t_model);\n  for (i=0; i < sizeof table / sizeof *table; i++)\n    if (!strncmp (name, table[i].prefix, strlen(table[i].prefix))) {\n      if (table[i].t_black)   black   = (ushort) table[i].t_black;\n      if (table[i].t_maximum) maximum = (ushort) table[i].t_maximum;\n      if (table[i].trans[0]) {\n\tfor (j=0; j < 12; j++)\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.color.cam_xyz[0][j] = \n#endif\n\t  cam_xyz[0][j] = table[i].trans[j] / 10000.0;\n\tcam_xyz_coeff (cam_xyz);\n      }\n      break;\n    }\n}\n\nvoid CLASS simple_coeff (int index)\n{\n  static const float table[][12] = {\n  /* index 0 -- all Foveon cameras */\n  { 1.4032,-0.2231,-0.1016,-0.5263,1.4816,0.017,-0.0112,0.0183,0.9113 },\n  /* index 1 -- Kodak DC20 and DC25 */\n  { 2.25,0.75,-1.75,-0.25,-0.25,0.75,0.75,-0.25,-0.25,-1.75,0.75,2.25 },\n  /* index 2 -- Logitech Fotoman Pixtura */\n  { 1.893,-0.418,-0.476,-0.495,1.773,-0.278,-1.017,-0.655,2.672 },\n  /* index 3 -- Nikon E880, E900, and E990 */\n  { -1.936280,  1.800443, -1.448486,  2.584324,\n     1.405365, -0.524955, -0.289090,  0.408680,\n    -1.204965,  1.082304,  2.941367, -1.818705 }\n  };\n  int i, c;\n\n  for (raw_color = i=0; i < 3; i++)\n    FORCC rgb_cam[i][c] = table[index][i*colors+c];\n}\n\nshort CLASS guess_byte_order (int words)\n{\n  uchar test[4][2];\n  int t=2, msb;\n  double diff, sum[2] = {0,0};\n\n  fread (test[0], 2, 2, ifp);\n  for (words-=2; words--; ) {\n    fread (test[t], 2, 1, ifp);\n    for (msb=0; msb < 2; msb++) {\n      diff = (test[t^2][msb] << 8 | test[t^2][!msb])\n\t   - (test[t  ][msb] << 8 | test[t  ][!msb]);\n      sum[msb] += diff*diff;\n    }\n    t = (t+1) & 3;\n  }\n  return sum[0] < sum[1] ? 0x4d4d : 0x4949;\n}\n\nfloat CLASS find_green (int bps, int bite, int off0, int off1)\n{\n  UINT64 bitbuf=0;\n  int vbits, col, i, c;\n  ushort img[2][2064];\n  double sum[]={0,0};\n\n  FORC(2) {\n    fseek (ifp, c ? off1:off0, SEEK_SET);\n    for (vbits=col=0; col < width; col++) {\n      for (vbits -= bps; vbits < 0; vbits += bite) {\n\tbitbuf <<= bite;\n\tfor (i=0; i < bite; i+=8)\n\t  bitbuf |= (unsigned) (fgetc(ifp) << i);\n      }\n      img[c][col] = bitbuf << (64-bps-vbits) >> (64-bps);\n    }\n  }\n  FORC(width-1) {\n    sum[ c & 1] += ABS(img[0][c]-img[1][c+1]);\n    sum[~c & 1] += ABS(img[1][c]-img[0][c+1]);\n  }\n  return 100 * log(sum[0]/sum[1]);\n}\n\n\n#ifndef LIBRAW_LIBRARY_BUILD\nvoid CLASS identify2(unsigned fsize, unsigned flen, char *head);\n#endif\n\n/*\n   Identify which camera created this file, and set global variables\n   accordingly.\n */\nvoid CLASS identify()\n{\n  char head[32], *cp;\n  int hlen, flen, fsize, zero_fsize=1, i, c, is_canon;\n  struct jhead jh;\n  static const struct {\n    int fsize;\n    char t_make[12], t_model[19], withjpeg;\n  } table[] = {\n    {    62464, \"Kodak\",    \"DC20\"            ,0 },\n    {   124928, \"Kodak\",    \"DC20\"            ,0 },\n    {  1652736, \"Kodak\",    \"DCS200\"          ,0 },\n    {  4159302, \"Kodak\",    \"C330\"            ,0 },\n    {  4162462, \"Kodak\",    \"C330\"            ,0 },\n    {   460800, \"Kodak\",    \"C603v\"           ,0 },\n    {   614400, \"Kodak\",    \"C603v\"           ,0 },\n    {  6163328, \"Kodak\",    \"C603\"            ,0 },\n    {  6166488, \"Kodak\",    \"C603\"            ,0 },\n    {  9116448, \"Kodak\",    \"C603y\"           ,0 },\n    {   311696, \"ST Micro\", \"STV680 VGA\"      ,0 },  /* SPYz */\n    {   787456, \"Creative\", \"PC-CAM 600\"      ,0 },\n    {  1138688, \"Minolta\",  \"RD175\"           ,0 },\n    {  3840000, \"Foculus\",  \"531C\"            ,0 },\n    {   307200, \"Generic\",  \"640x480\"         ,0 },\n    {   786432, \"AVT\",      \"F-080C\"          ,0 },\n    {  1447680, \"AVT\",      \"F-145C\"          ,0 },\n    {  1920000, \"AVT\",      \"F-201C\"          ,0 },\n    {  5067304, \"AVT\",      \"F-510C\"          ,0 },\n    {  5067316, \"AVT\",      \"F-510C\"          ,0 },\n    { 10134608, \"AVT\",      \"F-510C\"          ,0 },\n    { 10134620, \"AVT\",      \"F-510C\"          ,0 },\n    { 16157136, \"AVT\",      \"F-810C\"          ,0 },\n    {  1409024, \"Sony\",     \"XCD-SX910CR\"     ,0 },\n    {  2818048, \"Sony\",     \"XCD-SX910CR\"     ,0 },\n    {  3884928, \"Micron\",   \"2010\"            ,0 },\n    {  6624000, \"Pixelink\", \"A782\"            ,0 },\n    { 13248000, \"Pixelink\", \"A782\"            ,0 },\n    {  6291456, \"RoverShot\",\"3320AF\"          ,0 },\n    {  6553440, \"Canon\",    \"PowerShot A460\"  ,0 },\n    {  6653280, \"Canon\",    \"PowerShot A530\"  ,0 },\n    {  6573120, \"Canon\",    \"PowerShot A610\"  ,0 },\n    {  9219600, \"Canon\",    \"PowerShot A620\"  ,0 },\n    {  9243240, \"Canon\",    \"PowerShot A470\"  ,0 },\n    { 10341600, \"Canon\",    \"PowerShot A720 IS\",0 },\n    { 10383120, \"Canon\",    \"PowerShot A630\"  ,0 },\n    { 12945240, \"Canon\",    \"PowerShot A640\"  ,0 },\n    { 15636240, \"Canon\",    \"PowerShot A650\"  ,0 },\n    {  5298000, \"Canon\",    \"PowerShot SD300\" ,0 },\n    {  7710960, \"Canon\",    \"PowerShot S3 IS\" ,0 },\n    { 15467760, \"Canon\",    \"PowerShot SX110 IS\",0 },\n    { 15534576, \"Canon\",    \"PowerShot SX120 IS\",0 },\n    { 18653760, \"Canon\",    \"PowerShot SX20 IS\",0 },\n    { 19131120, \"Canon\",    \"PowerShot SX220 HS\",0 },\n    { 21936096, \"Canon\",    \"PowerShot SX30 IS\",0 },\n    {  5939200, \"OLYMPUS\",  \"C770UZ\"          ,0 },\n    {  1581060, \"NIKON\",    \"E900\"            ,1 },  /* or E900s,E910 */\n    {  2465792, \"NIKON\",    \"E950\"            ,1 },  /* or E800,E700 */\n    {  2940928, \"NIKON\",    \"E2100\"           ,1 },  /* or E2500 */\n    {  4771840, \"NIKON\",    \"E990\"            ,1 },  /* or E995, Oly C3030Z */\n    {  4775936, \"NIKON\",    \"E3700\"           ,1 },  /* or Optio 33WR */\n    {  5869568, \"NIKON\",    \"E4300\"           ,1 },  /* or DiMAGE Z2 */\n    {  5865472, \"NIKON\",    \"E4500\"           ,1 },\n    {  7438336, \"NIKON\",    \"E5000\"           ,1 },  /* or E5700 */\n    {  8998912, \"NIKON\",    \"COOLPIX S6\"      ,1 },\n    {  1976352, \"CASIO\",    \"QV-2000UX\"       ,1 },\n    {  3217760, \"CASIO\",    \"QV-3*00EX\"       ,1 },\n    {  6218368, \"CASIO\",    \"QV-5700\"         ,1 },\n    {  6054400, \"CASIO\",    \"QV-R41\"          ,1 },\n    {  7530816, \"CASIO\",    \"QV-R51\"          ,1 },\n    {  7684000, \"CASIO\",    \"QV-4000\"         ,1 },\n    {  2937856, \"CASIO\",    \"EX-S20\"          ,1 },\n    {  4948608, \"CASIO\",    \"EX-S100\"         ,1 },\n    {  7542528, \"CASIO\",    \"EX-Z50\"          ,1 },\n    {  7562048, \"CASIO\",    \"EX-Z500\"         ,1 },\n    {  7753344, \"CASIO\",    \"EX-Z55\"          ,1 },\n    {  7816704, \"CASIO\",    \"EX-Z60\"          ,1 },\n    { 10843712, \"CASIO\",    \"EX-Z75\"          ,1 },\n    { 10834368, \"CASIO\",    \"EX-Z750\"         ,1 },\n    { 12310144, \"CASIO\",    \"EX-Z850\"         ,1 },\n    { 12489984, \"CASIO\",    \"EX-Z8\"           ,1 },\n    { 15499264, \"CASIO\",    \"EX-Z1050\"        ,1 },\n    { 18702336, \"CASIO\",    \"EX-ZR100\"        ,1 },\n    {  7426656, \"CASIO\",    \"EX-P505\"         ,1 },\n    {  9313536, \"CASIO\",    \"EX-P600\"         ,1 },\n    { 10979200, \"CASIO\",    \"EX-P700\"         ,1 },\n    {  3178560, \"PENTAX\",   \"Optio S\"         ,1 },\n    {  4841984, \"PENTAX\",   \"Optio S\"         ,1 },\n    {  6114240, \"PENTAX\",   \"Optio S4\"        ,1 },  /* or S4i, CASIO EX-Z4 */\n    { 10702848, \"PENTAX\",   \"Optio 750Z\"      ,1 },\n    { 15980544, \"AGFAPHOTO\",\"DC-833m\"         ,1 },\n    { 16098048, \"SAMSUNG\",  \"S85\"             ,1 },\n    { 16215552, \"SAMSUNG\",  \"S85\"             ,1 },\n    { 20487168, \"SAMSUNG\",  \"WB550\"           ,1 },\n    { 24000000, \"SAMSUNG\",  \"WB550\"           ,1 },\n    { 9994240, \"ptGrey\", \"GRAS-50S5C\" ,0 }, // KC: SUPPORT GRASSHOPPER\n    { 10075968, \"JaiPulnix\",\"BB-500CL\" ,0 }, // KC: SUPPORT BB-500CL\n    { 10108896, \"JaiPulnix\",\"BB-500GE\" ,0 }, // KC: SUPPORT BB-500GE\n    { 10036800, \"SVS\", \"SVS625CL\" ,0 }, // KC: SUPPORT SVS625 cameralink\n    { 12582980, \"Sinar\",    \"\"                ,0 },\n    { 33292868, \"Sinar\",    \"\"                ,0 },\n    { 44390468, \"Sinar\",    \"\"                ,0 } };\n  static const char *corp[] =\n    { \"Canon\", \"NIKON\", \"EPSON\", \"KODAK\", \"Kodak\", \"OLYMPUS\", \"PENTAX\",\n      \"MINOLTA\", \"Minolta\", \"Konica\", \"CASIO\", \"Sinar\", \"Phase One\",\n      \"SAMSUNG\", \"Mamiya\", \"MOTOROLA\", \"LEICA\" };\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY,0,2);\n#endif\n\n  tiff_flip = flip = filters = -1;\t/* 0 is valid, so -1 is unknown */\n  raw_height = raw_width = fuji_width = fuji_layout = cr2_slice[0] = 0;\n  maximum = height = width = top_margin = left_margin = 0;\n  cdesc[0] = desc[0] = artist[0] = make[0] = model[0] = model2[0] = 0;\n  iso_speed = shutter = aperture = focal_len = unique_id = 0;\n  tiff_nifds = 0;\n  memset (tiff_ifd, 0, sizeof tiff_ifd);\n  memset (gpsdata, 0, sizeof gpsdata);\n  memset (cblack, 0, sizeof cblack);\n  memset (white, 0, sizeof white);\n  memset (mask, 0, sizeof mask);\n  thumb_offset = thumb_length = thumb_width = thumb_height = 0;\n  load_raw = thumb_load_raw = 0;\n  write_thumb = &CLASS jpeg_thumb;\n  data_offset = meta_length = tiff_bps = tiff_compress = 0;\n  kodak_cbpp = zero_after_ff = dng_version = load_flags = 0;\n  timestamp = shot_order = tiff_samples = black = is_foveon = 0;\n  mix_green = profile_length = data_error = zero_is_bad = 0;\n  pixel_aspect = is_raw = raw_color = 1;\n  tile_width = tile_length = 0;\n  for (i=0; i < 4; i++) {\n    cam_mul[i] = i == 1;\n    pre_mul[i] = i < 3;\n    FORC3 cmatrix[c][i] = 0;\n    FORC3 rgb_cam[c][i] = c == i;\n  }\n  colors = 3;\n  for (i=0; i < 0x10000; i++) curve[i] = i;\n\n  order = get2();\n  hlen = get4();\n  fseek (ifp, 0, SEEK_SET);\n  fread (head, 1, 32, ifp);\n  fseek (ifp, 0, SEEK_END);\n  flen = fsize = ftell(ifp);\n  if ((cp = (char *) memmem (head, 32, (char*)\"MMMM\", 4)) ||\n      (cp = (char *) memmem (head, 32, (char*)\"IIII\", 4))) {\n    parse_phase_one (cp-head);\n    if (cp-head && parse_tiff(0)) apply_tiff();\n  } else if (order == 0x4949 || order == 0x4d4d) {\n    if (!memcmp (head+6,\"HEAPCCDR\",8)) {\n      data_offset = hlen;\n      parse_ciff (hlen, flen - hlen);\n    } else if (parse_tiff(0)) apply_tiff();\n  } else if (!memcmp (head,\"\\xff\\xd8\\xff\\xe1\",4) &&\n\t     !memcmp (head+6,\"Exif\",4)) {\n    fseek (ifp, 4, SEEK_SET);\n    data_offset = 4 + get2();\n    fseek (ifp, data_offset, SEEK_SET);\n    if (fgetc(ifp) != 0xff)\n      parse_tiff(12);\n    thumb_offset = 0;\n  } else if (!memcmp (head+25,\"ARECOYK\",7)) {\n    strcpy (make, \"Contax\");\n    strcpy (model,\"N Digital\");\n    fseek (ifp, 33, SEEK_SET);\n    get_timestamp(1);\n    fseek (ifp, 60, SEEK_SET);\n    FORC4 cam_mul[c ^ (c >> 1)] = get4();\n  } else if (!strcmp (head, \"PXN\")) {\n    strcpy (make, \"Logitech\");\n    strcpy (model,\"Fotoman Pixtura\");\n  } else if (!strcmp (head, \"qktk\")) {\n    strcpy (make, \"Apple\");\n    strcpy (model,\"QuickTake 100\");\n    load_raw = &CLASS quicktake_100_load_raw;\n  } else if (!strcmp (head, \"qktn\")) {\n    strcpy (make, \"Apple\");\n    strcpy (model,\"QuickTake 150\");\n    load_raw = &CLASS kodak_radc_load_raw;\n  } else if (!memcmp (head,\"FUJIFILM\",8)) {\n    fseek (ifp, 84, SEEK_SET);\n    thumb_offset = get4();\n    thumb_length = get4();\n    fseek (ifp, 92, SEEK_SET);\n    parse_fuji (get4());\n    if (thumb_offset > 120) {\n      fseek (ifp, 120, SEEK_SET);\n      is_raw += (i = get4()) && 1;\n      if (is_raw == 2 && shot_select)\n\tparse_fuji (i);\n    }\n    load_raw = &CLASS unpacked_load_raw;\n    fseek (ifp, 100+28*(shot_select > 0), SEEK_SET);\n    parse_tiff (data_offset = get4());\n    parse_tiff (thumb_offset+12);\n    apply_tiff();\n  } else if (!memcmp (head,\"RIFF\",4)) {\n    fseek (ifp, 0, SEEK_SET);\n    parse_riff();\n  } else if (!memcmp (head,\"\\0\\001\\0\\001\\0@\",6)) {\n    fseek (ifp, 6, SEEK_SET);\n    fread (make, 1, 8, ifp);\n    fread (model, 1, 8, ifp);\n    fread (model2, 1, 16, ifp);\n    data_offset = get2();\n    get2();\n    raw_width = get2();\n    raw_height = get2();\n    load_raw = &CLASS nokia_load_raw;\n    filters = 0x61616161;\n  } else if (!memcmp (head,\"NOKIARAW\",8)) {\n    strcpy (make, \"NOKIA\");\n    strcpy (model, \"X2\");\n    order = 0x4949;\n    fseek (ifp, 300, SEEK_SET);\n    data_offset = get4();\n    i = get4();\n    width = get2();\n    height = get2();\n    data_offset += i - width * 5 / 4 * height;\n    load_raw = &CLASS nokia_load_raw;\n    filters = 0x61616161;\n  } else if (!memcmp (head,\"ARRI\",4)) {\n    order = 0x4949;\n    fseek (ifp, 20, SEEK_SET);\n    width = get4();\n    height = get4();\n    strcpy (make, \"ARRI\");\n    fseek (ifp, 668, SEEK_SET);\n    fread (model, 1, 64, ifp);\n    data_offset = 4096;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 88;\n    filters = 0x61616161;\n  } else if (!memcmp (head+4,\"RED1\",4)) {\n    strcpy (make, \"RED\");\n    strcpy (model,\"ONE\");\n    parse_redcine();\n    load_raw = &CLASS redcine_load_raw;\n    gamma_curve (1/2.4, 12.92, 1, 4095);\n    filters = 0x49494949;\n  } else if (!memcmp (head,\"DSC-Image\",9))\n    parse_rollei();\n  else if (!memcmp (head,\"PWAD\",4))\n    parse_sinar_ia();\n  else if (!memcmp (head,\"\\0MRM\",4))\n    parse_minolta(0);\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n  else if (!memcmp (head,\"FOVb\",4))\n    parse_foveon();\n#endif\n  else if (!memcmp (head,\"CI\",2))\n    parse_cine();\n  else\n    for (zero_fsize=i=0; i < sizeof table / sizeof *table; i++)\n      if (fsize == table[i].fsize) {\n\tstrcpy (make,  table[i].t_make );\n\tstrcpy (model, table[i].t_model);\n\tif (table[i].withjpeg)\n\t  parse_external_jpeg();\n      }\n  if (zero_fsize) fsize = 0;\n  if (make[0] == 0) parse_smal (0, flen);\n  if (make[0] == 0) {\n    parse_jpeg(0);\n    fseek(ifp,0,SEEK_END);\n    int sz = ftell(ifp);\n    if (!strncmp(model,\"ov\",2) && sz>=6404096 && !fseek (ifp, -6404096, SEEK_END) &&\n\tfread (head, 1, 32, ifp) && !strcmp(head,\"BRCMn\")) {\n      strcpy (make, \"OmniVision\");\n      data_offset = ftell(ifp) + 0x8000-32;\n      width = raw_width;\n      raw_width = 2611;\n      load_raw = &CLASS nokia_load_raw;\n      filters = 0x16161616;\n    } else is_raw = 0;\n  }\n\n  for (i=0; i < sizeof corp / sizeof *corp; i++)\n    if (strstr (make, corp[i]))\t\t/* Simplify company names */\n\tstrcpy (make, corp[i]);\n  if (!strncmp (make,\"KODAK\",5) &&\n\t((cp = strstr(model,\" DIGITAL CAMERA\")) ||\n\t (cp = strstr(model,\" Digital Camera\")) ||\n\t (cp = strstr(model,\"FILE VERSION\"))))\n     *cp = 0;\n  cp = make + strlen(make);\t\t/* Remove trailing spaces */\n  while (*--cp == ' ') *cp = 0;\n  cp = model + strlen(model);\n  while (*--cp == ' ') *cp = 0;\n  i = strlen(make);\t\t\t/* Remove make from model */\n  if (!strncasecmp (model, make, i) && model[i++] == ' ')\n    memmove (model, model+i, 64-i);\n  if (!strncmp (model,\"FinePix \",8))\n    strcpy (model, model+8);\n  if (!strncmp (model,\"Digital Camera \",15))\n    strcpy (model, model+15);\n  desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;\n  if (!is_raw) goto notraw;\n\n  if (!height) height = raw_height;\n  if (!width)  width  = raw_width;\n  if (height == 2624 && width == 3936)\t/* Pentax K10D and Samsung GX10 */\n    { height  = 2616;   width  = 3896; }\n  if (height == 3136 && width == 4864)  /* Pentax K20D and Samsung GX20 */\n    { height  = 3124;   width  = 4688; filters = 0x16161616; }\n  if (width == 4352 && (!strcmp(model,\"K-r\") || !strcmp(model,\"K-x\")))\n    {\t\t\twidth  = 4309; filters = 0x16161616; }\n  if (width >= 4960 && !strncmp(model,\"K-5\",3))\n    { left_margin = 10; width  = 4950; filters = 0x16161616; }\n  if (width >= 4960 && !strncmp(model,\"K-5 II\",6))\n    { left_margin = 10; width  = 4948; filters = 0x16161616; }\n  if (width == 4736 && !strcmp(model,\"K-7\"))\n    { height  = 3122;   width  = 4684; filters = 0x16161616; top_margin = 2; }\n  if (width == 7424 && !strcmp(model,\"645D\"))\n    { height  = 5502;   width  = 7328; filters = 0x61616161; top_margin = 29;\n      left_margin = 48; }\n  if (height == 3014 && width == 4096)\t/* Ricoh GX200 */\n\t\t\twidth  = 4014;\n  if (dng_version) {\n    if (filters == UINT_MAX) filters = 0;\n    if (filters) is_raw = tiff_samples;\n    else\t colors = tiff_samples;\n    if (tiff_compress == 1)\n      load_raw = &CLASS packed_dng_load_raw;\n    if (tiff_compress == 7)\n      load_raw = &CLASS lossless_dng_load_raw;\n    goto dng_skip;\n  }\n  if ((is_canon = !strcmp(make,\"Canon\")))\n    load_raw = memcmp (head+6,\"HEAPCCDR\",8) ?\n\t&CLASS lossless_jpeg_load_raw : &CLASS canon_load_raw;\n  if (!strcmp(make,\"NIKON\")) {\n    if (!load_raw)\n      load_raw = &CLASS packed_load_raw;\n    if (model[0] == 'E')\n      load_flags |= !data_offset << 2 | 2;\n  }\n  if (!strcmp(make,\"CASIO\")) {\n    load_raw = &CLASS packed_load_raw;\n    maximum = 0xf7f;\n  }\n\n/* Set parameters based on camera name (for non-DNG files). */\n\n  if (is_foveon) {\n    if (height*2 < width) pixel_aspect = 0.5;\n    if (height   > width) pixel_aspect = 2;\n    filters = 0;\n    simple_coeff(0);\n  } else if (is_canon && tiff_bps == 15) {\n    switch (width) {\n      case 3344: width -= 66;\n      case 3872: width -= 6;\n    }\n    if (height > width) SWAP(height,width);\n    filters = 0;\n    load_raw = &CLASS canon_sraw_load_raw;\n  } else if (!strcmp(model,\"PowerShot 600\")) {\n    height = 613;\n    width  = 854;\n    raw_width = 896;\n    pixel_aspect = 607/628.0;\n    colors = 4;\n    filters = 0xe1e4e1e4;\n    load_raw = &CLASS canon_600_load_raw;\n  } else if (!strcmp(model,\"PowerShot A5\") ||\n\t     !strcmp(model,\"PowerShot A5 Zoom\")) {\n    height = 773;\n    width  = 960;\n    raw_width = 992;\n    pixel_aspect = 256/235.0;\n    colors = 4;\n    filters = 0x1e4e1e4e;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A50\")) {\n    height =  968;\n    width  = 1290;\n    raw_width = 1320;\n    colors = 4;\n    filters = 0x1b4e4b1e;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot Pro70\")) {\n    height = 1024;\n    width  = 1552;\n    colors = 4;\n    filters = 0x1e4b4e1b;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot SD300\")) {\n    height = 1752;\n    width  = 2344;\n    raw_height = 1766;\n    raw_width  = 2400;\n    top_margin  = 12;\n    left_margin = 12;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A460\")) {\n    height = 1960;\n    width  = 2616;\n    raw_height = 1968;\n    raw_width  = 2664;\n    top_margin  = 4;\n    left_margin = 4;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A530\")) {\n    height = 1984;\n    width  = 2620;\n    raw_height = 1992;\n    raw_width  = 2672;\n    top_margin  = 6;\n    left_margin = 10;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A610\")) {\n    if (canon_s2is()) strcpy (model+10, \"S2 IS\");\n    height = 1960;\n    width  = 2616;\n    raw_height = 1968;\n    raw_width  = 2672;\n    top_margin  = 8;\n    left_margin = 12;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A620\")) {\n    height = 2328;\n    width  = 3112;\n    raw_height = 2340;\n    raw_width  = 3152;\n    top_margin  = 12;\n    left_margin = 36;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A470\")) {\n    height = 2328;\n    width  = 3096;\n    raw_height = 2346;\n    raw_width  = 3152;\n    top_margin  = 6;\n    left_margin = 12;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A720 IS\")) {\n    height = 2472;\n    width  = 3298;\n    raw_height = 2480;\n    raw_width  = 3336;\n    top_margin  = 5;\n    left_margin = 6;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A630\")) {\n    height = 2472;\n    width  = 3288;\n    raw_height = 2484;\n    raw_width  = 3344;\n    top_margin  = 6;\n    left_margin = 12;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A640\")) {\n    height = 2760;\n    width  = 3672;\n    raw_height = 2772;\n    raw_width  = 3736;\n    top_margin  = 6;\n    left_margin = 12;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A650\")) {\n    height = 3024;\n    width  = 4032;\n    raw_height = 3048;\n    raw_width  = 4104;\n    top_margin  = 12;\n    left_margin = 48;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot S3 IS\")) {\n    height = 2128;\n    width  = 2840;\n    raw_height = 2136;\n    raw_width  = 2888;\n    top_margin  = 8;\n    left_margin = 44;\ncanon_a5:\n    tiff_bps = 10;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 40;\n    if (raw_width > 1600) zero_is_bad = 1;\n  } else if (!strcmp(model,\"PowerShot SX110 IS\")) {\n    height = 2760;\n    width  = 3684;\n    raw_height = 2772;\n    raw_width  = 3720;\n    top_margin  = 12;\n    left_margin = 6;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 40;\n    zero_is_bad = 1;\n  } else if (!strcmp(model,\"PowerShot SX120 IS\")) {\n    height = 2742;\n    width  = 3664;\n    raw_height = 2778;\n    raw_width  = 3728;\n    top_margin  = 18;\n    left_margin = 16;\n    filters = 0x49494949;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 40;\n    zero_is_bad = 1;\n  } else if (!strcmp(model,\"PowerShot SX20 IS\")) {\n    height = 3024;\n    width  = 4032;\n    raw_height = 3048;\n    raw_width  = 4080;\n    top_margin  = 12;\n    left_margin = 24;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 40;\n    zero_is_bad = 1;\n  } else if (!strcmp(model,\"PowerShot SX220 HS\")) {\n    height = 3043;\n    width  = 4072;\n    raw_height = 3060;\n    raw_width  = 4168;\n    mask[0][0] = top_margin = 16;\n    mask[0][2] = top_margin + height;\n    mask[0][3] = left_margin = 92;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 8;\n    zero_is_bad = 1;\n  } else if (!strcmp(model,\"PowerShot SX50 HS\")) {\n    top_margin=16;\n    left_margin=94;\n    height = 3043;\n    width  = 4072;\n  } else if (!strcmp(model,\"PowerShot SX30 IS\")) {\n    height = 3254;\n    width  = 4366;\n    raw_height = 3276;\n    raw_width  = 4464;\n    top_margin  = 10;\n    left_margin = 25;\n    filters = 0x16161616;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 40;\n    zero_is_bad = 1;\n  } else if (!strcmp(model,\"PowerShot Pro90 IS\")) {\n    width  = 1896;\n    colors = 4;\n    filters = 0xb4b4b4b4;\n  } else if (is_canon && raw_width == 2144) {\n    height = 1550;\n    width  = 2088;\n    top_margin  = 8;\n    left_margin = 4;\n    if (!strcmp(model,\"PowerShot G1\")) {\n      colors = 4;\n      filters = 0xb4b4b4b4;\n    }\n  } else if (is_canon && raw_width == 2224) {\n    height = 1448;\n    width  = 2176;\n    top_margin  = 6;\n    left_margin = 48;\n  } else if (is_canon && raw_width == 2376) {\n    height = 1720;\n    width  = 2312;\n    top_margin  = 6;\n    left_margin = 12;\n  } else if (is_canon && raw_width == 2672) {\n    height = 1960;\n    width  = 2616;\n    top_margin  = 6;\n    left_margin = 12;\n  } else if (is_canon && raw_width == 3152) {\n    height = 2056;\n    width  = 3088;\n    top_margin  = 12;\n    left_margin = 64;\n    if (unique_id == 0x80000170)\n      adobe_coeff (\"Canon\",\"EOS 300D\");\n  } else if (is_canon && raw_width == 3160) {\n    height = 2328;\n    width  = 3112;\n    top_margin  = 12;\n    left_margin = 44;\n  } else if (is_canon && raw_width == 3344) {\n    height = 2472;\n    width  = 3288;\n    top_margin  = 6;\n    left_margin = 4;\n  } else if (!strcmp(model,\"EOS D2000C\")) {\n    filters = 0x61616161;\n    black = curve[200];\n  } else if (is_canon && raw_width == 3516) {\n    top_margin  = 14;\n    left_margin = 42;\n    if (unique_id == 0x80000189)\n      adobe_coeff (\"Canon\",\"EOS 350D\");\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 3596) {\n    top_margin  = 12;\n    left_margin = 74;\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 3744) {\n    height = 2760;\n    width  = 3684;\n    top_margin  = 16;\n    left_margin = 8;\n    if (unique_id > 0x2720000) {\n      top_margin  = 12;\n      left_margin = 52;\n    }\n  } else if (is_canon && raw_width == 3944) {\n    height = 2602;\n    width  = 3908;\n    top_margin  = 18;\n    left_margin = 30;\n  } else if (is_canon && raw_width == 3948) {\n    top_margin  = 18;\n    left_margin = 42;\n    height -= 2;\n    if (unique_id == 0x80000236)\n      adobe_coeff (\"Canon\",\"EOS 400D\");\n    if (unique_id == 0x80000254)\n      adobe_coeff (\"Canon\",\"EOS 1000D\");\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 3984) {\n    top_margin  = 20;\n    left_margin = 76;\n    height -= 2;\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 4104) {\n    height = 3024;\n    width  = 4032;\n    top_margin  = 12;\n    left_margin = 48;\n  } else if (is_canon && raw_width == 4152) {\n    top_margin  = 12;\n    left_margin = 192;\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 4160) {\n    height = 3048;\n    width  = 4048;\n    top_margin  = 11;\n    left_margin = 104;\n  } else if (is_canon && raw_width == 4176) {\n    height = 3045;\n    width  = 4072;\n    left_margin = 96;\n    mask[0][0] = top_margin = 17;\n    mask[0][2] = raw_height;\n    mask[0][3] = 80;\n    filters = 0x49494949;\n  } else if (is_canon && raw_width == 4312) {\n    top_margin  = 18;\n    left_margin = 22;\n    height -= 2;\n    if (unique_id == 0x80000176)\n      adobe_coeff (\"Canon\",\"EOS 450D\");\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 4352) {\n    top_margin  = 18;\n    left_margin = 62;\n    if (unique_id == 0x80000288)\n      adobe_coeff (\"Canon\",\"EOS 1100D\");\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 4476) {\n    top_margin  = 34;\n    left_margin = 90;\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 4480) {\n    height = 3326;\n    width  = 4432;\n    top_margin  = 10;\n    left_margin = 12;\n    filters = 0x49494949;\n  } else if (is_canon && raw_width == 4496) {\n    height = 3316;\n    width  = 4404;\n    top_margin  = 50;\n    left_margin = 80;\n  } else if (is_canon && raw_width == 4832) {\n    top_margin = unique_id == 0x80000261 ? 51:26;\n    left_margin = 62;\n    if (unique_id == 0x80000252)\n      adobe_coeff (\"Canon\",\"EOS 500D\");\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 5108) {\n    top_margin  = 13;\n    left_margin = 98;\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 5120) {\n    height -= top_margin = 45;\n    left_margin = 142;\n    width = 4916;\n  } else if (is_canon && raw_width == 5280) {\n    top_margin  = 52;\n    left_margin = 72;\n    if (unique_id == 0x80000301)\n      adobe_coeff (\"Canon\",\"EOS 650D\");\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 5344) {\n    top_margin = 51;\n    left_margin = 142;\n    if (unique_id == 0x80000269) {\n      top_margin = 100;\n      left_margin = 126;\n      height -= 2;\n      adobe_coeff (\"Canon\",\"EOS-1D X\");\n    }\n    if (unique_id == 0x80000270)\n      adobe_coeff (\"Canon\",\"EOS 550D\");\n    if (unique_id == 0x80000286)\n      adobe_coeff (\"Canon\",\"EOS 600D\");\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 5360) {\n    top_margin = 51;\n    left_margin = 158;\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 5568) {\n    top_margin = 38;\n    left_margin = 72;\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 5712) {\n    height = 3752;\n    width  = 5640;\n    top_margin  = 20;\n    left_margin = 62;\n  } else if (is_canon && raw_width == 5792) {\n    top_margin  = 51;\n    left_margin = 158;\ncanon_cr2:\n    height -= top_margin;\n    width  -= left_margin;\n  } else if (is_canon && raw_width == 5920) {\n    height = 3870;\n    width  = 5796;\n    top_margin  = 80;\n    left_margin = 122;\n  } else if (!strcmp(model,\"D1\")) {\n    cam_mul[0] *= 256/527.0;\n    cam_mul[2] *= 256/317.0;\n  } else if (!strcmp(model,\"D1X\")) {\n    width -= 4;\n    pixel_aspect = 0.5;\n  } else if (!strcmp(model,\"D40X\") ||\n\t     !strcmp(model,\"D60\")  ||\n\t     !strcmp(model,\"D80\")  ||\n\t     !strcmp(model,\"D3000\")) {\n    height -= 3;\n    width  -= 4;\n  } else if (!strcmp(model,\"D3\")   ||\n\t     !strcmp(model,\"D3S\")  ||\n\t     !strcmp(model,\"D700\")) {\n    width -= 4;\n    left_margin = 2;\n  } else if (!strcmp(model,\"D3100\")) {\n    width -= 28;\n    left_margin = 6;\n  } else if (!strcmp(model,\"D5000\") ||\n\t     !strcmp(model,\"D90\")) {\n    width -= 42;\n  } else if (!strcmp(model,\"D5100\") ||\n\t     !strcmp(model,\"D7000\")) {\n    width -= 44;\n  } else if (!strcmp(model,\"D3200\") ||\n\t     !strcmp(model,\"D800E\") ||\n\t     !strcmp(model,\"D600\")  ||\n\t     !strcmp(model,\"D800\")) {\n    width -= 46;\n  } else if (!strcmp(model,\"D4\")) {\n    width -= 52;\n    left_margin = 2;\n  } else if (!strcmp(model,\"D600\")) {\n    width -= 48;\n  } else if (!strncmp(model,\"D40\",3) ||\n\t     !strncmp(model,\"D50\",3) ||\n\t     !strncmp(model,\"D70\",3)) {\n    width--;\n  } else if (!strcmp(model,\"D100\")) {\n    if (load_flags)\n      raw_width = (width += 3) + 3;\n  } else if (!strcmp(model,\"D200\")) {\n    left_margin = 1;\n    width -= 4;\n    filters = 0x94949494;\n  } else if (!strncmp(model,\"D2H\",3)) {\n    left_margin = 6;\n    width -= 14;\n  } else if (!strncmp(model,\"D2X\",3)) {\n    if (width == 3264) width -= 32;\n    else width -= 8;\n  } else if (!strncmp(model,\"D300\",4)) {\n    width -= 32;\n  } else if (!strcmp(make,\"NIKON\") && raw_width == 4032) {\n    adobe_coeff (\"NIKON\",\"COOLPIX P7700\");\n  } else if (!strncmp(model,\"COOLPIX P\",9)) {\n    load_flags = 24;\n    filters = 0x94949494;\n    if (model[9] == '7' && iso_speed >= 400)\n      black = 255;\n  } else if (!strncmp(model,\"COOLPIX A\",9) && raw_width == 4992) {\n\t  width = 4948;\n  } else if (!strncmp(model,\"1 \",2)) {\n    height -= 2;\n  } else if (fsize == 1581060) {\n    height = 963;\n    width = 1287;\n    raw_width = 1632;\n    maximum = 0x3f4;\n    colors = 4;\n    filters = 0x1e1e1e1e;\n    simple_coeff(3);\n    pre_mul[0] = 1.2085;\n    pre_mul[1] = 1.0943;\n    pre_mul[3] = 1.1103;\n    goto e900;\n  } else if (fsize == 2465792) {\n    height = 1203;\n    width  = 1616;\n    raw_width = 2048;\n    colors = 4;\n    filters = 0x4b4b4b4b;\n    adobe_coeff (\"NIKON\",\"E950\");\ne900:\n    tiff_bps = 10;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 6;\n  } else if (fsize == 4771840) {\n    height = 1540;\n    width  = 2064;\n    colors = 4;\n    filters = 0xe1e1e1e1;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 6;\n    if (!timestamp && nikon_e995())\n      strcpy (model, \"E995\");\n    if (strcmp(model,\"E995\")) {\n      filters = 0xb4b4b4b4;\n      simple_coeff(3);\n      pre_mul[0] = 1.196;\n      pre_mul[1] = 1.246;\n      pre_mul[2] = 1.018;\n    }\n  } else if (!strcmp(model,\"E2100\")) {\n    if (!timestamp && !nikon_e2100()) goto cp_e2500;\n    height = 1206;\n    width  = 1616;\n    load_flags = 30;\n  } else if (!strcmp(model,\"E2500\")) {\ncp_e2500:\n    strcpy (model, \"E2500\");\n    height = 1204;\n    width  = 1616;\n    colors = 4;\n    filters = 0x4b4b4b4b;\n  } else if (fsize == 4775936) {\n    height = 1542;\n    width  = 2064;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 30;\n    if (!timestamp) nikon_3700();\n    if (model[0] == 'E' && atoi(model+1) < 3700)\n      filters = 0x49494949;\n    if (!strcmp(model,\"Optio 33WR\")) {\n      flip = 1;\n      filters = 0x16161616;\n    }\n    if (make[0] == 'O') {\n      i = find_green (12, 32, 1188864, 3576832);\n      c = find_green (12, 32, 2383920, 2387016);\n      if (abs(i) < abs(c)) {\n\tSWAP(i,c);\n\tload_flags = 24;\n      }\n      if (i < 0) filters = 0x61616161;\n    }\n  } else if (fsize == 5869568) {\n    height = 1710;\n    width  = 2288;\n    filters = 0x16161616;\n    if (!timestamp && minolta_z2()) {\n      strcpy (make, \"Minolta\");\n      strcpy (model,\"DiMAGE Z2\");\n    }\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 6 + 24*(make[0] == 'M');\n  } else if (!strcmp(model,\"E4500\")) {\n    height = 1708;\n    width  = 2288;\n    colors = 4;\n    filters = 0xb4b4b4b4;\n  } else if (fsize == 7438336) {\n    height = 1924;\n    width  = 2576;\n    colors = 4;\n    filters = 0xb4b4b4b4;\n  } else if (fsize == 8998912) {\n    height = 2118;\n    width  = 2832;\n    maximum = 0xf83;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 30;\n  } else if (!strcmp(make,\"FUJIFILM\")) {\n    if (!strcmp(model+7,\"S2Pro\")) {\n      strcpy (model,\"S2Pro\");\n      height = 2144;\n      width  = 2880;\n      flip = 6;\n    } else if (load_raw != &CLASS packed_load_raw)\n      maximum = (is_raw == 2 && shot_select) ? 0x2f00 : 0x3e00;\n    top_margin = (raw_height - height) >> 2 << 1;\n    left_margin = (raw_width - width ) >> 2 << 1;\n    if (width == 2848) filters = 0x16161616;\n    if (width == 3328) {\n      width = 3262;\n      left_margin = 34;\n    }\n    if (width == 4952) {\n      left_margin = 0;\n      filters = 2;\n    }\n\tif(!strcmp(model,\"HS50EXR\"))\n\t{\n\t\tfilters = 0x1e1e1e1e;\n\t\twidth=3230;\n\t}\n\tif(!strcmp(model,\"X20\"))\n\t{\n\t\tleft_margin = 2;\n\t\ttop_margin=2;\n\t\twidth = 4030;\n\t\theight = 3010;\n\t\traw_height = 3012;\n\t\tfilters = 2;\n\t}\n\tif(!strcmp(model,\"X100S\"))\n\t{\n\t\tleft_margin = 2;\n\t\ttop_margin = 1;\n\t\twidth = 4934;\n\t\theight = 3290;\n\t\traw_height = 3295;\n\t\tfilters = 2;\n\t\tdata_offset +=8;\n\t\tload_raw = &CLASS unpacked_load_raw;\n\t\tload_flags = 0;\n\t\tmaximum = 16383;\n\t}\n    if (fuji_layout) raw_width *= is_raw;\n  } else if (!strcmp(model,\"RD175\")) {\n    height = 986;\n    width = 1534;\n    data_offset = 513;\n    filters = 0x61616161;\n    load_raw = &CLASS minolta_rd175_load_raw;\n  } else if (!strcmp(model,\"KD-400Z\")) {\n    height = 1712;\n    width  = 2312;\n    raw_width = 2336;\n    goto konica_400z;\n  } else if (!strcmp(model,\"KD-510Z\")) {\n    goto konica_510z;\n  } else if (!strcasecmp(make,\"MINOLTA\")) {\n    load_raw = &CLASS unpacked_load_raw;\n    maximum = 0xfff;\n    if (!strncmp(model,\"DiMAGE A\",8)) {\n      if (!strcmp(model,\"DiMAGE A200\"))\n\tfilters = 0x49494949;\n      tiff_bps = 12;\n      load_raw = &CLASS packed_load_raw;\n    } else if (!strncmp(model,\"ALPHA\",5) ||\n\t       !strncmp(model,\"DYNAX\",5) ||\n\t       !strncmp(model,\"MAXXUM\",6)) {\n      sprintf (model+20, \"DYNAX %-10s\", model+6+(model[0]=='M'));\n      adobe_coeff (make, model+20);\n      load_raw = &CLASS packed_load_raw;\n    } else if (!strncmp(model,\"DiMAGE G\",8)) {\n      if (model[8] == '4') {\n\theight = 1716;\n\twidth  = 2304;\n      } else if (model[8] == '5') {\nkonica_510z:\n\theight = 1956;\n\twidth  = 2607;\n\traw_width = 2624;\n      } else if (model[8] == '6') {\n\theight = 2136;\n\twidth  = 2848;\n      }\n      data_offset += 14;\n      filters = 0x61616161;\nkonica_400z:\n      load_raw = &CLASS unpacked_load_raw;\n      maximum = 0x3df;\n      order = 0x4d4d;\n    }\n  } else if (!strcmp(model,\"*ist D\")) {\n    load_raw = &CLASS unpacked_load_raw;\n    data_error = -1;\n  } else if (!strcmp(model,\"*ist DS\")) {\n    height -= 2;\n  } else if (!strcmp(model,\"Optio S\")) {\n    if (fsize == 3178560) {\n      height = 1540;\n      width  = 2064;\n      load_raw = &CLASS eight_bit_load_raw;\n      cam_mul[0] *= 4;\n      cam_mul[2] *= 4;\n    } else {\n      height = 1544;\n      width  = 2068;\n      raw_width = 3136;\n      load_raw = &CLASS packed_load_raw;\n      maximum = 0xf7c;\n    }\n  } else if (fsize == 6114240) {\n    height = 1737;\n    width  = 2324;\n    raw_width = 3520;\n    load_raw = &CLASS packed_load_raw;\n    maximum = 0xf7a;\n  } else if (!strcmp(model,\"Optio 750Z\")) {\n    height = 2302;\n    width  = 3072;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 30;\n  } else if (!strcmp(model,\"DC-833m\")) {\n    height = 2448;\n    width  = 3264;\n    order = 0x4949;\n    filters = 0x61616161;\n    load_raw = &CLASS unpacked_load_raw;\n    maximum = 0xfc00;\n  } else if (!strncmp(model,\"S85\",3)) {\n    height = 2448;\n    width  = 3264;\n    raw_width = fsize/height/2;\n    order = 0x4d4d;\n    load_raw = &CLASS unpacked_load_raw;\n  } else if (!strcmp(make,\"SAMSUNG\") && raw_width == 4704) {\n    height -= top_margin = 8;\n    width -= 2 * (left_margin = 8);\n    load_flags = 32;\n  } else if (!strcmp(make,\"SAMSUNG\") && raw_width == 5632) {\n    order = 0x4949;\n    height = 3694;\n    top_margin = 2;\n    width  = 5574 - (left_margin = 32 + tiff_bps);\n    if (tiff_bps == 12) load_flags = 80;\n  } else if (!strcmp(make,\"SAMSUNG\") && !strcmp(model,\"NX300\")) {\n\t  is_raw =0;\n  } else if (!strcmp(model,\"EX1\")) {\n    order = 0x4949;\n    height -= 20;\n    top_margin = 2;\n    if ((width -= 6) > 3682) {\n      height -= 10;\n      width  -= 46;\n      top_margin = 8;\n    }\n  } else if (!strcmp(model,\"WB2000\")) {\n    order = 0x4949;\n    height -= 3;\n    top_margin = 2;\n    if ((width -= 10) > 3718) {\n      height -= 28;\n      width  -= 56;\n      top_margin = 8;\n    }\n  } else if (fsize == 20487168) {\n    height = 2808;\n    width  = 3648;\n    goto wb550;\n  } else if (fsize == 24000000) {\n    height = 3000;\n    width  = 4000;\nwb550:\n    strcpy (model, \"WB550\");\n    order = 0x4d4d;\n    load_raw = &CLASS unpacked_load_raw;\n    load_flags = 6;\n    maximum = 0x3df;\n  } else if (!strcmp(model,\"EX2F\")) {\n    height = 3045;\n    width  = 4070;\n    top_margin = 3;\n    order = 0x4949;\n    filters = 0x49494949;\n    load_raw = &CLASS unpacked_load_raw;\n  } else if (!strcmp(model,\"STV680 VGA\")) {\n    height = 484;\n    width  = 644;\n    load_raw = &CLASS eight_bit_load_raw;\n    flip = 2;\n    filters = 0x16161616;\n    black = 16;\n  }  else\n      identify2(fsize,flen,head); /* Avoid MS VS 2008/2010 bug */\n\n  if (!model[0])\n    sprintf (model, \"%dx%d\", width, height);\n  if (filters == UINT_MAX) filters = 0x94949494;\n  if (raw_color) adobe_coeff (make, model);\n  if (load_raw == &CLASS kodak_radc_load_raw)\n    if (raw_color) adobe_coeff (\"Apple\",\"Quicktake\");\n  if (thumb_offset && !thumb_height) {\n    fseek (ifp, thumb_offset, SEEK_SET);\n    if (ljpeg_start (&jh, 1)) {\n      thumb_width  = jh.wide;\n      thumb_height = jh.high;\n    }\n  }\ndng_skip:\n  if (fuji_width) {\n    fuji_width = width >> !fuji_layout;\n    if (~fuji_width & 1) filters = 0x49494949;\n    width = (height >> fuji_layout) + fuji_width;\n    height = width - 1;\n    pixel_aspect = 1;\n  } else {\n    if (raw_height < height) raw_height = height;\n    if (raw_width  < width ) raw_width  = width;\n  }\n  if (!tiff_bps) tiff_bps = 12;\n  if (!maximum) maximum = (1 << tiff_bps) - 1;\n  if (!load_raw || height < 22) is_raw = 0;\n#ifdef NO_JASPER\n  if (load_raw == &CLASS redcine_load_raw) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s: You must link dcraw with %s!!\\n\"),\n\tifname, \"libjasper\");\n#endif\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_JASPER;\n#endif\n  }\n#endif\n#ifdef NO_JPEG\n  if (load_raw == &CLASS kodak_jpeg_load_raw ||\n      load_raw == &CLASS lossy_dng_load_raw) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s: You must link dcraw with %s!!\\n\"),\n\tifname, \"libjpeg\");\n#endif\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_JPEGLIB;\n#endif\n  }\n#endif\n  if (!cdesc[0])\n    strcpy (cdesc, colors == 3 ? \"RGBG\":\"GMCY\");\n  if (!raw_height) raw_height = height;\n  if (!raw_width ) raw_width  = width;\n  if (filters && colors == 3)\n    filters |= ((filters >> 2 & 0x22222222) |\n\t\t(filters << 2 & 0x88888888)) & filters << 1;\nnotraw:\n  if (flip == -1) flip = tiff_flip;\n  if (flip == -1) flip = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY,1,2);\n#endif\n}\n\nvoid CLASS identify2(unsigned fsize, unsigned flen, char *head)\n{\n  short pana[][6] = {\n    { 3130, 1743,  4,  0, -6,  0 },\n    { 3130, 2055,  4,  0, -6,  0 },\n    { 3130, 2319,  4,  0, -6,  0 },\n    { 3170, 2103, 18,  0,-42, 20 },\n    { 3170, 2367, 18, 13,-42,-21 },\n    { 3177, 2367,  0,  0, -1,  0 },\n    { 3304, 2458,  0,  0, -1,  0 },\n    { 3330, 2463,  9,  0, -5,  0 },\n    { 3330, 2479,  9,  0,-17,  4 },\n    { 3370, 1899, 15,  0,-44, 20 },\n    { 3370, 2235, 15,  0,-44, 20 },\n    { 3370, 2511, 15, 10,-44,-21 },\n    { 3690, 2751,  3,  0, -8, -3 },\n    { 3710, 2751,  0,  0, -3,  0 },\n    { 3724, 2450,  0,  0,  0, -2 },\n    { 3770, 2487, 17,  0,-44, 19 },\n    { 3770, 2799, 17, 15,-44,-19 },\n    { 3880, 2170,  6,  0, -6,  0 },\n    { 4060, 3018,  0,  0,  0, -2 },\n    { 4290, 2391,  3,  0, -8, -1 },\n    { 4330, 2439, 17, 15,-44,-19 },\n    { 4508, 2962,  0,  0, -3, -4 },\n    { 4508, 3330,  0,  0, -3, -6 } };\n\n\n  struct jhead jh;\n  int i;\n if (!strcmp(model,\"N95\")) {\n    height = raw_height - (top_margin = 2);\n  } else if (!strcmp(model,\"531C\")) {\n    height = 1200;\n    width  = 1600;\n    load_raw = &CLASS unpacked_load_raw;\n    filters = 0x49494949;\n  } else if (!strcmp(model,\"640x480\")) {\n    height = 480;\n    width  = 640;\n    load_raw = &CLASS eight_bit_load_raw;\n    gamma_curve (0.45, 4.5, 1, 255);\n  } else if (!strcmp(model,\"F-080C\")) {\n    height = 768;\n    width  = 1024;\n    load_raw = &CLASS eight_bit_load_raw;\n  } else if (!strcmp(model,\"F-145C\")) {\n    height = 1040;\n    width  = 1392;\n    load_raw = &CLASS eight_bit_load_raw;\n  } else if (!strcmp(model,\"F-201C\")) {\n    height = 1200;\n    width  = 1600;\n    load_raw = &CLASS eight_bit_load_raw;\n  } else if (!strcmp(model,\"F-510C\")) {\n    height = 1958;\n    width  = 2588;\n    load_raw = fsize < 7500000 ?\n\t&CLASS eight_bit_load_raw : &CLASS unpacked_load_raw;\n    data_offset = fsize - width*height*(fsize >> 22);\n    maximum = 0xfff0;\n  } else if (!strcmp(model,\"F-810C\")) {\n    height = 2469;\n    width  = 3272;\n    load_raw = &CLASS unpacked_load_raw;\n    maximum = 0xfff0;\n  } else if (!strcmp(model,\"XCD-SX910CR\")) {\n    height = 1024;\n    width  = 1375;\n    raw_width = 1376;\n    filters = 0x49494949;\n    maximum = 0x3ff;\n    load_raw = fsize < 2000000 ?\n\t&CLASS eight_bit_load_raw : &CLASS unpacked_load_raw;\n  } else if (!strcmp(model,\"2010\")) {\n    height = 1207;\n    width  = 1608;\n    order = 0x4949;\n    filters = 0x16161616;\n    data_offset = 3212;\n    maximum = 0x3ff;\n    load_raw = &CLASS unpacked_load_raw;\n  } else if (!strcmp(model,\"A782\")) {\n    height = 3000;\n    width  = 2208;\n    filters = 0x61616161;\n    load_raw = fsize < 10000000 ?\n\t&CLASS eight_bit_load_raw : &CLASS unpacked_load_raw;\n    maximum = 0xffc0;\n  } else if (!strcmp(model,\"3320AF\")) {\n    height = 1536;\n    raw_width = width = 2048;\n    filters = 0x61616161;\n    load_raw = &CLASS unpacked_load_raw;\n    maximum = 0x3ff;\n    fseek (ifp, 0x300000, SEEK_SET);\n    if ((order = guess_byte_order(0x10000)) == 0x4d4d) {\n      height -= (top_margin = 16);\n      width -= (left_margin = 28);\n      maximum = 0xf5c0;\n      strcpy (make, \"ISG\");\n      model[0] = 0;\n    }\n  } else if (!strcmp(make,\"Hasselblad\")) {\n    if (load_raw == &CLASS lossless_jpeg_load_raw)\n      load_raw = &CLASS hasselblad_load_raw;\n    if (raw_width == 7262) {\n      height = 5444;\n      width  = 7248;\n      top_margin  = 4;\n      left_margin = 7;\n      filters = 0x61616161;\n    } else if (raw_width == 7410) {\n      height = 5502;\n      width  = 7328;\n      top_margin  = 4;\n      left_margin = 41;\n      filters = 0x61616161;\n    } else if (raw_width == 9044) {\n      height = 6716;\n      width  = 8964;\n      top_margin  = 8;\n      left_margin = 40;\n      black += load_flags = 256;\n      maximum = 0x8101;\n    } else if (raw_width == 4090) {\n      strcpy (model, \"V96C\");\n      height -= (top_margin = 6);\n      width -= (left_margin = 3) + 7;\n      filters = 0x61616161;\n    }\n  } else if (!strcmp(make,\"Sinar\")) {\n    if (!memcmp(head,\"8BPS\",4)) {\n      fseek (ifp, 14, SEEK_SET);\n      height = get4();\n      width  = get4();\n      filters = 0x61616161;\n      data_offset = 68;\n    }\n    if (!load_raw) load_raw = &CLASS unpacked_load_raw;\n    maximum = 0x3fff;\n  } else if (!strcmp(make,\"Leaf\")) {\n    maximum = 0x3fff;\n    fseek (ifp, data_offset, SEEK_SET);\n    if (ljpeg_start (&jh, 1) && jh.bits == 15)\n      maximum = 0x1fff;\n    if (tiff_samples > 1) filters = 0;\n    if (tiff_samples > 1 || tile_length < raw_height) {\n      load_raw = &CLASS leaf_hdr_load_raw;\n      raw_width = tile_width;\n    }\n    if ((width | height) == 2048) {\n      if (tiff_samples == 1) {\n\tfilters = 1;\n\tstrcpy (cdesc, \"RBTG\");\n\tstrcpy (model, \"CatchLight\");\n\ttop_margin =  8; left_margin = 18; height = 2032; width = 2016;\n      } else {\n\tstrcpy (model, \"DCB2\");\n\ttop_margin = 10; left_margin = 16; height = 2028; width = 2022;\n      }\n    } else if (width+height == 3144+2060) {\n      if (!model[0]) strcpy (model, \"Cantare\");\n      if (width > height) {\n\t top_margin = 6; left_margin = 32; height = 2048;  width = 3072;\n\tfilters = 0x61616161;\n      } else {\n\tleft_margin = 6;  top_margin = 32;  width = 2048; height = 3072;\n\tfilters = 0x16161616;\n      }\n      if (!cam_mul[0] || model[0] == 'V') filters = 0;\n      else is_raw = tiff_samples;\n    } else if (width == 2116) {\n      strcpy (model, \"Valeo 6\");\n      height -= 2 * (top_margin = 30);\n      width -= 2 * (left_margin = 55);\n      filters = 0x49494949;\n    } else if (width == 3171) {\n      strcpy (model, \"Valeo 6\");\n      height -= 2 * (top_margin = 24);\n      width -= 2 * (left_margin = 24);\n      filters = 0x16161616;\n    }\n  } else if (!strcmp(make,\"LEICA\") || !strcmp(make,\"Panasonic\")) {\n    if ((flen - data_offset) / (raw_width*8/7) == raw_height)\n      load_raw = &CLASS panasonic_load_raw;\n    if (!load_raw) {\n      load_raw = &CLASS unpacked_load_raw;\n      load_flags = 4;\n    }\n    zero_is_bad = 1;\n    if ((height += 12) > raw_height) height = raw_height;\n    for (i=0; i < sizeof pana / sizeof *pana; i++)\n      if (raw_width == pana[i][0] && raw_height == pana[i][1]) {\n\tleft_margin = pana[i][2];\n\t top_margin = pana[i][3];\n\t     width += pana[i][4];\n\t    height += pana[i][5];\n      }\n    filters = 0x01010101 * (uchar) \"\\x94\\x61\\x49\\x16\"\n\t[((filters-1) ^ (left_margin & 1) ^ (top_margin << 1)) & 3];\n  } else if (!strcmp(model,\"C770UZ\")) {\n    height = 1718;\n    width  = 2304;\n    filters = 0x16161616;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 30;\n  } else if (!strcmp(make,\"OLYMPUS\")) {\n    height += height & 1;\n    filters = exif_cfa;\n    if (width == 4100) width -= 4;\n    if (width == 4080) width -= 24;\n    if (load_raw == &CLASS unpacked_load_raw)\n      load_flags = 4;\n    tiff_bps = 12;\n    if (!strcmp(model,\"E-300\") ||\n\t!strcmp(model,\"E-500\")) {\n      width -= 20;\n      if (load_raw == &CLASS unpacked_load_raw) {\n\tmaximum = 0xfc3;\n\tmemset (cblack, 0, sizeof cblack);\n      }\n    } else if (!strcmp(model,\"E-330\")) {\n      width -= 30;\n      if (load_raw == &CLASS unpacked_load_raw)\n\tmaximum = 0xf79;\n    } else if (!strcmp(model,\"SP550UZ\")) {\n      thumb_length = flen - (thumb_offset = 0xa39800);\n      thumb_height = 480;\n      thumb_width  = 640;\n    } else if (!strcmp(model,\"XZ-2\")) {\n      load_raw = &CLASS packed_load_raw;\n      load_flags = 24;\n    } else if (!strcmp(model,\"XZ-10\")) {\n      load_raw = &CLASS packed_load_raw;\n      load_flags = 24;\n    }\n  } else if (!strcmp(model,\"N Digital\")) {\n    height = 2047;\n    width  = 3072;\n    filters = 0x61616161;\n    data_offset = 0x1a00;\n    load_raw = &CLASS packed_load_raw;\n  } else if (!strcmp(model,\"DSC-F828\")) {\n    width = 3288;\n    left_margin = 5;\n    mask[1][3] = -17;\n    data_offset = 862144;\n    load_raw = &CLASS sony_load_raw;\n    filters = 0x9c9c9c9c;\n    colors = 4;\n    strcpy (cdesc, \"RGBE\");\n  } else if (!strcmp(model,\"DSC-V3\")) {\n    width = 3109;\n    left_margin = 59;\n    mask[0][1] = 9;\n    data_offset = 787392;\n    load_raw = &CLASS sony_load_raw;\n  } else if (!strcmp(make,\"SONY\") && raw_width == 3984) {\n    adobe_coeff (\"SONY\",\"DSC-R1\");\n    width = 3925;\n    order = 0x4d4d;\n  } else if (!strcmp(make,\"SONY\") && raw_width == 5504) {\n    width -= 8;\n  } else if (!strcmp(make,\"SONY\") && raw_width == 6048) {\n    width -= 24;\n  } else if (!strcmp(model,\"DSLR-A100\")) {\n    if (width == 3880) {\n      height--;\n      width = ++raw_width;\n    } else {\n      order = 0x4d4d;\n      load_flags = 2;\n    }\n    filters = 0x61616161;\n  } else if (!strcmp(model,\"DSLR-A350\")) {\n    height -= 4;\n  } else if (!strcmp(model,\"PIXL\")) {\n    height -= top_margin = 4;\n    width -= left_margin = 32;\n    gamma_curve (0, 7, 1, 255);\n  } else if (!strcmp(model,\"C603v\")) {\n    height = 480;\n    width  = 640;\n    if (fsize < 614400 || find_green (16, 16, 3840, 5120) < 25) goto c603v;\n    strcpy (model,\"KAI-0340\");\n    height -= 3;\n    data_offset = 3840;\n    order = 0x4949;\n    load_raw = &CLASS unpacked_load_raw;\n  } else if (!strcmp(model,\"C603y\")) {\n    height = 2134;\n    width  = 2848;\nc603v:\n    filters = 0;\n    load_raw = &CLASS kodak_yrgb_load_raw;\n    gamma_curve (0, 3.875, 1, 255);\n  } else if (!strcmp(model,\"C603\")) {\n    raw_height = height = 2152;\n    raw_width  = width  = 2864;\n    goto c603;\n  } else if (!strcmp(model,\"C330\")) {\n    height = 1744;\n    width  = 2336;\n    raw_height = 1779;\n    raw_width  = 2338;\n    top_margin = 33;\n    left_margin = 1;\nc603:\n    order = 0x4949;\n    if ((data_offset = fsize - raw_height*raw_width)) {\n      fseek (ifp, 168, SEEK_SET);\n      read_shorts (curve, 256);\n    } else gamma_curve (0, 3.875, 1, 255);\n    load_raw = &CLASS eight_bit_load_raw;\n  } else if (!strncasecmp(model,\"EasyShare\",9)) {\n    data_offset = data_offset < 0x15000 ? 0x15000 : 0x17000;\n    load_raw = &CLASS packed_load_raw;\n  } else if (!strcasecmp(make,\"KODAK\")) {\n    if (filters == UINT_MAX) filters = 0x61616161;\n    if (!strncmp(model,\"NC2000\",6)) {\n      width -= 4;\n      left_margin = 2;\n    } else if (!strcmp(model,\"EOSDCS3B\")) {\n      width -= 4;\n      left_margin = 2;\n    } else if (!strcmp(model,\"EOSDCS1\")) {\n      width -= 4;\n      left_margin = 2;\n    } else if (!strcmp(model,\"DCS420\")) {\n      width -= 4;\n      left_margin = 2;\n    } else if (!strncmp(model,\"DCS460 \",7)) {\n      model[6] = 0;\n      width -= 4;\n      left_margin = 2;\n    } else if (!strcmp(model,\"DCS460A\")) {\n      width -= 4;\n      left_margin = 2;\n      colors = 1;\n      filters = 0;\n    } else if (!strcmp(model,\"DCS660M\")) {\n      black = 214;\n      colors = 1;\n      filters = 0;\n    } else if (!strcmp(model,\"DCS760M\")) {\n      colors = 1;\n      filters = 0;\n    }\n    if (!strcmp(model+4,\"20X\"))\n      strcpy (cdesc, \"MYCY\");\n    if (strstr(model,\"DC25\")) {\n      strcpy (model, \"DC25\");\n      data_offset = 15424;\n    }\n    if (!strncmp(model,\"DC2\",3)) {\n      raw_height = height = 242;\n      if (flen < 100000) {\n\traw_width = 256; width = 249;\n\tpixel_aspect = (4.0*height) / (3.0*width);\n      } else {\n\traw_width = 512; width = 501;\n\tpixel_aspect = (493.0*height) / (373.0*width);\n      }\n      data_offset += raw_width + 1;\n      colors = 4;\n      filters = 0x8d8d8d8d;\n      simple_coeff(1);\n      pre_mul[1] = 1.179;\n      pre_mul[2] = 1.209;\n      pre_mul[3] = 1.036;\n      load_raw = &CLASS eight_bit_load_raw;\n    } else if (!strcmp(model,\"40\")) {\n      strcpy (model, \"DC40\");\n      height = 512;\n      width  = 768;\n      data_offset = 1152;\n      load_raw = &CLASS kodak_radc_load_raw;\n    } else if (strstr(model,\"DC50\")) {\n      strcpy (model, \"DC50\");\n      height = 512;\n      width  = 768;\n      data_offset = 19712;\n      load_raw = &CLASS kodak_radc_load_raw;\n    } else if (strstr(model,\"DC120\")) {\n      strcpy (model, \"DC120\");\n      height = 976;\n      width  = 848;\n      pixel_aspect = height/0.75/width;\n      load_raw = tiff_compress == 7 ?\n\t&CLASS kodak_jpeg_load_raw : &CLASS kodak_dc120_load_raw;\n    } else if (!strcmp(model,\"DCS200\")) {\n      thumb_height = 128;\n      thumb_width  = 192;\n      thumb_offset = 6144;\n      thumb_misc   = 360;\n      write_thumb = &CLASS layer_thumb;\n      height = 1024;\n      width  = 1536;\n      data_offset = 79872;\n      load_raw = &CLASS eight_bit_load_raw;\n      black = 17;\n    }\n  } else if (!strcmp(model,\"Fotoman Pixtura\")) {\n    height = 512;\n    width  = 768;\n    data_offset = 3632;\n    load_raw = &CLASS kodak_radc_load_raw;\n    filters = 0x61616161;\n    simple_coeff(2);\n  } else if (!strncmp(model,\"QuickTake\",9)) {\n    if (head[5]) strcpy (model+10, \"200\");\n    fseek (ifp, 544, SEEK_SET);\n    height = get2();\n    width  = get2();\n    data_offset = (get4(),get2()) == 30 ? 738:736;\n    if (height > width) {\n      SWAP(height,width);\n      fseek (ifp, data_offset-6, SEEK_SET);\n      flip = ~get2() & 3 ? 5:6;\n    }\n    filters = 0x61616161;\n  } else if (!strcmp(make,\"Rollei\") && !load_raw) {\n    switch (raw_width) {\n      case 1316:\n\theight = 1030;\n\twidth  = 1300;\n\ttop_margin  = 1;\n\tleft_margin = 6;\n\tbreak;\n      case 2568:\n\theight = 1960;\n\twidth  = 2560;\n\ttop_margin  = 2;\n\tleft_margin = 8;\n    }\n    filters = 0x16161616;\n    load_raw = &CLASS rollei_load_raw;\n  } else if (!strcmp(model,\"PC-CAM 600\")) {\n    height = 768;\n    data_offset = width = 1024;\n    filters = 0x49494949;\n    load_raw = &CLASS eight_bit_load_raw;\n  } else if (!strcmp(model,\"QV-2000UX\")) {\n    height = 1208;\n    width  = 1632;\n    data_offset = width * 2;\n    load_raw = &CLASS eight_bit_load_raw;\n  } else if (fsize == 3217760) {\n    height = 1546;\n    width  = 2070;\n    raw_width = 2080;\n    load_raw = &CLASS eight_bit_load_raw;\n  } else if (!strcmp(model,\"QV-4000\")) {\n    height = 1700;\n    width  = 2260;\n    load_raw = &CLASS unpacked_load_raw;\n    maximum = 0xffff;\n  } else if (!strcmp(model,\"QV-5700\")) {\n    height = 1924;\n    width  = 2576;\n    raw_width = 3232;\n    tiff_bps = 10;\n  } else if (!strcmp(model,\"QV-R41\")) {\n    height = 1720;\n    width  = 2312;\n    raw_width = 3520;\n    left_margin = 2;\n  } else if (!strcmp(model,\"QV-R51\")) {\n    height = 1926;\n    width  = 2580;\n    raw_width = 3904;\n  } else if (!strcmp(model,\"EX-S20\")) {\n    height = 1208;\n    width  = 1620;\n    raw_width = 2432;\n    flip = 3;\n  } else if (!strcmp(model,\"EX-S100\")) {\n    height = 1544;\n    width  = 2058;\n    raw_width = 3136;\n  } else if (!strcmp(model,\"EX-Z50\")) {\n    height = 1931;\n    width  = 2570;\n    raw_width = 3904;\n  } else if (!strcmp(model,\"EX-Z500\")) {\n    height = 1937;\n    width  = 2577;\n    raw_width = 3904;\n    filters = 0x16161616;\n  } else if (!strcmp(model,\"EX-Z55\")) {\n    height = 1960;\n    width  = 2570;\n    raw_width = 3904;\n  } else if (!strcmp(model,\"EX-Z60\")) {\n    height = 2145;\n    width  = 2833;\n    raw_width = 3584;\n    filters = 0x16161616;\n    tiff_bps = 10;\n  } else if (!strcmp(model,\"EX-Z75\")) {\n    height = 2321;\n    width  = 3089;\n    raw_width = 4672;\n    maximum = 0xfff;\n  } else if (!strcmp(model,\"EX-Z750\")) {\n    height = 2319;\n    width  = 3087;\n    raw_width = 4672;\n    maximum = 0xfff;\n  } else if (!strcmp(model,\"EX-Z850\")) {\n    height = 2468;\n    width  = 3279;\n    raw_width = 4928;\n    maximum = 0xfff;\n  } else if (!strcmp(model,\"EX-Z8\")) {\n    height = 2467;\n    width  = 3281;\n    raw_height = 2502;\n    raw_width  = 4992;\n    maximum = 0xfff;\n  } else if (fsize == 15499264) {\t/* EX-Z1050 or EX-Z1080 */\n    height = 2752;\n    width  = 3672;\n    raw_width = 5632;\n  } else if (!strcmp(model,\"EX-ZR100\")) {\n    height = 3044;\n    width  = 4072;\n    raw_width = 4096;\n    load_flags = 80;\n  } else if (!strcmp(model,\"EX-P505\")) {\n    height = 1928;\n    width  = 2568;\n    raw_width = 3852;\n    maximum = 0xfff;\n  } else if (fsize == 9313536) {\t/* EX-P600 or QV-R61 */\n    height = 2142;\n    width  = 2844;\n    raw_width = 4288;\n  } else if (!strcmp(model,\"EX-P700\")) {\n    height = 2318;\n    width  = 3082;\n    raw_width = 4672;\n  }\n  else if (!strcmp(model,\"GRAS-50S5C\")) {\n   height = 2048;\n   width = 2440;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x49494949;\n   order = 0x4949;\n   maximum = 0xfffC;\n  } else if (!strcmp(model,\"BB-500CL\")) {\n   height = 2058;\n   width = 2448;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x94949494;\n   order = 0x4949;\n   maximum = 0x3fff;\n  } else if (!strcmp(model,\"BB-500GE\")) {\n   height = 2058;\n   width = 2456;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x94949494;\n   order = 0x4949;\n   maximum = 0x3fff;\n  } else if (!strcmp(model,\"SVS625CL\")) {\n   height = 2050;\n   width = 2448;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x94949494;\n   order = 0x4949;\n   maximum = 0x0fff;\n  }\n}\n\n\n#line 10231 \"dcraw/dcraw.c\"\nvoid CLASS convert_to_rgb()\n{\n#ifndef LIBRAW_LIBRARY_BUILD\n  int row, col, c;\n#endif\n  int  i, j, k;\n#ifndef LIBRAW_LIBRARY_BUILD\n  ushort *img;\n  float out[3];\n#endif\n  float out_cam[3][4];\n  double num, inverse[3][3];\n  static const double xyzd50_srgb[3][3] =\n  { { 0.436083, 0.385083, 0.143055 },\n    { 0.222507, 0.716888, 0.060608 },\n    { 0.013930, 0.097097, 0.714022 } };\n  static const double rgb_rgb[3][3] =\n  { { 1,0,0 }, { 0,1,0 }, { 0,0,1 } };\n  static const double adobe_rgb[3][3] =\n  { { 0.715146, 0.284856, 0.000000 },\n    { 0.000000, 1.000000, 0.000000 },\n    { 0.000000, 0.041166, 0.958839 } };\n  static const double wide_rgb[3][3] =\n  { { 0.593087, 0.404710, 0.002206 },\n    { 0.095413, 0.843149, 0.061439 },\n    { 0.011621, 0.069091, 0.919288 } };\n  static const double prophoto_rgb[3][3] =\n  { { 0.529317, 0.330092, 0.140588 },\n    { 0.098368, 0.873465, 0.028169 },\n    { 0.016879, 0.117663, 0.865457 } };\n  static const double (*out_rgb[])[3] =\n  { rgb_rgb, adobe_rgb, wide_rgb, prophoto_rgb, xyz_rgb };\n  static const char *name[] =\n  { \"sRGB\", \"Adobe RGB (1998)\", \"WideGamut D65\", \"ProPhoto D65\", \"XYZ\" };\n  static const unsigned phead[] =\n  { 1024, 0, 0x2100000, 0x6d6e7472, 0x52474220, 0x58595a20, 0, 0, 0,\n    0x61637370, 0, 0, 0x6e6f6e65, 0, 0, 0, 0, 0xf6d6, 0x10000, 0xd32d };\n  unsigned pbody[] =\n  { 10, 0x63707274, 0, 36,\t/* cprt */\n\t0x64657363, 0, 40,\t/* desc */\n\t0x77747074, 0, 20,\t/* wtpt */\n\t0x626b7074, 0, 20,\t/* bkpt */\n\t0x72545243, 0, 14,\t/* rTRC */\n\t0x67545243, 0, 14,\t/* gTRC */\n\t0x62545243, 0, 14,\t/* bTRC */\n\t0x7258595a, 0, 20,\t/* rXYZ */\n\t0x6758595a, 0, 20,\t/* gXYZ */\n\t0x6258595a, 0, 20 };\t/* bXYZ */\n  static const unsigned pwhite[] = { 0xf351, 0x10000, 0x116cc };\n  unsigned pcurve[] = { 0x63757276, 0, 1, 0x1000000 };\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB,0,2);\n#endif\n  gamma_curve (gamm[0], gamm[1], 0, 0);\n  memcpy (out_cam, rgb_cam, sizeof out_cam);\n#ifndef LIBRAW_LIBRARY_BUILD\n  raw_color |= colors == 1 || document_mode ||\n\t\toutput_color < 1 || output_color > 5;\n#else\n  raw_color |= colors == 1 || \n\t\toutput_color < 1 || output_color > 5;\n#endif\n  if (!raw_color) {\n    oprof = (unsigned *) calloc (phead[0], 1);\n    merror (oprof, \"convert_to_rgb()\");\n    memcpy (oprof, phead, sizeof phead);\n    if (output_color == 5) oprof[4] = oprof[5];\n    oprof[0] = 132 + 12*pbody[0];\n    for (i=0; i < pbody[0]; i++) {\n      oprof[oprof[0]/4] = i ? (i > 1 ? 0x58595a20 : 0x64657363) : 0x74657874;\n      pbody[i*3+2] = oprof[0];\n      oprof[0] += (pbody[i*3+3] + 3) & -4;\n    }\n    memcpy (oprof+32, pbody, sizeof pbody);\n    oprof[pbody[5]/4+2] = strlen(name[output_color-1]) + 1;\n    memcpy ((char *)oprof+pbody[8]+8, pwhite, sizeof pwhite);\n    pcurve[3] = (short)(256/gamm[5]+0.5) << 16;\n    for (i=4; i < 7; i++)\n      memcpy ((char *)oprof+pbody[i*3+2], pcurve, sizeof pcurve);\n    pseudoinverse ((double (*)[3]) out_rgb[output_color-1], inverse, 3);\n    for (i=0; i < 3; i++)\n      for (j=0; j < 3; j++) {\n\tfor (num = k=0; k < 3; k++)\n\t  num += xyzd50_srgb[i][k] * inverse[j][k];\n\toprof[pbody[j*3+23]/4+i+2] = num * 0x10000 + 0.5;\n      }\n    for (i=0; i < phead[0]/4; i++)\n      oprof[i] = htonl(oprof[i]);\n    strcpy ((char *)oprof+pbody[2]+8, \"auto-generated by dcraw\");\n    strcpy ((char *)oprof+pbody[5]+12, name[output_color-1]);\n    for (i=0; i < 3; i++)\n      for (j=0; j < colors; j++)\n\tfor (out_cam[i][j] = k=0; k < 3; k++)\n\t  out_cam[i][j] += out_rgb[output_color-1][i][k] * rgb_cam[k][j];\n  }\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf (stderr, raw_color ? _(\"Building histograms...\\n\") :\n\t_(\"Converting to %s colorspace...\\n\"), name[output_color-1]);\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  convert_to_rgb_loop(out_cam);\n#else\n  memset (histogram, 0, sizeof histogram);\n  for (img=image[0], row=0; row < height; row++)\n    for (col=0; col < width; col++, img+=4) {\n      if (!raw_color) {\n\tout[0] = out[1] = out[2] = 0;\n\tFORCC {\n\t  out[0] += out_cam[0][c] * img[c];\n\t  out[1] += out_cam[1][c] * img[c];\n\t  out[2] += out_cam[2][c] * img[c];\n\t}\n\tFORC3 img[c] = CLIP((int) out[c]);\n      }\n      else if (document_mode)\n\timg[0] = img[fcol(row,col)];\n      FORCC histogram[c][img[c] >> 3]++;\n    }\n#endif\n  if (colors == 4 && output_color) colors = 3;\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (document_mode && filters) colors = 1;\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB,1,2);\n#endif\n}\n\nvoid CLASS fuji_rotate()\n{\n  int i, row, col;\n  double step;\n  float r, c, fr, fc;\n  unsigned ur, uc;\n  ushort wide, high, (*img)[4], (*pix)[4];\n\n  if (!fuji_width) return;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf (stderr,_(\"Rotating image 45 degrees...\\n\"));\n#endif\n  fuji_width = (fuji_width - 1 + shrink) >> shrink;\n  step = sqrt(0.5);\n  wide = fuji_width / step;\n  high = (height - fuji_width) / step;\n  img = (ushort (*)[4]) calloc (wide*high, sizeof *img);\n  merror (img, \"fuji_rotate()\");\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE,0,2);\n#endif\n\n  for (row=0; row < high; row++)\n    for (col=0; col < wide; col++) {\n      ur = r = fuji_width + (row-col)*step;\n      uc = c = (row+col)*step;\n      if (ur > height-2 || uc > width-2) continue;\n      fr = r - ur;\n      fc = c - uc;\n      pix = image + ur*width + uc;\n      for (i=0; i < colors; i++)\n\timg[row*wide+col][i] =\n\t  (pix[    0][i]*(1-fc) + pix[      1][i]*fc) * (1-fr) +\n\t  (pix[width][i]*(1-fc) + pix[width+1][i]*fc) * fr;\n    }\n\n  free (image);\n  width  = wide;\n  height = high;\n  image  = img;\n  fuji_width = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE,1,2);\n#endif\n}\n\nvoid CLASS stretch()\n{\n  ushort newdim, (*img)[4], *pix0, *pix1;\n  int row, col, c;\n  double rc, frac;\n\n  if (pixel_aspect == 1) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH,0,2);\n#endif\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Stretching the image...\\n\"));\n#endif\n  if (pixel_aspect < 1) {\n    newdim = height / pixel_aspect + 0.5;\n    img = (ushort (*)[4]) calloc (width*newdim, sizeof *img);\n    merror (img, \"stretch()\");\n    for (rc=row=0; row < newdim; row++, rc+=pixel_aspect) {\n      frac = rc - (c = rc);\n      pix0 = pix1 = image[c*width];\n      if (c+1 < height) pix1 += width*4;\n      for (col=0; col < width; col++, pix0+=4, pix1+=4)\n\tFORCC img[row*width+col][c] = pix0[c]*(1-frac) + pix1[c]*frac + 0.5;\n    }\n    height = newdim;\n  } else {\n    newdim = width * pixel_aspect + 0.5;\n    img = (ushort (*)[4]) calloc (height*newdim, sizeof *img);\n    merror (img, \"stretch()\");\n    for (rc=col=0; col < newdim; col++, rc+=1/pixel_aspect) {\n      frac = rc - (c = rc);\n      pix0 = pix1 = image[c];\n      if (c+1 < width) pix1 += 4;\n      for (row=0; row < height; row++, pix0+=width*4, pix1+=width*4)\n\tFORCC img[row*newdim+col][c] = pix0[c]*(1-frac) + pix1[c]*frac + 0.5;\n    }\n    width = newdim;\n  }\n  free (image);\n  image = img;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH,1,2);\n#endif\n}\n\nint CLASS flip_index (int row, int col)\n{\n  if (flip & 4) SWAP(row,col);\n  if (flip & 2) row = iheight - 1 - row;\n  if (flip & 1) col = iwidth  - 1 - col;\n  return row * iwidth + col;\n}\n#line 10487 \"dcraw/dcraw.c\"\nvoid CLASS tiff_set (ushort *ntag,\n\tushort tag, ushort type, int count, int val)\n{\n  struct tiff_tag *tt;\n  int c;\n\n  tt = (struct tiff_tag *)(ntag+1) + (*ntag)++;\n  tt->tag = tag;\n  tt->type = type;\n  tt->count = count;\n  if (type < 3 && count <= 4)\n    FORC(4) tt->val.c[c] = val >> (c << 3);\n  else if (type == 3 && count <= 2)\n    FORC(2) tt->val.s[c] = val >> (c << 4);\n  else tt->val.i = val;\n}\n\n#define TOFF(ptr) ((char *)(&(ptr)) - (char *)th)\n\nvoid CLASS tiff_head (struct tiff_hdr *th, int full)\n{\n  int c, psize=0;\n  struct tm *t;\n\n  memset (th, 0, sizeof *th);\n  th->t_order = htonl(0x4d4d4949) >> 16;\n  th->magic = 42;\n  th->ifd = 10;\n  if (full) {\n    tiff_set (&th->ntag, 254, 4, 1, 0);\n    tiff_set (&th->ntag, 256, 4, 1, width);\n    tiff_set (&th->ntag, 257, 4, 1, height);\n    tiff_set (&th->ntag, 258, 3, colors, output_bps);\n    if (colors > 2)\n      th->tag[th->ntag-1].val.i = TOFF(th->bps);\n    FORC4 th->bps[c] = output_bps;\n    tiff_set (&th->ntag, 259, 3, 1, 1);\n    tiff_set (&th->ntag, 262, 3, 1, 1 + (colors > 1));\n  }\n  tiff_set (&th->ntag, 270, 2, 512, TOFF(th->t_desc));\n  tiff_set (&th->ntag, 271, 2, 64, TOFF(th->t_make));\n  tiff_set (&th->ntag, 272, 2, 64, TOFF(th->t_model));\n  if (full) {\n    if (oprof) psize = ntohl(oprof[0]);\n    tiff_set (&th->ntag, 273, 4, 1, sizeof *th + psize);\n    tiff_set (&th->ntag, 277, 3, 1, colors);\n    tiff_set (&th->ntag, 278, 4, 1, height);\n    tiff_set (&th->ntag, 279, 4, 1, height*width*colors*output_bps/8);\n  } else\n    tiff_set (&th->ntag, 274, 3, 1, \"12435867\"[flip]-'0');\n  tiff_set (&th->ntag, 282, 5, 1, TOFF(th->rat[0]));\n  tiff_set (&th->ntag, 283, 5, 1, TOFF(th->rat[2]));\n  tiff_set (&th->ntag, 284, 3, 1, 1);\n  tiff_set (&th->ntag, 296, 3, 1, 2);\n  tiff_set (&th->ntag, 305, 2, 32, TOFF(th->soft));\n  tiff_set (&th->ntag, 306, 2, 20, TOFF(th->date));\n  tiff_set (&th->ntag, 315, 2, 64, TOFF(th->t_artist));\n  tiff_set (&th->ntag, 34665, 4, 1, TOFF(th->nexif));\n  if (psize) tiff_set (&th->ntag, 34675, 7, psize, sizeof *th);\n  tiff_set (&th->nexif, 33434, 5, 1, TOFF(th->rat[4]));\n  tiff_set (&th->nexif, 33437, 5, 1, TOFF(th->rat[6]));\n  tiff_set (&th->nexif, 34855, 3, 1, iso_speed);\n  tiff_set (&th->nexif, 37386, 5, 1, TOFF(th->rat[8]));\n  if (gpsdata[1]) {\n    tiff_set (&th->ntag, 34853, 4, 1, TOFF(th->ngps));\n    tiff_set (&th->ngps,  0, 1,  4, 0x202);\n    tiff_set (&th->ngps,  1, 2,  2, gpsdata[29]);\n    tiff_set (&th->ngps,  2, 5,  3, TOFF(th->gps[0]));\n    tiff_set (&th->ngps,  3, 2,  2, gpsdata[30]);\n    tiff_set (&th->ngps,  4, 5,  3, TOFF(th->gps[6]));\n    tiff_set (&th->ngps,  5, 1,  1, gpsdata[31]);\n    tiff_set (&th->ngps,  6, 5,  1, TOFF(th->gps[18]));\n    tiff_set (&th->ngps,  7, 5,  3, TOFF(th->gps[12]));\n    tiff_set (&th->ngps, 18, 2, 12, TOFF(th->gps[20]));\n    tiff_set (&th->ngps, 29, 2, 12, TOFF(th->gps[23]));\n    memcpy (th->gps, gpsdata, sizeof th->gps);\n  }\n  th->rat[0] = th->rat[2] = 300;\n  th->rat[1] = th->rat[3] = 1;\n  FORC(6) th->rat[4+c] = 1000000;\n  th->rat[4] *= shutter;\n  th->rat[6] *= aperture;\n  th->rat[8] *= focal_len;\n  strncpy (th->t_desc, desc, 512);\n  strncpy (th->t_make, make, 64);\n  strncpy (th->t_model, model, 64);\n  strcpy (th->soft, \"dcraw v\"DCRAW_VERSION);\n  t = localtime (&timestamp);\n  sprintf (th->date, \"%04d:%02d:%02d %02d:%02d:%02d\",\n      t->tm_year+1900,t->tm_mon+1,t->tm_mday,t->tm_hour,t->tm_min,t->tm_sec);\n  strncpy (th->t_artist, artist, 64);\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\nvoid CLASS jpeg_thumb_writer (FILE *tfp,char *t_humb,int t_humb_length)\n{\n  ushort exif[5];\n  struct tiff_hdr th;\n  fputc (0xff, tfp);\n  fputc (0xd8, tfp);\n  if (strcmp (t_humb+6, \"Exif\")) {\n    memcpy (exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n    exif[1] = htons (8 + sizeof th);\n    fwrite (exif, 1, sizeof exif, tfp);\n    tiff_head (&th, 0);\n    fwrite (&th, 1, sizeof th, tfp);\n  }\n  fwrite (t_humb+2, 1, t_humb_length-2, tfp);\n}\n\nvoid CLASS jpeg_thumb()\n{\n  char *thumb;\n\n  thumb = (char *) malloc (thumb_length);\n  merror (thumb, \"jpeg_thumb()\");\n  fread (thumb, 1, thumb_length, ifp);\n  jpeg_thumb_writer(ofp,thumb,thumb_length);\n  free (thumb);\n}\n#else\nvoid CLASS jpeg_thumb()\n{\n  char *thumb;\n  ushort exif[5];\n  struct tiff_hdr th;\n\n  thumb = (char *) malloc (thumb_length);\n  merror (thumb, \"jpeg_thumb()\");\n  fread (thumb, 1, thumb_length, ifp);\n  fputc (0xff, ofp);\n  fputc (0xd8, ofp);\n  if (strcmp (thumb+6, \"Exif\")) {\n    memcpy (exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n    exif[1] = htons (8 + sizeof th);\n    fwrite (exif, 1, sizeof exif, ofp);\n    tiff_head (&th, 0);\n    fwrite (&th, 1, sizeof th, ofp);\n  }\n  fwrite (thumb+2, 1, thumb_length-2, ofp);\n  free (thumb);\n}\n#endif\n\nvoid CLASS write_ppm_tiff()\n{\n  struct tiff_hdr th;\n  uchar *ppm;\n  ushort *ppm2;\n  int c, row, col, soff, rstep, cstep;\n  int perc, val, total, t_white=0x2000;\n\n  perc = width * height * 0.01;\t\t/* 99th percentile white level */\n  if (fuji_width) perc /= 2;\n  if (!((highlight & ~2) || no_auto_bright))\n    for (t_white=c=0; c < colors; c++) {\n      for (val=0x2000, total=0; --val > 32; )\n\tif ((total += histogram[c][val]) > perc) break;\n      if (t_white < val) t_white = val;\n    }\n  gamma_curve (gamm[0], gamm[1], 2, (t_white << 3)/bright);\n  iheight = height;\n  iwidth  = width;\n  if (flip & 4) SWAP(height,width);\n  ppm = (uchar *) calloc (width, colors*output_bps/8);\n  ppm2 = (ushort *) ppm;\n  merror (ppm, \"write_ppm_tiff()\");\n  if (output_tiff) {\n    tiff_head (&th, 1);\n    fwrite (&th, sizeof th, 1, ofp);\n    if (oprof)\n      fwrite (oprof, ntohl(oprof[0]), 1, ofp);\n  } else if (colors > 3)\n    fprintf (ofp,\n      \"P7\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %d\\nMAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\",\n\twidth, height, colors, (1 << output_bps)-1, cdesc);\n  else\n    fprintf (ofp, \"P%d\\n%d %d\\n%d\\n\",\n\tcolors/2+5, width, height, (1 << output_bps)-1);\n  soff  = flip_index (0, 0);\n  cstep = flip_index (0, 1) - soff;\n  rstep = flip_index (1, 0) - flip_index (0, width);\n  for (row=0; row < height; row++, soff += rstep) {\n    for (col=0; col < width; col++, soff += cstep)\n      if (output_bps == 8)\n\t   FORCC ppm [col*colors+c] = curve[image[soff][c]] >> 8;\n      else FORCC ppm2[col*colors+c] = curve[image[soff][c]];\n    if (output_bps == 16 && !output_tiff && htons(0x55aa) != 0x55aa)\n      swab ((char*)ppm2, (char*)ppm2, width*colors*2);\n    fwrite (ppm, colors*output_bps/8, width, ofp);\n  }\n  free (ppm);\n}\n", "/* \n  Copyright 2008-2013 LibRaw LLC (info@libraw.org)\n\nLibRaw is free software; you can redistribute it and/or modify\nit under the terms of the one of three licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n3. LibRaw Software License 27032010\n   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).\n\n   This file is generated from Dave Coffin's dcraw.c\n   dcraw.c -- Dave Coffin's raw photo decoder\n   Copyright 1997-2010 by Dave Coffin, dcoffin a cybercom o net\n\n   Look into dcraw homepage (probably http://cybercom.net/~dcoffin/dcraw/)\n   for more information\n*/\n\n#line 3948 \"dcraw/dcraw.c\"\n#include <math.h>\n#define CLASS LibRaw::\n#include \"libraw/libraw_types.h\"\n#define LIBRAW_LIBRARY_BUILD\n#include \"libraw/libraw.h\"\n#include \"internal/defines.h\"\n#include \"internal/var_defines.h\"\n#line 3959 \"dcraw/dcraw.c\"\n/*\n   Seach from the current directory up to the root looking for\n   a \".badpixels\" file, and fix those pixels now.\n */\nvoid CLASS bad_pixels (const char *cfname)\n{\n  FILE *fp=NULL;\n#ifndef LIBRAW_LIBRARY_BUILD\n  char *fname, *cp, line[128];\n  int len, time, row, col, r, c, rad, tot, n, fixed=0;\n#else\n  char *cp, line[128];\n  int time, row, col, r, c, rad, tot, n;\n#ifdef DCRAW_VERBOSE\n  int fixed = 0;\n#endif\n#endif\n\n  if (!filters) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,0,2);\n#endif\n  if (cfname)\n    fp = fopen (cfname, \"r\");\n#line 4009 \"dcraw/dcraw.c\"\n  if (!fp)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_BADPIXELMAP;\n#endif\n          return;\n      }\n  while (fgets (line, 128, fp)) {\n    cp = strchr (line, '#');\n    if (cp) *cp = 0;\n    if (sscanf (line, \"%d %d %d\", &col, &row, &time) != 3) continue;\n    if ((unsigned) col >= width || (unsigned) row >= height) continue;\n    if (time > timestamp) continue;\n    for (tot=n=0, rad=1; rad < 3 && n==0; rad++)\n      for (r = row-rad; r <= row+rad; r++)\n\tfor (c = col-rad; c <= col+rad; c++)\n\t  if ((unsigned) r < height && (unsigned) c < width &&\n\t\t(r != row || c != col) && fcol(r,c) == fcol(row,col)) {\n\t    tot += BAYER2(r,c);\n\t    n++;\n\t  }\n    BAYER2(row,col) = tot/n;\n#ifdef DCRAW_VERBOSE\n    if (verbose) {\n      if (!fixed++)\n\tfprintf (stderr,_(\"Fixed dead pixels at:\"));\n      fprintf (stderr, \" %d,%d\", col, row);\n    }\n#endif\n  }\n#ifdef DCRAW_VERBOSE\n  if (fixed) fputc ('\\n', stderr);\n#endif\n  fclose (fp);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,1,2);\n#endif\n}\n\nvoid CLASS subtract (const char *fname)\n{\n  FILE *fp;\n  int dim[3]={0,0,0}, comment=0, number=0, error=0, nd=0, c, row, col;\n  ushort *pixel;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME,0,2);\n#endif\n\n  if (!(fp = fopen (fname, \"rb\"))) {\n#ifdef DCRAW_VERBOSE\n    perror (fname); \n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_BAD_DARKFRAME_FILE;\n#endif\n    return;\n  }\n  if (fgetc(fp) != 'P' || fgetc(fp) != '5') error = 1;\n  while (!error && nd < 3 && (c = fgetc(fp)) != EOF) {\n    if (c == '#')  comment = 1;\n    if (c == '\\n') comment = 0;\n    if (comment) continue;\n    if (isdigit(c)) number = 1;\n    if (number) {\n      if (isdigit(c)) dim[nd] = dim[nd]*10 + c -'0';\n      else if (isspace(c)) {\n\tnumber = 0;  nd++;\n      } else error = 1;\n    }\n  }\n  if (error || nd < 3) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s is not a valid PGM file!\\n\"), fname);\n#endif\n    fclose (fp);  return;\n  } else if (dim[0] != width || dim[1] != height || dim[2] != 65535) {\n#ifdef DCRAW_VERBOSE\n      fprintf (stderr,_(\"%s has the wrong dimensions!\\n\"), fname);\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.process_warnings |= LIBRAW_WARN_BAD_DARKFRAME_DIM;\n#endif\n    fclose (fp);  return;\n  }\n  pixel = (ushort *) calloc (width, sizeof *pixel);\n  merror (pixel, \"subtract()\");\n  for (row=0; row < height; row++) {\n    fread (pixel, 2, width, fp);\n    for (col=0; col < width; col++)\n      BAYER(row,col) = MAX (BAYER(row,col) - ntohs(pixel[col]), 0);\n  }\n  free (pixel);\n  fclose (fp);\n  memset (cblack, 0, sizeof cblack);\n  black = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME,1,2);\n#endif\n}\n#line 10142 \"dcraw/dcraw.c\"\n#ifndef NO_LCMS\nvoid CLASS apply_profile (const char *input, const char *output)\n{\n  char *prof;\n  cmsHPROFILE hInProfile=0, hOutProfile=0;\n  cmsHTRANSFORM hTransform;\n  FILE *fp;\n  unsigned size;\n\n#ifndef USE_LCMS2\n  cmsErrorAction (LCMS_ERROR_SHOW);\n#endif\n  if (strcmp (input, \"embed\"))\n    hInProfile = cmsOpenProfileFromFile (input, \"r\");\n  else if (profile_length) {\n#ifndef LIBRAW_LIBRARY_BUILD\n    prof = (char *) malloc (profile_length);\n    merror (prof, \"apply_profile()\");\n    fseek (ifp, profile_offset, SEEK_SET);\n    fread (prof, 1, profile_length, ifp);\n    hInProfile = cmsOpenProfileFromMem (prof, profile_length);\n    free (prof);\n#else\n    hInProfile = cmsOpenProfileFromMem (imgdata.color.profile, profile_length);\n#endif\n  } else\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_EMBEDDED_PROFILE;\n#endif\n#ifdef DCRAW_VERBOSE\n          fprintf (stderr,_(\"%s has no embedded profile.\\n\"), ifname);\n#endif\n    }\n  if (!hInProfile)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_INPUT_PROFILE;\n#endif\n          return;\n      }\n  if (!output)\n    hOutProfile = cmsCreate_sRGBProfile();\n  else if ((fp = fopen (output, \"rb\"))) {\n    fread (&size, 4, 1, fp);\n    fseek (fp, 0, SEEK_SET);\n    oprof = (unsigned *) malloc (size = ntohl(size));\n    merror (oprof, \"apply_profile()\");\n    fread (oprof, 1, size, fp);\n    fclose (fp);\n    if (!(hOutProfile = cmsOpenProfileFromMem (oprof, size))) {\n      free (oprof);\n      oprof = 0;\n    }\n  }\n#ifdef DCRAW_VERBOSE\n else\n    fprintf (stderr,_(\"Cannot open file %s!\\n\"), output);\n#endif\n  if (!hOutProfile)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_BAD_OUTPUT_PROFILE;\n#endif\n          goto quit;\n      }\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf (stderr,_(\"Applying color profile...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_APPLY_PROFILE,0,2);\n#endif\n  hTransform = cmsCreateTransform (hInProfile, TYPE_RGBA_16,\n\thOutProfile, TYPE_RGBA_16, INTENT_PERCEPTUAL, 0);\n  cmsDoTransform (hTransform, image, image, width*height);\n  raw_color = 1;\t\t/* Don't use rgb_cam with a profile */\n  cmsDeleteTransform (hTransform);\n  cmsCloseProfile (hOutProfile);\nquit:\n  cmsCloseProfile (hInProfile);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_APPLY_PROFILE,1,2);\n#endif\n}\n#endif\n", "/* -*- C++ -*-\n * File: libraw_version.h\n * Copyright 2008-2013 LibRaw LLC (info@libraw.org)\n * Created: Mon Sept  8, 2008 \n *\n * LibRaw C++ interface\n *\n\nLibRaw is free software; you can redistribute it and/or modify\nit under the terms of the one of three licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n(See the file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n(See the file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n3. LibRaw Software License 27032010\n  (See the file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).\n\n */\n\n#ifndef __VERSION_H\n#define __VERSION_H\n\n#define LIBRAW_MAJOR_VERSION  0\n#define LIBRAW_MINOR_VERSION  15\n#define LIBRAW_PATCH_VERSION  3\n#define LIBRAW_VERSION_TAIL   Release\n\n#define LIBRAW_SHLIB_CURRENT  \t9\n#define LIBRAW_SHLIB_REVISION \t0\n#define LIBRAW_SHLIB_AGE     \t0\n\n#define _LIBRAW_VERSION_MAKE(a,b,c,d) #a\".\"#b\".\"#c\"-\"#d\n#define LIBRAW_VERSION_MAKE(a,b,c,d) _LIBRAW_VERSION_MAKE(a,b,c,d)\n\n#define LIBRAW_VERSION_STR LIBRAW_VERSION_MAKE(LIBRAW_MAJOR_VERSION,LIBRAW_MINOR_VERSION,LIBRAW_PATCH_VERSION,LIBRAW_VERSION_TAIL)\n\n#define LIBRAW_MAKE_VERSION(major,minor,patch) \\\n    (((major) << 16) | ((minor) << 8) | (patch))\n\n#define LIBRAW_VERSION \\\n    LIBRAW_MAKE_VERSION(LIBRAW_MAJOR_VERSION,LIBRAW_MINOR_VERSION,LIBRAW_PATCH_VERSION)\n\n#define LIBRAW_CHECK_VERSION(major,minor,patch) \\\n    ( LibRaw::versionNumber() >= LIBRAW_MAKE_VERSION(major,minor,patch) )\n\n#define LIBRAW_RUNTIME_CHECK_VERSION_EXACT() \\\n    ( (LibRaw::versionNumber() & 0xffff00) == LIBRAW_MAKE_VERSION(LIBRAW_MAJOR_VERSION,LIBRAW_MINOR_VERSION,0) )\n\n#define LIBRAW_RUNTIME_CHECK_VERSION_NOTLESS() \\\n    ( (LibRaw::versionNumber() & 0xffff00) >= LIBRAW_MAKE_VERSION(LIBRAW_MAJOR_VERSION,LIBRAW_MINOR_VERSION,0) )\n\n#define LIBRAW_COMPILE_CHECK_VERSION(major,minor) \\\n    (LIBRAW_MAKE_VERSION(major,minor,0) == (LIBRAW_VERSION & 0xffff00))\n\n#define LIBRAW_COMPILE_CHECK_VERSION_NOTLESS(major,minor) \\\n    (LIBRAW_MAKE_VERSION(major,minor,0) <= (LIBRAW_VERSION & 0xffff00))\n\n\n#endif\n", "/* -*- C++ -*-\n * File: libraw_datastream.cpp\n * Copyright 2008-2013 LibRaw LLC (info@libraw.org)\n *\n * LibRaw C++ interface (implementation)\n\n LibRaw is free software; you can redistribute it and/or modify\n it under the terms of the one of three licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n3. LibRaw Software License 27032010\n   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).\n\n*/\n\n#ifdef WIN32\n#ifdef __MINGW32__\n    #define _WIN32_WINNT 0x0500\n    #include <stdexcept>\n#endif\n#endif\n\n#define LIBRAW_LIBRARY_BUILD\n#include \"libraw/libraw_types.h\"\n#include \"libraw/libraw.h\"\n#include \"libraw/libraw_datastream.h\"\n#include \"internal/libraw_bytebuffer.h\"\n#include <sys/stat.h>\n#ifdef USE_JASPER\n#include <jasper/jasper.h>\t/* Decode RED camera movies */\n#else\n#define NO_JASPER\n#endif\n#ifdef USE_JPEG\n#include <jpeglib.h>\n#else\n#define NO_JPEG\n#endif\n\n\nLibRaw_byte_buffer::LibRaw_byte_buffer(unsigned sz) \n{ \n    buf=0; size=sz; offt=0; do_free=0; \n    if(size)\n        { \n            buf = (unsigned char*)malloc(size); do_free=1;\n        }\n}\n\nvoid LibRaw_byte_buffer::set_buffer(void *bb, unsigned int sz) \n{ \n    buf = (unsigned char*)bb; size = sz; offt=0; do_free=0;\n}\n\nLibRaw_byte_buffer::~LibRaw_byte_buffer() \n{ \n    if(do_free) free(buf);\n}\n\nLibRaw_byte_buffer *LibRaw_abstract_datastream::make_byte_buffer(unsigned int sz)\n{\n    LibRaw_byte_buffer *ret = new LibRaw_byte_buffer(sz);\n    read(ret->get_buffer(),sz,1);\n    return ret;\n}\n\nint LibRaw_abstract_datastream::tempbuffer_open(void  *buf, size_t size)\n{\n    if(substream) return EBUSY;\n    substream = new LibRaw_buffer_datastream(buf,size);\n    return substream?0:EINVAL;\n}\n\n\nvoid\tLibRaw_abstract_datastream::tempbuffer_close()\n{\n    if(substream) delete substream;\n    substream = NULL;\n}\n\n// == LibRaw_file_datastream ==\n\nLibRaw_file_datastream::~LibRaw_file_datastream()\n{\n  if(jas_file) fclose(jas_file);\n}\n\nLibRaw_file_datastream::LibRaw_file_datastream(const char *fname)\n    :filename(fname)\n#ifdef WIN32\n    ,wfilename()\n#endif\n    ,jas_file(NULL),_fsize(0)\n{\n  if (filename.size()>0) \n    {\n#ifndef WIN32\n      struct stat st;\n      if(!stat(filename.c_str(),&st))\n        _fsize = st.st_size;\t\n#else\n      struct _stati64 st;\n      if(!_stati64(filename.c_str(),&st))\n        _fsize = st.st_size;\n#endif\n      \n      std::auto_ptr<std::filebuf> buf(new std::filebuf());\n      buf->open(filename.c_str(), std::ios_base::in | std::ios_base::binary);\n      if (buf->is_open()) {\n        f = buf;\n      }\n    }\n}\n#if defined(WIN32) && !defined(__MINGW32__)\nLibRaw_file_datastream::LibRaw_file_datastream(const wchar_t *fname) : filename(),wfilename(fname),jas_file(NULL),_fsize(0)\n{\n  if (wfilename.size()>0) \n    {\n      struct _stati64 st;\n      if(!_wstati64(wfilename.c_str(),&st))\n        _fsize = st.st_size;\n      std::auto_ptr<std::filebuf> buf(new std::filebuf());\n      buf->open(wfilename.c_str(), std::ios_base::in | std::ios_base::binary);\n      if (buf->is_open()) {\n        f = buf;\n      }\n    }\n}\nconst wchar_t *LibRaw_file_datastream::wfname()\n{\n  return wfilename.size()>0?wfilename.c_str():NULL;\n}\n#endif\n\n int LibRaw_file_datastream::valid()\n{ \n    return f.get() ? 1 : 0; \n}\n\n#define LR_STREAM_CHK() do {if(!f.get()) throw LIBRAW_EXCEPTION_IO_EOF;}while(0)\n\nint LibRaw_file_datastream::read(void * ptr,size_t size, size_t nmemb)\n{\n    if(substream) return substream->read(ptr,size,nmemb);\n    \n/* Visual Studio 2008 marks sgetn as insecure, but VS2010 does not. */\n#if defined(WIN32SECURECALLS) && (_MSC_VER < 1600)\n    LR_STREAM_CHK(); return int(f->_Sgetn_s(static_cast<char*>(ptr), nmemb * size,nmemb * size) / size); \n#else\n    LR_STREAM_CHK(); return int(f->sgetn(static_cast<char*>(ptr), std::streamsize(nmemb * size)) / size); \n#endif\n}\n\nint LibRaw_file_datastream::eof() \n{ \n    if(substream) return substream->eof();\n    LR_STREAM_CHK(); return f->sgetc() == EOF; \n}\n\nint LibRaw_file_datastream::seek(INT64 o, int whence) \n{ \n    if(substream) return substream->seek(o,whence);\n    LR_STREAM_CHK(); \n    std::ios_base::seekdir dir;\n    switch (whence) \n        {\n        case SEEK_SET: dir = std::ios_base::beg; break;\n        case SEEK_CUR: dir = std::ios_base::cur; break;\n        case SEEK_END: dir = std::ios_base::end; break;\n        default: dir = std::ios_base::beg;\n        }\n    return (int)f->pubseekoff((long)o, dir)<0?-1:0;\n}\n\nINT64 LibRaw_file_datastream::tell()     \n{ \n    if(substream) return substream->tell();\n    LR_STREAM_CHK(); return f->pubseekoff(0, std::ios_base::cur);  \n}\n\nchar* LibRaw_file_datastream::gets(char *str, int sz) \n{ \n    if(substream) return substream->gets(str,sz);\n    LR_STREAM_CHK(); \n    std::istream is(f.get());\n    is.getline(str, sz);\n    if (is.fail()) return 0;\n    return str;\n}\n\nint LibRaw_file_datastream::scanf_one(const char *fmt, void*val) \n{ \n    if(substream) return substream->scanf_one(fmt,val);\n    LR_STREAM_CHK(); \n    \n    std::istream is(f.get());\n    \n    /* HUGE ASSUMPTION: *fmt is either \"%d\" or \"%f\" */\n    if (strcmp(fmt, \"%d\") == 0) {\n        int d;\n        is >> d;\n        if (is.fail()) return EOF;\n        *(static_cast<int*>(val)) = d;\n    } else {\n        float f;\n        is >> f;\n        if (is.fail()) return EOF;\n        *(static_cast<float*>(val)) = f;\n    }\n    \n    return 1;\n}\n\nconst char* LibRaw_file_datastream::fname() \n{ \n  return filename.size()>0?filename.c_str():NULL; \n}\n    \n/* You can't have a \"subfile\" and a \"tempfile\" at the same time. */\nint LibRaw_file_datastream::subfile_open(const char *fn)\n{\n    LR_STREAM_CHK();\n    if (saved_f.get()) return EBUSY;\n    saved_f = f;\n        std::auto_ptr<std::filebuf> buf(new std::filebuf());\n        \n        buf->open(fn, std::ios_base::in | std::ios_base::binary);\n        if (!buf->is_open()) {\n            f = saved_f;\n            return ENOENT;\n        } else {\n            f = buf;\n        }\n        \n        return 0;\n}\n\n#if defined(WIN32) && !defined(__MINGW32__)\nint LibRaw_file_datastream::subfile_open(const wchar_t *fn)\n{\n\tLR_STREAM_CHK();\n\tif (saved_f.get()) return EBUSY;\n\tsaved_f = f;\n\tstd::auto_ptr<std::filebuf> buf(new std::filebuf());\n\n\tbuf->open(fn, std::ios_base::in | std::ios_base::binary);\n\tif (!buf->is_open()) {\n\t\tf = saved_f;\n\t\treturn ENOENT;\n\t} else {\n\t\tf = buf;\n\t}\n\n\treturn 0;\n}\n#endif\n\n\nvoid LibRaw_file_datastream::subfile_close()\n{ \n    if (!saved_f.get()) return; \n    f = saved_f;   \n}\n\n#undef LR_STREAM_CHK\n\nvoid * LibRaw_file_datastream::make_jas_stream()\n{\n#ifdef NO_JASPER\n    return NULL;\n#else\n#if defined(WIN32) && !defined(__MINGW32__)\n\tif(wfname())\n\t{\n\t\tjas_file = _wfopen(wfname(),L\"rb\");\n\t\treturn jas_stream_fdopen(fileno(jas_file),\"rb\");\n\t}\n\telse\n#endif\n\t{\n\t\treturn jas_stream_fopen(fname(),\"rb\");\n\t}\n#endif\n}\n\nint LibRaw_file_datastream::jpeg_src(void *jpegdata)\n{\n#ifdef NO_JPEG\n  return -1; // not supported\n#else\n  if(jas_file) { fclose(jas_file); jas_file = NULL;}\n#if defined(WIN32) && !defined(__MINGW32__)\n  if(wfname())\n    {\n      jas_file = _wfopen(wfname(),L\"rb\");\n    }\n  else\n#endif\n    {\n      jas_file = fopen(fname(),\"rb\");\n    }\n  if(jas_file)\n    {\n      fseek(jas_file,tell(),SEEK_SET);\n      j_decompress_ptr cinfo = (j_decompress_ptr) jpegdata;\n      jpeg_stdio_src(cinfo,jas_file);\n      return 0; // OK\n    }\n  return -1;\n#endif\n}\n\n\n// == LibRaw_buffer_datastream\nLibRaw_buffer_datastream::LibRaw_buffer_datastream(void *buffer, size_t bsize)\n{    \n    buf = (unsigned char*)buffer; streampos = 0; streamsize = bsize;\n}\n\nLibRaw_buffer_datastream::~LibRaw_buffer_datastream(){}\n\nint LibRaw_buffer_datastream::read(void * ptr,size_t sz, size_t nmemb)\n{ \n    if(substream) return substream->read(ptr,sz,nmemb);\n    size_t to_read = sz*nmemb;\n    if(to_read > streamsize - streampos)\n        to_read = streamsize-streampos;\n    if(to_read<1) \n        return 0;\n    memmove(ptr,buf+streampos,to_read);\n    streampos+=to_read;\n    return int((to_read+sz-1)/sz);\n}\n\nint LibRaw_buffer_datastream::seek(INT64 o, int whence)\n{ \n    if(substream) return substream->seek(o,whence);\n    switch(whence)\n        {\n        case SEEK_SET:\n            if(o<0)\n                streampos = 0;\n            else if (size_t(o) > streamsize)\n                streampos = streamsize;\n            else\n                streampos = size_t(o);\n            return 0;\n        case SEEK_CUR:\n            if(o<0)\n                {\n                    if(size_t(-o) >= streampos)\n                        streampos = 0;\n                    else\n                        streampos += (size_t)o;\n                }\n            else if (o>0)\n                {\n                    if(o+streampos> streamsize)\n                        streampos = streamsize;\n                    else\n                        streampos += (size_t)o;\n                }\n            return 0;\n        case SEEK_END:\n            if(o>0)\n                streampos = streamsize;\n            else if ( size_t(-o) > streamsize)\n                streampos = 0;\n            else\n                streampos = streamsize+(size_t)o;\n            return 0;\n        default:\n            return 0;\n        }\n}\n\nINT64 LibRaw_buffer_datastream::tell()\n{ \n    if(substream) return substream->tell();\n    return INT64(streampos);\n}\n\nchar* LibRaw_buffer_datastream::gets(char *s, int sz)\n{ \n    if (substream) return substream->gets(s,sz);\n    unsigned char *psrc,*pdest,*str;\n    str = (unsigned char *)s;\n    psrc = buf+streampos;\n    pdest = str;\n    while ( (size_t(psrc - buf) < streamsize)\n            &&\n            ((pdest-str)<sz)\n        )\n        {\n            *pdest = *psrc;\n            if(*psrc == '\\n')\n                break;\n            psrc++;\n            pdest++;\n        }\n    if(size_t(psrc-buf) < streamsize)\n        psrc++;\n    if((pdest-str)<sz)\n        *(++pdest)=0;\n    streampos = psrc - buf;\n    return s;\n}\n\nint LibRaw_buffer_datastream::scanf_one(const char *fmt, void* val)\n{ \n    if(substream) return substream->scanf_one(fmt,val);\n    int scanf_res;\n    if(streampos>streamsize) return 0;\n#ifndef WIN32SECURECALLS\n    scanf_res = sscanf((char*)(buf+streampos),fmt,val);\n#else\n    scanf_res = sscanf_s((char*)(buf+streampos),fmt,val);\n#endif\n    if(scanf_res>0)\n        {\n            int xcnt=0;\n            while(streampos<streamsize)\n                {\n                    streampos++;\n                    xcnt++;\n                    if(buf[streampos] == 0\n                       || buf[streampos]==' '\n                       || buf[streampos]=='\\t'\n                       || buf[streampos]=='\\n'\n                       || xcnt>24)\n                        break;\n                }\n        }\n    return scanf_res;\n}\n\nLibRaw_byte_buffer *LibRaw_buffer_datastream::make_byte_buffer(unsigned int sz)\n{\n    LibRaw_byte_buffer *ret = new LibRaw_byte_buffer(0);\n    if(streampos + sz > streamsize)\n        sz = streamsize - streampos;\n    ret->set_buffer(buf+streampos,sz);\n    return ret;\n}\n\nint LibRaw_buffer_datastream::eof()\n{ \n    if(substream) return substream->eof();\n    return streampos >= streamsize;\n}\n int LibRaw_buffer_datastream::valid() \n{ \n    return buf?1:0;\n}\n\n\nvoid * LibRaw_buffer_datastream::make_jas_stream()\n{\n#ifdef NO_JASPER\n    return NULL;\n#else\n    return jas_stream_memopen((char*)buf+streampos,streamsize-streampos);\n#endif\n}\n\nint LibRaw_buffer_datastream::jpeg_src(void *jpegdata)\n{\n#if defined(NO_JPEG) || !defined (USE_JPEG8)\n  return -1;\n#else\n  j_decompress_ptr cinfo = (j_decompress_ptr) jpegdata;\n  jpeg_mem_src(cinfo,(unsigned char*)buf+streampos,streamsize-streampos);\n  return 0;\n#endif\n}\n\n\n//int LibRaw_buffer_datastream\n\n\n// == LibRaw_bigfile_datastream\nLibRaw_bigfile_datastream::LibRaw_bigfile_datastream(const char *fname): filename(fname)\n#ifdef WIN32\n\t,wfilename()\n#endif\n{ \n  if(filename.size()>0)\n    {\n#ifndef WIN32\n      struct stat st;\n      if(!stat(filename.c_str(),&st))\n        _fsize = st.st_size;\t\n#else\n      struct _stati64 st;\n      if(!_stati64(filename.c_str(),&st))\n        _fsize = st.st_size;\n#endif\n\n#ifndef WIN32SECURECALLS\n      f = fopen(fname,\"rb\");\n#else\n      if(fopen_s(&f,fname,\"rb\"))\n        f = 0;\n#endif\n    }\n    else \n      {filename=std::string();f=0;}\n    sav=0;\n}\n\n#if defined(WIN32) && !defined(__MINGW32__)\nLibRaw_bigfile_datastream::LibRaw_bigfile_datastream(const wchar_t *fname) : filename(),wfilename(fname)\n{ \n  if(wfilename.size()>0)\n    {\n      struct _stati64 st;\n      if(!_wstati64(wfilename.c_str(),&st))\n        _fsize = st.st_size;\n#ifndef WIN32SECURECALLS\n      f = _wfopen(wfilename.c_str(),L\"rb\");\n#else\n      if(_wfopen_s(&f,fname,L\"rb\"))\n        f = 0;\n#endif\n    }\n  else \n    {\n      wfilename=std::wstring();\n      f=0;\n    }\n  sav=0;\n}\nconst wchar_t *LibRaw_bigfile_datastream::wfname()\n{\n  return wfilename.size()>0?wfilename.c_str():NULL;\n}\n#endif\n\nLibRaw_bigfile_datastream::~LibRaw_bigfile_datastream() {if(f)fclose(f); if(sav)fclose(sav);}\nint         LibRaw_bigfile_datastream::valid() { return f?1:0;}\n\n#define LR_BF_CHK() do {if(!f) throw LIBRAW_EXCEPTION_IO_EOF;}while(0)\n\nint LibRaw_bigfile_datastream::read(void * ptr,size_t size, size_t nmemb) \n{ \n    LR_BF_CHK(); \n    return substream?substream->read(ptr,size,nmemb):int(fread(ptr,size,nmemb,f));\n}\n\nint LibRaw_bigfile_datastream::eof()\n{ \n    LR_BF_CHK(); \n    return substream?substream->eof():feof(f);\n}\n\nint     LibRaw_bigfile_datastream:: seek(INT64 o, int whence)\n{ \n    LR_BF_CHK(); \n#if defined (WIN32) \n#ifdef WIN32SECURECALLS\n    return substream?substream->seek(o,whence):_fseeki64(f,o,whence);\n#else\n    return substream?substream->seek(o,whence):fseek(f,(long)o,whence);\n#endif\n#else\n    return substream?substream->seek(o,whence):fseeko(f,o,whence);\n#endif\n}\n\nINT64 LibRaw_bigfile_datastream::tell()\n{ \n    LR_BF_CHK(); \n#if defined (WIN32)\n#ifdef WIN32SECURECALLS\n    return substream?substream->tell():_ftelli64(f);\n#else\n    return substream?substream->tell():ftell(f);\n#endif\n#else\n    return substream?substream->tell():ftello(f);\n#endif\n}\n\nchar* LibRaw_bigfile_datastream::gets(char *str, int sz)\n{ \n    LR_BF_CHK(); \n    return substream?substream->gets(str,sz):fgets(str,sz,f);\n}\n\nint LibRaw_bigfile_datastream::scanf_one(const char *fmt, void*val)\n{ \n    LR_BF_CHK(); \n    return substream?substream->scanf_one(fmt,val):\n#ifndef WIN32SECURECALLS\t\t\t\n        fscanf(f,fmt,val)\n#else\n        fscanf_s(f,fmt,val)\n#endif\n        ;\n}\n\nconst char *LibRaw_bigfile_datastream::fname() \n{ \n  return filename.size()>0?filename.c_str():NULL; \n}\n\nint LibRaw_bigfile_datastream::subfile_open(const char *fn)\n{\n    if(sav) return EBUSY;\n    sav = f;\n#ifndef WIN32SECURECALLS\n    f = fopen(fn,\"rb\");\n#else\n    fopen_s(&f,fn,\"rb\");\n#endif\n    if(!f)\n        {\n            f = sav;\n            sav = NULL;\n            return ENOENT;\n        }\n    else\n        return 0;\n}\n#if defined(WIN32) && !defined(__MINGW32__)\nint LibRaw_bigfile_datastream::subfile_open(const wchar_t *fn)\n{\n\tif(sav) return EBUSY;\n\tsav = f;\n#ifndef WIN32SECURECALLS\n\tf = _wfopen(fn,L\"rb\");\n#else\n\t_wfopen_s(&f,fn,L\"rb\");\n#endif\n\tif(!f)\n\t{\n\t\tf = sav;\n\t\tsav = NULL;\n\t\treturn ENOENT;\n\t}\n\telse\n\t\treturn 0;\n}\n#endif\n\n\nvoid LibRaw_bigfile_datastream::subfile_close()\n{\n    if(!sav) return;\n    fclose(f);\n    f = sav;\n    sav = 0;\n}\n\n\nvoid *LibRaw_bigfile_datastream::make_jas_stream()\n{\n#ifdef NO_JASPER\n    return NULL;\n#else\n    return jas_stream_fdopen(fileno(f),\"rb\");\n#endif\n}\n\nint LibRaw_bigfile_datastream::jpeg_src(void *jpegdata)\n{\n#ifdef NO_JPEG\n  return -1;\n#else\n  if(!f) return -1;\n  j_decompress_ptr cinfo = (j_decompress_ptr) jpegdata;\n  jpeg_stdio_src(cinfo,f);\n  return 0; // OK\n#endif\n}\n\n\n// == LibRaw_windows_datastream\n#ifdef WIN32\n\nLibRaw_windows_datastream::LibRaw_windows_datastream(const TCHAR* sFile)\n    : LibRaw_buffer_datastream(NULL, 0)\n    , hMap_(0)\n    , pView_(NULL)\n{\n    HANDLE hFile = CreateFile(sFile, GENERIC_READ, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);\n    if (hFile == INVALID_HANDLE_VALUE) \n        throw std::runtime_error(\"failed to open the file\"); \n    \n    try { Open(hFile); \t}\tcatch(...) { CloseHandle(hFile); throw; }\n    \n    CloseHandle(hFile);\t\t// windows will defer the actual closing of this handle until the hMap_ is closed\n    reconstruct_base();\n}\n\n\t// ctor: construct with a file handle - caller is responsible for closing the file handle\nLibRaw_windows_datastream::LibRaw_windows_datastream(HANDLE hFile)\n    : LibRaw_buffer_datastream(NULL, 0)\n    , hMap_(0)\n    , pView_(NULL)\n{\n    Open(hFile);\n    reconstruct_base();\n}\n\n// dtor: unmap and close the mapping handle\nLibRaw_windows_datastream::~LibRaw_windows_datastream()\n{\n    if (pView_ != NULL)\n        ::UnmapViewOfFile(pView_);\n    \n    if (hMap_ != 0)\n        ::CloseHandle(hMap_);\n}\n\nvoid LibRaw_windows_datastream::Open(HANDLE hFile)\n{\n    // create a file mapping handle on the file handle\n    hMap_ = ::CreateFileMapping(hFile, 0, PAGE_READONLY, 0, 0, 0);\n    if (hMap_ == NULL)\tthrow std::runtime_error(\"failed to create file mapping\"); \n    \n    // now map the whole file base view\n    if (!::GetFileSizeEx(hFile, (PLARGE_INTEGER)&cbView_))\n        throw std::runtime_error(\"failed to get the file size\"); \n    \n    pView_ = ::MapViewOfFile(hMap_, FILE_MAP_READ, 0, 0, (size_t)cbView_);\n    if (pView_ == NULL)\t\n        throw std::runtime_error(\"failed to map the file\"); \n}\n\n\n#endif\n\n\n    \n"], "fixing_code": ["2013-08-28 Alex Tutubalin <lexa@lexa.ru>\n  * Additional checks to data to prevent broken file opening\n  * New camera/format support:\n     Richon GR\n     Panasonic LF1\n     Canon EOS 70D\n     Sony RX100II, RX1R\n     Olympus E-P5\n  * Generalized size copy from RawSpeed data\n  * LibRaw 0.15.4\n\n2013-07-04 Alex Tutubalin <lexa@lexa.ru>\n  * New camera/format support:\n     OmniVision OV5647 (Raspberry Pi)\n     Nikon D5200\n     Panasonic DMC-GF6\n  * Fixed decoding error for some Canon sRAW files.\n  * LibRaw 0.15.3\n\n2013-05-26 Alex Tutubalin <lexa@lexa.ru>\n  * Fixed possible double-free() on error recovery on damaged full-color\n    (Foveon, sRAW) files.\n  * wchar_t* file interface disabled for MinGW32 compilation\n  * LibRaw 0.15.2\n\n2013-05-25 Alex Tutubalin <lexa@lexa.ru>\n  * fixed wrong data maximum calculation for Panasonic files\n  * check for possible buffer overrun in exposure correction code\n  * LibRaw 0.15.1\n      \n2013-05-23 Alex Tutubalin <lexa@lexa.ru>\n\n LibRaw 0.15-Release\n \n New camera/format support:\n  * Adobe DNG:\tfast Load DNG (LightRoom 4.x), support for \n\t\tlossy-compressed DNG (LR 4.x, requires libjpeg 6+)\n  * Canon:\tG1 X, SX220 HS, EOS 5D Mark III, EOS 650D, EOS 1D-X, \n\t\t100D (Rebel SL1), 700D (Rebel T5i), 6D, EOS M, G15, S110, SX50\n  * Casio:\tEX-ZR100,EX-Z8\n  * Fujifilm:\tX-S1, HS30EXR, X1-Pro,X-E1, X20, X100S, SL1000, HS50EXR,\n  \t\tF800EXR, XF1\n  * Leica:\tD-LUX6 and V-LUX4\n  * Nikon:\tD4, D3200, D800, D800E, 1 J2, 1 V2, D600, 1 J3, 1 S1, Coolpix A,\n\t\tCoolpix P330, Coolpix P7700, D7100\n  * Olympus:\tE-M5, XZ-2, XZ-10, E-PL5, E-PM2\n  * Panasonic:\tG5, G6, DMC-GF5, FZ200, GH3, LX7\n  * Pentax:\tMX-1, K-5 II, K-5 IIs, K-30, Q10\n  * Samsung:\tEX2F, NX20, NX210, support for the new firmware for NX100\n  * Sigma:\tSD15, SD1, SD1 Merill, DP1, DP1S, DP1X, DP2, DP2S, DP2X \n\t\t(only with Demosaic-pack-GPL2)\n  * Sony:\tSLT-A58, RX-1, SLT-A99, NEX-5R, NEX-6, NEX-F3, SLT-A37, SLT-A57\n  * Multishot files:\tImacon Ixpress 39Mpix\n\nAPI changes:\n  1. dcraw_process() can now be called several times with different parameters \n     without re-opening and unpacking the file for second and consecutive \n     calls to dcraw_process\n\n  2. deleted (nobody uses those)\n   - LibRaw::dcraw_document_mode_processing  (and respective C-API)\n   - imgdata.color.color_flags data field\n\n  3. LibRaw::unpack() now decodes data into different buffers, the buffer\n     depends on the raw data type\n     - imgdata.rawdata.raw_image - 1 color component per pixel, \n       for b/w and Bayer type sensors\n     - imgdata.rawdata.color3_image - 3 color components per pixel, \n       sRAW/mRAW files, RawSpeed decoding\n     - imgdata.rawdata.color4_image - 4 components per pixel, the 4th \n       component can be void\n\n   4. Support for compiling with RawSpeed library, http://rawstudio.org/blog/?p=800\n      details are in README.RawSpeed\n\n   5. Suppression of banding\n\n   6. New API calls\n     - recycle_datastream(), \n     - open_file(wchar_t*) (Win32)\n\n\n2012-04-05 Alex Tutubalin <lexa@lexa.ru>\n        * Casio EX-Z500 support\n        * (possible) I/O exceptions on file open catched in open_datastream\n        * Fixed possible read-after-buffer in Sony ARW2 decoder\n        * Fixed mingw32 errors when compiling LibRaw_windows_datastream\n        * Makefile.msvc: support of OpenMP and LCMS (uncomment to use)\n        * Fixed decoding of some Leaf Aptus II files\n        * LibRaw 0.14.6-Release\n\n2011-12-24 Alex Tutubalin <lexa@lexa.ru>\n        * Fixed bug (uninitialized variable) in SMAL format decoding.\n\n        * Imported new dcraw 9.12 (1.446): support for Leica V-LUX 3, \n          updated color data for Canon S100, Fujifilm X10, Nikon 1 J1/V1,\n          Panasonic GX1, Samsung NX200, Sony NEX-7\n\n        * LibRaw 0.14.5-Release\n\n2011-12-12 Alex Tutubalin <lexa@lexa.ru>\n\n        * Fixes to Panasonic/Leica file parser to prevent crash\n          on broken jpegs.\n\n        * Fixes to include order in src/libraw_datastream.cpp to\n          better compile with KDEWIN\n\n        * Floating-point DNGs are rejected on early processing stage.\n\n        * Support for new cameras: Canon S100, Fuji X10, Panasonic GX1, \n          Samsung NX200, Sony NEX-7.\n\n        * LibRaw 0.14.4-Release\n          \n\n2011-10-26 Alex Tutubalin <lexa@lexa.ru>\n        * Bug fixes in black level subtraction code for PhaseOne files\n\n        * New API call LibRaw::get_internal_data_pointer() for developers\n           who need access to libraw_internal_data fields (i.e. \n           Fuji SuperCCD layout).\n\n        *  doc/API-overview fixes to reflect 0.14 changes\n\n        * LibRaw 0.14.3-Release\n\n2011-10-19 Alex Tutubalin <lexa@lexa.ru>\n        * Fixed bug in Canon 1D and 1Ds files decoding.\n        * New decoder information bit DECODER_HASRAWCURVE \n        * LibRaw 0.14.2-Release\n\n2011-10-11 Alex Tutubalin <lexa@lexa.ru>\n        * Imported dcraw 9.11/1.445:\n          + Support for new cameras added: Fujifilm F600EXR, Nikon P7100,\n            Olympus E-PL3 and E-PM1, Panasonic DMC-FZ150, Sony NEX-5N, \n            A65 and A77.\n          + Changed color data for: Olympus E-P3, Panasonic G3 and GF3,\n            PhaseOne H25, P40 and P65, Sony NEX-C3, NEX-5, NEX-3, A35 and A55.\n          + Support for dark frame extraction on Sony cameras.\n\n        * DCB demosaicing: reserving 6 pixels instead of 3 to suppress \n          colored image frame.\n        * LibRaw 0.14.1-Release\n\n2011-09-21 Alex Tutubalin <lexa@lexa.ru>\n        * Cosmetic changes to make Visual C++/OpenMP more happy\n        * Fix megapixel calculation for postprocessing_benchmark in half mode\n        * Shlib version number increment\n        * LibRaw 0.14.0-Release\n\n2011-09-04 Alex Tutubalin <lexa@lexa.ru>\n        * Fixed bug with Kodak thumbnail extraction\n        * raw2image_ex() always return value\n        * LibRaw 0.14.0-Beta2\n\n2011-09-02 Alex Tutubalin <lexa@lexa.ru>\n        * Cosmetic changes to LibRaw_file_datastream interface\n\n        * OpenMP speedup of postprocessing steps (up to 50% for\n          half mode and 4-core machine)\n\n        * LibRaw 0.14.0-Beta1\n\n2011-08-20 Alex Tutubalin <lexa@lexa.ru>\n\n        * Patch to dcraw_emu for SunStudio compiler compatibility\n\n        * Fixed crash in unprocessed_raw sample due to uninitialized\n          timestamp variable.\n\n        * Fixed crash in raw decoding if raw_width/raw_height is\n          less than resulting image width/height.\n\n        * imgdata.sizes.flip is set from user_flip only on\n          postprocessing and/or adjust_sizes_info_only()\n\n        * Fixed buffer overrun for some LJPEG-compressed files\n\n        * Most of LibRaw_datastream function bodies are moved to\n          separate source file\n\n        * LibRaw_windows_datastream is merged to main sourcetree\n\n        * LibRaw 0.14.0-Alpha5\n\n2011-08-11 Alex Tutubalin <lexa@lexa.ru>\n        * Imported dcraw 9.10 (1.444), support for new cameras added:\n          ARRIRAW format, Canon SX30 IS, Leica D-LUX 5 and V-LUX2,\n          Olympus E-P3, Panasonic G3 and GF3, Sony NEX-C3 and SLT-A35\n          \n        * Support for RedOne digital movie cameras (R3D format). \n          To enable this support you should:\n           + install libjasper JPEG2000 support library\n\n           + compile LibRaw with -DUSE_JASPER compiler switch (./configure\n             will do it for you)\n\n           + If you use own LibRaw_datastream implementation, you should\n             implement make_jas_stream() call for your datastream. See\n             bottom of src/libraw_cxx.cpp for  implementations in datafile\n             and mem-buffer LibRaw streams.\n\n        * Bugfix: green matching is turned off if output image is shrinked\n          due to wavelet filtering or aberration correction.\n\n        * fixed open_file()/adjust_sizes_info_only() code path\n\n        * Removed imgdata.sizes.bottom_margin and right_margin data fields\n          use imgdata.sizes.raw_width - width - left_margin to get right one,\n          the same with bottom_margin.\n\n        * minor ./configure cleanup\n        \n        * Qmake files and Visual Studio Project files are updated.\n\n        * New version check macros:\n          For use at runtime checks:\n           LIBRAW_RUNTIME_CHECK_VERSION_EXACT() - checks  that runtime \n            major/minor version numbers are same with compile-time values.\n\n           LIBRAW_RUNTIME_CHECK_VERSION_NOTLESS() - checks that runtime\n            version is not less that compile-time one.\n\n          For use at compile-time in preprocessor directives:\n           LIBRAW_COMPILE_CHECK_VERSION_EXACT(major,minor) - Compile-time\n            check that LibRaw version is exact major.minor.\n\n           LIBRAW_COMPILE_CHECK_VERSION_NOTLESS(major,minor) - Compile-time\n            check that version is not less than major.minor.\n\n        * all client code should be recompiled due to internals change.\n\n        * LibRaw 0.14.0-Alpha4\n\n2011-07-19 Alex Tutubalin <lexa@lexa.ru>\n        * New sample samples/postprocessing_benchmark.cpp\n          This sample measures postprocessing speed.\n          All demosaic methods, averaged white balance, median\n          filtering, wavelet filtration, highlight recovery, and\n          cropping are supported.\n\n        * Removed LibRaw::rotate_fuji_raw() call and corresponding C-API call.\n\n        * The LibRaw::adjust_sizes_info_only() call may be called repeated\n          and mixed with dcraw_process() call.\n\n        * Postprocessing speedup and optimization, especially if cropping set.\n\n        * Cropping works for FujiCCD raws. For the technical reasons, the position\n          of top-left corner of crop area will be rounded to the nearest\n          multiple of 4 (the corner is shifted top-left).\n\n        * LibRaw 0.14.0-Alpha3\n\n2011-07-15 Alex Tutubalin <lexa@lexa.ru>\n        * imported cropping code from 0.13 branch\n\n2011-07-12 Alex Tutubalin <lexa@lexa.ru>\n        * samples/multirender_test - check for different clip settings\n\n2011-07-11 Alex Tutubalin <lexa@lexa.ru>\n        * New call LibRaw::free_image(), deallocates imgdata.image buffer.\n          Use this call if current postprocessing results are not\n          needed, but it is to early to call recycle() because\n          dcraw_process() may be called later.\n\n        * New C-API calls\n          libraw_raw2image() - C API for LibRaw::raw2image()\n          libraw_free_image() - C API for LibRaw::free_image()\n          libraw_get_decoder_info() - C API for LibRaw::get_decoder_info()\n\n        * Bugfix: change of params.user_flip aftee open()/unpack()\n          calls should work.\n\n        * LibRaw 0.14.0-Alpha2\n\n2011-07-10 Alex Tutubalin <lexa@lexa.ru>\n        * Multiple rendering (LibRaw::dcraw_process() calls) allowed\n          without re-opening RAW file thrfough the sequence of open()/unpack()\n          calls.\n          You should be able to change any processing parameters (except\n          shot_select parameter) between dcraw_process() calls.\n\n          + New sample in samples/multirender_test.cpp: renders data 4 times:\n            in half and full modes with different white balance settings.\n\n          + Unprocessed RAW data is stored in separate data buffer:\n            (2 bytes per pixel for all Bayer-pattern images,\n            8 bytes per pixel for Foveon, sRAW, and other full-color raw \n            formats), so now LibRaw uses 25% more memory for full processing of \n            most common Bayer images; while for just unpack memory is reduced \n            4 times.\n\n          + New call LibRaw::raw2image() fills imgdata.image array\n            with fresh copy of data.\n            There is no need to call raw2image() separately if you use \n            dcraw_process() or dcraw_document_mode_processing() calls.\n\n          + New call LibRaw::get_decoder_info() to determine raw data\n            storage layout. See samples/unprocessed_raw.cpp for an example \n            of how to use it.\n\n        If your code uses usual open()/unpack()/dcraw_process() call\n        sequence, then NOTHING CHANGED: your program should produce same\n        results. For interactive programs you may skip open()/unpack()\n        calls after adjusting processing parameters, so user should see\n        image refreshed much faster.\n\n        If your code uses raw data (open+unpack calls), you need to call\n        LibRaw::raw2image(), and imgdata.image will contain same bitmap\n        as in LibRaw 0.13.x\n\n        If you code uses access to masked borders data, you need to\n        rewrite it. See samples/unprocessed_raw.cpp as a sample.\n\n        Unfortunately, documentation is untouched yet. This problem will be\n        fixed in next Alpha release.\n\n        Other changes:\n\n        * No separate imgdata.masked_pixels buffers, Bayer raw formats are read\n          to buffer with borders. So, no ugly add_masked_border_to_bitmap()\n          call.\n\n        * No filtering_mode parameter. Raw tone curve is applied \n          at unpack() stage; zero pixels removed on postprocesing stage.\n\n        * unprocessed_raw and 4colors samples are adjusted to use\n          new RAW data storage layout.\n\n        * all client code should be recompiled due to internals change.\n\n        * LibRaw 0.14.0-Alpha1\n\n2011-07-03 Alex Tutubalin <lexa@lexa.ru>\n        * Cosmetic cleanup in Libraw_memmgr code\n\n        * Permit OpenMP support on MS VS2008\n\n        * More general mem_image interface:\n          + New call get_mem_image_format returns bitmap size and bit depth\n          + New call copy_mem_image can copy bitmap into buffer with \n            different color order (RGB/BGR) and line stride\n          + dcraw_make_mem_image() uses calls mentioned above\n          + see documentation for info on these function parameters.\n\n        * libraw/librawwindows.h implements LibRaw_datastream class based\n          on Windows memory mapped files.Win32/64-only \n          Thanks to Linc Brookes.\n\n        * Fixed parallel make errors in configure/Makefile.am\n\n        * LibRaw 0.13.6-Release\n\n        \n2011-05-18 Alex Tutubalin <lexa@lexa.ru>\n        * Imported new dcraw 9.08/1.443:\n           + New color data for Canon 600D and 1100D, Fuji S200EXR\n           + New camera supported: Fuji HS20EXR and F550EXR, Kodak Z990, \n                                   Nikon D5100, Olympus E-PL1s and XZ-1, \n                                   Samsung NX11, Sony A230 and 290.\n        * LibRaw 0.13.5-Release\n\n2011-04-02 Alex Tutubalin <lexa@lexa.ru>\n        * Imported new dcraw 9.07/1.442:\n          + Support for Canon 600D and 1100D, Hasselblad H4D-60,\n            Olympus E-PL2\n        * Color data for Leaf Aptus II and Canon Powershot S2 IS\n        * LibRaw 0.13.4-Release\n\n2011-03-30 Alex Tutubalin <lexa@lexa.ru>\n        * Preliminary support for Leaf Aptus II cameras (no color data yet):\n          Leaf Aptus II 6,7,8,10 and 12 are tested, Aptus II 5 should work.\n        * Preliminary support for Fujifilm X100 camera (again, no color data).\n        * Fixed possible after the end of buffer read when working with\n          in-memory data.\n        * Fixed possible loss of JPEG stream sync marks in LJPEG decoder\n          (this bug was found only for Leaf Aptus II RAWs).\n        * LibRaw 0.13.3-Release\n\n2011-03-08 Alex Tutubalin <lexa@lexa.ru>\n        * Fixed broken camera white balance reading for some Sony cameras\n        * LibRaw 0.13.2-Release\n\n2011-02-25 Alex Tutubalin <lexa@lexa.ru>\n\t* Sony A390 support (colordata from A380)\n\t* Leica D-LUX 4: fixed typo in camera name in colordata\n\n2011-02-15 Alex Tutubalin <lexa@lexa.ru>\n\t* New -mem option for dcraw_emu: I/O via allocated buffer\n\t* Removed debug printf from LibRaw_memory_buffer code\n\t* Preliminary shared library support\n\n2011-02-12 Alex Tutubalin <lexa@lexa.ru>\n\t* Added qmake .pro and Visual Studio 2008 sln/vcproj project files\n2011-02-07 Alex Tutubalin <lexa@lexa.ru>\n        * dcraw_emu documentation updated\n        * ./configure stuff changed for correct linking on some systems        \n        * FBDD denoising is disabled for full-color images and 4-color bayer\n          data (including forced 4-color via four_color_rgb option)\n        * LibRaw 0.13.1-Release\n\n2011-02-05 Alex Tutubalin <lexa@lexa.ru>\n        * ./configure fixes for PACKAGE_REQUIRES\n        * Makefile.msvc: correct compiler flags for demosaic packs\n        * dcraw.c 9.06/1.440 imported:\n          + New camera support: Canon S95, Casio EX-Z1080, Panasonic GF2 \n            and GH2, Samsung NX100, Sony A-580\n          + New color data for: Canon G12, Nikon D3100, D7000 and P7000,\n            Olympus E-5, Pentax K-r and K-5, Samsung NX10 and WB2000 \n        * green_matching() code is disabled for half-size processing\n        * LibRaw 0.13.0-Release\n\n2011-01-15 Alex Tutubalin <lexa@lexa.ru>\n        * Fallback to old huffman decoder for Sony files with unspecified\n          data length (Sony A100)\n        * Fixed incomplete data fields reset in LibRaw::recycle()\n        * LibRaw 0.13.0-Beta3\n   \n2011-01-13 Alex Tutubalin <lexa@lexa.ru>\n        * Better parsing of unknown command-line params in dcraw_emu sample\n        * Brigtness table in ahd_demosaic is calculated in reversed order\n          to prevent possible (very unlikely) multithreaded app problem.\n        * New exposure correction code based on linear-cubic root combination.\n          New working correction range is from 0.25 (-2 stops) to 8 (+3 stops)\n        * LibRaw 0.13.0-Beta2\n\n2011-01-10 Alex Tutubalin <lexa@lexa.ru>\n\t* Fixed file extension in half_mt.c sample\n\n2011-01-10 Alex Tutubalin <lexa@lexa.ru>\n\t* Three patches provided by Jacques Desmis:\n          - Exposure correction before demosaic (demosaic pack GPL3)\n\t  - OpenMP speed-up in median filters (demosaic pack GPL2)\n\t  - OpenMP speed-up in green equilibration (demosaic pack GPL3)\n\t* Merged 0.12.2-0.12.3 changes:\n          - Patches for ./configure system for better LCMS2 support\n\t  - Patches for ./configure system\n\t  - math.h included before any other includes to make KDE compile\n\t    with Visual C++ happy\n\t  - Fuji FinePix S5500 size adjusted to ignore (rare?) garbage \n\t    at top of frame.\n        * all client code should be recompiled due to internals change.\n        * LibRaw 0.13.0-Beta1\n\n2010-12-22 Alex Tutubalin <lexa@lexa.ru>\n        * Zero copy huffman buffer for LibRaw_buffer_datastream\n        * Fixed memory leak in compressed NEFs handling\n        * LibRaw 0.13.0-Alpha2\n\n2010-12-20 Alex Tutubalin <lexa@lexa.ru>\n        * Demosaic-pack-GPL3 changes:\n          + New noise reduction methods before demosaic \n             - Banding suppression\n             - High-frequency noise suppression\n             - Green channel equalization\n          + New chromatic abberration correction.\n          All three methods are written by Emil Martinec for Raw Therapee.\n          Adapted to LibRaw by Jacques Desmis\n\n        * Merged Foveon code fix from LibRaw 0.12.1\n\n        * LJPEG decompressor speed-up (about 1.5 times for Canon cameras\n          and slightly less for others). Some ideas are from RawSpeed library.\n\n        * all client code should be recompiled due to internals change.\n\n        * LibRaw 0.13.0-Alpha1\n\n2010-12-12 Alex Tutubalin <lexa@lexa.ru>\n\t* Thread-safe and demosaic packs support for MinGW build\n\t* Demosaic packs support for MS VC build\n        * LibRaw 0.12.0-Release\n\n2010-12-09 Alex Tutubalin <lexa@lexa.ru>\n        * Fixed bug in add_masked_borders_to_bitmap() call for cameras\n          with odd pixels border.\n        * New command line options for unprocessed_raw sample:\n           -B - subtract black level, -M - add masked pixels to bitmap.\n        * Foveon-sensor cameras added to supported camera list if\n          compiled with demosaic pack GPL2 \n        * LibRaw 0.12.0-Beta4\n\n2010-12-05 Alex Tutubalin <lexa@lexa.ru>\n        * Demosaic packs support in Makefile.dist\n        * Foveon support in LibRaw demosaic pack GPL2 \n        * all client code should be recompiled due to internals change.\n        * LibRaw 0.12.0-Beta3\n\n2010-11-27 Alex Tutubalin <lexa@lexa.ru>\n        * Fixed allocation bug in lmmse_interpolation (demosaic-pack-GPL2)\n\t* In LMMSE and AMaZE interpolators allocation changed to calloc\n\t  to make valgrind happy with uninitialized values\n        * Changes in distribution-making scripts\n        * LibRaw 0.12.0-Beta2\n\n2010-11-21 Alex Tutubalin <lexa@lexa.ru>\n\t* Fixes to green_matching code by Sergey Pavlov\n\n2010-11-20 Alex Tutubalin <lexa@lexa.ru>\n        * Update for new demosaic-pack-GPL3\n\t* LibRaw 0.12.0-Beta1\n\n2010-11-19 Alex Tutubalin <lexa@lexa.ru>\n        * Demosaic pack(s) supported via ./configure   \n\n2010-11-17 Alex Tutubalin <lexa@lexa.ru>\n\t* LCMS2 support\n\t* afd_interpolate(2,1) instead of (5,0)\n        * dcraw_emu sample command line keys added and reordered\n          to reflect changes in LibRaw 0.12. \n\t* Nikon P7000: color matrix data and black level patch for ISO >=400\n\t  Thanks to Gunnar Thorburn \n        * Support for several industrial cameras based on Sony ICX 625/655 \n\t  sensor: JAI BB500CL/GE, SVS625CL, ptGrey GRAS-50S5C\n\t  Thanks to kaare\n\n2010-11-15 Alex Tutubalin <lexa@lexa.ru>\n\n        * Several demosaic algorithms, found in other open-source RAW processing\n          packages are implemented in LibRaw. \n\n          1) DCB demosaic and FBDD denoise by Jacek Gozdz are included in \n             main LibRaw source.\n          2) GPL2 demosaic pack with these demosaic methods:\n             * AFD and LMMSE implementations from PerfectRaw by Manuel Llorens\n             * VCD, Modified AHD, post-demosaic refinemend and median\n               filters by Paul Lee\n          3) GPL3 demosaic pack with AMaZe interpolation  by Emil Martinec\n\n          See more details in README.demosaic-packs\n        \n        * Current implementation of dcraw_emu sample allows only selection\n          of demosaic method (via -q) options. All other parameters change\n          will be implemented later.\n\n\t* LibRaw 0.12-alpha1\n\n2010-11-11 Alex Tutubalin <lexa@lexa.ru>\n\t* Imported 0.11(2) version changes:\n\t  + Fixed dcraw_emu command line processing code\n          + OpenMP is completely disabled on MacOS X if compiled with -pthread\n            due to well-known MacOS problem.\n          + dcraw 9.05 (1.439) imported, many new cameras supported:\n              Canon: G12, SX120, 60D,\n              Hasselblad H4D, Nokia X2, Olympus E-5,\n              Nikon: D3100, D7000, P7000,\n              Panasonic: FZ40, FZ100, LX5,\n              Pentax: K-r, K-5, 645D,\n              Samsung GX20, WB2000\n\t* LibRaw 0.12-alpha0\n\n2010-11-08 Alex Tutubalin <lexa@lexa.ru>\n\t* Fixes for Sun Studio compiler compatibility\n\t* Fixes for Visual Studio 2010 compatibility\n\t* All russian-language files are converted to UTF-8\n\t* LibRaw 0.11.0-Release\n\n2010-10-18 Alex Tutubalin <lexa@lexa.ru>\n           * Disabled OpenMP for wavelet_denoise under Mac OS X\n           * More Visual C++ 2003 warnings cleaned in libraw/*h files\n           * LibRaw 0.11-Beta7\n\n2010-10-16 Alex Tutubalin <lexa@lexa.ru>\n           * internal/dcraw_fileio.c can be compiled with -DDCRAW_VERBOSE again\n           * fixed comment style in libraw_datastream.h\n           * LibRaw 0.11-Beta6\n\n2010-10-15 Alex Tutubalin <lexa@lexa.ru>\n\n           * New changes to I/O layer. Three LibRaw_*datastream clasees are\n             exists: \n               + LibRaw_buffer_datastream - buffer reaging\n               + LibRaw_file_datastream - file reading using iostreams\n                 (large files are no supported on some systems)\n               + LibRaw_bigfile_datastream - FILE*-based file I/O\n\n           *  file/bigfile_datastream is selected automatically by\n              LibRaw::open_file based on input file size.\n              By default, files larger than 250Mb are opened using\n              bigfile interface, you may change this behaviour\n              by using second optional parameter of open_file()\n\n           * There is no way to use default parameter values in C API,\n             so new call libraw_open_file_ex added with two parameters\n             (file name and minimal file size for bigfile_datastream use).\n\n           * all client code should be recompiled due to internals change.\n\n           * All LibRaw_abstract_datastream functions are virtual again. You may\n             (again) use your own I/O layer.\n\n           * new -d key for dcraw_emu sample: print timings of processing stages\n\n           * simple_dcraw sample simplified: no mmap code\n\n           * LibRaw 0.11-Beta5\n\n2010-10-08 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in exception handling in OpenMP sections in \n             AHD interpolation code.\n\n           * LibRaw_datastreams are now C++ iostreams based instead of old\n             plain FILE* calls.\n             LibRaw::open_file() in multithreaded programs are WAY faster\n             on many OSes (Linux, Windows, MacOSX) because of no extra locks.\n\n           * all client code should be recompiled due to internals change.\n\n           * LibRaw 0.11-Beta4\n\n\n2010-10-01 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in LibRaw::dcraw_process() code: for half_size\n             processing, params.four_color_rgb was set to 1 internally\n             and not returned back after postprocessing.\n\n           * Several Visual Studio 2003 compatibility fixes\n\n            * AHD interpolation refactored. Now it is about 10% faster than\n              dcraw in single-process mode and up to 1.5 times faster on\n              4-core and OpenMP (total execution time counted, not AHD itself)\n              Thanks to Adam Hooper\n           * AHD interpolation refactored. Now it is about 10% faster than\n             dcraw in single-process mode and up to 1.5 times faster on\n             4-core and OpenMP (total execution time counted, not AHD itself)\n             Thanks to Adam Hooper\n              \n           * LibRaw 0.11-Beta3\n\n2010-09-07 Alex Tutubalin <lexa@lexa.ru>\n           * Phase One files: LibRaw::unpack() sets colordata.black to\n             approximately correct value. \n\n           * Fixed minor error in setting colordata.maximum value\n             for Phase One files.\n\n           * LibRaw::subtract_black() sets colordata.black and\n             colordata.cblack[] to zero to preserve data integrity.\n\n           * LibRaw 0.11-Beta2\n             \n\n2010-09-04 Alex Tutubalin <lexa@lexa.ru>\n\n           * It is now possible to crop output image on postprocessing\n            stage (dcraw_process). Coordinates and size of the output box\n            are set via imgdata.params.cropbox[4] parameter. Look into\n            LibRaw documentation for more details.\n\n              + New fatal error code LIBRAW_BAD_CROP\n\n              + New dcraw_emu sample command line switch: -B x y w h\n                (sets cropbox)\n\n             Thanks to Patrick and Jan.\n\n            * Processing pipeline has changed: the black level is subtracted\n              from data on postprocessing stage either automatically \n              (on dcraw_process() stage) or by special LibRaw API call:\n\n               + New API calls:  LibRaw::subtract_black() (C++ API) and\n                 libraw_subtract_black (C API). \n                 If you use dcraw_process() or dcraw_document_mode_processing()\n                 calls YOU DON'T NEED to call subtract_black() directly.\n               \n               + The raw preprocessing mode LIBRAW_FILTERING_NOBLACKS\n                 is deprecated and removed from LibRaw.\n\n             * New ./configure script.\n               Use ./configure -h for usage details.\n               Thanks to Siddhesh Poyarekar\n\n             * New API cals static LibRaw::dcraw_clear_mem() (C++ API)\n               and libraw_dcraw_clear_mem(..) (C API).\n               This calls are used to free memory, allocated by\n               dcraw_make_mem_image() and dcraw_make_mem_thumb() instead\n               of free() call.\n\n               In some cases LibRaw and calling process have different\n               memory managers, so free() of make_mem_image() data \n               results to program crash (especially in Win32/VisualStudio\n               enviroment).\n\n             * LibRaw::free() is now private instead of public (again).\n\n             * Minor changes and bugfixes:\n\n               + Memory allocation exceptions (std::bad_alloc) are caught,\n                 so LibRaw API calls will return reasonable error codes\n                 instead of C++ exception (possibly unhandled).\n                 This problem is very unlikely to see in wild: if application\n                 cannot allocate small data for internal structure, it will \n                 always fail on allocation for RAW image data.\n\n               + WIN32/VisualStudio 2008/2010: fopen,fscanf and sscanf calls\n                 in Libraw_datastream code are changed to *_s (secure) ones.\n\n               + Debug print removed from fatal error handler.\n\n               + Mmaped I/O for dcraw_emu sample is turned on via -E switch\n                 now (because old -B switch is used for settng cropbox).\n\n           * all client code should be recompiled due to structures size change\n           \n           * LibRaw 0.11-Beta1\n\n\n2010-07-31 Alex Tutubalin <lexa@lexa.ru>\n           * dcraw 9.04 (1.438) imported: changes in tiff metadata parser,\n            fixed a typo in Canon A720 model name\n           * small patch in Sony ARW2 unpacking code to make valgrind happy\n           * LibRaw 0.10.0-Beta3.\n\n2010-07-05 Alex Tutubalin <lexa@lexa.ru>\n           * dcraw 9.03 (1.437) imported:\n             + New cameras: Canon SX20, Nikon D3s, Olympus E-P2, Panasoni DMC-GF1,\n               Samsung EX1, Sony A450\n             + Color data changed for some cameras\n\n           * LibRaw 0.10.0-Beta2.\n\n2010-06-06 Alex Tutubalin <lexa@lexa.ru>\n           * dcraw 9.01 (1.434) imported:\n             + Separate black levels for each color channel.\n             + New cameras: Canon 550D, Casio EX-Z1050, Fuji HS10/HS11,\n               Kodak Z981, Panasonic G2 and G10, Phase One P65, \n               Samsung NX-10 and WB550, Sony NEX-3 and NEX-5.\n             + Fixed file descriptor leak in dark frame subtraction processing\n\n           * Fixed dcraw 9.01's bug in DNG black level processing\n\n           * Preliminary support for Sony A450 camera.\n\n           * New command-line switch -h in mem_image sample (half_size support)\n\n           * Some patches by Johannes Hanika (darktable author):\n              + OpenMP speedup  for PPG-interpolation\n              + green_matching  - suppress of 'color maze' on cameras with\n              different green channel sensitivity. This option is turns on\n              by  filed with same name in imgdata.params\n            \n           * all client code should be recompiled due to structures size \n             change\n\n           * LibRaw::free() is now public instead of private.\n\n           * LibRaw 0.10.0-Beta1.\n\n2010-05-15 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in 8-bit RAW processing code\n           * LibRaw 0.9.1-Release\n\n2010-04-26 Alex Tutubalin <lexa@lexa.ru>\n           * OpenMP support: OpenMP is possible under MinGW (untested)\n           * LibRaw 0.9.0-Release\n\n2010-04-21 Alex Tutubalin <lexa@lexa.ru>\n           * Finally fixed inconsistency in Fuji files processing\n           * New COLOR(row,col) call to get bayer color index in image[] array\n           * Old FC() call is deprecated and will be removed in future releases\n           * unprocessed_raw sample switched to COLOR() call\n           * LibRaw 0.9.0-Beta5\n\n\n2010-04-10 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in unpacking DNG files made from Fuji RAFs.\n           * LibRaw 0.9.0-Beta4\n\n2010-04-09 Alex Tutubalin <lexa@lexa.ru>\n\n           * Fixed typecast error (problem reported only on gcc 4.2.1/32bit)\n            in CRW files processing.\n\n           * C++ API call LibRaw::adjust_maximum() is now deprecated and\n             de-documented, use params.adjust_maximum_thr instead (on by default)\n\n           *  C-API call libraw_adjust_maximum() removed.\n\n           * New postprocessing parameter params.adjust_maximum_thr\n             This parameter replaces LibRaw::adjust_maximum(), but more flexible\n             Defaults are reasonable (0.75, same as in old adjust_maximum),\n             look into documentation for more details.\n\n           * Removed last OpenMP warning\n\n           * dcraw_emu's -c parameter now wants numeric (float) argument. This value\n             is assigned to params.adjust_maximum_thr.\n             Use -c 0.0 for dcraw compatibility.\n\n           * all client code should be recompiled due to structures size \n             change\n\n           * LibRaw 0.9.0-Beta3\n\n\n2010-03-29 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed a bug in channel_maximum[] calculation for\n             Panasonic cameras.\n           * channel_maximum[] data now calculated for ALL cameras.\n           * OpenMP warnings suppressed.\n           * Documented the -c command-line switch for dcraw_emu sample.\n           * Removed extra messages from dcraw_emu sample.\n           * LibRaw 0.9.0-Beta2\n\n2010-03-28 Alex Tutubalin <lexa@lexa.ru>\n           \n           New licensing:\n\n           * Triple licensing (selected by LibRaw user):\n\n              + LGPL 2.1 (http://www.gnu.org/licenses/lgpl-2.1.html)\n              + CDDL 1.0 (http://www.opensource.org/licenses/cddl1.txt)\n              + LibRaw Software License (27 March 2010 version)\n               (http://www.libraw.org/data/LICENSE.LibRaw.pdf)\n\n           * There is no separate LibRaw-Lite and LibRaw-Commercial versions,\n             only single LibRaw.\n             Current LibRaw-Lite and LibRaw-Commercial users should switch\n             to LibRaw without loss of functionality.\n             It is possible to change licensig too (e.g. from LGPL to CDDL\n             for LibRaw-Lite users and from LibRaw License to LGPL or CDDL\n             for LibRaw-Commercial users).\n\n           * No Foveon support :(\n             It is not possible to get good color from Foveon sensors with\n             *any* converter. So, there is no need to support these cameras.\n             Dcraw's Foveon-processing code is too strict licensed (GPL),\n             so we choose to drop it.\n             \n           New Features:\n\n           * New data field  colordata.channel_maximum[4] - per channel data\n            maximum (calculated for most cameras, 0 for others).\n\n           * New call LibRaw::adjust_maximum() (and libraw_adjust_maximum() in C API).\n             This call changes hardcoded colordata.maximum value to calculated\n             at unpack stage. This helps suppress false color in highlights\n             (magenta clouds and so).\n\n           * New command line parameter -c for dcraw_emu sample. Calls adjust_maximum()\n             for each processed file.\n\n           * all client code should be recompiled due to structures size \n             change\n\n           * LibRaw 0.9.0-Beta1\n\n2010-02-06 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed ambiguity in pow/sqrt calls (to make Sun C++ compiler happy)\n           * OpenMP is not supported under MS Visual Studio\n           * Masked a bug in RIFF format parser \n           * LibRaw 0.8.6\n\n2009-12-30 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in simple_dcraw sample parameters processing\n           * Imported dcraw 8.99 (1.432):\n             + New cameras: Canon:  1D mk IV, Canon S90; Casio Z750, \n               Nikon D3S, Pentax K-x, Sony A-500/550, Fuji S200EXR\n             + New color data for Canon G11 and Sony A850\n             + Changes in Canon sRAW processing\n             + Changes in Kodak metadata processing\n             + Changes in uncompressed Fuji files processing (FinePix S5xxx)\n           * LibRaw 0.8.5\n\n2009-11-21 Alex Tutubalin <lexa@lexa.ru>\n           + Fixed a bug in processing of uncompressed Phase One files \n           * LibRaw 0.8.4\n\n2009-10-24 Alex Tutubalin <lexa@lexa.ru>\n           + Imported dcraw 8.98/1.431:\n             * New Cameras: Canon 7D, Panasonic GF1, Sony A850 and A380, \n             Casio Z850, Nikon D300s\n           + changes in libraw_datastream.h to make compilers more happy\n           * LibRaw 0.8.3\n\n2009-09-02 Alex Tutubalin <lexa@lexa.ru>\n           + Fixed bug in Hasselblad .3FR unpacking code\n           * Imported dcraw 8.97/1.428: Nikon D3000 image width fix\n           * LibRaw 0.8.2\n           \n2009-08-31 Alex Tutubalin <lexa@lexa.ru>\n           + Enum LibRaw_thumbnail_formats (LIBRAW_IMAGE_*) values changed to\n             match values in  enum LibRaw_image_formats (LIBRAW_THUMBNAIL_*).\n             You need to recompile all sources using these constants.\n\n2009-08-30 Alex Tutubalin <lexa@lexa.ru>\n           * Imported dcraw 8.97/1.427:\n             + new cameras: Canon A470, Canon G11 (without color data),\n                Nikon D3000, Olympus E-P1, Panasonic DMC-FZ35/FZ38\n             + some changes in decoding code.\n            * Fixes for Microsoft Visual C++ 6.0 compatibility\n            * C-API dcraw_make_mem_thumb() call finally exported in API\n           * LibRaw 0.8.1\n\n2009-08-24 Alex Tutubalin <lexa@lexa.ru>\n           * Imported dcraw 8.96/1.426\n             + New cameras: Casio EX-Z60 and EX-Z75, Kodak Z980,\n               Nikon D5000,  Olympus X200, D560Z,C350Z,E620,\n               Pentax K7, Sony A330.\n             + New color data for many cameras\n             + Generalized unpacker code for Canon and Casio P&S cameras\n           * LibRaw 0.8.0-Release\n\n2009-08-13 Alex Tutubalin <lexa@lexa.ru>\n           * RAW files larger than 2Gb are supported on:\n              - Unix (all supported: FreeBSD, MacOS X, Linux)\n              - Windows (with C runtime version  >= 8.0)\n           * bzero replaced with memset to make Solaris users happy\n           * All applications on 32-bit systems should be recompiled\n             due to data structures size changes.\n           * Minor fixes in windows makefile\n           * LibRaw 0.8.0-Beta5\n\n2009-07-21 Alex Tutubalin <lexa@lexa.ru>\n           * Imported dcraw 8.95 (1.425):\n             + new huffman tree code\n             + New cameras supported: AGFAPHOTO DC-833m, Casio EX-S20,\n                Phase One P65, Samsung S850\n             + Removed hardcoded white-balance data for many P&S cameras.\n               It is recommended to set params.use_camera_wb to 1 for \n               safe WB.\n           * Fixes for Nikon D5000 files: no pink stripe at \n             right side of frame\n           * C-wrapper: added missed calls\n               libraw_dcraw_make_mem_image\n               libraw_dcraw_ make_mem_thumb\n           * Minor fixes to make non-gcc compilers more happy\n           * Internal structures changed, full recompilation of all client \n             code is needed.\n           * LibRaw 0.8.0-Beta4\n                \n2009-06-08 Alex Tutubalin <lexa@lexa.ru>\n           * Fixes: gamma  curve processing was not performed in \n              dcraw_write_mem_image()\n           * Fixes: gamma curve processing was not performed for \n              Kodak thumbnails\n           * LibRaw 0.8.0-Beta3\n\n2009-06-05 Alex Tutubalin <lexa@lexa.ru>\n           * Fixes in documentation: params.gamm[] described more precisely\n           * Fixes in version number, 0.8-beta1 was mistakenly 0.0.0-beta1\n           * LibRaw 0.8.0-Beta2\n\n2009-06-04 Alex Tutubalin <lexa@lexa.ru>\n           * Imported dcraw 8.94 (1.423):\n             + New camera support:\n                 Canon: SX1, 500D/Rebel T1i, A570, A590, SX110\n                 Kodak Z1015, Motorola PIXL, Olympus E30, Panasonic DMC-GH1\n             + Improved color data for Nikon D3X\n             + New gamma curve model\n             + Many changes in RAW unpacking code\n             + Canon cameras: black level is not subtracted if set \n               params.document_mode > 1\n\n           * API changed: params.gamma_16bit field removed. Gamma curve is\n             set via params.gamm[0]/gamm[1] values (see documentation and \n             samples for details)\n           * LibRaw::identify() splitted to avoid MS VS2008 bug (too many \n             nested blocks)\n\n           * Samples: dcraw_emu and mem_image samples supports new dcraw \n              16bit/gamma semantics:\n                -6: set 16 bit output\n                -4: set 16 bit output and linear gamma curve and no auto \n                   brighness\n           *  LibRaw 0.8.0-Beta1\n\n2009-04-28 Alex Tutubalin <lexa@lexa.ru>\n           * Identify sample renamed to raw-identify (name conflict \n             with ImageMagic)\n           * Copyright notice changes\n           * Many compiler warnings removed\n\n2009-04-07 Alex Tutubalin <lexa@lexa.ru>\n           * More accurate types conversion in libraw_datastream.h \n           * New postprocessing parameter auto_bright_thr: set portion of \n             clipped pixels for auto brightening code (instead of \n             dcraw-derived hardcoded 1%)\n           * -U  option for dcraw_emu sample sets auto_bright_thr parameter\n           * all client code should be recompiled due to structures size \n             change\n           * LibRaw 0.7.2-Release\n\n2009-03-22 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed typo in OpenMP support code\n           * MinGW support \n           * dcraw source is included in distribution\n           * LibRaw 0.7.1-Release\n\n2009-03-15 Alex Tutubalin <lexa@lexa.ru>\n           * Fuji SuperCCD RAWs: color channels unshuffled on RAW\n             read stage (moved from postprocessing stage)\n\n           * LibRaw 0.7.0-Release\n\n2009-03-13 Alex Tutubalin <lexa@lexa.ru>\n           * dcraw 8.93/1.421 imported:\n             + more accurate pentax dSLR support\n             + fixes in Kodak 620x/720x identification\n             + faster identification procedure for some formats.\n           * LibRaw 0.7.0-Beta5\n\n\n2009-03-08 Alex Tutubalin <lexa@lexa.ru>\n           * dcraw 8.92/1.420 imported:\n             + user-specified gamma curve\n             + Pentax K2000/Km support\n             + Changes in Canon sRAW processing (support for 5D2 fw 1.07)\n\n           * all client code should be recompiled\n\n           * LibRaw 0.7.0-Beta4\n\n2009-02-13 Alex Tutubalin <lexa@lexa.ru>\n           * bugfix: 4channels sample finally subtracts black by default\n           * dcraw 8.91/1.419 imported:\n              + fixes in RIFF files parsing\n\n           * LibRaw 0.7.0-Beta3\n\n2009-02-12 Alex Tutubalin <lexa@lexa.ru>\n           * Black level was not calculated for Canon RAWs in\n             some filtering modes\n\n           * 4channels sample prints calculated black level\n             (scaled if autoscaling used). \n             Also output file names for this sample now includes \n             color channel name (R/G/B/G2 or C/M/Y/G)\n\n           * LibRaw 0.7.0-Beta2\n\n2009-02-09 Alex Tutubalin <lexa@lexa.ru>\n           * New sample 4channels: splits RAW color channels into four \n             separate TIFFs\n\n           * LibRaw 0.7.0-Beta1\n\n2009-02-07 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in external jpeg metadata reading code.\n\n           * Cleaned some C++ warnings\n\n           * dcraw 8.91/1.418 imported\n             + Hasselblad V96C support\n\n           * You need to clean and recompile client code which\n             uses LibRaw_*_datastream classes.\n\n           * LibRaw 0.7.0-Alpha6\n\n2009-01-30  Alex Tutubalin <lexa@lexa.ru>\n\n           * New data input framework is created. It is possible now to\n             easyly implement your own data input interface for LibRaw\n             (e.g. for reading RAW data from network data stream)\n             \n           * All older programs using previous LibRaw versions are\n\t     compatible at source code level.\n\n           * LibRaw can read RAW data from memory buffer via\n             new LibRaw::open_buffer() API call (implemented on top of\n             new input framework). \n             This call used in sample application dcraw_emu and simple_dcraw\n             (with -B command-line switch) to test new API.\n\n           * Error handling callback functions now can be called with\n             NULL filename passed (if underlying data stream object\n             does not know file name).\n             So, client error handling callbacks should work with NULL\n             filename.\n\n           * All client code should be recompiled\n\n           * Imported dcraw 8.90/1.417:\n              + Support for loading White Balance data from\n                Sony ARW files edited with Sony IDC software.\n\n           * LibRaw 0.7.0-Alpha5\n\n2009-01-17 Alex Tutubalin <lexa@lexa.ru>\n           * Raw filtering mode LIBRAW_FILTERING_NOPOSTPROCESS has renamed\n            to LIBRAW_FILTERING_NORAWCURVE for better reflect its purpose.\n            This filtering_mode bit turns off tone curve applying on\n            RAW data on bayer-pattern cameras with raw tone curve:\n              + Adobe DNG (only RAW with bayer pattern)\n              + Nikon compressed NEF\n              + Some Kodak cameras\n              + Sony A700/A900 (tone curve applied to 8-bit raws)\n\n           * unprocessed_raw sample: added command-line key -N, this key\n             turns on LIBRAW_FILTERING_NORAWCURVE filtering mode.\n\n           * New scheme of Fuji RAW processing (introduced in 0.7-Alpha3)\n             supports DNG files generated from Fuji RAF.\n           \n           * Imported dcraw 8.90/1.416:\n              + better support for Samsung S85\n              + fixed possible integer overflow in wavelet denoising code\n\n           * LibRaw 0.7.0-Alpha4\n\n\n2009-01-14 Alex Tutubalin <lexa@lexa.ru>\n           * Black mask extraction supported for all files with bayer data\n            (one component per pixel). Black mask data not avaliable\n            for multi-component data (Foveon, Canon sRAW, Sinar 4-shot,\n            Kodak YCC/YRGB).\n\n           * Black level subtraction can be turned off for all bayer\n            cameras (added support for PhaseOne backs).\n\n           * Fujifilm camera processing model changed:\n              + RAW data is extracted without 45-degree rotation\n              + dcraw-compatible rotation is performed on postptocessing stage\n              + it is possible to rotate RAW data without postprocessing\n                by LibRaw::rotate_fuji_raw() call.\n\n           * New filtering mode setting: LIBRAW_FILTERING_NOPOSTPROCESS\n             This bits turns off RAW tone curve processing based on tone curve\n             readed from RAW metadata.\n             This mode supported only for PhaseOne backs now (to be supported\n             on all relevant cameras in nearest future releases)\n\n           * Black level data (got from RAW data) are stored for PhaseOne backs.\n\n           * Black level subtraction bug (derived from dcraw) fixed\n             for PhaseOne files.\n\n           * Fixed processing of -s parameter for dcraw_emu sample\n           \n           * Parameter  -s N (select shot number) added to \n             unprocessed_raw sample.\n\n           * Imported dcraw 8.90/1.414:\n              + changes in QuickTake 100 metadata processing\n              + changes in external jpeg processing code\n              + Samsung S85 support\n\n           * All client code should be recompiled\n\n           * LibRaw 0.7.0-Alpha3 released\n\n2009-01-10 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in add_masked_borders: crash if output dimensions\n            is already larger than raw dimensions\n            * Fixed out of bounds in samples/unprocessed_raw.cpp for files\n            with non-square pixels\n\n           * LibRaw 0.7.0-Alpha2 released\n           \n2009-01-08 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in  0.7.0-a0: black frame size has not reset, \n             so in batch processing there is an error in black frame\n             size for files without black frame.\n\n           * Implemented reading of black/masked pixels data for \n             near all cameras with masked pixels, exclding:\n              + Canon sRAW, Leaf (MOS), Sinar 4-shot - more than one \n                color component in black frame (redesign of black frame\n                data structures required).\n              + Fuji SuperCCD: need to design right methods of extraction \n                (should we rotate and resize black pixels as active ones??)\n\n            * Tested for most dSLR data formats with masked pixels: 7 of 9\n              untested formats are from old P&S cameras.\n\n           * New call LibRaw::unpack_function_name() returns unpack function name\n             (useful for testers only)\n\n           * New identify sample parameters (useful for test-suite builders\n             to check test coverage):\n                  -u - print unpack function name\n                  -f - print masked frame size\n             These parameters works only for identify run without -v parameter\n\n           * Imported dcraw 8.89/1.411\n             + changes in Panasonic FZ50 files parsing\n\n           * LibRaw 0.7.0-Alpha1 released\n\n\n2009-01-05 Alex Tutubalin <lexa@lexa.ru>\n           * It is possible to turn off RAW data filtration (black level \n             subtraction,              zero pixels averaging):\n                + supported on all cameras except Foveon and Phase One\n                + filtraction controlled by new parameter \"filtering_mode\"\n                + it is possible to expand API by filtering procedures \n                  built for specific camera model.\n\n           * Black border (masked pixels) extraction:\n                + API (data structures) for storing black mask.\n                + Black mask extraction supported only for limited list of\n                  data formats: \n                       - Canon .CRW, .CR2 (with exception of sRAW),A600, A5\n                       - Adobe DNG (both converted RAW and native DNG)\n                       - Nikon NEF (compressed only)\n                  this list to be expanded in future LibRaw versions\n           * New call add_masked_borders_to_bitmap makes full bitmap\n             'masked border' + image\n           * Usage sample for functionality listed above: \n              samples/unprocessed_raw \n           * Imported dcraw 8.89/1.410:\n              + fixed bugs in Hasselblad .fff decoding\n              + fixes in Imacon metadata decoding\n           * Documentation changes\n           * All client code should be recompiled\n           * LibRaw 0.7.0-Alpha0\n\n\n2009-01-01 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed a bug (filedescriptor and buffer memory leak)  in thumbnail \n             extraction when called before metadata analysis. \n             Thanks to Albert Astalis Cid.\n           * LibRaw 0.6.4 Release\n\n2008-12-11 Alex Tutubalin <lexa@lexa.ru>\n           * Imported new edition of dcraw 8.89 (version 1.409)\n           * Nikon NEF decoding changed\n           * LibRaw 0.6.3 Release\n           \n2008-12-03 Alex Tutubalin <lexa@lexa.ru>\n           * fixed bug in Panasonic .RW2 processing (only for thread-safe version,\n             single-threaded version was not affected)\n           * All client code should be recompiled\n           * LibRaw 0.6.2 Release\n\n2008-12-03 Alex Tutubalin <lexa@lexa.ru>\n           * Imported  dcraw 8.89 (version 1.407)\n           * New cameras:\n               Canon G10 & 5D Mk2, Leaf AFi 7, Leica D-LUX4, Panasonic FX150 & G1, \n               Fujifilm IS Pro,\n           * Changed camera support (color conversion tables):\n               Canon 50D, Nikon D90 & P6000, Panasonic LX3 & FZ28, Sony A900\n           * LibRaw 0.6.2 beta\n\n2008-09-25 Alex Tutubalin <lexa@lexa.ru>\n           * Added new data field  float LibRaw::imgdata.color.cam_xyz[4][3]. \n           This field contains constant table (different for each camera) for\n           Camera RGB->XYZ conversion.\n           * All client code should be recompiled\n           * LibRaw 0.6.1 Release\n\n2008-09-18 Alex Tutubalin <lexa@lexa.ru>\n           * dcraw 8.88 imported:\n              - new cameras (Canon 50D, Sony A900, Nikon D90 & P6000,\n                Panasonic LX3 FZ28)\n              - new method of black point subtraction for Canon cameras, \n                preliminary banding supression.\n            * Stack memory usage lowered (some thread data moved to dynamic\n            memory) \n            * some patches for MSVC compatibility\n            * LibRaw 0.6.0 Release\n\n2008-09-16 Alex Tutubalin <lexa@lexa.ru>\n           * Enum definitions changed to make gcc -pedantic happy\n           * Compiler/preprocessor flags does not affects LibRaw class field set\n           (i.e. structure for thread local storage is always allocated)                   \n           * Default library compilation mode (i.e. sources imported in another\n             project) is thread-safe \n\n2008-09-14 Alex Tutubalin <lexa@lexa.ru>\n           * OpenMP support for most CPU consuming steps of processing:\n             ahd_interpolation. wavelet_denoise\n             10-30% speed-up of full processing pipe on 2-core CPU \n             OpenMP supported only on gcc (Linux/FreeBSD and Mac OS X)\n\n           * LibRaw 0.6.0-Beta-1\n\n2008-09-10 Alex Tutubalin <lexa@lexa.ru>\n           *  All set_**handler accepts additional void* pointer, which should point to\n            callback private data. This pointer passed to user callback when it called.\n\n           * LibRaw 0.6.0-alpha5\n\n           * All client code should be recompiled\n\n2008-09-10 Alex Tutubalin <lexa@lexa.ru>\n           * New processing stages in enum LibRaw_progress: \n             LIBRAW_PROGRESS_BAD_PIXELS LIBRAW_PROGRESS_DARK_FRAME\n            (reserved stages LIBRAW_PROGRESS_RESERVED_PRE1-PRE2 has removed)\n           * libraw_strprogress() - convert progress code into string\n\n           * Added progress/cancellation user callbacks\n             + new fatal error code: CANCELLED_BY_CALLBACK\n             + sample usage in samples/dcraw_emu.cpp (try run it with -v -v -v opts)\n\n           * LibRaw 0.6.0-alpha4\n\n           * All client code should be recompiled\n\n2008-09-08 Alex Tutubalin <lexa@lexa.ru>\n           * ICC-profiles support (same as in dcraw)\n             + input/output profiles (specified as path to 'icc' file or 'embed' for \n               embedded input profile)\n             + additional warnings\n             + LCMS library used\n\n           * support of bad pixel map (caller should specify path to bad pixel file \n              in dcraw-compatible format)\n\n           * dark frame subtraction support (caller should supply path to 16-bit PGM \n              map). samples/simple_dcraw.cpp - -4 option added for dark frame file \n              generation\n\n           * support of bad pixeld map (dcraw-compatible format)\n\n           * the dcraw_emu sample supports all new features (ICC, dark frame, bad \n              pixels)\n\n           * libraw/libraw_version.h, defines, calls and macros for version checks:\n              + LibRaw::version(), LibRaw::versionNumber(), LIBRAW_CHECK_VERSION()\n\n           * List of supported cameras:\n              + LibRaw::cameraCount()\n              + LibRaw::cameraList()\n\n           * fixed error in adjust_sizes_info_only\n\n           * documentation changes\n\n           * LibRaw 0.6.0-alpha3\n\n2008-09-07 Alex Tutubalin <lexa@lexa.ru>\n           * samples/mem_image.c - bitwise equal output with dcraw -4\n             (PPMs outputted with network byte order)\n           * LibRaw 0.6.0-alpha2\n           \n2008-09-06 Alex Tutubalin <lexa@lexa.ru>\n           * Added calls dcraw_make_mem_image and dcraw_make_mem_image:\n             + functions (and supporting code)\n             + documentation changed\n             + new sample code samples/mem_image.cpp\n           * Added processing parameter  LibRaw::imgdata.params.gamma_16bit \n              (set to 1 to make gamma correction for 16-bit output)\n           * LibRaw 0.6.0-alpha1\n\n2008-08-28 Alex Tutubalin <lexa@lexa.ru>\n           * dcraw 1.404 (8.87) imported:\n             - 6 new cameras supported (Canon 1000D, A720, SD300; \n                Nikon D700, Oly E-520,Kodak C603)\n           * Licensing changed to GPL v2\n\n2008-05-02  Alex Tutubalin <lexa@lexa.ru>\n            * mmap/malloc+read IO-layer removed due to no performance gain.\n              FILE I/O returned\n\n2008-05-02  Alex Tutubalin <lexa@lexa.ru>\n            * dcraw 1.403 imported\n              - changes in ljpeg decompression (index values cut to 12 bit)\n              - changes in parse_foveon() jpeg thumbnail extraction\t\n            * LibRaw 0.5.3 released\n\n2008-04-24  Alex Tutubalin <lexa@lexa.ru>\n            * Linux build of samples/identify fixed\n            * documentation editorial\n            * LibRaw 0.5.2 released\n\n2008-04-21  Alex Tutubalin <lexa@lexa.ru>\n            * All documentation translated to English\n            * English changelog started :)\n            * minor bug (include path) fixed in samples/half_mt \n            * LibRaw 0.5.1 released\n", "all: sources library all_samples dcraw_binaries\n\nPP=./internal/preprocess.pl\n\nCC=gcc\nCXX=g++\nCFLAGS+= -O -g -I.\n\n# RawSpeed Support\n#CFLAGS+=-DUSE_RAWSPEED -I../RawSpeed -I/usr/local/include/libxml2\n#LDADD+=-L../RawSpeed/RawSpeed/release -lrawspeed -L/usr/local/include -ljpeg -lxml2\n#RAWSPEED_DATA=../RawSpeed/data/cameras.xml\n\n\n#CC=gcc48\n#CXX=g++48\n#CFLAGS+= -O -g -I. -march=corei7 -mtune=corei7 -I. -pedantic  -Wno-long-long -Wno-overflow -msse4.2 -mfpmath=sse  -fopenmp \n\n\n# LCMS support\n# For lcms2 set -DUSE_LCMS2\n#CFLAGS+=-DUSE_LCMS -I/usr/local/include\n#LDADD+=-L/usr/local/lib -llcms\n\n# Jasper support for RedCine\nCFLAGS+=-DUSE_JASPER -I/usr/local/include\nLDADD+=-L/usr/local/lib -ljasper\n\n# JPEG support for DNG\nCFLAGS+=-DUSE_JPEG -I/usr/local/include\nLDADD+=-L/usr/local/lib -ljpeg\n# LIBJPEG8:\nCFLAGS+=-DUSE_JPEG8\n\n# Demosaic Pack GPL2:\nDPCFLAGS+=-I../LibRaw-demosaic-pack-GPL2\nCFLAGS+=-DLIBRAW_DEMOSAIC_PACK_GPL2\n\n# Demosaic Pack GPL3:\nDPCFLAGS+=-I../LibRaw-demosaic-pack-GPL3\nCFLAGS+=-DLIBRAW_DEMOSAIC_PACK_GPL3\n\n\nDCRAW_GEN= internal/dcraw_common.cpp internal/dcraw_fileio.cpp\nDCRAW_LIB_OBJECTS=object/dcraw_common.o object/libraw_cxx.o object/libraw_datastream.o object/libraw_c_api.o object/dcraw_fileio.o object/demosaic_packs.o\nDCRAW_LIB_MT_OBJECTS=object/dcraw_common_mt.o object/libraw_cxx_mt.o object/libraw_datastream_mt.o object/libraw_c_api_mt.o object/dcraw_fileio_mt.o object/demosaic_packs_mt.o\nLR_INCLUDES=libraw/libraw.h libraw/libraw_alloc.h libraw/libraw_const.h libraw/libraw_datastream.h libraw/libraw_internal.h libraw/libraw_types.h libraw/libraw_version.h\n\nsources: ${DCRAW_GEN} Makefile.devel ${PP}\nlibrary: lib/libraw.a lib/libraw_r.a\n\nall_samples: bin/raw-identify bin/simple_dcraw  bin/dcraw_emu bin/dcraw_half bin/half_mt bin/mem_image \\\n        bin/unprocessed_raw bin/4channels bin/multirender_test bin/postprocessing_benchmark\n\n## RawSpeed xml file\n\nRawSpeed/rawspeed_xmldata.cpp: ${RAWSPEED_DATA}\n\t./rsxml2c.sh ${RAWSPEED_DATA} > RawSpeed/rawspeed_xmldata.cpp\n\n## Demosaic Pack(s)\n\nobject/demosaic_packs.o: internal/demosaic_packs.cpp ${LR_INCLUDES}\n\t$(CXX) -w -c -DLIBRAW_NOTHREADS ${CFLAGS} ${DPCFLAGS} -o object/demosaic_packs.o internal/demosaic_packs.cpp\n\nobject/demosaic_packs_mt.o: internal/demosaic_packs.cpp ${LR_INCLUDES}\n\t$(CXX) -w -c -pthread ${CFLAGS} ${DPCFLAGS} -o object/demosaic_packs_mt.o internal/demosaic_packs.cpp\n\n## Samples ##\nbin/raw-identify: lib/libraw.a samples/raw-identify.cpp\n\t$(CXX) ${CFLAGS} -o bin/raw-identify samples/raw-identify.cpp -L./lib -lraw  -lm  ${LDADD}\n\nbin/simple_dcraw: lib/libraw.a samples/simple_dcraw.cpp\n\t$(CXX) -DLIBRAW_NOTHREADS ${CFLAGS} -o bin/simple_dcraw samples/simple_dcraw.cpp -L./lib -lraw  -lm  ${LDADD}\n\nbin/multirender_test: lib/libraw.a samples/multirender_test.cpp\n\t$(CXX) -DLIBRAW_NOTHREADS ${CFLAGS} -o bin/multirender_test samples/multirender_test.cpp -L./lib -lraw  -lm  ${LDADD}\n\nbin/postprocessing_benchmark: lib/libraw.a samples/postprocessing_benchmark.cpp\n\t$(CXX) -DLIBRAW_NOTHREADS ${CFLAGS} -o bin/postprocessing_benchmark samples/postprocessing_benchmark.cpp -L./lib -lraw  -lm  ${LDADD}\n\nbin/unprocessed_raw: lib/libraw.a samples/unprocessed_raw.cpp\n\t$(CXX) -DLIBRAW_NOTHREADS ${CFLAGS} -o bin/unprocessed_raw samples/unprocessed_raw.cpp -L./lib -lraw  -lm  ${LDADD}\n\nbin/4channels: lib/libraw.a samples/4channels.cpp\n\t$(CXX) -DLIBRAW_NOTHREADS ${CFLAGS} -o bin/4channels samples/4channels.cpp -L./lib -lraw  -lm  ${LDADD}\n\nbin/mem_image: lib/libraw.a samples/mem_image.cpp\n\t$(CXX) ${CFLAGS} -o bin/mem_image samples/mem_image.cpp -L./lib -lraw  -lm  ${LDADD}\n\nbin/dcraw_half: lib/libraw.a samples/dcraw_half.c\n\t$(CC) ${CFLAGS} -o bin/dcraw_half samples/dcraw_half.c -L./lib -lraw  -lm -lstdc++  ${LDADD}\n\nbin/half_mt: lib/libraw_r.a samples/half_mt.c\n\t$(CC) -pthread ${CFLAGS} -o bin/half_mt samples/half_mt.c -L./lib -lraw_r  -lm -lstdc++  ${LDADD}\n\nbin/dcraw_emu: lib/libraw.a samples/dcraw_emu.cpp\n\t$(CXX) ${CFLAGS} -o bin/dcraw_emu samples/dcraw_emu.cpp -L./lib -lraw_r  -lm ${LDADD}\n\ndcraw_binaries: bin/dcraw_dist\n\nbin/dcraw_dist: dcraw/dcraw.c Makefile.devel\n\t$(CXX) -w -O4 -DLIBRAW_NOTHREADS -DNO_JPEG -DNO_LCMS -DNO_JASPER -I/usr/local/include -o bin/dcraw_dist dcraw/dcraw.c -lm -L/usr/local/lib \n\nregenerate:\n\t${PP} -N -DDEFINES dcraw/dcraw.c  >internal/defines.h\n\t${PP} -N -DCOMMON dcraw/dcraw.c >internal/dcraw_common.cpp\n\t${PP} -N -DFILEIO dcraw/dcraw.c >internal/dcraw_fileio.cpp\n\ninternal/defines.h: dcraw/dcraw.c  ${PP}\n\t${PP} -DDEFINES dcraw/dcraw.c  >internal/defines.h\n\ninternal/dcraw_common.cpp: dcraw/dcraw.c internal/defines.h  ${PP} Makefile.devel\n\t${PP} -DCOMMON dcraw/dcraw.c >internal/dcraw_common.cpp\n\ninternal/dcraw_fileio.cpp: dcraw/dcraw.c internal/defines.h  ${PP} Makefile.devel\n\t${PP} -DFILEIO dcraw/dcraw.c >internal/dcraw_fileio.cpp\n\nobject/dcraw_common.o: internal/dcraw_common.cpp ${LR_INCLUDES}\n\t$(CXX) -c -DLIBRAW_NOTHREADS ${CFLAGS} ${LCMS_DEF} -o object/dcraw_common.o internal/dcraw_common.cpp\n\nobject/dcraw_fileio.o: internal/dcraw_fileio.cpp ${LR_INCLUDES}\n\t$(CXX) -c -DLIBRAW_NOTHREADS ${CFLAGS} ${LCMS_DEF} -o object/dcraw_fileio.o internal/dcraw_fileio.cpp\n\nobject/libraw_cxx.o: src/libraw_cxx.cpp ${LR_INCLUDES} RawSpeed/rawspeed_xmldata.cpp\n\t$(CXX) -c -DLIBRAW_NOTHREADS ${LCMS_DEF} ${CFLAGS} -o object/libraw_cxx.o src/libraw_cxx.cpp\n\nobject/libraw_datastream.o: src/libraw_datastream.cpp ${LR_INCLUDES}\n\t$(CXX) -c -DLIBRAW_NOTHREADS ${LCMS_DEF} ${CFLAGS} -o object/libraw_datastream.o src/libraw_datastream.cpp\n\nobject/libraw_c_api.o: src/libraw_c_api.cpp ${LR_INCLUDES}\n\t$(CXX) -c -DLIBRAW_NOTHREADS ${LCMS_DEF}  ${CFLAGS} -o object/libraw_c_api.o src/libraw_c_api.cpp\n\nlib/libraw.a: ${DCRAW_LIB_OBJECTS}\n\trm -f lib/libraw.a\n\tar crv lib/libraw.a ${DCRAW_LIB_OBJECTS}\n\tranlib lib/libraw.a\n\nlib/libraw_r.a: ${DCRAW_LIB_MT_OBJECTS}\n\trm -f lib/libraw_r.a\n\tar crv lib/libraw_r.a ${DCRAW_LIB_MT_OBJECTS}\n\tranlib lib/libraw_r.a\n\nobject/dcraw_common_mt.o: internal/dcraw_common.cpp ${LR_INCLUDES}\n\t$(CXX) -c -pthread ${LCMS_DEF} ${CFLAGS} -o object/dcraw_common_mt.o internal/dcraw_common.cpp\n\nobject/dcraw_fileio_mt.o: internal/dcraw_fileio.cpp ${LR_INCLUDES}\n\t$(CXX)  -c -pthread ${LCMS_DEF} ${CFLAGS} -o object/dcraw_fileio_mt.o internal/dcraw_fileio.cpp\n\nobject/libraw_cxx_mt.o: src/libraw_cxx.cpp ${LR_INCLUDES}\n\t$(CXX) -c ${LCMS_DEF} -pthread ${CFLAGS} -o object/libraw_cxx_mt.o src/libraw_cxx.cpp\n\nobject/libraw_datastream_mt.o: src/libraw_datastream.cpp ${LR_INCLUDES}\n\t$(CXX) -c ${LCMS_DEF} -pthread ${CFLAGS} -o object/libraw_datastream_mt.o src/libraw_datastream.cpp\n\nobject/libraw_c_api_mt.o: src/libraw_c_api.cpp ${LR_INCLUDES}\n\t$(CXX) -c ${LCMS_DEF} -pthread ${CFLAGS} -o object/libraw_c_api_mt.o src/libraw_c_api.cpp\n\nclean:\n\trm -fr bin/*.dSYM\n\trm -f *.o *~ src/*~ samples/*~ internal/*~ libraw/*~ lib/lib*.a bin/[4a-z]* object/*o dcraw/*~ doc/*~ bin/*~\n\nfullclean: clean\n\trm -f ${DCRAW_GEN}\n", "#ifndef IGNOREALL\n/*\n   dcraw.c -- Dave Coffin's raw photo decoder\n   Copyright 1997-2012 by Dave Coffin, dcoffin a cybercom o net\n\n   This is a command-line ANSI C program to convert raw photos from\n   any digital camera on any computer running any operating system.\n\n   No license is required to download and use dcraw.c.  However,\n   to lawfully redistribute dcraw, you must either (a) offer, at\n   no extra charge, full source code* for all executable files\n   containing RESTRICTED functions, (b) distribute this code under\n   the GPL Version 2 or later, (c) remove all RESTRICTED functions,\n   re-implement them, or copy them from an earlier, unrestricted\n   Revision of dcraw.c, or (d) purchase a license from the author.\n\n   The functions that process Foveon images have been RESTRICTED\n   since Revision 1.237.  All other code remains free for all uses.\n\n   *If you have not modified dcraw.c in any way, a link to my\n   homepage qualifies as \"full source code\".\n\n   $Revision: 1.454 $\n   $Date: 2012/12/23 19:25:36 $\n */\n/*@out DEFINES\n#ifndef USE_JPEG\n#define NO_JPEG\n#endif\n#ifndef USE_JASPER\n#define NO_JASPER\n#endif\n@end DEFINES */\n\n#define NO_LCMS\n#define DCRAW_VERBOSE\n//@out DEFINES\n#define DCRAW_VERSION \"9.17\"\n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#define _USE_MATH_DEFINES\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include <setjmp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <sys/types.h>\n\n#ifdef NODEPS\n#define NO_JASPER\n#define NO_JPEG\n#define NO_LCMS\n#endif\n#ifndef NO_JASPER\n#include <jasper/jasper.h>\t/* Decode RED camera movies */\n#endif\n#ifndef NO_JPEG\n#include <jpeglib.h>\t\t/* Decode compressed Kodak DC120 photos */\n#endif\t\t\t\t/* and Adobe Lossy DNGs */\n//@end DEFINES\n#ifndef NO_LCMS\n#include <lcms.h>\t\t/* Support color profiles */\n#endif\n//@out DEFINES\n#ifdef LOCALEDIR\n#include <libintl.h>\n#define _(String) gettext(String)\n#else\n#define _(String) (String)\n#endif\n//@end DEFINES\n#if defined(DJGPP) || defined(__MINGW32__)\n#define fseeko fseek\n#define ftello ftell\n#else\n#define fgetc getc_unlocked\n#endif\n//@out DEFINES\n#ifdef __CYGWIN__\n#include <io.h>\n#endif\n#ifdef WIN32\n#include <sys/utime.h>\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32.lib\")\n#define snprintf _snprintf\n#define strcasecmp stricmp\n#define strncasecmp strnicmp\n//@end DEFINES\ntypedef __int64 INT64;\ntypedef unsigned __int64 UINT64;\n//@out DEFINES\n#else\n#include <unistd.h>\n#include <utime.h>\n#include <netinet/in.h>\ntypedef long long INT64;\ntypedef unsigned long long UINT64;\n#endif\n\n#ifdef LJPEG_DECODE\n#error Please compile dcraw.c by itself.\n#error Do not link it with ljpeg_decode.\n#endif\n\n#ifndef LONG_BIT\n#define LONG_BIT (8 * sizeof (long))\n#endif\n//@end DEFINES\n\n#if !defined(uchar)\n#define uchar unsigned char\n#endif\n#if !defined(ushort)\n#define ushort unsigned short\n#endif\n\n/*\n   All global variables are defined here, and all functions that\n   access them are prefixed with \"CLASS\".  Note that a thread-safe\n   C++ class cannot have non-const static local variables.\n */\nFILE *ifp, *ofp;\nshort order;\nconst char *ifname;\nchar *meta_data;\nchar cdesc[5], desc[512], make[64], model[64], model2[64], artist[64];\nfloat flash_used, canon_ev, iso_speed, shutter, aperture, focal_len;\ntime_t timestamp;\nunsigned shot_order, kodak_cbpp, filters, exif_cfa, unique_id;\noff_t    strip_offset, data_offset;\noff_t    thumb_offset, meta_offset, profile_offset;\nunsigned thumb_length, meta_length, profile_length;\nunsigned thumb_misc, *oprof, fuji_layout, shot_select=0, multi_out=0;\nunsigned tiff_nifds, tiff_samples, tiff_bps, tiff_compress;\nunsigned black, cblack[4], maximum, mix_green, raw_color, zero_is_bad;\nunsigned zero_after_ff, is_raw, dng_version, is_foveon, data_error;\nunsigned tile_width, tile_length, gpsdata[32], load_flags;\nushort raw_height, raw_width, height, width, top_margin, left_margin;\nushort shrink, iheight, iwidth, fuji_width, thumb_width, thumb_height;\nushort *raw_image, (*image)[4];\nushort white[8][8], curve[0x10000], cr2_slice[3], sraw_mul[4];\nint mask[8][4], flip, tiff_flip, colors;\ndouble pixel_aspect, aber[4]={1,1,1,1}, gamm[6]={ 0.45,4.5,0,0,0,0 };\nfloat bright=1, user_mul[4]={0,0,0,0}, threshold=0;\nint half_size=0, four_color_rgb=0, document_mode=0, highlight=0;\nint verbose=0, use_auto_wb=0, use_camera_wb=0, use_camera_matrix=-1;\nint output_color=1, output_bps=8, output_tiff=0, med_passes=0;\nint no_auto_bright=0;\nunsigned greybox[4] = { 0, 0, UINT_MAX, UINT_MAX };\nfloat cam_mul[4], pre_mul[4], cmatrix[3][4], rgb_cam[3][4];\nconst double xyz_rgb[3][3] = {\t\t\t/* XYZ from RGB */\n  { 0.412453, 0.357580, 0.180423 },\n  { 0.212671, 0.715160, 0.072169 },\n  { 0.019334, 0.119193, 0.950227 } };\nconst float d65_white[3] = { 0.950456, 1, 1.088754 };\nint histogram[4][0x2000];\nvoid (*write_thumb)(), (*write_fun)();\nvoid (*load_raw)(), (*thumb_load_raw)();\njmp_buf failure;\n\nstruct decode {\n  struct decode *branch[2];\n  int leaf;\n} first_decode[2048], *second_decode, *free_decode;\n\nstruct tiff_ifd {\n  int t_width, t_height, bps, comp, phint, offset, t_flip, samples, bytes;\n  int t_tile_width, t_tile_length;\n} tiff_ifd[10];\n\nstruct ph1 {\n  int format, key_off, t_black, black_off, split_col, tag_21a;\n  float tag_210;\n} ph1;\n\n#define CLASS\n\n//@out DEFINES\n#define FORC(cnt) for (c=0; c < cnt; c++)\n#define FORC3 FORC(3)\n#define FORC4 FORC(4)\n#define FORCC FORC(colors)\n\n#define SQR(x) ((x)*(x))\n#define ABS(x) (((int)(x) ^ ((int)(x) >> 31)) - ((int)(x) >> 31))\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define LIM(x,min,max) MAX(min,MIN(x,max))\n#define ULIM(x,y,z) ((y) < (z) ? LIM(x,y,z) : LIM(x,z,y))\n#define CLIP(x) LIM(x,0,65535)\n#define SWAP(a,b) { a=a+b; b=a-b; a=a-b; }\n\n/*\n   In order to inline this calculation, I make the risky\n   assumption that all filter patterns can be described\n   by a repeating pattern of eight rows and two columns\n\n   Do not use the FC or BAYER macros with the Leaf CatchLight,\n   because its pattern is 16x16, not 2x8.\n\n   Return values are either 0/1/2/3 = G/M/C/Y or 0/1/2/3 = R/G1/B/G2\n\n\tPowerShot 600\tPowerShot A50\tPowerShot Pro70\tPro90 & G1\n\t0xe1e4e1e4:\t0x1b4e4b1e:\t0x1e4b4e1b:\t0xb4b4b4b4:\n\n\t  0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\n\t0 G M G M G M\t0 C Y C Y C Y\t0 Y C Y C Y C\t0 G M G M G M\n\t1 C Y C Y C Y\t1 M G M G M G\t1 M G M G M G\t1 Y C Y C Y C\n\t2 M G M G M G\t2 Y C Y C Y C\t2 C Y C Y C Y\n\t3 C Y C Y C Y\t3 G M G M G M\t3 G M G M G M\n\t\t\t4 C Y C Y C Y\t4 Y C Y C Y C\n\tPowerShot A5\t5 G M G M G M\t5 G M G M G M\n\t0x1e4e1e4e:\t6 Y C Y C Y C\t6 C Y C Y C Y\n\t\t\t7 M G M G M G\t7 M G M G M G\n\t  0 1 2 3 4 5\n\t0 C Y C Y C Y\n\t1 G M G M G M\n\t2 C Y C Y C Y\n\t3 M G M G M G\n\n   All RGB cameras use one of these Bayer grids:\n\n\t0x16161616:\t0x61616161:\t0x49494949:\t0x94949494:\n\n\t  0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\n\t0 B G B G B G\t0 G R G R G R\t0 G B G B G B\t0 R G R G R G\n\t1 G R G R G R\t1 B G B G B G\t1 R G R G R G\t1 G B G B G B\n\t2 B G B G B G\t2 G R G R G R\t2 G B G B G B\t2 R G R G R G\n\t3 G R G R G R\t3 B G B G B G\t3 R G R G R G\t3 G B G B G B\n */\n\n#define RAW(row,col) \\\n\traw_image[(row)*raw_width+(col)]\n//@end DEFINES\n\n#define FC(row,col) \\\n\t(filters >> ((((row) << 1 & 14) + ((col) & 1)) << 1) & 3)\n\n//@out DEFINES\n#define BAYER(row,col) \\\n\timage[((row) >> shrink)*iwidth + ((col) >> shrink)][FC(row,col)]\n\n#define BAYER2(row,col) \\\n\timage[((row) >> shrink)*iwidth + ((col) >> shrink)][fcol(row,col)]\n//@end DEFINES\n\n/* @out COMMON\n#include <math.h>\n#define CLASS LibRaw::\n#include \"libraw/libraw_types.h\"\n#define LIBRAW_LIBRARY_BUILD\n#define LIBRAW_IO_REDEFINED\n#include \"libraw/libraw.h\"\n#include \"internal/defines.h\"\n#include \"internal/var_defines.h\"\n#include \"internal/libraw_bytebuffer.h\"\n@end COMMON */\n\n//@out COMMON\nint CLASS fcol (int row, int col)\n{\n  static const char filter[16][16] =\n  { { 2,1,1,3,2,3,2,0,3,2,3,0,1,2,1,0 },\n    { 0,3,0,2,0,1,3,1,0,1,1,2,0,3,3,2 },\n    { 2,3,3,2,3,1,1,3,3,1,2,1,2,0,0,3 },\n    { 0,1,0,1,0,2,0,2,2,0,3,0,1,3,2,1 },\n    { 3,1,1,2,0,1,0,2,1,3,1,3,0,1,3,0 },\n    { 2,0,0,3,3,2,3,1,2,0,2,0,3,2,2,1 },\n    { 2,3,3,1,2,1,2,1,2,1,1,2,3,0,0,1 },\n    { 1,0,0,2,3,0,0,3,0,3,0,3,2,1,2,3 },\n    { 2,3,3,1,1,2,1,0,3,2,3,0,2,3,1,3 },\n    { 1,0,2,0,3,0,3,2,0,1,1,2,0,1,0,2 },\n    { 0,1,1,3,3,2,2,1,1,3,3,0,2,1,3,2 },\n    { 2,3,2,0,0,1,3,0,2,0,1,2,3,0,1,0 },\n    { 1,3,1,2,3,2,3,2,0,2,0,1,1,0,3,0 },\n    { 0,2,0,3,1,0,0,1,1,3,3,2,3,2,2,1 },\n    { 2,1,3,2,3,1,2,1,0,3,0,2,0,2,0,2 },\n    { 0,3,1,0,0,2,0,3,2,1,3,1,1,3,1,3 } };\n  static const char filter2[6][6] =\n  { { 1,1,0,1,1,2 },\n    { 1,1,2,1,1,0 },\n    { 2,0,1,0,2,1 },\n    { 1,1,2,1,1,0 },\n    { 1,1,0,1,1,2 },\n    { 0,2,1,2,0,1 } };\n\n  if (filters == 1) return filter[(row+top_margin)&15][(col+left_margin)&15];\n  if (filters == 2) return filter2[(row+6) % 6][(col+6) % 6];\n  return FC(row,col);\n}\n\n#ifndef __GLIBC__\nchar *my_memmem (char *haystack, size_t haystacklen,\n\t      char *needle, size_t needlelen)\n{\n  char *c;\n  for (c = haystack; c <= haystack + haystacklen - needlelen; c++)\n    if (!memcmp (c, needle, needlelen))\n      return c;\n  return 0;\n}\n#define memmem my_memmem\n#endif\n//@end COMMON\n\nvoid CLASS merror (void *ptr, const char *where)\n{\n  if (ptr) return;\n  fprintf (stderr,_(\"%s: Out of memory in %s\\n\"), ifname, where);\n  longjmp (failure, 1);\n}\n\nvoid CLASS derror()\n{\n  if (!data_error) {\n    fprintf (stderr, \"%s: \", ifname);\n    if (feof(ifp))\n      fprintf (stderr,_(\"Unexpected end of file\\n\"));\n    else\n      fprintf (stderr,_(\"Corrupt data near 0x%llx\\n\"), (INT64) ftello(ifp));\n  }\n  data_error++;\n}\n\n//@out COMMON\nushort CLASS sget2 (uchar *s)\n{\n  if (order == 0x4949)\t\t/* \"II\" means little-endian */\n    return s[0] | s[1] << 8;\n  else\t\t\t\t/* \"MM\" means big-endian */\n    return s[0] << 8 | s[1];\n}\n\nushort CLASS get2()\n{\n  uchar str[2] = { 0xff,0xff };\n  fread (str, 1, 2, ifp);\n  return sget2(str);\n}\n\nunsigned CLASS sget4 (uchar *s)\n{\n  if (order == 0x4949)\n    return s[0] | s[1] << 8 | s[2] << 16 | s[3] << 24;\n  else\n    return s[0] << 24 | s[1] << 16 | s[2] << 8 | s[3];\n}\n#define sget4(s) sget4((uchar *)s)\n\nunsigned CLASS get4()\n{\n  uchar str[4] = { 0xff,0xff,0xff,0xff };\n  fread (str, 1, 4, ifp);\n  return sget4(str);\n}\n\nunsigned CLASS getint (int type)\n{\n  return type == 3 ? get2() : get4();\n}\n\nfloat CLASS int_to_float (int i)\n{\n  union { int i; float f; } u;\n  u.i = i;\n  return u.f;\n}\n\ndouble CLASS getreal (int type)\n{\n  union { char c[8]; double d; } u;\n  int i, rev;\n\n  switch (type) {\n    case 3: return (unsigned short) get2();\n    case 4: return (unsigned int) get4();\n    case 5:  u.d = (unsigned int) get4();\n      return u.d / (unsigned int) get4();\n    case 8: return (signed short) get2();\n    case 9: return (signed int) get4();\n    case 10: u.d = (signed int) get4();\n      return u.d / (signed int) get4();\n    case 11: return int_to_float (get4());\n    case 12:\n      rev = 7 * ((order == 0x4949) == (ntohs(0x1234) == 0x1234));\n      for (i=0; i < 8; i++)\n\tu.c[i ^ rev] = fgetc(ifp);\n      return u.d;\n    default: return fgetc(ifp);\n  }\n}\n\nvoid CLASS read_shorts (ushort *pixel, int count)\n{\n  if (fread (pixel, 2, count, ifp) < count) derror();\n  if ((order == 0x4949) == (ntohs(0x1234) == 0x1234))\n    swab ((char*)pixel, (char*)pixel, count*2);\n}\n\nvoid CLASS canon_600_fixed_wb (int temp)\n{\n  static const short mul[4][5] = {\n    {  667, 358,397,565,452 },\n    {  731, 390,367,499,517 },\n    { 1119, 396,348,448,537 },\n    { 1399, 485,431,508,688 } };\n  int lo, hi, i;\n  float frac=0;\n\n  for (lo=4; --lo; )\n    if (*mul[lo] <= temp) break;\n  for (hi=0; hi < 3; hi++)\n    if (*mul[hi] >= temp) break;\n  if (lo != hi)\n    frac = (float) (temp - *mul[lo]) / (*mul[hi] - *mul[lo]);\n  for (i=1; i < 5; i++)\n    pre_mul[i-1] = 1 / (frac * mul[hi][i] + (1-frac) * mul[lo][i]);\n}\n\n/* Return values:  0 = white  1 = near white  2 = not white */\nint CLASS canon_600_color (int ratio[2], int mar)\n{\n  int clipped=0, target, miss;\n\n  if (flash_used) {\n    if (ratio[1] < -104)\n      { ratio[1] = -104; clipped = 1; }\n    if (ratio[1] >   12)\n      { ratio[1] =   12; clipped = 1; }\n  } else {\n    if (ratio[1] < -264 || ratio[1] > 461) return 2;\n    if (ratio[1] < -50)\n      { ratio[1] = -50; clipped = 1; }\n    if (ratio[1] > 307)\n      { ratio[1] = 307; clipped = 1; }\n  }\n  target = flash_used || ratio[1] < 197\n\t? -38 - (398 * ratio[1] >> 10)\n\t: -123 + (48 * ratio[1] >> 10);\n  if (target - mar <= ratio[0] &&\n      target + 20  >= ratio[0] && !clipped) return 0;\n  miss = target - ratio[0];\n  if (abs(miss) >= mar*4) return 2;\n  if (miss < -20) miss = -20;\n  if (miss > mar) miss = mar;\n  ratio[0] = target - miss;\n  return 1;\n}\n\nvoid CLASS canon_600_auto_wb()\n{\n  int mar, row, col, i, j, st, count[] = { 0,0 };\n  int test[8], total[2][8], ratio[2][2], stat[2];\n\n  memset (&total, 0, sizeof total);\n  i = canon_ev + 0.5;\n  if      (i < 10) mar = 150;\n  else if (i > 12) mar = 20;\n  else mar = 280 - 20 * i;\n  if (flash_used) mar = 80;\n  for (row=14; row < height-14; row+=4)\n    for (col=10; col < width; col+=2) {\n      for (i=0; i < 8; i++)\n\ttest[(i & 4) + FC(row+(i >> 1),col+(i & 1))] =\n\t\t    BAYER(row+(i >> 1),col+(i & 1));\n      for (i=0; i < 8; i++)\n\tif (test[i] < 150 || test[i] > 1500) goto next;\n      for (i=0; i < 4; i++)\n\tif (abs(test[i] - test[i+4]) > 50) goto next;\n      for (i=0; i < 2; i++) {\n\tfor (j=0; j < 4; j+=2)\n\t  ratio[i][j >> 1] = ((test[i*4+j+1]-test[i*4+j]) << 10) / test[i*4+j];\n\tstat[i] = canon_600_color (ratio[i], mar);\n      }\n      if ((st = stat[0] | stat[1]) > 1) goto next;\n      for (i=0; i < 2; i++)\n\tif (stat[i])\n\t  for (j=0; j < 2; j++)\n\t    test[i*4+j*2+1] = test[i*4+j*2] * (0x400 + ratio[i][j]) >> 10;\n      for (i=0; i < 8; i++)\n\ttotal[st][i] += test[i];\n      count[st]++;\nnext: ;\n    }\n  if (count[0] | count[1]) {\n    st = count[0]*200 < count[1];\n    for (i=0; i < 4; i++)\n      pre_mul[i] = 1.0 / (total[st][i] + total[st][i+4]);\n  }\n}\n\nvoid CLASS canon_600_coeff()\n{\n  static const short table[6][12] = {\n    { -190,702,-1878,2390,   1861,-1349,905,-393, -432,944,2617,-2105  },\n    { -1203,1715,-1136,1648, 1388,-876,267,245,  -1641,2153,3921,-3409 },\n    { -615,1127,-1563,2075,  1437,-925,509,3,     -756,1268,2519,-2007 },\n    { -190,702,-1886,2398,   2153,-1641,763,-251, -452,964,3040,-2528  },\n    { -190,702,-1878,2390,   1861,-1349,905,-393, -432,944,2617,-2105  },\n    { -807,1319,-1785,2297,  1388,-876,769,-257,  -230,742,2067,-1555  } };\n  int t=0, i, c;\n  float mc, yc;\n\n  mc = pre_mul[1] / pre_mul[2];\n  yc = pre_mul[3] / pre_mul[2];\n  if (mc > 1 && mc <= 1.28 && yc < 0.8789) t=1;\n  if (mc > 1.28 && mc <= 2) {\n    if  (yc < 0.8789) t=3;\n    else if (yc <= 2) t=4;\n  }\n  if (flash_used) t=5;\n  for (raw_color = i=0; i < 3; i++)\n    FORCC rgb_cam[i][c] = table[t][i*4 + c] / 1024.0;\n}\n\nvoid CLASS canon_600_load_raw()\n{\n  uchar  data[1120], *dp;\n  ushort *pix;\n  int irow, row;\n\n  for (irow=row=0; irow < height; irow++) {\n    if (fread (data, 1, 1120, ifp) < 1120) derror();\n    pix = raw_image + row*raw_width;\n    for (dp=data; dp < data+1120;  dp+=10, pix+=8) {\n      pix[0] = (dp[0] << 2) + (dp[1] >> 6    );\n      pix[1] = (dp[2] << 2) + (dp[1] >> 4 & 3);\n      pix[2] = (dp[3] << 2) + (dp[1] >> 2 & 3);\n      pix[3] = (dp[4] << 2) + (dp[1]      & 3);\n      pix[4] = (dp[5] << 2) + (dp[9]      & 3);\n      pix[5] = (dp[6] << 2) + (dp[9] >> 2 & 3);\n      pix[6] = (dp[7] << 2) + (dp[9] >> 4 & 3);\n      pix[7] = (dp[8] << 2) + (dp[9] >> 6    );\n    }\n    if ((row+=2) > height) row = 1;\n  }\n}\n\nvoid CLASS canon_600_correct()\n{\n  int row, col, val;\n  static const short mul[4][2] =\n  { { 1141,1145 }, { 1128,1109 }, { 1178,1149 }, { 1128,1109 } };\n\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++) {\n      if ((val = BAYER(row,col) - black) < 0) val = 0;\n      val = val * mul[row & 3][col & 1] >> 9;\n      BAYER(row,col) = val;\n    }\n  canon_600_fixed_wb(1311);\n  canon_600_auto_wb();\n  canon_600_coeff();\n  maximum = (0x3ff - black) * 1109 >> 9;\n  black = 0;\n}\n\nint CLASS canon_s2is()\n{\n  unsigned row;\n\n  for (row=0; row < 100; row++) {\n    fseek (ifp, row*3340 + 3284, SEEK_SET);\n    if (getc(ifp) > 15) return 1;\n  }\n  return 0;\n}\n\n/*\n   getbits(-1) initializes the buffer\n   getbits(n) where 0 <= n <= 25 returns an n-bit integer\n */\nunsigned CLASS getbithuff (int nbits, ushort *huff)\n{\n#ifdef LIBRAW_NOTHREADS\n  static unsigned bitbuf=0;\n  static int vbits=0, reset=0;\n#else\n#define bitbuf tls->getbits.bitbuf\n#define vbits  tls->getbits.vbits\n#define reset  tls->getbits.reset\n#endif\n  unsigned c;\n\n  if (nbits == -1)\n    return bitbuf = vbits = reset = 0;\n  if (nbits == 0 || vbits < 0) return 0;\n  while (!reset && vbits < nbits && (c = fgetc(ifp)) != EOF &&\n    !(reset = zero_after_ff && c == 0xff && fgetc(ifp))) {\n    bitbuf = (bitbuf << 8) + (uchar) c;\n    vbits += 8;\n  }\n  c = bitbuf << (32-vbits) >> (32-nbits);\n  if (huff) {\n    vbits -= huff[c] >> 8;\n    c = (uchar) huff[c];\n  } else\n    vbits -= nbits;\n  if (vbits < 0) derror();\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#undef reset\n#endif\n}\n\n#define getbits(n) getbithuff(n,0)\n#define gethuff(h) getbithuff(*h,h+1)\n\n/*\n   Construct a decode tree according the specification in *source.\n   The first 16 bytes specify how many codes should be 1-bit, 2-bit\n   3-bit, etc.  Bytes after that are the leaf values.\n\n   For example, if the source is\n\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,\n      0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },\n\n   then the code is\n\n\t00\t\t0x04\n\t010\t\t0x03\n\t011\t\t0x05\n\t100\t\t0x06\n\t101\t\t0x02\n\t1100\t\t0x07\n\t1101\t\t0x01\n\t11100\t\t0x08\n\t11101\t\t0x09\n\t11110\t\t0x00\n\t111110\t\t0x0a\n\t1111110\t\t0x0b\n\t1111111\t\t0xff\n */\nushort * CLASS make_decoder_ref (const uchar **source)\n{\n  int max, len, h, i, j;\n  const uchar *count;\n  ushort *huff;\n\n  count = (*source += 16) - 17;\n  for (max=16; max && !count[max]; max--);\n  huff = (ushort *) calloc (1 + (1 << max), sizeof *huff);\n  merror (huff, \"make_decoder()\");\n  huff[0] = max;\n  for (h=len=1; len <= max; len++)\n    for (i=0; i < count[len]; i++, ++*source)\n      for (j=0; j < 1 << (max-len); j++)\n\tif (h <= 1 << max)\n\t  huff[h++] = len << 8 | **source;\n  return huff;\n}\n\nushort * CLASS make_decoder (const uchar *source)\n{\n  return make_decoder_ref (&source);\n}\n\nvoid CLASS crw_init_tables (unsigned table, ushort *huff[2])\n{\n  static const uchar first_tree[3][29] = {\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,\n      0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },\n    { 0,2,2,3,1,1,1,1,2,0,0,0,0,0,0,0,\n      0x03,0x02,0x04,0x01,0x05,0x00,0x06,0x07,0x09,0x08,0x0a,0x0b,0xff  },\n    { 0,0,6,3,1,1,2,0,0,0,0,0,0,0,0,0,\n      0x06,0x05,0x07,0x04,0x08,0x03,0x09,0x02,0x00,0x0a,0x01,0x0b,0xff  },\n  };\n  static const uchar second_tree[3][180] = {\n    { 0,2,2,2,1,4,2,1,2,5,1,1,0,0,0,139,\n      0x03,0x04,0x02,0x05,0x01,0x06,0x07,0x08,\n      0x12,0x13,0x11,0x14,0x09,0x15,0x22,0x00,0x21,0x16,0x0a,0xf0,\n      0x23,0x17,0x24,0x31,0x32,0x18,0x19,0x33,0x25,0x41,0x34,0x42,\n      0x35,0x51,0x36,0x37,0x38,0x29,0x79,0x26,0x1a,0x39,0x56,0x57,\n      0x28,0x27,0x52,0x55,0x58,0x43,0x76,0x59,0x77,0x54,0x61,0xf9,\n      0x71,0x78,0x75,0x96,0x97,0x49,0xb7,0x53,0xd7,0x74,0xb6,0x98,\n      0x47,0x48,0x95,0x69,0x99,0x91,0xfa,0xb8,0x68,0xb5,0xb9,0xd6,\n      0xf7,0xd8,0x67,0x46,0x45,0x94,0x89,0xf8,0x81,0xd5,0xf6,0xb4,\n      0x88,0xb1,0x2a,0x44,0x72,0xd9,0x87,0x66,0xd4,0xf5,0x3a,0xa7,\n      0x73,0xa9,0xa8,0x86,0x62,0xc7,0x65,0xc8,0xc9,0xa1,0xf4,0xd1,\n      0xe9,0x5a,0x92,0x85,0xa6,0xe7,0x93,0xe8,0xc1,0xc6,0x7a,0x64,\n      0xe1,0x4a,0x6a,0xe6,0xb3,0xf1,0xd3,0xa5,0x8a,0xb2,0x9a,0xba,\n      0x84,0xa4,0x63,0xe5,0xc5,0xf3,0xd2,0xc4,0x82,0xaa,0xda,0xe4,\n      0xf2,0xca,0x83,0xa3,0xa2,0xc3,0xea,0xc2,0xe2,0xe3,0xff,0xff  },\n    { 0,2,2,1,4,1,4,1,3,3,1,0,0,0,0,140,\n      0x02,0x03,0x01,0x04,0x05,0x12,0x11,0x06,\n      0x13,0x07,0x08,0x14,0x22,0x09,0x21,0x00,0x23,0x15,0x31,0x32,\n      0x0a,0x16,0xf0,0x24,0x33,0x41,0x42,0x19,0x17,0x25,0x18,0x51,\n      0x34,0x43,0x52,0x29,0x35,0x61,0x39,0x71,0x62,0x36,0x53,0x26,\n      0x38,0x1a,0x37,0x81,0x27,0x91,0x79,0x55,0x45,0x28,0x72,0x59,\n      0xa1,0xb1,0x44,0x69,0x54,0x58,0xd1,0xfa,0x57,0xe1,0xf1,0xb9,\n      0x49,0x47,0x63,0x6a,0xf9,0x56,0x46,0xa8,0x2a,0x4a,0x78,0x99,\n      0x3a,0x75,0x74,0x86,0x65,0xc1,0x76,0xb6,0x96,0xd6,0x89,0x85,\n      0xc9,0xf5,0x95,0xb4,0xc7,0xf7,0x8a,0x97,0xb8,0x73,0xb7,0xd8,\n      0xd9,0x87,0xa7,0x7a,0x48,0x82,0x84,0xea,0xf4,0xa6,0xc5,0x5a,\n      0x94,0xa4,0xc6,0x92,0xc3,0x68,0xb5,0xc8,0xe4,0xe5,0xe6,0xe9,\n      0xa2,0xa3,0xe3,0xc2,0x66,0x67,0x93,0xaa,0xd4,0xd5,0xe7,0xf8,\n      0x88,0x9a,0xd7,0x77,0xc4,0x64,0xe2,0x98,0xa5,0xca,0xda,0xe8,\n      0xf3,0xf6,0xa9,0xb2,0xb3,0xf2,0xd2,0x83,0xba,0xd3,0xff,0xff  },\n    { 0,0,6,2,1,3,3,2,5,1,2,2,8,10,0,117,\n      0x04,0x05,0x03,0x06,0x02,0x07,0x01,0x08,\n      0x09,0x12,0x13,0x14,0x11,0x15,0x0a,0x16,0x17,0xf0,0x00,0x22,\n      0x21,0x18,0x23,0x19,0x24,0x32,0x31,0x25,0x33,0x38,0x37,0x34,\n      0x35,0x36,0x39,0x79,0x57,0x58,0x59,0x28,0x56,0x78,0x27,0x41,\n      0x29,0x77,0x26,0x42,0x76,0x99,0x1a,0x55,0x98,0x97,0xf9,0x48,\n      0x54,0x96,0x89,0x47,0xb7,0x49,0xfa,0x75,0x68,0xb6,0x67,0x69,\n      0xb9,0xb8,0xd8,0x52,0xd7,0x88,0xb5,0x74,0x51,0x46,0xd9,0xf8,\n      0x3a,0xd6,0x87,0x45,0x7a,0x95,0xd5,0xf6,0x86,0xb4,0xa9,0x94,\n      0x53,0x2a,0xa8,0x43,0xf5,0xf7,0xd4,0x66,0xa7,0x5a,0x44,0x8a,\n      0xc9,0xe8,0xc8,0xe7,0x9a,0x6a,0x73,0x4a,0x61,0xc7,0xf4,0xc6,\n      0x65,0xe9,0x72,0xe6,0x71,0x91,0x93,0xa6,0xda,0x92,0x85,0x62,\n      0xf3,0xc5,0xb2,0xa4,0x84,0xba,0x64,0xa5,0xb3,0xd2,0x81,0xe5,\n      0xd3,0xaa,0xc4,0xca,0xf2,0xb1,0xe4,0xd1,0x83,0x63,0xea,0xc3,\n      0xe2,0x82,0xf1,0xa3,0xc2,0xa1,0xc1,0xe3,0xa2,0xe1,0xff,0xff  }\n  };\n  if (table > 2) table = 2;\n  huff[0] = make_decoder ( first_tree[table]);\n  huff[1] = make_decoder (second_tree[table]);\n}\n\n/*\n   Return 0 if the image starts with compressed data,\n   1 if it starts with uncompressed low-order bits.\n\n   In Canon compressed data, 0xff is always followed by 0x00.\n */\nint CLASS canon_has_lowbits()\n{\n  uchar test[0x4000];\n  int ret=1, i;\n\n  fseek (ifp, 0, SEEK_SET);\n  fread (test, 1, sizeof test, ifp);\n  for (i=540; i < sizeof test - 1; i++)\n    if (test[i] == 0xff) {\n      if (test[i+1]) return 1;\n      ret=0;\n    }\n  return ret;\n}\n\nvoid CLASS canon_load_raw()\n{\n  ushort *pixel, *prow, *huff[2];\n  int nblocks, lowbits, i, c, row, r, save, val;\n  int block, diffbuf[64], leaf, len, diff, carry=0, pnum=0, base[2];\n\n  crw_init_tables (tiff_compress, huff);\n  lowbits = canon_has_lowbits();\n  if (!lowbits) maximum = 0x3ff;\n  fseek (ifp, 540 + lowbits*raw_height*raw_width/4, SEEK_SET);\n  zero_after_ff = 1;\n  getbits(-1);\n  for (row=0; row < raw_height; row+=8) {\n    pixel = raw_image + row*raw_width;\n    nblocks = MIN (8, raw_height-row) * raw_width >> 6;\n    for (block=0; block < nblocks; block++) {\n      memset (diffbuf, 0, sizeof diffbuf);\n      for (i=0; i < 64; i++ ) {\n\tleaf = gethuff(huff[i > 0]);\n\tif (leaf == 0 && i) break;\n\tif (leaf == 0xff) continue;\n\ti  += leaf >> 4;\n\tlen = leaf & 15;\n\tif (len == 0) continue;\n\tdiff = getbits(len);\n\tif ((diff & (1 << (len-1))) == 0)\n\t  diff -= (1 << len) - 1;\n\tif (i < 64) diffbuf[i] = diff;\n      }\n      diffbuf[0] += carry;\n      carry = diffbuf[0];\n      for (i=0; i < 64; i++ ) {\n\tif (pnum++ % raw_width == 0)\n\t  base[0] = base[1] = 512;\n\tif ((pixel[(block << 6) + i] = base[i & 1] += diffbuf[i]) >> 10)\n\t  derror();\n      }\n    }\n    if (lowbits) {\n      save = ftell(ifp);\n      fseek (ifp, 26 + row*raw_width/4, SEEK_SET);\n      for (prow=pixel, i=0; i < raw_width*2; i++) {\n\tc = fgetc(ifp);\n\tfor (r=0; r < 8; r+=2, prow++) {\n\t  val = (*prow << 2) + ((c >> r) & 3);\n\t  if (raw_width == 2672 && val < 512) val += 2;\n\t  *prow = val;\n\t}\n      }\n      fseek (ifp, save, SEEK_SET);\n    }\n  }\n  FORC(2) free (huff[c]);\n}\n//@end COMMON\n\n/*\n   Not a full implementation of Lossless JPEG, just\n   enough to decode Canon, Kodak and Adobe DNG images.\n */\nstruct jhead {\n  int bits, high, wide, clrs, sraw, psv, restart, vpred[6];\n  ushort *huff[6], *free[4], *row;\n};\n\n//@out COMMON\nint CLASS ljpeg_start (struct jhead *jh, int info_only)\n{\n  int c, tag, len;\n  uchar data[0x10000];\n  const uchar *dp;\n\n  memset (jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  fread (data, 2, 1, ifp);\n  if (data[1] != 0xd8) return 0;\n  do {\n    fread (data, 2, 2, ifp);\n    tag =  data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00) return 0;\n    fread (data, 1, len, ifp);\n    switch (tag) {\n      case 0xffc3:\n\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n      case 0xffc0:\n\tjh->bits = data[0];\n\tjh->high = data[1] << 8 | data[2];\n\tjh->wide = data[3] << 8 | data[4];\n\tjh->clrs = data[5] + jh->sraw;\n\tif (len == 9 && !dng_version) getc(ifp);\n\tbreak;\n      case 0xffc4:\n\tif (info_only) break;\n\tfor (dp = data; dp < data+len && (c = *dp++) < 4; )\n\t  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);\n\tbreak;\n      case 0xffda:\n\tjh->psv = data[1+data[0]*2];\n\tjh->bits -= data[3+data[0]*2] & 15;\n\tbreak;\n      case 0xffdd:\n\tjh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (info_only) return 1;\n  FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];\n  if (jh->sraw) {\n    FORC(4)        jh->huff[2+c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\n  }\n  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\n  merror (jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}\n\nvoid CLASS ljpeg_end (struct jhead *jh)\n{\n  int c;\n  FORC4 if (jh->free[c]) free (jh->free[c]);\n  free (jh->row);\n}\n\nint CLASS ljpeg_diff (ushort *huff)\n{\n  int len, diff;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!huff)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n  len = gethuff(huff);\n  if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n    return -32768;\n  diff = getbits(len);\n  if ((diff & (1 << (len-1))) == 0)\n    diff -= (1 << len) - 1;\n  return diff;\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\nint CLASS ljpeg_diff_new (LibRaw_bit_buffer& bits, LibRaw_byte_buffer* buf,ushort *huff)\n{\n  int len, diff;\n\n  if(!huff || !buf)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  len = bits._gethuff_lj(buf,*huff,huff+1);\n  if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n    return -32768;\n  diff = bits._getbits_lj(buf,len);\n  if ((diff & (1 << (len-1))) == 0)\n    diff -= (1 << len) - 1;\n  return diff;\n}\n\nushort * CLASS ljpeg_row_new (int jrow, struct jhead *jh, LibRaw_bit_buffer& bits,LibRaw_byte_buffer* bytes)\n{\n  int col, c, diff, pred, spred=0;\n  ushort mark=0, *row[3];\n\n  if (jrow * jh->wide % jh->restart == 0) {\n    FORC(6) jh->vpred[c] = 1 << (jh->bits-1);\n    if (jrow) {\n        bytes->unseek2();\n        do mark = (mark << 8) + (c = bytes->get_byte());\n        while (c != EOF && mark >> 4 != 0xffd);\n    }\n    bits.reset();\n  }\n  FORC3 row[c] = jh->row + jh->wide*jh->clrs*((jrow+c) & 1);\n  for (col=0; col < jh->wide; col++)\n    FORC(jh->clrs) {\n        diff = ljpeg_diff_new (bits,bytes,jh->huff[c]);\n      if (jh->sraw && c <= jh->sraw && (col | c))\n\t\t    pred = spred;\n      else if (col) pred = row[0][-jh->clrs];\n      else\t    pred = (jh->vpred[c] += diff) - diff;\n      if (jrow && col) switch (jh->psv) {\n\tcase 1:\tbreak;\n\tcase 2: pred = row[1][0];\t\t\t\t\tbreak;\n\tcase 3: pred = row[1][-jh->clrs];\t\t\t\tbreak;\n\tcase 4: pred = pred +   row[1][0] - row[1][-jh->clrs];\t\tbreak;\n\tcase 5: pred = pred + ((row[1][0] - row[1][-jh->clrs]) >> 1);\tbreak;\n\tcase 6: pred = row[1][0] + ((pred - row[1][-jh->clrs]) >> 1);\tbreak;\n\tcase 7: pred = (pred + row[1][0]) >> 1;\t\t\t\tbreak;\n\tdefault: pred = 0;\n      }\n      if ((**row = pred + diff) >> jh->bits) derror();\n      if (c <= jh->sraw) spred = **row;\n      row[0]++; row[1]++;\n    }\n  return row[2];\n}\n\n#endif\n\n\nushort * CLASS ljpeg_row (int jrow, struct jhead *jh)\n{\n  int col, c, diff, pred, spred=0;\n  ushort mark=0, *row[3];\n\n  if (jrow * jh->wide % jh->restart == 0) {\n    FORC(6) jh->vpred[c] = 1 << (jh->bits-1);\n    if (jrow) {\n      fseek (ifp, -2, SEEK_CUR);\n      do mark = (mark << 8) + (c = fgetc(ifp));\n      while (c != EOF && mark >> 4 != 0xffd);\n    }\n    getbits(-1);\n  }\n  FORC3 row[c] = jh->row + jh->wide*jh->clrs*((jrow+c) & 1);\n  for (col=0; col < jh->wide; col++)\n    FORC(jh->clrs) {\n      diff = ljpeg_diff (jh->huff[c]);\n      if (jh->sraw && c <= jh->sraw && (col | c))\n\t\t    pred = spred;\n      else if (col) pred = row[0][-jh->clrs];\n      else\t    pred = (jh->vpred[c] += diff) - diff;\n      if (jrow && col) switch (jh->psv) {\n\tcase 1:\tbreak;\n\tcase 2: pred = row[1][0];\t\t\t\t\tbreak;\n\tcase 3: pred = row[1][-jh->clrs];\t\t\t\tbreak;\n\tcase 4: pred = pred +   row[1][0] - row[1][-jh->clrs];\t\tbreak;\n\tcase 5: pred = pred + ((row[1][0] - row[1][-jh->clrs]) >> 1);\tbreak;\n\tcase 6: pred = row[1][0] + ((pred - row[1][-jh->clrs]) >> 1);\tbreak;\n\tcase 7: pred = (pred + row[1][0]) >> 1;\t\t\t\tbreak;\n\tdefault: pred = 0;\n      }\n      if ((**row = pred + diff) >> jh->bits) derror();\n      if (c <= jh->sraw) spred = **row;\n      row[0]++; row[1]++;\n    }\n  return row[2];\n}\n\nvoid CLASS lossless_jpeg_load_raw()\n{\n  int jwide, jrow, jcol, val, i, row=0, col=0;\n#ifndef LIBRAW_LIBRARY_BUILD\n  int jidx,j;\n#endif\n  struct jhead jh;\n  ushort *rp;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  int save_min = 0;\n  unsigned slicesW[16],slicesWcnt=0,slices;\n  unsigned *offset;\n  unsigned t_y=0,t_x=0,t_s=0,slice=0,pixelsInSlice,pixno;\n  if (!strcasecmp(make,\"KODAK\"))\n      save_min = 1;\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (cr2_slice[0]>15)\n      throw LIBRAW_EXCEPTION_IO_EOF; // change many slices\n#else\n  if (cr2_slice[0]>15)\n  {\n      fprintf(stderr,\"Too many CR2 slices: %d\\n\",cr2_slice[0]+1);\n      return;\n  }\n#endif\n\n  if (!ljpeg_start (&jh, 0)) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(jh.wide<1 || jh.high<1 || jh.clrs<1 || jh.bits <1)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  jwide = jh.wide * jh.clrs;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(cr2_slice[0])\n      {\n          for(i=0;i<cr2_slice[0];i++)\n              slicesW[slicesWcnt++] = cr2_slice[1];\n          slicesW[slicesWcnt++] = cr2_slice[2];\n      }\n  else\n      {\n          // not sliced\n          slicesW[slicesWcnt++] = raw_width; // safe fallback\n      }\n       \n  slices = slicesWcnt * jh.high;\n  if(!slices)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  offset = (unsigned*)calloc(slices+1,sizeof(offset[0]));\n\n  for(slice=0;slice<slices;slice++)\n      {\n          offset[slice] = (t_x + t_y * raw_width)| (t_s<<28);\n          if((offset[slice] & 0x0fffffff) >= raw_width * raw_height)\n            {\n              free(offset);\n              throw LIBRAW_EXCEPTION_IO_BADFILE; \n            }\n          t_y++;\n          if(t_y == jh.high)\n              {\n                  t_y = 0;\n                  t_x += slicesW[t_s++];\n              }\n      }\n  offset[slices] = offset[slices-1];\n  slice = 1; // next slice\n  pixno = offset[0]; \n  pixelsInSlice = slicesW[0];\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  LibRaw_byte_buffer *buf=NULL;\n  if(data_size)\n      buf = ifp->make_byte_buffer(data_size);\n  LibRaw_bit_buffer bits;\n#endif\n\n  for (jrow=0; jrow < jh.high; jrow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (buf)\n          rp = ljpeg_row_new (jrow, &jh,bits,buf);\n      else\n#endif\n    rp = ljpeg_row (jrow, &jh);\n    if (load_flags & 1)\n      row = jrow & 1 ? height-1-jrow/2 : jrow/2;\n    for (jcol=0; jcol < jwide; jcol++) {\n      val = curve[*rp++];\n#ifndef LIBRAW_LIBRARY_BUILD\n      // slow dcraw way to calculate row/col\n      if (cr2_slice[0]) {\n\tjidx = jrow*jwide + jcol;\n\ti = jidx / (cr2_slice[1]*jh.high);\n\tif ((j = i >= cr2_slice[0]))\n\t\t i  = cr2_slice[0];\n\tjidx -= i * (cr2_slice[1]*jh.high);\n\trow = jidx / cr2_slice[1+j];\n\tcol = jidx % cr2_slice[1+j] + i*cr2_slice[1];\n      }\n#else\n      // new fast one, but for data_size defined only (i.e. new CR2 format, not 1D/1Ds)\n      if(buf) \n          {\n              if(!(load_flags & 1))\n                  row = pixno/raw_width;\n              col = pixno % raw_width;\n              pixno++;\n              if (0 == --pixelsInSlice)\n                  {\n                    if(slice > slices)\n                      {\n                        free(offset);\n                        throw LIBRAW_EXCEPTION_IO_CORRUPT;\n                      }\n                      unsigned o = offset[slice++];\n                      pixno = o & 0x0fffffff;\n                      pixelsInSlice = slicesW[o>>28];\n                  }\n          }\n#endif\n\n      if(row>raw_height)\n#ifdef LIBRAW_LIBRARY_BUILD\n      {\n        free(offset);\n        throw LIBRAW_EXCEPTION_IO_CORRUPT;\n      }\n#else\n        longjmp (failure, 3);\n#endif\n      if (raw_width == 3984 && (col -= 2) < 0)\n\tcol += (row--,raw_width);\n      if (row >= 0) RAW(row,col) = val;\n#ifndef LIBRAW_LIBRARY_BUILD\n      if (++col >= raw_width)\n\tcol = (row++,0);\n#else\n      if(!buf) // 1D or 1Ds case\n         if (++col >= raw_width)\n            col = (row++,0);\n#endif\n    }\n  }\n  ljpeg_end (&jh);\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(buf)\n      delete buf;\n  free(offset);\n#endif\n}\n\nvoid CLASS canon_sraw_load_raw()\n{\n  struct jhead jh;\n  short *rp=0, (*ip)[4];\n  int jwide, slice, scol, ecol, row, col, jrow=0, jcol=0, pix[3], c;\n  int v[3]={0,0,0}, ver, hue;\n  char *cp;\n\n  if (!ljpeg_start (&jh, 0)) return;\n  jwide = (jh.wide >>= 1) * jh.clrs;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!data_size)\n      throw LIBRAW_EXCEPTION_IO_BADFILE;\n  LibRaw_byte_buffer *buf = ifp->make_byte_buffer(data_size);\n  LibRaw_bit_buffer bits;\n#endif\n\n  for (ecol=slice=0; slice <= cr2_slice[0]; slice++) {\n    scol = ecol;\n    ecol += cr2_slice[1] * 2 / jh.clrs;\n    if (!cr2_slice[0] || ecol > raw_width-1) ecol = raw_width & -2;\n    for (row=0; row < height; row += (jh.clrs >> 1) - 1) {\n      ip = (short (*)[4]) image + row*width;\n      for (col=scol; col < ecol; col+=2, jcol+=jh.clrs) {\n\tif ((jcol %= jwide) == 0)\n#ifdef LIBRAW_LIBRARY_BUILD\n            rp = (short*) ljpeg_row_new (jrow++, &jh,bits,buf);\n#else\n            rp = (short *) ljpeg_row (jrow++, &jh);\n#endif\n\tif (col >= width) continue;\n\tFORC (jh.clrs-2)\n\t  ip[col + (c >> 1)*width + (c & 1)][0] = rp[jcol+c];\n\tip[col][1] = rp[jcol+jh.clrs-2] - 16384;\n\tip[col][2] = rp[jcol+jh.clrs-1] - 16384;\n      }\n    }\n  }\n  for (cp=model2; *cp && !isdigit(*cp); cp++);\n  sscanf (cp, \"%d.%d.%d\", v, v+1, v+2);\n  ver = (v[0]*1000 + v[1])*1000 + v[2];\n  hue = (jh.sraw+1) << 2;\n  if (unique_id >= 0x80000281 || (unique_id == 0x80000218 && ver > 1000006))\n    hue = jh.sraw << 1;\n  ip = (short (*)[4]) image;\n  rp = ip[0];\n  for (row=0; row < height; row++, ip+=width) {\n    if (row & (jh.sraw >> 1))\n      for (col=0; col < width; col+=2)\n\tfor (c=1; c < 3; c++)\n\t  if (row == height-1)\n\t       ip[col][c] =  ip[col-width][c];\n\t  else ip[col][c] = (ip[col-width][c] + ip[col+width][c] + 1) >> 1;\n    for (col=1; col < width; col+=2)\n      for (c=1; c < 3; c++)\n\tif (col == width-1)\n\t     ip[col][c] =  ip[col-1][c];\n\telse ip[col][c] = (ip[col-1][c] + ip[col+1][c] + 1) >> 1;\n  }\n  for ( ; rp < ip[0]; rp+=4) {\n    if (unique_id == 0x80000218 ||\n\tunique_id == 0x80000250 ||\n\tunique_id == 0x80000261 ||\n\tunique_id == 0x80000281 ||\n\tunique_id == 0x80000287) {\n      rp[1] = (rp[1] << 2) + hue;\n      rp[2] = (rp[2] << 2) + hue;\n      pix[0] = rp[0] + ((   50*rp[1] + 22929*rp[2]) >> 14);\n      pix[1] = rp[0] + ((-5640*rp[1] - 11751*rp[2]) >> 14);\n      pix[2] = rp[0] + ((29040*rp[1] -   101*rp[2]) >> 14);\n    } else {\n      if (unique_id < 0x80000218) rp[0] -= 512;\n      pix[0] = rp[0] + rp[2];\n      pix[2] = rp[0] + rp[1];\n      pix[1] = rp[0] + ((-778*rp[1] - (rp[2] << 11)) >> 12);\n    }\n    FORC3 rp[c] = CLIP(pix[c] * sraw_mul[c] >> 10);\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  delete buf;\n#endif\n  ljpeg_end (&jh);\n  maximum = 0x3fff;\n}\n\n#ifndef LIBRAW_LIBRARY_BUILD\nvoid CLASS adobe_copy_pixel (unsigned row, unsigned col, ushort **rp)\n{\n  int c;\n\n  if (is_raw == 2 && shot_select) (*rp)++;\n  if (raw_image) {\n    if (row < raw_height && col < raw_width)\n      RAW(row,col) = curve[**rp];\n    *rp += is_raw;\n  } else {\n    if (row < height && col < width)\n      FORC(tiff_samples)\n\timage[row*width+col][c] = curve[(*rp)[c]];\n    *rp += tiff_samples;\n  }\n  if (is_raw == 2 && shot_select) (*rp)--;\n}\n#else\nvoid CLASS adobe_copy_pixel_raw (unsigned row, unsigned col, ushort **rp)\n{\n  if (is_raw == 2 && shot_select) (*rp)++;\n  if (row < raw_height && col < raw_width)\n    RAW(row,col) = curve[**rp];\n  *rp += is_raw;\n  if (is_raw == 2 && shot_select) (*rp)--;\n}\nvoid CLASS adobe_copy_pixel_color (unsigned row, unsigned col, ushort **rp)\n{\n  int c;\n\n  if (is_raw == 2 && shot_select) (*rp)++;\n  if (row < height && col < width)\n    FORC(tiff_samples)\n      image[row*width+col][c] = curve[(*rp)[c]];\n  *rp += tiff_samples;\n  if (is_raw == 2 && shot_select) (*rp)--;\n}\n#endif\n\n\nvoid CLASS lossless_dng_load_raw()\n{\n  unsigned save, trow=0, tcol=0, jwide, jrow, jcol, row, col;\n  struct jhead jh;\n  ushort *rp;\n\n  while (trow < raw_height) {\n    save = ftell(ifp);\n    if (tile_length < INT_MAX)\n      fseek (ifp, get4(), SEEK_SET);\n    if (!ljpeg_start (&jh, 0)) break;\n    jwide = jh.wide;\n    if (filters) jwide *= jh.clrs;\n    jwide /= is_raw;\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(!data_size)\n        throw LIBRAW_EXCEPTION_IO_BADFILE;\n    LibRaw_byte_buffer *buf = ifp->make_byte_buffer(data_size);\n    LibRaw_bit_buffer bits;\n#endif\n\n#ifndef LIBRAW_LIBRARY_BUILD\n    for (row=col=jrow=0; jrow < jh.high; jrow++) {\n      rp = ljpeg_row (jrow, &jh);\n      for (jcol=0; jcol < jwide; jcol++) {\n\tadobe_copy_pixel (trow+row, tcol+col, &rp);\n\tif (++col >= tile_width || col >= raw_width)\n\t  row += 1 + (col = 0);\n      }\n    }\n#else\n    if(raw_image)\n      {\n        for (row=col=jrow=0; jrow < jh.high; jrow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n          rp = ljpeg_row_new (jrow, &jh,bits,buf);\n#else\n          rp = ljpeg_row (jrow, &jh);\n#endif\n          for (jcol=0; jcol < jwide; jcol++) {\n            adobe_copy_pixel_raw (trow+row, tcol+col, &rp);\n            if (++col >= tile_width || col >= raw_width)\n              row += 1 + (col = 0);\n          }\n        }\n      }\n    else\n      {\n        for (row=col=jrow=0; jrow < jh.high; jrow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n          rp = ljpeg_row_new (jrow, &jh,bits,buf);\n#else\n          rp = ljpeg_row (jrow, &jh);\n#endif\n          for (jcol=0; jcol < jwide; jcol++) {\n            adobe_copy_pixel_color (trow+row, tcol+col, &rp);\n            if (++col >= tile_width || col >= raw_width)\n              row += 1 + (col = 0);\n          }\n        }\n      }\n#endif\n    fseek (ifp, save+4, SEEK_SET);\n    if ((tcol += tile_width) >= raw_width)\n      trow += tile_length + (tcol = 0);\n    ljpeg_end (&jh);\n#ifdef LIBRAW_LIBRARY_BUILD\n    delete buf;\n#endif\n  }\n}\n\nvoid CLASS packed_dng_load_raw()\n{\n  ushort *pixel, *rp;\n  int row, col;\n\n  pixel = (ushort *) calloc (raw_width * tiff_samples, sizeof *pixel);\n  merror (pixel, \"packed_dng_load_raw()\");\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  int dsz= raw_height*raw_width * tiff_samples * tiff_bps/8;\n  LibRaw_byte_buffer *buf = NULL;\n  if (tiff_bps != 16)\n      {\n          buf = ifp->make_byte_buffer(dsz);\n      }\n  LibRaw_bit_buffer bits;\n#endif\n\n  for (row=0; row < raw_height; row++) {\n    if (tiff_bps == 16)\n      read_shorts (pixel, raw_width * tiff_samples);\n    else {\n#ifdef LIBRAW_LIBRARY_BUILD\n        bits.reset();\n        for (col=0; col < raw_width * tiff_samples; col++)\n            pixel[col] = bits._getbits(buf,tiff_bps,zero_after_ff);\n\n#else\n      getbits(-1);\n      for (col=0; col < raw_width * tiff_samples; col++)\n\tpixel[col] = getbits(tiff_bps);\n#endif\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n    for (rp=pixel, col=0; col < raw_width; col++)\n      adobe_copy_pixel (row, col, &rp);\n#else\n    if(raw_image)\n      for (rp=pixel, col=0; col < raw_width; col++)\n        adobe_copy_pixel_raw (row, col, &rp);\n    else\n      for (rp=pixel, col=0; col < raw_width; col++)\n        adobe_copy_pixel_color (row, col, &rp);\n#endif\n  }\n  free (pixel);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(buf)\n        delete buf;\n#endif\n}\n\nvoid CLASS pentax_load_raw()\n{\n  ushort bit[2][15], huff[4097];\n  int dep, row, col, diff, c, i;\n  ushort vpred[2][2] = {{0,0},{0,0}}, hpred[2];\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  dep = (get2() + 12) & 15;\n  fseek (ifp, 12, SEEK_CUR);\n  FORC(dep) bit[0][c] = get2();\n  FORC(dep) bit[1][c] = fgetc(ifp);\n  FORC(dep)\n    for (i=bit[0][c]; i <= ((bit[0][c]+(4096 >> bit[1][c])-1) & 4095); )\n      huff[++i] = bit[1][c] << 8 | c;\n  huff[0] = 12;\n  fseek (ifp, data_offset, SEEK_SET);\n  getbits(-1);\n  for (row=0; row < raw_height; row++)\n    for (col=0; col < raw_width; col++) {\n      diff = ljpeg_diff (huff);\n      if (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n      else\t   hpred[col & 1] += diff;\n      RAW(row,col) = hpred[col & 1];\n      if (hpred[col & 1] >> tiff_bps) derror();\n    }\n}\n\nvoid CLASS nikon_load_raw()\n{\n  static const uchar nikon_tree[][32] = {\n    { 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,\t/* 12-bit lossy */\n      5,4,3,6,2,7,1,0,8,9,11,10,12 },\n    { 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,\t/* 12-bit lossy after split */\n      0x39,0x5a,0x38,0x27,0x16,5,4,3,2,1,0,11,12,12 },\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,  /* 12-bit lossless */\n      5,4,6,3,7,2,8,1,9,0,10,11,12 },\n    { 0,1,4,3,1,1,1,1,1,2,0,0,0,0,0,0,\t/* 14-bit lossy */\n      5,6,4,7,8,3,9,2,1,0,10,11,12,13,14 },\n    { 0,1,5,1,1,1,1,1,1,1,2,0,0,0,0,0,\t/* 14-bit lossy after split */\n      8,0x5c,0x4b,0x3a,0x29,7,6,5,4,3,2,1,0,13,14 },\n    { 0,1,4,2,2,3,1,2,0,0,0,0,0,0,0,0,\t/* 14-bit lossless */\n      7,6,8,5,9,4,10,3,11,12,2,0,1,13,14 } };\n  ushort *huff, ver0, ver1, vpred[2][2], hpred[2], csize;\n  int i, min, max, step=0, tree=0, split=0, row, col, len, shl, diff;\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  ver0 = fgetc(ifp);\n  ver1 = fgetc(ifp);\n  if (ver0 == 0x49 || ver1 == 0x58)\n    fseek (ifp, 2110, SEEK_CUR);\n  if (ver0 == 0x46) tree = 2;\n  if (tiff_bps == 14) tree += 3;\n  read_shorts (vpred[0], 4);\n  max = 1 << tiff_bps & 0x7fff;\n  if ((csize = get2()) > 1)\n    step = max / (csize-1);\n  if (ver0 == 0x44 && ver1 == 0x20 && step > 0) {\n    for (i=0; i < csize; i++)\n      curve[i*step] = get2();\n    for (i=0; i < max; i++)\n      curve[i] = ( curve[i-i%step]*(step-i%step) +\n\t\t   curve[i-i%step+step]*(i%step) ) / step;\n    fseek (ifp, meta_offset+562, SEEK_SET);\n    split = get2();\n  } else if (ver0 != 0x46 && csize <= 0x4001)\n    read_shorts (curve, max=csize);\n  while (curve[max-2] == curve[max-1]) max--;\n  huff = make_decoder (nikon_tree[tree]);\n  fseek (ifp, data_offset, SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!data_size)\n      throw LIBRAW_EXCEPTION_IO_BADFILE;\n  LibRaw_byte_buffer *buf = ifp->make_byte_buffer(data_size);\n  LibRaw_bit_buffer bits;\n  bits.reset();\n#else\n  getbits(-1);\n#endif\n  for (min=row=0; row < height; row++) {\n    if (split && row == split) {\n      free (huff);\n      huff = make_decoder (nikon_tree[tree+1]);\n      max += (min = 16) << 1;\n    }\n    for (col=0; col < raw_width; col++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n        i = bits._gethuff(buf,*huff,huff+1,zero_after_ff);\n#else\n      i = gethuff(huff);\n#endif\n      len = i & 15;\n      shl = i >> 4;\n#ifdef LIBRAW_LIBRARY_BUILD\n      diff = ((bits._getbits(buf,len-shl,zero_after_ff) << 1) + 1) << shl >> 1;\n#else\n      diff = ((getbits(len-shl) << 1) + 1) << shl >> 1;\n#endif\n      if ((diff & (1 << (len-1))) == 0)\n\tdiff -= (1 << len) - !shl;\n      if (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n      else\t   hpred[col & 1] += diff;\n      if ((ushort)(hpred[col & 1] + min) >= max) derror();\n      RAW(row,col) = curve[LIM((short)hpred[col & 1],0,0x3fff)];\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  delete buf;\n#endif\n  free (huff);\n}\n\n/*\n   Returns 1 for a Coolpix 995, 0 for anything else.\n */\nint CLASS nikon_e995()\n{\n  int i, histo[256];\n  const uchar often[] = { 0x00, 0x55, 0xaa, 0xff };\n\n  memset (histo, 0, sizeof histo);\n  fseek (ifp, -2000, SEEK_END);\n  for (i=0; i < 2000; i++)\n    histo[fgetc(ifp)]++;\n  for (i=0; i < 4; i++)\n    if (histo[often[i]] < 200)\n      return 0;\n  return 1;\n}\n\n/*\n   Returns 1 for a Coolpix 2100, 0 for anything else.\n */\nint CLASS nikon_e2100()\n{\n  uchar t[12];\n  int i;\n\n  fseek (ifp, 0, SEEK_SET);\n  for (i=0; i < 1024; i++) {\n    fread (t, 1, 12, ifp);\n    if (((t[2] & t[4] & t[7] & t[9]) >> 4\n\t& t[1] & t[6] & t[8] & t[11] & 3) != 3)\n      return 0;\n  }\n  return 1;\n}\n\nvoid CLASS nikon_3700()\n{\n  int bits, i;\n  uchar dp[24];\n  static const struct {\n    int bits;\n    char t_make[12], t_model[15];\n  } table[] = {\n    { 0x00, \"PENTAX\",  \"Optio 33WR\" },\n    { 0x03, \"NIKON\",   \"E3200\" },\n    { 0x32, \"NIKON\",   \"E3700\" },\n    { 0x33, \"OLYMPUS\", \"C740UZ\" } };\n\n  fseek (ifp, 3072, SEEK_SET);\n  fread (dp, 1, 24, ifp);\n  bits = (dp[8] & 3) << 4 | (dp[20] & 3);\n  for (i=0; i < sizeof table / sizeof *table; i++)\n    if (bits == table[i].bits) {\n      strcpy (make,  table[i].t_make );\n      strcpy (model, table[i].t_model);\n    }\n}\n\n/*\n   Separates a Minolta DiMAGE Z2 from a Nikon E4300.\n */\nint CLASS minolta_z2()\n{\n  int i, nz;\n  char tail[424];\n\n  fseek (ifp, -sizeof tail, SEEK_END);\n  fread (tail, 1, sizeof tail, ifp);\n  for (nz=i=0; i < sizeof tail; i++)\n    if (tail[i]) nz++;\n  return nz > 20;\n}\n//@end COMMON\n\nvoid CLASS jpeg_thumb();\n\n//@out COMMON\nvoid CLASS ppm_thumb()\n{\n  char *thumb;\n  thumb_length = thumb_width*thumb_height*3;\n  thumb = (char *) malloc (thumb_length);\n  merror (thumb, \"ppm_thumb()\");\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  fread  (thumb, 1, thumb_length, ifp);\n  fwrite (thumb, 1, thumb_length, ofp);\n  free (thumb);\n}\n\nvoid CLASS ppm16_thumb()\n{\n  int i;\n  char *thumb;\n  thumb_length = thumb_width*thumb_height*3;\n  thumb = (char *) calloc (thumb_length,2);\n  merror (thumb, \"ppm16_thumb()\");\n  read_shorts ((ushort *) thumb, thumb_length);\n  for (i=0; i < thumb_length; i++)\n    thumb[i] = ((ushort *) thumb)[i] >> 8;\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  fwrite (thumb, 1, thumb_length, ofp);\n  free (thumb);\n}\n\nvoid CLASS layer_thumb()\n{\n  int i, c;\n  char *thumb, map[][4] = { \"012\",\"102\" };\n\n  colors = thumb_misc >> 5 & 7;\n  thumb_length = thumb_width*thumb_height;\n  thumb = (char *) calloc (colors, thumb_length);\n  merror (thumb, \"layer_thumb()\");\n  fprintf (ofp, \"P%d\\n%d %d\\n255\\n\",\n\t5 + (colors >> 1), thumb_width, thumb_height);\n  fread (thumb, thumb_length, colors, ifp);\n  for (i=0; i < thumb_length; i++)\n    FORCC putc (thumb[i+thumb_length*(map[thumb_misc >> 8][c]-'0')], ofp);\n  free (thumb);\n}\n\nvoid CLASS rollei_thumb()\n{\n  unsigned i;\n  ushort *thumb;\n\n  thumb_length = thumb_width * thumb_height;\n  thumb = (ushort *) calloc (thumb_length, 2);\n  merror (thumb, \"rollei_thumb()\");\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  read_shorts (thumb, thumb_length);\n  for (i=0; i < thumb_length; i++) {\n    putc (thumb[i] << 3, ofp);\n    putc (thumb[i] >> 5  << 2, ofp);\n    putc (thumb[i] >> 11 << 3, ofp);\n  }\n  free (thumb);\n}\n\nvoid CLASS rollei_load_raw()\n{\n  uchar pixel[10];\n  unsigned iten=0, isix, i, buffer=0, todo[16];\n\n  isix = raw_width * raw_height * 5 / 8;\n  while (fread (pixel, 1, 10, ifp) == 10) {\n    for (i=0; i < 10; i+=2) {\n      todo[i]   = iten++;\n      todo[i+1] = pixel[i] << 8 | pixel[i+1];\n      buffer    = pixel[i] >> 2 | buffer << 6;\n    }\n    for (   ; i < 16; i+=2) {\n      todo[i]   = isix++;\n      todo[i+1] = buffer >> (14-i)*5;\n    }\n    for (i=0; i < 16; i+=2)\n      raw_image[todo[i]] = (todo[i+1] & 0x3ff);\n  }\n  maximum = 0x3ff;\n}\n\nint CLASS raw (unsigned row, unsigned col)\n{\n  return (row < raw_height && col < raw_width) ? RAW(row,col) : 0;\n}\n\nvoid CLASS phase_one_flat_field (int is_float, int nc)\n{\n  ushort head[8];\n  unsigned wide, y, x, c, rend, cend, row, col;\n  float *mrow, num, mult[4];\n\n  read_shorts (head, 8);\n  wide = head[2] / head[4];\n  mrow = (float *) calloc (nc*wide, sizeof *mrow);\n  merror (mrow, \"phase_one_flat_field()\");\n  for (y=0; y < head[3] / head[5]; y++) {\n    for (x=0; x < wide; x++)\n      for (c=0; c < nc; c+=2) {\n\tnum = is_float ? getreal(11) : get2()/32768.0;\n\tif (y==0) mrow[c*wide+x] = num;\n\telse mrow[(c+1)*wide+x] = (num - mrow[c*wide+x]) / head[5];\n      }\n    if (y==0) continue;\n    rend = head[1] + y*head[5];\n    for (row = rend-head[5]; row < raw_height && row < rend; row++) {\n      for (x=1; x < wide; x++) {\n\tfor (c=0; c < nc; c+=2) {\n\t  mult[c] = mrow[c*wide+x-1];\n\t  mult[c+1] = (mrow[c*wide+x] - mult[c]) / head[4];\n\t}\n\tcend = head[0] + x*head[4];\n\tfor (col = cend-head[4]; col < raw_width && col < cend; col++) {\n\t  c = nc > 2 ? FC(row-top_margin,col-left_margin) : 0;\n\t  if (!(c & 1)) {\n\t    c = RAW(row,col) * mult[c];\n\t    RAW(row,col) = LIM(c,0,65535);\n\t  }\n\t  for (c=0; c < nc; c+=2)\n\t    mult[c] += mult[c+1];\n\t}\n      }\n      for (x=0; x < wide; x++)\n\tfor (c=0; c < nc; c+=2)\n\t  mrow[c*wide+x] += mrow[(c+1)*wide+x];\n    }\n  }\n  free (mrow);\n}\n\nvoid CLASS phase_one_correct()\n{\n  unsigned entries, tag, data, save, col, row, type;\n  int len, i, j, k, cip, val[4], dev[4], sum, max;\n  int head[9], diff, mindiff=INT_MAX, off_412=0;\n  static const signed char dir[12][2] =\n    { {-1,-1}, {-1,1}, {1,-1}, {1,1}, {-2,0}, {0,-2}, {0,2}, {2,0},\n      {-2,-2}, {-2,2}, {2,-2}, {2,2} };\n  float poly[8], num, cfrac, frac, mult[2], *yval[2];\n  ushort *xval[2];\n\n  if (half_size || !meta_length) return;\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Phase One correction...\\n\"));\n#endif\n  fseek (ifp, meta_offset, SEEK_SET);\n  order = get2();\n  fseek (ifp, 6, SEEK_CUR);\n  fseek (ifp, meta_offset+get4(), SEEK_SET);\n  entries = get4();  get4();\n  while (entries--) {\n    tag  = get4();\n    len  = get4();\n    data = get4();\n    save = ftell(ifp);\n    fseek (ifp, meta_offset+data, SEEK_SET);\n    if (tag == 0x419) {\t\t\t\t/* Polynomial curve */\n      for (get4(), i=0; i < 8; i++)\n\tpoly[i] = getreal(11);\n      poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;\n      for (i=0; i < 0x10000; i++) {\n\tnum = (poly[5]*i + poly[3])*i + poly[1];\n\tcurve[i] = LIM(num,0,65535);\n      } goto apply;\t\t\t\t/* apply to right half */\n    } else if (tag == 0x41a) {\t\t\t/* Polynomial curve */\n      for (i=0; i < 4; i++)\n\tpoly[i] = getreal(11);\n      for (i=0; i < 0x10000; i++) {\n\tfor (num=0, j=4; j--; )\n\t  num = num * i + poly[j];\n\tcurve[i] = LIM(num+i,0,65535);\n      } apply:\t\t\t\t\t/* apply to whole image */\n      for (row=0; row < raw_height; row++)\n\tfor (col = (tag & 1)*ph1.split_col; col < raw_width; col++)\n\t  RAW(row,col) = curve[RAW(row,col)];\n    } else if (tag == 0x400) {\t\t\t/* Sensor defects */\n      while ((len -= 8) >= 0) {\n\tcol  = get2();\n\trow  = get2();\n\ttype = get2(); get2();\n\tif (col >= raw_width) continue;\n\tif (type == 131)\t\t\t/* Bad column */\n\t  for (row=0; row < raw_height; row++)\n\t    if (FC(row-top_margin,col-left_margin) == 1) {\n\t      for (sum=i=0; i < 4; i++)\n\t\tsum += val[i] = raw (row+dir[i][0], col+dir[i][1]);\n\t      for (max=i=0; i < 4; i++) {\n\t\tdev[i] = abs((val[i] << 2) - sum);\n\t\tif (dev[max] < dev[i]) max = i;\n\t      }\n\t      RAW(row,col) = (sum - val[max])/3.0 + 0.5;\n\t    } else {\n\t      for (sum=0, i=8; i < 12; i++)\n\t\tsum += raw (row+dir[i][0], col+dir[i][1]);\n\t      RAW(row,col) = 0.5 + sum * 0.0732233 +\n\t\t(raw(row,col-2) + raw(row,col+2)) * 0.3535534;\n\t    }\n\telse if (type == 129) {\t\t\t/* Bad pixel */\n\t  if (row >= raw_height) continue;\n\t  j = (FC(row-top_margin,col-left_margin) != 1) * 4;\n\t  for (sum=0, i=j; i < j+8; i++)\n\t    sum += raw (row+dir[i][0], col+dir[i][1]);\n\t  RAW(row,col) = (sum + 4) >> 3;\n\t}\n      }\n    } else if (tag == 0x401) {\t\t\t/* All-color flat fields */\n      phase_one_flat_field (1, 2);\n    } else if (tag == 0x416 || tag == 0x410) {\n      phase_one_flat_field (0, 2);\n    } else if (tag == 0x40b) {\t\t\t/* Red+blue flat field */\n      phase_one_flat_field (0, 4);\n    } else if (tag == 0x412) {\n      fseek (ifp, 36, SEEK_CUR);\n      diff = abs (get2() - ph1.tag_21a);\n      if (mindiff > diff) {\n\tmindiff = diff;\n\toff_412 = ftell(ifp) - 38;\n      }\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n  if (off_412) {\n    fseek (ifp, off_412, SEEK_SET);\n    for (i=0; i < 9; i++) head[i] = get4() & 0x7fff;\n    yval[0] = (float *) calloc (head[1]*head[3] + head[2]*head[4], 6);\n    merror (yval[0], \"phase_one_correct()\");\n    yval[1] = (float  *) (yval[0] + head[1]*head[3]);\n    xval[0] = (ushort *) (yval[1] + head[2]*head[4]);\n    xval[1] = (ushort *) (xval[0] + head[1]*head[3]);\n    get2();\n    for (i=0; i < 2; i++)\n      for (j=0; j < head[i+1]*head[i+3]; j++)\n\tyval[i][j] = getreal(11);\n    for (i=0; i < 2; i++)\n      for (j=0; j < head[i+1]*head[i+3]; j++)\n\txval[i][j] = get2();\n    for (row=0; row < raw_height; row++)\n      for (col=0; col < raw_width; col++) {\n\tcfrac = (float) col * head[3] / raw_width;\n\tcfrac -= cip = cfrac;\n\tnum = RAW(row,col) * 0.5;\n\tfor (i=cip; i < cip+2; i++) {\n\t  for (k=j=0; j < head[1]; j++)\n\t    if (num < xval[0][k = head[1]*i+j]) break;\n\t  frac = (j == 0 || j == head[1]) ? 0 :\n\t\t(xval[0][k] - num) / (xval[0][k] - xval[0][k-1]);\n\t  mult[i-cip] = yval[0][k-1] * frac + yval[0][k] * (1-frac);\n\t}\n\ti = ((mult[0] * (1-cfrac) + mult[1] * cfrac) * row + num) * 2;\n\tRAW(row,col) = LIM(i,0,65535);\n      }\n    free (yval[0]);\n  }\n}\n\nvoid CLASS phase_one_load_raw()\n{\n  int a, b, i;\n  ushort akey, bkey, t_mask;\n\n  fseek (ifp, ph1.key_off, SEEK_SET);\n  akey = get2();\n  bkey = get2();\n  t_mask = ph1.format == 1 ? 0x5555:0x1354;\n  fseek (ifp, data_offset, SEEK_SET);\n  read_shorts (raw_image, raw_width*raw_height);\n  if (ph1.format)\n    for (i=0; i < raw_width*raw_height; i+=2) {\n      a = raw_image[i+0] ^ akey;\n      b = raw_image[i+1] ^ bkey;\n      raw_image[i+0] = (a & t_mask) | (b & ~t_mask);\n      raw_image[i+1] = (b & t_mask) | (a & ~t_mask);\n    }\n}\n\nunsigned CLASS ph1_bithuff (int nbits, ushort *huff)\n{\n#ifndef LIBRAW_NOTHREADS\n#define bitbuf tls->ph1_bits.bitbuf\n#define vbits  tls->ph1_bits.vbits    \n#else\n  static UINT64 bitbuf=0;\n  static int vbits=0;\n#endif\n  unsigned c;\n\n  if (nbits == -1)\n    return bitbuf = vbits = 0;\n  if (nbits == 0) return 0;\n  if (vbits < nbits) {\n    bitbuf = bitbuf << 32 | get4();\n    vbits += 32;\n  }\n  c = bitbuf << (64-vbits) >> (64-nbits);\n  if (huff) {\n    vbits -= huff[c] >> 8;\n    return (uchar) huff[c];\n  }\n  vbits -= nbits;\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#endif\n}\n#define ph1_bits(n) ph1_bithuff(n,0)\n#define ph1_huff(h) ph1_bithuff(*h,h+1)\n\nvoid CLASS phase_one_load_raw_c()\n{\n  static const int length[] = { 8,7,6,9,11,10,5,12,14,13 };\n  int *offset, len[2], pred[2], row, col, i, j;\n  ushort *pixel;\n  short (*t_black)[2];\n\n  pixel = (ushort *) calloc (raw_width + raw_height*4, 2);\n  merror (pixel, \"phase_one_load_raw_c()\");\n  offset = (int *) (pixel + raw_width);\n  fseek (ifp, strip_offset, SEEK_SET);\n  for (row=0; row < raw_height; row++)\n    offset[row] = get4();\n  t_black = (short (*)[2]) offset + raw_height;\n  fseek (ifp, ph1.black_off, SEEK_SET);\n  if (ph1.black_off)\n      {\n          read_shorts ((ushort *) t_black[0], raw_height*2);\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.rawdata.ph1_black = (short (*)[2])calloc(raw_height*2,sizeof(short));\n          merror (imgdata.rawdata.ph1_black, \"phase_one_load_raw_c()\");\n          memmove(imgdata.rawdata.ph1_black,(short *) t_black[0],raw_height*2*sizeof(short));\n#endif\n      }\n  for (i=0; i < 256; i++)\n    curve[i] = i*i / 3.969 + 0.5;\n  for (row=0; row < raw_height; row++) {\n    fseek (ifp, data_offset + offset[row], SEEK_SET);\n    ph1_bits(-1);\n    pred[0] = pred[1] = 0;\n    for (col=0; col < raw_width; col++) {\n      if (col >= (raw_width & -8))\n\tlen[0] = len[1] = 14;\n      else if ((col & 7) == 0)\n\tfor (i=0; i < 2; i++) {\n\t  for (j=0; j < 5 && !ph1_bits(1); j++);\n\t  if (j--) len[i] = length[j*2 + ph1_bits(1)];\n\t}\n      if ((i = len[col & 1]) == 14)\n\tpixel[col] = pred[col & 1] = ph1_bits(16);\n      else\n\tpixel[col] = pred[col & 1] += ph1_bits(i) + 1 - (1 << (i - 1));\n      if (pred[col & 1] >> 16) derror();\n      if (ph1.format == 5 && pixel[col] < 256)\n\tpixel[col] = curve[pixel[col]];\n    }\n    for (col=0; col < raw_width; col++) {\n#ifndef LIBRAW_LIBRARY_BUILD\n      i = (pixel[col] << 2) - ph1.t_black + t_black[row][col >= ph1.split_col];\n      if (i > 0) RAW(row,col) = i;\n#else\n      RAW(row,col) = pixel[col] << 2;\n#endif\n    }\n  }\n  free (pixel);\n  maximum = 0xfffc - ph1.t_black;\n}\n\nvoid CLASS hasselblad_load_raw()\n{\n  struct jhead jh;\n  int row, col, pred[2], len[2], diff, c;\n\n  if (!ljpeg_start (&jh, 0)) return;\n  order = 0x4949;\n  ph1_bits(-1);\n  for (row=0; row < raw_height; row++) {\n    pred[0] = pred[1] = 0x8000 + load_flags;\n    for (col=0; col < raw_width; col+=2) {\n      FORC(2) len[c] = ph1_huff(jh.huff[0]);\n      FORC(2) {\n\tdiff = ph1_bits(len[c]);\n\tif ((diff & (1 << (len[c]-1))) == 0)\n\t  diff -= (1 << len[c]) - 1;\n\tif (diff == 65535) diff = -32768;\n\tRAW(row,col+c) = pred[c] += diff;\n      }\n    }\n  }\n  ljpeg_end (&jh);\n  maximum = 0xffff;\n}\n\nvoid CLASS leaf_hdr_load_raw()\n{\n  ushort *pixel=0;\n  unsigned tile=0, r, c, row, col;\n\n  if (!filters) {\n    pixel = (ushort *) calloc (raw_width, sizeof *pixel);\n    merror (pixel, \"leaf_hdr_load_raw()\");\n  }\n  FORC(tiff_samples)\n    for (r=0; r < raw_height; r++) {\n      if (r % tile_length == 0) {\n\tfseek (ifp, data_offset + 4*tile++, SEEK_SET);\n\tfseek (ifp, get4(), SEEK_SET);\n      }\n      if (filters && c != shot_select) continue;\n      if (filters) pixel = raw_image + r*raw_width;\n      read_shorts (pixel, raw_width);\n      if (!filters && (row = r - top_margin) < height)\n\tfor (col=0; col < width; col++)\n\t  image[row*width+col][c] = pixel[col+left_margin];\n    }\n  if (!filters) {\n    maximum = 0xffff;\n    raw_color = 1;\n    free (pixel);\n  }\n}\n\nvoid CLASS unpacked_load_raw()\n{\n  int row, col, bits=0;\n\n  while (1 << ++bits < maximum);\n  read_shorts (raw_image, raw_width*raw_height);\n  for (row=0; row < raw_height; row++)\n    for (col=0; col < raw_width; col++)\n      if ((RAW(row,col) >>= load_flags) >> bits\n\t&& (unsigned) (row-top_margin) < height\n\t&& (unsigned) (col-left_margin) < width) derror();\n}\n\nvoid CLASS sinar_4shot_load_raw()\n{\n  ushort *pixel;\n  unsigned shot, row, col, r, c;\n\n  if ((shot = shot_select) || half_size) {\n    if (shot) shot--;\n    if (shot > 3) shot = 3;\n    fseek (ifp, data_offset + shot*4, SEEK_SET);\n    fseek (ifp, get4(), SEEK_SET);\n    unpacked_load_raw();\n    return;\n  }\n#ifndef LIBRAW_LIBRARY_BUILD\n  free (raw_image);\n  raw_image = 0;\n  free (image);\n  image = (ushort (*)[4])\n\tcalloc ((iheight=height)*(iwidth=width), sizeof *image);\n  merror (image, \"sinar_4shot_load_raw()\");\n#endif\n  pixel = (ushort *) calloc (raw_width, sizeof *pixel);\n  merror (pixel, \"sinar_4shot_load_raw()\");\n  for (shot=0; shot < 4; shot++) {\n    fseek (ifp, data_offset + shot*4, SEEK_SET);\n    fseek (ifp, get4(), SEEK_SET);\n    for (row=0; row < raw_height; row++) {\n      read_shorts (pixel, raw_width);\n      if ((r = row-top_margin - (shot >> 1 & 1)) >= height) continue;\n      for (col=0; col < raw_width; col++) {\n\tif ((c = col-left_margin - (shot & 1)) >= width) continue;\n\timage[r*width+c][FC(row,col)] = pixel[col];\n      }\n    }\n  }\n  free (pixel);\n  shrink = filters = 0;\n}\n\nvoid CLASS imacon_full_load_raw()\n{\n  int row, col;\n\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      read_shorts (image[row*width+col], 3);\n}\n\nvoid CLASS packed_load_raw()\n{\n  int vbits=0, bwide, pwide, rbits, bite, half, irow, row, col, val, i;\n  UINT64 bitbuf=0;\n\n  if (raw_width * 8 >= width * tiff_bps)\t/* Is raw_width in bytes? */\n       pwide = (bwide = raw_width) * 8 / tiff_bps;\n  else bwide = (pwide = raw_width) * tiff_bps / 8;\n  rbits = bwide * 8 - pwide * tiff_bps;\n  if (load_flags & 1) bwide = bwide * 16 / 15;\n  bite = 8 + (load_flags & 24);\n  half = (raw_height+1) >> 1;\n  for (irow=0; irow < raw_height; irow++) {\n    row = irow;\n    if (load_flags & 2 &&\n\t(row = irow % half * 2 + irow / half) == 1 &&\n\tload_flags & 4) {\n      if (vbits=0, tiff_compress)\n\tfseek (ifp, data_offset - (-half*bwide & -2048), SEEK_SET);\n      else {\n\tfseek (ifp, 0, SEEK_END);\n\tfseek (ifp, ftell(ifp) >> 3 << 2, SEEK_SET);\n      }\n    }\n    for (col=0; col < pwide; col++) {\n      for (vbits -= tiff_bps; vbits < 0; vbits += bite) {\n\tbitbuf <<= bite;\n\tfor (i=0; i < bite; i+=8)\n\t  bitbuf |= (unsigned) (fgetc(ifp) << i);\n      }\n      val = bitbuf << (64-tiff_bps-vbits) >> (64-tiff_bps);\n      RAW(row,col ^ (load_flags >> 6)) = val;\n      if (load_flags & 1 && (col % 10) == 9 &&\n\tfgetc(ifp) && col < width+left_margin) derror();\n    }\n    vbits -= rbits;\n  }\n}\n\nvoid CLASS nokia_load_raw()\n{\n  uchar  *data,  *dp;\n  int rev, dwide, row, col, c;\n\n  rev = 3 * (order == 0x4949);\n  dwide = (raw_width * 5 +1) / 4;\n  data = (uchar *) malloc (dwide*2);\n  merror (data, \"nokia_load_raw()\");\n  for (row=0; row < raw_height; row++) {\n    if (fread (data+dwide, 1, dwide, ifp) < dwide) derror();\n    FORC(dwide) data[c] = data[dwide+(c ^ rev)];\n    for (dp=data, col=0; col < raw_width; dp+=5, col+=4)\n      FORC4 RAW(row,col+c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n  }\n  free (data);\n  maximum = 0x3ff;\n}\n\nunsigned CLASS pana_bits (int nbits)\n{\n#ifndef LIBRAW_NOTHREADS\n#define buf tls->pana_bits.buf\n#define vbits tls->pana_bits.vbits   \n#else\n  static uchar buf[0x4000];\n  static int vbits;\n#endif\n  int byte;\n\n  if (!nbits) return vbits=0;\n  if (!vbits) {\n    fread (buf+load_flags, 1, 0x4000-load_flags, ifp);\n    fread (buf, 1, load_flags, ifp);\n  }\n  vbits = (vbits - nbits) & 0x1ffff;\n  byte = vbits >> 3 ^ 0x3ff0;\n  return (buf[byte] | buf[byte+1] << 8) >> (vbits & 7) & ~(-1 << nbits);\n#ifndef LIBRAW_NOTHREADS\n#undef buf\n#undef vbits\n#endif\n}\n\nvoid CLASS panasonic_load_raw()\n{\n  int row, col, i, j, sh=0, pred[2], nonz[2];\n\n  pana_bits(0);\n  for (row=0; row < height; row++)\n    for (col=0; col < raw_width; col++) {\n      if ((i = col % 14) == 0)\n\tpred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n      if (i % 3 == 2) sh = 4 >> (3 - pana_bits(2));\n      if (nonz[i & 1]) {\n\tif ((j = pana_bits(8))) {\n\t  if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)\n\t       pred[i & 1] &= ~(-1 << sh);\n\t  pred[i & 1] += j << sh;\n\t}\n      } else if ((nonz[i & 1] = pana_bits(8)) || i > 11)\n\tpred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);\n      if ((RAW(row,col) = pred[col & 1]) > 4098 && col < width) derror();\n    }\n}\n\nvoid CLASS olympus_load_raw()\n{\n  ushort huff[4096];\n  int row, col, nbits, sign, low, high, i, c, w, n, nw;\n  int acarry[2][3], *carry, pred, diff;\n\n  huff[n=0] = 0xc0c;\n  for (i=12; i--; )\n    FORC(2048 >> i) huff[++n] = (i+1) << 8 | i;\n  fseek (ifp, 7, SEEK_CUR);\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!data_size)\n      throw LIBRAW_EXCEPTION_IO_BADFILE;\n  LibRaw_byte_buffer *buf = ifp->make_byte_buffer(data_size);\n  LibRaw_bit_buffer bits;\n  bits.reset();\n#else\n  getbits(-1);\n#endif\n  for (row=0; row < height; row++) {\n    memset (acarry, 0, sizeof acarry);\n    for (col=0; col < raw_width; col++) {\n      carry = acarry[col & 1];\n      i = 2 * (carry[2] < 3);\n      for (nbits=2+i; (ushort) carry[0] >> (nbits+i); nbits++);\n#ifdef LIBRAW_LIBRARY_BUILD\n      low = (sign = bits._getbits(buf,3,zero_after_ff)) & 3;\n      sign = sign << 29 >> 31;\n      if ((high = bits._gethuff(buf,12,huff,zero_after_ff)) == 12)\n          high = bits._getbits(buf,16-nbits,zero_after_ff) >> 1;\n      carry[0] = (high << nbits) | bits._getbits(buf,nbits,zero_after_ff);\n#else\n      low = (sign = getbits(3)) & 3;\n      sign = sign << 29 >> 31;\n      if ((high = getbithuff(12,huff)) == 12)\n\thigh = getbits(16-nbits) >> 1;\n      carry[0] = (high << nbits) | getbits(nbits);\n#endif\n      diff = (carry[0] ^ sign) + carry[1];\n      carry[1] = (diff*3 + carry[1]) >> 5;\n      carry[2] = carry[0] > 16 ? 0 : carry[2]+1;\n      if (col >= width) continue;\n      if (row < 2 && col < 2) pred = 0;\n      else if (row < 2) pred = RAW(row,col-2);\n      else if (col < 2) pred = RAW(row-2,col);\n      else {\n\tw  = RAW(row,col-2);\n\tn  = RAW(row-2,col);\n\tnw = RAW(row-2,col-2);\n\tif ((w < nw && nw < n) || (n < nw && nw < w)) {\n\t  if (ABS(w-nw) > 32 || ABS(n-nw) > 32)\n\t    pred = w + n - nw;\n\t  else pred = (w + n) >> 1;\n\t} else pred = ABS(w-nw) > ABS(n-nw) ? w : n;\n      }\n      if ((RAW(row,col) = pred + ((diff << 2) | low)) >> 12) derror();\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  delete buf;\n#endif\n}\n\nvoid CLASS minolta_rd175_load_raw()\n{\n  uchar pixel[768];\n  unsigned irow, box, row, col;\n\n  for (irow=0; irow < 1481; irow++) {\n    if (fread (pixel, 1, 768, ifp) < 768) derror();\n    box = irow / 82;\n    row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box-12)*2);\n    switch (irow) {\n      case 1477: case 1479: continue;\n      case 1476: row = 984; break;\n      case 1480: row = 985; break;\n      case 1478: row = 985; box = 1;\n    }\n    if ((box < 12) && (box & 1)) {\n      for (col=0; col < 1533; col++, row ^= 1)\n\tif (col != 1) RAW(row,col) = (col+1) & 2 ?\n\t\t   pixel[col/2-1] + pixel[col/2+1] : pixel[col/2] << 1;\n      RAW(row,1)    = pixel[1]   << 1;\n      RAW(row,1533) = pixel[765] << 1;\n    } else\n      for (col=row & 1; col < 1534; col+=2)\n\tRAW(row,col) = pixel[col/2] << 1;\n  }\n  maximum = 0xff << 1;\n}\n\nvoid CLASS quicktake_100_load_raw()\n{\n  uchar pixel[484][644];\n  static const short gstep[16] =\n  { -89,-60,-44,-32,-22,-15,-8,-2,2,8,15,22,32,44,60,89 };\n  static const short rstep[6][4] =\n  { {  -3,-1,1,3  }, {  -5,-1,1,5  }, {  -8,-2,2,8  },\n    { -13,-3,3,13 }, { -19,-4,4,19 }, { -28,-6,6,28 } };\n  static const short t_curve[256] =\n  { 0,1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,\n    28,29,30,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,53,\n    54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,74,75,76,77,78,\n    79,80,81,82,83,84,86,88,90,92,94,97,99,101,103,105,107,110,112,114,116,\n    118,120,123,125,127,129,131,134,136,138,140,142,144,147,149,151,153,155,\n    158,160,162,164,166,168,171,173,175,177,179,181,184,186,188,190,192,195,\n    197,199,201,203,205,208,210,212,214,216,218,221,223,226,230,235,239,244,\n    248,252,257,261,265,270,274,278,283,287,291,296,300,305,309,313,318,322,\n    326,331,335,339,344,348,352,357,361,365,370,374,379,383,387,392,396,400,\n    405,409,413,418,422,426,431,435,440,444,448,453,457,461,466,470,474,479,\n    483,487,492,496,500,508,519,531,542,553,564,575,587,598,609,620,631,643,\n    654,665,676,687,698,710,721,732,743,754,766,777,788,799,810,822,833,844,\n    855,866,878,889,900,911,922,933,945,956,967,978,989,1001,1012,1023 };\n  int rb, row, col, sharp, val=0;\n\n  getbits(-1);\n  memset (pixel, 0x80, sizeof pixel);\n  for (row=2; row < height+2; row++) {\n    for (col=2+(row & 1); col < width+2; col+=2) {\n      val = ((pixel[row-1][col-1] + 2*pixel[row-1][col+1] +\n\t\tpixel[row][col-2]) >> 2) + gstep[getbits(4)];\n      pixel[row][col] = val = LIM(val,0,255);\n      if (col < 4)\n\tpixel[row][col-2] = pixel[row+1][~row & 1] = val;\n      if (row == 2)\n\tpixel[row-1][col+1] = pixel[row-1][col+3] = val;\n    }\n    pixel[row][col] = val;\n  }\n  for (rb=0; rb < 2; rb++)\n    for (row=2+rb; row < height+2; row+=2)\n      for (col=3-(row & 1); col < width+2; col+=2) {\n\tif (row < 4 || col < 4) sharp = 2;\n\telse {\n\t  val = ABS(pixel[row-2][col] - pixel[row][col-2])\n\t      + ABS(pixel[row-2][col] - pixel[row-2][col-2])\n\t      + ABS(pixel[row][col-2] - pixel[row-2][col-2]);\n\t  sharp = val <  4 ? 0 : val <  8 ? 1 : val < 16 ? 2 :\n\t\t  val < 32 ? 3 : val < 48 ? 4 : 5;\n\t}\n\tval = ((pixel[row-2][col] + pixel[row][col-2]) >> 1)\n\t      + rstep[sharp][getbits(2)];\n\tpixel[row][col] = val = LIM(val,0,255);\n\tif (row < 4) pixel[row-2][col+2] = val;\n\tif (col < 4) pixel[row+2][col-2] = val;\n      }\n  for (row=2; row < height+2; row++)\n    for (col=3-(row & 1); col < width+2; col+=2) {\n      val = ((pixel[row][col-1] + (pixel[row][col] << 2) +\n\t      pixel[row][col+1]) >> 1) - 0x100;\n      pixel[row][col] = LIM(val,0,255);\n    }\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      RAW(row,col) = t_curve[pixel[row+2][col+2]];\n  maximum = 0x3ff;\n}\n\n#define radc_token(tree) ((signed char) getbithuff(8,huff[tree]))\n\n#define FORYX for (y=1; y < 3; y++) for (x=col+1; x >= col; x--)\n\n#define PREDICTOR (c ? (buf[c][y-1][x] + buf[c][y][x+1]) / 2 \\\n: (buf[c][y-1][x+1] + 2*buf[c][y-1][x] + buf[c][y][x+1]) / 4)\n\n#ifdef __GNUC__\n# if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)\n# pragma GCC optimize(\"no-aggressive-loop-optimizations\")\n# endif\n#endif\n\nvoid CLASS kodak_radc_load_raw()\n{\n  static const char src[] = {\n    1,1, 2,3, 3,4, 4,2, 5,7, 6,5, 7,6, 7,8,\n    1,0, 2,1, 3,3, 4,4, 5,2, 6,7, 7,6, 8,5, 8,8,\n    2,1, 2,3, 3,0, 3,2, 3,4, 4,6, 5,5, 6,7, 6,8,\n    2,0, 2,1, 2,3, 3,2, 4,4, 5,6, 6,7, 7,5, 7,8,\n    2,1, 2,4, 3,0, 3,2, 3,3, 4,7, 5,5, 6,6, 6,8,\n    2,3, 3,1, 3,2, 3,4, 3,5, 3,6, 4,7, 5,0, 5,8,\n    2,3, 2,6, 3,0, 3,1, 4,4, 4,5, 4,7, 5,2, 5,8,\n    2,4, 2,7, 3,3, 3,6, 4,1, 4,2, 4,5, 5,0, 5,8,\n    2,6, 3,1, 3,3, 3,5, 3,7, 3,8, 4,0, 5,2, 5,4,\n    2,0, 2,1, 3,2, 3,3, 4,4, 4,5, 5,6, 5,7, 4,8,\n    1,0, 2,2, 2,-2,\n    1,-3, 1,3,\n    2,-17, 2,-5, 2,5, 2,17,\n    2,-7, 2,2, 2,9, 2,18,\n    2,-18, 2,-9, 2,-2, 2,7,\n    2,-28, 2,28, 3,-49, 3,-9, 3,9, 4,49, 5,-79, 5,79,\n    2,-1, 2,13, 2,26, 3,39, 4,-16, 5,55, 6,-37, 6,76,\n    2,-26, 2,-13, 2,1, 3,-39, 4,16, 5,-55, 6,-76, 6,37\n  };\n  ushort huff[19][256];\n  int row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;\n  short last[3] = { 16,16,16 }, mul[3], buf[3][3][386];\n  static const ushort pt[] =\n    { 0,0, 1280,1344, 2320,3616, 3328,8000, 4095,16383, 65535,16383 };\n\n  for (i=2; i < 12; i+=2)\n    for (c=pt[i-2]; c <= pt[i]; c++)\n      curve[c] = (float)\n\t(c-pt[i-2]) / (pt[i]-pt[i-2]) * (pt[i+1]-pt[i-1]) + pt[i-1] + 0.5;\n  for (s=i=0; i < sizeof src; i+=2)\n    FORC(256 >> src[i])\n      huff[0][s++] = src[i] << 8 | (uchar) src[i+1];\n  s = kodak_cbpp == 243 ? 2 : 3;\n  FORC(256) huff[18][c] = (8-s) << 8 | c >> s << s | 1 << (s-1);\n  getbits(-1);\n  for (i=0; i < sizeof(buf)/sizeof(short); i++)\n    buf[0][0][i] = 2048;\n  for (row=0; row < height; row+=4) {\n    FORC3 mul[c] = getbits(6);\n    FORC3 {\n      val = ((0x1000000/last[c] + 0x7ff) >> 12) * mul[c];\n      s = val > 65564 ? 10:12;\n      x = ~(-1 << (s-1));\n      val <<= 12-s;\n      for (i=0; i < sizeof(buf[0])/sizeof(short); i++)\n\tbuf[c][0][i] = (buf[c][0][i] * val + x) >> s;\n      last[c] = mul[c];\n      for (r=0; r <= !c; r++) {\n\tbuf[c][1][width/2] = buf[c][2][width/2] = mul[c] << 7;\n\tfor (tree=1, col=width/2; col > 0; ) {\n\t  if ((tree = radc_token(tree))) {\n\t    col -= 2;\n\t    if (tree == 8)\n\t      FORYX buf[c][y][x] = (uchar) radc_token(18) * mul[c];\n\t    else\n\t      FORYX buf[c][y][x] = radc_token(tree+10) * 16 + PREDICTOR;\n\t  } else\n\t    do {\n\t      nreps = (col > 2) ? radc_token(9) + 1 : 1;\n\t      for (rep=0; rep < 8 && rep < nreps && col > 0; rep++) {\n\t\tcol -= 2;\n\t\tFORYX buf[c][y][x] = PREDICTOR;\n\t\tif (rep & 1) {\n\t\t  step = radc_token(10) << 4;\n\t\t  FORYX buf[c][y][x] += step;\n\t\t}\n\t      }\n\t    } while (nreps == 9);\n\t}\n\tfor (y=0; y < 2; y++)\n\t  for (x=0; x < width/2; x++) {\n\t    val = (buf[c][y+1][x] << 4) / mul[c];\n\t    if (val < 0) val = 0;\n\t    if (c) RAW(row+y*2+c-1,x*2+2-c) = val;\n\t    else   RAW(row+r*2+y,x*2+y) = val;\n\t  }\n\tmemcpy (buf[c][0]+!c, buf[c][2], sizeof buf[c][0]-2*!c);\n      }\n    }\n    for (y=row; y < row+4; y++)\n      for (x=0; x < width; x++)\n\tif ((x+y) & 1) {\n\t  r = x ? x-1 : x+1;\n\t  s = x+1 < width ? x+1 : x-1;\n\t  val = (RAW(y,x)-2048)*2 + (RAW(y,r)+RAW(y,s))/2;\n\t  if (val < 0) val = 0;\n\t  RAW(y,x) = val;\n\t}\n  }\n  for (i=0; i < height*width; i++)\n    raw_image[i] = curve[raw_image[i]];\n  maximum = 0x3fff;\n}\n\n#undef FORYX\n#undef PREDICTOR\n\n#ifdef NO_JPEG\nvoid CLASS kodak_jpeg_load_raw() {}\nvoid CLASS lossy_dng_load_raw() {}\n#else\n\n#ifdef LIBRAW_LIBRARY_BUILD\nvoid CLASS kodak_jpeg_load_raw() {}\n#else\n\nMETHODDEF(boolean)\nfill_input_buffer (j_decompress_ptr cinfo)\n{\n#ifndef LIBRAW_NOTHREADS\n#define jpeg_buffer tls->jpeg_buffer\n#else\n  static uchar jpeg_buffer[4096];\n#endif\n  size_t nbytes;\n\n  nbytes = fread (jpeg_buffer, 1, 4096, ifp);\n  swab (jpeg_buffer, jpeg_buffer, nbytes);\n  cinfo->src->next_input_byte = jpeg_buffer;\n  cinfo->src->bytes_in_buffer = nbytes;\n  return TRUE;\n#ifndef LIBRAW_NOTHREADS\n#undef jpeg_buffer\n#endif\n}\n\nvoid CLASS kodak_jpeg_load_raw()\n{\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  JSAMPARRAY buf;\n  JSAMPLE (*pixel)[3];\n  int row, col;\n\n  cinfo.err = jpeg_std_error (&jerr);\n  jpeg_create_decompress (&cinfo);\n  jpeg_stdio_src (&cinfo, ifp);\n  cinfo.src->fill_input_buffer = fill_input_buffer;\n  jpeg_read_header (&cinfo, TRUE);\n  jpeg_start_decompress (&cinfo);\n  if ((cinfo.output_width      != width  ) ||\n      (cinfo.output_height*2   != height ) ||\n      (cinfo.output_components != 3      )) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s: incorrect JPEG dimensions\\n\"), ifname);\n#endif\n    jpeg_destroy_decompress (&cinfo);\n#ifdef LIBRAW_LIBRARY_BUILD\n    throw LIBRAW_EXCEPTION_DECODE_JPEG;\n#else\n    longjmp (failure, 3);\n#endif\n  }\n  buf = (*cinfo.mem->alloc_sarray)\n\t\t((j_common_ptr) &cinfo, JPOOL_IMAGE, width*3, 1);\n\n  while (cinfo.output_scanline < cinfo.output_height) {\n    row = cinfo.output_scanline * 2;\n    jpeg_read_scanlines (&cinfo, buf, 1);\n    pixel = (JSAMPLE (*)[3]) buf[0];\n    for (col=0; col < width; col+=2) {\n      RAW(row+0,col+0) = pixel[col+0][1] << 1;\n      RAW(row+1,col+1) = pixel[col+1][1] << 1;\n      RAW(row+0,col+1) = pixel[col][0] + pixel[col+1][0];\n      RAW(row+1,col+0) = pixel[col][2] + pixel[col+1][2];\n    }\n  }\n  jpeg_finish_decompress (&cinfo);\n  jpeg_destroy_decompress (&cinfo);\n  maximum = 0xff << 1;\n}\n#endif\n\nvoid CLASS lossy_dng_load_raw()\n{\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  JSAMPARRAY buf;\n  JSAMPLE (*pixel)[3];\n  unsigned sorder=order, ntags, opcode, deg, i, j, c;\n  unsigned save=data_offset-4, trow=0, tcol=0, row, col;\n  ushort t_curve[3][256];\n  double coeff[9], tot;\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  order = 0x4d4d;\n  ntags = get4();\n  while (ntags--) {\n    opcode = get4(); get4(); get4();\n    if (opcode != 8)\n    { fseek (ifp, get4(), SEEK_CUR); continue; }\n    fseek (ifp, 20, SEEK_CUR);\n    if ((c = get4()) > 2) break;\n    fseek (ifp, 12, SEEK_CUR);\n    if ((deg = get4()) > 8) break;\n    for (i=0; i <= deg && i < 9; i++)\n      coeff[i] = getreal(12);\n    for (i=0; i < 256; i++) {\n      for (tot=j=0; j <= deg; j++)\n\ttot += coeff[j] * pow(i/255.0, (int)j);\n      t_curve[c][i] = tot*0xffff;\n    }\n  }\n  order = sorder;\n  cinfo.err = jpeg_std_error (&jerr);\n  jpeg_create_decompress (&cinfo);\n  while (trow < raw_height) {\n    fseek (ifp, save+=4, SEEK_SET);\n    if (tile_length < INT_MAX)\n      fseek (ifp, get4(), SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(libraw_internal_data.internal_data.input->jpeg_src(&cinfo) == -1)\n      {\n        jpeg_destroy_decompress(&cinfo);\n        throw LIBRAW_EXCEPTION_DECODE_JPEG;\n      }\n#else\n    jpeg_stdio_src (&cinfo, ifp);\n#endif\n    jpeg_read_header (&cinfo, TRUE);\n    jpeg_start_decompress (&cinfo);\n    buf = (*cinfo.mem->alloc_sarray)\n\t((j_common_ptr) &cinfo, JPOOL_IMAGE, cinfo.output_width*3, 1);\n    while (cinfo.output_scanline < cinfo.output_height &&\n\t(row = trow + cinfo.output_scanline) < height) {\n      jpeg_read_scanlines (&cinfo, buf, 1);\n      pixel = (JSAMPLE (*)[3]) buf[0];\n      for (col=0; col < cinfo.output_width && tcol+col < width; col++) {\n\tFORC3 image[row*width+tcol+col][c] = t_curve[c][pixel[col][c]];\n      }\n    }\n    jpeg_abort_decompress (&cinfo);\n    if ((tcol += tile_width) >= raw_width)\n      trow += tile_length + (tcol = 0);\n  }\n  jpeg_destroy_decompress (&cinfo);\n  maximum = 0xffff;\n}\n#endif\n\nvoid CLASS kodak_dc120_load_raw()\n{\n  static const int mul[4] = { 162, 192, 187,  92 };\n  static const int add[4] = {   0, 636, 424, 212 };\n  uchar pixel[848];\n  int row, shift, col;\n\n  for (row=0; row < height; row++) {\n    if (fread (pixel, 1, 848, ifp) < 848) derror();\n    shift = row * mul[row & 3] + add[row & 3];\n    for (col=0; col < width; col++)\n      RAW(row,col) = (ushort) pixel[(col + shift) % 848];\n  }\n  maximum = 0xff;\n}\n\nvoid CLASS eight_bit_load_raw()\n{\n  uchar *pixel;\n  unsigned row, col;\n\n  pixel = (uchar *) calloc (raw_width, sizeof *pixel);\n  merror (pixel, \"eight_bit_load_raw()\");\n  for (row=0; row < raw_height; row++) {\n    if (fread (pixel, 1, raw_width, ifp) < raw_width) derror();\n    for (col=0; col < raw_width; col++)\n      RAW(row,col) = curve[pixel[col]];\n  }\n  free (pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_yrgb_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *) calloc (raw_width, 3*sizeof *pixel);\n  merror (pixel, \"kodak_yrgb_load_raw()\");\n  for (row=0; row < height; row++) {\n    if (~row & 1)\n      if (fread (pixel, raw_width, 3, ifp) < 3) derror();\n    for (col=0; col < raw_width; col++) {\n      y  = pixel[width*2*(row & 1) + col];\n      cb = pixel[width + (col & -2)]   - 128;\n      cr = pixel[width + (col & -2)+1] - 128;\n      rgb[1] = y-((cb + cr + 2) >> 2);\n      rgb[2] = rgb[1] + cb;\n      rgb[0] = rgb[1] + cr;\n      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];\n    }\n  }\n  free (pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_262_load_raw()\n{\n  static const uchar kodak_tree[2][26] =\n  { { 0,1,5,1,1,2,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 },\n    { 0,3,1,1,1,1,1,2,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 } };\n  ushort *huff[2];\n  uchar *pixel;\n  int *strip, ns, c, row, col, chess, pi=0, pi1, pi2, pred, val;\n\n  FORC(2) huff[c] = make_decoder (kodak_tree[c]);\n  ns = (raw_height+63) >> 5;\n  pixel = (uchar *) malloc (raw_width*32 + ns*4);\n  merror (pixel, \"kodak_262_load_raw()\");\n  strip = (int *) (pixel + raw_width*32);\n  order = 0x4d4d;\n  FORC(ns) strip[c] = get4();\n  for (row=0; row < raw_height; row++) {\n    if ((row & 31) == 0) {\n      fseek (ifp, strip[row >> 5], SEEK_SET);\n      getbits(-1);\n      pi = 0;\n    }\n    for (col=0; col < raw_width; col++) {\n      chess = (row + col) & 1;\n      pi1 = chess ? pi-2           : pi-raw_width-1;\n      pi2 = chess ? pi-2*raw_width : pi-raw_width+1;\n      if (col <= chess) pi1 = -1;\n      if (pi1 < 0) pi1 = pi2;\n      if (pi2 < 0) pi2 = pi1;\n      if (pi1 < 0 && col > 1) pi1 = pi2 = pi-2;\n      pred = (pi1 < 0) ? 0 : (pixel[pi1] + pixel[pi2]) >> 1;\n      pixel[pi] = val = pred + ljpeg_diff (huff[chess]);\n      if (val >> 8) derror();\n      val = curve[pixel[pi++]];\n      RAW(row,col) = val;\n    }\n  }\n  free (pixel);\n  FORC(2) free (huff[c]);\n}\n\nint CLASS kodak_65000_decode (short *out, int bsize)\n{\n  uchar c, blen[768];\n  ushort raw[6];\n  INT64 bitbuf=0;\n  int save, bits=0, i, j, len, diff;\n\n  save = ftell(ifp);\n  bsize = (bsize + 3) & -4;\n  for (i=0; i < bsize; i+=2) {\n    c = fgetc(ifp);\n    if ((blen[i  ] = c & 15) > 12 ||\n\t(blen[i+1] = c >> 4) > 12 ) {\n      fseek (ifp, save, SEEK_SET);\n      for (i=0; i < bsize; i+=8) {\n\tread_shorts (raw, 6);\n\tout[i  ] = raw[0] >> 12 << 8 | raw[2] >> 12 << 4 | raw[4] >> 12;\n\tout[i+1] = raw[1] >> 12 << 8 | raw[3] >> 12 << 4 | raw[5] >> 12;\n\tfor (j=0; j < 6; j++)\n\t  out[i+2+j] = raw[j] & 0xfff;\n      }\n      return 1;\n    }\n  }\n  if ((bsize & 7) == 4) {\n    bitbuf  = fgetc(ifp) << 8;\n    bitbuf += fgetc(ifp);\n    bits = 16;\n  }\n  for (i=0; i < bsize; i++) {\n    len = blen[i];\n    if (bits < len) {\n      for (j=0; j < 32; j+=8)\n\tbitbuf += (INT64) fgetc(ifp) << (bits+(j^8));\n      bits += 32;\n    }\n    diff = bitbuf & (0xffff >> (16-len));\n    bitbuf >>= len;\n    bits -= len;\n    if ((diff & (1 << (len-1))) == 0)\n      diff -= (1 << len) - 1;\n    out[i] = diff;\n  }\n  return 0;\n}\n\nvoid CLASS kodak_65000_load_raw()\n{\n  short buf[256];\n  int row, col, len, pred[2], ret, i;\n\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col+=256) {\n      pred[0] = pred[1] = 0;\n      len = MIN (256, width-col);\n      ret = kodak_65000_decode (buf, len);\n      for (i=0; i < len; i++)\n\tif ((RAW(row,col+i) =\tcurve[ret ? buf[i] :\n\t\t(pred[i & 1] += buf[i])]) >> 12) derror();\n    }\n}\n\nvoid CLASS kodak_ycbcr_load_raw()\n{\n  short buf[384], *bp;\n  int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n  ushort *ip;\n\n  for (row=0; row < height; row+=2)\n    for (col=0; col < width; col+=128) {\n      len = MIN (128, width-col);\n      kodak_65000_decode (buf, len*3);\n      y[0][1] = y[1][1] = cb = cr = 0;\n      for (bp=buf, i=0; i < len; i+=2, bp+=2) {\n\tcb += bp[4];\n\tcr += bp[5];\n\trgb[1] = -((cb + cr + 2) >> 2);\n\trgb[2] = rgb[1] + cb;\n\trgb[0] = rgb[1] + cr;\n\tfor (j=0; j < 2; j++)\n\t  for (k=0; k < 2; k++) {\n\t    if ((y[j][k] = y[j][k^1] + *bp++) >> 10) derror();\n\t    ip = image[(row+j)*width + col+i+k];\n\t    FORC3 ip[c] = curve[LIM(y[j][k]+rgb[c], 0, 0xfff)];\n\t  }\n      }\n    }\n}\n\nvoid CLASS kodak_rgb_load_raw()\n{\n  short buf[768], *bp;\n  int row, col, len, c, i, rgb[3];\n  ushort *ip=image[0];\n\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (raw_image) free (raw_image);\n  raw_image = 0;\n#endif\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col+=256) {\n      len = MIN (256, width-col);\n      kodak_65000_decode (buf, len*3);\n      memset (rgb, 0, sizeof rgb);\n      for (bp=buf, i=0; i < len; i++, ip+=4)\n\tFORC3 if ((ip[c] = rgb[c] += *bp++) >> 12) derror();\n    }\n}\n\nvoid CLASS kodak_thumb_load_raw()\n{\n  int row, col;\n  colors = thumb_misc >> 5;\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      read_shorts (image[row*width+col], colors);\n  maximum = (1 << (thumb_misc & 31)) - 1;\n}\n\nvoid CLASS sony_decrypt (unsigned *data, int len, int start, int key)\n{\n#ifndef LIBRAW_NOTHREADS\n#define pad tls->sony_decrypt.pad\n#define p   tls->sony_decrypt.p\n#else\n  static unsigned pad[128], p;\n#endif\n  if (start) {\n    for (p=0; p < 4; p++)\n      pad[p] = key = key * 48828125 + 1;\n    pad[3] = pad[3] << 1 | (pad[0]^pad[2]) >> 31;\n    for (p=4; p < 127; p++)\n      pad[p] = (pad[p-4]^pad[p-2]) << 1 | (pad[p-3]^pad[p-1]) >> 31;\n    for (p=0; p < 127; p++)\n      pad[p] = htonl(pad[p]);\n  }\n#if 1 // Avoid gcc 4.8 bug\n  while (len--)\n    {\n      *data++ ^= pad[p & 127] = pad[(p+1) & 127] ^ pad[(p+65) & 127];\n      p++;     \n    }\n#else\n  while (len--)\n    *data++ ^= pad[p++ & 127] = pad[(p+1) & 127] ^ pad[(p+65) & 127];\n#endif\n#ifndef LIBRAW_NOTHREADS\n#undef pad\n#undef p\n#endif\n}\n\nvoid CLASS sony_load_raw()\n{\n  uchar head[40];\n  ushort *pixel;\n  unsigned i, key, row, col;\n\n  fseek (ifp, 200896, SEEK_SET);\n  fseek (ifp, (unsigned) fgetc(ifp)*4 - 1, SEEK_CUR);\n  order = 0x4d4d;\n  key = get4();\n  fseek (ifp, 164600, SEEK_SET);\n  fread (head, 1, 40, ifp);\n  sony_decrypt ((unsigned int *) head, 10, 1, key);\n  for (i=26; i-- > 22; )\n    key = key << 8 | head[i];\n  fseek (ifp, data_offset, SEEK_SET);\n  for (row=0; row < raw_height; row++) {\n    pixel = raw_image + row*raw_width;\n    if (fread (pixel, 2, raw_width, ifp) < raw_width) derror();\n    sony_decrypt ((unsigned int *) pixel, raw_width/2, !row, key);\n    for (col=0; col < raw_width; col++)\n      if ((pixel[col] = ntohs(pixel[col])) >> 14) derror();\n  }\n  maximum = 0x3ff0;\n}\n\nvoid CLASS sony_arw_load_raw()\n{\n  ushort huff[32768];\n  static const ushort tab[18] =\n  { 0xf11,0xf10,0xe0f,0xd0e,0xc0d,0xb0c,0xa0b,0x90a,0x809,\n    0x708,0x607,0x506,0x405,0x304,0x303,0x300,0x202,0x201 };\n  int i, c, n, col, row, len, diff, sum=0;\n\n  for (n=i=0; i < 18; i++)\n    FORC(32768 >> (tab[i] >> 8)) huff[n++] = tab[i];\n#ifdef LIBRAW_LIBRARY_BUILD\n  LibRaw_byte_buffer *buf=NULL;\n  if(data_size)\n      buf = ifp->make_byte_buffer(data_size);\n  else\n      getbits(-1);\n      \n  LibRaw_bit_buffer bits;\n  bits.reset();\n#else\n  getbits(-1);\n#endif\n  for (col = raw_width; col--; )\n    for (row=0; row < raw_height+1; row+=2) {\n      if (row == raw_height) row = 1;\n#ifdef LIBRAW_LIBRARY_BUILD\n      if(data_size)\n          {\n              len = bits._gethuff(buf,15,huff,zero_after_ff);\n              diff = bits._getbits(buf,len,zero_after_ff);\n          }\n      else\n          {\n              len = getbithuff(15,huff);\n              diff = getbits(len);\n          }\n#else\n      len = getbithuff(15,huff);\n      diff = getbits(len);\n#endif\n      if ((diff & (1 << (len-1))) == 0)\n\tdiff -= (1 << len) - 1;\n      if ((sum += diff) >> 12) derror();\n      if (row < height) RAW(row,col) = sum;\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(buf) delete buf;\n#endif\n}\n\nvoid CLASS sony_arw2_load_raw()\n{\n  uchar *data, *dp;\n  ushort pix[16];\n  int row, col, val, max, min, imax, imin, sh, bit, i;\n\n  data = (uchar *) malloc (raw_width);\n  merror (data, \"sony_arw2_load_raw()\");\n  for (row=0; row < height; row++) {\n    fread (data, 1, raw_width, ifp);\n    for (dp=data, col=0; col < raw_width-30; dp+=16) {\n      max = 0x7ff & (val = sget4(dp));\n      min = 0x7ff & val >> 11;\n      imax = 0x0f & val >> 22;\n      imin = 0x0f & val >> 26;\n      for (sh=0; sh < 4 && 0x80 << sh <= max-min; sh++);\n      for (bit=30, i=0; i < 16; i++)\n\tif      (i == imax) pix[i] = max;\n\telse if (i == imin) pix[i] = min;\n\telse {\n\t  pix[i] = ((sget2(dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n\t  if (pix[i] > 0x7ff) pix[i] = 0x7ff;\n\t  bit += 7;\n\t}\n#ifdef LIBRAW_LIBRARY_BUILD\n      if(imgdata.params.sony_arw2_hack)\n          {\n              for (i=0; i < 16; i++, col+=2)\n                  RAW(row,col) = curve[pix[i] << 1];\n          }\n      else\n          {\n              for (i=0; i < 16; i++, col+=2)\n                  RAW(row,col) = curve[pix[i] << 1] >> 2;\n          }\n#else\n      for (i=0; i < 16; i++, col+=2)\n\tRAW(row,col) = curve[pix[i] << 1] >> 2;\n#endif\n      col -= col & 1 ? 1:31;\n    }\n  }\n  free (data);\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(imgdata.params.sony_arw2_hack)\n  {\n\tblack <<= 2;\n\tmaximum <<=2;\n  }\n#endif\n}\n\n#define HOLE(row) ((holes >> (((row) - raw_height) & 7)) & 1)\n\n/* Kudos to Rich Taylor for figuring out SMaL's compression algorithm. */\nvoid CLASS smal_decode_segment (unsigned seg[2][2], int holes)\n{\n  uchar hist[3][13] = {\n    { 7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0 },\n    { 7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0 },\n    { 3, 3, 0, 0, 63,     47,     31,     15,    0 } };\n  int low, high=0xff, carry=0, nbits=8;\n  int pix, s, count, bin, next, i, sym[3];\n  uchar diff, pred[]={0,0};\n  ushort data=0, range=0;\n\n  fseek (ifp, seg[0][1]+1, SEEK_SET);\n  getbits(-1);\n  for (pix=seg[0][0]; pix < seg[1][0]; pix++) {\n    for (s=0; s < 3; s++) {\n      data = data << nbits | getbits(nbits);\n      if (carry < 0)\n\tcarry = (nbits += carry+1) < 1 ? nbits-1 : 0;\n      while (--nbits >= 0)\n\tif ((data >> nbits & 0xff) == 0xff) break;\n      if (nbits > 0)\n\t  data = ((data & ((1 << (nbits-1)) - 1)) << 1) |\n\t((data + (((data & (1 << (nbits-1)))) << 1)) & (-1 << nbits));\n      if (nbits >= 0) {\n\tdata += getbits(1);\n\tcarry = nbits - 8;\n      }\n      count = ((((data-range+1) & 0xffff) << 2) - 1) / (high >> 4);\n      for (bin=0; hist[s][bin+5] > count; bin++);\n\t\tlow = hist[s][bin+5] * (high >> 4) >> 2;\n      if (bin) high = hist[s][bin+4] * (high >> 4) >> 2;\n      high -= low;\n      for (nbits=0; high << nbits < 128; nbits++);\n      range = (range+low) << nbits;\n      high <<= nbits;\n      next = hist[s][1];\n      if (++hist[s][2] > hist[s][3]) {\n\tnext = (next+1) & hist[s][0];\n\thist[s][3] = (hist[s][next+4] - hist[s][next+5]) >> 2;\n\thist[s][2] = 1;\n      }\n      if (hist[s][hist[s][1]+4] - hist[s][hist[s][1]+5] > 1) {\n\tif (bin < hist[s][1])\n\t  for (i=bin; i < hist[s][1]; i++) hist[s][i+5]--;\n\telse if (next <= bin)\n\t  for (i=hist[s][1]; i < bin; i++) hist[s][i+5]++;\n      }\n      hist[s][1] = next;\n      sym[s] = bin;\n    }\n    diff = sym[2] << 5 | sym[1] << 2 | (sym[0] & 3);\n    if (sym[0] & 4)\n      diff = diff ? -diff : 0x80;\n    if (ftell(ifp) + 12 >= seg[1][1])\n      diff = 0;\n    raw_image[pix] = pred[pix & 1] += diff;\n    if (!(pix & 1) && HOLE(pix / raw_width)) pix += 2;\n  }\n  maximum = 0xff;\n}\n\nvoid CLASS smal_v6_load_raw()\n{\n  unsigned seg[2][2];\n\n  fseek (ifp, 16, SEEK_SET);\n  seg[0][0] = 0;\n  seg[0][1] = get2();\n  seg[1][0] = raw_width * raw_height;\n  seg[1][1] = INT_MAX;\n  smal_decode_segment (seg, 0);\n}\n\nint CLASS median4 (int *p)\n{\n  int min, max, sum, i;\n\n  min = max = sum = p[0];\n  for (i=1; i < 4; i++) {\n    sum += p[i];\n    if (min > p[i]) min = p[i];\n    if (max < p[i]) max = p[i];\n  }\n  return (sum - min - max) >> 1;\n}\n\nvoid CLASS fill_holes (int holes)\n{\n  int row, col, val[4];\n\n  for (row=2; row < height-2; row++) {\n    if (!HOLE(row)) continue;\n    for (col=1; col < width-1; col+=4) {\n      val[0] = RAW(row-1,col-1);\n      val[1] = RAW(row-1,col+1);\n      val[2] = RAW(row+1,col-1);\n      val[3] = RAW(row+1,col+1);\n      RAW(row,col) = median4(val);\n    }\n    for (col=2; col < width-2; col+=4)\n      if (HOLE(row-2) || HOLE(row+2))\n\tRAW(row,col) = (RAW(row,col-2) + RAW(row,col+2)) >> 1;\n      else {\n\tval[0] = RAW(row,col-2);\n\tval[1] = RAW(row,col+2);\n\tval[2] = RAW(row-2,col);\n\tval[3] = RAW(row+2,col);\n\tRAW(row,col) = median4(val);\n      }\n  }\n}\n\nvoid CLASS smal_v9_load_raw()\n{\n  unsigned seg[256][2], offset, nseg, holes, i;\n\n  fseek (ifp, 67, SEEK_SET);\n  offset = get4();\n  nseg = fgetc(ifp);\n  fseek (ifp, offset, SEEK_SET);\n  for (i=0; i < nseg*2; i++)\n    seg[0][i] = get4() + data_offset*(i & 1);\n  fseek (ifp, 78, SEEK_SET);\n  holes = fgetc(ifp);\n  fseek (ifp, 88, SEEK_SET);\n  seg[nseg][0] = raw_height * raw_width;\n  seg[nseg][1] = get4() + data_offset;\n  for (i=0; i < nseg; i++)\n    smal_decode_segment (seg+i, holes);\n  if (holes) fill_holes (holes);\n}\n\nvoid CLASS redcine_load_raw()\n{\n#ifndef NO_JASPER\n  int c, row, col;\n  jas_stream_t *in;\n  jas_image_t *jimg;\n  jas_matrix_t *jmat;\n  jas_seqent_t *data;\n  ushort *img, *pix;\n\n  jas_init();\n#ifndef LIBRAW_LIBRARY_BUILD\n  in = jas_stream_fopen (ifname, \"rb\");\n#else\n  in = (jas_stream_t*)ifp->make_jas_stream();\n  if(!in)\n          throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n#endif\n  jas_stream_seek (in, data_offset+20, SEEK_SET);\n  jimg = jas_image_decode (in, -1, 0);\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!jimg) longjmp (failure, 3);\n#else\n  if(!jimg)\n      {\n          jas_stream_close (in);\n          throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n      }\n#endif\n  jmat = jas_matrix_create (height/2, width/2);\n  merror (jmat, \"redcine_load_raw()\");\n  img = (ushort *) calloc ((height+2)*(width+2), 2);\n  merror (img, \"redcine_load_raw()\");\n  FORC4 {\n    jas_image_readcmpt (jimg, c, 0, 0, width/2, height/2, jmat);\n    data = jas_matrix_getref (jmat, 0, 0);\n    for (row = c >> 1; row < height; row+=2)\n      for (col = c & 1; col < width; col+=2)\n\timg[(row+1)*(width+2)+col+1] = data[(row/2)*(width/2)+col/2];\n  }\n  for (col=1; col <= width; col++) {\n    img[col] = img[2*(width+2)+col];\n    img[(height+1)*(width+2)+col] = img[(height-1)*(width+2)+col];\n  }\n  for (row=0; row < height+2; row++) {\n    img[row*(width+2)] = img[row*(width+2)+2];\n    img[(row+1)*(width+2)-1] = img[(row+1)*(width+2)-3];\n  }\n  for (row=1; row <= height; row++) {\n    pix = img + row*(width+2) + (col = 1 + (FC(row,1) & 1));\n    for (   ; col <= width; col+=2, pix+=2) {\n      c = (((pix[0] - 0x800) << 3) +\n\tpix[-(width+2)] + pix[width+2] + pix[-1] + pix[1]) >> 2;\n      pix[0] = LIM(c,0,4095);\n    }\n  }\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      RAW(row,col) = curve[img[(row+1)*(width+2)+col+1]];\n  free (img);\n  jas_matrix_destroy (jmat);\n  jas_image_destroy (jimg);\n  jas_stream_close (in);\n#endif\n}\n//@end COMMON\n\n/* RESTRICTED code starts here */\n\nvoid CLASS foveon_decoder (unsigned size, unsigned code)\n{\n  static unsigned huff[1024];\n  struct decode *cur;\n  int i, len;\n\n  if (!code) {\n    for (i=0; i < size; i++)\n      huff[i] = get4();\n    memset (first_decode, 0, sizeof first_decode);\n    free_decode = first_decode;\n  }\n  cur = free_decode++;\n  if (free_decode > first_decode+2048) {\n    fprintf (stderr,_(\"%s: decoder table overflow\\n\"), ifname);\n    longjmp (failure, 2);\n  }\n  if (code)\n    for (i=0; i < size; i++)\n      if (huff[i] == code) {\n\tcur->leaf = i;\n\treturn;\n      }\n  if ((len = code >> 27) > 26) return;\n  code = (len+1) << 27 | (code & 0x3ffffff) << 1;\n\n  cur->branch[0] = free_decode;\n  foveon_decoder (size, code);\n  cur->branch[1] = free_decode;\n  foveon_decoder (size, code+1);\n}\n\nvoid CLASS foveon_thumb()\n{\n  unsigned bwide, row, col, bitbuf=0, bit=1, c, i;\n  char *buf;\n  struct decode *dindex;\n  short pred[3];\n\n  bwide = get4();\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  if (bwide > 0) {\n    if (bwide < thumb_width*3) return;\n    buf = (char *) malloc (bwide);\n    merror (buf, \"foveon_thumb()\");\n    for (row=0; row < thumb_height; row++) {\n      fread  (buf, 1, bwide, ifp);\n      fwrite (buf, 3, thumb_width, ofp);\n    }\n    free (buf);\n    return;\n  }\n  foveon_decoder (256, 0);\n\n  for (row=0; row < thumb_height; row++) {\n    memset (pred, 0, sizeof pred);\n    if (!bit) get4();\n    for (bit=col=0; col < thumb_width; col++)\n      FORC3 {\n\tfor (dindex=first_decode; dindex->branch[0]; ) {\n\t  if ((bit = (bit-1) & 31) == 31)\n\t    for (i=0; i < 4; i++)\n\t      bitbuf = (bitbuf << 8) + fgetc(ifp);\n\t  dindex = dindex->branch[bitbuf >> bit & 1];\n\t}\n\tpred[c] += dindex->leaf;\n\tfputc (pred[c], ofp);\n      }\n  }\n}\n\nvoid CLASS foveon_sd_load_raw()\n{\n  struct decode *dindex;\n  short diff[1024];\n  unsigned bitbuf=0;\n  int pred[3], row, col, bit=-1, c, i;\n\n  read_shorts ((ushort *) diff, 1024);\n  if (!load_flags) foveon_decoder (1024, 0);\n\n  for (row=0; row < height; row++) {\n    memset (pred, 0, sizeof pred);\n    if (!bit && !load_flags && atoi(model+2) < 14) get4();\n    for (col=bit=0; col < width; col++) {\n      if (load_flags) {\n\tbitbuf = get4();\n\tFORC3 pred[2-c] += diff[bitbuf >> c*10 & 0x3ff];\n      }\n      else FORC3 {\n\tfor (dindex=first_decode; dindex->branch[0]; ) {\n\t  if ((bit = (bit-1) & 31) == 31)\n\t    for (i=0; i < 4; i++)\n\t      bitbuf = (bitbuf << 8) + fgetc(ifp);\n\t  dindex = dindex->branch[bitbuf >> bit & 1];\n\t}\n\tpred[c] += diff[dindex->leaf];\n\tif (pred[c] >> 16 && ~pred[c] >> 16) derror();\n      }\n      FORC3 image[row*width+col][c] = pred[c];\n    }\n  }\n}\n\nvoid CLASS foveon_huff (ushort *huff)\n{\n  int i, j, clen, code;\n\n  huff[0] = 8;\n  for (i=0; i < 13; i++) {\n    clen = getc(ifp);\n    code = getc(ifp);\n    for (j=0; j < 256 >> clen; )\n      huff[code+ ++j] = clen << 8 | i;\n  }\n  get2();\n}\n\nvoid CLASS foveon_dp_load_raw()\n{\n  unsigned c, roff[4], row, col, diff;\n  ushort huff[258], vpred[2][2], hpred[2];\n\n  fseek (ifp, 8, SEEK_CUR);\n  foveon_huff (huff);\n  roff[0] = 48;\n  FORC3 roff[c+1] = -(-(roff[c] + get4()) & -16);\n  FORC3 {\n    fseek (ifp, data_offset+roff[c], SEEK_SET);\n    getbits(-1);\n    vpred[0][0] = vpred[0][1] = vpred[1][0] = vpred[1][1] = 512;\n    for (row=0; row < height; row++) {\n      for (col=0; col < width; col++) {\n       diff = ljpeg_diff(huff);\n       if (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n       else hpred[col & 1] += diff;\n       image[row*width+col][c] = hpred[col & 1];\n      }\n    }\n  }\n}\n\n\nvoid CLASS foveon_load_camf()\n{\n  unsigned type, wide, high, i, j, row, col, diff;\n  ushort huff[258], vpred[2][2] = {{512,512},{512,512}}, hpred[2];\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  type = get4();  get4();  get4();\n  wide = get4();\n  high = get4();\n  if (type == 2) {\n    fread (meta_data, 1, meta_length, ifp);\n    for (i=0; i < meta_length; i++) {\n      high = (high * 1597 + 51749) % 244944;\n      wide = high * (INT64) 301593171 >> 24;\n      meta_data[i] ^= ((((high << 8) - wide) >> 1) + wide) >> 17;\n    }\n  } else if (type == 4) {\n    free (meta_data);\n    meta_data = (char *) malloc (meta_length = wide*high*3/2);\n    merror (meta_data, \"foveon_load_camf()\");\n    foveon_huff (huff);\n    get4();\n    getbits(-1);\n    for (j=row=0; row < high; row++) {\n      for (col=0; col < wide; col++) {\n\tdiff = ljpeg_diff(huff);\n\tif (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n\telse         hpred[col & 1] += diff;\n\tif (col & 1) {\n\t  meta_data[j++] = hpred[0] >> 4;\n\t  meta_data[j++] = hpred[0] << 4 | hpred[1] >> 8;\n\t  meta_data[j++] = hpred[1];\n        }\n      }\n    }\n  } else\n    fprintf (stderr,_(\"%s has unknown CAMF type %d.\\n\"), ifname, type);\n}\n\nconst char * CLASS foveon_camf_param (const char *block, const char *param)\n{\n  unsigned idx, num;\n  char *pos, *cp, *dp;\n\n  for (idx=0; idx < meta_length; idx += sget4(pos+8)) {\n    pos = meta_data + idx;\n    if (strncmp (pos, \"CMb\", 3)) break;\n    if (pos[3] != 'P') continue;\n    if (strcmp (block, pos+sget4(pos+12))) continue;\n    cp = pos + sget4(pos+16);\n    num = sget4(cp);\n    dp = pos + sget4(cp+4);\n    while (num--) {\n      cp += 8;\n      if (!strcmp (param, dp+sget4(cp)))\n\treturn dp+sget4(cp+4);\n    }\n  }\n  return 0;\n}\n\nvoid * CLASS foveon_camf_matrix (unsigned dim[3], const char *name)\n{\n  unsigned i, idx, type, ndim, size, *mat;\n  char *pos, *cp, *dp;\n  double dsize;\n\n  for (idx=0; idx < meta_length; idx += sget4(pos+8)) {\n    pos = meta_data + idx;\n    if (strncmp (pos, \"CMb\", 3)) break;\n    if (pos[3] != 'M') continue;\n    if (strcmp (name, pos+sget4(pos+12))) continue;\n    dim[0] = dim[1] = dim[2] = 1;\n    cp = pos + sget4(pos+16);\n    type = sget4(cp);\n    if ((ndim = sget4(cp+4)) > 3) break;\n    dp = pos + sget4(cp+8);\n    for (i=ndim; i--; ) {\n      cp += 12;\n      dim[i] = sget4(cp);\n    }\n    if ((dsize = (double) dim[0]*dim[1]*dim[2]) > meta_length/4) break;\n    mat = (unsigned *) malloc ((size = dsize) * 4);\n    merror (mat, \"foveon_camf_matrix()\");\n    for (i=0; i < size; i++)\n      if (type && type != 6)\n\tmat[i] = sget4(dp + i*4);\n      else\n\tmat[i] = sget4(dp + i*2) & 0xffff;\n    return mat;\n  }\n  fprintf (stderr,_(\"%s: \\\"%s\\\" matrix not found!\\n\"), ifname, name);\n  return 0;\n}\n\nint CLASS foveon_fixed (void *ptr, int size, const char *name)\n{\n  void *dp;\n  unsigned dim[3];\n\n  if (!name) return 0;\n  dp = foveon_camf_matrix (dim, name);\n  if (!dp) return 0;\n  memcpy (ptr, dp, size*4);\n  free (dp);\n  return 1;\n}\n\nfloat CLASS foveon_avg (short *pix, int range[2], float cfilt)\n{\n  int i;\n  float val, min=FLT_MAX, max=-FLT_MAX, sum=0;\n\n  for (i=range[0]; i <= range[1]; i++) {\n    sum += val = pix[i*4] + (pix[i*4]-pix[(i-1)*4]) * cfilt;\n    if (min > val) min = val;\n    if (max < val) max = val;\n  }\n  if (range[1] - range[0] == 1) return sum/2;\n  return (sum - min - max) / (range[1] - range[0] - 1);\n}\n\nshort * CLASS foveon_make_curve (double max, double mul, double filt)\n{\n  short *curve;\n  unsigned i, size;\n  double x;\n\n  if (!filt) filt = 0.8;\n  size = 4*M_PI*max / filt;\n  if (size == UINT_MAX) size--;\n  curve = (short *) calloc (size+1, sizeof *curve);\n  merror (curve, \"foveon_make_curve()\");\n  curve[0] = size;\n  for (i=0; i < size; i++) {\n    x = i*filt/max/4;\n    curve[i+1] = (cos(x)+1)/2 * tanh(i*filt/mul) * mul + 0.5;\n  }\n  return curve;\n}\n\nvoid CLASS foveon_make_curves\n\t(short **curvep, float dq[3], float div[3], float filt)\n{\n  double mul[3], max=0;\n  int c;\n\n  FORC3 mul[c] = dq[c]/div[c];\n  FORC3 if (max < mul[c]) max = mul[c];\n  FORC3 curvep[c] = foveon_make_curve (max, mul[c], filt);\n}\n\nint CLASS foveon_apply_curve (short *curve, int i)\n{\n  if (abs(i) >= curve[0]) return 0;\n  return i < 0 ? -curve[1-i] : curve[1+i];\n}\n\n#define image ((short (*)[4]) image)\n\nvoid CLASS foveon_interpolate()\n{\n  static const short hood[] = { -1,-1, -1,0, -1,1, 0,-1, 0,1, 1,-1, 1,0, 1,1 };\n  short *pix, prev[3], *curve[8], (*shrink)[3];\n  float cfilt=0, ddft[3][3][2], ppm[3][3][3];\n  float cam_xyz[3][3], correct[3][3], last[3][3], trans[3][3];\n  float chroma_dq[3], color_dq[3], diag[3][3], div[3];\n  float (*black)[3], (*sgain)[3], (*sgrow)[3];\n  float fsum[3], val, frow, num;\n  int row, col, c, i, j, diff, sgx, irow, sum, min, max, limit;\n  int dscr[2][2], dstb[4], (*smrow[7])[3], total[4], ipix[3];\n  int work[3][3], smlast, smred, smred_p=0, dev[3];\n  int satlev[3], keep[4], active[4];\n  unsigned dim[3], *badpix;\n  double dsum=0, trsum[3];\n  char str[128];\n  const char* cp;\n\n  if (verbose)\n    fprintf (stderr,_(\"Foveon interpolation...\\n\"));\n\n  foveon_load_camf();\n  foveon_fixed (dscr, 4, \"DarkShieldColRange\");\n  foveon_fixed (ppm[0][0], 27, \"PostPolyMatrix\");\n  foveon_fixed (satlev, 3, \"SaturationLevel\");\n  foveon_fixed (keep, 4, \"KeepImageArea\");\n  foveon_fixed (active, 4, \"ActiveImageArea\");\n  foveon_fixed (chroma_dq, 3, \"ChromaDQ\");\n  foveon_fixed (color_dq, 3,\n\tfoveon_camf_param (\"IncludeBlocks\", \"ColorDQ\") ?\n\t\t\"ColorDQ\" : \"ColorDQCamRGB\");\n  if (foveon_camf_param (\"IncludeBlocks\", \"ColumnFilter\"))\n  \t\t foveon_fixed (&cfilt, 1, \"ColumnFilter\");\n\n  memset (ddft, 0, sizeof ddft);\n  if (!foveon_camf_param (\"IncludeBlocks\", \"DarkDrift\")\n\t || !foveon_fixed (ddft[1][0], 12, \"DarkDrift\"))\n    for (i=0; i < 2; i++) {\n      foveon_fixed (dstb, 4, i ? \"DarkShieldBottom\":\"DarkShieldTop\");\n      for (row = dstb[1]; row <= dstb[3]; row++)\n\tfor (col = dstb[0]; col <= dstb[2]; col++)\n\t  FORC3 ddft[i+1][c][1] += (short) image[row*width+col][c];\n      FORC3 ddft[i+1][c][1] /= (dstb[3]-dstb[1]+1) * (dstb[2]-dstb[0]+1);\n    }\n\n  if (!(cp = foveon_camf_param (\"WhiteBalanceIlluminants\", model2)))\n  { fprintf (stderr,_(\"%s: Invalid white balance \\\"%s\\\"\\n\"), ifname, model2);\n    return; }\n  foveon_fixed (cam_xyz, 9, cp);\n  foveon_fixed (correct, 9,\n\tfoveon_camf_param (\"WhiteBalanceCorrections\", model2));\n  memset (last, 0, sizeof last);\n  for (i=0; i < 3; i++)\n    for (j=0; j < 3; j++)\n      FORC3 last[i][j] += correct[i][c] * cam_xyz[c][j];\n\n  #define LAST(x,y) last[(i+x)%3][(c+y)%3]\n  for (i=0; i < 3; i++)\n    FORC3 diag[c][i] = LAST(1,1)*LAST(2,2) - LAST(1,2)*LAST(2,1);\n  #undef LAST\n  FORC3 div[c] = diag[c][0]*0.3127 + diag[c][1]*0.329 + diag[c][2]*0.3583;\n  sprintf (str, \"%sRGBNeutral\", model2);\n  if (foveon_camf_param (\"IncludeBlocks\", str))\n    foveon_fixed (div, 3, str);\n  num = 0;\n  FORC3 if (num < div[c]) num = div[c];\n  FORC3 div[c] /= num;\n\n  memset (trans, 0, sizeof trans);\n  for (i=0; i < 3; i++)\n    for (j=0; j < 3; j++)\n      FORC3 trans[i][j] += rgb_cam[i][c] * last[c][j] * div[j];\n  FORC3 trsum[c] = trans[c][0] + trans[c][1] + trans[c][2];\n  dsum = (6*trsum[0] + 11*trsum[1] + 3*trsum[2]) / 20;\n  for (i=0; i < 3; i++)\n    FORC3 last[i][c] = trans[i][c] * dsum / trsum[i];\n  memset (trans, 0, sizeof trans);\n  for (i=0; i < 3; i++)\n    for (j=0; j < 3; j++)\n      FORC3 trans[i][j] += (i==c ? 32 : -1) * last[c][j] / 30;\n\n  foveon_make_curves (curve, color_dq, div, cfilt);\n  FORC3 chroma_dq[c] /= 3;\n  foveon_make_curves (curve+3, chroma_dq, div, cfilt);\n  FORC3 dsum += chroma_dq[c] / div[c];\n  curve[6] = foveon_make_curve (dsum, dsum, cfilt);\n  curve[7] = foveon_make_curve (dsum*2, dsum*2, cfilt);\n\n  sgain = (float (*)[3]) foveon_camf_matrix (dim, \"SpatialGain\");\n  if (!sgain) return;\n  sgrow = (float (*)[3]) calloc (dim[1], sizeof *sgrow);\n  sgx = (width + dim[1]-2) / (dim[1]-1);\n\n  black = (float (*)[3]) calloc (height, sizeof *black);\n  for (row=0; row < height; row++) {\n    for (i=0; i < 6; i++)\n      ddft[0][0][i] = ddft[1][0][i] +\n\trow / (height-1.0) * (ddft[2][0][i] - ddft[1][0][i]);\n    FORC3 black[row][c] =\n \t( foveon_avg (image[row*width]+c, dscr[0], cfilt) +\n\t  foveon_avg (image[row*width]+c, dscr[1], cfilt) * 3\n\t  - ddft[0][c][0] ) / 4 - ddft[0][c][1];\n  }\n  memcpy (black, black+8, sizeof *black*8);\n  memcpy (black+height-11, black+height-22, 11*sizeof *black);\n  memcpy (last, black, sizeof last);\n\n  for (row=1; row < height-1; row++) {\n    FORC3 if (last[1][c] > last[0][c]) {\n\tif (last[1][c] > last[2][c])\n\t  black[row][c] = (last[0][c] > last[2][c]) ? last[0][c]:last[2][c];\n      } else\n\tif (last[1][c] < last[2][c])\n\t  black[row][c] = (last[0][c] < last[2][c]) ? last[0][c]:last[2][c];\n    memmove (last, last+1, 2*sizeof last[0]);\n    memcpy (last[2], black[row+1], sizeof last[2]);\n  }\n  FORC3 black[row][c] = (last[0][c] + last[1][c])/2;\n  FORC3 black[0][c] = (black[1][c] + black[3][c])/2;\n\n  val = 1 - exp(-1/24.0);\n  memcpy (fsum, black, sizeof fsum);\n  for (row=1; row < height; row++)\n    FORC3 fsum[c] += black[row][c] =\n\t(black[row][c] - black[row-1][c])*val + black[row-1][c];\n  memcpy (last[0], black[height-1], sizeof last[0]);\n  FORC3 fsum[c] /= height;\n  for (row = height; row--; )\n    FORC3 last[0][c] = black[row][c] =\n\t(black[row][c] - fsum[c] - last[0][c])*val + last[0][c];\n\n  memset (total, 0, sizeof total);\n  for (row=2; row < height; row+=4)\n    for (col=2; col < width; col+=4) {\n      FORC3 total[c] += (short) image[row*width+col][c];\n      total[3]++;\n    }\n  for (row=0; row < height; row++)\n    FORC3 black[row][c] += fsum[c]/2 + total[c]/(total[3]*100.0);\n\n  for (row=0; row < height; row++) {\n    for (i=0; i < 6; i++)\n      ddft[0][0][i] = ddft[1][0][i] +\n\trow / (height-1.0) * (ddft[2][0][i] - ddft[1][0][i]);\n    pix = image[row*width];\n    memcpy (prev, pix, sizeof prev);\n    frow = row / (height-1.0) * (dim[2]-1);\n    if ((irow = frow) == dim[2]-1) irow--;\n    frow -= irow;\n    for (i=0; i < dim[1]; i++)\n      FORC3 sgrow[i][c] = sgain[ irow   *dim[1]+i][c] * (1-frow) +\n\t\t\t  sgain[(irow+1)*dim[1]+i][c] *    frow;\n    for (col=0; col < width; col++) {\n      FORC3 {\n\tdiff = pix[c] - prev[c];\n\tprev[c] = pix[c];\n\tipix[c] = pix[c] + floor ((diff + (diff*diff >> 14)) * cfilt\n\t\t- ddft[0][c][1] - ddft[0][c][0] * ((float) col/width - 0.5)\n\t\t- black[row][c] );\n      }\n      FORC3 {\n\twork[0][c] = ipix[c] * ipix[c] >> 14;\n\twork[2][c] = ipix[c] * work[0][c] >> 14;\n\twork[1][2-c] = ipix[(c+1) % 3] * ipix[(c+2) % 3] >> 14;\n      }\n      FORC3 {\n\tfor (val=i=0; i < 3; i++)\n\t  for (  j=0; j < 3; j++)\n\t    val += ppm[c][i][j] * work[i][j];\n\tipix[c] = floor ((ipix[c] + floor(val)) *\n\t\t( sgrow[col/sgx  ][c] * (sgx - col%sgx) +\n\t\t  sgrow[col/sgx+1][c] * (col%sgx) ) / sgx / div[c]);\n\tif (ipix[c] > 32000) ipix[c] = 32000;\n\tpix[c] = ipix[c];\n      }\n      pix += 4;\n    }\n  }\n  free (black);\n  free (sgrow);\n  free (sgain);\n\n  if ((badpix = (unsigned int *) foveon_camf_matrix (dim, \"BadPixels\"))) {\n    for (i=0; i < dim[0]; i++) {\n      col = (badpix[i] >> 8 & 0xfff) - keep[0];\n      row = (badpix[i] >> 20       ) - keep[1];\n      if ((unsigned)(row-1) > height-3 || (unsigned)(col-1) > width-3)\n\tcontinue;\n      memset (fsum, 0, sizeof fsum);\n      for (sum=j=0; j < 8; j++)\n\tif (badpix[i] & (1 << j)) {\n\t  FORC3 fsum[c] += (short)\n\t\timage[(row+hood[j*2])*width+col+hood[j*2+1]][c];\n\t  sum++;\n\t}\n      if (sum) FORC3 image[row*width+col][c] = fsum[c]/sum;\n    }\n    free (badpix);\n  }\n\n  /* Array for 5x5 Gaussian averaging of red values */\n  smrow[6] = (int (*)[3]) calloc (width*5, sizeof **smrow);\n  merror (smrow[6], \"foveon_interpolate()\");\n  for (i=0; i < 5; i++)\n    smrow[i] = smrow[6] + i*width;\n\n  /* Sharpen the reds against these Gaussian averages */\n  for (smlast=-1, row=2; row < height-2; row++) {\n    while (smlast < row+2) {\n      for (i=0; i < 6; i++)\n\tsmrow[(i+5) % 6] = smrow[i];\n      pix = image[++smlast*width+2];\n      for (col=2; col < width-2; col++) {\n\tsmrow[4][col][0] =\n\t  (pix[0]*6 + (pix[-4]+pix[4])*4 + pix[-8]+pix[8] + 8) >> 4;\n\tpix += 4;\n      }\n    }\n    pix = image[row*width+2];\n    for (col=2; col < width-2; col++) {\n      smred = ( 6 *  smrow[2][col][0]\n\t      + 4 * (smrow[1][col][0] + smrow[3][col][0])\n\t      +      smrow[0][col][0] + smrow[4][col][0] + 8 ) >> 4;\n      if (col == 2)\n\tsmred_p = smred;\n      i = pix[0] + ((pix[0] - ((smred*7 + smred_p) >> 3)) >> 3);\n      if (i > 32000) i = 32000;\n      pix[0] = i;\n      smred_p = smred;\n      pix += 4;\n    }\n  }\n\n  /* Adjust the brighter pixels for better linearity */\n  min = 0xffff;\n  FORC3 {\n    i = satlev[c] / div[c];\n    if (min > i) min = i;\n  }\n  limit = min * 9 >> 4;\n  for (pix=image[0]; pix < image[height*width]; pix+=4) {\n    if (pix[0] <= limit || pix[1] <= limit || pix[2] <= limit)\n      continue;\n    min = max = pix[0];\n    for (c=1; c < 3; c++) {\n      if (min > pix[c]) min = pix[c];\n      if (max < pix[c]) max = pix[c];\n    }\n    if (min >= limit*2) {\n      pix[0] = pix[1] = pix[2] = max;\n    } else {\n      i = 0x4000 - ((min - limit) << 14) / limit;\n      i = 0x4000 - (i*i >> 14);\n      i = i*i >> 14;\n      FORC3 pix[c] += (max - pix[c]) * i >> 14;\n    }\n  }\n/*\n   Because photons that miss one detector often hit another,\n   the sum R+G+B is much less noisy than the individual colors.\n   So smooth the hues without smoothing the total.\n */\n  for (smlast=-1, row=2; row < height-2; row++) {\n    while (smlast < row+2) {\n      for (i=0; i < 6; i++)\n\tsmrow[(i+5) % 6] = smrow[i];\n      pix = image[++smlast*width+2];\n      for (col=2; col < width-2; col++) {\n\tFORC3 smrow[4][col][c] = (pix[c-4]+2*pix[c]+pix[c+4]+2) >> 2;\n\tpix += 4;\n      }\n    }\n    pix = image[row*width+2];\n    for (col=2; col < width-2; col++) {\n      FORC3 dev[c] = -foveon_apply_curve (curve[7], pix[c] -\n\t((smrow[1][col][c] + 2*smrow[2][col][c] + smrow[3][col][c]) >> 2));\n      sum = (dev[0] + dev[1] + dev[2]) >> 3;\n      FORC3 pix[c] += dev[c] - sum;\n      pix += 4;\n    }\n  }\n  for (smlast=-1, row=2; row < height-2; row++) {\n    while (smlast < row+2) {\n      for (i=0; i < 6; i++)\n\tsmrow[(i+5) % 6] = smrow[i];\n      pix = image[++smlast*width+2];\n      for (col=2; col < width-2; col++) {\n\tFORC3 smrow[4][col][c] =\n\t\t(pix[c-8]+pix[c-4]+pix[c]+pix[c+4]+pix[c+8]+2) >> 2;\n\tpix += 4;\n      }\n    }\n    pix = image[row*width+2];\n    for (col=2; col < width-2; col++) {\n      for (total[3]=375, sum=60, c=0; c < 3; c++) {\n\tfor (total[c]=i=0; i < 5; i++)\n\t  total[c] += smrow[i][col][c];\n\ttotal[3] += total[c];\n\tsum += pix[c];\n      }\n      if (sum < 0) sum = 0;\n      j = total[3] > 375 ? (sum << 16) / total[3] : sum * 174;\n      FORC3 pix[c] += foveon_apply_curve (curve[6],\n\t\t((j*total[c] + 0x8000) >> 16) - pix[c]);\n      pix += 4;\n    }\n  }\n\n  /* Transform the image to a different colorspace */\n  for (pix=image[0]; pix < image[height*width]; pix+=4) {\n    FORC3 pix[c] -= foveon_apply_curve (curve[c], pix[c]);\n    sum = (pix[0]+pix[1]+pix[1]+pix[2]) >> 2;\n    FORC3 pix[c] -= foveon_apply_curve (curve[c], pix[c]-sum);\n    FORC3 {\n      for (dsum=i=0; i < 3; i++)\n\tdsum += trans[c][i] * pix[i];\n      if (dsum < 0)  dsum = 0;\n      if (dsum > 24000) dsum = 24000;\n      ipix[c] = dsum + 0.5;\n    }\n    FORC3 pix[c] = ipix[c];\n  }\n\n  /* Smooth the image bottom-to-top and save at 1/4 scale */\n  shrink = (short (*)[3]) calloc ((width/4) * (height/4), sizeof *shrink);\n  merror (shrink, \"foveon_interpolate()\");\n  for (row = height/4; row--; )\n    for (col=0; col < width/4; col++) {\n      ipix[0] = ipix[1] = ipix[2] = 0;\n      for (i=0; i < 4; i++)\n\tfor (j=0; j < 4; j++)\n\t  FORC3 ipix[c] += image[(row*4+i)*width+col*4+j][c];\n      FORC3\n\tif (row+2 > height/4)\n\t  shrink[row*(width/4)+col][c] = ipix[c] >> 4;\n\telse\n\t  shrink[row*(width/4)+col][c] =\n\t    (shrink[(row+1)*(width/4)+col][c]*1840 + ipix[c]*141 + 2048) >> 12;\n    }\n  /* From the 1/4-scale image, smooth right-to-left */\n  for (row=0; row < (height & ~3); row++) {\n    ipix[0] = ipix[1] = ipix[2] = 0;\n    if ((row & 3) == 0)\n      for (col = width & ~3 ; col--; )\n\tFORC3 smrow[0][col][c] = ipix[c] =\n\t  (shrink[(row/4)*(width/4)+col/4][c]*1485 + ipix[c]*6707 + 4096) >> 13;\n\n  /* Then smooth left-to-right */\n    ipix[0] = ipix[1] = ipix[2] = 0;\n    for (col=0; col < (width & ~3); col++)\n      FORC3 smrow[1][col][c] = ipix[c] =\n\t(smrow[0][col][c]*1485 + ipix[c]*6707 + 4096) >> 13;\n\n  /* Smooth top-to-bottom */\n    if (row == 0)\n      memcpy (smrow[2], smrow[1], sizeof **smrow * width);\n    else\n      for (col=0; col < (width & ~3); col++)\n\tFORC3 smrow[2][col][c] =\n\t  (smrow[2][col][c]*6707 + smrow[1][col][c]*1485 + 4096) >> 13;\n\n  /* Adjust the chroma toward the smooth values */\n    for (col=0; col < (width & ~3); col++) {\n      for (i=j=30, c=0; c < 3; c++) {\n\ti += smrow[2][col][c];\n\tj += image[row*width+col][c];\n      }\n      j = (j << 16) / i;\n      for (sum=c=0; c < 3; c++) {\n\tipix[c] = foveon_apply_curve (curve[c+3],\n\t  ((smrow[2][col][c] * j + 0x8000) >> 16) - image[row*width+col][c]);\n\tsum += ipix[c];\n      }\n      sum >>= 3;\n      FORC3 {\n\ti = image[row*width+col][c] + ipix[c] - sum;\n\tif (i < 0) i = 0;\n\timage[row*width+col][c] = i;\n      }\n    }\n  }\n  free (shrink);\n  free (smrow[6]);\n  for (i=0; i < 8; i++)\n    free (curve[i]);\n\n  /* Trim off the black border */\n  active[1] -= keep[1];\n  active[3] -= 2;\n  i = active[2] - active[0];\n  for (row=0; row < active[3]-active[1]; row++)\n    memcpy (image[row*i], image[(row+active[1])*width+active[0]],\n\t i * sizeof *image);\n  width = i;\n  height = row;\n}\n#undef image\n\n/* RESTRICTED code ends here */\n\n//@out COMMON\nvoid CLASS crop_masked_pixels()\n{\n  int row, col;\n  unsigned \n#ifndef LIBRAW_LIBRARY_BUILD\n    r, raw_pitch = raw_width*2,\n#endif\n    c, m, mblack[8], zero, val;\n\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (load_raw == &CLASS phase_one_load_raw ||\n      load_raw == &CLASS phase_one_load_raw_c)\n    phase_one_correct();\n  if (fuji_width) {\n    for (row=0; row < raw_height-top_margin*2; row++) {\n      for (col=0; col < fuji_width << !fuji_layout; col++) {\n\tif (fuji_layout) {\n\t  r = fuji_width - 1 - col + (row >> 1);\n\t  c = col + ((row+1) >> 1);\n\t} else {\n\t  r = fuji_width - 1 + row - (col >> 1);\n\t  c = row + ((col+1) >> 1);\n\t}\n\tif (r < height && c < width)\n\t  BAYER(r,c) = RAW(row+top_margin,col+left_margin);\n      }\n    }\n  } else {\n    for (row=0; row < height; row++)\n      for (col=0; col < width; col++)\n\tBAYER2(row,col) = RAW(row+top_margin,col+left_margin);\n  }\n#endif\n  if (mask[0][3]) goto mask_set;\n  if (load_raw == &CLASS canon_load_raw ||\n      load_raw == &CLASS lossless_jpeg_load_raw) {\n    mask[0][1] = mask[1][1] = 2;\n    mask[0][3] = -2;\n    goto sides;\n  }\n  if (load_raw == &CLASS canon_600_load_raw ||\n      load_raw == &CLASS sony_load_raw ||\n     (load_raw == &CLASS eight_bit_load_raw && strncmp(model,\"DC2\",3)) ||\n      load_raw == &CLASS kodak_262_load_raw ||\n     (load_raw == &CLASS packed_load_raw && (load_flags & 32))) {\nsides:\n    mask[0][0] = mask[1][0] = top_margin;\n    mask[0][2] = mask[1][2] = top_margin+height;\n    mask[0][3] += left_margin;\n    mask[1][1] += left_margin+width;\n    mask[1][3] += raw_width;\n  }\n  if (load_raw == &CLASS nokia_load_raw) {\n    mask[0][2] = top_margin;\n    mask[0][3] = width;\n  }\nmask_set:\n  memset (mblack, 0, sizeof mblack);\n  for (zero=m=0; m < 8; m++)\n    for (row=mask[m][0]; row < mask[m][2]; row++)\n      for (col=mask[m][1]; col < mask[m][3]; col++) {\n\tc = FC(row-top_margin,col-left_margin);\n\tmblack[c] += val = raw_image[(row)*raw_pitch/2+(col)];\n\tmblack[4+c]++;\n\tzero += !val;\n      }\n  if (load_raw == &CLASS canon_600_load_raw && width < raw_width) {\n    black = (mblack[0]+mblack[1]+mblack[2]+mblack[3]) /\n\t    (mblack[4]+mblack[5]+mblack[6]+mblack[7]) - 4;\n#ifndef LIBRAW_LIBRARY_BUILD\n    canon_600_correct();\n#endif\n  } else if (zero < mblack[4] && mblack[5] && mblack[6] && mblack[7])\n    FORC4 cblack[c] = mblack[c] / mblack[4+c];\n}\n\nvoid CLASS remove_zeroes()\n{\n  unsigned row, col, tot, n, r, c;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES,0,2);\n#endif\n\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      if (BAYER(row,col) == 0) {\n\ttot = n = 0;\n\tfor (r = row-2; r <= row+2; r++)\n\t  for (c = col-2; c <= col+2; c++)\n\t    if (r < height && c < width &&\n\t\tFC(r,c) == FC(row,col) && BAYER(r,c))\n\t      tot += (n++,BAYER(r,c));\n\tif (n) BAYER(row,col) = tot/n;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES,1,2);\n#endif\n}\n//@end COMMON\n\n/* @out FILEIO\n#include <math.h>\n#define CLASS LibRaw::\n#include \"libraw/libraw_types.h\"\n#define LIBRAW_LIBRARY_BUILD\n#include \"libraw/libraw.h\"\n#include \"internal/defines.h\"\n#include \"internal/var_defines.h\"\n@end FILEIO */\n\n\n// @out FILEIO\n/*\n   Seach from the current directory up to the root looking for\n   a \".badpixels\" file, and fix those pixels now.\n */\nvoid CLASS bad_pixels (const char *cfname)\n{\n  FILE *fp=NULL;\n#ifndef LIBRAW_LIBRARY_BUILD\n  char *fname, *cp, line[128];\n  int len, time, row, col, r, c, rad, tot, n, fixed=0;\n#else\n  char *cp, line[128];\n  int time, row, col, r, c, rad, tot, n;\n#ifdef DCRAW_VERBOSE\n  int fixed = 0;\n#endif\n#endif\n\n  if (!filters) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,0,2);\n#endif\n  if (cfname)\n    fp = fopen (cfname, \"r\");\n// @end FILEIO\n  else {\n    for (len=32 ; ; len *= 2) {\n      fname = (char *) malloc (len);\n      if (!fname) return;\n      if (getcwd (fname, len-16)) break;\n      free (fname);\n      if (errno != ERANGE) return;\n    }\n#if defined(WIN32) || defined(DJGPP)\n    if (fname[1] == ':')\n      memmove (fname, fname+2, len-2);\n    for (cp=fname; *cp; cp++)\n      if (*cp == '\\\\') *cp = '/';\n#endif\n    cp = fname + strlen(fname);\n    if (cp[-1] == '/') cp--;\n    while (*fname == '/') {\n      strcpy (cp, \"/.badpixels\");\n      if ((fp = fopen (fname, \"r\"))) break;\n      if (cp == fname) break;\n      while (*--cp != '/');\n    }\n    free (fname);\n  }\n// @out FILEIO\n  if (!fp)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_BADPIXELMAP;\n#endif\n          return;\n      }\n  while (fgets (line, 128, fp)) {\n    cp = strchr (line, '#');\n    if (cp) *cp = 0;\n    if (sscanf (line, \"%d %d %d\", &col, &row, &time) != 3) continue;\n    if ((unsigned) col >= width || (unsigned) row >= height) continue;\n    if (time > timestamp) continue;\n    for (tot=n=0, rad=1; rad < 3 && n==0; rad++)\n      for (r = row-rad; r <= row+rad; r++)\n\tfor (c = col-rad; c <= col+rad; c++)\n\t  if ((unsigned) r < height && (unsigned) c < width &&\n\t\t(r != row || c != col) && fcol(r,c) == fcol(row,col)) {\n\t    tot += BAYER2(r,c);\n\t    n++;\n\t  }\n    BAYER2(row,col) = tot/n;\n#ifdef DCRAW_VERBOSE\n    if (verbose) {\n      if (!fixed++)\n\tfprintf (stderr,_(\"Fixed dead pixels at:\"));\n      fprintf (stderr, \" %d,%d\", col, row);\n    }\n#endif\n  }\n#ifdef DCRAW_VERBOSE\n  if (fixed) fputc ('\\n', stderr);\n#endif\n  fclose (fp);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,1,2);\n#endif\n}\n\nvoid CLASS subtract (const char *fname)\n{\n  FILE *fp;\n  int dim[3]={0,0,0}, comment=0, number=0, error=0, nd=0, c, row, col;\n  ushort *pixel;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME,0,2);\n#endif\n\n  if (!(fp = fopen (fname, \"rb\"))) {\n#ifdef DCRAW_VERBOSE\n    perror (fname); \n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_BAD_DARKFRAME_FILE;\n#endif\n    return;\n  }\n  if (fgetc(fp) != 'P' || fgetc(fp) != '5') error = 1;\n  while (!error && nd < 3 && (c = fgetc(fp)) != EOF) {\n    if (c == '#')  comment = 1;\n    if (c == '\\n') comment = 0;\n    if (comment) continue;\n    if (isdigit(c)) number = 1;\n    if (number) {\n      if (isdigit(c)) dim[nd] = dim[nd]*10 + c -'0';\n      else if (isspace(c)) {\n\tnumber = 0;  nd++;\n      } else error = 1;\n    }\n  }\n  if (error || nd < 3) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s is not a valid PGM file!\\n\"), fname);\n#endif\n    fclose (fp);  return;\n  } else if (dim[0] != width || dim[1] != height || dim[2] != 65535) {\n#ifdef DCRAW_VERBOSE\n      fprintf (stderr,_(\"%s has the wrong dimensions!\\n\"), fname);\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.process_warnings |= LIBRAW_WARN_BAD_DARKFRAME_DIM;\n#endif\n    fclose (fp);  return;\n  }\n  pixel = (ushort *) calloc (width, sizeof *pixel);\n  merror (pixel, \"subtract()\");\n  for (row=0; row < height; row++) {\n    fread (pixel, 2, width, fp);\n    for (col=0; col < width; col++)\n      BAYER(row,col) = MAX (BAYER(row,col) - ntohs(pixel[col]), 0);\n  }\n  free (pixel);\n  fclose (fp);\n  memset (cblack, 0, sizeof cblack);\n  black = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME,1,2);\n#endif\n}\n//@end FILEIO\n\n//@out COMMON\nvoid CLASS gamma_curve (double pwr, double ts, int mode, int imax)\n{\n  int i;\n  double g[6], bnd[2]={0,0}, r;\n\n  g[0] = pwr;\n  g[1] = ts;\n  g[2] = g[3] = g[4] = 0;\n  bnd[g[1] >= 1] = 1;\n  if (g[1] && (g[1]-1)*(g[0]-1) <= 0) {\n    for (i=0; i < 48; i++) {\n      g[2] = (bnd[0] + bnd[1])/2;\n      if (g[0]) bnd[(pow(g[2]/g[1],-g[0]) - 1)/g[0] - 1/g[2] > -1] = g[2];\n      else\tbnd[g[2]/exp(1-1/g[2]) < g[1]] = g[2];\n    }\n    g[3] = g[2] / g[1];\n    if (g[0]) g[4] = g[2] * (1/g[0] - 1);\n  }\n  if (g[0]) g[5] = 1 / (g[1]*SQR(g[3])/2 - g[4]*(1 - g[3]) +\n\t\t(1 - pow(g[3],1+g[0]))*(1 + g[4])/(1 + g[0])) - 1;\n  else      g[5] = 1 / (g[1]*SQR(g[3])/2 + 1\n\t\t- g[2] - g[3] -\tg[2]*g[3]*(log(g[3]) - 1)) - 1;\n  if (!mode--) {\n    memcpy (gamm, g, sizeof gamm);\n    return;\n  }\n  for (i=0; i < 0x10000; i++) {\n    curve[i] = 0xffff;\n    if ((r = (double) i / imax) < 1)\n      curve[i] = 0x10000 * ( mode\n\t? (r < g[3] ? r*g[1] : (g[0] ? pow( r,g[0])*(1+g[4])-g[4]    : log(r)*g[2]+1))\n\t: (r < g[2] ? r/g[1] : (g[0] ? pow((r+g[4])/(1+g[4]),1/g[0]) : exp((r-1)/g[2]))));\n  }\n}\n\nvoid CLASS pseudoinverse (double (*in)[3], double (*out)[3], int size)\n{\n  double work[3][6], num;\n  int i, j, k;\n\n  for (i=0; i < 3; i++) {\n    for (j=0; j < 6; j++)\n      work[i][j] = j == i+3;\n    for (j=0; j < 3; j++)\n      for (k=0; k < size; k++)\n\twork[i][j] += in[k][i] * in[k][j];\n  }\n  for (i=0; i < 3; i++) {\n    num = work[i][i];\n    for (j=0; j < 6; j++)\n      work[i][j] /= num;\n    for (k=0; k < 3; k++) {\n      if (k==i) continue;\n      num = work[k][i];\n      for (j=0; j < 6; j++)\n\twork[k][j] -= work[i][j] * num;\n    }\n  }\n  for (i=0; i < size; i++)\n    for (j=0; j < 3; j++)\n      for (out[i][j]=k=0; k < 3; k++)\n\tout[i][j] += work[j][k+3] * in[i][k];\n}\n\nvoid CLASS cam_xyz_coeff (double cam_xyz[4][3])\n{\n  double cam_rgb[4][3], inverse[4][3], num;\n  int i, j, k;\n\n  for (i=0; i < colors; i++)\t\t/* Multiply out XYZ colorspace */\n    for (j=0; j < 3; j++)\n      for (cam_rgb[i][j] = k=0; k < 3; k++)\n\tcam_rgb[i][j] += cam_xyz[i][k] * xyz_rgb[k][j];\n\n  for (i=0; i < colors; i++) {\t\t/* Normalize cam_rgb so that */\n    for (num=j=0; j < 3; j++)\t\t/* cam_rgb * (1,1,1) is (1,1,1,1) */\n      num += cam_rgb[i][j];\n    for (j=0; j < 3; j++)\n      cam_rgb[i][j] /= num;\n    pre_mul[i] = 1 / num;\n  }\n  pseudoinverse (cam_rgb, inverse, colors);\n  for (raw_color = i=0; i < 3; i++)\n    for (j=0; j < colors; j++)\n      rgb_cam[i][j] = inverse[j][i];\n}\n\n#ifdef COLORCHECK\nvoid CLASS colorcheck()\n{\n#define NSQ 24\n// Coordinates of the GretagMacbeth ColorChecker squares\n// width, height, 1st_column, 1st_row\n  int cut[NSQ][4];\t\t\t// you must set these\n// ColorChecker Chart under 6500-kelvin illumination\n  static const double gmb_xyY[NSQ][3] = {\n    { 0.400, 0.350, 10.1 },\t\t// Dark Skin\n    { 0.377, 0.345, 35.8 },\t\t// Light Skin\n    { 0.247, 0.251, 19.3 },\t\t// Blue Sky\n    { 0.337, 0.422, 13.3 },\t\t// Foliage\n    { 0.265, 0.240, 24.3 },\t\t// Blue Flower\n    { 0.261, 0.343, 43.1 },\t\t// Bluish Green\n    { 0.506, 0.407, 30.1 },\t\t// Orange\n    { 0.211, 0.175, 12.0 },\t\t// Purplish Blue\n    { 0.453, 0.306, 19.8 },\t\t// Moderate Red\n    { 0.285, 0.202, 6.6 },\t\t// Purple\n    { 0.380, 0.489, 44.3 },\t\t// Yellow Green\n    { 0.473, 0.438, 43.1 },\t\t// Orange Yellow\n    { 0.187, 0.129, 6.1 },\t\t// Blue\n    { 0.305, 0.478, 23.4 },\t\t// Green\n    { 0.539, 0.313, 12.0 },\t\t// Red\n    { 0.448, 0.470, 59.1 },\t\t// Yellow\n    { 0.364, 0.233, 19.8 },\t\t// Magenta\n    { 0.196, 0.252, 19.8 },\t\t// Cyan\n    { 0.310, 0.316, 90.0 },\t\t// White\n    { 0.310, 0.316, 59.1 },\t\t// Neutral 8\n    { 0.310, 0.316, 36.2 },\t\t// Neutral 6.5\n    { 0.310, 0.316, 19.8 },\t\t// Neutral 5\n    { 0.310, 0.316, 9.0 },\t\t// Neutral 3.5\n    { 0.310, 0.316, 3.1 } };\t\t// Black\n  double gmb_cam[NSQ][4], gmb_xyz[NSQ][3];\n  double inverse[NSQ][3], cam_xyz[4][3], num;\n  int c, i, j, k, sq, row, col, count[4];\n\n  memset (gmb_cam, 0, sizeof gmb_cam);\n  for (sq=0; sq < NSQ; sq++) {\n    FORCC count[c] = 0;\n    for   (row=cut[sq][3]; row < cut[sq][3]+cut[sq][1]; row++)\n      for (col=cut[sq][2]; col < cut[sq][2]+cut[sq][0]; col++) {\n\tc = FC(row,col);\n\tif (c >= colors) c -= 2;\n\tgmb_cam[sq][c] += BAYER(row,col);\n\tcount[c]++;\n      }\n    FORCC gmb_cam[sq][c] = gmb_cam[sq][c]/count[c] - black;\n    gmb_xyz[sq][0] = gmb_xyY[sq][2] * gmb_xyY[sq][0] / gmb_xyY[sq][1];\n    gmb_xyz[sq][1] = gmb_xyY[sq][2];\n    gmb_xyz[sq][2] = gmb_xyY[sq][2] *\n\t\t(1 - gmb_xyY[sq][0] - gmb_xyY[sq][1]) / gmb_xyY[sq][1];\n  }\n  pseudoinverse (gmb_xyz, inverse, NSQ);\n  for (i=0; i < colors; i++)\n    for (j=0; j < 3; j++)\n      for (cam_xyz[i][j] = k=0; k < NSQ; k++)\n\tcam_xyz[i][j] += gmb_cam[k][i] * inverse[k][j];\n  cam_xyz_coeff (cam_xyz);\n  if (verbose) {\n    printf (\"    { \\\"%s %s\\\", %d,\\n\\t{\", make, model, black);\n    num = 10000 / (cam_xyz[1][0] + cam_xyz[1][1] + cam_xyz[1][2]);\n    FORCC for (j=0; j < 3; j++)\n      printf (\"%c%d\", (c | j) ? ',':' ', (int) (cam_xyz[c][j] * num + 0.5));\n    puts (\" } },\");\n  }\n#undef NSQ\n}\n#endif\n\nvoid CLASS hat_transform (float *temp, float *base, int st, int size, int sc)\n{\n  int i;\n  for (i=0; i < sc; i++)\n    temp[i] = 2*base[st*i] + base[st*(sc-i)] + base[st*(i+sc)];\n  for (; i+sc < size; i++)\n    temp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(i+sc)];\n  for (; i < size; i++)\n    temp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(2*size-2-(i+sc))];\n}\n\n#if !defined(LIBRAW_USE_OPENMP)\nvoid CLASS wavelet_denoise()\n{\n  float *fimg=0, *temp, thold, mul[2], avg, diff;\n  int scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];\n  ushort *window[4];\n  static const float noise[] =\n  { 0.8002,0.2735,0.1202,0.0585,0.0291,0.0152,0.0080,0.0044 };\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Wavelet denoising...\\n\"));\n#endif\n\n  while (maximum << scale < 0x10000) scale++;\n  maximum <<= --scale;\n  black <<= scale;\n  FORC4 cblack[c] <<= scale;\n  if ((size = iheight*iwidth) < 0x15550000)\n    fimg = (float *) malloc ((size*3 + iheight + iwidth) * sizeof *fimg);\n  merror (fimg, \"wavelet_denoise()\");\n  temp = fimg + size*3;\n  if ((nc = colors) == 3 && filters) nc++;\n  FORC(nc) {\t\t\t/* denoise R,G1,B,G3 individually */\n    for (i=0; i < size; i++)\n      fimg[i] = 256 * sqrt((double)(image[i][c] << scale));\n    for (hpass=lev=0; lev < 5; lev++) {\n      lpass = size*((lev & 1)+1);\n      for (row=0; row < iheight; row++) {\n\that_transform (temp, fimg+hpass+row*iwidth, 1, iwidth, 1 << lev);\n\tfor (col=0; col < iwidth; col++)\n\t  fimg[lpass + row*iwidth + col] = temp[col] * 0.25;\n      }\n      for (col=0; col < iwidth; col++) {\n\that_transform (temp, fimg+lpass+col, iwidth, iheight, 1 << lev);\n\tfor (row=0; row < iheight; row++)\n\t  fimg[lpass + row*iwidth + col] = temp[row] * 0.25;\n      }\n      thold = threshold * noise[lev];\n      for (i=0; i < size; i++) {\n\tfimg[hpass+i] -= fimg[lpass+i];\n\tif\t(fimg[hpass+i] < -thold) fimg[hpass+i] += thold;\n\telse if (fimg[hpass+i] >  thold) fimg[hpass+i] -= thold;\n\telse\t fimg[hpass+i] = 0;\n\tif (hpass) fimg[i] += fimg[hpass+i];\n      }\n      hpass = lpass;\n    }\n    for (i=0; i < size; i++)\n      image[i][c] = CLIP(SQR(fimg[i]+fimg[lpass+i])/0x10000);\n  }\n  if (filters && colors == 3) {  /* pull G1 and G3 closer together */\n    for (row=0; row < 2; row++) {\n      mul[row] = 0.125 * pre_mul[FC(row+1,0) | 1] / pre_mul[FC(row,0) | 1];\n      blk[row] = cblack[FC(row,0) | 1];\n    }\n    for (i=0; i < 4; i++)\n      window[i] = (ushort *) fimg + width*i;\n    for (wlast=-1, row=1; row < height-1; row++) {\n      while (wlast < row+1) {\n\tfor (wlast++, i=0; i < 4; i++)\n\t  window[(i+3) & 3] = window[i];\n\tfor (col = FC(wlast,1) & 1; col < width; col+=2)\n\t  window[2][col] = BAYER(wlast,col);\n      }\n      thold = threshold/512;\n      for (col = (FC(row,0) & 1)+1; col < width-1; col+=2) {\n\tavg = ( window[0][col-1] + window[0][col+1] +\n\t\twindow[2][col-1] + window[2][col+1] - blk[~row & 1]*4 )\n\t      * mul[row & 1] + (window[1][col] + blk[row & 1]) * 0.5;\n\tavg = avg < 0 ? 0 : sqrt(avg);\n\tdiff = sqrt((double)BAYER(row,col)) - avg;\n\tif      (diff < -thold) diff += thold;\n\telse if (diff >  thold) diff -= thold;\n\telse diff = 0;\n\tBAYER(row,col) = CLIP(SQR(avg+diff) + 0.5);\n      }\n    }\n  }\n  free (fimg);\n}\n#else /* LIBRAW_USE_OPENMP */\nvoid CLASS wavelet_denoise()\n{\n  float *fimg=0, *temp, thold, mul[2], avg, diff;\n   int scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];\n  ushort *window[4];\n  static const float noise[] =\n  { 0.8002,0.2735,0.1202,0.0585,0.0291,0.0152,0.0080,0.0044 };\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Wavelet denoising...\\n\"));\n#endif\n\n  while (maximum << scale < 0x10000) scale++;\n  maximum <<= --scale;\n  black <<= scale;\n  FORC4 cblack[c] <<= scale;\n  if ((size = iheight*iwidth) < 0x15550000)\n    fimg = (float *) malloc ((size*3 + iheight + iwidth) * sizeof *fimg);\n  merror (fimg, \"wavelet_denoise()\");\n  temp = fimg + size*3;\n  if ((nc = colors) == 3 && filters) nc++;\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp parallel default(shared) private(i,col,row,thold,lev,lpass,hpass,temp,c) firstprivate(scale,size) \n#endif\n  {\n      temp = (float*)malloc( (iheight + iwidth) * sizeof *fimg);\n    FORC(nc) {\t\t\t/* denoise R,G1,B,G3 individually */\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n      for (i=0; i < size; i++)\n        fimg[i] = 256 * sqrt((double)(image[i][c] << scale));\n      for (hpass=lev=0; lev < 5; lev++) {\n\tlpass = size*((lev & 1)+1);\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n\tfor (row=0; row < iheight; row++) {\n\t  hat_transform (temp, fimg+hpass+row*iwidth, 1, iwidth, 1 << lev);\n\t  for (col=0; col < iwidth; col++)\n\t    fimg[lpass + row*iwidth + col] = temp[col] * 0.25;\n\t}\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n\tfor (col=0; col < iwidth; col++) {\n\t  hat_transform (temp, fimg+lpass+col, iwidth, iheight, 1 << lev);\n\t  for (row=0; row < iheight; row++)\n\t    fimg[lpass + row*iwidth + col] = temp[row] * 0.25;\n\t}\n\tthold = threshold * noise[lev];\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n\tfor (i=0; i < size; i++) {\n\t  fimg[hpass+i] -= fimg[lpass+i];\n\t  if\t(fimg[hpass+i] < -thold) fimg[hpass+i] += thold;\n\t  else if (fimg[hpass+i] >  thold) fimg[hpass+i] -= thold;\n\t  else\t fimg[hpass+i] = 0;\n\t  if (hpass) fimg[i] += fimg[hpass+i];\n\t}\n\thpass = lpass;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n      for (i=0; i < size; i++)\n\timage[i][c] = CLIP(SQR(fimg[i]+fimg[lpass+i])/0x10000);\n    }\n    free(temp);\n  } /* end omp parallel */\n/* the following loops are hard to parallize, no idea yes,\n * problem is wlast which is carrying dependency\n * second part should be easyer, but did not yet get it right.\n */\n  if (filters && colors == 3) {  /* pull G1 and G3 closer together */\n   for (row=0; row < 2; row++){\n      mul[row] = 0.125 * pre_mul[FC(row+1,0) | 1] / pre_mul[FC(row,0) | 1];\n      blk[row] = cblack[FC(row,0) | 1];\n   }\n    for (i=0; i < 4; i++)\n      window[i] = (ushort *) fimg + width*i;\n    for (wlast=-1, row=1; row < height-1; row++) {\n      while (wlast < row+1) {\n\tfor (wlast++, i=0; i < 4; i++)\n\t  window[(i+3) & 3] = window[i];\n\tfor (col = FC(wlast,1) & 1; col < width; col+=2)\n\t  window[2][col] = BAYER(wlast,col);\n      }\n      thold = threshold/512;\n      for (col = (FC(row,0) & 1)+1; col < width-1; col+=2) {\n\tavg = ( window[0][col-1] + window[0][col+1] +\n\t\twindow[2][col-1] + window[2][col+1] - blk[~row & 1]*4 )\n\t      * mul[row & 1] + (window[1][col] + blk[row & 1]) * 0.5;\n\tavg = avg < 0 ? 0 : sqrt(avg);\n\tdiff = sqrt((double)BAYER(row,col)) - avg;\n\tif      (diff < -thold) diff += thold;\n\telse if (diff >  thold) diff -= thold;\n\telse diff = 0;\n\tBAYER(row,col) = CLIP(SQR(avg+diff) + 0.5);\n      }\n    }\n  }\n  free (fimg);\n}\n\n#endif\n\n// green equilibration\nvoid CLASS green_matching()\n{\n  int i,j;\n  double m1,m2,c1,c2;\n  int o1_1,o1_2,o1_3,o1_4;\n  int o2_1,o2_2,o2_3,o2_4;\n  ushort (*img)[4];\n  const int margin = 3;\n  int oj = 2, oi = 2;\n  float f;\n  const float thr = 0.01f;\n  if(half_size || shrink) return;\n  if(FC(oj, oi) != 3) oj++;\n  if(FC(oj, oi) != 3) oi++;\n  if(FC(oj, oi) != 3) oj--;\n\n  img = (ushort (*)[4]) calloc (height*width, sizeof *image);\n  merror (img, \"green_matching()\");\n  memcpy(img,image,height*width*sizeof *image);\n\n  for(j=oj;j<height-margin;j+=2)\n    for(i=oi;i<width-margin;i+=2){\n      o1_1=img[(j-1)*width+i-1][1];\n      o1_2=img[(j-1)*width+i+1][1];\n      o1_3=img[(j+1)*width+i-1][1];\n      o1_4=img[(j+1)*width+i+1][1];\n      o2_1=img[(j-2)*width+i][3];\n      o2_2=img[(j+2)*width+i][3];\n      o2_3=img[j*width+i-2][3];\n      o2_4=img[j*width+i+2][3];\n\n      m1=(o1_1+o1_2+o1_3+o1_4)/4.0;\n      m2=(o2_1+o2_2+o2_3+o2_4)/4.0;\n\n      c1=(abs(o1_1-o1_2)+abs(o1_1-o1_3)+abs(o1_1-o1_4)+abs(o1_2-o1_3)+abs(o1_3-o1_4)+abs(o1_2-o1_4))/6.0;\n      c2=(abs(o2_1-o2_2)+abs(o2_1-o2_3)+abs(o2_1-o2_4)+abs(o2_2-o2_3)+abs(o2_3-o2_4)+abs(o2_2-o2_4))/6.0;\n      if((img[j*width+i][3]<maximum*0.95)&&(c1<maximum*thr)&&(c2<maximum*thr))\n      {\n        f = image[j*width+i][3]*m1/m2;\n        image[j*width+i][3]=f>0xffff?0xffff:f;\n      }\n    }\n  free(img);\n}\n\nvoid CLASS scale_colors()\n{\n  unsigned bottom, right, size, row, col, ur, uc, i, x, y, c, sum[8];\n  int val, dark, sat;\n  double dsum[8], dmin, dmax;\n  float scale_mul[4], fr, fc;\n  ushort *img=0, *pix;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS,0,2);\n#endif\n\n  if (user_mul[0])\n    memcpy (pre_mul, user_mul, sizeof pre_mul);\n  if (use_auto_wb || (use_camera_wb && cam_mul[0] == -1)) {\n    memset (dsum, 0, sizeof dsum);\n    bottom = MIN (greybox[1]+greybox[3], height);\n    right  = MIN (greybox[0]+greybox[2], width);\n    for (row=greybox[1]; row < bottom; row += 8)\n      for (col=greybox[0]; col < right; col += 8) {\n\tmemset (sum, 0, sizeof sum);\n\tfor (y=row; y < row+8 && y < bottom; y++)\n\t  for (x=col; x < col+8 && x < right; x++)\n\t    FORC4 {\n\t      if (filters) {\n\t\tc = fcol(y,x);\n\t\tval = BAYER2(y,x);\n\t      } else\n\t\tval = image[y*width+x][c];\n\t      if (val > maximum-25) goto skip_block;\n\t      if ((val -= cblack[c]) < 0) val = 0;\n\t      sum[c] += val;\n\t      sum[c+4]++;\n\t      if (filters) break;\n\t    }\n\tFORC(8) dsum[c] += sum[c];\nskip_block: ;\n      }\n    FORC4 if (dsum[c]) pre_mul[c] = dsum[c+4] / dsum[c];\n  }\n  if (use_camera_wb && cam_mul[0] != -1) {\n    memset (sum, 0, sizeof sum);\n    for (row=0; row < 8; row++)\n      for (col=0; col < 8; col++) {\n\tc = FC(row,col);\n\tif ((val = white[row][col] - cblack[c]) > 0)\n\t  sum[c] += val;\n\tsum[c+4]++;\n      }\n    if (sum[0] && sum[1] && sum[2] && sum[3])\n      FORC4 pre_mul[c] = (float) sum[c+4] / sum[c];\n    else if (cam_mul[0] && cam_mul[2])\n      memcpy (pre_mul, cam_mul, sizeof pre_mul);\n    else\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n            imgdata.process_warnings |= LIBRAW_WARN_BAD_CAMERA_WB;\n#endif\n#ifdef DCRAW_VERBOSE\n            fprintf (stderr,_(\"%s: Cannot use camera white balance.\\n\"), ifname);\n#endif\n      }\n  }\n  if (pre_mul[3] == 0) pre_mul[3] = colors < 4 ? pre_mul[1] : 1;\n  dark = black;\n  sat = maximum;\n  if (threshold) wavelet_denoise();\n  maximum -= black;\n  for (dmin=DBL_MAX, dmax=c=0; c < 4; c++) {\n    if (dmin > pre_mul[c])\n\tdmin = pre_mul[c];\n    if (dmax < pre_mul[c])\n\tdmax = pre_mul[c];\n  }\n  if (!highlight) dmax = dmin;\n  FORC4 scale_mul[c] = (pre_mul[c] /= dmax) * 65535.0 / maximum;\n#ifdef DCRAW_VERBOSE\n  if (verbose) {\n    fprintf (stderr,\n      _(\"Scaling with darkness %d, saturation %d, and\\nmultipliers\"), dark, sat);\n    FORC4 fprintf (stderr, \" %f\", pre_mul[c]);\n    fputc ('\\n', stderr);\n  }\n#endif\n  size = iheight*iwidth;\n#ifdef LIBRAW_LIBRARY_BUILD\n  scale_colors_loop(scale_mul);\n#else\n  for (i=0; i < size*4; i++) {\n    val = image[0][i];\n    if (!val) continue;\n    val -= cblack[i & 3];\n    val *= scale_mul[i & 3];\n    image[0][i] = CLIP(val);\n  }\n#endif\n  if ((aber[0] != 1 || aber[2] != 1) && colors == 3) {\n#ifdef DCRAW_VERBOSE\n    if (verbose)\n      fprintf (stderr,_(\"Correcting chromatic aberration...\\n\"));\n#endif\n    for (c=0; c < 4; c+=2) {\n      if (aber[c] == 1) continue;\n      img = (ushort *) malloc (size * sizeof *img);\n      merror (img, \"scale_colors()\");\n      for (i=0; i < size; i++)\n\timg[i] = image[i][c];\n      for (row=0; row < iheight; row++) {\n\tur = fr = (row - iheight*0.5) * aber[c] + iheight*0.5;\n\tif (ur > iheight-2) continue;\n\tfr -= ur;\n\tfor (col=0; col < iwidth; col++) {\n\t  uc = fc = (col - iwidth*0.5) * aber[c] + iwidth*0.5;\n\t  if (uc > iwidth-2) continue;\n\t  fc -= uc;\n\t  pix = img + ur*iwidth + uc;\n\t  image[row*iwidth+col][c] =\n\t    (pix[     0]*(1-fc) + pix[       1]*fc) * (1-fr) +\n\t    (pix[iwidth]*(1-fc) + pix[iwidth+1]*fc) * fr;\n\t}\n      }\n      free(img);\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS,1,2);\n#endif\n}\n\nvoid CLASS pre_interpolate()\n{\n  ushort (*img)[4];\n  int row, col, c;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE,0,2);\n#endif\n  if (shrink) {\n    if (half_size) {\n      height = iheight;\n      width  = iwidth;\n    } else {\n      img = (ushort (*)[4]) calloc (height*width, sizeof *img);\n      merror (img, \"pre_interpolate()\");\n      for (row=0; row < height; row++)\n\tfor (col=0; col < width; col++) {\n\t  c = fcol(row,col);\n\t  img[row*width+col][c] = image[(row >> 1)*iwidth+(col >> 1)][c];\n\t}\n      free (image);\n      image = img;\n      shrink = 0;\n    }\n  }\n  if (filters > 1000 && colors == 3) {\n    if (four_color_rgb && colors++)\n      mix_green = !half_size;\n    else {\n      for (row = FC(1,0) >> 1; row < height; row+=2)\n\tfor (col = FC(row,1) & 1; col < width; col+=2)\n\t  image[row*width+col][1] = image[row*width+col][3];\n      filters &= ~((filters & 0x55555555) << 1);\n    }\n  }\n  if (half_size) filters = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE,1,2);\n#endif\n}\n\nvoid CLASS border_interpolate (int border)\n{\n  unsigned row, col, y, x, f, c, sum[8];\n\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++) {\n      if (col==border && row >= border && row < height-border)\n\tcol = width-border;\n      memset (sum, 0, sizeof sum);\n      for (y=row-1; y != row+2; y++)\n\tfor (x=col-1; x != col+2; x++)\n\t  if (y < height && x < width) {\n\t    f = fcol(y,x);\n\t    sum[f] += image[y*width+x][f];\n\t    sum[f+4]++;\n\t  }\n      f = fcol(row,col);\n      FORCC if (c != f && sum[c+4])\n\timage[row*width+col][c] = sum[c] / sum[c+4];\n    }\n}\n\nvoid CLASS lin_interpolate_loop(int code[16][16][32],int size)\n{\n  int row;\n  for (row=1; row < height-1; row++)\n    {\n      int col,*ip;\n      ushort *pix;\n      for (col=1; col < width-1; col++) {\n        int i;\n        int sum[4];\n        pix = image[row*width+col];\n        ip = code[row % size][col % size];\n        memset (sum, 0, sizeof sum);\n        for (i=*ip++; i--; ip+=3)\n          sum[ip[2]] += pix[ip[0]] << ip[1];\n        for (i=colors; --i; ip+=2)\n          pix[ip[0]] = sum[ip[0]] * ip[1] >> 8;\n      }\n    }\n}\n\nvoid CLASS lin_interpolate()\n{\n  int code[16][16][32], size=16, *ip, sum[4];\n  int f, c, x, y, row, col, shift, color;\n\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Bilinear interpolation...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,0,3);\n#endif\n\n  if (filters == 2) size = 6;\n  border_interpolate(1);\n  for (row=0; row < size; row++)\n    for (col=0; col < size; col++) {\n      ip = code[row][col]+1;\n      f = fcol(row,col);\n      memset (sum, 0, sizeof sum);\n      for (y=-1; y <= 1; y++)\n\tfor (x=-1; x <= 1; x++) {\n\t  shift = (y==0) + (x==0);\n\t  color = fcol(row+y,col+x);\n\t  if (color == f) continue;\n\t  *ip++ = (width*y + x)*4 + color;\n\t  *ip++ = shift;\n\t  *ip++ = color;\n\t  sum[color] += 1 << shift;\n\t}\n      code[row][col][0] = (ip - code[row][col]) / 3;\n      FORCC\n\tif (c != f) {\n\t  *ip++ = c;\n\t  *ip++ = 256 / sum[c];\n\t}\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,1,3);\n#endif\n  lin_interpolate_loop(code,size);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,2,3);\n#endif\n}\n\n/*\n   This algorithm is officially called:\n\n   \"Interpolation using a Threshold-based variable number of gradients\"\n\n   described in http://scien.stanford.edu/pages/labsite/1999/psych221/projects/99/tingchen/algodep/vargra.html\n\n   I've extended the basic idea to work with non-Bayer filter arrays.\n   Gradients are numbered clockwise from NW=0 to W=7.\n */\nvoid CLASS vng_interpolate()\n{\n  static const signed char *cp, terms[] = {\n    -2,-2,+0,-1,0,0x01, -2,-2,+0,+0,1,0x01, -2,-1,-1,+0,0,0x01,\n    -2,-1,+0,-1,0,0x02, -2,-1,+0,+0,0,0x03, -2,-1,+0,+1,1,0x01,\n    -2,+0,+0,-1,0,0x06, -2,+0,+0,+0,1,0x02, -2,+0,+0,+1,0,0x03,\n    -2,+1,-1,+0,0,0x04, -2,+1,+0,-1,1,0x04, -2,+1,+0,+0,0,0x06,\n    -2,+1,+0,+1,0,0x02, -2,+2,+0,+0,1,0x04, -2,+2,+0,+1,0,0x04,\n    -1,-2,-1,+0,0,0x80, -1,-2,+0,-1,0,0x01, -1,-2,+1,-1,0,0x01,\n    -1,-2,+1,+0,1,0x01, -1,-1,-1,+1,0,0x88, -1,-1,+1,-2,0,0x40,\n    -1,-1,+1,-1,0,0x22, -1,-1,+1,+0,0,0x33, -1,-1,+1,+1,1,0x11,\n    -1,+0,-1,+2,0,0x08, -1,+0,+0,-1,0,0x44, -1,+0,+0,+1,0,0x11,\n    -1,+0,+1,-2,1,0x40, -1,+0,+1,-1,0,0x66, -1,+0,+1,+0,1,0x22,\n    -1,+0,+1,+1,0,0x33, -1,+0,+1,+2,1,0x10, -1,+1,+1,-1,1,0x44,\n    -1,+1,+1,+0,0,0x66, -1,+1,+1,+1,0,0x22, -1,+1,+1,+2,0,0x10,\n    -1,+2,+0,+1,0,0x04, -1,+2,+1,+0,1,0x04, -1,+2,+1,+1,0,0x04,\n    +0,-2,+0,+0,1,0x80, +0,-1,+0,+1,1,0x88, +0,-1,+1,-2,0,0x40,\n    +0,-1,+1,+0,0,0x11, +0,-1,+2,-2,0,0x40, +0,-1,+2,-1,0,0x20,\n    +0,-1,+2,+0,0,0x30, +0,-1,+2,+1,1,0x10, +0,+0,+0,+2,1,0x08,\n    +0,+0,+2,-2,1,0x40, +0,+0,+2,-1,0,0x60, +0,+0,+2,+0,1,0x20,\n    +0,+0,+2,+1,0,0x30, +0,+0,+2,+2,1,0x10, +0,+1,+1,+0,0,0x44,\n    +0,+1,+1,+2,0,0x10, +0,+1,+2,-1,1,0x40, +0,+1,+2,+0,0,0x60,\n    +0,+1,+2,+1,0,0x20, +0,+1,+2,+2,0,0x10, +1,-2,+1,+0,0,0x80,\n    +1,-1,+1,+1,0,0x88, +1,+0,+1,+2,0,0x08, +1,+0,+2,-1,0,0x40,\n    +1,+0,+2,+1,0,0x10\n  }, chood[] = { -1,-1, -1,0, -1,+1, 0,+1, +1,+1, +1,0, +1,-1, 0,-1 };\n  ushort (*brow[5])[4], *pix;\n  int prow=8, pcol=2, *ip, *code[16][16], gval[8], gmin, gmax, sum[4];\n  int row, col, x, y, x1, x2, y1, y2, t, weight, grads, color, diag;\n  int g, diff, thold, num, c;\n\n  lin_interpolate();\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"VNG interpolation...\\n\"));\n#endif\n\n  if (filters == 1) prow = pcol = 16;\n  if (filters == 2) prow = pcol =  6;\n  ip = (int *) calloc (prow*pcol, 1280);\n  merror (ip, \"vng_interpolate()\");\n  for (row=0; row < prow; row++)\t\t/* Precalculate for VNG */\n    for (col=0; col < pcol; col++) {\n      code[row][col] = ip;\n      for (cp=terms, t=0; t < 64; t++) {\n\ty1 = *cp++;  x1 = *cp++;\n\ty2 = *cp++;  x2 = *cp++;\n\tweight = *cp++;\n\tgrads = *cp++;\n\tcolor = fcol(row+y1,col+x1);\n\tif (fcol(row+y2,col+x2) != color) continue;\n\tdiag = (fcol(row,col+1) == color && fcol(row+1,col) == color) ? 2:1;\n\tif (abs(y1-y2) == diag && abs(x1-x2) == diag) continue;\n\t*ip++ = (y1*width + x1)*4 + color;\n\t*ip++ = (y2*width + x2)*4 + color;\n\t*ip++ = weight;\n\tfor (g=0; g < 8; g++)\n\t  if (grads & 1<<g) *ip++ = g;\n\t*ip++ = -1;\n      }\n      *ip++ = INT_MAX;\n      for (cp=chood, g=0; g < 8; g++) {\n\ty = *cp++;  x = *cp++;\n\t*ip++ = (y*width + x) * 4;\n\tcolor = fcol(row,col);\n\tif (fcol(row+y,col+x) != color && fcol(row+y*2,col+x*2) == color)\n\t  *ip++ = (y*width + x) * 8 + color;\n\telse\n\t  *ip++ = 0;\n      }\n    }\n  brow[4] = (ushort (*)[4]) calloc (width*3, sizeof **brow);\n  merror (brow[4], \"vng_interpolate()\");\n  for (row=0; row < 3; row++)\n    brow[row] = brow[4] + row*width;\n  for (row=2; row < height-2; row++) {\t\t/* Do VNG interpolation */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if(!((row-2)%256))RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,(row-2)/256+1,((height-3)/256)+1);\n#endif\n    for (col=2; col < width-2; col++) {\n      pix = image[row*width+col];\n      ip = code[row % prow][col % pcol];\n      memset (gval, 0, sizeof gval);\n      while ((g = ip[0]) != INT_MAX) {\t\t/* Calculate gradients */\n\tdiff = ABS(pix[g] - pix[ip[1]]) << ip[2];\n\tgval[ip[3]] += diff;\n\tip += 5;\n\tif ((g = ip[-1]) == -1) continue;\n\tgval[g] += diff;\n\twhile ((g = *ip++) != -1)\n\t  gval[g] += diff;\n      }\n      ip++;\n      gmin = gmax = gval[0];\t\t\t/* Choose a threshold */\n      for (g=1; g < 8; g++) {\n\tif (gmin > gval[g]) gmin = gval[g];\n\tif (gmax < gval[g]) gmax = gval[g];\n      }\n      if (gmax == 0) {\n\tmemcpy (brow[2][col], pix, sizeof *image);\n\tcontinue;\n      }\n      thold = gmin + (gmax >> 1);\n      memset (sum, 0, sizeof sum);\n      color = fcol(row,col);\n      for (num=g=0; g < 8; g++,ip+=2) {\t\t/* Average the neighbors */\n\tif (gval[g] <= thold) {\n\t  FORCC\n\t    if (c == color && ip[1])\n\t      sum[c] += (pix[c] + pix[ip[1]]) >> 1;\n\t    else\n\t      sum[c] += pix[ip[0] + c];\n\t  num++;\n\t}\n      }\n      FORCC {\t\t\t\t\t/* Save to buffer */\n\tt = pix[color];\n\tif (c != color)\n\t  t += (sum[c] - sum[color]) / num;\n\tbrow[2][col][c] = CLIP(t);\n      }\n    }\n    if (row > 3)\t\t\t\t/* Write buffer to image */\n      memcpy (image[(row-2)*width+2], brow[0]+2, (width-4)*sizeof *image);\n    for (g=0; g < 4; g++)\n      brow[(g-1) & 3] = brow[g];\n  }\n  memcpy (image[(row-2)*width+2], brow[0]+2, (width-4)*sizeof *image);\n  memcpy (image[(row-1)*width+2], brow[1]+2, (width-4)*sizeof *image);\n  free (brow[4]);\n  free (code[0][0]);\n}\n\n/*\n   Patterned Pixel Grouping Interpolation by Alain Desbiolles\n*/\nvoid CLASS ppg_interpolate()\n{\n  int dir[5] = { 1, width, -1, -width, 1 };\n  int row, col, diff[2], guess[2], c, d, i;\n  ushort (*pix)[4];\n\n  border_interpolate(3);\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"PPG interpolation...\\n\"));\n#endif\n\n/*  Fill in the green layer with gradients and pattern recognition: */\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,0,3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row=3; row < height-3; row++)\n    for (col=3+(FC(row,3) & 1), c=FC(row,col); col < width-3; col+=2) {\n      pix = image + row*width+col;\n      for (i=0; (d=dir[i]) > 0; i++) {\n\tguess[i] = (pix[-d][1] + pix[0][c] + pix[d][1]) * 2\n\t\t      - pix[-2*d][c] - pix[2*d][c];\n\tdiff[i] = ( ABS(pix[-2*d][c] - pix[ 0][c]) +\n\t\t    ABS(pix[ 2*d][c] - pix[ 0][c]) +\n\t\t    ABS(pix[  -d][1] - pix[ d][1]) ) * 3 +\n\t\t  ( ABS(pix[ 3*d][1] - pix[ d][1]) +\n\t\t    ABS(pix[-3*d][1] - pix[-d][1]) ) * 2;\n      }\n      d = dir[i = diff[0] > diff[1]];\n      pix[0][1] = ULIM(guess[i] >> 2, pix[d][1], pix[-d][1]);\n    }\n/*  Calculate red and blue for each green pixel:\t\t*/\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,1,3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row=1; row < height-1; row++)\n    for (col=1+(FC(row,2) & 1), c=FC(row,col+1); col < width-1; col+=2) {\n      pix = image + row*width+col;\n      for (i=0; (d=dir[i]) > 0; c=2-c, i++)\n\tpix[0][c] = CLIP((pix[-d][c] + pix[d][c] + 2*pix[0][1]\n\t\t\t- pix[-d][1] - pix[d][1]) >> 1);\n    }\n/*  Calculate blue for red pixels and vice versa:\t\t*/\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,2,3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row=1; row < height-1; row++)\n    for (col=1+(FC(row,1) & 1), c=2-FC(row,col); col < width-1; col+=2) {\n      pix = image + row*width+col;\n      for (i=0; (d=dir[i]+dir[i+1]) > 0; i++) {\n\tdiff[i] = ABS(pix[-d][c] - pix[d][c]) +\n\t\t  ABS(pix[-d][1] - pix[0][1]) +\n\t\t  ABS(pix[ d][1] - pix[0][1]);\n\tguess[i] = pix[-d][c] + pix[d][c] + 2*pix[0][1]\n\t\t - pix[-d][1] - pix[d][1];\n      }\n      if (diff[0] != diff[1])\n\tpix[0][c] = CLIP(guess[diff[0] > diff[1]] >> 1);\n      else\n\tpix[0][c] = CLIP((guess[0]+guess[1]) >> 2);\n    }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n/*\n   Adaptive Homogeneity-Directed interpolation is based on\n   the work of Keigo Hirakawa, Thomas Parks, and Paul Lee.\n */\n#define TS 256\t\t/* Tile Size */\nstatic float dcraw_cbrt[0x10000] = {-1.0f};\n\nstatic inline float calc_64cbrt(float f)\n{\n  unsigned u;\n  static float lower = dcraw_cbrt[0];\n  static float upper = dcraw_cbrt[0xffff];\n\n  if (f <= 0) {\n    return lower;\n  }\n\n  u = (unsigned) f;\n  if (u >= 0xffff) {\n    return upper;\n  }\n  return dcraw_cbrt[u];\n}\nvoid CLASS ahd_interpolate_green_h_and_v(int top, int left, ushort (*out_rgb)[TS][TS][3])\n{\n  int row, col;\n  int c, val;\n  ushort (*pix)[4];\n  const int rowlimit = MIN(top+TS, height-2);\n  const int collimit = MIN(left+TS, width-2);\n\n  for (row = top; row < rowlimit; row++) {\n    col = left + (FC(row,left) & 1);\n    for (c = FC(row,col); col < collimit; col+=2) {\n      pix = image + row*width+col;\n      val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2\n            - pix[-2][c] - pix[2][c]) >> 2;\n      out_rgb[0][row-top][col-left][1] = ULIM(val,pix[-1][1],pix[1][1]);\n      val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2\n            - pix[-2*width][c] - pix[2*width][c]) >> 2;\n      out_rgb[1][row-top][col-left][1] = ULIM(val,pix[-width][1],pix[width][1]);\n    }\n  }\n}\nvoid CLASS ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][3], short (*out_lab)[TS][3], const float (&xyz_cam)[3][4])\n{\n  unsigned row, col;\n  int c, val;\n  ushort (*pix)[4];\n  ushort (*rix)[3];\n  short (*lix)[3];\n  float xyz[3];\n  const unsigned num_pix_per_row = 4*width;\n  const unsigned rowlimit = MIN(top+TS-1, height-3);\n  const unsigned collimit = MIN(left+TS-1, width-3);\n  ushort *pix_above;\n  ushort *pix_below;\n  int t1, t2;\n\n  for (row = top+1; row < rowlimit; row++) {\n    pix = image + row*width + left;\n    rix = &inout_rgb[row-top][0];\n    lix = &out_lab[row-top][0];\n\n    for (col = left+1; col < collimit; col++) {\n      pix++;\n      pix_above = &pix[0][0] - num_pix_per_row;\n      pix_below = &pix[0][0] + num_pix_per_row;\n      rix++;\n      lix++;\n\n      c = 2 - FC(row, col);\n\n      if (c == 1) {\n        c = FC(row+1,col);\n\tt1 = 2-c;\n        val = pix[0][1] + (( pix[-1][t1] + pix[1][t1]\n              - rix[-1][1] - rix[1][1] ) >> 1);\n        rix[0][t1] = CLIP(val);\n        val = pix[0][1] + (( pix_above[c] + pix_below[c]\n              - rix[-TS][1] - rix[TS][1] ) >> 1);\n      } else {\n\tt1 = -4+c; /* -4+c: pixel of color c to the left */\n\tt2 = 4+c; /* 4+c: pixel of color c to the right */\n        val = rix[0][1] + (( pix_above[t1] + pix_above[t2]\n              + pix_below[t1] + pix_below[t2]\n              - rix[-TS-1][1] - rix[-TS+1][1]\n              - rix[+TS-1][1] - rix[+TS+1][1] + 1) >> 2);\n      }\n      rix[0][c] = CLIP(val);\n      c = FC(row,col);\n      rix[0][c] = pix[0][c];\n      xyz[0] = xyz[1] = xyz[2] = 0.5;\n      FORC3 {\n\t/*\n\t * Technically this ought to be FORCC, but the rest of\n\t * ahd_interpolate() assumes 3 colors so let's help the compiler.\n\t */\n        xyz[0] += xyz_cam[0][c] * rix[0][c];\n        xyz[1] += xyz_cam[1][c] * rix[0][c];\n        xyz[2] += xyz_cam[2][c] * rix[0][c];\n      }\n      FORC3 {\n\txyz[c] = calc_64cbrt(xyz[c]);\n      }\n      lix[0][0] = (116 * xyz[1] - 16);\n      lix[0][1] = 500 * (xyz[0] - xyz[1]);\n      lix[0][2] = 200 * (xyz[1] - xyz[2]);\n    }\n  }\n}\nvoid CLASS ahd_interpolate_r_and_b_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][TS][3], short (*out_lab)[TS][TS][3], const float (&xyz_cam)[3][4])\n{\n  int direction;\n  for (direction = 0; direction < 2; direction++) {\n    ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(top, left, inout_rgb[direction], out_lab[direction], xyz_cam);\n  }\n}\nvoid CLASS ahd_interpolate_build_homogeneity_map(int top, int left, short (*lab)[TS][TS][3], char (*out_homogeneity_map)[TS][2])\n{\n  int row, col;\n  int tr, tc;\n  int direction;\n  int i;\n  short (*lix)[3];\n  short (*lixs[2])[3];\n  short *adjacent_lix;\n  unsigned ldiff[2][4], abdiff[2][4], leps, abeps;\n  static const int dir[4] = { -1, 1, -TS, TS };\n  const int rowlimit = MIN(top+TS-2, height-4);\n  const int collimit = MIN(left+TS-2, width-4);\n  int homogeneity;\n  char (*homogeneity_map_p)[2];\n\n  memset (out_homogeneity_map, 0, 2*TS*TS);\n\n  for (row=top+2; row < rowlimit; row++) {\n    tr = row-top;\n    homogeneity_map_p = &out_homogeneity_map[tr][1];\n    for (direction=0; direction < 2; direction++) {\n      lixs[direction] = &lab[direction][tr][1];\n    }\n\n    for (col=left+2; col < collimit; col++) {\n      tc = col-left;\n      homogeneity_map_p++;\n\n      for (direction=0; direction < 2; direction++) {\n        lix = ++lixs[direction];\n        for (i=0; i < 4; i++) {\n\t  adjacent_lix = lix[dir[i]];\n          ldiff[direction][i] = ABS(lix[0][0]-adjacent_lix[0]);\n          abdiff[direction][i] = SQR(lix[0][1]-adjacent_lix[1])\n            + SQR(lix[0][2]-adjacent_lix[2]);\n        }\n      }\n      leps = MIN(MAX(ldiff[0][0],ldiff[0][1]),\n          MAX(ldiff[1][2],ldiff[1][3]));\n      abeps = MIN(MAX(abdiff[0][0],abdiff[0][1]),\n          MAX(abdiff[1][2],abdiff[1][3]));\n      for (direction=0; direction < 2; direction++) {\n\thomogeneity = 0;\n        for (i=0; i < 4; i++) {\n          if (ldiff[direction][i] <= leps && abdiff[direction][i] <= abeps) {\n\t    homogeneity++;\n\t  }\n\t}\n\thomogeneity_map_p[0][direction] = homogeneity;\n      }\n    }\n  }\n}\nvoid CLASS ahd_interpolate_combine_homogeneous_pixels(int top, int left, ushort (*rgb)[TS][TS][3], char (*homogeneity_map)[TS][2])\n{\n  int row, col;\n  int tr, tc;\n  int i, j;\n  int direction;\n  int hm[2];\n  int c;\n  const int rowlimit = MIN(top+TS-3, height-5);\n  const int collimit = MIN(left+TS-3, width-5);\n\n  ushort (*pix)[4];\n  ushort (*rix[2])[3];\n\n  for (row=top+3; row < rowlimit; row++) {\n    tr = row-top;\n    pix = &image[row*width+left+2];\n    for (direction = 0; direction < 2; direction++) {\n      rix[direction] = &rgb[direction][tr][2];\n    }\n\n    for (col=left+3; col < collimit; col++) {\n      tc = col-left;\n      pix++;\n      for (direction = 0; direction < 2; direction++) {\n        rix[direction]++;\n      }\n\n      for (direction=0; direction < 2; direction++) {\n        hm[direction] = 0;\n        for (i=tr-1; i <= tr+1; i++) {\n          for (j=tc-1; j <= tc+1; j++) {\n            hm[direction] += homogeneity_map[i][j][direction];\n          }\n        }\n      }\n      if (hm[0] != hm[1]) {\n        memcpy(pix[0], rix[hm[1] > hm[0]][0], 3 * sizeof(ushort));\n      } else {\n        FORC3 {\n          pix[0][c] = (rix[0][0][c] + rix[1][0][c]) >> 1;\n        }\n      }\n    }\n  }\n}\nvoid CLASS ahd_interpolate()\n{\n  int i, j, k, top, left;\n  float xyz_cam[3][4],r;\n  char *buffer;\n  ushort (*rgb)[TS][TS][3];\n  short (*lab)[TS][TS][3];\n  char (*homo)[TS][2];\n  int terminate_flag = 0;\n\n  if(dcraw_cbrt[0]<-0.1){\n      for (i=0x10000-1; i >=0; i--) {\n          r = i / 65535.0;\n          dcraw_cbrt[i] = 64.0*(r > 0.008856 ? pow((double)r,1/3.0) : 7.787*r + 16/116.0);\n      }\n  }\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"AHD interpolation...\\n\"));\n#endif\n\n  for (i=0; i < 3; i++) {\n    for (j=0; j < colors; j++) {\n      xyz_cam[i][j] = 0;\n      for (k=0; k < 3; k++) {\n        xyz_cam[i][j] += xyz_rgb[i][k] * rgb_cam[k][j] / d65_white[i];\n      }\n    }\n  }\n\n  border_interpolate(5);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel private(buffer,rgb,lab,homo,top,left,i,j,k) shared(xyz_cam,terminate_flag)\n#endif\n#endif\n  {\n    buffer = (char *) malloc (26*TS*TS);\t\t/* 1664 kB */\n    merror (buffer, \"ahd_interpolate()\");\n    rgb  = (ushort(*)[TS][TS][3]) buffer;\n    lab  = (short (*)[TS][TS][3])(buffer + 12*TS*TS);\n    homo = (char  (*)[TS][2])    (buffer + 24*TS*TS);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp for schedule(dynamic)\n#endif\n#endif\n    for (top=2; top < height-5; top += TS-6){\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n        if(0== omp_get_thread_num())\n#endif\n           if(callbacks.progress_cb) {                                     \n               int rr = (*callbacks.progress_cb)(callbacks.progresscb_data,LIBRAW_PROGRESS_INTERPOLATE,top-2,height-7);\n               if(rr)\n                   terminate_flag = 1;\n           }\n#endif\n        for (left=2; !terminate_flag && (left < width-5); left += TS-6) {\n            ahd_interpolate_green_h_and_v(top, left, rgb);\n            ahd_interpolate_r_and_b_and_convert_to_cielab(top, left, rgb, lab, xyz_cam);\n            ahd_interpolate_build_homogeneity_map(top, left, lab, homo);\n            ahd_interpolate_combine_homogeneous_pixels(top, left, rgb, homo);\n      }\n    }\n    free (buffer);\n  }\n#ifdef LIBRAW_LIBRARY_BUILD \n  if(terminate_flag)\n      throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#endif\n}\n\n\n\n#undef TS\n\n#else\n/*\n   Adaptive Homogeneity-Directed interpolation is based on\n   the work of Keigo Hirakawa, Thomas Parks, and Paul Lee.\n */\n#define TS 256\t\t/* Tile Size */\n\nvoid CLASS ahd_interpolate()\n{\n  int i, j, k, top, left, row, col, tr, tc, c, d, val, hm[2];\n  ushort (*pix)[4], (*rix)[3];\n  static const int dir[4] = { -1, 1, -TS, TS };\n  unsigned ldiff[2][4], abdiff[2][4], leps, abeps;\n  float r, cbrt[0x10000], xyz[3], xyz_cam[3][4];\n  ushort (*rgb)[TS][TS][3];\n   short (*lab)[TS][TS][3], (*lix)[3];\n   char (*homo)[TS][TS], *buffer;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"AHD interpolation...\\n\"));\n#endif\n\n  for (i=0; i < 0x10000; i++) {\n    r = i / 65535.0;\n    cbrt[i] = r > 0.008856 ? pow((double)r,(double)(1/3.0)) : 7.787*r + 16/116.0;\n  }\n  for (i=0; i < 3; i++)\n    for (j=0; j < colors; j++)\n      for (xyz_cam[i][j] = k=0; k < 3; k++)\n\txyz_cam[i][j] += xyz_rgb[i][k] * rgb_cam[k][j] / d65_white[i];\n\n  border_interpolate(5);\n  buffer = (char *) malloc (26*TS*TS);\t\t/* 1664 kB */\n  merror (buffer, \"ahd_interpolate()\");\n  rgb  = (ushort(*)[TS][TS][3]) buffer;\n  lab  = (short (*)[TS][TS][3])(buffer + 12*TS*TS);\n  homo = (char  (*)[TS][TS])   (buffer + 24*TS*TS);\n\n  for (top=2; top < height-5; top += TS-6)\n    for (left=2; left < width-5; left += TS-6) {\n\n/*  Interpolate green horizontally and vertically:\t\t*/\n      for (row = top; row < top+TS && row < height-2; row++) {\n\tcol = left + (FC(row,left) & 1);\n\tfor (c = FC(row,col); col < left+TS && col < width-2; col+=2) {\n\t  pix = image + row*width+col;\n\t  val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2\n\t\t- pix[-2][c] - pix[2][c]) >> 2;\n\t  rgb[0][row-top][col-left][1] = ULIM(val,pix[-1][1],pix[1][1]);\n\t  val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2\n\t\t- pix[-2*width][c] - pix[2*width][c]) >> 2;\n\t  rgb[1][row-top][col-left][1] = ULIM(val,pix[-width][1],pix[width][1]);\n\t}\n      }\n/*  Interpolate red and blue, and convert to CIELab:\t\t*/\n      for (d=0; d < 2; d++)\n\tfor (row=top+1; row < top+TS-1 && row < height-3; row++)\n\t  for (col=left+1; col < left+TS-1 && col < width-3; col++) {\n\t    pix = image + row*width+col;\n\t    rix = &rgb[d][row-top][col-left];\n\t    lix = &lab[d][row-top][col-left];\n\t    if ((c = 2 - FC(row,col)) == 1) {\n\t      c = FC(row+1,col);\n\t      val = pix[0][1] + (( pix[-1][2-c] + pix[1][2-c]\n\t\t\t\t - rix[-1][1] - rix[1][1] ) >> 1);\n\t      rix[0][2-c] = CLIP(val);\n\t      val = pix[0][1] + (( pix[-width][c] + pix[width][c]\n\t\t\t\t - rix[-TS][1] - rix[TS][1] ) >> 1);\n\t    } else\n\t      val = rix[0][1] + (( pix[-width-1][c] + pix[-width+1][c]\n\t\t\t\t + pix[+width-1][c] + pix[+width+1][c]\n\t\t\t\t - rix[-TS-1][1] - rix[-TS+1][1]\n\t\t\t\t - rix[+TS-1][1] - rix[+TS+1][1] + 1) >> 2);\n\t    rix[0][c] = CLIP(val);\n\t    c = FC(row,col);\n\t    rix[0][c] = pix[0][c];\n\t    xyz[0] = xyz[1] = xyz[2] = 0.5;\n\t    FORCC {\n\t      xyz[0] += xyz_cam[0][c] * rix[0][c];\n\t      xyz[1] += xyz_cam[1][c] * rix[0][c];\n\t      xyz[2] += xyz_cam[2][c] * rix[0][c];\n\t    }\n\t    xyz[0] = cbrt[CLIP((int) xyz[0])];\n\t    xyz[1] = cbrt[CLIP((int) xyz[1])];\n\t    xyz[2] = cbrt[CLIP((int) xyz[2])];\n\t    lix[0][0] = 64 * (116 * xyz[1] - 16);\n\t    lix[0][1] = 64 * 500 * (xyz[0] - xyz[1]);\n\t    lix[0][2] = 64 * 200 * (xyz[1] - xyz[2]);\n\t  }\n/*  Build homogeneity maps from the CIELab images:\t\t*/\n      memset (homo, 0, 2*TS*TS);\n      for (row=top+2; row < top+TS-2 && row < height-4; row++) {\n\ttr = row-top;\n\tfor (col=left+2; col < left+TS-2 && col < width-4; col++) {\n\t  tc = col-left;\n\t  for (d=0; d < 2; d++) {\n\t    lix = &lab[d][tr][tc];\n\t    for (i=0; i < 4; i++) {\n\t       ldiff[d][i] = ABS(lix[0][0]-lix[dir[i]][0]);\n\t      abdiff[d][i] = SQR(lix[0][1]-lix[dir[i]][1])\n\t\t\t   + SQR(lix[0][2]-lix[dir[i]][2]);\n\t    }\n\t  }\n\t  leps = MIN(MAX(ldiff[0][0],ldiff[0][1]),\n\t\t     MAX(ldiff[1][2],ldiff[1][3]));\n\t  abeps = MIN(MAX(abdiff[0][0],abdiff[0][1]),\n\t\t      MAX(abdiff[1][2],abdiff[1][3]));\n\t  for (d=0; d < 2; d++)\n\t    for (i=0; i < 4; i++)\n\t      if (ldiff[d][i] <= leps && abdiff[d][i] <= abeps)\n\t\thomo[d][tr][tc]++;\n\t}\n      }\n/*  Combine the most homogenous pixels for the final result:\t*/\n      for (row=top+3; row < top+TS-3 && row < height-5; row++) {\n\ttr = row-top;\n\tfor (col=left+3; col < left+TS-3 && col < width-5; col++) {\n\t  tc = col-left;\n\t  for (d=0; d < 2; d++)\n\t    for (hm[d]=0, i=tr-1; i <= tr+1; i++)\n\t      for (j=tc-1; j <= tc+1; j++)\n\t\thm[d] += homo[d][i][j];\n\t  if (hm[0] != hm[1])\n\t    FORC3 image[row*width+col][c] = rgb[hm[1] > hm[0]][tr][tc][c];\n\t  else\n\t    FORC3 image[row*width+col][c] =\n\t\t(rgb[0][tr][tc][c] + rgb[1][tr][tc][c]) >> 1;\n\t}\n      }\n    }\n  free (buffer);\n}\n#undef TS\n#endif\n\nvoid CLASS median_filter()\n{\n  ushort (*pix)[4];\n  int pass, c, i, j, k, med[9];\n  static const uchar opt[] =\t/* Optimal 9-element median search */\n  { 1,2, 4,5, 7,8, 0,1, 3,4, 6,7, 1,2, 4,5, 7,8,\n    0,3, 5,8, 4,7, 3,6, 1,4, 2,5, 4,7, 4,2, 6,4, 4,2 };\n\n  for (pass=1; pass <= med_passes; pass++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n      RUN_CALLBACK(LIBRAW_PROGRESS_MEDIAN_FILTER,pass-1,med_passes);\n#endif\n#ifdef DCRAW_VERBOSE\n    if (verbose)\n      fprintf (stderr,_(\"Median filter pass %d...\\n\"), pass);\n#endif\n    for (c=0; c < 3; c+=2) {\n      for (pix = image; pix < image+width*height; pix++)\n\tpix[0][3] = pix[0][c];\n      for (pix = image+width; pix < image+width*(height-1); pix++) {\n\tif ((pix-image+1) % width < 2) continue;\n\tfor (k=0, i = -width; i <= width; i += width)\n\t  for (j = i-1; j <= i+1; j++)\n\t    med[k++] = pix[j][3] - pix[j][1];\n\tfor (i=0; i < sizeof opt; i+=2)\n\t  if     (med[opt[i]] > med[opt[i+1]])\n\t    SWAP (med[opt[i]] , med[opt[i+1]]);\n\tpix[0][c] = CLIP(med[4] + pix[0][1]);\n      }\n    }\n  }\n}\n\nvoid CLASS blend_highlights()\n{\n  int clip=INT_MAX, row, col, c, i, j;\n  static const float trans[2][4][4] =\n  { { { 1,1,1 }, { 1.7320508,-1.7320508,0 }, { -1,-1,2 } },\n    { { 1,1,1,1 }, { 1,-1,1,-1 }, { 1,1,-1,-1 }, { 1,-1,-1,1 } } };\n  static const float itrans[2][4][4] =\n  { { { 1,0.8660254,-0.5 }, { 1,-0.8660254,-0.5 }, { 1,0,1 } },\n    { { 1,1,1,1 }, { 1,-1,1,-1 }, { 1,1,-1,-1 }, { 1,-1,-1,1 } } };\n  float cam[2][4], lab[2][4], sum[2], chratio;\n\n  if ((unsigned) (colors-3) > 1) return;\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Blending highlights...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,0,2);\n#endif\n  FORCC if (clip > (i = 65535*pre_mul[c])) clip = i;\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++) {\n      FORCC if (image[row*width+col][c] > clip) break;\n      if (c == colors) continue;\n      FORCC {\n\tcam[0][c] = image[row*width+col][c];\n\tcam[1][c] = MIN(cam[0][c],clip);\n      }\n      for (i=0; i < 2; i++) {\n\tFORCC for (lab[i][c]=j=0; j < colors; j++)\n\t  lab[i][c] += trans[colors-3][c][j] * cam[i][j];\n\tfor (sum[i]=0,c=1; c < colors; c++)\n\t  sum[i] += SQR(lab[i][c]);\n      }\n      chratio = sqrt(sum[1]/sum[0]);\n      for (c=1; c < colors; c++)\n\tlab[0][c] *= chratio;\n      FORCC for (cam[0][c]=j=0; j < colors; j++)\n\tcam[0][c] += itrans[colors-3][c][j] * lab[0][j];\n      FORCC image[row*width+col][c] = cam[0][c] / colors;\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,1,2);\n#endif\n}\n\n#define SCALE (4 >> shrink)\nvoid CLASS recover_highlights()\n{\n  float *map, sum, wgt, grow;\n  int hsat[4], count, spread, change, val, i;\n  unsigned high, wide, mrow, mcol, row, col, kc, c, d, y, x;\n  ushort *pixel;\n  static const signed char dir[8][2] =\n    { {-1,-1}, {-1,0}, {-1,1}, {0,1}, {1,1}, {1,0}, {1,-1}, {0,-1} };\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Rebuilding highlights...\\n\"));\n#endif\n\n  grow = pow (2.0, 4-highlight);\n  FORCC hsat[c] = 32000 * pre_mul[c];\n  for (kc=0, c=1; c < colors; c++)\n    if (pre_mul[kc] < pre_mul[c]) kc = c;\n  high = height / SCALE;\n  wide =  width / SCALE;\n  map = (float *) calloc (high*wide, sizeof *map);\n  merror (map, \"recover_highlights()\");\n  FORCC if (c != kc) {\n#ifdef LIBRAW_LIBRARY_BUILD\n      RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,c-1,colors-1);\n#endif\n    memset (map, 0, high*wide*sizeof *map);\n    for (mrow=0; mrow < high; mrow++)\n      for (mcol=0; mcol < wide; mcol++) {\n\tsum = wgt = count = 0;\n\tfor (row = mrow*SCALE; row < (mrow+1)*SCALE; row++)\n\t  for (col = mcol*SCALE; col < (mcol+1)*SCALE; col++) {\n\t    pixel = image[row*width+col];\n\t    if (pixel[c] / hsat[c] == 1 && pixel[kc] > 24000) {\n\t      sum += pixel[c];\n\t      wgt += pixel[kc];\n\t      count++;\n\t    }\n\t  }\n\tif (count == SCALE*SCALE)\n\t  map[mrow*wide+mcol] = sum / wgt;\n      }\n    for (spread = 32/grow; spread--; ) {\n      for (mrow=0; mrow < high; mrow++)\n\tfor (mcol=0; mcol < wide; mcol++) {\n\t  if (map[mrow*wide+mcol]) continue;\n\t  sum = count = 0;\n\t  for (d=0; d < 8; d++) {\n\t    y = mrow + dir[d][0];\n\t    x = mcol + dir[d][1];\n\t    if (y < high && x < wide && map[y*wide+x] > 0) {\n\t      sum  += (1 + (d & 1)) * map[y*wide+x];\n\t      count += 1 + (d & 1);\n\t    }\n\t  }\n\t  if (count > 3)\n\t    map[mrow*wide+mcol] = - (sum+grow) / (count+grow);\n\t}\n      for (change=i=0; i < high*wide; i++)\n\tif (map[i] < 0) {\n\t  map[i] = -map[i];\n\t  change = 1;\n\t}\n      if (!change) break;\n    }\n    for (i=0; i < high*wide; i++)\n      if (map[i] == 0) map[i] = 1;\n    for (mrow=0; mrow < high; mrow++)\n      for (mcol=0; mcol < wide; mcol++) {\n\tfor (row = mrow*SCALE; row < (mrow+1)*SCALE; row++)\n\t  for (col = mcol*SCALE; col < (mcol+1)*SCALE; col++) {\n\t    pixel = image[row*width+col];\n\t    if (pixel[c] / hsat[c] > 1) {\n\t      val = pixel[kc] * map[mrow*wide+mcol];\n\t      if (pixel[c] < val) pixel[c] = CLIP(val);\n\t    }\n\t  }\n      }\n  }\n  free (map);\n}\n#undef SCALE\n\nvoid CLASS tiff_get (unsigned base,\n\tunsigned *tag, unsigned *type, unsigned *len, unsigned *save)\n{\n  *tag  = get2();\n  *type = get2();\n  *len  = get4();\n  *save = ftell(ifp) + 4;\n  if (*len * (\"11124811248488\"[*type < 14 ? *type:0]-'0') > 4)\n    fseek (ifp, get4()+base, SEEK_SET);\n}\n\nvoid CLASS parse_thumb_note (int base, unsigned toff, unsigned tlen)\n{\n  unsigned entries, tag, type, len, save;\n\n  entries = get2();\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    if (tag == toff) thumb_offset = get4()+base;\n    if (tag == tlen) thumb_length = get4();\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n//@end COMMON\n\nint CLASS parse_tiff_ifd (int base);\n\n//@out COMMON\nvoid CLASS parse_makernote (int base, int uptag)\n{\n  static const uchar xlat[2][256] = {\n  { 0xc1,0xbf,0x6d,0x0d,0x59,0xc5,0x13,0x9d,0x83,0x61,0x6b,0x4f,0xc7,0x7f,0x3d,0x3d,\n    0x53,0x59,0xe3,0xc7,0xe9,0x2f,0x95,0xa7,0x95,0x1f,0xdf,0x7f,0x2b,0x29,0xc7,0x0d,\n    0xdf,0x07,0xef,0x71,0x89,0x3d,0x13,0x3d,0x3b,0x13,0xfb,0x0d,0x89,0xc1,0x65,0x1f,\n    0xb3,0x0d,0x6b,0x29,0xe3,0xfb,0xef,0xa3,0x6b,0x47,0x7f,0x95,0x35,0xa7,0x47,0x4f,\n    0xc7,0xf1,0x59,0x95,0x35,0x11,0x29,0x61,0xf1,0x3d,0xb3,0x2b,0x0d,0x43,0x89,0xc1,\n    0x9d,0x9d,0x89,0x65,0xf1,0xe9,0xdf,0xbf,0x3d,0x7f,0x53,0x97,0xe5,0xe9,0x95,0x17,\n    0x1d,0x3d,0x8b,0xfb,0xc7,0xe3,0x67,0xa7,0x07,0xf1,0x71,0xa7,0x53,0xb5,0x29,0x89,\n    0xe5,0x2b,0xa7,0x17,0x29,0xe9,0x4f,0xc5,0x65,0x6d,0x6b,0xef,0x0d,0x89,0x49,0x2f,\n    0xb3,0x43,0x53,0x65,0x1d,0x49,0xa3,0x13,0x89,0x59,0xef,0x6b,0xef,0x65,0x1d,0x0b,\n    0x59,0x13,0xe3,0x4f,0x9d,0xb3,0x29,0x43,0x2b,0x07,0x1d,0x95,0x59,0x59,0x47,0xfb,\n    0xe5,0xe9,0x61,0x47,0x2f,0x35,0x7f,0x17,0x7f,0xef,0x7f,0x95,0x95,0x71,0xd3,0xa3,\n    0x0b,0x71,0xa3,0xad,0x0b,0x3b,0xb5,0xfb,0xa3,0xbf,0x4f,0x83,0x1d,0xad,0xe9,0x2f,\n    0x71,0x65,0xa3,0xe5,0x07,0x35,0x3d,0x0d,0xb5,0xe9,0xe5,0x47,0x3b,0x9d,0xef,0x35,\n    0xa3,0xbf,0xb3,0xdf,0x53,0xd3,0x97,0x53,0x49,0x71,0x07,0x35,0x61,0x71,0x2f,0x43,\n    0x2f,0x11,0xdf,0x17,0x97,0xfb,0x95,0x3b,0x7f,0x6b,0xd3,0x25,0xbf,0xad,0xc7,0xc5,\n    0xc5,0xb5,0x8b,0xef,0x2f,0xd3,0x07,0x6b,0x25,0x49,0x95,0x25,0x49,0x6d,0x71,0xc7 },\n  { 0xa7,0xbc,0xc9,0xad,0x91,0xdf,0x85,0xe5,0xd4,0x78,0xd5,0x17,0x46,0x7c,0x29,0x4c,\n    0x4d,0x03,0xe9,0x25,0x68,0x11,0x86,0xb3,0xbd,0xf7,0x6f,0x61,0x22,0xa2,0x26,0x34,\n    0x2a,0xbe,0x1e,0x46,0x14,0x68,0x9d,0x44,0x18,0xc2,0x40,0xf4,0x7e,0x5f,0x1b,0xad,\n    0x0b,0x94,0xb6,0x67,0xb4,0x0b,0xe1,0xea,0x95,0x9c,0x66,0xdc,0xe7,0x5d,0x6c,0x05,\n    0xda,0xd5,0xdf,0x7a,0xef,0xf6,0xdb,0x1f,0x82,0x4c,0xc0,0x68,0x47,0xa1,0xbd,0xee,\n    0x39,0x50,0x56,0x4a,0xdd,0xdf,0xa5,0xf8,0xc6,0xda,0xca,0x90,0xca,0x01,0x42,0x9d,\n    0x8b,0x0c,0x73,0x43,0x75,0x05,0x94,0xde,0x24,0xb3,0x80,0x34,0xe5,0x2c,0xdc,0x9b,\n    0x3f,0xca,0x33,0x45,0xd0,0xdb,0x5f,0xf5,0x52,0xc3,0x21,0xda,0xe2,0x22,0x72,0x6b,\n    0x3e,0xd0,0x5b,0xa8,0x87,0x8c,0x06,0x5d,0x0f,0xdd,0x09,0x19,0x93,0xd0,0xb9,0xfc,\n    0x8b,0x0f,0x84,0x60,0x33,0x1c,0x9b,0x45,0xf1,0xf0,0xa3,0x94,0x3a,0x12,0x77,0x33,\n    0x4d,0x44,0x78,0x28,0x3c,0x9e,0xfd,0x65,0x57,0x16,0x94,0x6b,0xfb,0x59,0xd0,0xc8,\n    0x22,0x36,0xdb,0xd2,0x63,0x98,0x43,0xa1,0x04,0x87,0x86,0xf7,0xa6,0x26,0xbb,0xd6,\n    0x59,0x4d,0xbf,0x6a,0x2e,0xaa,0x2b,0xef,0xe6,0x78,0xb6,0x4e,0xe0,0x2f,0xdc,0x7c,\n    0xbe,0x57,0x19,0x32,0x7e,0x2a,0xd0,0xb8,0xba,0x29,0x00,0x3c,0x52,0x7d,0xa8,0x49,\n    0x3b,0x2d,0xeb,0x25,0x49,0xfa,0xa3,0xaa,0x39,0xa7,0xc5,0xa7,0x50,0x11,0x36,0xfb,\n    0xc6,0x67,0x4a,0xf5,0xa5,0x12,0x65,0x7e,0xb0,0xdf,0xaf,0x4e,0xb3,0x61,0x7f,0x2f } };\n  unsigned offset=0, entries, tag, type, len, save, c;\n  unsigned ver97=0, serial=0, i, wbi=0, wb[4]={0,0,0,0};\n  uchar buf97[324], ci, cj, ck;\n  short morder, sorder=order;\n  char buf[10];\n/*\n   The MakerNote might have its own TIFF header (possibly with\n   its own byte-order!), or it might just be a table.\n */\n  if (!strcmp(make,\"Nokia\")) return;\n  fread (buf, 1, 10, ifp);\n  if (!strncmp (buf,\"KDK\" ,3) ||\t/* these aren't TIFF tables */\n      !strncmp (buf,\"VER\" ,3) ||\n      !strncmp (buf,\"IIII\",4) ||\n      !strncmp (buf,\"MMMM\",4)) return;\n  if (!strncmp (buf,\"KC\"  ,2) ||\t/* Konica KD-400Z, KD-510Z */\n      !strncmp (buf,\"MLY\" ,3)) {\t/* Minolta DiMAGE G series */\n    order = 0x4d4d;\n    while ((i=ftell(ifp)) < data_offset && i < 16384) {\n      wb[0] = wb[2];  wb[2] = wb[1];  wb[1] = wb[3];\n      wb[3] = get2();\n      if (wb[1] == 256 && wb[3] == 256 &&\n\t  wb[0] > 256 && wb[0] < 640 && wb[2] > 256 && wb[2] < 640)\n\tFORC4 cam_mul[c] = wb[c];\n    }\n    goto quit;\n  }\n  if (!strcmp (buf,\"Nikon\")) {\n    base = ftell(ifp);\n    order = get2();\n    if (get2() != 42) goto quit;\n    offset = get4();\n    fseek (ifp, offset-8, SEEK_CUR);\n  } else if (!strcmp (buf,\"OLYMPUS\")) {\n    base = ftell(ifp)-10;\n    fseek (ifp, -2, SEEK_CUR);\n    order = get2();  get2();\n  } else if (!strncmp (buf,\"SONY\",4) ||\n\t     !strcmp  (buf,\"Panasonic\")) {\n    goto nf;\n  } else if (!strncmp (buf,\"FUJIFILM\",8)) {\n    base = ftell(ifp)-10;\nnf: order = 0x4949;\n    fseek (ifp,  2, SEEK_CUR);\n  } else if (!strcmp (buf,\"OLYMP\") ||\n\t     !strcmp (buf,\"LEICA\") ||\n\t     !strcmp (buf,\"Ricoh\") ||\n\t     !strcmp (buf,\"EPSON\"))\n    fseek (ifp, -2, SEEK_CUR);\n  else if (!strcmp (buf,\"AOC\") ||\n\t   !strcmp (buf,\"QVC\"))\n    fseek (ifp, -4, SEEK_CUR);\n  else {\n    fseek (ifp, -10, SEEK_CUR);\n    if (!strncmp(make,\"SAMSUNG\",7))\n      base = ftell(ifp);\n  }\n  entries = get2();\n  if (entries > 1000) return;\n  morder = order;\n  while (entries--) {\n    order = morder;\n    tiff_get (base, &tag, &type, &len, &save);\n    tag |= uptag << 16;\n    if (tag == 2 && strstr(make,\"NIKON\") && !iso_speed)\n      iso_speed = (get2(),get2());\n    if (tag == 4 && len > 26 && len < 35) {\n      if ((i=(get4(),get2())) != 0x7fff && !iso_speed)\n\tiso_speed = 50 * pow (2, i/32.0 - 4);\n      if ((i=(get2(),get2())) != 0x7fff && !aperture)\n\taperture = pow (2, i/64.0);\n      if ((i=get2()) != 0xffff && !shutter)\n\tshutter = pow (2, (short) i/-32.0);\n      wbi = (get2(),get2());\n      shot_order = (get2(),get2());\n    }\n    if ((tag == 4 || tag == 0x114) && !strncmp(make,\"KONICA\",6)) {\n      fseek (ifp, tag == 4 ? 140:160, SEEK_CUR);\n      switch (get2()) {\n\tcase 72:  flip = 0;  break;\n\tcase 76:  flip = 6;  break;\n\tcase 82:  flip = 5;  break;\n      }\n    }\n    if (tag == 7 && type == 2 && len > 20)\n      fgets (model2, 64, ifp);\n    if (tag == 8 && type == 4)\n      shot_order = get4();\n    if (tag == 9 && !strcmp(make,\"Canon\"))\n      fread (artist, 64, 1, ifp);\n    if (tag == 0xc && len == 4) {\n      cam_mul[0] = getreal(type);\n      cam_mul[2] = getreal(type);\n    }\n    if (tag == 0xd && type == 7 && get2() == 0xaaaa) {\n      for (c=i=2; (ushort) c != 0xbbbb && i < len; i++)\n\tc = c << 8 | fgetc(ifp);\n      while ((i+=4) < len-5)\n\tif (get4() == 257 && (i=len) && (c = (get4(),fgetc(ifp))) < 3)\n\t  flip = \"065\"[c]-'0';\n    }\n    if (tag == 0x10 && type == 4)\n      unique_id = get4();\n    if (tag == 0x11 && is_raw && !strncmp(make,\"NIKON\",5)) {\n      fseek (ifp, get4()+base, SEEK_SET);\n      parse_tiff_ifd (base);\n    }\n    if (tag == 0x14 && type == 7) {\n      if (len == 2560) {\n\tfseek (ifp, 1248, SEEK_CUR);\n\tgoto get2_256;\n      }\n      fread (buf, 1, 10, ifp);\n      if (!strncmp(buf,\"NRW \",4)) {\n\tfseek (ifp, strcmp(buf+4,\"0100\") ? 46:1546, SEEK_CUR);\n\tcam_mul[0] = get4() << 2;\n\tcam_mul[1] = get4() + get4();\n\tcam_mul[2] = get4() << 2;\n      }\n    }\n    if (tag == 0x15 && type == 2 && is_raw)\n      fread (model, 64, 1, ifp);\n    if (strstr(make,\"PENTAX\")) {\n      if (tag == 0x1b) tag = 0x1018;\n      if (tag == 0x1c) tag = 0x1017;\n    }\n    if (tag == 0x1d)\n      while ((c = fgetc(ifp)) && c != EOF)\n\tserial = serial*10 + (isdigit(c) ? c - '0' : c % 10);\n    if (tag == 0x81 && type == 4) {\n      data_offset = get4();\n      fseek (ifp, data_offset + 41, SEEK_SET);\n      raw_height = get2() * 2;\n      raw_width  = get2();\n      filters = 0x61616161;\n    }\n    if (tag == 0x29 && type == 1) {\n      c = wbi < 18 ? \"012347800000005896\"[wbi]-'0' : 0;\n      fseek (ifp, 8 + c*32, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get4();\n    }\n    if ((tag == 0x81  && type == 7) ||\n\t(tag == 0x100 && type == 7) ||\n\t(tag == 0x280 && type == 1)) {\n      thumb_offset = ftell(ifp);\n      thumb_length = len;\n    }\n    if (tag == 0x88 && type == 4 && (thumb_offset = get4()))\n      thumb_offset += base;\n    if (tag == 0x89 && type == 4)\n      thumb_length = get4();\n    if (tag == 0x8c || tag == 0x96)\n      meta_offset = ftell(ifp);\n    if (tag == 0x97) {\n      for (i=0; i < 4; i++)\n\tver97 = ver97 * 10 + fgetc(ifp)-'0';\n      switch (ver97) {\n\tcase 100:\n\t  fseek (ifp, 68, SEEK_CUR);\n\t  FORC4 cam_mul[(c >> 1) | ((c & 1) << 1)] = get2();\n\t  break;\n\tcase 102:\n\t  fseek (ifp, 6, SEEK_CUR);\n\t  goto get2_rggb;\n\tcase 103:\n\t  fseek (ifp, 16, SEEK_CUR);\n\t  FORC4 cam_mul[c] = get2();\n      }\n      if (ver97 >= 200) {\n\tif (ver97 != 205) fseek (ifp, 280, SEEK_CUR);\n\tfread (buf97, 324, 1, ifp);\n      }\n    }\n    if (tag == 0xa1 && type == 7) {\n      order = 0x4949;\n      fseek (ifp, 140, SEEK_CUR);\n      FORC3 cam_mul[c] = get4();\n    }\n    if (tag == 0xa4 && type == 3) {\n      fseek (ifp, wbi*48, SEEK_CUR);\n      FORC3 cam_mul[c] = get2();\n    }\n    if (tag == 0xa7 && (unsigned) (ver97-200) < 17) {\n      ci = xlat[0][serial & 0xff];\n      cj = xlat[1][fgetc(ifp)^fgetc(ifp)^fgetc(ifp)^fgetc(ifp)];\n      ck = 0x60;\n      for (i=0; i < 324; i++)\n\tbuf97[i] ^= (cj += ci * ck++);\n      i = \"66666>666;6A;:;55\"[ver97-200] - '0';\n      FORC4 cam_mul[c ^ (c >> 1) ^ (i & 1)] =\n\tsget2 (buf97 + (i & -2) + c*2);\n    }\n    if (tag == 0x200 && len == 3)\n      shot_order = (get4(),get4());\n    if (tag == 0x200 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2();\n    if (tag == 0x201 && len == 4)\n      goto get2_rggb;\n    if (tag == 0x220 && type == 7)\n      meta_offset = ftell(ifp);\n    if (tag == 0x401 && type == 4 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get4();\n    if (tag == 0xe01) {\t\t/* Nikon Capture Note */\n      order = 0x4949;\n      fseek (ifp, 22, SEEK_CUR);\n      for (offset=22; offset+22 < len; offset += 22+i) {\n\ttag = get4();\n\tfseek (ifp, 14, SEEK_CUR);\n\ti = get4()-4;\n\tif (tag == 0x76a43207) flip = get2();\n\telse fseek (ifp, i, SEEK_CUR);\n      }\n    }\n    if (tag == 0xe80 && len == 256 && type == 7) {\n      fseek (ifp, 48, SEEK_CUR);\n      cam_mul[0] = get2() * 508 * 1.078 / 0x10000;\n      cam_mul[2] = get2() * 382 * 1.173 / 0x10000;\n    }\n    if (tag == 0xf00 && type == 7) {\n      if (len == 614)\n\tfseek (ifp, 176, SEEK_CUR);\n      else if (len == 734 || len == 1502)\n\tfseek (ifp, 148, SEEK_CUR);\n      else goto next;\n      goto get2_256;\n    }\n    if ((tag == 0x1011 && len == 9) || tag == 0x20400200)\n      for (i=0; i < 3; i++)\n\tFORC3 cmatrix[i][c] = ((short) get2()) / 256.0;\n    if ((tag == 0x1012 || tag == 0x20400600) && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2();\n    if (tag == 0x1017 || tag == 0x20400100)\n      cam_mul[0] = get2() / 256.0;\n    if (tag == 0x1018 || tag == 0x20400100)\n      cam_mul[2] = get2() / 256.0;\n    if (tag == 0x2011 && len == 2) {\nget2_256:\n      order = 0x4d4d;\n      cam_mul[0] = get2() / 256.0;\n      cam_mul[2] = get2() / 256.0;\n    }\n    if ((tag | 0x70) == 0x2070 && type == 4)\n      fseek (ifp, get4()+base, SEEK_SET);\n    if (tag == 0x2010 && type != 7)\n      load_raw = &CLASS olympus_load_raw;\n    if (tag == 0x2020)\n      parse_thumb_note (base, 257, 258);\n    if (tag == 0x2040)\n      parse_makernote (base, 0x2040);\n    if (tag == 0xb028) {\n      fseek (ifp, get4()+base, SEEK_SET);\n      parse_thumb_note (base, 136, 137);\n    }\n    if (tag == 0x4001 && len > 500) {\n      i = len == 582 ? 50 : len == 653 ? 68 : len == 5120 ? 142 : 126;\n      fseek (ifp, i, SEEK_CUR);\nget2_rggb:\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n      i = len >> 3 == 164 ? 112:22;\n      fseek (ifp, i, SEEK_CUR);\n      FORC4 sraw_mul[c ^ (c >> 1)] = get2();\n    }\n    if (tag == 0xa021)\n      FORC4 cam_mul[c ^ (c >> 1)] = get4();\n    if (tag == 0xa028)\n      FORC4 cam_mul[c ^ (c >> 1)] -= get4();\nnext:\n    fseek (ifp, save, SEEK_SET);\n  }\nquit:\n  order = sorder;\n}\n\n/*\n   Since the TIFF DateTime string has no timezone information,\n   assume that the camera's clock was set to Universal Time.\n */\nvoid CLASS get_timestamp (int reversed)\n{\n  struct tm t;\n  char str[20];\n  int i;\n\n  str[19] = 0;\n  if (reversed)\n    for (i=19; i--; ) str[i] = fgetc(ifp);\n  else\n    fread (str, 19, 1, ifp);\n  memset (&t, 0, sizeof t);\n  if (sscanf (str, \"%d:%d:%d %d:%d:%d\", &t.tm_year, &t.tm_mon,\n\t&t.tm_mday, &t.tm_hour, &t.tm_min, &t.tm_sec) != 6)\n    return;\n  t.tm_year -= 1900;\n  t.tm_mon -= 1;\n  t.tm_isdst = -1;\n  if (mktime(&t) > 0)\n    timestamp = mktime(&t);\n}\n\nvoid CLASS parse_exif (int base)\n{\n  unsigned kodak, entries, tag, type, len, save, c;\n  double expo;\n\n  kodak = !strncmp(make,\"EASTMAN\",7) && tiff_nifds < 3;\n  entries = get2();\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    switch (tag) {\n      case 33434:  shutter = getreal(type);\t\tbreak;\n      case 33437:  aperture = getreal(type);\t\tbreak;\n      case 34855:  iso_speed = get2();\t\t\tbreak;\n      case 36867:\n      case 36868:  get_timestamp(0);\t\t\tbreak;\n      case 37377:  if ((expo = -getreal(type)) < 128)\n\t\t     shutter = pow (2, expo);\t\tbreak;\n      case 37378:  aperture = pow (2, getreal(type)/2);\tbreak;\n      case 37386:  focal_len = getreal(type);\t\tbreak;\n      case 37500:  parse_makernote (base, 0);\t\tbreak;\n      case 40962:  if (kodak) raw_width  = get4();\tbreak;\n      case 40963:  if (kodak) raw_height = get4();\tbreak;\n      case 41730:\n\tif (get4() == 0x20002)\n\t  for (exif_cfa=c=0; c < 8; c+=2)\n\t    exif_cfa |= fgetc(ifp) * 0x01010101 << c;\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS parse_gps (int base)\n{\n  unsigned entries, tag, type, len, save, c;\n\n  entries = get2();\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    switch (tag) {\n      case 1: case 3: case 5:\n\tgpsdata[29+tag/2] = getc(ifp);\t\t\tbreak;\n      case 2: case 4: case 7:\n\tFORC(6) gpsdata[tag/3*6+c] = get4();\t\tbreak;\n      case 6:\n\tFORC(2) gpsdata[18+c] = get4();\t\t\tbreak;\n      case 18: case 29:\n\tfgets ((char *) (gpsdata+14+tag/3), MIN(len,12), ifp);\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS romm_coeff (float romm_cam[3][3])\n{\n  static const float rgb_romm[3][3] =\t/* ROMM == Kodak ProPhoto */\n  { {  2.034193, -0.727420, -0.306766 },\n    { -0.228811,  1.231729, -0.002922 },\n    { -0.008565, -0.153273,  1.161839 } };\n  int i, j, k;\n\n  for (i=0; i < 3; i++)\n    for (j=0; j < 3; j++)\n      for (cmatrix[i][j] = k=0; k < 3; k++)\n\tcmatrix[i][j] += rgb_romm[i][k] * romm_cam[k][j];\n}\n\nvoid CLASS parse_mos (int offset)\n{\n  char data[40];\n  int skip, from, i, c, neut[4], planes=0, frot=0;\n  static const char *mod[] =\n  { \"\",\"DCB2\",\"Volare\",\"Cantare\",\"CMost\",\"Valeo 6\",\"Valeo 11\",\"Valeo 22\",\n    \"Valeo 11p\",\"Valeo 17\",\"\",\"Aptus 17\",\"Aptus 22\",\"Aptus 75\",\"Aptus 65\",\n    \"Aptus 54S\",\"Aptus 65S\",\"Aptus 75S\",\"AFi 5\",\"AFi 6\",\"AFi 7\",\n    \"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"AFi-II 12\" };\n  float romm_cam[3][3];\n\n  fseek (ifp, offset, SEEK_SET);\n  while (1) {\n    if (get4() != 0x504b5453) break;\n    get4();\n    fread (data, 1, 40, ifp);\n    skip = get4();\n    from = ftell(ifp);\n    if (!strcmp(data,\"JPEG_preview_data\")) {\n      thumb_offset = from;\n      thumb_length = skip;\n    }\n    if (!strcmp(data,\"icc_camera_profile\")) {\n      profile_offset = from;\n      profile_length = skip;\n    }\n    if (!strcmp(data,\"ShootObj_back_type\")) {\n      fscanf (ifp, \"%d\", &i);\n      if ((unsigned) i < sizeof mod / sizeof (*mod))\n\tstrcpy (model, mod[i]);\n    }\n    if (!strcmp(data,\"icc_camera_to_tone_matrix\")) {\n      for (i=0; i < 9; i++)\n\tromm_cam[0][i] = int_to_float(get4());\n      romm_coeff (romm_cam);\n    }\n    if (!strcmp(data,\"CaptProf_color_matrix\")) {\n      for (i=0; i < 9; i++)\n\tfscanf (ifp, \"%f\", &romm_cam[0][i]);\n      romm_coeff (romm_cam);\n    }\n    if (!strcmp(data,\"CaptProf_number_of_planes\"))\n      fscanf (ifp, \"%d\", &planes);\n    if (!strcmp(data,\"CaptProf_raw_data_rotation\"))\n      fscanf (ifp, \"%d\", &flip);\n    if (!strcmp(data,\"CaptProf_mosaic_pattern\"))\n      FORC4 {\n\tfscanf (ifp, \"%d\", &i);\n\tif (i == 1) frot = c ^ (c >> 1);\n      }\n    if (!strcmp(data,\"ImgProf_rotation_angle\")) {\n      fscanf (ifp, \"%d\", &i);\n      flip = i - flip;\n    }\n    if (!strcmp(data,\"NeutObj_neutrals\") && !cam_mul[0]) {\n      FORC4 fscanf (ifp, \"%d\", neut+c);\n      FORC3 cam_mul[c] = (float) neut[0] / neut[c+1];\n    }\n    if (!strcmp(data,\"Rows_data\"))\n      load_flags = get4();\n    parse_mos (from);\n    fseek (ifp, skip+from, SEEK_SET);\n  }\n  if (planes)\n    filters = (planes == 1) * 0x01010101 *\n\t(uchar) \"\\x94\\x61\\x16\\x49\"[(flip/90 + frot) & 3];\n}\n\nvoid CLASS linear_table (unsigned len)\n{\n  int i;\n  if (len > 0x1000) len = 0x1000;\n  read_shorts (curve, len);\n  for (i=len; i < 0x1000; i++)\n    curve[i] = curve[i-1];\n  maximum = curve[0xfff];\n}\n\nvoid CLASS parse_kodak_ifd (int base)\n{\n  unsigned entries, tag, type, len, save;\n  int i, c, wbi=-2, wbtemp=6500;\n  float mul[3]={1,1,1}, num;\n  static const int wbtag[] = { 64037,64040,64039,64041,-1,-1,64042 };\n\n  entries = get2();\n  if (entries > 1024) return;\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    if (tag == 1020) wbi = getint(type);\n    if (tag == 1021 && len == 72) {\t\t/* WB set in software */\n      fseek (ifp, 40, SEEK_CUR);\n      FORC3 cam_mul[c] = 2048.0 / get2();\n      wbi = -2;\n    }\n    if (tag == 2118) wbtemp = getint(type);\n    if (tag == 2130 + wbi)\n      FORC3 mul[c] = getreal(type);\n    if (tag == 2140 + wbi && wbi >= 0)\n      FORC3 {\n\tfor (num=i=0; i < 4; i++)\n\t  num += getreal(type) * pow (wbtemp/100.0, i);\n\tcam_mul[c] = 2048 / (num * mul[c]);\n      }\n    if (tag == 2317) linear_table (len);\n    if (tag == 6020) iso_speed = getint(type);\n    if (tag == 64013) wbi = fgetc(ifp);\n    if ((unsigned) wbi < 7 && tag == wbtag[wbi])\n      FORC3 cam_mul[c] = get4();\n    if (tag == 64019) width = getint(type);\n    if (tag == 64020) height = (getint(type)+1) & -2;\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n//@end COMMON\n\nvoid CLASS parse_minolta (int base);\nint CLASS parse_tiff (int base);\n\n//@out COMMON\nint CLASS parse_tiff_ifd (int base)\n{\n  unsigned entries, tag, type, len, plen=16, save;\n  int ifd, use_cm=0, cfa, i, j, c, ima_len=0;\n  int blrr=1, blrc=1, dblack[] = { 0,0,0,0 };\n  char software[64], *cbuf, *cp;\n  uchar cfa_pat[16], cfa_pc[] = { 0,1,2,3 }, tab[256];\n  double cc[4][4], cm[4][3], cam_xyz[4][3], num;\n  double ab[]={ 1,1,1,1 }, asn[] = { 0,0,0,0 }, xyz[] = { 1,1,1 };\n  unsigned sony_curve[] = { 0,0,0,0,0,4095 };\n  unsigned *buf, sony_offset=0, sony_length=0, sony_key=0;\n  struct jhead jh;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *sfp;\n#endif\n\n  if (tiff_nifds >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n    return 1;\n  ifd = tiff_nifds++;\n  for (j=0; j < 4; j++)\n    for (i=0; i < 4; i++)\n      cc[j][i] = i == j;\n  entries = get2();\n  if (entries > 512) return 1;\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    switch (tag) {\n      case 5:   width  = get2();  break;\n      case 6:   height = get2();  break;\n      case 7:   width += get2();  break;\n      case 9:  filters = get2();  break;\n      case 17: case 18:\n\tif (type == 3 && len == 1)\n\t  cam_mul[(tag-17)*2] = get2() / 256.0;\n\tbreak;\n      case 23:\n\tif (type == 3) iso_speed = get2();\n\tbreak;\n      case 36: case 37: case 38:\n\tcam_mul[tag-0x24] = get2();\n\tbreak;\n      case 39:\n\tif (len < 50 || cam_mul[0]) break;\n\tfseek (ifp, 12, SEEK_CUR);\n\tFORC3 cam_mul[c] = get2();\n\tbreak;\n      case 46:\n\tif (type != 7 || fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8) break;\n\tthumb_offset = ftell(ifp) - 2;\n\tthumb_length = len;\n\tbreak;\n      case 61440:\t\t\t/* Fuji HS10 table */\n\tparse_tiff_ifd (base);\n\tbreak;\n      case 2: case 256: case 61441:\t/* ImageWidth */\n\ttiff_ifd[ifd].t_width = getint(type);\n\tbreak;\n      case 3: case 257: case 61442:\t/* ImageHeight */\n\ttiff_ifd[ifd].t_height = getint(type);\n\tbreak;\n      case 258:\t\t\t\t/* BitsPerSample */\n      case 61443:\n\ttiff_ifd[ifd].samples = len & 7;\n\ttiff_ifd[ifd].bps = getint(type);\n\tbreak;\n      case 61446:\n\traw_height = 0;\n\tload_raw = &CLASS packed_load_raw;\n\tload_flags = get4() && (filters=0x16161616) ? 24:80;\n\tbreak;\n      case 259:\t\t\t\t/* Compression */\n\ttiff_ifd[ifd].comp = getint(type);\n\tbreak;\n      case 262:\t\t\t\t/* PhotometricInterpretation */\n\ttiff_ifd[ifd].phint = get2();\n\tbreak;\n      case 270:\t\t\t\t/* ImageDescription */\n\tfread (desc, 512, 1, ifp);\n\tbreak;\n      case 271:\t\t\t\t/* Make */\n\tfgets (make, 64, ifp);\n\tbreak;\n      case 272:\t\t\t\t/* Model */\n\tfgets (model, 64, ifp);\n\tbreak;\n      case 280:\t\t\t\t/* Panasonic RW2 offset */\n\tif (type != 4) break;\n\tload_raw = &CLASS panasonic_load_raw;\n\tload_flags = 0x2008;\n      case 273:\t\t\t\t/* StripOffset */\n      case 513:\t\t\t\t/* JpegIFOffset */\n      case 61447:\n\ttiff_ifd[ifd].offset = get4()+base;\n\tif (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0) {\n\t  fseek (ifp, tiff_ifd[ifd].offset, SEEK_SET);\n\t  if (ljpeg_start (&jh, 1)) {\n\t    tiff_ifd[ifd].comp    = 6;\n\t    tiff_ifd[ifd].t_width   = jh.wide;\n\t    tiff_ifd[ifd].t_height  = jh.high;\n\t    tiff_ifd[ifd].bps     = jh.bits;\n\t    tiff_ifd[ifd].samples = jh.clrs;\n\t    if (!(jh.sraw || (jh.clrs & 1)))\n\t      tiff_ifd[ifd].t_width *= jh.clrs;\n\t    i = order;\n\t    parse_tiff (tiff_ifd[ifd].offset + 12);\n\t    order = i;\n\t  }\n\t}\n\tbreak;\n      case 274:\t\t\t\t/* Orientation */\n\ttiff_ifd[ifd].t_flip = \"50132467\"[get2() & 7]-'0';\n\tbreak;\n      case 277:\t\t\t\t/* SamplesPerPixel */\n\ttiff_ifd[ifd].samples = getint(type) & 7;\n\tbreak;\n      case 279:\t\t\t\t/* StripByteCounts */\n      case 514:\n      case 61448:\n\ttiff_ifd[ifd].bytes = get4();\n\tbreak;\n      case 61454:\n\tFORC3 cam_mul[(4-c) % 3] = getint(type);\n\tbreak;\n      case 305:  case 11:\t\t/* Software */\n\tfgets (software, 64, ifp);\n\tif (!strncmp(software,\"Adobe\",5) ||\n\t    !strncmp(software,\"dcraw\",5) ||\n\t    !strncmp(software,\"UFRaw\",5) ||\n\t    !strncmp(software,\"Bibble\",6) ||\n\t    !strncmp(software,\"Nikon Scan\",10) ||\n\t    !strcmp (software,\"Digital Photo Professional\"))\n\t  is_raw = 0;\n\tbreak;\n      case 306:\t\t\t\t/* DateTime */\n\tget_timestamp(0);\n\tbreak;\n      case 315:\t\t\t\t/* Artist */\n\tfread (artist, 64, 1, ifp);\n\tbreak;\n      case 322:\t\t\t\t/* TileWidth */\n\ttiff_ifd[ifd].t_tile_width = getint(type);\n\tbreak;\n      case 323:\t\t\t\t/* TileLength */\n\ttiff_ifd[ifd].t_tile_length = getint(type);\n\tbreak;\n      case 324:\t\t\t\t/* TileOffsets */\n\ttiff_ifd[ifd].offset = len > 1 ? ftell(ifp) : get4();\n\tif (len == 4) {\n\t  load_raw = &CLASS sinar_4shot_load_raw;\n\t  is_raw = 5;\n\t}\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 325:\t\t\t\t/* TileByteCount */\n          tiff_ifd[ifd].tile_maxbytes = 0;\n          for(int jj=0;jj<len;jj++)\n              {\n                  int s = get4();\n                  if(s > tiff_ifd[ifd].tile_maxbytes) tiff_ifd[ifd].tile_maxbytes=s;\n              }\n\tbreak;\n#endif\n      case 330:\t\t\t\t/* SubIFDs */\n\tif (!strcmp(model,\"DSLR-A100\") && tiff_ifd[ifd].t_width == 3872) {\n\t  load_raw = &CLASS sony_arw_load_raw;\n\t  data_offset = get4()+base;\n\t  ifd++;  break;\n\t}\n        if(len > 1000) len=1000; /* 1000 SubIFDs is enough */\n\twhile (len--) {\n\t  i = ftell(ifp);\n\t  fseek (ifp, get4()+base, SEEK_SET);\n\t  if (parse_tiff_ifd (base)) break;\n\t  fseek (ifp, i+4, SEEK_SET);\n\t}\n\tbreak;\n      case 400:\n\tstrcpy (make, \"Sarnoff\");\n\tmaximum = 0xfff;\n\tbreak;\n      case 28688:\n\tFORC4 sony_curve[c+1] = get2() >> 2 & 0xfff;\n\tfor (i=0; i < 5; i++)\n\t  for (j = sony_curve[i]+1; j <= sony_curve[i+1]; j++)\n\t    curve[j] = curve[j-1] + (1 << i);\n\tbreak;\n      case 29184: sony_offset = get4();  break;\n      case 29185: sony_length = get4();  break;\n      case 29217: sony_key    = get4();  break;\n      case 29264:\n\tparse_minolta (ftell(ifp));\n\traw_width = 0;\n\tbreak;\n      case 29443:\n\tFORC4 cam_mul[c ^ (c < 2)] = get2();\n\tbreak;\n      case 29459:\n\tFORC4 cam_mul[c] = get2();\n\ti = (cam_mul[1] == 1024 && cam_mul[2] == 1024) << 1;\n\tSWAP (cam_mul[i],cam_mul[i+1])\n\tbreak;\n      case 33405:\t\t\t/* Model2 */\n\tfgets (model2, 64, ifp);\n\tbreak;\n      case 33422:\t\t\t/* CFAPattern */\n      case 64777:\t\t\t/* Kodak P-series */\n\tif ((plen=len) > 16) plen = 16;\n\tfread (cfa_pat, 1, plen, ifp);\n\tfor (colors=cfa=i=0; i < plen; i++) {\n\t  colors += !(cfa & (1 << cfa_pat[i]));\n\t  cfa |= 1 << cfa_pat[i];\n\t}\n\tif (cfa == 070) memcpy (cfa_pc,\"\\003\\004\\005\",3);\t/* CMY */\n\tif (cfa == 072) memcpy (cfa_pc,\"\\005\\003\\004\\001\",4);\t/* GMCY */\n\tgoto guess_cfa_pc;\n      case 33424:\n      case 65024:\n\tfseek (ifp, get4()+base, SEEK_SET);\n\tparse_kodak_ifd (base);\n\tbreak;\n      case 33434:\t\t\t/* ExposureTime */\n\tshutter = getreal(type);\n\tbreak;\n      case 33437:\t\t\t/* FNumber */\n\taperture = getreal(type);\n\tbreak;\n      case 34306:\t\t\t/* Leaf white balance */\n\tFORC4 cam_mul[c ^ 1] = 4096.0 / get2();\n\tbreak;\n      case 34307:\t\t\t/* Leaf CatchLight color matrix */\n\tfread (software, 1, 7, ifp);\n\tif (strncmp(software,\"MATRIX\",6)) break;\n\tcolors = 4;\n\tfor (raw_color = i=0; i < 3; i++) {\n\t  FORC4 fscanf (ifp, \"%f\", &rgb_cam[i][c^1]);\n\t  if (!use_camera_wb) continue;\n\t  num = 0;\n\t  FORC4 num += rgb_cam[i][c];\n\t  FORC4 rgb_cam[i][c] /= num;\n\t}\n\tbreak;\n      case 34310:\t\t\t/* Leaf metadata */\n\tparse_mos (ftell(ifp));\n      case 34303:\n\tstrcpy (make, \"Leaf\");\n\tbreak;\n      case 34665:\t\t\t/* EXIF tag */\n\tfseek (ifp, get4()+base, SEEK_SET);\n\tparse_exif (base);\n\tbreak;\n      case 34853:\t\t\t/* GPSInfo tag */\n\tfseek (ifp, get4()+base, SEEK_SET);\n\tparse_gps (base);\n\tbreak;\n      case 34675:\t\t\t/* InterColorProfile */\n      case 50831:\t\t\t/* AsShotICCProfile */\n\tprofile_offset = ftell(ifp);\n\tprofile_length = len;\n\tbreak;\n      case 37122:\t\t\t/* CompressedBitsPerPixel */\n\tkodak_cbpp = get4();\n\tbreak;\n      case 37386:\t\t\t/* FocalLength */\n\tfocal_len = getreal(type);\n\tbreak;\n      case 37393:\t\t\t/* ImageNumber */\n\tshot_order = getint(type);\n\tbreak;\n      case 37400:\t\t\t/* old Kodak KDC tag */\n\tfor (raw_color = i=0; i < 3; i++) {\n\t  getreal(type);\n\t  FORC3 rgb_cam[i][c] = getreal(type);\n\t}\n\tbreak;\n      case 46275:\t\t\t/* Imacon tags */\n\tstrcpy (make, \"Imacon\");\n\tdata_offset = ftell(ifp);\n\tima_len = len;\n\tbreak;\n      case 46279:\n\tif (!ima_len) break;\n\tfseek (ifp, 38, SEEK_CUR);\n      case 46274:\n\tfseek (ifp, 40, SEEK_CUR);\n\traw_width  = get4();\n\traw_height = get4();\n\tleft_margin = get4() & 7;\n\twidth = raw_width - left_margin - (get4() & 7);\n\ttop_margin = get4() & 7;\n\theight = raw_height - top_margin - (get4() & 7);\n\tif (raw_width == 7262 && ima_len == 234317952 ) {\n\t  height = 5412;\n\t  width  = 7216;\n\t  left_margin = 7;\n          filters=0;\n\t} else \tif (raw_width == 7262) {\n\t  height = 5444;\n\t  width  = 7244;\n\t  left_margin = 7;\n\t}\n\tfseek (ifp, 52, SEEK_CUR);\n\tFORC3 cam_mul[c] = getreal(11);\n\tfseek (ifp, 114, SEEK_CUR);\n\tflip = (get2() >> 7) * 90;\n\tif (width * height * 6 == ima_len) {\n\t  if (flip % 180 == 90) SWAP(width,height);\n\t  raw_width = width;\n\t  raw_height = height;\n\t  left_margin = top_margin = filters = flip = 0;\n\t}\n\tsprintf (model, \"Ixpress %d-Mp\", height*width/1000000);\n\tload_raw = &CLASS imacon_full_load_raw;\n\tif (filters) {\n\t  if (left_margin & 1) filters = 0x61616161;\n\t  load_raw = &CLASS unpacked_load_raw;\n\t}\n\tmaximum = 0xffff;\n\tbreak;\n      case 50454:\t\t\t/* Sinar tag */\n      case 50455:\n\tif (!(cbuf = (char *) malloc(len))) break;\n\tfread (cbuf, 1, len, ifp);\n\tfor (cp = cbuf-1; cp && cp < cbuf+len; cp = strchr(cp,'\\n'))\n\t  if (!strncmp (++cp,\"Neutral \",8))\n\t    sscanf (cp+8, \"%f %f %f\", cam_mul, cam_mul+1, cam_mul+2);\n\tfree (cbuf);\n\tbreak;\n      case 50458:\n\tif (!make[0]) strcpy (make, \"Hasselblad\");\n\tbreak;\n      case 50459:\t\t\t/* Hasselblad tag */\n\ti = order;\n\tj = ftell(ifp);\n\tc = tiff_nifds;\n\torder = get2();\n\tfseek (ifp, j+(get2(),get4()), SEEK_SET);\n\tparse_tiff_ifd (j);\n\tmaximum = 0xffff;\n\ttiff_nifds = c;\n\torder = i;\n\tbreak;\n      case 50706:\t\t\t/* DNGVersion */\n\tFORC4 dng_version = (dng_version << 8) + fgetc(ifp);\n\tif (!make[0]) strcpy (make, \"DNG\");\n\tis_raw = 1;\n\tbreak;\n      case 50710:\t\t\t/* CFAPlaneColor */\n\tif (len > 4) len = 4;\n\tcolors = len;\n\tfread (cfa_pc, 1, colors, ifp);\nguess_cfa_pc:\n\tFORCC tab[cfa_pc[c]] = c;\n\tcdesc[c] = 0;\n\tfor (i=16; i--; )\n\t  filters = filters << 2 | tab[cfa_pat[i % plen]];\n\tbreak;\n      case 50711:\t\t\t/* CFALayout */\n\tif (get2() == 2) {\n\t  fuji_width = 1;\n\t  filters = 0x49494949;\n\t}\n\tbreak;\n      case 291:\n      case 50712:\t\t\t/* LinearizationTable */\n\tlinear_table (len);\n\tbreak;\n      case 50713:\t\t\t/* BlackLevelRepeatDim */\n\tblrr = get2();\n\tblrc = get2();\n\tbreak;\n      case 61450:\n\tblrr = blrc = 2;\n      case 50714:\t\t\t/* BlackLevel */\n\tblack = getreal(type);\n\tif (!filters || !~filters) break;\n\tdblack[0] = black;\n\tdblack[1] = (blrc == 2) ? getreal(type):dblack[0];\n\tdblack[2] = (blrr == 2) ? getreal(type):dblack[0];\n\tdblack[3] = (blrc == 2 && blrr == 2) ? getreal(type):dblack[1];\n\tif (colors == 3)\n\t  filters |= ((filters >> 2 & 0x22222222) |\n\t\t      (filters << 2 & 0x88888888)) & filters << 1;\n\tFORC4 cblack[filters >> (c << 1) & 3] = dblack[c];\n\tblack = 0;\n\tbreak;\n      case 50715:\t\t\t/* BlackLevelDeltaH */\n      case 50716:\t\t\t/* BlackLevelDeltaV */\n\tfor (num=i=0; i < len && i < 65536; i++)\n\t  num += getreal(type);\n\tblack += num/len + 0.5;\n\tbreak;\n      case 50717:\t\t\t/* WhiteLevel */\n\tmaximum = getint(type);\n\tbreak;\n      case 50718:\t\t\t/* DefaultScale */\n\tpixel_aspect  = getreal(type);\n\tpixel_aspect /= getreal(type);\n\tbreak;\n      case 50721:\t\t\t/* ColorMatrix1 */\n      case 50722:\t\t\t/* ColorMatrix2 */\n\tFORCC for (j=0; j < 3; j++)\n\t  cm[c][j] = getreal(type);\n\tuse_cm = 1;\n\tbreak;\n      case 50723:\t\t\t/* CameraCalibration1 */\n      case 50724:\t\t\t/* CameraCalibration2 */\n\tfor (i=0; i < colors; i++)\n\t  FORCC cc[i][c] = getreal(type);\n\tbreak;\n      case 50727:\t\t\t/* AnalogBalance */\n\tFORCC ab[c] = getreal(type);\n\tbreak;\n      case 50728:\t\t\t/* AsShotNeutral */\n\tFORCC asn[c] = getreal(type);\n\tbreak;\n      case 50729:\t\t\t/* AsShotWhiteXY */\n\txyz[0] = getreal(type);\n\txyz[1] = getreal(type);\n\txyz[2] = 1 - xyz[0] - xyz[1];\n\tFORC3 xyz[c] /= d65_white[c];\n\tbreak;\n      case 50740:\t\t\t/* DNGPrivateData */\n\tif (dng_version) break;\n\tparse_minolta (j = get4()+base);\n\tfseek (ifp, j, SEEK_SET);\n\tparse_tiff_ifd (base);\n\tbreak;\n      case 50752:\n\tread_shorts (cr2_slice, 3);\n\tbreak;\n      case 50829:\t\t\t/* ActiveArea */\n\ttop_margin = getint(type);\n\tleft_margin = getint(type);\n\theight = getint(type) - top_margin;\n\twidth = getint(type) - left_margin;\n\tbreak;\n      case 50830:\t\t\t/* MaskedAreas */\n        for (i=0; i < len && i < 32; i++)\n\t  mask[0][i] = getint(type);\n\tblack = 0;\n\tbreak;\n      case 51009:\t\t\t/* OpcodeList2 */\n\tmeta_offset = ftell(ifp);\n\tbreak;\n      case 64772:\t\t\t/* Kodak P-series */\n\tif (len < 13) break;\n\tfseek (ifp, 16, SEEK_CUR);\n\tdata_offset = get4();\n\tfseek (ifp, 28, SEEK_CUR);\n\tdata_offset += get4();\n\tload_raw = &CLASS packed_load_raw;\n\tbreak;\n      case 65026:\n\tif (type == 2) fgets (model2, 64, ifp);\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n  if (sony_length && (buf = (unsigned *) malloc(sony_length))) {\n    fseek (ifp, sony_offset, SEEK_SET);\n    fread (buf, sony_length, 1, ifp);\n    sony_decrypt (buf, sony_length/4, 1, sony_key);\n#ifndef LIBRAW_LIBRARY_BUILD\n    sfp = ifp;\n    if ((ifp = tmpfile())) {\n      fwrite (buf, sony_length, 1, ifp);\n      fseek (ifp, 0, SEEK_SET);\n      parse_tiff_ifd (-sony_offset);\n      fclose (ifp);\n    }\n    ifp = sfp;\n#else\n    if( !ifp->tempbuffer_open(buf,sony_length))\n        {\n            parse_tiff_ifd(-sony_offset);\n            ifp->tempbuffer_close();\n        }\n#endif\n    free (buf);\n  }\n  for (i=0; i < colors; i++)\n    FORCC cc[i][c] *= ab[i];\n  if (use_cm) {\n    FORCC for (i=0; i < 3; i++)\n      for (cam_xyz[c][i]=j=0; j < colors; j++)\n\tcam_xyz[c][i] += cc[c][j] * cm[j][i] * xyz[i];\n    cam_xyz_coeff (cam_xyz);\n  }\n  if (asn[0]) {\n    cam_mul[3] = 0;\n    FORCC cam_mul[c] = 1 / asn[c];\n  }\n  if (!use_cm)\n    FORCC pre_mul[c] /= cc[c][c];\n  return 0;\n}\n\nint CLASS parse_tiff (int base)\n{\n  int doff;\n\n  fseek (ifp, base, SEEK_SET);\n  order = get2();\n  if (order != 0x4949 && order != 0x4d4d) return 0;\n  get2();\n  while ((doff = get4())) {\n    fseek (ifp, doff+base, SEEK_SET);\n    if (parse_tiff_ifd (base)) break;\n  }\n  return 1;\n}\n\nvoid CLASS apply_tiff()\n{\n  int max_samp=0, raw=-1, thm=-1, i;\n  struct jhead jh;\n\n  thumb_misc = 16;\n  if (thumb_offset) {\n    fseek (ifp, thumb_offset, SEEK_SET);\n    if (ljpeg_start (&jh, 1)) {\n      if((unsigned)jh.bits<17 && (unsigned)jh.wide < 0x10000 && (unsigned)jh.high < 0x10000)\n        {\n          thumb_misc   = jh.bits;\n          thumb_width  = jh.wide;\n          thumb_height = jh.high;\n        }\n    }\n  }\n  for (i=0; i < tiff_nifds; i++) {\n    if (max_samp < tiff_ifd[i].samples)\n\tmax_samp = tiff_ifd[i].samples;\n    if (max_samp > 3) max_samp = 3;\n    if ((tiff_ifd[i].comp != 6 || tiff_ifd[i].samples != 3) &&\n        unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&\n        (unsigned)tiff_ifd[i].bps < 33 && (unsigned)tiff_ifd[i].samples < 13 &&\n\ttiff_ifd[i].t_width*tiff_ifd[i].t_height > raw_width*raw_height) {\n      raw_width     = tiff_ifd[i].t_width;\n      raw_height    = tiff_ifd[i].t_height;\n      tiff_bps      = tiff_ifd[i].bps;\n      tiff_compress = tiff_ifd[i].comp;\n      data_offset   = tiff_ifd[i].offset;\n      tiff_flip     = tiff_ifd[i].t_flip;\n      tiff_samples  = tiff_ifd[i].samples;\n      tile_width    = tiff_ifd[i].t_tile_width;\n      tile_length   = tiff_ifd[i].t_tile_length;\n#ifdef LIBRAW_LIBRARY_BUILD\n      data_size     = tile_length < INT_MAX && tile_length>0 ? tiff_ifd[i].tile_maxbytes: tiff_ifd[i].bytes;\n#endif\n      raw = i;\n    }\n  }\n  if (!tile_width ) tile_width  = INT_MAX;\n  if (!tile_length) tile_length = INT_MAX;\n  for (i=tiff_nifds; i--; )\n    if (tiff_ifd[i].t_flip) tiff_flip = tiff_ifd[i].t_flip;\n  if (raw >= 0 && !load_raw)\n    switch (tiff_compress) {\n      case 32767:\n\tif (tiff_ifd[raw].bytes == raw_width*raw_height) {\n\t  tiff_bps = 12;\n\t  load_raw = &CLASS sony_arw2_load_raw;\t\t\tbreak;\n\t}\n\tif (tiff_ifd[raw].bytes*8 != raw_width*raw_height*tiff_bps) {\n\t  raw_height += 8;\n\t  load_raw = &CLASS sony_arw_load_raw;\t\t\tbreak;\n\t}\n\tload_flags = 79;\n      case 32769:\n\tload_flags++;\n      case 32770:\n      case 32773: goto slr;\n      case 0:  case 1:\n\tif (tiff_ifd[raw].bytes*5 == raw_width*raw_height*8) {\n\t  load_flags = 81;\n\t  tiff_bps = 12;\n\t} slr:\n\tswitch (tiff_bps) {\n\t  case  8: load_raw = &CLASS eight_bit_load_raw;\tbreak;\n\t  case 12: if (tiff_ifd[raw].phint == 2)\n\t\t     load_flags = 6;\n\t\t   load_raw = &CLASS packed_load_raw;\t\tbreak;\n\t  case 14: load_flags = 0;\n\t  case 16: load_raw = &CLASS unpacked_load_raw;\t\tbreak;\n\t}\n\tbreak;\n      case 6:  case 7:  case 99:\n\tload_raw = &CLASS lossless_jpeg_load_raw;\t\tbreak;\n      case 262:\n\tload_raw = &CLASS kodak_262_load_raw;\t\t\tbreak;\n      case 34713:\n\tif ((raw_width+9)/10*16*raw_height == tiff_ifd[raw].bytes) {\n\t  load_raw = &CLASS packed_load_raw;\n\t  load_flags = 1;\n\t} else if (raw_width*raw_height*2 == tiff_ifd[raw].bytes) {\n\t  load_raw = &CLASS unpacked_load_raw;\n\t  load_flags = 4;\n\t  order = 0x4d4d;\n\t} else\n\t  load_raw = &CLASS nikon_load_raw;\t\t\tbreak;\n      case 34892:\n\tload_raw = &CLASS lossy_dng_load_raw;\t\t\tbreak;\n      case 65535:\n\tload_raw = &CLASS pentax_load_raw;\t\t\tbreak;\n      case 65000:\n\tswitch (tiff_ifd[raw].phint) {\n\t  case 2: load_raw = &CLASS kodak_rgb_load_raw;   filters = 0;  break;\n\t  case 6: load_raw = &CLASS kodak_ycbcr_load_raw; filters = 0;  break;\n\t  case 32803: load_raw = &CLASS kodak_65000_load_raw;\n\t}\n      case 32867: break;\n      default: is_raw = 0;\n    }\n  if (!dng_version)\n    if ( (tiff_samples == 3 && tiff_ifd[raw].bytes &&\n\t  tiff_bps != 14 && tiff_bps != 2048 && \n\t  tiff_compress != 32769 && tiff_compress != 32770)\n      || (tiff_bps == 8 && !strstr(make,\"KODAK\") && !strstr(make,\"Kodak\") &&\n\t  !strstr(model2,\"DEBUG RAW\")))\n      is_raw = 0;\n  for (i=0; i < tiff_nifds; i++)\n    if (i != raw && tiff_ifd[i].samples == max_samp &&\n        tiff_ifd[i].bps>0 && tiff_ifd[i].bps < 33 &&\n       unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&\n\ttiff_ifd[i].t_width * tiff_ifd[i].t_height / SQR(tiff_ifd[i].bps+1) >\n\t      thumb_width *       thumb_height / SQR(thumb_misc+1)\n\t&& tiff_ifd[i].comp != 34892) {\n      thumb_width  = tiff_ifd[i].t_width;\n      thumb_height = tiff_ifd[i].t_height;\n      thumb_offset = tiff_ifd[i].offset;\n      thumb_length = tiff_ifd[i].bytes;\n      thumb_misc   = tiff_ifd[i].bps;\n      thm = i;\n    }\n  if (thm >= 0) {\n    thumb_misc |= tiff_ifd[thm].samples << 5;\n    switch (tiff_ifd[thm].comp) {\n      case 0:\n\twrite_thumb = &CLASS layer_thumb;\n\tbreak;\n      case 1:\n\tif (tiff_ifd[thm].bps <= 8)\n\t  write_thumb = &CLASS ppm_thumb;\n\telse if (!strcmp(make,\"Imacon\"))\n\t  write_thumb = &CLASS ppm16_thumb;\n\telse\n\t  thumb_load_raw = &CLASS kodak_thumb_load_raw;\n\tbreak;\n      case 65000:\n\tthumb_load_raw = tiff_ifd[thm].phint == 6 ?\n\t\t&CLASS kodak_ycbcr_load_raw : &CLASS kodak_rgb_load_raw;\n    }\n  }\n}\n\nvoid CLASS parse_minolta (int base)\n{\n  int save, tag, len, offset, high=0, wide=0, i, c;\n  short sorder=order;\n\n  fseek (ifp, base, SEEK_SET);\n  if (fgetc(ifp) || fgetc(ifp)-'M' || fgetc(ifp)-'R') return;\n  order = fgetc(ifp) * 0x101;\n  offset = base + get4() + 8;\n  while ((save=ftell(ifp)) < offset) {\n    for (tag=i=0; i < 4; i++)\n      tag = tag << 8 | fgetc(ifp);\n    len = get4();\n    switch (tag) {\n      case 0x505244:\t\t\t\t/* PRD */\n\tfseek (ifp, 8, SEEK_CUR);\n\thigh = get2();\n\twide = get2();\n\tbreak;\n      case 0x574247:\t\t\t\t/* WBG */\n\tget4();\n\ti = strcmp(model,\"DiMAGE A200\") ? 0:3;\n\tFORC4 cam_mul[c ^ (c >> 1) ^ i] = get2();\n\tbreak;\n      case 0x545457:\t\t\t\t/* TTW */\n\tparse_tiff (ftell(ifp));\n\tdata_offset = offset;\n    }\n    fseek (ifp, save+len+8, SEEK_SET);\n  }\n  raw_height = high;\n  raw_width  = wide;\n  order = sorder;\n}\n\n/*\n   Many cameras have a \"debug mode\" that writes JPEG and raw\n   at the same time.  The raw file has no header, so try to\n   to open the matching JPEG file and read its metadata.\n */\nvoid CLASS parse_external_jpeg()\n{\n  const char *file, *ext;\n  char *jname, *jfile, *jext;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *save=ifp;\n#else\n#if defined (WIN32) && !defined(__MINGW32__)\n  if(ifp->wfname())\n  {\n\t  std::wstring rawfile(ifp->wfname());\n\t  rawfile.replace(rawfile.length()-3,3,L\"JPG\");\n\t  if(!ifp->subfile_open(rawfile.c_str()))\n\t  {\n\t\t  parse_tiff (12);\n\t\t  thumb_offset = 0;\n\t\t  is_raw = 1;\n\t\t  ifp->subfile_close();\n\t  }\n\t  else\n\t\t  imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n\t return;\n  }\n#endif\n  if(!ifp->fname())\n      {\n          imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n          return;\n      }\n#endif\n\n  ext  = strrchr (ifname, '.');\n  file = strrchr (ifname, '/');\n  if (!file) file = strrchr (ifname, '\\\\');\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!file) file = ifname-1;\n#else\n  if (!file) file = (char*)ifname-1;\n#endif\n  file++;\n  if (!ext || strlen(ext) != 4 || ext-file != 8) return;\n  jname = (char *) malloc (strlen(ifname) + 1);\n  merror (jname, \"parse_external_jpeg()\");\n  strcpy (jname, ifname);\n  jfile = file - ifname + jname;\n  jext  = ext  - ifname + jname;\n  if (strcasecmp (ext, \".jpg\")) {\n    strcpy (jext, isupper(ext[1]) ? \".JPG\":\".jpg\");\n    if (isdigit(*file)) {\n      memcpy (jfile, file+4, 4);\n      memcpy (jfile+4, file, 4);\n    }\n  } else\n    while (isdigit(*--jext)) {\n      if (*jext != '9') {\n\t(*jext)++;\n\tbreak;\n      }\n      *jext = '0';\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (strcmp (jname, ifname)) {\n    if ((ifp = fopen (jname, \"rb\"))) {\n#ifdef DCRAW_VERBOSE\n      if (verbose)\n\tfprintf (stderr,_(\"Reading metadata from %s ...\\n\"), jname);\n#endif\n      parse_tiff (12);\n      thumb_offset = 0;\n      is_raw = 1;\n      fclose (ifp);\n    }\n  }\n#else\n  if (strcmp (jname, ifname)) \n      {\n          if(!ifp->subfile_open(jname))\n              {\n                  parse_tiff (12);\n                  thumb_offset = 0;\n                  is_raw = 1;\n                  ifp->subfile_close();\n              }\n          else\n              imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n      }\n#endif\n  if (!timestamp)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n#endif\n#ifdef DCRAW_VERBOSE\n          fprintf (stderr,_(\"Failed to read metadata from %s\\n\"), jname);\n#endif\n      }\n  free (jname);\n#ifndef LIBRAW_LIBRARY_BUILD\n  ifp = save;\n#endif\n}\n\n/*\n   CIFF block 0x1030 contains an 8x8 white sample.\n   Load this into white[][] for use in scale_colors().\n */\nvoid CLASS ciff_block_1030()\n{\n  static const ushort key[] = { 0x410, 0x45f3 };\n  int i, bpp, row, col, vbits=0;\n  unsigned long bitbuf=0;\n\n  if ((get2(),get4()) != 0x80008 || !get4()) return;\n  bpp = get2();\n  if (bpp != 10 && bpp != 12) return;\n  for (i=row=0; row < 8; row++)\n    for (col=0; col < 8; col++) {\n      if (vbits < bpp) {\n\tbitbuf = bitbuf << 16 | (get2() ^ key[i++ & 1]);\n\tvbits += 16;\n      }\n      white[row][col] =\n\tbitbuf << (LONG_BIT - vbits) >> (LONG_BIT - bpp);\n      vbits -= bpp;\n    }\n}\n\n/*\n   Parse a CIFF file, better known as Canon CRW format.\n */\nvoid CLASS parse_ciff (int offset, int length)\n{\n  int tboff, nrecs, c, type, len, save, wbi=-1;\n  ushort key[] = { 0x410, 0x45f3 };\n\n  fseek (ifp, offset+length-4, SEEK_SET);\n  tboff = get4() + offset;\n  fseek (ifp, tboff, SEEK_SET);\n  nrecs = get2();\n  if (nrecs > 100) return;\n  while (nrecs--) {\n    type = get2();\n    len  = get4();\n    save = ftell(ifp) + 4;\n    fseek (ifp, offset+get4(), SEEK_SET);\n    if ((((type >> 8) + 8) | 8) == 0x38)\n      parse_ciff (ftell(ifp), len);\t/* Parse a sub-table */\n\n    if (type == 0x0810)\n      fread (artist, 64, 1, ifp);\n    if (type == 0x080a) {\n      fread (make, 64, 1, ifp);\n      fseek (ifp, strlen(make) - 63, SEEK_CUR);\n      fread (model, 64, 1, ifp);\n    }\n    if (type == 0x1810) {\n      fseek (ifp, 12, SEEK_CUR);\n      flip = get4();\n    }\n    if (type == 0x1835)\t\t\t/* Get the decoder table */\n      tiff_compress = get4();\n    if (type == 0x2007) {\n      thumb_offset = ftell(ifp);\n      thumb_length = len;\n    }\n    if (type == 0x1818) {\n      shutter = pow (2, -int_to_float((get4(),get4())));\n      aperture = pow (2, int_to_float(get4())/2);\n    }\n    if (type == 0x102a) {\n      iso_speed = pow (2, (get4(),get2())/32.0 - 4) * 50;\n      aperture  = pow (2, (get2(),(short)get2())/64.0);\n      shutter   = pow (2,-((short)get2())/32.0);\n      wbi = (get2(),get2());\n      if (wbi > 17) wbi = 0;\n      fseek (ifp, 32, SEEK_CUR);\n      if (shutter > 1e6) shutter = get2()/10.0;\n    }\n    if (type == 0x102c) {\n      if (get2() > 512) {\t\t/* Pro90, G1 */\n\tfseek (ifp, 118, SEEK_CUR);\n\tFORC4 cam_mul[c ^ 2] = get2();\n      } else {\t\t\t\t/* G2, S30, S40 */\n\tfseek (ifp, 98, SEEK_CUR);\n\tFORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2();\n      }\n    }\n    if (type == 0x0032) {\n      if (len == 768) {\t\t\t/* EOS D30 */\n\tfseek (ifp, 72, SEEK_CUR);\n\tFORC4 cam_mul[c ^ (c >> 1)] = 1024.0 / get2();\n\tif (!wbi) cam_mul[0] = -1;\t/* use my auto white balance */\n      } else if (!cam_mul[0]) {\n\tif (get2() == key[0])\t\t/* Pro1, G6, S60, S70 */\n\t  c = (strstr(model,\"Pro1\") ?\n\t      \"012346000000000000\":\"01345:000000006008\")[wbi]-'0'+ 2;\n\telse {\t\t\t\t/* G3, G5, S45, S50 */\n\t  c = \"023457000000006000\"[wbi]-'0';\n\t  key[0] = key[1] = 0;\n\t}\n\tfseek (ifp, 78 + c*8, SEEK_CUR);\n\tFORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2() ^ key[c & 1];\n\tif (!wbi) cam_mul[0] = -1;\n      }\n    }\n    if (type == 0x10a9) {\t\t/* D60, 10D, 300D, and clones */\n      if (len > 66) wbi = \"0134567028\"[wbi]-'0';\n      fseek (ifp, 2 + wbi*8, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n    }\n    if (type == 0x1030 && (0x18040 >> wbi & 1))\n      ciff_block_1030();\t\t/* all that don't have 0x10a9 */\n    if (type == 0x1031) {\n      raw_width = (get2(),get2());\n      raw_height = get2();\n    }\n    if (type == 0x5029) {\n      focal_len = len >> 16;\n      if ((len & 0xffff) == 2) focal_len /= 32;\n    }\n    if (type == 0x5813) flash_used = int_to_float(len);\n    if (type == 0x5814) canon_ev   = int_to_float(len);\n    if (type == 0x5817) shot_order = len;\n    if (type == 0x5834) unique_id  = len;\n    if (type == 0x580e) timestamp  = len;\n    if (type == 0x180e) timestamp  = get4();\n#ifdef LOCALTIME\n    if ((type | 0x4000) == 0x580e)\n      timestamp = mktime (gmtime (&timestamp));\n#endif\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS parse_rollei()\n{\n  char line[128], *val;\n  struct tm t;\n\n  fseek (ifp, 0, SEEK_SET);\n  memset (&t, 0, sizeof t);\n  do {\n    fgets (line, 128, ifp);\n    if ((val = strchr(line,'=')))\n      *val++ = 0;\n    else\n      val = line + strlen(line);\n    if (!strcmp(line,\"DAT\"))\n      sscanf (val, \"%d.%d.%d\", &t.tm_mday, &t.tm_mon, &t.tm_year);\n    if (!strcmp(line,\"TIM\"))\n      sscanf (val, \"%d:%d:%d\", &t.tm_hour, &t.tm_min, &t.tm_sec);\n    if (!strcmp(line,\"HDR\"))\n      thumb_offset = atoi(val);\n    if (!strcmp(line,\"X  \"))\n      raw_width = atoi(val);\n    if (!strcmp(line,\"Y  \"))\n      raw_height = atoi(val);\n    if (!strcmp(line,\"TX \"))\n      thumb_width = atoi(val);\n    if (!strcmp(line,\"TY \"))\n      thumb_height = atoi(val);\n  } while (strncmp(line,\"EOHD\",4));\n  data_offset = thumb_offset + thumb_width * thumb_height * 2;\n  t.tm_year -= 1900;\n  t.tm_mon -= 1;\n  if (mktime(&t) > 0)\n    timestamp = mktime(&t);\n  strcpy (make, \"Rollei\");\n  strcpy (model,\"d530flex\");\n  write_thumb = &CLASS rollei_thumb;\n}\n\nvoid CLASS parse_sinar_ia()\n{\n  int entries, off;\n  char str[8], *cp;\n\n  order = 0x4949;\n  fseek (ifp, 4, SEEK_SET);\n  entries = get4();\n  fseek (ifp, get4(), SEEK_SET);\n  while (entries--) {\n    off = get4(); get4();\n    fread (str, 8, 1, ifp);\n    if (!strcmp(str,\"META\"))   meta_offset = off;\n    if (!strcmp(str,\"THUMB\")) thumb_offset = off;\n    if (!strcmp(str,\"RAW0\"))   data_offset = off;\n  }\n  fseek (ifp, meta_offset+20, SEEK_SET);\n  fread (make, 64, 1, ifp);\n  make[63] = 0;\n  if ((cp = strchr(make,' '))) {\n    strcpy (model, cp+1);\n    *cp = 0;\n  }\n  raw_width  = get2();\n  raw_height = get2();\n  load_raw = &CLASS unpacked_load_raw;\n  thumb_width = (get4(),get2());\n  thumb_height = get2();\n  write_thumb = &CLASS ppm_thumb;\n  maximum = 0x3fff;\n}\n\nvoid CLASS parse_phase_one (int base)\n{\n  unsigned entries, tag, type, len, data, save, i, c;\n  float romm_cam[3][3];\n  char *cp;\n\n  memset (&ph1, 0, sizeof ph1);\n  fseek (ifp, base, SEEK_SET);\n  order = get4() & 0xffff;\n  if (get4() >> 8 != 0x526177) return;\t\t/* \"Raw\" */\n  fseek (ifp, get4()+base, SEEK_SET);\n  entries = get4();\n  get4();\n  while (entries--) {\n    tag  = get4();\n    type = get4();\n    len  = get4();\n    data = get4();\n    save = ftell(ifp);\n    fseek (ifp, base+data, SEEK_SET);\n    switch (tag) {\n      case 0x100:  flip = \"0653\"[data & 3]-'0';  break;\n      case 0x106:\n\tfor (i=0; i < 9; i++)\n\t  romm_cam[0][i] = getreal(11);\n\tromm_coeff (romm_cam);\n\tbreak;\n      case 0x107:\n\tFORC3 cam_mul[c] = getreal(11);\n\tbreak;\n      case 0x108:  raw_width     = data;\tbreak;\n      case 0x109:  raw_height    = data;\tbreak;\n      case 0x10a:  left_margin   = data;\tbreak;\n      case 0x10b:  top_margin    = data;\tbreak;\n      case 0x10c:  width         = data;\tbreak;\n      case 0x10d:  height        = data;\tbreak;\n      case 0x10e:  ph1.format    = data;\tbreak;\n      case 0x10f:  data_offset   = data+base;\tbreak;\n      case 0x110:  meta_offset   = data+base;\n\t\t   meta_length   = len;\t\t\tbreak;\n      case 0x112:  ph1.key_off   = save - 4;\t\tbreak;\n      case 0x210:  ph1.tag_210   = int_to_float(data);\tbreak;\n      case 0x21a:  ph1.tag_21a   = data;\t\tbreak;\n      case 0x21c:  strip_offset  = data+base;\t\tbreak;\n      case 0x21d:  ph1.t_black     = data;\t\tbreak;\n      case 0x222:  ph1.split_col = data;\t\tbreak;\n      case 0x223:  ph1.black_off = data+base;\t\tbreak;\n      case 0x301:\n\tmodel[63] = 0;\n\tfread (model, 1, 63, ifp);\n\tif ((cp = strstr(model,\" camera\"))) *cp = 0;\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n  load_raw = ph1.format < 3 ?\n\t&CLASS phase_one_load_raw : &CLASS phase_one_load_raw_c;\n  maximum = 0xffff;\n  strcpy (make, \"Phase One\");\n  if (model[0]) return;\n  switch (raw_height) {\n    case 2060: strcpy (model,\"LightPhase\");\tbreak;\n    case 2682: strcpy (model,\"H 10\");\t\tbreak;\n    case 4128: strcpy (model,\"H 20\");\t\tbreak;\n    case 5488: strcpy (model,\"H 25\");\t\tbreak;\n  }\n}\n\nvoid CLASS parse_fuji (int offset)\n{\n  unsigned entries, tag, len, save, c;\n\n  fseek (ifp, offset, SEEK_SET);\n  entries = get4();\n  if (entries > 255) return;\n  while (entries--) {\n    tag = get2();\n    len = get2();\n    save = ftell(ifp);\n    if (tag == 0x100) {\n      raw_height = get2();\n      raw_width  = get2();\n    } else if (tag == 0x121) {\n      height = get2();\n      if ((width = get2()) == 4284) width += 3;\n    } else if (tag == 0x130) {\n      fuji_layout = fgetc(ifp) >> 7;\n      fuji_width = !(fgetc(ifp) & 8);\n    } else if (tag == 0x2ff0) {\n      FORC4 cam_mul[c ^ 1] = get2();\n    } else if (tag == 0xc000) {\n      c = order;\n      order = 0x4949;\n      if ((width = get4()) > 10000) width = get4();\n      height = get4();\n      order = c;\n    }\n    fseek (ifp, save+len, SEEK_SET);\n  }\n  height <<= fuji_layout;\n  width  >>= fuji_layout;\n}\n\nint CLASS parse_jpeg (int offset)\n{\n  int len, save, hlen, mark;\n\n  fseek (ifp, offset, SEEK_SET);\n  if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8) return 0;\n\n  while (fgetc(ifp) == 0xff && (mark = fgetc(ifp)) != 0xda) {\n    order = 0x4d4d;\n    len   = get2() - 2;\n    save  = ftell(ifp);\n    if (mark == 0xc0 || mark == 0xc3) {\n      fgetc(ifp);\n      raw_height = get2();\n      raw_width  = get2();\n    }\n    order = get2();\n    hlen  = get4();\n    if (get4() == 0x48454150)\t\t/* \"HEAP\" */\n      parse_ciff (save+hlen, len-hlen);\n    if (parse_tiff (save+6)) apply_tiff();\n    fseek (ifp, save+len, SEEK_SET);\n  }\n  return 1;\n}\n\nvoid CLASS parse_riff()\n{\n  unsigned i, size, end;\n  char tag[4], date[64], month[64];\n  static const char mon[12][4] =\n  { \"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\" };\n  struct tm t;\n\n  order = 0x4949;\n  fread (tag, 4, 1, ifp);\n  size = get4();\n  end = ftell(ifp) + size;\n  if (!memcmp(tag,\"RIFF\",4) || !memcmp(tag,\"LIST\",4)) {\n    get4();\n    while (ftell(ifp)+7 < end)\n      parse_riff();\n  } else if (!memcmp(tag,\"nctg\",4)) {\n    while (ftell(ifp)+7 < end) {\n      i = get2();\n      size = get2();\n      if ((i+1) >> 1 == 10 && size == 20)\n\tget_timestamp(0);\n      else fseek (ifp, size, SEEK_CUR);\n    }\n  } else if (!memcmp(tag,\"IDIT\",4) && size < 64) {\n    fread (date, 64, 1, ifp);\n    date[size] = 0;\n    memset (&t, 0, sizeof t);\n    if (sscanf (date, \"%*s %s %d %d:%d:%d %d\", month, &t.tm_mday,\n\t&t.tm_hour, &t.tm_min, &t.tm_sec, &t.tm_year) == 6) {\n      for (i=0; i < 12 && strcasecmp(mon[i],month); i++);\n      t.tm_mon = i;\n      t.tm_year -= 1900;\n      if (mktime(&t) > 0)\n\ttimestamp = mktime(&t);\n    }\n  } else\n    fseek (ifp, size, SEEK_CUR);\n}\n\nvoid CLASS parse_smal (int offset, int fsize)\n{\n  int ver;\n\n  fseek (ifp, offset+2, SEEK_SET);\n  order = 0x4949;\n  ver = fgetc(ifp);\n  if (ver == 6)\n    fseek (ifp, 5, SEEK_CUR);\n  if (get4() != fsize) return;\n  if (ver > 6) data_offset = get4();\n  raw_height = height = get2();\n  raw_width  = width  = get2();\n  strcpy (make, \"SMaL\");\n  sprintf (model, \"v%d %dx%d\", ver, width, height);\n  if (ver == 6) load_raw = &CLASS smal_v6_load_raw;\n  if (ver == 9) load_raw = &CLASS smal_v9_load_raw;\n}\n\nvoid CLASS parse_cine()\n{\n  unsigned off_head, off_setup, off_image, i;\n\n  order = 0x4949;\n  fseek (ifp, 4, SEEK_SET);\n  is_raw = get2() == 2;\n  fseek (ifp, 14, SEEK_CUR);\n  is_raw *= get4();\n  off_head = get4();\n  off_setup = get4();\n  off_image = get4();\n  timestamp = get4();\n  if ((i = get4())) timestamp = i;\n  fseek (ifp, off_head+4, SEEK_SET);\n  raw_width = get4();\n  raw_height = get4();\n  switch (get2(),get2()) {\n    case  8:  load_raw = &CLASS eight_bit_load_raw;  break;\n    case 16:  load_raw = &CLASS  unpacked_load_raw;\n  }\n  fseek (ifp, off_setup+792, SEEK_SET);\n  strcpy (make, \"CINE\");\n  sprintf (model, \"%d\", get4());\n  fseek (ifp, 12, SEEK_CUR);\n  switch ((i=get4()) & 0xffffff) {\n    case  3:  filters = 0x94949494;  break;\n    case  4:  filters = 0x49494949;  break;\n    default:  is_raw = 0;\n  }\n  fseek (ifp, 72, SEEK_CUR);\n  switch ((get4()+3600) % 360) {\n    case 270:  flip = 4;  break;\n    case 180:  flip = 1;  break;\n    case  90:  flip = 7;  break;\n    case   0:  flip = 2;\n  }\n  cam_mul[0] = getreal(11);\n  cam_mul[2] = getreal(11);\n  maximum = ~(-1 << get4());\n  fseek (ifp, 668, SEEK_CUR);\n  shutter = get4()/1000000000.0;\n  fseek (ifp, off_image, SEEK_SET);\n  if (shot_select < is_raw)\n    fseek (ifp, shot_select*8, SEEK_CUR);\n  data_offset  = (INT64) get4() + 8;\n  data_offset += (INT64) get4() << 32;\n}\n\nvoid CLASS parse_redcine()\n{\n  unsigned i, len, rdvo;\n\n  order = 0x4d4d;\n  is_raw = 0;\n  fseek (ifp, 52, SEEK_SET);\n  width  = get4();\n  height = get4();\n  fseek (ifp, 0, SEEK_END);\n  fseek (ifp, -(i = ftello(ifp) & 511), SEEK_CUR);\n  if (get4() != i || get4() != 0x52454f42) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s: Tail is missing, parsing from head...\\n\"), ifname);\n#endif\n    fseek (ifp, 0, SEEK_SET);\n    while ((len = get4()) != EOF) {\n      if (get4() == 0x52454456)\n\tif (is_raw++ == shot_select)\n\t  data_offset = ftello(ifp) - 8;\n      fseek (ifp, len-8, SEEK_CUR);\n    }\n  } else {\n    rdvo = get4();\n    fseek (ifp, 12, SEEK_CUR);\n    is_raw = get4();\n    fseeko (ifp, rdvo+8 + shot_select*4, SEEK_SET);\n    data_offset = get4();\n  }\n}\n//@end COMMON\n\n//@out COMMON\nchar * CLASS foveon_gets (int offset, char *str, int len)\n{\n  int i;\n  fseek (ifp, offset, SEEK_SET);\n  for (i=0; i < len-1; i++)\n    if ((str[i] = get2()) == 0) break;\n  str[i] = 0;\n  return str;\n}\n\nvoid CLASS parse_foveon()\n{\n  int entries, img=0, off, len, tag, save, i, wide, high, pent, poff[256][2];\n  char name[64], value[64];\n\n  order = 0x4949;\t\t\t/* Little-endian */\n  fseek (ifp, 36, SEEK_SET);\n  flip = get4();\n  fseek (ifp, -4, SEEK_END);\n  fseek (ifp, get4(), SEEK_SET);\n  if (get4() != 0x64434553) return;\t/* SECd */\n  entries = (get4(),get4());\n  while (entries--) {\n    off = get4();\n    len = get4();\n    tag = get4();\n    save = ftell(ifp);\n    fseek (ifp, off, SEEK_SET);\n    if (get4() != (0x20434553 | (tag << 24))) return;\n    switch (tag) {\n      case 0x47414d49:\t\t\t/* IMAG */\n      case 0x32414d49:\t\t\t/* IMA2 */\n\tfseek (ifp, 8, SEEK_CUR);\n\tpent = get4();\n\twide = get4();\n\thigh = get4();\n\tif (wide > raw_width && high > raw_height) {\n\t  switch (pent) {\n\t    case  5:  load_flags = 1;\n\t    case  6:  load_raw = &CLASS foveon_sd_load_raw;  break;\n\t    case 30:  load_raw = &CLASS foveon_dp_load_raw;  break;\n\t    default:  load_raw = 0;\n\t  }\n\t  raw_width  = wide;\n\t  raw_height = high;\n\t  data_offset = off+28;\n\t}\n\tfseek (ifp, off+28, SEEK_SET);\n\tif (fgetc(ifp) == 0xff && fgetc(ifp) == 0xd8\n\t\t&& thumb_length < len-28) {\n\t  thumb_offset = off+28;\n\t  thumb_length = len-28;\n\t  write_thumb = &CLASS jpeg_thumb;\n\t}\n\tif (++img == 2 && !thumb_length) {\n\t  thumb_offset = off+24;\n\t  thumb_width = wide;\n\t  thumb_height = high;\n\t  write_thumb = &CLASS foveon_thumb;\n\t}\n\tbreak;\n      case 0x464d4143:\t\t\t/* CAMF */\n\tmeta_offset = off+8;\n\tmeta_length = len-28;\n\tbreak;\n      case 0x504f5250:\t\t\t/* PROP */\n\tpent = (get4(),get4());\n\tfseek (ifp, 12, SEEK_CUR);\n\toff += pent*8 + 24;\n\tif ((unsigned) pent > 256) pent=256;\n\tfor (i=0; i < pent*2; i++)\n\t  poff[0][i] = off + get4()*2;\n\tfor (i=0; i < pent; i++) {\n\t  foveon_gets (poff[i][0], name, 64);\n\t  foveon_gets (poff[i][1], value, 64);\n\t  if (!strcmp (name, \"ISO\"))\n\t    iso_speed = atoi(value);\n\t  if (!strcmp (name, \"CAMMANUF\"))\n\t    strcpy (make, value);\n\t  if (!strcmp (name, \"CAMMODEL\"))\n\t    strcpy (model, value);\n\t  if (!strcmp (name, \"WB_DESC\"))\n\t    strcpy (model2, value);\n\t  if (!strcmp (name, \"TIME\"))\n\t    timestamp = atoi(value);\n\t  if (!strcmp (name, \"EXPTIME\"))\n\t    shutter = atoi(value) / 1000000.0;\n\t  if (!strcmp (name, \"APERTURE\"))\n\t    aperture = atof(value);\n\t  if (!strcmp (name, \"FLENGTH\"))\n\t    focal_len = atof(value);\n\t}\n#ifdef LOCALTIME\n\ttimestamp = mktime (gmtime (&timestamp));\n#endif\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n  is_foveon = 1;\n}\n//@end COMMON\n\n//@out COMMON\n/*\n   All matrices are from Adobe DNG Converter unless otherwise noted.\n */\nvoid CLASS adobe_coeff (const char *t_make, const char *t_model)\n{\n  static const struct {\n    const char *prefix;\n    short t_black, t_maximum, trans[12];\n  } table[] = {\n    { \"AGFAPHOTO DC-833m\", 0, 0,\t/* DJC */\n\t{ 11438,-3762,-1115,-2409,9914,2497,-1227,2295,5300 } },\n    { \"Apple QuickTake\", 0, 0,\t\t/* DJC */\n\t{ 21392,-5653,-3353,2406,8010,-415,7166,1427,2078 } },\n    { \"Canon EOS D2000\", 0, 0,\n\t{ 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\n    { \"Canon EOS D6000\", 0, 0,\n\t{ 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\n    { \"Canon EOS D30\", 0, 0,\n\t{ 9805,-2689,-1312,-5803,13064,3068,-2438,3075,8775 } },\n    { \"Canon EOS D60\", 0, 0xfa0,\n\t{ 6188,-1341,-890,-7168,14489,2937,-2640,3228,8483 } },\n    { \"Canon EOS 5D Mark III\", 0, 0x3c80,\n\t{ 6722,-635,-963,-4287,12460,2028,-908,2162,5668 } },\n    { \"Canon EOS 5D Mark II\", 0, 0x3cf0,\n\t{ 4716,603,-830,-7798,15474,2480,-1496,1937,6651 } },\n    { \"Canon EOS 5D\", 0, 0xe6c,\n\t{ 6347,-479,-972,-8297,15954,2480,-1968,2131,7649 } },\n    { \"Canon EOS 6D\", 0, 0x3c82,\n\t{ 7034,-804,-1014,-4420,12564,2058,-851,1994,5758 } },\n    { \"Canon EOS 7D\", 0, 0x3510,\n\t{ 6844,-996,-856,-3876,11761,2396,-593,1772,6198 } },\n    { \"Canon EOS 10D\", 0, 0xfa0,\n\t{ 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\n    { \"Canon EOS 20Da\", 0, 0,\n\t{ 14155,-5065,-1382,-6550,14633,2039,-1623,1824,6561 } },\n    { \"Canon EOS 20D\", 0, 0xfff,\n\t{ 6599,-537,-891,-8071,15783,2424,-1983,2234,7462 } },\n    { \"Canon EOS 30D\", 0, 0,\n\t{ 6257,-303,-1000,-7880,15621,2396,-1714,1904,7046 } },\n    { \"Canon EOS 40D\", 0, 0x3f60,\n\t{ 6071,-747,-856,-7653,15365,2441,-2025,2553,7315 } },\n    { \"Canon EOS 50D\", 0, 0x3d93,\n\t{ 4920,616,-593,-6493,13964,2784,-1774,3178,7005 } },\n    { \"Canon EOS 60D\", 0, 0x2ff7,\n\t{ 6719,-994,-925,-4408,12426,2211,-887,2129,6051 } },\n    { \"Canon EOS 70D\", 0, 0x3c80,\n\t{ 7034,-804,-1014,-4420,12564,2058,-851,1994,5758 } },\n    { \"Canon EOS 300D\", 0, 0xfa0,\n\t{ 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\n    { \"Canon EOS 350D\", 0, 0xfff,\n\t{ 6018,-617,-965,-8645,15881,2975,-1530,1719,7642 } },\n    { \"Canon EOS 400D\", 0, 0xe8e,\n\t{ 7054,-1501,-990,-8156,15544,2812,-1278,1414,7796 } },\n    { \"Canon EOS 450D\", 0, 0x390d,\n\t{ 5784,-262,-821,-7539,15064,2672,-1982,2681,7427 } },\n    { \"Canon EOS 500D\", 0, 0x3479,\n\t{ 4763,712,-646,-6821,14399,2640,-1921,3276,6561 } },\n    { \"Canon EOS 550D\", 0, 0x3dd7,\n\t{ 6941,-1164,-857,-3825,11597,2534,-416,1540,6039 } },\n    { \"Canon EOS 600D\", 0, 0x3510,\n\t{ 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },\n    { \"Canon EOS 650D\", 0, 0x354d,\n\t{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 700D\", 0, 0x354d,\n\t{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS REBEL T5i\", 0, 0x354d,\n\t{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 1000D\", 0, 0xe43,\n\t{ 6771,-1139,-977,-7818,15123,2928,-1244,1437,7533 } },\n    { \"Canon EOS 1100D\", 0, 0x3510,\n\t{ 6444,-904,-893,-4563,12308,2535,-903,2016,6728 } },\n    { \"Canon EOS M\", 0, 0,\n\t{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS-1Ds Mark III\", 0, 0x3bb0,\n\t{ 5859,-211,-930,-8255,16017,2353,-1732,1887,7448 } },\n    { \"Canon EOS-1Ds Mark II\", 0, 0xe80,\n\t{ 6517,-602,-867,-8180,15926,2378,-1618,1771,7633 } },\n    { \"Canon EOS-1D Mark IV\", 0, 0x3bb0,\n\t{ 6014,-220,-795,-4109,12014,2361,-561,1824,5787 } },\n    { \"Canon EOS-1D Mark III\", 0, 0x3bb0,\n\t{ 6291,-540,-976,-8350,16145,2311,-1714,1858,7326 } },\n    { \"Canon EOS-1D Mark II N\", 0, 0xe80,\n\t{ 6240,-466,-822,-8180,15825,2500,-1801,1938,8042 } },\n    { \"Canon EOS-1D Mark II\", 0, 0xe80,\n\t{ 6264,-582,-724,-8312,15948,2504,-1744,1919,8664 } },\n    { \"Canon EOS-1DS\", 0, 0xe20,\n\t{ 4374,3631,-1743,-7520,15212,2472,-2892,3632,8161 } },\n    { \"Canon EOS-1D X\", 0, 0x3c4e,\n\t{ 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },\n    { \"Canon EOS-1D\", 0, 0xe20,\n\t{ 6806,-179,-1020,-8097,16415,1687,-3267,4236,7690 } },\n    { \"Canon EOS 100D\", 0, 0x3cf0,\n\t{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS REBEL SL1\", 0, 0x3cf0,\n\t{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS\", 0, 0,\n\t{ 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\n    { \"Canon PowerShot A530\", 0, 0,\n\t{ 0 } },\t/* don't want the A5 matrix */\n    { \"Canon PowerShot A50\", 0, 0,\n\t{ -5300,9846,1776,3436,684,3939,-5540,9879,6200,-1404,11175,217 } },\n    { \"Canon PowerShot A5\", 0, 0,\n\t{ -4801,9475,1952,2926,1611,4094,-5259,10164,5947,-1554,10883,547 } },\n    { \"Canon PowerShot G10\", 0, 0,\n\t{ 11093,-3906,-1028,-5047,12492,2879,-1003,1750,5561 } },\n    { \"Canon PowerShot G11\", 0, 0,\n\t{ 12177,-4817,-1069,-1612,9864,2049,-98,850,4471 } },\n    { \"Canon PowerShot G12\", 0, 0,\n\t{ 13244,-5501,-1248,-1508,9858,1935,-270,1083,4366 } },\n    { \"Canon PowerShot G15\", 0, 0,\n\t{ 7474,-2301,-567,-4056,11456,2975,-222,716,4181 } },\n    { \"Canon PowerShot G1 X\", 0, 0,\n\t{ 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },\n    { \"Canon PowerShot G1\", 0, 0,\n\t{ -4778,9467,2172,4743,-1141,4344,-5146,9908,6077,-1566,11051,557 } },\n    { \"Canon PowerShot G2\", 0, 0,\n\t{ 9087,-2693,-1049,-6715,14382,2537,-2291,2819,7790 } },\n    { \"Canon PowerShot G3\", 0, 0,\n\t{ 9212,-2781,-1073,-6573,14189,2605,-2300,2844,7664 } },\n    { \"Canon PowerShot G5\", 0, 0,\n\t{ 9757,-2872,-933,-5972,13861,2301,-1622,2328,7212 } },\n    { \"Canon PowerShot G6\", 0, 0,\n\t{ 9877,-3775,-871,-7613,14807,3072,-1448,1305,7485 } },\n    { \"Canon PowerShot G9\", 0, 0,\n\t{ 7368,-2141,-598,-5621,13254,2625,-1418,1696,5743 } },\n    { \"Canon PowerShot Pro1\", 0, 0,\n\t{ 10062,-3522,-999,-7643,15117,2730,-765,817,7323 } },\n    { \"Canon PowerShot Pro70\", 34, 0,\n\t{ -4155,9818,1529,3939,-25,4522,-5521,9870,6610,-2238,10873,1342 } },\n    { \"Canon PowerShot Pro90\", 0, 0,\n\t{ -4963,9896,2235,4642,-987,4294,-5162,10011,5859,-1770,11230,577 } },\n    { \"Canon PowerShot S30\", 0, 0,\n\t{ 10566,-3652,-1129,-6552,14662,2006,-2197,2581,7670 } },\n    { \"Canon PowerShot S40\", 0, 0,\n\t{ 8510,-2487,-940,-6869,14231,2900,-2318,2829,9013 } },\n    { \"Canon PowerShot S45\", 0, 0,\n\t{ 8163,-2333,-955,-6682,14174,2751,-2077,2597,8041 } },\n    { \"Canon PowerShot S50\", 0, 0,\n\t{ 8882,-2571,-863,-6348,14234,2288,-1516,2172,6569 } },\n    { \"Canon PowerShot S60\", 0, 0,\n\t{ 8795,-2482,-797,-7804,15403,2573,-1422,1996,7082 } },\n    { \"Canon PowerShot S70\", 0, 0,\n\t{ 9976,-3810,-832,-7115,14463,2906,-901,989,7889 } },\n    { \"Canon PowerShot S90\", 0, 0,\n\t{ 12374,-5016,-1049,-1677,9902,2078,-83,852,4683 } },\n    { \"Canon PowerShot S95\", 0, 0,\n\t{ 13440,-5896,-1279,-1236,9598,1931,-180,1001,4651 } },\n    { \"Canon PowerShot S110\", 0, 0,\n\t{ 8039,-2643,-654,-3783,11230,2930,-206,690,4194 } },\n    { \"Canon PowerShot S100\", 0, 0,\n\t{ 7968,-2565,-636,-2873,10697,2513,180,667,4211 } },\n    { \"Canon PowerShot S110\", 0, 0,\n\t{ 8039,-2643,-654,-3783,11230,2930,-206,690,4194 } },\n    { \"Canon PowerShot SX1 IS\", 0, 0,\n\t{ 6578,-259,-502,-5974,13030,3309,-308,1058,4970 } },\n    { \"Canon PowerShot SX50 HS\", 0, 0,\n\t{ 12432,-4753,-1247,-2110,10691,1629,-412,1623,4926 } },\n    { \"Canon PowerShot A470\", 0, 0,\t/* DJC */\n\t{ 12513,-4407,-1242,-2680,10276,2405,-878,2215,4734 } },\n    { \"Canon PowerShot A610\", 0, 0,\t/* DJC */\n\t{ 15591,-6402,-1592,-5365,13198,2168,-1300,1824,5075 } },\n    { \"Canon PowerShot A620\", 0, 0,\t/* DJC */\n\t{ 15265,-6193,-1558,-4125,12116,2010,-888,1639,5220 } },\n    { \"Canon PowerShot A630\", 0, 0,\t/* DJC */\n\t{ 14201,-5308,-1757,-6087,14472,1617,-2191,3105,5348 } },\n    { \"Canon PowerShot A640\", 0, 0,\t/* DJC */\n\t{ 13124,-5329,-1390,-3602,11658,1944,-1612,2863,4885 } },\n    { \"Canon PowerShot A650\", 0, 0,\t/* DJC */\n\t{ 9427,-3036,-959,-2581,10671,1911,-1039,1982,4430 } },\n    { \"Canon PowerShot A720\", 0, 0,\t/* DJC */\n\t{ 14573,-5482,-1546,-1266,9799,1468,-1040,1912,3810 } },\n    { \"Canon PowerShot S3 IS\", 0, 0,\t/* DJC */\n\t{ 14062,-5199,-1446,-4712,12470,2243,-1286,2028,4836 } },\n    { \"Canon PowerShot SX110 IS\", 0, 0,\t/* DJC */\n\t{ 14134,-5576,-1527,-1991,10719,1273,-1158,1929,3581 } },\n    { \"Canon PowerShot SX220\", 0, 0,\t/* DJC */\n\t{ 13898,-5076,-1447,-1405,10109,1297,-244,1860,3687 } },\n    { \"Canon PowerShot SX50\", 0, 0,\n\t{ 12432,-4753,-1247,-2110,10691,1629,-412,1623,4926 } },\n    { \"CASIO EX-S20\", 0, 0,\t\t/* DJC */\n\t{ 11634,-3924,-1128,-4968,12954,2015,-1588,2648,7206 } },\n    { \"CASIO EX-Z750\", 0, 0,\t\t/* DJC */\n\t{ 10819,-3873,-1099,-4903,13730,1175,-1755,3751,4632 } },\n    { \"CASIO EX-Z10\", 128, 0xfff,\t/* DJC */\n\t{ 9790,-3338,-603,-2321,10222,2099,-344,1273,4799 } },\n    { \"CINE 650\", 0, 0,\n\t{ 3390,480,-500,-800,3610,340,-550,2336,1192 } },\n    { \"CINE 660\", 0, 0,\n\t{ 3390,480,-500,-800,3610,340,-550,2336,1192 } },\n    { \"CINE\", 0, 0,\n\t{ 20183,-4295,-423,-3940,15330,3985,-280,4870,9800 } },\n    { \"Contax N Digital\", 0, 0xf1e,\n\t{ 7777,1285,-1053,-9280,16543,2916,-3677,5679,7060 } },\n    { \"EPSON R-D1\", 0, 0,\n\t{ 6827,-1878,-732,-8429,16012,2564,-704,592,7145 } },\n    { \"FUJIFILM E550\", 0, 0,\n\t{ 11044,-3888,-1120,-7248,15168,2208,-1531,2277,8069 } },\n    { \"FUJIFILM E900\", 0, 0,\n\t{ 9183,-2526,-1078,-7461,15071,2574,-2022,2440,8639 } },\n    { \"FUJIFILM F5\", 0, 0,\n\t{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"FUJIFILM F6\", 0, 0,\n\t{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"FUJIFILM F77\", 0, 0xfe9,\n\t{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"FUJIFILM F7\", 0, 0,\n\t{ 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\n    { \"FUJIFILM F800\", 0, 0,\n\t{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"FUJIFILM F8\", 0, 0,\n\t{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"FUJIFILM S100FS\", 514, 0,\n\t{ 11521,-4355,-1065,-6524,13767,3058,-1466,1984,6045 } },\n    { \"FUJIFILM S200EXR\", 512, 0x3fff,\n\t{ 11401,-4498,-1312,-5088,12751,2613,-838,1568,5941 } },\n    { \"FUJIFILM S20Pro\", 0, 0,\n\t{ 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\n    { \"FUJIFILM S2Pro\", 128, 0,\n\t{ 12492,-4690,-1402,-7033,15423,1647,-1507,2111,7697 } },\n    { \"FUJIFILM S3Pro\", 0, 0,\n\t{ 11807,-4612,-1294,-8927,16968,1988,-2120,2741,8006 } },\n    { \"FUJIFILM S5Pro\", 0, 0,\n\t{ 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\n    { \"FUJIFILM S5000\", 0, 0,\n\t{ 8754,-2732,-1019,-7204,15069,2276,-1702,2334,6982 } },\n    { \"FUJIFILM S5100\", 0, 0,\n\t{ 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\n    { \"FUJIFILM S5500\", 0, 0,\n\t{ 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\n    { \"FUJIFILM S5200\", 0, 0,\n\t{ 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\n    { \"FUJIFILM S5600\", 0, 0,\n\t{ 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\n    { \"FUJIFILM S6\", 0, 0,\n\t{ 12628,-4887,-1401,-6861,14996,1962,-2198,2782,7091 } },\n    { \"FUJIFILM S7000\", 0, 0,\n\t{ 10190,-3506,-1312,-7153,15051,2238,-2003,2399,7505 } },\n    { \"FUJIFILM S9000\", 0, 0,\n\t{ 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\n    { \"FUJIFILM S9500\", 0, 0,\n\t{ 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\n    { \"FUJIFILM S9100\", 0, 0,\n\t{ 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\n    { \"FUJIFILM S9600\", 0, 0,\n\t{ 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\n    { \"FUJIFILM IS-1\", 0, 0,\n\t{ 21461,-10807,-1441,-2332,10599,1999,289,875,7703 } },\n    { \"FUJIFILM IS Pro\", 0, 0,\n\t{ 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\n    { \"FUJIFILM HS10 HS11\", 0, 0xf68,\n\t{ 12440,-3954,-1183,-1123,9674,1708,-83,1614,4086 } },\n    { \"FUJIFILM HS20EXR\", 0, 0,\n\t{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"FUJIFILM HS3\", 0, 0,\n\t{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"FUJIFILM HS50EXR\", 0, 0,\n\t{ 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },\n    { \"FUJIFILM SL1000\", 0, 0,\n\t{ 11705,-4262,-1107,-2282,10791,1709,-555,1713,4945 } },\n    { \"FUJIFILM X100S\", 0, 0,\n\t{ 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },\n    { \"FUJIFILM X100\", 0, 0,\n\t{ 12161,-4457,-1069,-5034,12874,2400,-795,1724,6904 } },\n    { \"FUJIFILM X10\", 0, 0,\n\t{ 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"FUJIFILM X20\", 0, 0,\n\t{ 11768,-4971,-1133,-4904,12927,2183,-480,1723,4605 } },\n    { \"FUJIFILM XF1\", 0, 0,\n\t{ 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"FUJIFILM X-Pro1\", 0, 0,\n\t{ 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },\n    { \"FUJIFILM X-E1\", 0, 0,\n\t{ 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },\n    { \"FUJIFILM XF1\", 0, 0,\n\t{ 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"FUJIFILM X-S1\", 0, 0,\n\t{ 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Imacon Ixpress\", 0, 0,\t\t/* DJC */\n\t{ 7025,-1415,-704,-5188,13765,1424,-1248,2742,6038 } },\n    { \"KODAK NC2000\", 0, 0,\n\t{ 13891,-6055,-803,-465,9919,642,2121,82,1291 } },\n    { \"Kodak DCS315C\", 8, 0,\n\t{ 17523,-4827,-2510,756,8546,-137,6113,1649,2250 } },\n    { \"Kodak DCS330C\", 8, 0,\n\t{ 20620,-7572,-2801,-103,10073,-396,3551,-233,2220 } },\n    { \"KODAK DCS420\", 0, 0,\n\t{ 10868,-1852,-644,-1537,11083,484,2343,628,2216 } },\n    { \"KODAK DCS460\", 0, 0,\n\t{ 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\n    { \"KODAK EOSDCS1\", 0, 0,\n\t{ 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\n    { \"KODAK EOSDCS3B\", 0, 0,\n\t{ 9898,-2700,-940,-2478,12219,206,1985,634,1031 } },\n    { \"Kodak DCS520C\", 178, 0,\n\t{ 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\n    { \"Kodak DCS560C\", 177, 0,\n\t{ 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\n    { \"Kodak DCS620C\", 177, 0,\n\t{ 23617,-10175,-3149,-2054,11749,-272,2586,-489,3453 } },\n    { \"Kodak DCS620X\", 176, 0,\n\t{ 13095,-6231,154,12221,-21,-2137,895,4602,2258 } },\n    { \"Kodak DCS660C\", 173, 0,\n\t{ 18244,-6351,-2739,-791,11193,-521,3711,-129,2802 } },\n    { \"Kodak DCS720X\", 0, 0,\n\t{ 11775,-5884,950,9556,1846,-1286,-1019,6221,2728 } },\n    { \"Kodak DCS760C\", 0, 0,\n\t{ 16623,-6309,-1411,-4344,13923,323,2285,274,2926 } },\n    { \"Kodak DCS Pro SLR\", 0, 0,\n\t{ 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\n    { \"Kodak DCS Pro 14nx\", 0, 0,\n\t{ 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\n    { \"Kodak DCS Pro 14\", 0, 0,\n\t{ 7791,3128,-776,-8588,16458,2039,-2455,4006,6198 } },\n    { \"Kodak ProBack645\", 0, 0,\n\t{ 16414,-6060,-1470,-3555,13037,473,2545,122,4948 } },\n    { \"Kodak ProBack\", 0, 0,\n\t{ 21179,-8316,-2918,-915,11019,-165,3477,-180,4210 } },\n    { \"KODAK P712\", 0, 0,\n\t{ 9658,-3314,-823,-5163,12695,2768,-1342,1843,6044 } },\n    { \"KODAK P850\", 0, 0xf7c,\n\t{ 10511,-3836,-1102,-6946,14587,2558,-1481,1792,6246 } },\n    { \"KODAK P880\", 0, 0xfff,\n\t{ 12805,-4662,-1376,-7480,15267,2360,-1626,2194,7904 } },\n    { \"KODAK EasyShare Z980\", 0, 0,\n\t{ 11313,-3559,-1101,-3893,11891,2257,-1214,2398,4908 } },\n    { \"KODAK EasyShare Z981\", 0, 0,\n\t{ 12729,-4717,-1188,-1367,9187,2582,274,860,4411 } },\n    { \"KODAK EasyShare Z990\", 0, 0xfed,\n\t{ 11749,-4048,-1309,-1867,10572,1489,-138,1449,4522 } },\n    { \"KODAK EASYSHARE Z1015\", 0, 0xef1,\n\t{ 11265,-4286,-992,-4694,12343,2647,-1090,1523,5447 } },\n    { \"Leaf CMost\", 0, 0,\n\t{ 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\n    { \"Leaf Valeo 6\", 0, 0,\n\t{ 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\n    { \"Leaf Aptus 54S\", 0, 0,\n\t{ 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\n    { \"Leaf Aptus 65\", 0, 0,\n\t{ 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf Aptus 75\", 0, 0,\n\t{ 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf\", 0, 0,\n\t{ 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\n    { \"Mamiya ZD\", 0, 0,\n\t{ 7645,2579,-1363,-8689,16717,2015,-3712,5941,5961 } },\n    { \"Micron 2010\", 110, 0,\t\t/* DJC */\n\t{ 16695,-3761,-2151,155,9682,163,3433,951,4904 } },\n    { \"Minolta DiMAGE 5\", 0, 0xf7d,\n\t{ 8983,-2942,-963,-6556,14476,2237,-2426,2887,8014 } },\n    { \"Minolta DiMAGE 7Hi\", 0, 0xf7d,\n\t{ 11368,-3894,-1242,-6521,14358,2339,-2475,3056,7285 } },\n    { \"Minolta DiMAGE 7\", 0, 0xf7d,\n\t{ 9144,-2777,-998,-6676,14556,2281,-2470,3019,7744 } },\n    { \"Minolta DiMAGE A1\", 0, 0xf8b,\n\t{ 9274,-2547,-1167,-8220,16323,1943,-2273,2720,8340 } },\n    { \"MINOLTA DiMAGE A200\", 0, 0,\n\t{ 8560,-2487,-986,-8112,15535,2771,-1209,1324,7743 } },\n    { \"Minolta DiMAGE A2\", 0, 0xf8f,\n\t{ 9097,-2726,-1053,-8073,15506,2762,-966,981,7763 } },\n    { \"Minolta DiMAGE Z2\", 0, 0,\t/* DJC */\n\t{ 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\n    { \"MINOLTA DYNAX 5\", 0, 0xffb,\n\t{ 10284,-3283,-1086,-7957,15762,2316,-829,882,6644 } },\n    { \"MINOLTA DYNAX 7\", 0, 0xffb,\n\t{ 10239,-3104,-1099,-8037,15727,2451,-927,925,6871 } },\n    { \"MOTOROLA PIXL\", 0, 0,\t\t/* DJC */\n\t{ 8898,-989,-1033,-3292,11619,1674,-661,3178,5216 } },\n    { \"NIKON D100\", 0, 0,\n\t{ 5902,-933,-782,-8983,16719,2354,-1402,1455,6464 } },\n    { \"NIKON D1H\", 0, 0,\n\t{ 7577,-2166,-926,-7454,15592,1934,-2377,2808,8606 } },\n    { \"NIKON D1X\", 0, 0,\n\t{ 7702,-2245,-975,-9114,17242,1875,-2679,3055,8521 } },\n    { \"NIKON D1\", 0, 0, /* multiplied by 2.218750, 1.0, 1.148438 */\n\t{ 16772,-4726,-2141,-7611,15713,1972,-2846,3494,9521 } },\n    { \"NIKON D200\", 0, 0xfbc,\n\t{ 8367,-2248,-763,-8758,16447,2422,-1527,1550,8053 } },\n    { \"NIKON D2H\", 0, 0,\n\t{ 5710,-901,-615,-8594,16617,2024,-2975,4120,6830 } },\n    { \"NIKON D2X\", 0, 0,\n\t{ 10231,-2769,-1255,-8301,15900,2552,-797,680,7148 } },\n    { \"NIKON D3000\", 0, 0,\n\t{ 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },\n    { \"NIKON D3100\", 0, 0,\n\t{ 7911,-2167,-813,-5327,13150,2408,-1288,2483,7968 } },\n    { \"NIKON D3200\", 0, 0xfb9,\n\t{ 7013,-1408,-635,-5268,12902,2640,-1470,2801,7379 } },\n    { \"NIKON D300\", 0, 0,\n\t{ 9030,-1992,-715,-8465,16302,2255,-2689,3217,8069 } },\n    { \"NIKON D3X\", 0, 0,\n\t{ 7171,-1986,-648,-8085,15555,2718,-2170,2512,7457 } },\n    { \"NIKON D3S\", 0, 0,\n\t{ 8828,-2406,-694,-4874,12603,2541,-660,1509,7587 } },\n    { \"NIKON D3\", 0, 0,\n\t{ 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\n    { \"NIKON D40X\", 0, 0,\n\t{ 8819,-2543,-911,-9025,16928,2151,-1329,1213,8449 } },\n    { \"NIKON D40\", 0, 0,\n\t{ 6992,-1668,-806,-8138,15748,2543,-874,850,7897 } },\n    { \"NIKON D4\", 0, 0,\n\t{ 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"NIKON D5000\", 0, 0xf00,\n\t{ 7309,-1403,-519,-8474,16008,2622,-2433,2826,8064 } },\n    { \"NIKON D5100\", 0, 0x3de6,\n\t{ 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"NIKON D5200\", 0, 0,\n\t{ 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"NIKON D50\", 0, 0,\n\t{ 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\n    { \"NIKON D600\", 0, 0x3e07,\n\t{ 8178,-2245,-609,-4857,12394,2776,-1207,2086,7298 } },\n    { \"NIKON D60\", 0, 0,\n\t{ 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },\n    { \"NIKON D7000\", 0, 0,\n\t{ 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"NIKON D700\", 0, 0,\n\t{ 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\n    { \"NIKON D70\", 0, 0,\n\t{ 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\n    { \"NIKON D7100\", 0, 0,\n\t{ 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"NIKON D800\", 0, 0,\n\t{ 7866,-2108,-555,-4869,12483,2681,-1176,2069,7501 } },\n    { \"NIKON D80\", 0, 0,\n\t{ 8629,-2410,-883,-9055,16940,2171,-1490,1363,8520 } },\n    { \"NIKON D90\", 0, 0xf00,\n\t{ 7309,-1403,-519,-8474,16008,2622,-2434,2826,8064 } },\n    { \"NIKON E950\", 0, 0x3dd,\t\t/* DJC */\n\t{ -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"NIKON E995\", 0, 0,\t/* copied from E5000 */\n\t{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"NIKON E2100\", 0, 0,\t/* copied from Z2, new white balance */\n\t{ 13142,-4152,-1596,-4655,12374,2282,-1769,2696,6711} },\n    { \"NIKON E2500\", 0, 0,\n\t{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"NIKON E3200\", 0, 0,\t\t/* DJC */\n\t{ 9846,-2085,-1019,-3278,11109,2170,-774,2134,5745 } },\n    { \"NIKON E4300\", 0, 0,\t/* copied from Minolta DiMAGE Z2 */\n\t{ 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\n    { \"NIKON E4500\", 0, 0,\n\t{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"NIKON E5000\", 0, 0,\n\t{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"NIKON E5400\", 0, 0,\n\t{ 9349,-2987,-1001,-7919,15766,2266,-2098,2680,6839 } },\n    { \"NIKON E5700\", 0, 0,\n\t{ -5368,11478,2368,5537,-113,3148,-4969,10021,5782,778,9028,211 } },\n    { \"NIKON E8400\", 0, 0,\n\t{ 7842,-2320,-992,-8154,15718,2599,-1098,1342,7560 } },\n    { \"NIKON E8700\", 0, 0,\n\t{ 8489,-2583,-1036,-8051,15583,2643,-1307,1407,7354 } },\n    { \"NIKON E8800\", 0, 0,\n\t{ 7971,-2314,-913,-8451,15762,2894,-1442,1520,7610 } },\n    { \"NIKON COOLPIX A\", 0, 0,\n\t{ 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"NIKON COOLPIX P330\", 0, 0,\n\t{ 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"NIKON COOLPIX P6000\", 0, 0,\n\t{ 9698,-3367,-914,-4706,12584,2368,-837,968,5801 } },\n    { \"NIKON COOLPIX P7000\", 0, 0,\n\t{ 11432,-3679,-1111,-3169,11239,2202,-791,1380,4455 } },\n    { \"NIKON COOLPIX P7100\", 0, 0,\n\t{ 11053,-4269,-1024,-1976,10182,2088,-526,1263,4469 } },\n    { \"NIKON COOLPIX P7700\", 200, 0,\n\t{ 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"NIKON 1 J3\", 0, 0,\n\t{ 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },\n    { \"NIKON 1 S1\", 0, 0,\n\t{ 8994,-2667,-865,-4594,12324,2552,-699,1786,6260 } },\n    { \"NIKON 1 V2\", 0, 0,\n\t{ 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },\n    { \"NIKON 1 \", 0, 0,\n\t{ 8994,-2667,-865,-4594,12324,2552,-699,1786,6260 } },\n    { \"OLYMPUS C5050\", 0, 0,\n\t{ 10508,-3124,-1273,-6079,14294,1901,-1653,2306,6237 } },\n    { \"OLYMPUS C5060\", 0, 0,\n\t{ 10445,-3362,-1307,-7662,15690,2058,-1135,1176,7602 } },\n    { \"OLYMPUS C7070\", 0, 0,\n\t{ 10252,-3531,-1095,-7114,14850,2436,-1451,1723,6365 } },\n    { \"OLYMPUS C70\", 0, 0,\n\t{ 10793,-3791,-1146,-7498,15177,2488,-1390,1577,7321 } },\n    { \"OLYMPUS C80\", 0, 0,\n\t{ 8606,-2509,-1014,-8238,15714,2703,-942,979,7760 } },\n    { \"OLYMPUS E-10\", 0, 0xffc,\n\t{ 12745,-4500,-1416,-6062,14542,1580,-1934,2256,6603 } },\n    { \"OLYMPUS E-1\", 0, 0,\n\t{ 11846,-4767,-945,-7027,15878,1089,-2699,4122,8311 } },\n    { \"OLYMPUS E-20\", 0, 0xffc,\n\t{ 13173,-4732,-1499,-5807,14036,1895,-2045,2452,7142 } },\n    { \"OLYMPUS E-300\", 0, 0,\n\t{ 7828,-1761,-348,-5788,14071,1830,-2853,4518,6557 } },\n    { \"OLYMPUS E-330\", 0, 0,\n\t{ 8961,-2473,-1084,-7979,15990,2067,-2319,3035,8249 } },\n    { \"OLYMPUS E-30\", 0, 0xfbc,\n\t{ 8144,-1861,-1111,-7763,15894,1929,-1865,2542,7607 } },\n    { \"OLYMPUS E-3\", 0, 0xf99,\n\t{ 9487,-2875,-1115,-7533,15606,2010,-1618,2100,7389 } },\n    { \"OLYMPUS E-400\", 0, 0,\n\t{ 6169,-1483,-21,-7107,14761,2536,-2904,3580,8568 } },\n    { \"OLYMPUS E-410\", 0, 0xf6a,\n\t{ 8856,-2582,-1026,-7761,15766,2082,-2009,2575,7469 } },\n    { \"OLYMPUS E-420\", 0, 0xfd7,\n\t{ 8746,-2425,-1095,-7594,15612,2073,-1780,2309,7416 } },\n    { \"OLYMPUS E-450\", 0, 0xfd2,\n\t{ 8745,-2425,-1095,-7594,15613,2073,-1780,2309,7416 } },\n    { \"OLYMPUS E-500\", 0, 0,\n\t{ 8136,-1968,-299,-5481,13742,1871,-2556,4205,6630 } },\n    { \"OLYMPUS E-510\", 0, 0xf6a,\n\t{ 8785,-2529,-1033,-7639,15624,2112,-1783,2300,7817 } },\n    { \"OLYMPUS E-520\", 0, 0xfd2,\n\t{ 8344,-2322,-1020,-7596,15635,2048,-1748,2269,7287 } },\n    { \"OLYMPUS E-5\", 0, 0xeec,\n\t{ 11200,-3783,-1325,-4576,12593,2206,-695,1742,7504 } },\n    { \"OLYMPUS E-600\", 0, 0xfaf,\n\t{ 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },\n    { \"OLYMPUS E-620\", 0, 0xfaf,\n\t{ 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },\n    { \"OLYMPUS E-P1\", 0, 0xffd,\n\t{ 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },\n    { \"OLYMPUS E-P2\", 0, 0xffd,\n\t{ 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },\n    { \"OLYMPUS E-P3\", 0, 0,\n\t{ 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"OLYMPUS E-P5\", 0, 0,\n\t{ 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"OLYMPUS E-PL1s\", 0, 0,\n\t{ 11409,-3872,-1393,-4572,12757,2003,-709,1810,7415 } },\n    { \"OLYMPUS E-PL1\", 0, 0,\n\t{ 11408,-4289,-1215,-4286,12385,2118,-387,1467,7787 } },\n    { \"OLYMPUS E-PL2\", 0, 0,\n\t{ 15030,-5552,-1806,-3987,12387,1767,-592,1670,7023 } },\n    { \"OLYMPUS E-PL3\", 0, 0,\n\t{ 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"OLYMPUS E-PL5\", 0, 0xfcb,\n\t{ 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"OLYMPUS E-PM1\", 0, 0,\n\t{ 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"OLYMPUS E-PM2\", 0, 0,\n\t{ 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"OLYMPUS E-M5\", 0, 0xfe1,\n\t{ 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"OLYMPUS SP350\", 0, 0,\n\t{ 12078,-4836,-1069,-6671,14306,2578,-786,939,7418 } },\n    { \"OLYMPUS SP3\", 0, 0,\n\t{ 11766,-4445,-1067,-6901,14421,2707,-1029,1217,7572 } },\n    { \"OLYMPUS SP500UZ\", 0, 0xfff,\n\t{ 9493,-3415,-666,-5211,12334,3260,-1548,2262,6482 } },\n    { \"OLYMPUS SP510UZ\", 0, 0xffe,\n\t{ 10593,-3607,-1010,-5881,13127,3084,-1200,1805,6721 } },\n    { \"OLYMPUS SP550UZ\", 0, 0xffe,\n\t{ 11597,-4006,-1049,-5432,12799,2957,-1029,1750,6516 } },\n    { \"OLYMPUS SP560UZ\", 0, 0xff9,\n\t{ 10915,-3677,-982,-5587,12986,2911,-1168,1968,6223 } },\n    { \"OLYMPUS SP570UZ\", 0, 0,\n\t{ 11522,-4044,-1146,-4736,12172,2904,-988,1829,6039 } },\n    { \"OLYMPUS XZ-10\", 0, 0,\n\t{ 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },\n    { \"OLYMPUS XZ-1\", 0, 0,\n\t{ 10901,-4095,-1074,-1141,9208,2293,-62,1417,5158 } },\n    { \"OLYMPUS XZ-2\", 0, 0,\n\t{ 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },\n    { \"OmniVision ov5647\", 0, 0,\t/* DJC */\n\t{ 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } },\n    { \"PENTAX *ist DL2\", 0, 0,\n\t{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"PENTAX *ist DL\", 0, 0,\n\t{ 10829,-2838,-1115,-8339,15817,2696,-837,680,11939 } },\n    { \"PENTAX *ist DS2\", 0, 0,\n\t{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"PENTAX *ist DS\", 0, 0,\n\t{ 10371,-2333,-1206,-8688,16231,2602,-1230,1116,11282 } },\n    { \"PENTAX *ist D\", 0, 0,\n\t{ 9651,-2059,-1189,-8881,16512,2487,-1460,1345,10687 } },\n    { \"PENTAX K10D\", 0, 0,\n\t{ 9566,-2863,-803,-7170,15172,2112,-818,803,9705 } },\n    { \"PENTAX K1\", 0, 0,\n\t{ 11095,-3157,-1324,-8377,15834,2720,-1108,947,11688 } },\n    { \"PENTAX K20D\", 0, 0,\n\t{ 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },\n    { \"PENTAX K200D\", 0, 0,\n\t{ 9186,-2678,-907,-8693,16517,2260,-1129,1094,8524 } },\n    { \"PENTAX K2000\", 0, 0,\n\t{ 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },\n    { \"PENTAX K-m\", 0, 0,\n\t{ 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },\n    { \"PENTAX K-x\", 0, 0,\n\t{ 8843,-2837,-625,-5025,12644,2668,-411,1234,7410 } },\n    { \"PENTAX K-r\", 0, 0,\n\t{ 9895,-3077,-850,-5304,13035,2521,-883,1768,6936 } },\n    { \"PENTAX K-30\", 0, 0,\n\t{ 8833,-2670,-1183,-3995,12301,1881,-979,1717,6527 } },\n    { \"PENTAX K-5 II s\", 0, 0,\n\t{ 8366,-2528,-1120,-3995,12301,1881,-998,1749,6649 } },\n    { \"PENTAX K-5 II\", 0, 0,\n\t{ 8773,-2651,-1175,-3995,12301,1881,-973,1706,6486 } },\n    { \"PENTAX K-5\", 0, 0,\n\t{ 8713,-2833,-743,-4342,11900,2772,-722,1543,6247 } },\n    { \"PENTAX K-7\", 0, 0,\n\t{ 9142,-2947,-678,-8648,16967,1663,-2224,2898,8615 } },\n    { \"PENTAX MX-1\", 0, 0,\n\t{ 8804,-2523,-1238,-2423,11627,860,-682,1774,4753 } },\n    { \"PENTAX Q10\", 0, 0,\n\t{ 12995,-5593,-1107,-1879,10139,2027,-64,1233,4919 } },\n    { \"PENTAX 645D\", 0, 0x3e00,\n\t{ 10646,-3593,-1158,-3329,11699,1831,-667,2874,6287 } },\n    { \"Panasonic DMC-FZ8\", 0, 0xf7f,\n\t{ 8986,-2755,-802,-6341,13575,3077,-1476,2144,6379 } },\n    { \"Panasonic DMC-FZ18\", 0, 0,\n\t{ 9932,-3060,-935,-5809,13331,2753,-1267,2155,5575 } },\n    { \"Panasonic DMC-FZ28\", 15, 0xf96,\n\t{ 10109,-3488,-993,-5412,12812,2916,-1305,2140,5543 } },\n    { \"Panasonic DMC-FZ30\", 0, 0xf94,\n\t{ 10976,-4029,-1141,-7918,15491,2600,-1670,2071,8246 } },\n    { \"Panasonic DMC-FZ3\", 143, 0,\n\t{ 9938,-2780,-890,-4604,12393,2480,-1117,2304,4620 } },\n    { \"Panasonic DMC-FZ4\", 143, 0,\n\t{ 13639,-5535,-1371,-1698,9633,2430,316,1152,4108 } },\n    { \"Panasonic DMC-FZ50\", 0, 0,\n\t{ 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\n    { \"LEICA V-LUX1\", 0, 0,\n\t{ 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\n    { \"Panasonic DMC-L10\", 15, 0xf96,\n\t{ 8025,-1942,-1050,-7920,15904,2100,-2456,3005,7039 } },\n    { \"Panasonic DMC-L1\", 0, 0xf7f,\n\t{ 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\n    { \"LEICA DIGILUX 3\", 0, 0xf7f,\n\t{ 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\n    { \"Panasonic DMC-LC1\", 0, 0,\n\t{ 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\n    { \"LEICA DIGILUX 2\", 0, 0,\n\t{ 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\n    { \"Panasonic DMC-LF1\", 143, 0,\n\t{ 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },\n    { \"Panasonic DMC-LX1\", 0, 0xf7f,\n\t{ 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\n    { \"LEICA D-LUX2\", 0, 0xf7f,\n\t{ 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\n    { \"Panasonic DMC-LX2\", 0, 0,\n\t{ 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\n    { \"LEICA D-LUX3\", 0, 0,\n\t{ 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\n    { \"Panasonic DMC-LX3\", 15, 0,\n\t{ 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },\n    { \"LEICA D-LUX 4\", 15, 0,\n\t{ 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },\n    { \"Panasonic DMC-LX5\", 143, 0,\n\t{ 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },\n    { \"Panasonic DMC-LX7\", 143, 0,\n\t{ 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"LEICA D-LUX 5\", 143, 0,\n\t{ 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },\n    { \"Panasonic DMC-LX7\", 143, 0,\n\t{ 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"LEICA D-LUX 6\", 143, 0,\n\t{ 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"Panasonic DMC-FZ100\", 143, 0xfff,\n\t{ 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },\n    { \"LEICA V-LUX 2\", 143, 0xfff,\n\t{ 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },\n    { \"Panasonic DMC-FZ150\", 143, 0xfff,\n\t{ 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },\n    { \"LEICA V-LUX 3\", 143, 0xfff,\n\t{ 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },\n    { \"Panasonic DMC-FZ200\", 143, 0xfff,\n\t{ 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },\n    { \"LEICA V-LUX 4\", 143, 0xfff,\n\t{ 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },\n    { \"Panasonic DMC-FX150\", 15, 0xfff,\n\t{ 9082,-2907,-925,-6119,13377,3058,-1797,2641,5609 } },\n    { \"Panasonic DMC-G10\", 0, 0,\n\t{ 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },\n    { \"Panasonic DMC-G1\", 15, 0xf94,\n\t{ 8199,-2065,-1056,-8124,16156,2033,-2458,3022,7220 } },\n    { \"Panasonic DMC-G2\", 15, 0xf3c,\n\t{ 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },\n    { \"Panasonic DMC-G3\", 143, 0xfff,\n\t{ 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },\n    { \"Panasonic DMC-G5\", 143, 0xfff,\n\t{ 7798,-2562,-740,-3879,11584,2613,-1055,2248,5434 } },\n    { \"Panasonic DMC-G6\", 143, 0xfff,\n\t{ 8294,-2891,-651,-3869,11590,2595,-1183,2267,5352 } },\n    { \"Panasonic DMC-GF1\", 15, 0xf92,\n\t{ 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },\n    { \"Panasonic DMC-GF2\", 143, 0xfff,\n\t{ 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },\n    { \"Panasonic DMC-GF3\", 143, 0xfff,\n\t{ 9051,-2468,-1204,-5212,13276,2121,-1197,2510,6890 } },\n    { \"Panasonic DMC-GF5\", 143, 0xfff,\n\t{ 8228,-2945,-660,-3938,11792,2430,-1094,2278,5793 } },\n    { \"Panasonic DMC-GF6\", 143, 0,\n\t{ 8130,-2801,-946,-3520,11289,2552,-1314,2511,5791 } },\n    { \"Panasonic DMC-GH1\", 15, 0xf92,\n\t{ 6299,-1466,-532,-6535,13852,2969,-2331,3112,5984 } },\n    { \"Panasonic DMC-GH2\", 15, 0xf95,\n\t{ 7780,-2410,-806,-3913,11724,2484,-1018,2390,5298 } },\n    { \"Panasonic DMC-GH3\", 144, 0,\n\t{ 6559,-1752,-491,-3672,11407,2586,-962,1875,5130 } },\n    { \"Panasonic DMC-GX1\", 143, 0,\n\t{ 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },\n    { \"Phase One H 20\", 0, 0,\t\t/* DJC */\n\t{ 1313,1855,-109,-6715,15908,808,-327,1840,6020 } },\n    { \"Phase One H 25\", 0, 0,\n\t{ 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One P 2\", 0, 0,\n\t{ 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One P 30\", 0, 0,\n\t{ 4516,-245,-37,-7020,14976,2173,-3206,4671,7087 } },\n    { \"Phase One P 45\", 0, 0,\n\t{ 5053,-24,-117,-5684,14076,1702,-2619,4492,5849 } },\n    { \"Phase One P40\", 0, 0,\n\t{ 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Phase One P65\", 0, 0,\n\t{ 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"RED ONE\", 704, 0xffff,\t\t/* DJC */\n\t{ 21014,-7891,-2613,-3056,12201,856,-2203,5125,8042 } },\n    { \"SAMSUNG EX1\", 0, 0x3e00,\n\t{ 8898,-2498,-994,-3144,11328,2066,-760,1381,4576 } },\n    { \"SAMSUNG EX2F\", 0, 0x7ff,\n\t{ 10648,-3897,-1055,-2022,10573,1668,-492,1611,4742 } },\n    { \"SAMSUNG NX2\", 0, 0xfff,\t/* NX20, NX200, NX210 */\n\t{ 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"SAMSUNG NX1000\", 0, 0,\n\t{ 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"SAMSUNG NX\", 0, 0,\t/* NX5, NX10, NX11, NX100 */\n\t{ 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"SAMSUNG WB2000\", 0, 0xfff,\n\t{ 12093,-3557,-1155,-1000,9534,1733,-22,1787,4576 } },\n    { \"SAMSUNG GX-1\", 0, 0,\n\t{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"SAMSUNG S85\", 0, 0xffff,\t\t/* DJC */\n\t{ 11885,-3968,-1473,-4214,12299,1916,-835,1655,5549 } },\n    { \"Sinar\", 0, 0,\t\t\t/* DJC */\n\t{ 16442,-2956,-2422,-2877,12128,750,-1136,6066,4559 } },\n    { \"SONY DSC-F828\", 0, 0,\n\t{ 7924,-1910,-777,-8226,15459,2998,-1517,2199,6818,-7242,11401,3481 } },\n    { \"SONY DSC-R1\", 512, 0,\n\t{ 8512,-2641,-694,-8042,15670,2526,-1821,2117,7414 } },\n    { \"SONY DSC-V3\", 0, 0,\n\t{ 7511,-2571,-692,-7894,15088,3060,-948,1111,8128 } },\n    { \"SONY DSC-RX100M2\", 200, 0,\n\t{ 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },\n    { \"SONY DSC-RX100\", 200, 0,\n\t{ 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },\n    { \"SONY DSC-RX1R\", 128, 0,\n\t{ 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n    { \"SONY DSC-RX1\", 128, 0,\n\t{ 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n    { \"SONY DSLR-A100\", 0, 0xfeb,\n\t{ 9437,-2811,-774,-8405,16215,2290,-710,596,7181 } },\n    { \"SONY DSLR-A290\", 0, 0,\n\t{ 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"SONY DSLR-A2\", 0, 0,\n\t{ 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\n    { \"SONY DSLR-A300\", 0, 0,\n\t{ 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\n    { \"SONY DSLR-A330\", 0, 0,\n\t{ 9847,-3091,-929,-8485,16346,2225,-714,595,7103 } },\n    { \"SONY DSLR-A350\", 0, 0xffc,\n\t{ 6038,-1484,-578,-9146,16746,2513,-875,746,7217 } },\n    { \"SONY DSLR-A380\", 0, 0,\n\t{ 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"SONY DSLR-A390\", 0, 0,\n\t{ 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"SONY DSLR-A450\", 128, 0xfeb,\n\t{ 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },\n    { \"SONY DSLR-A580\", 128, 0xfeb,\n\t{ 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },\n    { \"SONY DSLR-A5\", 128, 0xfeb,\n\t{ 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },\n    { \"SONY DSLR-A700\", 126, 0,\n\t{ 5775,-805,-359,-8574,16295,2391,-1943,2341,7249 } },\n    { \"SONY DSLR-A850\", 128, 0,\n\t{ 5413,-1162,-365,-5665,13098,2866,-608,1179,8440 } },\n    { \"SONY DSLR-A900\", 128, 0,\n\t{ 5209,-1072,-397,-8845,16120,2919,-1618,1803,8654 } },\n    { \"SONY NEX-3N\", 128, 0,\t\t/* Adobe */\n\t{ 6129,-1545,\t-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"SONY NEX-3\", 128, 0,\t\t/* Adobe */\n\t{ 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },\n    { \"SONY NEX-5N\", 128, 0,\n\t{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"SONY NEX-5R\", 128, 0,\t\t\n\t{ 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"SONY NEX-5\", 128, 0,\t\t/* Adobe */\n\t{ 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },\n    { \"SONY NEX-6\", 128, 0,\n\t{ 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"SONY NEX-7\", 128, 0,\n\t{ 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"SONY NEX\", 128, 0,\t/* NEX-C3, NEX-F3 */\n\t{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"SONY SLT-A33\", 128, 0,\n\t{ 6069,-1221,-366,-5221,12779,2734,-1024,2066,6834 } },\n    { \"SONY SLT-A35\", 128, 0,\n\t{ 5986,-1618,-415,-4557,11820,3120,-681,1404,6971 } },\n    { \"SONY SLT-A37\", 128, 0,\n\t{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"SONY SLT-A55\", 128, 0,\n\t{ 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },\n    { \"SONY SLT-A57\", 128, 0,\n\t{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"SONY SLT-A58\", 128, 0,\n\t{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"SONY SLT-A65\", 128, 0,\n\t{ 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"SONY SLT-A77\", 128, 0,\n\t{ 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"SONY SLT-A99\", 128, 0,\n\t{ 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n  };\n  double cam_xyz[4][3];\n  char name[130];\n  int i, j;\n\n  sprintf (name, \"%s %s\", t_make, t_model);\n  for (i=0; i < sizeof table / sizeof *table; i++)\n    if (!strncmp (name, table[i].prefix, strlen(table[i].prefix))) {\n      if (table[i].t_black)   black   = (ushort) table[i].t_black;\n      if (table[i].t_maximum) maximum = (ushort) table[i].t_maximum;\n      if (table[i].trans[0]) {\n\tfor (j=0; j < 12; j++)\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.color.cam_xyz[0][j] = \n#endif\n\t  cam_xyz[0][j] = table[i].trans[j] / 10000.0;\n\tcam_xyz_coeff (cam_xyz);\n      }\n      break;\n    }\n}\n\nvoid CLASS simple_coeff (int index)\n{\n  static const float table[][12] = {\n  /* index 0 -- all Foveon cameras */\n  { 1.4032,-0.2231,-0.1016,-0.5263,1.4816,0.017,-0.0112,0.0183,0.9113 },\n  /* index 1 -- Kodak DC20 and DC25 */\n  { 2.25,0.75,-1.75,-0.25,-0.25,0.75,0.75,-0.25,-0.25,-1.75,0.75,2.25 },\n  /* index 2 -- Logitech Fotoman Pixtura */\n  { 1.893,-0.418,-0.476,-0.495,1.773,-0.278,-1.017,-0.655,2.672 },\n  /* index 3 -- Nikon E880, E900, and E990 */\n  { -1.936280,  1.800443, -1.448486,  2.584324,\n     1.405365, -0.524955, -0.289090,  0.408680,\n    -1.204965,  1.082304,  2.941367, -1.818705 }\n  };\n  int i, c;\n\n  for (raw_color = i=0; i < 3; i++)\n    FORCC rgb_cam[i][c] = table[index][i*colors+c];\n}\n\nshort CLASS guess_byte_order (int words)\n{\n  uchar test[4][2];\n  int t=2, msb;\n  double diff, sum[2] = {0,0};\n\n  fread (test[0], 2, 2, ifp);\n  for (words-=2; words--; ) {\n    fread (test[t], 2, 1, ifp);\n    for (msb=0; msb < 2; msb++) {\n      diff = (test[t^2][msb] << 8 | test[t^2][!msb])\n\t   - (test[t  ][msb] << 8 | test[t  ][!msb]);\n      sum[msb] += diff*diff;\n    }\n    t = (t+1) & 3;\n  }\n  return sum[0] < sum[1] ? 0x4d4d : 0x4949;\n}\n\nfloat CLASS find_green (int bps, int bite, int off0, int off1)\n{\n  UINT64 bitbuf=0;\n  int vbits, col, i, c;\n  ushort img[2][2064];\n  double sum[]={0,0};\n\n  FORC(2) {\n    fseek (ifp, c ? off1:off0, SEEK_SET);\n    for (vbits=col=0; col < width; col++) {\n      for (vbits -= bps; vbits < 0; vbits += bite) {\n\tbitbuf <<= bite;\n\tfor (i=0; i < bite; i+=8)\n\t  bitbuf |= (unsigned) (fgetc(ifp) << i);\n      }\n      img[c][col] = bitbuf << (64-bps-vbits) >> (64-bps);\n    }\n  }\n  FORC(width-1) {\n    sum[ c & 1] += ABS(img[0][c]-img[1][c+1]);\n    sum[~c & 1] += ABS(img[1][c]-img[0][c+1]);\n  }\n  return 100 * log(sum[0]/sum[1]);\n}\n\n\n#ifndef LIBRAW_LIBRARY_BUILD\nvoid CLASS identify2(unsigned fsize, unsigned flen, char *head);\n#endif\n\n/*\n   Identify which camera created this file, and set global variables\n   accordingly.\n */\nvoid CLASS identify()\n{\n  char head[32], *cp;\n  int hlen, flen, fsize, zero_fsize=1, i, c, is_canon;\n  struct jhead jh;\n  static const struct {\n    int fsize;\n    char t_make[12], t_model[19], withjpeg;\n  } table[] = {\n    {    62464, \"Kodak\",    \"DC20\"            ,0 },\n    {   124928, \"Kodak\",    \"DC20\"            ,0 },\n    {  1652736, \"Kodak\",    \"DCS200\"          ,0 },\n    {  4159302, \"Kodak\",    \"C330\"            ,0 },\n    {  4162462, \"Kodak\",    \"C330\"            ,0 },\n    {   460800, \"Kodak\",    \"C603v\"           ,0 },\n    {   614400, \"Kodak\",    \"C603v\"           ,0 },\n    {  6163328, \"Kodak\",    \"C603\"            ,0 },\n    {  6166488, \"Kodak\",    \"C603\"            ,0 },\n    {  9116448, \"Kodak\",    \"C603y\"           ,0 },\n    {   311696, \"ST Micro\", \"STV680 VGA\"      ,0 },  /* SPYz */\n    {   787456, \"Creative\", \"PC-CAM 600\"      ,0 },\n    {  1138688, \"Minolta\",  \"RD175\"           ,0 },\n    {  3840000, \"Foculus\",  \"531C\"            ,0 },\n    {   307200, \"Generic\",  \"640x480\"         ,0 },\n    {   786432, \"AVT\",      \"F-080C\"          ,0 },\n    {  1447680, \"AVT\",      \"F-145C\"          ,0 },\n    {  1920000, \"AVT\",      \"F-201C\"          ,0 },\n    {  5067304, \"AVT\",      \"F-510C\"          ,0 },\n    {  5067316, \"AVT\",      \"F-510C\"          ,0 },\n    { 10134608, \"AVT\",      \"F-510C\"          ,0 },\n    { 10134620, \"AVT\",      \"F-510C\"          ,0 },\n    { 16157136, \"AVT\",      \"F-810C\"          ,0 },\n    {  1409024, \"Sony\",     \"XCD-SX910CR\"     ,0 },\n    {  2818048, \"Sony\",     \"XCD-SX910CR\"     ,0 },\n    {  3884928, \"Micron\",   \"2010\"            ,0 },\n    {  6624000, \"Pixelink\", \"A782\"            ,0 },\n    { 13248000, \"Pixelink\", \"A782\"            ,0 },\n    {  6291456, \"RoverShot\",\"3320AF\"          ,0 },\n    {  6553440, \"Canon\",    \"PowerShot A460\"  ,0 },\n    {  6653280, \"Canon\",    \"PowerShot A530\"  ,0 },\n    {  6573120, \"Canon\",    \"PowerShot A610\"  ,0 },\n    {  9219600, \"Canon\",    \"PowerShot A620\"  ,0 },\n    {  9243240, \"Canon\",    \"PowerShot A470\"  ,0 },\n    { 10341600, \"Canon\",    \"PowerShot A720 IS\",0 },\n    { 10383120, \"Canon\",    \"PowerShot A630\"  ,0 },\n    { 12945240, \"Canon\",    \"PowerShot A640\"  ,0 },\n    { 15636240, \"Canon\",    \"PowerShot A650\"  ,0 },\n    {  5298000, \"Canon\",    \"PowerShot SD300\" ,0 },\n    {  7710960, \"Canon\",    \"PowerShot S3 IS\" ,0 },\n    { 15467760, \"Canon\",    \"PowerShot SX110 IS\",0 },\n    { 15534576, \"Canon\",    \"PowerShot SX120 IS\",0 },\n    { 18653760, \"Canon\",    \"PowerShot SX20 IS\",0 },\n    { 19131120, \"Canon\",    \"PowerShot SX220 HS\",0 },\n    { 21936096, \"Canon\",    \"PowerShot SX30 IS\",0 },\n    {  5939200, \"OLYMPUS\",  \"C770UZ\"          ,0 },\n    {  1581060, \"NIKON\",    \"E900\"            ,1 },  /* or E900s,E910 */\n    {  2465792, \"NIKON\",    \"E950\"            ,1 },  /* or E800,E700 */\n    {  2940928, \"NIKON\",    \"E2100\"           ,1 },  /* or E2500 */\n    {  4771840, \"NIKON\",    \"E990\"            ,1 },  /* or E995, Oly C3030Z */\n    {  4775936, \"NIKON\",    \"E3700\"           ,1 },  /* or Optio 33WR */\n    {  5869568, \"NIKON\",    \"E4300\"           ,1 },  /* or DiMAGE Z2 */\n    {  5865472, \"NIKON\",    \"E4500\"           ,1 },\n    {  7438336, \"NIKON\",    \"E5000\"           ,1 },  /* or E5700 */\n    {  8998912, \"NIKON\",    \"COOLPIX S6\"      ,1 },\n    {  1976352, \"CASIO\",    \"QV-2000UX\"       ,1 },\n    {  3217760, \"CASIO\",    \"QV-3*00EX\"       ,1 },\n    {  6218368, \"CASIO\",    \"QV-5700\"         ,1 },\n    {  6054400, \"CASIO\",    \"QV-R41\"          ,1 },\n    {  7530816, \"CASIO\",    \"QV-R51\"          ,1 },\n    {  7684000, \"CASIO\",    \"QV-4000\"         ,1 },\n    {  2937856, \"CASIO\",    \"EX-S20\"          ,1 },\n    {  4948608, \"CASIO\",    \"EX-S100\"         ,1 },\n    {  7542528, \"CASIO\",    \"EX-Z50\"          ,1 },\n    {  7562048, \"CASIO\",    \"EX-Z500\"         ,1 },\n    {  7753344, \"CASIO\",    \"EX-Z55\"          ,1 },\n    {  7816704, \"CASIO\",    \"EX-Z60\"          ,1 },\n    { 10843712, \"CASIO\",    \"EX-Z75\"          ,1 },\n    { 10834368, \"CASIO\",    \"EX-Z750\"         ,1 },\n    { 12310144, \"CASIO\",    \"EX-Z850\"         ,1 },\n    { 12489984, \"CASIO\",    \"EX-Z8\"           ,1 },\n    { 15499264, \"CASIO\",    \"EX-Z1050\"        ,1 },\n    { 18702336, \"CASIO\",    \"EX-ZR100\"        ,1 },\n    {  7426656, \"CASIO\",    \"EX-P505\"         ,1 },\n    {  9313536, \"CASIO\",    \"EX-P600\"         ,1 },\n    { 10979200, \"CASIO\",    \"EX-P700\"         ,1 },\n    {  3178560, \"PENTAX\",   \"Optio S\"         ,1 },\n    {  4841984, \"PENTAX\",   \"Optio S\"         ,1 },\n    {  6114240, \"PENTAX\",   \"Optio S4\"        ,1 },  /* or S4i, CASIO EX-Z4 */\n    { 10702848, \"PENTAX\",   \"Optio 750Z\"      ,1 },\n    { 15980544, \"AGFAPHOTO\",\"DC-833m\"         ,1 },\n    { 16098048, \"SAMSUNG\",  \"S85\"             ,1 },\n    { 16215552, \"SAMSUNG\",  \"S85\"             ,1 },\n    { 20487168, \"SAMSUNG\",  \"WB550\"           ,1 },\n    { 24000000, \"SAMSUNG\",  \"WB550\"           ,1 },\n    { 9994240, \"ptGrey\", \"GRAS-50S5C\" ,0 }, // KC: SUPPORT GRASSHOPPER\n    { 10075968, \"JaiPulnix\",\"BB-500CL\" ,0 }, // KC: SUPPORT BB-500CL\n    { 10108896, \"JaiPulnix\",\"BB-500GE\" ,0 }, // KC: SUPPORT BB-500GE\n    { 10036800, \"SVS\", \"SVS625CL\" ,0 }, // KC: SUPPORT SVS625 cameralink\n    { 12582980, \"Sinar\",    \"\"                ,0 },\n    { 33292868, \"Sinar\",    \"\"                ,0 },\n    { 44390468, \"Sinar\",    \"\"                ,0 } };\n  static const char *corp[] =\n    { \"Canon\", \"NIKON\", \"EPSON\", \"KODAK\", \"Kodak\", \"OLYMPUS\", \"PENTAX\",\n      \"MINOLTA\", \"Minolta\", \"Konica\", \"CASIO\", \"Sinar\", \"Phase One\",\n      \"SAMSUNG\", \"Mamiya\", \"MOTOROLA\", \"LEICA\" };\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY,0,2);\n#endif\n\n  tiff_flip = flip = filters = -1;\t/* 0 is valid, so -1 is unknown */\n  raw_height = raw_width = fuji_width = fuji_layout = cr2_slice[0] = 0;\n  maximum = height = width = top_margin = left_margin = 0;\n  cdesc[0] = desc[0] = artist[0] = make[0] = model[0] = model2[0] = 0;\n  iso_speed = shutter = aperture = focal_len = unique_id = 0;\n  tiff_nifds = 0;\n  memset (tiff_ifd, 0, sizeof tiff_ifd);\n  memset (gpsdata, 0, sizeof gpsdata);\n  memset (cblack, 0, sizeof cblack);\n  memset (white, 0, sizeof white);\n  memset (mask, 0, sizeof mask);\n  thumb_offset = thumb_length = thumb_width = thumb_height = 0;\n  load_raw = thumb_load_raw = 0;\n  write_thumb = &CLASS jpeg_thumb;\n  data_offset = meta_length = tiff_bps = tiff_compress = 0;\n  kodak_cbpp = zero_after_ff = dng_version = load_flags = 0;\n  timestamp = shot_order = tiff_samples = black = is_foveon = 0;\n  mix_green = profile_length = data_error = zero_is_bad = 0;\n  pixel_aspect = is_raw = raw_color = 1;\n  tile_width = tile_length = 0;\n  for (i=0; i < 4; i++) {\n    cam_mul[i] = i == 1;\n    pre_mul[i] = i < 3;\n    FORC3 cmatrix[c][i] = 0;\n    FORC3 rgb_cam[c][i] = c == i;\n  }\n  colors = 3;\n  for (i=0; i < 0x10000; i++) curve[i] = i;\n\n  order = get2();\n  hlen = get4();\n  fseek (ifp, 0, SEEK_SET);\n  fread (head, 1, 32, ifp);\n  fseek (ifp, 0, SEEK_END);\n  flen = fsize = ftell(ifp);\n  if ((cp = (char *) memmem (head, 32, (char*)\"MMMM\", 4)) ||\n      (cp = (char *) memmem (head, 32, (char*)\"IIII\", 4))) {\n    parse_phase_one (cp-head);\n    if (cp-head && parse_tiff(0)) apply_tiff();\n  } else if (order == 0x4949 || order == 0x4d4d) {\n    if (!memcmp (head+6,\"HEAPCCDR\",8)) {\n      data_offset = hlen;\n      parse_ciff (hlen, flen - hlen);\n    } else if (parse_tiff(0)) apply_tiff();\n  } else if (!memcmp (head,\"\\xff\\xd8\\xff\\xe1\",4) &&\n\t     !memcmp (head+6,\"Exif\",4)) {\n    fseek (ifp, 4, SEEK_SET);\n    data_offset = 4 + get2();\n    fseek (ifp, data_offset, SEEK_SET);\n    if (fgetc(ifp) != 0xff)\n      parse_tiff(12);\n    thumb_offset = 0;\n  } else if (!memcmp (head+25,\"ARECOYK\",7)) {\n    strcpy (make, \"Contax\");\n    strcpy (model,\"N Digital\");\n    fseek (ifp, 33, SEEK_SET);\n    get_timestamp(1);\n    fseek (ifp, 60, SEEK_SET);\n    FORC4 cam_mul[c ^ (c >> 1)] = get4();\n  } else if (!strcmp (head, \"PXN\")) {\n    strcpy (make, \"Logitech\");\n    strcpy (model,\"Fotoman Pixtura\");\n  } else if (!strcmp (head, \"qktk\")) {\n    strcpy (make, \"Apple\");\n    strcpy (model,\"QuickTake 100\");\n    load_raw = &CLASS quicktake_100_load_raw;\n  } else if (!strcmp (head, \"qktn\")) {\n    strcpy (make, \"Apple\");\n    strcpy (model,\"QuickTake 150\");\n    load_raw = &CLASS kodak_radc_load_raw;\n  } else if (!memcmp (head,\"FUJIFILM\",8)) {\n    fseek (ifp, 84, SEEK_SET);\n    thumb_offset = get4();\n    thumb_length = get4();\n    fseek (ifp, 92, SEEK_SET);\n    parse_fuji (get4());\n    if (thumb_offset > 120) {\n      fseek (ifp, 120, SEEK_SET);\n      is_raw += (i = get4()) && 1;\n      if (is_raw == 2 && shot_select)\n\tparse_fuji (i);\n    }\n    load_raw = &CLASS unpacked_load_raw;\n    fseek (ifp, 100+28*(shot_select > 0), SEEK_SET);\n    parse_tiff (data_offset = get4());\n    parse_tiff (thumb_offset+12);\n    apply_tiff();\n  } else if (!memcmp (head,\"RIFF\",4)) {\n    fseek (ifp, 0, SEEK_SET);\n    parse_riff();\n  } else if (!memcmp (head,\"\\0\\001\\0\\001\\0@\",6)) {\n    fseek (ifp, 6, SEEK_SET);\n    fread (make, 1, 8, ifp);\n    fread (model, 1, 8, ifp);\n    fread (model2, 1, 16, ifp);\n    data_offset = get2();\n    get2();\n    raw_width = get2();\n    raw_height = get2();\n    load_raw = &CLASS nokia_load_raw;\n    filters = 0x61616161;\n  } else if (!memcmp (head,\"NOKIARAW\",8)) {\n    strcpy (make, \"NOKIA\");\n    strcpy (model, \"X2\");\n    order = 0x4949;\n    fseek (ifp, 300, SEEK_SET);\n    data_offset = get4();\n    i = get4();\n    width = get2();\n    height = get2();\n    data_offset += i - width * 5 / 4 * height;\n    load_raw = &CLASS nokia_load_raw;\n    filters = 0x61616161;\n  } else if (!memcmp (head,\"ARRI\",4)) {\n    order = 0x4949;\n    fseek (ifp, 20, SEEK_SET);\n    width = get4();\n    height = get4();\n    strcpy (make, \"ARRI\");\n    fseek (ifp, 668, SEEK_SET);\n    fread (model, 1, 64, ifp);\n    data_offset = 4096;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 88;\n    filters = 0x61616161;\n  } else if (!memcmp (head+4,\"RED1\",4)) {\n    strcpy (make, \"RED\");\n    strcpy (model,\"ONE\");\n    parse_redcine();\n    load_raw = &CLASS redcine_load_raw;\n    gamma_curve (1/2.4, 12.92, 1, 4095);\n    filters = 0x49494949;\n  } else if (!memcmp (head,\"DSC-Image\",9))\n    parse_rollei();\n  else if (!memcmp (head,\"PWAD\",4))\n    parse_sinar_ia();\n  else if (!memcmp (head,\"\\0MRM\",4))\n    parse_minolta(0);\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n  else if (!memcmp (head,\"FOVb\",4))\n    parse_foveon();\n#endif\n  else if (!memcmp (head,\"CI\",2))\n    parse_cine();\n  else\n    for (zero_fsize=i=0; i < sizeof table / sizeof *table; i++)\n      if (fsize == table[i].fsize) {\n\tstrcpy (make,  table[i].t_make );\n\tstrcpy (model, table[i].t_model);\n\tif (table[i].withjpeg)\n\t  parse_external_jpeg();\n      }\n  if (zero_fsize) fsize = 0;\n  if (make[0] == 0) parse_smal (0, flen);\n  if (make[0] == 0) {\n    parse_jpeg(0);\n    fseek(ifp,0,SEEK_END);\n    int sz = ftell(ifp);\n    if (!strncmp(model,\"ov\",2) && sz>=6404096 && !fseek (ifp, -6404096, SEEK_END) &&\n\tfread (head, 1, 32, ifp) && !strcmp(head,\"BRCMn\")) {\n      strcpy (make, \"OmniVision\");\n      data_offset = ftell(ifp) + 0x8000-32;\n      width = raw_width;\n      raw_width = 2611;\n      load_raw = &CLASS nokia_load_raw;\n      filters = 0x16161616;\n    } else is_raw = 0;\n  }\n\n  for (i=0; i < sizeof corp / sizeof *corp; i++)\n    if (strstr (make, corp[i]))\t\t/* Simplify company names */\n\tstrcpy (make, corp[i]);\n  if (!strncmp (make,\"KODAK\",5) &&\n\t((cp = strstr(model,\" DIGITAL CAMERA\")) ||\n\t (cp = strstr(model,\" Digital Camera\")) ||\n\t (cp = strstr(model,\"FILE VERSION\"))))\n     *cp = 0;\n  cp = make + strlen(make);\t\t/* Remove trailing spaces */\n  while (*--cp == ' ') *cp = 0;\n  cp = model + strlen(model);\n  while (*--cp == ' ') *cp = 0;\n  i = strlen(make);\t\t\t/* Remove make from model */\n  if (!strncasecmp (model, make, i) && model[i++] == ' ')\n    memmove (model, model+i, 64-i);\n  if (!strncmp (model,\"FinePix \",8))\n    strcpy (model, model+8);\n  if (!strncmp (model,\"Digital Camera \",15))\n    strcpy (model, model+15);\n  desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;\n  if (!is_raw) goto notraw;\n\n  if (!height) height = raw_height;\n  if (!width)  width  = raw_width;\n  if (height == 2624 && width == 3936)\t/* Pentax K10D and Samsung GX10 */\n    { height  = 2616;   width  = 3896; }\n  if (height == 3136 && width == 4864)  /* Pentax K20D and Samsung GX20 */\n    { height  = 3124;   width  = 4688; filters = 0x16161616; }\n  if (width == 4352 && (!strcmp(model,\"K-r\") || !strcmp(model,\"K-x\")))\n    {\t\t\twidth  = 4309; filters = 0x16161616; }\n  if (width >= 4960 && !strncmp(model,\"K-5\",3))\n    { left_margin = 10; width  = 4950; filters = 0x16161616; }\n  if (width >= 4960 && !strncmp(model,\"K-5 II\",6))\n    { left_margin = 10; width  = 4948; filters = 0x16161616; }\n  if (width == 4736 && !strcmp(model,\"K-7\"))\n    { height  = 3122;   width  = 4684; filters = 0x16161616; top_margin = 2; }\n  if (width == 7424 && !strcmp(model,\"645D\"))\n    { height  = 5502;   width  = 7328; filters = 0x61616161; top_margin = 29;\n      left_margin = 48; }\n  if (height == 3014 && width == 4096)\t/* Ricoh GX200 */\n\t\t\twidth  = 4014;\n  if (dng_version) {\n    if (filters == UINT_MAX) filters = 0;\n    if (filters) is_raw = tiff_samples;\n    else\t colors = tiff_samples;\n    if (tiff_compress == 1)\n      load_raw = &CLASS packed_dng_load_raw;\n    if (tiff_compress == 7)\n      load_raw = &CLASS lossless_dng_load_raw;\n    goto dng_skip;\n  }\n  if ((is_canon = !strcmp(make,\"Canon\")))\n    load_raw = memcmp (head+6,\"HEAPCCDR\",8) ?\n\t&CLASS lossless_jpeg_load_raw : &CLASS canon_load_raw;\n  if (!strcmp(make,\"NIKON\")) {\n    if (!load_raw)\n      load_raw = &CLASS packed_load_raw;\n    if (model[0] == 'E')\n      load_flags |= !data_offset << 2 | 2;\n  }\n  if (!strcmp(make,\"CASIO\")) {\n    load_raw = &CLASS packed_load_raw;\n    maximum = 0xf7f;\n  }\n\n/* Set parameters based on camera name (for non-DNG files). */\n\n  if (is_foveon) {\n    if (height*2 < width) pixel_aspect = 0.5;\n    if (height   > width) pixel_aspect = 2;\n    filters = 0;\n    simple_coeff(0);\n  } else if (is_canon && tiff_bps == 15) {\n    switch (width) {\n      case 3344: width -= 66;\n      case 3872: width -= 6;\n    }\n    if (height > width) SWAP(height,width);\n    filters = 0;\n    load_raw = &CLASS canon_sraw_load_raw;\n  } else if (!strcmp(model,\"PowerShot 600\")) {\n    height = 613;\n    width  = 854;\n    raw_width = 896;\n    pixel_aspect = 607/628.0;\n    colors = 4;\n    filters = 0xe1e4e1e4;\n    load_raw = &CLASS canon_600_load_raw;\n  } else if (!strcmp(model,\"PowerShot A5\") ||\n\t     !strcmp(model,\"PowerShot A5 Zoom\")) {\n    height = 773;\n    width  = 960;\n    raw_width = 992;\n    pixel_aspect = 256/235.0;\n    colors = 4;\n    filters = 0x1e4e1e4e;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A50\")) {\n    height =  968;\n    width  = 1290;\n    raw_width = 1320;\n    colors = 4;\n    filters = 0x1b4e4b1e;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot Pro70\")) {\n    height = 1024;\n    width  = 1552;\n    colors = 4;\n    filters = 0x1e4b4e1b;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot SD300\")) {\n    height = 1752;\n    width  = 2344;\n    raw_height = 1766;\n    raw_width  = 2400;\n    top_margin  = 12;\n    left_margin = 12;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A460\")) {\n    height = 1960;\n    width  = 2616;\n    raw_height = 1968;\n    raw_width  = 2664;\n    top_margin  = 4;\n    left_margin = 4;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A530\")) {\n    height = 1984;\n    width  = 2620;\n    raw_height = 1992;\n    raw_width  = 2672;\n    top_margin  = 6;\n    left_margin = 10;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A610\")) {\n    if (canon_s2is()) strcpy (model+10, \"S2 IS\");\n    height = 1960;\n    width  = 2616;\n    raw_height = 1968;\n    raw_width  = 2672;\n    top_margin  = 8;\n    left_margin = 12;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A620\")) {\n    height = 2328;\n    width  = 3112;\n    raw_height = 2340;\n    raw_width  = 3152;\n    top_margin  = 12;\n    left_margin = 36;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A470\")) {\n    height = 2328;\n    width  = 3096;\n    raw_height = 2346;\n    raw_width  = 3152;\n    top_margin  = 6;\n    left_margin = 12;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A720 IS\")) {\n    height = 2472;\n    width  = 3298;\n    raw_height = 2480;\n    raw_width  = 3336;\n    top_margin  = 5;\n    left_margin = 6;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A630\")) {\n    height = 2472;\n    width  = 3288;\n    raw_height = 2484;\n    raw_width  = 3344;\n    top_margin  = 6;\n    left_margin = 12;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A640\")) {\n    height = 2760;\n    width  = 3672;\n    raw_height = 2772;\n    raw_width  = 3736;\n    top_margin  = 6;\n    left_margin = 12;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A650\")) {\n    height = 3024;\n    width  = 4032;\n    raw_height = 3048;\n    raw_width  = 4104;\n    top_margin  = 12;\n    left_margin = 48;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot S3 IS\")) {\n    height = 2128;\n    width  = 2840;\n    raw_height = 2136;\n    raw_width  = 2888;\n    top_margin  = 8;\n    left_margin = 44;\ncanon_a5:\n    tiff_bps = 10;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 40;\n    if (raw_width > 1600) zero_is_bad = 1;\n  } else if (!strcmp(model,\"PowerShot SX110 IS\")) {\n    height = 2760;\n    width  = 3684;\n    raw_height = 2772;\n    raw_width  = 3720;\n    top_margin  = 12;\n    left_margin = 6;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 40;\n    zero_is_bad = 1;\n  } else if (!strcmp(model,\"PowerShot SX120 IS\")) {\n    height = 2742;\n    width  = 3664;\n    raw_height = 2778;\n    raw_width  = 3728;\n    top_margin  = 18;\n    left_margin = 16;\n    filters = 0x49494949;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 40;\n    zero_is_bad = 1;\n  } else if (!strcmp(model,\"PowerShot SX20 IS\")) {\n    height = 3024;\n    width  = 4032;\n    raw_height = 3048;\n    raw_width  = 4080;\n    top_margin  = 12;\n    left_margin = 24;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 40;\n    zero_is_bad = 1;\n  } else if (!strcmp(model,\"PowerShot SX220 HS\")) {\n    height = 3043;\n    width  = 4072;\n    raw_height = 3060;\n    raw_width  = 4168;\n    mask[0][0] = top_margin = 16;\n    mask[0][2] = top_margin + height;\n    mask[0][3] = left_margin = 92;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 8;\n    zero_is_bad = 1;\n  } else if (!strcmp(model,\"PowerShot SX50 HS\")) {\n    top_margin=16;\n    left_margin=94;\n    height = 3043;\n    width  = 4072;\n  } else if (!strcmp(model,\"PowerShot SX30 IS\")) {\n    height = 3254;\n    width  = 4366;\n    raw_height = 3276;\n    raw_width  = 4464;\n    top_margin  = 10;\n    left_margin = 25;\n    filters = 0x16161616;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 40;\n    zero_is_bad = 1;\n  } else if (!strcmp(model,\"PowerShot Pro90 IS\")) {\n    width  = 1896;\n    colors = 4;\n    filters = 0xb4b4b4b4;\n  } else if (is_canon && raw_width == 2144) {\n    height = 1550;\n    width  = 2088;\n    top_margin  = 8;\n    left_margin = 4;\n    if (!strcmp(model,\"PowerShot G1\")) {\n      colors = 4;\n      filters = 0xb4b4b4b4;\n    }\n  } else if (is_canon && raw_width == 2224) {\n    height = 1448;\n    width  = 2176;\n    top_margin  = 6;\n    left_margin = 48;\n  } else if (is_canon && raw_width == 2376) {\n    height = 1720;\n    width  = 2312;\n    top_margin  = 6;\n    left_margin = 12;\n  } else if (is_canon && raw_width == 2672) {\n    height = 1960;\n    width  = 2616;\n    top_margin  = 6;\n    left_margin = 12;\n  } else if (is_canon && raw_width == 3152) {\n    height = 2056;\n    width  = 3088;\n    top_margin  = 12;\n    left_margin = 64;\n    if (unique_id == 0x80000170)\n      adobe_coeff (\"Canon\",\"EOS 300D\");\n  } else if (is_canon && raw_width == 3160) {\n    height = 2328;\n    width  = 3112;\n    top_margin  = 12;\n    left_margin = 44;\n  } else if (is_canon && raw_width == 3344) {\n    height = 2472;\n    width  = 3288;\n    top_margin  = 6;\n    left_margin = 4;\n  } else if (!strcmp(model,\"EOS D2000C\")) {\n    filters = 0x61616161;\n    black = curve[200];\n  } else if (is_canon && raw_width == 3516) {\n    top_margin  = 14;\n    left_margin = 42;\n    if (unique_id == 0x80000189)\n      adobe_coeff (\"Canon\",\"EOS 350D\");\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 3596) {\n    top_margin  = 12;\n    left_margin = 74;\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 3744) {\n    height = 2760;\n    width  = 3684;\n    top_margin  = 16;\n    left_margin = 8;\n    if (unique_id > 0x2720000) {\n      top_margin  = 12;\n      left_margin = 52;\n    }\n  } else if (is_canon && raw_width == 3944) {\n    height = 2602;\n    width  = 3908;\n    top_margin  = 18;\n    left_margin = 30;\n  } else if (is_canon && raw_width == 3948) {\n    top_margin  = 18;\n    left_margin = 42;\n    height -= 2;\n    if (unique_id == 0x80000236)\n      adobe_coeff (\"Canon\",\"EOS 400D\");\n    if (unique_id == 0x80000254)\n      adobe_coeff (\"Canon\",\"EOS 1000D\");\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 3984) {\n    top_margin  = 20;\n    left_margin = 76;\n    height -= 2;\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 4104) {\n    height = 3024;\n    width  = 4032;\n    top_margin  = 12;\n    left_margin = 48;\n  } else if (is_canon && raw_width == 4152) {\n    top_margin  = 12;\n    left_margin = 192;\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 4160) {\n    height = 3048;\n    width  = 4048;\n    top_margin  = 11;\n    left_margin = 104;\n  } else if (is_canon && raw_width == 4176) {\n    height = 3045;\n    width  = 4072;\n    left_margin = 96;\n    mask[0][0] = top_margin = 17;\n    mask[0][2] = raw_height;\n    mask[0][3] = 80;\n    filters = 0x49494949;\n  } else if (is_canon && raw_width == 4312) {\n    top_margin  = 18;\n    left_margin = 22;\n    height -= 2;\n    if (unique_id == 0x80000176)\n      adobe_coeff (\"Canon\",\"EOS 450D\");\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 4352) {\n    top_margin  = 18;\n    left_margin = 62;\n    if (unique_id == 0x80000288)\n      adobe_coeff (\"Canon\",\"EOS 1100D\");\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 4476) {\n    top_margin  = 34;\n    left_margin = 90;\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 4480) {\n    height = 3326;\n    width  = 4432;\n    top_margin  = 10;\n    left_margin = 12;\n    filters = 0x49494949;\n  } else if (is_canon && raw_width == 4496) {\n    height = 3316;\n    width  = 4404;\n    top_margin  = 50;\n    left_margin = 80;\n  } else if (is_canon && raw_width == 4832) {\n    top_margin = unique_id == 0x80000261 ? 51:26;\n    left_margin = 62;\n    if (unique_id == 0x80000252)\n      adobe_coeff (\"Canon\",\"EOS 500D\");\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 5108) {\n    top_margin  = 13;\n    left_margin = 98;\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 5120) {\n    height -= top_margin = 45;\n    left_margin = 142;\n    width = 4916;\n  } else if (is_canon && raw_width == 5280) {\n    top_margin  = 52;\n    left_margin = 72;\n    if (unique_id == 0x80000301)\n      adobe_coeff (\"Canon\",\"EOS 650D\");\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 5344) {\n    top_margin = 51;\n    left_margin = 142;\n    if (unique_id == 0x80000269) {\n      top_margin = 100;\n      left_margin = 126;\n      height -= 2;\n      adobe_coeff (\"Canon\",\"EOS-1D X\");\n    }\n    if (unique_id == 0x80000270)\n      adobe_coeff (\"Canon\",\"EOS 550D\");\n    if (unique_id == 0x80000286)\n      adobe_coeff (\"Canon\",\"EOS 600D\");\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 5360) {\n    top_margin = 51;\n    left_margin = 158;\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 5568) {\n    top_margin = 38;\n    left_margin = 72;\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 5712) {\n    height = 3752;\n    width  = 5640;\n    top_margin  = 20;\n    left_margin = 62;\n  } else if (is_canon && raw_width == 5792) {\n    top_margin  = 51;\n    left_margin = 158;\ncanon_cr2:\n    height -= top_margin;\n    width  -= left_margin;\n  } else if (is_canon && raw_width == 5920) {\n    height = 3870;\n    width  = 5796;\n    top_margin  = 80;\n    left_margin = 122;\n  } else if (!strcmp(model,\"D1\")) {\n    cam_mul[0] *= 256/527.0;\n    cam_mul[2] *= 256/317.0;\n  } else if (!strcmp(model,\"D1X\")) {\n    width -= 4;\n    pixel_aspect = 0.5;\n  } else if (!strcmp(model,\"D40X\") ||\n\t     !strcmp(model,\"D60\")  ||\n\t     !strcmp(model,\"D80\")  ||\n\t     !strcmp(model,\"D3000\")) {\n    height -= 3;\n    width  -= 4;\n  } else if (!strcmp(model,\"D3\")   ||\n\t     !strcmp(model,\"D3S\")  ||\n\t     !strcmp(model,\"D700\")) {\n    width -= 4;\n    left_margin = 2;\n  } else if (!strcmp(model,\"D3100\")) {\n    width -= 28;\n    left_margin = 6;\n  } else if (!strcmp(model,\"D5000\") ||\n\t     !strcmp(model,\"D90\")) {\n    width -= 42;\n  } else if (!strcmp(model,\"D5100\") ||\n\t     !strcmp(model,\"D7000\")) {\n    width -= 44;\n  } else if (!strcmp(model,\"D3200\") ||\n\t     !strcmp(model,\"D800E\") ||\n\t     !strcmp(model,\"D600\")  ||\n\t     !strcmp(model,\"D800\")) {\n    width -= 46;\n  } else if (!strcmp(model,\"D4\")) {\n    width -= 52;\n    left_margin = 2;\n  } else if (!strcmp(model,\"D600\")) {\n    width -= 48;\n  } else if (!strncmp(model,\"D40\",3) ||\n\t     !strncmp(model,\"D50\",3) ||\n\t     !strncmp(model,\"D70\",3)) {\n    width--;\n  } else if (!strcmp(model,\"D100\")) {\n    if (load_flags)\n      raw_width = (width += 3) + 3;\n  } else if (!strcmp(model,\"D200\")) {\n    left_margin = 1;\n    width -= 4;\n    filters = 0x94949494;\n  } else if (!strncmp(model,\"D2H\",3)) {\n    left_margin = 6;\n    width -= 14;\n  } else if (!strncmp(model,\"D2X\",3)) {\n    if (width == 3264) width -= 32;\n    else width -= 8;\n  } else if (!strncmp(model,\"D300\",4)) {\n    width -= 32;\n  } else if (!strcmp(make,\"NIKON\") && raw_width == 4032) {\n    adobe_coeff (\"NIKON\",\"COOLPIX P7700\");\n  } else if (!strncmp(model,\"COOLPIX P\",9)) {\n    load_flags = 24;\n    filters = 0x94949494;\n    if (model[9] == '7' && iso_speed >= 400)\n      black = 255;\n  } else if (!strncmp(model,\"COOLPIX A\",9) && raw_width == 4992) {\n\t  width = 4948;\n  } else if (!strncmp(model,\"1 \",2)) {\n    height -= 2;\n  } else if (fsize == 1581060) {\n    height = 963;\n    width = 1287;\n    raw_width = 1632;\n    maximum = 0x3f4;\n    colors = 4;\n    filters = 0x1e1e1e1e;\n    simple_coeff(3);\n    pre_mul[0] = 1.2085;\n    pre_mul[1] = 1.0943;\n    pre_mul[3] = 1.1103;\n    goto e900;\n  } else if (fsize == 2465792) {\n    height = 1203;\n    width  = 1616;\n    raw_width = 2048;\n    colors = 4;\n    filters = 0x4b4b4b4b;\n    adobe_coeff (\"NIKON\",\"E950\");\ne900:\n    tiff_bps = 10;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 6;\n  } else if (fsize == 4771840) {\n    height = 1540;\n    width  = 2064;\n    colors = 4;\n    filters = 0xe1e1e1e1;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 6;\n    if (!timestamp && nikon_e995())\n      strcpy (model, \"E995\");\n    if (strcmp(model,\"E995\")) {\n      filters = 0xb4b4b4b4;\n      simple_coeff(3);\n      pre_mul[0] = 1.196;\n      pre_mul[1] = 1.246;\n      pre_mul[2] = 1.018;\n    }\n  } else if (!strcmp(model,\"E2100\")) {\n    if (!timestamp && !nikon_e2100()) goto cp_e2500;\n    height = 1206;\n    width  = 1616;\n    load_flags = 30;\n  } else if (!strcmp(model,\"E2500\")) {\ncp_e2500:\n    strcpy (model, \"E2500\");\n    height = 1204;\n    width  = 1616;\n    colors = 4;\n    filters = 0x4b4b4b4b;\n  } else if (fsize == 4775936) {\n    height = 1542;\n    width  = 2064;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 30;\n    if (!timestamp) nikon_3700();\n    if (model[0] == 'E' && atoi(model+1) < 3700)\n      filters = 0x49494949;\n    if (!strcmp(model,\"Optio 33WR\")) {\n      flip = 1;\n      filters = 0x16161616;\n    }\n    if (make[0] == 'O') {\n      i = find_green (12, 32, 1188864, 3576832);\n      c = find_green (12, 32, 2383920, 2387016);\n      if (abs(i) < abs(c)) {\n\tSWAP(i,c);\n\tload_flags = 24;\n      }\n      if (i < 0) filters = 0x61616161;\n    }\n  } else if (fsize == 5869568) {\n    height = 1710;\n    width  = 2288;\n    filters = 0x16161616;\n    if (!timestamp && minolta_z2()) {\n      strcpy (make, \"Minolta\");\n      strcpy (model,\"DiMAGE Z2\");\n    }\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 6 + 24*(make[0] == 'M');\n  } else if (!strcmp(model,\"E4500\")) {\n    height = 1708;\n    width  = 2288;\n    colors = 4;\n    filters = 0xb4b4b4b4;\n  } else if (fsize == 7438336) {\n    height = 1924;\n    width  = 2576;\n    colors = 4;\n    filters = 0xb4b4b4b4;\n  } else if (fsize == 8998912) {\n    height = 2118;\n    width  = 2832;\n    maximum = 0xf83;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 30;\n  } else if (!strcmp(make,\"FUJIFILM\")) {\n    if (!strcmp(model+7,\"S2Pro\")) {\n      strcpy (model,\"S2Pro\");\n      height = 2144;\n      width  = 2880;\n      flip = 6;\n    } else if (load_raw != &CLASS packed_load_raw)\n      maximum = (is_raw == 2 && shot_select) ? 0x2f00 : 0x3e00;\n    top_margin = (raw_height - height) >> 2 << 1;\n    left_margin = (raw_width - width ) >> 2 << 1;\n    if (width == 2848) filters = 0x16161616;\n    if (width == 3328) {\n      width = 3262;\n      left_margin = 34;\n    }\n    if (width == 4952) {\n      left_margin = 0;\n      filters = 2;\n    }\n\tif(!strcmp(model,\"HS50EXR\"))\n\t{\n\t\tfilters = 0x1e1e1e1e;\n\t\twidth=3230;\n\t}\n\tif(!strcmp(model,\"X20\"))\n\t{\n\t\tleft_margin = 2;\n\t\ttop_margin=2;\n\t\twidth = 4030;\n\t\theight = 3010;\n\t\traw_height = 3012;\n\t\tfilters = 2;\n\t}\n\tif(!strcmp(model,\"X100S\"))\n\t{\n\t\tleft_margin = 2;\n\t\ttop_margin = 1;\n\t\twidth = 4934;\n\t\theight = 3290;\n\t\traw_height = 3295;\n\t\tfilters = 2;\n\t\tdata_offset +=8;\n\t\tload_raw = &CLASS unpacked_load_raw;\n\t\tload_flags = 0;\n\t\tmaximum = 16383;\n\t}\n    if (fuji_layout) raw_width *= is_raw;\n  } else if (!strcmp(model,\"RD175\")) {\n    height = 986;\n    width = 1534;\n    data_offset = 513;\n    filters = 0x61616161;\n    load_raw = &CLASS minolta_rd175_load_raw;\n  } else if (!strcmp(model,\"KD-400Z\")) {\n    height = 1712;\n    width  = 2312;\n    raw_width = 2336;\n    goto konica_400z;\n  } else if (!strcmp(model,\"KD-510Z\")) {\n    goto konica_510z;\n  } else if (!strcasecmp(make,\"MINOLTA\")) {\n    load_raw = &CLASS unpacked_load_raw;\n    maximum = 0xfff;\n    if (!strncmp(model,\"DiMAGE A\",8)) {\n      if (!strcmp(model,\"DiMAGE A200\"))\n\tfilters = 0x49494949;\n      tiff_bps = 12;\n      load_raw = &CLASS packed_load_raw;\n    } else if (!strncmp(model,\"ALPHA\",5) ||\n\t       !strncmp(model,\"DYNAX\",5) ||\n\t       !strncmp(model,\"MAXXUM\",6)) {\n      sprintf (model+20, \"DYNAX %-10s\", model+6+(model[0]=='M'));\n      adobe_coeff (make, model+20);\n      load_raw = &CLASS packed_load_raw;\n    } else if (!strncmp(model,\"DiMAGE G\",8)) {\n      if (model[8] == '4') {\n\theight = 1716;\n\twidth  = 2304;\n      } else if (model[8] == '5') {\nkonica_510z:\n\theight = 1956;\n\twidth  = 2607;\n\traw_width = 2624;\n      } else if (model[8] == '6') {\n\theight = 2136;\n\twidth  = 2848;\n      }\n      data_offset += 14;\n      filters = 0x61616161;\nkonica_400z:\n      load_raw = &CLASS unpacked_load_raw;\n      maximum = 0x3df;\n      order = 0x4d4d;\n    }\n  } else if (!strcmp(model,\"*ist D\")) {\n    load_raw = &CLASS unpacked_load_raw;\n    data_error = -1;\n  } else if (!strcmp(model,\"*ist DS\")) {\n    height -= 2;\n  } else if (!strcmp(model,\"Optio S\")) {\n    if (fsize == 3178560) {\n      height = 1540;\n      width  = 2064;\n      load_raw = &CLASS eight_bit_load_raw;\n      cam_mul[0] *= 4;\n      cam_mul[2] *= 4;\n    } else {\n      height = 1544;\n      width  = 2068;\n      raw_width = 3136;\n      load_raw = &CLASS packed_load_raw;\n      maximum = 0xf7c;\n    }\n  } else if (fsize == 6114240) {\n    height = 1737;\n    width  = 2324;\n    raw_width = 3520;\n    load_raw = &CLASS packed_load_raw;\n    maximum = 0xf7a;\n  } else if (!strcmp(model,\"Optio 750Z\")) {\n    height = 2302;\n    width  = 3072;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 30;\n  } else if (!strcmp(model,\"DC-833m\")) {\n    height = 2448;\n    width  = 3264;\n    order = 0x4949;\n    filters = 0x61616161;\n    load_raw = &CLASS unpacked_load_raw;\n    maximum = 0xfc00;\n  } else if (!strncmp(model,\"S85\",3)) {\n    height = 2448;\n    width  = 3264;\n    raw_width = fsize/height/2;\n    order = 0x4d4d;\n    load_raw = &CLASS unpacked_load_raw;\n  } else if (!strcmp(make,\"SAMSUNG\") && raw_width == 4704) {\n    height -= top_margin = 8;\n    width -= 2 * (left_margin = 8);\n    load_flags = 32;\n  } else if (!strcmp(make,\"SAMSUNG\") && raw_width == 5632) {\n    order = 0x4949;\n    height = 3694;\n    top_margin = 2;\n    width  = 5574 - (left_margin = 32 + tiff_bps);\n    if (tiff_bps == 12) load_flags = 80;\n  } else if (!strcmp(make,\"SAMSUNG\") && !strcmp(model,\"NX300\")) {\n\t  is_raw =0;\n  } else if (!strcmp(model,\"EX1\")) {\n    order = 0x4949;\n    height -= 20;\n    top_margin = 2;\n    if ((width -= 6) > 3682) {\n      height -= 10;\n      width  -= 46;\n      top_margin = 8;\n    }\n  } else if (!strcmp(model,\"WB2000\")) {\n    order = 0x4949;\n    height -= 3;\n    top_margin = 2;\n    if ((width -= 10) > 3718) {\n      height -= 28;\n      width  -= 56;\n      top_margin = 8;\n    }\n  } else if (fsize == 20487168) {\n    height = 2808;\n    width  = 3648;\n    goto wb550;\n  } else if (fsize == 24000000) {\n    height = 3000;\n    width  = 4000;\nwb550:\n    strcpy (model, \"WB550\");\n    order = 0x4d4d;\n    load_raw = &CLASS unpacked_load_raw;\n    load_flags = 6;\n    maximum = 0x3df;\n  } else if (!strcmp(model,\"EX2F\")) {\n    height = 3045;\n    width  = 4070;\n    top_margin = 3;\n    order = 0x4949;\n    filters = 0x49494949;\n    load_raw = &CLASS unpacked_load_raw;\n  } else if (!strcmp(model,\"STV680 VGA\")) {\n    height = 484;\n    width  = 644;\n    load_raw = &CLASS eight_bit_load_raw;\n    flip = 2;\n    filters = 0x16161616;\n    black = 16;\n  }  else\n      identify2(fsize,flen,head); /* Avoid MS VS 2008/2010 bug */\n\n  if (!model[0])\n    sprintf (model, \"%dx%d\", width, height);\n  if (filters == UINT_MAX) filters = 0x94949494;\n  if (raw_color) adobe_coeff (make, model);\n  if (load_raw == &CLASS kodak_radc_load_raw)\n    if (raw_color) adobe_coeff (\"Apple\",\"Quicktake\");\n  if (thumb_offset && !thumb_height) {\n    fseek (ifp, thumb_offset, SEEK_SET);\n    if (ljpeg_start (&jh, 1)) {\n      thumb_width  = jh.wide;\n      thumb_height = jh.high;\n    }\n  }\ndng_skip:\n  if (fuji_width) {\n    fuji_width = width >> !fuji_layout;\n    if (~fuji_width & 1) filters = 0x49494949;\n    width = (height >> fuji_layout) + fuji_width;\n    height = width - 1;\n    pixel_aspect = 1;\n  } else {\n    if (raw_height < height) raw_height = height;\n    if (raw_width  < width ) raw_width  = width;\n  }\n  if (!tiff_bps) tiff_bps = 12;\n  if (!maximum) maximum = (1 << tiff_bps) - 1;\n  if (!load_raw || height < 22) is_raw = 0;\n#ifdef NO_JASPER\n  if (load_raw == &CLASS redcine_load_raw) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s: You must link dcraw with %s!!\\n\"),\n\tifname, \"libjasper\");\n#endif\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_JASPER;\n#endif\n  }\n#endif\n#ifdef NO_JPEG\n  if (load_raw == &CLASS kodak_jpeg_load_raw ||\n      load_raw == &CLASS lossy_dng_load_raw) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s: You must link dcraw with %s!!\\n\"),\n\tifname, \"libjpeg\");\n#endif\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_JPEGLIB;\n#endif\n  }\n#endif\n  if (!cdesc[0])\n    strcpy (cdesc, colors == 3 ? \"RGBG\":\"GMCY\");\n  if (!raw_height) raw_height = height;\n  if (!raw_width ) raw_width  = width;\n  if (filters && colors == 3)\n    filters |= ((filters >> 2 & 0x22222222) |\n\t\t(filters << 2 & 0x88888888)) & filters << 1;\nnotraw:\n  if (flip == -1) flip = tiff_flip;\n  if (flip == -1) flip = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY,1,2);\n#endif\n}\n\nvoid CLASS identify2(unsigned fsize, unsigned flen, char *head)\n{\n  short pana[][6] = {\n    { 3130, 1743,  4,  0, -6,  0 },\n    { 3130, 2055,  4,  0, -6,  0 },\n    { 3130, 2319,  4,  0, -6,  0 },\n    { 3170, 2103, 18,  0,-42, 20 },\n    { 3170, 2367, 18, 13,-42,-21 },\n    { 3177, 2367,  0,  0, -1,  0 },\n    { 3304, 2458,  0,  0, -1,  0 },\n    { 3330, 2463,  9,  0, -5,  0 },\n    { 3330, 2479,  9,  0,-17,  4 },\n    { 3370, 1899, 15,  0,-44, 20 },\n    { 3370, 2235, 15,  0,-44, 20 },\n    { 3370, 2511, 15, 10,-44,-21 },\n    { 3690, 2751,  3,  0, -8, -3 },\n    { 3710, 2751,  0,  0, -3,  0 },\n    { 3724, 2450,  0,  0,  0, -2 },\n    { 3770, 2487, 17,  0,-44, 19 },\n    { 3770, 2799, 17, 15,-44,-19 },\n    { 3880, 2170,  6,  0, -6,  0 },\n    { 4060, 3018,  0,  0,  0, -2 },\n    { 4290, 2391,  3,  0, -8, -1 },\n    { 4330, 2439, 17, 15,-44,-19 },\n    { 4508, 2962,  0,  0, -3, -4 },\n    { 4508, 3330,  0,  0, -3, -6 } };\n\n\n  struct jhead jh;\n  int i;\n if (!strcmp(model,\"N95\")) {\n    height = raw_height - (top_margin = 2);\n  } else if (!strcmp(model,\"531C\")) {\n    height = 1200;\n    width  = 1600;\n    load_raw = &CLASS unpacked_load_raw;\n    filters = 0x49494949;\n  } else if (!strcmp(model,\"640x480\")) {\n    height = 480;\n    width  = 640;\n    load_raw = &CLASS eight_bit_load_raw;\n    gamma_curve (0.45, 4.5, 1, 255);\n  } else if (!strcmp(model,\"F-080C\")) {\n    height = 768;\n    width  = 1024;\n    load_raw = &CLASS eight_bit_load_raw;\n  } else if (!strcmp(model,\"F-145C\")) {\n    height = 1040;\n    width  = 1392;\n    load_raw = &CLASS eight_bit_load_raw;\n  } else if (!strcmp(model,\"F-201C\")) {\n    height = 1200;\n    width  = 1600;\n    load_raw = &CLASS eight_bit_load_raw;\n  } else if (!strcmp(model,\"F-510C\")) {\n    height = 1958;\n    width  = 2588;\n    load_raw = fsize < 7500000 ?\n\t&CLASS eight_bit_load_raw : &CLASS unpacked_load_raw;\n    data_offset = fsize - width*height*(fsize >> 22);\n    maximum = 0xfff0;\n  } else if (!strcmp(model,\"F-810C\")) {\n    height = 2469;\n    width  = 3272;\n    load_raw = &CLASS unpacked_load_raw;\n    maximum = 0xfff0;\n  } else if (!strcmp(model,\"XCD-SX910CR\")) {\n    height = 1024;\n    width  = 1375;\n    raw_width = 1376;\n    filters = 0x49494949;\n    maximum = 0x3ff;\n    load_raw = fsize < 2000000 ?\n\t&CLASS eight_bit_load_raw : &CLASS unpacked_load_raw;\n  } else if (!strcmp(model,\"2010\")) {\n    height = 1207;\n    width  = 1608;\n    order = 0x4949;\n    filters = 0x16161616;\n    data_offset = 3212;\n    maximum = 0x3ff;\n    load_raw = &CLASS unpacked_load_raw;\n  } else if (!strcmp(model,\"A782\")) {\n    height = 3000;\n    width  = 2208;\n    filters = 0x61616161;\n    load_raw = fsize < 10000000 ?\n\t&CLASS eight_bit_load_raw : &CLASS unpacked_load_raw;\n    maximum = 0xffc0;\n  } else if (!strcmp(model,\"3320AF\")) {\n    height = 1536;\n    raw_width = width = 2048;\n    filters = 0x61616161;\n    load_raw = &CLASS unpacked_load_raw;\n    maximum = 0x3ff;\n    fseek (ifp, 0x300000, SEEK_SET);\n    if ((order = guess_byte_order(0x10000)) == 0x4d4d) {\n      height -= (top_margin = 16);\n      width -= (left_margin = 28);\n      maximum = 0xf5c0;\n      strcpy (make, \"ISG\");\n      model[0] = 0;\n    }\n  } else if (!strcmp(make,\"Hasselblad\")) {\n    if (load_raw == &CLASS lossless_jpeg_load_raw)\n      load_raw = &CLASS hasselblad_load_raw;\n    if (raw_width == 7262) {\n      height = 5444;\n      width  = 7248;\n      top_margin  = 4;\n      left_margin = 7;\n      filters = 0x61616161;\n    } else if (raw_width == 7410) {\n      height = 5502;\n      width  = 7328;\n      top_margin  = 4;\n      left_margin = 41;\n      filters = 0x61616161;\n    } else if (raw_width == 9044) {\n      height = 6716;\n      width  = 8964;\n      top_margin  = 8;\n      left_margin = 40;\n      black += load_flags = 256;\n      maximum = 0x8101;\n    } else if (raw_width == 4090) {\n      strcpy (model, \"V96C\");\n      height -= (top_margin = 6);\n      width -= (left_margin = 3) + 7;\n      filters = 0x61616161;\n    }\n  } else if (!strcmp(make,\"Sinar\")) {\n    if (!memcmp(head,\"8BPS\",4)) {\n      fseek (ifp, 14, SEEK_SET);\n      height = get4();\n      width  = get4();\n      filters = 0x61616161;\n      data_offset = 68;\n    }\n    if (!load_raw) load_raw = &CLASS unpacked_load_raw;\n    maximum = 0x3fff;\n  } else if (!strcmp(make,\"Leaf\")) {\n    maximum = 0x3fff;\n    fseek (ifp, data_offset, SEEK_SET);\n    if (ljpeg_start (&jh, 1) && jh.bits == 15)\n      maximum = 0x1fff;\n    if (tiff_samples > 1) filters = 0;\n    if (tiff_samples > 1 || tile_length < raw_height) {\n      load_raw = &CLASS leaf_hdr_load_raw;\n      raw_width = tile_width;\n    }\n    if ((width | height) == 2048) {\n      if (tiff_samples == 1) {\n\tfilters = 1;\n\tstrcpy (cdesc, \"RBTG\");\n\tstrcpy (model, \"CatchLight\");\n\ttop_margin =  8; left_margin = 18; height = 2032; width = 2016;\n      } else {\n\tstrcpy (model, \"DCB2\");\n\ttop_margin = 10; left_margin = 16; height = 2028; width = 2022;\n      }\n    } else if (width+height == 3144+2060) {\n      if (!model[0]) strcpy (model, \"Cantare\");\n      if (width > height) {\n\t top_margin = 6; left_margin = 32; height = 2048;  width = 3072;\n\tfilters = 0x61616161;\n      } else {\n\tleft_margin = 6;  top_margin = 32;  width = 2048; height = 3072;\n\tfilters = 0x16161616;\n      }\n      if (!cam_mul[0] || model[0] == 'V') filters = 0;\n      else is_raw = tiff_samples;\n    } else if (width == 2116) {\n      strcpy (model, \"Valeo 6\");\n      height -= 2 * (top_margin = 30);\n      width -= 2 * (left_margin = 55);\n      filters = 0x49494949;\n    } else if (width == 3171) {\n      strcpy (model, \"Valeo 6\");\n      height -= 2 * (top_margin = 24);\n      width -= 2 * (left_margin = 24);\n      filters = 0x16161616;\n    }\n  } else if (!strcmp(make,\"LEICA\") || !strcmp(make,\"Panasonic\")) {\n    if ((flen - data_offset) / (raw_width*8/7) == raw_height)\n      load_raw = &CLASS panasonic_load_raw;\n    if (!load_raw) {\n      load_raw = &CLASS unpacked_load_raw;\n      load_flags = 4;\n    }\n    zero_is_bad = 1;\n    if ((height += 12) > raw_height) height = raw_height;\n    for (i=0; i < sizeof pana / sizeof *pana; i++)\n      if (raw_width == pana[i][0] && raw_height == pana[i][1]) {\n\tleft_margin = pana[i][2];\n\t top_margin = pana[i][3];\n\t     width += pana[i][4];\n\t    height += pana[i][5];\n      }\n    filters = 0x01010101 * (uchar) \"\\x94\\x61\\x49\\x16\"\n\t[((filters-1) ^ (left_margin & 1) ^ (top_margin << 1)) & 3];\n  } else if (!strcmp(model,\"C770UZ\")) {\n    height = 1718;\n    width  = 2304;\n    filters = 0x16161616;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 30;\n  } else if (!strcmp(make,\"OLYMPUS\")) {\n    height += height & 1;\n    filters = exif_cfa;\n    if (width == 4100) width -= 4;\n    if (width == 4080) width -= 24;\n    if (load_raw == &CLASS unpacked_load_raw)\n      load_flags = 4;\n    tiff_bps = 12;\n    if (!strcmp(model,\"E-300\") ||\n\t!strcmp(model,\"E-500\")) {\n      width -= 20;\n      if (load_raw == &CLASS unpacked_load_raw) {\n\tmaximum = 0xfc3;\n\tmemset (cblack, 0, sizeof cblack);\n      }\n    } else if (!strcmp(model,\"E-330\")) {\n      width -= 30;\n      if (load_raw == &CLASS unpacked_load_raw)\n\tmaximum = 0xf79;\n    } else if (!strcmp(model,\"SP550UZ\")) {\n      thumb_length = flen - (thumb_offset = 0xa39800);\n      thumb_height = 480;\n      thumb_width  = 640;\n    } else if (!strcmp(model,\"XZ-2\")) {\n      load_raw = &CLASS packed_load_raw;\n      load_flags = 24;\n    } else if (!strcmp(model,\"XZ-10\")) {\n      load_raw = &CLASS packed_load_raw;\n      load_flags = 24;\n    }\n  } else if (!strcmp(model,\"N Digital\")) {\n    height = 2047;\n    width  = 3072;\n    filters = 0x61616161;\n    data_offset = 0x1a00;\n    load_raw = &CLASS packed_load_raw;\n  } else if (!strcmp(model,\"DSC-F828\")) {\n    width = 3288;\n    left_margin = 5;\n    mask[1][3] = -17;\n    data_offset = 862144;\n    load_raw = &CLASS sony_load_raw;\n    filters = 0x9c9c9c9c;\n    colors = 4;\n    strcpy (cdesc, \"RGBE\");\n  } else if (!strcmp(model,\"DSC-V3\")) {\n    width = 3109;\n    left_margin = 59;\n    mask[0][1] = 9;\n    data_offset = 787392;\n    load_raw = &CLASS sony_load_raw;\n  } else if (!strcmp(make,\"SONY\") && raw_width == 3984) {\n    adobe_coeff (\"SONY\",\"DSC-R1\");\n    width = 3925;\n    order = 0x4d4d;\n  } else if (!strcmp(make,\"SONY\") && raw_width == 5504) {\n    width -= 8;\n  } else if (!strcmp(make,\"SONY\") && raw_width == 6048) {\n    width -= 24;\n  } else if (!strcmp(model,\"DSLR-A100\")) {\n    if (width == 3880) {\n      height--;\n      width = ++raw_width;\n    } else {\n      order = 0x4d4d;\n      load_flags = 2;\n    }\n    filters = 0x61616161;\n  } else if (!strcmp(model,\"DSLR-A350\")) {\n    height -= 4;\n  } else if (!strcmp(model,\"PIXL\")) {\n    height -= top_margin = 4;\n    width -= left_margin = 32;\n    gamma_curve (0, 7, 1, 255);\n  } else if (!strcmp(model,\"C603v\")) {\n    height = 480;\n    width  = 640;\n    if (fsize < 614400 || find_green (16, 16, 3840, 5120) < 25) goto c603v;\n    strcpy (model,\"KAI-0340\");\n    height -= 3;\n    data_offset = 3840;\n    order = 0x4949;\n    load_raw = &CLASS unpacked_load_raw;\n  } else if (!strcmp(model,\"C603y\")) {\n    height = 2134;\n    width  = 2848;\nc603v:\n    filters = 0;\n    load_raw = &CLASS kodak_yrgb_load_raw;\n    gamma_curve (0, 3.875, 1, 255);\n  } else if (!strcmp(model,\"C603\")) {\n    raw_height = height = 2152;\n    raw_width  = width  = 2864;\n    goto c603;\n  } else if (!strcmp(model,\"C330\")) {\n    height = 1744;\n    width  = 2336;\n    raw_height = 1779;\n    raw_width  = 2338;\n    top_margin = 33;\n    left_margin = 1;\nc603:\n    order = 0x4949;\n    if ((data_offset = fsize - raw_height*raw_width)) {\n      fseek (ifp, 168, SEEK_SET);\n      read_shorts (curve, 256);\n    } else gamma_curve (0, 3.875, 1, 255);\n    load_raw = &CLASS eight_bit_load_raw;\n  } else if (!strncasecmp(model,\"EasyShare\",9)) {\n    data_offset = data_offset < 0x15000 ? 0x15000 : 0x17000;\n    load_raw = &CLASS packed_load_raw;\n  } else if (!strcasecmp(make,\"KODAK\")) {\n    if (filters == UINT_MAX) filters = 0x61616161;\n    if (!strncmp(model,\"NC2000\",6)) {\n      width -= 4;\n      left_margin = 2;\n    } else if (!strcmp(model,\"EOSDCS3B\")) {\n      width -= 4;\n      left_margin = 2;\n    } else if (!strcmp(model,\"EOSDCS1\")) {\n      width -= 4;\n      left_margin = 2;\n    } else if (!strcmp(model,\"DCS420\")) {\n      width -= 4;\n      left_margin = 2;\n    } else if (!strncmp(model,\"DCS460 \",7)) {\n      model[6] = 0;\n      width -= 4;\n      left_margin = 2;\n    } else if (!strcmp(model,\"DCS460A\")) {\n      width -= 4;\n      left_margin = 2;\n      colors = 1;\n      filters = 0;\n    } else if (!strcmp(model,\"DCS660M\")) {\n      black = 214;\n      colors = 1;\n      filters = 0;\n    } else if (!strcmp(model,\"DCS760M\")) {\n      colors = 1;\n      filters = 0;\n    }\n    if (!strcmp(model+4,\"20X\"))\n      strcpy (cdesc, \"MYCY\");\n    if (strstr(model,\"DC25\")) {\n      strcpy (model, \"DC25\");\n      data_offset = 15424;\n    }\n    if (!strncmp(model,\"DC2\",3)) {\n      raw_height = height = 242;\n      if (flen < 100000) {\n\traw_width = 256; width = 249;\n\tpixel_aspect = (4.0*height) / (3.0*width);\n      } else {\n\traw_width = 512; width = 501;\n\tpixel_aspect = (493.0*height) / (373.0*width);\n      }\n      data_offset += raw_width + 1;\n      colors = 4;\n      filters = 0x8d8d8d8d;\n      simple_coeff(1);\n      pre_mul[1] = 1.179;\n      pre_mul[2] = 1.209;\n      pre_mul[3] = 1.036;\n      load_raw = &CLASS eight_bit_load_raw;\n    } else if (!strcmp(model,\"40\")) {\n      strcpy (model, \"DC40\");\n      height = 512;\n      width  = 768;\n      data_offset = 1152;\n      load_raw = &CLASS kodak_radc_load_raw;\n    } else if (strstr(model,\"DC50\")) {\n      strcpy (model, \"DC50\");\n      height = 512;\n      width  = 768;\n      data_offset = 19712;\n      load_raw = &CLASS kodak_radc_load_raw;\n    } else if (strstr(model,\"DC120\")) {\n      strcpy (model, \"DC120\");\n      height = 976;\n      width  = 848;\n      pixel_aspect = height/0.75/width;\n      load_raw = tiff_compress == 7 ?\n\t&CLASS kodak_jpeg_load_raw : &CLASS kodak_dc120_load_raw;\n    } else if (!strcmp(model,\"DCS200\")) {\n      thumb_height = 128;\n      thumb_width  = 192;\n      thumb_offset = 6144;\n      thumb_misc   = 360;\n      write_thumb = &CLASS layer_thumb;\n      height = 1024;\n      width  = 1536;\n      data_offset = 79872;\n      load_raw = &CLASS eight_bit_load_raw;\n      black = 17;\n    }\n  } else if (!strcmp(model,\"Fotoman Pixtura\")) {\n    height = 512;\n    width  = 768;\n    data_offset = 3632;\n    load_raw = &CLASS kodak_radc_load_raw;\n    filters = 0x61616161;\n    simple_coeff(2);\n  } else if (!strncmp(model,\"QuickTake\",9)) {\n    if (head[5]) strcpy (model+10, \"200\");\n    fseek (ifp, 544, SEEK_SET);\n    height = get2();\n    width  = get2();\n    data_offset = (get4(),get2()) == 30 ? 738:736;\n    if (height > width) {\n      SWAP(height,width);\n      fseek (ifp, data_offset-6, SEEK_SET);\n      flip = ~get2() & 3 ? 5:6;\n    }\n    filters = 0x61616161;\n  } else if (!strcmp(make,\"Rollei\") && !load_raw) {\n    switch (raw_width) {\n      case 1316:\n\theight = 1030;\n\twidth  = 1300;\n\ttop_margin  = 1;\n\tleft_margin = 6;\n\tbreak;\n      case 2568:\n\theight = 1960;\n\twidth  = 2560;\n\ttop_margin  = 2;\n\tleft_margin = 8;\n    }\n    filters = 0x16161616;\n    load_raw = &CLASS rollei_load_raw;\n  } else if (!strcmp(model,\"PC-CAM 600\")) {\n    height = 768;\n    data_offset = width = 1024;\n    filters = 0x49494949;\n    load_raw = &CLASS eight_bit_load_raw;\n  } else if (!strcmp(model,\"QV-2000UX\")) {\n    height = 1208;\n    width  = 1632;\n    data_offset = width * 2;\n    load_raw = &CLASS eight_bit_load_raw;\n  } else if (fsize == 3217760) {\n    height = 1546;\n    width  = 2070;\n    raw_width = 2080;\n    load_raw = &CLASS eight_bit_load_raw;\n  } else if (!strcmp(model,\"QV-4000\")) {\n    height = 1700;\n    width  = 2260;\n    load_raw = &CLASS unpacked_load_raw;\n    maximum = 0xffff;\n  } else if (!strcmp(model,\"QV-5700\")) {\n    height = 1924;\n    width  = 2576;\n    raw_width = 3232;\n    tiff_bps = 10;\n  } else if (!strcmp(model,\"QV-R41\")) {\n    height = 1720;\n    width  = 2312;\n    raw_width = 3520;\n    left_margin = 2;\n  } else if (!strcmp(model,\"QV-R51\")) {\n    height = 1926;\n    width  = 2580;\n    raw_width = 3904;\n  } else if (!strcmp(model,\"EX-S20\")) {\n    height = 1208;\n    width  = 1620;\n    raw_width = 2432;\n    flip = 3;\n  } else if (!strcmp(model,\"EX-S100\")) {\n    height = 1544;\n    width  = 2058;\n    raw_width = 3136;\n  } else if (!strcmp(model,\"EX-Z50\")) {\n    height = 1931;\n    width  = 2570;\n    raw_width = 3904;\n  } else if (!strcmp(model,\"EX-Z500\")) {\n    height = 1937;\n    width  = 2577;\n    raw_width = 3904;\n    filters = 0x16161616;\n  } else if (!strcmp(model,\"EX-Z55\")) {\n    height = 1960;\n    width  = 2570;\n    raw_width = 3904;\n  } else if (!strcmp(model,\"EX-Z60\")) {\n    height = 2145;\n    width  = 2833;\n    raw_width = 3584;\n    filters = 0x16161616;\n    tiff_bps = 10;\n  } else if (!strcmp(model,\"EX-Z75\")) {\n    height = 2321;\n    width  = 3089;\n    raw_width = 4672;\n    maximum = 0xfff;\n  } else if (!strcmp(model,\"EX-Z750\")) {\n    height = 2319;\n    width  = 3087;\n    raw_width = 4672;\n    maximum = 0xfff;\n  } else if (!strcmp(model,\"EX-Z850\")) {\n    height = 2468;\n    width  = 3279;\n    raw_width = 4928;\n    maximum = 0xfff;\n  } else if (!strcmp(model,\"EX-Z8\")) {\n    height = 2467;\n    width  = 3281;\n    raw_height = 2502;\n    raw_width  = 4992;\n    maximum = 0xfff;\n  } else if (fsize == 15499264) {\t/* EX-Z1050 or EX-Z1080 */\n    height = 2752;\n    width  = 3672;\n    raw_width = 5632;\n  } else if (!strcmp(model,\"EX-ZR100\")) {\n    height = 3044;\n    width  = 4072;\n    raw_width = 4096;\n    load_flags = 80;\n  } else if (!strcmp(model,\"EX-P505\")) {\n    height = 1928;\n    width  = 2568;\n    raw_width = 3852;\n    maximum = 0xfff;\n  } else if (fsize == 9313536) {\t/* EX-P600 or QV-R61 */\n    height = 2142;\n    width  = 2844;\n    raw_width = 4288;\n  } else if (!strcmp(model,\"EX-P700\")) {\n    height = 2318;\n    width  = 3082;\n    raw_width = 4672;\n  }\n  else if (!strcmp(model,\"GRAS-50S5C\")) {\n   height = 2048;\n   width = 2440;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x49494949;\n   order = 0x4949;\n   maximum = 0xfffC;\n  } else if (!strcmp(model,\"BB-500CL\")) {\n   height = 2058;\n   width = 2448;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x94949494;\n   order = 0x4949;\n   maximum = 0x3fff;\n  } else if (!strcmp(model,\"BB-500GE\")) {\n   height = 2058;\n   width = 2456;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x94949494;\n   order = 0x4949;\n   maximum = 0x3fff;\n  } else if (!strcmp(model,\"SVS625CL\")) {\n   height = 2050;\n   width = 2448;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x94949494;\n   order = 0x4949;\n   maximum = 0x0fff;\n  }\n}\n\n\n//@end COMMON\n\n//@out FILEIO\n#ifndef NO_LCMS\nvoid CLASS apply_profile (const char *input, const char *output)\n{\n  char *prof;\n  cmsHPROFILE hInProfile=0, hOutProfile=0;\n  cmsHTRANSFORM hTransform;\n  FILE *fp;\n  unsigned size;\n\n#ifndef USE_LCMS2\n  cmsErrorAction (LCMS_ERROR_SHOW);\n#endif\n  if (strcmp (input, \"embed\"))\n    hInProfile = cmsOpenProfileFromFile (input, \"r\");\n  else if (profile_length) {\n#ifndef LIBRAW_LIBRARY_BUILD\n    prof = (char *) malloc (profile_length);\n    merror (prof, \"apply_profile()\");\n    fseek (ifp, profile_offset, SEEK_SET);\n    fread (prof, 1, profile_length, ifp);\n    hInProfile = cmsOpenProfileFromMem (prof, profile_length);\n    free (prof);\n#else\n    hInProfile = cmsOpenProfileFromMem (imgdata.color.profile, profile_length);\n#endif\n  } else\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_EMBEDDED_PROFILE;\n#endif\n#ifdef DCRAW_VERBOSE\n          fprintf (stderr,_(\"%s has no embedded profile.\\n\"), ifname);\n#endif\n    }\n  if (!hInProfile)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_INPUT_PROFILE;\n#endif\n          return;\n      }\n  if (!output)\n    hOutProfile = cmsCreate_sRGBProfile();\n  else if ((fp = fopen (output, \"rb\"))) {\n    fread (&size, 4, 1, fp);\n    fseek (fp, 0, SEEK_SET);\n    oprof = (unsigned *) malloc (size = ntohl(size));\n    merror (oprof, \"apply_profile()\");\n    fread (oprof, 1, size, fp);\n    fclose (fp);\n    if (!(hOutProfile = cmsOpenProfileFromMem (oprof, size))) {\n      free (oprof);\n      oprof = 0;\n    }\n  }\n#ifdef DCRAW_VERBOSE\n else\n    fprintf (stderr,_(\"Cannot open file %s!\\n\"), output);\n#endif\n  if (!hOutProfile)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_BAD_OUTPUT_PROFILE;\n#endif\n          goto quit;\n      }\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf (stderr,_(\"Applying color profile...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_APPLY_PROFILE,0,2);\n#endif\n  hTransform = cmsCreateTransform (hInProfile, TYPE_RGBA_16,\n\thOutProfile, TYPE_RGBA_16, INTENT_PERCEPTUAL, 0);\n  cmsDoTransform (hTransform, image, image, width*height);\n  raw_color = 1;\t\t/* Don't use rgb_cam with a profile */\n  cmsDeleteTransform (hTransform);\n  cmsCloseProfile (hOutProfile);\nquit:\n  cmsCloseProfile (hInProfile);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_APPLY_PROFILE,1,2);\n#endif\n}\n#endif\n//@end FILEIO\n\n//@out COMMON\nvoid CLASS convert_to_rgb()\n{\n#ifndef LIBRAW_LIBRARY_BUILD\n  int row, col, c;\n#endif\n  int  i, j, k;\n#ifndef LIBRAW_LIBRARY_BUILD\n  ushort *img;\n  float out[3];\n#endif\n  float out_cam[3][4];\n  double num, inverse[3][3];\n  static const double xyzd50_srgb[3][3] =\n  { { 0.436083, 0.385083, 0.143055 },\n    { 0.222507, 0.716888, 0.060608 },\n    { 0.013930, 0.097097, 0.714022 } };\n  static const double rgb_rgb[3][3] =\n  { { 1,0,0 }, { 0,1,0 }, { 0,0,1 } };\n  static const double adobe_rgb[3][3] =\n  { { 0.715146, 0.284856, 0.000000 },\n    { 0.000000, 1.000000, 0.000000 },\n    { 0.000000, 0.041166, 0.958839 } };\n  static const double wide_rgb[3][3] =\n  { { 0.593087, 0.404710, 0.002206 },\n    { 0.095413, 0.843149, 0.061439 },\n    { 0.011621, 0.069091, 0.919288 } };\n  static const double prophoto_rgb[3][3] =\n  { { 0.529317, 0.330092, 0.140588 },\n    { 0.098368, 0.873465, 0.028169 },\n    { 0.016879, 0.117663, 0.865457 } };\n  static const double (*out_rgb[])[3] =\n  { rgb_rgb, adobe_rgb, wide_rgb, prophoto_rgb, xyz_rgb };\n  static const char *name[] =\n  { \"sRGB\", \"Adobe RGB (1998)\", \"WideGamut D65\", \"ProPhoto D65\", \"XYZ\" };\n  static const unsigned phead[] =\n  { 1024, 0, 0x2100000, 0x6d6e7472, 0x52474220, 0x58595a20, 0, 0, 0,\n    0x61637370, 0, 0, 0x6e6f6e65, 0, 0, 0, 0, 0xf6d6, 0x10000, 0xd32d };\n  unsigned pbody[] =\n  { 10, 0x63707274, 0, 36,\t/* cprt */\n\t0x64657363, 0, 40,\t/* desc */\n\t0x77747074, 0, 20,\t/* wtpt */\n\t0x626b7074, 0, 20,\t/* bkpt */\n\t0x72545243, 0, 14,\t/* rTRC */\n\t0x67545243, 0, 14,\t/* gTRC */\n\t0x62545243, 0, 14,\t/* bTRC */\n\t0x7258595a, 0, 20,\t/* rXYZ */\n\t0x6758595a, 0, 20,\t/* gXYZ */\n\t0x6258595a, 0, 20 };\t/* bXYZ */\n  static const unsigned pwhite[] = { 0xf351, 0x10000, 0x116cc };\n  unsigned pcurve[] = { 0x63757276, 0, 1, 0x1000000 };\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB,0,2);\n#endif\n  gamma_curve (gamm[0], gamm[1], 0, 0);\n  memcpy (out_cam, rgb_cam, sizeof out_cam);\n#ifndef LIBRAW_LIBRARY_BUILD\n  raw_color |= colors == 1 || document_mode ||\n\t\toutput_color < 1 || output_color > 5;\n#else\n  raw_color |= colors == 1 || \n\t\toutput_color < 1 || output_color > 5;\n#endif\n  if (!raw_color) {\n    oprof = (unsigned *) calloc (phead[0], 1);\n    merror (oprof, \"convert_to_rgb()\");\n    memcpy (oprof, phead, sizeof phead);\n    if (output_color == 5) oprof[4] = oprof[5];\n    oprof[0] = 132 + 12*pbody[0];\n    for (i=0; i < pbody[0]; i++) {\n      oprof[oprof[0]/4] = i ? (i > 1 ? 0x58595a20 : 0x64657363) : 0x74657874;\n      pbody[i*3+2] = oprof[0];\n      oprof[0] += (pbody[i*3+3] + 3) & -4;\n    }\n    memcpy (oprof+32, pbody, sizeof pbody);\n    oprof[pbody[5]/4+2] = strlen(name[output_color-1]) + 1;\n    memcpy ((char *)oprof+pbody[8]+8, pwhite, sizeof pwhite);\n    pcurve[3] = (short)(256/gamm[5]+0.5) << 16;\n    for (i=4; i < 7; i++)\n      memcpy ((char *)oprof+pbody[i*3+2], pcurve, sizeof pcurve);\n    pseudoinverse ((double (*)[3]) out_rgb[output_color-1], inverse, 3);\n    for (i=0; i < 3; i++)\n      for (j=0; j < 3; j++) {\n\tfor (num = k=0; k < 3; k++)\n\t  num += xyzd50_srgb[i][k] * inverse[j][k];\n\toprof[pbody[j*3+23]/4+i+2] = num * 0x10000 + 0.5;\n      }\n    for (i=0; i < phead[0]/4; i++)\n      oprof[i] = htonl(oprof[i]);\n    strcpy ((char *)oprof+pbody[2]+8, \"auto-generated by dcraw\");\n    strcpy ((char *)oprof+pbody[5]+12, name[output_color-1]);\n    for (i=0; i < 3; i++)\n      for (j=0; j < colors; j++)\n\tfor (out_cam[i][j] = k=0; k < 3; k++)\n\t  out_cam[i][j] += out_rgb[output_color-1][i][k] * rgb_cam[k][j];\n  }\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf (stderr, raw_color ? _(\"Building histograms...\\n\") :\n\t_(\"Converting to %s colorspace...\\n\"), name[output_color-1]);\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  convert_to_rgb_loop(out_cam);\n#else\n  memset (histogram, 0, sizeof histogram);\n  for (img=image[0], row=0; row < height; row++)\n    for (col=0; col < width; col++, img+=4) {\n      if (!raw_color) {\n\tout[0] = out[1] = out[2] = 0;\n\tFORCC {\n\t  out[0] += out_cam[0][c] * img[c];\n\t  out[1] += out_cam[1][c] * img[c];\n\t  out[2] += out_cam[2][c] * img[c];\n\t}\n\tFORC3 img[c] = CLIP((int) out[c]);\n      }\n      else if (document_mode)\n\timg[0] = img[fcol(row,col)];\n      FORCC histogram[c][img[c] >> 3]++;\n    }\n#endif\n  if (colors == 4 && output_color) colors = 3;\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (document_mode && filters) colors = 1;\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB,1,2);\n#endif\n}\n\nvoid CLASS fuji_rotate()\n{\n  int i, row, col;\n  double step;\n  float r, c, fr, fc;\n  unsigned ur, uc;\n  ushort wide, high, (*img)[4], (*pix)[4];\n\n  if (!fuji_width) return;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf (stderr,_(\"Rotating image 45 degrees...\\n\"));\n#endif\n  fuji_width = (fuji_width - 1 + shrink) >> shrink;\n  step = sqrt(0.5);\n  wide = fuji_width / step;\n  high = (height - fuji_width) / step;\n  img = (ushort (*)[4]) calloc (wide*high, sizeof *img);\n  merror (img, \"fuji_rotate()\");\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE,0,2);\n#endif\n\n  for (row=0; row < high; row++)\n    for (col=0; col < wide; col++) {\n      ur = r = fuji_width + (row-col)*step;\n      uc = c = (row+col)*step;\n      if (ur > height-2 || uc > width-2) continue;\n      fr = r - ur;\n      fc = c - uc;\n      pix = image + ur*width + uc;\n      for (i=0; i < colors; i++)\n\timg[row*wide+col][i] =\n\t  (pix[    0][i]*(1-fc) + pix[      1][i]*fc) * (1-fr) +\n\t  (pix[width][i]*(1-fc) + pix[width+1][i]*fc) * fr;\n    }\n\n  free (image);\n  width  = wide;\n  height = high;\n  image  = img;\n  fuji_width = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE,1,2);\n#endif\n}\n\nvoid CLASS stretch()\n{\n  ushort newdim, (*img)[4], *pix0, *pix1;\n  int row, col, c;\n  double rc, frac;\n\n  if (pixel_aspect == 1) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH,0,2);\n#endif\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Stretching the image...\\n\"));\n#endif\n  if (pixel_aspect < 1) {\n    newdim = height / pixel_aspect + 0.5;\n    img = (ushort (*)[4]) calloc (width*newdim, sizeof *img);\n    merror (img, \"stretch()\");\n    for (rc=row=0; row < newdim; row++, rc+=pixel_aspect) {\n      frac = rc - (c = rc);\n      pix0 = pix1 = image[c*width];\n      if (c+1 < height) pix1 += width*4;\n      for (col=0; col < width; col++, pix0+=4, pix1+=4)\n\tFORCC img[row*width+col][c] = pix0[c]*(1-frac) + pix1[c]*frac + 0.5;\n    }\n    height = newdim;\n  } else {\n    newdim = width * pixel_aspect + 0.5;\n    img = (ushort (*)[4]) calloc (height*newdim, sizeof *img);\n    merror (img, \"stretch()\");\n    for (rc=col=0; col < newdim; col++, rc+=1/pixel_aspect) {\n      frac = rc - (c = rc);\n      pix0 = pix1 = image[c];\n      if (c+1 < width) pix1 += 4;\n      for (row=0; row < height; row++, pix0+=width*4, pix1+=width*4)\n\tFORCC img[row*newdim+col][c] = pix0[c]*(1-frac) + pix1[c]*frac + 0.5;\n    }\n    width = newdim;\n  }\n  free (image);\n  image = img;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH,1,2);\n#endif\n}\n\nint CLASS flip_index (int row, int col)\n{\n  if (flip & 4) SWAP(row,col);\n  if (flip & 2) row = iheight - 1 - row;\n  if (flip & 1) col = iwidth  - 1 - col;\n  return row * iwidth + col;\n}\n//@end COMMON\n\n\nstruct tiff_tag {\n  ushort tag, type;\n  int count;\n  union { char c[4]; short s[2]; int i; } val;\n};\n\nstruct tiff_hdr {\n  ushort t_order, magic;\n  int ifd;\n  ushort pad, ntag;\n  struct tiff_tag tag[23];\n  int nextifd;\n  ushort pad2, nexif;\n  struct tiff_tag exif[4];\n  ushort pad3, ngps;\n  struct tiff_tag gpst[10];\n  short bps[4];\n  int rat[10];\n  unsigned gps[26];\n  char t_desc[512], t_make[64], t_model[64], soft[32], date[20], t_artist[64];\n};\n\n//@out COMMON\nvoid CLASS tiff_set (ushort *ntag,\n\tushort tag, ushort type, int count, int val)\n{\n  struct tiff_tag *tt;\n  int c;\n\n  tt = (struct tiff_tag *)(ntag+1) + (*ntag)++;\n  tt->tag = tag;\n  tt->type = type;\n  tt->count = count;\n  if (type < 3 && count <= 4)\n    FORC(4) tt->val.c[c] = val >> (c << 3);\n  else if (type == 3 && count <= 2)\n    FORC(2) tt->val.s[c] = val >> (c << 4);\n  else tt->val.i = val;\n}\n\n#define TOFF(ptr) ((char *)(&(ptr)) - (char *)th)\n\nvoid CLASS tiff_head (struct tiff_hdr *th, int full)\n{\n  int c, psize=0;\n  struct tm *t;\n\n  memset (th, 0, sizeof *th);\n  th->t_order = htonl(0x4d4d4949) >> 16;\n  th->magic = 42;\n  th->ifd = 10;\n  if (full) {\n    tiff_set (&th->ntag, 254, 4, 1, 0);\n    tiff_set (&th->ntag, 256, 4, 1, width);\n    tiff_set (&th->ntag, 257, 4, 1, height);\n    tiff_set (&th->ntag, 258, 3, colors, output_bps);\n    if (colors > 2)\n      th->tag[th->ntag-1].val.i = TOFF(th->bps);\n    FORC4 th->bps[c] = output_bps;\n    tiff_set (&th->ntag, 259, 3, 1, 1);\n    tiff_set (&th->ntag, 262, 3, 1, 1 + (colors > 1));\n  }\n  tiff_set (&th->ntag, 270, 2, 512, TOFF(th->t_desc));\n  tiff_set (&th->ntag, 271, 2, 64, TOFF(th->t_make));\n  tiff_set (&th->ntag, 272, 2, 64, TOFF(th->t_model));\n  if (full) {\n    if (oprof) psize = ntohl(oprof[0]);\n    tiff_set (&th->ntag, 273, 4, 1, sizeof *th + psize);\n    tiff_set (&th->ntag, 277, 3, 1, colors);\n    tiff_set (&th->ntag, 278, 4, 1, height);\n    tiff_set (&th->ntag, 279, 4, 1, height*width*colors*output_bps/8);\n  } else\n    tiff_set (&th->ntag, 274, 3, 1, \"12435867\"[flip]-'0');\n  tiff_set (&th->ntag, 282, 5, 1, TOFF(th->rat[0]));\n  tiff_set (&th->ntag, 283, 5, 1, TOFF(th->rat[2]));\n  tiff_set (&th->ntag, 284, 3, 1, 1);\n  tiff_set (&th->ntag, 296, 3, 1, 2);\n  tiff_set (&th->ntag, 305, 2, 32, TOFF(th->soft));\n  tiff_set (&th->ntag, 306, 2, 20, TOFF(th->date));\n  tiff_set (&th->ntag, 315, 2, 64, TOFF(th->t_artist));\n  tiff_set (&th->ntag, 34665, 4, 1, TOFF(th->nexif));\n  if (psize) tiff_set (&th->ntag, 34675, 7, psize, sizeof *th);\n  tiff_set (&th->nexif, 33434, 5, 1, TOFF(th->rat[4]));\n  tiff_set (&th->nexif, 33437, 5, 1, TOFF(th->rat[6]));\n  tiff_set (&th->nexif, 34855, 3, 1, iso_speed);\n  tiff_set (&th->nexif, 37386, 5, 1, TOFF(th->rat[8]));\n  if (gpsdata[1]) {\n    tiff_set (&th->ntag, 34853, 4, 1, TOFF(th->ngps));\n    tiff_set (&th->ngps,  0, 1,  4, 0x202);\n    tiff_set (&th->ngps,  1, 2,  2, gpsdata[29]);\n    tiff_set (&th->ngps,  2, 5,  3, TOFF(th->gps[0]));\n    tiff_set (&th->ngps,  3, 2,  2, gpsdata[30]);\n    tiff_set (&th->ngps,  4, 5,  3, TOFF(th->gps[6]));\n    tiff_set (&th->ngps,  5, 1,  1, gpsdata[31]);\n    tiff_set (&th->ngps,  6, 5,  1, TOFF(th->gps[18]));\n    tiff_set (&th->ngps,  7, 5,  3, TOFF(th->gps[12]));\n    tiff_set (&th->ngps, 18, 2, 12, TOFF(th->gps[20]));\n    tiff_set (&th->ngps, 29, 2, 12, TOFF(th->gps[23]));\n    memcpy (th->gps, gpsdata, sizeof th->gps);\n  }\n  th->rat[0] = th->rat[2] = 300;\n  th->rat[1] = th->rat[3] = 1;\n  FORC(6) th->rat[4+c] = 1000000;\n  th->rat[4] *= shutter;\n  th->rat[6] *= aperture;\n  th->rat[8] *= focal_len;\n  strncpy (th->t_desc, desc, 512);\n  strncpy (th->t_make, make, 64);\n  strncpy (th->t_model, model, 64);\n  strcpy (th->soft, \"dcraw v\"DCRAW_VERSION);\n  t = localtime (&timestamp);\n  sprintf (th->date, \"%04d:%02d:%02d %02d:%02d:%02d\",\n      t->tm_year+1900,t->tm_mon+1,t->tm_mday,t->tm_hour,t->tm_min,t->tm_sec);\n  strncpy (th->t_artist, artist, 64);\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\nvoid CLASS jpeg_thumb_writer (FILE *tfp,char *t_humb,int t_humb_length)\n{\n  ushort exif[5];\n  struct tiff_hdr th;\n  fputc (0xff, tfp);\n  fputc (0xd8, tfp);\n  if (strcmp (t_humb+6, \"Exif\")) {\n    memcpy (exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n    exif[1] = htons (8 + sizeof th);\n    fwrite (exif, 1, sizeof exif, tfp);\n    tiff_head (&th, 0);\n    fwrite (&th, 1, sizeof th, tfp);\n  }\n  fwrite (t_humb+2, 1, t_humb_length-2, tfp);\n}\n\nvoid CLASS jpeg_thumb()\n{\n  char *thumb;\n\n  thumb = (char *) malloc (thumb_length);\n  merror (thumb, \"jpeg_thumb()\");\n  fread (thumb, 1, thumb_length, ifp);\n  jpeg_thumb_writer(ofp,thumb,thumb_length);\n  free (thumb);\n}\n#else\nvoid CLASS jpeg_thumb()\n{\n  char *thumb;\n  ushort exif[5];\n  struct tiff_hdr th;\n\n  thumb = (char *) malloc (thumb_length);\n  merror (thumb, \"jpeg_thumb()\");\n  fread (thumb, 1, thumb_length, ifp);\n  fputc (0xff, ofp);\n  fputc (0xd8, ofp);\n  if (strcmp (thumb+6, \"Exif\")) {\n    memcpy (exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n    exif[1] = htons (8 + sizeof th);\n    fwrite (exif, 1, sizeof exif, ofp);\n    tiff_head (&th, 0);\n    fwrite (&th, 1, sizeof th, ofp);\n  }\n  fwrite (thumb+2, 1, thumb_length-2, ofp);\n  free (thumb);\n}\n#endif\n\nvoid CLASS write_ppm_tiff()\n{\n  struct tiff_hdr th;\n  uchar *ppm;\n  ushort *ppm2;\n  int c, row, col, soff, rstep, cstep;\n  int perc, val, total, t_white=0x2000;\n\n  perc = width * height * 0.01;\t\t/* 99th percentile white level */\n  if (fuji_width) perc /= 2;\n  if (!((highlight & ~2) || no_auto_bright))\n    for (t_white=c=0; c < colors; c++) {\n      for (val=0x2000, total=0; --val > 32; )\n\tif ((total += histogram[c][val]) > perc) break;\n      if (t_white < val) t_white = val;\n    }\n  gamma_curve (gamm[0], gamm[1], 2, (t_white << 3)/bright);\n  iheight = height;\n  iwidth  = width;\n  if (flip & 4) SWAP(height,width);\n  ppm = (uchar *) calloc (width, colors*output_bps/8);\n  ppm2 = (ushort *) ppm;\n  merror (ppm, \"write_ppm_tiff()\");\n  if (output_tiff) {\n    tiff_head (&th, 1);\n    fwrite (&th, sizeof th, 1, ofp);\n    if (oprof)\n      fwrite (oprof, ntohl(oprof[0]), 1, ofp);\n  } else if (colors > 3)\n    fprintf (ofp,\n      \"P7\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %d\\nMAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\",\n\twidth, height, colors, (1 << output_bps)-1, cdesc);\n  else\n    fprintf (ofp, \"P%d\\n%d %d\\n%d\\n\",\n\tcolors/2+5, width, height, (1 << output_bps)-1);\n  soff  = flip_index (0, 0);\n  cstep = flip_index (0, 1) - soff;\n  rstep = flip_index (1, 0) - flip_index (0, width);\n  for (row=0; row < height; row++, soff += rstep) {\n    for (col=0; col < width; col++, soff += cstep)\n      if (output_bps == 8)\n\t   FORCC ppm [col*colors+c] = curve[image[soff][c]] >> 8;\n      else FORCC ppm2[col*colors+c] = curve[image[soff][c]];\n    if (output_bps == 16 && !output_tiff && htons(0x55aa) != 0x55aa)\n      swab ((char*)ppm2, (char*)ppm2, width*colors*2);\n    fwrite (ppm, colors*output_bps/8, width, ofp);\n  }\n  free (ppm);\n}\n//@end COMMON\n\nint CLASS main (int argc, const char **argv)\n{\n  int arg, status=0, quality, i, c;\n  int timestamp_only=0, thumbnail_only=0, identify_only=0;\n  int user_qual=-1, user_black=-1, user_sat=-1, user_flip=-1;\n  int use_fuji_rotate=1, write_to_stdout=0, read_from_stdin=0;\n  const char *sp, *bpfile=0, *dark_frame=0, *write_ext;\n  char opm, opt, *ofname, *cp;\n  struct utimbuf ut;\n#ifndef NO_LCMS\n  const char *cam_profile=0, *out_profile=0;\n#endif\n\n#ifndef LOCALTIME\n  putenv ((char *) \"TZ=UTC\");\n#endif\n#ifdef LOCALEDIR\n  setlocale (LC_CTYPE, \"\");\n  setlocale (LC_MESSAGES, \"\");\n  bindtextdomain (\"dcraw\", LOCALEDIR);\n  textdomain (\"dcraw\");\n#endif\n\n  if (argc == 1) {\n    printf(_(\"\\nRaw photo decoder \\\"dcraw\\\" v%s\"), DCRAW_VERSION);\n    printf(_(\"\\nby Dave Coffin, dcoffin a cybercom o net\\n\"));\n    printf(_(\"\\nUsage:  %s [OPTION]... [FILE]...\\n\\n\"), argv[0]);\n    puts(_(\"-v        Print verbose messages\"));\n    puts(_(\"-c        Write image data to standard output\"));\n    puts(_(\"-e        Extract embedded thumbnail image\"));\n    puts(_(\"-i        Identify files without decoding them\"));\n    puts(_(\"-i -v     Identify files and show metadata\"));\n    puts(_(\"-z        Change file dates to camera timestamp\"));\n    puts(_(\"-w        Use camera white balance, if possible\"));\n    puts(_(\"-a        Average the whole image for white balance\"));\n    puts(_(\"-A <x y w h> Average a grey box for white balance\"));\n    puts(_(\"-r <r g b g> Set custom white balance\"));\n    puts(_(\"+M/-M     Use/don't use an embedded color matrix\"));\n    puts(_(\"-C <r b>  Correct chromatic aberration\"));\n    puts(_(\"-P <file> Fix the dead pixels listed in this file\"));\n    puts(_(\"-K <file> Subtract dark frame (16-bit raw PGM)\"));\n    puts(_(\"-k <num>  Set the darkness level\"));\n    puts(_(\"-S <num>  Set the saturation level\"));\n    puts(_(\"-n <num>  Set threshold for wavelet denoising\"));\n    puts(_(\"-H [0-9]  Highlight mode (0=clip, 1=unclip, 2=blend, 3+=rebuild)\"));\n    puts(_(\"-t [0-7]  Flip image (0=none, 3=180, 5=90CCW, 6=90CW)\"));\n    puts(_(\"-o [0-5]  Output colorspace (raw,sRGB,Adobe,Wide,ProPhoto,XYZ)\"));\n#ifndef NO_LCMS\n    puts(_(\"-o <file> Apply output ICC profile from file\"));\n    puts(_(\"-p <file> Apply camera ICC profile from file or \\\"embed\\\"\"));\n#endif\n    puts(_(\"-d        Document mode (no color, no interpolation)\"));\n    puts(_(\"-D        Document mode without scaling (totally raw)\"));\n    puts(_(\"-j        Don't stretch or rotate raw pixels\"));\n    puts(_(\"-W        Don't automatically brighten the image\"));\n    puts(_(\"-b <num>  Adjust brightness (default = 1.0)\"));\n    puts(_(\"-g <p ts> Set custom gamma curve (default = 2.222 4.5)\"));\n    puts(_(\"-q [0-3]  Set the interpolation quality\"));\n    puts(_(\"-h        Half-size color image (twice as fast as \\\"-q 0\\\")\"));\n    puts(_(\"-f        Interpolate RGGB as four colors\"));\n    puts(_(\"-m <num>  Apply a 3x3 median filter to R-G and B-G\"));\n    puts(_(\"-s [0..N-1] Select one raw image or \\\"all\\\" from each file\"));\n    puts(_(\"-6        Write 16-bit instead of 8-bit\"));\n    puts(_(\"-4        Linear 16-bit, same as \\\"-6 -W -g 1 1\\\"\"));\n    puts(_(\"-T        Write TIFF instead of PPM\"));\n    puts(\"\");\n    return 1;\n  }\n  argv[argc] = \"\";\n  for (arg=1; (((opm = argv[arg][0]) - 2) | 2) == '+'; ) {\n    opt = argv[arg++][1];\n    if ((cp = (char *) strchr (sp=\"nbrkStqmHACg\", opt)))\n      for (i=0; i < \"114111111422\"[cp-sp]-'0'; i++)\n\tif (!isdigit(argv[arg+i][0])) {\n\t  fprintf (stderr,_(\"Non-numeric argument to \\\"-%c\\\"\\n\"), opt);\n\t  return 1;\n\t}\n    switch (opt) {\n      case 'n':  threshold   = atof(argv[arg++]);  break;\n      case 'b':  bright      = atof(argv[arg++]);  break;\n      case 'r':\n\t   FORC4 user_mul[c] = atof(argv[arg++]);  break;\n      case 'C':  aber[0] = 1 / atof(argv[arg++]);\n\t\t aber[2] = 1 / atof(argv[arg++]);  break;\n      case 'g':  gamm[0] =     atof(argv[arg++]);\n\t\t gamm[1] =     atof(argv[arg++]);\n\t\t if (gamm[0]) gamm[0] = 1/gamm[0]; break;\n      case 'k':  user_black  = atoi(argv[arg++]);  break;\n      case 'S':  user_sat    = atoi(argv[arg++]);  break;\n      case 't':  user_flip   = atoi(argv[arg++]);  break;\n      case 'q':  user_qual   = atoi(argv[arg++]);  break;\n      case 'm':  med_passes  = atoi(argv[arg++]);  break;\n      case 'H':  highlight   = atoi(argv[arg++]);  break;\n      case 's':\n\tshot_select = abs(atoi(argv[arg]));\n\tmulti_out = !strcmp(argv[arg++],\"all\");\n\tbreak;\n      case 'o':\n\tif (isdigit(argv[arg][0]) && !argv[arg][1])\n\t  output_color = atoi(argv[arg++]);\n#ifndef NO_LCMS\n\telse     out_profile = argv[arg++];\n\tbreak;\n      case 'p':  cam_profile = argv[arg++];\n#endif\n\tbreak;\n      case 'P':  bpfile     = argv[arg++];  break;\n      case 'K':  dark_frame = argv[arg++];  break;\n      case 'z':  timestamp_only    = 1;  break;\n      case 'e':  thumbnail_only    = 1;  break;\n      case 'i':  identify_only     = 1;  break;\n      case 'c':  write_to_stdout   = 1;  break;\n      case 'v':  verbose           = 1;  break;\n      case 'h':  half_size         = 1;\t\t/* \"-h\" implies \"-f\" */\n      case 'f':  four_color_rgb    = 1;  break;\n      case 'A':  FORC4 greybox[c]  = atoi(argv[arg++]);\n      case 'a':  use_auto_wb       = 1;  break;\n      case 'w':  use_camera_wb     = 1;  break;\n      case 'M':  use_camera_matrix = (opm == '+');  break;\n      case 'I':  read_from_stdin   = 1;  break;\n      case 'E':  document_mode++;\n      case 'D':  document_mode++;\n      case 'd':  document_mode++;\n      case 'j':  use_fuji_rotate   = 0;  break;\n      case 'W':  no_auto_bright    = 1;  break;\n      case 'T':  output_tiff       = 1;  break;\n      case '4':  gamm[0] = gamm[1] =\n\t\t no_auto_bright    = 1;\n      case '6':  output_bps       = 16;  break;\n      default:\n\tfprintf (stderr,_(\"Unknown option \\\"-%c\\\".\\n\"), opt);\n\treturn 1;\n    }\n  }\n  if (use_camera_matrix < 0)\n      use_camera_matrix = use_camera_wb;\n  if (arg == argc) {\n    fprintf (stderr,_(\"No files to process.\\n\"));\n    return 1;\n  }\n  if (write_to_stdout) {\n    if (isatty(1)) {\n      fprintf (stderr,_(\"Will not write an image to the terminal!\\n\"));\n      return 1;\n    }\n#if defined(WIN32) || defined(DJGPP) || defined(__CYGWIN__)\n    if (setmode(1,O_BINARY) < 0) {\n      perror (\"setmode()\");\n      return 1;\n    }\n#endif\n  }\n  for ( ; arg < argc; arg++) {\n    status = 1;\n    raw_image = 0;\n    image = 0;\n    oprof = 0;\n    meta_data = ofname = 0;\n    ofp = stdout;\n    if (setjmp (failure)) {\n      if (fileno(ifp) > 2) fclose(ifp);\n      if (fileno(ofp) > 2) fclose(ofp);\n      status = 1;\n      goto cleanup;\n    }\n    ifname = argv[arg];\n    if (!(ifp = fopen (ifname, \"rb\"))) {\n      perror (ifname);\n      continue;\n    }\n    status = (identify(),!is_raw);\n    if (user_flip >= 0)\n      flip = user_flip;\n    switch ((flip+3600) % 360) {\n      case 270:  flip = 5;  break;\n      case 180:  flip = 3;  break;\n      case  90:  flip = 6;\n    }\n    if (timestamp_only) {\n      if ((status = !timestamp))\n\tfprintf (stderr,_(\"%s has no timestamp.\\n\"), ifname);\n      else if (identify_only)\n\tprintf (\"%10ld%10d %s\\n\", (long) timestamp, shot_order, ifname);\n      else {\n\tif (verbose)\n\t  fprintf (stderr,_(\"%s time set to %d.\\n\"), ifname, (int) timestamp);\n\tut.actime = ut.modtime = timestamp;\n\tutime (ifname, &ut);\n      }\n      goto next;\n    }\n    write_fun = &CLASS write_ppm_tiff;\n    if (thumbnail_only) {\n      if ((status = !thumb_offset)) {\n\tfprintf (stderr,_(\"%s has no thumbnail.\\n\"), ifname);\n\tgoto next;\n      } else if (thumb_load_raw) {\n\tload_raw = thumb_load_raw;\n\tdata_offset = thumb_offset;\n\theight = thumb_height;\n\twidth  = thumb_width;\n\tfilters = 0;\n      } else {\n\tfseek (ifp, thumb_offset, SEEK_SET);\n\twrite_fun = write_thumb;\n\tgoto thumbnail;\n      }\n    }\n    if (load_raw == &CLASS kodak_ycbcr_load_raw) {\n      height += height & 1;\n      width  += width  & 1;\n    }\n    if (identify_only && verbose && make[0]) {\n      printf (_(\"\\nFilename: %s\\n\"), ifname);\n      printf (_(\"Timestamp: %s\"), ctime(&timestamp));\n      printf (_(\"Camera: %s %s\\n\"), make, model);\n      if (artist[0])\n\tprintf (_(\"Owner: %s\\n\"), artist);\n      if (dng_version) {\n\tprintf (_(\"DNG Version: \"));\n\tfor (i=24; i >= 0; i -= 8)\n\t  printf (\"%d%c\", dng_version >> i & 255, i ? '.':'\\n');\n      }\n      printf (_(\"ISO speed: %d\\n\"), (int) iso_speed);\n      printf (_(\"Shutter: \"));\n      if (shutter > 0 && shutter < 1)\n\tshutter = (printf (\"1/\"), 1 / shutter);\n      printf (_(\"%0.1f sec\\n\"), shutter);\n      printf (_(\"Aperture: f/%0.1f\\n\"), aperture);\n      printf (_(\"Focal length: %0.1f mm\\n\"), focal_len);\n      printf (_(\"Embedded ICC profile: %s\\n\"), profile_length ? _(\"yes\"):_(\"no\"));\n      printf (_(\"Number of raw images: %d\\n\"), is_raw);\n      if (pixel_aspect != 1)\n\tprintf (_(\"Pixel Aspect Ratio: %0.6f\\n\"), pixel_aspect);\n      if (thumb_offset)\n\tprintf (_(\"Thumb size:  %4d x %d\\n\"), thumb_width, thumb_height);\n      printf (_(\"Full size:   %4d x %d\\n\"), raw_width, raw_height);\n    } else if (!is_raw)\n      fprintf (stderr,_(\"Cannot decode file %s\\n\"), ifname);\n    if (!is_raw) goto next;\n    shrink = filters && (half_size || (!identify_only &&\n\t(threshold || aber[0] != 1 || aber[2] != 1)));\n    iheight = (height + shrink) >> shrink;\n    iwidth  = (width  + shrink) >> shrink;\n    if (identify_only) {\n      if (verbose) {\n\tif (document_mode == 3) {\n\t  top_margin = left_margin = fuji_width = 0;\n\t  height = raw_height;\n\t  if  (width <= raw_width * 8 / tiff_bps)\n\t       width  = raw_width * 8 / tiff_bps;\n\t  else width  = raw_width;\n\t}\n\tiheight = (height + shrink) >> shrink;\n\tiwidth  = (width  + shrink) >> shrink;\n\tif (use_fuji_rotate) {\n\t  if (fuji_width) {\n\t    fuji_width = (fuji_width - 1 + shrink) >> shrink;\n\t    iwidth = fuji_width / sqrt(0.5);\n\t    iheight = (iheight - fuji_width) / sqrt(0.5);\n\t  } else {\n\t    if (pixel_aspect < 1) iheight = iheight / pixel_aspect + 0.5;\n\t    if (pixel_aspect > 1) iwidth  = iwidth  * pixel_aspect + 0.5;\n\t  }\n\t}\n\tif (flip & 4)\n\t  SWAP(iheight,iwidth);\n\tprintf (_(\"Image size:  %4d x %d\\n\"), width, height);\n\tprintf (_(\"Output size: %4d x %d\\n\"), iwidth, iheight);\n\tprintf (_(\"Raw colors: %d\"), colors);\n\tif (filters) {\n\t  printf (_(\"\\nFilter pattern: \"));\n\t  for (i=0; i < 16; i++)\n\t    putchar (cdesc[fcol(i >> 1,i & 1)]);\n\t}\n\tprintf (_(\"\\nDaylight multipliers:\"));\n\tFORCC printf (\" %f\", pre_mul[c]);\n\tif (cam_mul[0] > 0) {\n\t  printf (_(\"\\nCamera multipliers:\"));\n\t  FORC4 printf (\" %f\", cam_mul[c]);\n\t}\n\tputchar ('\\n');\n      } else\n\tprintf (_(\"%s is a %s %s image.\\n\"), ifname, make, model);\nnext:\n      fclose(ifp);\n      continue;\n    }\n    if (use_camera_matrix && cmatrix[0][0] > 0.25) {\n      memcpy (rgb_cam, cmatrix, sizeof cmatrix);\n      raw_color = 0;\n    }\n    if (meta_length) {\n      meta_data = (char *) malloc (meta_length);\n      merror (meta_data, \"main()\");\n    }\n    if (filters || colors == 1) {\n      raw_image = (ushort *) calloc ((raw_height+7)*raw_width, 2);\n      merror (raw_image, \"main()\");\n    } else {\n      image = (ushort (*)[4]) calloc (iheight*iwidth, sizeof *image);\n      merror (image, \"main()\");\n    }\n    if (verbose)\n      fprintf (stderr,_(\"Loading %s %s image from %s ...\\n\"),\n\tmake, model, ifname);\n    if (shot_select >= is_raw)\n      fprintf (stderr,_(\"%s: \\\"-s %d\\\" requests a nonexistent image!\\n\"),\n\tifname, shot_select);\n    fseeko (ifp, data_offset, SEEK_SET);\n    if (raw_image && read_from_stdin)\n      fread (raw_image, 2, raw_height*raw_width, stdin);\n    else (*load_raw)();\n    if (document_mode == 3) {\n      top_margin = left_margin = fuji_width = 0;\n      height = raw_height;\n      if  (width <= raw_width * 8 / tiff_bps)\n           width  = raw_width * 8 / tiff_bps;\n      else width  = raw_width;\n    }\n    iheight = (height + shrink) >> shrink;\n    iwidth  = (width  + shrink) >> shrink;\n    if (raw_image) {\n      image = (ushort (*)[4]) calloc (iheight*iwidth, sizeof *image);\n      merror (image, \"main()\");\n      crop_masked_pixels();\n      free (raw_image);\n    }\n    if (zero_is_bad) remove_zeroes();\n    bad_pixels (bpfile);\n    if (dark_frame) subtract (dark_frame);\n    quality = 2 + !fuji_width;\n    if (user_qual >= 0) quality = user_qual;\n    i = cblack[3];\n    FORC3 if (i > cblack[c]) i = cblack[c];\n    FORC4 cblack[c] -= i;\n    black += i;\n    if (user_black >= 0) black = user_black;\n    FORC4 cblack[c] += black;\n    if (user_sat > 0) maximum = user_sat;\n#ifdef COLORCHECK\n    colorcheck();\n#endif\n    if (is_foveon) {\n      if (document_mode || load_raw == &CLASS foveon_dp_load_raw) {\n\tfor (i=0; i < height*width*4; i++)\n\t  if ((short) image[0][i] < 0) image[0][i] = 0;\n      } else foveon_interpolate();\n    } else if (document_mode < 2)\n      scale_colors();\n    pre_interpolate();\n    if (filters && !document_mode) {\n      if (quality == 0)\n\tlin_interpolate();\n      else if (quality == 1 || colors > 3 || filters < 1000)\n\tvng_interpolate();\n      else if (quality == 2)\n\tppg_interpolate();\n      else ahd_interpolate();\n    }\n    if (mix_green)\n      for (colors=3, i=0; i < height*width; i++)\n\timage[i][1] = (image[i][1] + image[i][3]) >> 1;\n    if (!is_foveon && colors == 3) median_filter();\n    if (!is_foveon && highlight == 2) blend_highlights();\n    if (!is_foveon && highlight > 2) recover_highlights();\n    if (use_fuji_rotate) fuji_rotate();\n#ifndef NO_LCMS\n    if (cam_profile) apply_profile (cam_profile, out_profile);\n#endif\n    convert_to_rgb();\n    if (use_fuji_rotate) stretch();\nthumbnail:\n    if (write_fun == &CLASS jpeg_thumb)\n      write_ext = \".jpg\";\n    else if (output_tiff && write_fun == &CLASS write_ppm_tiff)\n      write_ext = \".tiff\";\n    else\n      write_ext = \".pgm\\0.ppm\\0.ppm\\0.pam\" + colors*5-5;\n    ofname = (char *) malloc (strlen(ifname) + 64);\n    merror (ofname, \"main()\");\n    if (write_to_stdout)\n      strcpy (ofname,_(\"standard output\"));\n    else {\n      strcpy (ofname, ifname);\n      if ((cp = strrchr (ofname, '.'))) *cp = 0;\n      if (multi_out)\n\tsprintf (ofname+strlen(ofname), \"_%0*d\",\n\t\tsnprintf(0,0,\"%d\",is_raw-1), shot_select);\n      if (thumbnail_only)\n\tstrcat (ofname, \".thumb\");\n      strcat (ofname, write_ext);\n      ofp = fopen (ofname, \"wb\");\n      if (!ofp) {\n\tstatus = 1;\n\tperror (ofname);\n\tgoto cleanup;\n      }\n    }\n    if (verbose)\n      fprintf (stderr,_(\"Writing data to %s ...\\n\"), ofname);\n    (*write_fun)();\n    fclose(ifp);\n    if (ofp != stdout) fclose(ofp);\ncleanup:\n    if (meta_data) free (meta_data);\n    if (ofname) free (ofname);\n    if (oprof) free (oprof);\n    if (image) free (image);\n    if (multi_out) {\n      if (++shot_select < is_raw) arg--;\n      else shot_select = 0;\n    }\n  }\n  return status;\n}\n#endif\n", "/* \n  Copyright 2008-2013 LibRaw LLC (info@libraw.org)\n\nLibRaw is free software; you can redistribute it and/or modify\nit under the terms of the one of three licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n3. LibRaw Software License 27032010\n   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).\n\n   This file is generated from Dave Coffin's dcraw.c\n   dcraw.c -- Dave Coffin's raw photo decoder\n   Copyright 1997-2010 by Dave Coffin, dcoffin a cybercom o net\n\n   Look into dcraw homepage (probably http://cybercom.net/~dcoffin/dcraw/)\n   for more information\n*/\n\n#line 257 \"dcraw/dcraw.c\"\n#include <math.h>\n#define CLASS LibRaw::\n#include \"libraw/libraw_types.h\"\n#define LIBRAW_LIBRARY_BUILD\n#define LIBRAW_IO_REDEFINED\n#include \"libraw/libraw.h\"\n#include \"internal/defines.h\"\n#include \"internal/var_defines.h\"\n#include \"internal/libraw_bytebuffer.h\"\n#line 269 \"dcraw/dcraw.c\"\nint CLASS fcol (int row, int col)\n{\n  static const char filter[16][16] =\n  { { 2,1,1,3,2,3,2,0,3,2,3,0,1,2,1,0 },\n    { 0,3,0,2,0,1,3,1,0,1,1,2,0,3,3,2 },\n    { 2,3,3,2,3,1,1,3,3,1,2,1,2,0,0,3 },\n    { 0,1,0,1,0,2,0,2,2,0,3,0,1,3,2,1 },\n    { 3,1,1,2,0,1,0,2,1,3,1,3,0,1,3,0 },\n    { 2,0,0,3,3,2,3,1,2,0,2,0,3,2,2,1 },\n    { 2,3,3,1,2,1,2,1,2,1,1,2,3,0,0,1 },\n    { 1,0,0,2,3,0,0,3,0,3,0,3,2,1,2,3 },\n    { 2,3,3,1,1,2,1,0,3,2,3,0,2,3,1,3 },\n    { 1,0,2,0,3,0,3,2,0,1,1,2,0,1,0,2 },\n    { 0,1,1,3,3,2,2,1,1,3,3,0,2,1,3,2 },\n    { 2,3,2,0,0,1,3,0,2,0,1,2,3,0,1,0 },\n    { 1,3,1,2,3,2,3,2,0,2,0,1,1,0,3,0 },\n    { 0,2,0,3,1,0,0,1,1,3,3,2,3,2,2,1 },\n    { 2,1,3,2,3,1,2,1,0,3,0,2,0,2,0,2 },\n    { 0,3,1,0,0,2,0,3,2,1,3,1,1,3,1,3 } };\n  static const char filter2[6][6] =\n  { { 1,1,0,1,1,2 },\n    { 1,1,2,1,1,0 },\n    { 2,0,1,0,2,1 },\n    { 1,1,2,1,1,0 },\n    { 1,1,0,1,1,2 },\n    { 0,2,1,2,0,1 } };\n\n  if (filters == 1) return filter[(row+top_margin)&15][(col+left_margin)&15];\n  if (filters == 2) return filter2[(row+6) % 6][(col+6) % 6];\n  return FC(row,col);\n}\n\n#ifndef __GLIBC__\nchar *my_memmem (char *haystack, size_t haystacklen,\n\t      char *needle, size_t needlelen)\n{\n  char *c;\n  for (c = haystack; c <= haystack + haystacklen - needlelen; c++)\n    if (!memcmp (c, needle, needlelen))\n      return c;\n  return 0;\n}\n#define memmem my_memmem\n#endif\n#line 335 \"dcraw/dcraw.c\"\nushort CLASS sget2 (uchar *s)\n{\n  if (order == 0x4949)\t\t/* \"II\" means little-endian */\n    return s[0] | s[1] << 8;\n  else\t\t\t\t/* \"MM\" means big-endian */\n    return s[0] << 8 | s[1];\n}\n\nushort CLASS get2()\n{\n  uchar str[2] = { 0xff,0xff };\n  fread (str, 1, 2, ifp);\n  return sget2(str);\n}\n\nunsigned CLASS sget4 (uchar *s)\n{\n  if (order == 0x4949)\n    return s[0] | s[1] << 8 | s[2] << 16 | s[3] << 24;\n  else\n    return s[0] << 24 | s[1] << 16 | s[2] << 8 | s[3];\n}\n#define sget4(s) sget4((uchar *)s)\n\nunsigned CLASS get4()\n{\n  uchar str[4] = { 0xff,0xff,0xff,0xff };\n  fread (str, 1, 4, ifp);\n  return sget4(str);\n}\n\nunsigned CLASS getint (int type)\n{\n  return type == 3 ? get2() : get4();\n}\n\nfloat CLASS int_to_float (int i)\n{\n  union { int i; float f; } u;\n  u.i = i;\n  return u.f;\n}\n\ndouble CLASS getreal (int type)\n{\n  union { char c[8]; double d; } u;\n  int i, rev;\n\n  switch (type) {\n    case 3: return (unsigned short) get2();\n    case 4: return (unsigned int) get4();\n    case 5:  u.d = (unsigned int) get4();\n      return u.d / (unsigned int) get4();\n    case 8: return (signed short) get2();\n    case 9: return (signed int) get4();\n    case 10: u.d = (signed int) get4();\n      return u.d / (signed int) get4();\n    case 11: return int_to_float (get4());\n    case 12:\n      rev = 7 * ((order == 0x4949) == (ntohs(0x1234) == 0x1234));\n      for (i=0; i < 8; i++)\n\tu.c[i ^ rev] = fgetc(ifp);\n      return u.d;\n    default: return fgetc(ifp);\n  }\n}\n\nvoid CLASS read_shorts (ushort *pixel, int count)\n{\n  if (fread (pixel, 2, count, ifp) < count) derror();\n  if ((order == 0x4949) == (ntohs(0x1234) == 0x1234))\n    swab ((char*)pixel, (char*)pixel, count*2);\n}\n\nvoid CLASS canon_600_fixed_wb (int temp)\n{\n  static const short mul[4][5] = {\n    {  667, 358,397,565,452 },\n    {  731, 390,367,499,517 },\n    { 1119, 396,348,448,537 },\n    { 1399, 485,431,508,688 } };\n  int lo, hi, i;\n  float frac=0;\n\n  for (lo=4; --lo; )\n    if (*mul[lo] <= temp) break;\n  for (hi=0; hi < 3; hi++)\n    if (*mul[hi] >= temp) break;\n  if (lo != hi)\n    frac = (float) (temp - *mul[lo]) / (*mul[hi] - *mul[lo]);\n  for (i=1; i < 5; i++)\n    pre_mul[i-1] = 1 / (frac * mul[hi][i] + (1-frac) * mul[lo][i]);\n}\n\n/* Return values:  0 = white  1 = near white  2 = not white */\nint CLASS canon_600_color (int ratio[2], int mar)\n{\n  int clipped=0, target, miss;\n\n  if (flash_used) {\n    if (ratio[1] < -104)\n      { ratio[1] = -104; clipped = 1; }\n    if (ratio[1] >   12)\n      { ratio[1] =   12; clipped = 1; }\n  } else {\n    if (ratio[1] < -264 || ratio[1] > 461) return 2;\n    if (ratio[1] < -50)\n      { ratio[1] = -50; clipped = 1; }\n    if (ratio[1] > 307)\n      { ratio[1] = 307; clipped = 1; }\n  }\n  target = flash_used || ratio[1] < 197\n\t? -38 - (398 * ratio[1] >> 10)\n\t: -123 + (48 * ratio[1] >> 10);\n  if (target - mar <= ratio[0] &&\n      target + 20  >= ratio[0] && !clipped) return 0;\n  miss = target - ratio[0];\n  if (abs(miss) >= mar*4) return 2;\n  if (miss < -20) miss = -20;\n  if (miss > mar) miss = mar;\n  ratio[0] = target - miss;\n  return 1;\n}\n\nvoid CLASS canon_600_auto_wb()\n{\n  int mar, row, col, i, j, st, count[] = { 0,0 };\n  int test[8], total[2][8], ratio[2][2], stat[2];\n\n  memset (&total, 0, sizeof total);\n  i = canon_ev + 0.5;\n  if      (i < 10) mar = 150;\n  else if (i > 12) mar = 20;\n  else mar = 280 - 20 * i;\n  if (flash_used) mar = 80;\n  for (row=14; row < height-14; row+=4)\n    for (col=10; col < width; col+=2) {\n      for (i=0; i < 8; i++)\n\ttest[(i & 4) + FC(row+(i >> 1),col+(i & 1))] =\n\t\t    BAYER(row+(i >> 1),col+(i & 1));\n      for (i=0; i < 8; i++)\n\tif (test[i] < 150 || test[i] > 1500) goto next;\n      for (i=0; i < 4; i++)\n\tif (abs(test[i] - test[i+4]) > 50) goto next;\n      for (i=0; i < 2; i++) {\n\tfor (j=0; j < 4; j+=2)\n\t  ratio[i][j >> 1] = ((test[i*4+j+1]-test[i*4+j]) << 10) / test[i*4+j];\n\tstat[i] = canon_600_color (ratio[i], mar);\n      }\n      if ((st = stat[0] | stat[1]) > 1) goto next;\n      for (i=0; i < 2; i++)\n\tif (stat[i])\n\t  for (j=0; j < 2; j++)\n\t    test[i*4+j*2+1] = test[i*4+j*2] * (0x400 + ratio[i][j]) >> 10;\n      for (i=0; i < 8; i++)\n\ttotal[st][i] += test[i];\n      count[st]++;\nnext: ;\n    }\n  if (count[0] | count[1]) {\n    st = count[0]*200 < count[1];\n    for (i=0; i < 4; i++)\n      pre_mul[i] = 1.0 / (total[st][i] + total[st][i+4]);\n  }\n}\n\nvoid CLASS canon_600_coeff()\n{\n  static const short table[6][12] = {\n    { -190,702,-1878,2390,   1861,-1349,905,-393, -432,944,2617,-2105  },\n    { -1203,1715,-1136,1648, 1388,-876,267,245,  -1641,2153,3921,-3409 },\n    { -615,1127,-1563,2075,  1437,-925,509,3,     -756,1268,2519,-2007 },\n    { -190,702,-1886,2398,   2153,-1641,763,-251, -452,964,3040,-2528  },\n    { -190,702,-1878,2390,   1861,-1349,905,-393, -432,944,2617,-2105  },\n    { -807,1319,-1785,2297,  1388,-876,769,-257,  -230,742,2067,-1555  } };\n  int t=0, i, c;\n  float mc, yc;\n\n  mc = pre_mul[1] / pre_mul[2];\n  yc = pre_mul[3] / pre_mul[2];\n  if (mc > 1 && mc <= 1.28 && yc < 0.8789) t=1;\n  if (mc > 1.28 && mc <= 2) {\n    if  (yc < 0.8789) t=3;\n    else if (yc <= 2) t=4;\n  }\n  if (flash_used) t=5;\n  for (raw_color = i=0; i < 3; i++)\n    FORCC rgb_cam[i][c] = table[t][i*4 + c] / 1024.0;\n}\n\nvoid CLASS canon_600_load_raw()\n{\n  uchar  data[1120], *dp;\n  ushort *pix;\n  int irow, row;\n\n  for (irow=row=0; irow < height; irow++) {\n    if (fread (data, 1, 1120, ifp) < 1120) derror();\n    pix = raw_image + row*raw_width;\n    for (dp=data; dp < data+1120;  dp+=10, pix+=8) {\n      pix[0] = (dp[0] << 2) + (dp[1] >> 6    );\n      pix[1] = (dp[2] << 2) + (dp[1] >> 4 & 3);\n      pix[2] = (dp[3] << 2) + (dp[1] >> 2 & 3);\n      pix[3] = (dp[4] << 2) + (dp[1]      & 3);\n      pix[4] = (dp[5] << 2) + (dp[9]      & 3);\n      pix[5] = (dp[6] << 2) + (dp[9] >> 2 & 3);\n      pix[6] = (dp[7] << 2) + (dp[9] >> 4 & 3);\n      pix[7] = (dp[8] << 2) + (dp[9] >> 6    );\n    }\n    if ((row+=2) > height) row = 1;\n  }\n}\n\nvoid CLASS canon_600_correct()\n{\n  int row, col, val;\n  static const short mul[4][2] =\n  { { 1141,1145 }, { 1128,1109 }, { 1178,1149 }, { 1128,1109 } };\n\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++) {\n      if ((val = BAYER(row,col) - black) < 0) val = 0;\n      val = val * mul[row & 3][col & 1] >> 9;\n      BAYER(row,col) = val;\n    }\n  canon_600_fixed_wb(1311);\n  canon_600_auto_wb();\n  canon_600_coeff();\n  maximum = (0x3ff - black) * 1109 >> 9;\n  black = 0;\n}\n\nint CLASS canon_s2is()\n{\n  unsigned row;\n\n  for (row=0; row < 100; row++) {\n    fseek (ifp, row*3340 + 3284, SEEK_SET);\n    if (getc(ifp) > 15) return 1;\n  }\n  return 0;\n}\n\n/*\n   getbits(-1) initializes the buffer\n   getbits(n) where 0 <= n <= 25 returns an n-bit integer\n */\nunsigned CLASS getbithuff (int nbits, ushort *huff)\n{\n#ifdef LIBRAW_NOTHREADS\n  static unsigned bitbuf=0;\n  static int vbits=0, reset=0;\n#else\n#define bitbuf tls->getbits.bitbuf\n#define vbits  tls->getbits.vbits\n#define reset  tls->getbits.reset\n#endif\n  unsigned c;\n\n  if (nbits == -1)\n    return bitbuf = vbits = reset = 0;\n  if (nbits == 0 || vbits < 0) return 0;\n  while (!reset && vbits < nbits && (c = fgetc(ifp)) != EOF &&\n    !(reset = zero_after_ff && c == 0xff && fgetc(ifp))) {\n    bitbuf = (bitbuf << 8) + (uchar) c;\n    vbits += 8;\n  }\n  c = bitbuf << (32-vbits) >> (32-nbits);\n  if (huff) {\n    vbits -= huff[c] >> 8;\n    c = (uchar) huff[c];\n  } else\n    vbits -= nbits;\n  if (vbits < 0) derror();\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#undef reset\n#endif\n}\n\n#define getbits(n) getbithuff(n,0)\n#define gethuff(h) getbithuff(*h,h+1)\n\n/*\n   Construct a decode tree according the specification in *source.\n   The first 16 bytes specify how many codes should be 1-bit, 2-bit\n   3-bit, etc.  Bytes after that are the leaf values.\n\n   For example, if the source is\n\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,\n      0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },\n\n   then the code is\n\n\t00\t\t0x04\n\t010\t\t0x03\n\t011\t\t0x05\n\t100\t\t0x06\n\t101\t\t0x02\n\t1100\t\t0x07\n\t1101\t\t0x01\n\t11100\t\t0x08\n\t11101\t\t0x09\n\t11110\t\t0x00\n\t111110\t\t0x0a\n\t1111110\t\t0x0b\n\t1111111\t\t0xff\n */\nushort * CLASS make_decoder_ref (const uchar **source)\n{\n  int max, len, h, i, j;\n  const uchar *count;\n  ushort *huff;\n\n  count = (*source += 16) - 17;\n  for (max=16; max && !count[max]; max--);\n  huff = (ushort *) calloc (1 + (1 << max), sizeof *huff);\n  merror (huff, \"make_decoder()\");\n  huff[0] = max;\n  for (h=len=1; len <= max; len++)\n    for (i=0; i < count[len]; i++, ++*source)\n      for (j=0; j < 1 << (max-len); j++)\n\tif (h <= 1 << max)\n\t  huff[h++] = len << 8 | **source;\n  return huff;\n}\n\nushort * CLASS make_decoder (const uchar *source)\n{\n  return make_decoder_ref (&source);\n}\n\nvoid CLASS crw_init_tables (unsigned table, ushort *huff[2])\n{\n  static const uchar first_tree[3][29] = {\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,\n      0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },\n    { 0,2,2,3,1,1,1,1,2,0,0,0,0,0,0,0,\n      0x03,0x02,0x04,0x01,0x05,0x00,0x06,0x07,0x09,0x08,0x0a,0x0b,0xff  },\n    { 0,0,6,3,1,1,2,0,0,0,0,0,0,0,0,0,\n      0x06,0x05,0x07,0x04,0x08,0x03,0x09,0x02,0x00,0x0a,0x01,0x0b,0xff  },\n  };\n  static const uchar second_tree[3][180] = {\n    { 0,2,2,2,1,4,2,1,2,5,1,1,0,0,0,139,\n      0x03,0x04,0x02,0x05,0x01,0x06,0x07,0x08,\n      0x12,0x13,0x11,0x14,0x09,0x15,0x22,0x00,0x21,0x16,0x0a,0xf0,\n      0x23,0x17,0x24,0x31,0x32,0x18,0x19,0x33,0x25,0x41,0x34,0x42,\n      0x35,0x51,0x36,0x37,0x38,0x29,0x79,0x26,0x1a,0x39,0x56,0x57,\n      0x28,0x27,0x52,0x55,0x58,0x43,0x76,0x59,0x77,0x54,0x61,0xf9,\n      0x71,0x78,0x75,0x96,0x97,0x49,0xb7,0x53,0xd7,0x74,0xb6,0x98,\n      0x47,0x48,0x95,0x69,0x99,0x91,0xfa,0xb8,0x68,0xb5,0xb9,0xd6,\n      0xf7,0xd8,0x67,0x46,0x45,0x94,0x89,0xf8,0x81,0xd5,0xf6,0xb4,\n      0x88,0xb1,0x2a,0x44,0x72,0xd9,0x87,0x66,0xd4,0xf5,0x3a,0xa7,\n      0x73,0xa9,0xa8,0x86,0x62,0xc7,0x65,0xc8,0xc9,0xa1,0xf4,0xd1,\n      0xe9,0x5a,0x92,0x85,0xa6,0xe7,0x93,0xe8,0xc1,0xc6,0x7a,0x64,\n      0xe1,0x4a,0x6a,0xe6,0xb3,0xf1,0xd3,0xa5,0x8a,0xb2,0x9a,0xba,\n      0x84,0xa4,0x63,0xe5,0xc5,0xf3,0xd2,0xc4,0x82,0xaa,0xda,0xe4,\n      0xf2,0xca,0x83,0xa3,0xa2,0xc3,0xea,0xc2,0xe2,0xe3,0xff,0xff  },\n    { 0,2,2,1,4,1,4,1,3,3,1,0,0,0,0,140,\n      0x02,0x03,0x01,0x04,0x05,0x12,0x11,0x06,\n      0x13,0x07,0x08,0x14,0x22,0x09,0x21,0x00,0x23,0x15,0x31,0x32,\n      0x0a,0x16,0xf0,0x24,0x33,0x41,0x42,0x19,0x17,0x25,0x18,0x51,\n      0x34,0x43,0x52,0x29,0x35,0x61,0x39,0x71,0x62,0x36,0x53,0x26,\n      0x38,0x1a,0x37,0x81,0x27,0x91,0x79,0x55,0x45,0x28,0x72,0x59,\n      0xa1,0xb1,0x44,0x69,0x54,0x58,0xd1,0xfa,0x57,0xe1,0xf1,0xb9,\n      0x49,0x47,0x63,0x6a,0xf9,0x56,0x46,0xa8,0x2a,0x4a,0x78,0x99,\n      0x3a,0x75,0x74,0x86,0x65,0xc1,0x76,0xb6,0x96,0xd6,0x89,0x85,\n      0xc9,0xf5,0x95,0xb4,0xc7,0xf7,0x8a,0x97,0xb8,0x73,0xb7,0xd8,\n      0xd9,0x87,0xa7,0x7a,0x48,0x82,0x84,0xea,0xf4,0xa6,0xc5,0x5a,\n      0x94,0xa4,0xc6,0x92,0xc3,0x68,0xb5,0xc8,0xe4,0xe5,0xe6,0xe9,\n      0xa2,0xa3,0xe3,0xc2,0x66,0x67,0x93,0xaa,0xd4,0xd5,0xe7,0xf8,\n      0x88,0x9a,0xd7,0x77,0xc4,0x64,0xe2,0x98,0xa5,0xca,0xda,0xe8,\n      0xf3,0xf6,0xa9,0xb2,0xb3,0xf2,0xd2,0x83,0xba,0xd3,0xff,0xff  },\n    { 0,0,6,2,1,3,3,2,5,1,2,2,8,10,0,117,\n      0x04,0x05,0x03,0x06,0x02,0x07,0x01,0x08,\n      0x09,0x12,0x13,0x14,0x11,0x15,0x0a,0x16,0x17,0xf0,0x00,0x22,\n      0x21,0x18,0x23,0x19,0x24,0x32,0x31,0x25,0x33,0x38,0x37,0x34,\n      0x35,0x36,0x39,0x79,0x57,0x58,0x59,0x28,0x56,0x78,0x27,0x41,\n      0x29,0x77,0x26,0x42,0x76,0x99,0x1a,0x55,0x98,0x97,0xf9,0x48,\n      0x54,0x96,0x89,0x47,0xb7,0x49,0xfa,0x75,0x68,0xb6,0x67,0x69,\n      0xb9,0xb8,0xd8,0x52,0xd7,0x88,0xb5,0x74,0x51,0x46,0xd9,0xf8,\n      0x3a,0xd6,0x87,0x45,0x7a,0x95,0xd5,0xf6,0x86,0xb4,0xa9,0x94,\n      0x53,0x2a,0xa8,0x43,0xf5,0xf7,0xd4,0x66,0xa7,0x5a,0x44,0x8a,\n      0xc9,0xe8,0xc8,0xe7,0x9a,0x6a,0x73,0x4a,0x61,0xc7,0xf4,0xc6,\n      0x65,0xe9,0x72,0xe6,0x71,0x91,0x93,0xa6,0xda,0x92,0x85,0x62,\n      0xf3,0xc5,0xb2,0xa4,0x84,0xba,0x64,0xa5,0xb3,0xd2,0x81,0xe5,\n      0xd3,0xaa,0xc4,0xca,0xf2,0xb1,0xe4,0xd1,0x83,0x63,0xea,0xc3,\n      0xe2,0x82,0xf1,0xa3,0xc2,0xa1,0xc1,0xe3,0xa2,0xe1,0xff,0xff  }\n  };\n  if (table > 2) table = 2;\n  huff[0] = make_decoder ( first_tree[table]);\n  huff[1] = make_decoder (second_tree[table]);\n}\n\n/*\n   Return 0 if the image starts with compressed data,\n   1 if it starts with uncompressed low-order bits.\n\n   In Canon compressed data, 0xff is always followed by 0x00.\n */\nint CLASS canon_has_lowbits()\n{\n  uchar test[0x4000];\n  int ret=1, i;\n\n  fseek (ifp, 0, SEEK_SET);\n  fread (test, 1, sizeof test, ifp);\n  for (i=540; i < sizeof test - 1; i++)\n    if (test[i] == 0xff) {\n      if (test[i+1]) return 1;\n      ret=0;\n    }\n  return ret;\n}\n\nvoid CLASS canon_load_raw()\n{\n  ushort *pixel, *prow, *huff[2];\n  int nblocks, lowbits, i, c, row, r, save, val;\n  int block, diffbuf[64], leaf, len, diff, carry=0, pnum=0, base[2];\n\n  crw_init_tables (tiff_compress, huff);\n  lowbits = canon_has_lowbits();\n  if (!lowbits) maximum = 0x3ff;\n  fseek (ifp, 540 + lowbits*raw_height*raw_width/4, SEEK_SET);\n  zero_after_ff = 1;\n  getbits(-1);\n  for (row=0; row < raw_height; row+=8) {\n    pixel = raw_image + row*raw_width;\n    nblocks = MIN (8, raw_height-row) * raw_width >> 6;\n    for (block=0; block < nblocks; block++) {\n      memset (diffbuf, 0, sizeof diffbuf);\n      for (i=0; i < 64; i++ ) {\n\tleaf = gethuff(huff[i > 0]);\n\tif (leaf == 0 && i) break;\n\tif (leaf == 0xff) continue;\n\ti  += leaf >> 4;\n\tlen = leaf & 15;\n\tif (len == 0) continue;\n\tdiff = getbits(len);\n\tif ((diff & (1 << (len-1))) == 0)\n\t  diff -= (1 << len) - 1;\n\tif (i < 64) diffbuf[i] = diff;\n      }\n      diffbuf[0] += carry;\n      carry = diffbuf[0];\n      for (i=0; i < 64; i++ ) {\n\tif (pnum++ % raw_width == 0)\n\t  base[0] = base[1] = 512;\n\tif ((pixel[(block << 6) + i] = base[i & 1] += diffbuf[i]) >> 10)\n\t  derror();\n      }\n    }\n    if (lowbits) {\n      save = ftell(ifp);\n      fseek (ifp, 26 + row*raw_width/4, SEEK_SET);\n      for (prow=pixel, i=0; i < raw_width*2; i++) {\n\tc = fgetc(ifp);\n\tfor (r=0; r < 8; r+=2, prow++) {\n\t  val = (*prow << 2) + ((c >> r) & 3);\n\t  if (raw_width == 2672 && val < 512) val += 2;\n\t  *prow = val;\n\t}\n      }\n      fseek (ifp, save, SEEK_SET);\n    }\n  }\n  FORC(2) free (huff[c]);\n}\n#line 819 \"dcraw/dcraw.c\"\nint CLASS ljpeg_start (struct jhead *jh, int info_only)\n{\n  int c, tag, len;\n  uchar data[0x10000];\n  const uchar *dp;\n\n  memset (jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  fread (data, 2, 1, ifp);\n  if (data[1] != 0xd8) return 0;\n  do {\n    fread (data, 2, 2, ifp);\n    tag =  data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00) return 0;\n    fread (data, 1, len, ifp);\n    switch (tag) {\n      case 0xffc3:\n\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n      case 0xffc0:\n\tjh->bits = data[0];\n\tjh->high = data[1] << 8 | data[2];\n\tjh->wide = data[3] << 8 | data[4];\n\tjh->clrs = data[5] + jh->sraw;\n\tif (len == 9 && !dng_version) getc(ifp);\n\tbreak;\n      case 0xffc4:\n\tif (info_only) break;\n\tfor (dp = data; dp < data+len && (c = *dp++) < 4; )\n\t  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);\n\tbreak;\n      case 0xffda:\n\tjh->psv = data[1+data[0]*2];\n\tjh->bits -= data[3+data[0]*2] & 15;\n\tbreak;\n      case 0xffdd:\n\tjh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (info_only) return 1;\n  FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];\n  if (jh->sraw) {\n    FORC(4)        jh->huff[2+c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\n  }\n  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\n  merror (jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}\n\nvoid CLASS ljpeg_end (struct jhead *jh)\n{\n  int c;\n  FORC4 if (jh->free[c]) free (jh->free[c]);\n  free (jh->row);\n}\n\nint CLASS ljpeg_diff (ushort *huff)\n{\n  int len, diff;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!huff)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n  len = gethuff(huff);\n  if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n    return -32768;\n  diff = getbits(len);\n  if ((diff & (1 << (len-1))) == 0)\n    diff -= (1 << len) - 1;\n  return diff;\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\nint CLASS ljpeg_diff_new (LibRaw_bit_buffer& bits, LibRaw_byte_buffer* buf,ushort *huff)\n{\n  int len, diff;\n\n  if(!huff || !buf)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  len = bits._gethuff_lj(buf,*huff,huff+1);\n  if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n    return -32768;\n  diff = bits._getbits_lj(buf,len);\n  if ((diff & (1 << (len-1))) == 0)\n    diff -= (1 << len) - 1;\n  return diff;\n}\n\nushort * CLASS ljpeg_row_new (int jrow, struct jhead *jh, LibRaw_bit_buffer& bits,LibRaw_byte_buffer* bytes)\n{\n  int col, c, diff, pred, spred=0;\n  ushort mark=0, *row[3];\n\n  if (jrow * jh->wide % jh->restart == 0) {\n    FORC(6) jh->vpred[c] = 1 << (jh->bits-1);\n    if (jrow) {\n        bytes->unseek2();\n        do mark = (mark << 8) + (c = bytes->get_byte());\n        while (c != EOF && mark >> 4 != 0xffd);\n    }\n    bits.reset();\n  }\n  FORC3 row[c] = jh->row + jh->wide*jh->clrs*((jrow+c) & 1);\n  for (col=0; col < jh->wide; col++)\n    FORC(jh->clrs) {\n        diff = ljpeg_diff_new (bits,bytes,jh->huff[c]);\n      if (jh->sraw && c <= jh->sraw && (col | c))\n\t\t    pred = spred;\n      else if (col) pred = row[0][-jh->clrs];\n      else\t    pred = (jh->vpred[c] += diff) - diff;\n      if (jrow && col) switch (jh->psv) {\n\tcase 1:\tbreak;\n\tcase 2: pred = row[1][0];\t\t\t\t\tbreak;\n\tcase 3: pred = row[1][-jh->clrs];\t\t\t\tbreak;\n\tcase 4: pred = pred +   row[1][0] - row[1][-jh->clrs];\t\tbreak;\n\tcase 5: pred = pred + ((row[1][0] - row[1][-jh->clrs]) >> 1);\tbreak;\n\tcase 6: pred = row[1][0] + ((pred - row[1][-jh->clrs]) >> 1);\tbreak;\n\tcase 7: pred = (pred + row[1][0]) >> 1;\t\t\t\tbreak;\n\tdefault: pred = 0;\n      }\n      if ((**row = pred + diff) >> jh->bits) derror();\n      if (c <= jh->sraw) spred = **row;\n      row[0]++; row[1]++;\n    }\n  return row[2];\n}\n\n#endif\n\n\nushort * CLASS ljpeg_row (int jrow, struct jhead *jh)\n{\n  int col, c, diff, pred, spred=0;\n  ushort mark=0, *row[3];\n\n  if (jrow * jh->wide % jh->restart == 0) {\n    FORC(6) jh->vpred[c] = 1 << (jh->bits-1);\n    if (jrow) {\n      fseek (ifp, -2, SEEK_CUR);\n      do mark = (mark << 8) + (c = fgetc(ifp));\n      while (c != EOF && mark >> 4 != 0xffd);\n    }\n    getbits(-1);\n  }\n  FORC3 row[c] = jh->row + jh->wide*jh->clrs*((jrow+c) & 1);\n  for (col=0; col < jh->wide; col++)\n    FORC(jh->clrs) {\n      diff = ljpeg_diff (jh->huff[c]);\n      if (jh->sraw && c <= jh->sraw && (col | c))\n\t\t    pred = spred;\n      else if (col) pred = row[0][-jh->clrs];\n      else\t    pred = (jh->vpred[c] += diff) - diff;\n      if (jrow && col) switch (jh->psv) {\n\tcase 1:\tbreak;\n\tcase 2: pred = row[1][0];\t\t\t\t\tbreak;\n\tcase 3: pred = row[1][-jh->clrs];\t\t\t\tbreak;\n\tcase 4: pred = pred +   row[1][0] - row[1][-jh->clrs];\t\tbreak;\n\tcase 5: pred = pred + ((row[1][0] - row[1][-jh->clrs]) >> 1);\tbreak;\n\tcase 6: pred = row[1][0] + ((pred - row[1][-jh->clrs]) >> 1);\tbreak;\n\tcase 7: pred = (pred + row[1][0]) >> 1;\t\t\t\tbreak;\n\tdefault: pred = 0;\n      }\n      if ((**row = pred + diff) >> jh->bits) derror();\n      if (c <= jh->sraw) spred = **row;\n      row[0]++; row[1]++;\n    }\n  return row[2];\n}\n\nvoid CLASS lossless_jpeg_load_raw()\n{\n  int jwide, jrow, jcol, val, i, row=0, col=0;\n#ifndef LIBRAW_LIBRARY_BUILD\n  int jidx,j;\n#endif\n  struct jhead jh;\n  ushort *rp;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  int save_min = 0;\n  unsigned slicesW[16],slicesWcnt=0,slices;\n  unsigned *offset;\n  unsigned t_y=0,t_x=0,t_s=0,slice=0,pixelsInSlice,pixno;\n  if (!strcasecmp(make,\"KODAK\"))\n      save_min = 1;\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (cr2_slice[0]>15)\n      throw LIBRAW_EXCEPTION_IO_EOF; // change many slices\n#else\n  if (cr2_slice[0]>15)\n  {\n      fprintf(stderr,\"Too many CR2 slices: %d\\n\",cr2_slice[0]+1);\n      return;\n  }\n#endif\n\n  if (!ljpeg_start (&jh, 0)) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(jh.wide<1 || jh.high<1 || jh.clrs<1 || jh.bits <1)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  jwide = jh.wide * jh.clrs;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(cr2_slice[0])\n      {\n          for(i=0;i<cr2_slice[0];i++)\n              slicesW[slicesWcnt++] = cr2_slice[1];\n          slicesW[slicesWcnt++] = cr2_slice[2];\n      }\n  else\n      {\n          // not sliced\n          slicesW[slicesWcnt++] = raw_width; // safe fallback\n      }\n       \n  slices = slicesWcnt * jh.high;\n  if(!slices)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  offset = (unsigned*)calloc(slices+1,sizeof(offset[0]));\n\n  for(slice=0;slice<slices;slice++)\n      {\n          offset[slice] = (t_x + t_y * raw_width)| (t_s<<28);\n          if((offset[slice] & 0x0fffffff) >= raw_width * raw_height)\n            {\n              free(offset);\n              throw LIBRAW_EXCEPTION_IO_BADFILE; \n            }\n          t_y++;\n          if(t_y == jh.high)\n              {\n                  t_y = 0;\n                  t_x += slicesW[t_s++];\n              }\n      }\n  offset[slices] = offset[slices-1];\n  slice = 1; // next slice\n  pixno = offset[0]; \n  pixelsInSlice = slicesW[0];\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  LibRaw_byte_buffer *buf=NULL;\n  if(data_size)\n      buf = ifp->make_byte_buffer(data_size);\n  LibRaw_bit_buffer bits;\n#endif\n\n  for (jrow=0; jrow < jh.high; jrow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (buf)\n          rp = ljpeg_row_new (jrow, &jh,bits,buf);\n      else\n#endif\n    rp = ljpeg_row (jrow, &jh);\n    if (load_flags & 1)\n      row = jrow & 1 ? height-1-jrow/2 : jrow/2;\n    for (jcol=0; jcol < jwide; jcol++) {\n      val = curve[*rp++];\n#ifndef LIBRAW_LIBRARY_BUILD\n      // slow dcraw way to calculate row/col\n      if (cr2_slice[0]) {\n\tjidx = jrow*jwide + jcol;\n\ti = jidx / (cr2_slice[1]*jh.high);\n\tif ((j = i >= cr2_slice[0]))\n\t\t i  = cr2_slice[0];\n\tjidx -= i * (cr2_slice[1]*jh.high);\n\trow = jidx / cr2_slice[1+j];\n\tcol = jidx % cr2_slice[1+j] + i*cr2_slice[1];\n      }\n#else\n      // new fast one, but for data_size defined only (i.e. new CR2 format, not 1D/1Ds)\n      if(buf) \n          {\n              if(!(load_flags & 1))\n                  row = pixno/raw_width;\n              col = pixno % raw_width;\n              pixno++;\n              if (0 == --pixelsInSlice)\n                  {\n                    if(slice > slices)\n                      {\n                        free(offset);\n                        throw LIBRAW_EXCEPTION_IO_CORRUPT;\n                      }\n                      unsigned o = offset[slice++];\n                      pixno = o & 0x0fffffff;\n                      pixelsInSlice = slicesW[o>>28];\n                  }\n          }\n#endif\n\n      if(row>raw_height)\n#ifdef LIBRAW_LIBRARY_BUILD\n      {\n        free(offset);\n        throw LIBRAW_EXCEPTION_IO_CORRUPT;\n      }\n#else\n        longjmp (failure, 3);\n#endif\n      if (raw_width == 3984 && (col -= 2) < 0)\n\tcol += (row--,raw_width);\n      if (row >= 0) RAW(row,col) = val;\n#ifndef LIBRAW_LIBRARY_BUILD\n      if (++col >= raw_width)\n\tcol = (row++,0);\n#else\n      if(!buf) // 1D or 1Ds case\n         if (++col >= raw_width)\n            col = (row++,0);\n#endif\n    }\n  }\n  ljpeg_end (&jh);\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(buf)\n      delete buf;\n  free(offset);\n#endif\n}\n\nvoid CLASS canon_sraw_load_raw()\n{\n  struct jhead jh;\n  short *rp=0, (*ip)[4];\n  int jwide, slice, scol, ecol, row, col, jrow=0, jcol=0, pix[3], c;\n  int v[3]={0,0,0}, ver, hue;\n  char *cp;\n\n  if (!ljpeg_start (&jh, 0)) return;\n  jwide = (jh.wide >>= 1) * jh.clrs;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!data_size)\n      throw LIBRAW_EXCEPTION_IO_BADFILE;\n  LibRaw_byte_buffer *buf = ifp->make_byte_buffer(data_size);\n  LibRaw_bit_buffer bits;\n#endif\n\n  for (ecol=slice=0; slice <= cr2_slice[0]; slice++) {\n    scol = ecol;\n    ecol += cr2_slice[1] * 2 / jh.clrs;\n    if (!cr2_slice[0] || ecol > raw_width-1) ecol = raw_width & -2;\n    for (row=0; row < height; row += (jh.clrs >> 1) - 1) {\n      ip = (short (*)[4]) image + row*width;\n      for (col=scol; col < ecol; col+=2, jcol+=jh.clrs) {\n\tif ((jcol %= jwide) == 0)\n#ifdef LIBRAW_LIBRARY_BUILD\n            rp = (short*) ljpeg_row_new (jrow++, &jh,bits,buf);\n#else\n            rp = (short *) ljpeg_row (jrow++, &jh);\n#endif\n\tif (col >= width) continue;\n\tFORC (jh.clrs-2)\n\t  ip[col + (c >> 1)*width + (c & 1)][0] = rp[jcol+c];\n\tip[col][1] = rp[jcol+jh.clrs-2] - 16384;\n\tip[col][2] = rp[jcol+jh.clrs-1] - 16384;\n      }\n    }\n  }\n  for (cp=model2; *cp && !isdigit(*cp); cp++);\n  sscanf (cp, \"%d.%d.%d\", v, v+1, v+2);\n  ver = (v[0]*1000 + v[1])*1000 + v[2];\n  hue = (jh.sraw+1) << 2;\n  if (unique_id >= 0x80000281 || (unique_id == 0x80000218 && ver > 1000006))\n    hue = jh.sraw << 1;\n  ip = (short (*)[4]) image;\n  rp = ip[0];\n  for (row=0; row < height; row++, ip+=width) {\n    if (row & (jh.sraw >> 1))\n      for (col=0; col < width; col+=2)\n\tfor (c=1; c < 3; c++)\n\t  if (row == height-1)\n\t       ip[col][c] =  ip[col-width][c];\n\t  else ip[col][c] = (ip[col-width][c] + ip[col+width][c] + 1) >> 1;\n    for (col=1; col < width; col+=2)\n      for (c=1; c < 3; c++)\n\tif (col == width-1)\n\t     ip[col][c] =  ip[col-1][c];\n\telse ip[col][c] = (ip[col-1][c] + ip[col+1][c] + 1) >> 1;\n  }\n  for ( ; rp < ip[0]; rp+=4) {\n    if (unique_id == 0x80000218 ||\n\tunique_id == 0x80000250 ||\n\tunique_id == 0x80000261 ||\n\tunique_id == 0x80000281 ||\n\tunique_id == 0x80000287) {\n      rp[1] = (rp[1] << 2) + hue;\n      rp[2] = (rp[2] << 2) + hue;\n      pix[0] = rp[0] + ((   50*rp[1] + 22929*rp[2]) >> 14);\n      pix[1] = rp[0] + ((-5640*rp[1] - 11751*rp[2]) >> 14);\n      pix[2] = rp[0] + ((29040*rp[1] -   101*rp[2]) >> 14);\n    } else {\n      if (unique_id < 0x80000218) rp[0] -= 512;\n      pix[0] = rp[0] + rp[2];\n      pix[2] = rp[0] + rp[1];\n      pix[1] = rp[0] + ((-778*rp[1] - (rp[2] << 11)) >> 12);\n    }\n    FORC3 rp[c] = CLIP(pix[c] * sraw_mul[c] >> 10);\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  delete buf;\n#endif\n  ljpeg_end (&jh);\n  maximum = 0x3fff;\n}\n\n#ifndef LIBRAW_LIBRARY_BUILD\nvoid CLASS adobe_copy_pixel (unsigned row, unsigned col, ushort **rp)\n{\n  int c;\n\n  if (is_raw == 2 && shot_select) (*rp)++;\n  if (raw_image) {\n    if (row < raw_height && col < raw_width)\n      RAW(row,col) = curve[**rp];\n    *rp += is_raw;\n  } else {\n    if (row < height && col < width)\n      FORC(tiff_samples)\n\timage[row*width+col][c] = curve[(*rp)[c]];\n    *rp += tiff_samples;\n  }\n  if (is_raw == 2 && shot_select) (*rp)--;\n}\n#else\nvoid CLASS adobe_copy_pixel_raw (unsigned row, unsigned col, ushort **rp)\n{\n  if (is_raw == 2 && shot_select) (*rp)++;\n  if (row < raw_height && col < raw_width)\n    RAW(row,col) = curve[**rp];\n  *rp += is_raw;\n  if (is_raw == 2 && shot_select) (*rp)--;\n}\nvoid CLASS adobe_copy_pixel_color (unsigned row, unsigned col, ushort **rp)\n{\n  int c;\n\n  if (is_raw == 2 && shot_select) (*rp)++;\n  if (row < height && col < width)\n    FORC(tiff_samples)\n      image[row*width+col][c] = curve[(*rp)[c]];\n  *rp += tiff_samples;\n  if (is_raw == 2 && shot_select) (*rp)--;\n}\n#endif\n\n\nvoid CLASS lossless_dng_load_raw()\n{\n  unsigned save, trow=0, tcol=0, jwide, jrow, jcol, row, col;\n  struct jhead jh;\n  ushort *rp;\n\n  while (trow < raw_height) {\n    save = ftell(ifp);\n    if (tile_length < INT_MAX)\n      fseek (ifp, get4(), SEEK_SET);\n    if (!ljpeg_start (&jh, 0)) break;\n    jwide = jh.wide;\n    if (filters) jwide *= jh.clrs;\n    jwide /= is_raw;\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(!data_size)\n        throw LIBRAW_EXCEPTION_IO_BADFILE;\n    LibRaw_byte_buffer *buf = ifp->make_byte_buffer(data_size);\n    LibRaw_bit_buffer bits;\n#endif\n\n#ifndef LIBRAW_LIBRARY_BUILD\n    for (row=col=jrow=0; jrow < jh.high; jrow++) {\n      rp = ljpeg_row (jrow, &jh);\n      for (jcol=0; jcol < jwide; jcol++) {\n\tadobe_copy_pixel (trow+row, tcol+col, &rp);\n\tif (++col >= tile_width || col >= raw_width)\n\t  row += 1 + (col = 0);\n      }\n    }\n#else\n    if(raw_image)\n      {\n        for (row=col=jrow=0; jrow < jh.high; jrow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n          rp = ljpeg_row_new (jrow, &jh,bits,buf);\n#else\n          rp = ljpeg_row (jrow, &jh);\n#endif\n          for (jcol=0; jcol < jwide; jcol++) {\n            adobe_copy_pixel_raw (trow+row, tcol+col, &rp);\n            if (++col >= tile_width || col >= raw_width)\n              row += 1 + (col = 0);\n          }\n        }\n      }\n    else\n      {\n        for (row=col=jrow=0; jrow < jh.high; jrow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n          rp = ljpeg_row_new (jrow, &jh,bits,buf);\n#else\n          rp = ljpeg_row (jrow, &jh);\n#endif\n          for (jcol=0; jcol < jwide; jcol++) {\n            adobe_copy_pixel_color (trow+row, tcol+col, &rp);\n            if (++col >= tile_width || col >= raw_width)\n              row += 1 + (col = 0);\n          }\n        }\n      }\n#endif\n    fseek (ifp, save+4, SEEK_SET);\n    if ((tcol += tile_width) >= raw_width)\n      trow += tile_length + (tcol = 0);\n    ljpeg_end (&jh);\n#ifdef LIBRAW_LIBRARY_BUILD\n    delete buf;\n#endif\n  }\n}\n\nvoid CLASS packed_dng_load_raw()\n{\n  ushort *pixel, *rp;\n  int row, col;\n\n  pixel = (ushort *) calloc (raw_width * tiff_samples, sizeof *pixel);\n  merror (pixel, \"packed_dng_load_raw()\");\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  int dsz= raw_height*raw_width * tiff_samples * tiff_bps/8;\n  LibRaw_byte_buffer *buf = NULL;\n  if (tiff_bps != 16)\n      {\n          buf = ifp->make_byte_buffer(dsz);\n      }\n  LibRaw_bit_buffer bits;\n#endif\n\n  for (row=0; row < raw_height; row++) {\n    if (tiff_bps == 16)\n      read_shorts (pixel, raw_width * tiff_samples);\n    else {\n#ifdef LIBRAW_LIBRARY_BUILD\n        bits.reset();\n        for (col=0; col < raw_width * tiff_samples; col++)\n            pixel[col] = bits._getbits(buf,tiff_bps,zero_after_ff);\n\n#else\n      getbits(-1);\n      for (col=0; col < raw_width * tiff_samples; col++)\n\tpixel[col] = getbits(tiff_bps);\n#endif\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n    for (rp=pixel, col=0; col < raw_width; col++)\n      adobe_copy_pixel (row, col, &rp);\n#else\n    if(raw_image)\n      for (rp=pixel, col=0; col < raw_width; col++)\n        adobe_copy_pixel_raw (row, col, &rp);\n    else\n      for (rp=pixel, col=0; col < raw_width; col++)\n        adobe_copy_pixel_color (row, col, &rp);\n#endif\n  }\n  free (pixel);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(buf)\n        delete buf;\n#endif\n}\n\nvoid CLASS pentax_load_raw()\n{\n  ushort bit[2][15], huff[4097];\n  int dep, row, col, diff, c, i;\n  ushort vpred[2][2] = {{0,0},{0,0}}, hpred[2];\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  dep = (get2() + 12) & 15;\n  fseek (ifp, 12, SEEK_CUR);\n  FORC(dep) bit[0][c] = get2();\n  FORC(dep) bit[1][c] = fgetc(ifp);\n  FORC(dep)\n    for (i=bit[0][c]; i <= ((bit[0][c]+(4096 >> bit[1][c])-1) & 4095); )\n      huff[++i] = bit[1][c] << 8 | c;\n  huff[0] = 12;\n  fseek (ifp, data_offset, SEEK_SET);\n  getbits(-1);\n  for (row=0; row < raw_height; row++)\n    for (col=0; col < raw_width; col++) {\n      diff = ljpeg_diff (huff);\n      if (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n      else\t   hpred[col & 1] += diff;\n      RAW(row,col) = hpred[col & 1];\n      if (hpred[col & 1] >> tiff_bps) derror();\n    }\n}\n\nvoid CLASS nikon_load_raw()\n{\n  static const uchar nikon_tree[][32] = {\n    { 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,\t/* 12-bit lossy */\n      5,4,3,6,2,7,1,0,8,9,11,10,12 },\n    { 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,\t/* 12-bit lossy after split */\n      0x39,0x5a,0x38,0x27,0x16,5,4,3,2,1,0,11,12,12 },\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,  /* 12-bit lossless */\n      5,4,6,3,7,2,8,1,9,0,10,11,12 },\n    { 0,1,4,3,1,1,1,1,1,2,0,0,0,0,0,0,\t/* 14-bit lossy */\n      5,6,4,7,8,3,9,2,1,0,10,11,12,13,14 },\n    { 0,1,5,1,1,1,1,1,1,1,2,0,0,0,0,0,\t/* 14-bit lossy after split */\n      8,0x5c,0x4b,0x3a,0x29,7,6,5,4,3,2,1,0,13,14 },\n    { 0,1,4,2,2,3,1,2,0,0,0,0,0,0,0,0,\t/* 14-bit lossless */\n      7,6,8,5,9,4,10,3,11,12,2,0,1,13,14 } };\n  ushort *huff, ver0, ver1, vpred[2][2], hpred[2], csize;\n  int i, min, max, step=0, tree=0, split=0, row, col, len, shl, diff;\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  ver0 = fgetc(ifp);\n  ver1 = fgetc(ifp);\n  if (ver0 == 0x49 || ver1 == 0x58)\n    fseek (ifp, 2110, SEEK_CUR);\n  if (ver0 == 0x46) tree = 2;\n  if (tiff_bps == 14) tree += 3;\n  read_shorts (vpred[0], 4);\n  max = 1 << tiff_bps & 0x7fff;\n  if ((csize = get2()) > 1)\n    step = max / (csize-1);\n  if (ver0 == 0x44 && ver1 == 0x20 && step > 0) {\n    for (i=0; i < csize; i++)\n      curve[i*step] = get2();\n    for (i=0; i < max; i++)\n      curve[i] = ( curve[i-i%step]*(step-i%step) +\n\t\t   curve[i-i%step+step]*(i%step) ) / step;\n    fseek (ifp, meta_offset+562, SEEK_SET);\n    split = get2();\n  } else if (ver0 != 0x46 && csize <= 0x4001)\n    read_shorts (curve, max=csize);\n  while (curve[max-2] == curve[max-1]) max--;\n  huff = make_decoder (nikon_tree[tree]);\n  fseek (ifp, data_offset, SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!data_size)\n      throw LIBRAW_EXCEPTION_IO_BADFILE;\n  LibRaw_byte_buffer *buf = ifp->make_byte_buffer(data_size);\n  LibRaw_bit_buffer bits;\n  bits.reset();\n#else\n  getbits(-1);\n#endif\n  for (min=row=0; row < height; row++) {\n    if (split && row == split) {\n      free (huff);\n      huff = make_decoder (nikon_tree[tree+1]);\n      max += (min = 16) << 1;\n    }\n    for (col=0; col < raw_width; col++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n        i = bits._gethuff(buf,*huff,huff+1,zero_after_ff);\n#else\n      i = gethuff(huff);\n#endif\n      len = i & 15;\n      shl = i >> 4;\n#ifdef LIBRAW_LIBRARY_BUILD\n      diff = ((bits._getbits(buf,len-shl,zero_after_ff) << 1) + 1) << shl >> 1;\n#else\n      diff = ((getbits(len-shl) << 1) + 1) << shl >> 1;\n#endif\n      if ((diff & (1 << (len-1))) == 0)\n\tdiff -= (1 << len) - !shl;\n      if (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n      else\t   hpred[col & 1] += diff;\n      if ((ushort)(hpred[col & 1] + min) >= max) derror();\n      RAW(row,col) = curve[LIM((short)hpred[col & 1],0,0x3fff)];\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  delete buf;\n#endif\n  free (huff);\n}\n\n/*\n   Returns 1 for a Coolpix 995, 0 for anything else.\n */\nint CLASS nikon_e995()\n{\n  int i, histo[256];\n  const uchar often[] = { 0x00, 0x55, 0xaa, 0xff };\n\n  memset (histo, 0, sizeof histo);\n  fseek (ifp, -2000, SEEK_END);\n  for (i=0; i < 2000; i++)\n    histo[fgetc(ifp)]++;\n  for (i=0; i < 4; i++)\n    if (histo[often[i]] < 200)\n      return 0;\n  return 1;\n}\n\n/*\n   Returns 1 for a Coolpix 2100, 0 for anything else.\n */\nint CLASS nikon_e2100()\n{\n  uchar t[12];\n  int i;\n\n  fseek (ifp, 0, SEEK_SET);\n  for (i=0; i < 1024; i++) {\n    fread (t, 1, 12, ifp);\n    if (((t[2] & t[4] & t[7] & t[9]) >> 4\n\t& t[1] & t[6] & t[8] & t[11] & 3) != 3)\n      return 0;\n  }\n  return 1;\n}\n\nvoid CLASS nikon_3700()\n{\n  int bits, i;\n  uchar dp[24];\n  static const struct {\n    int bits;\n    char t_make[12], t_model[15];\n  } table[] = {\n    { 0x00, \"PENTAX\",  \"Optio 33WR\" },\n    { 0x03, \"NIKON\",   \"E3200\" },\n    { 0x32, \"NIKON\",   \"E3700\" },\n    { 0x33, \"OLYMPUS\", \"C740UZ\" } };\n\n  fseek (ifp, 3072, SEEK_SET);\n  fread (dp, 1, 24, ifp);\n  bits = (dp[8] & 3) << 4 | (dp[20] & 3);\n  for (i=0; i < sizeof table / sizeof *table; i++)\n    if (bits == table[i].bits) {\n      strcpy (make,  table[i].t_make );\n      strcpy (model, table[i].t_model);\n    }\n}\n\n/*\n   Separates a Minolta DiMAGE Z2 from a Nikon E4300.\n */\nint CLASS minolta_z2()\n{\n  int i, nz;\n  char tail[424];\n\n  fseek (ifp, -sizeof tail, SEEK_END);\n  fread (tail, 1, sizeof tail, ifp);\n  for (nz=i=0; i < sizeof tail; i++)\n    if (tail[i]) nz++;\n  return nz > 20;\n}\n#line 1589 \"dcraw/dcraw.c\"\nvoid CLASS ppm_thumb()\n{\n  char *thumb;\n  thumb_length = thumb_width*thumb_height*3;\n  thumb = (char *) malloc (thumb_length);\n  merror (thumb, \"ppm_thumb()\");\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  fread  (thumb, 1, thumb_length, ifp);\n  fwrite (thumb, 1, thumb_length, ofp);\n  free (thumb);\n}\n\nvoid CLASS ppm16_thumb()\n{\n  int i;\n  char *thumb;\n  thumb_length = thumb_width*thumb_height*3;\n  thumb = (char *) calloc (thumb_length,2);\n  merror (thumb, \"ppm16_thumb()\");\n  read_shorts ((ushort *) thumb, thumb_length);\n  for (i=0; i < thumb_length; i++)\n    thumb[i] = ((ushort *) thumb)[i] >> 8;\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  fwrite (thumb, 1, thumb_length, ofp);\n  free (thumb);\n}\n\nvoid CLASS layer_thumb()\n{\n  int i, c;\n  char *thumb, map[][4] = { \"012\",\"102\" };\n\n  colors = thumb_misc >> 5 & 7;\n  thumb_length = thumb_width*thumb_height;\n  thumb = (char *) calloc (colors, thumb_length);\n  merror (thumb, \"layer_thumb()\");\n  fprintf (ofp, \"P%d\\n%d %d\\n255\\n\",\n\t5 + (colors >> 1), thumb_width, thumb_height);\n  fread (thumb, thumb_length, colors, ifp);\n  for (i=0; i < thumb_length; i++)\n    FORCC putc (thumb[i+thumb_length*(map[thumb_misc >> 8][c]-'0')], ofp);\n  free (thumb);\n}\n\nvoid CLASS rollei_thumb()\n{\n  unsigned i;\n  ushort *thumb;\n\n  thumb_length = thumb_width * thumb_height;\n  thumb = (ushort *) calloc (thumb_length, 2);\n  merror (thumb, \"rollei_thumb()\");\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  read_shorts (thumb, thumb_length);\n  for (i=0; i < thumb_length; i++) {\n    putc (thumb[i] << 3, ofp);\n    putc (thumb[i] >> 5  << 2, ofp);\n    putc (thumb[i] >> 11 << 3, ofp);\n  }\n  free (thumb);\n}\n\nvoid CLASS rollei_load_raw()\n{\n  uchar pixel[10];\n  unsigned iten=0, isix, i, buffer=0, todo[16];\n\n  isix = raw_width * raw_height * 5 / 8;\n  while (fread (pixel, 1, 10, ifp) == 10) {\n    for (i=0; i < 10; i+=2) {\n      todo[i]   = iten++;\n      todo[i+1] = pixel[i] << 8 | pixel[i+1];\n      buffer    = pixel[i] >> 2 | buffer << 6;\n    }\n    for (   ; i < 16; i+=2) {\n      todo[i]   = isix++;\n      todo[i+1] = buffer >> (14-i)*5;\n    }\n    for (i=0; i < 16; i+=2)\n      raw_image[todo[i]] = (todo[i+1] & 0x3ff);\n  }\n  maximum = 0x3ff;\n}\n\nint CLASS raw (unsigned row, unsigned col)\n{\n  return (row < raw_height && col < raw_width) ? RAW(row,col) : 0;\n}\n\nvoid CLASS phase_one_flat_field (int is_float, int nc)\n{\n  ushort head[8];\n  unsigned wide, y, x, c, rend, cend, row, col;\n  float *mrow, num, mult[4];\n\n  read_shorts (head, 8);\n  wide = head[2] / head[4];\n  mrow = (float *) calloc (nc*wide, sizeof *mrow);\n  merror (mrow, \"phase_one_flat_field()\");\n  for (y=0; y < head[3] / head[5]; y++) {\n    for (x=0; x < wide; x++)\n      for (c=0; c < nc; c+=2) {\n\tnum = is_float ? getreal(11) : get2()/32768.0;\n\tif (y==0) mrow[c*wide+x] = num;\n\telse mrow[(c+1)*wide+x] = (num - mrow[c*wide+x]) / head[5];\n      }\n    if (y==0) continue;\n    rend = head[1] + y*head[5];\n    for (row = rend-head[5]; row < raw_height && row < rend; row++) {\n      for (x=1; x < wide; x++) {\n\tfor (c=0; c < nc; c+=2) {\n\t  mult[c] = mrow[c*wide+x-1];\n\t  mult[c+1] = (mrow[c*wide+x] - mult[c]) / head[4];\n\t}\n\tcend = head[0] + x*head[4];\n\tfor (col = cend-head[4]; col < raw_width && col < cend; col++) {\n\t  c = nc > 2 ? FC(row-top_margin,col-left_margin) : 0;\n\t  if (!(c & 1)) {\n\t    c = RAW(row,col) * mult[c];\n\t    RAW(row,col) = LIM(c,0,65535);\n\t  }\n\t  for (c=0; c < nc; c+=2)\n\t    mult[c] += mult[c+1];\n\t}\n      }\n      for (x=0; x < wide; x++)\n\tfor (c=0; c < nc; c+=2)\n\t  mrow[c*wide+x] += mrow[(c+1)*wide+x];\n    }\n  }\n  free (mrow);\n}\n\nvoid CLASS phase_one_correct()\n{\n  unsigned entries, tag, data, save, col, row, type;\n  int len, i, j, k, cip, val[4], dev[4], sum, max;\n  int head[9], diff, mindiff=INT_MAX, off_412=0;\n  static const signed char dir[12][2] =\n    { {-1,-1}, {-1,1}, {1,-1}, {1,1}, {-2,0}, {0,-2}, {0,2}, {2,0},\n      {-2,-2}, {-2,2}, {2,-2}, {2,2} };\n  float poly[8], num, cfrac, frac, mult[2], *yval[2];\n  ushort *xval[2];\n\n  if (half_size || !meta_length) return;\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Phase One correction...\\n\"));\n#endif\n  fseek (ifp, meta_offset, SEEK_SET);\n  order = get2();\n  fseek (ifp, 6, SEEK_CUR);\n  fseek (ifp, meta_offset+get4(), SEEK_SET);\n  entries = get4();  get4();\n  while (entries--) {\n    tag  = get4();\n    len  = get4();\n    data = get4();\n    save = ftell(ifp);\n    fseek (ifp, meta_offset+data, SEEK_SET);\n    if (tag == 0x419) {\t\t\t\t/* Polynomial curve */\n      for (get4(), i=0; i < 8; i++)\n\tpoly[i] = getreal(11);\n      poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;\n      for (i=0; i < 0x10000; i++) {\n\tnum = (poly[5]*i + poly[3])*i + poly[1];\n\tcurve[i] = LIM(num,0,65535);\n      } goto apply;\t\t\t\t/* apply to right half */\n    } else if (tag == 0x41a) {\t\t\t/* Polynomial curve */\n      for (i=0; i < 4; i++)\n\tpoly[i] = getreal(11);\n      for (i=0; i < 0x10000; i++) {\n\tfor (num=0, j=4; j--; )\n\t  num = num * i + poly[j];\n\tcurve[i] = LIM(num+i,0,65535);\n      } apply:\t\t\t\t\t/* apply to whole image */\n      for (row=0; row < raw_height; row++)\n\tfor (col = (tag & 1)*ph1.split_col; col < raw_width; col++)\n\t  RAW(row,col) = curve[RAW(row,col)];\n    } else if (tag == 0x400) {\t\t\t/* Sensor defects */\n      while ((len -= 8) >= 0) {\n\tcol  = get2();\n\trow  = get2();\n\ttype = get2(); get2();\n\tif (col >= raw_width) continue;\n\tif (type == 131)\t\t\t/* Bad column */\n\t  for (row=0; row < raw_height; row++)\n\t    if (FC(row-top_margin,col-left_margin) == 1) {\n\t      for (sum=i=0; i < 4; i++)\n\t\tsum += val[i] = raw (row+dir[i][0], col+dir[i][1]);\n\t      for (max=i=0; i < 4; i++) {\n\t\tdev[i] = abs((val[i] << 2) - sum);\n\t\tif (dev[max] < dev[i]) max = i;\n\t      }\n\t      RAW(row,col) = (sum - val[max])/3.0 + 0.5;\n\t    } else {\n\t      for (sum=0, i=8; i < 12; i++)\n\t\tsum += raw (row+dir[i][0], col+dir[i][1]);\n\t      RAW(row,col) = 0.5 + sum * 0.0732233 +\n\t\t(raw(row,col-2) + raw(row,col+2)) * 0.3535534;\n\t    }\n\telse if (type == 129) {\t\t\t/* Bad pixel */\n\t  if (row >= raw_height) continue;\n\t  j = (FC(row-top_margin,col-left_margin) != 1) * 4;\n\t  for (sum=0, i=j; i < j+8; i++)\n\t    sum += raw (row+dir[i][0], col+dir[i][1]);\n\t  RAW(row,col) = (sum + 4) >> 3;\n\t}\n      }\n    } else if (tag == 0x401) {\t\t\t/* All-color flat fields */\n      phase_one_flat_field (1, 2);\n    } else if (tag == 0x416 || tag == 0x410) {\n      phase_one_flat_field (0, 2);\n    } else if (tag == 0x40b) {\t\t\t/* Red+blue flat field */\n      phase_one_flat_field (0, 4);\n    } else if (tag == 0x412) {\n      fseek (ifp, 36, SEEK_CUR);\n      diff = abs (get2() - ph1.tag_21a);\n      if (mindiff > diff) {\n\tmindiff = diff;\n\toff_412 = ftell(ifp) - 38;\n      }\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n  if (off_412) {\n    fseek (ifp, off_412, SEEK_SET);\n    for (i=0; i < 9; i++) head[i] = get4() & 0x7fff;\n    yval[0] = (float *) calloc (head[1]*head[3] + head[2]*head[4], 6);\n    merror (yval[0], \"phase_one_correct()\");\n    yval[1] = (float  *) (yval[0] + head[1]*head[3]);\n    xval[0] = (ushort *) (yval[1] + head[2]*head[4]);\n    xval[1] = (ushort *) (xval[0] + head[1]*head[3]);\n    get2();\n    for (i=0; i < 2; i++)\n      for (j=0; j < head[i+1]*head[i+3]; j++)\n\tyval[i][j] = getreal(11);\n    for (i=0; i < 2; i++)\n      for (j=0; j < head[i+1]*head[i+3]; j++)\n\txval[i][j] = get2();\n    for (row=0; row < raw_height; row++)\n      for (col=0; col < raw_width; col++) {\n\tcfrac = (float) col * head[3] / raw_width;\n\tcfrac -= cip = cfrac;\n\tnum = RAW(row,col) * 0.5;\n\tfor (i=cip; i < cip+2; i++) {\n\t  for (k=j=0; j < head[1]; j++)\n\t    if (num < xval[0][k = head[1]*i+j]) break;\n\t  frac = (j == 0 || j == head[1]) ? 0 :\n\t\t(xval[0][k] - num) / (xval[0][k] - xval[0][k-1]);\n\t  mult[i-cip] = yval[0][k-1] * frac + yval[0][k] * (1-frac);\n\t}\n\ti = ((mult[0] * (1-cfrac) + mult[1] * cfrac) * row + num) * 2;\n\tRAW(row,col) = LIM(i,0,65535);\n      }\n    free (yval[0]);\n  }\n}\n\nvoid CLASS phase_one_load_raw()\n{\n  int a, b, i;\n  ushort akey, bkey, t_mask;\n\n  fseek (ifp, ph1.key_off, SEEK_SET);\n  akey = get2();\n  bkey = get2();\n  t_mask = ph1.format == 1 ? 0x5555:0x1354;\n  fseek (ifp, data_offset, SEEK_SET);\n  read_shorts (raw_image, raw_width*raw_height);\n  if (ph1.format)\n    for (i=0; i < raw_width*raw_height; i+=2) {\n      a = raw_image[i+0] ^ akey;\n      b = raw_image[i+1] ^ bkey;\n      raw_image[i+0] = (a & t_mask) | (b & ~t_mask);\n      raw_image[i+1] = (b & t_mask) | (a & ~t_mask);\n    }\n}\n\nunsigned CLASS ph1_bithuff (int nbits, ushort *huff)\n{\n#ifndef LIBRAW_NOTHREADS\n#define bitbuf tls->ph1_bits.bitbuf\n#define vbits  tls->ph1_bits.vbits    \n#else\n  static UINT64 bitbuf=0;\n  static int vbits=0;\n#endif\n  unsigned c;\n\n  if (nbits == -1)\n    return bitbuf = vbits = 0;\n  if (nbits == 0) return 0;\n  if (vbits < nbits) {\n    bitbuf = bitbuf << 32 | get4();\n    vbits += 32;\n  }\n  c = bitbuf << (64-vbits) >> (64-nbits);\n  if (huff) {\n    vbits -= huff[c] >> 8;\n    return (uchar) huff[c];\n  }\n  vbits -= nbits;\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#endif\n}\n#define ph1_bits(n) ph1_bithuff(n,0)\n#define ph1_huff(h) ph1_bithuff(*h,h+1)\n\nvoid CLASS phase_one_load_raw_c()\n{\n  static const int length[] = { 8,7,6,9,11,10,5,12,14,13 };\n  int *offset, len[2], pred[2], row, col, i, j;\n  ushort *pixel;\n  short (*t_black)[2];\n\n  pixel = (ushort *) calloc (raw_width + raw_height*4, 2);\n  merror (pixel, \"phase_one_load_raw_c()\");\n  offset = (int *) (pixel + raw_width);\n  fseek (ifp, strip_offset, SEEK_SET);\n  for (row=0; row < raw_height; row++)\n    offset[row] = get4();\n  t_black = (short (*)[2]) offset + raw_height;\n  fseek (ifp, ph1.black_off, SEEK_SET);\n  if (ph1.black_off)\n      {\n          read_shorts ((ushort *) t_black[0], raw_height*2);\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.rawdata.ph1_black = (short (*)[2])calloc(raw_height*2,sizeof(short));\n          merror (imgdata.rawdata.ph1_black, \"phase_one_load_raw_c()\");\n          memmove(imgdata.rawdata.ph1_black,(short *) t_black[0],raw_height*2*sizeof(short));\n#endif\n      }\n  for (i=0; i < 256; i++)\n    curve[i] = i*i / 3.969 + 0.5;\n  for (row=0; row < raw_height; row++) {\n    fseek (ifp, data_offset + offset[row], SEEK_SET);\n    ph1_bits(-1);\n    pred[0] = pred[1] = 0;\n    for (col=0; col < raw_width; col++) {\n      if (col >= (raw_width & -8))\n\tlen[0] = len[1] = 14;\n      else if ((col & 7) == 0)\n\tfor (i=0; i < 2; i++) {\n\t  for (j=0; j < 5 && !ph1_bits(1); j++);\n\t  if (j--) len[i] = length[j*2 + ph1_bits(1)];\n\t}\n      if ((i = len[col & 1]) == 14)\n\tpixel[col] = pred[col & 1] = ph1_bits(16);\n      else\n\tpixel[col] = pred[col & 1] += ph1_bits(i) + 1 - (1 << (i - 1));\n      if (pred[col & 1] >> 16) derror();\n      if (ph1.format == 5 && pixel[col] < 256)\n\tpixel[col] = curve[pixel[col]];\n    }\n    for (col=0; col < raw_width; col++) {\n#ifndef LIBRAW_LIBRARY_BUILD\n      i = (pixel[col] << 2) - ph1.t_black + t_black[row][col >= ph1.split_col];\n      if (i > 0) RAW(row,col) = i;\n#else\n      RAW(row,col) = pixel[col] << 2;\n#endif\n    }\n  }\n  free (pixel);\n  maximum = 0xfffc - ph1.t_black;\n}\n\nvoid CLASS hasselblad_load_raw()\n{\n  struct jhead jh;\n  int row, col, pred[2], len[2], diff, c;\n\n  if (!ljpeg_start (&jh, 0)) return;\n  order = 0x4949;\n  ph1_bits(-1);\n  for (row=0; row < raw_height; row++) {\n    pred[0] = pred[1] = 0x8000 + load_flags;\n    for (col=0; col < raw_width; col+=2) {\n      FORC(2) len[c] = ph1_huff(jh.huff[0]);\n      FORC(2) {\n\tdiff = ph1_bits(len[c]);\n\tif ((diff & (1 << (len[c]-1))) == 0)\n\t  diff -= (1 << len[c]) - 1;\n\tif (diff == 65535) diff = -32768;\n\tRAW(row,col+c) = pred[c] += diff;\n      }\n    }\n  }\n  ljpeg_end (&jh);\n  maximum = 0xffff;\n}\n\nvoid CLASS leaf_hdr_load_raw()\n{\n  ushort *pixel=0;\n  unsigned tile=0, r, c, row, col;\n\n  if (!filters) {\n    pixel = (ushort *) calloc (raw_width, sizeof *pixel);\n    merror (pixel, \"leaf_hdr_load_raw()\");\n  }\n  FORC(tiff_samples)\n    for (r=0; r < raw_height; r++) {\n      if (r % tile_length == 0) {\n\tfseek (ifp, data_offset + 4*tile++, SEEK_SET);\n\tfseek (ifp, get4(), SEEK_SET);\n      }\n      if (filters && c != shot_select) continue;\n      if (filters) pixel = raw_image + r*raw_width;\n      read_shorts (pixel, raw_width);\n      if (!filters && (row = r - top_margin) < height)\n\tfor (col=0; col < width; col++)\n\t  image[row*width+col][c] = pixel[col+left_margin];\n    }\n  if (!filters) {\n    maximum = 0xffff;\n    raw_color = 1;\n    free (pixel);\n  }\n}\n\nvoid CLASS unpacked_load_raw()\n{\n  int row, col, bits=0;\n\n  while (1 << ++bits < maximum);\n  read_shorts (raw_image, raw_width*raw_height);\n  for (row=0; row < raw_height; row++)\n    for (col=0; col < raw_width; col++)\n      if ((RAW(row,col) >>= load_flags) >> bits\n\t&& (unsigned) (row-top_margin) < height\n\t&& (unsigned) (col-left_margin) < width) derror();\n}\n\nvoid CLASS sinar_4shot_load_raw()\n{\n  ushort *pixel;\n  unsigned shot, row, col, r, c;\n\n  if ((shot = shot_select) || half_size) {\n    if (shot) shot--;\n    if (shot > 3) shot = 3;\n    fseek (ifp, data_offset + shot*4, SEEK_SET);\n    fseek (ifp, get4(), SEEK_SET);\n    unpacked_load_raw();\n    return;\n  }\n#ifndef LIBRAW_LIBRARY_BUILD\n  free (raw_image);\n  raw_image = 0;\n  free (image);\n  image = (ushort (*)[4])\n\tcalloc ((iheight=height)*(iwidth=width), sizeof *image);\n  merror (image, \"sinar_4shot_load_raw()\");\n#endif\n  pixel = (ushort *) calloc (raw_width, sizeof *pixel);\n  merror (pixel, \"sinar_4shot_load_raw()\");\n  for (shot=0; shot < 4; shot++) {\n    fseek (ifp, data_offset + shot*4, SEEK_SET);\n    fseek (ifp, get4(), SEEK_SET);\n    for (row=0; row < raw_height; row++) {\n      read_shorts (pixel, raw_width);\n      if ((r = row-top_margin - (shot >> 1 & 1)) >= height) continue;\n      for (col=0; col < raw_width; col++) {\n\tif ((c = col-left_margin - (shot & 1)) >= width) continue;\n\timage[r*width+c][FC(row,col)] = pixel[col];\n      }\n    }\n  }\n  free (pixel);\n  shrink = filters = 0;\n}\n\nvoid CLASS imacon_full_load_raw()\n{\n  int row, col;\n\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      read_shorts (image[row*width+col], 3);\n}\n\nvoid CLASS packed_load_raw()\n{\n  int vbits=0, bwide, pwide, rbits, bite, half, irow, row, col, val, i;\n  UINT64 bitbuf=0;\n\n  if (raw_width * 8 >= width * tiff_bps)\t/* Is raw_width in bytes? */\n       pwide = (bwide = raw_width) * 8 / tiff_bps;\n  else bwide = (pwide = raw_width) * tiff_bps / 8;\n  rbits = bwide * 8 - pwide * tiff_bps;\n  if (load_flags & 1) bwide = bwide * 16 / 15;\n  bite = 8 + (load_flags & 24);\n  half = (raw_height+1) >> 1;\n  for (irow=0; irow < raw_height; irow++) {\n    row = irow;\n    if (load_flags & 2 &&\n\t(row = irow % half * 2 + irow / half) == 1 &&\n\tload_flags & 4) {\n      if (vbits=0, tiff_compress)\n\tfseek (ifp, data_offset - (-half*bwide & -2048), SEEK_SET);\n      else {\n\tfseek (ifp, 0, SEEK_END);\n\tfseek (ifp, ftell(ifp) >> 3 << 2, SEEK_SET);\n      }\n    }\n    for (col=0; col < pwide; col++) {\n      for (vbits -= tiff_bps; vbits < 0; vbits += bite) {\n\tbitbuf <<= bite;\n\tfor (i=0; i < bite; i+=8)\n\t  bitbuf |= (unsigned) (fgetc(ifp) << i);\n      }\n      val = bitbuf << (64-tiff_bps-vbits) >> (64-tiff_bps);\n      RAW(row,col ^ (load_flags >> 6)) = val;\n      if (load_flags & 1 && (col % 10) == 9 &&\n\tfgetc(ifp) && col < width+left_margin) derror();\n    }\n    vbits -= rbits;\n  }\n}\n\nvoid CLASS nokia_load_raw()\n{\n  uchar  *data,  *dp;\n  int rev, dwide, row, col, c;\n\n  rev = 3 * (order == 0x4949);\n  dwide = (raw_width * 5 +1) / 4;\n  data = (uchar *) malloc (dwide*2);\n  merror (data, \"nokia_load_raw()\");\n  for (row=0; row < raw_height; row++) {\n    if (fread (data+dwide, 1, dwide, ifp) < dwide) derror();\n    FORC(dwide) data[c] = data[dwide+(c ^ rev)];\n    for (dp=data, col=0; col < raw_width; dp+=5, col+=4)\n      FORC4 RAW(row,col+c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n  }\n  free (data);\n  maximum = 0x3ff;\n}\n\nunsigned CLASS pana_bits (int nbits)\n{\n#ifndef LIBRAW_NOTHREADS\n#define buf tls->pana_bits.buf\n#define vbits tls->pana_bits.vbits   \n#else\n  static uchar buf[0x4000];\n  static int vbits;\n#endif\n  int byte;\n\n  if (!nbits) return vbits=0;\n  if (!vbits) {\n    fread (buf+load_flags, 1, 0x4000-load_flags, ifp);\n    fread (buf, 1, load_flags, ifp);\n  }\n  vbits = (vbits - nbits) & 0x1ffff;\n  byte = vbits >> 3 ^ 0x3ff0;\n  return (buf[byte] | buf[byte+1] << 8) >> (vbits & 7) & ~(-1 << nbits);\n#ifndef LIBRAW_NOTHREADS\n#undef buf\n#undef vbits\n#endif\n}\n\nvoid CLASS panasonic_load_raw()\n{\n  int row, col, i, j, sh=0, pred[2], nonz[2];\n\n  pana_bits(0);\n  for (row=0; row < height; row++)\n    for (col=0; col < raw_width; col++) {\n      if ((i = col % 14) == 0)\n\tpred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n      if (i % 3 == 2) sh = 4 >> (3 - pana_bits(2));\n      if (nonz[i & 1]) {\n\tif ((j = pana_bits(8))) {\n\t  if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)\n\t       pred[i & 1] &= ~(-1 << sh);\n\t  pred[i & 1] += j << sh;\n\t}\n      } else if ((nonz[i & 1] = pana_bits(8)) || i > 11)\n\tpred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);\n      if ((RAW(row,col) = pred[col & 1]) > 4098 && col < width) derror();\n    }\n}\n\nvoid CLASS olympus_load_raw()\n{\n  ushort huff[4096];\n  int row, col, nbits, sign, low, high, i, c, w, n, nw;\n  int acarry[2][3], *carry, pred, diff;\n\n  huff[n=0] = 0xc0c;\n  for (i=12; i--; )\n    FORC(2048 >> i) huff[++n] = (i+1) << 8 | i;\n  fseek (ifp, 7, SEEK_CUR);\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!data_size)\n      throw LIBRAW_EXCEPTION_IO_BADFILE;\n  LibRaw_byte_buffer *buf = ifp->make_byte_buffer(data_size);\n  LibRaw_bit_buffer bits;\n  bits.reset();\n#else\n  getbits(-1);\n#endif\n  for (row=0; row < height; row++) {\n    memset (acarry, 0, sizeof acarry);\n    for (col=0; col < raw_width; col++) {\n      carry = acarry[col & 1];\n      i = 2 * (carry[2] < 3);\n      for (nbits=2+i; (ushort) carry[0] >> (nbits+i); nbits++);\n#ifdef LIBRAW_LIBRARY_BUILD\n      low = (sign = bits._getbits(buf,3,zero_after_ff)) & 3;\n      sign = sign << 29 >> 31;\n      if ((high = bits._gethuff(buf,12,huff,zero_after_ff)) == 12)\n          high = bits._getbits(buf,16-nbits,zero_after_ff) >> 1;\n      carry[0] = (high << nbits) | bits._getbits(buf,nbits,zero_after_ff);\n#else\n      low = (sign = getbits(3)) & 3;\n      sign = sign << 29 >> 31;\n      if ((high = getbithuff(12,huff)) == 12)\n\thigh = getbits(16-nbits) >> 1;\n      carry[0] = (high << nbits) | getbits(nbits);\n#endif\n      diff = (carry[0] ^ sign) + carry[1];\n      carry[1] = (diff*3 + carry[1]) >> 5;\n      carry[2] = carry[0] > 16 ? 0 : carry[2]+1;\n      if (col >= width) continue;\n      if (row < 2 && col < 2) pred = 0;\n      else if (row < 2) pred = RAW(row,col-2);\n      else if (col < 2) pred = RAW(row-2,col);\n      else {\n\tw  = RAW(row,col-2);\n\tn  = RAW(row-2,col);\n\tnw = RAW(row-2,col-2);\n\tif ((w < nw && nw < n) || (n < nw && nw < w)) {\n\t  if (ABS(w-nw) > 32 || ABS(n-nw) > 32)\n\t    pred = w + n - nw;\n\t  else pred = (w + n) >> 1;\n\t} else pred = ABS(w-nw) > ABS(n-nw) ? w : n;\n      }\n      if ((RAW(row,col) = pred + ((diff << 2) | low)) >> 12) derror();\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  delete buf;\n#endif\n}\n\nvoid CLASS minolta_rd175_load_raw()\n{\n  uchar pixel[768];\n  unsigned irow, box, row, col;\n\n  for (irow=0; irow < 1481; irow++) {\n    if (fread (pixel, 1, 768, ifp) < 768) derror();\n    box = irow / 82;\n    row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box-12)*2);\n    switch (irow) {\n      case 1477: case 1479: continue;\n      case 1476: row = 984; break;\n      case 1480: row = 985; break;\n      case 1478: row = 985; box = 1;\n    }\n    if ((box < 12) && (box & 1)) {\n      for (col=0; col < 1533; col++, row ^= 1)\n\tif (col != 1) RAW(row,col) = (col+1) & 2 ?\n\t\t   pixel[col/2-1] + pixel[col/2+1] : pixel[col/2] << 1;\n      RAW(row,1)    = pixel[1]   << 1;\n      RAW(row,1533) = pixel[765] << 1;\n    } else\n      for (col=row & 1; col < 1534; col+=2)\n\tRAW(row,col) = pixel[col/2] << 1;\n  }\n  maximum = 0xff << 1;\n}\n\nvoid CLASS quicktake_100_load_raw()\n{\n  uchar pixel[484][644];\n  static const short gstep[16] =\n  { -89,-60,-44,-32,-22,-15,-8,-2,2,8,15,22,32,44,60,89 };\n  static const short rstep[6][4] =\n  { {  -3,-1,1,3  }, {  -5,-1,1,5  }, {  -8,-2,2,8  },\n    { -13,-3,3,13 }, { -19,-4,4,19 }, { -28,-6,6,28 } };\n  static const short t_curve[256] =\n  { 0,1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,\n    28,29,30,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,53,\n    54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,74,75,76,77,78,\n    79,80,81,82,83,84,86,88,90,92,94,97,99,101,103,105,107,110,112,114,116,\n    118,120,123,125,127,129,131,134,136,138,140,142,144,147,149,151,153,155,\n    158,160,162,164,166,168,171,173,175,177,179,181,184,186,188,190,192,195,\n    197,199,201,203,205,208,210,212,214,216,218,221,223,226,230,235,239,244,\n    248,252,257,261,265,270,274,278,283,287,291,296,300,305,309,313,318,322,\n    326,331,335,339,344,348,352,357,361,365,370,374,379,383,387,392,396,400,\n    405,409,413,418,422,426,431,435,440,444,448,453,457,461,466,470,474,479,\n    483,487,492,496,500,508,519,531,542,553,564,575,587,598,609,620,631,643,\n    654,665,676,687,698,710,721,732,743,754,766,777,788,799,810,822,833,844,\n    855,866,878,889,900,911,922,933,945,956,967,978,989,1001,1012,1023 };\n  int rb, row, col, sharp, val=0;\n\n  getbits(-1);\n  memset (pixel, 0x80, sizeof pixel);\n  for (row=2; row < height+2; row++) {\n    for (col=2+(row & 1); col < width+2; col+=2) {\n      val = ((pixel[row-1][col-1] + 2*pixel[row-1][col+1] +\n\t\tpixel[row][col-2]) >> 2) + gstep[getbits(4)];\n      pixel[row][col] = val = LIM(val,0,255);\n      if (col < 4)\n\tpixel[row][col-2] = pixel[row+1][~row & 1] = val;\n      if (row == 2)\n\tpixel[row-1][col+1] = pixel[row-1][col+3] = val;\n    }\n    pixel[row][col] = val;\n  }\n  for (rb=0; rb < 2; rb++)\n    for (row=2+rb; row < height+2; row+=2)\n      for (col=3-(row & 1); col < width+2; col+=2) {\n\tif (row < 4 || col < 4) sharp = 2;\n\telse {\n\t  val = ABS(pixel[row-2][col] - pixel[row][col-2])\n\t      + ABS(pixel[row-2][col] - pixel[row-2][col-2])\n\t      + ABS(pixel[row][col-2] - pixel[row-2][col-2]);\n\t  sharp = val <  4 ? 0 : val <  8 ? 1 : val < 16 ? 2 :\n\t\t  val < 32 ? 3 : val < 48 ? 4 : 5;\n\t}\n\tval = ((pixel[row-2][col] + pixel[row][col-2]) >> 1)\n\t      + rstep[sharp][getbits(2)];\n\tpixel[row][col] = val = LIM(val,0,255);\n\tif (row < 4) pixel[row-2][col+2] = val;\n\tif (col < 4) pixel[row+2][col-2] = val;\n      }\n  for (row=2; row < height+2; row++)\n    for (col=3-(row & 1); col < width+2; col+=2) {\n      val = ((pixel[row][col-1] + (pixel[row][col] << 2) +\n\t      pixel[row][col+1]) >> 1) - 0x100;\n      pixel[row][col] = LIM(val,0,255);\n    }\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      RAW(row,col) = t_curve[pixel[row+2][col+2]];\n  maximum = 0x3ff;\n}\n\n#define radc_token(tree) ((signed char) getbithuff(8,huff[tree]))\n\n#define FORYX for (y=1; y < 3; y++) for (x=col+1; x >= col; x--)\n\n#define PREDICTOR (c ? (buf[c][y-1][x] + buf[c][y][x+1]) / 2 \\\n: (buf[c][y-1][x+1] + 2*buf[c][y-1][x] + buf[c][y][x+1]) / 4)\n\n#ifdef __GNUC__\n# if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)\n# pragma GCC optimize(\"no-aggressive-loop-optimizations\")\n# endif\n#endif\n\nvoid CLASS kodak_radc_load_raw()\n{\n  static const char src[] = {\n    1,1, 2,3, 3,4, 4,2, 5,7, 6,5, 7,6, 7,8,\n    1,0, 2,1, 3,3, 4,4, 5,2, 6,7, 7,6, 8,5, 8,8,\n    2,1, 2,3, 3,0, 3,2, 3,4, 4,6, 5,5, 6,7, 6,8,\n    2,0, 2,1, 2,3, 3,2, 4,4, 5,6, 6,7, 7,5, 7,8,\n    2,1, 2,4, 3,0, 3,2, 3,3, 4,7, 5,5, 6,6, 6,8,\n    2,3, 3,1, 3,2, 3,4, 3,5, 3,6, 4,7, 5,0, 5,8,\n    2,3, 2,6, 3,0, 3,1, 4,4, 4,5, 4,7, 5,2, 5,8,\n    2,4, 2,7, 3,3, 3,6, 4,1, 4,2, 4,5, 5,0, 5,8,\n    2,6, 3,1, 3,3, 3,5, 3,7, 3,8, 4,0, 5,2, 5,4,\n    2,0, 2,1, 3,2, 3,3, 4,4, 4,5, 5,6, 5,7, 4,8,\n    1,0, 2,2, 2,-2,\n    1,-3, 1,3,\n    2,-17, 2,-5, 2,5, 2,17,\n    2,-7, 2,2, 2,9, 2,18,\n    2,-18, 2,-9, 2,-2, 2,7,\n    2,-28, 2,28, 3,-49, 3,-9, 3,9, 4,49, 5,-79, 5,79,\n    2,-1, 2,13, 2,26, 3,39, 4,-16, 5,55, 6,-37, 6,76,\n    2,-26, 2,-13, 2,1, 3,-39, 4,16, 5,-55, 6,-76, 6,37\n  };\n  ushort huff[19][256];\n  int row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;\n  short last[3] = { 16,16,16 }, mul[3], buf[3][3][386];\n  static const ushort pt[] =\n    { 0,0, 1280,1344, 2320,3616, 3328,8000, 4095,16383, 65535,16383 };\n\n  for (i=2; i < 12; i+=2)\n    for (c=pt[i-2]; c <= pt[i]; c++)\n      curve[c] = (float)\n\t(c-pt[i-2]) / (pt[i]-pt[i-2]) * (pt[i+1]-pt[i-1]) + pt[i-1] + 0.5;\n  for (s=i=0; i < sizeof src; i+=2)\n    FORC(256 >> src[i])\n      huff[0][s++] = src[i] << 8 | (uchar) src[i+1];\n  s = kodak_cbpp == 243 ? 2 : 3;\n  FORC(256) huff[18][c] = (8-s) << 8 | c >> s << s | 1 << (s-1);\n  getbits(-1);\n  for (i=0; i < sizeof(buf)/sizeof(short); i++)\n    buf[0][0][i] = 2048;\n  for (row=0; row < height; row+=4) {\n    FORC3 mul[c] = getbits(6);\n    FORC3 {\n      val = ((0x1000000/last[c] + 0x7ff) >> 12) * mul[c];\n      s = val > 65564 ? 10:12;\n      x = ~(-1 << (s-1));\n      val <<= 12-s;\n      for (i=0; i < sizeof(buf[0])/sizeof(short); i++)\n\tbuf[c][0][i] = (buf[c][0][i] * val + x) >> s;\n      last[c] = mul[c];\n      for (r=0; r <= !c; r++) {\n\tbuf[c][1][width/2] = buf[c][2][width/2] = mul[c] << 7;\n\tfor (tree=1, col=width/2; col > 0; ) {\n\t  if ((tree = radc_token(tree))) {\n\t    col -= 2;\n\t    if (tree == 8)\n\t      FORYX buf[c][y][x] = (uchar) radc_token(18) * mul[c];\n\t    else\n\t      FORYX buf[c][y][x] = radc_token(tree+10) * 16 + PREDICTOR;\n\t  } else\n\t    do {\n\t      nreps = (col > 2) ? radc_token(9) + 1 : 1;\n\t      for (rep=0; rep < 8 && rep < nreps && col > 0; rep++) {\n\t\tcol -= 2;\n\t\tFORYX buf[c][y][x] = PREDICTOR;\n\t\tif (rep & 1) {\n\t\t  step = radc_token(10) << 4;\n\t\t  FORYX buf[c][y][x] += step;\n\t\t}\n\t      }\n\t    } while (nreps == 9);\n\t}\n\tfor (y=0; y < 2; y++)\n\t  for (x=0; x < width/2; x++) {\n\t    val = (buf[c][y+1][x] << 4) / mul[c];\n\t    if (val < 0) val = 0;\n\t    if (c) RAW(row+y*2+c-1,x*2+2-c) = val;\n\t    else   RAW(row+r*2+y,x*2+y) = val;\n\t  }\n\tmemcpy (buf[c][0]+!c, buf[c][2], sizeof buf[c][0]-2*!c);\n      }\n    }\n    for (y=row; y < row+4; y++)\n      for (x=0; x < width; x++)\n\tif ((x+y) & 1) {\n\t  r = x ? x-1 : x+1;\n\t  s = x+1 < width ? x+1 : x-1;\n\t  val = (RAW(y,x)-2048)*2 + (RAW(y,r)+RAW(y,s))/2;\n\t  if (val < 0) val = 0;\n\t  RAW(y,x) = val;\n\t}\n  }\n  for (i=0; i < height*width; i++)\n    raw_image[i] = curve[raw_image[i]];\n  maximum = 0x3fff;\n}\n\n#undef FORYX\n#undef PREDICTOR\n\n#ifdef NO_JPEG\nvoid CLASS kodak_jpeg_load_raw() {}\nvoid CLASS lossy_dng_load_raw() {}\n#else\n\n#ifdef LIBRAW_LIBRARY_BUILD\nvoid CLASS kodak_jpeg_load_raw() {}\n#else\n\nMETHODDEF(boolean)\nfill_input_buffer (j_decompress_ptr cinfo)\n{\n#ifndef LIBRAW_NOTHREADS\n#define jpeg_buffer tls->jpeg_buffer\n#else\n  static uchar jpeg_buffer[4096];\n#endif\n  size_t nbytes;\n\n  nbytes = fread (jpeg_buffer, 1, 4096, ifp);\n  swab (jpeg_buffer, jpeg_buffer, nbytes);\n  cinfo->src->next_input_byte = jpeg_buffer;\n  cinfo->src->bytes_in_buffer = nbytes;\n  return TRUE;\n#ifndef LIBRAW_NOTHREADS\n#undef jpeg_buffer\n#endif\n}\n\nvoid CLASS kodak_jpeg_load_raw()\n{\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  JSAMPARRAY buf;\n  JSAMPLE (*pixel)[3];\n  int row, col;\n\n  cinfo.err = jpeg_std_error (&jerr);\n  jpeg_create_decompress (&cinfo);\n  jpeg_stdio_src (&cinfo, ifp);\n  cinfo.src->fill_input_buffer = fill_input_buffer;\n  jpeg_read_header (&cinfo, TRUE);\n  jpeg_start_decompress (&cinfo);\n  if ((cinfo.output_width      != width  ) ||\n      (cinfo.output_height*2   != height ) ||\n      (cinfo.output_components != 3      )) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s: incorrect JPEG dimensions\\n\"), ifname);\n#endif\n    jpeg_destroy_decompress (&cinfo);\n#ifdef LIBRAW_LIBRARY_BUILD\n    throw LIBRAW_EXCEPTION_DECODE_JPEG;\n#else\n    longjmp (failure, 3);\n#endif\n  }\n  buf = (*cinfo.mem->alloc_sarray)\n\t\t((j_common_ptr) &cinfo, JPOOL_IMAGE, width*3, 1);\n\n  while (cinfo.output_scanline < cinfo.output_height) {\n    row = cinfo.output_scanline * 2;\n    jpeg_read_scanlines (&cinfo, buf, 1);\n    pixel = (JSAMPLE (*)[3]) buf[0];\n    for (col=0; col < width; col+=2) {\n      RAW(row+0,col+0) = pixel[col+0][1] << 1;\n      RAW(row+1,col+1) = pixel[col+1][1] << 1;\n      RAW(row+0,col+1) = pixel[col][0] + pixel[col+1][0];\n      RAW(row+1,col+0) = pixel[col][2] + pixel[col+1][2];\n    }\n  }\n  jpeg_finish_decompress (&cinfo);\n  jpeg_destroy_decompress (&cinfo);\n  maximum = 0xff << 1;\n}\n#endif\n\nvoid CLASS lossy_dng_load_raw()\n{\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  JSAMPARRAY buf;\n  JSAMPLE (*pixel)[3];\n  unsigned sorder=order, ntags, opcode, deg, i, j, c;\n  unsigned save=data_offset-4, trow=0, tcol=0, row, col;\n  ushort t_curve[3][256];\n  double coeff[9], tot;\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  order = 0x4d4d;\n  ntags = get4();\n  while (ntags--) {\n    opcode = get4(); get4(); get4();\n    if (opcode != 8)\n    { fseek (ifp, get4(), SEEK_CUR); continue; }\n    fseek (ifp, 20, SEEK_CUR);\n    if ((c = get4()) > 2) break;\n    fseek (ifp, 12, SEEK_CUR);\n    if ((deg = get4()) > 8) break;\n    for (i=0; i <= deg && i < 9; i++)\n      coeff[i] = getreal(12);\n    for (i=0; i < 256; i++) {\n      for (tot=j=0; j <= deg; j++)\n\ttot += coeff[j] * pow(i/255.0, (int)j);\n      t_curve[c][i] = tot*0xffff;\n    }\n  }\n  order = sorder;\n  cinfo.err = jpeg_std_error (&jerr);\n  jpeg_create_decompress (&cinfo);\n  while (trow < raw_height) {\n    fseek (ifp, save+=4, SEEK_SET);\n    if (tile_length < INT_MAX)\n      fseek (ifp, get4(), SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(libraw_internal_data.internal_data.input->jpeg_src(&cinfo) == -1)\n      {\n        jpeg_destroy_decompress(&cinfo);\n        throw LIBRAW_EXCEPTION_DECODE_JPEG;\n      }\n#else\n    jpeg_stdio_src (&cinfo, ifp);\n#endif\n    jpeg_read_header (&cinfo, TRUE);\n    jpeg_start_decompress (&cinfo);\n    buf = (*cinfo.mem->alloc_sarray)\n\t((j_common_ptr) &cinfo, JPOOL_IMAGE, cinfo.output_width*3, 1);\n    while (cinfo.output_scanline < cinfo.output_height &&\n\t(row = trow + cinfo.output_scanline) < height) {\n      jpeg_read_scanlines (&cinfo, buf, 1);\n      pixel = (JSAMPLE (*)[3]) buf[0];\n      for (col=0; col < cinfo.output_width && tcol+col < width; col++) {\n\tFORC3 image[row*width+tcol+col][c] = t_curve[c][pixel[col][c]];\n      }\n    }\n    jpeg_abort_decompress (&cinfo);\n    if ((tcol += tile_width) >= raw_width)\n      trow += tile_length + (tcol = 0);\n  }\n  jpeg_destroy_decompress (&cinfo);\n  maximum = 0xffff;\n}\n#endif\n\nvoid CLASS kodak_dc120_load_raw()\n{\n  static const int mul[4] = { 162, 192, 187,  92 };\n  static const int add[4] = {   0, 636, 424, 212 };\n  uchar pixel[848];\n  int row, shift, col;\n\n  for (row=0; row < height; row++) {\n    if (fread (pixel, 1, 848, ifp) < 848) derror();\n    shift = row * mul[row & 3] + add[row & 3];\n    for (col=0; col < width; col++)\n      RAW(row,col) = (ushort) pixel[(col + shift) % 848];\n  }\n  maximum = 0xff;\n}\n\nvoid CLASS eight_bit_load_raw()\n{\n  uchar *pixel;\n  unsigned row, col;\n\n  pixel = (uchar *) calloc (raw_width, sizeof *pixel);\n  merror (pixel, \"eight_bit_load_raw()\");\n  for (row=0; row < raw_height; row++) {\n    if (fread (pixel, 1, raw_width, ifp) < raw_width) derror();\n    for (col=0; col < raw_width; col++)\n      RAW(row,col) = curve[pixel[col]];\n  }\n  free (pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_yrgb_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *) calloc (raw_width, 3*sizeof *pixel);\n  merror (pixel, \"kodak_yrgb_load_raw()\");\n  for (row=0; row < height; row++) {\n    if (~row & 1)\n      if (fread (pixel, raw_width, 3, ifp) < 3) derror();\n    for (col=0; col < raw_width; col++) {\n      y  = pixel[width*2*(row & 1) + col];\n      cb = pixel[width + (col & -2)]   - 128;\n      cr = pixel[width + (col & -2)+1] - 128;\n      rgb[1] = y-((cb + cr + 2) >> 2);\n      rgb[2] = rgb[1] + cb;\n      rgb[0] = rgb[1] + cr;\n      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];\n    }\n  }\n  free (pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_262_load_raw()\n{\n  static const uchar kodak_tree[2][26] =\n  { { 0,1,5,1,1,2,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 },\n    { 0,3,1,1,1,1,1,2,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 } };\n  ushort *huff[2];\n  uchar *pixel;\n  int *strip, ns, c, row, col, chess, pi=0, pi1, pi2, pred, val;\n\n  FORC(2) huff[c] = make_decoder (kodak_tree[c]);\n  ns = (raw_height+63) >> 5;\n  pixel = (uchar *) malloc (raw_width*32 + ns*4);\n  merror (pixel, \"kodak_262_load_raw()\");\n  strip = (int *) (pixel + raw_width*32);\n  order = 0x4d4d;\n  FORC(ns) strip[c] = get4();\n  for (row=0; row < raw_height; row++) {\n    if ((row & 31) == 0) {\n      fseek (ifp, strip[row >> 5], SEEK_SET);\n      getbits(-1);\n      pi = 0;\n    }\n    for (col=0; col < raw_width; col++) {\n      chess = (row + col) & 1;\n      pi1 = chess ? pi-2           : pi-raw_width-1;\n      pi2 = chess ? pi-2*raw_width : pi-raw_width+1;\n      if (col <= chess) pi1 = -1;\n      if (pi1 < 0) pi1 = pi2;\n      if (pi2 < 0) pi2 = pi1;\n      if (pi1 < 0 && col > 1) pi1 = pi2 = pi-2;\n      pred = (pi1 < 0) ? 0 : (pixel[pi1] + pixel[pi2]) >> 1;\n      pixel[pi] = val = pred + ljpeg_diff (huff[chess]);\n      if (val >> 8) derror();\n      val = curve[pixel[pi++]];\n      RAW(row,col) = val;\n    }\n  }\n  free (pixel);\n  FORC(2) free (huff[c]);\n}\n\nint CLASS kodak_65000_decode (short *out, int bsize)\n{\n  uchar c, blen[768];\n  ushort raw[6];\n  INT64 bitbuf=0;\n  int save, bits=0, i, j, len, diff;\n\n  save = ftell(ifp);\n  bsize = (bsize + 3) & -4;\n  for (i=0; i < bsize; i+=2) {\n    c = fgetc(ifp);\n    if ((blen[i  ] = c & 15) > 12 ||\n\t(blen[i+1] = c >> 4) > 12 ) {\n      fseek (ifp, save, SEEK_SET);\n      for (i=0; i < bsize; i+=8) {\n\tread_shorts (raw, 6);\n\tout[i  ] = raw[0] >> 12 << 8 | raw[2] >> 12 << 4 | raw[4] >> 12;\n\tout[i+1] = raw[1] >> 12 << 8 | raw[3] >> 12 << 4 | raw[5] >> 12;\n\tfor (j=0; j < 6; j++)\n\t  out[i+2+j] = raw[j] & 0xfff;\n      }\n      return 1;\n    }\n  }\n  if ((bsize & 7) == 4) {\n    bitbuf  = fgetc(ifp) << 8;\n    bitbuf += fgetc(ifp);\n    bits = 16;\n  }\n  for (i=0; i < bsize; i++) {\n    len = blen[i];\n    if (bits < len) {\n      for (j=0; j < 32; j+=8)\n\tbitbuf += (INT64) fgetc(ifp) << (bits+(j^8));\n      bits += 32;\n    }\n    diff = bitbuf & (0xffff >> (16-len));\n    bitbuf >>= len;\n    bits -= len;\n    if ((diff & (1 << (len-1))) == 0)\n      diff -= (1 << len) - 1;\n    out[i] = diff;\n  }\n  return 0;\n}\n\nvoid CLASS kodak_65000_load_raw()\n{\n  short buf[256];\n  int row, col, len, pred[2], ret, i;\n\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col+=256) {\n      pred[0] = pred[1] = 0;\n      len = MIN (256, width-col);\n      ret = kodak_65000_decode (buf, len);\n      for (i=0; i < len; i++)\n\tif ((RAW(row,col+i) =\tcurve[ret ? buf[i] :\n\t\t(pred[i & 1] += buf[i])]) >> 12) derror();\n    }\n}\n\nvoid CLASS kodak_ycbcr_load_raw()\n{\n  short buf[384], *bp;\n  int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n  ushort *ip;\n\n  for (row=0; row < height; row+=2)\n    for (col=0; col < width; col+=128) {\n      len = MIN (128, width-col);\n      kodak_65000_decode (buf, len*3);\n      y[0][1] = y[1][1] = cb = cr = 0;\n      for (bp=buf, i=0; i < len; i+=2, bp+=2) {\n\tcb += bp[4];\n\tcr += bp[5];\n\trgb[1] = -((cb + cr + 2) >> 2);\n\trgb[2] = rgb[1] + cb;\n\trgb[0] = rgb[1] + cr;\n\tfor (j=0; j < 2; j++)\n\t  for (k=0; k < 2; k++) {\n\t    if ((y[j][k] = y[j][k^1] + *bp++) >> 10) derror();\n\t    ip = image[(row+j)*width + col+i+k];\n\t    FORC3 ip[c] = curve[LIM(y[j][k]+rgb[c], 0, 0xfff)];\n\t  }\n      }\n    }\n}\n\nvoid CLASS kodak_rgb_load_raw()\n{\n  short buf[768], *bp;\n  int row, col, len, c, i, rgb[3];\n  ushort *ip=image[0];\n\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (raw_image) free (raw_image);\n  raw_image = 0;\n#endif\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col+=256) {\n      len = MIN (256, width-col);\n      kodak_65000_decode (buf, len*3);\n      memset (rgb, 0, sizeof rgb);\n      for (bp=buf, i=0; i < len; i++, ip+=4)\n\tFORC3 if ((ip[c] = rgb[c] += *bp++) >> 12) derror();\n    }\n}\n\nvoid CLASS kodak_thumb_load_raw()\n{\n  int row, col;\n  colors = thumb_misc >> 5;\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      read_shorts (image[row*width+col], colors);\n  maximum = (1 << (thumb_misc & 31)) - 1;\n}\n\nvoid CLASS sony_decrypt (unsigned *data, int len, int start, int key)\n{\n#ifndef LIBRAW_NOTHREADS\n#define pad tls->sony_decrypt.pad\n#define p   tls->sony_decrypt.p\n#else\n  static unsigned pad[128], p;\n#endif\n  if (start) {\n    for (p=0; p < 4; p++)\n      pad[p] = key = key * 48828125 + 1;\n    pad[3] = pad[3] << 1 | (pad[0]^pad[2]) >> 31;\n    for (p=4; p < 127; p++)\n      pad[p] = (pad[p-4]^pad[p-2]) << 1 | (pad[p-3]^pad[p-1]) >> 31;\n    for (p=0; p < 127; p++)\n      pad[p] = htonl(pad[p]);\n  }\n#if 1 // Avoid gcc 4.8 bug\n  while (len--)\n    {\n      *data++ ^= pad[p & 127] = pad[(p+1) & 127] ^ pad[(p+65) & 127];\n      p++;     \n    }\n#else\n  while (len--)\n    *data++ ^= pad[p++ & 127] = pad[(p+1) & 127] ^ pad[(p+65) & 127];\n#endif\n#ifndef LIBRAW_NOTHREADS\n#undef pad\n#undef p\n#endif\n}\n\nvoid CLASS sony_load_raw()\n{\n  uchar head[40];\n  ushort *pixel;\n  unsigned i, key, row, col;\n\n  fseek (ifp, 200896, SEEK_SET);\n  fseek (ifp, (unsigned) fgetc(ifp)*4 - 1, SEEK_CUR);\n  order = 0x4d4d;\n  key = get4();\n  fseek (ifp, 164600, SEEK_SET);\n  fread (head, 1, 40, ifp);\n  sony_decrypt ((unsigned int *) head, 10, 1, key);\n  for (i=26; i-- > 22; )\n    key = key << 8 | head[i];\n  fseek (ifp, data_offset, SEEK_SET);\n  for (row=0; row < raw_height; row++) {\n    pixel = raw_image + row*raw_width;\n    if (fread (pixel, 2, raw_width, ifp) < raw_width) derror();\n    sony_decrypt ((unsigned int *) pixel, raw_width/2, !row, key);\n    for (col=0; col < raw_width; col++)\n      if ((pixel[col] = ntohs(pixel[col])) >> 14) derror();\n  }\n  maximum = 0x3ff0;\n}\n\nvoid CLASS sony_arw_load_raw()\n{\n  ushort huff[32768];\n  static const ushort tab[18] =\n  { 0xf11,0xf10,0xe0f,0xd0e,0xc0d,0xb0c,0xa0b,0x90a,0x809,\n    0x708,0x607,0x506,0x405,0x304,0x303,0x300,0x202,0x201 };\n  int i, c, n, col, row, len, diff, sum=0;\n\n  for (n=i=0; i < 18; i++)\n    FORC(32768 >> (tab[i] >> 8)) huff[n++] = tab[i];\n#ifdef LIBRAW_LIBRARY_BUILD\n  LibRaw_byte_buffer *buf=NULL;\n  if(data_size)\n      buf = ifp->make_byte_buffer(data_size);\n  else\n      getbits(-1);\n      \n  LibRaw_bit_buffer bits;\n  bits.reset();\n#else\n  getbits(-1);\n#endif\n  for (col = raw_width; col--; )\n    for (row=0; row < raw_height+1; row+=2) {\n      if (row == raw_height) row = 1;\n#ifdef LIBRAW_LIBRARY_BUILD\n      if(data_size)\n          {\n              len = bits._gethuff(buf,15,huff,zero_after_ff);\n              diff = bits._getbits(buf,len,zero_after_ff);\n          }\n      else\n          {\n              len = getbithuff(15,huff);\n              diff = getbits(len);\n          }\n#else\n      len = getbithuff(15,huff);\n      diff = getbits(len);\n#endif\n      if ((diff & (1 << (len-1))) == 0)\n\tdiff -= (1 << len) - 1;\n      if ((sum += diff) >> 12) derror();\n      if (row < height) RAW(row,col) = sum;\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(buf) delete buf;\n#endif\n}\n\nvoid CLASS sony_arw2_load_raw()\n{\n  uchar *data, *dp;\n  ushort pix[16];\n  int row, col, val, max, min, imax, imin, sh, bit, i;\n\n  data = (uchar *) malloc (raw_width);\n  merror (data, \"sony_arw2_load_raw()\");\n  for (row=0; row < height; row++) {\n    fread (data, 1, raw_width, ifp);\n    for (dp=data, col=0; col < raw_width-30; dp+=16) {\n      max = 0x7ff & (val = sget4(dp));\n      min = 0x7ff & val >> 11;\n      imax = 0x0f & val >> 22;\n      imin = 0x0f & val >> 26;\n      for (sh=0; sh < 4 && 0x80 << sh <= max-min; sh++);\n      for (bit=30, i=0; i < 16; i++)\n\tif      (i == imax) pix[i] = max;\n\telse if (i == imin) pix[i] = min;\n\telse {\n\t  pix[i] = ((sget2(dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n\t  if (pix[i] > 0x7ff) pix[i] = 0x7ff;\n\t  bit += 7;\n\t}\n#ifdef LIBRAW_LIBRARY_BUILD\n      if(imgdata.params.sony_arw2_hack)\n          {\n              for (i=0; i < 16; i++, col+=2)\n                  RAW(row,col) = curve[pix[i] << 1];\n          }\n      else\n          {\n              for (i=0; i < 16; i++, col+=2)\n                  RAW(row,col) = curve[pix[i] << 1] >> 2;\n          }\n#else\n      for (i=0; i < 16; i++, col+=2)\n\tRAW(row,col) = curve[pix[i] << 1] >> 2;\n#endif\n      col -= col & 1 ? 1:31;\n    }\n  }\n  free (data);\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(imgdata.params.sony_arw2_hack)\n  {\n\tblack <<= 2;\n\tmaximum <<=2;\n  }\n#endif\n}\n\n#define HOLE(row) ((holes >> (((row) - raw_height) & 7)) & 1)\n\n/* Kudos to Rich Taylor for figuring out SMaL's compression algorithm. */\nvoid CLASS smal_decode_segment (unsigned seg[2][2], int holes)\n{\n  uchar hist[3][13] = {\n    { 7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0 },\n    { 7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0 },\n    { 3, 3, 0, 0, 63,     47,     31,     15,    0 } };\n  int low, high=0xff, carry=0, nbits=8;\n  int pix, s, count, bin, next, i, sym[3];\n  uchar diff, pred[]={0,0};\n  ushort data=0, range=0;\n\n  fseek (ifp, seg[0][1]+1, SEEK_SET);\n  getbits(-1);\n  for (pix=seg[0][0]; pix < seg[1][0]; pix++) {\n    for (s=0; s < 3; s++) {\n      data = data << nbits | getbits(nbits);\n      if (carry < 0)\n\tcarry = (nbits += carry+1) < 1 ? nbits-1 : 0;\n      while (--nbits >= 0)\n\tif ((data >> nbits & 0xff) == 0xff) break;\n      if (nbits > 0)\n\t  data = ((data & ((1 << (nbits-1)) - 1)) << 1) |\n\t((data + (((data & (1 << (nbits-1)))) << 1)) & (-1 << nbits));\n      if (nbits >= 0) {\n\tdata += getbits(1);\n\tcarry = nbits - 8;\n      }\n      count = ((((data-range+1) & 0xffff) << 2) - 1) / (high >> 4);\n      for (bin=0; hist[s][bin+5] > count; bin++);\n\t\tlow = hist[s][bin+5] * (high >> 4) >> 2;\n      if (bin) high = hist[s][bin+4] * (high >> 4) >> 2;\n      high -= low;\n      for (nbits=0; high << nbits < 128; nbits++);\n      range = (range+low) << nbits;\n      high <<= nbits;\n      next = hist[s][1];\n      if (++hist[s][2] > hist[s][3]) {\n\tnext = (next+1) & hist[s][0];\n\thist[s][3] = (hist[s][next+4] - hist[s][next+5]) >> 2;\n\thist[s][2] = 1;\n      }\n      if (hist[s][hist[s][1]+4] - hist[s][hist[s][1]+5] > 1) {\n\tif (bin < hist[s][1])\n\t  for (i=bin; i < hist[s][1]; i++) hist[s][i+5]--;\n\telse if (next <= bin)\n\t  for (i=hist[s][1]; i < bin; i++) hist[s][i+5]++;\n      }\n      hist[s][1] = next;\n      sym[s] = bin;\n    }\n    diff = sym[2] << 5 | sym[1] << 2 | (sym[0] & 3);\n    if (sym[0] & 4)\n      diff = diff ? -diff : 0x80;\n    if (ftell(ifp) + 12 >= seg[1][1])\n      diff = 0;\n    raw_image[pix] = pred[pix & 1] += diff;\n    if (!(pix & 1) && HOLE(pix / raw_width)) pix += 2;\n  }\n  maximum = 0xff;\n}\n\nvoid CLASS smal_v6_load_raw()\n{\n  unsigned seg[2][2];\n\n  fseek (ifp, 16, SEEK_SET);\n  seg[0][0] = 0;\n  seg[0][1] = get2();\n  seg[1][0] = raw_width * raw_height;\n  seg[1][1] = INT_MAX;\n  smal_decode_segment (seg, 0);\n}\n\nint CLASS median4 (int *p)\n{\n  int min, max, sum, i;\n\n  min = max = sum = p[0];\n  for (i=1; i < 4; i++) {\n    sum += p[i];\n    if (min > p[i]) min = p[i];\n    if (max < p[i]) max = p[i];\n  }\n  return (sum - min - max) >> 1;\n}\n\nvoid CLASS fill_holes (int holes)\n{\n  int row, col, val[4];\n\n  for (row=2; row < height-2; row++) {\n    if (!HOLE(row)) continue;\n    for (col=1; col < width-1; col+=4) {\n      val[0] = RAW(row-1,col-1);\n      val[1] = RAW(row-1,col+1);\n      val[2] = RAW(row+1,col-1);\n      val[3] = RAW(row+1,col+1);\n      RAW(row,col) = median4(val);\n    }\n    for (col=2; col < width-2; col+=4)\n      if (HOLE(row-2) || HOLE(row+2))\n\tRAW(row,col) = (RAW(row,col-2) + RAW(row,col+2)) >> 1;\n      else {\n\tval[0] = RAW(row,col-2);\n\tval[1] = RAW(row,col+2);\n\tval[2] = RAW(row-2,col);\n\tval[3] = RAW(row+2,col);\n\tRAW(row,col) = median4(val);\n      }\n  }\n}\n\nvoid CLASS smal_v9_load_raw()\n{\n  unsigned seg[256][2], offset, nseg, holes, i;\n\n  fseek (ifp, 67, SEEK_SET);\n  offset = get4();\n  nseg = fgetc(ifp);\n  fseek (ifp, offset, SEEK_SET);\n  for (i=0; i < nseg*2; i++)\n    seg[0][i] = get4() + data_offset*(i & 1);\n  fseek (ifp, 78, SEEK_SET);\n  holes = fgetc(ifp);\n  fseek (ifp, 88, SEEK_SET);\n  seg[nseg][0] = raw_height * raw_width;\n  seg[nseg][1] = get4() + data_offset;\n  for (i=0; i < nseg; i++)\n    smal_decode_segment (seg+i, holes);\n  if (holes) fill_holes (holes);\n}\n\nvoid CLASS redcine_load_raw()\n{\n#ifndef NO_JASPER\n  int c, row, col;\n  jas_stream_t *in;\n  jas_image_t *jimg;\n  jas_matrix_t *jmat;\n  jas_seqent_t *data;\n  ushort *img, *pix;\n\n  jas_init();\n#ifndef LIBRAW_LIBRARY_BUILD\n  in = jas_stream_fopen (ifname, \"rb\");\n#else\n  in = (jas_stream_t*)ifp->make_jas_stream();\n  if(!in)\n          throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n#endif\n  jas_stream_seek (in, data_offset+20, SEEK_SET);\n  jimg = jas_image_decode (in, -1, 0);\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!jimg) longjmp (failure, 3);\n#else\n  if(!jimg)\n      {\n          jas_stream_close (in);\n          throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n      }\n#endif\n  jmat = jas_matrix_create (height/2, width/2);\n  merror (jmat, \"redcine_load_raw()\");\n  img = (ushort *) calloc ((height+2)*(width+2), 2);\n  merror (img, \"redcine_load_raw()\");\n  FORC4 {\n    jas_image_readcmpt (jimg, c, 0, 0, width/2, height/2, jmat);\n    data = jas_matrix_getref (jmat, 0, 0);\n    for (row = c >> 1; row < height; row+=2)\n      for (col = c & 1; col < width; col+=2)\n\timg[(row+1)*(width+2)+col+1] = data[(row/2)*(width/2)+col/2];\n  }\n  for (col=1; col <= width; col++) {\n    img[col] = img[2*(width+2)+col];\n    img[(height+1)*(width+2)+col] = img[(height-1)*(width+2)+col];\n  }\n  for (row=0; row < height+2; row++) {\n    img[row*(width+2)] = img[row*(width+2)+2];\n    img[(row+1)*(width+2)-1] = img[(row+1)*(width+2)-3];\n  }\n  for (row=1; row <= height; row++) {\n    pix = img + row*(width+2) + (col = 1 + (FC(row,1) & 1));\n    for (   ; col <= width; col+=2, pix+=2) {\n      c = (((pix[0] - 0x800) << 3) +\n\tpix[-(width+2)] + pix[width+2] + pix[-1] + pix[1]) >> 2;\n      pix[0] = LIM(c,0,4095);\n    }\n  }\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      RAW(row,col) = curve[img[(row+1)*(width+2)+col+1]];\n  free (img);\n  jas_matrix_destroy (jmat);\n  jas_image_destroy (jimg);\n  jas_stream_close (in);\n#endif\n}\n#line 3878 \"dcraw/dcraw.c\"\nvoid CLASS crop_masked_pixels()\n{\n  int row, col;\n  unsigned \n#ifndef LIBRAW_LIBRARY_BUILD\n    r, raw_pitch = raw_width*2,\n#endif\n    c, m, mblack[8], zero, val;\n\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (load_raw == &CLASS phase_one_load_raw ||\n      load_raw == &CLASS phase_one_load_raw_c)\n    phase_one_correct();\n  if (fuji_width) {\n    for (row=0; row < raw_height-top_margin*2; row++) {\n      for (col=0; col < fuji_width << !fuji_layout; col++) {\n\tif (fuji_layout) {\n\t  r = fuji_width - 1 - col + (row >> 1);\n\t  c = col + ((row+1) >> 1);\n\t} else {\n\t  r = fuji_width - 1 + row - (col >> 1);\n\t  c = row + ((col+1) >> 1);\n\t}\n\tif (r < height && c < width)\n\t  BAYER(r,c) = RAW(row+top_margin,col+left_margin);\n      }\n    }\n  } else {\n    for (row=0; row < height; row++)\n      for (col=0; col < width; col++)\n\tBAYER2(row,col) = RAW(row+top_margin,col+left_margin);\n  }\n#endif\n  if (mask[0][3]) goto mask_set;\n  if (load_raw == &CLASS canon_load_raw ||\n      load_raw == &CLASS lossless_jpeg_load_raw) {\n    mask[0][1] = mask[1][1] = 2;\n    mask[0][3] = -2;\n    goto sides;\n  }\n  if (load_raw == &CLASS canon_600_load_raw ||\n      load_raw == &CLASS sony_load_raw ||\n     (load_raw == &CLASS eight_bit_load_raw && strncmp(model,\"DC2\",3)) ||\n      load_raw == &CLASS kodak_262_load_raw ||\n     (load_raw == &CLASS packed_load_raw && (load_flags & 32))) {\nsides:\n    mask[0][0] = mask[1][0] = top_margin;\n    mask[0][2] = mask[1][2] = top_margin+height;\n    mask[0][3] += left_margin;\n    mask[1][1] += left_margin+width;\n    mask[1][3] += raw_width;\n  }\n  if (load_raw == &CLASS nokia_load_raw) {\n    mask[0][2] = top_margin;\n    mask[0][3] = width;\n  }\nmask_set:\n  memset (mblack, 0, sizeof mblack);\n  for (zero=m=0; m < 8; m++)\n    for (row=mask[m][0]; row < mask[m][2]; row++)\n      for (col=mask[m][1]; col < mask[m][3]; col++) {\n\tc = FC(row-top_margin,col-left_margin);\n\tmblack[c] += val = raw_image[(row)*raw_pitch/2+(col)];\n\tmblack[4+c]++;\n\tzero += !val;\n      }\n  if (load_raw == &CLASS canon_600_load_raw && width < raw_width) {\n    black = (mblack[0]+mblack[1]+mblack[2]+mblack[3]) /\n\t    (mblack[4]+mblack[5]+mblack[6]+mblack[7]) - 4;\n#ifndef LIBRAW_LIBRARY_BUILD\n    canon_600_correct();\n#endif\n  } else if (zero < mblack[4] && mblack[5] && mblack[6] && mblack[7])\n    FORC4 cblack[c] = mblack[c] / mblack[4+c];\n}\n\nvoid CLASS remove_zeroes()\n{\n  unsigned row, col, tot, n, r, c;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES,0,2);\n#endif\n\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      if (BAYER(row,col) == 0) {\n\ttot = n = 0;\n\tfor (r = row-2; r <= row+2; r++)\n\t  for (c = col-2; c <= col+2; c++)\n\t    if (r < height && c < width &&\n\t\tFC(r,c) == FC(row,col) && BAYER(r,c))\n\t      tot += (n++,BAYER(r,c));\n\tif (n) BAYER(row,col) = tot/n;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES,1,2);\n#endif\n}\n#line 4143 \"dcraw/dcraw.c\"\nvoid CLASS gamma_curve (double pwr, double ts, int mode, int imax)\n{\n  int i;\n  double g[6], bnd[2]={0,0}, r;\n\n  g[0] = pwr;\n  g[1] = ts;\n  g[2] = g[3] = g[4] = 0;\n  bnd[g[1] >= 1] = 1;\n  if (g[1] && (g[1]-1)*(g[0]-1) <= 0) {\n    for (i=0; i < 48; i++) {\n      g[2] = (bnd[0] + bnd[1])/2;\n      if (g[0]) bnd[(pow(g[2]/g[1],-g[0]) - 1)/g[0] - 1/g[2] > -1] = g[2];\n      else\tbnd[g[2]/exp(1-1/g[2]) < g[1]] = g[2];\n    }\n    g[3] = g[2] / g[1];\n    if (g[0]) g[4] = g[2] * (1/g[0] - 1);\n  }\n  if (g[0]) g[5] = 1 / (g[1]*SQR(g[3])/2 - g[4]*(1 - g[3]) +\n\t\t(1 - pow(g[3],1+g[0]))*(1 + g[4])/(1 + g[0])) - 1;\n  else      g[5] = 1 / (g[1]*SQR(g[3])/2 + 1\n\t\t- g[2] - g[3] -\tg[2]*g[3]*(log(g[3]) - 1)) - 1;\n  if (!mode--) {\n    memcpy (gamm, g, sizeof gamm);\n    return;\n  }\n  for (i=0; i < 0x10000; i++) {\n    curve[i] = 0xffff;\n    if ((r = (double) i / imax) < 1)\n      curve[i] = 0x10000 * ( mode\n\t? (r < g[3] ? r*g[1] : (g[0] ? pow( r,g[0])*(1+g[4])-g[4]    : log(r)*g[2]+1))\n\t: (r < g[2] ? r/g[1] : (g[0] ? pow((r+g[4])/(1+g[4]),1/g[0]) : exp((r-1)/g[2]))));\n  }\n}\n\nvoid CLASS pseudoinverse (double (*in)[3], double (*out)[3], int size)\n{\n  double work[3][6], num;\n  int i, j, k;\n\n  for (i=0; i < 3; i++) {\n    for (j=0; j < 6; j++)\n      work[i][j] = j == i+3;\n    for (j=0; j < 3; j++)\n      for (k=0; k < size; k++)\n\twork[i][j] += in[k][i] * in[k][j];\n  }\n  for (i=0; i < 3; i++) {\n    num = work[i][i];\n    for (j=0; j < 6; j++)\n      work[i][j] /= num;\n    for (k=0; k < 3; k++) {\n      if (k==i) continue;\n      num = work[k][i];\n      for (j=0; j < 6; j++)\n\twork[k][j] -= work[i][j] * num;\n    }\n  }\n  for (i=0; i < size; i++)\n    for (j=0; j < 3; j++)\n      for (out[i][j]=k=0; k < 3; k++)\n\tout[i][j] += work[j][k+3] * in[i][k];\n}\n\nvoid CLASS cam_xyz_coeff (double cam_xyz[4][3])\n{\n  double cam_rgb[4][3], inverse[4][3], num;\n  int i, j, k;\n\n  for (i=0; i < colors; i++)\t\t/* Multiply out XYZ colorspace */\n    for (j=0; j < 3; j++)\n      for (cam_rgb[i][j] = k=0; k < 3; k++)\n\tcam_rgb[i][j] += cam_xyz[i][k] * xyz_rgb[k][j];\n\n  for (i=0; i < colors; i++) {\t\t/* Normalize cam_rgb so that */\n    for (num=j=0; j < 3; j++)\t\t/* cam_rgb * (1,1,1) is (1,1,1,1) */\n      num += cam_rgb[i][j];\n    for (j=0; j < 3; j++)\n      cam_rgb[i][j] /= num;\n    pre_mul[i] = 1 / num;\n  }\n  pseudoinverse (cam_rgb, inverse, colors);\n  for (raw_color = i=0; i < 3; i++)\n    for (j=0; j < colors; j++)\n      rgb_cam[i][j] = inverse[j][i];\n}\n\n#ifdef COLORCHECK\nvoid CLASS colorcheck()\n{\n#define NSQ 24\n// Coordinates of the GretagMacbeth ColorChecker squares\n// width, height, 1st_column, 1st_row\n  int cut[NSQ][4];\t\t\t// you must set these\n// ColorChecker Chart under 6500-kelvin illumination\n  static const double gmb_xyY[NSQ][3] = {\n    { 0.400, 0.350, 10.1 },\t\t// Dark Skin\n    { 0.377, 0.345, 35.8 },\t\t// Light Skin\n    { 0.247, 0.251, 19.3 },\t\t// Blue Sky\n    { 0.337, 0.422, 13.3 },\t\t// Foliage\n    { 0.265, 0.240, 24.3 },\t\t// Blue Flower\n    { 0.261, 0.343, 43.1 },\t\t// Bluish Green\n    { 0.506, 0.407, 30.1 },\t\t// Orange\n    { 0.211, 0.175, 12.0 },\t\t// Purplish Blue\n    { 0.453, 0.306, 19.8 },\t\t// Moderate Red\n    { 0.285, 0.202, 6.6 },\t\t// Purple\n    { 0.380, 0.489, 44.3 },\t\t// Yellow Green\n    { 0.473, 0.438, 43.1 },\t\t// Orange Yellow\n    { 0.187, 0.129, 6.1 },\t\t// Blue\n    { 0.305, 0.478, 23.4 },\t\t// Green\n    { 0.539, 0.313, 12.0 },\t\t// Red\n    { 0.448, 0.470, 59.1 },\t\t// Yellow\n    { 0.364, 0.233, 19.8 },\t\t// Magenta\n    { 0.196, 0.252, 19.8 },\t\t// Cyan\n    { 0.310, 0.316, 90.0 },\t\t// White\n    { 0.310, 0.316, 59.1 },\t\t// Neutral 8\n    { 0.310, 0.316, 36.2 },\t\t// Neutral 6.5\n    { 0.310, 0.316, 19.8 },\t\t// Neutral 5\n    { 0.310, 0.316, 9.0 },\t\t// Neutral 3.5\n    { 0.310, 0.316, 3.1 } };\t\t// Black\n  double gmb_cam[NSQ][4], gmb_xyz[NSQ][3];\n  double inverse[NSQ][3], cam_xyz[4][3], num;\n  int c, i, j, k, sq, row, col, count[4];\n\n  memset (gmb_cam, 0, sizeof gmb_cam);\n  for (sq=0; sq < NSQ; sq++) {\n    FORCC count[c] = 0;\n    for   (row=cut[sq][3]; row < cut[sq][3]+cut[sq][1]; row++)\n      for (col=cut[sq][2]; col < cut[sq][2]+cut[sq][0]; col++) {\n\tc = FC(row,col);\n\tif (c >= colors) c -= 2;\n\tgmb_cam[sq][c] += BAYER(row,col);\n\tcount[c]++;\n      }\n    FORCC gmb_cam[sq][c] = gmb_cam[sq][c]/count[c] - black;\n    gmb_xyz[sq][0] = gmb_xyY[sq][2] * gmb_xyY[sq][0] / gmb_xyY[sq][1];\n    gmb_xyz[sq][1] = gmb_xyY[sq][2];\n    gmb_xyz[sq][2] = gmb_xyY[sq][2] *\n\t\t(1 - gmb_xyY[sq][0] - gmb_xyY[sq][1]) / gmb_xyY[sq][1];\n  }\n  pseudoinverse (gmb_xyz, inverse, NSQ);\n  for (i=0; i < colors; i++)\n    for (j=0; j < 3; j++)\n      for (cam_xyz[i][j] = k=0; k < NSQ; k++)\n\tcam_xyz[i][j] += gmb_cam[k][i] * inverse[k][j];\n  cam_xyz_coeff (cam_xyz);\n  if (verbose) {\n    printf (\"    { \\\"%s %s\\\", %d,\\n\\t{\", make, model, black);\n    num = 10000 / (cam_xyz[1][0] + cam_xyz[1][1] + cam_xyz[1][2]);\n    FORCC for (j=0; j < 3; j++)\n      printf (\"%c%d\", (c | j) ? ',':' ', (int) (cam_xyz[c][j] * num + 0.5));\n    puts (\" } },\");\n  }\n#undef NSQ\n}\n#endif\n\nvoid CLASS hat_transform (float *temp, float *base, int st, int size, int sc)\n{\n  int i;\n  for (i=0; i < sc; i++)\n    temp[i] = 2*base[st*i] + base[st*(sc-i)] + base[st*(i+sc)];\n  for (; i+sc < size; i++)\n    temp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(i+sc)];\n  for (; i < size; i++)\n    temp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(2*size-2-(i+sc))];\n}\n\n#if !defined(LIBRAW_USE_OPENMP)\nvoid CLASS wavelet_denoise()\n{\n  float *fimg=0, *temp, thold, mul[2], avg, diff;\n  int scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];\n  ushort *window[4];\n  static const float noise[] =\n  { 0.8002,0.2735,0.1202,0.0585,0.0291,0.0152,0.0080,0.0044 };\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Wavelet denoising...\\n\"));\n#endif\n\n  while (maximum << scale < 0x10000) scale++;\n  maximum <<= --scale;\n  black <<= scale;\n  FORC4 cblack[c] <<= scale;\n  if ((size = iheight*iwidth) < 0x15550000)\n    fimg = (float *) malloc ((size*3 + iheight + iwidth) * sizeof *fimg);\n  merror (fimg, \"wavelet_denoise()\");\n  temp = fimg + size*3;\n  if ((nc = colors) == 3 && filters) nc++;\n  FORC(nc) {\t\t\t/* denoise R,G1,B,G3 individually */\n    for (i=0; i < size; i++)\n      fimg[i] = 256 * sqrt((double)(image[i][c] << scale));\n    for (hpass=lev=0; lev < 5; lev++) {\n      lpass = size*((lev & 1)+1);\n      for (row=0; row < iheight; row++) {\n\that_transform (temp, fimg+hpass+row*iwidth, 1, iwidth, 1 << lev);\n\tfor (col=0; col < iwidth; col++)\n\t  fimg[lpass + row*iwidth + col] = temp[col] * 0.25;\n      }\n      for (col=0; col < iwidth; col++) {\n\that_transform (temp, fimg+lpass+col, iwidth, iheight, 1 << lev);\n\tfor (row=0; row < iheight; row++)\n\t  fimg[lpass + row*iwidth + col] = temp[row] * 0.25;\n      }\n      thold = threshold * noise[lev];\n      for (i=0; i < size; i++) {\n\tfimg[hpass+i] -= fimg[lpass+i];\n\tif\t(fimg[hpass+i] < -thold) fimg[hpass+i] += thold;\n\telse if (fimg[hpass+i] >  thold) fimg[hpass+i] -= thold;\n\telse\t fimg[hpass+i] = 0;\n\tif (hpass) fimg[i] += fimg[hpass+i];\n      }\n      hpass = lpass;\n    }\n    for (i=0; i < size; i++)\n      image[i][c] = CLIP(SQR(fimg[i]+fimg[lpass+i])/0x10000);\n  }\n  if (filters && colors == 3) {  /* pull G1 and G3 closer together */\n    for (row=0; row < 2; row++) {\n      mul[row] = 0.125 * pre_mul[FC(row+1,0) | 1] / pre_mul[FC(row,0) | 1];\n      blk[row] = cblack[FC(row,0) | 1];\n    }\n    for (i=0; i < 4; i++)\n      window[i] = (ushort *) fimg + width*i;\n    for (wlast=-1, row=1; row < height-1; row++) {\n      while (wlast < row+1) {\n\tfor (wlast++, i=0; i < 4; i++)\n\t  window[(i+3) & 3] = window[i];\n\tfor (col = FC(wlast,1) & 1; col < width; col+=2)\n\t  window[2][col] = BAYER(wlast,col);\n      }\n      thold = threshold/512;\n      for (col = (FC(row,0) & 1)+1; col < width-1; col+=2) {\n\tavg = ( window[0][col-1] + window[0][col+1] +\n\t\twindow[2][col-1] + window[2][col+1] - blk[~row & 1]*4 )\n\t      * mul[row & 1] + (window[1][col] + blk[row & 1]) * 0.5;\n\tavg = avg < 0 ? 0 : sqrt(avg);\n\tdiff = sqrt((double)BAYER(row,col)) - avg;\n\tif      (diff < -thold) diff += thold;\n\telse if (diff >  thold) diff -= thold;\n\telse diff = 0;\n\tBAYER(row,col) = CLIP(SQR(avg+diff) + 0.5);\n      }\n    }\n  }\n  free (fimg);\n}\n#else /* LIBRAW_USE_OPENMP */\nvoid CLASS wavelet_denoise()\n{\n  float *fimg=0, *temp, thold, mul[2], avg, diff;\n   int scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];\n  ushort *window[4];\n  static const float noise[] =\n  { 0.8002,0.2735,0.1202,0.0585,0.0291,0.0152,0.0080,0.0044 };\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Wavelet denoising...\\n\"));\n#endif\n\n  while (maximum << scale < 0x10000) scale++;\n  maximum <<= --scale;\n  black <<= scale;\n  FORC4 cblack[c] <<= scale;\n  if ((size = iheight*iwidth) < 0x15550000)\n    fimg = (float *) malloc ((size*3 + iheight + iwidth) * sizeof *fimg);\n  merror (fimg, \"wavelet_denoise()\");\n  temp = fimg + size*3;\n  if ((nc = colors) == 3 && filters) nc++;\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp parallel default(shared) private(i,col,row,thold,lev,lpass,hpass,temp,c) firstprivate(scale,size) \n#endif\n  {\n      temp = (float*)malloc( (iheight + iwidth) * sizeof *fimg);\n    FORC(nc) {\t\t\t/* denoise R,G1,B,G3 individually */\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n      for (i=0; i < size; i++)\n        fimg[i] = 256 * sqrt((double)(image[i][c] << scale));\n      for (hpass=lev=0; lev < 5; lev++) {\n\tlpass = size*((lev & 1)+1);\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n\tfor (row=0; row < iheight; row++) {\n\t  hat_transform (temp, fimg+hpass+row*iwidth, 1, iwidth, 1 << lev);\n\t  for (col=0; col < iwidth; col++)\n\t    fimg[lpass + row*iwidth + col] = temp[col] * 0.25;\n\t}\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n\tfor (col=0; col < iwidth; col++) {\n\t  hat_transform (temp, fimg+lpass+col, iwidth, iheight, 1 << lev);\n\t  for (row=0; row < iheight; row++)\n\t    fimg[lpass + row*iwidth + col] = temp[row] * 0.25;\n\t}\n\tthold = threshold * noise[lev];\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n\tfor (i=0; i < size; i++) {\n\t  fimg[hpass+i] -= fimg[lpass+i];\n\t  if\t(fimg[hpass+i] < -thold) fimg[hpass+i] += thold;\n\t  else if (fimg[hpass+i] >  thold) fimg[hpass+i] -= thold;\n\t  else\t fimg[hpass+i] = 0;\n\t  if (hpass) fimg[i] += fimg[hpass+i];\n\t}\n\thpass = lpass;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n      for (i=0; i < size; i++)\n\timage[i][c] = CLIP(SQR(fimg[i]+fimg[lpass+i])/0x10000);\n    }\n    free(temp);\n  } /* end omp parallel */\n/* the following loops are hard to parallize, no idea yes,\n * problem is wlast which is carrying dependency\n * second part should be easyer, but did not yet get it right.\n */\n  if (filters && colors == 3) {  /* pull G1 and G3 closer together */\n   for (row=0; row < 2; row++){\n      mul[row] = 0.125 * pre_mul[FC(row+1,0) | 1] / pre_mul[FC(row,0) | 1];\n      blk[row] = cblack[FC(row,0) | 1];\n   }\n    for (i=0; i < 4; i++)\n      window[i] = (ushort *) fimg + width*i;\n    for (wlast=-1, row=1; row < height-1; row++) {\n      while (wlast < row+1) {\n\tfor (wlast++, i=0; i < 4; i++)\n\t  window[(i+3) & 3] = window[i];\n\tfor (col = FC(wlast,1) & 1; col < width; col+=2)\n\t  window[2][col] = BAYER(wlast,col);\n      }\n      thold = threshold/512;\n      for (col = (FC(row,0) & 1)+1; col < width-1; col+=2) {\n\tavg = ( window[0][col-1] + window[0][col+1] +\n\t\twindow[2][col-1] + window[2][col+1] - blk[~row & 1]*4 )\n\t      * mul[row & 1] + (window[1][col] + blk[row & 1]) * 0.5;\n\tavg = avg < 0 ? 0 : sqrt(avg);\n\tdiff = sqrt((double)BAYER(row,col)) - avg;\n\tif      (diff < -thold) diff += thold;\n\telse if (diff >  thold) diff -= thold;\n\telse diff = 0;\n\tBAYER(row,col) = CLIP(SQR(avg+diff) + 0.5);\n      }\n    }\n  }\n  free (fimg);\n}\n\n#endif\n\n// green equilibration\nvoid CLASS green_matching()\n{\n  int i,j;\n  double m1,m2,c1,c2;\n  int o1_1,o1_2,o1_3,o1_4;\n  int o2_1,o2_2,o2_3,o2_4;\n  ushort (*img)[4];\n  const int margin = 3;\n  int oj = 2, oi = 2;\n  float f;\n  const float thr = 0.01f;\n  if(half_size || shrink) return;\n  if(FC(oj, oi) != 3) oj++;\n  if(FC(oj, oi) != 3) oi++;\n  if(FC(oj, oi) != 3) oj--;\n\n  img = (ushort (*)[4]) calloc (height*width, sizeof *image);\n  merror (img, \"green_matching()\");\n  memcpy(img,image,height*width*sizeof *image);\n\n  for(j=oj;j<height-margin;j+=2)\n    for(i=oi;i<width-margin;i+=2){\n      o1_1=img[(j-1)*width+i-1][1];\n      o1_2=img[(j-1)*width+i+1][1];\n      o1_3=img[(j+1)*width+i-1][1];\n      o1_4=img[(j+1)*width+i+1][1];\n      o2_1=img[(j-2)*width+i][3];\n      o2_2=img[(j+2)*width+i][3];\n      o2_3=img[j*width+i-2][3];\n      o2_4=img[j*width+i+2][3];\n\n      m1=(o1_1+o1_2+o1_3+o1_4)/4.0;\n      m2=(o2_1+o2_2+o2_3+o2_4)/4.0;\n\n      c1=(abs(o1_1-o1_2)+abs(o1_1-o1_3)+abs(o1_1-o1_4)+abs(o1_2-o1_3)+abs(o1_3-o1_4)+abs(o1_2-o1_4))/6.0;\n      c2=(abs(o2_1-o2_2)+abs(o2_1-o2_3)+abs(o2_1-o2_4)+abs(o2_2-o2_3)+abs(o2_3-o2_4)+abs(o2_2-o2_4))/6.0;\n      if((img[j*width+i][3]<maximum*0.95)&&(c1<maximum*thr)&&(c2<maximum*thr))\n      {\n        f = image[j*width+i][3]*m1/m2;\n        image[j*width+i][3]=f>0xffff?0xffff:f;\n      }\n    }\n  free(img);\n}\n\nvoid CLASS scale_colors()\n{\n  unsigned bottom, right, size, row, col, ur, uc, i, x, y, c, sum[8];\n  int val, dark, sat;\n  double dsum[8], dmin, dmax;\n  float scale_mul[4], fr, fc;\n  ushort *img=0, *pix;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS,0,2);\n#endif\n\n  if (user_mul[0])\n    memcpy (pre_mul, user_mul, sizeof pre_mul);\n  if (use_auto_wb || (use_camera_wb && cam_mul[0] == -1)) {\n    memset (dsum, 0, sizeof dsum);\n    bottom = MIN (greybox[1]+greybox[3], height);\n    right  = MIN (greybox[0]+greybox[2], width);\n    for (row=greybox[1]; row < bottom; row += 8)\n      for (col=greybox[0]; col < right; col += 8) {\n\tmemset (sum, 0, sizeof sum);\n\tfor (y=row; y < row+8 && y < bottom; y++)\n\t  for (x=col; x < col+8 && x < right; x++)\n\t    FORC4 {\n\t      if (filters) {\n\t\tc = fcol(y,x);\n\t\tval = BAYER2(y,x);\n\t      } else\n\t\tval = image[y*width+x][c];\n\t      if (val > maximum-25) goto skip_block;\n\t      if ((val -= cblack[c]) < 0) val = 0;\n\t      sum[c] += val;\n\t      sum[c+4]++;\n\t      if (filters) break;\n\t    }\n\tFORC(8) dsum[c] += sum[c];\nskip_block: ;\n      }\n    FORC4 if (dsum[c]) pre_mul[c] = dsum[c+4] / dsum[c];\n  }\n  if (use_camera_wb && cam_mul[0] != -1) {\n    memset (sum, 0, sizeof sum);\n    for (row=0; row < 8; row++)\n      for (col=0; col < 8; col++) {\n\tc = FC(row,col);\n\tif ((val = white[row][col] - cblack[c]) > 0)\n\t  sum[c] += val;\n\tsum[c+4]++;\n      }\n    if (sum[0] && sum[1] && sum[2] && sum[3])\n      FORC4 pre_mul[c] = (float) sum[c+4] / sum[c];\n    else if (cam_mul[0] && cam_mul[2])\n      memcpy (pre_mul, cam_mul, sizeof pre_mul);\n    else\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n            imgdata.process_warnings |= LIBRAW_WARN_BAD_CAMERA_WB;\n#endif\n#ifdef DCRAW_VERBOSE\n            fprintf (stderr,_(\"%s: Cannot use camera white balance.\\n\"), ifname);\n#endif\n      }\n  }\n  if (pre_mul[3] == 0) pre_mul[3] = colors < 4 ? pre_mul[1] : 1;\n  dark = black;\n  sat = maximum;\n  if (threshold) wavelet_denoise();\n  maximum -= black;\n  for (dmin=DBL_MAX, dmax=c=0; c < 4; c++) {\n    if (dmin > pre_mul[c])\n\tdmin = pre_mul[c];\n    if (dmax < pre_mul[c])\n\tdmax = pre_mul[c];\n  }\n  if (!highlight) dmax = dmin;\n  FORC4 scale_mul[c] = (pre_mul[c] /= dmax) * 65535.0 / maximum;\n#ifdef DCRAW_VERBOSE\n  if (verbose) {\n    fprintf (stderr,\n      _(\"Scaling with darkness %d, saturation %d, and\\nmultipliers\"), dark, sat);\n    FORC4 fprintf (stderr, \" %f\", pre_mul[c]);\n    fputc ('\\n', stderr);\n  }\n#endif\n  size = iheight*iwidth;\n#ifdef LIBRAW_LIBRARY_BUILD\n  scale_colors_loop(scale_mul);\n#else\n  for (i=0; i < size*4; i++) {\n    val = image[0][i];\n    if (!val) continue;\n    val -= cblack[i & 3];\n    val *= scale_mul[i & 3];\n    image[0][i] = CLIP(val);\n  }\n#endif\n  if ((aber[0] != 1 || aber[2] != 1) && colors == 3) {\n#ifdef DCRAW_VERBOSE\n    if (verbose)\n      fprintf (stderr,_(\"Correcting chromatic aberration...\\n\"));\n#endif\n    for (c=0; c < 4; c+=2) {\n      if (aber[c] == 1) continue;\n      img = (ushort *) malloc (size * sizeof *img);\n      merror (img, \"scale_colors()\");\n      for (i=0; i < size; i++)\n\timg[i] = image[i][c];\n      for (row=0; row < iheight; row++) {\n\tur = fr = (row - iheight*0.5) * aber[c] + iheight*0.5;\n\tif (ur > iheight-2) continue;\n\tfr -= ur;\n\tfor (col=0; col < iwidth; col++) {\n\t  uc = fc = (col - iwidth*0.5) * aber[c] + iwidth*0.5;\n\t  if (uc > iwidth-2) continue;\n\t  fc -= uc;\n\t  pix = img + ur*iwidth + uc;\n\t  image[row*iwidth+col][c] =\n\t    (pix[     0]*(1-fc) + pix[       1]*fc) * (1-fr) +\n\t    (pix[iwidth]*(1-fc) + pix[iwidth+1]*fc) * fr;\n\t}\n      }\n      free(img);\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS,1,2);\n#endif\n}\n\nvoid CLASS pre_interpolate()\n{\n  ushort (*img)[4];\n  int row, col, c;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE,0,2);\n#endif\n  if (shrink) {\n    if (half_size) {\n      height = iheight;\n      width  = iwidth;\n    } else {\n      img = (ushort (*)[4]) calloc (height*width, sizeof *img);\n      merror (img, \"pre_interpolate()\");\n      for (row=0; row < height; row++)\n\tfor (col=0; col < width; col++) {\n\t  c = fcol(row,col);\n\t  img[row*width+col][c] = image[(row >> 1)*iwidth+(col >> 1)][c];\n\t}\n      free (image);\n      image = img;\n      shrink = 0;\n    }\n  }\n  if (filters > 1000 && colors == 3) {\n    if (four_color_rgb && colors++)\n      mix_green = !half_size;\n    else {\n      for (row = FC(1,0) >> 1; row < height; row+=2)\n\tfor (col = FC(row,1) & 1; col < width; col+=2)\n\t  image[row*width+col][1] = image[row*width+col][3];\n      filters &= ~((filters & 0x55555555) << 1);\n    }\n  }\n  if (half_size) filters = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE,1,2);\n#endif\n}\n\nvoid CLASS border_interpolate (int border)\n{\n  unsigned row, col, y, x, f, c, sum[8];\n\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++) {\n      if (col==border && row >= border && row < height-border)\n\tcol = width-border;\n      memset (sum, 0, sizeof sum);\n      for (y=row-1; y != row+2; y++)\n\tfor (x=col-1; x != col+2; x++)\n\t  if (y < height && x < width) {\n\t    f = fcol(y,x);\n\t    sum[f] += image[y*width+x][f];\n\t    sum[f+4]++;\n\t  }\n      f = fcol(row,col);\n      FORCC if (c != f && sum[c+4])\n\timage[row*width+col][c] = sum[c] / sum[c+4];\n    }\n}\n\nvoid CLASS lin_interpolate_loop(int code[16][16][32],int size)\n{\n  int row;\n  for (row=1; row < height-1; row++)\n    {\n      int col,*ip;\n      ushort *pix;\n      for (col=1; col < width-1; col++) {\n        int i;\n        int sum[4];\n        pix = image[row*width+col];\n        ip = code[row % size][col % size];\n        memset (sum, 0, sizeof sum);\n        for (i=*ip++; i--; ip+=3)\n          sum[ip[2]] += pix[ip[0]] << ip[1];\n        for (i=colors; --i; ip+=2)\n          pix[ip[0]] = sum[ip[0]] * ip[1] >> 8;\n      }\n    }\n}\n\nvoid CLASS lin_interpolate()\n{\n  int code[16][16][32], size=16, *ip, sum[4];\n  int f, c, x, y, row, col, shift, color;\n\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Bilinear interpolation...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,0,3);\n#endif\n\n  if (filters == 2) size = 6;\n  border_interpolate(1);\n  for (row=0; row < size; row++)\n    for (col=0; col < size; col++) {\n      ip = code[row][col]+1;\n      f = fcol(row,col);\n      memset (sum, 0, sizeof sum);\n      for (y=-1; y <= 1; y++)\n\tfor (x=-1; x <= 1; x++) {\n\t  shift = (y==0) + (x==0);\n\t  color = fcol(row+y,col+x);\n\t  if (color == f) continue;\n\t  *ip++ = (width*y + x)*4 + color;\n\t  *ip++ = shift;\n\t  *ip++ = color;\n\t  sum[color] += 1 << shift;\n\t}\n      code[row][col][0] = (ip - code[row][col]) / 3;\n      FORCC\n\tif (c != f) {\n\t  *ip++ = c;\n\t  *ip++ = 256 / sum[c];\n\t}\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,1,3);\n#endif\n  lin_interpolate_loop(code,size);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,2,3);\n#endif\n}\n\n/*\n   This algorithm is officially called:\n\n   \"Interpolation using a Threshold-based variable number of gradients\"\n\n   described in http://scien.stanford.edu/pages/labsite/1999/psych221/projects/99/tingchen/algodep/vargra.html\n\n   I've extended the basic idea to work with non-Bayer filter arrays.\n   Gradients are numbered clockwise from NW=0 to W=7.\n */\nvoid CLASS vng_interpolate()\n{\n  static const signed char *cp, terms[] = {\n    -2,-2,+0,-1,0,0x01, -2,-2,+0,+0,1,0x01, -2,-1,-1,+0,0,0x01,\n    -2,-1,+0,-1,0,0x02, -2,-1,+0,+0,0,0x03, -2,-1,+0,+1,1,0x01,\n    -2,+0,+0,-1,0,0x06, -2,+0,+0,+0,1,0x02, -2,+0,+0,+1,0,0x03,\n    -2,+1,-1,+0,0,0x04, -2,+1,+0,-1,1,0x04, -2,+1,+0,+0,0,0x06,\n    -2,+1,+0,+1,0,0x02, -2,+2,+0,+0,1,0x04, -2,+2,+0,+1,0,0x04,\n    -1,-2,-1,+0,0,0x80, -1,-2,+0,-1,0,0x01, -1,-2,+1,-1,0,0x01,\n    -1,-2,+1,+0,1,0x01, -1,-1,-1,+1,0,0x88, -1,-1,+1,-2,0,0x40,\n    -1,-1,+1,-1,0,0x22, -1,-1,+1,+0,0,0x33, -1,-1,+1,+1,1,0x11,\n    -1,+0,-1,+2,0,0x08, -1,+0,+0,-1,0,0x44, -1,+0,+0,+1,0,0x11,\n    -1,+0,+1,-2,1,0x40, -1,+0,+1,-1,0,0x66, -1,+0,+1,+0,1,0x22,\n    -1,+0,+1,+1,0,0x33, -1,+0,+1,+2,1,0x10, -1,+1,+1,-1,1,0x44,\n    -1,+1,+1,+0,0,0x66, -1,+1,+1,+1,0,0x22, -1,+1,+1,+2,0,0x10,\n    -1,+2,+0,+1,0,0x04, -1,+2,+1,+0,1,0x04, -1,+2,+1,+1,0,0x04,\n    +0,-2,+0,+0,1,0x80, +0,-1,+0,+1,1,0x88, +0,-1,+1,-2,0,0x40,\n    +0,-1,+1,+0,0,0x11, +0,-1,+2,-2,0,0x40, +0,-1,+2,-1,0,0x20,\n    +0,-1,+2,+0,0,0x30, +0,-1,+2,+1,1,0x10, +0,+0,+0,+2,1,0x08,\n    +0,+0,+2,-2,1,0x40, +0,+0,+2,-1,0,0x60, +0,+0,+2,+0,1,0x20,\n    +0,+0,+2,+1,0,0x30, +0,+0,+2,+2,1,0x10, +0,+1,+1,+0,0,0x44,\n    +0,+1,+1,+2,0,0x10, +0,+1,+2,-1,1,0x40, +0,+1,+2,+0,0,0x60,\n    +0,+1,+2,+1,0,0x20, +0,+1,+2,+2,0,0x10, +1,-2,+1,+0,0,0x80,\n    +1,-1,+1,+1,0,0x88, +1,+0,+1,+2,0,0x08, +1,+0,+2,-1,0,0x40,\n    +1,+0,+2,+1,0,0x10\n  }, chood[] = { -1,-1, -1,0, -1,+1, 0,+1, +1,+1, +1,0, +1,-1, 0,-1 };\n  ushort (*brow[5])[4], *pix;\n  int prow=8, pcol=2, *ip, *code[16][16], gval[8], gmin, gmax, sum[4];\n  int row, col, x, y, x1, x2, y1, y2, t, weight, grads, color, diag;\n  int g, diff, thold, num, c;\n\n  lin_interpolate();\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"VNG interpolation...\\n\"));\n#endif\n\n  if (filters == 1) prow = pcol = 16;\n  if (filters == 2) prow = pcol =  6;\n  ip = (int *) calloc (prow*pcol, 1280);\n  merror (ip, \"vng_interpolate()\");\n  for (row=0; row < prow; row++)\t\t/* Precalculate for VNG */\n    for (col=0; col < pcol; col++) {\n      code[row][col] = ip;\n      for (cp=terms, t=0; t < 64; t++) {\n\ty1 = *cp++;  x1 = *cp++;\n\ty2 = *cp++;  x2 = *cp++;\n\tweight = *cp++;\n\tgrads = *cp++;\n\tcolor = fcol(row+y1,col+x1);\n\tif (fcol(row+y2,col+x2) != color) continue;\n\tdiag = (fcol(row,col+1) == color && fcol(row+1,col) == color) ? 2:1;\n\tif (abs(y1-y2) == diag && abs(x1-x2) == diag) continue;\n\t*ip++ = (y1*width + x1)*4 + color;\n\t*ip++ = (y2*width + x2)*4 + color;\n\t*ip++ = weight;\n\tfor (g=0; g < 8; g++)\n\t  if (grads & 1<<g) *ip++ = g;\n\t*ip++ = -1;\n      }\n      *ip++ = INT_MAX;\n      for (cp=chood, g=0; g < 8; g++) {\n\ty = *cp++;  x = *cp++;\n\t*ip++ = (y*width + x) * 4;\n\tcolor = fcol(row,col);\n\tif (fcol(row+y,col+x) != color && fcol(row+y*2,col+x*2) == color)\n\t  *ip++ = (y*width + x) * 8 + color;\n\telse\n\t  *ip++ = 0;\n      }\n    }\n  brow[4] = (ushort (*)[4]) calloc (width*3, sizeof **brow);\n  merror (brow[4], \"vng_interpolate()\");\n  for (row=0; row < 3; row++)\n    brow[row] = brow[4] + row*width;\n  for (row=2; row < height-2; row++) {\t\t/* Do VNG interpolation */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if(!((row-2)%256))RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,(row-2)/256+1,((height-3)/256)+1);\n#endif\n    for (col=2; col < width-2; col++) {\n      pix = image[row*width+col];\n      ip = code[row % prow][col % pcol];\n      memset (gval, 0, sizeof gval);\n      while ((g = ip[0]) != INT_MAX) {\t\t/* Calculate gradients */\n\tdiff = ABS(pix[g] - pix[ip[1]]) << ip[2];\n\tgval[ip[3]] += diff;\n\tip += 5;\n\tif ((g = ip[-1]) == -1) continue;\n\tgval[g] += diff;\n\twhile ((g = *ip++) != -1)\n\t  gval[g] += diff;\n      }\n      ip++;\n      gmin = gmax = gval[0];\t\t\t/* Choose a threshold */\n      for (g=1; g < 8; g++) {\n\tif (gmin > gval[g]) gmin = gval[g];\n\tif (gmax < gval[g]) gmax = gval[g];\n      }\n      if (gmax == 0) {\n\tmemcpy (brow[2][col], pix, sizeof *image);\n\tcontinue;\n      }\n      thold = gmin + (gmax >> 1);\n      memset (sum, 0, sizeof sum);\n      color = fcol(row,col);\n      for (num=g=0; g < 8; g++,ip+=2) {\t\t/* Average the neighbors */\n\tif (gval[g] <= thold) {\n\t  FORCC\n\t    if (c == color && ip[1])\n\t      sum[c] += (pix[c] + pix[ip[1]]) >> 1;\n\t    else\n\t      sum[c] += pix[ip[0] + c];\n\t  num++;\n\t}\n      }\n      FORCC {\t\t\t\t\t/* Save to buffer */\n\tt = pix[color];\n\tif (c != color)\n\t  t += (sum[c] - sum[color]) / num;\n\tbrow[2][col][c] = CLIP(t);\n      }\n    }\n    if (row > 3)\t\t\t\t/* Write buffer to image */\n      memcpy (image[(row-2)*width+2], brow[0]+2, (width-4)*sizeof *image);\n    for (g=0; g < 4; g++)\n      brow[(g-1) & 3] = brow[g];\n  }\n  memcpy (image[(row-2)*width+2], brow[0]+2, (width-4)*sizeof *image);\n  memcpy (image[(row-1)*width+2], brow[1]+2, (width-4)*sizeof *image);\n  free (brow[4]);\n  free (code[0][0]);\n}\n\n/*\n   Patterned Pixel Grouping Interpolation by Alain Desbiolles\n*/\nvoid CLASS ppg_interpolate()\n{\n  int dir[5] = { 1, width, -1, -width, 1 };\n  int row, col, diff[2], guess[2], c, d, i;\n  ushort (*pix)[4];\n\n  border_interpolate(3);\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"PPG interpolation...\\n\"));\n#endif\n\n/*  Fill in the green layer with gradients and pattern recognition: */\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,0,3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row=3; row < height-3; row++)\n    for (col=3+(FC(row,3) & 1), c=FC(row,col); col < width-3; col+=2) {\n      pix = image + row*width+col;\n      for (i=0; (d=dir[i]) > 0; i++) {\n\tguess[i] = (pix[-d][1] + pix[0][c] + pix[d][1]) * 2\n\t\t      - pix[-2*d][c] - pix[2*d][c];\n\tdiff[i] = ( ABS(pix[-2*d][c] - pix[ 0][c]) +\n\t\t    ABS(pix[ 2*d][c] - pix[ 0][c]) +\n\t\t    ABS(pix[  -d][1] - pix[ d][1]) ) * 3 +\n\t\t  ( ABS(pix[ 3*d][1] - pix[ d][1]) +\n\t\t    ABS(pix[-3*d][1] - pix[-d][1]) ) * 2;\n      }\n      d = dir[i = diff[0] > diff[1]];\n      pix[0][1] = ULIM(guess[i] >> 2, pix[d][1], pix[-d][1]);\n    }\n/*  Calculate red and blue for each green pixel:\t\t*/\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,1,3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row=1; row < height-1; row++)\n    for (col=1+(FC(row,2) & 1), c=FC(row,col+1); col < width-1; col+=2) {\n      pix = image + row*width+col;\n      for (i=0; (d=dir[i]) > 0; c=2-c, i++)\n\tpix[0][c] = CLIP((pix[-d][c] + pix[d][c] + 2*pix[0][1]\n\t\t\t- pix[-d][1] - pix[d][1]) >> 1);\n    }\n/*  Calculate blue for red pixels and vice versa:\t\t*/\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,2,3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row=1; row < height-1; row++)\n    for (col=1+(FC(row,1) & 1), c=2-FC(row,col); col < width-1; col+=2) {\n      pix = image + row*width+col;\n      for (i=0; (d=dir[i]+dir[i+1]) > 0; i++) {\n\tdiff[i] = ABS(pix[-d][c] - pix[d][c]) +\n\t\t  ABS(pix[-d][1] - pix[0][1]) +\n\t\t  ABS(pix[ d][1] - pix[0][1]);\n\tguess[i] = pix[-d][c] + pix[d][c] + 2*pix[0][1]\n\t\t - pix[-d][1] - pix[d][1];\n      }\n      if (diff[0] != diff[1])\n\tpix[0][c] = CLIP(guess[diff[0] > diff[1]] >> 1);\n      else\n\tpix[0][c] = CLIP((guess[0]+guess[1]) >> 2);\n    }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n/*\n   Adaptive Homogeneity-Directed interpolation is based on\n   the work of Keigo Hirakawa, Thomas Parks, and Paul Lee.\n */\n#define TS 256\t\t/* Tile Size */\nstatic float dcraw_cbrt[0x10000] = {-1.0f};\n\nstatic inline float calc_64cbrt(float f)\n{\n  unsigned u;\n  static float lower = dcraw_cbrt[0];\n  static float upper = dcraw_cbrt[0xffff];\n\n  if (f <= 0) {\n    return lower;\n  }\n\n  u = (unsigned) f;\n  if (u >= 0xffff) {\n    return upper;\n  }\n  return dcraw_cbrt[u];\n}\nvoid CLASS ahd_interpolate_green_h_and_v(int top, int left, ushort (*out_rgb)[TS][TS][3])\n{\n  int row, col;\n  int c, val;\n  ushort (*pix)[4];\n  const int rowlimit = MIN(top+TS, height-2);\n  const int collimit = MIN(left+TS, width-2);\n\n  for (row = top; row < rowlimit; row++) {\n    col = left + (FC(row,left) & 1);\n    for (c = FC(row,col); col < collimit; col+=2) {\n      pix = image + row*width+col;\n      val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2\n            - pix[-2][c] - pix[2][c]) >> 2;\n      out_rgb[0][row-top][col-left][1] = ULIM(val,pix[-1][1],pix[1][1]);\n      val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2\n            - pix[-2*width][c] - pix[2*width][c]) >> 2;\n      out_rgb[1][row-top][col-left][1] = ULIM(val,pix[-width][1],pix[width][1]);\n    }\n  }\n}\nvoid CLASS ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][3], short (*out_lab)[TS][3], const float (&xyz_cam)[3][4])\n{\n  unsigned row, col;\n  int c, val;\n  ushort (*pix)[4];\n  ushort (*rix)[3];\n  short (*lix)[3];\n  float xyz[3];\n  const unsigned num_pix_per_row = 4*width;\n  const unsigned rowlimit = MIN(top+TS-1, height-3);\n  const unsigned collimit = MIN(left+TS-1, width-3);\n  ushort *pix_above;\n  ushort *pix_below;\n  int t1, t2;\n\n  for (row = top+1; row < rowlimit; row++) {\n    pix = image + row*width + left;\n    rix = &inout_rgb[row-top][0];\n    lix = &out_lab[row-top][0];\n\n    for (col = left+1; col < collimit; col++) {\n      pix++;\n      pix_above = &pix[0][0] - num_pix_per_row;\n      pix_below = &pix[0][0] + num_pix_per_row;\n      rix++;\n      lix++;\n\n      c = 2 - FC(row, col);\n\n      if (c == 1) {\n        c = FC(row+1,col);\n\tt1 = 2-c;\n        val = pix[0][1] + (( pix[-1][t1] + pix[1][t1]\n              - rix[-1][1] - rix[1][1] ) >> 1);\n        rix[0][t1] = CLIP(val);\n        val = pix[0][1] + (( pix_above[c] + pix_below[c]\n              - rix[-TS][1] - rix[TS][1] ) >> 1);\n      } else {\n\tt1 = -4+c; /* -4+c: pixel of color c to the left */\n\tt2 = 4+c; /* 4+c: pixel of color c to the right */\n        val = rix[0][1] + (( pix_above[t1] + pix_above[t2]\n              + pix_below[t1] + pix_below[t2]\n              - rix[-TS-1][1] - rix[-TS+1][1]\n              - rix[+TS-1][1] - rix[+TS+1][1] + 1) >> 2);\n      }\n      rix[0][c] = CLIP(val);\n      c = FC(row,col);\n      rix[0][c] = pix[0][c];\n      xyz[0] = xyz[1] = xyz[2] = 0.5;\n      FORC3 {\n\t/*\n\t * Technically this ought to be FORCC, but the rest of\n\t * ahd_interpolate() assumes 3 colors so let's help the compiler.\n\t */\n        xyz[0] += xyz_cam[0][c] * rix[0][c];\n        xyz[1] += xyz_cam[1][c] * rix[0][c];\n        xyz[2] += xyz_cam[2][c] * rix[0][c];\n      }\n      FORC3 {\n\txyz[c] = calc_64cbrt(xyz[c]);\n      }\n      lix[0][0] = (116 * xyz[1] - 16);\n      lix[0][1] = 500 * (xyz[0] - xyz[1]);\n      lix[0][2] = 200 * (xyz[1] - xyz[2]);\n    }\n  }\n}\nvoid CLASS ahd_interpolate_r_and_b_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][TS][3], short (*out_lab)[TS][TS][3], const float (&xyz_cam)[3][4])\n{\n  int direction;\n  for (direction = 0; direction < 2; direction++) {\n    ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(top, left, inout_rgb[direction], out_lab[direction], xyz_cam);\n  }\n}\nvoid CLASS ahd_interpolate_build_homogeneity_map(int top, int left, short (*lab)[TS][TS][3], char (*out_homogeneity_map)[TS][2])\n{\n  int row, col;\n  int tr, tc;\n  int direction;\n  int i;\n  short (*lix)[3];\n  short (*lixs[2])[3];\n  short *adjacent_lix;\n  unsigned ldiff[2][4], abdiff[2][4], leps, abeps;\n  static const int dir[4] = { -1, 1, -TS, TS };\n  const int rowlimit = MIN(top+TS-2, height-4);\n  const int collimit = MIN(left+TS-2, width-4);\n  int homogeneity;\n  char (*homogeneity_map_p)[2];\n\n  memset (out_homogeneity_map, 0, 2*TS*TS);\n\n  for (row=top+2; row < rowlimit; row++) {\n    tr = row-top;\n    homogeneity_map_p = &out_homogeneity_map[tr][1];\n    for (direction=0; direction < 2; direction++) {\n      lixs[direction] = &lab[direction][tr][1];\n    }\n\n    for (col=left+2; col < collimit; col++) {\n      tc = col-left;\n      homogeneity_map_p++;\n\n      for (direction=0; direction < 2; direction++) {\n        lix = ++lixs[direction];\n        for (i=0; i < 4; i++) {\n\t  adjacent_lix = lix[dir[i]];\n          ldiff[direction][i] = ABS(lix[0][0]-adjacent_lix[0]);\n          abdiff[direction][i] = SQR(lix[0][1]-adjacent_lix[1])\n            + SQR(lix[0][2]-adjacent_lix[2]);\n        }\n      }\n      leps = MIN(MAX(ldiff[0][0],ldiff[0][1]),\n          MAX(ldiff[1][2],ldiff[1][3]));\n      abeps = MIN(MAX(abdiff[0][0],abdiff[0][1]),\n          MAX(abdiff[1][2],abdiff[1][3]));\n      for (direction=0; direction < 2; direction++) {\n\thomogeneity = 0;\n        for (i=0; i < 4; i++) {\n          if (ldiff[direction][i] <= leps && abdiff[direction][i] <= abeps) {\n\t    homogeneity++;\n\t  }\n\t}\n\thomogeneity_map_p[0][direction] = homogeneity;\n      }\n    }\n  }\n}\nvoid CLASS ahd_interpolate_combine_homogeneous_pixels(int top, int left, ushort (*rgb)[TS][TS][3], char (*homogeneity_map)[TS][2])\n{\n  int row, col;\n  int tr, tc;\n  int i, j;\n  int direction;\n  int hm[2];\n  int c;\n  const int rowlimit = MIN(top+TS-3, height-5);\n  const int collimit = MIN(left+TS-3, width-5);\n\n  ushort (*pix)[4];\n  ushort (*rix[2])[3];\n\n  for (row=top+3; row < rowlimit; row++) {\n    tr = row-top;\n    pix = &image[row*width+left+2];\n    for (direction = 0; direction < 2; direction++) {\n      rix[direction] = &rgb[direction][tr][2];\n    }\n\n    for (col=left+3; col < collimit; col++) {\n      tc = col-left;\n      pix++;\n      for (direction = 0; direction < 2; direction++) {\n        rix[direction]++;\n      }\n\n      for (direction=0; direction < 2; direction++) {\n        hm[direction] = 0;\n        for (i=tr-1; i <= tr+1; i++) {\n          for (j=tc-1; j <= tc+1; j++) {\n            hm[direction] += homogeneity_map[i][j][direction];\n          }\n        }\n      }\n      if (hm[0] != hm[1]) {\n        memcpy(pix[0], rix[hm[1] > hm[0]][0], 3 * sizeof(ushort));\n      } else {\n        FORC3 {\n          pix[0][c] = (rix[0][0][c] + rix[1][0][c]) >> 1;\n        }\n      }\n    }\n  }\n}\nvoid CLASS ahd_interpolate()\n{\n  int i, j, k, top, left;\n  float xyz_cam[3][4],r;\n  char *buffer;\n  ushort (*rgb)[TS][TS][3];\n  short (*lab)[TS][TS][3];\n  char (*homo)[TS][2];\n  int terminate_flag = 0;\n\n  if(dcraw_cbrt[0]<-0.1){\n      for (i=0x10000-1; i >=0; i--) {\n          r = i / 65535.0;\n          dcraw_cbrt[i] = 64.0*(r > 0.008856 ? pow((double)r,1/3.0) : 7.787*r + 16/116.0);\n      }\n  }\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"AHD interpolation...\\n\"));\n#endif\n\n  for (i=0; i < 3; i++) {\n    for (j=0; j < colors; j++) {\n      xyz_cam[i][j] = 0;\n      for (k=0; k < 3; k++) {\n        xyz_cam[i][j] += xyz_rgb[i][k] * rgb_cam[k][j] / d65_white[i];\n      }\n    }\n  }\n\n  border_interpolate(5);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel private(buffer,rgb,lab,homo,top,left,i,j,k) shared(xyz_cam,terminate_flag)\n#endif\n#endif\n  {\n    buffer = (char *) malloc (26*TS*TS);\t\t/* 1664 kB */\n    merror (buffer, \"ahd_interpolate()\");\n    rgb  = (ushort(*)[TS][TS][3]) buffer;\n    lab  = (short (*)[TS][TS][3])(buffer + 12*TS*TS);\n    homo = (char  (*)[TS][2])    (buffer + 24*TS*TS);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp for schedule(dynamic)\n#endif\n#endif\n    for (top=2; top < height-5; top += TS-6){\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n        if(0== omp_get_thread_num())\n#endif\n           if(callbacks.progress_cb) {                                     \n               int rr = (*callbacks.progress_cb)(callbacks.progresscb_data,LIBRAW_PROGRESS_INTERPOLATE,top-2,height-7);\n               if(rr)\n                   terminate_flag = 1;\n           }\n#endif\n        for (left=2; !terminate_flag && (left < width-5); left += TS-6) {\n            ahd_interpolate_green_h_and_v(top, left, rgb);\n            ahd_interpolate_r_and_b_and_convert_to_cielab(top, left, rgb, lab, xyz_cam);\n            ahd_interpolate_build_homogeneity_map(top, left, lab, homo);\n            ahd_interpolate_combine_homogeneous_pixels(top, left, rgb, homo);\n      }\n    }\n    free (buffer);\n  }\n#ifdef LIBRAW_LIBRARY_BUILD \n  if(terminate_flag)\n      throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#endif\n}\n\n\n\n#undef TS\n\n#else\n/*\n   Adaptive Homogeneity-Directed interpolation is based on\n   the work of Keigo Hirakawa, Thomas Parks, and Paul Lee.\n */\n#define TS 256\t\t/* Tile Size */\n\nvoid CLASS ahd_interpolate()\n{\n  int i, j, k, top, left, row, col, tr, tc, c, d, val, hm[2];\n  ushort (*pix)[4], (*rix)[3];\n  static const int dir[4] = { -1, 1, -TS, TS };\n  unsigned ldiff[2][4], abdiff[2][4], leps, abeps;\n  float r, cbrt[0x10000], xyz[3], xyz_cam[3][4];\n  ushort (*rgb)[TS][TS][3];\n   short (*lab)[TS][TS][3], (*lix)[3];\n   char (*homo)[TS][TS], *buffer;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"AHD interpolation...\\n\"));\n#endif\n\n  for (i=0; i < 0x10000; i++) {\n    r = i / 65535.0;\n    cbrt[i] = r > 0.008856 ? pow((double)r,(double)(1/3.0)) : 7.787*r + 16/116.0;\n  }\n  for (i=0; i < 3; i++)\n    for (j=0; j < colors; j++)\n      for (xyz_cam[i][j] = k=0; k < 3; k++)\n\txyz_cam[i][j] += xyz_rgb[i][k] * rgb_cam[k][j] / d65_white[i];\n\n  border_interpolate(5);\n  buffer = (char *) malloc (26*TS*TS);\t\t/* 1664 kB */\n  merror (buffer, \"ahd_interpolate()\");\n  rgb  = (ushort(*)[TS][TS][3]) buffer;\n  lab  = (short (*)[TS][TS][3])(buffer + 12*TS*TS);\n  homo = (char  (*)[TS][TS])   (buffer + 24*TS*TS);\n\n  for (top=2; top < height-5; top += TS-6)\n    for (left=2; left < width-5; left += TS-6) {\n\n/*  Interpolate green horizontally and vertically:\t\t*/\n      for (row = top; row < top+TS && row < height-2; row++) {\n\tcol = left + (FC(row,left) & 1);\n\tfor (c = FC(row,col); col < left+TS && col < width-2; col+=2) {\n\t  pix = image + row*width+col;\n\t  val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2\n\t\t- pix[-2][c] - pix[2][c]) >> 2;\n\t  rgb[0][row-top][col-left][1] = ULIM(val,pix[-1][1],pix[1][1]);\n\t  val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2\n\t\t- pix[-2*width][c] - pix[2*width][c]) >> 2;\n\t  rgb[1][row-top][col-left][1] = ULIM(val,pix[-width][1],pix[width][1]);\n\t}\n      }\n/*  Interpolate red and blue, and convert to CIELab:\t\t*/\n      for (d=0; d < 2; d++)\n\tfor (row=top+1; row < top+TS-1 && row < height-3; row++)\n\t  for (col=left+1; col < left+TS-1 && col < width-3; col++) {\n\t    pix = image + row*width+col;\n\t    rix = &rgb[d][row-top][col-left];\n\t    lix = &lab[d][row-top][col-left];\n\t    if ((c = 2 - FC(row,col)) == 1) {\n\t      c = FC(row+1,col);\n\t      val = pix[0][1] + (( pix[-1][2-c] + pix[1][2-c]\n\t\t\t\t - rix[-1][1] - rix[1][1] ) >> 1);\n\t      rix[0][2-c] = CLIP(val);\n\t      val = pix[0][1] + (( pix[-width][c] + pix[width][c]\n\t\t\t\t - rix[-TS][1] - rix[TS][1] ) >> 1);\n\t    } else\n\t      val = rix[0][1] + (( pix[-width-1][c] + pix[-width+1][c]\n\t\t\t\t + pix[+width-1][c] + pix[+width+1][c]\n\t\t\t\t - rix[-TS-1][1] - rix[-TS+1][1]\n\t\t\t\t - rix[+TS-1][1] - rix[+TS+1][1] + 1) >> 2);\n\t    rix[0][c] = CLIP(val);\n\t    c = FC(row,col);\n\t    rix[0][c] = pix[0][c];\n\t    xyz[0] = xyz[1] = xyz[2] = 0.5;\n\t    FORCC {\n\t      xyz[0] += xyz_cam[0][c] * rix[0][c];\n\t      xyz[1] += xyz_cam[1][c] * rix[0][c];\n\t      xyz[2] += xyz_cam[2][c] * rix[0][c];\n\t    }\n\t    xyz[0] = cbrt[CLIP((int) xyz[0])];\n\t    xyz[1] = cbrt[CLIP((int) xyz[1])];\n\t    xyz[2] = cbrt[CLIP((int) xyz[2])];\n\t    lix[0][0] = 64 * (116 * xyz[1] - 16);\n\t    lix[0][1] = 64 * 500 * (xyz[0] - xyz[1]);\n\t    lix[0][2] = 64 * 200 * (xyz[1] - xyz[2]);\n\t  }\n/*  Build homogeneity maps from the CIELab images:\t\t*/\n      memset (homo, 0, 2*TS*TS);\n      for (row=top+2; row < top+TS-2 && row < height-4; row++) {\n\ttr = row-top;\n\tfor (col=left+2; col < left+TS-2 && col < width-4; col++) {\n\t  tc = col-left;\n\t  for (d=0; d < 2; d++) {\n\t    lix = &lab[d][tr][tc];\n\t    for (i=0; i < 4; i++) {\n\t       ldiff[d][i] = ABS(lix[0][0]-lix[dir[i]][0]);\n\t      abdiff[d][i] = SQR(lix[0][1]-lix[dir[i]][1])\n\t\t\t   + SQR(lix[0][2]-lix[dir[i]][2]);\n\t    }\n\t  }\n\t  leps = MIN(MAX(ldiff[0][0],ldiff[0][1]),\n\t\t     MAX(ldiff[1][2],ldiff[1][3]));\n\t  abeps = MIN(MAX(abdiff[0][0],abdiff[0][1]),\n\t\t      MAX(abdiff[1][2],abdiff[1][3]));\n\t  for (d=0; d < 2; d++)\n\t    for (i=0; i < 4; i++)\n\t      if (ldiff[d][i] <= leps && abdiff[d][i] <= abeps)\n\t\thomo[d][tr][tc]++;\n\t}\n      }\n/*  Combine the most homogenous pixels for the final result:\t*/\n      for (row=top+3; row < top+TS-3 && row < height-5; row++) {\n\ttr = row-top;\n\tfor (col=left+3; col < left+TS-3 && col < width-5; col++) {\n\t  tc = col-left;\n\t  for (d=0; d < 2; d++)\n\t    for (hm[d]=0, i=tr-1; i <= tr+1; i++)\n\t      for (j=tc-1; j <= tc+1; j++)\n\t\thm[d] += homo[d][i][j];\n\t  if (hm[0] != hm[1])\n\t    FORC3 image[row*width+col][c] = rgb[hm[1] > hm[0]][tr][tc][c];\n\t  else\n\t    FORC3 image[row*width+col][c] =\n\t\t(rgb[0][tr][tc][c] + rgb[1][tr][tc][c]) >> 1;\n\t}\n      }\n    }\n  free (buffer);\n}\n#undef TS\n#endif\n\nvoid CLASS median_filter()\n{\n  ushort (*pix)[4];\n  int pass, c, i, j, k, med[9];\n  static const uchar opt[] =\t/* Optimal 9-element median search */\n  { 1,2, 4,5, 7,8, 0,1, 3,4, 6,7, 1,2, 4,5, 7,8,\n    0,3, 5,8, 4,7, 3,6, 1,4, 2,5, 4,7, 4,2, 6,4, 4,2 };\n\n  for (pass=1; pass <= med_passes; pass++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n      RUN_CALLBACK(LIBRAW_PROGRESS_MEDIAN_FILTER,pass-1,med_passes);\n#endif\n#ifdef DCRAW_VERBOSE\n    if (verbose)\n      fprintf (stderr,_(\"Median filter pass %d...\\n\"), pass);\n#endif\n    for (c=0; c < 3; c+=2) {\n      for (pix = image; pix < image+width*height; pix++)\n\tpix[0][3] = pix[0][c];\n      for (pix = image+width; pix < image+width*(height-1); pix++) {\n\tif ((pix-image+1) % width < 2) continue;\n\tfor (k=0, i = -width; i <= width; i += width)\n\t  for (j = i-1; j <= i+1; j++)\n\t    med[k++] = pix[j][3] - pix[j][1];\n\tfor (i=0; i < sizeof opt; i+=2)\n\t  if     (med[opt[i]] > med[opt[i+1]])\n\t    SWAP (med[opt[i]] , med[opt[i+1]]);\n\tpix[0][c] = CLIP(med[4] + pix[0][1]);\n      }\n    }\n  }\n}\n\nvoid CLASS blend_highlights()\n{\n  int clip=INT_MAX, row, col, c, i, j;\n  static const float trans[2][4][4] =\n  { { { 1,1,1 }, { 1.7320508,-1.7320508,0 }, { -1,-1,2 } },\n    { { 1,1,1,1 }, { 1,-1,1,-1 }, { 1,1,-1,-1 }, { 1,-1,-1,1 } } };\n  static const float itrans[2][4][4] =\n  { { { 1,0.8660254,-0.5 }, { 1,-0.8660254,-0.5 }, { 1,0,1 } },\n    { { 1,1,1,1 }, { 1,-1,1,-1 }, { 1,1,-1,-1 }, { 1,-1,-1,1 } } };\n  float cam[2][4], lab[2][4], sum[2], chratio;\n\n  if ((unsigned) (colors-3) > 1) return;\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Blending highlights...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,0,2);\n#endif\n  FORCC if (clip > (i = 65535*pre_mul[c])) clip = i;\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++) {\n      FORCC if (image[row*width+col][c] > clip) break;\n      if (c == colors) continue;\n      FORCC {\n\tcam[0][c] = image[row*width+col][c];\n\tcam[1][c] = MIN(cam[0][c],clip);\n      }\n      for (i=0; i < 2; i++) {\n\tFORCC for (lab[i][c]=j=0; j < colors; j++)\n\t  lab[i][c] += trans[colors-3][c][j] * cam[i][j];\n\tfor (sum[i]=0,c=1; c < colors; c++)\n\t  sum[i] += SQR(lab[i][c]);\n      }\n      chratio = sqrt(sum[1]/sum[0]);\n      for (c=1; c < colors; c++)\n\tlab[0][c] *= chratio;\n      FORCC for (cam[0][c]=j=0; j < colors; j++)\n\tcam[0][c] += itrans[colors-3][c][j] * lab[0][j];\n      FORCC image[row*width+col][c] = cam[0][c] / colors;\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,1,2);\n#endif\n}\n\n#define SCALE (4 >> shrink)\nvoid CLASS recover_highlights()\n{\n  float *map, sum, wgt, grow;\n  int hsat[4], count, spread, change, val, i;\n  unsigned high, wide, mrow, mcol, row, col, kc, c, d, y, x;\n  ushort *pixel;\n  static const signed char dir[8][2] =\n    { {-1,-1}, {-1,0}, {-1,1}, {0,1}, {1,1}, {1,0}, {1,-1}, {0,-1} };\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Rebuilding highlights...\\n\"));\n#endif\n\n  grow = pow (2.0, 4-highlight);\n  FORCC hsat[c] = 32000 * pre_mul[c];\n  for (kc=0, c=1; c < colors; c++)\n    if (pre_mul[kc] < pre_mul[c]) kc = c;\n  high = height / SCALE;\n  wide =  width / SCALE;\n  map = (float *) calloc (high*wide, sizeof *map);\n  merror (map, \"recover_highlights()\");\n  FORCC if (c != kc) {\n#ifdef LIBRAW_LIBRARY_BUILD\n      RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,c-1,colors-1);\n#endif\n    memset (map, 0, high*wide*sizeof *map);\n    for (mrow=0; mrow < high; mrow++)\n      for (mcol=0; mcol < wide; mcol++) {\n\tsum = wgt = count = 0;\n\tfor (row = mrow*SCALE; row < (mrow+1)*SCALE; row++)\n\t  for (col = mcol*SCALE; col < (mcol+1)*SCALE; col++) {\n\t    pixel = image[row*width+col];\n\t    if (pixel[c] / hsat[c] == 1 && pixel[kc] > 24000) {\n\t      sum += pixel[c];\n\t      wgt += pixel[kc];\n\t      count++;\n\t    }\n\t  }\n\tif (count == SCALE*SCALE)\n\t  map[mrow*wide+mcol] = sum / wgt;\n      }\n    for (spread = 32/grow; spread--; ) {\n      for (mrow=0; mrow < high; mrow++)\n\tfor (mcol=0; mcol < wide; mcol++) {\n\t  if (map[mrow*wide+mcol]) continue;\n\t  sum = count = 0;\n\t  for (d=0; d < 8; d++) {\n\t    y = mrow + dir[d][0];\n\t    x = mcol + dir[d][1];\n\t    if (y < high && x < wide && map[y*wide+x] > 0) {\n\t      sum  += (1 + (d & 1)) * map[y*wide+x];\n\t      count += 1 + (d & 1);\n\t    }\n\t  }\n\t  if (count > 3)\n\t    map[mrow*wide+mcol] = - (sum+grow) / (count+grow);\n\t}\n      for (change=i=0; i < high*wide; i++)\n\tif (map[i] < 0) {\n\t  map[i] = -map[i];\n\t  change = 1;\n\t}\n      if (!change) break;\n    }\n    for (i=0; i < high*wide; i++)\n      if (map[i] == 0) map[i] = 1;\n    for (mrow=0; mrow < high; mrow++)\n      for (mcol=0; mcol < wide; mcol++) {\n\tfor (row = mrow*SCALE; row < (mrow+1)*SCALE; row++)\n\t  for (col = mcol*SCALE; col < (mcol+1)*SCALE; col++) {\n\t    pixel = image[row*width+col];\n\t    if (pixel[c] / hsat[c] > 1) {\n\t      val = pixel[kc] * map[mrow*wide+mcol];\n\t      if (pixel[c] < val) pixel[c] = CLIP(val);\n\t    }\n\t  }\n      }\n  }\n  free (map);\n}\n#undef SCALE\n\nvoid CLASS tiff_get (unsigned base,\n\tunsigned *tag, unsigned *type, unsigned *len, unsigned *save)\n{\n  *tag  = get2();\n  *type = get2();\n  *len  = get4();\n  *save = ftell(ifp) + 4;\n  if (*len * (\"11124811248488\"[*type < 14 ? *type:0]-'0') > 4)\n    fseek (ifp, get4()+base, SEEK_SET);\n}\n\nvoid CLASS parse_thumb_note (int base, unsigned toff, unsigned tlen)\n{\n  unsigned entries, tag, type, len, save;\n\n  entries = get2();\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    if (tag == toff) thumb_offset = get4()+base;\n    if (tag == tlen) thumb_length = get4();\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n#line 5642 \"dcraw/dcraw.c\"\nvoid CLASS parse_makernote (int base, int uptag)\n{\n  static const uchar xlat[2][256] = {\n  { 0xc1,0xbf,0x6d,0x0d,0x59,0xc5,0x13,0x9d,0x83,0x61,0x6b,0x4f,0xc7,0x7f,0x3d,0x3d,\n    0x53,0x59,0xe3,0xc7,0xe9,0x2f,0x95,0xa7,0x95,0x1f,0xdf,0x7f,0x2b,0x29,0xc7,0x0d,\n    0xdf,0x07,0xef,0x71,0x89,0x3d,0x13,0x3d,0x3b,0x13,0xfb,0x0d,0x89,0xc1,0x65,0x1f,\n    0xb3,0x0d,0x6b,0x29,0xe3,0xfb,0xef,0xa3,0x6b,0x47,0x7f,0x95,0x35,0xa7,0x47,0x4f,\n    0xc7,0xf1,0x59,0x95,0x35,0x11,0x29,0x61,0xf1,0x3d,0xb3,0x2b,0x0d,0x43,0x89,0xc1,\n    0x9d,0x9d,0x89,0x65,0xf1,0xe9,0xdf,0xbf,0x3d,0x7f,0x53,0x97,0xe5,0xe9,0x95,0x17,\n    0x1d,0x3d,0x8b,0xfb,0xc7,0xe3,0x67,0xa7,0x07,0xf1,0x71,0xa7,0x53,0xb5,0x29,0x89,\n    0xe5,0x2b,0xa7,0x17,0x29,0xe9,0x4f,0xc5,0x65,0x6d,0x6b,0xef,0x0d,0x89,0x49,0x2f,\n    0xb3,0x43,0x53,0x65,0x1d,0x49,0xa3,0x13,0x89,0x59,0xef,0x6b,0xef,0x65,0x1d,0x0b,\n    0x59,0x13,0xe3,0x4f,0x9d,0xb3,0x29,0x43,0x2b,0x07,0x1d,0x95,0x59,0x59,0x47,0xfb,\n    0xe5,0xe9,0x61,0x47,0x2f,0x35,0x7f,0x17,0x7f,0xef,0x7f,0x95,0x95,0x71,0xd3,0xa3,\n    0x0b,0x71,0xa3,0xad,0x0b,0x3b,0xb5,0xfb,0xa3,0xbf,0x4f,0x83,0x1d,0xad,0xe9,0x2f,\n    0x71,0x65,0xa3,0xe5,0x07,0x35,0x3d,0x0d,0xb5,0xe9,0xe5,0x47,0x3b,0x9d,0xef,0x35,\n    0xa3,0xbf,0xb3,0xdf,0x53,0xd3,0x97,0x53,0x49,0x71,0x07,0x35,0x61,0x71,0x2f,0x43,\n    0x2f,0x11,0xdf,0x17,0x97,0xfb,0x95,0x3b,0x7f,0x6b,0xd3,0x25,0xbf,0xad,0xc7,0xc5,\n    0xc5,0xb5,0x8b,0xef,0x2f,0xd3,0x07,0x6b,0x25,0x49,0x95,0x25,0x49,0x6d,0x71,0xc7 },\n  { 0xa7,0xbc,0xc9,0xad,0x91,0xdf,0x85,0xe5,0xd4,0x78,0xd5,0x17,0x46,0x7c,0x29,0x4c,\n    0x4d,0x03,0xe9,0x25,0x68,0x11,0x86,0xb3,0xbd,0xf7,0x6f,0x61,0x22,0xa2,0x26,0x34,\n    0x2a,0xbe,0x1e,0x46,0x14,0x68,0x9d,0x44,0x18,0xc2,0x40,0xf4,0x7e,0x5f,0x1b,0xad,\n    0x0b,0x94,0xb6,0x67,0xb4,0x0b,0xe1,0xea,0x95,0x9c,0x66,0xdc,0xe7,0x5d,0x6c,0x05,\n    0xda,0xd5,0xdf,0x7a,0xef,0xf6,0xdb,0x1f,0x82,0x4c,0xc0,0x68,0x47,0xa1,0xbd,0xee,\n    0x39,0x50,0x56,0x4a,0xdd,0xdf,0xa5,0xf8,0xc6,0xda,0xca,0x90,0xca,0x01,0x42,0x9d,\n    0x8b,0x0c,0x73,0x43,0x75,0x05,0x94,0xde,0x24,0xb3,0x80,0x34,0xe5,0x2c,0xdc,0x9b,\n    0x3f,0xca,0x33,0x45,0xd0,0xdb,0x5f,0xf5,0x52,0xc3,0x21,0xda,0xe2,0x22,0x72,0x6b,\n    0x3e,0xd0,0x5b,0xa8,0x87,0x8c,0x06,0x5d,0x0f,0xdd,0x09,0x19,0x93,0xd0,0xb9,0xfc,\n    0x8b,0x0f,0x84,0x60,0x33,0x1c,0x9b,0x45,0xf1,0xf0,0xa3,0x94,0x3a,0x12,0x77,0x33,\n    0x4d,0x44,0x78,0x28,0x3c,0x9e,0xfd,0x65,0x57,0x16,0x94,0x6b,0xfb,0x59,0xd0,0xc8,\n    0x22,0x36,0xdb,0xd2,0x63,0x98,0x43,0xa1,0x04,0x87,0x86,0xf7,0xa6,0x26,0xbb,0xd6,\n    0x59,0x4d,0xbf,0x6a,0x2e,0xaa,0x2b,0xef,0xe6,0x78,0xb6,0x4e,0xe0,0x2f,0xdc,0x7c,\n    0xbe,0x57,0x19,0x32,0x7e,0x2a,0xd0,0xb8,0xba,0x29,0x00,0x3c,0x52,0x7d,0xa8,0x49,\n    0x3b,0x2d,0xeb,0x25,0x49,0xfa,0xa3,0xaa,0x39,0xa7,0xc5,0xa7,0x50,0x11,0x36,0xfb,\n    0xc6,0x67,0x4a,0xf5,0xa5,0x12,0x65,0x7e,0xb0,0xdf,0xaf,0x4e,0xb3,0x61,0x7f,0x2f } };\n  unsigned offset=0, entries, tag, type, len, save, c;\n  unsigned ver97=0, serial=0, i, wbi=0, wb[4]={0,0,0,0};\n  uchar buf97[324], ci, cj, ck;\n  short morder, sorder=order;\n  char buf[10];\n/*\n   The MakerNote might have its own TIFF header (possibly with\n   its own byte-order!), or it might just be a table.\n */\n  if (!strcmp(make,\"Nokia\")) return;\n  fread (buf, 1, 10, ifp);\n  if (!strncmp (buf,\"KDK\" ,3) ||\t/* these aren't TIFF tables */\n      !strncmp (buf,\"VER\" ,3) ||\n      !strncmp (buf,\"IIII\",4) ||\n      !strncmp (buf,\"MMMM\",4)) return;\n  if (!strncmp (buf,\"KC\"  ,2) ||\t/* Konica KD-400Z, KD-510Z */\n      !strncmp (buf,\"MLY\" ,3)) {\t/* Minolta DiMAGE G series */\n    order = 0x4d4d;\n    while ((i=ftell(ifp)) < data_offset && i < 16384) {\n      wb[0] = wb[2];  wb[2] = wb[1];  wb[1] = wb[3];\n      wb[3] = get2();\n      if (wb[1] == 256 && wb[3] == 256 &&\n\t  wb[0] > 256 && wb[0] < 640 && wb[2] > 256 && wb[2] < 640)\n\tFORC4 cam_mul[c] = wb[c];\n    }\n    goto quit;\n  }\n  if (!strcmp (buf,\"Nikon\")) {\n    base = ftell(ifp);\n    order = get2();\n    if (get2() != 42) goto quit;\n    offset = get4();\n    fseek (ifp, offset-8, SEEK_CUR);\n  } else if (!strcmp (buf,\"OLYMPUS\")) {\n    base = ftell(ifp)-10;\n    fseek (ifp, -2, SEEK_CUR);\n    order = get2();  get2();\n  } else if (!strncmp (buf,\"SONY\",4) ||\n\t     !strcmp  (buf,\"Panasonic\")) {\n    goto nf;\n  } else if (!strncmp (buf,\"FUJIFILM\",8)) {\n    base = ftell(ifp)-10;\nnf: order = 0x4949;\n    fseek (ifp,  2, SEEK_CUR);\n  } else if (!strcmp (buf,\"OLYMP\") ||\n\t     !strcmp (buf,\"LEICA\") ||\n\t     !strcmp (buf,\"Ricoh\") ||\n\t     !strcmp (buf,\"EPSON\"))\n    fseek (ifp, -2, SEEK_CUR);\n  else if (!strcmp (buf,\"AOC\") ||\n\t   !strcmp (buf,\"QVC\"))\n    fseek (ifp, -4, SEEK_CUR);\n  else {\n    fseek (ifp, -10, SEEK_CUR);\n    if (!strncmp(make,\"SAMSUNG\",7))\n      base = ftell(ifp);\n  }\n  entries = get2();\n  if (entries > 1000) return;\n  morder = order;\n  while (entries--) {\n    order = morder;\n    tiff_get (base, &tag, &type, &len, &save);\n    tag |= uptag << 16;\n    if (tag == 2 && strstr(make,\"NIKON\") && !iso_speed)\n      iso_speed = (get2(),get2());\n    if (tag == 4 && len > 26 && len < 35) {\n      if ((i=(get4(),get2())) != 0x7fff && !iso_speed)\n\tiso_speed = 50 * pow (2, i/32.0 - 4);\n      if ((i=(get2(),get2())) != 0x7fff && !aperture)\n\taperture = pow (2, i/64.0);\n      if ((i=get2()) != 0xffff && !shutter)\n\tshutter = pow (2, (short) i/-32.0);\n      wbi = (get2(),get2());\n      shot_order = (get2(),get2());\n    }\n    if ((tag == 4 || tag == 0x114) && !strncmp(make,\"KONICA\",6)) {\n      fseek (ifp, tag == 4 ? 140:160, SEEK_CUR);\n      switch (get2()) {\n\tcase 72:  flip = 0;  break;\n\tcase 76:  flip = 6;  break;\n\tcase 82:  flip = 5;  break;\n      }\n    }\n    if (tag == 7 && type == 2 && len > 20)\n      fgets (model2, 64, ifp);\n    if (tag == 8 && type == 4)\n      shot_order = get4();\n    if (tag == 9 && !strcmp(make,\"Canon\"))\n      fread (artist, 64, 1, ifp);\n    if (tag == 0xc && len == 4) {\n      cam_mul[0] = getreal(type);\n      cam_mul[2] = getreal(type);\n    }\n    if (tag == 0xd && type == 7 && get2() == 0xaaaa) {\n      for (c=i=2; (ushort) c != 0xbbbb && i < len; i++)\n\tc = c << 8 | fgetc(ifp);\n      while ((i+=4) < len-5)\n\tif (get4() == 257 && (i=len) && (c = (get4(),fgetc(ifp))) < 3)\n\t  flip = \"065\"[c]-'0';\n    }\n    if (tag == 0x10 && type == 4)\n      unique_id = get4();\n    if (tag == 0x11 && is_raw && !strncmp(make,\"NIKON\",5)) {\n      fseek (ifp, get4()+base, SEEK_SET);\n      parse_tiff_ifd (base);\n    }\n    if (tag == 0x14 && type == 7) {\n      if (len == 2560) {\n\tfseek (ifp, 1248, SEEK_CUR);\n\tgoto get2_256;\n      }\n      fread (buf, 1, 10, ifp);\n      if (!strncmp(buf,\"NRW \",4)) {\n\tfseek (ifp, strcmp(buf+4,\"0100\") ? 46:1546, SEEK_CUR);\n\tcam_mul[0] = get4() << 2;\n\tcam_mul[1] = get4() + get4();\n\tcam_mul[2] = get4() << 2;\n      }\n    }\n    if (tag == 0x15 && type == 2 && is_raw)\n      fread (model, 64, 1, ifp);\n    if (strstr(make,\"PENTAX\")) {\n      if (tag == 0x1b) tag = 0x1018;\n      if (tag == 0x1c) tag = 0x1017;\n    }\n    if (tag == 0x1d)\n      while ((c = fgetc(ifp)) && c != EOF)\n\tserial = serial*10 + (isdigit(c) ? c - '0' : c % 10);\n    if (tag == 0x81 && type == 4) {\n      data_offset = get4();\n      fseek (ifp, data_offset + 41, SEEK_SET);\n      raw_height = get2() * 2;\n      raw_width  = get2();\n      filters = 0x61616161;\n    }\n    if (tag == 0x29 && type == 1) {\n      c = wbi < 18 ? \"012347800000005896\"[wbi]-'0' : 0;\n      fseek (ifp, 8 + c*32, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get4();\n    }\n    if ((tag == 0x81  && type == 7) ||\n\t(tag == 0x100 && type == 7) ||\n\t(tag == 0x280 && type == 1)) {\n      thumb_offset = ftell(ifp);\n      thumb_length = len;\n    }\n    if (tag == 0x88 && type == 4 && (thumb_offset = get4()))\n      thumb_offset += base;\n    if (tag == 0x89 && type == 4)\n      thumb_length = get4();\n    if (tag == 0x8c || tag == 0x96)\n      meta_offset = ftell(ifp);\n    if (tag == 0x97) {\n      for (i=0; i < 4; i++)\n\tver97 = ver97 * 10 + fgetc(ifp)-'0';\n      switch (ver97) {\n\tcase 100:\n\t  fseek (ifp, 68, SEEK_CUR);\n\t  FORC4 cam_mul[(c >> 1) | ((c & 1) << 1)] = get2();\n\t  break;\n\tcase 102:\n\t  fseek (ifp, 6, SEEK_CUR);\n\t  goto get2_rggb;\n\tcase 103:\n\t  fseek (ifp, 16, SEEK_CUR);\n\t  FORC4 cam_mul[c] = get2();\n      }\n      if (ver97 >= 200) {\n\tif (ver97 != 205) fseek (ifp, 280, SEEK_CUR);\n\tfread (buf97, 324, 1, ifp);\n      }\n    }\n    if (tag == 0xa1 && type == 7) {\n      order = 0x4949;\n      fseek (ifp, 140, SEEK_CUR);\n      FORC3 cam_mul[c] = get4();\n    }\n    if (tag == 0xa4 && type == 3) {\n      fseek (ifp, wbi*48, SEEK_CUR);\n      FORC3 cam_mul[c] = get2();\n    }\n    if (tag == 0xa7 && (unsigned) (ver97-200) < 17) {\n      ci = xlat[0][serial & 0xff];\n      cj = xlat[1][fgetc(ifp)^fgetc(ifp)^fgetc(ifp)^fgetc(ifp)];\n      ck = 0x60;\n      for (i=0; i < 324; i++)\n\tbuf97[i] ^= (cj += ci * ck++);\n      i = \"66666>666;6A;:;55\"[ver97-200] - '0';\n      FORC4 cam_mul[c ^ (c >> 1) ^ (i & 1)] =\n\tsget2 (buf97 + (i & -2) + c*2);\n    }\n    if (tag == 0x200 && len == 3)\n      shot_order = (get4(),get4());\n    if (tag == 0x200 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2();\n    if (tag == 0x201 && len == 4)\n      goto get2_rggb;\n    if (tag == 0x220 && type == 7)\n      meta_offset = ftell(ifp);\n    if (tag == 0x401 && type == 4 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get4();\n    if (tag == 0xe01) {\t\t/* Nikon Capture Note */\n      order = 0x4949;\n      fseek (ifp, 22, SEEK_CUR);\n      for (offset=22; offset+22 < len; offset += 22+i) {\n\ttag = get4();\n\tfseek (ifp, 14, SEEK_CUR);\n\ti = get4()-4;\n\tif (tag == 0x76a43207) flip = get2();\n\telse fseek (ifp, i, SEEK_CUR);\n      }\n    }\n    if (tag == 0xe80 && len == 256 && type == 7) {\n      fseek (ifp, 48, SEEK_CUR);\n      cam_mul[0] = get2() * 508 * 1.078 / 0x10000;\n      cam_mul[2] = get2() * 382 * 1.173 / 0x10000;\n    }\n    if (tag == 0xf00 && type == 7) {\n      if (len == 614)\n\tfseek (ifp, 176, SEEK_CUR);\n      else if (len == 734 || len == 1502)\n\tfseek (ifp, 148, SEEK_CUR);\n      else goto next;\n      goto get2_256;\n    }\n    if ((tag == 0x1011 && len == 9) || tag == 0x20400200)\n      for (i=0; i < 3; i++)\n\tFORC3 cmatrix[i][c] = ((short) get2()) / 256.0;\n    if ((tag == 0x1012 || tag == 0x20400600) && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2();\n    if (tag == 0x1017 || tag == 0x20400100)\n      cam_mul[0] = get2() / 256.0;\n    if (tag == 0x1018 || tag == 0x20400100)\n      cam_mul[2] = get2() / 256.0;\n    if (tag == 0x2011 && len == 2) {\nget2_256:\n      order = 0x4d4d;\n      cam_mul[0] = get2() / 256.0;\n      cam_mul[2] = get2() / 256.0;\n    }\n    if ((tag | 0x70) == 0x2070 && type == 4)\n      fseek (ifp, get4()+base, SEEK_SET);\n    if (tag == 0x2010 && type != 7)\n      load_raw = &CLASS olympus_load_raw;\n    if (tag == 0x2020)\n      parse_thumb_note (base, 257, 258);\n    if (tag == 0x2040)\n      parse_makernote (base, 0x2040);\n    if (tag == 0xb028) {\n      fseek (ifp, get4()+base, SEEK_SET);\n      parse_thumb_note (base, 136, 137);\n    }\n    if (tag == 0x4001 && len > 500) {\n      i = len == 582 ? 50 : len == 653 ? 68 : len == 5120 ? 142 : 126;\n      fseek (ifp, i, SEEK_CUR);\nget2_rggb:\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n      i = len >> 3 == 164 ? 112:22;\n      fseek (ifp, i, SEEK_CUR);\n      FORC4 sraw_mul[c ^ (c >> 1)] = get2();\n    }\n    if (tag == 0xa021)\n      FORC4 cam_mul[c ^ (c >> 1)] = get4();\n    if (tag == 0xa028)\n      FORC4 cam_mul[c ^ (c >> 1)] -= get4();\nnext:\n    fseek (ifp, save, SEEK_SET);\n  }\nquit:\n  order = sorder;\n}\n\n/*\n   Since the TIFF DateTime string has no timezone information,\n   assume that the camera's clock was set to Universal Time.\n */\nvoid CLASS get_timestamp (int reversed)\n{\n  struct tm t;\n  char str[20];\n  int i;\n\n  str[19] = 0;\n  if (reversed)\n    for (i=19; i--; ) str[i] = fgetc(ifp);\n  else\n    fread (str, 19, 1, ifp);\n  memset (&t, 0, sizeof t);\n  if (sscanf (str, \"%d:%d:%d %d:%d:%d\", &t.tm_year, &t.tm_mon,\n\t&t.tm_mday, &t.tm_hour, &t.tm_min, &t.tm_sec) != 6)\n    return;\n  t.tm_year -= 1900;\n  t.tm_mon -= 1;\n  t.tm_isdst = -1;\n  if (mktime(&t) > 0)\n    timestamp = mktime(&t);\n}\n\nvoid CLASS parse_exif (int base)\n{\n  unsigned kodak, entries, tag, type, len, save, c;\n  double expo;\n\n  kodak = !strncmp(make,\"EASTMAN\",7) && tiff_nifds < 3;\n  entries = get2();\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    switch (tag) {\n      case 33434:  shutter = getreal(type);\t\tbreak;\n      case 33437:  aperture = getreal(type);\t\tbreak;\n      case 34855:  iso_speed = get2();\t\t\tbreak;\n      case 36867:\n      case 36868:  get_timestamp(0);\t\t\tbreak;\n      case 37377:  if ((expo = -getreal(type)) < 128)\n\t\t     shutter = pow (2, expo);\t\tbreak;\n      case 37378:  aperture = pow (2, getreal(type)/2);\tbreak;\n      case 37386:  focal_len = getreal(type);\t\tbreak;\n      case 37500:  parse_makernote (base, 0);\t\tbreak;\n      case 40962:  if (kodak) raw_width  = get4();\tbreak;\n      case 40963:  if (kodak) raw_height = get4();\tbreak;\n      case 41730:\n\tif (get4() == 0x20002)\n\t  for (exif_cfa=c=0; c < 8; c+=2)\n\t    exif_cfa |= fgetc(ifp) * 0x01010101 << c;\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS parse_gps (int base)\n{\n  unsigned entries, tag, type, len, save, c;\n\n  entries = get2();\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    switch (tag) {\n      case 1: case 3: case 5:\n\tgpsdata[29+tag/2] = getc(ifp);\t\t\tbreak;\n      case 2: case 4: case 7:\n\tFORC(6) gpsdata[tag/3*6+c] = get4();\t\tbreak;\n      case 6:\n\tFORC(2) gpsdata[18+c] = get4();\t\t\tbreak;\n      case 18: case 29:\n\tfgets ((char *) (gpsdata+14+tag/3), MIN(len,12), ifp);\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS romm_coeff (float romm_cam[3][3])\n{\n  static const float rgb_romm[3][3] =\t/* ROMM == Kodak ProPhoto */\n  { {  2.034193, -0.727420, -0.306766 },\n    { -0.228811,  1.231729, -0.002922 },\n    { -0.008565, -0.153273,  1.161839 } };\n  int i, j, k;\n\n  for (i=0; i < 3; i++)\n    for (j=0; j < 3; j++)\n      for (cmatrix[i][j] = k=0; k < 3; k++)\n\tcmatrix[i][j] += rgb_romm[i][k] * romm_cam[k][j];\n}\n\nvoid CLASS parse_mos (int offset)\n{\n  char data[40];\n  int skip, from, i, c, neut[4], planes=0, frot=0;\n  static const char *mod[] =\n  { \"\",\"DCB2\",\"Volare\",\"Cantare\",\"CMost\",\"Valeo 6\",\"Valeo 11\",\"Valeo 22\",\n    \"Valeo 11p\",\"Valeo 17\",\"\",\"Aptus 17\",\"Aptus 22\",\"Aptus 75\",\"Aptus 65\",\n    \"Aptus 54S\",\"Aptus 65S\",\"Aptus 75S\",\"AFi 5\",\"AFi 6\",\"AFi 7\",\n    \"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"AFi-II 12\" };\n  float romm_cam[3][3];\n\n  fseek (ifp, offset, SEEK_SET);\n  while (1) {\n    if (get4() != 0x504b5453) break;\n    get4();\n    fread (data, 1, 40, ifp);\n    skip = get4();\n    from = ftell(ifp);\n    if (!strcmp(data,\"JPEG_preview_data\")) {\n      thumb_offset = from;\n      thumb_length = skip;\n    }\n    if (!strcmp(data,\"icc_camera_profile\")) {\n      profile_offset = from;\n      profile_length = skip;\n    }\n    if (!strcmp(data,\"ShootObj_back_type\")) {\n      fscanf (ifp, \"%d\", &i);\n      if ((unsigned) i < sizeof mod / sizeof (*mod))\n\tstrcpy (model, mod[i]);\n    }\n    if (!strcmp(data,\"icc_camera_to_tone_matrix\")) {\n      for (i=0; i < 9; i++)\n\tromm_cam[0][i] = int_to_float(get4());\n      romm_coeff (romm_cam);\n    }\n    if (!strcmp(data,\"CaptProf_color_matrix\")) {\n      for (i=0; i < 9; i++)\n\tfscanf (ifp, \"%f\", &romm_cam[0][i]);\n      romm_coeff (romm_cam);\n    }\n    if (!strcmp(data,\"CaptProf_number_of_planes\"))\n      fscanf (ifp, \"%d\", &planes);\n    if (!strcmp(data,\"CaptProf_raw_data_rotation\"))\n      fscanf (ifp, \"%d\", &flip);\n    if (!strcmp(data,\"CaptProf_mosaic_pattern\"))\n      FORC4 {\n\tfscanf (ifp, \"%d\", &i);\n\tif (i == 1) frot = c ^ (c >> 1);\n      }\n    if (!strcmp(data,\"ImgProf_rotation_angle\")) {\n      fscanf (ifp, \"%d\", &i);\n      flip = i - flip;\n    }\n    if (!strcmp(data,\"NeutObj_neutrals\") && !cam_mul[0]) {\n      FORC4 fscanf (ifp, \"%d\", neut+c);\n      FORC3 cam_mul[c] = (float) neut[0] / neut[c+1];\n    }\n    if (!strcmp(data,\"Rows_data\"))\n      load_flags = get4();\n    parse_mos (from);\n    fseek (ifp, skip+from, SEEK_SET);\n  }\n  if (planes)\n    filters = (planes == 1) * 0x01010101 *\n\t(uchar) \"\\x94\\x61\\x16\\x49\"[(flip/90 + frot) & 3];\n}\n\nvoid CLASS linear_table (unsigned len)\n{\n  int i;\n  if (len > 0x1000) len = 0x1000;\n  read_shorts (curve, len);\n  for (i=len; i < 0x1000; i++)\n    curve[i] = curve[i-1];\n  maximum = curve[0xfff];\n}\n\nvoid CLASS parse_kodak_ifd (int base)\n{\n  unsigned entries, tag, type, len, save;\n  int i, c, wbi=-2, wbtemp=6500;\n  float mul[3]={1,1,1}, num;\n  static const int wbtag[] = { 64037,64040,64039,64041,-1,-1,64042 };\n\n  entries = get2();\n  if (entries > 1024) return;\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    if (tag == 1020) wbi = getint(type);\n    if (tag == 1021 && len == 72) {\t\t/* WB set in software */\n      fseek (ifp, 40, SEEK_CUR);\n      FORC3 cam_mul[c] = 2048.0 / get2();\n      wbi = -2;\n    }\n    if (tag == 2118) wbtemp = getint(type);\n    if (tag == 2130 + wbi)\n      FORC3 mul[c] = getreal(type);\n    if (tag == 2140 + wbi && wbi >= 0)\n      FORC3 {\n\tfor (num=i=0; i < 4; i++)\n\t  num += getreal(type) * pow (wbtemp/100.0, i);\n\tcam_mul[c] = 2048 / (num * mul[c]);\n      }\n    if (tag == 2317) linear_table (len);\n    if (tag == 6020) iso_speed = getint(type);\n    if (tag == 64013) wbi = fgetc(ifp);\n    if ((unsigned) wbi < 7 && tag == wbtag[wbi])\n      FORC3 cam_mul[c] = get4();\n    if (tag == 64019) width = getint(type);\n    if (tag == 64020) height = (getint(type)+1) & -2;\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n#line 6162 \"dcraw/dcraw.c\"\nint CLASS parse_tiff_ifd (int base)\n{\n  unsigned entries, tag, type, len, plen=16, save;\n  int ifd, use_cm=0, cfa, i, j, c, ima_len=0;\n  int blrr=1, blrc=1, dblack[] = { 0,0,0,0 };\n  char software[64], *cbuf, *cp;\n  uchar cfa_pat[16], cfa_pc[] = { 0,1,2,3 }, tab[256];\n  double cc[4][4], cm[4][3], cam_xyz[4][3], num;\n  double ab[]={ 1,1,1,1 }, asn[] = { 0,0,0,0 }, xyz[] = { 1,1,1 };\n  unsigned sony_curve[] = { 0,0,0,0,0,4095 };\n  unsigned *buf, sony_offset=0, sony_length=0, sony_key=0;\n  struct jhead jh;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *sfp;\n#endif\n\n  if (tiff_nifds >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n    return 1;\n  ifd = tiff_nifds++;\n  for (j=0; j < 4; j++)\n    for (i=0; i < 4; i++)\n      cc[j][i] = i == j;\n  entries = get2();\n  if (entries > 512) return 1;\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    switch (tag) {\n      case 5:   width  = get2();  break;\n      case 6:   height = get2();  break;\n      case 7:   width += get2();  break;\n      case 9:  filters = get2();  break;\n      case 17: case 18:\n\tif (type == 3 && len == 1)\n\t  cam_mul[(tag-17)*2] = get2() / 256.0;\n\tbreak;\n      case 23:\n\tif (type == 3) iso_speed = get2();\n\tbreak;\n      case 36: case 37: case 38:\n\tcam_mul[tag-0x24] = get2();\n\tbreak;\n      case 39:\n\tif (len < 50 || cam_mul[0]) break;\n\tfseek (ifp, 12, SEEK_CUR);\n\tFORC3 cam_mul[c] = get2();\n\tbreak;\n      case 46:\n\tif (type != 7 || fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8) break;\n\tthumb_offset = ftell(ifp) - 2;\n\tthumb_length = len;\n\tbreak;\n      case 61440:\t\t\t/* Fuji HS10 table */\n\tparse_tiff_ifd (base);\n\tbreak;\n      case 2: case 256: case 61441:\t/* ImageWidth */\n\ttiff_ifd[ifd].t_width = getint(type);\n\tbreak;\n      case 3: case 257: case 61442:\t/* ImageHeight */\n\ttiff_ifd[ifd].t_height = getint(type);\n\tbreak;\n      case 258:\t\t\t\t/* BitsPerSample */\n      case 61443:\n\ttiff_ifd[ifd].samples = len & 7;\n\ttiff_ifd[ifd].bps = getint(type);\n\tbreak;\n      case 61446:\n\traw_height = 0;\n\tload_raw = &CLASS packed_load_raw;\n\tload_flags = get4() && (filters=0x16161616) ? 24:80;\n\tbreak;\n      case 259:\t\t\t\t/* Compression */\n\ttiff_ifd[ifd].comp = getint(type);\n\tbreak;\n      case 262:\t\t\t\t/* PhotometricInterpretation */\n\ttiff_ifd[ifd].phint = get2();\n\tbreak;\n      case 270:\t\t\t\t/* ImageDescription */\n\tfread (desc, 512, 1, ifp);\n\tbreak;\n      case 271:\t\t\t\t/* Make */\n\tfgets (make, 64, ifp);\n\tbreak;\n      case 272:\t\t\t\t/* Model */\n\tfgets (model, 64, ifp);\n\tbreak;\n      case 280:\t\t\t\t/* Panasonic RW2 offset */\n\tif (type != 4) break;\n\tload_raw = &CLASS panasonic_load_raw;\n\tload_flags = 0x2008;\n      case 273:\t\t\t\t/* StripOffset */\n      case 513:\t\t\t\t/* JpegIFOffset */\n      case 61447:\n\ttiff_ifd[ifd].offset = get4()+base;\n\tif (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0) {\n\t  fseek (ifp, tiff_ifd[ifd].offset, SEEK_SET);\n\t  if (ljpeg_start (&jh, 1)) {\n\t    tiff_ifd[ifd].comp    = 6;\n\t    tiff_ifd[ifd].t_width   = jh.wide;\n\t    tiff_ifd[ifd].t_height  = jh.high;\n\t    tiff_ifd[ifd].bps     = jh.bits;\n\t    tiff_ifd[ifd].samples = jh.clrs;\n\t    if (!(jh.sraw || (jh.clrs & 1)))\n\t      tiff_ifd[ifd].t_width *= jh.clrs;\n\t    i = order;\n\t    parse_tiff (tiff_ifd[ifd].offset + 12);\n\t    order = i;\n\t  }\n\t}\n\tbreak;\n      case 274:\t\t\t\t/* Orientation */\n\ttiff_ifd[ifd].t_flip = \"50132467\"[get2() & 7]-'0';\n\tbreak;\n      case 277:\t\t\t\t/* SamplesPerPixel */\n\ttiff_ifd[ifd].samples = getint(type) & 7;\n\tbreak;\n      case 279:\t\t\t\t/* StripByteCounts */\n      case 514:\n      case 61448:\n\ttiff_ifd[ifd].bytes = get4();\n\tbreak;\n      case 61454:\n\tFORC3 cam_mul[(4-c) % 3] = getint(type);\n\tbreak;\n      case 305:  case 11:\t\t/* Software */\n\tfgets (software, 64, ifp);\n\tif (!strncmp(software,\"Adobe\",5) ||\n\t    !strncmp(software,\"dcraw\",5) ||\n\t    !strncmp(software,\"UFRaw\",5) ||\n\t    !strncmp(software,\"Bibble\",6) ||\n\t    !strncmp(software,\"Nikon Scan\",10) ||\n\t    !strcmp (software,\"Digital Photo Professional\"))\n\t  is_raw = 0;\n\tbreak;\n      case 306:\t\t\t\t/* DateTime */\n\tget_timestamp(0);\n\tbreak;\n      case 315:\t\t\t\t/* Artist */\n\tfread (artist, 64, 1, ifp);\n\tbreak;\n      case 322:\t\t\t\t/* TileWidth */\n\ttiff_ifd[ifd].t_tile_width = getint(type);\n\tbreak;\n      case 323:\t\t\t\t/* TileLength */\n\ttiff_ifd[ifd].t_tile_length = getint(type);\n\tbreak;\n      case 324:\t\t\t\t/* TileOffsets */\n\ttiff_ifd[ifd].offset = len > 1 ? ftell(ifp) : get4();\n\tif (len == 4) {\n\t  load_raw = &CLASS sinar_4shot_load_raw;\n\t  is_raw = 5;\n\t}\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 325:\t\t\t\t/* TileByteCount */\n          tiff_ifd[ifd].tile_maxbytes = 0;\n          for(int jj=0;jj<len;jj++)\n              {\n                  int s = get4();\n                  if(s > tiff_ifd[ifd].tile_maxbytes) tiff_ifd[ifd].tile_maxbytes=s;\n              }\n\tbreak;\n#endif\n      case 330:\t\t\t\t/* SubIFDs */\n\tif (!strcmp(model,\"DSLR-A100\") && tiff_ifd[ifd].t_width == 3872) {\n\t  load_raw = &CLASS sony_arw_load_raw;\n\t  data_offset = get4()+base;\n\t  ifd++;  break;\n\t}\n        if(len > 1000) len=1000; /* 1000 SubIFDs is enough */\n\twhile (len--) {\n\t  i = ftell(ifp);\n\t  fseek (ifp, get4()+base, SEEK_SET);\n\t  if (parse_tiff_ifd (base)) break;\n\t  fseek (ifp, i+4, SEEK_SET);\n\t}\n\tbreak;\n      case 400:\n\tstrcpy (make, \"Sarnoff\");\n\tmaximum = 0xfff;\n\tbreak;\n      case 28688:\n\tFORC4 sony_curve[c+1] = get2() >> 2 & 0xfff;\n\tfor (i=0; i < 5; i++)\n\t  for (j = sony_curve[i]+1; j <= sony_curve[i+1]; j++)\n\t    curve[j] = curve[j-1] + (1 << i);\n\tbreak;\n      case 29184: sony_offset = get4();  break;\n      case 29185: sony_length = get4();  break;\n      case 29217: sony_key    = get4();  break;\n      case 29264:\n\tparse_minolta (ftell(ifp));\n\traw_width = 0;\n\tbreak;\n      case 29443:\n\tFORC4 cam_mul[c ^ (c < 2)] = get2();\n\tbreak;\n      case 29459:\n\tFORC4 cam_mul[c] = get2();\n\ti = (cam_mul[1] == 1024 && cam_mul[2] == 1024) << 1;\n\tSWAP (cam_mul[i],cam_mul[i+1])\n\tbreak;\n      case 33405:\t\t\t/* Model2 */\n\tfgets (model2, 64, ifp);\n\tbreak;\n      case 33422:\t\t\t/* CFAPattern */\n      case 64777:\t\t\t/* Kodak P-series */\n\tif ((plen=len) > 16) plen = 16;\n\tfread (cfa_pat, 1, plen, ifp);\n\tfor (colors=cfa=i=0; i < plen; i++) {\n\t  colors += !(cfa & (1 << cfa_pat[i]));\n\t  cfa |= 1 << cfa_pat[i];\n\t}\n\tif (cfa == 070) memcpy (cfa_pc,\"\\003\\004\\005\",3);\t/* CMY */\n\tif (cfa == 072) memcpy (cfa_pc,\"\\005\\003\\004\\001\",4);\t/* GMCY */\n\tgoto guess_cfa_pc;\n      case 33424:\n      case 65024:\n\tfseek (ifp, get4()+base, SEEK_SET);\n\tparse_kodak_ifd (base);\n\tbreak;\n      case 33434:\t\t\t/* ExposureTime */\n\tshutter = getreal(type);\n\tbreak;\n      case 33437:\t\t\t/* FNumber */\n\taperture = getreal(type);\n\tbreak;\n      case 34306:\t\t\t/* Leaf white balance */\n\tFORC4 cam_mul[c ^ 1] = 4096.0 / get2();\n\tbreak;\n      case 34307:\t\t\t/* Leaf CatchLight color matrix */\n\tfread (software, 1, 7, ifp);\n\tif (strncmp(software,\"MATRIX\",6)) break;\n\tcolors = 4;\n\tfor (raw_color = i=0; i < 3; i++) {\n\t  FORC4 fscanf (ifp, \"%f\", &rgb_cam[i][c^1]);\n\t  if (!use_camera_wb) continue;\n\t  num = 0;\n\t  FORC4 num += rgb_cam[i][c];\n\t  FORC4 rgb_cam[i][c] /= num;\n\t}\n\tbreak;\n      case 34310:\t\t\t/* Leaf metadata */\n\tparse_mos (ftell(ifp));\n      case 34303:\n\tstrcpy (make, \"Leaf\");\n\tbreak;\n      case 34665:\t\t\t/* EXIF tag */\n\tfseek (ifp, get4()+base, SEEK_SET);\n\tparse_exif (base);\n\tbreak;\n      case 34853:\t\t\t/* GPSInfo tag */\n\tfseek (ifp, get4()+base, SEEK_SET);\n\tparse_gps (base);\n\tbreak;\n      case 34675:\t\t\t/* InterColorProfile */\n      case 50831:\t\t\t/* AsShotICCProfile */\n\tprofile_offset = ftell(ifp);\n\tprofile_length = len;\n\tbreak;\n      case 37122:\t\t\t/* CompressedBitsPerPixel */\n\tkodak_cbpp = get4();\n\tbreak;\n      case 37386:\t\t\t/* FocalLength */\n\tfocal_len = getreal(type);\n\tbreak;\n      case 37393:\t\t\t/* ImageNumber */\n\tshot_order = getint(type);\n\tbreak;\n      case 37400:\t\t\t/* old Kodak KDC tag */\n\tfor (raw_color = i=0; i < 3; i++) {\n\t  getreal(type);\n\t  FORC3 rgb_cam[i][c] = getreal(type);\n\t}\n\tbreak;\n      case 46275:\t\t\t/* Imacon tags */\n\tstrcpy (make, \"Imacon\");\n\tdata_offset = ftell(ifp);\n\tima_len = len;\n\tbreak;\n      case 46279:\n\tif (!ima_len) break;\n\tfseek (ifp, 38, SEEK_CUR);\n      case 46274:\n\tfseek (ifp, 40, SEEK_CUR);\n\traw_width  = get4();\n\traw_height = get4();\n\tleft_margin = get4() & 7;\n\twidth = raw_width - left_margin - (get4() & 7);\n\ttop_margin = get4() & 7;\n\theight = raw_height - top_margin - (get4() & 7);\n\tif (raw_width == 7262 && ima_len == 234317952 ) {\n\t  height = 5412;\n\t  width  = 7216;\n\t  left_margin = 7;\n          filters=0;\n\t} else \tif (raw_width == 7262) {\n\t  height = 5444;\n\t  width  = 7244;\n\t  left_margin = 7;\n\t}\n\tfseek (ifp, 52, SEEK_CUR);\n\tFORC3 cam_mul[c] = getreal(11);\n\tfseek (ifp, 114, SEEK_CUR);\n\tflip = (get2() >> 7) * 90;\n\tif (width * height * 6 == ima_len) {\n\t  if (flip % 180 == 90) SWAP(width,height);\n\t  raw_width = width;\n\t  raw_height = height;\n\t  left_margin = top_margin = filters = flip = 0;\n\t}\n\tsprintf (model, \"Ixpress %d-Mp\", height*width/1000000);\n\tload_raw = &CLASS imacon_full_load_raw;\n\tif (filters) {\n\t  if (left_margin & 1) filters = 0x61616161;\n\t  load_raw = &CLASS unpacked_load_raw;\n\t}\n\tmaximum = 0xffff;\n\tbreak;\n      case 50454:\t\t\t/* Sinar tag */\n      case 50455:\n\tif (!(cbuf = (char *) malloc(len))) break;\n\tfread (cbuf, 1, len, ifp);\n\tfor (cp = cbuf-1; cp && cp < cbuf+len; cp = strchr(cp,'\\n'))\n\t  if (!strncmp (++cp,\"Neutral \",8))\n\t    sscanf (cp+8, \"%f %f %f\", cam_mul, cam_mul+1, cam_mul+2);\n\tfree (cbuf);\n\tbreak;\n      case 50458:\n\tif (!make[0]) strcpy (make, \"Hasselblad\");\n\tbreak;\n      case 50459:\t\t\t/* Hasselblad tag */\n\ti = order;\n\tj = ftell(ifp);\n\tc = tiff_nifds;\n\torder = get2();\n\tfseek (ifp, j+(get2(),get4()), SEEK_SET);\n\tparse_tiff_ifd (j);\n\tmaximum = 0xffff;\n\ttiff_nifds = c;\n\torder = i;\n\tbreak;\n      case 50706:\t\t\t/* DNGVersion */\n\tFORC4 dng_version = (dng_version << 8) + fgetc(ifp);\n\tif (!make[0]) strcpy (make, \"DNG\");\n\tis_raw = 1;\n\tbreak;\n      case 50710:\t\t\t/* CFAPlaneColor */\n\tif (len > 4) len = 4;\n\tcolors = len;\n\tfread (cfa_pc, 1, colors, ifp);\nguess_cfa_pc:\n\tFORCC tab[cfa_pc[c]] = c;\n\tcdesc[c] = 0;\n\tfor (i=16; i--; )\n\t  filters = filters << 2 | tab[cfa_pat[i % plen]];\n\tbreak;\n      case 50711:\t\t\t/* CFALayout */\n\tif (get2() == 2) {\n\t  fuji_width = 1;\n\t  filters = 0x49494949;\n\t}\n\tbreak;\n      case 291:\n      case 50712:\t\t\t/* LinearizationTable */\n\tlinear_table (len);\n\tbreak;\n      case 50713:\t\t\t/* BlackLevelRepeatDim */\n\tblrr = get2();\n\tblrc = get2();\n\tbreak;\n      case 61450:\n\tblrr = blrc = 2;\n      case 50714:\t\t\t/* BlackLevel */\n\tblack = getreal(type);\n\tif (!filters || !~filters) break;\n\tdblack[0] = black;\n\tdblack[1] = (blrc == 2) ? getreal(type):dblack[0];\n\tdblack[2] = (blrr == 2) ? getreal(type):dblack[0];\n\tdblack[3] = (blrc == 2 && blrr == 2) ? getreal(type):dblack[1];\n\tif (colors == 3)\n\t  filters |= ((filters >> 2 & 0x22222222) |\n\t\t      (filters << 2 & 0x88888888)) & filters << 1;\n\tFORC4 cblack[filters >> (c << 1) & 3] = dblack[c];\n\tblack = 0;\n\tbreak;\n      case 50715:\t\t\t/* BlackLevelDeltaH */\n      case 50716:\t\t\t/* BlackLevelDeltaV */\n\tfor (num=i=0; i < len && i < 65536; i++)\n\t  num += getreal(type);\n\tblack += num/len + 0.5;\n\tbreak;\n      case 50717:\t\t\t/* WhiteLevel */\n\tmaximum = getint(type);\n\tbreak;\n      case 50718:\t\t\t/* DefaultScale */\n\tpixel_aspect  = getreal(type);\n\tpixel_aspect /= getreal(type);\n\tbreak;\n      case 50721:\t\t\t/* ColorMatrix1 */\n      case 50722:\t\t\t/* ColorMatrix2 */\n\tFORCC for (j=0; j < 3; j++)\n\t  cm[c][j] = getreal(type);\n\tuse_cm = 1;\n\tbreak;\n      case 50723:\t\t\t/* CameraCalibration1 */\n      case 50724:\t\t\t/* CameraCalibration2 */\n\tfor (i=0; i < colors; i++)\n\t  FORCC cc[i][c] = getreal(type);\n\tbreak;\n      case 50727:\t\t\t/* AnalogBalance */\n\tFORCC ab[c] = getreal(type);\n\tbreak;\n      case 50728:\t\t\t/* AsShotNeutral */\n\tFORCC asn[c] = getreal(type);\n\tbreak;\n      case 50729:\t\t\t/* AsShotWhiteXY */\n\txyz[0] = getreal(type);\n\txyz[1] = getreal(type);\n\txyz[2] = 1 - xyz[0] - xyz[1];\n\tFORC3 xyz[c] /= d65_white[c];\n\tbreak;\n      case 50740:\t\t\t/* DNGPrivateData */\n\tif (dng_version) break;\n\tparse_minolta (j = get4()+base);\n\tfseek (ifp, j, SEEK_SET);\n\tparse_tiff_ifd (base);\n\tbreak;\n      case 50752:\n\tread_shorts (cr2_slice, 3);\n\tbreak;\n      case 50829:\t\t\t/* ActiveArea */\n\ttop_margin = getint(type);\n\tleft_margin = getint(type);\n\theight = getint(type) - top_margin;\n\twidth = getint(type) - left_margin;\n\tbreak;\n      case 50830:\t\t\t/* MaskedAreas */\n        for (i=0; i < len && i < 32; i++)\n\t  mask[0][i] = getint(type);\n\tblack = 0;\n\tbreak;\n      case 51009:\t\t\t/* OpcodeList2 */\n\tmeta_offset = ftell(ifp);\n\tbreak;\n      case 64772:\t\t\t/* Kodak P-series */\n\tif (len < 13) break;\n\tfseek (ifp, 16, SEEK_CUR);\n\tdata_offset = get4();\n\tfseek (ifp, 28, SEEK_CUR);\n\tdata_offset += get4();\n\tload_raw = &CLASS packed_load_raw;\n\tbreak;\n      case 65026:\n\tif (type == 2) fgets (model2, 64, ifp);\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n  if (sony_length && (buf = (unsigned *) malloc(sony_length))) {\n    fseek (ifp, sony_offset, SEEK_SET);\n    fread (buf, sony_length, 1, ifp);\n    sony_decrypt (buf, sony_length/4, 1, sony_key);\n#ifndef LIBRAW_LIBRARY_BUILD\n    sfp = ifp;\n    if ((ifp = tmpfile())) {\n      fwrite (buf, sony_length, 1, ifp);\n      fseek (ifp, 0, SEEK_SET);\n      parse_tiff_ifd (-sony_offset);\n      fclose (ifp);\n    }\n    ifp = sfp;\n#else\n    if( !ifp->tempbuffer_open(buf,sony_length))\n        {\n            parse_tiff_ifd(-sony_offset);\n            ifp->tempbuffer_close();\n        }\n#endif\n    free (buf);\n  }\n  for (i=0; i < colors; i++)\n    FORCC cc[i][c] *= ab[i];\n  if (use_cm) {\n    FORCC for (i=0; i < 3; i++)\n      for (cam_xyz[c][i]=j=0; j < colors; j++)\n\tcam_xyz[c][i] += cc[c][j] * cm[j][i] * xyz[i];\n    cam_xyz_coeff (cam_xyz);\n  }\n  if (asn[0]) {\n    cam_mul[3] = 0;\n    FORCC cam_mul[c] = 1 / asn[c];\n  }\n  if (!use_cm)\n    FORCC pre_mul[c] /= cc[c][c];\n  return 0;\n}\n\nint CLASS parse_tiff (int base)\n{\n  int doff;\n\n  fseek (ifp, base, SEEK_SET);\n  order = get2();\n  if (order != 0x4949 && order != 0x4d4d) return 0;\n  get2();\n  while ((doff = get4())) {\n    fseek (ifp, doff+base, SEEK_SET);\n    if (parse_tiff_ifd (base)) break;\n  }\n  return 1;\n}\n\nvoid CLASS apply_tiff()\n{\n  int max_samp=0, raw=-1, thm=-1, i;\n  struct jhead jh;\n\n  thumb_misc = 16;\n  if (thumb_offset) {\n    fseek (ifp, thumb_offset, SEEK_SET);\n    if (ljpeg_start (&jh, 1)) {\n      if((unsigned)jh.bits<17 && (unsigned)jh.wide < 0x10000 && (unsigned)jh.high < 0x10000)\n        {\n          thumb_misc   = jh.bits;\n          thumb_width  = jh.wide;\n          thumb_height = jh.high;\n        }\n    }\n  }\n  for (i=0; i < tiff_nifds; i++) {\n    if (max_samp < tiff_ifd[i].samples)\n\tmax_samp = tiff_ifd[i].samples;\n    if (max_samp > 3) max_samp = 3;\n    if ((tiff_ifd[i].comp != 6 || tiff_ifd[i].samples != 3) &&\n        unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&\n        (unsigned)tiff_ifd[i].bps < 33 && (unsigned)tiff_ifd[i].samples < 13 &&\n\ttiff_ifd[i].t_width*tiff_ifd[i].t_height > raw_width*raw_height) {\n      raw_width     = tiff_ifd[i].t_width;\n      raw_height    = tiff_ifd[i].t_height;\n      tiff_bps      = tiff_ifd[i].bps;\n      tiff_compress = tiff_ifd[i].comp;\n      data_offset   = tiff_ifd[i].offset;\n      tiff_flip     = tiff_ifd[i].t_flip;\n      tiff_samples  = tiff_ifd[i].samples;\n      tile_width    = tiff_ifd[i].t_tile_width;\n      tile_length   = tiff_ifd[i].t_tile_length;\n#ifdef LIBRAW_LIBRARY_BUILD\n      data_size     = tile_length < INT_MAX && tile_length>0 ? tiff_ifd[i].tile_maxbytes: tiff_ifd[i].bytes;\n#endif\n      raw = i;\n    }\n  }\n  if (!tile_width ) tile_width  = INT_MAX;\n  if (!tile_length) tile_length = INT_MAX;\n  for (i=tiff_nifds; i--; )\n    if (tiff_ifd[i].t_flip) tiff_flip = tiff_ifd[i].t_flip;\n  if (raw >= 0 && !load_raw)\n    switch (tiff_compress) {\n      case 32767:\n\tif (tiff_ifd[raw].bytes == raw_width*raw_height) {\n\t  tiff_bps = 12;\n\t  load_raw = &CLASS sony_arw2_load_raw;\t\t\tbreak;\n\t}\n\tif (tiff_ifd[raw].bytes*8 != raw_width*raw_height*tiff_bps) {\n\t  raw_height += 8;\n\t  load_raw = &CLASS sony_arw_load_raw;\t\t\tbreak;\n\t}\n\tload_flags = 79;\n      case 32769:\n\tload_flags++;\n      case 32770:\n      case 32773: goto slr;\n      case 0:  case 1:\n\tif (tiff_ifd[raw].bytes*5 == raw_width*raw_height*8) {\n\t  load_flags = 81;\n\t  tiff_bps = 12;\n\t} slr:\n\tswitch (tiff_bps) {\n\t  case  8: load_raw = &CLASS eight_bit_load_raw;\tbreak;\n\t  case 12: if (tiff_ifd[raw].phint == 2)\n\t\t     load_flags = 6;\n\t\t   load_raw = &CLASS packed_load_raw;\t\tbreak;\n\t  case 14: load_flags = 0;\n\t  case 16: load_raw = &CLASS unpacked_load_raw;\t\tbreak;\n\t}\n\tbreak;\n      case 6:  case 7:  case 99:\n\tload_raw = &CLASS lossless_jpeg_load_raw;\t\tbreak;\n      case 262:\n\tload_raw = &CLASS kodak_262_load_raw;\t\t\tbreak;\n      case 34713:\n\tif ((raw_width+9)/10*16*raw_height == tiff_ifd[raw].bytes) {\n\t  load_raw = &CLASS packed_load_raw;\n\t  load_flags = 1;\n\t} else if (raw_width*raw_height*2 == tiff_ifd[raw].bytes) {\n\t  load_raw = &CLASS unpacked_load_raw;\n\t  load_flags = 4;\n\t  order = 0x4d4d;\n\t} else\n\t  load_raw = &CLASS nikon_load_raw;\t\t\tbreak;\n      case 34892:\n\tload_raw = &CLASS lossy_dng_load_raw;\t\t\tbreak;\n      case 65535:\n\tload_raw = &CLASS pentax_load_raw;\t\t\tbreak;\n      case 65000:\n\tswitch (tiff_ifd[raw].phint) {\n\t  case 2: load_raw = &CLASS kodak_rgb_load_raw;   filters = 0;  break;\n\t  case 6: load_raw = &CLASS kodak_ycbcr_load_raw; filters = 0;  break;\n\t  case 32803: load_raw = &CLASS kodak_65000_load_raw;\n\t}\n      case 32867: break;\n      default: is_raw = 0;\n    }\n  if (!dng_version)\n    if ( (tiff_samples == 3 && tiff_ifd[raw].bytes &&\n\t  tiff_bps != 14 && tiff_bps != 2048 && \n\t  tiff_compress != 32769 && tiff_compress != 32770)\n      || (tiff_bps == 8 && !strstr(make,\"KODAK\") && !strstr(make,\"Kodak\") &&\n\t  !strstr(model2,\"DEBUG RAW\")))\n      is_raw = 0;\n  for (i=0; i < tiff_nifds; i++)\n    if (i != raw && tiff_ifd[i].samples == max_samp &&\n        tiff_ifd[i].bps>0 && tiff_ifd[i].bps < 33 &&\n       unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&\n\ttiff_ifd[i].t_width * tiff_ifd[i].t_height / SQR(tiff_ifd[i].bps+1) >\n\t      thumb_width *       thumb_height / SQR(thumb_misc+1)\n\t&& tiff_ifd[i].comp != 34892) {\n      thumb_width  = tiff_ifd[i].t_width;\n      thumb_height = tiff_ifd[i].t_height;\n      thumb_offset = tiff_ifd[i].offset;\n      thumb_length = tiff_ifd[i].bytes;\n      thumb_misc   = tiff_ifd[i].bps;\n      thm = i;\n    }\n  if (thm >= 0) {\n    thumb_misc |= tiff_ifd[thm].samples << 5;\n    switch (tiff_ifd[thm].comp) {\n      case 0:\n\twrite_thumb = &CLASS layer_thumb;\n\tbreak;\n      case 1:\n\tif (tiff_ifd[thm].bps <= 8)\n\t  write_thumb = &CLASS ppm_thumb;\n\telse if (!strcmp(make,\"Imacon\"))\n\t  write_thumb = &CLASS ppm16_thumb;\n\telse\n\t  thumb_load_raw = &CLASS kodak_thumb_load_raw;\n\tbreak;\n      case 65000:\n\tthumb_load_raw = tiff_ifd[thm].phint == 6 ?\n\t\t&CLASS kodak_ycbcr_load_raw : &CLASS kodak_rgb_load_raw;\n    }\n  }\n}\n\nvoid CLASS parse_minolta (int base)\n{\n  int save, tag, len, offset, high=0, wide=0, i, c;\n  short sorder=order;\n\n  fseek (ifp, base, SEEK_SET);\n  if (fgetc(ifp) || fgetc(ifp)-'M' || fgetc(ifp)-'R') return;\n  order = fgetc(ifp) * 0x101;\n  offset = base + get4() + 8;\n  while ((save=ftell(ifp)) < offset) {\n    for (tag=i=0; i < 4; i++)\n      tag = tag << 8 | fgetc(ifp);\n    len = get4();\n    switch (tag) {\n      case 0x505244:\t\t\t\t/* PRD */\n\tfseek (ifp, 8, SEEK_CUR);\n\thigh = get2();\n\twide = get2();\n\tbreak;\n      case 0x574247:\t\t\t\t/* WBG */\n\tget4();\n\ti = strcmp(model,\"DiMAGE A200\") ? 0:3;\n\tFORC4 cam_mul[c ^ (c >> 1) ^ i] = get2();\n\tbreak;\n      case 0x545457:\t\t\t\t/* TTW */\n\tparse_tiff (ftell(ifp));\n\tdata_offset = offset;\n    }\n    fseek (ifp, save+len+8, SEEK_SET);\n  }\n  raw_height = high;\n  raw_width  = wide;\n  order = sorder;\n}\n\n/*\n   Many cameras have a \"debug mode\" that writes JPEG and raw\n   at the same time.  The raw file has no header, so try to\n   to open the matching JPEG file and read its metadata.\n */\nvoid CLASS parse_external_jpeg()\n{\n  const char *file, *ext;\n  char *jname, *jfile, *jext;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *save=ifp;\n#else\n#if defined (WIN32) && !defined(__MINGW32__)\n  if(ifp->wfname())\n  {\n\t  std::wstring rawfile(ifp->wfname());\n\t  rawfile.replace(rawfile.length()-3,3,L\"JPG\");\n\t  if(!ifp->subfile_open(rawfile.c_str()))\n\t  {\n\t\t  parse_tiff (12);\n\t\t  thumb_offset = 0;\n\t\t  is_raw = 1;\n\t\t  ifp->subfile_close();\n\t  }\n\t  else\n\t\t  imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n\t return;\n  }\n#endif\n  if(!ifp->fname())\n      {\n          imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n          return;\n      }\n#endif\n\n  ext  = strrchr (ifname, '.');\n  file = strrchr (ifname, '/');\n  if (!file) file = strrchr (ifname, '\\\\');\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!file) file = ifname-1;\n#else\n  if (!file) file = (char*)ifname-1;\n#endif\n  file++;\n  if (!ext || strlen(ext) != 4 || ext-file != 8) return;\n  jname = (char *) malloc (strlen(ifname) + 1);\n  merror (jname, \"parse_external_jpeg()\");\n  strcpy (jname, ifname);\n  jfile = file - ifname + jname;\n  jext  = ext  - ifname + jname;\n  if (strcasecmp (ext, \".jpg\")) {\n    strcpy (jext, isupper(ext[1]) ? \".JPG\":\".jpg\");\n    if (isdigit(*file)) {\n      memcpy (jfile, file+4, 4);\n      memcpy (jfile+4, file, 4);\n    }\n  } else\n    while (isdigit(*--jext)) {\n      if (*jext != '9') {\n\t(*jext)++;\n\tbreak;\n      }\n      *jext = '0';\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (strcmp (jname, ifname)) {\n    if ((ifp = fopen (jname, \"rb\"))) {\n#ifdef DCRAW_VERBOSE\n      if (verbose)\n\tfprintf (stderr,_(\"Reading metadata from %s ...\\n\"), jname);\n#endif\n      parse_tiff (12);\n      thumb_offset = 0;\n      is_raw = 1;\n      fclose (ifp);\n    }\n  }\n#else\n  if (strcmp (jname, ifname)) \n      {\n          if(!ifp->subfile_open(jname))\n              {\n                  parse_tiff (12);\n                  thumb_offset = 0;\n                  is_raw = 1;\n                  ifp->subfile_close();\n              }\n          else\n              imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n      }\n#endif\n  if (!timestamp)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n#endif\n#ifdef DCRAW_VERBOSE\n          fprintf (stderr,_(\"Failed to read metadata from %s\\n\"), jname);\n#endif\n      }\n  free (jname);\n#ifndef LIBRAW_LIBRARY_BUILD\n  ifp = save;\n#endif\n}\n\n/*\n   CIFF block 0x1030 contains an 8x8 white sample.\n   Load this into white[][] for use in scale_colors().\n */\nvoid CLASS ciff_block_1030()\n{\n  static const ushort key[] = { 0x410, 0x45f3 };\n  int i, bpp, row, col, vbits=0;\n  unsigned long bitbuf=0;\n\n  if ((get2(),get4()) != 0x80008 || !get4()) return;\n  bpp = get2();\n  if (bpp != 10 && bpp != 12) return;\n  for (i=row=0; row < 8; row++)\n    for (col=0; col < 8; col++) {\n      if (vbits < bpp) {\n\tbitbuf = bitbuf << 16 | (get2() ^ key[i++ & 1]);\n\tvbits += 16;\n      }\n      white[row][col] =\n\tbitbuf << (LONG_BIT - vbits) >> (LONG_BIT - bpp);\n      vbits -= bpp;\n    }\n}\n\n/*\n   Parse a CIFF file, better known as Canon CRW format.\n */\nvoid CLASS parse_ciff (int offset, int length)\n{\n  int tboff, nrecs, c, type, len, save, wbi=-1;\n  ushort key[] = { 0x410, 0x45f3 };\n\n  fseek (ifp, offset+length-4, SEEK_SET);\n  tboff = get4() + offset;\n  fseek (ifp, tboff, SEEK_SET);\n  nrecs = get2();\n  if (nrecs > 100) return;\n  while (nrecs--) {\n    type = get2();\n    len  = get4();\n    save = ftell(ifp) + 4;\n    fseek (ifp, offset+get4(), SEEK_SET);\n    if ((((type >> 8) + 8) | 8) == 0x38)\n      parse_ciff (ftell(ifp), len);\t/* Parse a sub-table */\n\n    if (type == 0x0810)\n      fread (artist, 64, 1, ifp);\n    if (type == 0x080a) {\n      fread (make, 64, 1, ifp);\n      fseek (ifp, strlen(make) - 63, SEEK_CUR);\n      fread (model, 64, 1, ifp);\n    }\n    if (type == 0x1810) {\n      fseek (ifp, 12, SEEK_CUR);\n      flip = get4();\n    }\n    if (type == 0x1835)\t\t\t/* Get the decoder table */\n      tiff_compress = get4();\n    if (type == 0x2007) {\n      thumb_offset = ftell(ifp);\n      thumb_length = len;\n    }\n    if (type == 0x1818) {\n      shutter = pow (2, -int_to_float((get4(),get4())));\n      aperture = pow (2, int_to_float(get4())/2);\n    }\n    if (type == 0x102a) {\n      iso_speed = pow (2, (get4(),get2())/32.0 - 4) * 50;\n      aperture  = pow (2, (get2(),(short)get2())/64.0);\n      shutter   = pow (2,-((short)get2())/32.0);\n      wbi = (get2(),get2());\n      if (wbi > 17) wbi = 0;\n      fseek (ifp, 32, SEEK_CUR);\n      if (shutter > 1e6) shutter = get2()/10.0;\n    }\n    if (type == 0x102c) {\n      if (get2() > 512) {\t\t/* Pro90, G1 */\n\tfseek (ifp, 118, SEEK_CUR);\n\tFORC4 cam_mul[c ^ 2] = get2();\n      } else {\t\t\t\t/* G2, S30, S40 */\n\tfseek (ifp, 98, SEEK_CUR);\n\tFORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2();\n      }\n    }\n    if (type == 0x0032) {\n      if (len == 768) {\t\t\t/* EOS D30 */\n\tfseek (ifp, 72, SEEK_CUR);\n\tFORC4 cam_mul[c ^ (c >> 1)] = 1024.0 / get2();\n\tif (!wbi) cam_mul[0] = -1;\t/* use my auto white balance */\n      } else if (!cam_mul[0]) {\n\tif (get2() == key[0])\t\t/* Pro1, G6, S60, S70 */\n\t  c = (strstr(model,\"Pro1\") ?\n\t      \"012346000000000000\":\"01345:000000006008\")[wbi]-'0'+ 2;\n\telse {\t\t\t\t/* G3, G5, S45, S50 */\n\t  c = \"023457000000006000\"[wbi]-'0';\n\t  key[0] = key[1] = 0;\n\t}\n\tfseek (ifp, 78 + c*8, SEEK_CUR);\n\tFORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2() ^ key[c & 1];\n\tif (!wbi) cam_mul[0] = -1;\n      }\n    }\n    if (type == 0x10a9) {\t\t/* D60, 10D, 300D, and clones */\n      if (len > 66) wbi = \"0134567028\"[wbi]-'0';\n      fseek (ifp, 2 + wbi*8, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n    }\n    if (type == 0x1030 && (0x18040 >> wbi & 1))\n      ciff_block_1030();\t\t/* all that don't have 0x10a9 */\n    if (type == 0x1031) {\n      raw_width = (get2(),get2());\n      raw_height = get2();\n    }\n    if (type == 0x5029) {\n      focal_len = len >> 16;\n      if ((len & 0xffff) == 2) focal_len /= 32;\n    }\n    if (type == 0x5813) flash_used = int_to_float(len);\n    if (type == 0x5814) canon_ev   = int_to_float(len);\n    if (type == 0x5817) shot_order = len;\n    if (type == 0x5834) unique_id  = len;\n    if (type == 0x580e) timestamp  = len;\n    if (type == 0x180e) timestamp  = get4();\n#ifdef LOCALTIME\n    if ((type | 0x4000) == 0x580e)\n      timestamp = mktime (gmtime (&timestamp));\n#endif\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS parse_rollei()\n{\n  char line[128], *val;\n  struct tm t;\n\n  fseek (ifp, 0, SEEK_SET);\n  memset (&t, 0, sizeof t);\n  do {\n    fgets (line, 128, ifp);\n    if ((val = strchr(line,'=')))\n      *val++ = 0;\n    else\n      val = line + strlen(line);\n    if (!strcmp(line,\"DAT\"))\n      sscanf (val, \"%d.%d.%d\", &t.tm_mday, &t.tm_mon, &t.tm_year);\n    if (!strcmp(line,\"TIM\"))\n      sscanf (val, \"%d:%d:%d\", &t.tm_hour, &t.tm_min, &t.tm_sec);\n    if (!strcmp(line,\"HDR\"))\n      thumb_offset = atoi(val);\n    if (!strcmp(line,\"X  \"))\n      raw_width = atoi(val);\n    if (!strcmp(line,\"Y  \"))\n      raw_height = atoi(val);\n    if (!strcmp(line,\"TX \"))\n      thumb_width = atoi(val);\n    if (!strcmp(line,\"TY \"))\n      thumb_height = atoi(val);\n  } while (strncmp(line,\"EOHD\",4));\n  data_offset = thumb_offset + thumb_width * thumb_height * 2;\n  t.tm_year -= 1900;\n  t.tm_mon -= 1;\n  if (mktime(&t) > 0)\n    timestamp = mktime(&t);\n  strcpy (make, \"Rollei\");\n  strcpy (model,\"d530flex\");\n  write_thumb = &CLASS rollei_thumb;\n}\n\nvoid CLASS parse_sinar_ia()\n{\n  int entries, off;\n  char str[8], *cp;\n\n  order = 0x4949;\n  fseek (ifp, 4, SEEK_SET);\n  entries = get4();\n  fseek (ifp, get4(), SEEK_SET);\n  while (entries--) {\n    off = get4(); get4();\n    fread (str, 8, 1, ifp);\n    if (!strcmp(str,\"META\"))   meta_offset = off;\n    if (!strcmp(str,\"THUMB\")) thumb_offset = off;\n    if (!strcmp(str,\"RAW0\"))   data_offset = off;\n  }\n  fseek (ifp, meta_offset+20, SEEK_SET);\n  fread (make, 64, 1, ifp);\n  make[63] = 0;\n  if ((cp = strchr(make,' '))) {\n    strcpy (model, cp+1);\n    *cp = 0;\n  }\n  raw_width  = get2();\n  raw_height = get2();\n  load_raw = &CLASS unpacked_load_raw;\n  thumb_width = (get4(),get2());\n  thumb_height = get2();\n  write_thumb = &CLASS ppm_thumb;\n  maximum = 0x3fff;\n}\n\nvoid CLASS parse_phase_one (int base)\n{\n  unsigned entries, tag, type, len, data, save, i, c;\n  float romm_cam[3][3];\n  char *cp;\n\n  memset (&ph1, 0, sizeof ph1);\n  fseek (ifp, base, SEEK_SET);\n  order = get4() & 0xffff;\n  if (get4() >> 8 != 0x526177) return;\t\t/* \"Raw\" */\n  fseek (ifp, get4()+base, SEEK_SET);\n  entries = get4();\n  get4();\n  while (entries--) {\n    tag  = get4();\n    type = get4();\n    len  = get4();\n    data = get4();\n    save = ftell(ifp);\n    fseek (ifp, base+data, SEEK_SET);\n    switch (tag) {\n      case 0x100:  flip = \"0653\"[data & 3]-'0';  break;\n      case 0x106:\n\tfor (i=0; i < 9; i++)\n\t  romm_cam[0][i] = getreal(11);\n\tromm_coeff (romm_cam);\n\tbreak;\n      case 0x107:\n\tFORC3 cam_mul[c] = getreal(11);\n\tbreak;\n      case 0x108:  raw_width     = data;\tbreak;\n      case 0x109:  raw_height    = data;\tbreak;\n      case 0x10a:  left_margin   = data;\tbreak;\n      case 0x10b:  top_margin    = data;\tbreak;\n      case 0x10c:  width         = data;\tbreak;\n      case 0x10d:  height        = data;\tbreak;\n      case 0x10e:  ph1.format    = data;\tbreak;\n      case 0x10f:  data_offset   = data+base;\tbreak;\n      case 0x110:  meta_offset   = data+base;\n\t\t   meta_length   = len;\t\t\tbreak;\n      case 0x112:  ph1.key_off   = save - 4;\t\tbreak;\n      case 0x210:  ph1.tag_210   = int_to_float(data);\tbreak;\n      case 0x21a:  ph1.tag_21a   = data;\t\tbreak;\n      case 0x21c:  strip_offset  = data+base;\t\tbreak;\n      case 0x21d:  ph1.t_black     = data;\t\tbreak;\n      case 0x222:  ph1.split_col = data;\t\tbreak;\n      case 0x223:  ph1.black_off = data+base;\t\tbreak;\n      case 0x301:\n\tmodel[63] = 0;\n\tfread (model, 1, 63, ifp);\n\tif ((cp = strstr(model,\" camera\"))) *cp = 0;\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n  load_raw = ph1.format < 3 ?\n\t&CLASS phase_one_load_raw : &CLASS phase_one_load_raw_c;\n  maximum = 0xffff;\n  strcpy (make, \"Phase One\");\n  if (model[0]) return;\n  switch (raw_height) {\n    case 2060: strcpy (model,\"LightPhase\");\tbreak;\n    case 2682: strcpy (model,\"H 10\");\t\tbreak;\n    case 4128: strcpy (model,\"H 20\");\t\tbreak;\n    case 5488: strcpy (model,\"H 25\");\t\tbreak;\n  }\n}\n\nvoid CLASS parse_fuji (int offset)\n{\n  unsigned entries, tag, len, save, c;\n\n  fseek (ifp, offset, SEEK_SET);\n  entries = get4();\n  if (entries > 255) return;\n  while (entries--) {\n    tag = get2();\n    len = get2();\n    save = ftell(ifp);\n    if (tag == 0x100) {\n      raw_height = get2();\n      raw_width  = get2();\n    } else if (tag == 0x121) {\n      height = get2();\n      if ((width = get2()) == 4284) width += 3;\n    } else if (tag == 0x130) {\n      fuji_layout = fgetc(ifp) >> 7;\n      fuji_width = !(fgetc(ifp) & 8);\n    } else if (tag == 0x2ff0) {\n      FORC4 cam_mul[c ^ 1] = get2();\n    } else if (tag == 0xc000) {\n      c = order;\n      order = 0x4949;\n      if ((width = get4()) > 10000) width = get4();\n      height = get4();\n      order = c;\n    }\n    fseek (ifp, save+len, SEEK_SET);\n  }\n  height <<= fuji_layout;\n  width  >>= fuji_layout;\n}\n\nint CLASS parse_jpeg (int offset)\n{\n  int len, save, hlen, mark;\n\n  fseek (ifp, offset, SEEK_SET);\n  if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8) return 0;\n\n  while (fgetc(ifp) == 0xff && (mark = fgetc(ifp)) != 0xda) {\n    order = 0x4d4d;\n    len   = get2() - 2;\n    save  = ftell(ifp);\n    if (mark == 0xc0 || mark == 0xc3) {\n      fgetc(ifp);\n      raw_height = get2();\n      raw_width  = get2();\n    }\n    order = get2();\n    hlen  = get4();\n    if (get4() == 0x48454150)\t\t/* \"HEAP\" */\n      parse_ciff (save+hlen, len-hlen);\n    if (parse_tiff (save+6)) apply_tiff();\n    fseek (ifp, save+len, SEEK_SET);\n  }\n  return 1;\n}\n\nvoid CLASS parse_riff()\n{\n  unsigned i, size, end;\n  char tag[4], date[64], month[64];\n  static const char mon[12][4] =\n  { \"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\" };\n  struct tm t;\n\n  order = 0x4949;\n  fread (tag, 4, 1, ifp);\n  size = get4();\n  end = ftell(ifp) + size;\n  if (!memcmp(tag,\"RIFF\",4) || !memcmp(tag,\"LIST\",4)) {\n    get4();\n    while (ftell(ifp)+7 < end)\n      parse_riff();\n  } else if (!memcmp(tag,\"nctg\",4)) {\n    while (ftell(ifp)+7 < end) {\n      i = get2();\n      size = get2();\n      if ((i+1) >> 1 == 10 && size == 20)\n\tget_timestamp(0);\n      else fseek (ifp, size, SEEK_CUR);\n    }\n  } else if (!memcmp(tag,\"IDIT\",4) && size < 64) {\n    fread (date, 64, 1, ifp);\n    date[size] = 0;\n    memset (&t, 0, sizeof t);\n    if (sscanf (date, \"%*s %s %d %d:%d:%d %d\", month, &t.tm_mday,\n\t&t.tm_hour, &t.tm_min, &t.tm_sec, &t.tm_year) == 6) {\n      for (i=0; i < 12 && strcasecmp(mon[i],month); i++);\n      t.tm_mon = i;\n      t.tm_year -= 1900;\n      if (mktime(&t) > 0)\n\ttimestamp = mktime(&t);\n    }\n  } else\n    fseek (ifp, size, SEEK_CUR);\n}\n\nvoid CLASS parse_smal (int offset, int fsize)\n{\n  int ver;\n\n  fseek (ifp, offset+2, SEEK_SET);\n  order = 0x4949;\n  ver = fgetc(ifp);\n  if (ver == 6)\n    fseek (ifp, 5, SEEK_CUR);\n  if (get4() != fsize) return;\n  if (ver > 6) data_offset = get4();\n  raw_height = height = get2();\n  raw_width  = width  = get2();\n  strcpy (make, \"SMaL\");\n  sprintf (model, \"v%d %dx%d\", ver, width, height);\n  if (ver == 6) load_raw = &CLASS smal_v6_load_raw;\n  if (ver == 9) load_raw = &CLASS smal_v9_load_raw;\n}\n\nvoid CLASS parse_cine()\n{\n  unsigned off_head, off_setup, off_image, i;\n\n  order = 0x4949;\n  fseek (ifp, 4, SEEK_SET);\n  is_raw = get2() == 2;\n  fseek (ifp, 14, SEEK_CUR);\n  is_raw *= get4();\n  off_head = get4();\n  off_setup = get4();\n  off_image = get4();\n  timestamp = get4();\n  if ((i = get4())) timestamp = i;\n  fseek (ifp, off_head+4, SEEK_SET);\n  raw_width = get4();\n  raw_height = get4();\n  switch (get2(),get2()) {\n    case  8:  load_raw = &CLASS eight_bit_load_raw;  break;\n    case 16:  load_raw = &CLASS  unpacked_load_raw;\n  }\n  fseek (ifp, off_setup+792, SEEK_SET);\n  strcpy (make, \"CINE\");\n  sprintf (model, \"%d\", get4());\n  fseek (ifp, 12, SEEK_CUR);\n  switch ((i=get4()) & 0xffffff) {\n    case  3:  filters = 0x94949494;  break;\n    case  4:  filters = 0x49494949;  break;\n    default:  is_raw = 0;\n  }\n  fseek (ifp, 72, SEEK_CUR);\n  switch ((get4()+3600) % 360) {\n    case 270:  flip = 4;  break;\n    case 180:  flip = 1;  break;\n    case  90:  flip = 7;  break;\n    case   0:  flip = 2;\n  }\n  cam_mul[0] = getreal(11);\n  cam_mul[2] = getreal(11);\n  maximum = ~(-1 << get4());\n  fseek (ifp, 668, SEEK_CUR);\n  shutter = get4()/1000000000.0;\n  fseek (ifp, off_image, SEEK_SET);\n  if (shot_select < is_raw)\n    fseek (ifp, shot_select*8, SEEK_CUR);\n  data_offset  = (INT64) get4() + 8;\n  data_offset += (INT64) get4() << 32;\n}\n\nvoid CLASS parse_redcine()\n{\n  unsigned i, len, rdvo;\n\n  order = 0x4d4d;\n  is_raw = 0;\n  fseek (ifp, 52, SEEK_SET);\n  width  = get4();\n  height = get4();\n  fseek (ifp, 0, SEEK_END);\n  fseek (ifp, -(i = ftello(ifp) & 511), SEEK_CUR);\n  if (get4() != i || get4() != 0x52454f42) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s: Tail is missing, parsing from head...\\n\"), ifname);\n#endif\n    fseek (ifp, 0, SEEK_SET);\n    while ((len = get4()) != EOF) {\n      if (get4() == 0x52454456)\n\tif (is_raw++ == shot_select)\n\t  data_offset = ftello(ifp) - 8;\n      fseek (ifp, len-8, SEEK_CUR);\n    }\n  } else {\n    rdvo = get4();\n    fseek (ifp, 12, SEEK_CUR);\n    is_raw = get4();\n    fseeko (ifp, rdvo+8 + shot_select*4, SEEK_SET);\n    data_offset = get4();\n  }\n}\n#line 7429 \"dcraw/dcraw.c\"\nchar * CLASS foveon_gets (int offset, char *str, int len)\n{\n  int i;\n  fseek (ifp, offset, SEEK_SET);\n  for (i=0; i < len-1; i++)\n    if ((str[i] = get2()) == 0) break;\n  str[i] = 0;\n  return str;\n}\n\nvoid CLASS parse_foveon()\n{\n  int entries, img=0, off, len, tag, save, i, wide, high, pent, poff[256][2];\n  char name[64], value[64];\n\n  order = 0x4949;\t\t\t/* Little-endian */\n  fseek (ifp, 36, SEEK_SET);\n  flip = get4();\n  fseek (ifp, -4, SEEK_END);\n  fseek (ifp, get4(), SEEK_SET);\n  if (get4() != 0x64434553) return;\t/* SECd */\n  entries = (get4(),get4());\n  while (entries--) {\n    off = get4();\n    len = get4();\n    tag = get4();\n    save = ftell(ifp);\n    fseek (ifp, off, SEEK_SET);\n    if (get4() != (0x20434553 | (tag << 24))) return;\n    switch (tag) {\n      case 0x47414d49:\t\t\t/* IMAG */\n      case 0x32414d49:\t\t\t/* IMA2 */\n\tfseek (ifp, 8, SEEK_CUR);\n\tpent = get4();\n\twide = get4();\n\thigh = get4();\n\tif (wide > raw_width && high > raw_height) {\n\t  switch (pent) {\n\t    case  5:  load_flags = 1;\n\t    case  6:  load_raw = &CLASS foveon_sd_load_raw;  break;\n\t    case 30:  load_raw = &CLASS foveon_dp_load_raw;  break;\n\t    default:  load_raw = 0;\n\t  }\n\t  raw_width  = wide;\n\t  raw_height = high;\n\t  data_offset = off+28;\n\t}\n\tfseek (ifp, off+28, SEEK_SET);\n\tif (fgetc(ifp) == 0xff && fgetc(ifp) == 0xd8\n\t\t&& thumb_length < len-28) {\n\t  thumb_offset = off+28;\n\t  thumb_length = len-28;\n\t  write_thumb = &CLASS jpeg_thumb;\n\t}\n\tif (++img == 2 && !thumb_length) {\n\t  thumb_offset = off+24;\n\t  thumb_width = wide;\n\t  thumb_height = high;\n\t  write_thumb = &CLASS foveon_thumb;\n\t}\n\tbreak;\n      case 0x464d4143:\t\t\t/* CAMF */\n\tmeta_offset = off+8;\n\tmeta_length = len-28;\n\tbreak;\n      case 0x504f5250:\t\t\t/* PROP */\n\tpent = (get4(),get4());\n\tfseek (ifp, 12, SEEK_CUR);\n\toff += pent*8 + 24;\n\tif ((unsigned) pent > 256) pent=256;\n\tfor (i=0; i < pent*2; i++)\n\t  poff[0][i] = off + get4()*2;\n\tfor (i=0; i < pent; i++) {\n\t  foveon_gets (poff[i][0], name, 64);\n\t  foveon_gets (poff[i][1], value, 64);\n\t  if (!strcmp (name, \"ISO\"))\n\t    iso_speed = atoi(value);\n\t  if (!strcmp (name, \"CAMMANUF\"))\n\t    strcpy (make, value);\n\t  if (!strcmp (name, \"CAMMODEL\"))\n\t    strcpy (model, value);\n\t  if (!strcmp (name, \"WB_DESC\"))\n\t    strcpy (model2, value);\n\t  if (!strcmp (name, \"TIME\"))\n\t    timestamp = atoi(value);\n\t  if (!strcmp (name, \"EXPTIME\"))\n\t    shutter = atoi(value) / 1000000.0;\n\t  if (!strcmp (name, \"APERTURE\"))\n\t    aperture = atof(value);\n\t  if (!strcmp (name, \"FLENGTH\"))\n\t    focal_len = atof(value);\n\t}\n#ifdef LOCALTIME\n\ttimestamp = mktime (gmtime (&timestamp));\n#endif\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n  is_foveon = 1;\n}\n#line 7532 \"dcraw/dcraw.c\"\n/*\n   All matrices are from Adobe DNG Converter unless otherwise noted.\n */\nvoid CLASS adobe_coeff (const char *t_make, const char *t_model)\n{\n  static const struct {\n    const char *prefix;\n    short t_black, t_maximum, trans[12];\n  } table[] = {\n    { \"AGFAPHOTO DC-833m\", 0, 0,\t/* DJC */\n\t{ 11438,-3762,-1115,-2409,9914,2497,-1227,2295,5300 } },\n    { \"Apple QuickTake\", 0, 0,\t\t/* DJC */\n\t{ 21392,-5653,-3353,2406,8010,-415,7166,1427,2078 } },\n    { \"Canon EOS D2000\", 0, 0,\n\t{ 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\n    { \"Canon EOS D6000\", 0, 0,\n\t{ 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\n    { \"Canon EOS D30\", 0, 0,\n\t{ 9805,-2689,-1312,-5803,13064,3068,-2438,3075,8775 } },\n    { \"Canon EOS D60\", 0, 0xfa0,\n\t{ 6188,-1341,-890,-7168,14489,2937,-2640,3228,8483 } },\n    { \"Canon EOS 5D Mark III\", 0, 0x3c80,\n\t{ 6722,-635,-963,-4287,12460,2028,-908,2162,5668 } },\n    { \"Canon EOS 5D Mark II\", 0, 0x3cf0,\n\t{ 4716,603,-830,-7798,15474,2480,-1496,1937,6651 } },\n    { \"Canon EOS 5D\", 0, 0xe6c,\n\t{ 6347,-479,-972,-8297,15954,2480,-1968,2131,7649 } },\n    { \"Canon EOS 6D\", 0, 0x3c82,\n\t{ 7034,-804,-1014,-4420,12564,2058,-851,1994,5758 } },\n    { \"Canon EOS 7D\", 0, 0x3510,\n\t{ 6844,-996,-856,-3876,11761,2396,-593,1772,6198 } },\n    { \"Canon EOS 10D\", 0, 0xfa0,\n\t{ 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\n    { \"Canon EOS 20Da\", 0, 0,\n\t{ 14155,-5065,-1382,-6550,14633,2039,-1623,1824,6561 } },\n    { \"Canon EOS 20D\", 0, 0xfff,\n\t{ 6599,-537,-891,-8071,15783,2424,-1983,2234,7462 } },\n    { \"Canon EOS 30D\", 0, 0,\n\t{ 6257,-303,-1000,-7880,15621,2396,-1714,1904,7046 } },\n    { \"Canon EOS 40D\", 0, 0x3f60,\n\t{ 6071,-747,-856,-7653,15365,2441,-2025,2553,7315 } },\n    { \"Canon EOS 50D\", 0, 0x3d93,\n\t{ 4920,616,-593,-6493,13964,2784,-1774,3178,7005 } },\n    { \"Canon EOS 60D\", 0, 0x2ff7,\n\t{ 6719,-994,-925,-4408,12426,2211,-887,2129,6051 } },\n    { \"Canon EOS 70D\", 0, 0x3c80,\n\t{ 7034,-804,-1014,-4420,12564,2058,-851,1994,5758 } },\n    { \"Canon EOS 300D\", 0, 0xfa0,\n\t{ 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\n    { \"Canon EOS 350D\", 0, 0xfff,\n\t{ 6018,-617,-965,-8645,15881,2975,-1530,1719,7642 } },\n    { \"Canon EOS 400D\", 0, 0xe8e,\n\t{ 7054,-1501,-990,-8156,15544,2812,-1278,1414,7796 } },\n    { \"Canon EOS 450D\", 0, 0x390d,\n\t{ 5784,-262,-821,-7539,15064,2672,-1982,2681,7427 } },\n    { \"Canon EOS 500D\", 0, 0x3479,\n\t{ 4763,712,-646,-6821,14399,2640,-1921,3276,6561 } },\n    { \"Canon EOS 550D\", 0, 0x3dd7,\n\t{ 6941,-1164,-857,-3825,11597,2534,-416,1540,6039 } },\n    { \"Canon EOS 600D\", 0, 0x3510,\n\t{ 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },\n    { \"Canon EOS 650D\", 0, 0x354d,\n\t{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 700D\", 0, 0x354d,\n\t{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS REBEL T5i\", 0, 0x354d,\n\t{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 1000D\", 0, 0xe43,\n\t{ 6771,-1139,-977,-7818,15123,2928,-1244,1437,7533 } },\n    { \"Canon EOS 1100D\", 0, 0x3510,\n\t{ 6444,-904,-893,-4563,12308,2535,-903,2016,6728 } },\n    { \"Canon EOS M\", 0, 0,\n\t{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS-1Ds Mark III\", 0, 0x3bb0,\n\t{ 5859,-211,-930,-8255,16017,2353,-1732,1887,7448 } },\n    { \"Canon EOS-1Ds Mark II\", 0, 0xe80,\n\t{ 6517,-602,-867,-8180,15926,2378,-1618,1771,7633 } },\n    { \"Canon EOS-1D Mark IV\", 0, 0x3bb0,\n\t{ 6014,-220,-795,-4109,12014,2361,-561,1824,5787 } },\n    { \"Canon EOS-1D Mark III\", 0, 0x3bb0,\n\t{ 6291,-540,-976,-8350,16145,2311,-1714,1858,7326 } },\n    { \"Canon EOS-1D Mark II N\", 0, 0xe80,\n\t{ 6240,-466,-822,-8180,15825,2500,-1801,1938,8042 } },\n    { \"Canon EOS-1D Mark II\", 0, 0xe80,\n\t{ 6264,-582,-724,-8312,15948,2504,-1744,1919,8664 } },\n    { \"Canon EOS-1DS\", 0, 0xe20,\n\t{ 4374,3631,-1743,-7520,15212,2472,-2892,3632,8161 } },\n    { \"Canon EOS-1D X\", 0, 0x3c4e,\n\t{ 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },\n    { \"Canon EOS-1D\", 0, 0xe20,\n\t{ 6806,-179,-1020,-8097,16415,1687,-3267,4236,7690 } },\n    { \"Canon EOS 100D\", 0, 0x3cf0,\n\t{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS REBEL SL1\", 0, 0x3cf0,\n\t{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS\", 0, 0,\n\t{ 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\n    { \"Canon PowerShot A530\", 0, 0,\n\t{ 0 } },\t/* don't want the A5 matrix */\n    { \"Canon PowerShot A50\", 0, 0,\n\t{ -5300,9846,1776,3436,684,3939,-5540,9879,6200,-1404,11175,217 } },\n    { \"Canon PowerShot A5\", 0, 0,\n\t{ -4801,9475,1952,2926,1611,4094,-5259,10164,5947,-1554,10883,547 } },\n    { \"Canon PowerShot G10\", 0, 0,\n\t{ 11093,-3906,-1028,-5047,12492,2879,-1003,1750,5561 } },\n    { \"Canon PowerShot G11\", 0, 0,\n\t{ 12177,-4817,-1069,-1612,9864,2049,-98,850,4471 } },\n    { \"Canon PowerShot G12\", 0, 0,\n\t{ 13244,-5501,-1248,-1508,9858,1935,-270,1083,4366 } },\n    { \"Canon PowerShot G15\", 0, 0,\n\t{ 7474,-2301,-567,-4056,11456,2975,-222,716,4181 } },\n    { \"Canon PowerShot G1 X\", 0, 0,\n\t{ 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },\n    { \"Canon PowerShot G1\", 0, 0,\n\t{ -4778,9467,2172,4743,-1141,4344,-5146,9908,6077,-1566,11051,557 } },\n    { \"Canon PowerShot G2\", 0, 0,\n\t{ 9087,-2693,-1049,-6715,14382,2537,-2291,2819,7790 } },\n    { \"Canon PowerShot G3\", 0, 0,\n\t{ 9212,-2781,-1073,-6573,14189,2605,-2300,2844,7664 } },\n    { \"Canon PowerShot G5\", 0, 0,\n\t{ 9757,-2872,-933,-5972,13861,2301,-1622,2328,7212 } },\n    { \"Canon PowerShot G6\", 0, 0,\n\t{ 9877,-3775,-871,-7613,14807,3072,-1448,1305,7485 } },\n    { \"Canon PowerShot G9\", 0, 0,\n\t{ 7368,-2141,-598,-5621,13254,2625,-1418,1696,5743 } },\n    { \"Canon PowerShot Pro1\", 0, 0,\n\t{ 10062,-3522,-999,-7643,15117,2730,-765,817,7323 } },\n    { \"Canon PowerShot Pro70\", 34, 0,\n\t{ -4155,9818,1529,3939,-25,4522,-5521,9870,6610,-2238,10873,1342 } },\n    { \"Canon PowerShot Pro90\", 0, 0,\n\t{ -4963,9896,2235,4642,-987,4294,-5162,10011,5859,-1770,11230,577 } },\n    { \"Canon PowerShot S30\", 0, 0,\n\t{ 10566,-3652,-1129,-6552,14662,2006,-2197,2581,7670 } },\n    { \"Canon PowerShot S40\", 0, 0,\n\t{ 8510,-2487,-940,-6869,14231,2900,-2318,2829,9013 } },\n    { \"Canon PowerShot S45\", 0, 0,\n\t{ 8163,-2333,-955,-6682,14174,2751,-2077,2597,8041 } },\n    { \"Canon PowerShot S50\", 0, 0,\n\t{ 8882,-2571,-863,-6348,14234,2288,-1516,2172,6569 } },\n    { \"Canon PowerShot S60\", 0, 0,\n\t{ 8795,-2482,-797,-7804,15403,2573,-1422,1996,7082 } },\n    { \"Canon PowerShot S70\", 0, 0,\n\t{ 9976,-3810,-832,-7115,14463,2906,-901,989,7889 } },\n    { \"Canon PowerShot S90\", 0, 0,\n\t{ 12374,-5016,-1049,-1677,9902,2078,-83,852,4683 } },\n    { \"Canon PowerShot S95\", 0, 0,\n\t{ 13440,-5896,-1279,-1236,9598,1931,-180,1001,4651 } },\n    { \"Canon PowerShot S110\", 0, 0,\n\t{ 8039,-2643,-654,-3783,11230,2930,-206,690,4194 } },\n    { \"Canon PowerShot S100\", 0, 0,\n\t{ 7968,-2565,-636,-2873,10697,2513,180,667,4211 } },\n    { \"Canon PowerShot S110\", 0, 0,\n\t{ 8039,-2643,-654,-3783,11230,2930,-206,690,4194 } },\n    { \"Canon PowerShot SX1 IS\", 0, 0,\n\t{ 6578,-259,-502,-5974,13030,3309,-308,1058,4970 } },\n    { \"Canon PowerShot SX50 HS\", 0, 0,\n\t{ 12432,-4753,-1247,-2110,10691,1629,-412,1623,4926 } },\n    { \"Canon PowerShot A470\", 0, 0,\t/* DJC */\n\t{ 12513,-4407,-1242,-2680,10276,2405,-878,2215,4734 } },\n    { \"Canon PowerShot A610\", 0, 0,\t/* DJC */\n\t{ 15591,-6402,-1592,-5365,13198,2168,-1300,1824,5075 } },\n    { \"Canon PowerShot A620\", 0, 0,\t/* DJC */\n\t{ 15265,-6193,-1558,-4125,12116,2010,-888,1639,5220 } },\n    { \"Canon PowerShot A630\", 0, 0,\t/* DJC */\n\t{ 14201,-5308,-1757,-6087,14472,1617,-2191,3105,5348 } },\n    { \"Canon PowerShot A640\", 0, 0,\t/* DJC */\n\t{ 13124,-5329,-1390,-3602,11658,1944,-1612,2863,4885 } },\n    { \"Canon PowerShot A650\", 0, 0,\t/* DJC */\n\t{ 9427,-3036,-959,-2581,10671,1911,-1039,1982,4430 } },\n    { \"Canon PowerShot A720\", 0, 0,\t/* DJC */\n\t{ 14573,-5482,-1546,-1266,9799,1468,-1040,1912,3810 } },\n    { \"Canon PowerShot S3 IS\", 0, 0,\t/* DJC */\n\t{ 14062,-5199,-1446,-4712,12470,2243,-1286,2028,4836 } },\n    { \"Canon PowerShot SX110 IS\", 0, 0,\t/* DJC */\n\t{ 14134,-5576,-1527,-1991,10719,1273,-1158,1929,3581 } },\n    { \"Canon PowerShot SX220\", 0, 0,\t/* DJC */\n\t{ 13898,-5076,-1447,-1405,10109,1297,-244,1860,3687 } },\n    { \"Canon PowerShot SX50\", 0, 0,\n\t{ 12432,-4753,-1247,-2110,10691,1629,-412,1623,4926 } },\n    { \"CASIO EX-S20\", 0, 0,\t\t/* DJC */\n\t{ 11634,-3924,-1128,-4968,12954,2015,-1588,2648,7206 } },\n    { \"CASIO EX-Z750\", 0, 0,\t\t/* DJC */\n\t{ 10819,-3873,-1099,-4903,13730,1175,-1755,3751,4632 } },\n    { \"CASIO EX-Z10\", 128, 0xfff,\t/* DJC */\n\t{ 9790,-3338,-603,-2321,10222,2099,-344,1273,4799 } },\n    { \"CINE 650\", 0, 0,\n\t{ 3390,480,-500,-800,3610,340,-550,2336,1192 } },\n    { \"CINE 660\", 0, 0,\n\t{ 3390,480,-500,-800,3610,340,-550,2336,1192 } },\n    { \"CINE\", 0, 0,\n\t{ 20183,-4295,-423,-3940,15330,3985,-280,4870,9800 } },\n    { \"Contax N Digital\", 0, 0xf1e,\n\t{ 7777,1285,-1053,-9280,16543,2916,-3677,5679,7060 } },\n    { \"EPSON R-D1\", 0, 0,\n\t{ 6827,-1878,-732,-8429,16012,2564,-704,592,7145 } },\n    { \"FUJIFILM E550\", 0, 0,\n\t{ 11044,-3888,-1120,-7248,15168,2208,-1531,2277,8069 } },\n    { \"FUJIFILM E900\", 0, 0,\n\t{ 9183,-2526,-1078,-7461,15071,2574,-2022,2440,8639 } },\n    { \"FUJIFILM F5\", 0, 0,\n\t{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"FUJIFILM F6\", 0, 0,\n\t{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"FUJIFILM F77\", 0, 0xfe9,\n\t{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"FUJIFILM F7\", 0, 0,\n\t{ 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\n    { \"FUJIFILM F800\", 0, 0,\n\t{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"FUJIFILM F8\", 0, 0,\n\t{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"FUJIFILM S100FS\", 514, 0,\n\t{ 11521,-4355,-1065,-6524,13767,3058,-1466,1984,6045 } },\n    { \"FUJIFILM S200EXR\", 512, 0x3fff,\n\t{ 11401,-4498,-1312,-5088,12751,2613,-838,1568,5941 } },\n    { \"FUJIFILM S20Pro\", 0, 0,\n\t{ 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\n    { \"FUJIFILM S2Pro\", 128, 0,\n\t{ 12492,-4690,-1402,-7033,15423,1647,-1507,2111,7697 } },\n    { \"FUJIFILM S3Pro\", 0, 0,\n\t{ 11807,-4612,-1294,-8927,16968,1988,-2120,2741,8006 } },\n    { \"FUJIFILM S5Pro\", 0, 0,\n\t{ 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\n    { \"FUJIFILM S5000\", 0, 0,\n\t{ 8754,-2732,-1019,-7204,15069,2276,-1702,2334,6982 } },\n    { \"FUJIFILM S5100\", 0, 0,\n\t{ 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\n    { \"FUJIFILM S5500\", 0, 0,\n\t{ 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\n    { \"FUJIFILM S5200\", 0, 0,\n\t{ 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\n    { \"FUJIFILM S5600\", 0, 0,\n\t{ 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\n    { \"FUJIFILM S6\", 0, 0,\n\t{ 12628,-4887,-1401,-6861,14996,1962,-2198,2782,7091 } },\n    { \"FUJIFILM S7000\", 0, 0,\n\t{ 10190,-3506,-1312,-7153,15051,2238,-2003,2399,7505 } },\n    { \"FUJIFILM S9000\", 0, 0,\n\t{ 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\n    { \"FUJIFILM S9500\", 0, 0,\n\t{ 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\n    { \"FUJIFILM S9100\", 0, 0,\n\t{ 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\n    { \"FUJIFILM S9600\", 0, 0,\n\t{ 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\n    { \"FUJIFILM IS-1\", 0, 0,\n\t{ 21461,-10807,-1441,-2332,10599,1999,289,875,7703 } },\n    { \"FUJIFILM IS Pro\", 0, 0,\n\t{ 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\n    { \"FUJIFILM HS10 HS11\", 0, 0xf68,\n\t{ 12440,-3954,-1183,-1123,9674,1708,-83,1614,4086 } },\n    { \"FUJIFILM HS20EXR\", 0, 0,\n\t{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"FUJIFILM HS3\", 0, 0,\n\t{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"FUJIFILM HS50EXR\", 0, 0,\n\t{ 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },\n    { \"FUJIFILM SL1000\", 0, 0,\n\t{ 11705,-4262,-1107,-2282,10791,1709,-555,1713,4945 } },\n    { \"FUJIFILM X100S\", 0, 0,\n\t{ 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },\n    { \"FUJIFILM X100\", 0, 0,\n\t{ 12161,-4457,-1069,-5034,12874,2400,-795,1724,6904 } },\n    { \"FUJIFILM X10\", 0, 0,\n\t{ 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"FUJIFILM X20\", 0, 0,\n\t{ 11768,-4971,-1133,-4904,12927,2183,-480,1723,4605 } },\n    { \"FUJIFILM XF1\", 0, 0,\n\t{ 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"FUJIFILM X-Pro1\", 0, 0,\n\t{ 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },\n    { \"FUJIFILM X-E1\", 0, 0,\n\t{ 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },\n    { \"FUJIFILM XF1\", 0, 0,\n\t{ 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"FUJIFILM X-S1\", 0, 0,\n\t{ 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Imacon Ixpress\", 0, 0,\t\t/* DJC */\n\t{ 7025,-1415,-704,-5188,13765,1424,-1248,2742,6038 } },\n    { \"KODAK NC2000\", 0, 0,\n\t{ 13891,-6055,-803,-465,9919,642,2121,82,1291 } },\n    { \"Kodak DCS315C\", 8, 0,\n\t{ 17523,-4827,-2510,756,8546,-137,6113,1649,2250 } },\n    { \"Kodak DCS330C\", 8, 0,\n\t{ 20620,-7572,-2801,-103,10073,-396,3551,-233,2220 } },\n    { \"KODAK DCS420\", 0, 0,\n\t{ 10868,-1852,-644,-1537,11083,484,2343,628,2216 } },\n    { \"KODAK DCS460\", 0, 0,\n\t{ 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\n    { \"KODAK EOSDCS1\", 0, 0,\n\t{ 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\n    { \"KODAK EOSDCS3B\", 0, 0,\n\t{ 9898,-2700,-940,-2478,12219,206,1985,634,1031 } },\n    { \"Kodak DCS520C\", 178, 0,\n\t{ 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\n    { \"Kodak DCS560C\", 177, 0,\n\t{ 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\n    { \"Kodak DCS620C\", 177, 0,\n\t{ 23617,-10175,-3149,-2054,11749,-272,2586,-489,3453 } },\n    { \"Kodak DCS620X\", 176, 0,\n\t{ 13095,-6231,154,12221,-21,-2137,895,4602,2258 } },\n    { \"Kodak DCS660C\", 173, 0,\n\t{ 18244,-6351,-2739,-791,11193,-521,3711,-129,2802 } },\n    { \"Kodak DCS720X\", 0, 0,\n\t{ 11775,-5884,950,9556,1846,-1286,-1019,6221,2728 } },\n    { \"Kodak DCS760C\", 0, 0,\n\t{ 16623,-6309,-1411,-4344,13923,323,2285,274,2926 } },\n    { \"Kodak DCS Pro SLR\", 0, 0,\n\t{ 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\n    { \"Kodak DCS Pro 14nx\", 0, 0,\n\t{ 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\n    { \"Kodak DCS Pro 14\", 0, 0,\n\t{ 7791,3128,-776,-8588,16458,2039,-2455,4006,6198 } },\n    { \"Kodak ProBack645\", 0, 0,\n\t{ 16414,-6060,-1470,-3555,13037,473,2545,122,4948 } },\n    { \"Kodak ProBack\", 0, 0,\n\t{ 21179,-8316,-2918,-915,11019,-165,3477,-180,4210 } },\n    { \"KODAK P712\", 0, 0,\n\t{ 9658,-3314,-823,-5163,12695,2768,-1342,1843,6044 } },\n    { \"KODAK P850\", 0, 0xf7c,\n\t{ 10511,-3836,-1102,-6946,14587,2558,-1481,1792,6246 } },\n    { \"KODAK P880\", 0, 0xfff,\n\t{ 12805,-4662,-1376,-7480,15267,2360,-1626,2194,7904 } },\n    { \"KODAK EasyShare Z980\", 0, 0,\n\t{ 11313,-3559,-1101,-3893,11891,2257,-1214,2398,4908 } },\n    { \"KODAK EasyShare Z981\", 0, 0,\n\t{ 12729,-4717,-1188,-1367,9187,2582,274,860,4411 } },\n    { \"KODAK EasyShare Z990\", 0, 0xfed,\n\t{ 11749,-4048,-1309,-1867,10572,1489,-138,1449,4522 } },\n    { \"KODAK EASYSHARE Z1015\", 0, 0xef1,\n\t{ 11265,-4286,-992,-4694,12343,2647,-1090,1523,5447 } },\n    { \"Leaf CMost\", 0, 0,\n\t{ 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\n    { \"Leaf Valeo 6\", 0, 0,\n\t{ 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\n    { \"Leaf Aptus 54S\", 0, 0,\n\t{ 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\n    { \"Leaf Aptus 65\", 0, 0,\n\t{ 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf Aptus 75\", 0, 0,\n\t{ 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf\", 0, 0,\n\t{ 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\n    { \"Mamiya ZD\", 0, 0,\n\t{ 7645,2579,-1363,-8689,16717,2015,-3712,5941,5961 } },\n    { \"Micron 2010\", 110, 0,\t\t/* DJC */\n\t{ 16695,-3761,-2151,155,9682,163,3433,951,4904 } },\n    { \"Minolta DiMAGE 5\", 0, 0xf7d,\n\t{ 8983,-2942,-963,-6556,14476,2237,-2426,2887,8014 } },\n    { \"Minolta DiMAGE 7Hi\", 0, 0xf7d,\n\t{ 11368,-3894,-1242,-6521,14358,2339,-2475,3056,7285 } },\n    { \"Minolta DiMAGE 7\", 0, 0xf7d,\n\t{ 9144,-2777,-998,-6676,14556,2281,-2470,3019,7744 } },\n    { \"Minolta DiMAGE A1\", 0, 0xf8b,\n\t{ 9274,-2547,-1167,-8220,16323,1943,-2273,2720,8340 } },\n    { \"MINOLTA DiMAGE A200\", 0, 0,\n\t{ 8560,-2487,-986,-8112,15535,2771,-1209,1324,7743 } },\n    { \"Minolta DiMAGE A2\", 0, 0xf8f,\n\t{ 9097,-2726,-1053,-8073,15506,2762,-966,981,7763 } },\n    { \"Minolta DiMAGE Z2\", 0, 0,\t/* DJC */\n\t{ 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\n    { \"MINOLTA DYNAX 5\", 0, 0xffb,\n\t{ 10284,-3283,-1086,-7957,15762,2316,-829,882,6644 } },\n    { \"MINOLTA DYNAX 7\", 0, 0xffb,\n\t{ 10239,-3104,-1099,-8037,15727,2451,-927,925,6871 } },\n    { \"MOTOROLA PIXL\", 0, 0,\t\t/* DJC */\n\t{ 8898,-989,-1033,-3292,11619,1674,-661,3178,5216 } },\n    { \"NIKON D100\", 0, 0,\n\t{ 5902,-933,-782,-8983,16719,2354,-1402,1455,6464 } },\n    { \"NIKON D1H\", 0, 0,\n\t{ 7577,-2166,-926,-7454,15592,1934,-2377,2808,8606 } },\n    { \"NIKON D1X\", 0, 0,\n\t{ 7702,-2245,-975,-9114,17242,1875,-2679,3055,8521 } },\n    { \"NIKON D1\", 0, 0, /* multiplied by 2.218750, 1.0, 1.148438 */\n\t{ 16772,-4726,-2141,-7611,15713,1972,-2846,3494,9521 } },\n    { \"NIKON D200\", 0, 0xfbc,\n\t{ 8367,-2248,-763,-8758,16447,2422,-1527,1550,8053 } },\n    { \"NIKON D2H\", 0, 0,\n\t{ 5710,-901,-615,-8594,16617,2024,-2975,4120,6830 } },\n    { \"NIKON D2X\", 0, 0,\n\t{ 10231,-2769,-1255,-8301,15900,2552,-797,680,7148 } },\n    { \"NIKON D3000\", 0, 0,\n\t{ 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },\n    { \"NIKON D3100\", 0, 0,\n\t{ 7911,-2167,-813,-5327,13150,2408,-1288,2483,7968 } },\n    { \"NIKON D3200\", 0, 0xfb9,\n\t{ 7013,-1408,-635,-5268,12902,2640,-1470,2801,7379 } },\n    { \"NIKON D300\", 0, 0,\n\t{ 9030,-1992,-715,-8465,16302,2255,-2689,3217,8069 } },\n    { \"NIKON D3X\", 0, 0,\n\t{ 7171,-1986,-648,-8085,15555,2718,-2170,2512,7457 } },\n    { \"NIKON D3S\", 0, 0,\n\t{ 8828,-2406,-694,-4874,12603,2541,-660,1509,7587 } },\n    { \"NIKON D3\", 0, 0,\n\t{ 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\n    { \"NIKON D40X\", 0, 0,\n\t{ 8819,-2543,-911,-9025,16928,2151,-1329,1213,8449 } },\n    { \"NIKON D40\", 0, 0,\n\t{ 6992,-1668,-806,-8138,15748,2543,-874,850,7897 } },\n    { \"NIKON D4\", 0, 0,\n\t{ 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"NIKON D5000\", 0, 0xf00,\n\t{ 7309,-1403,-519,-8474,16008,2622,-2433,2826,8064 } },\n    { \"NIKON D5100\", 0, 0x3de6,\n\t{ 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"NIKON D5200\", 0, 0,\n\t{ 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"NIKON D50\", 0, 0,\n\t{ 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\n    { \"NIKON D600\", 0, 0x3e07,\n\t{ 8178,-2245,-609,-4857,12394,2776,-1207,2086,7298 } },\n    { \"NIKON D60\", 0, 0,\n\t{ 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },\n    { \"NIKON D7000\", 0, 0,\n\t{ 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"NIKON D700\", 0, 0,\n\t{ 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\n    { \"NIKON D70\", 0, 0,\n\t{ 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\n    { \"NIKON D7100\", 0, 0,\n\t{ 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"NIKON D800\", 0, 0,\n\t{ 7866,-2108,-555,-4869,12483,2681,-1176,2069,7501 } },\n    { \"NIKON D80\", 0, 0,\n\t{ 8629,-2410,-883,-9055,16940,2171,-1490,1363,8520 } },\n    { \"NIKON D90\", 0, 0xf00,\n\t{ 7309,-1403,-519,-8474,16008,2622,-2434,2826,8064 } },\n    { \"NIKON E950\", 0, 0x3dd,\t\t/* DJC */\n\t{ -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"NIKON E995\", 0, 0,\t/* copied from E5000 */\n\t{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"NIKON E2100\", 0, 0,\t/* copied from Z2, new white balance */\n\t{ 13142,-4152,-1596,-4655,12374,2282,-1769,2696,6711} },\n    { \"NIKON E2500\", 0, 0,\n\t{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"NIKON E3200\", 0, 0,\t\t/* DJC */\n\t{ 9846,-2085,-1019,-3278,11109,2170,-774,2134,5745 } },\n    { \"NIKON E4300\", 0, 0,\t/* copied from Minolta DiMAGE Z2 */\n\t{ 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\n    { \"NIKON E4500\", 0, 0,\n\t{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"NIKON E5000\", 0, 0,\n\t{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"NIKON E5400\", 0, 0,\n\t{ 9349,-2987,-1001,-7919,15766,2266,-2098,2680,6839 } },\n    { \"NIKON E5700\", 0, 0,\n\t{ -5368,11478,2368,5537,-113,3148,-4969,10021,5782,778,9028,211 } },\n    { \"NIKON E8400\", 0, 0,\n\t{ 7842,-2320,-992,-8154,15718,2599,-1098,1342,7560 } },\n    { \"NIKON E8700\", 0, 0,\n\t{ 8489,-2583,-1036,-8051,15583,2643,-1307,1407,7354 } },\n    { \"NIKON E8800\", 0, 0,\n\t{ 7971,-2314,-913,-8451,15762,2894,-1442,1520,7610 } },\n    { \"NIKON COOLPIX A\", 0, 0,\n\t{ 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"NIKON COOLPIX P330\", 0, 0,\n\t{ 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"NIKON COOLPIX P6000\", 0, 0,\n\t{ 9698,-3367,-914,-4706,12584,2368,-837,968,5801 } },\n    { \"NIKON COOLPIX P7000\", 0, 0,\n\t{ 11432,-3679,-1111,-3169,11239,2202,-791,1380,4455 } },\n    { \"NIKON COOLPIX P7100\", 0, 0,\n\t{ 11053,-4269,-1024,-1976,10182,2088,-526,1263,4469 } },\n    { \"NIKON COOLPIX P7700\", 200, 0,\n\t{ 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"NIKON 1 J3\", 0, 0,\n\t{ 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },\n    { \"NIKON 1 S1\", 0, 0,\n\t{ 8994,-2667,-865,-4594,12324,2552,-699,1786,6260 } },\n    { \"NIKON 1 V2\", 0, 0,\n\t{ 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },\n    { \"NIKON 1 \", 0, 0,\n\t{ 8994,-2667,-865,-4594,12324,2552,-699,1786,6260 } },\n    { \"OLYMPUS C5050\", 0, 0,\n\t{ 10508,-3124,-1273,-6079,14294,1901,-1653,2306,6237 } },\n    { \"OLYMPUS C5060\", 0, 0,\n\t{ 10445,-3362,-1307,-7662,15690,2058,-1135,1176,7602 } },\n    { \"OLYMPUS C7070\", 0, 0,\n\t{ 10252,-3531,-1095,-7114,14850,2436,-1451,1723,6365 } },\n    { \"OLYMPUS C70\", 0, 0,\n\t{ 10793,-3791,-1146,-7498,15177,2488,-1390,1577,7321 } },\n    { \"OLYMPUS C80\", 0, 0,\n\t{ 8606,-2509,-1014,-8238,15714,2703,-942,979,7760 } },\n    { \"OLYMPUS E-10\", 0, 0xffc,\n\t{ 12745,-4500,-1416,-6062,14542,1580,-1934,2256,6603 } },\n    { \"OLYMPUS E-1\", 0, 0,\n\t{ 11846,-4767,-945,-7027,15878,1089,-2699,4122,8311 } },\n    { \"OLYMPUS E-20\", 0, 0xffc,\n\t{ 13173,-4732,-1499,-5807,14036,1895,-2045,2452,7142 } },\n    { \"OLYMPUS E-300\", 0, 0,\n\t{ 7828,-1761,-348,-5788,14071,1830,-2853,4518,6557 } },\n    { \"OLYMPUS E-330\", 0, 0,\n\t{ 8961,-2473,-1084,-7979,15990,2067,-2319,3035,8249 } },\n    { \"OLYMPUS E-30\", 0, 0xfbc,\n\t{ 8144,-1861,-1111,-7763,15894,1929,-1865,2542,7607 } },\n    { \"OLYMPUS E-3\", 0, 0xf99,\n\t{ 9487,-2875,-1115,-7533,15606,2010,-1618,2100,7389 } },\n    { \"OLYMPUS E-400\", 0, 0,\n\t{ 6169,-1483,-21,-7107,14761,2536,-2904,3580,8568 } },\n    { \"OLYMPUS E-410\", 0, 0xf6a,\n\t{ 8856,-2582,-1026,-7761,15766,2082,-2009,2575,7469 } },\n    { \"OLYMPUS E-420\", 0, 0xfd7,\n\t{ 8746,-2425,-1095,-7594,15612,2073,-1780,2309,7416 } },\n    { \"OLYMPUS E-450\", 0, 0xfd2,\n\t{ 8745,-2425,-1095,-7594,15613,2073,-1780,2309,7416 } },\n    { \"OLYMPUS E-500\", 0, 0,\n\t{ 8136,-1968,-299,-5481,13742,1871,-2556,4205,6630 } },\n    { \"OLYMPUS E-510\", 0, 0xf6a,\n\t{ 8785,-2529,-1033,-7639,15624,2112,-1783,2300,7817 } },\n    { \"OLYMPUS E-520\", 0, 0xfd2,\n\t{ 8344,-2322,-1020,-7596,15635,2048,-1748,2269,7287 } },\n    { \"OLYMPUS E-5\", 0, 0xeec,\n\t{ 11200,-3783,-1325,-4576,12593,2206,-695,1742,7504 } },\n    { \"OLYMPUS E-600\", 0, 0xfaf,\n\t{ 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },\n    { \"OLYMPUS E-620\", 0, 0xfaf,\n\t{ 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },\n    { \"OLYMPUS E-P1\", 0, 0xffd,\n\t{ 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },\n    { \"OLYMPUS E-P2\", 0, 0xffd,\n\t{ 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },\n    { \"OLYMPUS E-P3\", 0, 0,\n\t{ 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"OLYMPUS E-P5\", 0, 0,\n\t{ 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"OLYMPUS E-PL1s\", 0, 0,\n\t{ 11409,-3872,-1393,-4572,12757,2003,-709,1810,7415 } },\n    { \"OLYMPUS E-PL1\", 0, 0,\n\t{ 11408,-4289,-1215,-4286,12385,2118,-387,1467,7787 } },\n    { \"OLYMPUS E-PL2\", 0, 0,\n\t{ 15030,-5552,-1806,-3987,12387,1767,-592,1670,7023 } },\n    { \"OLYMPUS E-PL3\", 0, 0,\n\t{ 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"OLYMPUS E-PL5\", 0, 0xfcb,\n\t{ 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"OLYMPUS E-PM1\", 0, 0,\n\t{ 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"OLYMPUS E-PM2\", 0, 0,\n\t{ 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"OLYMPUS E-M5\", 0, 0xfe1,\n\t{ 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"OLYMPUS SP350\", 0, 0,\n\t{ 12078,-4836,-1069,-6671,14306,2578,-786,939,7418 } },\n    { \"OLYMPUS SP3\", 0, 0,\n\t{ 11766,-4445,-1067,-6901,14421,2707,-1029,1217,7572 } },\n    { \"OLYMPUS SP500UZ\", 0, 0xfff,\n\t{ 9493,-3415,-666,-5211,12334,3260,-1548,2262,6482 } },\n    { \"OLYMPUS SP510UZ\", 0, 0xffe,\n\t{ 10593,-3607,-1010,-5881,13127,3084,-1200,1805,6721 } },\n    { \"OLYMPUS SP550UZ\", 0, 0xffe,\n\t{ 11597,-4006,-1049,-5432,12799,2957,-1029,1750,6516 } },\n    { \"OLYMPUS SP560UZ\", 0, 0xff9,\n\t{ 10915,-3677,-982,-5587,12986,2911,-1168,1968,6223 } },\n    { \"OLYMPUS SP570UZ\", 0, 0,\n\t{ 11522,-4044,-1146,-4736,12172,2904,-988,1829,6039 } },\n    { \"OLYMPUS XZ-10\", 0, 0,\n\t{ 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },\n    { \"OLYMPUS XZ-1\", 0, 0,\n\t{ 10901,-4095,-1074,-1141,9208,2293,-62,1417,5158 } },\n    { \"OLYMPUS XZ-2\", 0, 0,\n\t{ 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },\n    { \"OmniVision ov5647\", 0, 0,\t/* DJC */\n\t{ 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } },\n    { \"PENTAX *ist DL2\", 0, 0,\n\t{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"PENTAX *ist DL\", 0, 0,\n\t{ 10829,-2838,-1115,-8339,15817,2696,-837,680,11939 } },\n    { \"PENTAX *ist DS2\", 0, 0,\n\t{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"PENTAX *ist DS\", 0, 0,\n\t{ 10371,-2333,-1206,-8688,16231,2602,-1230,1116,11282 } },\n    { \"PENTAX *ist D\", 0, 0,\n\t{ 9651,-2059,-1189,-8881,16512,2487,-1460,1345,10687 } },\n    { \"PENTAX K10D\", 0, 0,\n\t{ 9566,-2863,-803,-7170,15172,2112,-818,803,9705 } },\n    { \"PENTAX K1\", 0, 0,\n\t{ 11095,-3157,-1324,-8377,15834,2720,-1108,947,11688 } },\n    { \"PENTAX K20D\", 0, 0,\n\t{ 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },\n    { \"PENTAX K200D\", 0, 0,\n\t{ 9186,-2678,-907,-8693,16517,2260,-1129,1094,8524 } },\n    { \"PENTAX K2000\", 0, 0,\n\t{ 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },\n    { \"PENTAX K-m\", 0, 0,\n\t{ 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },\n    { \"PENTAX K-x\", 0, 0,\n\t{ 8843,-2837,-625,-5025,12644,2668,-411,1234,7410 } },\n    { \"PENTAX K-r\", 0, 0,\n\t{ 9895,-3077,-850,-5304,13035,2521,-883,1768,6936 } },\n    { \"PENTAX K-30\", 0, 0,\n\t{ 8833,-2670,-1183,-3995,12301,1881,-979,1717,6527 } },\n    { \"PENTAX K-5 II s\", 0, 0,\n\t{ 8366,-2528,-1120,-3995,12301,1881,-998,1749,6649 } },\n    { \"PENTAX K-5 II\", 0, 0,\n\t{ 8773,-2651,-1175,-3995,12301,1881,-973,1706,6486 } },\n    { \"PENTAX K-5\", 0, 0,\n\t{ 8713,-2833,-743,-4342,11900,2772,-722,1543,6247 } },\n    { \"PENTAX K-7\", 0, 0,\n\t{ 9142,-2947,-678,-8648,16967,1663,-2224,2898,8615 } },\n    { \"PENTAX MX-1\", 0, 0,\n\t{ 8804,-2523,-1238,-2423,11627,860,-682,1774,4753 } },\n    { \"PENTAX Q10\", 0, 0,\n\t{ 12995,-5593,-1107,-1879,10139,2027,-64,1233,4919 } },\n    { \"PENTAX 645D\", 0, 0x3e00,\n\t{ 10646,-3593,-1158,-3329,11699,1831,-667,2874,6287 } },\n    { \"Panasonic DMC-FZ8\", 0, 0xf7f,\n\t{ 8986,-2755,-802,-6341,13575,3077,-1476,2144,6379 } },\n    { \"Panasonic DMC-FZ18\", 0, 0,\n\t{ 9932,-3060,-935,-5809,13331,2753,-1267,2155,5575 } },\n    { \"Panasonic DMC-FZ28\", 15, 0xf96,\n\t{ 10109,-3488,-993,-5412,12812,2916,-1305,2140,5543 } },\n    { \"Panasonic DMC-FZ30\", 0, 0xf94,\n\t{ 10976,-4029,-1141,-7918,15491,2600,-1670,2071,8246 } },\n    { \"Panasonic DMC-FZ3\", 143, 0,\n\t{ 9938,-2780,-890,-4604,12393,2480,-1117,2304,4620 } },\n    { \"Panasonic DMC-FZ4\", 143, 0,\n\t{ 13639,-5535,-1371,-1698,9633,2430,316,1152,4108 } },\n    { \"Panasonic DMC-FZ50\", 0, 0,\n\t{ 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\n    { \"LEICA V-LUX1\", 0, 0,\n\t{ 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\n    { \"Panasonic DMC-L10\", 15, 0xf96,\n\t{ 8025,-1942,-1050,-7920,15904,2100,-2456,3005,7039 } },\n    { \"Panasonic DMC-L1\", 0, 0xf7f,\n\t{ 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\n    { \"LEICA DIGILUX 3\", 0, 0xf7f,\n\t{ 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\n    { \"Panasonic DMC-LC1\", 0, 0,\n\t{ 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\n    { \"LEICA DIGILUX 2\", 0, 0,\n\t{ 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\n    { \"Panasonic DMC-LF1\", 143, 0,\n\t{ 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },\n    { \"Panasonic DMC-LX1\", 0, 0xf7f,\n\t{ 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\n    { \"LEICA D-LUX2\", 0, 0xf7f,\n\t{ 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\n    { \"Panasonic DMC-LX2\", 0, 0,\n\t{ 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\n    { \"LEICA D-LUX3\", 0, 0,\n\t{ 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\n    { \"Panasonic DMC-LX3\", 15, 0,\n\t{ 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },\n    { \"LEICA D-LUX 4\", 15, 0,\n\t{ 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },\n    { \"Panasonic DMC-LX5\", 143, 0,\n\t{ 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },\n    { \"Panasonic DMC-LX7\", 143, 0,\n\t{ 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"LEICA D-LUX 5\", 143, 0,\n\t{ 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },\n    { \"Panasonic DMC-LX7\", 143, 0,\n\t{ 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"LEICA D-LUX 6\", 143, 0,\n\t{ 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"Panasonic DMC-FZ100\", 143, 0xfff,\n\t{ 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },\n    { \"LEICA V-LUX 2\", 143, 0xfff,\n\t{ 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },\n    { \"Panasonic DMC-FZ150\", 143, 0xfff,\n\t{ 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },\n    { \"LEICA V-LUX 3\", 143, 0xfff,\n\t{ 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },\n    { \"Panasonic DMC-FZ200\", 143, 0xfff,\n\t{ 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },\n    { \"LEICA V-LUX 4\", 143, 0xfff,\n\t{ 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },\n    { \"Panasonic DMC-FX150\", 15, 0xfff,\n\t{ 9082,-2907,-925,-6119,13377,3058,-1797,2641,5609 } },\n    { \"Panasonic DMC-G10\", 0, 0,\n\t{ 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },\n    { \"Panasonic DMC-G1\", 15, 0xf94,\n\t{ 8199,-2065,-1056,-8124,16156,2033,-2458,3022,7220 } },\n    { \"Panasonic DMC-G2\", 15, 0xf3c,\n\t{ 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },\n    { \"Panasonic DMC-G3\", 143, 0xfff,\n\t{ 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },\n    { \"Panasonic DMC-G5\", 143, 0xfff,\n\t{ 7798,-2562,-740,-3879,11584,2613,-1055,2248,5434 } },\n    { \"Panasonic DMC-G6\", 143, 0xfff,\n\t{ 8294,-2891,-651,-3869,11590,2595,-1183,2267,5352 } },\n    { \"Panasonic DMC-GF1\", 15, 0xf92,\n\t{ 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },\n    { \"Panasonic DMC-GF2\", 143, 0xfff,\n\t{ 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },\n    { \"Panasonic DMC-GF3\", 143, 0xfff,\n\t{ 9051,-2468,-1204,-5212,13276,2121,-1197,2510,6890 } },\n    { \"Panasonic DMC-GF5\", 143, 0xfff,\n\t{ 8228,-2945,-660,-3938,11792,2430,-1094,2278,5793 } },\n    { \"Panasonic DMC-GF6\", 143, 0,\n\t{ 8130,-2801,-946,-3520,11289,2552,-1314,2511,5791 } },\n    { \"Panasonic DMC-GH1\", 15, 0xf92,\n\t{ 6299,-1466,-532,-6535,13852,2969,-2331,3112,5984 } },\n    { \"Panasonic DMC-GH2\", 15, 0xf95,\n\t{ 7780,-2410,-806,-3913,11724,2484,-1018,2390,5298 } },\n    { \"Panasonic DMC-GH3\", 144, 0,\n\t{ 6559,-1752,-491,-3672,11407,2586,-962,1875,5130 } },\n    { \"Panasonic DMC-GX1\", 143, 0,\n\t{ 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },\n    { \"Phase One H 20\", 0, 0,\t\t/* DJC */\n\t{ 1313,1855,-109,-6715,15908,808,-327,1840,6020 } },\n    { \"Phase One H 25\", 0, 0,\n\t{ 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One P 2\", 0, 0,\n\t{ 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One P 30\", 0, 0,\n\t{ 4516,-245,-37,-7020,14976,2173,-3206,4671,7087 } },\n    { \"Phase One P 45\", 0, 0,\n\t{ 5053,-24,-117,-5684,14076,1702,-2619,4492,5849 } },\n    { \"Phase One P40\", 0, 0,\n\t{ 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Phase One P65\", 0, 0,\n\t{ 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"RED ONE\", 704, 0xffff,\t\t/* DJC */\n\t{ 21014,-7891,-2613,-3056,12201,856,-2203,5125,8042 } },\n    { \"SAMSUNG EX1\", 0, 0x3e00,\n\t{ 8898,-2498,-994,-3144,11328,2066,-760,1381,4576 } },\n    { \"SAMSUNG EX2F\", 0, 0x7ff,\n\t{ 10648,-3897,-1055,-2022,10573,1668,-492,1611,4742 } },\n    { \"SAMSUNG NX2\", 0, 0xfff,\t/* NX20, NX200, NX210 */\n\t{ 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"SAMSUNG NX1000\", 0, 0,\n\t{ 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"SAMSUNG NX\", 0, 0,\t/* NX5, NX10, NX11, NX100 */\n\t{ 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"SAMSUNG WB2000\", 0, 0xfff,\n\t{ 12093,-3557,-1155,-1000,9534,1733,-22,1787,4576 } },\n    { \"SAMSUNG GX-1\", 0, 0,\n\t{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"SAMSUNG S85\", 0, 0xffff,\t\t/* DJC */\n\t{ 11885,-3968,-1473,-4214,12299,1916,-835,1655,5549 } },\n    { \"Sinar\", 0, 0,\t\t\t/* DJC */\n\t{ 16442,-2956,-2422,-2877,12128,750,-1136,6066,4559 } },\n    { \"SONY DSC-F828\", 0, 0,\n\t{ 7924,-1910,-777,-8226,15459,2998,-1517,2199,6818,-7242,11401,3481 } },\n    { \"SONY DSC-R1\", 512, 0,\n\t{ 8512,-2641,-694,-8042,15670,2526,-1821,2117,7414 } },\n    { \"SONY DSC-V3\", 0, 0,\n\t{ 7511,-2571,-692,-7894,15088,3060,-948,1111,8128 } },\n    { \"SONY DSC-RX100M2\", 200, 0,\n\t{ 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },\n    { \"SONY DSC-RX100\", 200, 0,\n\t{ 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },\n    { \"SONY DSC-RX1R\", 128, 0,\n\t{ 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n    { \"SONY DSC-RX1\", 128, 0,\n\t{ 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n    { \"SONY DSLR-A100\", 0, 0xfeb,\n\t{ 9437,-2811,-774,-8405,16215,2290,-710,596,7181 } },\n    { \"SONY DSLR-A290\", 0, 0,\n\t{ 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"SONY DSLR-A2\", 0, 0,\n\t{ 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\n    { \"SONY DSLR-A300\", 0, 0,\n\t{ 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\n    { \"SONY DSLR-A330\", 0, 0,\n\t{ 9847,-3091,-929,-8485,16346,2225,-714,595,7103 } },\n    { \"SONY DSLR-A350\", 0, 0xffc,\n\t{ 6038,-1484,-578,-9146,16746,2513,-875,746,7217 } },\n    { \"SONY DSLR-A380\", 0, 0,\n\t{ 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"SONY DSLR-A390\", 0, 0,\n\t{ 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"SONY DSLR-A450\", 128, 0xfeb,\n\t{ 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },\n    { \"SONY DSLR-A580\", 128, 0xfeb,\n\t{ 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },\n    { \"SONY DSLR-A5\", 128, 0xfeb,\n\t{ 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },\n    { \"SONY DSLR-A700\", 126, 0,\n\t{ 5775,-805,-359,-8574,16295,2391,-1943,2341,7249 } },\n    { \"SONY DSLR-A850\", 128, 0,\n\t{ 5413,-1162,-365,-5665,13098,2866,-608,1179,8440 } },\n    { \"SONY DSLR-A900\", 128, 0,\n\t{ 5209,-1072,-397,-8845,16120,2919,-1618,1803,8654 } },\n    { \"SONY NEX-3N\", 128, 0,\t\t/* Adobe */\n\t{ 6129,-1545,\t-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"SONY NEX-3\", 128, 0,\t\t/* Adobe */\n\t{ 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },\n    { \"SONY NEX-5N\", 128, 0,\n\t{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"SONY NEX-5R\", 128, 0,\t\t\n\t{ 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"SONY NEX-5\", 128, 0,\t\t/* Adobe */\n\t{ 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },\n    { \"SONY NEX-6\", 128, 0,\n\t{ 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"SONY NEX-7\", 128, 0,\n\t{ 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"SONY NEX\", 128, 0,\t/* NEX-C3, NEX-F3 */\n\t{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"SONY SLT-A33\", 128, 0,\n\t{ 6069,-1221,-366,-5221,12779,2734,-1024,2066,6834 } },\n    { \"SONY SLT-A35\", 128, 0,\n\t{ 5986,-1618,-415,-4557,11820,3120,-681,1404,6971 } },\n    { \"SONY SLT-A37\", 128, 0,\n\t{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"SONY SLT-A55\", 128, 0,\n\t{ 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },\n    { \"SONY SLT-A57\", 128, 0,\n\t{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"SONY SLT-A58\", 128, 0,\n\t{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"SONY SLT-A65\", 128, 0,\n\t{ 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"SONY SLT-A77\", 128, 0,\n\t{ 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"SONY SLT-A99\", 128, 0,\n\t{ 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n  };\n  double cam_xyz[4][3];\n  char name[130];\n  int i, j;\n\n  sprintf (name, \"%s %s\", t_make, t_model);\n  for (i=0; i < sizeof table / sizeof *table; i++)\n    if (!strncmp (name, table[i].prefix, strlen(table[i].prefix))) {\n      if (table[i].t_black)   black   = (ushort) table[i].t_black;\n      if (table[i].t_maximum) maximum = (ushort) table[i].t_maximum;\n      if (table[i].trans[0]) {\n\tfor (j=0; j < 12; j++)\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.color.cam_xyz[0][j] = \n#endif\n\t  cam_xyz[0][j] = table[i].trans[j] / 10000.0;\n\tcam_xyz_coeff (cam_xyz);\n      }\n      break;\n    }\n}\n\nvoid CLASS simple_coeff (int index)\n{\n  static const float table[][12] = {\n  /* index 0 -- all Foveon cameras */\n  { 1.4032,-0.2231,-0.1016,-0.5263,1.4816,0.017,-0.0112,0.0183,0.9113 },\n  /* index 1 -- Kodak DC20 and DC25 */\n  { 2.25,0.75,-1.75,-0.25,-0.25,0.75,0.75,-0.25,-0.25,-1.75,0.75,2.25 },\n  /* index 2 -- Logitech Fotoman Pixtura */\n  { 1.893,-0.418,-0.476,-0.495,1.773,-0.278,-1.017,-0.655,2.672 },\n  /* index 3 -- Nikon E880, E900, and E990 */\n  { -1.936280,  1.800443, -1.448486,  2.584324,\n     1.405365, -0.524955, -0.289090,  0.408680,\n    -1.204965,  1.082304,  2.941367, -1.818705 }\n  };\n  int i, c;\n\n  for (raw_color = i=0; i < 3; i++)\n    FORCC rgb_cam[i][c] = table[index][i*colors+c];\n}\n\nshort CLASS guess_byte_order (int words)\n{\n  uchar test[4][2];\n  int t=2, msb;\n  double diff, sum[2] = {0,0};\n\n  fread (test[0], 2, 2, ifp);\n  for (words-=2; words--; ) {\n    fread (test[t], 2, 1, ifp);\n    for (msb=0; msb < 2; msb++) {\n      diff = (test[t^2][msb] << 8 | test[t^2][!msb])\n\t   - (test[t  ][msb] << 8 | test[t  ][!msb]);\n      sum[msb] += diff*diff;\n    }\n    t = (t+1) & 3;\n  }\n  return sum[0] < sum[1] ? 0x4d4d : 0x4949;\n}\n\nfloat CLASS find_green (int bps, int bite, int off0, int off1)\n{\n  UINT64 bitbuf=0;\n  int vbits, col, i, c;\n  ushort img[2][2064];\n  double sum[]={0,0};\n\n  FORC(2) {\n    fseek (ifp, c ? off1:off0, SEEK_SET);\n    for (vbits=col=0; col < width; col++) {\n      for (vbits -= bps; vbits < 0; vbits += bite) {\n\tbitbuf <<= bite;\n\tfor (i=0; i < bite; i+=8)\n\t  bitbuf |= (unsigned) (fgetc(ifp) << i);\n      }\n      img[c][col] = bitbuf << (64-bps-vbits) >> (64-bps);\n    }\n  }\n  FORC(width-1) {\n    sum[ c & 1] += ABS(img[0][c]-img[1][c+1]);\n    sum[~c & 1] += ABS(img[1][c]-img[0][c+1]);\n  }\n  return 100 * log(sum[0]/sum[1]);\n}\n\n\n#ifndef LIBRAW_LIBRARY_BUILD\nvoid CLASS identify2(unsigned fsize, unsigned flen, char *head);\n#endif\n\n/*\n   Identify which camera created this file, and set global variables\n   accordingly.\n */\nvoid CLASS identify()\n{\n  char head[32], *cp;\n  int hlen, flen, fsize, zero_fsize=1, i, c, is_canon;\n  struct jhead jh;\n  static const struct {\n    int fsize;\n    char t_make[12], t_model[19], withjpeg;\n  } table[] = {\n    {    62464, \"Kodak\",    \"DC20\"            ,0 },\n    {   124928, \"Kodak\",    \"DC20\"            ,0 },\n    {  1652736, \"Kodak\",    \"DCS200\"          ,0 },\n    {  4159302, \"Kodak\",    \"C330\"            ,0 },\n    {  4162462, \"Kodak\",    \"C330\"            ,0 },\n    {   460800, \"Kodak\",    \"C603v\"           ,0 },\n    {   614400, \"Kodak\",    \"C603v\"           ,0 },\n    {  6163328, \"Kodak\",    \"C603\"            ,0 },\n    {  6166488, \"Kodak\",    \"C603\"            ,0 },\n    {  9116448, \"Kodak\",    \"C603y\"           ,0 },\n    {   311696, \"ST Micro\", \"STV680 VGA\"      ,0 },  /* SPYz */\n    {   787456, \"Creative\", \"PC-CAM 600\"      ,0 },\n    {  1138688, \"Minolta\",  \"RD175\"           ,0 },\n    {  3840000, \"Foculus\",  \"531C\"            ,0 },\n    {   307200, \"Generic\",  \"640x480\"         ,0 },\n    {   786432, \"AVT\",      \"F-080C\"          ,0 },\n    {  1447680, \"AVT\",      \"F-145C\"          ,0 },\n    {  1920000, \"AVT\",      \"F-201C\"          ,0 },\n    {  5067304, \"AVT\",      \"F-510C\"          ,0 },\n    {  5067316, \"AVT\",      \"F-510C\"          ,0 },\n    { 10134608, \"AVT\",      \"F-510C\"          ,0 },\n    { 10134620, \"AVT\",      \"F-510C\"          ,0 },\n    { 16157136, \"AVT\",      \"F-810C\"          ,0 },\n    {  1409024, \"Sony\",     \"XCD-SX910CR\"     ,0 },\n    {  2818048, \"Sony\",     \"XCD-SX910CR\"     ,0 },\n    {  3884928, \"Micron\",   \"2010\"            ,0 },\n    {  6624000, \"Pixelink\", \"A782\"            ,0 },\n    { 13248000, \"Pixelink\", \"A782\"            ,0 },\n    {  6291456, \"RoverShot\",\"3320AF\"          ,0 },\n    {  6553440, \"Canon\",    \"PowerShot A460\"  ,0 },\n    {  6653280, \"Canon\",    \"PowerShot A530\"  ,0 },\n    {  6573120, \"Canon\",    \"PowerShot A610\"  ,0 },\n    {  9219600, \"Canon\",    \"PowerShot A620\"  ,0 },\n    {  9243240, \"Canon\",    \"PowerShot A470\"  ,0 },\n    { 10341600, \"Canon\",    \"PowerShot A720 IS\",0 },\n    { 10383120, \"Canon\",    \"PowerShot A630\"  ,0 },\n    { 12945240, \"Canon\",    \"PowerShot A640\"  ,0 },\n    { 15636240, \"Canon\",    \"PowerShot A650\"  ,0 },\n    {  5298000, \"Canon\",    \"PowerShot SD300\" ,0 },\n    {  7710960, \"Canon\",    \"PowerShot S3 IS\" ,0 },\n    { 15467760, \"Canon\",    \"PowerShot SX110 IS\",0 },\n    { 15534576, \"Canon\",    \"PowerShot SX120 IS\",0 },\n    { 18653760, \"Canon\",    \"PowerShot SX20 IS\",0 },\n    { 19131120, \"Canon\",    \"PowerShot SX220 HS\",0 },\n    { 21936096, \"Canon\",    \"PowerShot SX30 IS\",0 },\n    {  5939200, \"OLYMPUS\",  \"C770UZ\"          ,0 },\n    {  1581060, \"NIKON\",    \"E900\"            ,1 },  /* or E900s,E910 */\n    {  2465792, \"NIKON\",    \"E950\"            ,1 },  /* or E800,E700 */\n    {  2940928, \"NIKON\",    \"E2100\"           ,1 },  /* or E2500 */\n    {  4771840, \"NIKON\",    \"E990\"            ,1 },  /* or E995, Oly C3030Z */\n    {  4775936, \"NIKON\",    \"E3700\"           ,1 },  /* or Optio 33WR */\n    {  5869568, \"NIKON\",    \"E4300\"           ,1 },  /* or DiMAGE Z2 */\n    {  5865472, \"NIKON\",    \"E4500\"           ,1 },\n    {  7438336, \"NIKON\",    \"E5000\"           ,1 },  /* or E5700 */\n    {  8998912, \"NIKON\",    \"COOLPIX S6\"      ,1 },\n    {  1976352, \"CASIO\",    \"QV-2000UX\"       ,1 },\n    {  3217760, \"CASIO\",    \"QV-3*00EX\"       ,1 },\n    {  6218368, \"CASIO\",    \"QV-5700\"         ,1 },\n    {  6054400, \"CASIO\",    \"QV-R41\"          ,1 },\n    {  7530816, \"CASIO\",    \"QV-R51\"          ,1 },\n    {  7684000, \"CASIO\",    \"QV-4000\"         ,1 },\n    {  2937856, \"CASIO\",    \"EX-S20\"          ,1 },\n    {  4948608, \"CASIO\",    \"EX-S100\"         ,1 },\n    {  7542528, \"CASIO\",    \"EX-Z50\"          ,1 },\n    {  7562048, \"CASIO\",    \"EX-Z500\"         ,1 },\n    {  7753344, \"CASIO\",    \"EX-Z55\"          ,1 },\n    {  7816704, \"CASIO\",    \"EX-Z60\"          ,1 },\n    { 10843712, \"CASIO\",    \"EX-Z75\"          ,1 },\n    { 10834368, \"CASIO\",    \"EX-Z750\"         ,1 },\n    { 12310144, \"CASIO\",    \"EX-Z850\"         ,1 },\n    { 12489984, \"CASIO\",    \"EX-Z8\"           ,1 },\n    { 15499264, \"CASIO\",    \"EX-Z1050\"        ,1 },\n    { 18702336, \"CASIO\",    \"EX-ZR100\"        ,1 },\n    {  7426656, \"CASIO\",    \"EX-P505\"         ,1 },\n    {  9313536, \"CASIO\",    \"EX-P600\"         ,1 },\n    { 10979200, \"CASIO\",    \"EX-P700\"         ,1 },\n    {  3178560, \"PENTAX\",   \"Optio S\"         ,1 },\n    {  4841984, \"PENTAX\",   \"Optio S\"         ,1 },\n    {  6114240, \"PENTAX\",   \"Optio S4\"        ,1 },  /* or S4i, CASIO EX-Z4 */\n    { 10702848, \"PENTAX\",   \"Optio 750Z\"      ,1 },\n    { 15980544, \"AGFAPHOTO\",\"DC-833m\"         ,1 },\n    { 16098048, \"SAMSUNG\",  \"S85\"             ,1 },\n    { 16215552, \"SAMSUNG\",  \"S85\"             ,1 },\n    { 20487168, \"SAMSUNG\",  \"WB550\"           ,1 },\n    { 24000000, \"SAMSUNG\",  \"WB550\"           ,1 },\n    { 9994240, \"ptGrey\", \"GRAS-50S5C\" ,0 }, // KC: SUPPORT GRASSHOPPER\n    { 10075968, \"JaiPulnix\",\"BB-500CL\" ,0 }, // KC: SUPPORT BB-500CL\n    { 10108896, \"JaiPulnix\",\"BB-500GE\" ,0 }, // KC: SUPPORT BB-500GE\n    { 10036800, \"SVS\", \"SVS625CL\" ,0 }, // KC: SUPPORT SVS625 cameralink\n    { 12582980, \"Sinar\",    \"\"                ,0 },\n    { 33292868, \"Sinar\",    \"\"                ,0 },\n    { 44390468, \"Sinar\",    \"\"                ,0 } };\n  static const char *corp[] =\n    { \"Canon\", \"NIKON\", \"EPSON\", \"KODAK\", \"Kodak\", \"OLYMPUS\", \"PENTAX\",\n      \"MINOLTA\", \"Minolta\", \"Konica\", \"CASIO\", \"Sinar\", \"Phase One\",\n      \"SAMSUNG\", \"Mamiya\", \"MOTOROLA\", \"LEICA\" };\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY,0,2);\n#endif\n\n  tiff_flip = flip = filters = -1;\t/* 0 is valid, so -1 is unknown */\n  raw_height = raw_width = fuji_width = fuji_layout = cr2_slice[0] = 0;\n  maximum = height = width = top_margin = left_margin = 0;\n  cdesc[0] = desc[0] = artist[0] = make[0] = model[0] = model2[0] = 0;\n  iso_speed = shutter = aperture = focal_len = unique_id = 0;\n  tiff_nifds = 0;\n  memset (tiff_ifd, 0, sizeof tiff_ifd);\n  memset (gpsdata, 0, sizeof gpsdata);\n  memset (cblack, 0, sizeof cblack);\n  memset (white, 0, sizeof white);\n  memset (mask, 0, sizeof mask);\n  thumb_offset = thumb_length = thumb_width = thumb_height = 0;\n  load_raw = thumb_load_raw = 0;\n  write_thumb = &CLASS jpeg_thumb;\n  data_offset = meta_length = tiff_bps = tiff_compress = 0;\n  kodak_cbpp = zero_after_ff = dng_version = load_flags = 0;\n  timestamp = shot_order = tiff_samples = black = is_foveon = 0;\n  mix_green = profile_length = data_error = zero_is_bad = 0;\n  pixel_aspect = is_raw = raw_color = 1;\n  tile_width = tile_length = 0;\n  for (i=0; i < 4; i++) {\n    cam_mul[i] = i == 1;\n    pre_mul[i] = i < 3;\n    FORC3 cmatrix[c][i] = 0;\n    FORC3 rgb_cam[c][i] = c == i;\n  }\n  colors = 3;\n  for (i=0; i < 0x10000; i++) curve[i] = i;\n\n  order = get2();\n  hlen = get4();\n  fseek (ifp, 0, SEEK_SET);\n  fread (head, 1, 32, ifp);\n  fseek (ifp, 0, SEEK_END);\n  flen = fsize = ftell(ifp);\n  if ((cp = (char *) memmem (head, 32, (char*)\"MMMM\", 4)) ||\n      (cp = (char *) memmem (head, 32, (char*)\"IIII\", 4))) {\n    parse_phase_one (cp-head);\n    if (cp-head && parse_tiff(0)) apply_tiff();\n  } else if (order == 0x4949 || order == 0x4d4d) {\n    if (!memcmp (head+6,\"HEAPCCDR\",8)) {\n      data_offset = hlen;\n      parse_ciff (hlen, flen - hlen);\n    } else if (parse_tiff(0)) apply_tiff();\n  } else if (!memcmp (head,\"\\xff\\xd8\\xff\\xe1\",4) &&\n\t     !memcmp (head+6,\"Exif\",4)) {\n    fseek (ifp, 4, SEEK_SET);\n    data_offset = 4 + get2();\n    fseek (ifp, data_offset, SEEK_SET);\n    if (fgetc(ifp) != 0xff)\n      parse_tiff(12);\n    thumb_offset = 0;\n  } else if (!memcmp (head+25,\"ARECOYK\",7)) {\n    strcpy (make, \"Contax\");\n    strcpy (model,\"N Digital\");\n    fseek (ifp, 33, SEEK_SET);\n    get_timestamp(1);\n    fseek (ifp, 60, SEEK_SET);\n    FORC4 cam_mul[c ^ (c >> 1)] = get4();\n  } else if (!strcmp (head, \"PXN\")) {\n    strcpy (make, \"Logitech\");\n    strcpy (model,\"Fotoman Pixtura\");\n  } else if (!strcmp (head, \"qktk\")) {\n    strcpy (make, \"Apple\");\n    strcpy (model,\"QuickTake 100\");\n    load_raw = &CLASS quicktake_100_load_raw;\n  } else if (!strcmp (head, \"qktn\")) {\n    strcpy (make, \"Apple\");\n    strcpy (model,\"QuickTake 150\");\n    load_raw = &CLASS kodak_radc_load_raw;\n  } else if (!memcmp (head,\"FUJIFILM\",8)) {\n    fseek (ifp, 84, SEEK_SET);\n    thumb_offset = get4();\n    thumb_length = get4();\n    fseek (ifp, 92, SEEK_SET);\n    parse_fuji (get4());\n    if (thumb_offset > 120) {\n      fseek (ifp, 120, SEEK_SET);\n      is_raw += (i = get4()) && 1;\n      if (is_raw == 2 && shot_select)\n\tparse_fuji (i);\n    }\n    load_raw = &CLASS unpacked_load_raw;\n    fseek (ifp, 100+28*(shot_select > 0), SEEK_SET);\n    parse_tiff (data_offset = get4());\n    parse_tiff (thumb_offset+12);\n    apply_tiff();\n  } else if (!memcmp (head,\"RIFF\",4)) {\n    fseek (ifp, 0, SEEK_SET);\n    parse_riff();\n  } else if (!memcmp (head,\"\\0\\001\\0\\001\\0@\",6)) {\n    fseek (ifp, 6, SEEK_SET);\n    fread (make, 1, 8, ifp);\n    fread (model, 1, 8, ifp);\n    fread (model2, 1, 16, ifp);\n    data_offset = get2();\n    get2();\n    raw_width = get2();\n    raw_height = get2();\n    load_raw = &CLASS nokia_load_raw;\n    filters = 0x61616161;\n  } else if (!memcmp (head,\"NOKIARAW\",8)) {\n    strcpy (make, \"NOKIA\");\n    strcpy (model, \"X2\");\n    order = 0x4949;\n    fseek (ifp, 300, SEEK_SET);\n    data_offset = get4();\n    i = get4();\n    width = get2();\n    height = get2();\n    data_offset += i - width * 5 / 4 * height;\n    load_raw = &CLASS nokia_load_raw;\n    filters = 0x61616161;\n  } else if (!memcmp (head,\"ARRI\",4)) {\n    order = 0x4949;\n    fseek (ifp, 20, SEEK_SET);\n    width = get4();\n    height = get4();\n    strcpy (make, \"ARRI\");\n    fseek (ifp, 668, SEEK_SET);\n    fread (model, 1, 64, ifp);\n    data_offset = 4096;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 88;\n    filters = 0x61616161;\n  } else if (!memcmp (head+4,\"RED1\",4)) {\n    strcpy (make, \"RED\");\n    strcpy (model,\"ONE\");\n    parse_redcine();\n    load_raw = &CLASS redcine_load_raw;\n    gamma_curve (1/2.4, 12.92, 1, 4095);\n    filters = 0x49494949;\n  } else if (!memcmp (head,\"DSC-Image\",9))\n    parse_rollei();\n  else if (!memcmp (head,\"PWAD\",4))\n    parse_sinar_ia();\n  else if (!memcmp (head,\"\\0MRM\",4))\n    parse_minolta(0);\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n  else if (!memcmp (head,\"FOVb\",4))\n    parse_foveon();\n#endif\n  else if (!memcmp (head,\"CI\",2))\n    parse_cine();\n  else\n    for (zero_fsize=i=0; i < sizeof table / sizeof *table; i++)\n      if (fsize == table[i].fsize) {\n\tstrcpy (make,  table[i].t_make );\n\tstrcpy (model, table[i].t_model);\n\tif (table[i].withjpeg)\n\t  parse_external_jpeg();\n      }\n  if (zero_fsize) fsize = 0;\n  if (make[0] == 0) parse_smal (0, flen);\n  if (make[0] == 0) {\n    parse_jpeg(0);\n    fseek(ifp,0,SEEK_END);\n    int sz = ftell(ifp);\n    if (!strncmp(model,\"ov\",2) && sz>=6404096 && !fseek (ifp, -6404096, SEEK_END) &&\n\tfread (head, 1, 32, ifp) && !strcmp(head,\"BRCMn\")) {\n      strcpy (make, \"OmniVision\");\n      data_offset = ftell(ifp) + 0x8000-32;\n      width = raw_width;\n      raw_width = 2611;\n      load_raw = &CLASS nokia_load_raw;\n      filters = 0x16161616;\n    } else is_raw = 0;\n  }\n\n  for (i=0; i < sizeof corp / sizeof *corp; i++)\n    if (strstr (make, corp[i]))\t\t/* Simplify company names */\n\tstrcpy (make, corp[i]);\n  if (!strncmp (make,\"KODAK\",5) &&\n\t((cp = strstr(model,\" DIGITAL CAMERA\")) ||\n\t (cp = strstr(model,\" Digital Camera\")) ||\n\t (cp = strstr(model,\"FILE VERSION\"))))\n     *cp = 0;\n  cp = make + strlen(make);\t\t/* Remove trailing spaces */\n  while (*--cp == ' ') *cp = 0;\n  cp = model + strlen(model);\n  while (*--cp == ' ') *cp = 0;\n  i = strlen(make);\t\t\t/* Remove make from model */\n  if (!strncasecmp (model, make, i) && model[i++] == ' ')\n    memmove (model, model+i, 64-i);\n  if (!strncmp (model,\"FinePix \",8))\n    strcpy (model, model+8);\n  if (!strncmp (model,\"Digital Camera \",15))\n    strcpy (model, model+15);\n  desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;\n  if (!is_raw) goto notraw;\n\n  if (!height) height = raw_height;\n  if (!width)  width  = raw_width;\n  if (height == 2624 && width == 3936)\t/* Pentax K10D and Samsung GX10 */\n    { height  = 2616;   width  = 3896; }\n  if (height == 3136 && width == 4864)  /* Pentax K20D and Samsung GX20 */\n    { height  = 3124;   width  = 4688; filters = 0x16161616; }\n  if (width == 4352 && (!strcmp(model,\"K-r\") || !strcmp(model,\"K-x\")))\n    {\t\t\twidth  = 4309; filters = 0x16161616; }\n  if (width >= 4960 && !strncmp(model,\"K-5\",3))\n    { left_margin = 10; width  = 4950; filters = 0x16161616; }\n  if (width >= 4960 && !strncmp(model,\"K-5 II\",6))\n    { left_margin = 10; width  = 4948; filters = 0x16161616; }\n  if (width == 4736 && !strcmp(model,\"K-7\"))\n    { height  = 3122;   width  = 4684; filters = 0x16161616; top_margin = 2; }\n  if (width == 7424 && !strcmp(model,\"645D\"))\n    { height  = 5502;   width  = 7328; filters = 0x61616161; top_margin = 29;\n      left_margin = 48; }\n  if (height == 3014 && width == 4096)\t/* Ricoh GX200 */\n\t\t\twidth  = 4014;\n  if (dng_version) {\n    if (filters == UINT_MAX) filters = 0;\n    if (filters) is_raw = tiff_samples;\n    else\t colors = tiff_samples;\n    if (tiff_compress == 1)\n      load_raw = &CLASS packed_dng_load_raw;\n    if (tiff_compress == 7)\n      load_raw = &CLASS lossless_dng_load_raw;\n    goto dng_skip;\n  }\n  if ((is_canon = !strcmp(make,\"Canon\")))\n    load_raw = memcmp (head+6,\"HEAPCCDR\",8) ?\n\t&CLASS lossless_jpeg_load_raw : &CLASS canon_load_raw;\n  if (!strcmp(make,\"NIKON\")) {\n    if (!load_raw)\n      load_raw = &CLASS packed_load_raw;\n    if (model[0] == 'E')\n      load_flags |= !data_offset << 2 | 2;\n  }\n  if (!strcmp(make,\"CASIO\")) {\n    load_raw = &CLASS packed_load_raw;\n    maximum = 0xf7f;\n  }\n\n/* Set parameters based on camera name (for non-DNG files). */\n\n  if (is_foveon) {\n    if (height*2 < width) pixel_aspect = 0.5;\n    if (height   > width) pixel_aspect = 2;\n    filters = 0;\n    simple_coeff(0);\n  } else if (is_canon && tiff_bps == 15) {\n    switch (width) {\n      case 3344: width -= 66;\n      case 3872: width -= 6;\n    }\n    if (height > width) SWAP(height,width);\n    filters = 0;\n    load_raw = &CLASS canon_sraw_load_raw;\n  } else if (!strcmp(model,\"PowerShot 600\")) {\n    height = 613;\n    width  = 854;\n    raw_width = 896;\n    pixel_aspect = 607/628.0;\n    colors = 4;\n    filters = 0xe1e4e1e4;\n    load_raw = &CLASS canon_600_load_raw;\n  } else if (!strcmp(model,\"PowerShot A5\") ||\n\t     !strcmp(model,\"PowerShot A5 Zoom\")) {\n    height = 773;\n    width  = 960;\n    raw_width = 992;\n    pixel_aspect = 256/235.0;\n    colors = 4;\n    filters = 0x1e4e1e4e;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A50\")) {\n    height =  968;\n    width  = 1290;\n    raw_width = 1320;\n    colors = 4;\n    filters = 0x1b4e4b1e;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot Pro70\")) {\n    height = 1024;\n    width  = 1552;\n    colors = 4;\n    filters = 0x1e4b4e1b;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot SD300\")) {\n    height = 1752;\n    width  = 2344;\n    raw_height = 1766;\n    raw_width  = 2400;\n    top_margin  = 12;\n    left_margin = 12;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A460\")) {\n    height = 1960;\n    width  = 2616;\n    raw_height = 1968;\n    raw_width  = 2664;\n    top_margin  = 4;\n    left_margin = 4;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A530\")) {\n    height = 1984;\n    width  = 2620;\n    raw_height = 1992;\n    raw_width  = 2672;\n    top_margin  = 6;\n    left_margin = 10;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A610\")) {\n    if (canon_s2is()) strcpy (model+10, \"S2 IS\");\n    height = 1960;\n    width  = 2616;\n    raw_height = 1968;\n    raw_width  = 2672;\n    top_margin  = 8;\n    left_margin = 12;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A620\")) {\n    height = 2328;\n    width  = 3112;\n    raw_height = 2340;\n    raw_width  = 3152;\n    top_margin  = 12;\n    left_margin = 36;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A470\")) {\n    height = 2328;\n    width  = 3096;\n    raw_height = 2346;\n    raw_width  = 3152;\n    top_margin  = 6;\n    left_margin = 12;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A720 IS\")) {\n    height = 2472;\n    width  = 3298;\n    raw_height = 2480;\n    raw_width  = 3336;\n    top_margin  = 5;\n    left_margin = 6;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A630\")) {\n    height = 2472;\n    width  = 3288;\n    raw_height = 2484;\n    raw_width  = 3344;\n    top_margin  = 6;\n    left_margin = 12;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A640\")) {\n    height = 2760;\n    width  = 3672;\n    raw_height = 2772;\n    raw_width  = 3736;\n    top_margin  = 6;\n    left_margin = 12;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A650\")) {\n    height = 3024;\n    width  = 4032;\n    raw_height = 3048;\n    raw_width  = 4104;\n    top_margin  = 12;\n    left_margin = 48;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot S3 IS\")) {\n    height = 2128;\n    width  = 2840;\n    raw_height = 2136;\n    raw_width  = 2888;\n    top_margin  = 8;\n    left_margin = 44;\ncanon_a5:\n    tiff_bps = 10;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 40;\n    if (raw_width > 1600) zero_is_bad = 1;\n  } else if (!strcmp(model,\"PowerShot SX110 IS\")) {\n    height = 2760;\n    width  = 3684;\n    raw_height = 2772;\n    raw_width  = 3720;\n    top_margin  = 12;\n    left_margin = 6;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 40;\n    zero_is_bad = 1;\n  } else if (!strcmp(model,\"PowerShot SX120 IS\")) {\n    height = 2742;\n    width  = 3664;\n    raw_height = 2778;\n    raw_width  = 3728;\n    top_margin  = 18;\n    left_margin = 16;\n    filters = 0x49494949;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 40;\n    zero_is_bad = 1;\n  } else if (!strcmp(model,\"PowerShot SX20 IS\")) {\n    height = 3024;\n    width  = 4032;\n    raw_height = 3048;\n    raw_width  = 4080;\n    top_margin  = 12;\n    left_margin = 24;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 40;\n    zero_is_bad = 1;\n  } else if (!strcmp(model,\"PowerShot SX220 HS\")) {\n    height = 3043;\n    width  = 4072;\n    raw_height = 3060;\n    raw_width  = 4168;\n    mask[0][0] = top_margin = 16;\n    mask[0][2] = top_margin + height;\n    mask[0][3] = left_margin = 92;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 8;\n    zero_is_bad = 1;\n  } else if (!strcmp(model,\"PowerShot SX50 HS\")) {\n    top_margin=16;\n    left_margin=94;\n    height = 3043;\n    width  = 4072;\n  } else if (!strcmp(model,\"PowerShot SX30 IS\")) {\n    height = 3254;\n    width  = 4366;\n    raw_height = 3276;\n    raw_width  = 4464;\n    top_margin  = 10;\n    left_margin = 25;\n    filters = 0x16161616;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 40;\n    zero_is_bad = 1;\n  } else if (!strcmp(model,\"PowerShot Pro90 IS\")) {\n    width  = 1896;\n    colors = 4;\n    filters = 0xb4b4b4b4;\n  } else if (is_canon && raw_width == 2144) {\n    height = 1550;\n    width  = 2088;\n    top_margin  = 8;\n    left_margin = 4;\n    if (!strcmp(model,\"PowerShot G1\")) {\n      colors = 4;\n      filters = 0xb4b4b4b4;\n    }\n  } else if (is_canon && raw_width == 2224) {\n    height = 1448;\n    width  = 2176;\n    top_margin  = 6;\n    left_margin = 48;\n  } else if (is_canon && raw_width == 2376) {\n    height = 1720;\n    width  = 2312;\n    top_margin  = 6;\n    left_margin = 12;\n  } else if (is_canon && raw_width == 2672) {\n    height = 1960;\n    width  = 2616;\n    top_margin  = 6;\n    left_margin = 12;\n  } else if (is_canon && raw_width == 3152) {\n    height = 2056;\n    width  = 3088;\n    top_margin  = 12;\n    left_margin = 64;\n    if (unique_id == 0x80000170)\n      adobe_coeff (\"Canon\",\"EOS 300D\");\n  } else if (is_canon && raw_width == 3160) {\n    height = 2328;\n    width  = 3112;\n    top_margin  = 12;\n    left_margin = 44;\n  } else if (is_canon && raw_width == 3344) {\n    height = 2472;\n    width  = 3288;\n    top_margin  = 6;\n    left_margin = 4;\n  } else if (!strcmp(model,\"EOS D2000C\")) {\n    filters = 0x61616161;\n    black = curve[200];\n  } else if (is_canon && raw_width == 3516) {\n    top_margin  = 14;\n    left_margin = 42;\n    if (unique_id == 0x80000189)\n      adobe_coeff (\"Canon\",\"EOS 350D\");\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 3596) {\n    top_margin  = 12;\n    left_margin = 74;\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 3744) {\n    height = 2760;\n    width  = 3684;\n    top_margin  = 16;\n    left_margin = 8;\n    if (unique_id > 0x2720000) {\n      top_margin  = 12;\n      left_margin = 52;\n    }\n  } else if (is_canon && raw_width == 3944) {\n    height = 2602;\n    width  = 3908;\n    top_margin  = 18;\n    left_margin = 30;\n  } else if (is_canon && raw_width == 3948) {\n    top_margin  = 18;\n    left_margin = 42;\n    height -= 2;\n    if (unique_id == 0x80000236)\n      adobe_coeff (\"Canon\",\"EOS 400D\");\n    if (unique_id == 0x80000254)\n      adobe_coeff (\"Canon\",\"EOS 1000D\");\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 3984) {\n    top_margin  = 20;\n    left_margin = 76;\n    height -= 2;\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 4104) {\n    height = 3024;\n    width  = 4032;\n    top_margin  = 12;\n    left_margin = 48;\n  } else if (is_canon && raw_width == 4152) {\n    top_margin  = 12;\n    left_margin = 192;\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 4160) {\n    height = 3048;\n    width  = 4048;\n    top_margin  = 11;\n    left_margin = 104;\n  } else if (is_canon && raw_width == 4176) {\n    height = 3045;\n    width  = 4072;\n    left_margin = 96;\n    mask[0][0] = top_margin = 17;\n    mask[0][2] = raw_height;\n    mask[0][3] = 80;\n    filters = 0x49494949;\n  } else if (is_canon && raw_width == 4312) {\n    top_margin  = 18;\n    left_margin = 22;\n    height -= 2;\n    if (unique_id == 0x80000176)\n      adobe_coeff (\"Canon\",\"EOS 450D\");\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 4352) {\n    top_margin  = 18;\n    left_margin = 62;\n    if (unique_id == 0x80000288)\n      adobe_coeff (\"Canon\",\"EOS 1100D\");\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 4476) {\n    top_margin  = 34;\n    left_margin = 90;\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 4480) {\n    height = 3326;\n    width  = 4432;\n    top_margin  = 10;\n    left_margin = 12;\n    filters = 0x49494949;\n  } else if (is_canon && raw_width == 4496) {\n    height = 3316;\n    width  = 4404;\n    top_margin  = 50;\n    left_margin = 80;\n  } else if (is_canon && raw_width == 4832) {\n    top_margin = unique_id == 0x80000261 ? 51:26;\n    left_margin = 62;\n    if (unique_id == 0x80000252)\n      adobe_coeff (\"Canon\",\"EOS 500D\");\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 5108) {\n    top_margin  = 13;\n    left_margin = 98;\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 5120) {\n    height -= top_margin = 45;\n    left_margin = 142;\n    width = 4916;\n  } else if (is_canon && raw_width == 5280) {\n    top_margin  = 52;\n    left_margin = 72;\n    if (unique_id == 0x80000301)\n      adobe_coeff (\"Canon\",\"EOS 650D\");\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 5344) {\n    top_margin = 51;\n    left_margin = 142;\n    if (unique_id == 0x80000269) {\n      top_margin = 100;\n      left_margin = 126;\n      height -= 2;\n      adobe_coeff (\"Canon\",\"EOS-1D X\");\n    }\n    if (unique_id == 0x80000270)\n      adobe_coeff (\"Canon\",\"EOS 550D\");\n    if (unique_id == 0x80000286)\n      adobe_coeff (\"Canon\",\"EOS 600D\");\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 5360) {\n    top_margin = 51;\n    left_margin = 158;\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 5568) {\n    top_margin = 38;\n    left_margin = 72;\n    goto canon_cr2;\n  } else if (is_canon && raw_width == 5712) {\n    height = 3752;\n    width  = 5640;\n    top_margin  = 20;\n    left_margin = 62;\n  } else if (is_canon && raw_width == 5792) {\n    top_margin  = 51;\n    left_margin = 158;\ncanon_cr2:\n    height -= top_margin;\n    width  -= left_margin;\n  } else if (is_canon && raw_width == 5920) {\n    height = 3870;\n    width  = 5796;\n    top_margin  = 80;\n    left_margin = 122;\n  } else if (!strcmp(model,\"D1\")) {\n    cam_mul[0] *= 256/527.0;\n    cam_mul[2] *= 256/317.0;\n  } else if (!strcmp(model,\"D1X\")) {\n    width -= 4;\n    pixel_aspect = 0.5;\n  } else if (!strcmp(model,\"D40X\") ||\n\t     !strcmp(model,\"D60\")  ||\n\t     !strcmp(model,\"D80\")  ||\n\t     !strcmp(model,\"D3000\")) {\n    height -= 3;\n    width  -= 4;\n  } else if (!strcmp(model,\"D3\")   ||\n\t     !strcmp(model,\"D3S\")  ||\n\t     !strcmp(model,\"D700\")) {\n    width -= 4;\n    left_margin = 2;\n  } else if (!strcmp(model,\"D3100\")) {\n    width -= 28;\n    left_margin = 6;\n  } else if (!strcmp(model,\"D5000\") ||\n\t     !strcmp(model,\"D90\")) {\n    width -= 42;\n  } else if (!strcmp(model,\"D5100\") ||\n\t     !strcmp(model,\"D7000\")) {\n    width -= 44;\n  } else if (!strcmp(model,\"D3200\") ||\n\t     !strcmp(model,\"D800E\") ||\n\t     !strcmp(model,\"D600\")  ||\n\t     !strcmp(model,\"D800\")) {\n    width -= 46;\n  } else if (!strcmp(model,\"D4\")) {\n    width -= 52;\n    left_margin = 2;\n  } else if (!strcmp(model,\"D600\")) {\n    width -= 48;\n  } else if (!strncmp(model,\"D40\",3) ||\n\t     !strncmp(model,\"D50\",3) ||\n\t     !strncmp(model,\"D70\",3)) {\n    width--;\n  } else if (!strcmp(model,\"D100\")) {\n    if (load_flags)\n      raw_width = (width += 3) + 3;\n  } else if (!strcmp(model,\"D200\")) {\n    left_margin = 1;\n    width -= 4;\n    filters = 0x94949494;\n  } else if (!strncmp(model,\"D2H\",3)) {\n    left_margin = 6;\n    width -= 14;\n  } else if (!strncmp(model,\"D2X\",3)) {\n    if (width == 3264) width -= 32;\n    else width -= 8;\n  } else if (!strncmp(model,\"D300\",4)) {\n    width -= 32;\n  } else if (!strcmp(make,\"NIKON\") && raw_width == 4032) {\n    adobe_coeff (\"NIKON\",\"COOLPIX P7700\");\n  } else if (!strncmp(model,\"COOLPIX P\",9)) {\n    load_flags = 24;\n    filters = 0x94949494;\n    if (model[9] == '7' && iso_speed >= 400)\n      black = 255;\n  } else if (!strncmp(model,\"COOLPIX A\",9) && raw_width == 4992) {\n\t  width = 4948;\n  } else if (!strncmp(model,\"1 \",2)) {\n    height -= 2;\n  } else if (fsize == 1581060) {\n    height = 963;\n    width = 1287;\n    raw_width = 1632;\n    maximum = 0x3f4;\n    colors = 4;\n    filters = 0x1e1e1e1e;\n    simple_coeff(3);\n    pre_mul[0] = 1.2085;\n    pre_mul[1] = 1.0943;\n    pre_mul[3] = 1.1103;\n    goto e900;\n  } else if (fsize == 2465792) {\n    height = 1203;\n    width  = 1616;\n    raw_width = 2048;\n    colors = 4;\n    filters = 0x4b4b4b4b;\n    adobe_coeff (\"NIKON\",\"E950\");\ne900:\n    tiff_bps = 10;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 6;\n  } else if (fsize == 4771840) {\n    height = 1540;\n    width  = 2064;\n    colors = 4;\n    filters = 0xe1e1e1e1;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 6;\n    if (!timestamp && nikon_e995())\n      strcpy (model, \"E995\");\n    if (strcmp(model,\"E995\")) {\n      filters = 0xb4b4b4b4;\n      simple_coeff(3);\n      pre_mul[0] = 1.196;\n      pre_mul[1] = 1.246;\n      pre_mul[2] = 1.018;\n    }\n  } else if (!strcmp(model,\"E2100\")) {\n    if (!timestamp && !nikon_e2100()) goto cp_e2500;\n    height = 1206;\n    width  = 1616;\n    load_flags = 30;\n  } else if (!strcmp(model,\"E2500\")) {\ncp_e2500:\n    strcpy (model, \"E2500\");\n    height = 1204;\n    width  = 1616;\n    colors = 4;\n    filters = 0x4b4b4b4b;\n  } else if (fsize == 4775936) {\n    height = 1542;\n    width  = 2064;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 30;\n    if (!timestamp) nikon_3700();\n    if (model[0] == 'E' && atoi(model+1) < 3700)\n      filters = 0x49494949;\n    if (!strcmp(model,\"Optio 33WR\")) {\n      flip = 1;\n      filters = 0x16161616;\n    }\n    if (make[0] == 'O') {\n      i = find_green (12, 32, 1188864, 3576832);\n      c = find_green (12, 32, 2383920, 2387016);\n      if (abs(i) < abs(c)) {\n\tSWAP(i,c);\n\tload_flags = 24;\n      }\n      if (i < 0) filters = 0x61616161;\n    }\n  } else if (fsize == 5869568) {\n    height = 1710;\n    width  = 2288;\n    filters = 0x16161616;\n    if (!timestamp && minolta_z2()) {\n      strcpy (make, \"Minolta\");\n      strcpy (model,\"DiMAGE Z2\");\n    }\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 6 + 24*(make[0] == 'M');\n  } else if (!strcmp(model,\"E4500\")) {\n    height = 1708;\n    width  = 2288;\n    colors = 4;\n    filters = 0xb4b4b4b4;\n  } else if (fsize == 7438336) {\n    height = 1924;\n    width  = 2576;\n    colors = 4;\n    filters = 0xb4b4b4b4;\n  } else if (fsize == 8998912) {\n    height = 2118;\n    width  = 2832;\n    maximum = 0xf83;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 30;\n  } else if (!strcmp(make,\"FUJIFILM\")) {\n    if (!strcmp(model+7,\"S2Pro\")) {\n      strcpy (model,\"S2Pro\");\n      height = 2144;\n      width  = 2880;\n      flip = 6;\n    } else if (load_raw != &CLASS packed_load_raw)\n      maximum = (is_raw == 2 && shot_select) ? 0x2f00 : 0x3e00;\n    top_margin = (raw_height - height) >> 2 << 1;\n    left_margin = (raw_width - width ) >> 2 << 1;\n    if (width == 2848) filters = 0x16161616;\n    if (width == 3328) {\n      width = 3262;\n      left_margin = 34;\n    }\n    if (width == 4952) {\n      left_margin = 0;\n      filters = 2;\n    }\n\tif(!strcmp(model,\"HS50EXR\"))\n\t{\n\t\tfilters = 0x1e1e1e1e;\n\t\twidth=3230;\n\t}\n\tif(!strcmp(model,\"X20\"))\n\t{\n\t\tleft_margin = 2;\n\t\ttop_margin=2;\n\t\twidth = 4030;\n\t\theight = 3010;\n\t\traw_height = 3012;\n\t\tfilters = 2;\n\t}\n\tif(!strcmp(model,\"X100S\"))\n\t{\n\t\tleft_margin = 2;\n\t\ttop_margin = 1;\n\t\twidth = 4934;\n\t\theight = 3290;\n\t\traw_height = 3295;\n\t\tfilters = 2;\n\t\tdata_offset +=8;\n\t\tload_raw = &CLASS unpacked_load_raw;\n\t\tload_flags = 0;\n\t\tmaximum = 16383;\n\t}\n    if (fuji_layout) raw_width *= is_raw;\n  } else if (!strcmp(model,\"RD175\")) {\n    height = 986;\n    width = 1534;\n    data_offset = 513;\n    filters = 0x61616161;\n    load_raw = &CLASS minolta_rd175_load_raw;\n  } else if (!strcmp(model,\"KD-400Z\")) {\n    height = 1712;\n    width  = 2312;\n    raw_width = 2336;\n    goto konica_400z;\n  } else if (!strcmp(model,\"KD-510Z\")) {\n    goto konica_510z;\n  } else if (!strcasecmp(make,\"MINOLTA\")) {\n    load_raw = &CLASS unpacked_load_raw;\n    maximum = 0xfff;\n    if (!strncmp(model,\"DiMAGE A\",8)) {\n      if (!strcmp(model,\"DiMAGE A200\"))\n\tfilters = 0x49494949;\n      tiff_bps = 12;\n      load_raw = &CLASS packed_load_raw;\n    } else if (!strncmp(model,\"ALPHA\",5) ||\n\t       !strncmp(model,\"DYNAX\",5) ||\n\t       !strncmp(model,\"MAXXUM\",6)) {\n      sprintf (model+20, \"DYNAX %-10s\", model+6+(model[0]=='M'));\n      adobe_coeff (make, model+20);\n      load_raw = &CLASS packed_load_raw;\n    } else if (!strncmp(model,\"DiMAGE G\",8)) {\n      if (model[8] == '4') {\n\theight = 1716;\n\twidth  = 2304;\n      } else if (model[8] == '5') {\nkonica_510z:\n\theight = 1956;\n\twidth  = 2607;\n\traw_width = 2624;\n      } else if (model[8] == '6') {\n\theight = 2136;\n\twidth  = 2848;\n      }\n      data_offset += 14;\n      filters = 0x61616161;\nkonica_400z:\n      load_raw = &CLASS unpacked_load_raw;\n      maximum = 0x3df;\n      order = 0x4d4d;\n    }\n  } else if (!strcmp(model,\"*ist D\")) {\n    load_raw = &CLASS unpacked_load_raw;\n    data_error = -1;\n  } else if (!strcmp(model,\"*ist DS\")) {\n    height -= 2;\n  } else if (!strcmp(model,\"Optio S\")) {\n    if (fsize == 3178560) {\n      height = 1540;\n      width  = 2064;\n      load_raw = &CLASS eight_bit_load_raw;\n      cam_mul[0] *= 4;\n      cam_mul[2] *= 4;\n    } else {\n      height = 1544;\n      width  = 2068;\n      raw_width = 3136;\n      load_raw = &CLASS packed_load_raw;\n      maximum = 0xf7c;\n    }\n  } else if (fsize == 6114240) {\n    height = 1737;\n    width  = 2324;\n    raw_width = 3520;\n    load_raw = &CLASS packed_load_raw;\n    maximum = 0xf7a;\n  } else if (!strcmp(model,\"Optio 750Z\")) {\n    height = 2302;\n    width  = 3072;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 30;\n  } else if (!strcmp(model,\"DC-833m\")) {\n    height = 2448;\n    width  = 3264;\n    order = 0x4949;\n    filters = 0x61616161;\n    load_raw = &CLASS unpacked_load_raw;\n    maximum = 0xfc00;\n  } else if (!strncmp(model,\"S85\",3)) {\n    height = 2448;\n    width  = 3264;\n    raw_width = fsize/height/2;\n    order = 0x4d4d;\n    load_raw = &CLASS unpacked_load_raw;\n  } else if (!strcmp(make,\"SAMSUNG\") && raw_width == 4704) {\n    height -= top_margin = 8;\n    width -= 2 * (left_margin = 8);\n    load_flags = 32;\n  } else if (!strcmp(make,\"SAMSUNG\") && raw_width == 5632) {\n    order = 0x4949;\n    height = 3694;\n    top_margin = 2;\n    width  = 5574 - (left_margin = 32 + tiff_bps);\n    if (tiff_bps == 12) load_flags = 80;\n  } else if (!strcmp(make,\"SAMSUNG\") && !strcmp(model,\"NX300\")) {\n\t  is_raw =0;\n  } else if (!strcmp(model,\"EX1\")) {\n    order = 0x4949;\n    height -= 20;\n    top_margin = 2;\n    if ((width -= 6) > 3682) {\n      height -= 10;\n      width  -= 46;\n      top_margin = 8;\n    }\n  } else if (!strcmp(model,\"WB2000\")) {\n    order = 0x4949;\n    height -= 3;\n    top_margin = 2;\n    if ((width -= 10) > 3718) {\n      height -= 28;\n      width  -= 56;\n      top_margin = 8;\n    }\n  } else if (fsize == 20487168) {\n    height = 2808;\n    width  = 3648;\n    goto wb550;\n  } else if (fsize == 24000000) {\n    height = 3000;\n    width  = 4000;\nwb550:\n    strcpy (model, \"WB550\");\n    order = 0x4d4d;\n    load_raw = &CLASS unpacked_load_raw;\n    load_flags = 6;\n    maximum = 0x3df;\n  } else if (!strcmp(model,\"EX2F\")) {\n    height = 3045;\n    width  = 4070;\n    top_margin = 3;\n    order = 0x4949;\n    filters = 0x49494949;\n    load_raw = &CLASS unpacked_load_raw;\n  } else if (!strcmp(model,\"STV680 VGA\")) {\n    height = 484;\n    width  = 644;\n    load_raw = &CLASS eight_bit_load_raw;\n    flip = 2;\n    filters = 0x16161616;\n    black = 16;\n  }  else\n      identify2(fsize,flen,head); /* Avoid MS VS 2008/2010 bug */\n\n  if (!model[0])\n    sprintf (model, \"%dx%d\", width, height);\n  if (filters == UINT_MAX) filters = 0x94949494;\n  if (raw_color) adobe_coeff (make, model);\n  if (load_raw == &CLASS kodak_radc_load_raw)\n    if (raw_color) adobe_coeff (\"Apple\",\"Quicktake\");\n  if (thumb_offset && !thumb_height) {\n    fseek (ifp, thumb_offset, SEEK_SET);\n    if (ljpeg_start (&jh, 1)) {\n      thumb_width  = jh.wide;\n      thumb_height = jh.high;\n    }\n  }\ndng_skip:\n  if (fuji_width) {\n    fuji_width = width >> !fuji_layout;\n    if (~fuji_width & 1) filters = 0x49494949;\n    width = (height >> fuji_layout) + fuji_width;\n    height = width - 1;\n    pixel_aspect = 1;\n  } else {\n    if (raw_height < height) raw_height = height;\n    if (raw_width  < width ) raw_width  = width;\n  }\n  if (!tiff_bps) tiff_bps = 12;\n  if (!maximum) maximum = (1 << tiff_bps) - 1;\n  if (!load_raw || height < 22) is_raw = 0;\n#ifdef NO_JASPER\n  if (load_raw == &CLASS redcine_load_raw) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s: You must link dcraw with %s!!\\n\"),\n\tifname, \"libjasper\");\n#endif\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_JASPER;\n#endif\n  }\n#endif\n#ifdef NO_JPEG\n  if (load_raw == &CLASS kodak_jpeg_load_raw ||\n      load_raw == &CLASS lossy_dng_load_raw) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s: You must link dcraw with %s!!\\n\"),\n\tifname, \"libjpeg\");\n#endif\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_JPEGLIB;\n#endif\n  }\n#endif\n  if (!cdesc[0])\n    strcpy (cdesc, colors == 3 ? \"RGBG\":\"GMCY\");\n  if (!raw_height) raw_height = height;\n  if (!raw_width ) raw_width  = width;\n  if (filters && colors == 3)\n    filters |= ((filters >> 2 & 0x22222222) |\n\t\t(filters << 2 & 0x88888888)) & filters << 1;\nnotraw:\n  if (flip == -1) flip = tiff_flip;\n  if (flip == -1) flip = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY,1,2);\n#endif\n}\n\nvoid CLASS identify2(unsigned fsize, unsigned flen, char *head)\n{\n  short pana[][6] = {\n    { 3130, 1743,  4,  0, -6,  0 },\n    { 3130, 2055,  4,  0, -6,  0 },\n    { 3130, 2319,  4,  0, -6,  0 },\n    { 3170, 2103, 18,  0,-42, 20 },\n    { 3170, 2367, 18, 13,-42,-21 },\n    { 3177, 2367,  0,  0, -1,  0 },\n    { 3304, 2458,  0,  0, -1,  0 },\n    { 3330, 2463,  9,  0, -5,  0 },\n    { 3330, 2479,  9,  0,-17,  4 },\n    { 3370, 1899, 15,  0,-44, 20 },\n    { 3370, 2235, 15,  0,-44, 20 },\n    { 3370, 2511, 15, 10,-44,-21 },\n    { 3690, 2751,  3,  0, -8, -3 },\n    { 3710, 2751,  0,  0, -3,  0 },\n    { 3724, 2450,  0,  0,  0, -2 },\n    { 3770, 2487, 17,  0,-44, 19 },\n    { 3770, 2799, 17, 15,-44,-19 },\n    { 3880, 2170,  6,  0, -6,  0 },\n    { 4060, 3018,  0,  0,  0, -2 },\n    { 4290, 2391,  3,  0, -8, -1 },\n    { 4330, 2439, 17, 15,-44,-19 },\n    { 4508, 2962,  0,  0, -3, -4 },\n    { 4508, 3330,  0,  0, -3, -6 } };\n\n\n  struct jhead jh;\n  int i;\n if (!strcmp(model,\"N95\")) {\n    height = raw_height - (top_margin = 2);\n  } else if (!strcmp(model,\"531C\")) {\n    height = 1200;\n    width  = 1600;\n    load_raw = &CLASS unpacked_load_raw;\n    filters = 0x49494949;\n  } else if (!strcmp(model,\"640x480\")) {\n    height = 480;\n    width  = 640;\n    load_raw = &CLASS eight_bit_load_raw;\n    gamma_curve (0.45, 4.5, 1, 255);\n  } else if (!strcmp(model,\"F-080C\")) {\n    height = 768;\n    width  = 1024;\n    load_raw = &CLASS eight_bit_load_raw;\n  } else if (!strcmp(model,\"F-145C\")) {\n    height = 1040;\n    width  = 1392;\n    load_raw = &CLASS eight_bit_load_raw;\n  } else if (!strcmp(model,\"F-201C\")) {\n    height = 1200;\n    width  = 1600;\n    load_raw = &CLASS eight_bit_load_raw;\n  } else if (!strcmp(model,\"F-510C\")) {\n    height = 1958;\n    width  = 2588;\n    load_raw = fsize < 7500000 ?\n\t&CLASS eight_bit_load_raw : &CLASS unpacked_load_raw;\n    data_offset = fsize - width*height*(fsize >> 22);\n    maximum = 0xfff0;\n  } else if (!strcmp(model,\"F-810C\")) {\n    height = 2469;\n    width  = 3272;\n    load_raw = &CLASS unpacked_load_raw;\n    maximum = 0xfff0;\n  } else if (!strcmp(model,\"XCD-SX910CR\")) {\n    height = 1024;\n    width  = 1375;\n    raw_width = 1376;\n    filters = 0x49494949;\n    maximum = 0x3ff;\n    load_raw = fsize < 2000000 ?\n\t&CLASS eight_bit_load_raw : &CLASS unpacked_load_raw;\n  } else if (!strcmp(model,\"2010\")) {\n    height = 1207;\n    width  = 1608;\n    order = 0x4949;\n    filters = 0x16161616;\n    data_offset = 3212;\n    maximum = 0x3ff;\n    load_raw = &CLASS unpacked_load_raw;\n  } else if (!strcmp(model,\"A782\")) {\n    height = 3000;\n    width  = 2208;\n    filters = 0x61616161;\n    load_raw = fsize < 10000000 ?\n\t&CLASS eight_bit_load_raw : &CLASS unpacked_load_raw;\n    maximum = 0xffc0;\n  } else if (!strcmp(model,\"3320AF\")) {\n    height = 1536;\n    raw_width = width = 2048;\n    filters = 0x61616161;\n    load_raw = &CLASS unpacked_load_raw;\n    maximum = 0x3ff;\n    fseek (ifp, 0x300000, SEEK_SET);\n    if ((order = guess_byte_order(0x10000)) == 0x4d4d) {\n      height -= (top_margin = 16);\n      width -= (left_margin = 28);\n      maximum = 0xf5c0;\n      strcpy (make, \"ISG\");\n      model[0] = 0;\n    }\n  } else if (!strcmp(make,\"Hasselblad\")) {\n    if (load_raw == &CLASS lossless_jpeg_load_raw)\n      load_raw = &CLASS hasselblad_load_raw;\n    if (raw_width == 7262) {\n      height = 5444;\n      width  = 7248;\n      top_margin  = 4;\n      left_margin = 7;\n      filters = 0x61616161;\n    } else if (raw_width == 7410) {\n      height = 5502;\n      width  = 7328;\n      top_margin  = 4;\n      left_margin = 41;\n      filters = 0x61616161;\n    } else if (raw_width == 9044) {\n      height = 6716;\n      width  = 8964;\n      top_margin  = 8;\n      left_margin = 40;\n      black += load_flags = 256;\n      maximum = 0x8101;\n    } else if (raw_width == 4090) {\n      strcpy (model, \"V96C\");\n      height -= (top_margin = 6);\n      width -= (left_margin = 3) + 7;\n      filters = 0x61616161;\n    }\n  } else if (!strcmp(make,\"Sinar\")) {\n    if (!memcmp(head,\"8BPS\",4)) {\n      fseek (ifp, 14, SEEK_SET);\n      height = get4();\n      width  = get4();\n      filters = 0x61616161;\n      data_offset = 68;\n    }\n    if (!load_raw) load_raw = &CLASS unpacked_load_raw;\n    maximum = 0x3fff;\n  } else if (!strcmp(make,\"Leaf\")) {\n    maximum = 0x3fff;\n    fseek (ifp, data_offset, SEEK_SET);\n    if (ljpeg_start (&jh, 1) && jh.bits == 15)\n      maximum = 0x1fff;\n    if (tiff_samples > 1) filters = 0;\n    if (tiff_samples > 1 || tile_length < raw_height) {\n      load_raw = &CLASS leaf_hdr_load_raw;\n      raw_width = tile_width;\n    }\n    if ((width | height) == 2048) {\n      if (tiff_samples == 1) {\n\tfilters = 1;\n\tstrcpy (cdesc, \"RBTG\");\n\tstrcpy (model, \"CatchLight\");\n\ttop_margin =  8; left_margin = 18; height = 2032; width = 2016;\n      } else {\n\tstrcpy (model, \"DCB2\");\n\ttop_margin = 10; left_margin = 16; height = 2028; width = 2022;\n      }\n    } else if (width+height == 3144+2060) {\n      if (!model[0]) strcpy (model, \"Cantare\");\n      if (width > height) {\n\t top_margin = 6; left_margin = 32; height = 2048;  width = 3072;\n\tfilters = 0x61616161;\n      } else {\n\tleft_margin = 6;  top_margin = 32;  width = 2048; height = 3072;\n\tfilters = 0x16161616;\n      }\n      if (!cam_mul[0] || model[0] == 'V') filters = 0;\n      else is_raw = tiff_samples;\n    } else if (width == 2116) {\n      strcpy (model, \"Valeo 6\");\n      height -= 2 * (top_margin = 30);\n      width -= 2 * (left_margin = 55);\n      filters = 0x49494949;\n    } else if (width == 3171) {\n      strcpy (model, \"Valeo 6\");\n      height -= 2 * (top_margin = 24);\n      width -= 2 * (left_margin = 24);\n      filters = 0x16161616;\n    }\n  } else if (!strcmp(make,\"LEICA\") || !strcmp(make,\"Panasonic\")) {\n    if ((flen - data_offset) / (raw_width*8/7) == raw_height)\n      load_raw = &CLASS panasonic_load_raw;\n    if (!load_raw) {\n      load_raw = &CLASS unpacked_load_raw;\n      load_flags = 4;\n    }\n    zero_is_bad = 1;\n    if ((height += 12) > raw_height) height = raw_height;\n    for (i=0; i < sizeof pana / sizeof *pana; i++)\n      if (raw_width == pana[i][0] && raw_height == pana[i][1]) {\n\tleft_margin = pana[i][2];\n\t top_margin = pana[i][3];\n\t     width += pana[i][4];\n\t    height += pana[i][5];\n      }\n    filters = 0x01010101 * (uchar) \"\\x94\\x61\\x49\\x16\"\n\t[((filters-1) ^ (left_margin & 1) ^ (top_margin << 1)) & 3];\n  } else if (!strcmp(model,\"C770UZ\")) {\n    height = 1718;\n    width  = 2304;\n    filters = 0x16161616;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 30;\n  } else if (!strcmp(make,\"OLYMPUS\")) {\n    height += height & 1;\n    filters = exif_cfa;\n    if (width == 4100) width -= 4;\n    if (width == 4080) width -= 24;\n    if (load_raw == &CLASS unpacked_load_raw)\n      load_flags = 4;\n    tiff_bps = 12;\n    if (!strcmp(model,\"E-300\") ||\n\t!strcmp(model,\"E-500\")) {\n      width -= 20;\n      if (load_raw == &CLASS unpacked_load_raw) {\n\tmaximum = 0xfc3;\n\tmemset (cblack, 0, sizeof cblack);\n      }\n    } else if (!strcmp(model,\"E-330\")) {\n      width -= 30;\n      if (load_raw == &CLASS unpacked_load_raw)\n\tmaximum = 0xf79;\n    } else if (!strcmp(model,\"SP550UZ\")) {\n      thumb_length = flen - (thumb_offset = 0xa39800);\n      thumb_height = 480;\n      thumb_width  = 640;\n    } else if (!strcmp(model,\"XZ-2\")) {\n      load_raw = &CLASS packed_load_raw;\n      load_flags = 24;\n    } else if (!strcmp(model,\"XZ-10\")) {\n      load_raw = &CLASS packed_load_raw;\n      load_flags = 24;\n    }\n  } else if (!strcmp(model,\"N Digital\")) {\n    height = 2047;\n    width  = 3072;\n    filters = 0x61616161;\n    data_offset = 0x1a00;\n    load_raw = &CLASS packed_load_raw;\n  } else if (!strcmp(model,\"DSC-F828\")) {\n    width = 3288;\n    left_margin = 5;\n    mask[1][3] = -17;\n    data_offset = 862144;\n    load_raw = &CLASS sony_load_raw;\n    filters = 0x9c9c9c9c;\n    colors = 4;\n    strcpy (cdesc, \"RGBE\");\n  } else if (!strcmp(model,\"DSC-V3\")) {\n    width = 3109;\n    left_margin = 59;\n    mask[0][1] = 9;\n    data_offset = 787392;\n    load_raw = &CLASS sony_load_raw;\n  } else if (!strcmp(make,\"SONY\") && raw_width == 3984) {\n    adobe_coeff (\"SONY\",\"DSC-R1\");\n    width = 3925;\n    order = 0x4d4d;\n  } else if (!strcmp(make,\"SONY\") && raw_width == 5504) {\n    width -= 8;\n  } else if (!strcmp(make,\"SONY\") && raw_width == 6048) {\n    width -= 24;\n  } else if (!strcmp(model,\"DSLR-A100\")) {\n    if (width == 3880) {\n      height--;\n      width = ++raw_width;\n    } else {\n      order = 0x4d4d;\n      load_flags = 2;\n    }\n    filters = 0x61616161;\n  } else if (!strcmp(model,\"DSLR-A350\")) {\n    height -= 4;\n  } else if (!strcmp(model,\"PIXL\")) {\n    height -= top_margin = 4;\n    width -= left_margin = 32;\n    gamma_curve (0, 7, 1, 255);\n  } else if (!strcmp(model,\"C603v\")) {\n    height = 480;\n    width  = 640;\n    if (fsize < 614400 || find_green (16, 16, 3840, 5120) < 25) goto c603v;\n    strcpy (model,\"KAI-0340\");\n    height -= 3;\n    data_offset = 3840;\n    order = 0x4949;\n    load_raw = &CLASS unpacked_load_raw;\n  } else if (!strcmp(model,\"C603y\")) {\n    height = 2134;\n    width  = 2848;\nc603v:\n    filters = 0;\n    load_raw = &CLASS kodak_yrgb_load_raw;\n    gamma_curve (0, 3.875, 1, 255);\n  } else if (!strcmp(model,\"C603\")) {\n    raw_height = height = 2152;\n    raw_width  = width  = 2864;\n    goto c603;\n  } else if (!strcmp(model,\"C330\")) {\n    height = 1744;\n    width  = 2336;\n    raw_height = 1779;\n    raw_width  = 2338;\n    top_margin = 33;\n    left_margin = 1;\nc603:\n    order = 0x4949;\n    if ((data_offset = fsize - raw_height*raw_width)) {\n      fseek (ifp, 168, SEEK_SET);\n      read_shorts (curve, 256);\n    } else gamma_curve (0, 3.875, 1, 255);\n    load_raw = &CLASS eight_bit_load_raw;\n  } else if (!strncasecmp(model,\"EasyShare\",9)) {\n    data_offset = data_offset < 0x15000 ? 0x15000 : 0x17000;\n    load_raw = &CLASS packed_load_raw;\n  } else if (!strcasecmp(make,\"KODAK\")) {\n    if (filters == UINT_MAX) filters = 0x61616161;\n    if (!strncmp(model,\"NC2000\",6)) {\n      width -= 4;\n      left_margin = 2;\n    } else if (!strcmp(model,\"EOSDCS3B\")) {\n      width -= 4;\n      left_margin = 2;\n    } else if (!strcmp(model,\"EOSDCS1\")) {\n      width -= 4;\n      left_margin = 2;\n    } else if (!strcmp(model,\"DCS420\")) {\n      width -= 4;\n      left_margin = 2;\n    } else if (!strncmp(model,\"DCS460 \",7)) {\n      model[6] = 0;\n      width -= 4;\n      left_margin = 2;\n    } else if (!strcmp(model,\"DCS460A\")) {\n      width -= 4;\n      left_margin = 2;\n      colors = 1;\n      filters = 0;\n    } else if (!strcmp(model,\"DCS660M\")) {\n      black = 214;\n      colors = 1;\n      filters = 0;\n    } else if (!strcmp(model,\"DCS760M\")) {\n      colors = 1;\n      filters = 0;\n    }\n    if (!strcmp(model+4,\"20X\"))\n      strcpy (cdesc, \"MYCY\");\n    if (strstr(model,\"DC25\")) {\n      strcpy (model, \"DC25\");\n      data_offset = 15424;\n    }\n    if (!strncmp(model,\"DC2\",3)) {\n      raw_height = height = 242;\n      if (flen < 100000) {\n\traw_width = 256; width = 249;\n\tpixel_aspect = (4.0*height) / (3.0*width);\n      } else {\n\traw_width = 512; width = 501;\n\tpixel_aspect = (493.0*height) / (373.0*width);\n      }\n      data_offset += raw_width + 1;\n      colors = 4;\n      filters = 0x8d8d8d8d;\n      simple_coeff(1);\n      pre_mul[1] = 1.179;\n      pre_mul[2] = 1.209;\n      pre_mul[3] = 1.036;\n      load_raw = &CLASS eight_bit_load_raw;\n    } else if (!strcmp(model,\"40\")) {\n      strcpy (model, \"DC40\");\n      height = 512;\n      width  = 768;\n      data_offset = 1152;\n      load_raw = &CLASS kodak_radc_load_raw;\n    } else if (strstr(model,\"DC50\")) {\n      strcpy (model, \"DC50\");\n      height = 512;\n      width  = 768;\n      data_offset = 19712;\n      load_raw = &CLASS kodak_radc_load_raw;\n    } else if (strstr(model,\"DC120\")) {\n      strcpy (model, \"DC120\");\n      height = 976;\n      width  = 848;\n      pixel_aspect = height/0.75/width;\n      load_raw = tiff_compress == 7 ?\n\t&CLASS kodak_jpeg_load_raw : &CLASS kodak_dc120_load_raw;\n    } else if (!strcmp(model,\"DCS200\")) {\n      thumb_height = 128;\n      thumb_width  = 192;\n      thumb_offset = 6144;\n      thumb_misc   = 360;\n      write_thumb = &CLASS layer_thumb;\n      height = 1024;\n      width  = 1536;\n      data_offset = 79872;\n      load_raw = &CLASS eight_bit_load_raw;\n      black = 17;\n    }\n  } else if (!strcmp(model,\"Fotoman Pixtura\")) {\n    height = 512;\n    width  = 768;\n    data_offset = 3632;\n    load_raw = &CLASS kodak_radc_load_raw;\n    filters = 0x61616161;\n    simple_coeff(2);\n  } else if (!strncmp(model,\"QuickTake\",9)) {\n    if (head[5]) strcpy (model+10, \"200\");\n    fseek (ifp, 544, SEEK_SET);\n    height = get2();\n    width  = get2();\n    data_offset = (get4(),get2()) == 30 ? 738:736;\n    if (height > width) {\n      SWAP(height,width);\n      fseek (ifp, data_offset-6, SEEK_SET);\n      flip = ~get2() & 3 ? 5:6;\n    }\n    filters = 0x61616161;\n  } else if (!strcmp(make,\"Rollei\") && !load_raw) {\n    switch (raw_width) {\n      case 1316:\n\theight = 1030;\n\twidth  = 1300;\n\ttop_margin  = 1;\n\tleft_margin = 6;\n\tbreak;\n      case 2568:\n\theight = 1960;\n\twidth  = 2560;\n\ttop_margin  = 2;\n\tleft_margin = 8;\n    }\n    filters = 0x16161616;\n    load_raw = &CLASS rollei_load_raw;\n  } else if (!strcmp(model,\"PC-CAM 600\")) {\n    height = 768;\n    data_offset = width = 1024;\n    filters = 0x49494949;\n    load_raw = &CLASS eight_bit_load_raw;\n  } else if (!strcmp(model,\"QV-2000UX\")) {\n    height = 1208;\n    width  = 1632;\n    data_offset = width * 2;\n    load_raw = &CLASS eight_bit_load_raw;\n  } else if (fsize == 3217760) {\n    height = 1546;\n    width  = 2070;\n    raw_width = 2080;\n    load_raw = &CLASS eight_bit_load_raw;\n  } else if (!strcmp(model,\"QV-4000\")) {\n    height = 1700;\n    width  = 2260;\n    load_raw = &CLASS unpacked_load_raw;\n    maximum = 0xffff;\n  } else if (!strcmp(model,\"QV-5700\")) {\n    height = 1924;\n    width  = 2576;\n    raw_width = 3232;\n    tiff_bps = 10;\n  } else if (!strcmp(model,\"QV-R41\")) {\n    height = 1720;\n    width  = 2312;\n    raw_width = 3520;\n    left_margin = 2;\n  } else if (!strcmp(model,\"QV-R51\")) {\n    height = 1926;\n    width  = 2580;\n    raw_width = 3904;\n  } else if (!strcmp(model,\"EX-S20\")) {\n    height = 1208;\n    width  = 1620;\n    raw_width = 2432;\n    flip = 3;\n  } else if (!strcmp(model,\"EX-S100\")) {\n    height = 1544;\n    width  = 2058;\n    raw_width = 3136;\n  } else if (!strcmp(model,\"EX-Z50\")) {\n    height = 1931;\n    width  = 2570;\n    raw_width = 3904;\n  } else if (!strcmp(model,\"EX-Z500\")) {\n    height = 1937;\n    width  = 2577;\n    raw_width = 3904;\n    filters = 0x16161616;\n  } else if (!strcmp(model,\"EX-Z55\")) {\n    height = 1960;\n    width  = 2570;\n    raw_width = 3904;\n  } else if (!strcmp(model,\"EX-Z60\")) {\n    height = 2145;\n    width  = 2833;\n    raw_width = 3584;\n    filters = 0x16161616;\n    tiff_bps = 10;\n  } else if (!strcmp(model,\"EX-Z75\")) {\n    height = 2321;\n    width  = 3089;\n    raw_width = 4672;\n    maximum = 0xfff;\n  } else if (!strcmp(model,\"EX-Z750\")) {\n    height = 2319;\n    width  = 3087;\n    raw_width = 4672;\n    maximum = 0xfff;\n  } else if (!strcmp(model,\"EX-Z850\")) {\n    height = 2468;\n    width  = 3279;\n    raw_width = 4928;\n    maximum = 0xfff;\n  } else if (!strcmp(model,\"EX-Z8\")) {\n    height = 2467;\n    width  = 3281;\n    raw_height = 2502;\n    raw_width  = 4992;\n    maximum = 0xfff;\n  } else if (fsize == 15499264) {\t/* EX-Z1050 or EX-Z1080 */\n    height = 2752;\n    width  = 3672;\n    raw_width = 5632;\n  } else if (!strcmp(model,\"EX-ZR100\")) {\n    height = 3044;\n    width  = 4072;\n    raw_width = 4096;\n    load_flags = 80;\n  } else if (!strcmp(model,\"EX-P505\")) {\n    height = 1928;\n    width  = 2568;\n    raw_width = 3852;\n    maximum = 0xfff;\n  } else if (fsize == 9313536) {\t/* EX-P600 or QV-R61 */\n    height = 2142;\n    width  = 2844;\n    raw_width = 4288;\n  } else if (!strcmp(model,\"EX-P700\")) {\n    height = 2318;\n    width  = 3082;\n    raw_width = 4672;\n  }\n  else if (!strcmp(model,\"GRAS-50S5C\")) {\n   height = 2048;\n   width = 2440;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x49494949;\n   order = 0x4949;\n   maximum = 0xfffC;\n  } else if (!strcmp(model,\"BB-500CL\")) {\n   height = 2058;\n   width = 2448;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x94949494;\n   order = 0x4949;\n   maximum = 0x3fff;\n  } else if (!strcmp(model,\"BB-500GE\")) {\n   height = 2058;\n   width = 2456;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x94949494;\n   order = 0x4949;\n   maximum = 0x3fff;\n  } else if (!strcmp(model,\"SVS625CL\")) {\n   height = 2050;\n   width = 2448;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x94949494;\n   order = 0x4949;\n   maximum = 0x0fff;\n  }\n}\n\n\n#line 10270 \"dcraw/dcraw.c\"\nvoid CLASS convert_to_rgb()\n{\n#ifndef LIBRAW_LIBRARY_BUILD\n  int row, col, c;\n#endif\n  int  i, j, k;\n#ifndef LIBRAW_LIBRARY_BUILD\n  ushort *img;\n  float out[3];\n#endif\n  float out_cam[3][4];\n  double num, inverse[3][3];\n  static const double xyzd50_srgb[3][3] =\n  { { 0.436083, 0.385083, 0.143055 },\n    { 0.222507, 0.716888, 0.060608 },\n    { 0.013930, 0.097097, 0.714022 } };\n  static const double rgb_rgb[3][3] =\n  { { 1,0,0 }, { 0,1,0 }, { 0,0,1 } };\n  static const double adobe_rgb[3][3] =\n  { { 0.715146, 0.284856, 0.000000 },\n    { 0.000000, 1.000000, 0.000000 },\n    { 0.000000, 0.041166, 0.958839 } };\n  static const double wide_rgb[3][3] =\n  { { 0.593087, 0.404710, 0.002206 },\n    { 0.095413, 0.843149, 0.061439 },\n    { 0.011621, 0.069091, 0.919288 } };\n  static const double prophoto_rgb[3][3] =\n  { { 0.529317, 0.330092, 0.140588 },\n    { 0.098368, 0.873465, 0.028169 },\n    { 0.016879, 0.117663, 0.865457 } };\n  static const double (*out_rgb[])[3] =\n  { rgb_rgb, adobe_rgb, wide_rgb, prophoto_rgb, xyz_rgb };\n  static const char *name[] =\n  { \"sRGB\", \"Adobe RGB (1998)\", \"WideGamut D65\", \"ProPhoto D65\", \"XYZ\" };\n  static const unsigned phead[] =\n  { 1024, 0, 0x2100000, 0x6d6e7472, 0x52474220, 0x58595a20, 0, 0, 0,\n    0x61637370, 0, 0, 0x6e6f6e65, 0, 0, 0, 0, 0xf6d6, 0x10000, 0xd32d };\n  unsigned pbody[] =\n  { 10, 0x63707274, 0, 36,\t/* cprt */\n\t0x64657363, 0, 40,\t/* desc */\n\t0x77747074, 0, 20,\t/* wtpt */\n\t0x626b7074, 0, 20,\t/* bkpt */\n\t0x72545243, 0, 14,\t/* rTRC */\n\t0x67545243, 0, 14,\t/* gTRC */\n\t0x62545243, 0, 14,\t/* bTRC */\n\t0x7258595a, 0, 20,\t/* rXYZ */\n\t0x6758595a, 0, 20,\t/* gXYZ */\n\t0x6258595a, 0, 20 };\t/* bXYZ */\n  static const unsigned pwhite[] = { 0xf351, 0x10000, 0x116cc };\n  unsigned pcurve[] = { 0x63757276, 0, 1, 0x1000000 };\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB,0,2);\n#endif\n  gamma_curve (gamm[0], gamm[1], 0, 0);\n  memcpy (out_cam, rgb_cam, sizeof out_cam);\n#ifndef LIBRAW_LIBRARY_BUILD\n  raw_color |= colors == 1 || document_mode ||\n\t\toutput_color < 1 || output_color > 5;\n#else\n  raw_color |= colors == 1 || \n\t\toutput_color < 1 || output_color > 5;\n#endif\n  if (!raw_color) {\n    oprof = (unsigned *) calloc (phead[0], 1);\n    merror (oprof, \"convert_to_rgb()\");\n    memcpy (oprof, phead, sizeof phead);\n    if (output_color == 5) oprof[4] = oprof[5];\n    oprof[0] = 132 + 12*pbody[0];\n    for (i=0; i < pbody[0]; i++) {\n      oprof[oprof[0]/4] = i ? (i > 1 ? 0x58595a20 : 0x64657363) : 0x74657874;\n      pbody[i*3+2] = oprof[0];\n      oprof[0] += (pbody[i*3+3] + 3) & -4;\n    }\n    memcpy (oprof+32, pbody, sizeof pbody);\n    oprof[pbody[5]/4+2] = strlen(name[output_color-1]) + 1;\n    memcpy ((char *)oprof+pbody[8]+8, pwhite, sizeof pwhite);\n    pcurve[3] = (short)(256/gamm[5]+0.5) << 16;\n    for (i=4; i < 7; i++)\n      memcpy ((char *)oprof+pbody[i*3+2], pcurve, sizeof pcurve);\n    pseudoinverse ((double (*)[3]) out_rgb[output_color-1], inverse, 3);\n    for (i=0; i < 3; i++)\n      for (j=0; j < 3; j++) {\n\tfor (num = k=0; k < 3; k++)\n\t  num += xyzd50_srgb[i][k] * inverse[j][k];\n\toprof[pbody[j*3+23]/4+i+2] = num * 0x10000 + 0.5;\n      }\n    for (i=0; i < phead[0]/4; i++)\n      oprof[i] = htonl(oprof[i]);\n    strcpy ((char *)oprof+pbody[2]+8, \"auto-generated by dcraw\");\n    strcpy ((char *)oprof+pbody[5]+12, name[output_color-1]);\n    for (i=0; i < 3; i++)\n      for (j=0; j < colors; j++)\n\tfor (out_cam[i][j] = k=0; k < 3; k++)\n\t  out_cam[i][j] += out_rgb[output_color-1][i][k] * rgb_cam[k][j];\n  }\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf (stderr, raw_color ? _(\"Building histograms...\\n\") :\n\t_(\"Converting to %s colorspace...\\n\"), name[output_color-1]);\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  convert_to_rgb_loop(out_cam);\n#else\n  memset (histogram, 0, sizeof histogram);\n  for (img=image[0], row=0; row < height; row++)\n    for (col=0; col < width; col++, img+=4) {\n      if (!raw_color) {\n\tout[0] = out[1] = out[2] = 0;\n\tFORCC {\n\t  out[0] += out_cam[0][c] * img[c];\n\t  out[1] += out_cam[1][c] * img[c];\n\t  out[2] += out_cam[2][c] * img[c];\n\t}\n\tFORC3 img[c] = CLIP((int) out[c]);\n      }\n      else if (document_mode)\n\timg[0] = img[fcol(row,col)];\n      FORCC histogram[c][img[c] >> 3]++;\n    }\n#endif\n  if (colors == 4 && output_color) colors = 3;\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (document_mode && filters) colors = 1;\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB,1,2);\n#endif\n}\n\nvoid CLASS fuji_rotate()\n{\n  int i, row, col;\n  double step;\n  float r, c, fr, fc;\n  unsigned ur, uc;\n  ushort wide, high, (*img)[4], (*pix)[4];\n\n  if (!fuji_width) return;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf (stderr,_(\"Rotating image 45 degrees...\\n\"));\n#endif\n  fuji_width = (fuji_width - 1 + shrink) >> shrink;\n  step = sqrt(0.5);\n  wide = fuji_width / step;\n  high = (height - fuji_width) / step;\n  img = (ushort (*)[4]) calloc (wide*high, sizeof *img);\n  merror (img, \"fuji_rotate()\");\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE,0,2);\n#endif\n\n  for (row=0; row < high; row++)\n    for (col=0; col < wide; col++) {\n      ur = r = fuji_width + (row-col)*step;\n      uc = c = (row+col)*step;\n      if (ur > height-2 || uc > width-2) continue;\n      fr = r - ur;\n      fc = c - uc;\n      pix = image + ur*width + uc;\n      for (i=0; i < colors; i++)\n\timg[row*wide+col][i] =\n\t  (pix[    0][i]*(1-fc) + pix[      1][i]*fc) * (1-fr) +\n\t  (pix[width][i]*(1-fc) + pix[width+1][i]*fc) * fr;\n    }\n\n  free (image);\n  width  = wide;\n  height = high;\n  image  = img;\n  fuji_width = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE,1,2);\n#endif\n}\n\nvoid CLASS stretch()\n{\n  ushort newdim, (*img)[4], *pix0, *pix1;\n  int row, col, c;\n  double rc, frac;\n\n  if (pixel_aspect == 1) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH,0,2);\n#endif\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Stretching the image...\\n\"));\n#endif\n  if (pixel_aspect < 1) {\n    newdim = height / pixel_aspect + 0.5;\n    img = (ushort (*)[4]) calloc (width*newdim, sizeof *img);\n    merror (img, \"stretch()\");\n    for (rc=row=0; row < newdim; row++, rc+=pixel_aspect) {\n      frac = rc - (c = rc);\n      pix0 = pix1 = image[c*width];\n      if (c+1 < height) pix1 += width*4;\n      for (col=0; col < width; col++, pix0+=4, pix1+=4)\n\tFORCC img[row*width+col][c] = pix0[c]*(1-frac) + pix1[c]*frac + 0.5;\n    }\n    height = newdim;\n  } else {\n    newdim = width * pixel_aspect + 0.5;\n    img = (ushort (*)[4]) calloc (height*newdim, sizeof *img);\n    merror (img, \"stretch()\");\n    for (rc=col=0; col < newdim; col++, rc+=1/pixel_aspect) {\n      frac = rc - (c = rc);\n      pix0 = pix1 = image[c];\n      if (c+1 < width) pix1 += 4;\n      for (row=0; row < height; row++, pix0+=width*4, pix1+=width*4)\n\tFORCC img[row*newdim+col][c] = pix0[c]*(1-frac) + pix1[c]*frac + 0.5;\n    }\n    width = newdim;\n  }\n  free (image);\n  image = img;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH,1,2);\n#endif\n}\n\nint CLASS flip_index (int row, int col)\n{\n  if (flip & 4) SWAP(row,col);\n  if (flip & 2) row = iheight - 1 - row;\n  if (flip & 1) col = iwidth  - 1 - col;\n  return row * iwidth + col;\n}\n#line 10526 \"dcraw/dcraw.c\"\nvoid CLASS tiff_set (ushort *ntag,\n\tushort tag, ushort type, int count, int val)\n{\n  struct tiff_tag *tt;\n  int c;\n\n  tt = (struct tiff_tag *)(ntag+1) + (*ntag)++;\n  tt->tag = tag;\n  tt->type = type;\n  tt->count = count;\n  if (type < 3 && count <= 4)\n    FORC(4) tt->val.c[c] = val >> (c << 3);\n  else if (type == 3 && count <= 2)\n    FORC(2) tt->val.s[c] = val >> (c << 4);\n  else tt->val.i = val;\n}\n\n#define TOFF(ptr) ((char *)(&(ptr)) - (char *)th)\n\nvoid CLASS tiff_head (struct tiff_hdr *th, int full)\n{\n  int c, psize=0;\n  struct tm *t;\n\n  memset (th, 0, sizeof *th);\n  th->t_order = htonl(0x4d4d4949) >> 16;\n  th->magic = 42;\n  th->ifd = 10;\n  if (full) {\n    tiff_set (&th->ntag, 254, 4, 1, 0);\n    tiff_set (&th->ntag, 256, 4, 1, width);\n    tiff_set (&th->ntag, 257, 4, 1, height);\n    tiff_set (&th->ntag, 258, 3, colors, output_bps);\n    if (colors > 2)\n      th->tag[th->ntag-1].val.i = TOFF(th->bps);\n    FORC4 th->bps[c] = output_bps;\n    tiff_set (&th->ntag, 259, 3, 1, 1);\n    tiff_set (&th->ntag, 262, 3, 1, 1 + (colors > 1));\n  }\n  tiff_set (&th->ntag, 270, 2, 512, TOFF(th->t_desc));\n  tiff_set (&th->ntag, 271, 2, 64, TOFF(th->t_make));\n  tiff_set (&th->ntag, 272, 2, 64, TOFF(th->t_model));\n  if (full) {\n    if (oprof) psize = ntohl(oprof[0]);\n    tiff_set (&th->ntag, 273, 4, 1, sizeof *th + psize);\n    tiff_set (&th->ntag, 277, 3, 1, colors);\n    tiff_set (&th->ntag, 278, 4, 1, height);\n    tiff_set (&th->ntag, 279, 4, 1, height*width*colors*output_bps/8);\n  } else\n    tiff_set (&th->ntag, 274, 3, 1, \"12435867\"[flip]-'0');\n  tiff_set (&th->ntag, 282, 5, 1, TOFF(th->rat[0]));\n  tiff_set (&th->ntag, 283, 5, 1, TOFF(th->rat[2]));\n  tiff_set (&th->ntag, 284, 3, 1, 1);\n  tiff_set (&th->ntag, 296, 3, 1, 2);\n  tiff_set (&th->ntag, 305, 2, 32, TOFF(th->soft));\n  tiff_set (&th->ntag, 306, 2, 20, TOFF(th->date));\n  tiff_set (&th->ntag, 315, 2, 64, TOFF(th->t_artist));\n  tiff_set (&th->ntag, 34665, 4, 1, TOFF(th->nexif));\n  if (psize) tiff_set (&th->ntag, 34675, 7, psize, sizeof *th);\n  tiff_set (&th->nexif, 33434, 5, 1, TOFF(th->rat[4]));\n  tiff_set (&th->nexif, 33437, 5, 1, TOFF(th->rat[6]));\n  tiff_set (&th->nexif, 34855, 3, 1, iso_speed);\n  tiff_set (&th->nexif, 37386, 5, 1, TOFF(th->rat[8]));\n  if (gpsdata[1]) {\n    tiff_set (&th->ntag, 34853, 4, 1, TOFF(th->ngps));\n    tiff_set (&th->ngps,  0, 1,  4, 0x202);\n    tiff_set (&th->ngps,  1, 2,  2, gpsdata[29]);\n    tiff_set (&th->ngps,  2, 5,  3, TOFF(th->gps[0]));\n    tiff_set (&th->ngps,  3, 2,  2, gpsdata[30]);\n    tiff_set (&th->ngps,  4, 5,  3, TOFF(th->gps[6]));\n    tiff_set (&th->ngps,  5, 1,  1, gpsdata[31]);\n    tiff_set (&th->ngps,  6, 5,  1, TOFF(th->gps[18]));\n    tiff_set (&th->ngps,  7, 5,  3, TOFF(th->gps[12]));\n    tiff_set (&th->ngps, 18, 2, 12, TOFF(th->gps[20]));\n    tiff_set (&th->ngps, 29, 2, 12, TOFF(th->gps[23]));\n    memcpy (th->gps, gpsdata, sizeof th->gps);\n  }\n  th->rat[0] = th->rat[2] = 300;\n  th->rat[1] = th->rat[3] = 1;\n  FORC(6) th->rat[4+c] = 1000000;\n  th->rat[4] *= shutter;\n  th->rat[6] *= aperture;\n  th->rat[8] *= focal_len;\n  strncpy (th->t_desc, desc, 512);\n  strncpy (th->t_make, make, 64);\n  strncpy (th->t_model, model, 64);\n  strcpy (th->soft, \"dcraw v\"DCRAW_VERSION);\n  t = localtime (&timestamp);\n  sprintf (th->date, \"%04d:%02d:%02d %02d:%02d:%02d\",\n      t->tm_year+1900,t->tm_mon+1,t->tm_mday,t->tm_hour,t->tm_min,t->tm_sec);\n  strncpy (th->t_artist, artist, 64);\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\nvoid CLASS jpeg_thumb_writer (FILE *tfp,char *t_humb,int t_humb_length)\n{\n  ushort exif[5];\n  struct tiff_hdr th;\n  fputc (0xff, tfp);\n  fputc (0xd8, tfp);\n  if (strcmp (t_humb+6, \"Exif\")) {\n    memcpy (exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n    exif[1] = htons (8 + sizeof th);\n    fwrite (exif, 1, sizeof exif, tfp);\n    tiff_head (&th, 0);\n    fwrite (&th, 1, sizeof th, tfp);\n  }\n  fwrite (t_humb+2, 1, t_humb_length-2, tfp);\n}\n\nvoid CLASS jpeg_thumb()\n{\n  char *thumb;\n\n  thumb = (char *) malloc (thumb_length);\n  merror (thumb, \"jpeg_thumb()\");\n  fread (thumb, 1, thumb_length, ifp);\n  jpeg_thumb_writer(ofp,thumb,thumb_length);\n  free (thumb);\n}\n#else\nvoid CLASS jpeg_thumb()\n{\n  char *thumb;\n  ushort exif[5];\n  struct tiff_hdr th;\n\n  thumb = (char *) malloc (thumb_length);\n  merror (thumb, \"jpeg_thumb()\");\n  fread (thumb, 1, thumb_length, ifp);\n  fputc (0xff, ofp);\n  fputc (0xd8, ofp);\n  if (strcmp (thumb+6, \"Exif\")) {\n    memcpy (exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n    exif[1] = htons (8 + sizeof th);\n    fwrite (exif, 1, sizeof exif, ofp);\n    tiff_head (&th, 0);\n    fwrite (&th, 1, sizeof th, ofp);\n  }\n  fwrite (thumb+2, 1, thumb_length-2, ofp);\n  free (thumb);\n}\n#endif\n\nvoid CLASS write_ppm_tiff()\n{\n  struct tiff_hdr th;\n  uchar *ppm;\n  ushort *ppm2;\n  int c, row, col, soff, rstep, cstep;\n  int perc, val, total, t_white=0x2000;\n\n  perc = width * height * 0.01;\t\t/* 99th percentile white level */\n  if (fuji_width) perc /= 2;\n  if (!((highlight & ~2) || no_auto_bright))\n    for (t_white=c=0; c < colors; c++) {\n      for (val=0x2000, total=0; --val > 32; )\n\tif ((total += histogram[c][val]) > perc) break;\n      if (t_white < val) t_white = val;\n    }\n  gamma_curve (gamm[0], gamm[1], 2, (t_white << 3)/bright);\n  iheight = height;\n  iwidth  = width;\n  if (flip & 4) SWAP(height,width);\n  ppm = (uchar *) calloc (width, colors*output_bps/8);\n  ppm2 = (ushort *) ppm;\n  merror (ppm, \"write_ppm_tiff()\");\n  if (output_tiff) {\n    tiff_head (&th, 1);\n    fwrite (&th, sizeof th, 1, ofp);\n    if (oprof)\n      fwrite (oprof, ntohl(oprof[0]), 1, ofp);\n  } else if (colors > 3)\n    fprintf (ofp,\n      \"P7\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %d\\nMAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\",\n\twidth, height, colors, (1 << output_bps)-1, cdesc);\n  else\n    fprintf (ofp, \"P%d\\n%d %d\\n%d\\n\",\n\tcolors/2+5, width, height, (1 << output_bps)-1);\n  soff  = flip_index (0, 0);\n  cstep = flip_index (0, 1) - soff;\n  rstep = flip_index (1, 0) - flip_index (0, width);\n  for (row=0; row < height; row++, soff += rstep) {\n    for (col=0; col < width; col++, soff += cstep)\n      if (output_bps == 8)\n\t   FORCC ppm [col*colors+c] = curve[image[soff][c]] >> 8;\n      else FORCC ppm2[col*colors+c] = curve[image[soff][c]];\n    if (output_bps == 16 && !output_tiff && htons(0x55aa) != 0x55aa)\n      swab ((char*)ppm2, (char*)ppm2, width*colors*2);\n    fwrite (ppm, colors*output_bps/8, width, ofp);\n  }\n  free (ppm);\n}\n", "/* \n  Copyright 2008-2013 LibRaw LLC (info@libraw.org)\n\nLibRaw is free software; you can redistribute it and/or modify\nit under the terms of the one of three licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n3. LibRaw Software License 27032010\n   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).\n\n   This file is generated from Dave Coffin's dcraw.c\n   dcraw.c -- Dave Coffin's raw photo decoder\n   Copyright 1997-2010 by Dave Coffin, dcoffin a cybercom o net\n\n   Look into dcraw homepage (probably http://cybercom.net/~dcoffin/dcraw/)\n   for more information\n*/\n\n#line 3980 \"dcraw/dcraw.c\"\n#include <math.h>\n#define CLASS LibRaw::\n#include \"libraw/libraw_types.h\"\n#define LIBRAW_LIBRARY_BUILD\n#include \"libraw/libraw.h\"\n#include \"internal/defines.h\"\n#include \"internal/var_defines.h\"\n#line 3991 \"dcraw/dcraw.c\"\n/*\n   Seach from the current directory up to the root looking for\n   a \".badpixels\" file, and fix those pixels now.\n */\nvoid CLASS bad_pixels (const char *cfname)\n{\n  FILE *fp=NULL;\n#ifndef LIBRAW_LIBRARY_BUILD\n  char *fname, *cp, line[128];\n  int len, time, row, col, r, c, rad, tot, n, fixed=0;\n#else\n  char *cp, line[128];\n  int time, row, col, r, c, rad, tot, n;\n#ifdef DCRAW_VERBOSE\n  int fixed = 0;\n#endif\n#endif\n\n  if (!filters) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,0,2);\n#endif\n  if (cfname)\n    fp = fopen (cfname, \"r\");\n#line 4041 \"dcraw/dcraw.c\"\n  if (!fp)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_BADPIXELMAP;\n#endif\n          return;\n      }\n  while (fgets (line, 128, fp)) {\n    cp = strchr (line, '#');\n    if (cp) *cp = 0;\n    if (sscanf (line, \"%d %d %d\", &col, &row, &time) != 3) continue;\n    if ((unsigned) col >= width || (unsigned) row >= height) continue;\n    if (time > timestamp) continue;\n    for (tot=n=0, rad=1; rad < 3 && n==0; rad++)\n      for (r = row-rad; r <= row+rad; r++)\n\tfor (c = col-rad; c <= col+rad; c++)\n\t  if ((unsigned) r < height && (unsigned) c < width &&\n\t\t(r != row || c != col) && fcol(r,c) == fcol(row,col)) {\n\t    tot += BAYER2(r,c);\n\t    n++;\n\t  }\n    BAYER2(row,col) = tot/n;\n#ifdef DCRAW_VERBOSE\n    if (verbose) {\n      if (!fixed++)\n\tfprintf (stderr,_(\"Fixed dead pixels at:\"));\n      fprintf (stderr, \" %d,%d\", col, row);\n    }\n#endif\n  }\n#ifdef DCRAW_VERBOSE\n  if (fixed) fputc ('\\n', stderr);\n#endif\n  fclose (fp);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,1,2);\n#endif\n}\n\nvoid CLASS subtract (const char *fname)\n{\n  FILE *fp;\n  int dim[3]={0,0,0}, comment=0, number=0, error=0, nd=0, c, row, col;\n  ushort *pixel;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME,0,2);\n#endif\n\n  if (!(fp = fopen (fname, \"rb\"))) {\n#ifdef DCRAW_VERBOSE\n    perror (fname); \n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_BAD_DARKFRAME_FILE;\n#endif\n    return;\n  }\n  if (fgetc(fp) != 'P' || fgetc(fp) != '5') error = 1;\n  while (!error && nd < 3 && (c = fgetc(fp)) != EOF) {\n    if (c == '#')  comment = 1;\n    if (c == '\\n') comment = 0;\n    if (comment) continue;\n    if (isdigit(c)) number = 1;\n    if (number) {\n      if (isdigit(c)) dim[nd] = dim[nd]*10 + c -'0';\n      else if (isspace(c)) {\n\tnumber = 0;  nd++;\n      } else error = 1;\n    }\n  }\n  if (error || nd < 3) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s is not a valid PGM file!\\n\"), fname);\n#endif\n    fclose (fp);  return;\n  } else if (dim[0] != width || dim[1] != height || dim[2] != 65535) {\n#ifdef DCRAW_VERBOSE\n      fprintf (stderr,_(\"%s has the wrong dimensions!\\n\"), fname);\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.process_warnings |= LIBRAW_WARN_BAD_DARKFRAME_DIM;\n#endif\n    fclose (fp);  return;\n  }\n  pixel = (ushort *) calloc (width, sizeof *pixel);\n  merror (pixel, \"subtract()\");\n  for (row=0; row < height; row++) {\n    fread (pixel, 2, width, fp);\n    for (col=0; col < width; col++)\n      BAYER(row,col) = MAX (BAYER(row,col) - ntohs(pixel[col]), 0);\n  }\n  free (pixel);\n  fclose (fp);\n  memset (cblack, 0, sizeof cblack);\n  black = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME,1,2);\n#endif\n}\n#line 10181 \"dcraw/dcraw.c\"\n#ifndef NO_LCMS\nvoid CLASS apply_profile (const char *input, const char *output)\n{\n  char *prof;\n  cmsHPROFILE hInProfile=0, hOutProfile=0;\n  cmsHTRANSFORM hTransform;\n  FILE *fp;\n  unsigned size;\n\n#ifndef USE_LCMS2\n  cmsErrorAction (LCMS_ERROR_SHOW);\n#endif\n  if (strcmp (input, \"embed\"))\n    hInProfile = cmsOpenProfileFromFile (input, \"r\");\n  else if (profile_length) {\n#ifndef LIBRAW_LIBRARY_BUILD\n    prof = (char *) malloc (profile_length);\n    merror (prof, \"apply_profile()\");\n    fseek (ifp, profile_offset, SEEK_SET);\n    fread (prof, 1, profile_length, ifp);\n    hInProfile = cmsOpenProfileFromMem (prof, profile_length);\n    free (prof);\n#else\n    hInProfile = cmsOpenProfileFromMem (imgdata.color.profile, profile_length);\n#endif\n  } else\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_EMBEDDED_PROFILE;\n#endif\n#ifdef DCRAW_VERBOSE\n          fprintf (stderr,_(\"%s has no embedded profile.\\n\"), ifname);\n#endif\n    }\n  if (!hInProfile)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_INPUT_PROFILE;\n#endif\n          return;\n      }\n  if (!output)\n    hOutProfile = cmsCreate_sRGBProfile();\n  else if ((fp = fopen (output, \"rb\"))) {\n    fread (&size, 4, 1, fp);\n    fseek (fp, 0, SEEK_SET);\n    oprof = (unsigned *) malloc (size = ntohl(size));\n    merror (oprof, \"apply_profile()\");\n    fread (oprof, 1, size, fp);\n    fclose (fp);\n    if (!(hOutProfile = cmsOpenProfileFromMem (oprof, size))) {\n      free (oprof);\n      oprof = 0;\n    }\n  }\n#ifdef DCRAW_VERBOSE\n else\n    fprintf (stderr,_(\"Cannot open file %s!\\n\"), output);\n#endif\n  if (!hOutProfile)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_BAD_OUTPUT_PROFILE;\n#endif\n          goto quit;\n      }\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf (stderr,_(\"Applying color profile...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_APPLY_PROFILE,0,2);\n#endif\n  hTransform = cmsCreateTransform (hInProfile, TYPE_RGBA_16,\n\thOutProfile, TYPE_RGBA_16, INTENT_PERCEPTUAL, 0);\n  cmsDoTransform (hTransform, image, image, width*height);\n  raw_color = 1;\t\t/* Don't use rgb_cam with a profile */\n  cmsDeleteTransform (hTransform);\n  cmsCloseProfile (hOutProfile);\nquit:\n  cmsCloseProfile (hInProfile);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_APPLY_PROFILE,1,2);\n#endif\n}\n#endif\n", "/* -*- C++ -*-\n * File: libraw_version.h\n * Copyright 2008-2013 LibRaw LLC (info@libraw.org)\n * Created: Mon Sept  8, 2008 \n *\n * LibRaw C++ interface\n *\n\nLibRaw is free software; you can redistribute it and/or modify\nit under the terms of the one of three licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n(See the file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n(See the file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n3. LibRaw Software License 27032010\n  (See the file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).\n\n */\n\n#ifndef __VERSION_H\n#define __VERSION_H\n\n#define LIBRAW_MAJOR_VERSION  0\n#define LIBRAW_MINOR_VERSION  15\n#define LIBRAW_PATCH_VERSION  4\n#define LIBRAW_VERSION_TAIL   Release\n\n#define LIBRAW_SHLIB_CURRENT  \t9\n#define LIBRAW_SHLIB_REVISION \t0\n#define LIBRAW_SHLIB_AGE     \t0\n\n#define _LIBRAW_VERSION_MAKE(a,b,c,d) #a\".\"#b\".\"#c\"-\"#d\n#define LIBRAW_VERSION_MAKE(a,b,c,d) _LIBRAW_VERSION_MAKE(a,b,c,d)\n\n#define LIBRAW_VERSION_STR LIBRAW_VERSION_MAKE(LIBRAW_MAJOR_VERSION,LIBRAW_MINOR_VERSION,LIBRAW_PATCH_VERSION,LIBRAW_VERSION_TAIL)\n\n#define LIBRAW_MAKE_VERSION(major,minor,patch) \\\n    (((major) << 16) | ((minor) << 8) | (patch))\n\n#define LIBRAW_VERSION \\\n    LIBRAW_MAKE_VERSION(LIBRAW_MAJOR_VERSION,LIBRAW_MINOR_VERSION,LIBRAW_PATCH_VERSION)\n\n#define LIBRAW_CHECK_VERSION(major,minor,patch) \\\n    ( LibRaw::versionNumber() >= LIBRAW_MAKE_VERSION(major,minor,patch) )\n\n#define LIBRAW_RUNTIME_CHECK_VERSION_EXACT() \\\n    ( (LibRaw::versionNumber() & 0xffff00) == LIBRAW_MAKE_VERSION(LIBRAW_MAJOR_VERSION,LIBRAW_MINOR_VERSION,0) )\n\n#define LIBRAW_RUNTIME_CHECK_VERSION_NOTLESS() \\\n    ( (LibRaw::versionNumber() & 0xffff00) >= LIBRAW_MAKE_VERSION(LIBRAW_MAJOR_VERSION,LIBRAW_MINOR_VERSION,0) )\n\n#define LIBRAW_COMPILE_CHECK_VERSION(major,minor) \\\n    (LIBRAW_MAKE_VERSION(major,minor,0) == (LIBRAW_VERSION & 0xffff00))\n\n#define LIBRAW_COMPILE_CHECK_VERSION_NOTLESS(major,minor) \\\n    (LIBRAW_MAKE_VERSION(major,minor,0) <= (LIBRAW_VERSION & 0xffff00))\n\n\n#endif\n", "/* -*- C++ -*-\n * File: libraw_datastream.cpp\n * Copyright 2008-2013 LibRaw LLC (info@libraw.org)\n *\n * LibRaw C++ interface (implementation)\n\n LibRaw is free software; you can redistribute it and/or modify\n it under the terms of the one of three licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n3. LibRaw Software License 27032010\n   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).\n\n*/\n\n#ifdef WIN32\n#ifdef __MINGW32__\n    #define _WIN32_WINNT 0x0500\n    #include <stdexcept>\n#endif\n#endif\n\n#define LIBRAW_LIBRARY_BUILD\n#include \"libraw/libraw_types.h\"\n#include \"libraw/libraw.h\"\n#include \"libraw/libraw_datastream.h\"\n#include \"internal/libraw_bytebuffer.h\"\n#include <sys/stat.h>\n#ifdef USE_JASPER\n#include <jasper/jasper.h>\t/* Decode RED camera movies */\n#else\n#define NO_JASPER\n#endif\n#ifdef USE_JPEG\n#include <jpeglib.h>\n#else\n#define NO_JPEG\n#endif\n\n\nLibRaw_byte_buffer::LibRaw_byte_buffer(unsigned sz) \n{ \n    buf=0; size=sz; offt=0; do_free=0; \n    if(size)\n        { \n            buf = (unsigned char*)malloc(size); do_free=1;\n        }\n}\n\nvoid LibRaw_byte_buffer::set_buffer(void *bb, unsigned int sz) \n{ \n    buf = (unsigned char*)bb; size = sz; offt=0; do_free=0;\n}\n\nLibRaw_byte_buffer::~LibRaw_byte_buffer() \n{ \n    if(do_free) free(buf);\n}\n\nLibRaw_byte_buffer *LibRaw_abstract_datastream::make_byte_buffer(unsigned int sz)\n{\n  if(INT64(sz)>size())\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n    LibRaw_byte_buffer *ret = new LibRaw_byte_buffer(sz);\n    if(!ret) // failed new should throw std::exception\n      throw LIBRAW_EXCEPTION_ALLOC;\n    read(ret->get_buffer(),sz,1);\n    return ret;\n}\n\nint LibRaw_abstract_datastream::tempbuffer_open(void  *buf, size_t size)\n{\n    if(substream) return EBUSY;\n    substream = new LibRaw_buffer_datastream(buf,size);\n    return substream?0:EINVAL;\n}\n\n\nvoid\tLibRaw_abstract_datastream::tempbuffer_close()\n{\n    if(substream) delete substream;\n    substream = NULL;\n}\n\n// == LibRaw_file_datastream ==\n\nLibRaw_file_datastream::~LibRaw_file_datastream()\n{\n  if(jas_file) fclose(jas_file);\n}\n\nLibRaw_file_datastream::LibRaw_file_datastream(const char *fname)\n    :filename(fname)\n#ifdef WIN32\n    ,wfilename()\n#endif\n    ,jas_file(NULL),_fsize(0)\n{\n  if (filename.size()>0) \n    {\n#ifndef WIN32\n      struct stat st;\n      if(!stat(filename.c_str(),&st))\n        _fsize = st.st_size;\t\n#else\n      struct _stati64 st;\n      if(!_stati64(filename.c_str(),&st))\n        _fsize = st.st_size;\n#endif\n      \n      std::auto_ptr<std::filebuf> buf(new std::filebuf());\n      buf->open(filename.c_str(), std::ios_base::in | std::ios_base::binary);\n      if (buf->is_open()) {\n        f = buf;\n      }\n    }\n}\n#if defined(WIN32) && !defined(__MINGW32__)\nLibRaw_file_datastream::LibRaw_file_datastream(const wchar_t *fname) : filename(),wfilename(fname),jas_file(NULL),_fsize(0)\n{\n  if (wfilename.size()>0) \n    {\n      struct _stati64 st;\n      if(!_wstati64(wfilename.c_str(),&st))\n        _fsize = st.st_size;\n      std::auto_ptr<std::filebuf> buf(new std::filebuf());\n      buf->open(wfilename.c_str(), std::ios_base::in | std::ios_base::binary);\n      if (buf->is_open()) {\n        f = buf;\n      }\n    }\n}\nconst wchar_t *LibRaw_file_datastream::wfname()\n{\n  return wfilename.size()>0?wfilename.c_str():NULL;\n}\n#endif\n\n int LibRaw_file_datastream::valid()\n{ \n    return f.get() ? 1 : 0; \n}\n\n#define LR_STREAM_CHK() do {if(!f.get()) throw LIBRAW_EXCEPTION_IO_EOF;}while(0)\n\nint LibRaw_file_datastream::read(void * ptr,size_t size, size_t nmemb)\n{\n    if(substream) return substream->read(ptr,size,nmemb);\n    \n/* Visual Studio 2008 marks sgetn as insecure, but VS2010 does not. */\n#if defined(WIN32SECURECALLS) && (_MSC_VER < 1600)\n    LR_STREAM_CHK(); return int(f->_Sgetn_s(static_cast<char*>(ptr), nmemb * size,nmemb * size) / size); \n#else\n    LR_STREAM_CHK(); return int(f->sgetn(static_cast<char*>(ptr), std::streamsize(nmemb * size)) / size); \n#endif\n}\n\nint LibRaw_file_datastream::eof() \n{ \n    if(substream) return substream->eof();\n    LR_STREAM_CHK(); return f->sgetc() == EOF; \n}\n\nint LibRaw_file_datastream::seek(INT64 o, int whence) \n{ \n    if(substream) return substream->seek(o,whence);\n    LR_STREAM_CHK(); \n    std::ios_base::seekdir dir;\n    switch (whence) \n        {\n        case SEEK_SET: dir = std::ios_base::beg; break;\n        case SEEK_CUR: dir = std::ios_base::cur; break;\n        case SEEK_END: dir = std::ios_base::end; break;\n        default: dir = std::ios_base::beg;\n        }\n    return (int)f->pubseekoff((long)o, dir)<0?-1:0;\n}\n\nINT64 LibRaw_file_datastream::tell()     \n{ \n    if(substream) return substream->tell();\n    LR_STREAM_CHK(); return f->pubseekoff(0, std::ios_base::cur);  \n}\n\nchar* LibRaw_file_datastream::gets(char *str, int sz) \n{ \n    if(substream) return substream->gets(str,sz);\n    LR_STREAM_CHK(); \n    std::istream is(f.get());\n    is.getline(str, sz);\n    if (is.fail()) return 0;\n    return str;\n}\n\nint LibRaw_file_datastream::scanf_one(const char *fmt, void*val) \n{ \n    if(substream) return substream->scanf_one(fmt,val);\n    LR_STREAM_CHK(); \n    \n    std::istream is(f.get());\n    \n    /* HUGE ASSUMPTION: *fmt is either \"%d\" or \"%f\" */\n    if (strcmp(fmt, \"%d\") == 0) {\n        int d;\n        is >> d;\n        if (is.fail()) return EOF;\n        *(static_cast<int*>(val)) = d;\n    } else {\n        float f;\n        is >> f;\n        if (is.fail()) return EOF;\n        *(static_cast<float*>(val)) = f;\n    }\n    \n    return 1;\n}\n\nconst char* LibRaw_file_datastream::fname() \n{ \n  return filename.size()>0?filename.c_str():NULL; \n}\n    \n/* You can't have a \"subfile\" and a \"tempfile\" at the same time. */\nint LibRaw_file_datastream::subfile_open(const char *fn)\n{\n    LR_STREAM_CHK();\n    if (saved_f.get()) return EBUSY;\n    saved_f = f;\n        std::auto_ptr<std::filebuf> buf(new std::filebuf());\n        \n        buf->open(fn, std::ios_base::in | std::ios_base::binary);\n        if (!buf->is_open()) {\n            f = saved_f;\n            return ENOENT;\n        } else {\n            f = buf;\n        }\n        \n        return 0;\n}\n\n#if defined(WIN32) && !defined(__MINGW32__)\nint LibRaw_file_datastream::subfile_open(const wchar_t *fn)\n{\n\tLR_STREAM_CHK();\n\tif (saved_f.get()) return EBUSY;\n\tsaved_f = f;\n\tstd::auto_ptr<std::filebuf> buf(new std::filebuf());\n\n\tbuf->open(fn, std::ios_base::in | std::ios_base::binary);\n\tif (!buf->is_open()) {\n\t\tf = saved_f;\n\t\treturn ENOENT;\n\t} else {\n\t\tf = buf;\n\t}\n\n\treturn 0;\n}\n#endif\n\n\nvoid LibRaw_file_datastream::subfile_close()\n{ \n    if (!saved_f.get()) return; \n    f = saved_f;   \n}\n\n#undef LR_STREAM_CHK\n\nvoid * LibRaw_file_datastream::make_jas_stream()\n{\n#ifdef NO_JASPER\n    return NULL;\n#else\n#if defined(WIN32) && !defined(__MINGW32__)\n\tif(wfname())\n\t{\n\t\tjas_file = _wfopen(wfname(),L\"rb\");\n\t\treturn jas_stream_fdopen(fileno(jas_file),\"rb\");\n\t}\n\telse\n#endif\n\t{\n\t\treturn jas_stream_fopen(fname(),\"rb\");\n\t}\n#endif\n}\n\nint LibRaw_file_datastream::jpeg_src(void *jpegdata)\n{\n#ifdef NO_JPEG\n  return -1; // not supported\n#else\n  if(jas_file) { fclose(jas_file); jas_file = NULL;}\n#if defined(WIN32) && !defined(__MINGW32__)\n  if(wfname())\n    {\n      jas_file = _wfopen(wfname(),L\"rb\");\n    }\n  else\n#endif\n    {\n      jas_file = fopen(fname(),\"rb\");\n    }\n  if(jas_file)\n    {\n      fseek(jas_file,tell(),SEEK_SET);\n      j_decompress_ptr cinfo = (j_decompress_ptr) jpegdata;\n      jpeg_stdio_src(cinfo,jas_file);\n      return 0; // OK\n    }\n  return -1;\n#endif\n}\n\n\n// == LibRaw_buffer_datastream\nLibRaw_buffer_datastream::LibRaw_buffer_datastream(void *buffer, size_t bsize)\n{    \n    buf = (unsigned char*)buffer; streampos = 0; streamsize = bsize;\n}\n\nLibRaw_buffer_datastream::~LibRaw_buffer_datastream(){}\n\nint LibRaw_buffer_datastream::read(void * ptr,size_t sz, size_t nmemb)\n{ \n    if(substream) return substream->read(ptr,sz,nmemb);\n    size_t to_read = sz*nmemb;\n    if(to_read > streamsize - streampos)\n        to_read = streamsize-streampos;\n    if(to_read<1) \n        return 0;\n    memmove(ptr,buf+streampos,to_read);\n    streampos+=to_read;\n    return int((to_read+sz-1)/sz);\n}\n\nint LibRaw_buffer_datastream::seek(INT64 o, int whence)\n{ \n    if(substream) return substream->seek(o,whence);\n    switch(whence)\n        {\n        case SEEK_SET:\n            if(o<0)\n                streampos = 0;\n            else if (size_t(o) > streamsize)\n                streampos = streamsize;\n            else\n                streampos = size_t(o);\n            return 0;\n        case SEEK_CUR:\n            if(o<0)\n                {\n                    if(size_t(-o) >= streampos)\n                        streampos = 0;\n                    else\n                        streampos += (size_t)o;\n                }\n            else if (o>0)\n                {\n                    if(o+streampos> streamsize)\n                        streampos = streamsize;\n                    else\n                        streampos += (size_t)o;\n                }\n            return 0;\n        case SEEK_END:\n            if(o>0)\n                streampos = streamsize;\n            else if ( size_t(-o) > streamsize)\n                streampos = 0;\n            else\n                streampos = streamsize+(size_t)o;\n            return 0;\n        default:\n            return 0;\n        }\n}\n\nINT64 LibRaw_buffer_datastream::tell()\n{ \n    if(substream) return substream->tell();\n    return INT64(streampos);\n}\n\nchar* LibRaw_buffer_datastream::gets(char *s, int sz)\n{ \n    if (substream) return substream->gets(s,sz);\n    unsigned char *psrc,*pdest,*str;\n    str = (unsigned char *)s;\n    psrc = buf+streampos;\n    pdest = str;\n    while ( (size_t(psrc - buf) < streamsize)\n            &&\n            ((pdest-str)<sz)\n        )\n        {\n            *pdest = *psrc;\n            if(*psrc == '\\n')\n                break;\n            psrc++;\n            pdest++;\n        }\n    if(size_t(psrc-buf) < streamsize)\n        psrc++;\n    if((pdest-str)<sz)\n        *(++pdest)=0;\n    streampos = psrc - buf;\n    return s;\n}\n\nint LibRaw_buffer_datastream::scanf_one(const char *fmt, void* val)\n{ \n    if(substream) return substream->scanf_one(fmt,val);\n    int scanf_res;\n    if(streampos>streamsize) return 0;\n#ifndef WIN32SECURECALLS\n    scanf_res = sscanf((char*)(buf+streampos),fmt,val);\n#else\n    scanf_res = sscanf_s((char*)(buf+streampos),fmt,val);\n#endif\n    if(scanf_res>0)\n        {\n            int xcnt=0;\n            while(streampos<streamsize)\n                {\n                    streampos++;\n                    xcnt++;\n                    if(buf[streampos] == 0\n                       || buf[streampos]==' '\n                       || buf[streampos]=='\\t'\n                       || buf[streampos]=='\\n'\n                       || xcnt>24)\n                        break;\n                }\n        }\n    return scanf_res;\n}\n\nLibRaw_byte_buffer *LibRaw_buffer_datastream::make_byte_buffer(unsigned int sz)\n{\n  if(INT64(sz)>size())\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n    LibRaw_byte_buffer *ret = new LibRaw_byte_buffer(0);\n    if(!ret) // failed new should throw std::exception\n      throw LIBRAW_EXCEPTION_ALLOC;\n    if(streampos + sz > streamsize)\n        sz = streamsize - streampos;\n    ret->set_buffer(buf+streampos,sz);\n    return ret;\n}\n\nint LibRaw_buffer_datastream::eof()\n{ \n    if(substream) return substream->eof();\n    return streampos >= streamsize;\n}\n int LibRaw_buffer_datastream::valid() \n{ \n    return buf?1:0;\n}\n\n\nvoid * LibRaw_buffer_datastream::make_jas_stream()\n{\n#ifdef NO_JASPER\n    return NULL;\n#else\n    return jas_stream_memopen((char*)buf+streampos,streamsize-streampos);\n#endif\n}\n\nint LibRaw_buffer_datastream::jpeg_src(void *jpegdata)\n{\n#if defined(NO_JPEG) || !defined (USE_JPEG8)\n  return -1;\n#else\n  j_decompress_ptr cinfo = (j_decompress_ptr) jpegdata;\n  jpeg_mem_src(cinfo,(unsigned char*)buf+streampos,streamsize-streampos);\n  return 0;\n#endif\n}\n\n\n//int LibRaw_buffer_datastream\n\n\n// == LibRaw_bigfile_datastream\nLibRaw_bigfile_datastream::LibRaw_bigfile_datastream(const char *fname): filename(fname)\n#ifdef WIN32\n\t,wfilename()\n#endif\n{ \n  if(filename.size()>0)\n    {\n#ifndef WIN32\n      struct stat st;\n      if(!stat(filename.c_str(),&st))\n        _fsize = st.st_size;\t\n#else\n      struct _stati64 st;\n      if(!_stati64(filename.c_str(),&st))\n        _fsize = st.st_size;\n#endif\n\n#ifndef WIN32SECURECALLS\n      f = fopen(fname,\"rb\");\n#else\n      if(fopen_s(&f,fname,\"rb\"))\n        f = 0;\n#endif\n    }\n    else \n      {filename=std::string();f=0;}\n    sav=0;\n}\n\n#if defined(WIN32) && !defined(__MINGW32__)\nLibRaw_bigfile_datastream::LibRaw_bigfile_datastream(const wchar_t *fname) : filename(),wfilename(fname)\n{ \n  if(wfilename.size()>0)\n    {\n      struct _stati64 st;\n      if(!_wstati64(wfilename.c_str(),&st))\n        _fsize = st.st_size;\n#ifndef WIN32SECURECALLS\n      f = _wfopen(wfilename.c_str(),L\"rb\");\n#else\n      if(_wfopen_s(&f,fname,L\"rb\"))\n        f = 0;\n#endif\n    }\n  else \n    {\n      wfilename=std::wstring();\n      f=0;\n    }\n  sav=0;\n}\nconst wchar_t *LibRaw_bigfile_datastream::wfname()\n{\n  return wfilename.size()>0?wfilename.c_str():NULL;\n}\n#endif\n\nLibRaw_bigfile_datastream::~LibRaw_bigfile_datastream() {if(f)fclose(f); if(sav)fclose(sav);}\nint         LibRaw_bigfile_datastream::valid() { return f?1:0;}\n\n#define LR_BF_CHK() do {if(!f) throw LIBRAW_EXCEPTION_IO_EOF;}while(0)\n\nint LibRaw_bigfile_datastream::read(void * ptr,size_t size, size_t nmemb) \n{ \n    LR_BF_CHK(); \n    return substream?substream->read(ptr,size,nmemb):int(fread(ptr,size,nmemb,f));\n}\n\nint LibRaw_bigfile_datastream::eof()\n{ \n    LR_BF_CHK(); \n    return substream?substream->eof():feof(f);\n}\n\nint     LibRaw_bigfile_datastream:: seek(INT64 o, int whence)\n{ \n    LR_BF_CHK(); \n#if defined (WIN32) \n#ifdef WIN32SECURECALLS\n    return substream?substream->seek(o,whence):_fseeki64(f,o,whence);\n#else\n    return substream?substream->seek(o,whence):fseek(f,(long)o,whence);\n#endif\n#else\n    return substream?substream->seek(o,whence):fseeko(f,o,whence);\n#endif\n}\n\nINT64 LibRaw_bigfile_datastream::tell()\n{ \n    LR_BF_CHK(); \n#if defined (WIN32)\n#ifdef WIN32SECURECALLS\n    return substream?substream->tell():_ftelli64(f);\n#else\n    return substream?substream->tell():ftell(f);\n#endif\n#else\n    return substream?substream->tell():ftello(f);\n#endif\n}\n\nchar* LibRaw_bigfile_datastream::gets(char *str, int sz)\n{ \n    LR_BF_CHK(); \n    return substream?substream->gets(str,sz):fgets(str,sz,f);\n}\n\nint LibRaw_bigfile_datastream::scanf_one(const char *fmt, void*val)\n{ \n    LR_BF_CHK(); \n    return substream?substream->scanf_one(fmt,val):\n#ifndef WIN32SECURECALLS\t\t\t\n        fscanf(f,fmt,val)\n#else\n        fscanf_s(f,fmt,val)\n#endif\n        ;\n}\n\nconst char *LibRaw_bigfile_datastream::fname() \n{ \n  return filename.size()>0?filename.c_str():NULL; \n}\n\nint LibRaw_bigfile_datastream::subfile_open(const char *fn)\n{\n    if(sav) return EBUSY;\n    sav = f;\n#ifndef WIN32SECURECALLS\n    f = fopen(fn,\"rb\");\n#else\n    fopen_s(&f,fn,\"rb\");\n#endif\n    if(!f)\n        {\n            f = sav;\n            sav = NULL;\n            return ENOENT;\n        }\n    else\n        return 0;\n}\n#if defined(WIN32) && !defined(__MINGW32__)\nint LibRaw_bigfile_datastream::subfile_open(const wchar_t *fn)\n{\n\tif(sav) return EBUSY;\n\tsav = f;\n#ifndef WIN32SECURECALLS\n\tf = _wfopen(fn,L\"rb\");\n#else\n\t_wfopen_s(&f,fn,L\"rb\");\n#endif\n\tif(!f)\n\t{\n\t\tf = sav;\n\t\tsav = NULL;\n\t\treturn ENOENT;\n\t}\n\telse\n\t\treturn 0;\n}\n#endif\n\n\nvoid LibRaw_bigfile_datastream::subfile_close()\n{\n    if(!sav) return;\n    fclose(f);\n    f = sav;\n    sav = 0;\n}\n\n\nvoid *LibRaw_bigfile_datastream::make_jas_stream()\n{\n#ifdef NO_JASPER\n    return NULL;\n#else\n    return jas_stream_fdopen(fileno(f),\"rb\");\n#endif\n}\n\nint LibRaw_bigfile_datastream::jpeg_src(void *jpegdata)\n{\n#ifdef NO_JPEG\n  return -1;\n#else\n  if(!f) return -1;\n  j_decompress_ptr cinfo = (j_decompress_ptr) jpegdata;\n  jpeg_stdio_src(cinfo,f);\n  return 0; // OK\n#endif\n}\n\n\n// == LibRaw_windows_datastream\n#ifdef WIN32\n\nLibRaw_windows_datastream::LibRaw_windows_datastream(const TCHAR* sFile)\n    : LibRaw_buffer_datastream(NULL, 0)\n    , hMap_(0)\n    , pView_(NULL)\n{\n    HANDLE hFile = CreateFile(sFile, GENERIC_READ, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);\n    if (hFile == INVALID_HANDLE_VALUE) \n        throw std::runtime_error(\"failed to open the file\"); \n    \n    try { Open(hFile); \t}\tcatch(...) { CloseHandle(hFile); throw; }\n    \n    CloseHandle(hFile);\t\t// windows will defer the actual closing of this handle until the hMap_ is closed\n    reconstruct_base();\n}\n\n\t// ctor: construct with a file handle - caller is responsible for closing the file handle\nLibRaw_windows_datastream::LibRaw_windows_datastream(HANDLE hFile)\n    : LibRaw_buffer_datastream(NULL, 0)\n    , hMap_(0)\n    , pView_(NULL)\n{\n    Open(hFile);\n    reconstruct_base();\n}\n\n// dtor: unmap and close the mapping handle\nLibRaw_windows_datastream::~LibRaw_windows_datastream()\n{\n    if (pView_ != NULL)\n        ::UnmapViewOfFile(pView_);\n    \n    if (hMap_ != 0)\n        ::CloseHandle(hMap_);\n}\n\nvoid LibRaw_windows_datastream::Open(HANDLE hFile)\n{\n    // create a file mapping handle on the file handle\n    hMap_ = ::CreateFileMapping(hFile, 0, PAGE_READONLY, 0, 0, 0);\n    if (hMap_ == NULL)\tthrow std::runtime_error(\"failed to create file mapping\"); \n    \n    // now map the whole file base view\n    if (!::GetFileSizeEx(hFile, (PLARGE_INTEGER)&cbView_))\n        throw std::runtime_error(\"failed to get the file size\"); \n    \n    pView_ = ::MapViewOfFile(hMap_, FILE_MAP_READ, 0, 0, (size_t)cbView_);\n    if (pView_ == NULL)\t\n        throw std::runtime_error(\"failed to map the file\"); \n}\n\n\n#endif\n\n\n    \n"], "filenames": ["Changelog.txt", "Makefile.devel", "dcraw/dcraw.c", "internal/dcraw_common.cpp", "internal/dcraw_fileio.cpp", "libraw/libraw_version.h", "src/libraw_datastream.cpp"], "buggy_code_start_loc": [1, 6, 879, 613, 24, 28, 66], "buggy_code_end_loc": [8, 17, 6745, 9216, 158, 29, 444], "fixing_code_start_loc": [1, 7, 880, 614, 24, 28, 67], "fixing_code_end_loc": [11, 18, 6785, 9255, 158, 29, 455], "type": "NVD-CWE-Other", "message": "The \"faster LJPEG decoder\" in libraw 0.13.x, 0.14.x, and 0.15.x before 0.15.4 allows context-dependent attackers to cause a denial of service (NULL pointer dereference) via a crafted photo file.", "other": {"cve": {"id": "CVE-2013-1439", "sourceIdentifier": "security@debian.org", "published": "2013-09-16T19:14:37.693", "lastModified": "2013-11-15T04:39:25.227", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The \"faster LJPEG decoder\" in libraw 0.13.x, 0.14.x, and 0.15.x before 0.15.4 allows context-dependent attackers to cause a denial of service (NULL pointer dereference) via a crafted photo file."}, {"lang": "es", "value": "El \"faster LJPEG decoder\" en libraw versiones 0.13.x, 0.14.x, y versiones 0.15.x anteriores a 0.15.4, permite a los atacantes dependiendo del contexto causar una denegaci\u00f3n de servicio (desreferencia de un puntero NULL) por medio de un archivo de fotos dise\u00f1ado."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.13.0:*:*:*:*:*:*:*", "matchCriteriaId": "41959708-2D95-472D-B845-40EC10C51ACE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.13.1:*:*:*:*:*:*:*", "matchCriteriaId": "03492249-E4F2-4696-AE8A-7111E3834490"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.13.2:*:*:*:*:*:*:*", "matchCriteriaId": "8939A79E-5B9C-4389-9CEA-752899C4AAE9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.13.3:*:*:*:*:*:*:*", "matchCriteriaId": "0B566274-96B5-4966-9ECA-F78DBB8F0DFD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.13.4:*:*:*:*:*:*:*", "matchCriteriaId": "1C1C9DE3-EEFF-4C10-8212-1BDFAF900204"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.13.5:*:*:*:*:*:*:*", "matchCriteriaId": "3DA5937A-9559-4A3D-B550-05512F639B89"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.13.6:*:*:*:*:*:*:*", "matchCriteriaId": "93912D7A-FE0B-4ACE-9F96-64D6F0EDE5C9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.13.7:*:*:*:*:*:*:*", "matchCriteriaId": "9F3DBCCD-AC9F-4DAE-A6B2-13BA32F2575A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.13.8:*:*:*:*:*:*:*", "matchCriteriaId": "CA950266-7B17-4A01-B879-6DC30F793608"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.14.0:*:*:*:*:*:*:*", "matchCriteriaId": "98C296C8-D525-4847-AA59-8CC46719D92E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.14.1:*:*:*:*:*:*:*", "matchCriteriaId": "1DFCCA04-3EED-48C5-9C70-7D3F0003C0D6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.14.2:*:*:*:*:*:*:*", "matchCriteriaId": "8A74AA57-4D88-4DF0-85A9-E7D6D1CEFF00"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.14.3:*:*:*:*:*:*:*", "matchCriteriaId": "69FEC106-AC7E-4ED9-8963-3FD4817EC56B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.14.4:*:*:*:*:*:*:*", "matchCriteriaId": "05EEAF87-8CCE-48EC-86E7-EE28329D2A9D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.14.5:*:*:*:*:*:*:*", "matchCriteriaId": "D054474D-5C98-4797-9C15-217B8EBD55EA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.14.6:*:*:*:*:*:*:*", "matchCriteriaId": "333AFB23-DC69-4612-8C6D-097617993561"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.14.7:*:*:*:*:*:*:*", "matchCriteriaId": "4BD3FC3C-52B7-45C6-84E6-6574767B2C72"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.15.0:*:*:*:*:*:*:*", "matchCriteriaId": "25844B56-0F72-4FAA-9179-19659142A8C2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.15.1:*:*:*:*:*:*:*", "matchCriteriaId": "36D20992-4F53-4BBF-8CF8-C3128F07EAB6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.15.2:*:*:*:*:*:*:*", "matchCriteriaId": "1C98A25F-7E97-4FE9-86B6-C281AE330D8C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.15.3:*:*:*:*:*:*:*", "matchCriteriaId": "3E52EC30-160B-4095-A269-DA8B7F0A11AA"}]}]}], "references": [{"url": "http://www.debian.org/security/2013/dsa-2748", "source": "security@debian.org"}, {"url": "http://www.openwall.com/lists/oss-security/2013/08/29/3", "source": "security@debian.org", "tags": ["Exploit", "Patch"]}, {"url": "https://github.com/LibRaw/LibRaw/commit/11909cc59e712e09b508dda729b99aeaac2b29ad", "source": "security@debian.org", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/LibRaw/LibRaw/commit/11909cc59e712e09b508dda729b99aeaac2b29ad"}}