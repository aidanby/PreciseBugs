{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * eval.c: Expression evaluation.\n */\n#define USING_FLOAT_STUFF\n\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n#ifdef VMS\n# include <float.h>\n#endif\n\n#define NAMESPACE_CHAR\t(char_u *)\"abglstvw\"\n\n/*\n * When recursively copying lists and dicts we need to remember which ones we\n * have done to avoid endless recursiveness.  This unique ID is used for that.\n * The last bit is used for previous_funccal, ignored when comparing.\n */\nstatic int current_copyID = 0;\n\n/*\n * Info used by a \":for\" loop.\n */\ntypedef struct\n{\n    int\t\tfi_semicolon;\t// TRUE if ending in '; var]'\n    int\t\tfi_varcount;\t// nr of variables in the list\n    int\t\tfi_break_count;\t// nr of line breaks encountered\n    listwatch_T\tfi_lw;\t\t// keep an eye on the item used.\n    list_T\t*fi_list;\t// list being used\n    int\t\tfi_bi;\t\t// index of blob\n    blob_T\t*fi_blob;\t// blob being used\n    char_u\t*fi_string;\t// copy of string being used\n    int\t\tfi_byte_idx;\t// byte index in fi_string\n} forinfo_T;\n\nstatic int eval2(char_u **arg, typval_T *rettv, evalarg_T *evalarg);\nstatic int eval3(char_u **arg, typval_T *rettv, evalarg_T *evalarg);\nstatic int eval4(char_u **arg, typval_T *rettv, evalarg_T *evalarg);\nstatic int eval5(char_u **arg, typval_T *rettv, evalarg_T *evalarg);\nstatic int eval6(char_u **arg, typval_T *rettv, evalarg_T *evalarg);\nstatic int eval7(char_u **arg, typval_T *rettv, evalarg_T *evalarg, int want_string);\nstatic int eval8(char_u **arg, typval_T *rettv, evalarg_T *evalarg, int want_string);\nstatic int eval9(char_u **arg, typval_T *rettv, evalarg_T *evalarg, int want_string);\nstatic int eval9_leader(typval_T *rettv, int numeric_only, char_u *start_leader, char_u **end_leaderp);\n\nstatic int free_unref_items(int copyID);\nstatic char_u *make_expanded_name(char_u *in_start, char_u *expr_start, char_u *expr_end, char_u *in_end);\n\n/*\n * Return \"n1\" divided by \"n2\", taking care of dividing by zero.\n * If \"failed\" is not NULL set it to TRUE when dividing by zero fails.\n */\n\tvarnumber_T\nnum_divide(varnumber_T n1, varnumber_T n2, int *failed)\n{\n    varnumber_T\tresult;\n\n    if (n2 == 0)\n    {\n\tif (in_vim9script())\n\t{\n\t    emsg(_(e_divide_by_zero));\n\t    if (failed != NULL)\n\t\t*failed = TRUE;\n\t}\n\tif (n1 == 0)\n\t    result = VARNUM_MIN; // similar to NaN\n\telse if (n1 < 0)\n\t    result = -VARNUM_MAX;\n\telse\n\t    result = VARNUM_MAX;\n    }\n    else\n\tresult = n1 / n2;\n\n    return result;\n}\n\n/*\n * Return \"n1\" modulus \"n2\", taking care of dividing by zero.\n * If \"failed\" is not NULL set it to TRUE when dividing by zero fails.\n */\n\tvarnumber_T\nnum_modulus(varnumber_T n1, varnumber_T n2, int *failed)\n{\n    if (n2 == 0 && in_vim9script())\n    {\n\temsg(_(e_divide_by_zero));\n\tif (failed != NULL)\n\t    *failed = TRUE;\n    }\n    return (n2 == 0) ? 0 : (n1 % n2);\n}\n\n/*\n * Initialize the global and v: variables.\n */\n    void\neval_init(void)\n{\n    evalvars_init();\n    func_init();\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\neval_clear(void)\n{\n    evalvars_clear();\n    free_scriptnames();  // must come after evalvars_clear().\n    free_locales();\n\n    // autoloaded script names\n    free_autoload_scriptnames();\n\n    // unreferenced lists and dicts\n    (void)garbage_collect(FALSE);\n\n    // functions not garbage collected\n    free_all_functions();\n}\n#endif\n\n    void\nfill_evalarg_from_eap(evalarg_T *evalarg, exarg_T *eap, int skip)\n{\n    init_evalarg(evalarg);\n    evalarg->eval_flags = skip ? 0 : EVAL_EVALUATE;\n    if (eap != NULL)\n    {\n\tevalarg->eval_cstack = eap->cstack;\n\tif (sourcing_a_script(eap) || eap->getline == get_list_line)\n\t{\n\t    evalarg->eval_getline = eap->getline;\n\t    evalarg->eval_cookie = eap->cookie;\n\t}\n    }\n}\n\n/*\n * Top level evaluation function, returning a boolean.\n * Sets \"error\" to TRUE if there was an error.\n * Return TRUE or FALSE.\n */\n    int\neval_to_bool(\n    char_u\t*arg,\n    int\t\t*error,\n    exarg_T\t*eap,\n    int\t\tskip)\t    // only parse, don't execute\n{\n    typval_T\ttv;\n    varnumber_T\tretval = FALSE;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, skip);\n\n    if (skip)\n\t++emsg_skip;\n    if (eval0(arg, &tv, eap, &evalarg) == FAIL)\n\t*error = TRUE;\n    else\n    {\n\t*error = FALSE;\n\tif (!skip)\n\t{\n\t    if (in_vim9script())\n\t\tretval = tv_get_bool_chk(&tv, error);\n\t    else\n\t\tretval = (tv_get_number_chk(&tv, error) != 0);\n\t    clear_tv(&tv);\n\t}\n    }\n    if (skip)\n\t--emsg_skip;\n    clear_evalarg(&evalarg, eap);\n\n    return (int)retval;\n}\n\n/*\n * Call eval1() and give an error message if not done at a lower level.\n */\n    static int\neval1_emsg(char_u **arg, typval_T *rettv, exarg_T *eap)\n{\n    char_u\t*start = *arg;\n    int\t\tret;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tcalled_emsg_before = called_emsg;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, eap != NULL && eap->skip);\n\n    ret = eval1(arg, rettv, &evalarg);\n    if (ret == FAIL)\n    {\n\t// Report the invalid expression unless the expression evaluation has\n\t// been cancelled due to an aborting error, an interrupt, or an\n\t// exception, or we already gave a more specific error.\n\t// Also check called_emsg for when using assert_fails().\n\tif (!aborting() && did_emsg == did_emsg_before\n\t\t\t\t\t  && called_emsg == called_emsg_before)\n\t    semsg(_(e_invalid_expression_str), start);\n    }\n    clear_evalarg(&evalarg, eap);\n    return ret;\n}\n\n/*\n * Return whether a typval is a valid expression to pass to eval_expr_typval()\n * or eval_expr_to_bool().  An empty string returns FALSE;\n */\n    int\neval_expr_valid_arg(typval_T *tv)\n{\n    return tv->v_type != VAR_UNKNOWN\n\t    && (tv->v_type != VAR_STRING\n\t\t  || (tv->vval.v_string != NULL && *tv->vval.v_string != NUL));\n}\n\n/*\n * Evaluate an expression, which can be a function, partial or string.\n * Pass arguments \"argv[argc]\".\n * Return the result in \"rettv\" and OK or FAIL.\n */\n    int\neval_expr_typval(typval_T *expr, typval_T *argv, int argc, typval_T *rettv)\n{\n    char_u\t*s;\n    char_u\tbuf[NUMBUFLEN];\n    funcexe_T\tfuncexe;\n\n    if (expr->v_type == VAR_FUNC)\n    {\n\ts = expr->vval.v_string;\n\tif (s == NULL || *s == NUL)\n\t    return FAIL;\n\tCLEAR_FIELD(funcexe);\n\tfuncexe.fe_evaluate = TRUE;\n\tif (call_func(s, -1, rettv, argc, argv, &funcexe) == FAIL)\n\t    return FAIL;\n    }\n    else if (expr->v_type == VAR_PARTIAL)\n    {\n\tpartial_T   *partial = expr->vval.v_partial;\n\n\tif (partial == NULL)\n\t    return FAIL;\n\n\tif (partial->pt_func != NULL\n\t\t\t  && partial->pt_func->uf_def_status != UF_NOT_COMPILED)\n\t{\n\t    if (call_def_function(partial->pt_func, argc, argv,\n\t\t\t\t\t\t       partial, rettv) == FAIL)\n\t\treturn FAIL;\n\t}\n\telse\n\t{\n\t    s = partial_name(partial);\n\t    if (s == NULL || *s == NUL)\n\t\treturn FAIL;\n\t    CLEAR_FIELD(funcexe);\n\t    funcexe.fe_evaluate = TRUE;\n\t    funcexe.fe_partial = partial;\n\t    if (call_func(s, -1, rettv, argc, argv, &funcexe) == FAIL)\n\t\treturn FAIL;\n\t}\n    }\n    else if (expr->v_type == VAR_INSTR)\n    {\n\treturn exe_typval_instr(expr, rettv);\n    }\n    else\n    {\n\ts = tv_get_string_buf_chk_strict(expr, buf, in_vim9script());\n\tif (s == NULL)\n\t    return FAIL;\n\ts = skipwhite(s);\n\tif (eval1_emsg(&s, rettv, NULL) == FAIL)\n\t    return FAIL;\n\tif (*skipwhite(s) != NUL)  // check for trailing chars after expr\n\t{\n\t    clear_tv(rettv);\n\t    semsg(_(e_invalid_expression_str), s);\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n\n/*\n * Like eval_to_bool() but using a typval_T instead of a string.\n * Works for string, funcref and partial.\n */\n    int\neval_expr_to_bool(typval_T *expr, int *error)\n{\n    typval_T\trettv;\n    int\t\tres;\n\n    if (eval_expr_typval(expr, NULL, 0, &rettv) == FAIL)\n    {\n\t*error = TRUE;\n\treturn FALSE;\n    }\n    res = (tv_get_bool_chk(&rettv, error) != 0);\n    clear_tv(&rettv);\n    return res;\n}\n\n/*\n * Top level evaluation function, returning a string.  If \"skip\" is TRUE,\n * only parsing to \"nextcmd\" is done, without reporting errors.  Return\n * pointer to allocated memory, or NULL for failure or when \"skip\" is TRUE.\n */\n    char_u *\neval_to_string_skip(\n    char_u\t*arg,\n    exarg_T\t*eap,\n    int\t\tskip)\t    // only parse, don't execute\n{\n    typval_T\ttv;\n    char_u\t*retval;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, skip);\n    if (skip)\n\t++emsg_skip;\n    if (eval0(arg, &tv, eap, &evalarg) == FAIL || skip)\n\tretval = NULL;\n    else\n    {\n\tretval = vim_strsave(tv_get_string(&tv));\n\tclear_tv(&tv);\n    }\n    if (skip)\n\t--emsg_skip;\n    clear_evalarg(&evalarg, eap);\n\n    return retval;\n}\n\n/*\n * Skip over an expression at \"*pp\".\n * Return FAIL for an error, OK otherwise.\n */\n    int\nskip_expr(char_u **pp, evalarg_T *evalarg)\n{\n    typval_T\trettv;\n\n    *pp = skipwhite(*pp);\n    return eval1(pp, &rettv, evalarg);\n}\n\n/*\n * Skip over an expression at \"*arg\".\n * If in Vim9 script and line breaks are encountered, the lines are\n * concatenated.  \"evalarg->eval_tofree\" will be set accordingly.\n * \"arg\" is advanced to just after the expression.\n * \"start\" is set to the start of the expression, \"end\" to just after the end.\n * Also when the expression is copied to allocated memory.\n * Return FAIL for an error, OK otherwise.\n */\n    int\nskip_expr_concatenate(\n\tchar_u\t    **arg,\n\tchar_u\t    **start,\n\tchar_u\t    **end,\n\tevalarg_T   *evalarg)\n{\n    typval_T\trettv;\n    int\t\tres;\n    int\t\tvim9script = in_vim9script();\n    garray_T    *gap = evalarg == NULL ? NULL : &evalarg->eval_ga;\n    garray_T    *freegap = evalarg == NULL ? NULL : &evalarg->eval_freega;\n    int\t\tsave_flags = evalarg == NULL ? 0 : evalarg->eval_flags;\n    int\t\tevaluate = evalarg == NULL\n\t\t\t       ? FALSE : (evalarg->eval_flags & EVAL_EVALUATE);\n\n    if (vim9script && evaluate\n\t       && (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL))\n    {\n\tga_init2(gap, sizeof(char_u *), 10);\n\t// leave room for \"start\"\n\tif (ga_grow(gap, 1) == OK)\n\t    ++gap->ga_len;\n\tga_init2(freegap, sizeof(char_u *), 10);\n    }\n    *start = *arg;\n\n    // Don't evaluate the expression.\n    if (evalarg != NULL)\n\tevalarg->eval_flags &= ~EVAL_EVALUATE;\n    *arg = skipwhite(*arg);\n    res = eval1(arg, &rettv, evalarg);\n    *end = *arg;\n    if (evalarg != NULL)\n\tevalarg->eval_flags = save_flags;\n\n    if (vim9script && evaluate\n\t    && (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL))\n    {\n\tif (evalarg->eval_ga.ga_len == 1)\n\t{\n\t    // just the one line, no need to concatenate\n\t    ga_clear(gap);\n\t    gap->ga_itemsize = 0;\n\t}\n\telse\n\t{\n\t    char_u\t    *p;\n\t    size_t\t    endoff = STRLEN(*arg);\n\n\t    // Line breaks encountered, concatenate all the lines.\n\t    *((char_u **)gap->ga_data) = *start;\n\t    p = ga_concat_strings(gap, \" \");\n\n\t    // free the lines only when using getsourceline()\n\t    if (evalarg->eval_cookie != NULL)\n\t    {\n\t\t// Do not free the first line, the caller can still use it.\n\t\t*((char_u **)gap->ga_data) = NULL;\n\t\t// Do not free the last line, \"arg\" points into it, free it\n\t\t// later.\n\t\tvim_free(evalarg->eval_tofree);\n\t\tevalarg->eval_tofree =\n\t\t\t\t    ((char_u **)gap->ga_data)[gap->ga_len - 1];\n\t\t((char_u **)gap->ga_data)[gap->ga_len - 1] = NULL;\n\t\tga_clear_strings(gap);\n\t    }\n\t    else\n\t    {\n\t\tga_clear(gap);\n\n\t\t// free lines that were explicitly marked for freeing\n\t\tga_clear_strings(freegap);\n\t    }\n\n\t    gap->ga_itemsize = 0;\n\t    if (p == NULL)\n\t\treturn FAIL;\n\t    *start = p;\n\t    vim_free(evalarg->eval_tofree_lambda);\n\t    evalarg->eval_tofree_lambda = p;\n\t    // Compute \"end\" relative to the end.\n\t    *end = *start + STRLEN(*start) - endoff;\n\t}\n    }\n\n    return res;\n}\n\n/*\n * Convert \"tv\" to a string.\n * When \"convert\" is TRUE convert a List into a sequence of lines and convert\n * a Float to a String.\n * Returns an allocated string (NULL when out of memory).\n */\n    char_u *\ntypval2string(typval_T *tv, int convert)\n{\n    garray_T\tga;\n    char_u\t*retval;\n#ifdef FEAT_FLOAT\n    char_u\tnumbuf[NUMBUFLEN];\n#endif\n\n    if (convert && tv->v_type == VAR_LIST)\n    {\n\tga_init2(&ga, sizeof(char), 80);\n\tif (tv->vval.v_list != NULL)\n\t{\n\t    list_join(&ga, tv->vval.v_list, (char_u *)\"\\n\", TRUE, FALSE, 0);\n\t    if (tv->vval.v_list->lv_len > 0)\n\t\tga_append(&ga, NL);\n\t}\n\tga_append(&ga, NUL);\n\tretval = (char_u *)ga.ga_data;\n    }\n#ifdef FEAT_FLOAT\n    else if (convert && tv->v_type == VAR_FLOAT)\n    {\n\tvim_snprintf((char *)numbuf, NUMBUFLEN, \"%g\", tv->vval.v_float);\n\tretval = vim_strsave(numbuf);\n    }\n#endif\n    else\n\tretval = vim_strsave(tv_get_string(tv));\n    return retval;\n}\n\n/*\n * Top level evaluation function, returning a string.  Does not handle line\n * breaks.\n * When \"convert\" is TRUE convert a List into a sequence of lines and convert\n * a Float to a String.\n * Return pointer to allocated memory, or NULL for failure.\n */\n    char_u *\neval_to_string_eap(\n    char_u\t*arg,\n    int\t\tconvert,\n    exarg_T\t*eap)\n{\n    typval_T\ttv;\n    char_u\t*retval;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, eap != NULL && eap->skip);\n    if (eval0(arg, &tv, NULL, &evalarg) == FAIL)\n\tretval = NULL;\n    else\n    {\n\tretval = typval2string(&tv, convert);\n\tclear_tv(&tv);\n    }\n    clear_evalarg(&evalarg, NULL);\n\n    return retval;\n}\n\n    char_u *\neval_to_string(\n    char_u\t*arg,\n    int\t\tconvert)\n{\n    return eval_to_string_eap(arg, convert, NULL);\n}\n\n/*\n * Call eval_to_string() without using current local variables and using\n * textlock.  When \"use_sandbox\" is TRUE use the sandbox.\n * Use legacy Vim script syntax.\n */\n    char_u *\neval_to_string_safe(\n    char_u\t*arg,\n    int\t\tuse_sandbox,\n    int\t\tkeep_script_version)\n{\n    char_u\t*retval;\n    funccal_entry_T funccal_entry;\n    int\t\tsave_sc_version = current_sctx.sc_version;\n    int\t\tsave_garbage = may_garbage_collect;\n\n    if (!keep_script_version)\n\tcurrent_sctx.sc_version = 1;\n    save_funccal(&funccal_entry);\n    if (use_sandbox)\n\t++sandbox;\n    ++textlock;\n    may_garbage_collect = FALSE;\n    retval = eval_to_string(arg, FALSE);\n    if (use_sandbox)\n\t--sandbox;\n    --textlock;\n    may_garbage_collect = save_garbage;\n    restore_funccal();\n    current_sctx.sc_version = save_sc_version;\n    return retval;\n}\n\n/*\n * Top level evaluation function, returning a number.\n * Evaluates \"expr\" silently.\n * Returns -1 for an error.\n */\n    varnumber_T\neval_to_number(char_u *expr)\n{\n    typval_T\trettv;\n    varnumber_T\tretval;\n    char_u\t*p = skipwhite(expr);\n\n    ++emsg_off;\n\n    if (eval1(&p, &rettv, &EVALARG_EVALUATE) == FAIL)\n\tretval = -1;\n    else\n    {\n\tretval = tv_get_number_chk(&rettv, NULL);\n\tclear_tv(&rettv);\n    }\n    --emsg_off;\n\n    return retval;\n}\n\n/*\n * Top level evaluation function.\n * Returns an allocated typval_T with the result.\n * Returns NULL when there is an error.\n */\n    typval_T *\neval_expr(char_u *arg, exarg_T *eap)\n{\n    typval_T\t*tv;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, eap != NULL && eap->skip);\n\n    tv = ALLOC_ONE(typval_T);\n    if (tv != NULL && eval0(arg, tv, eap, &evalarg) == FAIL)\n\tVIM_CLEAR(tv);\n\n    clear_evalarg(&evalarg, eap);\n    return tv;\n}\n\n/*\n * \"*arg\" points to what can be a function name in the form of \"import.Name\" or\n * \"Funcref\".  Return the name of the function.  Set \"tofree\" to something that\n * was allocated.\n * If \"verbose\" is FALSE no errors are given.\n * Return NULL for any failure.\n */\n    static char_u *\nderef_function_name(\n\t    char_u\t**arg,\n\t    char_u\t**tofree,\n\t    evalarg_T\t*evalarg,\n\t    int\t\tverbose)\n{\n    typval_T\tref;\n    char_u\t*name = *arg;\n\n    ref.v_type = VAR_UNKNOWN;\n    if (eval9(arg, &ref, evalarg, FALSE) == FAIL)\n    {\n\tdictitem_T\t*v;\n\n\t// If <SID>VarName was used it would not be found, try another way.\n\tv = find_var_also_in_script(name, NULL, FALSE);\n\tif (v == NULL)\n\t    return NULL;\n\tcopy_tv(&v->di_tv, &ref);\n    }\n    if (*skipwhite(*arg) != NUL)\n    {\n\tif (verbose)\n\t    semsg(_(e_trailing_characters_str), *arg);\n\tname = NULL;\n    }\n    else if (ref.v_type == VAR_FUNC && ref.vval.v_string != NULL)\n    {\n\tname = ref.vval.v_string;\n\tref.vval.v_string = NULL;\n\t*tofree = name;\n    }\n    else if (ref.v_type == VAR_PARTIAL && ref.vval.v_partial != NULL)\n    {\n\tif (ref.vval.v_partial->pt_argc > 0\n\t\t|| ref.vval.v_partial->pt_dict != NULL)\n\t{\n\t    if (verbose)\n\t\temsg(_(e_cannot_use_partial_here));\n\t    name = NULL;\n\t}\n\telse\n\t{\n\t    name = vim_strsave(partial_name(ref.vval.v_partial));\n\t    *tofree = name;\n\t}\n    }\n    else\n    {\n\tif (verbose)\n\t    semsg(_(e_not_callable_type_str), name);\n\tname = NULL;\n    }\n    clear_tv(&ref);\n    return name;\n}\n\n/*\n * Call some Vim script function and return the result in \"*rettv\".\n * Uses argv[0] to argv[argc - 1] for the function arguments.  argv[argc]\n * should have type VAR_UNKNOWN.\n * Returns OK or FAIL.\n */\n    int\ncall_vim_function(\n    char_u      *func,\n    int\t\targc,\n    typval_T\t*argv,\n    typval_T\t*rettv)\n{\n    int\t\tret;\n    funcexe_T\tfuncexe;\n    char_u\t*arg;\n    char_u\t*name;\n    char_u\t*tofree = NULL;\n    int\t\tignore_errors;\n\n    rettv->v_type = VAR_UNKNOWN;\t\t// clear_tv() uses this\n    CLEAR_FIELD(funcexe);\n    funcexe.fe_firstline = curwin->w_cursor.lnum;\n    funcexe.fe_lastline = curwin->w_cursor.lnum;\n    funcexe.fe_evaluate = TRUE;\n\n    // The name might be \"import.Func\" or \"Funcref\".  We don't know, we need to\n    // ignore errors for an undefined name.  But we do want errors when an\n    // autoload script has errors.  Guess that when there is a dot in the name\n    // showing errors is the right choice.\n    ignore_errors = vim_strchr(func, '.') == NULL;\n    arg = func;\n    if (ignore_errors)\n\t++emsg_off;\n    name = deref_function_name(&arg, &tofree, &EVALARG_EVALUATE, FALSE);\n    if (ignore_errors)\n\t--emsg_off;\n    if (name == NULL)\n\tname = func;\n\n    ret = call_func(name, -1, rettv, argc, argv, &funcexe);\n\n    if (ret == FAIL)\n\tclear_tv(rettv);\n    vim_free(tofree);\n\n    return ret;\n}\n\n/*\n * Call Vim script function \"func\" and return the result as a string.\n * Uses \"argv[0]\" to \"argv[argc - 1]\" for the function arguments. \"argv[argc]\"\n * should have type VAR_UNKNOWN.\n * Returns NULL when calling the function fails.\n */\n    void *\ncall_func_retstr(\n    char_u      *func,\n    int\t\targc,\n    typval_T\t*argv)\n{\n    typval_T\trettv;\n    char_u\t*retval;\n\n    if (call_vim_function(func, argc, argv, &rettv) == FAIL)\n\treturn NULL;\n\n    retval = vim_strsave(tv_get_string(&rettv));\n    clear_tv(&rettv);\n    return retval;\n}\n\n/*\n * Call Vim script function \"func\" and return the result as a List.\n * Uses \"argv\" and \"argc\" as call_func_retstr().\n * Returns NULL when there is something wrong.\n */\n    void *\ncall_func_retlist(\n    char_u      *func,\n    int\t\targc,\n    typval_T\t*argv)\n{\n    typval_T\trettv;\n\n    if (call_vim_function(func, argc, argv, &rettv) == FAIL)\n\treturn NULL;\n\n    if (rettv.v_type != VAR_LIST)\n    {\n\tclear_tv(&rettv);\n\treturn NULL;\n    }\n\n    return rettv.vval.v_list;\n}\n\n#if defined(FEAT_FOLDING) || defined(PROTO)\n/*\n * Evaluate \"arg\", which is 'foldexpr'.\n * Note: caller must set \"curwin\" to match \"arg\".\n * Returns the foldlevel, and any character preceding it in \"*cp\".  Doesn't\n * give error messages.\n */\n    int\neval_foldexpr(win_T *wp, int *cp)\n{\n    char_u\t*arg;\n    typval_T\ttv;\n    varnumber_T\tretval;\n    char_u\t*s;\n    sctx_T\tsaved_sctx = current_sctx;\n    int\t\tuse_sandbox = was_set_insecurely((char_u *)\"foldexpr\",\n\t\t\t\t\t\t\t\t   OPT_LOCAL);\n\n    arg = wp->w_p_fde;\n    current_sctx = wp->w_p_script_ctx[WV_FDE];\n\n    ++emsg_off;\n    if (use_sandbox)\n\t++sandbox;\n    ++textlock;\n    *cp = NUL;\n    if (eval0(arg, &tv, NULL, &EVALARG_EVALUATE) == FAIL)\n\tretval = 0;\n    else\n    {\n\t// If the result is a number, just return the number.\n\tif (tv.v_type == VAR_NUMBER)\n\t    retval = tv.vval.v_number;\n\telse if (tv.v_type != VAR_STRING || tv.vval.v_string == NULL)\n\t    retval = 0;\n\telse\n\t{\n\t    // If the result is a string, check if there is a non-digit before\n\t    // the number.\n\t    s = tv.vval.v_string;\n\t    if (!VIM_ISDIGIT(*s) && *s != '-')\n\t\t*cp = *s++;\n\t    retval = atol((char *)s);\n\t}\n\tclear_tv(&tv);\n    }\n    --emsg_off;\n    if (use_sandbox)\n\t--sandbox;\n    --textlock;\n    clear_evalarg(&EVALARG_EVALUATE, NULL);\n    current_sctx = saved_sctx;\n\n    return (int)retval;\n}\n#endif\n\n/*\n * Get an lval: variable, Dict item or List item that can be assigned a value\n * to: \"name\", \"na{me}\", \"name[expr]\", \"name[expr:expr]\", \"name[expr][expr]\",\n * \"name.key\", \"name.key[expr]\" etc.\n * Indexing only works if \"name\" is an existing List or Dictionary.\n * \"name\" points to the start of the name.\n * If \"rettv\" is not NULL it points to the value to be assigned.\n * \"unlet\" is TRUE for \":unlet\": slightly different behavior when something is\n * wrong; must end in space or cmd separator.\n *\n * flags:\n *  GLV_QUIET:       do not give error messages\n *  GLV_READ_ONLY:   will not change the variable\n *  GLV_NO_AUTOLOAD: do not use script autoloading\n *\n * Returns a pointer to just after the name, including indexes.\n * When an evaluation error occurs \"lp->ll_name\" is NULL;\n * Returns NULL for a parsing error.  Still need to free items in \"lp\"!\n */\n    char_u *\nget_lval(\n    char_u\t*name,\n    typval_T\t*rettv,\n    lval_T\t*lp,\n    int\t\tunlet,\n    int\t\tskip,\n    int\t\tflags,\t    // GLV_ values\n    int\t\tfne_flags)  // flags for find_name_end()\n{\n    char_u\t*p;\n    char_u\t*expr_start, *expr_end;\n    int\t\tcc;\n    dictitem_T\t*v;\n    typval_T\tvar1;\n    typval_T\tvar2;\n    int\t\tempty1 = FALSE;\n    char_u\t*key = NULL;\n    int\t\tlen;\n    hashtab_T\t*ht = NULL;\n    int\t\tquiet = flags & GLV_QUIET;\n    int\t\twriting;\n    int\t\tvim9script = in_vim9script();\n\n    // Clear everything in \"lp\".\n    CLEAR_POINTER(lp);\n\n    if (skip || (flags & GLV_COMPILING))\n    {\n\t// When skipping or compiling just find the end of the name.\n\tlp->ll_name = name;\n\tlp->ll_name_end = find_name_end(name, NULL, NULL,\n\t\t\t\t\t\t      FNE_INCL_BR | fne_flags);\n\treturn lp->ll_name_end;\n    }\n\n    // Cannot use \"s:var\" at the Vim9 script level.  \"s: type\" is OK.\n    if (vim9script && at_script_level()\n\t\t  && name[0] == 's' && name[1] == ':' && !VIM_ISWHITE(name[2]))\n    {\n\tsemsg(_(e_cannot_use_s_colon_in_vim9_script_str), name);\n\treturn NULL;\n    }\n\n    // Find the end of the name.\n    p = find_name_end(name, &expr_start, &expr_end, fne_flags);\n    lp->ll_name_end = p;\n    if (expr_start != NULL)\n    {\n\t// Don't expand the name when we already know there is an error.\n\tif (unlet && !VIM_ISWHITE(*p) && !ends_excmd(*p)\n\t\t\t\t\t\t    && *p != '[' && *p != '.')\n\t{\n\t    semsg(_(e_trailing_characters_str), p);\n\t    return NULL;\n\t}\n\n\tlp->ll_exp_name = make_expanded_name(name, expr_start, expr_end, p);\n\tif (lp->ll_exp_name == NULL)\n\t{\n\t    // Report an invalid expression in braces, unless the\n\t    // expression evaluation has been cancelled due to an\n\t    // aborting error, an interrupt, or an exception.\n\t    if (!aborting() && !quiet)\n\t    {\n\t\temsg_severe = TRUE;\n\t\tsemsg(_(e_invalid_argument_str), name);\n\t\treturn NULL;\n\t    }\n\t}\n\tlp->ll_name = lp->ll_exp_name;\n    }\n    else\n    {\n\tlp->ll_name = name;\n\n\tif (vim9script)\n\t{\n\t    // \"a: type\" is declaring variable \"a\" with a type, not \"a:\".\n\t    // However, \"g:[key]\" is indexing a dictionary.\n\t    if (p == name + 2 && p[-1] == ':' && *p != '[')\n\t    {\n\t\t--p;\n\t\tlp->ll_name_end = p;\n\t    }\n\t    if (*p == ':')\n\t    {\n\t\tchar_u\t    *tp = skipwhite(p + 1);\n\n\t\tif (tp == p + 1 && !quiet)\n\t\t{\n\t\t    semsg(_(e_white_space_required_after_str_str), \":\", p);\n\t\t    return NULL;\n\t\t}\n\n\t\tif (!SCRIPT_ID_VALID(current_sctx.sc_sid))\n\t\t{\n\t\t    semsg(_(e_using_type_not_in_script_context_str), p);\n\t\t    return NULL;\n\t\t}\n\n\t\t// parse the type after the name\n\t\tlp->ll_type = parse_type(&tp,\n\t\t\t       &SCRIPT_ITEM(current_sctx.sc_sid)->sn_type_list,\n\t\t\t       !quiet);\n\t\tif (lp->ll_type == NULL && !quiet)\n\t\t    return NULL;\n\t\tlp->ll_name_end = tp;\n\t    }\n\t}\n    }\n    if (lp->ll_name == NULL)\n\treturn p;\n\n    if (*p == '.')\n    {\n\timported_T *import = find_imported(lp->ll_name, p - lp->ll_name, TRUE);\n\n\tif (import != NULL)\n\t{\n\t    ufunc_T *ufunc;\n\t    type_T *type;\n\n\t    lp->ll_sid = import->imp_sid;\n\t    lp->ll_name = skipwhite(p + 1);\n\t    p = find_name_end(lp->ll_name, NULL, NULL, fne_flags);\n\t    lp->ll_name_end = p;\n\n\t    // check the item is exported\n\t    cc = *p;\n\t    *p = NUL;\n\t    if (find_exported(import->imp_sid, lp->ll_name, &ufunc, &type,\n\t\t\t\t\t\t       NULL, NULL, TRUE) == -1)\n\t    {\n\t\t*p = cc;\n\t\treturn NULL;\n\t    }\n\t    *p = cc;\n\t}\n    }\n\n    // Without [idx] or .key we are done.\n    if ((*p != '[' && *p != '.'))\n\treturn p;\n\n    if (vim9script && lval_root != NULL)\n    {\n\t// using local variable\n\tlp->ll_tv = lval_root;\n\tv = NULL;\n    }\n    else\n    {\n\tcc = *p;\n\t*p = NUL;\n\t// When we would write to the variable pass &ht and prevent autoload.\n\twriting = !(flags & GLV_READ_ONLY);\n\tv = find_var(lp->ll_name, writing ? &ht : NULL,\n\t\t\t\t\t (flags & GLV_NO_AUTOLOAD) || writing);\n\tif (v == NULL && !quiet)\n\t    semsg(_(e_undefined_variable_str), lp->ll_name);\n\t*p = cc;\n\tif (v == NULL)\n\t    return NULL;\n\tlp->ll_tv = &v->di_tv;\n    }\n\n    if (vim9script && (flags & GLV_NO_DECL) == 0)\n    {\n\tif (!quiet)\n\t    semsg(_(e_variable_already_declared), lp->ll_name);\n\treturn NULL;\n    }\n\n    /*\n     * Loop until no more [idx] or .key is following.\n     */\n    var1.v_type = VAR_UNKNOWN;\n    var2.v_type = VAR_UNKNOWN;\n    while (*p == '[' || (*p == '.' && p[1] != '=' && p[1] != '.'))\n    {\n\tif (*p == '.' && lp->ll_tv->v_type != VAR_DICT)\n\t{\n\t    if (!quiet)\n\t\tsemsg(_(e_dot_can_only_be_used_on_dictionary_str), name);\n\t    return NULL;\n\t}\n\tif (lp->ll_tv->v_type != VAR_LIST\n\t\t&& lp->ll_tv->v_type != VAR_DICT\n\t\t&& lp->ll_tv->v_type != VAR_BLOB)\n\t{\n\t    if (!quiet)\n\t\temsg(_(e_can_only_index_list_dictionary_or_blob));\n\t    return NULL;\n\t}\n\n\t// a NULL list/blob works like an empty list/blob, allocate one now.\n\tif (lp->ll_tv->v_type == VAR_LIST && lp->ll_tv->vval.v_list == NULL)\n\t    rettv_list_alloc(lp->ll_tv);\n\telse if (lp->ll_tv->v_type == VAR_BLOB\n\t\t\t\t\t     && lp->ll_tv->vval.v_blob == NULL)\n\t    rettv_blob_alloc(lp->ll_tv);\n\n\tif (lp->ll_range)\n\t{\n\t    if (!quiet)\n\t\temsg(_(e_slice_must_come_last));\n\t    return NULL;\n\t}\n\n\tif (vim9script && lp->ll_valtype == NULL\n\t\t&& v != NULL\n\t\t&& lp->ll_tv == &v->di_tv\n\t\t&& ht != NULL && ht == get_script_local_ht())\n\t{\n\t    svar_T  *sv = find_typval_in_script(lp->ll_tv, 0, TRUE);\n\n\t    // Vim9 script local variable: get the type\n\t    if (sv != NULL)\n\t\tlp->ll_valtype = sv->sv_type;\n\t}\n\n\tlen = -1;\n\tif (*p == '.')\n\t{\n\t    key = p + 1;\n\t    for (len = 0; ASCII_ISALNUM(key[len]) || key[len] == '_'; ++len)\n\t\t;\n\t    if (len == 0)\n\t    {\n\t\tif (!quiet)\n\t\t    emsg(_(e_cannot_use_empty_key_for_dictionary));\n\t\treturn NULL;\n\t    }\n\t    p = key + len;\n\t}\n\telse\n\t{\n\t    // Get the index [expr] or the first index [expr: ].\n\t    p = skipwhite(p + 1);\n\t    if (*p == ':')\n\t\tempty1 = TRUE;\n\t    else\n\t    {\n\t\tempty1 = FALSE;\n\t\tif (eval1(&p, &var1, &EVALARG_EVALUATE) == FAIL)  // recursive!\n\t\t    return NULL;\n\t\tif (tv_get_string_chk(&var1) == NULL)\n\t\t{\n\t\t    // not a number or string\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t\tp = skipwhite(p);\n\t    }\n\n\t    // Optionally get the second index [ :expr].\n\t    if (*p == ':')\n\t    {\n\t\tif (lp->ll_tv->v_type == VAR_DICT)\n\t\t{\n\t\t    if (!quiet)\n\t\t\temsg(_(e_cannot_slice_dictionary));\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t\tif (rettv != NULL\n\t\t\t&& !(rettv->v_type == VAR_LIST\n\t\t\t\t\t\t && rettv->vval.v_list != NULL)\n\t\t\t&& !(rettv->v_type == VAR_BLOB\n\t\t\t\t\t\t&& rettv->vval.v_blob != NULL))\n\t\t{\n\t\t    if (!quiet)\n\t\t\temsg(_(e_slice_requires_list_or_blob_value));\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t\tp = skipwhite(p + 1);\n\t\tif (*p == ']')\n\t\t    lp->ll_empty2 = TRUE;\n\t\telse\n\t\t{\n\t\t    lp->ll_empty2 = FALSE;\n\t\t    // recursive!\n\t\t    if (eval1(&p, &var2, &EVALARG_EVALUATE) == FAIL)\n\t\t    {\n\t\t\tclear_tv(&var1);\n\t\t\treturn NULL;\n\t\t    }\n\t\t    if (tv_get_string_chk(&var2) == NULL)\n\t\t    {\n\t\t\t// not a number or string\n\t\t\tclear_tv(&var1);\n\t\t\tclear_tv(&var2);\n\t\t\treturn NULL;\n\t\t    }\n\t\t}\n\t\tlp->ll_range = TRUE;\n\t    }\n\t    else\n\t\tlp->ll_range = FALSE;\n\n\t    if (*p != ']')\n\t    {\n\t\tif (!quiet)\n\t\t    emsg(_(e_missing_closing_square_brace));\n\t\tclear_tv(&var1);\n\t\tclear_tv(&var2);\n\t\treturn NULL;\n\t    }\n\n\t    // Skip to past ']'.\n\t    ++p;\n\t}\n\n\tif (lp->ll_tv->v_type == VAR_DICT)\n\t{\n\t    if (len == -1)\n\t    {\n\t\t// \"[key]\": get key from \"var1\"\n\t\tkey = tv_get_string_chk(&var1);\t// is number or string\n\t\tif (key == NULL)\n\t\t{\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t    }\n\t    lp->ll_list = NULL;\n\n\t    // a NULL dict is equivalent with an empty dict\n\t    if (lp->ll_tv->vval.v_dict == NULL)\n\t    {\n\t\tlp->ll_tv->vval.v_dict = dict_alloc();\n\t\tif (lp->ll_tv->vval.v_dict == NULL)\n\t\t{\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t\t++lp->ll_tv->vval.v_dict->dv_refcount;\n\t    }\n\t    lp->ll_dict = lp->ll_tv->vval.v_dict;\n\n\t    lp->ll_di = dict_find(lp->ll_dict, key, len);\n\n\t    // When assigning to a scope dictionary check that a function and\n\t    // variable name is valid (only variable name unless it is l: or\n\t    // g: dictionary). Disallow overwriting a builtin function.\n\t    if (rettv != NULL && lp->ll_dict->dv_scope != 0)\n\t    {\n\t\tint prevval;\n\t\tint wrong;\n\n\t\tif (len != -1)\n\t\t{\n\t\t    prevval = key[len];\n\t\t    key[len] = NUL;\n\t\t}\n\t\telse\n\t\t    prevval = 0; // avoid compiler warning\n\t\twrong = (lp->ll_dict->dv_scope == VAR_DEF_SCOPE\n\t\t\t       && rettv->v_type == VAR_FUNC\n\t\t\t       && var_wrong_func_name(key, lp->ll_di == NULL))\n\t\t\t|| !valid_varname(key, -1, TRUE);\n\t\tif (len != -1)\n\t\t    key[len] = prevval;\n\t\tif (wrong)\n\t\t{\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t    }\n\n\t    if (lp->ll_valtype != NULL)\n\t\t// use the type of the member\n\t\tlp->ll_valtype = lp->ll_valtype->tt_member;\n\n\t    if (lp->ll_di == NULL)\n\t    {\n\t\t// Can't add \"v:\" or \"a:\" variable.\n\t\tif (lp->ll_dict == get_vimvar_dict()\n\t\t\t || &lp->ll_dict->dv_hashtab == get_funccal_args_ht())\n\t\t{\n\t\t    semsg(_(e_illegal_variable_name_str), name);\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\n\t\t// Key does not exist in dict: may need to add it.\n\t\tif (*p == '[' || *p == '.' || unlet)\n\t\t{\n\t\t    if (!quiet)\n\t\t\tsemsg(_(e_key_not_present_in_dictionary), key);\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t\tif (len == -1)\n\t\t    lp->ll_newkey = vim_strsave(key);\n\t\telse\n\t\t    lp->ll_newkey = vim_strnsave(key, len);\n\t\tclear_tv(&var1);\n\t\tif (lp->ll_newkey == NULL)\n\t\t    p = NULL;\n\t\tbreak;\n\t    }\n\t    // existing variable, need to check if it can be changed\n\t    else if ((flags & GLV_READ_ONLY) == 0\n\t\t\t&& (var_check_ro(lp->ll_di->di_flags, name, FALSE)\n\t\t\t  || var_check_lock(lp->ll_di->di_flags, name, FALSE)))\n\t    {\n\t\tclear_tv(&var1);\n\t\treturn NULL;\n\t    }\n\n\t    clear_tv(&var1);\n\t    lp->ll_tv = &lp->ll_di->di_tv;\n\t}\n\telse if (lp->ll_tv->v_type == VAR_BLOB)\n\t{\n\t    long bloblen = blob_len(lp->ll_tv->vval.v_blob);\n\n\t    /*\n\t     * Get the number and item for the only or first index of the List.\n\t     */\n\t    if (empty1)\n\t\tlp->ll_n1 = 0;\n\t    else\n\t\t// is number or string\n\t\tlp->ll_n1 = (long)tv_get_number(&var1);\n\t    clear_tv(&var1);\n\n\t    if (check_blob_index(bloblen, lp->ll_n1, quiet) == FAIL)\n\t    {\n\t\tclear_tv(&var2);\n\t\treturn NULL;\n\t    }\n\t    if (lp->ll_range && !lp->ll_empty2)\n\t    {\n\t\tlp->ll_n2 = (long)tv_get_number(&var2);\n\t\tclear_tv(&var2);\n\t\tif (check_blob_range(bloblen, lp->ll_n1, lp->ll_n2, quiet)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\t    return NULL;\n\t    }\n\t    lp->ll_blob = lp->ll_tv->vval.v_blob;\n\t    lp->ll_tv = NULL;\n\t    break;\n\t}\n\telse\n\t{\n\t    /*\n\t     * Get the number and item for the only or first index of the List.\n\t     */\n\t    if (empty1)\n\t\tlp->ll_n1 = 0;\n\t    else\n\t\t// is number or string\n\t\tlp->ll_n1 = (long)tv_get_number(&var1);\n\t    clear_tv(&var1);\n\n\t    lp->ll_dict = NULL;\n\t    lp->ll_list = lp->ll_tv->vval.v_list;\n\t    lp->ll_li = check_range_index_one(lp->ll_list, &lp->ll_n1,\n\t\t\t\t     (flags & GLV_ASSIGN_WITH_OP) == 0, quiet);\n\t    if (lp->ll_li == NULL)\n\t    {\n\t\tclear_tv(&var2);\n\t\treturn NULL;\n\t    }\n\n\t    if (lp->ll_valtype != NULL)\n\t\t// use the type of the member\n\t\tlp->ll_valtype = lp->ll_valtype->tt_member;\n\n\t    /*\n\t     * May need to find the item or absolute index for the second\n\t     * index of a range.\n\t     * When no index given: \"lp->ll_empty2\" is TRUE.\n\t     * Otherwise \"lp->ll_n2\" is set to the second index.\n\t     */\n\t    if (lp->ll_range && !lp->ll_empty2)\n\t    {\n\t\tlp->ll_n2 = (long)tv_get_number(&var2);\n\t\t\t\t\t\t    // is number or string\n\t\tclear_tv(&var2);\n\t\tif (check_range_index_two(lp->ll_list,\n\t\t\t\t\t    &lp->ll_n1, lp->ll_li,\n\t\t\t\t\t    &lp->ll_n2, quiet) == FAIL)\n\t\t    return NULL;\n\t    }\n\n\t    lp->ll_tv = &lp->ll_li->li_tv;\n\t}\n    }\n\n    clear_tv(&var1);\n    lp->ll_name_end = p;\n    return p;\n}\n\n/*\n * Clear lval \"lp\" that was filled by get_lval().\n */\n    void\nclear_lval(lval_T *lp)\n{\n    vim_free(lp->ll_exp_name);\n    vim_free(lp->ll_newkey);\n}\n\n/*\n * Set a variable that was parsed by get_lval() to \"rettv\".\n * \"endp\" points to just after the parsed name.\n * \"op\" is NULL, \"+\" for \"+=\", \"-\" for \"-=\", \"*\" for \"*=\", \"/\" for \"/=\",\n * \"%\" for \"%=\", \".\" for \".=\" or \"=\" for \"=\".\n */\n    void\nset_var_lval(\n    lval_T\t*lp,\n    char_u\t*endp,\n    typval_T\t*rettv,\n    int\t\tcopy,\n    int\t\tflags,\t    // ASSIGN_CONST, ASSIGN_NO_DECL\n    char_u\t*op,\n    int\t\tvar_idx)    // index for \"let [a, b] = list\"\n{\n    int\t\tcc;\n    dictitem_T\t*di;\n\n    if (lp->ll_tv == NULL)\n    {\n\tcc = *endp;\n\t*endp = NUL;\n\tif (in_vim9script() && check_reserved_name(lp->ll_name) == FAIL)\n\t    return;\n\n\tif (lp->ll_blob != NULL)\n\t{\n\t    int\t    error = FALSE, val;\n\n\t    if (op != NULL && *op != '=')\n\t    {\n\t\tsemsg(_(e_wrong_variable_type_for_str_equal), op);\n\t\treturn;\n\t    }\n\t    if (value_check_lock(lp->ll_blob->bv_lock, lp->ll_name, FALSE))\n\t\treturn;\n\n\t    if (lp->ll_range && rettv->v_type == VAR_BLOB)\n\t    {\n\t\tif (lp->ll_empty2)\n\t\t    lp->ll_n2 = blob_len(lp->ll_blob) - 1;\n\n\t\tif (blob_set_range(lp->ll_blob, lp->ll_n1, lp->ll_n2,\n\t\t\t\t\t\t\t\trettv) == FAIL)\n\t\t    return;\n\t    }\n\t    else\n\t    {\n\t\tval = (int)tv_get_number_chk(rettv, &error);\n\t\tif (!error)\n\t\t    blob_set_append(lp->ll_blob, lp->ll_n1, val);\n\t    }\n\t}\n\telse if (op != NULL && *op != '=')\n\t{\n\t    typval_T tv;\n\n\t    if ((flags & (ASSIGN_CONST | ASSIGN_FINAL))\n\t\t\t\t\t     && (flags & ASSIGN_FOR_LOOP) == 0)\n\t    {\n\t\temsg(_(e_cannot_modify_existing_variable));\n\t\t*endp = cc;\n\t\treturn;\n\t    }\n\n\t    // handle +=, -=, *=, /=, %= and .=\n\t    di = NULL;\n\t    if (eval_variable(lp->ll_name, (int)STRLEN(lp->ll_name),\n\t\t\t\t lp->ll_sid, &tv, &di, EVAL_VAR_VERBOSE) == OK)\n\t    {\n\t\tif ((di == NULL\n\t\t\t || (!var_check_ro(di->di_flags, lp->ll_name, FALSE)\n\t\t\t   && !tv_check_lock(&di->di_tv, lp->ll_name, FALSE)))\n\t\t\t&& tv_op(&tv, rettv, op) == OK)\n\t\t    set_var_const(lp->ll_name, lp->ll_sid, NULL, &tv, FALSE,\n\t\t\t\t\t\t\t    ASSIGN_NO_DECL, 0);\n\t\tclear_tv(&tv);\n\t    }\n\t}\n\telse\n\t{\n\t    if (lp->ll_type != NULL && check_typval_arg_type(lp->ll_type, rettv,\n\t\t\t\t\t\t\t      NULL, 0) == FAIL)\n\t\treturn;\n\t    set_var_const(lp->ll_name, lp->ll_sid, lp->ll_type, rettv, copy,\n\t\t\t\t\t\t\t       flags, var_idx);\n\t}\n\t*endp = cc;\n    }\n    else if (value_check_lock(lp->ll_newkey == NULL\n\t\t? lp->ll_tv->v_lock\n\t\t: lp->ll_tv->vval.v_dict->dv_lock, lp->ll_name, FALSE))\n\t;\n    else if (lp->ll_range)\n    {\n\tif ((flags & (ASSIGN_CONST | ASSIGN_FINAL))\n\t\t\t\t\t     && (flags & ASSIGN_FOR_LOOP) == 0)\n\t{\n\t    emsg(_(e_cannot_lock_range));\n\t    return;\n\t}\n\n\t(void)list_assign_range(lp->ll_list, rettv->vval.v_list,\n\t\t\t lp->ll_n1, lp->ll_n2, lp->ll_empty2, op, lp->ll_name);\n    }\n    else\n    {\n\t/*\n\t * Assign to a List or Dictionary item.\n\t */\n\tif ((flags & (ASSIGN_CONST | ASSIGN_FINAL))\n\t\t\t\t\t     && (flags & ASSIGN_FOR_LOOP) == 0)\n\t{\n\t    emsg(_(e_cannot_lock_list_or_dict));\n\t    return;\n\t}\n\n\tif (lp->ll_valtype != NULL\n\t\t    && check_typval_arg_type(lp->ll_valtype, rettv,\n\t\t\t\t\t\t\t      NULL, 0) == FAIL)\n\t    return;\n\n\tif (lp->ll_newkey != NULL)\n\t{\n\t    if (op != NULL && *op != '=')\n\t    {\n\t\tsemsg(_(e_key_not_present_in_dictionary), lp->ll_newkey);\n\t\treturn;\n\t    }\n\t    if (dict_wrong_func_name(lp->ll_tv->vval.v_dict, rettv,\n\t\t\t\t\t\t\t\tlp->ll_newkey))\n\t\treturn;\n\n\t    // Need to add an item to the Dictionary.\n\t    di = dictitem_alloc(lp->ll_newkey);\n\t    if (di == NULL)\n\t\treturn;\n\t    if (dict_add(lp->ll_tv->vval.v_dict, di) == FAIL)\n\t    {\n\t\tvim_free(di);\n\t\treturn;\n\t    }\n\t    lp->ll_tv = &di->di_tv;\n\t}\n\telse if (op != NULL && *op != '=')\n\t{\n\t    tv_op(lp->ll_tv, rettv, op);\n\t    return;\n\t}\n\telse\n\t    clear_tv(lp->ll_tv);\n\n\t/*\n\t * Assign the value to the variable or list item.\n\t */\n\tif (copy)\n\t    copy_tv(rettv, lp->ll_tv);\n\telse\n\t{\n\t    *lp->ll_tv = *rettv;\n\t    lp->ll_tv->v_lock = 0;\n\t    init_tv(rettv);\n\t}\n    }\n}\n\n/*\n * Handle \"tv1 += tv2\", \"tv1 -= tv2\", \"tv1 *= tv2\", \"tv1 /= tv2\", \"tv1 %= tv2\"\n * and \"tv1 .= tv2\"\n * Returns OK or FAIL.\n */\n    int\ntv_op(typval_T *tv1, typval_T *tv2, char_u *op)\n{\n    varnumber_T\tn;\n    char_u\tnumbuf[NUMBUFLEN];\n    char_u\t*s;\n    int\t\tfailed = FALSE;\n\n    // Can't do anything with a Funcref or Dict on the right.\n    // v:true and friends only work with \"..=\".\n    if (tv2->v_type != VAR_FUNC && tv2->v_type != VAR_DICT\n\t\t    && ((tv2->v_type != VAR_BOOL && tv2->v_type != VAR_SPECIAL)\n\t\t\t\t\t\t\t\t|| *op == '.'))\n    {\n\tswitch (tv1->v_type)\n\t{\n\t    case VAR_UNKNOWN:\n\t    case VAR_ANY:\n\t    case VAR_VOID:\n\t    case VAR_DICT:\n\t    case VAR_FUNC:\n\t    case VAR_PARTIAL:\n\t    case VAR_BOOL:\n\t    case VAR_SPECIAL:\n\t    case VAR_JOB:\n\t    case VAR_CHANNEL:\n\t    case VAR_INSTR:\n\t\tbreak;\n\n\t    case VAR_BLOB:\n\t\tif (*op != '+' || tv2->v_type != VAR_BLOB)\n\t\t    break;\n\t\t// BLOB += BLOB\n\t\tif (tv1->vval.v_blob != NULL && tv2->vval.v_blob != NULL)\n\t\t{\n\t\t    blob_T  *b1 = tv1->vval.v_blob;\n\t\t    blob_T  *b2 = tv2->vval.v_blob;\n\t\t    int\ti, len = blob_len(b2);\n\t\t    for (i = 0; i < len; i++)\n\t\t\tga_append(&b1->bv_ga, blob_get(b2, i));\n\t\t}\n\t\treturn OK;\n\n\t    case VAR_LIST:\n\t\tif (*op != '+' || tv2->v_type != VAR_LIST)\n\t\t    break;\n\t\t// List += List\n\t\tif (tv2->vval.v_list != NULL)\n\t\t{\n\t\t    if (tv1->vval.v_list == NULL)\n\t\t    {\n\t\t\ttv1->vval.v_list = tv2->vval.v_list;\n\t\t\t++tv1->vval.v_list->lv_refcount;\n\t\t    }\n\t\t    else\n\t\t\tlist_extend(tv1->vval.v_list, tv2->vval.v_list, NULL);\n\t\t}\n\t\treturn OK;\n\n\t    case VAR_NUMBER:\n\t    case VAR_STRING:\n\t\tif (tv2->v_type == VAR_LIST)\n\t\t    break;\n\t\tif (vim_strchr((char_u *)\"+-*/%\", *op) != NULL)\n\t\t{\n\t\t    // nr += nr , nr -= nr , nr *=nr , nr /= nr , nr %= nr\n\t\t    n = tv_get_number(tv1);\n#ifdef FEAT_FLOAT\n\t\t    if (tv2->v_type == VAR_FLOAT)\n\t\t    {\n\t\t\tfloat_T f = n;\n\n\t\t\tif (*op == '%')\n\t\t\t    break;\n\t\t\tswitch (*op)\n\t\t\t{\n\t\t\t    case '+': f += tv2->vval.v_float; break;\n\t\t\t    case '-': f -= tv2->vval.v_float; break;\n\t\t\t    case '*': f *= tv2->vval.v_float; break;\n\t\t\t    case '/': f /= tv2->vval.v_float; break;\n\t\t\t}\n\t\t\tclear_tv(tv1);\n\t\t\ttv1->v_type = VAR_FLOAT;\n\t\t\ttv1->vval.v_float = f;\n\t\t    }\n\t\t    else\n#endif\n\t\t    {\n\t\t\tswitch (*op)\n\t\t\t{\n\t\t\t    case '+': n += tv_get_number(tv2); break;\n\t\t\t    case '-': n -= tv_get_number(tv2); break;\n\t\t\t    case '*': n *= tv_get_number(tv2); break;\n\t\t\t    case '/': n = num_divide(n, tv_get_number(tv2),\n\t\t\t\t\t\t\t       &failed); break;\n\t\t\t    case '%': n = num_modulus(n, tv_get_number(tv2),\n\t\t\t\t\t\t\t       &failed); break;\n\t\t\t}\n\t\t\tclear_tv(tv1);\n\t\t\ttv1->v_type = VAR_NUMBER;\n\t\t\ttv1->vval.v_number = n;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (tv2->v_type == VAR_FLOAT)\n\t\t\tbreak;\n\n\t\t    // str .= str\n\t\t    s = tv_get_string(tv1);\n\t\t    s = concat_str(s, tv_get_string_buf(tv2, numbuf));\n\t\t    clear_tv(tv1);\n\t\t    tv1->v_type = VAR_STRING;\n\t\t    tv1->vval.v_string = s;\n\t\t}\n\t\treturn failed ? FAIL : OK;\n\n\t    case VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t\t{\n\t\t    float_T f;\n\n\t\t    if (*op == '%' || *op == '.'\n\t\t\t\t   || (tv2->v_type != VAR_FLOAT\n\t\t\t\t    && tv2->v_type != VAR_NUMBER\n\t\t\t\t    && tv2->v_type != VAR_STRING))\n\t\t\tbreak;\n\t\t    if (tv2->v_type == VAR_FLOAT)\n\t\t\tf = tv2->vval.v_float;\n\t\t    else\n\t\t\tf = tv_get_number(tv2);\n\t\t    switch (*op)\n\t\t    {\n\t\t\tcase '+': tv1->vval.v_float += f; break;\n\t\t\tcase '-': tv1->vval.v_float -= f; break;\n\t\t\tcase '*': tv1->vval.v_float *= f; break;\n\t\t\tcase '/': tv1->vval.v_float /= f; break;\n\t\t    }\n\t\t}\n#endif\n\t\treturn OK;\n\t}\n    }\n\n    semsg(_(e_wrong_variable_type_for_str_equal), op);\n    return FAIL;\n}\n\n/*\n * Evaluate the expression used in a \":for var in expr\" command.\n * \"arg\" points to \"var\".\n * Set \"*errp\" to TRUE for an error, FALSE otherwise;\n * Return a pointer that holds the info.  Null when there is an error.\n */\n    void *\neval_for_line(\n    char_u\t*arg,\n    int\t\t*errp,\n    exarg_T\t*eap,\n    evalarg_T\t*evalarg)\n{\n    forinfo_T\t*fi;\n    char_u\t*var_list_end;\n    char_u\t*expr;\n    typval_T\ttv;\n    list_T\t*l;\n    int\t\tskip = !(evalarg->eval_flags & EVAL_EVALUATE);\n\n    *errp = TRUE;\t// default: there is an error\n\n    fi = ALLOC_CLEAR_ONE(forinfo_T);\n    if (fi == NULL)\n\treturn NULL;\n\n    var_list_end = skip_var_list(arg, TRUE, &fi->fi_varcount,\n\t\t\t\t\t\t     &fi->fi_semicolon, FALSE);\n    if (var_list_end == NULL)\n\treturn fi;\n\n    expr = skipwhite_and_linebreak(var_list_end, evalarg);\n    if (expr[0] != 'i' || expr[1] != 'n'\n\t\t\t\t  || !(expr[2] == NUL || VIM_ISWHITE(expr[2])))\n    {\n\tif (in_vim9script() && *expr == ':' && expr != var_list_end)\n\t    semsg(_(e_no_white_space_allowed_before_colon_str), expr);\n\telse\n\t    emsg(_(e_missing_in_after_for));\n\treturn fi;\n    }\n\n    if (skip)\n\t++emsg_skip;\n    expr = skipwhite_and_linebreak(expr + 2, evalarg);\n    if (eval0(expr, &tv, eap, evalarg) == OK)\n    {\n\t*errp = FALSE;\n\tif (!skip)\n\t{\n\t    if (tv.v_type == VAR_LIST)\n\t    {\n\t\tl = tv.vval.v_list;\n\t\tif (l == NULL)\n\t\t{\n\t\t    // a null list is like an empty list: do nothing\n\t\t    clear_tv(&tv);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Need a real list here.\n\t\t    CHECK_LIST_MATERIALIZE(l);\n\n\t\t    // No need to increment the refcount, it's already set for\n\t\t    // the list being used in \"tv\".\n\t\t    fi->fi_list = l;\n\t\t    list_add_watch(l, &fi->fi_lw);\n\t\t    fi->fi_lw.lw_item = l->lv_first;\n\t\t}\n\t    }\n\t    else if (tv.v_type == VAR_BLOB)\n\t    {\n\t\tfi->fi_bi = 0;\n\t\tif (tv.vval.v_blob != NULL)\n\t\t{\n\t\t    typval_T btv;\n\n\t\t    // Make a copy, so that the iteration still works when the\n\t\t    // blob is changed.\n\t\t    blob_copy(tv.vval.v_blob, &btv);\n\t\t    fi->fi_blob = btv.vval.v_blob;\n\t\t}\n\t\tclear_tv(&tv);\n\t    }\n\t    else if (tv.v_type == VAR_STRING)\n\t    {\n\t\tfi->fi_byte_idx = 0;\n\t\tfi->fi_string = tv.vval.v_string;\n\t\ttv.vval.v_string = NULL;\n\t\tif (fi->fi_string == NULL)\n\t\t    fi->fi_string = vim_strsave((char_u *)\"\");\n\t    }\n\t    else\n\t    {\n\t\temsg(_(e_string_list_or_blob_required));\n\t\tclear_tv(&tv);\n\t    }\n\t}\n    }\n    if (skip)\n\t--emsg_skip;\n    fi->fi_break_count = evalarg->eval_break_count;\n\n    return fi;\n}\n\n/*\n * Used when looping over a :for line, skip the \"in expr\" part.\n */\n    void\nskip_for_lines(void *fi_void, evalarg_T *evalarg)\n{\n    forinfo_T\t*fi = (forinfo_T *)fi_void;\n    int\t\ti;\n\n    for (i = 0; i < fi->fi_break_count; ++i)\n\teval_next_line(NULL, evalarg);\n}\n\n/*\n * Use the first item in a \":for\" list.  Advance to the next.\n * Assign the values to the variable (list).  \"arg\" points to the first one.\n * Return TRUE when a valid item was found, FALSE when at end of list or\n * something wrong.\n */\n    int\nnext_for_item(void *fi_void, char_u *arg)\n{\n    forinfo_T\t*fi = (forinfo_T *)fi_void;\n    int\t\tresult;\n    int\t\tflag = ASSIGN_FOR_LOOP | (in_vim9script()\n\t\t\t ? (ASSIGN_FINAL\n\t\t\t     // first round: error if variable exists\n\t\t\t     | (fi->fi_bi == 0 ? 0 : ASSIGN_DECL)\n\t\t\t     | ASSIGN_NO_MEMBER_TYPE)\n\t\t\t : 0);\n    listitem_T\t*item;\n    int\t\tskip_assign = in_vim9script() && arg[0] == '_'\n\t\t\t\t\t\t      && !eval_isnamec(arg[1]);\n\n    if (fi->fi_blob != NULL)\n    {\n\ttypval_T\ttv;\n\n\tif (fi->fi_bi >= blob_len(fi->fi_blob))\n\t    return FALSE;\n\ttv.v_type = VAR_NUMBER;\n\ttv.v_lock = VAR_FIXED;\n\ttv.vval.v_number = blob_get(fi->fi_blob, fi->fi_bi);\n\t++fi->fi_bi;\n\tif (skip_assign)\n\t    return TRUE;\n\treturn ex_let_vars(arg, &tv, TRUE, fi->fi_semicolon,\n\t\t\t\t\t    fi->fi_varcount, flag, NULL) == OK;\n    }\n\n    if (fi->fi_string != NULL)\n    {\n\ttypval_T\ttv;\n\tint\t\tlen;\n\n\tlen = mb_ptr2len(fi->fi_string + fi->fi_byte_idx);\n\tif (len == 0)\n\t    return FALSE;\n\ttv.v_type = VAR_STRING;\n\ttv.v_lock = VAR_FIXED;\n\ttv.vval.v_string = vim_strnsave(fi->fi_string + fi->fi_byte_idx, len);\n\tfi->fi_byte_idx += len;\n\t++fi->fi_bi;\n\tif (skip_assign)\n\t    result = TRUE;\n\telse\n\t    result = ex_let_vars(arg, &tv, TRUE, fi->fi_semicolon,\n\t\t\t\t\t    fi->fi_varcount, flag, NULL) == OK;\n\tvim_free(tv.vval.v_string);\n\treturn result;\n    }\n\n    item = fi->fi_lw.lw_item;\n    if (item == NULL)\n\tresult = FALSE;\n    else\n    {\n\tfi->fi_lw.lw_item = item->li_next;\n\t++fi->fi_bi;\n\tif (skip_assign)\n\t    result = TRUE;\n\telse\n\t    result = (ex_let_vars(arg, &item->li_tv, TRUE, fi->fi_semicolon,\n\t\t\t\t\t   fi->fi_varcount, flag, NULL) == OK);\n    }\n    return result;\n}\n\n/*\n * Free the structure used to store info used by \":for\".\n */\n    void\nfree_for_info(void *fi_void)\n{\n    forinfo_T    *fi = (forinfo_T *)fi_void;\n\n    if (fi == NULL)\n\treturn;\n    if (fi->fi_list != NULL)\n    {\n\tlist_rem_watch(fi->fi_list, &fi->fi_lw);\n\tlist_unref(fi->fi_list);\n    }\n    else if (fi->fi_blob != NULL)\n\tblob_unref(fi->fi_blob);\n    else\n\tvim_free(fi->fi_string);\n    vim_free(fi);\n}\n\n    void\nset_context_for_expression(\n    expand_T\t*xp,\n    char_u\t*arg,\n    cmdidx_T\tcmdidx)\n{\n    int\t\thas_expr = cmdidx != CMD_let && cmdidx != CMD_var;\n    int\t\tc;\n    char_u\t*p;\n\n    if (cmdidx == CMD_let || cmdidx == CMD_var\n\t\t\t\t || cmdidx == CMD_const || cmdidx == CMD_final)\n    {\n\txp->xp_context = EXPAND_USER_VARS;\n\tif (vim_strpbrk(arg, (char_u *)\"\\\"'+-*/%.=!?~|&$([<>,#\") == NULL)\n\t{\n\t    // \":let var1 var2 ...\": find last space.\n\t    for (p = arg + STRLEN(arg); p >= arg; )\n\t    {\n\t\txp->xp_pattern = p;\n\t\tMB_PTR_BACK(arg, p);\n\t\tif (VIM_ISWHITE(*p))\n\t\t    break;\n\t    }\n\t    return;\n\t}\n    }\n    else\n\txp->xp_context = cmdidx == CMD_call ? EXPAND_FUNCTIONS\n\t\t\t\t\t\t\t  : EXPAND_EXPRESSION;\n    while ((xp->xp_pattern = vim_strpbrk(arg,\n\t\t\t\t  (char_u *)\"\\\"'+-*/%.=!?~|&$([<>,#\")) != NULL)\n    {\n\tc = *xp->xp_pattern;\n\tif (c == '&')\n\t{\n\t    c = xp->xp_pattern[1];\n\t    if (c == '&')\n\t    {\n\t\t++xp->xp_pattern;\n\t\txp->xp_context = has_expr ? EXPAND_EXPRESSION : EXPAND_NOTHING;\n\t    }\n\t    else if (c != ' ')\n\t    {\n\t\txp->xp_context = EXPAND_SETTINGS;\n\t\tif ((c == 'l' || c == 'g') && xp->xp_pattern[2] == ':')\n\t\t    xp->xp_pattern += 2;\n\n\t    }\n\t}\n\telse if (c == '$')\n\t{\n\t    // environment variable\n\t    xp->xp_context = EXPAND_ENV_VARS;\n\t}\n\telse if (c == '=')\n\t{\n\t    has_expr = TRUE;\n\t    xp->xp_context = EXPAND_EXPRESSION;\n\t}\n\telse if (c == '#'\n\t\t&& xp->xp_context == EXPAND_EXPRESSION)\n\t{\n\t    // Autoload function/variable contains '#'.\n\t    break;\n\t}\n\telse if ((c == '<' || c == '#')\n\t\t&& xp->xp_context == EXPAND_FUNCTIONS\n\t\t&& vim_strchr(xp->xp_pattern, '(') == NULL)\n\t{\n\t    // Function name can start with \"<SNR>\" and contain '#'.\n\t    break;\n\t}\n\telse if (has_expr)\n\t{\n\t    if (c == '\"')\t    // string\n\t    {\n\t\twhile ((c = *++xp->xp_pattern) != NUL && c != '\"')\n\t\t    if (c == '\\\\' && xp->xp_pattern[1] != NUL)\n\t\t\t++xp->xp_pattern;\n\t\txp->xp_context = EXPAND_NOTHING;\n\t    }\n\t    else if (c == '\\'')\t    // literal string\n\t    {\n\t\t// Trick: '' is like stopping and starting a literal string.\n\t\twhile ((c = *++xp->xp_pattern) != NUL && c != '\\'')\n\t\t    /* skip */ ;\n\t\txp->xp_context = EXPAND_NOTHING;\n\t    }\n\t    else if (c == '|')\n\t    {\n\t\tif (xp->xp_pattern[1] == '|')\n\t\t{\n\t\t    ++xp->xp_pattern;\n\t\t    xp->xp_context = EXPAND_EXPRESSION;\n\t\t}\n\t\telse\n\t\t    xp->xp_context = EXPAND_COMMANDS;\n\t    }\n\t    else\n\t\txp->xp_context = EXPAND_EXPRESSION;\n\t}\n\telse\n\t    // Doesn't look like something valid, expand as an expression\n\t    // anyway.\n\t    xp->xp_context = EXPAND_EXPRESSION;\n\targ = xp->xp_pattern;\n\tif (*arg != NUL)\n\t    while ((c = *++arg) != NUL && (c == ' ' || c == '\\t'))\n\t\t/* skip */ ;\n    }\n\n    // \":exe one two\" completes \"two\"\n    if ((cmdidx == CMD_execute\n\t\t|| cmdidx == CMD_echo\n\t\t|| cmdidx == CMD_echon\n\t\t|| cmdidx == CMD_echomsg)\n\t    && xp->xp_context == EXPAND_EXPRESSION)\n    {\n\tfor (;;)\n\t{\n\t    char_u *n = skiptowhite(arg);\n\n\t    if (n == arg || IS_WHITE_OR_NUL(*skipwhite(n)))\n\t\tbreak;\n\t    arg = skipwhite(n);\n\t}\n    }\n\n    xp->xp_pattern = arg;\n}\n\n/*\n * Return TRUE if \"pat\" matches \"text\".\n * Does not use 'cpo' and always uses 'magic'.\n */\n    int\npattern_match(char_u *pat, char_u *text, int ic)\n{\n    int\t\tmatches = FALSE;\n    char_u\t*save_cpo;\n    regmatch_T\tregmatch;\n\n    // avoid 'l' flag in 'cpoptions'\n    save_cpo = p_cpo;\n    p_cpo = empty_option;\n    regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);\n    if (regmatch.regprog != NULL)\n    {\n\tregmatch.rm_ic = ic;\n\tmatches = vim_regexec_nl(&regmatch, text, (colnr_T)0);\n\tvim_regfree(regmatch.regprog);\n    }\n    p_cpo = save_cpo;\n    return matches;\n}\n\n/*\n * Handle a name followed by \"(\".  Both for just \"name(arg)\" and for\n * \"expr->name(arg)\".\n * Returns OK or FAIL.\n */\n    static int\neval_func(\n\tchar_u\t    **arg,\t// points to \"(\", will be advanced\n\tevalarg_T   *evalarg,\n\tchar_u\t    *name,\n\tint\t    name_len,\n\ttypval_T    *rettv,\n\tint\t    flags,\n\ttypval_T    *basetv)\t// \"expr\" for \"expr->name(arg)\"\n{\n    int\t\tevaluate = flags & EVAL_EVALUATE;\n    char_u\t*s = name;\n    int\t\tlen = name_len;\n    partial_T\t*partial;\n    int\t\tret = OK;\n    type_T\t*type = NULL;\n    int\t\tfound_var = FALSE;\n\n    if (!evaluate)\n\tcheck_vars(s, len);\n\n    // If \"s\" is the name of a variable of type VAR_FUNC\n    // use its contents.\n    s = deref_func_name(s, &len, &partial,\n\t\t in_vim9script() ? &type : NULL, !evaluate, FALSE, &found_var);\n\n    // Need to make a copy, in case evaluating the arguments makes\n    // the name invalid.\n    s = vim_strsave(s);\n    if (s == NULL || (evaluate && (*s == NUL || (flags & EVAL_CONSTANT))))\n\tret = FAIL;\n    else\n    {\n\tfuncexe_T funcexe;\n\n\t// Invoke the function.\n\tCLEAR_FIELD(funcexe);\n\tfuncexe.fe_firstline = curwin->w_cursor.lnum;\n\tfuncexe.fe_lastline = curwin->w_cursor.lnum;\n\tfuncexe.fe_evaluate = evaluate;\n\tfuncexe.fe_partial = partial;\n\tfuncexe.fe_basetv = basetv;\n\tfuncexe.fe_check_type = type;\n\tfuncexe.fe_found_var = found_var;\n\tret = get_func_tv(s, len, rettv, arg, evalarg, &funcexe);\n    }\n    vim_free(s);\n\n    // If evaluate is FALSE rettv->v_type was not set in\n    // get_func_tv, but it's needed in handle_subscript() to parse\n    // what follows. So set it here.\n    if (rettv->v_type == VAR_UNKNOWN && !evaluate && **arg == '(')\n    {\n\trettv->vval.v_string = NULL;\n\trettv->v_type = VAR_FUNC;\n    }\n\n    // Stop the expression evaluation when immediately\n    // aborting on error, or when an interrupt occurred or\n    // an exception was thrown but not caught.\n    if (evaluate && aborting())\n    {\n\tif (ret == OK)\n\t    clear_tv(rettv);\n\tret = FAIL;\n    }\n    return ret;\n}\n\n/*\n * After a NL, skip over empty lines and comment-only lines.\n */\n    static char_u *\nnewline_skip_comments(char_u *arg)\n{\n    char_u *p = arg + 1;\n\n    for (;;)\n    {\n\tp = skipwhite(p);\n\n\tif (*p == NUL)\n\t    break;\n\tif (vim9_comment_start(p))\n\t{\n\t    char_u *nl = vim_strchr(p, NL);\n\n\t    if (nl == NULL)\n\t\t    break;\n\t    p = nl;\n\t}\n\tif (*p != NL)\n\t    break;\n\t++p;  // skip another NL\n    }\n    return p;\n}\n\n/*\n * Get the next line source line without advancing.  But do skip over comment\n * lines.\n * Only called for Vim9 script.\n */\n    static char_u *\ngetline_peek_skip_comments(evalarg_T *evalarg)\n{\n    for (;;)\n    {\n\tchar_u *next = getline_peek(evalarg->eval_getline,\n\t\t\t\t\t\t\t evalarg->eval_cookie);\n\tchar_u *p;\n\n\tif (next == NULL)\n\t    break;\n\tp = skipwhite(next);\n\tif (*p != NUL && !vim9_comment_start(p))\n\t    return next;\n\tif (eval_next_line(NULL, evalarg) == NULL)\n\t    break;\n    }\n    return NULL;\n}\n\n/*\n * If inside Vim9 script, \"arg\" points to the end of a line (ignoring a #\n * comment) and there is a next line, return the next line (skipping blanks)\n * and set \"getnext\".\n * Otherwise return the next non-white at or after \"arg\" and set \"getnext\" to\n * FALSE.\n * \"arg\" must point somewhere inside a line, not at the start.\n */\n    char_u *\neval_next_non_blank(char_u *arg, evalarg_T *evalarg, int *getnext)\n{\n    char_u *p = skipwhite(arg);\n\n    *getnext = FALSE;\n    if (in_vim9script()\n\t    && evalarg != NULL\n\t    && (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL\n\t\t\t\t\t\t\t\t   || *p == NL)\n\t    && (*p == NUL || *p == NL\n\t\t\t     || (vim9_comment_start(p) && VIM_ISWHITE(p[-1]))))\n    {\n\tchar_u *next;\n\n\tif (*p == NL)\n\t    next = newline_skip_comments(p);\n\telse if (evalarg->eval_cookie != NULL)\n\t    next = getline_peek_skip_comments(evalarg);\n\telse\n\t    next = peek_next_line_from_context(evalarg->eval_cctx);\n\n\tif (next != NULL)\n\t{\n\t    *getnext = TRUE;\n\t    return skipwhite(next);\n\t}\n    }\n    return p;\n}\n\n/*\n * To be called after eval_next_non_blank() sets \"getnext\" to TRUE.\n * Only called for Vim9 script.\n */\n    char_u *\neval_next_line(char_u *arg, evalarg_T *evalarg)\n{\n    garray_T\t*gap = &evalarg->eval_ga;\n    char_u\t*line;\n\n    if (arg != NULL)\n    {\n\tif (*arg == NL)\n\t    return newline_skip_comments(arg);\n\t// Truncate before a trailing comment, so that concatenating the lines\n\t// won't turn the rest into a comment.\n\tif (*skipwhite(arg) == '#')\n\t    *arg = NUL;\n    }\n\n    if (evalarg->eval_cookie != NULL)\n\tline = evalarg->eval_getline(0, evalarg->eval_cookie, 0,\n\t\t\t\t\t\t\t   GETLINE_CONCAT_ALL);\n    else\n\tline = next_line_from_context(evalarg->eval_cctx, TRUE);\n    if (line == NULL)\n\treturn NULL;\n\n    ++evalarg->eval_break_count;\n    if (gap->ga_itemsize > 0 && ga_grow(gap, 1) == OK)\n    {\n\tchar_u *p = skipwhite(line);\n\n\t// Going to concatenate the lines after parsing.  For an empty or\n\t// comment line use an empty string.\n\tif (*p == NUL || vim9_comment_start(p))\n\t{\n\t    vim_free(line);\n\t    line = vim_strsave((char_u *)\"\");\n\t}\n\n\t((char_u **)gap->ga_data)[gap->ga_len] = line;\n\t++gap->ga_len;\n    }\n    else if (evalarg->eval_cookie != NULL)\n    {\n\tvim_free(evalarg->eval_tofree);\n\tevalarg->eval_tofree = line;\n    }\n\n    // Advanced to the next line, \"arg\" no longer points into the previous\n    // line.\n    evalarg->eval_using_cmdline = FALSE;\n    return skipwhite(line);\n}\n\n/*\n * Call eval_next_non_blank() and get the next line if needed.\n */\n    char_u *\nskipwhite_and_linebreak(char_u *arg, evalarg_T *evalarg)\n{\n    int\t    getnext;\n    char_u  *p = skipwhite_and_nl(arg);\n\n    if (evalarg == NULL)\n\treturn skipwhite(arg);\n    eval_next_non_blank(p, evalarg, &getnext);\n    if (getnext)\n\treturn eval_next_line(arg, evalarg);\n    return p;\n}\n\n/*\n * Initialize \"evalarg\" for use.\n */\n    void\ninit_evalarg(evalarg_T *evalarg)\n{\n    CLEAR_POINTER(evalarg);\n    ga_init2(&evalarg->eval_tofree_ga, sizeof(char_u *), 20);\n}\n\n/*\n * After using \"evalarg\" filled from \"eap\": free the memory.\n */\n    void\nclear_evalarg(evalarg_T *evalarg, exarg_T *eap)\n{\n    if (evalarg != NULL)\n    {\n\tif (evalarg->eval_tofree != NULL)\n\t{\n\t    if (eap != NULL)\n\t    {\n\t\t// We may need to keep the original command line, e.g. for\n\t\t// \":let\" it has the variable names.  But we may also need the\n\t\t// new one, \"nextcmd\" points into it.  Keep both.\n\t\tvim_free(eap->cmdline_tofree);\n\t\teap->cmdline_tofree = *eap->cmdlinep;\n\t\t*eap->cmdlinep = evalarg->eval_tofree;\n\t    }\n\t    else\n\t\tvim_free(evalarg->eval_tofree);\n\t    evalarg->eval_tofree = NULL;\n\t}\n\n\tga_clear_strings(&evalarg->eval_tofree_ga);\n\tVIM_CLEAR(evalarg->eval_tofree_lambda);\n    }\n}\n\n/*\n * The \"evaluate\" argument: When FALSE, the argument is only parsed but not\n * executed.  The function may return OK, but the rettv will be of type\n * VAR_UNKNOWN.  The function still returns FAIL for a syntax error.\n */\n\n/*\n * Handle zero level expression.\n * This calls eval1() and handles error message and nextcmd.\n * Put the result in \"rettv\" when returning OK and \"evaluate\" is TRUE.\n * Note: \"rettv.v_lock\" is not set.\n * \"evalarg\" can be NULL, EVALARG_EVALUATE or a pointer.\n * Return OK or FAIL.\n */\n    int\neval0(\n    char_u\t*arg,\n    typval_T\t*rettv,\n    exarg_T\t*eap,\n    evalarg_T\t*evalarg)\n{\n    return eval0_retarg(arg, rettv, eap, evalarg, NULL);\n}\n\n/*\n * Like eval0() but when \"retarg\" is not NULL store the pointer to after the\n * expression and don't check what comes after the expression.\n */\n    int\neval0_retarg(\n    char_u\t*arg,\n    typval_T\t*rettv,\n    exarg_T\t*eap,\n    evalarg_T\t*evalarg,\n    char_u\t**retarg)\n{\n    int\t\tret;\n    char_u\t*p;\n    char_u\t*expr_end;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tcalled_emsg_before = called_emsg;\n    int\t\tflags = evalarg == NULL ? 0 : evalarg->eval_flags;\n    int\t\tcheck_for_end = retarg == NULL;\n    int\t\tend_error = FALSE;\n\n    p = skipwhite(arg);\n    ret = eval1(&p, rettv, evalarg);\n    expr_end = p;\n    p = skipwhite(p);\n\n    // In Vim9 script a command block is not split at NL characters for\n    // commands using an expression argument.  Skip over a '#' comment to check\n    // for a following NL.  Require white space before the '#'.\n    if (in_vim9script() && p > expr_end && retarg == NULL)\n\twhile (*p == '#')\n\t{\n\t    char_u *nl = vim_strchr(p, NL);\n\n\t    if (nl == NULL)\n\t\tbreak;\n\t    p = skipwhite(nl + 1);\n\t    if (eap != NULL && *p != NUL)\n\t\teap->nextcmd = p;\n\t    check_for_end = FALSE;\n\t}\n\n    if (ret != FAIL && check_for_end)\n\tend_error = !ends_excmd2(arg, p);\n    if (ret == FAIL || end_error)\n    {\n\tif (ret != FAIL)\n\t    clear_tv(rettv);\n\t/*\n\t * Report the invalid expression unless the expression evaluation has\n\t * been cancelled due to an aborting error, an interrupt, or an\n\t * exception, or we already gave a more specific error.\n\t * Also check called_emsg for when using assert_fails().\n\t */\n\tif (!aborting()\n\t\t&& did_emsg == did_emsg_before\n\t\t&& called_emsg == called_emsg_before\n\t\t&& (flags & EVAL_CONSTANT) == 0\n\t\t&& (!in_vim9script() || !vim9_bad_comment(p)))\n\t{\n\t    if (end_error)\n\t\tsemsg(_(e_trailing_characters_str), p);\n\t    else\n\t\tsemsg(_(e_invalid_expression_str), arg);\n\t}\n\n\t// Some of the expression may not have been consumed.  Do not check for\n\t// a next command to avoid more errors, unless \"|\" is following, which\n\t// could only be a command separator.\n\tif (eap != NULL && skipwhite(p)[0] == '|' && skipwhite(p)[1] != '|')\n\t    eap->nextcmd = check_nextcmd(p);\n\treturn FAIL;\n    }\n\n    if (retarg != NULL)\n\t*retarg = p;\n    else if (check_for_end && eap != NULL)\n\tset_nextcmd(eap, p);\n\n    return ret;\n}\n\n/*\n * Handle top level expression:\n *\texpr2 ? expr1 : expr1\n *\texpr2 ?? expr1\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Note: \"rettv.v_lock\" is not set.\n *\n * Return OK or FAIL.\n */\n    int\neval1(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    char_u  *p;\n    int\t    getnext;\n\n    CLEAR_POINTER(rettv);\n\n    /*\n     * Get the first variable.\n     */\n    if (eval2(arg, rettv, evalarg) == FAIL)\n\treturn FAIL;\n\n    p = eval_next_non_blank(*arg, evalarg, &getnext);\n    if (*p == '?')\n    {\n\tint\t\top_falsy = p[1] == '?';\n\tint\t\tresult;\n\ttypval_T\tvar2;\n\tevalarg_T\t*evalarg_used = evalarg;\n\tevalarg_T\tlocal_evalarg;\n\tint\t\torig_flags;\n\tint\t\tevaluate;\n\tint\t\tvim9script = in_vim9script();\n\n\tif (evalarg == NULL)\n\t{\n\t    init_evalarg(&local_evalarg);\n\t    evalarg_used = &local_evalarg;\n\t}\n\torig_flags = evalarg_used->eval_flags;\n\tevaluate = evalarg_used->eval_flags & EVAL_EVALUATE;\n\n\tif (getnext)\n\t    *arg = eval_next_line(*arg, evalarg_used);\n\telse\n\t{\n\t    if (evaluate && vim9script && !VIM_ISWHITE(p[-1]))\n\t    {\n\t\terror_white_both(p, op_falsy ? 2 : 1);\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t    *arg = p;\n\t}\n\n\tresult = FALSE;\n\tif (evaluate)\n\t{\n\t    int\t\terror = FALSE;\n\n\t    if (op_falsy)\n\t\tresult = tv2bool(rettv);\n\t    else if (vim9script)\n\t\tresult = tv_get_bool_chk(rettv, &error);\n\t    else if (tv_get_number_chk(rettv, &error) != 0)\n\t\tresult = TRUE;\n\t    if (error || !op_falsy || !result)\n\t\tclear_tv(rettv);\n\t    if (error)\n\t\treturn FAIL;\n\t}\n\n\t/*\n\t * Get the second variable.  Recursive!\n\t */\n\tif (op_falsy)\n\t    ++*arg;\n\tif (evaluate && vim9script && !IS_WHITE_OR_NUL((*arg)[1]))\n\t{\n\t    error_white_both(*arg - (op_falsy ? 1 : 0), op_falsy ? 2 : 1);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite_and_linebreak(*arg + 1, evalarg_used);\n\tevalarg_used->eval_flags = (op_falsy ? !result : result)\n\t\t\t\t    ? orig_flags : orig_flags & ~EVAL_EVALUATE;\n\tif (eval1(arg, &var2, evalarg_used) == FAIL)\n\t{\n\t    evalarg_used->eval_flags = orig_flags;\n\t    return FAIL;\n\t}\n\tif (!op_falsy || !result)\n\t    *rettv = var2;\n\n\tif (!op_falsy)\n\t{\n\t    /*\n\t     * Check for the \":\".\n\t     */\n\t    p = eval_next_non_blank(*arg, evalarg_used, &getnext);\n\t    if (*p != ':')\n\t    {\n\t\temsg(_(e_missing_colon_after_questionmark));\n\t\tif (evaluate && result)\n\t\t    clear_tv(rettv);\n\t\tevalarg_used->eval_flags = orig_flags;\n\t\treturn FAIL;\n\t    }\n\t    if (getnext)\n\t\t*arg = eval_next_line(*arg, evalarg_used);\n\t    else\n\t    {\n\t\tif (evaluate && vim9script && !VIM_ISWHITE(p[-1]))\n\t\t{\n\t\t    error_white_both(p, 1);\n\t\t    clear_tv(rettv);\n\t\t    evalarg_used->eval_flags = orig_flags;\n\t\t    return FAIL;\n\t\t}\n\t\t*arg = p;\n\t    }\n\n\t    /*\n\t     * Get the third variable.  Recursive!\n\t     */\n\t    if (evaluate && vim9script && !IS_WHITE_OR_NUL((*arg)[1]))\n\t    {\n\t\terror_white_both(*arg, 1);\n\t\tclear_tv(rettv);\n\t\tevalarg_used->eval_flags = orig_flags;\n\t\treturn FAIL;\n\t    }\n\t    *arg = skipwhite_and_linebreak(*arg + 1, evalarg_used);\n\t    evalarg_used->eval_flags = !result ? orig_flags\n\t\t\t\t\t\t : orig_flags & ~EVAL_EVALUATE;\n\t    if (eval1(arg, &var2, evalarg_used) == FAIL)\n\t    {\n\t\tif (evaluate && result)\n\t\t    clear_tv(rettv);\n\t\tevalarg_used->eval_flags = orig_flags;\n\t\treturn FAIL;\n\t    }\n\t    if (evaluate && !result)\n\t\t*rettv = var2;\n\t}\n\n\tif (evalarg == NULL)\n\t    clear_evalarg(&local_evalarg, NULL);\n\telse\n\t    evalarg->eval_flags = orig_flags;\n    }\n\n    return OK;\n}\n\n/*\n * Handle first level expression:\n *\texpr2 || expr2 || expr2\t    logical OR\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval2(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    char_u\t*p;\n    int\t\tgetnext;\n\n    /*\n     * Get the first expression.\n     */\n    if (eval3(arg, rettv, evalarg) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Handle the  \"||\" operator.\n     */\n    p = eval_next_non_blank(*arg, evalarg, &getnext);\n    if (p[0] == '|' && p[1] == '|')\n    {\n\tevalarg_T   *evalarg_used = evalarg;\n\tevalarg_T   local_evalarg;\n\tint\t    evaluate;\n\tint\t    orig_flags;\n\tlong\t    result = FALSE;\n\ttypval_T    var2;\n\tint\t    error = FALSE;\n\tint\t    vim9script = in_vim9script();\n\n\tif (evalarg == NULL)\n\t{\n\t    init_evalarg(&local_evalarg);\n\t    evalarg_used = &local_evalarg;\n\t}\n\torig_flags = evalarg_used->eval_flags;\n\tevaluate = orig_flags & EVAL_EVALUATE;\n\tif (evaluate)\n\t{\n\t    if (vim9script)\n\t\tresult = tv_get_bool_chk(rettv, &error);\n\t    else if (tv_get_number_chk(rettv, &error) != 0)\n\t\tresult = TRUE;\n\t    clear_tv(rettv);\n\t    if (error)\n\t\treturn FAIL;\n\t}\n\n\t/*\n\t * Repeat until there is no following \"||\".\n\t */\n\twhile (p[0] == '|' && p[1] == '|')\n\t{\n\t    if (getnext)\n\t\t*arg = eval_next_line(*arg, evalarg_used);\n\t    else\n\t    {\n\t\tif (evaluate && vim9script && !VIM_ISWHITE(p[-1]))\n\t\t{\n\t\t    error_white_both(p, 2);\n\t\t    clear_tv(rettv);\n\t\t    return FAIL;\n\t\t}\n\t\t*arg = p;\n\t    }\n\n\t    /*\n\t     * Get the second variable.\n\t     */\n\t    if (evaluate && vim9script && !IS_WHITE_OR_NUL((*arg)[2]))\n\t    {\n\t\terror_white_both(*arg, 2);\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t    *arg = skipwhite_and_linebreak(*arg + 2, evalarg_used);\n\t    evalarg_used->eval_flags = !result ? orig_flags\n\t\t\t\t\t\t : orig_flags & ~EVAL_EVALUATE;\n\t    if (eval3(arg, &var2, evalarg_used) == FAIL)\n\t\treturn FAIL;\n\n\t    /*\n\t     * Compute the result.\n\t     */\n\t    if (evaluate && !result)\n\t    {\n\t\tif (vim9script)\n\t\t    result = tv_get_bool_chk(&var2, &error);\n\t\telse if (tv_get_number_chk(&var2, &error) != 0)\n\t\t    result = TRUE;\n\t\tclear_tv(&var2);\n\t\tif (error)\n\t\t    return FAIL;\n\t    }\n\t    if (evaluate)\n\t    {\n\t\tif (vim9script)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = result ? VVAL_TRUE : VVAL_FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rettv->v_type = VAR_NUMBER;\n\t\t    rettv->vval.v_number = result;\n\t\t}\n\t    }\n\n\t    p = eval_next_non_blank(*arg, evalarg_used, &getnext);\n\t}\n\n\tif (evalarg == NULL)\n\t    clear_evalarg(&local_evalarg, NULL);\n\telse\n\t    evalarg->eval_flags = orig_flags;\n    }\n\n    return OK;\n}\n\n/*\n * Handle second level expression:\n *\texpr3 && expr3 && expr3\t    logical AND\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval3(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    char_u\t*p;\n    int\t\tgetnext;\n\n    /*\n     * Get the first expression.\n     */\n    if (eval4(arg, rettv, evalarg) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Handle the \"&&\" operator.\n     */\n    p = eval_next_non_blank(*arg, evalarg, &getnext);\n    if (p[0] == '&' && p[1] == '&')\n    {\n\tevalarg_T   *evalarg_used = evalarg;\n\tevalarg_T   local_evalarg;\n\tint\t    orig_flags;\n\tint\t    evaluate;\n\tlong\t    result = TRUE;\n\ttypval_T    var2;\n\tint\t    error = FALSE;\n\tint\t    vim9script = in_vim9script();\n\n\tif (evalarg == NULL)\n\t{\n\t    init_evalarg(&local_evalarg);\n\t    evalarg_used = &local_evalarg;\n\t}\n\torig_flags = evalarg_used->eval_flags;\n\tevaluate = orig_flags & EVAL_EVALUATE;\n\tif (evaluate)\n\t{\n\t    if (vim9script)\n\t\tresult = tv_get_bool_chk(rettv, &error);\n\t    else if (tv_get_number_chk(rettv, &error) == 0)\n\t\tresult = FALSE;\n\t    clear_tv(rettv);\n\t    if (error)\n\t\treturn FAIL;\n\t}\n\n\t/*\n\t * Repeat until there is no following \"&&\".\n\t */\n\twhile (p[0] == '&' && p[1] == '&')\n\t{\n\t    if (getnext)\n\t\t*arg = eval_next_line(*arg, evalarg_used);\n\t    else\n\t    {\n\t\tif (evaluate && vim9script && !VIM_ISWHITE(p[-1]))\n\t\t{\n\t\t    error_white_both(p, 2);\n\t\t    clear_tv(rettv);\n\t\t    return FAIL;\n\t\t}\n\t\t*arg = p;\n\t    }\n\n\t    /*\n\t     * Get the second variable.\n\t     */\n\t    if (evaluate && vim9script && !IS_WHITE_OR_NUL((*arg)[2]))\n\t    {\n\t\terror_white_both(*arg, 2);\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t    *arg = skipwhite_and_linebreak(*arg + 2, evalarg_used);\n\t    evalarg_used->eval_flags = result ? orig_flags\n\t\t\t\t\t\t : orig_flags & ~EVAL_EVALUATE;\n\t    CLEAR_FIELD(var2);\n\t    if (eval4(arg, &var2, evalarg_used) == FAIL)\n\t\treturn FAIL;\n\n\t    /*\n\t     * Compute the result.\n\t     */\n\t    if (evaluate && result)\n\t    {\n\t\tif (vim9script)\n\t\t    result = tv_get_bool_chk(&var2, &error);\n\t\telse if (tv_get_number_chk(&var2, &error) == 0)\n\t\t    result = FALSE;\n\t\tclear_tv(&var2);\n\t\tif (error)\n\t\t    return FAIL;\n\t    }\n\t    if (evaluate)\n\t    {\n\t\tif (vim9script)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = result ? VVAL_TRUE : VVAL_FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rettv->v_type = VAR_NUMBER;\n\t\t    rettv->vval.v_number = result;\n\t\t}\n\t    }\n\n\t    p = eval_next_non_blank(*arg, evalarg_used, &getnext);\n\t}\n\n\tif (evalarg == NULL)\n\t    clear_evalarg(&local_evalarg, NULL);\n\telse\n\t    evalarg->eval_flags = orig_flags;\n    }\n\n    return OK;\n}\n\n/*\n * Handle third level expression:\n *\tvar1 == var2\n *\tvar1 =~ var2\n *\tvar1 != var2\n *\tvar1 !~ var2\n *\tvar1 > var2\n *\tvar1 >= var2\n *\tvar1 < var2\n *\tvar1 <= var2\n *\tvar1 is var2\n *\tvar1 isnot var2\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval4(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    char_u\t*p;\n    int\t\tgetnext;\n    exprtype_T\ttype = EXPR_UNKNOWN;\n    int\t\tlen = 2;\n    int\t\ttype_is = FALSE;\n\n    /*\n     * Get the first expression.\n     */\n    if (eval5(arg, rettv, evalarg) == FAIL)\n\treturn FAIL;\n\n    p = eval_next_non_blank(*arg, evalarg, &getnext);\n\n    type = get_compare_type(p, &len, &type_is);\n\n    /*\n     * If there is a comparative operator, use it.\n     */\n    if (type != EXPR_UNKNOWN)\n    {\n\ttypval_T    var2;\n\tint\t    ic;\n\tint\t    vim9script = in_vim9script();\n\tint\t    evaluate = evalarg == NULL\n\t\t\t\t   ? 0 : (evalarg->eval_flags & EVAL_EVALUATE);\n\tlong\t    comp_lnum = SOURCING_LNUM;\n\n\tif (getnext)\n\t{\n\t    *arg = eval_next_line(*arg, evalarg);\n\t    p = *arg;\n\t}\n\telse if (evaluate && vim9script && !VIM_ISWHITE(**arg))\n\t{\n\t    error_white_both(*arg, len);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\n\tif (vim9script && type_is && (p[len] == '?' || p[len] == '#'))\n\t{\n\t    semsg(_(e_invalid_expression_str), p);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\n\t// extra question mark appended: ignore case\n\tif (p[len] == '?')\n\t{\n\t    ic = TRUE;\n\t    ++len;\n\t}\n\t// extra '#' appended: match case\n\telse if (p[len] == '#')\n\t{\n\t    ic = FALSE;\n\t    ++len;\n\t}\n\t// nothing appended: use 'ignorecase' if not in Vim script\n\telse\n\t    ic = vim9script ? FALSE : p_ic;\n\n\t/*\n\t * Get the second variable.\n\t */\n\tif (evaluate && vim9script && !IS_WHITE_OR_NUL(p[len]))\n\t{\n\t    error_white_both(p, len);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite_and_linebreak(p + len, evalarg);\n\tif (eval5(arg, &var2, evalarg) == FAIL)\n\t{\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\tif (evaluate)\n\t{\n\t    int ret;\n\n\t    // use the line of the comparison for messages\n\t    SOURCING_LNUM = comp_lnum;\n\t    if (vim9script && check_compare_types(type, rettv, &var2) == FAIL)\n\t    {\n\t\tret = FAIL;\n\t\tclear_tv(rettv);\n\t    }\n\t    else\n\t\tret = typval_compare(rettv, &var2, type, ic);\n\t    clear_tv(&var2);\n\t    return ret;\n\t}\n    }\n\n    return OK;\n}\n\n/*\n * Make a copy of blob \"tv1\" and append blob \"tv2\".\n */\n    void\neval_addblob(typval_T *tv1, typval_T *tv2)\n{\n    blob_T  *b1 = tv1->vval.v_blob;\n    blob_T  *b2 = tv2->vval.v_blob;\n    blob_T  *b = blob_alloc();\n    int\t    i;\n\n    if (b != NULL)\n    {\n\tfor (i = 0; i < blob_len(b1); i++)\n\t    ga_append(&b->bv_ga, blob_get(b1, i));\n\tfor (i = 0; i < blob_len(b2); i++)\n\t    ga_append(&b->bv_ga, blob_get(b2, i));\n\n\tclear_tv(tv1);\n\trettv_blob_set(tv1, b);\n    }\n}\n\n/*\n * Make a copy of list \"tv1\" and append list \"tv2\".\n */\n    int\neval_addlist(typval_T *tv1, typval_T *tv2)\n{\n    typval_T var3;\n\n    // concatenate Lists\n    if (list_concat(tv1->vval.v_list, tv2->vval.v_list, &var3) == FAIL)\n    {\n\tclear_tv(tv1);\n\tclear_tv(tv2);\n\treturn FAIL;\n    }\n    clear_tv(tv1);\n    *tv1 = var3;\n    return OK;\n}\n\n/*\n * Handle the bitwise left/right shift operator expression:\n *\tvar1 << var2\n *\tvar1 >> var2\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval5(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    /*\n     * Get the first expression.\n     */\n    if (eval6(arg, rettv, evalarg) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Repeat computing, until no '<<' or '>>' is following.\n     */\n    for (;;)\n    {\n\tchar_u\t\t*p;\n\tint\t\tgetnext;\n\texprtype_T\ttype;\n\tint\t\tevaluate;\n\ttypval_T\tvar2;\n\tint\t\tvim9script;\n\n\tp = eval_next_non_blank(*arg, evalarg, &getnext);\n\tif (p[0] == '<' && p[1] == '<')\n\t    type = EXPR_LSHIFT;\n\telse if (p[0] == '>' && p[1] == '>')\n\t    type = EXPR_RSHIFT;\n\telse\n\t    return OK;\n\n\t// Handle a bitwise left or right shift operator\n\tif (rettv->v_type != VAR_NUMBER)\n\t{\n\t    // left operand should be a number\n\t    emsg(_(e_bitshift_ops_must_be_number));\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\n\tevaluate = evalarg == NULL ? 0 : (evalarg->eval_flags & EVAL_EVALUATE);\n\tvim9script = in_vim9script();\n\tif (getnext)\n\t{\n\t    *arg = eval_next_line(*arg, evalarg);\n\t    p = *arg;\n\t}\n\telse if (evaluate && vim9script && !VIM_ISWHITE(**arg))\n\t{\n\t    error_white_both(*arg, 2);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\n\t/*\n\t * Get the second variable.\n\t */\n\tif (evaluate && vim9script && !IS_WHITE_OR_NUL(p[2]))\n\t{\n\t    error_white_both(p, 2);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite_and_linebreak(p + 2, evalarg);\n\tif (eval6(arg, &var2, evalarg) == FAIL)\n\t{\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\n\tif (var2.v_type != VAR_NUMBER || var2.vval.v_number < 0)\n\t{\n\t    // right operand should be a positive number\n\t    if (var2.v_type != VAR_NUMBER)\n\t\temsg(_(e_bitshift_ops_must_be_number));\n\t    else\n\t\temsg(_(e_bitshift_ops_must_be_postive));\n\t    clear_tv(rettv);\n\t    clear_tv(&var2);\n\t    return FAIL;\n\t}\n\n\tif (evaluate)\n\t{\n\t    if (var2.vval.v_number > MAX_LSHIFT_BITS)\n\t\t// shifting more bits than we have always results in zero\n\t\trettv->vval.v_number = 0;\n\t    else if (type == EXPR_LSHIFT)\n\t\trettv->vval.v_number =\n\t\t      (uvarnumber_T)rettv->vval.v_number << var2.vval.v_number;\n\t    else\n\t\trettv->vval.v_number =\n\t\t      (uvarnumber_T)rettv->vval.v_number >> var2.vval.v_number;\n\t}\n\n\tclear_tv(&var2);\n    }\n\n    return OK;\n}\n\n/*\n * Handle fifth level expression:\n *\t+\tnumber addition, concatenation of list or blob\n *\t-\tnumber subtraction\n *\t.\tstring concatenation (if script version is 1)\n *\t..\tstring concatenation\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval6(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    /*\n     * Get the first expression.\n     */\n    if (eval7(arg, rettv, evalarg, FALSE) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Repeat computing, until no '+', '-' or '.' is following.\n     */\n    for (;;)\n    {\n\tint\t    evaluate;\n\tint\t    getnext;\n\tchar_u\t    *p;\n\tint\t    op;\n\tint\t    oplen;\n\tint\t    concat;\n\ttypval_T    var2;\n\tint\t    vim9script = in_vim9script();\n\n\t// \".\" is only string concatenation when scriptversion is 1\n\t// \"+=\", \"-=\" and \"..=\" are assignments\n\t// \"++\" and \"--\" on the next line are a separate command.\n\tp = eval_next_non_blank(*arg, evalarg, &getnext);\n\top = *p;\n\tconcat = op == '.' && (*(p + 1) == '.' || in_old_script(2));\n\tif ((op != '+' && op != '-' && !concat) || p[1] == '='\n\t\t\t\t\t       || (p[1] == '.' && p[2] == '='))\n\t    break;\n\tif (getnext && (op == '+' || op == '-') && p[0] == p[1])\n\t    break;\n\n\tevaluate = evalarg == NULL ? 0 : (evalarg->eval_flags & EVAL_EVALUATE);\n\toplen = (concat && p[1] == '.') ? 2 : 1;\n\tif (getnext)\n\t    *arg = eval_next_line(*arg, evalarg);\n\telse\n\t{\n\t    if (evaluate && vim9script && !VIM_ISWHITE(**arg))\n\t    {\n\t\terror_white_both(*arg, oplen);\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t    *arg = p;\n\t}\n\tif ((op != '+' || (rettv->v_type != VAR_LIST\n\t\t\t\t\t\t && rettv->v_type != VAR_BLOB))\n#ifdef FEAT_FLOAT\n\t\t&& (op == '.' || rettv->v_type != VAR_FLOAT)\n#endif\n\t\t&& evaluate)\n\t{\n\t    int\t\terror = FALSE;\n\n\t    // For \"list + ...\", an illegal use of the first operand as\n\t    // a number cannot be determined before evaluating the 2nd\n\t    // operand: if this is also a list, all is ok.\n\t    // For \"something . ...\", \"something - ...\" or \"non-list + ...\",\n\t    // we know that the first operand needs to be a string or number\n\t    // without evaluating the 2nd operand.  So check before to avoid\n\t    // side effects after an error.\n\t    if (op != '.')\n\t\ttv_get_number_chk(rettv, &error);\n\t    if ((op == '.' && tv_get_string_chk(rettv) == NULL) || error)\n\t    {\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t/*\n\t * Get the second variable.\n\t */\n\tif (evaluate && vim9script && !IS_WHITE_OR_NUL((*arg)[oplen]))\n\t{\n\t    error_white_both(*arg, oplen);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite_and_linebreak(*arg + oplen, evalarg);\n\tif (eval7(arg, &var2, evalarg, !vim9script && op == '.') == FAIL)\n\t{\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\n\tif (evaluate)\n\t{\n\t    /*\n\t     * Compute the result.\n\t     */\n\t    if (op == '.')\n\t    {\n\t\tchar_u\tbuf1[NUMBUFLEN], buf2[NUMBUFLEN];\n\t\tchar_u\t*s1 = tv_get_string_buf(rettv, buf1);\n\t\tchar_u\t*s2 = NULL;\n\n\t\tif (vim9script && (var2.v_type == VAR_VOID\n\t\t\t|| var2.v_type == VAR_CHANNEL\n\t\t\t|| var2.v_type == VAR_JOB))\n\t\t    semsg(_(e_using_invalid_value_as_string_str),\n\t\t\t\t\t\t   vartype_name(var2.v_type));\n#ifdef FEAT_FLOAT\n\t\telse if (vim9script && var2.v_type == VAR_FLOAT)\n\t\t{\n\t\t    vim_snprintf((char *)buf2, NUMBUFLEN, \"%g\",\n\t\t\t\t\t\t\t    var2.vval.v_float);\n\t\t    s2 = buf2;\n\t\t}\n#endif\n\t\telse\n\t\t    s2 = tv_get_string_buf_chk(&var2, buf2);\n\t\tif (s2 == NULL)\t\t// type error ?\n\t\t{\n\t\t    clear_tv(rettv);\n\t\t    clear_tv(&var2);\n\t\t    return FAIL;\n\t\t}\n\t\tp = concat_str(s1, s2);\n\t\tclear_tv(rettv);\n\t\trettv->v_type = VAR_STRING;\n\t\trettv->vval.v_string = p;\n\t    }\n\t    else if (op == '+' && rettv->v_type == VAR_BLOB\n\t\t\t\t\t\t   && var2.v_type == VAR_BLOB)\n\t\teval_addblob(rettv, &var2);\n\t    else if (op == '+' && rettv->v_type == VAR_LIST\n\t\t\t\t\t\t   && var2.v_type == VAR_LIST)\n\t    {\n\t\tif (eval_addlist(rettv, &var2) == FAIL)\n\t\t    return FAIL;\n\t    }\n\t    else\n\t    {\n\t\tint\t\terror = FALSE;\n\t\tvarnumber_T\tn1, n2;\n#ifdef FEAT_FLOAT\n\t\tfloat_T\t    f1 = 0, f2 = 0;\n\n\t\tif (rettv->v_type == VAR_FLOAT)\n\t\t{\n\t\t    f1 = rettv->vval.v_float;\n\t\t    n1 = 0;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    n1 = tv_get_number_chk(rettv, &error);\n\t\t    if (error)\n\t\t    {\n\t\t\t// This can only happen for \"list + non-list\" or\n\t\t\t// \"blob + non-blob\".  For \"non-list + ...\" or\n\t\t\t// \"something - ...\", we returned before evaluating the\n\t\t\t// 2nd operand.\n\t\t\tclear_tv(rettv);\n\t\t\tclear_tv(&var2);\n\t\t\treturn FAIL;\n\t\t    }\n#ifdef FEAT_FLOAT\n\t\t    if (var2.v_type == VAR_FLOAT)\n\t\t\tf1 = n1;\n#endif\n\t\t}\n#ifdef FEAT_FLOAT\n\t\tif (var2.v_type == VAR_FLOAT)\n\t\t{\n\t\t    f2 = var2.vval.v_float;\n\t\t    n2 = 0;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    n2 = tv_get_number_chk(&var2, &error);\n\t\t    if (error)\n\t\t    {\n\t\t\tclear_tv(rettv);\n\t\t\tclear_tv(&var2);\n\t\t\treturn FAIL;\n\t\t    }\n#ifdef FEAT_FLOAT\n\t\t    if (rettv->v_type == VAR_FLOAT)\n\t\t\tf2 = n2;\n#endif\n\t\t}\n\t\tclear_tv(rettv);\n\n#ifdef FEAT_FLOAT\n\t\t// If there is a float on either side the result is a float.\n\t\tif (rettv->v_type == VAR_FLOAT || var2.v_type == VAR_FLOAT)\n\t\t{\n\t\t    if (op == '+')\n\t\t\tf1 = f1 + f2;\n\t\t    else\n\t\t\tf1 = f1 - f2;\n\t\t    rettv->v_type = VAR_FLOAT;\n\t\t    rettv->vval.v_float = f1;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    if (op == '+')\n\t\t\tn1 = n1 + n2;\n\t\t    else\n\t\t\tn1 = n1 - n2;\n\t\t    rettv->v_type = VAR_NUMBER;\n\t\t    rettv->vval.v_number = n1;\n\t\t}\n\t    }\n\t    clear_tv(&var2);\n\t}\n    }\n    return OK;\n}\n\n/*\n * Handle sixth level expression:\n *\t*\tnumber multiplication\n *\t/\tnumber division\n *\t%\tnumber modulo\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval7(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\twant_string)  // after \".\" operator\n{\n#ifdef FEAT_FLOAT\n    int\t    use_float = FALSE;\n#endif\n\n    /*\n     * Get the first expression.\n     */\n    if (eval8(arg, rettv, evalarg, want_string) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Repeat computing, until no '*', '/' or '%' is following.\n     */\n    for (;;)\n    {\n\tint\t    evaluate;\n\tint\t    getnext;\n\ttypval_T    var2;\n\tchar_u\t    *p;\n\tint\t    op;\n\tvarnumber_T n1, n2;\n#ifdef FEAT_FLOAT\n\tfloat_T\t    f1, f2;\n#endif\n\tint\t    error;\n\n\t// \"*=\", \"/=\" and \"%=\" are assignments\n\tp = eval_next_non_blank(*arg, evalarg, &getnext);\n\top = *p;\n\tif ((op != '*' && op != '/' && op != '%') || p[1] == '=')\n\t    break;\n\n\tevaluate = evalarg == NULL ? 0 : (evalarg->eval_flags & EVAL_EVALUATE);\n\tif (getnext)\n\t    *arg = eval_next_line(*arg, evalarg);\n\telse\n\t{\n\t    if (evaluate && in_vim9script() && !VIM_ISWHITE(**arg))\n\t    {\n\t\terror_white_both(*arg, 1);\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t    *arg = p;\n\t}\n\n#ifdef FEAT_FLOAT\n\tf1 = 0;\n\tf2 = 0;\n#endif\n\terror = FALSE;\n\tif (evaluate)\n\t{\n#ifdef FEAT_FLOAT\n\t    if (rettv->v_type == VAR_FLOAT)\n\t    {\n\t\tf1 = rettv->vval.v_float;\n\t\tuse_float = TRUE;\n\t\tn1 = 0;\n\t    }\n\t    else\n#endif\n\t\tn1 = tv_get_number_chk(rettv, &error);\n\t    clear_tv(rettv);\n\t    if (error)\n\t\treturn FAIL;\n\t}\n\telse\n\t    n1 = 0;\n\n\t/*\n\t * Get the second variable.\n\t */\n\tif (evaluate && in_vim9script() && !IS_WHITE_OR_NUL((*arg)[1]))\n\t{\n\t    error_white_both(*arg, 1);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite_and_linebreak(*arg + 1, evalarg);\n\tif (eval8(arg, &var2, evalarg, FALSE) == FAIL)\n\t    return FAIL;\n\n\tif (evaluate)\n\t{\n#ifdef FEAT_FLOAT\n\t    if (var2.v_type == VAR_FLOAT)\n\t    {\n\t\tif (!use_float)\n\t\t{\n\t\t    f1 = n1;\n\t\t    use_float = TRUE;\n\t\t}\n\t\tf2 = var2.vval.v_float;\n\t\tn2 = 0;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tn2 = tv_get_number_chk(&var2, &error);\n\t\tclear_tv(&var2);\n\t\tif (error)\n\t\t    return FAIL;\n#ifdef FEAT_FLOAT\n\t\tif (use_float)\n\t\t    f2 = n2;\n#endif\n\t    }\n\n\t    /*\n\t     * Compute the result.\n\t     * When either side is a float the result is a float.\n\t     */\n#ifdef FEAT_FLOAT\n\t    if (use_float)\n\t    {\n\t\tif (op == '*')\n\t\t    f1 = f1 * f2;\n\t\telse if (op == '/')\n\t\t{\n# ifdef VMS\n\t\t    // VMS crashes on divide by zero, work around it\n\t\t    if (f2 == 0.0)\n\t\t    {\n\t\t\tif (f1 == 0)\n\t\t\t    f1 = -1 * __F_FLT_MAX - 1L;   // similar to NaN\n\t\t\telse if (f1 < 0)\n\t\t\t    f1 = -1 * __F_FLT_MAX;\n\t\t\telse\n\t\t\t    f1 = __F_FLT_MAX;\n\t\t    }\n\t\t    else\n\t\t\tf1 = f1 / f2;\n# else\n\t\t    // We rely on the floating point library to handle divide\n\t\t    // by zero to result in \"inf\" and not a crash.\n\t\t    f1 = f1 / f2;\n# endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    emsg(_(e_cannot_use_percent_with_float));\n\t\t    return FAIL;\n\t\t}\n\t\trettv->v_type = VAR_FLOAT;\n\t\trettv->vval.v_float = f1;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tint\t    failed = FALSE;\n\n\t\tif (op == '*')\n\t\t    n1 = n1 * n2;\n\t\telse if (op == '/')\n\t\t    n1 = num_divide(n1, n2, &failed);\n\t\telse\n\t\t    n1 = num_modulus(n1, n2, &failed);\n\t\tif (failed)\n\t\t    return FAIL;\n\n\t\trettv->v_type = VAR_NUMBER;\n\t\trettv->vval.v_number = n1;\n\t    }\n\t}\n    }\n\n    return OK;\n}\n\n/*\n * Handle a type cast before a base level expression.\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n * Return OK or FAIL.\n */\n    static int\neval8(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\twant_string)\t// after \".\" operator\n{\n    type_T\t*want_type = NULL;\n    garray_T\ttype_list;\t    // list of pointers to allocated types\n    int\t\tres;\n    int\t\tevaluate = evalarg == NULL ? 0\n\t\t\t\t       : (evalarg->eval_flags & EVAL_EVALUATE);\n\n    // Recognize <type> in Vim9 script only.\n    if (in_vim9script() && **arg == '<' && eval_isnamec1((*arg)[1])\n\t\t\t\t\t     && STRNCMP(*arg, \"<SNR>\", 5) != 0)\n    {\n\t++*arg;\n\tga_init2(&type_list, sizeof(type_T *), 10);\n\twant_type = parse_type(arg, &type_list, TRUE);\n\tif (want_type == NULL && (evaluate || **arg != '>'))\n\t{\n\t    clear_type_list(&type_list);\n\t    return FAIL;\n\t}\n\n\tif (**arg != '>')\n\t{\n\t    if (*skipwhite(*arg) == '>')\n\t\tsemsg(_(e_no_white_space_allowed_before_str_str), \">\", *arg);\n\t    else\n\t\temsg(_(e_missing_gt));\n\t    clear_type_list(&type_list);\n\t    return FAIL;\n\t}\n\t++*arg;\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n    }\n\n    res = eval9(arg, rettv, evalarg, want_string);\n\n    if (want_type != NULL && evaluate)\n    {\n\tif (res == OK)\n\t{\n\t    type_T *actual = typval2type(rettv, get_copyID(), &type_list,\n\t\t\t\t\t\t\t       TVTT_DO_MEMBER);\n\n\t    if (!equal_type(want_type, actual, 0))\n\t    {\n\t\tif (want_type == &t_bool && actual != &t_bool\n\t\t\t\t\t&& (actual->tt_flags & TTFLAG_BOOL_OK))\n\t\t{\n\t\t    int n = tv2bool(rettv);\n\n\t\t    // can use \"0\" and \"1\" for boolean in some places\n\t\t    clear_tv(rettv);\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = n ? VVAL_TRUE : VVAL_FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    where_T where = WHERE_INIT;\n\n\t\t    where.wt_variable = TRUE;\n\t\t    res = check_type(want_type, actual, TRUE, where);\n\t\t}\n\t    }\n\t}\n\tclear_type_list(&type_list);\n    }\n\n    return res;\n}\n\n    int\neval_leader(char_u **arg, int vim9)\n{\n    char_u\t*s = *arg;\n    char_u\t*p = *arg;\n\n    while (*p == '!' || *p == '-' || *p == '+')\n    {\n\tchar_u *n = skipwhite(p + 1);\n\n\t// ++, --, -+ and +- are not accepted in Vim9 script\n\tif (vim9 && (*p == '-' || *p == '+') && (*n == '-' || *n == '+'))\n\t{\n\t    semsg(_(e_invalid_expression_str), s);\n\t    return FAIL;\n\t}\n\tp = n;\n    }\n    *arg = p;\n    return OK;\n}\n\n/*\n * Check for a predefined value \"true\", \"false\" and \"null.*\".\n * Return OK when recognized.\n */\n    int\nhandle_predefined(char_u *s, int len, typval_T *rettv)\n{\n    switch (len)\n    {\n\tcase 4: if (STRNCMP(s, \"true\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = VVAL_TRUE;\n\t\t    return OK;\n\t\t}\n\t\tif (STRNCMP(s, \"null\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_SPECIAL;\n\t\t    rettv->vval.v_number = VVAL_NULL;\n\t\t    return OK;\n\t\t}\n\t\tbreak;\n\tcase 5: if (STRNCMP(s, \"false\", 5) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = VVAL_FALSE;\n\t\t    return OK;\n\t\t}\n\t\tbreak;\n\tcase 8: if (STRNCMP(s, \"null_job\", 8) == 0)\n\t\t{\n#ifdef FEAT_JOB_CHANNEL\n\t\t    rettv->v_type = VAR_JOB;\n\t\t    rettv->vval.v_job = NULL;\n#else\n\t\t    rettv->v_type = VAR_SPECIAL;\n\t\t    rettv->vval.v_number = VVAL_NULL;\n#endif\n\t\t    return OK;\n\t\t}\n\t\tbreak;\n\tcase 9:\n\t\tif (STRNCMP(s, \"null_\", 5) != 0)\n\t\t    break;\n\t\tif (STRNCMP(s + 5, \"list\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_LIST;\n\t\t    rettv->vval.v_list = NULL;\n\t\t    return OK;\n\t\t}\n\t\tif (STRNCMP(s + 5, \"dict\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_DICT;\n\t\t    rettv->vval.v_dict = NULL;\n\t\t    return OK;\n\t\t}\n\t\tif (STRNCMP(s + 5, \"blob\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_BLOB;\n\t\t    rettv->vval.v_blob = NULL;\n\t\t    return OK;\n\t\t}\n\t\tbreak;\n\tcase 11: if (STRNCMP(s, \"null_string\", 11) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_STRING;\n\t\t    rettv->vval.v_string = NULL;\n\t\t    return OK;\n\t\t}\n\t\tbreak;\n\tcase 12:\n\t\tif (STRNCMP(s, \"null_channel\", 12) == 0)\n\t\t{\n#ifdef FEAT_JOB_CHANNEL\n\t\t    rettv->v_type = VAR_CHANNEL;\n\t\t    rettv->vval.v_channel = NULL;\n#else\n\t\t    rettv->v_type = VAR_SPECIAL;\n\t\t    rettv->vval.v_number = VVAL_NULL;\n#endif\n\t\t    return OK;\n\t\t}\n\t\tif (STRNCMP(s, \"null_partial\", 12) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_PARTIAL;\n\t\t    rettv->vval.v_partial = NULL;\n\t\t    return OK;\n\t\t}\n\t\tbreak;\n\tcase 13: if (STRNCMP(s, \"null_function\", 13) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_FUNC;\n\t\t    rettv->vval.v_string = NULL;\n\t\t    return OK;\n\t\t}\n\t\tbreak;\n    }\n    return FAIL;\n}\n\n/*\n * Handle sixth level expression:\n *  number\t\tnumber constant\n *  0zFFFFFFFF\t\tBlob constant\n *  \"string\"\t\tstring constant\n *  'string'\t\tliteral string constant\n *  &option-name\toption value\n *  @r\t\t\tregister contents\n *  identifier\t\tvariable value\n *  function()\t\tfunction call\n *  $VAR\t\tenvironment variable\n *  (expression)\tnested expression\n *  [expr, expr]\tList\n *  {arg, arg -> expr}\tLambda\n *  {key: val, key: val}   Dictionary\n *  #{key: val, key: val}  Dictionary with literal keys\n *\n *  Also handle:\n *  ! in front\t\tlogical NOT\n *  - in front\t\tunary minus\n *  + in front\t\tunary plus (ignored)\n *  trailing []\t\tsubscript in String or List\n *  trailing .name\tentry in Dictionary\n *  trailing ->name()\tmethod call\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval9(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\twant_string)\t// after \".\" operator\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    int\t\tlen;\n    char_u\t*s;\n    char_u\t*name_start = NULL;\n    char_u\t*start_leader, *end_leader;\n    int\t\tret = OK;\n    char_u\t*alias;\n    static int\trecurse = 0;\n    int\t\tvim9script = in_vim9script();\n\n    /*\n     * Initialise variable so that clear_tv() can't mistake this for a\n     * string and free a string that isn't there.\n     */\n    rettv->v_type = VAR_UNKNOWN;\n\n    /*\n     * Skip '!', '-' and '+' characters.  They are handled later.\n     */\n    start_leader = *arg;\n    if (eval_leader(arg, vim9script) == FAIL)\n\treturn FAIL;\n    end_leader = *arg;\n\n    if (**arg == '.' && (!isdigit(*(*arg + 1))\n#ifdef FEAT_FLOAT\n\t    || in_old_script(2)\n#endif\n\t    ))\n    {\n\tsemsg(_(e_invalid_expression_str), *arg);\n\t++*arg;\n\treturn FAIL;\n    }\n\n    // Limit recursion to 1000 levels.  At least at 10000 we run out of stack\n    // and crash.  With MSVC the stack is smaller.\n    if (recurse ==\n#ifdef _MSC_VER\n\t\t    300\n#else\n\t\t    1000\n#endif\n\t\t    )\n    {\n\tsemsg(_(e_expression_too_recursive_str), *arg);\n\treturn FAIL;\n    }\n    ++recurse;\n\n    switch (**arg)\n    {\n    /*\n     * Number constant.\n     */\n    case '0':\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case '.':\tret = eval_number(arg, rettv, evaluate, want_string);\n\n\t\t// Apply prefixed \"-\" and \"+\" now.  Matters especially when\n\t\t// \"->\" follows.\n\t\tif (ret == OK && evaluate && end_leader > start_leader\n\t\t\t\t\t\t  && rettv->v_type != VAR_BLOB)\n\t\t    ret = eval9_leader(rettv, TRUE, start_leader, &end_leader);\n\t\tbreak;\n\n    /*\n     * String constant: \"string\".\n     */\n    case '\"':\tret = eval_string(arg, rettv, evaluate, FALSE);\n\t\tbreak;\n\n    /*\n     * Literal string constant: 'str''ing'.\n     */\n    case '\\'':\tret = eval_lit_string(arg, rettv, evaluate, FALSE);\n\t\tbreak;\n\n    /*\n     * List: [expr, expr]\n     */\n    case '[':\tret = eval_list(arg, rettv, evalarg, TRUE);\n\t\tbreak;\n\n    /*\n     * Dictionary: #{key: val, key: val}\n     */\n    case '#':\tif (vim9script)\n\t\t{\n\t\t    ret = vim9_bad_comment(*arg) ? FAIL : NOTDONE;\n\t\t}\n\t\telse if ((*arg)[1] == '{')\n\t\t{\n\t\t    ++*arg;\n\t\t    ret = eval_dict(arg, rettv, evalarg, TRUE);\n\t\t}\n\t\telse\n\t\t    ret = NOTDONE;\n\t\tbreak;\n\n    /*\n     * Lambda: {arg, arg -> expr}\n     * Dictionary: {'key': val, 'key': val}\n     */\n    case '{':\tif (vim9script)\n\t\t    ret = NOTDONE;\n\t\telse\n\t\t    ret = get_lambda_tv(arg, rettv, vim9script, evalarg);\n\t\tif (ret == NOTDONE)\n\t\t    ret = eval_dict(arg, rettv, evalarg, FALSE);\n\t\tbreak;\n\n    /*\n     * Option value: &name\n     */\n    case '&':\tret = eval_option(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Environment variable: $VAR.\n     * Interpolated string: $\"string\" or $'string'.\n     */\n    case '$':\tif ((*arg)[1] == '\"' || (*arg)[1] == '\\'')\n\t\t    ret = eval_interp_string(arg, rettv, evaluate);\n\t\telse\n\t\t    ret = eval_env_var(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Register contents: @r.\n     */\n    case '@':\t++*arg;\n\t\tif (evaluate)\n\t\t{\n\t\t    if (vim9script && IS_WHITE_OR_NUL(**arg))\n\t\t\tsemsg(_(e_syntax_error_at_str), *arg);\n\t\t    else if (vim9script && !valid_yank_reg(**arg, FALSE))\n\t\t\temsg_invreg(**arg);\n\t\t    else\n\t\t    {\n\t\t\trettv->v_type = VAR_STRING;\n\t\t\trettv->vval.v_string = get_reg_contents(**arg,\n\t\t\t\t\t\t\t\tGREG_EXPR_SRC);\n\t\t    }\n\t\t}\n\t\tif (**arg != NUL)\n\t\t    ++*arg;\n\t\tbreak;\n\n    /*\n     * nested expression: (expression).\n     * or lambda: (arg) => expr\n     */\n    case '(':\tret = NOTDONE;\n\t\tif (vim9script)\n\t\t{\n\t\t    ret = get_lambda_tv(arg, rettv, TRUE, evalarg);\n\t\t    if (ret == OK && evaluate)\n\t\t    {\n\t\t\tufunc_T *ufunc = rettv->vval.v_partial->pt_func;\n\n\t\t\t// Compile it here to get the return type.  The return\n\t\t\t// type is optional, when it's missing use t_unknown.\n\t\t\t// This is recognized in compile_return().\n\t\t\tif (ufunc->uf_ret_type->tt_type == VAR_VOID)\n\t\t\t    ufunc->uf_ret_type = &t_unknown;\n\t\t\tif (compile_def_function(ufunc, FALSE,\n\t\t\t\t\tget_compile_type(ufunc), NULL) == FAIL)\n\t\t\t{\n\t\t\t    clear_tv(rettv);\n\t\t\t    ret = FAIL;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (ret == NOTDONE)\n\t\t{\n\t\t    *arg = skipwhite_and_linebreak(*arg + 1, evalarg);\n\t\t    ret = eval1(arg, rettv, evalarg);\t// recursive!\n\n\t\t    *arg = skipwhite_and_linebreak(*arg, evalarg);\n\t\t    if (**arg == ')')\n\t\t\t++*arg;\n\t\t    else if (ret == OK)\n\t\t    {\n\t\t\temsg(_(e_missing_closing_paren));\n\t\t\tclear_tv(rettv);\n\t\t\tret = FAIL;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n    default:\tret = NOTDONE;\n\t\tbreak;\n    }\n\n    if (ret == NOTDONE)\n    {\n\t/*\n\t * Must be a variable or function name.\n\t * Can also be a curly-braces kind of name: {expr}.\n\t */\n\ts = *arg;\n\tlen = get_name_len(arg, &alias, evaluate, TRUE);\n\tif (alias != NULL)\n\t    s = alias;\n\n\tif (len <= 0)\n\t    ret = FAIL;\n\telse\n\t{\n\t    int\t    flags = evalarg == NULL ? 0 : evalarg->eval_flags;\n\n\t    if (evaluate && vim9script && len == 1 && *s == '_')\n\t    {\n\t\temsg(_(e_cannot_use_underscore_here));\n\t\tret = FAIL;\n\t    }\n\t    else if (evaluate && vim9script && len > 2\n\t\t\t\t\t\t && s[0] == 's' && s[1] == ':')\n\t    {\n\t\tsemsg(_(e_cannot_use_s_colon_in_vim9_script_str), s);\n\t\tret = FAIL;\n\t    }\n\t    else if ((vim9script ? **arg : *skipwhite(*arg)) == '(')\n\t    {\n\t\t// \"name(...\"  recursive!\n\t\t*arg = skipwhite(*arg);\n\t\tret = eval_func(arg, evalarg, s, len, rettv, flags, NULL);\n\t    }\n\t    else if (flags & EVAL_CONSTANT)\n\t\tret = FAIL;\n\t    else if (evaluate)\n\t    {\n\t\t// get the value of \"true\", \"false\", etc. or a variable\n\t\tret = FAIL;\n\t\tif (vim9script)\n\t\t    ret = handle_predefined(s, len, rettv);\n\t\tif (ret == FAIL)\n\t\t{\n\t\t    name_start = s;\n\t\t    ret = eval_variable(s, len, 0, rettv, NULL,\n\t\t\t\t\t   EVAL_VAR_VERBOSE + EVAL_VAR_IMPORT);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// skip the name\n\t\tcheck_vars(s, len);\n\t\tret = OK;\n\t    }\n\t}\n\tvim_free(alias);\n    }\n\n    // Handle following '[', '(' and '.' for expr[expr], expr.name,\n    // expr(expr), expr->name(expr)\n    if (ret == OK)\n\tret = handle_subscript(arg, name_start, rettv, evalarg, TRUE);\n\n    /*\n     * Apply logical NOT and unary '-', from right to left, ignore '+'.\n     */\n    if (ret == OK && evaluate && end_leader > start_leader)\n\tret = eval9_leader(rettv, FALSE, start_leader, &end_leader);\n\n    --recurse;\n    return ret;\n}\n\n/*\n * Apply the leading \"!\" and \"-\" before an eval9 expression to \"rettv\".\n * When \"numeric_only\" is TRUE only handle \"+\" and \"-\".\n * Adjusts \"end_leaderp\" until it is at \"start_leader\".\n */\n    static int\neval9_leader(\n\ttypval_T    *rettv,\n\tint\t    numeric_only,\n\tchar_u\t    *start_leader,\n\tchar_u\t    **end_leaderp)\n{\n    char_u\t*end_leader = *end_leaderp;\n    int\t\tret = OK;\n    int\t\terror = FALSE;\n    varnumber_T val = 0;\n    vartype_T\ttype = rettv->v_type;\n    int\t\tvim9script = in_vim9script();\n#ifdef FEAT_FLOAT\n    float_T\t    f = 0.0;\n\n    if (rettv->v_type == VAR_FLOAT)\n\tf = rettv->vval.v_float;\n    else\n#endif\n    {\n\twhile (VIM_ISWHITE(end_leader[-1]))\n\t    --end_leader;\n\tif (vim9script && end_leader[-1] == '!')\n\t    val = tv2bool(rettv);\n\telse\n\t    val = tv_get_number_chk(rettv, &error);\n    }\n    if (error)\n    {\n\tclear_tv(rettv);\n\tret = FAIL;\n    }\n    else\n    {\n\twhile (end_leader > start_leader)\n\t{\n\t    --end_leader;\n\t    if (*end_leader == '!')\n\t    {\n\t\tif (numeric_only)\n\t\t{\n\t\t    ++end_leader;\n\t\t    break;\n\t\t}\n#ifdef FEAT_FLOAT\n\t\tif (rettv->v_type == VAR_FLOAT)\n\t\t{\n\t\t    if (vim9script)\n\t\t    {\n\t\t\trettv->v_type = VAR_BOOL;\n\t\t\tval = f == 0.0 ? VVAL_TRUE : VVAL_FALSE;\n\t\t    }\n\t\t    else\n\t\t\tf = !f;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    val = !val;\n\t\t    type = VAR_BOOL;\n\t\t}\n\t    }\n\t    else if (*end_leader == '-')\n\t    {\n#ifdef FEAT_FLOAT\n\t\tif (rettv->v_type == VAR_FLOAT)\n\t\t    f = -f;\n\t\telse\n#endif\n\t\t{\n\t\t    val = -val;\n\t\t    type = VAR_NUMBER;\n\t\t}\n\t    }\n\t}\n#ifdef FEAT_FLOAT\n\tif (rettv->v_type == VAR_FLOAT)\n\t{\n\t    clear_tv(rettv);\n\t    rettv->vval.v_float = f;\n\t}\n\telse\n#endif\n\t{\n\t    clear_tv(rettv);\n\t    if (vim9script)\n\t\trettv->v_type = type;\n\t    else\n\t\trettv->v_type = VAR_NUMBER;\n\t    rettv->vval.v_number = val;\n\t}\n    }\n    *end_leaderp = end_leader;\n    return ret;\n}\n\n/*\n * Call the function referred to in \"rettv\".\n */\n    static int\ncall_func_rettv(\n\tchar_u\t    **arg,\n\tevalarg_T   *evalarg,\n\ttypval_T    *rettv,\n\tint\t    evaluate,\n\tdict_T\t    *selfdict,\n\ttypval_T    *basetv)\n{\n    partial_T\t*pt = NULL;\n    funcexe_T\tfuncexe;\n    typval_T\tfunctv;\n    char_u\t*s;\n    int\t\tret;\n\n    // need to copy the funcref so that we can clear rettv\n    if (evaluate)\n    {\n\tfunctv = *rettv;\n\trettv->v_type = VAR_UNKNOWN;\n\n\t// Invoke the function.  Recursive!\n\tif (functv.v_type == VAR_PARTIAL)\n\t{\n\t    pt = functv.vval.v_partial;\n\t    s = partial_name(pt);\n\t}\n\telse\n\t{\n\t    s = functv.vval.v_string;\n\t    if (s == NULL || *s == NUL)\n\t    {\n\t\temsg(_(e_empty_function_name));\n\t\tret = FAIL;\n\t\tgoto theend;\n\t    }\n\t}\n    }\n    else\n\ts = (char_u *)\"\";\n\n    CLEAR_FIELD(funcexe);\n    funcexe.fe_firstline = curwin->w_cursor.lnum;\n    funcexe.fe_lastline = curwin->w_cursor.lnum;\n    funcexe.fe_evaluate = evaluate;\n    funcexe.fe_partial = pt;\n    funcexe.fe_selfdict = selfdict;\n    funcexe.fe_basetv = basetv;\n    ret = get_func_tv(s, -1, rettv, arg, evalarg, &funcexe);\n\ntheend:\n    // Clear the funcref afterwards, so that deleting it while\n    // evaluating the arguments is possible (see test55).\n    if (evaluate)\n\tclear_tv(&functv);\n\n    return ret;\n}\n\n/*\n * Evaluate \"->method()\".\n * \"*arg\" points to \"method\".\n * Returns FAIL or OK. \"*arg\" is advanced to after the ')'.\n */\n    static int\neval_lambda(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t// give error messages\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    typval_T\tbase = *rettv;\n    int\t\tret;\n\n    rettv->v_type = VAR_UNKNOWN;\n\n    if (**arg == '{')\n    {\n\t// ->{lambda}()\n\tret = get_lambda_tv(arg, rettv, FALSE, evalarg);\n    }\n    else\n    {\n\t// ->(lambda)()\n\t++*arg;\n\tret = eval1(arg, rettv, evalarg);\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg != ')')\n\t{\n\t    emsg(_(e_missing_closing_paren));\n\t    return FAIL;\n\t}\n\tif (rettv->v_type != VAR_STRING && rettv->v_type != VAR_FUNC\n\t\t\t\t\t       && rettv->v_type != VAR_PARTIAL)\n\t{\n\t    emsg(_(e_string_or_function_required_for_arrow_parens_expr));\n\t    return FAIL;\n\t}\n\t++*arg;\n    }\n    if (ret != OK)\n\treturn FAIL;\n\n    if (**arg != '(')\n    {\n\tif (verbose)\n\t{\n\t    if (*skipwhite(*arg) == '(')\n\t\temsg(_(e_no_white_space_allowed_before_parenthesis));\n\t    else\n\t\tsemsg(_(e_missing_parenthesis_str), \"lambda\");\n\t}\n\tclear_tv(rettv);\n\tret = FAIL;\n    }\n    else\n\tret = call_func_rettv(arg, evalarg, rettv, evaluate, NULL, &base);\n\n    // Clear the funcref afterwards, so that deleting it while\n    // evaluating the arguments is possible (see test55).\n    if (evaluate)\n\tclear_tv(&base);\n\n    return ret;\n}\n\n/*\n * Evaluate \"->method()\".\n * \"*arg\" points to \"method\".\n * Returns FAIL or OK. \"*arg\" is advanced to after the ')'.\n */\n    static int\neval_method(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t// give error messages\n{\n    char_u\t*name;\n    long\tlen;\n    char_u\t*alias;\n    char_u\t*tofree = NULL;\n    typval_T\tbase = *rettv;\n    int\t\tret = OK;\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n\n    rettv->v_type = VAR_UNKNOWN;\n\n    name = *arg;\n    len = get_name_len(arg, &alias, evaluate, TRUE);\n    if (alias != NULL)\n\tname = alias;\n\n    if (len <= 0)\n    {\n\tif (verbose)\n\t    emsg(_(e_missing_name_after_method));\n\tret = FAIL;\n    }\n    else\n    {\n\tchar_u *paren;\n\n\t// If there is no \"(\" immediately following, but there is further on,\n\t// it can be \"import.Func()\", \"dict.Func()\", \"list[nr]\", etc.\n\t// Does not handle anything where \"(\" is part of the expression.\n\t*arg = skipwhite(*arg);\n\n\tif (**arg != '(' && alias == NULL\n\t\t\t\t    && (paren = vim_strchr(*arg, '(')) != NULL)\n\t{\n\t    char_u *deref;\n\n\t    *arg = name;\n\t    *paren = NUL;\n\t    deref = deref_function_name(arg, &tofree, evalarg, verbose);\n\t    if (deref == NULL)\n\t    {\n\t\t*arg = name + len;\n\t\tret = FAIL;\n\t    }\n\t    else\n\t    {\n\t\tname = deref;\n\t\tlen = (long)STRLEN(name);\n\t    }\n\t    *paren = '(';\n\t}\n\n\tif (ret == OK)\n\t{\n\t    *arg = skipwhite(*arg);\n\n\t    if (**arg != '(')\n\t    {\n\t\tif (verbose)\n\t\t    semsg(_(e_missing_parenthesis_str), name);\n\t\tret = FAIL;\n\t    }\n\t    else if (VIM_ISWHITE((*arg)[-1]))\n\t    {\n\t\tif (verbose)\n\t\t    emsg(_(e_no_white_space_allowed_before_parenthesis));\n\t\tret = FAIL;\n\t    }\n\t    else\n\t\tret = eval_func(arg, evalarg, name, len, rettv,\n\t\t\t\t\t  evaluate ? EVAL_EVALUATE : 0, &base);\n\t}\n    }\n\n    // Clear the funcref afterwards, so that deleting it while\n    // evaluating the arguments is possible (see test55).\n    if (evaluate)\n\tclear_tv(&base);\n    vim_free(tofree);\n\n    return ret;\n}\n\n/*\n * Evaluate an \"[expr]\" or \"[expr:expr]\" index.  Also \"dict.key\".\n * \"*arg\" points to the '[' or '.'.\n * Returns FAIL or OK. \"*arg\" is advanced to after the ']'.\n */\n    static int\neval_index(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t// give error messages\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    int\t\tempty1 = FALSE, empty2 = FALSE;\n    typval_T\tvar1, var2;\n    int\t\trange = FALSE;\n    char_u\t*key = NULL;\n    int\t\tkeylen = -1;\n    int\t\tvim9script = in_vim9script();\n\n    if (check_can_index(rettv, evaluate, verbose) == FAIL)\n\treturn FAIL;\n\n    init_tv(&var1);\n    init_tv(&var2);\n    if (**arg == '.')\n    {\n\t/*\n\t * dict.name\n\t */\n\tkey = *arg + 1;\n\tfor (keylen = 0; eval_isdictc(key[keylen]); ++keylen)\n\t    ;\n\tif (keylen == 0)\n\t    return FAIL;\n\t*arg = key + keylen;\n    }\n    else\n    {\n\t/*\n\t * something[idx]\n\t *\n\t * Get the (first) variable from inside the [].\n\t */\n\t*arg = skipwhite_and_linebreak(*arg + 1, evalarg);\n\tif (**arg == ':')\n\t    empty1 = TRUE;\n\telse if (eval1(arg, &var1, evalarg) == FAIL)\t// recursive!\n\t    return FAIL;\n\telse if (vim9script && **arg == ':')\n\t{\n\t    semsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t    \":\", *arg);\n\t    clear_tv(&var1);\n\t    return FAIL;\n\t}\n\telse if (evaluate)\n\t{\n\t    int error = FALSE;\n\n#ifdef FEAT_FLOAT\n\t    // allow for indexing with float\n\t    if (vim9script && rettv->v_type == VAR_DICT\n\t\t\t\t\t\t   && var1.v_type == VAR_FLOAT)\n\t    {\n\t\tvar1.vval.v_string = typval_tostring(&var1, TRUE);\n\t\tvar1.v_type = VAR_STRING;\n\t    }\n#endif\n\t    if (vim9script && rettv->v_type == VAR_LIST)\n\t\ttv_get_number_chk(&var1, &error);\n\t    else\n\t\terror = tv_get_string_chk(&var1) == NULL;\n\t    if (error)\n\t    {\n\t\t// not a number or string\n\t\tclear_tv(&var1);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t/*\n\t * Get the second variable from inside the [:].\n\t */\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg == ':')\n\t{\n\t    range = TRUE;\n\t    ++*arg;\n\t    if (vim9script && !IS_WHITE_OR_NUL(**arg) && **arg != ']')\n\t    {\n\t\tsemsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t\":\", *arg - 1);\n\t\tif (!empty1)\n\t\t    clear_tv(&var1);\n\t\treturn FAIL;\n\t    }\n\t    *arg = skipwhite_and_linebreak(*arg, evalarg);\n\t    if (**arg == ']')\n\t\tempty2 = TRUE;\n\t    else if (eval1(arg, &var2, evalarg) == FAIL)\t// recursive!\n\t    {\n\t\tif (!empty1)\n\t\t    clear_tv(&var1);\n\t\treturn FAIL;\n\t    }\n\t    else if (evaluate && tv_get_string_chk(&var2) == NULL)\n\t    {\n\t\t// not a number or string\n\t\tif (!empty1)\n\t\t    clear_tv(&var1);\n\t\tclear_tv(&var2);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t// Check for the ']'.\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg != ']')\n\t{\n\t    if (verbose)\n\t\temsg(_(e_missing_closing_square_brace));\n\t    clear_tv(&var1);\n\t    if (range)\n\t\tclear_tv(&var2);\n\t    return FAIL;\n\t}\n\t*arg = *arg + 1;\t// skip over the ']'\n    }\n\n    if (evaluate)\n    {\n\tint res = eval_index_inner(rettv, range,\n\t\tempty1 ? NULL : &var1, empty2 ? NULL : &var2, FALSE,\n\t\tkey, keylen, verbose);\n\n\tif (!empty1)\n\t    clear_tv(&var1);\n\tif (range)\n\t    clear_tv(&var2);\n\treturn res;\n    }\n    return OK;\n}\n\n/*\n * Check if \"rettv\" can have an [index] or [sli:ce]\n */\n    int\ncheck_can_index(typval_T *rettv, int evaluate, int verbose)\n{\n    switch (rettv->v_type)\n    {\n\tcase VAR_FUNC:\n\tcase VAR_PARTIAL:\n\t    if (verbose)\n\t\temsg(_(e_cannot_index_a_funcref));\n\t    return FAIL;\n\tcase VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t    if (verbose)\n\t\temsg(_(e_using_float_as_string));\n\t    return FAIL;\n#endif\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\tcase VAR_JOB:\n\tcase VAR_CHANNEL:\n\tcase VAR_INSTR:\n\t    if (verbose)\n\t\temsg(_(e_cannot_index_special_variable));\n\t    return FAIL;\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\t    if (evaluate)\n\t    {\n\t\temsg(_(e_cannot_index_special_variable));\n\t\treturn FAIL;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase VAR_STRING:\n\tcase VAR_LIST:\n\tcase VAR_DICT:\n\tcase VAR_BLOB:\n\t    break;\n\tcase VAR_NUMBER:\n\t    if (in_vim9script())\n\t\temsg(_(e_cannot_index_number));\n\t    break;\n    }\n    return OK;\n}\n\n/*\n * slice() function\n */\n    void\nf_slice(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script()\n\t    && ((argvars[0].v_type != VAR_STRING\n\t\t    && argvars[0].v_type != VAR_LIST\n\t\t    && argvars[0].v_type != VAR_BLOB\n\t\t    && check_for_list_arg(argvars, 0) == FAIL)\n\t\t|| check_for_number_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_number_arg(argvars, 2) == FAIL))\n\treturn;\n\n    if (check_can_index(argvars, TRUE, FALSE) == OK)\n    {\n\tcopy_tv(argvars, rettv);\n\teval_index_inner(rettv, TRUE, argvars + 1,\n\t\targvars[2].v_type == VAR_UNKNOWN ? NULL : argvars + 2,\n\t\tTRUE, NULL, 0, FALSE);\n    }\n}\n\n/*\n * Apply index or range to \"rettv\".\n * \"var1\" is the first index, NULL for [:expr].\n * \"var2\" is the second index, NULL for [expr] and [expr: ]\n * \"exclusive\" is TRUE for slice(): second index is exclusive, use character\n * index for string.\n * Alternatively, \"key\" is not NULL, then key[keylen] is the dict index.\n */\n    int\neval_index_inner(\n\ttypval_T    *rettv,\n\tint\t    is_range,\n\ttypval_T    *var1,\n\ttypval_T    *var2,\n\tint\t    exclusive,\n\tchar_u\t    *key,\n\tint\t    keylen,\n\tint\t    verbose)\n{\n    varnumber_T\t    n1, n2 = 0;\n    long\t    len;\n\n    n1 = 0;\n    if (var1 != NULL && rettv->v_type != VAR_DICT)\n\tn1 = tv_get_number(var1);\n\n    if (is_range)\n    {\n\tif (rettv->v_type == VAR_DICT)\n\t{\n\t    if (verbose)\n\t\temsg(_(e_cannot_slice_dictionary));\n\t    return FAIL;\n\t}\n\tif (var2 != NULL)\n\t    n2 = tv_get_number(var2);\n\telse\n\t    n2 = VARNUM_MAX;\n    }\n\n    switch (rettv->v_type)\n    {\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\tcase VAR_FUNC:\n\tcase VAR_PARTIAL:\n\tcase VAR_FLOAT:\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\tcase VAR_JOB:\n\tcase VAR_CHANNEL:\n\tcase VAR_INSTR:\n\t    break; // not evaluating, skipping over subscript\n\n\tcase VAR_NUMBER:\n\tcase VAR_STRING:\n\t    {\n\t\tchar_u\t*s = tv_get_string(rettv);\n\n\t\tlen = (long)STRLEN(s);\n\t\tif (in_vim9script() || exclusive)\n\t\t{\n\t\t    if (is_range)\n\t\t\ts = string_slice(s, n1, n2, exclusive);\n\t\t    else\n\t\t\ts = char_from_string(s, n1);\n\t\t}\n\t\telse if (is_range)\n\t\t{\n\t\t    // The resulting variable is a substring.  If the indexes\n\t\t    // are out of range the result is empty.\n\t\t    if (n1 < 0)\n\t\t    {\n\t\t\tn1 = len + n1;\n\t\t\tif (n1 < 0)\n\t\t\t    n1 = 0;\n\t\t    }\n\t\t    if (n2 < 0)\n\t\t\tn2 = len + n2;\n\t\t    else if (n2 >= len)\n\t\t\tn2 = len;\n\t\t    if (n1 >= len || n2 < 0 || n1 > n2)\n\t\t\ts = NULL;\n\t\t    else\n\t\t\ts = vim_strnsave(s + n1, n2 - n1 + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // The resulting variable is a string of a single\n\t\t    // character.  If the index is too big or negative the\n\t\t    // result is empty.\n\t\t    if (n1 >= len || n1 < 0)\n\t\t\ts = NULL;\n\t\t    else\n\t\t\ts = vim_strnsave(s + n1, 1);\n\t\t}\n\t\tclear_tv(rettv);\n\t\trettv->v_type = VAR_STRING;\n\t\trettv->vval.v_string = s;\n\t    }\n\t    break;\n\n\tcase VAR_BLOB:\n\t    blob_slice_or_index(rettv->vval.v_blob, is_range, n1, n2,\n\t\t\t\t\t\t\t     exclusive, rettv);\n\t    break;\n\n\tcase VAR_LIST:\n\t    if (var1 == NULL)\n\t\tn1 = 0;\n\t    if (var2 == NULL)\n\t\tn2 = VARNUM_MAX;\n\t    if (list_slice_or_index(rettv->vval.v_list,\n\t\t\t  is_range, n1, n2, exclusive, rettv, verbose) == FAIL)\n\t\treturn FAIL;\n\t    break;\n\n\tcase VAR_DICT:\n\t    {\n\t\tdictitem_T\t*item;\n\t\ttypval_T\ttmp;\n\n\t\tif (key == NULL)\n\t\t{\n\t\t    key = tv_get_string_chk(var1);\n\t\t    if (key == NULL)\n\t\t\treturn FAIL;\n\t\t}\n\n\t\titem = dict_find(rettv->vval.v_dict, key, keylen);\n\n\t\tif (item == NULL)\n\t\t{\n\t\t    if (verbose)\n\t\t    {\n\t\t\tif (keylen > 0)\n\t\t\t    key[keylen] = NUL;\n\t\t\tsemsg(_(e_key_not_present_in_dictionary), key);\n\t\t    }\n\t\t    return FAIL;\n\t\t}\n\n\t\tcopy_tv(&item->di_tv, &tmp);\n\t\tclear_tv(rettv);\n\t\t*rettv = tmp;\n\t    }\n\t    break;\n    }\n    return OK;\n}\n\n/*\n * Return the function name of partial \"pt\".\n */\n    char_u *\npartial_name(partial_T *pt)\n{\n    if (pt != NULL)\n    {\n\tif (pt->pt_name != NULL)\n\t    return pt->pt_name;\n\tif (pt->pt_func != NULL)\n\t    return pt->pt_func->uf_name;\n    }\n    return (char_u *)\"\";\n}\n\n    static void\npartial_free(partial_T *pt)\n{\n    int i;\n\n    for (i = 0; i < pt->pt_argc; ++i)\n\tclear_tv(&pt->pt_argv[i]);\n    vim_free(pt->pt_argv);\n    dict_unref(pt->pt_dict);\n    if (pt->pt_name != NULL)\n    {\n\tfunc_unref(pt->pt_name);\n\tvim_free(pt->pt_name);\n    }\n    else\n\tfunc_ptr_unref(pt->pt_func);\n\n    // \"out_up\" is no longer used, decrement refcount on partial that owns it.\n    partial_unref(pt->pt_outer.out_up_partial);\n\n    // Using pt_outer from another partial.\n    partial_unref(pt->pt_outer_partial);\n\n    // Decrease the reference count for the context of a closure.  If down\n    // to the minimum it may be time to free it.\n    if (pt->pt_funcstack != NULL)\n    {\n\t--pt->pt_funcstack->fs_refcount;\n\tfuncstack_check_refcount(pt->pt_funcstack);\n    }\n\n    vim_free(pt);\n}\n\n/*\n * Unreference a closure: decrement the reference count and free it when it\n * becomes zero.\n */\n    void\npartial_unref(partial_T *pt)\n{\n    if (pt != NULL)\n    {\n\tif (--pt->pt_refcount <= 0)\n\t    partial_free(pt);\n\n\t// If the reference count goes down to one, the funcstack may be the\n\t// only reference and can be freed if no other partials reference it.\n\telse if (pt->pt_refcount == 1 && pt->pt_funcstack != NULL)\n\t    funcstack_check_refcount(pt->pt_funcstack);\n    }\n}\n\n/*\n * Return the next (unique) copy ID.\n * Used for serializing nested structures.\n */\n    int\nget_copyID(void)\n{\n    current_copyID += COPYID_INC;\n    return current_copyID;\n}\n\n/*\n * Garbage collection for lists and dictionaries.\n *\n * We use reference counts to be able to free most items right away when they\n * are no longer used.  But for composite items it's possible that it becomes\n * unused while the reference count is > 0: When there is a recursive\n * reference.  Example:\n *\t:let l = [1, 2, 3]\n *\t:let d = {9: l}\n *\t:let l[1] = d\n *\n * Since this is quite unusual we handle this with garbage collection: every\n * once in a while find out which lists and dicts are not referenced from any\n * variable.\n *\n * Here is a good reference text about garbage collection (refers to Python\n * but it applies to all reference-counting mechanisms):\n *\thttp://python.ca/nas/python/gc/\n */\n\n/*\n * Do garbage collection for lists and dicts.\n * When \"testing\" is TRUE this is called from test_garbagecollect_now().\n * Return TRUE if some memory was freed.\n */\n    int\ngarbage_collect(int testing)\n{\n    int\t\tcopyID;\n    int\t\tabort = FALSE;\n    buf_T\t*buf;\n    win_T\t*wp;\n    int\t\tdid_free = FALSE;\n    tabpage_T\t*tp;\n\n    if (!testing)\n    {\n\t// Only do this once.\n\twant_garbage_collect = FALSE;\n\tmay_garbage_collect = FALSE;\n\tgarbage_collect_at_exit = FALSE;\n    }\n\n    // The execution stack can grow big, limit the size.\n    if (exestack.ga_maxlen - exestack.ga_len > 500)\n    {\n\tsize_t\tnew_len;\n\tchar_u\t*pp;\n\tint\tn;\n\n\t// Keep 150% of the current size, with a minimum of the growth size.\n\tn = exestack.ga_len / 2;\n\tif (n < exestack.ga_growsize)\n\t    n = exestack.ga_growsize;\n\n\t// Don't make it bigger though.\n\tif (exestack.ga_len + n < exestack.ga_maxlen)\n\t{\n\t    new_len = (size_t)exestack.ga_itemsize * (exestack.ga_len + n);\n\t    pp = vim_realloc(exestack.ga_data, new_len);\n\t    if (pp == NULL)\n\t\treturn FAIL;\n\t    exestack.ga_maxlen = exestack.ga_len + n;\n\t    exestack.ga_data = pp;\n\t}\n    }\n\n    // We advance by two because we add one for items referenced through\n    // previous_funccal.\n    copyID = get_copyID();\n\n    /*\n     * 1. Go through all accessible variables and mark all lists and dicts\n     *    with copyID.\n     */\n\n    // Don't free variables in the previous_funccal list unless they are only\n    // referenced through previous_funccal.  This must be first, because if\n    // the item is referenced elsewhere the funccal must not be freed.\n    abort = abort || set_ref_in_previous_funccal(copyID);\n\n    // script-local variables\n    abort = abort || garbage_collect_scriptvars(copyID);\n\n    // buffer-local variables\n    FOR_ALL_BUFFERS(buf)\n\tabort = abort || set_ref_in_item(&buf->b_bufvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n\n    // window-local variables\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tabort = abort || set_ref_in_item(&wp->w_winvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n    if (aucmd_win != NULL)\n\tabort = abort || set_ref_in_item(&aucmd_win->w_winvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n#ifdef FEAT_PROP_POPUP\n    FOR_ALL_POPUPWINS(wp)\n\tabort = abort || set_ref_in_item(&wp->w_winvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n    FOR_ALL_TABPAGES(tp)\n\tFOR_ALL_POPUPWINS_IN_TAB(tp, wp)\n\t\tabort = abort || set_ref_in_item(&wp->w_winvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n#endif\n\n    // tabpage-local variables\n    FOR_ALL_TABPAGES(tp)\n\tabort = abort || set_ref_in_item(&tp->tp_winvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n    // global variables\n    abort = abort || garbage_collect_globvars(copyID);\n\n    // function-local variables\n    abort = abort || set_ref_in_call_stack(copyID);\n\n    // named functions (matters for closures)\n    abort = abort || set_ref_in_functions(copyID);\n\n    // function call arguments, if v:testing is set.\n    abort = abort || set_ref_in_func_args(copyID);\n\n    // funcstacks keep variables for closures\n    abort = abort || set_ref_in_funcstacks(copyID);\n\n    // v: vars\n    abort = abort || garbage_collect_vimvars(copyID);\n\n    // callbacks in buffers\n    abort = abort || set_ref_in_buffers(copyID);\n\n    // 'completefunc', 'omnifunc' and 'thesaurusfunc' callbacks\n    abort = abort || set_ref_in_insexpand_funcs(copyID);\n\n    // 'operatorfunc' callback\n    abort = abort || set_ref_in_opfunc(copyID);\n\n    // 'tagfunc' callback\n    abort = abort || set_ref_in_tagfunc(copyID);\n\n    // 'imactivatefunc' and 'imstatusfunc' callbacks\n    abort = abort || set_ref_in_im_funcs(copyID);\n\n#ifdef FEAT_LUA\n    abort = abort || set_ref_in_lua(copyID);\n#endif\n\n#ifdef FEAT_PYTHON\n    abort = abort || set_ref_in_python(copyID);\n#endif\n\n#ifdef FEAT_PYTHON3\n    abort = abort || set_ref_in_python3(copyID);\n#endif\n\n#ifdef FEAT_JOB_CHANNEL\n    abort = abort || set_ref_in_channel(copyID);\n    abort = abort || set_ref_in_job(copyID);\n#endif\n#ifdef FEAT_NETBEANS_INTG\n    abort = abort || set_ref_in_nb_channel(copyID);\n#endif\n\n#ifdef FEAT_TIMERS\n    abort = abort || set_ref_in_timer(copyID);\n#endif\n\n#ifdef FEAT_QUICKFIX\n    abort = abort || set_ref_in_quickfix(copyID);\n#endif\n\n#ifdef FEAT_TERMINAL\n    abort = abort || set_ref_in_term(copyID);\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    abort = abort || set_ref_in_popups(copyID);\n#endif\n\n    if (!abort)\n    {\n\t/*\n\t * 2. Free lists and dictionaries that are not referenced.\n\t */\n\tdid_free = free_unref_items(copyID);\n\n\t/*\n\t * 3. Check if any funccal can be freed now.\n\t *    This may call us back recursively.\n\t */\n\tfree_unref_funccal(copyID, testing);\n    }\n    else if (p_verbose > 0)\n    {\n\tverb_msg(_(\"Not enough memory to set references, garbage collection aborted!\"));\n    }\n\n    return did_free;\n}\n\n/*\n * Free lists, dictionaries, channels and jobs that are no longer referenced.\n */\n    static int\nfree_unref_items(int copyID)\n{\n    int\t\tdid_free = FALSE;\n\n    // Let all \"free\" functions know that we are here.  This means no\n    // dictionaries, lists, channels or jobs are to be freed, because we will\n    // do that here.\n    in_free_unref_items = TRUE;\n\n    /*\n     * PASS 1: free the contents of the items.  We don't free the items\n     * themselves yet, so that it is possible to decrement refcount counters\n     */\n\n    // Go through the list of dicts and free items without the copyID.\n    did_free |= dict_free_nonref(copyID);\n\n    // Go through the list of lists and free items without the copyID.\n    did_free |= list_free_nonref(copyID);\n\n#ifdef FEAT_JOB_CHANNEL\n    // Go through the list of jobs and free items without the copyID. This\n    // must happen before doing channels, because jobs refer to channels, but\n    // the reference from the channel to the job isn't tracked.\n    did_free |= free_unused_jobs_contents(copyID, COPYID_MASK);\n\n    // Go through the list of channels and free items without the copyID.\n    did_free |= free_unused_channels_contents(copyID, COPYID_MASK);\n#endif\n\n    /*\n     * PASS 2: free the items themselves.\n     */\n    dict_free_items(copyID);\n    list_free_items(copyID);\n\n#ifdef FEAT_JOB_CHANNEL\n    // Go through the list of jobs and free items without the copyID. This\n    // must happen before doing channels, because jobs refer to channels, but\n    // the reference from the channel to the job isn't tracked.\n    free_unused_jobs(copyID, COPYID_MASK);\n\n    // Go through the list of channels and free items without the copyID.\n    free_unused_channels(copyID, COPYID_MASK);\n#endif\n\n    in_free_unref_items = FALSE;\n\n    return did_free;\n}\n\n/*\n * Mark all lists and dicts referenced through hashtab \"ht\" with \"copyID\".\n * \"list_stack\" is used to add lists to be marked.  Can be NULL.\n *\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_ht(hashtab_T *ht, int copyID, list_stack_T **list_stack)\n{\n    int\t\ttodo;\n    int\t\tabort = FALSE;\n    hashitem_T\t*hi;\n    hashtab_T\t*cur_ht;\n    ht_stack_T\t*ht_stack = NULL;\n    ht_stack_T\t*tempitem;\n\n    cur_ht = ht;\n    for (;;)\n    {\n\tif (!abort)\n\t{\n\t    // Mark each item in the hashtab.  If the item contains a hashtab\n\t    // it is added to ht_stack, if it contains a list it is added to\n\t    // list_stack.\n\t    todo = (int)cur_ht->ht_used;\n\t    for (hi = cur_ht->ht_array; todo > 0; ++hi)\n\t\tif (!HASHITEM_EMPTY(hi))\n\t\t{\n\t\t    --todo;\n\t\t    abort = abort || set_ref_in_item(&HI2DI(hi)->di_tv, copyID,\n\t\t\t\t\t\t       &ht_stack, list_stack);\n\t\t}\n\t}\n\n\tif (ht_stack == NULL)\n\t    break;\n\n\t// take an item from the stack\n\tcur_ht = ht_stack->ht;\n\ttempitem = ht_stack;\n\tht_stack = ht_stack->prev;\n\tfree(tempitem);\n    }\n\n    return abort;\n}\n\n#if defined(FEAT_LUA) || defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) \\\n\t\t\t\t\t\t\t|| defined(PROTO)\n/*\n * Mark a dict and its items with \"copyID\".\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_dict(dict_T *d, int copyID)\n{\n    if (d != NULL && d->dv_copyID != copyID)\n    {\n\td->dv_copyID = copyID;\n\treturn set_ref_in_ht(&d->dv_hashtab, copyID, NULL);\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Mark a list and its items with \"copyID\".\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_list(list_T *ll, int copyID)\n{\n    if (ll != NULL && ll->lv_copyID != copyID)\n    {\n\tll->lv_copyID = copyID;\n\treturn set_ref_in_list_items(ll, copyID, NULL);\n    }\n    return FALSE;\n}\n\n/*\n * Mark all lists and dicts referenced through list \"l\" with \"copyID\".\n * \"ht_stack\" is used to add hashtabs to be marked.  Can be NULL.\n *\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_list_items(list_T *l, int copyID, ht_stack_T **ht_stack)\n{\n    listitem_T\t *li;\n    int\t\t abort = FALSE;\n    list_T\t *cur_l;\n    list_stack_T *list_stack = NULL;\n    list_stack_T *tempitem;\n\n    cur_l = l;\n    for (;;)\n    {\n\tif (!abort && cur_l->lv_first != &range_list_item)\n\t    // Mark each item in the list.  If the item contains a hashtab\n\t    // it is added to ht_stack, if it contains a list it is added to\n\t    // list_stack.\n\t    for (li = cur_l->lv_first; !abort && li != NULL; li = li->li_next)\n\t\tabort = abort || set_ref_in_item(&li->li_tv, copyID,\n\t\t\t\t\t\t       ht_stack, &list_stack);\n\tif (list_stack == NULL)\n\t    break;\n\n\t// take an item from the stack\n\tcur_l = list_stack->list;\n\ttempitem = list_stack;\n\tlist_stack = list_stack->prev;\n\tfree(tempitem);\n    }\n\n    return abort;\n}\n\n/*\n * Mark the partial in callback 'cb' with \"copyID\".\n */\n    int\nset_ref_in_callback(callback_T *cb, int copyID)\n{\n    typval_T tv;\n\n    if (cb->cb_name == NULL || *cb->cb_name == NUL || cb->cb_partial == NULL)\n\treturn FALSE;\n\n    tv.v_type = VAR_PARTIAL;\n    tv.vval.v_partial = cb->cb_partial;\n    return set_ref_in_item(&tv, copyID, NULL, NULL);\n}\n\n/*\n * Mark all lists and dicts referenced through typval \"tv\" with \"copyID\".\n * \"list_stack\" is used to add lists to be marked.  Can be NULL.\n * \"ht_stack\" is used to add hashtabs to be marked.  Can be NULL.\n *\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_item(\n    typval_T\t    *tv,\n    int\t\t    copyID,\n    ht_stack_T\t    **ht_stack,\n    list_stack_T    **list_stack)\n{\n    int\t\tabort = FALSE;\n\n    if (tv->v_type == VAR_DICT)\n    {\n\tdict_T\t*dd = tv->vval.v_dict;\n\n\tif (dd != NULL && dd->dv_copyID != copyID)\n\t{\n\t    // Didn't see this dict yet.\n\t    dd->dv_copyID = copyID;\n\t    if (ht_stack == NULL)\n\t    {\n\t\tabort = set_ref_in_ht(&dd->dv_hashtab, copyID, list_stack);\n\t    }\n\t    else\n\t    {\n\t\tht_stack_T *newitem = ALLOC_ONE(ht_stack_T);\n\n\t\tif (newitem == NULL)\n\t\t    abort = TRUE;\n\t\telse\n\t\t{\n\t\t    newitem->ht = &dd->dv_hashtab;\n\t\t    newitem->prev = *ht_stack;\n\t\t    *ht_stack = newitem;\n\t\t}\n\t    }\n\t}\n    }\n    else if (tv->v_type == VAR_LIST)\n    {\n\tlist_T\t*ll = tv->vval.v_list;\n\n\tif (ll != NULL && ll->lv_copyID != copyID)\n\t{\n\t    // Didn't see this list yet.\n\t    ll->lv_copyID = copyID;\n\t    if (list_stack == NULL)\n\t    {\n\t\tabort = set_ref_in_list_items(ll, copyID, ht_stack);\n\t    }\n\t    else\n\t    {\n\t\tlist_stack_T *newitem = ALLOC_ONE(list_stack_T);\n\n\t\tif (newitem == NULL)\n\t\t    abort = TRUE;\n\t\telse\n\t\t{\n\t\t    newitem->list = ll;\n\t\t    newitem->prev = *list_stack;\n\t\t    *list_stack = newitem;\n\t\t}\n\t    }\n\t}\n    }\n    else if (tv->v_type == VAR_FUNC)\n    {\n\tabort = set_ref_in_func(tv->vval.v_string, NULL, copyID);\n    }\n    else if (tv->v_type == VAR_PARTIAL)\n    {\n\tpartial_T\t*pt = tv->vval.v_partial;\n\tint\t\ti;\n\n\tif (pt != NULL && pt->pt_copyID != copyID)\n\t{\n\t    // Didn't see this partial yet.\n\t    pt->pt_copyID = copyID;\n\n\t    abort = set_ref_in_func(pt->pt_name, pt->pt_func, copyID);\n\n\t    if (pt->pt_dict != NULL)\n\t    {\n\t\ttypval_T dtv;\n\n\t\tdtv.v_type = VAR_DICT;\n\t\tdtv.vval.v_dict = pt->pt_dict;\n\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t    }\n\n\t    for (i = 0; i < pt->pt_argc; ++i)\n\t\tabort = abort || set_ref_in_item(&pt->pt_argv[i], copyID,\n\t\t\t\t\t\t\tht_stack, list_stack);\n\t    // pt_funcstack is handled in set_ref_in_funcstacks()\n\t}\n    }\n#ifdef FEAT_JOB_CHANNEL\n    else if (tv->v_type == VAR_JOB)\n    {\n\tjob_T\t    *job = tv->vval.v_job;\n\ttypval_T    dtv;\n\n\tif (job != NULL && job->jv_copyID != copyID)\n\t{\n\t    job->jv_copyID = copyID;\n\t    if (job->jv_channel != NULL)\n\t    {\n\t\tdtv.v_type = VAR_CHANNEL;\n\t\tdtv.vval.v_channel = job->jv_channel;\n\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t    }\n\t    if (job->jv_exit_cb.cb_partial != NULL)\n\t    {\n\t\tdtv.v_type = VAR_PARTIAL;\n\t\tdtv.vval.v_partial = job->jv_exit_cb.cb_partial;\n\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t    }\n\t}\n    }\n    else if (tv->v_type == VAR_CHANNEL)\n    {\n\tchannel_T   *ch =tv->vval.v_channel;\n\tch_part_T   part;\n\ttypval_T    dtv;\n\tjsonq_T\t    *jq;\n\tcbq_T\t    *cq;\n\n\tif (ch != NULL && ch->ch_copyID != copyID)\n\t{\n\t    ch->ch_copyID = copyID;\n\t    for (part = PART_SOCK; part < PART_COUNT; ++part)\n\t    {\n\t\tfor (jq = ch->ch_part[part].ch_json_head.jq_next; jq != NULL;\n\t\t\t\t\t\t\t     jq = jq->jq_next)\n\t\t    set_ref_in_item(jq->jq_value, copyID, ht_stack, list_stack);\n\t\tfor (cq = ch->ch_part[part].ch_cb_head.cq_next; cq != NULL;\n\t\t\t\t\t\t\t     cq = cq->cq_next)\n\t\t    if (cq->cq_callback.cb_partial != NULL)\n\t\t    {\n\t\t\tdtv.v_type = VAR_PARTIAL;\n\t\t\tdtv.vval.v_partial = cq->cq_callback.cb_partial;\n\t\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t\t    }\n\t\tif (ch->ch_part[part].ch_callback.cb_partial != NULL)\n\t\t{\n\t\t    dtv.v_type = VAR_PARTIAL;\n\t\t    dtv.vval.v_partial =\n\t\t\t\t      ch->ch_part[part].ch_callback.cb_partial;\n\t\t    set_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t\t}\n\t    }\n\t    if (ch->ch_callback.cb_partial != NULL)\n\t    {\n\t\tdtv.v_type = VAR_PARTIAL;\n\t\tdtv.vval.v_partial = ch->ch_callback.cb_partial;\n\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t    }\n\t    if (ch->ch_close_cb.cb_partial != NULL)\n\t    {\n\t\tdtv.v_type = VAR_PARTIAL;\n\t\tdtv.vval.v_partial = ch->ch_close_cb.cb_partial;\n\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t    }\n\t}\n    }\n#endif\n    return abort;\n}\n\n/*\n * Return a string with the string representation of a variable.\n * If the memory is allocated \"tofree\" is set to it, otherwise NULL.\n * \"numbuf\" is used for a number.\n * When \"copyID\" is not NULL replace recursive lists and dicts with \"...\".\n * When both \"echo_style\" and \"composite_val\" are FALSE, put quotes around\n * strings as \"string()\", otherwise does not put quotes around strings, as\n * \":echo\" displays values.\n * When \"restore_copyID\" is FALSE, repeated items in dictionaries and lists\n * are replaced with \"...\".\n * May return NULL.\n */\n    char_u *\necho_string_core(\n    typval_T\t*tv,\n    char_u\t**tofree,\n    char_u\t*numbuf,\n    int\t\tcopyID,\n    int\t\techo_style,\n    int\t\trestore_copyID,\n    int\t\tcomposite_val)\n{\n    static int\trecurse = 0;\n    char_u\t*r = NULL;\n\n    if (recurse >= DICT_MAXNEST)\n    {\n\tif (!did_echo_string_emsg)\n\t{\n\t    // Only give this message once for a recursive call to avoid\n\t    // flooding the user with errors.  And stop iterating over lists\n\t    // and dicts.\n\t    did_echo_string_emsg = TRUE;\n\t    emsg(_(e_variable_nested_too_deep_for_displaying));\n\t}\n\t*tofree = NULL;\n\treturn (char_u *)\"{E724}\";\n    }\n    ++recurse;\n\n    switch (tv->v_type)\n    {\n\tcase VAR_STRING:\n\t    if (echo_style && !composite_val)\n\t    {\n\t\t*tofree = NULL;\n\t\tr = tv->vval.v_string;\n\t\tif (r == NULL)\n\t\t    r = (char_u *)\"\";\n\t    }\n\t    else\n\t    {\n\t\t*tofree = string_quote(tv->vval.v_string, FALSE);\n\t\tr = *tofree;\n\t    }\n\t    break;\n\n\tcase VAR_FUNC:\n\t    {\n\t\tchar_u buf[MAX_FUNC_NAME_LEN];\n\n\t\tif (echo_style)\n\t\t{\n\t\t    r = tv->vval.v_string == NULL ? (char_u *)\"function()\"\n\t\t\t\t  : make_ufunc_name_readable(tv->vval.v_string,\n\t\t\t\t\t\t       buf, MAX_FUNC_NAME_LEN);\n\t\t    if (r == buf)\n\t\t    {\n\t\t\tr = vim_strsave(buf);\n\t\t\t*tofree = r;\n\t\t    }\n\t\t    else\n\t\t\t*tofree = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    *tofree = string_quote(tv->vval.v_string == NULL ? NULL\n\t\t\t    : make_ufunc_name_readable(\n\t\t\t\ttv->vval.v_string, buf, MAX_FUNC_NAME_LEN),\n\t\t\t\t\t\t\t\t\t TRUE);\n\t\t    r = *tofree;\n\t\t}\n\t    }\n\t    break;\n\n\tcase VAR_PARTIAL:\n\t    {\n\t\tpartial_T   *pt = tv->vval.v_partial;\n\t\tchar_u\t    *fname = string_quote(pt == NULL ? NULL\n\t\t\t\t\t\t    : partial_name(pt), FALSE);\n\t\tgarray_T    ga;\n\t\tint\t    i;\n\t\tchar_u\t    *tf;\n\n\t\tga_init2(&ga, 1, 100);\n\t\tga_concat(&ga, (char_u *)\"function(\");\n\t\tif (fname != NULL)\n\t\t{\n\t\t    // When using uf_name prepend \"g:\" for a global function.\n\t\t    if (pt != NULL && pt->pt_name == NULL && fname[0] == '\\''\n\t\t\t\t\t\t      && vim_isupper(fname[1]))\n\t\t    {\n\t\t\tga_concat(&ga, (char_u *)\"'g:\");\n\t\t\tga_concat(&ga, fname + 1);\n\t\t    }\n\t\t    else\n\t\t\tga_concat(&ga, fname);\n\t\t    vim_free(fname);\n\t\t}\n\t\tif (pt != NULL && pt->pt_argc > 0)\n\t\t{\n\t\t    ga_concat(&ga, (char_u *)\", [\");\n\t\t    for (i = 0; i < pt->pt_argc; ++i)\n\t\t    {\n\t\t\tif (i > 0)\n\t\t\t    ga_concat(&ga, (char_u *)\", \");\n\t\t\tga_concat(&ga,\n\t\t\t     tv2string(&pt->pt_argv[i], &tf, numbuf, copyID));\n\t\t\tvim_free(tf);\n\t\t    }\n\t\t    ga_concat(&ga, (char_u *)\"]\");\n\t\t}\n\t\tif (pt != NULL && pt->pt_dict != NULL)\n\t\t{\n\t\t    typval_T dtv;\n\n\t\t    ga_concat(&ga, (char_u *)\", \");\n\t\t    dtv.v_type = VAR_DICT;\n\t\t    dtv.vval.v_dict = pt->pt_dict;\n\t\t    ga_concat(&ga, tv2string(&dtv, &tf, numbuf, copyID));\n\t\t    vim_free(tf);\n\t\t}\n\t\t// terminate with ')' and a NUL\n\t\tga_concat_len(&ga, (char_u *)\")\", 2);\n\n\t\t*tofree = ga.ga_data;\n\t\tr = *tofree;\n\t\tbreak;\n\t    }\n\n\tcase VAR_BLOB:\n\t    r = blob2string(tv->vval.v_blob, tofree, numbuf);\n\t    break;\n\n\tcase VAR_LIST:\n\t    if (tv->vval.v_list == NULL)\n\t    {\n\t\t// NULL list is equivalent to empty list.\n\t\t*tofree = NULL;\n\t\tr = (char_u *)\"[]\";\n\t    }\n\t    else if (copyID != 0 && tv->vval.v_list->lv_copyID == copyID\n\t\t    && tv->vval.v_list->lv_len > 0)\n\t    {\n\t\t*tofree = NULL;\n\t\tr = (char_u *)\"[...]\";\n\t    }\n\t    else\n\t    {\n\t\tint old_copyID = tv->vval.v_list->lv_copyID;\n\n\t\ttv->vval.v_list->lv_copyID = copyID;\n\t\t*tofree = list2string(tv, copyID, restore_copyID);\n\t\tif (restore_copyID)\n\t\t    tv->vval.v_list->lv_copyID = old_copyID;\n\t\tr = *tofree;\n\t    }\n\t    break;\n\n\tcase VAR_DICT:\n\t    if (tv->vval.v_dict == NULL)\n\t    {\n\t\t// NULL dict is equivalent to empty dict.\n\t\t*tofree = NULL;\n\t\tr = (char_u *)\"{}\";\n\t    }\n\t    else if (copyID != 0 && tv->vval.v_dict->dv_copyID == copyID\n\t\t    && tv->vval.v_dict->dv_hashtab.ht_used != 0)\n\t    {\n\t\t*tofree = NULL;\n\t\tr = (char_u *)\"{...}\";\n\t    }\n\t    else\n\t    {\n\t\tint old_copyID = tv->vval.v_dict->dv_copyID;\n\n\t\ttv->vval.v_dict->dv_copyID = copyID;\n\t\t*tofree = dict2string(tv, copyID, restore_copyID);\n\t\tif (restore_copyID)\n\t\t    tv->vval.v_dict->dv_copyID = old_copyID;\n\t\tr = *tofree;\n\t    }\n\t    break;\n\n\tcase VAR_NUMBER:\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\t    *tofree = NULL;\n\t    r = tv_get_string_buf(tv, numbuf);\n\t    break;\n\n\tcase VAR_JOB:\n\tcase VAR_CHANNEL:\n#ifdef FEAT_JOB_CHANNEL\n\t    *tofree = NULL;\n\t    r = tv->v_type == VAR_JOB ? job_to_string_buf(tv, numbuf)\n\t\t\t\t\t   : channel_to_string_buf(tv, numbuf);\n\t    if (composite_val)\n\t    {\n\t\t*tofree = string_quote(r, FALSE);\n\t\tr = *tofree;\n\t    }\n#endif\n\t    break;\n\n\tcase VAR_INSTR:\n\t    *tofree = NULL;\n\t    r = (char_u *)\"instructions\";\n\t    break;\n\n\tcase VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t    *tofree = NULL;\n\t    vim_snprintf((char *)numbuf, NUMBUFLEN, \"%g\", tv->vval.v_float);\n\t    r = numbuf;\n\t    break;\n#endif\n\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\t    *tofree = NULL;\n\t    r = (char_u *)get_var_special_name(tv->vval.v_number);\n\t    break;\n    }\n\n    if (--recurse == 0)\n\tdid_echo_string_emsg = FALSE;\n    return r;\n}\n\n/*\n * Return a string with the string representation of a variable.\n * If the memory is allocated \"tofree\" is set to it, otherwise NULL.\n * \"numbuf\" is used for a number.\n * Does not put quotes around strings, as \":echo\" displays values.\n * When \"copyID\" is not NULL replace recursive lists and dicts with \"...\".\n * May return NULL.\n */\n    char_u *\necho_string(\n    typval_T\t*tv,\n    char_u\t**tofree,\n    char_u\t*numbuf,\n    int\t\tcopyID)\n{\n    return echo_string_core(tv, tofree, numbuf, copyID, TRUE, FALSE, FALSE);\n}\n\n/*\n * Convert the specified byte index of line 'lnum' in buffer 'buf' to a\n * character index.  Works only for loaded buffers. Returns -1 on failure.\n * The index of the first byte and the first character is zero.\n */\n    int\nbuf_byteidx_to_charidx(buf_T *buf, int lnum, int byteidx)\n{\n    char_u\t*str;\n    char_u\t*t;\n    int\t\tcount;\n\n    if (buf == NULL || buf->b_ml.ml_mfp == NULL)\n\treturn -1;\n\n    if (lnum > buf->b_ml.ml_line_count)\n\tlnum = buf->b_ml.ml_line_count;\n\n    str = ml_get_buf(buf, lnum, FALSE);\n    if (str == NULL)\n\treturn -1;\n\n    if (*str == NUL)\n\treturn 0;\n\n    // count the number of characters\n    t = str;\n    for (count = 0; *t != NUL && t <= str + byteidx; count++)\n\tt += mb_ptr2len(t);\n\n    // In insert mode, when the cursor is at the end of a non-empty line,\n    // byteidx points to the NUL character immediately past the end of the\n    // string. In this case, add one to the character count.\n    if (*t == NUL && byteidx != 0 && t == str + byteidx)\n\tcount++;\n\n    return count - 1;\n}\n\n/*\n * Convert the specified character index of line 'lnum' in buffer 'buf' to a\n * byte index.  Works only for loaded buffers. Returns -1 on failure.\n * The index of the first byte and the first character is zero.\n */\n    int\nbuf_charidx_to_byteidx(buf_T *buf, int lnum, int charidx)\n{\n    char_u\t*str;\n    char_u\t*t;\n\n    if (buf == NULL || buf->b_ml.ml_mfp == NULL)\n\treturn -1;\n\n    if (lnum > buf->b_ml.ml_line_count)\n\tlnum = buf->b_ml.ml_line_count;\n\n    str = ml_get_buf(buf, lnum, FALSE);\n    if (str == NULL)\n\treturn -1;\n\n    // Convert the character offset to a byte offset\n    t = str;\n    while (*t != NUL && --charidx > 0)\n\tt += mb_ptr2len(t);\n\n    return t - str;\n}\n\n/*\n * Translate a String variable into a position.\n * Returns NULL when there is an error.\n */\n    pos_T *\nvar2fpos(\n    typval_T\t*varp,\n    int\t\tdollar_lnum,\t// TRUE when $ is last line\n    int\t\t*fnum,\t\t// set to fnum for '0, 'A, etc.\n    int\t\tcharcol)\t// return character column\n{\n    char_u\t\t*name;\n    static pos_T\tpos;\n    pos_T\t\t*pp;\n\n    // Argument can be [lnum, col, coladd].\n    if (varp->v_type == VAR_LIST)\n    {\n\tlist_T\t\t*l;\n\tint\t\tlen;\n\tint\t\terror = FALSE;\n\tlistitem_T\t*li;\n\n\tl = varp->vval.v_list;\n\tif (l == NULL)\n\t    return NULL;\n\n\t// Get the line number\n\tpos.lnum = list_find_nr(l, 0L, &error);\n\tif (error || pos.lnum <= 0 || pos.lnum > curbuf->b_ml.ml_line_count)\n\t    return NULL;\t// invalid line number\n\tif (charcol)\n\t    len = (long)mb_charlen(ml_get(pos.lnum));\n\telse\n\t    len = (long)STRLEN(ml_get(pos.lnum));\n\n\t// Get the column number\n\t// We accept \"$\" for the column number: last column.\n\tli = list_find(l, 1L);\n\tif (li != NULL && li->li_tv.v_type == VAR_STRING\n\t\t&& li->li_tv.vval.v_string != NULL\n\t\t&& STRCMP(li->li_tv.vval.v_string, \"$\") == 0)\n\t{\n\t    pos.col = len + 1;\n\t}\n\telse\n\t{\n\t    pos.col = list_find_nr(l, 1L, &error);\n\t    if (error)\n\t\treturn NULL;\n\t}\n\n\t// Accept a position up to the NUL after the line.\n\tif (pos.col == 0 || (int)pos.col > len + 1)\n\t    return NULL;\t// invalid column number\n\t--pos.col;\n\n\t// Get the virtual offset.  Defaults to zero.\n\tpos.coladd = list_find_nr(l, 2L, &error);\n\tif (error)\n\t    pos.coladd = 0;\n\n\treturn &pos;\n    }\n\n    if (in_vim9script() && check_for_string_arg(varp, 0) == FAIL)\n\treturn NULL;\n\n    name = tv_get_string_chk(varp);\n    if (name == NULL)\n\treturn NULL;\n\n    pos.lnum = 0;\n    if (name[0] == '.' && (!in_vim9script() || name[1] == NUL))\n    {\n\t// cursor\n\tpos = curwin->w_cursor;\n    }\n    else if (name[0] == 'v' && name[1] == NUL)\n    {\n\t// Visual start\n\tif (VIsual_active)\n\t    pos = VIsual;\n\telse\n\t    pos = curwin->w_cursor;\n    }\n    else if (name[0] == '\\'' && (!in_vim9script()\n\t\t\t\t\t|| (name[1] != NUL && name[2] == NUL)))\n    {\n\t// mark\n\tpp = getmark_buf_fnum(curbuf, name[1], FALSE, fnum);\n\tif (pp == NULL || pp == (pos_T *)-1 || pp->lnum <= 0)\n\t    return NULL;\n\tpos = *pp;\n    }\n    if (pos.lnum != 0)\n    {\n\tif (charcol)\n\t    pos.col = buf_byteidx_to_charidx(curbuf, pos.lnum, pos.col);\n\treturn &pos;\n    }\n\n    pos.coladd = 0;\n\n    if (name[0] == 'w' && dollar_lnum)\n    {\n\tpos.col = 0;\n\tif (name[1] == '0')\t\t// \"w0\": first visible line\n\t{\n\t    update_topline();\n\t    // In silent Ex mode topline is zero, but that's not a valid line\n\t    // number; use one instead.\n\t    pos.lnum = curwin->w_topline > 0 ? curwin->w_topline : 1;\n\t    return &pos;\n\t}\n\telse if (name[1] == '$')\t// \"w$\": last visible line\n\t{\n\t    validate_botline();\n\t    // In silent Ex mode botline is zero, return zero then.\n\t    pos.lnum = curwin->w_botline > 0 ? curwin->w_botline - 1 : 0;\n\t    return &pos;\n\t}\n    }\n    else if (name[0] == '$')\t\t// last column or line\n    {\n\tif (dollar_lnum)\n\t{\n\t    pos.lnum = curbuf->b_ml.ml_line_count;\n\t    pos.col = 0;\n\t}\n\telse\n\t{\n\t    pos.lnum = curwin->w_cursor.lnum;\n\t    if (charcol)\n\t\tpos.col = (colnr_T)mb_charlen(ml_get_curline());\n\t    else\n\t\tpos.col = (colnr_T)STRLEN(ml_get_curline());\n\t}\n\treturn &pos;\n    }\n    if (in_vim9script())\n\tsemsg(_(e_invalid_value_for_line_number_str), name);\n    return NULL;\n}\n\n/*\n * Convert list in \"arg\" into a position and optional file number.\n * When \"fnump\" is NULL there is no file number, only 3 items.\n * Note that the column is passed on as-is, the caller may want to decrement\n * it to use 1 for the first column.\n * Return FAIL when conversion is not possible, doesn't check the position for\n * validity.\n */\n    int\nlist2fpos(\n    typval_T\t*arg,\n    pos_T\t*posp,\n    int\t\t*fnump,\n    colnr_T\t*curswantp,\n    int\t\tcharcol)\n{\n    list_T\t*l = arg->vval.v_list;\n    long\ti = 0;\n    long\tn;\n\n    // List must be: [fnum, lnum, col, coladd, curswant], where \"fnum\" is only\n    // there when \"fnump\" isn't NULL; \"coladd\" and \"curswant\" are optional.\n    if (arg->v_type != VAR_LIST\n\t    || l == NULL\n\t    || l->lv_len < (fnump == NULL ? 2 : 3)\n\t    || l->lv_len > (fnump == NULL ? 4 : 5))\n\treturn FAIL;\n\n    if (fnump != NULL)\n    {\n\tn = list_find_nr(l, i++, NULL);\t// fnum\n\tif (n < 0)\n\t    return FAIL;\n\tif (n == 0)\n\t    n = curbuf->b_fnum;\t\t// current buffer\n\t*fnump = n;\n    }\n\n    n = list_find_nr(l, i++, NULL);\t// lnum\n    if (n < 0)\n\treturn FAIL;\n    posp->lnum = n;\n\n    n = list_find_nr(l, i++, NULL);\t// col\n    if (n < 0)\n\treturn FAIL;\n    // If character position is specified, then convert to byte position\n    if (charcol)\n    {\n\tbuf_T\t*buf;\n\n\t// Get the text for the specified line in a loaded buffer\n\tbuf = buflist_findnr(fnump == NULL ? curbuf->b_fnum : *fnump);\n\tif (buf == NULL || buf->b_ml.ml_mfp == NULL)\n\t    return FAIL;\n\n\tn = buf_charidx_to_byteidx(buf, posp->lnum, n) + 1;\n    }\n    posp->col = n;\n\n    n = list_find_nr(l, i, NULL);\t// off\n    if (n < 0)\n\tposp->coladd = 0;\n    else\n\tposp->coladd = n;\n\n    if (curswantp != NULL)\n\t*curswantp = list_find_nr(l, i + 1, NULL);  // curswant\n\n    return OK;\n}\n\n/*\n * Get the length of an environment variable name.\n * Advance \"arg\" to the first character after the name.\n * Return 0 for error.\n */\n    int\nget_env_len(char_u **arg)\n{\n    char_u\t*p;\n    int\t\tlen;\n\n    for (p = *arg; vim_isIDc(*p); ++p)\n\t;\n    if (p == *arg)\t    // no name found\n\treturn 0;\n\n    len = (int)(p - *arg);\n    *arg = p;\n    return len;\n}\n\n/*\n * Get the length of the name of a function or internal variable.\n * \"arg\" is advanced to after the name.\n * Return 0 if something is wrong.\n */\n    int\nget_id_len(char_u **arg)\n{\n    char_u\t*p;\n    int\t\tlen;\n\n    // Find the end of the name.\n    for (p = *arg; eval_isnamec(*p); ++p)\n    {\n\tif (*p == ':')\n\t{\n\t    // \"s:\" is start of \"s:var\", but \"n:\" is not and can be used in\n\t    // slice \"[n:]\".  Also \"xx:\" is not a namespace.\n\t    len = (int)(p - *arg);\n\t    if ((len == 1 && vim_strchr(NAMESPACE_CHAR, **arg) == NULL)\n\t\t    || len > 1)\n\t\tbreak;\n\t}\n    }\n    if (p == *arg)\t    // no name found\n\treturn 0;\n\n    len = (int)(p - *arg);\n    *arg = p;\n\n    return len;\n}\n\n/*\n * Get the length of the name of a variable or function.\n * Only the name is recognized, does not handle \".key\" or \"[idx]\".\n * \"arg\" is advanced to the first non-white character after the name.\n * Return -1 if curly braces expansion failed.\n * Return 0 if something else is wrong.\n * If the name contains 'magic' {}'s, expand them and return the\n * expanded name in an allocated string via 'alias' - caller must free.\n */\n    int\nget_name_len(\n    char_u\t**arg,\n    char_u\t**alias,\n    int\t\tevaluate,\n    int\t\tverbose)\n{\n    int\t\tlen;\n    char_u\t*p;\n    char_u\t*expr_start;\n    char_u\t*expr_end;\n\n    *alias = NULL;  // default to no alias\n\n    if ((*arg)[0] == K_SPECIAL && (*arg)[1] == KS_EXTRA\n\t\t\t\t\t\t  && (*arg)[2] == (int)KE_SNR)\n    {\n\t// hard coded <SNR>, already translated\n\t*arg += 3;\n\treturn get_id_len(arg) + 3;\n    }\n    len = eval_fname_script(*arg);\n    if (len > 0)\n    {\n\t// literal \"<SID>\", \"s:\" or \"<SNR>\"\n\t*arg += len;\n    }\n\n    /*\n     * Find the end of the name; check for {} construction.\n     */\n    p = find_name_end(*arg, &expr_start, &expr_end,\n\t\t\t\t\t       len > 0 ? 0 : FNE_CHECK_START);\n    if (expr_start != NULL)\n    {\n\tchar_u\t*temp_string;\n\n\tif (!evaluate)\n\t{\n\t    len += (int)(p - *arg);\n\t    *arg = skipwhite(p);\n\t    return len;\n\t}\n\n\t/*\n\t * Include any <SID> etc in the expanded string:\n\t * Thus the -len here.\n\t */\n\ttemp_string = make_expanded_name(*arg - len, expr_start, expr_end, p);\n\tif (temp_string == NULL)\n\t    return -1;\n\t*alias = temp_string;\n\t*arg = skipwhite(p);\n\treturn (int)STRLEN(temp_string);\n    }\n\n    len += get_id_len(arg);\n    // Only give an error when there is something, otherwise it will be\n    // reported at a higher level.\n    if (len == 0 && verbose && **arg != NUL)\n\tsemsg(_(e_invalid_expression_str), *arg);\n\n    return len;\n}\n\n/*\n * Find the end of a variable or function name, taking care of magic braces.\n * If \"expr_start\" is not NULL then \"expr_start\" and \"expr_end\" are set to the\n * start and end of the first magic braces item.\n * \"flags\" can have FNE_INCL_BR and FNE_CHECK_START.\n * Return a pointer to just after the name.  Equal to \"arg\" if there is no\n * valid name.\n */\n    char_u *\nfind_name_end(\n    char_u\t*arg,\n    char_u\t**expr_start,\n    char_u\t**expr_end,\n    int\t\tflags)\n{\n    int\t\tmb_nest = 0;\n    int\t\tbr_nest = 0;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\tvim9script = in_vim9script();\n\n    if (expr_start != NULL)\n    {\n\t*expr_start = NULL;\n\t*expr_end = NULL;\n    }\n\n    // Quick check for valid starting character.\n    if ((flags & FNE_CHECK_START) && !eval_isnamec1(*arg)\n\t\t\t\t\t\t&& (*arg != '{' || vim9script))\n\treturn arg;\n\n    for (p = arg; *p != NUL\n\t\t    && (eval_isnamec(*p)\n\t\t\t|| (*p == '{' && !vim9script)\n\t\t\t|| ((flags & FNE_INCL_BR) && (*p == '['\n\t\t\t\t\t || (*p == '.' && eval_isdictc(p[1]))))\n\t\t\t|| mb_nest != 0\n\t\t\t|| br_nest != 0); MB_PTR_ADV(p))\n    {\n\tif (*p == '\\'')\n\t{\n\t    // skip over 'string' to avoid counting [ and ] inside it.\n\t    for (p = p + 1; *p != NUL && *p != '\\''; MB_PTR_ADV(p))\n\t\t;\n\t    if (*p == NUL)\n\t\tbreak;\n\t}\n\telse if (*p == '\"')\n\t{\n\t    // skip over \"str\\\"ing\" to avoid counting [ and ] inside it.\n\t    for (p = p + 1; *p != NUL && *p != '\"'; MB_PTR_ADV(p))\n\t\tif (*p == '\\\\' && p[1] != NUL)\n\t\t    ++p;\n\t    if (*p == NUL)\n\t\tbreak;\n\t}\n\telse if (br_nest == 0 && mb_nest == 0 && *p == ':')\n\t{\n\t    // \"s:\" is start of \"s:var\", but \"n:\" is not and can be used in\n\t    // slice \"[n:]\".  Also \"xx:\" is not a namespace. But {ns}: is.\n\t    len = (int)(p - arg);\n\t    if ((len == 1 && vim_strchr(NAMESPACE_CHAR, *arg) == NULL)\n\t\t    || (len > 1 && p[-1] != '}'))\n\t\tbreak;\n\t}\n\n\tif (mb_nest == 0)\n\t{\n\t    if (*p == '[')\n\t\t++br_nest;\n\t    else if (*p == ']')\n\t\t--br_nest;\n\t}\n\n\tif (br_nest == 0 && !vim9script)\n\t{\n\t    if (*p == '{')\n\t    {\n\t\tmb_nest++;\n\t\tif (expr_start != NULL && *expr_start == NULL)\n\t\t    *expr_start = p;\n\t    }\n\t    else if (*p == '}')\n\t    {\n\t\tmb_nest--;\n\t\tif (expr_start != NULL && mb_nest == 0 && *expr_end == NULL)\n\t\t    *expr_end = p;\n\t    }\n\t}\n    }\n\n    return p;\n}\n\n/*\n * Expands out the 'magic' {}'s in a variable/function name.\n * Note that this can call itself recursively, to deal with\n * constructs like foo{bar}{baz}{bam}\n * The four pointer arguments point to \"foo{expre}ss{ion}bar\"\n *\t\t\t\"in_start\"      ^\n *\t\t\t\"expr_start\"\t   ^\n *\t\t\t\"expr_end\"\t\t ^\n *\t\t\t\"in_end\"\t\t\t    ^\n *\n * Returns a new allocated string, which the caller must free.\n * Returns NULL for failure.\n */\n    static char_u *\nmake_expanded_name(\n    char_u\t*in_start,\n    char_u\t*expr_start,\n    char_u\t*expr_end,\n    char_u\t*in_end)\n{\n    char_u\tc1;\n    char_u\t*retval = NULL;\n    char_u\t*temp_result;\n\n    if (expr_end == NULL || in_end == NULL)\n\treturn NULL;\n    *expr_start\t= NUL;\n    *expr_end = NUL;\n    c1 = *in_end;\n    *in_end = NUL;\n\n    temp_result = eval_to_string(expr_start + 1, FALSE);\n    if (temp_result != NULL)\n    {\n\tretval = alloc(STRLEN(temp_result) + (expr_start - in_start)\n\t\t\t\t\t\t   + (in_end - expr_end) + 1);\n\tif (retval != NULL)\n\t{\n\t    STRCPY(retval, in_start);\n\t    STRCAT(retval, temp_result);\n\t    STRCAT(retval, expr_end + 1);\n\t}\n    }\n    vim_free(temp_result);\n\n    *in_end = c1;\t\t// put char back for error messages\n    *expr_start = '{';\n    *expr_end = '}';\n\n    if (retval != NULL)\n    {\n\ttemp_result = find_name_end(retval, &expr_start, &expr_end, 0);\n\tif (expr_start != NULL)\n\t{\n\t    // Further expansion!\n\t    temp_result = make_expanded_name(retval, expr_start,\n\t\t\t\t\t\t       expr_end, temp_result);\n\t    vim_free(retval);\n\t    retval = temp_result;\n\t}\n    }\n\n    return retval;\n}\n\n/*\n * Return TRUE if character \"c\" can be used in a variable or function name.\n * Does not include '{' or '}' for magic braces.\n */\n    int\neval_isnamec(int c)\n{\n    return ASCII_ISALNUM(c) || c == '_' || c == ':' || c == AUTOLOAD_CHAR;\n}\n\n/*\n * Return TRUE if character \"c\" can be used as the first character in a\n * variable or function name (excluding '{' and '}').\n */\n    int\neval_isnamec1(int c)\n{\n    return ASCII_ISALPHA(c) || c == '_';\n}\n\n/*\n * Return TRUE if character \"c\" can be used as the first character of a\n * dictionary key.\n */\n    int\neval_isdictc(int c)\n{\n    return ASCII_ISALNUM(c) || c == '_';\n}\n\n/*\n * Handle:\n * - expr[expr], expr[expr:expr] subscript\n * - \".name\" lookup\n * - function call with Funcref variable: func(expr)\n * - method call: var->method()\n *\n * Can all be combined in any order: dict.func(expr)[idx]['func'](expr)->len()\n * \"name_start\" points to a variable before the subscript or is NULL.\n */\n    int\nhandle_subscript(\n    char_u\t**arg,\n    char_u\t*name_start,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t// give error messages\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    int\t\tret = OK;\n    dict_T\t*selfdict = NULL;\n    int\t\tcheck_white = TRUE;\n    int\t\tgetnext;\n    char_u\t*p;\n\n    while (ret == OK)\n    {\n\t// When at the end of the line and \".name\" or \"->{\" or \"->X\" follows in\n\t// the next line then consume the line break.\n\tp = eval_next_non_blank(*arg, evalarg, &getnext);\n\tif (getnext\n\t    && ((rettv->v_type == VAR_DICT && *p == '.' && eval_isdictc(p[1]))\n\t\t|| (p[0] == '-' && p[1] == '>' && (p[2] == '{'\n\t\t\t|| ASCII_ISALPHA(in_vim9script() ? *skipwhite(p + 2)\n\t\t\t\t\t\t\t\t    : p[2])))))\n\t{\n\t    *arg = eval_next_line(*arg, evalarg);\n\t    p = *arg;\n\t    check_white = FALSE;\n\t}\n\n\tif (rettv->v_type == VAR_ANY)\n\t{\n\t    char_u\t*exp_name;\n\t    int\t\tcc;\n\t    int\t\tidx;\n\t    ufunc_T\t*ufunc;\n\t    type_T\t*type;\n\n\t    // Found script from \"import {name} as name\", script item name must\n\t    // follow.  \"rettv->vval.v_number\" has the script ID.\n\t    if (**arg != '.')\n\t    {\n\t\tif (verbose)\n\t\t    semsg(_(e_expected_dot_after_name_str),\n\t\t\t\t\tname_start != NULL ? name_start: *arg);\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t    ++*arg;\n\t    if (IS_WHITE_OR_NUL(**arg))\n\t    {\n\t\tif (verbose)\n\t\t    emsg(_(e_no_white_space_allowed_after_dot));\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\n\t    // isolate the name\n\t    exp_name = *arg;\n\t    while (eval_isnamec(**arg))\n\t\t++*arg;\n\t    cc = **arg;\n\t    **arg = NUL;\n\n\t    idx = find_exported(rettv->vval.v_number, exp_name, &ufunc, &type,\n\t\t\t    evalarg->eval_cctx, evalarg->eval_cstack, verbose);\n\t    **arg = cc;\n\n\t    if (idx < 0 && ufunc == NULL)\n\t    {\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t    if (idx >= 0)\n\t    {\n\t\tscriptitem_T    *si = SCRIPT_ITEM(rettv->vval.v_number);\n\t\tsvar_T\t\t*sv = ((svar_T *)si->sn_var_vals.ga_data) + idx;\n\n\t\tcopy_tv(sv->sv_tv, rettv);\n\t    }\n\t    else\n\t    {\n\t\trettv->v_type = VAR_FUNC;\n\t\trettv->vval.v_string = vim_strsave(ufunc->uf_name);\n\t    }\n\t    continue;\n\t}\n\n\tif ((**arg == '(' && (!evaluate || rettv->v_type == VAR_FUNC\n\t\t\t    || rettv->v_type == VAR_PARTIAL))\n\t\t    && (!check_white || !VIM_ISWHITE(*(*arg - 1))))\n\t{\n\t    ret = call_func_rettv(arg, evalarg, rettv, evaluate,\n\t\t\t\t\t\t\t       selfdict, NULL);\n\n\t    // Stop the expression evaluation when immediately aborting on\n\t    // error, or when an interrupt occurred or an exception was thrown\n\t    // but not caught.\n\t    if (aborting())\n\t    {\n\t\tif (ret == OK)\n\t\t    clear_tv(rettv);\n\t\tret = FAIL;\n\t    }\n\t    dict_unref(selfdict);\n\t    selfdict = NULL;\n\t}\n\telse if (p[0] == '-' && p[1] == '>')\n\t{\n\t    if (in_vim9script())\n\t\t*arg = skipwhite(p + 2);\n\t    else\n\t\t*arg = p + 2;\n\t    if (ret == OK)\n\t    {\n\t\tif (VIM_ISWHITE(**arg))\n\t\t{\n\t\t    emsg(_(e_no_white_space_allowed_before_parenthesis));\n\t\t    ret = FAIL;\n\t\t}\n\t\telse if ((**arg == '{' && !in_vim9script()) || **arg == '(')\n\t\t    // expr->{lambda}() or expr->(lambda)()\n\t\t    ret = eval_lambda(arg, rettv, evalarg, verbose);\n\t\telse\n\t\t    // expr->name()\n\t\t    ret = eval_method(arg, rettv, evalarg, verbose);\n\t    }\n\t}\n\t// \".\" is \".name\" lookup when we found a dict or when evaluating and\n\t// scriptversion is at least 2, where string concatenation is \"..\".\n\telse if (**arg == '['\n\t\t|| (**arg == '.' && (rettv->v_type == VAR_DICT\n\t\t\t|| (!evaluate\n\t\t\t    && (*arg)[1] != '.'\n\t\t\t    && !in_old_script(2)))))\n\t{\n\t    dict_unref(selfdict);\n\t    if (rettv->v_type == VAR_DICT)\n\t    {\n\t\tselfdict = rettv->vval.v_dict;\n\t\tif (selfdict != NULL)\n\t\t    ++selfdict->dv_refcount;\n\t    }\n\t    else\n\t\tselfdict = NULL;\n\t    if (eval_index(arg, rettv, evalarg, verbose) == FAIL)\n\t    {\n\t\tclear_tv(rettv);\n\t\tret = FAIL;\n\t    }\n\t}\n\telse\n\t    break;\n    }\n\n    // Turn \"dict.Func\" into a partial for \"Func\" bound to \"dict\".\n    // Don't do this when \"Func\" is already a partial that was bound\n    // explicitly (pt_auto is FALSE).\n    if (selfdict != NULL\n\t    && (rettv->v_type == VAR_FUNC\n\t\t|| (rettv->v_type == VAR_PARTIAL\n\t\t    && (rettv->vval.v_partial->pt_auto\n\t\t\t|| rettv->vval.v_partial->pt_dict == NULL))))\n\tselfdict = make_partial(selfdict, rettv);\n\n    dict_unref(selfdict);\n    return ret;\n}\n\n/*\n * Make a copy of an item.\n * Lists and Dictionaries are also copied.  A deep copy if \"deep\" is set.\n * \"top\" is TRUE for the toplevel of copy().\n * For deepcopy() \"copyID\" is zero for a full copy or the ID for when a\n * reference to an already copied list/dict can be used.\n * Returns FAIL or OK.\n */\n    int\nitem_copy(\n    typval_T\t*from,\n    typval_T\t*to,\n    int\t\tdeep,\n    int\t\ttop,\n    int\t\tcopyID)\n{\n    static int\trecurse = 0;\n    int\t\tret = OK;\n\n    if (recurse >= DICT_MAXNEST)\n    {\n\temsg(_(e_variable_nested_too_deep_for_making_copy));\n\treturn FAIL;\n    }\n    ++recurse;\n\n    switch (from->v_type)\n    {\n\tcase VAR_NUMBER:\n\tcase VAR_FLOAT:\n\tcase VAR_STRING:\n\tcase VAR_FUNC:\n\tcase VAR_PARTIAL:\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\tcase VAR_JOB:\n\tcase VAR_CHANNEL:\n\tcase VAR_INSTR:\n\t    copy_tv(from, to);\n\t    break;\n\tcase VAR_LIST:\n\t    to->v_type = VAR_LIST;\n\t    to->v_lock = 0;\n\t    if (from->vval.v_list == NULL)\n\t\tto->vval.v_list = NULL;\n\t    else if (copyID != 0 && from->vval.v_list->lv_copyID == copyID)\n\t    {\n\t\t// use the copy made earlier\n\t\tto->vval.v_list = from->vval.v_list->lv_copylist;\n\t\t++to->vval.v_list->lv_refcount;\n\t    }\n\t    else\n\t\tto->vval.v_list = list_copy(from->vval.v_list,\n\t\t\t\t\t\t\t    deep, top, copyID);\n\t    if (to->vval.v_list == NULL)\n\t\tret = FAIL;\n\t    break;\n\tcase VAR_BLOB:\n\t    ret = blob_copy(from->vval.v_blob, to);\n\t    break;\n\tcase VAR_DICT:\n\t    to->v_type = VAR_DICT;\n\t    to->v_lock = 0;\n\t    if (from->vval.v_dict == NULL)\n\t\tto->vval.v_dict = NULL;\n\t    else if (copyID != 0 && from->vval.v_dict->dv_copyID == copyID)\n\t    {\n\t\t// use the copy made earlier\n\t\tto->vval.v_dict = from->vval.v_dict->dv_copydict;\n\t\t++to->vval.v_dict->dv_refcount;\n\t    }\n\t    else\n\t\tto->vval.v_dict = dict_copy(from->vval.v_dict,\n\t\t\t\t\t\t\t    deep, top, copyID);\n\t    if (to->vval.v_dict == NULL)\n\t\tret = FAIL;\n\t    break;\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\t    internal_error_no_abort(\"item_copy(UNKNOWN)\");\n\t    ret = FAIL;\n    }\n    --recurse;\n    return ret;\n}\n\n    void\necho_one(typval_T *rettv, int with_space, int *atstart, int *needclr)\n{\n    char_u\t*tofree;\n    char_u\tnumbuf[NUMBUFLEN];\n    char_u\t*p = echo_string(rettv, &tofree, numbuf, get_copyID());\n\n    if (*atstart)\n    {\n\t*atstart = FALSE;\n\t// Call msg_start() after eval1(), evaluating the expression\n\t// may cause a message to appear.\n\tif (with_space)\n\t{\n\t    // Mark the saved text as finishing the line, so that what\n\t    // follows is displayed on a new line when scrolling back\n\t    // at the more prompt.\n\t    msg_sb_eol();\n\t    msg_start();\n\t}\n    }\n    else if (with_space)\n\tmsg_puts_attr(\" \", echo_attr);\n\n    if (p != NULL)\n\tfor ( ; *p != NUL && !got_int; ++p)\n\t{\n\t    if (*p == '\\n' || *p == '\\r' || *p == TAB)\n\t    {\n\t\tif (*p != TAB && *needclr)\n\t\t{\n\t\t    // remove any text still there from the command\n\t\t    msg_clr_eos();\n\t\t    *needclr = FALSE;\n\t\t}\n\t\tmsg_putchar_attr(*p, echo_attr);\n\t    }\n\t    else\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    int i = (*mb_ptr2len)(p);\n\n\t\t    (void)msg_outtrans_len_attr(p, i, echo_attr);\n\t\t    p += i - 1;\n\t\t}\n\t\telse\n\t\t    (void)msg_outtrans_len_attr(p, 1, echo_attr);\n\t    }\n\t}\n    vim_free(tofree);\n}\n\n/*\n * \":echo expr1 ...\"\tprint each argument separated with a space, add a\n *\t\t\tnewline at the end.\n * \":echon expr1 ...\"\tprint each argument plain.\n */\n    void\nex_echo(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    typval_T\trettv;\n    char_u\t*arg_start;\n    int\t\tneedclr = TRUE;\n    int\t\tatstart = TRUE;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tcalled_emsg_before = called_emsg;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, eap->skip);\n\n    if (eap->skip)\n\t++emsg_skip;\n    while ((!ends_excmd2(eap->cmd, arg) || *arg == '\"') && !got_int)\n    {\n\t// If eval1() causes an error message the text from the command may\n\t// still need to be cleared. E.g., \"echo 22,44\".\n\tneed_clr_eos = needclr;\n\n\targ_start = arg;\n\tif (eval1(&arg, &rettv, &evalarg) == FAIL)\n\t{\n\t    /*\n\t     * Report the invalid expression unless the expression evaluation\n\t     * has been cancelled due to an aborting error, an interrupt, or an\n\t     * exception.\n\t     */\n\t    if (!aborting() && did_emsg == did_emsg_before\n\t\t\t\t\t  && called_emsg == called_emsg_before)\n\t\tsemsg(_(e_invalid_expression_str), arg_start);\n\t    need_clr_eos = FALSE;\n\t    break;\n\t}\n\tneed_clr_eos = FALSE;\n\n\tif (!eap->skip)\n\t{\n\t    if (rettv.v_type == VAR_VOID)\n\t    {\n\t\tsemsg(_(e_expression_does_not_result_in_value_str), arg_start);\n\t\tbreak;\n\t    }\n\t    echo_one(&rettv, eap->cmdidx == CMD_echo, &atstart, &needclr);\n\t}\n\n\tclear_tv(&rettv);\n\targ = skipwhite(arg);\n    }\n    set_nextcmd(eap, arg);\n    clear_evalarg(&evalarg, eap);\n\n    if (eap->skip)\n\t--emsg_skip;\n    else\n    {\n\t// remove text that may still be there from the command\n\tif (needclr)\n\t    msg_clr_eos();\n\tif (eap->cmdidx == CMD_echo)\n\t    msg_end();\n    }\n}\n\n/*\n * \":echohl {name}\".\n */\n    void\nex_echohl(exarg_T *eap)\n{\n    echo_attr = syn_name2attr(eap->arg);\n}\n\n/*\n * Returns the :echo attribute\n */\n    int\nget_echo_attr(void)\n{\n    return echo_attr;\n}\n\n/*\n * \":execute expr1 ...\"\texecute the result of an expression.\n * \":echomsg expr1 ...\"\tPrint a message\n * \":echoerr expr1 ...\"\tPrint an error\n * \":echoconsole expr1 ...\" Print a message on stdout\n * Each gets spaces around each argument and a newline at the end for\n * echo commands\n */\n    void\nex_execute(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    typval_T\trettv;\n    int\t\tret = OK;\n    char_u\t*p;\n    garray_T\tga;\n    int\t\tlen;\n    long\tstart_lnum = SOURCING_LNUM;\n\n    ga_init2(&ga, 1, 80);\n\n    if (eap->skip)\n\t++emsg_skip;\n    while (!ends_excmd2(eap->cmd, arg) || *arg == '\"')\n    {\n\tret = eval1_emsg(&arg, &rettv, eap);\n\tif (ret == FAIL)\n\t    break;\n\n\tif (!eap->skip)\n\t{\n\t    char_u   buf[NUMBUFLEN];\n\n\t    if (eap->cmdidx == CMD_execute)\n\t    {\n\t\tif (rettv.v_type == VAR_CHANNEL || rettv.v_type == VAR_JOB)\n\t\t{\n\t\t    semsg(_(e_using_invalid_value_as_string_str),\n\t\t\t\t\t\t  vartype_name(rettv.v_type));\n\t\t    p = NULL;\n\t\t}\n\t\telse\n\t\t    p = tv_get_string_buf(&rettv, buf);\n\t    }\n\t    else\n\t\tp = tv_stringify(&rettv, buf);\n\t    if (p == NULL)\n\t    {\n\t\tclear_tv(&rettv);\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t    len = (int)STRLEN(p);\n\t    if (ga_grow(&ga, len + 2) == FAIL)\n\t    {\n\t\tclear_tv(&rettv);\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t    if (ga.ga_len)\n\t\t((char_u *)(ga.ga_data))[ga.ga_len++] = ' ';\n\t    STRCPY((char_u *)(ga.ga_data) + ga.ga_len, p);\n\t    ga.ga_len += len;\n\t}\n\n\tclear_tv(&rettv);\n\targ = skipwhite(arg);\n    }\n\n    if (ret != FAIL && ga.ga_data != NULL)\n    {\n\t// use the first line of continuation lines for messages\n\tSOURCING_LNUM = start_lnum;\n\n\tif (eap->cmdidx == CMD_echomsg || eap->cmdidx == CMD_echoerr)\n\t{\n\t    // Mark the already saved text as finishing the line, so that what\n\t    // follows is displayed on a new line when scrolling back at the\n\t    // more prompt.\n\t    msg_sb_eol();\n\t}\n\n\tif (eap->cmdidx == CMD_echomsg)\n\t{\n\t    msg_attr(ga.ga_data, echo_attr);\n\t    out_flush();\n\t}\n\telse if (eap->cmdidx == CMD_echoconsole)\n\t{\n\t    ui_write(ga.ga_data, (int)STRLEN(ga.ga_data), TRUE);\n\t    ui_write((char_u *)\"\\r\\n\", 2, TRUE);\n\t}\n\telse if (eap->cmdidx == CMD_echoerr)\n\t{\n\t    int\t\tsave_did_emsg = did_emsg;\n\n\t    // We don't want to abort following commands, restore did_emsg.\n\t    emsg(ga.ga_data);\n\t    if (!force_abort)\n\t\tdid_emsg = save_did_emsg;\n\t}\n\telse if (eap->cmdidx == CMD_execute)\n\t{\n\t    int save_sticky_cmdmod_flags = sticky_cmdmod_flags;\n\n\t    // \"legacy exe cmd\" and \"vim9cmd exe cmd\" applies to \"cmd\".\n\t    sticky_cmdmod_flags = cmdmod.cmod_flags\n\t\t\t\t\t\t& (CMOD_LEGACY | CMOD_VIM9CMD);\n\t    do_cmdline((char_u *)ga.ga_data,\n\t\t       eap->getline, eap->cookie, DOCMD_NOWAIT|DOCMD_VERBOSE);\n\t    sticky_cmdmod_flags = save_sticky_cmdmod_flags;\n\t}\n    }\n\n    ga_clear(&ga);\n\n    if (eap->skip)\n\t--emsg_skip;\n\n    set_nextcmd(eap, arg);\n}\n\n/*\n * Skip over the name of an option: \"&option\", \"&g:option\" or \"&l:option\".\n * \"arg\" points to the \"&\" or '+' when called, to \"option\" when returning.\n * Returns NULL when no option name found.  Otherwise pointer to the char\n * after the option name.\n */\n    char_u *\nfind_option_end(char_u **arg, int *scope)\n{\n    char_u\t*p = *arg;\n\n    ++p;\n    if (*p == 'g' && p[1] == ':')\n    {\n\t*scope = OPT_GLOBAL;\n\tp += 2;\n    }\n    else if (*p == 'l' && p[1] == ':')\n    {\n\t*scope = OPT_LOCAL;\n\tp += 2;\n    }\n    else\n\t*scope = 0;\n\n    if (!ASCII_ISALPHA(*p))\n\treturn NULL;\n    *arg = p;\n\n    if (p[0] == 't' && p[1] == '_' && p[2] != NUL && p[3] != NUL)\n\tp += 4;\t    // termcap option\n    else\n\twhile (ASCII_ISALPHA(*p))\n\t    ++p;\n    return p;\n}\n\n/*\n * Display script name where an item was last set.\n * Should only be invoked when 'verbose' is non-zero.\n */\n    void\nlast_set_msg(sctx_T script_ctx)\n{\n    char_u *p;\n\n    if (script_ctx.sc_sid != 0)\n    {\n\tp = home_replace_save(NULL, get_scriptname(script_ctx.sc_sid));\n\tif (p != NULL)\n\t{\n\t    verbose_enter();\n\t    msg_puts(_(\"\\n\\tLast set from \"));\n\t    msg_puts((char *)p);\n\t    if (script_ctx.sc_lnum > 0)\n\t    {\n\t\tmsg_puts(_(line_msg));\n\t\tmsg_outnum((long)script_ctx.sc_lnum);\n\t    }\n\t    verbose_leave();\n\t    vim_free(p);\n\t}\n    }\n}\n\n#endif // FEAT_EVAL\n\n/*\n * Perform a substitution on \"str\" with pattern \"pat\" and substitute \"sub\".\n * When \"sub\" is NULL \"expr\" is used, must be a VAR_FUNC or VAR_PARTIAL.\n * \"flags\" can be \"g\" to do a global substitute.\n * Returns an allocated string, NULL for error.\n */\n    char_u *\ndo_string_sub(\n    char_u\t*str,\n    char_u\t*pat,\n    char_u\t*sub,\n    typval_T\t*expr,\n    char_u\t*flags)\n{\n    int\t\tsublen;\n    regmatch_T\tregmatch;\n    int\t\ti;\n    int\t\tdo_all;\n    char_u\t*tail;\n    char_u\t*end;\n    garray_T\tga;\n    char_u\t*ret;\n    char_u\t*save_cpo;\n    char_u\t*zero_width = NULL;\n\n    // Make 'cpoptions' empty, so that the 'l' flag doesn't work here\n    save_cpo = p_cpo;\n    p_cpo = empty_option;\n\n    ga_init2(&ga, 1, 200);\n\n    do_all = (flags[0] == 'g');\n\n    regmatch.rm_ic = p_ic;\n    regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);\n    if (regmatch.regprog != NULL)\n    {\n\ttail = str;\n\tend = str + STRLEN(str);\n\twhile (vim_regexec_nl(&regmatch, str, (colnr_T)(tail - str)))\n\t{\n\t    // Skip empty match except for first match.\n\t    if (regmatch.startp[0] == regmatch.endp[0])\n\t    {\n\t\tif (zero_width == regmatch.startp[0])\n\t\t{\n\t\t    // avoid getting stuck on a match with an empty string\n\t\t    i = mb_ptr2len(tail);\n\t\t    mch_memmove((char_u *)ga.ga_data + ga.ga_len, tail,\n\t\t\t\t\t\t\t\t   (size_t)i);\n\t\t    ga.ga_len += i;\n\t\t    tail += i;\n\t\t    continue;\n\t\t}\n\t\tzero_width = regmatch.startp[0];\n\t    }\n\n\t    /*\n\t     * Get some space for a temporary buffer to do the substitution\n\t     * into.  It will contain:\n\t     * - The text up to where the match is.\n\t     * - The substituted text.\n\t     * - The text after the match.\n\t     */\n\t    sublen = vim_regsub(&regmatch, sub, expr, tail, 0, REGSUB_MAGIC);\n\t    if (ga_grow(&ga, (int)((end - tail) + sublen -\n\t\t\t    (regmatch.endp[0] - regmatch.startp[0]))) == FAIL)\n\t    {\n\t\tga_clear(&ga);\n\t\tbreak;\n\t    }\n\n\t    // copy the text up to where the match is\n\t    i = (int)(regmatch.startp[0] - tail);\n\t    mch_memmove((char_u *)ga.ga_data + ga.ga_len, tail, (size_t)i);\n\t    // add the substituted text\n\t    (void)vim_regsub(&regmatch, sub, expr,\n\t\t\t\t  (char_u *)ga.ga_data + ga.ga_len + i, sublen,\n\t\t\t\t  REGSUB_COPY | REGSUB_MAGIC);\n\t    ga.ga_len += i + sublen - 1;\n\t    tail = regmatch.endp[0];\n\t    if (*tail == NUL)\n\t\tbreak;\n\t    if (!do_all)\n\t\tbreak;\n\t}\n\n\tif (ga.ga_data != NULL)\n\t    STRCPY((char *)ga.ga_data + ga.ga_len, tail);\n\n\tvim_regfree(regmatch.regprog);\n    }\n\n    ret = vim_strsave(ga.ga_data == NULL ? str : (char_u *)ga.ga_data);\n    ga_clear(&ga);\n    if (p_cpo == empty_option)\n\tp_cpo = save_cpo;\n    else\n    {\n\t// Darn, evaluating {sub} expression or {expr} changed the value.\n\t// If it's still empty it was changed and restored, need to restore in\n\t// the complicated way.\n\tif (*p_cpo == NUL)\n\t    set_option_value_give_err((char_u *)\"cpo\", 0L, save_cpo, 0);\n\tfree_string_option(save_cpo);\n    }\n\n    return ret;\n}\n", "\" Test various aspects of the Vim script language.\n\" Most of this was formerly in test49.vim (developed by Servatius Brandt\n\" <Servatius.Brandt@fujitsu-siemens.com>)\n\nsource check.vim\nsource shared.vim\nsource script_util.vim\n\n\"-------------------------------------------------------------------------------\n\" Test environment\t\t\t\t\t\t\t    {{{1\n\"-------------------------------------------------------------------------------\n\n\" Append a message to the \"messages\" file\nfunc Xout(text)\n    split messages\n    $put =a:text\n    wq\nendfunc\n\ncom! -nargs=1\t     Xout     call Xout(<args>)\n\n\" Create a new instance of Vim and run the commands in 'test' and then 'verify'\n\" The commands in 'test' are expected to store the test results in the Xtest.out\n\" file. If the test passes successfully, then Xtest.out should be empty.\nfunc RunInNewVim(test, verify)\n  let init =<< trim END\n    set cpo-=C            \" support line-continuation in sourced script\n    source script_util.vim\n    XpathINIT\n    XloopINIT\n  END\n  let cleanup =<< trim END\n    call writefile(v:errors, 'Xtest.out')\n    qall\n  END\n  call writefile(init, 'Xtest.vim')\n  call writefile(a:test, 'Xtest.vim', 'a')\n  call writefile(a:verify, 'Xverify.vim')\n  call writefile(cleanup, 'Xverify.vim', 'a')\n  call RunVim([], [], \"-S Xtest.vim -S Xverify.vim\")\n  call assert_equal([], readfile('Xtest.out'))\n  call delete('Xtest.out')\n  call delete('Xtest.vim')\n  call delete('Xverify.vim')\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 1:   :endwhile in function\t\t\t\t\t    {{{1\n\"\n\"\t    Detect if a broken loop is (incorrectly) reactivated by the\n\"\t    :endwhile.  Use a :return to prevent an endless loop, and make\n\"\t    this test first to get a meaningful result on an error before other\n\"\t    tests will hang.\n\"-------------------------------------------------------------------------------\n\nfunc T1_F()\n    Xpath 'a'\n    let first = 1\n    while 1\n\tXpath 'b'\n\tif first\n\t    Xpath 'c'\n\t    let first = 0\n\t    break\n\telse\n\t    Xpath 'd'\n\t    return\n\tendif\n    endwhile\nendfunc\n\nfunc T1_G()\n    Xpath 'h'\n    let first = 1\n    while 1\n\tXpath 'i'\n\tif first\n\t    Xpath 'j'\n\t    let first = 0\n\t    break\n\telse\n\t    Xpath 'k'\n\t    return\n\tendif\n\tif 1\t\" unmatched :if\n    endwhile\nendfunc\n\nfunc Test_endwhile_function()\n  XpathINIT\n  call T1_F()\n  Xpath 'F'\n\n  try\n    call T1_G()\n  catch\n    \" Catch missing :endif\n    call assert_true(v:exception =~ 'E171:')\n    Xpath 'x'\n  endtry\n  Xpath 'G'\n\n  call assert_equal('abcFhijxG', g:Xpath)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 2:   :endwhile in script\t\t\t\t\t\t    {{{1\n\"\n\"\t    Detect if a broken loop is (incorrectly) reactivated by the\n\"\t    :endwhile.  Use a :finish to prevent an endless loop, and place\n\"\t    this test before others that might hang to get a meaningful result\n\"\t    on an error.\n\"\n\"\t    This test executes the bodies of the functions T1_F and T1_G from\n\"\t    the previous test as script files (:return replaced by :finish).\n\"-------------------------------------------------------------------------------\n\nfunc Test_endwhile_script()\n  XpathINIT\n  ExecAsScript T1_F\n  Xpath 'F'\n  call DeleteTheScript()\n\n  try\n    ExecAsScript T1_G\n  catch\n    \" Catch missing :endif\n    call assert_true(v:exception =~ 'E171:')\n    Xpath 'x'\n  endtry\n  Xpath 'G'\n  call DeleteTheScript()\n\n  call assert_equal('abcFhijxG', g:Xpath)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 3:   :if, :elseif, :while, :continue, :break\t\t\t    {{{1\n\"-------------------------------------------------------------------------------\n\nfunc Test_if_while()\n    XpathINIT\n    if 1\n\tXpath 'a'\n\tlet loops = 3\n\twhile loops > -1\t    \" main loop: loops == 3, 2, 1 (which breaks)\n\t    if loops <= 0\n\t\tlet break_err = 1\n\t\tlet loops = -1\n\t    else\n\t\tXpath 'b' . loops\n\t    endif\n\t    if (loops == 2)\n\t\twhile loops == 2 \" dummy loop\n\t\t    Xpath 'c' . loops\n\t\t    let loops = loops - 1\n\t\t    continue    \" stop dummy loop\n\t\t    Xpath 'd' . loops\n\t\tendwhile\n\t\tcontinue\t    \" continue main loop\n\t\tXpath 'e' . loops\n\t    elseif (loops == 1)\n\t\tlet p = 1\n\t\twhile p\t    \" dummy loop\n\t\t    Xpath 'f' . loops\n\t\t    let p = 0\n\t\t    break\t    \" break dummy loop\n\t\t    Xpath 'g' . loops\n\t\tendwhile\n\t\tXpath 'h' . loops\n\t\tunlet p\n\t\tbreak\t    \" break main loop\n\t\tXpath 'i' . loops\n\t    endif\n\t    if (loops > 0)\n\t\tXpath 'j' . loops\n\t    endif\n\t    while loops == 3    \" dummy loop\n\t\tlet loops = loops - 1\n\t    endwhile\t    \" end dummy loop\n\tendwhile\t\t    \" end main loop\n\tXpath 'k'\n    else\n\tXpath 'l'\n    endif\n    Xpath 'm'\n    if exists(\"break_err\")\n\tXpath 'm'\n\tunlet break_err\n    endif\n\n    unlet loops\n\n    call assert_equal('ab3j3b2c2b1f1h1km', g:Xpath)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 4:   :return\t\t\t\t\t\t\t    {{{1\n\"-------------------------------------------------------------------------------\n\nfunc T4_F()\n    if 1\n\tXpath 'a'\n\tlet loops = 3\n\twhile loops > 0\t\t\t\t\"    3:  2:     1:\n\t    Xpath 'b' . loops\n\t    if (loops == 2)\n\t\tXpath 'c' . loops\n\t\treturn\n\t\tXpath 'd' . loops\n\t    endif\n\t    Xpath 'e' . loops\n\t    let loops = loops - 1\n\tendwhile\n\tXpath 'f'\n    else\n\tXpath 'g'\n    endif\nendfunc\n\nfunc Test_return()\n    XpathINIT\n    call T4_F()\n    Xpath '4'\n\n    call assert_equal('ab3e3b2c24', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 5:   :finish\t\t\t\t\t\t\t    {{{1\n\"\n\"\t    This test executes the body of the function T4_F from the previous\n\"\t    test as a script file (:return replaced by :finish).\n\"-------------------------------------------------------------------------------\n\nfunc Test_finish()\n    XpathINIT\n    ExecAsScript T4_F\n    Xpath '5'\n    call DeleteTheScript()\n\n    call assert_equal('ab3e3b2c25', g:Xpath)\nendfunc\n\n\n\n\"-------------------------------------------------------------------------------\n\" Test 6:   Defining functions in :while loops\t\t\t\t    {{{1\n\"\n\"\t     Functions can be defined inside other functions.  An inner function\n\"\t     gets defined when the outer function is executed.  Functions may\n\"\t     also be defined inside while loops.  Expressions in braces for\n\"\t     defining the function name are allowed.\n\"\n\"\t     The functions are defined when sourcing the script, only the\n\"\t     resulting path is checked in the test function.\n\"-------------------------------------------------------------------------------\n\nXpathINIT\n\n\" The command CALL collects the argument of all its invocations in \"calls\"\n\" when used from a function (that is, when the global variable \"calls\" needs\n\" the \"g:\" prefix).  This is to check that the function code is skipped when\n\" the function is defined.  For inner functions, do so only if the outer\n\" function is not being executed.\n\"\nlet calls = \"\"\ncom! -nargs=1 CALL\n\t    \\ if !exists(\"calls\") && !exists(\"outer\") |\n\t    \\ let g:calls = g:calls . <args> |\n\t    \\ endif\n\nlet i = 0\nwhile i < 3\n    let i = i + 1\n    if i == 1\n\tXpath 'a'\n\tfunction! F1(arg)\n\t    CALL a:arg\n\t    let outer = 1\n\n\t    let j = 0\n\t    while j < 1\n\t\tXpath 'b'\n\t\tlet j = j + 1\n\t\tfunction! G1(arg)\n\t\t    CALL a:arg\n\t\tendfunction\n\t\tXpath 'c'\n\t    endwhile\n\tendfunction\n\tXpath 'd'\n\n\tcontinue\n    endif\n\n    Xpath 'e' . i\n    function! F{i}(i, arg)\n\tCALL a:arg\n\tlet outer = 1\n\n\tif a:i == 3\n\t    Xpath 'f'\n\tendif\n\tlet k = 0\n\twhile k < 3\n\t    Xpath 'g' . k\n\t    let k = k + 1\n\t    function! G{a:i}{k}(arg)\n\t\tCALL a:arg\n\t    endfunction\n\t    Xpath 'h' . k\n\tendwhile\n    endfunction\n    Xpath 'i'\n\nendwhile\n\nif exists(\"*G1\")\n    Xpath 'j'\nendif\nif exists(\"*F1\")\n    call F1(\"F1\")\n    if exists(\"*G1\")\n       call G1(\"G1\")\n    endif\nendif\n\nif exists(\"G21\") || exists(\"G22\") || exists(\"G23\")\n    Xpath 'k'\nendif\nif exists(\"*F2\")\n    call F2(2, \"F2\")\n    if exists(\"*G21\")\n       call G21(\"G21\")\n    endif\n    if exists(\"*G22\")\n       call G22(\"G22\")\n    endif\n    if exists(\"*G23\")\n       call G23(\"G23\")\n    endif\nendif\n\nif exists(\"G31\") || exists(\"G32\") || exists(\"G33\")\n    Xpath 'l'\nendif\nif exists(\"*F3\")\n    call F3(3, \"F3\")\n    if exists(\"*G31\")\n       call G31(\"G31\")\n    endif\n    if exists(\"*G32\")\n       call G32(\"G32\")\n    endif\n    if exists(\"*G33\")\n       call G33(\"G33\")\n    endif\nendif\n\nXpath 'm'\n\nlet g:test6_result = g:Xpath\nlet g:test6_calls = calls\n\nunlet calls\ndelfunction F1\ndelfunction G1\ndelfunction F2\ndelfunction G21\ndelfunction G22\ndelfunction G23\ndelfunction G31\ndelfunction G32\ndelfunction G33\n\nfunc Test_defining_functions()\n    call assert_equal('ade2ie3ibcg0h1g1h2g2h3fg0h1g1h2g2h3m', g:test6_result)\n    call assert_equal('F1G1F2G21G22G23F3G31G32G33', g:test6_calls)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 7:   Continuing on errors outside functions\t\t\t    {{{1\n\"\n\"\t    On an error outside a function, the script processing continues\n\"\t    at the line following the outermost :endif or :endwhile.  When not\n\"\t    inside an :if or :while, the script processing continues at the next\n\"\t    line.\n\"-------------------------------------------------------------------------------\n\nXpathINIT\n\nif 1\n    Xpath 'a'\n    while 1\n\tXpath 'b'\n\tasdf\n\tXpath 'c'\n\tbreak\n    endwhile | Xpath 'd'\n    Xpath 'e'\nendif | Xpath 'f'\nXpath 'g'\n\nwhile 1\n    Xpath 'h'\n    if 1\n\tXpath 'i'\n\tasdf\n\tXpath 'j'\n    endif | Xpath 'k'\n    Xpath 'l'\n    break\nendwhile | Xpath 'm'\nXpath 'n'\n\nasdf\nXpath 'o'\n\nasdf | Xpath 'p'\nXpath 'q'\n\nlet g:test7_result = g:Xpath\n\nfunc Test_error_in_script()\n    call assert_equal('abghinoq', g:test7_result)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 8:   Aborting and continuing on errors inside functions\t\t    {{{1\n\"\n\"\t    On an error inside a function without the \"abort\" attribute, the\n\"\t    script processing continues at the next line (unless the error was\n\"\t    in a :return command).  On an error inside a function with the\n\"\t    \"abort\" attribute, the function is aborted and the script processing\n\"\t    continues after the function call; the value -1 is returned then.\n\"-------------------------------------------------------------------------------\n\nXpathINIT\n\nfunc T8_F()\n    if 1\n\tXpath 'a'\n\twhile 1\n\t    Xpath 'b'\n\t    asdf\n\t    Xpath 'c'\n\t    asdf | Xpath 'd'\n\t    Xpath 'e'\n\t    break\n\tendwhile\n\tXpath 'f'\n    endif | Xpath 'g'\n    Xpath 'h'\n\n    while 1\n\tXpath 'i'\n\tif 1\n\t    Xpath 'j'\n\t    asdf\n\t    Xpath 'k'\n\t    asdf | Xpath 'l'\n\t    Xpath 'm'\n\tendif\n\tXpath 'n'\n\tbreak\n    endwhile | Xpath 'o'\n    Xpath 'p'\n\n    return novar\t\t\" returns (default return value 0)\n    Xpath 'q'\n    return 1\t\t\t\" not reached\nendfunc\n\nfunc T8_G() abort\n    if 1\n\tXpath 'r'\n\twhile 1\n\t    Xpath 's'\n\t    asdf\t\t\" returns -1\n\t    Xpath 't'\n\t    break\n\tendwhile\n\tXpath 'v'\n    endif | Xpath 'w'\n    Xpath 'x'\n\n    return -4\t\t\t\" not reached\nendfunc\n\nfunc T8_H() abort\n    while 1\n\tXpath 'A'\n\tif 1\n\t    Xpath 'B'\n\t    asdf\t\t\" returns -1\n\t    Xpath 'C'\n\tendif\n\tXpath 'D'\n\tbreak\n    endwhile | Xpath 'E'\n    Xpath 'F'\n\n    return -4\t\t\t\" not reached\nendfunc\n\n\" Aborted functions (T8_G and T8_H) return -1.\nlet g:test8_sum = (T8_F() + 1) - 4 * T8_G() - 8 * T8_H()\nXpath 'X'\nlet g:test8_result = g:Xpath\n\nfunc Test_error_in_function()\n    call assert_equal(13, g:test8_sum)\n    call assert_equal('abcefghijkmnoprsABX', g:test8_result)\n\n    delfunction T8_F\n    delfunction T8_G\n    delfunction T8_H\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 9:   Continuing after aborted functions\t\t\t\t    {{{1\n\"\n\"\t    When a function with the \"abort\" attribute is aborted due to an\n\"\t    error, the next function back in the call hierarchy without an\n\"\t    \"abort\" attribute continues; the value -1 is returned then.\n\"-------------------------------------------------------------------------------\n\nXpathINIT\n\nfunc F() abort\n    Xpath 'a'\n    let result = G()\t\" not aborted\n    Xpath 'b'\n    if result != 2\n\tXpath 'c'\n    endif\n    return 1\nendfunc\n\nfunc G()\t\t\" no abort attribute\n    Xpath 'd'\n    if H() != -1\t\" aborted\n\tXpath 'e'\n    endif\n    Xpath 'f'\n    return 2\nendfunc\n\nfunc H() abort\n    Xpath 'g'\n    call I()\t\t\" aborted\n    Xpath 'h'\n    return 4\nendfunc\n\nfunc I() abort\n    Xpath 'i'\n    asdf\t\t\" error\n    Xpath 'j'\n    return 8\nendfunc\n\nif F() != 1\n    Xpath 'k'\nendif\n\nlet g:test9_result = g:Xpath\n\ndelfunction F\ndelfunction G\ndelfunction H\ndelfunction I\n\nfunc Test_func_abort()\n    call assert_equal('adgifb', g:test9_result)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 10:  :if, :elseif, :while argument parsing\t\t\t    {{{1\n\"\n\"\t    A '\"' or '|' in an argument expression must not be mixed up with\n\"\t    a comment or a next command after a bar.  Parsing errors should\n\"\t    be recognized.\n\"-------------------------------------------------------------------------------\n\nXpathINIT\n\nfunc MSG(enr, emsg)\n    let english = v:lang == \"C\" || v:lang =~ '^[Ee]n'\n    if a:enr == \"\"\n\tXout \"TODO: Add message number for:\" a:emsg\n\tlet v:errmsg = \":\" . v:errmsg\n    endif\n    let match = 1\n    if v:errmsg !~ '^'.a:enr.':' || (english && v:errmsg !~ a:emsg)\n\tlet match = 0\n\tif v:errmsg == \"\"\n\t    Xout \"Message missing.\"\n\telse\n\t    let v:errmsg = v:errmsg->escape('\"')\n\t    Xout \"Unexpected message:\" v:errmsg\n\tendif\n    endif\n    return match\nendfunc\n\nif 1 || strlen(\"\\\"\") | Xpath 'a'\n    Xpath 'b'\nendif\nXpath 'c'\n\nif 0\nelseif 1 || strlen(\"\\\"\") | Xpath 'd'\n    Xpath 'e'\nendif\nXpath 'f'\n\nwhile 1 || strlen(\"\\\"\") | Xpath 'g'\n    Xpath 'h'\n    break\nendwhile\nXpath 'i'\n\nlet v:errmsg = \"\"\nif 1 ||| strlen(\"\\\"\") | Xpath 'j'\n    Xpath 'k'\nendif\nXpath 'l'\nif !MSG('E15', \"Invalid expression\")\n    Xpath 'm'\nendif\n\nlet v:errmsg = \"\"\nif 0\nelseif 1 ||| strlen(\"\\\"\") | Xpath 'n'\n    Xpath 'o'\nendif\nXpath 'p'\nif !MSG('E15', \"Invalid expression\")\n    Xpath 'q'\nendif\n\nlet v:errmsg = \"\"\nwhile 1 ||| strlen(\"\\\"\") | Xpath 'r'\n    Xpath 's'\n    break\nendwhile\nXpath 't'\nif !MSG('E15', \"Invalid expression\")\n    Xpath 'u'\nendif\n\nlet g:test10_result = g:Xpath\ndelfunction MSG\n\nfunc Test_expr_parsing()\n    call assert_equal('abcdefghilpt', g:test10_result)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 11:  :if, :elseif, :while argument evaluation after abort\t    {{{1\n\"\n\"\t    When code is skipped over due to an error, the boolean argument to\n\"\t    an :if, :elseif, or :while must not be evaluated.\n\"-------------------------------------------------------------------------------\n\nXpathINIT\n\nlet calls = 0\n\nfunc P(num)\n    let g:calls = g:calls + a:num   \" side effect on call\n    return 0\nendfunc\n\nif 1\n    Xpath 'a'\n    asdf\t\t\" error\n    Xpath 'b'\n    if P(1)\t\t\" should not be called\n\tXpath 'c'\n    elseif !P(2)\t\" should not be called\n\tXpath 'd'\n    else\n\tXpath 'e'\n    endif\n    Xpath 'f'\n    while P(4)\t\t\" should not be called\n\tXpath 'g'\n    endwhile\n    Xpath 'h'\nendif\nXpath 'x'\n\nlet g:test11_calls = calls\nlet g:test11_result = g:Xpath\n\nunlet calls\ndelfunction P\n\nfunc Test_arg_abort()\n    call assert_equal(0, g:test11_calls)\n    call assert_equal('ax', g:test11_result)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 12:  Expressions in braces in skipped code\t\t\t    {{{1\n\"\n\"\t    In code skipped over due to an error or inactive conditional,\n\"\t    an expression in braces as part of a variable or function name\n\"\t    should not be evaluated.\n\"-------------------------------------------------------------------------------\n\nXpathINIT\n\nfunction! NULL()\n    Xpath 'a'\n    return 0\nendfunction\n\nfunction! ZERO()\n    Xpath 'b'\n    return 0\nendfunction\n\nfunction! F0()\n    Xpath 'c'\nendfunction\n\nfunction! F1(arg)\n    Xpath 'e'\nendfunction\n\nlet V0 = 1\n\nXpath 'f'\necho 0 ? F{NULL() + V{ZERO()}}() : 1\n\nXpath 'g'\nif 0\n    Xpath 'h'\n    call F{NULL() + V{ZERO()}}()\nendif\n\nXpath 'i'\nif 1\n    asdf\t\t\" error\n    Xpath 'j'\n    call F1(F{NULL() + V{ZERO()}}())\nendif\n\nXpath 'k'\nif 1\n    asdf\t\t\" error\n    Xpath 'l'\n    call F{NULL() + V{ZERO()}}()\nendif\n\nlet g:test12_result = g:Xpath\n\nfunc Test_braces_skipped()\n    call assert_equal('fgik', g:test12_result)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 13:  Failure in argument evaluation for :while\t\t\t    {{{1\n\"\n\"\t    A failure in the expression evaluation for the condition of a :while\n\"\t    causes the whole :while loop until the matching :endwhile being\n\"\t    ignored.  Continuation is at the next following line.\n\"-------------------------------------------------------------------------------\n\nXpathINIT\n\nXpath 'a'\nwhile asdf\n    Xpath 'b'\n    while 1\n\tXpath 'c'\n\tbreak\n    endwhile\n    Xpath 'd'\n    break\nendwhile\nXpath 'e'\n\nwhile asdf | Xpath 'f' | endwhile | Xpath 'g'\nXpath 'h'\nlet g:test13_result = g:Xpath\n\nfunc Test_while_fail()\n    call assert_equal('aeh', g:test13_result)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 14:  Failure in argument evaluation for :if\t\t\t    {{{1\n\"\n\"\t    A failure in the expression evaluation for the condition of an :if\n\"\t    does not cause the corresponding :else or :endif being matched to\n\"\t    a previous :if/:elseif.  Neither of both branches of the failed :if\n\"\t    are executed.\n\"-------------------------------------------------------------------------------\n\nXpathINIT\n\nfunction! F()\n    Xpath 'a'\n    let x = 0\n    if x\t\t\" false\n\tXpath 'b'\n    elseif !x\t\t\" always true\n\tXpath 'c'\n\tlet x = 1\n\tif g:boolvar\t\" possibly undefined\n\t    Xpath 'd'\n\telse\n\t    Xpath 'e'\n\tendif\n\tXpath 'f'\n    elseif x\t\t\" never executed\n\tXpath 'g'\n    endif\n    Xpath 'h'\nendfunction\n\nlet boolvar = 1\ncall F()\nXpath '-'\n\nunlet boolvar\ncall F()\nlet g:test14_result = g:Xpath\n\ndelfunction F\n\nfunc Test_if_fail()\n    call assert_equal('acdfh-acfh', g:test14_result)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 15:  Failure in argument evaluation for :if (bar)\t\t    {{{1\n\"\n\"\t    Like previous test, except that the failing :if ... | ... | :endif\n\"\t    is in a single line.\n\"-------------------------------------------------------------------------------\n\nXpathINIT\n\nfunction! F()\n    Xpath 'a'\n    let x = 0\n    if x\t\t\" false\n\tXpath 'b'\n    elseif !x\t\t\" always true\n\tXpath 'c'\n\tlet x = 1\n\tif g:boolvar | Xpath 'd' | else | Xpath 'e' | endif\n\tXpath 'f'\n    elseif x\t\t\" never executed\n\tXpath 'g'\n    endif\n    Xpath 'h'\nendfunction\n\nlet boolvar = 1\ncall F()\nXpath '-'\n\nunlet boolvar\ncall F()\nlet g:test15_result = g:Xpath\n\ndelfunction F\n\nfunc Test_if_bar_fail()\n    call assert_equal('acdfh-acfh', g:test15_result)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 16:  Double :else or :elseif after :else\t\t\t\t    {{{1\n\"\n\"\t    Multiple :elses or an :elseif after an :else are forbidden.\n\"-------------------------------------------------------------------------------\n\nfunc T16_F() abort\n  if 0\n    Xpath 'a'\n  else\n    Xpath 'b'\n  else\t\t\" aborts function\n    Xpath 'c'\n  endif\n  Xpath 'd'\nendfunc\n\nfunc T16_G() abort\n  if 0\n    Xpath 'a'\n  else\n    Xpath 'b'\n  elseif 1\t\t\" aborts function\n    Xpath 'c'\n  else\n    Xpath 'd'\n  endif\n  Xpath 'e'\nendfunc\n\nfunc T16_H() abort\n  if 0\n    Xpath 'a'\n  elseif 0\n    Xpath 'b'\n  else\n    Xpath 'c'\n  else\t\t\" aborts function\n    Xpath 'd'\n  endif\n  Xpath 'e'\nendfunc\n\nfunc T16_I() abort\n  if 0\n    Xpath 'a'\n  elseif 0\n    Xpath 'b'\n  else\n    Xpath 'c'\n  elseif 1\t\t\" aborts function\n    Xpath 'd'\n  else\n    Xpath 'e'\n  endif\n  Xpath 'f'\nendfunc\n\nfunc Test_Multi_Else()\n  XpathINIT\n  try\n    call T16_F()\n  catch /E583:/\n    Xpath 'e'\n  endtry\n  call assert_equal('be', g:Xpath)\n\n  XpathINIT\n  try\n    call T16_G()\n  catch /E584:/\n    Xpath 'f'\n  endtry\n  call assert_equal('bf', g:Xpath)\n\n  XpathINIT\n  try\n    call T16_H()\n  catch /E583:/\n    Xpath 'f'\n  endtry\n  call assert_equal('cf', g:Xpath)\n\n  XpathINIT\n  try\n    call T16_I()\n  catch /E584:/\n    Xpath 'g'\n  endtry\n  call assert_equal('cg', g:Xpath)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 17:  Nesting of unmatched :if or :endif inside a :while\t\t    {{{1\n\"\n\"\t    The :while/:endwhile takes precedence in nesting over an unclosed\n\"\t    :if or an unopened :endif.\n\"-------------------------------------------------------------------------------\n\n\" While loops inside a function are continued on error.\nfunc T17_F()\n  let loops = 3\n  while loops > 0\n    let loops -= 1\n    Xpath 'a' . loops\n    if (loops == 1)\n      Xpath 'b' . loops\n      continue\n    elseif (loops == 0)\n      Xpath 'c' . loops\n      break\n    elseif 1\n      Xpath 'd' . loops\n    \" endif missing!\n  endwhile\t\" :endwhile after :if 1\n  Xpath 'e'\nendfunc\n\nfunc T17_G()\n  let loops = 2\n  while loops > 0\n    let loops -= 1\n    Xpath 'a' . loops\n    if 0\n      Xpath 'b' . loops\n    \" endif missing\n  endwhile\t\" :endwhile after :if 0\nendfunc\n\nfunc T17_H()\n  let loops = 2\n  while loops > 0\n    let loops -= 1\n    Xpath 'a' . loops\n    \" if missing!\n    endif\t\" :endif without :if in while\n    Xpath 'b' . loops\n  endwhile\nendfunc\n\n\" Error continuation outside a function is at the outermost :endwhile or :endif.\nXpathINIT\nlet v:errmsg = ''\nlet loops = 2\nwhile loops > 0\n    let loops -= 1\n    Xpath 'a' . loops\n    if 0\n\tXpath 'b' . loops\n    \" endif missing! Following :endwhile fails.\nendwhile | Xpath 'c'\nXpath 'd'\ncall assert_match('E171:', v:errmsg)\ncall assert_equal('a1d', g:Xpath)\n\nfunc Test_unmatched_if_in_while()\n  XpathINIT\n  call assert_fails('call T17_F()', 'E171:')\n  call assert_equal('a2d2a1b1a0c0e', g:Xpath)\n\n  XpathINIT\n  call assert_fails('call T17_G()', 'E171:')\n  call assert_equal('a1a0', g:Xpath)\n\n  XpathINIT\n  call assert_fails('call T17_H()', 'E580:')\n  call assert_equal('a1b1a0b0', g:Xpath)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 18:  Interrupt (Ctrl-C pressed)\t\t\t\t\t    {{{1\n\"\n\"\t    On an interrupt, the script processing is terminated immediately.\n\"-------------------------------------------------------------------------------\n\nfunc Test_interrupt_while_if()\n  let test =<< trim [CODE]\n    try\n      if 1\n        Xpath 'a'\n        while 1\n          Xpath 'b'\n          if 1\n            Xpath 'c'\n            call interrupt()\n            call assert_report('should not get here')\n            break\n            finish\n          endif | call assert_report('should not get here')\n          call assert_report('should not get here')\n        endwhile | call assert_report('should not get here')\n        call assert_report('should not get here')\n      endif | call assert_report('should not get here')\n      call assert_report('should not get here')\n    catch /^Vim:Interrupt$/\n      Xpath 'd'\n    endtry | Xpath 'e'\n    Xpath 'f'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcdef', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_interrupt_try()\n  let test =<< trim [CODE]\n    try\n      try\n        Xpath 'a'\n        call interrupt()\n        call assert_report('should not get here')\n      endtry | call assert_report('should not get here')\n      call assert_report('should not get here')\n    catch /^Vim:Interrupt$/\n      Xpath 'b'\n    endtry | Xpath 'c'\n    Xpath 'd'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcd', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_interrupt_func_while_if()\n  let test =<< trim [CODE]\n    func F()\n      if 1\n        Xpath 'a'\n        while 1\n          Xpath 'b'\n          if 1\n            Xpath 'c'\n            call interrupt()\n            call assert_report('should not get here')\n            break\n            return\n          endif | call assert_report('should not get here')\n          call assert_report('should not get here')\n        endwhile | call assert_report('should not get here')\n        call assert_report('should not get here')\n      endif | call assert_report('should not get here')\n      call assert_report('should not get here')\n    endfunc\n\n    Xpath 'd'\n    try\n      call F() | call assert_report('should not get here')\n    catch /^Vim:Interrupt$/\n      Xpath 'e'\n    endtry | Xpath 'f'\n    Xpath 'g'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('dabcefg', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_interrupt_func_try()\n  let test =<< trim [CODE]\n    func G()\n      try\n        Xpath 'a'\n        call interrupt()\n        call assert_report('should not get here')\n      endtry | call assert_report('should not get here')\n      call assert_report('should not get here')\n    endfunc\n\n    Xpath 'b'\n    try\n      call G() | call assert_report('should not get here')\n    catch /^Vim:Interrupt$/\n      Xpath 'c'\n    endtry | Xpath 'd'\n    Xpath 'e'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('bacde', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 19:  Aborting on errors inside :try/:endtry\t\t\t    {{{1\n\"\n\"\t    An error in a command dynamically enclosed in a :try/:endtry region\n\"\t    aborts script processing immediately.  It does not matter whether\n\"\t    the failing command is outside or inside a function and whether a\n\"\t    function has an \"abort\" attribute.\n\"-------------------------------------------------------------------------------\n\nfunc Test_try_error_abort_1()\n  let test =<< trim [CODE]\n    func F() abort\n      Xpath 'a'\n      asdf\n      call assert_report('should not get here')\n    endfunc\n\n    try\n      Xpath 'b'\n      call F()\n      call assert_report('should not get here')\n    endtry | call assert_report('should not get here')\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('ba', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_try_error_abort_2()\n  let test =<< trim [CODE]\n    func G()\n      Xpath 'a'\n      asdf\n      call assert_report('should not get here')\n    endfunc\n\n    try\n      Xpath 'b'\n      call G()\n      call assert_report('should not get here')\n    endtry | call assert_report('should not get here')\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('ba', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_try_error_abort_3()\n  let test =<< trim [CODE]\n    try\n      Xpath 'a'\n      asdf\n      call assert_report('should not get here')\n    endtry | call assert_report('should not get here')\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('a', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_try_error_abort_4()\n  let test =<< trim [CODE]\n    if 1\n      try\n        Xpath 'a'\n        asdf\n        call assert_report('should not get here')\n      endtry | call assert_report('should not get here')\n    endif | call assert_report('should not get here')\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('a', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_try_error_abort_5()\n  let test =<< trim [CODE]\n    let p = 1\n    while p\n      let p = 0\n      try\n        Xpath 'a'\n        asdf\n        call assert_report('should not get here')\n      endtry | call assert_report('should not get here')\n    endwhile | call assert_report('should not get here')\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('a', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_try_error_abort_6()\n  let test =<< trim [CODE]\n    let p = 1\n    Xpath 'a'\n    while p\n      Xpath 'b'\n      let p = 0\n      try\n        Xpath 'c'\n    endwhile | call assert_report('should not get here')\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abc', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 20:  Aborting on errors after :try/:endtry\t\t\t    {{{1\n\"\n\"\t    When an error occurs after the last active :try/:endtry region has\n\"\t    been left, termination behavior is as if no :try/:endtry has been\n\"\t    seen.\n\"-------------------------------------------------------------------------------\n\nfunc Test_error_after_try_1()\n  let test =<< trim [CODE]\n    let p = 1\n    while p\n      let p = 0\n      Xpath 'a'\n      try\n        Xpath 'b'\n      endtry\n      asdf\n      call assert_report('should not get here')\n    endwhile | call assert_report('should not get here')\n    Xpath 'c'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abc', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_error_after_try_2()\n  let test =<< trim [CODE]\n    while 1\n      try\n        Xpath 'a'\n        break\n        call assert_report('should not get here')\n      endtry\n    endwhile\n    Xpath 'b'\n    asdf\n    Xpath 'c'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abc', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_error_after_try_3()\n  let test =<< trim [CODE]\n    while 1\n      try\n        Xpath 'a'\n        break\n        call assert_report('should not get here')\n      finally\n        Xpath 'b'\n      endtry\n    endwhile\n    Xpath 'c'\n    asdf\n    Xpath 'd'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcd', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_error_after_try_4()\n  let test =<< trim [CODE]\n    while 1\n      try\n        Xpath 'a'\n      finally\n        Xpath 'b'\n        break\n        call assert_report('should not get here')\n      endtry\n    endwhile\n    Xpath 'c'\n    asdf\n    Xpath 'd'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcd', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_error_after_try_5()\n  let test =<< trim [CODE]\n    let p = 1\n    while p\n      let p = 0\n      try\n        Xpath 'a'\n        continue\n        call assert_report('should not get here')\n      endtry\n    endwhile\n    Xpath 'b'\n    asdf\n    Xpath 'c'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abc', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_error_after_try_6()\n  let test =<< trim [CODE]\n    let p = 1\n    while p\n      let p = 0\n      try\n        Xpath 'a'\n        continue\n        call assert_report('should not get here')\n      finally\n        Xpath 'b'\n      endtry\n    endwhile\n    Xpath 'c'\n    asdf\n    Xpath 'd'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcd', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_error_after_try_7()\n  let test =<< trim [CODE]\n    let p = 1\n    while p\n      let p = 0\n      try\n        Xpath 'a'\n      finally\n        Xpath 'b'\n        continue\n        call assert_report('should not get here')\n      endtry\n    endwhile\n    Xpath 'c'\n    asdf\n    Xpath 'd'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcd', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 21:  :finally for :try after :continue/:break/:return/:finish\t    {{{1\n\"\n\"\t    If a :try conditional stays inactive due to a preceding :continue,\n\"\t    :break, :return, or :finish, its :finally clause should not be\n\"\t    executed.\n\"-------------------------------------------------------------------------------\n\nfunc Test_finally_after_loop_ctrl_statement()\n  let test =<< trim [CODE]\n    func F()\n      let loops = 2\n      while loops > 0\n        XloopNEXT\n        let loops = loops - 1\n        try\n          if loops == 1\n            Xloop 'a'\n            continue\n            call assert_report('should not get here')\n          elseif loops == 0\n            Xloop 'b'\n            break\n            call assert_report('should not get here')\n          endif\n\n          try\t\t\" inactive\n            call assert_report('should not get here')\n          finally\n            call assert_report('should not get here')\n          endtry\n        finally\n          Xloop 'c'\n        endtry\n        call assert_report('should not get here')\n      endwhile\n\n      try\n        Xpath 'd'\n        return\n        call assert_report('should not get here')\n        try\t\t    \" inactive\n          call assert_report('should not get here')\n        finally\n          call assert_report('should not get here')\n        endtry\n      finally\n        Xpath 'e'\n      endtry\n      call assert_report('should not get here')\n    endfunc\n\n    try\n      Xpath 'f'\n      call F()\n      Xpath 'g'\n      finish\n      call assert_report('should not get here')\n      try\t\t\" inactive\n        call assert_report('should not get here')\n      finally\n        call assert_report('should not get here')\n      endtry\n    finally\n      Xpath 'h'\n    endtry\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('fa2c2b3c3degh', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 22:  :finally for a :try after an error/interrupt/:throw\t\t    {{{1\n\"\n\"\t    If a :try conditional stays inactive due to a preceding error or\n\"\t    interrupt or :throw, its :finally clause should not be executed.\n\"-------------------------------------------------------------------------------\n\nfunc Test_finally_after_error_in_func()\n  let test =<< trim [CODE]\n    func Error()\n      try\n        Xpath 'b'\n        asdf    \" aborting error, triggering error exception\n        call assert_report('should not get here')\n      endtry\n      call assert_report('should not get here')\n    endfunc\n\n    Xpath 'a'\n    call Error()\n    call assert_report('should not get here')\n\n    if 1\t\" not active due to error\n      try\t\" not active since :if inactive\n        call assert_report('should not get here')\n      finally\n        call assert_report('should not get here')\n      endtry\n    endif\n\n    try\t\t\" not active due to error\n      call assert_report('should not get here')\n    finally\n      call assert_report('should not get here')\n    endtry\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('ab', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_finally_after_interrupt()\n  let test =<< trim [CODE]\n    func Interrupt()\n      try\n        Xpath 'a'\n        call interrupt()            \" triggering interrupt exception\n        call assert_report('should not get here')\n      endtry\n    endfunc\n\n    Xpath 'b'\n    try\n      call Interrupt()\n    catch /^Vim:Interrupt$/\n      Xpath 'c'\n      finish\n    endtry\n    call assert_report('should not get here')\n\n    if 1\t\" not active due to interrupt\n      try\t\" not active since :if inactive\n        call assert_report('should not get here')\n      finally\n        call assert_report('should not get here')\n      endtry\n    endif\n\n    try\t\t\" not active due to interrupt\n      call assert_report('should not get here')\n    finally\n      call assert_report('should not get here')\n    endtry\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('bac', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_finally_after_throw()\n  let test =<< trim [CODE]\n    func Throw()\n      Xpath 'a'\n      throw 'xyz'\n    endfunc\n\n    Xpath 'b'\n    call Throw()\n    call assert_report('should not get here')\n\n    if 1\t\" not active due to :throw\n      try\t\" not active since :if inactive\n        call assert_report('should not get here')\n      finally\n        call assert_report('should not get here')\n      endtry\n    endif\n\n    try\t\t\" not active due to :throw\n      call assert_report('should not get here')\n    finally\n      call assert_report('should not get here')\n    endtry\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('ba', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 23:  :catch clauses for a :try after a :throw\t\t\t    {{{1\n\"\n\"\t    If a :try conditional stays inactive due to a preceding :throw,\n\"\t    none of its :catch clauses should be executed.\n\"-------------------------------------------------------------------------------\n\nfunc Test_catch_after_throw()\n  let test =<< trim [CODE]\n    try\n      Xpath 'a'\n      throw \"xyz\"\n      call assert_report('should not get here')\n\n      if 1\t\" not active due to :throw\n        try\t\" not active since :if inactive\n          call assert_report('should not get here')\n        catch /xyz/\n          call assert_report('should not get here')\n        endtry\n      endif\n    catch /xyz/\n      Xpath 'b'\n    endtry\n\n    Xpath 'c'\n    throw \"abc\"\n    call assert_report('should not get here')\n\n    try\t\t\" not active due to :throw\n      call assert_report('should not get here')\n    catch /abc/\n      call assert_report('should not get here')\n    endtry\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abc', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 24:  :endtry for a :try after a :throw\t\t\t\t    {{{1\n\"\n\"\t    If a :try conditional stays inactive due to a preceding :throw,\n\"\t    its :endtry should not rethrow the exception to the next surrounding\n\"\t    active :try conditional.\n\"-------------------------------------------------------------------------------\n\nfunc Test_endtry_after_throw()\n  let test =<< trim [CODE]\n    try\t\t\t\" try 1\n      try\t\t\" try 2\n        Xpath 'a'\n        throw \"xyz\"\t\" makes try 2 inactive\n        call assert_report('should not get here')\n\n        try\t\t\" try 3\n          call assert_report('should not get here')\n        endtry\t\" no rethrow to try 1\n      catch /xyz/\t\" should catch although try 2 inactive\n        Xpath 'b'\n      endtry\n    catch /xyz/\t\t\" try 1 active, but exception already caught\n      call assert_report('should not get here')\n    endtry\n    Xpath 'c'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abc', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 27:  Executing :finally clauses after :return\t\t\t    {{{1\n\"\n\"\t    For a :return command dynamically enclosed in a :try/:endtry region,\n\"\t    :finally clauses are executed and the called function is ended.\n\"-------------------------------------------------------------------------------\n\nfunc T27_F()\n  try\n    Xpath 'a'\n    try\n      Xpath 'b'\n      return\n      call assert_report('should not get here')\n    finally\n      Xpath 'c'\n    endtry\n    Xpath 'd'\n  finally\n    Xpath 'e'\n  endtry\n  call assert_report('should not get here')\nendfunc\n\nfunc T27_G()\n  try\n    Xpath 'f'\n    return\n    call assert_report('should not get here')\n  finally\n    Xpath 'g'\n    call T27_F()\n    Xpath 'h'\n  endtry\n  call assert_report('should not get here')\nendfunc\n\nfunc T27_H()\n  try\n    Xpath 'i'\n    call T27_G()\n    Xpath 'j'\n  finally\n    Xpath 'k'\n    return\n    call assert_report('should not get here')\n  endtry\n  call assert_report('should not get here')\nendfunction\n\nfunc Test_finally_after_return()\n  XpathINIT\n  try\n      Xpath 'l'\n      call T27_H()\n      Xpath 'm'\n  finally\n      Xpath 'n'\n  endtry\n  call assert_equal('lifgabcehjkmn', g:Xpath)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 28:  Executing :finally clauses after :finish\t\t\t    {{{1\n\"\n\"\t    For a :finish command dynamically enclosed in a :try/:endtry region,\n\"\t    :finally clauses are executed and the sourced file is finished.\n\"\n\"\t    This test executes the bodies of the functions F, G, and H from the\n\"\t    previous test as script files (:return replaced by :finish).\n\"-------------------------------------------------------------------------------\n\nfunc Test_finally_after_finish()\n  XpathINIT\n\n  let scriptF = MakeScript(\"T27_F\")\n  let scriptG = MakeScript(\"T27_G\", scriptF)\n  let scriptH = MakeScript(\"T27_H\", scriptG)\n\n  try\n    Xpath 'A'\n    exec \"source\" scriptH\n    Xpath 'B'\n  finally\n    Xpath 'C'\n  endtry\n  Xpath 'D'\n  call assert_equal('AifgabcehjkBCD', g:Xpath)\n  call delete(scriptF)\n  call delete(scriptG)\n  call delete(scriptH)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 29:  Executing :finally clauses on errors\t\t\t    {{{1\n\"\n\"\t    After an error in a command dynamically enclosed in a :try/:endtry\n\"\t    region, :finally clauses are executed and the script processing is\n\"\t    terminated.\n\"-------------------------------------------------------------------------------\n\nfunc Test_finally_after_error_1()\n  let test =<< trim [CODE]\n    func F()\n      while 1\n        try\n          Xpath 'a'\n          while 1\n            try\n              Xpath 'b'\n              asdf\t    \" error\n              call assert_report('should not get here')\n            finally\n              Xpath 'c'\n            endtry | call assert_report('should not get here')\n            call assert_report('should not get here')\n            break\n          endwhile\n          call assert_report('should not get here')\n        finally\n          Xpath 'd'\n        endtry | call assert_report('should not get here')\n        call assert_report('should not get here')\n        break\n      endwhile\n      call assert_report('should not get here')\n    endfunc\n\n    while 1\n      try\n        Xpath 'e'\n        while 1\n          call F()\n          call assert_report('should not get here')\n          break\n        endwhile  | call assert_report('should not get here')\n        call assert_report('should not get here')\n      finally\n        Xpath 'f'\n      endtry | call assert_report('should not get here')\n    endwhile | call assert_report('should not get here')\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('eabcdf', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_finally_after_error_2()\n  let test =<< trim [CODE]\n    func G() abort\n      if 1\n        try\n          Xpath 'a'\n          asdf\t    \" error\n          call assert_report('should not get here')\n        finally\n          Xpath 'b'\n        endtry | Xpath 'c'\n      endif | Xpath 'd'\n      call assert_report('should not get here')\n    endfunc\n\n    if 1\n      try\n        Xpath 'e'\n        call G()\n        call assert_report('should not get here')\n      finally\n        Xpath 'f'\n      endtry | call assert_report('should not get here')\n    endif | call assert_report('should not get here')\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('eabf', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 30:  Executing :finally clauses on interrupt\t\t\t    {{{1\n\"\n\"\t    After an interrupt in a command dynamically enclosed in\n\"\t    a :try/:endtry region, :finally clauses are executed and the\n\"\t    script processing is terminated.\n\"-------------------------------------------------------------------------------\n\nfunc Test_finally_on_interrupt()\n  let test =<< trim [CODE]\n    func F()\n      try\n        Xloop 'a'\n        call interrupt()\n        call assert_report('should not get here')\n      finally\n        Xloop 'b'\n      endtry\n      call assert_report('should not get here')\n    endfunc\n\n    try\n      try\n        Xpath 'c'\n        try\n          Xpath 'd'\n          call interrupt()\n          call assert_report('should not get here')\n        finally\n          Xpath 'e'\n          try\n            Xpath 'f'\n            try\n              Xpath 'g'\n            finally\n              Xpath 'h'\n              try\n                Xpath 'i'\n                call interrupt()\n                call assert_report('should not get here')\n              endtry\n              call assert_report('should not get here')\n            endtry\n            call assert_report('should not get here')\n          endtry\n          call assert_report('should not get here')\n        endtry\n        call assert_report('should not get here')\n      finally\n        Xpath 'j'\n        try\n          Xpath 'k'\n          call F()\n          call assert_report('should not get here')\n        finally\n          Xpath 'l'\n          try\n            Xpath 'm'\n            XloopNEXT\n            ExecAsScript F\n            call assert_report('should not get here')\n          finally\n            Xpath 'n'\n          endtry\n          call assert_report('should not get here')\n        endtry\n        call assert_report('should not get here')\n      endtry\n      call assert_report('should not get here')\n    catch /^Vim:Interrupt$/\n      Xpath 'o'\n    endtry\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('cdefghijka1b1lma2b2no', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 31:  Executing :finally clauses after :throw\t\t\t    {{{1\n\"\n\"\t    After a :throw dynamically enclosed in a :try/:endtry region,\n\"\t    :finally clauses are executed and the script processing is\n\"\t    terminated.\n\"-------------------------------------------------------------------------------\n\nfunc Test_finally_after_throw_2()\n  let test =<< trim [CODE]\n    func F()\n      try\n        Xloop 'a'\n        throw \"exception\"\n        call assert_report('should not get here')\n      finally\n        Xloop 'b'\n      endtry\n      call assert_report('should not get here')\n    endfunc\n\n    try\n      Xpath 'c'\n      try\n        Xpath 'd'\n        throw \"exception\"\n        call assert_report('should not get here')\n      finally\n        Xpath 'e'\n        try\n          Xpath 'f'\n          try\n            Xpath 'g'\n          finally\n            Xpath 'h'\n            try\n              Xpath 'i'\n              throw \"exception\"\n              call assert_report('should not get here')\n            endtry\n            call assert_report('should not get here')\n          endtry\n          call assert_report('should not get here')\n        endtry\n        call assert_report('should not get here')\n      endtry\n      call assert_report('should not get here')\n    finally\n      Xpath 'j'\n      try\n        Xpath 'k'\n        call F()\n        call assert_report('should not get here')\n      finally\n        Xpath 'l'\n        try\n          Xpath 'm'\n          XloopNEXT\n          ExecAsScript F\n          call assert_report('should not get here')\n        finally\n          Xpath 'n'\n        endtry\n        call assert_report('should not get here')\n      endtry\n      call assert_report('should not get here')\n    endtry\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('cdefghijka1b1lma2b2n', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 34:  :finally reason discarded by :continue\t\t\t    {{{1\n\"\n\"\t    When a :finally clause is executed due to a :continue, :break,\n\"\t    :return, :finish, error, interrupt or :throw, the jump reason is\n\"\t    discarded by a :continue in the finally clause.\n\"-------------------------------------------------------------------------------\n\nfunc Test_finally_after_continue()\n  let test =<< trim [CODE]\n    func C(jump)\n      XloopNEXT\n      let loop = 0\n      while loop < 2\n        let loop = loop + 1\n        if loop == 1\n          try\n            if a:jump == \"continue\"\n              continue\n            elseif a:jump == \"break\"\n              break\n            elseif a:jump == \"return\" || a:jump == \"finish\"\n              return\n            elseif a:jump == \"error\"\n              asdf\n            elseif a:jump == \"interrupt\"\n              call interrupt()\n              let dummy = 0\n            elseif a:jump == \"throw\"\n              throw \"abc\"\n            endif\n          finally\n            continue\t\" discards jump that caused the :finally\n            call assert_report('should not get here')\n          endtry\n          call assert_report('should not get here')\n        elseif loop == 2\n          Xloop 'a'\n        endif\n      endwhile\n    endfunc\n\n    call C(\"continue\")\n    Xpath 'b'\n    call C(\"break\")\n    Xpath 'c'\n    call C(\"return\")\n    Xpath 'd'\n    let g:jump = \"finish\"\n    ExecAsScript C\n    unlet g:jump\n    Xpath 'e'\n    try\n      call C(\"error\")\n      Xpath 'f'\n    finally\n      Xpath 'g'\n      try\n        call C(\"interrupt\")\n        Xpath 'h'\n      finally\n        Xpath 'i'\n        call C(\"throw\")\n        Xpath 'j'\n      endtry\n    endtry\n    Xpath 'k'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('a2ba3ca4da5ea6fga7hia8jk', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 35:  :finally reason discarded by :break\t\t\t\t    {{{1\n\"\n\"\t    When a :finally clause is executed due to a :continue, :break,\n\"\t    :return, :finish, error, interrupt or :throw, the jump reason is\n\"\t    discarded by a :break in the finally clause.\n\"-------------------------------------------------------------------------------\n\nfunc Test_finally_discard_by_break()\n  let test =<< trim [CODE]\n    func B(jump)\n      XloopNEXT\n      let loop = 0\n      while loop < 2\n        let loop = loop + 1\n        if loop == 1\n          try\n            if a:jump == \"continue\"\n              continue\n            elseif a:jump == \"break\"\n              break\n            elseif a:jump == \"return\" || a:jump == \"finish\"\n              return\n            elseif a:jump == \"error\"\n              asdf\n            elseif a:jump == \"interrupt\"\n              call interrupt()\n              let dummy = 0\n            elseif a:jump == \"throw\"\n              throw \"abc\"\n            endif\n          finally\n            break\t\" discards jump that caused the :finally\n            call assert_report('should not get here')\n          endtry\n        elseif loop == 2\n          call assert_report('should not get here')\n        endif\n      endwhile\n      Xloop 'a'\n    endfunc\n\n    call B(\"continue\")\n    Xpath 'b'\n    call B(\"break\")\n    Xpath 'c'\n    call B(\"return\")\n    Xpath 'd'\n    let g:jump = \"finish\"\n    ExecAsScript B\n    unlet g:jump\n    Xpath 'e'\n    try\n      call B(\"error\")\n      Xpath 'f'\n    finally\n      Xpath 'g'\n      try\n        call B(\"interrupt\")\n        Xpath 'h'\n      finally\n        Xpath 'i'\n        call B(\"throw\")\n        Xpath 'j'\n      endtry\n    endtry\n    Xpath 'k'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('a2ba3ca4da5ea6fga7hia8jk', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 36:  :finally reason discarded by :return\t\t\t    {{{1\n\"\n\"\t    When a :finally clause is executed due to a :continue, :break,\n\"\t    :return, :finish, error, interrupt or :throw, the jump reason is\n\"\t    discarded by a :return in the finally clause.\n\"-------------------------------------------------------------------------------\n\nfunc Test_finally_discard_by_return()\n  let test =<< trim [CODE]\n    func R(jump, retval) abort\n      let loop = 0\n      while loop < 2\n        let loop = loop + 1\n        if loop == 1\n          try\n            if a:jump == \"continue\"\n              continue\n            elseif a:jump == \"break\"\n              break\n            elseif a:jump == \"return\"\n              return\n            elseif a:jump == \"error\"\n              asdf\n            elseif a:jump == \"interrupt\"\n              call interrupt()\n              let dummy = 0\n            elseif a:jump == \"throw\"\n              throw \"abc\"\n            endif\n          finally\n            return a:retval\t\" discards jump that caused the :finally\n            call assert_report('should not get here')\n          endtry\n        elseif loop == 2\n          call assert_report('should not get here')\n        endif\n      endwhile\n      call assert_report('should not get here')\n    endfunc\n\n    let sum =  -R(\"continue\", -8)\n    Xpath 'a'\n    let sum = sum - R(\"break\", -16)\n    Xpath 'b'\n    let sum = sum - R(\"return\", -32)\n    Xpath 'c'\n    try\n      let sum = sum - R(\"error\", -64)\n      Xpath 'd'\n    finally\n      Xpath 'e'\n      try\n        let sum = sum - R(\"interrupt\", -128)\n        Xpath 'f'\n      finally\n        Xpath 'g'\n        let sum = sum - R(\"throw\", -256)\n        Xpath 'h'\n      endtry\n    endtry\n    Xpath 'i'\n\n    let expected = 8 + 16 + 32 + 64 + 128 + 256\n    call assert_equal(sum, expected)\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcdefghi', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 37:  :finally reason discarded by :finish\t\t\t    {{{1\n\"\n\"\t    When a :finally clause is executed due to a :continue, :break,\n\"\t    :return, :finish, error, interrupt or :throw, the jump reason is\n\"\t    discarded by a :finish in the finally clause.\n\"-------------------------------------------------------------------------------\n\nfunc Test_finally_discard_by_finish()\n  let test =<< trim [CODE]\n    func F(jump)\t\" not executed as function, transformed to a script\n      let loop = 0\n      while loop < 2\n        let loop = loop + 1\n        if loop == 1\n          try\n            if a:jump == \"continue\"\n              continue\n            elseif a:jump == \"break\"\n              break\n            elseif a:jump == \"finish\"\n              finish\n            elseif a:jump == \"error\"\n              asdf\n            elseif a:jump == \"interrupt\"\n              call interrupt()\n              let dummy = 0\n            elseif a:jump == \"throw\"\n              throw \"abc\"\n            endif\n          finally\n            finish\t\" discards jump that caused the :finally\n            call assert_report('should not get here')\n          endtry\n        elseif loop == 2\n          call assert_report('should not get here')\n        endif\n      endwhile\n      call assert_report('should not get here')\n    endfunc\n\n    let scriptF = MakeScript(\"F\")\n    delfunction F\n\n    let g:jump = \"continue\"\n    exec \"source\" scriptF\n    Xpath 'a'\n    let g:jump = \"break\"\n    exec \"source\" scriptF\n    Xpath 'b'\n    let g:jump = \"finish\"\n    exec \"source\" scriptF\n    Xpath 'c'\n    try\n      let g:jump = \"error\"\n      exec \"source\" scriptF\n      Xpath 'd'\n    finally\n      Xpath 'e'\n      try\n        let g:jump = \"interrupt\"\n        exec \"source\" scriptF\n        Xpath 'f'\n      finally\n        Xpath 'g'\n        try\n          let g:jump = \"throw\"\n          exec \"source\" scriptF\n          Xpath 'h'\n        finally\n          Xpath 'i'\n        endtry\n      endtry\n    endtry\n    unlet g:jump\n    call delete(scriptF)\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcdefghi', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 38:  :finally reason discarded by an error\t\t\t    {{{1\n\"\n\"\t    When a :finally clause is executed due to a :continue, :break,\n\"\t    :return, :finish, error, interrupt or :throw, the jump reason is\n\"\t    discarded by an error in the finally clause.\n\"-------------------------------------------------------------------------------\n\nfunc Test_finally_discard_by_error()\n  let test =<< trim [CODE]\n    func E(jump)\n      let loop = 0\n      while loop < 2\n        let loop = loop + 1\n        if loop == 1\n          try\n            if a:jump == \"continue\"\n              continue\n            elseif a:jump == \"break\"\n              break\n            elseif a:jump == \"return\" || a:jump == \"finish\"\n              return\n            elseif a:jump == \"error\"\n              asdf\n            elseif a:jump == \"interrupt\"\n              call interrupt()\n              let dummy = 0\n            elseif a:jump == \"throw\"\n              throw \"abc\"\n            endif\n          finally\n            asdf\t\" error; discards jump that caused the :finally\n          endtry\n        elseif loop == 2\n          call assert_report('should not get here')\n        endif\n      endwhile\n      call assert_report('should not get here')\n    endfunc\n\n    try\n      Xpath 'a'\n      call E(\"continue\")\n      call assert_report('should not get here')\n    finally\n      try\n        Xpath 'b'\n        call E(\"break\")\n        call assert_report('should not get here')\n      finally\n        try\n          Xpath 'c'\n          call E(\"return\")\n          call assert_report('should not get here')\n        finally\n          try\n            Xpath 'd'\n            let g:jump = \"finish\"\n            ExecAsScript E\n            call assert_report('should not get here')\n          finally\n            unlet g:jump\n            try\n              Xpath 'e'\n              call E(\"error\")\n              call assert_report('should not get here')\n            finally\n              try\n                Xpath 'f'\n                call E(\"interrupt\")\n                call assert_report('should not get here')\n              finally\n                try\n                  Xpath 'g'\n                  call E(\"throw\")\n                  call assert_report('should not get here')\n                finally\n                  Xpath 'h'\n                  delfunction E\n                endtry\n              endtry\n            endtry\n          endtry\n        endtry\n      endtry\n    endtry\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcdefgh', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 39:  :finally reason discarded by an interrupt\t\t\t    {{{1\n\"\n\"\t    When a :finally clause is executed due to a :continue, :break,\n\"\t    :return, :finish, error, interrupt or :throw, the jump reason is\n\"\t    discarded by an interrupt in the finally clause.\n\"-------------------------------------------------------------------------------\n\nfunc Test_finally_discarded_by_interrupt()\n  let test =<< trim [CODE]\n    func I(jump)\n      let loop = 0\n      while loop < 2\n        let loop = loop + 1\n        if loop == 1\n          try\n            if a:jump == \"continue\"\n              continue\n            elseif a:jump == \"break\"\n              break\n            elseif a:jump == \"return\" || a:jump == \"finish\"\n              return\n            elseif a:jump == \"error\"\n              asdf\n            elseif a:jump == \"interrupt\"\n              call interrupt()\n              let dummy = 0\n            elseif a:jump == \"throw\"\n              throw \"abc\"\n            endif\n          finally\n            call interrupt()\n            let dummy = 0\n          endtry\n        elseif loop == 2\n          call assert_report('should not get here')\n        endif\n      endwhile\n      call assert_report('should not get here')\n    endfunc\n\n    try\n      try\n        Xpath 'a'\n        call I(\"continue\")\n        call assert_report('should not get here')\n      finally\n        try\n          Xpath 'b'\n          call I(\"break\")\n          call assert_report('should not get here')\n        finally\n          try\n            Xpath 'c'\n            call I(\"return\")\n            call assert_report('should not get here')\n          finally\n            try\n              Xpath 'd'\n              let g:jump = \"finish\"\n              ExecAsScript I\n              call assert_report('should not get here')\n            finally\n              unlet g:jump\n              try\n                Xpath 'e'\n                call I(\"error\")\n                call assert_report('should not get here')\n              finally\n                try\n                  Xpath 'f'\n                  call I(\"interrupt\")\n                  call assert_report('should not get here')\n                finally\n                  try\n                    Xpath 'g'\n                    call I(\"throw\")\n                    call assert_report('should not get here')\n                  finally\n                    Xpath 'h'\n                    delfunction I\n                  endtry\n                endtry\n              endtry\n            endtry\n          endtry\n        endtry\n      endtry\n      call assert_report('should not get here')\n    catch /^Vim:Interrupt$/\n      Xpath 'A'\n    endtry\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcdefghA', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 40:  :finally reason discarded by :throw\t\t\t\t    {{{1\n\"\n\"\t    When a :finally clause is executed due to a :continue, :break,\n\"\t    :return, :finish, error, interrupt or :throw, the jump reason is\n\"\t    discarded by a :throw in the finally clause.\n\"-------------------------------------------------------------------------------\n\nfunc Test_finally_discard_by_throw()\n  let test =<< trim [CODE]\n    func T(jump)\n      let loop = 0\n      while loop < 2\n        let loop = loop + 1\n        if loop == 1\n          try\n            if a:jump == \"continue\"\n              continue\n            elseif a:jump == \"break\"\n              break\n            elseif a:jump == \"return\" || a:jump == \"finish\"\n              return\n            elseif a:jump == \"error\"\n              asdf\n            elseif a:jump == \"interrupt\"\n              call interrupt()\n              let dummy = 0\n            elseif a:jump == \"throw\"\n              throw \"abc\"\n            endif\n          finally\n            throw \"xyz\"\t\" discards jump that caused the :finally\n          endtry\n        elseif loop == 2\n          call assert_report('should not get here')\n        endif\n      endwhile\n      call assert_report('should not get here')\n    endfunc\n\n    try\n      Xpath 'a'\n      call T(\"continue\")\n      call assert_report('should not get here')\n    finally\n      try\n        Xpath 'b'\n        call T(\"break\")\n        call assert_report('should not get here')\n      finally\n        try\n          Xpath 'c'\n          call T(\"return\")\n          call assert_report('should not get here')\n        finally\n          try\n            Xpath 'd'\n            let g:jump = \"finish\"\n            ExecAsScript T\n            call assert_report('should not get here')\n          finally\n            unlet g:jump\n            try\n              Xpath 'e'\n              call T(\"error\")\n              call assert_report('should not get here')\n            finally\n              try\n                Xpath 'f'\n                call T(\"interrupt\")\n                call assert_report('should not get here')\n              finally\n                try\n                  Xpath 'g'\n                  call T(\"throw\")\n                  call assert_report('should not get here')\n                finally\n                  Xpath 'h'\n                  delfunction T\n                endtry\n              endtry\n            endtry\n          endtry\n        endtry\n      endtry\n    endtry\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcdefgh', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 49:  Throwing exceptions across functions\t\t\t    {{{1\n\"\n\"\t    When an exception is thrown but not caught inside a function, the\n\"\t    caller is checked for a matching :catch clause.\n\"-------------------------------------------------------------------------------\n\nfunc T49_C()\n  try\n    Xpath 'a'\n    throw \"arrgh\"\n    call assert_report('should not get here')\n  catch /arrgh/\n    Xpath 'b'\n  endtry\n  Xpath 'c'\nendfunc\n\nfunc T49_T1()\n  XloopNEXT\n  try\n    Xloop 'd'\n    throw \"arrgh\"\n    call assert_report('should not get here')\n  finally\n    Xloop 'e'\n  endtry\n  Xloop 'f'\nendfunc\n\nfunc T49_T2()\n  try\n    Xpath 'g'\n    call T49_T1()\n    call assert_report('should not get here')\n  finally\n    Xpath 'h'\n  endtry\n  call assert_report('should not get here')\nendfunc\n\nfunc Test_throw_exception_across_funcs()\n  XpathINIT\n  XloopINIT\n  try\n    Xpath 'i'\n    call T49_C()            \" throw and catch\n    Xpath 'j'\n  catch /.*/\n    call assert_report('should not get here')\n  endtry\n\n  try\n    Xpath 'k'\n    call T49_T1()  \" throw, one level\n    call assert_report('should not get here')\n  catch /arrgh/\n    Xpath 'l'\n  catch /.*/\n    call assert_report('should not get here')\n  endtry\n\n  try\n    Xpath 'm'\n    call T49_T2()\t\" throw, two levels\n    call assert_report('should not get here')\n  catch /arrgh/\n    Xpath 'n'\n  catch /.*/\n    call assert_report('should not get here')\n  endtry\n  Xpath 'o'\n\n  call assert_equal('iabcjkd2e2lmgd3e3hno', g:Xpath)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 50:  Throwing exceptions across script files\t\t\t    {{{1\n\"\n\"\t    When an exception is thrown but not caught inside a script file,\n\"\t    the sourcing script or function is checked for a matching :catch\n\"\t    clause.\n\"\n\"\t    This test executes the bodies of the functions C, T1, and T2 from\n\"\t    the previous test as script files (:return replaced by :finish).\n\"-------------------------------------------------------------------------------\n\nfunc T50_F()\n  try\n    Xpath 'A'\n    exec \"source\" g:scriptC\n    Xpath 'B'\n  catch /.*/\n    call assert_report('should not get here')\n  endtry\n\n  try\n    Xpath 'C'\n    exec \"source\" g:scriptT1\n    call assert_report('should not get here')\n  catch /arrgh/\n    Xpath 'D'\n  catch /.*/\n    call assert_report('should not get here')\n  endtry\nendfunc\n\nfunc Test_throw_across_script()\n  XpathINIT\n  XloopINIT\n  let g:scriptC = MakeScript(\"T49_C\")\n  let g:scriptT1 = MakeScript(\"T49_T1\")\n  let scriptT2 = MakeScript(\"T49_T2\", g:scriptT1)\n\n  try\n    Xpath 'E'\n    call T50_F()\n    Xpath 'F'\n    exec \"source\" scriptT2\n    call assert_report('should not get here')\n  catch /arrgh/\n    Xpath 'G'\n  catch /.*/\n    call assert_report('should not get here')\n  endtry\n  Xpath 'H'\n  call assert_equal('EAabcBCd2e2DFgd3e3hGH', g:Xpath)\n\n  call delete(g:scriptC)\n  call delete(g:scriptT1)\n  call delete(scriptT2)\n  unlet g:scriptC g:scriptT1 scriptT2\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 52:  Uncaught exceptions\t\t\t\t\t\t    {{{1\n\"\n\"\t    When an exception is thrown but not caught, an error message is\n\"\t    displayed when the script is terminated.  In case of an interrupt\n\"\t    or error exception, the normal interrupt or error message(s) are\n\"\t    displayed.\n\"-------------------------------------------------------------------------------\n\nfunc Test_uncaught_exception_1()\n  CheckEnglish\n\n  let test =<< trim [CODE]\n    Xpath 'a'\n    throw \"arrgh\"\n    call assert_report('should not get here')`\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('E605: Exception not caught: arrgh', v:errmsg)\n    call assert_equal('a', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_uncaught_exception_2()\n  CheckEnglish\n\n  let test =<< trim [CODE]\n    try\n      Xpath 'a'\n      throw \"oops\"\n      call assert_report('should not get here')`\n    catch /arrgh/\n      call assert_report('should not get here')`\n    endtry\n    call assert_report('should not get here')`\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('E605: Exception not caught: oops', v:errmsg)\n    call assert_equal('a', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_uncaught_exception_3()\n  CheckEnglish\n\n  let test =<< trim [CODE]\n    func T()\n      Xpath 'c'\n      throw \"brrr\"\n      call assert_report('should not get here')`\n    endfunc\n\n    try\n      Xpath 'a'\n      throw \"arrgh\"\n      call assert_report('should not get here')`\n    catch /.*/\n      Xpath 'b'\n      call T()\n      call assert_report('should not get here')`\n    endtry\n    call assert_report('should not get here')`\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('E605: Exception not caught: brrr', v:errmsg)\n    call assert_equal('abc', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_uncaught_exception_4()\n  CheckEnglish\n\n  let test =<< trim [CODE]\n    try\n      Xpath 'a'\n      throw \"arrgh\"\n      call assert_report('should not get here')`\n    finally\n      Xpath 'b'\n      throw \"brrr\"\n      call assert_report('should not get here')`\n    endtry\n    call assert_report('should not get here')`\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('E605: Exception not caught: brrr', v:errmsg)\n    call assert_equal('ab', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_uncaught_exception_5()\n  CheckEnglish\n\n  \" Need to catch and handle interrupt, otherwise the test will wait for the\n  \" user to press <Enter> to continue\n  let test =<< trim [CODE]\n    try\n      try\n        Xpath 'a'\n        call interrupt()\n        call assert_report('should not get here')\n      endtry\n      call assert_report('should not get here')\n    catch /^Vim:Interrupt$/\n      Xpath 'b'\n    endtry\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('ab', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_uncaught_exception_6()\n  CheckEnglish\n\n  let test =<< trim [CODE]\n    try\n      Xpath 'a'\n      let x = novar\t\" error E121; exception: E121\n    catch /E15:/\t\" should not catch\n      call assert_report('should not get here')\n    endtry\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('a', g:Xpath)\n    call assert_equal('E121: Undefined variable: novar', v:errmsg)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_uncaught_exception_7()\n  CheckEnglish\n\n  let test =<< trim [CODE]\n    try\n      Xpath 'a'\n      \" error E108/E488; exception: E488\n      unlet novar #\n    catch /E108:/       \" should not catch\n      call assert_report('should not get here')\n    endtry\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('a', g:Xpath)\n    call assert_equal('E488: Trailing characters: #', v:errmsg)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 53:  Nesting errors: :endif/:else/:elseif\t\t\t    {{{1\n\"\n\"\t    For nesting errors of :if conditionals the correct error messages\n\"\t    should be given.\n\"-------------------------------------------------------------------------------\n\nfunc Test_nested_if_else_errors()\n  CheckEnglish\n\n  \" :endif without :if\n  let code =<< trim END\n    endif\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endif):E580: :endif without :if')\n\n  \" :endif without :if\n  let code =<< trim END\n    while 1\n      endif\n    endwhile\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endif):E580: :endif without :if')\n\n  \" :endif without :if\n  let code =<< trim END\n    try\n    finally\n      endif\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endif):E580: :endif without :if')\n\n  \" :endif without :if\n  let code =<< trim END\n    try\n      endif\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endif):E580: :endif without :if')\n\n  \" :endif without :if\n  let code =<< trim END\n    try\n      throw \"a\"\n    catch /a/\n      endif\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endif):E580: :endif without :if')\n\n  \" :else without :if\n  let code =<< trim END\n    else\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(else):E581: :else without :if')\n\n  \" :else without :if\n  let code =<< trim END\n    while 1\n      else\n    endwhile\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(else):E581: :else without :if')\n\n  \" :else without :if\n  let code =<< trim END\n    try\n    finally\n      else\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(else):E581: :else without :if')\n\n  \" :else without :if\n  let code =<< trim END\n    try\n      else\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(else):E581: :else without :if')\n\n  \" :else without :if\n  let code =<< trim END\n    try\n      throw \"a\"\n    catch /a/\n      else\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(else):E581: :else without :if')\n\n  \" :elseif without :if\n  let code =<< trim END\n    elseif 1\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(elseif):E582: :elseif without :if')\n\n  \" :elseif without :if\n  let code =<< trim END\n    while 1\n      elseif 1\n    endwhile\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(elseif):E582: :elseif without :if')\n\n  \" :elseif without :if\n  let code =<< trim END\n    try\n    finally\n      elseif 1\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(elseif):E582: :elseif without :if')\n\n  \" :elseif without :if\n  let code =<< trim END\n    try\n      elseif 1\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(elseif):E582: :elseif without :if')\n\n  \" :elseif without :if\n  let code =<< trim END\n    try\n      throw \"a\"\n    catch /a/\n      elseif 1\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(elseif):E582: :elseif without :if')\n\n  \" multiple :else\n  let code =<< trim END\n    if 1\n    else\n    else\n    endif\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(else):E583: Multiple :else')\n\n  \" :elseif after :else\n  let code =<< trim END\n    if 1\n    else\n    elseif 1\n    endif\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(elseif):E584: :elseif after :else')\n\n  call delete('Xtest')\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 54:  Nesting errors: :while/:endwhile\t\t\t\t    {{{1\n\"\n\"\t    For nesting errors of :while conditionals the correct error messages\n\"\t    should be given.\n\"\n\"\t    This test reuses the function MESSAGES() from the previous test.\n\"\t    This functions checks the messages in g:msgfile.\n\"-------------------------------------------------------------------------------\n\nfunc Test_nested_while_error()\n  CheckEnglish\n\n  \" :endwhile without :while\n  let code =<< trim END\n    endwhile\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endwhile):E588: :endwhile without :while')\n\n  \" :endwhile without :while\n  let code =<< trim END\n    if 1\n      endwhile\n    endif\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endwhile):E588: :endwhile without :while')\n\n  \" Missing :endif\n  let code =<< trim END\n    while 1\n      if 1\n    endwhile\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endwhile):E171: Missing :endif')\n\n  \" :endwhile without :while\n  let code =<< trim END\n    try\n    finally\n      endwhile\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endwhile):E588: :endwhile without :while')\n\n  \" Missing :endtry\n  let code =<< trim END\n    while 1\n      try\n      finally\n    endwhile\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endwhile):E600: Missing :endtry')\n\n  \" Missing :endtry\n  let code =<< trim END\n    while 1\n      if 1\n        try\n        finally\n    endwhile\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endwhile):E600: Missing :endtry')\n\n  \" Missing :endif\n  let code =<< trim END\n    while 1\n      try\n      finally\n        if 1\n    endwhile\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endwhile):E171: Missing :endif')\n\n  \" :endwhile without :while\n  let code =<< trim END\n    try\n      endwhile\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endwhile):E588: :endwhile without :while')\n\n  \" :endwhile without :while\n  let code =<< trim END\n    while 1\n      try\n        endwhile\n      endtry\n    endwhile\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endwhile):E588: :endwhile without :while')\n\n  \" :endwhile without :while\n  let code =<< trim END\n    try\n      throw \"a\"\n    catch /a/\n      endwhile\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endwhile):E588: :endwhile without :while')\n\n  \" :endwhile without :while\n  let code =<< trim END\n    while 1\n      try\n        throw \"a\"\n      catch /a/\n        endwhile\n      endtry\n    endwhile\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endwhile):E588: :endwhile without :while')\n\n  call delete('Xtest')\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 55:  Nesting errors: :continue/:break\t\t\t\t    {{{1\n\"\n\"\t    For nesting errors of :continue and :break commands the correct\n\"\t    error messages should be given.\n\"\n\"\t    This test reuses the function MESSAGES() from the previous test.\n\"\t    This functions checks the messages in g:msgfile.\n\"-------------------------------------------------------------------------------\n\nfunc Test_nested_cont_break_error()\n  CheckEnglish\n\n  \" :continue without :while\n  let code =<< trim END\n    continue\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(continue):E586: :continue without :while or :for')\n\n  \" :continue without :while\n  let code =<< trim END\n    if 1\n      continue\n    endif\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(continue):E586: :continue without :while or :for')\n\n  \" :continue without :while\n  let code =<< trim END\n    try\n    finally\n      continue\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(continue):E586: :continue without :while or :for')\n\n  \" :continue without :while\n  let code =<< trim END\n    try\n      continue\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(continue):E586: :continue without :while or :for')\n\n  \" :continue without :while\n  let code =<< trim END\n    try\n      throw \"a\"\n    catch /a/\n      continue\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(continue):E586: :continue without :while or :for')\n\n  \" :break without :while\n  let code =<< trim END\n    break\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(break):E587: :break without :while or :for')\n\n  \" :break without :while\n  let code =<< trim END\n    if 1\n      break\n    endif\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(break):E587: :break without :while or :for')\n\n  \" :break without :while\n  let code =<< trim END\n    try\n    finally\n      break\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(break):E587: :break without :while or :for')\n\n  \" :break without :while\n  let code =<< trim END\n    try\n      break\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(break):E587: :break without :while or :for')\n\n  \" :break without :while\n  let code =<< trim END\n    try\n      throw \"a\"\n    catch /a/\n      break\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(break):E587: :break without :while or :for')\n\n  call delete('Xtest')\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 56:  Nesting errors: :endtry\t\t\t\t\t    {{{1\n\"\n\"\t    For nesting errors of :try conditionals the correct error messages\n\"\t    should be given.\n\"\n\"\t    This test reuses the function MESSAGES() from the previous test.\n\"\t    This functions checks the messages in g:msgfile.\n\"-------------------------------------------------------------------------------\n\nfunc Test_nested_endtry_error()\n  CheckEnglish\n\n  \" :endtry without :try\n  let code =<< trim END\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endtry):E602: :endtry without :try')\n\n  \" :endtry without :try\n  let code =<< trim END\n    if 1\n      endtry\n    endif\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endtry):E602: :endtry without :try')\n\n  \" :endtry without :try\n  let code =<< trim END\n    while 1\n      endtry\n    endwhile\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endtry):E602: :endtry without :try')\n\n  \" Missing :endif\n  let code =<< trim END\n    try\n        if 1\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endtry):E171: Missing :endif')\n\n  \" Missing :endwhile\n  let code =<< trim END\n    try\n      while 1\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endtry):E170: Missing :endwhile')\n\n  \" Missing :endif\n  let code =<< trim END\n    try\n    finally\n      if 1\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endtry):E171: Missing :endif')\n\n  \" Missing :endwhile\n  let code =<< trim END\n    try\n    finally\n      while 1\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endtry):E170: Missing :endwhile')\n\n  \" Missing :endif\n  let code =<< trim END\n    try\n      throw \"a\"\n    catch /a/\n      if 1\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endtry):E171: Missing :endif')\n\n  \" Missing :endwhile\n  let code =<< trim END\n    try\n      throw \"a\"\n    catch /a/\n      while 1\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endtry):E170: Missing :endwhile')\n\n  call delete('Xtest')\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 57:  v:exception and v:throwpoint for user exceptions\t\t    {{{1\n\"\n\"\t    v:exception evaluates to the value of the exception that was caught\n\"\t    most recently and is not finished.  (A caught exception is finished\n\"\t    when the next \":catch\", \":finally\", or \":endtry\" is reached.)\n\"\t    v:throwpoint evaluates to the script/function name and line number\n\"\t    where that exception has been thrown.\n\"-------------------------------------------------------------------------------\n\nfunc Test_user_exception_info()\n  CheckEnglish\n\n  XpathINIT\n  XloopINIT\n\n  func FuncException()\n    let g:exception = v:exception\n  endfunc\n\n  func FuncThrowpoint()\n    let g:throwpoint = v:throwpoint\n  endfunc\n\n  let scriptException  = MakeScript(\"FuncException\")\n  let scriptThrowPoint = MakeScript(\"FuncThrowpoint\")\n\n  command! CmdException  let g:exception  = v:exception\n  command! CmdThrowpoint let g:throwpoint = v:throwpoint\n\n  func T(arg, line)\n    if a:line == 2\n      throw a:arg\t\t\" in line 2\n    elseif a:line == 4\n      throw a:arg\t\t\" in line 4\n    elseif a:line == 6\n      throw a:arg\t\t\" in line 6\n    elseif a:line == 8\n      throw a:arg\t\t\" in line 8\n    endif\n  endfunc\n\n  func G(arg, line)\n    call T(a:arg, a:line)\n  endfunc\n\n  func F(arg, line)\n    call G(a:arg, a:line)\n  endfunc\n\n  let scriptT = MakeScript(\"T\")\n  let scriptG = MakeScript(\"G\", scriptT)\n  let scriptF = MakeScript(\"F\", scriptG)\n\n  try\n    Xpath 'a'\n    call F(\"oops\", 2)\n  catch /.*/\n    Xpath 'b'\n    let exception  = v:exception\n    let throwpoint = v:throwpoint\n    call assert_equal(\"oops\", v:exception)\n    call assert_match('\\<F\\[1]\\.\\.G\\[1]\\.\\.T\\>', v:throwpoint)\n    call assert_match('\\<2\\>', v:throwpoint)\n\n    exec \"let exception  = v:exception\"\n    exec \"let throwpoint = v:throwpoint\"\n    call assert_equal(\"oops\", v:exception)\n    call assert_match('\\<F\\[1]\\.\\.G\\[1]\\.\\.T\\>', v:throwpoint)\n    call assert_match('\\<2\\>', v:throwpoint)\n\n    CmdException\n    CmdThrowpoint\n    call assert_equal(\"oops\", v:exception)\n    call assert_match('\\<F\\[1]\\.\\.G\\[1]\\.\\.T\\>', v:throwpoint)\n    call assert_match('\\<2\\>', v:throwpoint)\n\n    call FuncException()\n    call FuncThrowpoint()\n    call assert_equal(\"oops\", v:exception)\n    call assert_match('\\<F\\[1]\\.\\.G\\[1]\\.\\.T\\>', v:throwpoint)\n    call assert_match('\\<2\\>', v:throwpoint)\n\n    exec \"source\" scriptException\n    exec \"source\" scriptThrowPoint\n    call assert_equal(\"oops\", v:exception)\n    call assert_match('\\<F\\[1]\\.\\.G\\[1]\\.\\.T\\>', v:throwpoint)\n    call assert_match('\\<2\\>', v:throwpoint)\n\n    try\n      Xpath 'c'\n      call G(\"arrgh\", 4)\n    catch /.*/\n      Xpath 'd'\n      let exception  = v:exception\n      let throwpoint = v:throwpoint\n      call assert_equal(\"arrgh\", v:exception)\n      call assert_match('\\<G\\[1]\\.\\.T\\>', v:throwpoint)\n      call assert_match('\\<4\\>', v:throwpoint)\n\n      try\n        Xpath 'e'\n        let g:arg = \"autsch\"\n        let g:line = 6\n        exec \"source\" scriptF\n      catch /.*/\n        Xpath 'f'\n        let exception  = v:exception\n        let throwpoint = v:throwpoint\n        call assert_equal(\"autsch\", v:exception)\n        call assert_match(fnamemodify(scriptT, ':t'), v:throwpoint)\n        call assert_match('\\<6\\>', v:throwpoint)\n      finally\n        Xpath 'g'\n        let exception  = v:exception\n        let throwpoint = v:throwpoint\n        call assert_equal(\"arrgh\", v:exception)\n        call assert_match('\\<G\\[1]\\.\\.T\\>', v:throwpoint)\n        call assert_match('\\<4\\>', v:throwpoint)\n        try\n          Xpath 'h'\n          let g:arg = \"brrrr\"\n          let g:line = 8\n          exec \"source\" scriptG\n        catch /.*/\n          Xpath 'i'\n          let exception  = v:exception\n          let throwpoint = v:throwpoint\n          \" Resolve scriptT for matching it against v:throwpoint.\n          call assert_equal(\"brrrr\", v:exception)\n          call assert_match(fnamemodify(scriptT, ':t'), v:throwpoint)\n          call assert_match('\\<8\\>', v:throwpoint)\n        finally\n          Xpath 'j'\n          let exception  = v:exception\n          let throwpoint = v:throwpoint\n          call assert_equal(\"arrgh\", v:exception)\n          call assert_match('\\<G\\[1]\\.\\.T\\>', v:throwpoint)\n          call assert_match('\\<4\\>', v:throwpoint)\n        endtry\n        Xpath 'k'\n        let exception  = v:exception\n        let throwpoint = v:throwpoint\n        call assert_equal(\"arrgh\", v:exception)\n        call assert_match('\\<G\\[1]\\.\\.T\\>', v:throwpoint)\n        call assert_match('\\<4\\>', v:throwpoint)\n      endtry\n      Xpath 'l'\n      let exception  = v:exception\n      let throwpoint = v:throwpoint\n      call assert_equal(\"arrgh\", v:exception)\n      call assert_match('\\<G\\[1]\\.\\.T\\>', v:throwpoint)\n      call assert_match('\\<4\\>', v:throwpoint)\n    finally\n      Xpath 'm'\n      let exception  = v:exception\n      let throwpoint = v:throwpoint\n      call assert_equal(\"oops\", v:exception)\n      call assert_match('\\<F\\[1]\\.\\.G\\[1]\\.\\.T\\>', v:throwpoint)\n      call assert_match('\\<2\\>', v:throwpoint)\n    endtry\n    Xpath 'n'\n    let exception  = v:exception\n    let throwpoint = v:throwpoint\n    call assert_equal(\"oops\", v:exception)\n    call assert_match('\\<F\\[1]\\.\\.G\\[1]\\.\\.T\\>', v:throwpoint)\n    call assert_match('\\<2\\>', v:throwpoint)\n  finally\n    Xpath 'o'\n    let exception  = v:exception\n    let throwpoint = v:throwpoint\n    call assert_equal(\"\", v:exception)\n    call assert_match('^$', v:throwpoint)\n    call assert_match('^$', v:throwpoint)\n  endtry\n\n  call assert_equal('abcdefghijklmno', g:Xpath)\n\n  unlet exception throwpoint\n  delfunction FuncException\n  delfunction FuncThrowpoint\n  call delete(scriptException)\n  call delete(scriptThrowPoint)\n  unlet scriptException scriptThrowPoint\n  delcommand CmdException\n  delcommand CmdThrowpoint\n  delfunction T\n  delfunction G\n  delfunction F\n  call delete(scriptT)\n  call delete(scriptG)\n  call delete(scriptF)\n  unlet scriptT scriptG scriptF\nendfunc\n\n\"-------------------------------------------------------------------------------\n\"\n\" Test 58:  v:exception and v:throwpoint for error/interrupt exceptions\t    {{{1\n\"\n\"\t    v:exception and v:throwpoint work also for error and interrupt\n\"\t    exceptions.\n\"-------------------------------------------------------------------------------\n\nfunc Test_exception_info_for_error()\n  CheckEnglish\n\n  let test =<< trim [CODE]\n    func T(line)\n      if a:line == 2\n        delfunction T\t\t\" error (function in use) in line 2\n      elseif a:line == 4\n        call interrupt()\n      endif\n    endfunc\n\n    while 1\n      try\n        Xpath 'a'\n        call T(2)\n        call assert_report('should not get here')\n      catch /.*/\n        Xpath 'b'\n        if v:exception !~ 'Vim(delfunction):'\n          call assert_report('should not get here')\n        endif\n        if v:throwpoint !~ '\\<T\\>'\n          call assert_report('should not get here')\n        endif\n        if v:throwpoint !~ '\\<2\\>'\n          call assert_report('should not get here')\n        endif\n      finally\n        Xpath 'c'\n        if v:exception != \"\"\n          call assert_report('should not get here')\n        endif\n        if v:throwpoint != \"\"\n          call assert_report('should not get here')\n        endif\n        break\n      endtry\n    endwhile\n\n    Xpath 'd'\n    if v:exception != \"\"\n      call assert_report('should not get here')\n    endif\n    if v:throwpoint != \"\"\n      call assert_report('should not get here')\n    endif\n\n    while 1\n      try\n        Xpath 'e'\n        call T(4)\n        call assert_report('should not get here')\n      catch /.*/\n        Xpath 'f'\n        if v:exception != 'Vim:Interrupt'\n          call assert_report('should not get here')\n        endif\n        if v:throwpoint !~ 'function T'\n          call assert_report('should not get here')\n        endif\n        if v:throwpoint !~ '\\<4\\>'\n          call assert_report('should not get here')\n        endif\n      finally\n        Xpath 'g'\n        if v:exception != \"\"\n          call assert_report('should not get here')\n        endif\n        if v:throwpoint != \"\"\n          call assert_report('should not get here')\n        endif\n        break\n      endtry\n    endwhile\n\n    Xpath 'h'\n    if v:exception != \"\"\n      call assert_report('should not get here')\n    endif\n    if v:throwpoint != \"\"\n      call assert_report('should not get here')\n    endif\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcdefgh', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\"\n\" Test 59:  v:exception and v:throwpoint when discarding exceptions\t    {{{1\n\"\n\"\t    When a :catch clause is left by a \":break\" etc or an error or\n\"\t    interrupt exception, v:exception and v:throwpoint are reset.  They\n\"\t    are not affected by an exception that is discarded before being\n\"\t    caught.\n\"-------------------------------------------------------------------------------\nfunc Test_exception_info_on_discard()\n  CheckEnglish\n\n  let test =<< trim [CODE]\n    let sfile = expand(\"<sfile>\")\n\n    while 1\n      try\n        throw \"x1\"\n      catch /.*/\n        break\n      endtry\n    endwhile\n    call assert_equal('', v:exception)\n    call assert_equal('', v:throwpoint)\n\n    while 1\n      try\n        throw \"x2\"\n      catch /.*/\n        break\n      finally\n        call assert_equal('', v:exception)\n        call assert_equal('', v:throwpoint)\n      endtry\n      break\n    endwhile\n    call assert_equal('', v:exception)\n    call assert_equal('', v:throwpoint)\n\n    while 1\n      try\n        let errcaught = 0\n        try\n          try\n            throw \"x3\"\n          catch /.*/\n            let lnum = expand(\"<sflnum>\")\n            asdf\n          endtry\n        catch /.*/\n          let errcaught = 1\n          call assert_match('Vim:E492: Not an editor command:', v:exception)\n          call assert_match('line ' .. (lnum + 1), v:throwpoint)\n        endtry\n      finally\n        call assert_equal(1, errcaught)\n        break\n      endtry\n    endwhile\n    call assert_equal('', v:exception)\n    call assert_equal('', v:throwpoint)\n\n    Xpath 'a'\n\n    while 1\n      try\n        let intcaught = 0\n        try\n          try\n            throw \"x4\"\n          catch /.*/\n            let lnum = expand(\"<sflnum>\")\n            call interrupt()\n          endtry\n        catch /.*/\n          let intcaught = 1\n          call assert_match('Vim:Interrupt', v:exception)\n          call assert_match('line ' .. (lnum + 1), v:throwpoint)\n        endtry\n      finally\n        call assert_equal(1, intcaught)\n        break\n      endtry\n    endwhile\n    call assert_equal('', v:exception)\n    call assert_equal('', v:throwpoint)\n\n    Xpath 'b'\n\n    while 1\n      try\n        let errcaught = 0\n        try\n          try\n            if 1\n              let lnum = expand(\"<sflnum>\")\n              throw \"x5\"\n            \" missing endif\n          catch /.*/\n            call assert_report('should not get here')\n          endtry\n        catch /.*/\n          let errcaught = 1\n          call assert_match('Vim(catch):E171: Missing :endif:', v:exception)\n          call assert_match('line ' .. (lnum + 3), v:throwpoint)\n        endtry\n      finally\n        call assert_equal(1, errcaught)\n        break\n      endtry\n    endwhile\n    call assert_equal('', v:exception)\n    call assert_equal('', v:throwpoint)\n\n    Xpath 'c'\n\n    try\n      while 1\n        try\n          throw \"x6\"\n        finally\n          break\n        endtry\n        break\n      endwhile\n    catch /.*/\n      call assert_report('should not get here')\n    endtry\n    call assert_equal('', v:exception)\n    call assert_equal('', v:throwpoint)\n\n    try\n      while 1\n        try\n          throw \"x7\"\n        finally\n          break\n        endtry\n        break\n      endwhile\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      call assert_equal('', v:exception)\n      call assert_equal('', v:throwpoint)\n    endtry\n    call assert_equal('', v:exception)\n    call assert_equal('', v:throwpoint)\n\n    while 1\n      try\n        let errcaught = 0\n        try\n          try\n            throw \"x8\"\n          finally\n            let lnum = expand(\"<sflnum>\")\n            asdf\n          endtry\n        catch /.*/\n          let errcaught = 1\n          call assert_match('Vim:E492: Not an editor command:', v:exception)\n          call assert_match('line ' .. (lnum + 1), v:throwpoint)\n        endtry\n      finally\n        call assert_equal(1, errcaught)\n        break\n      endtry\n    endwhile\n    call assert_equal('', v:exception)\n    call assert_equal('', v:throwpoint)\n\n    Xpath 'd'\n\n    while 1\n      try\n        let intcaught = 0\n        try\n          try\n            throw \"x9\"\n          finally\n            let lnum = expand(\"<sflnum>\")\n            call interrupt()\n          endtry\n        catch /.*/\n          let intcaught = 1\n          call assert_match('Vim:Interrupt', v:exception)\n          call assert_match('line ' .. (lnum + 1), v:throwpoint)\n        endtry\n      finally\n        call assert_equal(1, intcaught)\n        break\n      endtry\n    endwhile\n    call assert_equal('', v:exception)\n    call assert_equal('', v:throwpoint)\n\n    Xpath 'e'\n\n    while 1\n      try\n        let errcaught = 0\n        try\n          try\n            if 1\n              let lnum = expand(\"<sflnum>\")\n              throw \"x10\"\n            \" missing endif\n          finally\n            call assert_equal('', v:exception)\n            call assert_equal('', v:throwpoint)\n          endtry\n        catch /.*/\n          let errcaught = 1\n          call assert_match('Vim(finally):E171: Missing :endif:', v:exception)\n          call assert_match('line ' .. (lnum + 3), v:throwpoint)\n        endtry\n      finally\n        call assert_equal(1, errcaught)\n        break\n      endtry\n    endwhile\n    call assert_equal('', v:exception)\n    call assert_equal('', v:throwpoint)\n\n    Xpath 'f'\n\n    while 1\n      try\n        let errcaught = 0\n        try\n          try\n            if 1\n              let lnum = expand(\"<sflnum>\")\n              throw \"x11\"\n            \" missing endif\n          endtry\n        catch /.*/\n          let errcaught = 1\n          call assert_match('Vim(endtry):E171: Missing :endif:', v:exception)\n          call assert_match('line ' .. (lnum + 3), v:throwpoint)\n        endtry\n      finally\n        call assert_equal(1, errcaught)\n        break\n      endtry\n    endwhile\n    call assert_equal('', v:exception)\n    call assert_equal('', v:throwpoint)\n\n    Xpath 'g'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcdefg', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\"\n\" Test 60:  (Re)throwing v:exception; :echoerr.\t\t\t\t    {{{1\n\"\n\"\t    A user exception can be rethrown after catching by throwing\n\"\t    v:exception.  An error or interrupt exception cannot be rethrown\n\"\t    because Vim exceptions cannot be faked.  A Vim exception using the\n\"\t    value of v:exception can, however, be triggered by the :echoerr\n\"\t    command.\n\"-------------------------------------------------------------------------------\n\nfunc Test_rethrow_exception_1()\n  XpathINIT\n  try\n    try\n      Xpath 'a'\n      throw \"oops\"\n    catch /oops/\n      Xpath 'b'\n      throw v:exception\t\" rethrow user exception\n    catch /.*/\n      call assert_report('should not get here')\n    endtry\n  catch /^oops$/\t\t\t\" catches rethrown user exception\n    Xpath 'c'\n  catch /.*/\n    call assert_report('should not get here')\n  endtry\n  call assert_equal('abc', g:Xpath)\nendfunc\n\nfunc Test_rethrow_exception_2()\n  XpathINIT\n  try\n    let caught = 0\n    try\n      Xpath 'a'\n      write /n/o/n/w/r/i/t/a/b/l/e/_/f/i/l/e\n      call assert_report('should not get here')\n    catch /^Vim(write):/\n      let caught = 1\n      throw v:exception\t\" throw error: cannot fake Vim exception\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      Xpath 'b'\n      call assert_equal(1, caught)\n    endtry\n  catch /^Vim(throw):/\t\" catches throw error\n    let caught = caught + 1\n  catch /.*/\n    call assert_report('should not get here')\n  finally\n    Xpath 'c'\n    call assert_equal(2, caught)\n  endtry\n  call assert_equal('abc', g:Xpath)\nendfunc\n\nfunc Test_rethrow_exception_3()\n  XpathINIT\n  try\n    let caught = 0\n    try\n      Xpath 'a'\n      asdf\n    catch /^Vim/\t\t\" catch error exception\n      let caught = 1\n      \" Trigger Vim error exception with value specified after :echoerr\n      let value = substitute(v:exception, '^Vim\\((.*)\\)\\=:', '', \"\")\n      echoerr value\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      Xpath 'b'\n      call assert_equal(1, caught)\n    endtry\n  catch /^Vim(echoerr):/\n    let caught = caught + 1\n    call assert_match(value, v:exception)\n  catch /.*/\n    call assert_report('should not get here')\n  finally\n    Xpath 'c'\n    call assert_equal(2, caught)\n  endtry\n  call assert_equal('abc', g:Xpath)\nendfunc\n\nfunc Test_rethrow_exception_3()\n  XpathINIT\n  try\n    let errcaught = 0\n    try\n      Xpath 'a'\n      let intcaught = 0\n      call interrupt()\n    catch /^Vim:/\t\t\" catch interrupt exception\n      let intcaught = 1\n      \" Trigger Vim error exception with value specified after :echoerr\n      echoerr substitute(v:exception, '^Vim\\((.*)\\)\\=:', '', \"\")\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      Xpath 'b'\n      call assert_equal(1, intcaught)\n    endtry\n  catch /^Vim(echoerr):/\n    let errcaught = 1\n    call assert_match('Interrupt', v:exception)\n  finally\n    Xpath 'c'\n    call assert_equal(1, errcaught)\n  endtry\n  call assert_equal('abc', g:Xpath)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 61:  Catching interrupt exceptions\t\t\t\t    {{{1\n\"\n\"\t    When an interrupt occurs inside a :try/:endtry region, an\n\"\t    interrupt exception is thrown and can be caught.  Its value is\n\"\t    \"Vim:Interrupt\".  If the interrupt occurs after an error or a :throw\n\"\t    but before a matching :catch is reached, all following :catches of\n\"\t    that try block are ignored, but the interrupt exception can be\n\"\t    caught by the next surrounding try conditional.  An interrupt is\n\"\t    ignored when there is a previous interrupt that has not been caught\n\"\t    or causes a :finally clause to be executed.\n\"-------------------------------------------------------------------------------\n\nfunc Test_catch_intr_exception()\n  let test =<< trim [CODE]\n    while 1\n      try\n        try\n          Xpath 'a'\n          call interrupt()\n          call assert_report('should not get here')\n        catch /^Vim:Interrupt$/\n          Xpath 'b'\n        finally\n          Xpath 'c'\n        endtry\n      catch /.*/\n        call assert_report('should not get here')\n      finally\n        Xpath 'd'\n        break\n      endtry\n    endwhile\n\n    while 1\n      try\n        try\n          try\n            Xpath 'e'\n            asdf\n            call assert_report('should not get here')\n          catch /do_not_catch/\n            call assert_report('should not get here')\n          catch /.*/\n            Xpath 'f'\n            call interrupt()\n            call assert_report('should not get here')\n          catch /.*/\n            call assert_report('should not get here')\n          finally\n            Xpath 'g'\n            call interrupt()\n            call assert_report('should not get here')\n          endtry\n        catch /^Vim:Interrupt$/\n          Xpath 'h'\n        finally\n          Xpath 'i'\n        endtry\n      catch /.*/\n        call assert_report('should not get here')\n      finally\n        Xpath 'j'\n        break\n      endtry\n    endwhile\n\n    while 1\n      try\n        try\n          try\n            Xpath 'k'\n            throw \"x\"\n            call assert_report('should not get here')\n          catch /do_not_catch/\n            call assert_report('should not get here')\n          catch /x/\n            Xpath 'l'\n            call interrupt()\n            call assert_report('should not get here')\n          catch /.*/\n            call assert_report('should not get here')\n          endtry\n        catch /^Vim:Interrupt$/\n          Xpath 'm'\n        finally\n          Xpath 'n'\n        endtry\n      catch /.*/\n        call assert_report('should not get here')\n      finally\n        Xpath 'o'\n        break\n      endtry\n    endwhile\n\n    while 1\n      try\n        try\n          Xpath 'p'\n          call interrupt()\n          call assert_report('should not get here')\n        catch /do_not_catch/\n          call interrupt()\n          call assert_report('should not get here')\n        catch /^Vim:Interrupt$/\n          Xpath 'q'\n        finally\n          Xpath 'r'\n        endtry\n      catch /.*/\n        call assert_report('should not get here')\n      finally\n        Xpath 's'\n        break\n      endtry\n    endwhile\n\n    Xpath 't'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcdefghijklmnopqrst', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 62:  Catching error exceptions\t\t\t\t\t    {{{1\n\"\n\"\t    An error inside a :try/:endtry region is converted to an exception\n\"\t    and can be caught.  The error exception has a \"Vim(cmdname):\" prefix\n\"\t    where cmdname is the name of the failing command, or a \"Vim:\" prefix\n\"\t    if no command name is known.  The \"Vim\" prefixes cannot be faked.\n\"-------------------------------------------------------------------------------\n\nfunc Test_catch_err_exception_1()\n  XpathINIT\n  while 1\n    try\n      try\n        let caught = 0\n        unlet novar\n      catch /^Vim(unlet):/\n        Xpath 'a'\n        let caught = 1\n        let v:errmsg = substitute(v:exception, '^Vim(unlet):', '', \"\")\n      finally\n        Xpath 'b'\n        call assert_equal(1, caught)\n        call assert_match('E108: No such variable: \"novar\"', v:errmsg)\n      endtry\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      Xpath 'c'\n      break\n    endtry\n    call assert_report('should not get here')\n  endwhile\n  call assert_equal('abc', g:Xpath)\nendfunc\n\nfunc Test_catch_err_exception_2()\n  XpathINIT\n  while 1\n    try\n      try\n        let caught = 0\n        throw novar\t\t\t\" error in :throw\n      catch /^Vim(throw):/\n        Xpath 'a'\n        let caught = 1\n        let v:errmsg = substitute(v:exception, '^Vim(throw):', '', \"\")\n      finally\n        Xpath 'b'\n        call assert_equal(1, caught)\n        call assert_match('E121: Undefined variable: novar', v:errmsg)\n      endtry\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      Xpath 'c'\n      break\n    endtry\n    call assert_report('should not get here')\n  endwhile\n  call assert_equal('abc', g:Xpath)\nendfunc\n\nfunc Test_catch_err_exception_3()\n  XpathINIT\n  while 1\n    try\n      try\n        let caught = 0\n        throw \"Vim:faked\"\t\t\" error: cannot fake Vim exception\n      catch /^Vim(throw):/\n        Xpath 'a'\n        let caught = 1\n        let v:errmsg = substitute(v:exception, '^Vim(throw):', '', \"\")\n      finally\n        Xpath 'b'\n        call assert_equal(1, caught)\n        call assert_match(\"E608: Cannot :throw exceptions with 'Vim' prefix\",\n              \\ v:errmsg)\n      endtry\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      Xpath 'c'\n      break\n    endtry\n    call assert_report('should not get here')\n  endwhile\n  call assert_equal('abc', g:Xpath)\nendfunc\n\nfunc Test_catch_err_exception_4()\n  XpathINIT\n  func F()\n    while 1\n    \" Missing :endwhile\n  endfunc\n\n  while 1\n    try\n      try\n        let caught = 0\n        call F()\n      catch /^Vim(endfunction):/\n        Xpath 'a'\n        let caught = 1\n        let v:errmsg = substitute(v:exception, '^Vim(endfunction):', '', \"\")\n      finally\n        Xpath 'b'\n        call assert_equal(1, caught)\n        call assert_match(\"E170: Missing :endwhile\", v:errmsg)\n      endtry\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      Xpath 'c'\n      break\n    endtry\n    call assert_report('should not get here')\n  endwhile\n  call assert_equal('abc', g:Xpath)\n  delfunc F\nendfunc\n\nfunc Test_catch_err_exception_5()\n  XpathINIT\n  func F()\n    while 1\n    \" Missing :endwhile\n  endfunc\n\n  while 1\n    try\n      try\n        let caught = 0\n        ExecAsScript F\n      catch /^Vim:/\n        Xpath 'a'\n        let caught = 1\n        let v:errmsg = substitute(v:exception, '^Vim:', '', \"\")\n      finally\n        Xpath 'b'\n        call assert_equal(1, caught)\n        call assert_match(\"E170: Missing :endwhile\", v:errmsg)\n      endtry\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      Xpath 'c'\n      break\n    endtry\n    call assert_report('should not get here')\n  endwhile\n  call assert_equal('abc', g:Xpath)\n  delfunc F\nendfunc\n\nfunc Test_catch_err_exception_6()\n  XpathINIT\n  func G()\n    call G()\n  endfunc\n\n  while 1\n    try\n      let mfd_save = &mfd\n      set mfd=3\n      try\n        let caught = 0\n        call G()\n      catch /^Vim(call):/\n        Xpath 'a'\n        let caught = 1\n        let v:errmsg = substitute(v:exception, '^Vim(call):', '', \"\")\n      finally\n        Xpath 'b'\n        call assert_equal(1, caught)\n        call assert_match(\"E132: Function call depth is higher than 'maxfuncdepth'\", v:errmsg)\n      endtry\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      Xpath 'c'\n      let &mfd = mfd_save\n      break\n    endtry\n    call assert_report('should not get here')\n  endwhile\n  call assert_equal('abc', g:Xpath)\n  delfunc G\nendfunc\n\nfunc Test_catch_err_exception_7()\n  XpathINIT\n  func H()\n    return H()\n  endfunc\n\n  while 1\n    try\n      let mfd_save = &mfd\n      set mfd=3\n      try\n        let caught = 0\n        call H()\n      catch /^Vim(return):/\n        Xpath 'a'\n        let caught = 1\n        let v:errmsg = substitute(v:exception, '^Vim(return):', '', \"\")\n      finally\n        Xpath 'b'\n        call assert_equal(1, caught)\n        call assert_match(\"E132: Function call depth is higher than 'maxfuncdepth'\", v:errmsg)\n      endtry\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      Xpath 'c'\n      let &mfd = mfd_save\n      break\t\t\" discard error for $VIMNOERRTHROW\n    endtry\n    call assert_report('should not get here')\n  endwhile\n\n  call assert_equal('abc', g:Xpath)\n  delfunc H\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 63:  Suppressing error exceptions by :silent!.\t\t\t    {{{1\n\"\n\"\t    A :silent! command inside a :try/:endtry region suppresses the\n\"\t    conversion of errors to an exception and the immediate abortion on\n\"\t    error.  When the commands executed by the :silent! themselves open\n\"\t    a new :try/:endtry region, conversion of errors to exception and\n\"\t    immediate abortion is switched on again - until the next :silent!\n\"\t    etc.  The :silent! has the effect of setting v:errmsg to the error\n\"\t    message text (without displaying it) and continuing with the next\n\"\t    script line.\n\"\n\"\t    When a command triggering autocommands is executed by :silent!\n\"\t    inside a :try/:endtry, the autocommand execution is not suppressed\n\"\t    on error.\n\"\n\"\t    This test reuses the function MSG() from the previous test.\n\"-------------------------------------------------------------------------------\n\nfunc Test_silent_exception()\n  XpathINIT\n  XloopINIT\n  let g:taken = \"\"\n\n  func S(n) abort\n    XloopNEXT\n    let g:taken = g:taken . \"E\" . a:n\n    let v:errmsg = \"\"\n    exec \"asdf\" . a:n\n\n    \" Check that \":silent!\" continues:\n    Xloop 'a'\n\n    \" Check that \":silent!\" sets \"v:errmsg\":\n    call assert_match(\"E492: Not an editor command\", v:errmsg)\n  endfunc\n\n  func Foo()\n    while 1\n      try\n        try\n          let caught = 0\n          \" This is not silent:\n          call S(3)\n        catch /^Vim:/\n          Xpath 'b'\n          let caught = 1\n          let errmsg3 = substitute(v:exception, '^Vim:', '', \"\")\n          silent! call S(4)\n        finally\n          call assert_equal(1, caught)\n          Xpath 'c'\n          call assert_match(\"E492: Not an editor command\", errmsg3)\n          silent! call S(5)\n          \" Break out of try conditionals that cover \":silent!\".  This also\n          \" discards the aborting error when $VIMNOERRTHROW is non-zero.\n          break\n        endtry\n      catch /.*/\n        call assert_report('should not get here')\n      endtry\n    endwhile\n    \" This is a double \":silent!\" (see caller).\n    silent! call S(6)\n  endfunc\n\n  func Bar()\n    try\n      silent! call S(2)\n      silent! execute \"call Foo() | call S(7)\"\n      silent! call S(8)\n    endtry\t\" normal end of try cond that covers \":silent!\"\n    \" This has a \":silent!\" from the caller:\n    call S(9)\n  endfunc\n\n  silent! call S(1)\n  silent! call Bar()\n  silent! call S(10)\n\n  call assert_equal(\"E1E2E3E4E5E6E7E8E9E10\", g:taken)\n\n  augroup TMP\n    au!\n    autocmd BufWritePost * Xpath 'd'\n  augroup END\n\n  Xpath 'e'\n  silent! write /i/m/p/o/s/s/i/b/l/e\n  Xpath 'f'\n\n  call assert_equal('a2a3ba5ca6a7a8a9a10a11edf', g:Xpath)\n\n  augroup TMP\n    au!\n  augroup END\n  augroup! TMP\n  delfunction S\n  delfunction Foo\n  delfunction Bar\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 64:  Error exceptions after error, interrupt or :throw\t\t    {{{1\n\"\n\"\t    When an error occurs after an interrupt or a :throw but before\n\"\t    a matching :catch is reached, all following :catches of that try\n\"\t    block are ignored, but the error exception can be caught by the next\n\"\t    surrounding try conditional.  Any previous error exception is\n\"\t    discarded.  An error is ignored when there is a previous error that\n\"\t    has not been caught.\n\"-------------------------------------------------------------------------------\n\nfunc Test_exception_after_error_1()\n  XpathINIT\n  while 1\n    try\n      try\n        Xpath 'a'\n        let caught = 0\n        while 1\n          if 1\n          \" Missing :endif\n        endwhile\t\" throw error exception\n      catch /^Vim(/\n        Xpath 'b'\n        let caught = 1\n      finally\n        Xpath 'c'\n        call assert_equal(1, caught)\n      endtry\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      Xpath 'd'\n      break\n    endtry\n    call assert_report('should not get here')\n  endwhile\n  call assert_equal('abcd', g:Xpath)\nendfunc\n\nfunc Test_exception_after_error_2()\n  XpathINIT\n  while 1\n    try\n      try\n        Xpath 'a'\n        let caught = 0\n        try\n          if 1\n          \" Missing :endif\n        catch /.*/\t\" throw error exception\n          call assert_report('should not get here')\n        catch /.*/\n          call assert_report('should not get here')\n        endtry\n      catch /^Vim(/\n        Xpath 'b'\n        let caught = 1\n      finally\n        Xpath 'c'\n        call assert_equal(1, caught)\n      endtry\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      Xpath 'd'\n      break\n    endtry\n    call assert_report('should not get here')\n  endwhile\n  call assert_equal('abcd', g:Xpath)\nendfunc\n\nfunc Test_exception_after_error_3()\n  XpathINIT\n  while 1\n    try\n      try\n        let caught = 0\n        try\n          Xpath 'a'\n          call interrupt()\n        catch /do_not_catch/\n          call assert_report('should not get here')\n          if 1\n          \" Missing :endif\n        catch /.*/\t\" throw error exception\n          call assert_report('should not get here')\n        catch /.*/\n          call assert_report('should not get here')\n        endtry\n      catch /^Vim(/\n        Xpath 'b'\n        let caught = 1\n      finally\n        Xpath 'c'\n        call assert_equal(1, caught)\n      endtry\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      Xpath 'd'\n      break\n    endtry\n    call assert_report('should not get here')\n  endwhile\n  call assert_equal('abcd', g:Xpath)\nendfunc\n\nfunc Test_exception_after_error_4()\n  XpathINIT\n  while 1\n    try\n      try\n        let caught = 0\n        try\n          Xpath 'a'\n          throw \"x\"\n        catch /do_not_catch/\n          call assert_report('should not get here')\n          if 1\n          \" Missing :endif\n        catch /x/\t\" throw error exception\n          call assert_report('should not get here')\n        catch /.*/\n          call assert_report('should not get here')\n        endtry\n      catch /^Vim(/\n        Xpath 'b'\n        let caught = 1\n      finally\n        Xpath 'c'\n        call assert_equal(1, caught)\n      endtry\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      Xpath 'd'\n      break\n    endtry\n    call assert_report('should not get here')\n  endwhile\n  call assert_equal('abcd', g:Xpath)\nendfunc\n\nfunc Test_exception_after_error_5()\n  XpathINIT\n  while 1\n    try\n      try\n        let caught = 0\n        Xpath 'a'\n        endif\t\t\" :endif without :if; throw error exception\n        if 1\n        \" Missing :endif\n      catch /do_not_catch/ \" ignore new error\n        call assert_report('should not get here')\n      catch /^Vim(endif):/\n        Xpath 'b'\n        let caught = 1\n      catch /^Vim(/\n        call assert_report('should not get here')\n      finally\n        Xpath 'c'\n        call assert_equal(1, caught)\n      endtry\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      Xpath 'd'\n      break\n    endtry\n    call assert_report('should not get here')\n  endwhile\n  call assert_equal('abcd', g:Xpath)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 65:  Errors in the /pattern/ argument of a :catch\t\t    {{{1\n\"\n\"\t    On an error in the /pattern/ argument of a :catch, the :catch does\n\"\t    not match.  Any following :catches of the same :try/:endtry don't\n\"\t    match either.  Finally clauses are executed.\n\"-------------------------------------------------------------------------------\n\nfunc Test_catch_pattern_error()\n  CheckEnglish\n  XpathINIT\n\n  try\n    try\n      Xpath 'a'\n      throw \"oops\"\n    catch /^oops$/\n      Xpath 'b'\n    catch /\\)/\t\t\" not checked; exception has already been caught\n      call assert_report('should not get here')\n    endtry\n    Xpath 'c'\n  catch /.*/\n    call assert_report('should not get here')\n  endtry\n  call assert_equal('abc', g:Xpath)\n\n  XpathINIT\n  func F()\n    try\n      try\n        try\n          Xpath 'a'\n          throw \"ab\"\n        catch /abc/\t\" does not catch\n          call assert_report('should not get here')\n        catch /\\)/\t\" error; discards exception\n          call assert_report('should not get here')\n        catch /.*/\t\" not checked\n          call assert_report('should not get here')\n        finally\n          Xpath 'b'\n        endtry\n        call assert_report('should not get here')\n      catch /^ab$/\t\" checked, but original exception is discarded\n        call assert_report('should not get here')\n      catch /^Vim(catch):/\n        Xpath 'c'\n        call assert_match('Vim(catch):E475: Invalid argument:', v:exception)\n      finally\n        Xpath 'd'\n      endtry\n      Xpath 'e'\n    catch /.*/\n      call assert_report('should not get here')\n    endtry\n    Xpath 'f'\n  endfunc\n\n  call F()\n  call assert_equal('abcdef', g:Xpath)\n\n  delfunc F\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 66:  Stop range :call on error, interrupt, or :throw\t\t    {{{1\n\"\n\"\t    When a function which is multiply called for a range since it\n\"\t    doesn't handle the range itself has an error in a command\n\"\t    dynamically enclosed by :try/:endtry or gets an interrupt or\n\"\t    executes a :throw, no more calls for the remaining lines in the\n\"\t    range are made.  On an error in a command not dynamically enclosed\n\"\t    by :try/:endtry, the function is executed again for the remaining\n\"\t    lines in the range.\n\"-------------------------------------------------------------------------------\n\nfunc Test_stop_range_on_error()\n  let test =<< trim [CODE]\n    let file = tempname()\n    exec \"edit\" file\n    call setline(1, ['line 1', 'line 2', 'line 3'])\n    let taken = \"\"\n    let expected = \"G1EF1E(1)F1E(2)F1E(3)G2EF2E(1)G3IF3I(1)G4TF4T(1)G5AF5A(1)\"\n\n    func F(reason, n) abort\n      let g:taken = g:taken .. \"F\" .. a:n ..\n                          \\ substitute(a:reason, '\\(\\l\\).*', '\\u\\1', \"\") ..\n                          \\ \"(\" .. line(\".\") .. \")\"\n\n      if a:reason == \"error\"\n        asdf\n      elseif a:reason == \"interrupt\"\n        call interrupt()\n      elseif a:reason == \"throw\"\n        throw \"xyz\"\n      elseif a:reason == \"aborting error\"\n        XloopNEXT\n        call assert_equal(g:taken, g:expected)\n        try\n          bwipeout!\n          call delete(g:file)\n          asdf\n        endtry\n      endif\n    endfunc\n\n    func G(reason, n)\n      let g:taken = g:taken .. \"G\" .. a:n ..\n                              \\ substitute(a:reason, '\\(\\l\\).*', '\\u\\1', \"\")\n      1,3call F(a:reason, a:n)\n    endfunc\n\n    Xpath 'a'\n    call G(\"error\", 1)\n    try\n      Xpath 'b'\n      try\n        call G(\"error\", 2)\n        call assert_report('should not get here')\n      finally\n        Xpath 'c'\n        try\n          call G(\"interrupt\", 3)\n          call assert_report('should not get here')\n        finally\n          Xpath 'd'\n          try\n            call G(\"throw\", 4)\n            call assert_report('should not get here')\n          endtry\n        endtry\n      endtry\n    catch /xyz/\n      Xpath 'e'\n    catch /.*/\n      call assert_report('should not get here')\n    endtry\n    Xpath 'f'\n    call G(\"aborting error\", 5)\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcdef', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 67:  :throw across :call command\t\t\t\t\t    {{{1\n\"\n\"\t    On a call command, an exception might be thrown when evaluating the\n\"\t    function name, during evaluation of the arguments, or when the\n\"\t    function is being executed.  The exception can be caught by the\n\"\t    caller.\n\"-------------------------------------------------------------------------------\n\nfunc THROW(x, n)\n  if a:n == 1\n    Xpath 'A'\n  elseif a:n == 2\n    Xpath 'B'\n  elseif a:n == 3\n    Xpath 'C'\n  endif\n  throw a:x\nendfunc\n\nfunc NAME(x, n)\n  if a:n == 1\n    call assert_report('should not get here')\n  elseif a:n == 2\n    Xpath 'D'\n  elseif a:n == 3\n    Xpath 'E'\n  elseif a:n == 4\n    Xpath 'F'\n  endif\n  return a:x\nendfunc\n\nfunc ARG(x, n)\n  if a:n == 1\n    call assert_report('should not get here')\n  elseif a:n == 2\n    call assert_report('should not get here')\n  elseif a:n == 3\n    Xpath 'G'\n  elseif a:n == 4\n    Xpath 'I'\n  endif\n  return a:x\nendfunc\n\nfunc Test_throw_across_call_cmd()\n  XpathINIT\n\n  func F(x, n)\n    if a:n == 2\n      call assert_report('should not get here')\n    elseif a:n == 4\n      Xpath 'a'\n    endif\n  endfunc\n\n  while 1\n    try\n      let v:errmsg = \"\"\n\n      while 1\n        try\n          Xpath 'b'\n          call {NAME(THROW(\"name\", 1), 1)}(ARG(4711, 1), 1)\n          call assert_report('should not get here')\n        catch /^name$/\n          Xpath 'c'\n        catch /.*/\n          call assert_report('should not get here')\n        finally\n          call assert_equal(\"\", v:errmsg)\n          let v:errmsg = \"\"\n          break\n        endtry\n      endwhile\n\n      while 1\n        try\n          Xpath 'd'\n          call {NAME(\"F\", 2)}(ARG(THROW(\"arg\", 2), 2), 2)\n          call assert_report('should not get here')\n        catch /^arg$/\n          Xpath 'e'\n        catch /.*/\n          call assert_report('should not get here')\n        finally\n          call assert_equal(\"\", v:errmsg)\n          let v:errmsg = \"\"\n          break\n        endtry\n      endwhile\n\n      while 1\n        try\n          Xpath 'f'\n          call {NAME(\"THROW\", 3)}(ARG(\"call\", 3), 3)\n          call assert_report('should not get here')\n        catch /^call$/\n          Xpath 'g'\n        catch /^0$/\t    \" default return value\n          call assert_report('should not get here')\n        catch /.*/\n          call assert_report('should not get here')\n        finally\n          call assert_equal(\"\", v:errmsg)\n          let v:errmsg = \"\"\n          break\n        endtry\n      endwhile\n\n      while 1\n        try\n          Xpath 'h'\n          call {NAME(\"F\", 4)}(ARG(4711, 4), 4)\n          Xpath 'i'\n        catch /.*/\n          call assert_report('should not get here')\n        finally\n          call assert_equal(\"\", v:errmsg)\n          let v:errmsg = \"\"\n          break\n        endtry\n      endwhile\n\n    catch /^0$/\t    \" default return value\n      call assert_report('should not get here')\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      call assert_equal(\"\", v:errmsg)\n      let v:errmsg = \"\"\n      break\n    endtry\n  endwhile\n\n  call assert_equal('bAcdDBefEGCghFIai', g:Xpath)\n  delfunction F\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 68:  :throw across function calls in expressions\t\t\t    {{{1\n\"\n\"\t    On a function call within an expression, an exception might be\n\"\t    thrown when evaluating the function name, during evaluation of the\n\"\t    arguments, or when the function is being executed.  The exception\n\"\t    can be caught by the caller.\n\"\n\"\t    This test reuses the functions THROW(), NAME(), and ARG() from the\n\"\t    previous test.\n\"-------------------------------------------------------------------------------\n\nfunc Test_throw_across_call_expr()\n  XpathINIT\n\n  func F(x, n)\n    if a:n == 2\n      call assert_report('should not get here')\n    elseif a:n == 4\n      Xpath 'a'\n    endif\n    return a:x\n  endfunction\n\n  while 1\n    try\n      let error = 0\n      let v:errmsg = \"\"\n\n      while 1\n        try\n          Xpath 'b'\n          let var1 = {NAME(THROW(\"name\", 1), 1)}(ARG(4711, 1), 1)\n          call assert_report('should not get here')\n        catch /^name$/\n          Xpath 'c'\n        catch /.*/\n          call assert_report('should not get here')\n        finally\n          call assert_equal(\"\", v:errmsg)\n          let v:errmsg = \"\"\n          break\n        endtry\n      endwhile\n      call assert_true(!exists('var1'))\n\n      while 1\n        try\n          Xpath 'd'\n          let var2 = {NAME(\"F\", 2)}(ARG(THROW(\"arg\", 2), 2), 2)\n          call assert_report('should not get here')\n        catch /^arg$/\n          Xpath 'e'\n        catch /.*/\n          call assert_report('should not get here')\n        finally\n          call assert_equal(\"\", v:errmsg)\n          let v:errmsg = \"\"\n          break\n        endtry\n      endwhile\n      call assert_true(!exists('var2'))\n\n      while 1\n        try\n          Xpath 'f'\n          let var3 = {NAME(\"THROW\", 3)}(ARG(\"call\", 3), 3)\n          call assert_report('should not get here')\n        catch /^call$/\n          Xpath 'g'\n        catch /^0$/\t    \" default return value\n          call assert_report('should not get here')\n        catch /.*/\n          call assert_report('should not get here')\n        finally\n          call assert_equal(\"\", v:errmsg)\n          let v:errmsg = \"\"\n          break\n        endtry\n      endwhile\n      call assert_true(!exists('var3'))\n\n      while 1\n        try\n          Xpath 'h'\n          let var4 = {NAME(\"F\", 4)}(ARG(4711, 4), 4)\n          Xpath 'i'\n        catch /.*/\n          call assert_report('should not get here')\n        finally\n          call assert_equal(\"\", v:errmsg)\n          let v:errmsg = \"\"\n          break\n        endtry\n      endwhile\n      call assert_true(exists('var4') && var4 == 4711)\n\n    catch /^0$/\t    \" default return value\n      call assert_report('should not get here')\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      call assert_equal(\"\", v:errmsg)\n      break\n    endtry\n  endwhile\n\n  call assert_equal('bAcdDBefEGCghFIai', g:Xpath)\n  delfunc F\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 76:  Errors, interrupts, :throw during expression evaluation\t    {{{1\n\"\n\"\t    When a function call made during expression evaluation is aborted\n\"\t    due to an error inside a :try/:endtry region or due to an interrupt\n\"\t    or a :throw, the expression evaluation is aborted as well.\tNo\n\"\t    message is displayed for the cancelled expression evaluation.  On an\n\"\t    error not inside :try/:endtry, the expression evaluation continues.\n\"-------------------------------------------------------------------------------\n\nfunc Test_expr_eval_error()\n  let test =<< trim [CODE]\n    let taken = \"\"\n\n    func ERR(n)\n      let g:taken = g:taken .. \"E\" .. a:n\n      asdf\n    endfunc\n\n    func ERRabort(n) abort\n      let g:taken = g:taken .. \"A\" .. a:n\n      asdf\n    endfunc\t\" returns -1; may cause follow-up msg for illegal var/func name\n\n    func WRAP(n, arg)\n      let g:taken = g:taken .. \"W\" .. a:n\n      let g:saved_errmsg = v:errmsg\n      return arg\n    endfunc\n\n    func INT(n)\n      let g:taken = g:taken .. \"I\" .. a:n\n      call interrupt()\n    endfunc\n\n    func THR(n)\n      let g:taken = g:taken .. \"T\" .. a:n\n      throw \"should not be caught\"\n    endfunc\n\n    func CONT(n)\n      let g:taken = g:taken .. \"C\" .. a:n\n    endfunc\n\n    func MSG(n)\n      let g:taken = g:taken .. \"M\" .. a:n\n      let errmsg = (a:n >= 37 && a:n <= 44) ? g:saved_errmsg : v:errmsg\n      let msgptn = (a:n >= 10 && a:n <= 27) ? \"^$\" : \"asdf\"\n      call assert_match(msgptn, errmsg)\n      let v:errmsg = \"\"\n      let g:saved_errmsg = \"\"\n    endfunc\n\n    let v:errmsg = \"\"\n\n    try\n      let t = 1\n      while t <= 9\n        Xloop 'a'\n        try\n          if t == 1\n            let v{ERR(t) + CONT(t)} = 0\n          elseif t == 2\n            let v{ERR(t) + CONT(t)}\n          elseif t == 3\n            let var = exists('v{ERR(t) + CONT(t)}')\n          elseif t == 4\n            unlet v{ERR(t) + CONT(t)}\n          elseif t == 5\n            function F{ERR(t) + CONT(t)}()\n            endfunction\n          elseif t == 6\n            function F{ERR(t) + CONT(t)}\n          elseif t == 7\n            let var = exists('*F{ERR(t) + CONT(t)}')\n          elseif t == 8\n            delfunction F{ERR(t) + CONT(t)}\n          elseif t == 9\n            let var = ERR(t) + CONT(t)\n          endif\n        catch /asdf/\n          \" v:errmsg is not set when the error message is converted to an\n          \" exception.  Set it to the original error message.\n          let v:errmsg = substitute(v:exception, '^Vim:', '', \"\")\n        catch /^Vim\\((\\a\\+)\\)\\=:/\n          \" An error exception has been thrown after the original error.\n          let v:errmsg = \"\"\n        finally\n          call MSG(t)\n          let t = t + 1\n          XloopNEXT\n          continue\t\" discard an aborting error\n        endtry\n      endwhile\n    catch /.*/\n      call assert_report('should not get here')\n    endtry\n\n    try\n      let t = 10\n      while t <= 18\n        Xloop 'b'\n        try\n          if t == 10\n            let v{INT(t) + CONT(t)} = 0\n          elseif t == 11\n            let v{INT(t) + CONT(t)}\n          elseif t == 12\n            let var = exists('v{INT(t) + CONT(t)}')\n          elseif t == 13\n            unlet v{INT(t) + CONT(t)}\n          elseif t == 14\n            function F{INT(t) + CONT(t)}()\n            endfunction\n          elseif t == 15\n            function F{INT(t) + CONT(t)}\n          elseif t == 16\n            let var = exists('*F{INT(t) + CONT(t)}')\n          elseif t == 17\n            delfunction F{INT(t) + CONT(t)}\n          elseif t == 18\n            let var = INT(t) + CONT(t)\n          endif\n        catch /^Vim\\((\\a\\+)\\)\\=:\\(Interrupt\\)\\@!/\n          \" An error exception has been triggered after the interrupt.\n          let v:errmsg = substitute(v:exception, '^Vim\\((\\a\\+)\\)\\=:', '', \"\")\n        finally\n          call MSG(t)\n          let t = t + 1\n          XloopNEXT\n          continue\t\" discard interrupt\n        endtry\n      endwhile\n    catch /.*/\n      call assert_report('should not get here')\n    endtry\n\n    try\n      let t = 19\n      while t <= 27\n        Xloop 'c'\n        try\n          if t == 19\n            let v{THR(t) + CONT(t)} = 0\n          elseif t == 20\n            let v{THR(t) + CONT(t)}\n          elseif t == 21\n            let var = exists('v{THR(t) + CONT(t)}')\n          elseif t == 22\n            unlet v{THR(t) + CONT(t)}\n          elseif t == 23\n            function F{THR(t) + CONT(t)}()\n            endfunction\n          elseif t == 24\n            function F{THR(t) + CONT(t)}\n          elseif t == 25\n            let var = exists('*F{THR(t) + CONT(t)}')\n          elseif t == 26\n            delfunction F{THR(t) + CONT(t)}\n          elseif t == 27\n            let var = THR(t) + CONT(t)\n          endif\n        catch /^Vim\\((\\a\\+)\\)\\=:/\n          \" An error exception has been triggered after the :throw.\n          let v:errmsg = substitute(v:exception, '^Vim\\((\\a\\+)\\)\\=:', '', \"\")\n        finally\n          call MSG(t)\n          let t = t + 1\n          XloopNEXT\n          continue\t\" discard exception\n        endtry\n      endwhile\n    catch /.*/\n      call assert_report('should not get here')\n    endtry\n\n    let v{ERR(28) + CONT(28)} = 0\n    call MSG(28)\n    let v{ERR(29) + CONT(29)}\n    call MSG(29)\n    let var = exists('v{ERR(30) + CONT(30)}')\n    call MSG(30)\n    unlet v{ERR(31) + CONT(31)}\n    call MSG(31)\n    function F{ERR(32) + CONT(32)}()\n    endfunction\n    call MSG(32)\n    function F{ERR(33) + CONT(33)}\n    call MSG(33)\n    let var = exists('*F{ERR(34) + CONT(34)}')\n    call MSG(34)\n    delfunction F{ERR(35) + CONT(35)}\n    call MSG(35)\n    let var = ERR(36) + CONT(36)\n    call MSG(36)\n\n    let saved_errmsg = \"\"\n\n    let v{WRAP(37, ERRabort(37)) + CONT(37)} = 0\n    call MSG(37)\n    let v{WRAP(38, ERRabort(38)) + CONT(38)}\n    call MSG(38)\n    let var = exists('v{WRAP(39, ERRabort(39)) + CONT(39)}')\n    call MSG(39)\n    unlet v{WRAP(40, ERRabort(40)) + CONT(40)}\n    call MSG(40)\n    function F{WRAP(41, ERRabort(41)) + CONT(41)}()\n    endfunction\n    call MSG(41)\n    function F{WRAP(42, ERRabort(42)) + CONT(42)}\n    call MSG(42)\n    let var = exists('*F{WRAP(43, ERRabort(43)) + CONT(43)}')\n    call MSG(43)\n    delfunction F{WRAP(44, ERRabort(44)) + CONT(44)}\n    call MSG(44)\n    let var = ERRabort(45) + CONT(45)\n    call MSG(45)\n    Xpath 'd'\n\n    let expected = \"\"\n          \\ .. \"E1M1E2M2E3M3E4M4E5M5E6M6E7M7E8M8E9M9\"\n          \\ .. \"I10M10I11M11I12M12I13M13I14M14I15M15I16M16I17M17I18M18\"\n          \\ .. \"T19M19T20M20T21M21T22M22T23M23T24M24T25M25T26M26T27M27\"\n          \\ .. \"E28C28M28E29C29M29E30C30M30E31C31M31E32C32M32E33C33M33\"\n          \\ .. \"E34C34M34E35C35M35E36C36M36\"\n          \\ .. \"A37W37C37M37A38W38C38M38A39W39C39M39A40W40C40M40A41W41C41M41\"\n          \\ .. \"A42W42C42M42A43W43C43M43A44W44C44M44A45C45M45\"\n    call assert_equal(expected, taken)\n  [CODE]\n  let verify =<< trim [CODE]\n    let expected = \"a1a2a3a4a5a6a7a8a9\"\n                      \\ .. \"b10b11b12b13b14b15b16b17b18\"\n                      \\ .. \"c19c20c21c22c23c24c25c26c27d\"\n    call assert_equal(expected, g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 77:  Errors, interrupts, :throw in name{brace-expression}\t    {{{1\n\"\n\"\t    When a function call made during evaluation of an expression in\n\"\t    braces as part of a function name after \":function\" is aborted due\n\"\t    to an error inside a :try/:endtry region or due to an interrupt or\n\"\t    a :throw, the expression evaluation is aborted as well, and the\n\"\t    function definition is ignored, skipping all commands to the\n\"\t    \":endfunction\".  On an error not inside :try/:endtry, the expression\n\"\t    evaluation continues and the function gets defined, and can be\n\"\t    called and deleted.\n\"-------------------------------------------------------------------------------\nfunc Test_brace_expr_error()\n  let test =<< trim [CODE]\n    func ERR() abort\n      Xloop 'a'\n      asdf\n    endfunc\t\t\t\t\t\" returns -1\n\n    func OK()\n      Xloop 'b'\n      let v:errmsg = \"\"\n      return 0\n    endfunc\n\n    let v:errmsg = \"\"\n\n    Xpath 'c'\n    func F{1 + ERR() + OK()}(arg)\n      \" F0 should be defined.\n      if exists(\"a:arg\") && a:arg == \"calling\"\n        Xpath 'd'\n      else\n        call assert_report('should not get here')\n      endif\n    endfunction\n    call assert_equal(\"\", v:errmsg)\n    XloopNEXT\n\n    Xpath 'e'\n    call F{1 + ERR() + OK()}(\"calling\")\n    call assert_equal(\"\", v:errmsg)\n    XloopNEXT\n\n    Xpath 'f'\n    delfunction F{1 + ERR() + OK()}\n    call assert_equal(\"\", v:errmsg)\n    XloopNEXT\n\n    try\n      while 1\n        try\n          Xpath 'g'\n          func G{1 + ERR() + OK()}(arg)\n            \" G0 should not be defined, and the function body should be\n            \" skipped.\n            call assert_report('should not get here')\n            \" Use an unmatched \":finally\" to check whether the body is\n            \" skipped when an error occurs in ERR().  This works whether or\n            \" not the exception is converted to an exception.\n            finally\n              call assert_report('should not get here')\n            endtry\n          try\n            call assert_report('should not get here')\n          endfunction\n\n          call assert_report('should not get here')\n        catch /asdf/\n          \" Jumped to when the function is not defined and the body is\n          \" skipped.\n          Xpath 'h'\n        catch /.*/\n          call assert_report('should not get here')\n        finally\n          Xpath 'i'\n          break\n        endtry\t\t\t\" jumped to when the body is not skipped\n      endwhile\n    catch /.*/\n      call assert_report('should not get here')\n    endtry\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('ca1b1ea2b2dfa3b3ga4hi', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 78:  Messages on parsing errors in expression evaluation\t\t    {{{1\n\"\n\"\t    When an expression evaluation detects a parsing error, an error\n\"\t    message is given and converted to an exception, and the expression\n\"\t    evaluation is aborted.\n\"-------------------------------------------------------------------------------\nfunc Test_expr_eval_error_msg()\n  CheckEnglish\n\n  let test =<< trim [CODE]\n    let taken = \"\"\n\n    func F(n)\n      let g:taken = g:taken . \"F\" . a:n\n    endfunc\n\n    func MSG(n, enr, emsg)\n      let g:taken = g:taken . \"M\" . a:n\n      call assert_match('^' .. a:enr .. ':', v:errmsg)\n      call assert_match(a:emsg, v:errmsg)\n    endfunc\n\n    func CONT(n)\n      let g:taken = g:taken . \"C\" . a:n\n    endfunc\n\n    let v:errmsg = \"\"\n    try\n      let t = 1\n      while t <= 14\n        let g:taken = g:taken . \"T\" . t\n        let v:errmsg = \"\"\n        try\n          if t == 1\n            let v{novar + CONT(t)} = 0\n          elseif t == 2\n            let v{novar + CONT(t)}\n          elseif t == 3\n            let var = exists('v{novar + CONT(t)}')\n          elseif t == 4\n            unlet v{novar + CONT(t)}\n          elseif t == 5\n            function F{novar + CONT(t)}()\n            endfunction\n          elseif t == 6\n            function F{novar + CONT(t)}\n          elseif t == 7\n            let var = exists('*F{novar + CONT(t)}')\n          elseif t == 8\n            delfunction F{novar + CONT(t)}\n          elseif t == 9\n            echo novar + CONT(t)\n          elseif t == 10\n            echo v{novar + CONT(t)}\n          elseif t == 11\n            echo F{novar + CONT(t)}\n          elseif t == 12\n            let var = novar + CONT(t)\n          elseif t == 13\n            let var = v{novar + CONT(t)}\n          elseif t == 14\n            let var = F{novar + CONT(t)}()\n          endif\n        catch /^Vim\\((\\a\\+)\\)\\=:/\n          Xloop 'a'\n          \" v:errmsg is not set when the error message is converted to an\n          \" exception.  Set it to the original error message.\n          let v:errmsg = substitute(v:exception, '^Vim\\((\\a\\+)\\)\\=:', '', \"\")\n        finally\n          Xloop 'b'\n          if t <= 8 && t != 3 && t != 7\n            call MSG(t, 'E475', 'Invalid argument\\>')\n          else\n            call MSG(t, 'E121', \"Undefined variable\")\n          endif\n          let t = t + 1\n          XloopNEXT\n          continue\t\" discard an aborting error\n        endtry\n      endwhile\n    catch /.*/\n      call assert_report('should not get here')\n    endtry\n\n    func T(n, expr, enr, emsg)\n      try\n        let g:taken = g:taken . \"T\" . a:n\n        let v:errmsg = \"\"\n        try\n          execute \"let var = \" . a:expr\n        catch /^Vim\\((\\a\\+)\\)\\=:/\n          Xloop 'c'\n          \" v:errmsg is not set when the error message is converted to an\n          \" exception.  Set it to the original error message.\n          let v:errmsg = substitute(v:exception, '^Vim\\((\\a\\+)\\)\\=:', '', \"\")\n        finally\n          Xloop 'd'\n          call MSG(a:n, a:enr, a:emsg)\n          XloopNEXT\n          \" Discard an aborting error:\n          return\n        endtry\n      catch /.*/\n        call assert_report('should not get here')\n      endtry\n    endfunc\n\n    call T(15, 'Nofunc() + CONT(15)',\t'E117',\t\"Unknown function\")\n    call T(16, 'F(1 2 + CONT(16))',\t'E116',\t\"Invalid arguments\")\n    call T(17, 'F(1, 2) + CONT(17)',\t'E118',\t\"Too many arguments\")\n    call T(18, 'F() + CONT(18)',\t'E119',\t\"Not enough arguments\")\n    call T(19, '{(1} + CONT(19)',\t'E110',\t\"Missing ')'\")\n    call T(20, '(\"abc\"[1) + CONT(20)',\t'E111',\t\"Missing ']'\")\n    call T(21, '(1 +) + CONT(21)',\t'E15',\t\"Invalid expression\")\n    call T(22, '1 2 + CONT(22)',\t'E488',\t\"Trailing characters: 2 +\")\n    call T(23, '(1 ? 2) + CONT(23)',\t'E109',\t\"Missing ':' after '?'\")\n    call T(24, '(\"abc) + CONT(24)',\t'E114',\t\"Missing double quote\")\n    call T(25, \"('abc) + CONT(25)\",\t'E115',\t\"Missing single quote\")\n    call T(26, '& + CONT(26)',\t\t'E112', \"Option name missing\")\n    call T(27, '&asdf + CONT(27)',\t'E113', \"Unknown option\")\n\n    let expected = \"\"\n      \\ .. \"T1M1T2M2T3M3T4M4T5M5T6M6T7M7T8M8T9M9T10M10T11M11T12M12T13M13T14M14\"\n      \\ .. \"T15M15T16M16T17M17T18M18T19M19T20M20T21M21T22M22T23M23T24M24T25M25\"\n      \\ .. \"T26M26T27M27\"\n\n    call assert_equal(expected, taken)\n  [CODE]\n  let verify =<< trim [CODE]\n    let expected = \"a1b1a2b2a3b3a4b4a5b5a6b6a7b7a8b8a9b9a10b10a11b11a12b12\"\n                  \\ .. \"a13b13a14b14c15d15c16d16c17d17c18d18c19d19c20d20\"\n                  \\ .. \"c21d21c22d22c23d23c24d24c25d25c26d26c27d27\"\n    call assert_equal(expected, g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 79:  Throwing one of several errors for the same command\t\t    {{{1\n\"\n\"\t    When several errors appear in a row (for instance during expression\n\"\t    evaluation), the first as the most specific one is used when\n\"\t    throwing an error exception.  If, however, a syntax error is\n\"\t    detected afterwards, this one is used for the error exception.\n\"\t    On a syntax error, the next command is not executed, on a normal\n\"\t    error, however, it is (relevant only in a function without the\n\"\t    \"abort\" flag).  v:errmsg is not set.\n\"\n\"\t    If throwing error exceptions is configured off, v:errmsg is always\n\"\t    set to the latest error message, that is, to the more general\n\"\t    message or the syntax error, respectively.\n\"-------------------------------------------------------------------------------\nfunc Test_throw_multi_error()\n  CheckEnglish\n\n  let test =<< trim [CODE]\n    func NEXT(cmd)\n      exec a:cmd . \" | Xloop 'a'\"\n    endfun\n\n    call NEXT('echo novar')\t\t\t\" (checks nextcmd)\n    XloopNEXT\n    call NEXT('let novar #')\t\t\t\" (skips nextcmd)\n    XloopNEXT\n    call NEXT('unlet novar #')\t\t\t\" (skips nextcmd)\n    XloopNEXT\n    call NEXT('let {novar}')\t\t\t\" (skips nextcmd)\n    XloopNEXT\n    call NEXT('unlet{ novar}')\t\t\t\" (skips nextcmd)\n\n    call assert_equal('a1', g:Xpath)\n    XpathINIT\n    XloopINIT\n\n    func EXEC(cmd)\n      exec a:cmd\n    endfunc\n\n    try\n      while 1\t\t\t\t\" dummy loop\n        try\n          let v:errmsg = \"\"\n          call EXEC('echo novar')\t\" normal error\n        catch /^Vim\\((\\a\\+)\\)\\=:/\n          Xpath 'b'\n          call assert_match('E121: Undefined variable: novar', v:exception)\n        finally\n          Xpath 'c'\n          call assert_equal(\"\", v:errmsg)\n          break\n        endtry\n      endwhile\n\n      Xpath 'd'\n      let cmd = \"let\"\n      while cmd != \"\"\n        try\n          let v:errmsg = \"\"\n          call EXEC(cmd . ' novar #')\t\t\" normal plus syntax error\n        catch /^Vim\\((\\a\\+)\\)\\=:/\n          Xloop 'e'\n          if cmd =~ 'unlet'\n            \" TODO: should get error for 'novar'\n            call assert_match('E488: Trailing characters', v:exception)\n          else\n            call assert_match('E121: Undefined variable: novar', v:exception)\n          endif\n        finally\n          Xloop 'f'\n          call assert_equal(\"\", v:errmsg)\n          if cmd == \"let\"\n            let cmd = \"unlet\"\n          else\n            let cmd = \"\"\n          endif\n          XloopNEXT\n          continue\n        endtry\n      endwhile\n\n      Xpath 'g'\n      let cmd = \"let\"\n      while cmd != \"\"\n        try\n          let v:errmsg = \"\"\n          call EXEC(cmd . ' {novar}')\t\t\" normal plus syntax error\n        catch /^Vim\\((\\a\\+)\\)\\=:/\n          Xloop 'h'\n          call assert_match('E475: Invalid argument: {novar}', v:exception)\n        finally\n          Xloop 'i'\n          call assert_equal(\"\", v:errmsg)\n          if cmd == \"let\"\n            let cmd = \"unlet\"\n          else\n            let cmd = \"\"\n          endif\n          XloopNEXT\n          continue\n        endtry\n      endwhile\n    catch /.*/\n      call assert_report('should not get here')\n    endtry\n    Xpath 'j'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('bcde1f1e2f2gh3i3h4i4j', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 80:  Syntax error in expression for illegal :elseif\t\t    {{{1\n\"\n\"\t    If there is a syntax error in the expression after an illegal\n\"\t    :elseif, an error message is given (or an error exception thrown)\n\"\t    for the illegal :elseif rather than the expression error.\n\"-------------------------------------------------------------------------------\nfunc Test_if_syntax_error()\n  CheckEnglish\n\n  let test =<< trim [CODE]\n    let v:errmsg = \"\"\n    if 0\n    else\n    elseif 1 ||| 2\n    endif\n    Xpath 'a'\n    call assert_match('E584: :elseif after :else', v:errmsg)\n\n    let v:errmsg = \"\"\n    if 1\n    else\n    elseif 1 ||| 2\n    endif\n    Xpath 'b'\n    call assert_match('E584: :elseif after :else', v:errmsg)\n\n    let v:errmsg = \"\"\n    elseif 1 ||| 2\n    Xpath 'c'\n    call assert_match('E582: :elseif without :if', v:errmsg)\n\n    let v:errmsg = \"\"\n    while 1\n      elseif 1 ||| 2\n    endwhile\n    Xpath 'd'\n    call assert_match('E582: :elseif without :if', v:errmsg)\n\n    while 1\n      try\n        try\n          let v:errmsg = \"\"\n          if 0\n          else\n          elseif 1 ||| 2\n          endif\n        catch /^Vim\\((\\a\\+)\\)\\=:/\n          Xpath 'e'\n          call assert_match('E584: :elseif after :else', v:exception)\n        finally\n          Xpath 'f'\n          call assert_equal(\"\", v:errmsg)\n        endtry\n      catch /.*/\n      call assert_report('should not get here')\n      finally\n        Xpath 'g'\n        break\n      endtry\n    endwhile\n\n    while 1\n      try\n        try\n          let v:errmsg = \"\"\n          if 1\n          else\n          elseif 1 ||| 2\n          endif\n        catch /^Vim\\((\\a\\+)\\)\\=:/\n          Xpath 'h'\n          call assert_match('E584: :elseif after :else', v:exception)\n        finally\n          Xpath 'i'\n          call assert_equal(\"\", v:errmsg)\n        endtry\n      catch /.*/\n        call assert_report('should not get here')\n      finally\n        Xpath 'j'\n        break\n      endtry\n    endwhile\n\n    while 1\n      try\n        try\n          let v:errmsg = \"\"\n          elseif 1 ||| 2\n        catch /^Vim\\((\\a\\+)\\)\\=:/\n          Xpath 'k'\n          call assert_match('E582: :elseif without :if', v:exception)\n        finally\n          Xpath 'l'\n          call assert_equal(\"\", v:errmsg)\n        endtry\n      catch /.*/\n        call assert_report('should not get here')\n      finally\n        Xpath 'm'\n        break\n      endtry\n    endwhile\n\n    while 1\n      try\n        try\n          let v:errmsg = \"\"\n          while 1\n              elseif 1 ||| 2\n          endwhile\n        catch /^Vim\\((\\a\\+)\\)\\=:/\n          Xpath 'n'\n          call assert_match('E582: :elseif without :if', v:exception)\n        finally\n          Xpath 'o'\n          call assert_equal(\"\", v:errmsg)\n        endtry\n      catch /.*/\n        call assert_report('should not get here')\n      finally\n        Xpath 'p'\n        break\n      endtry\n    endwhile\n    Xpath 'q'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcdefghijklmnopq', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 81:  Discarding exceptions after an error or interrupt\t\t    {{{1\n\"\n\"\t    When an exception is thrown from inside a :try conditional without\n\"\t    :catch and :finally clauses and an error or interrupt occurs before\n\"\t    the :endtry is reached, the exception is discarded.\n\"-------------------------------------------------------------------------------\n\nfunc Test_discard_exception_after_error_1()\n  let test =<< trim [CODE]\n    try\n      Xpath 'a'\n      try\n        Xpath 'b'\n        throw \"arrgh\"\n        call assert_report('should not get here')\n        if 1\n        call assert_report('should not get here')\n        \" error after :throw: missing :endif\n      endtry\n      call assert_report('should not get here')\n    catch /arrgh/\n      call assert_report('should not get here')\n    endtry\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('ab', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\" interrupt the code before the endtry is invoked\nfunc Test_discard_exception_after_error_2()\n  XpathINIT\n  let lines =<< trim [CODE]\n    try\n      Xpath 'a'\n      try\n        Xpath 'b'\n        throw \"arrgh\"\n        call assert_report('should not get here')\n      endtry                      \" interrupt here\n      call assert_report('should not get here')\n    catch /arrgh/\n      call assert_report('should not get here')\n    endtry\n    call assert_report('should not get here')\n  [CODE]\n  call writefile(lines, 'Xscript')\n\n  breakadd file 7 Xscript\n  try\n    let caught_intr = 0\n    debuggreedy\n    call feedkeys(\":source Xscript\\<CR>quit\\<CR>\", \"xt\")\n  catch /^Vim:Interrupt$/\n    call assert_match('Xscript, line 7', v:throwpoint)\n    let caught_intr = 1\n  endtry\n  0debuggreedy\n  call assert_equal(1, caught_intr)\n  call assert_equal('ab', g:Xpath)\n  breakdel *\n  call delete('Xscript')\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 82:  Ignoring :catch clauses after an error or interrupt\t\t    {{{1\n\"\n\"\t    When an exception is thrown and an error or interrupt occurs before\n\"\t    the matching :catch clause is reached, the exception is discarded\n\"\t    and the :catch clause is ignored (also for the error or interrupt\n\"\t    exception being thrown then).\n\"-------------------------------------------------------------------------------\n\nfunc Test_ignore_catch_after_error_1()\n  let test =<< trim [CODE]\n    try\n      try\n        Xpath 'a'\n        throw \"arrgh\"\n        call assert_report('should not get here')\n        if 1\n        call assert_report('should not get here')\n        \" error after :throw: missing :endif\n      catch /.*/\n        call assert_report('should not get here')\n      catch /.*/\n        call assert_report('should not get here')\n      endtry\n      call assert_report('should not get here')\n    catch /arrgh/\n      call assert_report('should not get here')\n    endtry\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('a', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_ignore_catch_after_error_2()\n  let test =<< trim [CODE]\n    func E()\n      try\n        try\n          Xpath 'a'\n          throw \"arrgh\"\n          call assert_report('should not get here')\n          if 1\n          call assert_report('should not get here')\n          \" error after :throw: missing :endif\n        catch /.*/\n          call assert_report('should not get here')\n        catch /.*/\n          call assert_report('should not get here')\n        endtry\n        call assert_report('should not get here')\n      catch /arrgh/\n        call assert_report('should not get here')\n      endtry\n    endfunc\n\n    call E()\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('a', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\" interrupt right before a catch is invoked in a script\nfunc Test_ignore_catch_after_intr_1()\n  XpathINIT\n  let lines =<< trim [CODE]\n    try\n      try\n        Xpath 'a'\n        throw \"arrgh\"\n        call assert_report('should not get here')\n      catch /.*/              \" interrupt here\n        call assert_report('should not get here')\n      catch /.*/\n        call assert_report('should not get here')\n      endtry\n      call assert_report('should not get here')\n    catch /arrgh/\n      call assert_report('should not get here')\n    endtry\n    call assert_report('should not get here')\n  [CODE]\n  call writefile(lines, 'Xscript')\n\n  breakadd file 6 Xscript\n  try\n    let caught_intr = 0\n    debuggreedy\n    call feedkeys(\":source Xscript\\<CR>quit\\<CR>\", \"xt\")\n  catch /^Vim:Interrupt$/\n    call assert_match('Xscript, line 6', v:throwpoint)\n    let caught_intr = 1\n  endtry\n  0debuggreedy\n  call assert_equal(1, caught_intr)\n  call assert_equal('a', g:Xpath)\n  breakdel *\n  call delete('Xscript')\nendfunc\n\n\" interrupt right before a catch is invoked inside a function.\nfunc Test_ignore_catch_after_intr_2()\n  XpathINIT\n  func F()\n    try\n      try\n        Xpath 'a'\n        throw \"arrgh\"\n        call assert_report('should not get here')\n      catch /.*/              \" interrupt here\n        call assert_report('should not get here')\n      catch /.*/\n        call assert_report('should not get here')\n      endtry\n      call assert_report('should not get here')\n    catch /arrgh/\n      call assert_report('should not get here')\n    endtry\n    call assert_report('should not get here')\n  endfunc\n\n  breakadd func 6 F\n  try\n    let caught_intr = 0\n    debuggreedy\n    call feedkeys(\":call F()\\<CR>quit\\<CR>\", \"xt\")\n  catch /^Vim:Interrupt$/\n    call assert_match('\\.F, line 6', v:throwpoint)\n    let caught_intr = 1\n  endtry\n  0debuggreedy\n  call assert_equal(1, caught_intr)\n  call assert_equal('a', g:Xpath)\n  breakdel *\n  delfunc F\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 83:  Executing :finally clauses after an error or interrupt\t    {{{1\n\"\n\"\t    When an exception is thrown and an error or interrupt occurs before\n\"\t    the :finally of the innermost :try is reached, the exception is\n\"\t    discarded and the :finally clause is executed.\n\"-------------------------------------------------------------------------------\n\nfunc Test_finally_after_error()\n  let test =<< trim [CODE]\n    try\n      Xpath 'a'\n      try\n        Xpath 'b'\n        throw \"arrgh\"\n        call assert_report('should not get here')\n        if 1\n        call assert_report('should not get here')\n        \" error after :throw: missing :endif\n      finally\n        Xpath 'c'\n      endtry\n      call assert_report('should not get here')\n    catch /arrgh/\n      call assert_report('should not get here')\n    endtry\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abc', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\" interrupt the code right before the finally is invoked\nfunc Test_finally_after_intr()\n  XpathINIT\n  let lines =<< trim [CODE]\n    try\n      Xpath 'a'\n      try\n        Xpath 'b'\n        throw \"arrgh\"\n        call assert_report('should not get here')\n      finally\t\t\" interrupt here\n        Xpath 'c'\n      endtry\n      call assert_report('should not get here')\n    catch /arrgh/\n      call assert_report('should not get here')\n    endtry\n    call assert_report('should not get here')\n  [CODE]\n  call writefile(lines, 'Xscript')\n\n  breakadd file 7 Xscript\n  try\n    let caught_intr = 0\n    debuggreedy\n    call feedkeys(\":source Xscript\\<CR>quit\\<CR>\", \"xt\")\n  catch /^Vim:Interrupt$/\n    call assert_match('Xscript, line 7', v:throwpoint)\n    let caught_intr = 1\n  endtry\n  0debuggreedy\n  call assert_equal(1, caught_intr)\n  call assert_equal('abc', g:Xpath)\n  breakdel *\n  call delete('Xscript')\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 84:  Exceptions in autocommand sequences.\t\t\t    {{{1\n\"\n\"\t    When an exception occurs in a sequence of autocommands for\n\"\t    a specific event, the rest of the sequence is not executed.  The\n\"\t    command that triggered the autocommand execution aborts, and the\n\"\t    exception is propagated to the caller.\n\"\n\"\t    For the FuncUndefined event under a function call expression or\n\"\t    :call command, the function is not executed, even when it has\n\"\t    been defined by the autocommands before the exception occurred.\n\"-------------------------------------------------------------------------------\n\nfunc Test_autocmd_exception()\n  let test =<< trim [CODE]\n    func INT()\n      call interrupt()\n    endfunc\n\n    aug TMP\n      autocmd!\n\n      autocmd User x1 Xpath 'a'\n      autocmd User x1 throw \"x1\"\n      autocmd User x1 call assert_report('should not get here')\n\n      autocmd User x2 Xpath 'b'\n      autocmd User x2 asdf\n      autocmd User x2 call assert_report('should not get here')\n\n      autocmd User x3 Xpath 'c'\n      autocmd User x3 call INT()\n      autocmd User x3 call assert_report('should not get here')\n\n      autocmd FuncUndefined U1 func U1()\n      autocmd FuncUndefined U1   call assert_report('should not get here')\n      autocmd FuncUndefined U1 endfunc\n      autocmd FuncUndefined U1 Xpath 'd'\n      autocmd FuncUndefined U1 throw \"U1\"\n      autocmd FuncUndefined U1 call assert_report('should not get here')\n\n      autocmd FuncUndefined U2 func U2()\n      autocmd FuncUndefined U2   call assert_report('should not get here')\n      autocmd FuncUndefined U2 endfunc\n      autocmd FuncUndefined U2 Xpath 'e'\n      autocmd FuncUndefined U2 ASDF\n      autocmd FuncUndefined U2 call assert_report('should not get here')\n\n      autocmd FuncUndefined U3 func U3()\n      autocmd FuncUndefined U3   call assert_report('should not get here')\n      autocmd FuncUndefined U3 endfunc\n      autocmd FuncUndefined U3 Xpath 'f'\n      autocmd FuncUndefined U3 call INT()\n      autocmd FuncUndefined U3 call assert_report('should not get here')\n    aug END\n\n    try\n      try\n        Xpath 'g'\n        doautocmd User x1\n      catch /x1/\n        Xpath 'h'\n      endtry\n\n      while 1\n        try\n          Xpath 'i'\n          doautocmd User x2\n        catch /asdf/\n          Xpath 'j'\n        finally\n          Xpath 'k'\n          break\n        endtry\n      endwhile\n\n      while 1\n        try\n          Xpath 'l'\n          doautocmd User x3\n        catch /Vim:Interrupt/\n          Xpath 'm'\n        finally\n          Xpath 'n'\n          \" ... but break loop for caught interrupt exception,\n          \" or discard interrupt and break loop if $VIMNOINTTHROW\n          break\n        endtry\n      endwhile\n\n      if exists(\"*U1\") | delfunction U1 | endif\n      if exists(\"*U2\") | delfunction U2 | endif\n      if exists(\"*U3\") | delfunction U3 | endif\n\n      try\n        Xpath 'o'\n        call U1()\n      catch /U1/\n        Xpath 'p'\n      endtry\n\n      while 1\n        try\n          Xpath 'q'\n          call U2()\n        catch /ASDF/\n          Xpath 'r'\n        finally\n          Xpath 's'\n          \" ... but break loop for caught error exception,\n          \" or discard error and break loop if $VIMNOERRTHROW\n          break\n        endtry\n      endwhile\n\n      while 1\n        try\n          Xpath 't'\n          call U3()\n        catch /Vim:Interrupt/\n          Xpath 'u'\n        finally\n          Xpath 'v'\n          \" ... but break loop for caught interrupt exception,\n          \" or discard interrupt and break loop if $VIMNOINTTHROW\n          break\n        endtry\n      endwhile\n    catch /.*/\n      call assert_report('should not get here')\n    endtry\n    Xpath 'w'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('gahibjklcmnodpqerstfuvw', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 85:  Error exceptions in autocommands for I/O command events\t    {{{1\n\"\n\"\t    When an I/O command is inside :try/:endtry, autocommands to be\n\"\t    executed after it should be skipped on an error (exception) in the\n\"\t    command itself or in autocommands to be executed before the command.\n\"\t    In the latter case, the I/O command should not be executed either.\n\"\t    Example 1: BufWritePre, :write, BufWritePost\n\"\t    Example 2: FileReadPre, :read, FileReadPost.\n\"-------------------------------------------------------------------------------\n\nfunc Test_autocmd_error_io_exception()\n  let test =<< trim [CODE]\n    \" Remove the autocommands for the events specified as arguments in all used\n    \" autogroups.\n    func Delete_autocommands(...)\n      let augfile = tempname()\n      while 1\n        try\n          exec \"redir >\" . augfile\n          aug\n          redir END\n          exec \"edit\" augfile\n          g/^$/d\n          norm G$\n          let wrap = \"w\"\n          while search('\\%(  \\|^\\)\\@<=.\\{-}\\%(  \\)\\@=', wrap) > 0\n            let wrap = \"W\"\n            exec \"norm y/  \\n\"\n            let argno = 1\n            while argno <= a:0\n              exec \"au!\" escape(@\", \" \") a:{argno}\n              let argno = argno + 1\n            endwhile\n          endwhile\n        catch /.*/\n        finally\n          bwipeout!\n          call delete(augfile)\n          break\n        endtry\n      endwhile\n    endfunc\n\n    call Delete_autocommands(\"BufWritePre\", \"BufWritePost\")\n\n    while 1\n      try\n        try\n          let post = 0\n          aug TMP\n            au! BufWritePost * let post = 1\n          aug END\n          write /n/o/n/e/x/i/s/t/e/n/t\n        catch /^Vim(write):/\n          Xpath 'a'\n          call assert_match(\"E212: Can't open file for writing\", v:exception)\n        finally\n          Xpath 'b'\n          call assert_equal(0, post)\n          au! TMP\n          aug! TMP\n        endtry\n      catch /.*/\n        call assert_report('should not get here')\n      finally\n        Xpath 'c'\n        break\n      endtry\n    endwhile\n\n    while 1\n      try\n        try\n          let post = 0\n          aug TMP\n            au! BufWritePre  * asdf\n            au! BufWritePost * let post = 1\n          aug END\n          let tmpfile = tempname()\n          exec \"write\" tmpfile\n        catch /^Vim\\((write)\\)\\=:/\n          Xpath 'd'\n          call assert_match('E492: Not an editor command', v:exception)\n        finally\n          Xpath 'e'\n          if filereadable(tmpfile)\n            call assert_report('should not get here')\n          endif\n          call assert_equal(0, post)\n          au! TMP\n          aug! TMP\n        endtry\n      catch /.*/\n        call assert_report('should not get here')\n      finally\n        Xpath 'f'\n        break\n      endtry\n    endwhile\n\n    call delete(tmpfile)\n\n    call Delete_autocommands(\"BufWritePre\", \"BufWritePost\",\n          \\ \"BufReadPre\", \"BufReadPost\", \"FileReadPre\", \"FileReadPost\")\n\n    while 1\n      try\n        try\n          let post = 0\n          aug TMP\n            au! FileReadPost * let post = 1\n          aug END\n          let caught = 0\n          read /n/o/n/e/x/i/s/t/e/n/t\n        catch /^Vim(read):/\n          Xpath 'g'\n          call assert_match(\"E484: Can't open file\", v:exception)\n        finally\n          Xpath 'h'\n          call assert_equal(0, post)\n          au! TMP\n          aug! TMP\n        endtry\n      catch /.*/\n        call assert_report('should not get here')\n      finally\n        Xpath 'i'\n        break\n      endtry\n    endwhile\n\n    while 1\n      try\n        let infile = tempname()\n        let tmpfile = tempname()\n        call writefile([\"XYZ\"], infile)\n        exec \"edit\" tmpfile\n        try\n          Xpath 'j'\n          try\n            let post = 0\n            aug TMP\n              au! FileReadPre  * asdf\n              au! FileReadPost * let post = 1\n            aug END\n            exec \"0read\" infile\n          catch /^Vim\\((read)\\)\\=:/\n            Xpath 'k'\n            call assert_match('E492: Not an editor command', v:exception)\n          finally\n            Xpath 'l'\n            if getline(\"1\") == \"XYZ\"\n              call assert_report('should not get here')\n            endif\n            call assert_equal(0, post)\n            au! TMP\n            aug! TMP\n          endtry\n        finally\n          Xpath 'm'\n          bwipeout!\n        endtry\n      catch /.*/\n        call assert_report('should not get here')\n      finally\n        Xpath 'n'\n        break\n      endtry\n    endwhile\n\n    call delete(infile)\n    call delete(tmpfile)\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcdefghijklmn', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 87   using (expr) ? funcref : funcref\t\t\t\t    {{{1\n\"\n\"\t    Vim needs to correctly parse the funcref and even when it does\n\"\t    not execute the funcref, it needs to consume the trailing ()\n\"-------------------------------------------------------------------------------\n\nfunc Add2(x1, x2)\n  return a:x1 + a:x2\nendfu\n\nfunc GetStr()\n  return \"abcdefghijklmnopqrstuvwxyp\"\nendfu\n\nfunc Test_funcref_with_condexpr()\n  call assert_equal(5, function('Add2')(2,3))\n\n  call assert_equal(3, 1 ? function('Add2')(1,2) : function('Add2')(2,3))\n  call assert_equal(5, 0 ? function('Add2')(1,2) : function('Add2')(2,3))\n  \" Make sure, GetStr() still works.\n  call assert_equal('abcdefghijk', GetStr()[0:10])\nendfunc\n\n\" Test 90:  Recognizing {} in variable name.\t\t\t    {{{1\n\"-------------------------------------------------------------------------------\n\nfunc Test_curlies()\n    let s:var = 66\n    let ns = 's'\n    call assert_equal(66, {ns}:var)\n\n    let g:a = {}\n    let g:b = 't'\n    let g:a[g:b] = 77\n    call assert_equal(77, g:a['t'])\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 91:  using type().\t\t\t\t\t    {{{1\n\"-------------------------------------------------------------------------------\n\nfunc Test_type()\n    call assert_equal(0, type(0))\n    call assert_equal(1, type(\"\"))\n    call assert_equal(2, type(function(\"tr\")))\n    call assert_equal(2, type(function(\"tr\", [8])))\n    call assert_equal(3, type([]))\n    call assert_equal(4, type({}))\n    if has('float')\n      call assert_equal(5, type(0.0))\n    endif\n    call assert_equal(6, type(v:false))\n    call assert_equal(6, type(v:true))\n    call assert_equal(7, type(v:none))\n    call assert_equal(7, type(v:null))\n    call assert_equal(8, v:t_job)\n    call assert_equal(9, v:t_channel)\n    call assert_equal(v:t_number, type(0))\n    call assert_equal(v:t_string, type(\"\"))\n    call assert_equal(v:t_func, type(function(\"tr\")))\n    call assert_equal(v:t_func, type(function(\"tr\", [8])))\n    call assert_equal(v:t_list, type([]))\n    call assert_equal(v:t_dict, type({}))\n    if has('float')\n      call assert_equal(v:t_float, type(0.0))\n    endif\n    call assert_equal(v:t_bool, type(v:false))\n    call assert_equal(v:t_bool, type(v:true))\n    call assert_equal(v:t_none, type(v:none))\n    call assert_equal(v:t_none, type(v:null))\n    call assert_equal(v:t_string, type(test_null_string()))\n    call assert_equal(v:t_func, type(test_null_function()))\n    call assert_equal(v:t_func, type(test_null_partial()))\n    call assert_equal(v:t_list, type(test_null_list()))\n    call assert_equal(v:t_dict, type(test_null_dict()))\n    if has('job')\n      call assert_equal(v:t_job, type(test_null_job()))\n    endif\n    if has('channel')\n      call assert_equal(v:t_channel, type(test_null_channel()))\n    endif\n    call assert_equal(v:t_blob, type(test_null_blob()))\n\n    call assert_fails(\"call type(test_void())\", 'E685:')\n    call assert_fails(\"call type(test_unknown())\", 'E685:')\n\n    call assert_equal(0, 0 + v:false)\n    call assert_equal(1, 0 + v:true)\n    call assert_equal(0, 0 + v:none)\n    call assert_equal(0, 0 + v:null)\n\n    call assert_equal('v:false', '' . v:false)\n    call assert_equal('v:true', '' . v:true)\n    call assert_equal('v:none', '' . v:none)\n    call assert_equal('v:null', '' . v:null)\n\n    call assert_true(v:false == 0)\n    call assert_false(v:false != 0)\n    call assert_true(v:true == 1)\n    call assert_false(v:true != 1)\n    call assert_false(v:true == v:false)\n    call assert_true(v:true != v:false)\n\n    call assert_true(v:null == 0)\n    call assert_false(v:null == 1)\n    call assert_false(v:null != 0)\n    call assert_true(v:none == 0)\n    call assert_false(v:none == 1)\n    call assert_false(v:none != 0)\n    if has('float')\n      call assert_true(v:null == 0.0)\n      call assert_false(v:null == 0.1)\n      call assert_false(v:null != 0.0)\n    endif\n\n    call assert_true(v:false is v:false)\n    call assert_true(v:true is v:true)\n    call assert_true(v:none is v:none)\n    call assert_true(v:null is v:null)\n\n    call assert_false(v:false isnot v:false)\n    call assert_false(v:true isnot v:true)\n    call assert_false(v:none isnot v:none)\n    call assert_false(v:null isnot v:null)\n\n    call assert_false(v:false is 0)\n    call assert_false(v:true is 1)\n    call assert_false(v:true is v:false)\n    call assert_false(v:none is 0)\n    call assert_false(v:none is [])\n    call assert_false(v:none is {})\n    call assert_false(v:none is 'text')\n    call assert_false(v:null is 0)\n    call assert_false(v:null is v:none)\n\n    call assert_true(v:false isnot 0)\n    call assert_true(v:true isnot 1)\n    call assert_true(v:true isnot v:false)\n    call assert_true(v:none isnot 0)\n    call assert_true(v:null isnot 0)\n    call assert_true(v:null isnot v:none)\n\n    call assert_equal(v:false, eval(string(v:false)))\n    call assert_equal(v:true, eval(string(v:true)))\n    call assert_equal(v:none, eval(string(v:none)))\n    call assert_equal(v:null, eval(string(v:null)))\n\n    call assert_equal(v:false, copy(v:false))\n    call assert_equal(v:true, copy(v:true))\n    call assert_equal(v:none, copy(v:none))\n    call assert_equal(v:null, copy(v:null))\n\n    call assert_equal([v:false], deepcopy([v:false]))\n    call assert_equal([v:true], deepcopy([v:true]))\n    call assert_equal([v:none], deepcopy([v:none]))\n    call assert_equal([v:null], deepcopy([v:null]))\n\n    call assert_true(empty(v:false))\n    call assert_false(empty(v:true))\n    call assert_true(empty(v:null))\n    call assert_true(empty(v:none))\n\n    func ChangeYourMind()\n\ttry\n\t    return v:true\n\tfinally\n\t    return 'something else'\n\tendtry\n    endfunc\n\n    call ChangeYourMind()\nendfunc\n\nfunc Test_typename()\n  call assert_equal('number', typename(123))\n  call assert_equal('string', typename('x'))\n  call assert_equal('list<number>', typename([123]))\n  call assert_equal('dict<number>', typename(#{key: 123}))\n  call assert_equal('list<dict<number>>', typename([#{key: 123}]))\n\n  let l = []\n  let d = #{a: 0}\n  let l = [d]\n  let l[0].e = #{b: l}\n  call assert_equal('list<dict<any>>', typename(l))\n  call assert_equal('dict<any>', typename(d))\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 92:  skipping code\t\t\t\t\t    {{{1\n\"-------------------------------------------------------------------------------\n\nfunc Test_skip()\n    let Fn = function('Test_type')\n    call assert_false(0 && Fn[1])\n    call assert_false(0 && string(Fn))\n    call assert_false(0 && len(Fn))\n    let l = []\n    call assert_false(0 && l[1])\n    call assert_false(0 && string(l))\n    call assert_false(0 && len(l))\n    let f = 1.0\n    call assert_false(0 && f[1])\n    call assert_false(0 && string(f))\n    call assert_false(0 && len(f))\n    let sp = v:null\n    call assert_false(0 && sp[1])\n    call assert_false(0 && string(sp))\n    call assert_false(0 && len(sp))\n\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 93:  :echo and string()\t\t\t\t\t    {{{1\n\"-------------------------------------------------------------------------------\n\nfunc Test_echo_and_string()\n    \" String\n    let a = 'foo bar'\n    redir => result\n    echo a\n    echo string(a)\n    redir END\n    let l = split(result, \"\\n\")\n    call assert_equal([\"foo bar\",\n\t\t     \\ \"'foo bar'\"], l)\n\n    \" Float\n    if has('float')\n\tlet a = -1.2e0\n\tredir => result\n\techo a\n\techo string(a)\n\tredir END\n\tlet l = split(result, \"\\n\")\n\tcall assert_equal([\"-1.2\",\n\t\t\t \\ \"-1.2\"], l)\n    endif\n\n    \" Funcref\n    redir => result\n    echo function('string')\n    echo string(function('string'))\n    redir END\n    let l = split(result, \"\\n\")\n    call assert_equal([\"string\",\n\t\t     \\ \"function('string')\"], l)\n\n    \" Recursive dictionary\n    let a = {}\n    let a[\"a\"] = a\n    redir => result\n    echo a\n    echo string(a)\n    redir END\n    let l = split(result, \"\\n\")\n    call assert_equal([\"{'a': {...}}\",\n\t\t     \\ \"{'a': {...}}\"], l)\n\n    \" Recursive list\n    let a = [0]\n    let a[0] = a\n    redir => result\n    echo a\n    echo string(a)\n    redir END\n    let l = split(result, \"\\n\")\n    call assert_equal([\"[[...]]\",\n\t\t     \\ \"[[...]]\"], l)\n\n    \" Empty dictionaries in a list\n    let a = {}\n    redir => result\n    echo [a, a, a]\n    echo string([a, a, a])\n    redir END\n    let l = split(result, \"\\n\")\n    call assert_equal([\"[{}, {}, {}]\",\n\t\t     \\ \"[{}, {}, {}]\"], l)\n\n    \" Empty dictionaries in a dictionary\n    let a = {}\n    let b = {\"a\": a, \"b\": a}\n    redir => result\n    echo b\n    echo string(b)\n    redir END\n    let l = split(result, \"\\n\")\n    call assert_equal([\"{'a': {}, 'b': {}}\",\n\t\t     \\ \"{'a': {}, 'b': {}}\"], l)\n\n    \" Empty lists in a list\n    let a = []\n    redir => result\n    echo [a, a, a]\n    echo string([a, a, a])\n    redir END\n    let l = split(result, \"\\n\")\n    call assert_equal([\"[[], [], []]\",\n\t\t     \\ \"[[], [], []]\"], l)\n\n    \" Empty lists in a dictionary\n    let a = []\n    let b = {\"a\": a, \"b\": a}\n    redir => result\n    echo b\n    echo string(b)\n    redir END\n    let l = split(result, \"\\n\")\n    call assert_equal([\"{'a': [], 'b': []}\",\n\t\t     \\ \"{'a': [], 'b': []}\"], l)\n\n    \" Dictionaries in a list\n    let a = {\"one\": \"yes\", \"two\": \"yes\", \"three\": \"yes\"}\n    redir => result\n    echo [a, a, a]\n    echo string([a, a, a])\n    redir END\n    let l = split(result, \"\\n\")\n    call assert_equal([\"[{'one': 'yes', 'two': 'yes', 'three': 'yes'}, {...}, {...}]\",\n\t\t     \\ \"[{'one': 'yes', 'two': 'yes', 'three': 'yes'}, {'one': 'yes', 'two': 'yes', 'three': 'yes'}, {'one': 'yes', 'two': 'yes', 'three': 'yes'}]\"], l)\n\n    \" Dictionaries in a dictionary\n    let a = {\"one\": \"yes\", \"two\": \"yes\", \"three\": \"yes\"}\n    let b = {\"a\": a, \"b\": a}\n    redir => result\n    echo b\n    echo string(b)\n    redir END\n    let l = split(result, \"\\n\")\n    call assert_equal([\"{'a': {'one': 'yes', 'two': 'yes', 'three': 'yes'}, 'b': {...}}\",\n\t\t     \\ \"{'a': {'one': 'yes', 'two': 'yes', 'three': 'yes'}, 'b': {'one': 'yes', 'two': 'yes', 'three': 'yes'}}\"], l)\n\n    \" Lists in a list\n    let a = [1, 2, 3]\n    redir => result\n    echo [a, a, a]\n    echo string([a, a, a])\n    redir END\n    let l = split(result, \"\\n\")\n    call assert_equal([\"[[1, 2, 3], [...], [...]]\",\n\t\t     \\ \"[[1, 2, 3], [1, 2, 3], [1, 2, 3]]\"], l)\n\n    \" Lists in a dictionary\n    let a = [1, 2, 3]\n    let b = {\"a\": a, \"b\": a}\n    redir => result\n    echo b\n    echo string(b)\n    redir END\n    let l = split(result, \"\\n\")\n    call assert_equal([\"{'a': [1, 2, 3], 'b': [...]}\",\n\t\t     \\ \"{'a': [1, 2, 3], 'b': [1, 2, 3]}\"], l)\n\n    call assert_fails('echo &:', 'E112:')\n    call assert_fails('echo &g:', 'E112:')\n    call assert_fails('echo &l:', 'E112:')\n\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 94:  64-bit Numbers\t\t\t\t\t    {{{1\n\"-------------------------------------------------------------------------------\n\nfunc Test_num64()\n    call assert_notequal( 4294967296, 0)\n    call assert_notequal(-4294967296, 0)\n    call assert_equal( 4294967296,  0xFFFFffff + 1)\n    call assert_equal(-4294967296, -0xFFFFffff - 1)\n\n    call assert_equal( 9223372036854775807,  1 / 0)\n    call assert_equal(-9223372036854775807, -1 / 0)\n    call assert_equal(-9223372036854775807 - 1,  0 / 0)\n\n    if has('float')\n      call assert_equal( 0x7FFFffffFFFFffff, float2nr( 1.0e150))\n      call assert_equal(-0x7FFFffffFFFFffff, float2nr(-1.0e150))\n    endif\n\n    let rng = range(0xFFFFffff, 0x100000001)\n    call assert_equal([0xFFFFffff, 0x100000000, 0x100000001], rng)\n    call assert_equal(0x100000001, max(rng))\n    call assert_equal(0xFFFFffff, min(rng))\n    call assert_equal(rng, sort(range(0x100000001, 0xFFFFffff, -1), 'N'))\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 95:  lines of :append, :change, :insert\t\t\t    {{{1\n\"-------------------------------------------------------------------------------\n\nfunction! DefineFunction(name, body)\n    let func = join(['function! ' . a:name . '()'] + a:body + ['endfunction'], \"\\n\")\n    exec func\nendfunction\n\nfunc Test_script_lines()\n    \" :append\n    try\n\tcall DefineFunction('T_Append', [\n\t\t    \\ 'append',\n\t\t    \\ 'py <<EOS',\n\t\t    \\ '.',\n\t\t    \\ ])\n    catch\n\tcall assert_report(\"Can't define function\")\n    endtry\n    try\n\tcall DefineFunction('T_Append', [\n\t\t    \\ 'append',\n\t\t    \\ 'abc',\n\t\t    \\ ])\n\tcall assert_report(\"Shouldn't be able to define function\")\n    catch\n\tcall assert_exception('Vim(function):E1145: Missing heredoc end marker: .')\n    endtry\n\n    \" :change\n    try\n\tcall DefineFunction('T_Change', [\n\t\t    \\ 'change',\n\t\t    \\ 'py <<EOS',\n\t\t    \\ '.',\n\t\t    \\ ])\n    catch\n\tcall assert_report(\"Can't define function\")\n    endtry\n    try\n\tcall DefineFunction('T_Change', [\n\t\t    \\ 'change',\n\t\t    \\ 'abc',\n\t\t    \\ ])\n\tcall assert_report(\"Shouldn't be able to define function\")\n    catch\n\tcall assert_exception('Vim(function):E1145: Missing heredoc end marker: .')\n    endtry\n\n    \" :insert\n    try\n\tcall DefineFunction('T_Insert', [\n\t\t    \\ 'insert',\n\t\t    \\ 'py <<EOS',\n\t\t    \\ '.',\n\t\t    \\ ])\n    catch\n\tcall assert_report(\"Can't define function\")\n    endtry\n    try\n\tcall DefineFunction('T_Insert', [\n\t\t    \\ 'insert',\n\t\t    \\ 'abc',\n\t\t    \\ ])\n\tcall assert_report(\"Shouldn't be able to define function\")\n    catch\n\tcall assert_exception('Vim(function):E1145: Missing heredoc end marker: .')\n    endtry\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 96:  line continuation\t\t\t\t\t\t    {{{1\n\"\n\"\t    Undefined behavior was detected by ubsan with line continuation\n\"\t    after an empty line.\n\"-------------------------------------------------------------------------------\nfunc Test_script_emty_line_continuation()\n\n    \\\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 97:  bitwise functions\t\t\t\t\t\t    {{{1\n\"-------------------------------------------------------------------------------\nfunc Test_bitwise_functions()\n    \" and\n    call assert_equal(127, and(127, 127))\n    call assert_equal(16, and(127, 16))\n    eval 127->and(16)->assert_equal(16)\n    call assert_equal(0, and(127, 128))\n    call assert_fails(\"call and([], 1)\", 'E745:')\n    call assert_fails(\"call and({}, 1)\", 'E728:')\n    if has('float')\n      call assert_fails(\"call and(1.0, 1)\", 'E805:')\n      call assert_fails(\"call and(1, 1.0)\", 'E805:')\n    endif\n    call assert_fails(\"call and(1, [])\", 'E745:')\n    call assert_fails(\"call and(1, {})\", 'E728:')\n    \" or\n    call assert_equal(23, or(16, 7))\n    call assert_equal(15, or(8, 7))\n    eval 8->or(7)->assert_equal(15)\n    call assert_equal(123, or(0, 123))\n    call assert_fails(\"call or([], 1)\", 'E745:')\n    call assert_fails(\"call or({}, 1)\", 'E728:')\n    if has('float')\n      call assert_fails(\"call or(1.0, 1)\", 'E805:')\n      call assert_fails(\"call or(1, 1.0)\", 'E805:')\n    endif\n    call assert_fails(\"call or(1, [])\", 'E745:')\n    call assert_fails(\"call or(1, {})\", 'E728:')\n    \" xor\n    call assert_equal(0, xor(127, 127))\n    call assert_equal(111, xor(127, 16))\n    eval 127->xor(16)->assert_equal(111)\n    call assert_equal(255, xor(127, 128))\n    if has('float')\n      call assert_fails(\"call xor(1.0, 1)\", 'E805:')\n      call assert_fails(\"call xor(1, 1.0)\", 'E805:')\n    endif\n    call assert_fails(\"call xor([], 1)\", 'E745:')\n    call assert_fails(\"call xor({}, 1)\", 'E728:')\n    call assert_fails(\"call xor(1, [])\", 'E745:')\n    call assert_fails(\"call xor(1, {})\", 'E728:')\n    \" invert\n    call assert_equal(65408, and(invert(127), 65535))\n    eval 127->invert()->and(65535)->assert_equal(65408)\n    call assert_equal(65519, and(invert(16), 65535))\n    call assert_equal(65407, and(invert(128), 65535))\n    if has('float')\n      call assert_fails(\"call invert(1.0)\", 'E805:')\n    endif\n    call assert_fails(\"call invert([])\", 'E745:')\n    call assert_fails(\"call invert({})\", 'E728:')\nendfunc\n\n\" Test using bang after user command\t\t\t\t    {{{1\nfunc Test_user_command_with_bang()\n    command -bang Nieuw let nieuw = 1\n    Ni!\n    call assert_equal(1, nieuw)\n    unlet nieuw\n    delcommand Nieuw\nendfunc\n\nfunc Test_script_expand_sfile()\n  let lines =<< trim END\n    func s:snr()\n      return expand('<sfile>')\n    endfunc\n    let g:result = s:snr()\n  END\n  call writefile(lines, 'Xexpand')\n  source Xexpand\n  call assert_match('<SNR>\\d\\+_snr', g:result)\n  source Xexpand\n  call assert_match('<SNR>\\d\\+_snr', g:result)\n\n  call delete('Xexpand')\n  unlet g:result\nendfunc\n\nfunc Test_compound_assignment_operators()\n    \" Test for number\n    let x = 1\n    let x += 10\n    call assert_equal(11, x)\n    let x -= 5\n    call assert_equal(6, x)\n    let x *= 4\n    call assert_equal(24, x)\n    let x /= 3\n    call assert_equal(8, x)\n    let x %= 3\n    call assert_equal(2, x)\n    let x .= 'n'\n    call assert_equal('2n', x)\n\n    \" Test special cases: division or modulus with 0.\n    let x = 1\n    let x /= 0\n    call assert_equal(0x7FFFFFFFFFFFFFFF, x)\n\n    let x = -1\n    let x /= 0\n    call assert_equal(-0x7FFFFFFFFFFFFFFF, x)\n\n    let x = 0\n    let x /= 0\n    call assert_equal(-0x7FFFFFFFFFFFFFFF - 1, x)\n\n    let x = 1\n    let x %= 0\n    call assert_equal(0, x)\n\n    let x = -1\n    let x %= 0\n    call assert_equal(0, x)\n\n    let x = 0\n    let x %= 0\n    call assert_equal(0, x)\n\n    \" Test for string\n    let x = 'str'\n    let x .= 'ing'\n    call assert_equal('string', x)\n    let x += 1\n    call assert_equal(1, x)\n\n    if has('float')\n      \" Test for float\n      let x -= 1.5\n      call assert_equal(-0.5, x)\n      let x = 0.5\n      let x += 4.5\n      call assert_equal(5.0, x)\n      let x -= 1.5\n      call assert_equal(3.5, x)\n      let x *= 3.0\n      call assert_equal(10.5, x)\n      let x /= 2.5\n      call assert_equal(4.2, x)\n      call assert_fails('let x %= 0.5', 'E734:')\n      call assert_fails('let x .= \"f\"', 'E734:')\n      let x = !3.14\n      call assert_equal(0.0, x)\n\n      \" integer and float operations\n      let x = 1\n      let x *= 2.1\n      call assert_equal(2.1, x)\n      let x = 1\n      let x /= 0.25\n      call assert_equal(4.0, x)\n      let x = 1\n      call assert_fails('let x %= 0.25', 'E734:')\n      let x = 1\n      call assert_fails('let x .= 0.25', 'E734:')\n      let x = 1.0\n      call assert_fails('let x += [1.1]', 'E734:')\n    endif\n\n    \" Test for environment variable\n    let $FOO = 1\n    call assert_fails('let $FOO += 1', 'E734:')\n    call assert_fails('let $FOO -= 1', 'E734:')\n    call assert_fails('let $FOO *= 1', 'E734:')\n    call assert_fails('let $FOO /= 1', 'E734:')\n    call assert_fails('let $FOO %= 1', 'E734:')\n    let $FOO .= 's'\n    call assert_equal('1s', $FOO)\n    unlet $FOO\n\n    \" Test for option variable (type: number)\n    let &scrolljump = 1\n    let &scrolljump += 5\n    call assert_equal(6, &scrolljump)\n    let &scrolljump -= 2\n    call assert_equal(4, &scrolljump)\n    let &scrolljump *= 3\n    call assert_equal(12, &scrolljump)\n    let &scrolljump /= 2\n    call assert_equal(6, &scrolljump)\n    let &scrolljump %= 5\n    call assert_equal(1, &scrolljump)\n    call assert_fails('let &scrolljump .= \"j\"', 'E734:')\n    set scrolljump&vim\n\n    let &foldlevelstart = 2\n    let &foldlevelstart -= 1\n    call assert_equal(1, &foldlevelstart)\n    let &foldlevelstart -= 1\n    call assert_equal(0, &foldlevelstart)\n    let &foldlevelstart = 2\n    let &foldlevelstart -= 2\n    call assert_equal(0, &foldlevelstart)\n\n    \" Test for register\n    let @/ = 1\n    call assert_fails('let @/ += 1', 'E734:')\n    call assert_fails('let @/ -= 1', 'E734:')\n    call assert_fails('let @/ *= 1', 'E734:')\n    call assert_fails('let @/ /= 1', 'E734:')\n    call assert_fails('let @/ %= 1', 'E734:')\n    let @/ .= 's'\n    call assert_equal('1s', @/)\n    let @/ = ''\nendfunc\n\nfunc Test_unlet_env()\n  let $TESTVAR = 'yes'\n  call assert_equal('yes', $TESTVAR)\n  call assert_fails('lockvar $TESTVAR', 'E940:')\n  call assert_fails('unlockvar $TESTVAR', 'E940:')\n  call assert_equal('yes', $TESTVAR)\n  if 0\n    unlet $TESTVAR\n  endif\n  call assert_equal('yes', $TESTVAR)\n  unlet $TESTVAR\n  call assert_equal('', $TESTVAR)\nendfunc\n\nfunc Test_refcount()\n    \" Immediate values\n    call assert_equal(-1, test_refcount(1))\n    call assert_equal(-1, test_refcount('s'))\n    call assert_equal(-1, test_refcount(v:true))\n    call assert_equal(0, test_refcount([]))\n    call assert_equal(0, test_refcount({}))\n    call assert_equal(0, test_refcount(0zff))\n    call assert_equal(0, test_refcount({-> line('.')}))\n    if has('float')\n        call assert_equal(-1, test_refcount(0.1))\n    endif\n    if has('job')\n        call assert_equal(0, test_refcount(job_start([&shell, &shellcmdflag, 'echo .'])))\n    endif\n\n    \" No refcount types\n    let x = 1\n    call assert_equal(-1, test_refcount(x))\n    let x = 's'\n    call assert_equal(-1, test_refcount(x))\n    let x = v:true\n    call assert_equal(-1, test_refcount(x))\n    if has('float')\n        let x = 0.1\n        call assert_equal(-1, test_refcount(x))\n    endif\n\n    \" Check refcount\n    let x = []\n    call assert_equal(1, test_refcount(x))\n\n    let x = {}\n    call assert_equal(1, x->test_refcount())\n\n    let x = 0zff\n    call assert_equal(1, test_refcount(x))\n\n    let X = {-> line('.')}\n    call assert_equal(1, test_refcount(X))\n    let Y = X\n    call assert_equal(2, test_refcount(X))\n\n    if has('job')\n        let job = job_start([&shell, &shellcmdflag, 'echo .'])\n        call assert_equal(1, test_refcount(job))\n        call assert_equal(1, test_refcount(job_getchannel(job)))\n        call assert_equal(1, test_refcount(job))\n    endif\n\n    \" Function arguments, copying and unassigning\n    func ExprCheck(x, i)\n        let i = a:i + 1\n        call assert_equal(i, test_refcount(a:x))\n        let Y = a:x\n        call assert_equal(i + 1, test_refcount(a:x))\n        call assert_equal(test_refcount(a:x), test_refcount(Y))\n        let Y = 0\n        call assert_equal(i, test_refcount(a:x))\n    endfunc\n    call ExprCheck([], 0)\n    call ExprCheck({}, 0)\n    call ExprCheck(0zff, 0)\n    call ExprCheck({-> line('.')}, 0)\n    if has('job')\n\tcall ExprCheck(job, 1)\n\tcall ExprCheck(job_getchannel(job), 1)\n\tcall job_stop(job)\n    endif\n    delfunc ExprCheck\n\n    \" Regarding function\n    func Func(x) abort\n        call assert_equal(2, test_refcount(function('Func')))\n        call assert_equal(0, test_refcount(funcref('Func')))\n    endfunc\n    call assert_equal(1, test_refcount(function('Func')))\n    call assert_equal(0, test_refcount(function('Func', [1])))\n    call assert_equal(0, test_refcount(funcref('Func')))\n    call assert_equal(0, test_refcount(funcref('Func', [1])))\n    let X = function('Func')\n    let Y = X\n    call assert_equal(1, test_refcount(X))\n    let X = function('Func', [1])\n    let Y = X\n    call assert_equal(2, test_refcount(X))\n    let X = funcref('Func')\n    let Y = X\n    call assert_equal(2, test_refcount(X))\n    let X = funcref('Func', [1])\n    let Y = X\n    call assert_equal(2, test_refcount(X))\n    unlet X\n    unlet Y\n    call Func(1)\n    delfunc Func\n\n    \" Function with dict\n    func DictFunc() dict\n        call assert_equal(3, test_refcount(self))\n    endfunc\n    let d = {'Func': function('DictFunc')}\n    call assert_equal(1, test_refcount(d))\n    call assert_equal(0, test_refcount(d.Func))\n    call d.Func()\n    unlet d\n    delfunc DictFunc\nendfunc\n\n\" Test for missing :endif, :endfor, :endwhile and :endtry           {{{1\nfunc Test_missing_end()\n  call writefile(['if 2 > 1', 'echo \">\"'], 'Xscript')\n  call assert_fails('source Xscript', 'E171:')\n  call writefile(['for i in range(5)', 'echo i'], 'Xscript')\n  call assert_fails('source Xscript', 'E170:')\n  call writefile(['while v:true', 'echo \".\"'], 'Xscript')\n  call assert_fails('source Xscript', 'E170:')\n  call writefile(['try', 'echo \".\"'], 'Xscript')\n  call assert_fails('source Xscript', 'E600:')\n  call delete('Xscript')\n\n  \" Using endfor with :while\n  let caught_e732 = 0\n  try\n    while v:true\n    endfor\n  catch /E732:/\n    let caught_e732 = 1\n  endtry\n  call assert_equal(1, caught_e732)\n\n  \" Using endwhile with :for\n  let caught_e733 = 0\n  try\n    for i in range(1)\n    endwhile\n  catch /E733:/\n    let caught_e733 = 1\n  endtry\n  call assert_equal(1, caught_e733)\n\n  \" Using endfunc with :if\n  call assert_fails('exe \"if 1 | endfunc | endif\"', 'E193:')\n\n  \" Missing 'in' in a :for statement\n  call assert_fails('for i range(1) | endfor', 'E690:')\n\n  \" Incorrect number of variables in for\n  call assert_fails('for [i,] in range(3) | endfor', 'E475:')\nendfunc\n\n\" Test for deep nesting of if/for/while/try statements              {{{1\nfunc Test_deep_nest()\n  CheckRunVimInTerminal\n\n  let lines =<< trim [SCRIPT]\n    \" Deep nesting of if ... endif\n    func Test1()\n      let @a = join(repeat(['if v:true'], 51), \"\\n\")\n      let @a ..= \"\\n\"\n      let @a ..= join(repeat(['endif'], 51), \"\\n\")\n      @a\n      let @a = ''\n    endfunc\n\n    \" Deep nesting of for ... endfor\n    func Test2()\n      let @a = join(repeat(['for i in [1]'], 51), \"\\n\")\n      let @a ..= \"\\n\"\n      let @a ..= join(repeat(['endfor'], 51), \"\\n\")\n      @a\n      let @a = ''\n    endfunc\n\n    \" Deep nesting of while ... endwhile\n    func Test3()\n      let @a = join(repeat(['while v:true'], 51), \"\\n\")\n      let @a ..= \"\\n\"\n      let @a ..= join(repeat(['endwhile'], 51), \"\\n\")\n      @a\n      let @a = ''\n    endfunc\n\n    \" Deep nesting of try ... endtry\n    func Test4()\n      let @a = join(repeat(['try'], 51), \"\\n\")\n      let @a ..= \"\\necho v:true\\n\"\n      let @a ..= join(repeat(['endtry'], 51), \"\\n\")\n      @a\n      let @a = ''\n    endfunc\n\n    \" Deep nesting of function ... endfunction\n    func Test5()\n      let @a = join(repeat(['function X()'], 51), \"\\n\")\n      let @a ..= \"\\necho v:true\\n\"\n      let @a ..= join(repeat(['endfunction'], 51), \"\\n\")\n      @a\n      let @a = ''\n    endfunc\n  [SCRIPT]\n  call writefile(lines, 'Xscript')\n\n  let buf = RunVimInTerminal('-S Xscript', {'rows': 6})\n\n  \" Deep nesting of if ... endif\n  call term_sendkeys(buf, \":call Test1()\\n\")\n  call TermWait(buf)\n  call WaitForAssert({-> assert_match('^E579:', term_getline(buf, 5))})\n\n  \" Deep nesting of for ... endfor\n  call term_sendkeys(buf, \":call Test2()\\n\")\n  call TermWait(buf)\n  call WaitForAssert({-> assert_match('^E585:', term_getline(buf, 5))})\n\n  \" Deep nesting of while ... endwhile\n  call term_sendkeys(buf, \":call Test3()\\n\")\n  call TermWait(buf)\n  call WaitForAssert({-> assert_match('^E585:', term_getline(buf, 5))})\n\n  \" Deep nesting of try ... endtry\n  call term_sendkeys(buf, \":call Test4()\\n\")\n  call TermWait(buf)\n  call WaitForAssert({-> assert_match('^E601:', term_getline(buf, 5))})\n\n  \" Deep nesting of function ... endfunction\n  call term_sendkeys(buf, \":call Test5()\\n\")\n  call TermWait(buf)\n  call WaitForAssert({-> assert_match('^E1058:', term_getline(buf, 4))})\n  call term_sendkeys(buf, \"\\<C-C>\\n\")\n  call TermWait(buf)\n\n  \"let l = ''\n  \"for i in range(1, 6)\n  \"  let l ..= term_getline(buf, i) . \"\\n\"\n  \"endfor\n  \"call assert_report(l)\n\n  call StopVimInTerminal(buf)\n  call delete('Xscript')\nendfunc\n\n\" Test for errors in converting to float from various types         {{{1\nfunc Test_float_conversion_errors()\n  if has('float')\n    call assert_fails('let x = 4.0 % 2.0', 'E804:')\n    call assert_fails('echo 1.1[0]', 'E806:')\n    call assert_fails('echo sort([function(\"min\"), 1], \"f\")', 'E891:')\n    call assert_fails('echo 3.2 == \"vim\"', 'E892:')\n    call assert_fails('echo sort([[], 1], \"f\")', 'E893:')\n    call assert_fails('echo sort([{}, 1], \"f\")', 'E894:')\n    call assert_fails('echo 3.2 == v:true', 'E362:')\n    call assert_fails('echo 3.2 == v:none', 'E907:')\n  endif\nendfunc\n\n\" invalid function names               {{{1\nfunc Test_invalid_function_names()\n  \" function name not starting with capital\n  let caught_e128 = 0\n  try\n    func! g:test()\n      echo \"test\"\n    endfunc\n  catch /E128:/\n    let caught_e128 = 1\n  endtry\n  call assert_equal(1, caught_e128)\n\n  \" function name includes a colon\n  let caught_e884 = 0\n  try\n    func! b:test()\n      echo \"test\"\n    endfunc\n  catch /E884:/\n    let caught_e884 = 1\n  endtry\n  call assert_equal(1, caught_e884)\n\n  \" function name followed by #\n  let caught_e128 = 0\n  try\n    func! test2() \"#\n      echo \"test2\"\n    endfunc\n  catch /E128:/\n    let caught_e128 = 1\n  endtry\n  call assert_equal(1, caught_e128)\n\n  \" function name starting with/without \"g:\", buffer-local funcref.\n  function! g:Foo(n)\n    return 'called Foo(' . a:n . ')'\n  endfunction\n  let b:my_func = function('Foo')\n  call assert_equal('called Foo(1)', b:my_func(1))\n  call assert_equal('called Foo(2)', g:Foo(2))\n  call assert_equal('called Foo(3)', Foo(3))\n  delfunc g:Foo\n\n  \" script-local function used in Funcref must exist.\n  let lines =<< trim END\n    func s:Testje()\n      return \"foo\"\n    endfunc\n    let Bar = function('s:Testje')\n    call assert_equal(0, exists('s:Testje'))\n    call assert_equal(1, exists('*s:Testje'))\n    call assert_equal(1, exists('Bar'))\n    call assert_equal(1, exists('*Bar'))\n  END\n  call writefile(lines, 'Xscript')\n  source Xscript\n  call delete('Xscript')\nendfunc\n\n\" substring and variable name              {{{1\nfunc Test_substring_var()\n  let str = 'abcdef'\n  let n = 3\n  call assert_equal('def', str[n:])\n  call assert_equal('abcd', str[:n])\n  call assert_equal('d', str[n:n])\n  unlet n\n  let nn = 3\n  call assert_equal('def', str[nn:])\n  call assert_equal('abcd', str[:nn])\n  call assert_equal('d', str[nn:nn])\n  unlet nn\n  let b:nn = 4\n  call assert_equal('ef', str[b:nn:])\n  call assert_equal('abcde', str[:b:nn])\n  call assert_equal('e', str[b:nn:b:nn])\n  unlet b:nn\nendfunc\n\n\" Test using s: with a typed command              {{{1\nfunc Test_typed_script_var()\n  CheckRunVimInTerminal\n\n  let buf = RunVimInTerminal('', {'rows': 6})\n\n  \" Deep nesting of if ... endif\n  call term_sendkeys(buf, \":echo get(s:, 'foo', 'x')\\n\")\n  call TermWait(buf)\n  call WaitForAssert({-> assert_match('^E116:', term_getline(buf, 5))})\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" Test for issue6776              {{{1\nfunc Test_ternary_expression()\n  try\n    call eval('0 ? 0')\n  catch\n  endtry\n  \" previous failure should not cause next expression to fail\n  call assert_equal(v:false, eval(string(v:false)))\n\n  try\n    call eval('0 ? \"burp')\n  catch\n  endtry\n  \" previous failure should not cause next expression to fail\n  call assert_equal(v:false, eval(string(v:false)))\n\n  try\n    call eval('1 ? 0 : \"burp')\n  catch\n  endtry\n  \" previous failure should not cause next expression to fail\n  call assert_equal(v:false, eval(string(v:false)))\nendfunction\n\nfunc Test_for_over_string()\n  let res = ''\n  for c in 'a\u00e9c\u0300d'\n    let res ..= c .. '-'\n  endfor\n  call assert_equal('a-\u00e9-c\u0300-d-', res)\n\n  let res = ''\n  for c in ''\n    let res ..= c .. '-'\n  endfor\n  call assert_equal('', res)\n\n  let res = ''\n  for c in test_null_string()\n    let res ..= c .. '-'\n  endfor\n  call assert_equal('', res)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Modelines\t\t\t\t\t\t\t\t    {{{1\n\" vim: ts=8 sw=2 sts=2 expandtab tw=80 fdm=marker\n\"-------------------------------------------------------------------------------\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    5168,\n/**/\n    5167,\n/**/\n    5166,\n/**/\n    5165,\n/**/\n    5164,\n/**/\n    5163,\n/**/\n    5162,\n/**/\n    5161,\n/**/\n    5160,\n/**/\n    5159,\n/**/\n    5158,\n/**/\n    5157,\n/**/\n    5156,\n/**/\n    5155,\n/**/\n    5154,\n/**/\n    5153,\n/**/\n    5152,\n/**/\n    5151,\n/**/\n    5150,\n/**/\n    5149,\n/**/\n    5148,\n/**/\n    5147,\n/**/\n    5146,\n/**/\n    5145,\n/**/\n    5144,\n/**/\n    5143,\n/**/\n    5142,\n/**/\n    5141,\n/**/\n    5140,\n/**/\n    5139,\n/**/\n    5138,\n/**/\n    5137,\n/**/\n    5136,\n/**/\n    5135,\n/**/\n    5134,\n/**/\n    5133,\n/**/\n    5132,\n/**/\n    5131,\n/**/\n    5130,\n/**/\n    5129,\n/**/\n    5128,\n/**/\n    5127,\n/**/\n    5126,\n/**/\n    5125,\n/**/\n    5124,\n/**/\n    5123,\n/**/\n    5122,\n/**/\n    5121,\n/**/\n    5120,\n/**/\n    5119,\n/**/\n    5118,\n/**/\n    5117,\n/**/\n    5116,\n/**/\n    5115,\n/**/\n    5114,\n/**/\n    5113,\n/**/\n    5112,\n/**/\n    5111,\n/**/\n    5110,\n/**/\n    5109,\n/**/\n    5108,\n/**/\n    5107,\n/**/\n    5106,\n/**/\n    5105,\n/**/\n    5104,\n/**/\n    5103,\n/**/\n    5102,\n/**/\n    5101,\n/**/\n    5100,\n/**/\n    5099,\n/**/\n    5098,\n/**/\n    5097,\n/**/\n    5096,\n/**/\n    5095,\n/**/\n    5094,\n/**/\n    5093,\n/**/\n    5092,\n/**/\n    5091,\n/**/\n    5090,\n/**/\n    5089,\n/**/\n    5088,\n/**/\n    5087,\n/**/\n    5086,\n/**/\n    5085,\n/**/\n    5084,\n/**/\n    5083,\n/**/\n    5082,\n/**/\n    5081,\n/**/\n    5080,\n/**/\n    5079,\n/**/\n    5078,\n/**/\n    5077,\n/**/\n    5076,\n/**/\n    5075,\n/**/\n    5074,\n/**/\n    5073,\n/**/\n    5072,\n/**/\n    5071,\n/**/\n    5070,\n/**/\n    5069,\n/**/\n    5068,\n/**/\n    5067,\n/**/\n    5066,\n/**/\n    5065,\n/**/\n    5064,\n/**/\n    5063,\n/**/\n    5062,\n/**/\n    5061,\n/**/\n    5060,\n/**/\n    5059,\n/**/\n    5058,\n/**/\n    5057,\n/**/\n    5056,\n/**/\n    5055,\n/**/\n    5054,\n/**/\n    5053,\n/**/\n    5052,\n/**/\n    5051,\n/**/\n    5050,\n/**/\n    5049,\n/**/\n    5048,\n/**/\n    5047,\n/**/\n    5046,\n/**/\n    5045,\n/**/\n    5044,\n/**/\n    5043,\n/**/\n    5042,\n/**/\n    5041,\n/**/\n    5040,\n/**/\n    5039,\n/**/\n    5038,\n/**/\n    5037,\n/**/\n    5036,\n/**/\n    5035,\n/**/\n    5034,\n/**/\n    5033,\n/**/\n    5032,\n/**/\n    5031,\n/**/\n    5030,\n/**/\n    5029,\n/**/\n    5028,\n/**/\n    5027,\n/**/\n    5026,\n/**/\n    5025,\n/**/\n    5024,\n/**/\n    5023,\n/**/\n    5022,\n/**/\n    5021,\n/**/\n    5020,\n/**/\n    5019,\n/**/\n    5018,\n/**/\n    5017,\n/**/\n    5016,\n/**/\n    5015,\n/**/\n    5014,\n/**/\n    5013,\n/**/\n    5012,\n/**/\n    5011,\n/**/\n    5010,\n/**/\n    5009,\n/**/\n    5008,\n/**/\n    5007,\n/**/\n    5006,\n/**/\n    5005,\n/**/\n    5004,\n/**/\n    5003,\n/**/\n    5002,\n/**/\n    5001,\n/**/\n    5000,\n/**/\n    4999,\n/**/\n    4998,\n/**/\n    4997,\n/**/\n    4996,\n/**/\n    4995,\n/**/\n    4994,\n/**/\n    4993,\n/**/\n    4992,\n/**/\n    4991,\n/**/\n    4990,\n/**/\n    4989,\n/**/\n    4988,\n/**/\n    4987,\n/**/\n    4986,\n/**/\n    4985,\n/**/\n    4984,\n/**/\n    4983,\n/**/\n    4982,\n/**/\n    4981,\n/**/\n    4980,\n/**/\n    4979,\n/**/\n    4978,\n/**/\n    4977,\n/**/\n    4976,\n/**/\n    4975,\n/**/\n    4974,\n/**/\n    4973,\n/**/\n    4972,\n/**/\n    4971,\n/**/\n    4970,\n/**/\n    4969,\n/**/\n    4968,\n/**/\n    4967,\n/**/\n    4966,\n/**/\n    4965,\n/**/\n    4964,\n/**/\n    4963,\n/**/\n    4962,\n/**/\n    4961,\n/**/\n    4960,\n/**/\n    4959,\n/**/\n    4958,\n/**/\n    4957,\n/**/\n    4956,\n/**/\n    4955,\n/**/\n    4954,\n/**/\n    4953,\n/**/\n    4952,\n/**/\n    4951,\n/**/\n    4950,\n/**/\n    4949,\n/**/\n    4948,\n/**/\n    4947,\n/**/\n    4946,\n/**/\n    4945,\n/**/\n    4944,\n/**/\n    4943,\n/**/\n    4942,\n/**/\n    4941,\n/**/\n    4940,\n/**/\n    4939,\n/**/\n    4938,\n/**/\n    4937,\n/**/\n    4936,\n/**/\n    4935,\n/**/\n    4934,\n/**/\n    4933,\n/**/\n    4932,\n/**/\n    4931,\n/**/\n    4930,\n/**/\n    4929,\n/**/\n    4928,\n/**/\n    4927,\n/**/\n    4926,\n/**/\n    4925,\n/**/\n    4924,\n/**/\n    4923,\n/**/\n    4922,\n/**/\n    4921,\n/**/\n    4920,\n/**/\n    4919,\n/**/\n    4918,\n/**/\n    4917,\n/**/\n    4916,\n/**/\n    4915,\n/**/\n    4914,\n/**/\n    4913,\n/**/\n    4912,\n/**/\n    4911,\n/**/\n    4910,\n/**/\n    4909,\n/**/\n    4908,\n/**/\n    4907,\n/**/\n    4906,\n/**/\n    4905,\n/**/\n    4904,\n/**/\n    4903,\n/**/\n    4902,\n/**/\n    4901,\n/**/\n    4900,\n/**/\n    4899,\n/**/\n    4898,\n/**/\n    4897,\n/**/\n    4896,\n/**/\n    4895,\n/**/\n    4894,\n/**/\n    4893,\n/**/\n    4892,\n/**/\n    4891,\n/**/\n    4890,\n/**/\n    4889,\n/**/\n    4888,\n/**/\n    4887,\n/**/\n    4886,\n/**/\n    4885,\n/**/\n    4884,\n/**/\n    4883,\n/**/\n    4882,\n/**/\n    4881,\n/**/\n    4880,\n/**/\n    4879,\n/**/\n    4878,\n/**/\n    4877,\n/**/\n    4876,\n/**/\n    4875,\n/**/\n    4874,\n/**/\n    4873,\n/**/\n    4872,\n/**/\n    4871,\n/**/\n    4870,\n/**/\n    4869,\n/**/\n    4868,\n/**/\n    4867,\n/**/\n    4866,\n/**/\n    4865,\n/**/\n    4864,\n/**/\n    4863,\n/**/\n    4862,\n/**/\n    4861,\n/**/\n    4860,\n/**/\n    4859,\n/**/\n    4858,\n/**/\n    4857,\n/**/\n    4856,\n/**/\n    4855,\n/**/\n    4854,\n/**/\n    4853,\n/**/\n    4852,\n/**/\n    4851,\n/**/\n    4850,\n/**/\n    4849,\n/**/\n    4848,\n/**/\n    4847,\n/**/\n    4846,\n/**/\n    4845,\n/**/\n    4844,\n/**/\n    4843,\n/**/\n    4842,\n/**/\n    4841,\n/**/\n    4840,\n/**/\n    4839,\n/**/\n    4838,\n/**/\n    4837,\n/**/\n    4836,\n/**/\n    4835,\n/**/\n    4834,\n/**/\n    4833,\n/**/\n    4832,\n/**/\n    4831,\n/**/\n    4830,\n/**/\n    4829,\n/**/\n    4828,\n/**/\n    4827,\n/**/\n    4826,\n/**/\n    4825,\n/**/\n    4824,\n/**/\n    4823,\n/**/\n    4822,\n/**/\n    4821,\n/**/\n    4820,\n/**/\n    4819,\n/**/\n    4818,\n/**/\n    4817,\n/**/\n    4816,\n/**/\n    4815,\n/**/\n    4814,\n/**/\n    4813,\n/**/\n    4812,\n/**/\n    4811,\n/**/\n    4810,\n/**/\n    4809,\n/**/\n    4808,\n/**/\n    4807,\n/**/\n    4806,\n/**/\n    4805,\n/**/\n    4804,\n/**/\n    4803,\n/**/\n    4802,\n/**/\n    4801,\n/**/\n    4800,\n/**/\n    4799,\n/**/\n    4798,\n/**/\n    4797,\n/**/\n    4796,\n/**/\n    4795,\n/**/\n    4794,\n/**/\n    4793,\n/**/\n    4792,\n/**/\n    4791,\n/**/\n    4790,\n/**/\n    4789,\n/**/\n    4788,\n/**/\n    4787,\n/**/\n    4786,\n/**/\n    4785,\n/**/\n    4784,\n/**/\n    4783,\n/**/\n    4782,\n/**/\n    4781,\n/**/\n    4780,\n/**/\n    4779,\n/**/\n    4778,\n/**/\n    4777,\n/**/\n    4776,\n/**/\n    4775,\n/**/\n    4774,\n/**/\n    4773,\n/**/\n    4772,\n/**/\n    4771,\n/**/\n    4770,\n/**/\n    4769,\n/**/\n    4768,\n/**/\n    4767,\n/**/\n    4766,\n/**/\n    4765,\n/**/\n    4764,\n/**/\n    4763,\n/**/\n    4762,\n/**/\n    4761,\n/**/\n    4760,\n/**/\n    4759,\n/**/\n    4758,\n/**/\n    4757,\n/**/\n    4756,\n/**/\n    4755,\n/**/\n    4754,\n/**/\n    4753,\n/**/\n    4752,\n/**/\n    4751,\n/**/\n    4750,\n/**/\n    4749,\n/**/\n    4748,\n/**/\n    4747,\n/**/\n    4746,\n/**/\n    4745,\n/**/\n    4744,\n/**/\n    4743,\n/**/\n    4742,\n/**/\n    4741,\n/**/\n    4740,\n/**/\n    4739,\n/**/\n    4738,\n/**/\n    4737,\n/**/\n    4736,\n/**/\n    4735,\n/**/\n    4734,\n/**/\n    4733,\n/**/\n    4732,\n/**/\n    4731,\n/**/\n    4730,\n/**/\n    4729,\n/**/\n    4728,\n/**/\n    4727,\n/**/\n    4726,\n/**/\n    4725,\n/**/\n    4724,\n/**/\n    4723,\n/**/\n    4722,\n/**/\n    4721,\n/**/\n    4720,\n/**/\n    4719,\n/**/\n    4718,\n/**/\n    4717,\n/**/\n    4716,\n/**/\n    4715,\n/**/\n    4714,\n/**/\n    4713,\n/**/\n    4712,\n/**/\n    4711,\n/**/\n    4710,\n/**/\n    4709,\n/**/\n    4708,\n/**/\n    4707,\n/**/\n    4706,\n/**/\n    4705,\n/**/\n    4704,\n/**/\n    4703,\n/**/\n    4702,\n/**/\n    4701,\n/**/\n    4700,\n/**/\n    4699,\n/**/\n    4698,\n/**/\n    4697,\n/**/\n    4696,\n/**/\n    4695,\n/**/\n    4694,\n/**/\n    4693,\n/**/\n    4692,\n/**/\n    4691,\n/**/\n    4690,\n/**/\n    4689,\n/**/\n    4688,\n/**/\n    4687,\n/**/\n    4686,\n/**/\n    4685,\n/**/\n    4684,\n/**/\n    4683,\n/**/\n    4682,\n/**/\n    4681,\n/**/\n    4680,\n/**/\n    4679,\n/**/\n    4678,\n/**/\n    4677,\n/**/\n    4676,\n/**/\n    4675,\n/**/\n    4674,\n/**/\n    4673,\n/**/\n    4672,\n/**/\n    4671,\n/**/\n    4670,\n/**/\n    4669,\n/**/\n    4668,\n/**/\n    4667,\n/**/\n    4666,\n/**/\n    4665,\n/**/\n    4664,\n/**/\n    4663,\n/**/\n    4662,\n/**/\n    4661,\n/**/\n    4660,\n/**/\n    4659,\n/**/\n    4658,\n/**/\n    4657,\n/**/\n    4656,\n/**/\n    4655,\n/**/\n    4654,\n/**/\n    4653,\n/**/\n    4652,\n/**/\n    4651,\n/**/\n    4650,\n/**/\n    4649,\n/**/\n    4648,\n/**/\n    4647,\n/**/\n    4646,\n/**/\n    4645,\n/**/\n    4644,\n/**/\n    4643,\n/**/\n    4642,\n/**/\n    4641,\n/**/\n    4640,\n/**/\n    4639,\n/**/\n    4638,\n/**/\n    4637,\n/**/\n    4636,\n/**/\n    4635,\n/**/\n    4634,\n/**/\n    4633,\n/**/\n    4632,\n/**/\n    4631,\n/**/\n    4630,\n/**/\n    4629,\n/**/\n    4628,\n/**/\n    4627,\n/**/\n    4626,\n/**/\n    4625,\n/**/\n    4624,\n/**/\n    4623,\n/**/\n    4622,\n/**/\n    4621,\n/**/\n    4620,\n/**/\n    4619,\n/**/\n    4618,\n/**/\n    4617,\n/**/\n    4616,\n/**/\n    4615,\n/**/\n    4614,\n/**/\n    4613,\n/**/\n    4612,\n/**/\n    4611,\n/**/\n    4610,\n/**/\n    4609,\n/**/\n    4608,\n/**/\n    4607,\n/**/\n    4606,\n/**/\n    4605,\n/**/\n    4604,\n/**/\n    4603,\n/**/\n    4602,\n/**/\n    4601,\n/**/\n    4600,\n/**/\n    4599,\n/**/\n    4598,\n/**/\n    4597,\n/**/\n    4596,\n/**/\n    4595,\n/**/\n    4594,\n/**/\n    4593,\n/**/\n    4592,\n/**/\n    4591,\n/**/\n    4590,\n/**/\n    4589,\n/**/\n    4588,\n/**/\n    4587,\n/**/\n    4586,\n/**/\n    4585,\n/**/\n    4584,\n/**/\n    4583,\n/**/\n    4582,\n/**/\n    4581,\n/**/\n    4580,\n/**/\n    4579,\n/**/\n    4578,\n/**/\n    4577,\n/**/\n    4576,\n/**/\n    4575,\n/**/\n    4574,\n/**/\n    4573,\n/**/\n    4572,\n/**/\n    4571,\n/**/\n    4570,\n/**/\n    4569,\n/**/\n    4568,\n/**/\n    4567,\n/**/\n    4566,\n/**/\n    4565,\n/**/\n    4564,\n/**/\n    4563,\n/**/\n    4562,\n/**/\n    4561,\n/**/\n    4560,\n/**/\n    4559,\n/**/\n    4558,\n/**/\n    4557,\n/**/\n    4556,\n/**/\n    4555,\n/**/\n    4554,\n/**/\n    4553,\n/**/\n    4552,\n/**/\n    4551,\n/**/\n    4550,\n/**/\n    4549,\n/**/\n    4548,\n/**/\n    4547,\n/**/\n    4546,\n/**/\n    4545,\n/**/\n    4544,\n/**/\n    4543,\n/**/\n    4542,\n/**/\n    4541,\n/**/\n    4540,\n/**/\n    4539,\n/**/\n    4538,\n/**/\n    4537,\n/**/\n    4536,\n/**/\n    4535,\n/**/\n    4534,\n/**/\n    4533,\n/**/\n    4532,\n/**/\n    4531,\n/**/\n    4530,\n/**/\n    4529,\n/**/\n    4528,\n/**/\n    4527,\n/**/\n    4526,\n/**/\n    4525,\n/**/\n    4524,\n/**/\n    4523,\n/**/\n    4522,\n/**/\n    4521,\n/**/\n    4520,\n/**/\n    4519,\n/**/\n    4518,\n/**/\n    4517,\n/**/\n    4516,\n/**/\n    4515,\n/**/\n    4514,\n/**/\n    4513,\n/**/\n    4512,\n/**/\n    4511,\n/**/\n    4510,\n/**/\n    4509,\n/**/\n    4508,\n/**/\n    4507,\n/**/\n    4506,\n/**/\n    4505,\n/**/\n    4504,\n/**/\n    4503,\n/**/\n    4502,\n/**/\n    4501,\n/**/\n    4500,\n/**/\n    4499,\n/**/\n    4498,\n/**/\n    4497,\n/**/\n    4496,\n/**/\n    4495,\n/**/\n    4494,\n/**/\n    4493,\n/**/\n    4492,\n/**/\n    4491,\n/**/\n    4490,\n/**/\n    4489,\n/**/\n    4488,\n/**/\n    4487,\n/**/\n    4486,\n/**/\n    4485,\n/**/\n    4484,\n/**/\n    4483,\n/**/\n    4482,\n/**/\n    4481,\n/**/\n    4480,\n/**/\n    4479,\n/**/\n    4478,\n/**/\n    4477,\n/**/\n    4476,\n/**/\n    4475,\n/**/\n    4474,\n/**/\n    4473,\n/**/\n    4472,\n/**/\n    4471,\n/**/\n    4470,\n/**/\n    4469,\n/**/\n    4468,\n/**/\n    4467,\n/**/\n    4466,\n/**/\n    4465,\n/**/\n    4464,\n/**/\n    4463,\n/**/\n    4462,\n/**/\n    4461,\n/**/\n    4460,\n/**/\n    4459,\n/**/\n    4458,\n/**/\n    4457,\n/**/\n    4456,\n/**/\n    4455,\n/**/\n    4454,\n/**/\n    4453,\n/**/\n    4452,\n/**/\n    4451,\n/**/\n    4450,\n/**/\n    4449,\n/**/\n    4448,\n/**/\n    4447,\n/**/\n    4446,\n/**/\n    4445,\n/**/\n    4444,\n/**/\n    4443,\n/**/\n    4442,\n/**/\n    4441,\n/**/\n    4440,\n/**/\n    4439,\n/**/\n    4438,\n/**/\n    4437,\n/**/\n    4436,\n/**/\n    4435,\n/**/\n    4434,\n/**/\n    4433,\n/**/\n    4432,\n/**/\n    4431,\n/**/\n    4430,\n/**/\n    4429,\n/**/\n    4428,\n/**/\n    4427,\n/**/\n    4426,\n/**/\n    4425,\n/**/\n    4424,\n/**/\n    4423,\n/**/\n    4422,\n/**/\n    4421,\n/**/\n    4420,\n/**/\n    4419,\n/**/\n    4418,\n/**/\n    4417,\n/**/\n    4416,\n/**/\n    4415,\n/**/\n    4414,\n/**/\n    4413,\n/**/\n    4412,\n/**/\n    4411,\n/**/\n    4410,\n/**/\n    4409,\n/**/\n    4408,\n/**/\n    4407,\n/**/\n    4406,\n/**/\n    4405,\n/**/\n    4404,\n/**/\n    4403,\n/**/\n    4402,\n/**/\n    4401,\n/**/\n    4400,\n/**/\n    4399,\n/**/\n    4398,\n/**/\n    4397,\n/**/\n    4396,\n/**/\n    4395,\n/**/\n    4394,\n/**/\n    4393,\n/**/\n    4392,\n/**/\n    4391,\n/**/\n    4390,\n/**/\n    4389,\n/**/\n    4388,\n/**/\n    4387,\n/**/\n    4386,\n/**/\n    4385,\n/**/\n    4384,\n/**/\n    4383,\n/**/\n    4382,\n/**/\n    4381,\n/**/\n    4380,\n/**/\n    4379,\n/**/\n    4378,\n/**/\n    4377,\n/**/\n    4376,\n/**/\n    4375,\n/**/\n    4374,\n/**/\n    4373,\n/**/\n    4372,\n/**/\n    4371,\n/**/\n    4370,\n/**/\n    4369,\n/**/\n    4368,\n/**/\n    4367,\n/**/\n    4366,\n/**/\n    4365,\n/**/\n    4364,\n/**/\n    4363,\n/**/\n    4362,\n/**/\n    4361,\n/**/\n    4360,\n/**/\n    4359,\n/**/\n    4358,\n/**/\n    4357,\n/**/\n    4356,\n/**/\n    4355,\n/**/\n    4354,\n/**/\n    4353,\n/**/\n    4352,\n/**/\n    4351,\n/**/\n    4350,\n/**/\n    4349,\n/**/\n    4348,\n/**/\n    4347,\n/**/\n    4346,\n/**/\n    4345,\n/**/\n    4344,\n/**/\n    4343,\n/**/\n    4342,\n/**/\n    4341,\n/**/\n    4340,\n/**/\n    4339,\n/**/\n    4338,\n/**/\n    4337,\n/**/\n    4336,\n/**/\n    4335,\n/**/\n    4334,\n/**/\n    4333,\n/**/\n    4332,\n/**/\n    4331,\n/**/\n    4330,\n/**/\n    4329,\n/**/\n    4328,\n/**/\n    4327,\n/**/\n    4326,\n/**/\n    4325,\n/**/\n    4324,\n/**/\n    4323,\n/**/\n    4322,\n/**/\n    4321,\n/**/\n    4320,\n/**/\n    4319,\n/**/\n    4318,\n/**/\n    4317,\n/**/\n    4316,\n/**/\n    4315,\n/**/\n    4314,\n/**/\n    4313,\n/**/\n    4312,\n/**/\n    4311,\n/**/\n    4310,\n/**/\n    4309,\n/**/\n    4308,\n/**/\n    4307,\n/**/\n    4306,\n/**/\n    4305,\n/**/\n    4304,\n/**/\n    4303,\n/**/\n    4302,\n/**/\n    4301,\n/**/\n    4300,\n/**/\n    4299,\n/**/\n    4298,\n/**/\n    4297,\n/**/\n    4296,\n/**/\n    4295,\n/**/\n    4294,\n/**/\n    4293,\n/**/\n    4292,\n/**/\n    4291,\n/**/\n    4290,\n/**/\n    4289,\n/**/\n    4288,\n/**/\n    4287,\n/**/\n    4286,\n/**/\n    4285,\n/**/\n    4284,\n/**/\n    4283,\n/**/\n    4282,\n/**/\n    4281,\n/**/\n    4280,\n/**/\n    4279,\n/**/\n    4278,\n/**/\n    4277,\n/**/\n    4276,\n/**/\n    4275,\n/**/\n    4274,\n/**/\n    4273,\n/**/\n    4272,\n/**/\n    4271,\n/**/\n    4270,\n/**/\n    4269,\n/**/\n    4268,\n/**/\n    4267,\n/**/\n    4266,\n/**/\n    4265,\n/**/\n    4264,\n/**/\n    4263,\n/**/\n    4262,\n/**/\n    4261,\n/**/\n    4260,\n/**/\n    4259,\n/**/\n    4258,\n/**/\n    4257,\n/**/\n    4256,\n/**/\n    4255,\n/**/\n    4254,\n/**/\n    4253,\n/**/\n    4252,\n/**/\n    4251,\n/**/\n    4250,\n/**/\n    4249,\n/**/\n    4248,\n/**/\n    4247,\n/**/\n    4246,\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * eval.c: Expression evaluation.\n */\n#define USING_FLOAT_STUFF\n\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n#ifdef VMS\n# include <float.h>\n#endif\n\n#define NAMESPACE_CHAR\t(char_u *)\"abglstvw\"\n\n/*\n * When recursively copying lists and dicts we need to remember which ones we\n * have done to avoid endless recursiveness.  This unique ID is used for that.\n * The last bit is used for previous_funccal, ignored when comparing.\n */\nstatic int current_copyID = 0;\n\n/*\n * Info used by a \":for\" loop.\n */\ntypedef struct\n{\n    int\t\tfi_semicolon;\t// TRUE if ending in '; var]'\n    int\t\tfi_varcount;\t// nr of variables in the list\n    int\t\tfi_break_count;\t// nr of line breaks encountered\n    listwatch_T\tfi_lw;\t\t// keep an eye on the item used.\n    list_T\t*fi_list;\t// list being used\n    int\t\tfi_bi;\t\t// index of blob\n    blob_T\t*fi_blob;\t// blob being used\n    char_u\t*fi_string;\t// copy of string being used\n    int\t\tfi_byte_idx;\t// byte index in fi_string\n} forinfo_T;\n\nstatic int eval2(char_u **arg, typval_T *rettv, evalarg_T *evalarg);\nstatic int eval3(char_u **arg, typval_T *rettv, evalarg_T *evalarg);\nstatic int eval4(char_u **arg, typval_T *rettv, evalarg_T *evalarg);\nstatic int eval5(char_u **arg, typval_T *rettv, evalarg_T *evalarg);\nstatic int eval6(char_u **arg, typval_T *rettv, evalarg_T *evalarg);\nstatic int eval7(char_u **arg, typval_T *rettv, evalarg_T *evalarg, int want_string);\nstatic int eval8(char_u **arg, typval_T *rettv, evalarg_T *evalarg, int want_string);\nstatic int eval9(char_u **arg, typval_T *rettv, evalarg_T *evalarg, int want_string);\nstatic int eval9_leader(typval_T *rettv, int numeric_only, char_u *start_leader, char_u **end_leaderp);\n\nstatic int free_unref_items(int copyID);\nstatic char_u *make_expanded_name(char_u *in_start, char_u *expr_start, char_u *expr_end, char_u *in_end);\n\n/*\n * Return \"n1\" divided by \"n2\", taking care of dividing by zero.\n * If \"failed\" is not NULL set it to TRUE when dividing by zero fails.\n */\n\tvarnumber_T\nnum_divide(varnumber_T n1, varnumber_T n2, int *failed)\n{\n    varnumber_T\tresult;\n\n    if (n2 == 0)\n    {\n\tif (in_vim9script())\n\t{\n\t    emsg(_(e_divide_by_zero));\n\t    if (failed != NULL)\n\t\t*failed = TRUE;\n\t}\n\tif (n1 == 0)\n\t    result = VARNUM_MIN; // similar to NaN\n\telse if (n1 < 0)\n\t    result = -VARNUM_MAX;\n\telse\n\t    result = VARNUM_MAX;\n    }\n    else\n\tresult = n1 / n2;\n\n    return result;\n}\n\n/*\n * Return \"n1\" modulus \"n2\", taking care of dividing by zero.\n * If \"failed\" is not NULL set it to TRUE when dividing by zero fails.\n */\n\tvarnumber_T\nnum_modulus(varnumber_T n1, varnumber_T n2, int *failed)\n{\n    if (n2 == 0 && in_vim9script())\n    {\n\temsg(_(e_divide_by_zero));\n\tif (failed != NULL)\n\t    *failed = TRUE;\n    }\n    return (n2 == 0) ? 0 : (n1 % n2);\n}\n\n/*\n * Initialize the global and v: variables.\n */\n    void\neval_init(void)\n{\n    evalvars_init();\n    func_init();\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\neval_clear(void)\n{\n    evalvars_clear();\n    free_scriptnames();  // must come after evalvars_clear().\n    free_locales();\n\n    // autoloaded script names\n    free_autoload_scriptnames();\n\n    // unreferenced lists and dicts\n    (void)garbage_collect(FALSE);\n\n    // functions not garbage collected\n    free_all_functions();\n}\n#endif\n\n    void\nfill_evalarg_from_eap(evalarg_T *evalarg, exarg_T *eap, int skip)\n{\n    init_evalarg(evalarg);\n    evalarg->eval_flags = skip ? 0 : EVAL_EVALUATE;\n    if (eap != NULL)\n    {\n\tevalarg->eval_cstack = eap->cstack;\n\tif (sourcing_a_script(eap) || eap->getline == get_list_line)\n\t{\n\t    evalarg->eval_getline = eap->getline;\n\t    evalarg->eval_cookie = eap->cookie;\n\t}\n    }\n}\n\n/*\n * Top level evaluation function, returning a boolean.\n * Sets \"error\" to TRUE if there was an error.\n * Return TRUE or FALSE.\n */\n    int\neval_to_bool(\n    char_u\t*arg,\n    int\t\t*error,\n    exarg_T\t*eap,\n    int\t\tskip)\t    // only parse, don't execute\n{\n    typval_T\ttv;\n    varnumber_T\tretval = FALSE;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, skip);\n\n    if (skip)\n\t++emsg_skip;\n    if (eval0(arg, &tv, eap, &evalarg) == FAIL)\n\t*error = TRUE;\n    else\n    {\n\t*error = FALSE;\n\tif (!skip)\n\t{\n\t    if (in_vim9script())\n\t\tretval = tv_get_bool_chk(&tv, error);\n\t    else\n\t\tretval = (tv_get_number_chk(&tv, error) != 0);\n\t    clear_tv(&tv);\n\t}\n    }\n    if (skip)\n\t--emsg_skip;\n    clear_evalarg(&evalarg, eap);\n\n    return (int)retval;\n}\n\n/*\n * Call eval1() and give an error message if not done at a lower level.\n */\n    static int\neval1_emsg(char_u **arg, typval_T *rettv, exarg_T *eap)\n{\n    char_u\t*start = *arg;\n    int\t\tret;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tcalled_emsg_before = called_emsg;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, eap != NULL && eap->skip);\n\n    ret = eval1(arg, rettv, &evalarg);\n    if (ret == FAIL)\n    {\n\t// Report the invalid expression unless the expression evaluation has\n\t// been cancelled due to an aborting error, an interrupt, or an\n\t// exception, or we already gave a more specific error.\n\t// Also check called_emsg for when using assert_fails().\n\tif (!aborting() && did_emsg == did_emsg_before\n\t\t\t\t\t  && called_emsg == called_emsg_before)\n\t    semsg(_(e_invalid_expression_str), start);\n    }\n    clear_evalarg(&evalarg, eap);\n    return ret;\n}\n\n/*\n * Return whether a typval is a valid expression to pass to eval_expr_typval()\n * or eval_expr_to_bool().  An empty string returns FALSE;\n */\n    int\neval_expr_valid_arg(typval_T *tv)\n{\n    return tv->v_type != VAR_UNKNOWN\n\t    && (tv->v_type != VAR_STRING\n\t\t  || (tv->vval.v_string != NULL && *tv->vval.v_string != NUL));\n}\n\n/*\n * Evaluate an expression, which can be a function, partial or string.\n * Pass arguments \"argv[argc]\".\n * Return the result in \"rettv\" and OK or FAIL.\n */\n    int\neval_expr_typval(typval_T *expr, typval_T *argv, int argc, typval_T *rettv)\n{\n    char_u\t*s;\n    char_u\tbuf[NUMBUFLEN];\n    funcexe_T\tfuncexe;\n\n    if (expr->v_type == VAR_FUNC)\n    {\n\ts = expr->vval.v_string;\n\tif (s == NULL || *s == NUL)\n\t    return FAIL;\n\tCLEAR_FIELD(funcexe);\n\tfuncexe.fe_evaluate = TRUE;\n\tif (call_func(s, -1, rettv, argc, argv, &funcexe) == FAIL)\n\t    return FAIL;\n    }\n    else if (expr->v_type == VAR_PARTIAL)\n    {\n\tpartial_T   *partial = expr->vval.v_partial;\n\n\tif (partial == NULL)\n\t    return FAIL;\n\n\tif (partial->pt_func != NULL\n\t\t\t  && partial->pt_func->uf_def_status != UF_NOT_COMPILED)\n\t{\n\t    if (call_def_function(partial->pt_func, argc, argv,\n\t\t\t\t\t\t       partial, rettv) == FAIL)\n\t\treturn FAIL;\n\t}\n\telse\n\t{\n\t    s = partial_name(partial);\n\t    if (s == NULL || *s == NUL)\n\t\treturn FAIL;\n\t    CLEAR_FIELD(funcexe);\n\t    funcexe.fe_evaluate = TRUE;\n\t    funcexe.fe_partial = partial;\n\t    if (call_func(s, -1, rettv, argc, argv, &funcexe) == FAIL)\n\t\treturn FAIL;\n\t}\n    }\n    else if (expr->v_type == VAR_INSTR)\n    {\n\treturn exe_typval_instr(expr, rettv);\n    }\n    else\n    {\n\ts = tv_get_string_buf_chk_strict(expr, buf, in_vim9script());\n\tif (s == NULL)\n\t    return FAIL;\n\ts = skipwhite(s);\n\tif (eval1_emsg(&s, rettv, NULL) == FAIL)\n\t    return FAIL;\n\tif (*skipwhite(s) != NUL)  // check for trailing chars after expr\n\t{\n\t    clear_tv(rettv);\n\t    semsg(_(e_invalid_expression_str), s);\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n\n/*\n * Like eval_to_bool() but using a typval_T instead of a string.\n * Works for string, funcref and partial.\n */\n    int\neval_expr_to_bool(typval_T *expr, int *error)\n{\n    typval_T\trettv;\n    int\t\tres;\n\n    if (eval_expr_typval(expr, NULL, 0, &rettv) == FAIL)\n    {\n\t*error = TRUE;\n\treturn FALSE;\n    }\n    res = (tv_get_bool_chk(&rettv, error) != 0);\n    clear_tv(&rettv);\n    return res;\n}\n\n/*\n * Top level evaluation function, returning a string.  If \"skip\" is TRUE,\n * only parsing to \"nextcmd\" is done, without reporting errors.  Return\n * pointer to allocated memory, or NULL for failure or when \"skip\" is TRUE.\n */\n    char_u *\neval_to_string_skip(\n    char_u\t*arg,\n    exarg_T\t*eap,\n    int\t\tskip)\t    // only parse, don't execute\n{\n    typval_T\ttv;\n    char_u\t*retval;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, skip);\n    if (skip)\n\t++emsg_skip;\n    if (eval0(arg, &tv, eap, &evalarg) == FAIL || skip)\n\tretval = NULL;\n    else\n    {\n\tretval = vim_strsave(tv_get_string(&tv));\n\tclear_tv(&tv);\n    }\n    if (skip)\n\t--emsg_skip;\n    clear_evalarg(&evalarg, eap);\n\n    return retval;\n}\n\n/*\n * Skip over an expression at \"*pp\".\n * Return FAIL for an error, OK otherwise.\n */\n    int\nskip_expr(char_u **pp, evalarg_T *evalarg)\n{\n    typval_T\trettv;\n\n    *pp = skipwhite(*pp);\n    return eval1(pp, &rettv, evalarg);\n}\n\n/*\n * Skip over an expression at \"*arg\".\n * If in Vim9 script and line breaks are encountered, the lines are\n * concatenated.  \"evalarg->eval_tofree\" will be set accordingly.\n * \"arg\" is advanced to just after the expression.\n * \"start\" is set to the start of the expression, \"end\" to just after the end.\n * Also when the expression is copied to allocated memory.\n * Return FAIL for an error, OK otherwise.\n */\n    int\nskip_expr_concatenate(\n\tchar_u\t    **arg,\n\tchar_u\t    **start,\n\tchar_u\t    **end,\n\tevalarg_T   *evalarg)\n{\n    typval_T\trettv;\n    int\t\tres;\n    int\t\tvim9script = in_vim9script();\n    garray_T    *gap = evalarg == NULL ? NULL : &evalarg->eval_ga;\n    garray_T    *freegap = evalarg == NULL ? NULL : &evalarg->eval_freega;\n    int\t\tsave_flags = evalarg == NULL ? 0 : evalarg->eval_flags;\n    int\t\tevaluate = evalarg == NULL\n\t\t\t       ? FALSE : (evalarg->eval_flags & EVAL_EVALUATE);\n\n    if (vim9script && evaluate\n\t       && (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL))\n    {\n\tga_init2(gap, sizeof(char_u *), 10);\n\t// leave room for \"start\"\n\tif (ga_grow(gap, 1) == OK)\n\t    ++gap->ga_len;\n\tga_init2(freegap, sizeof(char_u *), 10);\n    }\n    *start = *arg;\n\n    // Don't evaluate the expression.\n    if (evalarg != NULL)\n\tevalarg->eval_flags &= ~EVAL_EVALUATE;\n    *arg = skipwhite(*arg);\n    res = eval1(arg, &rettv, evalarg);\n    *end = *arg;\n    if (evalarg != NULL)\n\tevalarg->eval_flags = save_flags;\n\n    if (vim9script && evaluate\n\t    && (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL))\n    {\n\tif (evalarg->eval_ga.ga_len == 1)\n\t{\n\t    // just the one line, no need to concatenate\n\t    ga_clear(gap);\n\t    gap->ga_itemsize = 0;\n\t}\n\telse\n\t{\n\t    char_u\t    *p;\n\t    size_t\t    endoff = STRLEN(*arg);\n\n\t    // Line breaks encountered, concatenate all the lines.\n\t    *((char_u **)gap->ga_data) = *start;\n\t    p = ga_concat_strings(gap, \" \");\n\n\t    // free the lines only when using getsourceline()\n\t    if (evalarg->eval_cookie != NULL)\n\t    {\n\t\t// Do not free the first line, the caller can still use it.\n\t\t*((char_u **)gap->ga_data) = NULL;\n\t\t// Do not free the last line, \"arg\" points into it, free it\n\t\t// later.\n\t\tvim_free(evalarg->eval_tofree);\n\t\tevalarg->eval_tofree =\n\t\t\t\t    ((char_u **)gap->ga_data)[gap->ga_len - 1];\n\t\t((char_u **)gap->ga_data)[gap->ga_len - 1] = NULL;\n\t\tga_clear_strings(gap);\n\t    }\n\t    else\n\t    {\n\t\tga_clear(gap);\n\n\t\t// free lines that were explicitly marked for freeing\n\t\tga_clear_strings(freegap);\n\t    }\n\n\t    gap->ga_itemsize = 0;\n\t    if (p == NULL)\n\t\treturn FAIL;\n\t    *start = p;\n\t    vim_free(evalarg->eval_tofree_lambda);\n\t    evalarg->eval_tofree_lambda = p;\n\t    // Compute \"end\" relative to the end.\n\t    *end = *start + STRLEN(*start) - endoff;\n\t}\n    }\n\n    return res;\n}\n\n/*\n * Convert \"tv\" to a string.\n * When \"convert\" is TRUE convert a List into a sequence of lines and convert\n * a Float to a String.\n * Returns an allocated string (NULL when out of memory).\n */\n    char_u *\ntypval2string(typval_T *tv, int convert)\n{\n    garray_T\tga;\n    char_u\t*retval;\n#ifdef FEAT_FLOAT\n    char_u\tnumbuf[NUMBUFLEN];\n#endif\n\n    if (convert && tv->v_type == VAR_LIST)\n    {\n\tga_init2(&ga, sizeof(char), 80);\n\tif (tv->vval.v_list != NULL)\n\t{\n\t    list_join(&ga, tv->vval.v_list, (char_u *)\"\\n\", TRUE, FALSE, 0);\n\t    if (tv->vval.v_list->lv_len > 0)\n\t\tga_append(&ga, NL);\n\t}\n\tga_append(&ga, NUL);\n\tretval = (char_u *)ga.ga_data;\n    }\n#ifdef FEAT_FLOAT\n    else if (convert && tv->v_type == VAR_FLOAT)\n    {\n\tvim_snprintf((char *)numbuf, NUMBUFLEN, \"%g\", tv->vval.v_float);\n\tretval = vim_strsave(numbuf);\n    }\n#endif\n    else\n\tretval = vim_strsave(tv_get_string(tv));\n    return retval;\n}\n\n/*\n * Top level evaluation function, returning a string.  Does not handle line\n * breaks.\n * When \"convert\" is TRUE convert a List into a sequence of lines and convert\n * a Float to a String.\n * Return pointer to allocated memory, or NULL for failure.\n */\n    char_u *\neval_to_string_eap(\n    char_u\t*arg,\n    int\t\tconvert,\n    exarg_T\t*eap)\n{\n    typval_T\ttv;\n    char_u\t*retval;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, eap != NULL && eap->skip);\n    if (eval0(arg, &tv, NULL, &evalarg) == FAIL)\n\tretval = NULL;\n    else\n    {\n\tretval = typval2string(&tv, convert);\n\tclear_tv(&tv);\n    }\n    clear_evalarg(&evalarg, NULL);\n\n    return retval;\n}\n\n    char_u *\neval_to_string(\n    char_u\t*arg,\n    int\t\tconvert)\n{\n    return eval_to_string_eap(arg, convert, NULL);\n}\n\n/*\n * Call eval_to_string() without using current local variables and using\n * textlock.  When \"use_sandbox\" is TRUE use the sandbox.\n * Use legacy Vim script syntax.\n */\n    char_u *\neval_to_string_safe(\n    char_u\t*arg,\n    int\t\tuse_sandbox,\n    int\t\tkeep_script_version)\n{\n    char_u\t*retval;\n    funccal_entry_T funccal_entry;\n    int\t\tsave_sc_version = current_sctx.sc_version;\n    int\t\tsave_garbage = may_garbage_collect;\n\n    if (!keep_script_version)\n\tcurrent_sctx.sc_version = 1;\n    save_funccal(&funccal_entry);\n    if (use_sandbox)\n\t++sandbox;\n    ++textlock;\n    may_garbage_collect = FALSE;\n    retval = eval_to_string(arg, FALSE);\n    if (use_sandbox)\n\t--sandbox;\n    --textlock;\n    may_garbage_collect = save_garbage;\n    restore_funccal();\n    current_sctx.sc_version = save_sc_version;\n    return retval;\n}\n\n/*\n * Top level evaluation function, returning a number.\n * Evaluates \"expr\" silently.\n * Returns -1 for an error.\n */\n    varnumber_T\neval_to_number(char_u *expr)\n{\n    typval_T\trettv;\n    varnumber_T\tretval;\n    char_u\t*p = skipwhite(expr);\n\n    ++emsg_off;\n\n    if (eval1(&p, &rettv, &EVALARG_EVALUATE) == FAIL)\n\tretval = -1;\n    else\n    {\n\tretval = tv_get_number_chk(&rettv, NULL);\n\tclear_tv(&rettv);\n    }\n    --emsg_off;\n\n    return retval;\n}\n\n/*\n * Top level evaluation function.\n * Returns an allocated typval_T with the result.\n * Returns NULL when there is an error.\n */\n    typval_T *\neval_expr(char_u *arg, exarg_T *eap)\n{\n    typval_T\t*tv;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, eap != NULL && eap->skip);\n\n    tv = ALLOC_ONE(typval_T);\n    if (tv != NULL && eval0(arg, tv, eap, &evalarg) == FAIL)\n\tVIM_CLEAR(tv);\n\n    clear_evalarg(&evalarg, eap);\n    return tv;\n}\n\n/*\n * \"*arg\" points to what can be a function name in the form of \"import.Name\" or\n * \"Funcref\".  Return the name of the function.  Set \"tofree\" to something that\n * was allocated.\n * If \"verbose\" is FALSE no errors are given.\n * Return NULL for any failure.\n */\n    static char_u *\nderef_function_name(\n\t    char_u\t**arg,\n\t    char_u\t**tofree,\n\t    evalarg_T\t*evalarg,\n\t    int\t\tverbose)\n{\n    typval_T\tref;\n    char_u\t*name = *arg;\n\n    ref.v_type = VAR_UNKNOWN;\n    if (eval9(arg, &ref, evalarg, FALSE) == FAIL)\n    {\n\tdictitem_T\t*v;\n\n\t// If <SID>VarName was used it would not be found, try another way.\n\tv = find_var_also_in_script(name, NULL, FALSE);\n\tif (v == NULL)\n\t    return NULL;\n\tcopy_tv(&v->di_tv, &ref);\n    }\n    if (*skipwhite(*arg) != NUL)\n    {\n\tif (verbose)\n\t    semsg(_(e_trailing_characters_str), *arg);\n\tname = NULL;\n    }\n    else if (ref.v_type == VAR_FUNC && ref.vval.v_string != NULL)\n    {\n\tname = ref.vval.v_string;\n\tref.vval.v_string = NULL;\n\t*tofree = name;\n    }\n    else if (ref.v_type == VAR_PARTIAL && ref.vval.v_partial != NULL)\n    {\n\tif (ref.vval.v_partial->pt_argc > 0\n\t\t|| ref.vval.v_partial->pt_dict != NULL)\n\t{\n\t    if (verbose)\n\t\temsg(_(e_cannot_use_partial_here));\n\t    name = NULL;\n\t}\n\telse\n\t{\n\t    name = vim_strsave(partial_name(ref.vval.v_partial));\n\t    *tofree = name;\n\t}\n    }\n    else\n    {\n\tif (verbose)\n\t    semsg(_(e_not_callable_type_str), name);\n\tname = NULL;\n    }\n    clear_tv(&ref);\n    return name;\n}\n\n/*\n * Call some Vim script function and return the result in \"*rettv\".\n * Uses argv[0] to argv[argc - 1] for the function arguments.  argv[argc]\n * should have type VAR_UNKNOWN.\n * Returns OK or FAIL.\n */\n    int\ncall_vim_function(\n    char_u      *func,\n    int\t\targc,\n    typval_T\t*argv,\n    typval_T\t*rettv)\n{\n    int\t\tret;\n    funcexe_T\tfuncexe;\n    char_u\t*arg;\n    char_u\t*name;\n    char_u\t*tofree = NULL;\n    int\t\tignore_errors;\n\n    rettv->v_type = VAR_UNKNOWN;\t\t// clear_tv() uses this\n    CLEAR_FIELD(funcexe);\n    funcexe.fe_firstline = curwin->w_cursor.lnum;\n    funcexe.fe_lastline = curwin->w_cursor.lnum;\n    funcexe.fe_evaluate = TRUE;\n\n    // The name might be \"import.Func\" or \"Funcref\".  We don't know, we need to\n    // ignore errors for an undefined name.  But we do want errors when an\n    // autoload script has errors.  Guess that when there is a dot in the name\n    // showing errors is the right choice.\n    ignore_errors = vim_strchr(func, '.') == NULL;\n    arg = func;\n    if (ignore_errors)\n\t++emsg_off;\n    name = deref_function_name(&arg, &tofree, &EVALARG_EVALUATE, FALSE);\n    if (ignore_errors)\n\t--emsg_off;\n    if (name == NULL)\n\tname = func;\n\n    ret = call_func(name, -1, rettv, argc, argv, &funcexe);\n\n    if (ret == FAIL)\n\tclear_tv(rettv);\n    vim_free(tofree);\n\n    return ret;\n}\n\n/*\n * Call Vim script function \"func\" and return the result as a string.\n * Uses \"argv[0]\" to \"argv[argc - 1]\" for the function arguments. \"argv[argc]\"\n * should have type VAR_UNKNOWN.\n * Returns NULL when calling the function fails.\n */\n    void *\ncall_func_retstr(\n    char_u      *func,\n    int\t\targc,\n    typval_T\t*argv)\n{\n    typval_T\trettv;\n    char_u\t*retval;\n\n    if (call_vim_function(func, argc, argv, &rettv) == FAIL)\n\treturn NULL;\n\n    retval = vim_strsave(tv_get_string(&rettv));\n    clear_tv(&rettv);\n    return retval;\n}\n\n/*\n * Call Vim script function \"func\" and return the result as a List.\n * Uses \"argv\" and \"argc\" as call_func_retstr().\n * Returns NULL when there is something wrong.\n */\n    void *\ncall_func_retlist(\n    char_u      *func,\n    int\t\targc,\n    typval_T\t*argv)\n{\n    typval_T\trettv;\n\n    if (call_vim_function(func, argc, argv, &rettv) == FAIL)\n\treturn NULL;\n\n    if (rettv.v_type != VAR_LIST)\n    {\n\tclear_tv(&rettv);\n\treturn NULL;\n    }\n\n    return rettv.vval.v_list;\n}\n\n#if defined(FEAT_FOLDING) || defined(PROTO)\n/*\n * Evaluate \"arg\", which is 'foldexpr'.\n * Note: caller must set \"curwin\" to match \"arg\".\n * Returns the foldlevel, and any character preceding it in \"*cp\".  Doesn't\n * give error messages.\n */\n    int\neval_foldexpr(win_T *wp, int *cp)\n{\n    char_u\t*arg;\n    typval_T\ttv;\n    varnumber_T\tretval;\n    char_u\t*s;\n    sctx_T\tsaved_sctx = current_sctx;\n    int\t\tuse_sandbox = was_set_insecurely((char_u *)\"foldexpr\",\n\t\t\t\t\t\t\t\t   OPT_LOCAL);\n\n    arg = wp->w_p_fde;\n    current_sctx = wp->w_p_script_ctx[WV_FDE];\n\n    ++emsg_off;\n    if (use_sandbox)\n\t++sandbox;\n    ++textlock;\n    *cp = NUL;\n    if (eval0(arg, &tv, NULL, &EVALARG_EVALUATE) == FAIL)\n\tretval = 0;\n    else\n    {\n\t// If the result is a number, just return the number.\n\tif (tv.v_type == VAR_NUMBER)\n\t    retval = tv.vval.v_number;\n\telse if (tv.v_type != VAR_STRING || tv.vval.v_string == NULL)\n\t    retval = 0;\n\telse\n\t{\n\t    // If the result is a string, check if there is a non-digit before\n\t    // the number.\n\t    s = tv.vval.v_string;\n\t    if (!VIM_ISDIGIT(*s) && *s != '-')\n\t\t*cp = *s++;\n\t    retval = atol((char *)s);\n\t}\n\tclear_tv(&tv);\n    }\n    --emsg_off;\n    if (use_sandbox)\n\t--sandbox;\n    --textlock;\n    clear_evalarg(&EVALARG_EVALUATE, NULL);\n    current_sctx = saved_sctx;\n\n    return (int)retval;\n}\n#endif\n\n/*\n * Get an lval: variable, Dict item or List item that can be assigned a value\n * to: \"name\", \"na{me}\", \"name[expr]\", \"name[expr:expr]\", \"name[expr][expr]\",\n * \"name.key\", \"name.key[expr]\" etc.\n * Indexing only works if \"name\" is an existing List or Dictionary.\n * \"name\" points to the start of the name.\n * If \"rettv\" is not NULL it points to the value to be assigned.\n * \"unlet\" is TRUE for \":unlet\": slightly different behavior when something is\n * wrong; must end in space or cmd separator.\n *\n * flags:\n *  GLV_QUIET:       do not give error messages\n *  GLV_READ_ONLY:   will not change the variable\n *  GLV_NO_AUTOLOAD: do not use script autoloading\n *\n * Returns a pointer to just after the name, including indexes.\n * When an evaluation error occurs \"lp->ll_name\" is NULL;\n * Returns NULL for a parsing error.  Still need to free items in \"lp\"!\n */\n    char_u *\nget_lval(\n    char_u\t*name,\n    typval_T\t*rettv,\n    lval_T\t*lp,\n    int\t\tunlet,\n    int\t\tskip,\n    int\t\tflags,\t    // GLV_ values\n    int\t\tfne_flags)  // flags for find_name_end()\n{\n    char_u\t*p;\n    char_u\t*expr_start, *expr_end;\n    int\t\tcc;\n    dictitem_T\t*v;\n    typval_T\tvar1;\n    typval_T\tvar2;\n    int\t\tempty1 = FALSE;\n    char_u\t*key = NULL;\n    int\t\tlen;\n    hashtab_T\t*ht = NULL;\n    int\t\tquiet = flags & GLV_QUIET;\n    int\t\twriting;\n    int\t\tvim9script = in_vim9script();\n\n    // Clear everything in \"lp\".\n    CLEAR_POINTER(lp);\n\n    if (skip || (flags & GLV_COMPILING))\n    {\n\t// When skipping or compiling just find the end of the name.\n\tlp->ll_name = name;\n\tlp->ll_name_end = find_name_end(name, NULL, NULL,\n\t\t\t\t\t\t      FNE_INCL_BR | fne_flags);\n\treturn lp->ll_name_end;\n    }\n\n    // Cannot use \"s:var\" at the Vim9 script level.  \"s: type\" is OK.\n    if (vim9script && at_script_level()\n\t\t  && name[0] == 's' && name[1] == ':' && !VIM_ISWHITE(name[2]))\n    {\n\tsemsg(_(e_cannot_use_s_colon_in_vim9_script_str), name);\n\treturn NULL;\n    }\n\n    // Find the end of the name.\n    p = find_name_end(name, &expr_start, &expr_end, fne_flags);\n    lp->ll_name_end = p;\n    if (expr_start != NULL)\n    {\n\t// Don't expand the name when we already know there is an error.\n\tif (unlet && !VIM_ISWHITE(*p) && !ends_excmd(*p)\n\t\t\t\t\t\t    && *p != '[' && *p != '.')\n\t{\n\t    semsg(_(e_trailing_characters_str), p);\n\t    return NULL;\n\t}\n\n\tlp->ll_exp_name = make_expanded_name(name, expr_start, expr_end, p);\n\tif (lp->ll_exp_name == NULL)\n\t{\n\t    // Report an invalid expression in braces, unless the\n\t    // expression evaluation has been cancelled due to an\n\t    // aborting error, an interrupt, or an exception.\n\t    if (!aborting() && !quiet)\n\t    {\n\t\temsg_severe = TRUE;\n\t\tsemsg(_(e_invalid_argument_str), name);\n\t\treturn NULL;\n\t    }\n\t}\n\tlp->ll_name = lp->ll_exp_name;\n    }\n    else\n    {\n\tlp->ll_name = name;\n\n\tif (vim9script)\n\t{\n\t    // \"a: type\" is declaring variable \"a\" with a type, not \"a:\".\n\t    // However, \"g:[key]\" is indexing a dictionary.\n\t    if (p == name + 2 && p[-1] == ':' && *p != '[')\n\t    {\n\t\t--p;\n\t\tlp->ll_name_end = p;\n\t    }\n\t    if (*p == ':')\n\t    {\n\t\tchar_u\t    *tp = skipwhite(p + 1);\n\n\t\tif (tp == p + 1 && !quiet)\n\t\t{\n\t\t    semsg(_(e_white_space_required_after_str_str), \":\", p);\n\t\t    return NULL;\n\t\t}\n\n\t\tif (!SCRIPT_ID_VALID(current_sctx.sc_sid))\n\t\t{\n\t\t    semsg(_(e_using_type_not_in_script_context_str), p);\n\t\t    return NULL;\n\t\t}\n\n\t\t// parse the type after the name\n\t\tlp->ll_type = parse_type(&tp,\n\t\t\t       &SCRIPT_ITEM(current_sctx.sc_sid)->sn_type_list,\n\t\t\t       !quiet);\n\t\tif (lp->ll_type == NULL && !quiet)\n\t\t    return NULL;\n\t\tlp->ll_name_end = tp;\n\t    }\n\t}\n    }\n    if (lp->ll_name == NULL)\n\treturn p;\n\n    if (*p == '.')\n    {\n\timported_T *import = find_imported(lp->ll_name, p - lp->ll_name, TRUE);\n\n\tif (import != NULL)\n\t{\n\t    ufunc_T *ufunc;\n\t    type_T *type;\n\n\t    lp->ll_sid = import->imp_sid;\n\t    lp->ll_name = skipwhite(p + 1);\n\t    p = find_name_end(lp->ll_name, NULL, NULL, fne_flags);\n\t    lp->ll_name_end = p;\n\n\t    // check the item is exported\n\t    cc = *p;\n\t    *p = NUL;\n\t    if (find_exported(import->imp_sid, lp->ll_name, &ufunc, &type,\n\t\t\t\t\t\t       NULL, NULL, TRUE) == -1)\n\t    {\n\t\t*p = cc;\n\t\treturn NULL;\n\t    }\n\t    *p = cc;\n\t}\n    }\n\n    // Without [idx] or .key we are done.\n    if ((*p != '[' && *p != '.'))\n\treturn p;\n\n    if (vim9script && lval_root != NULL)\n    {\n\t// using local variable\n\tlp->ll_tv = lval_root;\n\tv = NULL;\n    }\n    else\n    {\n\tcc = *p;\n\t*p = NUL;\n\t// When we would write to the variable pass &ht and prevent autoload.\n\twriting = !(flags & GLV_READ_ONLY);\n\tv = find_var(lp->ll_name, writing ? &ht : NULL,\n\t\t\t\t\t (flags & GLV_NO_AUTOLOAD) || writing);\n\tif (v == NULL && !quiet)\n\t    semsg(_(e_undefined_variable_str), lp->ll_name);\n\t*p = cc;\n\tif (v == NULL)\n\t    return NULL;\n\tlp->ll_tv = &v->di_tv;\n    }\n\n    if (vim9script && (flags & GLV_NO_DECL) == 0)\n    {\n\tif (!quiet)\n\t    semsg(_(e_variable_already_declared), lp->ll_name);\n\treturn NULL;\n    }\n\n    /*\n     * Loop until no more [idx] or .key is following.\n     */\n    var1.v_type = VAR_UNKNOWN;\n    var2.v_type = VAR_UNKNOWN;\n    while (*p == '[' || (*p == '.' && p[1] != '=' && p[1] != '.'))\n    {\n\tif (*p == '.' && lp->ll_tv->v_type != VAR_DICT)\n\t{\n\t    if (!quiet)\n\t\tsemsg(_(e_dot_can_only_be_used_on_dictionary_str), name);\n\t    return NULL;\n\t}\n\tif (lp->ll_tv->v_type != VAR_LIST\n\t\t&& lp->ll_tv->v_type != VAR_DICT\n\t\t&& lp->ll_tv->v_type != VAR_BLOB)\n\t{\n\t    if (!quiet)\n\t\temsg(_(e_can_only_index_list_dictionary_or_blob));\n\t    return NULL;\n\t}\n\n\t// a NULL list/blob works like an empty list/blob, allocate one now.\n\tif (lp->ll_tv->v_type == VAR_LIST && lp->ll_tv->vval.v_list == NULL)\n\t    rettv_list_alloc(lp->ll_tv);\n\telse if (lp->ll_tv->v_type == VAR_BLOB\n\t\t\t\t\t     && lp->ll_tv->vval.v_blob == NULL)\n\t    rettv_blob_alloc(lp->ll_tv);\n\n\tif (lp->ll_range)\n\t{\n\t    if (!quiet)\n\t\temsg(_(e_slice_must_come_last));\n\t    return NULL;\n\t}\n\n\tif (vim9script && lp->ll_valtype == NULL\n\t\t&& v != NULL\n\t\t&& lp->ll_tv == &v->di_tv\n\t\t&& ht != NULL && ht == get_script_local_ht())\n\t{\n\t    svar_T  *sv = find_typval_in_script(lp->ll_tv, 0, TRUE);\n\n\t    // Vim9 script local variable: get the type\n\t    if (sv != NULL)\n\t\tlp->ll_valtype = sv->sv_type;\n\t}\n\n\tlen = -1;\n\tif (*p == '.')\n\t{\n\t    key = p + 1;\n\t    for (len = 0; ASCII_ISALNUM(key[len]) || key[len] == '_'; ++len)\n\t\t;\n\t    if (len == 0)\n\t    {\n\t\tif (!quiet)\n\t\t    emsg(_(e_cannot_use_empty_key_for_dictionary));\n\t\treturn NULL;\n\t    }\n\t    p = key + len;\n\t}\n\telse\n\t{\n\t    // Get the index [expr] or the first index [expr: ].\n\t    p = skipwhite(p + 1);\n\t    if (*p == ':')\n\t\tempty1 = TRUE;\n\t    else\n\t    {\n\t\tempty1 = FALSE;\n\t\tif (eval1(&p, &var1, &EVALARG_EVALUATE) == FAIL)  // recursive!\n\t\t    return NULL;\n\t\tif (tv_get_string_chk(&var1) == NULL)\n\t\t{\n\t\t    // not a number or string\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t\tp = skipwhite(p);\n\t    }\n\n\t    // Optionally get the second index [ :expr].\n\t    if (*p == ':')\n\t    {\n\t\tif (lp->ll_tv->v_type == VAR_DICT)\n\t\t{\n\t\t    if (!quiet)\n\t\t\temsg(_(e_cannot_slice_dictionary));\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t\tif (rettv != NULL\n\t\t\t&& !(rettv->v_type == VAR_LIST\n\t\t\t\t\t\t && rettv->vval.v_list != NULL)\n\t\t\t&& !(rettv->v_type == VAR_BLOB\n\t\t\t\t\t\t&& rettv->vval.v_blob != NULL))\n\t\t{\n\t\t    if (!quiet)\n\t\t\temsg(_(e_slice_requires_list_or_blob_value));\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t\tp = skipwhite(p + 1);\n\t\tif (*p == ']')\n\t\t    lp->ll_empty2 = TRUE;\n\t\telse\n\t\t{\n\t\t    lp->ll_empty2 = FALSE;\n\t\t    // recursive!\n\t\t    if (eval1(&p, &var2, &EVALARG_EVALUATE) == FAIL)\n\t\t    {\n\t\t\tclear_tv(&var1);\n\t\t\treturn NULL;\n\t\t    }\n\t\t    if (tv_get_string_chk(&var2) == NULL)\n\t\t    {\n\t\t\t// not a number or string\n\t\t\tclear_tv(&var1);\n\t\t\tclear_tv(&var2);\n\t\t\treturn NULL;\n\t\t    }\n\t\t}\n\t\tlp->ll_range = TRUE;\n\t    }\n\t    else\n\t\tlp->ll_range = FALSE;\n\n\t    if (*p != ']')\n\t    {\n\t\tif (!quiet)\n\t\t    emsg(_(e_missing_closing_square_brace));\n\t\tclear_tv(&var1);\n\t\tclear_tv(&var2);\n\t\treturn NULL;\n\t    }\n\n\t    // Skip to past ']'.\n\t    ++p;\n\t}\n\n\tif (lp->ll_tv->v_type == VAR_DICT)\n\t{\n\t    if (len == -1)\n\t    {\n\t\t// \"[key]\": get key from \"var1\"\n\t\tkey = tv_get_string_chk(&var1);\t// is number or string\n\t\tif (key == NULL)\n\t\t{\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t    }\n\t    lp->ll_list = NULL;\n\n\t    // a NULL dict is equivalent with an empty dict\n\t    if (lp->ll_tv->vval.v_dict == NULL)\n\t    {\n\t\tlp->ll_tv->vval.v_dict = dict_alloc();\n\t\tif (lp->ll_tv->vval.v_dict == NULL)\n\t\t{\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t\t++lp->ll_tv->vval.v_dict->dv_refcount;\n\t    }\n\t    lp->ll_dict = lp->ll_tv->vval.v_dict;\n\n\t    lp->ll_di = dict_find(lp->ll_dict, key, len);\n\n\t    // When assigning to a scope dictionary check that a function and\n\t    // variable name is valid (only variable name unless it is l: or\n\t    // g: dictionary). Disallow overwriting a builtin function.\n\t    if (rettv != NULL && lp->ll_dict->dv_scope != 0)\n\t    {\n\t\tint prevval;\n\t\tint wrong;\n\n\t\tif (len != -1)\n\t\t{\n\t\t    prevval = key[len];\n\t\t    key[len] = NUL;\n\t\t}\n\t\telse\n\t\t    prevval = 0; // avoid compiler warning\n\t\twrong = (lp->ll_dict->dv_scope == VAR_DEF_SCOPE\n\t\t\t       && rettv->v_type == VAR_FUNC\n\t\t\t       && var_wrong_func_name(key, lp->ll_di == NULL))\n\t\t\t|| !valid_varname(key, -1, TRUE);\n\t\tif (len != -1)\n\t\t    key[len] = prevval;\n\t\tif (wrong)\n\t\t{\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t    }\n\n\t    if (lp->ll_valtype != NULL)\n\t\t// use the type of the member\n\t\tlp->ll_valtype = lp->ll_valtype->tt_member;\n\n\t    if (lp->ll_di == NULL)\n\t    {\n\t\t// Can't add \"v:\" or \"a:\" variable.\n\t\tif (lp->ll_dict == get_vimvar_dict()\n\t\t\t || &lp->ll_dict->dv_hashtab == get_funccal_args_ht())\n\t\t{\n\t\t    semsg(_(e_illegal_variable_name_str), name);\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\n\t\t// Key does not exist in dict: may need to add it.\n\t\tif (*p == '[' || *p == '.' || unlet)\n\t\t{\n\t\t    if (!quiet)\n\t\t\tsemsg(_(e_key_not_present_in_dictionary), key);\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t\tif (len == -1)\n\t\t    lp->ll_newkey = vim_strsave(key);\n\t\telse\n\t\t    lp->ll_newkey = vim_strnsave(key, len);\n\t\tclear_tv(&var1);\n\t\tif (lp->ll_newkey == NULL)\n\t\t    p = NULL;\n\t\tbreak;\n\t    }\n\t    // existing variable, need to check if it can be changed\n\t    else if ((flags & GLV_READ_ONLY) == 0\n\t\t\t&& (var_check_ro(lp->ll_di->di_flags, name, FALSE)\n\t\t\t  || var_check_lock(lp->ll_di->di_flags, name, FALSE)))\n\t    {\n\t\tclear_tv(&var1);\n\t\treturn NULL;\n\t    }\n\n\t    clear_tv(&var1);\n\t    lp->ll_tv = &lp->ll_di->di_tv;\n\t}\n\telse if (lp->ll_tv->v_type == VAR_BLOB)\n\t{\n\t    long bloblen = blob_len(lp->ll_tv->vval.v_blob);\n\n\t    /*\n\t     * Get the number and item for the only or first index of the List.\n\t     */\n\t    if (empty1)\n\t\tlp->ll_n1 = 0;\n\t    else\n\t\t// is number or string\n\t\tlp->ll_n1 = (long)tv_get_number(&var1);\n\t    clear_tv(&var1);\n\n\t    if (check_blob_index(bloblen, lp->ll_n1, quiet) == FAIL)\n\t    {\n\t\tclear_tv(&var2);\n\t\treturn NULL;\n\t    }\n\t    if (lp->ll_range && !lp->ll_empty2)\n\t    {\n\t\tlp->ll_n2 = (long)tv_get_number(&var2);\n\t\tclear_tv(&var2);\n\t\tif (check_blob_range(bloblen, lp->ll_n1, lp->ll_n2, quiet)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\t    return NULL;\n\t    }\n\t    lp->ll_blob = lp->ll_tv->vval.v_blob;\n\t    lp->ll_tv = NULL;\n\t    break;\n\t}\n\telse\n\t{\n\t    /*\n\t     * Get the number and item for the only or first index of the List.\n\t     */\n\t    if (empty1)\n\t\tlp->ll_n1 = 0;\n\t    else\n\t\t// is number or string\n\t\tlp->ll_n1 = (long)tv_get_number(&var1);\n\t    clear_tv(&var1);\n\n\t    lp->ll_dict = NULL;\n\t    lp->ll_list = lp->ll_tv->vval.v_list;\n\t    lp->ll_li = check_range_index_one(lp->ll_list, &lp->ll_n1,\n\t\t\t\t     (flags & GLV_ASSIGN_WITH_OP) == 0, quiet);\n\t    if (lp->ll_li == NULL)\n\t    {\n\t\tclear_tv(&var2);\n\t\treturn NULL;\n\t    }\n\n\t    if (lp->ll_valtype != NULL)\n\t\t// use the type of the member\n\t\tlp->ll_valtype = lp->ll_valtype->tt_member;\n\n\t    /*\n\t     * May need to find the item or absolute index for the second\n\t     * index of a range.\n\t     * When no index given: \"lp->ll_empty2\" is TRUE.\n\t     * Otherwise \"lp->ll_n2\" is set to the second index.\n\t     */\n\t    if (lp->ll_range && !lp->ll_empty2)\n\t    {\n\t\tlp->ll_n2 = (long)tv_get_number(&var2);\n\t\t\t\t\t\t    // is number or string\n\t\tclear_tv(&var2);\n\t\tif (check_range_index_two(lp->ll_list,\n\t\t\t\t\t    &lp->ll_n1, lp->ll_li,\n\t\t\t\t\t    &lp->ll_n2, quiet) == FAIL)\n\t\t    return NULL;\n\t    }\n\n\t    lp->ll_tv = &lp->ll_li->li_tv;\n\t}\n    }\n\n    clear_tv(&var1);\n    lp->ll_name_end = p;\n    return p;\n}\n\n/*\n * Clear lval \"lp\" that was filled by get_lval().\n */\n    void\nclear_lval(lval_T *lp)\n{\n    vim_free(lp->ll_exp_name);\n    vim_free(lp->ll_newkey);\n}\n\n/*\n * Set a variable that was parsed by get_lval() to \"rettv\".\n * \"endp\" points to just after the parsed name.\n * \"op\" is NULL, \"+\" for \"+=\", \"-\" for \"-=\", \"*\" for \"*=\", \"/\" for \"/=\",\n * \"%\" for \"%=\", \".\" for \".=\" or \"=\" for \"=\".\n */\n    void\nset_var_lval(\n    lval_T\t*lp,\n    char_u\t*endp,\n    typval_T\t*rettv,\n    int\t\tcopy,\n    int\t\tflags,\t    // ASSIGN_CONST, ASSIGN_NO_DECL\n    char_u\t*op,\n    int\t\tvar_idx)    // index for \"let [a, b] = list\"\n{\n    int\t\tcc;\n    dictitem_T\t*di;\n\n    if (lp->ll_tv == NULL)\n    {\n\tcc = *endp;\n\t*endp = NUL;\n\tif (in_vim9script() && check_reserved_name(lp->ll_name) == FAIL)\n\t    return;\n\n\tif (lp->ll_blob != NULL)\n\t{\n\t    int\t    error = FALSE, val;\n\n\t    if (op != NULL && *op != '=')\n\t    {\n\t\tsemsg(_(e_wrong_variable_type_for_str_equal), op);\n\t\treturn;\n\t    }\n\t    if (value_check_lock(lp->ll_blob->bv_lock, lp->ll_name, FALSE))\n\t\treturn;\n\n\t    if (lp->ll_range && rettv->v_type == VAR_BLOB)\n\t    {\n\t\tif (lp->ll_empty2)\n\t\t    lp->ll_n2 = blob_len(lp->ll_blob) - 1;\n\n\t\tif (blob_set_range(lp->ll_blob, lp->ll_n1, lp->ll_n2,\n\t\t\t\t\t\t\t\trettv) == FAIL)\n\t\t    return;\n\t    }\n\t    else\n\t    {\n\t\tval = (int)tv_get_number_chk(rettv, &error);\n\t\tif (!error)\n\t\t    blob_set_append(lp->ll_blob, lp->ll_n1, val);\n\t    }\n\t}\n\telse if (op != NULL && *op != '=')\n\t{\n\t    typval_T tv;\n\n\t    if ((flags & (ASSIGN_CONST | ASSIGN_FINAL))\n\t\t\t\t\t     && (flags & ASSIGN_FOR_LOOP) == 0)\n\t    {\n\t\temsg(_(e_cannot_modify_existing_variable));\n\t\t*endp = cc;\n\t\treturn;\n\t    }\n\n\t    // handle +=, -=, *=, /=, %= and .=\n\t    di = NULL;\n\t    if (eval_variable(lp->ll_name, (int)STRLEN(lp->ll_name),\n\t\t\t\t lp->ll_sid, &tv, &di, EVAL_VAR_VERBOSE) == OK)\n\t    {\n\t\tif ((di == NULL\n\t\t\t || (!var_check_ro(di->di_flags, lp->ll_name, FALSE)\n\t\t\t   && !tv_check_lock(&di->di_tv, lp->ll_name, FALSE)))\n\t\t\t&& tv_op(&tv, rettv, op) == OK)\n\t\t    set_var_const(lp->ll_name, lp->ll_sid, NULL, &tv, FALSE,\n\t\t\t\t\t\t\t    ASSIGN_NO_DECL, 0);\n\t\tclear_tv(&tv);\n\t    }\n\t}\n\telse\n\t{\n\t    if (lp->ll_type != NULL && check_typval_arg_type(lp->ll_type, rettv,\n\t\t\t\t\t\t\t      NULL, 0) == FAIL)\n\t\treturn;\n\t    set_var_const(lp->ll_name, lp->ll_sid, lp->ll_type, rettv, copy,\n\t\t\t\t\t\t\t       flags, var_idx);\n\t}\n\t*endp = cc;\n    }\n    else if (value_check_lock(lp->ll_newkey == NULL\n\t\t? lp->ll_tv->v_lock\n\t\t: lp->ll_tv->vval.v_dict->dv_lock, lp->ll_name, FALSE))\n\t;\n    else if (lp->ll_range)\n    {\n\tif ((flags & (ASSIGN_CONST | ASSIGN_FINAL))\n\t\t\t\t\t     && (flags & ASSIGN_FOR_LOOP) == 0)\n\t{\n\t    emsg(_(e_cannot_lock_range));\n\t    return;\n\t}\n\n\t(void)list_assign_range(lp->ll_list, rettv->vval.v_list,\n\t\t\t lp->ll_n1, lp->ll_n2, lp->ll_empty2, op, lp->ll_name);\n    }\n    else\n    {\n\t/*\n\t * Assign to a List or Dictionary item.\n\t */\n\tif ((flags & (ASSIGN_CONST | ASSIGN_FINAL))\n\t\t\t\t\t     && (flags & ASSIGN_FOR_LOOP) == 0)\n\t{\n\t    emsg(_(e_cannot_lock_list_or_dict));\n\t    return;\n\t}\n\n\tif (lp->ll_valtype != NULL\n\t\t    && check_typval_arg_type(lp->ll_valtype, rettv,\n\t\t\t\t\t\t\t      NULL, 0) == FAIL)\n\t    return;\n\n\tif (lp->ll_newkey != NULL)\n\t{\n\t    if (op != NULL && *op != '=')\n\t    {\n\t\tsemsg(_(e_key_not_present_in_dictionary), lp->ll_newkey);\n\t\treturn;\n\t    }\n\t    if (dict_wrong_func_name(lp->ll_tv->vval.v_dict, rettv,\n\t\t\t\t\t\t\t\tlp->ll_newkey))\n\t\treturn;\n\n\t    // Need to add an item to the Dictionary.\n\t    di = dictitem_alloc(lp->ll_newkey);\n\t    if (di == NULL)\n\t\treturn;\n\t    if (dict_add(lp->ll_tv->vval.v_dict, di) == FAIL)\n\t    {\n\t\tvim_free(di);\n\t\treturn;\n\t    }\n\t    lp->ll_tv = &di->di_tv;\n\t}\n\telse if (op != NULL && *op != '=')\n\t{\n\t    tv_op(lp->ll_tv, rettv, op);\n\t    return;\n\t}\n\telse\n\t    clear_tv(lp->ll_tv);\n\n\t/*\n\t * Assign the value to the variable or list item.\n\t */\n\tif (copy)\n\t    copy_tv(rettv, lp->ll_tv);\n\telse\n\t{\n\t    *lp->ll_tv = *rettv;\n\t    lp->ll_tv->v_lock = 0;\n\t    init_tv(rettv);\n\t}\n    }\n}\n\n/*\n * Handle \"tv1 += tv2\", \"tv1 -= tv2\", \"tv1 *= tv2\", \"tv1 /= tv2\", \"tv1 %= tv2\"\n * and \"tv1 .= tv2\"\n * Returns OK or FAIL.\n */\n    int\ntv_op(typval_T *tv1, typval_T *tv2, char_u *op)\n{\n    varnumber_T\tn;\n    char_u\tnumbuf[NUMBUFLEN];\n    char_u\t*s;\n    int\t\tfailed = FALSE;\n\n    // Can't do anything with a Funcref or Dict on the right.\n    // v:true and friends only work with \"..=\".\n    if (tv2->v_type != VAR_FUNC && tv2->v_type != VAR_DICT\n\t\t    && ((tv2->v_type != VAR_BOOL && tv2->v_type != VAR_SPECIAL)\n\t\t\t\t\t\t\t\t|| *op == '.'))\n    {\n\tswitch (tv1->v_type)\n\t{\n\t    case VAR_UNKNOWN:\n\t    case VAR_ANY:\n\t    case VAR_VOID:\n\t    case VAR_DICT:\n\t    case VAR_FUNC:\n\t    case VAR_PARTIAL:\n\t    case VAR_BOOL:\n\t    case VAR_SPECIAL:\n\t    case VAR_JOB:\n\t    case VAR_CHANNEL:\n\t    case VAR_INSTR:\n\t\tbreak;\n\n\t    case VAR_BLOB:\n\t\tif (*op != '+' || tv2->v_type != VAR_BLOB)\n\t\t    break;\n\t\t// BLOB += BLOB\n\t\tif (tv1->vval.v_blob != NULL && tv2->vval.v_blob != NULL)\n\t\t{\n\t\t    blob_T  *b1 = tv1->vval.v_blob;\n\t\t    blob_T  *b2 = tv2->vval.v_blob;\n\t\t    int\ti, len = blob_len(b2);\n\t\t    for (i = 0; i < len; i++)\n\t\t\tga_append(&b1->bv_ga, blob_get(b2, i));\n\t\t}\n\t\treturn OK;\n\n\t    case VAR_LIST:\n\t\tif (*op != '+' || tv2->v_type != VAR_LIST)\n\t\t    break;\n\t\t// List += List\n\t\tif (tv2->vval.v_list != NULL)\n\t\t{\n\t\t    if (tv1->vval.v_list == NULL)\n\t\t    {\n\t\t\ttv1->vval.v_list = tv2->vval.v_list;\n\t\t\t++tv1->vval.v_list->lv_refcount;\n\t\t    }\n\t\t    else\n\t\t\tlist_extend(tv1->vval.v_list, tv2->vval.v_list, NULL);\n\t\t}\n\t\treturn OK;\n\n\t    case VAR_NUMBER:\n\t    case VAR_STRING:\n\t\tif (tv2->v_type == VAR_LIST)\n\t\t    break;\n\t\tif (vim_strchr((char_u *)\"+-*/%\", *op) != NULL)\n\t\t{\n\t\t    // nr += nr , nr -= nr , nr *=nr , nr /= nr , nr %= nr\n\t\t    n = tv_get_number(tv1);\n#ifdef FEAT_FLOAT\n\t\t    if (tv2->v_type == VAR_FLOAT)\n\t\t    {\n\t\t\tfloat_T f = n;\n\n\t\t\tif (*op == '%')\n\t\t\t    break;\n\t\t\tswitch (*op)\n\t\t\t{\n\t\t\t    case '+': f += tv2->vval.v_float; break;\n\t\t\t    case '-': f -= tv2->vval.v_float; break;\n\t\t\t    case '*': f *= tv2->vval.v_float; break;\n\t\t\t    case '/': f /= tv2->vval.v_float; break;\n\t\t\t}\n\t\t\tclear_tv(tv1);\n\t\t\ttv1->v_type = VAR_FLOAT;\n\t\t\ttv1->vval.v_float = f;\n\t\t    }\n\t\t    else\n#endif\n\t\t    {\n\t\t\tswitch (*op)\n\t\t\t{\n\t\t\t    case '+': n += tv_get_number(tv2); break;\n\t\t\t    case '-': n -= tv_get_number(tv2); break;\n\t\t\t    case '*': n *= tv_get_number(tv2); break;\n\t\t\t    case '/': n = num_divide(n, tv_get_number(tv2),\n\t\t\t\t\t\t\t       &failed); break;\n\t\t\t    case '%': n = num_modulus(n, tv_get_number(tv2),\n\t\t\t\t\t\t\t       &failed); break;\n\t\t\t}\n\t\t\tclear_tv(tv1);\n\t\t\ttv1->v_type = VAR_NUMBER;\n\t\t\ttv1->vval.v_number = n;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (tv2->v_type == VAR_FLOAT)\n\t\t\tbreak;\n\n\t\t    // str .= str\n\t\t    s = tv_get_string(tv1);\n\t\t    s = concat_str(s, tv_get_string_buf(tv2, numbuf));\n\t\t    clear_tv(tv1);\n\t\t    tv1->v_type = VAR_STRING;\n\t\t    tv1->vval.v_string = s;\n\t\t}\n\t\treturn failed ? FAIL : OK;\n\n\t    case VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t\t{\n\t\t    float_T f;\n\n\t\t    if (*op == '%' || *op == '.'\n\t\t\t\t   || (tv2->v_type != VAR_FLOAT\n\t\t\t\t    && tv2->v_type != VAR_NUMBER\n\t\t\t\t    && tv2->v_type != VAR_STRING))\n\t\t\tbreak;\n\t\t    if (tv2->v_type == VAR_FLOAT)\n\t\t\tf = tv2->vval.v_float;\n\t\t    else\n\t\t\tf = tv_get_number(tv2);\n\t\t    switch (*op)\n\t\t    {\n\t\t\tcase '+': tv1->vval.v_float += f; break;\n\t\t\tcase '-': tv1->vval.v_float -= f; break;\n\t\t\tcase '*': tv1->vval.v_float *= f; break;\n\t\t\tcase '/': tv1->vval.v_float /= f; break;\n\t\t    }\n\t\t}\n#endif\n\t\treturn OK;\n\t}\n    }\n\n    semsg(_(e_wrong_variable_type_for_str_equal), op);\n    return FAIL;\n}\n\n/*\n * Evaluate the expression used in a \":for var in expr\" command.\n * \"arg\" points to \"var\".\n * Set \"*errp\" to TRUE for an error, FALSE otherwise;\n * Return a pointer that holds the info.  Null when there is an error.\n */\n    void *\neval_for_line(\n    char_u\t*arg,\n    int\t\t*errp,\n    exarg_T\t*eap,\n    evalarg_T\t*evalarg)\n{\n    forinfo_T\t*fi;\n    char_u\t*var_list_end;\n    char_u\t*expr;\n    typval_T\ttv;\n    list_T\t*l;\n    int\t\tskip = !(evalarg->eval_flags & EVAL_EVALUATE);\n\n    *errp = TRUE;\t// default: there is an error\n\n    fi = ALLOC_CLEAR_ONE(forinfo_T);\n    if (fi == NULL)\n\treturn NULL;\n\n    var_list_end = skip_var_list(arg, TRUE, &fi->fi_varcount,\n\t\t\t\t\t\t     &fi->fi_semicolon, FALSE);\n    if (var_list_end == NULL)\n\treturn fi;\n\n    expr = skipwhite_and_linebreak(var_list_end, evalarg);\n    if (expr[0] != 'i' || expr[1] != 'n'\n\t\t\t\t  || !(expr[2] == NUL || VIM_ISWHITE(expr[2])))\n    {\n\tif (in_vim9script() && *expr == ':' && expr != var_list_end)\n\t    semsg(_(e_no_white_space_allowed_before_colon_str), expr);\n\telse\n\t    emsg(_(e_missing_in_after_for));\n\treturn fi;\n    }\n\n    if (skip)\n\t++emsg_skip;\n    expr = skipwhite_and_linebreak(expr + 2, evalarg);\n    if (eval0(expr, &tv, eap, evalarg) == OK)\n    {\n\t*errp = FALSE;\n\tif (!skip)\n\t{\n\t    if (tv.v_type == VAR_LIST)\n\t    {\n\t\tl = tv.vval.v_list;\n\t\tif (l == NULL)\n\t\t{\n\t\t    // a null list is like an empty list: do nothing\n\t\t    clear_tv(&tv);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Need a real list here.\n\t\t    CHECK_LIST_MATERIALIZE(l);\n\n\t\t    // No need to increment the refcount, it's already set for\n\t\t    // the list being used in \"tv\".\n\t\t    fi->fi_list = l;\n\t\t    list_add_watch(l, &fi->fi_lw);\n\t\t    fi->fi_lw.lw_item = l->lv_first;\n\t\t}\n\t    }\n\t    else if (tv.v_type == VAR_BLOB)\n\t    {\n\t\tfi->fi_bi = 0;\n\t\tif (tv.vval.v_blob != NULL)\n\t\t{\n\t\t    typval_T btv;\n\n\t\t    // Make a copy, so that the iteration still works when the\n\t\t    // blob is changed.\n\t\t    blob_copy(tv.vval.v_blob, &btv);\n\t\t    fi->fi_blob = btv.vval.v_blob;\n\t\t}\n\t\tclear_tv(&tv);\n\t    }\n\t    else if (tv.v_type == VAR_STRING)\n\t    {\n\t\tfi->fi_byte_idx = 0;\n\t\tfi->fi_string = tv.vval.v_string;\n\t\ttv.vval.v_string = NULL;\n\t\tif (fi->fi_string == NULL)\n\t\t    fi->fi_string = vim_strsave((char_u *)\"\");\n\t    }\n\t    else\n\t    {\n\t\temsg(_(e_string_list_or_blob_required));\n\t\tclear_tv(&tv);\n\t    }\n\t}\n    }\n    if (skip)\n\t--emsg_skip;\n    fi->fi_break_count = evalarg->eval_break_count;\n\n    return fi;\n}\n\n/*\n * Used when looping over a :for line, skip the \"in expr\" part.\n */\n    void\nskip_for_lines(void *fi_void, evalarg_T *evalarg)\n{\n    forinfo_T\t*fi = (forinfo_T *)fi_void;\n    int\t\ti;\n\n    for (i = 0; i < fi->fi_break_count; ++i)\n\teval_next_line(NULL, evalarg);\n}\n\n/*\n * Use the first item in a \":for\" list.  Advance to the next.\n * Assign the values to the variable (list).  \"arg\" points to the first one.\n * Return TRUE when a valid item was found, FALSE when at end of list or\n * something wrong.\n */\n    int\nnext_for_item(void *fi_void, char_u *arg)\n{\n    forinfo_T\t*fi = (forinfo_T *)fi_void;\n    int\t\tresult;\n    int\t\tflag = ASSIGN_FOR_LOOP | (in_vim9script()\n\t\t\t ? (ASSIGN_FINAL\n\t\t\t     // first round: error if variable exists\n\t\t\t     | (fi->fi_bi == 0 ? 0 : ASSIGN_DECL)\n\t\t\t     | ASSIGN_NO_MEMBER_TYPE)\n\t\t\t : 0);\n    listitem_T\t*item;\n    int\t\tskip_assign = in_vim9script() && arg[0] == '_'\n\t\t\t\t\t\t      && !eval_isnamec(arg[1]);\n\n    if (fi->fi_blob != NULL)\n    {\n\ttypval_T\ttv;\n\n\tif (fi->fi_bi >= blob_len(fi->fi_blob))\n\t    return FALSE;\n\ttv.v_type = VAR_NUMBER;\n\ttv.v_lock = VAR_FIXED;\n\ttv.vval.v_number = blob_get(fi->fi_blob, fi->fi_bi);\n\t++fi->fi_bi;\n\tif (skip_assign)\n\t    return TRUE;\n\treturn ex_let_vars(arg, &tv, TRUE, fi->fi_semicolon,\n\t\t\t\t\t    fi->fi_varcount, flag, NULL) == OK;\n    }\n\n    if (fi->fi_string != NULL)\n    {\n\ttypval_T\ttv;\n\tint\t\tlen;\n\n\tlen = mb_ptr2len(fi->fi_string + fi->fi_byte_idx);\n\tif (len == 0)\n\t    return FALSE;\n\ttv.v_type = VAR_STRING;\n\ttv.v_lock = VAR_FIXED;\n\ttv.vval.v_string = vim_strnsave(fi->fi_string + fi->fi_byte_idx, len);\n\tfi->fi_byte_idx += len;\n\t++fi->fi_bi;\n\tif (skip_assign)\n\t    result = TRUE;\n\telse\n\t    result = ex_let_vars(arg, &tv, TRUE, fi->fi_semicolon,\n\t\t\t\t\t    fi->fi_varcount, flag, NULL) == OK;\n\tvim_free(tv.vval.v_string);\n\treturn result;\n    }\n\n    item = fi->fi_lw.lw_item;\n    if (item == NULL)\n\tresult = FALSE;\n    else\n    {\n\tfi->fi_lw.lw_item = item->li_next;\n\t++fi->fi_bi;\n\tif (skip_assign)\n\t    result = TRUE;\n\telse\n\t    result = (ex_let_vars(arg, &item->li_tv, TRUE, fi->fi_semicolon,\n\t\t\t\t\t   fi->fi_varcount, flag, NULL) == OK);\n    }\n    return result;\n}\n\n/*\n * Free the structure used to store info used by \":for\".\n */\n    void\nfree_for_info(void *fi_void)\n{\n    forinfo_T    *fi = (forinfo_T *)fi_void;\n\n    if (fi == NULL)\n\treturn;\n    if (fi->fi_list != NULL)\n    {\n\tlist_rem_watch(fi->fi_list, &fi->fi_lw);\n\tlist_unref(fi->fi_list);\n    }\n    else if (fi->fi_blob != NULL)\n\tblob_unref(fi->fi_blob);\n    else\n\tvim_free(fi->fi_string);\n    vim_free(fi);\n}\n\n    void\nset_context_for_expression(\n    expand_T\t*xp,\n    char_u\t*arg,\n    cmdidx_T\tcmdidx)\n{\n    int\t\thas_expr = cmdidx != CMD_let && cmdidx != CMD_var;\n    int\t\tc;\n    char_u\t*p;\n\n    if (cmdidx == CMD_let || cmdidx == CMD_var\n\t\t\t\t || cmdidx == CMD_const || cmdidx == CMD_final)\n    {\n\txp->xp_context = EXPAND_USER_VARS;\n\tif (vim_strpbrk(arg, (char_u *)\"\\\"'+-*/%.=!?~|&$([<>,#\") == NULL)\n\t{\n\t    // \":let var1 var2 ...\": find last space.\n\t    for (p = arg + STRLEN(arg); p >= arg; )\n\t    {\n\t\txp->xp_pattern = p;\n\t\tMB_PTR_BACK(arg, p);\n\t\tif (VIM_ISWHITE(*p))\n\t\t    break;\n\t    }\n\t    return;\n\t}\n    }\n    else\n\txp->xp_context = cmdidx == CMD_call ? EXPAND_FUNCTIONS\n\t\t\t\t\t\t\t  : EXPAND_EXPRESSION;\n    while ((xp->xp_pattern = vim_strpbrk(arg,\n\t\t\t\t  (char_u *)\"\\\"'+-*/%.=!?~|&$([<>,#\")) != NULL)\n    {\n\tc = *xp->xp_pattern;\n\tif (c == '&')\n\t{\n\t    c = xp->xp_pattern[1];\n\t    if (c == '&')\n\t    {\n\t\t++xp->xp_pattern;\n\t\txp->xp_context = has_expr ? EXPAND_EXPRESSION : EXPAND_NOTHING;\n\t    }\n\t    else if (c != ' ')\n\t    {\n\t\txp->xp_context = EXPAND_SETTINGS;\n\t\tif ((c == 'l' || c == 'g') && xp->xp_pattern[2] == ':')\n\t\t    xp->xp_pattern += 2;\n\n\t    }\n\t}\n\telse if (c == '$')\n\t{\n\t    // environment variable\n\t    xp->xp_context = EXPAND_ENV_VARS;\n\t}\n\telse if (c == '=')\n\t{\n\t    has_expr = TRUE;\n\t    xp->xp_context = EXPAND_EXPRESSION;\n\t}\n\telse if (c == '#'\n\t\t&& xp->xp_context == EXPAND_EXPRESSION)\n\t{\n\t    // Autoload function/variable contains '#'.\n\t    break;\n\t}\n\telse if ((c == '<' || c == '#')\n\t\t&& xp->xp_context == EXPAND_FUNCTIONS\n\t\t&& vim_strchr(xp->xp_pattern, '(') == NULL)\n\t{\n\t    // Function name can start with \"<SNR>\" and contain '#'.\n\t    break;\n\t}\n\telse if (has_expr)\n\t{\n\t    if (c == '\"')\t    // string\n\t    {\n\t\twhile ((c = *++xp->xp_pattern) != NUL && c != '\"')\n\t\t    if (c == '\\\\' && xp->xp_pattern[1] != NUL)\n\t\t\t++xp->xp_pattern;\n\t\txp->xp_context = EXPAND_NOTHING;\n\t    }\n\t    else if (c == '\\'')\t    // literal string\n\t    {\n\t\t// Trick: '' is like stopping and starting a literal string.\n\t\twhile ((c = *++xp->xp_pattern) != NUL && c != '\\'')\n\t\t    /* skip */ ;\n\t\txp->xp_context = EXPAND_NOTHING;\n\t    }\n\t    else if (c == '|')\n\t    {\n\t\tif (xp->xp_pattern[1] == '|')\n\t\t{\n\t\t    ++xp->xp_pattern;\n\t\t    xp->xp_context = EXPAND_EXPRESSION;\n\t\t}\n\t\telse\n\t\t    xp->xp_context = EXPAND_COMMANDS;\n\t    }\n\t    else\n\t\txp->xp_context = EXPAND_EXPRESSION;\n\t}\n\telse\n\t    // Doesn't look like something valid, expand as an expression\n\t    // anyway.\n\t    xp->xp_context = EXPAND_EXPRESSION;\n\targ = xp->xp_pattern;\n\tif (*arg != NUL)\n\t    while ((c = *++arg) != NUL && (c == ' ' || c == '\\t'))\n\t\t/* skip */ ;\n    }\n\n    // \":exe one two\" completes \"two\"\n    if ((cmdidx == CMD_execute\n\t\t|| cmdidx == CMD_echo\n\t\t|| cmdidx == CMD_echon\n\t\t|| cmdidx == CMD_echomsg)\n\t    && xp->xp_context == EXPAND_EXPRESSION)\n    {\n\tfor (;;)\n\t{\n\t    char_u *n = skiptowhite(arg);\n\n\t    if (n == arg || IS_WHITE_OR_NUL(*skipwhite(n)))\n\t\tbreak;\n\t    arg = skipwhite(n);\n\t}\n    }\n\n    xp->xp_pattern = arg;\n}\n\n/*\n * Return TRUE if \"pat\" matches \"text\".\n * Does not use 'cpo' and always uses 'magic'.\n */\n    int\npattern_match(char_u *pat, char_u *text, int ic)\n{\n    int\t\tmatches = FALSE;\n    char_u\t*save_cpo;\n    regmatch_T\tregmatch;\n\n    // avoid 'l' flag in 'cpoptions'\n    save_cpo = p_cpo;\n    p_cpo = empty_option;\n    regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);\n    if (regmatch.regprog != NULL)\n    {\n\tregmatch.rm_ic = ic;\n\tmatches = vim_regexec_nl(&regmatch, text, (colnr_T)0);\n\tvim_regfree(regmatch.regprog);\n    }\n    p_cpo = save_cpo;\n    return matches;\n}\n\n/*\n * Handle a name followed by \"(\".  Both for just \"name(arg)\" and for\n * \"expr->name(arg)\".\n * Returns OK or FAIL.\n */\n    static int\neval_func(\n\tchar_u\t    **arg,\t// points to \"(\", will be advanced\n\tevalarg_T   *evalarg,\n\tchar_u\t    *name,\n\tint\t    name_len,\n\ttypval_T    *rettv,\n\tint\t    flags,\n\ttypval_T    *basetv)\t// \"expr\" for \"expr->name(arg)\"\n{\n    int\t\tevaluate = flags & EVAL_EVALUATE;\n    char_u\t*s = name;\n    int\t\tlen = name_len;\n    partial_T\t*partial;\n    int\t\tret = OK;\n    type_T\t*type = NULL;\n    int\t\tfound_var = FALSE;\n\n    if (!evaluate)\n\tcheck_vars(s, len);\n\n    // If \"s\" is the name of a variable of type VAR_FUNC\n    // use its contents.\n    s = deref_func_name(s, &len, &partial,\n\t\t in_vim9script() ? &type : NULL, !evaluate, FALSE, &found_var);\n\n    // Need to make a copy, in case evaluating the arguments makes\n    // the name invalid.\n    s = vim_strsave(s);\n    if (s == NULL || (evaluate && (*s == NUL || (flags & EVAL_CONSTANT))))\n\tret = FAIL;\n    else\n    {\n\tfuncexe_T funcexe;\n\n\t// Invoke the function.\n\tCLEAR_FIELD(funcexe);\n\tfuncexe.fe_firstline = curwin->w_cursor.lnum;\n\tfuncexe.fe_lastline = curwin->w_cursor.lnum;\n\tfuncexe.fe_evaluate = evaluate;\n\tfuncexe.fe_partial = partial;\n\tfuncexe.fe_basetv = basetv;\n\tfuncexe.fe_check_type = type;\n\tfuncexe.fe_found_var = found_var;\n\tret = get_func_tv(s, len, rettv, arg, evalarg, &funcexe);\n    }\n    vim_free(s);\n\n    // If evaluate is FALSE rettv->v_type was not set in\n    // get_func_tv, but it's needed in handle_subscript() to parse\n    // what follows. So set it here.\n    if (rettv->v_type == VAR_UNKNOWN && !evaluate && **arg == '(')\n    {\n\trettv->vval.v_string = NULL;\n\trettv->v_type = VAR_FUNC;\n    }\n\n    // Stop the expression evaluation when immediately\n    // aborting on error, or when an interrupt occurred or\n    // an exception was thrown but not caught.\n    if (evaluate && aborting())\n    {\n\tif (ret == OK)\n\t    clear_tv(rettv);\n\tret = FAIL;\n    }\n    return ret;\n}\n\n/*\n * After a NL, skip over empty lines and comment-only lines.\n */\n    static char_u *\nnewline_skip_comments(char_u *arg)\n{\n    char_u *p = arg + 1;\n\n    for (;;)\n    {\n\tp = skipwhite(p);\n\n\tif (*p == NUL)\n\t    break;\n\tif (vim9_comment_start(p))\n\t{\n\t    char_u *nl = vim_strchr(p, NL);\n\n\t    if (nl == NULL)\n\t\t    break;\n\t    p = nl;\n\t}\n\tif (*p != NL)\n\t    break;\n\t++p;  // skip another NL\n    }\n    return p;\n}\n\n/*\n * Get the next line source line without advancing.  But do skip over comment\n * lines.\n * Only called for Vim9 script.\n */\n    static char_u *\ngetline_peek_skip_comments(evalarg_T *evalarg)\n{\n    for (;;)\n    {\n\tchar_u *next = getline_peek(evalarg->eval_getline,\n\t\t\t\t\t\t\t evalarg->eval_cookie);\n\tchar_u *p;\n\n\tif (next == NULL)\n\t    break;\n\tp = skipwhite(next);\n\tif (*p != NUL && !vim9_comment_start(p))\n\t    return next;\n\tif (eval_next_line(NULL, evalarg) == NULL)\n\t    break;\n    }\n    return NULL;\n}\n\n/*\n * If inside Vim9 script, \"arg\" points to the end of a line (ignoring a #\n * comment) and there is a next line, return the next line (skipping blanks)\n * and set \"getnext\".\n * Otherwise return the next non-white at or after \"arg\" and set \"getnext\" to\n * FALSE.\n * \"arg\" must point somewhere inside a line, not at the start.\n */\n    char_u *\neval_next_non_blank(char_u *arg, evalarg_T *evalarg, int *getnext)\n{\n    char_u *p = skipwhite(arg);\n\n    *getnext = FALSE;\n    if (in_vim9script()\n\t    && evalarg != NULL\n\t    && (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL\n\t\t\t\t\t\t\t\t   || *p == NL)\n\t    && (*p == NUL || *p == NL\n\t\t\t     || (vim9_comment_start(p) && VIM_ISWHITE(p[-1]))))\n    {\n\tchar_u *next;\n\n\tif (*p == NL)\n\t    next = newline_skip_comments(p);\n\telse if (evalarg->eval_cookie != NULL)\n\t    next = getline_peek_skip_comments(evalarg);\n\telse\n\t    next = peek_next_line_from_context(evalarg->eval_cctx);\n\n\tif (next != NULL)\n\t{\n\t    *getnext = TRUE;\n\t    return skipwhite(next);\n\t}\n    }\n    return p;\n}\n\n/*\n * To be called after eval_next_non_blank() sets \"getnext\" to TRUE.\n * Only called for Vim9 script.\n */\n    char_u *\neval_next_line(char_u *arg, evalarg_T *evalarg)\n{\n    garray_T\t*gap = &evalarg->eval_ga;\n    char_u\t*line;\n\n    if (arg != NULL)\n    {\n\tif (*arg == NL)\n\t    return newline_skip_comments(arg);\n\t// Truncate before a trailing comment, so that concatenating the lines\n\t// won't turn the rest into a comment.\n\tif (*skipwhite(arg) == '#')\n\t    *arg = NUL;\n    }\n\n    if (evalarg->eval_cookie != NULL)\n\tline = evalarg->eval_getline(0, evalarg->eval_cookie, 0,\n\t\t\t\t\t\t\t   GETLINE_CONCAT_ALL);\n    else\n\tline = next_line_from_context(evalarg->eval_cctx, TRUE);\n    if (line == NULL)\n\treturn NULL;\n\n    ++evalarg->eval_break_count;\n    if (gap->ga_itemsize > 0 && ga_grow(gap, 1) == OK)\n    {\n\tchar_u *p = skipwhite(line);\n\n\t// Going to concatenate the lines after parsing.  For an empty or\n\t// comment line use an empty string.\n\tif (*p == NUL || vim9_comment_start(p))\n\t{\n\t    vim_free(line);\n\t    line = vim_strsave((char_u *)\"\");\n\t}\n\n\t((char_u **)gap->ga_data)[gap->ga_len] = line;\n\t++gap->ga_len;\n    }\n    else if (evalarg->eval_cookie != NULL)\n    {\n\tvim_free(evalarg->eval_tofree);\n\tevalarg->eval_tofree = line;\n    }\n\n    // Advanced to the next line, \"arg\" no longer points into the previous\n    // line.\n    evalarg->eval_using_cmdline = FALSE;\n    return skipwhite(line);\n}\n\n/*\n * Call eval_next_non_blank() and get the next line if needed.\n */\n    char_u *\nskipwhite_and_linebreak(char_u *arg, evalarg_T *evalarg)\n{\n    int\t    getnext;\n    char_u  *p = skipwhite_and_nl(arg);\n\n    if (evalarg == NULL)\n\treturn skipwhite(arg);\n    eval_next_non_blank(p, evalarg, &getnext);\n    if (getnext)\n\treturn eval_next_line(arg, evalarg);\n    return p;\n}\n\n/*\n * Initialize \"evalarg\" for use.\n */\n    void\ninit_evalarg(evalarg_T *evalarg)\n{\n    CLEAR_POINTER(evalarg);\n    ga_init2(&evalarg->eval_tofree_ga, sizeof(char_u *), 20);\n}\n\n/*\n * After using \"evalarg\" filled from \"eap\": free the memory.\n */\n    void\nclear_evalarg(evalarg_T *evalarg, exarg_T *eap)\n{\n    if (evalarg != NULL)\n    {\n\tif (evalarg->eval_tofree != NULL)\n\t{\n\t    if (eap != NULL)\n\t    {\n\t\t// We may need to keep the original command line, e.g. for\n\t\t// \":let\" it has the variable names.  But we may also need the\n\t\t// new one, \"nextcmd\" points into it.  Keep both.\n\t\tvim_free(eap->cmdline_tofree);\n\t\teap->cmdline_tofree = *eap->cmdlinep;\n\t\t*eap->cmdlinep = evalarg->eval_tofree;\n\t    }\n\t    else\n\t\tvim_free(evalarg->eval_tofree);\n\t    evalarg->eval_tofree = NULL;\n\t}\n\n\tga_clear_strings(&evalarg->eval_tofree_ga);\n\tVIM_CLEAR(evalarg->eval_tofree_lambda);\n    }\n}\n\n/*\n * The \"evaluate\" argument: When FALSE, the argument is only parsed but not\n * executed.  The function may return OK, but the rettv will be of type\n * VAR_UNKNOWN.  The function still returns FAIL for a syntax error.\n */\n\n/*\n * Handle zero level expression.\n * This calls eval1() and handles error message and nextcmd.\n * Put the result in \"rettv\" when returning OK and \"evaluate\" is TRUE.\n * Note: \"rettv.v_lock\" is not set.\n * \"evalarg\" can be NULL, EVALARG_EVALUATE or a pointer.\n * Return OK or FAIL.\n */\n    int\neval0(\n    char_u\t*arg,\n    typval_T\t*rettv,\n    exarg_T\t*eap,\n    evalarg_T\t*evalarg)\n{\n    return eval0_retarg(arg, rettv, eap, evalarg, NULL);\n}\n\n/*\n * Like eval0() but when \"retarg\" is not NULL store the pointer to after the\n * expression and don't check what comes after the expression.\n */\n    int\neval0_retarg(\n    char_u\t*arg,\n    typval_T\t*rettv,\n    exarg_T\t*eap,\n    evalarg_T\t*evalarg,\n    char_u\t**retarg)\n{\n    int\t\tret;\n    char_u\t*p;\n    char_u\t*expr_end;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tcalled_emsg_before = called_emsg;\n    int\t\tflags = evalarg == NULL ? 0 : evalarg->eval_flags;\n    int\t\tcheck_for_end = retarg == NULL;\n    int\t\tend_error = FALSE;\n\n    p = skipwhite(arg);\n    ret = eval1(&p, rettv, evalarg);\n\n    if (ret != FAIL)\n    {\n\texpr_end = p;\n\tp = skipwhite(p);\n\n\t// In Vim9 script a command block is not split at NL characters for\n\t// commands using an expression argument.  Skip over a '#' comment to\n\t// check for a following NL.  Require white space before the '#'.\n\tif (in_vim9script() && p > expr_end && retarg == NULL)\n\t    while (*p == '#')\n\t    {\n\t\tchar_u *nl = vim_strchr(p, NL);\n\n\t\tif (nl == NULL)\n\t\t    break;\n\t\tp = skipwhite(nl + 1);\n\t\tif (eap != NULL && *p != NUL)\n\t\t    eap->nextcmd = p;\n\t\tcheck_for_end = FALSE;\n\t    }\n\n\tif (check_for_end)\n\t    end_error = !ends_excmd2(arg, p);\n    }\n\n    if (ret == FAIL || end_error)\n    {\n\tif (ret != FAIL)\n\t    clear_tv(rettv);\n\t/*\n\t * Report the invalid expression unless the expression evaluation has\n\t * been cancelled due to an aborting error, an interrupt, or an\n\t * exception, or we already gave a more specific error.\n\t * Also check called_emsg for when using assert_fails().\n\t */\n\tif (!aborting()\n\t\t&& did_emsg == did_emsg_before\n\t\t&& called_emsg == called_emsg_before\n\t\t&& (flags & EVAL_CONSTANT) == 0\n\t\t&& (!in_vim9script() || !vim9_bad_comment(p)))\n\t{\n\t    if (end_error)\n\t\tsemsg(_(e_trailing_characters_str), p);\n\t    else\n\t\tsemsg(_(e_invalid_expression_str), arg);\n\t}\n\n\t// Some of the expression may not have been consumed.  Do not check for\n\t// a next command to avoid more errors, unless \"|\" is following, which\n\t// could only be a command separator.\n\tif (eap != NULL && p != NULL\n\t\t\t  &&  skipwhite(p)[0] == '|' && skipwhite(p)[1] != '|')\n\t    eap->nextcmd = check_nextcmd(p);\n\treturn FAIL;\n    }\n\n    if (retarg != NULL)\n\t*retarg = p;\n    else if (check_for_end && eap != NULL)\n\tset_nextcmd(eap, p);\n\n    return ret;\n}\n\n/*\n * Handle top level expression:\n *\texpr2 ? expr1 : expr1\n *\texpr2 ?? expr1\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Note: \"rettv.v_lock\" is not set.\n *\n * Return OK or FAIL.\n */\n    int\neval1(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    char_u  *p;\n    int\t    getnext;\n\n    CLEAR_POINTER(rettv);\n\n    /*\n     * Get the first variable.\n     */\n    if (eval2(arg, rettv, evalarg) == FAIL)\n\treturn FAIL;\n\n    p = eval_next_non_blank(*arg, evalarg, &getnext);\n    if (*p == '?')\n    {\n\tint\t\top_falsy = p[1] == '?';\n\tint\t\tresult;\n\ttypval_T\tvar2;\n\tevalarg_T\t*evalarg_used = evalarg;\n\tevalarg_T\tlocal_evalarg;\n\tint\t\torig_flags;\n\tint\t\tevaluate;\n\tint\t\tvim9script = in_vim9script();\n\n\tif (evalarg == NULL)\n\t{\n\t    init_evalarg(&local_evalarg);\n\t    evalarg_used = &local_evalarg;\n\t}\n\torig_flags = evalarg_used->eval_flags;\n\tevaluate = evalarg_used->eval_flags & EVAL_EVALUATE;\n\n\tif (getnext)\n\t    *arg = eval_next_line(*arg, evalarg_used);\n\telse\n\t{\n\t    if (evaluate && vim9script && !VIM_ISWHITE(p[-1]))\n\t    {\n\t\terror_white_both(p, op_falsy ? 2 : 1);\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t    *arg = p;\n\t}\n\n\tresult = FALSE;\n\tif (evaluate)\n\t{\n\t    int\t\terror = FALSE;\n\n\t    if (op_falsy)\n\t\tresult = tv2bool(rettv);\n\t    else if (vim9script)\n\t\tresult = tv_get_bool_chk(rettv, &error);\n\t    else if (tv_get_number_chk(rettv, &error) != 0)\n\t\tresult = TRUE;\n\t    if (error || !op_falsy || !result)\n\t\tclear_tv(rettv);\n\t    if (error)\n\t\treturn FAIL;\n\t}\n\n\t/*\n\t * Get the second variable.  Recursive!\n\t */\n\tif (op_falsy)\n\t    ++*arg;\n\tif (evaluate && vim9script && !IS_WHITE_OR_NUL((*arg)[1]))\n\t{\n\t    error_white_both(*arg - (op_falsy ? 1 : 0), op_falsy ? 2 : 1);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite_and_linebreak(*arg + 1, evalarg_used);\n\tevalarg_used->eval_flags = (op_falsy ? !result : result)\n\t\t\t\t    ? orig_flags : orig_flags & ~EVAL_EVALUATE;\n\tif (eval1(arg, &var2, evalarg_used) == FAIL)\n\t{\n\t    evalarg_used->eval_flags = orig_flags;\n\t    return FAIL;\n\t}\n\tif (!op_falsy || !result)\n\t    *rettv = var2;\n\n\tif (!op_falsy)\n\t{\n\t    /*\n\t     * Check for the \":\".\n\t     */\n\t    p = eval_next_non_blank(*arg, evalarg_used, &getnext);\n\t    if (*p != ':')\n\t    {\n\t\temsg(_(e_missing_colon_after_questionmark));\n\t\tif (evaluate && result)\n\t\t    clear_tv(rettv);\n\t\tevalarg_used->eval_flags = orig_flags;\n\t\treturn FAIL;\n\t    }\n\t    if (getnext)\n\t\t*arg = eval_next_line(*arg, evalarg_used);\n\t    else\n\t    {\n\t\tif (evaluate && vim9script && !VIM_ISWHITE(p[-1]))\n\t\t{\n\t\t    error_white_both(p, 1);\n\t\t    clear_tv(rettv);\n\t\t    evalarg_used->eval_flags = orig_flags;\n\t\t    return FAIL;\n\t\t}\n\t\t*arg = p;\n\t    }\n\n\t    /*\n\t     * Get the third variable.  Recursive!\n\t     */\n\t    if (evaluate && vim9script && !IS_WHITE_OR_NUL((*arg)[1]))\n\t    {\n\t\terror_white_both(*arg, 1);\n\t\tclear_tv(rettv);\n\t\tevalarg_used->eval_flags = orig_flags;\n\t\treturn FAIL;\n\t    }\n\t    *arg = skipwhite_and_linebreak(*arg + 1, evalarg_used);\n\t    evalarg_used->eval_flags = !result ? orig_flags\n\t\t\t\t\t\t : orig_flags & ~EVAL_EVALUATE;\n\t    if (eval1(arg, &var2, evalarg_used) == FAIL)\n\t    {\n\t\tif (evaluate && result)\n\t\t    clear_tv(rettv);\n\t\tevalarg_used->eval_flags = orig_flags;\n\t\treturn FAIL;\n\t    }\n\t    if (evaluate && !result)\n\t\t*rettv = var2;\n\t}\n\n\tif (evalarg == NULL)\n\t    clear_evalarg(&local_evalarg, NULL);\n\telse\n\t    evalarg->eval_flags = orig_flags;\n    }\n\n    return OK;\n}\n\n/*\n * Handle first level expression:\n *\texpr2 || expr2 || expr2\t    logical OR\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval2(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    char_u\t*p;\n    int\t\tgetnext;\n\n    /*\n     * Get the first expression.\n     */\n    if (eval3(arg, rettv, evalarg) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Handle the  \"||\" operator.\n     */\n    p = eval_next_non_blank(*arg, evalarg, &getnext);\n    if (p[0] == '|' && p[1] == '|')\n    {\n\tevalarg_T   *evalarg_used = evalarg;\n\tevalarg_T   local_evalarg;\n\tint\t    evaluate;\n\tint\t    orig_flags;\n\tlong\t    result = FALSE;\n\ttypval_T    var2;\n\tint\t    error = FALSE;\n\tint\t    vim9script = in_vim9script();\n\n\tif (evalarg == NULL)\n\t{\n\t    init_evalarg(&local_evalarg);\n\t    evalarg_used = &local_evalarg;\n\t}\n\torig_flags = evalarg_used->eval_flags;\n\tevaluate = orig_flags & EVAL_EVALUATE;\n\tif (evaluate)\n\t{\n\t    if (vim9script)\n\t\tresult = tv_get_bool_chk(rettv, &error);\n\t    else if (tv_get_number_chk(rettv, &error) != 0)\n\t\tresult = TRUE;\n\t    clear_tv(rettv);\n\t    if (error)\n\t\treturn FAIL;\n\t}\n\n\t/*\n\t * Repeat until there is no following \"||\".\n\t */\n\twhile (p[0] == '|' && p[1] == '|')\n\t{\n\t    if (getnext)\n\t\t*arg = eval_next_line(*arg, evalarg_used);\n\t    else\n\t    {\n\t\tif (evaluate && vim9script && !VIM_ISWHITE(p[-1]))\n\t\t{\n\t\t    error_white_both(p, 2);\n\t\t    clear_tv(rettv);\n\t\t    return FAIL;\n\t\t}\n\t\t*arg = p;\n\t    }\n\n\t    /*\n\t     * Get the second variable.\n\t     */\n\t    if (evaluate && vim9script && !IS_WHITE_OR_NUL((*arg)[2]))\n\t    {\n\t\terror_white_both(*arg, 2);\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t    *arg = skipwhite_and_linebreak(*arg + 2, evalarg_used);\n\t    evalarg_used->eval_flags = !result ? orig_flags\n\t\t\t\t\t\t : orig_flags & ~EVAL_EVALUATE;\n\t    if (eval3(arg, &var2, evalarg_used) == FAIL)\n\t\treturn FAIL;\n\n\t    /*\n\t     * Compute the result.\n\t     */\n\t    if (evaluate && !result)\n\t    {\n\t\tif (vim9script)\n\t\t    result = tv_get_bool_chk(&var2, &error);\n\t\telse if (tv_get_number_chk(&var2, &error) != 0)\n\t\t    result = TRUE;\n\t\tclear_tv(&var2);\n\t\tif (error)\n\t\t    return FAIL;\n\t    }\n\t    if (evaluate)\n\t    {\n\t\tif (vim9script)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = result ? VVAL_TRUE : VVAL_FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rettv->v_type = VAR_NUMBER;\n\t\t    rettv->vval.v_number = result;\n\t\t}\n\t    }\n\n\t    p = eval_next_non_blank(*arg, evalarg_used, &getnext);\n\t}\n\n\tif (evalarg == NULL)\n\t    clear_evalarg(&local_evalarg, NULL);\n\telse\n\t    evalarg->eval_flags = orig_flags;\n    }\n\n    return OK;\n}\n\n/*\n * Handle second level expression:\n *\texpr3 && expr3 && expr3\t    logical AND\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval3(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    char_u\t*p;\n    int\t\tgetnext;\n\n    /*\n     * Get the first expression.\n     */\n    if (eval4(arg, rettv, evalarg) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Handle the \"&&\" operator.\n     */\n    p = eval_next_non_blank(*arg, evalarg, &getnext);\n    if (p[0] == '&' && p[1] == '&')\n    {\n\tevalarg_T   *evalarg_used = evalarg;\n\tevalarg_T   local_evalarg;\n\tint\t    orig_flags;\n\tint\t    evaluate;\n\tlong\t    result = TRUE;\n\ttypval_T    var2;\n\tint\t    error = FALSE;\n\tint\t    vim9script = in_vim9script();\n\n\tif (evalarg == NULL)\n\t{\n\t    init_evalarg(&local_evalarg);\n\t    evalarg_used = &local_evalarg;\n\t}\n\torig_flags = evalarg_used->eval_flags;\n\tevaluate = orig_flags & EVAL_EVALUATE;\n\tif (evaluate)\n\t{\n\t    if (vim9script)\n\t\tresult = tv_get_bool_chk(rettv, &error);\n\t    else if (tv_get_number_chk(rettv, &error) == 0)\n\t\tresult = FALSE;\n\t    clear_tv(rettv);\n\t    if (error)\n\t\treturn FAIL;\n\t}\n\n\t/*\n\t * Repeat until there is no following \"&&\".\n\t */\n\twhile (p[0] == '&' && p[1] == '&')\n\t{\n\t    if (getnext)\n\t\t*arg = eval_next_line(*arg, evalarg_used);\n\t    else\n\t    {\n\t\tif (evaluate && vim9script && !VIM_ISWHITE(p[-1]))\n\t\t{\n\t\t    error_white_both(p, 2);\n\t\t    clear_tv(rettv);\n\t\t    return FAIL;\n\t\t}\n\t\t*arg = p;\n\t    }\n\n\t    /*\n\t     * Get the second variable.\n\t     */\n\t    if (evaluate && vim9script && !IS_WHITE_OR_NUL((*arg)[2]))\n\t    {\n\t\terror_white_both(*arg, 2);\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t    *arg = skipwhite_and_linebreak(*arg + 2, evalarg_used);\n\t    evalarg_used->eval_flags = result ? orig_flags\n\t\t\t\t\t\t : orig_flags & ~EVAL_EVALUATE;\n\t    CLEAR_FIELD(var2);\n\t    if (eval4(arg, &var2, evalarg_used) == FAIL)\n\t\treturn FAIL;\n\n\t    /*\n\t     * Compute the result.\n\t     */\n\t    if (evaluate && result)\n\t    {\n\t\tif (vim9script)\n\t\t    result = tv_get_bool_chk(&var2, &error);\n\t\telse if (tv_get_number_chk(&var2, &error) == 0)\n\t\t    result = FALSE;\n\t\tclear_tv(&var2);\n\t\tif (error)\n\t\t    return FAIL;\n\t    }\n\t    if (evaluate)\n\t    {\n\t\tif (vim9script)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = result ? VVAL_TRUE : VVAL_FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rettv->v_type = VAR_NUMBER;\n\t\t    rettv->vval.v_number = result;\n\t\t}\n\t    }\n\n\t    p = eval_next_non_blank(*arg, evalarg_used, &getnext);\n\t}\n\n\tif (evalarg == NULL)\n\t    clear_evalarg(&local_evalarg, NULL);\n\telse\n\t    evalarg->eval_flags = orig_flags;\n    }\n\n    return OK;\n}\n\n/*\n * Handle third level expression:\n *\tvar1 == var2\n *\tvar1 =~ var2\n *\tvar1 != var2\n *\tvar1 !~ var2\n *\tvar1 > var2\n *\tvar1 >= var2\n *\tvar1 < var2\n *\tvar1 <= var2\n *\tvar1 is var2\n *\tvar1 isnot var2\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval4(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    char_u\t*p;\n    int\t\tgetnext;\n    exprtype_T\ttype = EXPR_UNKNOWN;\n    int\t\tlen = 2;\n    int\t\ttype_is = FALSE;\n\n    /*\n     * Get the first expression.\n     */\n    if (eval5(arg, rettv, evalarg) == FAIL)\n\treturn FAIL;\n\n    p = eval_next_non_blank(*arg, evalarg, &getnext);\n\n    type = get_compare_type(p, &len, &type_is);\n\n    /*\n     * If there is a comparative operator, use it.\n     */\n    if (type != EXPR_UNKNOWN)\n    {\n\ttypval_T    var2;\n\tint\t    ic;\n\tint\t    vim9script = in_vim9script();\n\tint\t    evaluate = evalarg == NULL\n\t\t\t\t   ? 0 : (evalarg->eval_flags & EVAL_EVALUATE);\n\tlong\t    comp_lnum = SOURCING_LNUM;\n\n\tif (getnext)\n\t{\n\t    *arg = eval_next_line(*arg, evalarg);\n\t    p = *arg;\n\t}\n\telse if (evaluate && vim9script && !VIM_ISWHITE(**arg))\n\t{\n\t    error_white_both(*arg, len);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\n\tif (vim9script && type_is && (p[len] == '?' || p[len] == '#'))\n\t{\n\t    semsg(_(e_invalid_expression_str), p);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\n\t// extra question mark appended: ignore case\n\tif (p[len] == '?')\n\t{\n\t    ic = TRUE;\n\t    ++len;\n\t}\n\t// extra '#' appended: match case\n\telse if (p[len] == '#')\n\t{\n\t    ic = FALSE;\n\t    ++len;\n\t}\n\t// nothing appended: use 'ignorecase' if not in Vim script\n\telse\n\t    ic = vim9script ? FALSE : p_ic;\n\n\t/*\n\t * Get the second variable.\n\t */\n\tif (evaluate && vim9script && !IS_WHITE_OR_NUL(p[len]))\n\t{\n\t    error_white_both(p, len);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite_and_linebreak(p + len, evalarg);\n\tif (eval5(arg, &var2, evalarg) == FAIL)\n\t{\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\tif (evaluate)\n\t{\n\t    int ret;\n\n\t    // use the line of the comparison for messages\n\t    SOURCING_LNUM = comp_lnum;\n\t    if (vim9script && check_compare_types(type, rettv, &var2) == FAIL)\n\t    {\n\t\tret = FAIL;\n\t\tclear_tv(rettv);\n\t    }\n\t    else\n\t\tret = typval_compare(rettv, &var2, type, ic);\n\t    clear_tv(&var2);\n\t    return ret;\n\t}\n    }\n\n    return OK;\n}\n\n/*\n * Make a copy of blob \"tv1\" and append blob \"tv2\".\n */\n    void\neval_addblob(typval_T *tv1, typval_T *tv2)\n{\n    blob_T  *b1 = tv1->vval.v_blob;\n    blob_T  *b2 = tv2->vval.v_blob;\n    blob_T  *b = blob_alloc();\n    int\t    i;\n\n    if (b != NULL)\n    {\n\tfor (i = 0; i < blob_len(b1); i++)\n\t    ga_append(&b->bv_ga, blob_get(b1, i));\n\tfor (i = 0; i < blob_len(b2); i++)\n\t    ga_append(&b->bv_ga, blob_get(b2, i));\n\n\tclear_tv(tv1);\n\trettv_blob_set(tv1, b);\n    }\n}\n\n/*\n * Make a copy of list \"tv1\" and append list \"tv2\".\n */\n    int\neval_addlist(typval_T *tv1, typval_T *tv2)\n{\n    typval_T var3;\n\n    // concatenate Lists\n    if (list_concat(tv1->vval.v_list, tv2->vval.v_list, &var3) == FAIL)\n    {\n\tclear_tv(tv1);\n\tclear_tv(tv2);\n\treturn FAIL;\n    }\n    clear_tv(tv1);\n    *tv1 = var3;\n    return OK;\n}\n\n/*\n * Handle the bitwise left/right shift operator expression:\n *\tvar1 << var2\n *\tvar1 >> var2\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval5(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    /*\n     * Get the first expression.\n     */\n    if (eval6(arg, rettv, evalarg) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Repeat computing, until no '<<' or '>>' is following.\n     */\n    for (;;)\n    {\n\tchar_u\t\t*p;\n\tint\t\tgetnext;\n\texprtype_T\ttype;\n\tint\t\tevaluate;\n\ttypval_T\tvar2;\n\tint\t\tvim9script;\n\n\tp = eval_next_non_blank(*arg, evalarg, &getnext);\n\tif (p[0] == '<' && p[1] == '<')\n\t    type = EXPR_LSHIFT;\n\telse if (p[0] == '>' && p[1] == '>')\n\t    type = EXPR_RSHIFT;\n\telse\n\t    return OK;\n\n\t// Handle a bitwise left or right shift operator\n\tif (rettv->v_type != VAR_NUMBER)\n\t{\n\t    // left operand should be a number\n\t    emsg(_(e_bitshift_ops_must_be_number));\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\n\tevaluate = evalarg == NULL ? 0 : (evalarg->eval_flags & EVAL_EVALUATE);\n\tvim9script = in_vim9script();\n\tif (getnext)\n\t{\n\t    *arg = eval_next_line(*arg, evalarg);\n\t    p = *arg;\n\t}\n\telse if (evaluate && vim9script && !VIM_ISWHITE(**arg))\n\t{\n\t    error_white_both(*arg, 2);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\n\t/*\n\t * Get the second variable.\n\t */\n\tif (evaluate && vim9script && !IS_WHITE_OR_NUL(p[2]))\n\t{\n\t    error_white_both(p, 2);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite_and_linebreak(p + 2, evalarg);\n\tif (eval6(arg, &var2, evalarg) == FAIL)\n\t{\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\n\tif (var2.v_type != VAR_NUMBER || var2.vval.v_number < 0)\n\t{\n\t    // right operand should be a positive number\n\t    if (var2.v_type != VAR_NUMBER)\n\t\temsg(_(e_bitshift_ops_must_be_number));\n\t    else\n\t\temsg(_(e_bitshift_ops_must_be_postive));\n\t    clear_tv(rettv);\n\t    clear_tv(&var2);\n\t    return FAIL;\n\t}\n\n\tif (evaluate)\n\t{\n\t    if (var2.vval.v_number > MAX_LSHIFT_BITS)\n\t\t// shifting more bits than we have always results in zero\n\t\trettv->vval.v_number = 0;\n\t    else if (type == EXPR_LSHIFT)\n\t\trettv->vval.v_number =\n\t\t      (uvarnumber_T)rettv->vval.v_number << var2.vval.v_number;\n\t    else\n\t\trettv->vval.v_number =\n\t\t      (uvarnumber_T)rettv->vval.v_number >> var2.vval.v_number;\n\t}\n\n\tclear_tv(&var2);\n    }\n\n    return OK;\n}\n\n/*\n * Handle fifth level expression:\n *\t+\tnumber addition, concatenation of list or blob\n *\t-\tnumber subtraction\n *\t.\tstring concatenation (if script version is 1)\n *\t..\tstring concatenation\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval6(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    /*\n     * Get the first expression.\n     */\n    if (eval7(arg, rettv, evalarg, FALSE) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Repeat computing, until no '+', '-' or '.' is following.\n     */\n    for (;;)\n    {\n\tint\t    evaluate;\n\tint\t    getnext;\n\tchar_u\t    *p;\n\tint\t    op;\n\tint\t    oplen;\n\tint\t    concat;\n\ttypval_T    var2;\n\tint\t    vim9script = in_vim9script();\n\n\t// \".\" is only string concatenation when scriptversion is 1\n\t// \"+=\", \"-=\" and \"..=\" are assignments\n\t// \"++\" and \"--\" on the next line are a separate command.\n\tp = eval_next_non_blank(*arg, evalarg, &getnext);\n\top = *p;\n\tconcat = op == '.' && (*(p + 1) == '.' || in_old_script(2));\n\tif ((op != '+' && op != '-' && !concat) || p[1] == '='\n\t\t\t\t\t       || (p[1] == '.' && p[2] == '='))\n\t    break;\n\tif (getnext && (op == '+' || op == '-') && p[0] == p[1])\n\t    break;\n\n\tevaluate = evalarg == NULL ? 0 : (evalarg->eval_flags & EVAL_EVALUATE);\n\toplen = (concat && p[1] == '.') ? 2 : 1;\n\tif (getnext)\n\t    *arg = eval_next_line(*arg, evalarg);\n\telse\n\t{\n\t    if (evaluate && vim9script && !VIM_ISWHITE(**arg))\n\t    {\n\t\terror_white_both(*arg, oplen);\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t    *arg = p;\n\t}\n\tif ((op != '+' || (rettv->v_type != VAR_LIST\n\t\t\t\t\t\t && rettv->v_type != VAR_BLOB))\n#ifdef FEAT_FLOAT\n\t\t&& (op == '.' || rettv->v_type != VAR_FLOAT)\n#endif\n\t\t&& evaluate)\n\t{\n\t    int\t\terror = FALSE;\n\n\t    // For \"list + ...\", an illegal use of the first operand as\n\t    // a number cannot be determined before evaluating the 2nd\n\t    // operand: if this is also a list, all is ok.\n\t    // For \"something . ...\", \"something - ...\" or \"non-list + ...\",\n\t    // we know that the first operand needs to be a string or number\n\t    // without evaluating the 2nd operand.  So check before to avoid\n\t    // side effects after an error.\n\t    if (op != '.')\n\t\ttv_get_number_chk(rettv, &error);\n\t    if ((op == '.' && tv_get_string_chk(rettv) == NULL) || error)\n\t    {\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t/*\n\t * Get the second variable.\n\t */\n\tif (evaluate && vim9script && !IS_WHITE_OR_NUL((*arg)[oplen]))\n\t{\n\t    error_white_both(*arg, oplen);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite_and_linebreak(*arg + oplen, evalarg);\n\tif (eval7(arg, &var2, evalarg, !vim9script && op == '.') == FAIL)\n\t{\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\n\tif (evaluate)\n\t{\n\t    /*\n\t     * Compute the result.\n\t     */\n\t    if (op == '.')\n\t    {\n\t\tchar_u\tbuf1[NUMBUFLEN], buf2[NUMBUFLEN];\n\t\tchar_u\t*s1 = tv_get_string_buf(rettv, buf1);\n\t\tchar_u\t*s2 = NULL;\n\n\t\tif (vim9script && (var2.v_type == VAR_VOID\n\t\t\t|| var2.v_type == VAR_CHANNEL\n\t\t\t|| var2.v_type == VAR_JOB))\n\t\t    semsg(_(e_using_invalid_value_as_string_str),\n\t\t\t\t\t\t   vartype_name(var2.v_type));\n#ifdef FEAT_FLOAT\n\t\telse if (vim9script && var2.v_type == VAR_FLOAT)\n\t\t{\n\t\t    vim_snprintf((char *)buf2, NUMBUFLEN, \"%g\",\n\t\t\t\t\t\t\t    var2.vval.v_float);\n\t\t    s2 = buf2;\n\t\t}\n#endif\n\t\telse\n\t\t    s2 = tv_get_string_buf_chk(&var2, buf2);\n\t\tif (s2 == NULL)\t\t// type error ?\n\t\t{\n\t\t    clear_tv(rettv);\n\t\t    clear_tv(&var2);\n\t\t    return FAIL;\n\t\t}\n\t\tp = concat_str(s1, s2);\n\t\tclear_tv(rettv);\n\t\trettv->v_type = VAR_STRING;\n\t\trettv->vval.v_string = p;\n\t    }\n\t    else if (op == '+' && rettv->v_type == VAR_BLOB\n\t\t\t\t\t\t   && var2.v_type == VAR_BLOB)\n\t\teval_addblob(rettv, &var2);\n\t    else if (op == '+' && rettv->v_type == VAR_LIST\n\t\t\t\t\t\t   && var2.v_type == VAR_LIST)\n\t    {\n\t\tif (eval_addlist(rettv, &var2) == FAIL)\n\t\t    return FAIL;\n\t    }\n\t    else\n\t    {\n\t\tint\t\terror = FALSE;\n\t\tvarnumber_T\tn1, n2;\n#ifdef FEAT_FLOAT\n\t\tfloat_T\t    f1 = 0, f2 = 0;\n\n\t\tif (rettv->v_type == VAR_FLOAT)\n\t\t{\n\t\t    f1 = rettv->vval.v_float;\n\t\t    n1 = 0;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    n1 = tv_get_number_chk(rettv, &error);\n\t\t    if (error)\n\t\t    {\n\t\t\t// This can only happen for \"list + non-list\" or\n\t\t\t// \"blob + non-blob\".  For \"non-list + ...\" or\n\t\t\t// \"something - ...\", we returned before evaluating the\n\t\t\t// 2nd operand.\n\t\t\tclear_tv(rettv);\n\t\t\tclear_tv(&var2);\n\t\t\treturn FAIL;\n\t\t    }\n#ifdef FEAT_FLOAT\n\t\t    if (var2.v_type == VAR_FLOAT)\n\t\t\tf1 = n1;\n#endif\n\t\t}\n#ifdef FEAT_FLOAT\n\t\tif (var2.v_type == VAR_FLOAT)\n\t\t{\n\t\t    f2 = var2.vval.v_float;\n\t\t    n2 = 0;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    n2 = tv_get_number_chk(&var2, &error);\n\t\t    if (error)\n\t\t    {\n\t\t\tclear_tv(rettv);\n\t\t\tclear_tv(&var2);\n\t\t\treturn FAIL;\n\t\t    }\n#ifdef FEAT_FLOAT\n\t\t    if (rettv->v_type == VAR_FLOAT)\n\t\t\tf2 = n2;\n#endif\n\t\t}\n\t\tclear_tv(rettv);\n\n#ifdef FEAT_FLOAT\n\t\t// If there is a float on either side the result is a float.\n\t\tif (rettv->v_type == VAR_FLOAT || var2.v_type == VAR_FLOAT)\n\t\t{\n\t\t    if (op == '+')\n\t\t\tf1 = f1 + f2;\n\t\t    else\n\t\t\tf1 = f1 - f2;\n\t\t    rettv->v_type = VAR_FLOAT;\n\t\t    rettv->vval.v_float = f1;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    if (op == '+')\n\t\t\tn1 = n1 + n2;\n\t\t    else\n\t\t\tn1 = n1 - n2;\n\t\t    rettv->v_type = VAR_NUMBER;\n\t\t    rettv->vval.v_number = n1;\n\t\t}\n\t    }\n\t    clear_tv(&var2);\n\t}\n    }\n    return OK;\n}\n\n/*\n * Handle sixth level expression:\n *\t*\tnumber multiplication\n *\t/\tnumber division\n *\t%\tnumber modulo\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval7(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\twant_string)  // after \".\" operator\n{\n#ifdef FEAT_FLOAT\n    int\t    use_float = FALSE;\n#endif\n\n    /*\n     * Get the first expression.\n     */\n    if (eval8(arg, rettv, evalarg, want_string) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Repeat computing, until no '*', '/' or '%' is following.\n     */\n    for (;;)\n    {\n\tint\t    evaluate;\n\tint\t    getnext;\n\ttypval_T    var2;\n\tchar_u\t    *p;\n\tint\t    op;\n\tvarnumber_T n1, n2;\n#ifdef FEAT_FLOAT\n\tfloat_T\t    f1, f2;\n#endif\n\tint\t    error;\n\n\t// \"*=\", \"/=\" and \"%=\" are assignments\n\tp = eval_next_non_blank(*arg, evalarg, &getnext);\n\top = *p;\n\tif ((op != '*' && op != '/' && op != '%') || p[1] == '=')\n\t    break;\n\n\tevaluate = evalarg == NULL ? 0 : (evalarg->eval_flags & EVAL_EVALUATE);\n\tif (getnext)\n\t    *arg = eval_next_line(*arg, evalarg);\n\telse\n\t{\n\t    if (evaluate && in_vim9script() && !VIM_ISWHITE(**arg))\n\t    {\n\t\terror_white_both(*arg, 1);\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t    *arg = p;\n\t}\n\n#ifdef FEAT_FLOAT\n\tf1 = 0;\n\tf2 = 0;\n#endif\n\terror = FALSE;\n\tif (evaluate)\n\t{\n#ifdef FEAT_FLOAT\n\t    if (rettv->v_type == VAR_FLOAT)\n\t    {\n\t\tf1 = rettv->vval.v_float;\n\t\tuse_float = TRUE;\n\t\tn1 = 0;\n\t    }\n\t    else\n#endif\n\t\tn1 = tv_get_number_chk(rettv, &error);\n\t    clear_tv(rettv);\n\t    if (error)\n\t\treturn FAIL;\n\t}\n\telse\n\t    n1 = 0;\n\n\t/*\n\t * Get the second variable.\n\t */\n\tif (evaluate && in_vim9script() && !IS_WHITE_OR_NUL((*arg)[1]))\n\t{\n\t    error_white_both(*arg, 1);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite_and_linebreak(*arg + 1, evalarg);\n\tif (eval8(arg, &var2, evalarg, FALSE) == FAIL)\n\t    return FAIL;\n\n\tif (evaluate)\n\t{\n#ifdef FEAT_FLOAT\n\t    if (var2.v_type == VAR_FLOAT)\n\t    {\n\t\tif (!use_float)\n\t\t{\n\t\t    f1 = n1;\n\t\t    use_float = TRUE;\n\t\t}\n\t\tf2 = var2.vval.v_float;\n\t\tn2 = 0;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tn2 = tv_get_number_chk(&var2, &error);\n\t\tclear_tv(&var2);\n\t\tif (error)\n\t\t    return FAIL;\n#ifdef FEAT_FLOAT\n\t\tif (use_float)\n\t\t    f2 = n2;\n#endif\n\t    }\n\n\t    /*\n\t     * Compute the result.\n\t     * When either side is a float the result is a float.\n\t     */\n#ifdef FEAT_FLOAT\n\t    if (use_float)\n\t    {\n\t\tif (op == '*')\n\t\t    f1 = f1 * f2;\n\t\telse if (op == '/')\n\t\t{\n# ifdef VMS\n\t\t    // VMS crashes on divide by zero, work around it\n\t\t    if (f2 == 0.0)\n\t\t    {\n\t\t\tif (f1 == 0)\n\t\t\t    f1 = -1 * __F_FLT_MAX - 1L;   // similar to NaN\n\t\t\telse if (f1 < 0)\n\t\t\t    f1 = -1 * __F_FLT_MAX;\n\t\t\telse\n\t\t\t    f1 = __F_FLT_MAX;\n\t\t    }\n\t\t    else\n\t\t\tf1 = f1 / f2;\n# else\n\t\t    // We rely on the floating point library to handle divide\n\t\t    // by zero to result in \"inf\" and not a crash.\n\t\t    f1 = f1 / f2;\n# endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    emsg(_(e_cannot_use_percent_with_float));\n\t\t    return FAIL;\n\t\t}\n\t\trettv->v_type = VAR_FLOAT;\n\t\trettv->vval.v_float = f1;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tint\t    failed = FALSE;\n\n\t\tif (op == '*')\n\t\t    n1 = n1 * n2;\n\t\telse if (op == '/')\n\t\t    n1 = num_divide(n1, n2, &failed);\n\t\telse\n\t\t    n1 = num_modulus(n1, n2, &failed);\n\t\tif (failed)\n\t\t    return FAIL;\n\n\t\trettv->v_type = VAR_NUMBER;\n\t\trettv->vval.v_number = n1;\n\t    }\n\t}\n    }\n\n    return OK;\n}\n\n/*\n * Handle a type cast before a base level expression.\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n * Return OK or FAIL.\n */\n    static int\neval8(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\twant_string)\t// after \".\" operator\n{\n    type_T\t*want_type = NULL;\n    garray_T\ttype_list;\t    // list of pointers to allocated types\n    int\t\tres;\n    int\t\tevaluate = evalarg == NULL ? 0\n\t\t\t\t       : (evalarg->eval_flags & EVAL_EVALUATE);\n\n    // Recognize <type> in Vim9 script only.\n    if (in_vim9script() && **arg == '<' && eval_isnamec1((*arg)[1])\n\t\t\t\t\t     && STRNCMP(*arg, \"<SNR>\", 5) != 0)\n    {\n\t++*arg;\n\tga_init2(&type_list, sizeof(type_T *), 10);\n\twant_type = parse_type(arg, &type_list, TRUE);\n\tif (want_type == NULL && (evaluate || **arg != '>'))\n\t{\n\t    clear_type_list(&type_list);\n\t    return FAIL;\n\t}\n\n\tif (**arg != '>')\n\t{\n\t    if (*skipwhite(*arg) == '>')\n\t\tsemsg(_(e_no_white_space_allowed_before_str_str), \">\", *arg);\n\t    else\n\t\temsg(_(e_missing_gt));\n\t    clear_type_list(&type_list);\n\t    return FAIL;\n\t}\n\t++*arg;\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n    }\n\n    res = eval9(arg, rettv, evalarg, want_string);\n\n    if (want_type != NULL && evaluate)\n    {\n\tif (res == OK)\n\t{\n\t    type_T *actual = typval2type(rettv, get_copyID(), &type_list,\n\t\t\t\t\t\t\t       TVTT_DO_MEMBER);\n\n\t    if (!equal_type(want_type, actual, 0))\n\t    {\n\t\tif (want_type == &t_bool && actual != &t_bool\n\t\t\t\t\t&& (actual->tt_flags & TTFLAG_BOOL_OK))\n\t\t{\n\t\t    int n = tv2bool(rettv);\n\n\t\t    // can use \"0\" and \"1\" for boolean in some places\n\t\t    clear_tv(rettv);\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = n ? VVAL_TRUE : VVAL_FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    where_T where = WHERE_INIT;\n\n\t\t    where.wt_variable = TRUE;\n\t\t    res = check_type(want_type, actual, TRUE, where);\n\t\t}\n\t    }\n\t}\n\tclear_type_list(&type_list);\n    }\n\n    return res;\n}\n\n    int\neval_leader(char_u **arg, int vim9)\n{\n    char_u\t*s = *arg;\n    char_u\t*p = *arg;\n\n    while (*p == '!' || *p == '-' || *p == '+')\n    {\n\tchar_u *n = skipwhite(p + 1);\n\n\t// ++, --, -+ and +- are not accepted in Vim9 script\n\tif (vim9 && (*p == '-' || *p == '+') && (*n == '-' || *n == '+'))\n\t{\n\t    semsg(_(e_invalid_expression_str), s);\n\t    return FAIL;\n\t}\n\tp = n;\n    }\n    *arg = p;\n    return OK;\n}\n\n/*\n * Check for a predefined value \"true\", \"false\" and \"null.*\".\n * Return OK when recognized.\n */\n    int\nhandle_predefined(char_u *s, int len, typval_T *rettv)\n{\n    switch (len)\n    {\n\tcase 4: if (STRNCMP(s, \"true\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = VVAL_TRUE;\n\t\t    return OK;\n\t\t}\n\t\tif (STRNCMP(s, \"null\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_SPECIAL;\n\t\t    rettv->vval.v_number = VVAL_NULL;\n\t\t    return OK;\n\t\t}\n\t\tbreak;\n\tcase 5: if (STRNCMP(s, \"false\", 5) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = VVAL_FALSE;\n\t\t    return OK;\n\t\t}\n\t\tbreak;\n\tcase 8: if (STRNCMP(s, \"null_job\", 8) == 0)\n\t\t{\n#ifdef FEAT_JOB_CHANNEL\n\t\t    rettv->v_type = VAR_JOB;\n\t\t    rettv->vval.v_job = NULL;\n#else\n\t\t    rettv->v_type = VAR_SPECIAL;\n\t\t    rettv->vval.v_number = VVAL_NULL;\n#endif\n\t\t    return OK;\n\t\t}\n\t\tbreak;\n\tcase 9:\n\t\tif (STRNCMP(s, \"null_\", 5) != 0)\n\t\t    break;\n\t\tif (STRNCMP(s + 5, \"list\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_LIST;\n\t\t    rettv->vval.v_list = NULL;\n\t\t    return OK;\n\t\t}\n\t\tif (STRNCMP(s + 5, \"dict\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_DICT;\n\t\t    rettv->vval.v_dict = NULL;\n\t\t    return OK;\n\t\t}\n\t\tif (STRNCMP(s + 5, \"blob\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_BLOB;\n\t\t    rettv->vval.v_blob = NULL;\n\t\t    return OK;\n\t\t}\n\t\tbreak;\n\tcase 11: if (STRNCMP(s, \"null_string\", 11) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_STRING;\n\t\t    rettv->vval.v_string = NULL;\n\t\t    return OK;\n\t\t}\n\t\tbreak;\n\tcase 12:\n\t\tif (STRNCMP(s, \"null_channel\", 12) == 0)\n\t\t{\n#ifdef FEAT_JOB_CHANNEL\n\t\t    rettv->v_type = VAR_CHANNEL;\n\t\t    rettv->vval.v_channel = NULL;\n#else\n\t\t    rettv->v_type = VAR_SPECIAL;\n\t\t    rettv->vval.v_number = VVAL_NULL;\n#endif\n\t\t    return OK;\n\t\t}\n\t\tif (STRNCMP(s, \"null_partial\", 12) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_PARTIAL;\n\t\t    rettv->vval.v_partial = NULL;\n\t\t    return OK;\n\t\t}\n\t\tbreak;\n\tcase 13: if (STRNCMP(s, \"null_function\", 13) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_FUNC;\n\t\t    rettv->vval.v_string = NULL;\n\t\t    return OK;\n\t\t}\n\t\tbreak;\n    }\n    return FAIL;\n}\n\n/*\n * Handle sixth level expression:\n *  number\t\tnumber constant\n *  0zFFFFFFFF\t\tBlob constant\n *  \"string\"\t\tstring constant\n *  'string'\t\tliteral string constant\n *  &option-name\toption value\n *  @r\t\t\tregister contents\n *  identifier\t\tvariable value\n *  function()\t\tfunction call\n *  $VAR\t\tenvironment variable\n *  (expression)\tnested expression\n *  [expr, expr]\tList\n *  {arg, arg -> expr}\tLambda\n *  {key: val, key: val}   Dictionary\n *  #{key: val, key: val}  Dictionary with literal keys\n *\n *  Also handle:\n *  ! in front\t\tlogical NOT\n *  - in front\t\tunary minus\n *  + in front\t\tunary plus (ignored)\n *  trailing []\t\tsubscript in String or List\n *  trailing .name\tentry in Dictionary\n *  trailing ->name()\tmethod call\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval9(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\twant_string)\t// after \".\" operator\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    int\t\tlen;\n    char_u\t*s;\n    char_u\t*name_start = NULL;\n    char_u\t*start_leader, *end_leader;\n    int\t\tret = OK;\n    char_u\t*alias;\n    static int\trecurse = 0;\n    int\t\tvim9script = in_vim9script();\n\n    /*\n     * Initialise variable so that clear_tv() can't mistake this for a\n     * string and free a string that isn't there.\n     */\n    rettv->v_type = VAR_UNKNOWN;\n\n    /*\n     * Skip '!', '-' and '+' characters.  They are handled later.\n     */\n    start_leader = *arg;\n    if (eval_leader(arg, vim9script) == FAIL)\n\treturn FAIL;\n    end_leader = *arg;\n\n    if (**arg == '.' && (!isdigit(*(*arg + 1))\n#ifdef FEAT_FLOAT\n\t    || in_old_script(2)\n#endif\n\t    ))\n    {\n\tsemsg(_(e_invalid_expression_str), *arg);\n\t++*arg;\n\treturn FAIL;\n    }\n\n    // Limit recursion to 1000 levels.  At least at 10000 we run out of stack\n    // and crash.  With MSVC the stack is smaller.\n    if (recurse ==\n#ifdef _MSC_VER\n\t\t    300\n#else\n\t\t    1000\n#endif\n\t\t    )\n    {\n\tsemsg(_(e_expression_too_recursive_str), *arg);\n\treturn FAIL;\n    }\n    ++recurse;\n\n    switch (**arg)\n    {\n    /*\n     * Number constant.\n     */\n    case '0':\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case '.':\tret = eval_number(arg, rettv, evaluate, want_string);\n\n\t\t// Apply prefixed \"-\" and \"+\" now.  Matters especially when\n\t\t// \"->\" follows.\n\t\tif (ret == OK && evaluate && end_leader > start_leader\n\t\t\t\t\t\t  && rettv->v_type != VAR_BLOB)\n\t\t    ret = eval9_leader(rettv, TRUE, start_leader, &end_leader);\n\t\tbreak;\n\n    /*\n     * String constant: \"string\".\n     */\n    case '\"':\tret = eval_string(arg, rettv, evaluate, FALSE);\n\t\tbreak;\n\n    /*\n     * Literal string constant: 'str''ing'.\n     */\n    case '\\'':\tret = eval_lit_string(arg, rettv, evaluate, FALSE);\n\t\tbreak;\n\n    /*\n     * List: [expr, expr]\n     */\n    case '[':\tret = eval_list(arg, rettv, evalarg, TRUE);\n\t\tbreak;\n\n    /*\n     * Dictionary: #{key: val, key: val}\n     */\n    case '#':\tif (vim9script)\n\t\t{\n\t\t    ret = vim9_bad_comment(*arg) ? FAIL : NOTDONE;\n\t\t}\n\t\telse if ((*arg)[1] == '{')\n\t\t{\n\t\t    ++*arg;\n\t\t    ret = eval_dict(arg, rettv, evalarg, TRUE);\n\t\t}\n\t\telse\n\t\t    ret = NOTDONE;\n\t\tbreak;\n\n    /*\n     * Lambda: {arg, arg -> expr}\n     * Dictionary: {'key': val, 'key': val}\n     */\n    case '{':\tif (vim9script)\n\t\t    ret = NOTDONE;\n\t\telse\n\t\t    ret = get_lambda_tv(arg, rettv, vim9script, evalarg);\n\t\tif (ret == NOTDONE)\n\t\t    ret = eval_dict(arg, rettv, evalarg, FALSE);\n\t\tbreak;\n\n    /*\n     * Option value: &name\n     */\n    case '&':\tret = eval_option(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Environment variable: $VAR.\n     * Interpolated string: $\"string\" or $'string'.\n     */\n    case '$':\tif ((*arg)[1] == '\"' || (*arg)[1] == '\\'')\n\t\t    ret = eval_interp_string(arg, rettv, evaluate);\n\t\telse\n\t\t    ret = eval_env_var(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Register contents: @r.\n     */\n    case '@':\t++*arg;\n\t\tif (evaluate)\n\t\t{\n\t\t    if (vim9script && IS_WHITE_OR_NUL(**arg))\n\t\t\tsemsg(_(e_syntax_error_at_str), *arg);\n\t\t    else if (vim9script && !valid_yank_reg(**arg, FALSE))\n\t\t\temsg_invreg(**arg);\n\t\t    else\n\t\t    {\n\t\t\trettv->v_type = VAR_STRING;\n\t\t\trettv->vval.v_string = get_reg_contents(**arg,\n\t\t\t\t\t\t\t\tGREG_EXPR_SRC);\n\t\t    }\n\t\t}\n\t\tif (**arg != NUL)\n\t\t    ++*arg;\n\t\tbreak;\n\n    /*\n     * nested expression: (expression).\n     * or lambda: (arg) => expr\n     */\n    case '(':\tret = NOTDONE;\n\t\tif (vim9script)\n\t\t{\n\t\t    ret = get_lambda_tv(arg, rettv, TRUE, evalarg);\n\t\t    if (ret == OK && evaluate)\n\t\t    {\n\t\t\tufunc_T *ufunc = rettv->vval.v_partial->pt_func;\n\n\t\t\t// Compile it here to get the return type.  The return\n\t\t\t// type is optional, when it's missing use t_unknown.\n\t\t\t// This is recognized in compile_return().\n\t\t\tif (ufunc->uf_ret_type->tt_type == VAR_VOID)\n\t\t\t    ufunc->uf_ret_type = &t_unknown;\n\t\t\tif (compile_def_function(ufunc, FALSE,\n\t\t\t\t\tget_compile_type(ufunc), NULL) == FAIL)\n\t\t\t{\n\t\t\t    clear_tv(rettv);\n\t\t\t    ret = FAIL;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (ret == NOTDONE)\n\t\t{\n\t\t    *arg = skipwhite_and_linebreak(*arg + 1, evalarg);\n\t\t    ret = eval1(arg, rettv, evalarg);\t// recursive!\n\n\t\t    *arg = skipwhite_and_linebreak(*arg, evalarg);\n\t\t    if (**arg == ')')\n\t\t\t++*arg;\n\t\t    else if (ret == OK)\n\t\t    {\n\t\t\temsg(_(e_missing_closing_paren));\n\t\t\tclear_tv(rettv);\n\t\t\tret = FAIL;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n    default:\tret = NOTDONE;\n\t\tbreak;\n    }\n\n    if (ret == NOTDONE)\n    {\n\t/*\n\t * Must be a variable or function name.\n\t * Can also be a curly-braces kind of name: {expr}.\n\t */\n\ts = *arg;\n\tlen = get_name_len(arg, &alias, evaluate, TRUE);\n\tif (alias != NULL)\n\t    s = alias;\n\n\tif (len <= 0)\n\t    ret = FAIL;\n\telse\n\t{\n\t    int\t    flags = evalarg == NULL ? 0 : evalarg->eval_flags;\n\n\t    if (evaluate && vim9script && len == 1 && *s == '_')\n\t    {\n\t\temsg(_(e_cannot_use_underscore_here));\n\t\tret = FAIL;\n\t    }\n\t    else if (evaluate && vim9script && len > 2\n\t\t\t\t\t\t && s[0] == 's' && s[1] == ':')\n\t    {\n\t\tsemsg(_(e_cannot_use_s_colon_in_vim9_script_str), s);\n\t\tret = FAIL;\n\t    }\n\t    else if ((vim9script ? **arg : *skipwhite(*arg)) == '(')\n\t    {\n\t\t// \"name(...\"  recursive!\n\t\t*arg = skipwhite(*arg);\n\t\tret = eval_func(arg, evalarg, s, len, rettv, flags, NULL);\n\t    }\n\t    else if (flags & EVAL_CONSTANT)\n\t\tret = FAIL;\n\t    else if (evaluate)\n\t    {\n\t\t// get the value of \"true\", \"false\", etc. or a variable\n\t\tret = FAIL;\n\t\tif (vim9script)\n\t\t    ret = handle_predefined(s, len, rettv);\n\t\tif (ret == FAIL)\n\t\t{\n\t\t    name_start = s;\n\t\t    ret = eval_variable(s, len, 0, rettv, NULL,\n\t\t\t\t\t   EVAL_VAR_VERBOSE + EVAL_VAR_IMPORT);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// skip the name\n\t\tcheck_vars(s, len);\n\t\tret = OK;\n\t    }\n\t}\n\tvim_free(alias);\n    }\n\n    // Handle following '[', '(' and '.' for expr[expr], expr.name,\n    // expr(expr), expr->name(expr)\n    if (ret == OK)\n\tret = handle_subscript(arg, name_start, rettv, evalarg, TRUE);\n\n    /*\n     * Apply logical NOT and unary '-', from right to left, ignore '+'.\n     */\n    if (ret == OK && evaluate && end_leader > start_leader)\n\tret = eval9_leader(rettv, FALSE, start_leader, &end_leader);\n\n    --recurse;\n    return ret;\n}\n\n/*\n * Apply the leading \"!\" and \"-\" before an eval9 expression to \"rettv\".\n * When \"numeric_only\" is TRUE only handle \"+\" and \"-\".\n * Adjusts \"end_leaderp\" until it is at \"start_leader\".\n */\n    static int\neval9_leader(\n\ttypval_T    *rettv,\n\tint\t    numeric_only,\n\tchar_u\t    *start_leader,\n\tchar_u\t    **end_leaderp)\n{\n    char_u\t*end_leader = *end_leaderp;\n    int\t\tret = OK;\n    int\t\terror = FALSE;\n    varnumber_T val = 0;\n    vartype_T\ttype = rettv->v_type;\n    int\t\tvim9script = in_vim9script();\n#ifdef FEAT_FLOAT\n    float_T\t    f = 0.0;\n\n    if (rettv->v_type == VAR_FLOAT)\n\tf = rettv->vval.v_float;\n    else\n#endif\n    {\n\twhile (VIM_ISWHITE(end_leader[-1]))\n\t    --end_leader;\n\tif (vim9script && end_leader[-1] == '!')\n\t    val = tv2bool(rettv);\n\telse\n\t    val = tv_get_number_chk(rettv, &error);\n    }\n    if (error)\n    {\n\tclear_tv(rettv);\n\tret = FAIL;\n    }\n    else\n    {\n\twhile (end_leader > start_leader)\n\t{\n\t    --end_leader;\n\t    if (*end_leader == '!')\n\t    {\n\t\tif (numeric_only)\n\t\t{\n\t\t    ++end_leader;\n\t\t    break;\n\t\t}\n#ifdef FEAT_FLOAT\n\t\tif (rettv->v_type == VAR_FLOAT)\n\t\t{\n\t\t    if (vim9script)\n\t\t    {\n\t\t\trettv->v_type = VAR_BOOL;\n\t\t\tval = f == 0.0 ? VVAL_TRUE : VVAL_FALSE;\n\t\t    }\n\t\t    else\n\t\t\tf = !f;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    val = !val;\n\t\t    type = VAR_BOOL;\n\t\t}\n\t    }\n\t    else if (*end_leader == '-')\n\t    {\n#ifdef FEAT_FLOAT\n\t\tif (rettv->v_type == VAR_FLOAT)\n\t\t    f = -f;\n\t\telse\n#endif\n\t\t{\n\t\t    val = -val;\n\t\t    type = VAR_NUMBER;\n\t\t}\n\t    }\n\t}\n#ifdef FEAT_FLOAT\n\tif (rettv->v_type == VAR_FLOAT)\n\t{\n\t    clear_tv(rettv);\n\t    rettv->vval.v_float = f;\n\t}\n\telse\n#endif\n\t{\n\t    clear_tv(rettv);\n\t    if (vim9script)\n\t\trettv->v_type = type;\n\t    else\n\t\trettv->v_type = VAR_NUMBER;\n\t    rettv->vval.v_number = val;\n\t}\n    }\n    *end_leaderp = end_leader;\n    return ret;\n}\n\n/*\n * Call the function referred to in \"rettv\".\n */\n    static int\ncall_func_rettv(\n\tchar_u\t    **arg,\n\tevalarg_T   *evalarg,\n\ttypval_T    *rettv,\n\tint\t    evaluate,\n\tdict_T\t    *selfdict,\n\ttypval_T    *basetv)\n{\n    partial_T\t*pt = NULL;\n    funcexe_T\tfuncexe;\n    typval_T\tfunctv;\n    char_u\t*s;\n    int\t\tret;\n\n    // need to copy the funcref so that we can clear rettv\n    if (evaluate)\n    {\n\tfunctv = *rettv;\n\trettv->v_type = VAR_UNKNOWN;\n\n\t// Invoke the function.  Recursive!\n\tif (functv.v_type == VAR_PARTIAL)\n\t{\n\t    pt = functv.vval.v_partial;\n\t    s = partial_name(pt);\n\t}\n\telse\n\t{\n\t    s = functv.vval.v_string;\n\t    if (s == NULL || *s == NUL)\n\t    {\n\t\temsg(_(e_empty_function_name));\n\t\tret = FAIL;\n\t\tgoto theend;\n\t    }\n\t}\n    }\n    else\n\ts = (char_u *)\"\";\n\n    CLEAR_FIELD(funcexe);\n    funcexe.fe_firstline = curwin->w_cursor.lnum;\n    funcexe.fe_lastline = curwin->w_cursor.lnum;\n    funcexe.fe_evaluate = evaluate;\n    funcexe.fe_partial = pt;\n    funcexe.fe_selfdict = selfdict;\n    funcexe.fe_basetv = basetv;\n    ret = get_func_tv(s, -1, rettv, arg, evalarg, &funcexe);\n\ntheend:\n    // Clear the funcref afterwards, so that deleting it while\n    // evaluating the arguments is possible (see test55).\n    if (evaluate)\n\tclear_tv(&functv);\n\n    return ret;\n}\n\n/*\n * Evaluate \"->method()\".\n * \"*arg\" points to \"method\".\n * Returns FAIL or OK. \"*arg\" is advanced to after the ')'.\n */\n    static int\neval_lambda(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t// give error messages\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    typval_T\tbase = *rettv;\n    int\t\tret;\n\n    rettv->v_type = VAR_UNKNOWN;\n\n    if (**arg == '{')\n    {\n\t// ->{lambda}()\n\tret = get_lambda_tv(arg, rettv, FALSE, evalarg);\n    }\n    else\n    {\n\t// ->(lambda)()\n\t++*arg;\n\tret = eval1(arg, rettv, evalarg);\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg != ')')\n\t{\n\t    emsg(_(e_missing_closing_paren));\n\t    return FAIL;\n\t}\n\tif (rettv->v_type != VAR_STRING && rettv->v_type != VAR_FUNC\n\t\t\t\t\t       && rettv->v_type != VAR_PARTIAL)\n\t{\n\t    emsg(_(e_string_or_function_required_for_arrow_parens_expr));\n\t    return FAIL;\n\t}\n\t++*arg;\n    }\n    if (ret != OK)\n\treturn FAIL;\n\n    if (**arg != '(')\n    {\n\tif (verbose)\n\t{\n\t    if (*skipwhite(*arg) == '(')\n\t\temsg(_(e_no_white_space_allowed_before_parenthesis));\n\t    else\n\t\tsemsg(_(e_missing_parenthesis_str), \"lambda\");\n\t}\n\tclear_tv(rettv);\n\tret = FAIL;\n    }\n    else\n\tret = call_func_rettv(arg, evalarg, rettv, evaluate, NULL, &base);\n\n    // Clear the funcref afterwards, so that deleting it while\n    // evaluating the arguments is possible (see test55).\n    if (evaluate)\n\tclear_tv(&base);\n\n    return ret;\n}\n\n/*\n * Evaluate \"->method()\".\n * \"*arg\" points to \"method\".\n * Returns FAIL or OK. \"*arg\" is advanced to after the ')'.\n */\n    static int\neval_method(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t// give error messages\n{\n    char_u\t*name;\n    long\tlen;\n    char_u\t*alias;\n    char_u\t*tofree = NULL;\n    typval_T\tbase = *rettv;\n    int\t\tret = OK;\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n\n    rettv->v_type = VAR_UNKNOWN;\n\n    name = *arg;\n    len = get_name_len(arg, &alias, evaluate, TRUE);\n    if (alias != NULL)\n\tname = alias;\n\n    if (len <= 0)\n    {\n\tif (verbose)\n\t    emsg(_(e_missing_name_after_method));\n\tret = FAIL;\n    }\n    else\n    {\n\tchar_u *paren;\n\n\t// If there is no \"(\" immediately following, but there is further on,\n\t// it can be \"import.Func()\", \"dict.Func()\", \"list[nr]\", etc.\n\t// Does not handle anything where \"(\" is part of the expression.\n\t*arg = skipwhite(*arg);\n\n\tif (**arg != '(' && alias == NULL\n\t\t\t\t    && (paren = vim_strchr(*arg, '(')) != NULL)\n\t{\n\t    char_u *deref;\n\n\t    *arg = name;\n\t    *paren = NUL;\n\t    deref = deref_function_name(arg, &tofree, evalarg, verbose);\n\t    if (deref == NULL)\n\t    {\n\t\t*arg = name + len;\n\t\tret = FAIL;\n\t    }\n\t    else\n\t    {\n\t\tname = deref;\n\t\tlen = (long)STRLEN(name);\n\t    }\n\t    *paren = '(';\n\t}\n\n\tif (ret == OK)\n\t{\n\t    *arg = skipwhite(*arg);\n\n\t    if (**arg != '(')\n\t    {\n\t\tif (verbose)\n\t\t    semsg(_(e_missing_parenthesis_str), name);\n\t\tret = FAIL;\n\t    }\n\t    else if (VIM_ISWHITE((*arg)[-1]))\n\t    {\n\t\tif (verbose)\n\t\t    emsg(_(e_no_white_space_allowed_before_parenthesis));\n\t\tret = FAIL;\n\t    }\n\t    else\n\t\tret = eval_func(arg, evalarg, name, len, rettv,\n\t\t\t\t\t  evaluate ? EVAL_EVALUATE : 0, &base);\n\t}\n    }\n\n    // Clear the funcref afterwards, so that deleting it while\n    // evaluating the arguments is possible (see test55).\n    if (evaluate)\n\tclear_tv(&base);\n    vim_free(tofree);\n\n    return ret;\n}\n\n/*\n * Evaluate an \"[expr]\" or \"[expr:expr]\" index.  Also \"dict.key\".\n * \"*arg\" points to the '[' or '.'.\n * Returns FAIL or OK. \"*arg\" is advanced to after the ']'.\n */\n    static int\neval_index(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t// give error messages\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    int\t\tempty1 = FALSE, empty2 = FALSE;\n    typval_T\tvar1, var2;\n    int\t\trange = FALSE;\n    char_u\t*key = NULL;\n    int\t\tkeylen = -1;\n    int\t\tvim9script = in_vim9script();\n\n    if (check_can_index(rettv, evaluate, verbose) == FAIL)\n\treturn FAIL;\n\n    init_tv(&var1);\n    init_tv(&var2);\n    if (**arg == '.')\n    {\n\t/*\n\t * dict.name\n\t */\n\tkey = *arg + 1;\n\tfor (keylen = 0; eval_isdictc(key[keylen]); ++keylen)\n\t    ;\n\tif (keylen == 0)\n\t    return FAIL;\n\t*arg = key + keylen;\n    }\n    else\n    {\n\t/*\n\t * something[idx]\n\t *\n\t * Get the (first) variable from inside the [].\n\t */\n\t*arg = skipwhite_and_linebreak(*arg + 1, evalarg);\n\tif (**arg == ':')\n\t    empty1 = TRUE;\n\telse if (eval1(arg, &var1, evalarg) == FAIL)\t// recursive!\n\t    return FAIL;\n\telse if (vim9script && **arg == ':')\n\t{\n\t    semsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t    \":\", *arg);\n\t    clear_tv(&var1);\n\t    return FAIL;\n\t}\n\telse if (evaluate)\n\t{\n\t    int error = FALSE;\n\n#ifdef FEAT_FLOAT\n\t    // allow for indexing with float\n\t    if (vim9script && rettv->v_type == VAR_DICT\n\t\t\t\t\t\t   && var1.v_type == VAR_FLOAT)\n\t    {\n\t\tvar1.vval.v_string = typval_tostring(&var1, TRUE);\n\t\tvar1.v_type = VAR_STRING;\n\t    }\n#endif\n\t    if (vim9script && rettv->v_type == VAR_LIST)\n\t\ttv_get_number_chk(&var1, &error);\n\t    else\n\t\terror = tv_get_string_chk(&var1) == NULL;\n\t    if (error)\n\t    {\n\t\t// not a number or string\n\t\tclear_tv(&var1);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t/*\n\t * Get the second variable from inside the [:].\n\t */\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg == ':')\n\t{\n\t    range = TRUE;\n\t    ++*arg;\n\t    if (vim9script && !IS_WHITE_OR_NUL(**arg) && **arg != ']')\n\t    {\n\t\tsemsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t\":\", *arg - 1);\n\t\tif (!empty1)\n\t\t    clear_tv(&var1);\n\t\treturn FAIL;\n\t    }\n\t    *arg = skipwhite_and_linebreak(*arg, evalarg);\n\t    if (**arg == ']')\n\t\tempty2 = TRUE;\n\t    else if (eval1(arg, &var2, evalarg) == FAIL)\t// recursive!\n\t    {\n\t\tif (!empty1)\n\t\t    clear_tv(&var1);\n\t\treturn FAIL;\n\t    }\n\t    else if (evaluate && tv_get_string_chk(&var2) == NULL)\n\t    {\n\t\t// not a number or string\n\t\tif (!empty1)\n\t\t    clear_tv(&var1);\n\t\tclear_tv(&var2);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t// Check for the ']'.\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg != ']')\n\t{\n\t    if (verbose)\n\t\temsg(_(e_missing_closing_square_brace));\n\t    clear_tv(&var1);\n\t    if (range)\n\t\tclear_tv(&var2);\n\t    return FAIL;\n\t}\n\t*arg = *arg + 1;\t// skip over the ']'\n    }\n\n    if (evaluate)\n    {\n\tint res = eval_index_inner(rettv, range,\n\t\tempty1 ? NULL : &var1, empty2 ? NULL : &var2, FALSE,\n\t\tkey, keylen, verbose);\n\n\tif (!empty1)\n\t    clear_tv(&var1);\n\tif (range)\n\t    clear_tv(&var2);\n\treturn res;\n    }\n    return OK;\n}\n\n/*\n * Check if \"rettv\" can have an [index] or [sli:ce]\n */\n    int\ncheck_can_index(typval_T *rettv, int evaluate, int verbose)\n{\n    switch (rettv->v_type)\n    {\n\tcase VAR_FUNC:\n\tcase VAR_PARTIAL:\n\t    if (verbose)\n\t\temsg(_(e_cannot_index_a_funcref));\n\t    return FAIL;\n\tcase VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t    if (verbose)\n\t\temsg(_(e_using_float_as_string));\n\t    return FAIL;\n#endif\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\tcase VAR_JOB:\n\tcase VAR_CHANNEL:\n\tcase VAR_INSTR:\n\t    if (verbose)\n\t\temsg(_(e_cannot_index_special_variable));\n\t    return FAIL;\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\t    if (evaluate)\n\t    {\n\t\temsg(_(e_cannot_index_special_variable));\n\t\treturn FAIL;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase VAR_STRING:\n\tcase VAR_LIST:\n\tcase VAR_DICT:\n\tcase VAR_BLOB:\n\t    break;\n\tcase VAR_NUMBER:\n\t    if (in_vim9script())\n\t\temsg(_(e_cannot_index_number));\n\t    break;\n    }\n    return OK;\n}\n\n/*\n * slice() function\n */\n    void\nf_slice(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script()\n\t    && ((argvars[0].v_type != VAR_STRING\n\t\t    && argvars[0].v_type != VAR_LIST\n\t\t    && argvars[0].v_type != VAR_BLOB\n\t\t    && check_for_list_arg(argvars, 0) == FAIL)\n\t\t|| check_for_number_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_number_arg(argvars, 2) == FAIL))\n\treturn;\n\n    if (check_can_index(argvars, TRUE, FALSE) == OK)\n    {\n\tcopy_tv(argvars, rettv);\n\teval_index_inner(rettv, TRUE, argvars + 1,\n\t\targvars[2].v_type == VAR_UNKNOWN ? NULL : argvars + 2,\n\t\tTRUE, NULL, 0, FALSE);\n    }\n}\n\n/*\n * Apply index or range to \"rettv\".\n * \"var1\" is the first index, NULL for [:expr].\n * \"var2\" is the second index, NULL for [expr] and [expr: ]\n * \"exclusive\" is TRUE for slice(): second index is exclusive, use character\n * index for string.\n * Alternatively, \"key\" is not NULL, then key[keylen] is the dict index.\n */\n    int\neval_index_inner(\n\ttypval_T    *rettv,\n\tint\t    is_range,\n\ttypval_T    *var1,\n\ttypval_T    *var2,\n\tint\t    exclusive,\n\tchar_u\t    *key,\n\tint\t    keylen,\n\tint\t    verbose)\n{\n    varnumber_T\t    n1, n2 = 0;\n    long\t    len;\n\n    n1 = 0;\n    if (var1 != NULL && rettv->v_type != VAR_DICT)\n\tn1 = tv_get_number(var1);\n\n    if (is_range)\n    {\n\tif (rettv->v_type == VAR_DICT)\n\t{\n\t    if (verbose)\n\t\temsg(_(e_cannot_slice_dictionary));\n\t    return FAIL;\n\t}\n\tif (var2 != NULL)\n\t    n2 = tv_get_number(var2);\n\telse\n\t    n2 = VARNUM_MAX;\n    }\n\n    switch (rettv->v_type)\n    {\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\tcase VAR_FUNC:\n\tcase VAR_PARTIAL:\n\tcase VAR_FLOAT:\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\tcase VAR_JOB:\n\tcase VAR_CHANNEL:\n\tcase VAR_INSTR:\n\t    break; // not evaluating, skipping over subscript\n\n\tcase VAR_NUMBER:\n\tcase VAR_STRING:\n\t    {\n\t\tchar_u\t*s = tv_get_string(rettv);\n\n\t\tlen = (long)STRLEN(s);\n\t\tif (in_vim9script() || exclusive)\n\t\t{\n\t\t    if (is_range)\n\t\t\ts = string_slice(s, n1, n2, exclusive);\n\t\t    else\n\t\t\ts = char_from_string(s, n1);\n\t\t}\n\t\telse if (is_range)\n\t\t{\n\t\t    // The resulting variable is a substring.  If the indexes\n\t\t    // are out of range the result is empty.\n\t\t    if (n1 < 0)\n\t\t    {\n\t\t\tn1 = len + n1;\n\t\t\tif (n1 < 0)\n\t\t\t    n1 = 0;\n\t\t    }\n\t\t    if (n2 < 0)\n\t\t\tn2 = len + n2;\n\t\t    else if (n2 >= len)\n\t\t\tn2 = len;\n\t\t    if (n1 >= len || n2 < 0 || n1 > n2)\n\t\t\ts = NULL;\n\t\t    else\n\t\t\ts = vim_strnsave(s + n1, n2 - n1 + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // The resulting variable is a string of a single\n\t\t    // character.  If the index is too big or negative the\n\t\t    // result is empty.\n\t\t    if (n1 >= len || n1 < 0)\n\t\t\ts = NULL;\n\t\t    else\n\t\t\ts = vim_strnsave(s + n1, 1);\n\t\t}\n\t\tclear_tv(rettv);\n\t\trettv->v_type = VAR_STRING;\n\t\trettv->vval.v_string = s;\n\t    }\n\t    break;\n\n\tcase VAR_BLOB:\n\t    blob_slice_or_index(rettv->vval.v_blob, is_range, n1, n2,\n\t\t\t\t\t\t\t     exclusive, rettv);\n\t    break;\n\n\tcase VAR_LIST:\n\t    if (var1 == NULL)\n\t\tn1 = 0;\n\t    if (var2 == NULL)\n\t\tn2 = VARNUM_MAX;\n\t    if (list_slice_or_index(rettv->vval.v_list,\n\t\t\t  is_range, n1, n2, exclusive, rettv, verbose) == FAIL)\n\t\treturn FAIL;\n\t    break;\n\n\tcase VAR_DICT:\n\t    {\n\t\tdictitem_T\t*item;\n\t\ttypval_T\ttmp;\n\n\t\tif (key == NULL)\n\t\t{\n\t\t    key = tv_get_string_chk(var1);\n\t\t    if (key == NULL)\n\t\t\treturn FAIL;\n\t\t}\n\n\t\titem = dict_find(rettv->vval.v_dict, key, keylen);\n\n\t\tif (item == NULL)\n\t\t{\n\t\t    if (verbose)\n\t\t    {\n\t\t\tif (keylen > 0)\n\t\t\t    key[keylen] = NUL;\n\t\t\tsemsg(_(e_key_not_present_in_dictionary), key);\n\t\t    }\n\t\t    return FAIL;\n\t\t}\n\n\t\tcopy_tv(&item->di_tv, &tmp);\n\t\tclear_tv(rettv);\n\t\t*rettv = tmp;\n\t    }\n\t    break;\n    }\n    return OK;\n}\n\n/*\n * Return the function name of partial \"pt\".\n */\n    char_u *\npartial_name(partial_T *pt)\n{\n    if (pt != NULL)\n    {\n\tif (pt->pt_name != NULL)\n\t    return pt->pt_name;\n\tif (pt->pt_func != NULL)\n\t    return pt->pt_func->uf_name;\n    }\n    return (char_u *)\"\";\n}\n\n    static void\npartial_free(partial_T *pt)\n{\n    int i;\n\n    for (i = 0; i < pt->pt_argc; ++i)\n\tclear_tv(&pt->pt_argv[i]);\n    vim_free(pt->pt_argv);\n    dict_unref(pt->pt_dict);\n    if (pt->pt_name != NULL)\n    {\n\tfunc_unref(pt->pt_name);\n\tvim_free(pt->pt_name);\n    }\n    else\n\tfunc_ptr_unref(pt->pt_func);\n\n    // \"out_up\" is no longer used, decrement refcount on partial that owns it.\n    partial_unref(pt->pt_outer.out_up_partial);\n\n    // Using pt_outer from another partial.\n    partial_unref(pt->pt_outer_partial);\n\n    // Decrease the reference count for the context of a closure.  If down\n    // to the minimum it may be time to free it.\n    if (pt->pt_funcstack != NULL)\n    {\n\t--pt->pt_funcstack->fs_refcount;\n\tfuncstack_check_refcount(pt->pt_funcstack);\n    }\n\n    vim_free(pt);\n}\n\n/*\n * Unreference a closure: decrement the reference count and free it when it\n * becomes zero.\n */\n    void\npartial_unref(partial_T *pt)\n{\n    if (pt != NULL)\n    {\n\tif (--pt->pt_refcount <= 0)\n\t    partial_free(pt);\n\n\t// If the reference count goes down to one, the funcstack may be the\n\t// only reference and can be freed if no other partials reference it.\n\telse if (pt->pt_refcount == 1 && pt->pt_funcstack != NULL)\n\t    funcstack_check_refcount(pt->pt_funcstack);\n    }\n}\n\n/*\n * Return the next (unique) copy ID.\n * Used for serializing nested structures.\n */\n    int\nget_copyID(void)\n{\n    current_copyID += COPYID_INC;\n    return current_copyID;\n}\n\n/*\n * Garbage collection for lists and dictionaries.\n *\n * We use reference counts to be able to free most items right away when they\n * are no longer used.  But for composite items it's possible that it becomes\n * unused while the reference count is > 0: When there is a recursive\n * reference.  Example:\n *\t:let l = [1, 2, 3]\n *\t:let d = {9: l}\n *\t:let l[1] = d\n *\n * Since this is quite unusual we handle this with garbage collection: every\n * once in a while find out which lists and dicts are not referenced from any\n * variable.\n *\n * Here is a good reference text about garbage collection (refers to Python\n * but it applies to all reference-counting mechanisms):\n *\thttp://python.ca/nas/python/gc/\n */\n\n/*\n * Do garbage collection for lists and dicts.\n * When \"testing\" is TRUE this is called from test_garbagecollect_now().\n * Return TRUE if some memory was freed.\n */\n    int\ngarbage_collect(int testing)\n{\n    int\t\tcopyID;\n    int\t\tabort = FALSE;\n    buf_T\t*buf;\n    win_T\t*wp;\n    int\t\tdid_free = FALSE;\n    tabpage_T\t*tp;\n\n    if (!testing)\n    {\n\t// Only do this once.\n\twant_garbage_collect = FALSE;\n\tmay_garbage_collect = FALSE;\n\tgarbage_collect_at_exit = FALSE;\n    }\n\n    // The execution stack can grow big, limit the size.\n    if (exestack.ga_maxlen - exestack.ga_len > 500)\n    {\n\tsize_t\tnew_len;\n\tchar_u\t*pp;\n\tint\tn;\n\n\t// Keep 150% of the current size, with a minimum of the growth size.\n\tn = exestack.ga_len / 2;\n\tif (n < exestack.ga_growsize)\n\t    n = exestack.ga_growsize;\n\n\t// Don't make it bigger though.\n\tif (exestack.ga_len + n < exestack.ga_maxlen)\n\t{\n\t    new_len = (size_t)exestack.ga_itemsize * (exestack.ga_len + n);\n\t    pp = vim_realloc(exestack.ga_data, new_len);\n\t    if (pp == NULL)\n\t\treturn FAIL;\n\t    exestack.ga_maxlen = exestack.ga_len + n;\n\t    exestack.ga_data = pp;\n\t}\n    }\n\n    // We advance by two because we add one for items referenced through\n    // previous_funccal.\n    copyID = get_copyID();\n\n    /*\n     * 1. Go through all accessible variables and mark all lists and dicts\n     *    with copyID.\n     */\n\n    // Don't free variables in the previous_funccal list unless they are only\n    // referenced through previous_funccal.  This must be first, because if\n    // the item is referenced elsewhere the funccal must not be freed.\n    abort = abort || set_ref_in_previous_funccal(copyID);\n\n    // script-local variables\n    abort = abort || garbage_collect_scriptvars(copyID);\n\n    // buffer-local variables\n    FOR_ALL_BUFFERS(buf)\n\tabort = abort || set_ref_in_item(&buf->b_bufvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n\n    // window-local variables\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tabort = abort || set_ref_in_item(&wp->w_winvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n    if (aucmd_win != NULL)\n\tabort = abort || set_ref_in_item(&aucmd_win->w_winvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n#ifdef FEAT_PROP_POPUP\n    FOR_ALL_POPUPWINS(wp)\n\tabort = abort || set_ref_in_item(&wp->w_winvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n    FOR_ALL_TABPAGES(tp)\n\tFOR_ALL_POPUPWINS_IN_TAB(tp, wp)\n\t\tabort = abort || set_ref_in_item(&wp->w_winvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n#endif\n\n    // tabpage-local variables\n    FOR_ALL_TABPAGES(tp)\n\tabort = abort || set_ref_in_item(&tp->tp_winvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n    // global variables\n    abort = abort || garbage_collect_globvars(copyID);\n\n    // function-local variables\n    abort = abort || set_ref_in_call_stack(copyID);\n\n    // named functions (matters for closures)\n    abort = abort || set_ref_in_functions(copyID);\n\n    // function call arguments, if v:testing is set.\n    abort = abort || set_ref_in_func_args(copyID);\n\n    // funcstacks keep variables for closures\n    abort = abort || set_ref_in_funcstacks(copyID);\n\n    // v: vars\n    abort = abort || garbage_collect_vimvars(copyID);\n\n    // callbacks in buffers\n    abort = abort || set_ref_in_buffers(copyID);\n\n    // 'completefunc', 'omnifunc' and 'thesaurusfunc' callbacks\n    abort = abort || set_ref_in_insexpand_funcs(copyID);\n\n    // 'operatorfunc' callback\n    abort = abort || set_ref_in_opfunc(copyID);\n\n    // 'tagfunc' callback\n    abort = abort || set_ref_in_tagfunc(copyID);\n\n    // 'imactivatefunc' and 'imstatusfunc' callbacks\n    abort = abort || set_ref_in_im_funcs(copyID);\n\n#ifdef FEAT_LUA\n    abort = abort || set_ref_in_lua(copyID);\n#endif\n\n#ifdef FEAT_PYTHON\n    abort = abort || set_ref_in_python(copyID);\n#endif\n\n#ifdef FEAT_PYTHON3\n    abort = abort || set_ref_in_python3(copyID);\n#endif\n\n#ifdef FEAT_JOB_CHANNEL\n    abort = abort || set_ref_in_channel(copyID);\n    abort = abort || set_ref_in_job(copyID);\n#endif\n#ifdef FEAT_NETBEANS_INTG\n    abort = abort || set_ref_in_nb_channel(copyID);\n#endif\n\n#ifdef FEAT_TIMERS\n    abort = abort || set_ref_in_timer(copyID);\n#endif\n\n#ifdef FEAT_QUICKFIX\n    abort = abort || set_ref_in_quickfix(copyID);\n#endif\n\n#ifdef FEAT_TERMINAL\n    abort = abort || set_ref_in_term(copyID);\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    abort = abort || set_ref_in_popups(copyID);\n#endif\n\n    if (!abort)\n    {\n\t/*\n\t * 2. Free lists and dictionaries that are not referenced.\n\t */\n\tdid_free = free_unref_items(copyID);\n\n\t/*\n\t * 3. Check if any funccal can be freed now.\n\t *    This may call us back recursively.\n\t */\n\tfree_unref_funccal(copyID, testing);\n    }\n    else if (p_verbose > 0)\n    {\n\tverb_msg(_(\"Not enough memory to set references, garbage collection aborted!\"));\n    }\n\n    return did_free;\n}\n\n/*\n * Free lists, dictionaries, channels and jobs that are no longer referenced.\n */\n    static int\nfree_unref_items(int copyID)\n{\n    int\t\tdid_free = FALSE;\n\n    // Let all \"free\" functions know that we are here.  This means no\n    // dictionaries, lists, channels or jobs are to be freed, because we will\n    // do that here.\n    in_free_unref_items = TRUE;\n\n    /*\n     * PASS 1: free the contents of the items.  We don't free the items\n     * themselves yet, so that it is possible to decrement refcount counters\n     */\n\n    // Go through the list of dicts and free items without the copyID.\n    did_free |= dict_free_nonref(copyID);\n\n    // Go through the list of lists and free items without the copyID.\n    did_free |= list_free_nonref(copyID);\n\n#ifdef FEAT_JOB_CHANNEL\n    // Go through the list of jobs and free items without the copyID. This\n    // must happen before doing channels, because jobs refer to channels, but\n    // the reference from the channel to the job isn't tracked.\n    did_free |= free_unused_jobs_contents(copyID, COPYID_MASK);\n\n    // Go through the list of channels and free items without the copyID.\n    did_free |= free_unused_channels_contents(copyID, COPYID_MASK);\n#endif\n\n    /*\n     * PASS 2: free the items themselves.\n     */\n    dict_free_items(copyID);\n    list_free_items(copyID);\n\n#ifdef FEAT_JOB_CHANNEL\n    // Go through the list of jobs and free items without the copyID. This\n    // must happen before doing channels, because jobs refer to channels, but\n    // the reference from the channel to the job isn't tracked.\n    free_unused_jobs(copyID, COPYID_MASK);\n\n    // Go through the list of channels and free items without the copyID.\n    free_unused_channels(copyID, COPYID_MASK);\n#endif\n\n    in_free_unref_items = FALSE;\n\n    return did_free;\n}\n\n/*\n * Mark all lists and dicts referenced through hashtab \"ht\" with \"copyID\".\n * \"list_stack\" is used to add lists to be marked.  Can be NULL.\n *\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_ht(hashtab_T *ht, int copyID, list_stack_T **list_stack)\n{\n    int\t\ttodo;\n    int\t\tabort = FALSE;\n    hashitem_T\t*hi;\n    hashtab_T\t*cur_ht;\n    ht_stack_T\t*ht_stack = NULL;\n    ht_stack_T\t*tempitem;\n\n    cur_ht = ht;\n    for (;;)\n    {\n\tif (!abort)\n\t{\n\t    // Mark each item in the hashtab.  If the item contains a hashtab\n\t    // it is added to ht_stack, if it contains a list it is added to\n\t    // list_stack.\n\t    todo = (int)cur_ht->ht_used;\n\t    for (hi = cur_ht->ht_array; todo > 0; ++hi)\n\t\tif (!HASHITEM_EMPTY(hi))\n\t\t{\n\t\t    --todo;\n\t\t    abort = abort || set_ref_in_item(&HI2DI(hi)->di_tv, copyID,\n\t\t\t\t\t\t       &ht_stack, list_stack);\n\t\t}\n\t}\n\n\tif (ht_stack == NULL)\n\t    break;\n\n\t// take an item from the stack\n\tcur_ht = ht_stack->ht;\n\ttempitem = ht_stack;\n\tht_stack = ht_stack->prev;\n\tfree(tempitem);\n    }\n\n    return abort;\n}\n\n#if defined(FEAT_LUA) || defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) \\\n\t\t\t\t\t\t\t|| defined(PROTO)\n/*\n * Mark a dict and its items with \"copyID\".\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_dict(dict_T *d, int copyID)\n{\n    if (d != NULL && d->dv_copyID != copyID)\n    {\n\td->dv_copyID = copyID;\n\treturn set_ref_in_ht(&d->dv_hashtab, copyID, NULL);\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Mark a list and its items with \"copyID\".\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_list(list_T *ll, int copyID)\n{\n    if (ll != NULL && ll->lv_copyID != copyID)\n    {\n\tll->lv_copyID = copyID;\n\treturn set_ref_in_list_items(ll, copyID, NULL);\n    }\n    return FALSE;\n}\n\n/*\n * Mark all lists and dicts referenced through list \"l\" with \"copyID\".\n * \"ht_stack\" is used to add hashtabs to be marked.  Can be NULL.\n *\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_list_items(list_T *l, int copyID, ht_stack_T **ht_stack)\n{\n    listitem_T\t *li;\n    int\t\t abort = FALSE;\n    list_T\t *cur_l;\n    list_stack_T *list_stack = NULL;\n    list_stack_T *tempitem;\n\n    cur_l = l;\n    for (;;)\n    {\n\tif (!abort && cur_l->lv_first != &range_list_item)\n\t    // Mark each item in the list.  If the item contains a hashtab\n\t    // it is added to ht_stack, if it contains a list it is added to\n\t    // list_stack.\n\t    for (li = cur_l->lv_first; !abort && li != NULL; li = li->li_next)\n\t\tabort = abort || set_ref_in_item(&li->li_tv, copyID,\n\t\t\t\t\t\t       ht_stack, &list_stack);\n\tif (list_stack == NULL)\n\t    break;\n\n\t// take an item from the stack\n\tcur_l = list_stack->list;\n\ttempitem = list_stack;\n\tlist_stack = list_stack->prev;\n\tfree(tempitem);\n    }\n\n    return abort;\n}\n\n/*\n * Mark the partial in callback 'cb' with \"copyID\".\n */\n    int\nset_ref_in_callback(callback_T *cb, int copyID)\n{\n    typval_T tv;\n\n    if (cb->cb_name == NULL || *cb->cb_name == NUL || cb->cb_partial == NULL)\n\treturn FALSE;\n\n    tv.v_type = VAR_PARTIAL;\n    tv.vval.v_partial = cb->cb_partial;\n    return set_ref_in_item(&tv, copyID, NULL, NULL);\n}\n\n/*\n * Mark all lists and dicts referenced through typval \"tv\" with \"copyID\".\n * \"list_stack\" is used to add lists to be marked.  Can be NULL.\n * \"ht_stack\" is used to add hashtabs to be marked.  Can be NULL.\n *\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_item(\n    typval_T\t    *tv,\n    int\t\t    copyID,\n    ht_stack_T\t    **ht_stack,\n    list_stack_T    **list_stack)\n{\n    int\t\tabort = FALSE;\n\n    if (tv->v_type == VAR_DICT)\n    {\n\tdict_T\t*dd = tv->vval.v_dict;\n\n\tif (dd != NULL && dd->dv_copyID != copyID)\n\t{\n\t    // Didn't see this dict yet.\n\t    dd->dv_copyID = copyID;\n\t    if (ht_stack == NULL)\n\t    {\n\t\tabort = set_ref_in_ht(&dd->dv_hashtab, copyID, list_stack);\n\t    }\n\t    else\n\t    {\n\t\tht_stack_T *newitem = ALLOC_ONE(ht_stack_T);\n\n\t\tif (newitem == NULL)\n\t\t    abort = TRUE;\n\t\telse\n\t\t{\n\t\t    newitem->ht = &dd->dv_hashtab;\n\t\t    newitem->prev = *ht_stack;\n\t\t    *ht_stack = newitem;\n\t\t}\n\t    }\n\t}\n    }\n    else if (tv->v_type == VAR_LIST)\n    {\n\tlist_T\t*ll = tv->vval.v_list;\n\n\tif (ll != NULL && ll->lv_copyID != copyID)\n\t{\n\t    // Didn't see this list yet.\n\t    ll->lv_copyID = copyID;\n\t    if (list_stack == NULL)\n\t    {\n\t\tabort = set_ref_in_list_items(ll, copyID, ht_stack);\n\t    }\n\t    else\n\t    {\n\t\tlist_stack_T *newitem = ALLOC_ONE(list_stack_T);\n\n\t\tif (newitem == NULL)\n\t\t    abort = TRUE;\n\t\telse\n\t\t{\n\t\t    newitem->list = ll;\n\t\t    newitem->prev = *list_stack;\n\t\t    *list_stack = newitem;\n\t\t}\n\t    }\n\t}\n    }\n    else if (tv->v_type == VAR_FUNC)\n    {\n\tabort = set_ref_in_func(tv->vval.v_string, NULL, copyID);\n    }\n    else if (tv->v_type == VAR_PARTIAL)\n    {\n\tpartial_T\t*pt = tv->vval.v_partial;\n\tint\t\ti;\n\n\tif (pt != NULL && pt->pt_copyID != copyID)\n\t{\n\t    // Didn't see this partial yet.\n\t    pt->pt_copyID = copyID;\n\n\t    abort = set_ref_in_func(pt->pt_name, pt->pt_func, copyID);\n\n\t    if (pt->pt_dict != NULL)\n\t    {\n\t\ttypval_T dtv;\n\n\t\tdtv.v_type = VAR_DICT;\n\t\tdtv.vval.v_dict = pt->pt_dict;\n\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t    }\n\n\t    for (i = 0; i < pt->pt_argc; ++i)\n\t\tabort = abort || set_ref_in_item(&pt->pt_argv[i], copyID,\n\t\t\t\t\t\t\tht_stack, list_stack);\n\t    // pt_funcstack is handled in set_ref_in_funcstacks()\n\t}\n    }\n#ifdef FEAT_JOB_CHANNEL\n    else if (tv->v_type == VAR_JOB)\n    {\n\tjob_T\t    *job = tv->vval.v_job;\n\ttypval_T    dtv;\n\n\tif (job != NULL && job->jv_copyID != copyID)\n\t{\n\t    job->jv_copyID = copyID;\n\t    if (job->jv_channel != NULL)\n\t    {\n\t\tdtv.v_type = VAR_CHANNEL;\n\t\tdtv.vval.v_channel = job->jv_channel;\n\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t    }\n\t    if (job->jv_exit_cb.cb_partial != NULL)\n\t    {\n\t\tdtv.v_type = VAR_PARTIAL;\n\t\tdtv.vval.v_partial = job->jv_exit_cb.cb_partial;\n\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t    }\n\t}\n    }\n    else if (tv->v_type == VAR_CHANNEL)\n    {\n\tchannel_T   *ch =tv->vval.v_channel;\n\tch_part_T   part;\n\ttypval_T    dtv;\n\tjsonq_T\t    *jq;\n\tcbq_T\t    *cq;\n\n\tif (ch != NULL && ch->ch_copyID != copyID)\n\t{\n\t    ch->ch_copyID = copyID;\n\t    for (part = PART_SOCK; part < PART_COUNT; ++part)\n\t    {\n\t\tfor (jq = ch->ch_part[part].ch_json_head.jq_next; jq != NULL;\n\t\t\t\t\t\t\t     jq = jq->jq_next)\n\t\t    set_ref_in_item(jq->jq_value, copyID, ht_stack, list_stack);\n\t\tfor (cq = ch->ch_part[part].ch_cb_head.cq_next; cq != NULL;\n\t\t\t\t\t\t\t     cq = cq->cq_next)\n\t\t    if (cq->cq_callback.cb_partial != NULL)\n\t\t    {\n\t\t\tdtv.v_type = VAR_PARTIAL;\n\t\t\tdtv.vval.v_partial = cq->cq_callback.cb_partial;\n\t\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t\t    }\n\t\tif (ch->ch_part[part].ch_callback.cb_partial != NULL)\n\t\t{\n\t\t    dtv.v_type = VAR_PARTIAL;\n\t\t    dtv.vval.v_partial =\n\t\t\t\t      ch->ch_part[part].ch_callback.cb_partial;\n\t\t    set_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t\t}\n\t    }\n\t    if (ch->ch_callback.cb_partial != NULL)\n\t    {\n\t\tdtv.v_type = VAR_PARTIAL;\n\t\tdtv.vval.v_partial = ch->ch_callback.cb_partial;\n\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t    }\n\t    if (ch->ch_close_cb.cb_partial != NULL)\n\t    {\n\t\tdtv.v_type = VAR_PARTIAL;\n\t\tdtv.vval.v_partial = ch->ch_close_cb.cb_partial;\n\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t    }\n\t}\n    }\n#endif\n    return abort;\n}\n\n/*\n * Return a string with the string representation of a variable.\n * If the memory is allocated \"tofree\" is set to it, otherwise NULL.\n * \"numbuf\" is used for a number.\n * When \"copyID\" is not NULL replace recursive lists and dicts with \"...\".\n * When both \"echo_style\" and \"composite_val\" are FALSE, put quotes around\n * strings as \"string()\", otherwise does not put quotes around strings, as\n * \":echo\" displays values.\n * When \"restore_copyID\" is FALSE, repeated items in dictionaries and lists\n * are replaced with \"...\".\n * May return NULL.\n */\n    char_u *\necho_string_core(\n    typval_T\t*tv,\n    char_u\t**tofree,\n    char_u\t*numbuf,\n    int\t\tcopyID,\n    int\t\techo_style,\n    int\t\trestore_copyID,\n    int\t\tcomposite_val)\n{\n    static int\trecurse = 0;\n    char_u\t*r = NULL;\n\n    if (recurse >= DICT_MAXNEST)\n    {\n\tif (!did_echo_string_emsg)\n\t{\n\t    // Only give this message once for a recursive call to avoid\n\t    // flooding the user with errors.  And stop iterating over lists\n\t    // and dicts.\n\t    did_echo_string_emsg = TRUE;\n\t    emsg(_(e_variable_nested_too_deep_for_displaying));\n\t}\n\t*tofree = NULL;\n\treturn (char_u *)\"{E724}\";\n    }\n    ++recurse;\n\n    switch (tv->v_type)\n    {\n\tcase VAR_STRING:\n\t    if (echo_style && !composite_val)\n\t    {\n\t\t*tofree = NULL;\n\t\tr = tv->vval.v_string;\n\t\tif (r == NULL)\n\t\t    r = (char_u *)\"\";\n\t    }\n\t    else\n\t    {\n\t\t*tofree = string_quote(tv->vval.v_string, FALSE);\n\t\tr = *tofree;\n\t    }\n\t    break;\n\n\tcase VAR_FUNC:\n\t    {\n\t\tchar_u buf[MAX_FUNC_NAME_LEN];\n\n\t\tif (echo_style)\n\t\t{\n\t\t    r = tv->vval.v_string == NULL ? (char_u *)\"function()\"\n\t\t\t\t  : make_ufunc_name_readable(tv->vval.v_string,\n\t\t\t\t\t\t       buf, MAX_FUNC_NAME_LEN);\n\t\t    if (r == buf)\n\t\t    {\n\t\t\tr = vim_strsave(buf);\n\t\t\t*tofree = r;\n\t\t    }\n\t\t    else\n\t\t\t*tofree = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    *tofree = string_quote(tv->vval.v_string == NULL ? NULL\n\t\t\t    : make_ufunc_name_readable(\n\t\t\t\ttv->vval.v_string, buf, MAX_FUNC_NAME_LEN),\n\t\t\t\t\t\t\t\t\t TRUE);\n\t\t    r = *tofree;\n\t\t}\n\t    }\n\t    break;\n\n\tcase VAR_PARTIAL:\n\t    {\n\t\tpartial_T   *pt = tv->vval.v_partial;\n\t\tchar_u\t    *fname = string_quote(pt == NULL ? NULL\n\t\t\t\t\t\t    : partial_name(pt), FALSE);\n\t\tgarray_T    ga;\n\t\tint\t    i;\n\t\tchar_u\t    *tf;\n\n\t\tga_init2(&ga, 1, 100);\n\t\tga_concat(&ga, (char_u *)\"function(\");\n\t\tif (fname != NULL)\n\t\t{\n\t\t    // When using uf_name prepend \"g:\" for a global function.\n\t\t    if (pt != NULL && pt->pt_name == NULL && fname[0] == '\\''\n\t\t\t\t\t\t      && vim_isupper(fname[1]))\n\t\t    {\n\t\t\tga_concat(&ga, (char_u *)\"'g:\");\n\t\t\tga_concat(&ga, fname + 1);\n\t\t    }\n\t\t    else\n\t\t\tga_concat(&ga, fname);\n\t\t    vim_free(fname);\n\t\t}\n\t\tif (pt != NULL && pt->pt_argc > 0)\n\t\t{\n\t\t    ga_concat(&ga, (char_u *)\", [\");\n\t\t    for (i = 0; i < pt->pt_argc; ++i)\n\t\t    {\n\t\t\tif (i > 0)\n\t\t\t    ga_concat(&ga, (char_u *)\", \");\n\t\t\tga_concat(&ga,\n\t\t\t     tv2string(&pt->pt_argv[i], &tf, numbuf, copyID));\n\t\t\tvim_free(tf);\n\t\t    }\n\t\t    ga_concat(&ga, (char_u *)\"]\");\n\t\t}\n\t\tif (pt != NULL && pt->pt_dict != NULL)\n\t\t{\n\t\t    typval_T dtv;\n\n\t\t    ga_concat(&ga, (char_u *)\", \");\n\t\t    dtv.v_type = VAR_DICT;\n\t\t    dtv.vval.v_dict = pt->pt_dict;\n\t\t    ga_concat(&ga, tv2string(&dtv, &tf, numbuf, copyID));\n\t\t    vim_free(tf);\n\t\t}\n\t\t// terminate with ')' and a NUL\n\t\tga_concat_len(&ga, (char_u *)\")\", 2);\n\n\t\t*tofree = ga.ga_data;\n\t\tr = *tofree;\n\t\tbreak;\n\t    }\n\n\tcase VAR_BLOB:\n\t    r = blob2string(tv->vval.v_blob, tofree, numbuf);\n\t    break;\n\n\tcase VAR_LIST:\n\t    if (tv->vval.v_list == NULL)\n\t    {\n\t\t// NULL list is equivalent to empty list.\n\t\t*tofree = NULL;\n\t\tr = (char_u *)\"[]\";\n\t    }\n\t    else if (copyID != 0 && tv->vval.v_list->lv_copyID == copyID\n\t\t    && tv->vval.v_list->lv_len > 0)\n\t    {\n\t\t*tofree = NULL;\n\t\tr = (char_u *)\"[...]\";\n\t    }\n\t    else\n\t    {\n\t\tint old_copyID = tv->vval.v_list->lv_copyID;\n\n\t\ttv->vval.v_list->lv_copyID = copyID;\n\t\t*tofree = list2string(tv, copyID, restore_copyID);\n\t\tif (restore_copyID)\n\t\t    tv->vval.v_list->lv_copyID = old_copyID;\n\t\tr = *tofree;\n\t    }\n\t    break;\n\n\tcase VAR_DICT:\n\t    if (tv->vval.v_dict == NULL)\n\t    {\n\t\t// NULL dict is equivalent to empty dict.\n\t\t*tofree = NULL;\n\t\tr = (char_u *)\"{}\";\n\t    }\n\t    else if (copyID != 0 && tv->vval.v_dict->dv_copyID == copyID\n\t\t    && tv->vval.v_dict->dv_hashtab.ht_used != 0)\n\t    {\n\t\t*tofree = NULL;\n\t\tr = (char_u *)\"{...}\";\n\t    }\n\t    else\n\t    {\n\t\tint old_copyID = tv->vval.v_dict->dv_copyID;\n\n\t\ttv->vval.v_dict->dv_copyID = copyID;\n\t\t*tofree = dict2string(tv, copyID, restore_copyID);\n\t\tif (restore_copyID)\n\t\t    tv->vval.v_dict->dv_copyID = old_copyID;\n\t\tr = *tofree;\n\t    }\n\t    break;\n\n\tcase VAR_NUMBER:\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\t    *tofree = NULL;\n\t    r = tv_get_string_buf(tv, numbuf);\n\t    break;\n\n\tcase VAR_JOB:\n\tcase VAR_CHANNEL:\n#ifdef FEAT_JOB_CHANNEL\n\t    *tofree = NULL;\n\t    r = tv->v_type == VAR_JOB ? job_to_string_buf(tv, numbuf)\n\t\t\t\t\t   : channel_to_string_buf(tv, numbuf);\n\t    if (composite_val)\n\t    {\n\t\t*tofree = string_quote(r, FALSE);\n\t\tr = *tofree;\n\t    }\n#endif\n\t    break;\n\n\tcase VAR_INSTR:\n\t    *tofree = NULL;\n\t    r = (char_u *)\"instructions\";\n\t    break;\n\n\tcase VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t    *tofree = NULL;\n\t    vim_snprintf((char *)numbuf, NUMBUFLEN, \"%g\", tv->vval.v_float);\n\t    r = numbuf;\n\t    break;\n#endif\n\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\t    *tofree = NULL;\n\t    r = (char_u *)get_var_special_name(tv->vval.v_number);\n\t    break;\n    }\n\n    if (--recurse == 0)\n\tdid_echo_string_emsg = FALSE;\n    return r;\n}\n\n/*\n * Return a string with the string representation of a variable.\n * If the memory is allocated \"tofree\" is set to it, otherwise NULL.\n * \"numbuf\" is used for a number.\n * Does not put quotes around strings, as \":echo\" displays values.\n * When \"copyID\" is not NULL replace recursive lists and dicts with \"...\".\n * May return NULL.\n */\n    char_u *\necho_string(\n    typval_T\t*tv,\n    char_u\t**tofree,\n    char_u\t*numbuf,\n    int\t\tcopyID)\n{\n    return echo_string_core(tv, tofree, numbuf, copyID, TRUE, FALSE, FALSE);\n}\n\n/*\n * Convert the specified byte index of line 'lnum' in buffer 'buf' to a\n * character index.  Works only for loaded buffers. Returns -1 on failure.\n * The index of the first byte and the first character is zero.\n */\n    int\nbuf_byteidx_to_charidx(buf_T *buf, int lnum, int byteidx)\n{\n    char_u\t*str;\n    char_u\t*t;\n    int\t\tcount;\n\n    if (buf == NULL || buf->b_ml.ml_mfp == NULL)\n\treturn -1;\n\n    if (lnum > buf->b_ml.ml_line_count)\n\tlnum = buf->b_ml.ml_line_count;\n\n    str = ml_get_buf(buf, lnum, FALSE);\n    if (str == NULL)\n\treturn -1;\n\n    if (*str == NUL)\n\treturn 0;\n\n    // count the number of characters\n    t = str;\n    for (count = 0; *t != NUL && t <= str + byteidx; count++)\n\tt += mb_ptr2len(t);\n\n    // In insert mode, when the cursor is at the end of a non-empty line,\n    // byteidx points to the NUL character immediately past the end of the\n    // string. In this case, add one to the character count.\n    if (*t == NUL && byteidx != 0 && t == str + byteidx)\n\tcount++;\n\n    return count - 1;\n}\n\n/*\n * Convert the specified character index of line 'lnum' in buffer 'buf' to a\n * byte index.  Works only for loaded buffers. Returns -1 on failure.\n * The index of the first byte and the first character is zero.\n */\n    int\nbuf_charidx_to_byteidx(buf_T *buf, int lnum, int charidx)\n{\n    char_u\t*str;\n    char_u\t*t;\n\n    if (buf == NULL || buf->b_ml.ml_mfp == NULL)\n\treturn -1;\n\n    if (lnum > buf->b_ml.ml_line_count)\n\tlnum = buf->b_ml.ml_line_count;\n\n    str = ml_get_buf(buf, lnum, FALSE);\n    if (str == NULL)\n\treturn -1;\n\n    // Convert the character offset to a byte offset\n    t = str;\n    while (*t != NUL && --charidx > 0)\n\tt += mb_ptr2len(t);\n\n    return t - str;\n}\n\n/*\n * Translate a String variable into a position.\n * Returns NULL when there is an error.\n */\n    pos_T *\nvar2fpos(\n    typval_T\t*varp,\n    int\t\tdollar_lnum,\t// TRUE when $ is last line\n    int\t\t*fnum,\t\t// set to fnum for '0, 'A, etc.\n    int\t\tcharcol)\t// return character column\n{\n    char_u\t\t*name;\n    static pos_T\tpos;\n    pos_T\t\t*pp;\n\n    // Argument can be [lnum, col, coladd].\n    if (varp->v_type == VAR_LIST)\n    {\n\tlist_T\t\t*l;\n\tint\t\tlen;\n\tint\t\terror = FALSE;\n\tlistitem_T\t*li;\n\n\tl = varp->vval.v_list;\n\tif (l == NULL)\n\t    return NULL;\n\n\t// Get the line number\n\tpos.lnum = list_find_nr(l, 0L, &error);\n\tif (error || pos.lnum <= 0 || pos.lnum > curbuf->b_ml.ml_line_count)\n\t    return NULL;\t// invalid line number\n\tif (charcol)\n\t    len = (long)mb_charlen(ml_get(pos.lnum));\n\telse\n\t    len = (long)STRLEN(ml_get(pos.lnum));\n\n\t// Get the column number\n\t// We accept \"$\" for the column number: last column.\n\tli = list_find(l, 1L);\n\tif (li != NULL && li->li_tv.v_type == VAR_STRING\n\t\t&& li->li_tv.vval.v_string != NULL\n\t\t&& STRCMP(li->li_tv.vval.v_string, \"$\") == 0)\n\t{\n\t    pos.col = len + 1;\n\t}\n\telse\n\t{\n\t    pos.col = list_find_nr(l, 1L, &error);\n\t    if (error)\n\t\treturn NULL;\n\t}\n\n\t// Accept a position up to the NUL after the line.\n\tif (pos.col == 0 || (int)pos.col > len + 1)\n\t    return NULL;\t// invalid column number\n\t--pos.col;\n\n\t// Get the virtual offset.  Defaults to zero.\n\tpos.coladd = list_find_nr(l, 2L, &error);\n\tif (error)\n\t    pos.coladd = 0;\n\n\treturn &pos;\n    }\n\n    if (in_vim9script() && check_for_string_arg(varp, 0) == FAIL)\n\treturn NULL;\n\n    name = tv_get_string_chk(varp);\n    if (name == NULL)\n\treturn NULL;\n\n    pos.lnum = 0;\n    if (name[0] == '.' && (!in_vim9script() || name[1] == NUL))\n    {\n\t// cursor\n\tpos = curwin->w_cursor;\n    }\n    else if (name[0] == 'v' && name[1] == NUL)\n    {\n\t// Visual start\n\tif (VIsual_active)\n\t    pos = VIsual;\n\telse\n\t    pos = curwin->w_cursor;\n    }\n    else if (name[0] == '\\'' && (!in_vim9script()\n\t\t\t\t\t|| (name[1] != NUL && name[2] == NUL)))\n    {\n\t// mark\n\tpp = getmark_buf_fnum(curbuf, name[1], FALSE, fnum);\n\tif (pp == NULL || pp == (pos_T *)-1 || pp->lnum <= 0)\n\t    return NULL;\n\tpos = *pp;\n    }\n    if (pos.lnum != 0)\n    {\n\tif (charcol)\n\t    pos.col = buf_byteidx_to_charidx(curbuf, pos.lnum, pos.col);\n\treturn &pos;\n    }\n\n    pos.coladd = 0;\n\n    if (name[0] == 'w' && dollar_lnum)\n    {\n\tpos.col = 0;\n\tif (name[1] == '0')\t\t// \"w0\": first visible line\n\t{\n\t    update_topline();\n\t    // In silent Ex mode topline is zero, but that's not a valid line\n\t    // number; use one instead.\n\t    pos.lnum = curwin->w_topline > 0 ? curwin->w_topline : 1;\n\t    return &pos;\n\t}\n\telse if (name[1] == '$')\t// \"w$\": last visible line\n\t{\n\t    validate_botline();\n\t    // In silent Ex mode botline is zero, return zero then.\n\t    pos.lnum = curwin->w_botline > 0 ? curwin->w_botline - 1 : 0;\n\t    return &pos;\n\t}\n    }\n    else if (name[0] == '$')\t\t// last column or line\n    {\n\tif (dollar_lnum)\n\t{\n\t    pos.lnum = curbuf->b_ml.ml_line_count;\n\t    pos.col = 0;\n\t}\n\telse\n\t{\n\t    pos.lnum = curwin->w_cursor.lnum;\n\t    if (charcol)\n\t\tpos.col = (colnr_T)mb_charlen(ml_get_curline());\n\t    else\n\t\tpos.col = (colnr_T)STRLEN(ml_get_curline());\n\t}\n\treturn &pos;\n    }\n    if (in_vim9script())\n\tsemsg(_(e_invalid_value_for_line_number_str), name);\n    return NULL;\n}\n\n/*\n * Convert list in \"arg\" into a position and optional file number.\n * When \"fnump\" is NULL there is no file number, only 3 items.\n * Note that the column is passed on as-is, the caller may want to decrement\n * it to use 1 for the first column.\n * Return FAIL when conversion is not possible, doesn't check the position for\n * validity.\n */\n    int\nlist2fpos(\n    typval_T\t*arg,\n    pos_T\t*posp,\n    int\t\t*fnump,\n    colnr_T\t*curswantp,\n    int\t\tcharcol)\n{\n    list_T\t*l = arg->vval.v_list;\n    long\ti = 0;\n    long\tn;\n\n    // List must be: [fnum, lnum, col, coladd, curswant], where \"fnum\" is only\n    // there when \"fnump\" isn't NULL; \"coladd\" and \"curswant\" are optional.\n    if (arg->v_type != VAR_LIST\n\t    || l == NULL\n\t    || l->lv_len < (fnump == NULL ? 2 : 3)\n\t    || l->lv_len > (fnump == NULL ? 4 : 5))\n\treturn FAIL;\n\n    if (fnump != NULL)\n    {\n\tn = list_find_nr(l, i++, NULL);\t// fnum\n\tif (n < 0)\n\t    return FAIL;\n\tif (n == 0)\n\t    n = curbuf->b_fnum;\t\t// current buffer\n\t*fnump = n;\n    }\n\n    n = list_find_nr(l, i++, NULL);\t// lnum\n    if (n < 0)\n\treturn FAIL;\n    posp->lnum = n;\n\n    n = list_find_nr(l, i++, NULL);\t// col\n    if (n < 0)\n\treturn FAIL;\n    // If character position is specified, then convert to byte position\n    if (charcol)\n    {\n\tbuf_T\t*buf;\n\n\t// Get the text for the specified line in a loaded buffer\n\tbuf = buflist_findnr(fnump == NULL ? curbuf->b_fnum : *fnump);\n\tif (buf == NULL || buf->b_ml.ml_mfp == NULL)\n\t    return FAIL;\n\n\tn = buf_charidx_to_byteidx(buf, posp->lnum, n) + 1;\n    }\n    posp->col = n;\n\n    n = list_find_nr(l, i, NULL);\t// off\n    if (n < 0)\n\tposp->coladd = 0;\n    else\n\tposp->coladd = n;\n\n    if (curswantp != NULL)\n\t*curswantp = list_find_nr(l, i + 1, NULL);  // curswant\n\n    return OK;\n}\n\n/*\n * Get the length of an environment variable name.\n * Advance \"arg\" to the first character after the name.\n * Return 0 for error.\n */\n    int\nget_env_len(char_u **arg)\n{\n    char_u\t*p;\n    int\t\tlen;\n\n    for (p = *arg; vim_isIDc(*p); ++p)\n\t;\n    if (p == *arg)\t    // no name found\n\treturn 0;\n\n    len = (int)(p - *arg);\n    *arg = p;\n    return len;\n}\n\n/*\n * Get the length of the name of a function or internal variable.\n * \"arg\" is advanced to after the name.\n * Return 0 if something is wrong.\n */\n    int\nget_id_len(char_u **arg)\n{\n    char_u\t*p;\n    int\t\tlen;\n\n    // Find the end of the name.\n    for (p = *arg; eval_isnamec(*p); ++p)\n    {\n\tif (*p == ':')\n\t{\n\t    // \"s:\" is start of \"s:var\", but \"n:\" is not and can be used in\n\t    // slice \"[n:]\".  Also \"xx:\" is not a namespace.\n\t    len = (int)(p - *arg);\n\t    if ((len == 1 && vim_strchr(NAMESPACE_CHAR, **arg) == NULL)\n\t\t    || len > 1)\n\t\tbreak;\n\t}\n    }\n    if (p == *arg)\t    // no name found\n\treturn 0;\n\n    len = (int)(p - *arg);\n    *arg = p;\n\n    return len;\n}\n\n/*\n * Get the length of the name of a variable or function.\n * Only the name is recognized, does not handle \".key\" or \"[idx]\".\n * \"arg\" is advanced to the first non-white character after the name.\n * Return -1 if curly braces expansion failed.\n * Return 0 if something else is wrong.\n * If the name contains 'magic' {}'s, expand them and return the\n * expanded name in an allocated string via 'alias' - caller must free.\n */\n    int\nget_name_len(\n    char_u\t**arg,\n    char_u\t**alias,\n    int\t\tevaluate,\n    int\t\tverbose)\n{\n    int\t\tlen;\n    char_u\t*p;\n    char_u\t*expr_start;\n    char_u\t*expr_end;\n\n    *alias = NULL;  // default to no alias\n\n    if ((*arg)[0] == K_SPECIAL && (*arg)[1] == KS_EXTRA\n\t\t\t\t\t\t  && (*arg)[2] == (int)KE_SNR)\n    {\n\t// hard coded <SNR>, already translated\n\t*arg += 3;\n\treturn get_id_len(arg) + 3;\n    }\n    len = eval_fname_script(*arg);\n    if (len > 0)\n    {\n\t// literal \"<SID>\", \"s:\" or \"<SNR>\"\n\t*arg += len;\n    }\n\n    /*\n     * Find the end of the name; check for {} construction.\n     */\n    p = find_name_end(*arg, &expr_start, &expr_end,\n\t\t\t\t\t       len > 0 ? 0 : FNE_CHECK_START);\n    if (expr_start != NULL)\n    {\n\tchar_u\t*temp_string;\n\n\tif (!evaluate)\n\t{\n\t    len += (int)(p - *arg);\n\t    *arg = skipwhite(p);\n\t    return len;\n\t}\n\n\t/*\n\t * Include any <SID> etc in the expanded string:\n\t * Thus the -len here.\n\t */\n\ttemp_string = make_expanded_name(*arg - len, expr_start, expr_end, p);\n\tif (temp_string == NULL)\n\t    return -1;\n\t*alias = temp_string;\n\t*arg = skipwhite(p);\n\treturn (int)STRLEN(temp_string);\n    }\n\n    len += get_id_len(arg);\n    // Only give an error when there is something, otherwise it will be\n    // reported at a higher level.\n    if (len == 0 && verbose && **arg != NUL)\n\tsemsg(_(e_invalid_expression_str), *arg);\n\n    return len;\n}\n\n/*\n * Find the end of a variable or function name, taking care of magic braces.\n * If \"expr_start\" is not NULL then \"expr_start\" and \"expr_end\" are set to the\n * start and end of the first magic braces item.\n * \"flags\" can have FNE_INCL_BR and FNE_CHECK_START.\n * Return a pointer to just after the name.  Equal to \"arg\" if there is no\n * valid name.\n */\n    char_u *\nfind_name_end(\n    char_u\t*arg,\n    char_u\t**expr_start,\n    char_u\t**expr_end,\n    int\t\tflags)\n{\n    int\t\tmb_nest = 0;\n    int\t\tbr_nest = 0;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\tvim9script = in_vim9script();\n\n    if (expr_start != NULL)\n    {\n\t*expr_start = NULL;\n\t*expr_end = NULL;\n    }\n\n    // Quick check for valid starting character.\n    if ((flags & FNE_CHECK_START) && !eval_isnamec1(*arg)\n\t\t\t\t\t\t&& (*arg != '{' || vim9script))\n\treturn arg;\n\n    for (p = arg; *p != NUL\n\t\t    && (eval_isnamec(*p)\n\t\t\t|| (*p == '{' && !vim9script)\n\t\t\t|| ((flags & FNE_INCL_BR) && (*p == '['\n\t\t\t\t\t || (*p == '.' && eval_isdictc(p[1]))))\n\t\t\t|| mb_nest != 0\n\t\t\t|| br_nest != 0); MB_PTR_ADV(p))\n    {\n\tif (*p == '\\'')\n\t{\n\t    // skip over 'string' to avoid counting [ and ] inside it.\n\t    for (p = p + 1; *p != NUL && *p != '\\''; MB_PTR_ADV(p))\n\t\t;\n\t    if (*p == NUL)\n\t\tbreak;\n\t}\n\telse if (*p == '\"')\n\t{\n\t    // skip over \"str\\\"ing\" to avoid counting [ and ] inside it.\n\t    for (p = p + 1; *p != NUL && *p != '\"'; MB_PTR_ADV(p))\n\t\tif (*p == '\\\\' && p[1] != NUL)\n\t\t    ++p;\n\t    if (*p == NUL)\n\t\tbreak;\n\t}\n\telse if (br_nest == 0 && mb_nest == 0 && *p == ':')\n\t{\n\t    // \"s:\" is start of \"s:var\", but \"n:\" is not and can be used in\n\t    // slice \"[n:]\".  Also \"xx:\" is not a namespace. But {ns}: is.\n\t    len = (int)(p - arg);\n\t    if ((len == 1 && vim_strchr(NAMESPACE_CHAR, *arg) == NULL)\n\t\t    || (len > 1 && p[-1] != '}'))\n\t\tbreak;\n\t}\n\n\tif (mb_nest == 0)\n\t{\n\t    if (*p == '[')\n\t\t++br_nest;\n\t    else if (*p == ']')\n\t\t--br_nest;\n\t}\n\n\tif (br_nest == 0 && !vim9script)\n\t{\n\t    if (*p == '{')\n\t    {\n\t\tmb_nest++;\n\t\tif (expr_start != NULL && *expr_start == NULL)\n\t\t    *expr_start = p;\n\t    }\n\t    else if (*p == '}')\n\t    {\n\t\tmb_nest--;\n\t\tif (expr_start != NULL && mb_nest == 0 && *expr_end == NULL)\n\t\t    *expr_end = p;\n\t    }\n\t}\n    }\n\n    return p;\n}\n\n/*\n * Expands out the 'magic' {}'s in a variable/function name.\n * Note that this can call itself recursively, to deal with\n * constructs like foo{bar}{baz}{bam}\n * The four pointer arguments point to \"foo{expre}ss{ion}bar\"\n *\t\t\t\"in_start\"      ^\n *\t\t\t\"expr_start\"\t   ^\n *\t\t\t\"expr_end\"\t\t ^\n *\t\t\t\"in_end\"\t\t\t    ^\n *\n * Returns a new allocated string, which the caller must free.\n * Returns NULL for failure.\n */\n    static char_u *\nmake_expanded_name(\n    char_u\t*in_start,\n    char_u\t*expr_start,\n    char_u\t*expr_end,\n    char_u\t*in_end)\n{\n    char_u\tc1;\n    char_u\t*retval = NULL;\n    char_u\t*temp_result;\n\n    if (expr_end == NULL || in_end == NULL)\n\treturn NULL;\n    *expr_start\t= NUL;\n    *expr_end = NUL;\n    c1 = *in_end;\n    *in_end = NUL;\n\n    temp_result = eval_to_string(expr_start + 1, FALSE);\n    if (temp_result != NULL)\n    {\n\tretval = alloc(STRLEN(temp_result) + (expr_start - in_start)\n\t\t\t\t\t\t   + (in_end - expr_end) + 1);\n\tif (retval != NULL)\n\t{\n\t    STRCPY(retval, in_start);\n\t    STRCAT(retval, temp_result);\n\t    STRCAT(retval, expr_end + 1);\n\t}\n    }\n    vim_free(temp_result);\n\n    *in_end = c1;\t\t// put char back for error messages\n    *expr_start = '{';\n    *expr_end = '}';\n\n    if (retval != NULL)\n    {\n\ttemp_result = find_name_end(retval, &expr_start, &expr_end, 0);\n\tif (expr_start != NULL)\n\t{\n\t    // Further expansion!\n\t    temp_result = make_expanded_name(retval, expr_start,\n\t\t\t\t\t\t       expr_end, temp_result);\n\t    vim_free(retval);\n\t    retval = temp_result;\n\t}\n    }\n\n    return retval;\n}\n\n/*\n * Return TRUE if character \"c\" can be used in a variable or function name.\n * Does not include '{' or '}' for magic braces.\n */\n    int\neval_isnamec(int c)\n{\n    return ASCII_ISALNUM(c) || c == '_' || c == ':' || c == AUTOLOAD_CHAR;\n}\n\n/*\n * Return TRUE if character \"c\" can be used as the first character in a\n * variable or function name (excluding '{' and '}').\n */\n    int\neval_isnamec1(int c)\n{\n    return ASCII_ISALPHA(c) || c == '_';\n}\n\n/*\n * Return TRUE if character \"c\" can be used as the first character of a\n * dictionary key.\n */\n    int\neval_isdictc(int c)\n{\n    return ASCII_ISALNUM(c) || c == '_';\n}\n\n/*\n * Handle:\n * - expr[expr], expr[expr:expr] subscript\n * - \".name\" lookup\n * - function call with Funcref variable: func(expr)\n * - method call: var->method()\n *\n * Can all be combined in any order: dict.func(expr)[idx]['func'](expr)->len()\n * \"name_start\" points to a variable before the subscript or is NULL.\n */\n    int\nhandle_subscript(\n    char_u\t**arg,\n    char_u\t*name_start,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t// give error messages\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    int\t\tret = OK;\n    dict_T\t*selfdict = NULL;\n    int\t\tcheck_white = TRUE;\n    int\t\tgetnext;\n    char_u\t*p;\n\n    while (ret == OK)\n    {\n\t// When at the end of the line and \".name\" or \"->{\" or \"->X\" follows in\n\t// the next line then consume the line break.\n\tp = eval_next_non_blank(*arg, evalarg, &getnext);\n\tif (getnext\n\t    && ((rettv->v_type == VAR_DICT && *p == '.' && eval_isdictc(p[1]))\n\t\t|| (p[0] == '-' && p[1] == '>' && (p[2] == '{'\n\t\t\t|| ASCII_ISALPHA(in_vim9script() ? *skipwhite(p + 2)\n\t\t\t\t\t\t\t\t    : p[2])))))\n\t{\n\t    *arg = eval_next_line(*arg, evalarg);\n\t    p = *arg;\n\t    check_white = FALSE;\n\t}\n\n\tif (rettv->v_type == VAR_ANY)\n\t{\n\t    char_u\t*exp_name;\n\t    int\t\tcc;\n\t    int\t\tidx;\n\t    ufunc_T\t*ufunc;\n\t    type_T\t*type;\n\n\t    // Found script from \"import {name} as name\", script item name must\n\t    // follow.  \"rettv->vval.v_number\" has the script ID.\n\t    if (**arg != '.')\n\t    {\n\t\tif (verbose)\n\t\t    semsg(_(e_expected_dot_after_name_str),\n\t\t\t\t\tname_start != NULL ? name_start: *arg);\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t    ++*arg;\n\t    if (IS_WHITE_OR_NUL(**arg))\n\t    {\n\t\tif (verbose)\n\t\t    emsg(_(e_no_white_space_allowed_after_dot));\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\n\t    // isolate the name\n\t    exp_name = *arg;\n\t    while (eval_isnamec(**arg))\n\t\t++*arg;\n\t    cc = **arg;\n\t    **arg = NUL;\n\n\t    idx = find_exported(rettv->vval.v_number, exp_name, &ufunc, &type,\n\t\t\t    evalarg->eval_cctx, evalarg->eval_cstack, verbose);\n\t    **arg = cc;\n\n\t    if (idx < 0 && ufunc == NULL)\n\t    {\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t    if (idx >= 0)\n\t    {\n\t\tscriptitem_T    *si = SCRIPT_ITEM(rettv->vval.v_number);\n\t\tsvar_T\t\t*sv = ((svar_T *)si->sn_var_vals.ga_data) + idx;\n\n\t\tcopy_tv(sv->sv_tv, rettv);\n\t    }\n\t    else\n\t    {\n\t\trettv->v_type = VAR_FUNC;\n\t\trettv->vval.v_string = vim_strsave(ufunc->uf_name);\n\t    }\n\t    continue;\n\t}\n\n\tif ((**arg == '(' && (!evaluate || rettv->v_type == VAR_FUNC\n\t\t\t    || rettv->v_type == VAR_PARTIAL))\n\t\t    && (!check_white || !VIM_ISWHITE(*(*arg - 1))))\n\t{\n\t    ret = call_func_rettv(arg, evalarg, rettv, evaluate,\n\t\t\t\t\t\t\t       selfdict, NULL);\n\n\t    // Stop the expression evaluation when immediately aborting on\n\t    // error, or when an interrupt occurred or an exception was thrown\n\t    // but not caught.\n\t    if (aborting())\n\t    {\n\t\tif (ret == OK)\n\t\t    clear_tv(rettv);\n\t\tret = FAIL;\n\t    }\n\t    dict_unref(selfdict);\n\t    selfdict = NULL;\n\t}\n\telse if (p[0] == '-' && p[1] == '>')\n\t{\n\t    if (in_vim9script())\n\t\t*arg = skipwhite(p + 2);\n\t    else\n\t\t*arg = p + 2;\n\t    if (ret == OK)\n\t    {\n\t\tif (VIM_ISWHITE(**arg))\n\t\t{\n\t\t    emsg(_(e_no_white_space_allowed_before_parenthesis));\n\t\t    ret = FAIL;\n\t\t}\n\t\telse if ((**arg == '{' && !in_vim9script()) || **arg == '(')\n\t\t    // expr->{lambda}() or expr->(lambda)()\n\t\t    ret = eval_lambda(arg, rettv, evalarg, verbose);\n\t\telse\n\t\t    // expr->name()\n\t\t    ret = eval_method(arg, rettv, evalarg, verbose);\n\t    }\n\t}\n\t// \".\" is \".name\" lookup when we found a dict or when evaluating and\n\t// scriptversion is at least 2, where string concatenation is \"..\".\n\telse if (**arg == '['\n\t\t|| (**arg == '.' && (rettv->v_type == VAR_DICT\n\t\t\t|| (!evaluate\n\t\t\t    && (*arg)[1] != '.'\n\t\t\t    && !in_old_script(2)))))\n\t{\n\t    dict_unref(selfdict);\n\t    if (rettv->v_type == VAR_DICT)\n\t    {\n\t\tselfdict = rettv->vval.v_dict;\n\t\tif (selfdict != NULL)\n\t\t    ++selfdict->dv_refcount;\n\t    }\n\t    else\n\t\tselfdict = NULL;\n\t    if (eval_index(arg, rettv, evalarg, verbose) == FAIL)\n\t    {\n\t\tclear_tv(rettv);\n\t\tret = FAIL;\n\t    }\n\t}\n\telse\n\t    break;\n    }\n\n    // Turn \"dict.Func\" into a partial for \"Func\" bound to \"dict\".\n    // Don't do this when \"Func\" is already a partial that was bound\n    // explicitly (pt_auto is FALSE).\n    if (selfdict != NULL\n\t    && (rettv->v_type == VAR_FUNC\n\t\t|| (rettv->v_type == VAR_PARTIAL\n\t\t    && (rettv->vval.v_partial->pt_auto\n\t\t\t|| rettv->vval.v_partial->pt_dict == NULL))))\n\tselfdict = make_partial(selfdict, rettv);\n\n    dict_unref(selfdict);\n    return ret;\n}\n\n/*\n * Make a copy of an item.\n * Lists and Dictionaries are also copied.  A deep copy if \"deep\" is set.\n * \"top\" is TRUE for the toplevel of copy().\n * For deepcopy() \"copyID\" is zero for a full copy or the ID for when a\n * reference to an already copied list/dict can be used.\n * Returns FAIL or OK.\n */\n    int\nitem_copy(\n    typval_T\t*from,\n    typval_T\t*to,\n    int\t\tdeep,\n    int\t\ttop,\n    int\t\tcopyID)\n{\n    static int\trecurse = 0;\n    int\t\tret = OK;\n\n    if (recurse >= DICT_MAXNEST)\n    {\n\temsg(_(e_variable_nested_too_deep_for_making_copy));\n\treturn FAIL;\n    }\n    ++recurse;\n\n    switch (from->v_type)\n    {\n\tcase VAR_NUMBER:\n\tcase VAR_FLOAT:\n\tcase VAR_STRING:\n\tcase VAR_FUNC:\n\tcase VAR_PARTIAL:\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\tcase VAR_JOB:\n\tcase VAR_CHANNEL:\n\tcase VAR_INSTR:\n\t    copy_tv(from, to);\n\t    break;\n\tcase VAR_LIST:\n\t    to->v_type = VAR_LIST;\n\t    to->v_lock = 0;\n\t    if (from->vval.v_list == NULL)\n\t\tto->vval.v_list = NULL;\n\t    else if (copyID != 0 && from->vval.v_list->lv_copyID == copyID)\n\t    {\n\t\t// use the copy made earlier\n\t\tto->vval.v_list = from->vval.v_list->lv_copylist;\n\t\t++to->vval.v_list->lv_refcount;\n\t    }\n\t    else\n\t\tto->vval.v_list = list_copy(from->vval.v_list,\n\t\t\t\t\t\t\t    deep, top, copyID);\n\t    if (to->vval.v_list == NULL)\n\t\tret = FAIL;\n\t    break;\n\tcase VAR_BLOB:\n\t    ret = blob_copy(from->vval.v_blob, to);\n\t    break;\n\tcase VAR_DICT:\n\t    to->v_type = VAR_DICT;\n\t    to->v_lock = 0;\n\t    if (from->vval.v_dict == NULL)\n\t\tto->vval.v_dict = NULL;\n\t    else if (copyID != 0 && from->vval.v_dict->dv_copyID == copyID)\n\t    {\n\t\t// use the copy made earlier\n\t\tto->vval.v_dict = from->vval.v_dict->dv_copydict;\n\t\t++to->vval.v_dict->dv_refcount;\n\t    }\n\t    else\n\t\tto->vval.v_dict = dict_copy(from->vval.v_dict,\n\t\t\t\t\t\t\t    deep, top, copyID);\n\t    if (to->vval.v_dict == NULL)\n\t\tret = FAIL;\n\t    break;\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\t    internal_error_no_abort(\"item_copy(UNKNOWN)\");\n\t    ret = FAIL;\n    }\n    --recurse;\n    return ret;\n}\n\n    void\necho_one(typval_T *rettv, int with_space, int *atstart, int *needclr)\n{\n    char_u\t*tofree;\n    char_u\tnumbuf[NUMBUFLEN];\n    char_u\t*p = echo_string(rettv, &tofree, numbuf, get_copyID());\n\n    if (*atstart)\n    {\n\t*atstart = FALSE;\n\t// Call msg_start() after eval1(), evaluating the expression\n\t// may cause a message to appear.\n\tif (with_space)\n\t{\n\t    // Mark the saved text as finishing the line, so that what\n\t    // follows is displayed on a new line when scrolling back\n\t    // at the more prompt.\n\t    msg_sb_eol();\n\t    msg_start();\n\t}\n    }\n    else if (with_space)\n\tmsg_puts_attr(\" \", echo_attr);\n\n    if (p != NULL)\n\tfor ( ; *p != NUL && !got_int; ++p)\n\t{\n\t    if (*p == '\\n' || *p == '\\r' || *p == TAB)\n\t    {\n\t\tif (*p != TAB && *needclr)\n\t\t{\n\t\t    // remove any text still there from the command\n\t\t    msg_clr_eos();\n\t\t    *needclr = FALSE;\n\t\t}\n\t\tmsg_putchar_attr(*p, echo_attr);\n\t    }\n\t    else\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    int i = (*mb_ptr2len)(p);\n\n\t\t    (void)msg_outtrans_len_attr(p, i, echo_attr);\n\t\t    p += i - 1;\n\t\t}\n\t\telse\n\t\t    (void)msg_outtrans_len_attr(p, 1, echo_attr);\n\t    }\n\t}\n    vim_free(tofree);\n}\n\n/*\n * \":echo expr1 ...\"\tprint each argument separated with a space, add a\n *\t\t\tnewline at the end.\n * \":echon expr1 ...\"\tprint each argument plain.\n */\n    void\nex_echo(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    typval_T\trettv;\n    char_u\t*arg_start;\n    int\t\tneedclr = TRUE;\n    int\t\tatstart = TRUE;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tcalled_emsg_before = called_emsg;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, eap->skip);\n\n    if (eap->skip)\n\t++emsg_skip;\n    while ((!ends_excmd2(eap->cmd, arg) || *arg == '\"') && !got_int)\n    {\n\t// If eval1() causes an error message the text from the command may\n\t// still need to be cleared. E.g., \"echo 22,44\".\n\tneed_clr_eos = needclr;\n\n\targ_start = arg;\n\tif (eval1(&arg, &rettv, &evalarg) == FAIL)\n\t{\n\t    /*\n\t     * Report the invalid expression unless the expression evaluation\n\t     * has been cancelled due to an aborting error, an interrupt, or an\n\t     * exception.\n\t     */\n\t    if (!aborting() && did_emsg == did_emsg_before\n\t\t\t\t\t  && called_emsg == called_emsg_before)\n\t\tsemsg(_(e_invalid_expression_str), arg_start);\n\t    need_clr_eos = FALSE;\n\t    break;\n\t}\n\tneed_clr_eos = FALSE;\n\n\tif (!eap->skip)\n\t{\n\t    if (rettv.v_type == VAR_VOID)\n\t    {\n\t\tsemsg(_(e_expression_does_not_result_in_value_str), arg_start);\n\t\tbreak;\n\t    }\n\t    echo_one(&rettv, eap->cmdidx == CMD_echo, &atstart, &needclr);\n\t}\n\n\tclear_tv(&rettv);\n\targ = skipwhite(arg);\n    }\n    set_nextcmd(eap, arg);\n    clear_evalarg(&evalarg, eap);\n\n    if (eap->skip)\n\t--emsg_skip;\n    else\n    {\n\t// remove text that may still be there from the command\n\tif (needclr)\n\t    msg_clr_eos();\n\tif (eap->cmdidx == CMD_echo)\n\t    msg_end();\n    }\n}\n\n/*\n * \":echohl {name}\".\n */\n    void\nex_echohl(exarg_T *eap)\n{\n    echo_attr = syn_name2attr(eap->arg);\n}\n\n/*\n * Returns the :echo attribute\n */\n    int\nget_echo_attr(void)\n{\n    return echo_attr;\n}\n\n/*\n * \":execute expr1 ...\"\texecute the result of an expression.\n * \":echomsg expr1 ...\"\tPrint a message\n * \":echoerr expr1 ...\"\tPrint an error\n * \":echoconsole expr1 ...\" Print a message on stdout\n * Each gets spaces around each argument and a newline at the end for\n * echo commands\n */\n    void\nex_execute(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    typval_T\trettv;\n    int\t\tret = OK;\n    char_u\t*p;\n    garray_T\tga;\n    int\t\tlen;\n    long\tstart_lnum = SOURCING_LNUM;\n\n    ga_init2(&ga, 1, 80);\n\n    if (eap->skip)\n\t++emsg_skip;\n    while (!ends_excmd2(eap->cmd, arg) || *arg == '\"')\n    {\n\tret = eval1_emsg(&arg, &rettv, eap);\n\tif (ret == FAIL)\n\t    break;\n\n\tif (!eap->skip)\n\t{\n\t    char_u   buf[NUMBUFLEN];\n\n\t    if (eap->cmdidx == CMD_execute)\n\t    {\n\t\tif (rettv.v_type == VAR_CHANNEL || rettv.v_type == VAR_JOB)\n\t\t{\n\t\t    semsg(_(e_using_invalid_value_as_string_str),\n\t\t\t\t\t\t  vartype_name(rettv.v_type));\n\t\t    p = NULL;\n\t\t}\n\t\telse\n\t\t    p = tv_get_string_buf(&rettv, buf);\n\t    }\n\t    else\n\t\tp = tv_stringify(&rettv, buf);\n\t    if (p == NULL)\n\t    {\n\t\tclear_tv(&rettv);\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t    len = (int)STRLEN(p);\n\t    if (ga_grow(&ga, len + 2) == FAIL)\n\t    {\n\t\tclear_tv(&rettv);\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t    if (ga.ga_len)\n\t\t((char_u *)(ga.ga_data))[ga.ga_len++] = ' ';\n\t    STRCPY((char_u *)(ga.ga_data) + ga.ga_len, p);\n\t    ga.ga_len += len;\n\t}\n\n\tclear_tv(&rettv);\n\targ = skipwhite(arg);\n    }\n\n    if (ret != FAIL && ga.ga_data != NULL)\n    {\n\t// use the first line of continuation lines for messages\n\tSOURCING_LNUM = start_lnum;\n\n\tif (eap->cmdidx == CMD_echomsg || eap->cmdidx == CMD_echoerr)\n\t{\n\t    // Mark the already saved text as finishing the line, so that what\n\t    // follows is displayed on a new line when scrolling back at the\n\t    // more prompt.\n\t    msg_sb_eol();\n\t}\n\n\tif (eap->cmdidx == CMD_echomsg)\n\t{\n\t    msg_attr(ga.ga_data, echo_attr);\n\t    out_flush();\n\t}\n\telse if (eap->cmdidx == CMD_echoconsole)\n\t{\n\t    ui_write(ga.ga_data, (int)STRLEN(ga.ga_data), TRUE);\n\t    ui_write((char_u *)\"\\r\\n\", 2, TRUE);\n\t}\n\telse if (eap->cmdidx == CMD_echoerr)\n\t{\n\t    int\t\tsave_did_emsg = did_emsg;\n\n\t    // We don't want to abort following commands, restore did_emsg.\n\t    emsg(ga.ga_data);\n\t    if (!force_abort)\n\t\tdid_emsg = save_did_emsg;\n\t}\n\telse if (eap->cmdidx == CMD_execute)\n\t{\n\t    int save_sticky_cmdmod_flags = sticky_cmdmod_flags;\n\n\t    // \"legacy exe cmd\" and \"vim9cmd exe cmd\" applies to \"cmd\".\n\t    sticky_cmdmod_flags = cmdmod.cmod_flags\n\t\t\t\t\t\t& (CMOD_LEGACY | CMOD_VIM9CMD);\n\t    do_cmdline((char_u *)ga.ga_data,\n\t\t       eap->getline, eap->cookie, DOCMD_NOWAIT|DOCMD_VERBOSE);\n\t    sticky_cmdmod_flags = save_sticky_cmdmod_flags;\n\t}\n    }\n\n    ga_clear(&ga);\n\n    if (eap->skip)\n\t--emsg_skip;\n\n    set_nextcmd(eap, arg);\n}\n\n/*\n * Skip over the name of an option: \"&option\", \"&g:option\" or \"&l:option\".\n * \"arg\" points to the \"&\" or '+' when called, to \"option\" when returning.\n * Returns NULL when no option name found.  Otherwise pointer to the char\n * after the option name.\n */\n    char_u *\nfind_option_end(char_u **arg, int *scope)\n{\n    char_u\t*p = *arg;\n\n    ++p;\n    if (*p == 'g' && p[1] == ':')\n    {\n\t*scope = OPT_GLOBAL;\n\tp += 2;\n    }\n    else if (*p == 'l' && p[1] == ':')\n    {\n\t*scope = OPT_LOCAL;\n\tp += 2;\n    }\n    else\n\t*scope = 0;\n\n    if (!ASCII_ISALPHA(*p))\n\treturn NULL;\n    *arg = p;\n\n    if (p[0] == 't' && p[1] == '_' && p[2] != NUL && p[3] != NUL)\n\tp += 4;\t    // termcap option\n    else\n\twhile (ASCII_ISALPHA(*p))\n\t    ++p;\n    return p;\n}\n\n/*\n * Display script name where an item was last set.\n * Should only be invoked when 'verbose' is non-zero.\n */\n    void\nlast_set_msg(sctx_T script_ctx)\n{\n    char_u *p;\n\n    if (script_ctx.sc_sid != 0)\n    {\n\tp = home_replace_save(NULL, get_scriptname(script_ctx.sc_sid));\n\tif (p != NULL)\n\t{\n\t    verbose_enter();\n\t    msg_puts(_(\"\\n\\tLast set from \"));\n\t    msg_puts((char *)p);\n\t    if (script_ctx.sc_lnum > 0)\n\t    {\n\t\tmsg_puts(_(line_msg));\n\t\tmsg_outnum((long)script_ctx.sc_lnum);\n\t    }\n\t    verbose_leave();\n\t    vim_free(p);\n\t}\n    }\n}\n\n#endif // FEAT_EVAL\n\n/*\n * Perform a substitution on \"str\" with pattern \"pat\" and substitute \"sub\".\n * When \"sub\" is NULL \"expr\" is used, must be a VAR_FUNC or VAR_PARTIAL.\n * \"flags\" can be \"g\" to do a global substitute.\n * Returns an allocated string, NULL for error.\n */\n    char_u *\ndo_string_sub(\n    char_u\t*str,\n    char_u\t*pat,\n    char_u\t*sub,\n    typval_T\t*expr,\n    char_u\t*flags)\n{\n    int\t\tsublen;\n    regmatch_T\tregmatch;\n    int\t\ti;\n    int\t\tdo_all;\n    char_u\t*tail;\n    char_u\t*end;\n    garray_T\tga;\n    char_u\t*ret;\n    char_u\t*save_cpo;\n    char_u\t*zero_width = NULL;\n\n    // Make 'cpoptions' empty, so that the 'l' flag doesn't work here\n    save_cpo = p_cpo;\n    p_cpo = empty_option;\n\n    ga_init2(&ga, 1, 200);\n\n    do_all = (flags[0] == 'g');\n\n    regmatch.rm_ic = p_ic;\n    regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);\n    if (regmatch.regprog != NULL)\n    {\n\ttail = str;\n\tend = str + STRLEN(str);\n\twhile (vim_regexec_nl(&regmatch, str, (colnr_T)(tail - str)))\n\t{\n\t    // Skip empty match except for first match.\n\t    if (regmatch.startp[0] == regmatch.endp[0])\n\t    {\n\t\tif (zero_width == regmatch.startp[0])\n\t\t{\n\t\t    // avoid getting stuck on a match with an empty string\n\t\t    i = mb_ptr2len(tail);\n\t\t    mch_memmove((char_u *)ga.ga_data + ga.ga_len, tail,\n\t\t\t\t\t\t\t\t   (size_t)i);\n\t\t    ga.ga_len += i;\n\t\t    tail += i;\n\t\t    continue;\n\t\t}\n\t\tzero_width = regmatch.startp[0];\n\t    }\n\n\t    /*\n\t     * Get some space for a temporary buffer to do the substitution\n\t     * into.  It will contain:\n\t     * - The text up to where the match is.\n\t     * - The substituted text.\n\t     * - The text after the match.\n\t     */\n\t    sublen = vim_regsub(&regmatch, sub, expr, tail, 0, REGSUB_MAGIC);\n\t    if (ga_grow(&ga, (int)((end - tail) + sublen -\n\t\t\t    (regmatch.endp[0] - regmatch.startp[0]))) == FAIL)\n\t    {\n\t\tga_clear(&ga);\n\t\tbreak;\n\t    }\n\n\t    // copy the text up to where the match is\n\t    i = (int)(regmatch.startp[0] - tail);\n\t    mch_memmove((char_u *)ga.ga_data + ga.ga_len, tail, (size_t)i);\n\t    // add the substituted text\n\t    (void)vim_regsub(&regmatch, sub, expr,\n\t\t\t\t  (char_u *)ga.ga_data + ga.ga_len + i, sublen,\n\t\t\t\t  REGSUB_COPY | REGSUB_MAGIC);\n\t    ga.ga_len += i + sublen - 1;\n\t    tail = regmatch.endp[0];\n\t    if (*tail == NUL)\n\t\tbreak;\n\t    if (!do_all)\n\t\tbreak;\n\t}\n\n\tif (ga.ga_data != NULL)\n\t    STRCPY((char *)ga.ga_data + ga.ga_len, tail);\n\n\tvim_regfree(regmatch.regprog);\n    }\n\n    ret = vim_strsave(ga.ga_data == NULL ? str : (char_u *)ga.ga_data);\n    ga_clear(&ga);\n    if (p_cpo == empty_option)\n\tp_cpo = save_cpo;\n    else\n    {\n\t// Darn, evaluating {sub} expression or {expr} changed the value.\n\t// If it's still empty it was changed and restored, need to restore in\n\t// the complicated way.\n\tif (*p_cpo == NUL)\n\t    set_option_value_give_err((char_u *)\"cpo\", 0L, save_cpo, 0);\n\tfree_string_option(save_cpo);\n    }\n\n    return ret;\n}\n", "\" Test various aspects of the Vim script language.\n\" Most of this was formerly in test49.vim (developed by Servatius Brandt\n\" <Servatius.Brandt@fujitsu-siemens.com>)\n\nsource check.vim\nsource shared.vim\nsource script_util.vim\n\n\"-------------------------------------------------------------------------------\n\" Test environment\t\t\t\t\t\t\t    {{{1\n\"-------------------------------------------------------------------------------\n\n\" Append a message to the \"messages\" file\nfunc Xout(text)\n    split messages\n    $put =a:text\n    wq\nendfunc\n\ncom! -nargs=1\t     Xout     call Xout(<args>)\n\n\" Create a new instance of Vim and run the commands in 'test' and then 'verify'\n\" The commands in 'test' are expected to store the test results in the Xtest.out\n\" file. If the test passes successfully, then Xtest.out should be empty.\nfunc RunInNewVim(test, verify)\n  let init =<< trim END\n    set cpo-=C            \" support line-continuation in sourced script\n    source script_util.vim\n    XpathINIT\n    XloopINIT\n  END\n  let cleanup =<< trim END\n    call writefile(v:errors, 'Xtest.out')\n    qall\n  END\n  call writefile(init, 'Xtest.vim')\n  call writefile(a:test, 'Xtest.vim', 'a')\n  call writefile(a:verify, 'Xverify.vim')\n  call writefile(cleanup, 'Xverify.vim', 'a')\n  call RunVim([], [], \"-S Xtest.vim -S Xverify.vim\")\n  call assert_equal([], readfile('Xtest.out'))\n  call delete('Xtest.out')\n  call delete('Xtest.vim')\n  call delete('Xverify.vim')\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 1:   :endwhile in function\t\t\t\t\t    {{{1\n\"\n\"\t    Detect if a broken loop is (incorrectly) reactivated by the\n\"\t    :endwhile.  Use a :return to prevent an endless loop, and make\n\"\t    this test first to get a meaningful result on an error before other\n\"\t    tests will hang.\n\"-------------------------------------------------------------------------------\n\nfunc T1_F()\n    Xpath 'a'\n    let first = 1\n    while 1\n\tXpath 'b'\n\tif first\n\t    Xpath 'c'\n\t    let first = 0\n\t    break\n\telse\n\t    Xpath 'd'\n\t    return\n\tendif\n    endwhile\nendfunc\n\nfunc T1_G()\n    Xpath 'h'\n    let first = 1\n    while 1\n\tXpath 'i'\n\tif first\n\t    Xpath 'j'\n\t    let first = 0\n\t    break\n\telse\n\t    Xpath 'k'\n\t    return\n\tendif\n\tif 1\t\" unmatched :if\n    endwhile\nendfunc\n\nfunc Test_endwhile_function()\n  XpathINIT\n  call T1_F()\n  Xpath 'F'\n\n  try\n    call T1_G()\n  catch\n    \" Catch missing :endif\n    call assert_true(v:exception =~ 'E171:')\n    Xpath 'x'\n  endtry\n  Xpath 'G'\n\n  call assert_equal('abcFhijxG', g:Xpath)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 2:   :endwhile in script\t\t\t\t\t\t    {{{1\n\"\n\"\t    Detect if a broken loop is (incorrectly) reactivated by the\n\"\t    :endwhile.  Use a :finish to prevent an endless loop, and place\n\"\t    this test before others that might hang to get a meaningful result\n\"\t    on an error.\n\"\n\"\t    This test executes the bodies of the functions T1_F and T1_G from\n\"\t    the previous test as script files (:return replaced by :finish).\n\"-------------------------------------------------------------------------------\n\nfunc Test_endwhile_script()\n  XpathINIT\n  ExecAsScript T1_F\n  Xpath 'F'\n  call DeleteTheScript()\n\n  try\n    ExecAsScript T1_G\n  catch\n    \" Catch missing :endif\n    call assert_true(v:exception =~ 'E171:')\n    Xpath 'x'\n  endtry\n  Xpath 'G'\n  call DeleteTheScript()\n\n  call assert_equal('abcFhijxG', g:Xpath)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 3:   :if, :elseif, :while, :continue, :break\t\t\t    {{{1\n\"-------------------------------------------------------------------------------\n\nfunc Test_if_while()\n    XpathINIT\n    if 1\n\tXpath 'a'\n\tlet loops = 3\n\twhile loops > -1\t    \" main loop: loops == 3, 2, 1 (which breaks)\n\t    if loops <= 0\n\t\tlet break_err = 1\n\t\tlet loops = -1\n\t    else\n\t\tXpath 'b' . loops\n\t    endif\n\t    if (loops == 2)\n\t\twhile loops == 2 \" dummy loop\n\t\t    Xpath 'c' . loops\n\t\t    let loops = loops - 1\n\t\t    continue    \" stop dummy loop\n\t\t    Xpath 'd' . loops\n\t\tendwhile\n\t\tcontinue\t    \" continue main loop\n\t\tXpath 'e' . loops\n\t    elseif (loops == 1)\n\t\tlet p = 1\n\t\twhile p\t    \" dummy loop\n\t\t    Xpath 'f' . loops\n\t\t    let p = 0\n\t\t    break\t    \" break dummy loop\n\t\t    Xpath 'g' . loops\n\t\tendwhile\n\t\tXpath 'h' . loops\n\t\tunlet p\n\t\tbreak\t    \" break main loop\n\t\tXpath 'i' . loops\n\t    endif\n\t    if (loops > 0)\n\t\tXpath 'j' . loops\n\t    endif\n\t    while loops == 3    \" dummy loop\n\t\tlet loops = loops - 1\n\t    endwhile\t    \" end dummy loop\n\tendwhile\t\t    \" end main loop\n\tXpath 'k'\n    else\n\tXpath 'l'\n    endif\n    Xpath 'm'\n    if exists(\"break_err\")\n\tXpath 'm'\n\tunlet break_err\n    endif\n\n    unlet loops\n\n    call assert_equal('ab3j3b2c2b1f1h1km', g:Xpath)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 4:   :return\t\t\t\t\t\t\t    {{{1\n\"-------------------------------------------------------------------------------\n\nfunc T4_F()\n    if 1\n\tXpath 'a'\n\tlet loops = 3\n\twhile loops > 0\t\t\t\t\"    3:  2:     1:\n\t    Xpath 'b' . loops\n\t    if (loops == 2)\n\t\tXpath 'c' . loops\n\t\treturn\n\t\tXpath 'd' . loops\n\t    endif\n\t    Xpath 'e' . loops\n\t    let loops = loops - 1\n\tendwhile\n\tXpath 'f'\n    else\n\tXpath 'g'\n    endif\nendfunc\n\nfunc Test_return()\n    XpathINIT\n    call T4_F()\n    Xpath '4'\n\n    call assert_equal('ab3e3b2c24', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 5:   :finish\t\t\t\t\t\t\t    {{{1\n\"\n\"\t    This test executes the body of the function T4_F from the previous\n\"\t    test as a script file (:return replaced by :finish).\n\"-------------------------------------------------------------------------------\n\nfunc Test_finish()\n    XpathINIT\n    ExecAsScript T4_F\n    Xpath '5'\n    call DeleteTheScript()\n\n    call assert_equal('ab3e3b2c25', g:Xpath)\nendfunc\n\n\n\n\"-------------------------------------------------------------------------------\n\" Test 6:   Defining functions in :while loops\t\t\t\t    {{{1\n\"\n\"\t     Functions can be defined inside other functions.  An inner function\n\"\t     gets defined when the outer function is executed.  Functions may\n\"\t     also be defined inside while loops.  Expressions in braces for\n\"\t     defining the function name are allowed.\n\"\n\"\t     The functions are defined when sourcing the script, only the\n\"\t     resulting path is checked in the test function.\n\"-------------------------------------------------------------------------------\n\nXpathINIT\n\n\" The command CALL collects the argument of all its invocations in \"calls\"\n\" when used from a function (that is, when the global variable \"calls\" needs\n\" the \"g:\" prefix).  This is to check that the function code is skipped when\n\" the function is defined.  For inner functions, do so only if the outer\n\" function is not being executed.\n\"\nlet calls = \"\"\ncom! -nargs=1 CALL\n\t    \\ if !exists(\"calls\") && !exists(\"outer\") |\n\t    \\ let g:calls = g:calls . <args> |\n\t    \\ endif\n\nlet i = 0\nwhile i < 3\n    let i = i + 1\n    if i == 1\n\tXpath 'a'\n\tfunction! F1(arg)\n\t    CALL a:arg\n\t    let outer = 1\n\n\t    let j = 0\n\t    while j < 1\n\t\tXpath 'b'\n\t\tlet j = j + 1\n\t\tfunction! G1(arg)\n\t\t    CALL a:arg\n\t\tendfunction\n\t\tXpath 'c'\n\t    endwhile\n\tendfunction\n\tXpath 'd'\n\n\tcontinue\n    endif\n\n    Xpath 'e' . i\n    function! F{i}(i, arg)\n\tCALL a:arg\n\tlet outer = 1\n\n\tif a:i == 3\n\t    Xpath 'f'\n\tendif\n\tlet k = 0\n\twhile k < 3\n\t    Xpath 'g' . k\n\t    let k = k + 1\n\t    function! G{a:i}{k}(arg)\n\t\tCALL a:arg\n\t    endfunction\n\t    Xpath 'h' . k\n\tendwhile\n    endfunction\n    Xpath 'i'\n\nendwhile\n\nif exists(\"*G1\")\n    Xpath 'j'\nendif\nif exists(\"*F1\")\n    call F1(\"F1\")\n    if exists(\"*G1\")\n       call G1(\"G1\")\n    endif\nendif\n\nif exists(\"G21\") || exists(\"G22\") || exists(\"G23\")\n    Xpath 'k'\nendif\nif exists(\"*F2\")\n    call F2(2, \"F2\")\n    if exists(\"*G21\")\n       call G21(\"G21\")\n    endif\n    if exists(\"*G22\")\n       call G22(\"G22\")\n    endif\n    if exists(\"*G23\")\n       call G23(\"G23\")\n    endif\nendif\n\nif exists(\"G31\") || exists(\"G32\") || exists(\"G33\")\n    Xpath 'l'\nendif\nif exists(\"*F3\")\n    call F3(3, \"F3\")\n    if exists(\"*G31\")\n       call G31(\"G31\")\n    endif\n    if exists(\"*G32\")\n       call G32(\"G32\")\n    endif\n    if exists(\"*G33\")\n       call G33(\"G33\")\n    endif\nendif\n\nXpath 'm'\n\nlet g:test6_result = g:Xpath\nlet g:test6_calls = calls\n\nunlet calls\ndelfunction F1\ndelfunction G1\ndelfunction F2\ndelfunction G21\ndelfunction G22\ndelfunction G23\ndelfunction G31\ndelfunction G32\ndelfunction G33\n\nfunc Test_defining_functions()\n    call assert_equal('ade2ie3ibcg0h1g1h2g2h3fg0h1g1h2g2h3m', g:test6_result)\n    call assert_equal('F1G1F2G21G22G23F3G31G32G33', g:test6_calls)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 7:   Continuing on errors outside functions\t\t\t    {{{1\n\"\n\"\t    On an error outside a function, the script processing continues\n\"\t    at the line following the outermost :endif or :endwhile.  When not\n\"\t    inside an :if or :while, the script processing continues at the next\n\"\t    line.\n\"-------------------------------------------------------------------------------\n\nXpathINIT\n\nif 1\n    Xpath 'a'\n    while 1\n\tXpath 'b'\n\tasdf\n\tXpath 'c'\n\tbreak\n    endwhile | Xpath 'd'\n    Xpath 'e'\nendif | Xpath 'f'\nXpath 'g'\n\nwhile 1\n    Xpath 'h'\n    if 1\n\tXpath 'i'\n\tasdf\n\tXpath 'j'\n    endif | Xpath 'k'\n    Xpath 'l'\n    break\nendwhile | Xpath 'm'\nXpath 'n'\n\nasdf\nXpath 'o'\n\nasdf | Xpath 'p'\nXpath 'q'\n\nlet g:test7_result = g:Xpath\n\nfunc Test_error_in_script()\n    call assert_equal('abghinoq', g:test7_result)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 8:   Aborting and continuing on errors inside functions\t\t    {{{1\n\"\n\"\t    On an error inside a function without the \"abort\" attribute, the\n\"\t    script processing continues at the next line (unless the error was\n\"\t    in a :return command).  On an error inside a function with the\n\"\t    \"abort\" attribute, the function is aborted and the script processing\n\"\t    continues after the function call; the value -1 is returned then.\n\"-------------------------------------------------------------------------------\n\nXpathINIT\n\nfunc T8_F()\n    if 1\n\tXpath 'a'\n\twhile 1\n\t    Xpath 'b'\n\t    asdf\n\t    Xpath 'c'\n\t    asdf | Xpath 'd'\n\t    Xpath 'e'\n\t    break\n\tendwhile\n\tXpath 'f'\n    endif | Xpath 'g'\n    Xpath 'h'\n\n    while 1\n\tXpath 'i'\n\tif 1\n\t    Xpath 'j'\n\t    asdf\n\t    Xpath 'k'\n\t    asdf | Xpath 'l'\n\t    Xpath 'm'\n\tendif\n\tXpath 'n'\n\tbreak\n    endwhile | Xpath 'o'\n    Xpath 'p'\n\n    return novar\t\t\" returns (default return value 0)\n    Xpath 'q'\n    return 1\t\t\t\" not reached\nendfunc\n\nfunc T8_G() abort\n    if 1\n\tXpath 'r'\n\twhile 1\n\t    Xpath 's'\n\t    asdf\t\t\" returns -1\n\t    Xpath 't'\n\t    break\n\tendwhile\n\tXpath 'v'\n    endif | Xpath 'w'\n    Xpath 'x'\n\n    return -4\t\t\t\" not reached\nendfunc\n\nfunc T8_H() abort\n    while 1\n\tXpath 'A'\n\tif 1\n\t    Xpath 'B'\n\t    asdf\t\t\" returns -1\n\t    Xpath 'C'\n\tendif\n\tXpath 'D'\n\tbreak\n    endwhile | Xpath 'E'\n    Xpath 'F'\n\n    return -4\t\t\t\" not reached\nendfunc\n\n\" Aborted functions (T8_G and T8_H) return -1.\nlet g:test8_sum = (T8_F() + 1) - 4 * T8_G() - 8 * T8_H()\nXpath 'X'\nlet g:test8_result = g:Xpath\n\nfunc Test_error_in_function()\n    call assert_equal(13, g:test8_sum)\n    call assert_equal('abcefghijkmnoprsABX', g:test8_result)\n\n    delfunction T8_F\n    delfunction T8_G\n    delfunction T8_H\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 9:   Continuing after aborted functions\t\t\t\t    {{{1\n\"\n\"\t    When a function with the \"abort\" attribute is aborted due to an\n\"\t    error, the next function back in the call hierarchy without an\n\"\t    \"abort\" attribute continues; the value -1 is returned then.\n\"-------------------------------------------------------------------------------\n\nXpathINIT\n\nfunc F() abort\n    Xpath 'a'\n    let result = G()\t\" not aborted\n    Xpath 'b'\n    if result != 2\n\tXpath 'c'\n    endif\n    return 1\nendfunc\n\nfunc G()\t\t\" no abort attribute\n    Xpath 'd'\n    if H() != -1\t\" aborted\n\tXpath 'e'\n    endif\n    Xpath 'f'\n    return 2\nendfunc\n\nfunc H() abort\n    Xpath 'g'\n    call I()\t\t\" aborted\n    Xpath 'h'\n    return 4\nendfunc\n\nfunc I() abort\n    Xpath 'i'\n    asdf\t\t\" error\n    Xpath 'j'\n    return 8\nendfunc\n\nif F() != 1\n    Xpath 'k'\nendif\n\nlet g:test9_result = g:Xpath\n\ndelfunction F\ndelfunction G\ndelfunction H\ndelfunction I\n\nfunc Test_func_abort()\n    call assert_equal('adgifb', g:test9_result)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 10:  :if, :elseif, :while argument parsing\t\t\t    {{{1\n\"\n\"\t    A '\"' or '|' in an argument expression must not be mixed up with\n\"\t    a comment or a next command after a bar.  Parsing errors should\n\"\t    be recognized.\n\"-------------------------------------------------------------------------------\n\nXpathINIT\n\nfunc MSG(enr, emsg)\n    let english = v:lang == \"C\" || v:lang =~ '^[Ee]n'\n    if a:enr == \"\"\n\tXout \"TODO: Add message number for:\" a:emsg\n\tlet v:errmsg = \":\" . v:errmsg\n    endif\n    let match = 1\n    if v:errmsg !~ '^'.a:enr.':' || (english && v:errmsg !~ a:emsg)\n\tlet match = 0\n\tif v:errmsg == \"\"\n\t    Xout \"Message missing.\"\n\telse\n\t    let v:errmsg = v:errmsg->escape('\"')\n\t    Xout \"Unexpected message:\" v:errmsg\n\tendif\n    endif\n    return match\nendfunc\n\nif 1 || strlen(\"\\\"\") | Xpath 'a'\n    Xpath 'b'\nendif\nXpath 'c'\n\nif 0\nelseif 1 || strlen(\"\\\"\") | Xpath 'd'\n    Xpath 'e'\nendif\nXpath 'f'\n\nwhile 1 || strlen(\"\\\"\") | Xpath 'g'\n    Xpath 'h'\n    break\nendwhile\nXpath 'i'\n\nlet v:errmsg = \"\"\nif 1 ||| strlen(\"\\\"\") | Xpath 'j'\n    Xpath 'k'\nendif\nXpath 'l'\nif !MSG('E15', \"Invalid expression\")\n    Xpath 'm'\nendif\n\nlet v:errmsg = \"\"\nif 0\nelseif 1 ||| strlen(\"\\\"\") | Xpath 'n'\n    Xpath 'o'\nendif\nXpath 'p'\nif !MSG('E15', \"Invalid expression\")\n    Xpath 'q'\nendif\n\nlet v:errmsg = \"\"\nwhile 1 ||| strlen(\"\\\"\") | Xpath 'r'\n    Xpath 's'\n    break\nendwhile\nXpath 't'\nif !MSG('E15', \"Invalid expression\")\n    Xpath 'u'\nendif\n\nlet g:test10_result = g:Xpath\ndelfunction MSG\n\nfunc Test_expr_parsing()\n    call assert_equal('abcdefghilpt', g:test10_result)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 11:  :if, :elseif, :while argument evaluation after abort\t    {{{1\n\"\n\"\t    When code is skipped over due to an error, the boolean argument to\n\"\t    an :if, :elseif, or :while must not be evaluated.\n\"-------------------------------------------------------------------------------\n\nXpathINIT\n\nlet calls = 0\n\nfunc P(num)\n    let g:calls = g:calls + a:num   \" side effect on call\n    return 0\nendfunc\n\nif 1\n    Xpath 'a'\n    asdf\t\t\" error\n    Xpath 'b'\n    if P(1)\t\t\" should not be called\n\tXpath 'c'\n    elseif !P(2)\t\" should not be called\n\tXpath 'd'\n    else\n\tXpath 'e'\n    endif\n    Xpath 'f'\n    while P(4)\t\t\" should not be called\n\tXpath 'g'\n    endwhile\n    Xpath 'h'\nendif\nXpath 'x'\n\nlet g:test11_calls = calls\nlet g:test11_result = g:Xpath\n\nunlet calls\ndelfunction P\n\nfunc Test_arg_abort()\n    call assert_equal(0, g:test11_calls)\n    call assert_equal('ax', g:test11_result)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 12:  Expressions in braces in skipped code\t\t\t    {{{1\n\"\n\"\t    In code skipped over due to an error or inactive conditional,\n\"\t    an expression in braces as part of a variable or function name\n\"\t    should not be evaluated.\n\"-------------------------------------------------------------------------------\n\nXpathINIT\n\nfunction! NULL()\n    Xpath 'a'\n    return 0\nendfunction\n\nfunction! ZERO()\n    Xpath 'b'\n    return 0\nendfunction\n\nfunction! F0()\n    Xpath 'c'\nendfunction\n\nfunction! F1(arg)\n    Xpath 'e'\nendfunction\n\nlet V0 = 1\n\nXpath 'f'\necho 0 ? F{NULL() + V{ZERO()}}() : 1\n\nXpath 'g'\nif 0\n    Xpath 'h'\n    call F{NULL() + V{ZERO()}}()\nendif\n\nXpath 'i'\nif 1\n    asdf\t\t\" error\n    Xpath 'j'\n    call F1(F{NULL() + V{ZERO()}}())\nendif\n\nXpath 'k'\nif 1\n    asdf\t\t\" error\n    Xpath 'l'\n    call F{NULL() + V{ZERO()}}()\nendif\n\nlet g:test12_result = g:Xpath\n\nfunc Test_braces_skipped()\n    call assert_equal('fgik', g:test12_result)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 13:  Failure in argument evaluation for :while\t\t\t    {{{1\n\"\n\"\t    A failure in the expression evaluation for the condition of a :while\n\"\t    causes the whole :while loop until the matching :endwhile being\n\"\t    ignored.  Continuation is at the next following line.\n\"-------------------------------------------------------------------------------\n\nXpathINIT\n\nXpath 'a'\nwhile asdf\n    Xpath 'b'\n    while 1\n\tXpath 'c'\n\tbreak\n    endwhile\n    Xpath 'd'\n    break\nendwhile\nXpath 'e'\n\nwhile asdf | Xpath 'f' | endwhile | Xpath 'g'\nXpath 'h'\nlet g:test13_result = g:Xpath\n\nfunc Test_while_fail()\n    call assert_equal('aeh', g:test13_result)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 14:  Failure in argument evaluation for :if\t\t\t    {{{1\n\"\n\"\t    A failure in the expression evaluation for the condition of an :if\n\"\t    does not cause the corresponding :else or :endif being matched to\n\"\t    a previous :if/:elseif.  Neither of both branches of the failed :if\n\"\t    are executed.\n\"-------------------------------------------------------------------------------\n\nXpathINIT\n\nfunction! F()\n    Xpath 'a'\n    let x = 0\n    if x\t\t\" false\n\tXpath 'b'\n    elseif !x\t\t\" always true\n\tXpath 'c'\n\tlet x = 1\n\tif g:boolvar\t\" possibly undefined\n\t    Xpath 'd'\n\telse\n\t    Xpath 'e'\n\tendif\n\tXpath 'f'\n    elseif x\t\t\" never executed\n\tXpath 'g'\n    endif\n    Xpath 'h'\nendfunction\n\nlet boolvar = 1\ncall F()\nXpath '-'\n\nunlet boolvar\ncall F()\nlet g:test14_result = g:Xpath\n\ndelfunction F\n\nfunc Test_if_fail()\n    call assert_equal('acdfh-acfh', g:test14_result)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 15:  Failure in argument evaluation for :if (bar)\t\t    {{{1\n\"\n\"\t    Like previous test, except that the failing :if ... | ... | :endif\n\"\t    is in a single line.\n\"-------------------------------------------------------------------------------\n\nXpathINIT\n\nfunction! F()\n    Xpath 'a'\n    let x = 0\n    if x\t\t\" false\n\tXpath 'b'\n    elseif !x\t\t\" always true\n\tXpath 'c'\n\tlet x = 1\n\tif g:boolvar | Xpath 'd' | else | Xpath 'e' | endif\n\tXpath 'f'\n    elseif x\t\t\" never executed\n\tXpath 'g'\n    endif\n    Xpath 'h'\nendfunction\n\nlet boolvar = 1\ncall F()\nXpath '-'\n\nunlet boolvar\ncall F()\nlet g:test15_result = g:Xpath\n\ndelfunction F\n\nfunc Test_if_bar_fail()\n    call assert_equal('acdfh-acfh', g:test15_result)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 16:  Double :else or :elseif after :else\t\t\t\t    {{{1\n\"\n\"\t    Multiple :elses or an :elseif after an :else are forbidden.\n\"-------------------------------------------------------------------------------\n\nfunc T16_F() abort\n  if 0\n    Xpath 'a'\n  else\n    Xpath 'b'\n  else\t\t\" aborts function\n    Xpath 'c'\n  endif\n  Xpath 'd'\nendfunc\n\nfunc T16_G() abort\n  if 0\n    Xpath 'a'\n  else\n    Xpath 'b'\n  elseif 1\t\t\" aborts function\n    Xpath 'c'\n  else\n    Xpath 'd'\n  endif\n  Xpath 'e'\nendfunc\n\nfunc T16_H() abort\n  if 0\n    Xpath 'a'\n  elseif 0\n    Xpath 'b'\n  else\n    Xpath 'c'\n  else\t\t\" aborts function\n    Xpath 'd'\n  endif\n  Xpath 'e'\nendfunc\n\nfunc T16_I() abort\n  if 0\n    Xpath 'a'\n  elseif 0\n    Xpath 'b'\n  else\n    Xpath 'c'\n  elseif 1\t\t\" aborts function\n    Xpath 'd'\n  else\n    Xpath 'e'\n  endif\n  Xpath 'f'\nendfunc\n\nfunc Test_Multi_Else()\n  XpathINIT\n  try\n    call T16_F()\n  catch /E583:/\n    Xpath 'e'\n  endtry\n  call assert_equal('be', g:Xpath)\n\n  XpathINIT\n  try\n    call T16_G()\n  catch /E584:/\n    Xpath 'f'\n  endtry\n  call assert_equal('bf', g:Xpath)\n\n  XpathINIT\n  try\n    call T16_H()\n  catch /E583:/\n    Xpath 'f'\n  endtry\n  call assert_equal('cf', g:Xpath)\n\n  XpathINIT\n  try\n    call T16_I()\n  catch /E584:/\n    Xpath 'g'\n  endtry\n  call assert_equal('cg', g:Xpath)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 17:  Nesting of unmatched :if or :endif inside a :while\t\t    {{{1\n\"\n\"\t    The :while/:endwhile takes precedence in nesting over an unclosed\n\"\t    :if or an unopened :endif.\n\"-------------------------------------------------------------------------------\n\n\" While loops inside a function are continued on error.\nfunc T17_F()\n  let loops = 3\n  while loops > 0\n    let loops -= 1\n    Xpath 'a' . loops\n    if (loops == 1)\n      Xpath 'b' . loops\n      continue\n    elseif (loops == 0)\n      Xpath 'c' . loops\n      break\n    elseif 1\n      Xpath 'd' . loops\n    \" endif missing!\n  endwhile\t\" :endwhile after :if 1\n  Xpath 'e'\nendfunc\n\nfunc T17_G()\n  let loops = 2\n  while loops > 0\n    let loops -= 1\n    Xpath 'a' . loops\n    if 0\n      Xpath 'b' . loops\n    \" endif missing\n  endwhile\t\" :endwhile after :if 0\nendfunc\n\nfunc T17_H()\n  let loops = 2\n  while loops > 0\n    let loops -= 1\n    Xpath 'a' . loops\n    \" if missing!\n    endif\t\" :endif without :if in while\n    Xpath 'b' . loops\n  endwhile\nendfunc\n\n\" Error continuation outside a function is at the outermost :endwhile or :endif.\nXpathINIT\nlet v:errmsg = ''\nlet loops = 2\nwhile loops > 0\n    let loops -= 1\n    Xpath 'a' . loops\n    if 0\n\tXpath 'b' . loops\n    \" endif missing! Following :endwhile fails.\nendwhile | Xpath 'c'\nXpath 'd'\ncall assert_match('E171:', v:errmsg)\ncall assert_equal('a1d', g:Xpath)\n\nfunc Test_unmatched_if_in_while()\n  XpathINIT\n  call assert_fails('call T17_F()', 'E171:')\n  call assert_equal('a2d2a1b1a0c0e', g:Xpath)\n\n  XpathINIT\n  call assert_fails('call T17_G()', 'E171:')\n  call assert_equal('a1a0', g:Xpath)\n\n  XpathINIT\n  call assert_fails('call T17_H()', 'E580:')\n  call assert_equal('a1b1a0b0', g:Xpath)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 18:  Interrupt (Ctrl-C pressed)\t\t\t\t\t    {{{1\n\"\n\"\t    On an interrupt, the script processing is terminated immediately.\n\"-------------------------------------------------------------------------------\n\nfunc Test_interrupt_while_if()\n  let test =<< trim [CODE]\n    try\n      if 1\n        Xpath 'a'\n        while 1\n          Xpath 'b'\n          if 1\n            Xpath 'c'\n            call interrupt()\n            call assert_report('should not get here')\n            break\n            finish\n          endif | call assert_report('should not get here')\n          call assert_report('should not get here')\n        endwhile | call assert_report('should not get here')\n        call assert_report('should not get here')\n      endif | call assert_report('should not get here')\n      call assert_report('should not get here')\n    catch /^Vim:Interrupt$/\n      Xpath 'd'\n    endtry | Xpath 'e'\n    Xpath 'f'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcdef', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_interrupt_try()\n  let test =<< trim [CODE]\n    try\n      try\n        Xpath 'a'\n        call interrupt()\n        call assert_report('should not get here')\n      endtry | call assert_report('should not get here')\n      call assert_report('should not get here')\n    catch /^Vim:Interrupt$/\n      Xpath 'b'\n    endtry | Xpath 'c'\n    Xpath 'd'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcd', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_interrupt_func_while_if()\n  let test =<< trim [CODE]\n    func F()\n      if 1\n        Xpath 'a'\n        while 1\n          Xpath 'b'\n          if 1\n            Xpath 'c'\n            call interrupt()\n            call assert_report('should not get here')\n            break\n            return\n          endif | call assert_report('should not get here')\n          call assert_report('should not get here')\n        endwhile | call assert_report('should not get here')\n        call assert_report('should not get here')\n      endif | call assert_report('should not get here')\n      call assert_report('should not get here')\n    endfunc\n\n    Xpath 'd'\n    try\n      call F() | call assert_report('should not get here')\n    catch /^Vim:Interrupt$/\n      Xpath 'e'\n    endtry | Xpath 'f'\n    Xpath 'g'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('dabcefg', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_interrupt_func_try()\n  let test =<< trim [CODE]\n    func G()\n      try\n        Xpath 'a'\n        call interrupt()\n        call assert_report('should not get here')\n      endtry | call assert_report('should not get here')\n      call assert_report('should not get here')\n    endfunc\n\n    Xpath 'b'\n    try\n      call G() | call assert_report('should not get here')\n    catch /^Vim:Interrupt$/\n      Xpath 'c'\n    endtry | Xpath 'd'\n    Xpath 'e'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('bacde', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 19:  Aborting on errors inside :try/:endtry\t\t\t    {{{1\n\"\n\"\t    An error in a command dynamically enclosed in a :try/:endtry region\n\"\t    aborts script processing immediately.  It does not matter whether\n\"\t    the failing command is outside or inside a function and whether a\n\"\t    function has an \"abort\" attribute.\n\"-------------------------------------------------------------------------------\n\nfunc Test_try_error_abort_1()\n  let test =<< trim [CODE]\n    func F() abort\n      Xpath 'a'\n      asdf\n      call assert_report('should not get here')\n    endfunc\n\n    try\n      Xpath 'b'\n      call F()\n      call assert_report('should not get here')\n    endtry | call assert_report('should not get here')\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('ba', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_try_error_abort_2()\n  let test =<< trim [CODE]\n    func G()\n      Xpath 'a'\n      asdf\n      call assert_report('should not get here')\n    endfunc\n\n    try\n      Xpath 'b'\n      call G()\n      call assert_report('should not get here')\n    endtry | call assert_report('should not get here')\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('ba', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_try_error_abort_3()\n  let test =<< trim [CODE]\n    try\n      Xpath 'a'\n      asdf\n      call assert_report('should not get here')\n    endtry | call assert_report('should not get here')\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('a', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_try_error_abort_4()\n  let test =<< trim [CODE]\n    if 1\n      try\n        Xpath 'a'\n        asdf\n        call assert_report('should not get here')\n      endtry | call assert_report('should not get here')\n    endif | call assert_report('should not get here')\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('a', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_try_error_abort_5()\n  let test =<< trim [CODE]\n    let p = 1\n    while p\n      let p = 0\n      try\n        Xpath 'a'\n        asdf\n        call assert_report('should not get here')\n      endtry | call assert_report('should not get here')\n    endwhile | call assert_report('should not get here')\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('a', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_try_error_abort_6()\n  let test =<< trim [CODE]\n    let p = 1\n    Xpath 'a'\n    while p\n      Xpath 'b'\n      let p = 0\n      try\n        Xpath 'c'\n    endwhile | call assert_report('should not get here')\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abc', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 20:  Aborting on errors after :try/:endtry\t\t\t    {{{1\n\"\n\"\t    When an error occurs after the last active :try/:endtry region has\n\"\t    been left, termination behavior is as if no :try/:endtry has been\n\"\t    seen.\n\"-------------------------------------------------------------------------------\n\nfunc Test_error_after_try_1()\n  let test =<< trim [CODE]\n    let p = 1\n    while p\n      let p = 0\n      Xpath 'a'\n      try\n        Xpath 'b'\n      endtry\n      asdf\n      call assert_report('should not get here')\n    endwhile | call assert_report('should not get here')\n    Xpath 'c'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abc', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_error_after_try_2()\n  let test =<< trim [CODE]\n    while 1\n      try\n        Xpath 'a'\n        break\n        call assert_report('should not get here')\n      endtry\n    endwhile\n    Xpath 'b'\n    asdf\n    Xpath 'c'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abc', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_error_after_try_3()\n  let test =<< trim [CODE]\n    while 1\n      try\n        Xpath 'a'\n        break\n        call assert_report('should not get here')\n      finally\n        Xpath 'b'\n      endtry\n    endwhile\n    Xpath 'c'\n    asdf\n    Xpath 'd'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcd', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_error_after_try_4()\n  let test =<< trim [CODE]\n    while 1\n      try\n        Xpath 'a'\n      finally\n        Xpath 'b'\n        break\n        call assert_report('should not get here')\n      endtry\n    endwhile\n    Xpath 'c'\n    asdf\n    Xpath 'd'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcd', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_error_after_try_5()\n  let test =<< trim [CODE]\n    let p = 1\n    while p\n      let p = 0\n      try\n        Xpath 'a'\n        continue\n        call assert_report('should not get here')\n      endtry\n    endwhile\n    Xpath 'b'\n    asdf\n    Xpath 'c'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abc', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_error_after_try_6()\n  let test =<< trim [CODE]\n    let p = 1\n    while p\n      let p = 0\n      try\n        Xpath 'a'\n        continue\n        call assert_report('should not get here')\n      finally\n        Xpath 'b'\n      endtry\n    endwhile\n    Xpath 'c'\n    asdf\n    Xpath 'd'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcd', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_error_after_try_7()\n  let test =<< trim [CODE]\n    let p = 1\n    while p\n      let p = 0\n      try\n        Xpath 'a'\n      finally\n        Xpath 'b'\n        continue\n        call assert_report('should not get here')\n      endtry\n    endwhile\n    Xpath 'c'\n    asdf\n    Xpath 'd'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcd', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 21:  :finally for :try after :continue/:break/:return/:finish\t    {{{1\n\"\n\"\t    If a :try conditional stays inactive due to a preceding :continue,\n\"\t    :break, :return, or :finish, its :finally clause should not be\n\"\t    executed.\n\"-------------------------------------------------------------------------------\n\nfunc Test_finally_after_loop_ctrl_statement()\n  let test =<< trim [CODE]\n    func F()\n      let loops = 2\n      while loops > 0\n        XloopNEXT\n        let loops = loops - 1\n        try\n          if loops == 1\n            Xloop 'a'\n            continue\n            call assert_report('should not get here')\n          elseif loops == 0\n            Xloop 'b'\n            break\n            call assert_report('should not get here')\n          endif\n\n          try\t\t\" inactive\n            call assert_report('should not get here')\n          finally\n            call assert_report('should not get here')\n          endtry\n        finally\n          Xloop 'c'\n        endtry\n        call assert_report('should not get here')\n      endwhile\n\n      try\n        Xpath 'd'\n        return\n        call assert_report('should not get here')\n        try\t\t    \" inactive\n          call assert_report('should not get here')\n        finally\n          call assert_report('should not get here')\n        endtry\n      finally\n        Xpath 'e'\n      endtry\n      call assert_report('should not get here')\n    endfunc\n\n    try\n      Xpath 'f'\n      call F()\n      Xpath 'g'\n      finish\n      call assert_report('should not get here')\n      try\t\t\" inactive\n        call assert_report('should not get here')\n      finally\n        call assert_report('should not get here')\n      endtry\n    finally\n      Xpath 'h'\n    endtry\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('fa2c2b3c3degh', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 22:  :finally for a :try after an error/interrupt/:throw\t\t    {{{1\n\"\n\"\t    If a :try conditional stays inactive due to a preceding error or\n\"\t    interrupt or :throw, its :finally clause should not be executed.\n\"-------------------------------------------------------------------------------\n\nfunc Test_finally_after_error_in_func()\n  let test =<< trim [CODE]\n    func Error()\n      try\n        Xpath 'b'\n        asdf    \" aborting error, triggering error exception\n        call assert_report('should not get here')\n      endtry\n      call assert_report('should not get here')\n    endfunc\n\n    Xpath 'a'\n    call Error()\n    call assert_report('should not get here')\n\n    if 1\t\" not active due to error\n      try\t\" not active since :if inactive\n        call assert_report('should not get here')\n      finally\n        call assert_report('should not get here')\n      endtry\n    endif\n\n    try\t\t\" not active due to error\n      call assert_report('should not get here')\n    finally\n      call assert_report('should not get here')\n    endtry\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('ab', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_finally_after_interrupt()\n  let test =<< trim [CODE]\n    func Interrupt()\n      try\n        Xpath 'a'\n        call interrupt()            \" triggering interrupt exception\n        call assert_report('should not get here')\n      endtry\n    endfunc\n\n    Xpath 'b'\n    try\n      call Interrupt()\n    catch /^Vim:Interrupt$/\n      Xpath 'c'\n      finish\n    endtry\n    call assert_report('should not get here')\n\n    if 1\t\" not active due to interrupt\n      try\t\" not active since :if inactive\n        call assert_report('should not get here')\n      finally\n        call assert_report('should not get here')\n      endtry\n    endif\n\n    try\t\t\" not active due to interrupt\n      call assert_report('should not get here')\n    finally\n      call assert_report('should not get here')\n    endtry\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('bac', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_finally_after_throw()\n  let test =<< trim [CODE]\n    func Throw()\n      Xpath 'a'\n      throw 'xyz'\n    endfunc\n\n    Xpath 'b'\n    call Throw()\n    call assert_report('should not get here')\n\n    if 1\t\" not active due to :throw\n      try\t\" not active since :if inactive\n        call assert_report('should not get here')\n      finally\n        call assert_report('should not get here')\n      endtry\n    endif\n\n    try\t\t\" not active due to :throw\n      call assert_report('should not get here')\n    finally\n      call assert_report('should not get here')\n    endtry\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('ba', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 23:  :catch clauses for a :try after a :throw\t\t\t    {{{1\n\"\n\"\t    If a :try conditional stays inactive due to a preceding :throw,\n\"\t    none of its :catch clauses should be executed.\n\"-------------------------------------------------------------------------------\n\nfunc Test_catch_after_throw()\n  let test =<< trim [CODE]\n    try\n      Xpath 'a'\n      throw \"xyz\"\n      call assert_report('should not get here')\n\n      if 1\t\" not active due to :throw\n        try\t\" not active since :if inactive\n          call assert_report('should not get here')\n        catch /xyz/\n          call assert_report('should not get here')\n        endtry\n      endif\n    catch /xyz/\n      Xpath 'b'\n    endtry\n\n    Xpath 'c'\n    throw \"abc\"\n    call assert_report('should not get here')\n\n    try\t\t\" not active due to :throw\n      call assert_report('should not get here')\n    catch /abc/\n      call assert_report('should not get here')\n    endtry\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abc', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 24:  :endtry for a :try after a :throw\t\t\t\t    {{{1\n\"\n\"\t    If a :try conditional stays inactive due to a preceding :throw,\n\"\t    its :endtry should not rethrow the exception to the next surrounding\n\"\t    active :try conditional.\n\"-------------------------------------------------------------------------------\n\nfunc Test_endtry_after_throw()\n  let test =<< trim [CODE]\n    try\t\t\t\" try 1\n      try\t\t\" try 2\n        Xpath 'a'\n        throw \"xyz\"\t\" makes try 2 inactive\n        call assert_report('should not get here')\n\n        try\t\t\" try 3\n          call assert_report('should not get here')\n        endtry\t\" no rethrow to try 1\n      catch /xyz/\t\" should catch although try 2 inactive\n        Xpath 'b'\n      endtry\n    catch /xyz/\t\t\" try 1 active, but exception already caught\n      call assert_report('should not get here')\n    endtry\n    Xpath 'c'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abc', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 27:  Executing :finally clauses after :return\t\t\t    {{{1\n\"\n\"\t    For a :return command dynamically enclosed in a :try/:endtry region,\n\"\t    :finally clauses are executed and the called function is ended.\n\"-------------------------------------------------------------------------------\n\nfunc T27_F()\n  try\n    Xpath 'a'\n    try\n      Xpath 'b'\n      return\n      call assert_report('should not get here')\n    finally\n      Xpath 'c'\n    endtry\n    Xpath 'd'\n  finally\n    Xpath 'e'\n  endtry\n  call assert_report('should not get here')\nendfunc\n\nfunc T27_G()\n  try\n    Xpath 'f'\n    return\n    call assert_report('should not get here')\n  finally\n    Xpath 'g'\n    call T27_F()\n    Xpath 'h'\n  endtry\n  call assert_report('should not get here')\nendfunc\n\nfunc T27_H()\n  try\n    Xpath 'i'\n    call T27_G()\n    Xpath 'j'\n  finally\n    Xpath 'k'\n    return\n    call assert_report('should not get here')\n  endtry\n  call assert_report('should not get here')\nendfunction\n\nfunc Test_finally_after_return()\n  XpathINIT\n  try\n      Xpath 'l'\n      call T27_H()\n      Xpath 'm'\n  finally\n      Xpath 'n'\n  endtry\n  call assert_equal('lifgabcehjkmn', g:Xpath)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 28:  Executing :finally clauses after :finish\t\t\t    {{{1\n\"\n\"\t    For a :finish command dynamically enclosed in a :try/:endtry region,\n\"\t    :finally clauses are executed and the sourced file is finished.\n\"\n\"\t    This test executes the bodies of the functions F, G, and H from the\n\"\t    previous test as script files (:return replaced by :finish).\n\"-------------------------------------------------------------------------------\n\nfunc Test_finally_after_finish()\n  XpathINIT\n\n  let scriptF = MakeScript(\"T27_F\")\n  let scriptG = MakeScript(\"T27_G\", scriptF)\n  let scriptH = MakeScript(\"T27_H\", scriptG)\n\n  try\n    Xpath 'A'\n    exec \"source\" scriptH\n    Xpath 'B'\n  finally\n    Xpath 'C'\n  endtry\n  Xpath 'D'\n  call assert_equal('AifgabcehjkBCD', g:Xpath)\n  call delete(scriptF)\n  call delete(scriptG)\n  call delete(scriptH)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 29:  Executing :finally clauses on errors\t\t\t    {{{1\n\"\n\"\t    After an error in a command dynamically enclosed in a :try/:endtry\n\"\t    region, :finally clauses are executed and the script processing is\n\"\t    terminated.\n\"-------------------------------------------------------------------------------\n\nfunc Test_finally_after_error_1()\n  let test =<< trim [CODE]\n    func F()\n      while 1\n        try\n          Xpath 'a'\n          while 1\n            try\n              Xpath 'b'\n              asdf\t    \" error\n              call assert_report('should not get here')\n            finally\n              Xpath 'c'\n            endtry | call assert_report('should not get here')\n            call assert_report('should not get here')\n            break\n          endwhile\n          call assert_report('should not get here')\n        finally\n          Xpath 'd'\n        endtry | call assert_report('should not get here')\n        call assert_report('should not get here')\n        break\n      endwhile\n      call assert_report('should not get here')\n    endfunc\n\n    while 1\n      try\n        Xpath 'e'\n        while 1\n          call F()\n          call assert_report('should not get here')\n          break\n        endwhile  | call assert_report('should not get here')\n        call assert_report('should not get here')\n      finally\n        Xpath 'f'\n      endtry | call assert_report('should not get here')\n    endwhile | call assert_report('should not get here')\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('eabcdf', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_finally_after_error_2()\n  let test =<< trim [CODE]\n    func G() abort\n      if 1\n        try\n          Xpath 'a'\n          asdf\t    \" error\n          call assert_report('should not get here')\n        finally\n          Xpath 'b'\n        endtry | Xpath 'c'\n      endif | Xpath 'd'\n      call assert_report('should not get here')\n    endfunc\n\n    if 1\n      try\n        Xpath 'e'\n        call G()\n        call assert_report('should not get here')\n      finally\n        Xpath 'f'\n      endtry | call assert_report('should not get here')\n    endif | call assert_report('should not get here')\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('eabf', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 30:  Executing :finally clauses on interrupt\t\t\t    {{{1\n\"\n\"\t    After an interrupt in a command dynamically enclosed in\n\"\t    a :try/:endtry region, :finally clauses are executed and the\n\"\t    script processing is terminated.\n\"-------------------------------------------------------------------------------\n\nfunc Test_finally_on_interrupt()\n  let test =<< trim [CODE]\n    func F()\n      try\n        Xloop 'a'\n        call interrupt()\n        call assert_report('should not get here')\n      finally\n        Xloop 'b'\n      endtry\n      call assert_report('should not get here')\n    endfunc\n\n    try\n      try\n        Xpath 'c'\n        try\n          Xpath 'd'\n          call interrupt()\n          call assert_report('should not get here')\n        finally\n          Xpath 'e'\n          try\n            Xpath 'f'\n            try\n              Xpath 'g'\n            finally\n              Xpath 'h'\n              try\n                Xpath 'i'\n                call interrupt()\n                call assert_report('should not get here')\n              endtry\n              call assert_report('should not get here')\n            endtry\n            call assert_report('should not get here')\n          endtry\n          call assert_report('should not get here')\n        endtry\n        call assert_report('should not get here')\n      finally\n        Xpath 'j'\n        try\n          Xpath 'k'\n          call F()\n          call assert_report('should not get here')\n        finally\n          Xpath 'l'\n          try\n            Xpath 'm'\n            XloopNEXT\n            ExecAsScript F\n            call assert_report('should not get here')\n          finally\n            Xpath 'n'\n          endtry\n          call assert_report('should not get here')\n        endtry\n        call assert_report('should not get here')\n      endtry\n      call assert_report('should not get here')\n    catch /^Vim:Interrupt$/\n      Xpath 'o'\n    endtry\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('cdefghijka1b1lma2b2no', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 31:  Executing :finally clauses after :throw\t\t\t    {{{1\n\"\n\"\t    After a :throw dynamically enclosed in a :try/:endtry region,\n\"\t    :finally clauses are executed and the script processing is\n\"\t    terminated.\n\"-------------------------------------------------------------------------------\n\nfunc Test_finally_after_throw_2()\n  let test =<< trim [CODE]\n    func F()\n      try\n        Xloop 'a'\n        throw \"exception\"\n        call assert_report('should not get here')\n      finally\n        Xloop 'b'\n      endtry\n      call assert_report('should not get here')\n    endfunc\n\n    try\n      Xpath 'c'\n      try\n        Xpath 'd'\n        throw \"exception\"\n        call assert_report('should not get here')\n      finally\n        Xpath 'e'\n        try\n          Xpath 'f'\n          try\n            Xpath 'g'\n          finally\n            Xpath 'h'\n            try\n              Xpath 'i'\n              throw \"exception\"\n              call assert_report('should not get here')\n            endtry\n            call assert_report('should not get here')\n          endtry\n          call assert_report('should not get here')\n        endtry\n        call assert_report('should not get here')\n      endtry\n      call assert_report('should not get here')\n    finally\n      Xpath 'j'\n      try\n        Xpath 'k'\n        call F()\n        call assert_report('should not get here')\n      finally\n        Xpath 'l'\n        try\n          Xpath 'm'\n          XloopNEXT\n          ExecAsScript F\n          call assert_report('should not get here')\n        finally\n          Xpath 'n'\n        endtry\n        call assert_report('should not get here')\n      endtry\n      call assert_report('should not get here')\n    endtry\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('cdefghijka1b1lma2b2n', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 34:  :finally reason discarded by :continue\t\t\t    {{{1\n\"\n\"\t    When a :finally clause is executed due to a :continue, :break,\n\"\t    :return, :finish, error, interrupt or :throw, the jump reason is\n\"\t    discarded by a :continue in the finally clause.\n\"-------------------------------------------------------------------------------\n\nfunc Test_finally_after_continue()\n  let test =<< trim [CODE]\n    func C(jump)\n      XloopNEXT\n      let loop = 0\n      while loop < 2\n        let loop = loop + 1\n        if loop == 1\n          try\n            if a:jump == \"continue\"\n              continue\n            elseif a:jump == \"break\"\n              break\n            elseif a:jump == \"return\" || a:jump == \"finish\"\n              return\n            elseif a:jump == \"error\"\n              asdf\n            elseif a:jump == \"interrupt\"\n              call interrupt()\n              let dummy = 0\n            elseif a:jump == \"throw\"\n              throw \"abc\"\n            endif\n          finally\n            continue\t\" discards jump that caused the :finally\n            call assert_report('should not get here')\n          endtry\n          call assert_report('should not get here')\n        elseif loop == 2\n          Xloop 'a'\n        endif\n      endwhile\n    endfunc\n\n    call C(\"continue\")\n    Xpath 'b'\n    call C(\"break\")\n    Xpath 'c'\n    call C(\"return\")\n    Xpath 'd'\n    let g:jump = \"finish\"\n    ExecAsScript C\n    unlet g:jump\n    Xpath 'e'\n    try\n      call C(\"error\")\n      Xpath 'f'\n    finally\n      Xpath 'g'\n      try\n        call C(\"interrupt\")\n        Xpath 'h'\n      finally\n        Xpath 'i'\n        call C(\"throw\")\n        Xpath 'j'\n      endtry\n    endtry\n    Xpath 'k'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('a2ba3ca4da5ea6fga7hia8jk', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 35:  :finally reason discarded by :break\t\t\t\t    {{{1\n\"\n\"\t    When a :finally clause is executed due to a :continue, :break,\n\"\t    :return, :finish, error, interrupt or :throw, the jump reason is\n\"\t    discarded by a :break in the finally clause.\n\"-------------------------------------------------------------------------------\n\nfunc Test_finally_discard_by_break()\n  let test =<< trim [CODE]\n    func B(jump)\n      XloopNEXT\n      let loop = 0\n      while loop < 2\n        let loop = loop + 1\n        if loop == 1\n          try\n            if a:jump == \"continue\"\n              continue\n            elseif a:jump == \"break\"\n              break\n            elseif a:jump == \"return\" || a:jump == \"finish\"\n              return\n            elseif a:jump == \"error\"\n              asdf\n            elseif a:jump == \"interrupt\"\n              call interrupt()\n              let dummy = 0\n            elseif a:jump == \"throw\"\n              throw \"abc\"\n            endif\n          finally\n            break\t\" discards jump that caused the :finally\n            call assert_report('should not get here')\n          endtry\n        elseif loop == 2\n          call assert_report('should not get here')\n        endif\n      endwhile\n      Xloop 'a'\n    endfunc\n\n    call B(\"continue\")\n    Xpath 'b'\n    call B(\"break\")\n    Xpath 'c'\n    call B(\"return\")\n    Xpath 'd'\n    let g:jump = \"finish\"\n    ExecAsScript B\n    unlet g:jump\n    Xpath 'e'\n    try\n      call B(\"error\")\n      Xpath 'f'\n    finally\n      Xpath 'g'\n      try\n        call B(\"interrupt\")\n        Xpath 'h'\n      finally\n        Xpath 'i'\n        call B(\"throw\")\n        Xpath 'j'\n      endtry\n    endtry\n    Xpath 'k'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('a2ba3ca4da5ea6fga7hia8jk', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 36:  :finally reason discarded by :return\t\t\t    {{{1\n\"\n\"\t    When a :finally clause is executed due to a :continue, :break,\n\"\t    :return, :finish, error, interrupt or :throw, the jump reason is\n\"\t    discarded by a :return in the finally clause.\n\"-------------------------------------------------------------------------------\n\nfunc Test_finally_discard_by_return()\n  let test =<< trim [CODE]\n    func R(jump, retval) abort\n      let loop = 0\n      while loop < 2\n        let loop = loop + 1\n        if loop == 1\n          try\n            if a:jump == \"continue\"\n              continue\n            elseif a:jump == \"break\"\n              break\n            elseif a:jump == \"return\"\n              return\n            elseif a:jump == \"error\"\n              asdf\n            elseif a:jump == \"interrupt\"\n              call interrupt()\n              let dummy = 0\n            elseif a:jump == \"throw\"\n              throw \"abc\"\n            endif\n          finally\n            return a:retval\t\" discards jump that caused the :finally\n            call assert_report('should not get here')\n          endtry\n        elseif loop == 2\n          call assert_report('should not get here')\n        endif\n      endwhile\n      call assert_report('should not get here')\n    endfunc\n\n    let sum =  -R(\"continue\", -8)\n    Xpath 'a'\n    let sum = sum - R(\"break\", -16)\n    Xpath 'b'\n    let sum = sum - R(\"return\", -32)\n    Xpath 'c'\n    try\n      let sum = sum - R(\"error\", -64)\n      Xpath 'd'\n    finally\n      Xpath 'e'\n      try\n        let sum = sum - R(\"interrupt\", -128)\n        Xpath 'f'\n      finally\n        Xpath 'g'\n        let sum = sum - R(\"throw\", -256)\n        Xpath 'h'\n      endtry\n    endtry\n    Xpath 'i'\n\n    let expected = 8 + 16 + 32 + 64 + 128 + 256\n    call assert_equal(sum, expected)\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcdefghi', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 37:  :finally reason discarded by :finish\t\t\t    {{{1\n\"\n\"\t    When a :finally clause is executed due to a :continue, :break,\n\"\t    :return, :finish, error, interrupt or :throw, the jump reason is\n\"\t    discarded by a :finish in the finally clause.\n\"-------------------------------------------------------------------------------\n\nfunc Test_finally_discard_by_finish()\n  let test =<< trim [CODE]\n    func F(jump)\t\" not executed as function, transformed to a script\n      let loop = 0\n      while loop < 2\n        let loop = loop + 1\n        if loop == 1\n          try\n            if a:jump == \"continue\"\n              continue\n            elseif a:jump == \"break\"\n              break\n            elseif a:jump == \"finish\"\n              finish\n            elseif a:jump == \"error\"\n              asdf\n            elseif a:jump == \"interrupt\"\n              call interrupt()\n              let dummy = 0\n            elseif a:jump == \"throw\"\n              throw \"abc\"\n            endif\n          finally\n            finish\t\" discards jump that caused the :finally\n            call assert_report('should not get here')\n          endtry\n        elseif loop == 2\n          call assert_report('should not get here')\n        endif\n      endwhile\n      call assert_report('should not get here')\n    endfunc\n\n    let scriptF = MakeScript(\"F\")\n    delfunction F\n\n    let g:jump = \"continue\"\n    exec \"source\" scriptF\n    Xpath 'a'\n    let g:jump = \"break\"\n    exec \"source\" scriptF\n    Xpath 'b'\n    let g:jump = \"finish\"\n    exec \"source\" scriptF\n    Xpath 'c'\n    try\n      let g:jump = \"error\"\n      exec \"source\" scriptF\n      Xpath 'd'\n    finally\n      Xpath 'e'\n      try\n        let g:jump = \"interrupt\"\n        exec \"source\" scriptF\n        Xpath 'f'\n      finally\n        Xpath 'g'\n        try\n          let g:jump = \"throw\"\n          exec \"source\" scriptF\n          Xpath 'h'\n        finally\n          Xpath 'i'\n        endtry\n      endtry\n    endtry\n    unlet g:jump\n    call delete(scriptF)\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcdefghi', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 38:  :finally reason discarded by an error\t\t\t    {{{1\n\"\n\"\t    When a :finally clause is executed due to a :continue, :break,\n\"\t    :return, :finish, error, interrupt or :throw, the jump reason is\n\"\t    discarded by an error in the finally clause.\n\"-------------------------------------------------------------------------------\n\nfunc Test_finally_discard_by_error()\n  let test =<< trim [CODE]\n    func E(jump)\n      let loop = 0\n      while loop < 2\n        let loop = loop + 1\n        if loop == 1\n          try\n            if a:jump == \"continue\"\n              continue\n            elseif a:jump == \"break\"\n              break\n            elseif a:jump == \"return\" || a:jump == \"finish\"\n              return\n            elseif a:jump == \"error\"\n              asdf\n            elseif a:jump == \"interrupt\"\n              call interrupt()\n              let dummy = 0\n            elseif a:jump == \"throw\"\n              throw \"abc\"\n            endif\n          finally\n            asdf\t\" error; discards jump that caused the :finally\n          endtry\n        elseif loop == 2\n          call assert_report('should not get here')\n        endif\n      endwhile\n      call assert_report('should not get here')\n    endfunc\n\n    try\n      Xpath 'a'\n      call E(\"continue\")\n      call assert_report('should not get here')\n    finally\n      try\n        Xpath 'b'\n        call E(\"break\")\n        call assert_report('should not get here')\n      finally\n        try\n          Xpath 'c'\n          call E(\"return\")\n          call assert_report('should not get here')\n        finally\n          try\n            Xpath 'd'\n            let g:jump = \"finish\"\n            ExecAsScript E\n            call assert_report('should not get here')\n          finally\n            unlet g:jump\n            try\n              Xpath 'e'\n              call E(\"error\")\n              call assert_report('should not get here')\n            finally\n              try\n                Xpath 'f'\n                call E(\"interrupt\")\n                call assert_report('should not get here')\n              finally\n                try\n                  Xpath 'g'\n                  call E(\"throw\")\n                  call assert_report('should not get here')\n                finally\n                  Xpath 'h'\n                  delfunction E\n                endtry\n              endtry\n            endtry\n          endtry\n        endtry\n      endtry\n    endtry\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcdefgh', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 39:  :finally reason discarded by an interrupt\t\t\t    {{{1\n\"\n\"\t    When a :finally clause is executed due to a :continue, :break,\n\"\t    :return, :finish, error, interrupt or :throw, the jump reason is\n\"\t    discarded by an interrupt in the finally clause.\n\"-------------------------------------------------------------------------------\n\nfunc Test_finally_discarded_by_interrupt()\n  let test =<< trim [CODE]\n    func I(jump)\n      let loop = 0\n      while loop < 2\n        let loop = loop + 1\n        if loop == 1\n          try\n            if a:jump == \"continue\"\n              continue\n            elseif a:jump == \"break\"\n              break\n            elseif a:jump == \"return\" || a:jump == \"finish\"\n              return\n            elseif a:jump == \"error\"\n              asdf\n            elseif a:jump == \"interrupt\"\n              call interrupt()\n              let dummy = 0\n            elseif a:jump == \"throw\"\n              throw \"abc\"\n            endif\n          finally\n            call interrupt()\n            let dummy = 0\n          endtry\n        elseif loop == 2\n          call assert_report('should not get here')\n        endif\n      endwhile\n      call assert_report('should not get here')\n    endfunc\n\n    try\n      try\n        Xpath 'a'\n        call I(\"continue\")\n        call assert_report('should not get here')\n      finally\n        try\n          Xpath 'b'\n          call I(\"break\")\n          call assert_report('should not get here')\n        finally\n          try\n            Xpath 'c'\n            call I(\"return\")\n            call assert_report('should not get here')\n          finally\n            try\n              Xpath 'd'\n              let g:jump = \"finish\"\n              ExecAsScript I\n              call assert_report('should not get here')\n            finally\n              unlet g:jump\n              try\n                Xpath 'e'\n                call I(\"error\")\n                call assert_report('should not get here')\n              finally\n                try\n                  Xpath 'f'\n                  call I(\"interrupt\")\n                  call assert_report('should not get here')\n                finally\n                  try\n                    Xpath 'g'\n                    call I(\"throw\")\n                    call assert_report('should not get here')\n                  finally\n                    Xpath 'h'\n                    delfunction I\n                  endtry\n                endtry\n              endtry\n            endtry\n          endtry\n        endtry\n      endtry\n      call assert_report('should not get here')\n    catch /^Vim:Interrupt$/\n      Xpath 'A'\n    endtry\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcdefghA', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 40:  :finally reason discarded by :throw\t\t\t\t    {{{1\n\"\n\"\t    When a :finally clause is executed due to a :continue, :break,\n\"\t    :return, :finish, error, interrupt or :throw, the jump reason is\n\"\t    discarded by a :throw in the finally clause.\n\"-------------------------------------------------------------------------------\n\nfunc Test_finally_discard_by_throw()\n  let test =<< trim [CODE]\n    func T(jump)\n      let loop = 0\n      while loop < 2\n        let loop = loop + 1\n        if loop == 1\n          try\n            if a:jump == \"continue\"\n              continue\n            elseif a:jump == \"break\"\n              break\n            elseif a:jump == \"return\" || a:jump == \"finish\"\n              return\n            elseif a:jump == \"error\"\n              asdf\n            elseif a:jump == \"interrupt\"\n              call interrupt()\n              let dummy = 0\n            elseif a:jump == \"throw\"\n              throw \"abc\"\n            endif\n          finally\n            throw \"xyz\"\t\" discards jump that caused the :finally\n          endtry\n        elseif loop == 2\n          call assert_report('should not get here')\n        endif\n      endwhile\n      call assert_report('should not get here')\n    endfunc\n\n    try\n      Xpath 'a'\n      call T(\"continue\")\n      call assert_report('should not get here')\n    finally\n      try\n        Xpath 'b'\n        call T(\"break\")\n        call assert_report('should not get here')\n      finally\n        try\n          Xpath 'c'\n          call T(\"return\")\n          call assert_report('should not get here')\n        finally\n          try\n            Xpath 'd'\n            let g:jump = \"finish\"\n            ExecAsScript T\n            call assert_report('should not get here')\n          finally\n            unlet g:jump\n            try\n              Xpath 'e'\n              call T(\"error\")\n              call assert_report('should not get here')\n            finally\n              try\n                Xpath 'f'\n                call T(\"interrupt\")\n                call assert_report('should not get here')\n              finally\n                try\n                  Xpath 'g'\n                  call T(\"throw\")\n                  call assert_report('should not get here')\n                finally\n                  Xpath 'h'\n                  delfunction T\n                endtry\n              endtry\n            endtry\n          endtry\n        endtry\n      endtry\n    endtry\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcdefgh', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 49:  Throwing exceptions across functions\t\t\t    {{{1\n\"\n\"\t    When an exception is thrown but not caught inside a function, the\n\"\t    caller is checked for a matching :catch clause.\n\"-------------------------------------------------------------------------------\n\nfunc T49_C()\n  try\n    Xpath 'a'\n    throw \"arrgh\"\n    call assert_report('should not get here')\n  catch /arrgh/\n    Xpath 'b'\n  endtry\n  Xpath 'c'\nendfunc\n\nfunc T49_T1()\n  XloopNEXT\n  try\n    Xloop 'd'\n    throw \"arrgh\"\n    call assert_report('should not get here')\n  finally\n    Xloop 'e'\n  endtry\n  Xloop 'f'\nendfunc\n\nfunc T49_T2()\n  try\n    Xpath 'g'\n    call T49_T1()\n    call assert_report('should not get here')\n  finally\n    Xpath 'h'\n  endtry\n  call assert_report('should not get here')\nendfunc\n\nfunc Test_throw_exception_across_funcs()\n  XpathINIT\n  XloopINIT\n  try\n    Xpath 'i'\n    call T49_C()            \" throw and catch\n    Xpath 'j'\n  catch /.*/\n    call assert_report('should not get here')\n  endtry\n\n  try\n    Xpath 'k'\n    call T49_T1()  \" throw, one level\n    call assert_report('should not get here')\n  catch /arrgh/\n    Xpath 'l'\n  catch /.*/\n    call assert_report('should not get here')\n  endtry\n\n  try\n    Xpath 'm'\n    call T49_T2()\t\" throw, two levels\n    call assert_report('should not get here')\n  catch /arrgh/\n    Xpath 'n'\n  catch /.*/\n    call assert_report('should not get here')\n  endtry\n  Xpath 'o'\n\n  call assert_equal('iabcjkd2e2lmgd3e3hno', g:Xpath)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 50:  Throwing exceptions across script files\t\t\t    {{{1\n\"\n\"\t    When an exception is thrown but not caught inside a script file,\n\"\t    the sourcing script or function is checked for a matching :catch\n\"\t    clause.\n\"\n\"\t    This test executes the bodies of the functions C, T1, and T2 from\n\"\t    the previous test as script files (:return replaced by :finish).\n\"-------------------------------------------------------------------------------\n\nfunc T50_F()\n  try\n    Xpath 'A'\n    exec \"source\" g:scriptC\n    Xpath 'B'\n  catch /.*/\n    call assert_report('should not get here')\n  endtry\n\n  try\n    Xpath 'C'\n    exec \"source\" g:scriptT1\n    call assert_report('should not get here')\n  catch /arrgh/\n    Xpath 'D'\n  catch /.*/\n    call assert_report('should not get here')\n  endtry\nendfunc\n\nfunc Test_throw_across_script()\n  XpathINIT\n  XloopINIT\n  let g:scriptC = MakeScript(\"T49_C\")\n  let g:scriptT1 = MakeScript(\"T49_T1\")\n  let scriptT2 = MakeScript(\"T49_T2\", g:scriptT1)\n\n  try\n    Xpath 'E'\n    call T50_F()\n    Xpath 'F'\n    exec \"source\" scriptT2\n    call assert_report('should not get here')\n  catch /arrgh/\n    Xpath 'G'\n  catch /.*/\n    call assert_report('should not get here')\n  endtry\n  Xpath 'H'\n  call assert_equal('EAabcBCd2e2DFgd3e3hGH', g:Xpath)\n\n  call delete(g:scriptC)\n  call delete(g:scriptT1)\n  call delete(scriptT2)\n  unlet g:scriptC g:scriptT1 scriptT2\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 52:  Uncaught exceptions\t\t\t\t\t\t    {{{1\n\"\n\"\t    When an exception is thrown but not caught, an error message is\n\"\t    displayed when the script is terminated.  In case of an interrupt\n\"\t    or error exception, the normal interrupt or error message(s) are\n\"\t    displayed.\n\"-------------------------------------------------------------------------------\n\nfunc Test_uncaught_exception_1()\n  CheckEnglish\n\n  let test =<< trim [CODE]\n    Xpath 'a'\n    throw \"arrgh\"\n    call assert_report('should not get here')`\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('E605: Exception not caught: arrgh', v:errmsg)\n    call assert_equal('a', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_uncaught_exception_2()\n  CheckEnglish\n\n  let test =<< trim [CODE]\n    try\n      Xpath 'a'\n      throw \"oops\"\n      call assert_report('should not get here')`\n    catch /arrgh/\n      call assert_report('should not get here')`\n    endtry\n    call assert_report('should not get here')`\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('E605: Exception not caught: oops', v:errmsg)\n    call assert_equal('a', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_uncaught_exception_3()\n  CheckEnglish\n\n  let test =<< trim [CODE]\n    func T()\n      Xpath 'c'\n      throw \"brrr\"\n      call assert_report('should not get here')`\n    endfunc\n\n    try\n      Xpath 'a'\n      throw \"arrgh\"\n      call assert_report('should not get here')`\n    catch /.*/\n      Xpath 'b'\n      call T()\n      call assert_report('should not get here')`\n    endtry\n    call assert_report('should not get here')`\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('E605: Exception not caught: brrr', v:errmsg)\n    call assert_equal('abc', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_uncaught_exception_4()\n  CheckEnglish\n\n  let test =<< trim [CODE]\n    try\n      Xpath 'a'\n      throw \"arrgh\"\n      call assert_report('should not get here')`\n    finally\n      Xpath 'b'\n      throw \"brrr\"\n      call assert_report('should not get here')`\n    endtry\n    call assert_report('should not get here')`\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('E605: Exception not caught: brrr', v:errmsg)\n    call assert_equal('ab', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_uncaught_exception_5()\n  CheckEnglish\n\n  \" Need to catch and handle interrupt, otherwise the test will wait for the\n  \" user to press <Enter> to continue\n  let test =<< trim [CODE]\n    try\n      try\n        Xpath 'a'\n        call interrupt()\n        call assert_report('should not get here')\n      endtry\n      call assert_report('should not get here')\n    catch /^Vim:Interrupt$/\n      Xpath 'b'\n    endtry\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('ab', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_uncaught_exception_6()\n  CheckEnglish\n\n  let test =<< trim [CODE]\n    try\n      Xpath 'a'\n      let x = novar\t\" error E121; exception: E121\n    catch /E15:/\t\" should not catch\n      call assert_report('should not get here')\n    endtry\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('a', g:Xpath)\n    call assert_equal('E121: Undefined variable: novar', v:errmsg)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_uncaught_exception_7()\n  CheckEnglish\n\n  let test =<< trim [CODE]\n    try\n      Xpath 'a'\n      \" error E108/E488; exception: E488\n      unlet novar #\n    catch /E108:/       \" should not catch\n      call assert_report('should not get here')\n    endtry\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('a', g:Xpath)\n    call assert_equal('E488: Trailing characters: #', v:errmsg)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 53:  Nesting errors: :endif/:else/:elseif\t\t\t    {{{1\n\"\n\"\t    For nesting errors of :if conditionals the correct error messages\n\"\t    should be given.\n\"-------------------------------------------------------------------------------\n\nfunc Test_nested_if_else_errors()\n  CheckEnglish\n\n  \" :endif without :if\n  let code =<< trim END\n    endif\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endif):E580: :endif without :if')\n\n  \" :endif without :if\n  let code =<< trim END\n    while 1\n      endif\n    endwhile\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endif):E580: :endif without :if')\n\n  \" :endif without :if\n  let code =<< trim END\n    try\n    finally\n      endif\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endif):E580: :endif without :if')\n\n  \" :endif without :if\n  let code =<< trim END\n    try\n      endif\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endif):E580: :endif without :if')\n\n  \" :endif without :if\n  let code =<< trim END\n    try\n      throw \"a\"\n    catch /a/\n      endif\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endif):E580: :endif without :if')\n\n  \" :else without :if\n  let code =<< trim END\n    else\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(else):E581: :else without :if')\n\n  \" :else without :if\n  let code =<< trim END\n    while 1\n      else\n    endwhile\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(else):E581: :else without :if')\n\n  \" :else without :if\n  let code =<< trim END\n    try\n    finally\n      else\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(else):E581: :else without :if')\n\n  \" :else without :if\n  let code =<< trim END\n    try\n      else\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(else):E581: :else without :if')\n\n  \" :else without :if\n  let code =<< trim END\n    try\n      throw \"a\"\n    catch /a/\n      else\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(else):E581: :else without :if')\n\n  \" :elseif without :if\n  let code =<< trim END\n    elseif 1\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(elseif):E582: :elseif without :if')\n\n  \" :elseif without :if\n  let code =<< trim END\n    while 1\n      elseif 1\n    endwhile\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(elseif):E582: :elseif without :if')\n\n  \" :elseif without :if\n  let code =<< trim END\n    try\n    finally\n      elseif 1\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(elseif):E582: :elseif without :if')\n\n  \" :elseif without :if\n  let code =<< trim END\n    try\n      elseif 1\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(elseif):E582: :elseif without :if')\n\n  \" :elseif without :if\n  let code =<< trim END\n    try\n      throw \"a\"\n    catch /a/\n      elseif 1\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(elseif):E582: :elseif without :if')\n\n  \" multiple :else\n  let code =<< trim END\n    if 1\n    else\n    else\n    endif\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(else):E583: Multiple :else')\n\n  \" :elseif after :else\n  let code =<< trim END\n    if 1\n    else\n    elseif 1\n    endif\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(elseif):E584: :elseif after :else')\n\n  call delete('Xtest')\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 54:  Nesting errors: :while/:endwhile\t\t\t\t    {{{1\n\"\n\"\t    For nesting errors of :while conditionals the correct error messages\n\"\t    should be given.\n\"\n\"\t    This test reuses the function MESSAGES() from the previous test.\n\"\t    This functions checks the messages in g:msgfile.\n\"-------------------------------------------------------------------------------\n\nfunc Test_nested_while_error()\n  CheckEnglish\n\n  \" :endwhile without :while\n  let code =<< trim END\n    endwhile\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endwhile):E588: :endwhile without :while')\n\n  \" :endwhile without :while\n  let code =<< trim END\n    if 1\n      endwhile\n    endif\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endwhile):E588: :endwhile without :while')\n\n  \" Missing :endif\n  let code =<< trim END\n    while 1\n      if 1\n    endwhile\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endwhile):E171: Missing :endif')\n\n  \" :endwhile without :while\n  let code =<< trim END\n    try\n    finally\n      endwhile\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endwhile):E588: :endwhile without :while')\n\n  \" Missing :endtry\n  let code =<< trim END\n    while 1\n      try\n      finally\n    endwhile\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endwhile):E600: Missing :endtry')\n\n  \" Missing :endtry\n  let code =<< trim END\n    while 1\n      if 1\n        try\n        finally\n    endwhile\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endwhile):E600: Missing :endtry')\n\n  \" Missing :endif\n  let code =<< trim END\n    while 1\n      try\n      finally\n        if 1\n    endwhile\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endwhile):E171: Missing :endif')\n\n  \" :endwhile without :while\n  let code =<< trim END\n    try\n      endwhile\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endwhile):E588: :endwhile without :while')\n\n  \" :endwhile without :while\n  let code =<< trim END\n    while 1\n      try\n        endwhile\n      endtry\n    endwhile\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endwhile):E588: :endwhile without :while')\n\n  \" :endwhile without :while\n  let code =<< trim END\n    try\n      throw \"a\"\n    catch /a/\n      endwhile\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endwhile):E588: :endwhile without :while')\n\n  \" :endwhile without :while\n  let code =<< trim END\n    while 1\n      try\n        throw \"a\"\n      catch /a/\n        endwhile\n      endtry\n    endwhile\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endwhile):E588: :endwhile without :while')\n\n  call delete('Xtest')\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 55:  Nesting errors: :continue/:break\t\t\t\t    {{{1\n\"\n\"\t    For nesting errors of :continue and :break commands the correct\n\"\t    error messages should be given.\n\"\n\"\t    This test reuses the function MESSAGES() from the previous test.\n\"\t    This functions checks the messages in g:msgfile.\n\"-------------------------------------------------------------------------------\n\nfunc Test_nested_cont_break_error()\n  CheckEnglish\n\n  \" :continue without :while\n  let code =<< trim END\n    continue\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(continue):E586: :continue without :while or :for')\n\n  \" :continue without :while\n  let code =<< trim END\n    if 1\n      continue\n    endif\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(continue):E586: :continue without :while or :for')\n\n  \" :continue without :while\n  let code =<< trim END\n    try\n    finally\n      continue\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(continue):E586: :continue without :while or :for')\n\n  \" :continue without :while\n  let code =<< trim END\n    try\n      continue\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(continue):E586: :continue without :while or :for')\n\n  \" :continue without :while\n  let code =<< trim END\n    try\n      throw \"a\"\n    catch /a/\n      continue\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(continue):E586: :continue without :while or :for')\n\n  \" :break without :while\n  let code =<< trim END\n    break\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(break):E587: :break without :while or :for')\n\n  \" :break without :while\n  let code =<< trim END\n    if 1\n      break\n    endif\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(break):E587: :break without :while or :for')\n\n  \" :break without :while\n  let code =<< trim END\n    try\n    finally\n      break\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(break):E587: :break without :while or :for')\n\n  \" :break without :while\n  let code =<< trim END\n    try\n      break\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(break):E587: :break without :while or :for')\n\n  \" :break without :while\n  let code =<< trim END\n    try\n      throw \"a\"\n    catch /a/\n      break\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(break):E587: :break without :while or :for')\n\n  call delete('Xtest')\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 56:  Nesting errors: :endtry\t\t\t\t\t    {{{1\n\"\n\"\t    For nesting errors of :try conditionals the correct error messages\n\"\t    should be given.\n\"\n\"\t    This test reuses the function MESSAGES() from the previous test.\n\"\t    This functions checks the messages in g:msgfile.\n\"-------------------------------------------------------------------------------\n\nfunc Test_nested_endtry_error()\n  CheckEnglish\n\n  \" :endtry without :try\n  let code =<< trim END\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endtry):E602: :endtry without :try')\n\n  \" :endtry without :try\n  let code =<< trim END\n    if 1\n      endtry\n    endif\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endtry):E602: :endtry without :try')\n\n  \" :endtry without :try\n  let code =<< trim END\n    while 1\n      endtry\n    endwhile\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endtry):E602: :endtry without :try')\n\n  \" Missing :endif\n  let code =<< trim END\n    try\n        if 1\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endtry):E171: Missing :endif')\n\n  \" Missing :endwhile\n  let code =<< trim END\n    try\n      while 1\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endtry):E170: Missing :endwhile')\n\n  \" Missing :endif\n  let code =<< trim END\n    try\n    finally\n      if 1\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endtry):E171: Missing :endif')\n\n  \" Missing :endwhile\n  let code =<< trim END\n    try\n    finally\n      while 1\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endtry):E170: Missing :endwhile')\n\n  \" Missing :endif\n  let code =<< trim END\n    try\n      throw \"a\"\n    catch /a/\n      if 1\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endtry):E171: Missing :endif')\n\n  \" Missing :endwhile\n  let code =<< trim END\n    try\n      throw \"a\"\n    catch /a/\n      while 1\n    endtry\n  END\n  call writefile(code, 'Xtest')\n  call AssertException(['source Xtest'], 'Vim(endtry):E170: Missing :endwhile')\n\n  call delete('Xtest')\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 57:  v:exception and v:throwpoint for user exceptions\t\t    {{{1\n\"\n\"\t    v:exception evaluates to the value of the exception that was caught\n\"\t    most recently and is not finished.  (A caught exception is finished\n\"\t    when the next \":catch\", \":finally\", or \":endtry\" is reached.)\n\"\t    v:throwpoint evaluates to the script/function name and line number\n\"\t    where that exception has been thrown.\n\"-------------------------------------------------------------------------------\n\nfunc Test_user_exception_info()\n  CheckEnglish\n\n  XpathINIT\n  XloopINIT\n\n  func FuncException()\n    let g:exception = v:exception\n  endfunc\n\n  func FuncThrowpoint()\n    let g:throwpoint = v:throwpoint\n  endfunc\n\n  let scriptException  = MakeScript(\"FuncException\")\n  let scriptThrowPoint = MakeScript(\"FuncThrowpoint\")\n\n  command! CmdException  let g:exception  = v:exception\n  command! CmdThrowpoint let g:throwpoint = v:throwpoint\n\n  func T(arg, line)\n    if a:line == 2\n      throw a:arg\t\t\" in line 2\n    elseif a:line == 4\n      throw a:arg\t\t\" in line 4\n    elseif a:line == 6\n      throw a:arg\t\t\" in line 6\n    elseif a:line == 8\n      throw a:arg\t\t\" in line 8\n    endif\n  endfunc\n\n  func G(arg, line)\n    call T(a:arg, a:line)\n  endfunc\n\n  func F(arg, line)\n    call G(a:arg, a:line)\n  endfunc\n\n  let scriptT = MakeScript(\"T\")\n  let scriptG = MakeScript(\"G\", scriptT)\n  let scriptF = MakeScript(\"F\", scriptG)\n\n  try\n    Xpath 'a'\n    call F(\"oops\", 2)\n  catch /.*/\n    Xpath 'b'\n    let exception  = v:exception\n    let throwpoint = v:throwpoint\n    call assert_equal(\"oops\", v:exception)\n    call assert_match('\\<F\\[1]\\.\\.G\\[1]\\.\\.T\\>', v:throwpoint)\n    call assert_match('\\<2\\>', v:throwpoint)\n\n    exec \"let exception  = v:exception\"\n    exec \"let throwpoint = v:throwpoint\"\n    call assert_equal(\"oops\", v:exception)\n    call assert_match('\\<F\\[1]\\.\\.G\\[1]\\.\\.T\\>', v:throwpoint)\n    call assert_match('\\<2\\>', v:throwpoint)\n\n    CmdException\n    CmdThrowpoint\n    call assert_equal(\"oops\", v:exception)\n    call assert_match('\\<F\\[1]\\.\\.G\\[1]\\.\\.T\\>', v:throwpoint)\n    call assert_match('\\<2\\>', v:throwpoint)\n\n    call FuncException()\n    call FuncThrowpoint()\n    call assert_equal(\"oops\", v:exception)\n    call assert_match('\\<F\\[1]\\.\\.G\\[1]\\.\\.T\\>', v:throwpoint)\n    call assert_match('\\<2\\>', v:throwpoint)\n\n    exec \"source\" scriptException\n    exec \"source\" scriptThrowPoint\n    call assert_equal(\"oops\", v:exception)\n    call assert_match('\\<F\\[1]\\.\\.G\\[1]\\.\\.T\\>', v:throwpoint)\n    call assert_match('\\<2\\>', v:throwpoint)\n\n    try\n      Xpath 'c'\n      call G(\"arrgh\", 4)\n    catch /.*/\n      Xpath 'd'\n      let exception  = v:exception\n      let throwpoint = v:throwpoint\n      call assert_equal(\"arrgh\", v:exception)\n      call assert_match('\\<G\\[1]\\.\\.T\\>', v:throwpoint)\n      call assert_match('\\<4\\>', v:throwpoint)\n\n      try\n        Xpath 'e'\n        let g:arg = \"autsch\"\n        let g:line = 6\n        exec \"source\" scriptF\n      catch /.*/\n        Xpath 'f'\n        let exception  = v:exception\n        let throwpoint = v:throwpoint\n        call assert_equal(\"autsch\", v:exception)\n        call assert_match(fnamemodify(scriptT, ':t'), v:throwpoint)\n        call assert_match('\\<6\\>', v:throwpoint)\n      finally\n        Xpath 'g'\n        let exception  = v:exception\n        let throwpoint = v:throwpoint\n        call assert_equal(\"arrgh\", v:exception)\n        call assert_match('\\<G\\[1]\\.\\.T\\>', v:throwpoint)\n        call assert_match('\\<4\\>', v:throwpoint)\n        try\n          Xpath 'h'\n          let g:arg = \"brrrr\"\n          let g:line = 8\n          exec \"source\" scriptG\n        catch /.*/\n          Xpath 'i'\n          let exception  = v:exception\n          let throwpoint = v:throwpoint\n          \" Resolve scriptT for matching it against v:throwpoint.\n          call assert_equal(\"brrrr\", v:exception)\n          call assert_match(fnamemodify(scriptT, ':t'), v:throwpoint)\n          call assert_match('\\<8\\>', v:throwpoint)\n        finally\n          Xpath 'j'\n          let exception  = v:exception\n          let throwpoint = v:throwpoint\n          call assert_equal(\"arrgh\", v:exception)\n          call assert_match('\\<G\\[1]\\.\\.T\\>', v:throwpoint)\n          call assert_match('\\<4\\>', v:throwpoint)\n        endtry\n        Xpath 'k'\n        let exception  = v:exception\n        let throwpoint = v:throwpoint\n        call assert_equal(\"arrgh\", v:exception)\n        call assert_match('\\<G\\[1]\\.\\.T\\>', v:throwpoint)\n        call assert_match('\\<4\\>', v:throwpoint)\n      endtry\n      Xpath 'l'\n      let exception  = v:exception\n      let throwpoint = v:throwpoint\n      call assert_equal(\"arrgh\", v:exception)\n      call assert_match('\\<G\\[1]\\.\\.T\\>', v:throwpoint)\n      call assert_match('\\<4\\>', v:throwpoint)\n    finally\n      Xpath 'm'\n      let exception  = v:exception\n      let throwpoint = v:throwpoint\n      call assert_equal(\"oops\", v:exception)\n      call assert_match('\\<F\\[1]\\.\\.G\\[1]\\.\\.T\\>', v:throwpoint)\n      call assert_match('\\<2\\>', v:throwpoint)\n    endtry\n    Xpath 'n'\n    let exception  = v:exception\n    let throwpoint = v:throwpoint\n    call assert_equal(\"oops\", v:exception)\n    call assert_match('\\<F\\[1]\\.\\.G\\[1]\\.\\.T\\>', v:throwpoint)\n    call assert_match('\\<2\\>', v:throwpoint)\n  finally\n    Xpath 'o'\n    let exception  = v:exception\n    let throwpoint = v:throwpoint\n    call assert_equal(\"\", v:exception)\n    call assert_match('^$', v:throwpoint)\n    call assert_match('^$', v:throwpoint)\n  endtry\n\n  call assert_equal('abcdefghijklmno', g:Xpath)\n\n  unlet exception throwpoint\n  delfunction FuncException\n  delfunction FuncThrowpoint\n  call delete(scriptException)\n  call delete(scriptThrowPoint)\n  unlet scriptException scriptThrowPoint\n  delcommand CmdException\n  delcommand CmdThrowpoint\n  delfunction T\n  delfunction G\n  delfunction F\n  call delete(scriptT)\n  call delete(scriptG)\n  call delete(scriptF)\n  unlet scriptT scriptG scriptF\nendfunc\n\n\"-------------------------------------------------------------------------------\n\"\n\" Test 58:  v:exception and v:throwpoint for error/interrupt exceptions\t    {{{1\n\"\n\"\t    v:exception and v:throwpoint work also for error and interrupt\n\"\t    exceptions.\n\"-------------------------------------------------------------------------------\n\nfunc Test_exception_info_for_error()\n  CheckEnglish\n\n  let test =<< trim [CODE]\n    func T(line)\n      if a:line == 2\n        delfunction T\t\t\" error (function in use) in line 2\n      elseif a:line == 4\n        call interrupt()\n      endif\n    endfunc\n\n    while 1\n      try\n        Xpath 'a'\n        call T(2)\n        call assert_report('should not get here')\n      catch /.*/\n        Xpath 'b'\n        if v:exception !~ 'Vim(delfunction):'\n          call assert_report('should not get here')\n        endif\n        if v:throwpoint !~ '\\<T\\>'\n          call assert_report('should not get here')\n        endif\n        if v:throwpoint !~ '\\<2\\>'\n          call assert_report('should not get here')\n        endif\n      finally\n        Xpath 'c'\n        if v:exception != \"\"\n          call assert_report('should not get here')\n        endif\n        if v:throwpoint != \"\"\n          call assert_report('should not get here')\n        endif\n        break\n      endtry\n    endwhile\n\n    Xpath 'd'\n    if v:exception != \"\"\n      call assert_report('should not get here')\n    endif\n    if v:throwpoint != \"\"\n      call assert_report('should not get here')\n    endif\n\n    while 1\n      try\n        Xpath 'e'\n        call T(4)\n        call assert_report('should not get here')\n      catch /.*/\n        Xpath 'f'\n        if v:exception != 'Vim:Interrupt'\n          call assert_report('should not get here')\n        endif\n        if v:throwpoint !~ 'function T'\n          call assert_report('should not get here')\n        endif\n        if v:throwpoint !~ '\\<4\\>'\n          call assert_report('should not get here')\n        endif\n      finally\n        Xpath 'g'\n        if v:exception != \"\"\n          call assert_report('should not get here')\n        endif\n        if v:throwpoint != \"\"\n          call assert_report('should not get here')\n        endif\n        break\n      endtry\n    endwhile\n\n    Xpath 'h'\n    if v:exception != \"\"\n      call assert_report('should not get here')\n    endif\n    if v:throwpoint != \"\"\n      call assert_report('should not get here')\n    endif\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcdefgh', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\"\n\" Test 59:  v:exception and v:throwpoint when discarding exceptions\t    {{{1\n\"\n\"\t    When a :catch clause is left by a \":break\" etc or an error or\n\"\t    interrupt exception, v:exception and v:throwpoint are reset.  They\n\"\t    are not affected by an exception that is discarded before being\n\"\t    caught.\n\"-------------------------------------------------------------------------------\nfunc Test_exception_info_on_discard()\n  CheckEnglish\n\n  let test =<< trim [CODE]\n    let sfile = expand(\"<sfile>\")\n\n    while 1\n      try\n        throw \"x1\"\n      catch /.*/\n        break\n      endtry\n    endwhile\n    call assert_equal('', v:exception)\n    call assert_equal('', v:throwpoint)\n\n    while 1\n      try\n        throw \"x2\"\n      catch /.*/\n        break\n      finally\n        call assert_equal('', v:exception)\n        call assert_equal('', v:throwpoint)\n      endtry\n      break\n    endwhile\n    call assert_equal('', v:exception)\n    call assert_equal('', v:throwpoint)\n\n    while 1\n      try\n        let errcaught = 0\n        try\n          try\n            throw \"x3\"\n          catch /.*/\n            let lnum = expand(\"<sflnum>\")\n            asdf\n          endtry\n        catch /.*/\n          let errcaught = 1\n          call assert_match('Vim:E492: Not an editor command:', v:exception)\n          call assert_match('line ' .. (lnum + 1), v:throwpoint)\n        endtry\n      finally\n        call assert_equal(1, errcaught)\n        break\n      endtry\n    endwhile\n    call assert_equal('', v:exception)\n    call assert_equal('', v:throwpoint)\n\n    Xpath 'a'\n\n    while 1\n      try\n        let intcaught = 0\n        try\n          try\n            throw \"x4\"\n          catch /.*/\n            let lnum = expand(\"<sflnum>\")\n            call interrupt()\n          endtry\n        catch /.*/\n          let intcaught = 1\n          call assert_match('Vim:Interrupt', v:exception)\n          call assert_match('line ' .. (lnum + 1), v:throwpoint)\n        endtry\n      finally\n        call assert_equal(1, intcaught)\n        break\n      endtry\n    endwhile\n    call assert_equal('', v:exception)\n    call assert_equal('', v:throwpoint)\n\n    Xpath 'b'\n\n    while 1\n      try\n        let errcaught = 0\n        try\n          try\n            if 1\n              let lnum = expand(\"<sflnum>\")\n              throw \"x5\"\n            \" missing endif\n          catch /.*/\n            call assert_report('should not get here')\n          endtry\n        catch /.*/\n          let errcaught = 1\n          call assert_match('Vim(catch):E171: Missing :endif:', v:exception)\n          call assert_match('line ' .. (lnum + 3), v:throwpoint)\n        endtry\n      finally\n        call assert_equal(1, errcaught)\n        break\n      endtry\n    endwhile\n    call assert_equal('', v:exception)\n    call assert_equal('', v:throwpoint)\n\n    Xpath 'c'\n\n    try\n      while 1\n        try\n          throw \"x6\"\n        finally\n          break\n        endtry\n        break\n      endwhile\n    catch /.*/\n      call assert_report('should not get here')\n    endtry\n    call assert_equal('', v:exception)\n    call assert_equal('', v:throwpoint)\n\n    try\n      while 1\n        try\n          throw \"x7\"\n        finally\n          break\n        endtry\n        break\n      endwhile\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      call assert_equal('', v:exception)\n      call assert_equal('', v:throwpoint)\n    endtry\n    call assert_equal('', v:exception)\n    call assert_equal('', v:throwpoint)\n\n    while 1\n      try\n        let errcaught = 0\n        try\n          try\n            throw \"x8\"\n          finally\n            let lnum = expand(\"<sflnum>\")\n            asdf\n          endtry\n        catch /.*/\n          let errcaught = 1\n          call assert_match('Vim:E492: Not an editor command:', v:exception)\n          call assert_match('line ' .. (lnum + 1), v:throwpoint)\n        endtry\n      finally\n        call assert_equal(1, errcaught)\n        break\n      endtry\n    endwhile\n    call assert_equal('', v:exception)\n    call assert_equal('', v:throwpoint)\n\n    Xpath 'd'\n\n    while 1\n      try\n        let intcaught = 0\n        try\n          try\n            throw \"x9\"\n          finally\n            let lnum = expand(\"<sflnum>\")\n            call interrupt()\n          endtry\n        catch /.*/\n          let intcaught = 1\n          call assert_match('Vim:Interrupt', v:exception)\n          call assert_match('line ' .. (lnum + 1), v:throwpoint)\n        endtry\n      finally\n        call assert_equal(1, intcaught)\n        break\n      endtry\n    endwhile\n    call assert_equal('', v:exception)\n    call assert_equal('', v:throwpoint)\n\n    Xpath 'e'\n\n    while 1\n      try\n        let errcaught = 0\n        try\n          try\n            if 1\n              let lnum = expand(\"<sflnum>\")\n              throw \"x10\"\n            \" missing endif\n          finally\n            call assert_equal('', v:exception)\n            call assert_equal('', v:throwpoint)\n          endtry\n        catch /.*/\n          let errcaught = 1\n          call assert_match('Vim(finally):E171: Missing :endif:', v:exception)\n          call assert_match('line ' .. (lnum + 3), v:throwpoint)\n        endtry\n      finally\n        call assert_equal(1, errcaught)\n        break\n      endtry\n    endwhile\n    call assert_equal('', v:exception)\n    call assert_equal('', v:throwpoint)\n\n    Xpath 'f'\n\n    while 1\n      try\n        let errcaught = 0\n        try\n          try\n            if 1\n              let lnum = expand(\"<sflnum>\")\n              throw \"x11\"\n            \" missing endif\n          endtry\n        catch /.*/\n          let errcaught = 1\n          call assert_match('Vim(endtry):E171: Missing :endif:', v:exception)\n          call assert_match('line ' .. (lnum + 3), v:throwpoint)\n        endtry\n      finally\n        call assert_equal(1, errcaught)\n        break\n      endtry\n    endwhile\n    call assert_equal('', v:exception)\n    call assert_equal('', v:throwpoint)\n\n    Xpath 'g'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcdefg', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\"\n\" Test 60:  (Re)throwing v:exception; :echoerr.\t\t\t\t    {{{1\n\"\n\"\t    A user exception can be rethrown after catching by throwing\n\"\t    v:exception.  An error or interrupt exception cannot be rethrown\n\"\t    because Vim exceptions cannot be faked.  A Vim exception using the\n\"\t    value of v:exception can, however, be triggered by the :echoerr\n\"\t    command.\n\"-------------------------------------------------------------------------------\n\nfunc Test_rethrow_exception_1()\n  XpathINIT\n  try\n    try\n      Xpath 'a'\n      throw \"oops\"\n    catch /oops/\n      Xpath 'b'\n      throw v:exception\t\" rethrow user exception\n    catch /.*/\n      call assert_report('should not get here')\n    endtry\n  catch /^oops$/\t\t\t\" catches rethrown user exception\n    Xpath 'c'\n  catch /.*/\n    call assert_report('should not get here')\n  endtry\n  call assert_equal('abc', g:Xpath)\nendfunc\n\nfunc Test_rethrow_exception_2()\n  XpathINIT\n  try\n    let caught = 0\n    try\n      Xpath 'a'\n      write /n/o/n/w/r/i/t/a/b/l/e/_/f/i/l/e\n      call assert_report('should not get here')\n    catch /^Vim(write):/\n      let caught = 1\n      throw v:exception\t\" throw error: cannot fake Vim exception\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      Xpath 'b'\n      call assert_equal(1, caught)\n    endtry\n  catch /^Vim(throw):/\t\" catches throw error\n    let caught = caught + 1\n  catch /.*/\n    call assert_report('should not get here')\n  finally\n    Xpath 'c'\n    call assert_equal(2, caught)\n  endtry\n  call assert_equal('abc', g:Xpath)\nendfunc\n\nfunc Test_rethrow_exception_3()\n  XpathINIT\n  try\n    let caught = 0\n    try\n      Xpath 'a'\n      asdf\n    catch /^Vim/\t\t\" catch error exception\n      let caught = 1\n      \" Trigger Vim error exception with value specified after :echoerr\n      let value = substitute(v:exception, '^Vim\\((.*)\\)\\=:', '', \"\")\n      echoerr value\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      Xpath 'b'\n      call assert_equal(1, caught)\n    endtry\n  catch /^Vim(echoerr):/\n    let caught = caught + 1\n    call assert_match(value, v:exception)\n  catch /.*/\n    call assert_report('should not get here')\n  finally\n    Xpath 'c'\n    call assert_equal(2, caught)\n  endtry\n  call assert_equal('abc', g:Xpath)\nendfunc\n\nfunc Test_rethrow_exception_3()\n  XpathINIT\n  try\n    let errcaught = 0\n    try\n      Xpath 'a'\n      let intcaught = 0\n      call interrupt()\n    catch /^Vim:/\t\t\" catch interrupt exception\n      let intcaught = 1\n      \" Trigger Vim error exception with value specified after :echoerr\n      echoerr substitute(v:exception, '^Vim\\((.*)\\)\\=:', '', \"\")\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      Xpath 'b'\n      call assert_equal(1, intcaught)\n    endtry\n  catch /^Vim(echoerr):/\n    let errcaught = 1\n    call assert_match('Interrupt', v:exception)\n  finally\n    Xpath 'c'\n    call assert_equal(1, errcaught)\n  endtry\n  call assert_equal('abc', g:Xpath)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 61:  Catching interrupt exceptions\t\t\t\t    {{{1\n\"\n\"\t    When an interrupt occurs inside a :try/:endtry region, an\n\"\t    interrupt exception is thrown and can be caught.  Its value is\n\"\t    \"Vim:Interrupt\".  If the interrupt occurs after an error or a :throw\n\"\t    but before a matching :catch is reached, all following :catches of\n\"\t    that try block are ignored, but the interrupt exception can be\n\"\t    caught by the next surrounding try conditional.  An interrupt is\n\"\t    ignored when there is a previous interrupt that has not been caught\n\"\t    or causes a :finally clause to be executed.\n\"-------------------------------------------------------------------------------\n\nfunc Test_catch_intr_exception()\n  let test =<< trim [CODE]\n    while 1\n      try\n        try\n          Xpath 'a'\n          call interrupt()\n          call assert_report('should not get here')\n        catch /^Vim:Interrupt$/\n          Xpath 'b'\n        finally\n          Xpath 'c'\n        endtry\n      catch /.*/\n        call assert_report('should not get here')\n      finally\n        Xpath 'd'\n        break\n      endtry\n    endwhile\n\n    while 1\n      try\n        try\n          try\n            Xpath 'e'\n            asdf\n            call assert_report('should not get here')\n          catch /do_not_catch/\n            call assert_report('should not get here')\n          catch /.*/\n            Xpath 'f'\n            call interrupt()\n            call assert_report('should not get here')\n          catch /.*/\n            call assert_report('should not get here')\n          finally\n            Xpath 'g'\n            call interrupt()\n            call assert_report('should not get here')\n          endtry\n        catch /^Vim:Interrupt$/\n          Xpath 'h'\n        finally\n          Xpath 'i'\n        endtry\n      catch /.*/\n        call assert_report('should not get here')\n      finally\n        Xpath 'j'\n        break\n      endtry\n    endwhile\n\n    while 1\n      try\n        try\n          try\n            Xpath 'k'\n            throw \"x\"\n            call assert_report('should not get here')\n          catch /do_not_catch/\n            call assert_report('should not get here')\n          catch /x/\n            Xpath 'l'\n            call interrupt()\n            call assert_report('should not get here')\n          catch /.*/\n            call assert_report('should not get here')\n          endtry\n        catch /^Vim:Interrupt$/\n          Xpath 'm'\n        finally\n          Xpath 'n'\n        endtry\n      catch /.*/\n        call assert_report('should not get here')\n      finally\n        Xpath 'o'\n        break\n      endtry\n    endwhile\n\n    while 1\n      try\n        try\n          Xpath 'p'\n          call interrupt()\n          call assert_report('should not get here')\n        catch /do_not_catch/\n          call interrupt()\n          call assert_report('should not get here')\n        catch /^Vim:Interrupt$/\n          Xpath 'q'\n        finally\n          Xpath 'r'\n        endtry\n      catch /.*/\n        call assert_report('should not get here')\n      finally\n        Xpath 's'\n        break\n      endtry\n    endwhile\n\n    Xpath 't'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcdefghijklmnopqrst', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 62:  Catching error exceptions\t\t\t\t\t    {{{1\n\"\n\"\t    An error inside a :try/:endtry region is converted to an exception\n\"\t    and can be caught.  The error exception has a \"Vim(cmdname):\" prefix\n\"\t    where cmdname is the name of the failing command, or a \"Vim:\" prefix\n\"\t    if no command name is known.  The \"Vim\" prefixes cannot be faked.\n\"-------------------------------------------------------------------------------\n\nfunc Test_catch_err_exception_1()\n  XpathINIT\n  while 1\n    try\n      try\n        let caught = 0\n        unlet novar\n      catch /^Vim(unlet):/\n        Xpath 'a'\n        let caught = 1\n        let v:errmsg = substitute(v:exception, '^Vim(unlet):', '', \"\")\n      finally\n        Xpath 'b'\n        call assert_equal(1, caught)\n        call assert_match('E108: No such variable: \"novar\"', v:errmsg)\n      endtry\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      Xpath 'c'\n      break\n    endtry\n    call assert_report('should not get here')\n  endwhile\n  call assert_equal('abc', g:Xpath)\nendfunc\n\nfunc Test_catch_err_exception_2()\n  XpathINIT\n  while 1\n    try\n      try\n        let caught = 0\n        throw novar\t\t\t\" error in :throw\n      catch /^Vim(throw):/\n        Xpath 'a'\n        let caught = 1\n        let v:errmsg = substitute(v:exception, '^Vim(throw):', '', \"\")\n      finally\n        Xpath 'b'\n        call assert_equal(1, caught)\n        call assert_match('E121: Undefined variable: novar', v:errmsg)\n      endtry\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      Xpath 'c'\n      break\n    endtry\n    call assert_report('should not get here')\n  endwhile\n  call assert_equal('abc', g:Xpath)\nendfunc\n\nfunc Test_catch_err_exception_3()\n  XpathINIT\n  while 1\n    try\n      try\n        let caught = 0\n        throw \"Vim:faked\"\t\t\" error: cannot fake Vim exception\n      catch /^Vim(throw):/\n        Xpath 'a'\n        let caught = 1\n        let v:errmsg = substitute(v:exception, '^Vim(throw):', '', \"\")\n      finally\n        Xpath 'b'\n        call assert_equal(1, caught)\n        call assert_match(\"E608: Cannot :throw exceptions with 'Vim' prefix\",\n              \\ v:errmsg)\n      endtry\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      Xpath 'c'\n      break\n    endtry\n    call assert_report('should not get here')\n  endwhile\n  call assert_equal('abc', g:Xpath)\nendfunc\n\nfunc Test_catch_err_exception_4()\n  XpathINIT\n  func F()\n    while 1\n    \" Missing :endwhile\n  endfunc\n\n  while 1\n    try\n      try\n        let caught = 0\n        call F()\n      catch /^Vim(endfunction):/\n        Xpath 'a'\n        let caught = 1\n        let v:errmsg = substitute(v:exception, '^Vim(endfunction):', '', \"\")\n      finally\n        Xpath 'b'\n        call assert_equal(1, caught)\n        call assert_match(\"E170: Missing :endwhile\", v:errmsg)\n      endtry\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      Xpath 'c'\n      break\n    endtry\n    call assert_report('should not get here')\n  endwhile\n  call assert_equal('abc', g:Xpath)\n  delfunc F\nendfunc\n\nfunc Test_catch_err_exception_5()\n  XpathINIT\n  func F()\n    while 1\n    \" Missing :endwhile\n  endfunc\n\n  while 1\n    try\n      try\n        let caught = 0\n        ExecAsScript F\n      catch /^Vim:/\n        Xpath 'a'\n        let caught = 1\n        let v:errmsg = substitute(v:exception, '^Vim:', '', \"\")\n      finally\n        Xpath 'b'\n        call assert_equal(1, caught)\n        call assert_match(\"E170: Missing :endwhile\", v:errmsg)\n      endtry\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      Xpath 'c'\n      break\n    endtry\n    call assert_report('should not get here')\n  endwhile\n  call assert_equal('abc', g:Xpath)\n  delfunc F\nendfunc\n\nfunc Test_catch_err_exception_6()\n  XpathINIT\n  func G()\n    call G()\n  endfunc\n\n  while 1\n    try\n      let mfd_save = &mfd\n      set mfd=3\n      try\n        let caught = 0\n        call G()\n      catch /^Vim(call):/\n        Xpath 'a'\n        let caught = 1\n        let v:errmsg = substitute(v:exception, '^Vim(call):', '', \"\")\n      finally\n        Xpath 'b'\n        call assert_equal(1, caught)\n        call assert_match(\"E132: Function call depth is higher than 'maxfuncdepth'\", v:errmsg)\n      endtry\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      Xpath 'c'\n      let &mfd = mfd_save\n      break\n    endtry\n    call assert_report('should not get here')\n  endwhile\n  call assert_equal('abc', g:Xpath)\n  delfunc G\nendfunc\n\nfunc Test_catch_err_exception_7()\n  XpathINIT\n  func H()\n    return H()\n  endfunc\n\n  while 1\n    try\n      let mfd_save = &mfd\n      set mfd=3\n      try\n        let caught = 0\n        call H()\n      catch /^Vim(return):/\n        Xpath 'a'\n        let caught = 1\n        let v:errmsg = substitute(v:exception, '^Vim(return):', '', \"\")\n      finally\n        Xpath 'b'\n        call assert_equal(1, caught)\n        call assert_match(\"E132: Function call depth is higher than 'maxfuncdepth'\", v:errmsg)\n      endtry\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      Xpath 'c'\n      let &mfd = mfd_save\n      break\t\t\" discard error for $VIMNOERRTHROW\n    endtry\n    call assert_report('should not get here')\n  endwhile\n\n  call assert_equal('abc', g:Xpath)\n  delfunc H\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 63:  Suppressing error exceptions by :silent!.\t\t\t    {{{1\n\"\n\"\t    A :silent! command inside a :try/:endtry region suppresses the\n\"\t    conversion of errors to an exception and the immediate abortion on\n\"\t    error.  When the commands executed by the :silent! themselves open\n\"\t    a new :try/:endtry region, conversion of errors to exception and\n\"\t    immediate abortion is switched on again - until the next :silent!\n\"\t    etc.  The :silent! has the effect of setting v:errmsg to the error\n\"\t    message text (without displaying it) and continuing with the next\n\"\t    script line.\n\"\n\"\t    When a command triggering autocommands is executed by :silent!\n\"\t    inside a :try/:endtry, the autocommand execution is not suppressed\n\"\t    on error.\n\"\n\"\t    This test reuses the function MSG() from the previous test.\n\"-------------------------------------------------------------------------------\n\nfunc Test_silent_exception()\n  XpathINIT\n  XloopINIT\n  let g:taken = \"\"\n\n  func S(n) abort\n    XloopNEXT\n    let g:taken = g:taken . \"E\" . a:n\n    let v:errmsg = \"\"\n    exec \"asdf\" . a:n\n\n    \" Check that \":silent!\" continues:\n    Xloop 'a'\n\n    \" Check that \":silent!\" sets \"v:errmsg\":\n    call assert_match(\"E492: Not an editor command\", v:errmsg)\n  endfunc\n\n  func Foo()\n    while 1\n      try\n        try\n          let caught = 0\n          \" This is not silent:\n          call S(3)\n        catch /^Vim:/\n          Xpath 'b'\n          let caught = 1\n          let errmsg3 = substitute(v:exception, '^Vim:', '', \"\")\n          silent! call S(4)\n        finally\n          call assert_equal(1, caught)\n          Xpath 'c'\n          call assert_match(\"E492: Not an editor command\", errmsg3)\n          silent! call S(5)\n          \" Break out of try conditionals that cover \":silent!\".  This also\n          \" discards the aborting error when $VIMNOERRTHROW is non-zero.\n          break\n        endtry\n      catch /.*/\n        call assert_report('should not get here')\n      endtry\n    endwhile\n    \" This is a double \":silent!\" (see caller).\n    silent! call S(6)\n  endfunc\n\n  func Bar()\n    try\n      silent! call S(2)\n      silent! execute \"call Foo() | call S(7)\"\n      silent! call S(8)\n    endtry\t\" normal end of try cond that covers \":silent!\"\n    \" This has a \":silent!\" from the caller:\n    call S(9)\n  endfunc\n\n  silent! call S(1)\n  silent! call Bar()\n  silent! call S(10)\n\n  call assert_equal(\"E1E2E3E4E5E6E7E8E9E10\", g:taken)\n\n  augroup TMP\n    au!\n    autocmd BufWritePost * Xpath 'd'\n  augroup END\n\n  Xpath 'e'\n  silent! write /i/m/p/o/s/s/i/b/l/e\n  Xpath 'f'\n\n  call assert_equal('a2a3ba5ca6a7a8a9a10a11edf', g:Xpath)\n\n  augroup TMP\n    au!\n  augroup END\n  augroup! TMP\n  delfunction S\n  delfunction Foo\n  delfunction Bar\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 64:  Error exceptions after error, interrupt or :throw\t\t    {{{1\n\"\n\"\t    When an error occurs after an interrupt or a :throw but before\n\"\t    a matching :catch is reached, all following :catches of that try\n\"\t    block are ignored, but the error exception can be caught by the next\n\"\t    surrounding try conditional.  Any previous error exception is\n\"\t    discarded.  An error is ignored when there is a previous error that\n\"\t    has not been caught.\n\"-------------------------------------------------------------------------------\n\nfunc Test_exception_after_error_1()\n  XpathINIT\n  while 1\n    try\n      try\n        Xpath 'a'\n        let caught = 0\n        while 1\n          if 1\n          \" Missing :endif\n        endwhile\t\" throw error exception\n      catch /^Vim(/\n        Xpath 'b'\n        let caught = 1\n      finally\n        Xpath 'c'\n        call assert_equal(1, caught)\n      endtry\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      Xpath 'd'\n      break\n    endtry\n    call assert_report('should not get here')\n  endwhile\n  call assert_equal('abcd', g:Xpath)\nendfunc\n\nfunc Test_exception_after_error_2()\n  XpathINIT\n  while 1\n    try\n      try\n        Xpath 'a'\n        let caught = 0\n        try\n          if 1\n          \" Missing :endif\n        catch /.*/\t\" throw error exception\n          call assert_report('should not get here')\n        catch /.*/\n          call assert_report('should not get here')\n        endtry\n      catch /^Vim(/\n        Xpath 'b'\n        let caught = 1\n      finally\n        Xpath 'c'\n        call assert_equal(1, caught)\n      endtry\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      Xpath 'd'\n      break\n    endtry\n    call assert_report('should not get here')\n  endwhile\n  call assert_equal('abcd', g:Xpath)\nendfunc\n\nfunc Test_exception_after_error_3()\n  XpathINIT\n  while 1\n    try\n      try\n        let caught = 0\n        try\n          Xpath 'a'\n          call interrupt()\n        catch /do_not_catch/\n          call assert_report('should not get here')\n          if 1\n          \" Missing :endif\n        catch /.*/\t\" throw error exception\n          call assert_report('should not get here')\n        catch /.*/\n          call assert_report('should not get here')\n        endtry\n      catch /^Vim(/\n        Xpath 'b'\n        let caught = 1\n      finally\n        Xpath 'c'\n        call assert_equal(1, caught)\n      endtry\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      Xpath 'd'\n      break\n    endtry\n    call assert_report('should not get here')\n  endwhile\n  call assert_equal('abcd', g:Xpath)\nendfunc\n\nfunc Test_exception_after_error_4()\n  XpathINIT\n  while 1\n    try\n      try\n        let caught = 0\n        try\n          Xpath 'a'\n          throw \"x\"\n        catch /do_not_catch/\n          call assert_report('should not get here')\n          if 1\n          \" Missing :endif\n        catch /x/\t\" throw error exception\n          call assert_report('should not get here')\n        catch /.*/\n          call assert_report('should not get here')\n        endtry\n      catch /^Vim(/\n        Xpath 'b'\n        let caught = 1\n      finally\n        Xpath 'c'\n        call assert_equal(1, caught)\n      endtry\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      Xpath 'd'\n      break\n    endtry\n    call assert_report('should not get here')\n  endwhile\n  call assert_equal('abcd', g:Xpath)\nendfunc\n\nfunc Test_exception_after_error_5()\n  XpathINIT\n  while 1\n    try\n      try\n        let caught = 0\n        Xpath 'a'\n        endif\t\t\" :endif without :if; throw error exception\n        if 1\n        \" Missing :endif\n      catch /do_not_catch/ \" ignore new error\n        call assert_report('should not get here')\n      catch /^Vim(endif):/\n        Xpath 'b'\n        let caught = 1\n      catch /^Vim(/\n        call assert_report('should not get here')\n      finally\n        Xpath 'c'\n        call assert_equal(1, caught)\n      endtry\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      Xpath 'd'\n      break\n    endtry\n    call assert_report('should not get here')\n  endwhile\n  call assert_equal('abcd', g:Xpath)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 65:  Errors in the /pattern/ argument of a :catch\t\t    {{{1\n\"\n\"\t    On an error in the /pattern/ argument of a :catch, the :catch does\n\"\t    not match.  Any following :catches of the same :try/:endtry don't\n\"\t    match either.  Finally clauses are executed.\n\"-------------------------------------------------------------------------------\n\nfunc Test_catch_pattern_error()\n  CheckEnglish\n  XpathINIT\n\n  try\n    try\n      Xpath 'a'\n      throw \"oops\"\n    catch /^oops$/\n      Xpath 'b'\n    catch /\\)/\t\t\" not checked; exception has already been caught\n      call assert_report('should not get here')\n    endtry\n    Xpath 'c'\n  catch /.*/\n    call assert_report('should not get here')\n  endtry\n  call assert_equal('abc', g:Xpath)\n\n  XpathINIT\n  func F()\n    try\n      try\n        try\n          Xpath 'a'\n          throw \"ab\"\n        catch /abc/\t\" does not catch\n          call assert_report('should not get here')\n        catch /\\)/\t\" error; discards exception\n          call assert_report('should not get here')\n        catch /.*/\t\" not checked\n          call assert_report('should not get here')\n        finally\n          Xpath 'b'\n        endtry\n        call assert_report('should not get here')\n      catch /^ab$/\t\" checked, but original exception is discarded\n        call assert_report('should not get here')\n      catch /^Vim(catch):/\n        Xpath 'c'\n        call assert_match('Vim(catch):E475: Invalid argument:', v:exception)\n      finally\n        Xpath 'd'\n      endtry\n      Xpath 'e'\n    catch /.*/\n      call assert_report('should not get here')\n    endtry\n    Xpath 'f'\n  endfunc\n\n  call F()\n  call assert_equal('abcdef', g:Xpath)\n\n  delfunc F\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 66:  Stop range :call on error, interrupt, or :throw\t\t    {{{1\n\"\n\"\t    When a function which is multiply called for a range since it\n\"\t    doesn't handle the range itself has an error in a command\n\"\t    dynamically enclosed by :try/:endtry or gets an interrupt or\n\"\t    executes a :throw, no more calls for the remaining lines in the\n\"\t    range are made.  On an error in a command not dynamically enclosed\n\"\t    by :try/:endtry, the function is executed again for the remaining\n\"\t    lines in the range.\n\"-------------------------------------------------------------------------------\n\nfunc Test_stop_range_on_error()\n  let test =<< trim [CODE]\n    let file = tempname()\n    exec \"edit\" file\n    call setline(1, ['line 1', 'line 2', 'line 3'])\n    let taken = \"\"\n    let expected = \"G1EF1E(1)F1E(2)F1E(3)G2EF2E(1)G3IF3I(1)G4TF4T(1)G5AF5A(1)\"\n\n    func F(reason, n) abort\n      let g:taken = g:taken .. \"F\" .. a:n ..\n                          \\ substitute(a:reason, '\\(\\l\\).*', '\\u\\1', \"\") ..\n                          \\ \"(\" .. line(\".\") .. \")\"\n\n      if a:reason == \"error\"\n        asdf\n      elseif a:reason == \"interrupt\"\n        call interrupt()\n      elseif a:reason == \"throw\"\n        throw \"xyz\"\n      elseif a:reason == \"aborting error\"\n        XloopNEXT\n        call assert_equal(g:taken, g:expected)\n        try\n          bwipeout!\n          call delete(g:file)\n          asdf\n        endtry\n      endif\n    endfunc\n\n    func G(reason, n)\n      let g:taken = g:taken .. \"G\" .. a:n ..\n                              \\ substitute(a:reason, '\\(\\l\\).*', '\\u\\1', \"\")\n      1,3call F(a:reason, a:n)\n    endfunc\n\n    Xpath 'a'\n    call G(\"error\", 1)\n    try\n      Xpath 'b'\n      try\n        call G(\"error\", 2)\n        call assert_report('should not get here')\n      finally\n        Xpath 'c'\n        try\n          call G(\"interrupt\", 3)\n          call assert_report('should not get here')\n        finally\n          Xpath 'd'\n          try\n            call G(\"throw\", 4)\n            call assert_report('should not get here')\n          endtry\n        endtry\n      endtry\n    catch /xyz/\n      Xpath 'e'\n    catch /.*/\n      call assert_report('should not get here')\n    endtry\n    Xpath 'f'\n    call G(\"aborting error\", 5)\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcdef', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 67:  :throw across :call command\t\t\t\t\t    {{{1\n\"\n\"\t    On a call command, an exception might be thrown when evaluating the\n\"\t    function name, during evaluation of the arguments, or when the\n\"\t    function is being executed.  The exception can be caught by the\n\"\t    caller.\n\"-------------------------------------------------------------------------------\n\nfunc THROW(x, n)\n  if a:n == 1\n    Xpath 'A'\n  elseif a:n == 2\n    Xpath 'B'\n  elseif a:n == 3\n    Xpath 'C'\n  endif\n  throw a:x\nendfunc\n\nfunc NAME(x, n)\n  if a:n == 1\n    call assert_report('should not get here')\n  elseif a:n == 2\n    Xpath 'D'\n  elseif a:n == 3\n    Xpath 'E'\n  elseif a:n == 4\n    Xpath 'F'\n  endif\n  return a:x\nendfunc\n\nfunc ARG(x, n)\n  if a:n == 1\n    call assert_report('should not get here')\n  elseif a:n == 2\n    call assert_report('should not get here')\n  elseif a:n == 3\n    Xpath 'G'\n  elseif a:n == 4\n    Xpath 'I'\n  endif\n  return a:x\nendfunc\n\nfunc Test_throw_across_call_cmd()\n  XpathINIT\n\n  func F(x, n)\n    if a:n == 2\n      call assert_report('should not get here')\n    elseif a:n == 4\n      Xpath 'a'\n    endif\n  endfunc\n\n  while 1\n    try\n      let v:errmsg = \"\"\n\n      while 1\n        try\n          Xpath 'b'\n          call {NAME(THROW(\"name\", 1), 1)}(ARG(4711, 1), 1)\n          call assert_report('should not get here')\n        catch /^name$/\n          Xpath 'c'\n        catch /.*/\n          call assert_report('should not get here')\n        finally\n          call assert_equal(\"\", v:errmsg)\n          let v:errmsg = \"\"\n          break\n        endtry\n      endwhile\n\n      while 1\n        try\n          Xpath 'd'\n          call {NAME(\"F\", 2)}(ARG(THROW(\"arg\", 2), 2), 2)\n          call assert_report('should not get here')\n        catch /^arg$/\n          Xpath 'e'\n        catch /.*/\n          call assert_report('should not get here')\n        finally\n          call assert_equal(\"\", v:errmsg)\n          let v:errmsg = \"\"\n          break\n        endtry\n      endwhile\n\n      while 1\n        try\n          Xpath 'f'\n          call {NAME(\"THROW\", 3)}(ARG(\"call\", 3), 3)\n          call assert_report('should not get here')\n        catch /^call$/\n          Xpath 'g'\n        catch /^0$/\t    \" default return value\n          call assert_report('should not get here')\n        catch /.*/\n          call assert_report('should not get here')\n        finally\n          call assert_equal(\"\", v:errmsg)\n          let v:errmsg = \"\"\n          break\n        endtry\n      endwhile\n\n      while 1\n        try\n          Xpath 'h'\n          call {NAME(\"F\", 4)}(ARG(4711, 4), 4)\n          Xpath 'i'\n        catch /.*/\n          call assert_report('should not get here')\n        finally\n          call assert_equal(\"\", v:errmsg)\n          let v:errmsg = \"\"\n          break\n        endtry\n      endwhile\n\n    catch /^0$/\t    \" default return value\n      call assert_report('should not get here')\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      call assert_equal(\"\", v:errmsg)\n      let v:errmsg = \"\"\n      break\n    endtry\n  endwhile\n\n  call assert_equal('bAcdDBefEGCghFIai', g:Xpath)\n  delfunction F\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 68:  :throw across function calls in expressions\t\t\t    {{{1\n\"\n\"\t    On a function call within an expression, an exception might be\n\"\t    thrown when evaluating the function name, during evaluation of the\n\"\t    arguments, or when the function is being executed.  The exception\n\"\t    can be caught by the caller.\n\"\n\"\t    This test reuses the functions THROW(), NAME(), and ARG() from the\n\"\t    previous test.\n\"-------------------------------------------------------------------------------\n\nfunc Test_throw_across_call_expr()\n  XpathINIT\n\n  func F(x, n)\n    if a:n == 2\n      call assert_report('should not get here')\n    elseif a:n == 4\n      Xpath 'a'\n    endif\n    return a:x\n  endfunction\n\n  while 1\n    try\n      let error = 0\n      let v:errmsg = \"\"\n\n      while 1\n        try\n          Xpath 'b'\n          let var1 = {NAME(THROW(\"name\", 1), 1)}(ARG(4711, 1), 1)\n          call assert_report('should not get here')\n        catch /^name$/\n          Xpath 'c'\n        catch /.*/\n          call assert_report('should not get here')\n        finally\n          call assert_equal(\"\", v:errmsg)\n          let v:errmsg = \"\"\n          break\n        endtry\n      endwhile\n      call assert_true(!exists('var1'))\n\n      while 1\n        try\n          Xpath 'd'\n          let var2 = {NAME(\"F\", 2)}(ARG(THROW(\"arg\", 2), 2), 2)\n          call assert_report('should not get here')\n        catch /^arg$/\n          Xpath 'e'\n        catch /.*/\n          call assert_report('should not get here')\n        finally\n          call assert_equal(\"\", v:errmsg)\n          let v:errmsg = \"\"\n          break\n        endtry\n      endwhile\n      call assert_true(!exists('var2'))\n\n      while 1\n        try\n          Xpath 'f'\n          let var3 = {NAME(\"THROW\", 3)}(ARG(\"call\", 3), 3)\n          call assert_report('should not get here')\n        catch /^call$/\n          Xpath 'g'\n        catch /^0$/\t    \" default return value\n          call assert_report('should not get here')\n        catch /.*/\n          call assert_report('should not get here')\n        finally\n          call assert_equal(\"\", v:errmsg)\n          let v:errmsg = \"\"\n          break\n        endtry\n      endwhile\n      call assert_true(!exists('var3'))\n\n      while 1\n        try\n          Xpath 'h'\n          let var4 = {NAME(\"F\", 4)}(ARG(4711, 4), 4)\n          Xpath 'i'\n        catch /.*/\n          call assert_report('should not get here')\n        finally\n          call assert_equal(\"\", v:errmsg)\n          let v:errmsg = \"\"\n          break\n        endtry\n      endwhile\n      call assert_true(exists('var4') && var4 == 4711)\n\n    catch /^0$/\t    \" default return value\n      call assert_report('should not get here')\n    catch /.*/\n      call assert_report('should not get here')\n    finally\n      call assert_equal(\"\", v:errmsg)\n      break\n    endtry\n  endwhile\n\n  call assert_equal('bAcdDBefEGCghFIai', g:Xpath)\n  delfunc F\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 76:  Errors, interrupts, :throw during expression evaluation\t    {{{1\n\"\n\"\t    When a function call made during expression evaluation is aborted\n\"\t    due to an error inside a :try/:endtry region or due to an interrupt\n\"\t    or a :throw, the expression evaluation is aborted as well.\tNo\n\"\t    message is displayed for the cancelled expression evaluation.  On an\n\"\t    error not inside :try/:endtry, the expression evaluation continues.\n\"-------------------------------------------------------------------------------\n\nfunc Test_expr_eval_error()\n  let test =<< trim [CODE]\n    let taken = \"\"\n\n    func ERR(n)\n      let g:taken = g:taken .. \"E\" .. a:n\n      asdf\n    endfunc\n\n    func ERRabort(n) abort\n      let g:taken = g:taken .. \"A\" .. a:n\n      asdf\n    endfunc\t\" returns -1; may cause follow-up msg for illegal var/func name\n\n    func WRAP(n, arg)\n      let g:taken = g:taken .. \"W\" .. a:n\n      let g:saved_errmsg = v:errmsg\n      return arg\n    endfunc\n\n    func INT(n)\n      let g:taken = g:taken .. \"I\" .. a:n\n      call interrupt()\n    endfunc\n\n    func THR(n)\n      let g:taken = g:taken .. \"T\" .. a:n\n      throw \"should not be caught\"\n    endfunc\n\n    func CONT(n)\n      let g:taken = g:taken .. \"C\" .. a:n\n    endfunc\n\n    func MSG(n)\n      let g:taken = g:taken .. \"M\" .. a:n\n      let errmsg = (a:n >= 37 && a:n <= 44) ? g:saved_errmsg : v:errmsg\n      let msgptn = (a:n >= 10 && a:n <= 27) ? \"^$\" : \"asdf\"\n      call assert_match(msgptn, errmsg)\n      let v:errmsg = \"\"\n      let g:saved_errmsg = \"\"\n    endfunc\n\n    let v:errmsg = \"\"\n\n    try\n      let t = 1\n      while t <= 9\n        Xloop 'a'\n        try\n          if t == 1\n            let v{ERR(t) + CONT(t)} = 0\n          elseif t == 2\n            let v{ERR(t) + CONT(t)}\n          elseif t == 3\n            let var = exists('v{ERR(t) + CONT(t)}')\n          elseif t == 4\n            unlet v{ERR(t) + CONT(t)}\n          elseif t == 5\n            function F{ERR(t) + CONT(t)}()\n            endfunction\n          elseif t == 6\n            function F{ERR(t) + CONT(t)}\n          elseif t == 7\n            let var = exists('*F{ERR(t) + CONT(t)}')\n          elseif t == 8\n            delfunction F{ERR(t) + CONT(t)}\n          elseif t == 9\n            let var = ERR(t) + CONT(t)\n          endif\n        catch /asdf/\n          \" v:errmsg is not set when the error message is converted to an\n          \" exception.  Set it to the original error message.\n          let v:errmsg = substitute(v:exception, '^Vim:', '', \"\")\n        catch /^Vim\\((\\a\\+)\\)\\=:/\n          \" An error exception has been thrown after the original error.\n          let v:errmsg = \"\"\n        finally\n          call MSG(t)\n          let t = t + 1\n          XloopNEXT\n          continue\t\" discard an aborting error\n        endtry\n      endwhile\n    catch /.*/\n      call assert_report('should not get here')\n    endtry\n\n    try\n      let t = 10\n      while t <= 18\n        Xloop 'b'\n        try\n          if t == 10\n            let v{INT(t) + CONT(t)} = 0\n          elseif t == 11\n            let v{INT(t) + CONT(t)}\n          elseif t == 12\n            let var = exists('v{INT(t) + CONT(t)}')\n          elseif t == 13\n            unlet v{INT(t) + CONT(t)}\n          elseif t == 14\n            function F{INT(t) + CONT(t)}()\n            endfunction\n          elseif t == 15\n            function F{INT(t) + CONT(t)}\n          elseif t == 16\n            let var = exists('*F{INT(t) + CONT(t)}')\n          elseif t == 17\n            delfunction F{INT(t) + CONT(t)}\n          elseif t == 18\n            let var = INT(t) + CONT(t)\n          endif\n        catch /^Vim\\((\\a\\+)\\)\\=:\\(Interrupt\\)\\@!/\n          \" An error exception has been triggered after the interrupt.\n          let v:errmsg = substitute(v:exception, '^Vim\\((\\a\\+)\\)\\=:', '', \"\")\n        finally\n          call MSG(t)\n          let t = t + 1\n          XloopNEXT\n          continue\t\" discard interrupt\n        endtry\n      endwhile\n    catch /.*/\n      call assert_report('should not get here')\n    endtry\n\n    try\n      let t = 19\n      while t <= 27\n        Xloop 'c'\n        try\n          if t == 19\n            let v{THR(t) + CONT(t)} = 0\n          elseif t == 20\n            let v{THR(t) + CONT(t)}\n          elseif t == 21\n            let var = exists('v{THR(t) + CONT(t)}')\n          elseif t == 22\n            unlet v{THR(t) + CONT(t)}\n          elseif t == 23\n            function F{THR(t) + CONT(t)}()\n            endfunction\n          elseif t == 24\n            function F{THR(t) + CONT(t)}\n          elseif t == 25\n            let var = exists('*F{THR(t) + CONT(t)}')\n          elseif t == 26\n            delfunction F{THR(t) + CONT(t)}\n          elseif t == 27\n            let var = THR(t) + CONT(t)\n          endif\n        catch /^Vim\\((\\a\\+)\\)\\=:/\n          \" An error exception has been triggered after the :throw.\n          let v:errmsg = substitute(v:exception, '^Vim\\((\\a\\+)\\)\\=:', '', \"\")\n        finally\n          call MSG(t)\n          let t = t + 1\n          XloopNEXT\n          continue\t\" discard exception\n        endtry\n      endwhile\n    catch /.*/\n      call assert_report('should not get here')\n    endtry\n\n    let v{ERR(28) + CONT(28)} = 0\n    call MSG(28)\n    let v{ERR(29) + CONT(29)}\n    call MSG(29)\n    let var = exists('v{ERR(30) + CONT(30)}')\n    call MSG(30)\n    unlet v{ERR(31) + CONT(31)}\n    call MSG(31)\n    function F{ERR(32) + CONT(32)}()\n    endfunction\n    call MSG(32)\n    function F{ERR(33) + CONT(33)}\n    call MSG(33)\n    let var = exists('*F{ERR(34) + CONT(34)}')\n    call MSG(34)\n    delfunction F{ERR(35) + CONT(35)}\n    call MSG(35)\n    let var = ERR(36) + CONT(36)\n    call MSG(36)\n\n    let saved_errmsg = \"\"\n\n    let v{WRAP(37, ERRabort(37)) + CONT(37)} = 0\n    call MSG(37)\n    let v{WRAP(38, ERRabort(38)) + CONT(38)}\n    call MSG(38)\n    let var = exists('v{WRAP(39, ERRabort(39)) + CONT(39)}')\n    call MSG(39)\n    unlet v{WRAP(40, ERRabort(40)) + CONT(40)}\n    call MSG(40)\n    function F{WRAP(41, ERRabort(41)) + CONT(41)}()\n    endfunction\n    call MSG(41)\n    function F{WRAP(42, ERRabort(42)) + CONT(42)}\n    call MSG(42)\n    let var = exists('*F{WRAP(43, ERRabort(43)) + CONT(43)}')\n    call MSG(43)\n    delfunction F{WRAP(44, ERRabort(44)) + CONT(44)}\n    call MSG(44)\n    let var = ERRabort(45) + CONT(45)\n    call MSG(45)\n    Xpath 'd'\n\n    let expected = \"\"\n          \\ .. \"E1M1E2M2E3M3E4M4E5M5E6M6E7M7E8M8E9M9\"\n          \\ .. \"I10M10I11M11I12M12I13M13I14M14I15M15I16M16I17M17I18M18\"\n          \\ .. \"T19M19T20M20T21M21T22M22T23M23T24M24T25M25T26M26T27M27\"\n          \\ .. \"E28C28M28E29C29M29E30C30M30E31C31M31E32C32M32E33C33M33\"\n          \\ .. \"E34C34M34E35C35M35E36C36M36\"\n          \\ .. \"A37W37C37M37A38W38C38M38A39W39C39M39A40W40C40M40A41W41C41M41\"\n          \\ .. \"A42W42C42M42A43W43C43M43A44W44C44M44A45C45M45\"\n    call assert_equal(expected, taken)\n  [CODE]\n  let verify =<< trim [CODE]\n    let expected = \"a1a2a3a4a5a6a7a8a9\"\n                      \\ .. \"b10b11b12b13b14b15b16b17b18\"\n                      \\ .. \"c19c20c21c22c23c24c25c26c27d\"\n    call assert_equal(expected, g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 77:  Errors, interrupts, :throw in name{brace-expression}\t    {{{1\n\"\n\"\t    When a function call made during evaluation of an expression in\n\"\t    braces as part of a function name after \":function\" is aborted due\n\"\t    to an error inside a :try/:endtry region or due to an interrupt or\n\"\t    a :throw, the expression evaluation is aborted as well, and the\n\"\t    function definition is ignored, skipping all commands to the\n\"\t    \":endfunction\".  On an error not inside :try/:endtry, the expression\n\"\t    evaluation continues and the function gets defined, and can be\n\"\t    called and deleted.\n\"-------------------------------------------------------------------------------\nfunc Test_brace_expr_error()\n  let test =<< trim [CODE]\n    func ERR() abort\n      Xloop 'a'\n      asdf\n    endfunc\t\t\t\t\t\" returns -1\n\n    func OK()\n      Xloop 'b'\n      let v:errmsg = \"\"\n      return 0\n    endfunc\n\n    let v:errmsg = \"\"\n\n    Xpath 'c'\n    func F{1 + ERR() + OK()}(arg)\n      \" F0 should be defined.\n      if exists(\"a:arg\") && a:arg == \"calling\"\n        Xpath 'd'\n      else\n        call assert_report('should not get here')\n      endif\n    endfunction\n    call assert_equal(\"\", v:errmsg)\n    XloopNEXT\n\n    Xpath 'e'\n    call F{1 + ERR() + OK()}(\"calling\")\n    call assert_equal(\"\", v:errmsg)\n    XloopNEXT\n\n    Xpath 'f'\n    delfunction F{1 + ERR() + OK()}\n    call assert_equal(\"\", v:errmsg)\n    XloopNEXT\n\n    try\n      while 1\n        try\n          Xpath 'g'\n          func G{1 + ERR() + OK()}(arg)\n            \" G0 should not be defined, and the function body should be\n            \" skipped.\n            call assert_report('should not get here')\n            \" Use an unmatched \":finally\" to check whether the body is\n            \" skipped when an error occurs in ERR().  This works whether or\n            \" not the exception is converted to an exception.\n            finally\n              call assert_report('should not get here')\n            endtry\n          try\n            call assert_report('should not get here')\n          endfunction\n\n          call assert_report('should not get here')\n        catch /asdf/\n          \" Jumped to when the function is not defined and the body is\n          \" skipped.\n          Xpath 'h'\n        catch /.*/\n          call assert_report('should not get here')\n        finally\n          Xpath 'i'\n          break\n        endtry\t\t\t\" jumped to when the body is not skipped\n      endwhile\n    catch /.*/\n      call assert_report('should not get here')\n    endtry\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('ca1b1ea2b2dfa3b3ga4hi', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 78:  Messages on parsing errors in expression evaluation\t\t    {{{1\n\"\n\"\t    When an expression evaluation detects a parsing error, an error\n\"\t    message is given and converted to an exception, and the expression\n\"\t    evaluation is aborted.\n\"-------------------------------------------------------------------------------\nfunc Test_expr_eval_error_msg()\n  CheckEnglish\n\n  let test =<< trim [CODE]\n    let taken = \"\"\n\n    func F(n)\n      let g:taken = g:taken . \"F\" . a:n\n    endfunc\n\n    func MSG(n, enr, emsg)\n      let g:taken = g:taken . \"M\" . a:n\n      call assert_match('^' .. a:enr .. ':', v:errmsg)\n      call assert_match(a:emsg, v:errmsg)\n    endfunc\n\n    func CONT(n)\n      let g:taken = g:taken . \"C\" . a:n\n    endfunc\n\n    let v:errmsg = \"\"\n    try\n      let t = 1\n      while t <= 14\n        let g:taken = g:taken . \"T\" . t\n        let v:errmsg = \"\"\n        try\n          if t == 1\n            let v{novar + CONT(t)} = 0\n          elseif t == 2\n            let v{novar + CONT(t)}\n          elseif t == 3\n            let var = exists('v{novar + CONT(t)}')\n          elseif t == 4\n            unlet v{novar + CONT(t)}\n          elseif t == 5\n            function F{novar + CONT(t)}()\n            endfunction\n          elseif t == 6\n            function F{novar + CONT(t)}\n          elseif t == 7\n            let var = exists('*F{novar + CONT(t)}')\n          elseif t == 8\n            delfunction F{novar + CONT(t)}\n          elseif t == 9\n            echo novar + CONT(t)\n          elseif t == 10\n            echo v{novar + CONT(t)}\n          elseif t == 11\n            echo F{novar + CONT(t)}\n          elseif t == 12\n            let var = novar + CONT(t)\n          elseif t == 13\n            let var = v{novar + CONT(t)}\n          elseif t == 14\n            let var = F{novar + CONT(t)}()\n          endif\n        catch /^Vim\\((\\a\\+)\\)\\=:/\n          Xloop 'a'\n          \" v:errmsg is not set when the error message is converted to an\n          \" exception.  Set it to the original error message.\n          let v:errmsg = substitute(v:exception, '^Vim\\((\\a\\+)\\)\\=:', '', \"\")\n        finally\n          Xloop 'b'\n          if t <= 8 && t != 3 && t != 7\n            call MSG(t, 'E475', 'Invalid argument\\>')\n          else\n            call MSG(t, 'E121', \"Undefined variable\")\n          endif\n          let t = t + 1\n          XloopNEXT\n          continue\t\" discard an aborting error\n        endtry\n      endwhile\n    catch /.*/\n      call assert_report('should not get here')\n    endtry\n\n    func T(n, expr, enr, emsg)\n      try\n        let g:taken = g:taken . \"T\" . a:n\n        let v:errmsg = \"\"\n        try\n          execute \"let var = \" . a:expr\n        catch /^Vim\\((\\a\\+)\\)\\=:/\n          Xloop 'c'\n          \" v:errmsg is not set when the error message is converted to an\n          \" exception.  Set it to the original error message.\n          let v:errmsg = substitute(v:exception, '^Vim\\((\\a\\+)\\)\\=:', '', \"\")\n        finally\n          Xloop 'd'\n          call MSG(a:n, a:enr, a:emsg)\n          XloopNEXT\n          \" Discard an aborting error:\n          return\n        endtry\n      catch /.*/\n        call assert_report('should not get here')\n      endtry\n    endfunc\n\n    call T(15, 'Nofunc() + CONT(15)',\t'E117',\t\"Unknown function\")\n    call T(16, 'F(1 2 + CONT(16))',\t'E116',\t\"Invalid arguments\")\n    call T(17, 'F(1, 2) + CONT(17)',\t'E118',\t\"Too many arguments\")\n    call T(18, 'F() + CONT(18)',\t'E119',\t\"Not enough arguments\")\n    call T(19, '{(1} + CONT(19)',\t'E110',\t\"Missing ')'\")\n    call T(20, '(\"abc\"[1) + CONT(20)',\t'E111',\t\"Missing ']'\")\n    call T(21, '(1 +) + CONT(21)',\t'E15',\t\"Invalid expression\")\n    call T(22, '1 2 + CONT(22)',\t'E488',\t\"Trailing characters: 2 +\")\n    call T(23, '(1 ? 2) + CONT(23)',\t'E109',\t\"Missing ':' after '?'\")\n    call T(24, '(\"abc) + CONT(24)',\t'E114',\t\"Missing double quote\")\n    call T(25, \"('abc) + CONT(25)\",\t'E115',\t\"Missing single quote\")\n    call T(26, '& + CONT(26)',\t\t'E112', \"Option name missing\")\n    call T(27, '&asdf + CONT(27)',\t'E113', \"Unknown option\")\n\n    let expected = \"\"\n      \\ .. \"T1M1T2M2T3M3T4M4T5M5T6M6T7M7T8M8T9M9T10M10T11M11T12M12T13M13T14M14\"\n      \\ .. \"T15M15T16M16T17M17T18M18T19M19T20M20T21M21T22M22T23M23T24M24T25M25\"\n      \\ .. \"T26M26T27M27\"\n\n    call assert_equal(expected, taken)\n  [CODE]\n  let verify =<< trim [CODE]\n    let expected = \"a1b1a2b2a3b3a4b4a5b5a6b6a7b7a8b8a9b9a10b10a11b11a12b12\"\n                  \\ .. \"a13b13a14b14c15d15c16d16c17d17c18d18c19d19c20d20\"\n                  \\ .. \"c21d21c22d22c23d23c24d24c25d25c26d26c27d27\"\n    call assert_equal(expected, g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 79:  Throwing one of several errors for the same command\t\t    {{{1\n\"\n\"\t    When several errors appear in a row (for instance during expression\n\"\t    evaluation), the first as the most specific one is used when\n\"\t    throwing an error exception.  If, however, a syntax error is\n\"\t    detected afterwards, this one is used for the error exception.\n\"\t    On a syntax error, the next command is not executed, on a normal\n\"\t    error, however, it is (relevant only in a function without the\n\"\t    \"abort\" flag).  v:errmsg is not set.\n\"\n\"\t    If throwing error exceptions is configured off, v:errmsg is always\n\"\t    set to the latest error message, that is, to the more general\n\"\t    message or the syntax error, respectively.\n\"-------------------------------------------------------------------------------\nfunc Test_throw_multi_error()\n  CheckEnglish\n\n  let test =<< trim [CODE]\n    func NEXT(cmd)\n      exec a:cmd . \" | Xloop 'a'\"\n    endfun\n\n    call NEXT('echo novar')\t\t\t\" (checks nextcmd)\n    XloopNEXT\n    call NEXT('let novar #')\t\t\t\" (skips nextcmd)\n    XloopNEXT\n    call NEXT('unlet novar #')\t\t\t\" (skips nextcmd)\n    XloopNEXT\n    call NEXT('let {novar}')\t\t\t\" (skips nextcmd)\n    XloopNEXT\n    call NEXT('unlet{ novar}')\t\t\t\" (skips nextcmd)\n\n    call assert_equal('a1', g:Xpath)\n    XpathINIT\n    XloopINIT\n\n    func EXEC(cmd)\n      exec a:cmd\n    endfunc\n\n    try\n      while 1\t\t\t\t\" dummy loop\n        try\n          let v:errmsg = \"\"\n          call EXEC('echo novar')\t\" normal error\n        catch /^Vim\\((\\a\\+)\\)\\=:/\n          Xpath 'b'\n          call assert_match('E121: Undefined variable: novar', v:exception)\n        finally\n          Xpath 'c'\n          call assert_equal(\"\", v:errmsg)\n          break\n        endtry\n      endwhile\n\n      Xpath 'd'\n      let cmd = \"let\"\n      while cmd != \"\"\n        try\n          let v:errmsg = \"\"\n          call EXEC(cmd . ' novar #')\t\t\" normal plus syntax error\n        catch /^Vim\\((\\a\\+)\\)\\=:/\n          Xloop 'e'\n          if cmd =~ 'unlet'\n            \" TODO: should get error for 'novar'\n            call assert_match('E488: Trailing characters', v:exception)\n          else\n            call assert_match('E121: Undefined variable: novar', v:exception)\n          endif\n        finally\n          Xloop 'f'\n          call assert_equal(\"\", v:errmsg)\n          if cmd == \"let\"\n            let cmd = \"unlet\"\n          else\n            let cmd = \"\"\n          endif\n          XloopNEXT\n          continue\n        endtry\n      endwhile\n\n      Xpath 'g'\n      let cmd = \"let\"\n      while cmd != \"\"\n        try\n          let v:errmsg = \"\"\n          call EXEC(cmd . ' {novar}')\t\t\" normal plus syntax error\n        catch /^Vim\\((\\a\\+)\\)\\=:/\n          Xloop 'h'\n          call assert_match('E475: Invalid argument: {novar}', v:exception)\n        finally\n          Xloop 'i'\n          call assert_equal(\"\", v:errmsg)\n          if cmd == \"let\"\n            let cmd = \"unlet\"\n          else\n            let cmd = \"\"\n          endif\n          XloopNEXT\n          continue\n        endtry\n      endwhile\n    catch /.*/\n      call assert_report('should not get here')\n    endtry\n    Xpath 'j'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('bcde1f1e2f2gh3i3h4i4j', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 80:  Syntax error in expression for illegal :elseif\t\t    {{{1\n\"\n\"\t    If there is a syntax error in the expression after an illegal\n\"\t    :elseif, an error message is given (or an error exception thrown)\n\"\t    for the illegal :elseif rather than the expression error.\n\"-------------------------------------------------------------------------------\nfunc Test_if_syntax_error()\n  CheckEnglish\n\n  let test =<< trim [CODE]\n    let v:errmsg = \"\"\n    if 0\n    else\n    elseif 1 ||| 2\n    endif\n    Xpath 'a'\n    call assert_match('E584: :elseif after :else', v:errmsg)\n\n    let v:errmsg = \"\"\n    if 1\n    else\n    elseif 1 ||| 2\n    endif\n    Xpath 'b'\n    call assert_match('E584: :elseif after :else', v:errmsg)\n\n    let v:errmsg = \"\"\n    elseif 1 ||| 2\n    Xpath 'c'\n    call assert_match('E582: :elseif without :if', v:errmsg)\n\n    let v:errmsg = \"\"\n    while 1\n      elseif 1 ||| 2\n    endwhile\n    Xpath 'd'\n    call assert_match('E582: :elseif without :if', v:errmsg)\n\n    while 1\n      try\n        try\n          let v:errmsg = \"\"\n          if 0\n          else\n          elseif 1 ||| 2\n          endif\n        catch /^Vim\\((\\a\\+)\\)\\=:/\n          Xpath 'e'\n          call assert_match('E584: :elseif after :else', v:exception)\n        finally\n          Xpath 'f'\n          call assert_equal(\"\", v:errmsg)\n        endtry\n      catch /.*/\n      call assert_report('should not get here')\n      finally\n        Xpath 'g'\n        break\n      endtry\n    endwhile\n\n    while 1\n      try\n        try\n          let v:errmsg = \"\"\n          if 1\n          else\n          elseif 1 ||| 2\n          endif\n        catch /^Vim\\((\\a\\+)\\)\\=:/\n          Xpath 'h'\n          call assert_match('E584: :elseif after :else', v:exception)\n        finally\n          Xpath 'i'\n          call assert_equal(\"\", v:errmsg)\n        endtry\n      catch /.*/\n        call assert_report('should not get here')\n      finally\n        Xpath 'j'\n        break\n      endtry\n    endwhile\n\n    while 1\n      try\n        try\n          let v:errmsg = \"\"\n          elseif 1 ||| 2\n        catch /^Vim\\((\\a\\+)\\)\\=:/\n          Xpath 'k'\n          call assert_match('E582: :elseif without :if', v:exception)\n        finally\n          Xpath 'l'\n          call assert_equal(\"\", v:errmsg)\n        endtry\n      catch /.*/\n        call assert_report('should not get here')\n      finally\n        Xpath 'm'\n        break\n      endtry\n    endwhile\n\n    while 1\n      try\n        try\n          let v:errmsg = \"\"\n          while 1\n              elseif 1 ||| 2\n          endwhile\n        catch /^Vim\\((\\a\\+)\\)\\=:/\n          Xpath 'n'\n          call assert_match('E582: :elseif without :if', v:exception)\n        finally\n          Xpath 'o'\n          call assert_equal(\"\", v:errmsg)\n        endtry\n      catch /.*/\n        call assert_report('should not get here')\n      finally\n        Xpath 'p'\n        break\n      endtry\n    endwhile\n    Xpath 'q'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcdefghijklmnopq', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 81:  Discarding exceptions after an error or interrupt\t\t    {{{1\n\"\n\"\t    When an exception is thrown from inside a :try conditional without\n\"\t    :catch and :finally clauses and an error or interrupt occurs before\n\"\t    the :endtry is reached, the exception is discarded.\n\"-------------------------------------------------------------------------------\n\nfunc Test_discard_exception_after_error_1()\n  let test =<< trim [CODE]\n    try\n      Xpath 'a'\n      try\n        Xpath 'b'\n        throw \"arrgh\"\n        call assert_report('should not get here')\n        if 1\n        call assert_report('should not get here')\n        \" error after :throw: missing :endif\n      endtry\n      call assert_report('should not get here')\n    catch /arrgh/\n      call assert_report('should not get here')\n    endtry\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('ab', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\" interrupt the code before the endtry is invoked\nfunc Test_discard_exception_after_error_2()\n  XpathINIT\n  let lines =<< trim [CODE]\n    try\n      Xpath 'a'\n      try\n        Xpath 'b'\n        throw \"arrgh\"\n        call assert_report('should not get here')\n      endtry                      \" interrupt here\n      call assert_report('should not get here')\n    catch /arrgh/\n      call assert_report('should not get here')\n    endtry\n    call assert_report('should not get here')\n  [CODE]\n  call writefile(lines, 'Xscript')\n\n  breakadd file 7 Xscript\n  try\n    let caught_intr = 0\n    debuggreedy\n    call feedkeys(\":source Xscript\\<CR>quit\\<CR>\", \"xt\")\n  catch /^Vim:Interrupt$/\n    call assert_match('Xscript, line 7', v:throwpoint)\n    let caught_intr = 1\n  endtry\n  0debuggreedy\n  call assert_equal(1, caught_intr)\n  call assert_equal('ab', g:Xpath)\n  breakdel *\n  call delete('Xscript')\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 82:  Ignoring :catch clauses after an error or interrupt\t\t    {{{1\n\"\n\"\t    When an exception is thrown and an error or interrupt occurs before\n\"\t    the matching :catch clause is reached, the exception is discarded\n\"\t    and the :catch clause is ignored (also for the error or interrupt\n\"\t    exception being thrown then).\n\"-------------------------------------------------------------------------------\n\nfunc Test_ignore_catch_after_error_1()\n  let test =<< trim [CODE]\n    try\n      try\n        Xpath 'a'\n        throw \"arrgh\"\n        call assert_report('should not get here')\n        if 1\n        call assert_report('should not get here')\n        \" error after :throw: missing :endif\n      catch /.*/\n        call assert_report('should not get here')\n      catch /.*/\n        call assert_report('should not get here')\n      endtry\n      call assert_report('should not get here')\n    catch /arrgh/\n      call assert_report('should not get here')\n    endtry\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('a', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\nfunc Test_ignore_catch_after_error_2()\n  let test =<< trim [CODE]\n    func E()\n      try\n        try\n          Xpath 'a'\n          throw \"arrgh\"\n          call assert_report('should not get here')\n          if 1\n          call assert_report('should not get here')\n          \" error after :throw: missing :endif\n        catch /.*/\n          call assert_report('should not get here')\n        catch /.*/\n          call assert_report('should not get here')\n        endtry\n        call assert_report('should not get here')\n      catch /arrgh/\n        call assert_report('should not get here')\n      endtry\n    endfunc\n\n    call E()\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('a', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\" interrupt right before a catch is invoked in a script\nfunc Test_ignore_catch_after_intr_1()\n  XpathINIT\n  let lines =<< trim [CODE]\n    try\n      try\n        Xpath 'a'\n        throw \"arrgh\"\n        call assert_report('should not get here')\n      catch /.*/              \" interrupt here\n        call assert_report('should not get here')\n      catch /.*/\n        call assert_report('should not get here')\n      endtry\n      call assert_report('should not get here')\n    catch /arrgh/\n      call assert_report('should not get here')\n    endtry\n    call assert_report('should not get here')\n  [CODE]\n  call writefile(lines, 'Xscript')\n\n  breakadd file 6 Xscript\n  try\n    let caught_intr = 0\n    debuggreedy\n    call feedkeys(\":source Xscript\\<CR>quit\\<CR>\", \"xt\")\n  catch /^Vim:Interrupt$/\n    call assert_match('Xscript, line 6', v:throwpoint)\n    let caught_intr = 1\n  endtry\n  0debuggreedy\n  call assert_equal(1, caught_intr)\n  call assert_equal('a', g:Xpath)\n  breakdel *\n  call delete('Xscript')\nendfunc\n\n\" interrupt right before a catch is invoked inside a function.\nfunc Test_ignore_catch_after_intr_2()\n  XpathINIT\n  func F()\n    try\n      try\n        Xpath 'a'\n        throw \"arrgh\"\n        call assert_report('should not get here')\n      catch /.*/              \" interrupt here\n        call assert_report('should not get here')\n      catch /.*/\n        call assert_report('should not get here')\n      endtry\n      call assert_report('should not get here')\n    catch /arrgh/\n      call assert_report('should not get here')\n    endtry\n    call assert_report('should not get here')\n  endfunc\n\n  breakadd func 6 F\n  try\n    let caught_intr = 0\n    debuggreedy\n    call feedkeys(\":call F()\\<CR>quit\\<CR>\", \"xt\")\n  catch /^Vim:Interrupt$/\n    call assert_match('\\.F, line 6', v:throwpoint)\n    let caught_intr = 1\n  endtry\n  0debuggreedy\n  call assert_equal(1, caught_intr)\n  call assert_equal('a', g:Xpath)\n  breakdel *\n  delfunc F\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 83:  Executing :finally clauses after an error or interrupt\t    {{{1\n\"\n\"\t    When an exception is thrown and an error or interrupt occurs before\n\"\t    the :finally of the innermost :try is reached, the exception is\n\"\t    discarded and the :finally clause is executed.\n\"-------------------------------------------------------------------------------\n\nfunc Test_finally_after_error()\n  let test =<< trim [CODE]\n    try\n      Xpath 'a'\n      try\n        Xpath 'b'\n        throw \"arrgh\"\n        call assert_report('should not get here')\n        if 1\n        call assert_report('should not get here')\n        \" error after :throw: missing :endif\n      finally\n        Xpath 'c'\n      endtry\n      call assert_report('should not get here')\n    catch /arrgh/\n      call assert_report('should not get here')\n    endtry\n    call assert_report('should not get here')\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abc', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\" interrupt the code right before the finally is invoked\nfunc Test_finally_after_intr()\n  XpathINIT\n  let lines =<< trim [CODE]\n    try\n      Xpath 'a'\n      try\n        Xpath 'b'\n        throw \"arrgh\"\n        call assert_report('should not get here')\n      finally\t\t\" interrupt here\n        Xpath 'c'\n      endtry\n      call assert_report('should not get here')\n    catch /arrgh/\n      call assert_report('should not get here')\n    endtry\n    call assert_report('should not get here')\n  [CODE]\n  call writefile(lines, 'Xscript')\n\n  breakadd file 7 Xscript\n  try\n    let caught_intr = 0\n    debuggreedy\n    call feedkeys(\":source Xscript\\<CR>quit\\<CR>\", \"xt\")\n  catch /^Vim:Interrupt$/\n    call assert_match('Xscript, line 7', v:throwpoint)\n    let caught_intr = 1\n  endtry\n  0debuggreedy\n  call assert_equal(1, caught_intr)\n  call assert_equal('abc', g:Xpath)\n  breakdel *\n  call delete('Xscript')\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 84:  Exceptions in autocommand sequences.\t\t\t    {{{1\n\"\n\"\t    When an exception occurs in a sequence of autocommands for\n\"\t    a specific event, the rest of the sequence is not executed.  The\n\"\t    command that triggered the autocommand execution aborts, and the\n\"\t    exception is propagated to the caller.\n\"\n\"\t    For the FuncUndefined event under a function call expression or\n\"\t    :call command, the function is not executed, even when it has\n\"\t    been defined by the autocommands before the exception occurred.\n\"-------------------------------------------------------------------------------\n\nfunc Test_autocmd_exception()\n  let test =<< trim [CODE]\n    func INT()\n      call interrupt()\n    endfunc\n\n    aug TMP\n      autocmd!\n\n      autocmd User x1 Xpath 'a'\n      autocmd User x1 throw \"x1\"\n      autocmd User x1 call assert_report('should not get here')\n\n      autocmd User x2 Xpath 'b'\n      autocmd User x2 asdf\n      autocmd User x2 call assert_report('should not get here')\n\n      autocmd User x3 Xpath 'c'\n      autocmd User x3 call INT()\n      autocmd User x3 call assert_report('should not get here')\n\n      autocmd FuncUndefined U1 func U1()\n      autocmd FuncUndefined U1   call assert_report('should not get here')\n      autocmd FuncUndefined U1 endfunc\n      autocmd FuncUndefined U1 Xpath 'd'\n      autocmd FuncUndefined U1 throw \"U1\"\n      autocmd FuncUndefined U1 call assert_report('should not get here')\n\n      autocmd FuncUndefined U2 func U2()\n      autocmd FuncUndefined U2   call assert_report('should not get here')\n      autocmd FuncUndefined U2 endfunc\n      autocmd FuncUndefined U2 Xpath 'e'\n      autocmd FuncUndefined U2 ASDF\n      autocmd FuncUndefined U2 call assert_report('should not get here')\n\n      autocmd FuncUndefined U3 func U3()\n      autocmd FuncUndefined U3   call assert_report('should not get here')\n      autocmd FuncUndefined U3 endfunc\n      autocmd FuncUndefined U3 Xpath 'f'\n      autocmd FuncUndefined U3 call INT()\n      autocmd FuncUndefined U3 call assert_report('should not get here')\n    aug END\n\n    try\n      try\n        Xpath 'g'\n        doautocmd User x1\n      catch /x1/\n        Xpath 'h'\n      endtry\n\n      while 1\n        try\n          Xpath 'i'\n          doautocmd User x2\n        catch /asdf/\n          Xpath 'j'\n        finally\n          Xpath 'k'\n          break\n        endtry\n      endwhile\n\n      while 1\n        try\n          Xpath 'l'\n          doautocmd User x3\n        catch /Vim:Interrupt/\n          Xpath 'm'\n        finally\n          Xpath 'n'\n          \" ... but break loop for caught interrupt exception,\n          \" or discard interrupt and break loop if $VIMNOINTTHROW\n          break\n        endtry\n      endwhile\n\n      if exists(\"*U1\") | delfunction U1 | endif\n      if exists(\"*U2\") | delfunction U2 | endif\n      if exists(\"*U3\") | delfunction U3 | endif\n\n      try\n        Xpath 'o'\n        call U1()\n      catch /U1/\n        Xpath 'p'\n      endtry\n\n      while 1\n        try\n          Xpath 'q'\n          call U2()\n        catch /ASDF/\n          Xpath 'r'\n        finally\n          Xpath 's'\n          \" ... but break loop for caught error exception,\n          \" or discard error and break loop if $VIMNOERRTHROW\n          break\n        endtry\n      endwhile\n\n      while 1\n        try\n          Xpath 't'\n          call U3()\n        catch /Vim:Interrupt/\n          Xpath 'u'\n        finally\n          Xpath 'v'\n          \" ... but break loop for caught interrupt exception,\n          \" or discard interrupt and break loop if $VIMNOINTTHROW\n          break\n        endtry\n      endwhile\n    catch /.*/\n      call assert_report('should not get here')\n    endtry\n    Xpath 'w'\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('gahibjklcmnodpqerstfuvw', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 85:  Error exceptions in autocommands for I/O command events\t    {{{1\n\"\n\"\t    When an I/O command is inside :try/:endtry, autocommands to be\n\"\t    executed after it should be skipped on an error (exception) in the\n\"\t    command itself or in autocommands to be executed before the command.\n\"\t    In the latter case, the I/O command should not be executed either.\n\"\t    Example 1: BufWritePre, :write, BufWritePost\n\"\t    Example 2: FileReadPre, :read, FileReadPost.\n\"-------------------------------------------------------------------------------\n\nfunc Test_autocmd_error_io_exception()\n  let test =<< trim [CODE]\n    \" Remove the autocommands for the events specified as arguments in all used\n    \" autogroups.\n    func Delete_autocommands(...)\n      let augfile = tempname()\n      while 1\n        try\n          exec \"redir >\" . augfile\n          aug\n          redir END\n          exec \"edit\" augfile\n          g/^$/d\n          norm G$\n          let wrap = \"w\"\n          while search('\\%(  \\|^\\)\\@<=.\\{-}\\%(  \\)\\@=', wrap) > 0\n            let wrap = \"W\"\n            exec \"norm y/  \\n\"\n            let argno = 1\n            while argno <= a:0\n              exec \"au!\" escape(@\", \" \") a:{argno}\n              let argno = argno + 1\n            endwhile\n          endwhile\n        catch /.*/\n        finally\n          bwipeout!\n          call delete(augfile)\n          break\n        endtry\n      endwhile\n    endfunc\n\n    call Delete_autocommands(\"BufWritePre\", \"BufWritePost\")\n\n    while 1\n      try\n        try\n          let post = 0\n          aug TMP\n            au! BufWritePost * let post = 1\n          aug END\n          write /n/o/n/e/x/i/s/t/e/n/t\n        catch /^Vim(write):/\n          Xpath 'a'\n          call assert_match(\"E212: Can't open file for writing\", v:exception)\n        finally\n          Xpath 'b'\n          call assert_equal(0, post)\n          au! TMP\n          aug! TMP\n        endtry\n      catch /.*/\n        call assert_report('should not get here')\n      finally\n        Xpath 'c'\n        break\n      endtry\n    endwhile\n\n    while 1\n      try\n        try\n          let post = 0\n          aug TMP\n            au! BufWritePre  * asdf\n            au! BufWritePost * let post = 1\n          aug END\n          let tmpfile = tempname()\n          exec \"write\" tmpfile\n        catch /^Vim\\((write)\\)\\=:/\n          Xpath 'd'\n          call assert_match('E492: Not an editor command', v:exception)\n        finally\n          Xpath 'e'\n          if filereadable(tmpfile)\n            call assert_report('should not get here')\n          endif\n          call assert_equal(0, post)\n          au! TMP\n          aug! TMP\n        endtry\n      catch /.*/\n        call assert_report('should not get here')\n      finally\n        Xpath 'f'\n        break\n      endtry\n    endwhile\n\n    call delete(tmpfile)\n\n    call Delete_autocommands(\"BufWritePre\", \"BufWritePost\",\n          \\ \"BufReadPre\", \"BufReadPost\", \"FileReadPre\", \"FileReadPost\")\n\n    while 1\n      try\n        try\n          let post = 0\n          aug TMP\n            au! FileReadPost * let post = 1\n          aug END\n          let caught = 0\n          read /n/o/n/e/x/i/s/t/e/n/t\n        catch /^Vim(read):/\n          Xpath 'g'\n          call assert_match(\"E484: Can't open file\", v:exception)\n        finally\n          Xpath 'h'\n          call assert_equal(0, post)\n          au! TMP\n          aug! TMP\n        endtry\n      catch /.*/\n        call assert_report('should not get here')\n      finally\n        Xpath 'i'\n        break\n      endtry\n    endwhile\n\n    while 1\n      try\n        let infile = tempname()\n        let tmpfile = tempname()\n        call writefile([\"XYZ\"], infile)\n        exec \"edit\" tmpfile\n        try\n          Xpath 'j'\n          try\n            let post = 0\n            aug TMP\n              au! FileReadPre  * asdf\n              au! FileReadPost * let post = 1\n            aug END\n            exec \"0read\" infile\n          catch /^Vim\\((read)\\)\\=:/\n            Xpath 'k'\n            call assert_match('E492: Not an editor command', v:exception)\n          finally\n            Xpath 'l'\n            if getline(\"1\") == \"XYZ\"\n              call assert_report('should not get here')\n            endif\n            call assert_equal(0, post)\n            au! TMP\n            aug! TMP\n          endtry\n        finally\n          Xpath 'm'\n          bwipeout!\n        endtry\n      catch /.*/\n        call assert_report('should not get here')\n      finally\n        Xpath 'n'\n        break\n      endtry\n    endwhile\n\n    call delete(infile)\n    call delete(tmpfile)\n  [CODE]\n  let verify =<< trim [CODE]\n    call assert_equal('abcdefghijklmn', g:Xpath)\n  [CODE]\n  call RunInNewVim(test, verify)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 87   using (expr) ? funcref : funcref\t\t\t\t    {{{1\n\"\n\"\t    Vim needs to correctly parse the funcref and even when it does\n\"\t    not execute the funcref, it needs to consume the trailing ()\n\"-------------------------------------------------------------------------------\n\nfunc Add2(x1, x2)\n  return a:x1 + a:x2\nendfu\n\nfunc GetStr()\n  return \"abcdefghijklmnopqrstuvwxyp\"\nendfu\n\nfunc Test_funcref_with_condexpr()\n  call assert_equal(5, function('Add2')(2,3))\n\n  call assert_equal(3, 1 ? function('Add2')(1,2) : function('Add2')(2,3))\n  call assert_equal(5, 0 ? function('Add2')(1,2) : function('Add2')(2,3))\n  \" Make sure, GetStr() still works.\n  call assert_equal('abcdefghijk', GetStr()[0:10])\nendfunc\n\n\" Test 90:  Recognizing {} in variable name.\t\t\t    {{{1\n\"-------------------------------------------------------------------------------\n\nfunc Test_curlies()\n    let s:var = 66\n    let ns = 's'\n    call assert_equal(66, {ns}:var)\n\n    let g:a = {}\n    let g:b = 't'\n    let g:a[g:b] = 77\n    call assert_equal(77, g:a['t'])\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 91:  using type().\t\t\t\t\t    {{{1\n\"-------------------------------------------------------------------------------\n\nfunc Test_type()\n    call assert_equal(0, type(0))\n    call assert_equal(1, type(\"\"))\n    call assert_equal(2, type(function(\"tr\")))\n    call assert_equal(2, type(function(\"tr\", [8])))\n    call assert_equal(3, type([]))\n    call assert_equal(4, type({}))\n    if has('float')\n      call assert_equal(5, type(0.0))\n    endif\n    call assert_equal(6, type(v:false))\n    call assert_equal(6, type(v:true))\n    call assert_equal(7, type(v:none))\n    call assert_equal(7, type(v:null))\n    call assert_equal(8, v:t_job)\n    call assert_equal(9, v:t_channel)\n    call assert_equal(v:t_number, type(0))\n    call assert_equal(v:t_string, type(\"\"))\n    call assert_equal(v:t_func, type(function(\"tr\")))\n    call assert_equal(v:t_func, type(function(\"tr\", [8])))\n    call assert_equal(v:t_list, type([]))\n    call assert_equal(v:t_dict, type({}))\n    if has('float')\n      call assert_equal(v:t_float, type(0.0))\n    endif\n    call assert_equal(v:t_bool, type(v:false))\n    call assert_equal(v:t_bool, type(v:true))\n    call assert_equal(v:t_none, type(v:none))\n    call assert_equal(v:t_none, type(v:null))\n    call assert_equal(v:t_string, type(test_null_string()))\n    call assert_equal(v:t_func, type(test_null_function()))\n    call assert_equal(v:t_func, type(test_null_partial()))\n    call assert_equal(v:t_list, type(test_null_list()))\n    call assert_equal(v:t_dict, type(test_null_dict()))\n    if has('job')\n      call assert_equal(v:t_job, type(test_null_job()))\n    endif\n    if has('channel')\n      call assert_equal(v:t_channel, type(test_null_channel()))\n    endif\n    call assert_equal(v:t_blob, type(test_null_blob()))\n\n    call assert_fails(\"call type(test_void())\", 'E685:')\n    call assert_fails(\"call type(test_unknown())\", 'E685:')\n\n    call assert_equal(0, 0 + v:false)\n    call assert_equal(1, 0 + v:true)\n    call assert_equal(0, 0 + v:none)\n    call assert_equal(0, 0 + v:null)\n\n    call assert_equal('v:false', '' . v:false)\n    call assert_equal('v:true', '' . v:true)\n    call assert_equal('v:none', '' . v:none)\n    call assert_equal('v:null', '' . v:null)\n\n    call assert_true(v:false == 0)\n    call assert_false(v:false != 0)\n    call assert_true(v:true == 1)\n    call assert_false(v:true != 1)\n    call assert_false(v:true == v:false)\n    call assert_true(v:true != v:false)\n\n    call assert_true(v:null == 0)\n    call assert_false(v:null == 1)\n    call assert_false(v:null != 0)\n    call assert_true(v:none == 0)\n    call assert_false(v:none == 1)\n    call assert_false(v:none != 0)\n    if has('float')\n      call assert_true(v:null == 0.0)\n      call assert_false(v:null == 0.1)\n      call assert_false(v:null != 0.0)\n    endif\n\n    call assert_true(v:false is v:false)\n    call assert_true(v:true is v:true)\n    call assert_true(v:none is v:none)\n    call assert_true(v:null is v:null)\n\n    call assert_false(v:false isnot v:false)\n    call assert_false(v:true isnot v:true)\n    call assert_false(v:none isnot v:none)\n    call assert_false(v:null isnot v:null)\n\n    call assert_false(v:false is 0)\n    call assert_false(v:true is 1)\n    call assert_false(v:true is v:false)\n    call assert_false(v:none is 0)\n    call assert_false(v:none is [])\n    call assert_false(v:none is {})\n    call assert_false(v:none is 'text')\n    call assert_false(v:null is 0)\n    call assert_false(v:null is v:none)\n\n    call assert_true(v:false isnot 0)\n    call assert_true(v:true isnot 1)\n    call assert_true(v:true isnot v:false)\n    call assert_true(v:none isnot 0)\n    call assert_true(v:null isnot 0)\n    call assert_true(v:null isnot v:none)\n\n    call assert_equal(v:false, eval(string(v:false)))\n    call assert_equal(v:true, eval(string(v:true)))\n    call assert_equal(v:none, eval(string(v:none)))\n    call assert_equal(v:null, eval(string(v:null)))\n\n    call assert_equal(v:false, copy(v:false))\n    call assert_equal(v:true, copy(v:true))\n    call assert_equal(v:none, copy(v:none))\n    call assert_equal(v:null, copy(v:null))\n\n    call assert_equal([v:false], deepcopy([v:false]))\n    call assert_equal([v:true], deepcopy([v:true]))\n    call assert_equal([v:none], deepcopy([v:none]))\n    call assert_equal([v:null], deepcopy([v:null]))\n\n    call assert_true(empty(v:false))\n    call assert_false(empty(v:true))\n    call assert_true(empty(v:null))\n    call assert_true(empty(v:none))\n\n    func ChangeYourMind()\n\ttry\n\t    return v:true\n\tfinally\n\t    return 'something else'\n\tendtry\n    endfunc\n\n    call ChangeYourMind()\nendfunc\n\nfunc Test_typename()\n  call assert_equal('number', typename(123))\n  call assert_equal('string', typename('x'))\n  call assert_equal('list<number>', typename([123]))\n  call assert_equal('dict<number>', typename(#{key: 123}))\n  call assert_equal('list<dict<number>>', typename([#{key: 123}]))\n\n  let l = []\n  let d = #{a: 0}\n  let l = [d]\n  let l[0].e = #{b: l}\n  call assert_equal('list<dict<any>>', typename(l))\n  call assert_equal('dict<any>', typename(d))\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 92:  skipping code\t\t\t\t\t    {{{1\n\"-------------------------------------------------------------------------------\n\nfunc Test_skip()\n    let Fn = function('Test_type')\n    call assert_false(0 && Fn[1])\n    call assert_false(0 && string(Fn))\n    call assert_false(0 && len(Fn))\n    let l = []\n    call assert_false(0 && l[1])\n    call assert_false(0 && string(l))\n    call assert_false(0 && len(l))\n    let f = 1.0\n    call assert_false(0 && f[1])\n    call assert_false(0 && string(f))\n    call assert_false(0 && len(f))\n    let sp = v:null\n    call assert_false(0 && sp[1])\n    call assert_false(0 && string(sp))\n    call assert_false(0 && len(sp))\n\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 93:  :echo and string()\t\t\t\t\t    {{{1\n\"-------------------------------------------------------------------------------\n\nfunc Test_echo_and_string()\n    \" String\n    let a = 'foo bar'\n    redir => result\n    echo a\n    echo string(a)\n    redir END\n    let l = split(result, \"\\n\")\n    call assert_equal([\"foo bar\",\n\t\t     \\ \"'foo bar'\"], l)\n\n    \" Float\n    if has('float')\n\tlet a = -1.2e0\n\tredir => result\n\techo a\n\techo string(a)\n\tredir END\n\tlet l = split(result, \"\\n\")\n\tcall assert_equal([\"-1.2\",\n\t\t\t \\ \"-1.2\"], l)\n    endif\n\n    \" Funcref\n    redir => result\n    echo function('string')\n    echo string(function('string'))\n    redir END\n    let l = split(result, \"\\n\")\n    call assert_equal([\"string\",\n\t\t     \\ \"function('string')\"], l)\n\n    \" Recursive dictionary\n    let a = {}\n    let a[\"a\"] = a\n    redir => result\n    echo a\n    echo string(a)\n    redir END\n    let l = split(result, \"\\n\")\n    call assert_equal([\"{'a': {...}}\",\n\t\t     \\ \"{'a': {...}}\"], l)\n\n    \" Recursive list\n    let a = [0]\n    let a[0] = a\n    redir => result\n    echo a\n    echo string(a)\n    redir END\n    let l = split(result, \"\\n\")\n    call assert_equal([\"[[...]]\",\n\t\t     \\ \"[[...]]\"], l)\n\n    \" Empty dictionaries in a list\n    let a = {}\n    redir => result\n    echo [a, a, a]\n    echo string([a, a, a])\n    redir END\n    let l = split(result, \"\\n\")\n    call assert_equal([\"[{}, {}, {}]\",\n\t\t     \\ \"[{}, {}, {}]\"], l)\n\n    \" Empty dictionaries in a dictionary\n    let a = {}\n    let b = {\"a\": a, \"b\": a}\n    redir => result\n    echo b\n    echo string(b)\n    redir END\n    let l = split(result, \"\\n\")\n    call assert_equal([\"{'a': {}, 'b': {}}\",\n\t\t     \\ \"{'a': {}, 'b': {}}\"], l)\n\n    \" Empty lists in a list\n    let a = []\n    redir => result\n    echo [a, a, a]\n    echo string([a, a, a])\n    redir END\n    let l = split(result, \"\\n\")\n    call assert_equal([\"[[], [], []]\",\n\t\t     \\ \"[[], [], []]\"], l)\n\n    \" Empty lists in a dictionary\n    let a = []\n    let b = {\"a\": a, \"b\": a}\n    redir => result\n    echo b\n    echo string(b)\n    redir END\n    let l = split(result, \"\\n\")\n    call assert_equal([\"{'a': [], 'b': []}\",\n\t\t     \\ \"{'a': [], 'b': []}\"], l)\n\n    \" Dictionaries in a list\n    let a = {\"one\": \"yes\", \"two\": \"yes\", \"three\": \"yes\"}\n    redir => result\n    echo [a, a, a]\n    echo string([a, a, a])\n    redir END\n    let l = split(result, \"\\n\")\n    call assert_equal([\"[{'one': 'yes', 'two': 'yes', 'three': 'yes'}, {...}, {...}]\",\n\t\t     \\ \"[{'one': 'yes', 'two': 'yes', 'three': 'yes'}, {'one': 'yes', 'two': 'yes', 'three': 'yes'}, {'one': 'yes', 'two': 'yes', 'three': 'yes'}]\"], l)\n\n    \" Dictionaries in a dictionary\n    let a = {\"one\": \"yes\", \"two\": \"yes\", \"three\": \"yes\"}\n    let b = {\"a\": a, \"b\": a}\n    redir => result\n    echo b\n    echo string(b)\n    redir END\n    let l = split(result, \"\\n\")\n    call assert_equal([\"{'a': {'one': 'yes', 'two': 'yes', 'three': 'yes'}, 'b': {...}}\",\n\t\t     \\ \"{'a': {'one': 'yes', 'two': 'yes', 'three': 'yes'}, 'b': {'one': 'yes', 'two': 'yes', 'three': 'yes'}}\"], l)\n\n    \" Lists in a list\n    let a = [1, 2, 3]\n    redir => result\n    echo [a, a, a]\n    echo string([a, a, a])\n    redir END\n    let l = split(result, \"\\n\")\n    call assert_equal([\"[[1, 2, 3], [...], [...]]\",\n\t\t     \\ \"[[1, 2, 3], [1, 2, 3], [1, 2, 3]]\"], l)\n\n    \" Lists in a dictionary\n    let a = [1, 2, 3]\n    let b = {\"a\": a, \"b\": a}\n    redir => result\n    echo b\n    echo string(b)\n    redir END\n    let l = split(result, \"\\n\")\n    call assert_equal([\"{'a': [1, 2, 3], 'b': [...]}\",\n\t\t     \\ \"{'a': [1, 2, 3], 'b': [1, 2, 3]}\"], l)\n\n    call assert_fails('echo &:', 'E112:')\n    call assert_fails('echo &g:', 'E112:')\n    call assert_fails('echo &l:', 'E112:')\n\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 94:  64-bit Numbers\t\t\t\t\t    {{{1\n\"-------------------------------------------------------------------------------\n\nfunc Test_num64()\n    call assert_notequal( 4294967296, 0)\n    call assert_notequal(-4294967296, 0)\n    call assert_equal( 4294967296,  0xFFFFffff + 1)\n    call assert_equal(-4294967296, -0xFFFFffff - 1)\n\n    call assert_equal( 9223372036854775807,  1 / 0)\n    call assert_equal(-9223372036854775807, -1 / 0)\n    call assert_equal(-9223372036854775807 - 1,  0 / 0)\n\n    if has('float')\n      call assert_equal( 0x7FFFffffFFFFffff, float2nr( 1.0e150))\n      call assert_equal(-0x7FFFffffFFFFffff, float2nr(-1.0e150))\n    endif\n\n    let rng = range(0xFFFFffff, 0x100000001)\n    call assert_equal([0xFFFFffff, 0x100000000, 0x100000001], rng)\n    call assert_equal(0x100000001, max(rng))\n    call assert_equal(0xFFFFffff, min(rng))\n    call assert_equal(rng, sort(range(0x100000001, 0xFFFFffff, -1), 'N'))\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 95:  lines of :append, :change, :insert\t\t\t    {{{1\n\"-------------------------------------------------------------------------------\n\nfunction! DefineFunction(name, body)\n    let func = join(['function! ' . a:name . '()'] + a:body + ['endfunction'], \"\\n\")\n    exec func\nendfunction\n\nfunc Test_script_lines()\n    \" :append\n    try\n\tcall DefineFunction('T_Append', [\n\t\t    \\ 'append',\n\t\t    \\ 'py <<EOS',\n\t\t    \\ '.',\n\t\t    \\ ])\n    catch\n\tcall assert_report(\"Can't define function\")\n    endtry\n    try\n\tcall DefineFunction('T_Append', [\n\t\t    \\ 'append',\n\t\t    \\ 'abc',\n\t\t    \\ ])\n\tcall assert_report(\"Shouldn't be able to define function\")\n    catch\n\tcall assert_exception('Vim(function):E1145: Missing heredoc end marker: .')\n    endtry\n\n    \" :change\n    try\n\tcall DefineFunction('T_Change', [\n\t\t    \\ 'change',\n\t\t    \\ 'py <<EOS',\n\t\t    \\ '.',\n\t\t    \\ ])\n    catch\n\tcall assert_report(\"Can't define function\")\n    endtry\n    try\n\tcall DefineFunction('T_Change', [\n\t\t    \\ 'change',\n\t\t    \\ 'abc',\n\t\t    \\ ])\n\tcall assert_report(\"Shouldn't be able to define function\")\n    catch\n\tcall assert_exception('Vim(function):E1145: Missing heredoc end marker: .')\n    endtry\n\n    \" :insert\n    try\n\tcall DefineFunction('T_Insert', [\n\t\t    \\ 'insert',\n\t\t    \\ 'py <<EOS',\n\t\t    \\ '.',\n\t\t    \\ ])\n    catch\n\tcall assert_report(\"Can't define function\")\n    endtry\n    try\n\tcall DefineFunction('T_Insert', [\n\t\t    \\ 'insert',\n\t\t    \\ 'abc',\n\t\t    \\ ])\n\tcall assert_report(\"Shouldn't be able to define function\")\n    catch\n\tcall assert_exception('Vim(function):E1145: Missing heredoc end marker: .')\n    endtry\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 96:  line continuation\t\t\t\t\t\t    {{{1\n\"\n\"\t    Undefined behavior was detected by ubsan with line continuation\n\"\t    after an empty line.\n\"-------------------------------------------------------------------------------\nfunc Test_script_emty_line_continuation()\n\n    \\\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 97:  bitwise functions\t\t\t\t\t\t    {{{1\n\"-------------------------------------------------------------------------------\nfunc Test_bitwise_functions()\n    \" and\n    call assert_equal(127, and(127, 127))\n    call assert_equal(16, and(127, 16))\n    eval 127->and(16)->assert_equal(16)\n    call assert_equal(0, and(127, 128))\n    call assert_fails(\"call and([], 1)\", 'E745:')\n    call assert_fails(\"call and({}, 1)\", 'E728:')\n    if has('float')\n      call assert_fails(\"call and(1.0, 1)\", 'E805:')\n      call assert_fails(\"call and(1, 1.0)\", 'E805:')\n    endif\n    call assert_fails(\"call and(1, [])\", 'E745:')\n    call assert_fails(\"call and(1, {})\", 'E728:')\n    \" or\n    call assert_equal(23, or(16, 7))\n    call assert_equal(15, or(8, 7))\n    eval 8->or(7)->assert_equal(15)\n    call assert_equal(123, or(0, 123))\n    call assert_fails(\"call or([], 1)\", 'E745:')\n    call assert_fails(\"call or({}, 1)\", 'E728:')\n    if has('float')\n      call assert_fails(\"call or(1.0, 1)\", 'E805:')\n      call assert_fails(\"call or(1, 1.0)\", 'E805:')\n    endif\n    call assert_fails(\"call or(1, [])\", 'E745:')\n    call assert_fails(\"call or(1, {})\", 'E728:')\n    \" xor\n    call assert_equal(0, xor(127, 127))\n    call assert_equal(111, xor(127, 16))\n    eval 127->xor(16)->assert_equal(111)\n    call assert_equal(255, xor(127, 128))\n    if has('float')\n      call assert_fails(\"call xor(1.0, 1)\", 'E805:')\n      call assert_fails(\"call xor(1, 1.0)\", 'E805:')\n    endif\n    call assert_fails(\"call xor([], 1)\", 'E745:')\n    call assert_fails(\"call xor({}, 1)\", 'E728:')\n    call assert_fails(\"call xor(1, [])\", 'E745:')\n    call assert_fails(\"call xor(1, {})\", 'E728:')\n    \" invert\n    call assert_equal(65408, and(invert(127), 65535))\n    eval 127->invert()->and(65535)->assert_equal(65408)\n    call assert_equal(65519, and(invert(16), 65535))\n    call assert_equal(65407, and(invert(128), 65535))\n    if has('float')\n      call assert_fails(\"call invert(1.0)\", 'E805:')\n    endif\n    call assert_fails(\"call invert([])\", 'E745:')\n    call assert_fails(\"call invert({})\", 'E728:')\nendfunc\n\n\" Test using bang after user command\t\t\t\t    {{{1\nfunc Test_user_command_with_bang()\n    command -bang Nieuw let nieuw = 1\n    Ni!\n    call assert_equal(1, nieuw)\n    unlet nieuw\n    delcommand Nieuw\nendfunc\n\nfunc Test_script_expand_sfile()\n  let lines =<< trim END\n    func s:snr()\n      return expand('<sfile>')\n    endfunc\n    let g:result = s:snr()\n  END\n  call writefile(lines, 'Xexpand')\n  source Xexpand\n  call assert_match('<SNR>\\d\\+_snr', g:result)\n  source Xexpand\n  call assert_match('<SNR>\\d\\+_snr', g:result)\n\n  call delete('Xexpand')\n  unlet g:result\nendfunc\n\nfunc Test_compound_assignment_operators()\n    \" Test for number\n    let x = 1\n    let x += 10\n    call assert_equal(11, x)\n    let x -= 5\n    call assert_equal(6, x)\n    let x *= 4\n    call assert_equal(24, x)\n    let x /= 3\n    call assert_equal(8, x)\n    let x %= 3\n    call assert_equal(2, x)\n    let x .= 'n'\n    call assert_equal('2n', x)\n\n    \" Test special cases: division or modulus with 0.\n    let x = 1\n    let x /= 0\n    call assert_equal(0x7FFFFFFFFFFFFFFF, x)\n\n    let x = -1\n    let x /= 0\n    call assert_equal(-0x7FFFFFFFFFFFFFFF, x)\n\n    let x = 0\n    let x /= 0\n    call assert_equal(-0x7FFFFFFFFFFFFFFF - 1, x)\n\n    let x = 1\n    let x %= 0\n    call assert_equal(0, x)\n\n    let x = -1\n    let x %= 0\n    call assert_equal(0, x)\n\n    let x = 0\n    let x %= 0\n    call assert_equal(0, x)\n\n    \" Test for string\n    let x = 'str'\n    let x .= 'ing'\n    call assert_equal('string', x)\n    let x += 1\n    call assert_equal(1, x)\n\n    if has('float')\n      \" Test for float\n      let x -= 1.5\n      call assert_equal(-0.5, x)\n      let x = 0.5\n      let x += 4.5\n      call assert_equal(5.0, x)\n      let x -= 1.5\n      call assert_equal(3.5, x)\n      let x *= 3.0\n      call assert_equal(10.5, x)\n      let x /= 2.5\n      call assert_equal(4.2, x)\n      call assert_fails('let x %= 0.5', 'E734:')\n      call assert_fails('let x .= \"f\"', 'E734:')\n      let x = !3.14\n      call assert_equal(0.0, x)\n\n      \" integer and float operations\n      let x = 1\n      let x *= 2.1\n      call assert_equal(2.1, x)\n      let x = 1\n      let x /= 0.25\n      call assert_equal(4.0, x)\n      let x = 1\n      call assert_fails('let x %= 0.25', 'E734:')\n      let x = 1\n      call assert_fails('let x .= 0.25', 'E734:')\n      let x = 1.0\n      call assert_fails('let x += [1.1]', 'E734:')\n    endif\n\n    \" Test for environment variable\n    let $FOO = 1\n    call assert_fails('let $FOO += 1', 'E734:')\n    call assert_fails('let $FOO -= 1', 'E734:')\n    call assert_fails('let $FOO *= 1', 'E734:')\n    call assert_fails('let $FOO /= 1', 'E734:')\n    call assert_fails('let $FOO %= 1', 'E734:')\n    let $FOO .= 's'\n    call assert_equal('1s', $FOO)\n    unlet $FOO\n\n    \" Test for option variable (type: number)\n    let &scrolljump = 1\n    let &scrolljump += 5\n    call assert_equal(6, &scrolljump)\n    let &scrolljump -= 2\n    call assert_equal(4, &scrolljump)\n    let &scrolljump *= 3\n    call assert_equal(12, &scrolljump)\n    let &scrolljump /= 2\n    call assert_equal(6, &scrolljump)\n    let &scrolljump %= 5\n    call assert_equal(1, &scrolljump)\n    call assert_fails('let &scrolljump .= \"j\"', 'E734:')\n    set scrolljump&vim\n\n    let &foldlevelstart = 2\n    let &foldlevelstart -= 1\n    call assert_equal(1, &foldlevelstart)\n    let &foldlevelstart -= 1\n    call assert_equal(0, &foldlevelstart)\n    let &foldlevelstart = 2\n    let &foldlevelstart -= 2\n    call assert_equal(0, &foldlevelstart)\n\n    \" Test for register\n    let @/ = 1\n    call assert_fails('let @/ += 1', 'E734:')\n    call assert_fails('let @/ -= 1', 'E734:')\n    call assert_fails('let @/ *= 1', 'E734:')\n    call assert_fails('let @/ /= 1', 'E734:')\n    call assert_fails('let @/ %= 1', 'E734:')\n    let @/ .= 's'\n    call assert_equal('1s', @/)\n    let @/ = ''\nendfunc\n\nfunc Test_unlet_env()\n  let $TESTVAR = 'yes'\n  call assert_equal('yes', $TESTVAR)\n  call assert_fails('lockvar $TESTVAR', 'E940:')\n  call assert_fails('unlockvar $TESTVAR', 'E940:')\n  call assert_equal('yes', $TESTVAR)\n  if 0\n    unlet $TESTVAR\n  endif\n  call assert_equal('yes', $TESTVAR)\n  unlet $TESTVAR\n  call assert_equal('', $TESTVAR)\nendfunc\n\nfunc Test_refcount()\n    \" Immediate values\n    call assert_equal(-1, test_refcount(1))\n    call assert_equal(-1, test_refcount('s'))\n    call assert_equal(-1, test_refcount(v:true))\n    call assert_equal(0, test_refcount([]))\n    call assert_equal(0, test_refcount({}))\n    call assert_equal(0, test_refcount(0zff))\n    call assert_equal(0, test_refcount({-> line('.')}))\n    if has('float')\n        call assert_equal(-1, test_refcount(0.1))\n    endif\n    if has('job')\n        call assert_equal(0, test_refcount(job_start([&shell, &shellcmdflag, 'echo .'])))\n    endif\n\n    \" No refcount types\n    let x = 1\n    call assert_equal(-1, test_refcount(x))\n    let x = 's'\n    call assert_equal(-1, test_refcount(x))\n    let x = v:true\n    call assert_equal(-1, test_refcount(x))\n    if has('float')\n        let x = 0.1\n        call assert_equal(-1, test_refcount(x))\n    endif\n\n    \" Check refcount\n    let x = []\n    call assert_equal(1, test_refcount(x))\n\n    let x = {}\n    call assert_equal(1, x->test_refcount())\n\n    let x = 0zff\n    call assert_equal(1, test_refcount(x))\n\n    let X = {-> line('.')}\n    call assert_equal(1, test_refcount(X))\n    let Y = X\n    call assert_equal(2, test_refcount(X))\n\n    if has('job')\n        let job = job_start([&shell, &shellcmdflag, 'echo .'])\n        call assert_equal(1, test_refcount(job))\n        call assert_equal(1, test_refcount(job_getchannel(job)))\n        call assert_equal(1, test_refcount(job))\n    endif\n\n    \" Function arguments, copying and unassigning\n    func ExprCheck(x, i)\n        let i = a:i + 1\n        call assert_equal(i, test_refcount(a:x))\n        let Y = a:x\n        call assert_equal(i + 1, test_refcount(a:x))\n        call assert_equal(test_refcount(a:x), test_refcount(Y))\n        let Y = 0\n        call assert_equal(i, test_refcount(a:x))\n    endfunc\n    call ExprCheck([], 0)\n    call ExprCheck({}, 0)\n    call ExprCheck(0zff, 0)\n    call ExprCheck({-> line('.')}, 0)\n    if has('job')\n\tcall ExprCheck(job, 1)\n\tcall ExprCheck(job_getchannel(job), 1)\n\tcall job_stop(job)\n    endif\n    delfunc ExprCheck\n\n    \" Regarding function\n    func Func(x) abort\n        call assert_equal(2, test_refcount(function('Func')))\n        call assert_equal(0, test_refcount(funcref('Func')))\n    endfunc\n    call assert_equal(1, test_refcount(function('Func')))\n    call assert_equal(0, test_refcount(function('Func', [1])))\n    call assert_equal(0, test_refcount(funcref('Func')))\n    call assert_equal(0, test_refcount(funcref('Func', [1])))\n    let X = function('Func')\n    let Y = X\n    call assert_equal(1, test_refcount(X))\n    let X = function('Func', [1])\n    let Y = X\n    call assert_equal(2, test_refcount(X))\n    let X = funcref('Func')\n    let Y = X\n    call assert_equal(2, test_refcount(X))\n    let X = funcref('Func', [1])\n    let Y = X\n    call assert_equal(2, test_refcount(X))\n    unlet X\n    unlet Y\n    call Func(1)\n    delfunc Func\n\n    \" Function with dict\n    func DictFunc() dict\n        call assert_equal(3, test_refcount(self))\n    endfunc\n    let d = {'Func': function('DictFunc')}\n    call assert_equal(1, test_refcount(d))\n    call assert_equal(0, test_refcount(d.Func))\n    call d.Func()\n    unlet d\n    delfunc DictFunc\nendfunc\n\n\" Test for missing :endif, :endfor, :endwhile and :endtry           {{{1\nfunc Test_missing_end()\n  call writefile(['if 2 > 1', 'echo \">\"'], 'Xscript')\n  call assert_fails('source Xscript', 'E171:')\n  call writefile(['for i in range(5)', 'echo i'], 'Xscript')\n  call assert_fails('source Xscript', 'E170:')\n  call writefile(['while v:true', 'echo \".\"'], 'Xscript')\n  call assert_fails('source Xscript', 'E170:')\n  call writefile(['try', 'echo \".\"'], 'Xscript')\n  call assert_fails('source Xscript', 'E600:')\n  call delete('Xscript')\n\n  \" Using endfor with :while\n  let caught_e732 = 0\n  try\n    while v:true\n    endfor\n  catch /E732:/\n    let caught_e732 = 1\n  endtry\n  call assert_equal(1, caught_e732)\n\n  \" Using endwhile with :for\n  let caught_e733 = 0\n  try\n    for i in range(1)\n    endwhile\n  catch /E733:/\n    let caught_e733 = 1\n  endtry\n  call assert_equal(1, caught_e733)\n\n  \" Using endfunc with :if\n  call assert_fails('exe \"if 1 | endfunc | endif\"', 'E193:')\n\n  \" Missing 'in' in a :for statement\n  call assert_fails('for i range(1) | endfor', 'E690:')\n\n  \" Incorrect number of variables in for\n  call assert_fails('for [i,] in range(3) | endfor', 'E475:')\nendfunc\n\n\" Test for deep nesting of if/for/while/try statements              {{{1\nfunc Test_deep_nest()\n  CheckRunVimInTerminal\n\n  let lines =<< trim [SCRIPT]\n    \" Deep nesting of if ... endif\n    func Test1()\n      let @a = join(repeat(['if v:true'], 51), \"\\n\")\n      let @a ..= \"\\n\"\n      let @a ..= join(repeat(['endif'], 51), \"\\n\")\n      @a\n      let @a = ''\n    endfunc\n\n    \" Deep nesting of for ... endfor\n    func Test2()\n      let @a = join(repeat(['for i in [1]'], 51), \"\\n\")\n      let @a ..= \"\\n\"\n      let @a ..= join(repeat(['endfor'], 51), \"\\n\")\n      @a\n      let @a = ''\n    endfunc\n\n    \" Deep nesting of while ... endwhile\n    func Test3()\n      let @a = join(repeat(['while v:true'], 51), \"\\n\")\n      let @a ..= \"\\n\"\n      let @a ..= join(repeat(['endwhile'], 51), \"\\n\")\n      @a\n      let @a = ''\n    endfunc\n\n    \" Deep nesting of try ... endtry\n    func Test4()\n      let @a = join(repeat(['try'], 51), \"\\n\")\n      let @a ..= \"\\necho v:true\\n\"\n      let @a ..= join(repeat(['endtry'], 51), \"\\n\")\n      @a\n      let @a = ''\n    endfunc\n\n    \" Deep nesting of function ... endfunction\n    func Test5()\n      let @a = join(repeat(['function X()'], 51), \"\\n\")\n      let @a ..= \"\\necho v:true\\n\"\n      let @a ..= join(repeat(['endfunction'], 51), \"\\n\")\n      @a\n      let @a = ''\n    endfunc\n  [SCRIPT]\n  call writefile(lines, 'Xscript')\n\n  let buf = RunVimInTerminal('-S Xscript', {'rows': 6})\n\n  \" Deep nesting of if ... endif\n  call term_sendkeys(buf, \":call Test1()\\n\")\n  call TermWait(buf)\n  call WaitForAssert({-> assert_match('^E579:', term_getline(buf, 5))})\n\n  \" Deep nesting of for ... endfor\n  call term_sendkeys(buf, \":call Test2()\\n\")\n  call TermWait(buf)\n  call WaitForAssert({-> assert_match('^E585:', term_getline(buf, 5))})\n\n  \" Deep nesting of while ... endwhile\n  call term_sendkeys(buf, \":call Test3()\\n\")\n  call TermWait(buf)\n  call WaitForAssert({-> assert_match('^E585:', term_getline(buf, 5))})\n\n  \" Deep nesting of try ... endtry\n  call term_sendkeys(buf, \":call Test4()\\n\")\n  call TermWait(buf)\n  call WaitForAssert({-> assert_match('^E601:', term_getline(buf, 5))})\n\n  \" Deep nesting of function ... endfunction\n  call term_sendkeys(buf, \":call Test5()\\n\")\n  call TermWait(buf)\n  call WaitForAssert({-> assert_match('^E1058:', term_getline(buf, 4))})\n  call term_sendkeys(buf, \"\\<C-C>\\n\")\n  call TermWait(buf)\n\n  \"let l = ''\n  \"for i in range(1, 6)\n  \"  let l ..= term_getline(buf, i) . \"\\n\"\n  \"endfor\n  \"call assert_report(l)\n\n  call StopVimInTerminal(buf)\n  call delete('Xscript')\nendfunc\n\n\" Test for errors in converting to float from various types         {{{1\nfunc Test_float_conversion_errors()\n  if has('float')\n    call assert_fails('let x = 4.0 % 2.0', 'E804:')\n    call assert_fails('echo 1.1[0]', 'E806:')\n    call assert_fails('echo sort([function(\"min\"), 1], \"f\")', 'E891:')\n    call assert_fails('echo 3.2 == \"vim\"', 'E892:')\n    call assert_fails('echo sort([[], 1], \"f\")', 'E893:')\n    call assert_fails('echo sort([{}, 1], \"f\")', 'E894:')\n    call assert_fails('echo 3.2 == v:true', 'E362:')\n    call assert_fails('echo 3.2 == v:none', 'E907:')\n  endif\nendfunc\n\n\" invalid function names               {{{1\nfunc Test_invalid_function_names()\n  \" function name not starting with capital\n  let caught_e128 = 0\n  try\n    func! g:test()\n      echo \"test\"\n    endfunc\n  catch /E128:/\n    let caught_e128 = 1\n  endtry\n  call assert_equal(1, caught_e128)\n\n  \" function name includes a colon\n  let caught_e884 = 0\n  try\n    func! b:test()\n      echo \"test\"\n    endfunc\n  catch /E884:/\n    let caught_e884 = 1\n  endtry\n  call assert_equal(1, caught_e884)\n\n  \" function name followed by #\n  let caught_e128 = 0\n  try\n    func! test2() \"#\n      echo \"test2\"\n    endfunc\n  catch /E128:/\n    let caught_e128 = 1\n  endtry\n  call assert_equal(1, caught_e128)\n\n  \" function name starting with/without \"g:\", buffer-local funcref.\n  function! g:Foo(n)\n    return 'called Foo(' . a:n . ')'\n  endfunction\n  let b:my_func = function('Foo')\n  call assert_equal('called Foo(1)', b:my_func(1))\n  call assert_equal('called Foo(2)', g:Foo(2))\n  call assert_equal('called Foo(3)', Foo(3))\n  delfunc g:Foo\n\n  \" script-local function used in Funcref must exist.\n  let lines =<< trim END\n    func s:Testje()\n      return \"foo\"\n    endfunc\n    let Bar = function('s:Testje')\n    call assert_equal(0, exists('s:Testje'))\n    call assert_equal(1, exists('*s:Testje'))\n    call assert_equal(1, exists('Bar'))\n    call assert_equal(1, exists('*Bar'))\n  END\n  call writefile(lines, 'Xscript')\n  source Xscript\n  call delete('Xscript')\nendfunc\n\n\" substring and variable name              {{{1\nfunc Test_substring_var()\n  let str = 'abcdef'\n  let n = 3\n  call assert_equal('def', str[n:])\n  call assert_equal('abcd', str[:n])\n  call assert_equal('d', str[n:n])\n  unlet n\n  let nn = 3\n  call assert_equal('def', str[nn:])\n  call assert_equal('abcd', str[:nn])\n  call assert_equal('d', str[nn:nn])\n  unlet nn\n  let b:nn = 4\n  call assert_equal('ef', str[b:nn:])\n  call assert_equal('abcde', str[:b:nn])\n  call assert_equal('e', str[b:nn:b:nn])\n  unlet b:nn\nendfunc\n\n\" Test using s: with a typed command              {{{1\nfunc Test_typed_script_var()\n  CheckRunVimInTerminal\n\n  let buf = RunVimInTerminal('', {'rows': 6})\n\n  \" Deep nesting of if ... endif\n  call term_sendkeys(buf, \":echo get(s:, 'foo', 'x')\\n\")\n  call TermWait(buf)\n  call WaitForAssert({-> assert_match('^E116:', term_getline(buf, 5))})\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" Test for issue6776              {{{1\nfunc Test_ternary_expression()\n  try\n    call eval('0 ? 0')\n  catch\n  endtry\n  \" previous failure should not cause next expression to fail\n  call assert_equal(v:false, eval(string(v:false)))\n\n  try\n    call eval('0 ? \"burp')\n  catch\n  endtry\n  \" previous failure should not cause next expression to fail\n  call assert_equal(v:false, eval(string(v:false)))\n\n  try\n    call eval('1 ? 0 : \"burp')\n  catch\n  endtry\n  \" previous failure should not cause next expression to fail\n  call assert_equal(v:false, eval(string(v:false)))\nendfunction\n\nfunc Test_for_over_string()\n  let res = ''\n  for c in 'a\u00e9c\u0300d'\n    let res ..= c .. '-'\n  endfor\n  call assert_equal('a-\u00e9-c\u0300-d-', res)\n\n  let res = ''\n  for c in ''\n    let res ..= c .. '-'\n  endfor\n  call assert_equal('', res)\n\n  let res = ''\n  for c in test_null_string()\n    let res ..= c .. '-'\n  endfor\n  call assert_equal('', res)\nendfunc\n\n\" Test for deeply nested :source command  {{{1\nfunc Test_deeply_nested_source()\n  let lines =<< trim END\n\n      so\n      sil 0scr\n      delete\n      so\n      0\n  END\n  call writefile([\"vim9 silent! @0 \\n/\"] + lines, 'Xnested.vim')\n\n  \" this must not crash\n  let cmd = GetVimCommand() .. \" -e -s -S Xnested.vim -c qa!\"\n  call system(cmd)\n\n  call delete('Xnested.vim')\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Modelines\t\t\t\t\t\t\t\t    {{{1\n\" vim: ts=8 sw=2 sts=2 expandtab tw=80 fdm=marker\n\"-------------------------------------------------------------------------------\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    5169,\n/**/\n    5168,\n/**/\n    5167,\n/**/\n    5166,\n/**/\n    5165,\n/**/\n    5164,\n/**/\n    5163,\n/**/\n    5162,\n/**/\n    5161,\n/**/\n    5160,\n/**/\n    5159,\n/**/\n    5158,\n/**/\n    5157,\n/**/\n    5156,\n/**/\n    5155,\n/**/\n    5154,\n/**/\n    5153,\n/**/\n    5152,\n/**/\n    5151,\n/**/\n    5150,\n/**/\n    5149,\n/**/\n    5148,\n/**/\n    5147,\n/**/\n    5146,\n/**/\n    5145,\n/**/\n    5144,\n/**/\n    5143,\n/**/\n    5142,\n/**/\n    5141,\n/**/\n    5140,\n/**/\n    5139,\n/**/\n    5138,\n/**/\n    5137,\n/**/\n    5136,\n/**/\n    5135,\n/**/\n    5134,\n/**/\n    5133,\n/**/\n    5132,\n/**/\n    5131,\n/**/\n    5130,\n/**/\n    5129,\n/**/\n    5128,\n/**/\n    5127,\n/**/\n    5126,\n/**/\n    5125,\n/**/\n    5124,\n/**/\n    5123,\n/**/\n    5122,\n/**/\n    5121,\n/**/\n    5120,\n/**/\n    5119,\n/**/\n    5118,\n/**/\n    5117,\n/**/\n    5116,\n/**/\n    5115,\n/**/\n    5114,\n/**/\n    5113,\n/**/\n    5112,\n/**/\n    5111,\n/**/\n    5110,\n/**/\n    5109,\n/**/\n    5108,\n/**/\n    5107,\n/**/\n    5106,\n/**/\n    5105,\n/**/\n    5104,\n/**/\n    5103,\n/**/\n    5102,\n/**/\n    5101,\n/**/\n    5100,\n/**/\n    5099,\n/**/\n    5098,\n/**/\n    5097,\n/**/\n    5096,\n/**/\n    5095,\n/**/\n    5094,\n/**/\n    5093,\n/**/\n    5092,\n/**/\n    5091,\n/**/\n    5090,\n/**/\n    5089,\n/**/\n    5088,\n/**/\n    5087,\n/**/\n    5086,\n/**/\n    5085,\n/**/\n    5084,\n/**/\n    5083,\n/**/\n    5082,\n/**/\n    5081,\n/**/\n    5080,\n/**/\n    5079,\n/**/\n    5078,\n/**/\n    5077,\n/**/\n    5076,\n/**/\n    5075,\n/**/\n    5074,\n/**/\n    5073,\n/**/\n    5072,\n/**/\n    5071,\n/**/\n    5070,\n/**/\n    5069,\n/**/\n    5068,\n/**/\n    5067,\n/**/\n    5066,\n/**/\n    5065,\n/**/\n    5064,\n/**/\n    5063,\n/**/\n    5062,\n/**/\n    5061,\n/**/\n    5060,\n/**/\n    5059,\n/**/\n    5058,\n/**/\n    5057,\n/**/\n    5056,\n/**/\n    5055,\n/**/\n    5054,\n/**/\n    5053,\n/**/\n    5052,\n/**/\n    5051,\n/**/\n    5050,\n/**/\n    5049,\n/**/\n    5048,\n/**/\n    5047,\n/**/\n    5046,\n/**/\n    5045,\n/**/\n    5044,\n/**/\n    5043,\n/**/\n    5042,\n/**/\n    5041,\n/**/\n    5040,\n/**/\n    5039,\n/**/\n    5038,\n/**/\n    5037,\n/**/\n    5036,\n/**/\n    5035,\n/**/\n    5034,\n/**/\n    5033,\n/**/\n    5032,\n/**/\n    5031,\n/**/\n    5030,\n/**/\n    5029,\n/**/\n    5028,\n/**/\n    5027,\n/**/\n    5026,\n/**/\n    5025,\n/**/\n    5024,\n/**/\n    5023,\n/**/\n    5022,\n/**/\n    5021,\n/**/\n    5020,\n/**/\n    5019,\n/**/\n    5018,\n/**/\n    5017,\n/**/\n    5016,\n/**/\n    5015,\n/**/\n    5014,\n/**/\n    5013,\n/**/\n    5012,\n/**/\n    5011,\n/**/\n    5010,\n/**/\n    5009,\n/**/\n    5008,\n/**/\n    5007,\n/**/\n    5006,\n/**/\n    5005,\n/**/\n    5004,\n/**/\n    5003,\n/**/\n    5002,\n/**/\n    5001,\n/**/\n    5000,\n/**/\n    4999,\n/**/\n    4998,\n/**/\n    4997,\n/**/\n    4996,\n/**/\n    4995,\n/**/\n    4994,\n/**/\n    4993,\n/**/\n    4992,\n/**/\n    4991,\n/**/\n    4990,\n/**/\n    4989,\n/**/\n    4988,\n/**/\n    4987,\n/**/\n    4986,\n/**/\n    4985,\n/**/\n    4984,\n/**/\n    4983,\n/**/\n    4982,\n/**/\n    4981,\n/**/\n    4980,\n/**/\n    4979,\n/**/\n    4978,\n/**/\n    4977,\n/**/\n    4976,\n/**/\n    4975,\n/**/\n    4974,\n/**/\n    4973,\n/**/\n    4972,\n/**/\n    4971,\n/**/\n    4970,\n/**/\n    4969,\n/**/\n    4968,\n/**/\n    4967,\n/**/\n    4966,\n/**/\n    4965,\n/**/\n    4964,\n/**/\n    4963,\n/**/\n    4962,\n/**/\n    4961,\n/**/\n    4960,\n/**/\n    4959,\n/**/\n    4958,\n/**/\n    4957,\n/**/\n    4956,\n/**/\n    4955,\n/**/\n    4954,\n/**/\n    4953,\n/**/\n    4952,\n/**/\n    4951,\n/**/\n    4950,\n/**/\n    4949,\n/**/\n    4948,\n/**/\n    4947,\n/**/\n    4946,\n/**/\n    4945,\n/**/\n    4944,\n/**/\n    4943,\n/**/\n    4942,\n/**/\n    4941,\n/**/\n    4940,\n/**/\n    4939,\n/**/\n    4938,\n/**/\n    4937,\n/**/\n    4936,\n/**/\n    4935,\n/**/\n    4934,\n/**/\n    4933,\n/**/\n    4932,\n/**/\n    4931,\n/**/\n    4930,\n/**/\n    4929,\n/**/\n    4928,\n/**/\n    4927,\n/**/\n    4926,\n/**/\n    4925,\n/**/\n    4924,\n/**/\n    4923,\n/**/\n    4922,\n/**/\n    4921,\n/**/\n    4920,\n/**/\n    4919,\n/**/\n    4918,\n/**/\n    4917,\n/**/\n    4916,\n/**/\n    4915,\n/**/\n    4914,\n/**/\n    4913,\n/**/\n    4912,\n/**/\n    4911,\n/**/\n    4910,\n/**/\n    4909,\n/**/\n    4908,\n/**/\n    4907,\n/**/\n    4906,\n/**/\n    4905,\n/**/\n    4904,\n/**/\n    4903,\n/**/\n    4902,\n/**/\n    4901,\n/**/\n    4900,\n/**/\n    4899,\n/**/\n    4898,\n/**/\n    4897,\n/**/\n    4896,\n/**/\n    4895,\n/**/\n    4894,\n/**/\n    4893,\n/**/\n    4892,\n/**/\n    4891,\n/**/\n    4890,\n/**/\n    4889,\n/**/\n    4888,\n/**/\n    4887,\n/**/\n    4886,\n/**/\n    4885,\n/**/\n    4884,\n/**/\n    4883,\n/**/\n    4882,\n/**/\n    4881,\n/**/\n    4880,\n/**/\n    4879,\n/**/\n    4878,\n/**/\n    4877,\n/**/\n    4876,\n/**/\n    4875,\n/**/\n    4874,\n/**/\n    4873,\n/**/\n    4872,\n/**/\n    4871,\n/**/\n    4870,\n/**/\n    4869,\n/**/\n    4868,\n/**/\n    4867,\n/**/\n    4866,\n/**/\n    4865,\n/**/\n    4864,\n/**/\n    4863,\n/**/\n    4862,\n/**/\n    4861,\n/**/\n    4860,\n/**/\n    4859,\n/**/\n    4858,\n/**/\n    4857,\n/**/\n    4856,\n/**/\n    4855,\n/**/\n    4854,\n/**/\n    4853,\n/**/\n    4852,\n/**/\n    4851,\n/**/\n    4850,\n/**/\n    4849,\n/**/\n    4848,\n/**/\n    4847,\n/**/\n    4846,\n/**/\n    4845,\n/**/\n    4844,\n/**/\n    4843,\n/**/\n    4842,\n/**/\n    4841,\n/**/\n    4840,\n/**/\n    4839,\n/**/\n    4838,\n/**/\n    4837,\n/**/\n    4836,\n/**/\n    4835,\n/**/\n    4834,\n/**/\n    4833,\n/**/\n    4832,\n/**/\n    4831,\n/**/\n    4830,\n/**/\n    4829,\n/**/\n    4828,\n/**/\n    4827,\n/**/\n    4826,\n/**/\n    4825,\n/**/\n    4824,\n/**/\n    4823,\n/**/\n    4822,\n/**/\n    4821,\n/**/\n    4820,\n/**/\n    4819,\n/**/\n    4818,\n/**/\n    4817,\n/**/\n    4816,\n/**/\n    4815,\n/**/\n    4814,\n/**/\n    4813,\n/**/\n    4812,\n/**/\n    4811,\n/**/\n    4810,\n/**/\n    4809,\n/**/\n    4808,\n/**/\n    4807,\n/**/\n    4806,\n/**/\n    4805,\n/**/\n    4804,\n/**/\n    4803,\n/**/\n    4802,\n/**/\n    4801,\n/**/\n    4800,\n/**/\n    4799,\n/**/\n    4798,\n/**/\n    4797,\n/**/\n    4796,\n/**/\n    4795,\n/**/\n    4794,\n/**/\n    4793,\n/**/\n    4792,\n/**/\n    4791,\n/**/\n    4790,\n/**/\n    4789,\n/**/\n    4788,\n/**/\n    4787,\n/**/\n    4786,\n/**/\n    4785,\n/**/\n    4784,\n/**/\n    4783,\n/**/\n    4782,\n/**/\n    4781,\n/**/\n    4780,\n/**/\n    4779,\n/**/\n    4778,\n/**/\n    4777,\n/**/\n    4776,\n/**/\n    4775,\n/**/\n    4774,\n/**/\n    4773,\n/**/\n    4772,\n/**/\n    4771,\n/**/\n    4770,\n/**/\n    4769,\n/**/\n    4768,\n/**/\n    4767,\n/**/\n    4766,\n/**/\n    4765,\n/**/\n    4764,\n/**/\n    4763,\n/**/\n    4762,\n/**/\n    4761,\n/**/\n    4760,\n/**/\n    4759,\n/**/\n    4758,\n/**/\n    4757,\n/**/\n    4756,\n/**/\n    4755,\n/**/\n    4754,\n/**/\n    4753,\n/**/\n    4752,\n/**/\n    4751,\n/**/\n    4750,\n/**/\n    4749,\n/**/\n    4748,\n/**/\n    4747,\n/**/\n    4746,\n/**/\n    4745,\n/**/\n    4744,\n/**/\n    4743,\n/**/\n    4742,\n/**/\n    4741,\n/**/\n    4740,\n/**/\n    4739,\n/**/\n    4738,\n/**/\n    4737,\n/**/\n    4736,\n/**/\n    4735,\n/**/\n    4734,\n/**/\n    4733,\n/**/\n    4732,\n/**/\n    4731,\n/**/\n    4730,\n/**/\n    4729,\n/**/\n    4728,\n/**/\n    4727,\n/**/\n    4726,\n/**/\n    4725,\n/**/\n    4724,\n/**/\n    4723,\n/**/\n    4722,\n/**/\n    4721,\n/**/\n    4720,\n/**/\n    4719,\n/**/\n    4718,\n/**/\n    4717,\n/**/\n    4716,\n/**/\n    4715,\n/**/\n    4714,\n/**/\n    4713,\n/**/\n    4712,\n/**/\n    4711,\n/**/\n    4710,\n/**/\n    4709,\n/**/\n    4708,\n/**/\n    4707,\n/**/\n    4706,\n/**/\n    4705,\n/**/\n    4704,\n/**/\n    4703,\n/**/\n    4702,\n/**/\n    4701,\n/**/\n    4700,\n/**/\n    4699,\n/**/\n    4698,\n/**/\n    4697,\n/**/\n    4696,\n/**/\n    4695,\n/**/\n    4694,\n/**/\n    4693,\n/**/\n    4692,\n/**/\n    4691,\n/**/\n    4690,\n/**/\n    4689,\n/**/\n    4688,\n/**/\n    4687,\n/**/\n    4686,\n/**/\n    4685,\n/**/\n    4684,\n/**/\n    4683,\n/**/\n    4682,\n/**/\n    4681,\n/**/\n    4680,\n/**/\n    4679,\n/**/\n    4678,\n/**/\n    4677,\n/**/\n    4676,\n/**/\n    4675,\n/**/\n    4674,\n/**/\n    4673,\n/**/\n    4672,\n/**/\n    4671,\n/**/\n    4670,\n/**/\n    4669,\n/**/\n    4668,\n/**/\n    4667,\n/**/\n    4666,\n/**/\n    4665,\n/**/\n    4664,\n/**/\n    4663,\n/**/\n    4662,\n/**/\n    4661,\n/**/\n    4660,\n/**/\n    4659,\n/**/\n    4658,\n/**/\n    4657,\n/**/\n    4656,\n/**/\n    4655,\n/**/\n    4654,\n/**/\n    4653,\n/**/\n    4652,\n/**/\n    4651,\n/**/\n    4650,\n/**/\n    4649,\n/**/\n    4648,\n/**/\n    4647,\n/**/\n    4646,\n/**/\n    4645,\n/**/\n    4644,\n/**/\n    4643,\n/**/\n    4642,\n/**/\n    4641,\n/**/\n    4640,\n/**/\n    4639,\n/**/\n    4638,\n/**/\n    4637,\n/**/\n    4636,\n/**/\n    4635,\n/**/\n    4634,\n/**/\n    4633,\n/**/\n    4632,\n/**/\n    4631,\n/**/\n    4630,\n/**/\n    4629,\n/**/\n    4628,\n/**/\n    4627,\n/**/\n    4626,\n/**/\n    4625,\n/**/\n    4624,\n/**/\n    4623,\n/**/\n    4622,\n/**/\n    4621,\n/**/\n    4620,\n/**/\n    4619,\n/**/\n    4618,\n/**/\n    4617,\n/**/\n    4616,\n/**/\n    4615,\n/**/\n    4614,\n/**/\n    4613,\n/**/\n    4612,\n/**/\n    4611,\n/**/\n    4610,\n/**/\n    4609,\n/**/\n    4608,\n/**/\n    4607,\n/**/\n    4606,\n/**/\n    4605,\n/**/\n    4604,\n/**/\n    4603,\n/**/\n    4602,\n/**/\n    4601,\n/**/\n    4600,\n/**/\n    4599,\n/**/\n    4598,\n/**/\n    4597,\n/**/\n    4596,\n/**/\n    4595,\n/**/\n    4594,\n/**/\n    4593,\n/**/\n    4592,\n/**/\n    4591,\n/**/\n    4590,\n/**/\n    4589,\n/**/\n    4588,\n/**/\n    4587,\n/**/\n    4586,\n/**/\n    4585,\n/**/\n    4584,\n/**/\n    4583,\n/**/\n    4582,\n/**/\n    4581,\n/**/\n    4580,\n/**/\n    4579,\n/**/\n    4578,\n/**/\n    4577,\n/**/\n    4576,\n/**/\n    4575,\n/**/\n    4574,\n/**/\n    4573,\n/**/\n    4572,\n/**/\n    4571,\n/**/\n    4570,\n/**/\n    4569,\n/**/\n    4568,\n/**/\n    4567,\n/**/\n    4566,\n/**/\n    4565,\n/**/\n    4564,\n/**/\n    4563,\n/**/\n    4562,\n/**/\n    4561,\n/**/\n    4560,\n/**/\n    4559,\n/**/\n    4558,\n/**/\n    4557,\n/**/\n    4556,\n/**/\n    4555,\n/**/\n    4554,\n/**/\n    4553,\n/**/\n    4552,\n/**/\n    4551,\n/**/\n    4550,\n/**/\n    4549,\n/**/\n    4548,\n/**/\n    4547,\n/**/\n    4546,\n/**/\n    4545,\n/**/\n    4544,\n/**/\n    4543,\n/**/\n    4542,\n/**/\n    4541,\n/**/\n    4540,\n/**/\n    4539,\n/**/\n    4538,\n/**/\n    4537,\n/**/\n    4536,\n/**/\n    4535,\n/**/\n    4534,\n/**/\n    4533,\n/**/\n    4532,\n/**/\n    4531,\n/**/\n    4530,\n/**/\n    4529,\n/**/\n    4528,\n/**/\n    4527,\n/**/\n    4526,\n/**/\n    4525,\n/**/\n    4524,\n/**/\n    4523,\n/**/\n    4522,\n/**/\n    4521,\n/**/\n    4520,\n/**/\n    4519,\n/**/\n    4518,\n/**/\n    4517,\n/**/\n    4516,\n/**/\n    4515,\n/**/\n    4514,\n/**/\n    4513,\n/**/\n    4512,\n/**/\n    4511,\n/**/\n    4510,\n/**/\n    4509,\n/**/\n    4508,\n/**/\n    4507,\n/**/\n    4506,\n/**/\n    4505,\n/**/\n    4504,\n/**/\n    4503,\n/**/\n    4502,\n/**/\n    4501,\n/**/\n    4500,\n/**/\n    4499,\n/**/\n    4498,\n/**/\n    4497,\n/**/\n    4496,\n/**/\n    4495,\n/**/\n    4494,\n/**/\n    4493,\n/**/\n    4492,\n/**/\n    4491,\n/**/\n    4490,\n/**/\n    4489,\n/**/\n    4488,\n/**/\n    4487,\n/**/\n    4486,\n/**/\n    4485,\n/**/\n    4484,\n/**/\n    4483,\n/**/\n    4482,\n/**/\n    4481,\n/**/\n    4480,\n/**/\n    4479,\n/**/\n    4478,\n/**/\n    4477,\n/**/\n    4476,\n/**/\n    4475,\n/**/\n    4474,\n/**/\n    4473,\n/**/\n    4472,\n/**/\n    4471,\n/**/\n    4470,\n/**/\n    4469,\n/**/\n    4468,\n/**/\n    4467,\n/**/\n    4466,\n/**/\n    4465,\n/**/\n    4464,\n/**/\n    4463,\n/**/\n    4462,\n/**/\n    4461,\n/**/\n    4460,\n/**/\n    4459,\n/**/\n    4458,\n/**/\n    4457,\n/**/\n    4456,\n/**/\n    4455,\n/**/\n    4454,\n/**/\n    4453,\n/**/\n    4452,\n/**/\n    4451,\n/**/\n    4450,\n/**/\n    4449,\n/**/\n    4448,\n/**/\n    4447,\n/**/\n    4446,\n/**/\n    4445,\n/**/\n    4444,\n/**/\n    4443,\n/**/\n    4442,\n/**/\n    4441,\n/**/\n    4440,\n/**/\n    4439,\n/**/\n    4438,\n/**/\n    4437,\n/**/\n    4436,\n/**/\n    4435,\n/**/\n    4434,\n/**/\n    4433,\n/**/\n    4432,\n/**/\n    4431,\n/**/\n    4430,\n/**/\n    4429,\n/**/\n    4428,\n/**/\n    4427,\n/**/\n    4426,\n/**/\n    4425,\n/**/\n    4424,\n/**/\n    4423,\n/**/\n    4422,\n/**/\n    4421,\n/**/\n    4420,\n/**/\n    4419,\n/**/\n    4418,\n/**/\n    4417,\n/**/\n    4416,\n/**/\n    4415,\n/**/\n    4414,\n/**/\n    4413,\n/**/\n    4412,\n/**/\n    4411,\n/**/\n    4410,\n/**/\n    4409,\n/**/\n    4408,\n/**/\n    4407,\n/**/\n    4406,\n/**/\n    4405,\n/**/\n    4404,\n/**/\n    4403,\n/**/\n    4402,\n/**/\n    4401,\n/**/\n    4400,\n/**/\n    4399,\n/**/\n    4398,\n/**/\n    4397,\n/**/\n    4396,\n/**/\n    4395,\n/**/\n    4394,\n/**/\n    4393,\n/**/\n    4392,\n/**/\n    4391,\n/**/\n    4390,\n/**/\n    4389,\n/**/\n    4388,\n/**/\n    4387,\n/**/\n    4386,\n/**/\n    4385,\n/**/\n    4384,\n/**/\n    4383,\n/**/\n    4382,\n/**/\n    4381,\n/**/\n    4380,\n/**/\n    4379,\n/**/\n    4378,\n/**/\n    4377,\n/**/\n    4376,\n/**/\n    4375,\n/**/\n    4374,\n/**/\n    4373,\n/**/\n    4372,\n/**/\n    4371,\n/**/\n    4370,\n/**/\n    4369,\n/**/\n    4368,\n/**/\n    4367,\n/**/\n    4366,\n/**/\n    4365,\n/**/\n    4364,\n/**/\n    4363,\n/**/\n    4362,\n/**/\n    4361,\n/**/\n    4360,\n/**/\n    4359,\n/**/\n    4358,\n/**/\n    4357,\n/**/\n    4356,\n/**/\n    4355,\n/**/\n    4354,\n/**/\n    4353,\n/**/\n    4352,\n/**/\n    4351,\n/**/\n    4350,\n/**/\n    4349,\n/**/\n    4348,\n/**/\n    4347,\n/**/\n    4346,\n/**/\n    4345,\n/**/\n    4344,\n/**/\n    4343,\n/**/\n    4342,\n/**/\n    4341,\n/**/\n    4340,\n/**/\n    4339,\n/**/\n    4338,\n/**/\n    4337,\n/**/\n    4336,\n/**/\n    4335,\n/**/\n    4334,\n/**/\n    4333,\n/**/\n    4332,\n/**/\n    4331,\n/**/\n    4330,\n/**/\n    4329,\n/**/\n    4328,\n/**/\n    4327,\n/**/\n    4326,\n/**/\n    4325,\n/**/\n    4324,\n/**/\n    4323,\n/**/\n    4322,\n/**/\n    4321,\n/**/\n    4320,\n/**/\n    4319,\n/**/\n    4318,\n/**/\n    4317,\n/**/\n    4316,\n/**/\n    4315,\n/**/\n    4314,\n/**/\n    4313,\n/**/\n    4312,\n/**/\n    4311,\n/**/\n    4310,\n/**/\n    4309,\n/**/\n    4308,\n/**/\n    4307,\n/**/\n    4306,\n/**/\n    4305,\n/**/\n    4304,\n/**/\n    4303,\n/**/\n    4302,\n/**/\n    4301,\n/**/\n    4300,\n/**/\n    4299,\n/**/\n    4298,\n/**/\n    4297,\n/**/\n    4296,\n/**/\n    4295,\n/**/\n    4294,\n/**/\n    4293,\n/**/\n    4292,\n/**/\n    4291,\n/**/\n    4290,\n/**/\n    4289,\n/**/\n    4288,\n/**/\n    4287,\n/**/\n    4286,\n/**/\n    4285,\n/**/\n    4284,\n/**/\n    4283,\n/**/\n    4282,\n/**/\n    4281,\n/**/\n    4280,\n/**/\n    4279,\n/**/\n    4278,\n/**/\n    4277,\n/**/\n    4276,\n/**/\n    4275,\n/**/\n    4274,\n/**/\n    4273,\n/**/\n    4272,\n/**/\n    4271,\n/**/\n    4270,\n/**/\n    4269,\n/**/\n    4268,\n/**/\n    4267,\n/**/\n    4266,\n/**/\n    4265,\n/**/\n    4264,\n/**/\n    4263,\n/**/\n    4262,\n/**/\n    4261,\n/**/\n    4260,\n/**/\n    4259,\n/**/\n    4258,\n/**/\n    4257,\n/**/\n    4256,\n/**/\n    4255,\n/**/\n    4254,\n/**/\n    4253,\n/**/\n    4252,\n/**/\n    4251,\n/**/\n    4250,\n/**/\n    4249,\n/**/\n    4248,\n/**/\n    4247,\n/**/\n    4246,\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/eval.c", "src/testdir/test_vimscript.vim", "src/version.c"], "buggy_code_start_loc": [2390, 7530, 737], "buggy_code_end_loc": [2437, 7530, 737], "fixing_code_start_loc": [2390, 7531, 738], "fixing_code_end_loc": [2443, 7550, 740], "type": "CWE-476", "message": "NULL Pointer Dereference in GitHub repository vim/vim prior to 8.2.", "other": {"cve": {"id": "CVE-2022-2231", "sourceIdentifier": "security@huntr.dev", "published": "2022-06-28T20:15:08.357", "lastModified": "2023-05-03T12:15:50.280", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "NULL Pointer Dereference in GitHub repository vim/vim prior to 8.2."}, {"lang": "es", "value": "Una Desreferencia de Puntero NULL en el repositorio de GitHub vim/vim versiones anteriores a 8.,2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2.5169", "matchCriteriaId": "FE3F9F5F-9459-442A-9A9C-71A6FC8DEEF1"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/79481367a457951aabd9501b510fd7e3eb29c3d8", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/8dae6ab4-7a7a-4716-a65c-9b090fa057b5", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/GFD2A4YLBR7OIRHTL7CK6YNMEIQ264CN/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/U743FMJGFQ35GBPCQ6OWMVZEJPDFVEWM/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/79481367a457951aabd9501b510fd7e3eb29c3d8"}}