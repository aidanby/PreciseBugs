{"buggy_code": ["# -*- coding: utf-8 -*-\n#       ____________\n#   ___/       |    \\_____________ _                 _ ___\n#  /        ___/    |    _ __ _  _| |   ___  __ _ __| |   \\\n# /    \\___/  ______/   | '_ \\ || | |__/ _ \\/ _` / _` |    \\\n# \\            \u25ef |      | .__/\\_, |____\\___/\\__,_\\__,_|    /\n#  \\_______\\    /_______|_|   |__/________________________/\n#           \\  /\n#            \\/\n\nimport os\n\nimport flask\nimport jinja2\nfrom werkzeug.serving import WSGIRequestHandler\n\nfrom .blueprints import BLUEPRINTS\nfrom .config import get_default_config\nfrom .extensions import EXTENSIONS, THEMES\nfrom .filters import TEMPLATE_FILTERS\nfrom .globals import TEMPLATE_GLOBALS\nfrom .handlers import ERROR_HANDLERS\nfrom .helpers import JSONEncoder\nfrom .processors import CONTEXT_PROCESSORS\n\n\n#: flask app singleton?\nclass App:\n\n    JINJA_TEMPLATE_GLOBALS = TEMPLATE_GLOBALS\n    JINJA_TEMPLATE_FILTERS = TEMPLATE_FILTERS\n    JINJA_CONTEXT_PROCESSORS = CONTEXT_PROCESSORS\n    FLASK_ERROR_HANDLERS = ERROR_HANDLERS\n    FLASK_BLUEPRINTS = BLUEPRINTS\n    FLASK_EXTENSIONS = EXTENSIONS\n    FLASK_THEMES = THEMES\n\n\n    @classmethod\n    def _configure_config(cls, app, develop):\n        conf_obj = get_default_config(develop)\n        app.config.from_object(conf_obj)\n\n    @classmethod\n    def _configure_blueprints(cls, app, path_prefix):\n        for blueprint in cls.FLASK_BLUEPRINTS:\n            url_prefix = path_prefix if not blueprint.url_prefix else None\n            app.register_blueprint(blueprint, url_prefix=url_prefix)\n\n    @classmethod\n    def _configure_extensions(cls, app):\n        for extension in cls.FLASK_EXTENSIONS:\n            extension.init_app(app)\n\n    @classmethod\n    def _configure_themes(cls, app, path_prefix=\"\"):\n        for theme in cls.FLASK_THEMES:\n            theme.init_app(app, path_prefix)\n\n    @classmethod\n    def _configure_handlers(cls, app):\n        \"\"\"\n        Register error handlers.\n        \"\"\"\n        for exc, fn in cls.FLASK_ERROR_HANDLERS:\n            app.register_error_handler(exc, fn)\n\n    @classmethod\n    def _configure_json_encoding(cls, app):\n        app.json_encoder = JSONEncoder\n\n    @classmethod\n    def _configure_templating(cls, app):\n        tempdir = app.config[\"PYLOAD_API\"].get_cachedir()\n        cache_path = os.path.join(tempdir, \"jinja\")\n\n        os.makedirs(cache_path, exist_ok=True)\n\n        app.create_jinja_environment()\n\n        # NOTE: enable autoescape for all file extensions (included .js)\n        #       maybe this will break .txt rendering, but we don't render this kind of files actually\n        #       that does not change 'default_for_string=False' (by default)\n        app.jinja_env.autoescape = jinja2.select_autoescape(default=True)\n        app.jinja_env.bytecode_cache = jinja2.FileSystemBytecodeCache(cache_path)\n\n        for fn in cls.JINJA_TEMPLATE_FILTERS:\n            app.add_template_filter(fn)\n\n        for fn in cls.JINJA_TEMPLATE_GLOBALS:\n            app.add_template_global(fn)\n\n        for fn in cls.JINJA_CONTEXT_PROCESSORS:\n            app.context_processor(fn)\n\n    @classmethod\n    def _configure_session(cls, app):\n        tempdir = app.config[\"PYLOAD_API\"].get_cachedir()\n        cache_path = os.path.join(tempdir, \"flask\")\n        os.makedirs(cache_path, exist_ok=True)\n\n        app.config[\"SESSION_FILE_DIR\"] = cache_path\n        app.config[\"SESSION_TYPE\"] = \"filesystem\"\n        app.config[\"SESSION_COOKIE_NAME\"] = \"pyload_session\"\n        app.config[\"SESSION_PERMANENT\"] = False\n\n        session_lifetime = max(app.config[\"PYLOAD_API\"].get_config_value(\"webui\", \"session_lifetime\"), 1) * 60\n        app.config[\"PERMANENT_SESSION_LIFETIME\"] = session_lifetime\n\n    @classmethod\n    def _configure_api(cls, app, pycore):\n        app.config[\"PYLOAD_API\"] = pycore.api\n\n    @classmethod\n    def _configure_logging(cls, app, pycore):\n        # Inject our custom logger\n        app.logger = pycore.log.getChild(\"webui\")\n\n    def __new__(cls, pycore, develop=False, path_prefix=None):\n        app = flask.Flask(__name__)\n\n        cls._configure_logging(app, pycore)\n        cls._configure_api(app, pycore)\n        cls._configure_config(app, develop)\n        cls._configure_templating(app)\n        cls._configure_json_encoding(app)\n        cls._configure_session(app)\n        cls._configure_blueprints(app, path_prefix)\n        cls._configure_extensions(app)\n        cls._configure_themes(app, path_prefix or \"\")\n        cls._configure_handlers(app)\n\n        WSGIRequestHandler.protocol_version = \"HTTP/1.1\"\n\n        return app\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n#       ____________\n#   ___/       |    \\_____________ _                 _ ___\n#  /        ___/    |    _ __ _  _| |   ___  __ _ __| |   \\\n# /    \\___/  ______/   | '_ \\ || | |__/ _ \\/ _` / _` |    \\\n# \\            \u25ef |      | .__/\\_, |____\\___/\\__,_\\__,_|    /\n#  \\_______\\    /_______|_|   |__/________________________/\n#           \\  /\n#            \\/\n\nimport os\n\nimport flask\nimport jinja2\nfrom werkzeug.serving import WSGIRequestHandler\n\nfrom .blueprints import BLUEPRINTS\nfrom .config import get_default_config\nfrom .extensions import EXTENSIONS, THEMES\nfrom .filters import TEMPLATE_FILTERS\nfrom .globals import TEMPLATE_GLOBALS\nfrom .handlers import ERROR_HANDLERS\nfrom .helpers import JSONEncoder\nfrom .processors import CONTEXT_PROCESSORS\n\n\n#: flask app singleton?\nclass App:\n\n    JINJA_TEMPLATE_GLOBALS = TEMPLATE_GLOBALS\n    JINJA_TEMPLATE_FILTERS = TEMPLATE_FILTERS\n    JINJA_CONTEXT_PROCESSORS = CONTEXT_PROCESSORS\n    FLASK_ERROR_HANDLERS = ERROR_HANDLERS\n    FLASK_BLUEPRINTS = BLUEPRINTS\n    FLASK_EXTENSIONS = EXTENSIONS\n    FLASK_THEMES = THEMES\n\n\n    @classmethod\n    def _configure_config(cls, app, develop):\n        conf_obj = get_default_config(develop)\n        app.config.from_object(conf_obj)\n\n    @classmethod\n    def _configure_blueprints(cls, app, path_prefix):\n        for blueprint in cls.FLASK_BLUEPRINTS:\n            url_prefix = path_prefix if not blueprint.url_prefix else None\n            app.register_blueprint(blueprint, url_prefix=url_prefix)\n\n    @classmethod\n    def _configure_extensions(cls, app):\n        for extension in cls.FLASK_EXTENSIONS:\n            extension.init_app(app)\n\n    @classmethod\n    def _configure_themes(cls, app, path_prefix=\"\"):\n        for theme in cls.FLASK_THEMES:\n            theme.init_app(app, path_prefix)\n\n    @classmethod\n    def _configure_handlers(cls, app):\n        \"\"\"\n        Register error handlers.\n        \"\"\"\n        for exc, fn in cls.FLASK_ERROR_HANDLERS:\n            app.register_error_handler(exc, fn)\n\n    @classmethod\n    def _configure_json_encoding(cls, app):\n        app.json_encoder = JSONEncoder\n\n    @classmethod\n    def _configure_templating(cls, app):\n        tempdir = app.config[\"PYLOAD_API\"].get_cachedir()\n        cache_path = os.path.join(tempdir, \"jinja\")\n\n        os.makedirs(cache_path, exist_ok=True)\n\n        app.create_jinja_environment()\n\n        # NOTE: enable auto escape for all file extensions (including .js)\n        #       maybe this will break .txt rendering, but we don't render this kind of files actually\n        #       that does not change 'default_for_string=False' (by default)\n        app.jinja_env.autoescape = jinja2.select_autoescape(default=True)\n        app.jinja_env.bytecode_cache = jinja2.FileSystemBytecodeCache(cache_path)\n\n        for fn in cls.JINJA_TEMPLATE_FILTERS:\n            app.add_template_filter(fn)\n\n        for fn in cls.JINJA_TEMPLATE_GLOBALS:\n            app.add_template_global(fn)\n\n        for fn in cls.JINJA_CONTEXT_PROCESSORS:\n            app.context_processor(fn)\n\n    @classmethod\n    def _configure_session(cls, app):\n        tempdir = app.config[\"PYLOAD_API\"].get_cachedir()\n        cache_path = os.path.join(tempdir, \"flask\")\n        os.makedirs(cache_path, exist_ok=True)\n\n        app.config[\"SESSION_FILE_DIR\"] = cache_path\n        app.config[\"SESSION_TYPE\"] = \"filesystem\"\n        app.config[\"SESSION_COOKIE_NAME\"] = \"pyload_session\"\n        app.config[\"SESSION_COOKIE_SECURE\"] = app.config[\"PYLOAD_API\"].get_config_value(\"webui\", \"use_ssl\")\n        app.config[\"SESSION_PERMANENT\"] = False\n\n        session_lifetime = max(app.config[\"PYLOAD_API\"].get_config_value(\"webui\", \"session_lifetime\"), 1) * 60\n        app.config[\"PERMANENT_SESSION_LIFETIME\"] = session_lifetime\n\n    @classmethod\n    def _configure_api(cls, app, pycore):\n        app.config[\"PYLOAD_API\"] = pycore.api\n\n    @classmethod\n    def _configure_logging(cls, app, pycore):\n        # Inject our custom logger\n        app.logger = pycore.log.getChild(\"webui\")\n\n    def __new__(cls, pycore, develop=False, path_prefix=None):\n        app = flask.Flask(__name__)\n\n        cls._configure_logging(app, pycore)\n        cls._configure_api(app, pycore)\n        cls._configure_config(app, develop)\n        cls._configure_templating(app)\n        cls._configure_json_encoding(app)\n        cls._configure_session(app)\n        cls._configure_blueprints(app, path_prefix)\n        cls._configure_extensions(app)\n        cls._configure_themes(app, path_prefix or \"\")\n        cls._configure_handlers(app)\n\n        WSGIRequestHandler.protocol_version = \"HTTP/1.1\"\n\n        return app\n"], "filenames": ["src/pyload/webui/app/__init__.py"], "buggy_code_start_loc": [81], "buggy_code_end_loc": [104], "fixing_code_start_loc": [81], "fixing_code_end_loc": [106], "type": "CWE-319", "message": "Sensitive Cookie in HTTPS Session Without 'Secure' Attribute in GitHub repository pyload/pyload prior to 0.5.0b3.dev32.", "other": {"cve": {"id": "CVE-2023-0055", "sourceIdentifier": "security@huntr.dev", "published": "2023-01-04T22:15:09.180", "lastModified": "2023-01-11T16:01:57.503", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Sensitive Cookie in HTTPS Session Without 'Secure' Attribute in GitHub repository pyload/pyload prior to 0.5.0b3.dev32."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.1, "baseSeverity": "LOW"}, "exploitabilityScore": 1.6, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-319"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-614"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pyload:pyload:0.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "E5A06D79-6D64-41FB-9040-17E9630DF4E9"}]}]}], "references": [{"url": "https://github.com/pyload/pyload/commit/7b53b8d43c2c072b457dcd19c8a09bcfc3721703", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/ed88e240-99ff-48a1-bf32-8e1ef5f13cce", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pyload/pyload/commit/7b53b8d43c2c072b457dcd19c8a09bcfc3721703"}}