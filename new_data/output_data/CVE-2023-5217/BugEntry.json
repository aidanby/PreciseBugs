{"buggy_code": ["/*\n *  Copyright (c) 2016 The WebM project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree. An additional intellectual property rights grant can be found\n *  in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */\n\n#include <climits>\n#include <cstring>\n#include <initializer_list>\n#include <new>\n\n#include \"third_party/googletest/src/include/gtest/gtest.h\"\n#include \"test/codec_factory.h\"\n#include \"test/encode_test_driver.h\"\n#include \"test/i420_video_source.h\"\n#include \"test/video_source.h\"\n\n#include \"./vpx_config.h\"\n#include \"vpx/vp8cx.h\"\n#include \"vpx/vpx_tpl.h\"\n\nnamespace {\n\nconst vpx_codec_iface_t *kCodecIfaces[] = {\n#if CONFIG_VP8_ENCODER\n  &vpx_codec_vp8_cx_algo,\n#endif\n#if CONFIG_VP9_ENCODER\n  &vpx_codec_vp9_cx_algo,\n#endif\n};\n\nbool IsVP9(const vpx_codec_iface_t *iface) {\n  static const char kVP9Name[] = \"WebM Project VP9\";\n  return strncmp(kVP9Name, vpx_codec_iface_name(iface), sizeof(kVP9Name) - 1) ==\n         0;\n}\n\nTEST(EncodeAPI, InvalidParams) {\n  uint8_t buf[1] = { 0 };\n  vpx_image_t img;\n  vpx_codec_ctx_t enc;\n  vpx_codec_enc_cfg_t cfg;\n\n  EXPECT_EQ(&img, vpx_img_wrap(&img, VPX_IMG_FMT_I420, 1, 1, 1, buf));\n\n  EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n            vpx_codec_enc_init(nullptr, nullptr, nullptr, 0));\n  EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n            vpx_codec_enc_init(&enc, nullptr, nullptr, 0));\n  EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n            vpx_codec_encode(nullptr, nullptr, 0, 0, 0, 0));\n  EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n            vpx_codec_encode(nullptr, &img, 0, 0, 0, 0));\n  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, vpx_codec_destroy(nullptr));\n  EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n            vpx_codec_enc_config_default(nullptr, nullptr, 0));\n  EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n            vpx_codec_enc_config_default(nullptr, &cfg, 0));\n  EXPECT_NE(vpx_codec_error(nullptr), nullptr);\n\n  for (const auto *iface : kCodecIfaces) {\n    SCOPED_TRACE(vpx_codec_iface_name(iface));\n    EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n              vpx_codec_enc_init(nullptr, iface, nullptr, 0));\n    EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n              vpx_codec_enc_init(&enc, iface, nullptr, 0));\n    EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n              vpx_codec_enc_config_default(iface, &cfg, 1));\n\n    EXPECT_EQ(VPX_CODEC_OK, vpx_codec_enc_config_default(iface, &cfg, 0));\n    EXPECT_EQ(VPX_CODEC_OK, vpx_codec_enc_init(&enc, iface, &cfg, 0));\n    EXPECT_EQ(VPX_CODEC_OK, vpx_codec_encode(&enc, nullptr, 0, 0, 0, 0));\n\n    EXPECT_EQ(VPX_CODEC_OK, vpx_codec_destroy(&enc));\n  }\n}\n\nTEST(EncodeAPI, HighBitDepthCapability) {\n// VP8 should not claim VP9 HBD as a capability.\n#if CONFIG_VP8_ENCODER\n  const vpx_codec_caps_t vp8_caps = vpx_codec_get_caps(&vpx_codec_vp8_cx_algo);\n  EXPECT_EQ(vp8_caps & VPX_CODEC_CAP_HIGHBITDEPTH, 0);\n#endif\n\n#if CONFIG_VP9_ENCODER\n  const vpx_codec_caps_t vp9_caps = vpx_codec_get_caps(&vpx_codec_vp9_cx_algo);\n#if CONFIG_VP9_HIGHBITDEPTH\n  EXPECT_EQ(vp9_caps & VPX_CODEC_CAP_HIGHBITDEPTH, VPX_CODEC_CAP_HIGHBITDEPTH);\n#else\n  EXPECT_EQ(vp9_caps & VPX_CODEC_CAP_HIGHBITDEPTH, 0);\n#endif\n#endif\n}\n\n#if CONFIG_VP8_ENCODER\nTEST(EncodeAPI, ImageSizeSetting) {\n  const int width = 711;\n  const int height = 360;\n  const int bps = 12;\n  vpx_image_t img;\n  vpx_codec_ctx_t enc;\n  vpx_codec_enc_cfg_t cfg;\n  uint8_t *img_buf = reinterpret_cast<uint8_t *>(\n      calloc(width * height * bps / 8, sizeof(*img_buf)));\n  vpx_codec_enc_config_default(vpx_codec_vp8_cx(), &cfg, 0);\n\n  cfg.g_w = width;\n  cfg.g_h = height;\n\n  vpx_img_wrap(&img, VPX_IMG_FMT_I420, width, height, 1, img_buf);\n\n  vpx_codec_enc_init(&enc, vpx_codec_vp8_cx(), &cfg, 0);\n\n  EXPECT_EQ(VPX_CODEC_OK, vpx_codec_encode(&enc, &img, 0, 1, 0, 0));\n\n  free(img_buf);\n\n  vpx_codec_destroy(&enc);\n}\n#endif\n\n// Set up 2 spatial streams with 2 temporal layers per stream, and generate\n// invalid configuration by setting the temporal layer rate allocation\n// (ts_target_bitrate[]) to 0 for both layers. This should fail independent of\n// CONFIG_MULTI_RES_ENCODING.\nTEST(EncodeAPI, MultiResEncode) {\n  const int width = 1280;\n  const int height = 720;\n  const int width_down = width / 2;\n  const int height_down = height / 2;\n  const int target_bitrate = 1000;\n  const int framerate = 30;\n\n  for (const auto *iface : kCodecIfaces) {\n    vpx_codec_ctx_t enc[2];\n    vpx_codec_enc_cfg_t cfg[2];\n    vpx_rational_t dsf[2] = { { 2, 1 }, { 2, 1 } };\n\n    memset(enc, 0, sizeof(enc));\n\n    for (int i = 0; i < 2; i++) {\n      vpx_codec_enc_config_default(iface, &cfg[i], 0);\n    }\n\n    /* Highest-resolution encoder settings */\n    cfg[0].g_w = width;\n    cfg[0].g_h = height;\n    cfg[0].rc_dropframe_thresh = 0;\n    cfg[0].rc_end_usage = VPX_CBR;\n    cfg[0].rc_resize_allowed = 0;\n    cfg[0].rc_min_quantizer = 2;\n    cfg[0].rc_max_quantizer = 56;\n    cfg[0].rc_undershoot_pct = 100;\n    cfg[0].rc_overshoot_pct = 15;\n    cfg[0].rc_buf_initial_sz = 500;\n    cfg[0].rc_buf_optimal_sz = 600;\n    cfg[0].rc_buf_sz = 1000;\n    cfg[0].g_error_resilient = 1; /* Enable error resilient mode */\n    cfg[0].g_lag_in_frames = 0;\n\n    cfg[0].kf_mode = VPX_KF_AUTO;\n    cfg[0].kf_min_dist = 3000;\n    cfg[0].kf_max_dist = 3000;\n\n    cfg[0].rc_target_bitrate = target_bitrate; /* Set target bitrate */\n    cfg[0].g_timebase.num = 1;                 /* Set fps */\n    cfg[0].g_timebase.den = framerate;\n\n    memcpy(&cfg[1], &cfg[0], sizeof(cfg[0]));\n    cfg[1].rc_target_bitrate = 500;\n    cfg[1].g_w = width_down;\n    cfg[1].g_h = height_down;\n\n    for (int i = 0; i < 2; i++) {\n      cfg[i].ts_number_layers = 2;\n      cfg[i].ts_periodicity = 2;\n      cfg[i].ts_rate_decimator[0] = 2;\n      cfg[i].ts_rate_decimator[1] = 1;\n      cfg[i].ts_layer_id[0] = 0;\n      cfg[i].ts_layer_id[1] = 1;\n      // Invalid parameters.\n      cfg[i].ts_target_bitrate[0] = 0;\n      cfg[i].ts_target_bitrate[1] = 0;\n    }\n\n    // VP9 should report incapable, VP8 invalid for all configurations.\n    EXPECT_EQ(IsVP9(iface) ? VPX_CODEC_INCAPABLE : VPX_CODEC_INVALID_PARAM,\n              vpx_codec_enc_init_multi(&enc[0], iface, &cfg[0], 2, 0, &dsf[0]));\n\n    for (int i = 0; i < 2; i++) {\n      vpx_codec_destroy(&enc[i]);\n    }\n  }\n}\n\nTEST(EncodeAPI, SetRoi) {\n  static struct {\n    const vpx_codec_iface_t *iface;\n    int ctrl_id;\n  } kCodecs[] = {\n#if CONFIG_VP8_ENCODER\n    { &vpx_codec_vp8_cx_algo, VP8E_SET_ROI_MAP },\n#endif\n#if CONFIG_VP9_ENCODER\n    { &vpx_codec_vp9_cx_algo, VP9E_SET_ROI_MAP },\n#endif\n  };\n  constexpr int kWidth = 64;\n  constexpr int kHeight = 64;\n\n  for (const auto &codec : kCodecs) {\n    SCOPED_TRACE(vpx_codec_iface_name(codec.iface));\n    vpx_codec_ctx_t enc;\n    vpx_codec_enc_cfg_t cfg;\n\n    EXPECT_EQ(vpx_codec_enc_config_default(codec.iface, &cfg, 0), VPX_CODEC_OK);\n    cfg.g_w = kWidth;\n    cfg.g_h = kHeight;\n    EXPECT_EQ(vpx_codec_enc_init(&enc, codec.iface, &cfg, 0), VPX_CODEC_OK);\n\n    vpx_roi_map_t roi = {};\n    uint8_t roi_map[kWidth * kHeight] = {};\n    if (IsVP9(codec.iface)) {\n      roi.rows = (cfg.g_w + 7) >> 3;\n      roi.cols = (cfg.g_h + 7) >> 3;\n    } else {\n      roi.rows = (cfg.g_w + 15) >> 4;\n      roi.cols = (cfg.g_h + 15) >> 4;\n    }\n    EXPECT_EQ(vpx_codec_control_(&enc, codec.ctrl_id, &roi), VPX_CODEC_OK);\n\n    roi.roi_map = roi_map;\n    // VP8 only. This value isn't range checked.\n    roi.static_threshold[1] = 1000;\n    roi.static_threshold[2] = UINT_MAX / 2 + 1;\n    roi.static_threshold[3] = UINT_MAX;\n\n    for (const auto delta : { -63, -1, 0, 1, 63 }) {\n      for (int i = 0; i < 8; ++i) {\n        roi.delta_q[i] = delta;\n        roi.delta_lf[i] = delta;\n        // VP9 only.\n        roi.skip[i] ^= 1;\n        roi.ref_frame[i] = (roi.ref_frame[i] + 1) % 4;\n        EXPECT_EQ(vpx_codec_control_(&enc, codec.ctrl_id, &roi), VPX_CODEC_OK);\n      }\n    }\n\n    vpx_codec_err_t expected_error;\n    for (const auto delta : { -64, 64, INT_MIN, INT_MAX }) {\n      expected_error = VPX_CODEC_INVALID_PARAM;\n      for (int i = 0; i < 8; ++i) {\n        roi.delta_q[i] = delta;\n        // The max segment count for VP8 is 4, the remainder of the entries are\n        // ignored.\n        if (i >= 4 && !IsVP9(codec.iface)) expected_error = VPX_CODEC_OK;\n\n        EXPECT_EQ(vpx_codec_control_(&enc, codec.ctrl_id, &roi), expected_error)\n            << \"delta_q[\" << i << \"]: \" << delta;\n        roi.delta_q[i] = 0;\n\n        roi.delta_lf[i] = delta;\n        EXPECT_EQ(vpx_codec_control_(&enc, codec.ctrl_id, &roi), expected_error)\n            << \"delta_lf[\" << i << \"]: \" << delta;\n        roi.delta_lf[i] = 0;\n      }\n    }\n\n    // VP8 should ignore skip[] and ref_frame[] values.\n    expected_error =\n        IsVP9(codec.iface) ? VPX_CODEC_INVALID_PARAM : VPX_CODEC_OK;\n    for (const auto skip : { -2, 2, INT_MIN, INT_MAX }) {\n      for (int i = 0; i < 8; ++i) {\n        roi.skip[i] = skip;\n        EXPECT_EQ(vpx_codec_control_(&enc, codec.ctrl_id, &roi), expected_error)\n            << \"skip[\" << i << \"]: \" << skip;\n        roi.skip[i] = 0;\n      }\n    }\n\n    // VP9 allows negative values to be used to disable segmentation.\n    for (int ref_frame = -3; ref_frame < 0; ++ref_frame) {\n      for (int i = 0; i < 8; ++i) {\n        roi.ref_frame[i] = ref_frame;\n        EXPECT_EQ(vpx_codec_control_(&enc, codec.ctrl_id, &roi), VPX_CODEC_OK)\n            << \"ref_frame[\" << i << \"]: \" << ref_frame;\n        roi.ref_frame[i] = 0;\n      }\n    }\n\n    for (const auto ref_frame : { 4, INT_MIN, INT_MAX }) {\n      for (int i = 0; i < 8; ++i) {\n        roi.ref_frame[i] = ref_frame;\n        EXPECT_EQ(vpx_codec_control_(&enc, codec.ctrl_id, &roi), expected_error)\n            << \"ref_frame[\" << i << \"]: \" << ref_frame;\n        roi.ref_frame[i] = 0;\n      }\n    }\n\n    EXPECT_EQ(vpx_codec_destroy(&enc), VPX_CODEC_OK);\n  }\n}\n\nvoid InitCodec(const vpx_codec_iface_t &iface, int width, int height,\n               vpx_codec_ctx_t *enc, vpx_codec_enc_cfg_t *cfg) {\n  cfg->g_w = width;\n  cfg->g_h = height;\n  cfg->g_lag_in_frames = 0;\n  cfg->g_pass = VPX_RC_ONE_PASS;\n  ASSERT_EQ(vpx_codec_enc_init(enc, &iface, cfg, 0), VPX_CODEC_OK);\n\n  ASSERT_EQ(vpx_codec_control_(enc, VP8E_SET_CPUUSED, 2), VPX_CODEC_OK);\n}\n\n// Encodes 1 frame of size |cfg.g_w| x |cfg.g_h| setting |enc|'s configuration\n// to |cfg|.\nvoid EncodeWithConfig(const vpx_codec_enc_cfg_t &cfg, vpx_codec_ctx_t *enc) {\n  libvpx_test::DummyVideoSource video;\n  video.SetSize(cfg.g_w, cfg.g_h);\n  video.Begin();\n  EXPECT_EQ(vpx_codec_enc_config_set(enc, &cfg), VPX_CODEC_OK)\n      << vpx_codec_error_detail(enc);\n\n  EXPECT_EQ(vpx_codec_encode(enc, video.img(), video.pts(), video.duration(),\n                             /*flags=*/0, VPX_DL_GOOD_QUALITY),\n            VPX_CODEC_OK)\n      << vpx_codec_error_detail(enc);\n}\n\nTEST(EncodeAPI, ConfigChangeThreadCount) {\n  constexpr int kWidth = 1920;\n  constexpr int kHeight = 1080;\n\n  for (const auto *iface : kCodecIfaces) {\n    SCOPED_TRACE(vpx_codec_iface_name(iface));\n    for (int i = 0; i < (IsVP9(iface) ? 2 : 1); ++i) {\n      vpx_codec_enc_cfg_t cfg = {};\n      struct Encoder {\n        ~Encoder() { EXPECT_EQ(vpx_codec_destroy(&ctx), VPX_CODEC_OK); }\n        vpx_codec_ctx_t ctx = {};\n      } enc;\n\n      ASSERT_EQ(vpx_codec_enc_config_default(iface, &cfg, 0), VPX_CODEC_OK);\n      EXPECT_NO_FATAL_FAILURE(\n          InitCodec(*iface, kWidth, kHeight, &enc.ctx, &cfg));\n      if (IsVP9(iface)) {\n        EXPECT_EQ(vpx_codec_control_(&enc.ctx, VP9E_SET_TILE_COLUMNS, 6),\n                  VPX_CODEC_OK);\n        EXPECT_EQ(vpx_codec_control_(&enc.ctx, VP9E_SET_ROW_MT, i),\n                  VPX_CODEC_OK);\n      }\n\n      for (const auto threads : { 1, 4, 8, 6, 2, 1 }) {\n        cfg.g_threads = threads;\n        EXPECT_NO_FATAL_FAILURE(EncodeWithConfig(cfg, &enc.ctx))\n            << \"iteration: \" << i << \" threads: \" << threads;\n      }\n    }\n  }\n}\n\nTEST(EncodeAPI, ConfigResizeChangeThreadCount) {\n  constexpr int kInitWidth = 1024;\n  constexpr int kInitHeight = 1024;\n\n  for (const auto *iface : kCodecIfaces) {\n    SCOPED_TRACE(vpx_codec_iface_name(iface));\n    if (!IsVP9(iface)) {\n      GTEST_SKIP() << \"TODO(https://crbug.com/1486441) remove this condition \"\n                      \"after VP8 is fixed.\";\n    }\n    for (int i = 0; i < (IsVP9(iface) ? 2 : 1); ++i) {\n      vpx_codec_enc_cfg_t cfg = {};\n      struct Encoder {\n        ~Encoder() { EXPECT_EQ(vpx_codec_destroy(&ctx), VPX_CODEC_OK); }\n        vpx_codec_ctx_t ctx = {};\n      } enc;\n\n      ASSERT_EQ(vpx_codec_enc_config_default(iface, &cfg, 0), VPX_CODEC_OK);\n      // Start in threaded mode to ensure resolution and thread related\n      // allocations are updated correctly across changes in resolution and\n      // thread counts. See https://crbug.com/1486441.\n      cfg.g_threads = 4;\n      EXPECT_NO_FATAL_FAILURE(\n          InitCodec(*iface, kInitWidth, kInitHeight, &enc.ctx, &cfg));\n      if (IsVP9(iface)) {\n        EXPECT_EQ(vpx_codec_control_(&enc.ctx, VP9E_SET_TILE_COLUMNS, 6),\n                  VPX_CODEC_OK);\n        EXPECT_EQ(vpx_codec_control_(&enc.ctx, VP9E_SET_ROW_MT, i),\n                  VPX_CODEC_OK);\n      }\n\n      cfg.g_w = 1000;\n      cfg.g_h = 608;\n      EXPECT_EQ(vpx_codec_enc_config_set(&enc.ctx, &cfg), VPX_CODEC_OK)\n          << vpx_codec_error_detail(&enc.ctx);\n\n      cfg.g_w = 16;\n      cfg.g_h = 720;\n\n      for (const auto threads : { 1, 4, 8, 6, 2, 1 }) {\n        cfg.g_threads = threads;\n        EXPECT_NO_FATAL_FAILURE(EncodeWithConfig(cfg, &enc.ctx))\n            << \"iteration: \" << i << \" threads: \" << threads;\n      }\n    }\n  }\n}\n\n#if CONFIG_VP9_ENCODER\nclass EncodeApiGetTplStatsTest\n    : public ::libvpx_test::EncoderTest,\n      public ::testing::TestWithParam<const libvpx_test::CodecFactory *> {\n public:\n  EncodeApiGetTplStatsTest() : EncoderTest(GetParam()), test_io_(false) {}\n  ~EncodeApiGetTplStatsTest() override = default;\n\n protected:\n  void SetUp() override {\n    InitializeConfig();\n    SetMode(::libvpx_test::kTwoPassGood);\n  }\n\n  void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                          ::libvpx_test::Encoder *encoder) override {\n    if (video->frame() == 0) {\n      encoder->Control(VP9E_SET_TPL, 1);\n    }\n  }\n\n  vpx_codec_err_t AllocateTplList(VpxTplGopStats *data) {\n    // Allocate MAX_ARF_GOP_SIZE (50) * sizeof(VpxTplFrameStats) that will be\n    // filled by VP9E_GET_TPL_STATS.\n    // MAX_ARF_GOP_SIZE is used here because the test doesn't know the size of\n    // each GOP before getting TPL stats from the encoder.\n    data->size = 50;\n    data->frame_stats_list =\n        static_cast<VpxTplFrameStats *>(calloc(50, sizeof(VpxTplFrameStats)));\n    if (data->frame_stats_list == nullptr) return VPX_CODEC_MEM_ERROR;\n    return VPX_CODEC_OK;\n  }\n\n  void CompareTplGopStats(const VpxTplGopStats &ref_gop_stats,\n                          const VpxTplGopStats &test_gop_stats) {\n    ASSERT_EQ(ref_gop_stats.size, test_gop_stats.size);\n    for (int frame = 0; frame < ref_gop_stats.size; frame++) {\n      const VpxTplFrameStats &ref_frame_stats =\n          ref_gop_stats.frame_stats_list[frame];\n      const VpxTplFrameStats &test_frame_stats =\n          test_gop_stats.frame_stats_list[frame];\n      ASSERT_EQ(ref_frame_stats.num_blocks, test_frame_stats.num_blocks);\n      ASSERT_EQ(ref_frame_stats.frame_width, test_frame_stats.frame_width);\n      ASSERT_EQ(ref_frame_stats.frame_height, test_frame_stats.frame_height);\n      for (int block = 0; block < ref_frame_stats.num_blocks; block++) {\n        const VpxTplBlockStats &ref_block_stats =\n            ref_frame_stats.block_stats_list[block];\n        const VpxTplBlockStats &test_block_stats =\n            test_frame_stats.block_stats_list[block];\n        ASSERT_EQ(ref_block_stats.inter_cost, test_block_stats.inter_cost);\n        ASSERT_EQ(ref_block_stats.intra_cost, test_block_stats.intra_cost);\n        ASSERT_EQ(ref_block_stats.mv_c, test_block_stats.mv_c);\n        ASSERT_EQ(ref_block_stats.mv_r, test_block_stats.mv_r);\n        ASSERT_EQ(ref_block_stats.recrf_dist, test_block_stats.recrf_dist);\n        ASSERT_EQ(ref_block_stats.recrf_rate, test_block_stats.recrf_rate);\n        ASSERT_EQ(ref_block_stats.ref_frame_index,\n                  test_block_stats.ref_frame_index);\n      }\n    }\n  }\n\n  void PostEncodeFrameHook(::libvpx_test::Encoder *encoder) override {\n    ::libvpx_test::CxDataIterator iter = encoder->GetCxData();\n    while (const vpx_codec_cx_pkt_t *pkt = iter.Next()) {\n      switch (pkt->kind) {\n        case VPX_CODEC_CX_FRAME_PKT: {\n          VpxTplGopStats tpl_stats;\n          EXPECT_EQ(AllocateTplList(&tpl_stats), VPX_CODEC_OK);\n          encoder->Control(VP9E_GET_TPL_STATS, &tpl_stats);\n          bool stats_not_all_zero = false;\n          for (int i = 0; i < tpl_stats.size; i++) {\n            VpxTplFrameStats *frame_stats_list = tpl_stats.frame_stats_list;\n            if (frame_stats_list[i].frame_width != 0) {\n              ASSERT_EQ(frame_stats_list[i].frame_width, width_);\n              ASSERT_EQ(frame_stats_list[i].frame_height, height_);\n              ASSERT_GT(frame_stats_list[i].num_blocks, 0);\n              ASSERT_NE(frame_stats_list[i].block_stats_list, nullptr);\n              stats_not_all_zero = true;\n            }\n          }\n          ASSERT_TRUE(stats_not_all_zero);\n          if (test_io_ && tpl_stats.size > 0) {\n            libvpx_test::TempOutFile *temp_out_file =\n                new (std::nothrow) libvpx_test::TempOutFile(\"w+\");\n            ASSERT_NE(temp_out_file, nullptr);\n            ASSERT_NE(temp_out_file->file(), nullptr);\n            vpx_write_tpl_gop_stats(temp_out_file->file(), &tpl_stats);\n            rewind(temp_out_file->file());\n            VpxTplGopStats gop_stats_io;\n            ASSERT_EQ(\n                vpx_read_tpl_gop_stats(temp_out_file->file(), &gop_stats_io),\n                VPX_CODEC_OK);\n            CompareTplGopStats(gop_stats_io, tpl_stats);\n            vpx_free_tpl_gop_stats(&gop_stats_io);\n            delete temp_out_file;\n          }\n          free(tpl_stats.frame_stats_list);\n          break;\n        }\n        default: break;\n      }\n    }\n  }\n\n  int width_;\n  int height_;\n  bool test_io_;\n};\n\nTEST_P(EncodeApiGetTplStatsTest, GetTplStats) {\n  cfg_.g_lag_in_frames = 25;\n  width_ = 352;\n  height_ = 288;\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", width_,\n                                       height_, 30, 1, 0, 50);\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n}\n\nTEST_P(EncodeApiGetTplStatsTest, GetTplStatsIO) {\n  cfg_.g_lag_in_frames = 25;\n  width_ = 352;\n  height_ = 288;\n  test_io_ = true;\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", width_,\n                                       height_, 30, 1, 0, 50);\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n}\n\nINSTANTIATE_TEST_SUITE_P(\n    VP9, EncodeApiGetTplStatsTest,\n    ::testing::Values(\n        static_cast<const libvpx_test::CodecFactory *>(&libvpx_test::kVP9)));\n#endif  // CONFIG_VP9_ENCODER\n\n}  // namespace\n", "/*\n *  Copyright (c) 2010 The WebM project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree. An additional intellectual property rights grant can be found\n *  in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */\n\n#include \"vpx_config.h\"\n#include \"./vpx_scale_rtcd.h\"\n#include \"./vpx_dsp_rtcd.h\"\n#include \"./vp8_rtcd.h\"\n#include \"bitstream.h\"\n#include \"vp8/common/onyxc_int.h\"\n#include \"vp8/common/blockd.h\"\n#include \"onyx_int.h\"\n#include \"vp8/common/systemdependent.h\"\n#include \"vp8/common/vp8_skin_detection.h\"\n#include \"vp8/encoder/quantize.h\"\n#include \"vp8/common/alloccommon.h\"\n#include \"mcomp.h\"\n#include \"firstpass.h\"\n#include \"vpx_dsp/psnr.h\"\n#include \"vpx_scale/vpx_scale.h\"\n#include \"vp8/common/extend.h\"\n#include \"ratectrl.h\"\n#include \"vp8/common/quant_common.h\"\n#include \"segmentation.h\"\n#if CONFIG_POSTPROC\n#include \"vp8/common/postproc.h\"\n#endif\n#include \"vpx_mem/vpx_mem.h\"\n#include \"vp8/common/reconintra.h\"\n#include \"vp8/common/swapyv12buffer.h\"\n#include \"vp8/common/threading.h\"\n#include \"vpx_ports/system_state.h\"\n#include \"vpx_ports/vpx_once.h\"\n#include \"vpx_ports/vpx_timer.h\"\n#include \"vpx_util/vpx_write_yuv_frame.h\"\n#if VPX_ARCH_ARM\n#include \"vpx_ports/arm.h\"\n#endif\n#if CONFIG_MULTI_RES_ENCODING\n#include \"mr_dissim.h\"\n#endif\n#include \"encodeframe.h\"\n#if CONFIG_MULTITHREAD\n#include \"ethreading.h\"\n#endif\n#include \"picklpf.h\"\n#if !CONFIG_REALTIME_ONLY\n#include \"temporal_filter.h\"\n#endif\n\n#include <assert.h>\n#include <math.h>\n#include <stdio.h>\n#include <limits.h>\n\n#if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING\nextern int vp8_update_coef_context(VP8_COMP *cpi);\n#endif\n\nextern unsigned int vp8_get_processor_freq();\n\nint vp8_calc_ss_err(YV12_BUFFER_CONFIG *source, YV12_BUFFER_CONFIG *dest);\n\nstatic void set_default_lf_deltas(VP8_COMP *cpi);\n\nextern const int vp8_gf_interval_table[101];\n\n#if CONFIG_INTERNAL_STATS\n#include \"math.h\"\n#include \"vpx_dsp/ssim.h\"\n#endif\n\n#ifdef OUTPUT_YUV_SRC\nFILE *yuv_file;\n#endif\n#ifdef OUTPUT_YUV_DENOISED\nFILE *yuv_denoised_file;\n#endif\n#ifdef OUTPUT_YUV_SKINMAP\nstatic FILE *yuv_skinmap_file = NULL;\n#endif\n\n#if 0\nFILE *framepsnr;\nFILE *kf_list;\nFILE *keyfile;\n#endif\n\n#if 0\nextern int skip_true_count;\nextern int skip_false_count;\n#endif\n\n#ifdef SPEEDSTATS\nunsigned int frames_at_speed[16] = { 0, 0, 0, 0, 0, 0, 0, 0,\n                                     0, 0, 0, 0, 0, 0, 0, 0 };\nunsigned int tot_pm = 0;\nunsigned int cnt_pm = 0;\nunsigned int tot_ef = 0;\nunsigned int cnt_ef = 0;\n#endif\n\n#ifdef MODE_STATS\nextern unsigned __int64 Sectionbits[50];\nextern int y_modes[5];\nextern int uv_modes[4];\nextern int b_modes[10];\n\nextern int inter_y_modes[10];\nextern int inter_uv_modes[4];\nextern unsigned int inter_b_modes[15];\n#endif\n\nextern const int vp8_bits_per_mb[2][QINDEX_RANGE];\n\nextern const int qrounding_factors[129];\nextern const int qzbin_factors[129];\nextern void vp8cx_init_quantizer(VP8_COMP *cpi);\nextern const int vp8cx_base_skip_false_prob[128];\n\n/* Tables relating active max Q to active min Q */\nstatic const unsigned char kf_low_motion_minq[QINDEX_RANGE] = {\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,\n  1,  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  4,  4,  4,  5,  5,  5,\n  5,  5,  6,  6,  6,  6,  7,  7,  8,  8,  8,  8,  9,  9,  10, 10, 10, 10, 11,\n  11, 11, 11, 12, 12, 13, 13, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16,\n  17, 17, 18, 18, 18, 18, 19, 20, 20, 21, 21, 22, 23, 23\n};\nstatic const unsigned char kf_high_motion_minq[QINDEX_RANGE] = {\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,\n  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,  4,  4,  4,  4,  5,\n  5,  5,  5,  5,  5,  6,  6,  6,  6,  7,  7,  8,  8,  8,  8,  9,  9,  10, 10,\n  10, 10, 11, 11, 11, 11, 12, 12, 13, 13, 13, 13, 14, 14, 15, 15, 15, 15, 16,\n  16, 16, 16, 17, 17, 18, 18, 18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21,\n  22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 28, 28, 29, 30\n};\nstatic const unsigned char gf_low_motion_minq[QINDEX_RANGE] = {\n  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  3,\n  3,  4,  4,  4,  4,  5,  5,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,\n  8,  8,  9,  9,  9,  9,  10, 10, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15,\n  15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24,\n  25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34,\n  34, 35, 35, 36, 36, 37, 37, 38, 38, 39, 39, 40, 40, 41, 41, 42, 42, 43, 44,\n  45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58\n};\nstatic const unsigned char gf_mid_motion_minq[QINDEX_RANGE] = {\n  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  2,  2,  3,  3,  3,  4,  4,  4,  5,\n  5,  5,  6,  6,  6,  7,  7,  7,  8,  8,  8,  9,  9,  9,  10, 10, 10, 10, 11,\n  11, 11, 12, 12, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 16, 16, 17, 17, 18,\n  18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35, 35, 36, 36, 37,\n  37, 38, 39, 39, 40, 40, 41, 41, 42, 42, 43, 43, 44, 45, 46, 47, 48, 49, 50,\n  51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64\n};\nstatic const unsigned char gf_high_motion_minq[QINDEX_RANGE] = {\n  0,  0,  0,  0,  1,  1,  1,  1,  1,  2,  2,  2,  3,  3,  3,  4,  4,  4,  5,\n  5,  5,  6,  6,  6,  7,  7,  7,  8,  8,  8,  9,  9,  9,  10, 10, 10, 11, 11,\n  12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21,\n  21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30,\n  31, 31, 32, 32, 33, 33, 34, 34, 35, 35, 36, 36, 37, 37, 38, 38, 39, 39, 40,\n  40, 41, 41, 42, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56,\n  57, 58, 59, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80\n};\nstatic const unsigned char inter_minq[QINDEX_RANGE] = {\n  0,  0,  1,  1,  2,  3,  3,  4,  4,  5,  6,  6,  7,  8,  8,  9,  9,  10, 11,\n  11, 12, 13, 13, 14, 15, 15, 16, 17, 17, 18, 19, 20, 20, 21, 22, 22, 23, 24,\n  24, 25, 26, 27, 27, 28, 29, 30, 30, 31, 32, 33, 33, 34, 35, 36, 36, 37, 38,\n  39, 39, 40, 41, 42, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 50, 51, 52, 53,\n  54, 55, 55, 56, 57, 58, 59, 60, 60, 61, 62, 63, 64, 65, 66, 67, 67, 68, 69,\n  70, 71, 72, 73, 74, 75, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 86,\n  87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100\n};\n\n#ifdef PACKET_TESTING\nextern FILE *vpxlogc;\n#endif\n\nvoid vp8_save_layer_context(VP8_COMP *cpi) {\n  LAYER_CONTEXT *lc = &cpi->layer_context[cpi->current_layer];\n\n  /* Save layer dependent coding state */\n  lc->target_bandwidth = cpi->target_bandwidth;\n  lc->starting_buffer_level = cpi->oxcf.starting_buffer_level;\n  lc->optimal_buffer_level = cpi->oxcf.optimal_buffer_level;\n  lc->maximum_buffer_size = cpi->oxcf.maximum_buffer_size;\n  lc->starting_buffer_level_in_ms = cpi->oxcf.starting_buffer_level_in_ms;\n  lc->optimal_buffer_level_in_ms = cpi->oxcf.optimal_buffer_level_in_ms;\n  lc->maximum_buffer_size_in_ms = cpi->oxcf.maximum_buffer_size_in_ms;\n  lc->buffer_level = cpi->buffer_level;\n  lc->bits_off_target = cpi->bits_off_target;\n  lc->total_actual_bits = cpi->total_actual_bits;\n  lc->worst_quality = cpi->worst_quality;\n  lc->active_worst_quality = cpi->active_worst_quality;\n  lc->best_quality = cpi->best_quality;\n  lc->active_best_quality = cpi->active_best_quality;\n  lc->ni_av_qi = cpi->ni_av_qi;\n  lc->ni_tot_qi = cpi->ni_tot_qi;\n  lc->ni_frames = cpi->ni_frames;\n  lc->avg_frame_qindex = cpi->avg_frame_qindex;\n  lc->rate_correction_factor = cpi->rate_correction_factor;\n  lc->key_frame_rate_correction_factor = cpi->key_frame_rate_correction_factor;\n  lc->gf_rate_correction_factor = cpi->gf_rate_correction_factor;\n  lc->zbin_over_quant = cpi->mb.zbin_over_quant;\n  lc->inter_frame_target = cpi->inter_frame_target;\n  lc->total_byte_count = cpi->total_byte_count;\n  lc->filter_level = cpi->common.filter_level;\n  lc->frames_since_last_drop_overshoot = cpi->frames_since_last_drop_overshoot;\n  lc->force_maxqp = cpi->force_maxqp;\n  lc->last_frame_percent_intra = cpi->last_frame_percent_intra;\n  lc->last_q[0] = cpi->last_q[0];\n  lc->last_q[1] = cpi->last_q[1];\n\n  memcpy(lc->count_mb_ref_frame_usage, cpi->mb.count_mb_ref_frame_usage,\n         sizeof(cpi->mb.count_mb_ref_frame_usage));\n}\n\nvoid vp8_restore_layer_context(VP8_COMP *cpi, const int layer) {\n  LAYER_CONTEXT *lc = &cpi->layer_context[layer];\n\n  /* Restore layer dependent coding state */\n  cpi->current_layer = layer;\n  cpi->target_bandwidth = lc->target_bandwidth;\n  cpi->oxcf.target_bandwidth = lc->target_bandwidth;\n  cpi->oxcf.starting_buffer_level = lc->starting_buffer_level;\n  cpi->oxcf.optimal_buffer_level = lc->optimal_buffer_level;\n  cpi->oxcf.maximum_buffer_size = lc->maximum_buffer_size;\n  cpi->oxcf.starting_buffer_level_in_ms = lc->starting_buffer_level_in_ms;\n  cpi->oxcf.optimal_buffer_level_in_ms = lc->optimal_buffer_level_in_ms;\n  cpi->oxcf.maximum_buffer_size_in_ms = lc->maximum_buffer_size_in_ms;\n  cpi->buffer_level = lc->buffer_level;\n  cpi->bits_off_target = lc->bits_off_target;\n  cpi->total_actual_bits = lc->total_actual_bits;\n  cpi->active_worst_quality = lc->active_worst_quality;\n  cpi->active_best_quality = lc->active_best_quality;\n  cpi->ni_av_qi = lc->ni_av_qi;\n  cpi->ni_tot_qi = lc->ni_tot_qi;\n  cpi->ni_frames = lc->ni_frames;\n  cpi->avg_frame_qindex = lc->avg_frame_qindex;\n  cpi->rate_correction_factor = lc->rate_correction_factor;\n  cpi->key_frame_rate_correction_factor = lc->key_frame_rate_correction_factor;\n  cpi->gf_rate_correction_factor = lc->gf_rate_correction_factor;\n  cpi->mb.zbin_over_quant = lc->zbin_over_quant;\n  cpi->inter_frame_target = lc->inter_frame_target;\n  cpi->total_byte_count = lc->total_byte_count;\n  cpi->common.filter_level = lc->filter_level;\n  cpi->frames_since_last_drop_overshoot = lc->frames_since_last_drop_overshoot;\n  cpi->force_maxqp = lc->force_maxqp;\n  cpi->last_frame_percent_intra = lc->last_frame_percent_intra;\n  cpi->last_q[0] = lc->last_q[0];\n  cpi->last_q[1] = lc->last_q[1];\n\n  memcpy(cpi->mb.count_mb_ref_frame_usage, lc->count_mb_ref_frame_usage,\n         sizeof(cpi->mb.count_mb_ref_frame_usage));\n}\n\nstatic int rescale(int val, int num, int denom) {\n  int64_t llnum = num;\n  int64_t llden = denom;\n  int64_t llval = val;\n\n  return (int)(llval * llnum / llden);\n}\n\nvoid vp8_init_temporal_layer_context(VP8_COMP *cpi, VP8_CONFIG *oxcf,\n                                     const int layer,\n                                     double prev_layer_framerate) {\n  LAYER_CONTEXT *lc = &cpi->layer_context[layer];\n\n  lc->framerate = cpi->output_framerate / cpi->oxcf.rate_decimator[layer];\n  lc->target_bandwidth = cpi->oxcf.target_bitrate[layer] * 1000;\n\n  lc->starting_buffer_level_in_ms = oxcf->starting_buffer_level;\n  lc->optimal_buffer_level_in_ms = oxcf->optimal_buffer_level;\n  lc->maximum_buffer_size_in_ms = oxcf->maximum_buffer_size;\n\n  lc->starting_buffer_level =\n      rescale((int)(oxcf->starting_buffer_level), lc->target_bandwidth, 1000);\n\n  if (oxcf->optimal_buffer_level == 0) {\n    lc->optimal_buffer_level = lc->target_bandwidth / 8;\n  } else {\n    lc->optimal_buffer_level =\n        rescale((int)(oxcf->optimal_buffer_level), lc->target_bandwidth, 1000);\n  }\n\n  if (oxcf->maximum_buffer_size == 0) {\n    lc->maximum_buffer_size = lc->target_bandwidth / 8;\n  } else {\n    lc->maximum_buffer_size =\n        rescale((int)(oxcf->maximum_buffer_size), lc->target_bandwidth, 1000);\n  }\n\n  /* Work out the average size of a frame within this layer */\n  if (layer > 0) {\n    lc->avg_frame_size_for_layer =\n        (int)round((cpi->oxcf.target_bitrate[layer] -\n                    cpi->oxcf.target_bitrate[layer - 1]) *\n                   1000 / (lc->framerate - prev_layer_framerate));\n  }\n\n  lc->active_worst_quality = cpi->oxcf.worst_allowed_q;\n  lc->active_best_quality = cpi->oxcf.best_allowed_q;\n  lc->avg_frame_qindex = cpi->oxcf.worst_allowed_q;\n\n  lc->buffer_level = lc->starting_buffer_level;\n  lc->bits_off_target = lc->starting_buffer_level;\n\n  lc->total_actual_bits = 0;\n  lc->ni_av_qi = 0;\n  lc->ni_tot_qi = 0;\n  lc->ni_frames = 0;\n  lc->rate_correction_factor = 1.0;\n  lc->key_frame_rate_correction_factor = 1.0;\n  lc->gf_rate_correction_factor = 1.0;\n  lc->inter_frame_target = 0;\n}\n\n// Upon a run-time change in temporal layers, reset the layer context parameters\n// for any \"new\" layers. For \"existing\" layers, let them inherit the parameters\n// from the previous layer state (at the same layer #). In future we may want\n// to better map the previous layer state(s) to the \"new\" ones.\nvoid vp8_reset_temporal_layer_change(VP8_COMP *cpi, VP8_CONFIG *oxcf,\n                                     const int prev_num_layers) {\n  int i;\n  double prev_layer_framerate = 0;\n  const int curr_num_layers = cpi->oxcf.number_of_layers;\n  // If the previous state was 1 layer, get current layer context from cpi.\n  // We need this to set the layer context for the new layers below.\n  if (prev_num_layers == 1) {\n    cpi->current_layer = 0;\n    vp8_save_layer_context(cpi);\n  }\n  for (i = 0; i < curr_num_layers; ++i) {\n    LAYER_CONTEXT *lc = &cpi->layer_context[i];\n    if (i >= prev_num_layers) {\n      vp8_init_temporal_layer_context(cpi, oxcf, i, prev_layer_framerate);\n    }\n    // The initial buffer levels are set based on their starting levels.\n    // We could set the buffer levels based on the previous state (normalized\n    // properly by the layer bandwidths) but we would need to keep track of\n    // the previous set of layer bandwidths (i.e., target_bitrate[i])\n    // before the layer change. For now, reset to the starting levels.\n    lc->buffer_level =\n        cpi->oxcf.starting_buffer_level_in_ms * cpi->oxcf.target_bitrate[i];\n    lc->bits_off_target = lc->buffer_level;\n    // TDOD(marpan): Should we set the rate_correction_factor and\n    // active_worst/best_quality to values derived from the previous layer\n    // state (to smooth-out quality dips/rate fluctuation at transition)?\n\n    // We need to treat the 1 layer case separately: oxcf.target_bitrate[i]\n    // is not set for 1 layer, and the vp8_restore_layer_context/save_context()\n    // are not called in the encoding loop, so we need to call it here to\n    // pass the layer context state to |cpi|.\n    if (curr_num_layers == 1) {\n      lc->target_bandwidth = cpi->oxcf.target_bandwidth;\n      lc->buffer_level =\n          cpi->oxcf.starting_buffer_level_in_ms * lc->target_bandwidth / 1000;\n      lc->bits_off_target = lc->buffer_level;\n      vp8_restore_layer_context(cpi, 0);\n    }\n    prev_layer_framerate = cpi->output_framerate / cpi->oxcf.rate_decimator[i];\n  }\n}\n\nstatic void setup_features(VP8_COMP *cpi) {\n  // If segmentation enabled set the update flags\n  if (cpi->mb.e_mbd.segmentation_enabled) {\n    cpi->mb.e_mbd.update_mb_segmentation_map = 1;\n    cpi->mb.e_mbd.update_mb_segmentation_data = 1;\n  } else {\n    cpi->mb.e_mbd.update_mb_segmentation_map = 0;\n    cpi->mb.e_mbd.update_mb_segmentation_data = 0;\n  }\n\n  cpi->mb.e_mbd.mode_ref_lf_delta_enabled = 0;\n  cpi->mb.e_mbd.mode_ref_lf_delta_update = 0;\n  memset(cpi->mb.e_mbd.ref_lf_deltas, 0, sizeof(cpi->mb.e_mbd.ref_lf_deltas));\n  memset(cpi->mb.e_mbd.mode_lf_deltas, 0, sizeof(cpi->mb.e_mbd.mode_lf_deltas));\n  memset(cpi->mb.e_mbd.last_ref_lf_deltas, 0,\n         sizeof(cpi->mb.e_mbd.ref_lf_deltas));\n  memset(cpi->mb.e_mbd.last_mode_lf_deltas, 0,\n         sizeof(cpi->mb.e_mbd.mode_lf_deltas));\n\n  set_default_lf_deltas(cpi);\n}\n\nstatic void dealloc_raw_frame_buffers(VP8_COMP *cpi);\n\nstatic void initialize_enc(void) {\n  vpx_dsp_rtcd();\n  vp8_init_intra_predictors();\n}\n\nvoid vp8_initialize_enc(void) { once(initialize_enc); }\n\nstatic void dealloc_compressor_data(VP8_COMP *cpi) {\n  vpx_free(cpi->tplist);\n  cpi->tplist = NULL;\n\n  /* Delete last frame MV storage buffers */\n  vpx_free(cpi->lfmv);\n  cpi->lfmv = 0;\n\n  vpx_free(cpi->lf_ref_frame_sign_bias);\n  cpi->lf_ref_frame_sign_bias = 0;\n\n  vpx_free(cpi->lf_ref_frame);\n  cpi->lf_ref_frame = 0;\n\n  /* Delete sementation map */\n  vpx_free(cpi->segmentation_map);\n  cpi->segmentation_map = 0;\n\n  vpx_free(cpi->active_map);\n  cpi->active_map = 0;\n\n  vp8_de_alloc_frame_buffers(&cpi->common);\n\n  vp8_yv12_de_alloc_frame_buffer(&cpi->pick_lf_lvl_frame);\n  vp8_yv12_de_alloc_frame_buffer(&cpi->scaled_source);\n  dealloc_raw_frame_buffers(cpi);\n\n  vpx_free(cpi->tok);\n  cpi->tok = 0;\n\n  /* Structure used to monitor GF usage */\n  vpx_free(cpi->gf_active_flags);\n  cpi->gf_active_flags = 0;\n\n  /* Activity mask based per mb zbin adjustments */\n  vpx_free(cpi->mb_activity_map);\n  cpi->mb_activity_map = 0;\n\n  vpx_free(cpi->mb.pip);\n  cpi->mb.pip = 0;\n\n#if CONFIG_MULTITHREAD\n  vpx_free(cpi->mt_current_mb_col);\n  cpi->mt_current_mb_col = NULL;\n#endif\n}\n\nstatic void enable_segmentation(VP8_COMP *cpi) {\n  /* Set the appropriate feature bit */\n  cpi->mb.e_mbd.segmentation_enabled = 1;\n  cpi->mb.e_mbd.update_mb_segmentation_map = 1;\n  cpi->mb.e_mbd.update_mb_segmentation_data = 1;\n}\nstatic void disable_segmentation(VP8_COMP *cpi) {\n  /* Clear the appropriate feature bit */\n  cpi->mb.e_mbd.segmentation_enabled = 0;\n}\n\n/* Valid values for a segment are 0 to 3\n * Segmentation map is arrange as [Rows][Columns]\n */\nstatic void set_segmentation_map(VP8_COMP *cpi,\n                                 unsigned char *segmentation_map) {\n  /* Copy in the new segmentation map */\n  memcpy(cpi->segmentation_map, segmentation_map,\n         (cpi->common.mb_rows * cpi->common.mb_cols));\n\n  /* Signal that the map should be updated. */\n  cpi->mb.e_mbd.update_mb_segmentation_map = 1;\n  cpi->mb.e_mbd.update_mb_segmentation_data = 1;\n}\n\n/* The values given for each segment can be either deltas (from the default\n * value chosen for the frame) or absolute values.\n *\n * Valid range for abs values is:\n *    (0-127 for MB_LVL_ALT_Q), (0-63 for SEGMENT_ALT_LF)\n * Valid range for delta values are:\n *    (+/-127 for MB_LVL_ALT_Q), (+/-63 for SEGMENT_ALT_LF)\n *\n * abs_delta = SEGMENT_DELTADATA (deltas)\n * abs_delta = SEGMENT_ABSDATA (use the absolute values given).\n *\n */\nstatic void set_segment_data(VP8_COMP *cpi, signed char *feature_data,\n                             unsigned char abs_delta) {\n  cpi->mb.e_mbd.mb_segment_abs_delta = abs_delta;\n  memcpy(cpi->segment_feature_data, feature_data,\n         sizeof(cpi->segment_feature_data));\n}\n\n/* A simple function to cyclically refresh the background at a lower Q */\nstatic void cyclic_background_refresh(VP8_COMP *cpi, int Q, int lf_adjustment) {\n  unsigned char *seg_map = cpi->segmentation_map;\n  signed char feature_data[MB_LVL_MAX][MAX_MB_SEGMENTS];\n  int i;\n  int block_count = cpi->cyclic_refresh_mode_max_mbs_perframe;\n  int mbs_in_frame = cpi->common.mb_rows * cpi->common.mb_cols;\n\n  cpi->cyclic_refresh_q = Q / 2;\n\n  if (cpi->oxcf.screen_content_mode) {\n    // Modify quality ramp-up based on Q. Above some Q level, increase the\n    // number of blocks to be refreshed, and reduce it below the thredhold.\n    // Turn-off under certain conditions (i.e., away from key frame, and if\n    // we are at good quality (low Q) and most of the blocks were\n    // skipped-encoded\n    // in previous frame.\n    int qp_thresh = (cpi->oxcf.screen_content_mode == 2) ? 80 : 100;\n    if (Q >= qp_thresh) {\n      cpi->cyclic_refresh_mode_max_mbs_perframe =\n          (cpi->common.mb_rows * cpi->common.mb_cols) / 10;\n    } else if (cpi->frames_since_key > 250 && Q < 20 &&\n               cpi->mb.skip_true_count > (int)(0.95 * mbs_in_frame)) {\n      cpi->cyclic_refresh_mode_max_mbs_perframe = 0;\n    } else {\n      cpi->cyclic_refresh_mode_max_mbs_perframe =\n          (cpi->common.mb_rows * cpi->common.mb_cols) / 20;\n    }\n    block_count = cpi->cyclic_refresh_mode_max_mbs_perframe;\n  }\n\n  // Set every macroblock to be eligible for update.\n  // For key frame this will reset seg map to 0.\n  memset(cpi->segmentation_map, 0, mbs_in_frame);\n\n  if (cpi->common.frame_type != KEY_FRAME && block_count > 0) {\n    /* Cycle through the macro_block rows */\n    /* MB loop to set local segmentation map */\n    i = cpi->cyclic_refresh_mode_index;\n    assert(i < mbs_in_frame);\n    do {\n      /* If the MB is as a candidate for clean up then mark it for\n       * possible boost/refresh (segment 1) The segment id may get\n       * reset to 0 later if the MB gets coded anything other than\n       * last frame 0,0 as only (last frame 0,0) MBs are eligable for\n       * refresh : that is to say Mbs likely to be background blocks.\n       */\n      if (cpi->cyclic_refresh_map[i] == 0) {\n        seg_map[i] = 1;\n        block_count--;\n      } else if (cpi->cyclic_refresh_map[i] < 0) {\n        cpi->cyclic_refresh_map[i]++;\n      }\n\n      i++;\n      if (i == mbs_in_frame) i = 0;\n\n    } while (block_count && i != cpi->cyclic_refresh_mode_index);\n\n    cpi->cyclic_refresh_mode_index = i;\n\n#if CONFIG_TEMPORAL_DENOISING\n    if (cpi->oxcf.noise_sensitivity > 0) {\n      if (cpi->denoiser.denoiser_mode == kDenoiserOnYUVAggressive &&\n          Q < (int)cpi->denoiser.denoise_pars.qp_thresh &&\n          (cpi->frames_since_key >\n           2 * cpi->denoiser.denoise_pars.consec_zerolast)) {\n        // Under aggressive denoising, use segmentation to turn off loop\n        // filter below some qp thresh. The filter is reduced for all\n        // blocks that have been encoded as ZEROMV LAST x frames in a row,\n        // where x is set by cpi->denoiser.denoise_pars.consec_zerolast.\n        // This is to avoid \"dot\" artifacts that can occur from repeated\n        // loop filtering on noisy input source.\n        cpi->cyclic_refresh_q = Q;\n        // lf_adjustment = -MAX_LOOP_FILTER;\n        lf_adjustment = -40;\n        for (i = 0; i < mbs_in_frame; ++i) {\n          seg_map[i] = (cpi->consec_zero_last[i] >\n                        cpi->denoiser.denoise_pars.consec_zerolast)\n                           ? 1\n                           : 0;\n        }\n      }\n    }\n#endif\n  }\n\n  /* Activate segmentation. */\n  cpi->mb.e_mbd.update_mb_segmentation_map = 1;\n  cpi->mb.e_mbd.update_mb_segmentation_data = 1;\n  enable_segmentation(cpi);\n\n  /* Set up the quant segment data */\n  feature_data[MB_LVL_ALT_Q][0] = 0;\n  feature_data[MB_LVL_ALT_Q][1] = (cpi->cyclic_refresh_q - Q);\n  feature_data[MB_LVL_ALT_Q][2] = 0;\n  feature_data[MB_LVL_ALT_Q][3] = 0;\n\n  /* Set up the loop segment data */\n  feature_data[MB_LVL_ALT_LF][0] = 0;\n  feature_data[MB_LVL_ALT_LF][1] = lf_adjustment;\n  feature_data[MB_LVL_ALT_LF][2] = 0;\n  feature_data[MB_LVL_ALT_LF][3] = 0;\n\n  /* Initialise the feature data structure */\n  set_segment_data(cpi, &feature_data[0][0], SEGMENT_DELTADATA);\n}\n\nstatic void compute_skin_map(VP8_COMP *cpi) {\n  int mb_row, mb_col, num_bl;\n  VP8_COMMON *cm = &cpi->common;\n  const uint8_t *src_y = cpi->Source->y_buffer;\n  const uint8_t *src_u = cpi->Source->u_buffer;\n  const uint8_t *src_v = cpi->Source->v_buffer;\n  const int src_ystride = cpi->Source->y_stride;\n  const int src_uvstride = cpi->Source->uv_stride;\n\n  const SKIN_DETECTION_BLOCK_SIZE bsize =\n      (cm->Width * cm->Height <= 352 * 288) ? SKIN_8X8 : SKIN_16X16;\n\n  for (mb_row = 0; mb_row < cm->mb_rows; mb_row++) {\n    num_bl = 0;\n    for (mb_col = 0; mb_col < cm->mb_cols; mb_col++) {\n      const int bl_index = mb_row * cm->mb_cols + mb_col;\n      cpi->skin_map[bl_index] =\n          vp8_compute_skin_block(src_y, src_u, src_v, src_ystride, src_uvstride,\n                                 bsize, cpi->consec_zero_last[bl_index], 0);\n      num_bl++;\n      src_y += 16;\n      src_u += 8;\n      src_v += 8;\n    }\n    src_y += (src_ystride << 4) - (num_bl << 4);\n    src_u += (src_uvstride << 3) - (num_bl << 3);\n    src_v += (src_uvstride << 3) - (num_bl << 3);\n  }\n\n  // Remove isolated skin blocks (none of its neighbors are skin) and isolated\n  // non-skin blocks (all of its neighbors are skin). Skip the boundary.\n  for (mb_row = 1; mb_row < cm->mb_rows - 1; mb_row++) {\n    for (mb_col = 1; mb_col < cm->mb_cols - 1; mb_col++) {\n      const int bl_index = mb_row * cm->mb_cols + mb_col;\n      int num_neighbor = 0;\n      int mi, mj;\n      int non_skin_threshold = 8;\n\n      for (mi = -1; mi <= 1; mi += 1) {\n        for (mj = -1; mj <= 1; mj += 1) {\n          int bl_neighbor_index = (mb_row + mi) * cm->mb_cols + mb_col + mj;\n          if (cpi->skin_map[bl_neighbor_index]) num_neighbor++;\n        }\n      }\n\n      if (cpi->skin_map[bl_index] && num_neighbor < 2)\n        cpi->skin_map[bl_index] = 0;\n      if (!cpi->skin_map[bl_index] && num_neighbor == non_skin_threshold)\n        cpi->skin_map[bl_index] = 1;\n    }\n  }\n}\n\nstatic void set_default_lf_deltas(VP8_COMP *cpi) {\n  cpi->mb.e_mbd.mode_ref_lf_delta_enabled = 1;\n  cpi->mb.e_mbd.mode_ref_lf_delta_update = 1;\n\n  memset(cpi->mb.e_mbd.ref_lf_deltas, 0, sizeof(cpi->mb.e_mbd.ref_lf_deltas));\n  memset(cpi->mb.e_mbd.mode_lf_deltas, 0, sizeof(cpi->mb.e_mbd.mode_lf_deltas));\n\n  /* Test of ref frame deltas */\n  cpi->mb.e_mbd.ref_lf_deltas[INTRA_FRAME] = 2;\n  cpi->mb.e_mbd.ref_lf_deltas[LAST_FRAME] = 0;\n  cpi->mb.e_mbd.ref_lf_deltas[GOLDEN_FRAME] = -2;\n  cpi->mb.e_mbd.ref_lf_deltas[ALTREF_FRAME] = -2;\n\n  cpi->mb.e_mbd.mode_lf_deltas[0] = 4; /* BPRED */\n\n  if (cpi->oxcf.Mode == MODE_REALTIME) {\n    cpi->mb.e_mbd.mode_lf_deltas[1] = -12; /* Zero */\n  } else {\n    cpi->mb.e_mbd.mode_lf_deltas[1] = -2; /* Zero */\n  }\n\n  cpi->mb.e_mbd.mode_lf_deltas[2] = 2; /* New mv */\n  cpi->mb.e_mbd.mode_lf_deltas[3] = 4; /* Split mv */\n}\n\n/* Convenience macros for mapping speed and mode into a continuous\n * range\n */\n#define GOOD(x) ((x) + 1)\n#define RT(x) ((x) + 7)\n\nstatic int speed_map(int speed, const int *map) {\n  int res;\n\n  do {\n    res = *map++;\n  } while (speed >= *map++);\n  return res;\n}\n\nstatic const int thresh_mult_map_znn[] = {\n  /* map common to zero, nearest, and near */\n  0, GOOD(2), 1500, GOOD(3), 2000, RT(0), 1000, RT(2), 2000, INT_MAX\n};\n\nstatic const int thresh_mult_map_vhpred[] = { 1000, GOOD(2), 1500,    GOOD(3),\n                                              2000, RT(0),   1000,    RT(1),\n                                              2000, RT(7),   INT_MAX, INT_MAX };\n\nstatic const int thresh_mult_map_bpred[] = { 2000,    GOOD(0), 2500, GOOD(2),\n                                             5000,    GOOD(3), 7500, RT(0),\n                                             2500,    RT(1),   5000, RT(6),\n                                             INT_MAX, INT_MAX };\n\nstatic const int thresh_mult_map_tm[] = { 1000,    GOOD(2), 1500, GOOD(3),\n                                          2000,    RT(0),   0,    RT(1),\n                                          1000,    RT(2),   2000, RT(7),\n                                          INT_MAX, INT_MAX };\n\nstatic const int thresh_mult_map_new1[] = { 1000,  GOOD(2), 2000,\n                                            RT(0), 2000,    INT_MAX };\n\nstatic const int thresh_mult_map_new2[] = { 1000, GOOD(2), 2000, GOOD(3),\n                                            2500, GOOD(5), 4000, RT(0),\n                                            2000, RT(2),   2500, RT(5),\n                                            4000, INT_MAX };\n\nstatic const int thresh_mult_map_split1[] = {\n  2500,  GOOD(0), 1700,  GOOD(2), 10000, GOOD(3), 25000, GOOD(4), INT_MAX,\n  RT(0), 5000,    RT(1), 10000,   RT(2), 25000,   RT(3), INT_MAX, INT_MAX\n};\n\nstatic const int thresh_mult_map_split2[] = {\n  5000,  GOOD(0), 4500,  GOOD(2), 20000, GOOD(3), 50000, GOOD(4), INT_MAX,\n  RT(0), 10000,   RT(1), 20000,   RT(2), 50000,   RT(3), INT_MAX, INT_MAX\n};\n\nstatic const int mode_check_freq_map_zn2[] = {\n  /* {zero,nearest}{2,3} */\n  0, RT(10), 1 << 1, RT(11), 1 << 2, RT(12), 1 << 3, INT_MAX\n};\n\nstatic const int mode_check_freq_map_vhbpred[] = { 0, GOOD(5), 2, RT(0),\n                                                   0, RT(3),   2, RT(5),\n                                                   4, INT_MAX };\n\nstatic const int mode_check_freq_map_near2[] = {\n  0,      GOOD(5), 2,      RT(0),  0,      RT(3),  2,\n  RT(10), 1 << 2,  RT(11), 1 << 3, RT(12), 1 << 4, INT_MAX\n};\n\nstatic const int mode_check_freq_map_new1[] = {\n  0, RT(10), 1 << 1, RT(11), 1 << 2, RT(12), 1 << 3, INT_MAX\n};\n\nstatic const int mode_check_freq_map_new2[] = { 0,      GOOD(5), 4,      RT(0),\n                                                0,      RT(3),   4,      RT(10),\n                                                1 << 3, RT(11),  1 << 4, RT(12),\n                                                1 << 5, INT_MAX };\n\nstatic const int mode_check_freq_map_split1[] = { 0, GOOD(2), 2, GOOD(3),\n                                                  7, RT(1),   2, RT(2),\n                                                  7, INT_MAX };\n\nstatic const int mode_check_freq_map_split2[] = { 0, GOOD(1), 2,  GOOD(2),\n                                                  4, GOOD(3), 15, RT(1),\n                                                  4, RT(2),   15, INT_MAX };\n\nvoid vp8_set_speed_features(VP8_COMP *cpi) {\n  SPEED_FEATURES *sf = &cpi->sf;\n  int Mode = cpi->compressor_speed;\n  int Speed = cpi->Speed;\n  int Speed2;\n  int i;\n  VP8_COMMON *cm = &cpi->common;\n  int last_improved_quant = sf->improved_quant;\n  int ref_frames;\n\n  /* Initialise default mode frequency sampling variables */\n  for (i = 0; i < MAX_MODES; ++i) {\n    cpi->mode_check_freq[i] = 0;\n  }\n\n  cpi->mb.mbs_tested_so_far = 0;\n  cpi->mb.mbs_zero_last_dot_suppress = 0;\n\n  /* best quality defaults */\n  sf->RD = 1;\n  sf->search_method = NSTEP;\n  sf->improved_quant = 1;\n  sf->improved_dct = 1;\n  sf->auto_filter = 1;\n  sf->recode_loop = 1;\n  sf->quarter_pixel_search = 1;\n  sf->half_pixel_search = 1;\n  sf->iterative_sub_pixel = 1;\n  sf->optimize_coefficients = 1;\n  sf->use_fastquant_for_pick = 0;\n  sf->no_skip_block4x4_search = 1;\n\n  sf->first_step = 0;\n  sf->max_step_search_steps = MAX_MVSEARCH_STEPS;\n  sf->improved_mv_pred = 1;\n\n  /* default thresholds to 0 */\n  for (i = 0; i < MAX_MODES; ++i) sf->thresh_mult[i] = 0;\n\n  /* Count enabled references */\n  ref_frames = 1;\n  if (cpi->ref_frame_flags & VP8_LAST_FRAME) ref_frames++;\n  if (cpi->ref_frame_flags & VP8_GOLD_FRAME) ref_frames++;\n  if (cpi->ref_frame_flags & VP8_ALTR_FRAME) ref_frames++;\n\n  /* Convert speed to continuous range, with clamping */\n  if (Mode == 0) {\n    Speed = 0;\n  } else if (Mode == 2) {\n    Speed = RT(Speed);\n  } else {\n    if (Speed > 5) Speed = 5;\n    Speed = GOOD(Speed);\n  }\n\n  sf->thresh_mult[THR_ZERO1] = sf->thresh_mult[THR_NEAREST1] =\n      sf->thresh_mult[THR_NEAR1] = sf->thresh_mult[THR_DC] = 0; /* always */\n\n  sf->thresh_mult[THR_ZERO2] = sf->thresh_mult[THR_ZERO3] =\n      sf->thresh_mult[THR_NEAREST2] = sf->thresh_mult[THR_NEAREST3] =\n          sf->thresh_mult[THR_NEAR2] = sf->thresh_mult[THR_NEAR3] =\n              speed_map(Speed, thresh_mult_map_znn);\n\n  sf->thresh_mult[THR_V_PRED] = sf->thresh_mult[THR_H_PRED] =\n      speed_map(Speed, thresh_mult_map_vhpred);\n  sf->thresh_mult[THR_B_PRED] = speed_map(Speed, thresh_mult_map_bpred);\n  sf->thresh_mult[THR_TM] = speed_map(Speed, thresh_mult_map_tm);\n  sf->thresh_mult[THR_NEW1] = speed_map(Speed, thresh_mult_map_new1);\n  sf->thresh_mult[THR_NEW2] = sf->thresh_mult[THR_NEW3] =\n      speed_map(Speed, thresh_mult_map_new2);\n  sf->thresh_mult[THR_SPLIT1] = speed_map(Speed, thresh_mult_map_split1);\n  sf->thresh_mult[THR_SPLIT2] = sf->thresh_mult[THR_SPLIT3] =\n      speed_map(Speed, thresh_mult_map_split2);\n\n  // Special case for temporal layers.\n  // Reduce the thresholds for zero/nearest/near for GOLDEN, if GOLDEN is\n  // used as second reference. We don't modify thresholds for ALTREF case\n  // since ALTREF is usually used as long-term reference in temporal layers.\n  if ((cpi->Speed <= 6) && (cpi->oxcf.number_of_layers > 1) &&\n      (cpi->ref_frame_flags & VP8_LAST_FRAME) &&\n      (cpi->ref_frame_flags & VP8_GOLD_FRAME)) {\n    if (cpi->closest_reference_frame == GOLDEN_FRAME) {\n      sf->thresh_mult[THR_ZERO2] = sf->thresh_mult[THR_ZERO2] >> 3;\n      sf->thresh_mult[THR_NEAREST2] = sf->thresh_mult[THR_NEAREST2] >> 3;\n      sf->thresh_mult[THR_NEAR2] = sf->thresh_mult[THR_NEAR2] >> 3;\n    } else {\n      sf->thresh_mult[THR_ZERO2] = sf->thresh_mult[THR_ZERO2] >> 1;\n      sf->thresh_mult[THR_NEAREST2] = sf->thresh_mult[THR_NEAREST2] >> 1;\n      sf->thresh_mult[THR_NEAR2] = sf->thresh_mult[THR_NEAR2] >> 1;\n    }\n  }\n\n  cpi->mode_check_freq[THR_ZERO1] = cpi->mode_check_freq[THR_NEAREST1] =\n      cpi->mode_check_freq[THR_NEAR1] = cpi->mode_check_freq[THR_TM] =\n          cpi->mode_check_freq[THR_DC] = 0; /* always */\n\n  cpi->mode_check_freq[THR_ZERO2] = cpi->mode_check_freq[THR_ZERO3] =\n      cpi->mode_check_freq[THR_NEAREST2] = cpi->mode_check_freq[THR_NEAREST3] =\n          speed_map(Speed, mode_check_freq_map_zn2);\n\n  cpi->mode_check_freq[THR_NEAR2] = cpi->mode_check_freq[THR_NEAR3] =\n      speed_map(Speed, mode_check_freq_map_near2);\n\n  cpi->mode_check_freq[THR_V_PRED] = cpi->mode_check_freq[THR_H_PRED] =\n      cpi->mode_check_freq[THR_B_PRED] =\n          speed_map(Speed, mode_check_freq_map_vhbpred);\n\n  // For real-time mode at speed 10 keep the mode_check_freq threshold\n  // for NEW1 similar to that of speed 9.\n  Speed2 = Speed;\n  if (cpi->Speed == 10 && Mode == 2) Speed2 = RT(9);\n  cpi->mode_check_freq[THR_NEW1] = speed_map(Speed2, mode_check_freq_map_new1);\n\n  cpi->mode_check_freq[THR_NEW2] = cpi->mode_check_freq[THR_NEW3] =\n      speed_map(Speed, mode_check_freq_map_new2);\n\n  cpi->mode_check_freq[THR_SPLIT1] =\n      speed_map(Speed, mode_check_freq_map_split1);\n  cpi->mode_check_freq[THR_SPLIT2] = cpi->mode_check_freq[THR_SPLIT3] =\n      speed_map(Speed, mode_check_freq_map_split2);\n  Speed = cpi->Speed;\n  switch (Mode) {\n#if !CONFIG_REALTIME_ONLY\n    case 0: /* best quality mode */\n      sf->first_step = 0;\n      sf->max_step_search_steps = MAX_MVSEARCH_STEPS;\n      break;\n    case 1:\n    case 3:\n      if (Speed > 0) {\n        /* Disable coefficient optimization above speed 0 */\n        sf->optimize_coefficients = 0;\n        sf->use_fastquant_for_pick = 1;\n        sf->no_skip_block4x4_search = 0;\n\n        sf->first_step = 1;\n      }\n\n      if (Speed > 2) {\n        sf->improved_quant = 0;\n        sf->improved_dct = 0;\n\n        /* Only do recode loop on key frames, golden frames and\n         * alt ref frames\n         */\n        sf->recode_loop = 2;\n      }\n\n      if (Speed > 3) {\n        sf->auto_filter = 1;\n        sf->recode_loop = 0; /* recode loop off */\n        sf->RD = 0;          /* Turn rd off */\n      }\n\n      if (Speed > 4) {\n        sf->auto_filter = 0; /* Faster selection of loop filter */\n      }\n\n      break;\n#endif\n    case 2:\n      sf->optimize_coefficients = 0;\n      sf->recode_loop = 0;\n      sf->auto_filter = 1;\n      sf->iterative_sub_pixel = 1;\n      sf->search_method = NSTEP;\n\n      if (Speed > 0) {\n        sf->improved_quant = 0;\n        sf->improved_dct = 0;\n\n        sf->use_fastquant_for_pick = 1;\n        sf->no_skip_block4x4_search = 0;\n        sf->first_step = 1;\n      }\n\n      if (Speed > 2) sf->auto_filter = 0; /* Faster selection of loop filter */\n\n      if (Speed > 3) {\n        sf->RD = 0;\n        sf->auto_filter = 1;\n      }\n\n      if (Speed > 4) {\n        sf->auto_filter = 0; /* Faster selection of loop filter */\n        sf->search_method = HEX;\n        sf->iterative_sub_pixel = 0;\n      }\n\n      if (Speed > 6) {\n        unsigned int sum = 0;\n        unsigned int total_mbs = cm->MBs;\n        int thresh;\n        unsigned int total_skip;\n\n        int min = 2000;\n\n        if (cpi->oxcf.encode_breakout > 2000) min = cpi->oxcf.encode_breakout;\n\n        min >>= 7;\n\n        for (i = 0; i < min; ++i) {\n          sum += cpi->mb.error_bins[i];\n        }\n\n        total_skip = sum;\n        sum = 0;\n\n        /* i starts from 2 to make sure thresh started from 2048 */\n        for (; i < 1024; ++i) {\n          sum += cpi->mb.error_bins[i];\n\n          if (10 * sum >=\n              (unsigned int)(cpi->Speed - 6) * (total_mbs - total_skip)) {\n            break;\n          }\n        }\n\n        i--;\n        thresh = (i << 7);\n\n        if (thresh < 2000) thresh = 2000;\n\n        if (ref_frames > 1) {\n          sf->thresh_mult[THR_NEW1] = thresh;\n          sf->thresh_mult[THR_NEAREST1] = thresh >> 1;\n          sf->thresh_mult[THR_NEAR1] = thresh >> 1;\n        }\n\n        if (ref_frames > 2) {\n          sf->thresh_mult[THR_NEW2] = thresh << 1;\n          sf->thresh_mult[THR_NEAREST2] = thresh;\n          sf->thresh_mult[THR_NEAR2] = thresh;\n        }\n\n        if (ref_frames > 3) {\n          sf->thresh_mult[THR_NEW3] = thresh << 1;\n          sf->thresh_mult[THR_NEAREST3] = thresh;\n          sf->thresh_mult[THR_NEAR3] = thresh;\n        }\n\n        sf->improved_mv_pred = 0;\n      }\n\n      if (Speed > 8) sf->quarter_pixel_search = 0;\n\n      if (cm->version == 0) {\n        cm->filter_type = NORMAL_LOOPFILTER;\n\n        if (Speed >= 14) cm->filter_type = SIMPLE_LOOPFILTER;\n      } else {\n        cm->filter_type = SIMPLE_LOOPFILTER;\n      }\n\n      /* This has a big hit on quality. Last resort */\n      if (Speed >= 15) sf->half_pixel_search = 0;\n\n      memset(cpi->mb.error_bins, 0, sizeof(cpi->mb.error_bins));\n\n  } /* switch */\n\n  /* Slow quant, dct and trellis not worthwhile for first pass\n   * so make sure they are always turned off.\n   */\n  if (cpi->pass == 1) {\n    sf->improved_quant = 0;\n    sf->optimize_coefficients = 0;\n    sf->improved_dct = 0;\n  }\n\n  if (cpi->sf.search_method == NSTEP) {\n    vp8_init3smotion_compensation(&cpi->mb,\n                                  cm->yv12_fb[cm->lst_fb_idx].y_stride);\n  } else if (cpi->sf.search_method == DIAMOND) {\n    vp8_init_dsmotion_compensation(&cpi->mb,\n                                   cm->yv12_fb[cm->lst_fb_idx].y_stride);\n  }\n\n  if (cpi->sf.improved_dct) {\n    cpi->mb.short_fdct8x4 = vp8_short_fdct8x4;\n    cpi->mb.short_fdct4x4 = vp8_short_fdct4x4;\n  } else {\n    /* No fast FDCT defined for any platform at this time. */\n    cpi->mb.short_fdct8x4 = vp8_short_fdct8x4;\n    cpi->mb.short_fdct4x4 = vp8_short_fdct4x4;\n  }\n\n  cpi->mb.short_walsh4x4 = vp8_short_walsh4x4;\n\n  if (cpi->sf.improved_quant) {\n    cpi->mb.quantize_b = vp8_regular_quantize_b;\n  } else {\n    cpi->mb.quantize_b = vp8_fast_quantize_b;\n  }\n  if (cpi->sf.improved_quant != last_improved_quant) vp8cx_init_quantizer(cpi);\n\n  if (cpi->sf.iterative_sub_pixel == 1) {\n    cpi->find_fractional_mv_step = vp8_find_best_sub_pixel_step_iteratively;\n  } else if (cpi->sf.quarter_pixel_search) {\n    cpi->find_fractional_mv_step = vp8_find_best_sub_pixel_step;\n  } else if (cpi->sf.half_pixel_search) {\n    cpi->find_fractional_mv_step = vp8_find_best_half_pixel_step;\n  } else {\n    cpi->find_fractional_mv_step = vp8_skip_fractional_mv_step;\n  }\n\n  if (cpi->sf.optimize_coefficients == 1 && cpi->pass != 1) {\n    cpi->mb.optimize = 1;\n  } else {\n    cpi->mb.optimize = 0;\n  }\n\n  if (cpi->common.full_pixel) {\n    cpi->find_fractional_mv_step = vp8_skip_fractional_mv_step;\n  }\n\n#ifdef SPEEDSTATS\n  frames_at_speed[cpi->Speed]++;\n#endif\n}\n#undef GOOD\n#undef RT\n\nstatic void alloc_raw_frame_buffers(VP8_COMP *cpi) {\n#if VP8_TEMPORAL_ALT_REF\n  int width = (cpi->oxcf.Width + 15) & ~15;\n  int height = (cpi->oxcf.Height + 15) & ~15;\n#endif\n\n  cpi->lookahead = vp8_lookahead_init(cpi->oxcf.Width, cpi->oxcf.Height,\n                                      cpi->oxcf.lag_in_frames);\n  if (!cpi->lookahead) {\n    vpx_internal_error(&cpi->common.error, VPX_CODEC_MEM_ERROR,\n                       \"Failed to allocate lag buffers\");\n  }\n\n#if VP8_TEMPORAL_ALT_REF\n\n  if (vp8_yv12_alloc_frame_buffer(&cpi->alt_ref_buffer, width, height,\n                                  VP8BORDERINPIXELS)) {\n    vpx_internal_error(&cpi->common.error, VPX_CODEC_MEM_ERROR,\n                       \"Failed to allocate altref buffer\");\n  }\n\n#endif\n}\n\nstatic void dealloc_raw_frame_buffers(VP8_COMP *cpi) {\n#if VP8_TEMPORAL_ALT_REF\n  vp8_yv12_de_alloc_frame_buffer(&cpi->alt_ref_buffer);\n#endif\n  vp8_lookahead_destroy(cpi->lookahead);\n}\n\nstatic int vp8_alloc_partition_data(VP8_COMP *cpi) {\n  vpx_free(cpi->mb.pip);\n\n  cpi->mb.pip =\n      vpx_calloc((cpi->common.mb_cols + 1) * (cpi->common.mb_rows + 1),\n                 sizeof(PARTITION_INFO));\n  if (!cpi->mb.pip) return 1;\n\n  cpi->mb.pi = cpi->mb.pip + cpi->common.mode_info_stride + 1;\n\n  return 0;\n}\n\nvoid vp8_alloc_compressor_data(VP8_COMP *cpi) {\n  VP8_COMMON *cm = &cpi->common;\n\n  int width = cm->Width;\n  int height = cm->Height;\n\n  if (vp8_alloc_frame_buffers(cm, width, height)) {\n    vpx_internal_error(&cpi->common.error, VPX_CODEC_MEM_ERROR,\n                       \"Failed to allocate frame buffers\");\n  }\n\n  if (vp8_alloc_partition_data(cpi)) {\n    vpx_internal_error(&cpi->common.error, VPX_CODEC_MEM_ERROR,\n                       \"Failed to allocate partition data\");\n  }\n\n  if ((width & 0xf) != 0) width += 16 - (width & 0xf);\n\n  if ((height & 0xf) != 0) height += 16 - (height & 0xf);\n\n  if (vp8_yv12_alloc_frame_buffer(&cpi->pick_lf_lvl_frame, width, height,\n                                  VP8BORDERINPIXELS)) {\n    vpx_internal_error(&cpi->common.error, VPX_CODEC_MEM_ERROR,\n                       \"Failed to allocate last frame buffer\");\n  }\n\n  if (vp8_yv12_alloc_frame_buffer(&cpi->scaled_source, width, height,\n                                  VP8BORDERINPIXELS)) {\n    vpx_internal_error(&cpi->common.error, VPX_CODEC_MEM_ERROR,\n                       \"Failed to allocate scaled source buffer\");\n  }\n\n  vpx_free(cpi->tok);\n\n  {\n#if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING\n    unsigned int tokens = 8 * 24 * 16; /* one MB for each thread */\n#else\n    unsigned int tokens = cm->mb_rows * cm->mb_cols * 24 * 16;\n#endif\n    CHECK_MEM_ERROR(&cpi->common.error, cpi->tok,\n                    vpx_calloc(tokens, sizeof(*cpi->tok)));\n  }\n\n  /* Data used for real time vc mode to see if gf needs refreshing */\n  cpi->zeromv_count = 0;\n\n  /* Structures used to monitor GF usage */\n  vpx_free(cpi->gf_active_flags);\n  CHECK_MEM_ERROR(\n      &cpi->common.error, cpi->gf_active_flags,\n      vpx_calloc(sizeof(*cpi->gf_active_flags), cm->mb_rows * cm->mb_cols));\n  cpi->gf_active_count = cm->mb_rows * cm->mb_cols;\n\n  vpx_free(cpi->mb_activity_map);\n  CHECK_MEM_ERROR(\n      &cpi->common.error, cpi->mb_activity_map,\n      vpx_calloc(sizeof(*cpi->mb_activity_map), cm->mb_rows * cm->mb_cols));\n\n  /* allocate memory for storing last frame's MVs for MV prediction. */\n  vpx_free(cpi->lfmv);\n  CHECK_MEM_ERROR(\n      &cpi->common.error, cpi->lfmv,\n      vpx_calloc((cm->mb_rows + 2) * (cm->mb_cols + 2), sizeof(*cpi->lfmv)));\n  vpx_free(cpi->lf_ref_frame_sign_bias);\n  CHECK_MEM_ERROR(&cpi->common.error, cpi->lf_ref_frame_sign_bias,\n                  vpx_calloc((cm->mb_rows + 2) * (cm->mb_cols + 2),\n                             sizeof(*cpi->lf_ref_frame_sign_bias)));\n  vpx_free(cpi->lf_ref_frame);\n  CHECK_MEM_ERROR(&cpi->common.error, cpi->lf_ref_frame,\n                  vpx_calloc((cm->mb_rows + 2) * (cm->mb_cols + 2),\n                             sizeof(*cpi->lf_ref_frame)));\n\n  /* Create the encoder segmentation map and set all entries to 0 */\n  vpx_free(cpi->segmentation_map);\n  CHECK_MEM_ERROR(\n      &cpi->common.error, cpi->segmentation_map,\n      vpx_calloc(cm->mb_rows * cm->mb_cols, sizeof(*cpi->segmentation_map)));\n  cpi->cyclic_refresh_mode_index = 0;\n  vpx_free(cpi->active_map);\n  CHECK_MEM_ERROR(\n      &cpi->common.error, cpi->active_map,\n      vpx_calloc(cm->mb_rows * cm->mb_cols, sizeof(*cpi->active_map)));\n  memset(cpi->active_map, 1, (cm->mb_rows * cm->mb_cols));\n\n#if CONFIG_MULTITHREAD\n  if (width < 640) {\n    cpi->mt_sync_range = 1;\n  } else if (width <= 1280) {\n    cpi->mt_sync_range = 4;\n  } else if (width <= 2560) {\n    cpi->mt_sync_range = 8;\n  } else {\n    cpi->mt_sync_range = 16;\n  }\n\n  if (cpi->oxcf.multi_threaded > 1) {\n    int i;\n\n    vpx_free(cpi->mt_current_mb_col);\n    CHECK_MEM_ERROR(&cpi->common.error, cpi->mt_current_mb_col,\n                    vpx_malloc(sizeof(*cpi->mt_current_mb_col) * cm->mb_rows));\n    for (i = 0; i < cm->mb_rows; ++i)\n      vpx_atomic_init(&cpi->mt_current_mb_col[i], 0);\n  }\n\n#endif\n\n  vpx_free(cpi->tplist);\n  CHECK_MEM_ERROR(&cpi->common.error, cpi->tplist,\n                  vpx_malloc(sizeof(TOKENLIST) * cm->mb_rows));\n\n#if CONFIG_TEMPORAL_DENOISING\n  if (cpi->oxcf.noise_sensitivity > 0) {\n    vp8_denoiser_free(&cpi->denoiser);\n    if (vp8_denoiser_allocate(&cpi->denoiser, width, height, cm->mb_rows,\n                              cm->mb_cols, cpi->oxcf.noise_sensitivity)) {\n      vpx_internal_error(&cpi->common.error, VPX_CODEC_MEM_ERROR,\n                         \"Failed to allocate denoiser\");\n    }\n  }\n#endif\n}\n\n/* Quant MOD */\nstatic const int q_trans[] = {\n  0,  1,  2,  3,  4,  5,  7,   8,   9,   10,  12,  13,  15,  17,  18,  19,\n  20, 21, 23, 24, 25, 26, 27,  28,  29,  30,  31,  33,  35,  37,  39,  41,\n  43, 45, 47, 49, 51, 53, 55,  57,  59,  61,  64,  67,  70,  73,  76,  79,\n  82, 85, 88, 91, 94, 97, 100, 103, 106, 109, 112, 115, 118, 121, 124, 127,\n};\n\nint vp8_reverse_trans(int x) {\n  int i;\n\n  for (i = 0; i < 64; ++i) {\n    if (q_trans[i] >= x) return i;\n  }\n\n  return 63;\n}\nvoid vp8_new_framerate(VP8_COMP *cpi, double framerate) {\n  if (framerate < .1) framerate = 30;\n\n  cpi->framerate = framerate;\n  cpi->output_framerate = framerate;\n  cpi->per_frame_bandwidth =\n      (int)round(cpi->oxcf.target_bandwidth / cpi->output_framerate);\n  cpi->av_per_frame_bandwidth = cpi->per_frame_bandwidth;\n  cpi->min_frame_bandwidth = (int)(cpi->av_per_frame_bandwidth *\n                                   cpi->oxcf.two_pass_vbrmin_section / 100);\n\n  /* Set Maximum gf/arf interval */\n  cpi->max_gf_interval = ((int)(cpi->output_framerate / 2.0) + 2);\n\n  if (cpi->max_gf_interval < 12) cpi->max_gf_interval = 12;\n\n  /* Extended interval for genuinely static scenes */\n  cpi->twopass.static_scene_max_gf_interval = cpi->key_frame_frequency >> 1;\n\n  /* Special conditions when altr ref frame enabled in lagged compress mode */\n  if (cpi->oxcf.play_alternate && cpi->oxcf.lag_in_frames) {\n    if (cpi->max_gf_interval > cpi->oxcf.lag_in_frames - 1) {\n      cpi->max_gf_interval = cpi->oxcf.lag_in_frames - 1;\n    }\n\n    if (cpi->twopass.static_scene_max_gf_interval >\n        cpi->oxcf.lag_in_frames - 1) {\n      cpi->twopass.static_scene_max_gf_interval = cpi->oxcf.lag_in_frames - 1;\n    }\n  }\n\n  if (cpi->max_gf_interval > cpi->twopass.static_scene_max_gf_interval) {\n    cpi->max_gf_interval = cpi->twopass.static_scene_max_gf_interval;\n  }\n}\n\nstatic void init_config(VP8_COMP *cpi, VP8_CONFIG *oxcf) {\n  VP8_COMMON *cm = &cpi->common;\n\n  cpi->oxcf = *oxcf;\n\n  cpi->auto_gold = 1;\n  cpi->auto_adjust_gold_quantizer = 1;\n\n  cm->version = oxcf->Version;\n  vp8_setup_version(cm);\n\n  /* Frame rate is not available on the first frame, as it's derived from\n   * the observed timestamps. The actual value used here doesn't matter\n   * too much, as it will adapt quickly.\n   */\n  if (oxcf->timebase.num > 0) {\n    cpi->framerate =\n        (double)(oxcf->timebase.den) / (double)(oxcf->timebase.num);\n  } else {\n    cpi->framerate = 30;\n  }\n\n  /* If the reciprocal of the timebase seems like a reasonable framerate,\n   * then use that as a guess, otherwise use 30.\n   */\n  if (cpi->framerate > 180) cpi->framerate = 30;\n\n  cpi->ref_framerate = cpi->framerate;\n\n  cpi->ref_frame_flags = VP8_ALTR_FRAME | VP8_GOLD_FRAME | VP8_LAST_FRAME;\n\n  cm->refresh_golden_frame = 0;\n  cm->refresh_last_frame = 1;\n  cm->refresh_entropy_probs = 1;\n\n  /* change includes all joint functionality */\n  vp8_change_config(cpi, oxcf);\n\n  /* Initialize active best and worst q and average q values. */\n  cpi->active_worst_quality = cpi->oxcf.worst_allowed_q;\n  cpi->active_best_quality = cpi->oxcf.best_allowed_q;\n  cpi->avg_frame_qindex = cpi->oxcf.worst_allowed_q;\n\n  /* Initialise the starting buffer levels */\n  cpi->buffer_level = cpi->oxcf.starting_buffer_level;\n  cpi->bits_off_target = cpi->oxcf.starting_buffer_level;\n\n  cpi->rolling_target_bits = cpi->av_per_frame_bandwidth;\n  cpi->rolling_actual_bits = cpi->av_per_frame_bandwidth;\n  cpi->long_rolling_target_bits = cpi->av_per_frame_bandwidth;\n  cpi->long_rolling_actual_bits = cpi->av_per_frame_bandwidth;\n\n  cpi->total_actual_bits = 0;\n  cpi->total_target_vs_actual = 0;\n\n  /* Temporal scalabilty */\n  if (cpi->oxcf.number_of_layers > 1) {\n    unsigned int i;\n    double prev_layer_framerate = 0;\n\n    for (i = 0; i < cpi->oxcf.number_of_layers; ++i) {\n      vp8_init_temporal_layer_context(cpi, oxcf, i, prev_layer_framerate);\n      prev_layer_framerate =\n          cpi->output_framerate / cpi->oxcf.rate_decimator[i];\n    }\n  }\n\n#if VP8_TEMPORAL_ALT_REF\n  {\n    int i;\n\n    cpi->fixed_divide[0] = 0;\n\n    for (i = 1; i < 512; ++i) cpi->fixed_divide[i] = 0x80000 / i;\n  }\n#endif\n}\n\nvoid vp8_update_layer_contexts(VP8_COMP *cpi) {\n  VP8_CONFIG *oxcf = &cpi->oxcf;\n\n  /* Update snapshots of the layer contexts to reflect new parameters */\n  if (oxcf->number_of_layers > 1) {\n    unsigned int i;\n    double prev_layer_framerate = 0;\n\n    assert(oxcf->number_of_layers <= VPX_TS_MAX_LAYERS);\n    for (i = 0; i < oxcf->number_of_layers && i < VPX_TS_MAX_LAYERS; ++i) {\n      LAYER_CONTEXT *lc = &cpi->layer_context[i];\n\n      lc->framerate = cpi->ref_framerate / oxcf->rate_decimator[i];\n      lc->target_bandwidth = oxcf->target_bitrate[i] * 1000;\n\n      lc->starting_buffer_level = rescale(\n          (int)oxcf->starting_buffer_level_in_ms, lc->target_bandwidth, 1000);\n\n      if (oxcf->optimal_buffer_level == 0) {\n        lc->optimal_buffer_level = lc->target_bandwidth / 8;\n      } else {\n        lc->optimal_buffer_level = rescale(\n            (int)oxcf->optimal_buffer_level_in_ms, lc->target_bandwidth, 1000);\n      }\n\n      if (oxcf->maximum_buffer_size == 0) {\n        lc->maximum_buffer_size = lc->target_bandwidth / 8;\n      } else {\n        lc->maximum_buffer_size = rescale((int)oxcf->maximum_buffer_size_in_ms,\n                                          lc->target_bandwidth, 1000);\n      }\n\n      /* Work out the average size of a frame within this layer */\n      if (i > 0) {\n        lc->avg_frame_size_for_layer =\n            (int)round((oxcf->target_bitrate[i] - oxcf->target_bitrate[i - 1]) *\n                       1000 / (lc->framerate - prev_layer_framerate));\n      }\n\n      prev_layer_framerate = lc->framerate;\n    }\n  }\n}\n\nvoid vp8_change_config(VP8_COMP *cpi, VP8_CONFIG *oxcf) {\n  VP8_COMMON *cm = &cpi->common;\n  int last_w, last_h;\n  unsigned int prev_number_of_layers;\n  unsigned int raw_target_rate;\n\n  if (!cpi) return;\n\n  if (!oxcf) return;\n\n  if (cm->version != oxcf->Version) {\n    cm->version = oxcf->Version;\n    vp8_setup_version(cm);\n  }\n\n  last_w = cpi->oxcf.Width;\n  last_h = cpi->oxcf.Height;\n  prev_number_of_layers = cpi->oxcf.number_of_layers;\n\n  cpi->oxcf = *oxcf;\n\n  switch (cpi->oxcf.Mode) {\n    case MODE_REALTIME:\n      cpi->pass = 0;\n      cpi->compressor_speed = 2;\n\n      if (cpi->oxcf.cpu_used < -16) {\n        cpi->oxcf.cpu_used = -16;\n      }\n\n      if (cpi->oxcf.cpu_used > 16) cpi->oxcf.cpu_used = 16;\n\n      break;\n\n    case MODE_GOODQUALITY:\n      cpi->pass = 0;\n      cpi->compressor_speed = 1;\n\n      if (cpi->oxcf.cpu_used < -5) {\n        cpi->oxcf.cpu_used = -5;\n      }\n\n      if (cpi->oxcf.cpu_used > 5) cpi->oxcf.cpu_used = 5;\n\n      break;\n\n    case MODE_BESTQUALITY:\n      cpi->pass = 0;\n      cpi->compressor_speed = 0;\n      break;\n\n    case MODE_FIRSTPASS:\n      cpi->pass = 1;\n      cpi->compressor_speed = 1;\n      break;\n    case MODE_SECONDPASS:\n      cpi->pass = 2;\n      cpi->compressor_speed = 1;\n\n      if (cpi->oxcf.cpu_used < -5) {\n        cpi->oxcf.cpu_used = -5;\n      }\n\n      if (cpi->oxcf.cpu_used > 5) cpi->oxcf.cpu_used = 5;\n\n      break;\n    case MODE_SECONDPASS_BEST:\n      cpi->pass = 2;\n      cpi->compressor_speed = 0;\n      break;\n  }\n\n  if (cpi->pass == 0) cpi->auto_worst_q = 1;\n\n  cpi->oxcf.worst_allowed_q = q_trans[oxcf->worst_allowed_q];\n  cpi->oxcf.best_allowed_q = q_trans[oxcf->best_allowed_q];\n  cpi->oxcf.cq_level = q_trans[cpi->oxcf.cq_level];\n\n  if (oxcf->fixed_q >= 0) {\n    if (oxcf->worst_allowed_q < 0) {\n      cpi->oxcf.fixed_q = q_trans[0];\n    } else {\n      cpi->oxcf.fixed_q = q_trans[oxcf->worst_allowed_q];\n    }\n\n    if (oxcf->alt_q < 0) {\n      cpi->oxcf.alt_q = q_trans[0];\n    } else {\n      cpi->oxcf.alt_q = q_trans[oxcf->alt_q];\n    }\n\n    if (oxcf->key_q < 0) {\n      cpi->oxcf.key_q = q_trans[0];\n    } else {\n      cpi->oxcf.key_q = q_trans[oxcf->key_q];\n    }\n\n    if (oxcf->gold_q < 0) {\n      cpi->oxcf.gold_q = q_trans[0];\n    } else {\n      cpi->oxcf.gold_q = q_trans[oxcf->gold_q];\n    }\n  }\n\n  cpi->ext_refresh_frame_flags_pending = 0;\n\n  cpi->baseline_gf_interval =\n      cpi->oxcf.alt_freq ? cpi->oxcf.alt_freq : DEFAULT_GF_INTERVAL;\n\n  // GF behavior for 1 pass CBR, used when error_resilience is off.\n  if (!cpi->oxcf.error_resilient_mode &&\n      cpi->oxcf.end_usage == USAGE_STREAM_FROM_SERVER &&\n      cpi->oxcf.Mode == MODE_REALTIME)\n    cpi->baseline_gf_interval = cpi->gf_interval_onepass_cbr;\n\n#if (CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING)\n  cpi->oxcf.token_partitions = 3;\n#endif\n\n  if (cpi->oxcf.token_partitions >= 0 && cpi->oxcf.token_partitions <= 3) {\n    cm->multi_token_partition = (TOKEN_PARTITION)cpi->oxcf.token_partitions;\n  }\n\n  setup_features(cpi);\n\n  if (!cpi->use_roi_static_threshold) {\n    int i;\n    for (i = 0; i < MAX_MB_SEGMENTS; ++i) {\n      cpi->segment_encode_breakout[i] = cpi->oxcf.encode_breakout;\n    }\n  }\n\n  /* At the moment the first order values may not be > MAXQ */\n  if (cpi->oxcf.fixed_q > MAXQ) cpi->oxcf.fixed_q = MAXQ;\n\n  /* local file playback mode == really big buffer */\n  if (cpi->oxcf.end_usage == USAGE_LOCAL_FILE_PLAYBACK) {\n    cpi->oxcf.starting_buffer_level = 60000;\n    cpi->oxcf.optimal_buffer_level = 60000;\n    cpi->oxcf.maximum_buffer_size = 240000;\n    cpi->oxcf.starting_buffer_level_in_ms = 60000;\n    cpi->oxcf.optimal_buffer_level_in_ms = 60000;\n    cpi->oxcf.maximum_buffer_size_in_ms = 240000;\n  }\n\n  raw_target_rate = (unsigned int)((int64_t)cpi->oxcf.Width * cpi->oxcf.Height *\n                                   8 * 3 * cpi->framerate / 1000);\n  if (cpi->oxcf.target_bandwidth > raw_target_rate)\n    cpi->oxcf.target_bandwidth = raw_target_rate;\n  /* Convert target bandwidth from Kbit/s to Bit/s */\n  cpi->oxcf.target_bandwidth *= 1000;\n\n  cpi->oxcf.starting_buffer_level = rescale(\n      (int)cpi->oxcf.starting_buffer_level, cpi->oxcf.target_bandwidth, 1000);\n\n  /* Set or reset optimal and maximum buffer levels. */\n  if (cpi->oxcf.optimal_buffer_level == 0) {\n    cpi->oxcf.optimal_buffer_level = cpi->oxcf.target_bandwidth / 8;\n  } else {\n    cpi->oxcf.optimal_buffer_level = rescale(\n        (int)cpi->oxcf.optimal_buffer_level, cpi->oxcf.target_bandwidth, 1000);\n  }\n\n  if (cpi->oxcf.maximum_buffer_size == 0) {\n    cpi->oxcf.maximum_buffer_size = cpi->oxcf.target_bandwidth / 8;\n  } else {\n    cpi->oxcf.maximum_buffer_size = rescale((int)cpi->oxcf.maximum_buffer_size,\n                                            cpi->oxcf.target_bandwidth, 1000);\n  }\n  // Under a configuration change, where maximum_buffer_size may change,\n  // keep buffer level clipped to the maximum allowed buffer size.\n  if (cpi->bits_off_target > cpi->oxcf.maximum_buffer_size) {\n    cpi->bits_off_target = cpi->oxcf.maximum_buffer_size;\n    cpi->buffer_level = cpi->bits_off_target;\n  }\n\n  /* Set up frame rate and related parameters rate control values. */\n  vp8_new_framerate(cpi, cpi->framerate);\n\n  /* Set absolute upper and lower quality limits */\n  cpi->worst_quality = cpi->oxcf.worst_allowed_q;\n  cpi->best_quality = cpi->oxcf.best_allowed_q;\n\n  /* active values should only be modified if out of new range */\n  if (cpi->active_worst_quality > cpi->oxcf.worst_allowed_q) {\n    cpi->active_worst_quality = cpi->oxcf.worst_allowed_q;\n  }\n  /* less likely */\n  else if (cpi->active_worst_quality < cpi->oxcf.best_allowed_q) {\n    cpi->active_worst_quality = cpi->oxcf.best_allowed_q;\n  }\n  if (cpi->active_best_quality < cpi->oxcf.best_allowed_q) {\n    cpi->active_best_quality = cpi->oxcf.best_allowed_q;\n  }\n  /* less likely */\n  else if (cpi->active_best_quality > cpi->oxcf.worst_allowed_q) {\n    cpi->active_best_quality = cpi->oxcf.worst_allowed_q;\n  }\n\n  cpi->buffered_mode = cpi->oxcf.optimal_buffer_level > 0;\n\n  cpi->cq_target_quality = cpi->oxcf.cq_level;\n\n  /* Only allow dropped frames in buffered mode */\n  cpi->drop_frames_allowed = cpi->oxcf.allow_df && cpi->buffered_mode;\n\n  cpi->target_bandwidth = cpi->oxcf.target_bandwidth;\n\n  // Check if the number of temporal layers has changed, and if so reset the\n  // pattern counter and set/initialize the temporal layer context for the\n  // new layer configuration.\n  if (cpi->oxcf.number_of_layers != prev_number_of_layers) {\n    // If the number of temporal layers are changed we must start at the\n    // base of the pattern cycle, so set the layer id to 0 and reset\n    // the temporal pattern counter.\n    if (cpi->temporal_layer_id > 0) {\n      cpi->temporal_layer_id = 0;\n    }\n    cpi->temporal_pattern_counter = 0;\n    vp8_reset_temporal_layer_change(cpi, oxcf, prev_number_of_layers);\n  }\n\n  if (!cpi->initial_width) {\n    cpi->initial_width = cpi->oxcf.Width;\n    cpi->initial_height = cpi->oxcf.Height;\n  }\n\n  cm->Width = cpi->oxcf.Width;\n  cm->Height = cpi->oxcf.Height;\n  assert(cm->Width <= cpi->initial_width);\n  assert(cm->Height <= cpi->initial_height);\n\n  /* TODO(jkoleszar): if an internal spatial resampling is active,\n   * and we downsize the input image, maybe we should clear the\n   * internal scale immediately rather than waiting for it to\n   * correct.\n   */\n\n  /* VP8 sharpness level mapping 0-7 (vs 0-10 in general VPx dialogs) */\n  if (cpi->oxcf.Sharpness > 7) cpi->oxcf.Sharpness = 7;\n\n  cm->sharpness_level = cpi->oxcf.Sharpness;\n\n  if (cm->horiz_scale != VP8E_NORMAL || cm->vert_scale != VP8E_NORMAL) {\n    int hr, hs, vr, vs;\n\n    Scale2Ratio(cm->horiz_scale, &hr, &hs);\n    Scale2Ratio(cm->vert_scale, &vr, &vs);\n\n    /* always go to the next whole number */\n    cm->Width = (hs - 1 + cpi->oxcf.Width * hr) / hs;\n    cm->Height = (vs - 1 + cpi->oxcf.Height * vr) / vs;\n  }\n\n  if (last_w != cpi->oxcf.Width || last_h != cpi->oxcf.Height) {\n    cpi->force_next_frame_intra = 1;\n  }\n\n  if (((cm->Width + 15) & ~15) != cm->yv12_fb[cm->lst_fb_idx].y_width ||\n      ((cm->Height + 15) & ~15) != cm->yv12_fb[cm->lst_fb_idx].y_height ||\n      cm->yv12_fb[cm->lst_fb_idx].y_width == 0) {\n    dealloc_raw_frame_buffers(cpi);\n    alloc_raw_frame_buffers(cpi);\n    vp8_alloc_compressor_data(cpi);\n  }\n\n  if (cpi->oxcf.fixed_q >= 0) {\n    cpi->last_q[0] = cpi->oxcf.fixed_q;\n    cpi->last_q[1] = cpi->oxcf.fixed_q;\n  }\n\n  cpi->Speed = cpi->oxcf.cpu_used;\n\n  /* force to allowlag to 0 if lag_in_frames is 0; */\n  if (cpi->oxcf.lag_in_frames == 0) {\n    cpi->oxcf.allow_lag = 0;\n  }\n  /* Limit on lag buffers as these are not currently dynamically allocated */\n  else if (cpi->oxcf.lag_in_frames > MAX_LAG_BUFFERS) {\n    cpi->oxcf.lag_in_frames = MAX_LAG_BUFFERS;\n  }\n\n  /* YX Temp */\n  cpi->alt_ref_source = NULL;\n  cpi->is_src_frame_alt_ref = 0;\n\n#if CONFIG_TEMPORAL_DENOISING\n  if (cpi->oxcf.noise_sensitivity) {\n    if (!cpi->denoiser.yv12_mc_running_avg.buffer_alloc) {\n      int width = (cpi->oxcf.Width + 15) & ~15;\n      int height = (cpi->oxcf.Height + 15) & ~15;\n      if (vp8_denoiser_allocate(&cpi->denoiser, width, height, cm->mb_rows,\n                                cm->mb_cols, cpi->oxcf.noise_sensitivity)) {\n        vpx_internal_error(&cpi->common.error, VPX_CODEC_MEM_ERROR,\n                           \"Failed to allocate denoiser\");\n      }\n    }\n  }\n#endif\n\n#if 0\n    /* Experimental RD Code */\n    cpi->frame_distortion = 0;\n    cpi->last_frame_distortion = 0;\n#endif\n}\n\n#ifndef M_LOG2_E\n#define M_LOG2_E 0.693147180559945309417\n#endif\n#define log2f(x) (log(x) / (float)M_LOG2_E)\n\nstatic void cal_mvsadcosts(int *mvsadcost[2]) {\n  int i = 1;\n\n  mvsadcost[0][0] = 300;\n  mvsadcost[1][0] = 300;\n\n  do {\n    double z = 256 * (2 * (log2f(8 * i) + .6));\n    mvsadcost[0][i] = (int)z;\n    mvsadcost[1][i] = (int)z;\n    mvsadcost[0][-i] = (int)z;\n    mvsadcost[1][-i] = (int)z;\n  } while (++i <= mvfp_max);\n}\n\nstruct VP8_COMP *vp8_create_compressor(VP8_CONFIG *oxcf) {\n  int i;\n\n  VP8_COMP *cpi;\n  VP8_COMMON *cm;\n\n  cpi = vpx_memalign(32, sizeof(VP8_COMP));\n  /* Check that the CPI instance is valid */\n  if (!cpi) return 0;\n\n  cm = &cpi->common;\n\n  memset(cpi, 0, sizeof(VP8_COMP));\n\n  if (setjmp(cm->error.jmp)) {\n    cpi->common.error.setjmp = 0;\n    vp8_remove_compressor(&cpi);\n    return 0;\n  }\n\n  cpi->common.error.setjmp = 1;\n\n  CHECK_MEM_ERROR(\n      &cpi->common.error, cpi->mb.ss,\n      vpx_calloc(sizeof(search_site), (MAX_MVSEARCH_STEPS * 8) + 1));\n\n  vp8_create_common(&cpi->common);\n\n  init_config(cpi, oxcf);\n\n  memcpy(cpi->base_skip_false_prob, vp8cx_base_skip_false_prob,\n         sizeof(vp8cx_base_skip_false_prob));\n  cpi->common.current_video_frame = 0;\n  cpi->temporal_pattern_counter = 0;\n  cpi->temporal_layer_id = -1;\n  cpi->kf_overspend_bits = 0;\n  cpi->kf_bitrate_adjustment = 0;\n  cpi->frames_till_gf_update_due = 0;\n  cpi->gf_overspend_bits = 0;\n  cpi->non_gf_bitrate_adjustment = 0;\n  cpi->prob_last_coded = 128;\n  cpi->prob_gf_coded = 128;\n  cpi->prob_intra_coded = 63;\n\n  /* Prime the recent reference frame usage counters.\n   * Hereafter they will be maintained as a sort of moving average\n   */\n  cpi->recent_ref_frame_usage[INTRA_FRAME] = 1;\n  cpi->recent_ref_frame_usage[LAST_FRAME] = 1;\n  cpi->recent_ref_frame_usage[GOLDEN_FRAME] = 1;\n  cpi->recent_ref_frame_usage[ALTREF_FRAME] = 1;\n\n  /* Set reference frame sign bias for ALTREF frame to 1 (for now) */\n  cpi->common.ref_frame_sign_bias[ALTREF_FRAME] = 1;\n\n  cpi->twopass.gf_decay_rate = 0;\n  cpi->baseline_gf_interval = DEFAULT_GF_INTERVAL;\n\n  cpi->gold_is_last = 0;\n  cpi->alt_is_last = 0;\n  cpi->gold_is_alt = 0;\n\n  cpi->active_map_enabled = 0;\n\n  cpi->use_roi_static_threshold = 0;\n\n#if 0\n    /* Experimental code for lagged and one pass */\n    /* Initialise one_pass GF frames stats */\n    /* Update stats used for GF selection */\n    if (cpi->pass == 0)\n    {\n        cpi->one_pass_frame_index = 0;\n\n        for (i = 0; i < MAX_LAG_BUFFERS; ++i)\n        {\n            cpi->one_pass_frame_stats[i].frames_so_far = 0;\n            cpi->one_pass_frame_stats[i].frame_intra_error = 0.0;\n            cpi->one_pass_frame_stats[i].frame_coded_error = 0.0;\n            cpi->one_pass_frame_stats[i].frame_pcnt_inter = 0.0;\n            cpi->one_pass_frame_stats[i].frame_pcnt_motion = 0.0;\n            cpi->one_pass_frame_stats[i].frame_mvr = 0.0;\n            cpi->one_pass_frame_stats[i].frame_mvr_abs = 0.0;\n            cpi->one_pass_frame_stats[i].frame_mvc = 0.0;\n            cpi->one_pass_frame_stats[i].frame_mvc_abs = 0.0;\n        }\n    }\n#endif\n\n  cpi->mse_source_denoised = 0;\n\n  /* Should we use the cyclic refresh method.\n   * Currently there is no external control for this.\n   * Enable it for error_resilient_mode, or for 1 pass CBR mode.\n   */\n  cpi->cyclic_refresh_mode_enabled =\n      (cpi->oxcf.error_resilient_mode ||\n       (cpi->oxcf.end_usage == USAGE_STREAM_FROM_SERVER &&\n        cpi->oxcf.Mode <= 2));\n  cpi->cyclic_refresh_mode_max_mbs_perframe =\n      (cpi->common.mb_rows * cpi->common.mb_cols) / 7;\n  if (cpi->oxcf.number_of_layers == 1) {\n    cpi->cyclic_refresh_mode_max_mbs_perframe =\n        (cpi->common.mb_rows * cpi->common.mb_cols) / 20;\n  } else if (cpi->oxcf.number_of_layers == 2) {\n    cpi->cyclic_refresh_mode_max_mbs_perframe =\n        (cpi->common.mb_rows * cpi->common.mb_cols) / 10;\n  }\n  cpi->cyclic_refresh_mode_index = 0;\n  cpi->cyclic_refresh_q = 32;\n\n  // GF behavior for 1 pass CBR, used when error_resilience is off.\n  cpi->gf_update_onepass_cbr = 0;\n  cpi->gf_noboost_onepass_cbr = 0;\n  if (!cpi->oxcf.error_resilient_mode &&\n      cpi->oxcf.end_usage == USAGE_STREAM_FROM_SERVER && cpi->oxcf.Mode <= 2) {\n    cpi->gf_update_onepass_cbr = 1;\n    cpi->gf_noboost_onepass_cbr = 1;\n    cpi->gf_interval_onepass_cbr =\n        cpi->cyclic_refresh_mode_max_mbs_perframe > 0\n            ? (2 * (cpi->common.mb_rows * cpi->common.mb_cols) /\n               cpi->cyclic_refresh_mode_max_mbs_perframe)\n            : 10;\n    cpi->gf_interval_onepass_cbr =\n        VPXMIN(40, VPXMAX(6, cpi->gf_interval_onepass_cbr));\n    cpi->baseline_gf_interval = cpi->gf_interval_onepass_cbr;\n  }\n\n  if (cpi->cyclic_refresh_mode_enabled) {\n    CHECK_MEM_ERROR(&cpi->common.error, cpi->cyclic_refresh_map,\n                    vpx_calloc((cpi->common.mb_rows * cpi->common.mb_cols), 1));\n  } else {\n    cpi->cyclic_refresh_map = (signed char *)NULL;\n  }\n\n  CHECK_MEM_ERROR(\n      &cpi->common.error, cpi->skin_map,\n      vpx_calloc(cm->mb_rows * cm->mb_cols, sizeof(cpi->skin_map[0])));\n\n  CHECK_MEM_ERROR(&cpi->common.error, cpi->consec_zero_last,\n                  vpx_calloc(cm->mb_rows * cm->mb_cols, 1));\n  CHECK_MEM_ERROR(&cpi->common.error, cpi->consec_zero_last_mvbias,\n                  vpx_calloc((cpi->common.mb_rows * cpi->common.mb_cols), 1));\n\n  /*Initialize the feed-forward activity masking.*/\n  cpi->activity_avg = 90 << 12;\n\n  /* Give a sensible default for the first frame. */\n  cpi->frames_since_key = 8;\n  cpi->key_frame_frequency = cpi->oxcf.key_freq;\n  cpi->this_key_frame_forced = 0;\n  cpi->next_key_frame_forced = 0;\n\n  cpi->source_alt_ref_pending = 0;\n  cpi->source_alt_ref_active = 0;\n  cpi->common.refresh_alt_ref_frame = 0;\n\n  cpi->force_maxqp = 0;\n  cpi->frames_since_last_drop_overshoot = 0;\n  cpi->rt_always_update_correction_factor = 0;\n\n  cpi->b_calculate_psnr = CONFIG_INTERNAL_STATS;\n#if CONFIG_INTERNAL_STATS\n  cpi->b_calculate_ssimg = 0;\n\n  cpi->count = 0;\n  cpi->bytes = 0;\n\n  if (cpi->b_calculate_psnr) {\n    cpi->total_sq_error = 0.0;\n    cpi->total_sq_error2 = 0.0;\n    cpi->total_y = 0.0;\n    cpi->total_u = 0.0;\n    cpi->total_v = 0.0;\n    cpi->total = 0.0;\n    cpi->totalp_y = 0.0;\n    cpi->totalp_u = 0.0;\n    cpi->totalp_v = 0.0;\n    cpi->totalp = 0.0;\n    cpi->tot_recode_hits = 0;\n    cpi->summed_quality = 0;\n    cpi->summed_weights = 0;\n  }\n\n#endif\n\n  cpi->first_time_stamp_ever = 0x7FFFFFFF;\n\n  cpi->frames_till_gf_update_due = 0;\n  cpi->key_frame_count = 1;\n\n  cpi->ni_av_qi = cpi->oxcf.worst_allowed_q;\n  cpi->ni_tot_qi = 0;\n  cpi->ni_frames = 0;\n  cpi->total_byte_count = 0;\n\n  cpi->drop_frame = 0;\n\n  cpi->rate_correction_factor = 1.0;\n  cpi->key_frame_rate_correction_factor = 1.0;\n  cpi->gf_rate_correction_factor = 1.0;\n  cpi->twopass.est_max_qcorrection_factor = 1.0;\n\n  for (i = 0; i < KEY_FRAME_CONTEXT; ++i) {\n    cpi->prior_key_frame_distance[i] = (int)cpi->output_framerate;\n  }\n\n#ifdef OUTPUT_YUV_SRC\n  yuv_file = fopen(\"bd.yuv\", \"ab\");\n#endif\n#ifdef OUTPUT_YUV_DENOISED\n  yuv_denoised_file = fopen(\"denoised.yuv\", \"ab\");\n#endif\n#ifdef OUTPUT_YUV_SKINMAP\n  yuv_skinmap_file = fopen(\"skinmap.yuv\", \"wb\");\n#endif\n\n#if 0\n    framepsnr = fopen(\"framepsnr.stt\", \"a\");\n    kf_list = fopen(\"kf_list.stt\", \"w\");\n#endif\n\n  cpi->output_pkt_list = oxcf->output_pkt_list;\n\n#if !CONFIG_REALTIME_ONLY\n\n  if (cpi->pass == 1) {\n    vp8_init_first_pass(cpi);\n  } else if (cpi->pass == 2) {\n    size_t packet_sz = sizeof(FIRSTPASS_STATS);\n    int packets = (int)(oxcf->two_pass_stats_in.sz / packet_sz);\n\n    cpi->twopass.stats_in_start = oxcf->two_pass_stats_in.buf;\n    cpi->twopass.stats_in = cpi->twopass.stats_in_start;\n    cpi->twopass.stats_in_end =\n        (void *)((char *)cpi->twopass.stats_in + (packets - 1) * packet_sz);\n    vp8_init_second_pass(cpi);\n  }\n\n#endif\n\n  if (cpi->compressor_speed == 2) {\n    cpi->avg_encode_time = 0;\n    cpi->avg_pick_mode_time = 0;\n  }\n\n  vp8_set_speed_features(cpi);\n\n  /* Set starting values of RD threshold multipliers (128 = *1) */\n  for (i = 0; i < MAX_MODES; ++i) {\n    cpi->mb.rd_thresh_mult[i] = 128;\n  }\n\n#if CONFIG_MULTITHREAD\n  if (vp8cx_create_encoder_threads(cpi)) {\n    vp8_remove_compressor(&cpi);\n    return 0;\n  }\n#endif\n\n  cpi->fn_ptr[BLOCK_16X16].sdf = vpx_sad16x16;\n  cpi->fn_ptr[BLOCK_16X16].vf = vpx_variance16x16;\n  cpi->fn_ptr[BLOCK_16X16].svf = vpx_sub_pixel_variance16x16;\n  cpi->fn_ptr[BLOCK_16X16].sdx4df = vpx_sad16x16x4d;\n\n  cpi->fn_ptr[BLOCK_16X8].sdf = vpx_sad16x8;\n  cpi->fn_ptr[BLOCK_16X8].vf = vpx_variance16x8;\n  cpi->fn_ptr[BLOCK_16X8].svf = vpx_sub_pixel_variance16x8;\n  cpi->fn_ptr[BLOCK_16X8].sdx4df = vpx_sad16x8x4d;\n\n  cpi->fn_ptr[BLOCK_8X16].sdf = vpx_sad8x16;\n  cpi->fn_ptr[BLOCK_8X16].vf = vpx_variance8x16;\n  cpi->fn_ptr[BLOCK_8X16].svf = vpx_sub_pixel_variance8x16;\n  cpi->fn_ptr[BLOCK_8X16].sdx4df = vpx_sad8x16x4d;\n\n  cpi->fn_ptr[BLOCK_8X8].sdf = vpx_sad8x8;\n  cpi->fn_ptr[BLOCK_8X8].vf = vpx_variance8x8;\n  cpi->fn_ptr[BLOCK_8X8].svf = vpx_sub_pixel_variance8x8;\n  cpi->fn_ptr[BLOCK_8X8].sdx4df = vpx_sad8x8x4d;\n\n  cpi->fn_ptr[BLOCK_4X4].sdf = vpx_sad4x4;\n  cpi->fn_ptr[BLOCK_4X4].vf = vpx_variance4x4;\n  cpi->fn_ptr[BLOCK_4X4].svf = vpx_sub_pixel_variance4x4;\n  cpi->fn_ptr[BLOCK_4X4].sdx4df = vpx_sad4x4x4d;\n\n#if VPX_ARCH_X86 || VPX_ARCH_X86_64\n  cpi->fn_ptr[BLOCK_16X16].copymem = vp8_copy32xn;\n  cpi->fn_ptr[BLOCK_16X8].copymem = vp8_copy32xn;\n  cpi->fn_ptr[BLOCK_8X16].copymem = vp8_copy32xn;\n  cpi->fn_ptr[BLOCK_8X8].copymem = vp8_copy32xn;\n  cpi->fn_ptr[BLOCK_4X4].copymem = vp8_copy32xn;\n#endif\n\n  cpi->diamond_search_sad = vp8_diamond_search_sad;\n  cpi->refining_search_sad = vp8_refining_search_sad;\n\n  /* make sure frame 1 is okay */\n  cpi->mb.error_bins[0] = cpi->common.MBs;\n\n  /* vp8cx_init_quantizer() is first called here. Add check in\n   * vp8cx_frame_init_quantizer() so that vp8cx_init_quantizer is only\n   * called later when needed. This will avoid unnecessary calls of\n   * vp8cx_init_quantizer() for every frame.\n   */\n  vp8cx_init_quantizer(cpi);\n\n  vp8_loop_filter_init(cm);\n\n  cpi->common.error.setjmp = 0;\n\n#if CONFIG_MULTI_RES_ENCODING\n\n  /* Calculate # of MBs in a row in lower-resolution level image. */\n  if (cpi->oxcf.mr_encoder_id > 0) vp8_cal_low_res_mb_cols(cpi);\n\n#endif\n\n  /* setup RD costs to MACROBLOCK struct */\n\n  cpi->mb.mvcost[0] = &cpi->rd_costs.mvcosts[0][mv_max + 1];\n  cpi->mb.mvcost[1] = &cpi->rd_costs.mvcosts[1][mv_max + 1];\n  cpi->mb.mvsadcost[0] = &cpi->rd_costs.mvsadcosts[0][mvfp_max + 1];\n  cpi->mb.mvsadcost[1] = &cpi->rd_costs.mvsadcosts[1][mvfp_max + 1];\n\n  cal_mvsadcosts(cpi->mb.mvsadcost);\n\n  cpi->mb.mbmode_cost = cpi->rd_costs.mbmode_cost;\n  cpi->mb.intra_uv_mode_cost = cpi->rd_costs.intra_uv_mode_cost;\n  cpi->mb.bmode_costs = cpi->rd_costs.bmode_costs;\n  cpi->mb.inter_bmode_costs = cpi->rd_costs.inter_bmode_costs;\n  cpi->mb.token_costs = cpi->rd_costs.token_costs;\n\n  /* setup block ptrs & offsets */\n  vp8_setup_block_ptrs(&cpi->mb);\n  vp8_setup_block_dptrs(&cpi->mb.e_mbd);\n\n  return cpi;\n}\n\nvoid vp8_remove_compressor(VP8_COMP **comp) {\n  VP8_COMP *cpi = *comp;\n\n  if (!cpi) return;\n\n  if (cpi && (cpi->common.current_video_frame > 0)) {\n#if !CONFIG_REALTIME_ONLY\n\n    if (cpi->pass == 2) {\n      vp8_end_second_pass(cpi);\n    }\n\n#endif\n\n#if CONFIG_INTERNAL_STATS\n\n    if (cpi->pass != 1) {\n      FILE *f = fopen(\"opsnr.stt\", \"a\");\n      double time_encoded =\n          (cpi->last_end_time_stamp_seen - cpi->first_time_stamp_ever) /\n          10000000.000;\n\n      if (cpi->b_calculate_psnr) {\n        if (cpi->oxcf.number_of_layers > 1) {\n          int i;\n\n          fprintf(f,\n                  \"Layer\\tBitrate\\tAVGPsnr\\tGLBPsnr\\tAVPsnrP\\t\"\n                  \"GLPsnrP\\tVPXSSIM\\n\");\n          for (i = 0; i < (int)cpi->oxcf.number_of_layers; ++i) {\n            double dr =\n                (double)cpi->bytes_in_layer[i] * 8.0 / 1000.0 / time_encoded;\n            double samples = 3.0 / 2 * cpi->frames_in_layer[i] *\n                             cpi->common.Width * cpi->common.Height;\n            double total_psnr =\n                vpx_sse_to_psnr(samples, 255.0, cpi->total_error2[i]);\n            double total_psnr2 =\n                vpx_sse_to_psnr(samples, 255.0, cpi->total_error2_p[i]);\n            double total_ssim =\n                100 * pow(cpi->sum_ssim[i] / cpi->sum_weights[i], 8.0);\n\n            fprintf(f,\n                    \"%5d\\t%7.3f\\t%7.3f\\t%7.3f\\t%7.3f\\t\"\n                    \"%7.3f\\t%7.3f\\n\",\n                    i, dr, cpi->sum_psnr[i] / cpi->frames_in_layer[i],\n                    total_psnr, cpi->sum_psnr_p[i] / cpi->frames_in_layer[i],\n                    total_psnr2, total_ssim);\n          }\n        } else {\n          double dr = (double)cpi->bytes * 8.0 / 1000.0 / time_encoded;\n          double samples =\n              3.0 / 2 * cpi->count * cpi->common.Width * cpi->common.Height;\n          double total_psnr =\n              vpx_sse_to_psnr(samples, 255.0, cpi->total_sq_error);\n          double total_psnr2 =\n              vpx_sse_to_psnr(samples, 255.0, cpi->total_sq_error2);\n          double total_ssim =\n              100 * pow(cpi->summed_quality / cpi->summed_weights, 8.0);\n\n          fprintf(f,\n                  \"Bitrate\\tAVGPsnr\\tGLBPsnr\\tAVPsnrP\\t\"\n                  \"GLPsnrP\\tVPXSSIM\\n\");\n          fprintf(f,\n                  \"%7.3f\\t%7.3f\\t%7.3f\\t%7.3f\\t%7.3f\\t\"\n                  \"%7.3f\\n\",\n                  dr, cpi->total / cpi->count, total_psnr,\n                  cpi->totalp / cpi->count, total_psnr2, total_ssim);\n        }\n      }\n      fclose(f);\n#if 0\n            f = fopen(\"qskip.stt\", \"a\");\n            fprintf(f, \"minq:%d -maxq:%d skiptrue:skipfalse = %d:%d\\n\", cpi->oxcf.best_allowed_q, cpi->oxcf.worst_allowed_q, skiptruecount, skipfalsecount);\n            fclose(f);\n#endif\n    }\n\n#endif\n\n#ifdef SPEEDSTATS\n\n    if (cpi->compressor_speed == 2) {\n      int i;\n      FILE *f = fopen(\"cxspeed.stt\", \"a\");\n      cnt_pm /= cpi->common.MBs;\n\n      for (i = 0; i < 16; ++i) fprintf(f, \"%5d\", frames_at_speed[i]);\n\n      fprintf(f, \"\\n\");\n      fclose(f);\n    }\n\n#endif\n\n#ifdef MODE_STATS\n    {\n      extern int count_mb_seg[4];\n      FILE *f = fopen(\"modes.stt\", \"a\");\n      double dr = (double)cpi->framerate * (double)bytes * (double)8 /\n                  (double)count / (double)1000;\n      fprintf(f, \"intra_mode in Intra Frames:\\n\");\n      fprintf(f, \"Y: %8d, %8d, %8d, %8d, %8d\\n\", y_modes[0], y_modes[1],\n              y_modes[2], y_modes[3], y_modes[4]);\n      fprintf(f, \"UV:%8d, %8d, %8d, %8d\\n\", uv_modes[0], uv_modes[1],\n              uv_modes[2], uv_modes[3]);\n      fprintf(f, \"B: \");\n      {\n        int i;\n\n        for (i = 0; i < 10; ++i) fprintf(f, \"%8d, \", b_modes[i]);\n\n        fprintf(f, \"\\n\");\n      }\n\n      fprintf(f, \"Modes in Inter Frames:\\n\");\n      fprintf(f, \"Y: %8d, %8d, %8d, %8d, %8d, %8d, %8d, %8d, %8d, %8d\\n\",\n              inter_y_modes[0], inter_y_modes[1], inter_y_modes[2],\n              inter_y_modes[3], inter_y_modes[4], inter_y_modes[5],\n              inter_y_modes[6], inter_y_modes[7], inter_y_modes[8],\n              inter_y_modes[9]);\n      fprintf(f, \"UV:%8d, %8d, %8d, %8d\\n\", inter_uv_modes[0],\n              inter_uv_modes[1], inter_uv_modes[2], inter_uv_modes[3]);\n      fprintf(f, \"B: \");\n      {\n        int i;\n\n        for (i = 0; i < 15; ++i) fprintf(f, \"%8d, \", inter_b_modes[i]);\n\n        fprintf(f, \"\\n\");\n      }\n      fprintf(f, \"P:%8d, %8d, %8d, %8d\\n\", count_mb_seg[0], count_mb_seg[1],\n              count_mb_seg[2], count_mb_seg[3]);\n      fprintf(f, \"PB:%8d, %8d, %8d, %8d\\n\", inter_b_modes[LEFT4X4],\n              inter_b_modes[ABOVE4X4], inter_b_modes[ZERO4X4],\n              inter_b_modes[NEW4X4]);\n\n      fclose(f);\n    }\n#endif\n\n#if defined(SECTIONBITS_OUTPUT)\n\n    if (0) {\n      int i;\n      FILE *f = fopen(\"tokenbits.stt\", \"a\");\n\n      for (i = 0; i < 28; ++i) fprintf(f, \"%8d\", (int)(Sectionbits[i] / 256));\n\n      fprintf(f, \"\\n\");\n      fclose(f);\n    }\n\n#endif\n\n#if 0\n        {\n            printf(\"\\n_pick_loop_filter_level:%d\\n\", cpi->time_pick_lpf / 1000);\n            printf(\"\\n_frames receive_data encod_mb_row compress_frame  Total\\n\");\n            printf(\"%6d %10ld %10ld %10ld %10ld\\n\", cpi->common.current_video_frame, cpi->time_receive_data / 1000, cpi->time_encode_mb_row / 1000, cpi->time_compress_data / 1000, (cpi->time_receive_data + cpi->time_compress_data) / 1000);\n        }\n#endif\n  }\n\n#if CONFIG_MULTITHREAD\n  vp8cx_remove_encoder_threads(cpi);\n#endif\n\n#if CONFIG_TEMPORAL_DENOISING\n  vp8_denoiser_free(&cpi->denoiser);\n#endif\n  dealloc_compressor_data(cpi);\n  vpx_free(cpi->mb.ss);\n  vpx_free(cpi->tok);\n  vpx_free(cpi->skin_map);\n  vpx_free(cpi->cyclic_refresh_map);\n  vpx_free(cpi->consec_zero_last);\n  vpx_free(cpi->consec_zero_last_mvbias);\n\n  vp8_remove_common(&cpi->common);\n  vpx_free(cpi);\n  *comp = 0;\n\n#ifdef OUTPUT_YUV_SRC\n  fclose(yuv_file);\n#endif\n#ifdef OUTPUT_YUV_DENOISED\n  fclose(yuv_denoised_file);\n#endif\n#ifdef OUTPUT_YUV_SKINMAP\n  fclose(yuv_skinmap_file);\n#endif\n\n#if 0\n\n    if (keyfile)\n        fclose(keyfile);\n\n    if (framepsnr)\n        fclose(framepsnr);\n\n    if (kf_list)\n        fclose(kf_list);\n\n#endif\n}\n\nstatic uint64_t calc_plane_error(unsigned char *orig, int orig_stride,\n                                 unsigned char *recon, int recon_stride,\n                                 unsigned int cols, unsigned int rows) {\n  unsigned int row, col;\n  uint64_t total_sse = 0;\n  int diff;\n\n  for (row = 0; row + 16 <= rows; row += 16) {\n    for (col = 0; col + 16 <= cols; col += 16) {\n      unsigned int sse;\n\n      vpx_mse16x16(orig + col, orig_stride, recon + col, recon_stride, &sse);\n      total_sse += sse;\n    }\n\n    /* Handle odd-sized width */\n    if (col < cols) {\n      unsigned int border_row, border_col;\n      unsigned char *border_orig = orig;\n      unsigned char *border_recon = recon;\n\n      for (border_row = 0; border_row < 16; ++border_row) {\n        for (border_col = col; border_col < cols; ++border_col) {\n          diff = border_orig[border_col] - border_recon[border_col];\n          total_sse += diff * diff;\n        }\n\n        border_orig += orig_stride;\n        border_recon += recon_stride;\n      }\n    }\n\n    orig += orig_stride * 16;\n    recon += recon_stride * 16;\n  }\n\n  /* Handle odd-sized height */\n  for (; row < rows; ++row) {\n    for (col = 0; col < cols; ++col) {\n      diff = orig[col] - recon[col];\n      total_sse += diff * diff;\n    }\n\n    orig += orig_stride;\n    recon += recon_stride;\n  }\n\n  vpx_clear_system_state();\n  return total_sse;\n}\n\nstatic void generate_psnr_packet(VP8_COMP *cpi) {\n  YV12_BUFFER_CONFIG *orig = cpi->Source;\n  YV12_BUFFER_CONFIG *recon = cpi->common.frame_to_show;\n  struct vpx_codec_cx_pkt pkt;\n  uint64_t sse;\n  int i;\n  unsigned int width = cpi->common.Width;\n  unsigned int height = cpi->common.Height;\n\n  pkt.kind = VPX_CODEC_PSNR_PKT;\n  sse = calc_plane_error(orig->y_buffer, orig->y_stride, recon->y_buffer,\n                         recon->y_stride, width, height);\n  pkt.data.psnr.sse[0] = sse;\n  pkt.data.psnr.sse[1] = sse;\n  pkt.data.psnr.samples[0] = width * height;\n  pkt.data.psnr.samples[1] = width * height;\n\n  width = (width + 1) / 2;\n  height = (height + 1) / 2;\n\n  sse = calc_plane_error(orig->u_buffer, orig->uv_stride, recon->u_buffer,\n                         recon->uv_stride, width, height);\n  pkt.data.psnr.sse[0] += sse;\n  pkt.data.psnr.sse[2] = sse;\n  pkt.data.psnr.samples[0] += width * height;\n  pkt.data.psnr.samples[2] = width * height;\n\n  sse = calc_plane_error(orig->v_buffer, orig->uv_stride, recon->v_buffer,\n                         recon->uv_stride, width, height);\n  pkt.data.psnr.sse[0] += sse;\n  pkt.data.psnr.sse[3] = sse;\n  pkt.data.psnr.samples[0] += width * height;\n  pkt.data.psnr.samples[3] = width * height;\n\n  for (i = 0; i < 4; ++i) {\n    pkt.data.psnr.psnr[i] = vpx_sse_to_psnr(pkt.data.psnr.samples[i], 255.0,\n                                            (double)(pkt.data.psnr.sse[i]));\n  }\n\n  vpx_codec_pkt_list_add(cpi->output_pkt_list, &pkt);\n}\n\nint vp8_use_as_reference(VP8_COMP *cpi, int ref_frame_flags) {\n  if (ref_frame_flags > 7) return -1;\n\n  cpi->ref_frame_flags = ref_frame_flags;\n  return 0;\n}\nint vp8_update_reference(VP8_COMP *cpi, int ref_frame_flags) {\n  if (ref_frame_flags > 7) return -1;\n\n  cpi->common.refresh_golden_frame = 0;\n  cpi->common.refresh_alt_ref_frame = 0;\n  cpi->common.refresh_last_frame = 0;\n\n  if (ref_frame_flags & VP8_LAST_FRAME) cpi->common.refresh_last_frame = 1;\n\n  if (ref_frame_flags & VP8_GOLD_FRAME) cpi->common.refresh_golden_frame = 1;\n\n  if (ref_frame_flags & VP8_ALTR_FRAME) cpi->common.refresh_alt_ref_frame = 1;\n\n  cpi->ext_refresh_frame_flags_pending = 1;\n  return 0;\n}\n\nint vp8_get_reference(VP8_COMP *cpi, enum vpx_ref_frame_type ref_frame_flag,\n                      YV12_BUFFER_CONFIG *sd) {\n  VP8_COMMON *cm = &cpi->common;\n  int ref_fb_idx;\n\n  if (ref_frame_flag == VP8_LAST_FRAME) {\n    ref_fb_idx = cm->lst_fb_idx;\n  } else if (ref_frame_flag == VP8_GOLD_FRAME) {\n    ref_fb_idx = cm->gld_fb_idx;\n  } else if (ref_frame_flag == VP8_ALTR_FRAME) {\n    ref_fb_idx = cm->alt_fb_idx;\n  } else {\n    return -1;\n  }\n\n  vp8_yv12_copy_frame(&cm->yv12_fb[ref_fb_idx], sd);\n\n  return 0;\n}\nint vp8_set_reference(VP8_COMP *cpi, enum vpx_ref_frame_type ref_frame_flag,\n                      YV12_BUFFER_CONFIG *sd) {\n  VP8_COMMON *cm = &cpi->common;\n\n  int ref_fb_idx;\n\n  if (ref_frame_flag == VP8_LAST_FRAME) {\n    ref_fb_idx = cm->lst_fb_idx;\n  } else if (ref_frame_flag == VP8_GOLD_FRAME) {\n    ref_fb_idx = cm->gld_fb_idx;\n  } else if (ref_frame_flag == VP8_ALTR_FRAME) {\n    ref_fb_idx = cm->alt_fb_idx;\n  } else {\n    return -1;\n  }\n\n  vp8_yv12_copy_frame(sd, &cm->yv12_fb[ref_fb_idx]);\n\n  return 0;\n}\nint vp8_update_entropy(VP8_COMP *cpi, int update) {\n  VP8_COMMON *cm = &cpi->common;\n  cm->refresh_entropy_probs = update;\n\n  return 0;\n}\n\nstatic void scale_and_extend_source(YV12_BUFFER_CONFIG *sd, VP8_COMP *cpi) {\n  VP8_COMMON *cm = &cpi->common;\n\n  /* are we resizing the image */\n  if (cm->horiz_scale != 0 || cm->vert_scale != 0) {\n#if CONFIG_SPATIAL_RESAMPLING\n    int hr, hs, vr, vs;\n    int tmp_height;\n\n    if (cm->vert_scale == 3) {\n      tmp_height = 9;\n    } else {\n      tmp_height = 11;\n    }\n\n    Scale2Ratio(cm->horiz_scale, &hr, &hs);\n    Scale2Ratio(cm->vert_scale, &vr, &vs);\n\n    vpx_scale_frame(sd, &cpi->scaled_source, cm->temp_scale_frame.y_buffer,\n                    tmp_height, hs, hr, vs, vr, 0);\n\n    vp8_yv12_extend_frame_borders(&cpi->scaled_source);\n    cpi->Source = &cpi->scaled_source;\n#endif\n  } else {\n    cpi->Source = sd;\n  }\n}\n\nstatic int resize_key_frame(VP8_COMP *cpi) {\n#if CONFIG_SPATIAL_RESAMPLING\n  VP8_COMMON *cm = &cpi->common;\n\n  /* Do we need to apply resampling for one pass cbr.\n   * In one pass this is more limited than in two pass cbr.\n   * The test and any change is only made once per key frame sequence.\n   */\n  if (cpi->oxcf.allow_spatial_resampling &&\n      (cpi->oxcf.end_usage == USAGE_STREAM_FROM_SERVER)) {\n    int hr, hs, vr, vs;\n    int new_width, new_height;\n\n    /* If we are below the resample DOWN watermark then scale down a\n     * notch.\n     */\n    if (cpi->buffer_level < (cpi->oxcf.resample_down_water_mark *\n                             cpi->oxcf.optimal_buffer_level / 100)) {\n      cm->horiz_scale =\n          (cm->horiz_scale < VP8E_ONETWO) ? cm->horiz_scale + 1 : VP8E_ONETWO;\n      cm->vert_scale =\n          (cm->vert_scale < VP8E_ONETWO) ? cm->vert_scale + 1 : VP8E_ONETWO;\n    }\n    /* Should we now start scaling back up */\n    else if (cpi->buffer_level > (cpi->oxcf.resample_up_water_mark *\n                                  cpi->oxcf.optimal_buffer_level / 100)) {\n      cm->horiz_scale =\n          (cm->horiz_scale > VP8E_NORMAL) ? cm->horiz_scale - 1 : VP8E_NORMAL;\n      cm->vert_scale =\n          (cm->vert_scale > VP8E_NORMAL) ? cm->vert_scale - 1 : VP8E_NORMAL;\n    }\n\n    /* Get the new height and width */\n    Scale2Ratio(cm->horiz_scale, &hr, &hs);\n    Scale2Ratio(cm->vert_scale, &vr, &vs);\n    new_width = ((hs - 1) + (cpi->oxcf.Width * hr)) / hs;\n    new_height = ((vs - 1) + (cpi->oxcf.Height * vr)) / vs;\n\n    /* If the image size has changed we need to reallocate the buffers\n     * and resample the source image\n     */\n    if ((cm->Width != new_width) || (cm->Height != new_height)) {\n      cm->Width = new_width;\n      cm->Height = new_height;\n      vp8_alloc_compressor_data(cpi);\n      scale_and_extend_source(cpi->un_scaled_source, cpi);\n      return 1;\n    }\n  }\n\n#endif\n  return 0;\n}\n\nstatic void update_alt_ref_frame_stats(VP8_COMP *cpi) {\n  VP8_COMMON *cm = &cpi->common;\n\n  /* Select an interval before next GF or altref */\n  if (!cpi->auto_gold) cpi->frames_till_gf_update_due = DEFAULT_GF_INTERVAL;\n\n  if ((cpi->pass != 2) && cpi->frames_till_gf_update_due) {\n    cpi->current_gf_interval = cpi->frames_till_gf_update_due;\n\n    /* Set the bits per frame that we should try and recover in\n     * subsequent inter frames to account for the extra GF spend...\n     * note that his does not apply for GF updates that occur\n     * coincident with a key frame as the extra cost of key frames is\n     * dealt with elsewhere.\n     */\n    cpi->gf_overspend_bits += cpi->projected_frame_size;\n    cpi->non_gf_bitrate_adjustment =\n        cpi->gf_overspend_bits / cpi->frames_till_gf_update_due;\n  }\n\n  /* Update data structure that monitors level of reference to last GF */\n  memset(cpi->gf_active_flags, 1, (cm->mb_rows * cm->mb_cols));\n  cpi->gf_active_count = cm->mb_rows * cm->mb_cols;\n\n  /* this frame refreshes means next frames don't unless specified by user */\n  cpi->frames_since_golden = 0;\n\n  /* Clear the alternate reference update pending flag. */\n  cpi->source_alt_ref_pending = 0;\n\n  /* Set the alternate reference frame active flag */\n  cpi->source_alt_ref_active = 1;\n}\nstatic void update_golden_frame_stats(VP8_COMP *cpi) {\n  VP8_COMMON *cm = &cpi->common;\n\n  /* Update the Golden frame usage counts. */\n  if (cm->refresh_golden_frame) {\n    /* Select an interval before next GF */\n    if (!cpi->auto_gold) cpi->frames_till_gf_update_due = DEFAULT_GF_INTERVAL;\n\n    if ((cpi->pass != 2) && (cpi->frames_till_gf_update_due > 0)) {\n      cpi->current_gf_interval = cpi->frames_till_gf_update_due;\n\n      /* Set the bits per frame that we should try and recover in\n       * subsequent inter frames to account for the extra GF spend...\n       * note that his does not apply for GF updates that occur\n       * coincident with a key frame as the extra cost of key frames\n       * is dealt with elsewhere.\n       */\n      if ((cm->frame_type != KEY_FRAME) && !cpi->source_alt_ref_active) {\n        /* Calcluate GF bits to be recovered\n         * Projected size - av frame bits available for inter\n         * frames for clip as a whole\n         */\n        cpi->gf_overspend_bits +=\n            (cpi->projected_frame_size - cpi->inter_frame_target);\n      }\n\n      cpi->non_gf_bitrate_adjustment =\n          cpi->gf_overspend_bits / cpi->frames_till_gf_update_due;\n    }\n\n    /* Update data structure that monitors level of reference to last GF */\n    memset(cpi->gf_active_flags, 1, (cm->mb_rows * cm->mb_cols));\n    cpi->gf_active_count = cm->mb_rows * cm->mb_cols;\n\n    /* this frame refreshes means next frames don't unless specified by\n     * user\n     */\n    cm->refresh_golden_frame = 0;\n    cpi->frames_since_golden = 0;\n\n    cpi->recent_ref_frame_usage[INTRA_FRAME] = 1;\n    cpi->recent_ref_frame_usage[LAST_FRAME] = 1;\n    cpi->recent_ref_frame_usage[GOLDEN_FRAME] = 1;\n    cpi->recent_ref_frame_usage[ALTREF_FRAME] = 1;\n\n    /* ******** Fixed Q test code only ************ */\n    /* If we are going to use the ALT reference for the next group of\n     * frames set a flag to say so.\n     */\n    if (cpi->oxcf.fixed_q >= 0 && cpi->oxcf.play_alternate &&\n        !cpi->common.refresh_alt_ref_frame) {\n      cpi->source_alt_ref_pending = 1;\n      cpi->frames_till_gf_update_due = cpi->baseline_gf_interval;\n    }\n\n    if (!cpi->source_alt_ref_pending) cpi->source_alt_ref_active = 0;\n\n    /* Decrement count down till next gf */\n    if (cpi->frames_till_gf_update_due > 0) cpi->frames_till_gf_update_due--;\n\n  } else if (!cpi->common.refresh_alt_ref_frame) {\n    /* Decrement count down till next gf */\n    if (cpi->frames_till_gf_update_due > 0) cpi->frames_till_gf_update_due--;\n\n    if (cpi->frames_till_alt_ref_frame) cpi->frames_till_alt_ref_frame--;\n\n    cpi->frames_since_golden++;\n\n    if (cpi->frames_since_golden > 1) {\n      cpi->recent_ref_frame_usage[INTRA_FRAME] +=\n          cpi->mb.count_mb_ref_frame_usage[INTRA_FRAME];\n      cpi->recent_ref_frame_usage[LAST_FRAME] +=\n          cpi->mb.count_mb_ref_frame_usage[LAST_FRAME];\n      cpi->recent_ref_frame_usage[GOLDEN_FRAME] +=\n          cpi->mb.count_mb_ref_frame_usage[GOLDEN_FRAME];\n      cpi->recent_ref_frame_usage[ALTREF_FRAME] +=\n          cpi->mb.count_mb_ref_frame_usage[ALTREF_FRAME];\n    }\n  }\n}\n\n/* This function updates the reference frame probability estimates that\n * will be used during mode selection\n */\nstatic void update_rd_ref_frame_probs(VP8_COMP *cpi) {\n  VP8_COMMON *cm = &cpi->common;\n\n  const int *const rfct = cpi->mb.count_mb_ref_frame_usage;\n  const int rf_intra = rfct[INTRA_FRAME];\n  const int rf_inter =\n      rfct[LAST_FRAME] + rfct[GOLDEN_FRAME] + rfct[ALTREF_FRAME];\n\n  if (cm->frame_type == KEY_FRAME) {\n    cpi->prob_intra_coded = 255;\n    cpi->prob_last_coded = 128;\n    cpi->prob_gf_coded = 128;\n  } else if (!(rf_intra + rf_inter)) {\n    cpi->prob_intra_coded = 63;\n    cpi->prob_last_coded = 128;\n    cpi->prob_gf_coded = 128;\n  }\n\n  /* update reference frame costs since we can do better than what we got\n   * last frame.\n   */\n  if (cpi->oxcf.number_of_layers == 1) {\n    if (cpi->common.refresh_alt_ref_frame) {\n      cpi->prob_intra_coded += 40;\n      if (cpi->prob_intra_coded > 255) cpi->prob_intra_coded = 255;\n      cpi->prob_last_coded = 200;\n      cpi->prob_gf_coded = 1;\n    } else if (cpi->frames_since_golden == 0) {\n      cpi->prob_last_coded = 214;\n    } else if (cpi->frames_since_golden == 1) {\n      cpi->prob_last_coded = 192;\n      cpi->prob_gf_coded = 220;\n    } else if (cpi->source_alt_ref_active) {\n      cpi->prob_gf_coded -= 20;\n\n      if (cpi->prob_gf_coded < 10) cpi->prob_gf_coded = 10;\n    }\n    if (!cpi->source_alt_ref_active) cpi->prob_gf_coded = 255;\n  }\n}\n\n#if !CONFIG_REALTIME_ONLY\n/* 1 = key, 0 = inter */\nstatic int decide_key_frame(VP8_COMP *cpi) {\n  VP8_COMMON *cm = &cpi->common;\n\n  int code_key_frame = 0;\n\n  cpi->kf_boost = 0;\n\n  if (cpi->Speed > 11) return 0;\n\n  /* Clear down mmx registers */\n  vpx_clear_system_state();\n\n  if ((cpi->compressor_speed == 2) && (cpi->Speed >= 5) && (cpi->sf.RD == 0)) {\n    double change = 1.0 *\n                    abs((int)(cpi->mb.intra_error - cpi->last_intra_error)) /\n                    (1 + cpi->last_intra_error);\n    double change2 =\n        1.0 *\n        abs((int)(cpi->mb.prediction_error - cpi->last_prediction_error)) /\n        (1 + cpi->last_prediction_error);\n    double minerror = cm->MBs * 256;\n\n    cpi->last_intra_error = cpi->mb.intra_error;\n    cpi->last_prediction_error = cpi->mb.prediction_error;\n\n    if (10 * cpi->mb.intra_error / (1 + cpi->mb.prediction_error) < 15 &&\n        cpi->mb.prediction_error > minerror &&\n        (change > .25 || change2 > .25)) {\n      /*(change > 1.4 || change < .75)&& cpi->this_frame_percent_intra >\n       * cpi->last_frame_percent_intra + 3*/\n      return 1;\n    }\n\n    return 0;\n  }\n\n  /* If the following are true we might as well code a key frame */\n  if (((cpi->this_frame_percent_intra == 100) &&\n       (cpi->this_frame_percent_intra > (cpi->last_frame_percent_intra + 2))) ||\n      ((cpi->this_frame_percent_intra > 95) &&\n       (cpi->this_frame_percent_intra >=\n        (cpi->last_frame_percent_intra + 5)))) {\n    code_key_frame = 1;\n  }\n  /* in addition if the following are true and this is not a golden frame\n   * then code a key frame Note that on golden frames there often seems\n   * to be a pop in intra usage anyway hence this restriction is\n   * designed to prevent spurious key frames. The Intra pop needs to be\n   * investigated.\n   */\n  else if (((cpi->this_frame_percent_intra > 60) &&\n            (cpi->this_frame_percent_intra >\n             (cpi->last_frame_percent_intra * 2))) ||\n           ((cpi->this_frame_percent_intra > 75) &&\n            (cpi->this_frame_percent_intra >\n             (cpi->last_frame_percent_intra * 3 / 2))) ||\n           ((cpi->this_frame_percent_intra > 90) &&\n            (cpi->this_frame_percent_intra >\n             (cpi->last_frame_percent_intra + 10)))) {\n    if (!cm->refresh_golden_frame) code_key_frame = 1;\n  }\n\n  return code_key_frame;\n}\n\nstatic void Pass1Encode(VP8_COMP *cpi) {\n  vp8_set_quantizer(cpi, 26);\n  vp8_first_pass(cpi);\n}\n#endif\n\n#if 0\nvoid write_cx_frame_to_file(YV12_BUFFER_CONFIG *frame, int this_frame)\n{\n\n    /* write the frame */\n    FILE *yframe;\n    int i;\n    char filename[255];\n\n    sprintf(filename, \"cx\\\\y%04d.raw\", this_frame);\n    yframe = fopen(filename, \"wb\");\n\n    for (i = 0; i < frame->y_height; ++i)\n        fwrite(frame->y_buffer + i * frame->y_stride, frame->y_width, 1, yframe);\n\n    fclose(yframe);\n    sprintf(filename, \"cx\\\\u%04d.raw\", this_frame);\n    yframe = fopen(filename, \"wb\");\n\n    for (i = 0; i < frame->uv_height; ++i)\n        fwrite(frame->u_buffer + i * frame->uv_stride, frame->uv_width, 1, yframe);\n\n    fclose(yframe);\n    sprintf(filename, \"cx\\\\v%04d.raw\", this_frame);\n    yframe = fopen(filename, \"wb\");\n\n    for (i = 0; i < frame->uv_height; ++i)\n        fwrite(frame->v_buffer + i * frame->uv_stride, frame->uv_width, 1, yframe);\n\n    fclose(yframe);\n}\n#endif\n\n#if !CONFIG_REALTIME_ONLY\n/* Function to test for conditions that indeicate we should loop\n * back and recode a frame.\n */\nstatic int recode_loop_test(VP8_COMP *cpi, int high_limit, int low_limit, int q,\n                            int maxq, int minq) {\n  int force_recode = 0;\n  VP8_COMMON *cm = &cpi->common;\n\n  /* Is frame recode allowed at all\n   * Yes if either recode mode 1 is selected or mode two is selcted\n   * and the frame is a key frame. golden frame or alt_ref_frame\n   */\n  if ((cpi->sf.recode_loop == 1) ||\n      ((cpi->sf.recode_loop == 2) &&\n       ((cm->frame_type == KEY_FRAME) || cm->refresh_golden_frame ||\n        cm->refresh_alt_ref_frame))) {\n    /* General over and under shoot tests */\n    if (((cpi->projected_frame_size > high_limit) && (q < maxq)) ||\n        ((cpi->projected_frame_size < low_limit) && (q > minq))) {\n      force_recode = 1;\n    }\n    /* Special Constrained quality tests */\n    else if (cpi->oxcf.end_usage == USAGE_CONSTRAINED_QUALITY) {\n      /* Undershoot and below auto cq level */\n      if ((q > cpi->cq_target_quality) &&\n          (cpi->projected_frame_size < ((cpi->this_frame_target * 7) >> 3))) {\n        force_recode = 1;\n      }\n      /* Severe undershoot and between auto and user cq level */\n      else if ((q > cpi->oxcf.cq_level) &&\n               (cpi->projected_frame_size < cpi->min_frame_bandwidth) &&\n               (cpi->active_best_quality > cpi->oxcf.cq_level)) {\n        force_recode = 1;\n        cpi->active_best_quality = cpi->oxcf.cq_level;\n      }\n    }\n  }\n\n  return force_recode;\n}\n#endif  // !CONFIG_REALTIME_ONLY\n\nstatic void update_reference_frames(VP8_COMP *cpi) {\n  VP8_COMMON *cm = &cpi->common;\n  YV12_BUFFER_CONFIG *yv12_fb = cm->yv12_fb;\n\n  /* At this point the new frame has been encoded.\n   * If any buffer copy / swapping is signaled it should be done here.\n   */\n\n  if (cm->frame_type == KEY_FRAME) {\n    yv12_fb[cm->new_fb_idx].flags |= VP8_GOLD_FRAME | VP8_ALTR_FRAME;\n\n    yv12_fb[cm->gld_fb_idx].flags &= ~VP8_GOLD_FRAME;\n    yv12_fb[cm->alt_fb_idx].flags &= ~VP8_ALTR_FRAME;\n\n    cm->alt_fb_idx = cm->gld_fb_idx = cm->new_fb_idx;\n\n    cpi->current_ref_frames[GOLDEN_FRAME] = cm->current_video_frame;\n    cpi->current_ref_frames[ALTREF_FRAME] = cm->current_video_frame;\n  } else {\n    if (cm->refresh_alt_ref_frame) {\n      assert(!cm->copy_buffer_to_arf);\n\n      cm->yv12_fb[cm->new_fb_idx].flags |= VP8_ALTR_FRAME;\n      cm->yv12_fb[cm->alt_fb_idx].flags &= ~VP8_ALTR_FRAME;\n      cm->alt_fb_idx = cm->new_fb_idx;\n\n      cpi->current_ref_frames[ALTREF_FRAME] = cm->current_video_frame;\n    } else if (cm->copy_buffer_to_arf) {\n      assert(!(cm->copy_buffer_to_arf & ~0x3));\n\n      if (cm->copy_buffer_to_arf == 1) {\n        if (cm->alt_fb_idx != cm->lst_fb_idx) {\n          yv12_fb[cm->lst_fb_idx].flags |= VP8_ALTR_FRAME;\n          yv12_fb[cm->alt_fb_idx].flags &= ~VP8_ALTR_FRAME;\n          cm->alt_fb_idx = cm->lst_fb_idx;\n\n          cpi->current_ref_frames[ALTREF_FRAME] =\n              cpi->current_ref_frames[LAST_FRAME];\n        }\n      } else {\n        if (cm->alt_fb_idx != cm->gld_fb_idx) {\n          yv12_fb[cm->gld_fb_idx].flags |= VP8_ALTR_FRAME;\n          yv12_fb[cm->alt_fb_idx].flags &= ~VP8_ALTR_FRAME;\n          cm->alt_fb_idx = cm->gld_fb_idx;\n\n          cpi->current_ref_frames[ALTREF_FRAME] =\n              cpi->current_ref_frames[GOLDEN_FRAME];\n        }\n      }\n    }\n\n    if (cm->refresh_golden_frame) {\n      assert(!cm->copy_buffer_to_gf);\n\n      cm->yv12_fb[cm->new_fb_idx].flags |= VP8_GOLD_FRAME;\n      cm->yv12_fb[cm->gld_fb_idx].flags &= ~VP8_GOLD_FRAME;\n      cm->gld_fb_idx = cm->new_fb_idx;\n\n      cpi->current_ref_frames[GOLDEN_FRAME] = cm->current_video_frame;\n    } else if (cm->copy_buffer_to_gf) {\n      assert(!(cm->copy_buffer_to_arf & ~0x3));\n\n      if (cm->copy_buffer_to_gf == 1) {\n        if (cm->gld_fb_idx != cm->lst_fb_idx) {\n          yv12_fb[cm->lst_fb_idx].flags |= VP8_GOLD_FRAME;\n          yv12_fb[cm->gld_fb_idx].flags &= ~VP8_GOLD_FRAME;\n          cm->gld_fb_idx = cm->lst_fb_idx;\n\n          cpi->current_ref_frames[GOLDEN_FRAME] =\n              cpi->current_ref_frames[LAST_FRAME];\n        }\n      } else {\n        if (cm->alt_fb_idx != cm->gld_fb_idx) {\n          yv12_fb[cm->alt_fb_idx].flags |= VP8_GOLD_FRAME;\n          yv12_fb[cm->gld_fb_idx].flags &= ~VP8_GOLD_FRAME;\n          cm->gld_fb_idx = cm->alt_fb_idx;\n\n          cpi->current_ref_frames[GOLDEN_FRAME] =\n              cpi->current_ref_frames[ALTREF_FRAME];\n        }\n      }\n    }\n  }\n\n  if (cm->refresh_last_frame) {\n    cm->yv12_fb[cm->new_fb_idx].flags |= VP8_LAST_FRAME;\n    cm->yv12_fb[cm->lst_fb_idx].flags &= ~VP8_LAST_FRAME;\n    cm->lst_fb_idx = cm->new_fb_idx;\n\n    cpi->current_ref_frames[LAST_FRAME] = cm->current_video_frame;\n  }\n\n#if CONFIG_TEMPORAL_DENOISING\n  if (cpi->oxcf.noise_sensitivity) {\n    /* we shouldn't have to keep multiple copies as we know in advance which\n     * buffer we should start - for now to get something up and running\n     * I've chosen to copy the buffers\n     */\n    if (cm->frame_type == KEY_FRAME) {\n      int i;\n      for (i = LAST_FRAME; i < MAX_REF_FRAMES; ++i)\n        vp8_yv12_copy_frame(cpi->Source, &cpi->denoiser.yv12_running_avg[i]);\n    } else {\n      vp8_yv12_extend_frame_borders(\n          &cpi->denoiser.yv12_running_avg[INTRA_FRAME]);\n\n      if (cm->refresh_alt_ref_frame || cm->copy_buffer_to_arf) {\n        vp8_yv12_copy_frame(&cpi->denoiser.yv12_running_avg[INTRA_FRAME],\n                            &cpi->denoiser.yv12_running_avg[ALTREF_FRAME]);\n      }\n      if (cm->refresh_golden_frame || cm->copy_buffer_to_gf) {\n        vp8_yv12_copy_frame(&cpi->denoiser.yv12_running_avg[INTRA_FRAME],\n                            &cpi->denoiser.yv12_running_avg[GOLDEN_FRAME]);\n      }\n      if (cm->refresh_last_frame) {\n        vp8_yv12_copy_frame(&cpi->denoiser.yv12_running_avg[INTRA_FRAME],\n                            &cpi->denoiser.yv12_running_avg[LAST_FRAME]);\n      }\n    }\n    if (cpi->oxcf.noise_sensitivity == 4)\n      vp8_yv12_copy_frame(cpi->Source, &cpi->denoiser.yv12_last_source);\n  }\n#endif\n}\n\nstatic int measure_square_diff_partial(YV12_BUFFER_CONFIG *source,\n                                       YV12_BUFFER_CONFIG *dest,\n                                       VP8_COMP *cpi) {\n  int i, j;\n  int Total = 0;\n  int num_blocks = 0;\n  int skip = 2;\n  int min_consec_zero_last = 10;\n  int tot_num_blocks = (source->y_height * source->y_width) >> 8;\n  unsigned char *src = source->y_buffer;\n  unsigned char *dst = dest->y_buffer;\n\n  /* Loop through the Y plane, every |skip| blocks along rows and colmumns,\n   * summing the square differences, and only for blocks that have been\n   * zero_last mode at least |x| frames in a row.\n   */\n  for (i = 0; i < source->y_height; i += 16 * skip) {\n    int block_index_row = (i >> 4) * cpi->common.mb_cols;\n    for (j = 0; j < source->y_width; j += 16 * skip) {\n      int index = block_index_row + (j >> 4);\n      if (cpi->consec_zero_last[index] >= min_consec_zero_last) {\n        unsigned int sse;\n        Total += vpx_mse16x16(src + j, source->y_stride, dst + j,\n                              dest->y_stride, &sse);\n        num_blocks++;\n      }\n    }\n    src += 16 * skip * source->y_stride;\n    dst += 16 * skip * dest->y_stride;\n  }\n  // Only return non-zero if we have at least ~1/16 samples for estimate.\n  if (num_blocks > (tot_num_blocks >> 4)) {\n    assert(num_blocks != 0);\n    return (Total / num_blocks);\n  } else {\n    return 0;\n  }\n}\n\n#if CONFIG_TEMPORAL_DENOISING\nstatic void process_denoiser_mode_change(VP8_COMP *cpi) {\n  const VP8_COMMON *const cm = &cpi->common;\n  int i, j;\n  int total = 0;\n  int num_blocks = 0;\n  // Number of blocks skipped along row/column in computing the\n  // nmse (normalized mean square error) of source.\n  int skip = 2;\n  // Only select blocks for computing nmse that have been encoded\n  // as ZERO LAST min_consec_zero_last frames in a row.\n  // Scale with number of temporal layers.\n  int min_consec_zero_last = 12 / cpi->oxcf.number_of_layers;\n  // Decision is tested for changing the denoising mode every\n  // num_mode_change times this function is called. Note that this\n  // function called every 8 frames, so (8 * num_mode_change) is number\n  // of frames where denoising mode change is tested for switch.\n  int num_mode_change = 20;\n  // Framerate factor, to compensate for larger mse at lower framerates.\n  // Use ref_framerate, which is full source framerate for temporal layers.\n  // TODO(marpan): Adjust this factor.\n  int fac_framerate = cpi->ref_framerate < 25.0f ? 80 : 100;\n  int tot_num_blocks = cm->mb_rows * cm->mb_cols;\n  int ystride = cpi->Source->y_stride;\n  unsigned char *src = cpi->Source->y_buffer;\n  unsigned char *dst = cpi->denoiser.yv12_last_source.y_buffer;\n  static const unsigned char const_source[16] = { 128, 128, 128, 128, 128, 128,\n                                                  128, 128, 128, 128, 128, 128,\n                                                  128, 128, 128, 128 };\n  int bandwidth = (int)(cpi->target_bandwidth);\n  // For temporal layers, use full bandwidth (top layer).\n  if (cpi->oxcf.number_of_layers > 1) {\n    LAYER_CONTEXT *lc = &cpi->layer_context[cpi->oxcf.number_of_layers - 1];\n    bandwidth = (int)(lc->target_bandwidth);\n  }\n  // Loop through the Y plane, every skip blocks along rows and columns,\n  // summing the normalized mean square error, only for blocks that have\n  // been encoded as ZEROMV LAST at least min_consec_zero_last least frames in\n  // a row and have small sum difference between current and previous frame.\n  // Normalization here is by the contrast of the current frame block.\n  for (i = 0; i < cm->Height; i += 16 * skip) {\n    int block_index_row = (i >> 4) * cm->mb_cols;\n    for (j = 0; j < cm->Width; j += 16 * skip) {\n      int index = block_index_row + (j >> 4);\n      if (cpi->consec_zero_last[index] >= min_consec_zero_last) {\n        unsigned int sse;\n        const unsigned int var =\n            vpx_variance16x16(src + j, ystride, dst + j, ystride, &sse);\n        // Only consider this block as valid for noise measurement\n        // if the sum_diff average of the current and previous frame\n        // is small (to avoid effects from lighting change).\n        if ((sse - var) < 128) {\n          unsigned int sse2;\n          const unsigned int act =\n              vpx_variance16x16(src + j, ystride, const_source, 0, &sse2);\n          if (act > 0) total += sse / act;\n          num_blocks++;\n        }\n      }\n    }\n    src += 16 * skip * ystride;\n    dst += 16 * skip * ystride;\n  }\n  total = total * fac_framerate / 100;\n\n  // Only consider this frame as valid sample if we have computed nmse over\n  // at least ~1/16 blocks, and Total > 0 (Total == 0 can happen if the\n  // application inputs duplicate frames, or contrast is all zero).\n  if (total > 0 && (num_blocks > (tot_num_blocks >> 4))) {\n    // Update the recursive mean square source_diff.\n    total = (total << 8) / num_blocks;\n    if (cpi->denoiser.nmse_source_diff_count == 0) {\n      // First sample in new interval.\n      cpi->denoiser.nmse_source_diff = total;\n      cpi->denoiser.qp_avg = cm->base_qindex;\n    } else {\n      // For subsequent samples, use average with weight ~1/4 for new sample.\n      cpi->denoiser.nmse_source_diff =\n          (int)((total + 3 * cpi->denoiser.nmse_source_diff) >> 2);\n      cpi->denoiser.qp_avg =\n          (int)((cm->base_qindex + 3 * cpi->denoiser.qp_avg) >> 2);\n    }\n    cpi->denoiser.nmse_source_diff_count++;\n  }\n  // Check for changing the denoiser mode, when we have obtained #samples =\n  // num_mode_change. Condition the change also on the bitrate and QP.\n  if (cpi->denoiser.nmse_source_diff_count == num_mode_change) {\n    // Check for going up: from normal to aggressive mode.\n    if ((cpi->denoiser.denoiser_mode == kDenoiserOnYUV) &&\n        (cpi->denoiser.nmse_source_diff >\n         cpi->denoiser.threshold_aggressive_mode) &&\n        (cpi->denoiser.qp_avg < cpi->denoiser.qp_threshold_up &&\n         bandwidth > cpi->denoiser.bitrate_threshold)) {\n      vp8_denoiser_set_parameters(&cpi->denoiser, kDenoiserOnYUVAggressive);\n    } else {\n      // Check for going down: from aggressive to normal mode.\n      if (((cpi->denoiser.denoiser_mode == kDenoiserOnYUVAggressive) &&\n           (cpi->denoiser.nmse_source_diff <\n            cpi->denoiser.threshold_aggressive_mode)) ||\n          ((cpi->denoiser.denoiser_mode == kDenoiserOnYUVAggressive) &&\n           (cpi->denoiser.qp_avg > cpi->denoiser.qp_threshold_down ||\n            bandwidth < cpi->denoiser.bitrate_threshold))) {\n        vp8_denoiser_set_parameters(&cpi->denoiser, kDenoiserOnYUV);\n      }\n    }\n    // Reset metric and counter for next interval.\n    cpi->denoiser.nmse_source_diff = 0;\n    cpi->denoiser.qp_avg = 0;\n    cpi->denoiser.nmse_source_diff_count = 0;\n  }\n}\n#endif\n\nvoid vp8_loopfilter_frame(VP8_COMP *cpi, VP8_COMMON *cm) {\n  const FRAME_TYPE frame_type = cm->frame_type;\n\n  int update_any_ref_buffers = 1;\n  if (cpi->common.refresh_last_frame == 0 &&\n      cpi->common.refresh_golden_frame == 0 &&\n      cpi->common.refresh_alt_ref_frame == 0) {\n    update_any_ref_buffers = 0;\n  }\n\n  if (cm->no_lpf) {\n    cm->filter_level = 0;\n  } else {\n    struct vpx_usec_timer timer;\n\n    vpx_clear_system_state();\n\n    vpx_usec_timer_start(&timer);\n    if (cpi->sf.auto_filter == 0) {\n#if CONFIG_TEMPORAL_DENOISING\n      if (cpi->oxcf.noise_sensitivity && cm->frame_type != KEY_FRAME) {\n        // Use the denoised buffer for selecting base loop filter level.\n        // Denoised signal for current frame is stored in INTRA_FRAME.\n        // No denoising on key frames.\n        vp8cx_pick_filter_level_fast(\n            &cpi->denoiser.yv12_running_avg[INTRA_FRAME], cpi);\n      } else {\n        vp8cx_pick_filter_level_fast(cpi->Source, cpi);\n      }\n#else\n      vp8cx_pick_filter_level_fast(cpi->Source, cpi);\n#endif\n    } else {\n#if CONFIG_TEMPORAL_DENOISING\n      if (cpi->oxcf.noise_sensitivity && cm->frame_type != KEY_FRAME) {\n        // Use the denoised buffer for selecting base loop filter level.\n        // Denoised signal for current frame is stored in INTRA_FRAME.\n        // No denoising on key frames.\n        vp8cx_pick_filter_level(&cpi->denoiser.yv12_running_avg[INTRA_FRAME],\n                                cpi);\n      } else {\n        vp8cx_pick_filter_level(cpi->Source, cpi);\n      }\n#else\n      vp8cx_pick_filter_level(cpi->Source, cpi);\n#endif\n    }\n\n    if (cm->filter_level > 0) {\n      vp8cx_set_alt_lf_level(cpi, cm->filter_level);\n    }\n\n    vpx_usec_timer_mark(&timer);\n    cpi->time_pick_lpf += vpx_usec_timer_elapsed(&timer);\n  }\n\n#if CONFIG_MULTITHREAD\n  if (vpx_atomic_load_acquire(&cpi->b_multi_threaded)) {\n    sem_post(&cpi->h_event_end_lpf); /* signal that we have set filter_level */\n  }\n#endif\n\n  // No need to apply loop-filter if the encoded frame does not update\n  // any reference buffers.\n  if (cm->filter_level > 0 && update_any_ref_buffers) {\n    vp8_loop_filter_frame(cm, &cpi->mb.e_mbd, frame_type);\n  }\n\n  vp8_yv12_extend_frame_borders(cm->frame_to_show);\n}\n\nstatic void encode_frame_to_data_rate(VP8_COMP *cpi, size_t *size,\n                                      unsigned char *dest,\n                                      unsigned char *dest_end,\n                                      unsigned int *frame_flags) {\n  int Q;\n  int frame_over_shoot_limit;\n  int frame_under_shoot_limit;\n\n  int Loop = 0;\n\n  VP8_COMMON *cm = &cpi->common;\n  int active_worst_qchanged = 0;\n\n#if !CONFIG_REALTIME_ONLY\n  int q_low;\n  int q_high;\n  int zbin_oq_high;\n  int zbin_oq_low = 0;\n  int top_index;\n  int bottom_index;\n  int overshoot_seen = 0;\n  int undershoot_seen = 0;\n#endif\n\n  int drop_mark = (int)(cpi->oxcf.drop_frames_water_mark *\n                        cpi->oxcf.optimal_buffer_level / 100);\n  int drop_mark75 = drop_mark * 2 / 3;\n  int drop_mark50 = drop_mark / 4;\n  int drop_mark25 = drop_mark / 8;\n\n  /* Clear down mmx registers to allow floating point in what follows */\n  vpx_clear_system_state();\n\n  if (cpi->force_next_frame_intra) {\n    cm->frame_type = KEY_FRAME; /* delayed intra frame */\n    cpi->force_next_frame_intra = 0;\n  }\n\n  /* For an alt ref frame in 2 pass we skip the call to the second pass\n   * function that sets the target bandwidth\n   */\n  switch (cpi->pass) {\n#if !CONFIG_REALTIME_ONLY\n    case 2:\n      if (cpi->common.refresh_alt_ref_frame) {\n        /* Per frame bit target for the alt ref frame */\n        cpi->per_frame_bandwidth = cpi->twopass.gf_bits;\n        /* per second target bitrate */\n        cpi->target_bandwidth =\n            (int)(cpi->twopass.gf_bits * cpi->output_framerate);\n      }\n      break;\n#endif  // !CONFIG_REALTIME_ONLY\n    default:\n      cpi->per_frame_bandwidth =\n          (int)round(cpi->target_bandwidth / cpi->output_framerate);\n      break;\n  }\n\n  /* Default turn off buffer to buffer copying */\n  cm->copy_buffer_to_gf = 0;\n  cm->copy_buffer_to_arf = 0;\n\n  /* Clear zbin over-quant value and mode boost values. */\n  cpi->mb.zbin_over_quant = 0;\n  cpi->mb.zbin_mode_boost = 0;\n\n  /* Enable or disable mode based tweaking of the zbin\n   * For 2 Pass Only used where GF/ARF prediction quality\n   * is above a threshold\n   */\n  cpi->mb.zbin_mode_boost_enabled = 1;\n  if (cpi->pass == 2) {\n    if (cpi->gfu_boost <= 400) {\n      cpi->mb.zbin_mode_boost_enabled = 0;\n    }\n  }\n\n  /* Current default encoder behaviour for the altref sign bias */\n  if (cpi->source_alt_ref_active) {\n    cpi->common.ref_frame_sign_bias[ALTREF_FRAME] = 1;\n  } else {\n    cpi->common.ref_frame_sign_bias[ALTREF_FRAME] = 0;\n  }\n\n  /* Check to see if a key frame is signaled\n   * For two pass with auto key frame enabled cm->frame_type may already\n   * be set, but not for one pass.\n   */\n  if ((cm->current_video_frame == 0) || (cm->frame_flags & FRAMEFLAGS_KEY) ||\n      (cpi->oxcf.auto_key &&\n       (cpi->frames_since_key % cpi->key_frame_frequency == 0))) {\n    /* Key frame from VFW/auto-keyframe/first frame */\n    cm->frame_type = KEY_FRAME;\n#if CONFIG_TEMPORAL_DENOISING\n    if (cpi->oxcf.noise_sensitivity == 4) {\n      // For adaptive mode, reset denoiser to normal mode on key frame.\n      vp8_denoiser_set_parameters(&cpi->denoiser, kDenoiserOnYUV);\n    }\n#endif\n  }\n\n#if CONFIG_MULTI_RES_ENCODING\n  if (cpi->oxcf.mr_total_resolutions > 1) {\n    LOWER_RES_FRAME_INFO *low_res_frame_info =\n        (LOWER_RES_FRAME_INFO *)cpi->oxcf.mr_low_res_mode_info;\n\n    if (cpi->oxcf.mr_encoder_id) {\n      // Check if lower resolution is available for motion vector reuse.\n      if (cm->frame_type != KEY_FRAME) {\n        cpi->mr_low_res_mv_avail = 1;\n        cpi->mr_low_res_mv_avail &= !(low_res_frame_info->is_frame_dropped);\n\n        if (cpi->ref_frame_flags & VP8_LAST_FRAME)\n          cpi->mr_low_res_mv_avail &=\n              (cpi->current_ref_frames[LAST_FRAME] ==\n               low_res_frame_info->low_res_ref_frames[LAST_FRAME]);\n\n        if (cpi->ref_frame_flags & VP8_GOLD_FRAME)\n          cpi->mr_low_res_mv_avail &=\n              (cpi->current_ref_frames[GOLDEN_FRAME] ==\n               low_res_frame_info->low_res_ref_frames[GOLDEN_FRAME]);\n\n        // Don't use altref to determine whether low res is available.\n        // TODO (marpan): Should we make this type of condition on a\n        // per-reference frame basis?\n        /*\n        if (cpi->ref_frame_flags & VP8_ALTR_FRAME)\n            cpi->mr_low_res_mv_avail &= (cpi->current_ref_frames[ALTREF_FRAME]\n                     == low_res_frame_info->low_res_ref_frames[ALTREF_FRAME]);\n        */\n      }\n      // Disable motion vector reuse (i.e., disable any usage of the low_res)\n      // if the previous lower stream is skipped/disabled.\n      if (low_res_frame_info->skip_encoding_prev_stream) {\n        cpi->mr_low_res_mv_avail = 0;\n      }\n    }\n    // This stream is not skipped (i.e., it's being encoded), so set this skip\n    // flag to 0. This is needed for the next stream (i.e., which is the next\n    // frame to be encoded).\n    low_res_frame_info->skip_encoding_prev_stream = 0;\n\n    // On a key frame: For the lowest resolution, keep track of the key frame\n    // counter value. For the higher resolutions, reset the current video\n    // frame counter to that of the lowest resolution.\n    // This is done to the handle the case where we may stop/start encoding\n    // higher layer(s). The restart-encoding of higher layer is only signaled\n    // by a key frame for now.\n    // TODO (marpan): Add flag to indicate restart-encoding of higher layer.\n    if (cm->frame_type == KEY_FRAME) {\n      if (cpi->oxcf.mr_encoder_id) {\n        // If the initial starting value of the buffer level is zero (this can\n        // happen because we may have not started encoding this higher stream),\n        // then reset it to non-zero value based on |starting_buffer_level|.\n        if (cpi->common.current_video_frame == 0 && cpi->buffer_level == 0) {\n          unsigned int i;\n          cpi->bits_off_target = cpi->oxcf.starting_buffer_level;\n          cpi->buffer_level = cpi->oxcf.starting_buffer_level;\n          for (i = 0; i < cpi->oxcf.number_of_layers; ++i) {\n            LAYER_CONTEXT *lc = &cpi->layer_context[i];\n            lc->bits_off_target = lc->starting_buffer_level;\n            lc->buffer_level = lc->starting_buffer_level;\n          }\n        }\n        cpi->common.current_video_frame =\n            low_res_frame_info->key_frame_counter_value;\n      } else {\n        low_res_frame_info->key_frame_counter_value =\n            cpi->common.current_video_frame;\n      }\n    }\n  }\n#endif\n\n  // Find the reference frame closest to the current frame.\n  cpi->closest_reference_frame = LAST_FRAME;\n  if (cm->frame_type != KEY_FRAME) {\n    int i;\n    MV_REFERENCE_FRAME closest_ref = INTRA_FRAME;\n    if (cpi->ref_frame_flags & VP8_LAST_FRAME) {\n      closest_ref = LAST_FRAME;\n    } else if (cpi->ref_frame_flags & VP8_GOLD_FRAME) {\n      closest_ref = GOLDEN_FRAME;\n    } else if (cpi->ref_frame_flags & VP8_ALTR_FRAME) {\n      closest_ref = ALTREF_FRAME;\n    }\n    for (i = 1; i <= 3; ++i) {\n      vpx_ref_frame_type_t ref_frame_type =\n          (vpx_ref_frame_type_t)((i == 3) ? 4 : i);\n      if (cpi->ref_frame_flags & ref_frame_type) {\n        if ((cm->current_video_frame - cpi->current_ref_frames[i]) <\n            (cm->current_video_frame - cpi->current_ref_frames[closest_ref])) {\n          closest_ref = i;\n        }\n      }\n    }\n    cpi->closest_reference_frame = closest_ref;\n  }\n\n  /* Set various flags etc to special state if it is a key frame */\n  if (cm->frame_type == KEY_FRAME) {\n    int i;\n\n    // Set the loop filter deltas and segmentation map update\n    setup_features(cpi);\n\n    /* The alternate reference frame cannot be active for a key frame */\n    cpi->source_alt_ref_active = 0;\n\n    /* Reset the RD threshold multipliers to default of * 1 (128) */\n    for (i = 0; i < MAX_MODES; ++i) {\n      cpi->mb.rd_thresh_mult[i] = 128;\n    }\n\n    // Reset the zero_last counter to 0 on key frame.\n    memset(cpi->consec_zero_last, 0, cm->mb_rows * cm->mb_cols);\n    memset(cpi->consec_zero_last_mvbias, 0,\n           (cpi->common.mb_rows * cpi->common.mb_cols));\n  }\n\n#if 0\n    /* Experimental code for lagged compress and one pass\n     * Initialise one_pass GF frames stats\n     * Update stats used for GF selection\n     */\n    {\n        cpi->one_pass_frame_index = cm->current_video_frame % MAX_LAG_BUFFERS;\n\n        cpi->one_pass_frame_stats[cpi->one_pass_frame_index ].frames_so_far = 0;\n        cpi->one_pass_frame_stats[cpi->one_pass_frame_index ].frame_intra_error = 0.0;\n        cpi->one_pass_frame_stats[cpi->one_pass_frame_index ].frame_coded_error = 0.0;\n        cpi->one_pass_frame_stats[cpi->one_pass_frame_index ].frame_pcnt_inter = 0.0;\n        cpi->one_pass_frame_stats[cpi->one_pass_frame_index ].frame_pcnt_motion = 0.0;\n        cpi->one_pass_frame_stats[cpi->one_pass_frame_index ].frame_mvr = 0.0;\n        cpi->one_pass_frame_stats[cpi->one_pass_frame_index ].frame_mvr_abs = 0.0;\n        cpi->one_pass_frame_stats[cpi->one_pass_frame_index ].frame_mvc = 0.0;\n        cpi->one_pass_frame_stats[cpi->one_pass_frame_index ].frame_mvc_abs = 0.0;\n    }\n#endif\n\n  update_rd_ref_frame_probs(cpi);\n\n  if (cpi->drop_frames_allowed) {\n    /* The reset to decimation 0 is only done here for one pass.\n     * Once it is set two pass leaves decimation on till the next kf.\n     */\n    if ((cpi->buffer_level > drop_mark) && (cpi->decimation_factor > 0)) {\n      cpi->decimation_factor--;\n    }\n\n    if (cpi->buffer_level > drop_mark75 && cpi->decimation_factor > 0) {\n      cpi->decimation_factor = 1;\n\n    } else if (cpi->buffer_level < drop_mark25 &&\n               (cpi->decimation_factor == 2 || cpi->decimation_factor == 3)) {\n      cpi->decimation_factor = 3;\n    } else if (cpi->buffer_level < drop_mark50 &&\n               (cpi->decimation_factor == 1 || cpi->decimation_factor == 2)) {\n      cpi->decimation_factor = 2;\n    } else if (cpi->buffer_level < drop_mark75 &&\n               (cpi->decimation_factor == 0 || cpi->decimation_factor == 1)) {\n      cpi->decimation_factor = 1;\n    }\n  }\n\n  /* The following decimates the frame rate according to a regular\n   * pattern (i.e. to 1/2 or 2/3 frame rate) This can be used to help\n   * prevent buffer under-run in CBR mode. Alternatively it might be\n   * desirable in some situations to drop frame rate but throw more bits\n   * at each frame.\n   *\n   * Note that dropping a key frame can be problematic if spatial\n   * resampling is also active\n   */\n  if (cpi->decimation_factor > 0 && cpi->drop_frames_allowed) {\n    switch (cpi->decimation_factor) {\n      case 1:\n        cpi->per_frame_bandwidth = cpi->per_frame_bandwidth * 3 / 2;\n        break;\n      case 2:\n        cpi->per_frame_bandwidth = cpi->per_frame_bandwidth * 5 / 4;\n        break;\n      case 3:\n        cpi->per_frame_bandwidth = cpi->per_frame_bandwidth * 5 / 4;\n        break;\n    }\n\n    /* Note that we should not throw out a key frame (especially when\n     * spatial resampling is enabled).\n     */\n    if (cm->frame_type == KEY_FRAME) {\n      cpi->decimation_count = cpi->decimation_factor;\n    } else if (cpi->decimation_count > 0) {\n      cpi->decimation_count--;\n\n      cpi->bits_off_target += cpi->av_per_frame_bandwidth;\n      if (cpi->bits_off_target > cpi->oxcf.maximum_buffer_size) {\n        cpi->bits_off_target = cpi->oxcf.maximum_buffer_size;\n      }\n\n#if CONFIG_MULTI_RES_ENCODING\n      vp8_store_drop_frame_info(cpi);\n#endif\n\n      cm->current_video_frame++;\n      cpi->frames_since_key++;\n      cpi->ext_refresh_frame_flags_pending = 0;\n      // We advance the temporal pattern for dropped frames.\n      cpi->temporal_pattern_counter++;\n\n#if CONFIG_INTERNAL_STATS\n      cpi->count++;\n#endif\n\n      cpi->buffer_level = cpi->bits_off_target;\n\n      if (cpi->oxcf.number_of_layers > 1) {\n        unsigned int i;\n\n        /* Propagate bits saved by dropping the frame to higher\n         * layers\n         */\n        for (i = cpi->current_layer + 1; i < cpi->oxcf.number_of_layers; ++i) {\n          LAYER_CONTEXT *lc = &cpi->layer_context[i];\n          lc->bits_off_target += (int)(lc->target_bandwidth / lc->framerate);\n          if (lc->bits_off_target > lc->maximum_buffer_size) {\n            lc->bits_off_target = lc->maximum_buffer_size;\n          }\n          lc->buffer_level = lc->bits_off_target;\n        }\n      }\n\n      return;\n    } else {\n      cpi->decimation_count = cpi->decimation_factor;\n    }\n  } else {\n    cpi->decimation_count = 0;\n  }\n\n  /* Decide how big to make the frame */\n  if (!vp8_pick_frame_size(cpi)) {\n/*TODO: 2 drop_frame and return code could be put together. */\n#if CONFIG_MULTI_RES_ENCODING\n    vp8_store_drop_frame_info(cpi);\n#endif\n    cm->current_video_frame++;\n    cpi->frames_since_key++;\n    cpi->ext_refresh_frame_flags_pending = 0;\n    // We advance the temporal pattern for dropped frames.\n    cpi->temporal_pattern_counter++;\n    return;\n  }\n\n  /* Reduce active_worst_allowed_q for CBR if our buffer is getting too full.\n   * This has a knock on effect on active best quality as well.\n   * For CBR if the buffer reaches its maximum level then we can no longer\n   * save up bits for later frames so we might as well use them up\n   * on the current frame.\n   */\n  if ((cpi->oxcf.end_usage == USAGE_STREAM_FROM_SERVER) &&\n      (cpi->buffer_level >= cpi->oxcf.optimal_buffer_level) &&\n      cpi->buffered_mode) {\n    /* Max adjustment is 1/4 */\n    int Adjustment = cpi->active_worst_quality / 4;\n\n    if (Adjustment) {\n      int buff_lvl_step;\n\n      if (cpi->buffer_level < cpi->oxcf.maximum_buffer_size) {\n        buff_lvl_step = (int)((cpi->oxcf.maximum_buffer_size -\n                               cpi->oxcf.optimal_buffer_level) /\n                              Adjustment);\n\n        if (buff_lvl_step) {\n          Adjustment =\n              (int)((cpi->buffer_level - cpi->oxcf.optimal_buffer_level) /\n                    buff_lvl_step);\n        } else {\n          Adjustment = 0;\n        }\n      }\n\n      cpi->active_worst_quality -= Adjustment;\n\n      if (cpi->active_worst_quality < cpi->active_best_quality) {\n        cpi->active_worst_quality = cpi->active_best_quality;\n      }\n    }\n  }\n\n  /* Set an active best quality and if necessary active worst quality\n   * There is some odd behavior for one pass here that needs attention.\n   */\n  if ((cpi->pass == 2) || (cpi->ni_frames > 150)) {\n    vpx_clear_system_state();\n\n    Q = cpi->active_worst_quality;\n\n    if (cm->frame_type == KEY_FRAME) {\n      if (cpi->pass == 2) {\n        if (cpi->gfu_boost > 600) {\n          cpi->active_best_quality = kf_low_motion_minq[Q];\n        } else {\n          cpi->active_best_quality = kf_high_motion_minq[Q];\n        }\n\n        /* Special case for key frames forced because we have reached\n         * the maximum key frame interval. Here force the Q to a range\n         * based on the ambient Q to reduce the risk of popping\n         */\n        if (cpi->this_key_frame_forced) {\n          if (cpi->active_best_quality > cpi->avg_frame_qindex * 7 / 8) {\n            cpi->active_best_quality = cpi->avg_frame_qindex * 7 / 8;\n          } else if (cpi->active_best_quality < (cpi->avg_frame_qindex >> 2)) {\n            cpi->active_best_quality = cpi->avg_frame_qindex >> 2;\n          }\n        }\n      }\n      /* One pass more conservative */\n      else {\n        cpi->active_best_quality = kf_high_motion_minq[Q];\n      }\n    }\n\n    else if (cpi->oxcf.number_of_layers == 1 &&\n             (cm->refresh_golden_frame || cpi->common.refresh_alt_ref_frame)) {\n      /* Use the lower of cpi->active_worst_quality and recent\n       * average Q as basis for GF/ARF Q limit unless last frame was\n       * a key frame.\n       */\n      if ((cpi->frames_since_key > 1) &&\n          (cpi->avg_frame_qindex < cpi->active_worst_quality)) {\n        Q = cpi->avg_frame_qindex;\n      }\n\n      /* For constrained quality don't allow Q less than the cq level */\n      if ((cpi->oxcf.end_usage == USAGE_CONSTRAINED_QUALITY) &&\n          (Q < cpi->cq_target_quality)) {\n        Q = cpi->cq_target_quality;\n      }\n\n      if (cpi->pass == 2) {\n        if (cpi->gfu_boost > 1000) {\n          cpi->active_best_quality = gf_low_motion_minq[Q];\n        } else if (cpi->gfu_boost < 400) {\n          cpi->active_best_quality = gf_high_motion_minq[Q];\n        } else {\n          cpi->active_best_quality = gf_mid_motion_minq[Q];\n        }\n\n        /* Constrained quality use slightly lower active best. */\n        if (cpi->oxcf.end_usage == USAGE_CONSTRAINED_QUALITY) {\n          cpi->active_best_quality = cpi->active_best_quality * 15 / 16;\n        }\n      }\n      /* One pass more conservative */\n      else {\n        cpi->active_best_quality = gf_high_motion_minq[Q];\n      }\n    } else {\n      cpi->active_best_quality = inter_minq[Q];\n\n      /* For the constant/constrained quality mode we don't want\n       * q to fall below the cq level.\n       */\n      if ((cpi->oxcf.end_usage == USAGE_CONSTRAINED_QUALITY) &&\n          (cpi->active_best_quality < cpi->cq_target_quality)) {\n        /* If we are strongly undershooting the target rate in the last\n         * frames then use the user passed in cq value not the auto\n         * cq value.\n         */\n        if (cpi->rolling_actual_bits < cpi->min_frame_bandwidth) {\n          cpi->active_best_quality = cpi->oxcf.cq_level;\n        } else {\n          cpi->active_best_quality = cpi->cq_target_quality;\n        }\n      }\n    }\n\n    /* If CBR and the buffer is as full then it is reasonable to allow\n     * higher quality on the frames to prevent bits just going to waste.\n     */\n    if (cpi->oxcf.end_usage == USAGE_STREAM_FROM_SERVER) {\n      /* Note that the use of >= here elliminates the risk of a divide\n       * by 0 error in the else if clause\n       */\n      if (cpi->buffer_level >= cpi->oxcf.maximum_buffer_size) {\n        cpi->active_best_quality = cpi->best_quality;\n\n      } else if (cpi->buffer_level > cpi->oxcf.optimal_buffer_level) {\n        int Fraction =\n            (int)(((cpi->buffer_level - cpi->oxcf.optimal_buffer_level) * 128) /\n                  (cpi->oxcf.maximum_buffer_size -\n                   cpi->oxcf.optimal_buffer_level));\n        int min_qadjustment =\n            ((cpi->active_best_quality - cpi->best_quality) * Fraction) / 128;\n\n        cpi->active_best_quality -= min_qadjustment;\n      }\n    }\n  }\n  /* Make sure constrained quality mode limits are adhered to for the first\n   * few frames of one pass encodes\n   */\n  else if (cpi->oxcf.end_usage == USAGE_CONSTRAINED_QUALITY) {\n    if ((cm->frame_type == KEY_FRAME) || cm->refresh_golden_frame ||\n        cpi->common.refresh_alt_ref_frame) {\n      cpi->active_best_quality = cpi->best_quality;\n    } else if (cpi->active_best_quality < cpi->cq_target_quality) {\n      cpi->active_best_quality = cpi->cq_target_quality;\n    }\n  }\n\n  /* Clip the active best and worst quality values to limits */\n  if (cpi->active_worst_quality > cpi->worst_quality) {\n    cpi->active_worst_quality = cpi->worst_quality;\n  }\n\n  if (cpi->active_best_quality < cpi->best_quality) {\n    cpi->active_best_quality = cpi->best_quality;\n  }\n\n  if (cpi->active_worst_quality < cpi->active_best_quality) {\n    cpi->active_worst_quality = cpi->active_best_quality;\n  }\n\n  /* Determine initial Q to try */\n  Q = vp8_regulate_q(cpi, cpi->this_frame_target);\n\n#if !CONFIG_REALTIME_ONLY\n\n  /* Set highest allowed value for Zbin over quant */\n  if (cm->frame_type == KEY_FRAME) {\n    zbin_oq_high = 0;\n  } else if ((cpi->oxcf.number_of_layers == 1) &&\n             ((cm->refresh_alt_ref_frame ||\n               (cm->refresh_golden_frame && !cpi->source_alt_ref_active)))) {\n    zbin_oq_high = 16;\n  } else {\n    zbin_oq_high = ZBIN_OQ_MAX;\n  }\n#endif\n\n  compute_skin_map(cpi);\n\n  /* Setup background Q adjustment for error resilient mode.\n   * For multi-layer encodes only enable this for the base layer.\n   */\n  if (cpi->cyclic_refresh_mode_enabled) {\n    // Special case for screen_content_mode with golden frame updates.\n    int disable_cr_gf =\n        (cpi->oxcf.screen_content_mode == 2 && cm->refresh_golden_frame);\n    if (cpi->current_layer == 0 && cpi->force_maxqp == 0 && !disable_cr_gf) {\n      cyclic_background_refresh(cpi, Q, 0);\n    } else {\n      disable_segmentation(cpi);\n    }\n  }\n\n  vp8_compute_frame_size_bounds(cpi, &frame_under_shoot_limit,\n                                &frame_over_shoot_limit);\n\n#if !CONFIG_REALTIME_ONLY\n  /* Limit Q range for the adaptive loop. */\n  bottom_index = cpi->active_best_quality;\n  top_index = cpi->active_worst_quality;\n  q_low = cpi->active_best_quality;\n  q_high = cpi->active_worst_quality;\n#endif\n\n  vp8_save_coding_context(cpi);\n\n  scale_and_extend_source(cpi->un_scaled_source, cpi);\n\n#if CONFIG_TEMPORAL_DENOISING && CONFIG_POSTPROC\n  // Option to apply spatial blur under the aggressive or adaptive\n  // (temporal denoising) mode.\n  if (cpi->oxcf.noise_sensitivity >= 3) {\n    if (cpi->denoiser.denoise_pars.spatial_blur != 0) {\n      vp8_de_noise(cm, cpi->Source, cpi->denoiser.denoise_pars.spatial_blur, 1);\n    }\n  }\n#endif\n\n#if !(CONFIG_REALTIME_ONLY) && CONFIG_POSTPROC && !(CONFIG_TEMPORAL_DENOISING)\n\n  if (cpi->oxcf.noise_sensitivity > 0) {\n    unsigned char *src;\n    int l = 0;\n\n    switch (cpi->oxcf.noise_sensitivity) {\n      case 1: l = 20; break;\n      case 2: l = 40; break;\n      case 3: l = 60; break;\n      case 4: l = 80; break;\n      case 5: l = 100; break;\n      case 6: l = 150; break;\n    }\n\n    if (cm->frame_type == KEY_FRAME) {\n      vp8_de_noise(cm, cpi->Source, l, 1);\n    } else {\n      vp8_de_noise(cm, cpi->Source, l, 1);\n\n      src = cpi->Source->y_buffer;\n\n      if (cpi->Source->y_stride < 0) {\n        src += cpi->Source->y_stride * (cpi->Source->y_height - 1);\n      }\n    }\n  }\n\n#endif\n\n#ifdef OUTPUT_YUV_SRC\n  vpx_write_yuv_frame(yuv_file, cpi->Source);\n#endif\n\n  do {\n    vpx_clear_system_state();\n\n    vp8_set_quantizer(cpi, Q);\n\n    /* setup skip prob for costing in mode/mv decision */\n    if (cpi->common.mb_no_coeff_skip) {\n      cpi->prob_skip_false = cpi->base_skip_false_prob[Q];\n\n      if (cm->frame_type != KEY_FRAME) {\n        if (cpi->common.refresh_alt_ref_frame) {\n          if (cpi->last_skip_false_probs[2] != 0) {\n            cpi->prob_skip_false = cpi->last_skip_false_probs[2];\n          }\n\n          /*\n                              if(cpi->last_skip_false_probs[2]!=0 && abs(Q-\n             cpi->last_skip_probs_q[2])<=16 )\n             cpi->prob_skip_false = cpi->last_skip_false_probs[2];\n                              else if (cpi->last_skip_false_probs[2]!=0)\n             cpi->prob_skip_false = (cpi->last_skip_false_probs[2]  +\n             cpi->prob_skip_false ) / 2;\n             */\n        } else if (cpi->common.refresh_golden_frame) {\n          if (cpi->last_skip_false_probs[1] != 0) {\n            cpi->prob_skip_false = cpi->last_skip_false_probs[1];\n          }\n\n          /*\n                              if(cpi->last_skip_false_probs[1]!=0 && abs(Q-\n             cpi->last_skip_probs_q[1])<=16 )\n             cpi->prob_skip_false = cpi->last_skip_false_probs[1];\n                              else if (cpi->last_skip_false_probs[1]!=0)\n             cpi->prob_skip_false = (cpi->last_skip_false_probs[1]  +\n             cpi->prob_skip_false ) / 2;\n             */\n        } else {\n          if (cpi->last_skip_false_probs[0] != 0) {\n            cpi->prob_skip_false = cpi->last_skip_false_probs[0];\n          }\n\n          /*\n          if(cpi->last_skip_false_probs[0]!=0 && abs(Q-\n          cpi->last_skip_probs_q[0])<=16 )\n              cpi->prob_skip_false = cpi->last_skip_false_probs[0];\n          else if(cpi->last_skip_false_probs[0]!=0)\n              cpi->prob_skip_false = (cpi->last_skip_false_probs[0]  +\n          cpi->prob_skip_false ) / 2;\n              */\n        }\n\n        /* as this is for cost estimate, let's make sure it does not\n         * go extreme eitehr way\n         */\n        if (cpi->prob_skip_false < 5) cpi->prob_skip_false = 5;\n\n        if (cpi->prob_skip_false > 250) cpi->prob_skip_false = 250;\n\n        if (cpi->oxcf.number_of_layers == 1 && cpi->is_src_frame_alt_ref) {\n          cpi->prob_skip_false = 1;\n        }\n      }\n\n#if 0\n\n            if (cpi->pass != 1)\n            {\n                FILE *f = fopen(\"skip.stt\", \"a\");\n                fprintf(f, \"%d, %d, %4d \", cpi->common.refresh_golden_frame, cpi->common.refresh_alt_ref_frame, cpi->prob_skip_false);\n                fclose(f);\n            }\n\n#endif\n    }\n\n    if (cm->frame_type == KEY_FRAME) {\n      if (resize_key_frame(cpi)) {\n        /* If the frame size has changed, need to reset Q, quantizer,\n         * and background refresh.\n         */\n        Q = vp8_regulate_q(cpi, cpi->this_frame_target);\n        if (cpi->cyclic_refresh_mode_enabled) {\n          if (cpi->current_layer == 0) {\n            cyclic_background_refresh(cpi, Q, 0);\n          } else {\n            disable_segmentation(cpi);\n          }\n        }\n        // Reset the zero_last counter to 0 on key frame.\n        memset(cpi->consec_zero_last, 0, cm->mb_rows * cm->mb_cols);\n        memset(cpi->consec_zero_last_mvbias, 0,\n               (cpi->common.mb_rows * cpi->common.mb_cols));\n        vp8_set_quantizer(cpi, Q);\n      }\n\n      vp8_setup_key_frame(cpi);\n    }\n\n#if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING\n    {\n      if (cpi->oxcf.error_resilient_mode) cm->refresh_entropy_probs = 0;\n\n      if (cpi->oxcf.error_resilient_mode & VPX_ERROR_RESILIENT_PARTITIONS) {\n        if (cm->frame_type == KEY_FRAME) cm->refresh_entropy_probs = 1;\n      }\n\n      if (cm->refresh_entropy_probs == 0) {\n        /* save a copy for later refresh */\n        memcpy(&cm->lfc, &cm->fc, sizeof(cm->fc));\n      }\n\n      vp8_update_coef_context(cpi);\n\n      vp8_update_coef_probs(cpi);\n\n      /* transform / motion compensation build reconstruction frame\n       * +pack coef partitions\n       */\n      vp8_encode_frame(cpi);\n\n      /* cpi->projected_frame_size is not needed for RT mode */\n    }\n#else\n    /* transform / motion compensation build reconstruction frame */\n    vp8_encode_frame(cpi);\n\n    if (cpi->pass == 0 && cpi->oxcf.end_usage == USAGE_STREAM_FROM_SERVER) {\n      if (vp8_drop_encodedframe_overshoot(cpi, Q)) {\n        vpx_clear_system_state();\n        return;\n      }\n      if (cm->frame_type != KEY_FRAME)\n        cpi->last_pred_err_mb =\n            (int)(cpi->mb.prediction_error / cpi->common.MBs);\n    }\n\n    cpi->projected_frame_size -= vp8_estimate_entropy_savings(cpi);\n    cpi->projected_frame_size =\n        (cpi->projected_frame_size > 0) ? cpi->projected_frame_size : 0;\n#endif\n    vpx_clear_system_state();\n\n    /* Test to see if the stats generated for this frame indicate that\n     * we should have coded a key frame (assuming that we didn't)!\n     */\n\n    if (cpi->pass != 2 && cpi->oxcf.auto_key && cm->frame_type != KEY_FRAME &&\n        cpi->compressor_speed != 2) {\n#if !CONFIG_REALTIME_ONLY\n      if (decide_key_frame(cpi)) {\n        /* Reset all our sizing numbers and recode */\n        cm->frame_type = KEY_FRAME;\n\n        vp8_pick_frame_size(cpi);\n\n        /* Clear the Alt reference frame active flag when we have\n         * a key frame\n         */\n        cpi->source_alt_ref_active = 0;\n\n        // Set the loop filter deltas and segmentation map update\n        setup_features(cpi);\n\n        vp8_restore_coding_context(cpi);\n\n        Q = vp8_regulate_q(cpi, cpi->this_frame_target);\n\n        vp8_compute_frame_size_bounds(cpi, &frame_under_shoot_limit,\n                                      &frame_over_shoot_limit);\n\n        /* Limit Q range for the adaptive loop. */\n        bottom_index = cpi->active_best_quality;\n        top_index = cpi->active_worst_quality;\n        q_low = cpi->active_best_quality;\n        q_high = cpi->active_worst_quality;\n\n        Loop = 1;\n\n        continue;\n      }\n#endif\n    }\n\n    vpx_clear_system_state();\n\n    if (frame_over_shoot_limit == 0) frame_over_shoot_limit = 1;\n\n    /* Are we are overshooting and up against the limit of active max Q. */\n    if (!cpi->rt_always_update_correction_factor &&\n        ((cpi->pass != 2) ||\n         (cpi->oxcf.end_usage == USAGE_STREAM_FROM_SERVER)) &&\n        (Q == cpi->active_worst_quality) &&\n        (cpi->active_worst_quality < cpi->worst_quality) &&\n        (cpi->projected_frame_size > frame_over_shoot_limit)) {\n      int over_size_percent =\n          ((cpi->projected_frame_size - frame_over_shoot_limit) * 100) /\n          frame_over_shoot_limit;\n\n      /* If so is there any scope for relaxing it */\n      while ((cpi->active_worst_quality < cpi->worst_quality) &&\n             (over_size_percent > 0)) {\n        cpi->active_worst_quality++;\n        /* Assume 1 qstep = about 4% on frame size. */\n        over_size_percent = (int)(over_size_percent * 0.96);\n      }\n#if !CONFIG_REALTIME_ONLY\n      top_index = cpi->active_worst_quality;\n#endif  // !CONFIG_REALTIME_ONLY\n      /* If we have updated the active max Q do not call\n       * vp8_update_rate_correction_factors() this loop.\n       */\n      active_worst_qchanged = 1;\n    } else {\n      active_worst_qchanged = 0;\n    }\n\n#if CONFIG_REALTIME_ONLY\n    Loop = 0;\n#else\n    /* Special case handling for forced key frames */\n    if ((cm->frame_type == KEY_FRAME) && cpi->this_key_frame_forced) {\n      int last_q = Q;\n      int kf_err = vp8_calc_ss_err(cpi->Source, &cm->yv12_fb[cm->new_fb_idx]);\n\n      /* The key frame is not good enough */\n      if (kf_err > ((cpi->ambient_err * 7) >> 3)) {\n        /* Lower q_high */\n        q_high = (Q > q_low) ? (Q - 1) : q_low;\n\n        /* Adjust Q */\n        Q = (q_high + q_low) >> 1;\n      }\n      /* The key frame is much better than the previous frame */\n      else if (kf_err < (cpi->ambient_err >> 1)) {\n        /* Raise q_low */\n        q_low = (Q < q_high) ? (Q + 1) : q_high;\n\n        /* Adjust Q */\n        Q = (q_high + q_low + 1) >> 1;\n      }\n\n      /* Clamp Q to upper and lower limits: */\n      if (Q > q_high) {\n        Q = q_high;\n      } else if (Q < q_low) {\n        Q = q_low;\n      }\n\n      Loop = Q != last_q;\n    }\n\n    /* Is the projected frame size out of range and are we allowed\n     * to attempt to recode.\n     */\n    else if (recode_loop_test(cpi, frame_over_shoot_limit,\n                              frame_under_shoot_limit, Q, top_index,\n                              bottom_index)) {\n      int last_q = Q;\n      int Retries = 0;\n\n      /* Frame size out of permitted range. Update correction factor\n       * & compute new Q to try...\n       */\n\n      /* Frame is too large */\n      if (cpi->projected_frame_size > cpi->this_frame_target) {\n        /* Raise Qlow as to at least the current value */\n        q_low = (Q < q_high) ? (Q + 1) : q_high;\n\n        /* If we are using over quant do the same for zbin_oq_low */\n        if (cpi->mb.zbin_over_quant > 0) {\n          zbin_oq_low = (cpi->mb.zbin_over_quant < zbin_oq_high)\n                            ? (cpi->mb.zbin_over_quant + 1)\n                            : zbin_oq_high;\n        }\n\n        if (undershoot_seen) {\n          /* Update rate_correction_factor unless\n           * cpi->active_worst_quality has changed.\n           */\n          if (!active_worst_qchanged) {\n            vp8_update_rate_correction_factors(cpi, 1);\n          }\n\n          Q = (q_high + q_low + 1) / 2;\n\n          /* Adjust cpi->zbin_over_quant (only allowed when Q\n           * is max)\n           */\n          if (Q < MAXQ) {\n            cpi->mb.zbin_over_quant = 0;\n          } else {\n            zbin_oq_low = (cpi->mb.zbin_over_quant < zbin_oq_high)\n                              ? (cpi->mb.zbin_over_quant + 1)\n                              : zbin_oq_high;\n            cpi->mb.zbin_over_quant = (zbin_oq_high + zbin_oq_low) / 2;\n          }\n        } else {\n          /* Update rate_correction_factor unless\n           * cpi->active_worst_quality has changed.\n           */\n          if (!active_worst_qchanged) {\n            vp8_update_rate_correction_factors(cpi, 0);\n          }\n\n          Q = vp8_regulate_q(cpi, cpi->this_frame_target);\n\n          while (((Q < q_low) || (cpi->mb.zbin_over_quant < zbin_oq_low)) &&\n                 (Retries < 10)) {\n            vp8_update_rate_correction_factors(cpi, 0);\n            Q = vp8_regulate_q(cpi, cpi->this_frame_target);\n            Retries++;\n          }\n        }\n\n        overshoot_seen = 1;\n      }\n      /* Frame is too small */\n      else {\n        if (cpi->mb.zbin_over_quant == 0) {\n          /* Lower q_high if not using over quant */\n          q_high = (Q > q_low) ? (Q - 1) : q_low;\n        } else {\n          /* else lower zbin_oq_high */\n          zbin_oq_high = (cpi->mb.zbin_over_quant > zbin_oq_low)\n                             ? (cpi->mb.zbin_over_quant - 1)\n                             : zbin_oq_low;\n        }\n\n        if (overshoot_seen) {\n          /* Update rate_correction_factor unless\n           * cpi->active_worst_quality has changed.\n           */\n          if (!active_worst_qchanged) {\n            vp8_update_rate_correction_factors(cpi, 1);\n          }\n\n          Q = (q_high + q_low) / 2;\n\n          /* Adjust cpi->zbin_over_quant (only allowed when Q\n           * is max)\n           */\n          if (Q < MAXQ) {\n            cpi->mb.zbin_over_quant = 0;\n          } else {\n            cpi->mb.zbin_over_quant = (zbin_oq_high + zbin_oq_low) / 2;\n          }\n        } else {\n          /* Update rate_correction_factor unless\n           * cpi->active_worst_quality has changed.\n           */\n          if (!active_worst_qchanged) {\n            vp8_update_rate_correction_factors(cpi, 0);\n          }\n\n          Q = vp8_regulate_q(cpi, cpi->this_frame_target);\n\n          /* Special case reset for qlow for constrained quality.\n           * This should only trigger where there is very substantial\n           * undershoot on a frame and the auto cq level is above\n           * the user passsed in value.\n           */\n          if ((cpi->oxcf.end_usage == USAGE_CONSTRAINED_QUALITY) &&\n              (Q < q_low)) {\n            q_low = Q;\n          }\n\n          while (((Q > q_high) || (cpi->mb.zbin_over_quant > zbin_oq_high)) &&\n                 (Retries < 10)) {\n            vp8_update_rate_correction_factors(cpi, 0);\n            Q = vp8_regulate_q(cpi, cpi->this_frame_target);\n            Retries++;\n          }\n        }\n\n        undershoot_seen = 1;\n      }\n\n      /* Clamp Q to upper and lower limits: */\n      if (Q > q_high) {\n        Q = q_high;\n      } else if (Q < q_low) {\n        Q = q_low;\n      }\n\n      /* Clamp cpi->zbin_over_quant */\n      cpi->mb.zbin_over_quant =\n          (cpi->mb.zbin_over_quant < zbin_oq_low)    ? zbin_oq_low\n          : (cpi->mb.zbin_over_quant > zbin_oq_high) ? zbin_oq_high\n                                                     : cpi->mb.zbin_over_quant;\n\n      Loop = Q != last_q;\n    } else {\n      Loop = 0;\n    }\n#endif  // CONFIG_REALTIME_ONLY\n\n    if (cpi->is_src_frame_alt_ref) Loop = 0;\n\n    if (Loop == 1) {\n      vp8_restore_coding_context(cpi);\n#if CONFIG_INTERNAL_STATS\n      cpi->tot_recode_hits++;\n#endif\n    }\n  } while (Loop == 1);\n\n#if defined(DROP_UNCODED_FRAMES)\n  /* if there are no coded macroblocks at all drop this frame */\n  if (cpi->common.MBs == cpi->mb.skip_true_count &&\n      (cpi->drop_frame_count & 7) != 7 && cm->frame_type != KEY_FRAME) {\n    cpi->common.current_video_frame++;\n    cpi->frames_since_key++;\n    cpi->drop_frame_count++;\n    cpi->ext_refresh_frame_flags_pending = 0;\n    // We advance the temporal pattern for dropped frames.\n    cpi->temporal_pattern_counter++;\n    return;\n  }\n  cpi->drop_frame_count = 0;\n#endif\n\n#if 0\n    /* Experimental code for lagged and one pass\n     * Update stats used for one pass GF selection\n     */\n    {\n        cpi->one_pass_frame_stats[cpi->one_pass_frame_index].frame_coded_error = (double)cpi->prediction_error;\n        cpi->one_pass_frame_stats[cpi->one_pass_frame_index].frame_intra_error = (double)cpi->intra_error;\n        cpi->one_pass_frame_stats[cpi->one_pass_frame_index].frame_pcnt_inter = (double)(100 - cpi->this_frame_percent_intra) / 100.0;\n    }\n#endif\n\n  /* Special case code to reduce pulsing when key frames are forced at a\n   * fixed interval. Note the reconstruction error if it is the frame before\n   * the force key frame\n   */\n  if (cpi->next_key_frame_forced && (cpi->twopass.frames_to_key == 0)) {\n    cpi->ambient_err =\n        vp8_calc_ss_err(cpi->Source, &cm->yv12_fb[cm->new_fb_idx]);\n  }\n\n/* This frame's MVs are saved and will be used in next frame's MV predictor.\n * Last frame has one more line(add to bottom) and one more column(add to\n * right) than cm->mip. The edge elements are initialized to 0.\n */\n#if CONFIG_MULTI_RES_ENCODING\n  if (!cpi->oxcf.mr_encoder_id && cm->show_frame)\n#else\n  if (cm->show_frame) /* do not save for altref frame */\n#endif\n  {\n    int mb_row;\n    int mb_col;\n    /* Point to beginning of allocated MODE_INFO arrays. */\n    MODE_INFO *tmp = cm->mip;\n\n    if (cm->frame_type != KEY_FRAME) {\n      for (mb_row = 0; mb_row < cm->mb_rows + 1; ++mb_row) {\n        for (mb_col = 0; mb_col < cm->mb_cols + 1; ++mb_col) {\n          if (tmp->mbmi.ref_frame != INTRA_FRAME) {\n            cpi->lfmv[mb_col + mb_row * (cm->mode_info_stride + 1)].as_int =\n                tmp->mbmi.mv.as_int;\n          }\n\n          cpi->lf_ref_frame_sign_bias[mb_col +\n                                      mb_row * (cm->mode_info_stride + 1)] =\n              cm->ref_frame_sign_bias[tmp->mbmi.ref_frame];\n          cpi->lf_ref_frame[mb_col + mb_row * (cm->mode_info_stride + 1)] =\n              tmp->mbmi.ref_frame;\n          tmp++;\n        }\n      }\n    }\n  }\n\n  /* Count last ref frame 0,0 usage on current encoded frame. */\n  {\n    int mb_row;\n    int mb_col;\n    /* Point to beginning of MODE_INFO arrays. */\n    MODE_INFO *tmp = cm->mi;\n\n    cpi->zeromv_count = 0;\n\n    if (cm->frame_type != KEY_FRAME) {\n      for (mb_row = 0; mb_row < cm->mb_rows; ++mb_row) {\n        for (mb_col = 0; mb_col < cm->mb_cols; ++mb_col) {\n          if (tmp->mbmi.mode == ZEROMV && tmp->mbmi.ref_frame == LAST_FRAME) {\n            cpi->zeromv_count++;\n          }\n          tmp++;\n        }\n        tmp++;\n      }\n    }\n  }\n\n#if CONFIG_MULTI_RES_ENCODING\n  vp8_cal_dissimilarity(cpi);\n#endif\n\n  /* Update the GF usage maps.\n   * This is done after completing the compression of a frame when all\n   * modes etc. are finalized but before loop filter\n   */\n  if (cpi->oxcf.number_of_layers == 1) {\n    vp8_update_gf_usage_maps(cpi, cm, &cpi->mb);\n  }\n\n  if (cm->frame_type == KEY_FRAME) cm->refresh_last_frame = 1;\n\n#if 0\n    {\n        FILE *f = fopen(\"gfactive.stt\", \"a\");\n        fprintf(f, \"%8d %8d %8d %8d %8d\\n\", cm->current_video_frame, (100 * cpi->gf_active_count) / (cpi->common.mb_rows * cpi->common.mb_cols), cpi->this_iiratio, cpi->next_iiratio, cm->refresh_golden_frame);\n        fclose(f);\n    }\n#endif\n\n  /* For inter frames the current default behavior is that when\n   * cm->refresh_golden_frame is set we copy the old GF over to the ARF buffer\n   * This is purely an encoder decision at present.\n   * Avoid this behavior when refresh flags are set by the user.\n   */\n  if (!cpi->oxcf.error_resilient_mode && cm->refresh_golden_frame &&\n      !cpi->ext_refresh_frame_flags_pending) {\n    cm->copy_buffer_to_arf = 2;\n  } else {\n    cm->copy_buffer_to_arf = 0;\n  }\n\n  cm->frame_to_show = &cm->yv12_fb[cm->new_fb_idx];\n\n#if CONFIG_TEMPORAL_DENOISING\n  // Get some measure of the amount of noise, by measuring the (partial) mse\n  // between source and denoised buffer, for y channel. Partial refers to\n  // computing the sse for a sub-sample of the frame (i.e., skip x blocks along\n  // row/column),\n  // and only for blocks in that set that are consecutive ZEROMV_LAST mode.\n  // Do this every ~8 frames, to further reduce complexity.\n  // TODO(marpan): Keep this for now for the case cpi->oxcf.noise_sensitivity <\n  // 4,\n  // should be removed in favor of the process_denoiser_mode_change() function\n  // below.\n  if (cpi->oxcf.noise_sensitivity > 0 && cpi->oxcf.noise_sensitivity < 4 &&\n      !cpi->oxcf.screen_content_mode && cpi->frames_since_key % 8 == 0 &&\n      cm->frame_type != KEY_FRAME) {\n    cpi->mse_source_denoised = measure_square_diff_partial(\n        &cpi->denoiser.yv12_running_avg[INTRA_FRAME], cpi->Source, cpi);\n  }\n\n  // For the adaptive denoising mode (noise_sensitivity == 4), sample the mse\n  // of source diff (between current and previous frame), and determine if we\n  // should switch the denoiser mode. Sampling refers to computing the mse for\n  // a sub-sample of the frame (i.e., skip x blocks along row/column), and\n  // only for blocks in that set that have used ZEROMV LAST, along with some\n  // constraint on the sum diff between blocks. This process is called every\n  // ~8 frames, to further reduce complexity.\n  if (cpi->oxcf.noise_sensitivity == 4 && !cpi->oxcf.screen_content_mode &&\n      cpi->frames_since_key % 8 == 0 && cm->frame_type != KEY_FRAME) {\n    process_denoiser_mode_change(cpi);\n  }\n#endif\n\n#ifdef OUTPUT_YUV_SKINMAP\n  if (cpi->common.current_video_frame > 1) {\n    vp8_compute_skin_map(cpi, yuv_skinmap_file);\n  }\n#endif\n\n#if CONFIG_MULTITHREAD\n  if (vpx_atomic_load_acquire(&cpi->b_multi_threaded)) {\n    /* start loopfilter in separate thread */\n    sem_post(&cpi->h_event_start_lpf);\n    cpi->b_lpf_running = 1;\n    /* wait for the filter_level to be picked so that we can continue with\n     * stream packing */\n    sem_wait(&cpi->h_event_end_lpf);\n  } else\n#endif\n  {\n    vp8_loopfilter_frame(cpi, cm);\n  }\n\n  update_reference_frames(cpi);\n\n#ifdef OUTPUT_YUV_DENOISED\n  vpx_write_yuv_frame(yuv_denoised_file,\n                      &cpi->denoiser.yv12_running_avg[INTRA_FRAME]);\n#endif\n\n#if !(CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING)\n  if (cpi->oxcf.error_resilient_mode) {\n    cm->refresh_entropy_probs = 0;\n  }\n#endif\n\n  /* build the bitstream */\n  vp8_pack_bitstream(cpi, dest, dest_end, size);\n\n  /* Move storing frame_type out of the above loop since it is also\n   * needed in motion search besides loopfilter */\n  cm->last_frame_type = cm->frame_type;\n\n  /* Update rate control heuristics */\n  cpi->total_byte_count += (*size);\n  cpi->projected_frame_size = (int)(*size) << 3;\n\n  if (cpi->oxcf.number_of_layers > 1) {\n    unsigned int i;\n    for (i = cpi->current_layer + 1; i < cpi->oxcf.number_of_layers; ++i) {\n      cpi->layer_context[i].total_byte_count += (*size);\n    }\n  }\n\n  if (!active_worst_qchanged) vp8_update_rate_correction_factors(cpi, 2);\n\n  cpi->last_q[cm->frame_type] = cm->base_qindex;\n\n  if (cm->frame_type == KEY_FRAME) {\n    vp8_adjust_key_frame_context(cpi);\n  }\n\n  /* Keep a record of ambient average Q. */\n  if (cm->frame_type != KEY_FRAME) {\n    cpi->avg_frame_qindex =\n        (2 + 3 * cpi->avg_frame_qindex + cm->base_qindex) >> 2;\n  }\n\n  /* Keep a record from which we can calculate the average Q excluding\n   * GF updates and key frames\n   */\n  if ((cm->frame_type != KEY_FRAME) &&\n      ((cpi->oxcf.number_of_layers > 1) ||\n       (!cm->refresh_golden_frame && !cm->refresh_alt_ref_frame))) {\n    cpi->ni_frames++;\n\n    /* Calculate the average Q for normal inter frames (not key or GFU\n     * frames).\n     */\n    if (cpi->pass == 2) {\n      cpi->ni_tot_qi += Q;\n      cpi->ni_av_qi = (cpi->ni_tot_qi / cpi->ni_frames);\n    } else {\n      /* Damp value for first few frames */\n      if (cpi->ni_frames > 150) {\n        cpi->ni_tot_qi += Q;\n        cpi->ni_av_qi = (cpi->ni_tot_qi / cpi->ni_frames);\n      }\n      /* For one pass, early in the clip ... average the current frame Q\n       * value with the worstq entered by the user as a dampening measure\n       */\n      else {\n        cpi->ni_tot_qi += Q;\n        cpi->ni_av_qi =\n            ((cpi->ni_tot_qi / cpi->ni_frames) + cpi->worst_quality + 1) / 2;\n      }\n\n      /* If the average Q is higher than what was used in the last\n       * frame (after going through the recode loop to keep the frame\n       * size within range) then use the last frame value - 1. The -1\n       * is designed to stop Q and hence the data rate, from\n       * progressively falling away during difficult sections, but at\n       * the same time reduce the number of iterations around the\n       * recode loop.\n       */\n      if (Q > cpi->ni_av_qi) cpi->ni_av_qi = Q - 1;\n    }\n  }\n\n  /* Update the buffer level variable. */\n  /* Non-viewable frames are a special case and are treated as pure overhead. */\n  if (!cm->show_frame) {\n    cpi->bits_off_target -= cpi->projected_frame_size;\n  } else {\n    cpi->bits_off_target +=\n        cpi->av_per_frame_bandwidth - cpi->projected_frame_size;\n  }\n\n  /* Clip the buffer level to the maximum specified buffer size */\n  if (cpi->bits_off_target > cpi->oxcf.maximum_buffer_size) {\n    cpi->bits_off_target = cpi->oxcf.maximum_buffer_size;\n  }\n\n  // Don't let the buffer level go below some threshold, given here\n  // by -|maximum_buffer_size|. For now we only do this for\n  // screen content input.\n  if (cpi->oxcf.screen_content_mode &&\n      cpi->bits_off_target < -cpi->oxcf.maximum_buffer_size) {\n    cpi->bits_off_target = -cpi->oxcf.maximum_buffer_size;\n  }\n\n  /* Rolling monitors of whether we are over or underspending used to\n   * help regulate min and Max Q in two pass.\n   */\n  cpi->rolling_target_bits = (int)ROUND64_POWER_OF_TWO(\n      (int64_t)cpi->rolling_target_bits * 3 + cpi->this_frame_target, 2);\n  cpi->rolling_actual_bits = (int)ROUND64_POWER_OF_TWO(\n      (int64_t)cpi->rolling_actual_bits * 3 + cpi->projected_frame_size, 2);\n  cpi->long_rolling_target_bits = (int)ROUND64_POWER_OF_TWO(\n      (int64_t)cpi->long_rolling_target_bits * 31 + cpi->this_frame_target, 5);\n  cpi->long_rolling_actual_bits = (int)ROUND64_POWER_OF_TWO(\n      (int64_t)cpi->long_rolling_actual_bits * 31 + cpi->projected_frame_size,\n      5);\n\n  /* Actual bits spent */\n  cpi->total_actual_bits += cpi->projected_frame_size;\n\n#if 0 && CONFIG_INTERNAL_STATS\n  /* Debug stats */\n  cpi->total_target_vs_actual +=\n      (cpi->this_frame_target - cpi->projected_frame_size);\n#endif\n\n  cpi->buffer_level = cpi->bits_off_target;\n\n  /* Propagate values to higher temporal layers */\n  if (cpi->oxcf.number_of_layers > 1) {\n    unsigned int i;\n\n    for (i = cpi->current_layer + 1; i < cpi->oxcf.number_of_layers; ++i) {\n      LAYER_CONTEXT *lc = &cpi->layer_context[i];\n      int bits_off_for_this_layer = (int)round(\n          lc->target_bandwidth / lc->framerate - cpi->projected_frame_size);\n\n      lc->bits_off_target += bits_off_for_this_layer;\n\n      /* Clip buffer level to maximum buffer size for the layer */\n      if (lc->bits_off_target > lc->maximum_buffer_size) {\n        lc->bits_off_target = lc->maximum_buffer_size;\n      }\n\n      lc->total_actual_bits += cpi->projected_frame_size;\n      lc->total_target_vs_actual += bits_off_for_this_layer;\n      lc->buffer_level = lc->bits_off_target;\n    }\n  }\n\n  /* Update bits left to the kf and gf groups to account for overshoot\n   * or undershoot on these frames\n   */\n  if (cm->frame_type == KEY_FRAME) {\n    cpi->twopass.kf_group_bits +=\n        cpi->this_frame_target - cpi->projected_frame_size;\n\n    if (cpi->twopass.kf_group_bits < 0) cpi->twopass.kf_group_bits = 0;\n  } else if (cm->refresh_golden_frame || cm->refresh_alt_ref_frame) {\n    cpi->twopass.gf_group_bits +=\n        cpi->this_frame_target - cpi->projected_frame_size;\n\n    if (cpi->twopass.gf_group_bits < 0) cpi->twopass.gf_group_bits = 0;\n  }\n\n  if (cm->frame_type != KEY_FRAME) {\n    if (cpi->common.refresh_alt_ref_frame) {\n      cpi->last_skip_false_probs[2] = cpi->prob_skip_false;\n      cpi->last_skip_probs_q[2] = cm->base_qindex;\n    } else if (cpi->common.refresh_golden_frame) {\n      cpi->last_skip_false_probs[1] = cpi->prob_skip_false;\n      cpi->last_skip_probs_q[1] = cm->base_qindex;\n    } else {\n      cpi->last_skip_false_probs[0] = cpi->prob_skip_false;\n      cpi->last_skip_probs_q[0] = cm->base_qindex;\n\n      /* update the baseline */\n      cpi->base_skip_false_prob[cm->base_qindex] = cpi->prob_skip_false;\n    }\n  }\n\n#if 0 && CONFIG_INTERNAL_STATS\n    {\n        FILE *f = fopen(\"tmp.stt\", \"a\");\n\n        vpx_clear_system_state();\n\n        if (cpi->twopass.total_left_stats.coded_error != 0.0)\n            fprintf(f, \"%10d %10d %10d %10d %10d %10\"PRId64\" %10\"PRId64\n                       \"%10\"PRId64\" %10d %6d %6d %6d %6d %5d %5d %5d %8d \"\n                       \"%8.2lf %\"PRId64\" %10.3lf %10\"PRId64\" %8d\\n\",\n                       cpi->common.current_video_frame, cpi->this_frame_target,\n                       cpi->projected_frame_size,\n                       (cpi->projected_frame_size - cpi->this_frame_target),\n                       cpi->total_target_vs_actual,\n                       cpi->buffer_level,\n                       (cpi->oxcf.starting_buffer_level-cpi->bits_off_target),\n                       cpi->total_actual_bits, cm->base_qindex,\n                       cpi->active_best_quality, cpi->active_worst_quality,\n                       cpi->ni_av_qi, cpi->cq_target_quality,\n                       cm->refresh_golden_frame, cm->refresh_alt_ref_frame,\n                       cm->frame_type, cpi->gfu_boost,\n                       cpi->twopass.est_max_qcorrection_factor,\n                       cpi->twopass.bits_left,\n                       cpi->twopass.total_left_stats.coded_error,\n                       (double)cpi->twopass.bits_left /\n                           cpi->twopass.total_left_stats.coded_error,\n                       cpi->tot_recode_hits);\n        else\n            fprintf(f, \"%10d %10d %10d %10d %10d %10\"PRId64\" %10\"PRId64\n                       \"%10\"PRId64\" %10d %6d %6d %6d %6d %5d %5d %5d %8d \"\n                       \"%8.2lf %\"PRId64\" %10.3lf %8d\\n\",\n                       cpi->common.current_video_frame, cpi->this_frame_target,\n                       cpi->projected_frame_size,\n                       (cpi->projected_frame_size - cpi->this_frame_target),\n                       cpi->total_target_vs_actual,\n                       cpi->buffer_level,\n                       (cpi->oxcf.starting_buffer_level-cpi->bits_off_target),\n                       cpi->total_actual_bits, cm->base_qindex,\n                       cpi->active_best_quality, cpi->active_worst_quality,\n                       cpi->ni_av_qi, cpi->cq_target_quality,\n                       cm->refresh_golden_frame, cm->refresh_alt_ref_frame,\n                       cm->frame_type, cpi->gfu_boost,\n                       cpi->twopass.est_max_qcorrection_factor,\n                       cpi->twopass.bits_left,\n                       cpi->twopass.total_left_stats.coded_error,\n                       cpi->tot_recode_hits);\n\n        fclose(f);\n\n        {\n            FILE *fmodes = fopen(\"Modes.stt\", \"a\");\n\n            fprintf(fmodes, \"%6d:%1d:%1d:%1d \",\n                        cpi->common.current_video_frame,\n                        cm->frame_type, cm->refresh_golden_frame,\n                        cm->refresh_alt_ref_frame);\n\n            fprintf(fmodes, \"\\n\");\n\n            fclose(fmodes);\n        }\n    }\n\n#endif\n\n  cpi->ext_refresh_frame_flags_pending = 0;\n\n  if (cm->refresh_golden_frame == 1) {\n    cm->frame_flags = cm->frame_flags | FRAMEFLAGS_GOLDEN;\n  } else {\n    cm->frame_flags = cm->frame_flags & ~FRAMEFLAGS_GOLDEN;\n  }\n\n  if (cm->refresh_alt_ref_frame == 1) {\n    cm->frame_flags = cm->frame_flags | FRAMEFLAGS_ALTREF;\n  } else {\n    cm->frame_flags = cm->frame_flags & ~FRAMEFLAGS_ALTREF;\n  }\n\n  if (cm->refresh_last_frame & cm->refresh_golden_frame) { /* both refreshed */\n    cpi->gold_is_last = 1;\n  } else if (cm->refresh_last_frame ^ cm->refresh_golden_frame) {\n    /* 1 refreshed but not the other */\n    cpi->gold_is_last = 0;\n  }\n\n  if (cm->refresh_last_frame & cm->refresh_alt_ref_frame) { /* both refreshed */\n    cpi->alt_is_last = 1;\n  } else if (cm->refresh_last_frame ^ cm->refresh_alt_ref_frame) {\n    /* 1 refreshed but not the other */\n    cpi->alt_is_last = 0;\n  }\n\n  if (cm->refresh_alt_ref_frame &\n      cm->refresh_golden_frame) { /* both refreshed */\n    cpi->gold_is_alt = 1;\n  } else if (cm->refresh_alt_ref_frame ^ cm->refresh_golden_frame) {\n    /* 1 refreshed but not the other */\n    cpi->gold_is_alt = 0;\n  }\n\n  cpi->ref_frame_flags = VP8_ALTR_FRAME | VP8_GOLD_FRAME | VP8_LAST_FRAME;\n\n  if (cpi->gold_is_last) cpi->ref_frame_flags &= ~VP8_GOLD_FRAME;\n\n  if (cpi->alt_is_last) cpi->ref_frame_flags &= ~VP8_ALTR_FRAME;\n\n  if (cpi->gold_is_alt) cpi->ref_frame_flags &= ~VP8_ALTR_FRAME;\n\n  if (!cpi->oxcf.error_resilient_mode) {\n    if (cpi->oxcf.play_alternate && cm->refresh_alt_ref_frame &&\n        (cm->frame_type != KEY_FRAME)) {\n      /* Update the alternate reference frame stats as appropriate. */\n      update_alt_ref_frame_stats(cpi);\n    } else {\n      /* Update the Golden frame stats as appropriate. */\n      update_golden_frame_stats(cpi);\n    }\n  }\n\n  if (cm->frame_type == KEY_FRAME) {\n    /* Tell the caller that the frame was coded as a key frame */\n    *frame_flags = cm->frame_flags | FRAMEFLAGS_KEY;\n\n    /* As this frame is a key frame  the next defaults to an inter frame. */\n    cm->frame_type = INTER_FRAME;\n\n    cpi->last_frame_percent_intra = 100;\n  } else {\n    *frame_flags = cm->frame_flags & ~FRAMEFLAGS_KEY;\n\n    cpi->last_frame_percent_intra = cpi->this_frame_percent_intra;\n  }\n\n  /* Clear the one shot update flags for segmentation map and mode/ref\n   * loop filter deltas.\n   */\n  cpi->mb.e_mbd.update_mb_segmentation_map = 0;\n  cpi->mb.e_mbd.update_mb_segmentation_data = 0;\n  cpi->mb.e_mbd.mode_ref_lf_delta_update = 0;\n\n  /* Don't increment frame counters if this was an altref buffer update\n   * not a real frame\n   */\n  if (cm->show_frame) {\n    cm->current_video_frame++;\n    cpi->frames_since_key++;\n    cpi->temporal_pattern_counter++;\n  }\n\n#if 0\n    {\n        char filename[512];\n        FILE *recon_file;\n        sprintf(filename, \"enc%04d.yuv\", (int) cm->current_video_frame);\n        recon_file = fopen(filename, \"wb\");\n        fwrite(cm->yv12_fb[cm->lst_fb_idx].buffer_alloc,\n               cm->yv12_fb[cm->lst_fb_idx].frame_size, 1, recon_file);\n        fclose(recon_file);\n    }\n#endif\n\n  /* DEBUG */\n  /* vpx_write_yuv_frame(\"encoder_recon.yuv\", cm->frame_to_show); */\n}\n#if !CONFIG_REALTIME_ONLY\nstatic void Pass2Encode(VP8_COMP *cpi, size_t *size, unsigned char *dest,\n                        unsigned char *dest_end, unsigned int *frame_flags) {\n  if (!cpi->common.refresh_alt_ref_frame) vp8_second_pass(cpi);\n\n  encode_frame_to_data_rate(cpi, size, dest, dest_end, frame_flags);\n  cpi->twopass.bits_left -= 8 * (int)(*size);\n\n  if (!cpi->common.refresh_alt_ref_frame) {\n    double two_pass_min_rate =\n        (double)(cpi->oxcf.target_bandwidth *\n                 cpi->oxcf.two_pass_vbrmin_section / 100);\n    cpi->twopass.bits_left += (int64_t)(two_pass_min_rate / cpi->framerate);\n  }\n}\n#endif\n\nint vp8_receive_raw_frame(VP8_COMP *cpi, unsigned int frame_flags,\n                          YV12_BUFFER_CONFIG *sd, int64_t time_stamp,\n                          int64_t end_time) {\n  struct vpx_usec_timer timer;\n  int res = 0;\n\n  vpx_usec_timer_start(&timer);\n\n  /* Reinit the lookahead buffer if the frame size changes */\n  if (sd->y_width != cpi->oxcf.Width || sd->y_height != cpi->oxcf.Height) {\n    assert(cpi->oxcf.lag_in_frames < 2);\n    dealloc_raw_frame_buffers(cpi);\n    alloc_raw_frame_buffers(cpi);\n  }\n\n  if (vp8_lookahead_push(cpi->lookahead, sd, time_stamp, end_time, frame_flags,\n                         cpi->active_map_enabled ? cpi->active_map : NULL)) {\n    res = -1;\n  }\n  vpx_usec_timer_mark(&timer);\n  cpi->time_receive_data += vpx_usec_timer_elapsed(&timer);\n\n  return res;\n}\n\nstatic int frame_is_reference(const VP8_COMP *cpi) {\n  const VP8_COMMON *cm = &cpi->common;\n  const MACROBLOCKD *xd = &cpi->mb.e_mbd;\n\n  return cm->frame_type == KEY_FRAME || cm->refresh_last_frame ||\n         cm->refresh_golden_frame || cm->refresh_alt_ref_frame ||\n         cm->copy_buffer_to_gf || cm->copy_buffer_to_arf ||\n         cm->refresh_entropy_probs || xd->mode_ref_lf_delta_update ||\n         xd->update_mb_segmentation_map || xd->update_mb_segmentation_data;\n}\n\nint vp8_get_compressed_data(VP8_COMP *cpi, unsigned int *frame_flags,\n                            size_t *size, unsigned char *dest,\n                            unsigned char *dest_end, int64_t *time_stamp,\n                            int64_t *time_end, int flush) {\n  VP8_COMMON *cm;\n  struct vpx_usec_timer tsctimer;\n  struct vpx_usec_timer ticktimer;\n  struct vpx_usec_timer cmptimer;\n  YV12_BUFFER_CONFIG *force_src_buffer = NULL;\n\n  if (!cpi) return -1;\n\n  cm = &cpi->common;\n\n  vpx_usec_timer_start(&cmptimer);\n\n  cpi->source = NULL;\n\n#if !CONFIG_REALTIME_ONLY\n  /* Should we code an alternate reference frame */\n  if (cpi->oxcf.error_resilient_mode == 0 && cpi->oxcf.play_alternate &&\n      cpi->source_alt_ref_pending) {\n    if ((cpi->source = vp8_lookahead_peek(\n             cpi->lookahead, cpi->frames_till_gf_update_due, PEEK_FORWARD))) {\n      cpi->alt_ref_source = cpi->source;\n      if (cpi->oxcf.arnr_max_frames > 0) {\n        vp8_temporal_filter_prepare_c(cpi, cpi->frames_till_gf_update_due);\n        force_src_buffer = &cpi->alt_ref_buffer;\n      }\n      cpi->frames_till_alt_ref_frame = cpi->frames_till_gf_update_due;\n      cm->refresh_alt_ref_frame = 1;\n      cm->refresh_golden_frame = 0;\n      cm->refresh_last_frame = 0;\n      cm->show_frame = 0;\n      /* Clear Pending alt Ref flag. */\n      cpi->source_alt_ref_pending = 0;\n      cpi->is_src_frame_alt_ref = 0;\n    }\n  }\n#endif\n\n  if (!cpi->source) {\n    /* Read last frame source if we are encoding first pass. */\n    if (cpi->pass == 1 && cm->current_video_frame > 0) {\n      if ((cpi->last_source =\n               vp8_lookahead_peek(cpi->lookahead, 1, PEEK_BACKWARD)) == NULL) {\n        return -1;\n      }\n    }\n\n    if ((cpi->source = vp8_lookahead_pop(cpi->lookahead, flush))) {\n      cm->show_frame = 1;\n\n      cpi->is_src_frame_alt_ref =\n          cpi->alt_ref_source && (cpi->source == cpi->alt_ref_source);\n\n      if (cpi->is_src_frame_alt_ref) cpi->alt_ref_source = NULL;\n    }\n  }\n\n  if (cpi->source) {\n    cpi->Source = force_src_buffer ? force_src_buffer : &cpi->source->img;\n    cpi->un_scaled_source = cpi->Source;\n    *time_stamp = cpi->source->ts_start;\n    *time_end = cpi->source->ts_end;\n    *frame_flags = cpi->source->flags;\n\n    if (cpi->pass == 1 && cm->current_video_frame > 0) {\n      cpi->last_frame_unscaled_source = &cpi->last_source->img;\n    }\n  } else {\n    *size = 0;\n#if !CONFIG_REALTIME_ONLY\n\n    if (flush && cpi->pass == 1 && !cpi->twopass.first_pass_done) {\n      vp8_end_first_pass(cpi); /* get last stats packet */\n      cpi->twopass.first_pass_done = 1;\n    }\n\n#endif\n\n    return -1;\n  }\n\n  if (cpi->source->ts_start < cpi->first_time_stamp_ever) {\n    cpi->first_time_stamp_ever = cpi->source->ts_start;\n    cpi->last_end_time_stamp_seen = cpi->source->ts_start;\n  }\n\n  /* adjust frame rates based on timestamps given */\n  if (cm->show_frame) {\n    int64_t this_duration;\n    int step = 0;\n\n    if (cpi->source->ts_start == cpi->first_time_stamp_ever) {\n      this_duration = cpi->source->ts_end - cpi->source->ts_start;\n      step = 1;\n    } else {\n      int64_t last_duration;\n\n      this_duration = cpi->source->ts_end - cpi->last_end_time_stamp_seen;\n      last_duration = cpi->last_end_time_stamp_seen - cpi->last_time_stamp_seen;\n      // Cap this to avoid overflow of (this_duration - last_duration) * 10\n      this_duration = VPXMIN(this_duration, INT64_MAX / 10);\n      /* do a step update if the duration changes by 10% */\n      if (last_duration) {\n        step = (int)(((this_duration - last_duration) * 10 / last_duration));\n      }\n    }\n\n    if (this_duration) {\n      if (step) {\n        cpi->ref_framerate = 10000000.0 / this_duration;\n      } else {\n        double avg_duration, interval;\n\n        /* Average this frame's rate into the last second's average\n         * frame rate. If we haven't seen 1 second yet, then average\n         * over the whole interval seen.\n         */\n        interval = (double)(cpi->source->ts_end - cpi->first_time_stamp_ever);\n        if (interval > 10000000.0) interval = 10000000;\n\n        avg_duration = 10000000.0 / cpi->ref_framerate;\n        avg_duration *= (interval - avg_duration + this_duration);\n        avg_duration /= interval;\n\n        cpi->ref_framerate = 10000000.0 / avg_duration;\n      }\n#if CONFIG_MULTI_RES_ENCODING\n      if (cpi->oxcf.mr_total_resolutions > 1) {\n        LOWER_RES_FRAME_INFO *low_res_frame_info =\n            (LOWER_RES_FRAME_INFO *)cpi->oxcf.mr_low_res_mode_info;\n        // Frame rate should be the same for all spatial layers in\n        // multi-res-encoding (simulcast), so we constrain the frame for\n        // higher layers to be that of lowest resolution. This is needed\n        // as he application may decide to skip encoding a high layer and\n        // then start again, in which case a big jump in time-stamps will\n        // be received for that high layer, which will yield an incorrect\n        // frame rate (from time-stamp adjustment in above calculation).\n        if (cpi->oxcf.mr_encoder_id) {\n          if (!low_res_frame_info->skip_encoding_base_stream)\n            cpi->ref_framerate = low_res_frame_info->low_res_framerate;\n        } else {\n          // Keep track of frame rate for lowest resolution.\n          low_res_frame_info->low_res_framerate = cpi->ref_framerate;\n          // The base stream is being encoded so set skip flag to 0.\n          low_res_frame_info->skip_encoding_base_stream = 0;\n        }\n      }\n#endif\n      if (cpi->oxcf.number_of_layers > 1) {\n        unsigned int i;\n\n        /* Update frame rates for each layer */\n        assert(cpi->oxcf.number_of_layers <= VPX_TS_MAX_LAYERS);\n        for (i = 0; i < cpi->oxcf.number_of_layers && i < VPX_TS_MAX_LAYERS;\n             ++i) {\n          LAYER_CONTEXT *lc = &cpi->layer_context[i];\n          lc->framerate = cpi->ref_framerate / cpi->oxcf.rate_decimator[i];\n        }\n      } else {\n        vp8_new_framerate(cpi, cpi->ref_framerate);\n      }\n    }\n\n    cpi->last_time_stamp_seen = cpi->source->ts_start;\n    cpi->last_end_time_stamp_seen = cpi->source->ts_end;\n  }\n\n  if (cpi->oxcf.number_of_layers > 1) {\n    int layer;\n\n    vp8_update_layer_contexts(cpi);\n\n    /* Restore layer specific context & set frame rate */\n    if (cpi->temporal_layer_id >= 0) {\n      layer = cpi->temporal_layer_id;\n    } else {\n      layer =\n          cpi->oxcf\n              .layer_id[cpi->temporal_pattern_counter % cpi->oxcf.periodicity];\n    }\n    vp8_restore_layer_context(cpi, layer);\n    vp8_new_framerate(cpi, cpi->layer_context[layer].framerate);\n  }\n\n  if (cpi->compressor_speed == 2) {\n    vpx_usec_timer_start(&tsctimer);\n    vpx_usec_timer_start(&ticktimer);\n  }\n\n  cpi->lf_zeromv_pct = (cpi->zeromv_count * 100) / cm->MBs;\n\n#if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING\n  {\n    int i;\n    const int num_part = (1 << cm->multi_token_partition);\n    /* the available bytes in dest */\n    const unsigned long dest_size = dest_end - dest;\n    const int tok_part_buff_size = (dest_size * 9) / (10 * num_part);\n\n    unsigned char *dp = dest;\n\n    cpi->partition_d[0] = dp;\n    dp += dest_size / 10; /* reserve 1/10 for control partition */\n    cpi->partition_d_end[0] = dp;\n\n    for (i = 0; i < num_part; ++i) {\n      cpi->partition_d[i + 1] = dp;\n      dp += tok_part_buff_size;\n      cpi->partition_d_end[i + 1] = dp;\n    }\n  }\n#endif\n\n  /* start with a 0 size frame */\n  *size = 0;\n\n  /* Clear down mmx registers */\n  vpx_clear_system_state();\n\n  cm->frame_type = INTER_FRAME;\n  cm->frame_flags = *frame_flags;\n\n#if 0\n\n    if (cm->refresh_alt_ref_frame)\n    {\n        cm->refresh_golden_frame = 0;\n        cm->refresh_last_frame = 0;\n    }\n    else\n    {\n        cm->refresh_golden_frame = 0;\n        cm->refresh_last_frame = 1;\n    }\n\n#endif\n  /* find a free buffer for the new frame */\n  {\n    int i = 0;\n    for (; i < NUM_YV12_BUFFERS; ++i) {\n      if (!cm->yv12_fb[i].flags) {\n        cm->new_fb_idx = i;\n        break;\n      }\n    }\n\n    assert(i < NUM_YV12_BUFFERS);\n  }\n  switch (cpi->pass) {\n#if !CONFIG_REALTIME_ONLY\n    case 1: Pass1Encode(cpi); break;\n    case 2: Pass2Encode(cpi, size, dest, dest_end, frame_flags); break;\n#endif  // !CONFIG_REALTIME_ONLY\n    default:\n      encode_frame_to_data_rate(cpi, size, dest, dest_end, frame_flags);\n      break;\n  }\n\n  if (cpi->compressor_speed == 2) {\n    unsigned int duration, duration2;\n    vpx_usec_timer_mark(&tsctimer);\n    vpx_usec_timer_mark(&ticktimer);\n\n    duration = (int)(vpx_usec_timer_elapsed(&ticktimer));\n    duration2 = (unsigned int)((double)duration / 2);\n\n    if (cm->frame_type != KEY_FRAME) {\n      if (cpi->avg_encode_time == 0) {\n        cpi->avg_encode_time = duration;\n      } else {\n        cpi->avg_encode_time = (7 * cpi->avg_encode_time + duration) >> 3;\n      }\n    }\n\n    if (duration2) {\n      {\n        if (cpi->avg_pick_mode_time == 0) {\n          cpi->avg_pick_mode_time = duration2;\n        } else {\n          cpi->avg_pick_mode_time =\n              (7 * cpi->avg_pick_mode_time + duration2) >> 3;\n        }\n      }\n    }\n  }\n\n  if (cm->refresh_entropy_probs == 0) {\n    memcpy(&cm->fc, &cm->lfc, sizeof(cm->fc));\n  }\n\n  /* Save the contexts separately for alt ref, gold and last. */\n  /* (TODO jbb -> Optimize this with pointers to avoid extra copies. ) */\n  if (cm->refresh_alt_ref_frame) memcpy(&cpi->lfc_a, &cm->fc, sizeof(cm->fc));\n\n  if (cm->refresh_golden_frame) memcpy(&cpi->lfc_g, &cm->fc, sizeof(cm->fc));\n\n  if (cm->refresh_last_frame) memcpy(&cpi->lfc_n, &cm->fc, sizeof(cm->fc));\n\n  /* if it's a dropped frame honor the requests on subsequent frames */\n  if (*size > 0) {\n    cpi->droppable = !frame_is_reference(cpi);\n\n    /* return to normal state */\n    cm->refresh_entropy_probs = 1;\n    cm->refresh_alt_ref_frame = 0;\n    cm->refresh_golden_frame = 0;\n    cm->refresh_last_frame = 1;\n    cm->frame_type = INTER_FRAME;\n  }\n\n  /* Save layer specific state */\n  if (cpi->oxcf.number_of_layers > 1) vp8_save_layer_context(cpi);\n\n  vpx_usec_timer_mark(&cmptimer);\n  cpi->time_compress_data += vpx_usec_timer_elapsed(&cmptimer);\n\n  if (cpi->b_calculate_psnr && cpi->pass != 1 && cm->show_frame) {\n    generate_psnr_packet(cpi);\n  }\n\n#if CONFIG_INTERNAL_STATS\n\n  if (cpi->pass != 1) {\n    cpi->bytes += *size;\n\n    if (cm->show_frame) {\n      cpi->common.show_frame_mi = cpi->common.mi;\n      cpi->count++;\n\n      if (cpi->b_calculate_psnr) {\n        uint64_t ye, ue, ve;\n        double frame_psnr;\n        YV12_BUFFER_CONFIG *orig = cpi->Source;\n        YV12_BUFFER_CONFIG *recon = cpi->common.frame_to_show;\n        unsigned int y_width = cpi->common.Width;\n        unsigned int y_height = cpi->common.Height;\n        unsigned int uv_width = (y_width + 1) / 2;\n        unsigned int uv_height = (y_height + 1) / 2;\n        int y_samples = y_height * y_width;\n        int uv_samples = uv_height * uv_width;\n        int t_samples = y_samples + 2 * uv_samples;\n        double sq_error;\n\n        ye = calc_plane_error(orig->y_buffer, orig->y_stride, recon->y_buffer,\n                              recon->y_stride, y_width, y_height);\n\n        ue = calc_plane_error(orig->u_buffer, orig->uv_stride, recon->u_buffer,\n                              recon->uv_stride, uv_width, uv_height);\n\n        ve = calc_plane_error(orig->v_buffer, orig->uv_stride, recon->v_buffer,\n                              recon->uv_stride, uv_width, uv_height);\n\n        sq_error = (double)(ye + ue + ve);\n\n        frame_psnr = vpx_sse_to_psnr(t_samples, 255.0, sq_error);\n\n        cpi->total_y += vpx_sse_to_psnr(y_samples, 255.0, (double)ye);\n        cpi->total_u += vpx_sse_to_psnr(uv_samples, 255.0, (double)ue);\n        cpi->total_v += vpx_sse_to_psnr(uv_samples, 255.0, (double)ve);\n        cpi->total_sq_error += sq_error;\n        cpi->total += frame_psnr;\n#if CONFIG_POSTPROC\n        {\n          YV12_BUFFER_CONFIG *pp = &cm->post_proc_buffer;\n          double sq_error2;\n          double frame_psnr2, frame_ssim2 = 0;\n          double weight = 0;\n\n          vp8_deblock(cm, cm->frame_to_show, &cm->post_proc_buffer,\n                      cm->filter_level * 10 / 6);\n          vpx_clear_system_state();\n\n          ye = calc_plane_error(orig->y_buffer, orig->y_stride, pp->y_buffer,\n                                pp->y_stride, y_width, y_height);\n\n          ue = calc_plane_error(orig->u_buffer, orig->uv_stride, pp->u_buffer,\n                                pp->uv_stride, uv_width, uv_height);\n\n          ve = calc_plane_error(orig->v_buffer, orig->uv_stride, pp->v_buffer,\n                                pp->uv_stride, uv_width, uv_height);\n\n          sq_error2 = (double)(ye + ue + ve);\n\n          frame_psnr2 = vpx_sse_to_psnr(t_samples, 255.0, sq_error2);\n\n          cpi->totalp_y += vpx_sse_to_psnr(y_samples, 255.0, (double)ye);\n          cpi->totalp_u += vpx_sse_to_psnr(uv_samples, 255.0, (double)ue);\n          cpi->totalp_v += vpx_sse_to_psnr(uv_samples, 255.0, (double)ve);\n          cpi->total_sq_error2 += sq_error2;\n          cpi->totalp += frame_psnr2;\n\n          frame_ssim2 =\n              vpx_calc_ssim(cpi->Source, &cm->post_proc_buffer, &weight);\n\n          cpi->summed_quality += frame_ssim2 * weight;\n          cpi->summed_weights += weight;\n\n          if (cpi->oxcf.number_of_layers > 1) {\n            unsigned int i;\n\n            for (i = cpi->current_layer; i < cpi->oxcf.number_of_layers; ++i) {\n              cpi->frames_in_layer[i]++;\n\n              cpi->bytes_in_layer[i] += *size;\n              cpi->sum_psnr[i] += frame_psnr;\n              cpi->sum_psnr_p[i] += frame_psnr2;\n              cpi->total_error2[i] += sq_error;\n              cpi->total_error2_p[i] += sq_error2;\n              cpi->sum_ssim[i] += frame_ssim2 * weight;\n              cpi->sum_weights[i] += weight;\n            }\n          }\n        }\n#endif\n      }\n    }\n  }\n\n#if 0\n\n    if (cpi->common.frame_type != 0 && cpi->common.base_qindex == cpi->oxcf.worst_allowed_q)\n    {\n        skiptruecount += cpi->skip_true_count;\n        skipfalsecount += cpi->skip_false_count;\n    }\n\n#endif\n#if 0\n\n    if (cpi->pass != 1)\n    {\n        FILE *f = fopen(\"skip.stt\", \"a\");\n        fprintf(f, \"frame:%4d flags:%4x Q:%4d P:%4d Size:%5d\\n\", cpi->common.current_video_frame, *frame_flags, cpi->common.base_qindex, cpi->prob_skip_false, *size);\n\n        if (cpi->is_src_frame_alt_ref == 1)\n            fprintf(f, \"skipcount: %4d framesize: %d\\n\", cpi->skip_true_count , *size);\n\n        fclose(f);\n    }\n\n#endif\n#endif\n\n  cpi->common.error.setjmp = 0;\n\n#if CONFIG_MULTITHREAD\n  /* wait for the lpf thread done */\n  if (vpx_atomic_load_acquire(&cpi->b_multi_threaded) && cpi->b_lpf_running) {\n    sem_wait(&cpi->h_event_end_lpf);\n    cpi->b_lpf_running = 0;\n  }\n#endif\n\n  return 0;\n}\n\nint vp8_get_preview_raw_frame(VP8_COMP *cpi, YV12_BUFFER_CONFIG *dest,\n                              vp8_ppflags_t *flags) {\n  if (cpi->common.refresh_alt_ref_frame) {\n    return -1;\n  } else {\n    int ret;\n\n#if CONFIG_POSTPROC\n    cpi->common.show_frame_mi = cpi->common.mi;\n    ret = vp8_post_proc_frame(&cpi->common, dest, flags);\n#else\n    (void)flags;\n\n    if (cpi->common.frame_to_show) {\n      *dest = *cpi->common.frame_to_show;\n      dest->y_width = cpi->common.Width;\n      dest->y_height = cpi->common.Height;\n      dest->uv_height = cpi->common.Height / 2;\n      ret = 0;\n    } else {\n      ret = -1;\n    }\n\n#endif\n    vpx_clear_system_state();\n    return ret;\n  }\n}\n\nint vp8_set_roimap(VP8_COMP *cpi, unsigned char *map, unsigned int rows,\n                   unsigned int cols, int delta_q[4], int delta_lf[4],\n                   unsigned int threshold[4]) {\n  signed char feature_data[MB_LVL_MAX][MAX_MB_SEGMENTS];\n  int internal_delta_q[MAX_MB_SEGMENTS];\n  const int range = 63;\n  int i;\n\n  // Check number of rows and columns match\n  if (cpi->common.mb_rows != (int)rows || cpi->common.mb_cols != (int)cols) {\n    return -1;\n  }\n\n  for (i = 0; i < MAX_MB_SEGMENTS; ++i) {\n    // Note abs() alone can't be used as the behavior of abs(INT_MIN) is\n    // undefined.\n    if (delta_q[i] > range || delta_q[i] < -range || delta_lf[i] > range ||\n        delta_lf[i] < -range) {\n      return -1;\n    }\n  }\n\n  // Also disable segmentation if no deltas are specified.\n  if (!map || (delta_q[0] == 0 && delta_q[1] == 0 && delta_q[2] == 0 &&\n               delta_q[3] == 0 && delta_lf[0] == 0 && delta_lf[1] == 0 &&\n               delta_lf[2] == 0 && delta_lf[3] == 0 && threshold[0] == 0 &&\n               threshold[1] == 0 && threshold[2] == 0 && threshold[3] == 0)) {\n    disable_segmentation(cpi);\n    return 0;\n  }\n\n  // Translate the external delta q values to internal values.\n  for (i = 0; i < MAX_MB_SEGMENTS; ++i) {\n    internal_delta_q[i] =\n        (delta_q[i] >= 0) ? q_trans[delta_q[i]] : -q_trans[-delta_q[i]];\n  }\n\n  /* Set the segmentation Map */\n  set_segmentation_map(cpi, map);\n\n  /* Activate segmentation. */\n  enable_segmentation(cpi);\n\n  /* Set up the quant segment data */\n  feature_data[MB_LVL_ALT_Q][0] = internal_delta_q[0];\n  feature_data[MB_LVL_ALT_Q][1] = internal_delta_q[1];\n  feature_data[MB_LVL_ALT_Q][2] = internal_delta_q[2];\n  feature_data[MB_LVL_ALT_Q][3] = internal_delta_q[3];\n\n  /* Set up the loop segment data s */\n  feature_data[MB_LVL_ALT_LF][0] = delta_lf[0];\n  feature_data[MB_LVL_ALT_LF][1] = delta_lf[1];\n  feature_data[MB_LVL_ALT_LF][2] = delta_lf[2];\n  feature_data[MB_LVL_ALT_LF][3] = delta_lf[3];\n\n  cpi->segment_encode_breakout[0] = threshold[0];\n  cpi->segment_encode_breakout[1] = threshold[1];\n  cpi->segment_encode_breakout[2] = threshold[2];\n  cpi->segment_encode_breakout[3] = threshold[3];\n\n  /* Initialise the feature data structure */\n  set_segment_data(cpi, &feature_data[0][0], SEGMENT_DELTADATA);\n\n  if (threshold[0] != 0 || threshold[1] != 0 || threshold[2] != 0 ||\n      threshold[3] != 0)\n    cpi->use_roi_static_threshold = 1;\n  cpi->cyclic_refresh_mode_enabled = 0;\n\n  return 0;\n}\n\nint vp8_set_active_map(VP8_COMP *cpi, unsigned char *map, unsigned int rows,\n                       unsigned int cols) {\n  if ((int)rows == cpi->common.mb_rows && (int)cols == cpi->common.mb_cols) {\n    if (map) {\n      memcpy(cpi->active_map, map, rows * cols);\n      cpi->active_map_enabled = 1;\n    } else {\n      cpi->active_map_enabled = 0;\n    }\n\n    return 0;\n  } else {\n    return -1;\n  }\n}\n\nint vp8_set_internal_size(VP8_COMP *cpi, VPX_SCALING_MODE horiz_mode,\n                          VPX_SCALING_MODE vert_mode) {\n  if (horiz_mode <= VP8E_ONETWO) {\n    cpi->common.horiz_scale = horiz_mode;\n  } else {\n    return -1;\n  }\n\n  if (vert_mode <= VP8E_ONETWO) {\n    cpi->common.vert_scale = vert_mode;\n  } else {\n    return -1;\n  }\n\n  return 0;\n}\n\nint vp8_calc_ss_err(YV12_BUFFER_CONFIG *source, YV12_BUFFER_CONFIG *dest) {\n  int i, j;\n  int Total = 0;\n\n  unsigned char *src = source->y_buffer;\n  unsigned char *dst = dest->y_buffer;\n\n  /* Loop through the Y plane raw and reconstruction data summing\n   * (square differences)\n   */\n  for (i = 0; i < source->y_height; i += 16) {\n    for (j = 0; j < source->y_width; j += 16) {\n      unsigned int sse;\n      Total += vpx_mse16x16(src + j, source->y_stride, dst + j, dest->y_stride,\n                            &sse);\n    }\n\n    src += 16 * source->y_stride;\n    dst += 16 * dest->y_stride;\n  }\n\n  return Total;\n}\n\nint vp8_get_quantizer(VP8_COMP *cpi) { return cpi->common.base_qindex; }\n"], "fixing_code": ["/*\n *  Copyright (c) 2016 The WebM project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree. An additional intellectual property rights grant can be found\n *  in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */\n\n#include <climits>\n#include <cstring>\n#include <initializer_list>\n#include <new>\n\n#include \"third_party/googletest/src/include/gtest/gtest.h\"\n#include \"test/codec_factory.h\"\n#include \"test/encode_test_driver.h\"\n#include \"test/i420_video_source.h\"\n#include \"test/video_source.h\"\n\n#include \"./vpx_config.h\"\n#include \"vpx/vp8cx.h\"\n#include \"vpx/vpx_tpl.h\"\n\nnamespace {\n\nconst vpx_codec_iface_t *kCodecIfaces[] = {\n#if CONFIG_VP8_ENCODER\n  &vpx_codec_vp8_cx_algo,\n#endif\n#if CONFIG_VP9_ENCODER\n  &vpx_codec_vp9_cx_algo,\n#endif\n};\n\nbool IsVP9(const vpx_codec_iface_t *iface) {\n  static const char kVP9Name[] = \"WebM Project VP9\";\n  return strncmp(kVP9Name, vpx_codec_iface_name(iface), sizeof(kVP9Name) - 1) ==\n         0;\n}\n\nTEST(EncodeAPI, InvalidParams) {\n  uint8_t buf[1] = { 0 };\n  vpx_image_t img;\n  vpx_codec_ctx_t enc;\n  vpx_codec_enc_cfg_t cfg;\n\n  EXPECT_EQ(&img, vpx_img_wrap(&img, VPX_IMG_FMT_I420, 1, 1, 1, buf));\n\n  EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n            vpx_codec_enc_init(nullptr, nullptr, nullptr, 0));\n  EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n            vpx_codec_enc_init(&enc, nullptr, nullptr, 0));\n  EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n            vpx_codec_encode(nullptr, nullptr, 0, 0, 0, 0));\n  EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n            vpx_codec_encode(nullptr, &img, 0, 0, 0, 0));\n  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, vpx_codec_destroy(nullptr));\n  EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n            vpx_codec_enc_config_default(nullptr, nullptr, 0));\n  EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n            vpx_codec_enc_config_default(nullptr, &cfg, 0));\n  EXPECT_NE(vpx_codec_error(nullptr), nullptr);\n\n  for (const auto *iface : kCodecIfaces) {\n    SCOPED_TRACE(vpx_codec_iface_name(iface));\n    EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n              vpx_codec_enc_init(nullptr, iface, nullptr, 0));\n    EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n              vpx_codec_enc_init(&enc, iface, nullptr, 0));\n    EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n              vpx_codec_enc_config_default(iface, &cfg, 1));\n\n    EXPECT_EQ(VPX_CODEC_OK, vpx_codec_enc_config_default(iface, &cfg, 0));\n    EXPECT_EQ(VPX_CODEC_OK, vpx_codec_enc_init(&enc, iface, &cfg, 0));\n    EXPECT_EQ(VPX_CODEC_OK, vpx_codec_encode(&enc, nullptr, 0, 0, 0, 0));\n\n    EXPECT_EQ(VPX_CODEC_OK, vpx_codec_destroy(&enc));\n  }\n}\n\nTEST(EncodeAPI, HighBitDepthCapability) {\n// VP8 should not claim VP9 HBD as a capability.\n#if CONFIG_VP8_ENCODER\n  const vpx_codec_caps_t vp8_caps = vpx_codec_get_caps(&vpx_codec_vp8_cx_algo);\n  EXPECT_EQ(vp8_caps & VPX_CODEC_CAP_HIGHBITDEPTH, 0);\n#endif\n\n#if CONFIG_VP9_ENCODER\n  const vpx_codec_caps_t vp9_caps = vpx_codec_get_caps(&vpx_codec_vp9_cx_algo);\n#if CONFIG_VP9_HIGHBITDEPTH\n  EXPECT_EQ(vp9_caps & VPX_CODEC_CAP_HIGHBITDEPTH, VPX_CODEC_CAP_HIGHBITDEPTH);\n#else\n  EXPECT_EQ(vp9_caps & VPX_CODEC_CAP_HIGHBITDEPTH, 0);\n#endif\n#endif\n}\n\n#if CONFIG_VP8_ENCODER\nTEST(EncodeAPI, ImageSizeSetting) {\n  const int width = 711;\n  const int height = 360;\n  const int bps = 12;\n  vpx_image_t img;\n  vpx_codec_ctx_t enc;\n  vpx_codec_enc_cfg_t cfg;\n  uint8_t *img_buf = reinterpret_cast<uint8_t *>(\n      calloc(width * height * bps / 8, sizeof(*img_buf)));\n  vpx_codec_enc_config_default(vpx_codec_vp8_cx(), &cfg, 0);\n\n  cfg.g_w = width;\n  cfg.g_h = height;\n\n  vpx_img_wrap(&img, VPX_IMG_FMT_I420, width, height, 1, img_buf);\n\n  vpx_codec_enc_init(&enc, vpx_codec_vp8_cx(), &cfg, 0);\n\n  EXPECT_EQ(VPX_CODEC_OK, vpx_codec_encode(&enc, &img, 0, 1, 0, 0));\n\n  free(img_buf);\n\n  vpx_codec_destroy(&enc);\n}\n#endif\n\n// Set up 2 spatial streams with 2 temporal layers per stream, and generate\n// invalid configuration by setting the temporal layer rate allocation\n// (ts_target_bitrate[]) to 0 for both layers. This should fail independent of\n// CONFIG_MULTI_RES_ENCODING.\nTEST(EncodeAPI, MultiResEncode) {\n  const int width = 1280;\n  const int height = 720;\n  const int width_down = width / 2;\n  const int height_down = height / 2;\n  const int target_bitrate = 1000;\n  const int framerate = 30;\n\n  for (const auto *iface : kCodecIfaces) {\n    vpx_codec_ctx_t enc[2];\n    vpx_codec_enc_cfg_t cfg[2];\n    vpx_rational_t dsf[2] = { { 2, 1 }, { 2, 1 } };\n\n    memset(enc, 0, sizeof(enc));\n\n    for (int i = 0; i < 2; i++) {\n      vpx_codec_enc_config_default(iface, &cfg[i], 0);\n    }\n\n    /* Highest-resolution encoder settings */\n    cfg[0].g_w = width;\n    cfg[0].g_h = height;\n    cfg[0].rc_dropframe_thresh = 0;\n    cfg[0].rc_end_usage = VPX_CBR;\n    cfg[0].rc_resize_allowed = 0;\n    cfg[0].rc_min_quantizer = 2;\n    cfg[0].rc_max_quantizer = 56;\n    cfg[0].rc_undershoot_pct = 100;\n    cfg[0].rc_overshoot_pct = 15;\n    cfg[0].rc_buf_initial_sz = 500;\n    cfg[0].rc_buf_optimal_sz = 600;\n    cfg[0].rc_buf_sz = 1000;\n    cfg[0].g_error_resilient = 1; /* Enable error resilient mode */\n    cfg[0].g_lag_in_frames = 0;\n\n    cfg[0].kf_mode = VPX_KF_AUTO;\n    cfg[0].kf_min_dist = 3000;\n    cfg[0].kf_max_dist = 3000;\n\n    cfg[0].rc_target_bitrate = target_bitrate; /* Set target bitrate */\n    cfg[0].g_timebase.num = 1;                 /* Set fps */\n    cfg[0].g_timebase.den = framerate;\n\n    memcpy(&cfg[1], &cfg[0], sizeof(cfg[0]));\n    cfg[1].rc_target_bitrate = 500;\n    cfg[1].g_w = width_down;\n    cfg[1].g_h = height_down;\n\n    for (int i = 0; i < 2; i++) {\n      cfg[i].ts_number_layers = 2;\n      cfg[i].ts_periodicity = 2;\n      cfg[i].ts_rate_decimator[0] = 2;\n      cfg[i].ts_rate_decimator[1] = 1;\n      cfg[i].ts_layer_id[0] = 0;\n      cfg[i].ts_layer_id[1] = 1;\n      // Invalid parameters.\n      cfg[i].ts_target_bitrate[0] = 0;\n      cfg[i].ts_target_bitrate[1] = 0;\n    }\n\n    // VP9 should report incapable, VP8 invalid for all configurations.\n    EXPECT_EQ(IsVP9(iface) ? VPX_CODEC_INCAPABLE : VPX_CODEC_INVALID_PARAM,\n              vpx_codec_enc_init_multi(&enc[0], iface, &cfg[0], 2, 0, &dsf[0]));\n\n    for (int i = 0; i < 2; i++) {\n      vpx_codec_destroy(&enc[i]);\n    }\n  }\n}\n\nTEST(EncodeAPI, SetRoi) {\n  static struct {\n    const vpx_codec_iface_t *iface;\n    int ctrl_id;\n  } kCodecs[] = {\n#if CONFIG_VP8_ENCODER\n    { &vpx_codec_vp8_cx_algo, VP8E_SET_ROI_MAP },\n#endif\n#if CONFIG_VP9_ENCODER\n    { &vpx_codec_vp9_cx_algo, VP9E_SET_ROI_MAP },\n#endif\n  };\n  constexpr int kWidth = 64;\n  constexpr int kHeight = 64;\n\n  for (const auto &codec : kCodecs) {\n    SCOPED_TRACE(vpx_codec_iface_name(codec.iface));\n    vpx_codec_ctx_t enc;\n    vpx_codec_enc_cfg_t cfg;\n\n    EXPECT_EQ(vpx_codec_enc_config_default(codec.iface, &cfg, 0), VPX_CODEC_OK);\n    cfg.g_w = kWidth;\n    cfg.g_h = kHeight;\n    EXPECT_EQ(vpx_codec_enc_init(&enc, codec.iface, &cfg, 0), VPX_CODEC_OK);\n\n    vpx_roi_map_t roi = {};\n    uint8_t roi_map[kWidth * kHeight] = {};\n    if (IsVP9(codec.iface)) {\n      roi.rows = (cfg.g_w + 7) >> 3;\n      roi.cols = (cfg.g_h + 7) >> 3;\n    } else {\n      roi.rows = (cfg.g_w + 15) >> 4;\n      roi.cols = (cfg.g_h + 15) >> 4;\n    }\n    EXPECT_EQ(vpx_codec_control_(&enc, codec.ctrl_id, &roi), VPX_CODEC_OK);\n\n    roi.roi_map = roi_map;\n    // VP8 only. This value isn't range checked.\n    roi.static_threshold[1] = 1000;\n    roi.static_threshold[2] = UINT_MAX / 2 + 1;\n    roi.static_threshold[3] = UINT_MAX;\n\n    for (const auto delta : { -63, -1, 0, 1, 63 }) {\n      for (int i = 0; i < 8; ++i) {\n        roi.delta_q[i] = delta;\n        roi.delta_lf[i] = delta;\n        // VP9 only.\n        roi.skip[i] ^= 1;\n        roi.ref_frame[i] = (roi.ref_frame[i] + 1) % 4;\n        EXPECT_EQ(vpx_codec_control_(&enc, codec.ctrl_id, &roi), VPX_CODEC_OK);\n      }\n    }\n\n    vpx_codec_err_t expected_error;\n    for (const auto delta : { -64, 64, INT_MIN, INT_MAX }) {\n      expected_error = VPX_CODEC_INVALID_PARAM;\n      for (int i = 0; i < 8; ++i) {\n        roi.delta_q[i] = delta;\n        // The max segment count for VP8 is 4, the remainder of the entries are\n        // ignored.\n        if (i >= 4 && !IsVP9(codec.iface)) expected_error = VPX_CODEC_OK;\n\n        EXPECT_EQ(vpx_codec_control_(&enc, codec.ctrl_id, &roi), expected_error)\n            << \"delta_q[\" << i << \"]: \" << delta;\n        roi.delta_q[i] = 0;\n\n        roi.delta_lf[i] = delta;\n        EXPECT_EQ(vpx_codec_control_(&enc, codec.ctrl_id, &roi), expected_error)\n            << \"delta_lf[\" << i << \"]: \" << delta;\n        roi.delta_lf[i] = 0;\n      }\n    }\n\n    // VP8 should ignore skip[] and ref_frame[] values.\n    expected_error =\n        IsVP9(codec.iface) ? VPX_CODEC_INVALID_PARAM : VPX_CODEC_OK;\n    for (const auto skip : { -2, 2, INT_MIN, INT_MAX }) {\n      for (int i = 0; i < 8; ++i) {\n        roi.skip[i] = skip;\n        EXPECT_EQ(vpx_codec_control_(&enc, codec.ctrl_id, &roi), expected_error)\n            << \"skip[\" << i << \"]: \" << skip;\n        roi.skip[i] = 0;\n      }\n    }\n\n    // VP9 allows negative values to be used to disable segmentation.\n    for (int ref_frame = -3; ref_frame < 0; ++ref_frame) {\n      for (int i = 0; i < 8; ++i) {\n        roi.ref_frame[i] = ref_frame;\n        EXPECT_EQ(vpx_codec_control_(&enc, codec.ctrl_id, &roi), VPX_CODEC_OK)\n            << \"ref_frame[\" << i << \"]: \" << ref_frame;\n        roi.ref_frame[i] = 0;\n      }\n    }\n\n    for (const auto ref_frame : { 4, INT_MIN, INT_MAX }) {\n      for (int i = 0; i < 8; ++i) {\n        roi.ref_frame[i] = ref_frame;\n        EXPECT_EQ(vpx_codec_control_(&enc, codec.ctrl_id, &roi), expected_error)\n            << \"ref_frame[\" << i << \"]: \" << ref_frame;\n        roi.ref_frame[i] = 0;\n      }\n    }\n\n    EXPECT_EQ(vpx_codec_destroy(&enc), VPX_CODEC_OK);\n  }\n}\n\nvoid InitCodec(const vpx_codec_iface_t &iface, int width, int height,\n               vpx_codec_ctx_t *enc, vpx_codec_enc_cfg_t *cfg) {\n  cfg->g_w = width;\n  cfg->g_h = height;\n  cfg->g_lag_in_frames = 0;\n  cfg->g_pass = VPX_RC_ONE_PASS;\n  ASSERT_EQ(vpx_codec_enc_init(enc, &iface, cfg, 0), VPX_CODEC_OK);\n\n  ASSERT_EQ(vpx_codec_control_(enc, VP8E_SET_CPUUSED, 2), VPX_CODEC_OK);\n}\n\n// Encodes 1 frame of size |cfg.g_w| x |cfg.g_h| setting |enc|'s configuration\n// to |cfg|.\nvoid EncodeWithConfig(const vpx_codec_enc_cfg_t &cfg, vpx_codec_ctx_t *enc) {\n  libvpx_test::DummyVideoSource video;\n  video.SetSize(cfg.g_w, cfg.g_h);\n  video.Begin();\n  EXPECT_EQ(vpx_codec_enc_config_set(enc, &cfg), VPX_CODEC_OK)\n      << vpx_codec_error_detail(enc);\n\n  EXPECT_EQ(vpx_codec_encode(enc, video.img(), video.pts(), video.duration(),\n                             /*flags=*/0, VPX_DL_GOOD_QUALITY),\n            VPX_CODEC_OK)\n      << vpx_codec_error_detail(enc);\n}\n\nTEST(EncodeAPI, ConfigChangeThreadCount) {\n  constexpr int kWidth = 1920;\n  constexpr int kHeight = 1080;\n\n  for (const auto *iface : kCodecIfaces) {\n    SCOPED_TRACE(vpx_codec_iface_name(iface));\n    for (int i = 0; i < (IsVP9(iface) ? 2 : 1); ++i) {\n      vpx_codec_enc_cfg_t cfg = {};\n      struct Encoder {\n        ~Encoder() { EXPECT_EQ(vpx_codec_destroy(&ctx), VPX_CODEC_OK); }\n        vpx_codec_ctx_t ctx = {};\n      } enc;\n\n      ASSERT_EQ(vpx_codec_enc_config_default(iface, &cfg, 0), VPX_CODEC_OK);\n      EXPECT_NO_FATAL_FAILURE(\n          InitCodec(*iface, kWidth, kHeight, &enc.ctx, &cfg));\n      if (IsVP9(iface)) {\n        EXPECT_EQ(vpx_codec_control_(&enc.ctx, VP9E_SET_TILE_COLUMNS, 6),\n                  VPX_CODEC_OK);\n        EXPECT_EQ(vpx_codec_control_(&enc.ctx, VP9E_SET_ROW_MT, i),\n                  VPX_CODEC_OK);\n      }\n\n      for (const auto threads : { 1, 4, 8, 6, 2, 1 }) {\n        cfg.g_threads = threads;\n        EXPECT_NO_FATAL_FAILURE(EncodeWithConfig(cfg, &enc.ctx))\n            << \"iteration: \" << i << \" threads: \" << threads;\n      }\n    }\n  }\n}\n\nTEST(EncodeAPI, ConfigResizeChangeThreadCount) {\n  constexpr int kInitWidth = 1024;\n  constexpr int kInitHeight = 1024;\n\n  for (const auto *iface : kCodecIfaces) {\n    SCOPED_TRACE(vpx_codec_iface_name(iface));\n    for (int i = 0; i < (IsVP9(iface) ? 2 : 1); ++i) {\n      vpx_codec_enc_cfg_t cfg = {};\n      struct Encoder {\n        ~Encoder() { EXPECT_EQ(vpx_codec_destroy(&ctx), VPX_CODEC_OK); }\n        vpx_codec_ctx_t ctx = {};\n      } enc;\n\n      ASSERT_EQ(vpx_codec_enc_config_default(iface, &cfg, 0), VPX_CODEC_OK);\n      // Start in threaded mode to ensure resolution and thread related\n      // allocations are updated correctly across changes in resolution and\n      // thread counts. See https://crbug.com/1486441.\n      cfg.g_threads = 4;\n      EXPECT_NO_FATAL_FAILURE(\n          InitCodec(*iface, kInitWidth, kInitHeight, &enc.ctx, &cfg));\n      if (IsVP9(iface)) {\n        EXPECT_EQ(vpx_codec_control_(&enc.ctx, VP9E_SET_TILE_COLUMNS, 6),\n                  VPX_CODEC_OK);\n        EXPECT_EQ(vpx_codec_control_(&enc.ctx, VP9E_SET_ROW_MT, i),\n                  VPX_CODEC_OK);\n      }\n\n      cfg.g_w = 1000;\n      cfg.g_h = 608;\n      EXPECT_EQ(vpx_codec_enc_config_set(&enc.ctx, &cfg), VPX_CODEC_OK)\n          << vpx_codec_error_detail(&enc.ctx);\n\n      cfg.g_w = 16;\n      cfg.g_h = 720;\n\n      for (const auto threads : { 1, 4, 8, 6, 2, 1 }) {\n        cfg.g_threads = threads;\n        EXPECT_NO_FATAL_FAILURE(EncodeWithConfig(cfg, &enc.ctx))\n            << \"iteration: \" << i << \" threads: \" << threads;\n      }\n    }\n  }\n}\n\n#if CONFIG_VP9_ENCODER\nclass EncodeApiGetTplStatsTest\n    : public ::libvpx_test::EncoderTest,\n      public ::testing::TestWithParam<const libvpx_test::CodecFactory *> {\n public:\n  EncodeApiGetTplStatsTest() : EncoderTest(GetParam()), test_io_(false) {}\n  ~EncodeApiGetTplStatsTest() override = default;\n\n protected:\n  void SetUp() override {\n    InitializeConfig();\n    SetMode(::libvpx_test::kTwoPassGood);\n  }\n\n  void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                          ::libvpx_test::Encoder *encoder) override {\n    if (video->frame() == 0) {\n      encoder->Control(VP9E_SET_TPL, 1);\n    }\n  }\n\n  vpx_codec_err_t AllocateTplList(VpxTplGopStats *data) {\n    // Allocate MAX_ARF_GOP_SIZE (50) * sizeof(VpxTplFrameStats) that will be\n    // filled by VP9E_GET_TPL_STATS.\n    // MAX_ARF_GOP_SIZE is used here because the test doesn't know the size of\n    // each GOP before getting TPL stats from the encoder.\n    data->size = 50;\n    data->frame_stats_list =\n        static_cast<VpxTplFrameStats *>(calloc(50, sizeof(VpxTplFrameStats)));\n    if (data->frame_stats_list == nullptr) return VPX_CODEC_MEM_ERROR;\n    return VPX_CODEC_OK;\n  }\n\n  void CompareTplGopStats(const VpxTplGopStats &ref_gop_stats,\n                          const VpxTplGopStats &test_gop_stats) {\n    ASSERT_EQ(ref_gop_stats.size, test_gop_stats.size);\n    for (int frame = 0; frame < ref_gop_stats.size; frame++) {\n      const VpxTplFrameStats &ref_frame_stats =\n          ref_gop_stats.frame_stats_list[frame];\n      const VpxTplFrameStats &test_frame_stats =\n          test_gop_stats.frame_stats_list[frame];\n      ASSERT_EQ(ref_frame_stats.num_blocks, test_frame_stats.num_blocks);\n      ASSERT_EQ(ref_frame_stats.frame_width, test_frame_stats.frame_width);\n      ASSERT_EQ(ref_frame_stats.frame_height, test_frame_stats.frame_height);\n      for (int block = 0; block < ref_frame_stats.num_blocks; block++) {\n        const VpxTplBlockStats &ref_block_stats =\n            ref_frame_stats.block_stats_list[block];\n        const VpxTplBlockStats &test_block_stats =\n            test_frame_stats.block_stats_list[block];\n        ASSERT_EQ(ref_block_stats.inter_cost, test_block_stats.inter_cost);\n        ASSERT_EQ(ref_block_stats.intra_cost, test_block_stats.intra_cost);\n        ASSERT_EQ(ref_block_stats.mv_c, test_block_stats.mv_c);\n        ASSERT_EQ(ref_block_stats.mv_r, test_block_stats.mv_r);\n        ASSERT_EQ(ref_block_stats.recrf_dist, test_block_stats.recrf_dist);\n        ASSERT_EQ(ref_block_stats.recrf_rate, test_block_stats.recrf_rate);\n        ASSERT_EQ(ref_block_stats.ref_frame_index,\n                  test_block_stats.ref_frame_index);\n      }\n    }\n  }\n\n  void PostEncodeFrameHook(::libvpx_test::Encoder *encoder) override {\n    ::libvpx_test::CxDataIterator iter = encoder->GetCxData();\n    while (const vpx_codec_cx_pkt_t *pkt = iter.Next()) {\n      switch (pkt->kind) {\n        case VPX_CODEC_CX_FRAME_PKT: {\n          VpxTplGopStats tpl_stats;\n          EXPECT_EQ(AllocateTplList(&tpl_stats), VPX_CODEC_OK);\n          encoder->Control(VP9E_GET_TPL_STATS, &tpl_stats);\n          bool stats_not_all_zero = false;\n          for (int i = 0; i < tpl_stats.size; i++) {\n            VpxTplFrameStats *frame_stats_list = tpl_stats.frame_stats_list;\n            if (frame_stats_list[i].frame_width != 0) {\n              ASSERT_EQ(frame_stats_list[i].frame_width, width_);\n              ASSERT_EQ(frame_stats_list[i].frame_height, height_);\n              ASSERT_GT(frame_stats_list[i].num_blocks, 0);\n              ASSERT_NE(frame_stats_list[i].block_stats_list, nullptr);\n              stats_not_all_zero = true;\n            }\n          }\n          ASSERT_TRUE(stats_not_all_zero);\n          if (test_io_ && tpl_stats.size > 0) {\n            libvpx_test::TempOutFile *temp_out_file =\n                new (std::nothrow) libvpx_test::TempOutFile(\"w+\");\n            ASSERT_NE(temp_out_file, nullptr);\n            ASSERT_NE(temp_out_file->file(), nullptr);\n            vpx_write_tpl_gop_stats(temp_out_file->file(), &tpl_stats);\n            rewind(temp_out_file->file());\n            VpxTplGopStats gop_stats_io;\n            ASSERT_EQ(\n                vpx_read_tpl_gop_stats(temp_out_file->file(), &gop_stats_io),\n                VPX_CODEC_OK);\n            CompareTplGopStats(gop_stats_io, tpl_stats);\n            vpx_free_tpl_gop_stats(&gop_stats_io);\n            delete temp_out_file;\n          }\n          free(tpl_stats.frame_stats_list);\n          break;\n        }\n        default: break;\n      }\n    }\n  }\n\n  int width_;\n  int height_;\n  bool test_io_;\n};\n\nTEST_P(EncodeApiGetTplStatsTest, GetTplStats) {\n  cfg_.g_lag_in_frames = 25;\n  width_ = 352;\n  height_ = 288;\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", width_,\n                                       height_, 30, 1, 0, 50);\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n}\n\nTEST_P(EncodeApiGetTplStatsTest, GetTplStatsIO) {\n  cfg_.g_lag_in_frames = 25;\n  width_ = 352;\n  height_ = 288;\n  test_io_ = true;\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", width_,\n                                       height_, 30, 1, 0, 50);\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n}\n\nINSTANTIATE_TEST_SUITE_P(\n    VP9, EncodeApiGetTplStatsTest,\n    ::testing::Values(\n        static_cast<const libvpx_test::CodecFactory *>(&libvpx_test::kVP9)));\n#endif  // CONFIG_VP9_ENCODER\n\n}  // namespace\n", "/*\n *  Copyright (c) 2010 The WebM project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree. An additional intellectual property rights grant can be found\n *  in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */\n\n#include \"vpx_config.h\"\n#include \"./vpx_scale_rtcd.h\"\n#include \"./vpx_dsp_rtcd.h\"\n#include \"./vp8_rtcd.h\"\n#include \"bitstream.h\"\n#include \"vp8/common/onyxc_int.h\"\n#include \"vp8/common/blockd.h\"\n#include \"onyx_int.h\"\n#include \"vp8/common/systemdependent.h\"\n#include \"vp8/common/vp8_skin_detection.h\"\n#include \"vp8/encoder/quantize.h\"\n#include \"vp8/common/alloccommon.h\"\n#include \"mcomp.h\"\n#include \"firstpass.h\"\n#include \"vpx_dsp/psnr.h\"\n#include \"vpx_scale/vpx_scale.h\"\n#include \"vp8/common/extend.h\"\n#include \"ratectrl.h\"\n#include \"vp8/common/quant_common.h\"\n#include \"segmentation.h\"\n#if CONFIG_POSTPROC\n#include \"vp8/common/postproc.h\"\n#endif\n#include \"vpx_mem/vpx_mem.h\"\n#include \"vp8/common/reconintra.h\"\n#include \"vp8/common/swapyv12buffer.h\"\n#include \"vp8/common/threading.h\"\n#include \"vpx_ports/system_state.h\"\n#include \"vpx_ports/vpx_once.h\"\n#include \"vpx_ports/vpx_timer.h\"\n#include \"vpx_util/vpx_write_yuv_frame.h\"\n#if VPX_ARCH_ARM\n#include \"vpx_ports/arm.h\"\n#endif\n#if CONFIG_MULTI_RES_ENCODING\n#include \"mr_dissim.h\"\n#endif\n#include \"encodeframe.h\"\n#if CONFIG_MULTITHREAD\n#include \"ethreading.h\"\n#endif\n#include \"picklpf.h\"\n#if !CONFIG_REALTIME_ONLY\n#include \"temporal_filter.h\"\n#endif\n\n#include <assert.h>\n#include <math.h>\n#include <stdio.h>\n#include <limits.h>\n\n#if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING\nextern int vp8_update_coef_context(VP8_COMP *cpi);\n#endif\n\nextern unsigned int vp8_get_processor_freq();\n\nint vp8_calc_ss_err(YV12_BUFFER_CONFIG *source, YV12_BUFFER_CONFIG *dest);\n\nstatic void set_default_lf_deltas(VP8_COMP *cpi);\n\nextern const int vp8_gf_interval_table[101];\n\n#if CONFIG_INTERNAL_STATS\n#include \"math.h\"\n#include \"vpx_dsp/ssim.h\"\n#endif\n\n#ifdef OUTPUT_YUV_SRC\nFILE *yuv_file;\n#endif\n#ifdef OUTPUT_YUV_DENOISED\nFILE *yuv_denoised_file;\n#endif\n#ifdef OUTPUT_YUV_SKINMAP\nstatic FILE *yuv_skinmap_file = NULL;\n#endif\n\n#if 0\nFILE *framepsnr;\nFILE *kf_list;\nFILE *keyfile;\n#endif\n\n#if 0\nextern int skip_true_count;\nextern int skip_false_count;\n#endif\n\n#ifdef SPEEDSTATS\nunsigned int frames_at_speed[16] = { 0, 0, 0, 0, 0, 0, 0, 0,\n                                     0, 0, 0, 0, 0, 0, 0, 0 };\nunsigned int tot_pm = 0;\nunsigned int cnt_pm = 0;\nunsigned int tot_ef = 0;\nunsigned int cnt_ef = 0;\n#endif\n\n#ifdef MODE_STATS\nextern unsigned __int64 Sectionbits[50];\nextern int y_modes[5];\nextern int uv_modes[4];\nextern int b_modes[10];\n\nextern int inter_y_modes[10];\nextern int inter_uv_modes[4];\nextern unsigned int inter_b_modes[15];\n#endif\n\nextern const int vp8_bits_per_mb[2][QINDEX_RANGE];\n\nextern const int qrounding_factors[129];\nextern const int qzbin_factors[129];\nextern void vp8cx_init_quantizer(VP8_COMP *cpi);\nextern const int vp8cx_base_skip_false_prob[128];\n\n/* Tables relating active max Q to active min Q */\nstatic const unsigned char kf_low_motion_minq[QINDEX_RANGE] = {\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,\n  1,  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  4,  4,  4,  5,  5,  5,\n  5,  5,  6,  6,  6,  6,  7,  7,  8,  8,  8,  8,  9,  9,  10, 10, 10, 10, 11,\n  11, 11, 11, 12, 12, 13, 13, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16,\n  17, 17, 18, 18, 18, 18, 19, 20, 20, 21, 21, 22, 23, 23\n};\nstatic const unsigned char kf_high_motion_minq[QINDEX_RANGE] = {\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,\n  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,  4,  4,  4,  4,  5,\n  5,  5,  5,  5,  5,  6,  6,  6,  6,  7,  7,  8,  8,  8,  8,  9,  9,  10, 10,\n  10, 10, 11, 11, 11, 11, 12, 12, 13, 13, 13, 13, 14, 14, 15, 15, 15, 15, 16,\n  16, 16, 16, 17, 17, 18, 18, 18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21,\n  22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 28, 28, 29, 30\n};\nstatic const unsigned char gf_low_motion_minq[QINDEX_RANGE] = {\n  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  3,\n  3,  4,  4,  4,  4,  5,  5,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,\n  8,  8,  9,  9,  9,  9,  10, 10, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15,\n  15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24,\n  25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34,\n  34, 35, 35, 36, 36, 37, 37, 38, 38, 39, 39, 40, 40, 41, 41, 42, 42, 43, 44,\n  45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58\n};\nstatic const unsigned char gf_mid_motion_minq[QINDEX_RANGE] = {\n  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  2,  2,  3,  3,  3,  4,  4,  4,  5,\n  5,  5,  6,  6,  6,  7,  7,  7,  8,  8,  8,  9,  9,  9,  10, 10, 10, 10, 11,\n  11, 11, 12, 12, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 16, 16, 17, 17, 18,\n  18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35, 35, 36, 36, 37,\n  37, 38, 39, 39, 40, 40, 41, 41, 42, 42, 43, 43, 44, 45, 46, 47, 48, 49, 50,\n  51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64\n};\nstatic const unsigned char gf_high_motion_minq[QINDEX_RANGE] = {\n  0,  0,  0,  0,  1,  1,  1,  1,  1,  2,  2,  2,  3,  3,  3,  4,  4,  4,  5,\n  5,  5,  6,  6,  6,  7,  7,  7,  8,  8,  8,  9,  9,  9,  10, 10, 10, 11, 11,\n  12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21,\n  21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30,\n  31, 31, 32, 32, 33, 33, 34, 34, 35, 35, 36, 36, 37, 37, 38, 38, 39, 39, 40,\n  40, 41, 41, 42, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56,\n  57, 58, 59, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80\n};\nstatic const unsigned char inter_minq[QINDEX_RANGE] = {\n  0,  0,  1,  1,  2,  3,  3,  4,  4,  5,  6,  6,  7,  8,  8,  9,  9,  10, 11,\n  11, 12, 13, 13, 14, 15, 15, 16, 17, 17, 18, 19, 20, 20, 21, 22, 22, 23, 24,\n  24, 25, 26, 27, 27, 28, 29, 30, 30, 31, 32, 33, 33, 34, 35, 36, 36, 37, 38,\n  39, 39, 40, 41, 42, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 50, 51, 52, 53,\n  54, 55, 55, 56, 57, 58, 59, 60, 60, 61, 62, 63, 64, 65, 66, 67, 67, 68, 69,\n  70, 71, 72, 73, 74, 75, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 86,\n  87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100\n};\n\n#ifdef PACKET_TESTING\nextern FILE *vpxlogc;\n#endif\n\nvoid vp8_save_layer_context(VP8_COMP *cpi) {\n  LAYER_CONTEXT *lc = &cpi->layer_context[cpi->current_layer];\n\n  /* Save layer dependent coding state */\n  lc->target_bandwidth = cpi->target_bandwidth;\n  lc->starting_buffer_level = cpi->oxcf.starting_buffer_level;\n  lc->optimal_buffer_level = cpi->oxcf.optimal_buffer_level;\n  lc->maximum_buffer_size = cpi->oxcf.maximum_buffer_size;\n  lc->starting_buffer_level_in_ms = cpi->oxcf.starting_buffer_level_in_ms;\n  lc->optimal_buffer_level_in_ms = cpi->oxcf.optimal_buffer_level_in_ms;\n  lc->maximum_buffer_size_in_ms = cpi->oxcf.maximum_buffer_size_in_ms;\n  lc->buffer_level = cpi->buffer_level;\n  lc->bits_off_target = cpi->bits_off_target;\n  lc->total_actual_bits = cpi->total_actual_bits;\n  lc->worst_quality = cpi->worst_quality;\n  lc->active_worst_quality = cpi->active_worst_quality;\n  lc->best_quality = cpi->best_quality;\n  lc->active_best_quality = cpi->active_best_quality;\n  lc->ni_av_qi = cpi->ni_av_qi;\n  lc->ni_tot_qi = cpi->ni_tot_qi;\n  lc->ni_frames = cpi->ni_frames;\n  lc->avg_frame_qindex = cpi->avg_frame_qindex;\n  lc->rate_correction_factor = cpi->rate_correction_factor;\n  lc->key_frame_rate_correction_factor = cpi->key_frame_rate_correction_factor;\n  lc->gf_rate_correction_factor = cpi->gf_rate_correction_factor;\n  lc->zbin_over_quant = cpi->mb.zbin_over_quant;\n  lc->inter_frame_target = cpi->inter_frame_target;\n  lc->total_byte_count = cpi->total_byte_count;\n  lc->filter_level = cpi->common.filter_level;\n  lc->frames_since_last_drop_overshoot = cpi->frames_since_last_drop_overshoot;\n  lc->force_maxqp = cpi->force_maxqp;\n  lc->last_frame_percent_intra = cpi->last_frame_percent_intra;\n  lc->last_q[0] = cpi->last_q[0];\n  lc->last_q[1] = cpi->last_q[1];\n\n  memcpy(lc->count_mb_ref_frame_usage, cpi->mb.count_mb_ref_frame_usage,\n         sizeof(cpi->mb.count_mb_ref_frame_usage));\n}\n\nvoid vp8_restore_layer_context(VP8_COMP *cpi, const int layer) {\n  LAYER_CONTEXT *lc = &cpi->layer_context[layer];\n\n  /* Restore layer dependent coding state */\n  cpi->current_layer = layer;\n  cpi->target_bandwidth = lc->target_bandwidth;\n  cpi->oxcf.target_bandwidth = lc->target_bandwidth;\n  cpi->oxcf.starting_buffer_level = lc->starting_buffer_level;\n  cpi->oxcf.optimal_buffer_level = lc->optimal_buffer_level;\n  cpi->oxcf.maximum_buffer_size = lc->maximum_buffer_size;\n  cpi->oxcf.starting_buffer_level_in_ms = lc->starting_buffer_level_in_ms;\n  cpi->oxcf.optimal_buffer_level_in_ms = lc->optimal_buffer_level_in_ms;\n  cpi->oxcf.maximum_buffer_size_in_ms = lc->maximum_buffer_size_in_ms;\n  cpi->buffer_level = lc->buffer_level;\n  cpi->bits_off_target = lc->bits_off_target;\n  cpi->total_actual_bits = lc->total_actual_bits;\n  cpi->active_worst_quality = lc->active_worst_quality;\n  cpi->active_best_quality = lc->active_best_quality;\n  cpi->ni_av_qi = lc->ni_av_qi;\n  cpi->ni_tot_qi = lc->ni_tot_qi;\n  cpi->ni_frames = lc->ni_frames;\n  cpi->avg_frame_qindex = lc->avg_frame_qindex;\n  cpi->rate_correction_factor = lc->rate_correction_factor;\n  cpi->key_frame_rate_correction_factor = lc->key_frame_rate_correction_factor;\n  cpi->gf_rate_correction_factor = lc->gf_rate_correction_factor;\n  cpi->mb.zbin_over_quant = lc->zbin_over_quant;\n  cpi->inter_frame_target = lc->inter_frame_target;\n  cpi->total_byte_count = lc->total_byte_count;\n  cpi->common.filter_level = lc->filter_level;\n  cpi->frames_since_last_drop_overshoot = lc->frames_since_last_drop_overshoot;\n  cpi->force_maxqp = lc->force_maxqp;\n  cpi->last_frame_percent_intra = lc->last_frame_percent_intra;\n  cpi->last_q[0] = lc->last_q[0];\n  cpi->last_q[1] = lc->last_q[1];\n\n  memcpy(cpi->mb.count_mb_ref_frame_usage, lc->count_mb_ref_frame_usage,\n         sizeof(cpi->mb.count_mb_ref_frame_usage));\n}\n\nstatic int rescale(int val, int num, int denom) {\n  int64_t llnum = num;\n  int64_t llden = denom;\n  int64_t llval = val;\n\n  return (int)(llval * llnum / llden);\n}\n\nvoid vp8_init_temporal_layer_context(VP8_COMP *cpi, VP8_CONFIG *oxcf,\n                                     const int layer,\n                                     double prev_layer_framerate) {\n  LAYER_CONTEXT *lc = &cpi->layer_context[layer];\n\n  lc->framerate = cpi->output_framerate / cpi->oxcf.rate_decimator[layer];\n  lc->target_bandwidth = cpi->oxcf.target_bitrate[layer] * 1000;\n\n  lc->starting_buffer_level_in_ms = oxcf->starting_buffer_level;\n  lc->optimal_buffer_level_in_ms = oxcf->optimal_buffer_level;\n  lc->maximum_buffer_size_in_ms = oxcf->maximum_buffer_size;\n\n  lc->starting_buffer_level =\n      rescale((int)(oxcf->starting_buffer_level), lc->target_bandwidth, 1000);\n\n  if (oxcf->optimal_buffer_level == 0) {\n    lc->optimal_buffer_level = lc->target_bandwidth / 8;\n  } else {\n    lc->optimal_buffer_level =\n        rescale((int)(oxcf->optimal_buffer_level), lc->target_bandwidth, 1000);\n  }\n\n  if (oxcf->maximum_buffer_size == 0) {\n    lc->maximum_buffer_size = lc->target_bandwidth / 8;\n  } else {\n    lc->maximum_buffer_size =\n        rescale((int)(oxcf->maximum_buffer_size), lc->target_bandwidth, 1000);\n  }\n\n  /* Work out the average size of a frame within this layer */\n  if (layer > 0) {\n    lc->avg_frame_size_for_layer =\n        (int)round((cpi->oxcf.target_bitrate[layer] -\n                    cpi->oxcf.target_bitrate[layer - 1]) *\n                   1000 / (lc->framerate - prev_layer_framerate));\n  }\n\n  lc->active_worst_quality = cpi->oxcf.worst_allowed_q;\n  lc->active_best_quality = cpi->oxcf.best_allowed_q;\n  lc->avg_frame_qindex = cpi->oxcf.worst_allowed_q;\n\n  lc->buffer_level = lc->starting_buffer_level;\n  lc->bits_off_target = lc->starting_buffer_level;\n\n  lc->total_actual_bits = 0;\n  lc->ni_av_qi = 0;\n  lc->ni_tot_qi = 0;\n  lc->ni_frames = 0;\n  lc->rate_correction_factor = 1.0;\n  lc->key_frame_rate_correction_factor = 1.0;\n  lc->gf_rate_correction_factor = 1.0;\n  lc->inter_frame_target = 0;\n}\n\n// Upon a run-time change in temporal layers, reset the layer context parameters\n// for any \"new\" layers. For \"existing\" layers, let them inherit the parameters\n// from the previous layer state (at the same layer #). In future we may want\n// to better map the previous layer state(s) to the \"new\" ones.\nvoid vp8_reset_temporal_layer_change(VP8_COMP *cpi, VP8_CONFIG *oxcf,\n                                     const int prev_num_layers) {\n  int i;\n  double prev_layer_framerate = 0;\n  const int curr_num_layers = cpi->oxcf.number_of_layers;\n  // If the previous state was 1 layer, get current layer context from cpi.\n  // We need this to set the layer context for the new layers below.\n  if (prev_num_layers == 1) {\n    cpi->current_layer = 0;\n    vp8_save_layer_context(cpi);\n  }\n  for (i = 0; i < curr_num_layers; ++i) {\n    LAYER_CONTEXT *lc = &cpi->layer_context[i];\n    if (i >= prev_num_layers) {\n      vp8_init_temporal_layer_context(cpi, oxcf, i, prev_layer_framerate);\n    }\n    // The initial buffer levels are set based on their starting levels.\n    // We could set the buffer levels based on the previous state (normalized\n    // properly by the layer bandwidths) but we would need to keep track of\n    // the previous set of layer bandwidths (i.e., target_bitrate[i])\n    // before the layer change. For now, reset to the starting levels.\n    lc->buffer_level =\n        cpi->oxcf.starting_buffer_level_in_ms * cpi->oxcf.target_bitrate[i];\n    lc->bits_off_target = lc->buffer_level;\n    // TDOD(marpan): Should we set the rate_correction_factor and\n    // active_worst/best_quality to values derived from the previous layer\n    // state (to smooth-out quality dips/rate fluctuation at transition)?\n\n    // We need to treat the 1 layer case separately: oxcf.target_bitrate[i]\n    // is not set for 1 layer, and the vp8_restore_layer_context/save_context()\n    // are not called in the encoding loop, so we need to call it here to\n    // pass the layer context state to |cpi|.\n    if (curr_num_layers == 1) {\n      lc->target_bandwidth = cpi->oxcf.target_bandwidth;\n      lc->buffer_level =\n          cpi->oxcf.starting_buffer_level_in_ms * lc->target_bandwidth / 1000;\n      lc->bits_off_target = lc->buffer_level;\n      vp8_restore_layer_context(cpi, 0);\n    }\n    prev_layer_framerate = cpi->output_framerate / cpi->oxcf.rate_decimator[i];\n  }\n}\n\nstatic void setup_features(VP8_COMP *cpi) {\n  // If segmentation enabled set the update flags\n  if (cpi->mb.e_mbd.segmentation_enabled) {\n    cpi->mb.e_mbd.update_mb_segmentation_map = 1;\n    cpi->mb.e_mbd.update_mb_segmentation_data = 1;\n  } else {\n    cpi->mb.e_mbd.update_mb_segmentation_map = 0;\n    cpi->mb.e_mbd.update_mb_segmentation_data = 0;\n  }\n\n  cpi->mb.e_mbd.mode_ref_lf_delta_enabled = 0;\n  cpi->mb.e_mbd.mode_ref_lf_delta_update = 0;\n  memset(cpi->mb.e_mbd.ref_lf_deltas, 0, sizeof(cpi->mb.e_mbd.ref_lf_deltas));\n  memset(cpi->mb.e_mbd.mode_lf_deltas, 0, sizeof(cpi->mb.e_mbd.mode_lf_deltas));\n  memset(cpi->mb.e_mbd.last_ref_lf_deltas, 0,\n         sizeof(cpi->mb.e_mbd.ref_lf_deltas));\n  memset(cpi->mb.e_mbd.last_mode_lf_deltas, 0,\n         sizeof(cpi->mb.e_mbd.mode_lf_deltas));\n\n  set_default_lf_deltas(cpi);\n}\n\nstatic void dealloc_raw_frame_buffers(VP8_COMP *cpi);\n\nstatic void initialize_enc(void) {\n  vpx_dsp_rtcd();\n  vp8_init_intra_predictors();\n}\n\nvoid vp8_initialize_enc(void) { once(initialize_enc); }\n\nstatic void dealloc_compressor_data(VP8_COMP *cpi) {\n  vpx_free(cpi->tplist);\n  cpi->tplist = NULL;\n\n  /* Delete last frame MV storage buffers */\n  vpx_free(cpi->lfmv);\n  cpi->lfmv = 0;\n\n  vpx_free(cpi->lf_ref_frame_sign_bias);\n  cpi->lf_ref_frame_sign_bias = 0;\n\n  vpx_free(cpi->lf_ref_frame);\n  cpi->lf_ref_frame = 0;\n\n  /* Delete sementation map */\n  vpx_free(cpi->segmentation_map);\n  cpi->segmentation_map = 0;\n\n  vpx_free(cpi->active_map);\n  cpi->active_map = 0;\n\n  vp8_de_alloc_frame_buffers(&cpi->common);\n\n  vp8_yv12_de_alloc_frame_buffer(&cpi->pick_lf_lvl_frame);\n  vp8_yv12_de_alloc_frame_buffer(&cpi->scaled_source);\n  dealloc_raw_frame_buffers(cpi);\n\n  vpx_free(cpi->tok);\n  cpi->tok = 0;\n\n  /* Structure used to monitor GF usage */\n  vpx_free(cpi->gf_active_flags);\n  cpi->gf_active_flags = 0;\n\n  /* Activity mask based per mb zbin adjustments */\n  vpx_free(cpi->mb_activity_map);\n  cpi->mb_activity_map = 0;\n\n  vpx_free(cpi->mb.pip);\n  cpi->mb.pip = 0;\n\n#if CONFIG_MULTITHREAD\n  vpx_free(cpi->mt_current_mb_col);\n  cpi->mt_current_mb_col = NULL;\n#endif\n}\n\nstatic void enable_segmentation(VP8_COMP *cpi) {\n  /* Set the appropriate feature bit */\n  cpi->mb.e_mbd.segmentation_enabled = 1;\n  cpi->mb.e_mbd.update_mb_segmentation_map = 1;\n  cpi->mb.e_mbd.update_mb_segmentation_data = 1;\n}\nstatic void disable_segmentation(VP8_COMP *cpi) {\n  /* Clear the appropriate feature bit */\n  cpi->mb.e_mbd.segmentation_enabled = 0;\n}\n\n/* Valid values for a segment are 0 to 3\n * Segmentation map is arrange as [Rows][Columns]\n */\nstatic void set_segmentation_map(VP8_COMP *cpi,\n                                 unsigned char *segmentation_map) {\n  /* Copy in the new segmentation map */\n  memcpy(cpi->segmentation_map, segmentation_map,\n         (cpi->common.mb_rows * cpi->common.mb_cols));\n\n  /* Signal that the map should be updated. */\n  cpi->mb.e_mbd.update_mb_segmentation_map = 1;\n  cpi->mb.e_mbd.update_mb_segmentation_data = 1;\n}\n\n/* The values given for each segment can be either deltas (from the default\n * value chosen for the frame) or absolute values.\n *\n * Valid range for abs values is:\n *    (0-127 for MB_LVL_ALT_Q), (0-63 for SEGMENT_ALT_LF)\n * Valid range for delta values are:\n *    (+/-127 for MB_LVL_ALT_Q), (+/-63 for SEGMENT_ALT_LF)\n *\n * abs_delta = SEGMENT_DELTADATA (deltas)\n * abs_delta = SEGMENT_ABSDATA (use the absolute values given).\n *\n */\nstatic void set_segment_data(VP8_COMP *cpi, signed char *feature_data,\n                             unsigned char abs_delta) {\n  cpi->mb.e_mbd.mb_segment_abs_delta = abs_delta;\n  memcpy(cpi->segment_feature_data, feature_data,\n         sizeof(cpi->segment_feature_data));\n}\n\n/* A simple function to cyclically refresh the background at a lower Q */\nstatic void cyclic_background_refresh(VP8_COMP *cpi, int Q, int lf_adjustment) {\n  unsigned char *seg_map = cpi->segmentation_map;\n  signed char feature_data[MB_LVL_MAX][MAX_MB_SEGMENTS];\n  int i;\n  int block_count = cpi->cyclic_refresh_mode_max_mbs_perframe;\n  int mbs_in_frame = cpi->common.mb_rows * cpi->common.mb_cols;\n\n  cpi->cyclic_refresh_q = Q / 2;\n\n  if (cpi->oxcf.screen_content_mode) {\n    // Modify quality ramp-up based on Q. Above some Q level, increase the\n    // number of blocks to be refreshed, and reduce it below the thredhold.\n    // Turn-off under certain conditions (i.e., away from key frame, and if\n    // we are at good quality (low Q) and most of the blocks were\n    // skipped-encoded\n    // in previous frame.\n    int qp_thresh = (cpi->oxcf.screen_content_mode == 2) ? 80 : 100;\n    if (Q >= qp_thresh) {\n      cpi->cyclic_refresh_mode_max_mbs_perframe =\n          (cpi->common.mb_rows * cpi->common.mb_cols) / 10;\n    } else if (cpi->frames_since_key > 250 && Q < 20 &&\n               cpi->mb.skip_true_count > (int)(0.95 * mbs_in_frame)) {\n      cpi->cyclic_refresh_mode_max_mbs_perframe = 0;\n    } else {\n      cpi->cyclic_refresh_mode_max_mbs_perframe =\n          (cpi->common.mb_rows * cpi->common.mb_cols) / 20;\n    }\n    block_count = cpi->cyclic_refresh_mode_max_mbs_perframe;\n  }\n\n  // Set every macroblock to be eligible for update.\n  // For key frame this will reset seg map to 0.\n  memset(cpi->segmentation_map, 0, mbs_in_frame);\n\n  if (cpi->common.frame_type != KEY_FRAME && block_count > 0) {\n    /* Cycle through the macro_block rows */\n    /* MB loop to set local segmentation map */\n    i = cpi->cyclic_refresh_mode_index;\n    assert(i < mbs_in_frame);\n    do {\n      /* If the MB is as a candidate for clean up then mark it for\n       * possible boost/refresh (segment 1) The segment id may get\n       * reset to 0 later if the MB gets coded anything other than\n       * last frame 0,0 as only (last frame 0,0) MBs are eligable for\n       * refresh : that is to say Mbs likely to be background blocks.\n       */\n      if (cpi->cyclic_refresh_map[i] == 0) {\n        seg_map[i] = 1;\n        block_count--;\n      } else if (cpi->cyclic_refresh_map[i] < 0) {\n        cpi->cyclic_refresh_map[i]++;\n      }\n\n      i++;\n      if (i == mbs_in_frame) i = 0;\n\n    } while (block_count && i != cpi->cyclic_refresh_mode_index);\n\n    cpi->cyclic_refresh_mode_index = i;\n\n#if CONFIG_TEMPORAL_DENOISING\n    if (cpi->oxcf.noise_sensitivity > 0) {\n      if (cpi->denoiser.denoiser_mode == kDenoiserOnYUVAggressive &&\n          Q < (int)cpi->denoiser.denoise_pars.qp_thresh &&\n          (cpi->frames_since_key >\n           2 * cpi->denoiser.denoise_pars.consec_zerolast)) {\n        // Under aggressive denoising, use segmentation to turn off loop\n        // filter below some qp thresh. The filter is reduced for all\n        // blocks that have been encoded as ZEROMV LAST x frames in a row,\n        // where x is set by cpi->denoiser.denoise_pars.consec_zerolast.\n        // This is to avoid \"dot\" artifacts that can occur from repeated\n        // loop filtering on noisy input source.\n        cpi->cyclic_refresh_q = Q;\n        // lf_adjustment = -MAX_LOOP_FILTER;\n        lf_adjustment = -40;\n        for (i = 0; i < mbs_in_frame; ++i) {\n          seg_map[i] = (cpi->consec_zero_last[i] >\n                        cpi->denoiser.denoise_pars.consec_zerolast)\n                           ? 1\n                           : 0;\n        }\n      }\n    }\n#endif\n  }\n\n  /* Activate segmentation. */\n  cpi->mb.e_mbd.update_mb_segmentation_map = 1;\n  cpi->mb.e_mbd.update_mb_segmentation_data = 1;\n  enable_segmentation(cpi);\n\n  /* Set up the quant segment data */\n  feature_data[MB_LVL_ALT_Q][0] = 0;\n  feature_data[MB_LVL_ALT_Q][1] = (cpi->cyclic_refresh_q - Q);\n  feature_data[MB_LVL_ALT_Q][2] = 0;\n  feature_data[MB_LVL_ALT_Q][3] = 0;\n\n  /* Set up the loop segment data */\n  feature_data[MB_LVL_ALT_LF][0] = 0;\n  feature_data[MB_LVL_ALT_LF][1] = lf_adjustment;\n  feature_data[MB_LVL_ALT_LF][2] = 0;\n  feature_data[MB_LVL_ALT_LF][3] = 0;\n\n  /* Initialise the feature data structure */\n  set_segment_data(cpi, &feature_data[0][0], SEGMENT_DELTADATA);\n}\n\nstatic void compute_skin_map(VP8_COMP *cpi) {\n  int mb_row, mb_col, num_bl;\n  VP8_COMMON *cm = &cpi->common;\n  const uint8_t *src_y = cpi->Source->y_buffer;\n  const uint8_t *src_u = cpi->Source->u_buffer;\n  const uint8_t *src_v = cpi->Source->v_buffer;\n  const int src_ystride = cpi->Source->y_stride;\n  const int src_uvstride = cpi->Source->uv_stride;\n\n  const SKIN_DETECTION_BLOCK_SIZE bsize =\n      (cm->Width * cm->Height <= 352 * 288) ? SKIN_8X8 : SKIN_16X16;\n\n  for (mb_row = 0; mb_row < cm->mb_rows; mb_row++) {\n    num_bl = 0;\n    for (mb_col = 0; mb_col < cm->mb_cols; mb_col++) {\n      const int bl_index = mb_row * cm->mb_cols + mb_col;\n      cpi->skin_map[bl_index] =\n          vp8_compute_skin_block(src_y, src_u, src_v, src_ystride, src_uvstride,\n                                 bsize, cpi->consec_zero_last[bl_index], 0);\n      num_bl++;\n      src_y += 16;\n      src_u += 8;\n      src_v += 8;\n    }\n    src_y += (src_ystride << 4) - (num_bl << 4);\n    src_u += (src_uvstride << 3) - (num_bl << 3);\n    src_v += (src_uvstride << 3) - (num_bl << 3);\n  }\n\n  // Remove isolated skin blocks (none of its neighbors are skin) and isolated\n  // non-skin blocks (all of its neighbors are skin). Skip the boundary.\n  for (mb_row = 1; mb_row < cm->mb_rows - 1; mb_row++) {\n    for (mb_col = 1; mb_col < cm->mb_cols - 1; mb_col++) {\n      const int bl_index = mb_row * cm->mb_cols + mb_col;\n      int num_neighbor = 0;\n      int mi, mj;\n      int non_skin_threshold = 8;\n\n      for (mi = -1; mi <= 1; mi += 1) {\n        for (mj = -1; mj <= 1; mj += 1) {\n          int bl_neighbor_index = (mb_row + mi) * cm->mb_cols + mb_col + mj;\n          if (cpi->skin_map[bl_neighbor_index]) num_neighbor++;\n        }\n      }\n\n      if (cpi->skin_map[bl_index] && num_neighbor < 2)\n        cpi->skin_map[bl_index] = 0;\n      if (!cpi->skin_map[bl_index] && num_neighbor == non_skin_threshold)\n        cpi->skin_map[bl_index] = 1;\n    }\n  }\n}\n\nstatic void set_default_lf_deltas(VP8_COMP *cpi) {\n  cpi->mb.e_mbd.mode_ref_lf_delta_enabled = 1;\n  cpi->mb.e_mbd.mode_ref_lf_delta_update = 1;\n\n  memset(cpi->mb.e_mbd.ref_lf_deltas, 0, sizeof(cpi->mb.e_mbd.ref_lf_deltas));\n  memset(cpi->mb.e_mbd.mode_lf_deltas, 0, sizeof(cpi->mb.e_mbd.mode_lf_deltas));\n\n  /* Test of ref frame deltas */\n  cpi->mb.e_mbd.ref_lf_deltas[INTRA_FRAME] = 2;\n  cpi->mb.e_mbd.ref_lf_deltas[LAST_FRAME] = 0;\n  cpi->mb.e_mbd.ref_lf_deltas[GOLDEN_FRAME] = -2;\n  cpi->mb.e_mbd.ref_lf_deltas[ALTREF_FRAME] = -2;\n\n  cpi->mb.e_mbd.mode_lf_deltas[0] = 4; /* BPRED */\n\n  if (cpi->oxcf.Mode == MODE_REALTIME) {\n    cpi->mb.e_mbd.mode_lf_deltas[1] = -12; /* Zero */\n  } else {\n    cpi->mb.e_mbd.mode_lf_deltas[1] = -2; /* Zero */\n  }\n\n  cpi->mb.e_mbd.mode_lf_deltas[2] = 2; /* New mv */\n  cpi->mb.e_mbd.mode_lf_deltas[3] = 4; /* Split mv */\n}\n\n/* Convenience macros for mapping speed and mode into a continuous\n * range\n */\n#define GOOD(x) ((x) + 1)\n#define RT(x) ((x) + 7)\n\nstatic int speed_map(int speed, const int *map) {\n  int res;\n\n  do {\n    res = *map++;\n  } while (speed >= *map++);\n  return res;\n}\n\nstatic const int thresh_mult_map_znn[] = {\n  /* map common to zero, nearest, and near */\n  0, GOOD(2), 1500, GOOD(3), 2000, RT(0), 1000, RT(2), 2000, INT_MAX\n};\n\nstatic const int thresh_mult_map_vhpred[] = { 1000, GOOD(2), 1500,    GOOD(3),\n                                              2000, RT(0),   1000,    RT(1),\n                                              2000, RT(7),   INT_MAX, INT_MAX };\n\nstatic const int thresh_mult_map_bpred[] = { 2000,    GOOD(0), 2500, GOOD(2),\n                                             5000,    GOOD(3), 7500, RT(0),\n                                             2500,    RT(1),   5000, RT(6),\n                                             INT_MAX, INT_MAX };\n\nstatic const int thresh_mult_map_tm[] = { 1000,    GOOD(2), 1500, GOOD(3),\n                                          2000,    RT(0),   0,    RT(1),\n                                          1000,    RT(2),   2000, RT(7),\n                                          INT_MAX, INT_MAX };\n\nstatic const int thresh_mult_map_new1[] = { 1000,  GOOD(2), 2000,\n                                            RT(0), 2000,    INT_MAX };\n\nstatic const int thresh_mult_map_new2[] = { 1000, GOOD(2), 2000, GOOD(3),\n                                            2500, GOOD(5), 4000, RT(0),\n                                            2000, RT(2),   2500, RT(5),\n                                            4000, INT_MAX };\n\nstatic const int thresh_mult_map_split1[] = {\n  2500,  GOOD(0), 1700,  GOOD(2), 10000, GOOD(3), 25000, GOOD(4), INT_MAX,\n  RT(0), 5000,    RT(1), 10000,   RT(2), 25000,   RT(3), INT_MAX, INT_MAX\n};\n\nstatic const int thresh_mult_map_split2[] = {\n  5000,  GOOD(0), 4500,  GOOD(2), 20000, GOOD(3), 50000, GOOD(4), INT_MAX,\n  RT(0), 10000,   RT(1), 20000,   RT(2), 50000,   RT(3), INT_MAX, INT_MAX\n};\n\nstatic const int mode_check_freq_map_zn2[] = {\n  /* {zero,nearest}{2,3} */\n  0, RT(10), 1 << 1, RT(11), 1 << 2, RT(12), 1 << 3, INT_MAX\n};\n\nstatic const int mode_check_freq_map_vhbpred[] = { 0, GOOD(5), 2, RT(0),\n                                                   0, RT(3),   2, RT(5),\n                                                   4, INT_MAX };\n\nstatic const int mode_check_freq_map_near2[] = {\n  0,      GOOD(5), 2,      RT(0),  0,      RT(3),  2,\n  RT(10), 1 << 2,  RT(11), 1 << 3, RT(12), 1 << 4, INT_MAX\n};\n\nstatic const int mode_check_freq_map_new1[] = {\n  0, RT(10), 1 << 1, RT(11), 1 << 2, RT(12), 1 << 3, INT_MAX\n};\n\nstatic const int mode_check_freq_map_new2[] = { 0,      GOOD(5), 4,      RT(0),\n                                                0,      RT(3),   4,      RT(10),\n                                                1 << 3, RT(11),  1 << 4, RT(12),\n                                                1 << 5, INT_MAX };\n\nstatic const int mode_check_freq_map_split1[] = { 0, GOOD(2), 2, GOOD(3),\n                                                  7, RT(1),   2, RT(2),\n                                                  7, INT_MAX };\n\nstatic const int mode_check_freq_map_split2[] = { 0, GOOD(1), 2,  GOOD(2),\n                                                  4, GOOD(3), 15, RT(1),\n                                                  4, RT(2),   15, INT_MAX };\n\nvoid vp8_set_speed_features(VP8_COMP *cpi) {\n  SPEED_FEATURES *sf = &cpi->sf;\n  int Mode = cpi->compressor_speed;\n  int Speed = cpi->Speed;\n  int Speed2;\n  int i;\n  VP8_COMMON *cm = &cpi->common;\n  int last_improved_quant = sf->improved_quant;\n  int ref_frames;\n\n  /* Initialise default mode frequency sampling variables */\n  for (i = 0; i < MAX_MODES; ++i) {\n    cpi->mode_check_freq[i] = 0;\n  }\n\n  cpi->mb.mbs_tested_so_far = 0;\n  cpi->mb.mbs_zero_last_dot_suppress = 0;\n\n  /* best quality defaults */\n  sf->RD = 1;\n  sf->search_method = NSTEP;\n  sf->improved_quant = 1;\n  sf->improved_dct = 1;\n  sf->auto_filter = 1;\n  sf->recode_loop = 1;\n  sf->quarter_pixel_search = 1;\n  sf->half_pixel_search = 1;\n  sf->iterative_sub_pixel = 1;\n  sf->optimize_coefficients = 1;\n  sf->use_fastquant_for_pick = 0;\n  sf->no_skip_block4x4_search = 1;\n\n  sf->first_step = 0;\n  sf->max_step_search_steps = MAX_MVSEARCH_STEPS;\n  sf->improved_mv_pred = 1;\n\n  /* default thresholds to 0 */\n  for (i = 0; i < MAX_MODES; ++i) sf->thresh_mult[i] = 0;\n\n  /* Count enabled references */\n  ref_frames = 1;\n  if (cpi->ref_frame_flags & VP8_LAST_FRAME) ref_frames++;\n  if (cpi->ref_frame_flags & VP8_GOLD_FRAME) ref_frames++;\n  if (cpi->ref_frame_flags & VP8_ALTR_FRAME) ref_frames++;\n\n  /* Convert speed to continuous range, with clamping */\n  if (Mode == 0) {\n    Speed = 0;\n  } else if (Mode == 2) {\n    Speed = RT(Speed);\n  } else {\n    if (Speed > 5) Speed = 5;\n    Speed = GOOD(Speed);\n  }\n\n  sf->thresh_mult[THR_ZERO1] = sf->thresh_mult[THR_NEAREST1] =\n      sf->thresh_mult[THR_NEAR1] = sf->thresh_mult[THR_DC] = 0; /* always */\n\n  sf->thresh_mult[THR_ZERO2] = sf->thresh_mult[THR_ZERO3] =\n      sf->thresh_mult[THR_NEAREST2] = sf->thresh_mult[THR_NEAREST3] =\n          sf->thresh_mult[THR_NEAR2] = sf->thresh_mult[THR_NEAR3] =\n              speed_map(Speed, thresh_mult_map_znn);\n\n  sf->thresh_mult[THR_V_PRED] = sf->thresh_mult[THR_H_PRED] =\n      speed_map(Speed, thresh_mult_map_vhpred);\n  sf->thresh_mult[THR_B_PRED] = speed_map(Speed, thresh_mult_map_bpred);\n  sf->thresh_mult[THR_TM] = speed_map(Speed, thresh_mult_map_tm);\n  sf->thresh_mult[THR_NEW1] = speed_map(Speed, thresh_mult_map_new1);\n  sf->thresh_mult[THR_NEW2] = sf->thresh_mult[THR_NEW3] =\n      speed_map(Speed, thresh_mult_map_new2);\n  sf->thresh_mult[THR_SPLIT1] = speed_map(Speed, thresh_mult_map_split1);\n  sf->thresh_mult[THR_SPLIT2] = sf->thresh_mult[THR_SPLIT3] =\n      speed_map(Speed, thresh_mult_map_split2);\n\n  // Special case for temporal layers.\n  // Reduce the thresholds for zero/nearest/near for GOLDEN, if GOLDEN is\n  // used as second reference. We don't modify thresholds for ALTREF case\n  // since ALTREF is usually used as long-term reference in temporal layers.\n  if ((cpi->Speed <= 6) && (cpi->oxcf.number_of_layers > 1) &&\n      (cpi->ref_frame_flags & VP8_LAST_FRAME) &&\n      (cpi->ref_frame_flags & VP8_GOLD_FRAME)) {\n    if (cpi->closest_reference_frame == GOLDEN_FRAME) {\n      sf->thresh_mult[THR_ZERO2] = sf->thresh_mult[THR_ZERO2] >> 3;\n      sf->thresh_mult[THR_NEAREST2] = sf->thresh_mult[THR_NEAREST2] >> 3;\n      sf->thresh_mult[THR_NEAR2] = sf->thresh_mult[THR_NEAR2] >> 3;\n    } else {\n      sf->thresh_mult[THR_ZERO2] = sf->thresh_mult[THR_ZERO2] >> 1;\n      sf->thresh_mult[THR_NEAREST2] = sf->thresh_mult[THR_NEAREST2] >> 1;\n      sf->thresh_mult[THR_NEAR2] = sf->thresh_mult[THR_NEAR2] >> 1;\n    }\n  }\n\n  cpi->mode_check_freq[THR_ZERO1] = cpi->mode_check_freq[THR_NEAREST1] =\n      cpi->mode_check_freq[THR_NEAR1] = cpi->mode_check_freq[THR_TM] =\n          cpi->mode_check_freq[THR_DC] = 0; /* always */\n\n  cpi->mode_check_freq[THR_ZERO2] = cpi->mode_check_freq[THR_ZERO3] =\n      cpi->mode_check_freq[THR_NEAREST2] = cpi->mode_check_freq[THR_NEAREST3] =\n          speed_map(Speed, mode_check_freq_map_zn2);\n\n  cpi->mode_check_freq[THR_NEAR2] = cpi->mode_check_freq[THR_NEAR3] =\n      speed_map(Speed, mode_check_freq_map_near2);\n\n  cpi->mode_check_freq[THR_V_PRED] = cpi->mode_check_freq[THR_H_PRED] =\n      cpi->mode_check_freq[THR_B_PRED] =\n          speed_map(Speed, mode_check_freq_map_vhbpred);\n\n  // For real-time mode at speed 10 keep the mode_check_freq threshold\n  // for NEW1 similar to that of speed 9.\n  Speed2 = Speed;\n  if (cpi->Speed == 10 && Mode == 2) Speed2 = RT(9);\n  cpi->mode_check_freq[THR_NEW1] = speed_map(Speed2, mode_check_freq_map_new1);\n\n  cpi->mode_check_freq[THR_NEW2] = cpi->mode_check_freq[THR_NEW3] =\n      speed_map(Speed, mode_check_freq_map_new2);\n\n  cpi->mode_check_freq[THR_SPLIT1] =\n      speed_map(Speed, mode_check_freq_map_split1);\n  cpi->mode_check_freq[THR_SPLIT2] = cpi->mode_check_freq[THR_SPLIT3] =\n      speed_map(Speed, mode_check_freq_map_split2);\n  Speed = cpi->Speed;\n  switch (Mode) {\n#if !CONFIG_REALTIME_ONLY\n    case 0: /* best quality mode */\n      sf->first_step = 0;\n      sf->max_step_search_steps = MAX_MVSEARCH_STEPS;\n      break;\n    case 1:\n    case 3:\n      if (Speed > 0) {\n        /* Disable coefficient optimization above speed 0 */\n        sf->optimize_coefficients = 0;\n        sf->use_fastquant_for_pick = 1;\n        sf->no_skip_block4x4_search = 0;\n\n        sf->first_step = 1;\n      }\n\n      if (Speed > 2) {\n        sf->improved_quant = 0;\n        sf->improved_dct = 0;\n\n        /* Only do recode loop on key frames, golden frames and\n         * alt ref frames\n         */\n        sf->recode_loop = 2;\n      }\n\n      if (Speed > 3) {\n        sf->auto_filter = 1;\n        sf->recode_loop = 0; /* recode loop off */\n        sf->RD = 0;          /* Turn rd off */\n      }\n\n      if (Speed > 4) {\n        sf->auto_filter = 0; /* Faster selection of loop filter */\n      }\n\n      break;\n#endif\n    case 2:\n      sf->optimize_coefficients = 0;\n      sf->recode_loop = 0;\n      sf->auto_filter = 1;\n      sf->iterative_sub_pixel = 1;\n      sf->search_method = NSTEP;\n\n      if (Speed > 0) {\n        sf->improved_quant = 0;\n        sf->improved_dct = 0;\n\n        sf->use_fastquant_for_pick = 1;\n        sf->no_skip_block4x4_search = 0;\n        sf->first_step = 1;\n      }\n\n      if (Speed > 2) sf->auto_filter = 0; /* Faster selection of loop filter */\n\n      if (Speed > 3) {\n        sf->RD = 0;\n        sf->auto_filter = 1;\n      }\n\n      if (Speed > 4) {\n        sf->auto_filter = 0; /* Faster selection of loop filter */\n        sf->search_method = HEX;\n        sf->iterative_sub_pixel = 0;\n      }\n\n      if (Speed > 6) {\n        unsigned int sum = 0;\n        unsigned int total_mbs = cm->MBs;\n        int thresh;\n        unsigned int total_skip;\n\n        int min = 2000;\n\n        if (cpi->oxcf.encode_breakout > 2000) min = cpi->oxcf.encode_breakout;\n\n        min >>= 7;\n\n        for (i = 0; i < min; ++i) {\n          sum += cpi->mb.error_bins[i];\n        }\n\n        total_skip = sum;\n        sum = 0;\n\n        /* i starts from 2 to make sure thresh started from 2048 */\n        for (; i < 1024; ++i) {\n          sum += cpi->mb.error_bins[i];\n\n          if (10 * sum >=\n              (unsigned int)(cpi->Speed - 6) * (total_mbs - total_skip)) {\n            break;\n          }\n        }\n\n        i--;\n        thresh = (i << 7);\n\n        if (thresh < 2000) thresh = 2000;\n\n        if (ref_frames > 1) {\n          sf->thresh_mult[THR_NEW1] = thresh;\n          sf->thresh_mult[THR_NEAREST1] = thresh >> 1;\n          sf->thresh_mult[THR_NEAR1] = thresh >> 1;\n        }\n\n        if (ref_frames > 2) {\n          sf->thresh_mult[THR_NEW2] = thresh << 1;\n          sf->thresh_mult[THR_NEAREST2] = thresh;\n          sf->thresh_mult[THR_NEAR2] = thresh;\n        }\n\n        if (ref_frames > 3) {\n          sf->thresh_mult[THR_NEW3] = thresh << 1;\n          sf->thresh_mult[THR_NEAREST3] = thresh;\n          sf->thresh_mult[THR_NEAR3] = thresh;\n        }\n\n        sf->improved_mv_pred = 0;\n      }\n\n      if (Speed > 8) sf->quarter_pixel_search = 0;\n\n      if (cm->version == 0) {\n        cm->filter_type = NORMAL_LOOPFILTER;\n\n        if (Speed >= 14) cm->filter_type = SIMPLE_LOOPFILTER;\n      } else {\n        cm->filter_type = SIMPLE_LOOPFILTER;\n      }\n\n      /* This has a big hit on quality. Last resort */\n      if (Speed >= 15) sf->half_pixel_search = 0;\n\n      memset(cpi->mb.error_bins, 0, sizeof(cpi->mb.error_bins));\n\n  } /* switch */\n\n  /* Slow quant, dct and trellis not worthwhile for first pass\n   * so make sure they are always turned off.\n   */\n  if (cpi->pass == 1) {\n    sf->improved_quant = 0;\n    sf->optimize_coefficients = 0;\n    sf->improved_dct = 0;\n  }\n\n  if (cpi->sf.search_method == NSTEP) {\n    vp8_init3smotion_compensation(&cpi->mb,\n                                  cm->yv12_fb[cm->lst_fb_idx].y_stride);\n  } else if (cpi->sf.search_method == DIAMOND) {\n    vp8_init_dsmotion_compensation(&cpi->mb,\n                                   cm->yv12_fb[cm->lst_fb_idx].y_stride);\n  }\n\n  if (cpi->sf.improved_dct) {\n    cpi->mb.short_fdct8x4 = vp8_short_fdct8x4;\n    cpi->mb.short_fdct4x4 = vp8_short_fdct4x4;\n  } else {\n    /* No fast FDCT defined for any platform at this time. */\n    cpi->mb.short_fdct8x4 = vp8_short_fdct8x4;\n    cpi->mb.short_fdct4x4 = vp8_short_fdct4x4;\n  }\n\n  cpi->mb.short_walsh4x4 = vp8_short_walsh4x4;\n\n  if (cpi->sf.improved_quant) {\n    cpi->mb.quantize_b = vp8_regular_quantize_b;\n  } else {\n    cpi->mb.quantize_b = vp8_fast_quantize_b;\n  }\n  if (cpi->sf.improved_quant != last_improved_quant) vp8cx_init_quantizer(cpi);\n\n  if (cpi->sf.iterative_sub_pixel == 1) {\n    cpi->find_fractional_mv_step = vp8_find_best_sub_pixel_step_iteratively;\n  } else if (cpi->sf.quarter_pixel_search) {\n    cpi->find_fractional_mv_step = vp8_find_best_sub_pixel_step;\n  } else if (cpi->sf.half_pixel_search) {\n    cpi->find_fractional_mv_step = vp8_find_best_half_pixel_step;\n  } else {\n    cpi->find_fractional_mv_step = vp8_skip_fractional_mv_step;\n  }\n\n  if (cpi->sf.optimize_coefficients == 1 && cpi->pass != 1) {\n    cpi->mb.optimize = 1;\n  } else {\n    cpi->mb.optimize = 0;\n  }\n\n  if (cpi->common.full_pixel) {\n    cpi->find_fractional_mv_step = vp8_skip_fractional_mv_step;\n  }\n\n#ifdef SPEEDSTATS\n  frames_at_speed[cpi->Speed]++;\n#endif\n}\n#undef GOOD\n#undef RT\n\nstatic void alloc_raw_frame_buffers(VP8_COMP *cpi) {\n#if VP8_TEMPORAL_ALT_REF\n  int width = (cpi->oxcf.Width + 15) & ~15;\n  int height = (cpi->oxcf.Height + 15) & ~15;\n#endif\n\n  cpi->lookahead = vp8_lookahead_init(cpi->oxcf.Width, cpi->oxcf.Height,\n                                      cpi->oxcf.lag_in_frames);\n  if (!cpi->lookahead) {\n    vpx_internal_error(&cpi->common.error, VPX_CODEC_MEM_ERROR,\n                       \"Failed to allocate lag buffers\");\n  }\n\n#if VP8_TEMPORAL_ALT_REF\n\n  if (vp8_yv12_alloc_frame_buffer(&cpi->alt_ref_buffer, width, height,\n                                  VP8BORDERINPIXELS)) {\n    vpx_internal_error(&cpi->common.error, VPX_CODEC_MEM_ERROR,\n                       \"Failed to allocate altref buffer\");\n  }\n\n#endif\n}\n\nstatic void dealloc_raw_frame_buffers(VP8_COMP *cpi) {\n#if VP8_TEMPORAL_ALT_REF\n  vp8_yv12_de_alloc_frame_buffer(&cpi->alt_ref_buffer);\n#endif\n  vp8_lookahead_destroy(cpi->lookahead);\n}\n\nstatic int vp8_alloc_partition_data(VP8_COMP *cpi) {\n  vpx_free(cpi->mb.pip);\n\n  cpi->mb.pip =\n      vpx_calloc((cpi->common.mb_cols + 1) * (cpi->common.mb_rows + 1),\n                 sizeof(PARTITION_INFO));\n  if (!cpi->mb.pip) return 1;\n\n  cpi->mb.pi = cpi->mb.pip + cpi->common.mode_info_stride + 1;\n\n  return 0;\n}\n\nvoid vp8_alloc_compressor_data(VP8_COMP *cpi) {\n  VP8_COMMON *cm = &cpi->common;\n\n  int width = cm->Width;\n  int height = cm->Height;\n\n  if (vp8_alloc_frame_buffers(cm, width, height)) {\n    vpx_internal_error(&cpi->common.error, VPX_CODEC_MEM_ERROR,\n                       \"Failed to allocate frame buffers\");\n  }\n\n  if (vp8_alloc_partition_data(cpi)) {\n    vpx_internal_error(&cpi->common.error, VPX_CODEC_MEM_ERROR,\n                       \"Failed to allocate partition data\");\n  }\n\n  if ((width & 0xf) != 0) width += 16 - (width & 0xf);\n\n  if ((height & 0xf) != 0) height += 16 - (height & 0xf);\n\n  if (vp8_yv12_alloc_frame_buffer(&cpi->pick_lf_lvl_frame, width, height,\n                                  VP8BORDERINPIXELS)) {\n    vpx_internal_error(&cpi->common.error, VPX_CODEC_MEM_ERROR,\n                       \"Failed to allocate last frame buffer\");\n  }\n\n  if (vp8_yv12_alloc_frame_buffer(&cpi->scaled_source, width, height,\n                                  VP8BORDERINPIXELS)) {\n    vpx_internal_error(&cpi->common.error, VPX_CODEC_MEM_ERROR,\n                       \"Failed to allocate scaled source buffer\");\n  }\n\n  vpx_free(cpi->tok);\n\n  {\n#if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING\n    unsigned int tokens = 8 * 24 * 16; /* one MB for each thread */\n#else\n    unsigned int tokens = cm->mb_rows * cm->mb_cols * 24 * 16;\n#endif\n    CHECK_MEM_ERROR(&cpi->common.error, cpi->tok,\n                    vpx_calloc(tokens, sizeof(*cpi->tok)));\n  }\n\n  /* Data used for real time vc mode to see if gf needs refreshing */\n  cpi->zeromv_count = 0;\n\n  /* Structures used to monitor GF usage */\n  vpx_free(cpi->gf_active_flags);\n  CHECK_MEM_ERROR(\n      &cpi->common.error, cpi->gf_active_flags,\n      vpx_calloc(sizeof(*cpi->gf_active_flags), cm->mb_rows * cm->mb_cols));\n  cpi->gf_active_count = cm->mb_rows * cm->mb_cols;\n\n  vpx_free(cpi->mb_activity_map);\n  CHECK_MEM_ERROR(\n      &cpi->common.error, cpi->mb_activity_map,\n      vpx_calloc(sizeof(*cpi->mb_activity_map), cm->mb_rows * cm->mb_cols));\n\n  /* allocate memory for storing last frame's MVs for MV prediction. */\n  vpx_free(cpi->lfmv);\n  CHECK_MEM_ERROR(\n      &cpi->common.error, cpi->lfmv,\n      vpx_calloc((cm->mb_rows + 2) * (cm->mb_cols + 2), sizeof(*cpi->lfmv)));\n  vpx_free(cpi->lf_ref_frame_sign_bias);\n  CHECK_MEM_ERROR(&cpi->common.error, cpi->lf_ref_frame_sign_bias,\n                  vpx_calloc((cm->mb_rows + 2) * (cm->mb_cols + 2),\n                             sizeof(*cpi->lf_ref_frame_sign_bias)));\n  vpx_free(cpi->lf_ref_frame);\n  CHECK_MEM_ERROR(&cpi->common.error, cpi->lf_ref_frame,\n                  vpx_calloc((cm->mb_rows + 2) * (cm->mb_cols + 2),\n                             sizeof(*cpi->lf_ref_frame)));\n\n  /* Create the encoder segmentation map and set all entries to 0 */\n  vpx_free(cpi->segmentation_map);\n  CHECK_MEM_ERROR(\n      &cpi->common.error, cpi->segmentation_map,\n      vpx_calloc(cm->mb_rows * cm->mb_cols, sizeof(*cpi->segmentation_map)));\n  cpi->cyclic_refresh_mode_index = 0;\n  vpx_free(cpi->active_map);\n  CHECK_MEM_ERROR(\n      &cpi->common.error, cpi->active_map,\n      vpx_calloc(cm->mb_rows * cm->mb_cols, sizeof(*cpi->active_map)));\n  memset(cpi->active_map, 1, (cm->mb_rows * cm->mb_cols));\n\n#if CONFIG_MULTITHREAD\n  if (width < 640) {\n    cpi->mt_sync_range = 1;\n  } else if (width <= 1280) {\n    cpi->mt_sync_range = 4;\n  } else if (width <= 2560) {\n    cpi->mt_sync_range = 8;\n  } else {\n    cpi->mt_sync_range = 16;\n  }\n\n  if (cpi->oxcf.multi_threaded > 1) {\n    int i;\n\n    vpx_free(cpi->mt_current_mb_col);\n    CHECK_MEM_ERROR(&cpi->common.error, cpi->mt_current_mb_col,\n                    vpx_malloc(sizeof(*cpi->mt_current_mb_col) * cm->mb_rows));\n    for (i = 0; i < cm->mb_rows; ++i)\n      vpx_atomic_init(&cpi->mt_current_mb_col[i], 0);\n  }\n\n#endif\n\n  vpx_free(cpi->tplist);\n  CHECK_MEM_ERROR(&cpi->common.error, cpi->tplist,\n                  vpx_malloc(sizeof(TOKENLIST) * cm->mb_rows));\n\n#if CONFIG_TEMPORAL_DENOISING\n  if (cpi->oxcf.noise_sensitivity > 0) {\n    vp8_denoiser_free(&cpi->denoiser);\n    if (vp8_denoiser_allocate(&cpi->denoiser, width, height, cm->mb_rows,\n                              cm->mb_cols, cpi->oxcf.noise_sensitivity)) {\n      vpx_internal_error(&cpi->common.error, VPX_CODEC_MEM_ERROR,\n                         \"Failed to allocate denoiser\");\n    }\n  }\n#endif\n}\n\n/* Quant MOD */\nstatic const int q_trans[] = {\n  0,  1,  2,  3,  4,  5,  7,   8,   9,   10,  12,  13,  15,  17,  18,  19,\n  20, 21, 23, 24, 25, 26, 27,  28,  29,  30,  31,  33,  35,  37,  39,  41,\n  43, 45, 47, 49, 51, 53, 55,  57,  59,  61,  64,  67,  70,  73,  76,  79,\n  82, 85, 88, 91, 94, 97, 100, 103, 106, 109, 112, 115, 118, 121, 124, 127,\n};\n\nint vp8_reverse_trans(int x) {\n  int i;\n\n  for (i = 0; i < 64; ++i) {\n    if (q_trans[i] >= x) return i;\n  }\n\n  return 63;\n}\nvoid vp8_new_framerate(VP8_COMP *cpi, double framerate) {\n  if (framerate < .1) framerate = 30;\n\n  cpi->framerate = framerate;\n  cpi->output_framerate = framerate;\n  cpi->per_frame_bandwidth =\n      (int)round(cpi->oxcf.target_bandwidth / cpi->output_framerate);\n  cpi->av_per_frame_bandwidth = cpi->per_frame_bandwidth;\n  cpi->min_frame_bandwidth = (int)(cpi->av_per_frame_bandwidth *\n                                   cpi->oxcf.two_pass_vbrmin_section / 100);\n\n  /* Set Maximum gf/arf interval */\n  cpi->max_gf_interval = ((int)(cpi->output_framerate / 2.0) + 2);\n\n  if (cpi->max_gf_interval < 12) cpi->max_gf_interval = 12;\n\n  /* Extended interval for genuinely static scenes */\n  cpi->twopass.static_scene_max_gf_interval = cpi->key_frame_frequency >> 1;\n\n  /* Special conditions when altr ref frame enabled in lagged compress mode */\n  if (cpi->oxcf.play_alternate && cpi->oxcf.lag_in_frames) {\n    if (cpi->max_gf_interval > cpi->oxcf.lag_in_frames - 1) {\n      cpi->max_gf_interval = cpi->oxcf.lag_in_frames - 1;\n    }\n\n    if (cpi->twopass.static_scene_max_gf_interval >\n        cpi->oxcf.lag_in_frames - 1) {\n      cpi->twopass.static_scene_max_gf_interval = cpi->oxcf.lag_in_frames - 1;\n    }\n  }\n\n  if (cpi->max_gf_interval > cpi->twopass.static_scene_max_gf_interval) {\n    cpi->max_gf_interval = cpi->twopass.static_scene_max_gf_interval;\n  }\n}\n\nstatic void init_config(VP8_COMP *cpi, VP8_CONFIG *oxcf) {\n  VP8_COMMON *cm = &cpi->common;\n\n  cpi->oxcf = *oxcf;\n\n  cpi->auto_gold = 1;\n  cpi->auto_adjust_gold_quantizer = 1;\n\n  cm->version = oxcf->Version;\n  vp8_setup_version(cm);\n\n  /* Frame rate is not available on the first frame, as it's derived from\n   * the observed timestamps. The actual value used here doesn't matter\n   * too much, as it will adapt quickly.\n   */\n  if (oxcf->timebase.num > 0) {\n    cpi->framerate =\n        (double)(oxcf->timebase.den) / (double)(oxcf->timebase.num);\n  } else {\n    cpi->framerate = 30;\n  }\n\n  /* If the reciprocal of the timebase seems like a reasonable framerate,\n   * then use that as a guess, otherwise use 30.\n   */\n  if (cpi->framerate > 180) cpi->framerate = 30;\n\n  cpi->ref_framerate = cpi->framerate;\n\n  cpi->ref_frame_flags = VP8_ALTR_FRAME | VP8_GOLD_FRAME | VP8_LAST_FRAME;\n\n  cm->refresh_golden_frame = 0;\n  cm->refresh_last_frame = 1;\n  cm->refresh_entropy_probs = 1;\n\n  /* change includes all joint functionality */\n  vp8_change_config(cpi, oxcf);\n\n  /* Initialize active best and worst q and average q values. */\n  cpi->active_worst_quality = cpi->oxcf.worst_allowed_q;\n  cpi->active_best_quality = cpi->oxcf.best_allowed_q;\n  cpi->avg_frame_qindex = cpi->oxcf.worst_allowed_q;\n\n  /* Initialise the starting buffer levels */\n  cpi->buffer_level = cpi->oxcf.starting_buffer_level;\n  cpi->bits_off_target = cpi->oxcf.starting_buffer_level;\n\n  cpi->rolling_target_bits = cpi->av_per_frame_bandwidth;\n  cpi->rolling_actual_bits = cpi->av_per_frame_bandwidth;\n  cpi->long_rolling_target_bits = cpi->av_per_frame_bandwidth;\n  cpi->long_rolling_actual_bits = cpi->av_per_frame_bandwidth;\n\n  cpi->total_actual_bits = 0;\n  cpi->total_target_vs_actual = 0;\n\n  /* Temporal scalabilty */\n  if (cpi->oxcf.number_of_layers > 1) {\n    unsigned int i;\n    double prev_layer_framerate = 0;\n\n    for (i = 0; i < cpi->oxcf.number_of_layers; ++i) {\n      vp8_init_temporal_layer_context(cpi, oxcf, i, prev_layer_framerate);\n      prev_layer_framerate =\n          cpi->output_framerate / cpi->oxcf.rate_decimator[i];\n    }\n  }\n\n#if VP8_TEMPORAL_ALT_REF\n  {\n    int i;\n\n    cpi->fixed_divide[0] = 0;\n\n    for (i = 1; i < 512; ++i) cpi->fixed_divide[i] = 0x80000 / i;\n  }\n#endif\n}\n\nvoid vp8_update_layer_contexts(VP8_COMP *cpi) {\n  VP8_CONFIG *oxcf = &cpi->oxcf;\n\n  /* Update snapshots of the layer contexts to reflect new parameters */\n  if (oxcf->number_of_layers > 1) {\n    unsigned int i;\n    double prev_layer_framerate = 0;\n\n    assert(oxcf->number_of_layers <= VPX_TS_MAX_LAYERS);\n    for (i = 0; i < oxcf->number_of_layers && i < VPX_TS_MAX_LAYERS; ++i) {\n      LAYER_CONTEXT *lc = &cpi->layer_context[i];\n\n      lc->framerate = cpi->ref_framerate / oxcf->rate_decimator[i];\n      lc->target_bandwidth = oxcf->target_bitrate[i] * 1000;\n\n      lc->starting_buffer_level = rescale(\n          (int)oxcf->starting_buffer_level_in_ms, lc->target_bandwidth, 1000);\n\n      if (oxcf->optimal_buffer_level == 0) {\n        lc->optimal_buffer_level = lc->target_bandwidth / 8;\n      } else {\n        lc->optimal_buffer_level = rescale(\n            (int)oxcf->optimal_buffer_level_in_ms, lc->target_bandwidth, 1000);\n      }\n\n      if (oxcf->maximum_buffer_size == 0) {\n        lc->maximum_buffer_size = lc->target_bandwidth / 8;\n      } else {\n        lc->maximum_buffer_size = rescale((int)oxcf->maximum_buffer_size_in_ms,\n                                          lc->target_bandwidth, 1000);\n      }\n\n      /* Work out the average size of a frame within this layer */\n      if (i > 0) {\n        lc->avg_frame_size_for_layer =\n            (int)round((oxcf->target_bitrate[i] - oxcf->target_bitrate[i - 1]) *\n                       1000 / (lc->framerate - prev_layer_framerate));\n      }\n\n      prev_layer_framerate = lc->framerate;\n    }\n  }\n}\n\nvoid vp8_change_config(VP8_COMP *cpi, VP8_CONFIG *oxcf) {\n  VP8_COMMON *cm = &cpi->common;\n  int last_w, last_h;\n  unsigned int prev_number_of_layers;\n  unsigned int raw_target_rate;\n\n  if (!cpi) return;\n\n  if (!oxcf) return;\n\n  if (cm->version != oxcf->Version) {\n    cm->version = oxcf->Version;\n    vp8_setup_version(cm);\n  }\n\n  last_w = cpi->oxcf.Width;\n  last_h = cpi->oxcf.Height;\n  prev_number_of_layers = cpi->oxcf.number_of_layers;\n\n  if (cpi->initial_width) {\n    // TODO(https://crbug.com/1486441): Allow changing thread counts; the\n    // allocation is done once in vp8_create_compressor().\n    oxcf->multi_threaded = cpi->oxcf.multi_threaded;\n  }\n  cpi->oxcf = *oxcf;\n\n  switch (cpi->oxcf.Mode) {\n    case MODE_REALTIME:\n      cpi->pass = 0;\n      cpi->compressor_speed = 2;\n\n      if (cpi->oxcf.cpu_used < -16) {\n        cpi->oxcf.cpu_used = -16;\n      }\n\n      if (cpi->oxcf.cpu_used > 16) cpi->oxcf.cpu_used = 16;\n\n      break;\n\n    case MODE_GOODQUALITY:\n      cpi->pass = 0;\n      cpi->compressor_speed = 1;\n\n      if (cpi->oxcf.cpu_used < -5) {\n        cpi->oxcf.cpu_used = -5;\n      }\n\n      if (cpi->oxcf.cpu_used > 5) cpi->oxcf.cpu_used = 5;\n\n      break;\n\n    case MODE_BESTQUALITY:\n      cpi->pass = 0;\n      cpi->compressor_speed = 0;\n      break;\n\n    case MODE_FIRSTPASS:\n      cpi->pass = 1;\n      cpi->compressor_speed = 1;\n      break;\n    case MODE_SECONDPASS:\n      cpi->pass = 2;\n      cpi->compressor_speed = 1;\n\n      if (cpi->oxcf.cpu_used < -5) {\n        cpi->oxcf.cpu_used = -5;\n      }\n\n      if (cpi->oxcf.cpu_used > 5) cpi->oxcf.cpu_used = 5;\n\n      break;\n    case MODE_SECONDPASS_BEST:\n      cpi->pass = 2;\n      cpi->compressor_speed = 0;\n      break;\n  }\n\n  if (cpi->pass == 0) cpi->auto_worst_q = 1;\n\n  cpi->oxcf.worst_allowed_q = q_trans[oxcf->worst_allowed_q];\n  cpi->oxcf.best_allowed_q = q_trans[oxcf->best_allowed_q];\n  cpi->oxcf.cq_level = q_trans[cpi->oxcf.cq_level];\n\n  if (oxcf->fixed_q >= 0) {\n    if (oxcf->worst_allowed_q < 0) {\n      cpi->oxcf.fixed_q = q_trans[0];\n    } else {\n      cpi->oxcf.fixed_q = q_trans[oxcf->worst_allowed_q];\n    }\n\n    if (oxcf->alt_q < 0) {\n      cpi->oxcf.alt_q = q_trans[0];\n    } else {\n      cpi->oxcf.alt_q = q_trans[oxcf->alt_q];\n    }\n\n    if (oxcf->key_q < 0) {\n      cpi->oxcf.key_q = q_trans[0];\n    } else {\n      cpi->oxcf.key_q = q_trans[oxcf->key_q];\n    }\n\n    if (oxcf->gold_q < 0) {\n      cpi->oxcf.gold_q = q_trans[0];\n    } else {\n      cpi->oxcf.gold_q = q_trans[oxcf->gold_q];\n    }\n  }\n\n  cpi->ext_refresh_frame_flags_pending = 0;\n\n  cpi->baseline_gf_interval =\n      cpi->oxcf.alt_freq ? cpi->oxcf.alt_freq : DEFAULT_GF_INTERVAL;\n\n  // GF behavior for 1 pass CBR, used when error_resilience is off.\n  if (!cpi->oxcf.error_resilient_mode &&\n      cpi->oxcf.end_usage == USAGE_STREAM_FROM_SERVER &&\n      cpi->oxcf.Mode == MODE_REALTIME)\n    cpi->baseline_gf_interval = cpi->gf_interval_onepass_cbr;\n\n#if (CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING)\n  cpi->oxcf.token_partitions = 3;\n#endif\n\n  if (cpi->oxcf.token_partitions >= 0 && cpi->oxcf.token_partitions <= 3) {\n    cm->multi_token_partition = (TOKEN_PARTITION)cpi->oxcf.token_partitions;\n  }\n\n  setup_features(cpi);\n\n  if (!cpi->use_roi_static_threshold) {\n    int i;\n    for (i = 0; i < MAX_MB_SEGMENTS; ++i) {\n      cpi->segment_encode_breakout[i] = cpi->oxcf.encode_breakout;\n    }\n  }\n\n  /* At the moment the first order values may not be > MAXQ */\n  if (cpi->oxcf.fixed_q > MAXQ) cpi->oxcf.fixed_q = MAXQ;\n\n  /* local file playback mode == really big buffer */\n  if (cpi->oxcf.end_usage == USAGE_LOCAL_FILE_PLAYBACK) {\n    cpi->oxcf.starting_buffer_level = 60000;\n    cpi->oxcf.optimal_buffer_level = 60000;\n    cpi->oxcf.maximum_buffer_size = 240000;\n    cpi->oxcf.starting_buffer_level_in_ms = 60000;\n    cpi->oxcf.optimal_buffer_level_in_ms = 60000;\n    cpi->oxcf.maximum_buffer_size_in_ms = 240000;\n  }\n\n  raw_target_rate = (unsigned int)((int64_t)cpi->oxcf.Width * cpi->oxcf.Height *\n                                   8 * 3 * cpi->framerate / 1000);\n  if (cpi->oxcf.target_bandwidth > raw_target_rate)\n    cpi->oxcf.target_bandwidth = raw_target_rate;\n  /* Convert target bandwidth from Kbit/s to Bit/s */\n  cpi->oxcf.target_bandwidth *= 1000;\n\n  cpi->oxcf.starting_buffer_level = rescale(\n      (int)cpi->oxcf.starting_buffer_level, cpi->oxcf.target_bandwidth, 1000);\n\n  /* Set or reset optimal and maximum buffer levels. */\n  if (cpi->oxcf.optimal_buffer_level == 0) {\n    cpi->oxcf.optimal_buffer_level = cpi->oxcf.target_bandwidth / 8;\n  } else {\n    cpi->oxcf.optimal_buffer_level = rescale(\n        (int)cpi->oxcf.optimal_buffer_level, cpi->oxcf.target_bandwidth, 1000);\n  }\n\n  if (cpi->oxcf.maximum_buffer_size == 0) {\n    cpi->oxcf.maximum_buffer_size = cpi->oxcf.target_bandwidth / 8;\n  } else {\n    cpi->oxcf.maximum_buffer_size = rescale((int)cpi->oxcf.maximum_buffer_size,\n                                            cpi->oxcf.target_bandwidth, 1000);\n  }\n  // Under a configuration change, where maximum_buffer_size may change,\n  // keep buffer level clipped to the maximum allowed buffer size.\n  if (cpi->bits_off_target > cpi->oxcf.maximum_buffer_size) {\n    cpi->bits_off_target = cpi->oxcf.maximum_buffer_size;\n    cpi->buffer_level = cpi->bits_off_target;\n  }\n\n  /* Set up frame rate and related parameters rate control values. */\n  vp8_new_framerate(cpi, cpi->framerate);\n\n  /* Set absolute upper and lower quality limits */\n  cpi->worst_quality = cpi->oxcf.worst_allowed_q;\n  cpi->best_quality = cpi->oxcf.best_allowed_q;\n\n  /* active values should only be modified if out of new range */\n  if (cpi->active_worst_quality > cpi->oxcf.worst_allowed_q) {\n    cpi->active_worst_quality = cpi->oxcf.worst_allowed_q;\n  }\n  /* less likely */\n  else if (cpi->active_worst_quality < cpi->oxcf.best_allowed_q) {\n    cpi->active_worst_quality = cpi->oxcf.best_allowed_q;\n  }\n  if (cpi->active_best_quality < cpi->oxcf.best_allowed_q) {\n    cpi->active_best_quality = cpi->oxcf.best_allowed_q;\n  }\n  /* less likely */\n  else if (cpi->active_best_quality > cpi->oxcf.worst_allowed_q) {\n    cpi->active_best_quality = cpi->oxcf.worst_allowed_q;\n  }\n\n  cpi->buffered_mode = cpi->oxcf.optimal_buffer_level > 0;\n\n  cpi->cq_target_quality = cpi->oxcf.cq_level;\n\n  /* Only allow dropped frames in buffered mode */\n  cpi->drop_frames_allowed = cpi->oxcf.allow_df && cpi->buffered_mode;\n\n  cpi->target_bandwidth = cpi->oxcf.target_bandwidth;\n\n  // Check if the number of temporal layers has changed, and if so reset the\n  // pattern counter and set/initialize the temporal layer context for the\n  // new layer configuration.\n  if (cpi->oxcf.number_of_layers != prev_number_of_layers) {\n    // If the number of temporal layers are changed we must start at the\n    // base of the pattern cycle, so set the layer id to 0 and reset\n    // the temporal pattern counter.\n    if (cpi->temporal_layer_id > 0) {\n      cpi->temporal_layer_id = 0;\n    }\n    cpi->temporal_pattern_counter = 0;\n    vp8_reset_temporal_layer_change(cpi, oxcf, prev_number_of_layers);\n  }\n\n  if (!cpi->initial_width) {\n    cpi->initial_width = cpi->oxcf.Width;\n    cpi->initial_height = cpi->oxcf.Height;\n  }\n\n  cm->Width = cpi->oxcf.Width;\n  cm->Height = cpi->oxcf.Height;\n  assert(cm->Width <= cpi->initial_width);\n  assert(cm->Height <= cpi->initial_height);\n\n  /* TODO(jkoleszar): if an internal spatial resampling is active,\n   * and we downsize the input image, maybe we should clear the\n   * internal scale immediately rather than waiting for it to\n   * correct.\n   */\n\n  /* VP8 sharpness level mapping 0-7 (vs 0-10 in general VPx dialogs) */\n  if (cpi->oxcf.Sharpness > 7) cpi->oxcf.Sharpness = 7;\n\n  cm->sharpness_level = cpi->oxcf.Sharpness;\n\n  if (cm->horiz_scale != VP8E_NORMAL || cm->vert_scale != VP8E_NORMAL) {\n    int hr, hs, vr, vs;\n\n    Scale2Ratio(cm->horiz_scale, &hr, &hs);\n    Scale2Ratio(cm->vert_scale, &vr, &vs);\n\n    /* always go to the next whole number */\n    cm->Width = (hs - 1 + cpi->oxcf.Width * hr) / hs;\n    cm->Height = (vs - 1 + cpi->oxcf.Height * vr) / vs;\n  }\n\n  if (last_w != cpi->oxcf.Width || last_h != cpi->oxcf.Height) {\n    cpi->force_next_frame_intra = 1;\n  }\n\n  if (((cm->Width + 15) & ~15) != cm->yv12_fb[cm->lst_fb_idx].y_width ||\n      ((cm->Height + 15) & ~15) != cm->yv12_fb[cm->lst_fb_idx].y_height ||\n      cm->yv12_fb[cm->lst_fb_idx].y_width == 0) {\n    dealloc_raw_frame_buffers(cpi);\n    alloc_raw_frame_buffers(cpi);\n    vp8_alloc_compressor_data(cpi);\n  }\n\n  if (cpi->oxcf.fixed_q >= 0) {\n    cpi->last_q[0] = cpi->oxcf.fixed_q;\n    cpi->last_q[1] = cpi->oxcf.fixed_q;\n  }\n\n  cpi->Speed = cpi->oxcf.cpu_used;\n\n  /* force to allowlag to 0 if lag_in_frames is 0; */\n  if (cpi->oxcf.lag_in_frames == 0) {\n    cpi->oxcf.allow_lag = 0;\n  }\n  /* Limit on lag buffers as these are not currently dynamically allocated */\n  else if (cpi->oxcf.lag_in_frames > MAX_LAG_BUFFERS) {\n    cpi->oxcf.lag_in_frames = MAX_LAG_BUFFERS;\n  }\n\n  /* YX Temp */\n  cpi->alt_ref_source = NULL;\n  cpi->is_src_frame_alt_ref = 0;\n\n#if CONFIG_TEMPORAL_DENOISING\n  if (cpi->oxcf.noise_sensitivity) {\n    if (!cpi->denoiser.yv12_mc_running_avg.buffer_alloc) {\n      int width = (cpi->oxcf.Width + 15) & ~15;\n      int height = (cpi->oxcf.Height + 15) & ~15;\n      if (vp8_denoiser_allocate(&cpi->denoiser, width, height, cm->mb_rows,\n                                cm->mb_cols, cpi->oxcf.noise_sensitivity)) {\n        vpx_internal_error(&cpi->common.error, VPX_CODEC_MEM_ERROR,\n                           \"Failed to allocate denoiser\");\n      }\n    }\n  }\n#endif\n\n#if 0\n    /* Experimental RD Code */\n    cpi->frame_distortion = 0;\n    cpi->last_frame_distortion = 0;\n#endif\n}\n\n#ifndef M_LOG2_E\n#define M_LOG2_E 0.693147180559945309417\n#endif\n#define log2f(x) (log(x) / (float)M_LOG2_E)\n\nstatic void cal_mvsadcosts(int *mvsadcost[2]) {\n  int i = 1;\n\n  mvsadcost[0][0] = 300;\n  mvsadcost[1][0] = 300;\n\n  do {\n    double z = 256 * (2 * (log2f(8 * i) + .6));\n    mvsadcost[0][i] = (int)z;\n    mvsadcost[1][i] = (int)z;\n    mvsadcost[0][-i] = (int)z;\n    mvsadcost[1][-i] = (int)z;\n  } while (++i <= mvfp_max);\n}\n\nstruct VP8_COMP *vp8_create_compressor(VP8_CONFIG *oxcf) {\n  int i;\n\n  VP8_COMP *cpi;\n  VP8_COMMON *cm;\n\n  cpi = vpx_memalign(32, sizeof(VP8_COMP));\n  /* Check that the CPI instance is valid */\n  if (!cpi) return 0;\n\n  cm = &cpi->common;\n\n  memset(cpi, 0, sizeof(VP8_COMP));\n\n  if (setjmp(cm->error.jmp)) {\n    cpi->common.error.setjmp = 0;\n    vp8_remove_compressor(&cpi);\n    return 0;\n  }\n\n  cpi->common.error.setjmp = 1;\n\n  CHECK_MEM_ERROR(\n      &cpi->common.error, cpi->mb.ss,\n      vpx_calloc(sizeof(search_site), (MAX_MVSEARCH_STEPS * 8) + 1));\n\n  vp8_create_common(&cpi->common);\n\n  init_config(cpi, oxcf);\n\n  memcpy(cpi->base_skip_false_prob, vp8cx_base_skip_false_prob,\n         sizeof(vp8cx_base_skip_false_prob));\n  cpi->common.current_video_frame = 0;\n  cpi->temporal_pattern_counter = 0;\n  cpi->temporal_layer_id = -1;\n  cpi->kf_overspend_bits = 0;\n  cpi->kf_bitrate_adjustment = 0;\n  cpi->frames_till_gf_update_due = 0;\n  cpi->gf_overspend_bits = 0;\n  cpi->non_gf_bitrate_adjustment = 0;\n  cpi->prob_last_coded = 128;\n  cpi->prob_gf_coded = 128;\n  cpi->prob_intra_coded = 63;\n\n  /* Prime the recent reference frame usage counters.\n   * Hereafter they will be maintained as a sort of moving average\n   */\n  cpi->recent_ref_frame_usage[INTRA_FRAME] = 1;\n  cpi->recent_ref_frame_usage[LAST_FRAME] = 1;\n  cpi->recent_ref_frame_usage[GOLDEN_FRAME] = 1;\n  cpi->recent_ref_frame_usage[ALTREF_FRAME] = 1;\n\n  /* Set reference frame sign bias for ALTREF frame to 1 (for now) */\n  cpi->common.ref_frame_sign_bias[ALTREF_FRAME] = 1;\n\n  cpi->twopass.gf_decay_rate = 0;\n  cpi->baseline_gf_interval = DEFAULT_GF_INTERVAL;\n\n  cpi->gold_is_last = 0;\n  cpi->alt_is_last = 0;\n  cpi->gold_is_alt = 0;\n\n  cpi->active_map_enabled = 0;\n\n  cpi->use_roi_static_threshold = 0;\n\n#if 0\n    /* Experimental code for lagged and one pass */\n    /* Initialise one_pass GF frames stats */\n    /* Update stats used for GF selection */\n    if (cpi->pass == 0)\n    {\n        cpi->one_pass_frame_index = 0;\n\n        for (i = 0; i < MAX_LAG_BUFFERS; ++i)\n        {\n            cpi->one_pass_frame_stats[i].frames_so_far = 0;\n            cpi->one_pass_frame_stats[i].frame_intra_error = 0.0;\n            cpi->one_pass_frame_stats[i].frame_coded_error = 0.0;\n            cpi->one_pass_frame_stats[i].frame_pcnt_inter = 0.0;\n            cpi->one_pass_frame_stats[i].frame_pcnt_motion = 0.0;\n            cpi->one_pass_frame_stats[i].frame_mvr = 0.0;\n            cpi->one_pass_frame_stats[i].frame_mvr_abs = 0.0;\n            cpi->one_pass_frame_stats[i].frame_mvc = 0.0;\n            cpi->one_pass_frame_stats[i].frame_mvc_abs = 0.0;\n        }\n    }\n#endif\n\n  cpi->mse_source_denoised = 0;\n\n  /* Should we use the cyclic refresh method.\n   * Currently there is no external control for this.\n   * Enable it for error_resilient_mode, or for 1 pass CBR mode.\n   */\n  cpi->cyclic_refresh_mode_enabled =\n      (cpi->oxcf.error_resilient_mode ||\n       (cpi->oxcf.end_usage == USAGE_STREAM_FROM_SERVER &&\n        cpi->oxcf.Mode <= 2));\n  cpi->cyclic_refresh_mode_max_mbs_perframe =\n      (cpi->common.mb_rows * cpi->common.mb_cols) / 7;\n  if (cpi->oxcf.number_of_layers == 1) {\n    cpi->cyclic_refresh_mode_max_mbs_perframe =\n        (cpi->common.mb_rows * cpi->common.mb_cols) / 20;\n  } else if (cpi->oxcf.number_of_layers == 2) {\n    cpi->cyclic_refresh_mode_max_mbs_perframe =\n        (cpi->common.mb_rows * cpi->common.mb_cols) / 10;\n  }\n  cpi->cyclic_refresh_mode_index = 0;\n  cpi->cyclic_refresh_q = 32;\n\n  // GF behavior for 1 pass CBR, used when error_resilience is off.\n  cpi->gf_update_onepass_cbr = 0;\n  cpi->gf_noboost_onepass_cbr = 0;\n  if (!cpi->oxcf.error_resilient_mode &&\n      cpi->oxcf.end_usage == USAGE_STREAM_FROM_SERVER && cpi->oxcf.Mode <= 2) {\n    cpi->gf_update_onepass_cbr = 1;\n    cpi->gf_noboost_onepass_cbr = 1;\n    cpi->gf_interval_onepass_cbr =\n        cpi->cyclic_refresh_mode_max_mbs_perframe > 0\n            ? (2 * (cpi->common.mb_rows * cpi->common.mb_cols) /\n               cpi->cyclic_refresh_mode_max_mbs_perframe)\n            : 10;\n    cpi->gf_interval_onepass_cbr =\n        VPXMIN(40, VPXMAX(6, cpi->gf_interval_onepass_cbr));\n    cpi->baseline_gf_interval = cpi->gf_interval_onepass_cbr;\n  }\n\n  if (cpi->cyclic_refresh_mode_enabled) {\n    CHECK_MEM_ERROR(&cpi->common.error, cpi->cyclic_refresh_map,\n                    vpx_calloc((cpi->common.mb_rows * cpi->common.mb_cols), 1));\n  } else {\n    cpi->cyclic_refresh_map = (signed char *)NULL;\n  }\n\n  CHECK_MEM_ERROR(\n      &cpi->common.error, cpi->skin_map,\n      vpx_calloc(cm->mb_rows * cm->mb_cols, sizeof(cpi->skin_map[0])));\n\n  CHECK_MEM_ERROR(&cpi->common.error, cpi->consec_zero_last,\n                  vpx_calloc(cm->mb_rows * cm->mb_cols, 1));\n  CHECK_MEM_ERROR(&cpi->common.error, cpi->consec_zero_last_mvbias,\n                  vpx_calloc((cpi->common.mb_rows * cpi->common.mb_cols), 1));\n\n  /*Initialize the feed-forward activity masking.*/\n  cpi->activity_avg = 90 << 12;\n\n  /* Give a sensible default for the first frame. */\n  cpi->frames_since_key = 8;\n  cpi->key_frame_frequency = cpi->oxcf.key_freq;\n  cpi->this_key_frame_forced = 0;\n  cpi->next_key_frame_forced = 0;\n\n  cpi->source_alt_ref_pending = 0;\n  cpi->source_alt_ref_active = 0;\n  cpi->common.refresh_alt_ref_frame = 0;\n\n  cpi->force_maxqp = 0;\n  cpi->frames_since_last_drop_overshoot = 0;\n  cpi->rt_always_update_correction_factor = 0;\n\n  cpi->b_calculate_psnr = CONFIG_INTERNAL_STATS;\n#if CONFIG_INTERNAL_STATS\n  cpi->b_calculate_ssimg = 0;\n\n  cpi->count = 0;\n  cpi->bytes = 0;\n\n  if (cpi->b_calculate_psnr) {\n    cpi->total_sq_error = 0.0;\n    cpi->total_sq_error2 = 0.0;\n    cpi->total_y = 0.0;\n    cpi->total_u = 0.0;\n    cpi->total_v = 0.0;\n    cpi->total = 0.0;\n    cpi->totalp_y = 0.0;\n    cpi->totalp_u = 0.0;\n    cpi->totalp_v = 0.0;\n    cpi->totalp = 0.0;\n    cpi->tot_recode_hits = 0;\n    cpi->summed_quality = 0;\n    cpi->summed_weights = 0;\n  }\n\n#endif\n\n  cpi->first_time_stamp_ever = 0x7FFFFFFF;\n\n  cpi->frames_till_gf_update_due = 0;\n  cpi->key_frame_count = 1;\n\n  cpi->ni_av_qi = cpi->oxcf.worst_allowed_q;\n  cpi->ni_tot_qi = 0;\n  cpi->ni_frames = 0;\n  cpi->total_byte_count = 0;\n\n  cpi->drop_frame = 0;\n\n  cpi->rate_correction_factor = 1.0;\n  cpi->key_frame_rate_correction_factor = 1.0;\n  cpi->gf_rate_correction_factor = 1.0;\n  cpi->twopass.est_max_qcorrection_factor = 1.0;\n\n  for (i = 0; i < KEY_FRAME_CONTEXT; ++i) {\n    cpi->prior_key_frame_distance[i] = (int)cpi->output_framerate;\n  }\n\n#ifdef OUTPUT_YUV_SRC\n  yuv_file = fopen(\"bd.yuv\", \"ab\");\n#endif\n#ifdef OUTPUT_YUV_DENOISED\n  yuv_denoised_file = fopen(\"denoised.yuv\", \"ab\");\n#endif\n#ifdef OUTPUT_YUV_SKINMAP\n  yuv_skinmap_file = fopen(\"skinmap.yuv\", \"wb\");\n#endif\n\n#if 0\n    framepsnr = fopen(\"framepsnr.stt\", \"a\");\n    kf_list = fopen(\"kf_list.stt\", \"w\");\n#endif\n\n  cpi->output_pkt_list = oxcf->output_pkt_list;\n\n#if !CONFIG_REALTIME_ONLY\n\n  if (cpi->pass == 1) {\n    vp8_init_first_pass(cpi);\n  } else if (cpi->pass == 2) {\n    size_t packet_sz = sizeof(FIRSTPASS_STATS);\n    int packets = (int)(oxcf->two_pass_stats_in.sz / packet_sz);\n\n    cpi->twopass.stats_in_start = oxcf->two_pass_stats_in.buf;\n    cpi->twopass.stats_in = cpi->twopass.stats_in_start;\n    cpi->twopass.stats_in_end =\n        (void *)((char *)cpi->twopass.stats_in + (packets - 1) * packet_sz);\n    vp8_init_second_pass(cpi);\n  }\n\n#endif\n\n  if (cpi->compressor_speed == 2) {\n    cpi->avg_encode_time = 0;\n    cpi->avg_pick_mode_time = 0;\n  }\n\n  vp8_set_speed_features(cpi);\n\n  /* Set starting values of RD threshold multipliers (128 = *1) */\n  for (i = 0; i < MAX_MODES; ++i) {\n    cpi->mb.rd_thresh_mult[i] = 128;\n  }\n\n#if CONFIG_MULTITHREAD\n  if (vp8cx_create_encoder_threads(cpi)) {\n    vp8_remove_compressor(&cpi);\n    return 0;\n  }\n#endif\n\n  cpi->fn_ptr[BLOCK_16X16].sdf = vpx_sad16x16;\n  cpi->fn_ptr[BLOCK_16X16].vf = vpx_variance16x16;\n  cpi->fn_ptr[BLOCK_16X16].svf = vpx_sub_pixel_variance16x16;\n  cpi->fn_ptr[BLOCK_16X16].sdx4df = vpx_sad16x16x4d;\n\n  cpi->fn_ptr[BLOCK_16X8].sdf = vpx_sad16x8;\n  cpi->fn_ptr[BLOCK_16X8].vf = vpx_variance16x8;\n  cpi->fn_ptr[BLOCK_16X8].svf = vpx_sub_pixel_variance16x8;\n  cpi->fn_ptr[BLOCK_16X8].sdx4df = vpx_sad16x8x4d;\n\n  cpi->fn_ptr[BLOCK_8X16].sdf = vpx_sad8x16;\n  cpi->fn_ptr[BLOCK_8X16].vf = vpx_variance8x16;\n  cpi->fn_ptr[BLOCK_8X16].svf = vpx_sub_pixel_variance8x16;\n  cpi->fn_ptr[BLOCK_8X16].sdx4df = vpx_sad8x16x4d;\n\n  cpi->fn_ptr[BLOCK_8X8].sdf = vpx_sad8x8;\n  cpi->fn_ptr[BLOCK_8X8].vf = vpx_variance8x8;\n  cpi->fn_ptr[BLOCK_8X8].svf = vpx_sub_pixel_variance8x8;\n  cpi->fn_ptr[BLOCK_8X8].sdx4df = vpx_sad8x8x4d;\n\n  cpi->fn_ptr[BLOCK_4X4].sdf = vpx_sad4x4;\n  cpi->fn_ptr[BLOCK_4X4].vf = vpx_variance4x4;\n  cpi->fn_ptr[BLOCK_4X4].svf = vpx_sub_pixel_variance4x4;\n  cpi->fn_ptr[BLOCK_4X4].sdx4df = vpx_sad4x4x4d;\n\n#if VPX_ARCH_X86 || VPX_ARCH_X86_64\n  cpi->fn_ptr[BLOCK_16X16].copymem = vp8_copy32xn;\n  cpi->fn_ptr[BLOCK_16X8].copymem = vp8_copy32xn;\n  cpi->fn_ptr[BLOCK_8X16].copymem = vp8_copy32xn;\n  cpi->fn_ptr[BLOCK_8X8].copymem = vp8_copy32xn;\n  cpi->fn_ptr[BLOCK_4X4].copymem = vp8_copy32xn;\n#endif\n\n  cpi->diamond_search_sad = vp8_diamond_search_sad;\n  cpi->refining_search_sad = vp8_refining_search_sad;\n\n  /* make sure frame 1 is okay */\n  cpi->mb.error_bins[0] = cpi->common.MBs;\n\n  /* vp8cx_init_quantizer() is first called here. Add check in\n   * vp8cx_frame_init_quantizer() so that vp8cx_init_quantizer is only\n   * called later when needed. This will avoid unnecessary calls of\n   * vp8cx_init_quantizer() for every frame.\n   */\n  vp8cx_init_quantizer(cpi);\n\n  vp8_loop_filter_init(cm);\n\n  cpi->common.error.setjmp = 0;\n\n#if CONFIG_MULTI_RES_ENCODING\n\n  /* Calculate # of MBs in a row in lower-resolution level image. */\n  if (cpi->oxcf.mr_encoder_id > 0) vp8_cal_low_res_mb_cols(cpi);\n\n#endif\n\n  /* setup RD costs to MACROBLOCK struct */\n\n  cpi->mb.mvcost[0] = &cpi->rd_costs.mvcosts[0][mv_max + 1];\n  cpi->mb.mvcost[1] = &cpi->rd_costs.mvcosts[1][mv_max + 1];\n  cpi->mb.mvsadcost[0] = &cpi->rd_costs.mvsadcosts[0][mvfp_max + 1];\n  cpi->mb.mvsadcost[1] = &cpi->rd_costs.mvsadcosts[1][mvfp_max + 1];\n\n  cal_mvsadcosts(cpi->mb.mvsadcost);\n\n  cpi->mb.mbmode_cost = cpi->rd_costs.mbmode_cost;\n  cpi->mb.intra_uv_mode_cost = cpi->rd_costs.intra_uv_mode_cost;\n  cpi->mb.bmode_costs = cpi->rd_costs.bmode_costs;\n  cpi->mb.inter_bmode_costs = cpi->rd_costs.inter_bmode_costs;\n  cpi->mb.token_costs = cpi->rd_costs.token_costs;\n\n  /* setup block ptrs & offsets */\n  vp8_setup_block_ptrs(&cpi->mb);\n  vp8_setup_block_dptrs(&cpi->mb.e_mbd);\n\n  return cpi;\n}\n\nvoid vp8_remove_compressor(VP8_COMP **comp) {\n  VP8_COMP *cpi = *comp;\n\n  if (!cpi) return;\n\n  if (cpi && (cpi->common.current_video_frame > 0)) {\n#if !CONFIG_REALTIME_ONLY\n\n    if (cpi->pass == 2) {\n      vp8_end_second_pass(cpi);\n    }\n\n#endif\n\n#if CONFIG_INTERNAL_STATS\n\n    if (cpi->pass != 1) {\n      FILE *f = fopen(\"opsnr.stt\", \"a\");\n      double time_encoded =\n          (cpi->last_end_time_stamp_seen - cpi->first_time_stamp_ever) /\n          10000000.000;\n\n      if (cpi->b_calculate_psnr) {\n        if (cpi->oxcf.number_of_layers > 1) {\n          int i;\n\n          fprintf(f,\n                  \"Layer\\tBitrate\\tAVGPsnr\\tGLBPsnr\\tAVPsnrP\\t\"\n                  \"GLPsnrP\\tVPXSSIM\\n\");\n          for (i = 0; i < (int)cpi->oxcf.number_of_layers; ++i) {\n            double dr =\n                (double)cpi->bytes_in_layer[i] * 8.0 / 1000.0 / time_encoded;\n            double samples = 3.0 / 2 * cpi->frames_in_layer[i] *\n                             cpi->common.Width * cpi->common.Height;\n            double total_psnr =\n                vpx_sse_to_psnr(samples, 255.0, cpi->total_error2[i]);\n            double total_psnr2 =\n                vpx_sse_to_psnr(samples, 255.0, cpi->total_error2_p[i]);\n            double total_ssim =\n                100 * pow(cpi->sum_ssim[i] / cpi->sum_weights[i], 8.0);\n\n            fprintf(f,\n                    \"%5d\\t%7.3f\\t%7.3f\\t%7.3f\\t%7.3f\\t\"\n                    \"%7.3f\\t%7.3f\\n\",\n                    i, dr, cpi->sum_psnr[i] / cpi->frames_in_layer[i],\n                    total_psnr, cpi->sum_psnr_p[i] / cpi->frames_in_layer[i],\n                    total_psnr2, total_ssim);\n          }\n        } else {\n          double dr = (double)cpi->bytes * 8.0 / 1000.0 / time_encoded;\n          double samples =\n              3.0 / 2 * cpi->count * cpi->common.Width * cpi->common.Height;\n          double total_psnr =\n              vpx_sse_to_psnr(samples, 255.0, cpi->total_sq_error);\n          double total_psnr2 =\n              vpx_sse_to_psnr(samples, 255.0, cpi->total_sq_error2);\n          double total_ssim =\n              100 * pow(cpi->summed_quality / cpi->summed_weights, 8.0);\n\n          fprintf(f,\n                  \"Bitrate\\tAVGPsnr\\tGLBPsnr\\tAVPsnrP\\t\"\n                  \"GLPsnrP\\tVPXSSIM\\n\");\n          fprintf(f,\n                  \"%7.3f\\t%7.3f\\t%7.3f\\t%7.3f\\t%7.3f\\t\"\n                  \"%7.3f\\n\",\n                  dr, cpi->total / cpi->count, total_psnr,\n                  cpi->totalp / cpi->count, total_psnr2, total_ssim);\n        }\n      }\n      fclose(f);\n#if 0\n            f = fopen(\"qskip.stt\", \"a\");\n            fprintf(f, \"minq:%d -maxq:%d skiptrue:skipfalse = %d:%d\\n\", cpi->oxcf.best_allowed_q, cpi->oxcf.worst_allowed_q, skiptruecount, skipfalsecount);\n            fclose(f);\n#endif\n    }\n\n#endif\n\n#ifdef SPEEDSTATS\n\n    if (cpi->compressor_speed == 2) {\n      int i;\n      FILE *f = fopen(\"cxspeed.stt\", \"a\");\n      cnt_pm /= cpi->common.MBs;\n\n      for (i = 0; i < 16; ++i) fprintf(f, \"%5d\", frames_at_speed[i]);\n\n      fprintf(f, \"\\n\");\n      fclose(f);\n    }\n\n#endif\n\n#ifdef MODE_STATS\n    {\n      extern int count_mb_seg[4];\n      FILE *f = fopen(\"modes.stt\", \"a\");\n      double dr = (double)cpi->framerate * (double)bytes * (double)8 /\n                  (double)count / (double)1000;\n      fprintf(f, \"intra_mode in Intra Frames:\\n\");\n      fprintf(f, \"Y: %8d, %8d, %8d, %8d, %8d\\n\", y_modes[0], y_modes[1],\n              y_modes[2], y_modes[3], y_modes[4]);\n      fprintf(f, \"UV:%8d, %8d, %8d, %8d\\n\", uv_modes[0], uv_modes[1],\n              uv_modes[2], uv_modes[3]);\n      fprintf(f, \"B: \");\n      {\n        int i;\n\n        for (i = 0; i < 10; ++i) fprintf(f, \"%8d, \", b_modes[i]);\n\n        fprintf(f, \"\\n\");\n      }\n\n      fprintf(f, \"Modes in Inter Frames:\\n\");\n      fprintf(f, \"Y: %8d, %8d, %8d, %8d, %8d, %8d, %8d, %8d, %8d, %8d\\n\",\n              inter_y_modes[0], inter_y_modes[1], inter_y_modes[2],\n              inter_y_modes[3], inter_y_modes[4], inter_y_modes[5],\n              inter_y_modes[6], inter_y_modes[7], inter_y_modes[8],\n              inter_y_modes[9]);\n      fprintf(f, \"UV:%8d, %8d, %8d, %8d\\n\", inter_uv_modes[0],\n              inter_uv_modes[1], inter_uv_modes[2], inter_uv_modes[3]);\n      fprintf(f, \"B: \");\n      {\n        int i;\n\n        for (i = 0; i < 15; ++i) fprintf(f, \"%8d, \", inter_b_modes[i]);\n\n        fprintf(f, \"\\n\");\n      }\n      fprintf(f, \"P:%8d, %8d, %8d, %8d\\n\", count_mb_seg[0], count_mb_seg[1],\n              count_mb_seg[2], count_mb_seg[3]);\n      fprintf(f, \"PB:%8d, %8d, %8d, %8d\\n\", inter_b_modes[LEFT4X4],\n              inter_b_modes[ABOVE4X4], inter_b_modes[ZERO4X4],\n              inter_b_modes[NEW4X4]);\n\n      fclose(f);\n    }\n#endif\n\n#if defined(SECTIONBITS_OUTPUT)\n\n    if (0) {\n      int i;\n      FILE *f = fopen(\"tokenbits.stt\", \"a\");\n\n      for (i = 0; i < 28; ++i) fprintf(f, \"%8d\", (int)(Sectionbits[i] / 256));\n\n      fprintf(f, \"\\n\");\n      fclose(f);\n    }\n\n#endif\n\n#if 0\n        {\n            printf(\"\\n_pick_loop_filter_level:%d\\n\", cpi->time_pick_lpf / 1000);\n            printf(\"\\n_frames receive_data encod_mb_row compress_frame  Total\\n\");\n            printf(\"%6d %10ld %10ld %10ld %10ld\\n\", cpi->common.current_video_frame, cpi->time_receive_data / 1000, cpi->time_encode_mb_row / 1000, cpi->time_compress_data / 1000, (cpi->time_receive_data + cpi->time_compress_data) / 1000);\n        }\n#endif\n  }\n\n#if CONFIG_MULTITHREAD\n  vp8cx_remove_encoder_threads(cpi);\n#endif\n\n#if CONFIG_TEMPORAL_DENOISING\n  vp8_denoiser_free(&cpi->denoiser);\n#endif\n  dealloc_compressor_data(cpi);\n  vpx_free(cpi->mb.ss);\n  vpx_free(cpi->tok);\n  vpx_free(cpi->skin_map);\n  vpx_free(cpi->cyclic_refresh_map);\n  vpx_free(cpi->consec_zero_last);\n  vpx_free(cpi->consec_zero_last_mvbias);\n\n  vp8_remove_common(&cpi->common);\n  vpx_free(cpi);\n  *comp = 0;\n\n#ifdef OUTPUT_YUV_SRC\n  fclose(yuv_file);\n#endif\n#ifdef OUTPUT_YUV_DENOISED\n  fclose(yuv_denoised_file);\n#endif\n#ifdef OUTPUT_YUV_SKINMAP\n  fclose(yuv_skinmap_file);\n#endif\n\n#if 0\n\n    if (keyfile)\n        fclose(keyfile);\n\n    if (framepsnr)\n        fclose(framepsnr);\n\n    if (kf_list)\n        fclose(kf_list);\n\n#endif\n}\n\nstatic uint64_t calc_plane_error(unsigned char *orig, int orig_stride,\n                                 unsigned char *recon, int recon_stride,\n                                 unsigned int cols, unsigned int rows) {\n  unsigned int row, col;\n  uint64_t total_sse = 0;\n  int diff;\n\n  for (row = 0; row + 16 <= rows; row += 16) {\n    for (col = 0; col + 16 <= cols; col += 16) {\n      unsigned int sse;\n\n      vpx_mse16x16(orig + col, orig_stride, recon + col, recon_stride, &sse);\n      total_sse += sse;\n    }\n\n    /* Handle odd-sized width */\n    if (col < cols) {\n      unsigned int border_row, border_col;\n      unsigned char *border_orig = orig;\n      unsigned char *border_recon = recon;\n\n      for (border_row = 0; border_row < 16; ++border_row) {\n        for (border_col = col; border_col < cols; ++border_col) {\n          diff = border_orig[border_col] - border_recon[border_col];\n          total_sse += diff * diff;\n        }\n\n        border_orig += orig_stride;\n        border_recon += recon_stride;\n      }\n    }\n\n    orig += orig_stride * 16;\n    recon += recon_stride * 16;\n  }\n\n  /* Handle odd-sized height */\n  for (; row < rows; ++row) {\n    for (col = 0; col < cols; ++col) {\n      diff = orig[col] - recon[col];\n      total_sse += diff * diff;\n    }\n\n    orig += orig_stride;\n    recon += recon_stride;\n  }\n\n  vpx_clear_system_state();\n  return total_sse;\n}\n\nstatic void generate_psnr_packet(VP8_COMP *cpi) {\n  YV12_BUFFER_CONFIG *orig = cpi->Source;\n  YV12_BUFFER_CONFIG *recon = cpi->common.frame_to_show;\n  struct vpx_codec_cx_pkt pkt;\n  uint64_t sse;\n  int i;\n  unsigned int width = cpi->common.Width;\n  unsigned int height = cpi->common.Height;\n\n  pkt.kind = VPX_CODEC_PSNR_PKT;\n  sse = calc_plane_error(orig->y_buffer, orig->y_stride, recon->y_buffer,\n                         recon->y_stride, width, height);\n  pkt.data.psnr.sse[0] = sse;\n  pkt.data.psnr.sse[1] = sse;\n  pkt.data.psnr.samples[0] = width * height;\n  pkt.data.psnr.samples[1] = width * height;\n\n  width = (width + 1) / 2;\n  height = (height + 1) / 2;\n\n  sse = calc_plane_error(orig->u_buffer, orig->uv_stride, recon->u_buffer,\n                         recon->uv_stride, width, height);\n  pkt.data.psnr.sse[0] += sse;\n  pkt.data.psnr.sse[2] = sse;\n  pkt.data.psnr.samples[0] += width * height;\n  pkt.data.psnr.samples[2] = width * height;\n\n  sse = calc_plane_error(orig->v_buffer, orig->uv_stride, recon->v_buffer,\n                         recon->uv_stride, width, height);\n  pkt.data.psnr.sse[0] += sse;\n  pkt.data.psnr.sse[3] = sse;\n  pkt.data.psnr.samples[0] += width * height;\n  pkt.data.psnr.samples[3] = width * height;\n\n  for (i = 0; i < 4; ++i) {\n    pkt.data.psnr.psnr[i] = vpx_sse_to_psnr(pkt.data.psnr.samples[i], 255.0,\n                                            (double)(pkt.data.psnr.sse[i]));\n  }\n\n  vpx_codec_pkt_list_add(cpi->output_pkt_list, &pkt);\n}\n\nint vp8_use_as_reference(VP8_COMP *cpi, int ref_frame_flags) {\n  if (ref_frame_flags > 7) return -1;\n\n  cpi->ref_frame_flags = ref_frame_flags;\n  return 0;\n}\nint vp8_update_reference(VP8_COMP *cpi, int ref_frame_flags) {\n  if (ref_frame_flags > 7) return -1;\n\n  cpi->common.refresh_golden_frame = 0;\n  cpi->common.refresh_alt_ref_frame = 0;\n  cpi->common.refresh_last_frame = 0;\n\n  if (ref_frame_flags & VP8_LAST_FRAME) cpi->common.refresh_last_frame = 1;\n\n  if (ref_frame_flags & VP8_GOLD_FRAME) cpi->common.refresh_golden_frame = 1;\n\n  if (ref_frame_flags & VP8_ALTR_FRAME) cpi->common.refresh_alt_ref_frame = 1;\n\n  cpi->ext_refresh_frame_flags_pending = 1;\n  return 0;\n}\n\nint vp8_get_reference(VP8_COMP *cpi, enum vpx_ref_frame_type ref_frame_flag,\n                      YV12_BUFFER_CONFIG *sd) {\n  VP8_COMMON *cm = &cpi->common;\n  int ref_fb_idx;\n\n  if (ref_frame_flag == VP8_LAST_FRAME) {\n    ref_fb_idx = cm->lst_fb_idx;\n  } else if (ref_frame_flag == VP8_GOLD_FRAME) {\n    ref_fb_idx = cm->gld_fb_idx;\n  } else if (ref_frame_flag == VP8_ALTR_FRAME) {\n    ref_fb_idx = cm->alt_fb_idx;\n  } else {\n    return -1;\n  }\n\n  vp8_yv12_copy_frame(&cm->yv12_fb[ref_fb_idx], sd);\n\n  return 0;\n}\nint vp8_set_reference(VP8_COMP *cpi, enum vpx_ref_frame_type ref_frame_flag,\n                      YV12_BUFFER_CONFIG *sd) {\n  VP8_COMMON *cm = &cpi->common;\n\n  int ref_fb_idx;\n\n  if (ref_frame_flag == VP8_LAST_FRAME) {\n    ref_fb_idx = cm->lst_fb_idx;\n  } else if (ref_frame_flag == VP8_GOLD_FRAME) {\n    ref_fb_idx = cm->gld_fb_idx;\n  } else if (ref_frame_flag == VP8_ALTR_FRAME) {\n    ref_fb_idx = cm->alt_fb_idx;\n  } else {\n    return -1;\n  }\n\n  vp8_yv12_copy_frame(sd, &cm->yv12_fb[ref_fb_idx]);\n\n  return 0;\n}\nint vp8_update_entropy(VP8_COMP *cpi, int update) {\n  VP8_COMMON *cm = &cpi->common;\n  cm->refresh_entropy_probs = update;\n\n  return 0;\n}\n\nstatic void scale_and_extend_source(YV12_BUFFER_CONFIG *sd, VP8_COMP *cpi) {\n  VP8_COMMON *cm = &cpi->common;\n\n  /* are we resizing the image */\n  if (cm->horiz_scale != 0 || cm->vert_scale != 0) {\n#if CONFIG_SPATIAL_RESAMPLING\n    int hr, hs, vr, vs;\n    int tmp_height;\n\n    if (cm->vert_scale == 3) {\n      tmp_height = 9;\n    } else {\n      tmp_height = 11;\n    }\n\n    Scale2Ratio(cm->horiz_scale, &hr, &hs);\n    Scale2Ratio(cm->vert_scale, &vr, &vs);\n\n    vpx_scale_frame(sd, &cpi->scaled_source, cm->temp_scale_frame.y_buffer,\n                    tmp_height, hs, hr, vs, vr, 0);\n\n    vp8_yv12_extend_frame_borders(&cpi->scaled_source);\n    cpi->Source = &cpi->scaled_source;\n#endif\n  } else {\n    cpi->Source = sd;\n  }\n}\n\nstatic int resize_key_frame(VP8_COMP *cpi) {\n#if CONFIG_SPATIAL_RESAMPLING\n  VP8_COMMON *cm = &cpi->common;\n\n  /* Do we need to apply resampling for one pass cbr.\n   * In one pass this is more limited than in two pass cbr.\n   * The test and any change is only made once per key frame sequence.\n   */\n  if (cpi->oxcf.allow_spatial_resampling &&\n      (cpi->oxcf.end_usage == USAGE_STREAM_FROM_SERVER)) {\n    int hr, hs, vr, vs;\n    int new_width, new_height;\n\n    /* If we are below the resample DOWN watermark then scale down a\n     * notch.\n     */\n    if (cpi->buffer_level < (cpi->oxcf.resample_down_water_mark *\n                             cpi->oxcf.optimal_buffer_level / 100)) {\n      cm->horiz_scale =\n          (cm->horiz_scale < VP8E_ONETWO) ? cm->horiz_scale + 1 : VP8E_ONETWO;\n      cm->vert_scale =\n          (cm->vert_scale < VP8E_ONETWO) ? cm->vert_scale + 1 : VP8E_ONETWO;\n    }\n    /* Should we now start scaling back up */\n    else if (cpi->buffer_level > (cpi->oxcf.resample_up_water_mark *\n                                  cpi->oxcf.optimal_buffer_level / 100)) {\n      cm->horiz_scale =\n          (cm->horiz_scale > VP8E_NORMAL) ? cm->horiz_scale - 1 : VP8E_NORMAL;\n      cm->vert_scale =\n          (cm->vert_scale > VP8E_NORMAL) ? cm->vert_scale - 1 : VP8E_NORMAL;\n    }\n\n    /* Get the new height and width */\n    Scale2Ratio(cm->horiz_scale, &hr, &hs);\n    Scale2Ratio(cm->vert_scale, &vr, &vs);\n    new_width = ((hs - 1) + (cpi->oxcf.Width * hr)) / hs;\n    new_height = ((vs - 1) + (cpi->oxcf.Height * vr)) / vs;\n\n    /* If the image size has changed we need to reallocate the buffers\n     * and resample the source image\n     */\n    if ((cm->Width != new_width) || (cm->Height != new_height)) {\n      cm->Width = new_width;\n      cm->Height = new_height;\n      vp8_alloc_compressor_data(cpi);\n      scale_and_extend_source(cpi->un_scaled_source, cpi);\n      return 1;\n    }\n  }\n\n#endif\n  return 0;\n}\n\nstatic void update_alt_ref_frame_stats(VP8_COMP *cpi) {\n  VP8_COMMON *cm = &cpi->common;\n\n  /* Select an interval before next GF or altref */\n  if (!cpi->auto_gold) cpi->frames_till_gf_update_due = DEFAULT_GF_INTERVAL;\n\n  if ((cpi->pass != 2) && cpi->frames_till_gf_update_due) {\n    cpi->current_gf_interval = cpi->frames_till_gf_update_due;\n\n    /* Set the bits per frame that we should try and recover in\n     * subsequent inter frames to account for the extra GF spend...\n     * note that his does not apply for GF updates that occur\n     * coincident with a key frame as the extra cost of key frames is\n     * dealt with elsewhere.\n     */\n    cpi->gf_overspend_bits += cpi->projected_frame_size;\n    cpi->non_gf_bitrate_adjustment =\n        cpi->gf_overspend_bits / cpi->frames_till_gf_update_due;\n  }\n\n  /* Update data structure that monitors level of reference to last GF */\n  memset(cpi->gf_active_flags, 1, (cm->mb_rows * cm->mb_cols));\n  cpi->gf_active_count = cm->mb_rows * cm->mb_cols;\n\n  /* this frame refreshes means next frames don't unless specified by user */\n  cpi->frames_since_golden = 0;\n\n  /* Clear the alternate reference update pending flag. */\n  cpi->source_alt_ref_pending = 0;\n\n  /* Set the alternate reference frame active flag */\n  cpi->source_alt_ref_active = 1;\n}\nstatic void update_golden_frame_stats(VP8_COMP *cpi) {\n  VP8_COMMON *cm = &cpi->common;\n\n  /* Update the Golden frame usage counts. */\n  if (cm->refresh_golden_frame) {\n    /* Select an interval before next GF */\n    if (!cpi->auto_gold) cpi->frames_till_gf_update_due = DEFAULT_GF_INTERVAL;\n\n    if ((cpi->pass != 2) && (cpi->frames_till_gf_update_due > 0)) {\n      cpi->current_gf_interval = cpi->frames_till_gf_update_due;\n\n      /* Set the bits per frame that we should try and recover in\n       * subsequent inter frames to account for the extra GF spend...\n       * note that his does not apply for GF updates that occur\n       * coincident with a key frame as the extra cost of key frames\n       * is dealt with elsewhere.\n       */\n      if ((cm->frame_type != KEY_FRAME) && !cpi->source_alt_ref_active) {\n        /* Calcluate GF bits to be recovered\n         * Projected size - av frame bits available for inter\n         * frames for clip as a whole\n         */\n        cpi->gf_overspend_bits +=\n            (cpi->projected_frame_size - cpi->inter_frame_target);\n      }\n\n      cpi->non_gf_bitrate_adjustment =\n          cpi->gf_overspend_bits / cpi->frames_till_gf_update_due;\n    }\n\n    /* Update data structure that monitors level of reference to last GF */\n    memset(cpi->gf_active_flags, 1, (cm->mb_rows * cm->mb_cols));\n    cpi->gf_active_count = cm->mb_rows * cm->mb_cols;\n\n    /* this frame refreshes means next frames don't unless specified by\n     * user\n     */\n    cm->refresh_golden_frame = 0;\n    cpi->frames_since_golden = 0;\n\n    cpi->recent_ref_frame_usage[INTRA_FRAME] = 1;\n    cpi->recent_ref_frame_usage[LAST_FRAME] = 1;\n    cpi->recent_ref_frame_usage[GOLDEN_FRAME] = 1;\n    cpi->recent_ref_frame_usage[ALTREF_FRAME] = 1;\n\n    /* ******** Fixed Q test code only ************ */\n    /* If we are going to use the ALT reference for the next group of\n     * frames set a flag to say so.\n     */\n    if (cpi->oxcf.fixed_q >= 0 && cpi->oxcf.play_alternate &&\n        !cpi->common.refresh_alt_ref_frame) {\n      cpi->source_alt_ref_pending = 1;\n      cpi->frames_till_gf_update_due = cpi->baseline_gf_interval;\n    }\n\n    if (!cpi->source_alt_ref_pending) cpi->source_alt_ref_active = 0;\n\n    /* Decrement count down till next gf */\n    if (cpi->frames_till_gf_update_due > 0) cpi->frames_till_gf_update_due--;\n\n  } else if (!cpi->common.refresh_alt_ref_frame) {\n    /* Decrement count down till next gf */\n    if (cpi->frames_till_gf_update_due > 0) cpi->frames_till_gf_update_due--;\n\n    if (cpi->frames_till_alt_ref_frame) cpi->frames_till_alt_ref_frame--;\n\n    cpi->frames_since_golden++;\n\n    if (cpi->frames_since_golden > 1) {\n      cpi->recent_ref_frame_usage[INTRA_FRAME] +=\n          cpi->mb.count_mb_ref_frame_usage[INTRA_FRAME];\n      cpi->recent_ref_frame_usage[LAST_FRAME] +=\n          cpi->mb.count_mb_ref_frame_usage[LAST_FRAME];\n      cpi->recent_ref_frame_usage[GOLDEN_FRAME] +=\n          cpi->mb.count_mb_ref_frame_usage[GOLDEN_FRAME];\n      cpi->recent_ref_frame_usage[ALTREF_FRAME] +=\n          cpi->mb.count_mb_ref_frame_usage[ALTREF_FRAME];\n    }\n  }\n}\n\n/* This function updates the reference frame probability estimates that\n * will be used during mode selection\n */\nstatic void update_rd_ref_frame_probs(VP8_COMP *cpi) {\n  VP8_COMMON *cm = &cpi->common;\n\n  const int *const rfct = cpi->mb.count_mb_ref_frame_usage;\n  const int rf_intra = rfct[INTRA_FRAME];\n  const int rf_inter =\n      rfct[LAST_FRAME] + rfct[GOLDEN_FRAME] + rfct[ALTREF_FRAME];\n\n  if (cm->frame_type == KEY_FRAME) {\n    cpi->prob_intra_coded = 255;\n    cpi->prob_last_coded = 128;\n    cpi->prob_gf_coded = 128;\n  } else if (!(rf_intra + rf_inter)) {\n    cpi->prob_intra_coded = 63;\n    cpi->prob_last_coded = 128;\n    cpi->prob_gf_coded = 128;\n  }\n\n  /* update reference frame costs since we can do better than what we got\n   * last frame.\n   */\n  if (cpi->oxcf.number_of_layers == 1) {\n    if (cpi->common.refresh_alt_ref_frame) {\n      cpi->prob_intra_coded += 40;\n      if (cpi->prob_intra_coded > 255) cpi->prob_intra_coded = 255;\n      cpi->prob_last_coded = 200;\n      cpi->prob_gf_coded = 1;\n    } else if (cpi->frames_since_golden == 0) {\n      cpi->prob_last_coded = 214;\n    } else if (cpi->frames_since_golden == 1) {\n      cpi->prob_last_coded = 192;\n      cpi->prob_gf_coded = 220;\n    } else if (cpi->source_alt_ref_active) {\n      cpi->prob_gf_coded -= 20;\n\n      if (cpi->prob_gf_coded < 10) cpi->prob_gf_coded = 10;\n    }\n    if (!cpi->source_alt_ref_active) cpi->prob_gf_coded = 255;\n  }\n}\n\n#if !CONFIG_REALTIME_ONLY\n/* 1 = key, 0 = inter */\nstatic int decide_key_frame(VP8_COMP *cpi) {\n  VP8_COMMON *cm = &cpi->common;\n\n  int code_key_frame = 0;\n\n  cpi->kf_boost = 0;\n\n  if (cpi->Speed > 11) return 0;\n\n  /* Clear down mmx registers */\n  vpx_clear_system_state();\n\n  if ((cpi->compressor_speed == 2) && (cpi->Speed >= 5) && (cpi->sf.RD == 0)) {\n    double change = 1.0 *\n                    abs((int)(cpi->mb.intra_error - cpi->last_intra_error)) /\n                    (1 + cpi->last_intra_error);\n    double change2 =\n        1.0 *\n        abs((int)(cpi->mb.prediction_error - cpi->last_prediction_error)) /\n        (1 + cpi->last_prediction_error);\n    double minerror = cm->MBs * 256;\n\n    cpi->last_intra_error = cpi->mb.intra_error;\n    cpi->last_prediction_error = cpi->mb.prediction_error;\n\n    if (10 * cpi->mb.intra_error / (1 + cpi->mb.prediction_error) < 15 &&\n        cpi->mb.prediction_error > minerror &&\n        (change > .25 || change2 > .25)) {\n      /*(change > 1.4 || change < .75)&& cpi->this_frame_percent_intra >\n       * cpi->last_frame_percent_intra + 3*/\n      return 1;\n    }\n\n    return 0;\n  }\n\n  /* If the following are true we might as well code a key frame */\n  if (((cpi->this_frame_percent_intra == 100) &&\n       (cpi->this_frame_percent_intra > (cpi->last_frame_percent_intra + 2))) ||\n      ((cpi->this_frame_percent_intra > 95) &&\n       (cpi->this_frame_percent_intra >=\n        (cpi->last_frame_percent_intra + 5)))) {\n    code_key_frame = 1;\n  }\n  /* in addition if the following are true and this is not a golden frame\n   * then code a key frame Note that on golden frames there often seems\n   * to be a pop in intra usage anyway hence this restriction is\n   * designed to prevent spurious key frames. The Intra pop needs to be\n   * investigated.\n   */\n  else if (((cpi->this_frame_percent_intra > 60) &&\n            (cpi->this_frame_percent_intra >\n             (cpi->last_frame_percent_intra * 2))) ||\n           ((cpi->this_frame_percent_intra > 75) &&\n            (cpi->this_frame_percent_intra >\n             (cpi->last_frame_percent_intra * 3 / 2))) ||\n           ((cpi->this_frame_percent_intra > 90) &&\n            (cpi->this_frame_percent_intra >\n             (cpi->last_frame_percent_intra + 10)))) {\n    if (!cm->refresh_golden_frame) code_key_frame = 1;\n  }\n\n  return code_key_frame;\n}\n\nstatic void Pass1Encode(VP8_COMP *cpi) {\n  vp8_set_quantizer(cpi, 26);\n  vp8_first_pass(cpi);\n}\n#endif\n\n#if 0\nvoid write_cx_frame_to_file(YV12_BUFFER_CONFIG *frame, int this_frame)\n{\n\n    /* write the frame */\n    FILE *yframe;\n    int i;\n    char filename[255];\n\n    sprintf(filename, \"cx\\\\y%04d.raw\", this_frame);\n    yframe = fopen(filename, \"wb\");\n\n    for (i = 0; i < frame->y_height; ++i)\n        fwrite(frame->y_buffer + i * frame->y_stride, frame->y_width, 1, yframe);\n\n    fclose(yframe);\n    sprintf(filename, \"cx\\\\u%04d.raw\", this_frame);\n    yframe = fopen(filename, \"wb\");\n\n    for (i = 0; i < frame->uv_height; ++i)\n        fwrite(frame->u_buffer + i * frame->uv_stride, frame->uv_width, 1, yframe);\n\n    fclose(yframe);\n    sprintf(filename, \"cx\\\\v%04d.raw\", this_frame);\n    yframe = fopen(filename, \"wb\");\n\n    for (i = 0; i < frame->uv_height; ++i)\n        fwrite(frame->v_buffer + i * frame->uv_stride, frame->uv_width, 1, yframe);\n\n    fclose(yframe);\n}\n#endif\n\n#if !CONFIG_REALTIME_ONLY\n/* Function to test for conditions that indeicate we should loop\n * back and recode a frame.\n */\nstatic int recode_loop_test(VP8_COMP *cpi, int high_limit, int low_limit, int q,\n                            int maxq, int minq) {\n  int force_recode = 0;\n  VP8_COMMON *cm = &cpi->common;\n\n  /* Is frame recode allowed at all\n   * Yes if either recode mode 1 is selected or mode two is selcted\n   * and the frame is a key frame. golden frame or alt_ref_frame\n   */\n  if ((cpi->sf.recode_loop == 1) ||\n      ((cpi->sf.recode_loop == 2) &&\n       ((cm->frame_type == KEY_FRAME) || cm->refresh_golden_frame ||\n        cm->refresh_alt_ref_frame))) {\n    /* General over and under shoot tests */\n    if (((cpi->projected_frame_size > high_limit) && (q < maxq)) ||\n        ((cpi->projected_frame_size < low_limit) && (q > minq))) {\n      force_recode = 1;\n    }\n    /* Special Constrained quality tests */\n    else if (cpi->oxcf.end_usage == USAGE_CONSTRAINED_QUALITY) {\n      /* Undershoot and below auto cq level */\n      if ((q > cpi->cq_target_quality) &&\n          (cpi->projected_frame_size < ((cpi->this_frame_target * 7) >> 3))) {\n        force_recode = 1;\n      }\n      /* Severe undershoot and between auto and user cq level */\n      else if ((q > cpi->oxcf.cq_level) &&\n               (cpi->projected_frame_size < cpi->min_frame_bandwidth) &&\n               (cpi->active_best_quality > cpi->oxcf.cq_level)) {\n        force_recode = 1;\n        cpi->active_best_quality = cpi->oxcf.cq_level;\n      }\n    }\n  }\n\n  return force_recode;\n}\n#endif  // !CONFIG_REALTIME_ONLY\n\nstatic void update_reference_frames(VP8_COMP *cpi) {\n  VP8_COMMON *cm = &cpi->common;\n  YV12_BUFFER_CONFIG *yv12_fb = cm->yv12_fb;\n\n  /* At this point the new frame has been encoded.\n   * If any buffer copy / swapping is signaled it should be done here.\n   */\n\n  if (cm->frame_type == KEY_FRAME) {\n    yv12_fb[cm->new_fb_idx].flags |= VP8_GOLD_FRAME | VP8_ALTR_FRAME;\n\n    yv12_fb[cm->gld_fb_idx].flags &= ~VP8_GOLD_FRAME;\n    yv12_fb[cm->alt_fb_idx].flags &= ~VP8_ALTR_FRAME;\n\n    cm->alt_fb_idx = cm->gld_fb_idx = cm->new_fb_idx;\n\n    cpi->current_ref_frames[GOLDEN_FRAME] = cm->current_video_frame;\n    cpi->current_ref_frames[ALTREF_FRAME] = cm->current_video_frame;\n  } else {\n    if (cm->refresh_alt_ref_frame) {\n      assert(!cm->copy_buffer_to_arf);\n\n      cm->yv12_fb[cm->new_fb_idx].flags |= VP8_ALTR_FRAME;\n      cm->yv12_fb[cm->alt_fb_idx].flags &= ~VP8_ALTR_FRAME;\n      cm->alt_fb_idx = cm->new_fb_idx;\n\n      cpi->current_ref_frames[ALTREF_FRAME] = cm->current_video_frame;\n    } else if (cm->copy_buffer_to_arf) {\n      assert(!(cm->copy_buffer_to_arf & ~0x3));\n\n      if (cm->copy_buffer_to_arf == 1) {\n        if (cm->alt_fb_idx != cm->lst_fb_idx) {\n          yv12_fb[cm->lst_fb_idx].flags |= VP8_ALTR_FRAME;\n          yv12_fb[cm->alt_fb_idx].flags &= ~VP8_ALTR_FRAME;\n          cm->alt_fb_idx = cm->lst_fb_idx;\n\n          cpi->current_ref_frames[ALTREF_FRAME] =\n              cpi->current_ref_frames[LAST_FRAME];\n        }\n      } else {\n        if (cm->alt_fb_idx != cm->gld_fb_idx) {\n          yv12_fb[cm->gld_fb_idx].flags |= VP8_ALTR_FRAME;\n          yv12_fb[cm->alt_fb_idx].flags &= ~VP8_ALTR_FRAME;\n          cm->alt_fb_idx = cm->gld_fb_idx;\n\n          cpi->current_ref_frames[ALTREF_FRAME] =\n              cpi->current_ref_frames[GOLDEN_FRAME];\n        }\n      }\n    }\n\n    if (cm->refresh_golden_frame) {\n      assert(!cm->copy_buffer_to_gf);\n\n      cm->yv12_fb[cm->new_fb_idx].flags |= VP8_GOLD_FRAME;\n      cm->yv12_fb[cm->gld_fb_idx].flags &= ~VP8_GOLD_FRAME;\n      cm->gld_fb_idx = cm->new_fb_idx;\n\n      cpi->current_ref_frames[GOLDEN_FRAME] = cm->current_video_frame;\n    } else if (cm->copy_buffer_to_gf) {\n      assert(!(cm->copy_buffer_to_arf & ~0x3));\n\n      if (cm->copy_buffer_to_gf == 1) {\n        if (cm->gld_fb_idx != cm->lst_fb_idx) {\n          yv12_fb[cm->lst_fb_idx].flags |= VP8_GOLD_FRAME;\n          yv12_fb[cm->gld_fb_idx].flags &= ~VP8_GOLD_FRAME;\n          cm->gld_fb_idx = cm->lst_fb_idx;\n\n          cpi->current_ref_frames[GOLDEN_FRAME] =\n              cpi->current_ref_frames[LAST_FRAME];\n        }\n      } else {\n        if (cm->alt_fb_idx != cm->gld_fb_idx) {\n          yv12_fb[cm->alt_fb_idx].flags |= VP8_GOLD_FRAME;\n          yv12_fb[cm->gld_fb_idx].flags &= ~VP8_GOLD_FRAME;\n          cm->gld_fb_idx = cm->alt_fb_idx;\n\n          cpi->current_ref_frames[GOLDEN_FRAME] =\n              cpi->current_ref_frames[ALTREF_FRAME];\n        }\n      }\n    }\n  }\n\n  if (cm->refresh_last_frame) {\n    cm->yv12_fb[cm->new_fb_idx].flags |= VP8_LAST_FRAME;\n    cm->yv12_fb[cm->lst_fb_idx].flags &= ~VP8_LAST_FRAME;\n    cm->lst_fb_idx = cm->new_fb_idx;\n\n    cpi->current_ref_frames[LAST_FRAME] = cm->current_video_frame;\n  }\n\n#if CONFIG_TEMPORAL_DENOISING\n  if (cpi->oxcf.noise_sensitivity) {\n    /* we shouldn't have to keep multiple copies as we know in advance which\n     * buffer we should start - for now to get something up and running\n     * I've chosen to copy the buffers\n     */\n    if (cm->frame_type == KEY_FRAME) {\n      int i;\n      for (i = LAST_FRAME; i < MAX_REF_FRAMES; ++i)\n        vp8_yv12_copy_frame(cpi->Source, &cpi->denoiser.yv12_running_avg[i]);\n    } else {\n      vp8_yv12_extend_frame_borders(\n          &cpi->denoiser.yv12_running_avg[INTRA_FRAME]);\n\n      if (cm->refresh_alt_ref_frame || cm->copy_buffer_to_arf) {\n        vp8_yv12_copy_frame(&cpi->denoiser.yv12_running_avg[INTRA_FRAME],\n                            &cpi->denoiser.yv12_running_avg[ALTREF_FRAME]);\n      }\n      if (cm->refresh_golden_frame || cm->copy_buffer_to_gf) {\n        vp8_yv12_copy_frame(&cpi->denoiser.yv12_running_avg[INTRA_FRAME],\n                            &cpi->denoiser.yv12_running_avg[GOLDEN_FRAME]);\n      }\n      if (cm->refresh_last_frame) {\n        vp8_yv12_copy_frame(&cpi->denoiser.yv12_running_avg[INTRA_FRAME],\n                            &cpi->denoiser.yv12_running_avg[LAST_FRAME]);\n      }\n    }\n    if (cpi->oxcf.noise_sensitivity == 4)\n      vp8_yv12_copy_frame(cpi->Source, &cpi->denoiser.yv12_last_source);\n  }\n#endif\n}\n\nstatic int measure_square_diff_partial(YV12_BUFFER_CONFIG *source,\n                                       YV12_BUFFER_CONFIG *dest,\n                                       VP8_COMP *cpi) {\n  int i, j;\n  int Total = 0;\n  int num_blocks = 0;\n  int skip = 2;\n  int min_consec_zero_last = 10;\n  int tot_num_blocks = (source->y_height * source->y_width) >> 8;\n  unsigned char *src = source->y_buffer;\n  unsigned char *dst = dest->y_buffer;\n\n  /* Loop through the Y plane, every |skip| blocks along rows and colmumns,\n   * summing the square differences, and only for blocks that have been\n   * zero_last mode at least |x| frames in a row.\n   */\n  for (i = 0; i < source->y_height; i += 16 * skip) {\n    int block_index_row = (i >> 4) * cpi->common.mb_cols;\n    for (j = 0; j < source->y_width; j += 16 * skip) {\n      int index = block_index_row + (j >> 4);\n      if (cpi->consec_zero_last[index] >= min_consec_zero_last) {\n        unsigned int sse;\n        Total += vpx_mse16x16(src + j, source->y_stride, dst + j,\n                              dest->y_stride, &sse);\n        num_blocks++;\n      }\n    }\n    src += 16 * skip * source->y_stride;\n    dst += 16 * skip * dest->y_stride;\n  }\n  // Only return non-zero if we have at least ~1/16 samples for estimate.\n  if (num_blocks > (tot_num_blocks >> 4)) {\n    assert(num_blocks != 0);\n    return (Total / num_blocks);\n  } else {\n    return 0;\n  }\n}\n\n#if CONFIG_TEMPORAL_DENOISING\nstatic void process_denoiser_mode_change(VP8_COMP *cpi) {\n  const VP8_COMMON *const cm = &cpi->common;\n  int i, j;\n  int total = 0;\n  int num_blocks = 0;\n  // Number of blocks skipped along row/column in computing the\n  // nmse (normalized mean square error) of source.\n  int skip = 2;\n  // Only select blocks for computing nmse that have been encoded\n  // as ZERO LAST min_consec_zero_last frames in a row.\n  // Scale with number of temporal layers.\n  int min_consec_zero_last = 12 / cpi->oxcf.number_of_layers;\n  // Decision is tested for changing the denoising mode every\n  // num_mode_change times this function is called. Note that this\n  // function called every 8 frames, so (8 * num_mode_change) is number\n  // of frames where denoising mode change is tested for switch.\n  int num_mode_change = 20;\n  // Framerate factor, to compensate for larger mse at lower framerates.\n  // Use ref_framerate, which is full source framerate for temporal layers.\n  // TODO(marpan): Adjust this factor.\n  int fac_framerate = cpi->ref_framerate < 25.0f ? 80 : 100;\n  int tot_num_blocks = cm->mb_rows * cm->mb_cols;\n  int ystride = cpi->Source->y_stride;\n  unsigned char *src = cpi->Source->y_buffer;\n  unsigned char *dst = cpi->denoiser.yv12_last_source.y_buffer;\n  static const unsigned char const_source[16] = { 128, 128, 128, 128, 128, 128,\n                                                  128, 128, 128, 128, 128, 128,\n                                                  128, 128, 128, 128 };\n  int bandwidth = (int)(cpi->target_bandwidth);\n  // For temporal layers, use full bandwidth (top layer).\n  if (cpi->oxcf.number_of_layers > 1) {\n    LAYER_CONTEXT *lc = &cpi->layer_context[cpi->oxcf.number_of_layers - 1];\n    bandwidth = (int)(lc->target_bandwidth);\n  }\n  // Loop through the Y plane, every skip blocks along rows and columns,\n  // summing the normalized mean square error, only for blocks that have\n  // been encoded as ZEROMV LAST at least min_consec_zero_last least frames in\n  // a row and have small sum difference between current and previous frame.\n  // Normalization here is by the contrast of the current frame block.\n  for (i = 0; i < cm->Height; i += 16 * skip) {\n    int block_index_row = (i >> 4) * cm->mb_cols;\n    for (j = 0; j < cm->Width; j += 16 * skip) {\n      int index = block_index_row + (j >> 4);\n      if (cpi->consec_zero_last[index] >= min_consec_zero_last) {\n        unsigned int sse;\n        const unsigned int var =\n            vpx_variance16x16(src + j, ystride, dst + j, ystride, &sse);\n        // Only consider this block as valid for noise measurement\n        // if the sum_diff average of the current and previous frame\n        // is small (to avoid effects from lighting change).\n        if ((sse - var) < 128) {\n          unsigned int sse2;\n          const unsigned int act =\n              vpx_variance16x16(src + j, ystride, const_source, 0, &sse2);\n          if (act > 0) total += sse / act;\n          num_blocks++;\n        }\n      }\n    }\n    src += 16 * skip * ystride;\n    dst += 16 * skip * ystride;\n  }\n  total = total * fac_framerate / 100;\n\n  // Only consider this frame as valid sample if we have computed nmse over\n  // at least ~1/16 blocks, and Total > 0 (Total == 0 can happen if the\n  // application inputs duplicate frames, or contrast is all zero).\n  if (total > 0 && (num_blocks > (tot_num_blocks >> 4))) {\n    // Update the recursive mean square source_diff.\n    total = (total << 8) / num_blocks;\n    if (cpi->denoiser.nmse_source_diff_count == 0) {\n      // First sample in new interval.\n      cpi->denoiser.nmse_source_diff = total;\n      cpi->denoiser.qp_avg = cm->base_qindex;\n    } else {\n      // For subsequent samples, use average with weight ~1/4 for new sample.\n      cpi->denoiser.nmse_source_diff =\n          (int)((total + 3 * cpi->denoiser.nmse_source_diff) >> 2);\n      cpi->denoiser.qp_avg =\n          (int)((cm->base_qindex + 3 * cpi->denoiser.qp_avg) >> 2);\n    }\n    cpi->denoiser.nmse_source_diff_count++;\n  }\n  // Check for changing the denoiser mode, when we have obtained #samples =\n  // num_mode_change. Condition the change also on the bitrate and QP.\n  if (cpi->denoiser.nmse_source_diff_count == num_mode_change) {\n    // Check for going up: from normal to aggressive mode.\n    if ((cpi->denoiser.denoiser_mode == kDenoiserOnYUV) &&\n        (cpi->denoiser.nmse_source_diff >\n         cpi->denoiser.threshold_aggressive_mode) &&\n        (cpi->denoiser.qp_avg < cpi->denoiser.qp_threshold_up &&\n         bandwidth > cpi->denoiser.bitrate_threshold)) {\n      vp8_denoiser_set_parameters(&cpi->denoiser, kDenoiserOnYUVAggressive);\n    } else {\n      // Check for going down: from aggressive to normal mode.\n      if (((cpi->denoiser.denoiser_mode == kDenoiserOnYUVAggressive) &&\n           (cpi->denoiser.nmse_source_diff <\n            cpi->denoiser.threshold_aggressive_mode)) ||\n          ((cpi->denoiser.denoiser_mode == kDenoiserOnYUVAggressive) &&\n           (cpi->denoiser.qp_avg > cpi->denoiser.qp_threshold_down ||\n            bandwidth < cpi->denoiser.bitrate_threshold))) {\n        vp8_denoiser_set_parameters(&cpi->denoiser, kDenoiserOnYUV);\n      }\n    }\n    // Reset metric and counter for next interval.\n    cpi->denoiser.nmse_source_diff = 0;\n    cpi->denoiser.qp_avg = 0;\n    cpi->denoiser.nmse_source_diff_count = 0;\n  }\n}\n#endif\n\nvoid vp8_loopfilter_frame(VP8_COMP *cpi, VP8_COMMON *cm) {\n  const FRAME_TYPE frame_type = cm->frame_type;\n\n  int update_any_ref_buffers = 1;\n  if (cpi->common.refresh_last_frame == 0 &&\n      cpi->common.refresh_golden_frame == 0 &&\n      cpi->common.refresh_alt_ref_frame == 0) {\n    update_any_ref_buffers = 0;\n  }\n\n  if (cm->no_lpf) {\n    cm->filter_level = 0;\n  } else {\n    struct vpx_usec_timer timer;\n\n    vpx_clear_system_state();\n\n    vpx_usec_timer_start(&timer);\n    if (cpi->sf.auto_filter == 0) {\n#if CONFIG_TEMPORAL_DENOISING\n      if (cpi->oxcf.noise_sensitivity && cm->frame_type != KEY_FRAME) {\n        // Use the denoised buffer for selecting base loop filter level.\n        // Denoised signal for current frame is stored in INTRA_FRAME.\n        // No denoising on key frames.\n        vp8cx_pick_filter_level_fast(\n            &cpi->denoiser.yv12_running_avg[INTRA_FRAME], cpi);\n      } else {\n        vp8cx_pick_filter_level_fast(cpi->Source, cpi);\n      }\n#else\n      vp8cx_pick_filter_level_fast(cpi->Source, cpi);\n#endif\n    } else {\n#if CONFIG_TEMPORAL_DENOISING\n      if (cpi->oxcf.noise_sensitivity && cm->frame_type != KEY_FRAME) {\n        // Use the denoised buffer for selecting base loop filter level.\n        // Denoised signal for current frame is stored in INTRA_FRAME.\n        // No denoising on key frames.\n        vp8cx_pick_filter_level(&cpi->denoiser.yv12_running_avg[INTRA_FRAME],\n                                cpi);\n      } else {\n        vp8cx_pick_filter_level(cpi->Source, cpi);\n      }\n#else\n      vp8cx_pick_filter_level(cpi->Source, cpi);\n#endif\n    }\n\n    if (cm->filter_level > 0) {\n      vp8cx_set_alt_lf_level(cpi, cm->filter_level);\n    }\n\n    vpx_usec_timer_mark(&timer);\n    cpi->time_pick_lpf += vpx_usec_timer_elapsed(&timer);\n  }\n\n#if CONFIG_MULTITHREAD\n  if (vpx_atomic_load_acquire(&cpi->b_multi_threaded)) {\n    sem_post(&cpi->h_event_end_lpf); /* signal that we have set filter_level */\n  }\n#endif\n\n  // No need to apply loop-filter if the encoded frame does not update\n  // any reference buffers.\n  if (cm->filter_level > 0 && update_any_ref_buffers) {\n    vp8_loop_filter_frame(cm, &cpi->mb.e_mbd, frame_type);\n  }\n\n  vp8_yv12_extend_frame_borders(cm->frame_to_show);\n}\n\nstatic void encode_frame_to_data_rate(VP8_COMP *cpi, size_t *size,\n                                      unsigned char *dest,\n                                      unsigned char *dest_end,\n                                      unsigned int *frame_flags) {\n  int Q;\n  int frame_over_shoot_limit;\n  int frame_under_shoot_limit;\n\n  int Loop = 0;\n\n  VP8_COMMON *cm = &cpi->common;\n  int active_worst_qchanged = 0;\n\n#if !CONFIG_REALTIME_ONLY\n  int q_low;\n  int q_high;\n  int zbin_oq_high;\n  int zbin_oq_low = 0;\n  int top_index;\n  int bottom_index;\n  int overshoot_seen = 0;\n  int undershoot_seen = 0;\n#endif\n\n  int drop_mark = (int)(cpi->oxcf.drop_frames_water_mark *\n                        cpi->oxcf.optimal_buffer_level / 100);\n  int drop_mark75 = drop_mark * 2 / 3;\n  int drop_mark50 = drop_mark / 4;\n  int drop_mark25 = drop_mark / 8;\n\n  /* Clear down mmx registers to allow floating point in what follows */\n  vpx_clear_system_state();\n\n  if (cpi->force_next_frame_intra) {\n    cm->frame_type = KEY_FRAME; /* delayed intra frame */\n    cpi->force_next_frame_intra = 0;\n  }\n\n  /* For an alt ref frame in 2 pass we skip the call to the second pass\n   * function that sets the target bandwidth\n   */\n  switch (cpi->pass) {\n#if !CONFIG_REALTIME_ONLY\n    case 2:\n      if (cpi->common.refresh_alt_ref_frame) {\n        /* Per frame bit target for the alt ref frame */\n        cpi->per_frame_bandwidth = cpi->twopass.gf_bits;\n        /* per second target bitrate */\n        cpi->target_bandwidth =\n            (int)(cpi->twopass.gf_bits * cpi->output_framerate);\n      }\n      break;\n#endif  // !CONFIG_REALTIME_ONLY\n    default:\n      cpi->per_frame_bandwidth =\n          (int)round(cpi->target_bandwidth / cpi->output_framerate);\n      break;\n  }\n\n  /* Default turn off buffer to buffer copying */\n  cm->copy_buffer_to_gf = 0;\n  cm->copy_buffer_to_arf = 0;\n\n  /* Clear zbin over-quant value and mode boost values. */\n  cpi->mb.zbin_over_quant = 0;\n  cpi->mb.zbin_mode_boost = 0;\n\n  /* Enable or disable mode based tweaking of the zbin\n   * For 2 Pass Only used where GF/ARF prediction quality\n   * is above a threshold\n   */\n  cpi->mb.zbin_mode_boost_enabled = 1;\n  if (cpi->pass == 2) {\n    if (cpi->gfu_boost <= 400) {\n      cpi->mb.zbin_mode_boost_enabled = 0;\n    }\n  }\n\n  /* Current default encoder behaviour for the altref sign bias */\n  if (cpi->source_alt_ref_active) {\n    cpi->common.ref_frame_sign_bias[ALTREF_FRAME] = 1;\n  } else {\n    cpi->common.ref_frame_sign_bias[ALTREF_FRAME] = 0;\n  }\n\n  /* Check to see if a key frame is signaled\n   * For two pass with auto key frame enabled cm->frame_type may already\n   * be set, but not for one pass.\n   */\n  if ((cm->current_video_frame == 0) || (cm->frame_flags & FRAMEFLAGS_KEY) ||\n      (cpi->oxcf.auto_key &&\n       (cpi->frames_since_key % cpi->key_frame_frequency == 0))) {\n    /* Key frame from VFW/auto-keyframe/first frame */\n    cm->frame_type = KEY_FRAME;\n#if CONFIG_TEMPORAL_DENOISING\n    if (cpi->oxcf.noise_sensitivity == 4) {\n      // For adaptive mode, reset denoiser to normal mode on key frame.\n      vp8_denoiser_set_parameters(&cpi->denoiser, kDenoiserOnYUV);\n    }\n#endif\n  }\n\n#if CONFIG_MULTI_RES_ENCODING\n  if (cpi->oxcf.mr_total_resolutions > 1) {\n    LOWER_RES_FRAME_INFO *low_res_frame_info =\n        (LOWER_RES_FRAME_INFO *)cpi->oxcf.mr_low_res_mode_info;\n\n    if (cpi->oxcf.mr_encoder_id) {\n      // Check if lower resolution is available for motion vector reuse.\n      if (cm->frame_type != KEY_FRAME) {\n        cpi->mr_low_res_mv_avail = 1;\n        cpi->mr_low_res_mv_avail &= !(low_res_frame_info->is_frame_dropped);\n\n        if (cpi->ref_frame_flags & VP8_LAST_FRAME)\n          cpi->mr_low_res_mv_avail &=\n              (cpi->current_ref_frames[LAST_FRAME] ==\n               low_res_frame_info->low_res_ref_frames[LAST_FRAME]);\n\n        if (cpi->ref_frame_flags & VP8_GOLD_FRAME)\n          cpi->mr_low_res_mv_avail &=\n              (cpi->current_ref_frames[GOLDEN_FRAME] ==\n               low_res_frame_info->low_res_ref_frames[GOLDEN_FRAME]);\n\n        // Don't use altref to determine whether low res is available.\n        // TODO (marpan): Should we make this type of condition on a\n        // per-reference frame basis?\n        /*\n        if (cpi->ref_frame_flags & VP8_ALTR_FRAME)\n            cpi->mr_low_res_mv_avail &= (cpi->current_ref_frames[ALTREF_FRAME]\n                     == low_res_frame_info->low_res_ref_frames[ALTREF_FRAME]);\n        */\n      }\n      // Disable motion vector reuse (i.e., disable any usage of the low_res)\n      // if the previous lower stream is skipped/disabled.\n      if (low_res_frame_info->skip_encoding_prev_stream) {\n        cpi->mr_low_res_mv_avail = 0;\n      }\n    }\n    // This stream is not skipped (i.e., it's being encoded), so set this skip\n    // flag to 0. This is needed for the next stream (i.e., which is the next\n    // frame to be encoded).\n    low_res_frame_info->skip_encoding_prev_stream = 0;\n\n    // On a key frame: For the lowest resolution, keep track of the key frame\n    // counter value. For the higher resolutions, reset the current video\n    // frame counter to that of the lowest resolution.\n    // This is done to the handle the case where we may stop/start encoding\n    // higher layer(s). The restart-encoding of higher layer is only signaled\n    // by a key frame for now.\n    // TODO (marpan): Add flag to indicate restart-encoding of higher layer.\n    if (cm->frame_type == KEY_FRAME) {\n      if (cpi->oxcf.mr_encoder_id) {\n        // If the initial starting value of the buffer level is zero (this can\n        // happen because we may have not started encoding this higher stream),\n        // then reset it to non-zero value based on |starting_buffer_level|.\n        if (cpi->common.current_video_frame == 0 && cpi->buffer_level == 0) {\n          unsigned int i;\n          cpi->bits_off_target = cpi->oxcf.starting_buffer_level;\n          cpi->buffer_level = cpi->oxcf.starting_buffer_level;\n          for (i = 0; i < cpi->oxcf.number_of_layers; ++i) {\n            LAYER_CONTEXT *lc = &cpi->layer_context[i];\n            lc->bits_off_target = lc->starting_buffer_level;\n            lc->buffer_level = lc->starting_buffer_level;\n          }\n        }\n        cpi->common.current_video_frame =\n            low_res_frame_info->key_frame_counter_value;\n      } else {\n        low_res_frame_info->key_frame_counter_value =\n            cpi->common.current_video_frame;\n      }\n    }\n  }\n#endif\n\n  // Find the reference frame closest to the current frame.\n  cpi->closest_reference_frame = LAST_FRAME;\n  if (cm->frame_type != KEY_FRAME) {\n    int i;\n    MV_REFERENCE_FRAME closest_ref = INTRA_FRAME;\n    if (cpi->ref_frame_flags & VP8_LAST_FRAME) {\n      closest_ref = LAST_FRAME;\n    } else if (cpi->ref_frame_flags & VP8_GOLD_FRAME) {\n      closest_ref = GOLDEN_FRAME;\n    } else if (cpi->ref_frame_flags & VP8_ALTR_FRAME) {\n      closest_ref = ALTREF_FRAME;\n    }\n    for (i = 1; i <= 3; ++i) {\n      vpx_ref_frame_type_t ref_frame_type =\n          (vpx_ref_frame_type_t)((i == 3) ? 4 : i);\n      if (cpi->ref_frame_flags & ref_frame_type) {\n        if ((cm->current_video_frame - cpi->current_ref_frames[i]) <\n            (cm->current_video_frame - cpi->current_ref_frames[closest_ref])) {\n          closest_ref = i;\n        }\n      }\n    }\n    cpi->closest_reference_frame = closest_ref;\n  }\n\n  /* Set various flags etc to special state if it is a key frame */\n  if (cm->frame_type == KEY_FRAME) {\n    int i;\n\n    // Set the loop filter deltas and segmentation map update\n    setup_features(cpi);\n\n    /* The alternate reference frame cannot be active for a key frame */\n    cpi->source_alt_ref_active = 0;\n\n    /* Reset the RD threshold multipliers to default of * 1 (128) */\n    for (i = 0; i < MAX_MODES; ++i) {\n      cpi->mb.rd_thresh_mult[i] = 128;\n    }\n\n    // Reset the zero_last counter to 0 on key frame.\n    memset(cpi->consec_zero_last, 0, cm->mb_rows * cm->mb_cols);\n    memset(cpi->consec_zero_last_mvbias, 0,\n           (cpi->common.mb_rows * cpi->common.mb_cols));\n  }\n\n#if 0\n    /* Experimental code for lagged compress and one pass\n     * Initialise one_pass GF frames stats\n     * Update stats used for GF selection\n     */\n    {\n        cpi->one_pass_frame_index = cm->current_video_frame % MAX_LAG_BUFFERS;\n\n        cpi->one_pass_frame_stats[cpi->one_pass_frame_index ].frames_so_far = 0;\n        cpi->one_pass_frame_stats[cpi->one_pass_frame_index ].frame_intra_error = 0.0;\n        cpi->one_pass_frame_stats[cpi->one_pass_frame_index ].frame_coded_error = 0.0;\n        cpi->one_pass_frame_stats[cpi->one_pass_frame_index ].frame_pcnt_inter = 0.0;\n        cpi->one_pass_frame_stats[cpi->one_pass_frame_index ].frame_pcnt_motion = 0.0;\n        cpi->one_pass_frame_stats[cpi->one_pass_frame_index ].frame_mvr = 0.0;\n        cpi->one_pass_frame_stats[cpi->one_pass_frame_index ].frame_mvr_abs = 0.0;\n        cpi->one_pass_frame_stats[cpi->one_pass_frame_index ].frame_mvc = 0.0;\n        cpi->one_pass_frame_stats[cpi->one_pass_frame_index ].frame_mvc_abs = 0.0;\n    }\n#endif\n\n  update_rd_ref_frame_probs(cpi);\n\n  if (cpi->drop_frames_allowed) {\n    /* The reset to decimation 0 is only done here for one pass.\n     * Once it is set two pass leaves decimation on till the next kf.\n     */\n    if ((cpi->buffer_level > drop_mark) && (cpi->decimation_factor > 0)) {\n      cpi->decimation_factor--;\n    }\n\n    if (cpi->buffer_level > drop_mark75 && cpi->decimation_factor > 0) {\n      cpi->decimation_factor = 1;\n\n    } else if (cpi->buffer_level < drop_mark25 &&\n               (cpi->decimation_factor == 2 || cpi->decimation_factor == 3)) {\n      cpi->decimation_factor = 3;\n    } else if (cpi->buffer_level < drop_mark50 &&\n               (cpi->decimation_factor == 1 || cpi->decimation_factor == 2)) {\n      cpi->decimation_factor = 2;\n    } else if (cpi->buffer_level < drop_mark75 &&\n               (cpi->decimation_factor == 0 || cpi->decimation_factor == 1)) {\n      cpi->decimation_factor = 1;\n    }\n  }\n\n  /* The following decimates the frame rate according to a regular\n   * pattern (i.e. to 1/2 or 2/3 frame rate) This can be used to help\n   * prevent buffer under-run in CBR mode. Alternatively it might be\n   * desirable in some situations to drop frame rate but throw more bits\n   * at each frame.\n   *\n   * Note that dropping a key frame can be problematic if spatial\n   * resampling is also active\n   */\n  if (cpi->decimation_factor > 0 && cpi->drop_frames_allowed) {\n    switch (cpi->decimation_factor) {\n      case 1:\n        cpi->per_frame_bandwidth = cpi->per_frame_bandwidth * 3 / 2;\n        break;\n      case 2:\n        cpi->per_frame_bandwidth = cpi->per_frame_bandwidth * 5 / 4;\n        break;\n      case 3:\n        cpi->per_frame_bandwidth = cpi->per_frame_bandwidth * 5 / 4;\n        break;\n    }\n\n    /* Note that we should not throw out a key frame (especially when\n     * spatial resampling is enabled).\n     */\n    if (cm->frame_type == KEY_FRAME) {\n      cpi->decimation_count = cpi->decimation_factor;\n    } else if (cpi->decimation_count > 0) {\n      cpi->decimation_count--;\n\n      cpi->bits_off_target += cpi->av_per_frame_bandwidth;\n      if (cpi->bits_off_target > cpi->oxcf.maximum_buffer_size) {\n        cpi->bits_off_target = cpi->oxcf.maximum_buffer_size;\n      }\n\n#if CONFIG_MULTI_RES_ENCODING\n      vp8_store_drop_frame_info(cpi);\n#endif\n\n      cm->current_video_frame++;\n      cpi->frames_since_key++;\n      cpi->ext_refresh_frame_flags_pending = 0;\n      // We advance the temporal pattern for dropped frames.\n      cpi->temporal_pattern_counter++;\n\n#if CONFIG_INTERNAL_STATS\n      cpi->count++;\n#endif\n\n      cpi->buffer_level = cpi->bits_off_target;\n\n      if (cpi->oxcf.number_of_layers > 1) {\n        unsigned int i;\n\n        /* Propagate bits saved by dropping the frame to higher\n         * layers\n         */\n        for (i = cpi->current_layer + 1; i < cpi->oxcf.number_of_layers; ++i) {\n          LAYER_CONTEXT *lc = &cpi->layer_context[i];\n          lc->bits_off_target += (int)(lc->target_bandwidth / lc->framerate);\n          if (lc->bits_off_target > lc->maximum_buffer_size) {\n            lc->bits_off_target = lc->maximum_buffer_size;\n          }\n          lc->buffer_level = lc->bits_off_target;\n        }\n      }\n\n      return;\n    } else {\n      cpi->decimation_count = cpi->decimation_factor;\n    }\n  } else {\n    cpi->decimation_count = 0;\n  }\n\n  /* Decide how big to make the frame */\n  if (!vp8_pick_frame_size(cpi)) {\n/*TODO: 2 drop_frame and return code could be put together. */\n#if CONFIG_MULTI_RES_ENCODING\n    vp8_store_drop_frame_info(cpi);\n#endif\n    cm->current_video_frame++;\n    cpi->frames_since_key++;\n    cpi->ext_refresh_frame_flags_pending = 0;\n    // We advance the temporal pattern for dropped frames.\n    cpi->temporal_pattern_counter++;\n    return;\n  }\n\n  /* Reduce active_worst_allowed_q for CBR if our buffer is getting too full.\n   * This has a knock on effect on active best quality as well.\n   * For CBR if the buffer reaches its maximum level then we can no longer\n   * save up bits for later frames so we might as well use them up\n   * on the current frame.\n   */\n  if ((cpi->oxcf.end_usage == USAGE_STREAM_FROM_SERVER) &&\n      (cpi->buffer_level >= cpi->oxcf.optimal_buffer_level) &&\n      cpi->buffered_mode) {\n    /* Max adjustment is 1/4 */\n    int Adjustment = cpi->active_worst_quality / 4;\n\n    if (Adjustment) {\n      int buff_lvl_step;\n\n      if (cpi->buffer_level < cpi->oxcf.maximum_buffer_size) {\n        buff_lvl_step = (int)((cpi->oxcf.maximum_buffer_size -\n                               cpi->oxcf.optimal_buffer_level) /\n                              Adjustment);\n\n        if (buff_lvl_step) {\n          Adjustment =\n              (int)((cpi->buffer_level - cpi->oxcf.optimal_buffer_level) /\n                    buff_lvl_step);\n        } else {\n          Adjustment = 0;\n        }\n      }\n\n      cpi->active_worst_quality -= Adjustment;\n\n      if (cpi->active_worst_quality < cpi->active_best_quality) {\n        cpi->active_worst_quality = cpi->active_best_quality;\n      }\n    }\n  }\n\n  /* Set an active best quality and if necessary active worst quality\n   * There is some odd behavior for one pass here that needs attention.\n   */\n  if ((cpi->pass == 2) || (cpi->ni_frames > 150)) {\n    vpx_clear_system_state();\n\n    Q = cpi->active_worst_quality;\n\n    if (cm->frame_type == KEY_FRAME) {\n      if (cpi->pass == 2) {\n        if (cpi->gfu_boost > 600) {\n          cpi->active_best_quality = kf_low_motion_minq[Q];\n        } else {\n          cpi->active_best_quality = kf_high_motion_minq[Q];\n        }\n\n        /* Special case for key frames forced because we have reached\n         * the maximum key frame interval. Here force the Q to a range\n         * based on the ambient Q to reduce the risk of popping\n         */\n        if (cpi->this_key_frame_forced) {\n          if (cpi->active_best_quality > cpi->avg_frame_qindex * 7 / 8) {\n            cpi->active_best_quality = cpi->avg_frame_qindex * 7 / 8;\n          } else if (cpi->active_best_quality < (cpi->avg_frame_qindex >> 2)) {\n            cpi->active_best_quality = cpi->avg_frame_qindex >> 2;\n          }\n        }\n      }\n      /* One pass more conservative */\n      else {\n        cpi->active_best_quality = kf_high_motion_minq[Q];\n      }\n    }\n\n    else if (cpi->oxcf.number_of_layers == 1 &&\n             (cm->refresh_golden_frame || cpi->common.refresh_alt_ref_frame)) {\n      /* Use the lower of cpi->active_worst_quality and recent\n       * average Q as basis for GF/ARF Q limit unless last frame was\n       * a key frame.\n       */\n      if ((cpi->frames_since_key > 1) &&\n          (cpi->avg_frame_qindex < cpi->active_worst_quality)) {\n        Q = cpi->avg_frame_qindex;\n      }\n\n      /* For constrained quality don't allow Q less than the cq level */\n      if ((cpi->oxcf.end_usage == USAGE_CONSTRAINED_QUALITY) &&\n          (Q < cpi->cq_target_quality)) {\n        Q = cpi->cq_target_quality;\n      }\n\n      if (cpi->pass == 2) {\n        if (cpi->gfu_boost > 1000) {\n          cpi->active_best_quality = gf_low_motion_minq[Q];\n        } else if (cpi->gfu_boost < 400) {\n          cpi->active_best_quality = gf_high_motion_minq[Q];\n        } else {\n          cpi->active_best_quality = gf_mid_motion_minq[Q];\n        }\n\n        /* Constrained quality use slightly lower active best. */\n        if (cpi->oxcf.end_usage == USAGE_CONSTRAINED_QUALITY) {\n          cpi->active_best_quality = cpi->active_best_quality * 15 / 16;\n        }\n      }\n      /* One pass more conservative */\n      else {\n        cpi->active_best_quality = gf_high_motion_minq[Q];\n      }\n    } else {\n      cpi->active_best_quality = inter_minq[Q];\n\n      /* For the constant/constrained quality mode we don't want\n       * q to fall below the cq level.\n       */\n      if ((cpi->oxcf.end_usage == USAGE_CONSTRAINED_QUALITY) &&\n          (cpi->active_best_quality < cpi->cq_target_quality)) {\n        /* If we are strongly undershooting the target rate in the last\n         * frames then use the user passed in cq value not the auto\n         * cq value.\n         */\n        if (cpi->rolling_actual_bits < cpi->min_frame_bandwidth) {\n          cpi->active_best_quality = cpi->oxcf.cq_level;\n        } else {\n          cpi->active_best_quality = cpi->cq_target_quality;\n        }\n      }\n    }\n\n    /* If CBR and the buffer is as full then it is reasonable to allow\n     * higher quality on the frames to prevent bits just going to waste.\n     */\n    if (cpi->oxcf.end_usage == USAGE_STREAM_FROM_SERVER) {\n      /* Note that the use of >= here elliminates the risk of a divide\n       * by 0 error in the else if clause\n       */\n      if (cpi->buffer_level >= cpi->oxcf.maximum_buffer_size) {\n        cpi->active_best_quality = cpi->best_quality;\n\n      } else if (cpi->buffer_level > cpi->oxcf.optimal_buffer_level) {\n        int Fraction =\n            (int)(((cpi->buffer_level - cpi->oxcf.optimal_buffer_level) * 128) /\n                  (cpi->oxcf.maximum_buffer_size -\n                   cpi->oxcf.optimal_buffer_level));\n        int min_qadjustment =\n            ((cpi->active_best_quality - cpi->best_quality) * Fraction) / 128;\n\n        cpi->active_best_quality -= min_qadjustment;\n      }\n    }\n  }\n  /* Make sure constrained quality mode limits are adhered to for the first\n   * few frames of one pass encodes\n   */\n  else if (cpi->oxcf.end_usage == USAGE_CONSTRAINED_QUALITY) {\n    if ((cm->frame_type == KEY_FRAME) || cm->refresh_golden_frame ||\n        cpi->common.refresh_alt_ref_frame) {\n      cpi->active_best_quality = cpi->best_quality;\n    } else if (cpi->active_best_quality < cpi->cq_target_quality) {\n      cpi->active_best_quality = cpi->cq_target_quality;\n    }\n  }\n\n  /* Clip the active best and worst quality values to limits */\n  if (cpi->active_worst_quality > cpi->worst_quality) {\n    cpi->active_worst_quality = cpi->worst_quality;\n  }\n\n  if (cpi->active_best_quality < cpi->best_quality) {\n    cpi->active_best_quality = cpi->best_quality;\n  }\n\n  if (cpi->active_worst_quality < cpi->active_best_quality) {\n    cpi->active_worst_quality = cpi->active_best_quality;\n  }\n\n  /* Determine initial Q to try */\n  Q = vp8_regulate_q(cpi, cpi->this_frame_target);\n\n#if !CONFIG_REALTIME_ONLY\n\n  /* Set highest allowed value for Zbin over quant */\n  if (cm->frame_type == KEY_FRAME) {\n    zbin_oq_high = 0;\n  } else if ((cpi->oxcf.number_of_layers == 1) &&\n             ((cm->refresh_alt_ref_frame ||\n               (cm->refresh_golden_frame && !cpi->source_alt_ref_active)))) {\n    zbin_oq_high = 16;\n  } else {\n    zbin_oq_high = ZBIN_OQ_MAX;\n  }\n#endif\n\n  compute_skin_map(cpi);\n\n  /* Setup background Q adjustment for error resilient mode.\n   * For multi-layer encodes only enable this for the base layer.\n   */\n  if (cpi->cyclic_refresh_mode_enabled) {\n    // Special case for screen_content_mode with golden frame updates.\n    int disable_cr_gf =\n        (cpi->oxcf.screen_content_mode == 2 && cm->refresh_golden_frame);\n    if (cpi->current_layer == 0 && cpi->force_maxqp == 0 && !disable_cr_gf) {\n      cyclic_background_refresh(cpi, Q, 0);\n    } else {\n      disable_segmentation(cpi);\n    }\n  }\n\n  vp8_compute_frame_size_bounds(cpi, &frame_under_shoot_limit,\n                                &frame_over_shoot_limit);\n\n#if !CONFIG_REALTIME_ONLY\n  /* Limit Q range for the adaptive loop. */\n  bottom_index = cpi->active_best_quality;\n  top_index = cpi->active_worst_quality;\n  q_low = cpi->active_best_quality;\n  q_high = cpi->active_worst_quality;\n#endif\n\n  vp8_save_coding_context(cpi);\n\n  scale_and_extend_source(cpi->un_scaled_source, cpi);\n\n#if CONFIG_TEMPORAL_DENOISING && CONFIG_POSTPROC\n  // Option to apply spatial blur under the aggressive or adaptive\n  // (temporal denoising) mode.\n  if (cpi->oxcf.noise_sensitivity >= 3) {\n    if (cpi->denoiser.denoise_pars.spatial_blur != 0) {\n      vp8_de_noise(cm, cpi->Source, cpi->denoiser.denoise_pars.spatial_blur, 1);\n    }\n  }\n#endif\n\n#if !(CONFIG_REALTIME_ONLY) && CONFIG_POSTPROC && !(CONFIG_TEMPORAL_DENOISING)\n\n  if (cpi->oxcf.noise_sensitivity > 0) {\n    unsigned char *src;\n    int l = 0;\n\n    switch (cpi->oxcf.noise_sensitivity) {\n      case 1: l = 20; break;\n      case 2: l = 40; break;\n      case 3: l = 60; break;\n      case 4: l = 80; break;\n      case 5: l = 100; break;\n      case 6: l = 150; break;\n    }\n\n    if (cm->frame_type == KEY_FRAME) {\n      vp8_de_noise(cm, cpi->Source, l, 1);\n    } else {\n      vp8_de_noise(cm, cpi->Source, l, 1);\n\n      src = cpi->Source->y_buffer;\n\n      if (cpi->Source->y_stride < 0) {\n        src += cpi->Source->y_stride * (cpi->Source->y_height - 1);\n      }\n    }\n  }\n\n#endif\n\n#ifdef OUTPUT_YUV_SRC\n  vpx_write_yuv_frame(yuv_file, cpi->Source);\n#endif\n\n  do {\n    vpx_clear_system_state();\n\n    vp8_set_quantizer(cpi, Q);\n\n    /* setup skip prob for costing in mode/mv decision */\n    if (cpi->common.mb_no_coeff_skip) {\n      cpi->prob_skip_false = cpi->base_skip_false_prob[Q];\n\n      if (cm->frame_type != KEY_FRAME) {\n        if (cpi->common.refresh_alt_ref_frame) {\n          if (cpi->last_skip_false_probs[2] != 0) {\n            cpi->prob_skip_false = cpi->last_skip_false_probs[2];\n          }\n\n          /*\n                              if(cpi->last_skip_false_probs[2]!=0 && abs(Q-\n             cpi->last_skip_probs_q[2])<=16 )\n             cpi->prob_skip_false = cpi->last_skip_false_probs[2];\n                              else if (cpi->last_skip_false_probs[2]!=0)\n             cpi->prob_skip_false = (cpi->last_skip_false_probs[2]  +\n             cpi->prob_skip_false ) / 2;\n             */\n        } else if (cpi->common.refresh_golden_frame) {\n          if (cpi->last_skip_false_probs[1] != 0) {\n            cpi->prob_skip_false = cpi->last_skip_false_probs[1];\n          }\n\n          /*\n                              if(cpi->last_skip_false_probs[1]!=0 && abs(Q-\n             cpi->last_skip_probs_q[1])<=16 )\n             cpi->prob_skip_false = cpi->last_skip_false_probs[1];\n                              else if (cpi->last_skip_false_probs[1]!=0)\n             cpi->prob_skip_false = (cpi->last_skip_false_probs[1]  +\n             cpi->prob_skip_false ) / 2;\n             */\n        } else {\n          if (cpi->last_skip_false_probs[0] != 0) {\n            cpi->prob_skip_false = cpi->last_skip_false_probs[0];\n          }\n\n          /*\n          if(cpi->last_skip_false_probs[0]!=0 && abs(Q-\n          cpi->last_skip_probs_q[0])<=16 )\n              cpi->prob_skip_false = cpi->last_skip_false_probs[0];\n          else if(cpi->last_skip_false_probs[0]!=0)\n              cpi->prob_skip_false = (cpi->last_skip_false_probs[0]  +\n          cpi->prob_skip_false ) / 2;\n              */\n        }\n\n        /* as this is for cost estimate, let's make sure it does not\n         * go extreme eitehr way\n         */\n        if (cpi->prob_skip_false < 5) cpi->prob_skip_false = 5;\n\n        if (cpi->prob_skip_false > 250) cpi->prob_skip_false = 250;\n\n        if (cpi->oxcf.number_of_layers == 1 && cpi->is_src_frame_alt_ref) {\n          cpi->prob_skip_false = 1;\n        }\n      }\n\n#if 0\n\n            if (cpi->pass != 1)\n            {\n                FILE *f = fopen(\"skip.stt\", \"a\");\n                fprintf(f, \"%d, %d, %4d \", cpi->common.refresh_golden_frame, cpi->common.refresh_alt_ref_frame, cpi->prob_skip_false);\n                fclose(f);\n            }\n\n#endif\n    }\n\n    if (cm->frame_type == KEY_FRAME) {\n      if (resize_key_frame(cpi)) {\n        /* If the frame size has changed, need to reset Q, quantizer,\n         * and background refresh.\n         */\n        Q = vp8_regulate_q(cpi, cpi->this_frame_target);\n        if (cpi->cyclic_refresh_mode_enabled) {\n          if (cpi->current_layer == 0) {\n            cyclic_background_refresh(cpi, Q, 0);\n          } else {\n            disable_segmentation(cpi);\n          }\n        }\n        // Reset the zero_last counter to 0 on key frame.\n        memset(cpi->consec_zero_last, 0, cm->mb_rows * cm->mb_cols);\n        memset(cpi->consec_zero_last_mvbias, 0,\n               (cpi->common.mb_rows * cpi->common.mb_cols));\n        vp8_set_quantizer(cpi, Q);\n      }\n\n      vp8_setup_key_frame(cpi);\n    }\n\n#if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING\n    {\n      if (cpi->oxcf.error_resilient_mode) cm->refresh_entropy_probs = 0;\n\n      if (cpi->oxcf.error_resilient_mode & VPX_ERROR_RESILIENT_PARTITIONS) {\n        if (cm->frame_type == KEY_FRAME) cm->refresh_entropy_probs = 1;\n      }\n\n      if (cm->refresh_entropy_probs == 0) {\n        /* save a copy for later refresh */\n        memcpy(&cm->lfc, &cm->fc, sizeof(cm->fc));\n      }\n\n      vp8_update_coef_context(cpi);\n\n      vp8_update_coef_probs(cpi);\n\n      /* transform / motion compensation build reconstruction frame\n       * +pack coef partitions\n       */\n      vp8_encode_frame(cpi);\n\n      /* cpi->projected_frame_size is not needed for RT mode */\n    }\n#else\n    /* transform / motion compensation build reconstruction frame */\n    vp8_encode_frame(cpi);\n\n    if (cpi->pass == 0 && cpi->oxcf.end_usage == USAGE_STREAM_FROM_SERVER) {\n      if (vp8_drop_encodedframe_overshoot(cpi, Q)) {\n        vpx_clear_system_state();\n        return;\n      }\n      if (cm->frame_type != KEY_FRAME)\n        cpi->last_pred_err_mb =\n            (int)(cpi->mb.prediction_error / cpi->common.MBs);\n    }\n\n    cpi->projected_frame_size -= vp8_estimate_entropy_savings(cpi);\n    cpi->projected_frame_size =\n        (cpi->projected_frame_size > 0) ? cpi->projected_frame_size : 0;\n#endif\n    vpx_clear_system_state();\n\n    /* Test to see if the stats generated for this frame indicate that\n     * we should have coded a key frame (assuming that we didn't)!\n     */\n\n    if (cpi->pass != 2 && cpi->oxcf.auto_key && cm->frame_type != KEY_FRAME &&\n        cpi->compressor_speed != 2) {\n#if !CONFIG_REALTIME_ONLY\n      if (decide_key_frame(cpi)) {\n        /* Reset all our sizing numbers and recode */\n        cm->frame_type = KEY_FRAME;\n\n        vp8_pick_frame_size(cpi);\n\n        /* Clear the Alt reference frame active flag when we have\n         * a key frame\n         */\n        cpi->source_alt_ref_active = 0;\n\n        // Set the loop filter deltas and segmentation map update\n        setup_features(cpi);\n\n        vp8_restore_coding_context(cpi);\n\n        Q = vp8_regulate_q(cpi, cpi->this_frame_target);\n\n        vp8_compute_frame_size_bounds(cpi, &frame_under_shoot_limit,\n                                      &frame_over_shoot_limit);\n\n        /* Limit Q range for the adaptive loop. */\n        bottom_index = cpi->active_best_quality;\n        top_index = cpi->active_worst_quality;\n        q_low = cpi->active_best_quality;\n        q_high = cpi->active_worst_quality;\n\n        Loop = 1;\n\n        continue;\n      }\n#endif\n    }\n\n    vpx_clear_system_state();\n\n    if (frame_over_shoot_limit == 0) frame_over_shoot_limit = 1;\n\n    /* Are we are overshooting and up against the limit of active max Q. */\n    if (!cpi->rt_always_update_correction_factor &&\n        ((cpi->pass != 2) ||\n         (cpi->oxcf.end_usage == USAGE_STREAM_FROM_SERVER)) &&\n        (Q == cpi->active_worst_quality) &&\n        (cpi->active_worst_quality < cpi->worst_quality) &&\n        (cpi->projected_frame_size > frame_over_shoot_limit)) {\n      int over_size_percent =\n          ((cpi->projected_frame_size - frame_over_shoot_limit) * 100) /\n          frame_over_shoot_limit;\n\n      /* If so is there any scope for relaxing it */\n      while ((cpi->active_worst_quality < cpi->worst_quality) &&\n             (over_size_percent > 0)) {\n        cpi->active_worst_quality++;\n        /* Assume 1 qstep = about 4% on frame size. */\n        over_size_percent = (int)(over_size_percent * 0.96);\n      }\n#if !CONFIG_REALTIME_ONLY\n      top_index = cpi->active_worst_quality;\n#endif  // !CONFIG_REALTIME_ONLY\n      /* If we have updated the active max Q do not call\n       * vp8_update_rate_correction_factors() this loop.\n       */\n      active_worst_qchanged = 1;\n    } else {\n      active_worst_qchanged = 0;\n    }\n\n#if CONFIG_REALTIME_ONLY\n    Loop = 0;\n#else\n    /* Special case handling for forced key frames */\n    if ((cm->frame_type == KEY_FRAME) && cpi->this_key_frame_forced) {\n      int last_q = Q;\n      int kf_err = vp8_calc_ss_err(cpi->Source, &cm->yv12_fb[cm->new_fb_idx]);\n\n      /* The key frame is not good enough */\n      if (kf_err > ((cpi->ambient_err * 7) >> 3)) {\n        /* Lower q_high */\n        q_high = (Q > q_low) ? (Q - 1) : q_low;\n\n        /* Adjust Q */\n        Q = (q_high + q_low) >> 1;\n      }\n      /* The key frame is much better than the previous frame */\n      else if (kf_err < (cpi->ambient_err >> 1)) {\n        /* Raise q_low */\n        q_low = (Q < q_high) ? (Q + 1) : q_high;\n\n        /* Adjust Q */\n        Q = (q_high + q_low + 1) >> 1;\n      }\n\n      /* Clamp Q to upper and lower limits: */\n      if (Q > q_high) {\n        Q = q_high;\n      } else if (Q < q_low) {\n        Q = q_low;\n      }\n\n      Loop = Q != last_q;\n    }\n\n    /* Is the projected frame size out of range and are we allowed\n     * to attempt to recode.\n     */\n    else if (recode_loop_test(cpi, frame_over_shoot_limit,\n                              frame_under_shoot_limit, Q, top_index,\n                              bottom_index)) {\n      int last_q = Q;\n      int Retries = 0;\n\n      /* Frame size out of permitted range. Update correction factor\n       * & compute new Q to try...\n       */\n\n      /* Frame is too large */\n      if (cpi->projected_frame_size > cpi->this_frame_target) {\n        /* Raise Qlow as to at least the current value */\n        q_low = (Q < q_high) ? (Q + 1) : q_high;\n\n        /* If we are using over quant do the same for zbin_oq_low */\n        if (cpi->mb.zbin_over_quant > 0) {\n          zbin_oq_low = (cpi->mb.zbin_over_quant < zbin_oq_high)\n                            ? (cpi->mb.zbin_over_quant + 1)\n                            : zbin_oq_high;\n        }\n\n        if (undershoot_seen) {\n          /* Update rate_correction_factor unless\n           * cpi->active_worst_quality has changed.\n           */\n          if (!active_worst_qchanged) {\n            vp8_update_rate_correction_factors(cpi, 1);\n          }\n\n          Q = (q_high + q_low + 1) / 2;\n\n          /* Adjust cpi->zbin_over_quant (only allowed when Q\n           * is max)\n           */\n          if (Q < MAXQ) {\n            cpi->mb.zbin_over_quant = 0;\n          } else {\n            zbin_oq_low = (cpi->mb.zbin_over_quant < zbin_oq_high)\n                              ? (cpi->mb.zbin_over_quant + 1)\n                              : zbin_oq_high;\n            cpi->mb.zbin_over_quant = (zbin_oq_high + zbin_oq_low) / 2;\n          }\n        } else {\n          /* Update rate_correction_factor unless\n           * cpi->active_worst_quality has changed.\n           */\n          if (!active_worst_qchanged) {\n            vp8_update_rate_correction_factors(cpi, 0);\n          }\n\n          Q = vp8_regulate_q(cpi, cpi->this_frame_target);\n\n          while (((Q < q_low) || (cpi->mb.zbin_over_quant < zbin_oq_low)) &&\n                 (Retries < 10)) {\n            vp8_update_rate_correction_factors(cpi, 0);\n            Q = vp8_regulate_q(cpi, cpi->this_frame_target);\n            Retries++;\n          }\n        }\n\n        overshoot_seen = 1;\n      }\n      /* Frame is too small */\n      else {\n        if (cpi->mb.zbin_over_quant == 0) {\n          /* Lower q_high if not using over quant */\n          q_high = (Q > q_low) ? (Q - 1) : q_low;\n        } else {\n          /* else lower zbin_oq_high */\n          zbin_oq_high = (cpi->mb.zbin_over_quant > zbin_oq_low)\n                             ? (cpi->mb.zbin_over_quant - 1)\n                             : zbin_oq_low;\n        }\n\n        if (overshoot_seen) {\n          /* Update rate_correction_factor unless\n           * cpi->active_worst_quality has changed.\n           */\n          if (!active_worst_qchanged) {\n            vp8_update_rate_correction_factors(cpi, 1);\n          }\n\n          Q = (q_high + q_low) / 2;\n\n          /* Adjust cpi->zbin_over_quant (only allowed when Q\n           * is max)\n           */\n          if (Q < MAXQ) {\n            cpi->mb.zbin_over_quant = 0;\n          } else {\n            cpi->mb.zbin_over_quant = (zbin_oq_high + zbin_oq_low) / 2;\n          }\n        } else {\n          /* Update rate_correction_factor unless\n           * cpi->active_worst_quality has changed.\n           */\n          if (!active_worst_qchanged) {\n            vp8_update_rate_correction_factors(cpi, 0);\n          }\n\n          Q = vp8_regulate_q(cpi, cpi->this_frame_target);\n\n          /* Special case reset for qlow for constrained quality.\n           * This should only trigger where there is very substantial\n           * undershoot on a frame and the auto cq level is above\n           * the user passsed in value.\n           */\n          if ((cpi->oxcf.end_usage == USAGE_CONSTRAINED_QUALITY) &&\n              (Q < q_low)) {\n            q_low = Q;\n          }\n\n          while (((Q > q_high) || (cpi->mb.zbin_over_quant > zbin_oq_high)) &&\n                 (Retries < 10)) {\n            vp8_update_rate_correction_factors(cpi, 0);\n            Q = vp8_regulate_q(cpi, cpi->this_frame_target);\n            Retries++;\n          }\n        }\n\n        undershoot_seen = 1;\n      }\n\n      /* Clamp Q to upper and lower limits: */\n      if (Q > q_high) {\n        Q = q_high;\n      } else if (Q < q_low) {\n        Q = q_low;\n      }\n\n      /* Clamp cpi->zbin_over_quant */\n      cpi->mb.zbin_over_quant =\n          (cpi->mb.zbin_over_quant < zbin_oq_low)    ? zbin_oq_low\n          : (cpi->mb.zbin_over_quant > zbin_oq_high) ? zbin_oq_high\n                                                     : cpi->mb.zbin_over_quant;\n\n      Loop = Q != last_q;\n    } else {\n      Loop = 0;\n    }\n#endif  // CONFIG_REALTIME_ONLY\n\n    if (cpi->is_src_frame_alt_ref) Loop = 0;\n\n    if (Loop == 1) {\n      vp8_restore_coding_context(cpi);\n#if CONFIG_INTERNAL_STATS\n      cpi->tot_recode_hits++;\n#endif\n    }\n  } while (Loop == 1);\n\n#if defined(DROP_UNCODED_FRAMES)\n  /* if there are no coded macroblocks at all drop this frame */\n  if (cpi->common.MBs == cpi->mb.skip_true_count &&\n      (cpi->drop_frame_count & 7) != 7 && cm->frame_type != KEY_FRAME) {\n    cpi->common.current_video_frame++;\n    cpi->frames_since_key++;\n    cpi->drop_frame_count++;\n    cpi->ext_refresh_frame_flags_pending = 0;\n    // We advance the temporal pattern for dropped frames.\n    cpi->temporal_pattern_counter++;\n    return;\n  }\n  cpi->drop_frame_count = 0;\n#endif\n\n#if 0\n    /* Experimental code for lagged and one pass\n     * Update stats used for one pass GF selection\n     */\n    {\n        cpi->one_pass_frame_stats[cpi->one_pass_frame_index].frame_coded_error = (double)cpi->prediction_error;\n        cpi->one_pass_frame_stats[cpi->one_pass_frame_index].frame_intra_error = (double)cpi->intra_error;\n        cpi->one_pass_frame_stats[cpi->one_pass_frame_index].frame_pcnt_inter = (double)(100 - cpi->this_frame_percent_intra) / 100.0;\n    }\n#endif\n\n  /* Special case code to reduce pulsing when key frames are forced at a\n   * fixed interval. Note the reconstruction error if it is the frame before\n   * the force key frame\n   */\n  if (cpi->next_key_frame_forced && (cpi->twopass.frames_to_key == 0)) {\n    cpi->ambient_err =\n        vp8_calc_ss_err(cpi->Source, &cm->yv12_fb[cm->new_fb_idx]);\n  }\n\n/* This frame's MVs are saved and will be used in next frame's MV predictor.\n * Last frame has one more line(add to bottom) and one more column(add to\n * right) than cm->mip. The edge elements are initialized to 0.\n */\n#if CONFIG_MULTI_RES_ENCODING\n  if (!cpi->oxcf.mr_encoder_id && cm->show_frame)\n#else\n  if (cm->show_frame) /* do not save for altref frame */\n#endif\n  {\n    int mb_row;\n    int mb_col;\n    /* Point to beginning of allocated MODE_INFO arrays. */\n    MODE_INFO *tmp = cm->mip;\n\n    if (cm->frame_type != KEY_FRAME) {\n      for (mb_row = 0; mb_row < cm->mb_rows + 1; ++mb_row) {\n        for (mb_col = 0; mb_col < cm->mb_cols + 1; ++mb_col) {\n          if (tmp->mbmi.ref_frame != INTRA_FRAME) {\n            cpi->lfmv[mb_col + mb_row * (cm->mode_info_stride + 1)].as_int =\n                tmp->mbmi.mv.as_int;\n          }\n\n          cpi->lf_ref_frame_sign_bias[mb_col +\n                                      mb_row * (cm->mode_info_stride + 1)] =\n              cm->ref_frame_sign_bias[tmp->mbmi.ref_frame];\n          cpi->lf_ref_frame[mb_col + mb_row * (cm->mode_info_stride + 1)] =\n              tmp->mbmi.ref_frame;\n          tmp++;\n        }\n      }\n    }\n  }\n\n  /* Count last ref frame 0,0 usage on current encoded frame. */\n  {\n    int mb_row;\n    int mb_col;\n    /* Point to beginning of MODE_INFO arrays. */\n    MODE_INFO *tmp = cm->mi;\n\n    cpi->zeromv_count = 0;\n\n    if (cm->frame_type != KEY_FRAME) {\n      for (mb_row = 0; mb_row < cm->mb_rows; ++mb_row) {\n        for (mb_col = 0; mb_col < cm->mb_cols; ++mb_col) {\n          if (tmp->mbmi.mode == ZEROMV && tmp->mbmi.ref_frame == LAST_FRAME) {\n            cpi->zeromv_count++;\n          }\n          tmp++;\n        }\n        tmp++;\n      }\n    }\n  }\n\n#if CONFIG_MULTI_RES_ENCODING\n  vp8_cal_dissimilarity(cpi);\n#endif\n\n  /* Update the GF usage maps.\n   * This is done after completing the compression of a frame when all\n   * modes etc. are finalized but before loop filter\n   */\n  if (cpi->oxcf.number_of_layers == 1) {\n    vp8_update_gf_usage_maps(cpi, cm, &cpi->mb);\n  }\n\n  if (cm->frame_type == KEY_FRAME) cm->refresh_last_frame = 1;\n\n#if 0\n    {\n        FILE *f = fopen(\"gfactive.stt\", \"a\");\n        fprintf(f, \"%8d %8d %8d %8d %8d\\n\", cm->current_video_frame, (100 * cpi->gf_active_count) / (cpi->common.mb_rows * cpi->common.mb_cols), cpi->this_iiratio, cpi->next_iiratio, cm->refresh_golden_frame);\n        fclose(f);\n    }\n#endif\n\n  /* For inter frames the current default behavior is that when\n   * cm->refresh_golden_frame is set we copy the old GF over to the ARF buffer\n   * This is purely an encoder decision at present.\n   * Avoid this behavior when refresh flags are set by the user.\n   */\n  if (!cpi->oxcf.error_resilient_mode && cm->refresh_golden_frame &&\n      !cpi->ext_refresh_frame_flags_pending) {\n    cm->copy_buffer_to_arf = 2;\n  } else {\n    cm->copy_buffer_to_arf = 0;\n  }\n\n  cm->frame_to_show = &cm->yv12_fb[cm->new_fb_idx];\n\n#if CONFIG_TEMPORAL_DENOISING\n  // Get some measure of the amount of noise, by measuring the (partial) mse\n  // between source and denoised buffer, for y channel. Partial refers to\n  // computing the sse for a sub-sample of the frame (i.e., skip x blocks along\n  // row/column),\n  // and only for blocks in that set that are consecutive ZEROMV_LAST mode.\n  // Do this every ~8 frames, to further reduce complexity.\n  // TODO(marpan): Keep this for now for the case cpi->oxcf.noise_sensitivity <\n  // 4,\n  // should be removed in favor of the process_denoiser_mode_change() function\n  // below.\n  if (cpi->oxcf.noise_sensitivity > 0 && cpi->oxcf.noise_sensitivity < 4 &&\n      !cpi->oxcf.screen_content_mode && cpi->frames_since_key % 8 == 0 &&\n      cm->frame_type != KEY_FRAME) {\n    cpi->mse_source_denoised = measure_square_diff_partial(\n        &cpi->denoiser.yv12_running_avg[INTRA_FRAME], cpi->Source, cpi);\n  }\n\n  // For the adaptive denoising mode (noise_sensitivity == 4), sample the mse\n  // of source diff (between current and previous frame), and determine if we\n  // should switch the denoiser mode. Sampling refers to computing the mse for\n  // a sub-sample of the frame (i.e., skip x blocks along row/column), and\n  // only for blocks in that set that have used ZEROMV LAST, along with some\n  // constraint on the sum diff between blocks. This process is called every\n  // ~8 frames, to further reduce complexity.\n  if (cpi->oxcf.noise_sensitivity == 4 && !cpi->oxcf.screen_content_mode &&\n      cpi->frames_since_key % 8 == 0 && cm->frame_type != KEY_FRAME) {\n    process_denoiser_mode_change(cpi);\n  }\n#endif\n\n#ifdef OUTPUT_YUV_SKINMAP\n  if (cpi->common.current_video_frame > 1) {\n    vp8_compute_skin_map(cpi, yuv_skinmap_file);\n  }\n#endif\n\n#if CONFIG_MULTITHREAD\n  if (vpx_atomic_load_acquire(&cpi->b_multi_threaded)) {\n    /* start loopfilter in separate thread */\n    sem_post(&cpi->h_event_start_lpf);\n    cpi->b_lpf_running = 1;\n    /* wait for the filter_level to be picked so that we can continue with\n     * stream packing */\n    sem_wait(&cpi->h_event_end_lpf);\n  } else\n#endif\n  {\n    vp8_loopfilter_frame(cpi, cm);\n  }\n\n  update_reference_frames(cpi);\n\n#ifdef OUTPUT_YUV_DENOISED\n  vpx_write_yuv_frame(yuv_denoised_file,\n                      &cpi->denoiser.yv12_running_avg[INTRA_FRAME]);\n#endif\n\n#if !(CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING)\n  if (cpi->oxcf.error_resilient_mode) {\n    cm->refresh_entropy_probs = 0;\n  }\n#endif\n\n  /* build the bitstream */\n  vp8_pack_bitstream(cpi, dest, dest_end, size);\n\n  /* Move storing frame_type out of the above loop since it is also\n   * needed in motion search besides loopfilter */\n  cm->last_frame_type = cm->frame_type;\n\n  /* Update rate control heuristics */\n  cpi->total_byte_count += (*size);\n  cpi->projected_frame_size = (int)(*size) << 3;\n\n  if (cpi->oxcf.number_of_layers > 1) {\n    unsigned int i;\n    for (i = cpi->current_layer + 1; i < cpi->oxcf.number_of_layers; ++i) {\n      cpi->layer_context[i].total_byte_count += (*size);\n    }\n  }\n\n  if (!active_worst_qchanged) vp8_update_rate_correction_factors(cpi, 2);\n\n  cpi->last_q[cm->frame_type] = cm->base_qindex;\n\n  if (cm->frame_type == KEY_FRAME) {\n    vp8_adjust_key_frame_context(cpi);\n  }\n\n  /* Keep a record of ambient average Q. */\n  if (cm->frame_type != KEY_FRAME) {\n    cpi->avg_frame_qindex =\n        (2 + 3 * cpi->avg_frame_qindex + cm->base_qindex) >> 2;\n  }\n\n  /* Keep a record from which we can calculate the average Q excluding\n   * GF updates and key frames\n   */\n  if ((cm->frame_type != KEY_FRAME) &&\n      ((cpi->oxcf.number_of_layers > 1) ||\n       (!cm->refresh_golden_frame && !cm->refresh_alt_ref_frame))) {\n    cpi->ni_frames++;\n\n    /* Calculate the average Q for normal inter frames (not key or GFU\n     * frames).\n     */\n    if (cpi->pass == 2) {\n      cpi->ni_tot_qi += Q;\n      cpi->ni_av_qi = (cpi->ni_tot_qi / cpi->ni_frames);\n    } else {\n      /* Damp value for first few frames */\n      if (cpi->ni_frames > 150) {\n        cpi->ni_tot_qi += Q;\n        cpi->ni_av_qi = (cpi->ni_tot_qi / cpi->ni_frames);\n      }\n      /* For one pass, early in the clip ... average the current frame Q\n       * value with the worstq entered by the user as a dampening measure\n       */\n      else {\n        cpi->ni_tot_qi += Q;\n        cpi->ni_av_qi =\n            ((cpi->ni_tot_qi / cpi->ni_frames) + cpi->worst_quality + 1) / 2;\n      }\n\n      /* If the average Q is higher than what was used in the last\n       * frame (after going through the recode loop to keep the frame\n       * size within range) then use the last frame value - 1. The -1\n       * is designed to stop Q and hence the data rate, from\n       * progressively falling away during difficult sections, but at\n       * the same time reduce the number of iterations around the\n       * recode loop.\n       */\n      if (Q > cpi->ni_av_qi) cpi->ni_av_qi = Q - 1;\n    }\n  }\n\n  /* Update the buffer level variable. */\n  /* Non-viewable frames are a special case and are treated as pure overhead. */\n  if (!cm->show_frame) {\n    cpi->bits_off_target -= cpi->projected_frame_size;\n  } else {\n    cpi->bits_off_target +=\n        cpi->av_per_frame_bandwidth - cpi->projected_frame_size;\n  }\n\n  /* Clip the buffer level to the maximum specified buffer size */\n  if (cpi->bits_off_target > cpi->oxcf.maximum_buffer_size) {\n    cpi->bits_off_target = cpi->oxcf.maximum_buffer_size;\n  }\n\n  // Don't let the buffer level go below some threshold, given here\n  // by -|maximum_buffer_size|. For now we only do this for\n  // screen content input.\n  if (cpi->oxcf.screen_content_mode &&\n      cpi->bits_off_target < -cpi->oxcf.maximum_buffer_size) {\n    cpi->bits_off_target = -cpi->oxcf.maximum_buffer_size;\n  }\n\n  /* Rolling monitors of whether we are over or underspending used to\n   * help regulate min and Max Q in two pass.\n   */\n  cpi->rolling_target_bits = (int)ROUND64_POWER_OF_TWO(\n      (int64_t)cpi->rolling_target_bits * 3 + cpi->this_frame_target, 2);\n  cpi->rolling_actual_bits = (int)ROUND64_POWER_OF_TWO(\n      (int64_t)cpi->rolling_actual_bits * 3 + cpi->projected_frame_size, 2);\n  cpi->long_rolling_target_bits = (int)ROUND64_POWER_OF_TWO(\n      (int64_t)cpi->long_rolling_target_bits * 31 + cpi->this_frame_target, 5);\n  cpi->long_rolling_actual_bits = (int)ROUND64_POWER_OF_TWO(\n      (int64_t)cpi->long_rolling_actual_bits * 31 + cpi->projected_frame_size,\n      5);\n\n  /* Actual bits spent */\n  cpi->total_actual_bits += cpi->projected_frame_size;\n\n#if 0 && CONFIG_INTERNAL_STATS\n  /* Debug stats */\n  cpi->total_target_vs_actual +=\n      (cpi->this_frame_target - cpi->projected_frame_size);\n#endif\n\n  cpi->buffer_level = cpi->bits_off_target;\n\n  /* Propagate values to higher temporal layers */\n  if (cpi->oxcf.number_of_layers > 1) {\n    unsigned int i;\n\n    for (i = cpi->current_layer + 1; i < cpi->oxcf.number_of_layers; ++i) {\n      LAYER_CONTEXT *lc = &cpi->layer_context[i];\n      int bits_off_for_this_layer = (int)round(\n          lc->target_bandwidth / lc->framerate - cpi->projected_frame_size);\n\n      lc->bits_off_target += bits_off_for_this_layer;\n\n      /* Clip buffer level to maximum buffer size for the layer */\n      if (lc->bits_off_target > lc->maximum_buffer_size) {\n        lc->bits_off_target = lc->maximum_buffer_size;\n      }\n\n      lc->total_actual_bits += cpi->projected_frame_size;\n      lc->total_target_vs_actual += bits_off_for_this_layer;\n      lc->buffer_level = lc->bits_off_target;\n    }\n  }\n\n  /* Update bits left to the kf and gf groups to account for overshoot\n   * or undershoot on these frames\n   */\n  if (cm->frame_type == KEY_FRAME) {\n    cpi->twopass.kf_group_bits +=\n        cpi->this_frame_target - cpi->projected_frame_size;\n\n    if (cpi->twopass.kf_group_bits < 0) cpi->twopass.kf_group_bits = 0;\n  } else if (cm->refresh_golden_frame || cm->refresh_alt_ref_frame) {\n    cpi->twopass.gf_group_bits +=\n        cpi->this_frame_target - cpi->projected_frame_size;\n\n    if (cpi->twopass.gf_group_bits < 0) cpi->twopass.gf_group_bits = 0;\n  }\n\n  if (cm->frame_type != KEY_FRAME) {\n    if (cpi->common.refresh_alt_ref_frame) {\n      cpi->last_skip_false_probs[2] = cpi->prob_skip_false;\n      cpi->last_skip_probs_q[2] = cm->base_qindex;\n    } else if (cpi->common.refresh_golden_frame) {\n      cpi->last_skip_false_probs[1] = cpi->prob_skip_false;\n      cpi->last_skip_probs_q[1] = cm->base_qindex;\n    } else {\n      cpi->last_skip_false_probs[0] = cpi->prob_skip_false;\n      cpi->last_skip_probs_q[0] = cm->base_qindex;\n\n      /* update the baseline */\n      cpi->base_skip_false_prob[cm->base_qindex] = cpi->prob_skip_false;\n    }\n  }\n\n#if 0 && CONFIG_INTERNAL_STATS\n    {\n        FILE *f = fopen(\"tmp.stt\", \"a\");\n\n        vpx_clear_system_state();\n\n        if (cpi->twopass.total_left_stats.coded_error != 0.0)\n            fprintf(f, \"%10d %10d %10d %10d %10d %10\"PRId64\" %10\"PRId64\n                       \"%10\"PRId64\" %10d %6d %6d %6d %6d %5d %5d %5d %8d \"\n                       \"%8.2lf %\"PRId64\" %10.3lf %10\"PRId64\" %8d\\n\",\n                       cpi->common.current_video_frame, cpi->this_frame_target,\n                       cpi->projected_frame_size,\n                       (cpi->projected_frame_size - cpi->this_frame_target),\n                       cpi->total_target_vs_actual,\n                       cpi->buffer_level,\n                       (cpi->oxcf.starting_buffer_level-cpi->bits_off_target),\n                       cpi->total_actual_bits, cm->base_qindex,\n                       cpi->active_best_quality, cpi->active_worst_quality,\n                       cpi->ni_av_qi, cpi->cq_target_quality,\n                       cm->refresh_golden_frame, cm->refresh_alt_ref_frame,\n                       cm->frame_type, cpi->gfu_boost,\n                       cpi->twopass.est_max_qcorrection_factor,\n                       cpi->twopass.bits_left,\n                       cpi->twopass.total_left_stats.coded_error,\n                       (double)cpi->twopass.bits_left /\n                           cpi->twopass.total_left_stats.coded_error,\n                       cpi->tot_recode_hits);\n        else\n            fprintf(f, \"%10d %10d %10d %10d %10d %10\"PRId64\" %10\"PRId64\n                       \"%10\"PRId64\" %10d %6d %6d %6d %6d %5d %5d %5d %8d \"\n                       \"%8.2lf %\"PRId64\" %10.3lf %8d\\n\",\n                       cpi->common.current_video_frame, cpi->this_frame_target,\n                       cpi->projected_frame_size,\n                       (cpi->projected_frame_size - cpi->this_frame_target),\n                       cpi->total_target_vs_actual,\n                       cpi->buffer_level,\n                       (cpi->oxcf.starting_buffer_level-cpi->bits_off_target),\n                       cpi->total_actual_bits, cm->base_qindex,\n                       cpi->active_best_quality, cpi->active_worst_quality,\n                       cpi->ni_av_qi, cpi->cq_target_quality,\n                       cm->refresh_golden_frame, cm->refresh_alt_ref_frame,\n                       cm->frame_type, cpi->gfu_boost,\n                       cpi->twopass.est_max_qcorrection_factor,\n                       cpi->twopass.bits_left,\n                       cpi->twopass.total_left_stats.coded_error,\n                       cpi->tot_recode_hits);\n\n        fclose(f);\n\n        {\n            FILE *fmodes = fopen(\"Modes.stt\", \"a\");\n\n            fprintf(fmodes, \"%6d:%1d:%1d:%1d \",\n                        cpi->common.current_video_frame,\n                        cm->frame_type, cm->refresh_golden_frame,\n                        cm->refresh_alt_ref_frame);\n\n            fprintf(fmodes, \"\\n\");\n\n            fclose(fmodes);\n        }\n    }\n\n#endif\n\n  cpi->ext_refresh_frame_flags_pending = 0;\n\n  if (cm->refresh_golden_frame == 1) {\n    cm->frame_flags = cm->frame_flags | FRAMEFLAGS_GOLDEN;\n  } else {\n    cm->frame_flags = cm->frame_flags & ~FRAMEFLAGS_GOLDEN;\n  }\n\n  if (cm->refresh_alt_ref_frame == 1) {\n    cm->frame_flags = cm->frame_flags | FRAMEFLAGS_ALTREF;\n  } else {\n    cm->frame_flags = cm->frame_flags & ~FRAMEFLAGS_ALTREF;\n  }\n\n  if (cm->refresh_last_frame & cm->refresh_golden_frame) { /* both refreshed */\n    cpi->gold_is_last = 1;\n  } else if (cm->refresh_last_frame ^ cm->refresh_golden_frame) {\n    /* 1 refreshed but not the other */\n    cpi->gold_is_last = 0;\n  }\n\n  if (cm->refresh_last_frame & cm->refresh_alt_ref_frame) { /* both refreshed */\n    cpi->alt_is_last = 1;\n  } else if (cm->refresh_last_frame ^ cm->refresh_alt_ref_frame) {\n    /* 1 refreshed but not the other */\n    cpi->alt_is_last = 0;\n  }\n\n  if (cm->refresh_alt_ref_frame &\n      cm->refresh_golden_frame) { /* both refreshed */\n    cpi->gold_is_alt = 1;\n  } else if (cm->refresh_alt_ref_frame ^ cm->refresh_golden_frame) {\n    /* 1 refreshed but not the other */\n    cpi->gold_is_alt = 0;\n  }\n\n  cpi->ref_frame_flags = VP8_ALTR_FRAME | VP8_GOLD_FRAME | VP8_LAST_FRAME;\n\n  if (cpi->gold_is_last) cpi->ref_frame_flags &= ~VP8_GOLD_FRAME;\n\n  if (cpi->alt_is_last) cpi->ref_frame_flags &= ~VP8_ALTR_FRAME;\n\n  if (cpi->gold_is_alt) cpi->ref_frame_flags &= ~VP8_ALTR_FRAME;\n\n  if (!cpi->oxcf.error_resilient_mode) {\n    if (cpi->oxcf.play_alternate && cm->refresh_alt_ref_frame &&\n        (cm->frame_type != KEY_FRAME)) {\n      /* Update the alternate reference frame stats as appropriate. */\n      update_alt_ref_frame_stats(cpi);\n    } else {\n      /* Update the Golden frame stats as appropriate. */\n      update_golden_frame_stats(cpi);\n    }\n  }\n\n  if (cm->frame_type == KEY_FRAME) {\n    /* Tell the caller that the frame was coded as a key frame */\n    *frame_flags = cm->frame_flags | FRAMEFLAGS_KEY;\n\n    /* As this frame is a key frame  the next defaults to an inter frame. */\n    cm->frame_type = INTER_FRAME;\n\n    cpi->last_frame_percent_intra = 100;\n  } else {\n    *frame_flags = cm->frame_flags & ~FRAMEFLAGS_KEY;\n\n    cpi->last_frame_percent_intra = cpi->this_frame_percent_intra;\n  }\n\n  /* Clear the one shot update flags for segmentation map and mode/ref\n   * loop filter deltas.\n   */\n  cpi->mb.e_mbd.update_mb_segmentation_map = 0;\n  cpi->mb.e_mbd.update_mb_segmentation_data = 0;\n  cpi->mb.e_mbd.mode_ref_lf_delta_update = 0;\n\n  /* Don't increment frame counters if this was an altref buffer update\n   * not a real frame\n   */\n  if (cm->show_frame) {\n    cm->current_video_frame++;\n    cpi->frames_since_key++;\n    cpi->temporal_pattern_counter++;\n  }\n\n#if 0\n    {\n        char filename[512];\n        FILE *recon_file;\n        sprintf(filename, \"enc%04d.yuv\", (int) cm->current_video_frame);\n        recon_file = fopen(filename, \"wb\");\n        fwrite(cm->yv12_fb[cm->lst_fb_idx].buffer_alloc,\n               cm->yv12_fb[cm->lst_fb_idx].frame_size, 1, recon_file);\n        fclose(recon_file);\n    }\n#endif\n\n  /* DEBUG */\n  /* vpx_write_yuv_frame(\"encoder_recon.yuv\", cm->frame_to_show); */\n}\n#if !CONFIG_REALTIME_ONLY\nstatic void Pass2Encode(VP8_COMP *cpi, size_t *size, unsigned char *dest,\n                        unsigned char *dest_end, unsigned int *frame_flags) {\n  if (!cpi->common.refresh_alt_ref_frame) vp8_second_pass(cpi);\n\n  encode_frame_to_data_rate(cpi, size, dest, dest_end, frame_flags);\n  cpi->twopass.bits_left -= 8 * (int)(*size);\n\n  if (!cpi->common.refresh_alt_ref_frame) {\n    double two_pass_min_rate =\n        (double)(cpi->oxcf.target_bandwidth *\n                 cpi->oxcf.two_pass_vbrmin_section / 100);\n    cpi->twopass.bits_left += (int64_t)(two_pass_min_rate / cpi->framerate);\n  }\n}\n#endif\n\nint vp8_receive_raw_frame(VP8_COMP *cpi, unsigned int frame_flags,\n                          YV12_BUFFER_CONFIG *sd, int64_t time_stamp,\n                          int64_t end_time) {\n  struct vpx_usec_timer timer;\n  int res = 0;\n\n  vpx_usec_timer_start(&timer);\n\n  /* Reinit the lookahead buffer if the frame size changes */\n  if (sd->y_width != cpi->oxcf.Width || sd->y_height != cpi->oxcf.Height) {\n    assert(cpi->oxcf.lag_in_frames < 2);\n    dealloc_raw_frame_buffers(cpi);\n    alloc_raw_frame_buffers(cpi);\n  }\n\n  if (vp8_lookahead_push(cpi->lookahead, sd, time_stamp, end_time, frame_flags,\n                         cpi->active_map_enabled ? cpi->active_map : NULL)) {\n    res = -1;\n  }\n  vpx_usec_timer_mark(&timer);\n  cpi->time_receive_data += vpx_usec_timer_elapsed(&timer);\n\n  return res;\n}\n\nstatic int frame_is_reference(const VP8_COMP *cpi) {\n  const VP8_COMMON *cm = &cpi->common;\n  const MACROBLOCKD *xd = &cpi->mb.e_mbd;\n\n  return cm->frame_type == KEY_FRAME || cm->refresh_last_frame ||\n         cm->refresh_golden_frame || cm->refresh_alt_ref_frame ||\n         cm->copy_buffer_to_gf || cm->copy_buffer_to_arf ||\n         cm->refresh_entropy_probs || xd->mode_ref_lf_delta_update ||\n         xd->update_mb_segmentation_map || xd->update_mb_segmentation_data;\n}\n\nint vp8_get_compressed_data(VP8_COMP *cpi, unsigned int *frame_flags,\n                            size_t *size, unsigned char *dest,\n                            unsigned char *dest_end, int64_t *time_stamp,\n                            int64_t *time_end, int flush) {\n  VP8_COMMON *cm;\n  struct vpx_usec_timer tsctimer;\n  struct vpx_usec_timer ticktimer;\n  struct vpx_usec_timer cmptimer;\n  YV12_BUFFER_CONFIG *force_src_buffer = NULL;\n\n  if (!cpi) return -1;\n\n  cm = &cpi->common;\n\n  vpx_usec_timer_start(&cmptimer);\n\n  cpi->source = NULL;\n\n#if !CONFIG_REALTIME_ONLY\n  /* Should we code an alternate reference frame */\n  if (cpi->oxcf.error_resilient_mode == 0 && cpi->oxcf.play_alternate &&\n      cpi->source_alt_ref_pending) {\n    if ((cpi->source = vp8_lookahead_peek(\n             cpi->lookahead, cpi->frames_till_gf_update_due, PEEK_FORWARD))) {\n      cpi->alt_ref_source = cpi->source;\n      if (cpi->oxcf.arnr_max_frames > 0) {\n        vp8_temporal_filter_prepare_c(cpi, cpi->frames_till_gf_update_due);\n        force_src_buffer = &cpi->alt_ref_buffer;\n      }\n      cpi->frames_till_alt_ref_frame = cpi->frames_till_gf_update_due;\n      cm->refresh_alt_ref_frame = 1;\n      cm->refresh_golden_frame = 0;\n      cm->refresh_last_frame = 0;\n      cm->show_frame = 0;\n      /* Clear Pending alt Ref flag. */\n      cpi->source_alt_ref_pending = 0;\n      cpi->is_src_frame_alt_ref = 0;\n    }\n  }\n#endif\n\n  if (!cpi->source) {\n    /* Read last frame source if we are encoding first pass. */\n    if (cpi->pass == 1 && cm->current_video_frame > 0) {\n      if ((cpi->last_source =\n               vp8_lookahead_peek(cpi->lookahead, 1, PEEK_BACKWARD)) == NULL) {\n        return -1;\n      }\n    }\n\n    if ((cpi->source = vp8_lookahead_pop(cpi->lookahead, flush))) {\n      cm->show_frame = 1;\n\n      cpi->is_src_frame_alt_ref =\n          cpi->alt_ref_source && (cpi->source == cpi->alt_ref_source);\n\n      if (cpi->is_src_frame_alt_ref) cpi->alt_ref_source = NULL;\n    }\n  }\n\n  if (cpi->source) {\n    cpi->Source = force_src_buffer ? force_src_buffer : &cpi->source->img;\n    cpi->un_scaled_source = cpi->Source;\n    *time_stamp = cpi->source->ts_start;\n    *time_end = cpi->source->ts_end;\n    *frame_flags = cpi->source->flags;\n\n    if (cpi->pass == 1 && cm->current_video_frame > 0) {\n      cpi->last_frame_unscaled_source = &cpi->last_source->img;\n    }\n  } else {\n    *size = 0;\n#if !CONFIG_REALTIME_ONLY\n\n    if (flush && cpi->pass == 1 && !cpi->twopass.first_pass_done) {\n      vp8_end_first_pass(cpi); /* get last stats packet */\n      cpi->twopass.first_pass_done = 1;\n    }\n\n#endif\n\n    return -1;\n  }\n\n  if (cpi->source->ts_start < cpi->first_time_stamp_ever) {\n    cpi->first_time_stamp_ever = cpi->source->ts_start;\n    cpi->last_end_time_stamp_seen = cpi->source->ts_start;\n  }\n\n  /* adjust frame rates based on timestamps given */\n  if (cm->show_frame) {\n    int64_t this_duration;\n    int step = 0;\n\n    if (cpi->source->ts_start == cpi->first_time_stamp_ever) {\n      this_duration = cpi->source->ts_end - cpi->source->ts_start;\n      step = 1;\n    } else {\n      int64_t last_duration;\n\n      this_duration = cpi->source->ts_end - cpi->last_end_time_stamp_seen;\n      last_duration = cpi->last_end_time_stamp_seen - cpi->last_time_stamp_seen;\n      // Cap this to avoid overflow of (this_duration - last_duration) * 10\n      this_duration = VPXMIN(this_duration, INT64_MAX / 10);\n      /* do a step update if the duration changes by 10% */\n      if (last_duration) {\n        step = (int)(((this_duration - last_duration) * 10 / last_duration));\n      }\n    }\n\n    if (this_duration) {\n      if (step) {\n        cpi->ref_framerate = 10000000.0 / this_duration;\n      } else {\n        double avg_duration, interval;\n\n        /* Average this frame's rate into the last second's average\n         * frame rate. If we haven't seen 1 second yet, then average\n         * over the whole interval seen.\n         */\n        interval = (double)(cpi->source->ts_end - cpi->first_time_stamp_ever);\n        if (interval > 10000000.0) interval = 10000000;\n\n        avg_duration = 10000000.0 / cpi->ref_framerate;\n        avg_duration *= (interval - avg_duration + this_duration);\n        avg_duration /= interval;\n\n        cpi->ref_framerate = 10000000.0 / avg_duration;\n      }\n#if CONFIG_MULTI_RES_ENCODING\n      if (cpi->oxcf.mr_total_resolutions > 1) {\n        LOWER_RES_FRAME_INFO *low_res_frame_info =\n            (LOWER_RES_FRAME_INFO *)cpi->oxcf.mr_low_res_mode_info;\n        // Frame rate should be the same for all spatial layers in\n        // multi-res-encoding (simulcast), so we constrain the frame for\n        // higher layers to be that of lowest resolution. This is needed\n        // as he application may decide to skip encoding a high layer and\n        // then start again, in which case a big jump in time-stamps will\n        // be received for that high layer, which will yield an incorrect\n        // frame rate (from time-stamp adjustment in above calculation).\n        if (cpi->oxcf.mr_encoder_id) {\n          if (!low_res_frame_info->skip_encoding_base_stream)\n            cpi->ref_framerate = low_res_frame_info->low_res_framerate;\n        } else {\n          // Keep track of frame rate for lowest resolution.\n          low_res_frame_info->low_res_framerate = cpi->ref_framerate;\n          // The base stream is being encoded so set skip flag to 0.\n          low_res_frame_info->skip_encoding_base_stream = 0;\n        }\n      }\n#endif\n      if (cpi->oxcf.number_of_layers > 1) {\n        unsigned int i;\n\n        /* Update frame rates for each layer */\n        assert(cpi->oxcf.number_of_layers <= VPX_TS_MAX_LAYERS);\n        for (i = 0; i < cpi->oxcf.number_of_layers && i < VPX_TS_MAX_LAYERS;\n             ++i) {\n          LAYER_CONTEXT *lc = &cpi->layer_context[i];\n          lc->framerate = cpi->ref_framerate / cpi->oxcf.rate_decimator[i];\n        }\n      } else {\n        vp8_new_framerate(cpi, cpi->ref_framerate);\n      }\n    }\n\n    cpi->last_time_stamp_seen = cpi->source->ts_start;\n    cpi->last_end_time_stamp_seen = cpi->source->ts_end;\n  }\n\n  if (cpi->oxcf.number_of_layers > 1) {\n    int layer;\n\n    vp8_update_layer_contexts(cpi);\n\n    /* Restore layer specific context & set frame rate */\n    if (cpi->temporal_layer_id >= 0) {\n      layer = cpi->temporal_layer_id;\n    } else {\n      layer =\n          cpi->oxcf\n              .layer_id[cpi->temporal_pattern_counter % cpi->oxcf.periodicity];\n    }\n    vp8_restore_layer_context(cpi, layer);\n    vp8_new_framerate(cpi, cpi->layer_context[layer].framerate);\n  }\n\n  if (cpi->compressor_speed == 2) {\n    vpx_usec_timer_start(&tsctimer);\n    vpx_usec_timer_start(&ticktimer);\n  }\n\n  cpi->lf_zeromv_pct = (cpi->zeromv_count * 100) / cm->MBs;\n\n#if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING\n  {\n    int i;\n    const int num_part = (1 << cm->multi_token_partition);\n    /* the available bytes in dest */\n    const unsigned long dest_size = dest_end - dest;\n    const int tok_part_buff_size = (dest_size * 9) / (10 * num_part);\n\n    unsigned char *dp = dest;\n\n    cpi->partition_d[0] = dp;\n    dp += dest_size / 10; /* reserve 1/10 for control partition */\n    cpi->partition_d_end[0] = dp;\n\n    for (i = 0; i < num_part; ++i) {\n      cpi->partition_d[i + 1] = dp;\n      dp += tok_part_buff_size;\n      cpi->partition_d_end[i + 1] = dp;\n    }\n  }\n#endif\n\n  /* start with a 0 size frame */\n  *size = 0;\n\n  /* Clear down mmx registers */\n  vpx_clear_system_state();\n\n  cm->frame_type = INTER_FRAME;\n  cm->frame_flags = *frame_flags;\n\n#if 0\n\n    if (cm->refresh_alt_ref_frame)\n    {\n        cm->refresh_golden_frame = 0;\n        cm->refresh_last_frame = 0;\n    }\n    else\n    {\n        cm->refresh_golden_frame = 0;\n        cm->refresh_last_frame = 1;\n    }\n\n#endif\n  /* find a free buffer for the new frame */\n  {\n    int i = 0;\n    for (; i < NUM_YV12_BUFFERS; ++i) {\n      if (!cm->yv12_fb[i].flags) {\n        cm->new_fb_idx = i;\n        break;\n      }\n    }\n\n    assert(i < NUM_YV12_BUFFERS);\n  }\n  switch (cpi->pass) {\n#if !CONFIG_REALTIME_ONLY\n    case 1: Pass1Encode(cpi); break;\n    case 2: Pass2Encode(cpi, size, dest, dest_end, frame_flags); break;\n#endif  // !CONFIG_REALTIME_ONLY\n    default:\n      encode_frame_to_data_rate(cpi, size, dest, dest_end, frame_flags);\n      break;\n  }\n\n  if (cpi->compressor_speed == 2) {\n    unsigned int duration, duration2;\n    vpx_usec_timer_mark(&tsctimer);\n    vpx_usec_timer_mark(&ticktimer);\n\n    duration = (int)(vpx_usec_timer_elapsed(&ticktimer));\n    duration2 = (unsigned int)((double)duration / 2);\n\n    if (cm->frame_type != KEY_FRAME) {\n      if (cpi->avg_encode_time == 0) {\n        cpi->avg_encode_time = duration;\n      } else {\n        cpi->avg_encode_time = (7 * cpi->avg_encode_time + duration) >> 3;\n      }\n    }\n\n    if (duration2) {\n      {\n        if (cpi->avg_pick_mode_time == 0) {\n          cpi->avg_pick_mode_time = duration2;\n        } else {\n          cpi->avg_pick_mode_time =\n              (7 * cpi->avg_pick_mode_time + duration2) >> 3;\n        }\n      }\n    }\n  }\n\n  if (cm->refresh_entropy_probs == 0) {\n    memcpy(&cm->fc, &cm->lfc, sizeof(cm->fc));\n  }\n\n  /* Save the contexts separately for alt ref, gold and last. */\n  /* (TODO jbb -> Optimize this with pointers to avoid extra copies. ) */\n  if (cm->refresh_alt_ref_frame) memcpy(&cpi->lfc_a, &cm->fc, sizeof(cm->fc));\n\n  if (cm->refresh_golden_frame) memcpy(&cpi->lfc_g, &cm->fc, sizeof(cm->fc));\n\n  if (cm->refresh_last_frame) memcpy(&cpi->lfc_n, &cm->fc, sizeof(cm->fc));\n\n  /* if it's a dropped frame honor the requests on subsequent frames */\n  if (*size > 0) {\n    cpi->droppable = !frame_is_reference(cpi);\n\n    /* return to normal state */\n    cm->refresh_entropy_probs = 1;\n    cm->refresh_alt_ref_frame = 0;\n    cm->refresh_golden_frame = 0;\n    cm->refresh_last_frame = 1;\n    cm->frame_type = INTER_FRAME;\n  }\n\n  /* Save layer specific state */\n  if (cpi->oxcf.number_of_layers > 1) vp8_save_layer_context(cpi);\n\n  vpx_usec_timer_mark(&cmptimer);\n  cpi->time_compress_data += vpx_usec_timer_elapsed(&cmptimer);\n\n  if (cpi->b_calculate_psnr && cpi->pass != 1 && cm->show_frame) {\n    generate_psnr_packet(cpi);\n  }\n\n#if CONFIG_INTERNAL_STATS\n\n  if (cpi->pass != 1) {\n    cpi->bytes += *size;\n\n    if (cm->show_frame) {\n      cpi->common.show_frame_mi = cpi->common.mi;\n      cpi->count++;\n\n      if (cpi->b_calculate_psnr) {\n        uint64_t ye, ue, ve;\n        double frame_psnr;\n        YV12_BUFFER_CONFIG *orig = cpi->Source;\n        YV12_BUFFER_CONFIG *recon = cpi->common.frame_to_show;\n        unsigned int y_width = cpi->common.Width;\n        unsigned int y_height = cpi->common.Height;\n        unsigned int uv_width = (y_width + 1) / 2;\n        unsigned int uv_height = (y_height + 1) / 2;\n        int y_samples = y_height * y_width;\n        int uv_samples = uv_height * uv_width;\n        int t_samples = y_samples + 2 * uv_samples;\n        double sq_error;\n\n        ye = calc_plane_error(orig->y_buffer, orig->y_stride, recon->y_buffer,\n                              recon->y_stride, y_width, y_height);\n\n        ue = calc_plane_error(orig->u_buffer, orig->uv_stride, recon->u_buffer,\n                              recon->uv_stride, uv_width, uv_height);\n\n        ve = calc_plane_error(orig->v_buffer, orig->uv_stride, recon->v_buffer,\n                              recon->uv_stride, uv_width, uv_height);\n\n        sq_error = (double)(ye + ue + ve);\n\n        frame_psnr = vpx_sse_to_psnr(t_samples, 255.0, sq_error);\n\n        cpi->total_y += vpx_sse_to_psnr(y_samples, 255.0, (double)ye);\n        cpi->total_u += vpx_sse_to_psnr(uv_samples, 255.0, (double)ue);\n        cpi->total_v += vpx_sse_to_psnr(uv_samples, 255.0, (double)ve);\n        cpi->total_sq_error += sq_error;\n        cpi->total += frame_psnr;\n#if CONFIG_POSTPROC\n        {\n          YV12_BUFFER_CONFIG *pp = &cm->post_proc_buffer;\n          double sq_error2;\n          double frame_psnr2, frame_ssim2 = 0;\n          double weight = 0;\n\n          vp8_deblock(cm, cm->frame_to_show, &cm->post_proc_buffer,\n                      cm->filter_level * 10 / 6);\n          vpx_clear_system_state();\n\n          ye = calc_plane_error(orig->y_buffer, orig->y_stride, pp->y_buffer,\n                                pp->y_stride, y_width, y_height);\n\n          ue = calc_plane_error(orig->u_buffer, orig->uv_stride, pp->u_buffer,\n                                pp->uv_stride, uv_width, uv_height);\n\n          ve = calc_plane_error(orig->v_buffer, orig->uv_stride, pp->v_buffer,\n                                pp->uv_stride, uv_width, uv_height);\n\n          sq_error2 = (double)(ye + ue + ve);\n\n          frame_psnr2 = vpx_sse_to_psnr(t_samples, 255.0, sq_error2);\n\n          cpi->totalp_y += vpx_sse_to_psnr(y_samples, 255.0, (double)ye);\n          cpi->totalp_u += vpx_sse_to_psnr(uv_samples, 255.0, (double)ue);\n          cpi->totalp_v += vpx_sse_to_psnr(uv_samples, 255.0, (double)ve);\n          cpi->total_sq_error2 += sq_error2;\n          cpi->totalp += frame_psnr2;\n\n          frame_ssim2 =\n              vpx_calc_ssim(cpi->Source, &cm->post_proc_buffer, &weight);\n\n          cpi->summed_quality += frame_ssim2 * weight;\n          cpi->summed_weights += weight;\n\n          if (cpi->oxcf.number_of_layers > 1) {\n            unsigned int i;\n\n            for (i = cpi->current_layer; i < cpi->oxcf.number_of_layers; ++i) {\n              cpi->frames_in_layer[i]++;\n\n              cpi->bytes_in_layer[i] += *size;\n              cpi->sum_psnr[i] += frame_psnr;\n              cpi->sum_psnr_p[i] += frame_psnr2;\n              cpi->total_error2[i] += sq_error;\n              cpi->total_error2_p[i] += sq_error2;\n              cpi->sum_ssim[i] += frame_ssim2 * weight;\n              cpi->sum_weights[i] += weight;\n            }\n          }\n        }\n#endif\n      }\n    }\n  }\n\n#if 0\n\n    if (cpi->common.frame_type != 0 && cpi->common.base_qindex == cpi->oxcf.worst_allowed_q)\n    {\n        skiptruecount += cpi->skip_true_count;\n        skipfalsecount += cpi->skip_false_count;\n    }\n\n#endif\n#if 0\n\n    if (cpi->pass != 1)\n    {\n        FILE *f = fopen(\"skip.stt\", \"a\");\n        fprintf(f, \"frame:%4d flags:%4x Q:%4d P:%4d Size:%5d\\n\", cpi->common.current_video_frame, *frame_flags, cpi->common.base_qindex, cpi->prob_skip_false, *size);\n\n        if (cpi->is_src_frame_alt_ref == 1)\n            fprintf(f, \"skipcount: %4d framesize: %d\\n\", cpi->skip_true_count , *size);\n\n        fclose(f);\n    }\n\n#endif\n#endif\n\n  cpi->common.error.setjmp = 0;\n\n#if CONFIG_MULTITHREAD\n  /* wait for the lpf thread done */\n  if (vpx_atomic_load_acquire(&cpi->b_multi_threaded) && cpi->b_lpf_running) {\n    sem_wait(&cpi->h_event_end_lpf);\n    cpi->b_lpf_running = 0;\n  }\n#endif\n\n  return 0;\n}\n\nint vp8_get_preview_raw_frame(VP8_COMP *cpi, YV12_BUFFER_CONFIG *dest,\n                              vp8_ppflags_t *flags) {\n  if (cpi->common.refresh_alt_ref_frame) {\n    return -1;\n  } else {\n    int ret;\n\n#if CONFIG_POSTPROC\n    cpi->common.show_frame_mi = cpi->common.mi;\n    ret = vp8_post_proc_frame(&cpi->common, dest, flags);\n#else\n    (void)flags;\n\n    if (cpi->common.frame_to_show) {\n      *dest = *cpi->common.frame_to_show;\n      dest->y_width = cpi->common.Width;\n      dest->y_height = cpi->common.Height;\n      dest->uv_height = cpi->common.Height / 2;\n      ret = 0;\n    } else {\n      ret = -1;\n    }\n\n#endif\n    vpx_clear_system_state();\n    return ret;\n  }\n}\n\nint vp8_set_roimap(VP8_COMP *cpi, unsigned char *map, unsigned int rows,\n                   unsigned int cols, int delta_q[4], int delta_lf[4],\n                   unsigned int threshold[4]) {\n  signed char feature_data[MB_LVL_MAX][MAX_MB_SEGMENTS];\n  int internal_delta_q[MAX_MB_SEGMENTS];\n  const int range = 63;\n  int i;\n\n  // Check number of rows and columns match\n  if (cpi->common.mb_rows != (int)rows || cpi->common.mb_cols != (int)cols) {\n    return -1;\n  }\n\n  for (i = 0; i < MAX_MB_SEGMENTS; ++i) {\n    // Note abs() alone can't be used as the behavior of abs(INT_MIN) is\n    // undefined.\n    if (delta_q[i] > range || delta_q[i] < -range || delta_lf[i] > range ||\n        delta_lf[i] < -range) {\n      return -1;\n    }\n  }\n\n  // Also disable segmentation if no deltas are specified.\n  if (!map || (delta_q[0] == 0 && delta_q[1] == 0 && delta_q[2] == 0 &&\n               delta_q[3] == 0 && delta_lf[0] == 0 && delta_lf[1] == 0 &&\n               delta_lf[2] == 0 && delta_lf[3] == 0 && threshold[0] == 0 &&\n               threshold[1] == 0 && threshold[2] == 0 && threshold[3] == 0)) {\n    disable_segmentation(cpi);\n    return 0;\n  }\n\n  // Translate the external delta q values to internal values.\n  for (i = 0; i < MAX_MB_SEGMENTS; ++i) {\n    internal_delta_q[i] =\n        (delta_q[i] >= 0) ? q_trans[delta_q[i]] : -q_trans[-delta_q[i]];\n  }\n\n  /* Set the segmentation Map */\n  set_segmentation_map(cpi, map);\n\n  /* Activate segmentation. */\n  enable_segmentation(cpi);\n\n  /* Set up the quant segment data */\n  feature_data[MB_LVL_ALT_Q][0] = internal_delta_q[0];\n  feature_data[MB_LVL_ALT_Q][1] = internal_delta_q[1];\n  feature_data[MB_LVL_ALT_Q][2] = internal_delta_q[2];\n  feature_data[MB_LVL_ALT_Q][3] = internal_delta_q[3];\n\n  /* Set up the loop segment data s */\n  feature_data[MB_LVL_ALT_LF][0] = delta_lf[0];\n  feature_data[MB_LVL_ALT_LF][1] = delta_lf[1];\n  feature_data[MB_LVL_ALT_LF][2] = delta_lf[2];\n  feature_data[MB_LVL_ALT_LF][3] = delta_lf[3];\n\n  cpi->segment_encode_breakout[0] = threshold[0];\n  cpi->segment_encode_breakout[1] = threshold[1];\n  cpi->segment_encode_breakout[2] = threshold[2];\n  cpi->segment_encode_breakout[3] = threshold[3];\n\n  /* Initialise the feature data structure */\n  set_segment_data(cpi, &feature_data[0][0], SEGMENT_DELTADATA);\n\n  if (threshold[0] != 0 || threshold[1] != 0 || threshold[2] != 0 ||\n      threshold[3] != 0)\n    cpi->use_roi_static_threshold = 1;\n  cpi->cyclic_refresh_mode_enabled = 0;\n\n  return 0;\n}\n\nint vp8_set_active_map(VP8_COMP *cpi, unsigned char *map, unsigned int rows,\n                       unsigned int cols) {\n  if ((int)rows == cpi->common.mb_rows && (int)cols == cpi->common.mb_cols) {\n    if (map) {\n      memcpy(cpi->active_map, map, rows * cols);\n      cpi->active_map_enabled = 1;\n    } else {\n      cpi->active_map_enabled = 0;\n    }\n\n    return 0;\n  } else {\n    return -1;\n  }\n}\n\nint vp8_set_internal_size(VP8_COMP *cpi, VPX_SCALING_MODE horiz_mode,\n                          VPX_SCALING_MODE vert_mode) {\n  if (horiz_mode <= VP8E_ONETWO) {\n    cpi->common.horiz_scale = horiz_mode;\n  } else {\n    return -1;\n  }\n\n  if (vert_mode <= VP8E_ONETWO) {\n    cpi->common.vert_scale = vert_mode;\n  } else {\n    return -1;\n  }\n\n  return 0;\n}\n\nint vp8_calc_ss_err(YV12_BUFFER_CONFIG *source, YV12_BUFFER_CONFIG *dest) {\n  int i, j;\n  int Total = 0;\n\n  unsigned char *src = source->y_buffer;\n  unsigned char *dst = dest->y_buffer;\n\n  /* Loop through the Y plane raw and reconstruction data summing\n   * (square differences)\n   */\n  for (i = 0; i < source->y_height; i += 16) {\n    for (j = 0; j < source->y_width; j += 16) {\n      unsigned int sse;\n      Total += vpx_mse16x16(src + j, source->y_stride, dst + j, dest->y_stride,\n                            &sse);\n    }\n\n    src += 16 * source->y_stride;\n    dst += 16 * dest->y_stride;\n  }\n\n  return Total;\n}\n\nint vp8_get_quantizer(VP8_COMP *cpi) { return cpi->common.base_qindex; }\n"], "filenames": ["test/encode_api_test.cc", "vp8/encoder/onyx_if.c"], "buggy_code_start_loc": [373, 1449], "buggy_code_end_loc": [377, 1449], "fixing_code_start_loc": [372, 1450], "fixing_code_end_loc": [372, 1455], "type": "CWE-787", "message": "Heap buffer overflow in vp8 encoding in libvpx in Google Chrome prior to 117.0.5938.132 and libvpx 1.13.1 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)", "other": {"cve": {"id": "CVE-2023-5217", "sourceIdentifier": "chrome-cve-admin@google.com", "published": "2023-09-28T16:15:10.980", "lastModified": "2024-02-15T02:00:01.650", "vulnStatus": "Analyzed", "cisaExploitAdd": "2023-10-02", "cisaActionDue": "2023-10-23", "cisaRequiredAction": "Apply mitigations per vendor instructions or discontinue use of the product if mitigations are unavailable.", "cisaVulnerabilityName": "Google Chromium libvpx Heap Buffer Overflow Vulnerability", "descriptions": [{"lang": "en", "value": "Heap buffer overflow in vp8 encoding in libvpx in Google Chrome prior to 117.0.5938.132 and libvpx 1.13.1 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)"}, {"lang": "es", "value": "El desbordamiento del b\u00fafer en la codificaci\u00f3n vp8 en libvpx en Google Chrome anterior a 117.0.5938.132 y libvpx 1.13.1 permit\u00eda a un atacante remoto explotar potencialmente la corrupci\u00f3n del mont\u00f3n a trav\u00e9s de una p\u00e1gina HTML manipulada. (Severidad de seguridad de Chrome: alta)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:webmproject:libvpx:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.13.1", "matchCriteriaId": "385F58CC-4AA0-4C41-9394-C9481586689E"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:a:google:chrome:*:*:*:*:*:*:*:*", "versionEndExcluding": "117.0.5938.132", "matchCriteriaId": "8F840D02-4766-4644-8FD6-637E945E88FB"}, {"vulnerable": false, "criteria": "cpe:2.3:a:mozilla:firefox:*:*:*:*:*:*:*:*", "versionEndExcluding": "118.0.1", "matchCriteriaId": "B8EE027E-A8D8-4038-B0C5-3F9ABA3079B6"}, {"vulnerable": false, "criteria": "cpe:2.3:a:mozilla:firefox:*:*:*:*:*:android:*:*", "versionEndExcluding": "118.1", "matchCriteriaId": "C0246068-275F-4D13-93B9-44AD91D2EFFB"}, {"vulnerable": false, "criteria": "cpe:2.3:a:mozilla:firefox_esr:*:*:*:*:*:*:*:*", "versionEndExcluding": "115.3.1", "matchCriteriaId": "2AAF4C02-0ED7-4AEF-BB14-A0A48DAC3B2E"}, {"vulnerable": false, "criteria": "cpe:2.3:a:mozilla:firefox_focus:*:*:*:*:*:android:*:*", "versionEndExcluding": "118.1", "matchCriteriaId": "54F53CD4-5766-401B-8333-1B8937112AD0"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:microsoft:edge:116.0.1938.98:*:*:*:*:*:*:*", "matchCriteriaId": "83749E8D-D4EC-4C5E-B031-8DD4C5C3AA72"}, {"vulnerable": true, "criteria": "cpe:2.3:a:microsoft:edge:117.0.2045.47:*:*:*:*:*:*:*", "matchCriteriaId": "39F5AB10-A20E-4B12-863D-9335A6344130"}, {"vulnerable": true, "criteria": "cpe:2.3:a:microsoft:edge_chromium:116.0.5845.229:*:*:*:*:*:*:*", "matchCriteriaId": "494B17DA-B40E-4B79-925D-2F439C7A4BCC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:microsoft:edge_chromium:117.0.5938.132:*:*:*:*:*:*:*", "matchCriteriaId": "0A1735C0-78BF-4B9C-9EC6-64471C609046"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:*:*:*:*:*:*:*:*", "versionEndExcluding": "118.0.1", "matchCriteriaId": "B8EE027E-A8D8-4038-B0C5-3F9ABA3079B6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:*:*:*:*:*:android:*:*", "versionEndExcluding": "118.1", "matchCriteriaId": "C0246068-275F-4D13-93B9-44AD91D2EFFB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox_esr:*:*:*:*:*:*:*:*", "versionEndExcluding": "115.3.1", "matchCriteriaId": "2AAF4C02-0ED7-4AEF-BB14-A0A48DAC3B2E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox_focus:*:*:*:*:*:android:*:*", "versionEndExcluding": "118.1", "matchCriteriaId": "54F53CD4-5766-401B-8333-1B8937112AD0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:thunderbird:*:*:*:*:*:*:*:*", "versionEndExcluding": "115.3.1", "matchCriteriaId": "C287FD41-1668-4BA8-9BF5-7C56420F6F38"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:38:*:*:*:*:*:*:*", "matchCriteriaId": "CC559B26-5DFC-4B7A-A27C-B77DE755DFF9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:39:*:*:*:*:*:*:*", "matchCriteriaId": "B8EDB836-4E6A-4B71-B9B2-AA3E03E0F646"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:12.0:*:*:*:*:*:*:*", "matchCriteriaId": "46D69DCC-AE4D-4EA5-861C-D60951444C6C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:apple:ipad_os:*:*:*:*:*:*:*:*", "versionStartIncluding": "17.0", "versionEndExcluding": "17.0.3", "matchCriteriaId": "DD22C5B0-7113-4F66-AF85-46F9DD0DC6B3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:ipad_os:16.7:*:*:*:*:*:*:*", "matchCriteriaId": "7DE4E0B0-9E6E-4735-8EFC-81D1F1724FCF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:iphone_os:*:*:*:*:*:*:*:*", "versionStartIncluding": "17.0", "versionEndExcluding": "17.0.3", "matchCriteriaId": "F1D28032-F9E6-45E7-98B6-7CE2351C4C99"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:iphone_os:16.7:*:*:*:*:*:*:*", "matchCriteriaId": "EF582B55-1D2F-4F53-9F3D-DB52F211B600"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2023/Oct/12", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2023/Oct/16", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2023/09/28/5", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2023/09/28/6", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2023/09/29/1", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2023/09/29/11", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2023/09/29/12", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2023/09/29/14", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2023/09/29/2", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2023/09/29/7", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2023/09/29/9", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2023/09/30/1", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2023/09/30/2", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2023/09/30/3", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2023/09/30/4", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2023/09/30/5", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2023/10/01/1", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2023/10/01/2", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2023/10/01/5", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2023/10/02/6", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2023/10/03/11", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://arstechnica.com/security/2023/09/new-0-day-in-chrome-and-firefox-is-likely-to-plague-other-software/", "source": "chrome-cve-admin@google.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2241191", "source": "chrome-cve-admin@google.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://chromereleases.googleblog.com/2023/09/stable-channel-update-for-desktop_27.html", "source": "chrome-cve-admin@google.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://crbug.com/1486441", "source": "chrome-cve-admin@google.com", "tags": ["Issue Tracking", "Permissions Required"]}, {"url": "https://github.com/webmproject/libvpx/commit/3fbd1dca6a4d2dad332a2110d646e4ffef36d590", "source": "chrome-cve-admin@google.com", "tags": ["Patch"]}, {"url": "https://github.com/webmproject/libvpx/commit/af6dedd715f4307669366944cca6e0417b290282", "source": "chrome-cve-admin@google.com", "tags": ["Patch"]}, {"url": "https://github.com/webmproject/libvpx/releases/tag/v1.13.1", "source": "chrome-cve-admin@google.com", "tags": ["Release Notes"]}, {"url": "https://github.com/webmproject/libvpx/tags", "source": "chrome-cve-admin@google.com", "tags": ["Product"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/09/msg00038.html", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/10/msg00001.html", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/10/msg00015.html", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4MFWDFJSSIFKWKNOCTQCFUNZWAXUCSS4/", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/55YVCZNAVY3Y5E4DWPWMX2SPKZ2E5SOV/", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/AY642Z6JZODQJE7Z62CFREVUHEGCXGPD/", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BCVSHVX2RFBU3RMCUFSATVQEJUFD4Q63/", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/CWEJYS5NC7KVFYU3OAMPKQDYN6JQGVK6/", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TE7F54W5O5RS4ZMAAC7YK3CZWQXIDSKB/", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WTRUIS3564P7ZLM2S2IH4Y4KZ327LI4I/", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List"]}, {"url": "https://pastebin.com/TdkC4pDv", "source": "chrome-cve-admin@google.com", "tags": ["Not Applicable"]}, {"url": "https://security-tracker.debian.org/tracker/CVE-2023-5217", "source": "chrome-cve-admin@google.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202310-04", "source": "chrome-cve-admin@google.com", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202401-34", "source": "chrome-cve-admin@google.com", "tags": ["Third Party Advisory"]}, {"url": "https://stackdiary.com/google-discloses-a-webm-vp8-bug-tracked-as-cve-2023-5217/", "source": "chrome-cve-admin@google.com", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213961", "source": "chrome-cve-admin@google.com", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213972", "source": "chrome-cve-admin@google.com", "tags": ["Third Party Advisory"]}, {"url": "https://twitter.com/maddiestone/status/1707163313711497266", "source": "chrome-cve-admin@google.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5508", "source": "chrome-cve-admin@google.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5509", "source": "chrome-cve-admin@google.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5510", "source": "chrome-cve-admin@google.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.mozilla.org/en-US/security/advisories/mfsa2023-44/", "source": "chrome-cve-admin@google.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2023/09/28/5", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/webmproject/libvpx/commit/3fbd1dca6a4d2dad332a2110d646e4ffef36d590"}}