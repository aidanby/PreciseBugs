{"buggy_code": ["/*\n * Interface between ext4 and JBD\n */\n\n#include \"ext4_jbd2.h\"\n\n#include <trace/events/ext4.h>\n\n/* Just increment the non-pointer handle value */\nstatic handle_t *ext4_get_nojournal(void)\n{\n\thandle_t *handle = current->journal_info;\n\tunsigned long ref_cnt = (unsigned long)handle;\n\n\tBUG_ON(ref_cnt >= EXT4_NOJOURNAL_MAX_REF_COUNT);\n\n\tref_cnt++;\n\thandle = (handle_t *)ref_cnt;\n\n\tcurrent->journal_info = handle;\n\treturn handle;\n}\n\n\n/* Decrement the non-pointer handle value */\nstatic void ext4_put_nojournal(handle_t *handle)\n{\n\tunsigned long ref_cnt = (unsigned long)handle;\n\n\tBUG_ON(ref_cnt == 0);\n\n\tref_cnt--;\n\thandle = (handle_t *)ref_cnt;\n\n\tcurrent->journal_info = handle;\n}\n\n/*\n * Wrappers for jbd2_journal_start/end.\n */\nstatic int ext4_journal_check_start(struct super_block *sb)\n{\n\tjournal_t *journal;\n\n\tmight_sleep();\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn -EROFS;\n\tWARN_ON(sb->s_writers.frozen == SB_FREEZE_COMPLETE);\n\tjournal = EXT4_SB(sb)->s_journal;\n\t/*\n\t * Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly.\n\t */\n\tif (journal && is_journal_aborted(journal)) {\n\t\text4_abort(sb, \"Detected aborted journal\");\n\t\treturn -EROFS;\n\t}\n\treturn 0;\n}\n\nhandle_t *__ext4_journal_start_sb(struct super_block *sb, unsigned int line,\n\t\t\t\t  int type, int blocks, int rsv_blocks)\n{\n\tjournal_t *journal;\n\tint err;\n\n\ttrace_ext4_journal_start(sb, blocks, rsv_blocks, _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\tjournal = EXT4_SB(sb)->s_journal;\n\tif (!journal)\n\t\treturn ext4_get_nojournal();\n\treturn jbd2__journal_start(journal, blocks, rsv_blocks, GFP_NOFS,\n\t\t\t\t   type, line);\n}\n\nint __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)\n{\n\tstruct super_block *sb;\n\tint err;\n\tint rc;\n\n\tif (!ext4_handle_valid(handle)) {\n\t\text4_put_nojournal(handle);\n\t\treturn 0;\n\t}\n\n\tif (!handle->h_transaction) {\n\t\terr = jbd2_journal_stop(handle);\n\t\treturn handle->h_err ? handle->h_err : err;\n\t}\n\n\tsb = handle->h_transaction->t_journal->j_private;\n\terr = handle->h_err;\n\trc = jbd2_journal_stop(handle);\n\n\tif (!err)\n\t\terr = rc;\n\tif (err)\n\t\t__ext4_std_error(sb, where, line, err);\n\treturn err;\n}\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}\n\nstatic void ext4_journal_abort_handle(const char *caller, unsigned int line,\n\t\t\t\t      const char *err_fn,\n\t\t\t\t      struct buffer_head *bh,\n\t\t\t\t      handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext4_decode_error(NULL, err, nbuf);\n\n\tBUG_ON(!ext4_handle_valid(handle));\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT4-fs: %s:%d: aborting transaction: %s in %s\\n\",\n\t       caller, line, errstr, err_fn);\n\n\tjbd2_journal_abort_handle(handle);\n}\n\nint __ext4_journal_get_write_access(const char *where, unsigned int line,\n\t\t\t\t    handle_t *handle, struct buffer_head *bh)\n{\n\tint err = 0;\n\n\tmight_sleep();\n\n\tif (ext4_handle_valid(handle)) {\n\t\terr = jbd2_journal_get_write_access(handle, bh);\n\t\tif (err)\n\t\t\text4_journal_abort_handle(where, line, __func__, bh,\n\t\t\t\t\t\t  handle, err);\n\t}\n\treturn err;\n}\n\n/*\n * The ext4 forget function must perform a revoke if we are freeing data\n * which has been journaled.  Metadata (eg. indirect blocks) must be\n * revoked in all cases.\n *\n * \"bh\" may be NULL: a metadata block may have been freed from memory\n * but there may still be a record of it in the journal, and that record\n * still needs to be revoked.\n *\n * If the handle isn't valid we're not journaling, but we still need to\n * call into ext4_journal_revoke() to put the buffer head.\n */\nint __ext4_forget(const char *where, unsigned int line, handle_t *handle,\n\t\t  int is_metadata, struct inode *inode,\n\t\t  struct buffer_head *bh, ext4_fsblk_t blocknr)\n{\n\tint err;\n\n\tmight_sleep();\n\n\ttrace_ext4_forget(inode, is_metadata, blocknr);\n\tBUFFER_TRACE(bh, \"enter\");\n\n\tjbd_debug(4, \"forgetting bh %p: is_metadata = %d, mode %o, \"\n\t\t  \"data mode %x\\n\",\n\t\t  bh, is_metadata, inode->i_mode,\n\t\t  test_opt(inode->i_sb, DATA_FLAGS));\n\n\t/* In the no journal case, we can just do a bforget and return */\n\tif (!ext4_handle_valid(handle)) {\n\t\tbforget(bh);\n\t\treturn 0;\n\t}\n\n\t/* Never use the revoke function if we are doing full data\n\t * journaling: there is no need to, and a V1 superblock won't\n\t * support it.  Otherwise, only skip the revoke on un-journaled\n\t * data blocks. */\n\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA ||\n\t    (!is_metadata && !ext4_should_journal_data(inode))) {\n\t\tif (bh) {\n\t\t\tBUFFER_TRACE(bh, \"call jbd2_journal_forget\");\n\t\t\terr = jbd2_journal_forget(handle, bh);\n\t\t\tif (err)\n\t\t\t\text4_journal_abort_handle(where, line, __func__,\n\t\t\t\t\t\t\t  bh, handle, err);\n\t\t\treturn err;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * data!=journal && (is_metadata || should_journal_data(inode))\n\t */\n\tBUFFER_TRACE(bh, \"call jbd2_journal_revoke\");\n\terr = jbd2_journal_revoke(handle, blocknr, bh);\n\tif (err) {\n\t\text4_journal_abort_handle(where, line, __func__,\n\t\t\t\t\t  bh, handle, err);\n\t\t__ext4_abort(inode->i_sb, where, line,\n\t\t\t   \"error %d when attempting revoke\", err);\n\t}\n\tBUFFER_TRACE(bh, \"exit\");\n\treturn err;\n}\n\nint __ext4_journal_get_create_access(const char *where, unsigned int line,\n\t\t\t\thandle_t *handle, struct buffer_head *bh)\n{\n\tint err = 0;\n\n\tif (ext4_handle_valid(handle)) {\n\t\terr = jbd2_journal_get_create_access(handle, bh);\n\t\tif (err)\n\t\t\text4_journal_abort_handle(where, line, __func__,\n\t\t\t\t\t\t  bh, handle, err);\n\t}\n\treturn err;\n}\n\nint __ext4_handle_dirty_metadata(const char *where, unsigned int line,\n\t\t\t\t handle_t *handle, struct inode *inode,\n\t\t\t\t struct buffer_head *bh)\n{\n\tint err = 0;\n\n\tmight_sleep();\n\n\tset_buffer_meta(bh);\n\tset_buffer_prio(bh);\n\tif (ext4_handle_valid(handle)) {\n\t\terr = jbd2_journal_dirty_metadata(handle, bh);\n\t\t/* Errors can only happen due to aborted journal or a nasty bug */\n\t\tif (!is_handle_aborted(handle) && WARN_ON_ONCE(err)) {\n\t\t\text4_journal_abort_handle(where, line, __func__, bh,\n\t\t\t\t\t\t  handle, err);\n\t\t\tif (inode == NULL) {\n\t\t\t\tpr_err(\"EXT4: jbd2_journal_dirty_metadata \"\n\t\t\t\t       \"failed: handle type %u started at \"\n\t\t\t\t       \"line %u, credits %u/%u, errcode %d\",\n\t\t\t\t       handle->h_type,\n\t\t\t\t       handle->h_line_no,\n\t\t\t\t       handle->h_requested_credits,\n\t\t\t\t       handle->h_buffer_credits, err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\text4_error_inode(inode, where, line,\n\t\t\t\t\t bh->b_blocknr,\n\t\t\t\t\t \"journal_dirty_metadata failed: \"\n\t\t\t\t\t \"handle type %u started at line %u, \"\n\t\t\t\t\t \"credits %u/%u, errcode %d\",\n\t\t\t\t\t handle->h_type,\n\t\t\t\t\t handle->h_line_no,\n\t\t\t\t\t handle->h_requested_credits,\n\t\t\t\t\t handle->h_buffer_credits, err);\n\t\t}\n\t} else {\n\t\tif (inode)\n\t\t\tmark_buffer_dirty_inode(bh, inode);\n\t\telse\n\t\t\tmark_buffer_dirty(bh);\n\t\tif (inode && inode_needs_sync(inode)) {\n\t\t\tsync_dirty_buffer(bh);\n\t\t\tif (buffer_req(bh) && !buffer_uptodate(bh)) {\n\t\t\t\tstruct ext4_super_block *es;\n\n\t\t\t\tes = EXT4_SB(inode->i_sb)->s_es;\n\t\t\t\tes->s_last_error_block =\n\t\t\t\t\tcpu_to_le64(bh->b_blocknr);\n\t\t\t\text4_error_inode(inode, where, line,\n\t\t\t\t\t\t bh->b_blocknr,\n\t\t\t\t\t\"IO error syncing itable block\");\n\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t}\n\t}\n\treturn err;\n}\n\nint __ext4_handle_dirty_super(const char *where, unsigned int line,\n\t\t\t      handle_t *handle, struct super_block *sb)\n{\n\tstruct buffer_head *bh = EXT4_SB(sb)->s_sbh;\n\tint err = 0;\n\n\text4_superblock_csum_set(sb);\n\tif (ext4_handle_valid(handle)) {\n\t\terr = jbd2_journal_dirty_metadata(handle, bh);\n\t\tif (err)\n\t\t\text4_journal_abort_handle(where, line, __func__,\n\t\t\t\t\t\t  bh, handle, err);\n\t} else\n\t\tmark_buffer_dirty(bh);\n\treturn err;\n}\n"], "fixing_code": ["/*\n * Interface between ext4 and JBD\n */\n\n#include \"ext4_jbd2.h\"\n\n#include <trace/events/ext4.h>\n\n/* Just increment the non-pointer handle value */\nstatic handle_t *ext4_get_nojournal(void)\n{\n\thandle_t *handle = current->journal_info;\n\tunsigned long ref_cnt = (unsigned long)handle;\n\n\tBUG_ON(ref_cnt >= EXT4_NOJOURNAL_MAX_REF_COUNT);\n\n\tref_cnt++;\n\thandle = (handle_t *)ref_cnt;\n\n\tcurrent->journal_info = handle;\n\treturn handle;\n}\n\n\n/* Decrement the non-pointer handle value */\nstatic void ext4_put_nojournal(handle_t *handle)\n{\n\tunsigned long ref_cnt = (unsigned long)handle;\n\n\tBUG_ON(ref_cnt == 0);\n\n\tref_cnt--;\n\thandle = (handle_t *)ref_cnt;\n\n\tcurrent->journal_info = handle;\n}\n\n/*\n * Wrappers for jbd2_journal_start/end.\n */\nstatic int ext4_journal_check_start(struct super_block *sb)\n{\n\tjournal_t *journal;\n\n\tmight_sleep();\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn -EROFS;\n\tWARN_ON(sb->s_writers.frozen == SB_FREEZE_COMPLETE);\n\tjournal = EXT4_SB(sb)->s_journal;\n\t/*\n\t * Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly.\n\t */\n\tif (journal && is_journal_aborted(journal)) {\n\t\text4_abort(sb, \"Detected aborted journal\");\n\t\treturn -EROFS;\n\t}\n\treturn 0;\n}\n\nhandle_t *__ext4_journal_start_sb(struct super_block *sb, unsigned int line,\n\t\t\t\t  int type, int blocks, int rsv_blocks)\n{\n\tjournal_t *journal;\n\tint err;\n\n\ttrace_ext4_journal_start(sb, blocks, rsv_blocks, _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\tjournal = EXT4_SB(sb)->s_journal;\n\tif (!journal)\n\t\treturn ext4_get_nojournal();\n\treturn jbd2__journal_start(journal, blocks, rsv_blocks, GFP_NOFS,\n\t\t\t\t   type, line);\n}\n\nint __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)\n{\n\tstruct super_block *sb;\n\tint err;\n\tint rc;\n\n\tif (!ext4_handle_valid(handle)) {\n\t\text4_put_nojournal(handle);\n\t\treturn 0;\n\t}\n\n\terr = handle->h_err;\n\tif (!handle->h_transaction) {\n\t\trc = jbd2_journal_stop(handle);\n\t\treturn err ? err : rc;\n\t}\n\n\tsb = handle->h_transaction->t_journal->j_private;\n\trc = jbd2_journal_stop(handle);\n\n\tif (!err)\n\t\terr = rc;\n\tif (err)\n\t\t__ext4_std_error(sb, where, line, err);\n\treturn err;\n}\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}\n\nstatic void ext4_journal_abort_handle(const char *caller, unsigned int line,\n\t\t\t\t      const char *err_fn,\n\t\t\t\t      struct buffer_head *bh,\n\t\t\t\t      handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext4_decode_error(NULL, err, nbuf);\n\n\tBUG_ON(!ext4_handle_valid(handle));\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT4-fs: %s:%d: aborting transaction: %s in %s\\n\",\n\t       caller, line, errstr, err_fn);\n\n\tjbd2_journal_abort_handle(handle);\n}\n\nint __ext4_journal_get_write_access(const char *where, unsigned int line,\n\t\t\t\t    handle_t *handle, struct buffer_head *bh)\n{\n\tint err = 0;\n\n\tmight_sleep();\n\n\tif (ext4_handle_valid(handle)) {\n\t\terr = jbd2_journal_get_write_access(handle, bh);\n\t\tif (err)\n\t\t\text4_journal_abort_handle(where, line, __func__, bh,\n\t\t\t\t\t\t  handle, err);\n\t}\n\treturn err;\n}\n\n/*\n * The ext4 forget function must perform a revoke if we are freeing data\n * which has been journaled.  Metadata (eg. indirect blocks) must be\n * revoked in all cases.\n *\n * \"bh\" may be NULL: a metadata block may have been freed from memory\n * but there may still be a record of it in the journal, and that record\n * still needs to be revoked.\n *\n * If the handle isn't valid we're not journaling, but we still need to\n * call into ext4_journal_revoke() to put the buffer head.\n */\nint __ext4_forget(const char *where, unsigned int line, handle_t *handle,\n\t\t  int is_metadata, struct inode *inode,\n\t\t  struct buffer_head *bh, ext4_fsblk_t blocknr)\n{\n\tint err;\n\n\tmight_sleep();\n\n\ttrace_ext4_forget(inode, is_metadata, blocknr);\n\tBUFFER_TRACE(bh, \"enter\");\n\n\tjbd_debug(4, \"forgetting bh %p: is_metadata = %d, mode %o, \"\n\t\t  \"data mode %x\\n\",\n\t\t  bh, is_metadata, inode->i_mode,\n\t\t  test_opt(inode->i_sb, DATA_FLAGS));\n\n\t/* In the no journal case, we can just do a bforget and return */\n\tif (!ext4_handle_valid(handle)) {\n\t\tbforget(bh);\n\t\treturn 0;\n\t}\n\n\t/* Never use the revoke function if we are doing full data\n\t * journaling: there is no need to, and a V1 superblock won't\n\t * support it.  Otherwise, only skip the revoke on un-journaled\n\t * data blocks. */\n\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA ||\n\t    (!is_metadata && !ext4_should_journal_data(inode))) {\n\t\tif (bh) {\n\t\t\tBUFFER_TRACE(bh, \"call jbd2_journal_forget\");\n\t\t\terr = jbd2_journal_forget(handle, bh);\n\t\t\tif (err)\n\t\t\t\text4_journal_abort_handle(where, line, __func__,\n\t\t\t\t\t\t\t  bh, handle, err);\n\t\t\treturn err;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * data!=journal && (is_metadata || should_journal_data(inode))\n\t */\n\tBUFFER_TRACE(bh, \"call jbd2_journal_revoke\");\n\terr = jbd2_journal_revoke(handle, blocknr, bh);\n\tif (err) {\n\t\text4_journal_abort_handle(where, line, __func__,\n\t\t\t\t\t  bh, handle, err);\n\t\t__ext4_abort(inode->i_sb, where, line,\n\t\t\t   \"error %d when attempting revoke\", err);\n\t}\n\tBUFFER_TRACE(bh, \"exit\");\n\treturn err;\n}\n\nint __ext4_journal_get_create_access(const char *where, unsigned int line,\n\t\t\t\thandle_t *handle, struct buffer_head *bh)\n{\n\tint err = 0;\n\n\tif (ext4_handle_valid(handle)) {\n\t\terr = jbd2_journal_get_create_access(handle, bh);\n\t\tif (err)\n\t\t\text4_journal_abort_handle(where, line, __func__,\n\t\t\t\t\t\t  bh, handle, err);\n\t}\n\treturn err;\n}\n\nint __ext4_handle_dirty_metadata(const char *where, unsigned int line,\n\t\t\t\t handle_t *handle, struct inode *inode,\n\t\t\t\t struct buffer_head *bh)\n{\n\tint err = 0;\n\n\tmight_sleep();\n\n\tset_buffer_meta(bh);\n\tset_buffer_prio(bh);\n\tif (ext4_handle_valid(handle)) {\n\t\terr = jbd2_journal_dirty_metadata(handle, bh);\n\t\t/* Errors can only happen due to aborted journal or a nasty bug */\n\t\tif (!is_handle_aborted(handle) && WARN_ON_ONCE(err)) {\n\t\t\text4_journal_abort_handle(where, line, __func__, bh,\n\t\t\t\t\t\t  handle, err);\n\t\t\tif (inode == NULL) {\n\t\t\t\tpr_err(\"EXT4: jbd2_journal_dirty_metadata \"\n\t\t\t\t       \"failed: handle type %u started at \"\n\t\t\t\t       \"line %u, credits %u/%u, errcode %d\",\n\t\t\t\t       handle->h_type,\n\t\t\t\t       handle->h_line_no,\n\t\t\t\t       handle->h_requested_credits,\n\t\t\t\t       handle->h_buffer_credits, err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\text4_error_inode(inode, where, line,\n\t\t\t\t\t bh->b_blocknr,\n\t\t\t\t\t \"journal_dirty_metadata failed: \"\n\t\t\t\t\t \"handle type %u started at line %u, \"\n\t\t\t\t\t \"credits %u/%u, errcode %d\",\n\t\t\t\t\t handle->h_type,\n\t\t\t\t\t handle->h_line_no,\n\t\t\t\t\t handle->h_requested_credits,\n\t\t\t\t\t handle->h_buffer_credits, err);\n\t\t}\n\t} else {\n\t\tif (inode)\n\t\t\tmark_buffer_dirty_inode(bh, inode);\n\t\telse\n\t\t\tmark_buffer_dirty(bh);\n\t\tif (inode && inode_needs_sync(inode)) {\n\t\t\tsync_dirty_buffer(bh);\n\t\t\tif (buffer_req(bh) && !buffer_uptodate(bh)) {\n\t\t\t\tstruct ext4_super_block *es;\n\n\t\t\t\tes = EXT4_SB(inode->i_sb)->s_es;\n\t\t\t\tes->s_last_error_block =\n\t\t\t\t\tcpu_to_le64(bh->b_blocknr);\n\t\t\t\text4_error_inode(inode, where, line,\n\t\t\t\t\t\t bh->b_blocknr,\n\t\t\t\t\t\"IO error syncing itable block\");\n\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t}\n\t}\n\treturn err;\n}\n\nint __ext4_handle_dirty_super(const char *where, unsigned int line,\n\t\t\t      handle_t *handle, struct super_block *sb)\n{\n\tstruct buffer_head *bh = EXT4_SB(sb)->s_sbh;\n\tint err = 0;\n\n\text4_superblock_csum_set(sb);\n\tif (ext4_handle_valid(handle)) {\n\t\terr = jbd2_journal_dirty_metadata(handle, bh);\n\t\tif (err)\n\t\t\text4_journal_abort_handle(where, line, __func__,\n\t\t\t\t\t\t  bh, handle, err);\n\t} else\n\t\tmark_buffer_dirty(bh);\n\treturn err;\n}\n"], "filenames": ["fs/ext4/ext4_jbd2.c"], "buggy_code_start_loc": [90], "buggy_code_end_loc": [98], "fixing_code_start_loc": [91], "fixing_code_end_loc": [97], "type": "CWE-416", "message": "The __ext4_journal_stop function in fs/ext4/ext4_jbd2.c in the Linux kernel before 4.3.3 allows local users to gain privileges or cause a denial of service (use-after-free) by leveraging improper access to a certain error field.", "other": {"cve": {"id": "CVE-2015-8961", "sourceIdentifier": "security@android.com", "published": "2016-11-16T05:59:00.140", "lastModified": "2023-01-19T16:05:41.817", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The __ext4_journal_stop function in fs/ext4/ext4_jbd2.c in the Linux kernel before 4.3.3 allows local users to gain privileges or cause a denial of service (use-after-free) by leveraging improper access to a certain error field."}, {"lang": "es", "value": "La funci\u00f3n __ext4_journal_stop en fs / ext4 / ext4_jbd2.c en el kernel de Linux en versiones anteriores a 4.3.3 permite a usuarios locales obtener privilegios o provocar una denegaci\u00f3n de servicio al utilizar un acceso incorrecto a un cierto campo de error."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 9.3}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.10.85", "versionEndExcluding": "3.12", "matchCriteriaId": "8D9994CF-60E9-40DC-90EA-253970B6893F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.12.46", "versionEndExcluding": "3.12.52", "matchCriteriaId": "DD258BA3-8666-4932-974F-567ADC3BB8A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.14.49", "versionEndExcluding": "3.14.59", "matchCriteriaId": "6E438FC9-06F9-422C-9C99-9C6C6A4E7433"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.18.20", "versionEndExcluding": "3.18.54", "matchCriteriaId": "3DFEDC10-1597-4BD9-9AF8-713AC8666AB0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.1.4", "versionEndExcluding": "4.1.15", "matchCriteriaId": "9B75A0C7-1BE2-4B3D-80D2-3659C3B6C34F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2", "versionEndExcluding": "4.2.8", "matchCriteriaId": "C905FCE9-FF1B-40C3-8890-A85C16CEF336"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.3", "versionEndExcluding": "4.3.3", "matchCriteriaId": "C9A419EE-0665-4EE4-B055-B8E76DEA1BE8"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=6934da9238da947628be83635e365df41064b09b", "source": "security@android.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.3.3", "source": "security@android.com", "tags": ["Release Notes"]}, {"url": "http://www.securityfocus.com/bid/94135", "source": "security@android.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/6934da9238da947628be83635e365df41064b09b", "source": "security@android.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://source.android.com/security/bulletin/2016-11-01.html", "source": "security@android.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/6934da9238da947628be83635e365df41064b09b"}}