{"buggy_code": ["![Rdiffweb Banner](https://gitlab.com/ikus-soft/rdiffweb/-/raw/master/doc/_static/banner.png)\n\n<p align=\"center\">\n<strong>\n<a href=\"https://www.rdiffweb.org\">website</a>\n\u2022 <a href=\"https://www.ikus-soft.com/archive/rdiffweb/doc/latest/html/\">docs</a>\n\u2022 <a href=\"https://groups.google.com/d/forum/rdiffweb\">community</a>\n\u2022 <a href=\"https://rdiffweb-demo.ikus-soft.com/\">demo</a>\n</strong>\n</p>\n\n<p align=\"center\">\n<a href=\"LICENSE\"><img alt=\"License\" src=\"https://img.shields.io/github/license/ikus060/rdiffweb\"></a>\n<a href=\"https://gitlab.com/ikus-soft/rdiffweb/pipelines\"><img alt=\"Build\" src=\"https://gitlab.com/ikus-soft/rdiffweb/badges/master/pipeline.svg\"></a>\n<a href=\"https://sonar.ikus-soft.com/dashboard?id=rdiffweb\"><img alt=\"Quality Gate Minarca Client\" src=\"https://sonar.ikus-soft.com/api/project_badges/measure?project=rdiffweb&metric=alert_status\"></a>\n<a href=\"https://sonar.ikus-soft.com/dashboard?id=rdiffweb\"><img alt=\"Coverage\" src=\"https://sonar.ikus-soft.com/api/project_badges/measure?project=rdiffweb&metric=coverage\"></a>\n<a href=\"https://bestpractices.coreinfrastructure.org/projects/6583\"><img src=\"https://bestpractices.coreinfrastructure.org/projects/6583/badge\"></a>\n</p>\n\n<h1 align=\"center\">\nWelcome to Rdiffweb\n</h1>\n\nRdiffweb is a web application that allows you to view repositories generated\nby [rdiff-backup](https://rdiff-backup.net/). The purpose of this\napplication is to ease the management of backups and quickly restore your data\nwith a rich and powerful web interface.\n\nRdiffweb is written in Python and is released as open source project under the \nGNU GENERAL PUBLIC LICENSE (GPL). All source code and documentation are\nCopyright Rdiffweb contributors.\n\nRdiffweb is actively developed by [IKUS Soft](https://www.ikus-soft.com/)\nsince November 2014.\n\nThe Rdiffweb source code is hosted on [Gitlab](https://gitlab.com/ikus-soft/rdiffweb)\nand mirrored to [Github](https://github.com/ikus060/rdiffweb).\n\nThe Rdiffweb website is https://rdiffweb.org/.\n\n## Features\n\nWith its rich web interface Rdiffweb provide a notable list of features:\n\n* Browse your backup\n* Restore single file or multiple files as an archived\n* Users authentication via local database and LDAP\n* Users authorization\n* Email notification when backup is not successful\n* Configurable repository encoding\n* Configurable retention period\n* Backup statistics visualization using graphs\n* SSH Keys management\n* Disk quota visualization\n* File and folder deletion\n\n## Demo\n\nIf you quickly want to check how Rdiffweb is behaving, you may try our demo server hosted on:\n\n[https://rdiffweb-demo.ikus-soft.com/](https://rdiffweb-demo.ikus-soft.com/)\n\nUse the following credential to login:\n\n* Username: admin\n* Password: admin123\n\n## Installation & Docker usage\n\nFor detailed installation steps, read the [Installation documentation](https://www.ikus-soft.com/archive/rdiffweb/doc/latest/html/installation.html).\n\n## Current Build Status\n\n[![Build Status](https://gitlab.com/ikus-soft/rdiffweb/badges/master/pipeline.svg)](https://gitlab.com/ikus-soft/rdiffweb/pipelines)\n\n## Download\n\nYou should read the [Documentation](https://www.ikus-soft.com/archive/rdiffweb/doc/latest/html/index.html) to properly install Rdiffweb in your environment.\n\n**Docker**\n\n    docker pull ikus060/rdiffweb\n\n**Debian**\n\n    curl -L https://www.ikus-soft.com/archive/rdiffweb/public.key | apt-key add - \n    echo \"deb https://nexus.ikus-soft.com/repository/apt-release-bullseye/ bullseye main\" > /etc/apt/sources.list.d/rdiffweb.list\n    apt update\n    apt install rdiffweb\n\n**Pypi**\n\n    pip install rdiffweb\n\n## Support\n\n### Mailing list\n\nRdiffweb users should use the [Rdiffweb mailing list](https://groups.google.com/forum/#!forum/rdiffweb).\n\n### Bug Reports\n\nBug reports should be reported on the Rdiffweb Gitlab at https://gitlab.com/ikus-soft/rdiffweb/-/issues\n\n### Professional support\n\nProfessional support for Rdiffweb is available by contacting [IKUS Soft](https://www.ikus-soft.com/en/support/#form).\n\n# Changelog\n\n## Next Release - 2.5.5\n\n* Fix loading of Charts in Status page\n* Ensure Gmail and other mail client doesn't create hyperlink automatically for any nodification sent by Rdiffweb to avoid phishing - credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Sent email notification to user when a new SSH Key get added - credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Ratelimit \"Resend code to my email\" in Two-Factor Authentication view - credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n\n## 2.5.4 (2022-12-19)\n\n* Discard `X-Forwarded-Host` headers credit to [Anishka Shukla](https://github.com/anishkashukla)\n* Create proper symbolic link of `chartkick.js` on Ubuntu Jammy to fix loading of Charts in web interface\n* Add CSRF verification on `/logout` credits to [reza.duty](https://rezaduty.me)\n\n## 2.5.3 (2022-12-05)\n\n* Add support for WTForms v3 to support Debian Bookworm\n* Fix strange behavior in access token management #247\n\n## 2.5.2 (2022-11-28)\n\n* Block repository access when user_root directory is empty or relative path [CVE-2022-4314](https://nvd.nist.gov/vuln/detail/CVE-2022-4314) credit to [neverjunior](https://github.com/neverjunior)\n* Replace admin password only when `--admin-password` option is provided #246\n* Invalidate browser cache for `logo`, `headerlogo` and `favicon` on restart #245\n\n## 2.5.1 (2022-11-11)\n\n* Add support for Ubuntu Kinetic #240\n* Disable filesize for deleted files to improve page loading #241\n\n## 2.5.0 (2022-11-09)\n\nThis next release focus on two-factor-authentication as a measure to increase security of user's account.\n\n* Store User's session information into database\n* Update ldap plugin to load additional attributes from LDAP server\n* Improve `/status` page error handling when `session_statistics` cannot be read\n* Add support for Ubuntu Jammy\n* Upgrade from Bootstrap v3 to v4 #204\n* Replace Fontello by Font-Awesome v4\n* Use CSS variables `var()` to customize themes using `--branding-X` options #239\n* Remove usage of Jquery.validate\n* Replace custom timsort by jquery DataTables #205\n* Add Active Session managements #203\n  * Active session should be visible in user's profiles\n  * Active session may be revoked by user\n  * Active session should be visible in administration view\n  * Action session may be revoke by administrator\n  * Show number of active users within the last 24 hours in dashboard\n* Handle migration of older Rdiffweb database by adding the missing `repos.Encoding`, `repos.keepdays` and `users.role` columns #185\n* Replace deprecated references of `disutils.spawn.find_executable()` by `shutil.which()` #208\n* Add two-factor authentication with email verification #201\n* Generate a new session on login and 2FA #220\n* Enforce permission on /etc/rdiffweb configuration folder\n* Enforce validation on fullname, username and email\n* Limit incorrect attempts to change the user's password to prevent brute force attacks #225 [CVE-2022-3273](https://nvd.nist.gov/vuln/detail/CVE-2022-3273) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Enforce password policy new password cannot be set as new password [CVE-2022-3376](https://nvd.nist.gov/vuln/detail/CVE-2022-3376) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Enforce better rate limit on login, mfa, password change and API [CVE-2022-3439](https://nvd.nist.gov/vuln/detail/CVE-2022-3439) [CVE-2022-3456](https://nvd.nist.gov/vuln/detail/CVE-2022-3456) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Enforce 'Origin' validation [CVE-2022-3457](https://nvd.nist.gov/vuln/detail/CVE-2022-3457) credit to [Nithissh12](Nithissh12)\n* Define idle and absolute session timeout with agressive default to protect usage on public computer [CVE-2022-3327](https://nvd.nist.gov/vuln/detail/CVE-2022-3327) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Send email notification when enabling or disabling MFA [CVE-2022-3363](https://nvd.nist.gov/vuln/detail/CVE-2022-3363) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Use Argon2id to store password hash #231\n* Fixed plugin priorities to ensure that jobs are scheduled at each startup #232\n* Revoke previous user's sessions on password change [CVE-2022-3362](https://nvd.nist.gov/vuln/detail/CVE-2022-3362) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n\nBreaking changes:\n\n* Drop Ubuntu Hirsute & Impish (End-of-life)\n* `session-dir` is deprecated and should be replace by `rate-limit-dir`. User's session are stored in database.\n* previous `.css` customization are not barkward compatible. Make usage of the `--branding-X` options.\n\n**Thanks to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172) with whom I collaborate to improve the security of this project.**\n\n## 2.4.10 (2022-10-03)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Mitigate path traversal vulnerability [CVE-2022-3389](https://nvd.nist.gov/vuln/detail/CVE-2022-3389) credit to [Hoang Van Hiep](https://www.linkedin.com/in/hiephv2410/)\n\n## 2.4.9 (2022-09-28)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Add `Cache-Control` and other security headers [CVE-2022-3292](https://nvd.nist.gov/vuln/detail/CVE-2022-3292) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Enforce password policy using `password-score` based on [zxcvbn](https://github.com/dropbox/zxcvbn) [CVE-2022-3326](https://nvd.nist.gov/vuln/detail/CVE-2022-3326) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n\n## 2.4.8 (2022-09-26)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Clean-up invalid path on error page\n* Limit username field length [CVE-2022-3290](https://nvd.nist.gov/vuln/detail/CVE-2022-3290) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Limit user's email field length [CVE-2022-3272](https://nvd.nist.gov/vuln/detail/CVE-2022-3272) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Limit user's root directory field length [CVE-2022-3295](https://nvd.nist.gov/vuln/detail/CVE-2022-3295) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Limit SSH Key title field length [CVE-2022-3298](https://nvd.nist.gov/vuln/detail/CVE-2022-3298) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n\n## 2.4.7 (2002-09-21)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Generate a new session on login and 2FA #220 [CVE-2022-3269](https://nvd.nist.gov/vuln/detail/CVE-2022-3269) credit to [Ambadi MP](https://www.linkedin.com/in/ambadi-m-p-16a95217b/)\n* Mitigate CSRF on user's settings #221 [CVE-2022-3274](https://nvd.nist.gov/vuln/detail/CVE-2022-3274) credit to [irfansayyed](https://github.com/irfansayyed-github)\n\n## 2.4.6 (2022-09-20)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Support MarkupSafe<3 for Debian bookworm\n* Mitigate CSRF on user's notification settings #216 [CVE-2022-3233](https://nvd.nist.gov/vuln/detail/CVE-2022-3233) credit to [Ambadi MP](https://www.linkedin.com/in/ambadi-m-p-16a95217b/)\n* Mitigate CSRF on repository settings #217 [CVE-2022-3267](https://nvd.nist.gov/vuln/detail/CVE-2022-3267) credit to [irfansayyed](https://github.com/irfansayyed-github)\n* Use 'Secure' Attribute with Sensitive Cookie in HTTPS Session on HTTP Error #218 [CVE-2022-3174](https://nvd.nist.gov/vuln/detail/CVE-2022-3174) credit to [Chuu](https://github.com/uonghoangminhchau)\n\n## 2.4.5 (2002-09-16)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Mitigate CSRF on repository deletion and user deletion [CVE-2022-3232](https://nvd.nist.gov/vuln/detail/CVE-2022-3232) #214 #215 credit to [Ambadi MP](https://www.linkedin.com/in/ambadi-m-p-16a95217b/)\n\n## 2.4.4 (2002-09-15)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Use `X-Real-IP` to identify client IP address to mitigate Brute-Force attack #213\n\n## 2.4.3 (2022-09-14)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Mitigate CSRF in profile's SSH Keys [CVE-2022-3221](https://nvd.nist.gov/vuln/detail/CVE-2022-3221) #212 credit to [Ambadi MP](https://www.linkedin.com/in/ambadi-m-p-16a95217b/)\n\n## 2.4.2 (2022-09-12)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Use 'Secure' Attribute with Sensitive Cookie in HTTPS Session. [CVE-2022-3174](https://nvd.nist.gov/vuln/detail/CVE-2022-3174) #209 credit to [Chuu](https://github.com/uonghoangminhchau)\n* Avoid leakage of the stack trace in the default error page. [CVE-2022-3175](https://nvd.nist.gov/vuln/detail/CVE-2022-3175) #210 credit to [Chuu](https://github.com/uonghoangminhchau)\n* Enforce minimum and maximum password length [CVE-2022-3175](https://nvd.nist.gov/vuln/detail/CVE-2022-3179) #211 credit to [Chuu](https://github.com/uonghoangminhchau)\n\n## 2.4.1 (2022-09-08)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Add Clickjacking Defense [CVE-2022-3167](https://nvd.nist.gov/vuln/detail/CVE-2022-3167) credit to [tharunavula](https://github.com/tharunavula)\n* Drop Ubuntu Hirsute & Impish (End-of-life)\n\n## 2.4.0 (2022-06-21)\n\nThis new release brings a lot of improvement since the last version, multiple bug fixes\nto make the application stable. A couple of new features to improve the overall\nusability and a new security feature to block a brute force attack.\n\n* Add RateLimit to login page and API to mitigate robots attacks #167\n* Send email notification only if `email-sender` option is defined to avoid raising exception in logs #176\n* Support file restore cancellation without leaving `rdiffweb-restore` process in `<defunct>` state #174\n* Replace `python-ldap` by `ldap3` a pure python implementation to avoid dependencies on `sasl` and `ldap` binaries #186\n* Reffactor core module to allow better extendability and reusability #183\n* Add support for Debian Bookworm #180\n* Add support for Ubuntu Impish #175\n* Add rdiff-backup version to administration view\n* Run unit test during Debian build package\n* Refresh repository list automatically when required #188 #189\n* Fix error 500 displayed in status page #191\n* Improve repository browsing speed by minimizing the number of I/O call #192\n* Publish Docker image directly to DockerHub #144\n* Add REST API to manage sshkeys\n\nBreaking changes:\n\n* Ldap Password changes is not supported anymore.\n* Ldap Check Shadow expire config is not supported anymore. It should be replace by a custom filter.\n* Drop CentOS 7 and CentOS 8 support\n\n## 2.3.9 (2022-01-05)\n\nMaintenance release to fix minor issues\n\n* Improve date parsing for `backup.log` to avoid printing exception in logs #170\n* Return HTTP error 403 for invalid symlink to avoid returning a misleading HTTP 500 Server Error #168\n* Show a user friendly error message when trying to create a new user with an existing username #169\n* Handle repository without last-backup date during the notification process to ensure notifications are sent #171\n* Replace CherryPy `storage_type` by `storage_class` to avoid warning in logs\n* Update code to avoid deprecation warning where applicable\n* Add Flake8 validation to improve code quality\n* Remove Ubuntu Groovy support\n\n## 2.3.8 (2021-12-01)\n\n* Push all artefacts to nexus server including binaries and documentation\n* Fix `Chart.js` loading on Debian bullseye #164\n* Update installation steps documentation\n* Improve LDAP authentication to lookup entire directory\n* Fix usage of `--ldap-add-user-default-userroot` to avoid error related to wrong encoding\n* Improve authentication mechanics\n* Avoid raising an HTTP error 500 when login form receive invalid payload\n* Mitigate open redirect vulnerability in login form\n\n## 2.3.7 (2021-10-21)\n\n* To avoid backward compatibility issue, revert CSRF Token validation\n* Mitigate CSRF vulnerability using cookies with `SameSite=Lax`\n* Mitigate CSRF vulnerability by validating the `Origin` header when a form is submited\n* Improve usage of WTForm for all form validation\n* Update installation stepd for debian #162\n* Build Ubuntu packages and publish them to our APT repo\n\n## 2.3.6 (2021-10-20)\n\n* Broken build\n\n## 2.3.5 (2021-10-18)\n\n* Mitigate CSRF vulnerability to user, ssh and repo management with CSRF Token\n\n## 2.3.4 (2021-09-20)\n\n* Skip email notification if `email-host` configuration is not provided #157\n* Skip email notification when the new attribute value has the same value #159\n* USE LDAP `mail` attribute when creating new user from LDAP directory #156\n\n## 2.3.3 (2021-09-10)\n\n* Provide a new theme `blue` to match IKUS Soft colors #158\n\n## 2.3.2 (2021-09-07)\n\n* Automatically update user's repository list based on user's home directory\n\n## 2.3.1 (2021-07-14)\n\n* Update default `session-dir` location to `/var/lib/rdiffweb/session` to avoid using `/var/run` #148\n\n## 2.3.0 (2021-07-06)\n\n* Improve timezone handling to display date with local timezone using javascript #143\n* Improve charts by replacing d3js by chartkick #122\n* Replace the status view by something meaningful with chartkick #122\n* Provide Docker image with Rdiffweb `docker pull ikus060/rdiffweb` #55\n* Fix file and folder sorting #143\n\n## 2.2.0 (2021-05-11)\n\n* Debian package:\n  * Add rdiff-backup as dependencies to comply with Debian packaging rules\n  * Multiple other fixed to control files\n  * Use debhelper-compat (= 13)\n  * Use debhelper-compat (= 13)\n  * Run test during packaging\n  * Create default folder `/var/run/rdiffweb/sessions` to store user session\n* Use ConfigArgPare for configuration to support configuration file, environment variables and arguments to configure rdiffweb #114\n* Fix cache in localization module\n* Add `ldap-add-default-role` and `ldap-add-default-userroot` option to define default value for role and user root when creating user from LDAP #125\n* Support PostgreSQL database by replacing our storage layer by SQLAlchemy #126\n* Fix to retrieve user quota only for valid user_root #135\n* Add option `disable-ssh-keys` to disable SSH Key management\n* Use absolute URL everywhere\n* Add support for `X-Forwarded-For`, `X-Forwarded-proto` and other reverse proxy header when generating absolute URL\n* Drop Debian Stretch support\n* Implement a new background scheduler using apscheduler #82\n* Use background job to send email notification to avoid blocking web page loading #47\n* Use background job to delete repository to avoid blocking web page loading #48\n* Allow deleting a specific file or folder from the history using `rdiff-backup-delete` #128\n* Improve support for `session-dir` #131\n* Add option `admin-password` to define administrator password for better security\n* Improve performance of repository browsing\n* Add a new view to display logs of a specific repository\n* Allow downloading the log\n* Define a default limit to graph statistics to make it display faster\n* Fix `get-quota-cmd` option to properly return a value\n\n## 2.1.0 (2021-01-15)\n\n* Debian package: Remove dh-systemd from Debian build dependencies (https://bugs.debian.org/871312we)\n* Improve Quota management:\n  * `QuotaSetCmd`, `QuotaGetCmd` and `QuotaUsedCmd` options could be used to customize how to set the quota for your environment.\n  * Display user's quota in User View\n  * Display user's quota in Admin View\n  * Allow admin to update user quota from Admin View when `QuotaSetCmd` is defined.\n  * Allow admin to define user quota using human readable value (e.g.: GiB, TiB, etc.)\n  * Improve logging around quota management\n* Improve robustness when service is starting\n* Improve robustness when repository has wrong permission defined (e.g.: when some files not readable)\n* Add user id in Admin view\n* Replace `UserObject(1)` by the actual username in log file to improve debugging\n\n## 2.0.0 (2020-12-04)\n\n* Re-implement logic to update repositories views to remove duplicates and avoid nesting repo. #107\n* Handle elapsed time of days in the graph. Thanks [Nathaniel van Diepen](https://github.com/Eeems) contributions.\n* Rebrand all link to ikus-soft.com\n* Update documentation to install rdiffweb\n* Remove obsolete minify dependency\n* Drop support for python2\n* Provide null translation if translation catalogues are not found\n* Pass a LANG environment variable to rdiff-backup restore process to fix encoding issue #112\n* Remove obsolete python shebang\n* Remove execution bit (+x) on python modules\n* Provide `--help` and `--version` on `rdiffweb` executable\n* Improve cherrypy version detection\n* Do not update translation files (.mo) during build\n\n## 1.5.0 (2020-06-24)\n\nThis minor release introduce official support of rdiffweb on Debian Bullseye. It also includes some usability improvements.\n\n* Change formatting of Last Backup date for \"Updated 3 weeks ago\" to ease the readability\n* Add support for Debian Bullseye\n* Add support for Python 3.8 (#104)\n* Add warning in the users list view when a root directory is invalid (#30)\n* Add options to control search depthness (#1)\n* Print a warning in the log when the \"DefaultTheme\" value is not valid (#90)\n\n## 1.4.0 (2020-05-20)\n\nThanks to our sponsor, this release introduce a feature to have better control over the user's permission by defining 3 different levels of privilege: Admin, Maintainer and User. This addition allows you to have better control on what your users can or can't do.\n\n* Fix single repository discovery when a user's home is a rdiff-backup repository\n* [SPONSORED] Add a new setting at the user level to define the user's role. Admin,\n   Maintainer and User. Admin are allowed to do everything. Maintainer are\n   allow to browse and delete repo. Users are only allowed to browse. #94\n* Add \"Powered by\" in the web interface footer #91\n* Display a nice error message when trying to delete admin user #93\n* Introduce usage of wtforms and flash in admin users for better form validation. #96 #97\n* Update French translation\n\n## 1.3.2 (2020-04-23)\n\nThis minor releases fixed issues found while testing release 1.3.0.\n\n* Fix lookup of executable rdiff-backup and rdiffweb-restore to search in current virtualenv first\n* Fix repository view when multiple repo path are conflicting\n* Fix logging of rdiffweb-restore subprocess\n\n## 1.3.1 (2020-04-10)\n\nThis minor release enforces security of the password stored in rdiffweb database to make use of a better encryption using SSHA.\nOnly new passwords will make use of the SSHA scheme.\n\n* Enforce password encryption by using SSHA scheme #88\n\n## 1.3.0 (2020-04-07)\n\nThis release focuses on improving the restore of big archives. The download should be much faster to start. Major enhancement was made to offload the processing outside the web server. And all of this is still compatible with rdiff-backup v1.2.8 and the latest v2.0.0.\n\n* Restore file and folder in a subprocess to make the download start faster\n* Fix encoding of archive on Python3.6 (CentOS 7) by using PAX format\n* Add support to restore files and folders using rdiff-backup2\n* Remove obsolete dependencies `pysqlite2`\n* Fix issue creating duplicate entries of repository in the database\n\n## 1.2.2 (2020-03-05)\n\nThis release provides little improvement to the v1.2.x including official support of rdiff-backup v2.0.0.\n\n* Enhance the repository to invite users to refresh the repository when the view is empty.\n* Support rdiff-backup v2.0.0\n* Deprecate support for cherrypy 4, 5, 6 and 7\n* Improve loading of repository data (cache status and entries)\n* Restore compatibility with SQLite 3.7 (CentOS7)\n\nKnown issues:\n\n* Filename encoding in tar.gz and zip file might not be accurate if you are running Python 3.6 (CentOS7)\n\n## 1.2.1 (2020-02-08)\n\nLittle bug fix following the previous release\n\n* Fix 404 error when trying to access other users repo as admin\n* Fix logging format for cherrypy logs to matches rdiffweb format\n* Add log rotation by default\n\n## 1.2.0 (2020-01-30)\n\nThis release focus on improving the database layers for better extendability to add more type of data and to support more databases backend like postgresql in the near future.\n\n* Add explicit testing for Debian Stretch & Buster\n* Change the persistence layers\n  * Minimize number of SQL queries\n  * Add object lazy loading\n  * Add object data caching\n* Fix bugs with SQLite <= 3.16 (Debian Stretch)\n\n## 1.1.0 (2019-10-31)\n\nThis release focus on improving the admin area and building the fundation for repository access control list (ACL).\n\n* Update documentation from PDSL web site\n* Improve the navigation bar layout\n* Update the login page headline\n* Update jinja2 version to allow 2.10.x\n* Show server log in admin area\n* Reduce code smell\n* Add System information in admin area\n* Validate credential using local database before LDAP\n* Reffactoring templates macros\n* Enhance user's view search bar\n* Change repository URL to username/repopath\n* Add System information in admin area\n* Improve testcases\n* Clean-up obsolete code\n* Fix issue with captital case encoding name\n* Fix compilation of less files\n* Fix google font import\n\n## 1.0.3 (2019-10-04)\n\n* Removing the auto update repos\n\n## 1.0.2 (2019-10-01)\n\n* Create \"admin\" user if missing\n* Update french translation\n\n## 1.0.1 (2019-09-22)\n\n* Update installation documentation\n* Fix removal of SSH Key\n* Return meaningful error to the user trying to add an existing SSH key\n\n## 1.0.0 (2019-09-11)\n\n* Make repository removal more robust\n* Improve performance of librdiff\n* Add new RESTful api\n* Return the right HTTP 401 or 402 error code for authentication\n* Fix bug introduce by upgrade to Jinja2 + python3\n* Store ssh keys in database and disk\n* Add support for theme (default, orange)\n* Remove deprecated profiling code\n* Add disk usage support / quota\n* Add support of cherrypy v18\n* Drop support of cherrypy v3.2.2\n* Add wsgi entry point\n* Replace the plugins architecture to ease implementation\n* Numerous bug fixes\n\n## 0.10.9 (2019-05-22)\n\n* Better error handling when error.log file are not valid gzip file\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nCreated on Dec 26, 2015\n\n@author: Patrik Dufresne\n\"\"\"\nimport os\n\nfrom parameterized import parameterized, parameterized_class\n\nimport rdiffweb.test\nfrom rdiffweb.core.model import DbSession, SessionObject, UserObject\nfrom rdiffweb.tools.auth_form import LOGIN_TIME, SESSION_KEY\n\n\nclass LoginPageTest(rdiffweb.test.WebCase):\n    def test_getpage(self):\n        # When making a query to a page while unauthenticated\n        self.getPage('/')\n        # Then user is redirected to login page\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/login/')\n        # Then a session object is created without a username\n        self.assertEqual(1, SessionObject.query.filter(SessionObject.id == self.session_id).count())\n        SessionObject.query.filter(SessionObject.id == self.session_id).first()\n        session = DbSession(id=self.session_id)\n        session.load()\n        self.assertIsNone(session.get(SESSION_KEY))\n\n    def test_login_success(self):\n        # Given an anonymous user\n        self.getPage('/')\n        prev_session_id = self.session_id\n        # Then user is redirected to /login page\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/login/')\n        # When authenticating with valid credentials.\n        self.getPage('/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD})\n        # Then a new session_id is generated\n        self.assertNotEqual(prev_session_id, self.session_id)\n        # Then user is redirected\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/')\n        # Then a session object is created with a username\n        self.assertEqual(1, SessionObject.query.filter(SessionObject.id == self.session_id).count())\n        SessionObject.query.filter(SessionObject.id == self.session_id).first()\n        session = DbSession(id=self.session_id)\n        session.load()\n        self.assertEqual('admin', session.get(SESSION_KEY))\n        self.assertIsNotNone(session.get(LOGIN_TIME))\n\n    def test_cookie_http_only(self):\n        # Given a request made to rdiffweb\n        # When receiving the response\n        self.getPage('/')\n        # Then the header contains Set-Cookie with HttpOnly\n        cookie = self.assertHeader('Set-Cookie')\n        self.assertIn('HttpOnly', cookie)\n\n    def test_login_with_plaintext(self):\n        \"\"\"\n        Requesting plain text without being authenticated should show the login form.\n        \"\"\"\n        # When querying root page without authentication\n        self.getPage('/', headers=[(\"Accept\", \"text/plain\")])\n        # Then user is redirected to /login page\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/login/')\n\n    @parameterized.expand(\n        [\n            ('with_root', '/'),\n            ('with_browse_url', '/browse/admin/testcases/Revisions/'),\n            ('with_encoded_url', '/browse/admin/testcases/DIR%EF%BF%BD/'),\n            (\n                'with_broken_encoding',\n                '/restore/admin/testcases/Fichier%20avec%20non%20asci%20char%20%C9velyne%20M%E8re.txt/?date=1415221507',\n            ),\n            ('with_query_string', '/restore/admin/testcases/Revisions?date=1477434528'),\n            ('with_multiple_query_string', '/restore/admin/testcases/Revisions?date=1477434528&kind=tar.gz'),\n            ('with_admin', '/admin/'),\n        ]\n    )\n    def test_login(self, unused, original_url):\n        # Given an unauthenticated user\n        # Query the page without login-in\n        self.getPage(original_url)\n        # Then user is redirected to the login page\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/login/')\n        # When authentication is successful\n        self.getPage('/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD})\n        # Then user is redirected to original URL\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + original_url)\n        # Then cookie is not persistent\n        self.assertNotIn('expires', self.cookies[0][1])\n        self.assertNotIn('Max-Age', self.cookies[0][1])\n        # When requesting the original page\n        self.getPage(original_url)\n        # Then page return without error\n        self.assertStatus(200)\n\n    def test_getpage_with_redirect_post(self):\n        \"\"\"\n        Check encoding of redirect url when send using POST method.\n        \"\"\"\n        # When posting invalid credentials\n        b = {'login': 'admin', 'password': 'invalid', 'redirect': '/browse/' + self.REPO + '/DIR%EF%BF%BD/'}\n        self.getPage('/login/', method='POST', body=b)\n        # Then page return without HTTP Error\n        self.assertStatus('200 OK')\n        # Then page display an error\n        self.assertInBody('Invalid username or password.')\n        self.assertInBody('form-login')\n        # Then redirect URL is ignored\n        self.assertNotInBody('/browse/' + self.REPO + '/DIR%EF%BF%BD/\"')\n\n    def test_getpage_without_username(self):\n        \"\"\"\n        Check if error is raised when requesting /login without a username.\n        \"\"\"\n        self.getPage('/login/', method='GET')\n        self.assertStatus('200 OK')\n\n    def test_getpage_with_username_too_long(self):\n        b = {'login': 'admin' * 52, 'password': 'admin123'}\n        self.getPage('/login/', method='POST', body=b)\n        self.assertStatus('200 OK')\n        self.assertInBody('Username too long.')\n\n    def test_getpage_with_empty_password(self):\n        \"\"\"\n        Check if authentication is failing without a password.\n        \"\"\"\n        b = {'login': 'admin', 'password': ''}\n        self.getPage('/login/', method='POST', body=b)\n        self.assertStatus('200 OK')\n        self.assertInBody('This field is required.')\n\n    def test_getpage_with_invalid_url(self):\n        self.getPage('/login/kefuxian.mvc', method='GET')\n        self.assertStatus('303 See Other')\n\n    def test_post_with_invalid_url(self):\n        self.getPage('/login/kefuxian.mvc', method='POST')\n        self.assertStatus('303 See Other')\n\n    def test_login_twice(self):\n        # Given an authenticated user\n        self.getPage('/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD})\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + \"/\")\n        self.getPage('/')\n        self.assertStatus(200)\n        self.assertInBody(self.USERNAME)\n        # Given another user\n        userobj = UserObject.add_user('otheruser', password='password')\n        userobj.commit()\n        # When trying to re-authenticated with login page\n        self.getPage('/login/', method='POST', body={'login': 'otheruser', 'password': 'password'})\n        # Then user is still authenticated with previous user\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + \"/\")\n        self.getPage('/')\n        self.assertStatus(200)\n        self.assertInBody(self.USERNAME)\n\n    def test_login_persistent(self):\n        # Given a user authenticated with persistent\n        self.getPage('/logout', method=\"POST\")\n        self.assertStatus(303)\n        self.getPage(\n            '/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD, 'persistent': '1'}\n        )\n        self.assertStatus(303)\n        # Then a persistent cookie is return\n        self.assertIn('expires', self.cookies[0][1])\n        self.assertIn('Max-Age', self.cookies[0][1])\n        # Then a session is created with persistent flag\n        session = DbSession(id=self.session_id)\n        session.load()\n        self.assertTrue(session['login_persistent'])\n        # Then session timeout is 30 days in future\n        self.assertAlmostEqual(session.timeout, 43200, delta=2)\n\n\nclass LoginPageWithWelcomeMsgTest(rdiffweb.test.WebCase):\n\n    default_config = {'welcomemsg': 'default message', 'welcomemsg[fr]': 'french message'}\n\n    def test_getpage_default(self):\n        \"\"\"\n        Make sure the login page can be rendered without error.\n        \"\"\"\n        self.getPage('/login/', headers=[(\"Accept-Language\", \"it\")])\n        self.assertStatus('200 OK')\n        self.assertInBody('default message')\n\n    def test_getpage_french(self):\n        \"\"\"\n        Make sure the login page can be rendered without error.\n        \"\"\"\n        self.getPage('/login/', headers=[(\"Accept-Language\", \"fr\")])\n        self.assertStatus('200 OK')\n        self.assertInBody('french message')\n\n\nclass LoginPageWithHeaderName(rdiffweb.test.WebCase):\n\n    default_config = {'header-name': 'HEADER-NAME'}\n\n    def test_getpage_default(self):\n        # Given a custom header-name\n        # When querying the loging page\n        self.getPage('/login/')\n        # Then the page display the header-name\n        self.assertStatus('200 OK')\n        self.assertInBody('HEADER-NAME')\n\n\n@parameterized_class(\n    [\n        {\"default_config\": {'rate-limit': 5}},\n        {\"default_config\": {'rate-limit': 5, 'rate-limit-dir': '/tmp'}},\n    ]\n)\nclass LoginPageRateLimitTest(rdiffweb.test.WebCase):\n    def setUp(self):\n        if os.path.isfile('/tmp/ratelimit-127.0.0.1'):\n            os.unlink('/tmp/ratelimit-127.0.0.1')\n        if os.path.isfile('/tmp/ratelimit-127.0.0.1.-login'):\n            os.unlink('/tmp/ratelimit-127.0.0.1.-login')\n        return super().setUp()\n\n    def test_login_ratelimit(self):\n        # Given an unauthenticate\n        # When requesting multiple time the login page\n        for i in range(1, 5):\n            self.getPage('/login/', method='POST', body={'login': 'invalid', 'password': 'invalid'})\n            self.assertStatus(200)\n        # Then a 429 error (too many request) is return\n        self.getPage('/login/', method='POST', body={'login': 'invalid', 'password': 'invalid'})\n        self.assertStatus(429)\n\n\nclass LoginPageRateLimitTest2(rdiffweb.test.WebCase):\n\n    default_config = {'rate-limit': 5}\n\n    def test_login_ratelimit_forwarded_for(self):\n        # Given an unauthenticate\n        # When requesting multiple time the login page with different `X-Forwarded-For`\n        for i in range(1, 5):\n            self.getPage(\n                '/login/',\n                headers=[('X-Forwarded-For', '127.0.0.%s' % i)],\n                method='POST',\n                body={'login': 'invalid', 'password': 'invalid'},\n            )\n            self.assertStatus(200)\n        # Then original IP get blocked\n        self.getPage(\n            '/login/',\n            headers=[('X-Forwarded-For', '127.0.0.%s' % i)],\n            method='POST',\n            body={'login': 'invalid', 'password': 'invalid'},\n        )\n        self.assertStatus(429)\n\n\nclass LoginPageRateLimitTest3(rdiffweb.test.WebCase):\n    default_config = {'rate-limit': 5}\n\n    def test_login_ratelimit_real_ip(self):\n        # Given an unauthenticate\n        # When requesting multiple time the login page with different `X-Real-IP`\n        for i in range(1, 5):\n            self.getPage(\n                '/login/',\n                headers=[('X-Real-IP', '127.0.0.128')],\n                method='POST',\n                body={'login': 'invalid', 'password': 'invalid'},\n            )\n            self.assertStatus(200)\n        # Then the X-Real-IP get blocked\n        self.getPage(\n            '/login/',\n            headers=[('X-Real-IP', '127.0.0.128')],\n            method='POST',\n            body={'login': 'invalid', 'password': 'invalid'},\n        )\n        self.assertStatus(429)\n\n\nclass LogoutPageTest(rdiffweb.test.WebCase):\n    def test_getpage_without_login(self):\n        # Given an unauthenticated user\n        # When Accessing logout page directly\n        self.getPage('/logout', method=\"POST\")\n        # Then user is redirect to root '/'\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/')\n\n    def test_getpage_with_login(self):\n        # Given an anonymous user\n        self.getPage('/')\n        prev_session_id = self.session_id\n        # Login\n        b = {'login': 'admin', 'password': 'admin123'}\n        self.getPage('/login/', method='POST', body=b)\n        self.assertStatus('303 See Other')\n        # Then a new session id is generated\n        self.assertNotEqual(prev_session_id, self.session_id)\n        prev_session_id = self.session_id\n        # Get content of a page.\n        self.getPage(\"/prefs/general\")\n        self.assertStatus('200 OK')\n        # When logout\n        self.getPage('/logout', method=\"POST\")\n        # Then a new session id is generated\n        self.assertNotEqual(prev_session_id, self.session_id)\n        # Then user is redirected to root page\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/')\n        # Get content of a page.\n        self.getPage(\"/prefs/general\")\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/login/')\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nCreated on Dec 26, 2015\n\n@author: Patrik Dufresne\n\"\"\"\n\nfrom unittest.mock import MagicMock\n\nimport cherrypy\nfrom parameterized import parameterized\n\nimport rdiffweb.test\nfrom rdiffweb.core.model import RepoObject, SessionObject, UserObject\n\n\nclass PagePrefGeneralTest(rdiffweb.test.WebCase):\n\n    PREFS = \"/prefs/general\"\n\n    login = True\n\n    def setUp(self):\n        self.listener = MagicMock()\n        cherrypy.engine.subscribe('user_password_changed', self.listener.user_password_changed, priority=50)\n        return super().setUp()\n\n    def tearDown(self):\n        cherrypy.engine.unsubscribe('user_password_changed', self.listener.user_password_changed)\n        return super().tearDown()\n\n    def _set_password(\n        self,\n        current,\n        new_password,\n        confirm,\n    ):\n        b = {\n            'action': 'set_password',\n            'current': current,\n            'new': new_password,\n            'confirm': confirm,\n        }\n        return self.getPage(self.PREFS, method='POST', body=b)\n\n    def _set_profile_info(self, email, fullname=None):\n        b = {\n            'action': 'set_profile_info',\n            'email': email,\n        }\n        if fullname:\n            b['fullname'] = fullname\n        return self.getPage(self.PREFS, method='POST', body=b)\n\n    def test_get_page(self):\n        # When querying the page\n        self.getPage(self.PREFS)\n        # Then the page is returned\n        self.assertStatus(200)\n        self.assertInBody('User profile')\n\n    def test_change_username_noop(self):\n        # Given an authenticated user\n        # When updating the username\n        self.getPage(\n            self.PREFS,\n            method='POST',\n            body={'action': 'set_profile_info', 'email': 'test@test.com', 'username': 'test'},\n        )\n        self.assertStatus(303)\n        self.getPage(self.PREFS)\n        self.assertInBody(\"Profile updated successfully.\")\n        # Then database is updated with fullname\n        user = UserObject.query.filter(UserObject.username == self.USERNAME).first()\n        self.assertIsNotNone(user)\n        self.assertEqual(\"test@test.com\", user.email)\n\n    @parameterized.expand(\n        [\n            # Invalid\n            ('@test.com', False),\n            ('test.com', False),\n            ('test@te_st.com', False),\n            ('test@test.com, test2@test.com', False),\n            # Valid\n            ('test', True),\n            ('My Fullname', True),\n        ]\n    )\n    def test_change_fullname(self, new_fullname, expected_valid):\n        # Given an authenticated user\n        # When update the fullname\n        self._set_profile_info(\"test@test.com\", new_fullname)\n        if expected_valid:\n            self.assertStatus(303)\n            self.getPage(self.PREFS)\n            self.assertInBody(\"Profile updated successfully.\")\n            # Then database is updated with fullname\n            self.assertInBody(new_fullname)\n            user = UserObject.query.filter(UserObject.username == self.USERNAME).first()\n            self.assertEqual(new_fullname, user.fullname)\n        else:\n            self.assertStatus(200)\n            self.assertNotInBody(\"Profile updated successfully.\")\n\n    def test_change_fullname_method_get(self):\n        # Given an authenticated user\n        # When trying to update full name using GET method\n        self.getPage(self.PREFS + '?action=set_profile_info&email=test@test.com')\n        # Then nothing happen\n        self.assertStatus(200)\n        self.assertNotInBody(\"Profile updated successfully.\")\n        user = UserObject.query.filter(UserObject.username == self.USERNAME).first()\n        self.assertEqual(\"\", user.fullname)\n\n    def test_change_fullname_too_long(self):\n        # Given an authenticated user\n        # When update the fullname\n        self._set_profile_info(\"test@test.com\", \"Fullname\" * 50)\n        # Then page return with error message\n        self.assertStatus(200)\n        self.assertNotInBody(\"Profile updated successfully.\")\n        self.assertInBody(\"Fullname too long.\")\n        # Then database is not updated\n        user = UserObject.query.filter(UserObject.username == self.USERNAME).first()\n        self.assertEqual(\"\", user.fullname)\n\n    def test_change_email(self):\n        self._set_profile_info(\"test@test.com\")\n        self.assertStatus(303)\n        self.getPage(self.PREFS)\n        self.assertInBody(\"Profile updated successfully.\")\n\n    @parameterized.expand(\n        [\n            # Invalid\n            ('@test.com', False),\n            ('test.com', False),\n            ('test', False),\n            ('test@te_st.com', False),\n            ('test@test.com, test2@test.com', False),\n            # Valid\n            ('test@test.com', True),\n        ]\n    )\n    def test_change_email_with_invalid_email(self, new_email, expected_valid):\n        self._set_profile_info(new_email)\n        if expected_valid:\n            self.assertStatus(303)\n            self.getPage(self.PREFS)\n            self.assertInBody(\"Profile updated successfully.\")\n            self.assertNotInBody(\"Must be a valid email address.\")\n        else:\n            self.assertStatus(200)\n            self.assertNotInBody(\"Profile updated successfully.\")\n            self.assertInBody(\"Must be a valid email address.\")\n\n    def test_change_email_with_too_long(self):\n        self._set_profile_info((\"test1\" * 50) + \"@test.com\")\n        self.assertInBody(\"Email too long.\")\n\n    def test_change_password(self):\n        # Given a user with 3 active sessions\n        self.cookies = None\n        self._login(self.USERNAME, self.PASSWORD)\n        self.cookies = None\n        self._login(self.USERNAME, self.PASSWORD)\n        self.assertEqual(3, SessionObject.query.count())\n        # When udating user's password\n        self.listener.user_password_changed.reset_mock()\n        self._set_password(self.PASSWORD, \"pr3j5Dwi\", \"pr3j5Dwi\")\n        # Then user is redirect to same page\n        self.assertStatus(303)\n        # Then the page return success message.\n        self.getPage(self.PREFS)\n        self.assertInBody(\"Password updated successfully.\")\n        # Then a notification is raised\n        self.listener.user_password_changed.assert_called_once()\n        # Then all users session get deleted except our own session.\n        self.assertEqual(1, SessionObject.query.count())\n        self.assertEqual(self.session_id, SessionObject.query.first().id)\n\n    def test_change_password_with_wrong_confirmation(self):\n        self._set_password(self.PASSWORD, \"t\", \"a\")\n        self.assertInBody(\"The new password and its confirmation do not match.\")\n\n    def test_change_password_with_wrong_password(self):\n        self._set_password(\"oups\", \"pr3j5Dwi\", \"pr3j5Dwi\")\n        self.assertInBody(\"Wrong current password\")\n\n    def test_change_password_with_too_short(self):\n        self._set_password(self.PASSWORD, \"short\", \"short\")\n        self.assertInBody(\"Password must have between 8 and 128 characters.\")\n\n    def test_change_password_with_too_long(self):\n        new_password = 'a' * 129\n        self._set_password(self.PASSWORD, new_password, new_password)\n        self.assertInBody(\"Password must have between 8 and 128 characters.\")\n\n    def test_change_password_with_same_value(self):\n        # Given a user with a password\n        self._set_password(self.PASSWORD, \"pr3j5Dwi\", \"pr3j5Dwi\")\n        self.assertStatus(303)\n        # When updating the pasword with the same password\n        self._set_password(\"pr3j5Dwi\", \"pr3j5Dwi\", \"pr3j5Dwi\")\n        self.assertStatus(200)\n        # Then an error should be displayed\n        self.assertInBody(\"The new password must be different from the current password.\")\n\n    def test_change_password_method_get(self):\n        # Given an authenticated user\n        # Trying to update password with GET method\n        self.getPage(self.PREFS + '?action=set_password&new=pr3j5Dwi&confirm=pr3j5Dwi&current=' + self.PASSWORD)\n        # Then nothing happen\n        self.assertStatus(200)\n        self.assertNotInBody(\"Password updated successfully.\")\n\n    def test_invalid_pref(self):\n        \"\"\"\n        Check if invalid prefs url is 404 Not Found.\n        \"\"\"\n        self.getPage(\"/prefs/invalid/\")\n        self.assertStatus(404)\n\n    def test_update_repos(self):\n        # Given a user with invalid repositories\n        userobj = UserObject.get_user(self.USERNAME)\n        RepoObject(userid=userobj.userid, repopath='invalid').add().commit()\n        self.assertEqual(['broker-repo', 'invalid', 'testcases'], sorted([r.name for r in userobj.repo_objs]))\n        # When updating the repository list\n        self.getPage(self.PREFS, method='POST', body={'action': 'update_repos'})\n        self.assertStatus(200)\n        # Then a success message is displayed\n        self.assertInBody('Repositories successfully updated')\n        # Then the list is free of inexisting repos.\n        userobj.expire()\n        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in userobj.repo_objs]))\n\n\nclass PagePrefGeneralRateLimitTest(rdiffweb.test.WebCase):\n    login = True\n\n    default_config = {'rate-limit': 5}\n\n    def test_change_password_too_many_attemps(self):\n        # When udating user's password with wrong current password 5 times\n        for _i in range(1, 5):\n            self.getPage(\n                '/prefs/general',\n                method='POST',\n                body={'action': 'set_password', 'current': 'wrong', 'new': 'pr3j5Dwi', 'confirm': 'pr3j5Dwi'},\n            )\n            self.assertStatus(200)\n            self.assertInBody(\"Wrong current password.\")\n        # Then user session is cleared and user is redirect to login page\n        self.getPage(\n            '/prefs/general',\n            method='POST',\n            body={'action': 'set_password', 'current': 'wrong', 'new': 'pr3j5Dwi', 'confirm': 'pr3j5Dwi'},\n        )\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + '/')\n        # Then a warning message is displayed on login page\n        self.getPage('/login/')\n        self.assertStatus(200)\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport logging\n\nimport cherrypy\nfrom cherrypy.process.plugins import SimplePlugin\n\nfrom rdiffweb.core.model import UserObject\n\nlogger = logging.getLogger(__name__)\n\n\nclass LoginPlugin(SimplePlugin):\n    \"\"\"\n    This plugins register an \"authenticate\" listener to validate\n    username and password of users. In addition, it provide a \"login\"\n    listener to authenticate and possibly create the user in database.\n    \"\"\"\n\n    add_missing_user = False\n    add_user_default_role = UserObject.USER_ROLE\n    add_user_default_userroot = None\n\n    def start(self):\n        self.bus.log('Start Login plugin')\n        self.bus.subscribe(\"authenticate\", self.authenticate)\n        self.bus.subscribe(\"login\", self.login)\n\n    def stop(self):\n        self.bus.log('Stop Login plugin')\n        self.bus.unsubscribe(\"authenticate\", self.authenticate)\n        self.bus.unsubscribe(\"login\", self.login)\n\n    def authenticate(self, username, password):\n        \"\"\"\n        Only verify the user's credentials using the database store.\n        \"\"\"\n        user = UserObject.query.filter_by(username=username).first()\n        if user and user.validate_password(password):\n            return username, {}\n        return False\n\n    def login(self, username, password):\n        \"\"\"\n        Validate username password using database and LDAP.\n        \"\"\"\n        # Validate credentials.\n        authenticates = self.bus.publish('authenticate', username, password)\n        authenticates = [a for a in authenticates if a]\n        if not authenticates:\n            return None\n        real_username = authenticates[0][0]\n        extra_attrs = authenticates[0][1]\n        fullname = extra_attrs.get('_fullname', None)\n        email = extra_attrs.get('_email', None)\n        # When enabled, create missing userobj in database.\n        userobj = UserObject.query.filter_by(username=username).first()\n        if userobj is None and self.add_missing_user:\n            try:\n                # At this point, we need to create a new user in database.\n                # In case default values are invalid, let evaluate them\n                # before creating the user in database.\n                default_user_root = self.add_user_default_userroot and self.add_user_default_userroot.format(\n                    **extra_attrs\n                )\n                default_role = UserObject.ROLES.get(self.add_user_default_role)\n                userobj = UserObject.add_user(\n                    username=real_username,\n                    fullname=fullname,\n                    email=email,\n                    role=default_role,\n                    user_root=default_user_root,\n                ).commit()\n            except Exception:\n                logger.error('fail to create new user', exc_info=1)\n        if userobj is None:\n            # User doesn't exists in database\n            return None\n\n        # Update user attributes\n        dirty = False\n        if fullname:\n            userobj.fullname = fullname\n            dirty = True\n        if email:\n            userobj.email = email\n            dirty = True\n        if dirty:\n            userobj.commit()\n        self.bus.publish('user_login', userobj)\n        return userobj\n\n\ncherrypy.login = LoginPlugin(cherrypy.engine)\ncherrypy.login.subscribe()\n\ncherrypy.config.namespaces['login'] = lambda key, value: setattr(cherrypy.login, key, value)\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport cherrypy\nfrom sqlalchemy import event\n\nfrom ._repo import RepoObject  # noqa\nfrom ._session import DbSession, SessionObject  # noqa\nfrom ._sshkey import SshKey  # noqa\nfrom ._token import Token  # noqa\nfrom ._user import DuplicateSSHKeyError, UserObject  # noqa\n\nBase = cherrypy.tools.db.get_base()\n\n\n@event.listens_for(Base.metadata, 'after_create')\ndef db_after_create(target, connection, **kw):\n    \"\"\"\n    Called on database creation to update database schema.\n    \"\"\"\n\n    def exists(column):\n        table_name = column.table.fullname\n        column_name = column.name\n        if 'SQLite' in connection.engine.dialect.__class__.__name__:\n            sql = \"SELECT COUNT(*) FROM pragma_table_info('%s') WHERE LOWER(name)=LOWER('%s')\" % (\n                table_name,\n                column_name,\n            )\n        else:\n            sql = \"SELECT COUNT(*) FROM information_schema.columns WHERE table_name='%s' and column_name='%s'\" % (\n                table_name,\n                column_name,\n            )\n        data = connection.engine.execute(sql).first()\n        return data[0] >= 1\n\n    def add_column(column):\n        if exists(column):\n            return\n        table_name = column.table.fullname\n        column_name = column.name\n        column_type = column.type.compile(connection.engine.dialect)\n        connection.engine.execute('ALTER TABLE %s ADD COLUMN %s %s' % (table_name, column_name, column_type))\n\n    if getattr(connection, '_transaction', None):\n        connection._transaction.commit()\n\n    # Add repo's Encoding\n    add_column(RepoObject.__table__.c.Encoding)\n    add_column(RepoObject.__table__.c.keepdays)\n\n    # Create column for roles using \"isadmin\" column. Keep the\n    # original column in case we need to revert to previous version.\n    if not exists(UserObject.__table__.c.role):\n        add_column(UserObject.__table__.c.role)\n        UserObject.query.filter(UserObject._is_admin == 1).update({UserObject.role: UserObject.ADMIN_ROLE})\n\n    # Add user's fullname column\n    add_column(UserObject.__table__.c.fullname)\n\n    # Add user's mfa column\n    add_column(UserObject.__table__.c.mfa)\n\n    # Re-create session table if Number column is missing\n    if not exists(SessionObject.__table__.c.Number):\n        SessionObject.__table__.drop()\n        SessionObject.__table__.create()\n\n    if getattr(connection, '_transaction', None):\n        connection._transaction.commit()\n    # Remove preceding and leading slash (/) generated by previous\n    # versions. Also rename '.' to ''\n    result = RepoObject.query.all()\n    for row in result:\n        if row.repopath.startswith('/') or row.repopath.endswith('/'):\n            row.repopath = row.repopath.strip('/')\n            row.commit()\n        if row.repopath == '.':\n            row.repopath = ''\n            row.commit()\n    # Remove duplicates and nested repositories.\n    result = RepoObject.query.order_by(RepoObject.userid, RepoObject.repopath).all()\n    prev_repo = (None, None)\n    for row in result:\n        if prev_repo[0] == row.userid and (prev_repo[1] == row.repopath or row.repopath.startswith(prev_repo[1] + '/')):\n            row.delete()\n        else:\n            prev_repo = (row.userid, row.repopath)\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\nimport logging\nimport os\nimport secrets\nimport string\n\nimport cherrypy\nfrom sqlalchemy import Column, Integer, SmallInteger, String, and_, event, inspect, or_\nfrom sqlalchemy.exc import IntegrityError\nfrom sqlalchemy.ext.hybrid import hybrid_property\nfrom sqlalchemy.orm import deferred, relationship, validates\nfrom zxcvbn import zxcvbn\n\nimport rdiffweb.tools.db  # noqa\nfrom rdiffweb.core import authorizedkeys\nfrom rdiffweb.core.passwd import check_password, hash_password\nfrom rdiffweb.tools.i18n import ugettext as _\n\nfrom ._repo import RepoObject\nfrom ._session import SessionObject\nfrom ._sshkey import SshKey\nfrom ._token import Token\n\nlogger = logging.getLogger(__name__)\n\nBase = cherrypy.tools.db.get_base()\n\nSEP = b'/'\n\n\nclass DuplicateSSHKeyError(Exception):\n    \"\"\"\n    Raised by add_authorizedkey when trying to add the same SSH Key twice.\n    \"\"\"\n\n    pass\n\n\nclass UserObject(Base):\n    __tablename__ = 'users'\n    __table_args__ = {'sqlite_autoincrement': True}\n\n    # Value for role.\n    ADMIN_ROLE = 0\n    MAINTAINER_ROLE = 5\n    USER_ROLE = 10\n    ROLES = {\n        'admin': ADMIN_ROLE,\n        'maintainer': MAINTAINER_ROLE,\n        'user': USER_ROLE,\n    }\n    # Value for mfa field\n    DISABLED_MFA = 0\n    ENABLED_MFA = 1\n\n    # Regex pattern to be used for validation.\n    PATTERN_EMAIL = r\"[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}$\"\n    PATTERN_FULLNAME = r\"\"\"[^!\"#$%&()*+,./:;<=>?@[\\]_{|}~]+$\"\"\"\n    PATTERN_USERNAME = r\"[a-zA-Z0-9_.\\-]+$\"\n\n    userid = Column('UserID', Integer, primary_key=True)\n    username = Column('Username', String, nullable=False, unique=True)\n    hash_password = Column('Password', String, nullable=False, default=\"\")\n    user_root = Column('UserRoot', String, nullable=False, default=\"\")\n    _is_admin = deferred(\n        Column(\n            'IsAdmin',\n            SmallInteger,\n            nullable=False,\n            server_default=\"0\",\n            doc=\"DEPRECATED This column is replaced by 'role'\",\n        )\n    )\n    email = Column('UserEmail', String, nullable=False, default=\"\")\n    restore_format = deferred(\n        Column(\n            'RestoreFormat',\n            SmallInteger,\n            nullable=False,\n            server_default=\"1\",\n            doc=\"DEPRECATED This column is not used anymore\",\n        )\n    )\n    role = Column('role', SmallInteger, nullable=False, server_default=str(USER_ROLE), default=USER_ROLE)\n    fullname = Column('fullname', String, nullable=False, default=\"\")\n    mfa = Column('mfa', SmallInteger, nullable=False, default=DISABLED_MFA)\n    repo_objs = relationship(\n        'RepoObject',\n        foreign_keys='UserObject.userid',\n        primaryjoin='UserObject.userid == RepoObject.userid',\n        uselist=True,\n        lazy=True,\n        order_by=lambda: RepoObject.repopath,\n    )\n\n    @classmethod\n    def get_user(cls, user):\n        \"\"\"Return a user object.\"\"\"\n        return UserObject.query.filter(UserObject.username == user).first()\n\n    @classmethod\n    def create_admin_user(cls, default_username, default_password):\n        # Check if admin user exists. If not, created it.\n        userobj = UserObject.get_user(default_username)\n        if not userobj:\n            userobj = cls.add_user(default_username, role=UserObject.ADMIN_ROLE, user_root='/backups')\n            userobj.hash_password = hash_password('admin123')\n        # Also make sure to update the password with latest value from config file.\n        if default_password:\n            if default_password.startswith('{SSHA}') or default_password.startswith('$argon2'):\n                userobj.hash_password = default_password\n            else:\n                userobj.hash_password = hash_password(default_password)\n        userobj.add()\n        return userobj\n\n    @classmethod\n    def add_user(cls, username, password=None, role=USER_ROLE, **attrs):\n        \"\"\"\n        Used to add a new user with an optional password.\n        \"\"\"\n        assert password is None or isinstance(password, str)\n        # Check if user already exists.\n        if UserObject.get_user(username):\n            raise ValueError(_(\"User %s already exists.\" % (username,)))\n\n        # Find a database where to add the user\n        logger.info(\"adding new user [%s]\", username)\n        userobj = UserObject(\n            username=username,\n            hash_password=hash_password(password) if password else '',\n            role=role,\n            **attrs,\n        ).add()\n        # Return user object\n        return userobj\n\n    def add_authorizedkey(self, key, comment=None):\n        \"\"\"\n        Add the given key to the user. Adding the key to his `authorized_keys`\n        file if it exists and adding it to database.\n        \"\"\"\n        # Parse and validate ssh key\n        assert key\n        key = authorizedkeys.check_publickey(key)\n\n        # Remove option, replace comments.\n        key = authorizedkeys.AuthorizedKey(\n            options=None, keytype=key.keytype, key=key.key, comment=comment or key.comment\n        )\n\n        # If a filename exists, use it by default.\n        filename = os.path.join(self.user_root, '.ssh', 'authorized_keys')\n        if os.path.isfile(filename):\n            with open(filename, mode=\"r+\", encoding='utf-8') as fh:\n                if authorizedkeys.exists(fh, key):\n                    raise DuplicateSSHKeyError(_(\"SSH key already exists\"))\n                logger.info(\"add key [%s] to [%s] authorized_keys\", key, self.username)\n                authorizedkeys.add(fh, key)\n        else:\n            # Also look in database.\n            logger.info(\"add key [%s] to [%s] database\", key, self.username)\n            try:\n                SshKey(userid=self.userid, fingerprint=key.fingerprint, key=key.getvalue()).add().flush()\n            except IntegrityError:\n                raise DuplicateSSHKeyError(\n                    _(\"Duplicate key. This key already exists or is associated to another user.\")\n                )\n        cherrypy.engine.publish('user_attr_changed', self, {'authorizedkeys': True})\n        cherrypy.engine.publish('authorizedkey_added', self, fingerprint=key.fingerprint, comment=comment)\n\n    def add_access_token(self, name, expiration_time=None, length=16):\n        \"\"\"\n        Create a new access token. Return the un-encrypted value of the token.\n        \"\"\"\n        assert name\n        assert length >= 8\n        # Generate a random token\n        token = ''.join(secrets.choice(string.ascii_lowercase) for i in range(length))\n        # Store hash token\n        try:\n            Token(\n                userid=self.userid, name=name, hash_token=hash_password(token), expiration_time=expiration_time\n            ).add().flush()\n        except IntegrityError:\n            raise ValueError(_(\"Duplicate token name: %s\") % name)\n        cherrypy.engine.publish('access_token_added', self, name)\n        return token\n\n    def valid_user_root(self):\n        \"\"\"\n        Check if the current user_root is valid and readable\n        \"\"\"\n        try:\n            return os.access(self.user_root, os.F_OK) and os.path.isdir(self.user_root)\n        except Exception:\n            return False\n\n    def delete(self, *args, **kwargs):\n        cfg = cherrypy.tree.apps[''].cfg\n        if self.username == cfg.admin_user:\n            raise ValueError(_(\"can't delete admin user\"))\n        # FIXME This should be deleted by cascade\n        SshKey.query.filter(SshKey.userid == self.userid).delete()\n        RepoObject.query.filter(RepoObject.userid == self.userid).delete()\n        Token.query.filter(Token.userid == self.userid).delete()\n        # Delete ourself\n        return Base.delete(self)\n\n    def delete_authorizedkey(self, fingerprint):\n        \"\"\"\n        Remove the given key from the user. Remove the key from his\n        `authorized_keys` file if it exists and from database database.\n        \"\"\"\n        # If a filename exists, use it by default.\n        filename = os.path.join(self.user_root, '.ssh', 'authorized_keys')\n        if os.path.isfile(filename):\n            with open(filename, mode='r+', encoding='utf-8') as fh:\n                logger.info(\"removing key [%s] from [%s] authorized_keys\", fingerprint, self.username)\n                authorizedkeys.remove(fh, fingerprint)\n        else:\n            # Also look in database.\n            logger.info(\"removing key [%s] from [%s] database\", fingerprint, self.username)\n            SshKey.query.filter(and_(SshKey.userid == self.userid, SshKey.fingerprint == fingerprint)).delete()\n        cherrypy.engine.publish('user_attr_changed', self, {'authorizedkeys': True})\n\n    def delete_access_token(self, name):\n        assert name\n        if not Token.query.filter(Token.userid == self.userid, Token.name == name).delete():\n            raise ValueError(_(\"token name doesn't exists: %s\") % name)\n\n    @property\n    def disk_usage(self):\n        # Skip if user_root is invalid.\n        if not self.user_root or not os.path.exists(self.user_root):\n            return 0\n        values = cherrypy.engine.publish('get_disk_usage', self)\n        # Return the first not None value\n        return next((v for v in values if v is not None), 0)\n\n    @property\n    def disk_quota(self):\n        # Skip if user_root is invalid.\n        if not self.user_root or not os.path.exists(self.user_root):\n            return 0\n        values = cherrypy.engine.publish('get_disk_quota', self)\n        # Return the first not None value\n        return next((v for v in values if v is not None), 0)\n\n    @disk_quota.setter\n    def disk_quota(self, value):\n        # Skip if user_root is invalid.\n        if not self.user_root or not os.path.exists(self.user_root):\n            return\n        cherrypy.engine.publish('set_disk_quota', self, value)\n\n    @property\n    def authorizedkeys(self):\n        \"\"\"\n        Return an iterator on the authorized key. Either from his\n        `authorized_keys` file if it exists or from database.\n        \"\"\"\n        # If a filename exists, use it by default.\n        filename = os.path.join(self.user_root, '.ssh', 'authorized_keys')\n        if os.path.isfile(filename):\n            for k in authorizedkeys.read(filename):\n                yield k\n\n        # Also look in database.\n        for record in SshKey.query.filter(SshKey.userid == self.userid).all():\n            yield authorizedkeys.check_publickey(record.key)\n\n    def refresh_repos(self, delete=False):\n        \"\"\"\n        Return list of repositories object to reflect the filesystem folders.\n\n        Return a RepoObject for each sub directories under `user_root` with `rdiff-backup-data`.\n        \"\"\"\n        # Update the repositories by walking in the directory tree.\n        def _onerror(unused):\n            logger.error('error updating user [%s] repos' % self.username, exc_info=1)\n\n        # Get application config\n        cfg = cherrypy.tree.apps[''].cfg\n\n        dirty = False\n        records = RepoObject.query.filter(RepoObject.userid == self.userid).order_by(RepoObject.repopath).all()\n        user_root = os.fsencode(self.user_root)\n        for root, dirs, unused_files in os.walk(user_root, _onerror):\n            for name in dirs.copy():\n                if name.startswith(b'.'):\n                    dirs.remove(name)\n            if b'rdiff-backup-data' in dirs:\n                repopath = os.path.relpath(root, start=user_root)\n                del dirs[:]\n                # Handle special scenario when the repo is the\n                # user_root\n                repopath = b'' if repopath == b'.' else repopath\n\n                # Check if repo path exists.\n                record_match = next((record for record in records if record.repopath == os.fsdecode(repopath)), None)\n                if not record_match:\n                    # Add repository to database.\n                    RepoObject(user=self, repopath=os.fsdecode(repopath)).add()\n                    dirty = True\n                else:\n                    records.remove(record_match)\n            if root.count(SEP) - user_root.count(SEP) >= cfg.max_depth:\n                del dirs[:]\n        # If enabled, remove entried from database\n        if delete:\n            for record in records:\n                RepoObject.query.filter(RepoObject.repoid == record.repoid).delete()\n        return dirty\n\n    @hybrid_property\n    def is_admin(self):\n        return self.role is not None and self.role <= self.ADMIN_ROLE\n\n    @hybrid_property\n    def is_ldap(self):\n        return self.hash_password is None or self.hash_password == ''\n\n    @is_ldap.expression\n    def is_ldap(cls):\n        return or_(cls.hash_password.is_(None), cls.hash_password == '')\n\n    @hybrid_property\n    def is_maintainer(self):\n        return self.role is not None and self.role <= self.MAINTAINER_ROLE\n\n    def set_password(self, password):\n        \"\"\"\n        Change the user's password. Raise a ValueError if the username or\n        the password are invalid.\n        \"\"\"\n        assert isinstance(password, str)\n        if not password:\n            raise ValueError(\"password can't be empty\")\n        cfg = cherrypy.tree.apps[''].cfg\n\n        # Cannot update admin-password if defined\n        if self.username == cfg.admin_user and cfg.admin_password:\n            raise ValueError(_(\"can't update admin-password defined in configuration file\"))\n\n        # Check password length\n        if cfg.password_min_length > len(password) or len(password) > cfg.password_max_length:\n            raise ValueError(\n                _('Password must have between %(min)d and %(max)d characters.')\n                % {'min': cfg.password_min_length, 'max': cfg.password_max_length}\n            )\n\n        # Verify password score using zxcvbn\n        stats = zxcvbn(password)\n        if stats.get('score') < cfg.password_score:\n            msg = _('Password too weak.')\n            warning = stats.get('feedback', {}).get('warning')\n            suggestions = stats.get('feedback', {}).get('suggestions')\n            if warning:\n                msg += ' ' + warning\n            if suggestions:\n                msg += ' ' + ' '.join(suggestions)\n            raise ValueError(msg)\n\n        # Store password\n        logger.info(\"updating user password [%s] and revoke sessions\", self.username)\n        self.hash_password = hash_password(password)\n\n        # Revoke other session to force re-login\n        session_id = cherrypy.serving.session.id if hasattr(cherrypy.serving, 'session') else None\n        SessionObject.query.filter(\n            SessionObject.username == self.username,\n            SessionObject.id != session_id,\n        ).delete()\n\n    def __eq__(self, other):\n        return type(self) == type(other) and inspect(self).key == inspect(other).key\n\n    @validates('username')\n    def validates_username(self, key, value):\n        if self.username:\n            raise ValueError('Username cannot be modified.')\n        return value\n\n    def validate_access_token(self, token):\n        \"\"\"\n        Check if the given token matches.\n        \"\"\"\n        for access_token in Token.query.all():\n            if access_token.is_expired:\n                continue\n            if check_password(token, access_token.hash_token):\n                # When it matches, return the record.\n                return access_token\n        return False\n\n    def validate_password(self, password):\n        return check_password(password, self.hash_password)\n\n\n@event.listens_for(UserObject.hash_password, \"set\")\ndef hash_password_set(target, value, oldvalue, initiator):\n    if value and value != oldvalue:\n        cherrypy.engine.publish('user_password_changed', target)\n\n\n@event.listens_for(UserObject, 'before_insert')\ndef user_before_insert(mapper, connection, target):\n    \"\"\"\n    Publish event when user is added\n    \"\"\"\n    cherrypy.engine.publish('user_added', target)\n\n\n@event.listens_for(UserObject, 'after_delete')\ndef user_after_delete(mapper, connection, target):\n    \"\"\"\n    Publish event when user is deleted.\n    \"\"\"\n    cherrypy.engine.publish('user_deleted', target.username)\n\n\n@event.listens_for(UserObject, 'after_update')\ndef user_attr_changed(mapper, connection, target):\n    changes = {}\n    state = inspect(target)\n    for attr in state.attrs:\n        if attr.key in ['user_root', 'email', 'role', 'mfa']:\n            hist = attr.load_history()\n            if hist.has_changes():\n                changes[attr.key] = (\n                    hist.deleted[0] if len(hist.deleted) >= 1 else None,\n                    hist.added[0] if len(hist.added) >= 1 else None,\n                )\n    if changes:\n        cherrypy.engine.publish('user_attr_changed', target, changes)\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nCreated on June 30, 2022\n\nModule to test `user` model.\n\n@author: Patrik Dufresne <patrik@ikus-soft.com>\n\"\"\"\nimport os\nfrom io import StringIO, open\nfrom unittest.mock import MagicMock\n\nimport cherrypy\nimport pkg_resources\nfrom parameterized import parameterized, parameterized_class\n\nimport rdiffweb.test\nfrom rdiffweb.core import authorizedkeys\nfrom rdiffweb.core.model import DuplicateSSHKeyError, RepoObject, UserObject\nfrom rdiffweb.core.passwd import check_password\n\n\nclass UserObjectTest(rdiffweb.test.WebCase):\n    def _read_ssh_key(self):\n        \"\"\"Readthe pub key from test packages\"\"\"\n        filename = pkg_resources.resource_filename('rdiffweb.core.tests', 'test_publickey_ssh_rsa.pub')\n        with open(filename, 'r', encoding='utf8') as f:\n            return f.readline()\n\n    def _read_authorized_keys(self):\n        \"\"\"Read the content of test_authorized_keys\"\"\"\n        filename = pkg_resources.resource_filename('rdiffweb.core.tests', 'test_authorized_keys')\n        with open(filename, 'r', encoding='utf8') as f:\n            return f.read()\n\n    def setUp(self):\n        super().setUp()\n        self.listener = MagicMock()\n        cherrypy.engine.subscribe('access_token_added', self.listener.access_token_added, priority=50)\n        cherrypy.engine.subscribe('queue_mail', self.listener.queue_mail, priority=50)\n        cherrypy.engine.subscribe('user_added', self.listener.user_added, priority=50)\n        cherrypy.engine.subscribe('user_attr_changed', self.listener.user_attr_changed, priority=50)\n        cherrypy.engine.subscribe('user_deleted', self.listener.user_deleted, priority=50)\n        cherrypy.engine.subscribe('user_login', self.listener.user_login, priority=50)\n        cherrypy.engine.subscribe('user_password_changed', self.listener.user_password_changed, priority=50)\n\n    def tearDown(self):\n        cherrypy.engine.unsubscribe('access_token_added', self.listener.access_token_added)\n        cherrypy.engine.unsubscribe('queue_mail', self.listener.queue_mail)\n        cherrypy.engine.unsubscribe('user_added', self.listener.user_added)\n        cherrypy.engine.unsubscribe('user_attr_changed', self.listener.user_attr_changed)\n        cherrypy.engine.unsubscribe('user_deleted', self.listener.user_deleted)\n        cherrypy.engine.unsubscribe('user_login', self.listener.user_login)\n        cherrypy.engine.unsubscribe('user_password_changed', self.listener.user_password_changed)\n        return super().tearDown()\n\n    def test_add_user(self):\n        \"\"\"Add user to database.\"\"\"\n        userobj = UserObject.add_user('joe')\n        userobj.commit()\n        self.assertIsNotNone(UserObject.get_user('joe'))\n        # Check if listener called\n        self.listener.user_added.assert_called_once_with(userobj)\n\n    def test_add_user_updated_by_listener(self):\n        \"\"\"Add user to database.\"\"\"\n        # Given a listener with side effet\n        def change_user_obj(userobj):\n            userobj.user_root = '/new/value'\n\n        self.listener.user_added.side_effect = change_user_obj\n        # When adding user\n        userobj = UserObject.add_user('joe')\n        userobj.commit()\n        self.assertIsNotNone(UserObject.get_user('joe'))\n        # Then lister get called\n        self.listener.user_added.assert_called_once_with(userobj)\n        # Then object was updated by listener\n        self.assertEqual('/new/value', userobj.user_root)\n\n    def test_add_user_with_duplicate(self):\n        \"\"\"Add user to database.\"\"\"\n        user = UserObject.add_user('denise')\n        user.commit()\n        self.listener.user_added.reset_mock()\n        with self.assertRaises(ValueError):\n            UserObject.add_user('denise')\n        # Check if listener called\n        self.listener.user_added.assert_not_called()\n\n    def test_add_user_with_password(self):\n        \"\"\"Add user to database with password.\"\"\"\n        userobj = UserObject.add_user('jo', 'password')\n        userobj.commit()\n        self.assertIsNotNone(UserObject.get_user('jo'))\n        # Check if listener called\n        self.listener.user_added.assert_called_once_with(userobj)\n\n    def test_delete_admin_user(self):\n        # Trying to delete admin user should raise an error.\n        userobj = UserObject.get_user('admin')\n        with self.assertRaises(ValueError):\n            userobj.delete()\n\n    def test_users(self):\n        # Check admin exists\n        self.assertEqual(1, UserObject.query.count())\n        # Create user.\n        user = UserObject.add_user('annik')\n        user.commit()\n        users = UserObject.query.all()\n        self.assertEqual(2, len(users))\n        self.assertEqual('annik', users[1].username)\n        # Then 2 user exists\n        self.assertEqual(2, UserObject.query.count())\n\n    def test_get_user(self):\n        # Create new user\n        user = UserObject.add_user('bernie', 'my-password')\n        user.user_root = self.testcases\n        user.role = UserObject.ADMIN_ROLE\n        user.email = 'bernie@gmail.com'\n        user.refresh_repos()\n        user.commit()\n        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in user.repo_objs]))\n        user.repo_objs[0].maxage = -1\n        user.repo_objs[1].maxage = 3\n        user.commit()\n\n        # Get user record.\n        obj = UserObject.get_user('bernie')\n        self.assertIsNotNone(obj)\n        self.assertEqual('bernie', obj.username)\n        self.assertEqual('bernie@gmail.com', obj.email)\n        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in obj.repo_objs]))\n        self.assertEqual(self.testcases, obj.user_root)\n        self.assertEqual(True, obj.is_admin)\n        self.assertEqual(UserObject.ADMIN_ROLE, obj.role)\n\n        # Get repo object\n        self.assertEqual('broker-repo', obj.repo_objs[0].name)\n        self.assertEqual(-1, obj.repo_objs[0].maxage)\n        self.assertEqual('testcases', obj.repo_objs[1].name)\n        self.assertEqual(3, obj.repo_objs[1].maxage)\n\n    def test_get_user_with_invalid_user(self):\n        self.assertIsNone(UserObject.get_user('invalid'))\n\n    def test_get_set(self):\n        user = UserObject.add_user('larry', 'password')\n        user.add().commit()\n\n        self.assertEqual('', user.email)\n        self.assertEqual([], user.repo_objs)\n        self.assertEqual('', user.user_root)\n        self.assertEqual(False, user.is_admin)\n        self.assertEqual(UserObject.USER_ROLE, user.role)\n\n        user.user_root = self.testcases\n        user.refresh_repos()\n        user.commit()\n        self.listener.user_attr_changed.assert_called_with(user, {'user_root': ('', self.testcases)})\n        self.listener.user_attr_changed.reset_mock()\n        user = UserObject.get_user('larry')\n        user.role = UserObject.ADMIN_ROLE\n        user.commit()\n        self.listener.user_attr_changed.assert_called_with(\n            user, {'role': (UserObject.USER_ROLE, UserObject.ADMIN_ROLE)}\n        )\n        self.listener.user_attr_changed.reset_mock()\n        user = UserObject.get_user('larry')\n        user.email = 'larry@gmail.com'\n        user.commit()\n        self.listener.user_attr_changed.assert_called_with(user, {'email': ('', 'larry@gmail.com')})\n        self.listener.user_attr_changed.reset_mock()\n\n        self.assertEqual('larry@gmail.com', user.email)\n        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in user.repo_objs]))\n        self.assertEqual(self.testcases, user.user_root)\n        self.assertEqual(True, user.is_admin)\n        self.assertEqual(UserObject.ADMIN_ROLE, user.role)\n\n    def test_set_role_null(self):\n        # Given a user\n        user = UserObject.add_user('annik', 'password')\n        user.add().commit()\n        # When trying to set the role to null\n        user.role = None\n        # Then an exception is raised\n        with self.assertRaises(Exception):\n            user.add().commit()\n\n    @parameterized.expand(\n        [\n            (-1, True),\n            (0, True),\n            (5, False),\n            (10, False),\n            (15, False),\n        ]\n    )\n    def test_is_admin(self, role, expected_is_admin):\n        # Given a user\n        user = UserObject.add_user('annik', 'password')\n        # When setting the role value\n        user.role = role\n        user.commit()\n        # Then the is_admin value get updated too\n        self.assertEqual(expected_is_admin, user.is_admin)\n\n    @parameterized.expand(\n        [\n            (-1, True),\n            (0, True),\n            (5, True),\n            (10, False),\n            (15, False),\n        ]\n    )\n    def test_is_maintainer(self, role, expected_is_maintainer):\n        # Given a user\n        user = UserObject.add_user('annik', 'password')\n        # When setting the role value\n        user.role = role\n        user.commit()\n        # Then the is_admin value get updated too\n        self.assertEqual(expected_is_maintainer, user.is_maintainer)\n\n    def test_set_password_update(self):\n        # Given a user in database with a password\n        userobj = UserObject.add_user('annik', 'password')\n        userobj.commit()\n        self.listener.user_password_changed.reset_mock()\n        # When updating the user's password\n        userobj.set_password('new_password')\n        userobj.commit()\n        # Then password is SSHA\n        self.assertTrue(check_password('new_password', userobj.hash_password))\n        # Check if listener called\n        self.listener.user_password_changed.assert_called_once_with(userobj)\n\n    def test_delete_user(self):\n        # Given an existing user in database\n        userobj = UserObject.add_user('vicky')\n        userobj.commit()\n        self.assertIsNotNone(UserObject.get_user('vicky'))\n        # When deleting that user\n        userobj.delete()\n        userobj.commit()\n        # Then user it no longer in database\n        self.assertIsNone(UserObject.get_user('vicky'))\n        # Then listner was called\n        self.listener.user_deleted.assert_called_once_with('vicky')\n\n    def test_set_password_empty(self):\n        \"\"\"Expect error when trying to update password of invalid user.\"\"\"\n        userobj = UserObject.add_user('john')\n        userobj.commit()\n        with self.assertRaises(ValueError):\n            self.assertFalse(userobj.set_password(''))\n\n    def test_disk_quota(self):\n        \"\"\"\n        Just make a call to the function.\n        \"\"\"\n        userobj = UserObject.get_user(self.USERNAME)\n        userobj.disk_quota\n\n    def test_disk_usage(self):\n        \"\"\"\n        Just make a call to the function.\n        \"\"\"\n        userobj = UserObject.get_user(self.USERNAME)\n        disk_usage = userobj.disk_usage\n        self.assertIsInstance(disk_usage, int)\n\n    def test_add_authorizedkey_without_file(self):\n        \"\"\"\n        Add an ssh key for a user without an authorizedkey file.\n        \"\"\"\n        # Read the pub key\n        key = self._read_ssh_key()\n        # Add the key to the user\n        userobj = UserObject.get_user(self.USERNAME)\n        userobj.add_authorizedkey(key)\n        userobj.commit()\n\n        # validate\n        keys = list(userobj.authorizedkeys)\n        self.assertEqual(1, len(keys), \"expecting one key\")\n        self.assertEqual(\"3c:99:ed:a7:82:a8:71:09:2c:15:3d:78:4a:8c:11:99\", keys[0].fingerprint)\n\n    def test_add_authorizedkey_duplicate(self):\n        # Read the pub key\n        key = self._read_ssh_key()\n        # Add the key to the user\n        userobj = UserObject.get_user(self.USERNAME)\n        userobj.add_authorizedkey(key)\n        userobj.commit()\n        # Add the same key\n        with self.assertRaises(DuplicateSSHKeyError):\n            userobj.add_authorizedkey(key)\n            userobj.commit()\n\n    def test_add_authorizedkey_with_file(self):\n        \"\"\"\n        Add an ssh key for a user with an authorizedkey file.\n        \"\"\"\n        userobj = UserObject.get_user(self.USERNAME)\n\n        # Create empty authorized_keys file\n        os.mkdir(os.path.join(userobj.user_root, '.ssh'))\n        filename = os.path.join(userobj.user_root, '.ssh', 'authorized_keys')\n        open(filename, 'a').close()\n\n        # Read the pub key\n        key = self._read_ssh_key()\n        userobj.add_authorizedkey(key)\n        userobj.commit()\n\n        # Validate\n        with open(filename, 'r') as fh:\n            self.assertEqual(key, fh.read())\n\n    def test_delete_authorizedkey_without_file(self):\n        \"\"\"\n        Remove an ssh key for a user without authorizedkey file.\n        \"\"\"\n        # Update user with ssh keys.\n        data = self._read_authorized_keys()\n        userobj = UserObject.get_user(self.USERNAME)\n        for k in authorizedkeys.read(StringIO(data)):\n            try:\n                userobj.add_authorizedkey(k.getvalue())\n            except ValueError:\n                # Some ssh key in the testing file are not valid.\n                pass\n\n        # Get the keys\n        keys = list(userobj.authorizedkeys)\n        self.assertEqual(2, len(keys))\n\n        # Remove a key\n        userobj.delete_authorizedkey(\"9a:f1:69:3c:bc:5a:cd:02:5e:33:bc:cd:c0:01:eb:4c\")\n        userobj.commit()\n\n        # Validate\n        keys = list(userobj.authorizedkeys)\n        self.assertEqual(1, len(keys))\n\n    def test_delete_authorizedkey_with_file(self):\n        \"\"\"\n        Remove an ssh key for a user with authorizedkey file.\n        \"\"\"\n        # Create authorized_keys file\n        data = self._read_authorized_keys()\n        userobj = UserObject.get_user(self.USERNAME)\n        os.mkdir(os.path.join(userobj.user_root, '.ssh'))\n        filename = os.path.join(userobj.user_root, '.ssh', 'authorized_keys')\n        with open(filename, 'w') as f:\n            f.write(data)\n\n        # Get the keys\n        keys = list(userobj.authorizedkeys)\n        self.assertEqual(5, len(keys))\n\n        # Remove a key\n        userobj.delete_authorizedkey(\"9a:f1:69:3c:bc:5a:cd:02:5e:33:bc:cd:c0:01:eb:4c\")\n\n        # Validate\n        keys = list(userobj.authorizedkeys)\n        self.assertEqual(4, len(keys))\n\n    def test_repo_objs(self):\n        # Given a user with a list of repositories\n        userobj = UserObject.get_user(self.USERNAME)\n        repos = sorted(userobj.repo_objs, key=lambda r: r.name)\n        self.assertEqual(['broker-repo', 'testcases'], [r.name for r in repos])\n        # When deleting a repository empty list\n        repos[1].delete()\n        repos[1].commit()\n        # Then the repository is removed from the list.\n        self.assertEqual(['broker-repo'], sorted([r.name for r in userobj.repo_objs]))\n\n    def test_refresh_repos_without_delete(self):\n        # Given a user with invalid repositories\n        userobj = UserObject.get_user(self.USERNAME)\n        RepoObject.query.delete()\n        RepoObject(userid=userobj.userid, repopath='invalid').add().commit()\n        self.assertEqual(['invalid'], sorted([r.name for r in userobj.repo_objs]))\n        # When updating the repository list without deletion\n        userobj.refresh_repos()\n        userobj.commit()\n        # Then the list invlaid the invalid repo and new repos\n        self.assertEqual(['broker-repo', 'invalid', 'testcases'], sorted([r.name for r in userobj.repo_objs]))\n\n    def test_refresh_repos_with_delete(self):\n        # Given a user with invalid repositories\n        userobj = UserObject.get_user(self.USERNAME)\n        RepoObject.query.delete()\n        RepoObject(userid=userobj.userid, repopath='invalid').add().commit()\n        self.assertEqual(['invalid'], sorted([r.name for r in userobj.repo_objs]))\n        # When updating the repository list without deletion\n        userobj.refresh_repos(delete=True)\n        userobj.commit()\n        # Then the list invlaid the invalid repo and new repos\n        userobj.expire()\n        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in userobj.repo_objs]))\n\n    def test_refresh_repos_with_single_repo(self):\n        # Given a user with invalid repositories\n        userobj = UserObject.get_user(self.USERNAME)\n        userobj.user_root = os.path.join(self.testcases, 'testcases')\n        # When updating the repository list without deletion\n        userobj.refresh_repos(delete=True)\n        userobj.commit()\n        # Then the list invlaid the invalid repo and new repos\n        userobj.expire()\n        self.assertEqual([''], sorted([r.name for r in userobj.repo_objs]))\n\n    def test_refresh_repos_with_empty_userroot(self):\n        # Given a user with valid repositories relative to root\n        userobj = UserObject.get_user(self.USERNAME)\n        for repo in userobj.repo_objs:\n            repo.repopath = self.testcases[1:] + '/' + repo.repopath\n            repo.add().commit()\n        userobj.user_root = '/'\n        userobj.add().commit()\n        self.assertEqual(['interrupted', 'ok'], sorted([r.status[0] for r in userobj.repo_objs]))\n        # When updating it's userroot directory to an empty value\n        userobj.user_root = ''\n        userobj.add().commit()\n        UserObject.session.expire_all()\n        # Then close session\n        cherrypy.tools.db.on_end_resource()\n        # Then repo status is \"broken\"\n        userobj = UserObject.get_user(self.USERNAME)\n        self.assertFalse(userobj.valid_user_root())\n        self.assertEqual(['failed', 'failed'], [r.status[0] for r in userobj.repo_objs])\n\n\n# password: test\n@parameterized_class(\n    [\n        {\n            'default_config': {\n                'admin-password': '{SSHA}wbSK4hlEX7mtGJplFi2oN6ABm6Y3Bo1e',\n            },\n        },\n        {\n            'default_config': {\n                'admin-password': '$argon2id$v=19$m=65536,t=3,p=4$N2FmDyCNjY/MTreAOWluLw$BbKVcHt99Jf5yeTbFcJhwJpcEtSSNCB1ru4D+Vvm+JM'\n            },\n        },\n        {\n            'default_config': {\n                'admin-password': 'test',\n            }\n        },\n    ]\n)\nclass UserObjectWithAdminPassword(rdiffweb.test.WebCase):\n    def setUp(self):\n        # Do nothing - We need to skip the default setup to avoid deleting the records.\n        pass\n\n    def test_create_admin_user(self):\n        # Given admin-password is configure\n        # When database get created\n        # Then admin user get created with 'test' password\n        userobj = UserObject.get_user(self.USERNAME)\n        self.assertIsNotNone(userobj)\n        self.assertTrue(check_password('test', userobj.hash_password))\n\n        # Given admin-password is configure\n        # When trying to update admin password\n        # Then an exception is raised\n        userobj = UserObject.get_user(self.USERNAME)\n        with self.assertRaises(ValueError):\n            userobj.set_password('newpassword')\n\n\nclass UserObjectWithoutAdminPassword(rdiffweb.test.WebCase):\n    def setUp(self):\n        # Do nothing - We need to skip the default setup to avoid deleting the records.\n        pass\n\n    def tearDown(self):\n        # Do nothing - We need to makre sure the database is not drop.\n        pass\n\n    def test_create_admin_user_without_password(self):\n        # Given an existing admin user with a password\n        userobj = UserObject.get_user(self.USERNAME)\n        userobj.hash_password = '{SSHA}wbSK4hlEX7mtGJplFi2oN6ABm6Y3Bo1e'  # test\n        # When application restart, create_admin_user is called again\n        user = UserObject.create_admin_user(self.USERNAME, None)\n        user.commit()\n        # Then user password must not be replaced\n        self.assertTrue(check_password('test', user.hash_password))\n\n    @parameterized.expand(\n        [\n            'puy3qjRWjpCn',\n            '$argon2id$v=19$m=65536,t=3,p=4$L91u8sX4ecyrbUSqvmb/FA$GOGR5uPmQmla6H62e5yKKNCRa7sY6d2Hxmly/eAXe6Q',\n            '{SSHA}3RkZu26wF8xSHInMcK8P/9wqqU1aCzie',\n        ]\n    )\n    def test_create_admin_user_with_password(self, new_password):\n        # Given an existing admin user with a password\n        userobj = UserObject.get_user(self.USERNAME)\n        userobj.hash_password = '{SSHA}wbSK4hlEX7mtGJplFi2oN6ABm6Y3Bo1e'  # test\n        # When application restart, create_admin_user is called again with a password\n        user = UserObject.create_admin_user(self.USERNAME, new_password)\n        user.commit()\n        # Then user password get replaced\n        self.assertTrue(check_password('puy3qjRWjpCn', user.hash_password))\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport unittest\n\nimport cherrypy\n\nfrom rdiffweb.core.librdiff import RdiffTime\nfrom rdiffweb.core.model import RepoObject, UserObject\nfrom rdiffweb.core.rdw_templating import _ParentEntry, attrib, do_format_lastupdated, list_parents, url_for\nfrom rdiffweb.test import WebCase\n\n\nclass TemplateManagerTest(unittest.TestCase):\n    def test_attrib(self):\n        # Single value\n        self.assertEqual('id=\"row\"', attrib(id='row'))\n        # Single value with quote\n        self.assertEqual('id=\"val&lt;ue&quot;with&quot;qu&gt;ot&amp;e\"', attrib(id='val<ue\"with\"qu>ot&e'))\n        # Multi attribute\n        self.assertEqual('id=\"row\" type=\"table\"', attrib(type='table', id='row'))\n        # Attribute with list\n        self.assertEqual('type=\"table container\"', attrib(type=['table', 'container']))\n        # Attribute with class\n        self.assertEqual('class=\"table container\"', attrib(**{'class': ['table', 'container']}))\n        # Boolean expressions\n        self.assertEqual('id=\"active\"', attrib(id=[False, 'active', False]))\n        self.assertEqual('data=\"coucou\" id=\"active\"', attrib(type=False, id=[False, 'active', False], data='coucou'))\n        active = True\n        self.assertEqual('id=\"active\"', attrib(id=[active and 'active']))\n        active = False\n        self.assertEqual('', attrib(id=[active and 'active']))\n\n        # With True\n        self.assertEqual('selected', attrib(selected=True))\n\n        # Bytes\n        self.assertEqual('selected=\"text\"', attrib(selected=b'text'))\n\n        # Newstr\n        self.assertEqual('selected=\"text\"', attrib(selected=str('text')))\n\n        self.assertEqual('value=\"0\"', attrib(value=0))\n\n    def test_url_for(self):\n        # Check backward compatibility\n        self.assertEqual(cherrypy.server.base() + '/', url_for('/'))\n        self.assertEqual(cherrypy.server.base() + '/browse', url_for('browse'))\n        self.assertEqual(cherrypy.server.base() + '/browse/testcases', url_for('browse', b'testcases'))\n        self.assertEqual(\n            cherrypy.server.base() + '/browse/testcases/Revisions', url_for('browse', b'testcases', b'Revisions')\n        )\n        self.assertEqual(\n            cherrypy.server.base() + '/restore/testcases/Revisions?date=1454448640',\n            url_for('restore', b'testcases', b'Revisions', date=1454448640),\n        )\n        self.assertEqual(\n            cherrypy.server.base() + '/restore/testcases/Revisions?date=1454448640&kind=tar.gz',\n            url_for('restore', b'testcases', b'Revisions', date=1454448640, kind='tar.gz'),\n        )\n        self.assertEqual(\n            cherrypy.server.base() + '/browse/testcases/R%C3%A9pertoire',\n            url_for('browse', b'testcases', b'R\\xc3\\xa9pertoire'),\n        )\n        # Check if multi path is supported.\n        self.assertEqual(cherrypy.server.base() + '/admin/logs', url_for('admin/logs'))\n        self.assertEqual(cherrypy.server.base() + '/admin/logs/backup.log', url_for('admin/logs', 'backup.log'))\n\n    def test_do_format_lastupdated(self):\n        self.assertEqual('23 seconds ago', do_format_lastupdated(1591978823, now=1591978846))\n        self.assertEqual('23 seconds ago', do_format_lastupdated(RdiffTime(value=1591978823), now=1591978846))\n        self.assertEqual('8 minutes ago', do_format_lastupdated(RdiffTime(value=1591978324), now=1591978846))\n        self.assertEqual('2 hours ago', do_format_lastupdated(RdiffTime(value=1591971646), now=1591978846))\n        self.assertEqual('2 days ago', do_format_lastupdated(RdiffTime(value=1591805524), now=1591978846))\n        self.assertEqual('4 weeks ago', do_format_lastupdated(RdiffTime(value=1589127124), now=1591978846))\n        self.assertEqual('5 months ago', do_format_lastupdated(RdiffTime(value=1578672724), now=1591978846))\n        self.assertEqual('4 years ago', do_format_lastupdated(RdiffTime(value=1452442324), now=1591978846))\n\n\nclass ListParentsTest(WebCase):\n    def test_list_parents_with_root_dir(self):\n        repo, path = RepoObject.get_repo_path(b'admin/testcases', as_user=UserObject.get_user('admin'))\n        self.assertEqual(list_parents(repo, path), [_ParentEntry(path=b'', display_name='testcases')])\n\n    def test_list_parents_with_root_subdir(self):\n        repo, path = RepoObject.get_repo_path(b'admin/testcases/Revisions', as_user=UserObject.get_user('admin'))\n        self.assertEqual(\n            list_parents(repo, path),\n            [\n                _ParentEntry(path=b'', display_name='testcases'),\n                _ParentEntry(path=b'Revisions', display_name='Revisions'),\n            ],\n        )\n\n\nclass UrlForTest(WebCase):\n    @property\n    def repo_obj(self):\n        user = UserObject.query.filter(UserObject.username == 'admin').first()\n        return RepoObject.query.filter(RepoObject.user == user, RepoObject.repopath == self.REPO).first()\n\n    def test_url_for_absolute_path(self):\n        self.assertEqual(cherrypy.server.base() + '/static/js/jquery.min.js', url_for('/static/js/jquery.min.js'))\n\n    def test_url_for_browse(self):\n        \"\"\"Check creation of url\"\"\"\n        self.assertEqual(cherrypy.server.base() + '/browse/admin/testcases', url_for('browse', self.repo_obj))\n        self.assertEqual(\n            cherrypy.server.base() + '/browse/admin/testcases/Revisions', url_for('browse', self.repo_obj, b'Revisions')\n        )\n        self.assertEqual(\n            cherrypy.server.base() + '/browse/admin/testcases/Revisions?restore=True',\n            url_for('browse', self.repo_obj, b'Revisions', restore=True),\n        )\n        self.assertEqual(\n            cherrypy.server.base()\n            + '/browse/admin/testcases/R%C3%A9pertoire%20%28%40vec%29%20%7Bc%C3%A0ra%C3%A7t%23%C3%A8r%C3%AB%7D%20%24%C3%A9p%C3%AAcial',\n            url_for(\n                'browse',\n                self.repo_obj,\n                b'R\\xc3\\xa9pertoire (@vec) {c\\xc3\\xa0ra\\xc3\\xa7t#\\xc3\\xa8r\\xc3\\xab} $\\xc3\\xa9p\\xc3\\xaacial',\n            ),\n        )\n\n    def test_url_for_graphs(self):\n        self.assertEqual(\n            cherrypy.server.base() + '/graphs/files/admin/testcases', url_for('graphs', 'files', self.repo_obj)\n        )\n\n    def test_url_for_history(self):\n        \"\"\"Check creation of url\"\"\"\n        self.assertEqual(cherrypy.server.base() + '/history/admin/testcases', url_for('history', self.repo_obj))\n\n    def test_url_for_restore(self):\n        self.assertEqual(\n            cherrypy.server.base() + '/restore/admin/testcases?date=1414967021',\n            url_for('restore', self.repo_obj, date=RdiffTime(1414967021)),\n        )\n        self.assertEqual(\n            cherrypy.server.base() + '/restore/admin/testcases?date=1414967021',\n            url_for('restore', self.repo_obj, b'', date=RdiffTime(1414967021)),\n        )\n        self.assertEqual(\n            cherrypy.server.base() + '/restore/admin/testcases?date=1414967021&kind=tar.gz',\n            url_for('restore', self.repo_obj, b'', date=RdiffTime(1414967021), kind='tar.gz'),\n        )\n        self.assertEqual(\n            cherrypy.server.base() + '/restore/admin/testcases/Revisions?date=1414967021',\n            url_for('restore', self.repo_obj, b'Revisions', date=RdiffTime(1414967021)),\n        )\n        self.assertEqual(\n            cherrypy.server.base()\n            + '/restore/admin/testcases/R%C3%A9pertoire%20%28%40vec%29%20%7Bc%C3%A0ra%C3%A7t%23%C3%A8r%C3%AB%7D%20%24%C3%A9p%C3%AAcial?date=1414967021',\n            url_for(\n                'restore',\n                self.repo_obj,\n                b'R\\xc3\\xa9pertoire (@vec) {c\\xc3\\xa0ra\\xc3\\xa7t#\\xc3\\xa8r\\xc3\\xab} $\\xc3\\xa9p\\xc3\\xaacial',\n                date=RdiffTime(1414967021),\n            ),\n        )\n\n    def test_url_for_status(self):\n        self.assertEqual(\n            cherrypy.server.base() + '/status?date=1414967021', url_for('status', date=RdiffTime(1414967021))\n        )\n        self.assertEqual(\n            cherrypy.server.base() + '/status/admin/testcases?date=1414967021',\n            url_for('status', self.repo_obj, date=RdiffTime(1414967021)),\n        )\n\n    def test_url_for_with_none(self):\n        self.assertEqual(cherrypy.server.base() + '/logs', url_for('logs', date=None))\n"], "fixing_code": ["![Rdiffweb Banner](https://gitlab.com/ikus-soft/rdiffweb/-/raw/master/doc/_static/banner.png)\n\n<p align=\"center\">\n<strong>\n<a href=\"https://www.rdiffweb.org\">website</a>\n\u2022 <a href=\"https://www.ikus-soft.com/archive/rdiffweb/doc/latest/html/\">docs</a>\n\u2022 <a href=\"https://groups.google.com/d/forum/rdiffweb\">community</a>\n\u2022 <a href=\"https://rdiffweb-demo.ikus-soft.com/\">demo</a>\n</strong>\n</p>\n\n<p align=\"center\">\n<a href=\"LICENSE\"><img alt=\"License\" src=\"https://img.shields.io/github/license/ikus060/rdiffweb\"></a>\n<a href=\"https://gitlab.com/ikus-soft/rdiffweb/pipelines\"><img alt=\"Build\" src=\"https://gitlab.com/ikus-soft/rdiffweb/badges/master/pipeline.svg\"></a>\n<a href=\"https://sonar.ikus-soft.com/dashboard?id=rdiffweb\"><img alt=\"Quality Gate Minarca Client\" src=\"https://sonar.ikus-soft.com/api/project_badges/measure?project=rdiffweb&metric=alert_status\"></a>\n<a href=\"https://sonar.ikus-soft.com/dashboard?id=rdiffweb\"><img alt=\"Coverage\" src=\"https://sonar.ikus-soft.com/api/project_badges/measure?project=rdiffweb&metric=coverage\"></a>\n<a href=\"https://bestpractices.coreinfrastructure.org/projects/6583\"><img src=\"https://bestpractices.coreinfrastructure.org/projects/6583/badge\"></a>\n</p>\n\n<h1 align=\"center\">\nWelcome to Rdiffweb\n</h1>\n\nRdiffweb is a web application that allows you to view repositories generated\nby [rdiff-backup](https://rdiff-backup.net/). The purpose of this\napplication is to ease the management of backups and quickly restore your data\nwith a rich and powerful web interface.\n\nRdiffweb is written in Python and is released as open source project under the\nGNU GENERAL PUBLIC LICENSE (GPL). All source code and documentation are\nCopyright Rdiffweb contributors.\n\nRdiffweb is actively developed by [IKUS Soft](https://www.ikus-soft.com/)\nsince November 2014.\n\nThe Rdiffweb source code is hosted on [Gitlab](https://gitlab.com/ikus-soft/rdiffweb)\nand mirrored to [Github](https://github.com/ikus060/rdiffweb).\n\nThe Rdiffweb website is <https://rdiffweb.org/>.\n\n## Features\n\nWith its rich web interface Rdiffweb provide a notable list of features:\n\n* Browse your backup\n* Restore single file or multiple files as an archived\n* Users authentication via local database and LDAP\n* Users authorization\n* Email notification when backup is not successful\n* Configurable repository encoding\n* Configurable retention period\n* Backup statistics visualization using graphs\n* SSH Keys management\n* Disk quota visualization\n* File and folder deletion\n\n## Demo\n\nIf you quickly want to check how Rdiffweb is behaving, you may try our demo server hosted on:\n\n[https://rdiffweb-demo.ikus-soft.com/](https://rdiffweb-demo.ikus-soft.com/)\n\nUse the following credential to login:\n\n* Username: admin\n* Password: admin123\n\n## Installation & Docker usage\n\nFor detailed installation steps, read the [Installation documentation](https://www.ikus-soft.com/archive/rdiffweb/doc/latest/html/installation.html).\n\n## Current Build Status\n\n[![Build Status](https://gitlab.com/ikus-soft/rdiffweb/badges/master/pipeline.svg)](https://gitlab.com/ikus-soft/rdiffweb/pipelines)\n\n## Download\n\nYou should read the [Documentation](https://www.ikus-soft.com/archive/rdiffweb/doc/latest/html/index.html) to properly install Rdiffweb in your environment.\n\n**Docker**\n\n    docker pull ikus060/rdiffweb\n\n**Debian**\n\n    curl -L https://www.ikus-soft.com/archive/rdiffweb/public.key | apt-key add - \n    echo \"deb https://nexus.ikus-soft.com/repository/apt-release-bullseye/ bullseye main\" > /etc/apt/sources.list.d/rdiffweb.list\n    apt update\n    apt install rdiffweb\n\n**Pypi**\n\n    pip install rdiffweb\n\n## Support\n\n### Mailing list\n\nRdiffweb users should use the [Rdiffweb mailing list](https://groups.google.com/forum/#!forum/rdiffweb).\n\n### Bug Reports\n\nBug reports should be reported on the Rdiffweb Gitlab at <https://gitlab.com/ikus-soft/rdiffweb/-/issues>\n\n### Professional support\n\nProfessional support for Rdiffweb is available by contacting [IKUS Soft](https://www.ikus-soft.com/en/support/#form).\n\n# Changelog\n\n## Next Release - 2.5.5\n\n* Fix loading of Charts in Status page\n* Ensure Gmail and other mail client doesn't create hyperlink automatically for any nodification sent by Rdiffweb to avoid phishing - credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Sent email notification to user when a new SSH Key get added - credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Ratelimit \"Resend code to my email\" in Two-Factor Authentication view - credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Username are not case-insensitive - credits to [raiders0786](https://www.linkedin.com/in/chirag-agrawal-770488144/)\n\nBreaking changes:\n\n* Username with different cases (e.g.: admin vs Ammin) are not supported. If your database contains such username make sure to remove them before upgrading otherwise Rdiffweb will not start.\n\n## 2.5.4 (2022-12-19)\n\n* Discard `X-Forwarded-Host` headers credit to [Anishka Shukla](https://github.com/anishkashukla)\n* Create proper symbolic link of `chartkick.js` on Ubuntu Jammy to fix loading of Charts in web interface\n* Add CSRF verification on `/logout` credits to [reza.duty](https://rezaduty.me)\n\n## 2.5.3 (2022-12-05)\n\n* Add support for WTForms v3 to support Debian Bookworm\n* Fix strange behavior in access token management #247\n\n## 2.5.2 (2022-11-28)\n\n* Block repository access when user_root directory is empty or relative path [CVE-2022-4314](https://nvd.nist.gov/vuln/detail/CVE-2022-4314) credit to [neverjunior](https://github.com/neverjunior)\n* Replace admin password only when `--admin-password` option is provided #246\n* Invalidate browser cache for `logo`, `headerlogo` and `favicon` on restart #245\n\n## 2.5.1 (2022-11-11)\n\n* Add support for Ubuntu Kinetic #240\n* Disable filesize for deleted files to improve page loading #241\n\n## 2.5.0 (2022-11-09)\n\nThis next release focus on two-factor-authentication as a measure to increase security of user's account.\n\n* Store User's session information into database\n* Update ldap plugin to load additional attributes from LDAP server\n* Improve `/status` page error handling when `session_statistics` cannot be read\n* Add support for Ubuntu Jammy\n* Upgrade from Bootstrap v3 to v4 #204\n* Replace Fontello by Font-Awesome v4\n* Use CSS variables `var()` to customize themes using `--branding-X` options #239\n* Remove usage of Jquery.validate\n* Replace custom timsort by jquery DataTables #205\n* Add Active Session managements #203\n  * Active session should be visible in user's profiles\n  * Active session may be revoked by user\n  * Active session should be visible in administration view\n  * Action session may be revoke by administrator\n  * Show number of active users within the last 24 hours in dashboard\n* Handle migration of older Rdiffweb database by adding the missing `repos.Encoding`, `repos.keepdays` and `users.role` columns #185\n* Replace deprecated references of `disutils.spawn.find_executable()` by `shutil.which()` #208\n* Add two-factor authentication with email verification #201\n* Generate a new session on login and 2FA #220\n* Enforce permission on /etc/rdiffweb configuration folder\n* Enforce validation on fullname, username and email\n* Limit incorrect attempts to change the user's password to prevent brute force attacks #225 [CVE-2022-3273](https://nvd.nist.gov/vuln/detail/CVE-2022-3273) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Enforce password policy new password cannot be set as new password [CVE-2022-3376](https://nvd.nist.gov/vuln/detail/CVE-2022-3376) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Enforce better rate limit on login, mfa, password change and API [CVE-2022-3439](https://nvd.nist.gov/vuln/detail/CVE-2022-3439) [CVE-2022-3456](https://nvd.nist.gov/vuln/detail/CVE-2022-3456) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Enforce 'Origin' validation [CVE-2022-3457](https://nvd.nist.gov/vuln/detail/CVE-2022-3457) credit to [Nithissh12](Nithissh12)\n* Define idle and absolute session timeout with agressive default to protect usage on public computer [CVE-2022-3327](https://nvd.nist.gov/vuln/detail/CVE-2022-3327) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Send email notification when enabling or disabling MFA [CVE-2022-3363](https://nvd.nist.gov/vuln/detail/CVE-2022-3363) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Use Argon2id to store password hash #231\n* Fixed plugin priorities to ensure that jobs are scheduled at each startup #232\n* Revoke previous user's sessions on password change [CVE-2022-3362](https://nvd.nist.gov/vuln/detail/CVE-2022-3362) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n\nBreaking changes:\n\n* Drop Ubuntu Hirsute & Impish (End-of-life)\n* `session-dir` is deprecated and should be replace by `rate-limit-dir`. User's session are stored in database.\n* previous `.css` customization are not barkward compatible. Make usage of the `--branding-X` options.\n\n**Thanks to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172) with whom I collaborate to improve the security of this project.**\n\n## 2.4.10 (2022-10-03)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Mitigate path traversal vulnerability [CVE-2022-3389](https://nvd.nist.gov/vuln/detail/CVE-2022-3389) credit to [Hoang Van Hiep](https://www.linkedin.com/in/hiephv2410/)\n\n## 2.4.9 (2022-09-28)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Add `Cache-Control` and other security headers [CVE-2022-3292](https://nvd.nist.gov/vuln/detail/CVE-2022-3292) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Enforce password policy using `password-score` based on [zxcvbn](https://github.com/dropbox/zxcvbn) [CVE-2022-3326](https://nvd.nist.gov/vuln/detail/CVE-2022-3326) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n\n## 2.4.8 (2022-09-26)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Clean-up invalid path on error page\n* Limit username field length [CVE-2022-3290](https://nvd.nist.gov/vuln/detail/CVE-2022-3290) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Limit user's email field length [CVE-2022-3272](https://nvd.nist.gov/vuln/detail/CVE-2022-3272) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Limit user's root directory field length [CVE-2022-3295](https://nvd.nist.gov/vuln/detail/CVE-2022-3295) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n* Limit SSH Key title field length [CVE-2022-3298](https://nvd.nist.gov/vuln/detail/CVE-2022-3298) credit to [Nehal Pillai](https://www.linkedin.com/in/nehal-pillai-02a854172)\n\n## 2.4.7 (2002-09-21)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Generate a new session on login and 2FA #220 [CVE-2022-3269](https://nvd.nist.gov/vuln/detail/CVE-2022-3269) credit to [Ambadi MP](https://www.linkedin.com/in/ambadi-m-p-16a95217b/)\n* Mitigate CSRF on user's settings #221 [CVE-2022-3274](https://nvd.nist.gov/vuln/detail/CVE-2022-3274) credit to [irfansayyed](https://github.com/irfansayyed-github)\n\n## 2.4.6 (2022-09-20)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Support MarkupSafe<3 for Debian bookworm\n* Mitigate CSRF on user's notification settings #216 [CVE-2022-3233](https://nvd.nist.gov/vuln/detail/CVE-2022-3233) credit to [Ambadi MP](https://www.linkedin.com/in/ambadi-m-p-16a95217b/)\n* Mitigate CSRF on repository settings #217 [CVE-2022-3267](https://nvd.nist.gov/vuln/detail/CVE-2022-3267) credit to [irfansayyed](https://github.com/irfansayyed-github)\n* Use 'Secure' Attribute with Sensitive Cookie in HTTPS Session on HTTP Error #218 [CVE-2022-3174](https://nvd.nist.gov/vuln/detail/CVE-2022-3174) credit to [Chuu](https://github.com/uonghoangminhchau)\n\n## 2.4.5 (2002-09-16)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Mitigate CSRF on repository deletion and user deletion [CVE-2022-3232](https://nvd.nist.gov/vuln/detail/CVE-2022-3232) #214 #215 credit to [Ambadi MP](https://www.linkedin.com/in/ambadi-m-p-16a95217b/)\n\n## 2.4.4 (2002-09-15)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Use `X-Real-IP` to identify client IP address to mitigate Brute-Force attack #213\n\n## 2.4.3 (2022-09-14)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Mitigate CSRF in profile's SSH Keys [CVE-2022-3221](https://nvd.nist.gov/vuln/detail/CVE-2022-3221) #212 credit to [Ambadi MP](https://www.linkedin.com/in/ambadi-m-p-16a95217b/)\n\n## 2.4.2 (2022-09-12)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Use 'Secure' Attribute with Sensitive Cookie in HTTPS Session. [CVE-2022-3174](https://nvd.nist.gov/vuln/detail/CVE-2022-3174) #209 credit to [Chuu](https://github.com/uonghoangminhchau)\n* Avoid leakage of the stack trace in the default error page. [CVE-2022-3175](https://nvd.nist.gov/vuln/detail/CVE-2022-3175) #210 credit to [Chuu](https://github.com/uonghoangminhchau)\n* Enforce minimum and maximum password length [CVE-2022-3175](https://nvd.nist.gov/vuln/detail/CVE-2022-3179) #211 credit to [Chuu](https://github.com/uonghoangminhchau)\n\n## 2.4.1 (2022-09-08)\n\nThis releases include a security fix. If you are using an earlier version, you should upgrade to this release immediately.\n\n* Add Clickjacking Defense [CVE-2022-3167](https://nvd.nist.gov/vuln/detail/CVE-2022-3167) credit to [tharunavula](https://github.com/tharunavula)\n* Drop Ubuntu Hirsute & Impish (End-of-life)\n\n## 2.4.0 (2022-06-21)\n\nThis new release brings a lot of improvement since the last version, multiple bug fixes\nto make the application stable. A couple of new features to improve the overall\nusability and a new security feature to block a brute force attack.\n\n* Add RateLimit to login page and API to mitigate robots attacks #167\n* Send email notification only if `email-sender` option is defined to avoid raising exception in logs #176\n* Support file restore cancellation without leaving `rdiffweb-restore` process in `<defunct>` state #174\n* Replace `python-ldap` by `ldap3` a pure python implementation to avoid dependencies on `sasl` and `ldap` binaries #186\n* Reffactor core module to allow better extendability and reusability #183\n* Add support for Debian Bookworm #180\n* Add support for Ubuntu Impish #175\n* Add rdiff-backup version to administration view\n* Run unit test during Debian build package\n* Refresh repository list automatically when required #188 #189\n* Fix error 500 displayed in status page #191\n* Improve repository browsing speed by minimizing the number of I/O call #192\n* Publish Docker image directly to DockerHub #144\n* Add REST API to manage sshkeys\n\nBreaking changes:\n\n* Ldap Password changes is not supported anymore.\n* Ldap Check Shadow expire config is not supported anymore. It should be replace by a custom filter.\n* Drop CentOS 7 and CentOS 8 support\n\n## 2.3.9 (2022-01-05)\n\nMaintenance release to fix minor issues\n\n* Improve date parsing for `backup.log` to avoid printing exception in logs #170\n* Return HTTP error 403 for invalid symlink to avoid returning a misleading HTTP 500 Server Error #168\n* Show a user friendly error message when trying to create a new user with an existing username #169\n* Handle repository without last-backup date during the notification process to ensure notifications are sent #171\n* Replace CherryPy `storage_type` by `storage_class` to avoid warning in logs\n* Update code to avoid deprecation warning where applicable\n* Add Flake8 validation to improve code quality\n* Remove Ubuntu Groovy support\n\n## 2.3.8 (2021-12-01)\n\n* Push all artefacts to nexus server including binaries and documentation\n* Fix `Chart.js` loading on Debian bullseye #164\n* Update installation steps documentation\n* Improve LDAP authentication to lookup entire directory\n* Fix usage of `--ldap-add-user-default-userroot` to avoid error related to wrong encoding\n* Improve authentication mechanics\n* Avoid raising an HTTP error 500 when login form receive invalid payload\n* Mitigate open redirect vulnerability in login form\n\n## 2.3.7 (2021-10-21)\n\n* To avoid backward compatibility issue, revert CSRF Token validation\n* Mitigate CSRF vulnerability using cookies with `SameSite=Lax`\n* Mitigate CSRF vulnerability by validating the `Origin` header when a form is submited\n* Improve usage of WTForm for all form validation\n* Update installation stepd for debian #162\n* Build Ubuntu packages and publish them to our APT repo\n\n## 2.3.6 (2021-10-20)\n\n* Broken build\n\n## 2.3.5 (2021-10-18)\n\n* Mitigate CSRF vulnerability to user, ssh and repo management with CSRF Token\n\n## 2.3.4 (2021-09-20)\n\n* Skip email notification if `email-host` configuration is not provided #157\n* Skip email notification when the new attribute value has the same value #159\n* USE LDAP `mail` attribute when creating new user from LDAP directory #156\n\n## 2.3.3 (2021-09-10)\n\n* Provide a new theme `blue` to match IKUS Soft colors #158\n\n## 2.3.2 (2021-09-07)\n\n* Automatically update user's repository list based on user's home directory\n\n## 2.3.1 (2021-07-14)\n\n* Update default `session-dir` location to `/var/lib/rdiffweb/session` to avoid using `/var/run` #148\n\n## 2.3.0 (2021-07-06)\n\n* Improve timezone handling to display date with local timezone using javascript #143\n* Improve charts by replacing d3js by chartkick #122\n* Replace the status view by something meaningful with chartkick #122\n* Provide Docker image with Rdiffweb `docker pull ikus060/rdiffweb` #55\n* Fix file and folder sorting #143\n\n## 2.2.0 (2021-05-11)\n\n* Debian package:\n  * Add rdiff-backup as dependencies to comply with Debian packaging rules\n  * Multiple other fixed to control files\n  * Use debhelper-compat (= 13)\n  * Use debhelper-compat (= 13)\n  * Run test during packaging\n  * Create default folder `/var/run/rdiffweb/sessions` to store user session\n* Use ConfigArgPare for configuration to support configuration file, environment variables and arguments to configure rdiffweb #114\n* Fix cache in localization module\n* Add `ldap-add-default-role` and `ldap-add-default-userroot` option to define default value for role and user root when creating user from LDAP #125\n* Support PostgreSQL database by replacing our storage layer by SQLAlchemy #126\n* Fix to retrieve user quota only for valid user_root #135\n* Add option `disable-ssh-keys` to disable SSH Key management\n* Use absolute URL everywhere\n* Add support for `X-Forwarded-For`, `X-Forwarded-proto` and other reverse proxy header when generating absolute URL\n* Drop Debian Stretch support\n* Implement a new background scheduler using apscheduler #82\n* Use background job to send email notification to avoid blocking web page loading #47\n* Use background job to delete repository to avoid blocking web page loading #48\n* Allow deleting a specific file or folder from the history using `rdiff-backup-delete` #128\n* Improve support for `session-dir` #131\n* Add option `admin-password` to define administrator password for better security\n* Improve performance of repository browsing\n* Add a new view to display logs of a specific repository\n* Allow downloading the log\n* Define a default limit to graph statistics to make it display faster\n* Fix `get-quota-cmd` option to properly return a value\n\n## 2.1.0 (2021-01-15)\n\n* Debian package: Remove dh-systemd from Debian build dependencies (<https://bugs.debian.org/871312we>)\n* Improve Quota management:\n  * `QuotaSetCmd`, `QuotaGetCmd` and `QuotaUsedCmd` options could be used to customize how to set the quota for your environment.\n  * Display user's quota in User View\n  * Display user's quota in Admin View\n  * Allow admin to update user quota from Admin View when `QuotaSetCmd` is defined.\n  * Allow admin to define user quota using human readable value (e.g.: GiB, TiB, etc.)\n  * Improve logging around quota management\n* Improve robustness when service is starting\n* Improve robustness when repository has wrong permission defined (e.g.: when some files not readable)\n* Add user id in Admin view\n* Replace `UserObject(1)` by the actual username in log file to improve debugging\n\n## 2.0.0 (2020-12-04)\n\n* Re-implement logic to update repositories views to remove duplicates and avoid nesting repo. #107\n* Handle elapsed time of days in the graph. Thanks [Nathaniel van Diepen](https://github.com/Eeems) contributions.\n* Rebrand all link to ikus-soft.com\n* Update documentation to install rdiffweb\n* Remove obsolete minify dependency\n* Drop support for python2\n* Provide null translation if translation catalogues are not found\n* Pass a LANG environment variable to rdiff-backup restore process to fix encoding issue #112\n* Remove obsolete python shebang\n* Remove execution bit (+x) on python modules\n* Provide `--help` and `--version` on `rdiffweb` executable\n* Improve cherrypy version detection\n* Do not update translation files (.mo) during build\n\n## 1.5.0 (2020-06-24)\n\nThis minor release introduce official support of rdiffweb on Debian Bullseye. It also includes some usability improvements.\n\n* Change formatting of Last Backup date for \"Updated 3 weeks ago\" to ease the readability\n* Add support for Debian Bullseye\n* Add support for Python 3.8 (#104)\n* Add warning in the users list view when a root directory is invalid (#30)\n* Add options to control search depthness (#1)\n* Print a warning in the log when the \"DefaultTheme\" value is not valid (#90)\n\n## 1.4.0 (2020-05-20)\n\nThanks to our sponsor, this release introduce a feature to have better control over the user's permission by defining 3 different levels of privilege: Admin, Maintainer and User. This addition allows you to have better control on what your users can or can't do.\n\n* Fix single repository discovery when a user's home is a rdiff-backup repository\n* [SPONSORED] Add a new setting at the user level to define the user's role. Admin,\n   Maintainer and User. Admin are allowed to do everything. Maintainer are\n   allow to browse and delete repo. Users are only allowed to browse. #94\n* Add \"Powered by\" in the web interface footer #91\n* Display a nice error message when trying to delete admin user #93\n* Introduce usage of wtforms and flash in admin users for better form validation. #96 #97\n* Update French translation\n\n## 1.3.2 (2020-04-23)\n\nThis minor releases fixed issues found while testing release 1.3.0.\n\n* Fix lookup of executable rdiff-backup and rdiffweb-restore to search in current virtualenv first\n* Fix repository view when multiple repo path are conflicting\n* Fix logging of rdiffweb-restore subprocess\n\n## 1.3.1 (2020-04-10)\n\nThis minor release enforces security of the password stored in rdiffweb database to make use of a better encryption using SSHA.\nOnly new passwords will make use of the SSHA scheme.\n\n* Enforce password encryption by using SSHA scheme #88\n\n## 1.3.0 (2020-04-07)\n\nThis release focuses on improving the restore of big archives. The download should be much faster to start. Major enhancement was made to offload the processing outside the web server. And all of this is still compatible with rdiff-backup v1.2.8 and the latest v2.0.0.\n\n* Restore file and folder in a subprocess to make the download start faster\n* Fix encoding of archive on Python3.6 (CentOS 7) by using PAX format\n* Add support to restore files and folders using rdiff-backup2\n* Remove obsolete dependencies `pysqlite2`\n* Fix issue creating duplicate entries of repository in the database\n\n## 1.2.2 (2020-03-05)\n\nThis release provides little improvement to the v1.2.x including official support of rdiff-backup v2.0.0.\n\n* Enhance the repository to invite users to refresh the repository when the view is empty.\n* Support rdiff-backup v2.0.0\n* Deprecate support for cherrypy 4, 5, 6 and 7\n* Improve loading of repository data (cache status and entries)\n* Restore compatibility with SQLite 3.7 (CentOS7)\n\nKnown issues:\n\n* Filename encoding in tar.gz and zip file might not be accurate if you are running Python 3.6 (CentOS7)\n\n## 1.2.1 (2020-02-08)\n\nLittle bug fix following the previous release\n\n* Fix 404 error when trying to access other users repo as admin\n* Fix logging format for cherrypy logs to matches rdiffweb format\n* Add log rotation by default\n\n## 1.2.0 (2020-01-30)\n\nThis release focus on improving the database layers for better extendability to add more type of data and to support more databases backend like postgresql in the near future.\n\n* Add explicit testing for Debian Stretch & Buster\n* Change the persistence layers\n  * Minimize number of SQL queries\n  * Add object lazy loading\n  * Add object data caching\n* Fix bugs with SQLite <= 3.16 (Debian Stretch)\n\n## 1.1.0 (2019-10-31)\n\nThis release focus on improving the admin area and building the fundation for repository access control list (ACL).\n\n* Update documentation from PDSL web site\n* Improve the navigation bar layout\n* Update the login page headline\n* Update jinja2 version to allow 2.10.x\n* Show server log in admin area\n* Reduce code smell\n* Add System information in admin area\n* Validate credential using local database before LDAP\n* Reffactoring templates macros\n* Enhance user's view search bar\n* Change repository URL to username/repopath\n* Add System information in admin area\n* Improve testcases\n* Clean-up obsolete code\n* Fix issue with captital case encoding name\n* Fix compilation of less files\n* Fix google font import\n\n## 1.0.3 (2019-10-04)\n\n* Removing the auto update repos\n\n## 1.0.2 (2019-10-01)\n\n* Create \"admin\" user if missing\n* Update french translation\n\n## 1.0.1 (2019-09-22)\n\n* Update installation documentation\n* Fix removal of SSH Key\n* Return meaningful error to the user trying to add an existing SSH key\n\n## 1.0.0 (2019-09-11)\n\n* Make repository removal more robust\n* Improve performance of librdiff\n* Add new RESTful api\n* Return the right HTTP 401 or 402 error code for authentication\n* Fix bug introduce by upgrade to Jinja2 + python3\n* Store ssh keys in database and disk\n* Add support for theme (default, orange)\n* Remove deprecated profiling code\n* Add disk usage support / quota\n* Add support of cherrypy v18\n* Drop support of cherrypy v3.2.2\n* Add wsgi entry point\n* Replace the plugins architecture to ease implementation\n* Numerous bug fixes\n\n## 0.10.9 (2019-05-22)\n\n* Better error handling when error.log file are not valid gzip file\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nCreated on Dec 26, 2015\n\n@author: Patrik Dufresne\n\"\"\"\nimport os\n\nfrom parameterized import parameterized, parameterized_class\n\nimport rdiffweb.test\nfrom rdiffweb.core.model import DbSession, SessionObject, UserObject\nfrom rdiffweb.tools.auth_form import LOGIN_TIME, SESSION_KEY\n\n\nclass LoginPageTest(rdiffweb.test.WebCase):\n    def test_getpage(self):\n        # When making a query to a page while unauthenticated\n        self.getPage('/')\n        # Then user is redirected to login page\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/login/')\n        # Then a session object is created without a username\n        self.assertEqual(1, SessionObject.query.filter(SessionObject.id == self.session_id).count())\n        SessionObject.query.filter(SessionObject.id == self.session_id).first()\n        session = DbSession(id=self.session_id)\n        session.load()\n        self.assertIsNone(session.get(SESSION_KEY))\n\n    def test_login_success(self):\n        # Given an anonymous user\n        self.getPage('/')\n        prev_session_id = self.session_id\n        # Then user is redirected to /login page\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/login/')\n        # When authenticating with valid credentials.\n        self.getPage('/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD})\n        # Then a new session_id is generated\n        self.assertNotEqual(prev_session_id, self.session_id)\n        # Then user is redirected\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/')\n        # Then a session object is created with a username\n        self.assertEqual(1, SessionObject.query.filter(SessionObject.id == self.session_id).count())\n        SessionObject.query.filter(SessionObject.id == self.session_id).first()\n        session = DbSession(id=self.session_id)\n        session.load()\n        self.assertEqual('admin', session.get(SESSION_KEY))\n        self.assertIsNotNone(session.get(LOGIN_TIME))\n\n    def test_login_case_insensitive(self):\n        # When authenticating with valid credentials with all uppercase username\n        self.getPage('/login/', method='POST', body={'login': self.USERNAME.upper(), 'password': self.PASSWORD})\n        # Then a new session_id is generated\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/')\n        self.getPage('/')\n        self.assertStatus(200)\n\n    def test_cookie_http_only(self):\n        # Given a request made to rdiffweb\n        # When receiving the response\n        self.getPage('/')\n        # Then the header contains Set-Cookie with HttpOnly\n        cookie = self.assertHeader('Set-Cookie')\n        self.assertIn('HttpOnly', cookie)\n\n    def test_login_with_plaintext(self):\n        \"\"\"\n        Requesting plain text without being authenticated should show the login form.\n        \"\"\"\n        # When querying root page without authentication\n        self.getPage('/', headers=[(\"Accept\", \"text/plain\")])\n        # Then user is redirected to /login page\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/login/')\n\n    @parameterized.expand(\n        [\n            ('with_root', '/'),\n            ('with_browse_url', '/browse/admin/testcases/Revisions/'),\n            ('with_encoded_url', '/browse/admin/testcases/DIR%EF%BF%BD/'),\n            (\n                'with_broken_encoding',\n                '/restore/admin/testcases/Fichier%20avec%20non%20asci%20char%20%C9velyne%20M%E8re.txt/?date=1415221507',\n            ),\n            ('with_query_string', '/restore/admin/testcases/Revisions?date=1477434528'),\n            ('with_multiple_query_string', '/restore/admin/testcases/Revisions?date=1477434528&kind=tar.gz'),\n            ('with_admin', '/admin/'),\n        ]\n    )\n    def test_login(self, unused, original_url):\n        # Given an unauthenticated user\n        # Query the page without login-in\n        self.getPage(original_url)\n        # Then user is redirected to the login page\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/login/')\n        # When authentication is successful\n        self.getPage('/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD})\n        # Then user is redirected to original URL\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + original_url)\n        # Then cookie is not persistent\n        self.assertNotIn('expires', self.cookies[0][1])\n        self.assertNotIn('Max-Age', self.cookies[0][1])\n        # When requesting the original page\n        self.getPage(original_url)\n        # Then page return without error\n        self.assertStatus(200)\n\n    def test_getpage_with_redirect_post(self):\n        \"\"\"\n        Check encoding of redirect url when send using POST method.\n        \"\"\"\n        # When posting invalid credentials\n        b = {'login': 'admin', 'password': 'invalid', 'redirect': '/browse/' + self.REPO + '/DIR%EF%BF%BD/'}\n        self.getPage('/login/', method='POST', body=b)\n        # Then page return without HTTP Error\n        self.assertStatus('200 OK')\n        # Then page display an error\n        self.assertInBody('Invalid username or password.')\n        self.assertInBody('form-login')\n        # Then redirect URL is ignored\n        self.assertNotInBody('/browse/' + self.REPO + '/DIR%EF%BF%BD/\"')\n\n    def test_getpage_without_username(self):\n        \"\"\"\n        Check if error is raised when requesting /login without a username.\n        \"\"\"\n        self.getPage('/login/', method='GET')\n        self.assertStatus('200 OK')\n\n    def test_getpage_with_username_too_long(self):\n        b = {'login': 'admin' * 52, 'password': 'admin123'}\n        self.getPage('/login/', method='POST', body=b)\n        self.assertStatus('200 OK')\n        self.assertInBody('Username too long.')\n\n    def test_getpage_with_empty_password(self):\n        \"\"\"\n        Check if authentication is failing without a password.\n        \"\"\"\n        b = {'login': 'admin', 'password': ''}\n        self.getPage('/login/', method='POST', body=b)\n        self.assertStatus('200 OK')\n        self.assertInBody('This field is required.')\n\n    def test_getpage_with_invalid_url(self):\n        self.getPage('/login/kefuxian.mvc', method='GET')\n        self.assertStatus('303 See Other')\n\n    def test_post_with_invalid_url(self):\n        self.getPage('/login/kefuxian.mvc', method='POST')\n        self.assertStatus('303 See Other')\n\n    def test_login_twice(self):\n        # Given an authenticated user\n        self.getPage('/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD})\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + \"/\")\n        self.getPage('/')\n        self.assertStatus(200)\n        self.assertInBody(self.USERNAME)\n        # Given another user\n        userobj = UserObject.add_user('otheruser', password='password')\n        userobj.commit()\n        # When trying to re-authenticated with login page\n        self.getPage('/login/', method='POST', body={'login': 'otheruser', 'password': 'password'})\n        # Then user is still authenticated with previous user\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + \"/\")\n        self.getPage('/')\n        self.assertStatus(200)\n        self.assertInBody(self.USERNAME)\n\n    def test_login_persistent(self):\n        # Given a user authenticated with persistent\n        self.getPage('/logout', method=\"POST\")\n        self.assertStatus(303)\n        self.getPage(\n            '/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD, 'persistent': '1'}\n        )\n        self.assertStatus(303)\n        # Then a persistent cookie is return\n        self.assertIn('expires', self.cookies[0][1])\n        self.assertIn('Max-Age', self.cookies[0][1])\n        # Then a session is created with persistent flag\n        session = DbSession(id=self.session_id)\n        session.load()\n        self.assertTrue(session['login_persistent'])\n        # Then session timeout is 30 days in future\n        self.assertAlmostEqual(session.timeout, 43200, delta=2)\n\n\nclass LoginPageWithWelcomeMsgTest(rdiffweb.test.WebCase):\n\n    default_config = {'welcomemsg': 'default message', 'welcomemsg[fr]': 'french message'}\n\n    def test_getpage_default(self):\n        \"\"\"\n        Make sure the login page can be rendered without error.\n        \"\"\"\n        self.getPage('/login/', headers=[(\"Accept-Language\", \"it\")])\n        self.assertStatus('200 OK')\n        self.assertInBody('default message')\n\n    def test_getpage_french(self):\n        \"\"\"\n        Make sure the login page can be rendered without error.\n        \"\"\"\n        self.getPage('/login/', headers=[(\"Accept-Language\", \"fr\")])\n        self.assertStatus('200 OK')\n        self.assertInBody('french message')\n\n\nclass LoginPageWithHeaderName(rdiffweb.test.WebCase):\n\n    default_config = {'header-name': 'HEADER-NAME'}\n\n    def test_getpage_default(self):\n        # Given a custom header-name\n        # When querying the loging page\n        self.getPage('/login/')\n        # Then the page display the header-name\n        self.assertStatus('200 OK')\n        self.assertInBody('HEADER-NAME')\n\n\n@parameterized_class(\n    [\n        {\"default_config\": {'rate-limit': 5}},\n        {\"default_config\": {'rate-limit': 5, 'rate-limit-dir': '/tmp'}},\n    ]\n)\nclass LoginPageRateLimitTest(rdiffweb.test.WebCase):\n    def setUp(self):\n        if os.path.isfile('/tmp/ratelimit-127.0.0.1'):\n            os.unlink('/tmp/ratelimit-127.0.0.1')\n        if os.path.isfile('/tmp/ratelimit-127.0.0.1.-login'):\n            os.unlink('/tmp/ratelimit-127.0.0.1.-login')\n        return super().setUp()\n\n    def test_login_ratelimit(self):\n        # Given an unauthenticate\n        # When requesting multiple time the login page\n        for i in range(1, 5):\n            self.getPage('/login/', method='POST', body={'login': 'invalid', 'password': 'invalid'})\n            self.assertStatus(200)\n        # Then a 429 error (too many request) is return\n        self.getPage('/login/', method='POST', body={'login': 'invalid', 'password': 'invalid'})\n        self.assertStatus(429)\n\n\nclass LoginPageRateLimitTest2(rdiffweb.test.WebCase):\n\n    default_config = {'rate-limit': 5}\n\n    def test_login_ratelimit_forwarded_for(self):\n        # Given an unauthenticate\n        # When requesting multiple time the login page with different `X-Forwarded-For`\n        for i in range(1, 5):\n            self.getPage(\n                '/login/',\n                headers=[('X-Forwarded-For', '127.0.0.%s' % i)],\n                method='POST',\n                body={'login': 'invalid', 'password': 'invalid'},\n            )\n            self.assertStatus(200)\n        # Then original IP get blocked\n        self.getPage(\n            '/login/',\n            headers=[('X-Forwarded-For', '127.0.0.%s' % i)],\n            method='POST',\n            body={'login': 'invalid', 'password': 'invalid'},\n        )\n        self.assertStatus(429)\n\n\nclass LoginPageRateLimitTest3(rdiffweb.test.WebCase):\n    default_config = {'rate-limit': 5}\n\n    def test_login_ratelimit_real_ip(self):\n        # Given an unauthenticate\n        # When requesting multiple time the login page with different `X-Real-IP`\n        for i in range(1, 5):\n            self.getPage(\n                '/login/',\n                headers=[('X-Real-IP', '127.0.0.128')],\n                method='POST',\n                body={'login': 'invalid', 'password': 'invalid'},\n            )\n            self.assertStatus(200)\n        # Then the X-Real-IP get blocked\n        self.getPage(\n            '/login/',\n            headers=[('X-Real-IP', '127.0.0.128')],\n            method='POST',\n            body={'login': 'invalid', 'password': 'invalid'},\n        )\n        self.assertStatus(429)\n\n\nclass LogoutPageTest(rdiffweb.test.WebCase):\n    def test_getpage_without_login(self):\n        # Given an unauthenticated user\n        # When Accessing logout page directly\n        self.getPage('/logout', method=\"POST\")\n        # Then user is redirect to root '/'\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/')\n\n    def test_getpage_with_login(self):\n        # Given an anonymous user\n        self.getPage('/')\n        prev_session_id = self.session_id\n        # Login\n        b = {'login': 'admin', 'password': 'admin123'}\n        self.getPage('/login/', method='POST', body=b)\n        self.assertStatus('303 See Other')\n        # Then a new session id is generated\n        self.assertNotEqual(prev_session_id, self.session_id)\n        prev_session_id = self.session_id\n        # Get content of a page.\n        self.getPage(\"/prefs/general\")\n        self.assertStatus('200 OK')\n        # When logout\n        self.getPage('/logout', method=\"POST\")\n        # Then a new session id is generated\n        self.assertNotEqual(prev_session_id, self.session_id)\n        # Then user is redirected to root page\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/')\n        # Get content of a page.\n        self.getPage(\"/prefs/general\")\n        self.assertStatus('303 See Other')\n        self.assertHeaderItemValue('Location', self.baseurl + '/login/')\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nCreated on Dec 26, 2015\n\n@author: Patrik Dufresne\n\"\"\"\n\nfrom unittest.mock import MagicMock\n\nimport cherrypy\nfrom parameterized import parameterized\n\nimport rdiffweb.test\nfrom rdiffweb.core.model import RepoObject, SessionObject, UserObject\n\n\nclass PagePrefGeneralTest(rdiffweb.test.WebCase):\n\n    PREFS = \"/prefs/general\"\n\n    login = True\n\n    def setUp(self):\n        self.listener = MagicMock()\n        cherrypy.engine.subscribe('user_password_changed', self.listener.user_password_changed, priority=50)\n        return super().setUp()\n\n    def tearDown(self):\n        cherrypy.engine.unsubscribe('user_password_changed', self.listener.user_password_changed)\n        return super().tearDown()\n\n    def _set_password(\n        self,\n        current,\n        new_password,\n        confirm,\n    ):\n        b = {\n            'action': 'set_password',\n            'current': current,\n            'new': new_password,\n            'confirm': confirm,\n        }\n        return self.getPage(self.PREFS, method='POST', body=b)\n\n    def _set_profile_info(self, email, fullname=None):\n        b = {\n            'action': 'set_profile_info',\n            'email': email,\n        }\n        if fullname:\n            b['fullname'] = fullname\n        return self.getPage(self.PREFS, method='POST', body=b)\n\n    def test_get_page(self):\n        # When querying the page\n        self.getPage(self.PREFS)\n        # Then the page is returned\n        self.assertStatus(200)\n        self.assertInBody('User profile')\n\n    def test_change_username_noop(self):\n        # Given an authenticated user\n        # When updating the username\n        self.getPage(\n            self.PREFS,\n            method='POST',\n            body={'action': 'set_profile_info', 'email': 'test@test.com', 'username': 'test'},\n        )\n        self.assertStatus(303)\n        self.getPage(self.PREFS)\n        self.assertInBody(\"Profile updated successfully.\")\n        # Then database is not updated with new username.\n        user = UserObject.get_user(self.USERNAME)\n        self.assertIsNotNone(user)\n        self.assertEqual(\"test@test.com\", user.email)\n\n    @parameterized.expand(\n        [\n            # Invalid\n            ('@test.com', False),\n            ('test.com', False),\n            ('test@te_st.com', False),\n            ('test@test.com, test2@test.com', False),\n            # Valid\n            ('test', True),\n            ('My Fullname', True),\n        ]\n    )\n    def test_change_fullname(self, new_fullname, expected_valid):\n        # Given an authenticated user\n        # When update the fullname\n        self._set_profile_info(\"test@test.com\", new_fullname)\n        if expected_valid:\n            self.assertStatus(303)\n            self.getPage(self.PREFS)\n            self.assertInBody(\"Profile updated successfully.\")\n            # Then database is updated with fullname\n            self.assertInBody(new_fullname)\n            user = UserObject.get_user(self.USERNAME)\n            self.assertEqual(new_fullname, user.fullname)\n        else:\n            self.assertStatus(200)\n            self.assertNotInBody(\"Profile updated successfully.\")\n\n    def test_change_fullname_method_get(self):\n        # Given an authenticated user\n        # When trying to update full name using GET method\n        self.getPage(self.PREFS + '?action=set_profile_info&email=test@test.com')\n        # Then nothing happen\n        self.assertStatus(200)\n        self.assertNotInBody(\"Profile updated successfully.\")\n        user = UserObject.get_user(self.USERNAME)\n        self.assertEqual(\"\", user.fullname)\n\n    def test_change_fullname_too_long(self):\n        # Given an authenticated user\n        # When update the fullname\n        self._set_profile_info(\"test@test.com\", \"Fullname\" * 50)\n        # Then page return with error message\n        self.assertStatus(200)\n        self.assertNotInBody(\"Profile updated successfully.\")\n        self.assertInBody(\"Fullname too long.\")\n        # Then database is not updated\n        user = UserObject.get_user(self.USERNAME)\n        self.assertEqual(\"\", user.fullname)\n\n    def test_change_email(self):\n        self._set_profile_info(\"test@test.com\")\n        self.assertStatus(303)\n        self.getPage(self.PREFS)\n        self.assertInBody(\"Profile updated successfully.\")\n\n    @parameterized.expand(\n        [\n            # Invalid\n            ('@test.com', False),\n            ('test.com', False),\n            ('test', False),\n            ('test@te_st.com', False),\n            ('test@test.com, test2@test.com', False),\n            # Valid\n            ('test@test.com', True),\n        ]\n    )\n    def test_change_email_with_invalid_email(self, new_email, expected_valid):\n        self._set_profile_info(new_email)\n        if expected_valid:\n            self.assertStatus(303)\n            self.getPage(self.PREFS)\n            self.assertInBody(\"Profile updated successfully.\")\n            self.assertNotInBody(\"Must be a valid email address.\")\n        else:\n            self.assertStatus(200)\n            self.assertNotInBody(\"Profile updated successfully.\")\n            self.assertInBody(\"Must be a valid email address.\")\n\n    def test_change_email_with_too_long(self):\n        self._set_profile_info((\"test1\" * 50) + \"@test.com\")\n        self.assertInBody(\"Email too long.\")\n\n    def test_change_password(self):\n        # Given a user with 3 active sessions\n        self.cookies = None\n        self._login(self.USERNAME, self.PASSWORD)\n        self.cookies = None\n        self._login(self.USERNAME, self.PASSWORD)\n        self.assertEqual(3, SessionObject.query.count())\n        # When udating user's password\n        self.listener.user_password_changed.reset_mock()\n        self._set_password(self.PASSWORD, \"pr3j5Dwi\", \"pr3j5Dwi\")\n        # Then user is redirect to same page\n        self.assertStatus(303)\n        # Then the page return success message.\n        self.getPage(self.PREFS)\n        self.assertInBody(\"Password updated successfully.\")\n        # Then a notification is raised\n        self.listener.user_password_changed.assert_called_once()\n        # Then all users session get deleted except our own session.\n        self.assertEqual(1, SessionObject.query.count())\n        self.assertEqual(self.session_id, SessionObject.query.first().id)\n\n    def test_change_password_with_wrong_confirmation(self):\n        self._set_password(self.PASSWORD, \"t\", \"a\")\n        self.assertInBody(\"The new password and its confirmation do not match.\")\n\n    def test_change_password_with_wrong_password(self):\n        self._set_password(\"oups\", \"pr3j5Dwi\", \"pr3j5Dwi\")\n        self.assertInBody(\"Wrong current password\")\n\n    def test_change_password_with_too_short(self):\n        self._set_password(self.PASSWORD, \"short\", \"short\")\n        self.assertInBody(\"Password must have between 8 and 128 characters.\")\n\n    def test_change_password_with_too_long(self):\n        new_password = 'a' * 129\n        self._set_password(self.PASSWORD, new_password, new_password)\n        self.assertInBody(\"Password must have between 8 and 128 characters.\")\n\n    def test_change_password_with_same_value(self):\n        # Given a user with a password\n        self._set_password(self.PASSWORD, \"pr3j5Dwi\", \"pr3j5Dwi\")\n        self.assertStatus(303)\n        # When updating the pasword with the same password\n        self._set_password(\"pr3j5Dwi\", \"pr3j5Dwi\", \"pr3j5Dwi\")\n        self.assertStatus(200)\n        # Then an error should be displayed\n        self.assertInBody(\"The new password must be different from the current password.\")\n\n    def test_change_password_method_get(self):\n        # Given an authenticated user\n        # Trying to update password with GET method\n        self.getPage(self.PREFS + '?action=set_password&new=pr3j5Dwi&confirm=pr3j5Dwi&current=' + self.PASSWORD)\n        # Then nothing happen\n        self.assertStatus(200)\n        self.assertNotInBody(\"Password updated successfully.\")\n\n    def test_invalid_pref(self):\n        \"\"\"\n        Check if invalid prefs url is 404 Not Found.\n        \"\"\"\n        self.getPage(\"/prefs/invalid/\")\n        self.assertStatus(404)\n\n    def test_update_repos(self):\n        # Given a user with invalid repositories\n        userobj = UserObject.get_user(self.USERNAME)\n        RepoObject(userid=userobj.userid, repopath='invalid').add().commit()\n        self.assertEqual(['broker-repo', 'invalid', 'testcases'], sorted([r.name for r in userobj.repo_objs]))\n        # When updating the repository list\n        self.getPage(self.PREFS, method='POST', body={'action': 'update_repos'})\n        self.assertStatus(200)\n        # Then a success message is displayed\n        self.assertInBody('Repositories successfully updated')\n        # Then the list is free of inexisting repos.\n        userobj.expire()\n        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in userobj.repo_objs]))\n\n\nclass PagePrefGeneralRateLimitTest(rdiffweb.test.WebCase):\n    login = True\n\n    default_config = {'rate-limit': 5}\n\n    def test_change_password_too_many_attemps(self):\n        # When udating user's password with wrong current password 5 times\n        for _i in range(1, 5):\n            self.getPage(\n                '/prefs/general',\n                method='POST',\n                body={'action': 'set_password', 'current': 'wrong', 'new': 'pr3j5Dwi', 'confirm': 'pr3j5Dwi'},\n            )\n            self.assertStatus(200)\n            self.assertInBody(\"Wrong current password.\")\n        # Then user session is cleared and user is redirect to login page\n        self.getPage(\n            '/prefs/general',\n            method='POST',\n            body={'action': 'set_password', 'current': 'wrong', 'new': 'pr3j5Dwi', 'confirm': 'pr3j5Dwi'},\n        )\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + '/')\n        # Then a warning message is displayed on login page\n        self.getPage('/login/')\n        self.assertStatus(200)\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport logging\n\nimport cherrypy\nfrom cherrypy.process.plugins import SimplePlugin\n\nfrom rdiffweb.core.model import UserObject\n\nlogger = logging.getLogger(__name__)\n\n\nclass LoginPlugin(SimplePlugin):\n    \"\"\"\n    This plugins register an \"authenticate\" listener to validate\n    username and password of users. In addition, it provide a \"login\"\n    listener to authenticate and possibly create the user in database.\n    \"\"\"\n\n    add_missing_user = False\n    add_user_default_role = UserObject.USER_ROLE\n    add_user_default_userroot = None\n\n    def start(self):\n        self.bus.log('Start Login plugin')\n        self.bus.subscribe(\"authenticate\", self.authenticate)\n        self.bus.subscribe(\"login\", self.login)\n\n    def stop(self):\n        self.bus.log('Stop Login plugin')\n        self.bus.unsubscribe(\"authenticate\", self.authenticate)\n        self.bus.unsubscribe(\"login\", self.login)\n\n    def authenticate(self, username, password):\n        \"\"\"\n        Only verify the user's credentials using the database store.\n        \"\"\"\n        user = UserObject.get_user(username)\n        if user and user.validate_password(password):\n            return username, {}\n        return False\n\n    def login(self, username, password):\n        \"\"\"\n        Validate username password using database and LDAP.\n        \"\"\"\n        # Validate credentials.\n        authenticates = self.bus.publish('authenticate', username, password)\n        authenticates = [a for a in authenticates if a]\n        if not authenticates:\n            return None\n        real_username = authenticates[0][0]\n        extra_attrs = authenticates[0][1]\n        fullname = extra_attrs.get('_fullname', None)\n        email = extra_attrs.get('_email', None)\n        # When enabled, create missing userobj in database.\n        userobj = UserObject.get_user(username)\n        if userobj is None and self.add_missing_user:\n            try:\n                # At this point, we need to create a new user in database.\n                # In case default values are invalid, let evaluate them\n                # before creating the user in database.\n                default_user_root = self.add_user_default_userroot and self.add_user_default_userroot.format(\n                    **extra_attrs\n                )\n                default_role = UserObject.ROLES.get(self.add_user_default_role)\n                userobj = UserObject.add_user(\n                    username=real_username,\n                    fullname=fullname,\n                    email=email,\n                    role=default_role,\n                    user_root=default_user_root,\n                ).commit()\n            except Exception:\n                logger.error('fail to create new user', exc_info=1)\n        if userobj is None:\n            # User doesn't exists in database\n            return None\n\n        # Update user attributes\n        dirty = False\n        if fullname:\n            userobj.fullname = fullname\n            dirty = True\n        if email:\n            userobj.email = email\n            dirty = True\n        if dirty:\n            userobj.commit()\n        self.bus.publish('user_login', userobj)\n        return userobj\n\n\ncherrypy.login = LoginPlugin(cherrypy.engine)\ncherrypy.login.subscribe()\n\ncherrypy.config.namespaces['login'] = lambda key, value: setattr(cherrypy.login, key, value)\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport logging\nimport sys\n\nimport cherrypy\nfrom sqlalchemy import event\nfrom sqlalchemy.exc import IntegrityError\n\nfrom ._repo import RepoObject  # noqa\nfrom ._session import DbSession, SessionObject  # noqa\nfrom ._sshkey import SshKey  # noqa\nfrom ._token import Token  # noqa\nfrom ._user import DuplicateSSHKeyError, UserObject, user_username_index  # noqa\n\nBase = cherrypy.tools.db.get_base()\n\nlogger = logging.getLogger(__name__)\n\n\ndef _column_add(connection, column):\n    if _column_exists(connection, column):\n        return\n    table_name = column.table.fullname\n    column_name = column.name\n    column_type = column.type.compile(connection.engine.dialect)\n    connection.engine.execute('ALTER TABLE %s ADD COLUMN %s %s' % (table_name, column_name, column_type))\n\n\ndef _column_exists(connection, column):\n    table_name = column.table.fullname\n    column_name = column.name\n    if 'SQLite' in connection.engine.dialect.__class__.__name__:\n        sql = \"SELECT COUNT(*) FROM pragma_table_info('%s') WHERE LOWER(name)=LOWER('%s')\" % (\n            table_name,\n            column_name,\n        )\n    else:\n        sql = \"SELECT COUNT(*) FROM information_schema.columns WHERE table_name='%s' and column_name='%s'\" % (\n            table_name,\n            column_name,\n        )\n    data = connection.engine.execute(sql).first()\n    return data[0] >= 1\n\n\ndef _index_exists(connection, index_name):\n    if 'SQLite' in connection.engine.dialect.__class__.__name__:\n        sql = \"SELECT name FROM sqlite_master WHERE type = 'index' AND name = '%s';\" % (index_name)\n    else:\n        sql = \"SELECT * FROM pg_indexes WHERE indexname = '%s'\" % (index_name)\n    return connection.engine.execute(sql).first() is not None\n\n\n@event.listens_for(Base.metadata, 'after_create')\ndef db_after_create(target, connection, **kw):\n    \"\"\"\n    Called on database creation to update database schema.\n    \"\"\"\n\n    if getattr(connection, '_transaction', None):\n        connection._transaction.commit()\n\n    # Add repo's Encoding\n    _column_add(connection, RepoObject.__table__.c.Encoding)\n    _column_add(connection, RepoObject.__table__.c.keepdays)\n\n    # Create column for roles using \"isadmin\" column. Keep the\n    # original column in case we need to revert to previous version.\n    if not _column_exists(connection, UserObject.__table__.c.role):\n        _column_add(connection, UserObject.__table__.c.role)\n        UserObject.query.filter(UserObject._is_admin == 1).update({UserObject.role: UserObject.ADMIN_ROLE})\n\n    # Add user's fullname column\n    _column_add(connection, UserObject.__table__.c.fullname)\n\n    # Add user's mfa column\n    _column_add(connection, UserObject.__table__.c.mfa)\n\n    # Re-create session table if Number column is missing\n    if not _column_exists(connection, SessionObject.__table__.c.Number):\n        SessionObject.__table__.drop()\n        SessionObject.__table__.create()\n\n    if getattr(connection, '_transaction', None):\n        connection._transaction.commit()\n\n    # Remove preceding and leading slash (/) generated by previous\n    # versions. Also rename '.' to ''\n    result = RepoObject.query.all()\n    for row in result:\n        if row.repopath.startswith('/') or row.repopath.endswith('/'):\n            row.repopath = row.repopath.strip('/')\n            row.commit()\n        if row.repopath == '.':\n            row.repopath = ''\n            row.commit()\n    # Remove duplicates and nested repositories.\n    result = RepoObject.query.order_by(RepoObject.userid, RepoObject.repopath).all()\n    prev_repo = (None, None)\n    for row in result:\n        if prev_repo[0] == row.userid and (prev_repo[1] == row.repopath or row.repopath.startswith(prev_repo[1] + '/')):\n            row.delete()\n        else:\n            prev_repo = (row.userid, row.repopath)\n\n    # Fix username case insensitive unique\n    if not _index_exists(connection, 'user_username_index'):\n        duplicate_users = (\n            UserObject.query.with_entities(func.lower(UserObject.username))\n            .group_by(func.lower(UserObject.username))\n            .having(func.count(UserObject.username) > 1)\n        ).all()\n        try:\n            user_username_index.create()\n        except IntegrityError:\n            msg = (\n                'Failure to upgrade your database to make Username case insensitive. '\n                'You must downgrade and deleted duplicate Username. '\n                '%s' % '\\n'.join([str(k) for k in duplicate_users]),\n            )\n            logger.error(msg)\n            print(msg, file=sys.stderr)\n            raise SystemExit(12)\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\nimport logging\nimport os\nimport secrets\nimport string\n\nimport cherrypy\nfrom sqlalchemy import Column, Index, Integer, SmallInteger, String, and_, event, func, inspect, or_\nfrom sqlalchemy.exc import IntegrityError\nfrom sqlalchemy.ext.hybrid import hybrid_property\nfrom sqlalchemy.orm import deferred, relationship, validates\nfrom zxcvbn import zxcvbn\n\nimport rdiffweb.tools.db  # noqa\nfrom rdiffweb.core import authorizedkeys\nfrom rdiffweb.core.passwd import check_password, hash_password\nfrom rdiffweb.tools.i18n import ugettext as _\n\nfrom ._repo import RepoObject\nfrom ._session import SessionObject\nfrom ._sshkey import SshKey\nfrom ._token import Token\n\nlogger = logging.getLogger(__name__)\n\nBase = cherrypy.tools.db.get_base()\n\nSEP = b'/'\n\n\nclass DuplicateSSHKeyError(Exception):\n    \"\"\"\n    Raised by add_authorizedkey when trying to add the same SSH Key twice.\n    \"\"\"\n\n    pass\n\n\nclass UserObject(Base):\n    __tablename__ = 'users'\n    __table_args__ = {'sqlite_autoincrement': True}\n\n    # Value for role.\n    ADMIN_ROLE = 0\n    MAINTAINER_ROLE = 5\n    USER_ROLE = 10\n    ROLES = {\n        'admin': ADMIN_ROLE,\n        'maintainer': MAINTAINER_ROLE,\n        'user': USER_ROLE,\n    }\n    # Value for mfa field\n    DISABLED_MFA = 0\n    ENABLED_MFA = 1\n\n    # Regex pattern to be used for validation.\n    PATTERN_EMAIL = r\"[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}$\"\n    PATTERN_FULLNAME = r\"\"\"[^!\"#$%&()*+,./:;<=>?@[\\]_{|}~]+$\"\"\"\n    PATTERN_USERNAME = r\"[a-zA-Z0-9_.\\-]+$\"\n\n    userid = Column('UserID', Integer, primary_key=True)\n    username = Column('Username', String, nullable=False)\n    hash_password = Column('Password', String, nullable=False, default=\"\")\n    user_root = Column('UserRoot', String, nullable=False, default=\"\")\n    _is_admin = deferred(\n        Column(\n            'IsAdmin',\n            SmallInteger,\n            nullable=False,\n            server_default=\"0\",\n            doc=\"DEPRECATED This column is replaced by 'role'\",\n        )\n    )\n    email = Column('UserEmail', String, nullable=False, default=\"\")\n    restore_format = deferred(\n        Column(\n            'RestoreFormat',\n            SmallInteger,\n            nullable=False,\n            server_default=\"1\",\n            doc=\"DEPRECATED This column is not used anymore\",\n        )\n    )\n    role = Column('role', SmallInteger, nullable=False, server_default=str(USER_ROLE), default=USER_ROLE)\n    fullname = Column('fullname', String, nullable=False, default=\"\")\n    mfa = Column('mfa', SmallInteger, nullable=False, default=DISABLED_MFA)\n    repo_objs = relationship(\n        'RepoObject',\n        foreign_keys='UserObject.userid',\n        primaryjoin='UserObject.userid == RepoObject.userid',\n        uselist=True,\n        lazy=True,\n        order_by=lambda: RepoObject.repopath,\n    )\n\n    @classmethod\n    def get_user(cls, user):\n        \"\"\"Return a user object with username case-insensitive\"\"\"\n        return UserObject.query.filter(func.lower(UserObject.username) == user.lower()).first()\n\n    @classmethod\n    def create_admin_user(cls, default_username, default_password):\n        # Check if admin user exists. If not, created it.\n        userobj = UserObject.get_user(default_username)\n        if not userobj:\n            userobj = cls.add_user(default_username, role=UserObject.ADMIN_ROLE, user_root='/backups')\n            userobj.hash_password = hash_password('admin123')\n        # Also make sure to update the password with latest value from config file.\n        if default_password:\n            if default_password.startswith('{SSHA}') or default_password.startswith('$argon2'):\n                userobj.hash_password = default_password\n            else:\n                userobj.hash_password = hash_password(default_password)\n        userobj.add()\n        return userobj\n\n    @classmethod\n    def add_user(cls, username, password=None, role=USER_ROLE, **attrs):\n        \"\"\"\n        Used to add a new user with an optional password.\n        \"\"\"\n        assert password is None or isinstance(password, str)\n        # Check if user already exists.\n        if UserObject.get_user(username):\n            raise ValueError(_(\"User %s already exists.\" % (username,)))\n\n        # Find a database where to add the user\n        logger.info(\"adding new user [%s]\", username)\n        userobj = UserObject(\n            username=username,\n            hash_password=hash_password(password) if password else '',\n            role=role,\n            **attrs,\n        ).add()\n        # Return user object\n        return userobj\n\n    def add_authorizedkey(self, key, comment=None):\n        \"\"\"\n        Add the given key to the user. Adding the key to his `authorized_keys`\n        file if it exists and adding it to database.\n        \"\"\"\n        # Parse and validate ssh key\n        assert key\n        key = authorizedkeys.check_publickey(key)\n\n        # Remove option, replace comments.\n        key = authorizedkeys.AuthorizedKey(\n            options=None, keytype=key.keytype, key=key.key, comment=comment or key.comment\n        )\n\n        # If a filename exists, use it by default.\n        filename = os.path.join(self.user_root, '.ssh', 'authorized_keys')\n        if os.path.isfile(filename):\n            with open(filename, mode=\"r+\", encoding='utf-8') as fh:\n                if authorizedkeys.exists(fh, key):\n                    raise DuplicateSSHKeyError(_(\"SSH key already exists\"))\n                logger.info(\"add key [%s] to [%s] authorized_keys\", key, self.username)\n                authorizedkeys.add(fh, key)\n        else:\n            # Also look in database.\n            logger.info(\"add key [%s] to [%s] database\", key, self.username)\n            try:\n                SshKey(userid=self.userid, fingerprint=key.fingerprint, key=key.getvalue()).add().flush()\n            except IntegrityError:\n                raise DuplicateSSHKeyError(\n                    _(\"Duplicate key. This key already exists or is associated to another user.\")\n                )\n        cherrypy.engine.publish('user_attr_changed', self, {'authorizedkeys': True})\n        cherrypy.engine.publish('authorizedkey_added', self, fingerprint=key.fingerprint, comment=comment)\n\n    def add_access_token(self, name, expiration_time=None, length=16):\n        \"\"\"\n        Create a new access token. Return the un-encrypted value of the token.\n        \"\"\"\n        assert name\n        assert length >= 8\n        # Generate a random token\n        token = ''.join(secrets.choice(string.ascii_lowercase) for i in range(length))\n        # Store hash token\n        try:\n            Token(\n                userid=self.userid, name=name, hash_token=hash_password(token), expiration_time=expiration_time\n            ).add().flush()\n        except IntegrityError:\n            raise ValueError(_(\"Duplicate token name: %s\") % name)\n        cherrypy.engine.publish('access_token_added', self, name)\n        return token\n\n    def valid_user_root(self):\n        \"\"\"\n        Check if the current user_root is valid and readable\n        \"\"\"\n        try:\n            return os.access(self.user_root, os.F_OK) and os.path.isdir(self.user_root)\n        except Exception:\n            return False\n\n    def delete(self, *args, **kwargs):\n        cfg = cherrypy.tree.apps[''].cfg\n        if self.username == cfg.admin_user:\n            raise ValueError(_(\"can't delete admin user\"))\n        # FIXME This should be deleted by cascade\n        SshKey.query.filter(SshKey.userid == self.userid).delete()\n        RepoObject.query.filter(RepoObject.userid == self.userid).delete()\n        Token.query.filter(Token.userid == self.userid).delete()\n        # Delete ourself\n        return Base.delete(self)\n\n    def delete_authorizedkey(self, fingerprint):\n        \"\"\"\n        Remove the given key from the user. Remove the key from his\n        `authorized_keys` file if it exists and from database database.\n        \"\"\"\n        # If a filename exists, use it by default.\n        filename = os.path.join(self.user_root, '.ssh', 'authorized_keys')\n        if os.path.isfile(filename):\n            with open(filename, mode='r+', encoding='utf-8') as fh:\n                logger.info(\"removing key [%s] from [%s] authorized_keys\", fingerprint, self.username)\n                authorizedkeys.remove(fh, fingerprint)\n        else:\n            # Also look in database.\n            logger.info(\"removing key [%s] from [%s] database\", fingerprint, self.username)\n            SshKey.query.filter(and_(SshKey.userid == self.userid, SshKey.fingerprint == fingerprint)).delete()\n        cherrypy.engine.publish('user_attr_changed', self, {'authorizedkeys': True})\n\n    def delete_access_token(self, name):\n        assert name\n        if not Token.query.filter(Token.userid == self.userid, Token.name == name).delete():\n            raise ValueError(_(\"token name doesn't exists: %s\") % name)\n\n    @property\n    def disk_usage(self):\n        # Skip if user_root is invalid.\n        if not self.user_root or not os.path.exists(self.user_root):\n            return 0\n        values = cherrypy.engine.publish('get_disk_usage', self)\n        # Return the first not None value\n        return next((v for v in values if v is not None), 0)\n\n    @property\n    def disk_quota(self):\n        # Skip if user_root is invalid.\n        if not self.user_root or not os.path.exists(self.user_root):\n            return 0\n        values = cherrypy.engine.publish('get_disk_quota', self)\n        # Return the first not None value\n        return next((v for v in values if v is not None), 0)\n\n    @disk_quota.setter\n    def disk_quota(self, value):\n        # Skip if user_root is invalid.\n        if not self.user_root or not os.path.exists(self.user_root):\n            return\n        cherrypy.engine.publish('set_disk_quota', self, value)\n\n    @property\n    def authorizedkeys(self):\n        \"\"\"\n        Return an iterator on the authorized key. Either from his\n        `authorized_keys` file if it exists or from database.\n        \"\"\"\n        # If a filename exists, use it by default.\n        filename = os.path.join(self.user_root, '.ssh', 'authorized_keys')\n        if os.path.isfile(filename):\n            for k in authorizedkeys.read(filename):\n                yield k\n\n        # Also look in database.\n        for record in SshKey.query.filter(SshKey.userid == self.userid).all():\n            yield authorizedkeys.check_publickey(record.key)\n\n    def refresh_repos(self, delete=False):\n        \"\"\"\n        Return list of repositories object to reflect the filesystem folders.\n\n        Return a RepoObject for each sub directories under `user_root` with `rdiff-backup-data`.\n        \"\"\"\n        # Update the repositories by walking in the directory tree.\n        def _onerror(unused):\n            logger.error('error updating user [%s] repos' % self.username, exc_info=1)\n\n        # Get application config\n        cfg = cherrypy.tree.apps[''].cfg\n\n        dirty = False\n        records = RepoObject.query.filter(RepoObject.userid == self.userid).order_by(RepoObject.repopath).all()\n        user_root = os.fsencode(self.user_root)\n        for root, dirs, unused_files in os.walk(user_root, _onerror):\n            for name in dirs.copy():\n                if name.startswith(b'.'):\n                    dirs.remove(name)\n            if b'rdiff-backup-data' in dirs:\n                repopath = os.path.relpath(root, start=user_root)\n                del dirs[:]\n                # Handle special scenario when the repo is the\n                # user_root\n                repopath = b'' if repopath == b'.' else repopath\n\n                # Check if repo path exists.\n                record_match = next((record for record in records if record.repopath == os.fsdecode(repopath)), None)\n                if not record_match:\n                    # Add repository to database.\n                    RepoObject(user=self, repopath=os.fsdecode(repopath)).add()\n                    dirty = True\n                else:\n                    records.remove(record_match)\n            if root.count(SEP) - user_root.count(SEP) >= cfg.max_depth:\n                del dirs[:]\n        # If enabled, remove entried from database\n        if delete:\n            for record in records:\n                RepoObject.query.filter(RepoObject.repoid == record.repoid).delete()\n        return dirty\n\n    @hybrid_property\n    def is_admin(self):\n        return self.role is not None and self.role <= self.ADMIN_ROLE\n\n    @hybrid_property\n    def is_ldap(self):\n        return self.hash_password is None or self.hash_password == ''\n\n    @is_ldap.expression\n    def is_ldap(cls):\n        return or_(cls.hash_password.is_(None), cls.hash_password == '')\n\n    @hybrid_property\n    def is_maintainer(self):\n        return self.role is not None and self.role <= self.MAINTAINER_ROLE\n\n    def set_password(self, password):\n        \"\"\"\n        Change the user's password. Raise a ValueError if the username or\n        the password are invalid.\n        \"\"\"\n        assert isinstance(password, str)\n        if not password:\n            raise ValueError(\"password can't be empty\")\n        cfg = cherrypy.tree.apps[''].cfg\n\n        # Cannot update admin-password if defined\n        if self.username == cfg.admin_user and cfg.admin_password:\n            raise ValueError(_(\"can't update admin-password defined in configuration file\"))\n\n        # Check password length\n        if cfg.password_min_length > len(password) or len(password) > cfg.password_max_length:\n            raise ValueError(\n                _('Password must have between %(min)d and %(max)d characters.')\n                % {'min': cfg.password_min_length, 'max': cfg.password_max_length}\n            )\n\n        # Verify password score using zxcvbn\n        stats = zxcvbn(password)\n        if stats.get('score') < cfg.password_score:\n            msg = _('Password too weak.')\n            warning = stats.get('feedback', {}).get('warning')\n            suggestions = stats.get('feedback', {}).get('suggestions')\n            if warning:\n                msg += ' ' + warning\n            if suggestions:\n                msg += ' ' + ' '.join(suggestions)\n            raise ValueError(msg)\n\n        # Store password\n        logger.info(\"updating user password [%s] and revoke sessions\", self.username)\n        self.hash_password = hash_password(password)\n\n        # Revoke other session to force re-login\n        session_id = cherrypy.serving.session.id if hasattr(cherrypy.serving, 'session') else None\n        SessionObject.query.filter(\n            SessionObject.username == self.username,\n            SessionObject.id != session_id,\n        ).delete()\n\n    def __eq__(self, other):\n        return type(self) == type(other) and inspect(self).key == inspect(other).key\n\n    @validates('username')\n    def validates_username(self, key, value):\n        if self.username:\n            raise ValueError('Username cannot be modified.')\n        return value\n\n    def validate_access_token(self, token):\n        \"\"\"\n        Check if the given token matches.\n        \"\"\"\n        for access_token in Token.query.all():\n            if access_token.is_expired:\n                continue\n            if check_password(token, access_token.hash_token):\n                # When it matches, return the record.\n                return access_token\n        return False\n\n    def validate_password(self, password):\n        return check_password(password, self.hash_password)\n\n\n# Username should be case insensitive\nuser_username_index = Index('user_username_index', func.lower(UserObject.username), unique=True)\n\n\n@event.listens_for(UserObject.hash_password, \"set\")\ndef hash_password_set(target, value, oldvalue, initiator):\n    if value and value != oldvalue:\n        cherrypy.engine.publish('user_password_changed', target)\n\n\n@event.listens_for(UserObject, 'before_insert')\ndef user_before_insert(mapper, connection, target):\n    \"\"\"\n    Publish event when user is added\n    \"\"\"\n    cherrypy.engine.publish('user_added', target)\n\n\n@event.listens_for(UserObject, 'after_delete')\ndef user_after_delete(mapper, connection, target):\n    \"\"\"\n    Publish event when user is deleted.\n    \"\"\"\n    cherrypy.engine.publish('user_deleted', target.username)\n\n\n@event.listens_for(UserObject, 'after_update')\ndef user_attr_changed(mapper, connection, target):\n    changes = {}\n    state = inspect(target)\n    for attr in state.attrs:\n        if attr.key in ['user_root', 'email', 'role', 'mfa']:\n            hist = attr.load_history()\n            if hist.has_changes():\n                changes[attr.key] = (\n                    hist.deleted[0] if len(hist.deleted) >= 1 else None,\n                    hist.added[0] if len(hist.added) >= 1 else None,\n                )\n    if changes:\n        cherrypy.engine.publish('user_attr_changed', target, changes)\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nCreated on June 30, 2022\n\nModule to test `user` model.\n\n@author: Patrik Dufresne <patrik@ikus-soft.com>\n\"\"\"\nimport os\nfrom io import StringIO, open\nfrom unittest.mock import MagicMock\n\nimport cherrypy\nimport pkg_resources\nfrom parameterized import parameterized, parameterized_class\n\nimport rdiffweb.test\nfrom rdiffweb.core import authorizedkeys\nfrom rdiffweb.core.model import DuplicateSSHKeyError, RepoObject, UserObject\nfrom rdiffweb.core.passwd import check_password\n\n\nclass UserObjectTest(rdiffweb.test.WebCase):\n    def _read_ssh_key(self):\n        \"\"\"Readthe pub key from test packages\"\"\"\n        filename = pkg_resources.resource_filename('rdiffweb.core.tests', 'test_publickey_ssh_rsa.pub')\n        with open(filename, 'r', encoding='utf8') as f:\n            return f.readline()\n\n    def _read_authorized_keys(self):\n        \"\"\"Read the content of test_authorized_keys\"\"\"\n        filename = pkg_resources.resource_filename('rdiffweb.core.tests', 'test_authorized_keys')\n        with open(filename, 'r', encoding='utf8') as f:\n            return f.read()\n\n    def setUp(self):\n        super().setUp()\n        self.listener = MagicMock()\n        cherrypy.engine.subscribe('access_token_added', self.listener.access_token_added, priority=50)\n        cherrypy.engine.subscribe('queue_mail', self.listener.queue_mail, priority=50)\n        cherrypy.engine.subscribe('user_added', self.listener.user_added, priority=50)\n        cherrypy.engine.subscribe('user_attr_changed', self.listener.user_attr_changed, priority=50)\n        cherrypy.engine.subscribe('user_deleted', self.listener.user_deleted, priority=50)\n        cherrypy.engine.subscribe('user_login', self.listener.user_login, priority=50)\n        cherrypy.engine.subscribe('user_password_changed', self.listener.user_password_changed, priority=50)\n\n    def tearDown(self):\n        cherrypy.engine.unsubscribe('access_token_added', self.listener.access_token_added)\n        cherrypy.engine.unsubscribe('queue_mail', self.listener.queue_mail)\n        cherrypy.engine.unsubscribe('user_added', self.listener.user_added)\n        cherrypy.engine.unsubscribe('user_attr_changed', self.listener.user_attr_changed)\n        cherrypy.engine.unsubscribe('user_deleted', self.listener.user_deleted)\n        cherrypy.engine.unsubscribe('user_login', self.listener.user_login)\n        cherrypy.engine.unsubscribe('user_password_changed', self.listener.user_password_changed)\n        return super().tearDown()\n\n    def test_add_user(self):\n        \"\"\"Add user to database.\"\"\"\n        userobj = UserObject.add_user('joe')\n        userobj.commit()\n        self.assertIsNotNone(UserObject.get_user('joe'))\n        # Check if listener called\n        self.listener.user_added.assert_called_once_with(userobj)\n\n    def test_add_user_updated_by_listener(self):\n        \"\"\"Add user to database.\"\"\"\n        # Given a listener with side effet\n        def change_user_obj(userobj):\n            userobj.user_root = '/new/value'\n\n        self.listener.user_added.side_effect = change_user_obj\n        # When adding user\n        userobj = UserObject.add_user('joe')\n        userobj.commit()\n        self.assertIsNotNone(UserObject.get_user('joe'))\n        # Then lister get called\n        self.listener.user_added.assert_called_once_with(userobj)\n        # Then object was updated by listener\n        self.assertEqual('/new/value', userobj.user_root)\n\n    def test_add_user_with_duplicate(self):\n        \"\"\"Add user to database.\"\"\"\n        user = UserObject.add_user('denise')\n        user.commit()\n        self.listener.user_added.reset_mock()\n        with self.assertRaises(ValueError):\n            UserObject.add_user('denise')\n        # Check if listener called\n        self.listener.user_added.assert_not_called()\n\n    def test_add_user_with_duplicate_caseinsensitive(self):\n        \"\"\"Add user to database.\"\"\"\n        user = UserObject.add_user('denise')\n        user.commit()\n        self.listener.user_added.reset_mock()\n        with self.assertRaises(ValueError):\n            UserObject.add_user('dEnIse')\n        # Check if listener called\n        self.listener.user_added.assert_not_called()\n\n    def test_add_user_with_password(self):\n        \"\"\"Add user to database with password.\"\"\"\n        userobj = UserObject.add_user('jo', 'password')\n        userobj.commit()\n        self.assertIsNotNone(UserObject.get_user('jo'))\n        # Check if listener called\n        self.listener.user_added.assert_called_once_with(userobj)\n\n    def test_delete_admin_user(self):\n        # Trying to delete admin user should raise an error.\n        userobj = UserObject.get_user('admin')\n        with self.assertRaises(ValueError):\n            userobj.delete()\n\n    def test_users(self):\n        # Check admin exists\n        self.assertEqual(1, UserObject.query.count())\n        # Create user.\n        user = UserObject.add_user('annik')\n        user.commit()\n        users = UserObject.query.all()\n        self.assertEqual(2, len(users))\n        self.assertEqual('annik', users[1].username)\n        # Then 2 user exists\n        self.assertEqual(2, UserObject.query.count())\n\n    def test_get_user(self):\n        # Create new user\n        user = UserObject.add_user('bernie', 'my-password')\n        user.user_root = self.testcases\n        user.role = UserObject.ADMIN_ROLE\n        user.email = 'bernie@gmail.com'\n        user.refresh_repos()\n        user.commit()\n        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in user.repo_objs]))\n        user.repo_objs[0].maxage = -1\n        user.repo_objs[1].maxage = 3\n        user.commit()\n\n        # Get user record.\n        obj = UserObject.get_user('bernie')\n        self.assertIsNotNone(obj)\n        self.assertEqual('bernie', obj.username)\n        self.assertEqual('bernie@gmail.com', obj.email)\n        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in obj.repo_objs]))\n        self.assertEqual(self.testcases, obj.user_root)\n        self.assertEqual(True, obj.is_admin)\n        self.assertEqual(UserObject.ADMIN_ROLE, obj.role)\n\n        # Get repo object\n        self.assertEqual('broker-repo', obj.repo_objs[0].name)\n        self.assertEqual(-1, obj.repo_objs[0].maxage)\n        self.assertEqual('testcases', obj.repo_objs[1].name)\n        self.assertEqual(3, obj.repo_objs[1].maxage)\n\n    def test_get_user_case_insensitive(self):\n        userobj1 = UserObject.get_user(self.USERNAME)\n        userobj2 = UserObject.get_user(self.USERNAME.lower())\n        userobj3 = UserObject.get_user(self.USERNAME.upper())\n        self.assertEqual(userobj1, userobj2)\n        self.assertEqual(userobj2, userobj3)\n\n    def test_get_user_with_invalid_user(self):\n        self.assertIsNone(UserObject.get_user('invalid'))\n\n    def test_get_set(self):\n        user = UserObject.add_user('larry', 'password')\n        user.add().commit()\n\n        self.assertEqual('', user.email)\n        self.assertEqual([], user.repo_objs)\n        self.assertEqual('', user.user_root)\n        self.assertEqual(False, user.is_admin)\n        self.assertEqual(UserObject.USER_ROLE, user.role)\n\n        user.user_root = self.testcases\n        user.refresh_repos()\n        user.commit()\n        self.listener.user_attr_changed.assert_called_with(user, {'user_root': ('', self.testcases)})\n        self.listener.user_attr_changed.reset_mock()\n        user = UserObject.get_user('larry')\n        user.role = UserObject.ADMIN_ROLE\n        user.commit()\n        self.listener.user_attr_changed.assert_called_with(\n            user, {'role': (UserObject.USER_ROLE, UserObject.ADMIN_ROLE)}\n        )\n        self.listener.user_attr_changed.reset_mock()\n        user = UserObject.get_user('larry')\n        user.email = 'larry@gmail.com'\n        user.commit()\n        self.listener.user_attr_changed.assert_called_with(user, {'email': ('', 'larry@gmail.com')})\n        self.listener.user_attr_changed.reset_mock()\n\n        self.assertEqual('larry@gmail.com', user.email)\n        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in user.repo_objs]))\n        self.assertEqual(self.testcases, user.user_root)\n        self.assertEqual(True, user.is_admin)\n        self.assertEqual(UserObject.ADMIN_ROLE, user.role)\n\n    def test_set_role_null(self):\n        # Given a user\n        user = UserObject.add_user('annik', 'password')\n        user.add().commit()\n        # When trying to set the role to null\n        user.role = None\n        # Then an exception is raised\n        with self.assertRaises(Exception):\n            user.add().commit()\n\n    @parameterized.expand(\n        [\n            (-1, True),\n            (0, True),\n            (5, False),\n            (10, False),\n            (15, False),\n        ]\n    )\n    def test_is_admin(self, role, expected_is_admin):\n        # Given a user\n        user = UserObject.add_user('annik', 'password')\n        # When setting the role value\n        user.role = role\n        user.commit()\n        # Then the is_admin value get updated too\n        self.assertEqual(expected_is_admin, user.is_admin)\n\n    @parameterized.expand(\n        [\n            (-1, True),\n            (0, True),\n            (5, True),\n            (10, False),\n            (15, False),\n        ]\n    )\n    def test_is_maintainer(self, role, expected_is_maintainer):\n        # Given a user\n        user = UserObject.add_user('annik', 'password')\n        # When setting the role value\n        user.role = role\n        user.commit()\n        # Then the is_admin value get updated too\n        self.assertEqual(expected_is_maintainer, user.is_maintainer)\n\n    def test_set_password_update(self):\n        # Given a user in database with a password\n        userobj = UserObject.add_user('annik', 'password')\n        userobj.commit()\n        self.listener.user_password_changed.reset_mock()\n        # When updating the user's password\n        userobj.set_password('new_password')\n        userobj.commit()\n        # Then password is SSHA\n        self.assertTrue(check_password('new_password', userobj.hash_password))\n        # Check if listener called\n        self.listener.user_password_changed.assert_called_once_with(userobj)\n\n    def test_delete_user(self):\n        # Given an existing user in database\n        userobj = UserObject.add_user('vicky')\n        userobj.commit()\n        self.assertIsNotNone(UserObject.get_user('vicky'))\n        # When deleting that user\n        userobj.delete()\n        userobj.commit()\n        # Then user it no longer in database\n        self.assertIsNone(UserObject.get_user('vicky'))\n        # Then listner was called\n        self.listener.user_deleted.assert_called_once_with('vicky')\n\n    def test_set_password_empty(self):\n        \"\"\"Expect error when trying to update password of invalid user.\"\"\"\n        userobj = UserObject.add_user('john')\n        userobj.commit()\n        with self.assertRaises(ValueError):\n            self.assertFalse(userobj.set_password(''))\n\n    def test_disk_quota(self):\n        \"\"\"\n        Just make a call to the function.\n        \"\"\"\n        userobj = UserObject.get_user(self.USERNAME)\n        userobj.disk_quota\n\n    def test_disk_usage(self):\n        \"\"\"\n        Just make a call to the function.\n        \"\"\"\n        userobj = UserObject.get_user(self.USERNAME)\n        disk_usage = userobj.disk_usage\n        self.assertIsInstance(disk_usage, int)\n\n    def test_add_authorizedkey_without_file(self):\n        \"\"\"\n        Add an ssh key for a user without an authorizedkey file.\n        \"\"\"\n        # Read the pub key\n        key = self._read_ssh_key()\n        # Add the key to the user\n        userobj = UserObject.get_user(self.USERNAME)\n        userobj.add_authorizedkey(key)\n        userobj.commit()\n\n        # validate\n        keys = list(userobj.authorizedkeys)\n        self.assertEqual(1, len(keys), \"expecting one key\")\n        self.assertEqual(\"3c:99:ed:a7:82:a8:71:09:2c:15:3d:78:4a:8c:11:99\", keys[0].fingerprint)\n\n    def test_add_authorizedkey_duplicate(self):\n        # Read the pub key\n        key = self._read_ssh_key()\n        # Add the key to the user\n        userobj = UserObject.get_user(self.USERNAME)\n        userobj.add_authorizedkey(key)\n        userobj.commit()\n        # Add the same key\n        with self.assertRaises(DuplicateSSHKeyError):\n            userobj.add_authorizedkey(key)\n            userobj.commit()\n\n    def test_add_authorizedkey_with_file(self):\n        \"\"\"\n        Add an ssh key for a user with an authorizedkey file.\n        \"\"\"\n        userobj = UserObject.get_user(self.USERNAME)\n\n        # Create empty authorized_keys file\n        os.mkdir(os.path.join(userobj.user_root, '.ssh'))\n        filename = os.path.join(userobj.user_root, '.ssh', 'authorized_keys')\n        open(filename, 'a').close()\n\n        # Read the pub key\n        key = self._read_ssh_key()\n        userobj.add_authorizedkey(key)\n        userobj.commit()\n\n        # Validate\n        with open(filename, 'r') as fh:\n            self.assertEqual(key, fh.read())\n\n    def test_delete_authorizedkey_without_file(self):\n        \"\"\"\n        Remove an ssh key for a user without authorizedkey file.\n        \"\"\"\n        # Update user with ssh keys.\n        data = self._read_authorized_keys()\n        userobj = UserObject.get_user(self.USERNAME)\n        for k in authorizedkeys.read(StringIO(data)):\n            try:\n                userobj.add_authorizedkey(k.getvalue())\n            except ValueError:\n                # Some ssh key in the testing file are not valid.\n                pass\n\n        # Get the keys\n        keys = list(userobj.authorizedkeys)\n        self.assertEqual(2, len(keys))\n\n        # Remove a key\n        userobj.delete_authorizedkey(\"9a:f1:69:3c:bc:5a:cd:02:5e:33:bc:cd:c0:01:eb:4c\")\n        userobj.commit()\n\n        # Validate\n        keys = list(userobj.authorizedkeys)\n        self.assertEqual(1, len(keys))\n\n    def test_delete_authorizedkey_with_file(self):\n        \"\"\"\n        Remove an ssh key for a user with authorizedkey file.\n        \"\"\"\n        # Create authorized_keys file\n        data = self._read_authorized_keys()\n        userobj = UserObject.get_user(self.USERNAME)\n        os.mkdir(os.path.join(userobj.user_root, '.ssh'))\n        filename = os.path.join(userobj.user_root, '.ssh', 'authorized_keys')\n        with open(filename, 'w') as f:\n            f.write(data)\n\n        # Get the keys\n        keys = list(userobj.authorizedkeys)\n        self.assertEqual(5, len(keys))\n\n        # Remove a key\n        userobj.delete_authorizedkey(\"9a:f1:69:3c:bc:5a:cd:02:5e:33:bc:cd:c0:01:eb:4c\")\n\n        # Validate\n        keys = list(userobj.authorizedkeys)\n        self.assertEqual(4, len(keys))\n\n    def test_repo_objs(self):\n        # Given a user with a list of repositories\n        userobj = UserObject.get_user(self.USERNAME)\n        repos = sorted(userobj.repo_objs, key=lambda r: r.name)\n        self.assertEqual(['broker-repo', 'testcases'], [r.name for r in repos])\n        # When deleting a repository empty list\n        repos[1].delete()\n        repos[1].commit()\n        # Then the repository is removed from the list.\n        self.assertEqual(['broker-repo'], sorted([r.name for r in userobj.repo_objs]))\n\n    def test_refresh_repos_without_delete(self):\n        # Given a user with invalid repositories\n        userobj = UserObject.get_user(self.USERNAME)\n        RepoObject.query.delete()\n        RepoObject(userid=userobj.userid, repopath='invalid').add().commit()\n        self.assertEqual(['invalid'], sorted([r.name for r in userobj.repo_objs]))\n        # When updating the repository list without deletion\n        userobj.refresh_repos()\n        userobj.commit()\n        # Then the list invlaid the invalid repo and new repos\n        self.assertEqual(['broker-repo', 'invalid', 'testcases'], sorted([r.name for r in userobj.repo_objs]))\n\n    def test_refresh_repos_with_delete(self):\n        # Given a user with invalid repositories\n        userobj = UserObject.get_user(self.USERNAME)\n        RepoObject.query.delete()\n        RepoObject(userid=userobj.userid, repopath='invalid').add().commit()\n        self.assertEqual(['invalid'], sorted([r.name for r in userobj.repo_objs]))\n        # When updating the repository list without deletion\n        userobj.refresh_repos(delete=True)\n        userobj.commit()\n        # Then the list invlaid the invalid repo and new repos\n        userobj.expire()\n        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in userobj.repo_objs]))\n\n    def test_refresh_repos_with_single_repo(self):\n        # Given a user with invalid repositories\n        userobj = UserObject.get_user(self.USERNAME)\n        userobj.user_root = os.path.join(self.testcases, 'testcases')\n        # When updating the repository list without deletion\n        userobj.refresh_repos(delete=True)\n        userobj.commit()\n        # Then the list invlaid the invalid repo and new repos\n        userobj.expire()\n        self.assertEqual([''], sorted([r.name for r in userobj.repo_objs]))\n\n    def test_refresh_repos_with_empty_userroot(self):\n        # Given a user with valid repositories relative to root\n        userobj = UserObject.get_user(self.USERNAME)\n        for repo in userobj.repo_objs:\n            repo.repopath = self.testcases[1:] + '/' + repo.repopath\n            repo.add().commit()\n        userobj.user_root = '/'\n        userobj.add().commit()\n        self.assertEqual(['interrupted', 'ok'], sorted([r.status[0] for r in userobj.repo_objs]))\n        # When updating it's userroot directory to an empty value\n        userobj.user_root = ''\n        userobj.add().commit()\n        UserObject.session.expire_all()\n        # Then close session\n        cherrypy.tools.db.on_end_resource()\n        # Then repo status is \"broken\"\n        userobj = UserObject.get_user(self.USERNAME)\n        self.assertFalse(userobj.valid_user_root())\n        self.assertEqual(['failed', 'failed'], [r.status[0] for r in userobj.repo_objs])\n\n\n# password: test\n@parameterized_class(\n    [\n        {\n            'default_config': {\n                'admin-password': '{SSHA}wbSK4hlEX7mtGJplFi2oN6ABm6Y3Bo1e',\n            },\n        },\n        {\n            'default_config': {\n                'admin-password': '$argon2id$v=19$m=65536,t=3,p=4$N2FmDyCNjY/MTreAOWluLw$BbKVcHt99Jf5yeTbFcJhwJpcEtSSNCB1ru4D+Vvm+JM'\n            },\n        },\n        {\n            'default_config': {\n                'admin-password': 'test',\n            }\n        },\n    ]\n)\nclass UserObjectWithAdminPassword(rdiffweb.test.WebCase):\n    def setUp(self):\n        # Do nothing - We need to skip the default setup to avoid deleting the records.\n        pass\n\n    def test_create_admin_user(self):\n        # Given admin-password is configure\n        # When database get created\n        # Then admin user get created with 'test' password\n        userobj = UserObject.get_user(self.USERNAME)\n        self.assertIsNotNone(userobj)\n        self.assertTrue(check_password('test', userobj.hash_password))\n\n        # Given admin-password is configure\n        # When trying to update admin password\n        # Then an exception is raised\n        userobj = UserObject.get_user(self.USERNAME)\n        with self.assertRaises(ValueError):\n            userobj.set_password('newpassword')\n\n\nclass UserObjectWithoutAdminPassword(rdiffweb.test.WebCase):\n    def setUp(self):\n        # Do nothing - We need to skip the default setup to avoid deleting the records.\n        pass\n\n    def tearDown(self):\n        # Do nothing - We need to makre sure the database is not drop.\n        pass\n\n    def test_create_admin_user_without_password(self):\n        # Given an existing admin user with a password\n        userobj = UserObject.get_user(self.USERNAME)\n        userobj.hash_password = '{SSHA}wbSK4hlEX7mtGJplFi2oN6ABm6Y3Bo1e'  # test\n        # When application restart, create_admin_user is called again\n        user = UserObject.create_admin_user(self.USERNAME, None)\n        user.commit()\n        # Then user password must not be replaced\n        self.assertTrue(check_password('test', user.hash_password))\n\n    @parameterized.expand(\n        [\n            'puy3qjRWjpCn',\n            '$argon2id$v=19$m=65536,t=3,p=4$L91u8sX4ecyrbUSqvmb/FA$GOGR5uPmQmla6H62e5yKKNCRa7sY6d2Hxmly/eAXe6Q',\n            '{SSHA}3RkZu26wF8xSHInMcK8P/9wqqU1aCzie',\n        ]\n    )\n    def test_create_admin_user_with_password(self, new_password):\n        # Given an existing admin user with a password\n        userobj = UserObject.get_user(self.USERNAME)\n        userobj.hash_password = '{SSHA}wbSK4hlEX7mtGJplFi2oN6ABm6Y3Bo1e'  # test\n        # When application restart, create_admin_user is called again with a password\n        user = UserObject.create_admin_user(self.USERNAME, new_password)\n        user.commit()\n        # Then user password get replaced\n        self.assertTrue(check_password('puy3qjRWjpCn', user.hash_password))\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport unittest\n\nimport cherrypy\n\nfrom rdiffweb.core.librdiff import RdiffTime\nfrom rdiffweb.core.model import RepoObject, UserObject\nfrom rdiffweb.core.rdw_templating import _ParentEntry, attrib, do_format_lastupdated, list_parents, url_for\nfrom rdiffweb.test import WebCase\n\n\nclass TemplateManagerTest(unittest.TestCase):\n    def test_attrib(self):\n        # Single value\n        self.assertEqual('id=\"row\"', attrib(id='row'))\n        # Single value with quote\n        self.assertEqual('id=\"val&lt;ue&quot;with&quot;qu&gt;ot&amp;e\"', attrib(id='val<ue\"with\"qu>ot&e'))\n        # Multi attribute\n        self.assertEqual('id=\"row\" type=\"table\"', attrib(type='table', id='row'))\n        # Attribute with list\n        self.assertEqual('type=\"table container\"', attrib(type=['table', 'container']))\n        # Attribute with class\n        self.assertEqual('class=\"table container\"', attrib(**{'class': ['table', 'container']}))\n        # Boolean expressions\n        self.assertEqual('id=\"active\"', attrib(id=[False, 'active', False]))\n        self.assertEqual('data=\"coucou\" id=\"active\"', attrib(type=False, id=[False, 'active', False], data='coucou'))\n        active = True\n        self.assertEqual('id=\"active\"', attrib(id=[active and 'active']))\n        active = False\n        self.assertEqual('', attrib(id=[active and 'active']))\n\n        # With True\n        self.assertEqual('selected', attrib(selected=True))\n\n        # Bytes\n        self.assertEqual('selected=\"text\"', attrib(selected=b'text'))\n\n        # Newstr\n        self.assertEqual('selected=\"text\"', attrib(selected=str('text')))\n\n        self.assertEqual('value=\"0\"', attrib(value=0))\n\n    def test_url_for(self):\n        # Check backward compatibility\n        self.assertEqual(cherrypy.server.base() + '/', url_for('/'))\n        self.assertEqual(cherrypy.server.base() + '/browse', url_for('browse'))\n        self.assertEqual(cherrypy.server.base() + '/browse/testcases', url_for('browse', b'testcases'))\n        self.assertEqual(\n            cherrypy.server.base() + '/browse/testcases/Revisions', url_for('browse', b'testcases', b'Revisions')\n        )\n        self.assertEqual(\n            cherrypy.server.base() + '/restore/testcases/Revisions?date=1454448640',\n            url_for('restore', b'testcases', b'Revisions', date=1454448640),\n        )\n        self.assertEqual(\n            cherrypy.server.base() + '/restore/testcases/Revisions?date=1454448640&kind=tar.gz',\n            url_for('restore', b'testcases', b'Revisions', date=1454448640, kind='tar.gz'),\n        )\n        self.assertEqual(\n            cherrypy.server.base() + '/browse/testcases/R%C3%A9pertoire',\n            url_for('browse', b'testcases', b'R\\xc3\\xa9pertoire'),\n        )\n        # Check if multi path is supported.\n        self.assertEqual(cherrypy.server.base() + '/admin/logs', url_for('admin/logs'))\n        self.assertEqual(cherrypy.server.base() + '/admin/logs/backup.log', url_for('admin/logs', 'backup.log'))\n\n    def test_do_format_lastupdated(self):\n        self.assertEqual('23 seconds ago', do_format_lastupdated(1591978823, now=1591978846))\n        self.assertEqual('23 seconds ago', do_format_lastupdated(RdiffTime(value=1591978823), now=1591978846))\n        self.assertEqual('8 minutes ago', do_format_lastupdated(RdiffTime(value=1591978324), now=1591978846))\n        self.assertEqual('2 hours ago', do_format_lastupdated(RdiffTime(value=1591971646), now=1591978846))\n        self.assertEqual('2 days ago', do_format_lastupdated(RdiffTime(value=1591805524), now=1591978846))\n        self.assertEqual('4 weeks ago', do_format_lastupdated(RdiffTime(value=1589127124), now=1591978846))\n        self.assertEqual('5 months ago', do_format_lastupdated(RdiffTime(value=1578672724), now=1591978846))\n        self.assertEqual('4 years ago', do_format_lastupdated(RdiffTime(value=1452442324), now=1591978846))\n\n\nclass ListParentsTest(WebCase):\n    def test_list_parents_with_root_dir(self):\n        repo, path = RepoObject.get_repo_path(b'admin/testcases', as_user=UserObject.get_user('admin'))\n        self.assertEqual(list_parents(repo, path), [_ParentEntry(path=b'', display_name='testcases')])\n\n    def test_list_parents_with_root_subdir(self):\n        repo, path = RepoObject.get_repo_path(b'admin/testcases/Revisions', as_user=UserObject.get_user('admin'))\n        self.assertEqual(\n            list_parents(repo, path),\n            [\n                _ParentEntry(path=b'', display_name='testcases'),\n                _ParentEntry(path=b'Revisions', display_name='Revisions'),\n            ],\n        )\n\n\nclass UrlForTest(WebCase):\n    @property\n    def repo_obj(self):\n        user = UserObject.get_user('admin')\n        return RepoObject.query.filter(RepoObject.user == user, RepoObject.repopath == self.REPO).first()\n\n    def test_url_for_absolute_path(self):\n        self.assertEqual(cherrypy.server.base() + '/static/js/jquery.min.js', url_for('/static/js/jquery.min.js'))\n\n    def test_url_for_browse(self):\n        \"\"\"Check creation of url\"\"\"\n        self.assertEqual(cherrypy.server.base() + '/browse/admin/testcases', url_for('browse', self.repo_obj))\n        self.assertEqual(\n            cherrypy.server.base() + '/browse/admin/testcases/Revisions', url_for('browse', self.repo_obj, b'Revisions')\n        )\n        self.assertEqual(\n            cherrypy.server.base() + '/browse/admin/testcases/Revisions?restore=True',\n            url_for('browse', self.repo_obj, b'Revisions', restore=True),\n        )\n        self.assertEqual(\n            cherrypy.server.base()\n            + '/browse/admin/testcases/R%C3%A9pertoire%20%28%40vec%29%20%7Bc%C3%A0ra%C3%A7t%23%C3%A8r%C3%AB%7D%20%24%C3%A9p%C3%AAcial',\n            url_for(\n                'browse',\n                self.repo_obj,\n                b'R\\xc3\\xa9pertoire (@vec) {c\\xc3\\xa0ra\\xc3\\xa7t#\\xc3\\xa8r\\xc3\\xab} $\\xc3\\xa9p\\xc3\\xaacial',\n            ),\n        )\n\n    def test_url_for_graphs(self):\n        self.assertEqual(\n            cherrypy.server.base() + '/graphs/files/admin/testcases', url_for('graphs', 'files', self.repo_obj)\n        )\n\n    def test_url_for_history(self):\n        \"\"\"Check creation of url\"\"\"\n        self.assertEqual(cherrypy.server.base() + '/history/admin/testcases', url_for('history', self.repo_obj))\n\n    def test_url_for_restore(self):\n        self.assertEqual(\n            cherrypy.server.base() + '/restore/admin/testcases?date=1414967021',\n            url_for('restore', self.repo_obj, date=RdiffTime(1414967021)),\n        )\n        self.assertEqual(\n            cherrypy.server.base() + '/restore/admin/testcases?date=1414967021',\n            url_for('restore', self.repo_obj, b'', date=RdiffTime(1414967021)),\n        )\n        self.assertEqual(\n            cherrypy.server.base() + '/restore/admin/testcases?date=1414967021&kind=tar.gz',\n            url_for('restore', self.repo_obj, b'', date=RdiffTime(1414967021), kind='tar.gz'),\n        )\n        self.assertEqual(\n            cherrypy.server.base() + '/restore/admin/testcases/Revisions?date=1414967021',\n            url_for('restore', self.repo_obj, b'Revisions', date=RdiffTime(1414967021)),\n        )\n        self.assertEqual(\n            cherrypy.server.base()\n            + '/restore/admin/testcases/R%C3%A9pertoire%20%28%40vec%29%20%7Bc%C3%A0ra%C3%A7t%23%C3%A8r%C3%AB%7D%20%24%C3%A9p%C3%AAcial?date=1414967021',\n            url_for(\n                'restore',\n                self.repo_obj,\n                b'R\\xc3\\xa9pertoire (@vec) {c\\xc3\\xa0ra\\xc3\\xa7t#\\xc3\\xa8r\\xc3\\xab} $\\xc3\\xa9p\\xc3\\xaacial',\n                date=RdiffTime(1414967021),\n            ),\n        )\n\n    def test_url_for_status(self):\n        self.assertEqual(\n            cherrypy.server.base() + '/status?date=1414967021', url_for('status', date=RdiffTime(1414967021))\n        )\n        self.assertEqual(\n            cherrypy.server.base() + '/status/admin/testcases?date=1414967021',\n            url_for('status', self.repo_obj, date=RdiffTime(1414967021)),\n        )\n\n    def test_url_for_with_none(self):\n        self.assertEqual(cherrypy.server.base() + '/logs', url_for('logs', date=None))\n"], "filenames": ["README.md", "rdiffweb/controller/tests/test_page_login.py", "rdiffweb/controller/tests/test_page_prefs_general.py", "rdiffweb/core/login.py", "rdiffweb/core/model/__init__.py", "rdiffweb/core/model/_user.py", "rdiffweb/core/model/tests/test_user.py", "rdiffweb/core/tests/test_rdw_templating.py"], "buggy_code_start_loc": [29, 65, 88, 53, 17, 23, 105, 113], "buggy_code_end_loc": [382, 65, 141, 73, 103, 415, 159, 114], "fixing_code_start_loc": [29, 66, 88, 53, 18, 23, 106, 113], "fixing_code_end_loc": [387, 75, 141, 73, 140, 420, 177, 114], "type": "CWE-305", "message": "Authentication Bypass by Primary Weakness in GitHub repository ikus060/rdiffweb prior to 2.5.5.", "other": {"cve": {"id": "CVE-2022-4722", "sourceIdentifier": "security@huntr.dev", "published": "2022-12-27T15:15:11.900", "lastModified": "2023-01-05T14:47:54.860", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Authentication Bypass by Primary Weakness in GitHub repository ikus060/rdiffweb prior to 2.5.5."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-305"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ikus-soft:rdiffweb:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.5.5", "matchCriteriaId": "16348FC3-32AD-4A89-937B-E3A5249CE371"}]}]}], "references": [{"url": "https://github.com/ikus060/rdiffweb/commit/d1aaa96b665a39fba9e98d6054a9de511ba0a837", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/c62126dc-d9a6-4d3e-988d-967031876c58", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ikus060/rdiffweb/commit/d1aaa96b665a39fba9e98d6054a9de511ba0a837"}}