{"buggy_code": ["<?php\n\nuse dokuwiki\\ChangeLog\\MediaChangeLog;\nuse dokuwiki\\File\\MediaResolver;\nuse dokuwiki\\File\\PageResolver;\n\n/**\n * Renderer for XHTML output\n *\n * This is DokuWiki's main renderer used to display page content in the wiki\n *\n * @author Harry Fuecks <hfuecks@gmail.com>\n * @author Andreas Gohr <andi@splitbrain.org>\n *\n */\nclass Doku_Renderer_xhtml extends Doku_Renderer {\n    /** @var array store the table of contents */\n    public $toc = array();\n\n    /** @var array A stack of section edit data */\n    protected $sectionedits = array();\n\n    /** @var int last section edit id, used by startSectionEdit */\n    protected $lastsecid = 0;\n\n    /** @var array a list of footnotes, list starts at 1! */\n    protected $footnotes = array();\n\n    /** @var int current section level */\n    protected $lastlevel = 0;\n    /** @var array section node tracker */\n    protected $node = array(0, 0, 0, 0, 0);\n\n    /** @var string temporary $doc store */\n    protected $store = '';\n\n    /** @var array global counter, for table classes etc. */\n    protected $_counter = array(); //\n\n    /** @var int counts the code and file blocks, used to provide download links */\n    protected $_codeblock = 0;\n\n    /** @var array list of allowed URL schemes */\n    protected $schemes = null;\n\n    /**\n     * Register a new edit section range\n     *\n     * @param int    $start  The byte position for the edit start\n     * @param array  $data   Associative array with section data:\n     *                       Key 'name': the section name/title\n     *                       Key 'target': the target for the section edit,\n     *                                     e.g. 'section' or 'table'\n     *                       Key 'hid': header id\n     *                       Key 'codeblockOffset': actual code block index\n     *                       Key 'start': set in startSectionEdit(),\n     *                                    do not set yourself\n     *                       Key 'range': calculated from 'start' and\n     *                                    $key in finishSectionEdit(),\n     *                                    do not set yourself\n     * @return string  A marker class for the starting HTML element\n     *\n     * @author Adrian Lang <lang@cosmocode.de>\n     */\n    public function startSectionEdit($start, $data) {\n        if (!is_array($data)) {\n            msg(\n                sprintf(\n                    'startSectionEdit: $data \"%s\" is NOT an array! One of your plugins needs an update.',\n                    hsc((string) $data)\n                ), -1\n            );\n\n            // @deprecated 2018-04-14, backward compatibility\n            $args = func_get_args();\n            $data = array();\n            if(isset($args[1])) $data['target'] = $args[1];\n            if(isset($args[2])) $data['name'] = $args[2];\n            if(isset($args[3])) $data['hid'] = $args[3];\n        }\n        $data['secid'] = ++$this->lastsecid;\n        $data['start'] = $start;\n        $this->sectionedits[] = $data;\n        return 'sectionedit'.$data['secid'];\n    }\n\n    /**\n     * Finish an edit section range\n     *\n     * @param int  $end     The byte position for the edit end; null for the rest of the page\n     *\n     * @author Adrian Lang <lang@cosmocode.de>\n     */\n    public function finishSectionEdit($end = null, $hid = null) {\n        if(count($this->sectionedits) == 0) {\n            return;\n        }\n        $data = array_pop($this->sectionedits);\n        if(!is_null($end) && $end <= $data['start']) {\n            return;\n        }\n        if(!is_null($hid)) {\n            $data['hid'] .= $hid;\n        }\n        $data['range'] = $data['start'].'-'.(is_null($end) ? '' : $end);\n        unset($data['start']);\n        $this->doc .= '<!-- EDIT'.hsc(json_encode ($data)).' -->';\n    }\n\n    /**\n     * Returns the format produced by this renderer.\n     *\n     * @return string always 'xhtml'\n     */\n    public function getFormat() {\n        return 'xhtml';\n    }\n\n    /**\n     * Initialize the document\n     */\n    public function document_start() {\n        //reset some internals\n        $this->toc     = array();\n    }\n\n    /**\n     * Finalize the document\n     */\n    public function document_end() {\n        // Finish open section edits.\n        while(count($this->sectionedits) > 0) {\n            if($this->sectionedits[count($this->sectionedits) - 1]['start'] <= 1) {\n                // If there is only one section, do not write a section edit\n                // marker.\n                array_pop($this->sectionedits);\n            } else {\n                $this->finishSectionEdit();\n            }\n        }\n\n        if(count($this->footnotes) > 0) {\n            $this->doc .= '<div class=\"footnotes\">'.DOKU_LF;\n\n            foreach($this->footnotes as $id => $footnote) {\n                // check its not a placeholder that indicates actual footnote text is elsewhere\n                if(substr($footnote, 0, 5) != \"@@FNT\") {\n\n                    // open the footnote and set the anchor and backlink\n                    $this->doc .= '<div class=\"fn\">';\n                    $this->doc .= '<sup><a href=\"#fnt__'.$id.'\" id=\"fn__'.$id.'\" class=\"fn_bot\">';\n                    $this->doc .= $id.')</a></sup> '.DOKU_LF;\n\n                    // get any other footnotes that use the same markup\n                    $alt = array_keys($this->footnotes, \"@@FNT$id\");\n\n                    if(count($alt)) {\n                        foreach($alt as $ref) {\n                            // set anchor and backlink for the other footnotes\n                            $this->doc .= ', <sup><a href=\"#fnt__'.($ref).'\" id=\"fn__'.($ref).'\" class=\"fn_bot\">';\n                            $this->doc .= ($ref).')</a></sup> '.DOKU_LF;\n                        }\n                    }\n\n                    // add footnote markup and close this footnote\n                    $this->doc .= '<div class=\"content\">'.$footnote.'</div>';\n                    $this->doc .= '</div>'.DOKU_LF;\n                }\n            }\n            $this->doc .= '</div>'.DOKU_LF;\n        }\n\n        // Prepare the TOC\n        global $conf;\n        if(\n            $this->info['toc'] &&\n            is_array($this->toc) &&\n            $conf['tocminheads'] && count($this->toc) >= $conf['tocminheads']\n        ) {\n            global $TOC;\n            $TOC = $this->toc;\n        }\n\n        // make sure there are no empty paragraphs\n        $this->doc = preg_replace('#<p>\\s*</p>#', '', $this->doc);\n    }\n\n    /**\n     * Add an item to the TOC\n     *\n     * @param string $id       the hash link\n     * @param string $text     the text to display\n     * @param int    $level    the nesting level\n     */\n    public function toc_additem($id, $text, $level) {\n        global $conf;\n\n        //handle TOC\n        if($level >= $conf['toptoclevel'] && $level <= $conf['maxtoclevel']) {\n            $this->toc[] = html_mktocitem($id, $text, $level - $conf['toptoclevel'] + 1);\n        }\n    }\n\n    /**\n     * Render a heading\n     *\n     * @param string $text       the text to display\n     * @param int    $level      header level\n     * @param int    $pos        byte position in the original source\n     * @param bool   $returnonly whether to return html or write to doc attribute\n     * @return void|string writes to doc attribute or returns html depends on $returnonly\n     */\n    public function header($text, $level, $pos, $returnonly = false) {\n        global $conf;\n\n        if(blank($text)) return; //skip empty headlines\n\n        $hid = $this->_headerToLink($text, true);\n\n        //only add items within configured levels\n        $this->toc_additem($hid, $text, $level);\n\n        // adjust $node to reflect hierarchy of levels\n        $this->node[$level - 1]++;\n        if($level < $this->lastlevel) {\n            for($i = 0; $i < $this->lastlevel - $level; $i++) {\n                $this->node[$this->lastlevel - $i - 1] = 0;\n            }\n        }\n        $this->lastlevel = $level;\n\n        if($level <= $conf['maxseclevel'] &&\n            count($this->sectionedits) > 0 &&\n            $this->sectionedits[count($this->sectionedits) - 1]['target'] === 'section'\n        ) {\n            $this->finishSectionEdit($pos - 1);\n        }\n\n        // build the header\n        $header = DOKU_LF.'<h'.$level;\n        if($level <= $conf['maxseclevel']) {\n            $data = array();\n            $data['target'] = 'section';\n            $data['name'] = $text;\n            $data['hid'] = $hid;\n            $data['codeblockOffset'] = $this->_codeblock;\n            $header .= ' class=\"'.$this->startSectionEdit($pos, $data).'\"';\n        }\n        $header .= ' id=\"'.$hid.'\">';\n        $header .= $this->_xmlEntities($text);\n        $header .= \"</h$level>\".DOKU_LF;\n\n        if ($returnonly) {\n            return $header;\n        } else {\n            $this->doc .= $header;\n        }\n    }\n\n    /**\n     * Open a new section\n     *\n     * @param int $level section level (as determined by the previous header)\n     */\n    public function section_open($level) {\n        $this->doc .= '<div class=\"level'.$level.'\">'.DOKU_LF;\n    }\n\n    /**\n     * Close the current section\n     */\n    public function section_close() {\n        $this->doc .= DOKU_LF.'</div>'.DOKU_LF;\n    }\n\n    /**\n     * Render plain text data\n     *\n     * @param $text\n     */\n    public function cdata($text) {\n        $this->doc .= $this->_xmlEntities($text);\n    }\n\n    /**\n     * Open a paragraph\n     */\n    public function p_open() {\n        $this->doc .= DOKU_LF.'<p>'.DOKU_LF;\n    }\n\n    /**\n     * Close a paragraph\n     */\n    public function p_close() {\n        $this->doc .= DOKU_LF.'</p>'.DOKU_LF;\n    }\n\n    /**\n     * Create a line break\n     */\n    public function linebreak() {\n        $this->doc .= '<br/>'.DOKU_LF;\n    }\n\n    /**\n     * Create a horizontal line\n     */\n    public function hr() {\n        $this->doc .= '<hr />'.DOKU_LF;\n    }\n\n    /**\n     * Start strong (bold) formatting\n     */\n    public function strong_open() {\n        $this->doc .= '<strong>';\n    }\n\n    /**\n     * Stop strong (bold) formatting\n     */\n    public function strong_close() {\n        $this->doc .= '</strong>';\n    }\n\n    /**\n     * Start emphasis (italics) formatting\n     */\n    public function emphasis_open() {\n        $this->doc .= '<em>';\n    }\n\n    /**\n     * Stop emphasis (italics) formatting\n     */\n    public function emphasis_close() {\n        $this->doc .= '</em>';\n    }\n\n    /**\n     * Start underline formatting\n     */\n    public function underline_open() {\n        $this->doc .= '<em class=\"u\">';\n    }\n\n    /**\n     * Stop underline formatting\n     */\n    public function underline_close() {\n        $this->doc .= '</em>';\n    }\n\n    /**\n     * Start monospace formatting\n     */\n    public function monospace_open() {\n        $this->doc .= '<code>';\n    }\n\n    /**\n     * Stop monospace formatting\n     */\n    public function monospace_close() {\n        $this->doc .= '</code>';\n    }\n\n    /**\n     * Start a subscript\n     */\n    public function subscript_open() {\n        $this->doc .= '<sub>';\n    }\n\n    /**\n     * Stop a subscript\n     */\n    public function subscript_close() {\n        $this->doc .= '</sub>';\n    }\n\n    /**\n     * Start a superscript\n     */\n    public function superscript_open() {\n        $this->doc .= '<sup>';\n    }\n\n    /**\n     * Stop a superscript\n     */\n    public function superscript_close() {\n        $this->doc .= '</sup>';\n    }\n\n    /**\n     * Start deleted (strike-through) formatting\n     */\n    public function deleted_open() {\n        $this->doc .= '<del>';\n    }\n\n    /**\n     * Stop deleted (strike-through) formatting\n     */\n    public function deleted_close() {\n        $this->doc .= '</del>';\n    }\n\n    /**\n     * Callback for footnote start syntax\n     *\n     * All following content will go to the footnote instead of\n     * the document. To achieve this the previous rendered content\n     * is moved to $store and $doc is cleared\n     *\n     * @author Andreas Gohr <andi@splitbrain.org>\n     */\n    public function footnote_open() {\n\n        // move current content to store and record footnote\n        $this->store = $this->doc;\n        $this->doc   = '';\n    }\n\n    /**\n     * Callback for footnote end syntax\n     *\n     * All rendered content is moved to the $footnotes array and the old\n     * content is restored from $store again\n     *\n     * @author Andreas Gohr\n     */\n    public function footnote_close() {\n        /** @var $fnid int takes track of seen footnotes, assures they are unique even across multiple docs FS#2841 */\n        static $fnid = 0;\n        // assign new footnote id (we start at 1)\n        $fnid++;\n\n        // recover footnote into the stack and restore old content\n        $footnote    = $this->doc;\n        $this->doc   = $this->store;\n        $this->store = '';\n\n        // check to see if this footnote has been seen before\n        $i = array_search($footnote, $this->footnotes);\n\n        if($i === false) {\n            // its a new footnote, add it to the $footnotes array\n            $this->footnotes[$fnid] = $footnote;\n        } else {\n            // seen this one before, save a placeholder\n            $this->footnotes[$fnid] = \"@@FNT\".($i);\n        }\n\n        // output the footnote reference and link\n        $this->doc .= '<sup><a href=\"#fn__'.$fnid.'\" id=\"fnt__'.$fnid.'\" class=\"fn_top\">'.$fnid.')</a></sup>';\n    }\n\n    /**\n     * Open an unordered list\n     *\n     * @param string|string[] $classes css classes - have to be valid, do not pass unfiltered user input\n     */\n    public function listu_open($classes = null) {\n        $class = '';\n        if($classes !== null) {\n            if(is_array($classes)) $classes = join(' ', $classes);\n            $class = \" class=\\\"$classes\\\"\";\n        }\n        $this->doc .= \"<ul$class>\".DOKU_LF;\n    }\n\n    /**\n     * Close an unordered list\n     */\n    public function listu_close() {\n        $this->doc .= '</ul>'.DOKU_LF;\n    }\n\n    /**\n     * Open an ordered list\n     *\n     * @param string|string[] $classes css classes - have to be valid, do not pass unfiltered user input\n     */\n    public function listo_open($classes = null) {\n        $class = '';\n        if($classes !== null) {\n            if(is_array($classes)) $classes = join(' ', $classes);\n            $class = \" class=\\\"$classes\\\"\";\n        }\n        $this->doc .= \"<ol$class>\".DOKU_LF;\n    }\n\n    /**\n     * Close an ordered list\n     */\n    public function listo_close() {\n        $this->doc .= '</ol>'.DOKU_LF;\n    }\n\n    /**\n     * Open a list item\n     *\n     * @param int $level the nesting level\n     * @param bool $node true when a node; false when a leaf\n     */\n    public function listitem_open($level, $node=false) {\n        $branching = $node ? ' node' : '';\n        $this->doc .= '<li class=\"level'.$level.$branching.'\">';\n    }\n\n    /**\n     * Close a list item\n     */\n    public function listitem_close() {\n        $this->doc .= '</li>'.DOKU_LF;\n    }\n\n    /**\n     * Start the content of a list item\n     */\n    public function listcontent_open() {\n        $this->doc .= '<div class=\"li\">';\n    }\n\n    /**\n     * Stop the content of a list item\n     */\n    public function listcontent_close() {\n        $this->doc .= '</div>'.DOKU_LF;\n    }\n\n    /**\n     * Output unformatted $text\n     *\n     * Defaults to $this->cdata()\n     *\n     * @param string $text\n     */\n    public function unformatted($text) {\n        $this->doc .= $this->_xmlEntities($text);\n    }\n\n    /**\n     * Start a block quote\n     */\n    public function quote_open() {\n        $this->doc .= '<blockquote><div class=\"no\">'.DOKU_LF;\n    }\n\n    /**\n     * Stop a block quote\n     */\n    public function quote_close() {\n        $this->doc .= '</div></blockquote>'.DOKU_LF;\n    }\n\n    /**\n     * Output preformatted text\n     *\n     * @param string $text\n     */\n    public function preformatted($text) {\n        $this->doc .= '<pre class=\"code\">'.trim($this->_xmlEntities($text), \"\\n\\r\").'</pre>'.DOKU_LF;\n    }\n\n    /**\n     * Display text as file content, optionally syntax highlighted\n     *\n     * @param string $text     text to show\n     * @param string $language programming language to use for syntax highlighting\n     * @param string $filename file path label\n     * @param array  $options  assoziative array with additional geshi options\n     */\n    public function file($text, $language = null, $filename = null, $options=null) {\n        $this->_highlight('file', $text, $language, $filename, $options);\n    }\n\n    /**\n     * Display text as code content, optionally syntax highlighted\n     *\n     * @param string $text     text to show\n     * @param string $language programming language to use for syntax highlighting\n     * @param string $filename file path label\n     * @param array  $options  assoziative array with additional geshi options\n     */\n    public function code($text, $language = null, $filename = null, $options=null) {\n        $this->_highlight('code', $text, $language, $filename, $options);\n    }\n\n    /**\n     * Use GeSHi to highlight language syntax in code and file blocks\n     *\n     * @author Andreas Gohr <andi@splitbrain.org>\n     * @param string $type     code|file\n     * @param string $text     text to show\n     * @param string $language programming language to use for syntax highlighting\n     * @param string $filename file path label\n     * @param array  $options  assoziative array with additional geshi options\n     */\n    public function _highlight($type, $text, $language = null, $filename = null, $options = null) {\n        global $ID;\n        global $lang;\n        global $INPUT;\n\n        $language = preg_replace(PREG_PATTERN_VALID_LANGUAGE, '', $language ?? '');\n\n        if($filename) {\n            // add icon\n            list($ext) = mimetype($filename, false);\n            $class = preg_replace('/[^_\\-a-z0-9]+/i', '_', $ext);\n            $class = 'mediafile mf_'.$class;\n\n            $offset = 0;\n            if ($INPUT->has('codeblockOffset')) {\n                $offset = $INPUT->str('codeblockOffset');\n            }\n            $this->doc .= '<dl class=\"'.$type.'\">'.DOKU_LF;\n            $this->doc .= '<dt><a href=\"' .\n                exportlink(\n                    $ID,\n                    'code',\n                    array('codeblock' => $offset + $this->_codeblock)\n                ) . '\" title=\"' . $lang['download'] . '\" class=\"' . $class . '\">';\n            $this->doc .= hsc($filename);\n            $this->doc .= '</a></dt>'.DOKU_LF.'<dd>';\n        }\n\n        if($text[0] == \"\\n\") {\n            $text = substr($text, 1);\n        }\n        if(substr($text, -1) == \"\\n\") {\n            $text = substr($text, 0, -1);\n        }\n\n        if(empty($language)) { // empty is faster than is_null and can prevent '' string\n            $this->doc .= '<pre class=\"'.$type.'\">'.$this->_xmlEntities($text).'</pre>'.DOKU_LF;\n        } else {\n            $class = 'code'; //we always need the code class to make the syntax highlighting apply\n            if($type != 'code') $class .= ' '.$type;\n\n            $this->doc .= \"<pre class=\\\"$class $language\\\">\" .\n                p_xhtml_cached_geshi($text, $language, '', $options) .\n                '</pre>' . DOKU_LF;\n        }\n\n        if($filename) {\n            $this->doc .= '</dd></dl>'.DOKU_LF;\n        }\n\n        $this->_codeblock++;\n    }\n\n    /**\n     * Format an acronym\n     *\n     * Uses $this->acronyms\n     *\n     * @param string $acronym\n     */\n    public function acronym($acronym) {\n\n        if(array_key_exists($acronym, $this->acronyms)) {\n\n            $title = $this->_xmlEntities($this->acronyms[$acronym]);\n\n            $this->doc .= '<abbr title=\"'.$title\n                .'\">'.$this->_xmlEntities($acronym).'</abbr>';\n\n        } else {\n            $this->doc .= $this->_xmlEntities($acronym);\n        }\n    }\n\n    /**\n     * Format a smiley\n     *\n     * Uses $this->smiley\n     *\n     * @param string $smiley\n     */\n    public function smiley($smiley) {\n        if (isset($this->smileys[$smiley])) {\n            $this->doc .= '<img src=\"' . DOKU_BASE . 'lib/images/smileys/' . $this->smileys[$smiley] .\n                '\" class=\"icon smiley\" alt=\"' . $this->_xmlEntities($smiley) . '\" />';\n        } else {\n            $this->doc .= $this->_xmlEntities($smiley);\n        }\n    }\n\n    /**\n     * Format an entity\n     *\n     * Entities are basically small text replacements\n     *\n     * Uses $this->entities\n     *\n     * @param string $entity\n     */\n    public function entity($entity) {\n        if(array_key_exists($entity, $this->entities)) {\n            $this->doc .= $this->entities[$entity];\n        } else {\n            $this->doc .= $this->_xmlEntities($entity);\n        }\n    }\n\n    /**\n     * Typographically format a multiply sign\n     *\n     * Example: ($x=640, $y=480) should result in \"640\u00d7480\"\n     *\n     * @param string|int $x first value\n     * @param string|int $y second value\n     */\n    public function multiplyentity($x, $y) {\n        $this->doc .= \"$x&times;$y\";\n    }\n\n    /**\n     * Render an opening single quote char (language specific)\n     */\n    public function singlequoteopening() {\n        global $lang;\n        $this->doc .= $lang['singlequoteopening'];\n    }\n\n    /**\n     * Render a closing single quote char (language specific)\n     */\n    public function singlequoteclosing() {\n        global $lang;\n        $this->doc .= $lang['singlequoteclosing'];\n    }\n\n    /**\n     * Render an apostrophe char (language specific)\n     */\n    public function apostrophe() {\n        global $lang;\n        $this->doc .= $lang['apostrophe'];\n    }\n\n    /**\n     * Render an opening double quote char (language specific)\n     */\n    public function doublequoteopening() {\n        global $lang;\n        $this->doc .= $lang['doublequoteopening'];\n    }\n\n    /**\n     * Render an closinging double quote char (language specific)\n     */\n    public function doublequoteclosing() {\n        global $lang;\n        $this->doc .= $lang['doublequoteclosing'];\n    }\n\n    /**\n     * Render a CamelCase link\n     *\n     * @param string $link       The link name\n     * @param bool   $returnonly whether to return html or write to doc attribute\n     * @return void|string writes to doc attribute or returns html depends on $returnonly\n     *\n     * @see http://en.wikipedia.org/wiki/CamelCase\n     */\n    public function camelcaselink($link, $returnonly = false) {\n        if($returnonly) {\n          return $this->internallink($link, $link, null, true);\n        } else {\n          $this->internallink($link, $link);\n        }\n    }\n\n    /**\n     * Render a page local link\n     *\n     * @param string $hash       hash link identifier\n     * @param string $name       name for the link\n     * @param bool   $returnonly whether to return html or write to doc attribute\n     * @return void|string writes to doc attribute or returns html depends on $returnonly\n     */\n    public function locallink($hash, $name = null, $returnonly = false) {\n        global $ID;\n        $name  = $this->_getLinkTitle($name, $hash, $isImage);\n        $hash  = $this->_headerToLink($hash);\n        $title = $ID.' \u21b5';\n\n        $doc = '<a href=\"#'.$hash.'\" title=\"'.$title.'\" class=\"wikilink1\">';\n        $doc .= $name;\n        $doc .= '</a>';\n\n        if($returnonly) {\n          return $doc;\n        } else {\n          $this->doc .= $doc;\n        }\n    }\n\n    /**\n     * Render an internal Wiki Link\n     *\n     * $search,$returnonly & $linktype are not for the renderer but are used\n     * elsewhere - no need to implement them in other renderers\n     *\n     * @author Andreas Gohr <andi@splitbrain.org>\n     * @param string      $id         pageid\n     * @param string|null $name       link name\n     * @param string|null $search     adds search url param\n     * @param bool        $returnonly whether to return html or write to doc attribute\n     * @param string      $linktype   type to set use of headings\n     * @return void|string writes to doc attribute or returns html depends on $returnonly\n     */\n    public function internallink($id, $name = null, $search = null, $returnonly = false, $linktype = 'content') {\n        global $conf;\n        global $ID;\n        global $INFO;\n\n        $params = '';\n        $parts  = explode('?', $id, 2);\n        if(count($parts) === 2) {\n            $id     = $parts[0];\n            $params = $parts[1];\n        }\n\n        // For empty $id we need to know the current $ID\n        // We need this check because _simpleTitle needs\n        // correct $id and resolve_pageid() use cleanID($id)\n        // (some things could be lost)\n        if($id === '') {\n            $id = $ID;\n        }\n\n        // default name is based on $id as given\n        $default = $this->_simpleTitle($id);\n\n        // now first resolve and clean up the $id\n        $id = (new PageResolver($ID))->resolveId($id, $this->date_at, true);\n        $exists = page_exists($id, $this->date_at, false, true);\n\n        $link = array();\n        $name = $this->_getLinkTitle($name, $default, $isImage, $id, $linktype);\n        if(!$isImage) {\n            if($exists) {\n                $class = 'wikilink1';\n            } else {\n                $class       = 'wikilink2';\n                $link['rel'] = 'nofollow';\n            }\n        } else {\n            $class = 'media';\n        }\n\n        //keep hash anchor\n        list($id, $hash) = sexplode('#', $id, 2);\n        if(!empty($hash)) $hash = $this->_headerToLink($hash);\n\n        //prepare for formating\n        $link['target'] = $conf['target']['wiki'];\n        $link['style']  = '';\n        $link['pre']    = '';\n        $link['suf']    = '';\n        $link['more']   = 'data-wiki-id=\"'.$id.'\"'; // id is already cleaned\n        $link['class']  = $class;\n        if($this->date_at) {\n            $params = $params.'&at='.rawurlencode($this->date_at);\n        }\n        $link['url']    = wl($id, $params);\n        $link['name']   = $name;\n        $link['title']  = $id;\n        //add search string\n        if($search) {\n            ($conf['userewrite']) ? $link['url'] .= '?' : $link['url'] .= '&amp;';\n            if(is_array($search)) {\n                $search = array_map('rawurlencode', $search);\n                $link['url'] .= 's[]='.join('&amp;s[]=', $search);\n            } else {\n                $link['url'] .= 's='.rawurlencode($search);\n            }\n        }\n\n        //keep hash\n        if($hash) $link['url'] .= '#'.$hash;\n\n        //output formatted\n        if($returnonly) {\n            return $this->_formatLink($link);\n        } else {\n            $this->doc .= $this->_formatLink($link);\n        }\n    }\n\n    /**\n     * Render an external link\n     *\n     * @param string       $url        full URL with scheme\n     * @param string|array $name       name for the link, array for media file\n     * @param bool         $returnonly whether to return html or write to doc attribute\n     * @return void|string writes to doc attribute or returns html depends on $returnonly\n     */\n    public function externallink($url, $name = null, $returnonly = false) {\n        global $conf;\n\n        $name = $this->_getLinkTitle($name, $url, $isImage);\n\n        // url might be an attack vector, only allow registered protocols\n        if(is_null($this->schemes)) $this->schemes = getSchemes();\n        list($scheme) = explode('://', $url);\n        $scheme = strtolower($scheme);\n        if(!in_array($scheme, $this->schemes)) $url = '';\n\n        // is there still an URL?\n        if(!$url) {\n            if($returnonly) {\n                return $name;\n            } else {\n                $this->doc .= $name;\n            }\n            return;\n        }\n\n        // set class\n        if(!$isImage) {\n            $class = 'urlextern';\n        } else {\n            $class = 'media';\n        }\n\n        //prepare for formating\n        $link = array();\n        $link['target'] = $conf['target']['extern'];\n        $link['style']  = '';\n        $link['pre']    = '';\n        $link['suf']    = '';\n        $link['more']   = '';\n        $link['class']  = $class;\n        $link['url']    = $url;\n        $link['rel']    = '';\n\n        $link['name']  = $name;\n        $link['title'] = $this->_xmlEntities($url);\n        if($conf['relnofollow']) $link['rel'] .= ' ugc nofollow';\n        if($conf['target']['extern']) $link['rel'] .= ' noopener';\n\n        //output formatted\n        if($returnonly) {\n            return $this->_formatLink($link);\n        } else {\n            $this->doc .= $this->_formatLink($link);\n        }\n    }\n\n    /**\n     * Render an interwiki link\n     *\n     * You may want to use $this->_resolveInterWiki() here\n     *\n     * @param string       $match      original link - probably not much use\n     * @param string|array $name       name for the link, array for media file\n     * @param string       $wikiName   indentifier (shortcut) for the remote wiki\n     * @param string       $wikiUri    the fragment parsed from the original link\n     * @param bool         $returnonly whether to return html or write to doc attribute\n     * @return void|string writes to doc attribute or returns html depends on $returnonly\n     */\n    public function interwikilink($match, $name, $wikiName, $wikiUri, $returnonly = false) {\n        global $conf;\n\n        $link           = array();\n        $link['target'] = $conf['target']['interwiki'];\n        $link['pre']    = '';\n        $link['suf']    = '';\n        $link['more']   = '';\n        $link['name']   = $this->_getLinkTitle($name, $wikiUri, $isImage);\n        $link['rel']    = '';\n\n        //get interwiki URL\n        $exists = null;\n        $url    = $this->_resolveInterWiki($wikiName, $wikiUri, $exists);\n\n        if(!$isImage) {\n            $class         = preg_replace('/[^_\\-a-z0-9]+/i', '_', $wikiName);\n            $link['class'] = \"interwiki iw_$class\";\n        } else {\n            $link['class'] = 'media';\n        }\n\n        //do we stay at the same server? Use local target\n        if(strpos($url, DOKU_URL) === 0 OR strpos($url, DOKU_BASE) === 0) {\n            $link['target'] = $conf['target']['wiki'];\n        }\n        if($exists !== null && !$isImage) {\n            if($exists) {\n                $link['class'] .= ' wikilink1';\n            } else {\n                $link['class'] .= ' wikilink2';\n                $link['rel'] .= ' nofollow';\n            }\n        }\n        if($conf['target']['interwiki']) $link['rel'] .= ' noopener';\n\n        $link['url']   = $url;\n        $link['title'] = $this->_xmlEntities($link['url']);\n\n        // output formatted\n        if($returnonly) {\n            if($url == '') return $link['name'];\n            return $this->_formatLink($link);\n        } else {\n            if($url == '') $this->doc .= $link['name'];\n            else $this->doc .= $this->_formatLink($link);\n        }\n    }\n\n    /**\n     * Link to windows share\n     *\n     * @param string       $url        the link\n     * @param string|array $name       name for the link, array for media file\n     * @param bool         $returnonly whether to return html or write to doc attribute\n     * @return void|string writes to doc attribute or returns html depends on $returnonly\n     */\n    public function windowssharelink($url, $name = null, $returnonly = false) {\n        global $conf;\n\n        //simple setup\n        $link = array();\n        $link['target'] = $conf['target']['windows'];\n        $link['pre']    = '';\n        $link['suf']    = '';\n        $link['style']  = '';\n\n        $link['name'] = $this->_getLinkTitle($name, $url, $isImage);\n        if(!$isImage) {\n            $link['class'] = 'windows';\n        } else {\n            $link['class'] = 'media';\n        }\n\n        $link['title'] = $this->_xmlEntities($url);\n        $url           = str_replace('\\\\', '/', $url);\n        $url           = 'file:///'.$url;\n        $link['url']   = $url;\n\n        //output formatted\n        if($returnonly) {\n            return $this->_formatLink($link);\n        } else {\n            $this->doc .= $this->_formatLink($link);\n        }\n    }\n\n    /**\n     * Render a linked E-Mail Address\n     *\n     * Honors $conf['mailguard'] setting\n     *\n     * @param string       $address    Email-Address\n     * @param string|array $name       name for the link, array for media file\n     * @param bool         $returnonly whether to return html or write to doc attribute\n     * @return void|string writes to doc attribute or returns html depends on $returnonly\n     */\n    public function emaillink($address, $name = null, $returnonly = false) {\n        global $conf;\n        //simple setup\n        $link           = array();\n        $link['target'] = '';\n        $link['pre']    = '';\n        $link['suf']    = '';\n        $link['style']  = '';\n        $link['more']   = '';\n\n        $name = $this->_getLinkTitle($name, '', $isImage);\n        if(!$isImage) {\n            $link['class'] = 'mail';\n        } else {\n            $link['class'] = 'media';\n        }\n\n        $address = $this->_xmlEntities($address);\n        $address = obfuscate($address);\n        $title   = $address;\n\n        if(empty($name)) {\n            $name = $address;\n        }\n\n        if($conf['mailguard'] == 'visible') $address = rawurlencode($address);\n\n        $link['url']   = 'mailto:'.$address;\n        $link['name']  = $name;\n        $link['title'] = $title;\n\n        //output formatted\n        if($returnonly) {\n            return $this->_formatLink($link);\n        } else {\n            $this->doc .= $this->_formatLink($link);\n        }\n    }\n\n    /**\n     * Render an internal media file\n     *\n     * @param string $src       media ID\n     * @param string $title     descriptive text\n     * @param string $align     left|center|right\n     * @param int    $width     width of media in pixel\n     * @param int    $height    height of media in pixel\n     * @param string $cache     cache|recache|nocache\n     * @param string $linking   linkonly|detail|nolink\n     * @param bool   $return    return HTML instead of adding to $doc\n     * @return void|string writes to doc attribute or returns html depends on $return\n     */\n    public function internalmedia($src, $title = null, $align = null, $width = null,\n                           $height = null, $cache = null, $linking = null, $return = false) {\n        global $ID;\n        if (strpos($src, '#') !== false) {\n            list($src, $hash) = sexplode('#', $src, 2);\n        }\n        $src = (new MediaResolver($ID))->resolveId($src,$this->date_at,true);\n        $exists = media_exists($src);\n\n        $noLink = false;\n        $render = ($linking == 'linkonly') ? false : true;\n        $link   = $this->_getMediaLinkConf($src, $title, $align, $width, $height, $cache, $render);\n\n        list($ext, $mime) = mimetype($src, false);\n        if(substr($mime, 0, 5) == 'image' && $render) {\n            $link['url'] = ml(\n                $src,\n                array(\n                    'id' => $ID,\n                    'cache' => $cache,\n                    'rev' => $this->_getLastMediaRevisionAt($src)\n                ),\n                ($linking == 'direct')\n            );\n        } elseif(($mime == 'application/x-shockwave-flash' || media_supportedav($mime)) && $render) {\n            // don't link movies\n            $noLink = true;\n        } else {\n            // add file icons\n            $class = preg_replace('/[^_\\-a-z0-9]+/i', '_', $ext);\n            $link['class'] .= ' mediafile mf_'.$class;\n            $link['url'] = ml(\n                $src,\n                array(\n                    'id' => $ID,\n                    'cache' => $cache,\n                    'rev' => $this->_getLastMediaRevisionAt($src)\n                ),\n                true\n            );\n            if($exists) $link['title'] .= ' ('.filesize_h(filesize(mediaFN($src))).')';\n        }\n\n        if (!empty($hash)) $link['url'] .= '#'.$hash;\n\n        //markup non existing files\n        if(!$exists) {\n            $link['class'] .= ' wikilink2';\n        }\n\n        //output formatted\n        if($return) {\n            if($linking == 'nolink' || $noLink) return $link['name'];\n            else return $this->_formatLink($link);\n        } else {\n            if($linking == 'nolink' || $noLink) $this->doc .= $link['name'];\n            else $this->doc .= $this->_formatLink($link);\n        }\n    }\n\n    /**\n     * Render an external media file\n     *\n     * @param string $src     full media URL\n     * @param string $title   descriptive text\n     * @param string $align   left|center|right\n     * @param int    $width   width of media in pixel\n     * @param int    $height  height of media in pixel\n     * @param string $cache   cache|recache|nocache\n     * @param string $linking linkonly|detail|nolink\n     * @param bool   $return  return HTML instead of adding to $doc\n     * @return void|string writes to doc attribute or returns html depends on $return\n     */\n    public function externalmedia($src, $title = null, $align = null, $width = null,\n                           $height = null, $cache = null, $linking = null, $return = false) {\n        if(link_isinterwiki($src)){\n            list($shortcut, $reference) = sexplode('>', $src, 2, '');\n            $exists = null;\n            $src = $this->_resolveInterWiki($shortcut, $reference, $exists);\n            if($src == '' && empty($title)){\n                // make sure at least something will be shown in this case\n                $title = $reference;\n            }\n        }\n        list($src, $hash) = sexplode('#', $src, 2);\n        $noLink = false;\n        if($src == '') {\n            // only output plaintext without link if there is no src\n            $noLink = true;\n        }\n        $render = ($linking == 'linkonly') ? false : true;\n        $link   = $this->_getMediaLinkConf($src, $title, $align, $width, $height, $cache, $render);\n\n        $link['url'] = ml($src, array('cache' => $cache));\n\n        list($ext, $mime) = mimetype($src, false);\n        if(substr($mime, 0, 5) == 'image' && $render) {\n            // link only jpeg images\n            // if ($ext != 'jpg' && $ext != 'jpeg') $noLink = true;\n        } elseif(($mime == 'application/x-shockwave-flash' || media_supportedav($mime)) && $render) {\n            // don't link movies\n            $noLink = true;\n        } else {\n            // add file icons\n            $class = preg_replace('/[^_\\-a-z0-9]+/i', '_', $ext);\n            $link['class'] .= ' mediafile mf_'.$class;\n        }\n\n        if($hash) $link['url'] .= '#'.$hash;\n\n        //output formatted\n        if($return) {\n            if($linking == 'nolink' || $noLink) return $link['name'];\n            else return $this->_formatLink($link);\n        } else {\n            if($linking == 'nolink' || $noLink) $this->doc .= $link['name'];\n            else $this->doc .= $this->_formatLink($link);\n        }\n    }\n\n    /**\n     * Renders an RSS feed\n     *\n     * @param string $url    URL of the feed\n     * @param array  $params Finetuning of the output\n     *\n     * @author Andreas Gohr <andi@splitbrain.org>\n     */\n    public function rss($url, $params) {\n        global $lang;\n        global $conf;\n\n        require_once(DOKU_INC.'inc/FeedParser.php');\n        $feed = new FeedParser();\n        $feed->set_feed_url($url);\n\n        //disable warning while fetching\n        if(!defined('DOKU_E_LEVEL')) {\n            $elvl = error_reporting(E_ERROR);\n        }\n        $rc = $feed->init();\n        if(isset($elvl)) {\n            error_reporting($elvl);\n        }\n\n        if($params['nosort']) $feed->enable_order_by_date(false);\n\n        //decide on start and end\n        if($params['reverse']) {\n            $mod   = -1;\n            $start = $feed->get_item_quantity() - 1;\n            $end   = $start - ($params['max']);\n            $end   = ($end < -1) ? -1 : $end;\n        } else {\n            $mod   = 1;\n            $start = 0;\n            $end   = $feed->get_item_quantity();\n            $end   = ($end > $params['max']) ? $params['max'] : $end;\n        }\n\n        $this->doc .= '<ul class=\"rss\">';\n        if($rc) {\n            for($x = $start; $x != $end; $x += $mod) {\n                $item = $feed->get_item($x);\n                $this->doc .= '<li><div class=\"li\">';\n                // support feeds without links\n                $lnkurl = $item->get_permalink();\n                if($lnkurl) {\n                    // title is escaped by SimplePie, we unescape here because it\n                    // is escaped again in externallink() FS#1705\n                    $this->externallink(\n                        $item->get_permalink(),\n                        html_entity_decode($item->get_title(), ENT_QUOTES, 'UTF-8')\n                    );\n                } else {\n                    $this->doc .= ' '.$item->get_title();\n                }\n                if($params['author']) {\n                    $author = $item->get_author(0);\n                    if($author) {\n                        $name = $author->get_name();\n                        if(!$name) $name = $author->get_email();\n                        if($name) $this->doc .= ' '.$lang['by'].' '.hsc($name);\n                    }\n                }\n                if($params['date']) {\n                    $this->doc .= ' ('.$item->get_local_date($conf['dformat']).')';\n                }\n                if($params['details']) {\n                    $this->doc .= '<div class=\"detail\">';\n                    $this->doc .= strip_tags($item->get_description());\n                    $this->doc .= '</div>';\n                }\n\n                $this->doc .= '</div></li>';\n            }\n        } else {\n            $this->doc .= '<li><div class=\"li\">';\n            $this->doc .= '<em>'.$lang['rssfailed'].'</em>';\n            $this->externallink($url);\n            if($conf['allowdebug']) {\n                $this->doc .= '<!--'.hsc($feed->error).'-->';\n            }\n            $this->doc .= '</div></li>';\n        }\n        $this->doc .= '</ul>';\n    }\n\n    /**\n     * Start a table\n     *\n     * @param int $maxcols maximum number of columns\n     * @param int $numrows NOT IMPLEMENTED\n     * @param int $pos byte position in the original source\n     * @param string|string[] $classes css classes - have to be valid, do not pass unfiltered user input\n     */\n    public function table_open($maxcols = null, $numrows = null, $pos = null, $classes = null) {\n        // initialize the row counter used for classes\n        $this->_counter['row_counter'] = 0;\n        $class                         = 'table';\n        if($classes !== null) {\n            if(is_array($classes)) $classes = join(' ', $classes);\n            $class .= ' ' . $classes;\n        }\n        if($pos !== null) {\n            $hid = $this->_headerToLink($class, true);\n            $data = array();\n            $data['target'] = 'table';\n            $data['name'] = '';\n            $data['hid'] = $hid;\n            $class .= ' '.$this->startSectionEdit($pos, $data);\n        }\n        $this->doc .= '<div class=\"'.$class.'\"><table class=\"inline\">'.\n            DOKU_LF;\n    }\n\n    /**\n     * Close a table\n     *\n     * @param int $pos byte position in the original source\n     */\n    public function table_close($pos = null) {\n        $this->doc .= '</table></div>'.DOKU_LF;\n        if($pos !== null) {\n            $this->finishSectionEdit($pos);\n        }\n    }\n\n    /**\n     * Open a table header\n     */\n    public function tablethead_open() {\n        $this->doc .= DOKU_TAB.'<thead>'.DOKU_LF;\n    }\n\n    /**\n     * Close a table header\n     */\n    public function tablethead_close() {\n        $this->doc .= DOKU_TAB.'</thead>'.DOKU_LF;\n    }\n\n    /**\n     * Open a table body\n     */\n    public function tabletbody_open() {\n        $this->doc .= DOKU_TAB.'<tbody>'.DOKU_LF;\n    }\n\n    /**\n     * Close a table body\n     */\n    public function tabletbody_close() {\n        $this->doc .= DOKU_TAB.'</tbody>'.DOKU_LF;\n    }\n\n    /**\n     * Open a table footer\n     */\n    public function tabletfoot_open() {\n        $this->doc .= DOKU_TAB.'<tfoot>'.DOKU_LF;\n    }\n\n    /**\n     * Close a table footer\n     */\n    public function tabletfoot_close() {\n        $this->doc .= DOKU_TAB.'</tfoot>'.DOKU_LF;\n    }\n\n    /**\n     * Open a table row\n     *\n     * @param string|string[] $classes css classes - have to be valid, do not pass unfiltered user input\n     */\n    public function tablerow_open($classes = null) {\n        // initialize the cell counter used for classes\n        $this->_counter['cell_counter'] = 0;\n        $class                          = 'row'.$this->_counter['row_counter']++;\n        if($classes !== null) {\n            if(is_array($classes)) $classes = join(' ', $classes);\n            $class .= ' ' . $classes;\n        }\n        $this->doc .= DOKU_TAB.'<tr class=\"'.$class.'\">'.DOKU_LF.DOKU_TAB.DOKU_TAB;\n    }\n\n    /**\n     * Close a table row\n     */\n    public function tablerow_close() {\n        $this->doc .= DOKU_LF.DOKU_TAB.'</tr>'.DOKU_LF;\n    }\n\n    /**\n     * Open a table header cell\n     *\n     * @param int    $colspan\n     * @param string $align left|center|right\n     * @param int    $rowspan\n     * @param string|string[] $classes css classes - have to be valid, do not pass unfiltered user input\n     */\n    public function tableheader_open($colspan = 1, $align = null, $rowspan = 1, $classes = null) {\n        $class = 'class=\"col'.$this->_counter['cell_counter']++;\n        if(!is_null($align)) {\n            $class .= ' '.$align.'align';\n        }\n        if($classes !== null) {\n            if(is_array($classes)) $classes = join(' ', $classes);\n            $class .= ' ' . $classes;\n        }\n        $class .= '\"';\n        $this->doc .= '<th '.$class;\n        if($colspan > 1) {\n            $this->_counter['cell_counter'] += $colspan - 1;\n            $this->doc .= ' colspan=\"'.$colspan.'\"';\n        }\n        if($rowspan > 1) {\n            $this->doc .= ' rowspan=\"'.$rowspan.'\"';\n        }\n        $this->doc .= '>';\n    }\n\n    /**\n     * Close a table header cell\n     */\n    public function tableheader_close() {\n        $this->doc .= '</th>';\n    }\n\n    /**\n     * Open a table cell\n     *\n     * @param int       $colspan\n     * @param string    $align left|center|right\n     * @param int       $rowspan\n     * @param string|string[]    $classes css classes - have to be valid, do not pass unfiltered user input\n     */\n    public function tablecell_open($colspan = 1, $align = null, $rowspan = 1, $classes = null) {\n        $class = 'class=\"col'.$this->_counter['cell_counter']++;\n        if(!is_null($align)) {\n            $class .= ' '.$align.'align';\n        }\n        if($classes !== null) {\n            if(is_array($classes)) $classes = join(' ', $classes);\n            $class .= ' ' . $classes;\n        }\n        $class .= '\"';\n        $this->doc .= '<td '.$class;\n        if($colspan > 1) {\n            $this->_counter['cell_counter'] += $colspan - 1;\n            $this->doc .= ' colspan=\"'.$colspan.'\"';\n        }\n        if($rowspan > 1) {\n            $this->doc .= ' rowspan=\"'.$rowspan.'\"';\n        }\n        $this->doc .= '>';\n    }\n\n    /**\n     * Close a table cell\n     */\n    public function tablecell_close() {\n        $this->doc .= '</td>';\n    }\n\n    /**\n     * Returns the current header level.\n     * (required e.g. by the filelist plugin)\n     *\n     * @return int The current header level\n     */\n    public function getLastlevel() {\n        return $this->lastlevel;\n    }\n\n    #region Utility functions\n\n    /**\n     * Build a link\n     *\n     * Assembles all parts defined in $link returns HTML for the link\n     *\n     * @param array $link attributes of a link\n     * @return string\n     *\n     * @author Andreas Gohr <andi@splitbrain.org>\n     */\n    public function _formatLink($link) {\n        //make sure the url is XHTML compliant (skip mailto)\n        if(substr($link['url'], 0, 7) != 'mailto:') {\n            $link['url'] = str_replace('&', '&amp;', $link['url']);\n            $link['url'] = str_replace('&amp;amp;', '&amp;', $link['url']);\n        }\n        //remove double encodings in titles\n        $link['title'] = str_replace('&amp;amp;', '&amp;', $link['title']);\n\n        // be sure there are no bad chars in url or title\n        // (we can't do this for name because it can contain an img tag)\n        $link['url']   = strtr($link['url'], array('>' => '%3E', '<' => '%3C', '\"' => '%22'));\n        $link['title'] = strtr($link['title'], array('>' => '&gt;', '<' => '&lt;', '\"' => '&quot;'));\n\n        $ret = '';\n        $ret .= $link['pre'];\n        $ret .= '<a href=\"'.$link['url'].'\"';\n        if(!empty($link['class'])) $ret .= ' class=\"'.$link['class'].'\"';\n        if(!empty($link['target'])) $ret .= ' target=\"'.$link['target'].'\"';\n        if(!empty($link['title'])) $ret .= ' title=\"'.$link['title'].'\"';\n        if(!empty($link['style'])) $ret .= ' style=\"'.$link['style'].'\"';\n        if(!empty($link['rel'])) $ret .= ' rel=\"'.trim($link['rel']).'\"';\n        if(!empty($link['more'])) $ret .= ' '.$link['more'];\n        $ret .= '>';\n        $ret .= $link['name'];\n        $ret .= '</a>';\n        $ret .= $link['suf'];\n        return $ret;\n    }\n\n    /**\n     * Renders internal and external media\n     *\n     * @author Andreas Gohr <andi@splitbrain.org>\n     * @param string $src       media ID\n     * @param string $title     descriptive text\n     * @param string $align     left|center|right\n     * @param int    $width     width of media in pixel\n     * @param int    $height    height of media in pixel\n     * @param string $cache     cache|recache|nocache\n     * @param bool   $render    should the media be embedded inline or just linked\n     * @return string\n     */\n    public function _media($src, $title = null, $align = null, $width = null,\n                    $height = null, $cache = null, $render = true) {\n\n        $ret = '';\n\n        list($ext, $mime) = mimetype($src);\n        if(substr($mime, 0, 5) == 'image') {\n            // first get the $title\n            if(!is_null($title)) {\n                $title = $this->_xmlEntities($title);\n            } elseif($ext == 'jpg' || $ext == 'jpeg') {\n                //try to use the caption from IPTC/EXIF\n                require_once(DOKU_INC.'inc/JpegMeta.php');\n                $jpeg = new JpegMeta(mediaFN($src));\n                if($jpeg !== false) $cap = $jpeg->getTitle();\n                if(!empty($cap)) {\n                    $title = $this->_xmlEntities($cap);\n                }\n            }\n            if(!$render) {\n                // if the picture is not supposed to be rendered\n                // return the title of the picture\n                if($title === null || $title === \"\") {\n                    // just show the sourcename\n                    $title = $this->_xmlEntities(\\dokuwiki\\Utf8\\PhpString::basename(noNS($src)));\n                }\n                return $title;\n            }\n            //add image tag\n            $ret .= '<img src=\"' . ml(\n                    $src,\n                    array(\n                        'w' => $width, 'h' => $height,\n                        'cache' => $cache,\n                        'rev' => $this->_getLastMediaRevisionAt($src)\n                    )\n                ) . '\"';\n            $ret .= ' class=\"media'.$align.'\"';\n            $ret .= ' loading=\"lazy\"';\n\n            if($title) {\n                $ret .= ' title=\"'.$title.'\"';\n                $ret .= ' alt=\"'.$title.'\"';\n            } else {\n                $ret .= ' alt=\"\"';\n            }\n\n            if(!is_null($width))\n                $ret .= ' width=\"'.$this->_xmlEntities($width).'\"';\n\n            if(!is_null($height))\n                $ret .= ' height=\"'.$this->_xmlEntities($height).'\"';\n\n            $ret .= ' />';\n\n        } elseif(media_supportedav($mime, 'video') || media_supportedav($mime, 'audio')) {\n            // first get the $title\n            $title = !is_null($title) ? $title : false;\n            if(!$render) {\n                // if the file is not supposed to be rendered\n                // return the title of the file (just the sourcename if there is no title)\n                return $this->_xmlEntities($title ? $title : \\dokuwiki\\Utf8\\PhpString::basename(noNS($src)));\n            }\n\n            $att          = array();\n            $att['class'] = \"media$align\";\n            if($title) {\n                $att['title'] = $title;\n            }\n\n            if(media_supportedav($mime, 'video')) {\n                //add video\n                $ret .= $this->_video($src, $width, $height, $att);\n            }\n            if(media_supportedav($mime, 'audio')) {\n                //add audio\n                $ret .= $this->_audio($src, $att);\n            }\n\n        } elseif($mime == 'application/x-shockwave-flash') {\n            if(!$render) {\n                // if the flash is not supposed to be rendered\n                // return the title of the flash\n                if(!$title) {\n                    // just show the sourcename\n                    $title = \\dokuwiki\\Utf8\\PhpString::basename(noNS($src));\n                }\n                return $this->_xmlEntities($title);\n            }\n\n            $att          = array();\n            $att['class'] = \"media$align\";\n            if($align == 'right') $att['align'] = 'right';\n            if($align == 'left') $att['align'] = 'left';\n            $ret .= html_flashobject(\n                ml($src, array('cache' => $cache), true, '&'), $width, $height,\n                array('quality' => 'high'),\n                null,\n                $att,\n                $this->_xmlEntities($title)\n            );\n        } elseif($title) {\n            // well at least we have a title to display\n            $ret .= $this->_xmlEntities($title);\n        } else {\n            // just show the sourcename\n            $ret .= $this->_xmlEntities(\\dokuwiki\\Utf8\\PhpString::basename(noNS($src)));\n        }\n\n        return $ret;\n    }\n\n    /**\n     * Escape string for output\n     *\n     * @param $string\n     * @return string\n     */\n    public function _xmlEntities($string) {\n        return hsc($string);\n    }\n\n\n\n    /**\n     * Construct a title and handle images in titles\n     *\n     * @author Harry Fuecks <hfuecks@gmail.com>\n     * @param string|array $title    either string title or media array\n     * @param string       $default  default title if nothing else is found\n     * @param bool         $isImage  will be set to true if it's a media file\n     * @param null|string  $id       linked page id (used to extract title from first heading)\n     * @param string       $linktype content|navigation\n     * @return string      HTML of the title, might be full image tag or just escaped text\n     */\n    public function _getLinkTitle($title, $default, &$isImage, $id = null, $linktype = 'content') {\n        $isImage = false;\n        if(is_array($title)) {\n            $isImage = true;\n            return $this->_imageTitle($title);\n        } elseif(is_null($title) || trim($title) == '') {\n            if(useHeading($linktype) && $id) {\n                $heading = p_get_first_heading($id);\n                if(!blank($heading)) {\n                    return $this->_xmlEntities($heading);\n                }\n            }\n            return $this->_xmlEntities($default);\n        } else {\n            return $this->_xmlEntities($title);\n        }\n    }\n\n    /**\n     * Returns HTML code for images used in link titles\n     *\n     * @author Andreas Gohr <andi@splitbrain.org>\n     * @param array $img\n     * @return string HTML img tag or similar\n     */\n    public function _imageTitle($img) {\n        global $ID;\n\n        // some fixes on $img['src']\n        // see internalmedia() and externalmedia()\n        list($img['src']) = explode('#', $img['src'], 2);\n        if($img['type'] == 'internalmedia') {\n            $img['src'] = (new MediaResolver($ID))->resolveId($img['src'], $this->date_at, true);\n        }\n\n        return $this->_media(\n            $img['src'],\n            $img['title'],\n            $img['align'],\n            $img['width'],\n            $img['height'],\n            $img['cache']\n        );\n    }\n\n    /**\n     * helperfunction to return a basic link to a media\n     *\n     * used in internalmedia() and externalmedia()\n     *\n     * @author   Pierre Spring <pierre.spring@liip.ch>\n     * @param string $src       media ID\n     * @param string $title     descriptive text\n     * @param string $align     left|center|right\n     * @param int    $width     width of media in pixel\n     * @param int    $height    height of media in pixel\n     * @param string $cache     cache|recache|nocache\n     * @param bool   $render    should the media be embedded inline or just linked\n     * @return array associative array with link config\n     */\n    public function _getMediaLinkConf($src, $title, $align, $width, $height, $cache, $render) {\n        global $conf;\n\n        $link           = array();\n        $link['class']  = 'media';\n        $link['style']  = '';\n        $link['pre']    = '';\n        $link['suf']    = '';\n        $link['more']   = '';\n        $link['target'] = $conf['target']['media'];\n        if($conf['target']['media']) $link['rel'] = 'noopener';\n        $link['title']  = $this->_xmlEntities($src);\n        $link['name']   = $this->_media($src, $title, $align, $width, $height, $cache, $render);\n\n        return $link;\n    }\n\n    /**\n     * Embed video(s) in HTML\n     *\n     * @author Anika Henke <anika@selfthinker.org>\n     * @author Schplurtz le D\u00e9boulonn\u00e9 <Schplurtz@laposte.net>\n     *\n     * @param string $src         - ID of video to embed\n     * @param int    $width       - width of the video in pixels\n     * @param int    $height      - height of the video in pixels\n     * @param array  $atts        - additional attributes for the <video> tag\n     * @return string\n     */\n    public function _video($src, $width, $height, $atts = null) {\n        // prepare width and height\n        if(is_null($atts)) $atts = array();\n        $atts['width']  = (int) $width;\n        $atts['height'] = (int) $height;\n        if(!$atts['width']) $atts['width'] = 320;\n        if(!$atts['height']) $atts['height'] = 240;\n\n        $posterUrl = '';\n        $files = array();\n        $tracks = array();\n        $isExternal = media_isexternal($src);\n\n        if ($isExternal) {\n            // take direct source for external files\n            list(/*ext*/, $srcMime) = mimetype($src);\n            $files[$srcMime] = $src;\n        } else {\n            // prepare alternative formats\n            $extensions   = array('webm', 'ogv', 'mp4');\n            $files        = media_alternativefiles($src, $extensions);\n            $poster       = media_alternativefiles($src, array('jpg', 'png'));\n            $tracks       = media_trackfiles($src);\n            if(!empty($poster)) {\n                $posterUrl = ml(reset($poster), '', true, '&');\n            }\n        }\n\n        $out = '';\n        // open video tag\n        $out .= '<video '.buildAttributes($atts).' controls=\"controls\"';\n        if($posterUrl) $out .= ' poster=\"'.hsc($posterUrl).'\"';\n        $out .= '>'.NL;\n        $fallback = '';\n\n        // output source for each alternative video format\n        foreach($files as $mime => $file) {\n            if ($isExternal) {\n                $url = $file;\n                $linkType = 'externalmedia';\n            } else {\n                $url = ml($file, '', true, '&');\n                $linkType = 'internalmedia';\n            }\n            $title = !empty($atts['title'])\n                ? $atts['title']\n                : $this->_xmlEntities(\\dokuwiki\\Utf8\\PhpString::basename(noNS($file)));\n\n            $out .= '<source src=\"'.hsc($url).'\" type=\"'.$mime.'\" />'.NL;\n            // alternative content (just a link to the file)\n            $fallback .= $this->$linkType(\n                $file,\n                $title,\n                null,\n                null,\n                null,\n                $cache = null,\n                $linking = 'linkonly',\n                $return = true\n            );\n        }\n\n        // output each track if any\n        foreach( $tracks as $trackid => $info ) {\n            list( $kind, $srclang ) = array_map( 'hsc', $info );\n            $out .= \"<track kind=\\\"$kind\\\" srclang=\\\"$srclang\\\" \";\n            $out .= \"label=\\\"$srclang\\\" \";\n            $out .= 'src=\"'.ml($trackid, '', true).'\">'.NL;\n        }\n\n        // finish\n        $out .= $fallback;\n        $out .= '</video>'.NL;\n        return $out;\n    }\n\n    /**\n     * Embed audio in HTML\n     *\n     * @author Anika Henke <anika@selfthinker.org>\n     *\n     * @param string $src       - ID of audio to embed\n     * @param array  $atts      - additional attributes for the <audio> tag\n     * @return string\n     */\n    public function _audio($src, $atts = array()) {\n        $files = array();\n        $isExternal = media_isexternal($src);\n\n        if ($isExternal) {\n            // take direct source for external files\n            list(/*ext*/, $srcMime) = mimetype($src);\n            $files[$srcMime] = $src;\n        } else {\n            // prepare alternative formats\n            $extensions   = array('ogg', 'mp3', 'wav');\n            $files        = media_alternativefiles($src, $extensions);\n        }\n\n        $out = '';\n        // open audio tag\n        $out .= '<audio '.buildAttributes($atts).' controls=\"controls\">'.NL;\n        $fallback = '';\n\n        // output source for each alternative audio format\n        foreach($files as $mime => $file) {\n            if ($isExternal) {\n                $url = $file;\n                $linkType = 'externalmedia';\n            } else {\n                $url = ml($file, '', true, '&');\n                $linkType = 'internalmedia';\n            }\n            $title = $atts['title'] ? $atts['title'] : $this->_xmlEntities(\\dokuwiki\\Utf8\\PhpString::basename(noNS($file)));\n\n            $out .= '<source src=\"'.hsc($url).'\" type=\"'.$mime.'\" />'.NL;\n            // alternative content (just a link to the file)\n            $fallback .= $this->$linkType(\n                $file,\n                $title,\n                null,\n                null,\n                null,\n                $cache = null,\n                $linking = 'linkonly',\n                $return = true\n            );\n        }\n\n        // finish\n        $out .= $fallback;\n        $out .= '</audio>'.NL;\n        return $out;\n    }\n\n    /**\n     * _getLastMediaRevisionAt is a helperfunction to internalmedia() and _media()\n     * which returns an existing media revision less or equal to rev or date_at\n     *\n     * @author lisps\n     * @param string $media_id\n     * @access protected\n     * @return string revision ('' for current)\n     */\n    protected function _getLastMediaRevisionAt($media_id) {\n        if (!$this->date_at || media_isexternal($media_id)) return '';\n        $changelog = new MediaChangeLog($media_id);\n        return $changelog->getLastRevisionAt($this->date_at);\n    }\n\n    #endregion\n}\n\n//Setup VIM: ex: et ts=4 :\n"], "fixing_code": ["<?php\n\nuse dokuwiki\\ChangeLog\\MediaChangeLog;\nuse dokuwiki\\File\\MediaResolver;\nuse dokuwiki\\File\\PageResolver;\n\n/**\n * Renderer for XHTML output\n *\n * This is DokuWiki's main renderer used to display page content in the wiki\n *\n * @author Harry Fuecks <hfuecks@gmail.com>\n * @author Andreas Gohr <andi@splitbrain.org>\n *\n */\nclass Doku_Renderer_xhtml extends Doku_Renderer {\n    /** @var array store the table of contents */\n    public $toc = array();\n\n    /** @var array A stack of section edit data */\n    protected $sectionedits = array();\n\n    /** @var int last section edit id, used by startSectionEdit */\n    protected $lastsecid = 0;\n\n    /** @var array a list of footnotes, list starts at 1! */\n    protected $footnotes = array();\n\n    /** @var int current section level */\n    protected $lastlevel = 0;\n    /** @var array section node tracker */\n    protected $node = array(0, 0, 0, 0, 0);\n\n    /** @var string temporary $doc store */\n    protected $store = '';\n\n    /** @var array global counter, for table classes etc. */\n    protected $_counter = array(); //\n\n    /** @var int counts the code and file blocks, used to provide download links */\n    protected $_codeblock = 0;\n\n    /** @var array list of allowed URL schemes */\n    protected $schemes = null;\n\n    /**\n     * Register a new edit section range\n     *\n     * @param int    $start  The byte position for the edit start\n     * @param array  $data   Associative array with section data:\n     *                       Key 'name': the section name/title\n     *                       Key 'target': the target for the section edit,\n     *                                     e.g. 'section' or 'table'\n     *                       Key 'hid': header id\n     *                       Key 'codeblockOffset': actual code block index\n     *                       Key 'start': set in startSectionEdit(),\n     *                                    do not set yourself\n     *                       Key 'range': calculated from 'start' and\n     *                                    $key in finishSectionEdit(),\n     *                                    do not set yourself\n     * @return string  A marker class for the starting HTML element\n     *\n     * @author Adrian Lang <lang@cosmocode.de>\n     */\n    public function startSectionEdit($start, $data) {\n        if (!is_array($data)) {\n            msg(\n                sprintf(\n                    'startSectionEdit: $data \"%s\" is NOT an array! One of your plugins needs an update.',\n                    hsc((string) $data)\n                ), -1\n            );\n\n            // @deprecated 2018-04-14, backward compatibility\n            $args = func_get_args();\n            $data = array();\n            if(isset($args[1])) $data['target'] = $args[1];\n            if(isset($args[2])) $data['name'] = $args[2];\n            if(isset($args[3])) $data['hid'] = $args[3];\n        }\n        $data['secid'] = ++$this->lastsecid;\n        $data['start'] = $start;\n        $this->sectionedits[] = $data;\n        return 'sectionedit'.$data['secid'];\n    }\n\n    /**\n     * Finish an edit section range\n     *\n     * @param int  $end     The byte position for the edit end; null for the rest of the page\n     *\n     * @author Adrian Lang <lang@cosmocode.de>\n     */\n    public function finishSectionEdit($end = null, $hid = null) {\n        if(count($this->sectionedits) == 0) {\n            return;\n        }\n        $data = array_pop($this->sectionedits);\n        if(!is_null($end) && $end <= $data['start']) {\n            return;\n        }\n        if(!is_null($hid)) {\n            $data['hid'] .= $hid;\n        }\n        $data['range'] = $data['start'].'-'.(is_null($end) ? '' : $end);\n        unset($data['start']);\n        $this->doc .= '<!-- EDIT'.hsc(json_encode ($data)).' -->';\n    }\n\n    /**\n     * Returns the format produced by this renderer.\n     *\n     * @return string always 'xhtml'\n     */\n    public function getFormat() {\n        return 'xhtml';\n    }\n\n    /**\n     * Initialize the document\n     */\n    public function document_start() {\n        //reset some internals\n        $this->toc     = array();\n    }\n\n    /**\n     * Finalize the document\n     */\n    public function document_end() {\n        // Finish open section edits.\n        while(count($this->sectionedits) > 0) {\n            if($this->sectionedits[count($this->sectionedits) - 1]['start'] <= 1) {\n                // If there is only one section, do not write a section edit\n                // marker.\n                array_pop($this->sectionedits);\n            } else {\n                $this->finishSectionEdit();\n            }\n        }\n\n        if(count($this->footnotes) > 0) {\n            $this->doc .= '<div class=\"footnotes\">'.DOKU_LF;\n\n            foreach($this->footnotes as $id => $footnote) {\n                // check its not a placeholder that indicates actual footnote text is elsewhere\n                if(substr($footnote, 0, 5) != \"@@FNT\") {\n\n                    // open the footnote and set the anchor and backlink\n                    $this->doc .= '<div class=\"fn\">';\n                    $this->doc .= '<sup><a href=\"#fnt__'.$id.'\" id=\"fn__'.$id.'\" class=\"fn_bot\">';\n                    $this->doc .= $id.')</a></sup> '.DOKU_LF;\n\n                    // get any other footnotes that use the same markup\n                    $alt = array_keys($this->footnotes, \"@@FNT$id\");\n\n                    if(count($alt)) {\n                        foreach($alt as $ref) {\n                            // set anchor and backlink for the other footnotes\n                            $this->doc .= ', <sup><a href=\"#fnt__'.($ref).'\" id=\"fn__'.($ref).'\" class=\"fn_bot\">';\n                            $this->doc .= ($ref).')</a></sup> '.DOKU_LF;\n                        }\n                    }\n\n                    // add footnote markup and close this footnote\n                    $this->doc .= '<div class=\"content\">'.$footnote.'</div>';\n                    $this->doc .= '</div>'.DOKU_LF;\n                }\n            }\n            $this->doc .= '</div>'.DOKU_LF;\n        }\n\n        // Prepare the TOC\n        global $conf;\n        if(\n            $this->info['toc'] &&\n            is_array($this->toc) &&\n            $conf['tocminheads'] && count($this->toc) >= $conf['tocminheads']\n        ) {\n            global $TOC;\n            $TOC = $this->toc;\n        }\n\n        // make sure there are no empty paragraphs\n        $this->doc = preg_replace('#<p>\\s*</p>#', '', $this->doc);\n    }\n\n    /**\n     * Add an item to the TOC\n     *\n     * @param string $id       the hash link\n     * @param string $text     the text to display\n     * @param int    $level    the nesting level\n     */\n    public function toc_additem($id, $text, $level) {\n        global $conf;\n\n        //handle TOC\n        if($level >= $conf['toptoclevel'] && $level <= $conf['maxtoclevel']) {\n            $this->toc[] = html_mktocitem($id, $text, $level - $conf['toptoclevel'] + 1);\n        }\n    }\n\n    /**\n     * Render a heading\n     *\n     * @param string $text       the text to display\n     * @param int    $level      header level\n     * @param int    $pos        byte position in the original source\n     * @param bool   $returnonly whether to return html or write to doc attribute\n     * @return void|string writes to doc attribute or returns html depends on $returnonly\n     */\n    public function header($text, $level, $pos, $returnonly = false) {\n        global $conf;\n\n        if(blank($text)) return; //skip empty headlines\n\n        $hid = $this->_headerToLink($text, true);\n\n        //only add items within configured levels\n        $this->toc_additem($hid, $text, $level);\n\n        // adjust $node to reflect hierarchy of levels\n        $this->node[$level - 1]++;\n        if($level < $this->lastlevel) {\n            for($i = 0; $i < $this->lastlevel - $level; $i++) {\n                $this->node[$this->lastlevel - $i - 1] = 0;\n            }\n        }\n        $this->lastlevel = $level;\n\n        if($level <= $conf['maxseclevel'] &&\n            count($this->sectionedits) > 0 &&\n            $this->sectionedits[count($this->sectionedits) - 1]['target'] === 'section'\n        ) {\n            $this->finishSectionEdit($pos - 1);\n        }\n\n        // build the header\n        $header = DOKU_LF.'<h'.$level;\n        if($level <= $conf['maxseclevel']) {\n            $data = array();\n            $data['target'] = 'section';\n            $data['name'] = $text;\n            $data['hid'] = $hid;\n            $data['codeblockOffset'] = $this->_codeblock;\n            $header .= ' class=\"'.$this->startSectionEdit($pos, $data).'\"';\n        }\n        $header .= ' id=\"'.$hid.'\">';\n        $header .= $this->_xmlEntities($text);\n        $header .= \"</h$level>\".DOKU_LF;\n\n        if ($returnonly) {\n            return $header;\n        } else {\n            $this->doc .= $header;\n        }\n    }\n\n    /**\n     * Open a new section\n     *\n     * @param int $level section level (as determined by the previous header)\n     */\n    public function section_open($level) {\n        $this->doc .= '<div class=\"level'.$level.'\">'.DOKU_LF;\n    }\n\n    /**\n     * Close the current section\n     */\n    public function section_close() {\n        $this->doc .= DOKU_LF.'</div>'.DOKU_LF;\n    }\n\n    /**\n     * Render plain text data\n     *\n     * @param $text\n     */\n    public function cdata($text) {\n        $this->doc .= $this->_xmlEntities($text);\n    }\n\n    /**\n     * Open a paragraph\n     */\n    public function p_open() {\n        $this->doc .= DOKU_LF.'<p>'.DOKU_LF;\n    }\n\n    /**\n     * Close a paragraph\n     */\n    public function p_close() {\n        $this->doc .= DOKU_LF.'</p>'.DOKU_LF;\n    }\n\n    /**\n     * Create a line break\n     */\n    public function linebreak() {\n        $this->doc .= '<br/>'.DOKU_LF;\n    }\n\n    /**\n     * Create a horizontal line\n     */\n    public function hr() {\n        $this->doc .= '<hr />'.DOKU_LF;\n    }\n\n    /**\n     * Start strong (bold) formatting\n     */\n    public function strong_open() {\n        $this->doc .= '<strong>';\n    }\n\n    /**\n     * Stop strong (bold) formatting\n     */\n    public function strong_close() {\n        $this->doc .= '</strong>';\n    }\n\n    /**\n     * Start emphasis (italics) formatting\n     */\n    public function emphasis_open() {\n        $this->doc .= '<em>';\n    }\n\n    /**\n     * Stop emphasis (italics) formatting\n     */\n    public function emphasis_close() {\n        $this->doc .= '</em>';\n    }\n\n    /**\n     * Start underline formatting\n     */\n    public function underline_open() {\n        $this->doc .= '<em class=\"u\">';\n    }\n\n    /**\n     * Stop underline formatting\n     */\n    public function underline_close() {\n        $this->doc .= '</em>';\n    }\n\n    /**\n     * Start monospace formatting\n     */\n    public function monospace_open() {\n        $this->doc .= '<code>';\n    }\n\n    /**\n     * Stop monospace formatting\n     */\n    public function monospace_close() {\n        $this->doc .= '</code>';\n    }\n\n    /**\n     * Start a subscript\n     */\n    public function subscript_open() {\n        $this->doc .= '<sub>';\n    }\n\n    /**\n     * Stop a subscript\n     */\n    public function subscript_close() {\n        $this->doc .= '</sub>';\n    }\n\n    /**\n     * Start a superscript\n     */\n    public function superscript_open() {\n        $this->doc .= '<sup>';\n    }\n\n    /**\n     * Stop a superscript\n     */\n    public function superscript_close() {\n        $this->doc .= '</sup>';\n    }\n\n    /**\n     * Start deleted (strike-through) formatting\n     */\n    public function deleted_open() {\n        $this->doc .= '<del>';\n    }\n\n    /**\n     * Stop deleted (strike-through) formatting\n     */\n    public function deleted_close() {\n        $this->doc .= '</del>';\n    }\n\n    /**\n     * Callback for footnote start syntax\n     *\n     * All following content will go to the footnote instead of\n     * the document. To achieve this the previous rendered content\n     * is moved to $store and $doc is cleared\n     *\n     * @author Andreas Gohr <andi@splitbrain.org>\n     */\n    public function footnote_open() {\n\n        // move current content to store and record footnote\n        $this->store = $this->doc;\n        $this->doc   = '';\n    }\n\n    /**\n     * Callback for footnote end syntax\n     *\n     * All rendered content is moved to the $footnotes array and the old\n     * content is restored from $store again\n     *\n     * @author Andreas Gohr\n     */\n    public function footnote_close() {\n        /** @var $fnid int takes track of seen footnotes, assures they are unique even across multiple docs FS#2841 */\n        static $fnid = 0;\n        // assign new footnote id (we start at 1)\n        $fnid++;\n\n        // recover footnote into the stack and restore old content\n        $footnote    = $this->doc;\n        $this->doc   = $this->store;\n        $this->store = '';\n\n        // check to see if this footnote has been seen before\n        $i = array_search($footnote, $this->footnotes);\n\n        if($i === false) {\n            // its a new footnote, add it to the $footnotes array\n            $this->footnotes[$fnid] = $footnote;\n        } else {\n            // seen this one before, save a placeholder\n            $this->footnotes[$fnid] = \"@@FNT\".($i);\n        }\n\n        // output the footnote reference and link\n        $this->doc .= '<sup><a href=\"#fn__'.$fnid.'\" id=\"fnt__'.$fnid.'\" class=\"fn_top\">'.$fnid.')</a></sup>';\n    }\n\n    /**\n     * Open an unordered list\n     *\n     * @param string|string[] $classes css classes - have to be valid, do not pass unfiltered user input\n     */\n    public function listu_open($classes = null) {\n        $class = '';\n        if($classes !== null) {\n            if(is_array($classes)) $classes = join(' ', $classes);\n            $class = \" class=\\\"$classes\\\"\";\n        }\n        $this->doc .= \"<ul$class>\".DOKU_LF;\n    }\n\n    /**\n     * Close an unordered list\n     */\n    public function listu_close() {\n        $this->doc .= '</ul>'.DOKU_LF;\n    }\n\n    /**\n     * Open an ordered list\n     *\n     * @param string|string[] $classes css classes - have to be valid, do not pass unfiltered user input\n     */\n    public function listo_open($classes = null) {\n        $class = '';\n        if($classes !== null) {\n            if(is_array($classes)) $classes = join(' ', $classes);\n            $class = \" class=\\\"$classes\\\"\";\n        }\n        $this->doc .= \"<ol$class>\".DOKU_LF;\n    }\n\n    /**\n     * Close an ordered list\n     */\n    public function listo_close() {\n        $this->doc .= '</ol>'.DOKU_LF;\n    }\n\n    /**\n     * Open a list item\n     *\n     * @param int $level the nesting level\n     * @param bool $node true when a node; false when a leaf\n     */\n    public function listitem_open($level, $node=false) {\n        $branching = $node ? ' node' : '';\n        $this->doc .= '<li class=\"level'.$level.$branching.'\">';\n    }\n\n    /**\n     * Close a list item\n     */\n    public function listitem_close() {\n        $this->doc .= '</li>'.DOKU_LF;\n    }\n\n    /**\n     * Start the content of a list item\n     */\n    public function listcontent_open() {\n        $this->doc .= '<div class=\"li\">';\n    }\n\n    /**\n     * Stop the content of a list item\n     */\n    public function listcontent_close() {\n        $this->doc .= '</div>'.DOKU_LF;\n    }\n\n    /**\n     * Output unformatted $text\n     *\n     * Defaults to $this->cdata()\n     *\n     * @param string $text\n     */\n    public function unformatted($text) {\n        $this->doc .= $this->_xmlEntities($text);\n    }\n\n    /**\n     * Start a block quote\n     */\n    public function quote_open() {\n        $this->doc .= '<blockquote><div class=\"no\">'.DOKU_LF;\n    }\n\n    /**\n     * Stop a block quote\n     */\n    public function quote_close() {\n        $this->doc .= '</div></blockquote>'.DOKU_LF;\n    }\n\n    /**\n     * Output preformatted text\n     *\n     * @param string $text\n     */\n    public function preformatted($text) {\n        $this->doc .= '<pre class=\"code\">'.trim($this->_xmlEntities($text), \"\\n\\r\").'</pre>'.DOKU_LF;\n    }\n\n    /**\n     * Display text as file content, optionally syntax highlighted\n     *\n     * @param string $text     text to show\n     * @param string $language programming language to use for syntax highlighting\n     * @param string $filename file path label\n     * @param array  $options  assoziative array with additional geshi options\n     */\n    public function file($text, $language = null, $filename = null, $options=null) {\n        $this->_highlight('file', $text, $language, $filename, $options);\n    }\n\n    /**\n     * Display text as code content, optionally syntax highlighted\n     *\n     * @param string $text     text to show\n     * @param string $language programming language to use for syntax highlighting\n     * @param string $filename file path label\n     * @param array  $options  assoziative array with additional geshi options\n     */\n    public function code($text, $language = null, $filename = null, $options=null) {\n        $this->_highlight('code', $text, $language, $filename, $options);\n    }\n\n    /**\n     * Use GeSHi to highlight language syntax in code and file blocks\n     *\n     * @author Andreas Gohr <andi@splitbrain.org>\n     * @param string $type     code|file\n     * @param string $text     text to show\n     * @param string $language programming language to use for syntax highlighting\n     * @param string $filename file path label\n     * @param array  $options  assoziative array with additional geshi options\n     */\n    public function _highlight($type, $text, $language = null, $filename = null, $options = null) {\n        global $ID;\n        global $lang;\n        global $INPUT;\n\n        $language = preg_replace(PREG_PATTERN_VALID_LANGUAGE, '', $language ?? '');\n\n        if($filename) {\n            // add icon\n            list($ext) = mimetype($filename, false);\n            $class = preg_replace('/[^_\\-a-z0-9]+/i', '_', $ext);\n            $class = 'mediafile mf_'.$class;\n\n            $offset = 0;\n            if ($INPUT->has('codeblockOffset')) {\n                $offset = $INPUT->str('codeblockOffset');\n            }\n            $this->doc .= '<dl class=\"'.$type.'\">'.DOKU_LF;\n            $this->doc .= '<dt><a href=\"' .\n                exportlink(\n                    $ID,\n                    'code',\n                    array('codeblock' => $offset + $this->_codeblock)\n                ) . '\" title=\"' . $lang['download'] . '\" class=\"' . $class . '\">';\n            $this->doc .= hsc($filename);\n            $this->doc .= '</a></dt>'.DOKU_LF.'<dd>';\n        }\n\n        if($text[0] == \"\\n\") {\n            $text = substr($text, 1);\n        }\n        if(substr($text, -1) == \"\\n\") {\n            $text = substr($text, 0, -1);\n        }\n\n        if(empty($language)) { // empty is faster than is_null and can prevent '' string\n            $this->doc .= '<pre class=\"'.$type.'\">'.$this->_xmlEntities($text).'</pre>'.DOKU_LF;\n        } else {\n            $class = 'code'; //we always need the code class to make the syntax highlighting apply\n            if($type != 'code') $class .= ' '.$type;\n\n            $this->doc .= \"<pre class=\\\"$class $language\\\">\" .\n                p_xhtml_cached_geshi($text, $language, '', $options) .\n                '</pre>' . DOKU_LF;\n        }\n\n        if($filename) {\n            $this->doc .= '</dd></dl>'.DOKU_LF;\n        }\n\n        $this->_codeblock++;\n    }\n\n    /**\n     * Format an acronym\n     *\n     * Uses $this->acronyms\n     *\n     * @param string $acronym\n     */\n    public function acronym($acronym) {\n\n        if(array_key_exists($acronym, $this->acronyms)) {\n\n            $title = $this->_xmlEntities($this->acronyms[$acronym]);\n\n            $this->doc .= '<abbr title=\"'.$title\n                .'\">'.$this->_xmlEntities($acronym).'</abbr>';\n\n        } else {\n            $this->doc .= $this->_xmlEntities($acronym);\n        }\n    }\n\n    /**\n     * Format a smiley\n     *\n     * Uses $this->smiley\n     *\n     * @param string $smiley\n     */\n    public function smiley($smiley) {\n        if (isset($this->smileys[$smiley])) {\n            $this->doc .= '<img src=\"' . DOKU_BASE . 'lib/images/smileys/' . $this->smileys[$smiley] .\n                '\" class=\"icon smiley\" alt=\"' . $this->_xmlEntities($smiley) . '\" />';\n        } else {\n            $this->doc .= $this->_xmlEntities($smiley);\n        }\n    }\n\n    /**\n     * Format an entity\n     *\n     * Entities are basically small text replacements\n     *\n     * Uses $this->entities\n     *\n     * @param string $entity\n     */\n    public function entity($entity) {\n        if(array_key_exists($entity, $this->entities)) {\n            $this->doc .= $this->entities[$entity];\n        } else {\n            $this->doc .= $this->_xmlEntities($entity);\n        }\n    }\n\n    /**\n     * Typographically format a multiply sign\n     *\n     * Example: ($x=640, $y=480) should result in \"640\u00d7480\"\n     *\n     * @param string|int $x first value\n     * @param string|int $y second value\n     */\n    public function multiplyentity($x, $y) {\n        $this->doc .= \"$x&times;$y\";\n    }\n\n    /**\n     * Render an opening single quote char (language specific)\n     */\n    public function singlequoteopening() {\n        global $lang;\n        $this->doc .= $lang['singlequoteopening'];\n    }\n\n    /**\n     * Render a closing single quote char (language specific)\n     */\n    public function singlequoteclosing() {\n        global $lang;\n        $this->doc .= $lang['singlequoteclosing'];\n    }\n\n    /**\n     * Render an apostrophe char (language specific)\n     */\n    public function apostrophe() {\n        global $lang;\n        $this->doc .= $lang['apostrophe'];\n    }\n\n    /**\n     * Render an opening double quote char (language specific)\n     */\n    public function doublequoteopening() {\n        global $lang;\n        $this->doc .= $lang['doublequoteopening'];\n    }\n\n    /**\n     * Render an closinging double quote char (language specific)\n     */\n    public function doublequoteclosing() {\n        global $lang;\n        $this->doc .= $lang['doublequoteclosing'];\n    }\n\n    /**\n     * Render a CamelCase link\n     *\n     * @param string $link       The link name\n     * @param bool   $returnonly whether to return html or write to doc attribute\n     * @return void|string writes to doc attribute or returns html depends on $returnonly\n     *\n     * @see http://en.wikipedia.org/wiki/CamelCase\n     */\n    public function camelcaselink($link, $returnonly = false) {\n        if($returnonly) {\n          return $this->internallink($link, $link, null, true);\n        } else {\n          $this->internallink($link, $link);\n        }\n    }\n\n    /**\n     * Render a page local link\n     *\n     * @param string $hash       hash link identifier\n     * @param string $name       name for the link\n     * @param bool   $returnonly whether to return html or write to doc attribute\n     * @return void|string writes to doc attribute or returns html depends on $returnonly\n     */\n    public function locallink($hash, $name = null, $returnonly = false) {\n        global $ID;\n        $name  = $this->_getLinkTitle($name, $hash, $isImage);\n        $hash  = $this->_headerToLink($hash);\n        $title = $ID.' \u21b5';\n\n        $doc = '<a href=\"#'.$hash.'\" title=\"'.$title.'\" class=\"wikilink1\">';\n        $doc .= $name;\n        $doc .= '</a>';\n\n        if($returnonly) {\n          return $doc;\n        } else {\n          $this->doc .= $doc;\n        }\n    }\n\n    /**\n     * Render an internal Wiki Link\n     *\n     * $search,$returnonly & $linktype are not for the renderer but are used\n     * elsewhere - no need to implement them in other renderers\n     *\n     * @author Andreas Gohr <andi@splitbrain.org>\n     * @param string      $id         pageid\n     * @param string|null $name       link name\n     * @param string|null $search     adds search url param\n     * @param bool        $returnonly whether to return html or write to doc attribute\n     * @param string      $linktype   type to set use of headings\n     * @return void|string writes to doc attribute or returns html depends on $returnonly\n     */\n    public function internallink($id, $name = null, $search = null, $returnonly = false, $linktype = 'content') {\n        global $conf;\n        global $ID;\n        global $INFO;\n\n        $params = '';\n        $parts  = explode('?', $id, 2);\n        if(count($parts) === 2) {\n            $id     = $parts[0];\n            $params = $parts[1];\n        }\n\n        // For empty $id we need to know the current $ID\n        // We need this check because _simpleTitle needs\n        // correct $id and resolve_pageid() use cleanID($id)\n        // (some things could be lost)\n        if($id === '') {\n            $id = $ID;\n        }\n\n        // default name is based on $id as given\n        $default = $this->_simpleTitle($id);\n\n        // now first resolve and clean up the $id\n        $id = (new PageResolver($ID))->resolveId($id, $this->date_at, true);\n        $exists = page_exists($id, $this->date_at, false, true);\n\n        $link = array();\n        $name = $this->_getLinkTitle($name, $default, $isImage, $id, $linktype);\n        if(!$isImage) {\n            if($exists) {\n                $class = 'wikilink1';\n            } else {\n                $class       = 'wikilink2';\n                $link['rel'] = 'nofollow';\n            }\n        } else {\n            $class = 'media';\n        }\n\n        //keep hash anchor\n        list($id, $hash) = sexplode('#', $id, 2);\n        if(!empty($hash)) $hash = $this->_headerToLink($hash);\n\n        //prepare for formating\n        $link['target'] = $conf['target']['wiki'];\n        $link['style']  = '';\n        $link['pre']    = '';\n        $link['suf']    = '';\n        $link['more']   = 'data-wiki-id=\"'.$id.'\"'; // id is already cleaned\n        $link['class']  = $class;\n        if($this->date_at) {\n            $params = $params.'&at='.rawurlencode($this->date_at);\n        }\n        $link['url']    = wl($id, $params);\n        $link['name']   = $name;\n        $link['title']  = $id;\n        //add search string\n        if($search) {\n            ($conf['userewrite']) ? $link['url'] .= '?' : $link['url'] .= '&amp;';\n            if(is_array($search)) {\n                $search = array_map('rawurlencode', $search);\n                $link['url'] .= 's[]='.join('&amp;s[]=', $search);\n            } else {\n                $link['url'] .= 's='.rawurlencode($search);\n            }\n        }\n\n        //keep hash\n        if($hash) $link['url'] .= '#'.$hash;\n\n        //output formatted\n        if($returnonly) {\n            return $this->_formatLink($link);\n        } else {\n            $this->doc .= $this->_formatLink($link);\n        }\n    }\n\n    /**\n     * Render an external link\n     *\n     * @param string       $url        full URL with scheme\n     * @param string|array $name       name for the link, array for media file\n     * @param bool         $returnonly whether to return html or write to doc attribute\n     * @return void|string writes to doc attribute or returns html depends on $returnonly\n     */\n    public function externallink($url, $name = null, $returnonly = false) {\n        global $conf;\n\n        $name = $this->_getLinkTitle($name, $url, $isImage);\n\n        // url might be an attack vector, only allow registered protocols\n        if(is_null($this->schemes)) $this->schemes = getSchemes();\n        list($scheme) = explode('://', $url);\n        $scheme = strtolower($scheme);\n        if(!in_array($scheme, $this->schemes)) $url = '';\n\n        // is there still an URL?\n        if(!$url) {\n            if($returnonly) {\n                return $name;\n            } else {\n                $this->doc .= $name;\n            }\n            return;\n        }\n\n        // set class\n        if(!$isImage) {\n            $class = 'urlextern';\n        } else {\n            $class = 'media';\n        }\n\n        //prepare for formating\n        $link = array();\n        $link['target'] = $conf['target']['extern'];\n        $link['style']  = '';\n        $link['pre']    = '';\n        $link['suf']    = '';\n        $link['more']   = '';\n        $link['class']  = $class;\n        $link['url']    = $url;\n        $link['rel']    = '';\n\n        $link['name']  = $name;\n        $link['title'] = $this->_xmlEntities($url);\n        if($conf['relnofollow']) $link['rel'] .= ' ugc nofollow';\n        if($conf['target']['extern']) $link['rel'] .= ' noopener';\n\n        //output formatted\n        if($returnonly) {\n            return $this->_formatLink($link);\n        } else {\n            $this->doc .= $this->_formatLink($link);\n        }\n    }\n\n    /**\n     * Render an interwiki link\n     *\n     * You may want to use $this->_resolveInterWiki() here\n     *\n     * @param string       $match      original link - probably not much use\n     * @param string|array $name       name for the link, array for media file\n     * @param string       $wikiName   indentifier (shortcut) for the remote wiki\n     * @param string       $wikiUri    the fragment parsed from the original link\n     * @param bool         $returnonly whether to return html or write to doc attribute\n     * @return void|string writes to doc attribute or returns html depends on $returnonly\n     */\n    public function interwikilink($match, $name, $wikiName, $wikiUri, $returnonly = false) {\n        global $conf;\n\n        $link           = array();\n        $link['target'] = $conf['target']['interwiki'];\n        $link['pre']    = '';\n        $link['suf']    = '';\n        $link['more']   = '';\n        $link['name']   = $this->_getLinkTitle($name, $wikiUri, $isImage);\n        $link['rel']    = '';\n\n        //get interwiki URL\n        $exists = null;\n        $url    = $this->_resolveInterWiki($wikiName, $wikiUri, $exists);\n\n        if(!$isImage) {\n            $class         = preg_replace('/[^_\\-a-z0-9]+/i', '_', $wikiName);\n            $link['class'] = \"interwiki iw_$class\";\n        } else {\n            $link['class'] = 'media';\n        }\n\n        //do we stay at the same server? Use local target\n        if(strpos($url, DOKU_URL) === 0 OR strpos($url, DOKU_BASE) === 0) {\n            $link['target'] = $conf['target']['wiki'];\n        }\n        if($exists !== null && !$isImage) {\n            if($exists) {\n                $link['class'] .= ' wikilink1';\n            } else {\n                $link['class'] .= ' wikilink2';\n                $link['rel'] .= ' nofollow';\n            }\n        }\n        if($conf['target']['interwiki']) $link['rel'] .= ' noopener';\n\n        $link['url']   = $url;\n        $link['title'] = $this->_xmlEntities($link['url']);\n\n        // output formatted\n        if($returnonly) {\n            if($url == '') return $link['name'];\n            return $this->_formatLink($link);\n        } else {\n            if($url == '') $this->doc .= $link['name'];\n            else $this->doc .= $this->_formatLink($link);\n        }\n    }\n\n    /**\n     * Link to windows share\n     *\n     * @param string       $url        the link\n     * @param string|array $name       name for the link, array for media file\n     * @param bool         $returnonly whether to return html or write to doc attribute\n     * @return void|string writes to doc attribute or returns html depends on $returnonly\n     */\n    public function windowssharelink($url, $name = null, $returnonly = false) {\n        global $conf;\n\n        //simple setup\n        $link = array();\n        $link['target'] = $conf['target']['windows'];\n        $link['pre']    = '';\n        $link['suf']    = '';\n        $link['style']  = '';\n\n        $link['name'] = $this->_getLinkTitle($name, $url, $isImage);\n        if(!$isImage) {\n            $link['class'] = 'windows';\n        } else {\n            $link['class'] = 'media';\n        }\n\n        $link['title'] = $this->_xmlEntities($url);\n        $url           = str_replace('\\\\', '/', $url);\n        $url           = 'file:///'.$url;\n        $link['url']   = $url;\n\n        //output formatted\n        if($returnonly) {\n            return $this->_formatLink($link);\n        } else {\n            $this->doc .= $this->_formatLink($link);\n        }\n    }\n\n    /**\n     * Render a linked E-Mail Address\n     *\n     * Honors $conf['mailguard'] setting\n     *\n     * @param string       $address    Email-Address\n     * @param string|array $name       name for the link, array for media file\n     * @param bool         $returnonly whether to return html or write to doc attribute\n     * @return void|string writes to doc attribute or returns html depends on $returnonly\n     */\n    public function emaillink($address, $name = null, $returnonly = false) {\n        global $conf;\n        //simple setup\n        $link           = array();\n        $link['target'] = '';\n        $link['pre']    = '';\n        $link['suf']    = '';\n        $link['style']  = '';\n        $link['more']   = '';\n\n        $name = $this->_getLinkTitle($name, '', $isImage);\n        if(!$isImage) {\n            $link['class'] = 'mail';\n        } else {\n            $link['class'] = 'media';\n        }\n\n        $address = $this->_xmlEntities($address);\n        $address = obfuscate($address);\n        $title   = $address;\n\n        if(empty($name)) {\n            $name = $address;\n        }\n\n        if($conf['mailguard'] == 'visible') $address = rawurlencode($address);\n\n        $link['url']   = 'mailto:'.$address;\n        $link['name']  = $name;\n        $link['title'] = $title;\n\n        //output formatted\n        if($returnonly) {\n            return $this->_formatLink($link);\n        } else {\n            $this->doc .= $this->_formatLink($link);\n        }\n    }\n\n    /**\n     * Render an internal media file\n     *\n     * @param string $src       media ID\n     * @param string $title     descriptive text\n     * @param string $align     left|center|right\n     * @param int    $width     width of media in pixel\n     * @param int    $height    height of media in pixel\n     * @param string $cache     cache|recache|nocache\n     * @param string $linking   linkonly|detail|nolink\n     * @param bool   $return    return HTML instead of adding to $doc\n     * @return void|string writes to doc attribute or returns html depends on $return\n     */\n    public function internalmedia($src, $title = null, $align = null, $width = null,\n                           $height = null, $cache = null, $linking = null, $return = false) {\n        global $ID;\n        if (strpos($src, '#') !== false) {\n            list($src, $hash) = sexplode('#', $src, 2);\n        }\n        $src = (new MediaResolver($ID))->resolveId($src,$this->date_at,true);\n        $exists = media_exists($src);\n\n        $noLink = false;\n        $render = ($linking == 'linkonly') ? false : true;\n        $link   = $this->_getMediaLinkConf($src, $title, $align, $width, $height, $cache, $render);\n\n        list($ext, $mime) = mimetype($src, false);\n        if(substr($mime, 0, 5) == 'image' && $render) {\n            $link['url'] = ml(\n                $src,\n                array(\n                    'id' => $ID,\n                    'cache' => $cache,\n                    'rev' => $this->_getLastMediaRevisionAt($src)\n                ),\n                ($linking == 'direct')\n            );\n        } elseif(($mime == 'application/x-shockwave-flash' || media_supportedav($mime)) && $render) {\n            // don't link movies\n            $noLink = true;\n        } else {\n            // add file icons\n            $class = preg_replace('/[^_\\-a-z0-9]+/i', '_', $ext);\n            $link['class'] .= ' mediafile mf_'.$class;\n            $link['url'] = ml(\n                $src,\n                array(\n                    'id' => $ID,\n                    'cache' => $cache,\n                    'rev' => $this->_getLastMediaRevisionAt($src)\n                ),\n                true\n            );\n            if($exists) $link['title'] .= ' ('.filesize_h(filesize(mediaFN($src))).')';\n        }\n\n        if (!empty($hash)) $link['url'] .= '#'.$hash;\n\n        //markup non existing files\n        if(!$exists) {\n            $link['class'] .= ' wikilink2';\n        }\n\n        //output formatted\n        if($return) {\n            if($linking == 'nolink' || $noLink) return $link['name'];\n            else return $this->_formatLink($link);\n        } else {\n            if($linking == 'nolink' || $noLink) $this->doc .= $link['name'];\n            else $this->doc .= $this->_formatLink($link);\n        }\n    }\n\n    /**\n     * Render an external media file\n     *\n     * @param string $src     full media URL\n     * @param string $title   descriptive text\n     * @param string $align   left|center|right\n     * @param int    $width   width of media in pixel\n     * @param int    $height  height of media in pixel\n     * @param string $cache   cache|recache|nocache\n     * @param string $linking linkonly|detail|nolink\n     * @param bool   $return  return HTML instead of adding to $doc\n     * @return void|string writes to doc attribute or returns html depends on $return\n     */\n    public function externalmedia($src, $title = null, $align = null, $width = null,\n                           $height = null, $cache = null, $linking = null, $return = false) {\n        if(link_isinterwiki($src)){\n            list($shortcut, $reference) = sexplode('>', $src, 2, '');\n            $exists = null;\n            $src = $this->_resolveInterWiki($shortcut, $reference, $exists);\n            if($src == '' && empty($title)){\n                // make sure at least something will be shown in this case\n                $title = $reference;\n            }\n        }\n        list($src, $hash) = sexplode('#', $src, 2);\n        $noLink = false;\n        if($src == '') {\n            // only output plaintext without link if there is no src\n            $noLink = true;\n        }\n        $render = ($linking == 'linkonly') ? false : true;\n        $link   = $this->_getMediaLinkConf($src, $title, $align, $width, $height, $cache, $render);\n\n        $link['url'] = ml($src, array('cache' => $cache));\n\n        list($ext, $mime) = mimetype($src, false);\n        if(substr($mime, 0, 5) == 'image' && $render) {\n            // link only jpeg images\n            // if ($ext != 'jpg' && $ext != 'jpeg') $noLink = true;\n        } elseif(($mime == 'application/x-shockwave-flash' || media_supportedav($mime)) && $render) {\n            // don't link movies\n            $noLink = true;\n        } else {\n            // add file icons\n            $class = preg_replace('/[^_\\-a-z0-9]+/i', '_', $ext);\n            $link['class'] .= ' mediafile mf_'.$class;\n        }\n\n        if($hash) $link['url'] .= '#'.$hash;\n\n        //output formatted\n        if($return) {\n            if($linking == 'nolink' || $noLink) return $link['name'];\n            else return $this->_formatLink($link);\n        } else {\n            if($linking == 'nolink' || $noLink) $this->doc .= $link['name'];\n            else $this->doc .= $this->_formatLink($link);\n        }\n    }\n\n    /**\n     * Renders an RSS feed\n     *\n     * @param string $url    URL of the feed\n     * @param array  $params Finetuning of the output\n     *\n     * @author Andreas Gohr <andi@splitbrain.org>\n     */\n    public function rss($url, $params) {\n        global $lang;\n        global $conf;\n\n        require_once(DOKU_INC.'inc/FeedParser.php');\n        $feed = new FeedParser();\n        $feed->set_feed_url($url);\n\n        //disable warning while fetching\n        if(!defined('DOKU_E_LEVEL')) {\n            $elvl = error_reporting(E_ERROR);\n        }\n        $rc = $feed->init();\n        if(isset($elvl)) {\n            error_reporting($elvl);\n        }\n\n        if($params['nosort']) $feed->enable_order_by_date(false);\n\n        //decide on start and end\n        if($params['reverse']) {\n            $mod   = -1;\n            $start = $feed->get_item_quantity() - 1;\n            $end   = $start - ($params['max']);\n            $end   = ($end < -1) ? -1 : $end;\n        } else {\n            $mod   = 1;\n            $start = 0;\n            $end   = $feed->get_item_quantity();\n            $end   = ($end > $params['max']) ? $params['max'] : $end;\n        }\n\n        $this->doc .= '<ul class=\"rss\">';\n        if($rc) {\n            for($x = $start; $x != $end; $x += $mod) {\n                $item = $feed->get_item($x);\n                $this->doc .= '<li><div class=\"li\">';\n\n                $lnkurl = $item->get_permalink();\n                $title = html_entity_decode($item->get_title(), ENT_QUOTES, 'UTF-8');\n\n                // support feeds without links\n                if($lnkurl) {\n                    $this->externallink($item->get_permalink(), $title);\n                } else {\n                    $this->doc .= ' '.hsc($item->get_title());\n                }\n                if($params['author']) {\n                    $author = $item->get_author(0);\n                    if($author) {\n                        $name = $author->get_name();\n                        if(!$name) $name = $author->get_email();\n                        if($name) $this->doc .= ' '.$lang['by'].' '.hsc($name);\n                    }\n                }\n                if($params['date']) {\n                    $this->doc .= ' ('.$item->get_local_date($conf['dformat']).')';\n                }\n                if($params['details']) {\n                    $desc = $item->get_description();\n                    $desc = strip_tags($desc);\n                    $desc = html_entity_decode($desc, ENT_QUOTES, 'UTF-8');\n                    $this->doc .= '<div class=\"detail\">';\n                    $this->doc .= hsc($desc);\n                    $this->doc .= '</div>';\n                }\n\n                $this->doc .= '</div></li>';\n            }\n        } else {\n            $this->doc .= '<li><div class=\"li\">';\n            $this->doc .= '<em>'.$lang['rssfailed'].'</em>';\n            $this->externallink($url);\n            if($conf['allowdebug']) {\n                $this->doc .= '<!--'.hsc($feed->error).'-->';\n            }\n            $this->doc .= '</div></li>';\n        }\n        $this->doc .= '</ul>';\n    }\n\n    /**\n     * Start a table\n     *\n     * @param int $maxcols maximum number of columns\n     * @param int $numrows NOT IMPLEMENTED\n     * @param int $pos byte position in the original source\n     * @param string|string[] $classes css classes - have to be valid, do not pass unfiltered user input\n     */\n    public function table_open($maxcols = null, $numrows = null, $pos = null, $classes = null) {\n        // initialize the row counter used for classes\n        $this->_counter['row_counter'] = 0;\n        $class                         = 'table';\n        if($classes !== null) {\n            if(is_array($classes)) $classes = join(' ', $classes);\n            $class .= ' ' . $classes;\n        }\n        if($pos !== null) {\n            $hid = $this->_headerToLink($class, true);\n            $data = array();\n            $data['target'] = 'table';\n            $data['name'] = '';\n            $data['hid'] = $hid;\n            $class .= ' '.$this->startSectionEdit($pos, $data);\n        }\n        $this->doc .= '<div class=\"'.$class.'\"><table class=\"inline\">'.\n            DOKU_LF;\n    }\n\n    /**\n     * Close a table\n     *\n     * @param int $pos byte position in the original source\n     */\n    public function table_close($pos = null) {\n        $this->doc .= '</table></div>'.DOKU_LF;\n        if($pos !== null) {\n            $this->finishSectionEdit($pos);\n        }\n    }\n\n    /**\n     * Open a table header\n     */\n    public function tablethead_open() {\n        $this->doc .= DOKU_TAB.'<thead>'.DOKU_LF;\n    }\n\n    /**\n     * Close a table header\n     */\n    public function tablethead_close() {\n        $this->doc .= DOKU_TAB.'</thead>'.DOKU_LF;\n    }\n\n    /**\n     * Open a table body\n     */\n    public function tabletbody_open() {\n        $this->doc .= DOKU_TAB.'<tbody>'.DOKU_LF;\n    }\n\n    /**\n     * Close a table body\n     */\n    public function tabletbody_close() {\n        $this->doc .= DOKU_TAB.'</tbody>'.DOKU_LF;\n    }\n\n    /**\n     * Open a table footer\n     */\n    public function tabletfoot_open() {\n        $this->doc .= DOKU_TAB.'<tfoot>'.DOKU_LF;\n    }\n\n    /**\n     * Close a table footer\n     */\n    public function tabletfoot_close() {\n        $this->doc .= DOKU_TAB.'</tfoot>'.DOKU_LF;\n    }\n\n    /**\n     * Open a table row\n     *\n     * @param string|string[] $classes css classes - have to be valid, do not pass unfiltered user input\n     */\n    public function tablerow_open($classes = null) {\n        // initialize the cell counter used for classes\n        $this->_counter['cell_counter'] = 0;\n        $class                          = 'row'.$this->_counter['row_counter']++;\n        if($classes !== null) {\n            if(is_array($classes)) $classes = join(' ', $classes);\n            $class .= ' ' . $classes;\n        }\n        $this->doc .= DOKU_TAB.'<tr class=\"'.$class.'\">'.DOKU_LF.DOKU_TAB.DOKU_TAB;\n    }\n\n    /**\n     * Close a table row\n     */\n    public function tablerow_close() {\n        $this->doc .= DOKU_LF.DOKU_TAB.'</tr>'.DOKU_LF;\n    }\n\n    /**\n     * Open a table header cell\n     *\n     * @param int    $colspan\n     * @param string $align left|center|right\n     * @param int    $rowspan\n     * @param string|string[] $classes css classes - have to be valid, do not pass unfiltered user input\n     */\n    public function tableheader_open($colspan = 1, $align = null, $rowspan = 1, $classes = null) {\n        $class = 'class=\"col'.$this->_counter['cell_counter']++;\n        if(!is_null($align)) {\n            $class .= ' '.$align.'align';\n        }\n        if($classes !== null) {\n            if(is_array($classes)) $classes = join(' ', $classes);\n            $class .= ' ' . $classes;\n        }\n        $class .= '\"';\n        $this->doc .= '<th '.$class;\n        if($colspan > 1) {\n            $this->_counter['cell_counter'] += $colspan - 1;\n            $this->doc .= ' colspan=\"'.$colspan.'\"';\n        }\n        if($rowspan > 1) {\n            $this->doc .= ' rowspan=\"'.$rowspan.'\"';\n        }\n        $this->doc .= '>';\n    }\n\n    /**\n     * Close a table header cell\n     */\n    public function tableheader_close() {\n        $this->doc .= '</th>';\n    }\n\n    /**\n     * Open a table cell\n     *\n     * @param int       $colspan\n     * @param string    $align left|center|right\n     * @param int       $rowspan\n     * @param string|string[]    $classes css classes - have to be valid, do not pass unfiltered user input\n     */\n    public function tablecell_open($colspan = 1, $align = null, $rowspan = 1, $classes = null) {\n        $class = 'class=\"col'.$this->_counter['cell_counter']++;\n        if(!is_null($align)) {\n            $class .= ' '.$align.'align';\n        }\n        if($classes !== null) {\n            if(is_array($classes)) $classes = join(' ', $classes);\n            $class .= ' ' . $classes;\n        }\n        $class .= '\"';\n        $this->doc .= '<td '.$class;\n        if($colspan > 1) {\n            $this->_counter['cell_counter'] += $colspan - 1;\n            $this->doc .= ' colspan=\"'.$colspan.'\"';\n        }\n        if($rowspan > 1) {\n            $this->doc .= ' rowspan=\"'.$rowspan.'\"';\n        }\n        $this->doc .= '>';\n    }\n\n    /**\n     * Close a table cell\n     */\n    public function tablecell_close() {\n        $this->doc .= '</td>';\n    }\n\n    /**\n     * Returns the current header level.\n     * (required e.g. by the filelist plugin)\n     *\n     * @return int The current header level\n     */\n    public function getLastlevel() {\n        return $this->lastlevel;\n    }\n\n    #region Utility functions\n\n    /**\n     * Build a link\n     *\n     * Assembles all parts defined in $link returns HTML for the link\n     *\n     * @param array $link attributes of a link\n     * @return string\n     *\n     * @author Andreas Gohr <andi@splitbrain.org>\n     */\n    public function _formatLink($link) {\n        //make sure the url is XHTML compliant (skip mailto)\n        if(substr($link['url'], 0, 7) != 'mailto:') {\n            $link['url'] = str_replace('&', '&amp;', $link['url']);\n            $link['url'] = str_replace('&amp;amp;', '&amp;', $link['url']);\n        }\n        //remove double encodings in titles\n        $link['title'] = str_replace('&amp;amp;', '&amp;', $link['title']);\n\n        // be sure there are no bad chars in url or title\n        // (we can't do this for name because it can contain an img tag)\n        $link['url']   = strtr($link['url'], array('>' => '%3E', '<' => '%3C', '\"' => '%22'));\n        $link['title'] = strtr($link['title'], array('>' => '&gt;', '<' => '&lt;', '\"' => '&quot;'));\n\n        $ret = '';\n        $ret .= $link['pre'];\n        $ret .= '<a href=\"'.$link['url'].'\"';\n        if(!empty($link['class'])) $ret .= ' class=\"'.$link['class'].'\"';\n        if(!empty($link['target'])) $ret .= ' target=\"'.$link['target'].'\"';\n        if(!empty($link['title'])) $ret .= ' title=\"'.$link['title'].'\"';\n        if(!empty($link['style'])) $ret .= ' style=\"'.$link['style'].'\"';\n        if(!empty($link['rel'])) $ret .= ' rel=\"'.trim($link['rel']).'\"';\n        if(!empty($link['more'])) $ret .= ' '.$link['more'];\n        $ret .= '>';\n        $ret .= $link['name'];\n        $ret .= '</a>';\n        $ret .= $link['suf'];\n        return $ret;\n    }\n\n    /**\n     * Renders internal and external media\n     *\n     * @author Andreas Gohr <andi@splitbrain.org>\n     * @param string $src       media ID\n     * @param string $title     descriptive text\n     * @param string $align     left|center|right\n     * @param int    $width     width of media in pixel\n     * @param int    $height    height of media in pixel\n     * @param string $cache     cache|recache|nocache\n     * @param bool   $render    should the media be embedded inline or just linked\n     * @return string\n     */\n    public function _media($src, $title = null, $align = null, $width = null,\n                    $height = null, $cache = null, $render = true) {\n\n        $ret = '';\n\n        list($ext, $mime) = mimetype($src);\n        if(substr($mime, 0, 5) == 'image') {\n            // first get the $title\n            if(!is_null($title)) {\n                $title = $this->_xmlEntities($title);\n            } elseif($ext == 'jpg' || $ext == 'jpeg') {\n                //try to use the caption from IPTC/EXIF\n                require_once(DOKU_INC.'inc/JpegMeta.php');\n                $jpeg = new JpegMeta(mediaFN($src));\n                if($jpeg !== false) $cap = $jpeg->getTitle();\n                if(!empty($cap)) {\n                    $title = $this->_xmlEntities($cap);\n                }\n            }\n            if(!$render) {\n                // if the picture is not supposed to be rendered\n                // return the title of the picture\n                if($title === null || $title === \"\") {\n                    // just show the sourcename\n                    $title = $this->_xmlEntities(\\dokuwiki\\Utf8\\PhpString::basename(noNS($src)));\n                }\n                return $title;\n            }\n            //add image tag\n            $ret .= '<img src=\"' . ml(\n                    $src,\n                    array(\n                        'w' => $width, 'h' => $height,\n                        'cache' => $cache,\n                        'rev' => $this->_getLastMediaRevisionAt($src)\n                    )\n                ) . '\"';\n            $ret .= ' class=\"media'.$align.'\"';\n            $ret .= ' loading=\"lazy\"';\n\n            if($title) {\n                $ret .= ' title=\"'.$title.'\"';\n                $ret .= ' alt=\"'.$title.'\"';\n            } else {\n                $ret .= ' alt=\"\"';\n            }\n\n            if(!is_null($width))\n                $ret .= ' width=\"'.$this->_xmlEntities($width).'\"';\n\n            if(!is_null($height))\n                $ret .= ' height=\"'.$this->_xmlEntities($height).'\"';\n\n            $ret .= ' />';\n\n        } elseif(media_supportedav($mime, 'video') || media_supportedav($mime, 'audio')) {\n            // first get the $title\n            $title = !is_null($title) ? $title : false;\n            if(!$render) {\n                // if the file is not supposed to be rendered\n                // return the title of the file (just the sourcename if there is no title)\n                return $this->_xmlEntities($title ? $title : \\dokuwiki\\Utf8\\PhpString::basename(noNS($src)));\n            }\n\n            $att          = array();\n            $att['class'] = \"media$align\";\n            if($title) {\n                $att['title'] = $title;\n            }\n\n            if(media_supportedav($mime, 'video')) {\n                //add video\n                $ret .= $this->_video($src, $width, $height, $att);\n            }\n            if(media_supportedav($mime, 'audio')) {\n                //add audio\n                $ret .= $this->_audio($src, $att);\n            }\n\n        } elseif($mime == 'application/x-shockwave-flash') {\n            if(!$render) {\n                // if the flash is not supposed to be rendered\n                // return the title of the flash\n                if(!$title) {\n                    // just show the sourcename\n                    $title = \\dokuwiki\\Utf8\\PhpString::basename(noNS($src));\n                }\n                return $this->_xmlEntities($title);\n            }\n\n            $att          = array();\n            $att['class'] = \"media$align\";\n            if($align == 'right') $att['align'] = 'right';\n            if($align == 'left') $att['align'] = 'left';\n            $ret .= html_flashobject(\n                ml($src, array('cache' => $cache), true, '&'), $width, $height,\n                array('quality' => 'high'),\n                null,\n                $att,\n                $this->_xmlEntities($title)\n            );\n        } elseif($title) {\n            // well at least we have a title to display\n            $ret .= $this->_xmlEntities($title);\n        } else {\n            // just show the sourcename\n            $ret .= $this->_xmlEntities(\\dokuwiki\\Utf8\\PhpString::basename(noNS($src)));\n        }\n\n        return $ret;\n    }\n\n    /**\n     * Escape string for output\n     *\n     * @param $string\n     * @return string\n     */\n    public function _xmlEntities($string) {\n        return hsc($string);\n    }\n\n\n\n    /**\n     * Construct a title and handle images in titles\n     *\n     * @author Harry Fuecks <hfuecks@gmail.com>\n     * @param string|array $title    either string title or media array\n     * @param string       $default  default title if nothing else is found\n     * @param bool         $isImage  will be set to true if it's a media file\n     * @param null|string  $id       linked page id (used to extract title from first heading)\n     * @param string       $linktype content|navigation\n     * @return string      HTML of the title, might be full image tag or just escaped text\n     */\n    public function _getLinkTitle($title, $default, &$isImage, $id = null, $linktype = 'content') {\n        $isImage = false;\n        if(is_array($title)) {\n            $isImage = true;\n            return $this->_imageTitle($title);\n        } elseif(is_null($title) || trim($title) == '') {\n            if(useHeading($linktype) && $id) {\n                $heading = p_get_first_heading($id);\n                if(!blank($heading)) {\n                    return $this->_xmlEntities($heading);\n                }\n            }\n            return $this->_xmlEntities($default);\n        } else {\n            return $this->_xmlEntities($title);\n        }\n    }\n\n    /**\n     * Returns HTML code for images used in link titles\n     *\n     * @author Andreas Gohr <andi@splitbrain.org>\n     * @param array $img\n     * @return string HTML img tag or similar\n     */\n    public function _imageTitle($img) {\n        global $ID;\n\n        // some fixes on $img['src']\n        // see internalmedia() and externalmedia()\n        list($img['src']) = explode('#', $img['src'], 2);\n        if($img['type'] == 'internalmedia') {\n            $img['src'] = (new MediaResolver($ID))->resolveId($img['src'], $this->date_at, true);\n        }\n\n        return $this->_media(\n            $img['src'],\n            $img['title'],\n            $img['align'],\n            $img['width'],\n            $img['height'],\n            $img['cache']\n        );\n    }\n\n    /**\n     * helperfunction to return a basic link to a media\n     *\n     * used in internalmedia() and externalmedia()\n     *\n     * @author   Pierre Spring <pierre.spring@liip.ch>\n     * @param string $src       media ID\n     * @param string $title     descriptive text\n     * @param string $align     left|center|right\n     * @param int    $width     width of media in pixel\n     * @param int    $height    height of media in pixel\n     * @param string $cache     cache|recache|nocache\n     * @param bool   $render    should the media be embedded inline or just linked\n     * @return array associative array with link config\n     */\n    public function _getMediaLinkConf($src, $title, $align, $width, $height, $cache, $render) {\n        global $conf;\n\n        $link           = array();\n        $link['class']  = 'media';\n        $link['style']  = '';\n        $link['pre']    = '';\n        $link['suf']    = '';\n        $link['more']   = '';\n        $link['target'] = $conf['target']['media'];\n        if($conf['target']['media']) $link['rel'] = 'noopener';\n        $link['title']  = $this->_xmlEntities($src);\n        $link['name']   = $this->_media($src, $title, $align, $width, $height, $cache, $render);\n\n        return $link;\n    }\n\n    /**\n     * Embed video(s) in HTML\n     *\n     * @author Anika Henke <anika@selfthinker.org>\n     * @author Schplurtz le D\u00e9boulonn\u00e9 <Schplurtz@laposte.net>\n     *\n     * @param string $src         - ID of video to embed\n     * @param int    $width       - width of the video in pixels\n     * @param int    $height      - height of the video in pixels\n     * @param array  $atts        - additional attributes for the <video> tag\n     * @return string\n     */\n    public function _video($src, $width, $height, $atts = null) {\n        // prepare width and height\n        if(is_null($atts)) $atts = array();\n        $atts['width']  = (int) $width;\n        $atts['height'] = (int) $height;\n        if(!$atts['width']) $atts['width'] = 320;\n        if(!$atts['height']) $atts['height'] = 240;\n\n        $posterUrl = '';\n        $files = array();\n        $tracks = array();\n        $isExternal = media_isexternal($src);\n\n        if ($isExternal) {\n            // take direct source for external files\n            list(/*ext*/, $srcMime) = mimetype($src);\n            $files[$srcMime] = $src;\n        } else {\n            // prepare alternative formats\n            $extensions   = array('webm', 'ogv', 'mp4');\n            $files        = media_alternativefiles($src, $extensions);\n            $poster       = media_alternativefiles($src, array('jpg', 'png'));\n            $tracks       = media_trackfiles($src);\n            if(!empty($poster)) {\n                $posterUrl = ml(reset($poster), '', true, '&');\n            }\n        }\n\n        $out = '';\n        // open video tag\n        $out .= '<video '.buildAttributes($atts).' controls=\"controls\"';\n        if($posterUrl) $out .= ' poster=\"'.hsc($posterUrl).'\"';\n        $out .= '>'.NL;\n        $fallback = '';\n\n        // output source for each alternative video format\n        foreach($files as $mime => $file) {\n            if ($isExternal) {\n                $url = $file;\n                $linkType = 'externalmedia';\n            } else {\n                $url = ml($file, '', true, '&');\n                $linkType = 'internalmedia';\n            }\n            $title = !empty($atts['title'])\n                ? $atts['title']\n                : $this->_xmlEntities(\\dokuwiki\\Utf8\\PhpString::basename(noNS($file)));\n\n            $out .= '<source src=\"'.hsc($url).'\" type=\"'.$mime.'\" />'.NL;\n            // alternative content (just a link to the file)\n            $fallback .= $this->$linkType(\n                $file,\n                $title,\n                null,\n                null,\n                null,\n                $cache = null,\n                $linking = 'linkonly',\n                $return = true\n            );\n        }\n\n        // output each track if any\n        foreach( $tracks as $trackid => $info ) {\n            list( $kind, $srclang ) = array_map( 'hsc', $info );\n            $out .= \"<track kind=\\\"$kind\\\" srclang=\\\"$srclang\\\" \";\n            $out .= \"label=\\\"$srclang\\\" \";\n            $out .= 'src=\"'.ml($trackid, '', true).'\">'.NL;\n        }\n\n        // finish\n        $out .= $fallback;\n        $out .= '</video>'.NL;\n        return $out;\n    }\n\n    /**\n     * Embed audio in HTML\n     *\n     * @author Anika Henke <anika@selfthinker.org>\n     *\n     * @param string $src       - ID of audio to embed\n     * @param array  $atts      - additional attributes for the <audio> tag\n     * @return string\n     */\n    public function _audio($src, $atts = array()) {\n        $files = array();\n        $isExternal = media_isexternal($src);\n\n        if ($isExternal) {\n            // take direct source for external files\n            list(/*ext*/, $srcMime) = mimetype($src);\n            $files[$srcMime] = $src;\n        } else {\n            // prepare alternative formats\n            $extensions   = array('ogg', 'mp3', 'wav');\n            $files        = media_alternativefiles($src, $extensions);\n        }\n\n        $out = '';\n        // open audio tag\n        $out .= '<audio '.buildAttributes($atts).' controls=\"controls\">'.NL;\n        $fallback = '';\n\n        // output source for each alternative audio format\n        foreach($files as $mime => $file) {\n            if ($isExternal) {\n                $url = $file;\n                $linkType = 'externalmedia';\n            } else {\n                $url = ml($file, '', true, '&');\n                $linkType = 'internalmedia';\n            }\n            $title = $atts['title'] ? $atts['title'] : $this->_xmlEntities(\\dokuwiki\\Utf8\\PhpString::basename(noNS($file)));\n\n            $out .= '<source src=\"'.hsc($url).'\" type=\"'.$mime.'\" />'.NL;\n            // alternative content (just a link to the file)\n            $fallback .= $this->$linkType(\n                $file,\n                $title,\n                null,\n                null,\n                null,\n                $cache = null,\n                $linking = 'linkonly',\n                $return = true\n            );\n        }\n\n        // finish\n        $out .= $fallback;\n        $out .= '</audio>'.NL;\n        return $out;\n    }\n\n    /**\n     * _getLastMediaRevisionAt is a helperfunction to internalmedia() and _media()\n     * which returns an existing media revision less or equal to rev or date_at\n     *\n     * @author lisps\n     * @param string $media_id\n     * @access protected\n     * @return string revision ('' for current)\n     */\n    protected function _getLastMediaRevisionAt($media_id) {\n        if (!$this->date_at || media_isexternal($media_id)) return '';\n        $changelog = new MediaChangeLog($media_id);\n        return $changelog->getLastRevisionAt($this->date_at);\n    }\n\n    #endregion\n}\n\n//Setup VIM: ex: et ts=4 :\n"], "filenames": ["inc/parser/xhtml.php"], "buggy_code_start_loc": [1282], "buggy_code_end_loc": [1309], "fixing_code_start_loc": [1283], "fixing_code_end_loc": [1310], "type": "CWE-79", "message": "DokuWiki before 2023-04-04a allows XSS via RSS titles.", "other": {"cve": {"id": "CVE-2023-34408", "sourceIdentifier": "cve@mitre.org", "published": "2023-06-05T02:15:09.537", "lastModified": "2023-06-09T18:44:52.567", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "DokuWiki before 2023-04-04a allows XSS via RSS titles."}, {"lang": "es", "value": "DokuWiki antes de la fecha 04-04-2023 permite ataques de Cross-Site Scripting (XSS) a trav\u00e9s de t\u00edtulos RSS. "}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dokuwiki:dokuwiki:*:*:*:*:*:*:*:*", "versionEndExcluding": "2023-04-04a", "matchCriteriaId": "FDA8006C-4EDB-4CC6-9FB5-1A0F553ABE62"}]}]}], "references": [{"url": "https://github.com/dokuwiki/dokuwiki/compare/release-2023-04-04...release-2023-04-04a", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/dokuwiki/dokuwiki/pull/3967", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/c6119106-1a5c-464c-94dd-ee7c5d0bece0/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://www.github.com/splitbrain/dokuwiki/commit/53df38b0e4465894a67a5890f74a6f5f82e827de", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://www.github.com/splitbrain/dokuwiki/commit/53df38b0e4465894a67a5890f74a6f5f82e827de"}}