{"buggy_code": ["/*\n * NXP Wireless LAN device driver: association and ad-hoc start/join\n *\n * Copyright 2011-2020 NXP\n *\n * This software file (the \"File\") is distributed by NXP\n * under the terms of the GNU General Public License Version 2, June 1991\n * (the \"License\").  You may use, redistribute and/or modify this File in\n * accordance with the terms and conditions of the License, a copy of which\n * is available by writing to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the\n * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n *\n * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE\n * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about\n * this warranty disclaimer.\n */\n\n#include \"decl.h\"\n#include \"ioctl.h\"\n#include \"util.h\"\n#include \"fw.h\"\n#include \"main.h\"\n#include \"wmm.h\"\n#include \"11n.h\"\n#include \"11ac.h\"\n\n#define CAPINFO_MASK    (~(BIT(15) | BIT(14) | BIT(12) | BIT(11) | BIT(9)))\n\n/*\n * Append a generic IE as a pass through TLV to a TLV buffer.\n *\n * This function is called from the network join command preparation routine.\n *\n * If the IE buffer has been setup by the application, this routine appends\n * the buffer as a pass through TLV type to the request.\n */\nstatic int\nmwifiex_cmd_append_generic_ie(struct mwifiex_private *priv, u8 **buffer)\n{\n\tint ret_len = 0;\n\tstruct mwifiex_ie_types_header ie_header;\n\n\t/* Null Checks */\n\tif (!buffer)\n\t\treturn 0;\n\tif (!(*buffer))\n\t\treturn 0;\n\n\t/*\n\t * If there is a generic ie buffer setup, append it to the return\n\t *   parameter buffer pointer.\n\t */\n\tif (priv->gen_ie_buf_len) {\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: %s: append generic ie len %d to %p\\n\",\n\t\t\t    __func__, priv->gen_ie_buf_len, *buffer);\n\n\t\t/* Wrap the generic IE buffer with a pass through TLV type */\n\t\tie_header.type = cpu_to_le16(TLV_TYPE_PASSTHROUGH);\n\t\tie_header.len = cpu_to_le16(priv->gen_ie_buf_len);\n\t\tmemcpy(*buffer, &ie_header, sizeof(ie_header));\n\n\t\t/* Increment the return size and the return buffer pointer\n\t\t   param */\n\t\t*buffer += sizeof(ie_header);\n\t\tret_len += sizeof(ie_header);\n\n\t\t/* Copy the generic IE buffer to the output buffer, advance\n\t\t   pointer */\n\t\tmemcpy(*buffer, priv->gen_ie_buf, priv->gen_ie_buf_len);\n\n\t\t/* Increment the return size and the return buffer pointer\n\t\t   param */\n\t\t*buffer += priv->gen_ie_buf_len;\n\t\tret_len += priv->gen_ie_buf_len;\n\n\t\t/* Reset the generic IE buffer */\n\t\tpriv->gen_ie_buf_len = 0;\n\t}\n\n\t/* return the length appended to the buffer */\n\treturn ret_len;\n}\n\n/*\n * Append TSF tracking info from the scan table for the target AP.\n *\n * This function is called from the network join command preparation routine.\n *\n * The TSF table TSF sent to the firmware contains two TSF values:\n *      - The TSF of the target AP from its previous beacon/probe response\n *      - The TSF timestamp of our local MAC at the time we observed the\n *        beacon/probe response.\n *\n * The firmware uses the timestamp values to set an initial TSF value\n * in the MAC for the new association after a reassociation attempt.\n */\nstatic int\nmwifiex_cmd_append_tsf_tlv(struct mwifiex_private *priv, u8 **buffer,\n\t\t\t   struct mwifiex_bssdescriptor *bss_desc)\n{\n\tstruct mwifiex_ie_types_tsf_timestamp tsf_tlv;\n\t__le64 tsf_val;\n\n\t/* Null Checks */\n\tif (buffer == NULL)\n\t\treturn 0;\n\tif (*buffer == NULL)\n\t\treturn 0;\n\n\tmemset(&tsf_tlv, 0x00, sizeof(struct mwifiex_ie_types_tsf_timestamp));\n\n\ttsf_tlv.header.type = cpu_to_le16(TLV_TYPE_TSFTIMESTAMP);\n\ttsf_tlv.header.len = cpu_to_le16(2 * sizeof(tsf_val));\n\n\tmemcpy(*buffer, &tsf_tlv, sizeof(tsf_tlv.header));\n\t*buffer += sizeof(tsf_tlv.header);\n\n\t/* TSF at the time when beacon/probe_response was received */\n\ttsf_val = cpu_to_le64(bss_desc->fw_tsf);\n\tmemcpy(*buffer, &tsf_val, sizeof(tsf_val));\n\t*buffer += sizeof(tsf_val);\n\n\ttsf_val = cpu_to_le64(bss_desc->timestamp);\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: %s: TSF offset calc: %016llx - %016llx\\n\",\n\t\t    __func__, bss_desc->timestamp, bss_desc->fw_tsf);\n\n\tmemcpy(*buffer, &tsf_val, sizeof(tsf_val));\n\t*buffer += sizeof(tsf_val);\n\n\treturn sizeof(tsf_tlv.header) + (2 * sizeof(tsf_val));\n}\n\n/*\n * This function finds out the common rates between rate1 and rate2.\n *\n * It will fill common rates in rate1 as output if found.\n *\n * NOTE: Setting the MSB of the basic rates needs to be taken\n * care of, either before or after calling this function.\n */\nstatic int mwifiex_get_common_rates(struct mwifiex_private *priv, u8 *rate1,\n\t\t\t\t    u32 rate1_size, u8 *rate2, u32 rate2_size)\n{\n\tint ret;\n\tu8 *ptr = rate1, *tmp;\n\tu32 i, j;\n\n\ttmp = kmemdup(rate1, rate1_size, GFP_KERNEL);\n\tif (!tmp) {\n\t\tmwifiex_dbg(priv->adapter, ERROR, \"failed to alloc tmp buf\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(rate1, 0, rate1_size);\n\n\tfor (i = 0; i < rate2_size && rate2[i]; i++) {\n\t\tfor (j = 0; j < rate1_size && tmp[j]; j++) {\n\t\t\t/* Check common rate, excluding the bit for\n\t\t\t   basic rate */\n\t\t\tif ((rate2[i] & 0x7F) == (tmp[j] & 0x7F)) {\n\t\t\t\t*rate1++ = tmp[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tmwifiex_dbg(priv->adapter, INFO, \"info: Tx data rate set to %#x\\n\",\n\t\t    priv->data_rate);\n\n\tif (!priv->is_data_rate_auto) {\n\t\twhile (*ptr) {\n\t\t\tif ((*ptr & 0x7f) == priv->data_rate) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tptr++;\n\t\t}\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"previously set fixed data rate %#x\\t\"\n\t\t\t    \"is not compatible with the network\\n\",\n\t\t\t    priv->data_rate);\n\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\n\tret = 0;\ndone:\n\tkfree(tmp);\n\treturn ret;\n}\n\n/*\n * This function creates the intersection of the rates supported by a\n * target BSS and our adapter settings for use in an assoc/join command.\n */\nstatic int\nmwifiex_setup_rates_from_bssdesc(struct mwifiex_private *priv,\n\t\t\t\t struct mwifiex_bssdescriptor *bss_desc,\n\t\t\t\t u8 *out_rates, u32 *out_rates_size)\n{\n\tu8 card_rates[MWIFIEX_SUPPORTED_RATES];\n\tu32 card_rates_size;\n\n\t/* Copy AP supported rates */\n\tmemcpy(out_rates, bss_desc->supported_rates, MWIFIEX_SUPPORTED_RATES);\n\t/* Get the STA supported rates */\n\tcard_rates_size = mwifiex_get_active_data_rates(priv, card_rates);\n\t/* Get the common rates between AP and STA supported rates */\n\tif (mwifiex_get_common_rates(priv, out_rates, MWIFIEX_SUPPORTED_RATES,\n\t\t\t\t     card_rates, card_rates_size)) {\n\t\t*out_rates_size = 0;\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"%s: cannot get common rates\\n\",\n\t\t\t    __func__);\n\t\treturn -1;\n\t}\n\n\t*out_rates_size =\n\t\tmin_t(size_t, strlen(out_rates), MWIFIEX_SUPPORTED_RATES);\n\n\treturn 0;\n}\n\n/*\n * This function appends a WPS IE. It is called from the network join command\n * preparation routine.\n *\n * If the IE buffer has been setup by the application, this routine appends\n * the buffer as a WPS TLV type to the request.\n */\nstatic int\nmwifiex_cmd_append_wps_ie(struct mwifiex_private *priv, u8 **buffer)\n{\n\tint retLen = 0;\n\tstruct mwifiex_ie_types_header ie_header;\n\n\tif (!buffer || !*buffer)\n\t\treturn 0;\n\n\t/*\n\t * If there is a wps ie buffer setup, append it to the return\n\t * parameter buffer pointer.\n\t */\n\tif (priv->wps_ie_len) {\n\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t    \"cmd: append wps ie %d to %p\\n\",\n\t\t\t    priv->wps_ie_len, *buffer);\n\n\t\t/* Wrap the generic IE buffer with a pass through TLV type */\n\t\tie_header.type = cpu_to_le16(TLV_TYPE_PASSTHROUGH);\n\t\tie_header.len = cpu_to_le16(priv->wps_ie_len);\n\t\tmemcpy(*buffer, &ie_header, sizeof(ie_header));\n\t\t*buffer += sizeof(ie_header);\n\t\tretLen += sizeof(ie_header);\n\n\t\tmemcpy(*buffer, priv->wps_ie, priv->wps_ie_len);\n\t\t*buffer += priv->wps_ie_len;\n\t\tretLen += priv->wps_ie_len;\n\n\t}\n\n\tkfree(priv->wps_ie);\n\tpriv->wps_ie_len = 0;\n\treturn retLen;\n}\n\n/*\n * This function appends a WAPI IE.\n *\n * This function is called from the network join command preparation routine.\n *\n * If the IE buffer has been setup by the application, this routine appends\n * the buffer as a WAPI TLV type to the request.\n */\nstatic int\nmwifiex_cmd_append_wapi_ie(struct mwifiex_private *priv, u8 **buffer)\n{\n\tint retLen = 0;\n\tstruct mwifiex_ie_types_header ie_header;\n\n\t/* Null Checks */\n\tif (buffer == NULL)\n\t\treturn 0;\n\tif (*buffer == NULL)\n\t\treturn 0;\n\n\t/*\n\t * If there is a wapi ie buffer setup, append it to the return\n\t *   parameter buffer pointer.\n\t */\n\tif (priv->wapi_ie_len) {\n\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t    \"cmd: append wapi ie %d to %p\\n\",\n\t\t\t    priv->wapi_ie_len, *buffer);\n\n\t\t/* Wrap the generic IE buffer with a pass through TLV type */\n\t\tie_header.type = cpu_to_le16(TLV_TYPE_WAPI_IE);\n\t\tie_header.len = cpu_to_le16(priv->wapi_ie_len);\n\t\tmemcpy(*buffer, &ie_header, sizeof(ie_header));\n\n\t\t/* Increment the return size and the return buffer pointer\n\t\t   param */\n\t\t*buffer += sizeof(ie_header);\n\t\tretLen += sizeof(ie_header);\n\n\t\t/* Copy the wapi IE buffer to the output buffer, advance\n\t\t   pointer */\n\t\tmemcpy(*buffer, priv->wapi_ie, priv->wapi_ie_len);\n\n\t\t/* Increment the return size and the return buffer pointer\n\t\t   param */\n\t\t*buffer += priv->wapi_ie_len;\n\t\tretLen += priv->wapi_ie_len;\n\n\t}\n\t/* return the length appended to the buffer */\n\treturn retLen;\n}\n\n/*\n * This function appends rsn ie tlv for wpa/wpa2 security modes.\n * It is called from the network join command preparation routine.\n */\nstatic int mwifiex_append_rsn_ie_wpa_wpa2(struct mwifiex_private *priv,\n\t\t\t\t\t  u8 **buffer)\n{\n\tstruct mwifiex_ie_types_rsn_param_set *rsn_ie_tlv;\n\tint rsn_ie_len;\n\n\tif (!buffer || !(*buffer))\n\t\treturn 0;\n\n\trsn_ie_tlv = (struct mwifiex_ie_types_rsn_param_set *) (*buffer);\n\trsn_ie_tlv->header.type = cpu_to_le16((u16) priv->wpa_ie[0]);\n\trsn_ie_tlv->header.type = cpu_to_le16(\n\t\t\t\t le16_to_cpu(rsn_ie_tlv->header.type) & 0x00FF);\n\trsn_ie_tlv->header.len = cpu_to_le16((u16) priv->wpa_ie[1]);\n\trsn_ie_tlv->header.len = cpu_to_le16(le16_to_cpu(rsn_ie_tlv->header.len)\n\t\t\t\t\t\t\t & 0x00FF);\n\tif (le16_to_cpu(rsn_ie_tlv->header.len) <= (sizeof(priv->wpa_ie) - 2))\n\t\tmemcpy(rsn_ie_tlv->rsn_ie, &priv->wpa_ie[2],\n\t\t       le16_to_cpu(rsn_ie_tlv->header.len));\n\telse\n\t\treturn -1;\n\n\trsn_ie_len = sizeof(rsn_ie_tlv->header) +\n\t\t\t\t\tle16_to_cpu(rsn_ie_tlv->header.len);\n\t*buffer += rsn_ie_len;\n\n\treturn rsn_ie_len;\n}\n\n/*\n * This function prepares command for association.\n *\n * This sets the following parameters -\n *      - Peer MAC address\n *      - Listen interval\n *      - Beacon interval\n *      - Capability information\n *\n * ...and the following TLVs, as required -\n *      - SSID TLV\n *      - PHY TLV\n *      - SS TLV\n *      - Rates TLV\n *      - Authentication TLV\n *      - Channel TLV\n *      - WPA/WPA2 IE\n *      - 11n TLV\n *      - Vendor specific TLV\n *      - WMM TLV\n *      - WAPI IE\n *      - Generic IE\n *      - TSF TLV\n *\n * Preparation also includes -\n *      - Setting command ID and proper size\n *      - Ensuring correct endian-ness\n */\nint mwifiex_cmd_802_11_associate(struct mwifiex_private *priv,\n\t\t\t\t struct host_cmd_ds_command *cmd,\n\t\t\t\t struct mwifiex_bssdescriptor *bss_desc)\n{\n\tstruct host_cmd_ds_802_11_associate *assoc = &cmd->params.associate;\n\tstruct mwifiex_ie_types_ssid_param_set *ssid_tlv;\n\tstruct mwifiex_ie_types_phy_param_set *phy_tlv;\n\tstruct mwifiex_ie_types_ss_param_set *ss_tlv;\n\tstruct mwifiex_ie_types_rates_param_set *rates_tlv;\n\tstruct mwifiex_ie_types_auth_type *auth_tlv;\n\tstruct mwifiex_ie_types_chan_list_param_set *chan_tlv;\n\tu8 rates[MWIFIEX_SUPPORTED_RATES];\n\tu32 rates_size;\n\tu16 tmp_cap;\n\tu8 *pos;\n\tint rsn_ie_len = 0;\n\n\tpos = (u8 *) assoc;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_ASSOCIATE);\n\n\t/* Save so we know which BSS Desc to use in the response handler */\n\tpriv->attempted_bss_desc = bss_desc;\n\n\tmemcpy(assoc->peer_sta_addr,\n\t       bss_desc->mac_address, sizeof(assoc->peer_sta_addr));\n\tpos += sizeof(assoc->peer_sta_addr);\n\n\t/* Set the listen interval */\n\tassoc->listen_interval = cpu_to_le16(priv->listen_interval);\n\t/* Set the beacon period */\n\tassoc->beacon_period = cpu_to_le16(bss_desc->beacon_period);\n\n\tpos += sizeof(assoc->cap_info_bitmap);\n\tpos += sizeof(assoc->listen_interval);\n\tpos += sizeof(assoc->beacon_period);\n\tpos += sizeof(assoc->dtim_period);\n\n\tssid_tlv = (struct mwifiex_ie_types_ssid_param_set *) pos;\n\tssid_tlv->header.type = cpu_to_le16(WLAN_EID_SSID);\n\tssid_tlv->header.len = cpu_to_le16((u16) bss_desc->ssid.ssid_len);\n\tmemcpy(ssid_tlv->ssid, bss_desc->ssid.ssid,\n\t       le16_to_cpu(ssid_tlv->header.len));\n\tpos += sizeof(ssid_tlv->header) + le16_to_cpu(ssid_tlv->header.len);\n\n\tphy_tlv = (struct mwifiex_ie_types_phy_param_set *) pos;\n\tphy_tlv->header.type = cpu_to_le16(WLAN_EID_DS_PARAMS);\n\tphy_tlv->header.len = cpu_to_le16(sizeof(phy_tlv->fh_ds.ds_param_set));\n\tmemcpy(&phy_tlv->fh_ds.ds_param_set,\n\t       &bss_desc->phy_param_set.ds_param_set.current_chan,\n\t       sizeof(phy_tlv->fh_ds.ds_param_set));\n\tpos += sizeof(phy_tlv->header) + le16_to_cpu(phy_tlv->header.len);\n\n\tss_tlv = (struct mwifiex_ie_types_ss_param_set *) pos;\n\tss_tlv->header.type = cpu_to_le16(WLAN_EID_CF_PARAMS);\n\tss_tlv->header.len = cpu_to_le16(sizeof(ss_tlv->cf_ibss.cf_param_set));\n\tpos += sizeof(ss_tlv->header) + le16_to_cpu(ss_tlv->header.len);\n\n\t/* Get the common rates supported between the driver and the BSS Desc */\n\tif (mwifiex_setup_rates_from_bssdesc\n\t    (priv, bss_desc, rates, &rates_size))\n\t\treturn -1;\n\n\t/* Save the data rates into Current BSS state structure */\n\tpriv->curr_bss_params.num_of_rates = rates_size;\n\tmemcpy(&priv->curr_bss_params.data_rates, rates, rates_size);\n\n\t/* Setup the Rates TLV in the association command */\n\trates_tlv = (struct mwifiex_ie_types_rates_param_set *) pos;\n\trates_tlv->header.type = cpu_to_le16(WLAN_EID_SUPP_RATES);\n\trates_tlv->header.len = cpu_to_le16((u16) rates_size);\n\tmemcpy(rates_tlv->rates, rates, rates_size);\n\tpos += sizeof(rates_tlv->header) + rates_size;\n\tmwifiex_dbg(priv->adapter, INFO, \"info: ASSOC_CMD: rates size = %d\\n\",\n\t\t    rates_size);\n\n\t/* Add the Authentication type to be used for Auth frames */\n\tauth_tlv = (struct mwifiex_ie_types_auth_type *) pos;\n\tauth_tlv->header.type = cpu_to_le16(TLV_TYPE_AUTH_TYPE);\n\tauth_tlv->header.len = cpu_to_le16(sizeof(auth_tlv->auth_type));\n\tif (priv->sec_info.wep_enabled)\n\t\tauth_tlv->auth_type = cpu_to_le16(\n\t\t\t\t(u16) priv->sec_info.authentication_mode);\n\telse\n\t\tauth_tlv->auth_type = cpu_to_le16(NL80211_AUTHTYPE_OPEN_SYSTEM);\n\n\tpos += sizeof(auth_tlv->header) + le16_to_cpu(auth_tlv->header.len);\n\n\tif (IS_SUPPORT_MULTI_BANDS(priv->adapter) &&\n\t    !(ISSUPP_11NENABLED(priv->adapter->fw_cap_info) &&\n\t    (!bss_desc->disable_11n) &&\n\t    (priv->adapter->config_bands & BAND_GN ||\n\t     priv->adapter->config_bands & BAND_AN) &&\n\t    (bss_desc->bcn_ht_cap)\n\t    )\n\t\t) {\n\t\t/* Append a channel TLV for the channel the attempted AP was\n\t\t   found on */\n\t\tchan_tlv = (struct mwifiex_ie_types_chan_list_param_set *) pos;\n\t\tchan_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\n\t\tchan_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(struct mwifiex_chan_scan_param_set));\n\n\t\tmemset(chan_tlv->chan_scan_param, 0x00,\n\t\t       sizeof(struct mwifiex_chan_scan_param_set));\n\t\tchan_tlv->chan_scan_param[0].chan_number =\n\t\t\t(bss_desc->phy_param_set.ds_param_set.current_chan);\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: Assoc: TLV Chan = %d\\n\",\n\t\t\t    chan_tlv->chan_scan_param[0].chan_number);\n\n\t\tchan_tlv->chan_scan_param[0].radio_type =\n\t\t\tmwifiex_band_to_radio_type((u8) bss_desc->bss_band);\n\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: Assoc: TLV Band = %d\\n\",\n\t\t\t    chan_tlv->chan_scan_param[0].radio_type);\n\t\tpos += sizeof(chan_tlv->header) +\n\t\t\tsizeof(struct mwifiex_chan_scan_param_set);\n\t}\n\n\tif (!priv->wps.session_enable) {\n\t\tif (priv->sec_info.wpa_enabled || priv->sec_info.wpa2_enabled)\n\t\t\trsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2(priv, &pos);\n\n\t\tif (rsn_ie_len == -1)\n\t\t\treturn -1;\n\t}\n\n\tif (ISSUPP_11NENABLED(priv->adapter->fw_cap_info) &&\n\t    (!bss_desc->disable_11n) &&\n\t    (priv->adapter->config_bands & BAND_GN ||\n\t     priv->adapter->config_bands & BAND_AN))\n\t\tmwifiex_cmd_append_11n_tlv(priv, bss_desc, &pos);\n\n\tif (ISSUPP_11ACENABLED(priv->adapter->fw_cap_info) &&\n\t    !bss_desc->disable_11n && !bss_desc->disable_11ac &&\n\t    priv->adapter->config_bands & BAND_AAC)\n\t\tmwifiex_cmd_append_11ac_tlv(priv, bss_desc, &pos);\n\n\t/* Append vendor specific IE TLV */\n\tmwifiex_cmd_append_vsie_tlv(priv, MWIFIEX_VSIE_MASK_ASSOC, &pos);\n\n\tmwifiex_wmm_process_association_req(priv, &pos, &bss_desc->wmm_ie,\n\t\t\t\t\t    bss_desc->bcn_ht_cap);\n\tif (priv->sec_info.wapi_enabled && priv->wapi_ie_len)\n\t\tmwifiex_cmd_append_wapi_ie(priv, &pos);\n\n\tif (priv->wps.session_enable && priv->wps_ie_len)\n\t\tmwifiex_cmd_append_wps_ie(priv, &pos);\n\n\tmwifiex_cmd_append_generic_ie(priv, &pos);\n\n\tmwifiex_cmd_append_tsf_tlv(priv, &pos, bss_desc);\n\n\tmwifiex_11h_process_join(priv, &pos, bss_desc);\n\n\tcmd->size = cpu_to_le16((u16) (pos - (u8 *) assoc) + S_DS_GEN);\n\n\t/* Set the Capability info at last */\n\ttmp_cap = bss_desc->cap_info_bitmap;\n\n\tif (priv->adapter->config_bands == BAND_B)\n\t\ttmp_cap &= ~WLAN_CAPABILITY_SHORT_SLOT_TIME;\n\n\ttmp_cap &= CAPINFO_MASK;\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: ASSOC_CMD: tmp_cap=%4X CAPINFO_MASK=%4lX\\n\",\n\t\t    tmp_cap, CAPINFO_MASK);\n\tassoc->cap_info_bitmap = cpu_to_le16(tmp_cap);\n\n\treturn 0;\n}\n\nstatic const char *assoc_failure_reason_to_str(u16 cap_info)\n{\n\tswitch (cap_info) {\n\tcase CONNECT_ERR_AUTH_ERR_STA_FAILURE:\n\t\treturn \"CONNECT_ERR_AUTH_ERR_STA_FAILURE\";\n\tcase CONNECT_ERR_AUTH_MSG_UNHANDLED:\n\t\treturn \"CONNECT_ERR_AUTH_MSG_UNHANDLED\";\n\tcase CONNECT_ERR_ASSOC_ERR_TIMEOUT:\n\t\treturn \"CONNECT_ERR_ASSOC_ERR_TIMEOUT\";\n\tcase CONNECT_ERR_ASSOC_ERR_AUTH_REFUSED:\n\t\treturn \"CONNECT_ERR_ASSOC_ERR_AUTH_REFUSED\";\n\tcase CONNECT_ERR_STA_FAILURE:\n\t\treturn \"CONNECT_ERR_STA_FAILURE\";\n\t}\n\n\treturn \"Unknown connect failure\";\n}\n/*\n * Association firmware command response handler\n *\n * The response buffer for the association command has the following\n * memory layout.\n *\n * For cases where an association response was not received (indicated\n * by the CapInfo and AId field):\n *\n *     .------------------------------------------------------------.\n *     |  Header(4 * sizeof(t_u16)):  Standard command response hdr |\n *     .------------------------------------------------------------.\n *     |  cap_info/Error Return(t_u16):                             |\n *     |           0xFFFF(-1): Internal error                       |\n *     |           0xFFFE(-2): Authentication unhandled message     |\n *     |           0xFFFD(-3): Authentication refused               |\n *     |           0xFFFC(-4): Timeout waiting for AP response      |\n *     .------------------------------------------------------------.\n *     |  status_code(t_u16):                                       |\n *     |        If cap_info is -1:                                  |\n *     |           An internal firmware failure prevented the       |\n *     |           command from being processed.  The status_code   |\n *     |           will be set to 1.                                |\n *     |                                                            |\n *     |        If cap_info is -2:                                  |\n *     |           An authentication frame was received but was     |\n *     |           not handled by the firmware.  IEEE Status        |\n *     |           code for the failure is returned.                |\n *     |                                                            |\n *     |        If cap_info is -3:                                  |\n *     |           An authentication frame was received and the     |\n *     |           status_code is the IEEE Status reported in the   |\n *     |           response.                                        |\n *     |                                                            |\n *     |        If cap_info is -4:                                  |\n *     |           (1) Association response timeout                 |\n *     |           (2) Authentication response timeout              |\n *     .------------------------------------------------------------.\n *     |  a_id(t_u16): 0xFFFF                                       |\n *     .------------------------------------------------------------.\n *\n *\n * For cases where an association response was received, the IEEE\n * standard association response frame is returned:\n *\n *     .------------------------------------------------------------.\n *     |  Header(4 * sizeof(t_u16)):  Standard command response hdr |\n *     .------------------------------------------------------------.\n *     |  cap_info(t_u16): IEEE Capability                          |\n *     .------------------------------------------------------------.\n *     |  status_code(t_u16): IEEE Status Code                      |\n *     .------------------------------------------------------------.\n *     |  a_id(t_u16): IEEE Association ID                          |\n *     .------------------------------------------------------------.\n *     |  IEEE IEs(variable): Any received IEs comprising the       |\n *     |                      remaining portion of a received       |\n *     |                      association response frame.           |\n *     .------------------------------------------------------------.\n *\n * For simplistic handling, the status_code field can be used to determine\n * an association success (0) or failure (non-zero).\n */\nint mwifiex_ret_802_11_associate(struct mwifiex_private *priv,\n\t\t\t     struct host_cmd_ds_command *resp)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tint ret = 0;\n\tstruct ieee_types_assoc_rsp *assoc_rsp;\n\tstruct mwifiex_bssdescriptor *bss_desc;\n\tbool enable_data = true;\n\tu16 cap_info, status_code, aid;\n\tconst u8 *ie_ptr;\n\tstruct ieee80211_ht_operation *assoc_resp_ht_oper;\n\n\tif (!priv->attempted_bss_desc) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"ASSOC_RESP: failed, association terminated by host\\n\");\n\t\tgoto done;\n\t}\n\n\tassoc_rsp = (struct ieee_types_assoc_rsp *) &resp->params;\n\n\tcap_info = le16_to_cpu(assoc_rsp->cap_info_bitmap);\n\tstatus_code = le16_to_cpu(assoc_rsp->status_code);\n\taid = le16_to_cpu(assoc_rsp->a_id);\n\n\tif ((aid & (BIT(15) | BIT(14))) != (BIT(15) | BIT(14)))\n\t\tdev_err(priv->adapter->dev,\n\t\t\t\"invalid AID value 0x%x; bits 15:14 not set\\n\",\n\t\t\taid);\n\n\taid &= ~(BIT(15) | BIT(14));\n\n\tpriv->assoc_rsp_size = min(le16_to_cpu(resp->size) - S_DS_GEN,\n\t\t\t\t   sizeof(priv->assoc_rsp_buf));\n\n\tassoc_rsp->a_id = cpu_to_le16(aid);\n\tmemcpy(priv->assoc_rsp_buf, &resp->params, priv->assoc_rsp_size);\n\n\tif (status_code) {\n\t\tpriv->adapter->dbg.num_cmd_assoc_failure++;\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"ASSOC_RESP: failed,\\t\"\n\t\t\t    \"status code=%d err=%#x a_id=%#x\\n\",\n\t\t\t    status_code, cap_info,\n\t\t\t    le16_to_cpu(assoc_rsp->a_id));\n\n\t\tmwifiex_dbg(priv->adapter, ERROR, \"assoc failure: reason %s\\n\",\n\t\t\t    assoc_failure_reason_to_str(cap_info));\n\t\tif (cap_info == CONNECT_ERR_ASSOC_ERR_TIMEOUT) {\n\t\t\tif (status_code == MWIFIEX_ASSOC_CMD_FAILURE_AUTH) {\n\t\t\t\tret = WLAN_STATUS_AUTH_TIMEOUT;\n\t\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t\t    \"ASSOC_RESP: AUTH timeout\\n\");\n\t\t\t} else {\n\t\t\t\tret = WLAN_STATUS_UNSPECIFIED_FAILURE;\n\t\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t\t    \"ASSOC_RESP: UNSPECIFIED failure\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tret = status_code;\n\t\t}\n\n\t\tgoto done;\n\t}\n\n\t/* Send a Media Connected event, according to the Spec */\n\tpriv->media_connected = true;\n\n\tpriv->adapter->ps_state = PS_STATE_AWAKE;\n\tpriv->adapter->pps_uapsd_mode = false;\n\tpriv->adapter->tx_lock_flag = false;\n\n\t/* Set the attempted BSSID Index to current */\n\tbss_desc = priv->attempted_bss_desc;\n\n\tmwifiex_dbg(priv->adapter, INFO, \"info: ASSOC_RESP: %s\\n\",\n\t\t    bss_desc->ssid.ssid);\n\n\t/* Make a copy of current BSSID descriptor */\n\tmemcpy(&priv->curr_bss_params.bss_descriptor,\n\t       bss_desc, sizeof(struct mwifiex_bssdescriptor));\n\n\t/* Update curr_bss_params */\n\tpriv->curr_bss_params.bss_descriptor.channel\n\t\t= bss_desc->phy_param_set.ds_param_set.current_chan;\n\n\tpriv->curr_bss_params.band = (u8) bss_desc->bss_band;\n\n\tif (bss_desc->wmm_ie.vend_hdr.element_id == WLAN_EID_VENDOR_SPECIFIC)\n\t\tpriv->curr_bss_params.wmm_enabled = true;\n\telse\n\t\tpriv->curr_bss_params.wmm_enabled = false;\n\n\tif ((priv->wmm_required || bss_desc->bcn_ht_cap) &&\n\t    priv->curr_bss_params.wmm_enabled)\n\t\tpriv->wmm_enabled = true;\n\telse\n\t\tpriv->wmm_enabled = false;\n\n\tpriv->curr_bss_params.wmm_uapsd_enabled = false;\n\n\tif (priv->wmm_enabled)\n\t\tpriv->curr_bss_params.wmm_uapsd_enabled\n\t\t\t= ((bss_desc->wmm_ie.qos_info_bitmap &\n\t\t\t\tIEEE80211_WMM_IE_AP_QOSINFO_UAPSD) ? 1 : 0);\n\n\t/* Store the bandwidth information from assoc response */\n\tie_ptr = cfg80211_find_ie(WLAN_EID_HT_OPERATION, assoc_rsp->ie_buffer,\n\t\t\t\t  priv->assoc_rsp_size\n\t\t\t\t  - sizeof(struct ieee_types_assoc_rsp));\n\tif (ie_ptr) {\n\t\tassoc_resp_ht_oper = (struct ieee80211_ht_operation *)(ie_ptr\n\t\t\t\t\t+ sizeof(struct ieee_types_header));\n\t\tpriv->assoc_resp_ht_param = assoc_resp_ht_oper->ht_param;\n\t\tpriv->ht_param_present = true;\n\t} else {\n\t\tpriv->ht_param_present = false;\n\t}\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: ASSOC_RESP: curr_pkt_filter is %#x\\n\",\n\t\t    priv->curr_pkt_filter);\n\tif (priv->sec_info.wpa_enabled || priv->sec_info.wpa2_enabled)\n\t\tpriv->wpa_is_gtk_set = false;\n\n\tif (priv->wmm_enabled) {\n\t\t/* Don't re-enable carrier until we get the WMM_GET_STATUS\n\t\t   event */\n\t\tenable_data = false;\n\t} else {\n\t\t/* Since WMM is not enabled, setup the queues with the\n\t\t   defaults */\n\t\tmwifiex_wmm_setup_queue_priorities(priv, NULL);\n\t\tmwifiex_wmm_setup_ac_downgrade(priv);\n\t}\n\n\tif (enable_data)\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: post association, re-enabling data flow\\n\");\n\n\t/* Reset SNR/NF/RSSI values */\n\tpriv->data_rssi_last = 0;\n\tpriv->data_nf_last = 0;\n\tpriv->data_rssi_avg = 0;\n\tpriv->data_nf_avg = 0;\n\tpriv->bcn_rssi_last = 0;\n\tpriv->bcn_nf_last = 0;\n\tpriv->bcn_rssi_avg = 0;\n\tpriv->bcn_nf_avg = 0;\n\tpriv->rxpd_rate = 0;\n\tpriv->rxpd_htinfo = 0;\n\n\tmwifiex_save_curr_bcn(priv);\n\n\tpriv->adapter->dbg.num_cmd_assoc_success++;\n\n\tmwifiex_dbg(priv->adapter, INFO, \"info: ASSOC_RESP: associated\\n\");\n\n\t/* Add the ra_list here for infra mode as there will be only 1 ra\n\t   always */\n\tmwifiex_ralist_add(priv,\n\t\t\t   priv->curr_bss_params.bss_descriptor.mac_address);\n\n\tif (!netif_carrier_ok(priv->netdev))\n\t\tnetif_carrier_on(priv->netdev);\n\tmwifiex_wake_up_net_dev_queue(priv->netdev, adapter);\n\n\tif (priv->sec_info.wpa_enabled || priv->sec_info.wpa2_enabled)\n\t\tpriv->scan_block = true;\n\telse\n\t\tpriv->port_open = true;\n\ndone:\n\t/* Need to indicate IOCTL complete */\n\tif (adapter->curr_cmd->wait_q_enabled) {\n\t\tif (ret)\n\t\t\tadapter->cmd_wait_q.status = -1;\n\t\telse\n\t\t\tadapter->cmd_wait_q.status = 0;\n\t}\n\n\treturn ret;\n}\n\n/*\n * This function prepares command for ad-hoc start.\n *\n * Driver will fill up SSID, BSS mode, IBSS parameters, physical\n * parameters, probe delay, and capability information. Firmware\n * will fill up beacon period, basic rates and operational rates.\n *\n * In addition, the following TLVs are added -\n *      - Channel TLV\n *      - Vendor specific IE\n *      - WPA/WPA2 IE\n *      - HT Capabilities IE\n *      - HT Information IE\n *\n * Preparation also includes -\n *      - Setting command ID and proper size\n *      - Ensuring correct endian-ness\n */\nint\nmwifiex_cmd_802_11_ad_hoc_start(struct mwifiex_private *priv,\n\t\t\t\tstruct host_cmd_ds_command *cmd,\n\t\t\t\tstruct cfg80211_ssid *req_ssid)\n{\n\tint rsn_ie_len = 0;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct host_cmd_ds_802_11_ad_hoc_start *adhoc_start =\n\t\t&cmd->params.adhoc_start;\n\tstruct mwifiex_bssdescriptor *bss_desc;\n\tu32 cmd_append_size = 0;\n\tu32 i;\n\tu16 tmp_cap;\n\tstruct mwifiex_ie_types_chan_list_param_set *chan_tlv;\n\tu8 radio_type;\n\n\tstruct mwifiex_ie_types_htcap *ht_cap;\n\tstruct mwifiex_ie_types_htinfo *ht_info;\n\tu8 *pos = (u8 *) adhoc_start +\n\t\t\tsizeof(struct host_cmd_ds_802_11_ad_hoc_start);\n\n\tif (!adapter)\n\t\treturn -1;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_START);\n\n\tbss_desc = &priv->curr_bss_params.bss_descriptor;\n\tpriv->attempted_bss_desc = bss_desc;\n\n\t/*\n\t * Fill in the parameters for 2 data structures:\n\t *   1. struct host_cmd_ds_802_11_ad_hoc_start command\n\t *   2. bss_desc\n\t * Driver will fill up SSID, bss_mode,IBSS param, Physical Param,\n\t * probe delay, and Cap info.\n\t * Firmware will fill up beacon period, Basic rates\n\t * and operational rates.\n\t */\n\n\tmemset(adhoc_start->ssid, 0, IEEE80211_MAX_SSID_LEN);\n\n\tmemcpy(adhoc_start->ssid, req_ssid->ssid, req_ssid->ssid_len);\n\n\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: SSID = %s\\n\",\n\t\t    adhoc_start->ssid);\n\n\tmemset(bss_desc->ssid.ssid, 0, IEEE80211_MAX_SSID_LEN);\n\tmemcpy(bss_desc->ssid.ssid, req_ssid->ssid, req_ssid->ssid_len);\n\n\tbss_desc->ssid.ssid_len = req_ssid->ssid_len;\n\n\t/* Set the BSS mode */\n\tadhoc_start->bss_mode = HostCmd_BSS_MODE_IBSS;\n\tbss_desc->bss_mode = NL80211_IFTYPE_ADHOC;\n\tadhoc_start->beacon_period = cpu_to_le16(priv->beacon_period);\n\tbss_desc->beacon_period = priv->beacon_period;\n\n\t/* Set Physical param set */\n/* Parameter IE Id */\n#define DS_PARA_IE_ID   3\n/* Parameter IE length */\n#define DS_PARA_IE_LEN  1\n\n\tadhoc_start->phy_param_set.ds_param_set.element_id = DS_PARA_IE_ID;\n\tadhoc_start->phy_param_set.ds_param_set.len = DS_PARA_IE_LEN;\n\n\tif (!mwifiex_get_cfp(priv, adapter->adhoc_start_band,\n\t\t\t     (u16) priv->adhoc_channel, 0)) {\n\t\tstruct mwifiex_chan_freq_power *cfp;\n\t\tcfp = mwifiex_get_cfp(priv, adapter->adhoc_start_band,\n\t\t\t\t      FIRST_VALID_CHANNEL, 0);\n\t\tif (cfp)\n\t\t\tpriv->adhoc_channel = (u8) cfp->channel;\n\t}\n\n\tif (!priv->adhoc_channel) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"ADHOC_S_CMD: adhoc_channel cannot be 0\\n\");\n\t\treturn -1;\n\t}\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: ADHOC_S_CMD: creating ADHOC on channel %d\\n\",\n\t\t    priv->adhoc_channel);\n\n\tpriv->curr_bss_params.bss_descriptor.channel = priv->adhoc_channel;\n\tpriv->curr_bss_params.band = adapter->adhoc_start_band;\n\n\tbss_desc->channel = priv->adhoc_channel;\n\tadhoc_start->phy_param_set.ds_param_set.current_chan =\n\t\tpriv->adhoc_channel;\n\n\tmemcpy(&bss_desc->phy_param_set, &adhoc_start->phy_param_set,\n\t       sizeof(union ieee_types_phy_param_set));\n\n\t/* Set IBSS param set */\n/* IBSS parameter IE Id */\n#define IBSS_PARA_IE_ID   6\n/* IBSS parameter IE length */\n#define IBSS_PARA_IE_LEN  2\n\n\tadhoc_start->ss_param_set.ibss_param_set.element_id = IBSS_PARA_IE_ID;\n\tadhoc_start->ss_param_set.ibss_param_set.len = IBSS_PARA_IE_LEN;\n\tadhoc_start->ss_param_set.ibss_param_set.atim_window\n\t\t\t\t\t= cpu_to_le16(priv->atim_window);\n\tmemcpy(&bss_desc->ss_param_set, &adhoc_start->ss_param_set,\n\t       sizeof(union ieee_types_ss_param_set));\n\n\t/* Set Capability info */\n\tbss_desc->cap_info_bitmap |= WLAN_CAPABILITY_IBSS;\n\ttmp_cap = WLAN_CAPABILITY_IBSS;\n\n\t/* Set up privacy in bss_desc */\n\tif (priv->sec_info.encryption_mode) {\n\t\t/* Ad-Hoc capability privacy on */\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: ADHOC_S_CMD: wep_status set privacy to WEP\\n\");\n\t\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_8021X_WEP;\n\t\ttmp_cap |= WLAN_CAPABILITY_PRIVACY;\n\t} else {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: ADHOC_S_CMD: wep_status NOT set,\\t\"\n\t\t\t    \"setting privacy to ACCEPT ALL\\n\");\n\t\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_ACCEPT_ALL;\n\t}\n\n\tmemset(adhoc_start->data_rate, 0, sizeof(adhoc_start->data_rate));\n\tmwifiex_get_active_data_rates(priv, adhoc_start->data_rate);\n\tif ((adapter->adhoc_start_band & BAND_G) &&\n\t    (priv->curr_pkt_filter & HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON)) {\n\t\tif (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\n\t\t\t\t     HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t     &priv->curr_pkt_filter, false)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"ADHOC_S_CMD: G Protection config failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/* Find the last non zero */\n\tfor (i = 0; i < sizeof(adhoc_start->data_rate); i++)\n\t\tif (!adhoc_start->data_rate[i])\n\t\t\tbreak;\n\n\tpriv->curr_bss_params.num_of_rates = i;\n\n\t/* Copy the ad-hoc creating rates into Current BSS rate structure */\n\tmemcpy(&priv->curr_bss_params.data_rates,\n\t       &adhoc_start->data_rate, priv->curr_bss_params.num_of_rates);\n\n\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: rates=%4ph\\n\",\n\t\t    adhoc_start->data_rate);\n\n\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: AD-HOC Start command is ready\\n\");\n\n\tif (IS_SUPPORT_MULTI_BANDS(adapter)) {\n\t\t/* Append a channel TLV */\n\t\tchan_tlv = (struct mwifiex_ie_types_chan_list_param_set *) pos;\n\t\tchan_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\n\t\tchan_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(struct mwifiex_chan_scan_param_set));\n\n\t\tmemset(chan_tlv->chan_scan_param, 0x00,\n\t\t       sizeof(struct mwifiex_chan_scan_param_set));\n\t\tchan_tlv->chan_scan_param[0].chan_number =\n\t\t\t(u8) priv->curr_bss_params.bss_descriptor.channel;\n\n\t\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: TLV Chan = %d\\n\",\n\t\t\t    chan_tlv->chan_scan_param[0].chan_number);\n\n\t\tchan_tlv->chan_scan_param[0].radio_type\n\t\t       = mwifiex_band_to_radio_type(priv->curr_bss_params.band);\n\t\tif (adapter->adhoc_start_band & BAND_GN ||\n\t\t    adapter->adhoc_start_band & BAND_AN) {\n\t\t\tif (adapter->sec_chan_offset ==\n\t\t\t\t\t    IEEE80211_HT_PARAM_CHA_SEC_ABOVE)\n\t\t\t\tchan_tlv->chan_scan_param[0].radio_type |=\n\t\t\t\t\t(IEEE80211_HT_PARAM_CHA_SEC_ABOVE << 4);\n\t\t\telse if (adapter->sec_chan_offset ==\n\t\t\t\t\t    IEEE80211_HT_PARAM_CHA_SEC_BELOW)\n\t\t\t\tchan_tlv->chan_scan_param[0].radio_type |=\n\t\t\t\t\t(IEEE80211_HT_PARAM_CHA_SEC_BELOW << 4);\n\t\t}\n\t\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: TLV Band = %d\\n\",\n\t\t\t    chan_tlv->chan_scan_param[0].radio_type);\n\t\tpos += sizeof(chan_tlv->header) +\n\t\t\tsizeof(struct mwifiex_chan_scan_param_set);\n\t\tcmd_append_size +=\n\t\t\tsizeof(chan_tlv->header) +\n\t\t\tsizeof(struct mwifiex_chan_scan_param_set);\n\t}\n\n\t/* Append vendor specific IE TLV */\n\tcmd_append_size += mwifiex_cmd_append_vsie_tlv(priv,\n\t\t\t\tMWIFIEX_VSIE_MASK_ADHOC, &pos);\n\n\tif (priv->sec_info.wpa_enabled) {\n\t\trsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2(priv, &pos);\n\t\tif (rsn_ie_len == -1)\n\t\t\treturn -1;\n\t\tcmd_append_size += rsn_ie_len;\n\t}\n\n\tif (adapter->adhoc_11n_enabled) {\n\t\t/* Fill HT CAPABILITY */\n\t\tht_cap = (struct mwifiex_ie_types_htcap *) pos;\n\t\tmemset(ht_cap, 0, sizeof(struct mwifiex_ie_types_htcap));\n\t\tht_cap->header.type = cpu_to_le16(WLAN_EID_HT_CAPABILITY);\n\t\tht_cap->header.len =\n\t\t       cpu_to_le16(sizeof(struct ieee80211_ht_cap));\n\t\tradio_type = mwifiex_band_to_radio_type(\n\t\t\t\t\tpriv->adapter->config_bands);\n\t\tmwifiex_fill_cap_info(priv, radio_type, &ht_cap->ht_cap);\n\n\t\tif (adapter->sec_chan_offset ==\n\t\t\t\t\tIEEE80211_HT_PARAM_CHA_SEC_NONE) {\n\t\t\tu16 tmp_ht_cap;\n\n\t\t\ttmp_ht_cap = le16_to_cpu(ht_cap->ht_cap.cap_info);\n\t\t\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\t\t\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SGI_40;\n\t\t\tht_cap->ht_cap.cap_info = cpu_to_le16(tmp_ht_cap);\n\t\t}\n\n\t\tpos += sizeof(struct mwifiex_ie_types_htcap);\n\t\tcmd_append_size += sizeof(struct mwifiex_ie_types_htcap);\n\n\t\t/* Fill HT INFORMATION */\n\t\tht_info = (struct mwifiex_ie_types_htinfo *) pos;\n\t\tmemset(ht_info, 0, sizeof(struct mwifiex_ie_types_htinfo));\n\t\tht_info->header.type = cpu_to_le16(WLAN_EID_HT_OPERATION);\n\t\tht_info->header.len =\n\t\t\tcpu_to_le16(sizeof(struct ieee80211_ht_operation));\n\n\t\tht_info->ht_oper.primary_chan =\n\t\t\t(u8) priv->curr_bss_params.bss_descriptor.channel;\n\t\tif (adapter->sec_chan_offset) {\n\t\t\tht_info->ht_oper.ht_param = adapter->sec_chan_offset;\n\t\t\tht_info->ht_oper.ht_param |=\n\t\t\t\t\tIEEE80211_HT_PARAM_CHAN_WIDTH_ANY;\n\t\t}\n\t\tht_info->ht_oper.operation_mode =\n\t\t     cpu_to_le16(IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);\n\t\tht_info->ht_oper.basic_set[0] = 0xff;\n\t\tpos += sizeof(struct mwifiex_ie_types_htinfo);\n\t\tcmd_append_size +=\n\t\t\t\tsizeof(struct mwifiex_ie_types_htinfo);\n\t}\n\n\tcmd->size =\n\t\tcpu_to_le16((u16)(sizeof(struct host_cmd_ds_802_11_ad_hoc_start)\n\t\t\t\t  + S_DS_GEN + cmd_append_size));\n\n\tif (adapter->adhoc_start_band == BAND_B)\n\t\ttmp_cap &= ~WLAN_CAPABILITY_SHORT_SLOT_TIME;\n\telse\n\t\ttmp_cap |= WLAN_CAPABILITY_SHORT_SLOT_TIME;\n\n\tadhoc_start->cap_info_bitmap = cpu_to_le16(tmp_cap);\n\n\treturn 0;\n}\n\n/*\n * This function prepares command for ad-hoc join.\n *\n * Most of the parameters are set up by copying from the target BSS descriptor\n * from the scan response.\n *\n * In addition, the following TLVs are added -\n *      - Channel TLV\n *      - Vendor specific IE\n *      - WPA/WPA2 IE\n *      - 11n IE\n *\n * Preparation also includes -\n *      - Setting command ID and proper size\n *      - Ensuring correct endian-ness\n */\nint\nmwifiex_cmd_802_11_ad_hoc_join(struct mwifiex_private *priv,\n\t\t\t       struct host_cmd_ds_command *cmd,\n\t\t\t       struct mwifiex_bssdescriptor *bss_desc)\n{\n\tint rsn_ie_len = 0;\n\tstruct host_cmd_ds_802_11_ad_hoc_join *adhoc_join =\n\t\t&cmd->params.adhoc_join;\n\tstruct mwifiex_ie_types_chan_list_param_set *chan_tlv;\n\tu32 cmd_append_size = 0;\n\tu16 tmp_cap;\n\tu32 i, rates_size = 0;\n\tu16 curr_pkt_filter;\n\tu8 *pos =\n\t\t(u8 *) adhoc_join +\n\t\tsizeof(struct host_cmd_ds_802_11_ad_hoc_join);\n\n/* Use G protection */\n#define USE_G_PROTECTION        0x02\n\tif (bss_desc->erp_flags & USE_G_PROTECTION) {\n\t\tcurr_pkt_filter =\n\t\t\tpriv->\n\t\t\tcurr_pkt_filter | HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON;\n\n\t\tif (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\n\t\t\t\t     HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t     &curr_pkt_filter, false)) {\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"ADHOC_J_CMD: G Protection config failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tpriv->attempted_bss_desc = bss_desc;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_JOIN);\n\n\tadhoc_join->bss_descriptor.bss_mode = HostCmd_BSS_MODE_IBSS;\n\n\tadhoc_join->bss_descriptor.beacon_period\n\t\t= cpu_to_le16(bss_desc->beacon_period);\n\n\tmemcpy(&adhoc_join->bss_descriptor.bssid,\n\t       &bss_desc->mac_address, ETH_ALEN);\n\n\tmemcpy(&adhoc_join->bss_descriptor.ssid,\n\t       &bss_desc->ssid.ssid, bss_desc->ssid.ssid_len);\n\n\tmemcpy(&adhoc_join->bss_descriptor.phy_param_set,\n\t       &bss_desc->phy_param_set,\n\t       sizeof(union ieee_types_phy_param_set));\n\n\tmemcpy(&adhoc_join->bss_descriptor.ss_param_set,\n\t       &bss_desc->ss_param_set, sizeof(union ieee_types_ss_param_set));\n\n\ttmp_cap = bss_desc->cap_info_bitmap;\n\n\ttmp_cap &= CAPINFO_MASK;\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: ADHOC_J_CMD: tmp_cap=%4X CAPINFO_MASK=%4lX\\n\",\n\t\t    tmp_cap, CAPINFO_MASK);\n\n\t/* Information on BSSID descriptor passed to FW */\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: ADHOC_J_CMD: BSSID=%pM, SSID='%s'\\n\",\n\t\t    adhoc_join->bss_descriptor.bssid,\n\t\t    adhoc_join->bss_descriptor.ssid);\n\n\tfor (i = 0; i < MWIFIEX_SUPPORTED_RATES &&\n\t\t    bss_desc->supported_rates[i]; i++)\n\t\t;\n\trates_size = i;\n\n\t/* Copy Data Rates from the Rates recorded in scan response */\n\tmemset(adhoc_join->bss_descriptor.data_rates, 0,\n\t       sizeof(adhoc_join->bss_descriptor.data_rates));\n\tmemcpy(adhoc_join->bss_descriptor.data_rates,\n\t       bss_desc->supported_rates, rates_size);\n\n\t/* Copy the adhoc join rates into Current BSS state structure */\n\tpriv->curr_bss_params.num_of_rates = rates_size;\n\tmemcpy(&priv->curr_bss_params.data_rates, bss_desc->supported_rates,\n\t       rates_size);\n\n\t/* Copy the channel information */\n\tpriv->curr_bss_params.bss_descriptor.channel = bss_desc->channel;\n\tpriv->curr_bss_params.band = (u8) bss_desc->bss_band;\n\n\tif (priv->sec_info.wep_enabled || priv->sec_info.wpa_enabled)\n\t\ttmp_cap |= WLAN_CAPABILITY_PRIVACY;\n\n\tif (IS_SUPPORT_MULTI_BANDS(priv->adapter)) {\n\t\t/* Append a channel TLV */\n\t\tchan_tlv = (struct mwifiex_ie_types_chan_list_param_set *) pos;\n\t\tchan_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\n\t\tchan_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(struct mwifiex_chan_scan_param_set));\n\n\t\tmemset(chan_tlv->chan_scan_param, 0x00,\n\t\t       sizeof(struct mwifiex_chan_scan_param_set));\n\t\tchan_tlv->chan_scan_param[0].chan_number =\n\t\t\t(bss_desc->phy_param_set.ds_param_set.current_chan);\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: ADHOC_J_CMD: TLV Chan=%d\\n\",\n\t\t\t    chan_tlv->chan_scan_param[0].chan_number);\n\n\t\tchan_tlv->chan_scan_param[0].radio_type =\n\t\t\tmwifiex_band_to_radio_type((u8) bss_desc->bss_band);\n\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: ADHOC_J_CMD: TLV Band=%d\\n\",\n\t\t\t    chan_tlv->chan_scan_param[0].radio_type);\n\t\tpos += sizeof(chan_tlv->header) +\n\t\t\t\tsizeof(struct mwifiex_chan_scan_param_set);\n\t\tcmd_append_size += sizeof(chan_tlv->header) +\n\t\t\t\tsizeof(struct mwifiex_chan_scan_param_set);\n\t}\n\n\tif (priv->sec_info.wpa_enabled)\n\t\trsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2(priv, &pos);\n\tif (rsn_ie_len == -1)\n\t\treturn -1;\n\tcmd_append_size += rsn_ie_len;\n\n\tif (ISSUPP_11NENABLED(priv->adapter->fw_cap_info))\n\t\tcmd_append_size += mwifiex_cmd_append_11n_tlv(priv,\n\t\t\tbss_desc, &pos);\n\n\t/* Append vendor specific IE TLV */\n\tcmd_append_size += mwifiex_cmd_append_vsie_tlv(priv,\n\t\t\tMWIFIEX_VSIE_MASK_ADHOC, &pos);\n\n\tcmd->size = cpu_to_le16\n\t\t((u16) (sizeof(struct host_cmd_ds_802_11_ad_hoc_join)\n\t\t\t+ S_DS_GEN + cmd_append_size));\n\n\tadhoc_join->bss_descriptor.cap_info_bitmap = cpu_to_le16(tmp_cap);\n\n\treturn 0;\n}\n\n/*\n * This function handles the command response of ad-hoc start and\n * ad-hoc join.\n *\n * The function generates a device-connected event to notify\n * the applications, in case of successful ad-hoc start/join, and\n * saves the beacon buffer.\n */\nint mwifiex_ret_802_11_ad_hoc(struct mwifiex_private *priv,\n\t\t\t      struct host_cmd_ds_command *resp)\n{\n\tint ret = 0;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct host_cmd_ds_802_11_ad_hoc_start_result *start_result =\n\t\t\t\t&resp->params.start_result;\n\tstruct host_cmd_ds_802_11_ad_hoc_join_result *join_result =\n\t\t\t\t&resp->params.join_result;\n\tstruct mwifiex_bssdescriptor *bss_desc;\n\tu16 cmd = le16_to_cpu(resp->command);\n\tu8 result;\n\n\tif (!priv->attempted_bss_desc) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"ADHOC_RESP: failed, association terminated by host\\n\");\n\t\tgoto done;\n\t}\n\n\tif (cmd == HostCmd_CMD_802_11_AD_HOC_START)\n\t\tresult = start_result->result;\n\telse\n\t\tresult = join_result->result;\n\n\tbss_desc = priv->attempted_bss_desc;\n\n\t/* Join result code 0 --> SUCCESS */\n\tif (result) {\n\t\tmwifiex_dbg(priv->adapter, ERROR, \"ADHOC_RESP: failed\\n\");\n\t\tif (priv->media_connected)\n\t\t\tmwifiex_reset_connect_state(priv, result, true);\n\n\t\tmemset(&priv->curr_bss_params.bss_descriptor,\n\t\t       0x00, sizeof(struct mwifiex_bssdescriptor));\n\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\n\t/* Send a Media Connected event, according to the Spec */\n\tpriv->media_connected = true;\n\n\tif (le16_to_cpu(resp->command) == HostCmd_CMD_802_11_AD_HOC_START) {\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: ADHOC_S_RESP %s\\n\",\n\t\t\t    bss_desc->ssid.ssid);\n\n\t\t/* Update the created network descriptor with the new BSSID */\n\t\tmemcpy(bss_desc->mac_address,\n\t\t       start_result->bssid, ETH_ALEN);\n\n\t\tpriv->adhoc_state = ADHOC_STARTED;\n\t} else {\n\t\t/*\n\t\t * Now the join cmd should be successful.\n\t\t * If BSSID has changed use SSID to compare instead of BSSID\n\t\t */\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: ADHOC_J_RESP %s\\n\",\n\t\t\t    bss_desc->ssid.ssid);\n\n\t\t/*\n\t\t * Make a copy of current BSSID descriptor, only needed for\n\t\t * join since the current descriptor is already being used\n\t\t * for adhoc start\n\t\t */\n\t\tmemcpy(&priv->curr_bss_params.bss_descriptor,\n\t\t       bss_desc, sizeof(struct mwifiex_bssdescriptor));\n\n\t\tpriv->adhoc_state = ADHOC_JOINED;\n\t}\n\n\tmwifiex_dbg(priv->adapter, INFO, \"info: ADHOC_RESP: channel = %d\\n\",\n\t\t    priv->adhoc_channel);\n\tmwifiex_dbg(priv->adapter, INFO, \"info: ADHOC_RESP: BSSID = %pM\\n\",\n\t\t    priv->curr_bss_params.bss_descriptor.mac_address);\n\n\tif (!netif_carrier_ok(priv->netdev))\n\t\tnetif_carrier_on(priv->netdev);\n\tmwifiex_wake_up_net_dev_queue(priv->netdev, adapter);\n\n\tmwifiex_save_curr_bcn(priv);\n\ndone:\n\t/* Need to indicate IOCTL complete */\n\tif (adapter->curr_cmd->wait_q_enabled) {\n\t\tif (ret)\n\t\t\tadapter->cmd_wait_q.status = -1;\n\t\telse\n\t\t\tadapter->cmd_wait_q.status = 0;\n\n\t}\n\n\treturn ret;\n}\n\n/*\n * This function associates to a specific BSS discovered in a scan.\n *\n * It clears any past association response stored for application\n * retrieval and calls the command preparation routine to send the\n * command to firmware.\n */\nint mwifiex_associate(struct mwifiex_private *priv,\n\t\t      struct mwifiex_bssdescriptor *bss_desc)\n{\n\t/* Return error if the adapter is not STA role or table entry\n\t * is not marked as infra.\n\t */\n\tif ((GET_BSS_ROLE(priv) != MWIFIEX_BSS_ROLE_STA) ||\n\t    (bss_desc->bss_mode != NL80211_IFTYPE_STATION))\n\t\treturn -1;\n\n\tif (ISSUPP_11ACENABLED(priv->adapter->fw_cap_info) &&\n\t    !bss_desc->disable_11n && !bss_desc->disable_11ac &&\n\t    priv->adapter->config_bands & BAND_AAC)\n\t\tmwifiex_set_11ac_ba_params(priv);\n\telse\n\t\tmwifiex_set_ba_params(priv);\n\n\t/* Clear any past association response stored for application\n\t   retrieval */\n\tpriv->assoc_rsp_size = 0;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_ASSOCIATE,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, bss_desc, true);\n}\n\n/*\n * This function starts an ad-hoc network.\n *\n * It calls the command preparation routine to send the command to firmware.\n */\nint\nmwifiex_adhoc_start(struct mwifiex_private *priv,\n\t\t    struct cfg80211_ssid *adhoc_ssid)\n{\n\tmwifiex_dbg(priv->adapter, INFO, \"info: Adhoc Channel = %d\\n\",\n\t\t    priv->adhoc_channel);\n\tmwifiex_dbg(priv->adapter, INFO, \"info: curr_bss_params.channel = %d\\n\",\n\t\t    priv->curr_bss_params.bss_descriptor.channel);\n\tmwifiex_dbg(priv->adapter, INFO, \"info: curr_bss_params.band = %d\\n\",\n\t\t    priv->curr_bss_params.band);\n\n\tif (ISSUPP_11ACENABLED(priv->adapter->fw_cap_info) &&\n\t    priv->adapter->config_bands & BAND_AAC)\n\t\tmwifiex_set_11ac_ba_params(priv);\n\telse\n\t\tmwifiex_set_ba_params(priv);\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_AD_HOC_START,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, adhoc_ssid, true);\n}\n\n/*\n * This function joins an ad-hoc network found in a previous scan.\n *\n * It calls the command preparation routine to send the command to firmware,\n * if already not connected to the requested SSID.\n */\nint mwifiex_adhoc_join(struct mwifiex_private *priv,\n\t\t       struct mwifiex_bssdescriptor *bss_desc)\n{\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: adhoc join: curr_bss ssid =%s\\n\",\n\t\t    priv->curr_bss_params.bss_descriptor.ssid.ssid);\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: adhoc join: curr_bss ssid_len =%u\\n\",\n\t\t    priv->curr_bss_params.bss_descriptor.ssid.ssid_len);\n\tmwifiex_dbg(priv->adapter, INFO, \"info: adhoc join: ssid =%s\\n\",\n\t\t    bss_desc->ssid.ssid);\n\tmwifiex_dbg(priv->adapter, INFO, \"info: adhoc join: ssid_len =%u\\n\",\n\t\t    bss_desc->ssid.ssid_len);\n\n\t/* Check if the requested SSID is already joined */\n\tif (priv->curr_bss_params.bss_descriptor.ssid.ssid_len &&\n\t    !mwifiex_ssid_cmp(&bss_desc->ssid,\n\t\t\t      &priv->curr_bss_params.bss_descriptor.ssid) &&\n\t    (priv->curr_bss_params.bss_descriptor.bss_mode ==\n\t\t\t\t\t\t\tNL80211_IFTYPE_ADHOC)) {\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: ADHOC_J_CMD: new ad-hoc SSID\\t\"\n\t\t\t    \"is the same as current; not attempting to re-join\\n\");\n\t\treturn -1;\n\t}\n\n\tif (ISSUPP_11ACENABLED(priv->adapter->fw_cap_info) &&\n\t    !bss_desc->disable_11n && !bss_desc->disable_11ac &&\n\t    priv->adapter->config_bands & BAND_AAC)\n\t\tmwifiex_set_11ac_ba_params(priv);\n\telse\n\t\tmwifiex_set_ba_params(priv);\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: curr_bss_params.channel = %d\\n\",\n\t\t    priv->curr_bss_params.bss_descriptor.channel);\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: curr_bss_params.band = %c\\n\",\n\t\t    priv->curr_bss_params.band);\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_AD_HOC_JOIN,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, bss_desc, true);\n}\n\n/*\n * This function deauthenticates/disconnects from infra network by sending\n * deauthentication request.\n */\nstatic int mwifiex_deauthenticate_infra(struct mwifiex_private *priv, u8 *mac)\n{\n\tu8 mac_address[ETH_ALEN];\n\tint ret;\n\n\tif (!mac || is_zero_ether_addr(mac))\n\t\tmemcpy(mac_address,\n\t\t       priv->curr_bss_params.bss_descriptor.mac_address,\n\t\t       ETH_ALEN);\n\telse\n\t\tmemcpy(mac_address, mac, ETH_ALEN);\n\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_DEAUTHENTICATE,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, mac_address, true);\n\n\treturn ret;\n}\n\n/*\n * This function deauthenticates/disconnects from a BSS.\n *\n * In case of infra made, it sends deauthentication request, and\n * in case of ad-hoc mode, a stop network request is sent to the firmware.\n * In AP mode, a command to stop bss is sent to firmware.\n */\nint mwifiex_deauthenticate(struct mwifiex_private *priv, u8 *mac)\n{\n\tint ret = 0;\n\n\tif (!priv->media_connected)\n\t\treturn 0;\n\n\tswitch (priv->bss_mode) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tret = mwifiex_deauthenticate_infra(priv, mac);\n\t\tif (ret)\n\t\t\tcfg80211_disconnected(priv->netdev, 0, NULL, 0,\n\t\t\t\t\t      true, GFP_KERNEL);\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_AD_HOC_STOP,\n\t\t\t\t\tHostCmd_ACT_GEN_SET, 0, NULL, true);\n\tcase NL80211_IFTYPE_AP:\n\t\treturn mwifiex_send_cmd(priv, HostCmd_CMD_UAP_BSS_STOP,\n\t\t\t\t\tHostCmd_ACT_GEN_SET, 0, NULL, true);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n/* This function deauthenticates/disconnects from all BSS. */\nvoid mwifiex_deauthenticate_all(struct mwifiex_adapter *adapter)\n{\n\tstruct mwifiex_private *priv;\n\tint i;\n\n\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\tpriv = adapter->priv[i];\n\t\tif (priv)\n\t\t\tmwifiex_deauthenticate(priv, NULL);\n\t}\n}\nEXPORT_SYMBOL_GPL(mwifiex_deauthenticate_all);\n\n/*\n * This function converts band to radio type used in channel TLV.\n */\nu8\nmwifiex_band_to_radio_type(u8 band)\n{\n\tswitch (band) {\n\tcase BAND_A:\n\tcase BAND_AN:\n\tcase BAND_A | BAND_AN:\n\tcase BAND_A | BAND_AN | BAND_AAC:\n\t\treturn HostCmd_SCAN_RADIO_TYPE_A;\n\tcase BAND_B:\n\tcase BAND_G:\n\tcase BAND_B | BAND_G:\n\tdefault:\n\t\treturn HostCmd_SCAN_RADIO_TYPE_BG;\n\t}\n}\n"], "fixing_code": ["/*\n * NXP Wireless LAN device driver: association and ad-hoc start/join\n *\n * Copyright 2011-2020 NXP\n *\n * This software file (the \"File\") is distributed by NXP\n * under the terms of the GNU General Public License Version 2, June 1991\n * (the \"License\").  You may use, redistribute and/or modify this File in\n * accordance with the terms and conditions of the License, a copy of which\n * is available by writing to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the\n * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n *\n * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE\n * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about\n * this warranty disclaimer.\n */\n\n#include \"decl.h\"\n#include \"ioctl.h\"\n#include \"util.h\"\n#include \"fw.h\"\n#include \"main.h\"\n#include \"wmm.h\"\n#include \"11n.h\"\n#include \"11ac.h\"\n\n#define CAPINFO_MASK    (~(BIT(15) | BIT(14) | BIT(12) | BIT(11) | BIT(9)))\n\n/*\n * Append a generic IE as a pass through TLV to a TLV buffer.\n *\n * This function is called from the network join command preparation routine.\n *\n * If the IE buffer has been setup by the application, this routine appends\n * the buffer as a pass through TLV type to the request.\n */\nstatic int\nmwifiex_cmd_append_generic_ie(struct mwifiex_private *priv, u8 **buffer)\n{\n\tint ret_len = 0;\n\tstruct mwifiex_ie_types_header ie_header;\n\n\t/* Null Checks */\n\tif (!buffer)\n\t\treturn 0;\n\tif (!(*buffer))\n\t\treturn 0;\n\n\t/*\n\t * If there is a generic ie buffer setup, append it to the return\n\t *   parameter buffer pointer.\n\t */\n\tif (priv->gen_ie_buf_len) {\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: %s: append generic ie len %d to %p\\n\",\n\t\t\t    __func__, priv->gen_ie_buf_len, *buffer);\n\n\t\t/* Wrap the generic IE buffer with a pass through TLV type */\n\t\tie_header.type = cpu_to_le16(TLV_TYPE_PASSTHROUGH);\n\t\tie_header.len = cpu_to_le16(priv->gen_ie_buf_len);\n\t\tmemcpy(*buffer, &ie_header, sizeof(ie_header));\n\n\t\t/* Increment the return size and the return buffer pointer\n\t\t   param */\n\t\t*buffer += sizeof(ie_header);\n\t\tret_len += sizeof(ie_header);\n\n\t\t/* Copy the generic IE buffer to the output buffer, advance\n\t\t   pointer */\n\t\tmemcpy(*buffer, priv->gen_ie_buf, priv->gen_ie_buf_len);\n\n\t\t/* Increment the return size and the return buffer pointer\n\t\t   param */\n\t\t*buffer += priv->gen_ie_buf_len;\n\t\tret_len += priv->gen_ie_buf_len;\n\n\t\t/* Reset the generic IE buffer */\n\t\tpriv->gen_ie_buf_len = 0;\n\t}\n\n\t/* return the length appended to the buffer */\n\treturn ret_len;\n}\n\n/*\n * Append TSF tracking info from the scan table for the target AP.\n *\n * This function is called from the network join command preparation routine.\n *\n * The TSF table TSF sent to the firmware contains two TSF values:\n *      - The TSF of the target AP from its previous beacon/probe response\n *      - The TSF timestamp of our local MAC at the time we observed the\n *        beacon/probe response.\n *\n * The firmware uses the timestamp values to set an initial TSF value\n * in the MAC for the new association after a reassociation attempt.\n */\nstatic int\nmwifiex_cmd_append_tsf_tlv(struct mwifiex_private *priv, u8 **buffer,\n\t\t\t   struct mwifiex_bssdescriptor *bss_desc)\n{\n\tstruct mwifiex_ie_types_tsf_timestamp tsf_tlv;\n\t__le64 tsf_val;\n\n\t/* Null Checks */\n\tif (buffer == NULL)\n\t\treturn 0;\n\tif (*buffer == NULL)\n\t\treturn 0;\n\n\tmemset(&tsf_tlv, 0x00, sizeof(struct mwifiex_ie_types_tsf_timestamp));\n\n\ttsf_tlv.header.type = cpu_to_le16(TLV_TYPE_TSFTIMESTAMP);\n\ttsf_tlv.header.len = cpu_to_le16(2 * sizeof(tsf_val));\n\n\tmemcpy(*buffer, &tsf_tlv, sizeof(tsf_tlv.header));\n\t*buffer += sizeof(tsf_tlv.header);\n\n\t/* TSF at the time when beacon/probe_response was received */\n\ttsf_val = cpu_to_le64(bss_desc->fw_tsf);\n\tmemcpy(*buffer, &tsf_val, sizeof(tsf_val));\n\t*buffer += sizeof(tsf_val);\n\n\ttsf_val = cpu_to_le64(bss_desc->timestamp);\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: %s: TSF offset calc: %016llx - %016llx\\n\",\n\t\t    __func__, bss_desc->timestamp, bss_desc->fw_tsf);\n\n\tmemcpy(*buffer, &tsf_val, sizeof(tsf_val));\n\t*buffer += sizeof(tsf_val);\n\n\treturn sizeof(tsf_tlv.header) + (2 * sizeof(tsf_val));\n}\n\n/*\n * This function finds out the common rates between rate1 and rate2.\n *\n * It will fill common rates in rate1 as output if found.\n *\n * NOTE: Setting the MSB of the basic rates needs to be taken\n * care of, either before or after calling this function.\n */\nstatic int mwifiex_get_common_rates(struct mwifiex_private *priv, u8 *rate1,\n\t\t\t\t    u32 rate1_size, u8 *rate2, u32 rate2_size)\n{\n\tint ret;\n\tu8 *ptr = rate1, *tmp;\n\tu32 i, j;\n\n\ttmp = kmemdup(rate1, rate1_size, GFP_KERNEL);\n\tif (!tmp) {\n\t\tmwifiex_dbg(priv->adapter, ERROR, \"failed to alloc tmp buf\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(rate1, 0, rate1_size);\n\n\tfor (i = 0; i < rate2_size && rate2[i]; i++) {\n\t\tfor (j = 0; j < rate1_size && tmp[j]; j++) {\n\t\t\t/* Check common rate, excluding the bit for\n\t\t\t   basic rate */\n\t\t\tif ((rate2[i] & 0x7F) == (tmp[j] & 0x7F)) {\n\t\t\t\t*rate1++ = tmp[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tmwifiex_dbg(priv->adapter, INFO, \"info: Tx data rate set to %#x\\n\",\n\t\t    priv->data_rate);\n\n\tif (!priv->is_data_rate_auto) {\n\t\twhile (*ptr) {\n\t\t\tif ((*ptr & 0x7f) == priv->data_rate) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tptr++;\n\t\t}\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"previously set fixed data rate %#x\\t\"\n\t\t\t    \"is not compatible with the network\\n\",\n\t\t\t    priv->data_rate);\n\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\n\tret = 0;\ndone:\n\tkfree(tmp);\n\treturn ret;\n}\n\n/*\n * This function creates the intersection of the rates supported by a\n * target BSS and our adapter settings for use in an assoc/join command.\n */\nstatic int\nmwifiex_setup_rates_from_bssdesc(struct mwifiex_private *priv,\n\t\t\t\t struct mwifiex_bssdescriptor *bss_desc,\n\t\t\t\t u8 *out_rates, u32 *out_rates_size)\n{\n\tu8 card_rates[MWIFIEX_SUPPORTED_RATES];\n\tu32 card_rates_size;\n\n\t/* Copy AP supported rates */\n\tmemcpy(out_rates, bss_desc->supported_rates, MWIFIEX_SUPPORTED_RATES);\n\t/* Get the STA supported rates */\n\tcard_rates_size = mwifiex_get_active_data_rates(priv, card_rates);\n\t/* Get the common rates between AP and STA supported rates */\n\tif (mwifiex_get_common_rates(priv, out_rates, MWIFIEX_SUPPORTED_RATES,\n\t\t\t\t     card_rates, card_rates_size)) {\n\t\t*out_rates_size = 0;\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"%s: cannot get common rates\\n\",\n\t\t\t    __func__);\n\t\treturn -1;\n\t}\n\n\t*out_rates_size =\n\t\tmin_t(size_t, strlen(out_rates), MWIFIEX_SUPPORTED_RATES);\n\n\treturn 0;\n}\n\n/*\n * This function appends a WPS IE. It is called from the network join command\n * preparation routine.\n *\n * If the IE buffer has been setup by the application, this routine appends\n * the buffer as a WPS TLV type to the request.\n */\nstatic int\nmwifiex_cmd_append_wps_ie(struct mwifiex_private *priv, u8 **buffer)\n{\n\tint retLen = 0;\n\tstruct mwifiex_ie_types_header ie_header;\n\n\tif (!buffer || !*buffer)\n\t\treturn 0;\n\n\t/*\n\t * If there is a wps ie buffer setup, append it to the return\n\t * parameter buffer pointer.\n\t */\n\tif (priv->wps_ie_len) {\n\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t    \"cmd: append wps ie %d to %p\\n\",\n\t\t\t    priv->wps_ie_len, *buffer);\n\n\t\t/* Wrap the generic IE buffer with a pass through TLV type */\n\t\tie_header.type = cpu_to_le16(TLV_TYPE_PASSTHROUGH);\n\t\tie_header.len = cpu_to_le16(priv->wps_ie_len);\n\t\tmemcpy(*buffer, &ie_header, sizeof(ie_header));\n\t\t*buffer += sizeof(ie_header);\n\t\tretLen += sizeof(ie_header);\n\n\t\tmemcpy(*buffer, priv->wps_ie, priv->wps_ie_len);\n\t\t*buffer += priv->wps_ie_len;\n\t\tretLen += priv->wps_ie_len;\n\n\t}\n\n\tkfree(priv->wps_ie);\n\tpriv->wps_ie_len = 0;\n\treturn retLen;\n}\n\n/*\n * This function appends a WAPI IE.\n *\n * This function is called from the network join command preparation routine.\n *\n * If the IE buffer has been setup by the application, this routine appends\n * the buffer as a WAPI TLV type to the request.\n */\nstatic int\nmwifiex_cmd_append_wapi_ie(struct mwifiex_private *priv, u8 **buffer)\n{\n\tint retLen = 0;\n\tstruct mwifiex_ie_types_header ie_header;\n\n\t/* Null Checks */\n\tif (buffer == NULL)\n\t\treturn 0;\n\tif (*buffer == NULL)\n\t\treturn 0;\n\n\t/*\n\t * If there is a wapi ie buffer setup, append it to the return\n\t *   parameter buffer pointer.\n\t */\n\tif (priv->wapi_ie_len) {\n\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t    \"cmd: append wapi ie %d to %p\\n\",\n\t\t\t    priv->wapi_ie_len, *buffer);\n\n\t\t/* Wrap the generic IE buffer with a pass through TLV type */\n\t\tie_header.type = cpu_to_le16(TLV_TYPE_WAPI_IE);\n\t\tie_header.len = cpu_to_le16(priv->wapi_ie_len);\n\t\tmemcpy(*buffer, &ie_header, sizeof(ie_header));\n\n\t\t/* Increment the return size and the return buffer pointer\n\t\t   param */\n\t\t*buffer += sizeof(ie_header);\n\t\tretLen += sizeof(ie_header);\n\n\t\t/* Copy the wapi IE buffer to the output buffer, advance\n\t\t   pointer */\n\t\tmemcpy(*buffer, priv->wapi_ie, priv->wapi_ie_len);\n\n\t\t/* Increment the return size and the return buffer pointer\n\t\t   param */\n\t\t*buffer += priv->wapi_ie_len;\n\t\tretLen += priv->wapi_ie_len;\n\n\t}\n\t/* return the length appended to the buffer */\n\treturn retLen;\n}\n\n/*\n * This function appends rsn ie tlv for wpa/wpa2 security modes.\n * It is called from the network join command preparation routine.\n */\nstatic int mwifiex_append_rsn_ie_wpa_wpa2(struct mwifiex_private *priv,\n\t\t\t\t\t  u8 **buffer)\n{\n\tstruct mwifiex_ie_types_rsn_param_set *rsn_ie_tlv;\n\tint rsn_ie_len;\n\n\tif (!buffer || !(*buffer))\n\t\treturn 0;\n\n\trsn_ie_tlv = (struct mwifiex_ie_types_rsn_param_set *) (*buffer);\n\trsn_ie_tlv->header.type = cpu_to_le16((u16) priv->wpa_ie[0]);\n\trsn_ie_tlv->header.type = cpu_to_le16(\n\t\t\t\t le16_to_cpu(rsn_ie_tlv->header.type) & 0x00FF);\n\trsn_ie_tlv->header.len = cpu_to_le16((u16) priv->wpa_ie[1]);\n\trsn_ie_tlv->header.len = cpu_to_le16(le16_to_cpu(rsn_ie_tlv->header.len)\n\t\t\t\t\t\t\t & 0x00FF);\n\tif (le16_to_cpu(rsn_ie_tlv->header.len) <= (sizeof(priv->wpa_ie) - 2))\n\t\tmemcpy(rsn_ie_tlv->rsn_ie, &priv->wpa_ie[2],\n\t\t       le16_to_cpu(rsn_ie_tlv->header.len));\n\telse\n\t\treturn -1;\n\n\trsn_ie_len = sizeof(rsn_ie_tlv->header) +\n\t\t\t\t\tle16_to_cpu(rsn_ie_tlv->header.len);\n\t*buffer += rsn_ie_len;\n\n\treturn rsn_ie_len;\n}\n\n/*\n * This function prepares command for association.\n *\n * This sets the following parameters -\n *      - Peer MAC address\n *      - Listen interval\n *      - Beacon interval\n *      - Capability information\n *\n * ...and the following TLVs, as required -\n *      - SSID TLV\n *      - PHY TLV\n *      - SS TLV\n *      - Rates TLV\n *      - Authentication TLV\n *      - Channel TLV\n *      - WPA/WPA2 IE\n *      - 11n TLV\n *      - Vendor specific TLV\n *      - WMM TLV\n *      - WAPI IE\n *      - Generic IE\n *      - TSF TLV\n *\n * Preparation also includes -\n *      - Setting command ID and proper size\n *      - Ensuring correct endian-ness\n */\nint mwifiex_cmd_802_11_associate(struct mwifiex_private *priv,\n\t\t\t\t struct host_cmd_ds_command *cmd,\n\t\t\t\t struct mwifiex_bssdescriptor *bss_desc)\n{\n\tstruct host_cmd_ds_802_11_associate *assoc = &cmd->params.associate;\n\tstruct mwifiex_ie_types_ssid_param_set *ssid_tlv;\n\tstruct mwifiex_ie_types_phy_param_set *phy_tlv;\n\tstruct mwifiex_ie_types_ss_param_set *ss_tlv;\n\tstruct mwifiex_ie_types_rates_param_set *rates_tlv;\n\tstruct mwifiex_ie_types_auth_type *auth_tlv;\n\tstruct mwifiex_ie_types_chan_list_param_set *chan_tlv;\n\tu8 rates[MWIFIEX_SUPPORTED_RATES];\n\tu32 rates_size;\n\tu16 tmp_cap;\n\tu8 *pos;\n\tint rsn_ie_len = 0;\n\n\tpos = (u8 *) assoc;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_ASSOCIATE);\n\n\t/* Save so we know which BSS Desc to use in the response handler */\n\tpriv->attempted_bss_desc = bss_desc;\n\n\tmemcpy(assoc->peer_sta_addr,\n\t       bss_desc->mac_address, sizeof(assoc->peer_sta_addr));\n\tpos += sizeof(assoc->peer_sta_addr);\n\n\t/* Set the listen interval */\n\tassoc->listen_interval = cpu_to_le16(priv->listen_interval);\n\t/* Set the beacon period */\n\tassoc->beacon_period = cpu_to_le16(bss_desc->beacon_period);\n\n\tpos += sizeof(assoc->cap_info_bitmap);\n\tpos += sizeof(assoc->listen_interval);\n\tpos += sizeof(assoc->beacon_period);\n\tpos += sizeof(assoc->dtim_period);\n\n\tssid_tlv = (struct mwifiex_ie_types_ssid_param_set *) pos;\n\tssid_tlv->header.type = cpu_to_le16(WLAN_EID_SSID);\n\tssid_tlv->header.len = cpu_to_le16((u16) bss_desc->ssid.ssid_len);\n\tmemcpy(ssid_tlv->ssid, bss_desc->ssid.ssid,\n\t       le16_to_cpu(ssid_tlv->header.len));\n\tpos += sizeof(ssid_tlv->header) + le16_to_cpu(ssid_tlv->header.len);\n\n\tphy_tlv = (struct mwifiex_ie_types_phy_param_set *) pos;\n\tphy_tlv->header.type = cpu_to_le16(WLAN_EID_DS_PARAMS);\n\tphy_tlv->header.len = cpu_to_le16(sizeof(phy_tlv->fh_ds.ds_param_set));\n\tmemcpy(&phy_tlv->fh_ds.ds_param_set,\n\t       &bss_desc->phy_param_set.ds_param_set.current_chan,\n\t       sizeof(phy_tlv->fh_ds.ds_param_set));\n\tpos += sizeof(phy_tlv->header) + le16_to_cpu(phy_tlv->header.len);\n\n\tss_tlv = (struct mwifiex_ie_types_ss_param_set *) pos;\n\tss_tlv->header.type = cpu_to_le16(WLAN_EID_CF_PARAMS);\n\tss_tlv->header.len = cpu_to_le16(sizeof(ss_tlv->cf_ibss.cf_param_set));\n\tpos += sizeof(ss_tlv->header) + le16_to_cpu(ss_tlv->header.len);\n\n\t/* Get the common rates supported between the driver and the BSS Desc */\n\tif (mwifiex_setup_rates_from_bssdesc\n\t    (priv, bss_desc, rates, &rates_size))\n\t\treturn -1;\n\n\t/* Save the data rates into Current BSS state structure */\n\tpriv->curr_bss_params.num_of_rates = rates_size;\n\tmemcpy(&priv->curr_bss_params.data_rates, rates, rates_size);\n\n\t/* Setup the Rates TLV in the association command */\n\trates_tlv = (struct mwifiex_ie_types_rates_param_set *) pos;\n\trates_tlv->header.type = cpu_to_le16(WLAN_EID_SUPP_RATES);\n\trates_tlv->header.len = cpu_to_le16((u16) rates_size);\n\tmemcpy(rates_tlv->rates, rates, rates_size);\n\tpos += sizeof(rates_tlv->header) + rates_size;\n\tmwifiex_dbg(priv->adapter, INFO, \"info: ASSOC_CMD: rates size = %d\\n\",\n\t\t    rates_size);\n\n\t/* Add the Authentication type to be used for Auth frames */\n\tauth_tlv = (struct mwifiex_ie_types_auth_type *) pos;\n\tauth_tlv->header.type = cpu_to_le16(TLV_TYPE_AUTH_TYPE);\n\tauth_tlv->header.len = cpu_to_le16(sizeof(auth_tlv->auth_type));\n\tif (priv->sec_info.wep_enabled)\n\t\tauth_tlv->auth_type = cpu_to_le16(\n\t\t\t\t(u16) priv->sec_info.authentication_mode);\n\telse\n\t\tauth_tlv->auth_type = cpu_to_le16(NL80211_AUTHTYPE_OPEN_SYSTEM);\n\n\tpos += sizeof(auth_tlv->header) + le16_to_cpu(auth_tlv->header.len);\n\n\tif (IS_SUPPORT_MULTI_BANDS(priv->adapter) &&\n\t    !(ISSUPP_11NENABLED(priv->adapter->fw_cap_info) &&\n\t    (!bss_desc->disable_11n) &&\n\t    (priv->adapter->config_bands & BAND_GN ||\n\t     priv->adapter->config_bands & BAND_AN) &&\n\t    (bss_desc->bcn_ht_cap)\n\t    )\n\t\t) {\n\t\t/* Append a channel TLV for the channel the attempted AP was\n\t\t   found on */\n\t\tchan_tlv = (struct mwifiex_ie_types_chan_list_param_set *) pos;\n\t\tchan_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\n\t\tchan_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(struct mwifiex_chan_scan_param_set));\n\n\t\tmemset(chan_tlv->chan_scan_param, 0x00,\n\t\t       sizeof(struct mwifiex_chan_scan_param_set));\n\t\tchan_tlv->chan_scan_param[0].chan_number =\n\t\t\t(bss_desc->phy_param_set.ds_param_set.current_chan);\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: Assoc: TLV Chan = %d\\n\",\n\t\t\t    chan_tlv->chan_scan_param[0].chan_number);\n\n\t\tchan_tlv->chan_scan_param[0].radio_type =\n\t\t\tmwifiex_band_to_radio_type((u8) bss_desc->bss_band);\n\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: Assoc: TLV Band = %d\\n\",\n\t\t\t    chan_tlv->chan_scan_param[0].radio_type);\n\t\tpos += sizeof(chan_tlv->header) +\n\t\t\tsizeof(struct mwifiex_chan_scan_param_set);\n\t}\n\n\tif (!priv->wps.session_enable) {\n\t\tif (priv->sec_info.wpa_enabled || priv->sec_info.wpa2_enabled)\n\t\t\trsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2(priv, &pos);\n\n\t\tif (rsn_ie_len == -1)\n\t\t\treturn -1;\n\t}\n\n\tif (ISSUPP_11NENABLED(priv->adapter->fw_cap_info) &&\n\t    (!bss_desc->disable_11n) &&\n\t    (priv->adapter->config_bands & BAND_GN ||\n\t     priv->adapter->config_bands & BAND_AN))\n\t\tmwifiex_cmd_append_11n_tlv(priv, bss_desc, &pos);\n\n\tif (ISSUPP_11ACENABLED(priv->adapter->fw_cap_info) &&\n\t    !bss_desc->disable_11n && !bss_desc->disable_11ac &&\n\t    priv->adapter->config_bands & BAND_AAC)\n\t\tmwifiex_cmd_append_11ac_tlv(priv, bss_desc, &pos);\n\n\t/* Append vendor specific IE TLV */\n\tmwifiex_cmd_append_vsie_tlv(priv, MWIFIEX_VSIE_MASK_ASSOC, &pos);\n\n\tmwifiex_wmm_process_association_req(priv, &pos, &bss_desc->wmm_ie,\n\t\t\t\t\t    bss_desc->bcn_ht_cap);\n\tif (priv->sec_info.wapi_enabled && priv->wapi_ie_len)\n\t\tmwifiex_cmd_append_wapi_ie(priv, &pos);\n\n\tif (priv->wps.session_enable && priv->wps_ie_len)\n\t\tmwifiex_cmd_append_wps_ie(priv, &pos);\n\n\tmwifiex_cmd_append_generic_ie(priv, &pos);\n\n\tmwifiex_cmd_append_tsf_tlv(priv, &pos, bss_desc);\n\n\tmwifiex_11h_process_join(priv, &pos, bss_desc);\n\n\tcmd->size = cpu_to_le16((u16) (pos - (u8 *) assoc) + S_DS_GEN);\n\n\t/* Set the Capability info at last */\n\ttmp_cap = bss_desc->cap_info_bitmap;\n\n\tif (priv->adapter->config_bands == BAND_B)\n\t\ttmp_cap &= ~WLAN_CAPABILITY_SHORT_SLOT_TIME;\n\n\ttmp_cap &= CAPINFO_MASK;\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: ASSOC_CMD: tmp_cap=%4X CAPINFO_MASK=%4lX\\n\",\n\t\t    tmp_cap, CAPINFO_MASK);\n\tassoc->cap_info_bitmap = cpu_to_le16(tmp_cap);\n\n\treturn 0;\n}\n\nstatic const char *assoc_failure_reason_to_str(u16 cap_info)\n{\n\tswitch (cap_info) {\n\tcase CONNECT_ERR_AUTH_ERR_STA_FAILURE:\n\t\treturn \"CONNECT_ERR_AUTH_ERR_STA_FAILURE\";\n\tcase CONNECT_ERR_AUTH_MSG_UNHANDLED:\n\t\treturn \"CONNECT_ERR_AUTH_MSG_UNHANDLED\";\n\tcase CONNECT_ERR_ASSOC_ERR_TIMEOUT:\n\t\treturn \"CONNECT_ERR_ASSOC_ERR_TIMEOUT\";\n\tcase CONNECT_ERR_ASSOC_ERR_AUTH_REFUSED:\n\t\treturn \"CONNECT_ERR_ASSOC_ERR_AUTH_REFUSED\";\n\tcase CONNECT_ERR_STA_FAILURE:\n\t\treturn \"CONNECT_ERR_STA_FAILURE\";\n\t}\n\n\treturn \"Unknown connect failure\";\n}\n/*\n * Association firmware command response handler\n *\n * The response buffer for the association command has the following\n * memory layout.\n *\n * For cases where an association response was not received (indicated\n * by the CapInfo and AId field):\n *\n *     .------------------------------------------------------------.\n *     |  Header(4 * sizeof(t_u16)):  Standard command response hdr |\n *     .------------------------------------------------------------.\n *     |  cap_info/Error Return(t_u16):                             |\n *     |           0xFFFF(-1): Internal error                       |\n *     |           0xFFFE(-2): Authentication unhandled message     |\n *     |           0xFFFD(-3): Authentication refused               |\n *     |           0xFFFC(-4): Timeout waiting for AP response      |\n *     .------------------------------------------------------------.\n *     |  status_code(t_u16):                                       |\n *     |        If cap_info is -1:                                  |\n *     |           An internal firmware failure prevented the       |\n *     |           command from being processed.  The status_code   |\n *     |           will be set to 1.                                |\n *     |                                                            |\n *     |        If cap_info is -2:                                  |\n *     |           An authentication frame was received but was     |\n *     |           not handled by the firmware.  IEEE Status        |\n *     |           code for the failure is returned.                |\n *     |                                                            |\n *     |        If cap_info is -3:                                  |\n *     |           An authentication frame was received and the     |\n *     |           status_code is the IEEE Status reported in the   |\n *     |           response.                                        |\n *     |                                                            |\n *     |        If cap_info is -4:                                  |\n *     |           (1) Association response timeout                 |\n *     |           (2) Authentication response timeout              |\n *     .------------------------------------------------------------.\n *     |  a_id(t_u16): 0xFFFF                                       |\n *     .------------------------------------------------------------.\n *\n *\n * For cases where an association response was received, the IEEE\n * standard association response frame is returned:\n *\n *     .------------------------------------------------------------.\n *     |  Header(4 * sizeof(t_u16)):  Standard command response hdr |\n *     .------------------------------------------------------------.\n *     |  cap_info(t_u16): IEEE Capability                          |\n *     .------------------------------------------------------------.\n *     |  status_code(t_u16): IEEE Status Code                      |\n *     .------------------------------------------------------------.\n *     |  a_id(t_u16): IEEE Association ID                          |\n *     .------------------------------------------------------------.\n *     |  IEEE IEs(variable): Any received IEs comprising the       |\n *     |                      remaining portion of a received       |\n *     |                      association response frame.           |\n *     .------------------------------------------------------------.\n *\n * For simplistic handling, the status_code field can be used to determine\n * an association success (0) or failure (non-zero).\n */\nint mwifiex_ret_802_11_associate(struct mwifiex_private *priv,\n\t\t\t     struct host_cmd_ds_command *resp)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tint ret = 0;\n\tstruct ieee_types_assoc_rsp *assoc_rsp;\n\tstruct mwifiex_bssdescriptor *bss_desc;\n\tbool enable_data = true;\n\tu16 cap_info, status_code, aid;\n\tconst u8 *ie_ptr;\n\tstruct ieee80211_ht_operation *assoc_resp_ht_oper;\n\n\tif (!priv->attempted_bss_desc) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"ASSOC_RESP: failed, association terminated by host\\n\");\n\t\tgoto done;\n\t}\n\n\tassoc_rsp = (struct ieee_types_assoc_rsp *) &resp->params;\n\n\tcap_info = le16_to_cpu(assoc_rsp->cap_info_bitmap);\n\tstatus_code = le16_to_cpu(assoc_rsp->status_code);\n\taid = le16_to_cpu(assoc_rsp->a_id);\n\n\tif ((aid & (BIT(15) | BIT(14))) != (BIT(15) | BIT(14)))\n\t\tdev_err(priv->adapter->dev,\n\t\t\t\"invalid AID value 0x%x; bits 15:14 not set\\n\",\n\t\t\taid);\n\n\taid &= ~(BIT(15) | BIT(14));\n\n\tpriv->assoc_rsp_size = min(le16_to_cpu(resp->size) - S_DS_GEN,\n\t\t\t\t   sizeof(priv->assoc_rsp_buf));\n\n\tassoc_rsp->a_id = cpu_to_le16(aid);\n\tmemcpy(priv->assoc_rsp_buf, &resp->params, priv->assoc_rsp_size);\n\n\tif (status_code) {\n\t\tpriv->adapter->dbg.num_cmd_assoc_failure++;\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"ASSOC_RESP: failed,\\t\"\n\t\t\t    \"status code=%d err=%#x a_id=%#x\\n\",\n\t\t\t    status_code, cap_info,\n\t\t\t    le16_to_cpu(assoc_rsp->a_id));\n\n\t\tmwifiex_dbg(priv->adapter, ERROR, \"assoc failure: reason %s\\n\",\n\t\t\t    assoc_failure_reason_to_str(cap_info));\n\t\tif (cap_info == CONNECT_ERR_ASSOC_ERR_TIMEOUT) {\n\t\t\tif (status_code == MWIFIEX_ASSOC_CMD_FAILURE_AUTH) {\n\t\t\t\tret = WLAN_STATUS_AUTH_TIMEOUT;\n\t\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t\t    \"ASSOC_RESP: AUTH timeout\\n\");\n\t\t\t} else {\n\t\t\t\tret = WLAN_STATUS_UNSPECIFIED_FAILURE;\n\t\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t\t    \"ASSOC_RESP: UNSPECIFIED failure\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tret = status_code;\n\t\t}\n\n\t\tgoto done;\n\t}\n\n\t/* Send a Media Connected event, according to the Spec */\n\tpriv->media_connected = true;\n\n\tpriv->adapter->ps_state = PS_STATE_AWAKE;\n\tpriv->adapter->pps_uapsd_mode = false;\n\tpriv->adapter->tx_lock_flag = false;\n\n\t/* Set the attempted BSSID Index to current */\n\tbss_desc = priv->attempted_bss_desc;\n\n\tmwifiex_dbg(priv->adapter, INFO, \"info: ASSOC_RESP: %s\\n\",\n\t\t    bss_desc->ssid.ssid);\n\n\t/* Make a copy of current BSSID descriptor */\n\tmemcpy(&priv->curr_bss_params.bss_descriptor,\n\t       bss_desc, sizeof(struct mwifiex_bssdescriptor));\n\n\t/* Update curr_bss_params */\n\tpriv->curr_bss_params.bss_descriptor.channel\n\t\t= bss_desc->phy_param_set.ds_param_set.current_chan;\n\n\tpriv->curr_bss_params.band = (u8) bss_desc->bss_band;\n\n\tif (bss_desc->wmm_ie.vend_hdr.element_id == WLAN_EID_VENDOR_SPECIFIC)\n\t\tpriv->curr_bss_params.wmm_enabled = true;\n\telse\n\t\tpriv->curr_bss_params.wmm_enabled = false;\n\n\tif ((priv->wmm_required || bss_desc->bcn_ht_cap) &&\n\t    priv->curr_bss_params.wmm_enabled)\n\t\tpriv->wmm_enabled = true;\n\telse\n\t\tpriv->wmm_enabled = false;\n\n\tpriv->curr_bss_params.wmm_uapsd_enabled = false;\n\n\tif (priv->wmm_enabled)\n\t\tpriv->curr_bss_params.wmm_uapsd_enabled\n\t\t\t= ((bss_desc->wmm_ie.qos_info_bitmap &\n\t\t\t\tIEEE80211_WMM_IE_AP_QOSINFO_UAPSD) ? 1 : 0);\n\n\t/* Store the bandwidth information from assoc response */\n\tie_ptr = cfg80211_find_ie(WLAN_EID_HT_OPERATION, assoc_rsp->ie_buffer,\n\t\t\t\t  priv->assoc_rsp_size\n\t\t\t\t  - sizeof(struct ieee_types_assoc_rsp));\n\tif (ie_ptr) {\n\t\tassoc_resp_ht_oper = (struct ieee80211_ht_operation *)(ie_ptr\n\t\t\t\t\t+ sizeof(struct ieee_types_header));\n\t\tpriv->assoc_resp_ht_param = assoc_resp_ht_oper->ht_param;\n\t\tpriv->ht_param_present = true;\n\t} else {\n\t\tpriv->ht_param_present = false;\n\t}\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: ASSOC_RESP: curr_pkt_filter is %#x\\n\",\n\t\t    priv->curr_pkt_filter);\n\tif (priv->sec_info.wpa_enabled || priv->sec_info.wpa2_enabled)\n\t\tpriv->wpa_is_gtk_set = false;\n\n\tif (priv->wmm_enabled) {\n\t\t/* Don't re-enable carrier until we get the WMM_GET_STATUS\n\t\t   event */\n\t\tenable_data = false;\n\t} else {\n\t\t/* Since WMM is not enabled, setup the queues with the\n\t\t   defaults */\n\t\tmwifiex_wmm_setup_queue_priorities(priv, NULL);\n\t\tmwifiex_wmm_setup_ac_downgrade(priv);\n\t}\n\n\tif (enable_data)\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: post association, re-enabling data flow\\n\");\n\n\t/* Reset SNR/NF/RSSI values */\n\tpriv->data_rssi_last = 0;\n\tpriv->data_nf_last = 0;\n\tpriv->data_rssi_avg = 0;\n\tpriv->data_nf_avg = 0;\n\tpriv->bcn_rssi_last = 0;\n\tpriv->bcn_nf_last = 0;\n\tpriv->bcn_rssi_avg = 0;\n\tpriv->bcn_nf_avg = 0;\n\tpriv->rxpd_rate = 0;\n\tpriv->rxpd_htinfo = 0;\n\n\tmwifiex_save_curr_bcn(priv);\n\n\tpriv->adapter->dbg.num_cmd_assoc_success++;\n\n\tmwifiex_dbg(priv->adapter, INFO, \"info: ASSOC_RESP: associated\\n\");\n\n\t/* Add the ra_list here for infra mode as there will be only 1 ra\n\t   always */\n\tmwifiex_ralist_add(priv,\n\t\t\t   priv->curr_bss_params.bss_descriptor.mac_address);\n\n\tif (!netif_carrier_ok(priv->netdev))\n\t\tnetif_carrier_on(priv->netdev);\n\tmwifiex_wake_up_net_dev_queue(priv->netdev, adapter);\n\n\tif (priv->sec_info.wpa_enabled || priv->sec_info.wpa2_enabled)\n\t\tpriv->scan_block = true;\n\telse\n\t\tpriv->port_open = true;\n\ndone:\n\t/* Need to indicate IOCTL complete */\n\tif (adapter->curr_cmd->wait_q_enabled) {\n\t\tif (ret)\n\t\t\tadapter->cmd_wait_q.status = -1;\n\t\telse\n\t\t\tadapter->cmd_wait_q.status = 0;\n\t}\n\n\treturn ret;\n}\n\n/*\n * This function prepares command for ad-hoc start.\n *\n * Driver will fill up SSID, BSS mode, IBSS parameters, physical\n * parameters, probe delay, and capability information. Firmware\n * will fill up beacon period, basic rates and operational rates.\n *\n * In addition, the following TLVs are added -\n *      - Channel TLV\n *      - Vendor specific IE\n *      - WPA/WPA2 IE\n *      - HT Capabilities IE\n *      - HT Information IE\n *\n * Preparation also includes -\n *      - Setting command ID and proper size\n *      - Ensuring correct endian-ness\n */\nint\nmwifiex_cmd_802_11_ad_hoc_start(struct mwifiex_private *priv,\n\t\t\t\tstruct host_cmd_ds_command *cmd,\n\t\t\t\tstruct cfg80211_ssid *req_ssid)\n{\n\tint rsn_ie_len = 0;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct host_cmd_ds_802_11_ad_hoc_start *adhoc_start =\n\t\t&cmd->params.adhoc_start;\n\tstruct mwifiex_bssdescriptor *bss_desc;\n\tu32 cmd_append_size = 0;\n\tu32 i;\n\tu16 tmp_cap;\n\tstruct mwifiex_ie_types_chan_list_param_set *chan_tlv;\n\tu8 radio_type;\n\n\tstruct mwifiex_ie_types_htcap *ht_cap;\n\tstruct mwifiex_ie_types_htinfo *ht_info;\n\tu8 *pos = (u8 *) adhoc_start +\n\t\t\tsizeof(struct host_cmd_ds_802_11_ad_hoc_start);\n\n\tif (!adapter)\n\t\treturn -1;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_START);\n\n\tbss_desc = &priv->curr_bss_params.bss_descriptor;\n\tpriv->attempted_bss_desc = bss_desc;\n\n\t/*\n\t * Fill in the parameters for 2 data structures:\n\t *   1. struct host_cmd_ds_802_11_ad_hoc_start command\n\t *   2. bss_desc\n\t * Driver will fill up SSID, bss_mode,IBSS param, Physical Param,\n\t * probe delay, and Cap info.\n\t * Firmware will fill up beacon period, Basic rates\n\t * and operational rates.\n\t */\n\n\tmemset(adhoc_start->ssid, 0, IEEE80211_MAX_SSID_LEN);\n\n\tif (req_ssid->ssid_len > IEEE80211_MAX_SSID_LEN)\n\t\treq_ssid->ssid_len = IEEE80211_MAX_SSID_LEN;\n\tmemcpy(adhoc_start->ssid, req_ssid->ssid, req_ssid->ssid_len);\n\n\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: SSID = %s\\n\",\n\t\t    adhoc_start->ssid);\n\n\tmemset(bss_desc->ssid.ssid, 0, IEEE80211_MAX_SSID_LEN);\n\tmemcpy(bss_desc->ssid.ssid, req_ssid->ssid, req_ssid->ssid_len);\n\n\tbss_desc->ssid.ssid_len = req_ssid->ssid_len;\n\n\t/* Set the BSS mode */\n\tadhoc_start->bss_mode = HostCmd_BSS_MODE_IBSS;\n\tbss_desc->bss_mode = NL80211_IFTYPE_ADHOC;\n\tadhoc_start->beacon_period = cpu_to_le16(priv->beacon_period);\n\tbss_desc->beacon_period = priv->beacon_period;\n\n\t/* Set Physical param set */\n/* Parameter IE Id */\n#define DS_PARA_IE_ID   3\n/* Parameter IE length */\n#define DS_PARA_IE_LEN  1\n\n\tadhoc_start->phy_param_set.ds_param_set.element_id = DS_PARA_IE_ID;\n\tadhoc_start->phy_param_set.ds_param_set.len = DS_PARA_IE_LEN;\n\n\tif (!mwifiex_get_cfp(priv, adapter->adhoc_start_band,\n\t\t\t     (u16) priv->adhoc_channel, 0)) {\n\t\tstruct mwifiex_chan_freq_power *cfp;\n\t\tcfp = mwifiex_get_cfp(priv, adapter->adhoc_start_band,\n\t\t\t\t      FIRST_VALID_CHANNEL, 0);\n\t\tif (cfp)\n\t\t\tpriv->adhoc_channel = (u8) cfp->channel;\n\t}\n\n\tif (!priv->adhoc_channel) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"ADHOC_S_CMD: adhoc_channel cannot be 0\\n\");\n\t\treturn -1;\n\t}\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: ADHOC_S_CMD: creating ADHOC on channel %d\\n\",\n\t\t    priv->adhoc_channel);\n\n\tpriv->curr_bss_params.bss_descriptor.channel = priv->adhoc_channel;\n\tpriv->curr_bss_params.band = adapter->adhoc_start_band;\n\n\tbss_desc->channel = priv->adhoc_channel;\n\tadhoc_start->phy_param_set.ds_param_set.current_chan =\n\t\tpriv->adhoc_channel;\n\n\tmemcpy(&bss_desc->phy_param_set, &adhoc_start->phy_param_set,\n\t       sizeof(union ieee_types_phy_param_set));\n\n\t/* Set IBSS param set */\n/* IBSS parameter IE Id */\n#define IBSS_PARA_IE_ID   6\n/* IBSS parameter IE length */\n#define IBSS_PARA_IE_LEN  2\n\n\tadhoc_start->ss_param_set.ibss_param_set.element_id = IBSS_PARA_IE_ID;\n\tadhoc_start->ss_param_set.ibss_param_set.len = IBSS_PARA_IE_LEN;\n\tadhoc_start->ss_param_set.ibss_param_set.atim_window\n\t\t\t\t\t= cpu_to_le16(priv->atim_window);\n\tmemcpy(&bss_desc->ss_param_set, &adhoc_start->ss_param_set,\n\t       sizeof(union ieee_types_ss_param_set));\n\n\t/* Set Capability info */\n\tbss_desc->cap_info_bitmap |= WLAN_CAPABILITY_IBSS;\n\ttmp_cap = WLAN_CAPABILITY_IBSS;\n\n\t/* Set up privacy in bss_desc */\n\tif (priv->sec_info.encryption_mode) {\n\t\t/* Ad-Hoc capability privacy on */\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: ADHOC_S_CMD: wep_status set privacy to WEP\\n\");\n\t\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_8021X_WEP;\n\t\ttmp_cap |= WLAN_CAPABILITY_PRIVACY;\n\t} else {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: ADHOC_S_CMD: wep_status NOT set,\\t\"\n\t\t\t    \"setting privacy to ACCEPT ALL\\n\");\n\t\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_ACCEPT_ALL;\n\t}\n\n\tmemset(adhoc_start->data_rate, 0, sizeof(adhoc_start->data_rate));\n\tmwifiex_get_active_data_rates(priv, adhoc_start->data_rate);\n\tif ((adapter->adhoc_start_band & BAND_G) &&\n\t    (priv->curr_pkt_filter & HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON)) {\n\t\tif (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\n\t\t\t\t     HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t     &priv->curr_pkt_filter, false)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"ADHOC_S_CMD: G Protection config failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/* Find the last non zero */\n\tfor (i = 0; i < sizeof(adhoc_start->data_rate); i++)\n\t\tif (!adhoc_start->data_rate[i])\n\t\t\tbreak;\n\n\tpriv->curr_bss_params.num_of_rates = i;\n\n\t/* Copy the ad-hoc creating rates into Current BSS rate structure */\n\tmemcpy(&priv->curr_bss_params.data_rates,\n\t       &adhoc_start->data_rate, priv->curr_bss_params.num_of_rates);\n\n\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: rates=%4ph\\n\",\n\t\t    adhoc_start->data_rate);\n\n\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: AD-HOC Start command is ready\\n\");\n\n\tif (IS_SUPPORT_MULTI_BANDS(adapter)) {\n\t\t/* Append a channel TLV */\n\t\tchan_tlv = (struct mwifiex_ie_types_chan_list_param_set *) pos;\n\t\tchan_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\n\t\tchan_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(struct mwifiex_chan_scan_param_set));\n\n\t\tmemset(chan_tlv->chan_scan_param, 0x00,\n\t\t       sizeof(struct mwifiex_chan_scan_param_set));\n\t\tchan_tlv->chan_scan_param[0].chan_number =\n\t\t\t(u8) priv->curr_bss_params.bss_descriptor.channel;\n\n\t\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: TLV Chan = %d\\n\",\n\t\t\t    chan_tlv->chan_scan_param[0].chan_number);\n\n\t\tchan_tlv->chan_scan_param[0].radio_type\n\t\t       = mwifiex_band_to_radio_type(priv->curr_bss_params.band);\n\t\tif (adapter->adhoc_start_band & BAND_GN ||\n\t\t    adapter->adhoc_start_band & BAND_AN) {\n\t\t\tif (adapter->sec_chan_offset ==\n\t\t\t\t\t    IEEE80211_HT_PARAM_CHA_SEC_ABOVE)\n\t\t\t\tchan_tlv->chan_scan_param[0].radio_type |=\n\t\t\t\t\t(IEEE80211_HT_PARAM_CHA_SEC_ABOVE << 4);\n\t\t\telse if (adapter->sec_chan_offset ==\n\t\t\t\t\t    IEEE80211_HT_PARAM_CHA_SEC_BELOW)\n\t\t\t\tchan_tlv->chan_scan_param[0].radio_type |=\n\t\t\t\t\t(IEEE80211_HT_PARAM_CHA_SEC_BELOW << 4);\n\t\t}\n\t\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: TLV Band = %d\\n\",\n\t\t\t    chan_tlv->chan_scan_param[0].radio_type);\n\t\tpos += sizeof(chan_tlv->header) +\n\t\t\tsizeof(struct mwifiex_chan_scan_param_set);\n\t\tcmd_append_size +=\n\t\t\tsizeof(chan_tlv->header) +\n\t\t\tsizeof(struct mwifiex_chan_scan_param_set);\n\t}\n\n\t/* Append vendor specific IE TLV */\n\tcmd_append_size += mwifiex_cmd_append_vsie_tlv(priv,\n\t\t\t\tMWIFIEX_VSIE_MASK_ADHOC, &pos);\n\n\tif (priv->sec_info.wpa_enabled) {\n\t\trsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2(priv, &pos);\n\t\tif (rsn_ie_len == -1)\n\t\t\treturn -1;\n\t\tcmd_append_size += rsn_ie_len;\n\t}\n\n\tif (adapter->adhoc_11n_enabled) {\n\t\t/* Fill HT CAPABILITY */\n\t\tht_cap = (struct mwifiex_ie_types_htcap *) pos;\n\t\tmemset(ht_cap, 0, sizeof(struct mwifiex_ie_types_htcap));\n\t\tht_cap->header.type = cpu_to_le16(WLAN_EID_HT_CAPABILITY);\n\t\tht_cap->header.len =\n\t\t       cpu_to_le16(sizeof(struct ieee80211_ht_cap));\n\t\tradio_type = mwifiex_band_to_radio_type(\n\t\t\t\t\tpriv->adapter->config_bands);\n\t\tmwifiex_fill_cap_info(priv, radio_type, &ht_cap->ht_cap);\n\n\t\tif (adapter->sec_chan_offset ==\n\t\t\t\t\tIEEE80211_HT_PARAM_CHA_SEC_NONE) {\n\t\t\tu16 tmp_ht_cap;\n\n\t\t\ttmp_ht_cap = le16_to_cpu(ht_cap->ht_cap.cap_info);\n\t\t\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\t\t\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SGI_40;\n\t\t\tht_cap->ht_cap.cap_info = cpu_to_le16(tmp_ht_cap);\n\t\t}\n\n\t\tpos += sizeof(struct mwifiex_ie_types_htcap);\n\t\tcmd_append_size += sizeof(struct mwifiex_ie_types_htcap);\n\n\t\t/* Fill HT INFORMATION */\n\t\tht_info = (struct mwifiex_ie_types_htinfo *) pos;\n\t\tmemset(ht_info, 0, sizeof(struct mwifiex_ie_types_htinfo));\n\t\tht_info->header.type = cpu_to_le16(WLAN_EID_HT_OPERATION);\n\t\tht_info->header.len =\n\t\t\tcpu_to_le16(sizeof(struct ieee80211_ht_operation));\n\n\t\tht_info->ht_oper.primary_chan =\n\t\t\t(u8) priv->curr_bss_params.bss_descriptor.channel;\n\t\tif (adapter->sec_chan_offset) {\n\t\t\tht_info->ht_oper.ht_param = adapter->sec_chan_offset;\n\t\t\tht_info->ht_oper.ht_param |=\n\t\t\t\t\tIEEE80211_HT_PARAM_CHAN_WIDTH_ANY;\n\t\t}\n\t\tht_info->ht_oper.operation_mode =\n\t\t     cpu_to_le16(IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);\n\t\tht_info->ht_oper.basic_set[0] = 0xff;\n\t\tpos += sizeof(struct mwifiex_ie_types_htinfo);\n\t\tcmd_append_size +=\n\t\t\t\tsizeof(struct mwifiex_ie_types_htinfo);\n\t}\n\n\tcmd->size =\n\t\tcpu_to_le16((u16)(sizeof(struct host_cmd_ds_802_11_ad_hoc_start)\n\t\t\t\t  + S_DS_GEN + cmd_append_size));\n\n\tif (adapter->adhoc_start_band == BAND_B)\n\t\ttmp_cap &= ~WLAN_CAPABILITY_SHORT_SLOT_TIME;\n\telse\n\t\ttmp_cap |= WLAN_CAPABILITY_SHORT_SLOT_TIME;\n\n\tadhoc_start->cap_info_bitmap = cpu_to_le16(tmp_cap);\n\n\treturn 0;\n}\n\n/*\n * This function prepares command for ad-hoc join.\n *\n * Most of the parameters are set up by copying from the target BSS descriptor\n * from the scan response.\n *\n * In addition, the following TLVs are added -\n *      - Channel TLV\n *      - Vendor specific IE\n *      - WPA/WPA2 IE\n *      - 11n IE\n *\n * Preparation also includes -\n *      - Setting command ID and proper size\n *      - Ensuring correct endian-ness\n */\nint\nmwifiex_cmd_802_11_ad_hoc_join(struct mwifiex_private *priv,\n\t\t\t       struct host_cmd_ds_command *cmd,\n\t\t\t       struct mwifiex_bssdescriptor *bss_desc)\n{\n\tint rsn_ie_len = 0;\n\tstruct host_cmd_ds_802_11_ad_hoc_join *adhoc_join =\n\t\t&cmd->params.adhoc_join;\n\tstruct mwifiex_ie_types_chan_list_param_set *chan_tlv;\n\tu32 cmd_append_size = 0;\n\tu16 tmp_cap;\n\tu32 i, rates_size = 0;\n\tu16 curr_pkt_filter;\n\tu8 *pos =\n\t\t(u8 *) adhoc_join +\n\t\tsizeof(struct host_cmd_ds_802_11_ad_hoc_join);\n\n/* Use G protection */\n#define USE_G_PROTECTION        0x02\n\tif (bss_desc->erp_flags & USE_G_PROTECTION) {\n\t\tcurr_pkt_filter =\n\t\t\tpriv->\n\t\t\tcurr_pkt_filter | HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON;\n\n\t\tif (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\n\t\t\t\t     HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t     &curr_pkt_filter, false)) {\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"ADHOC_J_CMD: G Protection config failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tpriv->attempted_bss_desc = bss_desc;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_JOIN);\n\n\tadhoc_join->bss_descriptor.bss_mode = HostCmd_BSS_MODE_IBSS;\n\n\tadhoc_join->bss_descriptor.beacon_period\n\t\t= cpu_to_le16(bss_desc->beacon_period);\n\n\tmemcpy(&adhoc_join->bss_descriptor.bssid,\n\t       &bss_desc->mac_address, ETH_ALEN);\n\n\tmemcpy(&adhoc_join->bss_descriptor.ssid,\n\t       &bss_desc->ssid.ssid, bss_desc->ssid.ssid_len);\n\n\tmemcpy(&adhoc_join->bss_descriptor.phy_param_set,\n\t       &bss_desc->phy_param_set,\n\t       sizeof(union ieee_types_phy_param_set));\n\n\tmemcpy(&adhoc_join->bss_descriptor.ss_param_set,\n\t       &bss_desc->ss_param_set, sizeof(union ieee_types_ss_param_set));\n\n\ttmp_cap = bss_desc->cap_info_bitmap;\n\n\ttmp_cap &= CAPINFO_MASK;\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: ADHOC_J_CMD: tmp_cap=%4X CAPINFO_MASK=%4lX\\n\",\n\t\t    tmp_cap, CAPINFO_MASK);\n\n\t/* Information on BSSID descriptor passed to FW */\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: ADHOC_J_CMD: BSSID=%pM, SSID='%s'\\n\",\n\t\t    adhoc_join->bss_descriptor.bssid,\n\t\t    adhoc_join->bss_descriptor.ssid);\n\n\tfor (i = 0; i < MWIFIEX_SUPPORTED_RATES &&\n\t\t    bss_desc->supported_rates[i]; i++)\n\t\t;\n\trates_size = i;\n\n\t/* Copy Data Rates from the Rates recorded in scan response */\n\tmemset(adhoc_join->bss_descriptor.data_rates, 0,\n\t       sizeof(adhoc_join->bss_descriptor.data_rates));\n\tmemcpy(adhoc_join->bss_descriptor.data_rates,\n\t       bss_desc->supported_rates, rates_size);\n\n\t/* Copy the adhoc join rates into Current BSS state structure */\n\tpriv->curr_bss_params.num_of_rates = rates_size;\n\tmemcpy(&priv->curr_bss_params.data_rates, bss_desc->supported_rates,\n\t       rates_size);\n\n\t/* Copy the channel information */\n\tpriv->curr_bss_params.bss_descriptor.channel = bss_desc->channel;\n\tpriv->curr_bss_params.band = (u8) bss_desc->bss_band;\n\n\tif (priv->sec_info.wep_enabled || priv->sec_info.wpa_enabled)\n\t\ttmp_cap |= WLAN_CAPABILITY_PRIVACY;\n\n\tif (IS_SUPPORT_MULTI_BANDS(priv->adapter)) {\n\t\t/* Append a channel TLV */\n\t\tchan_tlv = (struct mwifiex_ie_types_chan_list_param_set *) pos;\n\t\tchan_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\n\t\tchan_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(struct mwifiex_chan_scan_param_set));\n\n\t\tmemset(chan_tlv->chan_scan_param, 0x00,\n\t\t       sizeof(struct mwifiex_chan_scan_param_set));\n\t\tchan_tlv->chan_scan_param[0].chan_number =\n\t\t\t(bss_desc->phy_param_set.ds_param_set.current_chan);\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: ADHOC_J_CMD: TLV Chan=%d\\n\",\n\t\t\t    chan_tlv->chan_scan_param[0].chan_number);\n\n\t\tchan_tlv->chan_scan_param[0].radio_type =\n\t\t\tmwifiex_band_to_radio_type((u8) bss_desc->bss_band);\n\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: ADHOC_J_CMD: TLV Band=%d\\n\",\n\t\t\t    chan_tlv->chan_scan_param[0].radio_type);\n\t\tpos += sizeof(chan_tlv->header) +\n\t\t\t\tsizeof(struct mwifiex_chan_scan_param_set);\n\t\tcmd_append_size += sizeof(chan_tlv->header) +\n\t\t\t\tsizeof(struct mwifiex_chan_scan_param_set);\n\t}\n\n\tif (priv->sec_info.wpa_enabled)\n\t\trsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2(priv, &pos);\n\tif (rsn_ie_len == -1)\n\t\treturn -1;\n\tcmd_append_size += rsn_ie_len;\n\n\tif (ISSUPP_11NENABLED(priv->adapter->fw_cap_info))\n\t\tcmd_append_size += mwifiex_cmd_append_11n_tlv(priv,\n\t\t\tbss_desc, &pos);\n\n\t/* Append vendor specific IE TLV */\n\tcmd_append_size += mwifiex_cmd_append_vsie_tlv(priv,\n\t\t\tMWIFIEX_VSIE_MASK_ADHOC, &pos);\n\n\tcmd->size = cpu_to_le16\n\t\t((u16) (sizeof(struct host_cmd_ds_802_11_ad_hoc_join)\n\t\t\t+ S_DS_GEN + cmd_append_size));\n\n\tadhoc_join->bss_descriptor.cap_info_bitmap = cpu_to_le16(tmp_cap);\n\n\treturn 0;\n}\n\n/*\n * This function handles the command response of ad-hoc start and\n * ad-hoc join.\n *\n * The function generates a device-connected event to notify\n * the applications, in case of successful ad-hoc start/join, and\n * saves the beacon buffer.\n */\nint mwifiex_ret_802_11_ad_hoc(struct mwifiex_private *priv,\n\t\t\t      struct host_cmd_ds_command *resp)\n{\n\tint ret = 0;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct host_cmd_ds_802_11_ad_hoc_start_result *start_result =\n\t\t\t\t&resp->params.start_result;\n\tstruct host_cmd_ds_802_11_ad_hoc_join_result *join_result =\n\t\t\t\t&resp->params.join_result;\n\tstruct mwifiex_bssdescriptor *bss_desc;\n\tu16 cmd = le16_to_cpu(resp->command);\n\tu8 result;\n\n\tif (!priv->attempted_bss_desc) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"ADHOC_RESP: failed, association terminated by host\\n\");\n\t\tgoto done;\n\t}\n\n\tif (cmd == HostCmd_CMD_802_11_AD_HOC_START)\n\t\tresult = start_result->result;\n\telse\n\t\tresult = join_result->result;\n\n\tbss_desc = priv->attempted_bss_desc;\n\n\t/* Join result code 0 --> SUCCESS */\n\tif (result) {\n\t\tmwifiex_dbg(priv->adapter, ERROR, \"ADHOC_RESP: failed\\n\");\n\t\tif (priv->media_connected)\n\t\t\tmwifiex_reset_connect_state(priv, result, true);\n\n\t\tmemset(&priv->curr_bss_params.bss_descriptor,\n\t\t       0x00, sizeof(struct mwifiex_bssdescriptor));\n\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\n\t/* Send a Media Connected event, according to the Spec */\n\tpriv->media_connected = true;\n\n\tif (le16_to_cpu(resp->command) == HostCmd_CMD_802_11_AD_HOC_START) {\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: ADHOC_S_RESP %s\\n\",\n\t\t\t    bss_desc->ssid.ssid);\n\n\t\t/* Update the created network descriptor with the new BSSID */\n\t\tmemcpy(bss_desc->mac_address,\n\t\t       start_result->bssid, ETH_ALEN);\n\n\t\tpriv->adhoc_state = ADHOC_STARTED;\n\t} else {\n\t\t/*\n\t\t * Now the join cmd should be successful.\n\t\t * If BSSID has changed use SSID to compare instead of BSSID\n\t\t */\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: ADHOC_J_RESP %s\\n\",\n\t\t\t    bss_desc->ssid.ssid);\n\n\t\t/*\n\t\t * Make a copy of current BSSID descriptor, only needed for\n\t\t * join since the current descriptor is already being used\n\t\t * for adhoc start\n\t\t */\n\t\tmemcpy(&priv->curr_bss_params.bss_descriptor,\n\t\t       bss_desc, sizeof(struct mwifiex_bssdescriptor));\n\n\t\tpriv->adhoc_state = ADHOC_JOINED;\n\t}\n\n\tmwifiex_dbg(priv->adapter, INFO, \"info: ADHOC_RESP: channel = %d\\n\",\n\t\t    priv->adhoc_channel);\n\tmwifiex_dbg(priv->adapter, INFO, \"info: ADHOC_RESP: BSSID = %pM\\n\",\n\t\t    priv->curr_bss_params.bss_descriptor.mac_address);\n\n\tif (!netif_carrier_ok(priv->netdev))\n\t\tnetif_carrier_on(priv->netdev);\n\tmwifiex_wake_up_net_dev_queue(priv->netdev, adapter);\n\n\tmwifiex_save_curr_bcn(priv);\n\ndone:\n\t/* Need to indicate IOCTL complete */\n\tif (adapter->curr_cmd->wait_q_enabled) {\n\t\tif (ret)\n\t\t\tadapter->cmd_wait_q.status = -1;\n\t\telse\n\t\t\tadapter->cmd_wait_q.status = 0;\n\n\t}\n\n\treturn ret;\n}\n\n/*\n * This function associates to a specific BSS discovered in a scan.\n *\n * It clears any past association response stored for application\n * retrieval and calls the command preparation routine to send the\n * command to firmware.\n */\nint mwifiex_associate(struct mwifiex_private *priv,\n\t\t      struct mwifiex_bssdescriptor *bss_desc)\n{\n\t/* Return error if the adapter is not STA role or table entry\n\t * is not marked as infra.\n\t */\n\tif ((GET_BSS_ROLE(priv) != MWIFIEX_BSS_ROLE_STA) ||\n\t    (bss_desc->bss_mode != NL80211_IFTYPE_STATION))\n\t\treturn -1;\n\n\tif (ISSUPP_11ACENABLED(priv->adapter->fw_cap_info) &&\n\t    !bss_desc->disable_11n && !bss_desc->disable_11ac &&\n\t    priv->adapter->config_bands & BAND_AAC)\n\t\tmwifiex_set_11ac_ba_params(priv);\n\telse\n\t\tmwifiex_set_ba_params(priv);\n\n\t/* Clear any past association response stored for application\n\t   retrieval */\n\tpriv->assoc_rsp_size = 0;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_ASSOCIATE,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, bss_desc, true);\n}\n\n/*\n * This function starts an ad-hoc network.\n *\n * It calls the command preparation routine to send the command to firmware.\n */\nint\nmwifiex_adhoc_start(struct mwifiex_private *priv,\n\t\t    struct cfg80211_ssid *adhoc_ssid)\n{\n\tmwifiex_dbg(priv->adapter, INFO, \"info: Adhoc Channel = %d\\n\",\n\t\t    priv->adhoc_channel);\n\tmwifiex_dbg(priv->adapter, INFO, \"info: curr_bss_params.channel = %d\\n\",\n\t\t    priv->curr_bss_params.bss_descriptor.channel);\n\tmwifiex_dbg(priv->adapter, INFO, \"info: curr_bss_params.band = %d\\n\",\n\t\t    priv->curr_bss_params.band);\n\n\tif (ISSUPP_11ACENABLED(priv->adapter->fw_cap_info) &&\n\t    priv->adapter->config_bands & BAND_AAC)\n\t\tmwifiex_set_11ac_ba_params(priv);\n\telse\n\t\tmwifiex_set_ba_params(priv);\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_AD_HOC_START,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, adhoc_ssid, true);\n}\n\n/*\n * This function joins an ad-hoc network found in a previous scan.\n *\n * It calls the command preparation routine to send the command to firmware,\n * if already not connected to the requested SSID.\n */\nint mwifiex_adhoc_join(struct mwifiex_private *priv,\n\t\t       struct mwifiex_bssdescriptor *bss_desc)\n{\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: adhoc join: curr_bss ssid =%s\\n\",\n\t\t    priv->curr_bss_params.bss_descriptor.ssid.ssid);\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: adhoc join: curr_bss ssid_len =%u\\n\",\n\t\t    priv->curr_bss_params.bss_descriptor.ssid.ssid_len);\n\tmwifiex_dbg(priv->adapter, INFO, \"info: adhoc join: ssid =%s\\n\",\n\t\t    bss_desc->ssid.ssid);\n\tmwifiex_dbg(priv->adapter, INFO, \"info: adhoc join: ssid_len =%u\\n\",\n\t\t    bss_desc->ssid.ssid_len);\n\n\t/* Check if the requested SSID is already joined */\n\tif (priv->curr_bss_params.bss_descriptor.ssid.ssid_len &&\n\t    !mwifiex_ssid_cmp(&bss_desc->ssid,\n\t\t\t      &priv->curr_bss_params.bss_descriptor.ssid) &&\n\t    (priv->curr_bss_params.bss_descriptor.bss_mode ==\n\t\t\t\t\t\t\tNL80211_IFTYPE_ADHOC)) {\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: ADHOC_J_CMD: new ad-hoc SSID\\t\"\n\t\t\t    \"is the same as current; not attempting to re-join\\n\");\n\t\treturn -1;\n\t}\n\n\tif (ISSUPP_11ACENABLED(priv->adapter->fw_cap_info) &&\n\t    !bss_desc->disable_11n && !bss_desc->disable_11ac &&\n\t    priv->adapter->config_bands & BAND_AAC)\n\t\tmwifiex_set_11ac_ba_params(priv);\n\telse\n\t\tmwifiex_set_ba_params(priv);\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: curr_bss_params.channel = %d\\n\",\n\t\t    priv->curr_bss_params.bss_descriptor.channel);\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: curr_bss_params.band = %c\\n\",\n\t\t    priv->curr_bss_params.band);\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_AD_HOC_JOIN,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, bss_desc, true);\n}\n\n/*\n * This function deauthenticates/disconnects from infra network by sending\n * deauthentication request.\n */\nstatic int mwifiex_deauthenticate_infra(struct mwifiex_private *priv, u8 *mac)\n{\n\tu8 mac_address[ETH_ALEN];\n\tint ret;\n\n\tif (!mac || is_zero_ether_addr(mac))\n\t\tmemcpy(mac_address,\n\t\t       priv->curr_bss_params.bss_descriptor.mac_address,\n\t\t       ETH_ALEN);\n\telse\n\t\tmemcpy(mac_address, mac, ETH_ALEN);\n\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_DEAUTHENTICATE,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, mac_address, true);\n\n\treturn ret;\n}\n\n/*\n * This function deauthenticates/disconnects from a BSS.\n *\n * In case of infra made, it sends deauthentication request, and\n * in case of ad-hoc mode, a stop network request is sent to the firmware.\n * In AP mode, a command to stop bss is sent to firmware.\n */\nint mwifiex_deauthenticate(struct mwifiex_private *priv, u8 *mac)\n{\n\tint ret = 0;\n\n\tif (!priv->media_connected)\n\t\treturn 0;\n\n\tswitch (priv->bss_mode) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tret = mwifiex_deauthenticate_infra(priv, mac);\n\t\tif (ret)\n\t\t\tcfg80211_disconnected(priv->netdev, 0, NULL, 0,\n\t\t\t\t\t      true, GFP_KERNEL);\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_AD_HOC_STOP,\n\t\t\t\t\tHostCmd_ACT_GEN_SET, 0, NULL, true);\n\tcase NL80211_IFTYPE_AP:\n\t\treturn mwifiex_send_cmd(priv, HostCmd_CMD_UAP_BSS_STOP,\n\t\t\t\t\tHostCmd_ACT_GEN_SET, 0, NULL, true);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n/* This function deauthenticates/disconnects from all BSS. */\nvoid mwifiex_deauthenticate_all(struct mwifiex_adapter *adapter)\n{\n\tstruct mwifiex_private *priv;\n\tint i;\n\n\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\tpriv = adapter->priv[i];\n\t\tif (priv)\n\t\t\tmwifiex_deauthenticate(priv, NULL);\n\t}\n}\nEXPORT_SYMBOL_GPL(mwifiex_deauthenticate_all);\n\n/*\n * This function converts band to radio type used in channel TLV.\n */\nu8\nmwifiex_band_to_radio_type(u8 band)\n{\n\tswitch (band) {\n\tcase BAND_A:\n\tcase BAND_AN:\n\tcase BAND_A | BAND_AN:\n\tcase BAND_A | BAND_AN | BAND_AAC:\n\t\treturn HostCmd_SCAN_RADIO_TYPE_A;\n\tcase BAND_B:\n\tcase BAND_G:\n\tcase BAND_B | BAND_G:\n\tdefault:\n\t\treturn HostCmd_SCAN_RADIO_TYPE_BG;\n\t}\n}\n"], "filenames": ["drivers/net/wireless/marvell/mwifiex/join.c"], "buggy_code_start_loc": [879], "buggy_code_end_loc": [879], "fixing_code_start_loc": [880], "fixing_code_end_loc": [882], "type": "CWE-120", "message": "mwifiex_cmd_802_11_ad_hoc_start in drivers/net/wireless/marvell/mwifiex/join.c in the Linux kernel through 5.10.4 might allow remote attackers to execute arbitrary code via a long SSID value, aka CID-5c455c5ab332.", "other": {"cve": {"id": "CVE-2020-36158", "sourceIdentifier": "cve@mitre.org", "published": "2021-01-05T05:15:10.737", "lastModified": "2022-10-07T00:52:41.123", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "mwifiex_cmd_802_11_ad_hoc_start in drivers/net/wireless/marvell/mwifiex/join.c in the Linux kernel through 5.10.4 might allow remote attackers to execute arbitrary code via a long SSID value, aka CID-5c455c5ab332."}, {"lang": "es", "value": "La funci\u00f3n mwifiex_cmd_802_11_ad_hoc_start en el archivo drivers/net/wireless/marvell/mwifiex/join.c en el kernel de Linux versiones hasta 5.10.4, podr\u00eda permitir a atacantes remotos ejecutar c\u00f3digo arbitrario por medio de un valor SSID grande, tambi\u00e9n se conoce como CID-5c455c5ab332"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 5.9}, {"source": "cve@mitre.org", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.10.4", "matchCriteriaId": "758E081B-4420-4DEC-B5BC-CC90E584DF84"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:cloud_backup:-:*:*:*:*:*:*:*", "matchCriteriaId": "5C2089EE-5D7F-47EC-8EA5-0F69790564C4"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:solidfire_baseboard_management_controller_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "FB9B8171-F6CA-427D-81E0-6536D3BBFA8D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:solidfire_baseboard_management_controller:-:*:*:*:*:*:*:*", "matchCriteriaId": "090AA6F4-4404-4E26-82AB-C3A22636F276"}]}]}], "references": [{"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=5c455c5ab332773464d02ba17015acdca198f03d", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/5c455c5ab332773464d02ba17015acdca198f03d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/02/msg00018.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/03/msg00010.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HCHBIRS27VMOGMBHPWP2R7SZRFXT6O6U/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lore.kernel.org/r/20201206084801.26479-1-ruc_zhangxiaohui@163.com", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://patchwork.kernel.org/project/linux-wireless/patch/20201206084801.26479-1-ruc_zhangxiaohui@163.com/", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210212-0002/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2021/dsa-4843", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/5c455c5ab332773464d02ba17015acdca198f03d"}}