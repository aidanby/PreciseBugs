{"buggy_code": ["# teler-waf\n\n[![Kitabisa Security](https://img.shields.io/badge/kitabisa-security%20project-blue)](#)\n[![GoDoc](https://pkg.go.dev/static/frontend/badge/badge.svg)](http://pkg.go.dev/github.com/kitabisa/teler-waf)\n[![tests](https://github.com/kitabisa/teler-waf/actions/workflows/test.yaml/badge.svg)](https://github.com/kitabisa/teler-waf/actions/workflows/test.yaml)\n\n<img src=\"https://user-images.githubusercontent.com/25837540/97091757-7200d880-1668-11eb-82c4-e5c4971d2bc8.png\" align=\"right\" width=\"250px\"/>\n\n**teler-waf** is a comprehensive security solution for Go-based web applications. It acts as an HTTP middleware, providing an easy-to-use interface for integrating IDS functionality with [teler IDS](https://github.com/kitabisa/teler-waf) into existing Go applications. By using teler-waf, you can help protect against a variety of web-based attacks, such as cross-site scripting (XSS) and SQL injection.\n\nThe package comes with a standard [`net/http.Handler`](https://pkg.go.dev/net/http#Handler), making it easy to integrate into your application's routing. When a client makes a request to a route protected by teler-waf, the request is first checked against the teler IDS to detect known malicious patterns. If no malicious patterns are detected, the request is then passed through for further processing.\n\nIn addition to providing protection against web-based attacks, teler-waf can also help improve the overall security and integrity of your application. It is highly configurable, allowing you to tailor it to fit the specific needs of your application.\n\n**See also:**\n\n- [kitabisa/teler](https://github.com/kitabisa/teler): Real-time HTTP intrusion detection.\n- [dwisiswant0/cox](https://github.com/dwisiswant0/cox): Cox is [bluemonday](https://github.com/microcosm-cc/bluemonday)-wrapper to perform a deep-clean and/or sanitization of <i>(nested-)</i>interfaces from HTML to prevent XSS payloads.\n\n## Features\n\nSome core features of teler-waf include:\n\n- **HTTP middleware** for Go web applications.\n- Integration of **teler IDS** functionality.\n- **Detection of known malicious patterns** using the teler IDS.\n  - Common web attacks, such as cross-site scripting (XSS) and SQL injection, etc.\n  - CVEs, covers known vulnerabilities and exploits.\n  - Bad IP addresses, such as those associated with known malicious actors or botnets.\n  - Bad HTTP referers, such as those that are not expected based on the application's URL structure or are known to be associated with malicious actors.\n  - Bad crawlers, covers requests from known bad crawlers or scrapers, such as those that are known to cause performance issues or attempt to extract sensitive information from the application.\n  - Directory bruteforce attacks, such as by trying common directory names or using dictionary attacks.\n- Configuration options to **whitelist specific types of requests** based on their URL or headers.\n- **Easy integration** with many frameworks.\n- **High configurability** to fit the specific needs of your application.\n\nOverall, teler-waf provides a comprehensive security solution for Go-based web applications, helping to protect against web-based attacks and improve the overall security and integrity of your application.\n\n## Install\n\nTo install teler-waf in your Go application, run the following command to download and install the teler-waf package:\n\n```console\ngo get github.com/kitabisa/teler-waf\n```\n\n## Usage\n\nHere is an example of how to use teler-waf in a Go application:\n\n1. Import the teler-waf package in your Go code:\n\n```go\nimport \"github.com/kitabisa/teler-waf\"\n```\n\n2. Use the `New` function to create a new instance of the `Teler` type. This function takes a variety of optional parameters that can be used to configure teler-waf to suit the specific needs of your application.\n\n```go\nwaf := teler.New()\n```\n\n3. Use the `Handler` method of the `Teler` instance to create a `net/http.Handler`. This handler can then be used in your application's HTTP routing to apply teler-waf's security measures to specific routes.\n\n```go\nhandler := waf.Handler(http.HandlerFunc(yourHandlerFunc))\n```\n\n4. Use the `handler` in your application's HTTP routing to apply teler-waf's security measures to specific routes.\n\n```go\nhttp.Handle(\"/path\", handler)\n```\n\nThat's it! You have configured teler-waf in your Go application.\n\n**Options:**\n\nFor a list of the options available to customize teler-waf, see the [`teler.Options`](https://pkg.go.dev/github.com/kitabisa/teler-waf#Options) struct.\n\n### Examples\n\nHere is an example of how to customize the options and rules for teler-waf:\n\n```go\n// main.go\npackage main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/kitabisa/teler-waf\"\n\t\"github.com/kitabisa/teler-waf/request\"\n\t\"github.com/kitabisa/teler-waf/threat\"\n)\n\nvar myHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t// This is the handler function for the route that we want to protect\n\t// with teler-waf's security measures.\n\tw.Write([]byte(\"hello world\"))\n})\n\nvar rejectHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t// This is the handler function for the route that we want to be rejected\n\t// if the teler-waf's security measures are triggered.\n\thttp.Error(w, \"Sorry, your request has been denied for security reasons.\", http.StatusForbidden)\n})\n\nfunc main() {\n\t// Create a new instance of the Teler type using the New function\n\t// and configure it using the Options struct.\n\ttelerMiddleware := teler.New(teler.Options{\n\t\t// Exclude specific threats from being checked by the teler-waf.\n\t\tExcludes: []threat.Threat{\n\t\t\tthreat.BadReferrer,\n\t\t\tthreat.BadCrawler,\n\t\t},\n\t\t// Specify whitelisted URIs (path & query parameters), headers,\n\t\t// or IP addresses that will always be allowed by the teler-waf.\n\t\tWhitelists: []string{\n\t\t\t`(curl|Go-http-client|okhttp)/*`,\n\t\t\t`^/wp-login\\.php`,\n\t\t\t`(?i)Referer: https?:\\/\\/www\\.facebook\\.com`,\n\t\t\t`192\\.168\\.0\\.1`,\n\t\t},\n\t\t// Specify custom rules for the teler-waf to follow.\n\t\tCustoms: []teler.Rule{\n\t\t\t{\n\t\t\t\t// Give the rule a name for easy identification.\n\t\t\t\tName:      \"Log4j Attack\",\n\t\t\t\t// Specify the logical operator to use when evaluating the rule's conditions.\n\t\t\t\tCondition: \"or\",\n\t\t\t\t// Specify the conditions that must be met for the rule to trigger.\n\t\t\t\tRules: []teler.Condition{\n\t\t\t\t\t{\n\t\t\t\t\t\t// Specify the HTTP method that the rule applies to.\n\t\t\t\t\t\tMethod: request.GET,\n\t\t\t\t\t\t// Specify the element of the request that the rule applies to\n\t\t\t\t\t\t// (e.g. URI, headers, body).\n\t\t\t\t\t\tElement: request.URI,\n\t\t\t\t\t\t// Specify the pattern to match against the element of the request.\n\t\t\t\t\t\tPattern: `\\$\\{.*:\\/\\/.*\\/?\\w+?\\}`,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t// Specify the file path to use for logging.\n\t\tLogFile: \"/tmp/teler.log\",\n\t})\n\n\t// Set the rejectHandler as the handler for the telerMiddleware.\n\ttelerMiddleware.SetHandler(rejectHandler)\n\n\t// Create a new handler using the handler method of the Teler instance\n\t// and pass in the myHandler function for the route we want to protect.\n\tapp := telerMiddleware.Handler(myHandler)\n\n\t// Use the app handler as the handler for the route.\n\thttp.ListenAndServe(\"127.0.0.1:3000\", app)\n}\n```\n\nFor more examples of how to use teler-waf or integrate it with any framework, take a look at [examples/](https://github.com/kitabisa/teler-waf/tree/master/examples) directory.\n\n#### Logs\n\nHere is an example of what the log lines would look like if teler-waf detects a threat on a request:\n\n```json\n{\"level\":\"warn\",\"ts\":1672261174.5995026,\"msg\":\"bad crawler\",\"id\":\"654b85325e1b2911258a\",\"category\":\"BadCrawler\",\"request\":{\"method\":\"GET\",\"path\":\"/\",\"ip_addr\":\"127.0.0.1:37702\",\"headers\":{\"Accept\":[\"*/*\"],\"User-Agent\":[\"curl/7.81.0\"]},\"body\":\"\"}}\n{\"level\":\"warn\",\"ts\":1672261175.9567692,\"msg\":\"directory bruteforce\",\"id\":\"b29546945276ed6b1fba\",\"category\":\"DirectoryBruteforce\",\"request\":{\"method\":\"GET\",\"path\":\"/.git\",\"ip_addr\":\"127.0.0.1:37716\",\"headers\":{\"Accept\":[\"*/*\"],\"User-Agent\":[\"X\"]},\"body\":\"\"}}\n{\"level\":\"warn\",\"ts\":1672261177.1487508,\"msg\":\"Detects common comment types\",\"id\":\"75412f2cc0ec1cf79efd\",\"category\":\"CommonWebAttack\",\"request\":{\"method\":\"GET\",\"path\":\"/?id=1%27%20or%201%3D1%23\",\"ip_addr\":\"127.0.0.1:37728\",\"headers\":{\"Accept\":[\"*/*\"],\"User-Agent\":[\"X\"]},\"body\":\"\"}}\n```\n\nThe **id** is a unique identifier that is generated when a request is rejected by teler-waf. It is included in the HTTP response headers of the request (`X-Teler-Req-Id`), and can be used to troubleshoot issues with requests that are being made to the website.\n\nFor example, if a request to a website returns an HTTP error status code, such as a 403 Forbidden, the teler request ID can be used to identify the specific request that caused the error and help troubleshoot the issue.\n\nTeler request IDs are used by teler-waf to track requests made to its web application and can be useful for debugging and analyzing traffic patterns on a website.\n\n#### Demo\n\nYou are free to use the following site for testing, https://waf.teler.app.\n\n## Limitations\n\nHere are some limitations of using teler-waf:\n\n- **Performance overhead**: teler-waf may introduce some performance overhead, as the teler-waf will need to process each incoming request. If you have a high volume of traffic, this can potentially slow down the overall performance of your application significantly, _especially_ if you enable the CVEs threat detection. See benchmark below:\n\n```console\n$ go test -bench . -cpu=4\ngoos: linux\ngoarch: amd64\npkg: github.com/kitabisa/teler-waf\ncpu: 11th Gen Intel(R) Core(TM) i9-11900H @ 2.50GHz\nBenchmarkTelerDefaultOptions-4               \t    4530\t    265197 ns/op\t   35710 B/op\t    1690 allocs/op\nBenchmarkTelerCommonWebAttackOnly-4          \t   32484\t     35325 ns/op\t    5949 B/op\t     118 allocs/op\nBenchmarkTelerCVEOnly-4                      \t    6248\t    187397 ns/op\t   33402 B/op\t    1647 allocs/op\nBenchmarkTelerBadIPAddressOnly-4             \t   20649\t     54890 ns/op\t    5974 B/op\t      86 allocs/op\nBenchmarkTelerBadReferrerOnly-4              \t   48594\t     22629 ns/op\t    5548 B/op\t      87 allocs/op\nBenchmarkTelerBadCrawlerOnly-4               \t   41832\t     26891 ns/op\t    5634 B/op\t      85 allocs/op\nBenchmarkTelerDirectoryBruteforceOnly-4      \t   48087\t     22008 ns/op\t    5554 B/op\t      84 allocs/op\nBenchmarkTelerCustomRule-4                   \t   50428\t     21523 ns/op\t    5323 B/op\t      84 allocs/op\nBenchmarkTelerWithoutCommonWebAttack-4       \t    5133\t    230608 ns/op\t   34619 B/op\t    1654 allocs/op\nBenchmarkTelerWithoutCVE-4                   \t   15229\t     75995 ns/op\t    7169 B/op\t     124 allocs/op\nBenchmarkTelerWithoutBadIPAddress-4          \t    5677\t    211478 ns/op\t   34602 B/op\t    1685 allocs/op\nBenchmarkTelerWithoutBadReferrer-4           \t    4875\t    240689 ns/op\t   35127 B/op\t    1684 allocs/op\nBenchmarkTelerWithoutBadCrawler-4            \t    4922\t    238995 ns/op\t   35000 B/op\t    1686 allocs/op\nBenchmarkTelerWithoutDirectoryBruteforce-4   \t    4894\t    242973 ns/op\t   35241 B/op\t    1687 allocs/op\nPASS\nok  \tgithub.com/kitabisa/teler-waf\t23.207s\n```\n\n> **Note**: It's important to note that the benchmarking results may vary and may not be consistent. Those results were obtained when there were **>1.5k** CVE templates and the [teler-resources](https://github.com/kitabisa/teler-resources) dataset may have increased since then, which may impact the results.\n\n- **Configuration complexity**: Configuring teler-waf to suit the specific needs of your application can be complex, and may require a certain level of expertise in web security. This can make it difficult for those who are not familiar with application firewalls and IDS systems to properly set up and use teler-waf.\n- **Limited protection**: teler-waf is not a perfect security solution, and it may not be able to protect against all possible types of attacks. As with any security system, it is important to regularly monitor and maintain teler-waf to ensure that it is providing the desired level of protection.\n\n#### Known Issues\n\nTo view a list of known issues with teler-waf, please filter the issues by the [\"known-issue\" label](https://github.com/kitabisa/teler-waf/issues?q=is%3Aopen+is%3Aissue+label%3Aknown-issue).\n\n## License\n\nThis program is developed and maintained by members of Kitabisa Security Team, and this is not an officially supported Kitabisa product. This program is free software: you can redistribute it and/or modify it under the terms of the [Apache license](/LICENSE). Kitabisa teler-waf and any contributions are copyright \u00a9 by Dwi Siswanto 2022-2023.", "package teler\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"net/http\"\n\t\"net/url\"\n\t\"path/filepath\"\n\n\t\"github.com/kitabisa/teler-waf/request\"\n\t\"github.com/kitabisa/teler-waf/threat\"\n\t\"github.com/scorpionknifes/go-pcre\"\n\t\"golang.org/x/net/publicsuffix\"\n)\n\n// Analyze runs the actual checks.\nfunc (t *Teler) Analyze(w http.ResponseWriter, r *http.Request) error {\n\t_, err := t.analyzeRequest(w, r)\n\n\treturn err\n}\n\n/*\nanalyzeRequest checks an incoming HTTP request for certain types of threats or vulnerabilities.\nIf a threat is detected, the function returns an error and the request is stopped from continuing through the middleware chain.\n\nThe function takes in two arguments: a http.ResponseWriter and an http.Request.\nIt returns a threat type and an error value.\n\nThe function first checks the request against any custom rules defined in the Teler struct.\nIf a custom rule is violated, the function returns an error with the name of the violated rule as the message.\nIf no custom rules are violated, the function continues processing.\n\nThe function then checks whether the request URI, headers, or client IP address are included\nin a whitelist of patterns. If any of those values are in the whitelist, the function returns early.\n\nThe function then retrieves the threat struct from the Teler struct.\nIt iterates over the elements in the excludes map of the threat struct.\nFor each element in the excludes map, the function checks whether the value is true.\nIf it is true, the loop continues to the next iteration.\nOtherwise, the function performs a check based on the type of threat specified by the key in the excludes map.\n\nThe types of threats that are checked for are:\n\n- Common web attacks\n- Common Vulnerabilities and Exposures (CVEs)\n- Bad IP addresses\n- Bad referrers\n- Bad crawlers\n- Directory bruteforce attacks\n*/\nfunc (t *Teler) analyzeRequest(w http.ResponseWriter, r *http.Request) (threat.Threat, error) {\n\tvar err error\n\n\t// Check the request against custom rules\n\tif err = t.checkCustomRules(r); err != nil {\n\t\treturn threat.Custom, err\n\t}\n\n\t// Check the request against the whitelists\n\tif t.inWhitelist(r) {\n\t\treturn threat.Undefined, nil\n\t}\n\n\t// Retrieve the threat struct from the Teler struct\n\tth := t.threat\n\n\t// Iterate over the excludes map in the threat struct\n\tfor k, v := range th.excludes {\n\t\t// If the value in the excludes map is true, skip to the next iteration\n\t\tif v {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Check for the threat type specified by the key in the excludes map\n\t\tswitch k {\n\t\tcase threat.CommonWebAttack:\n\t\t\terr = t.checkCommonWebAttack(r) // Check for common web attacks\n\t\tcase threat.CVE:\n\t\t\terr = t.checkCVE(r) // Check for Common Vulnerabilities and Exposures (CVEs)\n\t\tcase threat.BadIPAddress:\n\t\t\terr = t.checkBadIPAddress(r) // Check for bad IP addresses\n\t\tcase threat.BadReferrer:\n\t\t\terr = t.checkBadReferrer(r) // Check for bad referrers\n\t\tcase threat.BadCrawler:\n\t\t\terr = t.checkBadCrawler(r) // Check for bad crawlers\n\t\tcase threat.DirectoryBruteforce:\n\t\t\terr = t.checkDirectoryBruteforce(r) // Check for directory bruteforce attacks\n\t\t}\n\n\t\t// If a threat is detected, return the threat type and an error\n\t\tif err != nil {\n\t\t\treturn k, err\n\t\t}\n\t}\n\n\t// If no threats are detected, return Undefined and a nil error\n\treturn threat.Undefined, nil\n}\n\n// checkCustomRules checks the given http.Request against a set of custom rules defined in the Teler struct.\n// If any of the custom rules are violated, the function returns an error with the name of the violated rule as the message.\n// If no custom rules are violated, the function returns nil.\nfunc (t *Teler) checkCustomRules(r *http.Request) error {\n\t// Converts map of headers to RAW string\n\theaders := headersToRawString(r.Header)\n\n\t// Decode the URL-encoded request URI of the URL\n\turi := toURLDecode(r.URL.RequestURI())\n\n\t// Declare byte slice for request body.\n\tvar body string\n\n\t// Initialize buffer to hold request body.\n\tbuf := &bytes.Buffer{}\n\n\t// Use io.Copy to copy the request body to the buffer.\n\t_, err := io.Copy(buf, r.Body)\n\tif err == nil {\n\t\t// If the read not fails, replace the request body\n\t\t// with a new io.ReadCloser that reads from the buffer.\n\t\tr.Body = io.NopCloser(buf)\n\n\t\t// Convert the buffer to a string.\n\t\tbody = buf.String()\n\t}\n\n\t// Decode the URL-encoded of body\n\tbody = toURLDecode(body)\n\n\t// Iterate over the Customs field of the Teler struct, which is a slice of custom rules\n\tfor _, rule := range t.opt.Customs {\n\t\t// Initialize the found match counter to zero\n\t\tf := 0\n\n\t\t// Iterate over the Rules field of the current custom rule, which is a slice of rule conditions\n\t\tfor _, cond := range rule.Rules {\n\t\t\tok := false\n\n\t\t\t// Check if the Method field of the current rule condition matches the request method\n\t\t\t// If the Method field is ALL, match any request method\n\t\t\tswitch {\n\t\t\tcase cond.Method == request.ALL:\n\t\t\tcase string(cond.Method) == r.Method:\n\t\t\t\tok = true\n\t\t\t}\n\n\t\t\t// If the request method doesn't match, skip the current rule condition\n\t\t\tif !ok {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tok = false\n\n\t\t\t// Get the compiled regex pattern for the current rule condition\n\t\t\tpattern := cond.patternRegex\n\n\t\t\t// Check if the Element field of the current rule condition matches the request URI, headers, body, or any of them\n\t\t\t// If it matches, set ok to true\n\t\t\tswitch cond.Element {\n\t\t\tcase request.URI:\n\t\t\t\tok = pattern.MatchString(uri)\n\t\t\tcase request.Headers:\n\t\t\t\tok = pattern.MatchString(headers)\n\t\t\tcase request.Body:\n\t\t\t\tok = pattern.MatchString(body)\n\t\t\tcase request.Any:\n\t\t\t\tok = (pattern.MatchString(uri) || pattern.MatchString(headers) || pattern.MatchString(body))\n\t\t\t}\n\n\t\t\t// If the rule condition is satisfied, increment the found match counter\n\t\t\tif ok {\n\t\t\t\t// If the rule condition \"or\", return an error with the Name field of the custom rule as the message\n\t\t\t\t// If the rule condition is \"and\", increment the found match counter\n\t\t\t\tswitch rule.Condition {\n\t\t\t\tcase \"or\":\n\t\t\t\t\treturn errors.New(rule.Name)\n\t\t\t\tcase \"and\":\n\t\t\t\t\tf++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If the rule condition is \"and\", and number of found matches is equal to the number of rule conditions,\n\t\t// return an error with the Name field of the custom rule as the message\n\t\tif rule.Condition == \"and\" && f >= len(rule.Rules) {\n\t\t\treturn errors.New(rule.Name)\n\t\t}\n\t}\n\n\t// If no custom rules were violated, return nil\n\treturn nil\n}\n\n// checkCommonWebAttack checks if the request contains any patterns that match the common web attacks data.\n// If a match is found, it returns an error indicating a common web attack has been detected.\n// If no match is found, it returns nil.\nfunc (t *Teler) checkCommonWebAttack(r *http.Request) error {\n\t// Decode the URL-encoded request URI of the URL\n\turi := toURLDecode(r.URL.RequestURI())\n\n\t// Declare byte slice for request body.\n\tvar body string\n\n\t// Initialize buffer to hold request body.\n\tbuf := &bytes.Buffer{}\n\n\t// Use io.Copy to copy the request body to the buffer.\n\t_, err := io.Copy(buf, r.Body)\n\tif err == nil {\n\t\t// If the read not fails, replace the request body\n\t\t// with a new io.ReadCloser that reads from the buffer.\n\t\tr.Body = io.NopCloser(buf)\n\n\t\t// Convert the buffer to a string.\n\t\tbody = buf.String()\n\t}\n\n\t// Decode the URL-encoded of body\n\tbody = toURLDecode(body)\n\n\t// Iterate over the filters in the CommonWebAttack data stored in the t.threat.cwa.Filters field\n\tfor _, filter := range t.threat.cwa.Filters {\n\t\t// Initialize a variable to track whether a match is found\n\t\tvar match bool\n\n\t\t// Check the type of the filter's pattern\n\t\tswitch pattern := filter.pattern.(type) {\n\t\tcase *regexp.Regexp: // If the pattern is a regex\n\t\t\tmatch = pattern.MatchString(uri) || pattern.MatchString(body)\n\t\tcase *pcre.Matcher: // If the pattern is a PCRE expr\n\t\t\tmatch = pattern.MatchString(uri, 0) || pattern.MatchString(body, 0)\n\t\tdefault: // If the pattern is of an unknown type, skip to the next iteration\n\t\t\tcontinue\n\t\t}\n\n\t\t// If the pattern matches the request URI or body, return an error indicating a common web attack has been detected\n\t\tif match {\n\t\t\treturn errors.New(filter.Description)\n\t\t}\n\t}\n\n\t// Return nil if no match is found\n\treturn nil\n}\n\n// checkCVE checks the request against a set of templates to see if it matches a known\n// Common Vulnerabilities and Exposures (CVE) threat.\n// It takes a pointer to an HTTP request as an input and returns an error if the request\n// matches a known threat. Otherwise, it returns nil.\nfunc (t *Teler) checkCVE(r *http.Request) error {\n\t// data is the set of templates to check against.\n\tcveData := t.threat.cve\n\n\t// kind is the type of template to check (either \"path\" or \"raw\").\n\tvar kind string\n\n\t// requestParams is a map that stores the query parameters of the request URI and\n\t// iterate over the query parameters of the request URI and add them to the map.\n\trequestParams := make(map[string]string)\n\tfor q, v := range r.URL.Query() {\n\t\trequestParams[q] = v[0]\n\t}\n\n\t// Iterate over the templates in the data set.\n\tfor _, cveTemplate := range cveData.GetArray(\"templates\") {\n\t\t// ID is the current CVE ID of the templates\n\t\tcveID := string(cveTemplate.GetStringBytes(\"id\"))\n\n\t\t// Iterate over the requests in the template.\n\t\tfor _, request := range cveTemplate.GetArray(\"requests\") {\n\t\t\t// Determine the kind of template (either \"path\" or \"raw\").\n\t\t\tswitch {\n\t\t\tcase len(request.GetArray(\"path\")) > 0:\n\t\t\t\tkind = \"path\"\n\t\t\tcase len(request.GetArray(\"raw\")) > 0:\n\t\t\t\tkind = \"raw\"\n\t\t\t}\n\n\t\t\t// If the template is a \"path\" type and the request method doesn't match, skip this template.\n\t\t\tif kind == \"path\" && string(request.GetStringBytes(\"method\")) != r.Method {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Iterate over the CVE URLs\n\t\t\tfor _, cve := range cveURL[cveID] {\n\t\t\t\t// If the CVE path is empty or contains only a single character, skip this CVE URL.\n\t\t\t\tif len(cve.Path) <= 1 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// If the request path doesn't match the CVE path, skip this CVE URL.\n\t\t\t\tif r.URL.Path != cve.Path {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// diffParams is a map that stores the query parameters of the CVE URI and iterate over the\n\t\t\t\t// query parameters of the CVE URI and add them to the diffParams map.\n\t\t\t\tdiffParams := make(map[string]string)\n\t\t\t\tfor q, v := range cve.Query() {\n\t\t\t\t\tdiffParams[q] = v[0]\n\t\t\t\t}\n\n\t\t\t\t// allParamsMatch is a flag that indicates whether all the query parameters in the CVE URI are\n\t\t\t\t// present in the request URI and iterate over the query parameters of the CVE URI.\n\t\t\t\tallParamsMatch := true\n\t\t\t\tfor q, v := range diffParams {\n\t\t\t\t\t// If a query parameter in the CVE URI is not present in the request URI,\n\t\t\t\t\t// set allParamsMatch to false and break out of the loop.\n\t\t\t\t\tif requestParams[q] != v {\n\t\t\t\t\t\tallParamsMatch = false\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If all the query parameters in the CVE URI are present in the request URI, return an error of CVE ID.\n\t\t\t\tif allParamsMatch {\n\t\t\t\t\treturn errors.New(cveID)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return nil if the request doesn't match any known threat.\n\treturn nil\n}\n\n// checkBadIPAddress checks if the client IP address is in the BadIPAddress index.\n// It returns an error if the client IP address is found in the index, indicating a bad IP address.\n// Otherwise, it returns nil.\nfunc (t *Teler) checkBadIPAddress(r *http.Request) error {\n\t// Get the client's IP address\n\tclientIP := getClientIP(r)\n\n\t// Check if the client IP address is in BadIPAddress index\n\tif t.inThreatIndex(threat.BadIPAddress, clientIP) {\n\t\t// Return an error indicating a bad IP address has been detected\n\t\treturn errors.New(\"bad IP address\")\n\t}\n\n\t// Return nil if the remote address is not found in the index\n\treturn nil\n}\n\n// checkBadReferrer checks if the request referer header is from a known bad referer.\n// It does this by parsing the referer URL, extracting the hostname, and then finding the effective top-level domain plus one.\n// The resulting domain is then checked against the BadReferrer index in the threat struct.\n// If the domain is found in the index, an error indicating a bad HTTP referer is returned.\n// Otherwise, nil is returned.\nfunc (t *Teler) checkBadReferrer(r *http.Request) error {\n\t// Parse the request referer URL\n\tref, err := url.Parse(r.Referer())\n\tif err != nil {\n\t\t// If there is an error parsing the URL, return nil\n\t\t// TODO: What should we do so as not to stop the threat analysis chain from analyzeRequest?\n\t\treturn nil\n\t}\n\n\t// Extract the effective top-level domain plus one from the hostname of the referer URL\n\teTLD1, err := publicsuffix.EffectiveTLDPlusOne(ref.Hostname())\n\tif err != nil {\n\t\t// If there is an error extracting the effective top-level domain plus one, return nil\n\t\t// TODO: What should we do so as not to stop the threat analysis chain from analyzeRequest?\n\t\treturn nil\n\t}\n\n\t// Check if the root domain of request referer header is in the BadReferrer index\n\tif t.inThreatIndex(threat.BadReferrer, eTLD1) {\n\t\t// If the domain is found in the index, return an error indicating a bad HTTP referer\n\t\treturn errors.New(\"bad HTTP referer\")\n\t}\n\n\t// Return nil if no match is found in the BadReferrer index\n\treturn nil\n}\n\n// checkBadCrawler checks the request for bad crawler activity.\n// It retrieves the User-Agent from the request and iterates over\n// the compiled regular expressions in the badCrawler field of the threat struct.\n// If any of the regular expressions match the User-Agent,\n// it returns an error with the message \"bad crawler\".\n// If the User-Agent is empty or no regular expressions match,\n// it returns nil.\nfunc (t *Teler) checkBadCrawler(r *http.Request) error {\n\t// Retrieve the User-Agent from the request\n\tua := r.UserAgent()\n\n\t// Do not process the check if User-Agent is empty\n\tif ua == \"\" {\n\t\treturn nil\n\t}\n\n\t// Iterate over BadCrawler compiled patterns and do the check\n\tfor _, pattern := range t.threat.badCrawler {\n\t\t// Initialize a variable to track whether a match is found\n\t\tvar match bool\n\n\t\t// Check the type of the pattern\n\t\tswitch p := pattern.(type) {\n\t\tcase *regexp.Regexp: // If the pattern is a regex\n\t\t\tmatch = p.MatchString(ua)\n\t\tcase *pcre.Matcher: // If the pattern is a PCRE expr\n\t\t\tmatch = p.MatchString(ua, 0)\n\t\tdefault: // If the pattern is of an unknown type, skip to the next iteration\n\t\t\tcontinue\n\t\t}\n\n\t\t// Check if the pattern is not nil and matches the User-Agent\n\t\tif match {\n\t\t\treturn errors.New(\"bad crawler\")\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// checkDirectoryBruteforce checks the request for a directory bruteforce attack.\n// It extracts the file extension from the request path, creates a regex pattern\n// that matches the entire request path, and replaces any instances of .%EXT% in\n// the directory bruteforce data with the file extension. It then checks if the\n// pattern matches the data using regexp.MatchString. If a match is found, it\n// returns an error indicating a directory bruteforce attack has been detected.\n// If no match is found or there was an error during the regex matching process,\n// it returns nil.\nfunc (t *Teler) checkDirectoryBruteforce(r *http.Request) error {\n\t// Extract the file extension from the request path and if\n\t// file extension is empty string, do not process the check\n\text := filepath.Ext(r.URL.Path)\n\tif ext == \"\" {\n\t\treturn nil\n\t}\n\n\t// Trim the leading slash from the request path, and if path\n\t// is empty string after the trim, do not process the check\n\tpath := strings.TrimLeft(r.URL.Path, \"/\")\n\tif path == \"\" {\n\t\treturn nil\n\t}\n\n\t// Create a regex pattern that matches the entire request path\n\tpattern := fmt.Sprintf(\"(?m)^%s$\", regexp.QuoteMeta(path))\n\n\t// Replace any instances of .%EXT% in the directory bruteforce data with the file extension\n\tdata := strings.ReplaceAll(t.threat.data[threat.DirectoryBruteforce], \".%EXT%\", ext)\n\n\t// Check if the pattern matches the data using regexp.MatchString\n\tmatch, err := regexp.MatchString(pattern, data)\n\tif err != nil {\n\t\t// Return nil if there was an error during the regex matching process\n\t\treturn nil\n\t}\n\n\t// If the pattern matches the data, return an error indicating a directory bruteforce attack has been detected\n\tif match {\n\t\treturn errors.New(\"directory bruteforce\")\n\t}\n\n\t// Return nil if no match is found\n\treturn nil\n}\n", "package teler\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"net/http\"\n\n\t\"github.com/kitabisa/teler-waf/request\"\n\t\"github.com/kitabisa/teler-waf/threat\"\n\t\"gitlab.com/golang-commonmark/mdurl\"\n)\n\n// inThreatIndex checks if the given substring is in specific threat datasets\nfunc (t *Teler) inThreatIndex(kind threat.Threat, substr string) bool {\n\tif i := strings.Index(t.threat.data[kind], substr); i >= 0 {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// inWhitelist checks if the given substring is in whitelist patterns\nfunc (t *Teler) inWhitelist(r *http.Request) bool {\n\turi := toURLDecode(r.URL.RequestURI())\n\theaders := headersToRawString(r.Header)\n\tclientIP := getClientIP(r)\n\n\t// Check the request URI, headers, and client IP address against the whitelist\n\tfor _, pattern := range t.whitelistRegexes {\n\t\tif pattern.MatchString(uri) || pattern.MatchString(headers) || pattern.MatchString(clientIP) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// headersToRawString converts a map of http.Header to\n// multiline string, example:\n// from,\n//\n//\tHeader = map[string][]string{\n//\t\t\"Accept-Encoding\": {\"gzip, deflate\"},\n//\t\t\"Accept-Language\": {\"en-us\"},\n//\t\t\"Foo\": {\"Bar\", \"two\"},\n//\t}\n//\n// to\n//\n//\tHost: example.com\n//\taccept-encoding: gzip, deflate\n//\tAccept-Language: en-us\n//\tfOO: Bar\n//\tfoo: two\nfunc headersToRawString(headers http.Header) string {\n\tvar h strings.Builder\n\n\t// Iterate over the request headers and append each key-value pair to the builder\n\tfor key, values := range headers {\n\t\tfor _, value := range values {\n\t\t\th.WriteString(\n\t\t\t\tfmt.Sprintf(\"%s: %s\\n\", toURLDecode(key), toURLDecode(value)),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Returns the accumulated string of builder\n\treturn h.String()\n}\n\n// toURLDecode decode URL-decoded characters string using mdurl package\nfunc toURLDecode(s string) string {\n\treturn mdurl.Decode(s)\n}\n\n// isValidMethod check if the given request.Method is valid\nfunc isValidMethod(method request.Method) bool {\n\tswitch method {\n\tcase request.GET, request.HEAD, request.POST, request.PUT, request.PATCH:\n\tcase request.DELETE, request.CONNECT, request.OPTIONS, request.TRACE, request.ALL:\n\tcase \"\":\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// normalizeRawStringReader trim double-quotes of HTTP raw string,\n// replace double-escape of CR and LF, and double it in the end, and\n// returning as pointer of strings.Reader\nfunc normalizeRawStringReader(raw string) *strings.Reader {\n\tvar builder strings.Builder\n\n\traw = strings.Trim(raw, `\"`)\n\traw = strings.ReplaceAll(raw, \"\\\\n\", \"\\n\")\n\traw = strings.ReplaceAll(raw, \"\\\\r\", \"\\r\")\n\tbuilder.WriteString(raw)\n\tbuilder.WriteString(\"\\r\\n\\r\\n\")\n\n\treturn strings.NewReader(builder.String())\n}\n\n// getClientIP to get client IP address from request\nfunc getClientIP(r *http.Request) string {\n\t// Get the client's IP address from the X-Real-Ip header field\n\tclientIP := r.Header.Get(\"X-Real-Ip\")\n\n\t// If the X-Real-Ip header field is not present, try the X-Forwarded-For header field\n\tif clientIP == \"\" {\n\t\tclientIP = r.Header.Get(\"X-Forwarded-For\")\n\t}\n\n\t// If the X-Forwarded-For header field is not present, use the RemoteAddr field\n\tif clientIP == \"\" {\n\t\tclientIP = r.RemoteAddr\n\t}\n\n\t// Returning client IP address\n\treturn clientIP\n}\n"], "fixing_code": ["# teler-waf\n\n[![Kitabisa Security](https://img.shields.io/badge/kitabisa-security%20project-blue)](#)\n[![GoDoc](https://pkg.go.dev/static/frontend/badge/badge.svg)](http://pkg.go.dev/github.com/kitabisa/teler-waf)\n[![tests](https://github.com/kitabisa/teler-waf/actions/workflows/test.yaml/badge.svg)](https://github.com/kitabisa/teler-waf/actions/workflows/test.yaml)\n\n<img src=\"https://user-images.githubusercontent.com/25837540/97091757-7200d880-1668-11eb-82c4-e5c4971d2bc8.png\" align=\"right\" width=\"250px\"/>\n\n**teler-waf** is a comprehensive security solution for Go-based web applications. It acts as an HTTP middleware, providing an easy-to-use interface for integrating IDS functionality with [teler IDS](https://github.com/kitabisa/teler-waf) into existing Go applications. By using teler-waf, you can help protect against a variety of web-based attacks, such as cross-site scripting (XSS) and SQL injection.\n\nThe package comes with a standard [`net/http.Handler`](https://pkg.go.dev/net/http#Handler), making it easy to integrate into your application's routing. When a client makes a request to a route protected by teler-waf, the request is first checked against the teler IDS to detect known malicious patterns. If no malicious patterns are detected, the request is then passed through for further processing.\n\nIn addition to providing protection against web-based attacks, teler-waf can also help improve the overall security and integrity of your application. It is highly configurable, allowing you to tailor it to fit the specific needs of your application.\n\n**See also:**\n\n- [kitabisa/teler](https://github.com/kitabisa/teler): Real-time HTTP intrusion detection.\n- [dwisiswant0/cox](https://github.com/dwisiswant0/cox): Cox is [bluemonday](https://github.com/microcosm-cc/bluemonday)-wrapper to perform a deep-clean and/or sanitization of <i>(nested-)</i>interfaces from HTML to prevent XSS payloads.\n\n## Features\n\nSome core features of teler-waf include:\n\n- **HTTP middleware** for Go web applications.\n- Integration of **teler IDS** functionality.\n- **Detection of known malicious patterns** using the teler IDS.\n  - Common web attacks, such as cross-site scripting (XSS) and SQL injection, etc.\n  - CVEs, covers known vulnerabilities and exploits.\n  - Bad IP addresses, such as those associated with known malicious actors or botnets.\n  - Bad HTTP referers, such as those that are not expected based on the application's URL structure or are known to be associated with malicious actors.\n  - Bad crawlers, covers requests from known bad crawlers or scrapers, such as those that are known to cause performance issues or attempt to extract sensitive information from the application.\n  - Directory bruteforce attacks, such as by trying common directory names or using dictionary attacks.\n- Configuration options to **whitelist specific types of requests** based on their URL or headers.\n- **Easy integration** with many frameworks.\n- **High configurability** to fit the specific needs of your application.\n\nOverall, teler-waf provides a comprehensive security solution for Go-based web applications, helping to protect against web-based attacks and improve the overall security and integrity of your application.\n\n## Install\n\nTo install teler-waf in your Go application, run the following command to download and install the teler-waf package:\n\n```console\ngo get github.com/kitabisa/teler-waf\n```\n\n## Usage\n\nHere is an example of how to use teler-waf in a Go application:\n\n1. Import the teler-waf package in your Go code:\n\n```go\nimport \"github.com/kitabisa/teler-waf\"\n```\n\n2. Use the `New` function to create a new instance of the `Teler` type. This function takes a variety of optional parameters that can be used to configure teler-waf to suit the specific needs of your application.\n\n```go\nwaf := teler.New()\n```\n\n3. Use the `Handler` method of the `Teler` instance to create a `net/http.Handler`. This handler can then be used in your application's HTTP routing to apply teler-waf's security measures to specific routes.\n\n```go\nhandler := waf.Handler(http.HandlerFunc(yourHandlerFunc))\n```\n\n4. Use the `handler` in your application's HTTP routing to apply teler-waf's security measures to specific routes.\n\n```go\nhttp.Handle(\"/path\", handler)\n```\n\nThat's it! You have configured teler-waf in your Go application.\n\n**Options:**\n\nFor a list of the options available to customize teler-waf, see the [`teler.Options`](https://pkg.go.dev/github.com/kitabisa/teler-waf#Options) struct.\n\n### Examples\n\nHere is an example of how to customize the options and rules for teler-waf:\n\n```go\n// main.go\npackage main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/kitabisa/teler-waf\"\n\t\"github.com/kitabisa/teler-waf/request\"\n\t\"github.com/kitabisa/teler-waf/threat\"\n)\n\nvar myHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t// This is the handler function for the route that we want to protect\n\t// with teler-waf's security measures.\n\tw.Write([]byte(\"hello world\"))\n})\n\nvar rejectHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t// This is the handler function for the route that we want to be rejected\n\t// if the teler-waf's security measures are triggered.\n\thttp.Error(w, \"Sorry, your request has been denied for security reasons.\", http.StatusForbidden)\n})\n\nfunc main() {\n\t// Create a new instance of the Teler type using the New function\n\t// and configure it using the Options struct.\n\ttelerMiddleware := teler.New(teler.Options{\n\t\t// Exclude specific threats from being checked by the teler-waf.\n\t\tExcludes: []threat.Threat{\n\t\t\tthreat.BadReferrer,\n\t\t\tthreat.BadCrawler,\n\t\t},\n\t\t// Specify whitelisted URIs (path & query parameters), headers,\n\t\t// or IP addresses that will always be allowed by the teler-waf.\n\t\tWhitelists: []string{\n\t\t\t`(curl|Go-http-client|okhttp)/*`,\n\t\t\t`^/wp-login\\.php`,\n\t\t\t`(?i)Referer: https?:\\/\\/www\\.facebook\\.com`,\n\t\t\t`192\\.168\\.0\\.1`,\n\t\t},\n\t\t// Specify custom rules for the teler-waf to follow.\n\t\tCustoms: []teler.Rule{\n\t\t\t{\n\t\t\t\t// Give the rule a name for easy identification.\n\t\t\t\tName:      \"Log4j Attack\",\n\t\t\t\t// Specify the logical operator to use when evaluating the rule's conditions.\n\t\t\t\tCondition: \"or\",\n\t\t\t\t// Specify the conditions that must be met for the rule to trigger.\n\t\t\t\tRules: []teler.Condition{\n\t\t\t\t\t{\n\t\t\t\t\t\t// Specify the HTTP method that the rule applies to.\n\t\t\t\t\t\tMethod: request.GET,\n\t\t\t\t\t\t// Specify the element of the request that the rule applies to\n\t\t\t\t\t\t// (e.g. URI, headers, body).\n\t\t\t\t\t\tElement: request.URI,\n\t\t\t\t\t\t// Specify the pattern to match against the element of the request.\n\t\t\t\t\t\tPattern: `\\$\\{.*:\\/\\/.*\\/?\\w+?\\}`,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t// Specify the file path to use for logging.\n\t\tLogFile: \"/tmp/teler.log\",\n\t})\n\n\t// Set the rejectHandler as the handler for the telerMiddleware.\n\ttelerMiddleware.SetHandler(rejectHandler)\n\n\t// Create a new handler using the handler method of the Teler instance\n\t// and pass in the myHandler function for the route we want to protect.\n\tapp := telerMiddleware.Handler(myHandler)\n\n\t// Use the app handler as the handler for the route.\n\thttp.ListenAndServe(\"127.0.0.1:3000\", app)\n}\n```\n\nFor more examples of how to use teler-waf or integrate it with any framework, take a look at [examples/](https://github.com/kitabisa/teler-waf/tree/master/examples) directory.\n\n#### Logs\n\nHere is an example of what the log lines would look like if teler-waf detects a threat on a request:\n\n```json\n{\"level\":\"warn\",\"ts\":1672261174.5995026,\"msg\":\"bad crawler\",\"id\":\"654b85325e1b2911258a\",\"category\":\"BadCrawler\",\"request\":{\"method\":\"GET\",\"path\":\"/\",\"ip_addr\":\"127.0.0.1:37702\",\"headers\":{\"Accept\":[\"*/*\"],\"User-Agent\":[\"curl/7.81.0\"]},\"body\":\"\"}}\n{\"level\":\"warn\",\"ts\":1672261175.9567692,\"msg\":\"directory bruteforce\",\"id\":\"b29546945276ed6b1fba\",\"category\":\"DirectoryBruteforce\",\"request\":{\"method\":\"GET\",\"path\":\"/.git\",\"ip_addr\":\"127.0.0.1:37716\",\"headers\":{\"Accept\":[\"*/*\"],\"User-Agent\":[\"X\"]},\"body\":\"\"}}\n{\"level\":\"warn\",\"ts\":1672261177.1487508,\"msg\":\"Detects common comment types\",\"id\":\"75412f2cc0ec1cf79efd\",\"category\":\"CommonWebAttack\",\"request\":{\"method\":\"GET\",\"path\":\"/?id=1%27%20or%201%3D1%23\",\"ip_addr\":\"127.0.0.1:37728\",\"headers\":{\"Accept\":[\"*/*\"],\"User-Agent\":[\"X\"]},\"body\":\"\"}}\n```\n\nThe **id** is a unique identifier that is generated when a request is rejected by teler-waf. It is included in the HTTP response headers of the request (`X-Teler-Req-Id`), and can be used to troubleshoot issues with requests that are being made to the website.\n\nFor example, if a request to a website returns an HTTP error status code, such as a 403 Forbidden, the teler request ID can be used to identify the specific request that caused the error and help troubleshoot the issue.\n\nTeler request IDs are used by teler-waf to track requests made to its web application and can be useful for debugging and analyzing traffic patterns on a website.\n\n#### Demo\n\nYou are free to use the following site for testing, https://waf.teler.app.\n\n## Limitations\n\nHere are some limitations of using teler-waf:\n\n- **Performance overhead**: teler-waf may introduce some performance overhead, as the teler-waf will need to process each incoming request. If you have a high volume of traffic, this can potentially slow down the overall performance of your application significantly, _especially_ if you enable the CVEs threat detection. See benchmark below:\n\n```console\n$ go test -bench . -cpu=4\ngoos: linux\ngoarch: amd64\npkg: github.com/kitabisa/teler-waf\ncpu: 11th Gen Intel(R) Core(TM) i9-11900H @ 2.50GHz\nBenchmarkTelerDefaultOptions-4               \t    4396\t    266918 ns/op\t   35944 B/op\t    1696 allocs/op\nBenchmarkTelerCommonWebAttackOnly-4          \t   30795\t     35602 ns/op\t    5990 B/op\t     118 allocs/op\nBenchmarkTelerCVEOnly-4                      \t    6171\t    194193 ns/op\t   33533 B/op\t    1652 allocs/op\nBenchmarkTelerBadIPAddressOnly-4             \t   20464\t     55957 ns/op\t    5986 B/op\t      86 allocs/op\nBenchmarkTelerBadReferrerOnly-4              \t   48403\t     23128 ns/op\t    5551 B/op\t      87 allocs/op\nBenchmarkTelerBadCrawlerOnly-4               \t   42002\t     27165 ns/op\t    5633 B/op\t      85 allocs/op\nBenchmarkTelerDirectoryBruteforceOnly-4      \t   50103\t     23074 ns/op\t    5535 B/op\t      84 allocs/op\nBenchmarkTelerCustomRule-4                   \t   49483\t     22086 ns/op\t    5332 B/op\t      84 allocs/op\nBenchmarkTelerWithoutCommonWebAttack-4       \t    5156\t    228950 ns/op\t   34683 B/op\t    1658 allocs/op\nBenchmarkTelerWithoutCVE-4                   \t   15295\t     76501 ns/op\t    7167 B/op\t     124 allocs/op\nBenchmarkTelerWithoutBadIPAddress-4          \t    5484\t    216523 ns/op\t   34820 B/op\t    1691 allocs/op\nBenchmarkTelerWithoutBadReferrer-4           \t    4894\t    240202 ns/op\t   35133 B/op\t    1689 allocs/op\nBenchmarkTelerWithoutBadCrawler-4            \t    5012\t    239976 ns/op\t   34995 B/op\t    1691 allocs/op\nBenchmarkTelerWithoutDirectoryBruteforce-4   \t    4736\t    247549 ns/op\t   35496 B/op\t    1693 allocs/op\nPASS\nok  \tgithub.com/kitabisa/teler-waf\t23.660s\n```\n\n> **Note**: It's important to note that the benchmarking results may vary and may not be consistent. Those results were obtained when there were **>1.5k** CVE templates and the [teler-resources](https://github.com/kitabisa/teler-resources) dataset may have increased since then, which may impact the results.\n\n- **Configuration complexity**: Configuring teler-waf to suit the specific needs of your application can be complex, and may require a certain level of expertise in web security. This can make it difficult for those who are not familiar with application firewalls and IDS systems to properly set up and use teler-waf.\n- **Limited protection**: teler-waf is not a perfect security solution, and it may not be able to protect against all possible types of attacks. As with any security system, it is important to regularly monitor and maintain teler-waf to ensure that it is providing the desired level of protection.\n\n#### Known Issues\n\nTo view a list of known issues with teler-waf, please filter the issues by the [\"known-issue\" label](https://github.com/kitabisa/teler-waf/issues?q=is%3Aopen+is%3Aissue+label%3Aknown-issue).\n\n## License\n\nThis program is developed and maintained by members of Kitabisa Security Team, and this is not an officially supported Kitabisa product. This program is free software: you can redistribute it and/or modify it under the terms of the [Apache license](/LICENSE). Kitabisa teler-waf and any contributions are copyright \u00a9 by Dwi Siswanto 2022-2023.", "package teler\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"net/http\"\n\t\"net/url\"\n\t\"path/filepath\"\n\n\t\"github.com/kitabisa/teler-waf/request\"\n\t\"github.com/kitabisa/teler-waf/threat\"\n\t\"github.com/scorpionknifes/go-pcre\"\n\t\"golang.org/x/net/publicsuffix\"\n)\n\n// Analyze runs the actual checks.\nfunc (t *Teler) Analyze(w http.ResponseWriter, r *http.Request) error {\n\t_, err := t.analyzeRequest(w, r)\n\n\treturn err\n}\n\n/*\nanalyzeRequest checks an incoming HTTP request for certain types of threats or vulnerabilities.\nIf a threat is detected, the function returns an error and the request is stopped from continuing through the middleware chain.\n\nThe function takes in two arguments: a http.ResponseWriter and an http.Request.\nIt returns a threat type and an error value.\n\nThe function first checks the request against any custom rules defined in the Teler struct.\nIf a custom rule is violated, the function returns an error with the name of the violated rule as the message.\nIf no custom rules are violated, the function continues processing.\n\nThe function then checks whether the request URI, headers, or client IP address are included\nin a whitelist of patterns. If any of those values are in the whitelist, the function returns early.\n\nThe function then retrieves the threat struct from the Teler struct.\nIt iterates over the elements in the excludes map of the threat struct.\nFor each element in the excludes map, the function checks whether the value is true.\nIf it is true, the loop continues to the next iteration.\nOtherwise, the function performs a check based on the type of threat specified by the key in the excludes map.\n\nThe types of threats that are checked for are:\n\n- Common web attacks\n- Common Vulnerabilities and Exposures (CVEs)\n- Bad IP addresses\n- Bad referrers\n- Bad crawlers\n- Directory bruteforce attacks\n*/\nfunc (t *Teler) analyzeRequest(w http.ResponseWriter, r *http.Request) (threat.Threat, error) {\n\tvar err error\n\n\t// Check the request against custom rules\n\tif err = t.checkCustomRules(r); err != nil {\n\t\treturn threat.Custom, err\n\t}\n\n\t// Check the request against the whitelists\n\tif t.inWhitelist(r) {\n\t\treturn threat.Undefined, nil\n\t}\n\n\t// Retrieve the threat struct from the Teler struct\n\tth := t.threat\n\n\t// Iterate over the excludes map in the threat struct\n\tfor k, v := range th.excludes {\n\t\t// If the value in the excludes map is true, skip to the next iteration\n\t\tif v {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Check for the threat type specified by the key in the excludes map\n\t\tswitch k {\n\t\tcase threat.CommonWebAttack:\n\t\t\terr = t.checkCommonWebAttack(r) // Check for common web attacks\n\t\tcase threat.CVE:\n\t\t\terr = t.checkCVE(r) // Check for Common Vulnerabilities and Exposures (CVEs)\n\t\tcase threat.BadIPAddress:\n\t\t\terr = t.checkBadIPAddress(r) // Check for bad IP addresses\n\t\tcase threat.BadReferrer:\n\t\t\terr = t.checkBadReferrer(r) // Check for bad referrers\n\t\tcase threat.BadCrawler:\n\t\t\terr = t.checkBadCrawler(r) // Check for bad crawlers\n\t\tcase threat.DirectoryBruteforce:\n\t\t\terr = t.checkDirectoryBruteforce(r) // Check for directory bruteforce attacks\n\t\t}\n\n\t\t// If a threat is detected, return the threat type and an error\n\t\tif err != nil {\n\t\t\treturn k, err\n\t\t}\n\t}\n\n\t// If no threats are detected, return Undefined and a nil error\n\treturn threat.Undefined, nil\n}\n\n// checkCustomRules checks the given http.Request against a set of custom rules defined in the Teler struct.\n// If any of the custom rules are violated, the function returns an error with the name of the violated rule as the message.\n// If no custom rules are violated, the function returns nil.\nfunc (t *Teler) checkCustomRules(r *http.Request) error {\n\t// Converts map of headers to RAW string\n\theaders := headersToRawString(r.Header)\n\n\t// Decode the URL-encoded and unescape HTML entities request URI of the URL\n\turi := stringDeUnescape(r.URL.RequestURI())\n\n\t// Declare byte slice for request body.\n\tvar body string\n\n\t// Initialize buffer to hold request body.\n\tbuf := &bytes.Buffer{}\n\n\t// Use io.Copy to copy the request body to the buffer.\n\t_, err := io.Copy(buf, r.Body)\n\tif err == nil {\n\t\t// If the read not fails, replace the request body\n\t\t// with a new io.ReadCloser that reads from the buffer.\n\t\tr.Body = io.NopCloser(buf)\n\n\t\t// Convert the buffer to a string.\n\t\tbody = buf.String()\n\t}\n\n\t// Decode the URL-encoded and unescape HTML entities of body\n\tbody = stringDeUnescape(body)\n\n\t// Iterate over the Customs field of the Teler struct, which is a slice of custom rules\n\tfor _, rule := range t.opt.Customs {\n\t\t// Initialize the found match counter to zero\n\t\tf := 0\n\n\t\t// Iterate over the Rules field of the current custom rule, which is a slice of rule conditions\n\t\tfor _, cond := range rule.Rules {\n\t\t\tok := false\n\n\t\t\t// Check if the Method field of the current rule condition matches the request method\n\t\t\t// If the Method field is ALL, match any request method\n\t\t\tswitch {\n\t\t\tcase cond.Method == request.ALL:\n\t\t\tcase string(cond.Method) == r.Method:\n\t\t\t\tok = true\n\t\t\t}\n\n\t\t\t// If the request method doesn't match, skip the current rule condition\n\t\t\tif !ok {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tok = false\n\n\t\t\t// Get the compiled regex pattern for the current rule condition\n\t\t\tpattern := cond.patternRegex\n\n\t\t\t// Check if the Element field of the current rule condition matches the request URI, headers, body, or any of them\n\t\t\t// If it matches, set ok to true\n\t\t\tswitch cond.Element {\n\t\t\tcase request.URI:\n\t\t\t\tok = pattern.MatchString(uri)\n\t\t\tcase request.Headers:\n\t\t\t\tok = pattern.MatchString(headers)\n\t\t\tcase request.Body:\n\t\t\t\tok = pattern.MatchString(body)\n\t\t\tcase request.Any:\n\t\t\t\tok = (pattern.MatchString(uri) || pattern.MatchString(headers) || pattern.MatchString(body))\n\t\t\t}\n\n\t\t\t// If the rule condition is satisfied, increment the found match counter\n\t\t\tif ok {\n\t\t\t\t// If the rule condition \"or\", return an error with the Name field of the custom rule as the message\n\t\t\t\t// If the rule condition is \"and\", increment the found match counter\n\t\t\t\tswitch rule.Condition {\n\t\t\t\tcase \"or\":\n\t\t\t\t\treturn errors.New(rule.Name)\n\t\t\t\tcase \"and\":\n\t\t\t\t\tf++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If the rule condition is \"and\", and number of found matches is equal to the number of rule conditions,\n\t\t// return an error with the Name field of the custom rule as the message\n\t\tif rule.Condition == \"and\" && f >= len(rule.Rules) {\n\t\t\treturn errors.New(rule.Name)\n\t\t}\n\t}\n\n\t// If no custom rules were violated, return nil\n\treturn nil\n}\n\n// checkCommonWebAttack checks if the request contains any patterns that match the common web attacks data.\n// If a match is found, it returns an error indicating a common web attack has been detected.\n// If no match is found, it returns nil.\nfunc (t *Teler) checkCommonWebAttack(r *http.Request) error {\n\t// Decode the URL-encoded and unescape HTML entities request URI of the URL\n\turi := stringDeUnescape(r.URL.RequestURI())\n\n\t// Declare byte slice for request body.\n\tvar body string\n\n\t// Initialize buffer to hold request body.\n\tbuf := &bytes.Buffer{}\n\n\t// Use io.Copy to copy the request body to the buffer.\n\t_, err := io.Copy(buf, r.Body)\n\tif err == nil {\n\t\t// If the read not fails, replace the request body\n\t\t// with a new io.ReadCloser that reads from the buffer.\n\t\tr.Body = io.NopCloser(buf)\n\n\t\t// Convert the buffer to a string.\n\t\tbody = buf.String()\n\t}\n\n\t// Decode the URL-encoded and unescape HTML entities of body\n\tbody = stringDeUnescape(body)\n\n\t// Iterate over the filters in the CommonWebAttack data stored in the t.threat.cwa.Filters field\n\tfor _, filter := range t.threat.cwa.Filters {\n\t\t// Initialize a variable to track whether a match is found\n\t\tvar match bool\n\n\t\t// Check the type of the filter's pattern\n\t\tswitch pattern := filter.pattern.(type) {\n\t\tcase *regexp.Regexp: // If the pattern is a regex\n\t\t\tmatch = pattern.MatchString(uri) || pattern.MatchString(body)\n\t\tcase *pcre.Matcher: // If the pattern is a PCRE expr\n\t\t\tmatch = pattern.MatchString(uri, 0) || pattern.MatchString(body, 0)\n\t\tdefault: // If the pattern is of an unknown type, skip to the next iteration\n\t\t\tcontinue\n\t\t}\n\n\t\t// If the pattern matches the request URI or body, return an error indicating a common web attack has been detected\n\t\tif match {\n\t\t\treturn errors.New(filter.Description)\n\t\t}\n\t}\n\n\t// Return nil if no match is found\n\treturn nil\n}\n\n// checkCVE checks the request against a set of templates to see if it matches a known\n// Common Vulnerabilities and Exposures (CVE) threat.\n// It takes a pointer to an HTTP request as an input and returns an error if the request\n// matches a known threat. Otherwise, it returns nil.\nfunc (t *Teler) checkCVE(r *http.Request) error {\n\t// data is the set of templates to check against.\n\tcveData := t.threat.cve\n\n\t// kind is the type of template to check (either \"path\" or \"raw\").\n\tvar kind string\n\n\t// requestParams is a map that stores the query parameters of the request URI and\n\t// iterate over the query parameters of the request URI and add them to the map.\n\trequestParams := make(map[string]string)\n\tfor q, v := range r.URL.Query() {\n\t\trequestParams[q] = v[0]\n\t}\n\n\t// Iterate over the templates in the data set.\n\tfor _, cveTemplate := range cveData.GetArray(\"templates\") {\n\t\t// ID is the current CVE ID of the templates\n\t\tcveID := string(cveTemplate.GetStringBytes(\"id\"))\n\n\t\t// Iterate over the requests in the template.\n\t\tfor _, request := range cveTemplate.GetArray(\"requests\") {\n\t\t\t// Determine the kind of template (either \"path\" or \"raw\").\n\t\t\tswitch {\n\t\t\tcase len(request.GetArray(\"path\")) > 0:\n\t\t\t\tkind = \"path\"\n\t\t\tcase len(request.GetArray(\"raw\")) > 0:\n\t\t\t\tkind = \"raw\"\n\t\t\t}\n\n\t\t\t// If the template is a \"path\" type and the request method doesn't match, skip this template.\n\t\t\tif kind == \"path\" && string(request.GetStringBytes(\"method\")) != r.Method {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Iterate over the CVE URLs\n\t\t\tfor _, cve := range cveURL[cveID] {\n\t\t\t\t// If the CVE path is empty or contains only a single character, skip this CVE URL.\n\t\t\t\tif len(cve.Path) <= 1 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// If the request path doesn't match the CVE path, skip this CVE URL.\n\t\t\t\tif r.URL.Path != cve.Path {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// diffParams is a map that stores the query parameters of the CVE URI and iterate over the\n\t\t\t\t// query parameters of the CVE URI and add them to the diffParams map.\n\t\t\t\tdiffParams := make(map[string]string)\n\t\t\t\tfor q, v := range cve.Query() {\n\t\t\t\t\tdiffParams[q] = v[0]\n\t\t\t\t}\n\n\t\t\t\t// allParamsMatch is a flag that indicates whether all the query parameters in the CVE URI are\n\t\t\t\t// present in the request URI and iterate over the query parameters of the CVE URI.\n\t\t\t\tallParamsMatch := true\n\t\t\t\tfor q, v := range diffParams {\n\t\t\t\t\t// If a query parameter in the CVE URI is not present in the request URI,\n\t\t\t\t\t// set allParamsMatch to false and break out of the loop.\n\t\t\t\t\tif requestParams[q] != v {\n\t\t\t\t\t\tallParamsMatch = false\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If all the query parameters in the CVE URI are present in the request URI, return an error of CVE ID.\n\t\t\t\tif allParamsMatch {\n\t\t\t\t\treturn errors.New(cveID)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return nil if the request doesn't match any known threat.\n\treturn nil\n}\n\n// checkBadIPAddress checks if the client IP address is in the BadIPAddress index.\n// It returns an error if the client IP address is found in the index, indicating a bad IP address.\n// Otherwise, it returns nil.\nfunc (t *Teler) checkBadIPAddress(r *http.Request) error {\n\t// Get the client's IP address\n\tclientIP := getClientIP(r)\n\n\t// Check if the client IP address is in BadIPAddress index\n\tif t.inThreatIndex(threat.BadIPAddress, clientIP) {\n\t\t// Return an error indicating a bad IP address has been detected\n\t\treturn errors.New(\"bad IP address\")\n\t}\n\n\t// Return nil if the remote address is not found in the index\n\treturn nil\n}\n\n// checkBadReferrer checks if the request referer header is from a known bad referer.\n// It does this by parsing the referer URL, extracting the hostname, and then finding the effective top-level domain plus one.\n// The resulting domain is then checked against the BadReferrer index in the threat struct.\n// If the domain is found in the index, an error indicating a bad HTTP referer is returned.\n// Otherwise, nil is returned.\nfunc (t *Teler) checkBadReferrer(r *http.Request) error {\n\t// Parse the request referer URL\n\tref, err := url.Parse(r.Referer())\n\tif err != nil {\n\t\t// If there is an error parsing the URL, return nil\n\t\t// TODO: What should we do so as not to stop the threat analysis chain from analyzeRequest?\n\t\treturn nil\n\t}\n\n\t// Extract the effective top-level domain plus one from the hostname of the referer URL\n\teTLD1, err := publicsuffix.EffectiveTLDPlusOne(ref.Hostname())\n\tif err != nil {\n\t\t// If there is an error extracting the effective top-level domain plus one, return nil\n\t\t// TODO: What should we do so as not to stop the threat analysis chain from analyzeRequest?\n\t\treturn nil\n\t}\n\n\t// Check if the root domain of request referer header is in the BadReferrer index\n\tif t.inThreatIndex(threat.BadReferrer, eTLD1) {\n\t\t// If the domain is found in the index, return an error indicating a bad HTTP referer\n\t\treturn errors.New(\"bad HTTP referer\")\n\t}\n\n\t// Return nil if no match is found in the BadReferrer index\n\treturn nil\n}\n\n// checkBadCrawler checks the request for bad crawler activity.\n// It retrieves the User-Agent from the request and iterates over\n// the compiled regular expressions in the badCrawler field of the threat struct.\n// If any of the regular expressions match the User-Agent,\n// it returns an error with the message \"bad crawler\".\n// If the User-Agent is empty or no regular expressions match,\n// it returns nil.\nfunc (t *Teler) checkBadCrawler(r *http.Request) error {\n\t// Retrieve the User-Agent from the request\n\tua := r.UserAgent()\n\n\t// Do not process the check if User-Agent is empty\n\tif ua == \"\" {\n\t\treturn nil\n\t}\n\n\t// Iterate over BadCrawler compiled patterns and do the check\n\tfor _, pattern := range t.threat.badCrawler {\n\t\t// Initialize a variable to track whether a match is found\n\t\tvar match bool\n\n\t\t// Check the type of the pattern\n\t\tswitch p := pattern.(type) {\n\t\tcase *regexp.Regexp: // If the pattern is a regex\n\t\t\tmatch = p.MatchString(ua)\n\t\tcase *pcre.Matcher: // If the pattern is a PCRE expr\n\t\t\tmatch = p.MatchString(ua, 0)\n\t\tdefault: // If the pattern is of an unknown type, skip to the next iteration\n\t\t\tcontinue\n\t\t}\n\n\t\t// Check if the pattern is not nil and matches the User-Agent\n\t\tif match {\n\t\t\treturn errors.New(\"bad crawler\")\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// checkDirectoryBruteforce checks the request for a directory bruteforce attack.\n// It extracts the file extension from the request path, creates a regex pattern\n// that matches the entire request path, and replaces any instances of .%EXT% in\n// the directory bruteforce data with the file extension. It then checks if the\n// pattern matches the data using regexp.MatchString. If a match is found, it\n// returns an error indicating a directory bruteforce attack has been detected.\n// If no match is found or there was an error during the regex matching process,\n// it returns nil.\nfunc (t *Teler) checkDirectoryBruteforce(r *http.Request) error {\n\t// Extract the file extension from the request path and if\n\t// file extension is empty string, do not process the check\n\text := filepath.Ext(r.URL.Path)\n\tif ext == \"\" {\n\t\treturn nil\n\t}\n\n\t// Trim the leading slash from the request path, and if path\n\t// is empty string after the trim, do not process the check\n\tpath := strings.TrimLeft(r.URL.Path, \"/\")\n\tif path == \"\" {\n\t\treturn nil\n\t}\n\n\t// Create a regex pattern that matches the entire request path\n\tpattern := fmt.Sprintf(\"(?m)^%s$\", regexp.QuoteMeta(path))\n\n\t// Replace any instances of .%EXT% in the directory bruteforce data with the file extension\n\tdata := strings.ReplaceAll(t.threat.data[threat.DirectoryBruteforce], \".%EXT%\", ext)\n\n\t// Check if the pattern matches the data using regexp.MatchString\n\tmatch, err := regexp.MatchString(pattern, data)\n\tif err != nil {\n\t\t// Return nil if there was an error during the regex matching process\n\t\treturn nil\n\t}\n\n\t// If the pattern matches the data, return an error indicating a directory bruteforce attack has been detected\n\tif match {\n\t\treturn errors.New(\"directory bruteforce\")\n\t}\n\n\t// Return nil if no match is found\n\treturn nil\n}\n", "package teler\n\nimport (\n\t\"fmt\"\n\t\"html\"\n\t\"strings\"\n\n\t\"net/http\"\n\n\t\"github.com/kitabisa/teler-waf/request\"\n\t\"github.com/kitabisa/teler-waf/threat\"\n\t\"gitlab.com/golang-commonmark/mdurl\"\n)\n\n// inThreatIndex checks if the given substring is in specific threat datasets\nfunc (t *Teler) inThreatIndex(kind threat.Threat, substr string) bool {\n\tif i := strings.Index(t.threat.data[kind], substr); i >= 0 {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// inWhitelist checks if the given substring is in whitelist patterns\nfunc (t *Teler) inWhitelist(r *http.Request) bool {\n\turi := toURLDecode(r.URL.RequestURI())\n\theaders := headersToRawString(r.Header)\n\tclientIP := getClientIP(r)\n\n\t// Check the request URI, headers, and client IP address against the whitelist\n\tfor _, pattern := range t.whitelistRegexes {\n\t\tif pattern.MatchString(uri) || pattern.MatchString(headers) || pattern.MatchString(clientIP) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// headersToRawString converts a map of http.Header to\n// multiline string, example:\n// from,\n//\n//\tHeader = map[string][]string{\n//\t\t\"Accept-Encoding\": {\"gzip, deflate\"},\n//\t\t\"Accept-Language\": {\"en-us\"},\n//\t\t\"Foo\": {\"Bar\", \"two\"},\n//\t}\n//\n// to\n//\n//\tHost: example.com\n//\taccept-encoding: gzip, deflate\n//\tAccept-Language: en-us\n//\tfOO: Bar\n//\tfoo: two\nfunc headersToRawString(headers http.Header) string {\n\tvar h strings.Builder\n\n\t// Iterate over the request headers and append each key-value pair to the builder\n\tfor key, values := range headers {\n\t\tfor _, value := range values {\n\t\t\th.WriteString(\n\t\t\t\tfmt.Sprintf(\"%s: %s\\n\", toURLDecode(key), toURLDecode(value)),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Returns the accumulated string of builder\n\treturn h.String()\n}\n\n// unescapeHTML to unescapes any HTML entities, i.e. &aacute;\"\n// unescapes to \"\u00e1\", as does \"&#225;\" and \"&#xE1;\".\nfunc unescapeHTML(s string) string {\n\treturn html.UnescapeString(s)\n}\n\n// toURLDecode decode URL-decoded characters string using mdurl\nfunc toURLDecode(s string) string {\n\treturn mdurl.Decode(s)\n}\n\n// stringDeUnescape to decode URL-decoded characters, and\n// unescapes any HTML entities\nfunc stringDeUnescape(s string) string {\n\ts = toURLDecode(s)\n\treturn unescapeHTML(s)\n}\n\n// isValidMethod check if the given request.Method is valid\nfunc isValidMethod(method request.Method) bool {\n\tswitch method {\n\tcase request.GET, request.HEAD, request.POST, request.PUT, request.PATCH:\n\tcase request.DELETE, request.CONNECT, request.OPTIONS, request.TRACE, request.ALL:\n\tcase \"\":\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// normalizeRawStringReader trim double-quotes of HTTP raw string,\n// replace double-escape of CR and LF, and double it in the end, and\n// returning as pointer of strings.Reader\nfunc normalizeRawStringReader(raw string) *strings.Reader {\n\tvar builder strings.Builder\n\n\traw = strings.Trim(raw, `\"`)\n\traw = strings.ReplaceAll(raw, \"\\\\n\", \"\\n\")\n\traw = strings.ReplaceAll(raw, \"\\\\r\", \"\\r\")\n\tbuilder.WriteString(raw)\n\tbuilder.WriteString(\"\\r\\n\\r\\n\")\n\n\treturn strings.NewReader(builder.String())\n}\n\n// getClientIP to get client IP address from request\nfunc getClientIP(r *http.Request) string {\n\t// Get the client's IP address from the X-Real-Ip header field\n\tclientIP := r.Header.Get(\"X-Real-Ip\")\n\n\t// If the X-Real-Ip header field is not present, try the X-Forwarded-For header field\n\tif clientIP == \"\" {\n\t\tclientIP = r.Header.Get(\"X-Forwarded-For\")\n\t}\n\n\t// If the X-Forwarded-For header field is not present, use the RemoteAddr field\n\tif clientIP == \"\" {\n\t\tclientIP = r.RemoteAddr\n\t}\n\n\t// Returning client IP address\n\treturn clientIP\n}\n"], "filenames": ["README.md", "analyze.go", "utils.go"], "buggy_code_start_loc": [197, 113, 4], "buggy_code_end_loc": [213, 226, 74], "fixing_code_start_loc": [197, 113, 5], "fixing_code_end_loc": [213, 226, 89], "type": "CWE-79", "message": "teler-waf is a Go HTTP middleware that provides teler IDS functionality to protect against web-based attacks. In teler-waf prior to version 0.1.1 is vulnerable to bypassing common web attack rules when a specific HTML entities payload is used. This vulnerability allows an attacker to execute arbitrary JavaScript code on the victim's browser and compromise the security of the web application. The vulnerability exists due to teler-waf failure to properly sanitize and filter HTML entities in user input. An attacker can exploit this vulnerability to bypass common web attack threat rules in teler-waf and launch cross-site scripting (XSS) attacks. The attacker can execute arbitrary JavaScript code on the victim's browser and steal sensitive information, such as login credentials and session tokens, or take control of the victim's browser and perform malicious actions. This issue has been fixed in version 0.1.1.", "other": {"cve": {"id": "CVE-2023-26046", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-02T01:15:11.840", "lastModified": "2023-03-10T04:58:56.760", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "teler-waf is a Go HTTP middleware that provides teler IDS functionality to protect against web-based attacks. In teler-waf prior to version 0.1.1 is vulnerable to bypassing common web attack rules when a specific HTML entities payload is used. This vulnerability allows an attacker to execute arbitrary JavaScript code on the victim's browser and compromise the security of the web application. The vulnerability exists due to teler-waf failure to properly sanitize and filter HTML entities in user input. An attacker can exploit this vulnerability to bypass common web attack threat rules in teler-waf and launch cross-site scripting (XSS) attacks. The attacker can execute arbitrary JavaScript code on the victim's browser and steal sensitive information, such as login credentials and session tokens, or take control of the victim's browser and perform malicious actions. This issue has been fixed in version 0.1.1."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-80"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:kitabisa:teler-waf:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.1.1", "matchCriteriaId": "B024397E-BFE9-4CF5-AC4F-84248CAF9865"}]}]}], "references": [{"url": "https://github.com/kitabisa/teler-waf/commit/d1d49cfddfa3ec2adad962870f14b85cd1aaf739", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/kitabisa/teler-waf/releases/tag/v0.1.1", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/kitabisa/teler-waf/security/advisories/GHSA-9f95-hhg4-pg4f", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/kitabisa/teler-waf/commit/d1d49cfddfa3ec2adad962870f14b85cd1aaf739"}}